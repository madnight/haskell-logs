00:00:05 <copumpkin> sigh, uninformative types!
00:00:15 <copumpkin> what's the point of insertWithKey on IntMap?
00:00:15 <copumpkin> oh, I suppose it might give better sharing
00:07:37 <statusfailed> What's the Control.Lens equivalent of 'focus' here: http://hackage.haskell.org/packages/archive/data-lens-fd/2.0.3/doc/html/Data-Lens.html#v%3afocus ?
00:07:51 <statusfailed> I found %%= but it doesn't  seem to be exactly the same
00:07:54 <edwardk> zoom
00:08:06 <statusfailed> ooh
00:08:14 <edwardk> zoom is focus on steroids
00:08:18 <statusfailed> scarier types :p
00:08:38 <statusfailed> awesome, thanks :)
00:08:40 <edwardk> it can edit state way down in a monad transformer stack, and it can be used to get monoidal summaries of traversals
00:08:48 <edwardk> so it is a bit more complex ;)
00:08:53 <statusfailed> I'll be honest, I didn't follow that at all :p
00:09:02 <edwardk> you know how to use focus?
00:09:26 <statusfailed> I know what I want it for- it basically just transforms an s-stateful computation into an s'-stateful one
00:09:30 <statusfailed> er.
00:09:31 <shachaf> edwardk: Well, zoom just doubles every type, right?
00:09:35 <shachaf> m n, s t, etc.
00:09:41 <shachaf> So it's more like focus on stereoids.
00:09:50 <edwardk> shachaf: *groan*
00:10:00 <statusfailed> :D
00:10:13 <edwardk> focus wasn't built with a class originally, and even in its current classy form, isn't as classy as zoom ;)
00:10:46 <edwardk> the class there was taken from an early version of lens. (if he pushed it out)
00:10:52 <statusfailed> Is there a tutorial on Control.Lens? I'm not really that familiar with lots of the base classes
00:11:13 <edwardk> there is a wiki that has some tutorial-ish material in it
00:11:22 <statusfailed> on the github?
00:11:23 <edwardk> github.com/ekmett/lens/wiki
00:11:26 <edwardk> yeah
00:11:32 <shachaf> I should really write something.
00:11:36 <edwardk> that doesn't cover zoom though
00:11:49 <edwardk> :t zoom _1
00:11:51 <lambdabot> (Functor (k c), Zoom m n k s t, Field1 t t s s) => m c -> n c
00:11:54 <statusfailed> that's ok, I think I basically get it
00:12:10 <statusfailed> I have some stateful computation on Ints and I want to use it on an object containing ints
00:12:14 <statusfailed> such that the correct field is modified
00:12:23 <edwardk> that takes a state action that knows how to work with some state s' and gives you one you can run in (s, t)
00:12:26 <statusfailed> but zoom is totes more generalbeans
00:12:34 <edwardk> :t zoom both
00:12:36 <lambdabot> (Applicative (k c), Zoom m n k s (s, s)) => m c -> n c
00:12:41 <edwardk> that is where it gets interesting
00:12:52 <statusfailed> oooh
00:13:09 <statusfailed> oh and I can compose two lenses to be a traversal on two fields?
00:13:14 <statusfailed> (is that what traversals are?)
00:13:25 <edwardk> zoom both takes a state action that returns a monoidal result, and runs it over both halves of the pair that is the state, and gives you the monoidal summary of the answer.
00:13:55 <edwardk> traversals are like that, but you have to define the traversal all at once right now, we don't have a 'run this lens and then that lens'. the lenses would have to not overlap, and we can't check that side-condition
00:14:15 <statusfailed> ah ok
00:14:17 <edwardk> _2 f (a,b) = (,) a <$> f b  -- is how we can define the lens for the second member of a pair
00:14:29 <edwardk> both f (a,b) = (,) <$> f a <*> f b -- defines the traversal of both
00:14:55 <edwardk> that demands an applicative of its argument, while _2 only required a functor, it never used (<*>) or pure
00:15:16 <yaw> Has anyone here read this? http://www.haskellforall.com/2012/05/scrap-your-type-classes.html
00:15:33 <edwardk> as a result, zoom _1 winds up demanding nothing of the result type of your state, while, zoom both requires the monoid since it needs the monoid to get an applicative way down deep in some code i have
00:16:19 <edwardk> yaw: it was a fairly common well known idiom years before that article
00:16:21 <statusfailed> Right
00:16:24 <statusfailed> I think I grokked that!
00:16:32 <statusfailed> the monoid requrement was confusing me
00:16:52 <edwardk> it only needs a monoid when you zoom in on a traversal.
00:17:12 <edwardk> because it has to update multiple parts of the state. so the only thing it could do is run your action focused in on each in turn, and glue together the answers ;)
00:17:15 <yaw> edwardk: fair enough, i was wondering what people's general opinion on the matter is
00:17:18 <shachaf> edwardk: Wasn't it a well-known idiom from the first time they implemented type classes?
00:17:27 <shachaf> What with that being what they turn into and all.
00:17:33 <edwardk> shachaf: yes. so 1990ish
00:17:56 <shachaf> So forever.
00:18:03 <statusfailed> edwardk: thanks, that really helped :D
00:18:18 <edwardk> yaw: i think i have written enough scala to believe that it is a terrible idea in practice ;)
00:18:48 <edwardk> yaw: it _occasionally_ is useful to pass around a packet of related functions like that to work around haskell 98, etc.
00:19:09 <edwardk> but the hatred of newtypes that drives it is somewhat irrational.
00:19:36 <yaw> interesting comment, i always thought scala's approach was pretty nifty
00:19:40 <yaw> but i haven't used it much
00:20:28 <yaw> what makes it a terrible idea? (if you can be bothered explaining :P - in case it's a long story)
00:20:44 <shachaf> Records of values (which may or may not be functions) are a great idiom.
00:21:19 <shachaf> In most cases where you'd use it in Haskell where you might also use type classes, there's fairly clearly one solution or the other that's better.
00:23:23 <yaw> thanks, interesting to hear that thought
00:37:50 <gnomeasn> hello there
00:43:51 <kuznero> Hi All!
00:44:34 <kuznero> Who knows how do I make haskell mode in vim to work with "import Paths_prj (version)"?
00:46:45 <Ralith> @hoogle m a -> (a -> m b) -> m (a, b)
00:46:46 <lambdabot> No results found
00:46:53 <Ralith> @hoogle Monad m => m a -> (a -> m b) -> m (a, b)
00:46:54 <lambdabot> No results found
00:46:56 <Ralith> aw
00:47:10 <Ralith> :t strong
00:47:11 <lambdabot>     Not in scope: `strong'
00:47:12 <lambdabot>     Perhaps you meant one of these:
00:47:12 <lambdabot>       `strMsg' (imported from Control.Monad.Error),
00:47:15 <Ralith> blah.
00:47:25 <Ralith> oy shachaf
00:47:29 <Ralith> what am I looking for
00:47:55 <kuznero> Who knows how do I make haskell mode in vim to work with "import Paths_prj (version)"?
00:48:18 <shachaf> @ty liftM . ap (,)
00:48:19 <lambdabot> Monad m => (a1 -> a) -> m a1 -> m (a1, a)
00:48:39 <Ralith> geez shachaf you forgot flip
00:48:41 <Ralith> you have failed me
00:49:06 <shachaf> Ralith: The type I gave you is superior.
00:49:37 <Ralith> wait hold on
00:49:46 <Ralith> that isn't even what I asked for >:O
00:50:14 <Ralith> the hof was monadic
00:50:20 <shachaf> Oh.
00:50:27 <shachaf> Well, uh, y'know.
00:50:36 <shachaf> Add a join or something.
00:50:49 <Ralith> :P
00:51:05 <shachaf> @ty \m f -> m >>= (\x -> f x >>= (\y -> return (x, y)))
00:51:07 <lambdabot> Monad m => m t -> (t -> m t1) -> m (t, t1)
00:51:27 <Ralith> where's the fun in using functions not composed out of elementary combinators
00:52:24 <shachaf> @pl \f -> (>>= liftM (flip (,) y) . f)
00:52:25 <lambdabot> (=<<) . (fmap (flip (,) y) .)
00:52:28 <shachaf> There you go.
00:52:33 <Ralith> welp
00:52:36 <shachaf> hi twanvl_
00:52:45 <statusfailed> > runState (zoom both $ modify (+1) >> gets Sum) (0, 0)
00:52:48 <lambdabot>   (Sum {getSum = 2},(1,1))
00:52:51 <statusfailed> woo :D
00:53:05 <shachaf> twanvl_: You wrote the original Derive{Functor,Foldable,Traversable} code, right?
00:53:51 <twanvl_> shachaf: yes
00:54:17 <shachaf> twanvl_: Do you know why it eta-expands the function at each iteration?
00:54:39 <shachaf> As in foldr f z (Cons x xs) = f x (foldr (\a b -> f a b) z xs)
00:55:05 <shachaf> It looks like it goes to a bit of trouble to do that so I'm wondering whether there's a reason.
00:55:18 <kuznero> Who knows how do I make haskell mode in vim to work with "import Paths_prj (version)"?
00:55:32 <kuznero> (last attempt)
00:55:34 <kuznero> :)
00:57:10 <deus_rex> kuznero: what do you mean?
00:57:18 <twanvl_> shachaf: I don't remember exactly why, but iirc it is for consistency. The derived foldr for parts of the type has two 'holes', and they need to be filled
00:57:20 <dsantiago> If I have a Data.Set of strings, is there any way I can call isPrefixOf against a ByteString? Do I need to convert one to the other?
00:58:21 <shachaf> twanvl_: Well, is there a reason you couldn't pass f recursively instead of eta-expanded f?
00:58:26 <kuznero> deus_rex: I'm using haskell mode in vim to code haskell projects. And Im using this unusual import Paths_... (version) to get information about package version (from cabal) from within the code. Which does not work in conjunction with haskell mode for vim
00:58:41 <shachaf> (The code as it is leads to quadratic-time behavior on Functor/Foldable/Traversable instances.)
00:59:02 <kuznero> deus_rex: here is what I get in :copen - Main.hs|9 col 8 error|  Could not find module `Paths_integra' Use -v to see a list of the files searched for.
00:59:29 <twanvl_> shachaf: the "f a b" here might not be the literal f, it could also be something like "foldr f b a"
01:00:33 <shachaf> twanvl_: Oh, you mean if you encounter a different Foldable instance?
01:01:34 <shachaf> (The issue involved here is http://hackage.haskell.org/trac/ghc/ticket/7436 )
01:03:08 <deus_rex> kuznero: does it compile from the terminal, just running ghc on it?
01:03:29 <twanvl_> the real issue is that (\a b -> f a b) performs so much worse
01:03:36 <deus_rex> (i have to admit i'm barely competent in vim, a haskell newbie, and just installed haskellmode-vim two days ago :))
01:04:32 <kuznero> deus_rex: nope, it does not. But it works with cabal configure/build
01:04:33 <shachaf> twanvl_: Well, it would require some cleverness on the part of the compiler to fix that, wouldn't it?
01:05:56 <kuznero> deus_rex: So, I guess that is the answer pretty much - if haskell mode is built on top of ghc (which is the case) then it does not now a thing about cabal infrastructure most likely :(
01:06:12 <kuznero> Ok, then I will just mock this call for a while... :(
01:06:30 <Ralith> shachaf: fmap ((,) x) (f x)
01:06:41 <Ralith> shachaf: that one really should have been obvious >.<
01:06:45 <shapr> SHAZAM!
01:06:45 <shachaf> @ty \f x -> fmap ((,) x) (f x)
01:06:47 <lambdabot> Functor f => (a1 -> f a) -> a1 -> f (a1, a)
01:06:55 <ski> hm, this reminds me of writing a CPS-translation that correctly eta-reduces continuations for tail-calls (or rather, abstains from eta-expanding them)
01:07:15 <danr> @unpl fmap (,) <$> f
01:07:15 <lambdabot> ((fmap (,)) <$> f)
01:07:44 <deus_rex> kuznero: you may need to mess with :GHCStaticOptions
01:08:10 <deus_rex> this thread has a solution for people using ghc-mod, maybe it could be applied to haskellmode-vim as well? http://comments.gmane.org/gmane.comp.lang.haskell.cafe/99700
01:08:28 <Ralith> iow liftM2 fmap (,)
01:08:34 <kuznero> Let me check, thanks!
01:08:54 <deus_rex> it seems :GHCStaticOptions changes the ghc options for the current buffer, and there's another option you can set to add some defaults
01:12:02 <bitonic> edwardk:
01:12:11 <edwardk> heya
01:12:30 <bitonic> oops.  anyway. edwardk: one of the annoyances with bound is that writing terms manually when you need is very verbose
01:12:47 <edwardk> bitonic: thats why i recommend making smart constructors
01:12:49 <bitonic> I've got a lot of `toScope' and `fmap F' and stuff like this
01:12:51 <bitonic> yeah
01:13:01 * hackagebot network-transport 0.3.0.1 - Network abstraction layer  http://hackage.haskell.org/package/network-transport-0.3.0.1 (EdskoDeVries)
01:13:17 <bitonic> but then if you have smart constructors you have to come up with fresh names
01:13:20 <edwardk> did you see the simple examples?
01:13:23 <edwardk> yeah
01:13:25 <edwardk> there is that
01:13:25 <bitonic> yes yes
01:13:55 <edwardk> i tend to build my examples in Exp String or something ad then close them and just use them polymorphically
01:14:19 <bitonic> but I am typechecking now and I just have to form some types to compare - and I'd like to avoid having to generate names.  I think I'll write smart constructors for de bruijin terms, which would already be much better
01:14:32 <bitonic> and there is also the issue that I have to use existing terms while forming the new term manually
01:15:15 <bitonic> tbh the only type checking rule that comes out really ugly is the eliminator for W types, where I need to write down quite a long type
01:15:47 <edwardk> bitonic: you might be better off picking dolio's brain about that one. since he's had more relevant experience with bound
01:16:06 <edwardk> my code is usually structured differently and doing different things with it
01:16:37 <bitonic> edwardk: I'll see.  btw, the TT I'm writing is here: <https://github.com/bitonic/mfixed>, I'm only missing W types and prop. equality and then it's a quite complete intensional type theory
01:17:30 <bitonic> if I have time I'll clean it up and write a tutorial about it
01:18:02 * hackagebot rank1dynamic 0.1.0.2 - Like Data.Dynamic/Data.Typeable but with support for rank-1 polymorphic types  http://hackage.haskell.org/package/rank1dynamic-0.1.0.2 (EdskoDeVries)
01:18:25 <edwardk> yeah i'd definitely ask dolio if he has any suggestions for doing what you need better
01:18:41 <edwardk> since in my experience i'm rarely plumbing B's and F's in by hand
01:20:48 <bitonic> edwardk: I'm sure some better combinators can be imagined - but AFAICT dolio didn't have the types I have, at least in the UPTS thing
01:20:57 <edwardk> probably not
01:20:59 <bitonic> maybe he did other stuff outside that
01:21:01 <edwardk> er definitely not
01:21:27 <edwardk> i just mean that he's at least seem something much closer to what you are doing than i have ;)
01:21:35 <edwardk> and he's a pretty smart guy besides ;)
01:22:27 <bitonic> so I don't think he stumbled on the same problems, because again the only annoying thing is when I have to check that something has the type "dependent function with 4 arguments whose types are related to other types outside" :P
01:23:02 * hackagebot distributed-static 0.2.1.1 - Compositional, type-safe, polymorphic static values and closures  http://hackage.haskell.org/package/distributed-static-0.2.1.1 (EdskoDeVries)
01:23:08 <edwardk> fair nuff
01:23:27 <edwardk> i look forward to your elegant solution ;)
01:23:35 <bitonic> but anyhow, you saved me a lot of time ehe
01:29:19 <statusfailed> What's wrongwith this type annotation?
01:29:22 <statusfailed> > zoom _1 (modify (+1)) :: MonadState (Int, Int) m => m ()
01:29:24 <lambdabot>   No instance for (GHC.Base.Functor (k0 ()))
01:29:24 <lambdabot>    arising from a use of `Contro...
01:29:39 <edwardk> :t zoom _1 (modify (+1))
01:29:41 <lambdabot> (Functor (k ()), Num s, Zoom m n k s t, Field1 t t s s) => n ()
01:30:05 <edwardk> you can't use anything MonadState (Int, Int) m
01:30:07 <statusfailed> I just want to make mine less general for clarity (just to help me understand)
01:30:16 <edwardk> you can only use particular MonadState instances.
01:30:22 <statusfailed> ah ok
01:30:26 <edwardk> e.g. State (Int, Int) a
01:30:34 <statusfailed> doesn't that make it awkward to use with stacks?
01:30:35 <edwardk> because i can't do the zoom rewrite just knowing that you have MonadState
01:30:42 <edwardk> you can keep the zoom signature in there
01:30:54 <edwardk> you can also use any particular monad state stack with it with the whole thing vanishing
01:31:09 <edwardk> you couldn't even _write_ it before with stacks ,so its a compromise ;)
01:31:15 <statusfailed> haha
01:31:23 <statusfailed> ok, fair enough :P
01:31:43 <statusfailed> I'll leave it as is then :)
01:31:45 <statusfailed> cheers
01:33:02 * hackagebot distributed-process 0.4.1 - Cloud Haskell: Erlang-style concurrency in Haskell  http://hackage.haskell.org/package/distributed-process-0.4.1 (EdskoDeVries)
01:39:42 <edwardk> partsOf folded  :: (Foldable f1, Gettable f) => LensLike f (f1 a) (f1 a) [a] [a]
01:39:44 <edwardk> woot!
01:42:33 <hiptobecubic> edwardk, go on...?
01:43:02 <edwardk> > [1..10]^.partsOf traverse
01:43:05 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
01:43:06 <edwardk> > [1..10]^.partsOf folded
01:43:09 <lambdabot>   No instance for (Control.Lens.Internal.Gettable
01:43:09 <lambdabot>                     (Contro...
01:43:13 <edwardk> that didn't use to work
01:43:17 <edwardk> it does in HEAD
01:43:58 <hiptobecubic> hm
01:58:03 * hackagebot lens 3.4 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.4 (EdwardKmett)
01:59:39 <atriq> Ooh, cool
01:59:44 <atriq> New lens package
01:59:45 <atriq> To cabal!
01:59:52 <edwardk> Cale: I released lens 3.4, which switches over to &, and provides a number of structural improvements, and deals a lot better with infinities.
02:00:26 <atriq> edwardk, can you do a zipper on an integer now, or is that still mathematically impossible?
02:00:44 <edwardk> still impossible to do an infinite number of operations in finite time
02:01:00 <edwardk> when i fix that, my universe similator should let me do well in the stock market
02:01:08 <edwardk> er simulator
02:01:27 <atriq> A similator is similar to a simulator
02:02:12 <atriq> In other news, I HAVE BEGUN TO FIX MY PERSONAL CABAL HELL, ONE PACKAGE AT A TIME
02:02:14 <atriq> HAHAHAHA!
02:03:02 <atriq> In other words, I got someone to fix authenticate-oauth
02:03:16 <hiptobecubic> edwardk, so what is partsOf doing?  loks like 'id' to me ;)
02:03:19 <hiptobecubic> looks*
02:03:23 <atriq> :t partsOf
02:03:25 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
02:03:34 <hiptobecubic> atriq, right. I got that far as well
02:03:51 <edwardk> partsOf takes any fold or traversal and turns it into a getter or lens that takes a list and accepts a list back
02:04:01 <edwardk> where you are encouraged to return a list of the same length you were given
02:04:08 <edwardk> because otherwise its an illegal lens ;)
02:04:29 <atriq> :t partsOf traverseArray
02:04:31 <lambdabot> Not in scope: `traverseArray'
02:04:45 <edwardk> > partsOf (traverse.filtered isAlpha) %~ reverse $ "this is kinda !@# cool"
02:04:48 <lambdabot>   "looc ad niksi !@# siht"
02:05:17 <atriq> (Functor f, Ix i, IArray arr b) => LensLike f (arr i b) (arr i b) [b] [b]
02:05:19 <hiptobecubic> weird
02:05:19 <aleator> wat?
02:05:40 <atriq> Or SimpleLens (arr i b) [b]
02:05:45 <hiptobecubic> ah i see
02:05:54 <edwardk> i told it to take all the alpha characters in that and turn them around
02:06:04 <hiptobecubic> yes
02:06:11 <edwardk> that was a bit of an abuse because filtered shouldn't be used like that
02:06:16 <atriq> Gets dangerously close to swearing
02:06:21 <edwardk> > (1,2)^.partsOf both
02:06:22 <hiptobecubic> no?
02:06:24 <lambdabot>   [1,2]
02:06:43 <edwardk> > (1,2) % partsOf both %~ reverse
02:06:45 <lambdabot>   (2,1)
02:07:25 <edwardk> ^. partsOf (foo)    should work like ^.. foo
02:07:33 <edwardk> but you can write back to it
02:07:56 <hiptobecubic> this thing is...
02:08:03 * hackagebot distributed-process-simplelocalnet 0.2.0.8 - Simple zero-configuration backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-simplelocalnet-0.2.0.8 (EdskoDeVries)
02:09:22 <hiptobecubic> > (1,2) % partsOf both %~ tail
02:09:24 <lambdabot>   (2,2)
02:09:31 <edwardk> > ("hello","hiptobecubic") & partsOf both %~ length
02:09:33 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
02:09:34 <lambdabot>              with actual ...
02:09:38 <edwardk> > ("hello","hiptobecubic") & unsafePartsOf both %~ length
02:09:40 <lambdabot>   Couldn't match expected type `[b0]'
02:09:40 <lambdabot>              with actual type `GHC.Type...
02:10:01 <edwardk> > ("hello","hiptobecubic") % unsafePartsOf both %~ length
02:10:04 <lambdabot>   Couldn't match expected type `[b0]'
02:10:04 <lambdabot>              with actual type `GHC.Type...
02:10:17 <edwardk> interesting, not sure what i screwed up there
02:10:24 <hiptobecubic> me either. looks right?
02:10:47 <edwardk> > ("hello","hiptobecubic") % unsafePartsOf both.traverse %~ length
02:10:50 <lambdabot>   (5,12)
02:10:52 <hiptobecubic> aha
02:11:06 <hiptobecubic> why was traverse needed?
02:11:09 <edwardk> > ("hello","hiptobecubic") % both %~ length
02:11:12 <lambdabot>   (5,12)
02:11:22 <edwardk> because it was giving me back a list of lists
02:11:32 <edwardk> > ("hello","hiptobecubic") % er a list of strings
02:11:34 <lambdabot>   <hint>:1:38: parse error on input `of'
02:11:36 <hiptobecubic> list of lists of...? char?
02:11:38 <edwardk> but it couldn't take back a number
02:11:43 <edwardk> yep
02:14:04 <hiptobecubic> so it needs to return the same type then?
02:14:13 <hiptobecubic> you can just change the entire list to a new type?
02:14:15 <hiptobecubic> can't*
02:14:16 <edwardk> :t partsOf
02:14:18 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
02:14:24 <hiptobecubic> ah
02:14:29 <edwardk> that needs to go from one list of the same type to another of the same
02:14:29 <hiptobecubic> wait, what's t
02:14:32 <edwardk> :t unsafePartsOf
02:14:33 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a b) s t a b -> ([a] -> f [b]) -> s -> f t
02:14:38 <edwardk> that can change the list type
02:15:15 <edwardk> ust because the type of the field doesn't change doesn't mean that the outside type stays the same.
02:15:27 <edwardk> consider editing the 'a' in Const a b = Const a
02:15:27 <shachaf> @ty \l -> unsafePartsOf l.traverse
02:15:29 <lambdabot> Applicative f => LensLike (Control.Lens.Internal.Bazaar a b) s t a b -> (a -> f b) -> s -> f t
02:16:10 <hiptobecubic> :t traverse
02:16:11 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
02:16:45 <edwardk> the new one looks like:
02:17:14 <hiptobecubic> > traverse Just (Just 5)
02:17:15 <edwardk> unsafePartsOf ?l . traverse :: (Applicative f, ?l::LensLike (EvilBazaar f a b) s t a b) =>     (a -> f b) -> s -> f t
02:17:15 <lambdabot>   Just (Just 5)
02:17:37 <hiptobecubic> what is "?l"
02:17:50 <hiptobecubic> > traverse Just [1..5]
02:17:52 <lambdabot>   Just [1,2,3,4,5]
02:17:56 <edwardk> its an implicit param, its a nice way of saying 'figure out a type that can go here'
02:18:03 <edwardk> :t [(),?a]
02:18:05 <lambdabot> (?a::()) => [()]
02:18:16 <edwardk> :t ([(),?a], ?b)
02:18:17 <Yuu-chan> Hello
02:18:18 <lambdabot> (?a::(), ?b::t) => ([()], t)
02:18:42 <hiptobecubic> oh
02:18:42 <Yuu-chan> I'm curious of an automatic parallelism
02:18:45 <edwardk> it can be used for passing params, and there are ways to read them, but its often used as a placeholder hack
02:18:53 <hiptobecubic> i see
02:19:23 <hiptobecubic> > traverse (replicate 2) [1..5]
02:19:25 <lambdabot>   [[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1,2,3,4,5],[1...
02:19:37 <hiptobecubic> > traverse (replicate 2) [1..2]
02:19:39 <lambdabot>   [[1,2],[1,2],[1,2],[1,2]]
02:19:52 <hiptobecubic> wat
02:19:53 <Yuu-chan> If we have f g h, and both g and h are pure, could the compile compute them in parallel, without explicit `par`?
02:20:02 <Yuu-chan> *the compiler
02:20:11 <shachaf> It could.
02:20:13 <hiptobecubic> Yuu-chan, in theory yes.
02:20:21 <shachaf> `par` doesn't change semantics.
02:20:32 <shachaf> But it turns out to be pretty tricky to figure out where to do it.
02:20:55 <hiptobecubic> Yuu-chan, in practice it turns out pretty badly because the compiler doesn't know how expensive things and the overhead of doing it in parallel is not negligible.
02:21:00 <hiptobecubic> things are*
02:21:04 <edwardk> Yuu-chan: if your compiler was omniscient and smarter than anything we have access to, yes
02:22:10 <edwardk> some early haskells did this. parallel haskell used to spawn each thunk as a thread or some such which helped stretch the statement that our semantics are 'non-strict' to the breaking point ;)
02:22:30 <hiptobecubic> that must have been pretty slow
02:22:42 <edwardk> it also predated pesky things like IO
02:23:09 <hiptobecubic> seems like you could just make a hard 'no IO' rule
02:23:51 <Yuu-chan> I see, thank you
02:25:26 <hiptobecubic> My "add `par` as close to main as possible" strategy has served me pretty well
02:25:49 <edwardk> my main trick is abusing speculation
02:25:55 <edwardk> @hackage speculation
02:25:56 <lambdabot> http://hackage.haskell.org/package/speculation
02:27:25 <Yuu-chan> edwardk: could you please show an example?
02:27:40 <hiptobecubic> interesting
02:27:52 <hiptobecubic> edwardk, figures.... this is also from you
02:28:13 <edwardk> Yuu-chan: of speculation?
02:28:20 <Yuu-chan> edwardk: yes
02:28:41 <edwardk> the paper linked to there gives many more compelling examples than i can on irc ;)
02:28:52 <edwardk> http://research.microsoft.com/pubs/118795/pldi026-vaswani.pdf
02:29:28 <edwardk> the major contribution of that package is distilling that 12 page paper into a 1 line haskell program
02:29:39 <hiptobecubic> :D
02:30:28 <edwardk> spec g f a = r `par` if a == g then r else f a where r = f g
02:31:27 <Yuu-chan> @type \g f a = r `par` if a == g then r else f a where r = f g
02:31:29 <edwardk> given a guess, and a function and an actual argument, start running the function on the guess in the background, then check that you guessed right (which will force the actual argument, which we guesstimate will be fairly slow to calculate, e.g. the result from the first stage of a pipeline)
02:31:29 <lambdabot> parse error on input `='
02:31:37 <Yuu-chan> @type \g f a -> r `par` if a == g then r else f a where r = f g
02:31:38 <lambdabot> parse error on input `where'
02:31:50 <Yuu-chan> ...
02:31:52 <edwardk> the where clause is biting you. not valid in a lambda
02:32:01 <edwardk> @type let spec g f a = r `par` if a == g then r else f a where r = f g in spec
02:32:03 <lambdabot> Eq a => a -> (a -> b) -> a -> b
02:33:16 <hiptobecubic> it's such a simple idea
02:33:59 <hiptobecubic> is there a generalized version? instead of with (==) ?
02:34:15 <edwardk> yes
02:34:17 <edwardk> all packaged
02:34:32 <Yuu-chan> hiptobecubic: specBy
02:34:37 <hiptobecubic> aha
02:34:43 <edwardk> there are also tricks it can use to check the tagbits on the argument and avoid guessing, etc. which make it progressively more tricky
02:35:00 <edwardk> specBy assumes your function quotients under that equivalence relation
02:35:13 <edwardk> or that you're willing to say 'meh, close enough'
02:37:00 <hiptobecubic> right
02:37:21 <stacky> is there any way I can write a Functor instance for Data.Tree.Forest as is (i.e. without wrapping it into a newtype)?
02:37:45 <hiptobecubic> ok, enough fun. back to not fun.
02:38:42 <Yuu-chan> stacky: you can use compiler extensions
02:39:05 <stacky> what do I need?
02:39:06 <edwardk> stacky: no
02:39:14 <edwardk> Yuu-chan: doesn't work for forest
02:39:17 <edwardk> which is just a list of trees
02:39:41 <Yuu-chan> Won't FlexibleInstances help?
02:39:41 <edwardk> you can make a setter or traversal for a forest, but not a functor or traversable
02:39:43 <edwardk> no
02:39:50 <edwardk> [Tree a]  -- can't be made a Functor
02:40:07 <Yuu-chan> :k [Tree a]
02:40:08 <edwardk> its got the wtong shape. thats f (g a)   not (f a)
02:40:10 <lambdabot> Not in scope: type variable `a'
02:40:18 <edwardk> er wrong
02:40:41 <edwardk> Tree is a Functor, [] is a Functor.
02:40:51 <shachaf> Compose [] Tree is a Functor
02:41:15 <edwardk> you can make a newtype wrapper, or use Compose, or you can adopt some of my lens craziness, but thats about it ;)
02:41:18 <alpounet> <edwardk> some early haskells did this. parallel haskell used to spawn each thunk as a thread or some such which helped stretch the statement that our semantics are 'non-strict' to the breaking point ;) <<< any reference/must-read about this?
02:41:29 <shachaf> You can also make a SEC
02:41:36 <edwardk> alpounet: lennart augustsson's talk. one sec.
02:41:45 <shachaf> Which just means "take fmap and give it its own name rather than putting it in a class"
02:41:52 <edwardk> :t (map.fmap)
02:41:54 <lambdabot> Functor f => (a -> b) -> [f a] -> [f b]
02:42:32 <edwardk> alpounet: https://www.youtube.com/watch?v=hgOzYZDrXL0 talks about it
02:43:49 <stacky> ok, thanks guys
02:43:55 <alpounet> edwardk, oh nice, thanks!
02:53:37 <Yuu-chan> Could somebody explain why it's impossible to declare an instance for a parameterized type synonym?
02:54:08 <Jafet1> Because type synonyms aren't types
02:57:02 <bxx> how can I shadow name from prelude so I can define my function with the same name?
02:57:26 <edwardk> bxx: import Prelude hiding (foo)
02:57:55 <bxx> thanks
03:04:31 <fmap> bxx: you can define your function without hiding prelude imports, you just can't use it :]
03:04:59 <Yuu-chan> fmap: you can, by calling YourModule.yourClashingFunction
03:12:19 <pdxleif> This isn't some kind of joke, is it? https://github.com/ghc/packages-base/blob/master/Data/Monoid.hs#L110
03:12:32 <pdxleif> Wondering about whether to be strict on Unit?
03:13:07 <sopvop> what if you get unit from some huge side-effecting function?
03:13:36 <sopvop> io is strict anyway though
03:13:50 <typoclass> > () `mappend` () -- weird instance
03:13:53 <lambdabot>   ()
03:14:30 <sopvop> ("foo", ()) `mappend` ("bar", ())
03:14:34 <fmap> > undefined `mappend` ()
03:14:35 <lambdabot>   ()
03:14:56 <fmap> you may want to get undefined there
03:15:43 <pdxleif> > (unsafePerformIO $ putStrLn "foo") <> (unsafePerformIO $ putStrLn "bar")
03:15:45 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `unsafePerformIO'
03:16:12 <Yuu-chan> lambdabot: y u no have modules?
03:16:26 <sopvop> lambdabot is safe
03:16:34 <sopvop> warm and fuzzy
03:16:40 <Yuu-chan> Like a monad?
03:16:49 <pdxleif> like a burrito
03:18:05 <sopvop> Like a burrito in a space suit
03:22:46 <kmels> I'm using unsafeCoerce to convert an EpochTime to Double, is that ok? EpochTime being a synonym for CTime (http://hackage.haskell.org/packages/archive/base/latest/doc/html/Foreign-C-Types.html#t:CTime)
03:23:04 <edwardk> pdxleif: no its not a joke, both have performance impacts
03:23:21 <edwardk> one might build up a chain of unnecessary thunks. the other might crash unnecessarily, etc.
03:23:21 <osa1> I'm about to submit my first package to hackage, can anyone point me some nice cabal files to compare my file ? I may be leaving some necessary parts
03:24:08 <dcoutts_> osa1: and also use 'cabal check'
03:24:31 <osa1> dcoutts_: thanks for the tip
03:24:52 <pdxleif> How can forcing unit cause a crash?
03:24:57 <pdxleif> Side-effecty unit?
03:25:22 <dobblego> undefined `mappend` ()
03:26:26 <luite> kmels: realToFrac
03:26:43 <pdxleif> Ah, I guess since the input to mappend for the () instance is ignored anyways, building up thunks doesn't sound like something to worry about?
03:28:45 <kmels> thank you luite
03:30:01 <pdxleif> If something's of type (), I shouldn't even have to evaluate it to know its value is (), but I guess IO or whatever would get skipped, then.
03:30:59 <Ralith> pdxleif: fortunately, values in IO are by definition not of type ()!
03:31:07 <Ralith> it's very convenient.
03:31:58 <Ralith> kmels: no, that's not okay.
03:32:03 <Ralith> kmels: why did you think it might be?
03:33:44 <Yuu-chan> Ralith: is unsafeCoerce similar to C-style cast?
03:33:52 <Ralith> Yuu-chan: no.
03:34:19 <pdxleif> The () at the end of main isn't evaluated either, looks like?  main = putStrLn "Hello" >> return undefined
03:36:32 <ziarkaen> I have:  "type Path = Maybe [Dir]".  I want to define the function "findpath :: (Eq a, Eq Dir) => BTree a -> a -> Path", but I get an error in Hugs: "Illegal Haskell 98 class constraint in type declaratio".  Any ideas?
03:36:52 <shachaf> You can't write Eq Dir in the constraint.
03:36:53 <sopvop> I have Either [a] [b], and want to get  [Either a b], how do I?
03:37:15 <shachaf> ziarkaen: Either there's an instance Eq Dir, in which case you don't need that, or there isn't, in which case it's invalid.
03:37:50 <shachaf> sopvop: foo (Left xs) = map Left xs; foo (Right ys) = map Right ys?
03:38:12 <typoclass> sopvop: not sure if there's a stock function. "map (either Left Right)" possibly?
03:38:26 <atriq> sopvop, "either (map Left) (map Right)" works
03:38:29 <sopvop> why it was so hard for me... must be all the lens and bi-functors and whatnot
03:38:35 <sopvop> thanks everyone
03:39:06 <pdxleif> In "a <- return undefined :: IO ()", a is (), whereas in "let a = undefined :: ()", a is _|_
03:39:24 <shachaf> @ty view chosen . over (traverseLeft.traverse) Left . over (traverseRight.traverse) Right
03:39:26 <lambdabot> Traversable t => Either (t a) (t b) -> t (Either a b)
03:39:32 <shachaf> sopvop: Lensy enough for you?
03:39:46 <shachaf> pdxleif: a is ()?
03:39:53 <sopvop> less lens, less lens!
03:40:30 <Ralith> pdxleif: no, a is undefined.
03:40:33 <Ralith> :D
03:40:55 <pdxleif> Running "a <- return undefined :: IO ()" in GHCI gives me a with a value of ().
03:41:08 <Ralith> what do you think 'undefined' means?
03:41:35 <pdxleif> indeterminate value?
03:42:00 <Ralith> undefined. :P
03:42:10 <shachaf> pdxleif: Not me.
03:42:20 <shachaf> λ> a <- return undefined :: IO ()
03:42:20 <Ralith> (though the standard might not actually specify that)
03:42:20 <shachaf> λ> a
03:42:20 <shachaf> *** Exception: Prelude.undefined
03:42:33 <Ralith> (I was mostly joking)
03:43:08 <Ralith> pdxleif: in general, though, when you read 'undefined value' you should interpret 'value could be anything possible, and a few impossible things'
03:43:59 <Ralith> fortunately this doesn't come up much in haskell.
03:44:39 <pdxleif> shachaf: Ah, you're right, I was merely doing :t a, not actually a.
03:45:15 <shachaf> Ralith: That's not what "undefined" means in Haskell.
03:45:25 <Ralith> shachaf: see above :p
03:45:30 <pdxleif> (return undefined)::IO () doesn't cause any problems in ghci or at the end of main, though - I'm assuming () is merely unevaluated.
03:45:43 <Ralith> pdxleif: are you familiar with lazy evaluation and WHNF?
03:45:48 <shachaf> No real reason to evaluate it.
03:47:11 <pdxleif> Ralith: Vaguely.  I remember spoon evaluating an expression for exceptions, somewhat.
03:48:05 * hackagebot distributed-process-p2p 0.1.1.0 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.1.0 (AlexanderBondarenko)
03:48:14 <Ralith> > isJust (Just $ error "whee")
03:48:15 <lambdabot>   True
03:48:51 <pdxleif> Like say, 1 : _|_ is WHNF, or something?
03:49:08 <shachaf> It is once you evaluate it to WHNF!
03:53:05 * hackagebot http-reverse-proxy 0.1.0.6 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.6 (MichaelSnoyman)
03:55:00 <pdxleif> It's not smart enough to shortcut an undefined tail: foldl1 (<>) (undefined : undefined :: [()])
03:55:14 <pdxleif> But this works: foldl1 (<>) (undefined : undefined : [()]:: [()])
03:55:58 <atriq> Is it bad that I really don't like touching other people's cabal files?
03:56:22 <shachaf> pdxleif: There's no issue of "smart" here.
03:56:37 <shachaf> The meaning of that expression is well defined. Optimziations won't change it.
03:56:44 <sopvop> atriq: You feel dirty after?
03:56:57 <atriq> sopvop, I've never felt comfortable with even trying
03:57:10 <Ralith> atriq: you should at least take them out to dinner first.
03:57:30 <atriq> :P
03:57:41 <atriq> In other news, I've submitted a pull request to aeson-lens
03:58:00 <sopvop> it doesn't count if it doesn't touch
03:59:19 <atriq> It touches a .hs file
04:01:09 <atriq> tanakh_, are you the person to moan about aeson-lens to?
04:01:18 <pdxleif> shachaf: I know that forall (), () `mappappend` () is (), but I guess Haskell's not going to apply that to foldl to shortcut a list of indeterminate length.
04:01:32 <atriq> @src foldl
04:01:33 <lambdabot> foldl f z []     = z
04:01:33 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
04:01:45 <atriq> @src mappend ()
04:01:45 <lambdabot> Source not found. I've seen penguins that can type better than that.
04:01:49 <atriq> @src () mappend
04:01:50 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:02:14 <pdxleif> the mappend instance for () is just mappend () () = ().
04:02:24 <pdxleif> or mappend _ _ = ()
04:02:30 <shachaf> pdxleif: What does forall () mean?
04:02:38 <shachaf> > undefined `mappend` ()
04:02:40 <lambdabot>   ()
04:02:42 <atriq> It's mappend _ _ = (), which makes a difference
04:02:46 <shachaf> > undefined `mappend` undefined :: ()
04:02:48 <lambdabot>   ()
04:02:49 <shachaf> Ah, I see.
04:02:57 <shachaf> > compare undefined (undefined::())
04:03:00 <lambdabot>   *Exception: Prelude.undefined
04:03:01 <shachaf> :-(
04:03:05 * hackagebot blaze-builder-conduit 0.5.0.3 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.5.0.3 (MichaelSnoyman)
04:03:07 * hackagebot network-conduit-tls 0.6.0.3 - Create TLS-aware network code with conduits  http://hackage.haskell.org/package/network-conduit-tls-0.6.0.3 (MichaelSnoyman)
04:03:09 <pdxleif> I guess saying "forall unit" isn't saying much. :J
04:03:27 <shachaf> Well, if you mean forall (x :: ())., that's a different matter.
04:03:27 <typoclass> :t compare
04:03:29 <lambdabot> Ord a => a -> a -> Ordering
04:03:30 <atriq> But foldl doesn't let that come into it
04:03:40 <atriq> @src foldr
04:03:41 <lambdabot> foldr f z []     = z
04:03:41 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
04:03:55 <osa1> hmm I can't run "cabal-dev ghci", does anyone know why ? http://hpaste.org/78047
04:04:08 <atriq> foldr has the same problem
04:04:20 <fmap> osa1: ghc 7.6?
04:04:20 <pdxleif> Yeah, I meant more like forall (x :: ()), x `mappend` x == ()
04:04:26 <typoclass> interesting, 'compare' feels that they're of the same type, otherwise it'd have given a compile error. so at runtime it looks at the values, and barfs
04:04:29 <osa1> fmap: 7.4.1
04:05:01 <atriq> > (fold :: [()] -> ()) undefined
04:05:03 <lambdabot>   Not in scope: `fold'
04:05:03 <lambdabot>  Perhaps you meant one of these:
04:05:03 <lambdabot>    `Data.Foldable.fol...
04:05:10 <atriq> > (Data.Foldable.fold :: [()] -> ()) undefined
04:05:12 <lambdabot>   *Exception: Prelude.undefined
04:05:25 <atriq> Yeah, that has the same problem
04:05:47 <pdxleif> Anyways, folds have to traverse the list to produce an answer... wasn't there some "cofold" or whatever?
04:06:10 <atriq> Nothing on Hayoo called "cofold"
04:06:49 <sopvop> unfold
04:06:59 <atriq> :t unfoldr
04:07:00 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
04:07:15 <atriq> Completely wrong type signature for what you're trying to do
04:08:05 <sopvop> I don't get what you are trying to do
04:08:06 <fmap> cofold takes resulting value and a list and gives folding function?
04:08:09 * hackagebot resourcet 0.4.4 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.4 (MichaelSnoyman)
04:08:11 * hackagebot zlib-conduit 0.5.0.3 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.5.0.3 (MichaelSnoyman)
04:08:12 <sopvop> fold a list of undefines?
04:08:32 <atriq> I'm not sure who's trying to do this
04:08:54 <atriq> I think we may have just gone on a tangent and forgot where we came from
04:09:31 <pdxleif> I'm lost, nevermind me.
04:09:44 <pdxleif> And scanl seems all eager or something.
04:09:56 <pdxleif> It won't even let me do:  head $ scanl1 (<>) (undefined : undefined : undefined : [()])
04:10:35 <atriq> @src scanl1
04:10:36 <lambdabot> scanl1 f (x:xs) =  scanl f x xs
04:10:36 <lambdabot> scanl1 _ []     =  []
04:10:36 <sopvop> > foldMap (const ()) [undefined::()]
04:10:38 <lambdabot>   Not in scope: `foldMap'
04:10:39 <lambdabot>  Perhaps you meant one of these:
04:10:39 <lambdabot>    `Data.Foldable....
04:10:48 <sopvop> > Data.Foldable.foldMap (const ()) [undefined::()]
04:10:50 <lambdabot>   ()
04:10:51 <atriq> @src scan;
04:10:51 <lambdabot> Source not found. You speak an infinite deal of nothing
04:10:53 <atriq> @src scanl
04:10:53 <lambdabot> scanl f q ls = q : case ls of
04:10:53 <lambdabot>     []   -> []
04:10:53 <lambdabot>     x:xs -> scanl f (f q x) xs
04:10:55 <pdxleif> Oh, cool, scanr1 works.
04:11:53 <pdxleif> As long as the list is finite.
04:12:00 <pdxleif> > head $ scanr1 (<>) (undefined : undefined : [()])
04:12:03 <lambdabot>   ()
04:13:06 * hackagebot persistent 1.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.2 (MichaelSnoyman)
04:13:07 <sopvop> > Data.Foldable.foldMap id (undefined:undefined:undefined ::[()])
04:13:08 * hackagebot persistent-mysql 1.0.2 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-1.0.2 (MichaelSnoyman)
04:13:08 <lambdabot>   ()
04:14:03 <pdxleif> Without a single () in sight - woo.
04:15:16 <sopvop> pdxleif: why do you need it anyway?
04:15:43 <pdxleif> I want to be able to produce lots of ()'s from undefineds very quickly!
04:15:51 <sopvop> > Data.Foldable.fold (undefined:undefined:undefined ::[()])
04:15:53 <lambdabot>   ()
04:16:02 <pdxleif> No - just trying to understand the comment about laziness on () in the Data.Monoid instance.
04:16:32 <bxx> is there a convention for local helper functions? fooHelper? just helper?
04:16:37 <atriq> > last (repeat ()) <> last (repeat ())
04:16:38 <pdxleif> foo' ?
04:16:39 <lambdabot>   ()
04:16:41 <sopvop> bxx: go
04:16:55 <sopvop> go is for recursive part actually
04:17:17 <fmap> bxx: what's wrong with f, g, h?
04:17:45 <sopvop> fmap: not enterprisey enough.
04:17:49 <bxx> fmap I usually use those for argument names
04:17:57 <bxx> but nothing wrong with it
04:18:06 * hackagebot persistent-postgresql 1.0.1 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.0.1 (MichaelSnoyman)
04:18:18 <bxx> sopvop you mean for recursive helper functions?
04:18:26 <sopvop> bxx: yup
04:18:51 <osa1> is there a way to give arbitrary links to some web pages in haddock ?
04:19:36 <sopvop> -- <http://github.com/ekmett/lens/wiki>
04:19:43 <sopvop> -- <<http://github.com/ekmett/lens/wiki/images/Hierarchy-3.2.png>>
04:20:19 <sopvop> osa1: ^
04:20:22 <osa1> sopvop: thanks
04:20:29 <osa1> sopvop: can I specify link text ?
04:21:24 <sopvop> I think not
04:23:08 * hackagebot persistent-sqlite 1.0.1 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-1.0.1 (MichaelSnoyman)
04:23:09 <sopvop> http://trac.haskell.org/haddock/ticket/190
04:28:06 * hackagebot authenticate-oauth 1.4.0.3 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.4.0.3 (HiromiIshii)
04:28:15 <atriq> Yes! I made a difference!
04:32:02 <sopvop> atriq: welcome to FOSS!
04:32:12 <romildo> I need help with llvm to build a function type using functionType [http://hackage.haskell.org/packages/archive/llvm-base/3.0.1.0/doc/html/LLVM-FFI-Core.html#v:functionType]. The return type is int64Type and the argument type list is empty. How should the functionType call be coded?
04:32:35 <atriq> sopvop, I just made an issue on the git saying "dependencies are outdated"
04:32:50 <shachaf> romildo: That looks like a low-level API.
04:32:53 <atriq> Saying that, I've also made a difference to lens and semigroupoids
04:33:22 <shachaf> romildo: Why are you using it?
04:33:34 <shachaf> "an issue on the git" :-(
04:33:55 <atriq> shachaf, how should I have phrased that?
04:33:59 <atriq> Or what should I have done?
04:34:05 <shachaf> I don't know. It depends on what you did.
04:34:07 <atriq> Depending on the precise meaning of the ":-("
04:34:21 <shachaf> Where did you make the issue?
04:34:27 <atriq> https://github.com/yesodweb/authenticate/issues/15
04:35:40 <romildo> shachaf, I am just starting writing my first (simple) code generator using llvm in Haskell. I have already wrote one in OCaml and I am willing to use the same level of API that is available to OCaml.
04:36:25 <romildo> shachaf, is there a higher level function to create a llvm function type in haskell?
04:36:35 <sopvop> atriq: Next time make a pull request with changes, that would be level 2 achievement!
04:39:18 <shachaf> romildo: OK, you shouldn't use these functions, then.
04:39:48 <shachaf> http://hackage.haskell.org/package/llvm
04:39:48 <atriq> sopvop, look at the aeson-lens thingy
04:39:52 <shachaf> http://hackage.haskell.org/package/llvm-base
04:41:38 <sopvop> atriq: the one about 'itraverse'?
04:41:50 <atriq> Perhaps
04:41:52 <atriq> Yes
04:42:05 <atriq> I'm Taneb
04:42:13 <shachaf> hi Taneb
04:42:17 <sopvop> -12 chatacters, nicely done!
04:42:23 <atriq> Soon, very soom
04:42:25 <atriq> *soon
04:42:29 <atriq> I SHALL GET LEVEL 3!
04:42:49 <atriq> Which, I presume, is making a contribution that actually adds stuff
04:44:18 <sopvop> Ladies and gentlemen, SPJ just left Microsoft.
04:44:28 <atriq> I saw
04:44:41 <typoclass> you mean simon marlow?
04:44:44 <shachaf> sopvop: SPJ too?
04:44:48 <atriq> Hopefully, this means Facebook becomes much better
04:44:49 <sopvop> whah
04:44:58 <sopvop> no, It was simon marlow
04:45:00 <luite> sopvop: you scary
04:45:01 <shachaf> With Marlow leaving earlier today, we're really going to be doomed.
04:45:09 * sopvop is embarrassed 
04:45:58 <sopvop> We still have one of Simons in MS
04:46:19 <luite> fortunately i can still do javascript programming if haskell fails, others might not be so lucky ;)
04:46:40 <atriq> Haskell's too fast to fail
04:47:06 <t7> i can still do excel, im safe
04:47:37 <sopvop> I can do python, and also CGI if all else fails.
04:47:41 <arcatan> hmm. i wonedr if FB is up to something.
04:47:45 <sopvop> CGI as in computer graphics
04:48:29 <luite> arcatan: distributed data mining stuff in haskell?
04:50:35 <sopvop> Does facebook make the same trick as google - "you apply, but never know what you'll be doing"?
04:50:59 * sopvop could not believe when first heard of how google hires
04:51:13 <atriq> Nah, they use the same trick as Facebook: "you apply, and will be working with PHP"
04:53:08 <sopvop> PHP - worse than Hitler, and even Java.
04:54:17 <lantti> \o/
04:54:43 <lantti> An open source project where I'd like to contribute has elected to use even more PHP...
04:55:06 <lantti> I tried to talk to them about yesod, but they made strange faces :(
04:55:20 <sipa> what do you mean by "you apply, but never know what you'll be doing"?
04:55:23 <atriq> lantti, make your own open source project!
04:55:28 <atriq> With blackjack!
04:55:31 <atriq> And hookers!
04:55:40 <lantti> I started my own fork yes!
04:55:45 <lantti> Just to show them
04:55:54 <sopvop> I make strange face about yseod also.
04:56:13 <atriq> Link? I may give you a hand
04:56:29 <lantti> sopvop: Because of template haskell?
04:56:47 <lantti> Or is there something more sinister there behind?
04:57:01 <lantti> I really just stared playing around with it :)
04:57:19 <atriq> It's not very good at keeping up with dependencies
04:57:27 <sopvop> huge number of packages, TH in routing and templates
04:57:33 <sopvop> not what TH is bad
04:58:07 * hackagebot yesod-auth 1.1.1.7 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.7 (MichaelSnoyman)
04:58:09 * hackagebot yesod-core 1.1.6 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.6 (MichaelSnoyman)
04:58:12 <sopvop> TH is good for same things as derving(Show,...)
04:58:41 <lantti> atriq: Nothing concrete done yet. I just took a yesod scaffolding and started to make it like http://www.bewelcome.org
04:58:55 <shachaf> sopvop: Some of the uses of TH coïncide with the uses of deriving, yes.
04:59:13 <lantti> If I manage to convince that I want to finish that then I might accept help too ;)
04:59:22 <sopvop> shachaf: That uses I accept :)
04:59:34 <sopvop> lantti: So, it's like a facebook?
04:59:57 <lantti> It is a travelling community site, yes
05:00:08 <shachaf> This seems a bit offtopic for #haskell
05:00:09 <atriq> There is the yesod-pure package, which takes out a fair bit of TH
05:00:15 <atriq> But I don't know how complete it is?
05:00:21 <sopvop> Inviting stangers to live in your house? What, that's scary.
05:00:25 <lantti> After couchsurfing started playing dirty a lot of people wanted to move to an open source platform
05:01:08 <lantti> sopvop: That has been one of the best decisions I have done in my life :)
05:01:50 <lantti> I feel part of the real world now in a way I never did :)
05:02:14 <zomg> Thankfully my home has no room for extra people living there
05:02:27 <zomg> Thus if I somehow went mental and thought that was a good idea, the size of my apartment would stop me
05:02:30 <zomg> ;>
05:02:32 <mpu> You just need a couch...
05:02:43 <mpu> (I don't have one, though)
05:03:10 <zomg> I have a couch but it's so uncomfortable nobody could sleep on it
05:03:11 <zomg> :D
05:03:11 <sopvop> I feel part of real world living with wife and kid in a 50m^2 flat.
05:03:23 <atriq> I wonder if Facebook is going to end up using Haskell
05:03:39 <zomg> atriq: they will probably write something that mixes haskell and php in some mad way
05:03:51 <lantti> I was talking about using haskell at google the other day
05:03:58 <djcoin> and C++
05:03:58 <mpu> I am sure they will never leave php.
05:04:04 <niteria> is SPJ moving from MS to FB? is there some news somewhere?
05:04:14 <lantti> But strangely they didn't think there was anything in it for them
05:04:14 <sopvop> Not SPJ, Simon Marlow
05:04:41 <typoclass> niteria: http://www.haskell.org/pipermail/glasgow-haskell-users/2012-November/023078.html
05:04:44 <lantti> Even stranger because they actually hosted a Haskell Hackathon already
05:05:06 <sopvop> It seems what half of programmers on teh internet work at google.
05:05:19 <typoclass> atriq: i thought they already were using haskell?
05:05:22 <lantti> The other half a fb
05:06:10 <sopvop> nay, fb is small.
05:06:50 <lantti> At least that's what the google guys were complaining about. That a lot of their teams jump to fb
05:07:25 <lantti> Or that google is training engineers for fb
05:07:31 <mpu> I am not sure to understand what they actually do there...
05:08:12 <sopvop> scrum meetings mostly
05:08:28 <lantti> But it coulf have been just a couple of people this particular guy felt important
05:08:51 <lantti> When I said google I actually meant the two engineers that gave me the tour :)
05:13:07 * hackagebot persistent 1.0.2.1 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-1.0.2.1 (MichaelSnoyman)
05:17:47 <atriq> Hmm
05:17:58 <atriq> I'd like to install ixset, but I don't actually need it
05:18:04 <atriq> Or particularly want it
05:18:12 <atriq> I'm just on a roll of installing things
05:20:31 <niteria> atriq: using your pc as a heater?
05:20:41 <atriq> Using my PC has a distraction implement
05:23:43 <bxx> is there a built in comparing function where `compareFunc "foo2" "foo10"' would return LT?
05:24:12 <shachaf> > (compare `on` length) "foo2" "foo10"
05:24:14 <lambdabot>   LT
05:24:27 <bxx> not what I had in mind :)
05:24:36 <shachaf> I know, but I don't know what you had in mind.
05:25:05 <bxx> it should compare numbers that are part of the string as numbers
05:25:07 <shachaf> Filter out all the non-digits, pad with zeros at the beginning of the shorter string, and compare lexicographically?
05:25:15 <bxx> yes
05:25:23 <shachaf> What, really?
05:25:29 <shachaf> That's just a random thing I came up with.
05:25:48 <shachaf> It's unlikely that it's exactly what you had in mind.
05:25:57 <donri> i'm sure there's a lens for this
05:26:36 <bxx> lens? a function would do.
05:26:57 <shachaf> donri is just making fun of me.
05:27:04 <donri> i'm being silly
05:27:14 <donri> not you
05:27:39 <donri> ed if anyone :p
05:27:56 <shachaf> Hey, I'm a committer too!
05:28:07 <shachaf> Today I committed some code that can segfault if you prod it the wrong way.
05:28:13 <shachaf> Then he released it.
05:28:56 * typoclass refrains from prodding it the wrong way
05:28:59 <donri> awesome!
05:29:04 * typoclass also refrains from prodding ed the wrong way
05:29:22 <bxx> anyway, if it wasn't clear, strings that have same prefixes followed by a number should have their numbers compared as numbers not as strings.
05:29:31 <bxx> no such function?
05:29:56 <typoclass> bxx: you could strip off the prefix, then do 'read' on them ...?
05:30:21 <typoclass> > read <$> stripPrefix "lol" "lolcat"
05:30:23 <lambdabot>   Just *Exception: Prelude.read: no parse
05:30:36 <TBJoe> hey guys, i tried to install vacuum-cairo with "cabal install vacuum-cairo" but it fails to install it ... are there any more steps i have to do? there obviously are some dependencies but i dont know how i can fix this or why it cant intall the required packages (running win7 64bit if it matters)
05:30:36 <typoclass> er, yeah, 'cat' is not a number, but you get the idea :-)
05:30:37 <shachaf> bxx: The question you should think about isn't what happens when you get strings that fit your mental model.
05:30:38 <donri> http://hackage.haskell.org/packages/archive/text-icu/0.6.3.5/doc/html/Data-Text-ICU-Collate.html ?
05:30:45 <shachaf> You should think about strings that *don't*.
05:30:50 <shachaf> Be your own worst enemy.
05:30:56 <donri> bxx: ^
05:33:14 <Yuu-chan> bxx: something like comparing (second (read :: String -> Int) . span isAlpha) ?
05:34:51 <bxx> Yuu-chan it should compare all substrings containing numbers as numbers
05:35:45 <Yuu-chan> bxx: yes, so the string is converted to the pair of substring and subnumber
05:35:59 <bxx> yes. is that what your code does? let me check
05:36:01 <donri> >>> collate mcol "foo2" "foo10"
05:36:02 <donri> LT
05:36:04 <donri> use text-icu
05:36:24 <donri> >>> setAttribute mcol (Numeric True)
05:36:28 <bxx> thanks to both
05:39:12 <ajason> why cant / work with Int ?
05:39:28 <shachaf> Because.
05:39:38 <Yuu-chan> ajason: for integral division, use `div`
05:39:39 <shachaf> Integer division is a different operation from divison.
05:39:57 <shachaf> It behaves very differently. People like it when x * y / y = x
05:40:01 <shachaf> (Or tries to.)
05:40:05 <ajason> I nevet said I want to do integral division
05:40:24 <shachaf> You never said what you want to do at all.
05:40:38 <shachaf> We shouldn't have tried to read your mind.
05:40:40 <ajason> I want to use Int to do non-integral division. why is haskell stopping me?i
05:40:46 <shachaf> Because
05:40:49 <shachaf> @type (/)
05:40:50 <Yuu-chan> ajason: / returns the value of the same type as its arguments. But the result of (1 :: Int) / (2 :: Int) is not an Int.
05:40:50 <lambdabot> Fractional a => a -> a -> a
05:41:16 <shachaf> What kind of division do you want, if not integer divison?
05:41:22 <flux> ajason, well, if you divided by 1, would you expect an integral or non-integral result?
05:41:27 <ajason> floating division
05:41:28 <TBJoe> can someone help me with setting up "vacuum-cairo"?
05:41:30 <shachaf> Polynomial division? Moon divison?
05:41:39 <shachaf> ajason: OK, so turn the Ints into floating point values.
05:41:47 <ajason> shachaf: stop being a smatarse
05:41:48 <Yuu-chan> ajason: or you may want to convert arguments with fromIntegral
05:41:52 <shachaf> fromIntegral :: Int -> Double
05:41:53 <typoclass> > 1/2
05:41:55 <lambdabot>   0.5
05:42:02 <FireFly> "on" might be helpful here
05:42:11 <ajason> Yuu-chan: I know, its just annoying I have to do that
05:42:39 <Yuu-chan> ajason: it's a part of Haskell strong typing, it disallows implicit conversions
05:42:42 <shachaf> If you already know the answer to your question, you should phrase it in such a way that we know what you know and what you don't know.
05:42:59 <Yuu-chan> It's both unsafe and breaks the type inference.
05:43:13 <typoclass> ajason: if all else fails, you could make your own function "f a b = fromIntegral a / fromIntegral b" or similar
05:43:19 <shachaf> You're free to make an operator (//) :: (Integral a, Integral b) => a -> b -> Double; x // y = fromIntegral a / fromIntegral b
05:43:26 <Yuu-chan> :t (/) `on` fromIntegral
05:43:28 <lambdabot> (Fractional c, Integral a) => a -> a -> c
05:43:43 <dcoutts_> TBJoe: the tricky bit is the cairo C lib on Windows. But if you follow the instructions on the gtk2hs web site about windows, that should get you there.
05:43:44 * Yuu-chan loves combinators
05:43:56 * shachaf has no idea what "combinator" means anymore.
05:44:02 <shachaf> I suspect people use it to mean "function"
05:44:44 <TBJoe> dcoutts_ which website exactly?
05:44:55 <typoclass> shachaf: yeah, i think it mostly means "function that takes another function". (hof, in other words)
05:45:23 <Yuu-chan> shachaf: I treat this as "a lambda term without free variables which can be reduced without eta conversion"
05:46:07 <Yuu-chan> or a function which combines another function into a new function.
05:46:07 <vraid> oh, x ^ 2 is not optimized to x * x for Ints?
05:46:18 <vraid> i just had a remarkable speedup
05:46:32 <dcoutts_> TBJoe: google gtk2hs
05:46:56 <hpc> @hackage gtk
05:46:56 <lambdabot> http://hackage.haskell.org/package/gtk
05:47:08 <hiptobecubic> can rewrite rules depend on types?
05:47:10 <Yuu-chan> vraid: AFAIK, (^ 2) x can only be computed as x ^ x
05:47:15 <shachaf> vraid: Maybe it is, maybe it isn't.
05:47:31 <shachaf> (^) is defined as an ordinary recursive function. Who knows what GHC will do to it.
05:47:58 <hiptobecubic> @src (^)
05:47:59 <lambdabot> x ^ 0            =  1
05:47:59 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
05:47:59 <lambdabot>   where f _ 0 y = y
05:47:59 <lambdabot>         f x n y = g x n
05:47:59 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
05:48:01 <lambdabot>                       | otherwise = f x (n-1) (x*y)
05:48:03 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
05:48:09 <vraid> execution time went from 3m27s to 0m6s
05:48:23 <hiptobecubic> vraid, that is crazy. something else must have happened
05:48:45 <shachaf> vraid: Paste code?
05:49:09 <lantti> Something wonderful has happened?
05:49:22 <TBJoe> dcoutts_ if you mean this one http://projects.haskell.org/gtk2hs/archives/2005/06/24/installing-on-windows/#more-16 i just tried that, and the install process kinda fails
05:49:26 <lantti> Your Haskell is alive?
05:49:49 <atriq> x ^ 2 -> f x 1 x -> g x 1 -> f x 0 (x * x) -> (x * x)
05:50:00 <atriq> 4 steps to become (x * x)
05:50:18 <shachaf> atriq: As I said, who knows what GHC does with it.
05:50:21 <hiptobecubic> inlined hopefully?
05:50:29 <hiptobecubic> check the core i guess
05:50:50 <shachaf> Rule 3 of optimization: Your intuition is wrong.
05:51:24 <FireFly> What is rule 2?
05:51:26 <merijn> shachaf: What's rules 1 and 2?
05:51:51 <c_wraith> rule 1: don't optimize
05:52:00 <c_wraith> rule 2: (for experts only) don't optimize yet
05:52:56 <shachaf> What c_wraith said.
05:52:57 <vraid> shachaf, hiptobecubic: relevant function, before and after http://ideone.com/Ipub3y
05:53:23 <romildo> What should be type of a LLVM function with no arguments returning an int32?
05:53:24 <shachaf> "relevant function" isn't code I can run.
05:53:30 <shachaf> romildo: Did you take my advice before?
05:53:35 <ion> @tell elliott You talked about Applicative sugar for records. How about making banana brackets work for that? (| Record { field0 = foo, field1 = bar, field2 = baz } |) = (\a b c -> Record { field0 = a, field1 = b, field2 = c }) <$> foo <*> bar <*> baz
05:53:35 <lambdabot> Consider it noted.
05:53:51 <romildo> shachaf, yes, i did.
05:53:59 <shachaf> So now you're using the high-level bindings?
05:54:32 <romildo> shachaf, I am using the high-level llvm bindings.
05:54:48 <shachaf> vraid: You should avoid using head and tail if at all possible, by the way.
05:54:51 <shachaf> Pattern-match instead.
05:55:02 <vraid> shachaf: Primes.hs http://ideone.com/PMFxTb , Main.hs http://ideone.com/8Ng9Wr
05:55:18 <ajason> if / accepted Num and returned haskell equivalent of float you could pass a number of any type to it. why isnt it defined like that?
05:55:19 <vraid> could you elaborate?
05:55:52 <u_quark> is there a connection with:
05:55:52 <u_quark> @pl (\f g x y -> f (g x y))
05:55:52 <u_quark> @pl (\f g x y z -> f (g x y z))
05:55:52 <u_quark> @pl (\f g x y z w -> f (g x y z w))
05:55:52 <u_quark> etc and arrows ?
05:55:53 <lambdabot> (.) . (.)
05:55:53 <lambdabot> (.) . (.) . (.)
05:55:53 <lambdabot> (.) . (.) . (.) . (.)
05:56:09 <hiptobecubic> vraid, what happens if you factor out the head ps, but leave  p ^ 2
05:56:11 <yiannis_t> aren't those the tit-functions?
05:56:12 <FireFly> ajason: if I divide two rational numbers I probably don't want a float as the result
05:56:13 <Yuu-chan> vraid: use pattern matching: prime (p:ps) = <...>
05:57:04 <vraid> hiptobecubic: doesn't run in 6 seconds anymore
05:57:38 <ion> ajason: The current way lets you dictate the types of all values in an expression such as ((2 + 3) / 4 * 5 :: Rational) just by choosing the type of the result.
05:57:39 <shachaf> vraid: Program takes the same amount of time with ^2 and with p*p
05:58:04 <ajason> FireFly: thats a design issue then that / does both float and fractional division. they could have made a different function for that like div for integral division
05:58:15 <hiptobecubic> vraid, compiler flags?
05:58:15 <romildo> shachaf, I have used    Function (IO Int32)     as the type for a function with no args returning an int (the main function), but llc (the llvm ir compiler) gives the error: void type only allowed for function results
05:58:15 <romildo> define i32 @Main(void) {
05:58:16 <romildo>  
05:58:16 <vraid> shachaf: could the profiler be slowing it down?
05:58:22 <hiptobecubic> vraid, yes.
05:58:22 <vraid> yeah, i have profiling on
05:58:53 <hiptobecubic> profile to profile, not to benchmark
05:59:12 <ajason> they could have made a different function for rational division, even
05:59:25 <Yuu-chan> ajason: what for?
05:59:31 <vraid> right, right. Still, i somehow expected p^2 to be identical to p*p
05:59:35 <hiptobecubic> the current method is working nicely
05:59:35 <shachaf> ajason: They do.
05:59:38 <shachaf> vraid: It is.
05:59:42 <shachaf> Well, when I measured it.
05:59:48 <vraid> not with the profiler on
05:59:48 <FireFly> I think it makes much more sense to have (/) in a type class instead of tying it to a single type
05:59:52 <vraid> that's what i meant
06:00:17 <ajason> Yuu-chan: to avoid ugliness that is (fromIntegral a) / b
06:00:41 <shachaf> vraid: I turned the profiler on. Still the same.
06:00:43 <hiptobecubic> ajason, that 'ugliness' is called type-safety. You learn to love it.
06:01:12 <lantti> Not to mention love learning it :)
06:01:17 <hiptobecubic> if you want a different operator for converting things to float unnecessarily, then make one
06:01:18 <Yuu-chan> ajason: I don't see how unique operators for division of each numeric type could made the life easier
06:01:35 <lantti> I have found out that I actually benefit from using haskell in all other stuff that I do
06:01:42 <hiptobecubic> besides, we need those operators for lens, apparently
06:02:02 <vraid> shachaf: i turned the profiler off.. no improvement for p^2
06:02:18 <shachaf> vraid: Could you:
06:02:20 <vraid> am i running some gimped version of ghc
06:02:29 <shachaf> Put Main.hs and Primes.hs in a single file.
06:02:40 <shachaf> Make two versions of this file, identical except for p^2 or p*p
06:02:57 <shachaf> Compile and run each version separately, and tell us what the flags you're using are
06:03:01 <vraid> that did it
06:03:01 <shachaf> And paste all that somewhere?
06:03:10 <typoclass> hiptobecubic: i'm not necessarily against what you said, but could you elaborate how things get safer if it's disallowed to divide (3 :: Float) by (2 :: Int) ?
06:03:11 <vraid> 0.418s instead of 1m4.375s
06:03:11 <Yuu-chan> ajason: as shachaf said, integral division is deeply different because it doesn't have a reverse
06:03:21 <ajason> hiptobecubic if they did it like this it would work and you wouldnt need fromInteger anywere.  / -> floating division.  div integral division.  whatever -> rational division.
06:03:50 <shachaf> ajason: I'm sorry that numbers in Haskell are terrible.
06:04:04 <Yuu-chan> You can't divide any two numbers from some set and get a result from the same set.
06:04:04 <vraid> shachaf: they run in the same time now
06:04:09 <shachaf> ajason: Lots of people say they're terrible, though their reasons are usually different from yours.
06:04:19 <hiptobecubic> typoclass, because if you used /, you are expecting that the top and bottom have the same type.
06:04:20 <shachaf> This won't be changing, though.
06:04:27 <shachaf> So there's not much fruit to it.
06:04:44 <shachaf> vraid: I say you weren't actually testing what you thought you were testing before.
06:04:56 <vraid> i wasn't properly compiling Primes.hs, then
06:05:01 <shachaf> Learn to be careful when running benchmarks. :-) It's hard enough when you're careful.
06:06:00 <vraid> yeah, i'm new to this. Thanks :)
06:06:31 <typoclass> hiptobecubic: yes, but why? if i'm doing (==), i can see that it requires both arguments to be the same type. equality means it's the same type and same value; the first half can be checked at compile time already. now that i'm thinking about it, i'm not as clear why that's necessary for (/)
06:07:44 <typoclass> ajason: you might be interested in (%) from Data.Ratio, by the way :-) i'd demonstrate it, but (%) in lambdabot is something else. but it will work in your ghci http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html#t:Ratio
06:07:57 <fmap> :t R.%
06:07:59 <lambdabot> parse error on input `R.%'
06:08:00 <Yuu-chan> Imagine (/) :: (Fractional a, Num b) => a -> b -> a
06:08:05 <fmap> :t (R.%)
06:08:07 <lambdabot> Integral a => a -> a -> Ratio a
06:08:12 <ilias> willb: 2
06:08:45 <Yuu-chan> That reminds me of Numeric Prelude or something
06:09:36 <ajason> Yuu-chan: the same is true about floating division. its not exact and you arent guaranteed to get original number back. so why not have two functions accepting any number (Num)
06:09:59 <Yuu-chan> ajason: but what they will return?
06:11:06 <ajason> Yuu-chan: floating division haskell equivalent od a float, rational division a rational
06:11:21 <hiptobecubic> what about a float and a rational?
06:11:25 <Yuu-chan> ajason: well, mixed division?
06:11:37 <typoclass> that's what i was getting at. (/) is a best-effort thing anyway. "i'll divide it and give you the result of the division, or some number in the general vicinity thereof, hope ya don't mind". it wouldn't be totally off-the-wall to say, "for float, the precision is XYZ, and for int, it's coarser"
06:11:52 <hiptobecubic> that's not at all what it is.
06:12:03 <hiptobecubic> floating point numbers are well defined
06:12:07 <ajason> if you passed float and rational to / you would get a float back. / would always return float
06:12:17 <typoclass> > (1/3) * 0.6 -- hiptobecubic
06:12:19 <lambdabot>   0.19999999999999998
06:12:31 <shachaf> Sorry, ajason. I don't want to live in that world.
06:12:33 <hiptobecubic> typoclass, yes. and that behavior is well defined.
06:12:35 <typoclass> hiptobecubic: integer division (rounding down) is well-defined too ...
06:12:53 <shachaf> > 1 / 2 :: Rational -- no float in sight
06:12:55 <lambdabot>   1 % 2
06:13:16 <hpc> @src Rational
06:13:16 <lambdabot> type Rational = Ratio Integer
06:13:19 <hpc> @src Ratio
06:13:19 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:13:22 <ajason> shachaf: so?
06:13:27 <shachaf> So what?
06:13:28 <vraid> typoclass: problems only arise when people expect floating point arithmetic to have perfect precision
06:13:32 <FireFly> This new (/) doesn't float my boat
06:13:38 <FireFly> or rather, suggested (/)
06:13:39 <hiptobecubic> typoclass, vraid which is wrong to start with.
06:13:43 <ajason> so what if there is no float in  sight?
06:13:50 <hiptobecubic> ajason, so why would you convert to float
06:14:24 <ajason> hiptobecubic: because you passed it to a function that does floating division
06:14:54 <hiptobecubic> ajason, and why would you want that?
06:15:11 <hiptobecubic> > (1/3) * 0.6 :: Rational
06:15:12 <shachaf> ajason: They're not going to rewrite the Haskell report to behave this way, so there's not much point in arguing about what (/) should be.
06:15:13 <lambdabot>   1 % 5
06:15:14 <typoclass> hiptobecubic, vraid: right, floats don't have perfect precision. but if i understood correctly, the reasoning earlier was "(/) can never be allowed to take Ints, because integer division is lossy and imperfect"
06:15:27 <hiptobecubic> no
06:15:32 <hiptobecubic> It is *different*
06:15:47 <hiptobecubic> it's not trying to be floating point division and just unable to do it
06:16:02 <shachaf> Integer division is a well-defined thing.
06:16:06 <hiptobecubic> right
06:16:36 <shachaf> x = y * (x `div` y) + x `div` y
06:16:38 <shachaf> Or something
06:17:32 <vraid> typoclass: ah, i missed that part
06:18:02 <ajason> hiptobecubic: because I should be able to use Integer in a division
06:18:08 <hiptobecubic> :t div
06:18:09 <ajason> in a floating
06:18:10 <lambdabot> Integral a => a -> a -> a
06:18:25 <hiptobecubic> ajason, you can. That's exactly what fromIntegral lets you do.
06:18:35 <shachaf> ajason: I disagree but it doesn't matter because the Haskell spec isn't going to change.
06:18:43 <shachaf> So what's the point of this argument?
06:18:46 <hiptobecubic> First we make this integer into the appropriate type, then we do that type's division.
06:19:21 <ajason> hiptobecubic: that clutters code
06:20:53 <ajason> the issue is that / does two type o divisions, instead of just floating division. haskell did a right thing to separate integral and floating division. too bad they didnt also separate floating and rational division
06:21:38 <typoclass> i'm not convinced that it's so unthinkable to have a hypothetical language that has divInt, which is like haskell's div, and divUniversal, which takes two Nums and gives a fuzzy "i'll do my best" result, and divFloat, which is floating division as defined in ieee754 or whatever the number
06:22:49 <fmap> how about hypothetical language without Float, Double and friends?
06:23:31 <typoclass> fmap: sign me up for that! i always found them more trouble than they're worth. there's some niches, but they shouldn't be so prominent (in Prelude and all)
06:24:11 <padrian2ss> hello. I have a question regarding this behavior, given this function append xs ys = foldr (:) xs ys  and applicative function append [1..10] [9..1]  the result is surprising [1,2,3,4,5,6,7,8,9,10]
06:24:32 <padrian2ss> why? :)
06:25:18 <FireFly> > [9..1]
06:25:19 <hiptobecubic> ajason, define // and you're done. one line.
06:25:22 <lambdabot>   mueval-core: Time limit exceeded
06:25:34 <ajason> wait, % does rational divison? even weirder that / does both thn
06:25:47 <vraid> > foldr (:) [1..10] [9,8..1]
06:25:49 <lambdabot>   [9,8,7,6,5,4,3,2,1,1,2,3,4,5,6,7,8,9,10]
06:25:59 <hiptobecubic> ajason, typeclasses.  (%) is a constructor, not division.
06:26:24 <FireFly> padrian2ss: you need an extra element in the range if you want another step size than 1 (such as -1 in this case)
06:26:24 <hiptobecubic> @info Rational
06:26:24 <lambdabot> Rational
06:26:28 <hiptobecubic> :D great
06:26:43 <hiptobecubic> @src Ratio Integer
06:26:43 <lambdabot> Source not found. Where did you learn to type?
06:26:45 <padrian2ss> sorry... [9..1] return []
06:26:46 <hiptobecubic> @src Ratio
06:26:46 <lambdabot> data (Integral a) => Ratio a = !a :% !a
06:26:47 <Philonous> hiptobecubic:  @info gets auto corrected to undo
06:27:03 <hiptobecubic> Philonous, why?
06:27:21 <vraid> padrian2ss: [9..1] is all numbers of the list [9, 10, 11, 12, 13, 14..] less than 1
06:27:31 <vraid> (i.e the empty list)
06:27:45 <Philonous> hiptobecubic:  No idea. You'd have to ask the author of lambdabot.
06:28:14 <vraid> since the default increment for lists is 1, you have to start the list with two terms [9,8..1] if it is to be decreasing
06:28:20 <flux> if I had to guess, it's because it's editing distance is less than or equal to two :)
06:28:24 <typoclass> ajason: often you'll use % with two Integers (they're arbitrary-length). you can do the regular calculations with them as well
06:28:26 <typoclass> > (1/3 :: Rational) * (6/10 :: Rational) -- ajason
06:28:28 <lambdabot>   1 % 5
06:29:04 <padrian2ss> vraid: I just realized that when I tried [9..1] on ghci after pushing my question here
06:29:44 <bxx> hiptobecubic how would you define such a function? there's no anyNumToFloat function that I see
06:30:13 <Philonous> :t fromIntegral
06:30:15 <lambdabot> (Integral a, Num b) => a -> b
06:30:30 <bxx> that doensn't work with any number though
06:30:53 <ion> is anyRealToFloat enough?
06:30:57 <ion> :t realToFrac
06:30:59 <lambdabot> (Fractional b, Real a) => a -> b
06:31:00 <Philonous> bxx:  Define "any number"
06:31:10 <bxx> Num
06:31:26 <shachaf> What would anyNumToFloat do?
06:31:27 <bxx> @hoogle Num a => a -> Float
06:31:28 <lambdabot> Prelude abs :: Num a => a -> a
06:31:28 <lambdabot> Prelude negate :: Num a => a -> a
06:31:28 <lambdabot> Prelude signum :: Num a => a -> a
06:31:33 <shachaf> That function doesn't make sense.
06:31:34 <Philonous> bxx:  How would you convert a complex number to a float?
06:31:40 <ion> How would you prefer to convert a Complex Float to a Float?
06:32:05 <shachaf> How would you convert a Philonous to an ion?
06:32:16 <shachaf> A: Convert number to Float.
06:32:23 <bxx> ok so instead of Num make that any number type that is convertible to Float, whatever the name of that typeclass is
06:32:37 <ion> :t realToFrac
06:32:38 <lambdabot> (Fractional b, Real a) => a -> b
06:33:05 <xplat> ajason: the main reason that there aren't automatic conversions like from Int to Float is that the clarity you gain there would be lost somewhere else from the complication of the type system created
06:33:10 <shachaf> ion: Why didn't you say so 2 minutes ago?
06:33:25 <xplat> ajason: if you want a typed language that took the other side of that tradeoff, there's always scala
06:34:31 <xplat> (or you could write your own alternative prelude to Haskell)
06:34:44 <ion> Because there aren’t enough alternative Preludes yet.
06:34:50 <Philonous> ajason:  Note that you can get into trouble when chaining overloaded functions because the type "in the middle" will be underspecified
06:35:09 <ajason> xplat: I wasnt arguing for auto conversions. but / accepting all numbers you can do floating divison with and returning result as a float. is this possible with haskell tupe system?
06:35:24 <shachaf> Floating points are terrible.
06:35:27 <shachaf> They are not to be encouraged.
06:35:34 <sopvop> I'll just leave it here http://www.haskell.org/haskellwiki/Converting_numbers
06:35:48 <shachaf> With that said, yes, you can do that. People have said how to do that several times recently, in fact.
06:36:26 <xplat> ajason: ah, that's possible, but what if you wanted to use some other type of floating or floating-ish number besides the builtin Float for the result?
06:37:06 <ajason> xplat: such as? does haskell have more than one floating type?
06:37:20 <sopvop> Haskell can have as many as you want
06:37:23 <ion> Float and Double for starters.
06:37:57 <xplat> ajason: Float, CFloat, CDouble, CReal (which is not a floating-point representation, but does implement the relevant typeclass)
06:38:09 * hackagebot PrimitiveArray 0.4.0.1 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.4.0.1 (ChristianHoener)
06:38:11 * hackagebot BiobaseXNA 0.6.3.1 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.3.1 (ChristianHoener)
06:38:13 * hackagebot BiobaseInfernal 0.7.0.1 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.7.0.1 (ChristianHoener)
06:38:17 <ajason> ok then that wouldnt work as well as I imagined
06:41:11 <parcs`> over time one begins to appreciate the explicitness of numeric conversions in haskell
06:42:05 <sopvop> After C you appreciate it from start
06:42:09 <sopvop> and after PHP...
06:42:31 <osfameron> I like Int vs Float etc.
06:42:56 <osfameron> but Int versus Integer vs Integral and Float vs Long makes me want to kick puppies in the face
06:43:09 * hackagebot file-location 0.4.5.2 - common functions that show file location information  http://hackage.haskell.org/package/file-location-0.4.5.2 (GregWeber)
06:43:22 <vraid> sopvop: what, you mean 5 + 'a' doesn't make perfect sense? :)
06:44:11 <xplat> of course, it means 'f'.  or '5a'.
06:44:46 <xplat> or 'D' (or was that 'C')  :)
06:46:53 <ajason> parcs`: yeah I can see the advantages. just not used to it
06:47:22 <sopvop> Another sinner has seen the light of glorious type system!
06:48:28 <hiptobecubic> osfameron, you just haven't needed them to be different yet
06:49:04 <osfameron> hiptobecubic: I want to not be able to care in a high-level language
06:49:13 <osfameron> doing numbersy stuff in haskell is a massive pain in the arse
06:49:50 <sopvop> All numbers are not equal.
06:49:53 <hiptobecubic> indeed
06:50:38 <hiptobecubic> It would be nice to able to specify the precedence for inferred literal types it hink
06:50:45 <hiptobecubic> I think*
06:50:50 <bartavelle> yes
06:50:57 <bartavelle> but automatic promotion is a bad idea
06:51:15 <osfameron> I'd be happy if someone told me there was a LANGUAGE UseSensibleNumericDefaults pragma I could use
06:51:15 <bartavelle> it is all fun and games until someone gets hit by an integer overflow
06:51:25 <typoclass> is that written up somewhere, (/) and div and Prelude numbers in general? basically a write-up of what ajason asked
06:51:28 <hiptobecubic> So you could put at the top {-# LANGUAGE INT_GODDAMNIT #-}
06:51:41 <hpaste> timbla pasted “bla” at http://hpaste.org/78050
06:51:44 <typoclass> ... erm sorry, that question was unspecific :-/
06:54:35 <rwbarton> default (Int, Double)
06:54:36 <vraid> while we're on the topic, how do you convert an Int to an Integer?
06:55:15 <typoclass> vraid: fromIntegral doesn't work for you?
06:55:29 <parcs`> toInteger or fromIntegral
06:55:35 <vraid> oh, ofc
06:57:32 <bxx> is there a show equivalent that accepts a and returns a string, but doesn't put additional quotes if passed a string
06:57:37 <sopvop> god damn emacs, C-W does not cut text in pidgin.
06:58:09 * hackagebot CMCompare 0.0.1.5 - Infernal covariance model comparison  http://hackage.haskell.org/package/CMCompare-0.0.1.5 (ChristianHoener)
06:58:59 <ion> sopvop: gtk-key-theme-name = "Emacs"
07:00:37 <sopvop> It does really exist?
07:01:10 <parcs`> bxx: showString "foo ""
07:01:46 <typoclass> where is the Fractional instance for Float defined? (is it at all readable, or some very bonkers low-level internal thing?)
07:01:59 <parcs`> bxx: oh, sorry, i misread
07:02:03 <sopvop> And about numbers, why not add LANGUAGE OveloadedNumberSuffixes, like    10i -> Int, 10I -> integer, and you can do your own shit like   1024uid -> UserId
07:02:32 <hiptobecubic> didn't c++ add that recently?
07:02:51 <sopvop> in extensible way?
07:03:00 <hiptobecubic> you can specify your own i think
07:03:05 <hiptobecubic> i don't know how general it gets
07:03:05 <typoclass> sopvop: i guess you could use a function 'uid' and write it backwards ... uid 1024
07:03:16 <hiptobecubic> but the example was for working with units
07:03:21 <hiptobecubic> looked useful
07:03:22 <sopvop> typoclass: Well ok, that one is too long :)
07:03:44 <typoclass> =)
07:04:23 <latermuse> bxx: try this:
07:04:25 <latermuse> > reverse $ drop 1 $ reverse $ drop 1 $ show "meow"
07:04:27 <lambdabot>   "meow"
07:05:06 <vraid> :t show
07:05:08 <lambdabot> Show a => a -> String
07:05:23 <vraid> > drop 1 $ show "meow"
07:05:25 <Pantoufle> > drop 1 $ show "meow"
07:05:25 <lambdabot>   "meow\""
07:05:26 <lambdabot>   "meow\""
07:05:32 <Pantoufle> Clever
07:05:54 <vraid> > show "meow"
07:05:56 <lambdabot>   "\"meow\""
07:06:14 <vraid> what is \"
07:06:36 <vraid> ah, never mind, it escapes the "
07:06:58 <osa1> cabal haddock generates docs for unexported modules, this doesn't mean that docs will show up in hackage page, right ?
07:07:12 <nand`> > tail . init $ show "meow"
07:07:15 <lambdabot>   "meow"
07:07:26 <latermuse> nice nand'
07:07:36 <rwbarton> bxx: no
07:07:40 <parcs`> that won't work because bxx wants overloading
07:07:42 <nand`> > tail . init $ show "\x123"
07:07:44 <lambdabot>   "\\291"
07:08:09 <latermuse> parcs': what is overloading?
07:08:36 <bxx> it should do that for strings only
07:09:35 <rwbarton> you should just keep track of whether you have a String and if so not call "show"
07:09:57 <niteria> when is forall used?
07:10:03 <parcs`> bxx: such a class doesn't exist in the base library. you can use a pretty printer, but that's probably overkill
07:11:13 <parcs`> instead of calling 'show' from the callee, call 'show' from the caller
07:11:14 <nand`> newtype Lit = Lit String; instance Show Lit where show (Lit s) = s
07:12:10 <sopvop> osa1: There is a way to hide module from haddock, but I can't remember how
07:13:23 <sopvop> osa1: try before  '-- #hide' before 'module Foo'
07:13:44 <parcs`> bxx: so instead of having 'f :: Show a => a -> ...', you have 'f :: String -> ...' and call 'f (show x)' when x is not a String. if x is a String then just call 'f x' (you'll know that x is not a String because as the caller, you know what x is (usually))
07:18:47 <osa1> sopvop: didn't work ;-(
07:19:15 <osa1> sopvop: http://www.haskell.org/haddock/doc/html/module-attributes.html
07:19:41 <sopvop> Oh, cool. thanks
07:19:53 <bxx> parcs` what if x is of Show type though?
07:20:52 <nand`> x can't be of type Show
07:20:55 <vraid> shachaf: what was the function you told me to try using to avoid stack overflow?
07:20:57 <bxx> can I create a typeclass that would call show for all of Show types except strings
07:21:17 <nand`> with overlapping classes, sure
07:21:42 <bartavelle> but show is bad even for not strings ?
07:22:12 <bartavelle> isn't it implemented like "show . unpack" for bytestrings ?
07:23:50 <xplat> bxx: a key thing here is that Show is not a type, it's a constraint
07:24:50 <xplat> if you use overlapping instances you can do something like
07:26:30 <xplat> class ToString a where { toString :: a -> String }
07:27:36 <xplat> instance ToString String where { toString = id }
07:28:24 <xplat> instance (Show a) => ToString a where { toString = show }
07:29:05 <xplat> but that's kind of gross, because the latter instance overlaps with the String instance and every other instance you may define
07:29:52 <bxx> why gross? that's what I want. and that's the only way to do it as far as I can see
07:30:11 <xplat> which means it's not actually safe to define any of your own instances (even for types without a Show instance) in any other module
07:30:53 <bxx> you mean it's not safe to define your own instances of toString?
07:31:01 <xplat> right
07:31:24 <xplat> it's not that bad in your application, but it's not a good habit to get in for reasons like that
07:31:35 <bxx> I am not seeing what could go wrong
07:32:55 <xplat> i'm not saying 'don't do this', it's more 'don't do things similar to this because a lot of them can go wrong'
07:33:43 <bxx> I mean I don't see how it could be unsafe to define your own instance of toString
07:33:47 <rwbarton> http://stackoverflow.com/questions/10942136/whats-so-bad-about-overlappinginstances has some discussion
07:33:48 <xplat> the other problem is this kind of toString function makes it easy to get 'injection' problems
07:34:59 <rwbarton> bxx: let's say that what xplat wrote above is in module A and module B imports module A and defines a second instance ToString ByteString
07:35:14 <rwbarton> then modules A and B will disagree about what toString x means when x is a ByteString
07:35:32 <Cale> Instances are selected based on the structure of the type alone, and the class constraints on them are only enforced after having decided which instance is to be used.
07:35:48 <Cale> (In addition to the problem that rwbarton is pointing out)
07:36:46 <Cale> So, basically, if you define an instance (Show a) => ToString a, then as far as choosing which instance to use goes, this looks like an instance ToString a, which will overlap with absolutely everything.
07:37:12 <Cale> (whether there's a Show instance or not)
07:40:10 <xplat> so the only safe way to do this is, for whichever sets of instances overlap, they must all be defined in one module
07:40:33 <xplat> this is the extreme case where all instances must be defined in one module period
07:41:15 <xplat> in general i don't know if there's any way to enforce that
07:44:06 <xplat> hiding a class would make it hard to write type signatures
07:47:10 <rwbarton> and again the "unsafety" lies in the fact that you have little control over which instance is selected
07:47:17 <t7> has anyone actually implemented the calculus in wadlers type class paper? (no not ghc or scala, something minimal)
07:47:22 <rwbarton> move a definition from module A to module B and it can change meaning
07:47:54 <rwbarton> or -- if module C imports module A a definition in module C can have one meaning, but then if module B is added as an import in module C the definition can change meaning
07:48:12 * hackagebot nerf 0.2.0 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.2.0 (JakubWaszczuk)
07:48:17 <rwbarton> that sort of thing is not supposed to be possible in Haskell
07:49:51 <xplat> nerf -- ooh, i was looking for things like that
07:50:10 <ocharles> the 'newtype' package mentions McBride a bunch of times -- was there a paper that motivated that package?
08:04:14 <efie> cabal update tells me that I have to run cabal install cabal-install. If i do so, cabal-install-1.16.0.2 is built then. If i do cabal update after that, it again tells me that I have to run cabal install cabal-install
08:04:32 <dcoutts> efie: check your $PATH
08:04:48 <dcoutts> efie: the new one you installed is likely being masked on the $PATH by your existing one
08:05:16 <bgamari> from Control.Lens.Internal: data EvilBazaar g a b s
08:07:00 * bgamari shutters to think about how many sleepless nights edwardk must have struggled to name Bazaar
08:09:01 <efie> dcoutts: I have /home/X/.cabal/bin in my path, do you know where the new one is installed?
08:09:32 <efie> after cabal install cabal-install it said "Installing executable(s) in /home/tobias/.cabal/bin"
08:09:48 <efie> let tobias = X
08:10:11 <Saizan> ocharles: i don't think so, he has promoted his ala combinator in a few emails though
08:11:02 <copumpkin> bgamari: I was around for part of it
08:11:13 <copumpkin> "what's a good name for a collection of stores?"
08:11:18 <copumpkin> Mall
08:12:04 <osfameron> if you speak en_US yeah
08:12:10 <bgamari> heh
08:12:28 <nicoo> copumpkin: There is no such thing as American English ;)
08:14:49 <dcoutts> efie: you can check with: which cabal
08:14:58 <geekosaur> efie, if you are still in the same shell then you may need to do:  hash -r
08:15:18 <geekosaur> because the shll knows it already fund it in another place and won't check again unless you flush its hash tabl
08:20:42 <ocharles> Saizan: ok, on the cafe?
08:21:29 <edwardk> bgamari: i chewed on it for a couple of days. it used to go by various names that roconnor had picked. CartesianStore and KleeneStore, etc.
08:21:43 <Iceland_jack> Is there an easy way to generate Cartesian products of infinite lists in Haskell such that all tuples will eventually be generated (think Zig-Zag proof of countability of rational number): As an example, [ (x, y) | x <- [1..], y <- [1..] ] would never hit x > 1
08:24:28 <efie> dcoutts: which cabal gives me "/usr/local/bin/cabal" (cabal file last modified June2012), but in my PATH is "/home/X/.cabal/bin" (last modified today), how can I point cabal to the latter?
08:24:51 <Cale> Iceland_jack: There's some stuff in the logict package which can be used for that
08:24:58 <geekosaur> efie:  what is the value of $PATH?
08:25:00 <dcoutts> efie: either remove the first one, or change the order of the entries in your $PATH
08:25:15 <Iceland_jack> Thanks Cale, I'll look into it :)
08:25:22 <Cale> > [1..] >>- \x -> [1..] >>- \y -> return (x,y)
08:25:24 <lambdabot>   [(1,1),(2,1),(1,2),(3,1),(1,3),(2,2),(1,4),(4,1),(1,5),(2,3),(1,6),(3,2),(1...
08:25:35 <Iceland_jack> oh, fantastic!
08:25:48 <efie> geekosaur: /usr/lib/lightdm/lightdm:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games:/home/X/.cabal/bin:/home/X/.cabal/bin
08:25:48 <Cale> This order might not quite be the one you want
08:26:08 <Iceland_jack> Cale: The order isn't really of any concern
08:26:16 <geekosaur> efiie:  $PATH is searched from left to right; if you want ~/.cabal/bin to be seen first, put it on the left instead of the right
08:26:54 <Iceland_jack> :i (>>-)
08:26:54 <geekosaur> note that you may need to restart to get the new $PATH everywhere, although you can manually set it in open terminal windows
08:27:00 <FireFly> @ty (>>-)
08:27:02 <lambdabot> MonadLogic m => m a -> (a -> m b) -> m b
08:27:14 <Iceland_jack> Thanks FireFly
08:27:22 <FireFly> Oh, I was doing that for myself :P
08:27:24 <FireFly> But you're welcome
08:27:33 <Iceland_jack> hah
08:27:36 <FireFly> Looks similar to bind
08:27:58 <Cale> The similarity to bind is intentional
08:28:10 <Cale> It produces the same results, but in a different order
08:28:35 <efie> geekosaur: sorry, but where is /usr/local/bin/cabal in my $PATH? I don't see, that's why I thought home/X/.cabal/bin would be seen; does /usr/local/bin include it?
08:29:02 <dcoutts> efie: /usr/local/bin is the directory, /usr/local/bin/cabal is the executable within that directory.
08:29:06 <geekosaur> efie, $PATH is directories.  All executables in the directory are seen
08:29:27 <Iceland_jack> One unrelated (and subjective) question: is the possibility of defining infix operators in Haskell a bad thing? I'd think it clashes pretty hard with keeping function names descriptive
08:29:34 <geekosaur> having to list every exeutable would be insane, and would rapidly hit process limits on the size of argv+environment
08:30:14 <efie> uh-oh
08:30:22 <efie> thanks, I will try it :)
08:30:34 <PedroWard> efie refers to the director
08:30:44 <bxx> is there a function that takes predicate and then groups elements into sublist?  doit even [1,1,1,2,2,3,4]  => [[1,1,1],[2,2],[3],[4]]
08:30:47 <PedroWard> scrub that
08:30:57 <Iceland_jack> bxx: group?
08:31:03 <Iceland_jack> > group [1,1,1,2,2,3,4]
08:31:05 <lambdabot>   [[1,1,1],[2,2],[3],[4]]
08:31:12 <PedroWard> group
08:31:12 <Iceland_jack> oh sorry, I didn't notice the predicate
08:31:14 <geekosaur> more generaly I think it's groupBy
08:31:17 <geekosaur> :t groupBy
08:31:20 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
08:31:25 <Iceland_jack> > groupBy even [1,1,1,2,2,3,4]
08:31:27 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
08:31:27 <lambdabot>              with actua...
08:31:32 <ion> > groupBy (==) [1,1,1,2,2,3,4]
08:31:34 <lambdabot>   [[1,1,1],[2,2],[3],[4]]
08:31:50 <dcoutts> bxx: in addition to groupBy, you usually need to sort first
08:32:09 <dcoutts> unless you know it's already sorted obviously
08:32:16 <bxx> that's perfect thanks, don't know how i missed it
08:32:17 <FireFly> > groupBy ((==) `on` even) [1,1,1,2,2,3,4]
08:32:19 <lambdabot>   [[1,1,1],[2,2],[3],[4]]
08:35:41 <t7> i think Set should be the default container
08:35:53 <t7> 80% of the time people need a set rather than list
08:36:23 <Iceland_jack> lists are way too imba in Haskell anyway..
08:36:25 <Philippa> eh. Often a multiset, or something else with different laws
08:36:52 <Philippa> Iceland_jack: you can eliminate them with a simple fold!
08:37:25 <Cale> I agree with the list default
08:37:43 <Cale> (I think lists are more important than people give them credit for)
08:37:57 <symplectic> how do I profile a multithreaded Haskell program? I'm just getting that it spends most of its time IDLE but I can't figure out why
08:37:58 <hiptobecubic> I second lists
08:38:05 <Iceland_jack> What I meant is that the whole Haskell language seems to revolve around lists, it provides a list `lookup' in the Prelude but you have to import Data.Set and Data.Map to use them, and they don't even have a reader syntax
08:38:07 <geekosaur> they're important, they're just abused for some things (many uses of strings...)
08:38:14 <hiptobecubic> I don't think people want unordered sets by default at all
08:38:24 <hiptobecubic> thanksgiving time. bbl
08:38:34 <Philippa> Iceland_jack: yeah. There's a good reason for it though - lists are loops in Haskell
08:38:34 <Cale> Iceland_jack: Well, lookup we could do away with mostly :)
08:38:38 <geekosaur> (sadly strings are a bit of a cesspool)
08:38:49 <Cale> But yes, lists are your loops in Haskell
08:38:57 <Philippa> Cale: butbutbut I'd have to import something extra when I'm writing a lazyass interpreter or typechecker!
08:39:09 <Philippa> (...but oh for a proper module system, once again)
08:39:13 <Iceland_jack> I mean lists are elegant in Haskell and they have a nice pattern-matching/inductive definition thing going for it
08:39:22 <Philippa> (who needs to declare the type classes when you can just infer the signatures?)
08:39:47 <Iceland_jack> but it means that people will favour lists for things where associative arrays or sets would be a better choice
08:39:54 <Iceland_jack> imo
08:40:01 <Cale> Iceland_jack: It's kind of like saying that people shouldn't write loops in imperative languages.
08:40:41 <Iceland_jack> Cale: Hm.. I'm not sure about that, this is just an idea that has been irking me for a some time
08:40:56 <Cale> We also have arrays and sets and maps, and people use them regularly
08:41:01 <Iceland_jack> I know.
08:41:08 <Cale> But when you want to iterate over such a structure, you make a list from it
08:41:41 <Iceland_jack> But in Haskell tutorials, lists seem overrepresented to me and the reason appears to be how accessible they are compared to other DSs
08:41:52 <Saizan> ocharles: yeah, it seems it's not straightforward to find them though
08:42:21 <Cale> They're overrepresented because introducing all the data structures at once would be confusing.
08:42:44 <Iceland_jack> Cale: I respectfully disagree
08:42:48 <Cale> But: Just as a loop either doesn't occur at all (perhaps its precondition isn't met) or consists of a single iteration followed by another loop, a list is either empty or consists of a single element followed by another list.
08:43:13 * hackagebot GenericPretty 1.2.1 - A generic, derivable, haskell pretty printer.  http://hackage.haskell.org/package/GenericPretty-1.2.1 (RazvanRanca)
08:43:30 <Cale> Because lists correspond to loops in this way, and iteration is a very common algorithmic tactic, lists are common in Haskell.
08:44:00 <typoclass> what's the thing that was removed this year, the Eq constraint for Num, wasn't it?
08:44:00 <Cale> So it pays to become extremely familiar with them right off the bat
08:44:13 <Cale> None of the other data structures will gain you as much expressive traction
08:45:09 <bgamari> symplectic, Have you tried threadscope?
08:45:11 <Iceland_jack> Fair enough, but there are also cases where you're not using lists to express algorithms but simply to store data
08:45:11 <Philippa> I dunno, you could go straight to generic stuff on algebraic datatypes? But then you probably fry your brain
08:45:34 * bgamari adores Threadscope
08:45:38 <typoclass> ... nvm, found it. Eq and Show constraint
08:45:56 <Philippa> Iceland_jack: I do it, because I'm lazy and I don't care that association lists are slow? But I also make myself abstract mildly, it seems to work as a trade-off when I decide I do care about performance later
08:46:12 <Cale> Iceland_jack: If you're using a list to store data, it's basically expressing the concept that you're eventually going to iterate over that data one element at a time eventually.
08:46:27 <Marr> i hear that recursion in haskell is very effective compared to recursion in other languages
08:46:39 <Cale> er, delete one of those occurrences of 'eventually' :)
08:46:48 <Iceland_jack> heh
08:47:23 <Philippa> Marr: recursion in strict languages that don't do tail call optimisation is rather limited by space behaviour, yeah
08:47:25 <Iceland_jack> Association lists just remind me too much of my time with Common Lisp
08:47:32 <Philippa> but it's more that many other languages are bad at recursion? :-)
08:47:46 <Philippa> Iceland_jack: Ah. That explains a lot :p
08:47:52 <Marr> what is tail call optimization?
08:48:22 <Iceland_jack> And it feels weird to me that a language with excellent map support doesn't make it a bit nicer to use
08:48:32 <Philippa> Marr: it's when you implement tail calls - calls that are the last thing a function does - in a way that ditches the existing function's activation record/stack frame
08:48:47 <Philippa> so you can have a recursive function run in constant space, for example
08:49:00 <Marr> ohh so the memory is only perminately stored if you need to use it later?
08:49:04 <Philippa> (or write one in that form where all the allocation is made explicit by passing everything that's still relevant along)
08:49:13 <osfameron> in languages like Perl, you usually have a way to optimize tail calls, but manually.
08:49:57 <Cale> However, tail call optimisation isn't something which really makes sense in the case of most Haskell (or lazy) evaluators, because there tends not to be a call stack in the first place
08:50:02 <Philippa> Marr: yeah, if you're only going to pass through rather than run more code on the way back you can skip it
08:50:10 <Cale> (and this is the case in GHC)
08:50:26 <Philippa> the new call just returns to wherever the old one was going to go
08:50:38 <Cale> Tail-call optimisation is important for implementing recursion efficiently in a strict evaluator with a call stack though.
08:50:46 <Marr> thats why its called a "lazy" functional language?
08:51:10 <Philippa> yeah, because typical implementations are based around lazy evaluation
08:51:27 <Philippa> (strictly speaking it's a non-strict language, but that's semantics. Except that means something for once)
08:51:29 <Marr> and also...what is this whole thing about maps?
08:51:49 <Marr> i know in java they are key/value objects
08:52:38 <Cale> Marr: There are two things: lazy evaluation (a particular order in which to evaluate expressions, along with a rule regarding not duplicating certain work, I'll explain that soon), and nonstrict semantics (if there is an evaluation order under which the evaluation terminates and produces a result, then it ought to terminate)
08:53:50 <Cale> Haskell as specified is just nonstrict -- the Report says nothing about what order to evaluate expressions in, but strict evaluation (where you always evaluate all the parameters to a function first) isn't good enough, because it won't terminate in some cases where another evaluation order will.
08:54:11 <Cale> However, lazy evaluation has the nice property that if there is any evaluation order which terminates, then lazy evaluation will.
08:54:12 <Philippa> Marr: yeah, that's more or less what Data.Map supplies in Haskell too
08:54:35 <elliott> maybe marr means the map function
08:54:38 <Philippa> you can also make a shoddy map out of a list of (key, value) pairs, and the functions to do it are in the Prelude. Which is what Iceland_jack was concerned by
08:54:45 <Philippa> elliott: point
08:55:10 <Cale> But in practice, like in GHC for example, smart implementations will adjust the order of evaluation to improve space performance.
08:55:18 <Philippa> the map function is something very different :-) It iterates along a list and applies a function pointwise to each value, spitting out a new list
08:55:24 <Philippa> > map (+1) [1,2,3]
08:55:26 <lambdabot>   [2,3,4]
08:55:56 <Marr> oh ok
08:56:04 <Cale> Marr: So, I'll give my favourite toy example to discuss evaluation orders. Suppose we have the program  double x = x + x, and we want to evaluate double (double 5)
08:56:15 <Philippa> we also have map functions for other data types, though they're usually named fmap
08:56:25 <Cale> Under strict (innermost-first) evaluation, it goes like this:
08:56:28 <Cale> double (double 5)
08:56:33 <Cale> -> double (5 + 5)
08:56:35 <Cale> -> double 10
08:56:39 <Cale> -> 10 + 10
08:56:41 <Cale> -> 20
08:57:04 <Cale> We could also try evaluating outermost-first, which would go like this:
08:57:08 <Cale> double (double 5)
08:57:14 <Cale> -> (double 5) + (double 5)
08:57:22 <Cale> -> (5 + 5) + (double 5)
08:57:25 <Cale> -> 10 + (double 5)
08:57:28 <Cale> -> 10 + (5 + 5)
08:57:31 <Cale> -> 10 + 10
08:57:32 <Cale> -> 20
08:58:07 <Cale> (i.e. find the outermost-leftmost reducible expression and reduce it)
08:58:20 <Cale> But you can see that we wasted a bunch of work computing double 5 twice
08:58:40 <Cale> because the x parameter to double occurred twice in its body, and we needed both copies
08:59:24 <Marr> ok
08:59:35 <Cale> So, we could resolve that any parameter to a function is evaluated at most once, and the result of that evaluation shared between occurrences.
08:59:45 <Marr> the syntax kind of reminds me of BNF grammar
09:00:19 <Cale> In real implementations, this tends to be represented by a graph structure where the occurrences of the variable will be pointers to the same place in memory.
09:00:35 <Cale> But I'll use let ... in ... syntax to represent this sharing
09:00:36 <Marr> ah ok
09:00:42 <Cale> So we'd get:
09:00:45 <Cale> double (double 5)
09:00:58 <Cale> -> let x = double 5 in x + x  -- we're still reducing the outermost double first.
09:01:07 <Cale> -> let x = 5 + 5 in x + x
09:01:11 <Cale> -> let x = 10 in x + x
09:01:27 <Philippa> Marr: it's a lot like applying productions as you parse, yes. Similar kind of formal system, only this one's turing complete
09:01:31 <Cale> -> 10 + 10  -- may or may not count as an actual reduction step
09:01:33 <Cale> -> 20
09:01:57 <Marr> ok
09:02:16 <ski> Cale : i'd argue that it's still good to know about and understand tail calls in Haskell, though it needs to be tempered by the fact that often you can be incremental instead
09:02:16 <Marr> and are any of you familiar with the implementation of skip lists?
09:02:18 <Cale> and this is what lazy evaluation is: outermost-first evaluation with the proviso that any parameter to a function is evaluated at most once
09:02:34 <Marr> i know that this is a data structure that is for OO programming
09:02:35 <Cale> ski: Yes, tail calls, but not tail call optimisation :)
09:02:41 <Marr> but i was just curious
09:02:56 <ski> Cale : but i'd say the basic idea of "proper tail recursion", that you can have an unbounded number of "active tail calls" in bounded space, still holds
09:03:07 <Marr> that makes sense
09:03:45 <ski> (and yes, "proper tail recursion" isn't really a good name for it, but it's the technical term we have)
09:03:51 <Marr> so in other words, in the recursion, instead of storing each iteration in the stack like java, haskell updates what the pointer is pointing to in memory
09:04:09 <Marr> and puts the old calls in the garbage collector?
09:04:14 <Cale> Marr: This is a very simplified model of what GHC will actually do when evaluating your program. In practice, it does a bunch of complicated analysis to decide when it's okay to evaluate the parameter to a function earlier, and "strictify" things.
09:04:46 <Cale> Marr: yeah, that's more or less right
09:05:05 <Cale> Marr: When you get down to the level of pointers, all the values get represented by pointers to code
09:05:23 <Cale> or expressions are, rather
09:05:48 <ski> Marr : consider `factorial 0 = 1; factorial n = n * factorial (n - 1)' -- to compute `factorial 3' naively by this, we need to compute `factorial 2', and *then* multiply the result of that with `3', to get the final answer -- the recursive call `factorial (n - 1)' here is *not* a tail-call
09:06:57 <Cale> and then the first time that you evaluate an expression, you jump to the code that the pointer points to, and that code overwrites the pointer with a pointer to a "blackhole" (which detects some infinite loops), then computes the value, and finally updates the pointer to a shorter piece of code which will return the value immediately
09:07:18 <ski> Marr : but for *tail-calls*, there's nothing to do after the tail-call yields a value, so in *that* case can we remove the information keeping track of what to do after the call (which in this case is just "pass the result back to the caller")
09:08:05 <Marr> so haskell is strictly a functional programing language?
09:08:17 <Marr> one cannot create objects like in python?
09:08:31 <elliott> depends what you mean by "objects"
09:08:40 <Cale> Marr: I would say that it supports object oriented programming better than most typed OO languages do, myself.
09:08:42 <atriq> You can make things that aren't functions
09:08:47 <elliott> Marr: you can certainly do object-oriented programming in haskell, though it's a different sort to Python
09:08:57 <ski> Marr : think of it like this : A sends a letter to B with instructions to perform a task, with a return address specified. B (after doing some work) delegates the rest of the task to C. if the result of C is the result of B, then B could forward the return address of *A* (instead of itself, B) to C, so that C will send the "letter" with the answer back directly to A
09:09:03 <Marr> ?? then why do people call haskell functional?
09:09:04 <lambdabot> Plugin `compose' failed with: Unknown command: ""
09:09:09 <elliott> because it is functional
09:09:11 <Cale> Marr: But it comes out a fair bit different than you might be used to
09:09:12 <Marr> is it because that is what it is mainly used for?
09:09:19 <elliott> Haskell has no special support for OOP
09:09:29 <elliott> it just has the necessary tools to structure programs in a way that resembles OOP
09:09:30 <typoclass> Marr: it is a functional language, yes. i wouldn't say "strictly functional", because functional programming is kind of a loose term anyway ...
09:09:39 <elliott> it'll make more sense if you learn the language
09:09:48 <Cale> Marr: Haskell provides many useful facilities for working with and manipulating functions.
09:09:49 <typoclass> Marr: haskell has lambdas (closures). that's the important thing :-)
09:10:02 <Marr> what are closures?
09:10:12 <Cale> Closures are an implementation mechanism for functions
09:10:21 <Philippa> Marr: all the computing is done by functions
09:10:23 <Cale> Haskell doesn't have closures, some implementations of Haskell do ;)
09:10:24 <ski> Functional Programming tends to focus on manipulating values via functions (which are also values)
09:11:08 <bxx> > groupByDigit = groupBy ((==) `on` isDigit)
09:11:10 <lambdabot>   <hint>:1:14: parse error on input `='
09:11:15 <Philippa> Marr: you can still embed other languages, in fact that's standard practice, but they're built in terms of functions still
09:11:27 <ski> @let groupByDigit = groupBy (equating isDigit)
09:11:30 <lambdabot>  Defined.
09:11:35 <neutrino> a closure is a syntactic scope which is neither global nor local.
09:11:39 <neutrino> and has some other properties.
09:11:43 <neutrino> that's my definition of it.
09:12:08 <elliott> that's not really what a closure is...
09:12:13 <bxx> I wanted to do (groupByDigit string1) < (groupByDigit string2), where list would contain both strings and integers. that won't work obviously. any other elegant way to do it?
09:12:20 <Philippa> a closure is a thing I just pulled out of my backside and wrapped in toilet paper to 'close' it...
09:12:39 <neutrino> i think that is equivalent to my definition
09:12:44 <ski> bxx : not sure what you mean. elaborate ? example ?
09:12:44 <Philippa> neutrino: I can see what you're getting at? But it's not a well-formed definition, it's open to misinterpretation :-)
09:12:47 <Cale> Marr: A closure is a pair consisting of (some representation for) a bunch of code which has free variables in it, along with a dictionary mapping those free variables to values. It's a structure which is often used to implement first class functions -- when you create a function, a pointer to the code for it is stored alongside a dictionary which captures the values of local variables at the place where the function is
09:12:47 <Cale>  defined.
09:12:53 <neutrino> but i'm not clear on the left-going implication
09:13:07 <Cale> Don't let people tell you that it's the same thing as a first class function -- it's the implementation mechanism.
09:13:25 <Cale> There are other implementation mechanisms for first class functions.
09:13:32 <typoclass> Cale: in what contexts does that distinction matter?
09:13:34 <bxx> ski I want to compare two strings, where number part of the string would be compared as number rather than a string. so "foo2" would be LT "foo10"
09:13:36 <elliott> I don't think talking about closures is really helpful for newbies, anyway... it's not usually an implementation detail that matters
09:13:38 <Cale> And also, it can be used to implement other things
09:13:48 <Iceland_jack> If I didn't know what Haskell was these explanations would just confuse me more..
09:13:50 <Cale> Like objects, or first class procedures
09:14:07 <elliott> Iceland_jack: agreed :P
09:14:09 <Cale> But "what is a closure" is not really a beginner question :)
09:14:20 <Cale> Nobody should have mentioned closures anyway :P
09:14:22 <ski> bxx : perhaps something with `span' ior `break' ..
09:14:30 <neutrino> Cale: from your definition, how can one define a function with a static value?
09:14:35 <arcatan> Cale: what would be some other implementation mechanismis for first-class functions?
09:14:37 <Marr> actually im ok with learning about closures..im definitely not a beginner programmer
09:14:42 <Marr> but i am new to haskell
09:14:53 <Cale> arcatan: Graph reduction
09:14:56 <bxx> closures aren't specific to haskell
09:14:57 <Iceland_jack> What's a function? “See for a Cartesian product A × B of domain A and codomain B where... currying... partial application... not the same as partial functions...) → confusion
09:15:01 <Cale> arcatan: (i.e. template instantiation)
09:15:20 <neutrino> arcatan: depth-first search.
09:15:23 <Cale> arcatan: Where we copy the body of the function and replace the occurrences of the variables with their values.
09:15:43 <typoclass> Iceland_jack: agreed :-/
09:16:08 <arcatan> Cale: okay, makes sense
09:16:15 <arcatan> neutrino: hmm?
09:16:17 <elliott> as t goes to infinity, the probability of #haskell trying a given explanation for something approaches 1 :P
09:16:23 <Iceland_jack> haha
09:17:05 <neutrino> arcatan: look at prolog
09:17:17 <neutrino> arcatan: it's basically a language for expressing search
09:17:18 <Cale> Marr: If you're interested in the really low-level details of how to do this stuff, there's a rather nice paper about it...
09:17:22 <neutrino> and you define all your functions in it
09:17:27 <Marr> Sooo about that " Halting Problem"...when you think about it, it really is possible to create a program that detects infinite loops
09:17:28 <ski> as Cale said, a closure is a way to implement a function value -- in the case the expression evaluating to it can depend on non-local-scope (but still not module-scope) variables
09:17:35 <Cale> http://www.ncc.up.pt/~pbv/aulas/linguagens/peytonjones92implementing.pdf
09:17:37 <Marr> you just have to define what infinite is, right?
09:17:38 <elliott> I don't think "depth-first search" is an implementation strategy for first-class functions.
09:17:59 <Cale> Marr: You can detect *some* infinite loops
09:18:06 <companion_cube> Marr: the problem is more general, it's about programs that do not terminate, not loops
09:18:06 <Cale> Marr: You'll never be able to detect them all
09:18:21 <Cale> (depending on what you mean by infinite loop)
09:18:32 <Marr> but if you define infinite as taking up a certain amount of memory
09:18:49 <Iceland_jack> Marr: You're possible confusing infinity with infinite loops
09:19:19 <Marr> ill be back guys
09:19:23 <Iceland_jack> Take care Marr
09:20:09 <neutrino> Cale: going from your definition of closure, how does one obtain a function with a static variable?
09:20:14 <atriq> Huh
09:20:15 <ski> Marr : considering the definition `foo x = \y -> y ^ x', then consider the following expression `map (foo 3) (0 : 1 : 2 : [])'
09:20:21 <Cale> Marr: For example, in Haskell's case, we can detect the infinite loops in programs like x = x + 1 -- when you try to evaluate x, it reduces to x + 1, and then (+) needs to evaluate its first parameter, which is x, which we were already trying to evaluate. So if you do this in Haskell you'll (usually) get an exception <<loop>> because the evaluation mechanism is clever enough to detect this.
09:20:23 <atriq> authenticate-oauth won't build
09:20:29 <notdan> Is there a special function for sorting an associative list on the second elements of a pair?
09:20:36 <notdan> Or do I have to use sortBy for that?
09:20:40 <Cale> neutrino: I'm not sure what you mean by "static variable" in this context.
09:20:59 <ski> Marr : one way of explaining how this can evaluate is :
09:20:59 <arcatan> neutrino: hmmh. i have to think about Prolog.
09:21:00 <atriq> :t sortBy (compare `on` snd)
09:21:02 <lambdabot> Ord b => [(a, b)] -> [(a, b)]
09:21:04 <Iceland_jack> notdan: You'd use something like sortBy (comparing snd)
09:21:07 <gwern> 'Today I'm announcing that I'm leaving Microsoft Research.  My plan is to take a break to finish the book on Parallel and Concurrent Haskell for O'Reilly, before taking up a position at Facebook in the UK in March 2013. ' o.0 o.0
09:21:09 <Philippa> ski, Cale: they're going :-)
09:21:15 <notdan> oh, comparing
09:21:23 <Philippa> gwern: yeah, odd, huh?
09:21:23 <notdan> thanks atriq Iceland_jack
09:21:24 <ski> hm, ok
09:21:31 <Cale> neutrino: But some languages also use closures to implement first class procedures rather than functions, which can have effects, and in particular, the code in the first part of the closure can update the values in the map which is the second part of the closure.
09:21:34 <neutrino> foo(int i = 0) { print i; i++; }; foo(); foo(); // prints 0, 1
09:21:39 <neutrino> this is what i mean Cale
09:21:44 <Iceland_jack> > sortBy (comparing snd) [(10,0),(9,2),(11,1)]
09:21:45 <lambdabot>   [(10,0),(11,1),(9,2)]
09:21:55 <gwern> Philippa: no kidding. why does facebook want a GHC guru? and what did they have to offer him to leave MSR, which I understand is a fantastic environment and the closest thing to Bell Labs these days?
09:22:00 <neutrino> a variable which basically does not reset value between function calls but is not global
09:22:00 <Cale> neutrino: But that's not a function, so again, closures and functions are two different things :)
09:22:01 <elliott> what is it with facebook buying all these haskell people
09:22:05 <elliott> are they planning a rewrite or something :P
09:22:11 <neutrino> Cale: why is that not a function?
09:22:26 <Cale> neutrino: Because it does not produce the same result for the same parameters.
09:22:30 <typoclass> i thought fb is using a fair bit of haskell internally ...?
09:22:34 <Philippa> gwern: heh, I guess I did get a free can of coke out of them last week ;-) But yeah
09:22:39 <elliott> I think they have some PHP program transformer in Haskell or something
09:22:40 <notdan> Is there a reverse comparing btw?
09:22:43 <notdan> Or should I reverse the list?
09:22:54 <prophile> facebook is trying to eat microsoft from the inside out
09:22:55 <Cale> notdan: sortBy (flip compare)
09:22:57 <neutrino> Cale: that's a function in terms of non-functional languages.
09:23:16 <neutrino> Cale: closures in those languages can be used to create functions with static variables like this.
09:23:16 <elliott> non-functional-langauge functions aren't mathematical functions
09:23:17 <gwern> typoclass: I've never heard of FB using haskell before but I haven't been following haskell stuff closely lately...
09:23:20 <elliott> *language
09:23:21 <Cale> neutrino: Right, but in our technical discussion here, I've been referring to that sort of thing as a procedure.
09:23:28 <notdan> Cale: thanks
09:23:36 <neutrino> Cale: you can use that nomenclature too, it's ok
09:23:51 <Cale> neutrino: Even if some people like to abuse the word function, it doesn't mean we have to ;)
09:24:03 <neutrino> Cale: how does one create the notion of static variables from your definition of "code plus dictionary"?
09:24:15 <neutrino> i'm just curious
09:24:17 <Cale> neutrino: By having the code update the dictionary
09:24:43 <neutrino> the dictionary is only available from the code, and not from the global scope, yes?
09:24:55 <atriq> Where the hell is Cabal getting authenticate-oauth-1.4.03 from
09:25:04 <elliott> is this even about Haskell any more?
09:25:06 <atriq> Hackage only has up to -1.4.0.2
09:25:24 <dcoutts> atriq: installed locally?
09:25:29 <Cale> Usually, yes. Though while this thing is still a closure and not abstracted into, say, a first class procedure, we can inspect that dictionary from outside and update it.
09:25:32 <atriq> Wait, that was my browser cache
09:25:38 <atriq> 1.4.0.3 exists
09:26:08 <neutrino> Cale: gotcha.
09:26:16 <arcatan> can i somehow reverse cabal-dev add-source?
09:26:30 <neutrino> elliott: given that cale's contribution to the channel is infinitely bigger than yours, i don't think you should be complaining about his choice of discussion topic.
09:26:54 <neutrino> Cale: ghc uses closures, right? can they be inspected in ghc?
09:26:55 <elliott> what?
09:27:20 <arcatan> i should learn to never use the next logical version name as the version for my custom hacked builds of packages :|
09:27:44 <Cale> neutrino: Via low-level hackery, yes
09:28:07 <neutrino> can i access this functionality from normal code?
09:28:12 <elliott> I don't see what this has to do with anyone's contribution to the channel at all
09:28:19 <Cale> yeah, there's even some libraries to make it a bit easier
09:28:25 <Cale> vacuum in particular
09:28:33 <neutrino> elliott: the connection is through common courtesy.
09:28:34 <Cale> But the direct way is using the GHC API
09:28:47 <neutrino> Cale: right, i thought the ghc api would tie in somehow.
09:28:54 <Cale> http://hackage.haskell.org/package/vacuum
09:29:13 <neutrino> last time i checked, i was fairly new to haskell, but it seemed like you couldn't call the ghc api from usual code easily? maybe i was wrong?
09:29:17 <Cale> http://hackage.haskell.org/packages/archive/vacuum/2.1.0.1/doc/html/GHC-Vacuum-ClosureType.html -- there are a large number of closure types in GHC :)
09:29:52 <neutrino> way cool
09:30:17 <ski> neutrino : you could perhaps think of it like `data a -> b = forall env. Clos# (# env , (# env , a #) #-> b #)', where `a #-> b' is the type of functions from `a' to `b' which doesn't depend on any locally computed values -- in terms of C, this could be a function pointer
09:30:45 <neutrino> what are locally computed values?
09:30:48 <ski> (and a value of type `(# a , b #)' is an unboxed tuple of an `a' and a `b')
09:33:20 <arcatan> …
09:34:01 <atriq> Can anyone else install authenticate-oauth-1.4.0.3?
09:34:11 <atriq> It fails for me in cabal
09:36:03 <neutrino> ski?
09:36:16 <ski> i'm trying to formulate what i mean
09:36:23 <Entroacceptor> atriq: RSA-1.2.1.0 depends on monadcryptorandom-0.5 which failed to install.
09:36:24 <Entroacceptor> ?
09:36:30 <neutrino> ok :) thanks
09:36:46 <Entroacceptor> oh, wait, that's my flawky connection
09:36:50 <atriq> Entroacceptor, "cabal update" first?
09:37:03 <atriq> This version just came out today
09:37:26 <Entroacceptor> oh, right, it was 1.4.0.2
09:38:49 <arcatan> atriq: the problem with deriving Ord PrivateKey?
09:38:59 <atriq> Yeah
09:39:21 <arcatan> i think you can cirmcumvent it by using crypto-pubkey-types 0.1.1 instead of 0.2.0
09:39:21 <ski> neutrino : taking `foo x = \y -> y ^ x', `foo (...)' (say `...' evaluates to `3' here, being dependent on user-input) will return a function value (which could be symbolized as `let x = 3 in \y -> y ^ x'), but since it depends on the locally-computed value `3', which couldn't have been computed at compile-time, ..
09:39:27 <ski> neutrino : .. we either have to (a) bundle up the value `3' (and a representation of the identifier `x') with (a representation of) the code `\y -> y ^ x'; or (b) we have to generate code at run-time, corresponding to `\y -> y ^ 3' (with the value `3' plugged in)
09:39:44 <andsens> Hey there, any specific channels regarding Parsec, or should I just post it here?
09:39:57 <arcatan> (or possibly by adding deriving instance Ord PublicKey to Web.Authenticate.OAuth :P)
09:40:04 <atriq> arcatan, that doesn't have an Ord instance either?
09:40:17 <atriq> andsens, here should be fine
09:41:22 <arcatan> atriq: the problem is that in 0.2.0, PrivateKey has a field of type PublicKey, whereas in the previous version it just had the three equivalent Integer fields
09:41:25 <ski> neutrino : the (a) case is a closure : a bundle of (in general several) computed values for free variables (above `x' and `(^)'), together with (a representation) of the code which contained the free variables (in this case `\y -> y ^ x')
09:41:40 <arcatan> atriq: and authenticate-oauth is deriving an instance for PrivateKey, but not for PublicKey
09:41:54 <andsens> OK, so I am trying to parse some mustache xml templates (http://mustache.github.com/). What I am wondering is, how I should classify strings like "<"  "/>" and the must ache specific ones "{{" and "}}"
09:42:07 <andsens> are the reservedOpNames in the LanguageDef?
09:42:16 <andsens> *are they
09:43:25 <ski> neutrino : and it's relatively common to represent this bundle essentially as `(Env {x = 3,(^) = ...},\(Env {x,(^)},y) -> y ^ x)', with `data Env = Env {x :: Integer,(^) :: Integer -> Integer -> Integer}', say
09:43:26 <donri> oh god |> is horrible, are people serious with that? o_O
09:43:58 <arcatan> i guess the Ord instances aren't actually used for anything, they're there just out of courtesy
09:44:05 <monochrom> andsens: I guess yes
09:44:10 <donri> hey let's change $ to <|
09:44:15 <dcoutts> donri: I don't understand why lenses etc want a reverse . anyway
09:44:18 <ski> neutrino : does it make any sense ?
09:44:24 <Cale> dcoutts: me too
09:44:34 <donri> dcoutts: shrug, "that OOP feel"? :)
09:44:40 <edwardk> dcoutts: its reverse ($) ;)
09:44:41 <andsens> monchrom: Thanks, I wasn't too sure, thought they should be symbols first, but that won't fly.
09:44:42 <Cale> dcoutts: Edward seems to think it makes more sense with all his funny operator symbols
09:44:46 <edwardk> reverse (.) already exists
09:44:47 <dcoutts> edwardk: oh yes, ok
09:44:53 <Cale> But I think everything reads just fine with normal (.)
09:45:08 <Cale> (though I use the funny operators a lot less)
09:45:15 <donri> reverse (.) is kinda horrible too, btw
09:45:51 <elliott> donri: wasn't (&) winning the vote?
09:46:04 <edwardk> yes
09:46:05 <donri> duno, looks to me like "no" is winning
09:46:20 <edwardk> donri: (&) is up 10.2 to 2.1 at last check.
09:46:30 <edwardk> there have been a couple of no votes, but not many
09:46:41 <Cale> What is this vote?
09:46:46 <elliott> needs some smartass to vote +pi to make edwardk's tallying life harder :)
09:46:48 <edwardk> on adding (&) to lens
09:46:55 <donri> Cale: lib ml
09:46:56 <Cale> What is (&)
09:47:01 <edwardk> elliott: meh, i'll just clamp it to 1 ;)
09:47:04 <elliott> Data.Function, not lens, isn't it?
09:47:06 <andsens> another more complicated question is this: How do I properly parse a random string until a reservedOpName is encountered?
09:47:11 <andsens> text = manyTill anyChar (try T.reservedOp) doesn't work...
09:47:15 <edwardk> it was (%) in lens, it got renamed in 3.4 after yitz's rant ;)
09:47:31 <edwardk> it avoids trompling Data.Ratio.% and it reads a little nicer.
09:47:36 <elliott> I mean, the vote is on adding (&) to Data.Function, not lens :)
09:47:43 <donri> Cale: Data.Function.& is a proposed flip ($)
09:47:47 <edwardk> er yes, to Data.Function =)
09:47:50 <Cale> I vote no on any kind of reverse application operator :P
09:48:01 <sclv> haha omg on my ghci 7.4.1 on os x, rounding a negative double apparently causes a segfault
09:48:04 <Cale> I would vote yes on flipping the *associativity* of ($) though ;)
09:48:05 <sclv> surely this must be fixed in head
09:48:24 <t7> Cale: is that a joke?
09:48:30 <Cale> t7: no
09:48:34 <edwardk> cale: you should do both, then your flipped associativity would drive more folks to use & ! =)
09:48:53 <Cale> edwardk: But I want it to drive more folks to use (.)
09:48:57 <elliott> Cale-associativity ($) and (&) might be a nice combo actually
09:49:05 <donri> i can see why people would oppose adding this to Prelude, but why so much resistance for just Data.Function?
09:49:34 <donri> edwardk: oh btw if they do add |> to base, please keep % or & in lens :P
09:49:54 <Cale> donri: It's one of those little innocuous things which once it's available, people might actually use it to write monstrosities.
09:50:03 <edwardk> anyways, so far they yes votes outweigh the no votes
09:50:07 <edwardk> things can change though
09:50:16 <atriq> Where is this vote?
09:50:22 <edwardk> libraries@ mailing list
09:50:31 <luite> sclv: yeah there were some weird problems with that on os x, was fixed in 7.4.2
09:50:44 <donri> can anyone vote?
09:50:51 <donri> i guess the vote is informal?
09:51:02 <sclv> thx for confirming it -- i found it sort of hilarious is all
09:51:14 <elliott> edwardk: (^!?), really :P
09:51:29 <sclv> donri: its semi-formal
09:51:49 <edwardk> elliott: i kept screwing up the order ;)
09:52:05 * Cale hopes that the issue of what to name the operator symbol causes flipped application to be bikeshedded into the ground
09:52:05 <sclv> there's no rules about who can vote, but if people whose votes seemed v. untrustworthy (i.e. random trolls, etc) started jumping in, i have no doubt they would be dismissed
09:52:09 <elliott> edwardk: that means less temptation to use it!
09:52:24 <elliott> you used the non-canonical order in an example btw, dunno if that was intentional :P
09:52:31 <andsens> monochrom: any chance you could answer my second question?
09:52:34 <edwardk> feel free to patch =P
09:52:47 <elliott> pfft
09:52:49 <sclv> and even though i think a majority should carry it, for controversial issues the guideline is more "clear consensus" if i recall?
09:52:53 <elliott> I won't let anyone blame me for that more than they already can
09:53:14 * hackagebot shell-escape 0.1.2 - Shell escaping library.  http://hackage.haskell.org/package/shell-escape-0.1.2 (JasonDusek)
09:53:39 <edwardk> we'll see how it goes. i'd like to have it standardized, but i could live with the whole thing getting shot down. its just nice to be able to use it consistently across packages
09:54:52 <edwardk> current tally: &: 6.2, |> -0.9, $. -5, # -3
09:55:43 <edwardk> anyways back to useful stuff =)
09:55:45 <typoclass> edwardk: well what about € ?
09:55:51 <edwardk> typoclass: currently 0 =P
09:56:06 <edwardk> actually it'd be -3 because there are 3 'no to all incarnations' votes
09:56:17 <edwardk> er 4 such.
09:56:42 <typoclass> i thought € had here and there been used as a flipped $
09:56:48 <typoclass> could be misremembering
09:56:57 <edwardk> its just untypeable to most users
09:57:23 <typoclass> altgr-e ...?
09:57:28 <int-e> (I think that if we used |> then . should be renamed to <| ... not likely to happen ;-) )
09:57:33 <donri> typoclass: not on US keyboards
09:57:55 <typoclass> donri: i see
09:58:14 <edwardk> int-e: (|>) and (.) are unrelated. (|>) is more correlated to ($)
09:58:16 <donri> int-e: you mean $
09:58:28 <int-e> donri: oh. true.
09:58:41 <donri> >>> is flipped (.)
09:58:57 <elliott> it's a shame (>>>) has such a long name
09:59:03 <geekosaur> with the wrong fiuxity
09:59:09 <elliott> (though I usually prefer (.) anyway)
09:59:20 <edwardk> clearly >>> should be ;
09:59:22 <prophile> welcome to haskell, where 3 characters is considered a long name :D
09:59:29 <bxx> what fixity should it have?
09:59:37 <typoclass> » is nearly as pointy and only one char 8-)
09:59:43 <donri> prophile: what other languages even have 3-character operators?
09:59:56 <elliott> Java has <<< and >>> too :p
09:59:56 <prophile> Java has >>> for logical shift right
10:00:11 <prophile> and many C like languages have >>= and <<= for assign-with-bitshift
10:00:18 <int-e> php has === ;-)
10:00:23 <prophile> so does javascript
10:00:26 <prophile> perl has <=>
10:00:29 <Cale> I say remove flipped application from all libraries, and let people define it in local scopes if they really want to use it.
10:00:29 <prophile> for compare
10:00:43 <donri> javascript has 'typeof' which is an operator ;)
10:00:44 <ski> (`=>>' and `=<<' ?)
10:01:00 <typoclass> Cale: you mean, standardize on reading right-to-left?
10:01:02 <prophile> and C has sizeof() :)
10:01:23 <typoclass> ooh, java has instanceof ;-)
10:01:36 <Cale> typoclass: Read from left to right anyway :)
10:02:22 <Cale> After all, of the three functions being composed in (f . g . h) x, under lazy evaluation f is the first one to be applied.
10:02:31 <int-e> clearly haskell needs an `infix'operator'with'a'name'so'long'that'nobody'ever'uses'it`
10:03:04 <typoclass> Cale: hm ... this might be my quirk, but i read "reverse . map" from right to left. are you proposing removing (.) or those newfangle (&) things people came up with?
10:03:07 <copumpkin> int-e: in scala, the following works
10:03:08 <copumpkin> def `def foo = (n: Int) => n + 1` = (n: Int) => n + 1
10:03:09 <int-e> and more ?????????????
10:03:24 <Cale> typoclass: I don't like the newfangled (&) things
10:03:35 <Cale> typoclass: and I think ordinary composition reads just fine
10:03:37 <typoclass> Cale: ok got you
10:03:38 <elliott> copumpkin: but if you do that, you can't support `flip map` :(
10:03:47 <copumpkin> sure you can
10:03:50 <copumpkin> just define something called flip map :P
10:04:40 <int-e> @hoogle for
10:04:40 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
10:04:41 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
10:04:41 <lambdabot> Foreign module Foreign
10:04:57 <typoclass> solution: throw the comparison stuff out of Prelude and use (>) and (<)
10:04:58 <typoclass> ;-)
10:06:45 <Cale> A nice thing about Haskell is that you can read expressions in any order, but that doesn't mean we ought to write them in every possible order :P
10:06:49 <cl1> happy thanksgiving! that is all
10:07:15 <int-e> mean do what you? Cale:
10:08:15 * hackagebot highlight-versions 0.1.2.1 - Highlight package versions which differ from the latest  version on Hackage  http://hackage.haskell.org/package/highlight-versions-0.1.2.1 (BrentYorgey)
10:09:30 <ramses_> @pl \f -> unzip . filter (not . (uncurry f))
10:09:30 <lambdabot> (unzip .) . filter . (not .) . uncurry
10:11:52 <Cale> ramses_: It may also help to note that if you import Control.Monad.Instances and/or Data.Function, you can write that as  fmap unzip . filter . fmap not . uncurry
10:12:54 <Cale> Which gives the idea that you're applying 'not', for instance, to the results of the function that's being manipulated
10:13:08 * edwardk contemplates a @uncale plugin that flips all uses of $ to &
10:13:15 * hackagebot lens 3.5 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.5 (EdwardKmett)
10:14:07 <edwardk> lens: now with 100% user-definable unsafeCoerce!
10:14:11 <edwardk> er 100% less!
10:14:14 <edwardk> freudian slip
10:14:39 <Cale> Where was the unsafeCoerce from?
10:14:41 <ramses_> Cale: interesting, I'll have a look at it :) The lambdabot output is terribly unreadable
10:15:07 <Cale> ramses_: It's not *that* bad once you're used to it, but yeah, I wouldn't tend to write things in that way, usually.
10:15:08 <edwardk> using 'EvilBazaar' and a custom Gettable instance that used coerce = undefined -- you could define unsafeCoerce
10:15:34 <Cale> Can we use this to hack the current instance of lambdabot :)
10:15:37 <donri> :t (&)
10:15:38 <edwardk> now to do so you have to import a module flagged 'Unsafe' in SafeHaskell and make a custom instance of 'Trustworthy' for your type, so the failure is then on your head
10:15:39 <edwardk> no
10:15:39 <lambdabot> b -> (b -> c) -> c
10:15:51 <edwardk> its requires an instance that doesn't exist
10:15:57 <edwardk> er it
10:16:04 <ramses_> Cale: I'm doing a university assignment, the professor wont appreciate it such code ;) But she's more of a prolog person anyway
10:16:13 <edwardk> https://github.com/ekmett/lens/issues/111
10:18:43 <edwardk> ick. i broke the safehaskell flag though. 3.5.1 coming up!
10:20:19 <Cale> ramses_: For example,  fmap not  is something which will negate any predicate -- in this case, it'll be the uncurry of some two-parameter function which produces a Bool result
10:20:29 <donri> edwardk: also you still have haddock links to EvilBazaar in Unsafe (other places?)
10:20:41 <elliott> I can't quite tell why edwardk needs unsafeCoerce just to have things work on Folds :P
10:20:46 <edwardk> donri: patch please? i'll fix the safehaskell bit
10:20:53 <Cale> ramses_: i.e. fmap not :: (a -> Bool) -> (a -> Bool) in this case
10:21:05 <edwardk> elliott: i invite you to make taking work with infinite traversals and infinite folds without it
10:21:12 <edwardk> if you can ill throw away BazaarT!
10:21:21 <ski> @type unzip .: filter . not .: uncurry
10:21:23 <lambdabot> (a -> b -> Bool) -> [(a, b)] -> ([a], [b])
10:21:23 <elliott> edwardk: well I have no idea
10:21:25 <elliott> but it seems weird!
10:21:49 <edwardk> it does, but its one of those things where when you've beaten on it long enough why it works becomes obvious. its hard to explain without the war wounds ;)
10:22:30 <ramses_> @t (.:)
10:22:30 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
10:22:33 <Cale> edwardk: Why it works, or why it's required?
10:22:36 <ramses_> @type (.:)
10:22:37 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
10:22:45 <edwardk> both actually
10:23:12 <edwardk> can someone help me figure out why Control.Lens in 3.5 isn't getting Safe-Inferred?
10:23:16 <edwardk> i can't see it
10:23:18 <ramses_> Cale: I'm working out the types on paper :) Its a good exercise
10:23:28 <ski> @type let infixr 9 .,.:; (.) = (Prelude..); (.:) = (.) . (.) in (.:)
10:23:29 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:23:35 <ski> ramses_ ^
10:23:52 <donri> edwardk: -fwarn-unsafe?
10:24:27 <Cale> I actually think that when it comes to these expressions involving (f .) and so on, thinking in terms of Functor actually makes things easier.
10:24:30 <donri> edwardk: https://github.com/ekmett/lens/pull/112
10:24:49 <Eelis> i always wonder: why, when ghc sees "forall", does it suggest RankNTypes instead of ScopedTypeVariables by default? ScopedTypeVariables would seem a lot more conservative and give you "forall"
10:25:01 <edwardk> donri: thanks
10:25:18 <Cale> After all, look at the type of (.:) when specialised vs. the generalised functor version -- generalisation actually tidies things up quite nicely there :)
10:25:32 <donri> edwardk: hm of course haddock won't make links for those because they're not imported... and if you import them you'll get warnings for redundant imports! :)
10:25:35 <edwardk> donri: no love from -fwarn-unsafe
10:25:48 <Philonous> Eelis:  Shouldn't that be ExplicitForAll ?
10:25:55 <edwardk> donri: i usually explicitly qualify the things within ''s if they aren't in scope
10:26:05 <Eelis> Philonous: never heard of it :) i always use ScopedTypeVariables :)
10:26:08 <edwardk> that makes my haddocks hell to read from the source code side, but it makes them hyperlink nicely
10:26:09 <ski> Eelis : there's also `ExplicitForAll' and `PolymorphicComponents'
10:26:19 <donri> edwardk: oh, you can do that? hm
10:26:24 <ski> (and `Rank2Types')
10:26:25 <ramses_> ski: that looks like a tough function for my not-so-used-to-haskell-yet brain!
10:26:30 <edwardk> 'Control.Lens.Traversal.Traversal'
10:26:50 <donri> i thought you had to import qualified for that
10:26:55 <edwardk> nope
10:26:56 <donri> and then you also get warnings anyway
10:26:58 <Eelis> ski, Philonous: cool, thanks
10:26:58 <donri> ok
10:26:58 <edwardk> works without any import
10:27:09 <edwardk> but if the link is to another module you get some bad behavior anywyas
10:27:10 <edwardk> ;)
10:27:12 <ski> ramses_ : `(.:) :: (c -> d) -> (a -> b -> c) -> (a -> b -> d)', is like `(.)', but passes two arguments to the function to the right
10:27:14 <edwardk> er i mean if its to another package
10:27:20 <edwardk> as long as its within the package it works
10:27:38 <ski> ramses_ : `(f . g) x = f (g x)' but `(f .: g) x y = f (g x y)'
10:28:09 <ski> (and of course `ExistentialQuantification' also uses `forall')
10:28:14 <donri> aha
10:28:16 <donri> makes sense
10:28:34 <ramses_> ski: yeah, I do get the types, I've written the same with some other name before, but the implementation is quite cryptic to me
10:29:06 <ramses_> ski: I see how it works out, but it's not intuitive (yet?)
10:29:12 <Cale> ramses_: You might picture a function s -> t as being a big container of some sort with "cubbyholes" indexed by values of type s, and each cubbyhole has a value of type t in it. Then fmap f will take such a function, and apply f to all the values in the cubbyholes (similar to what fmap does on lists then)
10:29:23 <ski> Cale : SEC:y `result' and `argument' could also be reasonably readable, i think
10:29:42 <Cale> and fmap f here is equivalent to (f .)
10:30:46 <Cale> ramses_: Does that make some amount of sense? :)
10:31:11 <ramses_> Cale: I'm not too sure what you mean by 'cubbyhole', I'm not a native english speaker...
10:31:27 <Cale> ramses_: Like what you have in a mail room where people receive letters
10:31:39 <ski> ramses_ : `(f .: g) x y = f (g x y) = (f . g x) y = ((f .) (g x)) y = ((f .) . g) x y' so `f .: g = (f .) . g' so `(.:) f g = (.) ((.) f) g = ((.) . (.)) f g', so `(.:) = (.) . (.)'
10:31:51 <jedai> ramses_: boxes
10:32:06 <ski> ramses_ : the more general type above in lambdabot is due to that lambdabot has `(.) = fmap', which is a generalization of `(.)'
10:32:11 <Cale> ramses_: and there's a grid of boxes labelled with people's names where letters are put for them
10:32:35 <ski> @wn cubbyhole
10:32:36 <lambdabot> *** "cubbyhole" wn "WordNet (r) 3.0 (2006)"
10:32:36 <lambdabot> cubbyhole
10:32:36 <lambdabot>     n 1: a small compartment [syn: {cubbyhole}, {pigeonhole}]
10:32:36 <lambdabot>     2: a small secluded room [syn: {cubby}, {cubbyhole}, {snuggery},
10:32:36 <lambdabot>        {snug}]
10:33:01 <edwardk> found it. because we're getting instances from an unsafe module Unsafe infects code using Gettable right now
10:33:13 <Cale> ramses_: That's abstractly like a function from people's names to their mail :)
10:34:17 <ramses_> Cale: okay, that makes your explanation more understandable :)
10:36:18 <ramses_> Cale: so fmap f actually applies f to the result of whatever function it is being applied to. Alright, I think I (almost) understand the line you gave me
10:37:12 <Cale> ramses_: and so  fmap f g  will be the function which at some position x will have the value f (g x)
10:37:21 <Cale> ramses_: So fmap here is just function composition :)
10:37:44 <johnw> ramses_: exactly.  just as fmap f (a,b) applies f to b, fmap f (a -> b) does as well, which works out to have the same meaning as composition, as Cale said
10:38:04 <Cale> I haven't talked about the pair instance of Functor
10:38:11 <Cale> but perhaps the list one is familiar
10:38:14 <ramses_> Cale: yeah, I notice now that the specialised type is indeed exact that of (.)
10:38:18 <Cale> (fmap = map in that case)
10:38:27 <Cale> ramses_: yeah :)
10:38:59 <ramses_> I'm familiar with the pair one, but I never used (->) a as a functor before
10:39:23 <donri> > 3 . [1,2,3]
10:39:25 <lambdabot>   [3,3,3]
10:39:34 <donri> caleskel is cuhrazy
10:39:44 <johnw> > fmap (const 3) [1,2,3]
10:39:46 <lambdabot>   [3,3,3]
10:39:48 <johnw> for the less insane
10:39:56 <elliott> with flip returned to its former glory it's only a matter of time until (.) is too :)
10:40:36 <Cale> elliott: The funny thing is, the very day that I replaced flip with its original version, I had someone who needed the generalised one :)
10:40:44 <elliott> "needed"
10:41:00 * elliott likes Cale-flip, but not its name
10:41:02 <TBJoe> is there an explanation how to install vacuum-cairo (win7) for very stupid idiots? everything i do fails :(
10:41:18 <Philonous> What's cale-flip?
10:41:27 <Cale> It's actually due to ski, iirc.
10:41:42 <Cale> :t flip
10:41:44 <lambdabot> (a -> b -> c) -> b -> a -> c
10:41:52 <Philonous> That looks rather mundane
10:42:08 <Cale> this can be generalised to (Functor f) => f (b -> c) -> b -> f c
10:43:33 <Philonous> @type flip (fmap . flip id)
10:43:34 <lambdabot> Functor f => f (a -> b) -> a -> f b
10:45:08 <gfrederi`> when I google 'haskell blowfish' it brings up the Codec.Encryption.Blowfish module on hackage
10:45:57 * gfrederi` tries to figure out if he has a question
10:45:57 <Cale> TBJoe: Do you have a working installation of gtk2hs?
10:46:25 <Cale> TBJoe: I'd start with that part -- I don't use windows myself, so I really have no idea, but it's supposed to work on windows.
10:47:23 <Philonous> gfredericks:  And you are surprised that google is actually useful? Sometimes I have that same issue. You should file a bug report with their search engine team.
10:47:54 <gfredericks> :)
10:47:56 <Cale> I think if there's a question, it might be about whether or not the Crypto package is still a good one to use.
10:48:08 <gfredericks> that was one question yes
10:48:10 <Cale> It was written long before ByteString existed.
10:48:12 <gfredericks> the other was how to use the Data.Word module
10:48:20 <gfredericks> Cale: is there an alternative?
10:48:24 <Cale> So, it could probably use some updating to be more convenient.
10:48:25 <TBJoe> Cale: i have installed it but dont know it it works properly :p
10:48:56 <Philonous> @hackage cyptocipher
10:48:56 <lambdabot> http://hackage.haskell.org/package/cyptocipher
10:49:16 <gfredericks> Philonous: thanks :)
10:49:35 <Philonous> @hackage cryptocipher
10:49:36 <lambdabot> http://hackage.haskell.org/package/cryptocipher
10:49:37 <gfredericks> 404'd
10:49:43 <Cale> TBJoe: Open up ghci and type  :m + Graphics.Rendering.Cairo  and see if you get an error
10:49:47 <Philonous> My mistake, can't spell
10:50:21 * gfredericks cabal installs cryptocipher
10:50:24 <bxx> I am not too happy with how I wrote this function. can someone think of a more concise and elegant way to do it? http://hpaste.org/78080
10:50:46 <TBJoe> it cant find it and suggests that i couldve meant Graphics.Rendering.OpenGL
10:51:48 <ski> @type uncurry (fmap . (,))
10:51:50 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
10:51:50 <Cale> bxx: Does this ignore non-digit characters when comparing?
10:52:12 <bxx> Cale no. it compares non-digital substrings as strings, and digital substrings as numbers
10:53:07 <Botje> bxx: so why not extract the number beforehand?
10:53:16 * hackagebot lens 3.5.1 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.5.1 (EdwardKmett)
10:54:50 <bxx> Botje can you elaborate
10:55:07 <Cale> bxx: My first reaction would be to first get hold of a function which splits a string into digit and non-digit sections.
10:55:38 <Philonous> Cale:  Isn't that what groupByDigit does?
10:55:43 <Cale> yes
10:55:44 <bxx> yes
10:56:34 <Cale> though, hmm, it would probably be good if that were  String -> [Either String Integer]
10:56:51 <ion> bxx: https://github.com/ion1/beagle_bone_pins/blob/master/Generate/NumCompare.hs
10:57:31 <Philonous> Cale:  Well, you can't read the integers beforehand because they are treated as strings when the corresponding section in the other string is not a number
10:58:09 <Philonous> Unless this function doesn't care about strings that start with digits
10:58:38 <Cale> I was thinking that a string which began with digits would be treated as a string which began with an empty string section :)
10:58:58 <Cale> But that might not actually be correct with respect to this
10:59:18 <Philonous> Cale:  That's not the semantics of the function as it is implemented, is it?
10:59:36 <Cale> Right, it's not
11:05:19 <ski> > unfoldr (fmap (((fst &&& fst . snd) &&& snd . snd) . fmap (span isDigit) . break isDigit) . (\l -> (guard . not . null) l >> Just l)) "foo39bar"
11:05:22 <lambdabot>   [("foo","39"),("bar","")]
11:06:32 <Marr> so a factorial function would be:
11:06:42 <hpaste> Cale annotated “collate” with “collate -- funny data-centric approach” at http://hpaste.org/78080#a78085
11:07:03 <Cale> That's not *quite* the same function, as we already know :)
11:07:11 <Philonous> Cale:  It might be close enough, though, because digits compare as LT to letters, so does the empty string
11:07:13 <Cale> But I think it's more sanely-behaved in some respects
11:07:39 <xunatai> newbie question: suppose i have a typeclass with a lot of parameters, what would be the easiest way of essentially making a copy with one just one of the parameters changed?
11:08:03 <Philonous> > ("123" `compare` "abc") == ("" `compare` "abc")
11:08:05 <lambdabot>   True
11:08:16 <Cale> xunatai: uhhh... can you give an example of what you mean?
11:10:25 <xunatai> sure, just as soon as i become un-confused
11:10:25 <ion> cale: The LeafS/LeafI data type thing becomes a bit less nice if you want to add a third type, e.g. for Debian-style version number comparison where '~' is < everything. With <https://github.com/ion1/beagle_bone_pins/blob/master/Generate/NumCompare.hs> you could just add a “NSTilde” data constructor to the beginning of NumSort and detect '~' in numCompare.
11:10:27 <Cale> xunatai: Typeclasses don't usually accumulate all that many parameters
11:10:46 <Cale> ion: That's true.
11:11:12 <Cale> ion: Well... you end up encoding a sort of finite state machine into the datatypes rather than the code.
11:11:37 <Cale> It's not *too* bad, but it's sort of weird :)
11:12:46 <TBJoe> a short question .. if i calculate a value in a function and use it twice, is haskell able to reuse it or does it calculate the expression 2 times? i mean something like 'f x = (bla x) ++ (bla x)' .. would it calculate '(bla x)' two times or just one time? would i have to write 'f x = value where value = (bla x)' to make it more efficient?
11:13:07 <Cale> TBJoe: The latter
11:13:13 <xunatai> i'll just say what i'm trying to do: i'm trying to hold a jumble of things together all in one big state, with ways of modifying small parts and producing a new big state
11:13:22 <Cale> It would calculate bla x twice if you write bla x twice
11:13:45 <ski> TBJoe : also s/haskell/GHC/
11:13:47 <Cale> TBJoe: Functions are not automatically memoised, but the value of a variable is computed at most once
11:14:02 <Cale> (under lazy evaluation or GHC)
11:14:22 <Cale> (or really, any reasonably sane implementation of Haskell)
11:14:38 <Cale> If you start memoising all the functions all the time, you can never garbage collect anything.
11:15:03 <TBJoe> but it could notice that the value is needed in the exact same function again :p
11:15:09 <Cale> However, it might be reasonable to try to detect occurrences of the same subexpression
11:15:22 <Cale> But this can cause an exponential blowup in space usage in some program
11:15:22 <Cale> s
11:15:29 <bxx> ion thanks for the link
11:15:29 <TBJoe> yeah right
11:15:36 <ski> TBJoe : yes, but sometimes doing that automatically can lead to a less efficient program
11:15:55 <Cale> So GHC won't do it automatically, at least.
11:16:07 <Cale> except in a very limited and unusual case
11:16:23 <Cale> where you have two nested case expressions which have the same scrutinee
11:16:24 <ion> bxx: Perhaps i should separate that to a package of its own and push it to Hackage.
11:16:44 <kini> huh? Data.Ratio can't deal with (a % b) % (c % d)?
11:16:46 <ion> There was a natural sort package in Hackage, but it did this horribly contrived thing involving AttoParsec and stuff.
11:16:51 <Cale> that's unlikely to appear in human-written code, but it shows up as GHC transforms things
11:16:53 <TBJoe> ok then ill just keep the where statement :)
11:17:23 <ion> kini: (a / b) / (c / d)
11:17:26 <Cale> kini: That's not well-typed
11:17:42 <Cale> kini: (%) :: a -> a -> Ratio a
11:17:59 <kini> Cale: so we can't have Ratio Ratio Int?
11:18:02 <Cale> sorry
11:18:05 <Cale> (%) :: Integral a => a -> a -> Ratio a
11:18:07 <ski> > (2 / 3) / (10 / 21) :: Rational
11:18:08 <ion> kini: If a and b are Integers, (a % b) / (c % d)
11:18:09 <lambdabot>   7 % 5
11:18:24 <Cale> :t ($)
11:18:26 <lambdabot> (a -> b) -> a -> b
11:18:26 <Cale> :t (%)
11:18:28 <lambdabot> a -> (a -> b) -> b
11:18:30 <Cale> lol
11:18:45 <elliott> heheh
11:18:46 <kini> huh? haha
11:18:49 <elliott> kini: just use (/) not (%)
11:18:52 <Cale> See, edwardk and his backwards function application
11:18:59 <ski> @type (Data.Ratio.%)
11:19:00 <lambdabot> Integral a => a -> a -> Ratio a
11:19:01 <Cale> are making it hard to talk about this :)
11:19:33 <kini> elliott: well I want exact arithmetic, doesn't / make floating points? (<- this is a statement that is probably full of stupid)
11:19:42 <ion> kini: No.
11:19:45 <ion> @type (/)
11:19:46 <Cale> kini: (/) :: Fractional a => a -> a -> a
11:19:47 <lambdabot> Fractional a => a -> a -> a
11:19:49 <ski> kini : no, `(/)' works fine for rationals
11:19:59 <atriq> You can use that with Rationals, yeah
11:19:59 <ski> kini : see my example above
11:20:11 <elliott> > 1/2 :: Rational
11:20:13 <lambdabot>   1 % 2
11:20:14 <kini> oh :o
11:20:26 <kini> I see, I see :)
11:20:26 <elliott> (%) shouldn't really exist, it is kind of pointless
11:20:40 <Cale> (%) isn't pointless...
11:20:44 <kini> thanks Cale, ski, ion, elliott!
11:20:45 <kini> Cale: ha.
11:21:06 <ski> kini : if you need to pass in integral numerator and denominator, you can use `%' -- if you just want to convert an integral number to a rational, you can use `fromIntegral'
11:21:29 <kini> ski: I just wanted to do a bunch of arbitrary precision multiplication and division
11:21:51 <kini> now I realize (I think) that I wasn't getting floats until I tried to putStrLn the stuff
11:21:51 * ski nods
11:21:54 <elliott> Cale: well, I don't like it much
11:22:21 <ski> kini : well, the context decides whether it's floating-point or rational or whatever from the start
11:22:28 <kini> ... oh wait, yeah...
11:22:34 <Cale> elliott: If you're going to complain that it makes it too easy to accidentally use Ratio Int, then my reply is that Int should be kicked out of the Prelude.
11:22:49 <ion> kini: putStrLn/print/show won’t convert Rationals to Doubles, but if you didn’t specify what type you want, it might have defaulted to Double. print (something :: Rational)
11:23:02 <elliott> Cale: my bigger complaint is that it's redundant to (/)
11:23:16 <Cale> elliott: But they have rather different types
11:23:25 <elliott> sure
11:23:29 <elliott> but I prefer (/)'s type :p
11:23:35 <ion> to (/),fromIntegral
11:23:37 <kini> :t (/)
11:23:38 <Cale> I suppose you could always write fromIntegral a / fromIntegral b and make sure there are enough type signatures around
11:23:39 <lambdabot> Fractional a => a -> a -> a
11:23:41 <bxx> ion that's a good idea (to to separate it and put it on hackage on it's own)
11:23:53 <elliott> Cale: right, but often you don't even have to do that
11:23:59 <elliott> for literals, (/) is fine, for instance
11:24:10 <elliott> we use fromIntegral when working with Doubles etc., why not with Ratios?
11:24:14 <Cale> Yeah, because those already have fromInteger applied :P
11:24:37 <Cale> Because if you're using Rational in the first place, you're probably working with exact discrete quantities somewhere
11:25:40 <Cale> (In my experience, you're almost always counting things of some sort)
11:26:02 <ski> @type ((/) `on` fromIntegral) `asTypeOf` (Data.Ratio.%)
11:26:03 <lambdabot> Integral a => a -> a -> Ratio a
11:26:43 <ski> @check \n d -> ((/) `on` fromIntegral) n d == (Data.Ratio.%) n d
11:26:44 <gfredericks> how do I get a [GHC.Word.Word8] from a String?
11:26:45 <lambdabot>   Not in scope: `myquickcheck'
11:27:08 <Cale> So it's a little more natural somehow to want to construct a rational in that way from a couple of integer values than it is in the case of floating point.
11:27:11 <ion> gfredericks: What result do you want for "☺"?
11:27:41 <gfredericks> ion: not too important to me; this is an error case
11:27:44 <ion> gfredericks: Also, do you really want [Word8] instead of ByteString?
11:27:55 <gfredericks> no I want a ByteString
11:27:57 <ion> If that is an error case, why have a String in the first place?
11:28:06 <gfredericks> but the ByteString constructors are from [Word8]
11:28:20 <gfredericks> I have a string because that's the left half of the Either
11:28:45 <gfredericks> returned from Crypto.Cipher.Blowfish.initKey
11:29:49 <ion> gfredericks: Data.ByteString.Char8.pack is a quick way to encode String as a ByteString using whatever encoding.
11:29:59 <mutha> why doesnt this work?  fromInteger (10 :: Int)
11:30:08 <ion> @type fromInteger
11:30:09 <lambdabot> Num a => Integer -> a
11:30:14 <ion> Int ≠ Integer
11:30:29 <ski> mutha : `10 :: Int' isn't an `Integer', it's an `Int' -- perhaps you wanted `fromIntegral' or wanted to use `Integer' there ?
11:30:54 <ski> > fromInteger (10 :: Integer) :: Rational
11:30:56 <lambdabot>   10 % 1
11:31:01 <ski> > fromInteger 10 :: Rational
11:31:03 <lambdabot>   10 % 1
11:31:04 <mutha> yes thanks. actually i didnt realize there were two functions
11:31:09 <ski> > fromIntgral (10 :: Int) :: Rational
11:31:11 <lambdabot>   Not in scope: `fromIntgral'
11:31:11 <lambdabot>  Perhaps you meant `fromIntegral' (imported fro...
11:31:15 <ski> > fromIntegral (10 :: Int) :: Rational
11:31:16 <gfredericks> ion: ah ha; thanks; I hadn't realized the diff between Data.ByteString.pack and Data.ByteString.Char8.pack
11:31:17 <lambdabot>   10 % 1
11:31:21 <ion> Also note that “fromInteger (10 :: Integer)” is a long way to write “10”.
11:31:49 * ski suspects that mutha didn't have a literal in the original code in question
11:32:25 <mutha> that is correct
11:33:11 <ski> mutha : unless you need to constrain the input to `fromIntegral', you probably don't need the type ascription on it
11:38:48 <gfredericks> is ByteString like a general replacement for String?
11:39:33 <atriq> No
11:39:43 <atriq> It's a replacement for strings of bytes
11:39:50 <atriq> Like, the raw data stuff
11:39:51 <gfredericks> for [Word8]?
11:40:03 <atriq> Yeah, and some uses of String
11:40:17 <atriq> If you want a type to use for text, try Text
11:41:30 <gfredericks> just trying to get a feel for the purpose of the different types
11:41:49 <atriq> If you want low-level, go for ByteString
11:41:56 <atriq> If you want high-level, go for Text
11:42:14 <andsens> I am going crazy trying to use anyToken in Parsec. Does anybody have some experience with it?
11:42:15 <atriq> If you want the joy of all the list functions defined elsewhere, go for String
11:43:43 * xunatai bangs head against wall trying to figure out how simulate state with monads
11:44:18 <gfredericks> atriq: thanks
11:44:30 <andsens> Wow, it's quiet here...
11:44:38 * xunatai bangs head louder
11:44:43 <andsens> there we go
11:44:48 <atriq> xunatai, Control.Monad.State
11:45:03 <atriq> Basically, a wrapper around s -> (a, s)
11:45:14 <tominator2> hi
11:45:27 <atriq> Hey, tominator2
11:45:29 <tominator2> Is there any way to :l two different files in GHCI?
11:45:39 <xunatai> i know about Control.Monad.State
11:45:41 <andsens> xunatai: Here's a good introduction. http://learnyouahaskell.com/for-a-few-monads-more#state
11:45:42 <xunatai> but that's it
11:45:54 <startling> xunatai, oh, it's easy.
11:46:00 <atriq> What else do you want with it?
11:46:19 <startling> xunatai, it's just a way to simplify state -> (value, state) functions into State value
11:46:25 <startling> er, State state value
11:46:59 <andsens> I can't figure this out: nodeData = try (manyTill anyChar anyToken) <|> many anyChar
11:47:09 <andsens> Please oh please some help. I am going insane here
11:47:27 <andsens> It breaks because anyToken is not supposed to be used like that
11:48:17 <andsens> ah, ok: nodeData = try (manyTill anyChar (try anyToken))
11:48:47 <andsens> but how the f.. do I get it to recognize my own tokens, Is that something that is hardcoded into Parsec?
11:48:59 <xunatai> my problem is i really just don't understand... stuff
11:49:04 <xunatai> i'll work through that LYAH page
11:49:19 <atriq> What are you having trouble with
11:49:21 <andsens> xunatai: read it twice at least.
11:49:29 <xunatai> i read half of it once
11:49:39 <Cale> andsens: You'd use the 'token' function in Parsec.Prim
11:49:41 <xunatai> 10 month ago
11:49:57 <xunatai> s
11:50:52 <Cale> xunatai: Do you understand how to simulate state just with plain function parameters?
11:51:05 <xunatai> well, yes
11:51:33 <xunatai> but
11:51:49 <andsens> Cale: Thanks, but how do I make the parser aware of it? The manual by daan doesn't talk about that
11:52:22 <andsens> Without haveing to create a scanner and all the other stuff
11:52:26 <sonOfRa> I am trying to remove certain elements from a list, I am using the following function: http://hpaste.org/78087
11:52:29 <xunatai> i'm not sure how to do that nicely if i have a zillion things in a state, and i just want to modify a part of it at a time
11:52:35 <sonOfRa> Is there a "smarter" way to do this?
11:53:03 <Cale> andsens: Oh, no, what I was describing was definitely for the case where you wanted to have a separate tokeniser (which you'd probably also write using parsec, but as a separate pass)
11:53:31 <andsens> ah, ok.
11:53:34 <xunatai> i have thing vague idea that i need to bundle a bunch so-called "state trasformers" int one "state transformer" to achieve what i want
11:53:50 <startling> xunatai: I think you're confused.
11:54:40 <Cale> xunatai: The problem of how to extract or to replace (in a pure way) some small part of a value with a different value is sort of what lenses are all about
11:54:56 <xunatai> never heard of lenses before
11:55:19 <andsens> Cale: my problem is that I have different operators like "<" and "/> (yes, xml). How can I define those tokens once, so I don't have to do the (try (reservedOp "<") <|> (reservedOp ">")….. (+8 more) all the time?
11:55:21 <tominator2> In GHCI, when I first :l file1.hs and then :l file2.hs I no longer have access to things in file1.hs. Is this how it's supposed to work?
11:55:31 <Cale> xunatai: But you perhaps should start just by writing some functions for doing that manually, because it's good to understand the plain way before you adopt fancy technology :)
11:55:36 <b_jonas> wasn't zippers, which was the previous big hype, also about replacing some small part of a value as well?
11:56:24 <startling> b_jonas, no, you're thinking of lenses
11:56:30 <Cale> andsens: Write a parser for each one of them which matches it along with an arbitrary amount of following whitespace (perhaps)
11:56:32 <peterjan> Hi, I'm wondering if one of you guys could help me out? I'm having some difficulty implementing some trivial exercise and i'm stuck on type matching error.
11:56:35 <andsens> zippers are for traversing stuff
11:56:53 <tominator2> peterjan, hpaste.org
11:56:55 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'j' & rezip
11:56:57 <Cale> andsens: and then combine those into a parser which parses any one of them and produces a value of some new token type
11:56:58 <nand`> the real hype is Traversal
11:56:58 <lambdabot>   ("jello","world")
11:57:09 <peterjan> @tominator2 thx
11:57:09 <lambdabot> Unknown command, try @list
11:57:10 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y' & rezip
11:57:12 <lambdabot>   ("jelly","world")
11:57:17 <nand`> I was about to say
11:57:39 <andsens> Cale: ok, seems like that is the only way. I hoped is was easier to integrate that stuff somehow.
11:57:44 <edwardk> b_jonas: zippers let you replace a small part of a structure by walking down to it. that zipper there though, is built by taking each of the steps as a lens or traversal ;)
11:57:57 <xunatai> i can see how to do it plainly, but i don't want to do this everywhere:
11:57:58 <xunatai> modHerpInGiantState giantState stuff1 stuff2 stuff3 herp stuff 4 = GiantState stuff1 stuff2 stuff3 herp stuff4
11:58:18 <Cale> andsens: Well, if you have any repeated section or pattern in your code, you ought to be able to extract that into a new definition...
11:58:19 <xunatai> her
11:58:24 <xunatai> er
11:58:27 <xunatai> i mean
11:58:42 <hpaste> “Peter-Jan Brone” pasted “Graph nodes” at http://hpaste.org/78088
11:59:08 <Cale> andsens: and for example you could write  choice . map try $ ops
11:59:27 <xunatai> modHerpInGiantState giantState herp = GiantState (stuff1 giantState) ... etc ... (herp giantState)
11:59:29 <nand`> my greatest dilemma is when factoring out the common bits is more work than simply repeating it twice
11:59:35 <andsens> Cale: THATS HOW! Thank you, I couldn't get that working properly
11:59:43 <nand`> work as in “complexity, lines of code”
12:00:09 <donri> also the point of zippers is that they let you keep a position in the structure without walking it all over again
12:00:17 <xunatai> is there a better "plain way" than that?
12:00:26 <nand`> donri: what was that called again?
12:00:34 <nand`> history?
12:00:34 <donri> what?
12:00:43 <donri> breadcrumbs? :)
12:00:55 <nand`> oh
12:00:57 <nand`> TApe
12:01:00 <Cale> xunatai: well, to begin with, there's the record syntax, which gives you a syntax for updating a single field
12:01:02 <nand`> Tape, even
12:01:02 <donri> ah
12:01:05 <peterjan> Could anyone consider helping me out with my problem? :) I'm sure you guys could easily fix it, it takes a 2 min. explanation though. (http://hpaste.org/78088) Also if this is not the usual way of doing things please let me know so i can address my issue properly.
12:01:07 <donri> in lens yea
12:01:18 <xunatai> how do i use record syntax to update a single field?
12:01:19 <Cale> xunatai: but you might still find that somewhat unpleasant, especially once you start nesting structures
12:01:34 <Cale> myRecord { fieldThree = newValue }
12:01:46 <andsens> Cale: muahaha! choice . map try $ map reservedOp operators      Thank you!
12:01:55 <xunatai> hm
12:01:59 <elliott> lens for haskell platform!
12:02:05 <Cale> andsens: btw, if you're parsing XML, why not use one of the existing libraries?
12:02:08 <edwardk> :t zipper ("hello","world") & down _1
12:02:10 <lambdabot> (Top :> ([Char], [Char])) :> [Char]
12:02:11 <elliott> andsens: choice . map try . map reservedOp $ operators
12:02:14 <elliott> andsens: is nicer
12:02:18 <tl`> I'm using vect and need to negate Normal3's components. Is making Normal3 instance of Num, defining 'negate' and leaving everything else undefined is okay? Or should I just keep is as another function, like 'negateNormal'? Is there a better way?
12:02:18 <edwardk> ^- that was designed to look like a breadcrumb trail
12:02:21 <elliott> or choice . map (try . reservedOp) $ operators
12:02:59 <Cale> :t down _1 . zipper $ ("hello", "world")
12:03:01 <lambdabot> (Top :> ([Char], [Char])) :> [Char]
12:03:09 <andsens> Cale: because I have template variables directly interleaved with XML. In attributes etc.
12:03:28 <Cale> andsens: In a way which wouldn't parse as XML?
12:03:32 <Cale> hmm
12:03:40 <tominator2> It seems as though it is not possible to pattern match on Data.Ratio values. I can't find any information about this on Google. Is this a known fact?
12:03:50 <andsens> mustache templates to be exact
12:03:50 <Cale> tominator2: That's true
12:04:01 <andsens> Stuff like <a href="{{link}}">
12:04:29 <tominator2> Cale, okay thanks. Any suggestion on what one might do instead? Guards perhaps?
12:04:38 <xunatai> anyway, thanks for pointing that out Cale, i didn't realize that before
12:04:40 <Cale> tominator2: It's somewhat by design. The internal constructor :% isn't exposed, and instead you have % which does reduction
12:04:45 <xunatai> that should hold me over for a bit
12:05:23 <Cale> tominator2: (i.e. divide out the gcd of the numerator and denominator)
12:05:39 <nand`> > let t = zipper [1..10] % fromWithin (traverse.filtered even) % save in fmap (view focus) $ restore t [2,4..20]
12:05:41 <lambdabot>   Just 2
12:05:48 <Cale> xunatai: and when you're fed up with that, you can move on to lenses :)
12:06:02 <edwardk> nand`: =)
12:06:02 <beaky> hello
12:06:03 <nand`> ah, so filtered doesn't behave nicely there
12:06:05 <Cale> xunatai: which are a bit nicer way to encode fields of datastructures and give you operations on them
12:06:07 <beaky> http://www.haskell.org/pipermail/haskell/2012-November/023566.html
12:06:15 <nand`> well, depends on what ‘nicely’ means
12:06:25 <edwardk> nand`: yeah
12:06:50 <edwardk> nand`: it has no way to remember which entries it dropped the first time
12:07:02 <edwardk> but filtered isn't a legal traversal
12:07:08 <edwardk> so shame on you ;)
12:07:11 <nand`> there should be some way to ‘find’ some focus matching a predicate
12:07:21 <edwardk> like a 'seek' or some such?
12:07:22 <nand`> without the use of ‘filtered’
12:07:24 <nand`> yeah
12:07:31 <nand`> ‘seek right even’
12:07:38 <edwardk> cute.
12:07:55 <edwardk> 'scan right even'
12:07:58 <edwardk> well, not scan
12:08:05 <nand`> or wrapRight or whatever that was
12:08:06 <edwardk> needs a nice less used name
12:08:18 * hackagebot codo-notation 0.5.2 - A notation for comonads, analogous to the do-notation for monads.  http://hackage.haskell.org/package/codo-notation-0.5.2 (DominicOrchard)
12:08:41 <edwardk> ooh, that even uses Control.Comonad now!
12:08:59 <nand`> seek :: ((a :> b) -> f (a :> b)) -> (b -> Bool) -> (a :> b) -> f (a :> b); I guess
12:08:59 <Cale> inb4 edwardk steals the name scanr
12:09:00 <nand`> for some f
12:09:05 <edwardk> Cale: =)
12:09:13 <edwardk> :t scanr1Of
12:09:15 <lambdabot> LensLike (State (Maybe a)) s t a a -> (a -> a -> a) -> s -> t
12:09:43 <edwardk> nand`: bah, but what if i want to seek down ;)
12:10:00 <nand`> hmm
12:10:10 <edwardk> (you need to cps that to handle the existential)
12:10:24 <nand`> ((s :> a) -> f (t :> a)) wouldn't work?
12:11:38 <nand`> oh, not for more than one iteration, at any rate
12:12:10 <b_jonas> peterjan: but what's your question about that paste?
12:13:11 <nand`> in my example above, f would need to be a monad, I guess
12:13:17 <lispy> Hello
12:14:16 <KBme> hi
12:14:17 <b_jonas> peterjan: if it helps, I'd probably write the first three functions using more library functions instead of directly like this, such as check :: [Bool] -> Bool; check = not . any; contains :: (Char, String) -> [(Char, String)] -> Bool; contains = elem;
12:14:27 <tominator2> Does anyone know about a module with a function primeFactors somewhere that uses a better algorithm than Trial Division, for example quadratic sieve? (Data.Numbers.Primes uses Trial Division)
12:14:46 <nand`> edwardk: at any rate, I don't see how seeking down can be realized without dependent types; the contents of the zipper can determine how many breadcrumbs the result will have
12:14:57 <peterjan> b_jonas: thx, i finally found my mistake :)
12:15:05 <peterjan> b_jonas: stuck on something else now but i'll find it! :p
12:15:18 <peterjan> b_jonas: also i will take a look at those library functions thx
12:15:47 <KBme> if I have a Module/ directory, Module/SubModule.hs file and want to be able to export Module *and* Module.SubModule, I should put everything I want in Module into Main.hs right?
12:16:09 <KBme> I mean Module/Main.hs
12:16:16 <mutha> is iyt possible to custom compare function to Data.Set and Data.Map?
12:16:20 <ski> @type not . any :: [Bool] -> Bool
12:16:21 <lambdabot>     Couldn't match expected type `[Bool]' with actual type `a0 -> Bool'
12:16:22 <lambdabot>     Expected type: [Bool] -> Bool
12:16:22 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> Bool
12:16:26 <mutha> to use*
12:16:38 <monochrom> no, you have to use a newtype
12:16:47 * KBme reminds himself: read the source luke
12:16:47 <asdfj> foo has type String but when i do > foo  in ghci,  it starts a newline and gives me "
12:16:48 <b_jonas> peterjan: for neighbours, you could use the Data.Maybe.mapMaybe function
12:16:55 <asdfj> what does this mean?
12:17:20 <nand`> asdfj: sounds like it's stuck evaluating the contents of ‘foo’
12:17:22 <asdfj> like it is asking for extra input
12:17:26 <nus> @hoogle sieve
12:17:27 <lambdabot> package NumberSieves
12:17:32 <peterjan> b_jonas: thx will do. I currently have no errors but faulty results :p debugging this is hard pf
12:17:33 <b_jonas> asdfj: probably an infinite loop
12:17:35 <nand`> > fix id :: String
12:17:39 <lambdabot>   mueval-core: Time limit exceeded
12:17:40 <asdfj> oh, thanks
12:17:44 <nand`> oh, right, that doesn't even produce output
12:18:13 <b_jonas> peterjan: is this some kind of graph thing?
12:19:03 <peterjan> b_jonas: yes it is :)
12:19:32 <tominator2> peterjan, what algorithm are you trying to implement?
12:19:43 <nus> tominator2, have a look at NumberSieves and arithmoi
12:19:52 <tominator2> thanks nus
12:19:58 * ski . o O ( `withCompare :: (Functor f,Functor g) => (a -> a -> Ordering) -> (forall b. Ord b => f b -> g b) -> (f a -> g a)' )
12:20:12 <asdfj> what would be the function   replace :: a -> a -> [a] ?
12:20:27 <peterjan> tominator2: it's a graph, each node has a color and arcs go both ways, neighbouring nodes have to have different colors
12:20:31 <peterjan> that's it
12:21:04 <peterjan> desired output:
12:21:05 <peterjan> Main> colored [('a',"rood"),('b',"blauw"),('c',"groen")] [('a','b'),('b','c'),('c','a')]
12:21:06 <peterjan> True
12:21:06 <peterjan> Main> colored [('a',"rood"),('b',"rood"),('c',"groen")] [('a','b'),('b','c'),('c','a')]
12:21:06 <peterjan> False
12:21:07 <b_jonas> so you want to check whether a coloring is valid for a graph?
12:21:18 <chersanya> anyone knows, is there a way to link a haskell program with very low memory? ld writes "/usr/bin/ld: final link failed: Memory exhausted"
12:21:42 <lispy> chersanya: yes there is a solution to this
12:21:48 <mutha> is there a type like Data.Set.Set that takes custom comparison function?
12:21:52 <peterjan> i receive a graph description and have to calc. if it's valid yes or no. It's valid when neighbouring nodes are different in color.
12:21:59 <lispy> chersanya: gnu ld doesn't like it when ghc splits haskell files into many .o files
12:21:59 <peterjan> are of a different color*
12:22:26 <lispy> chersanya: The problem can come up in several places, either in your $HOME/.cabal/config or when ghc was built
12:22:36 <peterjan> but I try to avoid library functions because it's for a homework, they will appreciate it more when i implement it myself.
12:23:01 <lispy> chersanya: Try setting split-objs: False in your cabal config (it should have an option commented out that mentions split-objs, just find it, uncomment it, and make it false)
12:23:09 <lispy> chersanya: if that works you're done. If not, I have other ideas.
12:23:39 <hpaste> “Peter-Jan Brone” annotated “Graph nodes” with “Graph nodes (annotation)” at http://hpaste.org/78088#a78089
12:23:57 <b_jonas> peterjan: I don't really understand what your code wants to do. I for one would have the outer loop iterate over the edges, and for each of them test whether their endpoints have different colors
12:23:57 <lispy> chersanya: I've never tried it, but possible the gold linker uses less memory
12:24:27 <b_jonas> peterjan: here your outer loop iterates over the vertices, which also works, but isn't the natural way I'd do this
12:24:27 <lispy> chersanya: in the worst case scenario, you need to rebuild your ghc with split-objs set to false in the ghc source tree (I have to do it this way on my linode)
12:24:35 <peterjan> b_jonas: It's not a graph like you are use to. It has 3 nodes and forms a triangle
12:24:40 <Shin-LaC> guys, I'm on OS X and I usually use homebrew to install/update/uninstall programs; should I install ghc and haskell platform via homebrew, or is it better to use the binary on the website?
12:24:43 <chersanya> lispy: no, it didn't help
12:24:55 <chersanya> I mean setting it in config
12:25:00 <peterjan> b_jonas: I updated the pastebin thing, could you just take one more really quick look. I'm error free but still not the wanted output.
12:25:01 <lispy> chersanya: Maybe try the gold linker?
12:25:12 <chersanya> hm, what is it?)
12:25:39 <lispy> chersanya: https://en.wikipedia.org/wiki/Gold_(linker)
12:26:14 <edwardk> nand`: it was somewhat tongue in cheek, but you maybe could do it with an appropriate rank3 type. i've done something somewhat similar before
12:26:25 <lispy> chersanya: I'm not sure how to make it the default linker or if it will solve the problem. If you're open to rebuilding ghc I do know that works and I know what to do
12:26:35 <b_jonas> peterjan: why are you checking each arc in both directions in first place?
12:26:41 <b_jonas> peterjan: isn't it enough to check in one direction?
12:27:22 <ski> mutha : no. you'd need something like ML module functors (or dependent typing) to have a type depend on a value like that. usually you define a wrapper `newtype' and make the instance you want for that one
12:27:25 <peterjan> b_jonas: you're right, I think you're right I'll check
12:27:44 <edwardk> e.g. (forall a b. (a :> b) -> a :> b :> c) -> (forall a' b'. (a' :> b' :> c) -> r) -> r
12:27:49 <ski> mutha : it might be possible to do something like the `withCompare' i pondered above -- perhaps using edwardk `reflection' package
12:27:56 <ski> @hackage reflection
12:27:57 <lambdabot> http://hackage.haskell.org/package/reflection
12:28:01 <tominator2> Shin-LaC, I used the binary (32Bit)
12:28:12 <chersanya> lispy: sounds interesting, yes, i'm open to rebuilding it))
12:28:26 <b_jonas> peterjan: but then I also don't understand your colored function. are you trying to search for a neighbour that has the same _name_ as well as color as your node?
12:28:34 <b_jonas> that doesn't seem to make sense
12:28:44 <b_jonas> why don't you search for a neighbour with the same color only?
12:28:51 <lispy> chersanya: get the source from here: http://www.haskell.org/ghc/download_ghc_7_6_1#sources
12:28:52 <ski> mutha : anyway, the main problem is that if you store the comparision function in the set, then if you got two sets to take the intersection or union of, how do you know the two stored comparision are compatible ?
12:28:59 <lispy> chersanya: it doesn't matter what version you use, but 7.6 is the latest release
12:29:50 <peterjan> b_jonas: for each node, I get all its neighbours, then if that node had the color red I use all those neighbours and check if the tupple (neighbour,color) is in the rest of my nodes list.
12:29:55 <Shin-LaC> I seem to remember that 32 bit was preferable to 64 bit
12:30:03 <lispy> chersanya: in the source tree we need to create a file: mk/build.mk
12:30:05 <Shin-LaC> but I don't see that notice any more on h-p or ghc's sites
12:30:14 <lispy> chersanya: it only needs to have one line:
12:30:15 <lispy> $ cat mk/build.mk
12:30:15 <lispy> SplitObjs          = NO
12:30:22 <peterjan> b_jonas: I'm sure it's not the most effective, it's my first go at it but i'm also sure that i'll find the solution if I work in that manner.
12:30:26 <lispy> chersanya: then build/install your ghc
12:30:58 <peterjan> b_jonas: so loop each node, get its neighbours, pair it with the node-color in a tupple and then check if that tupple is present in the graph description list.
12:30:59 <neutrino> ski: hi, reading what you wrote now
12:31:01 <ski> edwardk : do you happen to have a way to reify a comparision `a -> a -> Ordering' to a type `cmp' and some kind of `instance ..cmp.. => Ord (OrderedBy cmp a)' ?
12:31:05 <lispy> chersanya: to build and install you use the normal ./configure --prefix=whatever && make && [sudo] make install
12:31:17 <b_jonas> peterjan: but I'd really write this looping the other way in first place: first write a function findColor :: [(Char,String)] -> Char -> String; where (findColor c n) gives the color of the node n; then write a function coloredEdge [(Char,String)] -> (Char,Char) -> Bool; that checks whether a single edge is colored correctly; then write a function that checks all edges with this.
12:31:20 <edwardk> ski: you can write one with reflection, but i don't have it packaged
12:31:36 <b_jonas> peterjan: it sure works the other way too, but it's more confusing for me.
12:31:41 <chersanya> lispy: thanks, i'll start trying now
12:31:52 <lispy> chersanya: cool, good luck!
12:31:53 <peterjan> b_jonas: ok i'll try it your way
12:32:00 * ski is reading what neutrino wrote now
12:32:02 <chersanya> lispy: nooby question - should i remove existing ghc?
12:32:17 <Digihash> peterjan
12:32:27 <edwardk> ski: it'd basically be like https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs but for Ord
12:32:33 <peterjan> Digihash: yes?
12:32:39 <lispy> chersanya: no, they can live together. If you use the default prefix the new ghc will likely be first in your path.
12:32:52 <ski> mutha : see what edwardk said
12:32:58 <lispy> chersanya: if you don't ever plan on using the old ghc you might as well remove it though. It's broken, right?
12:33:12 <mutha> ski i figured comparison function would be part of the type, like in C++'s std::map
12:33:38 <edwardk> mutha: with reflection it does wind up part of the type, reified from the term you are using to compare with
12:33:50 <ski> edwardk : was there any reason for `M a s' rather than `M s a' ?
12:34:17 <edwardk> ski: sneakily it lets me use the "M a"  as p in reflect :: Reifies s a => p s -> a
12:34:18 <chersanya> lispy: by the way, how much memory did your server have? where you tried it
12:34:37 <edwardk> that lets me just reflect from an M rather than have to use scopedtypevariables or something
12:34:47 <ski> mutha : there can at most be one `Ord' instance for any type. since you presumably wanted a non-standard ordering, you need to (in one way or another) use a different type (which contains the value of the original type)
12:35:11 <edwardk> mutha: normally that is exactly what happens, we just call that modified type a newtype ;)
12:35:12 <ski> edwardk : i figured there was a reason, but didn't recall what it was. ty
12:35:32 <neutrino> ski: your explanation made perfect sense
12:35:41 <neutrino> i was going to ask you some questions but then you answered them too
12:35:44 <edwardk> but the issue is newtype based instances can't depend on part of the environment at the term level, which is what reflection is used for
12:35:49 <ski> neutrino : ooi, my explanation of what ? :)
12:36:16 <lispy> chersanya: 768megs? free -m is saying the total is < 500, but I think that's a bug
12:36:41 <lispy> chersanya: the linode website says it should be 512
12:36:58 <neutrino> ski: closures, we were talking about that 3h ago
12:37:11 <ski> neutrino : ah, ok
12:37:26 <neutrino> i had to go catch the bus (didn't catch it anyways)
12:38:43 <chersanya> lispy: mine has 256))
12:38:59 <Digihash> Hello
12:39:08 <chersanya> lispy: e.g. /bin/ will be suitable as a prefix?
12:42:31 <xunatai> are there any good haskell indentation plugins for vim?
12:43:10 <ski> neutrino : note that the common C idioms `typedef struct {void *data_ptr; result_t (*fun_ptr)(void *data_ptr; argument_t arg);} my_fun_t;' and `other_result_t blah(void *data_ptr, result_t (*fun_ptr)(argument_t arg), other_arg_t other_arg) {..data_ptr..fun_ptr..other_arg..}' correspond to `data MyFunT = forall env. MFT {data :: env,fun :: env -> ArgumentT -> ResultT}' and `blah :: (exists env. (env,env -> ArgumentT -> ResultT)) -> OtherArgumen
12:43:13 <lispy> chersanya: well, the default prefix is something like /usr/local and that puts my ghc in /usr/local/bin/ and the docs in /usr/local/docs
12:43:38 <Digihash> Hello everybody
12:43:46 <Digihash> I have the same thing like peterjan
12:43:53 <lispy> xunatai: I just use the default vim indentation: https://github.com/dagit/dotfiles/blob/master/.vimrc
12:43:53 <ski> neutrino : hm, probably cut off, near "ResultT)) -> OtherArgumentT -> OtherResultT' (which is basically the same as `blah :: forall env. env -> (env -> ArgumentT -> ResultT) -> OtherArgumentT -> OtherResultT')"
12:44:18 <lispy> chersanya: I don't know if 256 will be enough even after we disable split-objs :(
12:45:08 <b_jonas> Digihash: do you mean the same homework?
12:45:32 <Digihash> jep
12:45:45 <Digihash> I also have some trouble with it
12:46:13 <Digihash> But like you explained it, b_jonas, it's a good way of thinking. I'll first try it that way.
12:46:15 <Digihash> Thank you
12:46:46 <neutrino> OtherArgumen
12:47:14 <neutrino> buut i don't know C well
12:47:22 <neutrino> so i can't talk about "common" idioms
12:47:23 <beaky> I love C
12:47:30 <beaky> C is like the ultimate language
12:47:34 <beaky> for memory manipulation
12:47:42 <beaky> and for flipping bits
12:47:45 <t7> whats the opposite of exponent? like (^2) -> sqrt
12:47:46 <neutrino> except memory manipulation is boring
12:47:56 <t7> (^x) -> ?
12:48:03 <neutrino> ^(1/x)
12:48:04 <beaky> t7: the inverse of exponentiation is taking the logarithm
12:48:12 <neutrino> beaky: no.
12:48:16 <beaky> ah
12:48:20 <beaky> I'm mistaken :(
12:48:39 <neutrino> t7: notice that sqrt x == x ^ (1/2)
12:48:39 <xunatai> well, beaky is right, but that's not what t7 wants
12:48:43 <beaky> also sorry I thought this was the ##c channel :(
12:49:04 <ski> neutrino : in pseudo-C++, one could perhaps write the two former as `typedef local<T> struct {T *data_ptr; result_t (*fun_ptr)(T *data_ptr; argument_t arg);} my_fun_t;' and `template other_result_t blah<T>(T *data_ptr, result_t (*fun_ptr)(T *data_ptr,argument_t arg), other_arg_t other_arg) {..data_ptr..fun_ptr..other_arg..}'
12:49:10 <tominator2> What does double hash mean for a channel name?
12:49:22 <neutrino> ski: you're getting even further and further
12:49:23 <neutrino> :)
12:49:30 <FireFly> beaky: Haskell is better suited for flipping functions ;-)
12:49:32 <beaky> in freenode a double-hashed name is like a channel for a topic
12:49:36 <neutrino> please don't try cobol next ;)
12:49:44 <ski> (neutrino : sorry, in the earlier statement, `result_t (*fun_ptr)(argument_t arg)' should have been `result_t (*fun_ptr)(void *data_ptr,argument_t arg)')
12:49:49 <beaky> Lisp is for flipping entire programs :D
12:49:57 * neutrino 's head explodes
12:50:00 <ski> neutrino : further and further towards where ?
12:50:07 <Adeon\SIGSEGV> is there a language for flipping tables
12:50:08 <Eduard_Munteanu> t7: that's not an exponential, it's a power function
12:50:10 <neutrino> further from me understanding :)
12:50:17 <neutrino> i know little about C and C++ :)
12:50:19 <t7> yeah power
12:50:21 <FireFly> Adeon\SIGSEGV: many languages provide a transpose operation
12:50:37 <t7> im a wally
12:50:41 <FireFly> (which is kinda like flipping tables... if a table is a matrix and flipping is transposition)
12:50:44 <ski> neutrino : ok, then you can ignore my attempt to draw an analogy with idioms in C
12:51:19 <t7> 1,000,000 cubed is 100 then   1,000,000 ^ (1/3) = 100
12:51:27 <t7> i can math
12:51:29 <neutrino> ski: i promise i'll try to grok it later, but right now i'm a bit too tired to try and imagine what it might mean in C
12:52:12 <ski> neutrino : the main point is that we (a) keep the "source" of the function, `\y -> y ^ x' (but compiled into some more efficient representation), and we keep *on-the-side* the association from `x' to the value `x' had when the closure was created
12:52:19 <sipa> t7: 100 cubed is 1000000
12:52:50 <t7> yeah cube root
12:52:51 <t7> i mean
12:52:59 <ski> neutrino : so, each call to `foo x = \y -> y ^ x' will create a closure, where each such closure contains the *same* function pointer to `\y -> y ^ x', but (in general) *different* values for `x'
12:53:00 <t7> jeez, i'll get my coat
12:53:30 <neutrino> ski: yeah, basically we keep everything we need to compute a value without applying rewriting.
12:54:03 <ski> neutrino : the alternative to this is to *replace* `x' in (a copy of) the code `\y -> y ^ x' with the value `3', getting `\y -> y ^ 3' -- but for this, we need to be able to actually generate new code at run-time
12:54:20 <neutrino> ski: yeah, basically either you apply rewriting or not. i got it.
12:54:53 <neutrino> ski: and since you need to carry around dependencies if you don't apply rewriting, you get a new scope, which is where the closure scope comes from.
12:55:00 <neutrino> that's pretty cool.
12:55:07 <ski> neutrino : if you want, you can think of keeping the environment separate as "lazy substitution" -- we don't actually perform the substitution until the last possible moment : i.e. when the function is called with a value for `y', and we *need* the value for `x' to compute `y ^ x'
12:55:38 <neutrino> yep i got that
12:55:39 <neutrino> :)
12:55:41 <neutrino> thanks
12:55:46 <neutrino> that was a great explanation
12:56:08 <ski> (and this "lazy substitution" then just amounts to accessing the `x' field in the environment structure (which needn't be flat, that's up to the compiler))
12:56:09 <neutrino> i wonder if there's anything between rewriting and not rewriting... can you partially rewrite a function?
12:56:22 <ski> presumably
12:56:23 <chersanya> lispy: after several problems i've installed it)) now trying to compile with it...
12:56:36 <neutrino> for example
12:56:59 <ski> the simple case is when all the rewriting is performed statically, at compile-time
12:57:12 <neutrino> if your function has a general type, like say foo x = x + y would have type a -> a
12:57:22 <ski> (perhaps lambda-lifting or let-hoisting or something)
12:57:27 <neutrino> but if your closure says that y :: Int, then you can be sure that x has to be of type int too
12:57:34 <neutrino> so then your function becomes Int -> Int
12:57:52 <neutrino> this way you can possibly do some stronger type checking or optimization
12:58:14 <neutrino> what is lambda-lifting?
12:58:16 <ski> hm, yea but that's not (much) related to how it evaluates, that's the static semantics, the type checking
12:58:43 <ski> <http://en.wikipedia.org/wiki/Lambda_lifting>
12:58:47 <startling> neutrino, you turn closures into environment -> function functions.
12:58:54 <neutrino> you could also for example look at the source of the function and optimize some of it
12:59:20 <neutrino> for example, let's say foo x = if (x * y > 0) then 1 else 2
12:59:32 <ski> basically, it moves parts of the environment in the closure into proper arguments
12:59:39 <neutrino> if y = 0 then you can see that the function would evaluate to const 2
13:00:06 <neutrino> or let's say foo x = if (x * y > 0) then 1 + y else 2 + y
13:00:34 <neutrino> then if y == 0, foo x evaluates to 2 + y always
13:00:40 <ski> neutrino : hm, sounds like you're thinking about program specialization, such as *partial evaluation*, now
13:00:58 <neutrino> so you still have y as a free variable in the function code and it's not plugged, but it's partially optimized
13:01:03 <ski> (or possibly, staged programming, as in MetaML / MetaOCaml)
13:01:06 <neutrino> ski, i guess so yeah
13:01:07 <chersanya> lispy: now it gives even more "memory exhausted", for different libraries
13:01:49 <neutrino> basically, we plug y in for a second to see if any parts of our function fall away, but then make it a free variable again
13:06:45 <b_jonas> peterjan: try on these inputs: http://dpaste.com/834975/ . one of them is a proper coloring, the other isn't.
13:08:04 <peterjan> b_jonas: thx
13:08:27 <peterjan> b_jonas: i have inputs but thx :) not quite there yet but getting close!
13:09:09 <t7> proving the 4 colour theorem ?
13:13:58 <Digihash> Hello, I have a parse error on input -> What could the problem be?
13:14:26 <b_jonas> what parse error on what input?
13:14:53 <atriq> Digihash, did you forget to write "::"?
13:15:49 <lispy> chersanya: hmm
13:16:00 <lispy> chersanya: It's possible that 256 megs is just too few
13:16:21 <Digihash> Ah damm, so stupid
13:16:21 <Cale> Digihash: a large number of syntax errors
13:16:37 <Cale> oh, wow, atriq managed to nail it!
13:16:49 <chersanya> lispy: so i'm going to compile and link programs on my pc and upload them in binary
13:16:56 <lispy> chersanya: if it's still gnu ld that complains, you could try using the gold linker with the split-objs=No and see if the combination is enough to make it work
13:17:12 <atriq> Cale, he did mention "->", and it happens to me a lot
13:17:21 <Cale> yeah, I just realised that
13:17:29 <elliott> atriq: you're pioneering the next wave of psychic debugging
13:17:30 <Cale> I thought the -> was part of his sentence
13:17:42 <mauke> atriq++
13:17:55 <hpaste> sonOfRa pasted “How to indent where” at http://hpaste.org/78091
13:18:02 <sonOfRa> Style-related question
13:18:12 <Cale> sonOfRa: Firstly: do not use tabs
13:18:13 <sonOfRa> How do I "correctly" indent 'where'?
13:18:17 <sonOfRa> alright
13:18:19 <Digihash> It's fixed, I did forget the ::
13:18:34 <Cale> sonOfRa: Configure your text editor to replace them with spaces -- every good text editor has such a feature :)
13:18:37 <lispy> sonOfRa: I do the first style, but I only indent where by 2 spaces
13:18:38 <mauke> sonOfRa: I'd use the first version but with 4 spaces
13:19:01 <sonOfRa> I usually use tab = 4 spaces when replacing
13:19:17 <Cale> I would write one of:
13:19:22 <Cale> add' a b = c
13:19:27 <Cale>   where c = a + b
13:19:29 <Cale> or
13:19:33 <Cale> add' a b = c
13:19:35 <Cale>   where
13:19:40 <b_jonas> oh no, holy war
13:19:40 <Cale>     c = a + b
13:19:50 * lispy agrees with Cale 
13:19:55 <Cale> and the number of spaces involved doesn't matter
13:19:55 <lispy> oh wait
13:20:04 <FireFly> I'd probably go with the former of those
13:20:07 <lispy> Cale: er, I guess I don't usually indent the c line more than the where
13:20:07 <Cale> what matters is how things line up
13:20:20 <sonOfRa> Cale, assume more than one expression/function in where
13:20:27 <sonOfRa> even then, put one on the same line?
13:20:28 <mauke> sonOfRa: makes no difference
13:20:34 <lispy> I'm very concious of both long lines and deeply indented lines
13:20:35 <mauke> I'd rather write:
13:20:36 <mauke> add a b = c where
13:20:38 <mauke>     c = a + b
13:20:46 <Cale> sonOfRa: You may, just make sure that the rest of the block starts in the same column as the first definition
13:20:47 <nand`> the style I used to use for multi-line where blocks is to indent the ‘where’ by one space and the following line (definitions) by one space as well, such that the overall indentation for the definitions was 2
13:20:56 <mauke> but normally I put the 'where' on a line of its own
13:21:04 <lispy> mauke: but written that way I would be compelled to line up the =s
13:21:06 <nand`> but I think I'll start using the style where the definitions start on the same line as ‘where’; because it saves a SLOC
13:21:13 <Cale> I don't like mauke's style there, because the 'where' is really part of the definition of 'add' and not the expression on the right of the =
13:21:15 <mauke> lispy: you're weird
13:21:23 <Cale> and moving it down a line makes that clearer
13:21:27 <mauke> Cale: but that's not how the grammar works
13:21:30 <nand`> not sure whether the extra few colums you can squeeze in is worth the line spent
13:21:44 <Cale> mauke: Of course, your version is legal
13:22:02 <mauke> so is yours
13:22:08 <lispy> add a b = let c = a + b in c
13:22:10 <sonOfRa> nand`, why so fixed on saving SLOC? never really understood that measure
13:22:10 <Cale> But I tend to think the layout rules are a bit lax :)
13:22:18 <lispy> there we go, no where to fuss about :)
13:22:32 <Cale> sonOfRa: It's more a matter of how it lies on the page than anything.
13:22:34 <mauke> the point is that [add a b = c where] is part of the outer context while [c = a + b] is part of a nested { } block
13:22:57 <Cale> sonOfRa: I would tend to newline after the 'where' if I expected the stuff which I was putting in the 'where' block to be long.
13:23:10 <Cale> sonOfRa: because it saves horizontal space
13:23:11 <sonOfRa> So, all in all, there is no real "convention" on how to correctly indent 'where'
13:23:31 <lispy> sonOfRa: there are a few popular styles, but no style that dominates
13:23:32 <Cale> sonOfRa: The only convention is to make things line up nicely whenever possible :)
13:23:43 <Cale> and DON'T USE TABS
13:23:50 <sonOfRa> Sir yes sir.
13:24:00 <mauke> sonOfRa: well, the convention I use is your #1
13:24:02 <hpaste> theezakje pasted “list of tupels out of 2 lists of tupels” at http://hpaste.org/78092
13:24:04 <Cale> (they will make your life horrible later if you do)
13:24:06 <lispy> Does the wiki document coding styles?
13:24:13 <lispy> Or maybe a wikibook article?
13:24:30 <theezakje> Hello, I'm quite a newbie and I posted a question in a paste: http://hpaste.org/78092
13:24:35 <Cale> sonOfRa: You might look here, though you will mostly find the same thing we told you: http://urchin.earth.li/~ian/style/haskell.html
13:24:39 <lispy> sonOfRa: did you find this already? http://urchin.earth.li/~ian/style/haskell.html
13:24:41 <nand`> I'm also not sure how bad it is use inconsistent coding styles throughout a single module
13:24:53 <nand`> because depending on the situation, one style may fit better than the other
13:24:59 <theezakje> could anyone take a quick look? I suppose it's quite a simple problem
13:25:02 <mauke> theezakje: something involving map and lookup
13:25:21 <Cale> sonOfRa: I also am not sure about the line length thing that document mentions -- sometimes, given the fact that I'm always on an X terminal which is potentially very wide, it's more comfortable to adopt a longer line limit.
13:25:22 <theezakje> hmm
13:25:38 <b_jonas> @let petersenGraph = [('2','3'),('0','1'),('9','4'),('9','0'),('6','0'),('8','5'),('6','5'),('8','4'),('2','7'),('6','7'),('2','1'),('9','3'),('5','3'),('4','7'),('8','1')]
13:25:40 <lambdabot>  Defined.
13:25:42 <sonOfRa> I'm usually using 80 or 100
13:25:50 <Cale> sonOfRa: But if things get "too long", I will start to wrap them nicely, and line them up.
13:25:54 <b_jonas> @let coloring0 =
13:25:55 <lambdabot>   Parse error: ;
13:26:07 <b_jonas> @let coloring0 = [('0',"yellow")('1',"blue")('2',"yellow")('3',"blue")('4',"yellow")('5',"yellow")('6',"blue")('7',"red")('8',"red")('9',"red")]
13:26:09 <lambdabot>  <local>:10:14:
13:26:09 <lambdabot>      The function `('0', "yellow")' is applied to 9 arguments...
13:26:18 <lispy> I like to make vertical columns in the code whenever it permits it
13:26:33 <lispy> This makes future edits with rectangular commands easier
13:26:33 <b_jonas> ah
13:26:46 <gulk> yellow fellas.
13:27:08 <mauke> wello
13:27:09 <lispy> So I make my "<-" line up, my "=" and all that jazz
13:27:20 * nand` obsessively aligns
13:27:36 <gulk> i have a haskell newbie question
13:27:44 <theezakje> the problem is mauke that I cannot make use of the Data map type
13:27:45 <nand`> the worst part is when I have a list that I split up over three lines, I'll make all of the ,s line up as well, so the resulting colums are all the same width
13:27:53 <gulk> how does one make a simple function to return a random number
13:27:58 <gulk> lets say
13:28:00 <theezakje> any idea if its possible using something else, maybe list comprehension(s)?
13:28:01 <nand`> this can occasionally result in situations that take a lot of adjusting to ‘settle’
13:28:04 <mauke> theezakje: how is that a problem?
13:28:10 <gulk> (rN,rN,rN) for rbg
13:28:14 <nand`> it's even harder when I need to align elements inside those list colums
13:28:16 <nand`> +n
13:28:19 <mauke> theezakje: use map and lookup
13:28:19 <b_jonas> peterjan: syntax error fixed (no more missing commas, I hope): http://dpaste.com/834990/
13:28:31 <b_jonas> @let coloring0 = [('0',"yellow"),('1',"blue"),('2',"yellow"),('3',"blue"),('4',"yellow"),('5',"yellow"),('6',"blue"),('7',"red"),('8',"red"),('9',"red")];
13:28:33 <lambdabot>  Defined.
13:28:42 <b_jonas> @let coloring1 = [('0',"yellow"),('1',"blue"),('2',"blue"),('3',"yellow"),('4',"yellow"),('5',"blue"),('6',"blue"),('7',"red"),('8',"red"),('9',"blue")];
13:28:44 <lambdabot>  Defined.
13:28:45 <theezakje> problem is the input arguments are both LISTS
13:28:45 <nand`> sometimes I feel I spend more time aligning and fitting things into 80col than I do actually writing new code
13:28:59 <mauke> theezakje: how is that a problem?
13:29:06 <theezakje> hmmm
13:29:16 <theezakje> I'm really new, I've never used the map datatype
13:29:59 <mauke> theezakje: there is no "map datatype"
13:30:07 <mauke> types start with an uppercase letter
13:30:33 * nand` .oO( exists map. )
13:30:36 <hiptobecubic> gulk, without diving too deeply, that requires doing IO
13:31:00 <edwardk> :t M.fromList
13:31:01 <gulk> i tried
13:31:01 <gulk> rN :: IO Int
13:31:02 <gulk> rN = randomRIO (0, 255)
13:31:02 <lambdabot> Ord k => [(k, a)] -> M.Map k a
13:31:02 <nand`> gulk: that's a bit contradictory
13:31:02 <theezakje> so I should implement my own map type with own lookup function :s?
13:31:06 <nand`> functions don't return random results
13:31:19 <gulk> it works ok, until i call it inside another fuction
13:31:20 <edwardk> that M is in Data.Map
13:31:26 <gulk> to try passing it as int
13:31:32 <edwardk> er rather M is an alias for Data.Map in lambdabot right now
13:31:39 <b_jonas> ah, so theezakje is also solving the first step of the same homework as peterjan and Digihash?
13:32:20 <b_jonas> looking up the colors of nodes in an association list representing a coloring
13:32:30 <mauke> theezakje: you can't implement a "map type". types start with an uppercase letter
13:32:38 <theezakje> yes b_jonas :)
13:32:54 <ion> edwardk: The lens operator prefix: http://www.charbase.com/1f4f7-unicode-camera
13:33:05 <edwardk> ion: =)
13:33:14 <mauke> gulk: that's not a function
13:33:16 <theezakje> any ideas b_jonas ?
13:33:23 <fjh> theezakje: there is a function called "lookup", which works on association lists
13:33:33 <nand`> lispy: “Our favourite revision crontrol [sic] system” links to darcs; all is well in the world :)
13:33:35 <mauke> theezakje: are you just going to ignore me now?
13:33:38 <b_jonas> theezakje: first, write a function that looks up the color of just one node in the assoc list of colors
13:33:39 <gulk> mauke any thoughts on how could i do that?
13:33:47 <b_jonas> theezakje: use these colorings at http://dpaste.com/835013/
13:34:02 <mauke> gulk: do what?
13:34:08 <nand`> gulk: you can't, without breaking some laws
13:34:23 <b_jonas> theezakje: and write a function findColor :: [(Char, String)] -> Char -> String; such that (findColor coloring1 '3') evaluates to "blue"
13:34:40 <b_jonas> theezakje: then, once you have that function working, write the function you want by calling this function
13:34:46 <b_jonas> so break it down to smaller parts
13:35:47 <ion> http://www.charbase.com/1f52e-unicode-crystal-ball
13:35:49 <b_jonas> fjh: yes, (flip lookup) does exactly this first part, but apparently at least peterjan wants to learn how to recurse over lists by hand first, before using those library functions
13:36:15 <fjh> ah, right
13:36:20 <gulk> mauke get random ints lets say to get a random color (r,b,g) beeing them int
13:36:52 <mauke> gulk: liftM3 (,,) rN rN rN
13:37:14 <b_jonas> > flip lookup coloring0 '3'
13:37:17 <lambdabot>   Just "blue"
13:37:21 <b_jonas> well, almost
13:37:27 <b_jonas> > (fromJust . flip lookup) coloring0 '3'
13:37:29 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe b0'
13:37:29 <lambdabot>              with actual...
13:37:33 <lispy> nand`: sorry?
13:37:48 <lispy> nand`: oh I see
13:37:48 <nand`> lispy: you linked to http://urchin.earth.li/~ian/style/haskell.html earlier
13:38:16 <b_jonas> > ((fromJust .) . flip lookup) coloring0 '3'
13:38:18 <lambdabot>   "blue"
13:38:22 <b_jonas> better
13:39:03 <nand`> on the topic of style guides, what's the preferred way to indent haddock comments? Add an extra two spaces at the start of each comment (to match the '| ') or not?
13:39:29 <Digihash> Thank you b_jonas for your idea of implementing this problem. It almost works
13:40:02 <lispy> https://en.wikibooks.org/wiki/Haskell/Indentation
13:41:05 <Digihash> So I have a function that checks wether 2 nodes in the grpah have the same color or not. Then I return a boolean of that. But my problem is now that if I run over the list of tuples (nodes connected to each other), I don't really see how to check if everything is ok
13:41:05 <donri> nand`: seen both, prefer matching myself currently
13:41:36 <lispy> http://www.haskell.org/haskellwiki/Category:Style
13:41:45 <Digihash> now I now if one check returns False, my whole solution is false
13:41:48 <ion> edwardk: Why are there two identical operators for (^?!)?
13:41:54 <gulk> with the same "function" i pasted before?
13:42:34 <Digihash> But how can I check wether everything is ok and I can return true
13:42:53 <b_jonas> Digihash: then change your code so you get True as the final result only if you get False for every element of the list
13:43:18 <theezakje> any tips on couldn't match type b with Maybe b?
13:43:55 <hpc> theezakje: i assume that's a ghc error?
13:43:59 <theezakje> yes
13:44:52 <hpc> somewhere in your code you are using a value of type (Maybe b) as if it were b
13:44:54 <hpc> or vice-versa
13:46:05 <t7> 25cm^2 = 625cm   0.25m^2 = 0.06m ?
13:46:12 <t7> wut
13:46:30 <troydm> it's correct
13:46:46 <troydm> no wait
13:46:50 * b_jonas is reminded to the "O HAI I fixed ur type error" lambdacat
13:46:51 <troydm> it's not
13:47:47 <t7> doesnt work for numbers < 1 ?
13:48:01 <peterjan> b_jonas: thx for your help, got it.
13:48:25 <booski> (25cm)^2 = 625 cm^2, (0.25m)^2 = 0.0625 m^2 ?
13:48:26 <b_jonas> peterjan: have you find the two edges that break one of the colorings? which edges are they?
13:48:40 <b_jonas> or at least one of the two edges
13:48:54 <nand`> t7: (25 cm)^2 = 625 cm²; (0.25 m)^2 = 0.0625 m²
13:48:54 <theezakje> peterjan could you lend me a hand :)?
13:48:56 <nand`> I don't see the problem
13:48:58 <peterjan> I couldn't use your input cause of the numbers instead of characters to indicute nodes
13:49:08 <b_jonas> peterjan: what? it totally has characters
13:49:10 <peterjan> theezakje: nog een van 't schakeljaar toch ni
13:49:21 <theezakje> haha :p
13:49:22 <peterjan> b_jonas: ? i'll check again just a sec
13:49:24 <b_jonas> @type petersenGraph
13:49:25 <lambdabot> [(Char, Char)]
13:49:28 <b_jonas> it says Char
13:49:37 <b_jonas> no number anywhere
13:49:40 <sipa> t7: 1 cm^2 == 0.0001 m^2
13:49:54 <sipa> as there are 10000 square centimeters in a square meter
13:50:02 <theezakje> idd peterjan
13:50:09 <b_jonas> theezakje: but where are you stuck? why don't you show us what works and what doesn't?
13:50:12 <sipa> tsss al dat genederlands here...
13:51:13 <theezakje> I'm stuck at the following
13:51:46 <theezakje> If i get a list of tupels with colors like: [("red","yellow"), ("blue", "green")]
13:51:53 <theezakje> then my problem is fixed
13:52:16 <Digihash> It's fixed. Thank you b_jonas
13:52:16 <theezakje> now I get a lisst of tupels with [(Just red, Just yellow), ...]
13:52:37 <b_jonas> peterjan: try http://dpaste.com/835013/ because that has less missing commas than the version I pasted first
13:52:54 <b_jonas> theezakje: but how do you get that list of tuples?
13:53:16 <theezakje> colored :: Eq a => [(a,b)] -> [(a,a)] -> [(Maybe b,Maybe b)]
13:53:16 <theezakje> colored l1 []         = []
13:53:16 <theezakje> colored l1 ((c,d):ys) = ((lookup c l1, lookup d l1) : (colored l1 ys))
13:53:22 <fjh> theezakje: lookup wraps the values in a Maybe, because there might not be a value corresponding to the key
13:53:31 <theezakje> I know fjh
13:53:41 <theezakje> but in this case there always is a value for the key
13:53:58 <b_jonas> theezakje: so write a function that looks up the color of just one edge first, and returns it
13:54:02 <fjh> the quick -and-dirty solution to this problem is to use the fromJust function
13:54:02 <b_jonas> not wrapped in a Just
13:54:08 <b_jonas> then use that function here instead of lookup
13:54:16 <peterjan> b_jonas: i get this error: The function `('0', "yellow")' is applied to 9 arguments,
13:54:16 <peterjan>     but its type `(Char, [Char])' has none
13:54:30 <b_jonas> peterjan: again, try http://dpaste.com/835013/ because that has less missing commas than the version I pasted first
13:54:34 <theezakje> mmm ok b_jonas will give it a try, thank you!
13:55:15 <peterjan> b_jonas: first one is correct ! :p
13:55:47 <peterjan> b_jonas: second one isn't
13:56:21 <b_jonas> peterjan: yes
13:56:44 <peterjan> b_jonas: do you know how to alter everything so it'll take not only char but everything
13:56:45 <b_jonas> peterjan: so can you show an edge that has the same color of endpoints in coloring1 ?
13:57:09 <peterjan> b_jonas: no it's a true/false thing :p
13:57:20 <theezakje> b_jonas what should I return then if the color isn't found?
13:57:43 <theezakje> lookupc :: Char -> [(a,b)] -> b
13:57:43 <theezakje> lookupc k []         =
13:57:43 <theezakje> lookupc k ((a,b):xs) | b == k = b
13:57:43 <theezakje>                      | otherwise lookup k xs
13:57:46 <b_jonas> peterjan: just use a type variable for the type of colors in your type declarations instead of Char, but an Eq constraint on it because you need to compare the colors for equality
13:58:01 <ncs> i'm trying to install the package "time" but I get an error:
13:58:01 <ncs> $ cabal install time-1.3
13:58:02 <ncs> Resolving dependencies...
13:58:02 <ncs> <command line>: cannot satisfy -package Cabal-1.14.0:
13:58:02 <ncs>     Cabal-1.14.0-a54f5d8d1a0caab231d803c3b625dd01 is unusable due to missing or recursive dependencies:
13:58:02 <ncs>       array-0.4.0.0-4f6c2a594155b0b953c1cf0f54040f61 containers-0.4.2.1-efa59805336a77490296ae3897cecb87
13:58:03 <ncs>     (use -v for more information)
13:58:05 <b_jonas> theezakje: how about an error?
13:58:05 <ncs> cabal: Error: some packages failed to install:
13:58:08 <ncs> time-1.3 failed during the configure step. The exception was:
13:58:10 <ncs> ExitFailure 1
13:58:13 <ncs> what does that mean?
13:58:17 <theezakje> interesting :)
13:59:07 <b_jonas> theezakje: that code seems wrong though
13:59:10 <dcoutts> ncs: using cabal-install-0.10.x ?
13:59:25 <b_jonas> for at least two reasons
13:59:37 <ncs> cabal-install version 0.14.0
14:00:48 <peterjan> b_jonas: could you tell me how would you alter this to fit everything : colored :: [(Char,String)] -> [(Char,Char)] -> Bool
14:01:29 <dcoutts> ncs: ah ok, it's failing when it tries to compile the Setup.hs for time
14:01:49 <dcoutts> ncs: run ghc-pkg check, you may have broken packages
14:01:50 <theezakje> lookupc :: Char -> [(a,b)] -> b
14:01:50 <theezakje> lookupc k [] = "Not found"
14:01:50 <theezakje> lookupc k ((a,b):xs) | a == k    = b
14:01:50 <theezakje>                      | otherwise = lookupc k xs
14:02:01 <b_jonas> peterjan: replace the Char with c, and add a constraint (Eq c) =>
14:02:07 <theezakje> couldn't match type a with char in "a == k"
14:02:13 <b_jonas> no wait
14:02:18 <b_jonas> you want to change the type of the nodes
14:02:29 <b_jonas> then replace the Char with n, and add a constrinat (Eq n) =>
14:02:32 <b_jonas> because n stands for node
14:02:58 <peterjan> :) thx
14:03:01 <b_jonas> theezakje: throw in an error before that string. you don't want to return the string "Not found"
14:03:36 <b_jonas> theezakje: or just remove that arm of the definition and trust haskell to give a sensible error message when the pattern of the second arm doesn't match
14:03:42 <theezakje> ok
14:03:52 <theezakje> did that but didn't fix my error:
14:03:54 <theezakje> couldn't match type a with char in "a == k"
14:04:25 <b_jonas> theezakje: so what does your code look like now? can you paste the whole thing to hpaste.org so we can look at it?
14:04:48 <hpaste> theezakje pasted “test” at http://hpaste.org/78093
14:05:02 <b_jonas> theezakje: wait, your type signiture for that function doesn't even make sense
14:05:14 <b_jonas> theezakje: figure out the correct type you want for that function, and use that in the signature
14:06:13 <theezakje> ok got it
14:06:18 <theezakje> had to change char in a
14:06:25 <theezakje> I want it to be as polymorphic as possible
14:07:43 <beaky> does haskell have a debugger like gdb?
14:07:53 <Digihash> You just have to do something like (Eq a,Eq b) => [(a,b)] -> ...
14:08:04 <Digihash> In my solution that works
14:08:19 <Digihash> you use Eq because you compare then to each other
14:08:28 <Digihash> sorry, with each other
14:08:55 <fjh> you don't have to constrain b, I think
14:09:09 <b_jonas> fjh: you have to constrain both the colors and the nodes
14:09:17 <b_jonas> Eq on each
14:09:38 <fjh> ok, sorry, have not looked at the whole problem yet, just the bits described by theezakje so far
14:09:59 <b_jonas> fjh: ah
14:10:28 <b_jonas> fjh: they want to check whether a coloring is proper given the coloring (as an association list) and the list of edges of the graph
14:10:35 <b_jonas> fjh: with input like http://dpaste.com/835013/
14:11:05 <b_jonas> fjh: coloring0 is proper, but coloring1 is not, though they still haven't found which two edges break it
14:12:10 <b_jonas> I wonder which university has this programming course :-)
14:12:26 <peterjan> b_jonas: would it be a good or a bad thing?
14:12:49 <monochrom> lookupc [] = "not found" --- this will break your desired type
14:12:50 <peterjan> b_jonas: in other words are you making fun of the course? :p
14:13:38 <b_jonas> peterjan: no, I'm just surprised on three people asking for help on irc about the same problem at the same time. the course itself is not unusual, but students using irc is.
14:15:20 <peterjan> b_jonas: we have an exercise due and on the course description i believe there's a note that there exists a haskell channel :D the funny thing is that we're all just trying it out, by coincidence all at the same time
14:15:55 <lispy> has anyone here worked on a Haskell backend for antlr?
14:16:21 <lispy> (or even a similar language like ocaml, [s]ml, f#, etc?)
14:16:33 <peterjan> b_jonas: if you have to constrain two variables, y wont this work: colored ::  (Eq n)(Eq c) => [(n,c)] -> [(n,n)] -> Bool
14:16:52 <peterjan> b_jonas: nor does: colored ::  (Eq n, Eq c) => [(n,c)] -> [(n,n)] -> Bool
14:17:46 <mauke> peterjan: protip: "doesn't work" is meaningless
14:19:13 <peterjan> mauke: i'll write that down
14:19:37 <mauke> yay
14:19:49 <b_jonas> > let { colored ::  (Eq n, Eq c) => [(n,c)] -> [(n,n)] -> Bool; colored = undefined; } in ()
14:19:50 <lambdabot>   ()
14:19:55 <b_jonas> it doesn't work?
14:20:02 <peterjan> b_jonas: got it nvm
14:20:11 <b_jonas> > let { colored ::  (Eq n)(Eq c) => [(n,c)] -> [(n,n)] -> Bool; colored = undefined; } in ()
14:20:13 <lambdabot>   `GHC.Classes.Eq n' is applied to too many type arguments
14:20:14 <peterjan> b_jonas: + thx for all your help
14:20:16 <mauke> a much better template is: "I did A, and got results B. but I expected it to do C. what is going on?"
14:21:38 <cmccann> mauke, the only thing less useful than "it doesn't work" is "it didn't work", adding the implication that the unknown and unspecified problem may also be unreproducible
14:22:05 <mauke> heh
14:26:21 <elliott> cmccann: "it won't work"
14:26:45 <cmccann> eh, in practice that usually means the same thing as "doesn't work"
14:27:05 <cmccann> though sometimes also implying that they're predicting failure before actually trying something
14:27:11 <mauke> "I can't get it to work"
14:27:19 <cmccann> either way, still better than an unknown past failure
14:27:26 <sipa> cmccann: on the contrary, "it didn't work" is acknowledging that it may be unreproducible; "it doesn't work" often means the user tried once and assumes it won't ever work :)
14:27:28 <mauke> = I may or may not have made unspecified changes to what you suggested
14:27:31 <shachaf> "it works. help!"
14:27:37 <mauke> error: success
14:27:45 <cmccann> mauke, ahahaha ok yeah
14:27:58 <cmccann> can't argue with that one
14:28:14 <shachaf> "I don't think it's working"
14:28:36 <sipa> "it sucks"
14:28:47 <mauke> "no joy"
14:28:53 <hpaste> theezakje pasted “weird” at http://hpaste.org/78094
14:29:06 <cmccann> though I'm not sure anything can beat a description of a situation that isn't obviously wrong together with an ambiguous comment that doesn't indicate what the problem is
14:29:12 <theezakje> b_jonas
14:29:26 <theezakje> I'm rly stuck at this: http://hpaste.org/78094
14:29:36 <theezakje> I'm almost there... just getting one error
14:29:46 <mauke> "I'm getting an error"
14:29:47 <elliott> cmccann: well the idea of "it won't work" is someone is saying your code will have an unspecified error in the future
14:29:50 <elliott> but currently does not
14:29:58 <elliott> so you can't even do anything about it if you wanted to
14:29:59 <sipa> cmccann: how about a game support service that gets a complaint from a user that it crashed... unknowing it was about a flight simulator
14:30:00 <theezakje> No instanse of (Eq b) arising from use of "check"
14:30:09 <cmccann> sipa, bwahahaha
14:30:18 <mauke> theezakje: what's the rest of the error message?
14:30:39 <cmccann> elliott, hm true
14:31:18 <b_jonas> theezakje: then look at the code line the error message refers to and read the error message and think about why it gives that error
14:31:18 <theezakje> Couldn't match expected type [(b,b)] with actual type Bool
14:31:53 <mauke> theezakje: what's the rest of the error message?
14:32:11 <theezakje> thats it
14:32:16 <elliott> that's not it
14:32:19 <theezakje> I cant copy and paste from this ghci window somehow
14:32:28 <mauke> so?
14:32:29 <theezakje> using windows
14:32:38 <mauke> that doesn't mean "that's it"
14:33:09 <hiptobecubic> http://svn.coderepos.org/share/lang/haskell/nario/  :D
14:33:13 <shachaf> "that's all I'm prepared to type"
14:33:26 <shachaf> "consider yourselves lucky that I gave you that much"
14:33:27 <hiptobecubic> Had to do a minor tweak,  Images.hs needs Data.Maybe instead of Maybe
14:33:33 <mauke> your choices are: 1) figure out how to use the windows console
14:33:38 <mauke> 2) post a screenshot
14:33:39 <hiptobecubic> then you can ghc --make Main.hs and fire it up
14:33:43 <mauke> 3) retype everything
14:33:55 <mauke> 4) don't use windows
14:34:05 <sipa> 5) figure it out yourself :)
14:34:10 <mauke> or that
14:34:55 <t7> copy and paste from cmd.exe: right click -> click mark -> click and drag the bit u wanna copy -> left click to save in clippy
14:35:17 <theezakje> doestn work in ghci.exe
14:35:39 <t7> oh who uses that anyway
14:35:40 <b_jonas> 6) rerun the compiler from the shell with the stderr redirected to a file, then paste that file
14:35:44 <t7> doesnt even do unicode
14:35:57 <hiptobecubic> Well *I* thought it was neat
14:35:58 <mauke> t7: or <enter> to copy
14:36:07 <b_jonas> such as ghci CheckColors.hs 2> errors.txt
14:36:31 <b_jonas> um
14:36:38 <b_jonas> ghc CheckColors.hs 2> errors.txt
14:36:41 <b_jonas> or something like that
14:36:46 <fjh> theezakje: on line 5, I think you mean to call colorlist where you call colored. at least that looks like it should be a type error
14:36:53 <ncs> how can I remove completely the haskell platform with all the packages, so that I can install it again from scratch?
14:37:40 <shachaf> That depends on how you installed it.
14:38:16 <t7> control panel :£
14:39:08 <ncs> i'm running  ubuntu and i just installed it with apt-get
14:43:39 <bartavelle> ncs, then you can remove it with apt-get remove --purge
14:43:52 <bartavelle> or dpkg --purge if you know the list of packages
14:46:11 <hpaste> theezakje pasted “error” at http://hpaste.org/78096
14:46:19 <theezakje> any idea on this?
14:46:21 <theezakje> http://postimage.org/image/hpuabn06t/
14:46:29 <theezakje> hpaste =  http://hpaste.org/78096
14:47:55 <Nereid> @type all (uncurry (/=))
14:47:57 <lambdabot> Eq b => [(b, b)] -> Bool
14:47:59 <mauke> theezakje: the type signature for colored is missing an (Eq b) constraint
14:48:49 <mauke> theezakje: and (Eq a), apparently
14:48:56 <Nereid> also, it's probably a good idea to use a Maybe for the return type of lookupc
14:49:02 <Nereid> @type lookup
14:49:04 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
14:49:57 <Nereid> also, I can copy from ghci.exe here
14:50:09 <Nereid> system menu -> edit -> mark
14:50:19 <theezakje> thx Nereid :)
14:51:16 <mauke> theezakje: D:\Dropbox\KUL\declaratieve_talen\haskell\oef\oef2\geq\oplossing.hs
14:51:18 <mauke> ಠ_ಠ
14:51:34 <theezakje> ?
14:52:05 <Nereid> @type \l -> map (over both (`lookup` l))
14:52:07 <lambdabot> Eq a => [(a, b)] -> [(a, a)] -> [(Maybe b, Maybe b)]
14:52:37 <Jafet> mauke: at least he uses version control
14:53:08 <mauke> theezakje: http://postimage.org/image/6qbfiolcx/
14:53:33 <theezakje> get a life mauke :D
14:53:39 <theezakje> thx lambdabot
14:53:42 <Nereid> also, once you put an Eq constraint on colored, you'll either:
14:53:51 <Nereid> 1) also need to put one on colorlist, or
14:54:14 <Nereid> 2) use ScopedTypeVariables and also put a forall on the type for colored
14:54:46 <mauke> theezakje: I'm just trying to point out that your method of redacting sensitive information doesn't actually work
14:55:00 <Nereid> haha
14:55:51 <shachaf> mauke: Oh, that's what those annoying black lines were?
14:56:03 <sipa> theezakje: kuleuven student?
14:56:54 <ncs> bartavelle: i tried that but on reinstall i still have some leftover (broken) packages... any other suggestions?
14:56:57 <Jafet> shachaf: the pixels got smudged
14:56:59 <theezakje> yes sipa
14:57:40 <sipa> cool, they switched to ghc; in my time it was hugs :)
14:57:58 <Nereid> does anyone use hugs anymore?
14:58:00 <Philippa> heh, yes, it was at UoN in my year too
14:58:05 <cmccann> the correct way to redact ████ is to ████ and ████ until [DATA REDACTED].
14:58:32 <shachaf> There should be a REDACTED combining character.
14:58:37 <Nereid> haha.
14:58:44 <Nereid> or at least make a rectangular selection and fill.
14:58:49 <cmccann> shachaf, ahahahaha yes
14:59:17 <sipa> theezakje: gerda still teaching DT?
14:59:23 <theezakje> yes :D
14:59:37 <shachaf> cmccann: Did you hear about the evil Bazaar thing?
14:59:50 <cmccann> maybe?
14:59:58 <cmccann> sounds disreputable
14:59:59 <Jafet> http://blogs.adobe.com/acrobat/redaction-gone-wrong/
15:00:06 <shachaf> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/BazaarT.hs
15:00:08 <theezakje> b_jonas http://dpaste.com/835013/ this link, the colorings is it so that the first one is correct and the second incorrect?
15:00:23 <shachaf> cmccann: "we couldn't figure out how to write it so we just used unsafeCoerce"
15:00:44 <cmccann> bwahahaha
15:01:13 <Digihash> Hi sipa, are you an ex-KU Leuven student? Did you also study "schakelprogramma toegepaste informatica" or did you do academic bachelor informatics?
15:01:36 <sipa> Digihash: i studied computer science
15:01:42 <Digihash> Ah nice
15:02:09 <Digihash> So from a Civil Engineer to Computer science?
15:02:26 <Digihash> Do you also like Haskell more than Prolog?
15:02:27 <sipa> no, computer science is one of engineering's master
15:02:51 <sipa> so not really "from / to", just part of it
15:03:07 <sipa> Digihash: yes, i prefer haskell :)
15:03:09 <Digihash> I don't know why, but I understand Haskell better than Prolog
15:03:32 <theezakje> Digihash here it's just the other way around
15:03:54 <Digihash> :)
15:04:15 <sipa> i always found that to write any nontrivial program in prolog you can't just keep living in the abstraction... you really have to think about how it gets executed
15:04:33 <sipa> while in haskell that (at least for me) only seems necessary when trying to optimize performance :)
15:05:02 <Digihash> Yes, that's possibly true.
15:05:53 <cmccann> Q: how many prolog programmers does it take to change a lightbulb? A: No
15:06:10 <shachaf> cmccann is such a pessimist.
15:06:34 <cmccann> nah. I just had a prolog course in university.
15:07:20 * cmccann should give prolog a try again one of these days.
15:07:22 <xunatai> working on a roguelike-ish game: http://oi49.tinypic.com/indaww.jpg
15:07:39 <Cale> nice
15:07:47 <cmccann> xunatai, the player isn't dead yet, what kind of roguelike is that? :P
15:07:47 <xunatai> you can move around a character!
15:07:56 <xunatai> and that's it
15:08:09 <xunatai> code is only slightly horrible
15:08:18 <xunatai> er, mostly*
15:08:35 <sacundim> now you just need a hobgoblin with an ice monster behind it and you're done
15:08:45 <cmccann> the "hello world" of roguelikes is a program that just prints "You have died." to the console and quits
15:09:08 <shachaf> cmccann: I thought that was the state of the art?
15:09:12 <xunatai> right now my primary goal is to figure out how to make the code not horrible
15:09:41 <osfameron> cmccann: hah
15:09:46 <cmccann> shachaf, no that would also include identifying your posessions
15:10:00 <shachaf> DYWCPI?
15:10:06 <xunatai> http://pastebin.com/QREQ5zrK
15:10:09 <mauke> The paste QREQ5zrK has been copied to http://hpaste.org/78097
15:11:30 <cmccann> xunatai, why use case in getMovement?
15:11:49 <xunatai> why not?
15:12:00 <shachaf> getTheDirectionThatMovementShouldBeHappeningIn
15:12:07 <cmccann> pattern matching in the function definition is more idiomatic
15:12:17 <xunatai> wow
15:12:20 <xunatai> good point
15:12:28 <shachaf> Not if the function name is long and awkward.
15:12:36 <shachaf> And there are dozens of other parameters.
15:12:45 <xunatai> on the other hand, the case looks nicer
15:12:47 <cmccann> likewise, using guards in advance instead of if
15:12:58 <cmccann> if the function name is long an awkward step 1 is rename it
15:13:57 <Cale> I'd use case there
15:14:03 <niteria> I'd prefer getMovement being a lookup in some map / list
15:14:14 <cmccann> yeah, in actual practice I'd use a Map or something
15:14:26 <shachaf> Really?
15:14:26 <Nereid> or just a [(Char, (Int,Int))]
15:14:32 <Nereid> why bother constructing a map just for that
15:14:34 <shachaf> For four directions?
15:14:36 <cmccann> and/or an intermediate type representing directions
15:14:43 <cmccann> so that input could be configurable
15:14:45 <Cale> Heh, it would probably actually not be better to use the Prelude's lookup with a list of options that short
15:14:51 <Nereid> I definitely would do that.
15:14:59 <cmccann> but that's getting far more complicated than this simple version :P
15:14:59 <Nereid> data Movement = Up | ...
15:15:00 <Cale> er, it would be better*
15:15:01 <xunatai> i like how you guys are criticizing the only sane-looking piece of code
15:15:08 <Nereid> haha
15:15:09 <Cale> xunatai: lol
15:15:19 <Cale> xunatai: formatting:
15:15:20 <Cale> if foo
15:15:22 <Cale>   then bar
15:15:24 <Cale>   else quuz
15:15:46 <Cale> xunatai: Generally 'then' and 'else' ought to line up
15:15:57 <Nereid> let x = y in do z   -->  do { let x = y; z }
15:16:15 <xunatai> ah
15:16:16 <cmccann> xunatai, I'd probably rewrite renderDiff substantially
15:16:31 <cmccann> most of the "bunch of IO actions" stuff is fine, it is what it is
15:16:56 <Nereid> if x then y else return ()   -->  when x y
15:17:08 <niteria> "return ()", I think you can use mapM_ for that
15:17:10 <Cale> > (1,2) + (-1,0)
15:17:12 <lambdabot>   (0,2)
15:17:16 <Nereid> yes, mapM_ for that
15:17:19 <sacundim> um, did I just say "yo" in this channel?  this irc client is confusing
15:17:22 <cmccann> I'd also break loop apart into a looping combinator and a single-step function that took the result of getch as a parameter
15:17:27 <Nereid> sacundim: nope
15:17:46 <cmccann> but that may just be one of my weird things
15:17:46 <sacundim> Nereid: oh, so i said it in the right channel, but i have the wrong nick there
15:17:50 <sacundim> thanks
15:18:46 <Nereid> also
15:18:47 <Nereid> lens! :D
15:19:27 <shachaf> Yes, a len or two could surely improve your program.
15:19:35 <Cale> xunatai: Probably the best way to make it nice is to formalise some type for the various inputs that can occur, and then write a function  step :: Input -> Game -> Game
15:19:38 <Nereid> haha shachaf.
15:19:52 <xunatai> i was thinking about that
15:20:02 <Cale> xunatai: Which steps the game world forward by a tick, taking the input into consideration, without doing any I/O
15:20:20 <Cale> You might also want it to produce a list of messages though
15:20:29 <Nereid> sounds like the State monad.
15:20:46 <shachaf> Sounds the the (Endo Game).
15:20:54 <sipa> ender's game?
15:20:56 <shachaf> Maybe Endo should be called "the state monoid"
15:21:07 <Nereid> lol
15:24:29 <ion> monochrom++. This was informative. http://www.vex.net/~trebla/haskell/ghc-conc-ffi.xhtml
15:27:29 <cmccann> shachaf, Kleisli State is equivalent to composing functions "(a, s) -> (a, s)" so that's not entirely inaccurate
15:28:04 <shachaf> cmccann: Right.
15:28:12 <shachaf> Well, (a, s) -> (b, s), so it can't be a Monoid
15:28:20 <cmccann> er, right
15:28:48 <cmccann> specialized to a single parameter type, I meant
15:28:50 <shachaf> But in general any Monad-like thing where you only ever use () should be Monoidable?
15:30:26 <binroot> Anyone know what Simon Marlow will contribute to Facebook?
15:31:12 <Saizan> magic
15:33:42 <binroot> I hope FB starts investing in haskell!
15:33:46 <cmccann> shachaf, for extra fun, have a monoid on "(a, s) -> (a, s)" where the order of composition is different for the two components
15:34:28 <cmccann> e.g. \f g (x, y) -> let (x2,y3) = g (x,y2); (x3,y2) = f (x2,y) in (x3,y3)
15:34:52 <copumpkin> lol
15:35:02 <sipa> binroot: i'm sure we'll soon see a EDSL for describing complicated relationships
15:35:58 <kqr> binroot, he was hoping he would be doing haskell so we'll see
15:36:04 <kqr> binroot, its not that unlikely, after all
15:36:15 <monochrom> ion: thank you for choosing monochrom!
15:36:43 <Nereid> yes, for any Monad m, m () is a monoid under (>>) and return ()
15:37:11 <Nereid> (Applicative too)
15:39:11 <ion> monochrom: http://www.vex.net/~trebla/haskell/hxt-arrow/lesson-0.xhtml http://4.bp.blogspot.com/_D_Z-D2tzi14/S8TRIo4br3I/AAAAAAAACv4/Zh7_GcMlRKo/s400/ALOT.png
15:43:22 <Nereid> :t ZipList
15:43:24 <lambdabot> [a] -> ZipList a
15:43:40 <Nereid> > ZipList [(),()] *> ZipList [(),(),()] *> pure ()
15:43:43 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.ZipList ()))
15:43:43 <lambdabot>    arising...
15:43:51 <Nereid> what
15:43:55 <Nereid> > getZipList $ ZipList [(),()] *> ZipList [(),(),()] *> pure ()
15:43:57 <lambdabot>   [(),()]
15:44:07 <Nereid> > getZipList $ pure ()
15:44:10 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
15:44:14 <Nereid> ah, the "min" monoid.
15:44:31 <Nereid> > [(),()] *> [(),(),()]
15:44:33 <lambdabot>   [(),(),(),(),(),()]
15:44:42 <ion> I don’t get why there’s no Show instance for ZipList.
15:44:52 <Nereid> yes that is very peculiar
15:45:07 <sacundim> i had to make a Show instance for Identity yesterday
15:45:53 <shachaf> ion: There's a convention of not deriving Show for all those newtypes for whatever reason.
15:46:38 <typoclass> i don't get tons of things. e.g., i've thought about the Fractional typeclass for a while, and i don't get that anymore
15:46:56 <cmccann> better not think too hard about Real then
15:46:59 <cmccann> because man
15:47:01 <cmccann> what the crap
15:47:22 <ion> It’s unreal.
15:47:26 <sacundim> i've been asking myself these days how did people get any work done without ScopedTypeVariables
15:48:10 <otters> > let replicate' = (*>) . enumFrom 1 in replicate' 4 'c'
15:48:12 <lambdabot>   Could not deduce (GHC.Enum.Enum (f a0))
15:48:13 <lambdabot>    arising from the ambiguity check...
15:48:13 <Nereid> why Real?
15:48:16 <otters> rats
15:48:27 <otters> > let replicate' = (*>) . enumFrom (1 :: Integer) in replicate' 4 'c'
15:48:29 <lambdabot>   Couldn't match expected type `f0 a0'
15:48:29 <lambdabot>              with actual type `GHC.Int...
15:49:17 <otters> oh yeah
15:49:35 <ion> > let r n a = a <$ enumFromTo 1 n in r 4 'c'
15:49:37 <lambdabot>   "cccc"
15:50:15 <cmccann> Nereid, it's a class called Real but the one operation it defines is a conversion to Rational
15:50:17 <cmccann> think about that for a while
15:50:33 <Nereid> no I was going to type something else about Real but then I stopped
15:51:00 <Nereid> I mean the whole point of real numbers is that they're complete.
15:51:02 <Nereid> :p
15:51:13 <ion> > toRational pi
15:51:15 <lambdabot>   884279719003555 % 281474976710656
15:51:18 <Nereid> lovely
15:51:24 <ion> > toRational (exp 1)
15:51:26 <shachaf> > toRational (pi::CReal)
15:51:26 <lambdabot>   6121026514868073 % 2251799813685248
15:51:28 <lambdabot>   *Exception: CReal.toRational
15:51:28 <typoclass> oh right, i've seen that class when thinking about Fractional. yeah i don't get Real either. the docs for toRational say "with full precision". i don't know if that's with all the precision of the source type or all the precision of the target type ...
15:51:45 <Nereid> Rational has infinite precision so
15:52:05 <ion> so it can represent pi
15:52:12 <Nereid> no, pi isn't rational
15:52:27 <Nereid> > 1 + 1/10^100 :: Rational
15:52:29 <lambdabot>   100000000000000000000000000000000000000000000000000000000000000000000000000...
15:52:43 <ion> 31415926… / 10000000…
15:53:07 <cmccann> ion, hahaha
15:53:25 <sacundim> next you're going to tell us that 1 ≠ 0.999...
15:53:38 <shachaf> Go away, sacundim.
15:53:41 <Nereid> > 1 - 1/10^100 :: Rational
15:53:43 <lambdabot>   999999999999999999999999999999999999999999999999999999999999999999999999999...
15:53:55 <shachaf> > toRational (1/0)
15:53:57 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
15:54:10 <shachaf> I guess that's infinity?
15:54:14 <shachaf> > length.show$toRational (1/0)
15:54:15 <Nereid> nice
15:54:16 <lambdabot>   313
15:54:23 <shachaf> Hmm, infinity is smaller than I thought.
15:54:27 <Nereid> > denominator (toRational (1/0))
15:54:29 <lambdabot>   1
15:54:33 <shachaf> 179769313486231590772930519078902473361797697894230657273430081157732675805500963132708477322407536021120113879871393357658789768814416622492847430639474124377767893424865485276302219601246094119453082952085005768838150682342462881473913110540827237163350510684586298239947245938479716304835356329624224137216 % 1
15:54:44 <Nereid> > maxBound :: Double
15:54:46 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
15:54:47 <lambdabot>    arising from a use o...
15:54:48 <Nereid> aw
15:55:12 <shachaf> > toRational(-1/0)
15:55:14 <lambdabot>   (-1797693134862315907729305190789024733617976978942306572734300811577326758...
15:55:16 <cmccann> ...what
15:55:25 <cmccann> floats have an obvious max and min bound
15:55:38 <ion> nereid, cmccann: https://gist.github.com/1188115
15:55:40 <shachaf> NaN?
15:55:41 <Nereid> > length.show $ 2^1023
15:55:43 <lambdabot>   308
15:55:45 <ion> cmccann: Yes: minus infinity and infinity.
15:56:22 <Nereid> > 2^1023
15:56:25 <lambdabot>   898846567431157953864652595394512366808988489471153286367150405788663379027...
15:56:28 <Nereid> > 2^1024
15:56:30 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
15:56:30 <kqr> almost infinity
15:56:39 <Nereid> > 2^1024 - toRational (1/0)
15:56:41 <lambdabot>   0 % 1
15:56:46 <Nereid> aha, infinity = 2^1024 :))
15:56:49 <kqr> yes
15:56:52 <otters> > toRational (1/0)
15:56:55 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
15:56:57 <otters> oh
15:57:01 <ion> > toRational $ fix (\p -> let r = floatRadix p; d = floatDigits p; (_,e) = floatRange p in encodeFloat (r^d-1) (e-d))
15:57:01 <shachaf> > (1/0) == 2^1024
15:57:03 <lambdabot>   179769313486231570814527423731704356798070567525844996598917476803157260780...
15:57:03 <lambdabot>   can't find file: L.hs
15:57:07 <typoclass> > 2^1023 - toRational (1/0)
15:57:09 <lambdabot>   (-8988465674311579538646525953945123668089884894711532863671504057886633790...
15:57:14 <kqr> now please never use numbers that big for anything real
15:57:19 <Nereid> > 2^1024 + toRational (-1/0)
15:57:21 <lambdabot>   0 % 1
15:57:28 <Nereid> kqr: or rational
15:57:29 <otters> what about counting the number of bad monad tutorials
15:57:32 <Nereid> lol
15:57:34 <shachaf> copumpkin: Is 2^1024 a prime?
15:57:35 <kqr> Nereid, haha
15:57:39 <ion> (bad monad) tutorial
15:57:41 <otters> P:
15:57:42 <shachaf> Computer-verified proof please.
15:57:47 <otters> the Bad monad
15:57:50 <copumpkin> shachaf: no
15:57:58 <otters> violates all the laws and uses unsafePerformIO to effect random behavior
15:57:58 <monochrom> you need IEEE 754 to count bad monad tutorials. because you'll need its +Infinity
15:57:59 <Nereid> > toRational (1/0) == 2^1024
15:58:01 <lambdabot>   True
15:58:02 <typoclass> otters: we have a spiffy graph on http://www.haskell.org/haskellwiki/Monad_tutorials_timeline
15:58:06 <copumpkin> shachaf: it's actually pretty easy for me to prove it isn't even in Agda :P
15:58:22 <copumpkin> shachaf: you gonna make me do it?
15:58:37 <ion> typoclass: haha
15:58:58 <kqr> otters, isn't the io monad pretty much the bad monad?
15:59:06 <shachaf> copumpkin: OK, OK, that won't be necessary.
15:59:16 <ion> How is IO bad?
15:59:18 <elliott> copumpkin: yes
15:59:20 <otters> kqr: at least its behavior isn't intentionally unpredictable
15:59:22 <elliott> i'll make you
15:59:25 <copumpkin> shachaf: http://snapplr.com/etke
15:59:27 <shachaf> don't do it copumpkin!
15:59:31 <kqr> otters, fair enough
15:59:32 <copumpkin> can you see why that's easy?
15:59:32 <Nereid> IO is evil, not bad
15:59:45 <xunatai> if i put more applications to a function on the next line, should i use an indent?
15:59:45 <ion> How is it even evil?
15:59:47 <kqr> ion, i was more referring to it being the sin bin
15:59:47 <copumpkin> I can easily prove that 2 is prime, and that it divides 2^1024
15:59:56 <shachaf> copumpkin: Yes, I know.
16:00:01 <copumpkin> and I have another separate proof that if you're composite, then you aren't prime
16:00:04 <kqr> ion, things that people don't understand the implications of go in the io monad
16:00:14 <elliott> copumpkin: i'm waiting for the code.
16:00:32 <kqr> xunatai, yes
16:00:36 <typoclass> xunatai: could you hpaste the lines in question?
16:00:38 <typoclass> @where hpaste
16:00:38 <lambdabot> http://hpaste.org/
16:00:43 <kqr> xunatai, the next line should be indented further than the previous, i would think
16:01:01 <copumpkin> elliott: I wouldn't want to wait for it to typecheck :) the proof is simple, but Agda's gonna blow up trying to normalize the type
16:01:12 <elliott> copumpkin: sounds like you can't do it!
16:01:20 * copumpkin kicks elliott 
16:01:26 <ion> killiott
16:02:39 <xunatai> foo arg1 arg2
16:02:44 <xunatai>     arg3
16:02:53 <xunatai> or, no indent
16:04:18 <ion> I tend to indent all parameters (that don’t follow a previous one on the same line) to the same column.
16:05:00 <typoclass> xunatai: i'd definitely indent that. just to show "the arg3 line belongs to the previous line"
16:05:02 <andsens> In Parsec: How do I parse an arbitrary string until I meet specific tokens without the tokens being consumed?
16:06:01 <xunatai> here's the actual code: http://pastebin.com/gKCZBydC
16:06:04 <mauke> The paste gKCZBydC has been copied to http://hpaste.org/78100
16:07:19 <xunatai> kind of clunky
16:07:19 <ion> andsens: lookAhead parses without consuming.
16:07:49 <andsens> lookAhead?
16:07:58 <andsens> Where is that documented?
16:08:04 <ion> @hoogle lookAhead
16:08:04 <lambdabot> Text.Parsec.Prim lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
16:08:04 <lambdabot> Text.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
16:08:04 <lambdabot> Text.ParserCombinators.Parsec.Combinator lookAhead :: Stream s m t => ParsecT s u m a -> ParsecT s u m a
16:08:34 <andsens> huh, must've missed that
16:08:39 <tomeo> Could someone please tell me how to install this package? http://hackage.haskell.org/packages/archive/data-memocombinators/0.3/doc/html/Data-MemoCombinators.html
16:08:56 <tomeo> I tried cabal install memocombinators --enable-documentation
16:09:03 <andsens> thanks ion
16:09:11 <ion> The name of the package is data-memocombinators.
16:09:29 <tomeo> oh, thanks IanKelling
16:09:31 <tomeo> ion
16:09:35 <kqr> xunatai, http://pastebin.com/aQFeNxz2
16:09:37 <mauke> The paste aQFeNxz2 has been copied to http://hpaste.org/78101
16:09:38 <kqr> xunatai, i would probably do it like that
16:09:41 <ion> You can add documentation: True to ~/.cabal/config
16:09:44 <kqr> xunatai, if i understand your intention correctly
16:09:54 <xunatai> that looks much better, thanks
16:09:58 <kqr> xunatai, but i think there's a lot of personal preference to that
16:10:28 <ion> kqr: I dislike the unindentation in the middle of the parameters to putChar.
16:11:00 <kqr> ion, where?
16:11:02 <xunatai> ?
16:11:15 <andsens> wow. Sincere thanks ion, I just slapped lookAhead into my composition and it works, haha!
16:11:40 <xunatai> ion: the next stuff belongs to mapM_
16:12:09 <typoclass> ion: not sure what you mean, but there's a closing parens :-/ stumped me as well
16:12:11 <ion> Ah, sorry. I’m blind. :-)
16:13:17 <kqr> i'm an old lisper, so i guess i sort of go by the indentation and not the actual parens
16:14:02 <typoclass> xunatai: here's another possibility http://pastebin.com/3ZbjGF6d
16:14:05 <mauke> The paste 3ZbjGF6d has been copied to http://hpaste.org/78102
16:14:59 <kqr> typoclass, i would prefer more descriptive names on f and xs though
16:15:06 <ion> Yeah, i didn’t look closely enough at the code and interpreted the initial paste as if the “filter…” stuff belonged to the “putChar…” expression based on the indentation. Then i saw the new indentation and neglected revising my initial interpretation.
16:15:12 <xunatai> but still, the where clause is a good idea regardless
16:15:30 <kqr> ion, yeah that troubled me too. i thought i caught a loose opening paren before i spotted where the closing one was
16:19:41 <typoclass> kqr: i'm okay with f and xs in this case because it's only a small area where they are visible. and earlier they didn't have names at all :-)
16:20:49 <typoclass> kqr: (rule of thumb: the bigger the scope, the longer the variable name. if you're juggling 37 names, it'd be terribly confusing if they all have 2-letter names. if you're only working with 3 names, i find it appropriate if they're "xs", "a", and so on)
16:22:06 <xunatai> http://hpaste.org/new
16:23:05 <xunatai> er
16:23:30 <xunatai> http://hpaste.org/78103
16:24:06 <xunatai> this, of course, is the original
16:24:07 <ion> That looks nice.
16:24:07 <xunatai> http://hpaste.org/78104
16:24:47 <ion> This is, of course, entirely subjective, but i would put the comma in the list comprehension below the |. That makes it more apparent at a glance.
16:25:00 <xunatai> i thought about that
16:25:40 <xunatai> the first version is horrific
16:34:15 <xunatai> this looks like something a monad could help with:
16:34:17 <xunatai> game {level = tileMod (tileMod (level game) (pos game) ' ') newPos '@', pos = newPos}
16:34:46 <shachaf> Looks like something lenses could help with!
16:36:35 <ion> Verily.
16:36:38 <simpson> If only we could combine them somehow, into some sort of..."lenad" or something.
16:37:12 <Dashkal> Sure you can.  Lenses work greate with the State monad.
16:37:19 <Dashkal> great*
16:37:53 <simpson> I was trying to be funny.
16:38:29 * simpson mjoke = case mjoke of { Just joke -> joke ; }
16:38:49 <sipa> mjoke = fromJust ?
16:39:37 <shachaf> There ought to be a rule against monad jokes.
16:40:00 <Dashkal> I claim the end-of-the day excuse for that whoosh
16:41:33 <typoclass> there ought to be a rule against fromJust
16:43:49 <simpson> ^^
16:44:46 <sipa> {-# RULES "bad/fromJust" fromJust = error "bad boy" #-}
16:52:29 <xunatai> uh oh
16:52:38 <xunatai> 5 PM, that's nearly my bed time
16:52:46 <binroot> Do any of you guys have AI projects in haskell?
16:52:58 <binroot> Artificial intellegence, machine learning, etc
16:53:11 <ion> I’m hoping to make a drone out of an RC plane.
16:55:48 <andsens> Does anybody know of a way to simulate many1Till?
16:55:54 <andsens> In Parsec that is
16:56:26 <andsens> My fallthrough case can return the empty string, which gets me into an infinite loop
17:12:50 <mapf> in order to forbid any IO actions all that we need is just hide unsafePerformIO and unsafeCoerse?
17:14:39 <cl1> what to use for a GUI in haskell?
17:19:15 <slack1256> when using STM I keep thinking on the situation that 2 thread with a common TVar keep changing it just in the middle of the other one, so neither finish its job.
17:19:32 <slack1256> could this happen? Am i misunderstanding something?
17:20:57 <edwardk> ion: because i kept typoing between them and reasoned others would too =P
17:22:33 <elliott> is this about (^!?)
17:24:30 <ion> edwardk: That sounds like a great indicator of the accumulation of operators having gone too far. :-P
17:24:53 <edwardk> ion: well, the addition of that operator was deliberate in that it let us put partial lenses to rest for good.
17:24:53 <ion> What’s wrong with `these`?
17:25:28 <edwardk> and the name is deliberately chosen to look dangerous ;)
17:25:30 <shachaf> What, really? (^!?)?
17:25:40 * shachaf missed that bit.
17:25:40 <edwardk> ^!?  isn't an operator that inspires confidence in one's code
17:25:45 <ion> shachaf: For which (^!?) is a synonym.
17:25:51 <shachaf> (^!?) is the devil.
17:25:53 <ion> i mean, (^?!)
17:26:05 <shachaf> Do you really want code which uses both ^?! and ^!? ?
17:26:19 <edwardk> shachaf: its the same right now. im willing to kill one though ;)
17:26:32 <shachaf> I'd say kill (^!?)
17:27:23 <edwardk> Put an issue in and i'll mark it for 3.6 we can kill it before we ship that
17:28:24 <ion> `unsafeHead`
17:28:39 <edwardk> i'd rather accrete a few actual improvements before shipping a breaking change though =P
17:28:44 <edwardk> ion: =P
17:28:57 <edwardk> er that was a tongue sticking out, not an operator suggestion
17:29:20 <ion> I still can’t even remember the operators for set, view and over.
17:29:40 <shachaf> I always mix up .~ with ~.
17:29:47 <shachaf> Not that ~. is a thing.
17:30:30 <ion> It would be a bit better if there was a common prefix to all lens operators (say, ^).
17:30:56 <mauke> how about Lens.?
17:31:17 <liyang> @remember edwardk er that was a tongue sticking out, not an operator suggestion
17:31:17 <lambdabot> I will never forget.
17:31:37 <shachaf> ion: ^ is a common prefix for getting
17:31:44 <shachaf> ~ is a common suffix for setting
17:31:50 <shachaf> = is a common suffix for State-setting
17:33:40 <liyang> On the topic of not being able to figure out lens operators… if I want two updates like: "s % a . b .~ f % a . c .~ g" , how do I factor out the 'a' part that's common to both?
17:34:27 <edwardk> liyang: good question.
17:34:34 <edwardk> you can probably nest them in a %~ some how
17:34:50 <shachaf> over (a.b) f . over (a.c) g $ s
17:35:02 <shachaf> over a (over b f . over c g) $ s ?
17:35:09 <edwardk> shachaf yep
17:35:21 <edwardk> which then transforms back into infix style into so much line noise
17:35:36 * shachaf doesn't really like operator soup.
17:35:47 <edwardk> a %~ (b .~ f >>> c .~ g) $ s
17:35:49 <edwardk> whee
17:36:09 <edwardk> i mixed in (>>>) there just to mess with cale
17:36:18 <shachaf> Hmm, b and c could overlap.
17:36:24 <shachaf> So the order does matter.
17:36:30 <edwardk> yeah
17:36:31 <liyang> Yay! … \¬_¬/
17:36:44 <edwardk> i wrote them in the order of his code though
17:36:46 <edwardk> =)
17:37:01 <shachaf> Yes, but I didn't.
17:37:31 <Jafet> "-- This line is due to shachaf and edwardk, private communication"
17:46:49 <QinGW> How to navigate to package source code of function in haskell-mode by emacs?
17:47:28 <shachaf> Sounds more like an Emacs question than a Haskell question.
17:47:55 * liyang ended up with "over a (set c g . set b f) s".
17:53:31 * hackagebot dawg 0.6.0 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.6.0 (JakubWaszczuk)
17:56:25 <QinGW> shachaf: right.
17:58:31 <typoclass> is there a good summary of people's criticisms of Num?
17:58:38 <typoclass> (blog post, etc.)
17:58:54 <Eduard_Munteanu> Good, I was going to say just "Num sucks". :P
17:59:58 <typoclass> Eduard_Munteanu: well, 2 words is a little shorter than i hoped :-)
18:00:16 <aristid> "Num sucks a lot, it's totally b0rked"
18:00:18 <aristid> better?
18:00:34 <aristid> typoclass: also is it true that you were geheimdienst?
18:00:36 <Eduard_Munteanu> That's an in-depth take on it, but yeah, same idea. :P
18:00:59 <typoclass> aristid: yes, sure
18:01:18 * aristid updates surveillance spreadsheet
18:02:25 <aristid> typoclass: so one obvious criticism of Num would be that it puts a lot of methods in there that valid number-like types cannot really implement, so often they just error them out
18:02:55 <aristid> like, what would be the negate function for an arbitrary-size unsigned integer type?
18:03:32 <aristid> typoclass: hmm but you want a comprehensive summary i guess?
18:04:03 <Jafet> class Addable
18:04:09 <Jafet> class Minusable
18:04:18 <Eduard_Munteanu> I think other preludes also take a mathier approach (e.g. defining rings etc.).
18:04:44 <papermachine> It was really hubris on the Prelude-writers
18:05:55 <typoclass> aristid: (the old nick was stupid, it was the german word for 'intelligence agency', 'secret police', that sort of thing. but people looked it up in dictionaries and came up with 'intelligence', and that's just terribly pompous)
18:06:29 <typoclass> aristid: interesting, thanks for the explanation. i can see how Num being so big is a problem
18:06:37 <Jafet> But "dmwit" is okay
18:07:23 <aristid> typoclass: i know what geheimdienst means, being german:P
18:08:02 <aristid> Jafet: i guess self-deprecation is considered better than boasting
18:08:26 <popl> In some circles.
18:08:58 <typoclass> aristid: ah :-) where from?
18:09:00 <aristid> typoclass: so another common complaint is the lack of laws surrounding it. some people say that type classes are only cool if they come with laws
18:09:04 <aristid> typoclass: south!
18:09:07 <Jafet> Criticism schema for Num: Num stands for Number. Some mathematician called ?Foo a number. Therefore ?Foo should be a Num. But Num requires methods that ?Foo doesn't have. Finally, we conclude that Num sucks.
18:09:45 <aristid> Jafet: i guess it would also be possible to make a contrarianism schema for Jafet :P
18:10:17 <zenware> Does anyone here use archlinux and could help me solve a problem I'm having with xMonad?
18:11:05 <aristid> zenware: consider asking in #xmonad?
18:11:19 <typoclass> aristid: hm, the lack of laws seems less convincing so far. what would be a law, (+) being commutative, that sort of thing?
18:11:39 <aristid> typoclass: sure, and maybe the relation between (+) and (*)
18:11:51 <aristid> typoclass: maybe the associativity of the operations
18:11:55 <Jafet> The main purpose of Num is syntactic sugar
18:12:10 <aristid> typoclass: relationship of (-) with (+) combined with negate
18:12:31 <popl> You know what they say about syntactic sugar...
18:12:40 <Jafet> Someone wants to write Num Matrix, sure, go head
18:14:01 <typoclass> aristid: hm yeah ... i wonder what you'd gain from those laws. in the sense of "because of the law of commutativity, this code here can now be much simpler, or can be written at all"
18:14:24 <aristid> typoclass: well you could use them to reason about code that uses the typeclass
18:14:54 <aristid> typoclass: you could say that a + negate b and a - b are equivalent and use that to refactor your code
18:14:56 <aristid> stuff like that
18:15:05 <typoclass> aristid: right, of course
18:15:18 <Jafet> You can say that about nearly all instances of Num, so what's the problem?
18:15:37 <typoclass> i have a feeling people already do that anyway, it's just not written down. and what jafet says.
18:15:43 <aristid> typoclass: see, i'm not personally criticizing Num, my opinion on it is not strong. i'm trying to relay the criticisms i've heard in this channel:)
18:15:44 <Jafet> You can also say that about Real instead.
18:16:26 <aristid> i do think the structure of the Num-related classes feels somewhat ad hoc
18:16:41 <aristid> what does "RealFrac" actually mean?
18:17:10 <typoclass> aristid: oh yes, i totally agree
18:17:10 <Jafet> Real a, Fractional a => RealFrac a
18:17:41 <chemistree> T:
18:17:55 <aristid> Jafet: RealFrac adds its own functions
18:18:08 <Jafet> Functions that make sense for Real Fractional
18:18:12 <aristid> if those are just more efficient implementations of what can be done with Real and Fractional, that's a law
18:18:21 <typoclass> i've looked at the Report's description of the numeric classes, and it didn't really become clear to me. "what was the reason again why we need a typeclass for this ...?"
18:18:27 <aristid> i.e. that they must be these more efficient implementations of the same thing
18:19:56 <Jafet> But no one writes any instances for these anyway
18:20:08 <Jafet> All the instances that matter have already been written
18:20:57 <mercury^> I am having a weird problem: ghc complains about a type error for:  flip runContT return . callCC $ \k -> (>> k True) (...), but if I replace (>> k True) by (>> return True) it compiles just fine.
18:21:24 <mercury^> I could not reproduce that just playing around in ghci, it only happens for the program I am working on.
18:22:01 <typoclass> mercury^: DMR ...?
18:22:13 <mercury^> What does that mean?
18:22:32 <mauke> @where DMR
18:22:33 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
18:22:39 <typoclass> mercury^: erm sorry :-) i mean, have you tried adding {-# LANGUAGE NoMonomorphismRestriction #-} at the top?
18:23:41 <mercury^> Let's see. :)
18:23:59 <typoclass> mercury^: just a wild guess, mind you
18:24:24 <mercury^> Well, it was correct.
18:24:28 <mercury^> :>
18:24:31 <mercury^> Thanks.
18:25:03 <Eduard_Munteanu> You probably want to add type signatures, though.
18:25:48 <chemistree> can someone direct me to the list of available IRC commands for this channel? seems to be unique (restricted), relative to other channels.
18:25:57 <cl1> when is it better to use let..in instead of where, or vise-versa?
18:26:07 <mauke> chemistree: channels don't have IRC commands
18:26:10 <mauke> servers do
18:26:12 <Eduard_Munteanu> @list
18:26:13 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:26:22 <Eduard_Munteanu> chemistree: you mean lambdabot's commands? ^^
18:26:45 <Eduard_Munteanu> Erm, looking back, probably not.
18:26:51 <typoclass> chemistree: here you go http://www.haskell.org/haskellwiki/Lambdabot it's not really very well documented. i guess the main way of learning it is asking in here, talking to lambdabot privately, and using @help
18:29:02 <Eduard_Munteanu> cl1: http://www.haskell.org/haskellwiki/Let_vs._Where
18:29:33 <Eduard_Munteanu> chemistree: let's talk in here, not privately.
18:30:15 <Eduard_Munteanu> @google irc
18:30:17 <lambdabot> http://en.wikipedia.org/wiki/Internet_Relay_Chat
18:30:17 <lambdabot> Title: Internet Relay Chat - Wikipedia, the free encyclopedia
18:30:48 <Eduard_Munteanu> That should give you some background; they also provide a list of commands.
18:31:09 <cl1> Eduard_Munteanu: thanks
18:31:15 <geekosaur> ...
18:31:23 <typoclass> cl1: it's largely equivalent. it's a matter of personal style, so use your judgement, discuss examples with people ...
18:31:29 * geekosaur just misread that as "...list of comonads".  blames the channel :p
18:31:39 <Eduard_Munteanu> :D
18:31:41 <edwardk> haha
18:33:06 <mercury^> By the way, earlier today ghc had a fatal error when it encountered "lift lift", with lift from mtl (I think). Is that even worth reporting, or is it some FD cornercase not of general interest?
18:33:56 <elliott> that is worth reporting
18:34:38 <typoclass> mercury^: oh, absolutely worth reporting. iirc the ghc trac has a guest account, so you don't need to register just for one bug ticket
18:36:31 <mercury^> Ok, then I just need to see if I can reproduce it now.
18:40:14 <Boney> hey mercury^ check out the mercury programming language ;-)
18:49:07 <mercury^> http://hackage.haskell.org/trac/ghc/ticket/7441
18:58:26 <mercury^> Oh, hmm. It was not the monomorphism restriction after all   -- I just accidentally tried witthe version that uses "return" instead
18:59:43 <mercury^> Any other suggestions on what might cause it?
19:02:41 <hpaste> ag90 pasted “MonadReader over EitherT” at http://hpaste.org/78105
19:03:23 <ag90> Hi. So, I'm trying to figure out the best way to add an EitherT to my monad stack.
19:04:28 <ag90> I have got a StateT over IO and I want functions in the monad to be able to fail with EitherT. Thus far, I've been adding EitherT explicitly to all function definitions at the top level.
19:04:44 <ski> @unmtl EitherT MyError (ReaderT Env IO) a
19:04:44 <lambdabot> EitherT MyError (ReaderT Env IO) a
19:05:31 <ag90> ski, that's what I thought of doing. But that means all functions have to explicitly call lift before accessing the Reader value.
19:05:35 <ski> @unmtl ErrorT MyError (ReaderT Env IO) a
19:05:36 <lambdabot> Env -> IO (Either MyError a)
19:06:15 <ag90> So I tried implementing MonadReader for MonadReader m => (EitherT e m) but I can't, for the life of me, figure out how to write the local there.
19:06:44 <ag90> The only way would end up with the Env wrapped in an Either MyError Env.
19:07:04 <ski>   deriving (Functor, Applicative, Monad, MonadReader Env, MonadIO)
19:07:24 <ag90> You're suggesting using ErrorT over EitherT?
19:07:33 <ski> no
19:07:55 <ski> i just wanted `unmtl' to expand it, and it didn't understood `EitherT'
19:08:09 <ag90> Oh, I see. I'm not familiar with the bot.
19:08:16 <ski> (it's more or less the same as `EitherT')
19:08:48 <ski> `unmtl' can be useful to get an idea of what a specific monad transformer ordering will mean
19:09:12 <ag90> Ah. Okay.
19:09:38 <chemistree> Help:
19:10:00 <ski> @unmtl WriterT w (ErrorT e (StateT s m)) a
19:10:00 <lambdabot> s -> m (Either e (a, w), s)
19:10:01 <ski> @unmtl ErrorT e (WriterT w (StateT s m)) a
19:10:01 <lambdabot> s -> m (Either e a, w, s)
19:10:55 <ski> in the former of those cases, if there's an exception (iow `Left ...' result), the output/logging `w' will be lost, but the state won't
19:11:11 <ski> in the latter, the logging `w' is kept even in case of exception
19:12:15 <ski> @unmtl StateT s (ErrorT e (WriterT w m)) a
19:12:16 <lambdabot> s -> m (Either e (a, s), w)
19:12:27 <ski> in this case, the logging is kept, but not the state
19:12:54 <ski> ag90 : anyway, you should be able to derive `MonadReader Env'
19:13:34 <ag90> Thanks. That will work if I switch over to ErrorT. EitherT is not an instance of that class so generalized deriving will not work.
19:13:43 <ski> hm, `local' ..
19:14:18 <ski>   local :: MonadReader r m => (r -> r) -> (m a -> m a)
19:14:55 <ski>   local :: MonadReader r m => (r -> r) -> (EitherT r m a -> EitherT r m a)  -- in your case
19:15:27 <ag90> Yeah. So, the issue here is that if I'm defining "local f m", m is of the top-level type (EitherT).
19:15:31 * ski sometimes finds it helpful to add the specialized type signatures for instance methods
19:15:39 <ski> too bad i have to add them in a comment
19:17:00 <startling> it'd be cool if you could write many type signatures.
19:17:23 <ski>   newtype EitherT l m a = EitherT { runEitherT :: m (Either l a) }
19:18:15 <ski>   local rr (EitherT mera) = EitherT (..rr..mera..)
19:18:34 * ski is a bit sleepy, needs to think explicitly
19:18:49 <ski>   MonadReader r m
19:18:52 <ski>   rr :: r -> r
19:19:00 <ski>   mera :: m (Either r a)
19:19:05 <ag90> A simple way would be: EitherT $ local f (runEitherT m), but (runEitherT m) is (Either l a) while f :: r -> r
19:19:11 <ski>   ..rr..mera.. :: m (Either r a)
19:20:20 <ski> `runEitherT m :: m (Either l a)', actually
19:20:39 <ag90> Hah, good catch.
19:21:02 <cl1> i'm doing this tutorial (http://www.haskell.org/haskellwiki/Hitchhikers_guide_to_Haskell) and its showing me how to use QuickCheck to do unit testing. However i'm getting the error `coarbitrary' is not a (visible) method of class `Arbitrary'
19:21:34 <cl1> the tutorial has me define coarbitrary = undefined in my Arbitrary instance
19:22:26 <ski>   local rr (EitherT mera) = EitherT (local rr mera)  -- wouldn't this just work ?
19:22:56 <ski> (which is basically the same as your `EitherT $ local f (runEitherT m)')
19:23:44 <ag90> Let me try.
19:24:39 <mm_freak> ski: in GHC 7.6 you can actually write type signatures for type class members
19:24:51 <mm_freak> you have to turn on an extension whose name i always forget
19:25:02 <ski> oh, that's nice
19:25:06 * ski didn't know
19:25:56 <cl1> this must be an old tutorial :k Arbitrary doesn't even have that function in it anymore
19:26:29 <mm_freak> ski: {-# LANGUAGE InstanceSigs #-}
19:26:32 <ski> @kind Test.QuickCheck.Arbitrary
19:26:34 <lambdabot> * -> Constraint
19:26:48 <cl1> err i meant :i Arbitrary
19:27:02 <cl1> @info Test.QuickCheck.Arbitrary
19:27:02 <lambdabot> Test.QuickCheck.Arbitrary
19:27:15 <mauke> ಠ_ಠ
19:28:10 <ski> <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#instance-sigs>
19:28:21 <ski> "The type signature in the instance declaration must be precisely the same as the one in the class declaration, instantiated with the instance type." nice
19:28:47 <ag90> It worked! Thanks, ski!
19:29:13 <ski> ag90 : yw :)
19:29:17 <ski> ag90 : anyway, the problem with trying to use `lift' for `local' is that it takes an `m a' as *input* -- `lift' doesn't do that, it only goes the other way around
19:30:06 <cl1> yay! my first unit test in haskell
19:30:20 <cl1> doesn't feel like a unit test, feels more like fuzzy testing
19:32:26 <ski> ag90 : you might encounter similar problems with `listen' and `pass' for `MonadWriter' -- solution is to open the data type as above, instead of using `lift' (which i think should work fine for the other cases)
19:32:48 <ski> quickcheck testing isn't quite unit testing
19:32:52 <ski> it's property testing
19:32:53 <ag90> I had been staring at this too long. Just unwrapping the data type just did not occur to me.
19:33:25 <ag90> Thanks.
19:34:23 <cl1> where do y'all post code to in here?
19:34:37 <shachaf> @paste
19:34:37 <lambdabot> Haskell pastebin: http://hpaste.org/
19:34:45 <cl1> thanks
19:41:22 <cl1> so i just implemented an instance of this Arbitrary typeclass for my Dir data type. How do i scope this instance so it is only visible to certain functions?
19:42:29 <Ralith> why do you want that?
19:42:51 <startling> cl1: you can't, unfortunately.
19:43:21 <startling> cl1, you might want to write some Gen Mytype and not put it in an instance.
19:44:05 <cl1> startling: i appreciate the help, however I didn't understand anything you said about the Gen Mytype
19:44:38 <cl1> Ralith, because I don't want my type being used as an instance of Arbitrary anywhere except in those functions
19:44:54 <Ralith> cl1: why not?
19:44:59 <startling> cl1, when you write instance Arbitrary Mytype where arbitrary = ..., "arbitrary"'s type is Gen Mytype.
19:46:43 <cl1> Ralith, because its only applicable while unit testing
19:47:50 <startling> cl1, what? it's not hurting anything.
19:48:36 * hackagebot xcb-types 0.6.2 - Parses XML files used by the XCB project  http://hackage.haskell.org/package/xcb-types-0.6.2 (AntoineLatter)
19:48:38 <cl1> startling, i know I was just curious about it. i'm sorta new to haskell.
19:48:57 <kizzo> Where is the %% operator defined?  It's funny how you can't search Google with strings like that.
19:49:07 <startling> @hoogle (%%)
19:49:07 <lambdabot> No results found
19:49:08 <cl1> i'm used to programmers misuing features
19:49:27 <startling> kizzo: try :info (%%) in ghci
19:49:41 <startling> cl1, oh, don't worry about it.
19:49:42 <kizzo> Yeah I searched Hoogle for that too and nothing came back.
19:50:02 <simpson> :t (%%) -- is it in lens?
19:50:04 <lambdabot>     Not in scope: `%%'
19:50:04 <lambdabot>     Perhaps you meant one of these:
19:50:04 <lambdabot>       `R.%' (imported from Data.Ratio), `%' (imported from Control.Lens),
19:50:11 <edwardk> no
19:50:15 <edwardk> what would (%%) do?
19:50:22 <startling> flip (%)
19:50:24 <shachaf> kizzo: How about Hayoo?
19:50:28 <edwardk> we call that ($) ;)
19:50:47 <kizzo> Oh it's defined in http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.4.3/doc/html/Graphics-DrawingCombinators.html
19:50:52 <edwardk> :t ($)
19:50:53 <kizzo> Sorry.
19:50:54 <lambdabot> (a -> b) -> a -> b
19:50:56 <edwardk> :t (%)
19:50:58 <lambdabot> a -> (a -> b) -> b
19:51:21 <kizzo> I'm trying to get the example at the top to compile and didn't search THAT page for %%
19:51:29 <startling> hah
19:51:37 <startling> edwardk: yeah, that's the joke. :/
19:51:41 <yepyep> Greetings, I'm attempting to implement a Red Black Tree in Haskell as an exercise in using FP for data structures.
19:52:00 <yepyep> I have a question regarding typeclasses in data constructors
19:52:33 <rwbarton> > return 3 :: (String, Integer)
19:52:35 <lambdabot>   No instance for (GHC.Base.Monad ((,) GHC.Base.String))
19:52:35 <lambdabot>    arising from a us...
19:52:37 <startling> typeclasses *in* datat constructors?
19:52:46 <yepyep> err
19:52:55 <yepyep> perhaps if i post an example it would be clearer
19:53:19 <yepyep> just one line.  my terminology may also be off, so pardon me if i sound ridiculous coming from imperative languages
19:53:41 <yepyep> data (Ord a) => RBTree a = Empty | RBNode Color (RBTree a) a (RBTree a) deriving Show
19:53:43 <cl1> so in do notation this (<-) operator, where does it come from?
19:53:59 <shachaf> It's not an operator, it's syntax.
19:54:03 <shachaf> cl1: See Hoogle. :-)
19:54:31 <cl1> hence why i can't find it in ghci with :t, :i, or :k
19:54:51 <yepyep> attempting to compile gives this error:  Illegal datatype context (use -XDatatypeContexts): Ord a =>
19:55:03 <startling> cl1, it desugars to >>= and some lambdas.
19:55:04 <shachaf> yepyep: Don't put Ord a => there. I won't do you any good.
19:56:04 <yepyep> do i need to use the ord typeclass in every function definition where i need to compare a?  or is there some way i can indicate that a inside the data constructor should implement Ord?
19:56:16 <startling> yepyep: the former
19:57:04 <yepyep> I also read something about GADTs.  are they a viable alternative?  It seemed a bit high level so i didn't really understand it all
19:57:24 <shachaf> yepyep: You can do something with GADTs where you won't need the context for every function that uses it.
19:57:27 <shachaf> But don't.
19:57:39 <shachaf> What that does is store the Ord dictionary with the type.
19:58:22 <yepyep> when would it be desirable to use GADTs then?
19:59:15 <shachaf> There are many different contexts where it's desirable to use GADTs
19:59:29 <shachaf> (In fact I think you can do this without GADT syntax.)
19:59:38 <shachaf> (As in data Foo a = Ord a => Foo a)
19:59:47 <shachaf> (But don't do that.)
20:00:27 <yepyep> so i could redefine a in terms of a data type that implements ord?  seems a bit overwrap-y
20:01:24 <shachaf> ?
20:01:36 <yepyep> never mind. on to another question
20:02:11 <yepyep> say I want an int with a custom bound, say 0 to 5000
20:02:38 <yepyep> what is the most idiomatic way to implement that in a way that someone couldn't override the bounds
20:02:52 <shachaf> Is the bound known at compile time or at runtime?
20:03:06 <yepyep> It would be known at compile time
20:03:28 <shachaf> You could make a newtype Foo = Foo Int
20:03:41 <shachaf> instance Num Foo where ...
20:04:09 <shachaf> Depending on the behavior you wanted you can implement all the Num operations that way.
20:04:53 <yepyep> i was learning about newtype today.  Do you always need to unpack it to treat it like the underlying concrete type?
20:05:09 <shachaf> Yes.
20:05:14 <Ralith> there's GeneralizedNewtypeDeriving
20:05:21 <shachaf> Yes, but that won't help you here.
20:05:31 <Ralith> depends what he wants from his Num instance
20:05:31 <shachaf> (This is purely for the type checker -- at runtime it'll be represented the same way.)
20:06:13 <Jafet> Don't forget Bounded Foo, Enum Foo, Eq Foo, Integral Foo, Ord Foo, Read Foo, Real Foo, Show Foo
20:07:19 <Ralith> indeed :P
20:07:27 <yepyep> :/
20:07:46 <name> nam
20:08:33 <yepyep> does changing bounded actually do anything aside from changing the values for maxBound, minBound for a given type?  I initially was thinking about changing the minBound and maxBound.
20:08:40 <xunatai> Complex Foo
20:08:55 <rwbarton> @src Bounded
20:08:56 <lambdabot> class  Bounded a  where
20:08:56 <lambdabot>     minBound, maxBound :: a
20:09:55 <yepyep> mmm.  well thanks
20:10:23 <name> @src sort
20:10:23 <lambdabot> sort = sortBy compare
20:10:33 <name> @src sortBy
20:10:34 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
20:10:42 <name> @src insertBy
20:10:42 <lambdabot> insertBy _   x [] = [x]
20:10:43 <lambdabot> insertBy cmp x ys@(y:ys') = case cmp x y of
20:10:43 <lambdabot>                                  GT -> y : insertBy cmp x ys'
20:10:43 <lambdabot>                                  _  -> x : ys
20:11:01 <name> @src foldr
20:11:02 <lambdabot> foldr f z []     = z
20:11:02 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:11:04 <yepyep> wow. nice irc bot feature
20:11:15 <Ralith> it's even nicer when you use it in PM!
20:11:48 <yepyep> haha
20:12:12 <xunatai> @src splitAt
20:12:13 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
20:13:28 <shachaf> Speaking of splitAt, should there be a splittingAt lens now?
20:13:37 * hackagebot publicsuffixlist 0.0.1 - Is a given string a domain suffix?  http://hackage.haskell.org/package/publicsuffixlist-0.0.1 (MylesMaxfield)
20:14:44 <yepyep> this is a bit meta but...  is it normal to feel pretty overwhelmed with some of the higher level stuff in haskell like applicatives and state monad etc coming from an imperative background?
20:15:26 <mgsloan> yepyep: yep yep
20:15:31 <yepyep> I was initially going to learn lisp as a first functional language, but I thought it seemed too dependent on using emacs with all those parens
20:16:07 <xunatai> i'm overwhelmed as well
20:16:10 <yepyep> no offense to emacs.  i just cant get used to chords
20:16:14 <xunatai> this is my third attempt at learning haskell
20:16:33 <gusto> ah, i had more
20:16:52 <gusto> and emacs was supposed to be easier than VI, well mission failed
20:17:25 <sclv> my advice is to stick clear of applicatives and monads as long as possible
20:17:28 <sclv> and just do pure code
20:17:33 <sclv> with a minimal IO wrapper
20:17:41 <gusto> yes
20:17:45 <sclv> then once you're comfortable with idiomatic functional programming
20:17:56 <sclv> you can start to muck around more
20:18:04 <xunatai> that's what i'm sort of doing
20:18:13 <yepyep> I feel pretty comfortable with stuff in prelude
20:18:24 <mgsloan> Yup, these abstractions make more sense at that point, and after becoming comfortable with the syntax / types
20:18:32 <gusto> "muck around more" is better done with other languages, like java or such
20:18:35 <yepyep> but some of the stuff in Control.Applicative et al seem a bit high level
20:18:44 <sclv> applicative is really simple
20:18:51 <gusto> you mean GHCi as "prelude"
20:18:52 <sclv> but you shouldn't feel you need to learn libraries to learn them
20:18:57 <sclv> reach for them when you need them
20:19:11 <shachaf> Keep in mind that doing I/O is a separate task from "understanding monads".
20:19:15 <rwbarton> you have to write the code the direct, laborious way before you can appreciate the higher level of abstraction
20:19:21 <yepyep> isn't I/O a monad?
20:19:26 <shachaf> Lots of things are.
20:19:31 <yepyep> Lists?
20:19:32 <sclv> yeah, but its better to understand monads sans io
20:19:44 <shachaf> And it's (maybe) better to understand IO sans monads!
20:19:57 <sclv> state, reader, writer, trees, maybe, either, etc.
20:20:16 <sclv> write code you want, and reach for the abstractions when you need them
20:20:17 <shachaf> By the way, I figured that when people say that a monad is like a box, what they really mean is just that it's covariant.
20:20:57 <sclv> the less you use monadic stuff at all, the more you'll appreciate it when you do, and the generally cleaner and more functional your code will be
20:20:59 <Jafet> And comonads are variant
20:21:12 <sclv> covariant in what?!
20:21:21 <rwbarton> the stuff in the box!!
20:21:39 <sclv> which varies covariantly with regards to what?
20:21:42 <yepyep> what's covariant?  will abstract math/theory of comp help me learn haskell?
20:21:53 <sclv> yepyep: the opposite
20:21:57 <shachaf> Nah.
20:21:57 <Ralith> shachaf: I'm sure the newbies will find that very enlightening.
20:22:04 <sclv> the more haskell you learn, the more you'll appreciate abstract math/CS
20:22:23 <shachaf> Ralith: I think the concept is a pretty important one, even early on.
20:22:34 <shachaf> You could use nicer names, like "producer" and "consumer".
20:22:59 <shachaf> Though OO people don't seem to have an issue with "covariant" and "contravariant"...
20:23:08 <sclv> I still don't understand what you mean though
20:23:15 <Ralith> OO people do terrible things to terminology
20:23:20 * startling covaries shachaf 
20:23:23 <sclv> do you mean return :: a -> m a is covariant in some sense?
20:23:28 <shachaf> sclv: "Maybe a" is covariant in "a"
20:23:53 * startling sticks Ralith in an AbstractProxyLambdaBeanMonad
20:23:54 <sclv> ah, as in a covariant functor!
20:23:57 <shachaf> Right.
20:24:07 <sclv> ok, yeah, that makes a lot of sense!
20:24:47 * Ralith throws himself to freedom
20:25:12 <startling> Ralith, it's not a MonadError
20:25:23 <Jafet1> :t fail
20:25:25 <lambdabot> Monad m => String -> m a
20:25:51 <Jafet1> fail is, like, extra covariant
20:26:19 <cl1> so Maybe a is more generic than a?
20:26:32 <sclv> no
20:26:39 <yepyep> anyways, thanks for the advice.  I'll avoid the higher level stuff for now.
20:26:48 <Ralith> startling: precisely
20:26:55 <Ralith> startling: I snuck out through the type error :D
20:29:55 <cl1> Given Eq a => Ord a, Maybe (Ord a) is also Maybe (Eq a), that is where the covariance is?
20:30:37 * cl1 is confused
20:30:46 <rwbarton> yes, you are
20:30:54 <Ralith> (Ord a) is not a thing you should be feeding to Maybe.
20:30:59 * cl1 curses parametric polymorphism
20:31:05 <shachaf> cl1: No, this is unrelated to type classes.
20:31:40 * startling o O ( Do coeggs come from covaries? )
20:31:52 <pqmodn> http://mathworld.wolfram.com/CovariantFunctor.html
20:32:03 <shachaf> @ki 'Just (Eq Int)
20:32:05 <lambdabot> Maybe Constraint
20:32:13 <beaky> how do I generate a tuple of size 100
20:32:18 <copumpkin> you don't
20:32:24 <shachaf> You hold down the , key
20:32:29 <beaky> lol
20:32:34 <Jafet1> :t (,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,)
20:32:35 <rwbarton> ( ctrl-u 99 )
20:32:36 <lambdabot> a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> t28 -> t29 -> t30 -> t31 -> t32 -> t33 -> t34 -> t35 -> t36 -> t37 ->
20:32:36 <lambdabot>  t38 -> t39 -> t40 -> t41 -> t42 -> t43 -> t44 -> t45 -> t46 -> t47 -> t48 -> t49 -> t50 -> t51 -> t52 -> t53 -> t54 -> t55 -> t56 -> t57 -> t58 -> t59 -> t60 -> t61 -> t62 -> t63 -> t64 -> t65 ->
20:32:36 <lambdabot> t66 -> t67 -> t68 -> t69 -> t70 -> t71 -> t72 -> t73 -> t74 -> t75 -> t76 -> t77 -> t78 -> t79 -> t80 -> t81 -> t82 -> t83 -> t84 -> t85 -> t86 -> t87 -> t88 -> t89 -> t90 -> t91 -> t92 -> t93 ->
20:32:36 <lambdabot> t94 -> t95 -> t96 -> t97 -> t98 -> t99 -> t100 -> t101 -> (a, b, c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, t28, t29, t30, t31, t32, t33, t34, t35, t36, t37, t38, t39,
20:32:36 <lambdabot> t40, t41, t42, t43, t44, t45, t46, t47, t48, t49, t50, t51, t52, t53, t54, t55, t56, t57, t58, t59, t60, t61, t62, t63, t64, t65, t66, t67, t68, t69, t70, t71, t72, t73, t74, t75, t76, t77, t78, t79,
20:32:38 <lambdabot>  t80, t81, t82, t83, t84, t85, t86, t87, t88, t89, t90, t91, t92, t93, t94, t95, t96, t97, t98, t99, t100, t101)
20:32:42 <rwbarton> with a comma in there too
20:32:53 <copumpkin> ಠ_ಠ
20:33:04 <shachaf> (,)))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))
20:33:17 <beaky> I want to solve the birthday problem in haskell
20:33:31 <Nereid> my birthday is just fine thanks :(
20:33:32 <shachaf> beaky: 1.2√n
20:33:36 <Ralith> I want to eat dinner
20:33:39 <cl1> that link cleared things up
20:34:19 <rwbarton> http://hackage.haskell.org/package/lens made it onto my most frequently visited pages in chrome
20:34:22 <beaky> I need to generate a list of all permutations of a 100-tuple
20:34:32 <Nereid> please don't use such tuples
20:34:40 <beaky> what do I do instead
20:34:41 <shachaf> > product [1..100]
20:34:42 <Nereid> use a list or vector or something
20:34:43 <pqmodn> beaky: list might be easier to work with
20:34:43 <lambdabot>   933262154439441526816992388562667004907159682643816214685929638952175999932...
20:34:46 <cl1> [1..100]
20:34:49 <startling> rwbarton: isn't it nice?
20:35:01 <rwbarton> if it was really nice I would have memorized the whole API by now
20:35:05 <copumpkin> beaky: tuples give you heterogeneity that you don't need
20:35:07 <startling> rwbarton, just having to type 'h' is nice too
20:35:12 <beaky> right
20:35:13 <rwbarton> heh, that is true :)
20:35:25 <rwbarton> I actually have to type h rightarrow l
20:35:25 <copumpkin> beaky: you can have fixed-length homogeneous lists too
20:35:29 <Jafet1> > permutations [1..100]
20:35:31 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:35:35 <Nereid> > permutations [1..3]
20:35:38 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
20:35:41 <Nereid> > permutations [1..]
20:35:43 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:35:45 <beaky> ah cool
20:35:54 <beaky> but aren't haskell lists slow?
20:35:57 <rwbarton> uh
20:35:59 <copumpkin> > length $ permutations [1..10]
20:36:00 <Jafet1> > take 4 <$> permutations [1..]
20:36:01 <startling> copumpkin: where are they?
20:36:02 <lambdabot>   3628800
20:36:02 <lambdabot>   can't find file: L.hs
20:36:03 <copumpkin> beaky: not particularly
20:36:05 <Jafet1> > take 4 <$> permutations [1..]
20:36:07 <beaky> ah
20:36:08 <lambdabot>   [[1,2,3,4],[2,1,3,4],[3,2,1,4],[2,3,1,4],[3,1,2,4],[1,3,2,4],[4,3,2,1],[3,4...
20:36:11 <rwbarton> ugh
20:36:13 <copumpkin> beaky: you just need to be aware of what they are and what they aren't
20:36:22 <rwbarton> more madlibs questions
20:36:22 <Nereid> > head <$> permutations [1..]
20:36:22 <beaky> what are haskell lists?
20:36:24 <lambdabot>   [1,2,3,2,3,1,4,3,3,4,2,2,4,1,1,4,2,2,4,1,1,4,3,3,5,4,4,4,5,3,3,3,5,2,2,2,5,...
20:36:26 <copumpkin> they're not slow for what they are, but they aren't arrays
20:36:30 <Nereid> ^ explain this
20:36:36 <copumpkin> Nereid: you can't explain that.
20:36:38 <Nereid> :P
20:36:45 <Jafet1> @oeis 1 2 3 2 3 1 4 3
20:36:52 <shachaf> rwbarton: I wish I had a rightarrow key. :-(
20:36:57 <lambdabot>  (prime(k)-prime(j))/8, where the pairs (k,j) are given by A205705 and A205706.
20:36:58 <lambdabot>  [1,1,2,1,2,3,2,3,1,4,3,1,3,5,4,3,5,3,2,6,5,3,2,7,6,5,2,7,6,4,3,1,8,7,6,3,1,8...
20:37:01 <beaky> :t (<$>)
20:37:02 <cl1> so when you said Maybe a is covariant in a, you really meant that Maybe a is isomorphic in its covariance with regards to a? yes?
20:37:02 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:37:14 <Nereid> cl1: what?
20:37:19 <Nereid> cl1: it just means it's a functor.
20:37:26 <beaky> > (head . permutations) [1..]
20:37:27 <Nereid> as opposed to a contravariant functor.
20:37:28 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:37:35 <Jafet1> I wonder which subset of permutations [1..] is contained in permutations [1..].
20:37:46 <rwbarton> the finitely supported ones, I hope
20:37:47 <Nereid> Jafet1: every subset.
20:38:01 <copumpkin> lol
20:38:09 <beaky> > map head (permutations [1..])
20:38:11 <lambdabot>   [1,2,3,2,3,1,4,3,3,4,2,2,4,1,1,4,2,2,4,1,1,4,3,3,5,4,4,4,5,3,3,3,5,2,2,2,5,...
20:38:25 <copumpkin> > permutations [1..] !! 10
20:38:27 <lambdabot>   [2,4,3,1,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:38:35 <Nereid> > permutations [1..] !! 362880
20:38:37 <lambdabot>   [10,9,8,7,6,5,4,3,2,1,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:38:45 <copumpkin> cute
20:38:57 <rwbarton> > permutations [1..] !! 362881
20:38:58 <copumpkin> now we know how to reverse the prefix of a list!
20:39:00 <lambdabot>   [9,10,8,7,6,5,4,3,2,1,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:39:05 <Nereid> :D
20:39:13 <Nereid> > permutations [1..] !! 362879
20:39:15 <lambdabot>   [4,6,3,7,2,8,1,9,5,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:39:22 <copumpkin> oh man, I can't wait until a newb comes along asking how to reverse the prefix of a list
20:39:23 <shachaf> > over (taking 5 traverse) reverse [1..50]
20:39:25 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
20:39:25 <lambdabot>    arising from a u...
20:39:28 <Nereid> copumpkin: haha.
20:39:29 <rwbarton> oh i get it, right
20:39:41 <shachaf> > over (partsOf $ taking 5 traverse) reverse [1..50]
20:39:43 <lambdabot>   [5,4,3,2,1,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
20:39:51 <copumpkin> shachaf: screw that
20:39:52 <Crockeo> copumkin: How do you reverse the prefix of a list?
20:39:55 <Crockeo> Haha
20:39:58 <copumpkin> Crockeo: funny you should ask!
20:39:59 <rwbarton> > [ permutations [1..] !! (product [1..n] - 1) | n <- [1..10] ]
20:40:00 <Nereid> > over (partsOf $ taking 5 traverse) reverse [1..] -- :((((
20:40:02 <lambdabot>   [[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
20:40:03 <lambdabot>   *Exception: stack overflow
20:40:08 <sclv> cl1: the point is just that you have an fmap operation, of type (a -> b) -> f a -> f b
20:40:11 <rwbarton> > [ take n $ permutations [1..] !! (product [1..n] - 1) | n <- [1..10] ]
20:40:12 <shachaf> Nereid: It works in HEAD!
20:40:14 <lambdabot>   [[1],[2,1],[1,3,2],[3,1,4,2],[2,4,1,5,3],[4,2,5,1,6,3],[3,5,2,6,1,7,4],[5,3...
20:40:16 <sclv> which is really a "covariant" fmap
20:40:21 <Crockeo> :(
20:40:24 <Crockeo> Maaaaaaaan I forgot a p in your name
20:40:25 <Nereid> shachaf: oh you figured it out now?
20:40:26 <copumpkin> rwbarton: why -1?
20:40:28 <sclv> because there's contramap of type (b -> a) -> f b -> f a
20:40:38 <rwbarton> because 0 indexed
20:40:42 <sclv> or rather (b -> a) -> f a -> f b
20:40:46 <shachaf> Nereid: Yep, about an hour ago.
20:40:49 <Nereid> cool
20:40:52 <rwbarton> i want to see what the last one it generates is
20:40:52 * Nereid looks
20:40:55 <shachaf> Well, not "properly"
20:40:56 <copumpkin> > take 10 $ permutations [1..] !! 362880
20:40:59 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
20:41:00 <Nereid> ohh
20:41:01 <Nereid> :(
20:41:07 <shachaf> Nereid: But at least there's no unsafeCoerce now
20:41:08 <sclv> so a monad is a "box" in the very loose sense that you can reach into it and "do something" to its contents
20:41:09 <copumpkin> > take 10 $ permutations [1..] !! product [1..10]
20:41:10 <Nereid> heh
20:41:11 <lambdabot>   [11,10,9,8,7,6,5,4,3,2]
20:41:11 <rwbarton> that's the first permutation that moves 10 (362880 = 9!)
20:41:12 <shachaf> Nereid: So I'm pleased with myself.
20:41:23 <copumpkin> yeah
20:41:26 <cl1> sclv : i think i understand
20:41:29 <rwbarton> I want to see the last permutation that only moves [1..9]
20:41:29 <sclv> which is a bad intuition, but explains why people find it an intuition at all
20:41:53 <Jafet1> @quote kmc synonymous
20:41:54 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
20:41:58 <shachaf> sclv: Well, the "box" analogy, if it applies at all, applies even to things that aren't monads.
20:42:05 <gulk> anyone can point me to the direction on this: i have a X,Y and radius of a circle. I need to generate an aquimedean spiral with them, as a tag cloud, and then i need to check if the circles intersects each other?
20:42:05 <sclv> i agree
20:42:09 <gulk> ive generated the spiral
20:42:13 <gulk> but i cant get the checking to work
20:42:16 <gulk> with recursion
20:42:31 <sclv> it applies to applicative functors too.
20:42:39 <shachaf> And regular functors!
20:42:39 <sclv> or really any pointed functor
20:42:39 <Nereid> doesn't it apply to functors in general?
20:42:49 <Jafet1> You can't do this in haskell, it isn't webscale enough.
20:42:49 <Nereid> why pointed?
20:42:56 <sclv> well i'd argue that the other half of a box analogy is you can "put something in"
20:43:03 <Nereid> heh
20:43:06 <sclv> so you need a point :: a -> f a
20:43:10 <shachaf> What's a non-pointed Functor instance?
20:43:18 <Nereid> Const Void
20:43:21 <copumpkin> shachaf: Map
20:43:31 <copumpkin> Map k that is
20:43:33 <Nereid> I'm boring.
20:43:39 <shachaf> sclv: The other other half of a box analogy is that you can "take something out". And that certainly doesn't apply. :-)
20:44:04 <Nereid> you can take something out as long as you put it back in once you're done with it
20:44:09 <sclv> well that's why is a box full of nuclear waste that you have to don a spacesuit to enter
20:44:11 <Jafet1> So Functor satisfies one half of the box analogy, but not the other two halves.
20:44:13 <sclv> or whatever
20:44:24 <sclv> so that's where the analogy breaks down and goes crazy, basically
20:45:00 <Nereid> monads are like analogies
20:45:07 * shachaf sighs.
20:45:08 <Ralith> delicious with salsa
20:45:15 <shachaf> I was hoping to avoid the monad jokes for once.
20:45:34 <copumpkin> @quote analogies
20:45:35 <lambdabot> RaptorJesus says: using analogies on logic is like using a wrench on rivets
20:45:36 <copumpkin> @quote analogies
20:45:37 <Ralith> it's best not to hope for futile things
20:45:37 <lambdabot> mmorrow says: a functor is like an analogy between two analogies
20:45:50 <Crockeo> So a monad walks into a bar and confuses the fuck out of all of the imperative programmers.
20:46:01 <Crockeo> Such as myself a short time ago.
20:46:04 <Crockeo> And myself now.
20:46:10 <Crockeo> And probably myself for the next few weeks.
20:46:10 <Ralith> what about a short time in the future
20:46:13 <sclv> an analogy is a functor, more like
20:46:28 <rwbarton> actually a natural transformation is an analogy between analogies yes
20:46:52 <sclv> haha, yes that would be the consequence
20:47:29 <Crockeo> "How many distinct terms are in the sequence generated by ab for 2  a  100 and 2  b  100?" from Project Euler
20:47:33 <Crockeo> if I were doing that in Java or C++
20:47:35 <Crockeo> I'd be boggled
20:47:39 <Crockeo> but in Haskell that's super-easy.
20:48:38 * hackagebot xhb 0.5.2012.11.23 - X Haskell Bindings  http://hackage.haskell.org/package/xhb-0.5.2012.11.23 (AntoineLatter)
20:48:40 * hackagebot plot 0.1.6 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.6 (VivianMcPhail)
20:48:50 <shachaf> Sounds like you should learn more Java or C++, then.
20:49:16 <Nereid> lol
20:49:17 <Crockeo> Well, boggled as in I'd have to do /some/ work
20:49:17 <Crockeo> same difference, y'know?
20:49:19 <Crockeo> (Still, I probably should)
20:49:35 <Crockeo> "length $ nub [a ^ b | a <- [2..100], b <- [2..100]]" ... I think
20:49:56 <Crockeo> It's not ab, by the way, it just copied weirdly, it's a ^ b
20:50:29 <shachaf> OK, so there are more library functions available, that's all.
20:50:55 * cl1 is still confused about this covariance thing
20:51:20 <Nereid> cl1: you can safely ignore "covariant". a "covariant functor" is just a functor.
20:51:27 <Crockeo> And more library functions means less coding.
20:51:27 <meromorph> can anyone give me a few tips about parallelisation... I've been attempting it but it just comes out way slower each time and I don't really know how to glean useful information from threadscope
20:52:08 <cl1> Nereid: so covariant is the identity function for functor?
20:52:10 <meromorph> in essence my program creates some large traversable structure, maps a (somewhat) expensive functor over it, then turns the thing into a list and uses that list to produce the output
20:52:15 <cl1> I kid, lol
20:52:16 <Nereid> cl1: what?
20:52:17 <Nereid> :v
20:52:21 <pqmodn> heh
20:52:41 <meromorph> so far I just tried parList, parListChunk and parBuffer once I have converted the structure to a list
20:52:53 <cornihilio> do people only use haskell-mode with emacs? I'm wondering if there is a decent alternative
20:52:54 <meromorph> and I never seem to get a speedup
20:53:10 <ski> cl1 : there are both covariant and contravariant functors. the former is the "normal" case, and every instance of the `Functor' class is of the former type
20:53:16 <sclv> covariant means two things vary the same way
20:53:27 <sclv> contravariant means that one goes the opposite way
20:53:43 <sclv> so (b -> a) -> f a -> f b is contravariant
20:53:57 <sclv> a -> b is a covariant functor in b, but a contravariant functor in a
20:54:11 <sclv> because we can "precompose" the function we're contramapping to the front
20:54:13 <pqmodn> @hoogle (b -> a) -> f a -> f b
20:54:14 <lambdabot> Data.IntMap updateMax :: (a -> a) -> IntMap a -> IntMap a
20:54:14 <lambdabot> Data.IntMap updateMin :: (a -> a) -> IntMap a -> IntMap a
20:54:14 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
20:55:21 <cl1> so basically there is no rank involved with this covariance, only ordering
20:55:47 <copumpkin> ⨀_⨀
20:56:03 <sclv> its analogous with covariance and contravariance in e.g. linear algebra
20:56:26 <sclv> it turns out to be the "same" thing from an abstract (categorical) enough standpoint
20:56:26 <cl1> I have confused covariance from computer science with covariance from category theory, I think
20:56:27 <Nereid> is it?
20:56:37 <copumpkin> cl1: they're the same thing
20:56:38 <sclv> and also the same as co/contravariance from subtyping
20:57:23 <cornihilio> is there an alternative to haskell-mode for emacs?
20:58:44 <cmccann> covariance can be confusing when it's unclear which thing is varying in the same way as what other thing
20:58:59 <cl1> cmccann: you got that right
20:59:34 <cmccann> but hey, at least contravariance is easy once you've figured out which thing is which
20:59:58 <sclv> some contrafunctors: http://hackage.haskell.org/packages/archive/contravariant/0.2.0.2/doc/html/Data-Functor-Contravariant.html
21:00:05 <copumpkin> cl1: fmap :: (a -> b) -> (f a -> f b)
21:00:12 <copumpkin> cl1: do you see parallel direction there?
21:00:24 <cl1> copumpkin: yes
21:00:31 <copumpkin> now, try (a -> b) -> (f a <- f b)
21:00:33 <copumpkin> :P
21:00:52 <cl1> (b -> a) -> (f a -> f b)
21:00:57 <copumpkin> of course <- isn't a real operator, so you write it the other way around, (a -> b) -> (f b -> f a)
21:00:57 <sclv> cornihilio: i think most of the "alternative" modes for emacs got folded into haskell-mode
21:01:04 <sclv> but haskell-mode is very configurable
21:01:20 <copumpkin> cl1: sure, if you like writing it that way around
21:01:21 <sclv> so if there's stuff you don't like, you probably can change it
21:02:23 <shachaf> type a <-- b = b -> a
21:02:41 <cl1> does haskell-mode allow you to navigate to definition arbitrarily deep, and then navigate back to where you started?
21:02:57 <shachaf> That sounds like an Emacs question, not a Haskell question.
21:03:00 <shachaf> In vim I'd just use ^O
21:03:22 <PatrixCR> hello guys. is haskell "structurally typed"?
21:03:23 <applicative> funny, I was just checking "type a <-- b = b -> a" to make sure
21:03:29 <copumpkin> PatrixCR: no.
21:04:12 <shachaf> applicative: Hmm, you can type a ← b = b -> a
21:04:23 <shachaf> and type a → b = a -> b
21:04:32 <copumpkin> or just turn on unicode syntax
21:04:41 <shachaf> UnicodeSyntax won't give me ←
21:04:46 <copumpkin> yeah, for the forward arrow I meant
21:05:01 <applicative> hah, it deprives you of symbols
21:05:28 <PatrixCR> Does a PL have to be "nominally typed" or "structurally typed", or can it be both (hybrid)?
21:06:16 <ski> PatrixCR : arguably, `data's and `newtype's introduce the former, while the latter is also present in Haskell
21:06:17 <copumpkin> you could be both, I guess
21:06:32 <applicative> meromorph: Is your module too complicated to paste? -- Not that any brilliant idea is likely to occur
21:06:32 <copumpkin> ski: using typeclasses?
21:06:45 <ski> copumpkin : sorry ?
21:06:53 <copumpkin> "the latter is also present in haskell"
21:07:49 <ski> i mean that if you compare a `Foo' with `Bar' from `type Foo = [String]' and `type Bar = [[Char]]', then `Foo' and `Bar' are structually equal
21:07:54 <sclv> just use either, maybe and co.
21:08:25 <ski> (also if you compares `[[Char]]' directly with `[[Char]]', though that's more obvious)
21:08:30 <Jafet> @hoogle toDyn
21:08:31 <shachaf> Moreover, "[Char]" and "[  Char  ]" are structurually equal!
21:08:31 <lambdabot> Data.Dynamic toDyn :: Typeable a => a -> Dynamic
21:08:37 <copumpkin> ski: from what I've seen of that structural typing stuff, most people use it when talking about records, and it seems to resemble row polymorphism
21:08:40 <copumpkin> but maybe I'm wrong there
21:08:47 <Jafet> [] ([] Char)
21:08:54 <copumpkin> (because most people haven't even heard of sum types :P)
21:09:19 <mgsloan> doesn't typeclass-per-row give you most of what you need?
21:09:21 <sclv> arguably a la carte is structural typing
21:09:23 <shachaf> ∃t. MostPeopleHaven'tHeardOf(t)
21:09:31 <copumpkin> mgsloan: that's what I was asking if ski intended
21:09:36 <mgsloan> yup
21:09:43 <ski> copumpkin : well, afaiu, that extra complication needn't be in the picture if we're just talking basic "nominal vs. structural typing"
21:09:46 <sclv> with records that's structural *subtyping*
21:10:10 <mgsloan> isn't structural typing always about subtyping?
21:10:13 <applicative> it seems to be independent of subtyping, to judge from wikipedia
21:10:19 <mgsloan> hmm
21:10:27 <ski> mgsloan : i don't think so
21:10:38 <ski> structural *sub*typing is another thing, though
21:11:00 <sclv> in haskell, nominal and structural subtyping are on absolutely equal footing, since we have neither.
21:11:07 <applicative> mgsloan: it sounds like if our compiler had a name independent view of the types we define on the surface, it would be 'structurally typed'
21:11:09 <meromorph> applicative: yeah, it's a bit long, sorry
21:11:50 <mgsloan> applicative: gotcha.  I think my confusion comes from the intuition that there'd be little benefit to doing that if you weren't going to use it for subtyping
21:11:58 <Nereid> hmm
21:12:07 <Nereid> how come the aeson-lens on hackage is more up-to-date than on github?
21:12:17 <ski> sclv : do you mean that we don't have one to the extent we have the other, or something more serious ?
21:12:20 <edwardk> Nereid; no idea
21:12:31 <meromorph> but in essence it's what I said, build a traversable structure, map a functor over it (which is really the thing I want to be evaluated in parallel as much as possible), then turn the structure into a list and consume that list in order to produce output
21:12:40 <sclv> i mean we have neither, since we have no subtyping at all :-P
21:12:54 <sclv> (but we can build either, with sufficient pain)
21:14:16 <meromorph> there shouldn't be anything forcing the thunks to be evaluated before I actually ask for it to happen with that parList etc...
21:14:20 <copumpkin> sclv: we sort of have subtypey behavior with typeclasses (especially ocne you start doing higher-rank stuff)
21:14:28 <applicative> nereid are you looking at https://github.com/tanakh/aeson-lens
21:14:30 <meromorph> I can show what some of the threadscope graphs looked like but I couldn't really get much out of it myself
21:14:41 <Nereid> applicative: yes
21:15:23 <ski> in Pascal, when you define a name to stand for e.g. a reference to boolean, then that type is different from any other type (including other names defined to stand for reference to boolean) -- so it acts a bit like `newtype', though strangely enough, there's still no explicit conversion between this named type and the "reference type itself" (arguably the latter doesn't exist in itself, but only as a construct for defining types (like `data' i
21:16:16 <copumpkin> "defining types (like `data'"
21:16:36 <applicative> Neried, the hackage one is 12 days old, the last patch 11 days ago
21:16:54 <applicative> 12 days is an eternity on hackage
21:16:59 <ski> "(like `data' is in Haskell))"
21:17:48 <Nereid> well how come the github one says version 0.3.0.0
21:18:58 <Nereid> or maybe he uploaded 0.4.0.0 right after that last commit but forgot to push the change to the .cabal or something
21:20:13 <edwardk> probably
21:20:51 <edwardk> i've got an open issue with him on the fact that aeson-lens has a lot of illegal lenses in it, and he pushed back asking me to come up with ones that don't break the laws and i admit i haven't had bandwidth
21:21:24 <Nereid> mhm
21:25:16 <applicative> meromorph: did you try parTraversable on this structure. It sounded like you were  using parListxyz to the result of  toList $ fmap f my_big_traversable
21:26:48 <applicative> edwardk: he doesnt understand that as a member of the Lens Army, the lens laws are a matter of martial law
21:26:57 <edwardk> yes
21:27:08 <meromorph> applicative: I'll try to give it a go, thanks
21:27:25 <edwardk> :t Control.Parallel.Strategies.Lens.parOf
21:27:27 <lambdabot> SimpleLensLike Eval s a -> Strategy a -> Strategy s
21:32:26 <elliott> edwardk: not that lens is above violating a few laws itself :P
21:32:51 <simpson> If only the laws could be encoded in types.
21:32:56 <edwardk> elliott: which lens, the traversal for eval?
21:33:06 <sclv> the lens army serves a higher law
21:33:18 <elliott> I was thinking the filtery one with the overly-general type
21:33:20 <shachaf> @arrmy
21:33:21 <lambdabot> I'll crush ye barnacles!
21:33:31 <shachaf> There are lots of invalid lenses
21:33:33 <shachaf> Like partsOf
21:33:33 <elliott> traversal for eval sounds a bit evil though
21:33:48 <edwardk> Said with my best Sylvester Stallone impression: "I AM THE (lens) LAW!"
21:34:13 <edwardk> parOf traverse = parTraversal -- that Eval is just another Applicative
21:34:19 <elliott> wow, this "field" combinator is something else entirely
21:34:24 <edwardk> elliott: =)
21:34:34 <elliott> terrifying
21:34:44 <sclv> i'm glad it still shocks after all these years
21:34:44 <hpaste> cl1 pasted “find inner function types” at http://hpaste.org/78107
21:34:45 <edwardk> i'm trying to get field fst and field snd to work now
21:35:02 <elliott> should put this in some .Unsafe module
21:35:04 <edwardk> i resisted the temptation to call the operator __
21:35:08 <cl1> how do I find the type of gen_size in that hpaste?
21:35:11 <ion> field combinator?
21:35:15 <sclv> its perfectly safe!
21:35:19 <ion> @hoogle field
21:35:19 <lambdabot> Language.Haskell.TH.Syntax type FieldExp = (Name, Exp)
21:35:20 <lambdabot> Language.Haskell.TH type FieldExp = (Name, Exp)
21:35:20 <lambdabot> Language.Haskell.TH.Lib fieldExp :: Name -> ExpQ -> Q (Name, Exp)
21:35:28 <sclv> all it uses are imprecise exceptions, unsafeCoerce, and unsafePerformIO
21:35:30 <sclv> and Data
21:35:42 <edwardk> ion: https://github.com/ekmett/lens/commit/ea3791b7cc498f6dee483d4c98c53b90e404990e#L2R751
21:35:46 <elliott> ion: field :: forall a b. Data a => (a -> b) -> Simple Lens a b
21:36:02 <elliott> edwardk: what happens if you do e.g. field (\_ -> 42)
21:36:12 <ski> cl1 : how is `Dir' defined ?
21:36:18 <edwardk> given data Foo = Foo { fooBar :: Int } deriving (Data,Typeable) you can use field fooBar .~ 20 $ Foo 10
21:36:33 <ion> hah
21:36:38 <edwardk> elliott: the accessor to read from it works, and writing to it gives you back undefined
21:36:39 <sclv> elliott: error "field: not a field"
21:36:49 <elliott> edwardk: :(
21:36:50 <hpaste> cl1 annotated “find inner function types” with “find inner function types (annotation)” at http://hpaste.org/78107#a78108
21:36:56 <elliott> how long until you regret adding this and rip it out
21:37:13 <cl1> ski: data Dir = Dir {dir_size::Int, dir_name::String} deriving Show
21:37:16 <sclv> edwardk: arguably it should just not update anything instead of erroring out in that cse
21:37:17 <edwardk> it has some nice big caveats about what you are allowed to use it with
21:37:30 <elliott> also I bet you can make this work with strict fields
21:37:31 <elliott> but
21:37:32 <ski> cl1 : so i think `gen_size :: Gen Int' then
21:37:34 <edwardk> sclv: hrmm i might be able to do that
21:37:35 <elliott> I don't want to help make that possible
21:37:47 <elliott> sclv: isn't const an invalid lens, though?
21:37:53 <elliott> if it is going to violate the laws, might as well do it noisily
21:38:02 <cl1> ski: i know that, how can i use :t in ghci to print it?
21:38:06 <sclv> true enough
21:38:08 <edwardk> elliott: better to violate the lens laws that crash when you do something that stupid ;)
21:38:27 <edwardk> well, maybe not
21:38:28 <Nereid> what
21:38:31 <sclv> i'm not thinking of const as a lens though -- just as an "index" into a structure
21:38:31 <Nereid> how does field work
21:38:31 <Nereid> what
21:38:32 <edwardk> not sure on the right behavior
21:38:33 <elliott> edwardk: if it crashes you know you made a mistake
21:38:38 <elliott> rather than just silent law-breakage
21:38:38 <sclv> in which case the inverse is naturally a no-op
21:38:44 <mgsloan> hahahaha, that's a hilarious implementation
21:38:46 <sclv> depends how you approach it
21:38:57 <elliott> sclv: right but this kind of thing violates the lens laws
21:38:58 <edwardk> right now it yells at you to fix your code, which is pretty sane
21:39:01 <elliott> because you can put something in and then can't read it back
21:39:07 <sclv> yeah, noisy makes sense here.
21:39:08 <edwardk> but i could see the illegal-lens version too
21:39:23 <elliott> evilField
21:39:49 <edwardk> with partsOf we go out of our way to avoid failing though, in a similar way, so i could definitely make the case for graceful degradation
21:40:10 <sclv> it also of course only works on simple accessors, so field (\x -> fooBar x * 2) also is no good
21:40:11 <elliott> :t partsOf
21:40:13 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
21:40:21 <elliott> i think this is another lens I hate
21:40:36 <edwardk> without partsOf most of Plated wouldn't be implementable internally
21:40:36 <mgsloan> is GHC sufficiently smart to inline usages of "field" with a compiletime evaluated "ix"?  Methinks not due to the potential for unsafePerformIO in Data instances (along with the difficulty of actually making an optimizer that aggressive)
21:40:39 <elliott> the function has to preserve length, right?
21:40:47 <shachaf> elliott: If you think you hate partsOf, just wait until you see the new version.
21:40:48 <sclv> field is a dirty hack that's handy for getting started with.
21:40:51 <edwardk> with plated if you don't preserve length you violate laws
21:41:00 <edwardk> er with partsOf
21:41:09 <sclv> even if its perfectly stable, the performance won't be great for production code
21:41:21 <shachaf> edwardk: Is there an easy way to say over (partsOf l) reverse without partsOf?
21:41:24 <elliott> edwardk: well, you could have it be ((Nat -> a) -> f (Nat -> a)), right? :)
21:41:25 <edwardk> unsafePartsOf will upgrade that to not only violate laws, but crash, but gives you a more liberal type in exchange
21:41:34 <elliott> oh it's actually Vec n a
21:41:37 <edwardk> shachaf: not really
21:41:45 <elliott> so you want like
21:41:54 <elliott> (forall i. (SomeTypeclass i) => (i -> a) -> f (i -> a))
21:41:58 <ski> cl1 : though i suppose you could get the general `gen_size :: (Random a,Num a) => Gen a' as answer then -- not sure if you're satisfied, or wanted something more
21:42:18 <edwardk> elliott: yeah ideally it would just require you to give the mapping for (forall n. Vec n a -> f (Vec n a))
21:42:21 <edwardk> but that breaks the lens shape
21:42:24 <applicative> cl1 you can't print it readily. I recommend adding a wrong type signature to 'where gen_size =' and seeing what the complaint is
21:42:32 <elliott> edwardk: hrm, right
21:42:43 <ski> cl1 : oops, forgot : i think you could move `gen_size' outside of the `instance'
21:42:47 <elliott> edwardk: so what you need is more type parameters!
21:43:05 <shachaf> s t a b elliott
21:43:05 <elliott> edwardk: well, partsOf wouldn't really suffer from the extra quantifier, right?
21:43:09 <elliott> it'd still compose properly and stuff
21:43:18 <elliott> I guess you wouldn't be able to pass partsOf as arguments to stuff
21:43:22 <edwardk> no, they don't compose well when you make them higher rank
21:43:29 <Nereid> this field thing
21:43:29 <Nereid> ...
21:43:30 <elliott> mm
21:43:30 <edwardk> i tried for other lenses
21:43:41 * hackagebot edge 0.8.12.1 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.12.1 (ChristopherHoward)
21:43:52 <edwardk> Nereid: its only a little evil. ;)
21:43:55 <elliott> ok so what if you moved the quantifier up
21:44:13 <shachaf> How can you do that?
21:44:18 <edwardk> elliott: you can't
21:44:19 <shachaf> You don't know n
21:44:23 <elliott> (FinVec v) => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> Lens v v s t
21:44:26 <elliott> oh right
21:44:28 <elliott> duh :)
21:44:32 <ion> Finnish Vector
21:44:39 <elliott> there must be *something* you can do :(
21:44:46 <applicative> cl1: somewhere there was a brilliant scheme of using the debugger
21:44:54 <edwardk> yeah, you can make it a list, degrade gracefully on error, and move on ;)
21:45:12 <elliott> edwardk: sure, that works! just like PHP
21:45:14 <elliott> :(
21:45:18 <applicative> oh my god I finally too a look at this 'field' function
21:45:21 <applicative> took
21:45:31 <shachaf> elliott: Bazaar a b t itself is ~ (exists n. (Vec n a, Vec n b -> t))
21:45:46 <shachaf> So just write whatever function you want to deal with a Bazaar
21:46:09 <elliott> mmmmmm
21:46:21 <shachaf> EvilBazaar a b t is ~ to, uh, what?
21:46:21 <elliott> but that makes things inconvenient :(
21:46:23 <cl1> applicative: haven't gotten to using the debugger part of my tutorial yet
21:46:34 <shachaf> What would BazaarT a b g t be?
21:46:49 <cl1> the tutorial recommeded i try to figure out how to print the type as a challenge
21:46:49 <ion> BazaarT l g b t
21:46:59 <applicative> cl1: I'll find it somewhere,  it wouldn't be practical in this case.
21:47:01 <edwardk> ion: =)
21:47:59 <applicative> no sooner does Control.Lens.Type.field appear than S. Marlow leaves for Facebook.  ...
21:48:18 <edwardk> applicative: coincidence? i think not
21:48:44 <applicative> exactly. why not php after that?
21:48:57 <ion> Why not Zoidberg?
21:49:08 <sclv> error "field: not a field"
21:49:09 <elliott> at least edwardk had to make his local variables uglier as punishment
21:49:15 <sclv> er, rather: http://www.youtube.com/watch?v=dsx2vdn7gpY
21:49:19 <elliott> edwardk: btw, I hope you don't get field just by importing Control.Lens
21:49:21 <elliott> that would be an awful name clash
21:49:37 <ion> btw, I hope you don’t get field
21:49:42 <shachaf> Maybe field should be called "lense"!
21:49:42 * edwardk whistles innocently
21:49:56 <ion> shachaf: e for evil?
21:49:57 <edwardk> shachaf: thats currently the combinator for lenq in the branch
21:49:57 <shachaf> mgsloan can come up with another name.
21:50:50 <mgsloan> true, like "l"
21:50:51 <ion> > unwords . map (("len"++) . pure) $ ['a'..'z']
21:50:53 <lambdabot>   "lena lenb lenc lend lene lenf leng lenh leni lenj lenk lenl lenm lenn leno...
21:50:54 <mgsloan> ;)
21:51:03 <shachaf> > l
21:51:06 <lambdabot>   l
21:51:16 <mgsloan> > l ^ 2
21:51:18 <lambdabot>   l * l
21:51:40 <Nereid> > l^7
21:51:42 <lambdabot>   l * l * (l * l) * (l * l * l)
21:52:06 <elliott> edwardk: how about rename it to something unicode
21:52:08 <elliott> so nobody can type it
21:52:50 <ion> ⽥ U+2F65 KANGXI RADICAL FIELD
21:52:53 <shachaf> λενσ
21:54:01 <ion> Does “field” have any benefit over Control.Lens.TH?
21:54:16 <shachaf> You can use it for types you didn't write.
21:54:22 <shachaf> Hmm, maybe you can do that anyway.
21:54:33 <elliott> ion: it's slower!
21:54:36 <elliott> and less reliable
21:54:37 <shachaf> You can use it without TH.
21:54:40 <shachaf> That's a benefit.
21:54:46 <ion> shachaf: …if they happened to derive Typeable and Data?
21:54:56 <edwardk> ion: using makeLenses can take a long time on load. field is a lot slower at runtime, but you can use it without TH
21:55:20 <shachaf> It's a pity makeLenses takes such a long time.
21:55:41 <edwardk> i'm trying not to be too prescriptivist about style with lens, so i'm including it because a.) its a very neat trick, b.) someone might find it useful, c.) it'd be a lot of work for someone to rederive independently
21:56:14 <edwardk> i'm patching it right now so it works properly with fst, snd, etc.
21:56:37 <elliott> if someone uses this thing in a tutorial edwardk will have some explaining to o
21:56:38 <elliott> do
21:58:01 <shachaf> "field" *is* a bit of a common name to take ove.
21:58:07 <shachaf> It's not in the lens tradition at all!
21:58:10 <shachaf> fielded?
21:58:18 <startling> elliott: <interactive>:2:1: Empty 'do' block
21:58:19 <ion> unsafeField
21:58:25 <startling> felt
21:58:31 <applicative> I like this field thing; now I don't need any underscores
21:58:33 <shachaf> startling: He's not finished typing!
21:58:36 <shachaf> What kind of ghci are you?
21:58:36 <mgsloan> unsafeFeels
21:58:45 <shachaf> _field?
21:58:45 <elliott> shachaf: well you don't get it just from importing Control.Lens do you
21:58:54 <shachaf> You don't?
21:58:55 <edwardk> @hoogle field
21:58:56 <lambdabot> Language.Haskell.TH.Syntax type FieldExp = (Name, Exp)
21:58:56 <lambdabot> Language.Haskell.TH type FieldExp = (Name, Exp)
21:58:56 <lambdabot> Language.Haskell.TH.Lib fieldExp :: Name -> ExpQ -> Q (Name, Exp)
21:58:56 <mgsloan> I like "unsafeField" or "evilField"
21:59:02 <elliott> well
21:59:03 <edwardk> find me one named field
21:59:04 <startling> what's this thing do?
21:59:04 <elliott> edwardk: do you?
21:59:12 <shachaf> elliott: Given that it's defined in .Type, I imagine you do.
21:59:15 <elliott> i use field as a local variable all the time
21:59:19 <ion> Bring the one named field to me
21:59:22 <mgsloan> "fieldLens" ?
21:59:26 <edwardk> ion: hhahaha
21:59:53 <edwardk> mgsloan: i have avoided randomly mangling the combinators in lens with fooLens up until now im not going to recant on that for this one =P
22:00:06 <edwardk> i took _1 rather than fstLens, recall =P
22:00:17 <ion> That was evil, too. ;-)
22:00:23 <elliott> well if this thing really does give you a field binding by default then that is upsetting :(
22:00:24 <edwardk> ion: and it has worked out very well
22:00:30 <mgsloan> edwardk: fair'nough :)
22:00:46 <shachaf> edwardk: Now everyone says that the primary benefit of lens over Prelude is that it gives you a size-polymorphic fst!
22:01:03 <edwardk> heh, its a good newbie sell at least ;)
22:01:07 <ion> edwardk: Since you include field, how about including my _unsafePerformIO and spoon lenses, too? They’re about the same level of evilness. ;-)
22:01:20 <edwardk> ooh, _unsafePerformIO
22:01:21 <edwardk> =)
22:01:28 <elliott> _unsafePerformIO :: Simple Lens (IO a) a?
22:01:36 <applicative> Judas acquired a field with the reward of his unjust deed, and falling headfirst he burst open in the middle and all his intestines gushed out. This became known to all who lived in Jerusalem, so that in their own language they called that field Hakeldama, that is, “Field of Blood."
22:01:37 <shachaf> When are we going to have both :: Both s t a b => Traversal s t a b?
22:01:43 <edwardk> Iso (IO a) (IO b) a b
22:01:46 <ion> _unsafePerformIO :: Simple Iso (IO a) a; _unsafePerformIO = iso unsafePerformIO pure
22:01:59 <elliott> that's not an isomorphism at all :(
22:02:01 <edwardk> shachaf: when and if it infers properly
22:02:05 <ion> spoon :: Exception e => Simple Iso a (Either e a); spoon = iso (unsafePerformIO . try . evaluate) (unsafePerformIO . either throwIO pure); spoon' :: Simple Iso a (Either SomeException a); spoon' = spoon
22:02:16 <elliott> shachaf: what would that even mean
22:02:16 <edwardk> shachaf: my attempts at good inference for it have failed
22:02:22 <elliott> oh hm
22:02:25 <shachaf> elliott: All the fields of a tuple.
22:02:26 <Nereid> haha
22:02:28 <meromorph> so parTraversable didn't solve my problem, I'm still getting parallel usage that looks like this: http://i.imgur.com/WI9iS.png http://i.imgur.com/yLPCL.png any ideas?
22:03:30 <elliott> shachaf: how about generalise it further to "uniform"
22:03:33 <elliott> so you can use it for [a] too!
22:03:50 <elliott> and (Vec n a)
22:05:11 <shachaf> elliott: instance Both [a] [b] a b
22:05:25 <Nereid> > fix (over both show)
22:05:27 <lambdabot>   ("\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\...
22:05:45 <elliott> shachaf: okay but then both is a terrible name anyway
22:05:57 <shachaf> Yep.
22:06:03 <copumpkin> > fix show
22:06:04 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:06:06 <Nereid> hello?
22:06:28 <copumpkin> hello!
22:06:36 <Nereid> oh, I was lagging or something.
22:07:19 <Nereid> > fix (show . diag)
22:07:21 <lambdabot>   Not in scope: `diag'
22:07:22 <Adeon\SIGSEGV> excessive amount of backslashes are interfering with our communication protocols
22:07:27 <Nereid> > fix (show . (id &&& id))
22:07:30 <lambdabot>   "(\"(\\\"(\\\\\\\"(\\\\\\\\\\\\\\\"(\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"(\\\\\\...
22:07:46 <Nereid> > fix (show . Left)
22:07:47 <applicative> > show ^% fix
22:07:48 <lambdabot>   "Left \"Left \\\"Left \\\\\\\"Left \\\\\\\\\\\\\\\"Left \\\\\\\\\\\\\\\\\\\...
22:07:49 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:08:05 <ion> @type (^%)
22:08:06 <lambdabot> a -> (a -> b) -> b
22:08:12 <Nereid> > fix (Left . show)
22:08:15 <lambdabot>   Left "Left \"Left \\\"Left \\\\\\\"Left \\\\\\\\\\\\\\\"Left \\\\\\\\\\\\\\...
22:08:48 <copumpkin> > map length . filter ((/= '"') . head) . group $ fix show
22:08:52 <lambdabot>   mueval-core: Time limit exceeded
22:08:57 <copumpkin> > take 10 . map length . filter ((/= '"') . head) . group $ fix show
22:09:00 <edwardk> elliott: i'm not planning on generalizing both at this time and keeping the name
22:09:00 <lambdabot>   [1,3,7,15,31,63,127,255,511,1023]
22:10:11 <ion> > fix (show . Left . map Right)
22:10:13 <lambdabot>   "Left [Right 'L',Right 'e',Right 'f',Right 't',Right ' ',Right '[',Right 'R...
22:10:16 <copumpkin> @let thrice f = f . f . f
22:10:17 <Nereid> :V
22:10:21 <lambdabot>  Defined.
22:10:28 <copumpkin> > thrice thrice (+1) 0
22:10:31 <lambdabot>   27
22:10:37 <copumpkin> > (thrice . thrice) (+1) 0
22:10:40 <lambdabot>   9
22:10:45 <copumpkin> > thrice thrice thrice (+1) 0
22:10:48 <lambdabot>   *Exception: stack overflow
22:10:52 <Nereid> eh
22:10:59 <Nereid> oh
22:11:12 <Nereid> 3^3^3 is big.
22:11:17 <copumpkin> > thrice (thrice thrice) (+1) 0
22:11:19 <lambdabot>   19683
22:11:32 <copumpkin> > thrice (thrice . thrice) (+1) 0
22:11:35 <lambdabot>   729
22:11:49 <Nereid> > fix thrice (+1) 0
22:11:55 <lambdabot>   mueval: ExitFailure 1
22:11:55 <lambdabot>  mueval: Prelude.undefined
22:11:59 <Nereid> =(
22:12:00 <copumpkin> o.O
22:12:03 <ion> ♪ THRICE
22:12:14 <copumpkin> > (thrice . thrice) thrice (+1) 0
22:12:17 <Nereid> > fix thrice (const 1)
22:12:19 <lambdabot>   mueval-core: Time limit exceeded
22:12:22 <lambdabot>   mueval-core: Time limit exceeded
22:12:37 <Nereid> > thrice thrice thrice (const 1)
22:12:39 <lambdabot>   *Exception: show: No overloading for function
22:12:45 <shachaf> What's the earliest version of GHC that lens is supposed to work on?
22:12:46 <Nereid> > thrice thrice thrice (const 1) 0
22:12:49 <lambdabot>   1
22:12:53 <Nereid> > fix thrice (const 1) 0
22:12:55 <edwardk> it used to be 7.2, it may be 7.4 now
22:12:55 <copumpkin> \o/
22:13:04 <lambdabot>   mueval: ExitFailure 1
22:13:04 <lambdabot>  mueval: Prelude.undefined
22:13:06 <ion> shachaf: The one edwardk runs at any given time.
22:13:23 <edwardk> ok, field fst .~ 1 $ (0,0)   works now
22:13:26 <shachaf> ion: Hey, it has to work on the one travis-ci runs too!
22:13:30 <Nereid> edwardk: disgusting
22:13:31 <shachaf> And the one I run.
22:13:49 <johnw> edwardk: is "field" new?
22:13:55 <edwardk> Nereid: just be glad i haven't written custom setter syntax for them ;)
22:14:06 <Nereid> lol
22:14:16 <edwardk> fst !@#(~ 1 $ (0,0)  =P
22:14:20 <ion> john: It is not new. It has awaited in a slumber on the bottom of a sea for millenia. It was only summoned recently.
22:14:20 <Nereid> @let magic = set . field
22:14:24 <lambdabot>  <local>:14:15: Not in scope: `field'
22:14:29 <Nereid> oh duh
22:14:30 <edwardk> johnw: its new in HEAD
22:14:35 <copumpkin> edwardk: wow
22:14:38 <johnw> ion: are the argonauts in trouble?
22:14:39 <shachaf> edwardk: That wouldn't be composable.
22:14:47 <edwardk> shachaf: thats why it doesn't exist ;)
22:15:03 <johnw> so what is field, turning any accessor functions automatically into a Lens?
22:15:07 <Nereid> yes :(
22:15:09 <edwardk> johnw: yep
22:15:12 <johnw> does it perform?
22:15:19 <edwardk> its slow, but it'll work
22:15:20 <Nereid> unsafely, yes
22:15:25 <johnw> huh
22:15:34 <elliott> FSVO "any", "automatically"
22:15:38 <elliott> "accessor", "functions", "Lens"
22:15:41 <elliott> "a", "into"...
22:15:42 <Nereid> johnw: it uses unsafePerformIO
22:15:49 <johnw> so, _1 = field fst, eh?
22:15:50 <Nereid> :(
22:15:59 <johnw> elliott: lol
22:15:59 <Nereid> yes but faster.
22:16:02 <copumpkin> that's terrifying
22:16:04 <elliott> edwardk: does field head work
22:16:15 <edwardk> johnw: morally. of course _1 is smarter, and can be used to change types, etc.
22:16:20 <edwardk> elliott: checking
22:16:29 <startling> how in the world does that work?
22:16:32 <johnw> edwardk: I can see field being handy if you really need it
22:16:39 <copumpkin> startling: don't do it
22:16:45 <copumpkin> startling: your eyes will turn black, and will fall out
22:16:49 <edwardk> >>> field head .~ 'j' $ "hello"
22:16:49 <edwardk> "jello"
22:16:56 * copumpkin hangs head in shame
22:16:57 <Nereid> and field tail?
22:16:58 <elliott> edwardk: i think i will cry
22:17:04 <elliott> edwardk: what is [] ^. field head
22:17:06 <edwardk> field tail fails because it would be recursive
22:17:11 * ion is both horrified and amazed
22:17:12 <Nereid> this is the most disgusting thing I have heard in #haskell all month.
22:17:18 <Nereid> edwardk: how so?
22:17:20 <copumpkin> edwardk: fails how? and what about field head on an empty list?
22:17:26 <edwardk> >>> ""^.field head
22:17:27 <edwardk> *** Exception: Prelude.head: empty list
22:17:34 <mgsloan> yeah, if haskell had a brilliantly awful code competition, this'd take the cake
22:17:35 <elliott> right I guess I should have anticipated that
22:17:39 <elliott> edwardk: what about
22:17:39 <applicative> > head ""
22:17:43 <lambdabot>   mueval-core: Time limit exceeded
22:17:45 <elliott> field head .~ 'q' $ ""
22:17:48 <mgsloan> I'd think that tail would work - the thing that wouldn't work would be "last"
22:17:49 <mgsloan> etc
22:17:52 <startling> edwardk, now just write a template haskell thing that generates every possible lens
22:17:52 <edwardk> you gave me an accessor that crashed, so of course i crash =P
22:17:59 <copumpkin> wouldn't field tail act like append?
22:18:03 <mgsloan> startling: working on it ;)
22:18:06 <copumpkin> when setting
22:18:09 <Nereid> edwardk: did you try it?
22:18:13 <edwardk> elliott: >>> "" & field head .~ 'j'    ==> "*** Exception: Prelude.head: empty list
22:18:20 <elliott> right
22:18:26 <Nereid> I mean field tail
22:18:37 <johnw> field (! "sup") +~ 1 $ fromList [("sup", 0)]
22:18:38 <edwardk> field tail will work
22:18:46 <edwardk> field last and field init will fail
22:18:47 <edwardk> sorry
22:18:52 <meromorph> the only thing I could think of doing was making sure the traversable data structure was fully evaluated before fmapping, but that made no difference
22:19:13 <elliott> edwardk: what about field ($ ())
22:19:15 <elliott> oh I guess it lacks the instances
22:19:16 <johnw> edwardk: could you do term rewriting so that things like "field fst" are caught and transformed into _1?
22:19:30 <Nereid> more disgusting
22:19:32 <elliott> johnw: don't give him any more terrible ideas!!!
22:19:37 <elliott> he finds enough on his own apparently
22:19:39 <edwardk> johnw: you probably could but thats a lot of rewrite rules ;)
22:19:42 <edwardk> elliott: hahahaha
22:20:00 <johnw> it's just easier to remember field X in the heat of battle than every lens variant of all the basic accessors...
22:20:09 <mgsloan> need to up the ante and make this work on recursive structures
22:20:30 <elliott> johnw: this comabintor will be awfully slow at runtime and stuff though :(
22:20:30 <edwardk> mgsloan: i've thought about it. i think i can
22:20:48 <johnw> elliott: yeah, that's why I ask for a rewriter; otherwise, I don't see why I'd use them
22:20:51 <sclv> should work on heterogeneous nested ones too
22:20:53 <ion> A thought: instead of requiring .TH fields to begin with _, keep the normal names and add rewrite rules to replace the accessors with lenses.
22:20:53 <elliott> this thing really needs a more evil name than just "field" :P
22:21:05 <edwardk> mgsloan: the slowdown would be O(n^2) for a list though
22:21:10 <mauke> what is this sorcery
22:21:10 <johnw> ion: now you're thinking!
22:21:15 <mgsloan> edwardk: You should make it so we have a good thing to name "evilField"
22:21:24 <johnw> ion: except, could you still use them for pattern matching?
22:21:36 <ion> johnw: I’d assume so.
22:21:44 <johnw> man, that would be pretty sweet
22:21:47 <sclv> i'm so happy with the outcry. when i first posted this trick in '08 it was met with stony silence
22:21:49 <ion> That would be pretty evil.
22:21:51 <elliott> evilField :: (a -> b) -> SimpleLens a b
22:21:52 <johnw> record accessor lenses only when you needed them
22:21:53 <mgsloan> edwardk: yeah, and it could also loop forever
22:21:54 <elliott> no constraints
22:22:02 <elliott> it looks at your accessor's compiled code
22:22:10 <Nereid> lol
22:22:11 <edwardk> mgsloan: i suppose, given an infinite list it would, yeah
22:22:15 <elliott> and writes a setter for it
22:22:28 <edwardk> mgsloan: a 'deepField' combinator could work though
22:22:35 <edwardk> something separate that recursively searched
22:22:50 <shachaf> Does SafeHaskell let you write your own Typeable instances?
22:22:53 <shachaf> Er, Data.
22:22:58 <edwardk> shachaf: no
22:23:00 <shachaf> I know it forbids Typeable.
22:23:03 <elliott> evilField :: SimpleLens a b  -- brute-forces lenses until it finds one that satisfies the laws
22:23:04 <shachaf> OK.
22:23:17 <edwardk> oh, well with data i think the answer is yes
22:23:21 <elliott> evilField2 :: SimpleLens a b  -- the same as evilField but goes for the second one it finds that satisfies the laws
22:23:45 <ion> Generate evilField{N} with Template Haskell. No, wait! We need method_missing.
22:24:09 <elliott> evilField :: Integer -> SimpleLEns a b
22:24:25 <copumpkin> Ptr a ->
22:24:31 <elliott> evillerField :: integer -> SimpleLens a b  -- supports any type with any number of elements
22:24:37 <edwardk> happy thanksgiving ;)
22:24:38 <elliott> e.g. evillerField "", evillerField "\000"
22:24:53 <copumpkin> elliott: he's calling you a turkey
22:25:00 <sclv> haha yes can we make a lens for pointers?
22:25:25 <elliott> sclv: you already can, safely, I think!
22:25:40 <elliott> Action IO (Ptr a) a
22:25:47 <sclv> nice
22:25:52 <elliott> that's only one-way though. edwardk: is there a way to have a setter there too?
22:26:10 <elliott> :t act peek
22:26:12 <lambdabot> Not in scope: `peek'
22:26:15 <elliott> pah
22:26:18 <edwardk> elliott: sadly no. i've not been able to concoct a form of 'MonadicLens' that permits reading and writing in a principled way
22:26:21 <elliott> :t act putStrLn
22:26:23 <lambdabot> Control.Lens.Internal.Effective IO r f => (() -> f ()) -> String -> f String
22:26:30 <sclv> @hoogle peek
22:26:31 <lambdabot> Foreign.Storable peek :: Storable a => Ptr a -> IO a
22:26:32 <lambdabot> Foreign.Marshal.Array peekArray :: Storable a => Int -> Ptr a -> IO [a]
22:26:32 <lambdabot> Foreign.Marshal.Array peekArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO [a]
22:26:42 <sclv> :t act
22:26:43 <lambdabot> Control.Lens.Internal.Effective m r f => (s -> m a) -> (a -> f a) -> s -> f s
22:27:10 <sclv> ah, so no lens for MVars either then
22:27:15 <edwardk> act takes a Kleisli arrow and gives you a monadic action that can be composed wiht other actions, getters, folds, and lenses with (.) yielding a new action
22:27:20 <edwardk> (or monadic fold)
22:27:25 <shachaf> We're actors -- we're the opposite of people!
22:27:43 <edwardk> you can run an Action (or MonadicFold) with (^!)
22:27:50 <elliott> edwardk: i guess the problem with setting is that it isn't really setting
22:27:59 <elliott> becauase your return value is sort of meaningless
22:28:20 <edwardk> elliott: yeah. you wind up with some pretty funny laws, and you wind up doing a lot of unnecessary reading and writing back
22:28:21 <ion> Acting m a s t a b
22:28:24 <ion> Masta B sounds like a rapper name.
22:28:44 <edwardk> hahah Acting Masta B is bad ass
22:29:09 <elliott> well we know he's a master of acting
22:29:23 <shachaf> Not as much as Acting Masta A, presumably.
22:29:44 <shachaf> Or maybe he's even more of a master!
22:31:25 <edwardk> He's only the "Acting Masta" B, because Masta A is out sick this week.
22:31:48 <simpson> Heh.
22:32:13 <shachaf> Acting Masta B = Acting Undastudy A?
22:37:40 <edwardk> i wonder if a more principled version of field could be made that generates a traversal only
22:38:05 <edwardk> e.g. it returns the value iff the field accessor you give it is an accessor, and updates it accordingly
22:38:26 <edwardk> then the use of ^?! with that might cause elliott to be able to sleep at night
22:38:48 <shachaf> elliott has never slept at night.
22:39:28 <elliott> edwardk: import Control.Lens hiding (field, (^?!))
22:39:58 <edwardk> elliott: for you https://github.com/ekmett/lens/issues/119
22:40:12 <sopvop> Mom, there are lens under my bed.
22:40:36 <elliott> edwardk: what will happen if you use a strict accessor
22:40:43 <elliott> as in, accessor for a strict field
22:40:45 <edwardk> good question. test it ;)
22:40:53 <edwardk> i know for unboxed ones it should crap out
22:41:09 <johnw> sopvop: "If you look at them, while they're looking at you, they'll infinite recurse and go away"
22:41:23 <shachaf> The only thing keeping you from using field to unsafeCoerce is the fact that it's Simple, right?
22:41:26 <edwardk> johnw: nah, we fixed all the infinite recursion bugs ;)
22:41:30 * startling curses johnw.
22:41:35 * startling recurses johnw.
22:41:37 <edwardk> shachaf: yes
22:42:07 <elliott> shachaf: can you convince edwardk to get rid of field like you did (^!?)
22:42:24 <elliott> the world is counting on you!
22:42:29 <shachaf> elliott: I did it by opening a bug report.
22:43:00 <elliott> right
22:43:04 <elliott> worth a try??
22:43:57 <edwardk> elliott: with the Traversal you shouldn't have any objection to field.
22:44:35 <elliott> well I  guess it'll be theoretically okay
22:44:41 <elliott> but I bet you can still break it by passing in evil functions :P
22:44:51 <elliott> like, can it really avoid breakage with partial functions
22:45:11 <edwardk> if i don't go off on these little flights of fancy you don't get to use the neat toys i bring back =P
22:45:32 <edwardk> sometimes they can be a little unsettling as I go, though =P
22:45:50 <elliott> neat toys is edwardkese for lovecraftian horrors, right?
22:45:57 <edwardk> well, yes.
22:46:13 <simpson> I still don't grok traversals and actions in lens, but maybe I'm just not yet ready.
22:46:38 <edwardk> simpson: do you know how to use Data.Traversable?
22:46:45 <edwardk> e.g. traverse?
22:46:48 <johnw> simpson: a traversal is a "lens" that focuses on 0 or more items within a structure
22:46:55 * shachaf considers defining indexedGmapM
22:47:03 <simpson> edwardk: I don't get the point of traversals beyond Functors. I understand Foldable.
22:47:08 <elliott> > both .~ 42 $ (1,2)
22:47:10 <lambdabot>   (42,42)
22:47:18 <elliott> > traverse .~ 42 $ [1,2,3,4]
22:47:20 <lambdabot>   [42,42,42,42]
22:47:28 <edwardk> :t mapM putStrLn ["hello","world"]
22:47:28 <elliott> > iwhere (\i -> i `mod` 2 == 0) .~ 42 $ [1,2,3,4]
22:47:30 <lambdabot> IO [()]
22:47:31 <lambdabot>   [42,2,42,4]
22:47:31 <edwardk> :t mapM_ putStrLn ["hello","world"]
22:47:32 <elliott> (iwhere = index where)
22:47:34 <lambdabot> IO ()
22:47:36 <elliott> if you can understand that, you understand Traversal
22:47:47 <edwardk> traverse lets you have applicative or monadic side-effects to the action you pass each value
22:47:59 <edwardk> and it lets you repackage it back up in the same shape you started from
22:48:16 <edwardk> so if you mapM over a list with an action you get a new list, with each of the answers in it
22:48:56 <simpson> Huh. How is the order defined?
22:49:14 <edwardk> by convention we do things left to right through the fields of the constructors
22:49:23 <edwardk> so you pick field orders that make it behave the 'right' way
22:49:26 <simpson> What about depth?
22:49:26 <edwardk> same with foldable
22:49:31 <edwardk> you already have to pick an order
22:49:38 <edwardk> its the same order Foldable will visit
22:49:47 <simpson> Interesting.
22:50:00 <edwardk> its just like a Foldable you can repack up behind yourself with new contents.
22:50:32 <edwardk> Set is Foldable, but not Traversable, because it doesn't make sense to repack a set with new values of arbitrary unrestricted type in the places they came from.. you need the tree in sorted order
22:51:01 <simpson> Hm.
22:51:03 <edwardk> but Intmap a  is traversable, it happens to traverse the values in order, and you can put other values back in at the same keys you found them at
22:52:11 <edwardk> now, when you go to work with Traversable, you always go look for 'a' in 'f a' and given an action from 'a -> m b' you build up a new 'f b'  inside m.
22:52:15 <shachaf> Do you mind if I simplify field a bit to use indexedGmap?
22:52:25 <edwardk> shachaf: knock yourself out.
22:52:41 <edwardk> i was about to rewrite it to a traversal but hadn't started
22:52:58 <shachaf> Oh, maybe a traversal makes more sense here.
22:53:13 <shachaf> It's just a one-or-zero traversal, though, right?
22:53:23 <edwardk> i mean rewrite field itself to be one, not to rewrite the gmapM parts
22:53:23 <shachaf> Hmm, you could do better than that.
22:53:30 <shachaf> Right.
22:54:16 <edwardk> why not push the indexedGmap cleanup, and i'll do that after
22:54:37 <edwardk> its a bit tricky because you can't just use the user supplied function directly any more as the getter side of things
22:54:44 <edwardk> you have to go make sure its a field accessor first
22:54:49 <edwardk> which makes for another gmap
22:55:58 <shachaf> Maybe there's no point to the change I'm making now, then.
22:56:21 <shachaf> Oh well.
22:57:45 <shachaf> Wait, does lens use two-space indentation?
22:57:50 <edwardk> yes
22:57:58 <shachaf> Somehow I thought it was 4-space.
22:58:11 <edwardk> noticing i keep respacing your patches?
22:58:18 <shachaf> You are?
22:58:22 <shachaf> I didn't notice that either.
22:58:25 <Nereid> lol
22:58:29 <shachaf> Sorry. :-(
22:58:33 <edwardk> sok
22:59:23 <edwardk> i go out of my way to keep the coding style consistent about 2 space indentation and things like not using prophylactic parentheses at all even around (Foo a) => .. but its just a nervous twitch not something i think hard about =P
22:59:35 <edwardk> its something my fingers do while i think other thoughts
22:59:53 <shachaf> Funny, I tend to do the same thing with four spaces.
23:00:19 <edwardk> i switched to 2 for haskell because stuff was getting way intended in my cps'd code
23:00:42 <elliott> omitting the ()s around contexts feels weird
23:00:44 * shachaf wonders whether that's a message from the universe about CPS...
23:01:04 <elliott> edwardk: you know, I hear Haskell has this nice abstraction to represent CPS called a monad
23:01:12 <elliott> and even some nice syntactic sugar to avoid deep nesting when using them!
23:01:24 <edwardk> =)
23:01:33 <edwardk> it doesn't help so much when you are defining the monad
23:01:51 <Cale> It's so much better when CPS is unintentional
23:02:05 <edwardk> and it can make a factor of 4 speed difference so i tend to roll it out by hand
23:02:10 <shachaf> Cale: You'll be happy to hear that I got rid of the evil unsafeCoerce in lens.
23:02:16 <shachaf> But as soon as I did that edwardk added another one.
23:02:22 <Cale> lol
23:02:25 <edwardk> it helped me get a lot more comfortable with the types and thinking in negative position
23:02:26 <shachaf> Conservation of evil and all.
23:02:39 <edwardk> field is awesome!
23:03:00 <edwardk> indexedGmap in?
23:03:07 <shachaf> I'll push in a moment.
23:03:12 <edwardk> kk
23:04:24 <jamy23> Hello! How i can understand functors? This is like object or function or so on?
23:04:35 <mauke> no
23:04:56 <mauke> functors are like containers
23:05:09 <edwardk> containers made out of burritos
23:05:10 <mauke> basic example: lists
23:05:21 <mauke> [] is a functor
23:05:31 <ion> Some functors are like containers
23:05:39 <johnw> a burrito is like a monad
23:05:41 <copumpkin> jamy23: you seem to be using the C++ definition of functor, maybe?
23:05:41 <edwardk> ion: its a useful starting intuition
23:05:56 <shachaf> Let me just run the tests.
23:05:59 <edwardk> kk
23:06:12 <shachaf> Functors are covariant, is what mauke means to say.
23:06:30 <copumpkin> do you really think that'll help jamy23?
23:06:36 <ion> Obviously
23:06:46 <jamy23> I dont understand what is covariant to
23:06:48 <simpson> edwardk: How is it that when *you* say "burrito" you get ignored, and when I say "burrito" the mods warn me?
23:06:57 <edwardk> notice that the actual helpful comment stream has been drowned out by snark
23:07:09 <shachaf> True.
23:07:43 <copumpkin> jamy23: I wouldn't worry too much about variance, unless you actively want to know about variance
23:07:46 <edwardk> simpson: because life is unfair. i was being a bit of a dick. i apologize
23:07:54 <mauke> well, it's jamy23's turn again
23:08:30 <shachaf> Pushed.
23:08:33 <jamy23> What difference of monad and functors?
23:08:53 <elliott> a monad is a functor that supports some extra operations
23:09:23 <jamy23> "some extra operations" - side effects?
23:09:28 <ion> jamy23: Functor is something for which a map operation is defined. Are you familiar with a map operation on lists?
23:09:35 <elliott> not... really, no
23:09:38 <elliott> how much Haskell do you know?
23:09:45 <edwardk> shachaf: i like
23:09:48 <elliott> it's probably pointless trying to explain these things if it's below a certain amount
23:09:55 <copumpkin> jamy23: monads have a notion of "do X, then do Y", which functors don't
23:10:06 <copumpkin> jamy23: I wouldn't talk about side effects
23:10:30 <ion> copumpkin: Applicative functors have that; monads also have “do X, then choose what to do based on its result”. Very roughly.
23:10:37 <mauke> monads have return and join
23:10:43 <copumpkin> ion: you think I don't know that? :P
23:10:45 <copumpkin> seriously
23:10:53 <ion> copumpkin: I don’t think you don’t know that.
23:10:58 <copumpkin> do you think he needs to know that?
23:11:13 * copumpkin shrugs
23:11:22 <copumpkin> anyway, have fun y'all
23:11:36 <jamy23> So functors its like a collections in imperative?
23:11:37 <elliott> @where typeclassopedia
23:11:38 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
23:11:51 <elliott> jamy23: http://www.haskell.org/haskellwiki/Typeclassopedia will explain functors and monads far better than #haskell can, really
23:12:18 <elliott> you need to know haskell already to some degree to understand it, but most likely you wouldn't be able to understand the concepts very well without that knowledge anyway
23:12:33 <elliott> since the concepts do not really map directly to typical imperative langauges
23:13:16 <edwardk> jamy23: a functor is like a polymorphic collection where you can change out the type of the contents with an operation we call fmap. so if you give me a function from a -> b, i can take a container full of a's and give you a container full of b's.
23:14:07 <ion> > fmap length ["foobar", "baz", "quux"]
23:14:07 <edwardk> jamy23: it doesn't give you any way to index into it, or update individual 'a's or look at the individual 'a's, just the ability to sweepingly replace all 'a's with 'b's by running each one through a supplied function.
23:14:08 <lambdabot>   [6,3,4]
23:14:17 <ion> > fmap length (Just "foo")
23:14:19 <lambdabot>   Just 3
23:14:41 <jamy23> edwardk: +1
23:14:46 <jamy23> Question closed
23:14:49 <edwardk> jamy23: the 'power' of the notion of a functor, comes from the fact that there are a _ton_ of types that satisfy this requirement
23:15:19 <johnw> and that's the only the beginning of its power :)
23:15:28 <edwardk> jamy23: we also state a few laws for it, that require that mapping doesn't have any effects other than changing out the contents
23:15:58 <edwardk> that is that if you map with a function f, and then map with a function g, separately you get the same answer as if you mapped with the composition of those two functions.
23:16:10 <edwardk> and that if you map with the identity function the meaning of the whole container isn't changed.
23:16:17 <deus_rex> > length <$> (Just "foo")
23:16:19 <lambdabot>   Just 3
23:16:20 <edwardk> we write those fmap f . fmap g = fmap (f . g)
23:16:24 <edwardk> and fmap id = id
23:16:47 <edwardk> this means that fmap isn't going to launch missiles, it isn't updating some other numbers behind your back, etc.
23:16:51 <edwardk> its just changing out contents
23:17:04 <edwardk> and it enables you to reason about fusing together passes over the structure.
23:17:23 <edwardk> because if you find that you were doing two separate fmaps, you can smash them together into one.
23:17:25 <johnw> dues_rex: you don't need parens there
23:17:45 <jamy23> Do you have any realworld example of using functors?
23:18:04 <simpson> Sure. fmap for lists is map.
23:18:33 <edwardk> > fmap (+1) [1,2]
23:18:35 <lambdabot>   [2,3]
23:18:59 <jamy23> > map (+1)[1,2]
23:18:59 <johnw> jamy23: one thing functors do is they can map any function a -> b into a function f a -> f b.  If "f" in this case is a list, that means that a function like String -> Int can be turned into a function [String] -> [Int], simply by calling fmap on that function
23:19:01 <lambdabot>   [2,3]
23:19:15 <mauke> split1 c = fmap (S.drop 1) . S.span (c /=)
23:19:27 <mauke> n <- fmap (fromIntegral . runGet getWord32be) $ recvX s 4
23:19:44 <mauke> nick <- fmap norm nickname
23:20:02 <mauke> ^ code from preflex
23:20:49 <shachaf> preflex: seen preflex
23:20:49 <simpson> > fmap toUpper ["super-size me"]
23:20:51 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
23:20:51 <lambdabot>              with actual type...
23:21:03 <simpson> Oh, derp.
23:21:07 <simpson> > fmap toUpper "super-size me"
23:21:09 <lambdabot>   "SUPER-SIZE ME"
23:21:09 <ion> > fmap (fmap toUpper) ["foo", "bar"]
23:21:10 <edwardk> A bigger stretch for an example is that we use these things called Monads for all of our interaction with the real world. Every monad is (at least logically) a functor, including IO. Say you have something that reads a line from the user, that is an action of type IO String. You can fmap a calculation over that that does something with the string and gives you a new value, to get a value 'inside' IO. This is where the container analog
23:21:10 <edwardk>  breaks down and reasoning by the laws start to kick in.
23:21:11 <lambdabot>   ["FOO","BAR"]
23:21:24 * simpson may or may not have been doing Python all night
23:22:27 <jamy23> > let plusOne = fmap (+1)
23:22:29 <lambdabot>   not an expression: `let plusOne = fmap (+1)'
23:22:43 <deus_rex> @let plusOne = fmap (+1)
23:22:46 <lambdabot>  Defined.
23:23:00 * applicative have finally manage to compile Frank so he can run c. mcbride's mysterious s-expression parser, if thats what it should be called
23:23:12 <jamy23> plusOne [1,2]
23:23:16 <johnw> applicative: link?
23:23:31 <ion> > plusOne [1,2]
23:23:33 <simpson> > plusOne [1,2,3]
23:23:34 <lambdabot>   [2,3]
23:23:35 <lambdabot>   [2,3,4]
23:23:47 <applicative> https://personal.cis.strath.ac.uk/conor.mcbride/pub/Frank/fun.fk  http://hackage.haskell.org/package/Frank
23:23:51 <ion> @type plusOne readLn
23:23:53 <lambdabot> (Num b, Read b) => IO b
23:24:16 <jamy23> IO ? o_O
23:24:35 <ion> See what edwardk was talking about a moment ago.
23:25:08 <mauke> > fmap (+1) (2,3)
23:25:10 <lambdabot>   (2,4)
23:25:47 <ion> Given an IO action “a” that upon execution reads a line and returns a number, “plusOne a” upon execution reads a line and returns the number plus one.
23:25:59 <deus_rex> btw: http://english.stackexchange.com/questions/30654/where-does-the-term-monad-come-from
23:26:00 <sopvop> lens-3.5.1 - first minor version! lens development finally slows down?
23:26:15 <edwardk> sopvop: there were a lot of minor versions in the 3.0 era
23:26:21 <johnw> given how quickly it followed 3.5, i'm not sure that's why...
23:26:29 <edwardk> the major vs minor bumps are almost entirely driven by the PVP
23:26:31 <ion> Computations can be functors, too. Instead of containing a value of some type they can generate a value of said type. Parsers are another good example of that.
23:26:33 <shachaf> sopvop: No, that minor version came out because there was a bug in 3.5 that let you segfault.
23:26:46 <edwardk> that was 3.4
23:26:48 <shachaf> Oh.
23:26:53 <shachaf> Whoops, right.
23:26:54 <sopvop> Considering what major version releases every other day...
23:26:57 <edwardk> 3.5 was the fix to that. 3.5.1 was the fix to the SafeHaskell flags in 3.5
23:27:08 <shachaf> 3.6 will make them both obsolete.
23:27:17 <mgsloan> jamy23: IO is like a container, but in the process of asking for its contents, something with side effects might happen.  So it's easier just to think of them as actions.
23:27:25 <mgsloan> lenq will make it all obsolete ;)
23:27:27 <edwardk> 3.6 removes the need for all those SafeHaskell flags, and gives you the awesomeness that is field'
23:27:29 <mgsloan> I kidd I kidd
23:27:34 <edwardk> er 'field'
23:27:42 <simpson> Perhaps it might be useful to show off a type which has side effects.
23:27:42 <jamy23> So if i am compile this function in ghc and not push list from real world then this function dont be IO?
23:27:48 <sopvop> Will you split lens-core with all Control.Lens from rest of package in the future?
23:27:54 <simpson> This is around the time where Cale would show up and demonstrate State in -overflow. :3
23:27:54 <edwardk> sopvop: no
23:28:04 <mgsloan> or perhaps just distasteful to those who dislike finding TH in their Haskell soup
23:28:16 <edwardk> sopvop: the issue is that lens-core would need basically all of the same extensions and 90% of the same dependencies
23:28:34 <edwardk> sopvop: so users would suffer to no real portability benefit
23:28:59 <ion> jamy23: Sorry, what code do you mean?
23:29:02 <edwardk> the various Data.Foo.Lens packages are all in the platform
23:29:07 <sopvop> lets hope what monsters from cabal-hell don't get loose
23:29:47 <jamy23> plusOne have type IO becouse they print result on terminal?
23:29:48 <sopvop> And comonad and semigroups?
23:29:57 <edwardk> lens should build on the last 2 platforms, and will build on some 'frankenbuild' combinations before that
23:30:12 <edwardk> comonad and semigroups are needed for the API it presents.
23:30:47 <edwardk> all dependencies of lens are for things lens does internally or in the platform. the latter are supplied to provide a nice 'batteries included' api, and really its just a couple of additions to what lens uses on its own
23:30:55 <sopvop> I'm no longer sure what snap decision on moving to lens from data-lens is such a good idea. Way too early it seems.
23:31:05 <deus_rex> @type plusOne
23:31:06 <lambdabot> (Functor f, Num b) => f b -> f b
23:31:12 <edwardk> i don't add any dependency to lens that isn't in the platform or used directly by lens itself
23:31:29 <sopvop> Whats cool
23:31:33 <sopvop> Thats cool
23:32:09 <ion> plusOne :: f Integer -> f Integer where f is a Functor, that is, plusOne :: Functor f => f Integer -> f Integer. f can be list (i.e. []), Maybe, IO, a bunch of things. When you apply plusOne to a list, you get a list back. When you apply it to an IO action, you get an IO action back.
23:32:10 <edwardk> its pretty much the only sane way i can think of to keep the scope in check
23:32:23 <shachaf> edwardk: There's no easy way to get field to memoize the index, is there?
23:32:29 <elliott> how is it way too early?
23:32:30 <shachaf> Because it needs a structure to iterate over.
23:32:35 <edwardk> shachaf: sadly no. because the index could even change
23:32:38 <elliott> lens seems pretty stable to me
23:32:47 <edwardk> e.g. you could look at field 1 and use choose the second or third
23:32:49 <elliott> the essential API of the types is fundamental enough to not need changing
23:32:54 <edwardk> or base it on the constructor, etc.
23:33:23 <edwardk> 95% of lens has been stable since 2.0 or so =P
23:33:43 <Crockeo> I find it interesting that I go AFK 3 or so hours ago and you're still talking about lens.
23:33:55 <elliott> why talk about anything else
23:33:59 <elliott> it's the perfect topic!
23:34:07 <Crockeo> If there's one thing Haskell programmers know how to do it's to not mutate topics.
23:34:08 <Crockeo> BAM
23:34:12 <Crockeo> IMMUTABLE DATA JOKES
23:34:18 <shachaf> edwardk: Right.
23:34:23 <johnw> aka, Persistence Jokes
23:34:30 <deus_rex> @type cons
23:34:31 <Crockeo> Yeah... that
23:34:32 <lambdabot>     Not in scope: `cons'
23:34:32 <lambdabot>     Perhaps you meant one of these:
23:34:32 <lambdabot>       `BS.cons' (imported from Data.ByteString),
23:34:35 <edwardk> crockeo: well the topic may be immutable, but we have lots of them lying around.
23:34:45 <Crockeo> Haha
23:34:57 <johnw> every line we type spawns a new instance of this channel
23:35:09 <deus_rex> lol
23:36:00 <Crockeo> enter :: Chat -> Chat
23:36:02 <Crockeo> WAIT NO
23:36:10 <Crockeo> enter :: String -> Chat -> Chat
23:36:11 <shachaf> edwardk: Uh oh.
23:36:13 <johnw> it would have to be IO Chat
23:36:15 <edwardk> ?
23:36:17 <Crockeo> :(
23:36:17 <shachaf> λ> set (field (fst.fst)) 'q' (('a','b'),('c','d'))
23:36:17 <shachaf> ((Segmentation fault
23:36:18 <Crockeo> Oh yea.
23:36:27 <Crockeo> Well
23:36:28 <Crockeo> lets just say
23:36:38 <ion> shachaf: nice
23:36:39 <edwardk> let me try it with the new traversal one
23:36:41 <edwardk> which is safer
23:37:26 <Crockeo> Wait, johnw, no it doesn't, this is just creating a new Chat object for when we add another line.
23:37:26 <Crockeo> It doesn't have to know that it came from user input.
23:37:26 <Crockeo> ...
23:37:26 <Crockeo> Does it?
23:37:54 <johnw> Crockeo: then how am I going to see the result of your addition?
23:38:04 <Crockeo> Uhhhhhhhhhhhhhh
23:38:05 <Crockeo> well
23:38:07 <Crockeo> see
23:38:08 <Crockeo> once upon a time
23:38:17 <Crockeo> we had a new user trying to make a joke
23:38:29 <deus_rex> unsafePerformIO ? :)
23:38:35 <johnw> dues_rex: bad!
23:38:40 <Crockeo> and he didn't fully understand the consequences of trying to make misinformed jokes in an IRC chat filled with Haskell programmers.
23:39:13 <edwardk> shachaf: neat
23:39:21 <jamy23> So plusOne doesn't have type IO. It has readLine
23:39:22 <shachaf> edwardk: Does it fix it?
23:39:28 <edwardk> same
23:39:37 <edwardk> one sec. let me put the cast back in and require Typeable on the field =(
23:39:47 <shachaf> I thought so.
23:39:56 <shachaf> I think you have to do something like that.
23:41:19 <ion> jamy23: readLn :: IO Integer; plusOne :: Functor f => f Integer -> f Integer. When you apply plusOne to readLn you make the “f” “IO” for that invocation. [1,2,3] :: [Integer]. When you apply plusOne to [1,2,3] you make the “f” “[]” for that invocation. ([] Integer = [Integer])
23:43:26 <edwardk> shachaf: >>> set (field (fst.fst)) 'q' (('a','b'),('c','d'))   ==> (('a','b'),('c','d')) properly ignores it
23:43:37 <johnw> what is the best way to render a Rational as floating point?  I know GHC uses GMP for rationals; does it also use MPFR?
23:43:45 <shachaf> edwardk: With the Typeable constraint?
23:43:48 <edwardk> yeah
23:43:50 <johnw> and by floating point, I mean decimal floating point
23:43:51 <ion> johnw: realToFrac :: Rational -> Double
23:43:54 <shachaf> Makes sense.
23:43:58 <edwardk> typeable there isn't so bad, with data on the overall container
23:44:04 <edwardk> you have to have typeable ;)
23:44:06 <johnw> ion: I more am interested in turning a Rational into a decimal floating point *string*
23:44:11 <johnw> not a Double (which is binary floating point()
23:44:14 <shachaf> Do you still have to unsafeCoerce?
23:44:20 <edwardk> no, thats gone
23:44:23 <edwardk> its safer now
23:44:26 <edwardk> just cast
23:44:33 <johnw> in C, I'd using mpfr_printf
23:45:01 <johnw> ah, I can use hmpfr
23:45:09 <jamy23> ion: so i can not worry about of purity function plusOne?
23:45:35 <ion> johnw: show . (realToFrac :: Rational -> Double)? Or perhaps CReal instead of Double for more precision.
23:45:51 <johnw> a Double will not hold a Rational
23:45:56 <johnw> of type Ratio Integer
23:46:30 <johnw> i need GMP-scale rendering of rationals to decimal floating point; that's one reason MPFR was created
23:47:20 <ion> jamy23: An IO action (a value of type IO Something) in itself is a pure, immutable value. The side effects only happen when it’s executed. You can, say, store IO actions in a list and they won’t be executed unless you choose to do so. You can also use fmap against IO actions without that involving any impurity.
23:48:59 <jamy23> Storing IO-s actions - sounds good! :))))
23:49:18 <lispy> When I was in undergrad I thought Ratio Integer was awesome. I can't think of a time since thinking that that I've found a legitimate time when it was actually the solution :(
23:49:56 <Ralith> it's a nice solution for accurately storing human-entered decimals
23:50:02 <Ralith> and fractions
23:50:04 <ion> jamy23: An example: main = [ print "foo", print "bar", print "baz" ] !! 1
23:50:27 <ion> jamy23: That will evaluate (without any impurity) to main = print "bar"
23:50:32 <johnw> man, edwardk commented even on the hmpfr thread; he truly is omnipresent
23:50:55 <ion> jamy23: The runtime system will execute only the IO action bound to “main”.
23:52:18 <edwardk> johnw: well, if i can get my version of it working then i'll be happy ;)
23:52:36 <edwardk> hmpfr is pretty useless in its current incarnation
23:52:45 <copumpkin> >_>
23:52:47 <copumpkin> <_<
23:52:53 * copumpkin *poof*
23:53:10 <edwardk> =)
23:53:15 <johnw> edwardk: i'm wondering if it's good enough for the one thing I need it for
23:53:31 <johnw> is there any alternative?
23:53:40 <jamy23> whether the pythons programmers say "I store the IO action"? Or ruby? Or lisp? Or etc?
23:54:03 <copumpkin> johnw: you need a custom GHC to even use it
23:54:06 <edwardk> johnw: i've been working on 'rounded' but i haven't shipped it and it interacts poorly with ghci right now
23:54:18 <johnw> copumpkin: well, the project page says that 0.3.3 will work "most of the time" with an unmodified GHC
23:54:21 <edwardk> copumpkin will fix it though. i have faith
23:54:26 <edwardk> johnw: it lies
23:54:38 <johnw> i only need "toString", nothing else
23:54:43 <edwardk> they seriously underestimate the scope of the problem
23:54:50 <copumpkin> johnw: presumably you need to do arithmetic?
23:54:53 <johnw> no
23:54:59 <johnw> all my arithmetic is done on rational
23:55:00 <johnw> ss
23:55:09 <copumpkin> why not just use CReal?
23:55:11 <johnw> I only need mpfr for properly rounded conversion to decimal FP strings
23:55:19 <johnw> is CReal arbitrary precision?
23:55:22 <copumpkin> infinite
23:55:24 <edwardk> johnw: note the conversion from a rational is 'arithmetic' =P
23:55:24 <johnw> ooh
23:55:29 <ion> jamy23: IO actions aren’t first-class values in those languages; e.g. in Python or Ruby evaluating ‘print "foo"’ will already execute the side effect of printing something. In them you can’t directly make a list of [ print "foo", print "bar", print "baz" ] and only pick one of the items to be executed.
23:55:31 <johnw> edwardk: ah, ok
23:55:34 <copumpkin> > showCReal 100 pi
23:55:36 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
23:55:42 <copumpkin> > length $ showCReal 1000 pi
23:55:44 <johnw> is CReal properly rounded?
23:55:45 <lambdabot>   1002
23:55:51 <copumpkin> johnw: CReal doesn't do rounding at all
23:55:55 <copumpkin> it's infinite!
23:55:59 <johnw> hmm
23:56:03 <edwardk> johnw: CReal is infinite, it gives you digits until you tell it to stop
23:56:04 <johnw> i need to be able to specify a precision
23:56:11 <johnw> like, "2 places", with proper rounding
23:56:18 <edwardk> then specify more precision than you need, and round the result
23:56:30 <edwardk> CReal is going to produce exact answers very slowly
23:56:38 <johnw> edwardk: yeah, then we get into some heavy imprecision though
23:56:38 <copumpkin> yeah, I'm not sure what showCReal is doing at the last spot, but you can always just ask for more
23:56:45 <copumpkin> johnw: how?
23:57:04 <johnw> well, how many "extra" places do I need before I avoid a rounding error?
23:57:13 <johnw> 4999999999, for example
23:57:23 <ion> jamy23: The IO action returned by ‘print "foo"’ in Haskell is more like a description of a side-effectful computation you can choose to have executed by the runtime by binding it to “main”.
23:57:50 <johnw> that should round down to 0 in some cases, toward 5 in others
23:58:10 <johnw> 0.1549999 should become 0.15 cents
23:58:15 <johnw> or 0.155 cents
23:58:32 <simpson> Well, money's different.
23:58:36 <ion> > showCReal 2 0.1549999
23:58:38 <lambdabot>   "0.15"
23:58:40 <johnw> that's all that I'll be using it for
23:58:44 <ion> > showCReal 3 0.1549999
23:58:46 <lambdabot>   "0.155"
23:58:54 <johnw> cool!
23:59:00 <simpson> Uh. If you're handling money, I'd think that you'd want a much more precise and controllable datatype.
23:59:00 <johnw> that may be good enough, excellent
23:59:09 <copumpkin> simpson: you can't get more precise than CReal :P
23:59:13 <copumpkin> you just can't observe the precision :)
23:59:26 <deus_rex> is somebody using floating point arithmetic for currency?
23:59:29 <simpson> copumpkin: You're right, I meant "exact," not "precise."
23:59:30 <copumpkin> deus_rex: no
23:59:33 <lispy> is CReal ready for real use?
23:59:37 <johnw> i maintain precision myself separately from my rendering to a decimal
23:59:38 <copumpkin> lispy: no
23:59:44 <lispy> I recommended it to a friend and he came back saying it looked very unpolished
23:59:46 <ion> lispy: Doesn’t its name answer your question?
23:59:50 <lispy> (he read the source)
23:59:57 <johnw> copumpkin: it's not ready for real use?
23:59:57 <copumpkin> lispy: it's slow, but it works
23:59:59 <edwardk> lispy: well, its not going to get any more refined ;)
