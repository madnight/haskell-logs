00:00:42 <fenton> sopvop: thx!
00:01:39 <fenton> sopvop: wont there be issues if I 'make install' while I've got a current ghc in place?  can we have two ghc's at once?
00:02:13 <fenton> sopvop: or use a prefix to ensure it doesn't go into the system location?
00:02:33 <sopvop> fenton: That's what I've meant
00:02:47 <fenton> sopvop: ok...got it.
00:04:55 * hackagebot cryptohash 0.7.7 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.7 (VincentHanquez)
00:07:28 <o-_-o> Where is the config.log for a cabal build ?
00:07:52 <o-_-o> A build is failing and I am trying to debug, but unable to find the config.log
00:08:01 <o-_-o> THis is in windows BTW
00:08:31 <adnauseam> running a search isn't helping ?
00:08:45 <o-_-o> On the entire filesystem ?!
00:08:48 <shachaf> You should pick a less punctuationful nick. :-(
00:09:00 <simpson> Hey, he's just got earmuffs, man.
00:09:10 <manjunaths> Sorry
00:09:14 <shachaf> If this was UNIX I would say strace.
00:09:16 <manjunaths> Go ahead.
00:09:41 <Saizan> manjunaths: i think it should be in the dist dir
00:09:56 <manjunaths> Saizan, Where will this be ?
00:10:13 <Saizan> manjunaths: so cabal unpack the package and cabal install from within the created directory
00:10:24 <Saizan> manjunaths: dist will be created there
00:10:37 <manjunaths> Saizan, ah...great. I'll try that.
00:12:27 <manjunaths> cabal.exe: Missing dependency on a foreign library:
00:12:28 <manjunaths> * Missing C library: fftw3
00:12:37 <manjunaths> I installed this library and it is in /usr
00:13:39 <Saizan> yeah, the log or -v3 should tell you why it doesn't work for cabal
00:13:54 <Saizan> or at least what cabal is testing
00:17:01 <manjunaths> I am going crazy here, I think
00:21:39 <frontend1oader> http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html for the 9th question at the bottom, there's a way to dodge floating point math in that right?
00:23:33 <frontend1oader> my math is rusty, but I think you can do a cross product of vectors to get a direction?
00:23:56 <c_wraith> frontend1oader: well, no, if the numbers are floating point, arithmetic on them is floating point.  But it certainly doesn't require division
00:24:38 <frontend1oader> the points I get wouldn't be floats, but some of the intermediate math might need to be
00:25:03 <c_wraith> nah, you only need multiplication, addition, and subtraction
00:25:35 <Nereid> frontend1oader: cross product as it is only makes sense in 3 dimensions, but there's a similar thing you can do in 2d to get an orientation.
00:25:40 <Nereid> in terms of some determinant.
00:26:01 <c_wraith> oh, and comparison with zero
00:26:10 <ski> (cross product can also make sense in `0',`1' and `7' dimensions, iirc)
00:26:21 <frontend1oader> I've been trying to avoid trig for this
00:26:36 <Nereid> ski: but it's trivial in 0 and 1, and not unique in 7
00:27:12 <ski> sounds plausible
00:27:22 <c_wraith> you don't need trig
00:27:28 <c_wraith> it's just multiplication and addition
00:27:40 <c_wraith> (well, and subtraction to calculate the two vectors to compare)
00:27:42 <Nereid> if nothing in your problems involves computing/using an angle, then you don't need trig. period.
00:29:47 <cornihilio> hey, how do I solve this problem?: "cabal: Missing dependency on a foreign library: * Missing C library: pcre"
00:30:09 <Nereid> sounds like you need pcre
00:30:35 <cornihilio> yeah, but when I search ubuntu packages for pcre I get libraries for using it, but nothing seems to stick out as the c lib
00:30:59 <Nereid> cornihilio: no -dev package?
00:31:19 <luite> and you need the development package (that includes headers)
00:31:22 <luite> libpcre3-dev
00:31:44 <neutrino_> hey guys. i have a function f :: a -> IO (b, b). I want to get the first element of that in IO (I want a function :: a -> IO b). how can i do that with "fst"?
00:31:54 <Nereid> @type fmap fst
00:31:56 <lambdabot> Functor f => f (b, b1) -> f b
00:32:04 <neutrino_> ohh nice fmap
00:32:14 <neutrino_> how can i do this with <$>?
00:32:21 <ion> (<$>) = fmap
00:32:22 <luite> fst <$> a
00:32:22 <Nereid> (<$>) = fmap
00:32:28 <neutrino_> ok
00:33:05 <neutrino_> and if i then want to apply e.g. "length" to that first element and get IO Int, then i'd do:     f arg <$> fst <*> length ?
00:33:18 <cornihilio> Nereid: thank you, that was the issue
00:33:30 <luite> neutrino_: no, fst and length are pure
00:33:33 <ion> length . fst <$> f arg
00:33:46 <Nereid> cornihilio: in general you need the corresponding -dev package to compile stuff that uses a library
00:33:46 <neutrino_> :S
00:33:52 <neutrino_> ok
00:34:06 <neutrino_> makes sense. thanks
00:34:18 <ion> @type (<$>)
00:34:20 <lambdabot> Functor f => (a -> b) -> f a -> f b
00:34:29 <neutrino_> right
00:34:33 <neutrino_> @type (<*>)
00:34:35 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
00:34:41 <ion> (([a],[b]) -> Int) -> IO ([a],[b]) -> IO Int
00:35:05 <neutrino_> yup :)
00:35:07 <neutrino_> thank you ion
00:36:49 <neutrino_> btw, is there a way to assert in HUnit that what a function returns is Just _ and not Nothing?
00:37:02 <ion> @type isJust
00:37:03 <lambdabot> Maybe a -> Bool
00:37:18 <neutrino_> hmm
00:37:29 <neutrino_> more generally, is there a way to assert a specific pattern matches?
00:37:42 <shachaf> Yes, by matching on it.
00:37:42 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
00:37:47 <Nereid> you'll have to write your own function if it doesn't already exist
00:38:14 <fenton> yeah, I'm gonna give up on arch...so sad...off to gentoo land.
00:38:16 <neutrino_> how?
00:38:41 <Nereid> like
00:38:44 <Nereid> f (Just _) = True; f _ = False
00:38:44 <ion> case foo of Bar -> True; Baz -> False
00:38:45 <yitz> seems like in 4d it would make sense to talk about the cross product of two planes
00:38:56 <ion> f Bar = True; f Baz = False
00:38:58 <Nereid> yitz: you don't get another plane there
00:39:11 <neutrino_> mhm
00:39:25 <shachaf> (\case of Bar -> True; _ -> False)
00:39:26 <neutrino_> i thought of that but i am sort of unhappy with it
00:39:28 <yitz> Nereid: what do you mean? there are plenty of them to go around.
00:39:31 <neutrino_> because the error report will suck
00:39:33 <Nereid> yitz: just try it
00:40:11 <Nereid> yitz: the cross product in 3 dimensions is formed by:
00:40:20 <Nereid> you have two (1-)vectors
00:40:30 <Nereid> you take their wedge product to get a bivector (1 + 1 = 2)
00:40:37 <Nereid> and then dualize to get a vector back (3 - 2 = 1)
00:41:49 <Nereid> (Hodge dual)
00:42:33 <neutrino_> you can however have some fun by generalizing bilinear forms
00:43:07 <neutrino_> the details escape me though
00:44:41 <statusfailed> Does anyone know how to get in touch with bryan o'sullivan? I'm trying to get the riak package updated...
00:45:05 <statusfailed> I sent him an email but haven't heard back
00:46:23 <shachaf> Sometimes he's in here.
00:46:32 <covi> After finishing LYAH, what should I read / learn to hone my skills?
00:46:43 <statusfailed> shachaf: do you know his nick?
00:46:45 <yitz> Nereid: the two planes might miss, or intersect in a point. but if they intersect in a line, then there is a unique plane containing that line and perpendicular to both of them.
00:46:51 <Nereid> statusfailed: he's usually here as "bos"
00:46:54 <shachaf> statusfailed: It's bos. But he's not in here right now.
00:46:57 <statusfailed> ah ok, cheers
00:47:44 <Nereid> yitz: two planes through the origin will never miss. in any case, they will generically intersect in a point
00:48:02 <ski> statusfailed : .. you could try leaving a message, i suppose
00:48:14 <Nereid> yitz: so any continuous function of two planes that vanishes when the planes intersect at a point is trivial
00:48:16 <yitz> Nereid: through the origin, yes.
00:49:04 <statusfailed> ski: with @tell is it?
00:49:07 <yitz> Nereid: sorry i don't follow that
00:49:24 <yitz> what is a "function of two planes"?
00:49:24 <ski> statusfailed : yes, or `@ask'
00:49:35 <Nereid> yitz: a function which takes two planes as an argument
00:50:07 <Nereid> because
00:50:14 <Nereid> given any pair of planes that intersect in a line,
00:50:35 <Nereid> moving one of the planes a little bit can change the intersection to just a point
00:50:38 <statusfailed> ski: cheers
00:54:46 <yitz> Nereid: yes. but my function is defined on the variety of pairs of planes that meet in a line.
00:54:54 <Nereid> ok, and then?
00:54:56 * hackagebot project-template 0.1.0.1 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.0.1 (MichaelSnoyman)
00:56:12 <yitz> Nereid: i'm just not understanding what point you are trying make with your statement about continuous functions on all pairs of planes
00:56:36 <Nereid> if your function was defined on all pairs of planes
00:56:48 <Nereid> and it was trivial when the planes intersect in a point
00:56:58 <Nereid> and it's continuous, then it's trivial everywhere.
00:57:28 <Nereid> that's all I was saying.
00:57:46 <yitz> Nereid: but it's not defined at all on pairs of planes that intersect in a point
00:57:54 <Nereid> if you want.
00:57:59 <Nereid> then what I said doesn't apply.
00:59:13 <fujisan> @messages
00:59:13 <lambdabot> veronicamars said 29s ago: "Hell is other people." ~Sartre
00:59:34 <Nereid> I don't know where you're going with it, though.
01:00:45 <yitz> Nereid: people were discussing possible analogues of the cross product in higher dimensions. i was just mentioning one that immediately came to mind.
01:01:06 <yitz> Nereid: in other words, where i'm going with it is off on a perpendicular, really.
01:02:46 <mmos> I've been using the musicxml package for Haskell work with music representation in MusicXML but it is hopelessly out of date. I was wondering if maybe there is an automated tool that would let me build a haskell interface for any XML specification (called DTD? or something).. it doesn't have to be pretty, just compile with modern versions of GHC.
01:03:47 <yitz> mmos: i was working on a package like that.
01:04:29 <Nereid> anyway, the cross product deals with vectors, not lines.
01:05:07 <frontend1oader> http://stackoverflow.com/a/3461533 this SO answer covers what I was looking for
01:05:41 <Nereid> it does. I'm really hesitant to call it a cross product though
01:06:43 <yitz> Nereid: yeah, it gives you a function on lines, but that function isn't really what people usually mean when they say cross product.
01:06:46 <randomclown> You got n red ball and n blacks balls in a sack. You take them out one by one and you write down the sequence of reds and blacks you get. How many different sequences could you get?
01:07:38 <mmos> yitz: sorry, you were working on autogenerating code from the DTD, or on MusicXML?
01:07:48 <randomclown> Sorry wrong channel
01:07:58 <yitz> mmos: from dtds.
01:08:23 <fujisan> @messages
01:08:23 <lambdabot> You don't have any new messages.
01:08:26 <yitz> mmos: musicxml is horribly messy. i use lilypond, which is also messy, but less so.
01:08:28 <Nereid> #messages
01:08:31 <Nereid> @messages
01:08:31 <lambdabot> You don't have any new messages.
01:08:31 <frontend1oader> It's too late and I can't quite concentrate long enough to derive that formula on SO in my head
01:09:03 <yitz> @tell Nereid now you have a message
01:09:03 <lambdabot> Consider it noted.
01:09:34 <Nereid> @messages
01:09:34 <lambdabot> yitz said 32s ago: now you have a message
01:09:35 <fujisan> @messages
01:09:36 <lambdabot> veronicamars said 7s ago: "I've got a secret a good one."
01:09:37 <Nereid> !
01:10:37 <fujisan> yitz what's that thing you do to pants?
01:11:20 <neutrino_> wat
01:15:18 <fujisan> yitz still here?
01:33:43 <neutrino_> hunit is really working out for me so far
01:34:06 <neutrino_> in most other languages tdd is always a drag but here it kind of works out
01:34:18 <neutrino_> maybe it's because additional constraints on how i structure my code
01:34:40 <neutrino_> and definitely because of the functional nature of it which makes it immediately testable in most cases
01:36:00 <mmos> yitz: if you are still there, I'm using MusicXML export from Sibelius as an interface into some algorithms for simulating human performance. I like the rich-features WYSIWYG software for editing and working with the music so LilyPond doesn't appeal, not at this stage.
01:36:42 <neutrino_> have you considered using an intermediary in python which converts from xml to say json?
01:37:14 <neutrino_> i bet you don't need full fledged musicxml support?
01:37:29 <neutrino_> just note time, duration, and pitch
01:38:00 <shachaf> doublenapped g = unsafeCoerce $ map (unsafeCoerce (unsafeCoerce $ map (unsafeCoerce g)))
01:38:10 <shachaf> Great code, eh?
01:38:45 <startling> shachaf: haha what
01:39:11 <startling> :t unsafeCoerce
01:39:13 <lambdabot> Not in scope: `unsafeCoerce'
01:39:15 <shachaf> a -> b
01:39:18 <startling> aw. I wanted to typecheck that.
01:39:41 <shachaf> Why are you eta-expanding, GHC? :-(
01:40:04 <neutrino_> it is eta expanding towards a cold death
01:40:08 <startling> :t let unsafeCoerce = undefined :: a -> b in \g -> unsafeCoerce $ map (unsafeCoerce (unsafeCoerce $ map (unsafeCoerce g)))
01:40:09 <lambdabot> a -> b
01:40:15 <startling> heh.
01:40:25 <neutrino_> you had that one coming
01:40:32 <shachaf> Well, you can't blame it.
01:40:42 <shachaf> It's actually :: Setting [[a]] [[b]] a b
01:40:53 <startling> shachaf: oh god is this lens
01:41:42 <shachaf> Grr!
01:41:52 <shachaf> No wonder it wasn't working. I was testing against doublemapped instead of doublenapped.
01:41:53 <neutrino_> *meow*
01:42:25 <neutrino_> shachaf: i was wondering if you were thinking about dozing off, but hadn't realized it was an error.
01:44:12 <shachaf> startling: Hmm...
01:44:16 <shachaf> Maybe I just need to add a pure#
01:44:29 <shachaf> edwardk was saying it doesn't matter but I think it does matter when you nest lenses.
01:44:35 <Sonderblade> i need a way in haskell to describe arbitrary traversal of a nested json object, like getValue jsonObj ["commands", 0, "parameters", "bar"]. read as "take the value of the commands key, then the first element of the array, then the parameters key then "bar" key and return the value found
01:44:49 <Sonderblade> it doesnt work because you cant mix data types in list, how can you do it instead?
01:45:09 <Botje> you typically create a tagged union.
01:45:19 <shachaf> data Foo = Key String | Index Int?
01:45:28 <shachaf> [Key "commands", Index 0, ...]
01:45:36 <Jafet> [Dynamic]
01:47:07 <Sonderblade> cool, is there a builtin types for "either String or Int"?
01:47:25 <Jafet> Either String Int
01:47:30 <neutrino_> Sonderblade: lens
01:48:06 <shachaf> Is neutrino_ just trolling this channel or what?
01:48:13 <Sonderblade> idk what that is
01:48:57 <neutrino_> i believe if you used lens the syntax would be something like jsonObj ^.at "commands" ^._1 ^.at "parameters" . "bar"
01:49:02 <neutrino_> shachaf: what is your problem with me?
01:49:35 <neutrino_> Sonderblade: https://github.com/ekmett/lens/wiki/Examples
01:50:21 <neutrino_> shachaf: please stop being unfriendly towards me. this is not helping the channel and there is no reason for it.
01:54:17 <Jafet> This is what happens when someone says "tr*v*rs*l" around here
01:55:36 <Jafet> Hm... t7l, c7t, c11t, b4r
01:56:20 <Nereid> what are those last ones?
01:56:33 <Sonderblade> also i think the json library i'm using (aeson) should have what i'm looking for builtin, but im to stupid to find it in the docs
01:59:24 <neutrino_> @hoogle [a] -> Value -> b
01:59:25 <lambdabot> Warning: Unknown type Value
01:59:25 <lambdabot> Prelude foldl :: (a -> b -> a) -> a -> [b] -> a
01:59:25 <lambdabot> Data.List foldl :: (a -> b -> a) -> a -> [b] -> a
01:59:29 <neutrino_> hmm.
01:59:42 <neutrino_> @hoogle [a] -> Data.Aeson.Types.Value -> b
01:59:43 <lambdabot> Parse error:
01:59:43 <lambdabot>   [a] -> Data.Aeson.Types.Value -> b
01:59:43 <lambdabot>              ^
02:00:49 <fujisan1> hello shachaf
02:04:35 <fmap> Sonderblade: I don't think aeson has this builtin.
02:05:44 <Nereid> aeson doesn't have a whole lot built in.
02:05:56 <Nereid> but there's aeson-lens =)
02:06:42 <Nereid> so that you might use this lens: obj "commands" . arr 0 . obj "parameters" . obj "bar"
02:08:14 <neutrino_> hah
02:08:15 <neutrino_> nice
02:08:21 <shachaf> @messages
02:08:22 <lambdabot> fujisan1 said 31s ago: “Ready are you? What know you of ready? For eight hundred years have I trained shachaf. My own counsel will I keep on who is to be trained. A shachaf must have the deepest
02:08:22 <lambdabot> commitment, the most serious mind. This one a long time have I watched. All his life has he looked away... to the future, to the horizon. Never his mind on where he was. Hmm? What he was doing. Hmph.
02:08:22 <lambdabot>  Adventure. Heh. Excitement. Heh. A shachaf craves not
02:08:31 <Sonderblade> Nereid: that's really similar to what shachaf suggested
02:08:31 <shachaf> @where ops
02:08:31 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
02:08:44 <Nereid> Sonderblade: it's really not
02:08:47 <shachaf> Can someone do something about fujisanspam?
02:09:27 <Sonderblade> Nereid: the syntax is similar anyway :p
02:09:40 <fmap> Nereid: you mean key "commands" . nth 0 . key "commands" . key "bar" :)
02:10:32 <Nereid> what are those?
02:10:39 <fmap> aeson-lens
02:10:49 <Nereid> oh I was looking at the doc for an older version.
02:13:02 <neutrino_> that's so annoying isn't it, you google for a package and you get linked to an old version
02:13:24 <fujisan1> hi lambdabot
02:13:44 <fujisan1> can someone do something about shachaf bad mojo karma ?
02:13:50 <fujisan1> it's because im asian right?
02:13:58 <fmap> there probably should be monomorphic `key'-like lenses, writing type annotations isn't fun
02:14:40 <Nereid> why make those key-like?
02:15:05 <Nereid> why not have something like asDouble :: SimpleLens (Maybe Value) (MaybeDouble)
02:15:09 <Nereid> oops space
02:15:24 <fmap> or this
02:15:55 <fmap> anyway `:: Maybe Double' is ew
02:15:57 <Nereid> put all the monomorphism together, instead of spreading it all over the library.
02:16:11 <Nereid> I'm just saying that to make it compatible with nth/key
02:16:13 <shachaf> Oh, hmm.
02:16:13 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
02:16:17 <shachaf> I think this might be another GHC bug.
02:16:18 <shachaf> @messages
02:16:19 <lambdabot> fujisan1 said 4m 31s ago: http://www.brainyquote.com/quotes/quotes/j/jimrohn147503.html
02:17:47 <Nereid> shachaf: what is?
02:18:40 <startling> Nereid: Maybe things aren't often legal lenses
02:19:13 <Nereid> tell that to the aeson-lens author
02:19:15 <startling> err, never mind, I misread that.
02:19:24 <shachaf> Nereid: blah x = over (mapped.mapped.mapped) x seems to generate different code from triplemapped=mapped.mapped.mapped; blah x = over (triplemapped) x
02:19:30 <shachaf> I mean, code with different strictness.
02:19:44 <Nereid> shachaf: oh dear
02:20:04 <fmap> Nereid: yeah, I've sent him an email
02:20:36 <Nereid> fmap: I guess you'd still get a traversal though?
02:20:37 <Nereid> or
02:21:09 <startling> it's when you get nested maybes that you get illegal lenses.
02:21:14 <Nereid> I know.
02:21:16 <startling> but yeah, you could still have a traversal.
02:22:03 <fmap> Nereid: tbh I don't care if something is legal if it's practical
02:22:07 <Nereid> heh
02:22:13 <fmap> I'm a horrible person :[
02:23:20 <Nereid> isn't a traversal just as good in this case though?
02:23:22 <startling> you can write a separate Getter as well as the Traversal and still be legal, I think.
02:23:30 <startling> Nereid, you can't get with a traversal.
02:23:37 <Nereid> no, but
02:23:42 <Saizan> you can fold
02:23:51 <Nereid> you can fold into a Maybe
02:24:02 <startling> yeah. hmmm
02:24:07 <Nereid> and it's just as good as getting a Maybe
02:26:24 <startling> what does the kind of fold look like?
02:26:32 <Nereid> kind?
02:26:43 <neutrino_> :t fold
02:26:45 <lambdabot>     Not in scope: `fold'
02:26:45 <lambdabot>     Perhaps you meant one of these:
02:26:45 <lambdabot>       `Data.Foldable.fold' (imported from Data.Foldable),
02:26:54 <shachaf> type Fold s a = (a -> Const r a) -> s -> Const r s , if that's what you mean.
02:26:57 <Nereid> :t (^?)
02:26:59 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
02:26:59 <neutrino_> :t Data.Foldable.Fold
02:27:01 <lambdabot>     Not in scope: data constructor `Data.Foldable.Fold'
02:27:01 <shachaf> It's like a read-only Traversal.
02:27:05 <neutrino_> erm.
02:27:08 <neutrino_> :t Data.Foldable.fold
02:27:09 <lambdabot> (Data.Foldable.Foldable t, Monoid m) => t m -> m
02:27:21 <neutrino_> isn't the kind going to be * -> * ?
02:27:26 <shachaf> There's no kind.
02:27:34 <startling> god damn, I need to stop using that word in #haskell.
02:27:35 <Nereid> values have types, not kinds
02:28:09 <Nereid> types have kinds.
02:28:12 <startling> I mean, what would a fold over a traversal to produce a Maybe look like?
02:28:23 <startling> Nereid: yes, I know, I meant "kind" in the layman sense.
02:28:24 <Nereid> it would look like (^?)
02:28:42 <shachaf> headOf?
02:28:58 <Nereid> same thing, just flipped
02:29:01 <fujisan1> hi
02:29:07 <shachaf> > [1,2,3] ^? traverse
02:29:09 <lambdabot>   Just 1
02:29:12 <shachaf> > [] ^? traverse
02:29:14 <lambdabot>   Nothing
02:29:29 <shachaf> (Well, I'm not sure what you actually meant.)
02:29:35 <startling> huh, neat.
02:30:00 <Nereid> shachaf: we're looking at aeson-lens
02:30:26 <Nereid> and noting that nth and key aren't valid lenses, but they could made into traversals, and the interface would probably end up being better too
02:30:49 <fujisan1> not valid shachaf
02:31:16 <fujisan1> Nereid:  i concur
02:32:43 <Saizan> shachaf: do we have implicit quantification in the RHS of type synonyms now?
02:33:15 <shachaf> Saizan: Ah, no.
02:33:30 <shachaf> Although ghci will print the types unquantified if you don't have -fprint-explicit-foralls. :-)
02:33:35 <fujisan1> does that imply the negative of explicit qualification in the RHS of type antonyms then?
02:33:46 --- mode: ChanServ set +o Saizan
02:33:56 <Nereid> ...
02:34:04 <Saizan> he flew?
02:34:23 <Nereid> I should fly too. to bed.
02:34:46 <shachaf> Saizan: He's been banned several times, and has been spamming me over #haskell, /msg, and @tell.
02:35:34 <startling> ghc should get type antonyms.
02:36:26 <Saizan> shachaf: i wonder what we could do
02:36:26 <lambdabot> Saizan: You have 1 new message. '/msg lambdabot @messages' to read it.
02:36:33 <Saizan> oh, god.
02:36:55 <Nereid> does lambdabot have an ignore feature?
02:36:58 <shachaf> Yes.
02:37:04 <Nereid> as any bot should.
02:37:08 <shachaf> If I was a legitimate @admin I would use it.
02:37:15 <shachaf> Unfortunately the list doesn't persist across restarts.
02:37:25 <Nereid> well then.
02:37:29 <Saizan> shachaf: we could ask Cale to put it in the .rc
02:37:49 * shachaf suspects it won't do too much good.
02:37:57 <shachaf> Oh well. It'll pass.
02:38:17 --- mode: Saizan set +b fujisan1!*@*
02:38:22 <Saizan> one more ban won't hurt
02:38:27 --- mode: Saizan set -o Saizan
02:38:37 <Saizan> shachaf: well, he could change nicks
02:38:41 <shachaf> Right.
02:39:59 * hackagebot flaccuraterip 0.2 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.2 (NicolaSquartini)
02:40:22 <Nereid> form
02:41:18 <Inst> huh
02:42:12 <Nereid> time to sleep.
02:42:19 <Nereid> bye
02:42:23 <FUZxxl> Heyhey
02:42:48 <FUZxxl> Is there something like getCOntents that returns bytes instead of (encoding translated) chars?
02:43:14 <shachaf> Oh boy.
02:43:19 <Saizan> in bytestring
02:43:25 <shachaf> (map . (map . map)) /= ((map . map) . map)?
02:43:28 <shachaf> Could it be?
02:43:41 <shachaf> WRT strictness.
02:45:04 <shachaf> (And the left-associative version is better?)
02:47:27 <startling> :t map . (map . map)
02:47:28 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
02:47:36 <startling> right, makes sense.
02:47:48 <startling> not the associativity though.
02:48:55 <FUZxxl> shachaf: Thank you
02:49:00 <FUZxxl> Totally forgot about that...
02:49:07 <FUZxxl> I haven't done any Haskell for so long
02:49:27 <shachaf> FUZxxl: Glad to be of service. Even if the service is just "be in the channel while Saizan helps you".
02:49:37 <FUZxxl> hehe
02:49:48 <FUZxxl> Oh ....
02:49:59 <FUZxxl> Saizan: Thank you for your help!
02:49:59 * hackagebot shelly 0.14.2.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.14.2.3 (GregWeber)
03:10:46 <shachaf> Half this library is made up of unsafeCoerces with particular types now.
03:11:36 <startling> there should be an unsafe-lens
03:12:02 <startling> it'd be just like lens, but %~. would fail every once in a while with a cryptic error message.
03:12:12 <xwit> Whats that other editor that sint emacs?
03:12:21 <shachaf> You mean at runtime instead of compiletime?
03:12:21 <startling> vim?
03:12:24 <xwit> y
03:12:26 <xwit> ty
03:12:28 <startling> shachaf: precisely
03:12:52 <startling> shachaf: failing nondeterministically at compile-time is also acceptable.
03:19:24 <Raynes> HTTP doesn't support https? :(
03:20:59 <Raynes> I just wrote half a library based on HTTP, assuming it would work with https. It's both wonderful and terrible. Wonderful because I was able to write half a library without really testing anything because the fact that it compiled made it likely that it worked, terrible because darn it.
03:21:24 <startling> Raynes, pull request?
03:21:51 <Raynes> I don't think so.
03:22:06 <Raynes> I think http-conduit supports https. Can probably use it without much more work.
03:22:18 <startling> but yeah, that's pretty odd.
03:22:36 <Raynes> Hey, it's called HTTP, not HTTPS. I should have known. :P
03:23:57 <neutrino_> Raynes: you normally want to do your ssl endpoint in a standalone server anyways.
03:24:04 <Inst> my three concerns are becoming a better programmer (i don't program), programming efficiently, and having code that runs quickly
03:24:08 <Inst> why haskell over lisp?
03:24:13 <arcatan> Raynes: ugh, been there, done that, switched to http-enumerator
03:24:15 <Inst> is lisp haskell blub?
03:24:16 <shachaf> Inst: See the FAQ.
03:24:18 <shachaf> @where faq
03:24:19 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:24:24 <ivanm> I'm thinking of writing a library which wraps around Map, Vector, etc. in the sense of "I want to add a value to a lookup table, so find the next available spot and give me back the key"
03:24:27 <Raynes> neutrino_: I don't follow
03:24:36 <ivanm> what would be a good name for a library/class that does that?
03:24:55 <shachaf> I'm not sure there is a good name.
03:25:07 <shachaf> Is it a good class?
03:25:15 <neutrino_> Raynes: do you want to have a service which accepts https connections, or which connects to an https server?
03:25:16 <ivanm> heh
03:25:26 <neutrino_> ivanm: packrat
03:25:41 <startling> ivanm, lost keys
03:25:41 <Raynes> neutrino_: I'm writing a library for working with a website's API.
03:25:43 <shachaf> @hackage HTTP -- neutrino_
03:25:43 <lambdabot> http://hackage.haskell.org/package/HTTP -- neutrino_
03:25:57 <djcoin> What is the best way to browse haskell sources ? Get the sources somewhere and browse it with an editor ? Is there a website providing searching functionnality etc. for browsing the source ?
03:25:59 <ivanm> shachaf: well, I'm thinking about re-writing planar-graph to use Vector rather than Map, since in my Haskell vs C benchmark it was abysmally slow... and figured the behaviour could be abstracted away
03:25:59 <neutrino_> Raynes: oh. sorry, i was thinking of the other way around.
03:26:06 <Raynes> No worries.
03:26:11 <merijn> Is there a Parsec function "Parser a -> String -> Maybe a" or something? I can't seem to locate one in the Haddock pages
03:26:15 <ivanm> djcoin: hackage
03:26:36 <ivanm> djcoin: hackage has documentation for projects (if it builds) linked up source for them
03:26:37 <djcoin> ivanm: ok, thanks
03:26:53 <neutrino_> djcoin: i prefer to do "cabal unpack"
03:27:03 <ivanm> djcoin: hoogle and hayoo are two different haskell search engines (hoogle gives better results IMHO, but hayoo searches more packages by default)
03:27:17 <ivanm> merijn: you could probably write one based upon running the parser
03:27:19 <Raynes> arcatan: Looks like http-conduit is the successor to that, so I think I'm on the right track.
03:27:25 <parcs`> merijn: runParser
03:27:31 <bxc> are there interesting categories in haskell that aren't arrows?
03:27:35 <ClaudiusMaximus> merijn: runParser gives Either ParseError a, so   either (const Nothing) Just
03:27:38 <merijn> ivanm: Yeah, but I can't figure out which of the parser running functions I want
03:27:53 <ivanm> merijn: I think there's one that returns an Either
03:28:07 <ivanm> neutrino_: why packrat?
03:28:22 <ivanm> that's the name of a parser IIRC
03:28:28 <Eidel> I want do define a datatype which references to another data type. Is this possible?
03:28:30 <hpaste> Eidel pasted “Reference data type” at http://hpaste.org/77442
03:28:36 <djcoin> ivanm: neutrino_  btw I meant core of haskell itself, prelude library etc. (maybe I was not clear enought)
03:28:48 <ivanm> Eidel: sure: data IntOrFloat = MyInt Int | MyFloat Float
03:29:00 <ivanm> djcoin: oh, view the GHC docs
03:29:14 <ivanm> djcoin: hoogle indexes those as well as others
03:29:18 <neutrino_> ivanm: because it always finds a place to stuff something in.
03:29:24 <merijn> ivanm, ClaudiusMaximus: I think I just want the "parse" function
03:29:27 <ivanm> djcoin: the Prelude is part of base...
03:29:36 <shachaf> Eidel: data Integer' = Zero | Positive Digit | Negative Digit
03:29:41 <ivanm> neutrino_: yeah, I think it has too many connotations with parsing though... thanks anyway
03:29:43 <shachaf> Except Digit is normally called Nat. :-)
03:29:44 <startling> djcoin: http://hackage.haskell.org/package/base
03:29:46 <ClaudiusMaximus> Eidel: your Zero | Digit | Minus Digit   defines a constructor with no arguments called Digit
03:29:58 <neutrino_> ivanm: yw
03:30:10 <shachaf> Also, er, that won't work.
03:30:13 <shachaf> You have two Zeros.
03:30:13 <startling> djcoin, browse the modules + there's a "source" link at the upper-right
03:30:49 <startling> he has three Zeros! Positive Zero, Negative Zero, and Zero
03:31:05 <Eidel> Haha
03:31:21 <Eidel> Ok, i got some hints now :)
03:31:24 <startling> Eidel, maybe leave 0 out of your Digit.
03:31:32 <djcoin> startling: thanks
03:31:38 <startling> then Zero can be only for Integer
03:31:43 <shachaf> startling: That doesn't sound right.
03:31:51 <shachaf> data Digit = Succ Digit?
03:32:00 <parcs`> maybe Eidel is taking limits
03:32:01 <Eidel> startling: Yes, i think i solved it
03:32:06 <startling> shachaf: heh. I mean data Digit = One | Succ Digit
03:32:14 <shachaf> I mean, that *is* actually an accurate Nat, given ⊥s...
03:32:19 <shachaf> But that's not much good.
03:32:22 <neutrino_> ivanm: portable hole
03:32:22 <Eidel> data Digit = Digit | Succ Digit
03:32:29 <shachaf> What?
03:32:52 <ivanm> neutrino_: yeah, I'd prefer a more technical name rather than a cute-sy one
03:32:52 <neutrino_> (works especially well if you use holes to implement it)
03:33:00 <neutrino_> oh, ok.
03:33:21 <cebewee> Is there are neat way to lift if-then-else the functions (or arrows)? I.e., I'd like to extract the x from "if b x then e1 x else e2 x"
03:33:24 <neutrino_> ("portable hole" has fairly geeky rpg background but i know what you mean)
03:33:27 <ivanm> then again, "keyless entry" has a nice ring to it, and matches the behaviour :p
03:33:32 <neutrino_> yeah
03:33:43 <Eidel> Thanks for your help :) Going to class.
03:34:06 <startling> cebewee: how do you mean?
03:34:17 <startling> cebewee: you can do (if b x then e1 else e2) x
03:34:37 <startling> @src if'
03:34:37 <cebewee> startling: i'd like to get it out of the condition as well
03:34:37 <lambdabot> Source not found. That's something I cannot allow to happen.
03:34:52 <startling> cebewee, that doesn't work in general though
03:35:07 <startling> since presumably b is X -> Bool while e1 is X -> SomethingElse
03:36:23 <startling> :t \b e1 e2 x -> if b x then e1 x else e2 x
03:36:25 <lambdabot> (t1 -> Bool) -> (t1 -> t) -> (t1 -> t) -> t1 -> t
03:36:32 <startling> ^ or just stick that in a where clause.
03:38:08 <shachaf> @pl if b x then e1 x else e2 x
03:38:08 <lambdabot> if' (b x) (e1 x) (e2 x)
03:38:11 <shachaf> If you have if' :-)
03:38:16 <shachaf> @pl \x -> if b x then e1 x else e2 x
03:38:16 <lambdabot> ap (liftM2 if' b e1) e2
03:38:54 <startling> shachaf: oh, I though if' got lost in the upgrade or something
03:39:05 <shachaf> if' was never there in the first place.
03:39:13 <startling> since <startling> @src if' got nothing
03:39:16 <startling> shachaf: oh?
03:39:24 <shachaf> if' is a lie.
03:39:34 <shachaf> If it existed it would be if' b x y = if b then x else y
03:39:59 <startling> sure. I assumed defined somewhere in lambdabot, though. weird that it's not.
03:40:00 * hackagebot lvmlib 1.0 - The Lazy Virtual Machine (LVM).  http://hackage.haskell.org/package/lvmlib-1.0 (JurriaanHage)
03:40:11 <shachaf> pl is independent of lambdabot
03:40:16 <startling> ah.
03:41:57 <cebewee> ok, I can of course do this.
03:42:55 <cebewee> I thought I got could maybe implement this with Arrows (as there is ArrowChoice, which seems to do what I want, except that I'm missing a way to function to inject a boolean function into Either ...)
03:43:27 <cebewee> oh, I'll have to leave for a while
03:43:29 <startling> cebewee: I think you're overengineering
03:47:16 <shachaf> If an optimization changes semantics but no one manages to demonstrate it, is it still unsound?
03:47:45 <startling> haha
03:48:33 <Inst> what's the advantages of learning haskell after lisp?
03:49:34 <Raynes> Pretty mind blowing type system.
03:49:44 <ivanm> with Vectors, is there any way of shifting the keys? or optionally, replacing a slice of one vector with a slice of another?
03:49:56 <Iceland_jack> I wouldn't call Haskell's type system mind-blowing
03:50:00 * hackagebot hat 2.7.0.7 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.7 (OlafChitil)
03:50:52 <ivanm> wanting something equivalent to doing a M.mapMonotonic to shift the keys of one Map up, and then a M.union (with the shifted graph being the second argument)
03:51:09 <Raynes> Iceland_jack: To whom?
03:52:10 <ClaudiusMaximus> @hoogle Vector e -> Vector e -> Vector e
03:52:10 <lambdabot> Warning: Unknown type Vector
03:52:10 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
03:52:10 <lambdabot> Language.Haskell.TH.Syntax qRecover :: Quasi m => m a -> m a -> m a
03:52:17 <ivanm> I know there's ++
03:52:21 <Iceland_jack> As type systems go it's pretty mild
03:52:25 <Iceland_jack> which is a good thing imo
03:52:28 <ClaudiusMaximus> ivanm: that's what i was looking for..
03:52:51 <ivanm> but I was hoping to be able to say "here's an initial Vector of the correct size already, just shove the second one into the empty space in the first one"
03:53:10 <ivanm> Iceland_jack: what kind of type system do _you_ consider mind-blowing then?
03:53:26 <LAMMJohnson> Hey there, all.
03:53:39 * ivanm waves idly in LAMMJohnson's general direction
03:53:44 <LAMMJohnson> Sorry for the flyby question, but is there any way to wrap an enum in Haskell?
03:53:44 <Iceland_jack> Most systems with dependent types are pretty amazing
03:53:53 <ivanm> LAMMJohnson: what do you mean?
03:53:56 <Iceland_jack> I'm also partial to substructural type systems but I'm in the minority there
03:54:06 <ivanm> Iceland_jack: but compared to say Java's type system, Haskell's is still rather "meh"?
03:54:08 <LAMMJohnson> Sorry, terribly unclear. As in have it repeat without having to make my own infinite list?
03:54:22 <Iceland_jack> ivanm: I don't believe I said that
03:54:27 <ivanm> LAMMJohnson: can you provide an example?
03:54:32 <LAMMJohnson> Sure. 1 sec.
03:54:33 <ivanm> Iceland_jack: fine, s/meh/mild/
03:54:42 <LAMMJohnson> data Note = A | Ash | B | C | Csh | D | Dsh | E | F | Fsh | G | Gsh
03:54:45 <Peaker> hey, how do I hide my package (EitherT) so people know to use the "either" package?
03:54:50 <Iceland_jack> You've completely misunderstood what I said
03:54:52 <LAMMJohnson> succ Gsh returning A
03:55:03 <ivanm> Peaker: on hackage? I believe you need to email Ross
03:55:17 <ivanm> Iceland_jack: care to explain it then?
03:55:21 <ClaudiusMaximus> LAMMJohnson: cycle [minBound .. maxBound] - note that succ maxBound should be an error...
03:55:30 <ivanm> LAMMJohnson: ahhh, you can't really with Enum
03:55:38 <Peaker> ivan, oh, weird
03:55:48 <fmap> Peaker: you can use Tekmo's approach: http://hackage.haskell.org/package/transformers-free
03:55:50 <LAMMJohnson> Thanks, ClaudiusMaximus & ivanm.
03:55:55 <ClaudiusMaximus> LAMMJohnson: ..which is a bit annoying, Enum is weird like that (exists only for [..] syntax)
03:55:58 <Iceland_jack> Sure: Type systems like Java's aren't all too useful, ML/Haskell/'Caml's are
03:56:12 <LAMMJohnson> The main problem being I was going to use it in a foldr and feeding in an unnecessary list is makign things messy.
03:56:16 <ivanm> Peaker: also use DEPRECATE pragmas, etc. if you want to be specific about it; Hacakge is also meant to serve as a repository of Haskell code (to show how we've "grown", etc.)
03:56:21 <Iceland_jack> They do what you'd expect them to, and that's a good thing
03:56:54 <Iceland_jack> Nothing about that is “meh” or “mild” or what ever meaning you tried to convey
03:56:59 <ivanm> Iceland_jack: but if someone is only used to Java's type system, and then get demonstrated Haskell's, you don't think it'd be mind-blowing?
03:57:22 <Iceland_jack> That question is too general, I can't answer it
03:58:23 <startling> it's mindblowing in that how it works how you think it should and doesn't get in the way.
03:58:28 <fmap> but for nice red color you still need to email Ross I guess
03:58:31 <Iceland_jack> startling: Exactly
03:58:33 <ivanm> Iceland_jack: in the overall scale of type system's, Haskell's might be mild in comparison to some; but I think Raynes' point was that for someone used to much lower type systems, Haskell's would indeed by mind-blowing (in wtf-ness if nothing else :p)
03:58:50 <ivanm> fmap: also to get it hidden from the hackage list
03:58:55 <Iceland_jack> I think startling captures my belief fairly well
03:59:19 <ivanm> ClaudiusMaximus: hmmm, maybe update would do what I want, in conjunction with indexed + fmap
03:59:22 <startling> clumsy languages seem to have given types a bad name. :(
03:59:34 <Peaker> ivanm, I guess I can keep it. At least it helped formulate a joke on the HWN :)
03:59:45 <ivanm> heh
04:02:07 <ivanm> am I looking wrong, or is there no way of doing an O(1) update of a single value in Vector? the closest I can find is to use // with a singleton list, which is still O(n) on the length of the Vector :s
04:02:13 <hpc> startling: it's okay though, because clumsy programmers give lack-of-types a bad name too
04:02:42 <shachaf> ivanm: Mutable or immutable vector?
04:02:43 <hpc> ivanm: an immutable vector needs to be copied when you modify a value, if that's what you mean
04:02:55 <ivanm> immutable
04:02:55 <startling> hpc: heh
04:03:04 <ivanm> oh, duh, right
04:03:06 * ivanm facepalms
04:03:13 <hpc> ;)
04:05:26 <osa1> does anyone here know Text.PrettyPrinter ? I don't understand how `nest` works
04:05:58 <ivanm> osa1: I don't think it's something I ever used
04:06:17 <hpc> osa1: it's just indentation
04:06:21 <ivanm> oh, yeah, right
04:06:25 <ivanm> was thinking of a different function
04:06:29 <osa1> hpc: it somehow indents more than I passed it
04:07:00 <ivanm> > text "hi" $+$ nest 3 (text "a" $+$ text "b")
04:07:02 <lambdabot>   hi
04:07:02 <lambdabot>     a
04:07:02 <lambdabot>     b
04:07:06 <osa1> also, nest (-4) dedents just 1 character. strange
04:07:20 <ivanm> osa1: ^^ (note that lambdabot indents the first line by one character
04:07:36 <ivanm> hmmm.... I wonder
04:07:40 <osa1> ivanm: seems like nest 3 indents 2 characters
04:07:46 <ivanm> > nest (-1) (text "hi") $+$ nest 3 (text "a" $+$ text "b")
04:07:47 <lambdabot>   hi
04:07:47 <lambdabot>     a
04:07:47 <lambdabot>     b
04:07:50 <ivanm> didn't think so
04:08:03 <ivanm> osa1: no, 3; as I said, lambdabot indents the first line by a space
04:08:05 <hpc> > text "hi" $+$ nest 1 (text "a" $+$ text "b")
04:08:07 <lambdabot>   hi
04:08:07 <lambdabot>   a
04:08:07 <lambdabot>   b
04:08:14 <ivanm> > text "ignore this line" $+$  (text "hi") $+$ nest 3 (text "a" $+$ text "b")
04:08:16 <lambdabot>   ignore this line
04:08:16 <lambdabot>  hi
04:08:16 <lambdabot>     a
04:08:16 <lambdabot>     b
04:08:18 <hpc> > text "hi" $+$ nest 0 (text "a" $+$ text "b")
04:08:19 <lambdabot>   hi
04:08:19 <lambdabot>  a
04:08:20 <lambdabot>  b
04:08:22 <hpc> AHA!
04:08:28 <ivanm> osa1: ^^
04:08:31 <hpc> it's working correctly, lambdabot is just majorly derp
04:08:37 <osa1> heh
04:08:41 <ivanm> notice that "ignore this line" is indented by one space compared to "hi"
04:08:50 <ivanm> I believe that's to prevent people doing something like this:
04:08:58 <ivanm> > text "> print 3"
04:08:59 <lambdabot>   > print 3
04:09:03 <osa1> hahaha
04:09:06 <ivanm> (and thus getting lambdabot into loops)
04:09:28 <ClaudiusMaximus> ivanm: fwiw, i did some stuff with hand-rolled graph thing - using a Map for the initial construction then compacting to Vector for the main "do lots of lookups" code https://gitorious.org/maximus/graphgrow/blobs/master/Fractal/GraphGrow/Engine/Graph.hs
04:09:31 <hpc> lambdabot doesn't respond to its own input
04:09:37 <hpc> it's to prevent this:
04:09:54 <hpc> > text "preflex: echo > text \"...
04:09:56 <lambdabot>   <hint>:1:33:
04:09:56 <lambdabot>      lexical error in string/character literal at end of input
04:10:06 <osa1> > render (nest 4 empty $+$ nest (-4) (text "ok"))
04:10:08 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
04:10:08 <lambdabot>              w...
04:10:22 <osa1> w... ?
04:10:37 <ivanm> @type render
04:10:38 <lambdabot> Doc -> String
04:10:39 <osa1> nest 4 empty $+$ nest (-4) (text "ok")
04:10:43 <osa1> > nest 4 empty $+$ nest (-4) (text "ok")
04:10:44 <lambdabot>   Couldn't match expected type `Text.PrettyPrint.HughesPJ.Doc'
04:10:45 <lambdabot>              w...
04:10:50 <ivanm> @type empty
04:10:51 <lambdabot> Alternative f => f a
04:10:54 <hpc> :t ($+$)
04:10:55 <lambdabot> Doc -> Doc -> Doc
04:10:57 <ivanm> yeah, there's the culprit
04:11:03 <ivanm> osa1: use something other than empty
04:11:06 <osa1> > nest 4 (text "") $+$ nest (-4) (text "ok")
04:11:08 <lambdabot>  ok
04:11:20 <xwit> whats that window manager coded in haskell?
04:11:24 <hpc> xmonad
04:11:26 <ivanm> xmonad is the main one
04:11:30 <ivanm> there's at least one other
04:11:34 <xwit> is it apt-gettable in most distros+
04:11:35 <hpc> o.O
04:11:53 <hpc> should be
04:11:58 <xwit> and it just lets you handle your shell,firefox etc in some way you like?
04:12:04 <xwit> size?
04:12:09 <ivanm> xwit: you'll probably also want xmonad-contrib
04:12:16 <hpc> just beware: the default settings for xmonad look like ass
04:12:27 <xwit> what does it do?
04:12:28 <hpc> which is to say, there are no default settings
04:12:32 <ClaudiusMaximus> hpc: central split?
04:12:36 <ocharles> If I want to get my feet wet with functional reactive programming, should I grab reactive, netwire or reactive-banana?
04:12:37 <hpc> and it's just what X decides to do
04:12:48 <ocharles> I don't need to do GUI programming or anything, just a console app
04:12:51 <ivanm> hpc: sure there are default settings
04:12:54 <hpc> ClaudiusMaximus: the silly 1993-style window decoration ;)
04:12:58 <yitz> xwit: usually apt-getable or whatever. but since you need haskell installed anyway, you might be better off getting it via cabal install for a more recent version.
04:12:58 <lambdabot> yitz: You have 1 new message. '/msg lambdabot @messages' to read it.
04:13:00 <ocharles> reactive-banana and netwire seem to be the most active
04:13:14 <ivanm> banana has inbuilt GUI bindings as well
04:13:23 <yitz> xwit: except of course that then you'll have to manage xmonad itself manually with cabal install.
04:13:26 <ocharles> sure, but that's irrelevent for me right now :)
04:13:36 <fmap> hpc: xmonad has window decoration?
04:13:46 <osa1> > hang 4 (text "first") (text "second")
04:13:48 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
04:13:48 <lambdabot>              with actual type ...
04:14:01 <osa1> :t hang
04:14:03 <lambdabot> Doc -> Int -> Doc -> Doc
04:14:17 <osa1> hmm is this latest verions of Text.PrettyPrint
04:14:23 <osa1> > hang (text "first") 4 (text "second")
04:14:24 <lambdabot>   first second
04:14:25 <ivanm> osa1: maybe you should either a) privmsg lambdabot, or b) explore this on your own computer? ;-)
04:14:44 <osa1> right, sorry
04:14:48 <ivanm> and the pretty package hasn't changed in years, so I would think this is the latest version that lambdabot is using :)
04:17:24 <xwit> anyone know a really tiny apt-get-package?
04:17:39 <ivanm> as in a small package available via apt-get ?
04:17:49 <ivanm> or a really tiny implementation of apt-get?
04:18:01 <ivanm> either way, wouldn't #debian or something be a better choice? :p
04:18:41 <ivanm> ClaudiusMaximus: yeah, I keep manipulating my graphs throughout, rather than wanting to do lookups down the track
04:18:44 <ivanm> thanks anyway though
04:26:21 <ClaudiusMaximus> @hoogle (a -> a -> Bool) -> (a -> a -> a) -> [a] -> [a]
04:26:21 <lambdabot> No results found
04:26:58 <ClaudiusMaximus> nothing on hayoo either...
04:27:21 <ivanm> what's that meant to do?
04:27:21 <mkaito> hey folks, what's an appropiate way to express something like: map hPutStrLn . parseStuff . hGetLine
04:28:34 <ClaudiusMaximus> would anyone other than me find a library for that useful?  (closure eq op seed = ...)
04:28:40 <yitz> hey, preflex isn't around. what's up?
04:28:48 <ivanm> yitz: ask mauke
04:28:54 <ivanm> who's not around either :p
04:28:59 <yitz> mmm
04:29:02 <Jafet> :t mapM_ (hPutStrLn ?h) . ?parseStuff =<< hGetLine ?h
04:29:04 <lambdabot>     Not in scope: `hPutStrLn'
04:29:04 <lambdabot>     Perhaps you meant one of these:
04:29:04 <lambdabot>       `BS.hPutStrLn' (imported from Data.ByteString),
04:29:16 <Jafet> :t mapM_ putStrLn . ?parseStuff =<< getLine
04:29:18 <lambdabot> (?parseStuff::String -> [String]) => IO ()
04:29:25 <Jafet> @seen preflex
04:29:26 <lambdabot> Unknown command, try @list
04:29:31 <yitz> i'll bet that means pastes aren't being copied to hpaste anymore either. :(
04:30:02 <mkaito> thanks Jafet
04:30:29 <yitz> Jafet: lambdabot stopped doing @seen a long time ago, due to a memory leak. we were using preflex for that. :(
04:31:03 <ivanm> yitz: /msg nickserv info <foo>
04:31:37 <shachaf> yitz: When mauke is around pastes are still copied to hpaste.
04:31:53 <ClaudiusMaximus> ivanm: closure of an operation with an equality predicate, i used it in one project to compute the full symmetry group from an initial list of reflections
04:32:00 <shachaf> yitz: If I remember correctly he had a hard disk crash or some other sort of data loss. Since then he and preflex have been online intermittently if at all.
04:32:12 <yitz> i see.
04:32:14 <ClaudiusMaximus> ivanm: using approximate equality for matrices due to floating point crapness
04:32:38 <yitz> looks like mauke *is* around, just not this moment. whereas preflex has been gone for a few weeks.
04:32:59 <shachaf> Yes.
04:33:14 <shachaf> But preflex did come back at some point after the Event.
04:33:29 <shachaf> yitz: When you write Lambdabot 2.0, you can add a non-leaky @seen!
04:33:30 <yitz> ok i guess we'll all just wish preflex a speedy recovery
04:33:47 <yitz> shachaf: right that solution would be even better ;)
04:34:02 <ivanm> ClaudiusMaximus: yeah, but I don't see how you're getting the second `a', unless you're comparing subsequent elements
04:34:45 <shachaf> yitz: I mean you personally. It's on your plate now.
04:34:57 <ClaudiusMaximus> ivanm: https://gitorious.org/polytopiary/reflex/blobs/master/Polychoron.hs#line86
04:38:08 <bartavelle> I have a question about hint. Let's say I have a .hs file, and I know a the name and type of a function in it. How do I call it ?
04:38:16 <bartavelle> it doesn't seems like I should use loadModule
04:38:20 <bartavelle> as it is not a module
04:54:51 <bartavelle> this doesn't seem possible at all
04:54:53 <bartavelle> crap
04:55:04 <cornihilio> if I wanted to work on something like this: http://hackage.haskell.org/trac/hackage/ticket/781 what files should I be looking at in cabal? Right now I'm looking at Command.hs in Distribution/Simple
04:57:28 <ivanm> cornihilio: the tracker is now on github
04:57:36 <ivanm> so check there first :)
05:01:08 <cornihilio> ivanm: ah, thank you for pointing that out! would you recommend any specific 'label' for a beginner?
05:01:26 <ivanm> nope, I just use Cabal and file bug reports when I find something wrong :p
05:01:41 <ivanm> try asking dcoutts when he comes online
05:01:44 <dcoutts> cornihilio: you'll want to look at two modules in cabal-install,
05:01:51 <ivanm> speak of the devil... ;-)
05:01:55 * ivanm waves at dcoutts 
05:02:02 * dcoutts grins
05:02:25 <ivanm> dcoutts: do you have notifications set up for Cabal or something?
05:02:57 <cornihilio> dcoutts: which modules?
05:03:01 <ivanm> though I can imagine that would be rather noisy, what with all the suggestions to do "cabal install <foo>", etc.
05:03:01 <dcoutts> cornihilio: cabal-install/Distribution/Client/Setup.hs for the command line parsing, see the section in there on list command & ListFlags etc
05:03:10 <ivanm> anyway, time I hit the sack
05:03:11 <ivanm> g'night all
05:03:28 <dcoutts> cornihilio: and for the module where it actually does stuff: cabal-install/Distribution/Client/List.hs
05:03:55 <osa1> can anyone give an example of how Text.PrettyPrint.hang works ?
05:04:33 <ivanm> > hang (text "hi") 5 (text "bye")
05:04:35 <lambdabot>   hi bye
05:04:57 <ivanm> > hang (text "hihihihihihihihihihihihihihihihih") 5 (text "bye")
05:04:59 <lambdabot>   hihihihihihihihihihihihihihihihih bye
05:05:08 <ivanm> OK, it's acting like <+>
05:05:27 <ivanm> > hang (text "hi") 5 (text "1" $+$ text "bye")
05:05:29 <lambdabot>   hi   1
05:05:29 <lambdabot>       bye
05:05:33 <ivanm> aha!
05:05:35 <ivanm> osa1: ^^
05:05:53 <cornihilio> dcoutts: would you recommend any specific issue for me to fix? I can't seem to find the equivalent issue from the trac tracker in the github one.
05:06:01 <cornihilio> attempt to fix*
05:06:06 <ivanm> dammit, I seem to have separately duplicated something to do just that in my own code... oh well :)
05:06:09 <dcoutts> cornihilio: oh they should all be there, they got imported
05:06:09 * ivanm really goes to bed now
05:06:31 <dcoutts> cornihilio: the extra features for cabal list would be a nice one
05:06:40 <dcoutts> cornihilio: and fairly self-contained
05:06:47 <osa1> ivanm: I'm looking for a function like nest but after creating the doc, $+$ returns nesting to the level it was before like
05:06:56 <cornihilio> ah found it
05:07:14 <cornihilio> thanks for pointing me at what files to look at!
05:11:59 <pordan30> is there any way to model negation as failure using type classes, for example, in order to fall through to a default case if instance resolution fails under a specified set of conditions?
05:12:32 <shachaf> Not really.
05:13:24 <Saizan> instance resolution is committed-choice
05:13:59 <pordan30> shachaf: that's too bad
05:15:21 <pordan30> saizan: why would that conflict with a negation operator interpreted as failure to resolve?
05:15:52 <Saizan> it conflicts with the "fall-through" part
05:16:03 <Anchakor> can someone explain what is this function supposed to do? h1 = (.(,)) . (.) . (,)
05:16:14 <shachaf> Confuse newcomers.
05:16:26 <shachaf> @unpl h1 = (.(,)) . (.) . (,)
05:16:27 <lambdabot> h1 g m d = ((,)) g (((,)) m d)
05:16:47 <shachaf> h1 x y z = (x, (y, z))
05:17:02 <shachaf> @type (.(,)) . (.) . (,) -- a good way to figure these things out
05:17:04 <lambdabot> a1 -> a -> b -> (a1, (a, b))
05:17:12 <Anchakor> huh so uncurry
05:17:35 <Anchakor> can I do that @type thing in ghci?
05:17:40 <bartavelle> :t
05:17:58 <shachaf> That's not quite uncurry. :-)
05:18:03 <bartavelle> :t (.(,)) . (.) . (,)
05:18:05 <lambdabot> a1 -> a -> b -> (a1, (a, b))
05:18:07 <shachaf> Yes, :t. It's the most useful ghci command.
05:18:51 <Anchakor> ah thanks
05:18:55 <pordan30> saizan: understood. by fall through, i didn't mean backtrack. that was an unfortunate choice of words. i meant being able to write something in pseudo-prolog like: instance \T a b => S a b where ... I see that the general consensus is that this isn't possible, however.
05:19:04 <bartavelle> I like :r too
05:20:31 <Anchakor> strange thing is I though . was defined only for unary functions
05:21:07 <shachaf> It is.
05:21:10 <bartavelle> you can see all functions as unary, so it works
05:21:57 <pordan30> well f . g = \x -> f (g x) for f g unary functions, but that doesn't mean that the codomain of f and g aren't functions, hence obscure lambdabot output
05:22:26 <Anchakor> so if i were to decypher (.(,)) . (.) . (,) myself, how would I go about it?
05:22:35 <shachaf> Evaluate it like a computer.
05:22:45 <shachaf> ((.(,)) . (.) . (,)) a b c
05:22:53 <shachaf> ((.(,)) . ((.) . (,))) a b c
05:23:08 <shachaf> (.(,)) (((.) . (,)) a) b c
05:23:14 <shachaf> Etc.
05:23:17 <shachaf> One step at a time. :-)
05:24:09 <Anchakor> I guess I am confused in the direction associativeness of operators
05:24:25 <pordan30> composition is right associative
05:24:38 <Anchakor> ok thanks
05:24:55 <Anchakor> I think I can work that out now
05:25:37 <int-e> (for composition it doesn't really matter - it is an associative operation)
05:29:05 <zed> Hi
05:30:18 <Guest9463> Can anybody please tell me about Haskell, and how can it be used by a person with experiance in ruby, python and go.
05:30:35 <zomg> You can use it by learning it
05:30:39 <bartavelle> Guest9463, it can be used by learning Haskell
05:31:04 <Guest9463> But what kind of problems are best solved by haskell?
05:31:16 <qnikst> can somebody help me with conduits? I'm having problem when I'm trying to run another pipeline in sink
05:31:27 <hiptobecubic> Guest9463, what kind of problems are best solved by programming?
05:31:33 <Guest9463> I have no experiance in functional programming...
05:32:04 <Guest9463> Hey don't be too harsh on me, I am a newbie
05:32:17 <zomg> Guest9463: any kind of problem
05:32:44 <Guest9463> Ok, is it being used in production?
05:32:45 <fmap> well, any decidable problem
05:32:48 <Botje> Guest9463: if you're asking us 'should I learn Haskell?', the answer is 'you will learn new things, even about the languages you thought you knew'
05:33:21 <zomg> Guest9463: yes it is
05:33:35 <Guest9463> Somebody today recommended me to check out Haskell, and I dropped in.
05:33:39 <zomg> Almost all programming languages are used in production, with the exception of esolangs =)
05:33:58 <zomg> Guest9463: if you haven't used functional languages before I can assure learning haskell will be interesting and fun and you will learn new things
05:34:17 <zomg> Be aware that there is a learning curve though
05:34:22 <pordan30> Guest9463: for starters: programs like compilers, parsers, problems like semantic analysis, and so forth, are traditional applications for showing off functional languages; in general, algorithms over recursive data structures.
05:34:23 <Botje> zomg: somewhere a mission-critical system is running on Piet.
05:34:38 <hiptobecubic> i hope so
05:35:06 <zomg> Botje: Yeah it would be funny if there was a museum using it, and all the paintings in it would just be the programs they use
05:35:25 <zomg> s/museum/art gallery
05:35:43 <Guest9463> My comrade recommended me to learn a functional language like haskell or erlang, and I dropped in here to have some fun with functional programming.
05:35:59 <strg> then do it :)
05:36:02 <zomg> Guest9463: I build  web apps in haskell, though mostly just hobby projects at the moment
05:36:02 <Guest9463> So where should I start?
05:36:13 <mauke> what languages do you know?
05:36:32 <Guest9463> Mostly python
05:36:46 <strg> Guest9463: 'Learn you a Haskell for Great Good', 'Real World Haskell', '99 Problems in Haskell' .. all available for free on the net.
05:36:59 <Guest9463> hmm
05:37:29 <Guest9463> Thank you all....
05:37:42 <mauke> @where lyah
05:37:43 <lambdabot> http://www.learnyouahaskell.com/
05:37:59 <merijn> Guest9463: I think Erlang is cool, but I'd recommend learning Haskell instead because it is "more different" from python, therefore introducing you to more new concepts
05:38:06 <mauke> do you have ghc?
05:38:43 <merijn> Guest9463: For example, things haskell has but Erlang does not are laziness, static typing, typeclasses. Learning Erlang after Haskell should be fairly easy afterwards
05:39:23 <bartavelle> Piet ...
05:39:53 <bartavelle> this _is_ esoteric
05:40:08 <merijn> Botje: I'd laugh, if I wasn't afraid you were right
05:40:17 <mauke> bartavelle: have you seen Malbolge and Tamerlane?
05:40:40 <Guest9463> hey thanks, it looks like a good book
05:40:53 <Guest9463> I have heard about BrainFuck
05:41:34 <Guest9463> No I dont have GHC
05:41:46 <Guest9463> I have to install it
05:42:09 <Guest9463> And what about a good IDE or text editor for haskell
05:42:13 <Guest9463> ?
05:42:15 <qnikst> vi?
05:42:24 <zomg> qnikst: you mean vim? ;)
05:42:26 <merijn> Guest9463: There's Yi and Leksah, but most people just use vim or emacs
05:42:31 <qnikst> zomg: yes
05:42:47 <Iceland_jack> Guest9463: if you don't use vi/emacs/... start out with a simple text editor
05:42:52 <hiptobecubic> eclipsefp maybe? Never used it
05:43:06 <merijn> zomg: Looks like qnikst is one of those people who starts vim by running vi and is going to be so confused when they log into a BSD/solaris system where that actually starts vi rather than vim :p
05:43:09 <Iceland_jack> No reason to learn a complicated editor while learning Haskell
05:43:16 <bartavelle> mauke, I know of malbolge, but it's just like brainfuck, the only design rule was to make it unusable
05:43:32 <bartavelle> (one could argue it was the same for crack-like mangling rules)
05:43:55 <Botje> brainfuck is usable, malbolge is actively hostile.
05:43:59 <zomg> merijn: hehe =)
05:44:06 <Guest9463> hey, bye meet you after reading some book.
05:44:09 <merijn> Guest9463: Assuming you have a "decent" editor (i.e. one that supports generic auto-complete, auto-indent and syntax highlighting) I'd just use the one you're used to
05:44:19 <qnikst> merijn: i'm not confused but start to shrug about missing features
05:44:24 <Guest9463> *poof*
05:44:57 <mauke> I would curse a lot
05:44:58 <cornihilio> if I am messing around in cabal, how do I check that it compiles? I think I'm making it very difficult for myself
05:45:02 <mauke> I use the cursor keys heavily
05:45:09 <bartavelle> oh tamerline seems pretty horrible too
05:45:51 <merijn> cornihilio: Just run "cabal build" in the directory you're working?
05:46:00 <cornihilio> merijn: thanks!
05:46:20 <merijn> cornihilio: (You might need to "cabal configure" first, but it'll yell at you if you forget)
05:47:07 <cornihilio> okay I git cloned the cabal repo, but apparently there is no .cabal file?
05:47:26 <cornihilio> does cabal configure generate a .cabal file?
05:47:45 <int-e> Botje: also malbolge is a finite state machine ... but people have done amazing stuff with it. (most impressive, a 99 bottles of beer program that uses an actual loop)
05:47:58 <merijn> cornihilio: Oh, the cabal repo has to different packages
05:48:09 <merijn> cornihilio: Cabal (the library) and cabal-install (the cabal executable)
05:48:19 <merijn> cornihilio: You need to go into either directory and run it there
05:49:17 <cornihilio> merijn: ah, thanks for pointing that out!
05:49:31 <cornihilio> I was thinking I screwed up a basic git clone :P
05:49:48 <dcoutts_> cornihilio: start by doing: cd cabal-install; cabal install ../Cabal/; cabal configure; cabal build
05:50:17 <dcoutts_> cornihilio: ie we install the dev version of the Cabal lib, then configure and build cabal-install using that
05:50:21 <pordan30> is there a better way to do something like this: <http://hpaste.org/77444>. the goal is to take the transitive/reflexive closure of a suitably formed binary type class; at this point, i can't figure out the best way to write a decision procedure in type-class prolog to decide membership in the tr closure.
05:55:27 <cornihilio> when I run cabal configure I get Cabal >=1.17.0 && <1.18, so I guess I'm supposed to be using a more bleeding edge version. how would I go about that?
05:55:40 <bxc>  
06:01:00 <dcoutts_> cornihilio: that's what I meant about doing cabal install ../Cabal/
06:01:10 <dcoutts_> cornihilio: to install the dev version from the same repo
06:01:20 <dcoutts_> make sense?
06:02:12 <cornihilio> dcoutts_: what happens when I start messing around in ../Cabal/ then? how do I fix that?
06:02:38 <dcoutts_> cornihilio: you'll be messing about with cabal-install, not Cabal, so it's ok, you just need to install Cabal once
06:03:07 <dcoutts_> cornihilio: if you did need to change Cabal too, then you'd need to reinstall it before you can use the changes in cabal-install
06:03:30 <andcarl> ciao
06:03:42 <andcarl> !list
06:03:42 <monochrom> andcarl: http://hackage.haskell.org/packages/archive/pkg-list.html
06:03:49 <cornihilio> dcoutts_: ah, okay that makes sense. Thank you for explaining that!
06:19:27 <cornihilio> for this issue: https://github.com/haskell/cabal/issues/771 what is this flag "--with-compiler" supposed to specify?
06:21:09 <dcoutts_> cornihilio: which installed packages to look at
06:21:28 <dcoutts_> e.g. the ones for ghc-7.4.1 or 7.6.1, or whatever other compilers you might have installed
06:21:42 <dcoutts_> cornihilio: since the sets of installed packages are different for each compiler
06:22:10 <dcoutts_> if I say cabal info blah, then it should tell me if blah is installed for my default ghc, but if I say
06:22:32 <dcoutts_> cabal info blah --with-compiler ghc-7.6.1, then I should get the status for that one
06:23:59 <cornihilio> I thought this issue was only in regards to how cabal list --with-compiler ghc-7.6.1 would work, not something like cabal info
06:24:05 <cornihilio> or am I misunderstanding the scope?
06:24:24 <dcoutts_> cornihilio: oh cabal list and cabal info are very closely related
06:24:52 <cornihilio> oh okay
06:25:04 <dcoutts_> and they should be consistent with each other, their impls are in the same module
06:25:42 <cornihilio> I am using ghc-7.4.2, should I install 7.6.1 so I have more than one version of ghc to test with?
06:25:59 <cornihilio> I think it would be impossible to work on this with only one version of the compiler, correct?
06:44:29 <nand`> hmm; is there no way to write overlapping family instance declarations?
06:44:33 <nand`> I want to provide a ‘base case’
06:44:40 <nand`> and I don't know how else to do it
06:45:34 <rwbarton> you can just write them i think
06:45:39 <rwbarton> as long as they are consistent
06:45:59 <nand`> here's what I'm trying to do
06:46:17 <nand`> type instance (a :: Symbol) :==: (a :: Symbol) = True -- this works and only matches eg. "foo" :==: "foo"
06:46:27 <nand`> type instance (a :: Symbol) :==: (b :: Symbol) = False -- this does not
06:46:38 <rwbarton> yes those are not consistent :)
06:46:49 <rwbarton> i don't know of a way to do that sort of thing
06:46:53 <rwbarton> well
06:47:18 <nand`> I mean, I can just leave off the right one and live with the huge type unification error in the case of failure
06:47:25 <nand`> leave off the last one*
06:50:13 <pordan30> can you write something like: type instance (a :: Symbol) :=: (b :: Symbol) = IfT (EqSymbol a b) True False, where IfT True a b = a; IfT False a b = b; EqSymbol a b = ...?
06:50:30 <pordan30> err, a :=: b = EqSymbol, i guess
06:50:54 <nand`> huh
06:51:12 <rwbarton> i think maybe you can still do it with the weird overlapping instances/fundeps trick
06:51:16 <rwbarton> but ew
06:52:29 <nand`> I'm not sure what that's referring to, but I'd like to avoid delegating anything to type classes
06:53:46 <pordan30> this, i think: http://www.haskell.org/haskellwiki/GHC/AdvancedOverlap
06:54:21 <SideEffffECt> Hi
06:54:23 <SideEffffECt> is Int an instance of Monoid? according to my short research it seems like not?
06:54:25 <SideEffffECt> is that so? why it's not an instance of Monoid?
06:55:04 * hackagebot tftp 0.1 - A library for building tftp servers  http://hackage.haskell.org/package/tftp-0.1 (SvenHeyll)
06:55:04 <pordan30> there are lots of monoids over the integers, they are encoded using newtype wrappers
06:55:06 * hackagebot arx 0.2.0 - Archive execution tool.  http://hackage.haskell.org/package/arx-0.2.0 (JasonDusek)
06:55:06 <nand`> SideEffffECt: because there are multiple possible instances
06:55:08 * hackagebot sssp 1.1.0 - HTTP proxy for S3.  http://hackage.haskell.org/package/sssp-1.1.0 (JasonDusek)
06:55:31 <geekosaur> take a look at the Sum and Product monoids
06:55:43 <rampion> question from a package developer
06:56:17 <rampion> should the tests be installed when using 'cabal install'?
06:56:18 <SideEffffECt> nand`: thanks for answering, could you please explain that answer a bit more? :)
06:56:50 <rwbarton> SideEffffECt, well what do you expect mappend to be
06:57:04 <rampion> SideEffffECt: well, if you're doing 3 `mappend` 4, there's two simple interpretations
06:57:17 <rampion> mappend == (+) => 3 `mappend` 4 = 3 + 4 = 7
06:57:30 <rampion> mappend == (*) => 3 `mappend` 4 = 3 * 4 = 12
06:57:31 <nand`> SideEffffECt: so rather than fixing some arbitrary instance as default, they choose to provide newtype wrappers for them instead and have no default
06:57:43 <pordan30> SideEffffECt: there are several monoids over the integers. for starts, considers the monoids under the product and sum operators. suppose you wish to write instances for each. how is the type system going to decide which monoid you want? instead, you wrap the type of integers with a revealing constructor, say Product and Sum, then write instances for those.
06:59:17 <SideEffffECt> yes, wonderful, now I see
06:59:18 <SideEffffECt> thx guys
06:59:58 <pordan30> so to encode the monoid under summation, say, you first create a newtype Sum = Sum { unSum :: Integer } and an instance Monoid Sum where mempty = Sum 0; mappend (Sum x) (Sum y) = Sum (x + y). you can generalize the approach and parameterize the sum wrapper, like Data.Monoid does.
07:00:21 <pordan30> <http://www.haskell.org/ghc/docs/7.4.2/html/libraries/base/src/Data-Monoid.html>
07:00:30 <rampion> I have a user for my package complaining that the tests aren't included in "the tarball" (https://github.com/rampion/ReadArgs/issues/4), but I haven't a clue as to what the tarball is.
07:00:41 <parcs`> nand`: rwbarton is referring to class Eq a b (c :: Bool) | a b -> c; instance Eq a b False; instance (a ~ b) => Eq a b True
07:01:25 <rwbarton> I thought you had to do something more convoluted than that
07:01:26 <nand`> parcs`: yeah, but I can't bring that into a type family can I?
07:01:30 <rwbarton> but basically yeah
07:01:38 <rwbarton> hm
07:01:58 <rwbarton> not sure
07:02:02 <cornihilio> how should I be trying to structure this if I am going to be adding a few more flags?: https://gist.github.com/4039314
07:03:43 <pordan30> rwbarton: how does that compile? i was attempting to write similar instances for a class earlier, with ghc complaining that the dependencies conflict between the instance declarations. actually, trying to compile that just now, it says the same.
07:04:11 <parcs`> oh, sorry
07:04:24 <pordan30> err, parcs, not rwbarton
07:04:31 <parcs`> it's instance Equal a b False; instance Equal (c ~ True) => Equal a a c
07:05:07 <rwbarton> I still think it is a bug that this compiles, but GHC apparently differs
07:06:24 <pordan30> closed type families with top-to-bottom pattern matching for case discrimination would be really useful
07:06:59 <BrianHV> are there known techniques for implementing data structures that aren't strictly hierarchical? say, mostly hierarchical data that also needs annotations, with bidirectional links between the annotations and the main data
07:07:10 <rwbarton> or just a built-in type inequality predicate
07:07:48 <pordan30> or a "failure to resolve"
07:08:59 <parcs`> nope, still wrong -_- it's instance Equal a a True; instance (c ~ False) => Equal a b c
07:09:01 <cornihilio> ignore what I asked, that was the wrong code
07:09:04 <rampion> cornihilio: you could use a case statement with pattern guards
07:09:16 <cornihilio> rampion: but thank you :)!
07:09:23 <fmap> rampion: no
07:09:31 <fmap> there is --enable-tests for that
07:09:40 <rampion> yeah, that's what I thought
07:10:11 <parcs`> pordan30: there was a long thread about this, and the essential problem iirc is that you can't encode overlapping type families in system f
07:15:42 <pordan30> parcs`: interesting. however, i am under the impression that other combinators of extensions currently in use in ghc-haskell can't be encoded in system f.
07:16:28 <cornihilio> what is this pattern called (specifically the usage of "|" and a let with no "in"): https://gist.github.com/4039378
07:17:13 <geekosaur> cornihilio, that's a list comprehension
07:17:27 <beaky> hello
07:18:23 <geekosaur> [ expr | generator , filters ] (and the let is because list comps are very similar to monads [in fact, they are the list monad] and can use the in-less let from do notation)
07:18:33 <beaky> let f xs = if (null xs) then [] else foldl' min (head xs) xs : f (tail xs) in f [3..1]
07:18:36 <beaky> > let f xs = if (null xs) then [] else foldl' min (head xs) xs : f (tail xs) in f [3..1]
07:18:38 <pordan30> apparently it looks like overlapping type family instances are currently being worked on, and has actually been implemented: <http://hackage.haskell.org/trac/ghc/wiki/NewAxioms>
07:18:38 <lambdabot>   []
07:19:00 <pordan30> *have
07:20:49 <beaky> what is the different between Eq and Ord
07:20:53 <beaky> and which should I use?
07:21:42 <Mortchek> beaky, Eq gives you (==), Ord gives you (<=) and friends
07:21:56 <Mortchek> beaky, you should use whichever contains the operations you want
07:22:19 <pordan30> do you need an ordering or simply equality? Eq a defines the class of types over which equality is defined, where Ord a defines the class of types over which (<) is defined, with Ord requiring an instance of Eq.
07:22:23 <beaky> right
07:22:36 <beaky> so a sorting algorithm needs to operate on an ord class?
07:22:42 <Mortchek> Yes
07:22:44 <beaky> min [1..10]
07:22:48 <beaky> > min [1..10]
07:22:50 <lambdabot>   *Exception: show: No overloading for function
07:22:53 <beaky> :(
07:22:57 <eMBee> is it possible to build haskell-platform on linux from a binary ghc without installing ghc (but just unpacking it somewhere) and then tell haskell-platform configure where ghc is unpacked?
07:23:02 <beaky> > minElement [1..10]
07:23:03 <Mortchek> > minimum [1..10]
07:23:05 <lambdabot>   Not in scope: `minElement'
07:23:05 <lambdabot>   can't find file: L.hs
07:23:23 <pordan30> foldr1 min [1..10]
07:23:25 <cornihilio> it looks like going by this that packages for the 'user' are not installed in a prespecified place?: http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
07:23:30 <pordan30> > foldr1 min [1..10]
07:23:32 <lambdabot>   1
07:23:47 <beaky> http://ideone.com/tfQZqO why doesn't this work?
07:23:53 <beaky> :t foldr1
07:23:55 <lambdabot> (a -> a -> a) -> [a] -> a
07:24:25 <geekosaur> beaky, what are you doing with x?
07:24:30 <kooocasaisninini> hello?
07:24:31 <beaky> ah right
07:24:37 <rwbarton> > [5..1]
07:24:38 <lambdabot>   []
07:24:45 <beaky> > [5..1]
07:24:47 <lambdabot>   []
07:24:49 <beaky> ah
07:24:56 <kooocasaisninini> lolsies
07:25:09 <tsou> beaky: you are ignoring x
07:25:18 <__arch> > [5,4..1]
07:25:20 <lambdabot>   [5,4,3,2,1]
07:25:54 <merijn> eMBee: You can just dump the binary GHC install in a random directory, put it in your path and you're done
07:26:01 <beaky> http://ideone.com/lHi7dy why doesn't this work too? :(
07:26:49 <geekosaur> that one's because you never remove the minimum item from xs
07:27:03 <__arch> yes, every time you fold over it, the minimum is 1
07:27:17 <geekosaur> in the pathological case with the minimum at the end, that means you get the last element every time
07:27:30 <beaky> oops
07:28:51 <beaky> so I need to be 'swapping' the minimum element rather than simply consing it
07:29:03 <eMBee> merijn: you mean without running configure;make install?
07:29:49 <notdan> How can I write something like (Show a) => data T a = ...
07:30:05 <notdan> in Haskell?
07:30:16 <cornihilio> it looks like going by this that packages for the 'user' are not installed in a prespecified place?: http://www.haskell.org/haskellwiki/Cabal/How_to_install_a_Cabal_package
07:30:38 <merijn> eMBee: if you run "./configure --prefix=~/my/path" and then run make install everything will be installed relative to "~/my/path"
07:30:40 <notdan> I want to make sure that a has an instance of Show, so I can use 'show a' in my functions
07:31:02 <merijn> eMBee: Then you just add "~/my/path/bin" (or something obvious like that, you have to check) to your path and you're done
07:31:10 <pordan30> you can use -XDataTypeContexts
07:31:41 <merijn> notdan: Just use "show" in your functions and then your functions will enforce the constraint
07:31:45 <fmap> that's fairly useless extension
07:31:51 <mentus> hello dear haskellers
07:31:57 <merijn> notdan: Take a look at Data.Map for example
07:31:59 <mentus> i have one question
07:32:09 <notdan> merijn: hm, okay
07:32:14 <notdan> @hoogle Data.Map
07:32:15 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
07:32:15 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
07:32:15 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
07:32:20 <notdan> er
07:32:31 <beaky> is unfoldr an anamorphism?
07:32:38 <merijn> notdan: There's is no restriction that keys should be Ord, but all function inserting/removing keys require Ord instances. Thus it is technically impossible to create a Map that has non-Ord keys
07:32:52 <pordan30> ha - "-XDatatypeContexts is deprecated: It was widely considered a misfeature, and has been removed from the Haskell language." I guess not, then.
07:33:34 <fmap> -XDatatypeContexts still doesn't save from writing `Show a =>' in type signatures
07:33:37 <eMBee> merijn: ok, thanks
07:34:01 <mentus> i need to be able to pass to the main function data which won't change but must be accessible during the execution of the program
07:34:22 <mentus> i don't want to pass it all the way through the function calls
07:34:24 <pordan30> fmap: i thought it did, my mistake
07:34:33 <mentus> what is the haskell way to go around this ?
07:34:36 <mentus> state monad ?
07:34:47 <pordan30> reader monad?
07:34:48 <mentus> but the data won't change...
07:35:06 <merijn> mentus: Reader monad is for immutable "global" state
07:35:12 <mentus> ok
07:35:19 <mentus> thanks, i will take a look at it
07:35:23 <merijn> mentus: i.e. it's the state monad without put
07:35:32 <mentus> ok...
07:36:13 <mentus> i will take a look on it
07:36:19 <mentus> thanks for the prompt help
07:36:35 <mentus> i am getting to appreciate haskell more and more ;-)
07:36:35 <Cale> mentus: Honestly, I would recommend just trying it by explicit parameter passing first.
07:37:07 <fmap> merijn: that's interesting statement; are you sure State without put is semantically equivalent to Reader?
07:37:39 <Cale> fmap: Sure
07:38:46 <cornihilio> where are user packages usually installed to? is this configured in ~/.cabal or something?
07:38:54 <Cale> mentus: Actually, can we see the program that you're doing this to?
07:39:22 <merijn> fmap: Why wouldn't it be?
07:39:52 <mentus> Cale: yes sure
07:40:05 <mentus> how shall i show it ?
07:40:20 <Cale> @paste
07:40:20 <lambdabot> Haskell pastebin: http://hpaste.org/
07:41:02 <mentus> basically i am trying to translage this AI lisp program to haskell
07:41:13 <mentus> http://norvig.com/paip/gps1.lisp
07:41:28 <mentus> it's an interesting exercise for me in order to learn haskell
07:42:14 <hiptobecubic> looks nice yeah
07:42:17 <hpaste> mentus pasted “GPS try in haskell” at http://hpaste.org/77447
07:43:03 <mentus> it is nothing working yet
07:43:29 <hiptobecubic> why doens't shop-installs-battery remove car-needs-battery from the state?
07:44:09 <Cale> mentus: by the way, foldl (&&) True is equivalent to foldr (&&) True (which is more efficient) and which has the name  and  in the Prelude.
07:44:24 <mentus> Cale: thanks
07:45:17 <mentus> so the constant data i was refering to is "schoolOps"
07:45:26 <Cale> mentus: This does look like possibly a job for the state monad.
07:45:57 <mentus> yes by the way i could grasp how to model the problem of *state* with the State Monad
07:46:29 <djcoin> Is the state monad in Haskell base package ? I can't find it :s
07:46:53 <Cale> djcoin: It's in mtl
07:46:55 <quicksilver> no, it's not in the base package
07:46:57 <Cale> Control.Monad.State
07:47:15 <Cale> mentus: So your issue is how to deal with *ops*?
07:47:16 <quicksilver> in general I think it's normally better to solve things the first time with explicit state passing (and returning)
07:47:17 <Sculptor> hi!
07:47:28 <quicksilver> and then you can clearly see what the state monad does (and doesn't) do
07:47:48 <mentus> Cale: yes, *ops*
07:47:48 <djcoin> but I can't import Control.Monad.State, it does not found it :\
07:48:23 <Cale> Honestly, I'd just pass the list around as a parameter. It would make the program clearer and easier to test to begin with.
07:48:43 <mentus> Ok, thanks for the good hint
07:48:48 <mentus> i will start with explicit passing
07:49:01 <Eduard_Munteanu> djcoin: how did you install GHC? Did you get the Haskell Platform?
07:49:39 <djcoin> Eduard_Munteanu: no, I get it from a package in my archlinux distribution. But i installed cabal-install too
07:49:41 <Cale> You could go ahead and make a custom monad for this, or just use State and wrap it up so that there's no way to redefine the list of ops in the middle of the computation
07:49:56 <djcoin> so I guess I can try to install it using Cabal.
07:50:02 <Cale> But that's a heavyweight thing to do for a small program like this :)
07:50:08 <mentus> yes :-)
07:50:10 <nand`> oh, hrm, I still need False to actually be able to decide anything
07:50:13 <dmytrish> Hello all. I want to reinstall Cabal and all packages. I moved ~/.cabal to ~/.cabal.save and tried to rebootstrap it (cabal-1.14 update; cabal-1.14 install cabal-install), but it still says that it will break the installed packages.
07:50:21 <Eduard_Munteanu> djcoin: that, or see if there's a separate 'mtl' package
07:50:22 <mentus> first i just want to make it work as expected
07:50:56 <nand`> so is this the part where I use MPTCs and FunDeps?
07:51:04 <dmytrish> does it depends on some configuration files I don't know about? I thought ~/.cabal keeps the whole configuration
07:51:09 <djcoin> Eduard_Munteanu: ok, thanks ! I guess the mtl package (I just googled it) is pretty popular. Is there a list of most popular packages to have some overview of the important package around ?
07:51:15 <rwbarton> dmytrish: move away ~/.ghc instead
07:52:22 <djcoin> (btw, cabal install cabal-install seems to have mtl as a dependency and has fetch/compile it)
07:53:04 <djcoin> Great, it worked :) I know have mtl
07:53:11 <djcoin> thanks
07:53:16 <dmytrish> rwbarton: oh, now I see, thanks.
07:55:05 * hackagebot hspec 1.4.0 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.0 (SimonHengel)
07:55:16 <z3r0pr0f1t> What are the main advantages of the haskell platform?
07:55:25 <z3r0pr0f1t> I always used GHC only
07:55:45 <merijn> z3r0pr0f1t: Guarantees all the major libraries are installed and working together
07:57:53 <z3r0pr0f1t> merijn, That's great :D
08:02:14 <ramses_> @pl \(a,b) -> Just (b, (b, a+b))
08:02:15 <lambdabot> uncurry ((Just .) . ap (,) . ap (,) . (+))
08:02:31 <Eduard_Munteanu> djcoin: not sure about an overview, but you might want to look up what packages Haskell Platform provides.
08:15:44 <cornihilio> what does !( ... ) mean?
08:16:17 <monochrom> in what context? example?
08:16:26 <cornihilio>   !(Map PackageName (Map Version [InstalledPackageInfo]))
08:16:44 <monochrom> in what context?
08:16:48 <cornihilio> it's in Cabal/Distribution/Simple/PackageIndex.hs
08:17:07 <dmwit> looks like a strictness annotation
08:17:14 <dcoutts_> it's a strict field
08:17:32 <dcoutts_> like  data D = D !Int
08:18:04 <cornihilio> what does that mean?
08:19:21 <rampion> it means that field isn't evaluated lazily
08:19:34 <dmwit> http://www.vex.net/~trebla/haskell/strict-field.xhtml maybe?
08:19:38 <dmwit> one of the top hits on Google
08:20:06 <rampion> data Lazy x = L x ; data Strict x = S x
08:20:28 <rampion> L (1 + 2) stores a thunk for evaluating (1+2) later
08:20:40 <dmwit> I think you meant data Strict x = S !x
08:20:45 <rampion> S (1 + 2) evaluates (1+2) now, and stores S 3
08:20:51 <rampion> dmwit: yeah, sorry
08:21:05 <Anchakor> hi I need help interpreting haskell formulas - when I interpret them, do I start from left or right? do infix operators have higher priority then prefix?
08:21:13 <cornihilio> dmwit: thank you! that web page is much more helpful than this one I was looking at: http://www.haskell.org/haskellwiki/Performance/Strictness
08:21:40 <mauke> Anchakor: there are no prefix operators
08:21:46 <Anchakor> for example: foldr g v . map f
08:21:57 <rampion> function binding is strictest
08:21:59 <dmwit> Anchakor: function application binds tighter than infix operators
08:22:02 <rampion> so that's equivalent to
08:22:10 <rampion> (foldr g v) . (map v)
08:22:15 <dmwit> Anchakor: As for "start from left or right", well, neither =P
08:22:17 <rampion> which is equivalent to
08:22:25 <rampion> ((foldr g) v) . (map v)
08:22:58 <Anchakor> I know foldr take 3 arguments
08:23:04 <rampion> well
08:23:05 <rampion> sort of
08:23:08 <rampion> foldr :: (a -> b -> b) -> b -> [a] -> b
08:23:20 <rampion> foldr takes one argument and returns a function
08:23:35 <rampion> if g :: x -> y -> y
08:23:36 <dmwit> foldr :: (a -> b -> b) -> (b -> [a] -> b)
08:23:53 <Anchakor> wtf
08:23:54 <rampion> then foldr g :: x -> [y] -> [y]
08:24:11 <Anchakor> now you are just confusing me even more
08:24:15 <rampion> yes
08:24:19 <rampion> but this is important
08:24:22 <dmwit> Anchakor: Mind-blowing, isn't it? That right there is THE fact that got me into Haskell. =)
08:24:26 <rampion> this is called currying
08:24:41 <rampion> gtg
08:24:46 <pordan30> just fyi, but instead of left to right, you could start with the outermost reducible expression
08:24:48 <dmwit> Anchakor: The type "a -> b -> c" is not a two-argument function, it's a one-argument function that returns _another function_. It's "a -> (b -> c)".
08:25:06 * hackagebot approx-rand-test 0.1.0 - Approximate randomization test  http://hackage.haskell.org/package/approx-rand-test-0.1.0 (DanielDeKok)
08:25:07 <Anchakor> ok, so it is both
08:25:23 <Anchakor> depends on perspective
08:25:27 <dmwit> that depends on what "is" is =)
08:25:53 <Anchakor> ok, so the example: foldr g v . map f
08:25:53 <eMBee> hmm, installing the binary with out a gmp headers produces an unusable ghc (for building haskell-platform). it ought to be nice to have configure warn about gmp missing
08:26:20 <cornihilio> okay, in cabal-install/Distribution/Client/List.hs there is this: import qualified Distribution.Simple.PackageIndex as InstalledPackageIndex but a Distribution/Simple does not exists in cabal-install, only in Cabal.
08:26:37 <Anchakor> now I read it like (((foldr g) v . map f) x?
08:26:40 <cornihilio> what's going on there?
08:26:45 <dcoutts_> cornihilio: yes, it's imported from the Cabal lib
08:26:49 <dmwit> cornihilio: cabal-install depends on the Cabal library
08:26:55 <enolan> > data Real = Rational (Ratio Integer) | Irrational ((Ratio Integer) -> (Radio Integer))
08:26:57 <lambdabot>   <hint>:1:1: parse error on input `data'
08:26:57 <beaky> what is a monoid?
08:27:05 <dmwit> Anchakor: You read it like that, except for the x, yes.
08:27:20 <dmwit> Anchakor: ((foldr g) v) . (map f)
08:27:26 <enolan> I can't do data declarations like in ghci here? :(
08:27:41 <cornihilio> dcoutts_, dmwit: I don't get that though. How are these lines next to each other?: import qualified Distribution.Simple.PackageIndex as InstalledPackageIndex; import qualified Distribution.Client.PackageIndex as PackageIndex
08:27:44 <dmwit> Anchakor: No fair creating new things (like x) out of nowhere when reading.
08:27:45 <dmwit> =)
08:27:57 <Anchakor> ok so I read the formulas from the left, counting the leftover arguments
08:27:59 <cornihilio> how would I know otherwise about one Distribution being from Cabal?
08:28:01 <dcoutts_> cornihilio: because we use both
08:28:16 <enolan> I'm looking for a way to write a type that represents real numbers in general, precisely.
08:28:24 <dmwit> cornihilio: You can ask ghc-pkg which modules come from which packages.
08:28:29 <dcoutts_> cornihilio: notice that one comes from D.Simple and the other D.Client
08:28:35 <dmwit> enolan: there's CReal
08:28:47 <dmwit> > pi :: CReal
08:28:49 <lambdabot>   3.1415926535897932384626433832795028841972
08:28:49 <Anchakor> dmwit: in the excercise the answer is the equivalent formula is foldr (\x t -> g (f x) t) v
08:28:56 <dcoutts_> cornihilio: but yes, it does mean you need to know what modules come from where, but the conventions make that not too hard
08:29:03 <sipa> TIL xmonad uses a monad called X
08:29:12 <dmwit> sipa: hence the name, yep =)
08:29:26 <sipa> yes, a revelation!
08:29:31 <enolan> The Irrational data constructor takes a function that takes a desired precision and returns  a rational approximation
08:29:31 <dmwit> enolan: http://hackage.haskell.org/packages/archive/numbers/3000.1.0.1/doc/html/Data-Number-CReal.html
08:29:36 <cornihilio> dcoutts_: but why isn't it Cabal.Distribution and Distribution?
08:30:18 <dmwit> cornihilio: The "Cabal" at the beginning isn't the package name. It's a module name.
08:30:20 <dcoutts_> cornihilio: maybe you're getting confused between package names and module names. Packages (at least library packages) just contain a bunch of modules.
08:30:27 <dmwit> cornihilio: There's no a priori connection between package names and module names.
08:30:49 <enolan> dmwit: awesome, I was on the right track and someone else ha done all the hard work for me!
08:31:10 <t7> > pi : Ratio Integer
08:31:12 <lambdabot>   Not in scope: data constructor `Ratio'Not in scope: data constructor `Integ...
08:31:14 <t7> > pi :: Ratio Integer
08:31:16 <lambdabot>   No instance for (GHC.Float.Floating
08:31:16 <lambdabot>                     (GHC.Real.Ratio GHC...
08:31:27 <cornihilio> so only modules matter when it's looking up stuff?
08:31:34 <sipa> > approximateRational pi
08:31:36 <lambdabot>   Not in scope: `approximateRational'
08:31:36 <lambdabot>  Perhaps you meant `approxRational' (im...
08:31:38 <cornihilio> that must get kind of nasty in big projects, right?
08:31:44 <dmwit> enolan: There's also http://hackage.haskell.org/package/cyclotomic which makes some different tradeoffs.
08:31:48 <sipa> > approxRational Pi
08:31:49 <lambdabot>   Not in scope: data constructor `Pi'
08:31:53 <sipa> sigh
08:31:54 <dmwit> enolan: But it has, e.g., decidable equality, which is nice.
08:32:02 <sipa> > approxRational pi
08:32:04 <lambdabot>   *Exception: show: No overloading for function
08:32:26 <t7> > fix fix
08:32:28 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
08:32:42 <dmwit> :t approxRational
08:32:43 <lambdabot> RealFrac a => a -> a -> Rational
08:32:46 <dmwit> > approxRational pi 0.1
08:32:48 <lambdabot>   16 % 5
08:33:07 <dmwit> > approxRational pi 0.01
08:33:09 <lambdabot>   22 % 7
08:33:11 <dmwit> > approxRational pi 1
08:33:12 <lambdabot>   3 % 1
08:33:22 <t7> > approxRational pi 0.00001
08:33:24 <lambdabot>   355 % 113
08:33:27 <sipa> > exp 3
08:33:29 <lambdabot>   20.085536923187668
08:33:52 <sipa> > approxRational (exp pi - pi) 0.001
08:33:54 <lambdabot>   20 % 1
08:33:58 <dmwit> > exp (3 :+ 0)
08:34:00 <lambdabot>   20.085536923187668 :+ 0.0
08:34:05 <dmwit> oops
08:34:07 <t7> the bible says pi = 3
08:34:09 <dmwit> > exp (0 :+ 3)
08:34:11 <lambdabot>   (-0.9899924966004454) :+ 0.1411200080598672
08:34:19 <t7> math would be a lot easier if it was
08:34:30 <sipa> > approxRational (exp pi - pi) 0.00000001
08:34:32 <lambdabot>   244429 % 12222
08:34:56 <enolan> hmm, is the bible older than the idea of deductive reasoning?
08:35:05 <dmytrish> cabal install hsc2hs fails saying "#include "../../includes/ghcconfig.h"" not found - where is this weird include supposed to be?
08:35:12 <sipa> t7: on the contrary, it would contradict itself
08:35:51 <dcoutts_> dmytrish: hmm, sounds like someone broke something. That would probably work within the ghc build tree, but clearly not standalone.
08:36:18 <dcoutts_> dmytrish: file a ticket in the ghc trac
08:36:47 <dmwit> Oh, hey, dcoutts, while you're here: do you know how to grant me control of the gtk2hs trac?
08:36:55 <dcoutts_> oh um
08:38:16 <dcoutts_> dmwit: what's your username in that trac?
08:38:25 <dmwit> I couldn't find a way to make one.
08:38:30 <dmwit> But dmwit would be my preferred name.
08:38:33 <dcoutts_> oh
08:40:11 <dmytrish> yes, I can find ghcconfig.h in the GHC sources
08:41:31 <Anchakor> could anyone explain, how to get from "foldr g v . map f" to "foldr (\x t -> g (f x) t) v" which is supposed to be equivalent?
08:41:48 <yitz> dmwit: approxRational is not useless, but it's a weird choice of approximation criteria. lifted straight out of scheme i think.
08:41:56 <dmwit> Anchakor: First you need to know how to define map in terms of foldr; then you need to know how to fuse two foldr's together.
08:42:21 <dmwit> yitz: I don't think I claimed it was useless?
08:42:36 <yitz> dmwit: i wish they had chosen continued fraction, which gives the optimal result in a more useful sense that the so-called "simplest" approximation chosen by approxRational.
08:42:44 <byorgey> you can't fuse foldrs together in general.
08:42:51 <yitz> dmwit: no. i am claiming that, sort of.
08:42:55 <dmwit> oh =)
08:42:58 <byorgey> but you can always fuse a foldr followed by a map.
08:43:10 <byorgey> I mean, a map followed by a foldr.
08:43:11 <nand`> newtypes are not promotable?
08:43:19 <dmwit> byorgey: ...quite right, of course
08:43:24 <dcoutts_> byorgey: right, I was going to say... :-)
08:43:28 <Cale> Anchakor: Are you looking for a formal proof or an informal argument?
08:43:33 <monochrom> something about foldr being catamorphism and map being functor
08:43:47 <dcoutts_> dmwit: ok, I've asked for Igloo to fix the file permissions so I can adjust the user db for the trac.
08:43:57 <dmwit> dcoutts_: Great, thanks.
08:44:03 <Anchakor> Cale: I am trying to figure out how would I choose that from the list of other similar options in the test :)
08:44:22 <dmwit> (I actually find it kind of funny... I asked Axel who asked you who asked Igloo... we'll have to unravel this stack eventually. =P)
08:44:33 <Anchakor> I thought I understood haskell, but then I looked at those examples and sat back
08:44:35 <Cale> Anchakor: The way that I would think about it is that foldr f z replaces each (:) in a list with f and the empty list [] at the end (if any) with z
08:44:52 <dmwit> Can we write map as a build? Then maybe we could do some fusion. =P
08:44:57 <Cale> Anchakor: map g of course applies g to each of the elements of the list
08:45:41 <Cale> Anchakor: So by this description of it,  foldr (:) []  is obviously the same thing as id
08:45:57 <Cale> and  foldr ((:) . g) []  is the same thing as  map g
08:46:34 <Cale> but then if we replace that (:) and [] with some other f and z, it'll have the effect of applying foldr f z to the result of map g
08:46:49 <Cale> i.e. foldr (f . g) z
08:47:20 <Cale> = foldr f z . foldr ((:) . g) [] = foldr f z . map g
08:47:37 <dcoutts_> dmwit: :-)
08:48:00 <Cale> http://cale.yi.org/share/Folds.svg
08:48:07 <dcoutts_> dmwit: on the other Q, yes, map can be written as a combination of foldr and build, so can fuse on both sides.
08:48:11 <Cale> Anchakor: ^^ have a look at the diagram for foldr :)
08:48:36 <Cale> I used to have one for map...
08:48:40 <Cale> where did that go...
08:48:49 <lispy> good morning
08:49:12 <hiptobecubic> Cale, how did you generate this?
08:49:22 <Anchakor> that's a nice diagram
08:49:26 <Anchakor> map is easy
08:50:11 <Cale> Anchakor: yeah, it's easy, but nice to have alongside the one for foldr when figuring this out :)
08:50:17 <Anchakor> but in your explanation I got stuck on: foldr ((:) . g) []  is the same thing as  map g
08:50:25 <nand`> did you generate that diagram with ‘diagrams’? :)
08:50:29 <Cale> nand`: no
08:50:31 <nand`> shame
08:50:36 <dmwit> dat mapAccumR
08:50:38 <Cale> nand`: I drew it by hand in inkscale
08:50:41 <monochrom> diagrams did not exist back then
08:50:42 <Cale> inkscape*
08:50:45 <nand`> yeah I think I've heard you say that before
08:50:45 <tsou> Cale: what does that weird equality-like symbol on the mapAccum cards stand for?
08:50:46 <hiptobecubic> really?
08:51:04 <Cale> tsou: =?
08:51:08 <quicksilver> the diagrams haskell package may not have
08:51:22 <quicksilver> however various LaTeX packages with similar names did
08:51:32 <hiptobecubic> I don't see a weird equality-like symbol
08:51:34 <Cale> tsou: which symbol?
08:51:48 <tsou> Cale: the = whose bottom - looks like a negation symbol
08:51:57 <Cale> There's a bit of text which says  "where f x a = (f_1 x a, f_2 x a)
08:52:01 <Cale> "
08:52:05 <tsou> shit, i need new glasses
08:52:16 <tsou> Cale: sorry i read the "_1" part as part of the symbol..
08:52:32 <hiptobecubic> what?
08:53:32 <Cale> It does look like the subscripts are positioned a bit oddly in my web browser's svg renderer, but they're not that far off here :)
08:53:41 <nand`> it reads =₁ for me
08:53:43 <FireFly> The _2 renders too far to the right for me, intersecting with the x
08:53:46 <tsou> Cale: Ok, I think it's rendered wrong on my browser the _1 and _2 are supposed to decorate the x's on the right.. on mine the _1 is stuck together with the =
08:54:06 <Cale> They're supposed to decorate the f's
08:54:17 <nand`> I think the font has something to do with it
08:54:23 <tsou> sorry, yes
08:54:30 <hiptobecubic> nand`, what browser?
08:54:36 <Cale> Yeah, I believe the font in that svg is Georgia
08:54:42 <nand`> I don't have Georgia
08:54:47 <nand`> it renders using terminus for me
08:54:51 <Cale> ah
08:54:53 <nand`> (which is monospace, incidentally)
08:54:57 <Cale> I should just render the png
08:55:04 <nand`> hiptobecubic: firefox v14.0.1
08:55:05 <hiptobecubic> Cale, yes
08:55:17 <hiptobecubic> it renders properly for me, but 1/5 isn't very good
08:55:30 <FireFly> Cale: thanks for making those images btw, they're great.  I think I had only seen the fold & scan ones before
08:56:07 <Cale> http://cale.yi.org/share/Folds.png
08:56:25 <nand`> Does anybody know if Richard Eisenberg is in here, or otherwise comes here regularly? His e-mail address uses ‘eir’ but I don't see any such nick
08:56:49 <nand`> heh, now it takes much much longer to load
08:56:52 <dmwit> He does not hang out in IRC.
08:56:59 <nand`> how large is that PNG?
08:57:12 <tsou> Cale: much better; thanks
08:57:19 <dmwit> ...he actually gets stuff done, the jerk. He makes all us officemates look bad. ;-)
08:57:22 <mauke> 224 kB
08:57:54 <nand`> 231 kB for me; optipng gets it down to 158 kB but still it shouldn't take that long to load, how odd
08:58:03 <nand`> must be an extremely poor connection between me and the server
08:58:06 <tac> Cale: yeah. Those images (especially the foldr one, because I use that one a lot) are great
08:58:47 <dmwit> Yes, Cale's server is historically very slow. I think he's self-hosting or something like that.
08:59:07 <Cale> Yeah, that's just the computer I'm sitting at right now
08:59:10 <tac> actually, foldr is just about the only function I ever use. I don't like the others. But the diagram for foldr makes it so obvious what it does :)
08:59:14 <Cale> My upload isn't great
08:59:17 <dmwit> Oh Rogers. I'm so sorry for you.
09:00:41 <Cale> http://www.speedtest.net/result/2294634095.png -- ridiculously asymmetric
09:00:43 <Anchakor> @type id
09:00:45 <lambdabot> a -> a
09:00:48 <Anchakor> @type curry
09:00:49 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:00:53 <Anchakor> @type curry id
09:00:55 <lambdabot> a -> b -> (a, b)
09:00:58 <Anchakor> how come?!
09:01:13 <Jafet> Cale: f₀ ∘ f₁ ∘ f₂
09:01:23 <Cale> Jafet: ?
09:01:27 <Anchakor> can someone explain how can I by using substitution get to the "curry id" type?
09:01:53 <Cale> Anchakor: c = (a,b)
09:01:55 <Jafet> I suppose your subscripts are made by shrinking the font
09:02:05 <Cale> Jafet: yeah
09:02:25 <Cale> I suppose I could use those unicode characters instead
09:03:03 <Anchakor> Cale: then how come I can delete the  ((a, b) -> (a, b)) on the start?
09:03:05 <Jafet> Not really. There will then be people who see boxes
09:03:29 <Cale> Anchakor: because you've applied it to a parameter of that type
09:03:40 <Cale> That's the (specialised) type of id
09:04:23 <Anchakor> I don't get it
09:04:45 <Cale> Anchakor: anyway, as to why foldr ((:) . g) [] = map g, perhaps it would help if I wrote it as  foldr (\x xs -> g x : xs) []
09:04:53 <dmwit> Anchakor: If f :: a -> b and x :: a, then f x :: b.
09:05:10 <Cale> :t curry
09:05:12 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:05:23 <Cale> :t id :: (a, b) -> (a, b)
09:05:25 <lambdabot> (a, b) -> (a, b)
09:05:43 <Cale> :t curry (id :: (a,b) -> (a,b))
09:05:43 <Anchakor> dmwit: I get that
09:05:44 <lambdabot> a -> b -> (a, b)
09:05:53 <dmwit> :t curry `asAppliedTo` id
09:05:55 <lambdabot> ((a, b) -> (a, b)) -> a -> b -> (a, b)
09:06:37 <hpaste> dan pasted “fgl problem” at http://hpaste.org/77448
09:07:04 <Anchakor> ok so I map id (a -> a) to ((a, b) -> c), making it ((a, b) -> (a, b))
09:07:05 <notdan> http://hpaste.org/77448 Hi, can someone please help me with this
09:07:10 <Anchakor> ok I think I get it now
09:07:15 <notdan> I don't understand the output
09:07:18 <dmwit> :t id `asArgumentTo` curry
09:07:20 <lambdabot> (a, b) -> (a, b)
09:07:40 <notdan> Why doesn't the node 3 context has input and output nodes?
09:07:45 <notdan> *output edges
09:07:57 <nand`> are type families not higher order?
09:07:58 <Cale> Anchakor: When we apply  curry :: ((a,b) -> c) -> a -> b -> c  to  id :: t -> t  we need the types t -> t and (a,b) -> c to match
09:08:02 <Cale> So t = (a,b) and t = c
09:08:42 <Cale> So c = (a,b), and the result of curry id has type (a -> b -> (a,b))
09:08:54 <Anchakor> thanks I get that now
09:09:36 <dmwit> :t \f -> f .: (,)
09:09:38 <lambdabot> ((a, b1) -> b) -> a -> b1 -> b
09:10:37 <dmwit> curry = (.: (,)) -- don't think I've seen this definition before, but I like it
09:11:31 <Cale> :t uncurry id
09:11:32 <lambdabot> (b -> c, b) -> c
09:12:02 <Cale> That would be the natural next one to sort out :)
09:12:13 <Anchakor> :t uncurry
09:12:15 <lambdabot> (a -> b -> c) -> (a, b) -> c
09:14:18 <Anchakor> so in this case a is mapped to b -> c?
09:14:39 <Cale> yeah
09:15:00 <Cale> because for t -> t to match a -> (b -> c)
09:15:05 <Cale> t = a and t = b -> c
09:15:06 <Anchakor> ok I seem to be getting hang of it
09:15:27 <Cale> :t curry (curry id)
09:15:28 <lambdabot> a -> b -> b1 -> ((a, b), b1)
09:23:55 <Anchakor> can anyone explain the step between: h x   = flip (.) (q x) . q
09:24:07 <Anchakor> and: h x   = (. q) (flip (.) (q x))
09:24:55 <tromp__> (. q) a = a . q
09:25:36 <Anchakor> and (.) q a = a . q
09:25:54 <Anchakor> right?
09:26:03 <tromp__> no
09:26:06 <cornihilio> what on earth does this data declaration  work?: https://gist.github.com/4039940 I don't get how it's just two tuples, without any of the other usual signifiers
09:26:07 <Clint> (.) q a = q . a
09:26:32 <Anchakor> damn that confuses me
09:26:35 <Anchakor> :t .
09:26:37 <lambdabot> parse error on input `.'
09:26:42 <Anchakor> :t (.)
09:26:44 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:27:13 <Clint> which signifiers are you expecting?
09:27:16 <Cale> Anchakor: You've hit a generalisation that I made in lambdabot's local scope
09:27:44 <Anchakor> how come: (. q) a = a . q
09:27:48 <nand`> Hmm, I need a better representation of integers
09:27:55 <Anchakor> but: (.) q a = q . a
09:28:08 <Cale> With f = (->) e it specialises back to usual function composition
09:28:29 <Cale> Anchakor: because (. q) = (\x -> x . q)
09:28:29 <tromp__> > (-1) 3
09:28:31 <lambdabot>   -1
09:28:42 <tromp__> > (-) 1 3
09:28:44 <lambdabot>   -2
09:29:05 <Cale> tromp__: - is probably the worst example you could have chosen there ;)
09:29:09 <fryguybob> Anchakor: If you write (a ^ b) and you want to refer to that without the a which makes more sense (b ^) or (^ b)?
09:29:10 <Anchakor> ((-) 1) 3
09:29:11 <tromp__> > (`subtract`1) 3
09:29:12 <lambdabot>   -2
09:29:20 <Cale> > (/ 2) 1
09:29:21 <Anchakor> > ((-) 1) 3
09:29:22 <lambdabot>   0.5
09:29:23 <tromp__> i realize:(
09:29:23 <lambdabot>   -2
09:29:35 <Cale> Let's use division
09:29:40 <Cale> > (/ 2) 1
09:29:42 <lambdabot>   0.5
09:29:48 <Cale> > (/) 2 1
09:29:49 <lambdabot>   2.0
09:29:52 <Cale> > (/) 1 2
09:29:53 <lambdabot>   0.5
09:30:00 <Cale> > (1/) 2
09:30:02 <lambdabot>   0.5
09:30:07 <killy9999> I have a question which I think will be a rethorical one
09:30:19 <Anchakor> ok, I thought (-1) means (\x -> 1 - x)
09:30:31 <Cale> (-1) is just negative 1
09:30:37 <quicksilver> it's an irregularity in the syntax, Anchakor
09:30:43 <killy9999> if I am using Eval monad and Strategies, but in the output I get "SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)" it means that I'm doing it wrong and not creating any sparks
09:30:47 <tromp__> ( `f` y) = \x -> x `f` y
09:30:48 <killy9999> ?
09:30:48 <quicksilver> (but you'd expect it to mean \x -> x - 1, not what you wrote.
09:31:00 <Cale> Since there's an instance of Num for functions in scope, you can also use (-1) as the constant function which always gives -1
09:31:03 <Anchakor> ok thanks all
09:31:06 <Cale> > map (-1) [1..10]
09:31:07 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
09:31:43 <parcs`> :t uncurry id
09:31:44 <lambdabot> (b -> c, b) -> c
09:31:55 <Cale> killy9999: Are you compiling with -threaded?
09:32:09 <killy9999> checking...
09:32:29 <killy9999> yes
09:32:41 <killy9999> -threaded -Odph
09:32:45 <Cale> and running with +RTS -N2 or the like?
09:32:48 <killy9999> + som other flags and LLVM
09:32:50 <killy9999> yes
09:33:04 <killy9999> +RTS -N2 -qa -g1 -ls -s
09:33:22 <nand`> what's a good representation of integers that has only one valid valuer for any integer?
09:33:35 <nand`> value*
09:33:49 <tac> nand`: Nat + Nat
09:33:58 <tac> Where inr n is treated as -1 - n
09:34:04 <tac> and inl n is just n
09:34:16 <nand`> I could do Int = Zero | Pos Nat1 | Neg Nat1 but addition etc. on that seems incredibly complicated, like I have to do nearly every combination
09:34:17 <cornihilio> Clint: you're right, I guess there doesn't need to be any signifier. I guess I meant something like '|' for adt's or record syntax or something
09:34:49 <tac> nand`: but yeah, writing basic functions on Ints is actually pretty tedious
09:35:09 <nand`> tac: how easy is addition and multiplication on those?
09:36:24 <Cale> killy9999: Are you seeing above 100% cpu usage at all? I don't know.
09:36:59 <Cale> killy9999: It could also be something wrong with whatever is counting the sparks.
09:37:48 <killy9999> Cale: it might also be that I don't know yet how to correctly use Eval :)
09:38:16 <killy9999> Productivity  91.7% of total user, 106.6% of total elapsed
09:47:30 <tac> nand`: they are both kinda a pain to write, unfortunately :(
09:47:51 <tac> nand`: though easier than in the P | Z | N formulation, because there are fewer cases.
09:48:03 <beaky> is it possible to do IO in haskell without monads?
09:48:08 <tac> beaky: yes
09:48:18 <tac> beaky: there's a post on reddit this morning that talks about exactly that
09:48:20 <beaky> ah
09:49:39 <tac> I thought.... I swear I was reading it :)
09:49:50 <beaky> http://pragprog.com/magazines/2012-11/thinking-functionally-with-haskell this?
09:50:34 <tac> beaky: yes. that's it.
09:50:55 <tac> I don't think it serves as a "how to", but it's an account of how it used to be done
09:50:59 <nand`> tac: mm, done with addition now, needed 5 cases
09:51:28 <nand`> time to do multiplication; to make my life easier I think I'll just implement multiplication with naturals; since that's really all I need
09:51:53 <tac> nand`: mult should be easier than addition on account of you can reduce it to a positive * positive case
09:51:58 <Cale> beaky: We could use IO without actually recognising the fact that IO happens to be a monad.
09:52:04 <tac> err, if it's double negative.
09:52:05 <beaky> right
09:52:18 <tac> err wait... anyway, you'll get it :)
09:52:22 <Cale> beaky: and there are other ways of putting together descriptions of effects
09:52:27 <nand`> (-1-a) * (-1-b) though
09:52:32 <beaky> I want to try doing purely-functional IO in other languages liek C and C++
09:52:37 <beaky> but I don't know how to do it
09:53:11 <nand`> = x + y + x*y + 1
09:53:16 <killy9999> Cale: so, I chcecked eventlog profile with ThreadScope and it looks that I really don't spawn the sparks...
09:53:16 <nand`> should be doable either way
09:53:33 <Cale> I prefer the idea that IO internally consists of abstract syntax describing the action to be performed.
09:53:54 <Cale> To the whole RealWorld -> (RealWorld, a) thing, which is kinda bogus.
09:54:02 <Cale> You could never really implement it like that without cheating.
09:54:08 <beaky> ah
09:54:34 <beaky> maybe C macros might help :D
09:54:46 <Cale> (In GHC, the implementation sort of looks like that, except that RealWorld is a 0-bit token just used to keep the order of things straight, and the effects are put unsafely into the function structure)
09:55:24 <monochrom> I use the continuation passing style story. "getLine >>= \x -> more" is really "getLine_then (\x -> more)"
09:55:35 * nand` prefers the free monad based version
09:56:03 <nand`> (made more efficient, of course, by slapping continuations on top of it)
09:56:04 <Cale> nand`: That's basically the abstract syntax way that I mentioned :)
09:56:41 <nand`> Run :: forall i o a. FFI i o -> i -> (o -> a) -> IO a
09:57:42 <nand`> err
09:57:45 <nand`> (o -> IO a)
09:58:44 <nand`> so how do I write a quasiquoter?
10:00:11 <ByronJohnson> w\la
10:03:19 <beaky> let y = \f -> f (y f) in y (\f n -> if n == 0 then 1 else n * f (n - 1))
10:03:39 <beaky> > let y = \f -> f (y f) in (y (\f n -> if n == 0 then 1 else n * f (n - 1))) 6
10:03:41 <lambdabot>   720
10:19:52 <SrPx> Is "=" infixl or infixr? What's it's precedence? I can find of the others but not of "="
10:20:10 <Jafet> = is not an operator
10:24:06 <SrPx> :/
10:24:23 <Jafet> (==) is infix 4.
10:24:25 <fmap> and there are operators that aren't infixl nor infixr
10:24:55 <Jafet> > True == True == True
10:24:57 <lambdabot>   Precedence parsing error
10:24:57 <lambdabot>      cannot mix `GHC.Classes.==' [infix 4] and `GH...
10:25:18 <nand`> ugh
10:25:25 <Cale> SrPx: = is just part of the syntax of declarations
10:25:30 <nand`> does TH have no PromotedListT :: [Type] -> Type
10:25:36 <Cale> (function bindings and pattern bindings)
10:26:53 <SrPx> hmm
10:27:07 <SrPx> ok, thanks
10:27:50 <Jafet> (and record syntax!)
10:29:54 <Jafet> Are there any pretty-printers better than the one in haskell-src-exts?
10:31:29 <neutrino> is there something i can do so that i can specify enum values by their numeric value, without writing fromEnum everywhere?
10:32:24 <Jafet> No. (That's a lie.)
10:32:49 <c_wraith> It's a lie, but it's better than the truth
10:33:19 <Jafet> YOU CAN'T HANDLE THE CATCHPHRASE
10:33:27 <neutrino> what is the truth
10:33:43 <c_wraith> The truth being "yes, but it will make your code brittle and full of really bizarre messages for type errors"
10:33:52 <neutrino> fuck that
10:33:57 <bxx> is there a way to fetch previous "its" in ghci, something like it2, it3
10:34:06 <Jafet> I wouldn't call making a Num instance just to get integer literals the truth.
10:34:14 <c_wraith> bxx: I don't believe so
10:34:18 <Jafet> bxx: no
10:34:19 <neutrino> is there any way to apply "fromEnum" to all elements of a 4-tuple?
10:34:26 <neutrino> i tried fmap but i don't think that's working out.
10:35:05 <neutrino> c_wraith: thanks for warning me about the brittle code lying ahead btw.
10:35:09 * hackagebot fixed-vector 0.1 - Generic vectors with fixed length  http://hackage.haskell.org/package/fixed-vector-0.1 (AlexeyKhudyakov)
10:35:17 <Jafet> apply4 :: (a -> b) -> (a, a, a, a) -> (b, b, b, b)
10:35:23 <Jafet> Tuples are crap
10:35:33 <neutrino> hm
10:35:39 <fmap> :t (both.both)
10:35:40 <neutrino> @hoogle apply4
10:35:40 <lambdabot> No results found
10:35:41 <lambdabot> Applicative f => (a -> f b) -> ((a, a), (a, a)) -> f ((b, b), (b, b))
10:36:00 <neutrino> i'll just write it
10:36:06 <neutrino> i think i can manage that
10:36:13 <Jafet> @djinn (a -> b) -> (a, a, a, a) -> (b, b, b, b)
10:36:13 <lambdabot> f a (b, _, _, _) = (a b, a b, a b, a b)
10:36:21 <Jafet> No
10:36:24 <neutrino> hahaha
10:37:03 <neutrino> @djinn a -> a
10:37:04 <lambdabot> f a = a
10:37:08 <neutrino> oh, clever.
10:37:17 <nand`> So much boilerplate :( http://hub.darcs.net/nand/units/browse/TH.hs
10:37:22 <neutrino> can you make djinn come up with more complicated ones?
10:38:53 <ClaudiusMaximus> @djinn Maybe a -> Maybe b -> Maybe (Either a b)
10:38:53 <lambdabot> f a b =
10:38:53 <lambdabot>     case a of
10:38:53 <lambdabot>     Nothing -> Nothing
10:38:53 <lambdabot>     Just c -> case b of
10:38:53 <lambdabot>               Nothing -> Just (Left c)
10:38:55 <lambdabot>               Just d -> Just (Right d)
10:39:31 <neutrino> does djinn come as a command line utility?
10:39:46 <ClaudiusMaximus> yes, i think it has a repl even
10:39:53 <neutrino> i could see major use when editing in vim
10:39:57 <nand`> that one could have been f a _ = fmap Left a
10:40:16 <ClaudiusMaximus> or f _ _ = Nothing
10:40:21 <nand`> indeed
10:40:35 <nand`> I wonder what exact logical rules it uses to decide how to implement these
10:40:36 <ClaudiusMaximus> but djinn ranks the results by how many arguments it uses, or something
10:40:37 <parcs`> @djinn ((a -> (b -> r) -> r) -> (a -> r) -> r) -> (a -> r) -> r
10:40:38 <lambdabot> f a b = a (\ c _ -> b c) b
10:40:40 <nand`> oh
10:40:42 <nand`> that makes sense
10:40:58 <nand`> wonder why it didn't come up with f a (b, c, d, e) = (a b, a c, a d, a e) then
10:41:42 <ClaudiusMaximus> djinn proper can be told to give all the results, as far as i know
10:42:07 <ClaudiusMaximus> which isn't much, even though i ripped it apart and stuck a TH front-end on it
10:42:36 <neutrino> why did you rip it apart ClaudiusMaximus?
10:42:49 <ClaudiusMaximus> with the idea of getting it to understand in-scope classes/instances, but never got around to
10:43:18 <ClaudiusMaximus> it was mostly adding a translation between djinn's AST and TH's AST
10:44:50 <parcs`> :t Proxy
10:44:51 <lambdabot> Not in scope: data constructor `Proxy'
10:45:04 <Cale> parcs`: Isn't that a 7.6 thing?
10:45:43 <parcs`> Cale: it is? i thought it was just a part of data-tagged
10:45:44 <lightquake> whenever i worry that my haskell programs are too verbose
10:45:48 <lightquake> i just think about java
10:45:49 <lightquake> http://javadoc.bugaco.com/com/sun/java/swing/plaf/nimbus/InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter.html
10:46:01 <parcs`> anyway apparently (typeOf1 (Proxy :: Proxy Int) == typeOf1 (Proxy :: Proxy ())) == True
10:46:07 <parcs`> seems wrong
10:46:23 <atriq> lightquake, that sounds like a song from Mighty Boosh
10:46:29 <ClaudiusMaximus> isn't typeOf1 the type of its type constructor?
10:46:40 <Cale> lightquake: loooool
10:46:41 <hpaste> “Seth Fogarty” pasted “Reduce/Reduce errors from sequencing” at http://hpaste.org/77451
10:46:57 <ClaudiusMaximus> > typeOf (undefined :: Either Int Bool)
10:46:58 <lambdabot>   Either Int Bool
10:47:01 <ClaudiusMaximus> > typeOf1 (undefined :: Either Int Bool)
10:47:03 <lambdabot>   Either Int
10:47:04 <parcs`> ClaudiusMaximus: oh, right you are
10:47:06 <ClaudiusMaximus> > typeOf2 (undefined :: Either Int Bool)
10:47:08 <lambdabot>   Either
10:47:14 <parcs`> that's better
10:47:24 <sfogarty> Is there anyone familiar with L/R parsers (and happy in specific) that could perhaps help? I'm getting reduce/reduce conflicts when I try to add "S ; E" sequencing, and I'm not sure how to resolve
10:47:33 <neutrino> hmm
10:47:33 <neutrino> that sounds like a great idea ClaudiusMaximus
10:47:33 <neutrino> i would love to see it happen
10:47:33 <neutrino> i'm having trouble using the djinn program. have you ever used it?
10:47:33 <neutrino> what would i need to do to get the same functionality as @djinn ?
10:48:08 <ClaudiusMaximus> neutrino: never used the program..
10:48:37 <ClaudiusMaximus> neutrino: djinn-th is my fork, but it probably fails to compile any more
10:49:32 <Cale> lightquake: https://svn.codehaus.org/grails-plugins/grails-searchable/trunk/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/mapping/SearchableGrailsDomainClassCompassClassMapperFactory.java
10:49:43 <ClaudiusMaximus> neutrino: (patches moderately unwelcome, would rather offers of new maintainership..)
10:50:28 <lightquake> Cale: D:
10:51:59 <ParahSail1n> im running some code using the mersenne package, and it seems to be calling  clock_gettime() a lot
10:52:45 <Cale> ParahSail1n: Maybe you're reinitialising the generator frequently for some reason?
10:54:48 <ParahSail1n> Cale: http://hpaste.org/77452
10:54:52 <ParahSail1n> should not be, right?
10:55:15 <nand`> Shouldn't there be a Parser Integer for natural numbers in decimal representation somewhere in Text.Parsec?
10:55:22 <neutrino> i figured out how to use djinn from the command line. you can just do djinn <(echo "foo ? a -> b")
10:55:33 <nand`> I can only find the ones in Text.Parsec.Language, I guess I could re-use the one from haskellDef
10:57:53 <Cale> ParahSail1n: Yeah, doesn't look like it ought to
10:58:23 <Cale> ParahSail1n: Which mersenne package is this?
10:58:29 <sfogarty> stupid reduce reduce conflicts.
10:58:50 <gds> Does anyone know how to tell haddock to build docs which hyperlink standard online library docs where available?
10:59:04 <gds> I've tried: cabal haddock --html-location=http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html
10:59:10 <Cale> ParahSail1n: mersenne-random?
10:59:14 <ParahSail1n> yeah
10:59:25 <gds> But the problem is that I'm using libraries from containers and mtl as well as from base.
10:59:32 <ParahSail1n> is there anything else that would call clock gettime repeatedly?
10:59:36 <gds> So only 1/3 of my docs hyperlink properly :/
11:00:36 <callen> ParahSail1n: I have to admit, I have a very hard time with your nick.
11:00:38 <Cale> ParahSail1n: Oh, also, newMTGen is a lie, you're only allowed to have one MTGen anyway, and it's   data MTGen = MTGen
11:01:38 <Cale> newMTGen Nothing = do
11:01:38 <Cale>     ct             <- getCPUTime
11:01:38 <Cale>     (TOD sec psec) <- getClockTime
11:01:38 <Cale>     newMTGen (Just (fromIntegral $ sec * 1013904242 + psec + ct) )
11:01:46 <Cale> But it does get the time
11:02:26 <pordan30> are monadic mapaccuml/r defined anywhere? i'd rather import it than define it inside a module.
11:02:33 <pordan30> *them
11:03:29 <Cale> pordan30: Not that I know of.
11:03:40 <atriq> How many prelude replacements are there...
11:03:43 <Cale> pordan30: What's the type that you want?
11:03:51 <Cale> atriq: Approximately zero
11:03:51 <atriq> Too many? Or... not enough!?
11:04:25 <Cale> There are none which are really worth caring about
11:04:29 <atriq> Cale, I mean stuff like general-prelude and prelude-generalize
11:04:43 <atriq> I don't care about whether they are worth caring about
11:04:54 <pordan30> Cale: i'm using mapAccumM :: Monad m => (a -> x -> m (a, y)) -> a -> [x] -> m (a, [y]), which is the type of a function apparently appearing in old versions of ghc
11:05:10 * hackagebot yesod-test 0.3.1.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.1.1 (MichaelSnoyman)
11:05:13 <sfogarty> Anyone know how to remove reduce/reduce conflicts of the form E := S ';' E ?
11:06:40 <Cale> pordan30: http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:(a%20-%3E%20x%20-%3E%20m%20(a%2C%20y))%20-%3E%20a%20-%3E%20%5Bx%5D%20-%3E%20m%20(a%2C%20%5By%5D)
11:06:41 <beaky> how od I introducte my own keywords in haskell
11:07:14 <Cale> beaky: ?
11:07:19 <ParahSail1n> cale, how would i profile this program to see what's messing up
11:07:19 <pordan30> atriq: there's the classy prelude, which is pretty cool: http://hackage.haskell.org/package/classy-prelude
11:07:42 <Cale> beaky: keywords are part of the language description, you don't add them, unless you're asking how to modify GHC...
11:08:14 <mauke> Perl can do it!
11:08:21 <Cale> pordan30: s/cool/terrible/ ;)
11:09:33 <beaky> I want to use `lambda x y -> x + y` instead of \x y -> x + y for example
11:10:11 <Cale> beaky: Write a source to source translator
11:10:34 <Cale> beaky: which accepts the syntax you want to write programs in, and emits Haskell code.
11:10:48 <beaky> ah
11:10:56 <beaky> that's easy to do in haskell :D
11:10:59 <ParahSail1n> #define lambda \
11:11:09 <Cale> ^^ or that, lol
11:11:15 <beaky> you can use the c preprocessor in askell?
11:11:18 <Cale> sure
11:11:25 <pordan30> Cale: i didn't know hayoo existed; it's much better than hackage. it appears that the desired function appeared in old versions of ghc, e.g. at least < 7.1 according to the docs, but not anymore. thanks for the help :)
11:11:26 <Cale> {-# LANGUAGE CPP #-}
11:11:33 <beaky> omg thats so cool
11:11:45 <mauke> s/cool/terrible/
11:11:53 <beaky> what
11:11:57 <ziman> #define cool terrible
11:12:21 <beaky> besides my case, why would haskell need the C preprocessor? :d
11:12:52 <nand`> @pl \x -> f x . g
11:12:53 <lambdabot> (. g) . f
11:13:02 <ethercrow> #ifdef DEBUG, #ifdef WINDOWS
11:13:15 <Cale> beaky: Platform-specific implementations of stuff
11:13:24 <beaky> oh
11:14:29 <pordan30> plus, think of the possibilities: #define /and/ pl
11:14:54 <Cale> Mixing quasiquoters with CPP, lol
11:15:47 <Cale> #define begin [myQQ| ; #define end |]
11:15:49 <c_wraith> But yeah, CPP is used primarily because it's the only way offered for some of the code compiled to vary by environment
11:16:11 <u_quark> @def data Cc = Cc Real Real
11:16:11 <ethercrow> #define CPP CPP_but_I_promise_to_think_about_future_maintainers
11:16:12 <lambdabot> Maybe you meant: bf do let
11:16:21 <u_quark> @let data Cc = Cc Real Real
11:16:21 <lambdabot>  Invalid declaration
11:16:33 <Cale> u_quark: You can't define new types in lambdabot
11:16:36 <pordan30> they should really choose a different name for quasiquotation, it's confusing: http://en.wikipedia.org/wiki/Quasi-quotation
11:16:36 <c_wraith> Like, TH can make code vary by environment, but only in limited ways.  It has no way to change imports based on environment
11:16:39 <u_quark> piiffff
11:16:46 <Cale> u_quark: also, Real isn't defined
11:16:47 <Sonderblade> where does the ^. operator come from?
11:16:51 <c_wraith> lens
11:16:54 <pordan30> data.lens
11:17:00 <Cale> :t (^.)
11:17:01 <lambdabot> s -> Getting a s t a b -> a
11:19:14 <Cale> harrison: Extreme nick indecision?
11:19:47 <c_wraith> Or maybe performing a one-man play in another channel
11:20:21 <edwardk> pordan30: Control.Lens actually =)
11:20:58 <c_wraith> I went with the package name.  Easier to remember
11:21:13 <harrison>  performing a one-man play in another channel lol
11:21:18 <harrison> story of my life
11:21:36 <harrison> that is the reaction people usually have to me
11:21:36 <danr> ^^
11:21:50 <harrison> but i never heard it phrased so succinctly
11:22:00 <pordan30> edwardk: of course, sorry about that :)
11:25:10 * hackagebot hexpat 0.20.3 - XML parser/formatter based on expat  http://hackage.haskell.org/package/hexpat-0.20.3 (StephenBlackheath)
11:29:59 <beaky> does haskell have a floating point math library?
11:30:13 <beaky> with things like sin, log, pow, pi, and stuff?
11:30:23 <Cale> That's all in the Prelude
11:30:23 <quicksilver> > sin 0.5
11:30:25 <lambdabot>   0.479425538604203
11:30:25 <Cale> :t sin
11:30:26 <lambdabot> Floating a => a -> a
11:30:31 <Cale> :t pi
11:30:33 <lambdabot> Floating a => a
11:30:39 <Cale> :t (^)
11:30:40 <lambdabot> (Integral b, Num a) => a -> b -> a
11:30:44 <Cale> :t (^^)
11:30:45 <lambdabot> (Fractional a, Integral b) => a -> b -> a
11:30:46 <Cale> :t (**)
11:30:47 <lambdabot> Floating a => a -> a -> a
11:30:55 <Cale> (three kinds of exponentiation)
11:30:57 <Cale> :t log
11:30:58 <lambdabot> Floating a => a -> a
11:30:59 <Cale> :t exp
11:31:00 <lambdabot> Floating a => a -> a
11:31:05 <Cale> > exp 1
11:31:07 <lambdabot>   2.718281828459045
11:31:10 <Cale> > log (exp 1)
11:31:12 <lambdabot>   1.0
11:31:45 <Cale> > exp (0 :+ pi)
11:31:47 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
11:31:58 <Cale> > exp (0 :+ pi) :: Complex CReal
11:32:00 <lambdabot>   (-1.0) :+ 0.0
11:32:06 <hiptobecubic> having fun?
11:32:10 <Cale> (CReal isn't in the Prelude)
11:32:36 <Cale> hiptobecubic: Demonstrating for beaky
11:32:51 <pordan30> there are also rationals, if you don't want to deal with floating point numbers
11:33:03 <hiptobecubic> Slow as balls tohugh
11:33:08 <hiptobecubic> though*.   Slow ones.
11:34:53 <dgpratt> supposing that I am trying to cabal install a package that can reasonably be assumed to be in working order, what could cause the package to fail to compile some template haskell code?
11:35:19 <hpaste> neutrino pasted “djinn vim command” at http://hpaste.org/77455
11:35:20 <atriq> > let sinh x = 0.5 * (exp x - exp (negate x)); cosh x = 0.5 * (exp x + exp (negate x)) in cosh 7 ^ 2 - sinh 7 ^ 2
11:35:23 <lambdabot>   0.9999999999417923
11:35:28 <neutrino> ^^
11:35:35 <sopvop> dpratt: wrong version of template-haskell?
11:35:54 <neutrino> Cale: my ide can generate code on its own now
11:36:04 <dgpratt> sopvop: I wondered about that; how do I know which is the right version?
11:36:08 <atriq> > let sinh x = 0.5 * (exp x - exp (negate x)); cosh x = 0.5 * (exp x + exp (negate x)) in (cosh 7 ^ 2 - sinh 7 ^ 2) :: CReal
11:36:09 <lambdabot>   1.0
11:36:45 <neutrino> atriq: looks about right
11:37:09 <atriq> Rounding errors are fun
11:37:52 <beaky> @hoogle a -> a -> a -> (a, a, a)
11:37:53 <lambdabot> Data.Sequence zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
11:37:53 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
11:37:53 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
11:37:55 <atriq> Where can I get CReal?
11:38:12 <neutrino> @hoogle CReal
11:38:13 <nand`> How do I quote operator names for template haskell?
11:38:13 <lambdabot> No results found
11:38:17 <neutrino> oh
11:38:24 <neutrino> @hayoo CReal
11:38:25 <lambdabot> Unknown command, try @list
11:38:28 <neutrino> hrm.
11:38:32 <nand`> I have data Exp = TString :^ Int but quoting it as ':^ fails
11:38:50 <nand`> same for (':^)
11:38:55 <geekosaur> '(:^) maybe?
11:38:55 <nand`> oh; '(:^) probably works
11:38:59 <nand`> yeah, seems to
11:39:27 <oldxchatnuts> what is haskell
11:39:39 <pordan30> atriq: the numbers package, i think
11:40:00 <dgpratt> template haskell has to be matched with GHC, right? I have GHC v7.4.1 and template-haskell v2.7.0.0; how do I know that's what it should be?
11:40:43 <atriq> :t \a b c -> set _1 a . set _2 b . set _3 c
11:40:44 <lambdabot> (Field3 s a2 a4 b3, Field2 a2 a a3 b2, Field1 a b a1 b1) => b1 -> b2 -> b3 -> s -> b
11:40:53 <atriq> :t (\a b c -> set _1 a . set _2 b . set _3 c) 1 2 3 ((),(),())
11:40:55 <lambdabot> (Num b2, Num b1, Num b) => (b, b1, b2)
11:41:00 <atriq> > (\a b c -> set _1 a . set _2 b . set _3 c) 1 2 3 ((),(),())
11:41:03 <lambdabot>   (1,2,3)
11:41:58 <Cale> :t (\a b c -> set _1 a . set _2 b . set _3 c)
11:41:59 <lambdabot> (Field3 s a2 a4 b3, Field2 a2 a a3 b2, Field1 a b a1 b1) => b1 -> b2 -> b3 -> s -> b
11:42:36 <Cale> oh, heh, you did that above :)
11:42:40 <geekosaur> dgpratt, you should have one template haskell installed, in the global packages; it should therefore match ghc because it was installed wigh ghc in the same way base is
11:42:54 <Cale> oldxchatnuts: A functional programming language
11:43:33 <dgpratt> geekosaur: ok thanks; I guess that is likely not my problem, then
11:43:37 <geekosaur> if you want to verify, http://www.haskell.org/ghc/docs/latest/html/libraries/index.html replace "latest" with the ghc version
11:43:45 <Sonderblade> how do you get data.aeson.lens working? afaict, the examples in the doc (http://hackage.haskell.org/packages/archive/aeson-lens/latest/doc/html/Data-Aeson-Lens.html) doesnt work
11:44:06 <edwardk> hrmm, never actually used it
11:44:23 <geekosaur> e.g. http://www.haskell.org/ghc/docs/7.4.1/html/libraries/index.html although I just nticed it doesn;t show the TH version so that's not so helpful :(
11:44:31 <geekosaur> can't make it easy, can they?
11:44:51 <fmap> Sonderblade: doesn't work?
11:45:10 <edwardk> those need to become non-simple indexed lenses
11:45:53 <edwardk> nth :: (FromJSON u, ToJSON v) => Int -> IndexedLens ValueIx (Maybe Value) (Maybe Value) (Maybe u) (Maybe v)
11:45:57 <atriq> Does Haddock expand Template Haskell?
11:46:01 <fmap> I've added some stuff to aeson-lens this evening but haven't tested it apart of "cabal-dev test" yet
11:46:37 <edwardk> fmap is aeson-lens yours?
11:46:45 <fmap> edwardk: nope
11:46:48 <edwardk> ah k
11:47:23 <Nereid> fmap: I was looking at that last night too.
11:47:27 <atriq> edwardk, is lens intended as a complete replacement to data-lens?
11:47:31 <Sonderblade> fmap: i typed in the examples on the ghci prompt and it errored out
11:47:31 <Nereid> yes
11:47:33 <edwardk> atriq: yes
11:47:57 <edwardk> snap 0.10 appears to be switching over
11:48:11 <Phlogistique> over what
11:48:30 <edwardk> Phlogistique: from data-lens to lens
11:48:32 <atriq> What will happen to Control.Category.Product? Did anyone use Control.Category.Product?
11:48:40 <fmap> Sonderblade: works for me. what's the error?
11:48:45 <beaky> http://ideone.com/cZwdPK is there a more elegant way to write this functions?
11:48:58 <beaky> without using lists and sort :D
11:49:05 <beaky> I did it in two lines in C++
11:49:24 <edwardk> first and second are just compositions with _1 and _2, so i don't see the point of them. (***) is alongside
11:49:26 <dgpratt> geekosaur: well, I was grasping at straws with that angle anyways; I just can't figure out why this package won't build
11:49:48 <edwardk> and the names conflict badly with Arrow
11:49:55 <geekosaur> maybe pastebin the failing part (with context) and the error?
11:49:57 <geekosaur> @paste
11:49:57 <lambdabot> Haskell pastebin: http://hpaste.org/
11:50:02 <fmap> edwardk: will you merge aeson-lens into lens?
11:50:02 <tsou> beaky: why are you defining min and max?
11:50:13 <beaky> tsou: they are already in the haskell stdlib?
11:50:22 <dgpratt> one of these days I'm gonna take the time to figure out just exactly what sort of magic cabal is made of
11:50:24 <edwardk> fmap: i'm torn. i kind of like it as an extra package i don't maintain.
11:50:40 <Nereid> I don't think it would make sense to include support for something that's not a standard library.
11:50:42 <edwardk> its also outside of the core competencies of lens. aeson is a specialty domain
11:50:57 <edwardk> everything else i support is a container or generic type of general utility
11:50:57 <dgpratt> geekosaur: actually, I hpasted it yesterday, lemme see if I can find it
11:51:23 <edwardk> and to date i haven't picked up any dependencies lens doesn't need for its own internal plumbing ;)
11:51:37 <Sonderblade> fmap: cannot mix `^.' [infixl 9] and `.' [infixr 9] in the same infix expression
11:51:45 <atriq> edwardk, not even unordered-containers?
11:51:53 <Nereid> Sonderblade: time to update lens
11:51:55 <beaky> I love where
11:52:08 <atriq> By which I mean, is unordered-containers used for lens's internal plumbing?
11:52:11 <edwardk> Sonderblade: ^. has been infixl 8 since a LONG time ago
11:52:27 <edwardk> atriq: unordered-containers makes a huge difference in the performance of the combinators in Data.Data.Lens
11:52:40 <edwardk> it would go from 40% faster than uniplate to 40% slower
11:52:40 <atriq> Ah, okay
11:52:41 <dgpratt> geekosaur: here it is: http://hpaste.org/77426
11:52:52 <Sonderblade> Nereid: is lens-3.1 old?
11:53:04 <Nereid> are you sure you're using lens-3.1?
11:53:18 <tsou> beaky: yes, min and max are in the Prelude no need to define them
11:53:20 <atriq> edwardk, how about filepath?
11:53:31 <edwardk> actually we're on 3.2, but ^. was infixl 9 some time < 1.0
11:53:37 <Sonderblade> Nereid: no idea, either that or data-lens-2.10.2
11:53:53 <edwardk> atriq: i should have stated my case more carefully. its stuff in the platform, or that it needs internally ;)
11:54:04 <atriq> Okay
11:54:12 <atriq> I was having fun there
11:54:12 <Nereid> Sonderblade: find out with -v
11:54:33 <edwardk> i consider the platform to be within its purview as long a the library is of general utility
11:54:38 <Nereid> or
11:54:47 <geekosaur> dgpratt, while the TH errors are not obvious by themselves, the other errors point to the package being a bit old for the version of ghc you have installed
11:55:06 <Sonderblade> Nereid: ?
11:55:20 <Nereid> Sonderblade: ghci should tell you which version of the package it's loading.
11:55:23 <dgpratt> geekosaur: really? I hadn't thought of that possiblity
11:55:32 <geekosaur> that said, I suspect the TH error is because the Paths module is generated by cabal-install, and quite possibly *that* is not realizing that it needs to enable TH
11:56:53 <geekosaur> and seems to be doing a number of other things wrong as well --- looks like cabal-install is confused
11:57:05 <geekosaur> I think you need dcoutts to untangle this :/
11:57:15 <dgpratt> you're saying cabal-install is generating Paths_cabal_dev.hs?
11:57:17 <geekosaur> yes
11:57:40 <dgpratt> not knowing how TH works, exactly, I thought it was TH generating that
11:58:02 <geekosaur> the path mentioend at the start of the compile alerts you to that ([ 7 of 19] Compiling Paths_cabal_dev  ( dist\build\autogen\Paths_cabal_dev.hs, dist\build\cabal-dev\cabal-dev-tmp\Paths_cabal_dev.o ))
11:58:04 <beaky> > exp(3)
11:58:06 <lambdabot>   20.085536923187668
11:58:29 <beaky> :t exp
11:58:31 <lambdabot> Floating a => a -> a
11:58:36 <nand`> hooray, a QuasiQuoter for units
11:58:43 <geekosaur> it's a file generated by cabal-install when a package needs to reference the build information generated by cabal-install
11:58:51 <nand`> type Newton = [u| kg*m/s² |]
11:59:05 <dgpratt> geekosaur: ok, that may prove helpful information, thank you
11:59:24 <johnw> is anyone who works on Hat here?
12:00:25 <Cale> johnw: There are people working on Hat? :)
12:00:37 <johnw> yeah, it just got updated to 2.7.0.7 today
12:00:53 <johnw> but i still can't get it to compile with GHC 7.6.  I've gotten pretty close, though
12:00:54 <beaky> How do I have double cases?
12:00:57 <beaky> double guards*
12:01:11 <johnw>  beaky: you mean, two of them?
12:01:16 <Sonderblade> Nereid: the module is data.lens.lazy but it's quite hard for me to figure out what of the competing lens libraries i've installed that it is
12:01:19 <beaky> nested guards*
12:01:30 <Nereid> Sonderblade: why are you using data-lens?
12:01:34 <johnw> define another function
12:01:40 <edwardk> Sonderblade: that is in data-lens
12:01:42 <johnw> in your where clause
12:02:05 <Sonderblade> ok
12:04:01 <pordan30> are typenats safe to use? it looks like they aren't in ghc yet.
12:04:32 <beaky> @hoogle isEven
12:04:33 <lambdabot> No results found
12:04:36 <beaky> @hoogle even
12:04:37 <lambdabot> Prelude even :: Integral a => a -> Bool
12:04:37 <lambdabot> System.Event data Event
12:04:37 <lambdabot> System.Event data EventManager
12:04:49 <atriq> There doesn't appear to be vector-lens yet
12:05:02 <beaky> @hoogle (Floating a, Integral b) => a -> b
12:05:03 <lambdabot> Prelude ceiling :: (RealFrac a, Integral b) => a -> b
12:05:03 <edwardk> knock yourself out ;)
12:05:03 <lambdabot> Prelude floor :: (RealFrac a, Integral b) => a -> b
12:05:03 <lambdabot> Prelude round :: (RealFrac a, Integral b) => a -> b
12:06:03 <edwardk> :t simple
12:06:04 <lambdabot> SimpleLensLike f s a -> SimpleLensLike f s a
12:06:11 <edwardk> bah, i should have done that differently
12:06:18 <beaky> how do I convert a floating type to an integral type?
12:06:25 <beaky> I want to test if a floating type is even
12:06:41 <edwardk> > round 2.0
12:06:43 <lambdabot>   2
12:06:49 <edwardk> > even (round 2.0)
12:06:50 <lambdabot>   True
12:07:18 <johnw> > floor 2.0
12:07:18 <nand`> isn't ‘round’ a bad idea for that? depends on what you mean by ‘even’ for floating types
12:07:20 <lambdabot>   2
12:07:21 <johnw> > ceiling 2.0
12:07:23 <lambdabot>   2
12:07:29 <nand`> > floor (-2)
12:07:30 <edwardk> nand`: it is a terrible idea for that ;)
12:07:31 <lambdabot>   -2
12:07:32 <nand`> > truncate (-2)
12:07:34 <lambdabot>   -2
12:07:36 <nand`> huh
12:07:44 <nand`> oh right, -2 is integral either way
12:07:46 <Nereid> lol
12:07:51 <nand`> > (floor (-2.5), truncate (-2.5))
12:07:53 <lambdabot>   (-3,-2)
12:08:08 <johnw> > (round (-2.5), floor (-2.5), ceiling (-2.5), truncate (-2.5))
12:08:10 <lambdabot>   (-2,-3,-2,-2)
12:08:16 <johnw> > (round (2.5), floor (2.5), ceiling (2.5), truncate (2.5))
12:08:18 <lambdabot>   (2,2,3,2)
12:08:36 <johnw> why does round 2.5 == 2?
12:08:40 <nand`> nearest even?
12:08:46 <edwardk> beaky: the issue is a floating point may have sufficient inaccuracy that it may not have integer resolution at the scale it is at. also what do you mean by even here? if it is 1.99999999    close enough to 2 to count?
12:08:47 <nand`> not sure, actually
12:08:50 <edwardk> > round 2.5
12:08:51 <lambdabot>   2
12:08:52 <edwardk> > round 3.5
12:08:53 <lambdabot>   4
12:08:56 <beaky> right
12:08:59 <nand`> > round 1.5
12:09:01 <lambdabot>   2
12:09:03 <edwardk> round-to-even semantics
12:09:05 <danr> what's it called? bank rounding?
12:09:06 <beaky> I want to implement a pow function
12:09:08 <nand`> yeah
12:09:09 <johnw> must have to do with the actual binary fraction?
12:09:23 <edwardk> :t (^)
12:09:24 <lambdabot> (Integral b, Num a) => a -> b -> a
12:09:25 <edwardk> :t (^^)
12:09:26 <lambdabot> (Fractional a, Integral b) => a -> b -> a
12:09:27 <edwardk> :t (**)
12:09:27 <Nereid> > even (round (3^20 :: Double))
12:09:28 <lambdabot> Floating a => a -> a -> a
12:09:29 <lambdabot>   False
12:09:43 <Nereid> > even (round (3^30 :: Double))
12:09:44 <edwardk> we have 3. you need another? =)
12:09:45 <lambdabot>   False
12:09:47 <johnw> > round (2.5) :: Double
12:09:49 <lambdabot>   No instance for (GHC.Real.Integral GHC.Types.Double)
12:09:50 <lambdabot>    arising from a use ...
12:09:56 <Nereid> > even (round (3^40 :: Double))
12:09:58 <lambdabot>   True
12:10:00 <Nereid> ;D
12:10:18 <nand`> ugh; why can't type synonyms be promoted to kind synonyms?
12:10:20 <Jafet> > even (round (1/0))
12:10:23 <lambdabot>   True
12:10:25 <nand`> writing out large kinds a lot gets tedious
12:10:45 <Jafet> {-# LANGUAGE CPP #-}
12:10:46 <Nereid> Jafet: what.
12:10:47 <danr> > round (1/0) -- curious
12:10:48 <Nereid> > round (1/0)
12:10:49 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:10:50 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:10:52 <Nereid> whoa.
12:10:54 <Nereid> what.
12:11:04 <Nereid> > 1/0
12:11:05 <johnw> round (2.5) in sage is correctly 3, so that is somewhat irksome
12:11:05 <lambdabot>   Infinity
12:11:15 <Jafet> @quote 2.1024
12:11:16 <lambdabot> glguy says: Hmm, for next Halloween, he could dress up as someone who recognizes 2^1024 on sight!
12:11:19 <Nereid> > round (2.5 :: Double)
12:11:20 <lambdabot>   2
12:11:22 <edwardk> hrmm i think simple :: SimpleLens a a    might be a nicer simple than the simple i provide in lens
12:11:24 <Nereid> hmm
12:11:29 <johnw> I would call that a bug
12:11:34 <Jafet> @quote and.beyond
12:11:34 <lambdabot> identity says: "To " ++ (show $ log (2^1024)) ++ " and beyond!"
12:11:46 <mauke> johnw: how is round 2.5 == 3 correct?
12:12:00 <johnw> the same way that round 3.5 == 4
12:12:10 <mauke> no, that's a different way
12:12:16 <mauke> 3 is not even
12:12:18 <c_wraith> mauke: it's correct by gradeschools that teach "rounding a decimal part of .5 is always up"
12:12:19 <Nereid> some people round half-integers up, some people round half-integers to the nearest even integer
12:12:47 <johnw> Nereid: I'd never even heard of the latter
12:12:54 <Nereid> no?
12:13:01 <johnw> not in any other language I've ever used, no
12:13:01 <Jafet> > abs (3 - 2.5) == abs (2 - 2.5)
12:13:03 <lambdabot>   True
12:13:18 <johnw> from the documentation for Haskell's round: "round x returns the nearest integer to x; the even integer if x is equidistant between two integers"
12:13:32 <johnw> so, interesting
12:13:44 <Jafet> More importantly: why do you care
12:13:51 <johnw> who, me?
12:14:05 <Nereid> "round x returns the nearest integer to x; the even integer if x is equidistant between two integers "
12:14:09 <Nereid> oh
12:14:12 <johnw> because every other round I've used would round 2.5 to 3, so that builds in an expectation which means my algorithms would have been wrong; but now I know
12:14:17 <Jafet> schoolRound x = floor $ x + 0.5
12:14:29 <Nereid> Jafet: what about negative numbers?
12:14:49 <Nereid> python rounds half-integers away from 0.
12:14:58 <johnw> which explains the sage behavior
12:15:03 <c_wraith> no one rounds negative numbers. It's just not done!
12:15:05 <beaky> what do I do if getLine returns EOF?
12:15:15 <Jafet> I round up numbers
12:15:16 <Nereid> wait.
12:15:23 <Nereid> python 2 rounds away from 0. python 3 rounds to the nearest even.
12:15:34 <Jafet> beaky: it can't. EOF is not a String
12:15:39 <Nereid> stupid python. :p
12:15:41 <beaky> ah
12:15:50 <beaky> how do I handle EOF?
12:15:54 <Jafet> You might receive an IOException
12:16:41 <c_wraith> Jafet: do you brand them after you've rounded them up?
12:16:59 <johnw> lol
12:17:15 <Jafet> Brand them with what
12:17:19 <Jafet> Numbers?
12:17:37 <c_wraith> Hot irons, usually.
12:17:37 <beaky> http://ideone.com/DXkN89 how do I impove the style of this program?
12:17:44 <beaky> also how do I implement my own power function?
12:17:47 <c_wraith> So you know who they belong to.
12:18:16 <neutrino> what is this "round to the nearest even" behaviour motivated with?
12:18:19 <neutrino> hi c_wraith
12:18:41 <johnw> beaky: pow x y = product (replicate y x)
12:18:48 <dmwit> beaky:
12:18:49 <Cale> johnw: Round-to-even is a sensible way to handle rounding, because it helps reduce bias in most cases.
12:18:50 <dmwit> ?src (^)
12:18:50 <lambdabot> x ^ 0            =  1
12:18:50 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
12:18:50 <lambdabot>   where f _ 0 y = y
12:18:50 <lambdabot>         f x n y = g x n
12:18:50 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
12:18:51 <c_wraith> it's something to do with eliminating biases in certain statistical cases
12:18:52 <lambdabot>                       | otherwise = f x (n-1) (x*y)
12:18:54 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
12:19:03 <beaky> @src (**)
12:19:04 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:19:06 <beaky> :(
12:19:11 <Jafet> The average (hah!) rounding is zero
12:19:13 <beaky> I want teh floating version :D
12:19:26 <neutrino> Jafet: ah
12:19:30 <neutrino> makes sense
12:19:31 <Jafet> x ** y = exp (log x * y)
12:19:38 <johnw> oh, cool
12:19:41 <johnw> i didn't know about that rule
12:19:46 <atriq> Well, I've made an indexed traversable for Vector
12:19:51 <Nereid> johnw: then how do you define powers?
12:19:56 <johnw> Nereid: I don't
12:19:58 <Nereid> lol
12:20:00 <Cale> johnw: Which one? The round-to-even rule?
12:20:06 <johnw> no, the exp log *
12:20:08 <dmwit> beaky: It's a class method.
12:20:12 <beaky> ah
12:20:15 <atriq> Actually looks quite neet
12:20:16 <Cale> oh, that's usually taken as the definition
12:20:18 <atriq> *neat
12:20:19 <johnw> i knew about exp log + :)
12:20:30 <Cale> (of exponentiation)
12:20:34 <Jafet> Nereid: anyone with ICBMs
12:20:35 <beaky> its an identity
12:20:43 <atriq> traverseVector = index (\f v -> uncurry f `traverse` indexed v)
12:20:44 <Nereid> Jafet: lol
12:20:46 <beaky> since x = exp(log(x))
12:20:50 <atriq> That's Data.Vector.indexed, btw
12:20:56 <atriq> I had to hide the one from Control.Lens
12:21:00 <Nereid> beaky: it's usually taken as a definition that x^a = exp(a log(x))
12:21:04 <Jafet> @src Double (**)
12:21:05 <lambdabot> Source not found. Sorry.
12:21:05 <Cale> It defines x^y when y is positive and real.
12:21:12 <atriq> Haven't tested efficiency or anything yet
12:21:16 <int-e> Cale: x :)
12:21:23 <Cale> er, yes, x
12:21:30 <Nereid> > (0 :+ 1) ** (0 :+ 1)
12:21:32 <lambdabot>   0.20787957635076193 :+ 0.0
12:21:42 <Cale> Or maybe I meant to type y^x, either way ;)
12:22:07 <Cale> The one you take the log of obviously needs to be positive
12:22:15 <edwardk> :t indexed traverse
12:22:16 <lambdabot> (Applicative f, Traversable t, Indexed Int k) => k (a -> f b) (t a -> f (t b))
12:22:24 <Nereid> Cale: unless you aren't scared of complex numbers.
12:22:36 <int-e> there's another approach - for a > 0, define for rational numbers, then extend it to a continues function.
12:22:39 <edwardk> atriq: you can just use that
12:22:42 <atriq> I could!
12:22:44 <c_wraith> complex numbers are too complicated for me.
12:22:46 <int-e> uhm. define a^x for rational x :)
12:22:46 <atriq> But I didn't!
12:22:49 <Nereid> int-e: then implement n'th roots
12:22:52 <edwardk> =)
12:22:53 <beaky> @hoogle CReal
12:22:53 <lambdabot> No results found
12:22:57 <Cale> Nereid: Of course, if you're already dealing with complex numbers, you probably don't need to be told about this.
12:23:29 <int-e> Nereid: sure. Hey I never suggested to *implement* that.
12:23:34 <Nereid> lol
12:24:07 <edwardk> atriq: i'm thinking about adding the instances for lens classes like TraversableWithIndex to vector-instances. if you are packaging some lenses for vector, would you object to depending on that package to 'infect' your code with those instances?
12:24:13 <Cale> int-e: Well, log and exp come out of the natural way to attempt to extend that function to a differentiable one anyway.
12:24:15 <sipa> @pl \(or,oxs) -> (or,x:oxs)
12:24:16 <lambdabot> second (x :)
12:24:18 <edwardk> atriq: not sure what other lenses you were thinking about
12:24:20 <int-e> Nereid: there's one slight advantage (at least in the context that I learned this, which was at highschool) - you never have to define e.
12:24:32 <atriq> edwardk, I'm just messing around, I'll be honest
12:24:36 <edwardk> kk
12:24:36 <atriq> I haven't yet reached serious
12:24:37 <Nereid> int-e: it works for any base
12:24:42 <Nereid> although
12:25:00 <Nereid> int-e: you have to be careful not to be circular: you can't define x^a = e^(a log(x)) if you haven't defined e^(-)
12:25:04 <int-e> Nereid: well you won't get logs until you define an exponential for *some* base :)
12:25:15 <Nereid> but you don't need e to define exp
12:25:28 <int-e> I know. But back then at high-school I didn't.
12:25:40 <Cale> The natural logarithm pops out in the discussion of how to make that extension, unless you cheap out and just define it as a certain supremum (which will be immediately painful as soon as you try to get almost any properties of the thing)
12:25:58 <Nereid> what supremum?
12:26:14 <Nereid> define x^y for rational y, show it's continuous in y, and then it extends uniquely to the reals.
12:26:43 <Nereid> although showing continuity sounds annoying.
12:26:47 <int-e> x^y = sup { x^y' | y' < y and y' real }
12:26:56 <Nereid> or y' rational
12:26:59 <int-e> meh. I mean rational.
12:27:02 <yitz> n
12:27:15 <Nereid> that also doesn't work if x < 1
12:27:34 <int-e> indeed.
12:27:38 <Cale> Yeah, it's annoying.
12:27:41 <int-e> so better use a limit :)
12:27:49 <Nereid> better use a universal property
12:29:01 <Nereid> i.e. for a complete metric space Y, there's a bijection between continuous maps R -> Y and continuous maps Q -> Y
12:29:04 <int-e> there's a reason why all the basic math is taught at least twice from school to university :)
12:29:13 <Cale> If you suppose there's a differentiable function f such that f(x + y) = f(x) f(y), then you can examine properties of its derivative.
12:29:23 <tac-nap> int-e: why's that?
12:29:40 <Nereid> Cale: or you could just start with my favourite definition: exp is the unique solution to exp(0) = 1, exp' = exp
12:30:05 <Nereid> and then many properties of exp become obvious
12:30:11 <Cale> and you'll see that f'(x) = limit as h -> 0 of (f(x + h) - f(x))/h = limit as h -> 0 of (f(x) f(h) - f(x))/h = f(x) (limit as h -> 0 of (f(h) - 1)/h) = f(x) f'(0)
12:30:57 <Nereid> e.g. for each a, there exists c such that for all x, exp(x + a) = c exp(x). (because x -> exp(x+a) also solves f' = f, so it's a multiple of exp)
12:31:01 <tac-nap> Nereid: the problem with that definition is that it assumes uniqueness of the solution. Don't you have to prove that separately?
12:31:02 <Nereid> then clearly c = exp(a) by putting x = 0
12:31:09 <Nereid> tac-nap: general theory of ODEs does it.
12:31:49 * tac-nap has never seen a personally satisfying foundation for ODEs.
12:31:50 <Nereid> picard-lindeloef or something
12:31:53 <Cale> and then if you suppose that f might be invertible, and consider the derivative of the inverse, you see that (f^-1)'(x) = 1/(f'(f^-1(x)) = 1/(f'(0) f(f^-1(x))) = 1/(f'(0) x)
12:31:57 <int-e> tac-nap: One reason is that (in my opinion) you need to know a lot of math to motivate the dry axiomatic approach that one learns later on.
12:32:05 <johnw> wow, all this just from asking for a power function :)
12:32:09 <tac-nap> int-e: I can agree with that.
12:32:12 <johnw> that's true #haskell for you :)
12:32:24 <Nereid> johnw: but it means you can compute x^y by numerically solving an ODE
12:32:28 <Nereid> :p
12:32:34 <johnw> what is an ODE?
12:32:36 <tac-nap> johnw: it's because Haskell was invented by category theorists :P
12:32:39 <neutrino> ordinary diff eq
12:32:41 <Nereid> ordinary differential equation
12:32:45 <neutrino> first!
12:32:46 <Cale> and from there it's natural to go at it by integration
12:32:50 <tac-nap> neutrino: :<
12:32:51 <int-e> Nereid: you cheated :)
12:32:51 <neutrino> :)
12:32:57 <Cale> and you get the integral definition of the logarithm
12:32:58 <Nereid> how?
12:33:11 <int-e> Nereid: I meant neutrino, bad tab completion.
12:33:14 <Nereid> oh
12:33:21 <int-e> sorry.
12:33:22 <Nereid> yes, cheated :(
12:33:32 <ParahSail1n> internal error: evacuate(static): strange closure type 17
12:33:37 <tac-nap> johnw: it's what happens when you say f(x) = f(x)' + f(x)'', for all x, what values of f satisfying this equation?
12:33:41 <Cale> f'(0) being arbitrary, it's sensible to just choose it to be 1
12:33:48 <int-e> ParahSail1n: fun.
12:34:01 <Nereid> Cale: no, choose f(0) to be 1.
12:34:13 <int-e> ParahSail1n: what's the ghc version?
12:34:24 <Cale> Nereid: Well, that will happen immediately
12:35:01 <yitz> tac-nap: no the category theory connection was noticed only later.  But there is something to that.
12:35:04 <Nereid> yes, but you don't specify initial conditions for a first-order ODE by giving a value of the derivative.
12:35:12 * hackagebot vector-instances 3.1 - Orphan Instances for 'Data.Vector'  http://hackage.haskell.org/package/vector-instances-3.1 (EdwardKmett)
12:35:18 <Cale> Because f'(x) = f'(0) f(x), from above, and so f'(0) = f'(0) f(0)
12:35:45 <Cale> Nereid: I'm not using the full theory of ODEs
12:35:45 <Nereid> Cale: what?
12:35:56 <ParahSail1n> 7.4.1
12:35:57 <atriq> edwardk, what's the point of Data.List.Lens.traverseHead?
12:35:59 <edwardk> atriq: that package exposes TraversableWithIndex, etc. instances for Data.Vector
12:36:06 <ParahSail1n> 7.4.2
12:36:07 <edwardk> atriq: how do you do it otherwise?
12:36:09 <neutrino> yeah, f(0) == 1 is a simple corollary
12:36:17 <Nereid> of what
12:36:21 <edwardk> > traverseHead %~ toUpper $ "hello"
12:36:23 <lambdabot>   Not in scope: `traverseHead'
12:36:23 <lambdabot>  Perhaps you meant one of these:
12:36:23 <lambdabot>    `traverseM...
12:36:30 <ParahSail1n> should i upgrayyedd?
12:36:31 <edwardk> > Data.List.Lens.traverseHead %~ toUpper $ "hello"
12:36:33 <lambdabot>   Not in scope: `Data.List.Lens.traverseHead'
12:36:33 <lambdabot>  Perhaps you meant `Data.Bits.L...
12:36:38 <Nereid> what's f
12:36:42 <Cale> Just supposing that f is a differentiable function with the desired property that f(x + y) = f(x) f(y), and then analysing its derivative and the derivative of its inverse (supposing that exists)
12:36:46 <Nereid> oh, that.
12:36:56 <Nereid> I thought we were talking about saying f' = f.
12:37:01 <edwardk> anyways if lambdabot exposed that, it'd uppercase to "Hello"
12:37:13 <Nereid> Cale: anyway, no need to assume it's differentiable. continuous suffices.
12:37:22 <Cale> Well, f' = f isn't an obvious property of an exponential map unless you already know that :)
12:37:36 <atriq> edwardk, it's a weaker version of _head, as far as I can see
12:37:40 <edwardk> atriq: i'm not saying its a great pattern to duplicate
12:37:46 <Nereid> atriq: it's a safer version of _head
12:37:52 <atriq> Ah, okay
12:37:53 <edwardk> manipulating _head on an empty list crashes
12:37:55 <Sonderblade> how do you convert a LazyByteString to a String?
12:38:05 <edwardk> _head is partial
12:38:05 <Nereid> Sonderblade: unpack
12:38:14 <Cale> But f(x + y) = f(x) f(y) is something which is satisfied by the exponential functions with integer and rational domains
12:38:16 <nand`> Can I assign fixivity declarations to type operators?
12:38:19 <Nereid> or decodeUtf8, or ...
12:38:23 <edwardk> nand`: yes
12:38:26 <atriq> Makes sense
12:38:39 <Cale> and if you only assume continuity, you don't get as much information about the properties of the thing you're after
12:38:43 <Sonderblade> Nereid: it converts it to [GHC.Word.Word8] not [Char]
12:38:52 <nand`> edwardk: what's the default fixivity?
12:39:09 <Cale> (you don't get to discover that f'(x) = f'(0) f(x) so easily)
12:39:10 <edwardk> infixl 9 i think
12:39:15 <Nereid> Sonderblade: decodeUtf8 then?
12:39:16 <nand`> ouch, that's fairly high
12:39:21 <edwardk> yep
12:39:48 <Nereid> Cale: showing existence is hard
12:39:57 <Nereid> well, not very
12:40:00 <Cale> It's not hard if you do it right
12:40:03 <Nereid> but you can't appeal to something general
12:40:24 <Cale> You use the fundamental theorem of calculus and the continuity of 1/x
12:40:41 <Cale> (at least, the first time you do this :)
12:40:43 <Nereid> what?
12:40:45 <Sonderblade> Nereid: in what module?
12:40:54 <Nereid> Sonderblade: I dunno, ask hoogle
12:41:12 <Sonderblade> @hoogle decodeUtf8
12:41:13 <lambdabot> Data.Text.Encoding decodeUtf8 :: ByteString -> Text
12:41:13 <lambdabot> Data.Text.Lazy.Encoding decodeUtf8 :: ByteString -> Text
12:41:13 <lambdabot> Data.Text.Encoding decodeUtf8' :: ByteString -> Either UnicodeException Text
12:41:18 <int-e> ParahSail1n: it's not 100% clear that it's ghc's fault. 17 is THUNK_1_0, hmm. That's indeed not a static closure.
12:41:29 <Nereid> uh Sonderblade
12:41:35 <Nereid> there's an unpack that gives you a string
12:41:39 <Nereid> @hoogle ByteString -> String
12:41:40 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
12:41:40 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
12:41:40 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
12:42:04 <Nereid> there's a difference between unpack and decodeUtf8 though.
12:42:04 <ParahSail1n> int-e: so what does it mean
12:42:28 <Nereid> the first maps bytes to characters one-to-one, so you'll only get Chars between chr 0 and chr 255
12:42:35 <Cale> Nereid: Well, based on the analysis of the inverse function that I gave above, we know that f^-1, if it exists and is differentiable, has the property that its derivative is 1/(f'(0) x), and if at that point we just assume f'(0) = 1, we know how to get a function whose derivative satisfies this.
12:42:58 <Cale> (by simply integrating)
12:43:36 <Nereid> Cale: oh fine, if you assume differentiability.
12:43:47 <yitz> tac-nap: haskell curry, who invented combinator theory, and after whom haskell is named, and saunders maclane, who invented category theory, were two americans who both did their phds in mathematical logic around the same time in Goethingen.
12:43:57 <Cale> Nereid: Well, you work backwards a short bit, and then prove differentiability almost by construction
12:44:09 <Sonderblade> Nereid: none of them appears to work on Data.ByteString.Lazy.Internal.ByteString
12:44:31 <Cale> Nereid: because you end up defining log x = integral from 1 to x of 1/t dt
12:44:43 <neutrino> hey guys, can i tell djinn about list types?
12:44:55 <int-e> ParahSail1n: well, during GC, the collector found a pointer that does not belong to the heap (as far as the runtime system knows), but is actually a dynamically allocated thunk.
12:44:58 <yitz> it's hard to imagine that they didn't know of each other.
12:45:00 <neutrino> i want to generate a function of the type [(a, b)] -> a for example
12:45:15 <Cale> Nereid: and then proving that this is monotone and continuous (not hard), and unbounded (slightly trickier), and so has an inverse R -> R+
12:45:20 <Nereid> Cale: sure.
12:45:28 <Nereid> then you just show that its inverse has the desired property.
12:45:39 <int-e> ParahSail1n: which indicates that the check goes wrong ... is this 32 bit or 64 bit?
12:45:49 <Nereid> Sonderblade: even the Lazy one?
12:45:57 <Cale> Nereid: which you basically already know is going to happen because of the way that you came to the definition in the first place :)
12:46:09 <geekosaur> neutrino, I think djinn doesn't support recursive types?
12:46:18 <neutrino> is a list recursive?
12:46:23 <Nereid> yes
12:46:27 <neutrino> oh, bollocks
12:46:29 <neutrino> that sucks
12:46:34 <Sonderblade> Nereid: oh Data.ByteString.Lazy.Char8.unpack is the right one, but dropping non-ascii is not what i want
12:46:37 <neutrino> totally needs to be fixed
12:46:39 <Nereid> there is no function of type [(a,b)] -> a, by the way
12:46:49 <Cale> neutrino: A list is either empty or consists of a single element followed by *another list*
12:46:51 <neutrino> are you suuuuuuuuuuuure
12:46:58 <neutrino> because i think there are many
12:47:03 <Nereid> Sonderblade: it doesn't drop non-ascii
12:47:04 <neutrino> Cale: yeah
12:47:08 <Cale> neutrino: Not in djinn's sense
12:47:11 <Nereid> Sonderblade: it just does the same dumb thing you'd do in C
12:47:15 <neutrino> Cale: right, yeah
12:47:15 <Nereid> as an array of chars
12:47:21 <int-e> ParahSail1n: (I have an idea how this could not be ghc's fault but it involves someone giving out a pointer to a haskell closure to foreign code, and later handing it back. or possibly turing a pointer to a heap object into a word (integer) and back, using unsafeCoerce)
12:47:22 <Cale> neutrino: What would such a function do to []?
12:47:41 <Cale> neutrino: It has to invent a value of type a, but doesn't know anything about a.
12:47:42 <pordan30> there is the constant function for inhabited types a
12:47:44 <ParahSail1n> int-e: i've done what it asked http://hackage.haskell.org/trac/ghc/ticket/7400
12:47:46 <int-e> ParahSail1n: both of which is quite wacky
12:47:52 <Nereid> pordan30: polymorphic in a?
12:48:03 <Nereid> you aren't allowed to pick a.
12:48:14 <Nereid> I'm alloewd to pick a.
12:48:23 <Nereid> so I pick a = Void.
12:48:25 <Nereid> and you lose.
12:48:42 <beaky> hello
12:48:46 <Nereid> hello
12:48:56 <atriq> Hey
12:48:59 <johnw> is there a category theory channel?
12:49:05 <Cale> yes
12:49:08 <Cale> ##categorytheory
12:49:11 <Nereid> that exists??
12:49:14 <Cale> yes
12:49:16 <Nereid> lol
12:49:56 <yitz> #haskell-in -depth. :)
12:49:57 <Sonderblade> Nereid: well.. I'd never do it that like that in c. decoding the strings is the right way
12:50:01 <pordan30> Nereid: i see, so there is only a function from Inhabited a => [(a,b)] -> a
12:50:12 <nand`> hmm
12:50:15 <int-e> ParahSail1n: what kind of input does that take?
12:50:23 <nand`> aesthetic question; what operator would you like for ‘tag this number with this unit’?
12:50:39 <Nereid> Sonderblade: time to use decodeUtf8 then, or something from text-icu if you want a different encoding
12:50:51 <Nereid> nand`: multiplication
12:51:00 <nand`> to be used with a quasiquoter, eg. 123<>[u|kg/ms²|] where <> is the operator in question
12:51:09 <fmap> ×
12:51:10 <nand`> Nereid: that already works, 123*newton
12:51:18 <Jafet> :::
12:51:21 <Nereid> so 123 * [u|kg/ms^2]
12:51:24 <Nereid> |]
12:51:50 <nand`> I uh, actually, yes, that's better than what I had planned
12:51:53 <Nereid> haha
12:52:08 <nand`> I was planning on using a singleton type and stuff but you made me realize I could just generate a ‘U 1’ with the correct type
12:52:19 <Nereid> pordan30: another name for Inhabited is Pointed
12:52:23 <Nereid> class Pointed a where point :: a
12:52:55 <nand`> Nereid: most importantly, less work for me :)
12:52:59 <ParahSail1n> int-e: you can feed it a file where odd numbered lines are an integer, and even numbered lines are any string
12:53:01 <Nereid> nand`: and a better result
12:53:39 <Nereid> it would be nice if we had some sort of GradedAlgebra thing though
12:53:41 <int-e> ParahSail1n: so  seq 1000 | ./Resample  would crash?
12:54:20 <ParahSail1n> int-e: possibly
12:54:31 <yitz> nand`: +@¶ ("tag")
12:54:33 <Nereid> and then a dimensioned quantity would be an element of the free graded algebra having kg, m, s, ... as invertible elements
12:54:47 <Nereid> (and having certain gradings)
12:55:03 <ParahSail1n> it crashes on files that are millions of lines long, not sure if it behaves correctly otherwise
12:55:05 <Jafet> > generalCategory '¶'
12:55:06 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
12:55:58 <Nereid> lol
12:56:07 <Nereid> hmm
12:56:24 <Nereid> there's a meeting in the room next door, and they have pizza. I hope there are leftovers.
12:56:27 <harovali> hi, is there any tool that you feed it with structured text, and
12:56:27 <harovali> 	   tries to guess a syntax to which that fed text complies?
12:56:49 <harovali> there might be a refining step by step process,
12:57:01 <Nereid> without any previous knowledge of possible syntaxes?
12:57:24 <harovali> in which one continues feeding structured text that presumably complies with the same syntax, so helping the derivaiton,
12:57:26 <Nereid> grammars
12:57:30 <harovali> Nereid: yes
12:57:40 <Nereid> ok, I write you a grammar that produces every string.
12:57:44 <harovali> Nereid: I mean, deriving grammars
12:57:52 <yitz> harovali: oeis does that with numbers
12:57:52 <Nereid> but that's not interesting.
12:57:54 <harovali> Nereid: I'm serious
12:57:59 <Nereid> I know what you want to do.
12:58:03 <Nereid> roughly.
12:58:07 <Nereid> sounds hard, though
12:58:12 <harovali> fine
12:58:13 <harovali> yes I know
12:58:26 <Jafet> yitz: I wish
12:58:36 <harovali> I imagine some sort of comparison tool, that goes granularily thru the texts,
12:58:40 <Nereid> yitz: oeis just searches a huge database
12:58:56 <harovali> produces some lexical analysis automaticall,
12:59:05 <yitz> Nereid: yes
12:59:16 <Nereid> sounds very different from what harovali wants
12:59:21 <harovali> and the lets the user interact with a token analyzing and pairing thing
12:59:32 <Nereid> ah, interactive.
12:59:44 <harovali> Nereid: yes you're right,
12:59:51 <harovali> yitz: I don't mean full text search
12:59:56 <Nereid> sounds slightly less hard
13:00:06 <yitz> harovali: google translate does it with human language
13:00:08 <harovali> Nereid: the interactivity is optional, but may be useful
13:00:08 <tac-nap> yitz: interesting nugget of history :)
13:00:20 <harovali> yitz: yes I know
13:00:26 <int-e> ParahSail1n: wow, how much memory are you throwing at that program?
13:01:32 <harovali> Sort of a "token diff" that lets one pair and chain tokens, with variable stuff in-between
13:01:36 <int-e> ParahSail1n: oh. I missed uncollapse. so seq 100000 | ... is a bit too much.
13:01:40 <harovali> producing a parser
13:02:06 <int-e> @type uncurry replicate
13:02:08 <lambdabot> (Int, b) -> [b]
13:03:18 <yitz> unix file command does it with binary file formats. As Nereid says allmy examples are db searches.
13:03:36 <harovali> I've been browsing thru a project called moose
13:03:39 <Jafet> file also looks up a database
13:04:17 <int-e> ParahSail1n: and do you also have the effect that compiling with -O makes the program *much* slower?
13:04:18 <harovali> which seems a very interesting reengineering tool which tries to help with the syntax transforms
13:05:02 <harovali> I just wondered whether in the haskell ecosystem there was something alike, since the best parsing library is in haskell imho
13:05:26 * yitz is typing to irc from a tablet for the first time. This is difficult and slow.
13:05:30 <ParahSail1n> int-e: i only tried O2
13:05:33 <Sonderblade> @hoogle openUrl
13:05:33 <lambdabot> No results found
13:06:07 <int-e> ParahSail1n: -O2 also makes it slower for me. (it feels like it's recomputing the whole vector each time.)
13:06:16 <int-e> ParahSail1n: (but I have not checked the code)
13:06:50 <ParahSail1n> strace shows it does a ton of clock_gettime()
13:06:51 <rudyl313> the following line: putStrLn "בני ברק" ... generates an error: "hPutChar: invalid argument (invalid character)" ... can anybody help?
13:08:19 <int-e> ParahSail1n: So, I have no crashes so far (but I can only test ghc 7.4.1 and 7.6.1 atm.) I'm using vector-0.9.1 with ghc-7.4.1 and vector-0.10.0.1 with ghc 7.6.1; both with mersenne-random-1.0.0.1
13:08:21 <Jafet> rudy: what happens when you replace putStrLn by print?
13:08:52 <int-e> ParahSail1n: (on linux and x86_64, so that should be the same)
13:09:13 <rudyl313> Jafet: it prints it as "\1489\1504\1497 \1489\1512\1511"
13:09:45 <nand`> hrm
13:09:50 <Jafet> You probably need to use a locale that actually contains hebrew script
13:10:08 <nand`> when writing a program I often have a separate module ‘Types.hs’ to avoid having to break my head over module dependencies
13:10:17 <rudyl313> Jafet: the strange thing I'm facing is when I putStrLn a variable that holds that hebrew string it prints it correctly as the hebrew string
13:10:19 <int-e> ParahSail1n: and bytestring is at versions 0.9.2.1 and 0.10.0.0, respectively.
13:10:19 <nand`> but when programming at the type level, should I rename that Kinds.hs?
13:10:30 <rudyl313> Jafet: the variable came from an api call
13:10:38 <int-e> ParahSail1n: any of those packages could be responsible besides ghc's runtime itself
13:10:41 <yitz> rudyl313: it's because internet use is discouraged in bnei brak
13:10:47 <Nereid> rudyl313: so if you write x = "בני ברק", then putStrLn x works?
13:11:05 <DanBurton> when I copy/pasted `putStrLn "בני ברק"' it worked fine, ghci 7.4.1
13:11:24 <Nereid> rudyl313: does it work in ghci but not in a compiled program? etc.
13:11:32 <geekosaur> rudyl313, your error is that there's a locale mismatch somewhere.  ghc generally is happiest when your locale is set to something UTF-8ish
13:11:42 <Nereid> yes, I suspect a locale thing too.
13:11:48 <rudyl313> Nereid: it doesn't work
13:12:09 <rudyl313> geekosaur: I checked the locale of my ubuntu machine and it's UTF-8
13:12:29 <rudyl313> is there a way to manually set the locale of ghc?
13:12:51 <rudyl313> I also checked the encoding of my source file and it says UTF8 too
13:13:03 <nand`> How do I mention a type operator in an export list? I have a type named (*) which I'm trying to export; but it doesn't seem to be working - I think it's exporting the Prelude.*
13:13:10 <Nereid> rudyl313: you can find out what encoding it's using with System.IO.localeEncoding
13:13:30 <Nereid> nand`: you have a type named (*)? disgusting
13:13:46 <geekosaur> hm, don;t type operators need to be prefixed with :?
13:13:47 <Nereid> (that even works?0
13:13:58 <Nereid> I thought so.
13:14:00 <nand`> of course it works
13:14:10 <rudyl313> Nereid: "ISO-8859-1"
13:14:18 <Nereid> rudyl313: that's the problem then
13:14:27 <Nereid> ISO-8859-1 can't encode hebrew.
13:14:31 <rudyl313> Nereid: great! I'm getting somewhere
13:14:35 <nand`> geekosaur: no, only constructors
13:14:38 <rudyl313> Nereid: so how do I change that?
13:14:40 <nand`> that is, on the value level
13:15:04 <nand`> oh, it works like this: (*)()
13:15:05 <Nereid> rudyl313: run your program in a better locale
13:15:15 <Nereid> nand`: heh
13:15:49 <rudyl313> Nereid: from the shell: $ locale.... outputs  "LANG=en_US.UTF-8..."
13:15:54 <Jafet> (*)() is like a C++ism
13:16:13 <ParahSail1n> int-e: weird, so sometimes O2 just messes up
13:16:31 <Nereid> rudyl313: and running the program with LC_ALL=en_US.UTF-8 doesn't change anything?
13:17:24 <rudyl313> Nereid: fixed!! thanks so much for the help
13:17:37 <Nereid> if that fixed it, you should probably look into fixing your OS configuration
13:18:19 <rudyl313> Nereid: not sure how to do that.. but I'll do some googling
13:18:23 <int-e> ParahSail1n: so I tried seq 20000 | ./Resample ... but I have not seen any crashes, just this strange slowdown, which goes away if I add -fno-state-hack to the compiler options.
13:19:37 <DanBurton> -fno-state-hack? o_O
13:20:02 <Jafet> I don't know what a state hack is, but I wouldn't want one either
13:20:03 <int-e> DanBurton: yes, wonderful, isn't it?
13:20:35 <ParahSail1n> hax
13:20:57 <DanBurton> what on earth *is* this state hack, and why is it included if turning it off makes something better?
13:23:24 <int-e> http://hackage.haskell.org/trac/ghc/ticket/1168 has an interesting discussion about the state hack (in particular, spj says that switching the hack off would be bad because a lot of programs profit from it.)
13:24:22 <DanBurton> interesting; I also found the ghc docs on it: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/options-optimise.html#options-f
13:26:34 <DanBurton> some of these option names make me laugh. -fpedantic-bottoms :)
13:27:45 <Nereid> I always read -funbox-strict-fields as "fun box"
13:27:46 <mcstar> yeah, that f is weird
13:28:19 <kmels> hello, anyone familiar with virthualenv? I'm getting this message if I try to use cabal cabal: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with Cabal
13:28:33 <Jafet> gcc -Larry -Wall -malign-double
13:28:41 <edwardk> Nereid: I think I noted the other day that -fundecidable-instances are neither fun nor decidable.
13:28:48 <Nereid> lol
13:28:53 <c_wraith> I thought double was pretty maligned already
13:30:17 <nand`> hmm, I still can't figure out a way to get rid of this ugly n:  n 5 * [u|some*unit^2|]
13:30:41 <c_wraith> nand`: try backspace?
13:30:42 <otters> is there anything in the standard library that will threadDelay for a time span longer than (maxBound :: Int) microseconds?
13:30:54 <Nereid> nand`: what do you need the n for?
13:31:00 <nand`> n :: a -> a :@ One; I thought I could just write an instance Num a => Num (a :@ One) to have literals be injectable into that type automatically, but it fails with ambiguous type errors when I try actually using it
13:31:10 <c_wraith> otters: nope. There is a library on hackage that at least wraps it in something that calls it repeatedly, if necessary
13:31:14 <nand`> Nereid: to identify numeric literals as having the empty type
13:31:18 <otters> lol
13:31:18 <Nereid> mm
13:31:20 <nand`> so the type-safe (*) works
13:31:20 <otters> c_wraith: I just found that
13:31:23 <otters> unbelievable
13:31:29 <otters> "why can't I sleep for forty minutes??"
13:31:46 <c_wraith> because you're not on a 64-bit system
13:31:47 <simpson> "Timers up to one month"
13:31:47 <c_wraith> :)
13:32:10 <otters> :(
13:32:15 <c_wraith> little-known feature - 64 bit systems enable more efficient not doing anything, too!
13:32:15 <danr> otters: system "sleep 2400" ?
13:32:18 <DanBurton> nand`: can you dump a complete minimal code sample on hpaste? I'm curious
13:32:23 <otters> hell no
13:32:35 <Jafet> danr: you need an OS thread for that!
13:32:43 <Jafet> or something something actually you probably don't
13:33:01 <Nereid> Jafet: like another process?
13:33:01 <Jafet> I've never used system
13:33:07 <Ralith> otters: what's wrong with looping?
13:33:11 <otters> Ralith: nothing
13:33:15 <Peaker> hey, "runhaskell" is being very slow. "ghc -O2 foo && ./foo" is not user-friendly.  Can "runhaskell foo" take some param to compile first?
13:33:16 <Ralith> well then
13:33:23 <otters> I hadn't thought of it
13:33:36 <Ralith> Peaker: you could write a trivial script to do the former.
13:33:48 <Jafet> Ralith: it sounds like linux philosophy
13:33:50 <Peaker> that's what I did...
13:33:58 <Peaker> but now I have an extra file polluting that directory
13:34:09 <Ralith> so stick it in /usr/local/bin instead?
13:34:54 <Jafet> Make a syscall to sleep, syscall returns with ENICENICEKEEPGOING
13:36:08 <nand`> DanBurton: the whole thing is on http://hub.darcs.net/nand/units/browse ; I'm not sure what you want a code sample of
13:36:54 <DanBurton> the ambiguous part
13:37:07 <nand`> oh
13:39:33 <DanBurton> aw i need to update my ghc for the lambdacase
13:39:42 <DanBurton> I guess it's about time
13:39:46 <atriq> But then you get the lame TypeOperators
13:41:01 <DanBurton> the TypeOperators situation irks me; why exactly can't we have constructors *and* higher-order type constructors be operators?
13:41:33 <DanBurton> type parameters, I should say
13:42:04 <DanBurton> that was the change, right? We lost type parameter operators so that our type constructors didn't all have to start with colon?
13:42:14 <atriq> Yeah
13:42:15 <quicksilver> yes.
13:42:21 <nand`> hmm, after trying to present a minimal case for the ambiguous type error I don't actually get an ambiguous type error; time to figure out why not
13:42:39 <quicksilver> I presume the notion that constructors are in a different syntax class is fairly deep in the parser
13:43:14 <quicksilver> what would you do? require variable operators to be explicitly foralled so it was clear they were variables?
13:43:21 <quicksilver> ISTR someone suggested that but it didn't work.
13:43:35 <nand`> I think I would be okay with that
13:44:28 <otters> does anybody know what (.*>) is
13:44:30 <otters> hoogle doesn't know
13:44:34 <otters> but I'm using it in two places in this project
13:45:13 <Nereid> otters: attoparsec has it?
13:45:20 <otters> does it
13:45:22 <geekosaur> http://holumbus.fh-wedel.de/hayoo/hayoo.html#0:(.*%3E)
13:45:38 <otters> oh, hayoo is better than hoogle
13:45:38 <geekosaur> hoogle doesn't look a lot of places by default; hayoo works better
13:45:42 <otters> who'd have thought
13:46:21 <DanBurton> hayoo is hoogle, but for all of the things
13:46:48 <Jafet> hayoo, like google, only finds a thing if you know part of the name of the thing
13:46:56 <tommd> That's not really fair.  Hoogle can be told what packages to look in and does better type search.
13:49:25 <nand`> I like hoogle's presentation better as well. I only use hayoo when hoogle doesn't find what I want
13:49:26 <ramses_> @pl \xs -> (group xs) >>= return . head
13:49:26 <lambdabot> (head `fmap`) . group
13:50:06 <DanBurton> foo >>= return . bar is the same as fmap bar foo
13:50:22 <DanBurton> I wonder why lambabut suggested (head `fmap`) instead of (fmap head)
13:51:01 <nand`> I bet @pl secretly has an algorithm to pick the most obfuscated looking alternatives
13:51:26 <otters> @pl \(a,(c,b)) -> [(c,a),(b,c),(a,b)]
13:51:28 <lambdabot> uncurry ((`ap` snd) . (. fst) . ap (ap . (((.) . (:)) .) . flip (,)) (flip (ap . ((:) .) . flip (,)) . flip flip [] . ((:) .) . (,)))
13:51:32 <otters> nonsense
13:51:36 <DanBurton> I sometimes use (foo `bar`) instead of (flip bar foo)
13:51:47 <DanBurton> doh, I mean (`bar` foo)
13:52:11 <nand`> I always use (`bar` foo) over (flip bar foo)
13:52:19 <otters> saves typing
13:52:32 <DanBurton> but the parens and backticks are harder to reach
13:52:35 <nand`> the only time I use ‘flip’ is when composing; eg foo . flip bar . bat
13:52:48 <DanBurton> if you're typing something like "flip evalStateT $ do ..."
13:52:58 <otters> yeah, I do that
13:52:59 <DanBurton> except you give it the state in there :P
13:53:22 <otters> e***StateT functions have absolutely stupid argument orders
13:53:39 <DanBurton> the argument order is lovely... if you are thinking of them as newtype unwrappers
13:53:48 <DanBurton> if you are actually trying to use them, however :P
13:53:59 <otters> the haskell philosophy, folks
13:54:22 <nand`> elegance over relevance
13:54:39 <edwardk> preflex: xseen lispy
13:54:52 <Peaker> otters: The runState function is just the constructor field
13:54:58 <Peaker> otters: So it has no choice in its arg order
13:55:04 <DanBurton> tbh there is *something* to be said for thinking of e***StateT as a transformation from a "stateful computation" to a function
13:55:28 <edwardk> otter: i can never remember if i'm evaling or execing state.
13:55:30 <Peaker> DanBurton, though I *awlays* end up doing:  (`runStateT` s) . (`runReaderT` env) . ... $ do
13:55:48 <nand`> eval -> you want the result; exec -> you want the effects (aka state)
13:55:50 <Peaker> execution is about effects, evaluation is about results
13:56:03 <Peaker> IO is executed, expressions are evaluated
13:56:12 <DanBurton> so just remember execeffect, evalresult
13:56:19 <edwardk> DanBurton: =P
13:56:22 <DanBurton> or is it execresult evaleffect
13:56:28 <Philippa_> ...ish. IO still has results even when they're results of actions with effects
13:56:40 <Philippa_> execution produces both
13:56:52 <Philippa_> ...sorry, contextectomy, my bad
13:56:57 <edwardk> i tend to just runStateT and do what i want with the pieces ;)
13:57:05 <Philippa_> I have that habit, yeah
13:57:12 <Philippa_> we remember what "run" means :p
13:57:19 <DanBurton> I just try one, and swap if the type system yells at me.
13:57:27 <Philippa_> that works too, yeah
13:57:42 * DanBurton is a lazy Haskeller
13:57:58 <nand`> that's how I do module imports
13:58:51 <pmade> Is there a function that will turn (a -> b) into (a -> m b)?  I was thinking something like liftM but that's not right.
13:59:03 <nand`> (return.)
13:59:14 <simpson> Pretty much.
13:59:16 <pmade> nand`: okay, that's what I'm using now, thanks.
13:59:31 <Ralith> there's usually a marginally cleaner way to do that, depending on what you need it for
14:00:02 <pmade> I'm still learning, so this is probably a hack, but what I have is:  p1 <- getLine >>= \x -> return $ read x
14:00:20 <nand`> I thought there was some cleaner function for this in Control.Kleislify, but it seems not
14:00:33 <DanBurton> p1 <- getLine >=> read
14:00:41 <DanBurton> no wait
14:00:48 <DanBurton> getLine >>= read
14:00:59 <DanBurton> no wrong still :P
14:01:23 <DanBurton> thinking read was something wonky; it's just plain read. p1 <- read <$> getLine
14:01:31 <nand`> read <$> getLine
14:01:33 <nand`> or fmap read getLine
14:01:46 <pmade> Okay, that's what I was looking for!
14:01:51 <pmade> Thanks DanBurton and nand`.
14:02:06 <ion> Don’t use read in IO. Use readIO.
14:02:11 <ion> readLn = getLine >>= readIO
14:02:21 <Ralith> readIO?
14:02:29 <DanBurton> @hoogle readIO
14:02:29 <lambdabot> Prelude readIO :: Read a => String -> IO a
14:02:30 <lambdabot> System.IO readIO :: Read a => String -> IO a
14:02:30 <lambdabot> Data.IORef readIORef :: IORef a -> IO a
14:02:30 <ion> (In fact, don’t use read anywhere.)
14:02:54 <pmade> ion: interesting
14:02:57 * DanBurton likes readMay
14:05:40 <otters> :t join (***)
14:05:42 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
14:05:47 <otters> what
14:06:08 <atriq> :t join (***) :: (b -> c) -> (b, b) -> (c, c)
14:06:09 <lambdabot> (b -> c) -> (b, b) -> (c, c)
14:06:13 <ion> :t join (***) `asAppliedTo` (undefined :: a -> b)
14:06:14 <lambdabot> (b -> c) -> (b, b) -> (c, c)
14:06:35 <edwardk> :t over both
14:06:37 <lambdabot> (a -> b) -> (a, a) -> (b, b)
14:06:50 <atriq> edwardk, is lens gonna replace everything
14:06:57 <edwardk> it already has
14:06:58 <edwardk> =)
14:07:05 <johnw> it replaced edwardk long ago
14:07:07 <atriq> Lenses: the new Monads?
14:07:15 <nand`> all you need is Action
14:07:20 <edwardk> atriq: that is what roconnor seemed to think
14:07:22 <edwardk> :t act
14:07:24 <lambdabot> Control.Lens.Internal.Effective m r f => (s -> m a) -> (a -> f a) -> s -> f s
14:07:30 <Ralith> are there utilities for using lenses with arrows yet?
14:07:33 <DanBurton> so, trying to install ghc 7.6. I'm getting this error when I try to run the configure script: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: No such file or directory
14:07:45 <edwardk> Ralith: heck you can build lenses with arrow sugar ;)
14:07:57 <nand`> edwardk: I'm curious to see what that would look like, incidentally
14:08:01 <nand`> I think we've discussed this before
14:08:08 <edwardk> nand`: its somewhat underwhelming ;)
14:08:19 <Ralith> edwardk: oh?
14:08:39 <nand`> edwardk: so when will you be porting lenses to the type level?
14:08:43 <nand`> I could use them
14:09:24 <edwardk> heading out of the office, bbl
14:10:03 <atriq> If we can express IO as a lens, we won't need Monads
14:12:27 <DanBurton> express IO as a lens, what does that even mean? o_O
14:12:40 <atriq> If we knew that, it would be easy
14:13:34 <DanBurton> Haskell: it's easy as soon as you wrap your brain around this really hard concept...
14:13:57 <atriq> That might just be me
14:15:45 <DanBurton> Well, this is better than other languages. Java: don't you dare try to embody any form of abstraction beyond a certain point...
14:21:13 <nand`> heh, I fiddled around with whether or not to expose the constructor so you can coerce units then converting, then I realized it can be done already in a much, much more elegant fashion, by multiplying with the corresponding reciprocal unit; eg. the conversion factor for yards -> meter would be 0.9144 * [u|m/yd|];  I'm really liking this version Nereid :P
14:21:44 <johnw> DanBurton: in Java, you just name AbstractFactoryFactoryInstanceInstanceClass
14:22:09 <nand`> ideally I'd still want to mangle it into something like 0.9144<m/yd>
14:22:21 <nand`> quasiquotes syntax is so ugly
14:22:57 <johnw> nand`: i don't find it all that bad
14:23:16 <johnw> nand`: [lt|foo#{var}bar|] isn't much worse than in any other language that doesn't have native templating
14:24:12 <atriq> Imagine any of these in brainfuck
14:26:56 <DanBurton> quasiquotes... could be worse
14:36:29 <otters> so Monoid is a "Data" and Monad is a "Control"
14:36:39 <Cale> otters: lol
14:36:51 <otters> must be some obscure aspect of category theory
14:37:12 <Cale> It's really just the fact that Data and Control both mean "Miscellaneous"
14:37:20 <otters> right
14:37:33 <otters> Well, I like namespace organization as much as the next guy
14:37:41 <otters> Especially when it's good
14:37:42 <jrajav> When someone learning about monads tries to reduce them to an oversimplified synonym or trite phrase: http://2.bp.blogspot.com/-Uyju3GqVvW8/UBFDvUyVsgI/AAAAAAAABGo/7HiFzOF3yug/s1600/natural.gif
14:38:44 <hiptobecubic> jrajav, monads are just like imaginary refrigerator boxes
14:39:00 <jrajav> I actually like that one
14:39:06 <shachaf> I like the part where Functor is Data and Monad is Control.
14:39:19 <c_wraith> little-known feature - 64 bit systems enable more efficient not doing anything, too!
14:39:24 <c_wraith> err. crap, wrong button
14:39:27 <c_wraith> monads are exactly what they are. You just have to find a way to believe they aren't a trick. :)
14:39:30 <shachaf> Also, is Lens Data or Control?!
14:39:33 <c_wraith> both
14:39:36 <otters> yes
14:39:46 <otters> c_wraith: hey, I remember that
14:40:10 <c_wraith> yeah, minor problem with hitting the up button before enter.
14:41:30 <shachaf> Everything c_wraith says comes from a prepopulated file containing hundreds of witty remarks.
14:41:58 <neutrino> c_wraith: have you installed nada?
14:42:03 <neutrino> ñada i guess
14:42:03 <shachaf> Sometimes he presses the wrong button and gets off-topic.
14:42:36 <c_wraith> It's hard being a bot.
14:43:15 <hpc> @let c_wraith = text "`cat /usr/share/games/fortunes/fortunes`"
14:43:17 <lambdabot>  Defined.
14:43:48 <otters> > c_wrath
14:43:50 <lambdabot>   Not in scope: `c_wrath'
14:43:50 <lambdabot>  Perhaps you meant `c_wraith' (line 7)
14:43:54 <otters> > c_wraith
14:43:54 <c_wraith> haha
14:43:56 <lambdabot>   `cat /usr/share/games/fortunes/fortunes`
14:43:56 <otters> lol
14:44:55 <monochrom> @quote c_wraith
14:44:56 <lambdabot> c_wraith says: oh.  well, then.  some actually *do* simply unsafePerformIO into Mordor.
14:44:58 <otters> @pl \f -> fmap (fmap (fmap f))
14:44:58 <lambdabot> fmap . fmap . fmap
14:45:04 <monochrom> haha
14:45:21 <shachaf> Man, if only we had a program for picking a random entry from /usr/share/games/fortunes/fortunes and printing it out.
14:45:28 <shachaf> That would be useful.
14:45:39 <monochrom> lambdabot's @quote is better
14:45:52 <shachaf>  @quonochrom
14:45:53 <monochrom> or maybe some prefer @nixon
14:45:58 <shachaf> @nixon
14:45:58 <lambdabot> Do you know what happened to the Romans?  The last six Roman emperors were fags. . . .  You know what happened to the popes?  It's all right that popes were laying the nuns.
14:46:13 <shachaf> I generally prefer @quote...
14:46:18 <monochrom> yes
14:46:28 <shachaf> @quote edwardk
14:46:28 <lambdabot> edwardk says: Haskell 98 is the Windows 98 of standards ;)
14:46:42 <shachaf> Good point, ghost-edwardk.
14:47:10 <shachaf> @quote fmap
14:47:11 <lambdabot> applicative says: if you are only beginning to learn Haskell, don't let them talk to you about monads. ask them about fmap
14:47:35 <monochrom> I simply unsafeInterleavIO into Mordor, and back again: http://hpaste.org/77374
14:48:31 <shachaf> monochrom: I guess you were so pleased with that when you wrote it that you pasted the link four or five times into the channel.
14:48:39 <shachaf> But only now we're beginning to force the thunks.
14:48:44 <monochrom> hahaha
14:49:09 <monochrom> but yes I'm very happy with this evil invention!
14:50:16 * hackagebot antigate 0.1.0 - Interface for antigate.com captcha recognition service.  http://hackage.haskell.org/package/antigate-0.1.0 (MikhailKuddah)
15:00:16 * hackagebot factual-api 0.6.1 - A driver for the Factual API  http://hackage.haskell.org/package/factual-api-0.6.1 (RudigerLippert)
15:02:58 <iosonofabio> would anyone have time for a newbie question about composition?
15:03:07 <dibblego> iosonofabio: go for it
15:03:09 <johnw> always time for newbie questions about composition
15:03:16 <johnw> compose your question
15:03:23 <iosonofabio> so, I have the following function:
15:03:33 <iosonofabio> with_status_io io = (get_status >>=) $ liftIO . io
15:03:36 <iosonofabio> which works
15:03:58 <iosonofabio> but if I redefine it without the argument, it does not:
15:04:17 <iosonofabio> with_status_io = (get_status >>=) $ liftIO .
15:04:19 <johnw> @pl \io = (get_status >>=) $ liftIO . oi
15:04:19 <lambdabot> (line 1, column 5):
15:04:20 <lambdabot> unexpected "="
15:04:20 <lambdabot> expecting operator, pattern or "->"
15:04:22 <johnw> @pl \io = (get_status >>=) $ liftIO . io
15:04:23 <lambdabot> (line 1, column 5):
15:04:23 <lambdabot> unexpected "="
15:04:23 <lambdabot> expecting operator, pattern or "->"
15:04:29 <johnw> @pl \io -> (get_status >>=) $ liftIO . io
15:04:30 <lambdabot> (get_status >>=) . (liftIO .)
15:05:10 <johnw> you drop a point, and add a ., ironically
15:05:45 <ploosh> what resources would you guys suggest for getting started programming in haskell?
15:05:51 <johnw> @lyah
15:05:52 <lambdabot> Unknown command, try @list
15:05:56 * cmccann encourages avoiding operator sections of (.) when making something pointlessly pointfree
15:05:56 <johnw> @hoogle LYAH
15:05:57 <lambdabot> No results found
15:06:00 <FireFly> @where lyah
15:06:00 <cmccann> @where lyah
15:06:00 <lambdabot> http://www.learnyouahaskell.com/
15:06:00 <lambdabot> http://www.learnyouahaskell.com/
15:06:03 <johnw> ah, thank you
15:06:17 * johnw agress with cmccann
15:06:29 <johnw> egregious pointfree notation helps few, and may endanger kittens
15:06:39 <iosonofabio> damn it, thanks... and without the last parenthesis it does not work either
15:06:42 <cmccann> one of my rules of thumbs for when to not be pointfree is ending up with sections of (.)
15:06:53 <FireFly> Yeah, parens are required when using sectioning
15:07:58 <FireFly> @unpl (f .) . (. g)
15:07:58 <lambdabot> (\ e j -> f (e (g j)))
15:08:37 <iosonofabio> argh
15:09:08 <iosonofabio> I'm getting cut by my own taylor
15:09:22 <iosonofabio> better be a little more verbose then... thanks a lot!
15:09:43 <johnw> there is nothing wrong with verbosity
15:10:16 * hackagebot antigate 0.1.1 - Interface for antigate.com captcha recognition service.  http://hackage.haskell.org/package/antigate-0.1.1 (MikhailKuddah)
15:11:06 <FireFly> @pl \f g x y -> (g x) `f` (g y)
15:11:07 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:11:27 <FireFly> ^ that's a case where you'd want the pointful version :p
15:11:49 <c_wraith> or just a version that uses on
15:12:51 <Peaker> Read the "read" discussion above
15:13:12 <Peaker> it's annoying that in many cases Haskell makes the least safe option the easiest...  the easiest import syntax is collision-prone
15:13:20 <Peaker> the easiest "read" function to use by far is the unsafe one
15:13:28 <Peaker> The easiest way to do IO is with lazy I/O, unsafely...
15:13:51 <Peaker> "fromMaybe" is not made easier than "fromJust", both are an import away :(
15:14:14 <Peaker> encouraging unsafe/bad programming style..
15:14:32 <johnw> Peaker: what is your point, actually?
15:15:23 <Peaker> that Haskell should encourage safe/good style by making is easier than the bad style.. import qualified should be the default, all names should be explicit (and ugly).  "read" should probably not exist (readMaybe should). lazy I/O should be shunned away in horrible libraries.
15:15:49 <johnw> i'm not sure that's going to change anytime soon
15:17:16 <Peaker> {-# LANGUAGE Prelude2012, ImportStyle #-}  could be nice :)
15:18:12 <mauke> {-# LANGUAGE NoPragmas #-}
15:18:58 <cl_away> Peaker: What's wrong with lazy I/O?
15:19:31 <cl_away> Peaker: Oh, I see.
15:20:56 <cl_away> Oh dang.  Haskell Cambridge was yesterday.
15:21:02 <cl_away> I totally meant to go to that.
15:21:05 <cl_away> How often are they?
15:21:36 <cl_away> Actually, I have to go.  Talk to you all later.
15:22:26 <mcstar> really, to all the 969 of us?
15:23:03 <cl_away> mcstar: That depends on whether you all stay in channel.
15:23:12 <mcstar> heh, i knew you couldnt resist
15:23:34 <cl_away> Nope, I'm a superconductor.
15:23:39 <ion> {-# LANGUAGE GangnamStyle #-}
15:23:39 <mcstar> XD
15:24:15 <mcstar> ion: your joke is probably funnier than the original clip
15:24:28 <hiptobecubic> That music video is gold
15:25:19 --- mode: ChanServ set +o mauke
15:25:19 --- kick: average_drifter was kicked by mauke (average_drifter)
15:26:13 <Jafet> http://opalang.org/gangnam.style.html
15:27:33 <hiptobecubic> this is pretty terrible whoring
15:27:47 --- mode: mauke set -o mauke
15:27:58 <mcstar> he says gangnam star, btw
15:29:42 <ivanm> mauke: is there any particular reason preflex isn't here?
15:30:02 <mauke> yeah, I have no server to run it on
15:30:20 <ivanm> ahhhh
15:42:12 <wereHamster> how do I convert a Int to a Double?
15:42:21 <monochrom> @quote monochrom Double
15:42:22 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
15:42:36 <startling> haha
15:43:14 <boris``> is there a way to make ghci use compiled versions of some modules, purely for performance's sake?
15:43:33 <hpaste> monochrom annotated “unsafeInterleavIO passing style” with “one simply unsafeInterleaveIO into Mordor” at http://hpaste.org/77374#a77457
15:44:03 <Jafet> Try compiling the modules
15:44:04 <ion> unsafeGangnam
15:44:49 <tac-nap> ion: gangnam is never done safely
15:45:02 <monochrom> GHC user guide section 2.3 says how to use compiled modules in ghci
15:45:08 <Rickasaurus> need a gangnam monad
15:45:49 * boris`` looks
15:46:29 <Rickasaurus> do haaaay sexy lady
15:47:49 <startling> are we pretending to be redditors today?
15:48:15 <Rickasaurus> Sorry, I didn't realize I wasn't cool enough to make jokes in the channel yet
15:48:33 <mauke> http://imgur.com/gallery/Y0FHq
15:49:36 <mcstar> Rickasaurus: you know when you crossed the line, mauke will kick you
15:49:56 <mcstar> if he is in a good mood, otherwise, ban
15:50:01 <Rickasaurus> mcstar, good to know
15:50:10 <mcstar> XD
15:50:15 <Rickasaurus> Any of you guys coming to the NYC Haskell Meetup next week?
15:50:17 * hackagebot antigate 0.2.0 - Interface for antigate.com captcha recognition service.  http://hackage.haskell.org/package/antigate-0.2.0 (MikhailKuddah)
15:50:38 <nyc> I live there. It's doubtful I'm going.
15:51:00 <Rickasaurus> looks like it's going to be a big event, tons of people signed up
15:51:43 <Rickasaurus> I think it's worth it for even just networking over beers afterward
15:54:40 <Rickasaurus> nyc, if you don't decide to come you should contact us with what would interest you.  We want to appeal to all haskellers in the area.
15:57:00 <espringe> After having written a parser (with parsec) I'm now finding my self writing a pretty-printer and reimplementing a lot of the same logic (esp. wrt escaping). Is there some sort of unified framework out there, that gives you both a parser and a pretty-printer in one?
16:00:51 <Cale> http://research.microsoft.com/pubs/64036/picklercombinators.pdf
16:01:25 <Cale> I don't know if an implementation of that library is on Hackage or not
16:01:46 <espringe> Cool, thanks for the link
16:02:15 <startling> espringe: I've been thinking about writing a thing like that
16:02:33 <startling> I also wanted quickcheck generators from the parser, too.
16:03:15 <espringe> startling: I did that actually, generate a quickcheck generator from a parser
16:03:19 <espringe> but it won't really test anything
16:03:23 <espringe> :D
16:04:24 <startling> espringe: sure, but it's a neat way to check a parser by eye.
16:04:34 <espringe> startling: https://plus.google.com/u/0/101137844407082453129/posts/YRtt5znycXs
16:04:46 <espringe> But yeah, generating a data->string and string->data would be super useful
16:04:52 <espringe> At least, i'd totally use it
16:05:10 <Cale> There is hexpat-pickle which does it specifically for XML
16:05:54 <espringe> But I imagine it's very hard, cause lots of stuff that isn't easily reversable. e.g.   parseChar <*> many spaces <*> parseChar
16:06:08 <Cale> and then to a certain extent all the binary/cereal instances are similar (though they're a bit more split up, and it's really just that if you have an instance, you'll have both directions)
16:06:34 <espringe> You'd sort of have to say stuff like: "This can be 1 or more space when reading it in. When writing it out, use exactly 2 spaces"
16:06:58 <espringe> Same with end-lines for instance, you might want to accept any endline, but only output unix endlines
16:06:59 <espringe> or such
16:07:12 <espringe> But it'd be really cool
16:07:13 <startling> espringe: yeah.
16:07:26 <startling> espringe: btw, fexprs are kind of terrible. I tried that route once.
16:07:42 <espringe> Really? I'm loving them
16:07:51 <espringe> What didn't you like about it?
16:08:17 <espringe> My only problem with them, is they're hard to debug (cause my language has no tools) and you can't have the equiv of macro-expand
16:08:22 <espringe> but other than that, i'm really loving them
16:09:12 <quest> are there any prelude function that can help me identify if x exists in a list?
16:09:19 <Cale> elem
16:09:30 <startling> espringe, it's pretty crazy for a function to be able to do things differently depending on whether you give it (+ 2 0) or (+ 1 1)
16:09:31 <Cale> > elem 'e' "Hello"
16:09:32 <lambdabot>   True
16:10:17 <tac-nap> > 5 `elem` [1,2,3,4,5,6,7,8,9,0]
16:10:19 <lambdabot>   True
16:10:21 <tac-nap> > 11 `elem` [1,2,3,4,5,6,7,8,9,0]
16:10:23 <lambdabot>   False
16:10:28 <quest> thx!
16:11:02 <espringe> startling: Yeah, they can easily be super abused. But they should really only be looking at the AST when they're trying to replace macros, not replacing normal functions
16:11:27 <espringe> and when they're replacing macros, I'm finding they're much better -- as there's no separate compile and run phase
16:11:49 <startling> espringe, have you seen scheme's macros?
16:11:53 <espringe> of course
16:12:10 <startling> I wonder whether a first-class version of that could work.
16:12:21 <espringe> That's effectively what an fexpr is
16:12:22 <startling> I'm not a big fan of ahead-of-time macros either, tbh.
16:12:35 <kkopiec> Hi all
16:12:40 <espringe> Since I don't have any docs, check out "kernel"
16:12:50 <kkopiec> anyone willing to help begginer ?
16:12:58 <espringe> kkopiec: Just ask :P
16:13:09 <hpaste> kkopiec pasted “how to skip a part of input” at http://hpaste.org/77458
16:13:51 <kkopiec> trying to parse document
16:14:07 <Cale> kkopiec: are you sure that <* at the start of the bracket there is what you intended?
16:14:23 <Cale> You have  many (<* space <* prefix ...)
16:16:01 <kkopiec> ow I am not space is a parser which eats space and I am not particular interested in this process apart of the fact that it its space
16:16:13 <espringe> kkopiec: I'm a total beginner too, but I found it a bit easier to read using do syntax for stuff like that (even if you're throwing away most of the stuff): eg. https://github.com/espringe/wisp/blob/master/haskell/src/Main.hs#L190
16:16:49 <Cale> espringe: btw,  _ <- foo  is the same as  foo
16:17:04 <hpaste> quest pasted “error #1” at http://hpaste.org/77459
16:17:12 <espringe> Cale: I think I was getting compile warngins with  just 'foo' ?
16:17:13 <quest> can someone help me check my error?
16:17:28 <Cale> espringe: Oh, perhaps if you turn on enough of the warning options :P
16:17:39 <Cale> -Wall is ridiculous overkill
16:17:58 <espringe> https://github.com/espringe/wisp/blob/master/haskell/src/Main.hs#L190
16:18:00 <espringe> whoops
16:18:12 <espringe> Yeah, I'm using -Wall
16:18:24 <Cale> (or at least, I think it is)
16:18:33 <startling> why would it warn on that?
16:18:33 <cmccann> just another brick in the -Wall
16:18:50 <startling> is it because it's not an m () ?
16:18:53 <Cale> startling: OH NO YOU DIDN'T USE THIS THING
16:19:06 <Cale> yeah
16:19:07 <espringe> A do-notation statement discarded a result of type Char.
16:19:07 <espringe>              Suppress this warning by saying "_ <- char '}'",
16:19:07 <espringe>              or by using the flag -fno-warn-unused-do-bind
16:19:29 <espringe> So I was lazy, and just used:  _ <- char '}'
16:19:44 <Cale> -Wall is unfortunately cluttered with too many dumb warning flags
16:19:58 <parcs`> i think that warning is very useful
16:20:12 <Cale> parcs`: rarely
16:20:20 <espringe> Since I'm a noob, i don't actually mind writing  "_ <- " anyway -- it's nice an explicit
16:20:22 <Cale> It's more annoying than useful
16:20:24 <parcs`> i just don't understand why parsec's char combinator returns a Char
16:20:45 <espringe> Yeah, me neither
16:20:46 <Cale> parcs`: because consider things like  string = mapM char
16:20:53 <tac-nap> espringe: it's good to know that it means that, but I wouldn't recommend writing it ;)
16:20:57 <fmap> _ <- looks scala
16:21:13 <espringe> Well, I did port this from scala :D
16:21:39 <Cale> well, I guess you could claim that you know the result of that parser when it succeeds too
16:21:43 <cmccann> yeah
16:21:48 <Cale> But as soon as you combine a few with <|>
16:21:58 <cmccann> there's not much point to a parser that only matches one thing returning that thing
16:21:58 <Cale> then you need that result to distinguish what you read
16:22:10 <Cale> cmccann: So untrue!
16:22:15 <Cale> We're combining parsers together
16:22:16 <cmccann> but it often saves you from doing (string "foo" *> return "foo") which is even more dumb
16:22:20 <Cale> So simple ones can be good!
16:22:44 <startling> yeah, I sometimes wish print was Show a => a -> IO a
16:22:50 <startling> mostly for traversals.
16:23:12 <Cale> That's an interesting idea :)
16:23:20 <parcs`> cmccann: you can simplify that too "foo" <$ string "foo" which isn't bad
16:23:53 <cmccann> parcs`, still more error-prone I think
16:23:59 <startling> > traverse print [1, 2, 3]
16:24:00 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [()]))
16:24:00 <lambdabot>    arising from a use o...
16:24:04 <startling> you can do:
16:24:06 <cmccann> I'm more likely to make a dumb typo than unintentionally discard a result in a do block
16:24:11 <startling> > traverse_ print [1, 2, 3]
16:24:13 <lambdabot>   Not in scope: `traverse_'
16:24:13 <startling> though
16:24:13 <lambdabot>  Perhaps you meant one of these:
16:24:13 <lambdabot>    `Data.Foldabl...
16:24:31 <startling> well, you get the idea.
16:24:43 <startling> a [()] isn't really useful.
16:25:11 <shachaf> startling doesn't like natural numbers. :-(
16:25:16 <Nereid> :(
16:25:29 <shachaf> I heard God invented those.
16:25:30 <startling> shachaf: ???
16:26:02 <cmccann> startling, [()] is equivalent to Nat = Zero | Succ Nat
16:26:08 <shachaf> traverseOf traverse print [1,2,3]
16:26:13 <startling> oh heh.
16:26:24 <shachaf> Other than ⊥
16:26:28 <Nereid> isn't traverseOf = id?
16:26:36 <shachaf> It's more like data Nat = Zero | Succ () Nat
16:26:40 <shachaf> Nereid: Yep.
16:26:46 <startling> :t taverseOf
16:26:47 <lambdabot>     Not in scope: `taverseOf'
16:26:48 <lambdabot>     Perhaps you meant one of these:
16:26:48 <lambdabot>       `traverseOf' (imported from Control.Lens),
16:26:48 <shachaf> traverseOf (traverseOf traverse) print [1,2,3]
16:26:49 <cmccann> equivalent up to the usual handwaving of _|_ yeah
16:26:53 <startling> :t traverseOf
16:26:54 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
16:27:04 <startling> that's silly.
16:27:23 <shachaf> cmccann: Yesterday I was digging through GHC Core and finding a lot of handwaving.
16:27:31 <shachaf> Suspicious optimizations.
16:27:37 <shachaf> Even with -fpedantic-bottoms.
16:27:52 <cmccann> shocking!
16:28:00 <shachaf> I know, man.
16:28:14 <startling> wow, ghc is just full of sex and drug related pun opportunities.
16:28:18 <shachaf> I can't actually come up with any test cases that expose its evil ways.
16:28:36 <startling> shachaf: this has an effect on map . (map . map)?
16:28:45 <shachaf> I'm not sure!
16:29:38 <fliip> How would I go about adding elements of a list of a list to another list of lists? Ie [[a,b,c],[d,e,f]] + [[a1,b1,c1],[d1,e1,f1]] = [[a+a1,b+b1,c+c1],[d+d1,e+e1,f+f1]]?
16:29:41 <shachaf> As I said: If an optimization changes semantics but no one manages to observe it, is it still unsound?
16:30:01 <Nereid> @type zipWith (zipWith (+))
16:30:03 <lambdabot> Num c => [[c]] -> [[c]] -> [[c]]
16:30:12 <shachaf> fliip: Are you sure lists are what you want?
16:30:16 <shachaf> What Nereid said, anyway.
16:30:24 <fliip> Ah ok thanks.
16:30:26 <fliip> =)
16:30:29 <shachaf> What if they have a different number of elements?
16:30:55 <fliip> Then its an invalid list for this function.
16:31:02 <Nereid> why not encode that in the types?
16:31:38 <Nereid> > zipWith (zipWith (+)) [[1,2],[3],[],[4]] [[10,20,30],[40,50],[60,70]]
16:31:39 <lambdabot>   [[11,22],[43],[]]
16:31:45 <shachaf> Are your things always lists of two lists of three values?
16:32:03 <fliip> No.
16:32:10 <fliip> They are similar lists though.
16:32:19 <covi> what does the function 'fix' do?
16:32:34 <Nereid> @src fix
16:32:34 <lambdabot> fix f = let x = f x in x
16:32:40 <Nereid> > fix (1:)
16:32:41 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
16:33:11 <Nereid> > fix (\f n -> if n == 0 then 1 else n * f(n-1)) 5
16:33:13 <lambdabot>   120
16:33:31 <hpaste> quest pasted “error #2” at http://hpaste.org/77460
16:33:42 <quest> hi why do i get non exhaustive function?
16:33:50 <quest> exhaustive patterns in function
16:34:03 <covi> Nereid: oh, fix as in 'fix point'?
16:34:09 <Nereid> quest: what is identify []?
16:34:10 <Nereid> covi: yes
16:34:59 <covi> Nereid: But I don't understand the source code. Why would f be applied more than once, where does the 'x' right after 'f' come from?
16:35:27 <Nereid> covi: fix f = f (fix f) = f (f (fix f)) = f (f (f (fix f))) = ...
16:35:45 <monochrom> http://www.vex.net/~trebla/haskell/fix.xhtml
16:36:04 <startling> > fix fix
16:36:06 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
16:36:10 <startling> :(
16:36:39 <mmos> is there a tutorial on using HaXml; in particular the types and instances generated by DtdToHaskell? I just ran DtdToHaskell on MusicXML's DTD but I don't know what to do next.
16:36:49 <quest> hi Nereid, i realized i need to put something for identify [], if i put identify [] = [], then i will have type error because it should return expr
16:37:12 <quest> then i tried to put identify [] = Num 0, then it just wont stop, like iterate
16:37:27 <Nereid> quest: well maybe you need to change your code a little
16:37:42 <Nereid> perhaps you don't want to cons anything when fst (...) is empty?
16:39:08 <typoclass> quest: if you're sure that the case "identify []" will never happen, you can silence the compiler warning by saying identify [] = error "can't happen"
16:39:23 <Nereid> but it did happen, hence the non-exhaustive patterns error
16:39:26 <quest> im sure identify [] will never happen
16:39:31 <quest> because its based on break
16:39:42 <Nereid> break can give you an empty list
16:39:49 <quest> you cant use break function and return empty first
16:40:07 <c_wraith> :t break
16:40:08 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
16:40:12 <Nereid> > break id [True]
16:40:13 <lambdabot>   ([],[True])
16:40:22 <c_wraith> > break ' ' " foo"
16:40:24 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
16:40:24 <lambdabot>              with actua...
16:40:30 <Nereid> break (' ' ==) " foo"
16:40:30 <c_wraith> > break isSpace " foo"
16:40:32 <lambdabot>   (""," foo")
16:40:33 <Nereid> or that
16:40:49 <Nereid> > break id []
16:40:51 <lambdabot>   ([],[])
16:41:27 <Nereid> also instead of using fst and snd, consider pattern matching on a pair in the where clause
16:41:33 <Nereid> so you don't compute break p y twice
16:42:26 <quest> owhhh
16:42:42 <Nereid> > break undefined []
16:42:43 <lambdabot>   ([],[])
16:42:45 <Nereid> hehe
16:42:53 <quest> ok i geddit
16:42:56 <quest> for the pattern matching
16:53:11 <hpaste> quest pasted “error 3” at http://hpaste.org/77462
16:53:36 <quest> now i test tokenize "5" works, "5+" works as well, but "5+5" returns exhaustive pattern
16:53:37 <quest> why?
16:53:43 <quest> and it compiles
16:54:06 <c_wraith> quest: by the way, look at the error hlint reports on that paste.
16:54:49 <quest> wow :O
16:55:53 <quest> i dont get the 2nd warning tho
16:56:04 <Cale> I don't really either
16:56:19 <quest> why elem a is inferior to a 'elem'
16:56:23 <c_wraith> it's suggesting using elem infix
16:56:30 <Cale> It seems to prefer infix `elem`
16:56:33 <c_wraith> but that's just an idiom thing
16:56:34 <shachaf> Because ndm likes it that way.
16:56:52 <Cale> btw it's backticks to infix, not quotes
16:56:56 <c_wraith> anyway, your error is almost certainly because identify is being called with an empty string.  You should handle that case somehow.
16:57:20 <quest> anyway back to why my code will return exhaustive pattern when my string gets large?
16:57:44 <c_wraith> it's not large, it's just the form
16:58:11 <c_wraith> and it's happening because it calls tokenize on the string "+5"
16:58:19 <Cale> > break isSpace " a"
16:58:21 <lambdabot>   (""," a")
16:58:24 <c_wraith> which the break converts into ("", "+5")
16:58:30 <c_wraith> so you call identify on ""
16:59:17 <quest> whats wrong with tokenizing +5? break will make it ( +, 5) then i identify + and tokenize 5 again...
16:59:30 <quest> owh, so the problem is my break
16:59:31 <quest> :o
16:59:38 <quest> is not doing what i thought it was doing?
17:00:01 <c_wraith> > break (== '+') "+5"
17:00:03 <lambdabot>   ("","+5")
17:00:18 <c_wraith> I think you're assuming break drops the element it found that satisfies the predicate
17:00:20 <c_wraith> it doesn't
17:01:38 <quest> i cant do == + because it should satisfy other operators as well
17:01:48 <c_wraith> but you're missing my point
17:02:21 <c_wraith> Your first call to tokenize is with "5+5".  The second call is with "+5", and your code can't handle it
17:02:31 <monochrom> the "split" package is now in the haskell platform. that is, the Data.Text.Split module
17:02:43 <quest> i thought break splits a list into 2 list, once it found an element that satisfy the predicate
17:02:55 <dmwit> quest: Correct so far.
17:03:11 <dmwit> quest: Now, ask yourself: in what situation can this description result in two lists, one of which is empty?
17:03:19 <quest> so i want "+5" to split into "+" and "5"
17:03:37 <dmwit> I agree that's what you want. Is that what you get?
17:03:38 <c_wraith> that's a reasonable thing to want, but that's not what your use of break does
17:03:42 <quest> well when its a singleton list?
17:04:20 <quest> thats not what i get :/
17:04:20 <c_wraith> > break isSpace " and a very long list here"
17:04:22 <lambdabot>   (""," and a very long list here")
17:04:48 <quest> yeah, break isSpace " sdfghjhgfd" will return [], sdfgf
17:05:38 <startling> > break isSpace (replicate 12 '!' ++ " " ++ repeat '!')
17:05:40 <lambdabot>   ("!!!!!!!!!!!!"," !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!...
17:05:55 <c_wraith> I think you'd get a lot of benefit from simplifying your logic into multiple passes.
17:06:29 <c_wraith> as a first pass, get rid of spaces.  You don't want to ignore them, so why not get rid of them entirely?
17:06:53 <c_wraith> as a second pass, separate into numbers and operators.
17:07:03 <c_wraith> as a third pass, parse each of those
17:07:19 <quest> hmmm
17:07:46 <c_wraith> it has the benefit of making each piece of logic smaller
17:08:25 <c_wraith> less cases, more obvious when you've got it right.
17:08:43 <quest> i'll try to do it this way
17:25:19 * hackagebot chronograph 0.1.0.0 - measure timings of data evaluation  http://hackage.haskell.org/package/chronograph-0.1.0.0 (JohnLato)
17:26:02 <quest> how do i make "+5" become "+","5" ?
17:26:36 <quest> i experimented break p y, where p = flip elem ops
17:26:51 <quest> but break p +5 still return "", +5
17:27:48 <mietek> Is there a way to process a large file line by line using ByteStrings?
17:28:36 <startling> mietek, lazy bytestrings
17:29:05 <startling> it won't be line-by-line exactly, but it won't load everything into memory at once like the strict ones do.
17:29:43 <Ralith> isn't there an mmap binding somewhere?
17:29:49 <Ralith> best of both worlds.
17:30:41 <donri> mietek: bytestrings don't actually know anything about lines
17:31:25 <startling> you could write a thing that did it, though
17:31:30 <donri> mietek: you should decode it into a Text first
17:31:36 <startling> that too.
17:31:43 <donri> startling: well, you can't, not really ;)
17:31:50 <mietek> I don't need Unicode for this
17:31:54 <startling> but it wouldn't be too hard to do readFile :: [ByteString] or [Text]
17:31:57 <donri> but if you want to pretend that you can, there's Char8 for you right there, it has a lines function
17:32:08 <startling> donri: why not?
17:32:08 <mietek> Let say Data.ByteString.Lazy.Char8 is L
17:32:21 <donri> startling: there is no such thing as a line in a string of bytes :)
17:32:31 <mietek> How strict is the following?  L.lines <$> L.getContents
17:32:57 <startling> donri, sure.
17:33:33 <donri> mietek: Text is fine for non-unicode encodings too
17:35:13 <mietek> "As of bytestring 0.9.0.3, this function is stricter than its list cousin.
17:36:36 <Ralith> @hoogle mmap
17:36:36 <lambdabot> package mmap
17:36:37 <lambdabot> package bindings-mmap
17:36:37 <lambdabot> package bytestring-mmap
17:36:45 <Ralith> well look at that
17:37:27 <donri> mietek: but you could do e.g., split 0xA bs, if that's what you're really asking for
17:38:04 <mietek> donri: how strict will be the result of this operation?
17:38:28 * Ralith makes noises
17:38:48 <donri> no idea
17:38:54 <mietek> Ralith: thanks, these have their own caveats
17:39:12 <donri> if you worry a lot about IO strictness maybe try pipes
17:39:38 <Ralith> mietek: what concerns you about them?
17:51:28 <hpaste> quest pasted “done” at http://hpaste.org/77464
17:51:58 <quest> hi, i finally did it, now it works how i want it to be, but is my way redundant?
17:52:43 <parcs`> mietek: should be pretty lazy
17:57:17 <Ralith> quest: well, you call 'elem a ops' in two different places to achieve the same goal; you can probably factor that out
17:58:35 <shachaf> elem n o
17:58:50 <shachaf> elem n op?
18:19:39 <mietek> Hmm
18:19:56 <mietek> I guess what I really want is a lazy ByteString which automatically frees processed chunks
18:20:08 <mietek> So indeed, conduit or pipes
18:20:10 <mietek> *sigh*
18:20:38 <mietek> donri: :)
18:21:38 <parcs`> mietek: you can also copy the bytestring line by line
18:22:00 <mietek> parcs`: can you explain, please?
18:22:10 <parcs`> do 'map copy (lines <$> getContents)'
18:22:18 <parcs`> er
18:22:44 <parcs`> map copy . lines <$> getContents
18:22:50 <Ralith> mietek: what's wrong with mmap?
18:23:30 <mietek> Ralith: how do you propose to unmap processed lines?
18:23:45 <mietek> parcs`: hmm.
18:24:01 <cornihilio> would any of these be a filepath to where the package is installed?: https://gist.github.com/4043327
18:24:34 <mietek> parcs`: I think the original ByteString will hang around until the last line is copied over
18:24:47 <Ralith> mietek: I don't know what "unmap processed lines" means.
18:24:49 <mietek> parcs`: so, the maximum memory usage will be 2 times the size of the original
18:25:25 <mietek> parcs`: let's see
18:26:02 <mietek> parcs`: my goal would be to have at most one line's worth of data in memory at any given time
18:26:19 * Ralith grumble grumble reimplementing kernel functionality grumble
18:26:46 <parcs`> mietek: right, my suggestion is silly
18:27:16 <Ralith> mietek: would you like to clarify?
18:27:16 <parcs`> mietek: but lines <$> getContents _should_ have about a line's worth of data in memory at a given time. you're saying that that's not the case?
18:27:28 <mietek> parcs`: I'm running out of stack space
18:27:39 <mietek> parcs`: after observing 2GB+ of real memory use
18:28:28 <mietek> Ralith: you have a point there about kernel functionality...
18:28:32 <Ralith> did you mean that you wanted to munmap portions of the file you have already processed?
18:28:33 <mietek> Perhaps I should reconsider
18:28:42 <Ralith> because the entire point of mmap is that you don't need to unload stuff.
18:28:45 <Ralith> unless you're stuck on 32 bit.
18:28:47 <mietek> Yeah.
18:29:10 <Ralith> but so long as you're not literally running out of address space, real memory use should take care of itself.
18:29:19 <parcs`> mietek: that is strange
18:29:45 <mietek> Ralith: slight problem is, can't mmap stdin
18:30:03 <Ralith> ah, so you're not just dealing with files.
18:30:13 <Ralith> gotta use something like conduits/pipes then, yeah
18:30:20 * hackagebot edge 0.8.6 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.6 (ChristopherHoward)
18:30:21 <cornihilio> dcoutts_: am I correct in believing that InstalledPackageInfo does not track where a package is installed? I do not see a FilePath value for that
18:30:21 <mietek> I'm playing around, so I could restrict myself to files
18:30:21 <parcs`> mietek: 'mapM_ BS.putStrLn =<< fmap BS.lines BS.getContents' runs in constant space for me, using a 24MB file as input
18:30:35 <cornihilio> dcoutts_: err and the code: https://gist.github.com/4043327
18:30:44 <mietek> parcs`: interesting, looking
18:31:31 <mietek> parcs`: which BS is that?
18:31:52 <parcs`> lazy of course
18:32:02 <mietek> Lazy non-Char8?
18:32:39 <parcs`> char8
18:42:16 <mietek> Hmm
18:51:12 <igni> hh
18:54:27 <Lajjla> cale, my old friend, why are you not in -blah?
19:00:26 <latro`a> suppose I have a divide and conquer method where each terminated component returns something, and I want to put those return values into some data structure; what is a good choice for this purpose?
19:00:36 <latro`a> *choice of a data structure
19:00:43 <latro`a> at the moment I'm just using a list and recursively concatenating
19:00:48 <latro`a> which is obviously terrible
19:01:30 <shachaf> Difference lists?
19:01:47 <hpaste> mietek pasted “Space leak” at http://hpaste.org/77465
19:01:48 <shachaf> I don't really know what you're doing.
19:02:05 <mietek> parcs`: can you take a look?
19:02:08 <latro`a> essentially I'm taking an interval and recursively chopping it up into subintervals until some convergence happens
19:02:17 <latro`a> and I want to know what the subintervals were
19:02:29 <mietek> parcs`: I'm thinking the way I generalized (+) to (Int, Int) causes the space leak
19:02:34 <mietek> parcs`: but I don't fully understand why
19:04:01 <latro`a> right now here's my recursion pattern
19:05:00 <tikonen> is there common mapper for case [a] -> Either b [c]  (i'm not sure about signature)
19:05:14 <hpaste> latro`a pasted “atrap” at http://hpaste.org/77466
19:05:21 <latro`a> err
19:05:24 <latro`a> missed a space
19:05:26 <tikonen> so it maps with function that returns Either, return value is first Left encountered or mapped list
19:05:36 <hpaste> latro`a annotated “atrap” with “atrap (annotation)” at http://hpaste.org/77466#a77467
19:05:50 <latro`a> obviously that recurses forever; there's a stop condition in the actual function
19:05:54 <tikonen> this is e.g. for validating and converting items in list or returning error otherwise
19:06:14 <cornihilio> hello? anybody here know if cabal stores where packages are installed to? so far I sadly don't think it does: https://gist.github.com/4043327
19:07:33 <typoclass> cornihilio: i think the install location depends really only on one or two config settings. by default it's ~/.cabal/lib/ or something
19:07:52 <shachaf> strace to the rescue!
19:08:05 <mietek> I'm mystified
19:08:08 <shachaf> cornihilio: ghc-pkg will probably be able to tell you.
19:09:00 <parcs`> mietek: the first three modes run in constant space for me
19:09:11 <mietek> parcs`: yes, same for me
19:09:31 <geekosaur> ghc-pkg has that information, you may need to use a detail option or inspect the package.conf files to get it
19:09:33 <typoclass> tikonen: good question. maybe you could use the monad instance of Either?
19:09:36 <mietek> Why doesn't the fourth run in constant space?
19:10:05 <geekosaur> ~/.cabal is just cabal's own metadata, package installation information is ghc-pkg's purview
19:10:33 <tikonen> typoclass, I wrote custom mapper like that but just wondering if there is better way or existing mapper
19:10:39 <parcs`> mietek: ah
19:10:48 <parcs`> mietek: because you're building up a thunk inside the tuple
19:11:11 <mietek> Ah, so I need to strictify each addition?
19:11:15 <mietek> Or use deepSeq
19:12:08 <parcs`> deepSeq is not necessary. use bang patterns on a1 and r1 or use seq directly
19:12:11 <shachaf> Don't use deepSeq. :-(
19:12:24 <mietek> (\(a1, r1) (a2, r2) -> let a = a1 + a2 in let r = r1 + r2 in a `seq` r `seq` (a, r))
19:12:31 <hpaste> quest pasted “error” at http://hpaste.org/77468
19:12:35 <mietek> How can I rewrite this with bang patterns?
19:12:47 <mietek> What's wrong with deepSeq?
19:12:56 <quest> i dont understand why haskell thinks my xs is operator
19:13:04 <shachaf> let !a = ...; !r = ... in ...?
19:13:08 <quest> it SHOULD be the right type
19:13:19 <shachaf> deepseq is rarely what you want.
19:13:24 <ivanm> quest: well, it can't think xs is an operator, it isn't composed of symbols
19:13:26 <quest> because my token can be Op, Var, Num...
19:13:43 <cornihilio> does "remote-build-reporting: anonymous" mean that by default ghc is reporting the success/failure of builds?
19:13:56 <ivanm> cornihilio: s/ghc/cabal-install/
19:14:08 <quest> but isnt the error code saying that haskell thinks its operator
19:14:11 <ivanm> I think there is some capability of cabal-install uploading build results to hackage or somewhere
19:14:12 <quest> thats why it cant compile?
19:14:25 <mietek> parcs`, shachaf: thank you
19:14:27 <ivanm> quest: oh, just saw hpaste with your link
19:14:43 <quest> do you need more context? i will paste somemore info...
19:14:48 <ivanm> quest: what are your Token ExprStack, Opstack and Expr types?
19:14:52 <cornihilio> I hope that feature isn't enabled yet, usually that's the sort of thing you are asked to opt into, right?
19:14:53 <parcs`> mietek: http://paste.debian.net/207644/ -- see lines 1, 23-26 and 47
19:15:24 <mietek> parcs`: ah, this way too
19:15:31 <ivanm> cornihilio: that config thing has been there from day 1 IIRC; don't recall it ever actually being used
19:15:44 <hpaste> quest pasted “infos” at http://hpaste.org/77469
19:15:56 <mietek> Nice.
19:16:30 <mietek> parcs`: lines 23-26 are optional, I think, as foldl' should already strictify the accumulator at the top level
19:17:06 <ivanm> quest: note that the xs there is the xs from your definition of parse'
19:17:16 <ivanm> quest: use different variable names in your definition of parse'
19:17:43 <ivanm> (actually, you sould be using better variable names throughout, rather than `x', `xs', etc. if your code isn't polymorphic)
19:18:00 <quest> but better = longer right?
19:18:10 <parcs`> mietek: not exactly
19:18:12 <ivanm> not necessarily
19:18:13 <quest> theres a strict rule of only 80 char
19:18:16 <quest> per line
19:18:28 <ivanm> parse (t:ts) (e,o) <== same length, better names
19:18:38 <ivanm> though eSt oSt would be slightly better
19:19:19 <parcs`> mietek: well, it "should", but it doesn't. i perceive a speed up when i add the bang patterns there
19:19:33 <ivanm> does parse' _really_ need the x and xs as inputs?  since it's in a where clause it could access them from the outer clause
19:19:35 <parcs`> s/perceive/measure
19:19:51 <mietek> Ah.
19:20:06 <ivanm> quest: note that in your last line, you're consing x onto bs; ergo, you're saying that the `x' in parse' is the same type as the `bs' in parse'
19:20:06 <latro`a> thanks shachaf, difference lists were easy to implement and seem to have sped the code up a bit
19:20:23 <ivanm> latro`a: wait, you implemented difference lists? why not use the dlist package?
19:20:28 <latro`a> err
19:20:29 <latro`a> to use
19:20:34 <ivanm> ahhh
19:20:34 <latro`a> using dlist
19:20:36 <ivanm> makes more sense :p
19:20:40 <latro`a> implementing this with dlist was easy, is what I meant
19:20:44 <ivanm> heh, fair enough
19:20:45 <shachaf> latro`a: Using DList probably isn't even worth it.
19:20:56 <latro`a> oh?
19:21:02 <shachaf> Just use (foo++) instead of (foo) and (.) instead of (++)
19:21:07 <shachaf> And then apply it to [] at the end.
19:21:27 <quest> ivanm well x is same type as bs, but xs shouldnt
19:21:36 <latro`a> I'm not sure that recursion pattern is quite the same as this
19:21:43 <ivanm> quest: simple answer: your entire code seems wrong :p
19:21:45 <quest> because my x:xs is something like 4+5+3+2
19:21:48 <quest> lol
19:21:53 <shachaf> ?
19:21:53 <latro`a> I mean yes, they correspond, but I have intermediate appends
19:21:59 <ivanm> quest: you have "(x:xs)"; ergo if x is of type `a', then `xs :: [a]"
19:22:08 <shachaf> Intermediate appends?
19:22:28 <latro`a> eh, I think I misunderstood you
19:22:36 <latro`a> what you're saying would work fine but arguably be a little less clear
19:22:40 <ivanm> quest: to start with, define parse' as a separate function
19:22:43 <quest> the list is a list of expression, can have Op +, Num 7, Var x
19:22:44 <ivanm> and use better variable names
19:22:47 <mietek> parcs`: you're right, 2x speedup
19:22:54 <mietek> Interesting
19:23:02 <ivanm> quest: I don't care what the operations are; your code is wrong and doesn't type-check! ;-)
19:23:04 <mietek> parcs`: thanks again
19:23:07 <latro`a> point is, using a difference list helped
19:23:13 <quest> ok i'll start over again
19:23:15 <latro`a> and was easy
19:23:20 <parcs`> mietek: no problem, glad i could help
19:23:57 <mietek> parcs`: there's even a tiny speedup when adding bangs to the second argument of the adder function
19:24:11 <shachaf> latro`a: Arguably.
19:24:18 <quest> basically the problem is ask us to write the Dijkstra's "Shunting Yard" Algorithm
19:24:29 <latro`a> upside is that then it would require no imports
19:24:38 <latro`a> (this code is actually quite trivial :))
19:25:21 * hackagebot opentheory-primitive 1.2 - Haskell primitives used by OpenTheory packages  http://hackage.haskell.org/package/opentheory-primitive-1.2 (JoeHurd)
19:25:24 * hackagebot opentheory 1.74 - The Haskell base  http://hackage.haskell.org/package/opentheory-1.74 (JoeHurd)
19:25:26 * hackagebot opentheory-parser 1.115 - Stream parsers  http://hackage.haskell.org/package/opentheory-parser-1.115 (JoeHurd)
19:35:22 * hackagebot opentheory-char 1.39 - Unicode characters  http://hackage.haskell.org/package/opentheory-char-1.39 (JoeHurd)
19:35:24 * hackagebot opentheory-prime 1.21 - Prime numbers  http://hackage.haskell.org/package/opentheory-prime-1.21 (JoeHurd)
19:37:58 <cornihilio> if I declare a value in a where clause, but it's never used (it's just there for debugging), is it evaluated?
19:38:43 <ion> no
19:40:27 <cornihilio> okay
19:41:02 <ion> > let a = 42 where { foo = error "oh noes" } in a
19:41:03 <lambdabot>   42
19:41:12 <cornihilio> I put this into Cabal/Distribution/Simple/LHC.hs https://gist.github.com/4043558 and I can't seem to trigger the debugging statement. does anyone know what I might be doing wrong?
19:42:21 <quest> error  lexical error in string/character literal at end of input
19:42:40 <ivanm> you forgot to close a bracket or something
20:07:59 <signalsea> hi all, question ... does an expression like " (\a -> foo a) <$> Const b" just discard the anonymous function?
20:08:25 <shachaf> signalsea: Try it out!
20:08:53 <shachaf> There's only one way to write fmap for Const, and it turns out that yes. :-)
20:09:06 <shachaf> (Well, OK... You could have a function-strict fmap if you were crazy.)
20:09:21 <signalsea> but it's essentially because of laziness right?
20:09:26 <signalsea> I have tried it out
20:09:44 <signalsea> in seeking to understand Twan Van Laarhoven's CPS fun refs articl
20:09:45 <signalsea> e
20:09:49 <shachaf> It doesn't have much to do with laziness.
20:10:03 <shachaf> The same thing would work in a strict language.
20:10:34 <shachaf> > getConst $ Const 3
20:10:35 <lambdabot>   3
20:10:42 <shachaf> > getConst $ fmap (\x -> error "hi") Const 3
20:10:43 <lambdabot>   *Exception: hi
20:10:50 <shachaf> Er.
20:10:51 <shachaf> > getConst $ fmap (\x -> error "hi") (Const 3)
20:10:52 <lambdabot>   3
20:11:06 <Nereid> > getConst $ fmap undefined (Const 3)
20:11:07 <lambdabot>   3
20:11:09 <signalsea> well, how would it infer the intial type of b in the type "Const a b" constructed from some "Const a" if the fmap'd function were polymorphic
20:11:45 <signalsea> like for example ((\a' -> (a', b) <$> Const "foo")
20:12:00 <Nereid> what's b?
20:12:00 <startling> > getConst $ fmap (const mempty) (Const 3)
20:12:02 <lambdabot>   Ambiguous type variable `b0' in the constraint:
20:12:02 <lambdabot>    (Data.Monoid.Monoid b0) ...
20:12:09 <startling> signalsea: ^
20:12:30 <shachaf> That doesn't parenthesis-check. :-)
20:12:32 <spherox> Is there a common function like
20:12:47 <signalsea> oopsies
20:12:47 <spherox> which fn a b = if fn a b then a else b
20:12:48 <shachaf> signalsea: I think the most helpful way to think of this is to start with the idea of mapM
20:13:14 <shachaf> spherox: Nope.
20:13:14 <signalsea> shachaf: how do you mean?
20:13:45 <spherox> shachaf, ok. It seems like a good generalization of min/max
20:13:54 <spherox> i.e. min = which (<), max = which (>)
20:14:23 <shachaf> signalsea: Well, that's if you were also looking to understand Traversal. :-)
20:15:11 <signalsea> shachaf: I'd like to, but I'm focused on just the cps functional references article atm
20:15:46 <shachaf> OK. Well, understand it any way that works.
20:15:57 <cornihilio> I put this into Cabal/Distribution/Simple/LHC.hs https://gist.github.com/4043558 and I can't seem to trigger the debugging statement. does anyone know what I might be doing wrong?
20:16:05 <shachaf> The reason this representation is interesting is probably the generalizations that it lets you make.
20:20:58 <cornihilio> on another note, [] and maybe are the same kind, right?
20:21:06 <shachaf> :k []
20:21:08 <lambdabot> * -> *
20:21:09 <shachaf> :k Maybe
20:21:10 <lambdabot> * -> *
20:21:26 <otters> :k Either
20:21:28 <lambdabot> * -> * -> *
20:21:32 <cornihilio> and that means they are equivalent?
20:21:34 <otters> is there any kind variable other than *
20:21:49 <shachaf> * isn't a variable.
20:22:05 <otters> yeah, I figured variable wasn't the right word
20:22:16 <shachaf> In Haskell 98, every kind is either (*) or (a -> b), where a and b are kinds.
20:22:22 <otters> okay
20:23:36 <signalsea> cornihilio: in what sense do you mean equivalent? They do have the same kind.
20:26:48 <cornihilio> signalsea: so "* -> *" is the kind of those two monads?
20:26:50 <Cale> :k RWST
20:26:51 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
20:26:59 <Cale> cornihilio: * -> * is the kind of every monad
20:27:09 <shachaf> Every monad is kinda * -> *
20:27:14 <Cale> :k Monad
20:27:15 <lambdabot> (* -> *) -> Constraint
20:27:45 <cornihilio> thank you for clearing that up
20:27:47 <shachaf> Note to otters: This is outside the realm of Haskell 98.
20:30:23 * hackagebot reactive-thread 0.3.1.0 - Reactive programming via imperative threads  http://hackage.haskell.org/package/reactive-thread-0.3.1.0 (MattGlazar)
20:40:23 * hackagebot aeson-lens 0.3.0.0 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.3.0.0 (HideyukiTanaka)
20:41:07 <Nereid> what's new in this version?
20:41:47 * geekosaur wants to ask if Mentor is listening...
20:41:48 <Nereid> ah, asDouble/Text/Bool
20:41:53 <Nereid> and as
20:44:34 <Ghoul> Irrelevant, but, AMD or Intel?
20:44:41 <Ghoul> in a laptop.
20:44:56 <shachaf> You answered your own question! :-)
20:45:02 <Nereid> lol
20:45:22 <ivanm> Ghoul: you can still get laptops with AMD CPUs? :o
20:45:54 <Ghoul> Well, im not sure whether the new A10 apu is a good choice
20:46:07 <Nereid> I'm under the impression that intel is better at performance against power consumption but I haven't really been following anything recently.
20:46:09 <Ghoul> I have an A8-3500M and I like it.
20:46:18 <Ghoul> A10 has better power consump
20:46:23 <Nereid> loving my new laptop though.
20:46:24 <ivanm> Nereid: that's the impression I also get, though AMD is often a better bang for buck
20:46:28 <Ghoul> high end i7's trump it in performance
20:46:33 <Ghoul> but its really unfair for amd I think
20:46:40 <Ghoul> because those intel's cost like $600
20:46:51 <Nereid> so don't get a high end i7?
20:47:20 <Ghoul> the A10 is like $200 so there isnt really a review that isnt cost biased
20:47:27 <Ghoul> to know what's better in a $1k laptop
20:50:39 <febuiles> Hi. Reading about FRP I saw something like (lbp -=> blue) and I was wondering if -=> is a Haskell operator or if it's something that's defined within FRP frameworks. (my Haskell knowledge is almost zero)
20:51:15 <Ralith> the latter.
20:52:29 <febuiles> ty
20:53:13 <Jafet> It's a Haskell operator that's defined by the FRP framework
20:53:26 <ivanm> how would you determine which operators are "Haskell" operators?  in-built and can't be replaced (e.g. `:' )?  Defined in libraries specified by a standard report?
20:53:40 <febuiles> Jafet ivanm: my bad, should've said "built-in operator"
20:54:45 <ivanm> febuiles: I'm wondering what a "built-in operator is", since most of the Haskell language is defined _in_ Haskell
20:55:00 <johnw> : and , are built-in operators, aren't they?
20:55:09 <ivanm> e.g. the definition of `+' is in the Num typeclass, rather than some hard-coded-into-compiler operator
20:55:11 <shachaf> , isn't really an operator.
20:55:14 <ivanm> yeah
20:55:18 <shachaf> : is, though.
20:55:27 <ivanm> is ~ considered an operator?
20:55:34 <johnw> and also the special handling of (-1)
20:55:37 <shachaf> Sounds like an argument about words!
20:55:37 <johnw> that would be an operator
20:55:42 <ivanm> shachaf: heh
20:55:50 <shachaf> Let's don't.
20:55:58 <Jafet> :t words
20:56:01 <lambdabot> String -> [String]
20:56:08 <ivanm> Jafet: heh
20:56:15 <Jafet> :t fighting
20:56:17 <lambdabot> Not in scope: `fighting'
20:56:49 <febuiles> ivanm: built-in as in: I don't have to define it myself, someone already did (in Haskell or w/e) :)
20:57:19 <ivanm> febuiles: in that case yes, -=> is built-in into one of the FRP libraries (assuming you read it in documentation) ;-)
20:57:42 <ivanm> and my question wasn't aimed at you specifically; just wondering where in general we could draw the line for "built-in"
20:57:57 <shachaf> tibbe: Does "From an engineering perspective I simply don't think the costs outweigh the benefits." mean you think it's a good idea or a bad idea?
20:59:13 <tibbe> shachaf: bad idea with alternative prelude
20:59:15 <febuiles> ivanm: np, I'm still struggling to express myself correctly.
20:59:17 * tibbe goes and watches a movie
21:00:24 * hackagebot Histogram 0.1.0.2 -   http://hackage.haskell.org/package/Histogram-0.1.0.2 (MikeIzbicki)
21:03:12 <caseyjames> Hi, I'm getting started with haskell and was wondering if anyone here has experience getting it running on ios?
21:03:37 <shachaf> I think blackh might know something.
21:04:35 <caseyjames> cool, ill send him a message.  I am very excited to get started with this language.
21:40:26 * hackagebot AhoCorasick 0.0.3 - Aho-Corasick string matching algorithm  http://hackage.haskell.org/package/AhoCorasick-0.0.3 (SergeyLymar)
21:44:21 <ion> The Fisher-Prescott-Burnham string matching algorithm is the best.
21:45:18 <shachaf> ion: ?
21:45:50 <ion> shachaf: (==)
21:46:10 <shachaf> I must be missing something.
21:46:44 <ion> * hackagebot AhoCorasick 0.0.3 - Aho-Corasick string matching algorithm http://hackage.haskell.org/package/AhoCorasick-0.0.3 (SergeyLymar)
21:46:52 <ssyl55> hi
21:46:56 <ivanm> shachaf: I think ion is referring to testing if two strings are equal by doing == on them
21:47:04 * ivanm waves idly in ssyl55's general direction
21:47:15 <shachaf> Yes. Where does "Fisher-Prescott-Burnham" come from?
21:47:52 <ivanm> ion has a random-name generator for use with fictional algorithm names! ;-)
22:00:53 <lispy> if your library implements a single algorithm and it's at version 0.0.3, what does that mean? You have just the Setup.hs and cabal files?
22:03:30 <ivanm> lispy: and presumably a file containing the actual algorithm
22:04:26 <simpson> https://github.com/lymar/AhoCorasick/blob/master/Text/AhoCorasick.hs
22:05:11 <ivanm> class constraints in data structures?
22:05:53 <ivanm> explicit Show instances which appear to be identical to those from deriving Show, but less efficient (as they define show rather than showsPrec)
22:06:08 <ivanm> no Read instances
22:16:35 <startling> how do showPrec and ShowS work?
22:17:27 <ivanm> @type showPrec
22:17:28 <shachaf> ShowS is just a difference list.
22:17:29 <lambdabot>     Not in scope: `showPrec'
22:17:29 <lambdabot>     Perhaps you meant one of these:
22:17:29 <lambdabot>       `showsPrec' (imported from Prelude),
22:17:31 <ivanm> @type showsPrec
22:17:32 <lambdabot> Show a => Int -> a -> ShowS
22:17:44 <shachaf> showsPrec also gets a precedence argument.
22:18:05 <ivanm> the precedence argument is used for determining when to put parentheses, etc.
22:18:26 <startling> where do parentheses get inserted for show?
22:18:38 <shachaf> > show (Just (Just 5))
22:18:40 <lambdabot>   "Just (Just 5)"
22:18:45 <startling> OH, neat.
22:20:45 <shachaf> Oh, I didn't know that the Report specifies the law "readsPrec should be able to parse the string produced by showsPrec, and should deliver the value that showsPrec started with"
22:20:53 <shachaf> Oh, hmm, this is just about derived instances.
22:21:13 <startling> makes sense. I don't think read / show makes sense for everything.
22:21:56 <tac> What is "surjective pairing" in lambda calculus?
22:23:15 <tac> oh, nvm
22:23:28 <tac> it's apparently a fancy-ass way of saying it has products
22:45:14 <manju> w00t
22:45:26 <manju> brb
22:47:41 <manju> Haha...got my old nick back. No more sticking to troll nicks, which bring up painful memories.
22:54:59 <neutrino> @hoogle [(a, b)] -> ([a], [b])
22:55:00 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
22:55:00 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
22:55:04 <neutrino> right
22:56:00 <shachaf> Not to be confused with rezip.
22:56:13 <shachaf> @ty rezip . zipper
22:56:15 <lambdabot> a -> a
22:56:19 <neutrino> @hoogle [Either a b] -> ([a], [b])
22:56:20 <lambdabot> Data.Either partitionEithers :: [Either a b] -> ([a], [b])
22:56:57 <otters> @hoogle ⊕
22:56:58 <lambdabot> hoogle: recoverEncode: invalid argument (invalid character)
22:57:02 <otters> aw
22:58:18 <neutrino> otters: :(
22:59:27 <johnw> @hoogle [a] -> [b] -> [(a,b)]
22:59:27 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
22:59:28 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
22:59:28 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
22:59:33 <johnw> is there a single function for getting a cartesian product of two lists?
22:59:50 <johnw> i.e., cartp xs ys = [ (x,y) | x <- xs, y <- ys ]
23:00:26 <lispy> ?hoogle [a] -> [b] -> [(a,b)]
23:00:26 <lambdabot> Prelude zip :: [a] -> [b] -> [(a, b)]
23:00:27 <lambdabot> Data.List zip :: [a] -> [b] -> [(a, b)]
23:00:27 <lambdabot> Test.QuickCheck.Modifiers shrinkState :: ShrinkState s a => a -> s -> [(a, s)]
23:00:36 <lispy> oh, sorry. I didn't see your hoogle
23:00:37 <johnw> yeah, I just did that :)
23:00:58 <lispy> If hoogle didn't find it and it's that generic, it likely doesn't exist
23:01:16 <Saizan> johnw: liftM2 (,)
23:01:23 <johnw> oho!
23:01:36 <johnw> > liftM2 (,) [1,2] [1,2]
23:01:37 <lispy> > liftA2 (,) [1,2,3] "abc"
23:01:38 <lambdabot>   [(1,1),(1,2),(2,1),(2,2)]
23:01:38 <lambdabot>   can't find file: L.hs
23:01:48 <johnw> cool, I wouldn't have thought of using the list monad like that
23:01:51 <lispy> OMG, who stole L.hs from lambdabot ??
23:02:06 <lispy> johnw: and yet you thought to use a list comp!
23:02:19 <johnw> well, the list comp fits the syntax of my set theory book :)
23:02:25 <lispy> Not a criticism, just pointing out that you did kind of think of it.
23:02:47 <johnw> i've been solving a lot of euler problem using sets, and then discovering it's just way too slow and I have to resolve it arithmetically
23:03:08 <lispy> euler problems are often dynamic programming instances
23:03:10 <johnw> and working with powersets is key to a lot of the solutions
23:03:29 <lispy> Have you seen the super elegant powerset in Haskell?
23:03:30 <johnw> well, to some of them
23:03:35 <johnw> no, what is it?
23:03:49 <johnw> subsequences (liftA2 (,) xs ys)?
23:04:07 <lispy> filterM (const [True, False])
23:04:17 <johnw> or, subsequences .: liftA2 (,)
23:04:26 <lispy> > filterM (const [True, False]) [1,2,3]
23:04:28 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
23:04:31 <johnw> huh
23:05:23 <lispy> filterM is conceptually operating on a decision tree. the (const [True, False]) part says to take both branches in that tree
23:05:53 <johnw> can you rewrite that using MonadPlus?
23:06:40 <lispy> We should have a Monad++
23:07:01 <johnw> :t filterM
23:07:02 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
23:07:19 <lispy> > filterM (const [True]) [1..3]
23:07:21 <lambdabot>   [[1,2,3]]
23:07:27 <lispy> > filterM (const [False]) [1..3]
23:07:28 <lambdabot>   [[]]
23:07:46 <Nereid> > filterM (const [True,True]) [1..3]
23:07:48 <lambdabot>   [[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3],[1,2,3]]
23:07:52 <Nereid> heh
23:07:59 <manju> Guys please stop with the spaces in "Haskell Platform" in windows.
23:08:14 <manju> Also please stop putting it in C:\Program Files
23:08:21 <Nereid> why?
23:08:29 <lispy> http://www.reddit.com/r/programming/comments/225f0/beautiful_haskell_implementation_of_maths_power/c227lp
23:08:35 <manju> I've been fighting for 3 days to compile 1 library
23:08:37 <manju> fft
23:08:38 <lispy> johnw: ^^
23:08:40 <manju> in Windows
23:11:06 <johnw> > subsequences [1..3]
23:11:07 <lambdabot>   [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
23:11:13 <manju> Haskell Platform on windows uses mingw
23:11:37 <manju> and mingw with pkg-config has untold problems with directories with spaces.
23:12:42 <Nereid> I think I used my own mingw installation for building such things on windows.
23:13:03 <lispy> manju: please file a bug report: http://trac.haskell.org/haskell-platform/
23:13:24 * lispy goes to bed
23:13:26 <lispy> night folks
23:13:38 <manju> Nereid, so did I, that is why it took 3 days.
23:13:54 <Nereid> I don't remember having to fight with anything.
23:13:57 <manju> Mingw, Msys, gtk, glib, pkg-config and compile fftw.
23:14:04 <manju> Nereid, lucky :-)
23:14:10 <Nereid> although it wasn't with fftw
23:14:25 <Nereid> (although I'd expect fftw to have fewer problems than sdl...)
23:14:40 <manju> my LD path looks like this LD = C:\Program\nFiles\Haskell\nPlatform\...
23:14:51 <manju> Argh how to type newline in xchat ?
23:14:59 <Nereid> you don't.
23:15:12 <manju> So it is spread across 3 lines and it fails.
23:15:23 <Nereid> don't do that then.
23:15:31 <Nereid> I didn't use the mingw that came with haskell platform.
23:15:31 <johnw> lispy: thanks a ton of cluing me into that, lispy
23:16:02 <manju> Nereid, I did, I still get the error.
23:16:04 <johnw> i've wanted to do "tree searches" of sets before, and never had a good tool, but this use of filterM really shows how to make good use of the list monad
23:16:11 <Nereid> did what?
23:16:32 <Nereid> oops I'm sleepy. bye
23:17:23 <manju> Bye.
23:20:59 <manju> Finally success!
23:25:08 <OceanSpray> why does Foldable's requirements include "only foldr" but not "only foldl"?
23:26:15 <johnw> you can implement foldl using foldr, but I'm not sure if the reverse is true...
23:33:53 <Ferdirand> foldl never produces something when given an infinite list, no matter what the folded function is, right ?
23:35:26 <otters> looks that way
23:35:42 <shachaf> Yep.
23:36:35 <Ferdirand> isn't that sufficient to prove you cannot write foldl with foldr ?
23:36:41 <Ferdirand> sorry
23:36:43 <Ferdirand> foldr with foldl
23:36:46 <shachaf> Yep.
23:36:54 <johnw> QED
23:36:57 <shachaf> (Well, that and the fact that it's not true of foldr.)
23:37:17 <shachaf> (FSVO "prove". Agda will require a bit more. :-) )
23:38:04 <Ferdirand> okay, i'm curious. What would Agda require ?
23:39:11 <shachaf> I don't know.
23:39:23 <Ralith> a proof.
23:39:24 <Ralith> :D
23:39:33 <Ferdirand> what is even the formal definition of writing x with y, anyway ?
23:40:37 <ion> Donald Knuth once foldl’d an infinite list.
23:42:21 <shachaf> ion: There are infinite list-like things that you can foldl.
23:43:39 <shachaf> Cale: Can we have "import qualified Data.FMList as FM" in lambdabot?
23:44:18 <ion> FYourListToo
23:44:36 <shachaf> ion: FMList is the future, man.
23:44:50 <ion> dude!
23:46:14 <shachaf> Hmm.
23:46:32 <shachaf> Is there ever a case where "folded" can be asymptotically moe efficient than "traverse"?
