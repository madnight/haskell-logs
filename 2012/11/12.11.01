00:02:32 <johnw> night
00:05:23 <otters> @hoogle [m a] -> m [a]
00:05:26 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
00:05:27 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
00:05:27 <lambdabot> Language.Haskell.TH.Syntax sequenceQ :: [Q a] -> Q [a]
00:06:57 <otters> :t mapM
00:07:13 <lambdabot> thread killed
00:07:32 <otters> okay
00:07:40 <paolino> :t mapM
00:07:52 <lambdabot> forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
00:08:06 <paolino> mh, not referentially transparent
00:08:42 <paolino> :t \f -> sequence . map f
00:09:01 <lambdabot> thread killed
00:09:17 <otters> @pl (\(a,b) -> do c <- b; return (a,c)}
00:09:20 <otters> @pl (\(a,b) -> do c <- b; return (a,c))
00:09:27 <lambdabot> (line 1, column 21):
00:09:28 <lambdabot> unexpected ";"
00:09:28 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
00:09:28 <lambdabot> (line 1, column 21):
00:09:28 <lambdabot> unexpected ";"
00:09:30 <lambdabot> expecting letter or digit, variable, "(", "`", "!!", ".", operator or ")"
00:09:49 <paolino> :t \f -> sequence . map f
00:10:03 <lambdabot> forall (m :: * -> *) a a1. Monad m => (a1 -> m a) -> [a1] -> m [a]
00:11:13 <Cale> ah, I had a runaway ghc
00:11:27 <Cale> hopefully you'll see a bit less "thread killed"
00:12:00 <shachaf> > 1 + 1
00:12:04 <lambdabot>   mueval-core: Time limit exceeded
00:12:06 <shachaf> > 1 + 1
00:12:11 <lambdabot>   mueval-core: Time limit exceeded
00:12:25 <shachaf> > hello
00:12:28 <lambdabot>   Not in scope: `hello'
00:12:32 <shachaf> > 1 + 1
00:12:36 <lambdabot>   2
00:12:46 <shachaf> @ty both
00:12:52 <lambdabot> Not in scope: `both'
00:13:15 <shachaf> :-(
00:13:23 <ski> @type none
00:13:27 <lambdabot> forall a. Maybe a
00:13:34 <paolino> :t second (>>=)
00:13:36 <lambdabot> forall d (m :: * -> *) a b. Monad m => (d, m a) -> (d, (a -> m b) -> m b)
00:13:45 <shachaf> Cale: cabal install lens; echo import Control.Lens >> L.hs
00:15:24 <paolino> :t apply
00:15:37 <lambdabot>     Not in scope: `apply'
00:15:37 <lambdabot>     Perhaps you meant `lapply' (imported from Data.LinearMap)
00:15:44 <paolino> :t app
00:15:46 <lambdabot> forall (a :: * -> * -> *) b c. ArrowApply a => a (a b c, b) c
00:16:29 <coldpizza72i> ANy ideas where I should start with this assigmtn? http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/Parser-kladoi/
00:16:53 <startling> is there an ifoldMap for any TraversableWithIndex in Control.Lens.WithIndex?
00:17:16 <espringe> coldpizza72i: parsec ?
00:19:22 <espringe> coldpizza72i: Just read through the assignment, looks reasonably straight forward to do with parsec
00:19:45 <coldpizza72i> espringe: so i can make a recursive descent parser using parsec?
00:19:51 <espringe> si
00:20:12 <espringe> There's a good tutorial on RealWorldHaskell and one on make you a scheme etc.
00:20:18 <espringe> probably more too if you google it
00:20:33 <paolino> :t fmap ((,) . fst)
00:20:43 <lambdabot> forall (f :: * -> *) a b b1. Functor f => f (a, b1) -> f (b -> (a, b))
00:20:46 <Cale> coldpizza72i: Well, first you should find a time machine, and then travel back in time to when you were first given the assignment. Then you should tell yourself not to start this assignment on the day when it's due. ;)
00:21:02 <Cale> (but if you know what you're doing, this should be pretty doable, really)
00:21:12 <espringe> And if I can make a recommendation, leave the operators to (+ - * / ) to last -- they're a bit tricky if haven't done stuff with parsers before
00:21:37 <coldpizza72i> Cale: you think 20+hours isn't enough?
00:21:51 <espringe> If you know haskell it should be fine
00:21:56 <espringe> if not, you're screwed :D
00:22:02 <Cale> Well, depending on what you know, an hour might be fine :)
00:22:49 <espringe> Oh, the operators are prefix. That's easy, don't worry about it :D
00:23:00 <espringe> Yeah, doesn't look like they're any gotchas
00:24:23 <paolino> :t (fmap . (,) . fst)
00:24:32 <lambdabot> forall (f :: * -> *) a a1 b. Functor f => (a1, b) -> f a -> f (a1, a)
00:25:01 <mikeplus64> is there any library providing an instance for Floating Rational?
00:25:06 <Cale> coldpizza72i: Have you talked much about, say, parser combinator libraries in this course?
00:25:19 <coldpizza72i> nope
00:25:42 <espringe> coldpizza72i: Invest an hour, and work through this: http://book.realworldhaskell.org/read/using-parsec.html
00:25:53 <espringe> playing with the repl really helps get an intuition how it works
00:25:56 <Cale> (Parsec is an example of one of those, though it's sort of a large piece of machinery to just pull in for an assignment)
00:26:31 <Cale> (though it, or something like it, makes this program significantly easier to write)
00:27:28 <mikeplus64> also, is there a library with arrays with lengths encoded as type literals in their types yet?
00:27:47 <espringe> boost::array :D
00:28:26 <mikeplus64> (lalalala)
00:28:54 <startling> why does the TraversableWithIndex instance for Map require Ord? the definition is itraverse f = sequenceA . Map.mapWithKey f, none of which require Ord.
00:35:31 <Cale> startling: I guess it wouldn't have to, though it would also be kinda weird if somehow you couldn't provide such an instance.
00:35:44 <paolino> :t app . first (fmap . (,))
00:35:49 <lambdabot>     Ambiguous occurrence `first'
00:35:49 <lambdabot>     It could refer to either `Control.Arrow.first',
00:35:49 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
00:36:00 <shachaf> ...Or?
00:36:01 <Cale> lol
00:36:04 <shachaf> Don't leave us hanging, lmabdabot!
00:36:10 <Cale> shachaf: GUESS
00:36:35 <paolino> :t app . Control.Arrow.first (fmap . (,))
00:36:37 <lambdabot> forall b (f :: * -> *) a. Functor f => (b, f a) -> f (b, a)
00:36:39 <shachaf> Cale: Well, it's not Control.Lens, because that doesnt' export a "first".
00:37:09 <Cale> hehe, it's actually kinda obscure
00:37:11 <Jafet> :t (%~)
00:37:12 <startling> Cale, why would it be kinda weird?
00:37:13 <lambdabot>     Not in scope: `%~'
00:37:13 <lambdabot>     Perhaps you meant `%' (imported from Data.Ratio)
00:37:13 <shachaf> Control.Lens calls first (over _1)
00:37:16 <paolino> (ok, now I'm awake)
00:37:29 <startling> Cale, everything works if I just get rid of the Ord k =>
00:37:40 <Cale> startling: because a Map whose keys aren't an instance of Ord is pretty useless generally
00:37:43 <shachaf> Cale: Oh, Doc.
00:37:59 <shachaf> What's up, Doc?
00:38:00 <startling> Cale, sure, but maybe I still want to traverse it with an index.
00:38:24 <Cale> @undefine
00:39:09 <shachaf> @let both f (x,y) = (,) <$> f x <*> f y
00:39:11 <lambdabot>  Defined.
00:39:17 <Cale> startling: you can't even have a Map with more than one element like that, though.
00:39:41 <startling> Cale, yes I can. I can map or traverse some other map.
00:39:48 <Cale> ?
00:40:04 <startling> Cale, fmap doesn't require Ord.
00:40:34 <Cale> yes, but any operation which creates a Map with more than one element requires the key type to be an instance of Ord
00:41:01 <startling> oh, right, altering the keys requires Ord.
00:41:17 <Cale> It used to be that you couldn't even create an empty map without an Ord instance, iirc, which was still sensible
00:41:30 <startling> that's probably why Lens has that, then
00:41:50 <startling> (backwards compatibility)
00:42:01 <startling> it just struck me as odd to require that there for no reason.
00:42:15 <Jafet> :t M.singleton
00:42:17 <lambdabot> forall k a. k -> a -> M.Map k a
00:42:46 <statusfailed> I'm getting "Unacceptable argument type in foreign decaration: CInt" cabal-installing the riak package
00:42:51 <statusfailed> is anyone else able to build it?
00:43:32 <paolino> a 7.6 problem
00:44:01 <statusfailed> paolino: A bug, or something I can fix?
00:44:25 <yitz> @type first
00:44:27 <lambdabot> forall (a :: * -> * -> *) b c d. Arrow a => a b c -> a (b, d) (c, d)
00:44:38 <paolino> it's about type vs newtypes in FFI
00:45:24 <paolino> CInt is a type synonym
00:45:31 <paolino> I think
00:45:51 <Cale> Not according to the Haddock
00:46:21 <yitz> coldpizza72i: watch out for a small bug in the homework specification. in the grammar, a Prog must have at least one Stmt, but in the Haskell type it can be Empty.
00:46:21 <Cale> It's apparently a newtype.
00:46:44 <paolino> ok, I shut up
00:47:05 <shachaf> stepcut: You need to add CInt(..) to the import
00:47:11 <shachaf> Er, statusfailed:
00:47:15 <shachaf> Rather than just CInt
00:47:15 <statusfailed> thought so :p
00:47:27 <shachaf> It's a bug in GHC 7.4. :-)
00:47:35 <statusfailed> wait- the import of riak?
00:47:46 <statusfailed> or the import in riak's code
00:48:40 <Cale> statusfailed: It sounds like the data constructor for CInt needs to be in scope wherever the foreign import is.
00:48:51 <morel> what's the best (meaning simplest and shortest) alternative to "f x = case g x of { Foo -> foo; Bar -> bar; }" ?
00:48:56 <statusfailed> Hmm, the offending file has this line: import Foreign.C.Types (CInt(..))
00:49:17 <startling> morel: well, what are Foo and Bar?
00:49:19 <statusfailed> The offending file being this: https://github.com/bos/riak-haskell-client/blob/master/src/Network/Riak/Connection/NoPush.hsc
00:49:32 <morel> startling: pairs (tuples,likeThis)
00:49:57 <statusfailed> morel: pattern match?
00:50:07 <Cale> statusfailed: Are you sure you have that exact version of it?
00:50:18 <morel> startling: Foo is "(beforeO,[])", and Bar is "(beforeO,(_:afterO))"
00:50:20 <statusfailed> no, I'll try compiling from the github
00:50:31 <statusfailed> good point
00:50:38 <Cale> statusfailed: The last change to that file was "Fix build with GHC 7.6"
00:50:45 <startling> morel: exactly how you have it, then
00:50:49 <morel> statusfailed: i can't pattern match directly because i need to apply "g" on "x" first.
00:51:05 <statusfailed> oh yeah, whoops :)
00:51:14 <Cale> https://github.com/bos/riak-haskell-client/commit/281a2fd835103d31bf349f306202b36602eb2806#src/Network/Riak/Connection/NoPush.hsc
00:51:29 <morel> startling: what about view patterns and pattern guards? do they help here?
00:51:38 <startling> not really.
00:51:58 <statusfailed> what's wrong with case?
00:52:45 <Cale> morel: pattern guards *might* be useful, though in the exact example you provided, they're counterproductive
00:52:47 <morel> it's too long... :/
00:53:05 <ski>   f (g -> (beforeO,[])) = foo
00:53:06 <ski>   f (g -> (beforeO,(_:afterO))) = bar
00:53:10 <ski> is one way
00:53:12 <morel> hm.. i think i'm looking for view patterns, ain't me?
00:53:16 <morel> yeah
00:53:22 <morel> that's nice
00:53:48 <morel> thanks :)
00:54:01 <ski> using pattern guards as well (or instead) might be nicer
00:54:27 <morel> ski: your statement is contrary to what Cale said, i think
00:54:55 <Cale> It's not contrary
00:55:00 <morel> ok
00:55:02 <Cale> I don't know what your actual code is
00:55:24 <ski>   f (g -> (beforeO,ys))
00:55:27 <ski>     | [      ] <- ys = foo
00:55:29 <ski>     | _:afterO <- ys = bar
00:55:32 <ski> alternatively
00:55:46 <ski>   f x
00:55:47 <ski>     | [      ] <- ys = foo
00:55:50 <ski>     | _:afterO <- ys = bar
00:55:53 <ski>       where
00:56:04 <ski>       (beforeO,ys) = g x
00:56:07 <statusfailed> wahhh all my github connections keep timing out
00:56:14 <morel> hmmm
00:56:38 <ski> these two latter probably have a higher chance of only calling `g' once on the input
00:56:57 <morel> yeah... i see..
00:57:08 * morel goes with the last one =)
00:57:17 <ski> (=
00:58:03 <morel> i bet the user "edwardk" will timeout in ca. 90 seconds
00:58:08 <morel> haha
01:00:16 <startling> is there a typeclass for traversing over two different kinds of elements of a thing?
01:01:07 <startling> I've got a tree; I want to apply one traversal to all the branches and another to all the leaves.
01:01:13 <morel> does "kind" mean "type of a type" in this phrase?
01:01:32 <startling> no, I should have said "type"
01:01:38 <morel> ok :)
01:01:57 <startling> damn category theorists appropriating my language.
01:02:16 <ski> "kind" doesn't really mean "type of a type" in category theory
01:02:27 <morel> but kind of
01:02:27 <morel> :D
01:02:36 <ski> you'll have to blame the type theorists
01:02:42 <startling> fair enough.
01:03:03 <ski> (and then probably only some sections of them)
01:03:23 <startling> ski: by "section" do you mean something like (12 +)?
01:03:52 <morel> heh :D
01:04:01 * ski nods solemnly
01:10:49 <Jafet> :t zipWith zip
01:10:50 <lambdabot> forall a b. [[a]] -> [[b]] -> [[(a, b)]]
01:20:54 * morel there's a whole planet waiting for me to rescue it
01:26:13 <Saizan> the whole value vs. type vs. kind distinction has pretty different connotations once type constructors cannot be matched over at compile-time and you have actual values in types instead
01:34:41 <fmap> > gcd 0 0
01:34:43 <lambdabot>   0
01:55:17 <mikeplus64> is there a way to "elevate" a value determined at runtime, e.g. the length of a list, to the type level?
01:55:27 <mikeplus64> i would guess not, but anything is possible ...
01:56:45 * hackagebot cabal-rpm 0.6.5 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.6.5 (JensPetersen)
01:57:31 <Jafet> You can attach a value to an existential type
01:57:59 <Jafet> But values cannot affect types
01:58:26 <Ralith> mikeplus64: in dependently typed languages, yes; in haskell, mostly no.
01:59:07 <Ralith> "mostly," because you can do some really evil things with haskell's type system if you are willing to enable enough extensions and go through enough contortions
01:59:34 <mikeplus64> i think i could use TH to break stuff
02:00:30 <Ralith> not TH, no.
02:00:33 <Ralith> TH is static.
02:00:36 <mikeplus64> yeah
02:00:46 <Jafet> The hammer
02:00:53 <mikeplus64> i mean somtehing like fromList [magic|0,1,2,3,4,5|] produces something :: Array (length of the argument) Int
02:01:22 <mikeplus64> that isn't really an answer to the original question, but it's a solution to what i'm trying to do
02:01:24 <Jafet> That is not dependently typed
02:03:34 <ski> fmap : .. oh !
02:04:14 <Ralith> mikeplus64: that's compiletime, not runtime.
02:04:28 <Ralith> and should be possible.
02:04:36 <Ralith> (without painful contortions beyond TH, even)
02:05:46 <Jafet> data Z; data S n; (:::) :: a -> Vec n a -> Vec (S n) a
02:05:54 <Jafet> or some other hack
02:05:58 <mikeplus64> yeah
02:06:34 <Jafet> You can't express that as a list, though
02:06:52 <mikeplus64> is this possible? data List len a where Cons :: a -> List (len + 1) a; Nil :: List 0 a
02:07:05 <Jafet> Absolutely not
02:07:11 <Jafet> Try #agda
02:07:19 <mikeplus64> GHCi doesn't mind it
02:07:53 <Ralith> or #idris
02:08:04 <Jafet> Okay, you can do some things with the new nat kind
02:08:55 <mikeplus64> oops i mean data List len a where Cons :: a -> List len a -> List (len + 1) a; Nil :: List 0 a
02:09:20 <mikeplus64> Prelude GHC.TypeLits> :t Cons 0 (Cons 1 Nil)
02:09:22 <mikeplus64> Cons 0 (Cons 1 Nil) :: Num a => List ((0 + 1) + 1) a
02:09:24 <mikeplus64> good enough
02:11:13 <coldpizza72i> Is parsec something that has to be installed?
02:11:54 <Jafet> Hm, what is the limit of the nat kind?
02:12:25 <Jafet> coldpizza: if you don't have parsec, and you want parsec, you need to install parsec
02:15:36 <Ralith> mikeplus64: I certainly hope it reduces that sooner or later, otherwise it's not much use...
02:16:34 <Ralith> mikeplus64: anyway, this works much better in idris.
02:16:54 <Jafet> Dependent typing tends to work much better in a dependently typed language
02:18:21 <Jafet> Actually, this still isn't dependent typing, because the Nats are not values
02:18:33 <mikeplus64> this is still fun though :)
02:20:14 <Jafet> So this is out: takeList :: (m : Nat) -> List n a -> List (n - m) a
02:24:14 <shachaf> Jafet: The Nat kind is pretty useless currently for most things you'd want to do.
02:24:30 <shachaf> More useless than the DataKind data N = Z | S N
02:25:17 <Ralith> that's pretty sad
02:25:30 <Jafet> Is DataKinds a different extension?
02:28:11 <mikeplus64> *Main GHC.TypeLits> fromList ("i'm" :> "a" :> "terible" :> "person" :> Z)
02:28:13 <mikeplus64> Array (fromList ["i'm","a","terible","person"])
02:28:15 <mikeplus64> it :: Array ((((0 + 1) + 1) + 1) + 1) String
02:29:17 <Jafet> @hoogle (:>)
02:29:18 <lambdabot> Data.Sequence (:>) :: Seq a -> a -> ViewR a
02:29:27 <mikeplus64>  :> is my Cons
02:29:39 <mikeplus64> (:>) :: a -> List l a -> List (l + 1) a
02:35:46 <Ralith> mikeplus64: seriously, play with something dependently typed; they're really cool.
02:36:48 * hackagebot iCalendar 0.1 - iCalendar data types, parser, and printer.  http://hackage.haskell.org/package/iCalendar-0.1 (ChristianRoedliAmble)
02:39:06 <mikeplus64> Ralith: will do
02:48:02 <coldpizza72i> Can someone help me with this http://ideone.com/JGbcaD
02:49:14 <chra> Other than that you have :: instead of = on line 57?
02:50:00 <coldpizza72i> oops
02:50:05 <coldpizza72i> …its getting late
02:54:27 <Ralith> coldpizza72i: it helps to frequently compile your code so that you know as soon as you make an error and don't have to guess what it was you did
03:02:37 <simon> what library do I use for parsing command-line arguments?
03:03:40 <zomg> simon: getopt, cmdargs, whatever =)
03:04:14 <yitz> simon: there are zillions of them now in different styles. search hackage and pick one that suits you.
03:05:16 <mikeplus64> *Main GHC.TypeLits> let arr :: Array 10 Int; arr = Array (V.fromList [1..9]) in arr ! (sing::Sing 2)
03:05:19 <mikeplus64> <interactive>:31:65:
03:05:20 <mikeplus64>     No instance for (2 <= 10) arising from a use of `!'
03:05:22 <mikeplus64> :(
03:06:32 <yitz> simon: how did you get that irc nick? you are an instant guru.
03:07:55 <yitz> mikeplus64: that is one of the strangest GHC errors i have ever seen
03:09:03 <mikeplus64> yitz: yeah it is very perculiar
03:09:14 <mauke> makes perfect sense if <= is a class and 2, 10 types
03:09:57 <mikeplus64> i'm using GHC.TypeLits' Nat and <=, (!) ::  (i <= l) => Array l a -> Sing i -> a
03:10:52 <mikeplus64> i thought that <= would have the "correct" instances for everything magically, so that there is an instance for 2 <= 10 for example
03:20:07 <hiji> Non-technical question, but why is Haskell apparently so popular in the financial industry? Strictness? Parallelizability? Speed? I'm just starting out and I've been thinking about this.
03:20:07 <simon> yitz, being "simon" on #haskell has its disadvantages. for example, I can never expect highlights to make sense. (:
03:20:26 <simon> yitz, normally when I hang out here for longer periods I switch to "sshine".
03:20:43 <simon> hiji, type safety.
03:21:51 * hackagebot netwire 4.0.1 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.1 (ErtugrulSoeylemez)
03:22:08 <hiji> simon, If type safety is so critical to mission-critical programs, why arent other industries using Haskell extensively? Or is it just that we dont hear anything about them?
03:22:40 <merijn> hiji: Some industries are
03:23:04 <hiji> merijn, like?
03:23:24 <merijn> hiji: I remember one of my theoretical CS profs got paid a few 100k to help formally verify the correctness of some embedded software (for truck elevators) after they lost a ton of money when a bug dropped a loaded truck to the ground
03:24:05 <hiji> but the embedded s/w itself wasnt in Haskell, right?
03:24:40 <merijn> hiji: In this case they wrote a proof in (I think) Coq and then extracted a correct ocaml program from that
03:25:00 <nohonor> is there a nice synonym for "monomorphic type" ?
03:25:07 <nohonor> since i see that "concrete" means something else
03:25:28 <cads> merijn, is there a ocamlculus for showing the correctness of the program?
03:25:29 <merijn> nohonor: What's wrong with the term "monomorphic type"? :p
03:25:36 <Ralith> hiji: another thing about the authors of mission-critical software is that they are necessarily very slow to decide to redo everything in another environment
03:25:40 <nohonor> as in "type expression of kind * without uninstantiated variables in context"
03:26:03 <hiji> merijn, but then why again is type safety so important?
03:26:11 <nohonor> merijn, i'm trying to find a more common term to use when talking to OO people
03:26:35 <merijn> hiji: You can encode correctness guarantees into the types, forcing the compiler to prove invariants to succesfully compile
03:26:39 <espringe> "fully qualified type"  ?
03:26:50 <espringe> "fully instantiated type" maybe
03:27:07 <espringe> Look at what error the Java compiler gives if you try to use a List without type arguments :D
03:27:12 <nohonor> espringe, doesn't "qualified" normally refers to namespace qualification :-)
03:27:13 <simon> hiji, it may be that the financial sector already has an affinity for mathematical notation, and Haskell is more mathematical than other programming languages.
03:27:24 <shachaf> Concrete types like "aerated autoclaved", "asphalt", "roller-compacted", "fiber-reinforced"?
03:27:26 <nohonor> espringe, interesting... what errors?
03:27:30 <hiji> simon, fair enough
03:27:48 <nohonor> shachaf, high-performance, acid-resistant, prestressed
03:27:59 <merijn> hiji: A simple example, I have some code that has two types of records, Data and Control records. I encode the difference in the type even though they're the same data structure, the result is that the type checker guarantees I never pass the wrong record type to a function
03:28:34 <nohonor> "fully instantiated" sounds ok
03:28:39 <simon> hiji, i.e. there is less risk of not finding competent programmers who want to write the software. if you make web apps and use Haskell, your potential employees are mostly limited to CS students who will often try to avoid making web apps.
03:29:57 <merijn> hiji: Have you heard of phantom types yet?
03:30:01 <hiji> merijn, do imperative languages not offer the same guarantees?
03:30:06 <hiji> merijn, no I haven't
03:30:31 <merijn> hiji: They could, given a sufficiently advanced type system that makes it behave a lot more like haskell :p
03:30:43 <hiji> merijn, haha :D
03:31:01 <shachaf> merijn: You *can* have two types that have the same representation in, say, C.
03:31:05 <merijn> hiji: For your type proofs to be worth something you need referential transparency (i.e., no side effects), otherwise the types don't tell you enough to write a good guarantee
03:31:17 <shachaf> struct Foo { Blah val; }; struct Bar { Blah val };
03:31:31 <shachaf> There you go, difference encoded in the type.
03:31:55 <fmap> hiji: implies haskell isn't imperative language
03:32:04 <hiji> simon, so I should avoid Haskell if I am thinking of quick-n-dirty web apps or startups based on them
03:32:39 <espringe> probably. You could try clojure if you're after more dirty but functional programming
03:33:13 <hiji> espringe, in that case what do I lose if I choose clojure?
03:33:16 <zomg> Clojure is pretty easy to get started, a lot easier than Haskell for sure
03:33:18 <espringe> its definitely more accessible
03:33:18 <srhb> hiji: I don't think I agree, it seems there are a lot of people who are just dying to get paid to do actual Haskell.
03:33:25 <srhb> Is it? O_o
03:33:48 <espringe> hiji: you lose all compile-time saftey (other than a few cases where it's like "used function with wrong amount of arguments)
03:33:51 <hiji> srhb, are they dying because middle managers dont understand the strengths of Haskell?
03:33:54 <espringe> but you keep a lot of the functioanl benefits
03:34:01 <srhb> hiji: I believe so.
03:34:18 <simon> hiji, I don't know... I'm thinking if I should ever write a lot of web apps, I'd use Haskell or Erlang.
03:35:16 <simon> hi srhb :)
03:35:23 <srhb> simon: ! :)
03:35:37 <simon> srhb, I wonder, if someone were to pronounce "srhb", would it be "sherb" or "shrub"?
03:35:58 <espringe> "serb" is how i've been mentally pronouncing it
03:36:03 <hiji> I went "sirhub"
03:36:04 <srhb> simon: I never thought of sherb. shrub was the intention :P
03:36:08 <srhb> haha
03:36:18 <srhb> Oh dear, time for a new nick.. :P
03:36:29 <hiji> partly coz I'm listening to Sir Mixalot
03:36:30 <simon> "sirhub" would probably be a bit off since srhb's name is Sarah.
03:36:59 <simon> although in Game of Thrones, both men and women, if knights, can hold the title "Ser" :)
03:37:03 <srhb> Screw it, I'll take it gives me a knightly title
03:37:40 <espringe> Well if its acceptable in GameOfThrones, it's definitely acceptable in real life  :P
03:39:07 <hiji> srhb, sorry, I tried coming up with meaningful combinations out of sirhub, but the only ones I can think of are "hubris" and "rubish" and "shirub" none of which are good or make sense :D
03:40:10 <merijn> hiji: btw, although you might think fmap was joking he was actually rather serious about calling Haskell an imperative language
03:40:30 <merijn> Haskell is by far my favorite imperative language
03:40:39 <espringe> if haskell is an imperative language, what's a functional one?
03:40:54 <merijn> espringe: Imperative and functional are not mutually exclusive
03:40:59 <shachaf> srhb: I pronounce "srhb" "S R H B".
03:41:07 <merijn> espringe: The IO monad is essentially an EDSL for writing imperative code
03:41:07 <shachaf> It's pretty creative.
03:41:34 <merijn> espringe: And it happens that it is a rather nice EDSL too
03:41:41 <simon> shachaf, maybe we need a revival of that "Hi. My name is Linus Torvalds and I pronounce ..." culture :)
03:41:52 <espringe> merijn: fair point, although I do think when you start calling haskell imperative it takes away the meaning from the term :D
03:42:05 <sipa> simon: the only .au file i ever had on my drive!
03:42:39 <espringe> "imperative language" just becomes "turing complete language"
03:42:50 <espringe> unless there's another language you'd call non-imperative ?
03:42:55 <nand`> so to summarize
03:42:55 <merijn> espringe: It depends, I have some haskell code which is essentially all in the IO monad, imperative style and it's much nicer than the equivalent code would have been in other languages
03:43:10 <shachaf> espringe: It's OK, the term doesn't have meaning in the first place.
03:43:23 <shachaf> It sounds like people here are just looking to argue about words.
03:43:33 <nand`> Haskell is imperative, object oriented and dynamically typed
03:43:41 <espringe> :P
03:43:44 <merijn> espringe: I'd call haskell multi-paradigm, it is both imperative and functional
03:43:57 <Sculptor> i liked that title
03:44:05 <nand`> any questions?
03:44:06 <merijn> Or rather, haskell is functional but IO is imperative
03:44:09 <espringe> can we add logical/declarative to that list?
03:44:29 <merijn> espringe: Sure, you can add anything you like
03:44:37 <Sculptor> "is your keyboard jammed, or you are just writing haskell?"
03:44:57 <hiptobecubic> monads are imperative
03:45:04 <espringe>  /me goes to update the wikipedia entry on haskell
03:45:15 <nand`> I think that anecdote fits perl far more
03:45:34 <merijn> hiptobecubic: Not all of them
03:45:51 <nohonor> what's imperative about IO
03:46:01 <hiptobecubic> Which isn't? When you start working it I mean.
03:46:05 <nohonor> you're just composing a tree of expressions
03:46:14 <nohonor> no one's forcing you to execute it
03:46:24 <shachaf> This is such a useless discussion.
03:46:31 <hiptobecubic> nohonor, sure, and no one forces you to run your C code after you write it either.
03:46:33 <shachaf> I recommend that you all stop caring about what's "imperative".
03:46:37 <merijn> shachaf: Well, it started out reasonably interesting, but not any more
03:46:42 <nohonor> hiptobecubic, but you can't put your C code in a list
03:46:52 <shachaf> http://worstargumentintheworld.com/
03:47:00 <merijn> shachaf: It can be enlightening to realise IO lets you write imperative haskell, but arguing about the details is boring
03:47:10 <nand`> the worst arguments in the world are arguments about the meanings of words
03:47:15 <nohonor> i think this discussion needs some definitions
03:47:18 <hiptobecubic> nohonor, you can have a list of function pointers. Close enough.
03:47:29 <nand`> (doesn't stop me from having them all the time)
03:47:36 <nohonor> hiptobecubic, can you compose them?
03:48:17 <nohonor> can you map a list of integers to a list of io expressions and then combine them into one large expression?
03:48:22 <nand`> “X is in a category whose archetypal member gives us a certain emotional reaction.” <- the category of Kittens?
03:48:49 <shachaf> Yes, nohonor, you can do that.
03:48:56 <shachaf> But this channel isn't about C.
03:51:41 <nohonor> still, it would be a nice parallel
03:51:48 <nohonor> how would you implement mapM in C?
03:53:46 <hiptobecubic> nohonor, download ghc 6.x, use -fvia-c, and see for yourself.
03:54:39 <nohonor> hiptobecubic, it would be an unreadable mess though, wouldn't it :-)
03:55:22 <nand`> an excellent answer; I agree
03:55:29 <hiptobecubic> now you're just arguing about syntax and library functions. :)
03:55:34 <nand`> perhaps; but you could still read up on how Haskell is compiled to C in general
03:55:37 <nand`> then do that for mapM
03:57:28 <nohonor> hiptobecubic, i guess you could do fp in assembly, that doesn't make it functional
03:57:36 <hiptobecubic> what does?
03:57:50 <shachaf> I don't care about what's functional and neither should you.
03:58:04 <nand`> you should care about what's functioning
03:58:06 <nohonor> all i wanted to say is that even though you're manipulating imperative statements in IO, you're still doing it declaratively
03:58:27 <shachaf> I don't care.
03:58:33 <hiptobecubic> print 4, is declarative?
03:58:36 <shachaf> Did you see Conal's post on that?
03:59:10 <nand`> shachaf: who, me?
03:59:48 <nohonor> :t print 4
03:59:49 <lambdabot> IO ()
04:00:02 <nohonor> hiptobecubic, that's all i wanted to say
04:00:05 <nohonor> enough jibber-jabber
04:03:05 <bxc> heh googling for rose tree didn't give me quite what i expected
04:03:46 <shachaf> data Rose a = Rose a [Rose a]
04:03:57 <Jafet> "Don't google group action"
04:04:03 <bxc> heh
04:05:22 <nand`> “A Rose Tree, also called a Multi-way Tree, is a Tree data structure. [More at Wikipedia]” <- first result for ‘rose tree’ for me
04:05:38 <srhb> Ah, filter bubble..
04:05:59 <nand`> srhb: I'm using a service which allegedly doesn't bubble
04:06:17 <shachaf> Not to be confused with Rowe's Tree
04:06:18 <srhb> Oh. I forgot there were alternatives. Again.
04:07:08 <nand`> Oh hey, the same service picks up “Group action: In algebra and geometry, a group action is a description of symmetries of objects using groups.” as first result; and “Group Action -- from Wolfram MathWorld” as second
04:07:09 <nand`> excellent
04:07:38 <bxc> nand`: i get stuff about plants
04:07:51 <bxc> actually the first is: Rose Tree - Premium Bedding & Home Fashions
04:07:51 <bxc> www.rose-tree.com/
04:07:51 <bxc> Since 1979, Rose Tree has designed and produced only the best quality Fashion Bedding, Pillows, and Bed Accessories. Our High Quality Bed Sets and ...
04:08:18 <nand`> bxc: http://duckduckgo.com :)
04:08:28 <merijn> bxc: Time to switch to...awww, someone beat me to it...
04:09:30 <nand`> (an with an 11 second ping too, you should be ashamed)
04:09:33 <nand`> and*
04:09:36 <troydm> ddg.gg is cool
04:09:55 <shachaf> Let's have some Haskell in here!
04:09:57 <shachaf> > liftA2 (++) inits tails "abcde" -- this looks interesting until you realize it's really boring
04:09:58 <lambdabot>   ["","a","ab","abc","abcd","abcde","abcde","bcde","cde","de","e",""]
04:12:38 <nand`> oh; I thought that liftA2 was in the list monad at first glance and was really confused
04:13:10 <nand`> > liftA2 (++) (inits "abcde") (tails "abcde")
04:13:11 <lambdabot>   ["abcde","bcde","cde","de","e","","aabcde","abcde","acde","ade","ae","a","a...
04:14:26 <byorgey> nand`: you mean the list Applicative ;)
04:14:30 <shachaf> nand`: Exactly!
04:14:51 <shachaf> > liftA2 (liftA2 (++)) inits tails "abcde"
04:14:53 <lambdabot>   ["abcde","bcde","cde","de","e","","aabcde","abcde","acde","ade","ae","a","a...
04:14:56 <shachaf> > liftA2 (liftA2 (++)) inits tails "abc"
04:14:58 <lambdabot>   ["abc","bc","c","","aabc","abc","ac","a","ababc","abbc","abc","ab","abcabc"...
04:15:32 <nand`> byorgey: same thing :)
04:16:41 <ivanm> with criterion, is there any way of benchmarking IO-based functions that print stuff without having the output clogging the terminal? (i.e. print to /dev/null or something)
04:18:10 <shachaf> > getZipList $ liftA2 (liftA2 (++) `on` ZipList) tails inits "abcde"
04:18:11 <byorgey> ivanm: there's some package that gives you functions for wrapping IO actions and suppressing output
04:18:12 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd","abcde"]
04:18:17 <byorgey> but I forget what it's called
04:18:26 <ivanm> heh
04:18:49 <byorgey> ah
04:18:52 <byorgey> @package silently
04:18:52 <lambdabot> http://hackage.haskell.org/package/silently
04:18:56 <nand`> shachaf: now there's an interesting function
04:19:46 <shachaf> Of course, that's more simply written
04:19:55 <shachaf> > liftA2 (zipWith (++)) tails inits "abcde"
04:19:56 <lambdabot>   ["abcde","bcdea","cdeab","deabc","eabcd","abcde"]
04:20:38 <shachaf> (You get an extra copy of the original. :-( )
04:20:51 <nand`> byorgey: nice
04:21:02 <byorgey> nand`: ?
04:21:13 <byorgey> oh, you mean silently?
04:21:16 <nand`> the ‘silently’ package; it could come in handy
04:21:24 <byorgey> yeah, it looks like a nice package
04:21:32 <byorgey> I've never had occasion to use it myself
04:22:20 <nand`> (I haven't looked at the source, don't know how it's implemented but) I wonder if a similar approach could be used to redirect handles instead
04:22:30 <nand`> I guess that's what ‘capture’ does under the hood
04:22:48 <libro> hello..
04:23:21 <libro> data Frank a b = Frank {frankField :: b a} deriving Show
04:23:48 <libro> *Main> :k Frank
04:23:49 <libro> Frank :: * -> (* -> *) -> *
04:24:34 <libro> i think, a can be (* -> *) .
04:24:51 <nand`> only with PolyKinds
04:24:52 <libro> i don't understand this result.
04:25:04 <libro> PolyKinds?
04:25:49 <libro> i don't know about PolyKinds
04:26:07 <nand`> if it helps you understand; Frank has the kind * -> (* -> *) -> * the same way ‘frank a b = b a’ has the type :: a -> (a -> b) -> b
04:26:57 <ivanm> byorgey: huh, for some reason one copy of it running still gets printed out from criterion...
04:27:35 <ivanm> well, part of the output anyway
04:28:48 <shachaf> libro: If a :: (* -> *), then b :: ((* -> *) -> *)
04:29:01 <shachaf> But b can only have one kind.
04:29:23 <byorgey> nand`: not quite.  * is not really like a type variable.
04:29:42 <shachaf> libro: If you want, you can annotate it: data Frank (a :: * -> *) b = Frank (b a)
04:29:46 <libro> hmm..
04:30:08 <shachaf> Alternatively, you can use -XPolyKinds and then it'll have kind k -> (k -> *) -> *
04:30:09 <nand`> byorgey: I guess it would be more like () -> (() -> ()) -> ()
04:30:54 <libro> it is haskell-standard? or ghc specific?
04:31:05 <shachaf> libro: PolyKinds is GHC-specific.
04:31:13 <shachaf> I think the kind annotation I gave might be GHC-specific too...
04:31:34 <shachaf> nand`: frank a b = b a; frank :: * -> (* -> **) -> ** -- Miranda is the future!
04:33:28 <byorgey> nand`: yes
04:33:53 <byorgey> the kind annotation is GHC-specific but much more likely to be supported by lots of Haskell implementations.
04:33:55 <libro> you mean, standard haskell treat  "data Frank a b = Frank {frankField :: b a} deriving Show"  as "Frank :: * -> (* -> *) -> *" ?
04:34:05 <byorgey> whereas PolyKinds is quite GHC-specific.
04:34:09 <byorgey> libro: yes.
04:34:21 <byorgey> what else should it be treated as?
04:34:29 <nand`> libro: try
04:34:37 <Jafet> ** -> (** -> *) -> *!
04:34:37 <nand`> data Frank a b c = Frank { frankField :: b a c }
04:35:03 <nand`> oh, no
04:35:05 <nand`> that's something else
04:35:06 <byorgey> for a really good time, try   data Frank a b c = Frank (b a c) (a c)
04:36:27 <Jafet> Pimp my F system
04:39:30 <libro> hmm...
04:39:50 <libro> thanks a lot , byorgey, nand', shachaft, you helped me. thanks. i can understand it now.
04:40:28 <nand`> data Frob a x = Frob { unFrob :: a x }; data Frank a b = Frank { unFrank :: b (Frob a) }
04:40:34 <nand`> Frank :: (* -> *) -> ((* -> *) -> *) -> *
04:40:57 <nand`> haskell 98!
04:41:56 <hiptobecubic> I am trying to rewrite filterM using just filter, but failing :(
04:42:18 <nand`> :t filterM
04:42:19 <lambdabot> forall (m :: * -> *) a. Monad m => (a -> m Bool) -> [a] -> m [a]
04:42:50 <hiptobecubic> particularly, the magic example:
04:42:59 <hiptobecubic> > filterM (const [True, False]) [1,2,3]
04:42:59 <nand`> I don't see that happening with just filter
04:43:00 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
04:43:18 <hiptobecubic> nand`, no? Using some convoluted method with >>= and return everywhere?
04:43:54 <nand`> wait, let me try
04:48:24 <nand`> :t \f -> liftM (map snd . filter fst) . liftM (uncurry (zipWith (,))) . uncurry (liftM2 (,)) . (sequence *** return) . (map f &&& id)
04:48:25 <lambdabot> forall (m :: * -> *) b. Monad m => (b -> m Bool) -> [b] -> m [b]
04:48:47 <Eduard_Munteanu> @unpl \f -> liftM (map snd . filter fst) . liftM (uncurry (zipWith (,))) . uncurry (liftM2 (,)) . (sequence *** return) . (map f  &&& id)
04:48:47 <lambdabot> \ f j -> liftM (\ m -> map snd (filter fst m)) (liftM (uncurry (zipWith (,))) (uncurry (\ d e -> d >>= \ b -> e >>= \ a -> return ((,) b a)) ((sequence *** return) (((map f) &&& \ g -> g) j))))
04:49:42 <byorgey> well that helps.
04:49:47 <hiptobecubic> yes
04:50:04 <hiptobecubic> @pl \f -> liftM (map snd . filter fst) . liftM (uncurry (zipWith (,))) . uncurry (liftM2 (,)) . (sequence *** return) . (map f  &&& id)
04:50:04 <lambdabot> ((fmap (map snd . filter fst . uncurry zip) . uncurry (liftM2 (,)) . (sequence *** return)) .) . (&&& id) . map
04:51:18 <nand`> to break it down: 1. map the function over the list and sequence it to get a list of bools; 2. zip that with the original list (inside the monad); 3. use filter fst to filter out all of the ones tagged with True; 4. use map snd to drop the bools
04:51:27 <nand`> there's probably a shorter formulation now that I think about it
04:52:10 <hiptobecubic> :t (***)
04:52:11 <lambdabot> forall (a :: * -> * -> *) b c b' c'. Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
04:52:18 <hiptobecubic> ugh
04:52:28 <hiptobecubic> ah
04:52:29 <nand`> :t \f x -> liftM (map fst . filter snd . zipWith (,) x) $ mapM f x
04:52:30 <lambdabot> forall (m :: * -> *) a. Monad m => (a -> m Bool) -> [a] -> m [a]
04:52:51 <hiptobecubic> :t zipWith (,)
04:52:52 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
04:52:55 <hiptobecubic> :t zip
04:52:56 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
04:53:00 <nand`> oh..
04:53:02 <nand`> right
04:53:09 <srhb> I always forget that as well :P
04:53:22 * nand` just remembers the generalized stuff :P
04:54:02 <hiptobecubic> I learned zip from python, so i always think about zipWith as "zip with something other than tuple()"
04:54:17 <nand`> zipWith is zip with something other than (,)
04:54:23 <nand`> so that's not too far-fetched
04:54:50 <hiptobecubic> Sure, i'm just saying my frame of reference is opposite to yours
04:55:23 <hiptobecubic> i'd be more likely to write  map (uncurry f) . zip
04:55:34 <nand`> heh
04:56:03 <hiptobecubic> [f(*x) for x in zip(l1,2l]
04:56:12 <srhb> zip(*list) was cool, in an unimaginably ugly way.
04:56:13 <hiptobecubic> l2 i mean
04:56:39 <hiptobecubic> srhb, it's a nice idiom for transposing. I use it a lot
04:56:57 <hiptobecubic> especially with some retarded functions, like matplotlibs plot()
04:57:53 <srhb> I just think the recursive map head solutions are more transparent, but I guess that's because I always found argument unpacking ugly.
05:02:12 <simon> I'm doing 'foo a1 a2 = bar a1 == bar a2' and I wonder if this can be generalized. I searched Hoogle for Ord b => (a -> b) -> a -> a -> Bool, but I didn't find anything useful.
05:02:27 <ivanm> simon: (==) `on` bar
05:02:30 <ivanm> @type on
05:02:31 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
05:02:57 <simon> ivanm, ah, how silly. I was sitting with compare `on` bar and got Ordering out! =)
05:03:03 <simon> ivanm, thanks!
05:03:03 <ivanm> heh
05:03:14 * bxc really nees to use `on` more - i only discovred it the other day
05:03:30 <bxc> too much learning hsakell in isolation for me.
05:03:43 <ivanm> I quite often do something like: groupSortBy f = groupBy ((==) `on` f) . sortBy (compare `on` f)
05:04:41 <ramses_> @pl (\x y -> All (x == y))
05:04:42 <lambdabot> (All .) . (==)
05:05:39 <srhb> @hoogle on
05:05:40 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
05:05:40 <lambdabot> Control.Exception.Base onException :: IO a -> IO b -> IO a
05:05:40 <lambdabot> Control.Exception onException :: IO a -> IO b -> IO a
05:05:49 <ivanm> @src on
05:05:49 <lambdabot> (*) `on` f = \x y -> f x * f y
05:06:08 <srhb> I know the function, but why is it suddenly in Data.Function. Or was it always. :P
05:06:18 <hpc> always was
05:06:25 <fmap> :t comparing
05:06:26 <srhb> Huh.
05:06:27 <lambdabot> forall a b. Ord a => (b -> a) -> b -> b -> Ordering
05:06:44 <nand`> :t All .: (==)
05:06:45 <lambdabot> forall a. Eq a => a -> a -> All
05:06:48 * ivanm prefers (compare `on`) to comparing
05:06:57 * hackagebot crf-chain2-generic 0.1.0 - Second-order, generic, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-generic-0.1.0 (JakubWaszczuk)
05:07:05 <ivanm> @hoogle All
05:07:05 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
05:07:05 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
05:07:05 <lambdabot> Data.Monoid All :: Bool -> All
05:07:10 * nand` prefers comparing, because it reads better
05:07:11 <ivanm> ahhh, Monoid
05:07:12 <nand`> sortBy (comparing fst)
05:07:22 <nand`> “sort by comparing” <- hey, that's almost like english
05:07:39 <ivanm> nand`: yeah, but I typically use it with groupBy as well, so I need `on` anyway
05:07:46 <nand`> ‘sortBy (comparing length)’
05:08:02 <ivanm> compare `on` length is relatively English as well
05:08:27 <donri> "sort by the compare operation on the fst function" sortBy (compare `on` fst)
05:08:43 <shachaf> compare `on` length is sadly inefficient.
05:08:53 <shachaf> When infinite lists are involved, it's infinitely inefficient.
05:08:59 <ivanm> shachaf: well, yeah, I don't do that in real code
05:09:22 <shachaf> (compare `on` map (const ())) is a hacky version that'll compare more lazily. :-)
05:09:29 <ivanm> I tend to do fst . sortBy (compare `on` second) . ap (,) length
05:09:41 <shachaf> ivanm: That still computes the whole length!
05:09:44 <ivanm> shachaf: that'll do the mapping each time though!
05:09:53 <ivanm> OK, fine, use genericLength with lazy Naturals!
05:10:05 <shachaf> That's equivalent to map (const ())
05:10:10 <nand`> but cooler
05:10:16 <ivanm> but you only do the computation _once_
05:10:19 <shachaf> More like "less cool" :-(
05:10:25 <shachaf> ivanm: You can do the same thing here.
05:10:26 <ivanm> rather than the map (const ()) for every time you do a comparison
05:10:34 <ivanm> shachaf: sure, but you didn't use that code! ;)
05:10:56 <shachaf> I'm not sure that that is in fact more efficient here.
05:11:32 <nand`> does lambdabot have lazy nats somewhere?
05:12:07 <ivanm> > 2 :: Nat
05:12:08 <lambdabot>   Not in scope: type constructor or class `Nat'
05:12:11 <ivanm> > 2 :: Natural
05:12:12 <lambdabot>   Not in scope: type constructor or class `Natural'
05:12:12 <lambdabot>  Perhaps you meant `Natur...
05:12:28 <ivanm> used to; copumpkin used to show off with them all the time
05:13:39 <shachaf> [()] ~ Nat
05:15:21 <ski> @let equating :: Eq b => (a -> b) -> (a -> a -> Bool); equating = ((==) `on`)
05:15:24 <lambdabot>  Defined.
05:16:00 <ski> bxc : perhaps, or perhaps not, you'd like that
05:16:26 <ski> simon : hm, i suppose i ought to have directed that to you
05:17:33 <Eduard_Munteanu> Hrm, can you implement lazy nats efficiently?
05:17:46 <Eduard_Munteanu> (as efficient as normal stuff or close, I mean)
05:19:47 <ClaudiusMaximus> Eduard_Munteanu: something like data AlmostLazyNat = Succ AlmostLazyNat | Flattened !Integer
05:19:50 <ClaudiusMaximus> maybe
05:20:28 <simon> ski, thanks.
05:21:21 <KBme> hello
05:21:30 <KBme> has anyone worked with HDBC and dates?
05:21:37 <Erstarrung> stepcut: Is it possible for you to give me an example of how to load a .o library (compiled from C) with plugins ?
05:21:38 <Eduard_Munteanu> Hi.
05:22:06 <KBme> I'm using Data.Time.Calendar.Day in my datatype, and need to convert it to sql
05:22:26 <KBme> in my database the column is of date type (postgresql)
05:24:29 <srhb> KBme: Looks like you need a POSIXTime
05:24:42 <hpc> KBme: my code appears to be using UTCTime and a timestamp column
05:24:50 <hpc> but i only select from it, and all my inserts use NOW()
05:25:01 <KBme> yeah, I don't need time, though
05:29:39 <Clint> KBme: persistent-postgresql handles Day
05:47:08 <ocharles> hmm, does anyone know if there's a way to 'zip' 3 data structures together inside an applicative functor? I feel like what I'm trying to do is almost like a zipper, except I'm unzipping 3 structures, inspecting their elements pairwise and then 'zipping' back up to a final structure by combining all 3 elements
05:51:08 <shachaf> @ty liftA3 (,,) -- ocharles: ?
05:51:10 <lambdabot> forall (f :: * -> *) a b c. Applicative f => f a -> f b -> f c -> f (a, b, c)
05:51:18 <int-e> > getZipList $ (\x y z -> x + y*z) <$> ZipList [1,2,3] <*> ZipList [2,1,3] <*> ZipList [4,5,6]
05:51:19 <lambdabot>   [9,7,21]
05:51:37 <shachaf> Well, depending on what you mean by "zip".
05:51:37 <ocharles> right, but I want to do this with arbitrary nested things, like (a, b, c), for example
05:51:42 <ocharles> i mean zip as in zipper
05:52:04 <shachaf> What does it mean to zip data structures together?
05:52:09 <S11001001> ocharles: the applicative functor for that is state
05:52:19 <ocharles> ok, let me step back
05:52:33 <ocharles> I'm trying to model a 3 way merge. here's what I have so far (doesn't compile because I'm literally in the process of writing this :))
05:53:03 <ocharles> https://gist.github.com/2ddffe9d67f3f84b35b3
05:53:13 <ocharles> line 47-49 is the 'meat' of the problem that I'm trying to solve
05:53:24 <ocharles> I need a way to merge 3 artists into one, with the chance that the merge could fail as a conflict
05:53:49 <ocharles> what I have now I do like quite a lot, but I wondered if there was any other prior art I could steal
05:54:27 <ivanm> only real prior art I can think of is how darcs manages merges
05:54:37 <ocharles> yea, I don't want to go down into the theory of patches
05:55:07 <ivanm> nothing to do with theory of patches, just see if they have any code for three-way merges
05:55:24 <ivanm> or else see other VCS implementations (albeit not in Haskell)
05:55:48 <ivanm> or else diff3
05:56:12 <ocharles> well it's not the diff algorithm I'm struggling with, it's just how to thread it all together in a very haskelly way
05:56:53 * shachaf tries to figure out what's going on.
05:56:55 <KBme> Clint, yeah, i don't use persistent.
05:57:00 <Daroth> hi
05:57:02 <shachaf> Probably doesn't help that it's ~06:00.
05:57:04 <coldpizza72i> What does manyL mean here in function sxmlP http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework06/soln/SXMLReformat06.hs
05:57:12 <ocharles> shachaf: your health is more important than irc!
05:57:20 <shachaf> ocharles: I bet lens would make your code nicer.
05:57:25 <ocharles> shachaf: yea
05:57:29 <Daroth> I can't find out what "type Predicate =  FilePath -> Permissions -> Maybe Integer -> ClockTime -> Bool" means. Is this documented anywhere ?
05:57:30 <ocharles> i'll wait for the wizard to wake up ;)
05:57:48 <ivanm> shachaf: do you say that about all code samples? :p
05:57:51 <ocharles> shachaf: I tried looking in Control.Lens.Zipper to see if there was anything that looked good, but I couldn't find anything that I wanted
05:57:55 <ivanm> Daroth: what in particular?
05:58:18 <shachaf> ivanm: Well, this one in particular has some obvious lens-y bits.
05:58:18 <ivanm> Daroth: the Predicate type is an alias for a function that takes a FilePath, Permissions, Maybe Integer and ClockTime and returns a Bool
05:58:19 <Daroth> ivanm: i've never seen type with -> between values before
05:58:42 <ocharles> 'runMerge (ArtistType "A") (ArtistType "B") (ArtistType "A") mergeArtist == Just (ArtistType {artistTypeName = "B"})' so this stuff is definitely working
05:58:46 <Daroth> ivanm: oh well, it's just syntaxic sugar ?
05:58:50 <ivanm> yup
05:58:53 <Daroth> thx :)
05:58:54 <ocharles> where mergeArtist = ArtistType <$> rescope artistTypeName mergeEq
05:58:58 <ivanm> I can say "type IntFunc = Int -> Int -> Int", so (+) :: IntFunc, etc.
05:59:16 * shachaf tries to figure out what's going on.
05:59:25 <shachaf> Why is that using Compose? Just to derive Applicative?
05:59:32 <statusfailed> I feel this might be a dumb question for some reason, but is there a data structure library for something like this? data Tree k v = Node (Map k (Tree k v)) | Leaf v
05:59:32 <ocharles> yea, cause I'm lazy
05:59:48 <ocharles> lazy/like standing on other peoples work
05:59:54 <ivanm> ocharles: oh, with the email to -cafe you had on this though, I was thinking that it might be cleaner if you did the merging as a class, and then newtypes for different operations like == rather than creating new merging functions all the time
05:59:55 <merijn> statusfailed: That's just a trie, right?
06:00:07 <ocharles> ivanm: I will have a class ultimately
06:00:13 <ivanm> statusfailed: not sure what you're doing there
06:00:15 <ocharles> but you can't do mergeEq with a class due to overlapping instances
06:00:29 <ocharles> shachaf: it's an applicative functor that takes an environment (the 3 sides of the merge), and can fail
06:00:31 <statusfailed> ivanm: trying to mimic JSON object hierarchies
06:00:36 <ivanm> statusfailed: which Tree type is that? Data.Tree is kind * -> *
06:00:41 <shachaf> ocharles: Does your code as it is type-check?
06:00:44 <ivanm> * Data.Tree.Tree
06:00:48 <ocharles> shachaf: no, but I can give you some that does now
06:00:52 <ivanm> ocharles: newtype it!
06:00:58 <ivanm> (for mergeEq)
06:01:10 <ocharles> i don't see what newtyping gains me
06:01:13 <ocharles> (in that sense)
06:01:14 <statusfailed> merijn: i'm not sure, I guess so?
06:01:37 <shachaf> ocharles: OK?
06:01:38 <merijn> statusfailed: Ah, no not entirely
06:01:42 <shachaf> I have the feeling I'm missing something.
06:01:45 <ivanm> ocharles: to avoid OverlappingInstances
06:01:48 <shachaf> It might be because I'm tired.
06:01:48 <ocharles> shachaf: https://gist.github.com/02aaef0f40fae73c59d1
06:01:58 <statusfailed> You could do it as a trie, but you'd have lots of single-child nodes
06:02:11 <ocharles> ivanm: yes, but it's more hassle to lift things into the newtype than to just call mergeEq (:
06:02:15 <ivanm> statusfailed: which Tree type is that? Data.Tree.Tree is kind * -> *, not * -> * -> *
06:02:22 <merijn> ivanm: A fictional one
06:02:33 <ivanm> oh
06:02:37 <ocharles> ivanm: for types with a very specific merge strategy (like merging Sets or merging 'Artist's) then I will use a class
06:02:37 <merijn> ivanm: Hence why he asked "is there an existing tree like this"
06:02:54 <ivanm> merijn: gah, didn't see the recursion in the type definition :)
06:03:16 <statusfailed> I should've answered earlier, what they said though :)
06:03:44 <statusfailed> s/they/merijn/
06:06:39 <atriq> You know that code I mentioned the other day with crazy indentation?
06:06:56 <atriq> I've got it down to 25 (from 49)
06:07:10 <statusfailed> atriq: 25 tabs? :P
06:07:21 <atriq> 25 spaces
06:07:24 <statusfailed> wat
06:07:38 <atriq> On the most spacey  line
06:07:41 <statusfailed> is there a gist?! :D
06:07:55 <atriq> Afraid not
06:08:00 <statusfailed> awww :)
06:08:10 <atriq> It's a silly Hunt the Wumpus clone, not that interesting other than me complaining about indentation
06:08:50 <statusfailed> well if I had an internet connection that would let me view web pages then it might matter :p
06:09:08 <atriq> Where are you?
06:09:13 <Jafet> statusfailed wants you to DCC him your leet warez
06:09:14 <statusfailed> Bangkok
06:09:17 <atriq> By which I mean, why is your connection bad?
06:09:23 <statusfailed> shitty apartment wifi
06:09:25 <atriq> Aaah
06:09:50 <statusfailed> for some reason my ssh is still up, but everything else is dead
06:09:54 <statusfailed> even icmp doesn't seem to work
06:10:05 <atriq> Maybe it's a router problem?
06:10:27 <statusfailed> probably, everything is going through a squid proxy which routinely falls over
06:10:40 <statusfailed> but actually you're right- icmp would work then
06:11:33 <ClaudiusMaximus> bad dns?
06:11:53 <statusfailed> I can't ping 8.8.8.8, which I think is google's public DNS server
06:12:04 <ClaudiusMaximus> meanwhile, does darcs gtk2hs work with ghc-7.6?
06:14:20 <ramses_> @pl (\x y -> x == (reverse y))
06:14:21 <lambdabot> (. reverse) . (==)
06:14:44 * shachaf wonders what contravariant lenses would look like.
06:15:22 <shachaf> type Contralens s t a b = (b -> a) -> s -> t
06:15:34 <Jafet> They look at you!
06:15:42 <edwardk> put the f in there with the Contravariant constraint and knock yourself out
06:16:24 <edwardk> also note that every Getter can be made Contravariant as well
06:16:27 <Jafet> http://en.wikipedia.org/wiki/File:Save_the_Contras.jpg
06:16:28 <edwardk> so you can use them as getters
06:16:36 <edwardk> =)
06:16:53 <edwardk> or rather you can use getters as 'contravariant' lenses
06:16:59 <dcoutts> ClaudiusMaximus: apparently now
06:17:03 <dcoutts> erm, not
06:17:07 <coldpizza72i> What does manyL mean here in function sxmlP http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework06/soln/SXMLReformat06.hs
06:17:11 <edwardk> i don't think they make much sense, but i'm happy to be proven wrong
06:17:23 <atriq> I really need to write down all the mistakes I find in documentation for stuff
06:17:45 <atriq> edwardk, the documentation for Fold is weird
06:17:50 <edwardk> ?
06:17:57 <mauke> coldpizza72i: what does 'import Parser' mean?
06:18:09 <edwardk> i'm happy to take a patch
06:18:21 <typoclass> atriq: sure, do it! :-) thanks a lot. most people will be happy to take documentation patches
06:18:22 <atriq> At the top it says "type Fold a c = forall m. Monoid m => Getting m a a c c", but Fold is actually defined as "type Fold a c = forall f. (Gettable f, Applicative f) => (c -> f c) -> a -> f a", but then it uses the Monoid-y one all the time?
06:18:29 <Jafet> It means his instructor is from 2002
06:18:36 <atriq> it confuses me
06:18:56 <shachaf> atriq: It works out to pretty much the same thing.
06:19:07 <shachaf> Use whichever one is clearer to you. :-)
06:19:16 <shachaf> atriq: Also, there's new documentation with exciting new names!
06:19:22 <edwardk> actually the one mentioned in the docs is i think slighty wrong
06:20:06 <ClaudiusMaximus> dcoutts: i just noticed - trying with the patch bundle posted to the mailing list
06:20:52 <shachaf> edwardk: Which one is wrong?
06:21:13 <edwardk> the docs. since getting was monomorphically constrained to use Accessor
06:21:51 <shachaf> I thought it was just meant to be a restricted version so you don't have to think about the type class nonsense.
06:22:05 <shachaf> Since the documentation is full of that. :-)
06:22:44 <statusfailed> so does anyone know if this exists as a library somewhere? data Tree k v = Node (Map k (Tree k v)) | Leaf v
06:22:54 <shachaf> ocharles: rescope l (Merge m) = Merge (m . over traverseMergeScope l) -- Isn't that sort of nice?
06:23:10 <shachaf> statusfailed: Is that meant to be a prefix tree of some sort?
06:23:18 <statusfailed> ooh
06:23:30 <statusfailed> that depends on what a prefix tree is
06:23:38 <statusfailed> let me bust out elinks
06:24:57 <statusfailed> I guess so? With strings instead of chars
06:25:11 <KBme> is there a way to convert between Data.Time and posixtime?
06:25:14 <mauke> now you're thinking with directories
06:25:20 <statusfailed> ^
06:25:33 <shachaf> statusfailed: A sort of patricia tree?
06:25:41 <mauke> a directory tree
06:25:47 <KBme> it seems strange to me that people are expected to use Data.Time when many things still use POSIXtime
06:26:09 <statusfailed> woah, elinks knows about the mouse!
06:26:14 <KBme> is there no possible conversion?
06:26:36 <mauke> KBme: I don't even know what you're talking about
06:27:06 <KBme> well, old time is supposed to be deprecated, and people are supposed to start using Data.Time instead, is this true?
06:27:08 <typoclass> KBme: Data.Time.Clock.POSIX can get the current posix time. not sure how to convert some other Data.Time, i *think* you can use one of the general-purpose conversion functions (toInteger? realToFrac? don't remember)
06:27:27 <atriq> edwardk, also, the documentation for Data.Extend from semigroupoids is dodgy, but I've told you before and said I'd make a patch and never did
06:27:38 <edwardk> k, send patch. will accept ;)
06:27:39 <mauke> KBme: what is old time?
06:27:41 <edwardk> gotta run
06:28:29 <KBme> mauke, http://lmgtfy.com/?q=haskell%20old%20time
06:29:19 <mauke> KBme: too much effort
06:29:27 <mauke> I'm not the one with the problem
06:29:48 <KBme> then don't help, i didn't ask you to.
06:31:23 <mauke> well, you asked the channel. I'm in the channel
06:31:52 <KBme> all right, whatever, no hard feelings, i'm a bit irritated, sorry for lashing out.
06:33:13 <KBme> so HDBC still uses old time, but i'd like to use Data.Time in my package, so I was looking for some kind of conversion
06:33:33 <srhb> KBme: In reality the new time library is probably more out of date than the old one is, afaik.
06:33:52 <KBme> really?
06:33:57 <KBme> well that's confuzing
06:34:01 <srhb> Yes, it is.
06:35:05 <KBme> yep, that's true
06:35:18 <KBme> Data.time was last updated in 2011, old-time in 2012
06:35:20 <KBme> fun
06:35:25 <KBme> thanks a bunch srhb
06:35:30 <srhb> Well, that's not really an issue. Or shouldn't be, unless you're on 7.6
06:35:35 <statusfailed> mauke: I don't spose you know what data structure a directory tree would use do you? :)
06:35:42 <KBme> srhb, it is for compatibility
06:35:49 <srhb> KBme: Right.
06:35:58 <KBme> I want to use the most standard tools possible
06:36:01 <mauke> statusfailed: I'd define my own
06:36:17 <typoclass> KBme: i think that might have been just some tiny compatibility thing. in principle you're right, if possible use Data.Time instead of things from old-time
06:36:59 <statusfailed> mauke: alright then, i'm just gonna suck it up and write it :D
06:37:14 <statusfailed> any obvious flaws with that previous definition?
06:37:17 <KBme> typoclass, I think not. I think Data.Time probably failed along the way and everyone just uses System.Time
06:37:22 <typoclass> KBme: http://pleac.sourceforge.net/pleac_haskell/datesandtimes.html <- this page is practically essential if you do anything with dates. includes answers to your question
06:37:31 <KBme> ah thanks
06:38:01 <typoclass> KBme: not sure about that :-) i don't have an overview of Data.Time usage vs. System.Time
06:38:27 <KBme> seems like System.Time does a lot more than Data.Time, and is used much more commonly
06:38:37 <KBme> and there is no simple way to convert between them
06:39:28 <typoclass> KBme: no, you just use the function utcTimeToPOSIXSeconds, or posixSecondsToUTCTime for the reverse
06:40:08 <KBme> I use Data.Time.Calendar.Day, and it's not the same, I don't think that works.
06:40:29 <KBme> and I don't want epoch because my dates can be before 1970
06:40:36 <coldpizza72i> Can someone tell me if it looks like I'm off in the right direction with the assignment I'm working on http://ideone.com/emxkeN http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/Parser-kladoi/
06:40:39 <Jafet> data DirectoryTree = DirectoryTree (Map FilePath (Either5 Hardlink Symlink NormalFile AbnormalFile DirectoryTree))
06:41:12 <statusfailed> Jafet: it's not actually for directories, but JSON objects, but otherwise thanks :)
06:41:51 <typoclass> KBme: posixSecondsToUTCTime (-123) works for me, it gives a date in 1969
06:42:40 <KBme> oh interesting
06:43:07 <KBme> but then again, i don't want to store date as an integer in the database
06:43:18 <KBme> I want to use the database's date type
06:43:18 <mauke> statusfailed: oh, there are libraries for JSON
06:43:27 <KBme> and the database driver uses System.Time
06:43:37 <KBme> so I think i'm better off just using System.Time
06:44:00 <statusfailed> mauke: I know- it's supposed to mirror the struture of a JSON object but not actually be one
06:44:03 <statusfailed> heh
06:44:07 <fmap> what
06:44:35 <statusfailed> fmap: what what?
06:44:51 <typoclass> KBme: UTCTime consists of two fields, one of them is a Day. it should be easy to convert a Day into a UTCTime, which you can convert to posix
06:45:17 <fmap> statusfailed: if you want to mirror JSON why can't you use existing JSON parsing libraries?
06:45:21 <KBme> hmmm
06:45:38 <statusfailed> fmap: mirror as in the structure of the object (which is also like directory trees), but not actually represent JSON data
06:45:46 <typoclass> KBme: if you do a lot of this, try the package time-lens, it simplifies those conversions iirc. i _think_ ed has added stuff from time-lens to his lens package as well
06:46:02 <KBme> ok
06:46:24 <KBme> typoclass, also, I *don't* want time, I want *date*
06:47:01 <coldpizza72i> anyone...?
06:47:04 * hackagebot bitwise 0.1.0.1 - fast multi-dimensional unboxed bit packed Bool arrays  http://hackage.haskell.org/package/bitwise-0.1.0.1 (ClaudeHeilandAllen)
06:47:06 <ClaudiusMaximus> ^^ only change is ghc-7.6 compatibility (adding "Num b =>" to "Bits b =>" constraints)
06:48:23 <typoclass> KBme: yes, sure, time-lens includes both
06:48:38 * KBme looks at time-lens
06:48:39 <KBme> thanks
06:49:03 <KBme> what does the "-lens" packages mean?
06:49:10 <typoclass> kbme, you're welcome
06:49:15 <KBme> am I understanding correctly that these do conversions?
06:49:54 <typoclass> KBme: i guess in this case lens just means "these are getters that are simpler than the regular stuff"
06:50:07 <typoclass> (also setters, if that's relevant to you)
06:50:26 <KBme> ok
06:50:32 <atriq> KBme, it means it uses the Data.Lens module in the data-lens package
06:50:51 <ramses_> @pl (\x -> x == (reverse x))
06:50:52 <lambdabot> ap (==) reverse
06:51:09 <atriq> :t (==) <*> reverse -- possibly more readable
06:51:11 <lambdabot> forall a. Eq a => [a] -> Bool
06:52:39 <mauke> coldpizza72i: what is eoperator?
06:52:44 <shachaf> data-lens :-(
06:52:58 <coldpizza72i> typo
06:53:13 <mauke> coldpizza72i: what is operator?
06:53:43 <typoclass> shachaf: i told ed about time-lens some months ago, and he said he hadn't seen it, but he would adopt the parts that he liked
06:53:54 <coldpizza72i> A Parser String
06:54:07 <mauke> coldpizza72i: where is it defined?
06:54:33 <merijn> typoclass: *Composable* getters and setters
06:55:28 <shachaf> merijn: That's lens. data-lens is so old you might as well call it *compostable* getters and setters.
06:55:55 <atriq> shachaf, if I remember correctly, Data.Lens.Lens was an instance of Category
06:56:06 <atriq> So it's both composable and compostable
07:00:23 <coldpizza72i> mauke: http://ideone.com/N9wEIm
07:01:11 <mauke> coldpizza72i: ?
07:02:13 <typoclass> merijn: yes yes, but more importantly, it's an improvement over the regular stuff :-) "getL Day" is better than "(\(d, _, _) -> d) $ toGregorian $ utctDay" or some such
07:32:43 <Philonous> Heh, it turns out it's a good idea to quickcheck-test even trivial functions because more often than not there is some corner case one can forget about.
07:33:22 <typoclass> so true!
07:41:55 <otters> :t uncurry (fmap . (,))
07:41:57 <lambdabot> forall a (f :: * -> *) a1. Functor f => (a, f a1) -> f (a, a1)
07:46:52 <gredy77> http://posatori.com/freelongvideos/HOT-SPANISH-BABYSITTER-SEDUCTRESS
07:58:00 <t7> > const "PONG" "PING"
07:58:01 <lambdabot>   "PONG"
07:58:38 <t7> i would click that link if i wasnt at work
07:59:52 <mauke> I wouldn't. the page title is "SEX SEX SEX SEX SEX SEX SEX | SEX SEX SEX"
08:01:06 <merijn> mauke: Sounds good ;)
08:02:15 <Philonous> mauke:  How do you know?
08:02:52 <mauke> a link title displaying script
08:03:35 <Philonous> Fair enough
08:07:08 * hackagebot photoname 3.0.1 - Rename JPEG photo files based on shoot date  http://hackage.haskell.org/package/photoname-3.0.1 (DinoMorelli)
08:07:20 <otters> @pl \a -> return ((pid,h):a)
08:07:21 <lambdabot> return . ((pid, h) :)
08:20:11 <JordiGH> Reading LYAHFGG, is this actually a reasonable function or is it just whacky for pedagogical purposes?
08:20:13 <JordiGH> length' xs = sum [1 | _ <- xs]
08:21:13 <srhb> JordiGH: It is reasonableish.
08:21:25 <Jafet> It's almost reasonable
08:21:34 <Jafet> foldl' (+) 0 [1 | _ <- xs ]
08:21:41 <mauke> it's not reasonable
08:21:53 <osfameron> why not?
08:21:59 <srhb> Jafet: That's the same.
08:22:09 <Jafet> > sum [1..10^6]
08:22:11 <lambdabot>   *Exception: stack overflow
08:22:14 <goose6> Hi, does anyone know how to code C# databases?
08:22:22 <int-e> srhb: the ' makes the difference
08:22:30 <srhb> Huh, I was sure sum used a strict left fold.
08:22:31 <JordiGH> Huh, how can summing such a small list incur recursive calls?
08:22:53 <int-e> srhb: by a historic accident, it doesn't.
08:23:00 <srhb> Meh.
08:23:06 <srhb> If it did, it would be reasonable :P
08:23:11 <mauke> JordiGH: what
08:23:25 <mauke> goose6: how is that a Haskell question?
08:23:27 <JordiGH> mauke: How can Jafet have overflowed the stack?
08:23:36 <Jafet> Yeah, why doesn't it use a while loop or something!
08:23:38 <mauke> JordiGH: nested thunks
08:23:51 <mauke> JordiGH: but wha does that have to do with recursive calls?
08:23:55 <osfameron> isn't it trivial to replace sum with sum' that uses strict fold?
08:23:56 <int-e> JordiGH: it's building a large expression (...((((0 + 1) + 2) + 3) + ... + 10^6)
08:24:07 <osfameron> I mean, why is the historical accident retained?
08:24:08 <int-e> JordiGH: evaluating that expression causes the stack overflow
08:24:10 <Jafet> Yes, and it works in every case that people use sum
08:24:15 <mauke> osfameron: yes, and ghc -O2 tends to do that automatically
08:24:18 <Jafet> But it's more strict than sum
08:24:26 <Jafet> sum :: [Nat] -> Nat
08:24:28 <JordiGH> mauke: I imagine the actual implementation in C involves recursive calls.
08:24:35 <mauke> JordiGH: you're crazy
08:24:38 <Jafet> sum isn't implemented in C
08:24:52 <JordiGH> Does ghc self bootstrap?
08:25:08 <Jafet> ghc compiles itself
08:25:13 <mauke> not quite
08:25:16 <JordiGH> Whatever, the object code must have a recursive call, right?
08:25:21 <mauke> JordiGH: no
08:25:35 <osfameron> fold is implemented recursively, isn't it?
08:25:36 <hpaste> caasi pasted “switch-to-igd.conf” at http://hpaste.org/77118
08:25:37 <int-e> large parts of the ghc run-time system are written in C.
08:25:41 <mauke> osfameron: yes
08:26:07 <osfameron> so that explains the stack overflow, no?  am I missing something?
08:26:12 <mauke> no, it doesn't
08:26:30 <Jafet> I'm not actually sure how exactly ghc uses the stack
08:26:31 <mauke> you're assuming the stack overflow is related to recursive function calls
08:26:37 <int-e> > foldl (const id) 0 [1..10^6]
08:26:39 <lambdabot>   1000000
08:26:43 <Jafet> But it's used to evaluate thunks
08:26:52 <JordiGH> mauke: So you can overflow the stack without making function calls?
08:26:57 <JordiGH> It's not a function call stack?
08:27:06 <mauke> function calls don't use the stack
08:27:13 <Jafet> There is no function stack
08:27:19 <osfameron> eeeeek!
08:27:28 * osfameron 's brane asplodes
08:27:31 <JordiGH> So the object code doesn't contain CALL opcodes?
08:27:45 <Jafet> I don't think so, except when invoking things like libc.
08:27:47 <mauke> no idea, actually
08:27:52 <Jafet> But you can check yourself
08:28:01 <Jafet> and this is mostly irrelevant
08:28:09 <JordiGH> object code is irrelevant?
08:28:13 <mauke> yes
08:28:23 <JordiGH> But you need a machine to run your code in...
08:28:27 <mauke> no
08:28:28 <Jafet> It's irrelevant to relate it to C object code
08:28:36 <zebr> it's really quite amazing how different compiling functional languages is compared to imperative ones...
08:28:40 <JordiGH> Jafet: object code in general, not just Haskell..
08:28:40 <Jafet> GHC produces very different code
08:28:50 <JordiGH> Er, not just object code produced by C.
08:29:12 <JordiGH> Really, so ghc produces object code without CALL opcodes? That's quite crazy.
08:29:19 <Jafet> Sure, like every other language doesn't, or has not at some point, compiled to object code by targeting C
08:30:12 <int-e> JordiGH: as a rough idea, it uses the CPS transform so all would-be calls become tail calls and are translated to jumps.
08:30:50 <mauke> does it actually?
08:31:04 <JordiGH> int-e: I see...
08:31:11 <Jafet> You could just, you know, read this
08:31:14 <Jafet> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Rts/HaskellExecution
08:31:17 <Philippa> mauke: IIRC it uses explicit stacks, so close enough in practice
08:31:31 <Philippa> (you get one per thread, of course)
08:31:51 <Philippa> they're still not the /same/ stack, either
08:34:41 <JordiGH> Hm, at a glance, this suggest that call opcodes are used and must be used in some circumstances: http://hackage.haskell.org/trac/ghc/wiki/Commentary/PositionIndependentCode
08:35:44 <srhb> JordiGH: You can always ask in #GHC. :)
08:41:15 <JordiGH> Can you guys recommend a favourite nontrivial project in Haskell? I'd like to start to read actual source code as soon as possible instead of pedagogical examples.
08:42:19 <nand`> diagrams
08:42:39 <ski> @hackage diagrams
08:42:39 <lambdabot> http://hackage.haskell.org/package/diagrams
08:43:33 <int-e> JordiGH: Hmm, that page describes using call instructions for reading the instruction pointer. I think that doesn't count. It's also used for calling functions in the RTS, but that has been mentioned before.
08:43:34 <JordiGH> Haha, favoured by NixOS, figures.
08:46:59 <otters> I'm 'accept' ing connections to a 'Socket' in a loop
08:47:15 <otters> after the first connection is received, subsequent calls to accept return instantly
08:47:20 <otters> even if there's no client connected
08:47:24 <otters> what am I not understanding
08:47:32 <Lutin`> Is there anyone who could add something to the haskell wiki for me?
08:47:35 <Lutin`> I don't have an account
08:48:12 <mauke> otters: what do they return?
08:48:55 <otters> @hoogle accept
08:48:57 <lambdabot> Network.CGI data Accept a
08:48:57 <lambdabot> Network accept :: Socket -> IO (Handle, HostName, PortNumber)
08:48:57 <lambdabot> Network.Socket accept :: Socket -> IO (Socket, SockAddr)
08:49:10 <otters> but the Handle returned is at EOF
08:49:24 <otters> so if I try to read from it, I get an exception
08:49:29 <otters> and then accept doesn't work anymore
08:49:31 <otters> @_@
08:49:35 <mauke> dunno, try strace?
08:49:37 <otters> ok
08:49:54 <srhb> unsafeAccept is bad!
08:49:55 <srhb> :P
08:49:56 <Philippa> JordiGH: a lot will depends on what sort of thing you want to write in Haskell. I blog mostly toy/pedagogical typecheckers but using techniques that are somewhat less toylike, for example
08:50:12 <Lutin`> On http://www.haskell.org/haskellwiki/Keywords#- ((-) 1) should be on there for the section
08:51:24 <srhb> Lutin`: Huh why?
08:51:51 <Lutin`> Well they suggest subtract and (+(-1)) but not ((-) 1)
08:51:53 <otters> I wish I knew how to use strace
08:51:59 <Lutin`> Which makes the most sense to me
08:52:02 <Jafet> > subtract 1 1
08:52:09 <lambdabot>   mueval: ExitFailure 1
08:52:09 <lambdabot>  mueval: Prelude.undefined
08:52:16 <Jafet> > subtract 1 1
08:52:16 <srhb> lambdabot: Good morning!
08:52:22 <lambdabot>   mueval-core: Time limit exceeded
08:52:47 <Jafet> Daisy, daisy do
08:53:09 <srhb> Lutin`: Those two are emphatically not the same thing, I'm sure you're aware.
08:53:13 <Jafet> Lutin: (-) 1 is (1-)
08:53:22 <Lutin`> Oh yes
08:54:04 <Lutin`> nevermind I'm not awake
08:54:29 <Lutin`> I guess : subtract = flip (-)?
08:54:39 <srhb> @src subtract
08:54:40 <lambdabot> subtract x y = y - x
08:54:45 <srhb> Yes.
08:54:52 <Jafet> @@ @pl @src subtract
08:54:52 <lambdabot>  (line 1, column 1):
08:54:53 <lambdabot> unexpected end of input
08:54:53 <lambdabot> expecting white space, "()", natural, identifier, lambda abstraction or expression
08:55:10 <Jafet> lambdabot is having a bad day
08:55:10 <Lutin`> @pl \x y -> y - x
08:55:11 <lambdabot> subtract
08:55:14 <Lutin`> lol
08:55:16 <srhb> xD
08:55:29 <srhb> just needed a "-- so SOD off!"
08:55:56 <Lutin`> @pl flip (-)
08:55:58 <lambdabot> subtract
08:56:00 <Lutin`> yep
09:08:41 <beaky> hello
09:08:46 <srhb> beaky: Hello.
09:11:51 <Lutin`> @src dropWhile
09:11:51 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:12:22 <ski> @src takeWhile
09:12:22 <lambdabot> takeWhile _ []                 =  []
09:12:23 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
09:12:23 <lambdabot>                    | otherwise =  []
09:13:43 <Jafet> dropWhile = snd .: span
09:13:54 <Lutin`> Was just comapring the pattern between drop/takeWhile and until
09:13:57 <Lutin`> comparing
09:14:25 <hiptobecubic> :t (.:)
09:14:40 <lambdabot> thread killed
09:14:45 <hiptobecubic> uhh
09:14:58 <hiptobecubic> :t (.:) -- DO MY BIDDING!
09:15:01 <Lutin`> What is with you today, lambdabot
09:15:06 <lambdabot> forall (f :: * -> *) (g :: * -> *) a b. (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
09:15:24 <ski>   dropWhile _     [    ] = [             ]
09:15:29 <ski>   dropWhile p as0@(a:as)
09:15:34 <ski>     | p x                = dropWhile p as
09:15:36 <ski>     | otherwise          =             as0
09:15:41 <ski> Lutin` : e.g.
09:15:46 <Jafet> until p f = head . snd . break p . iterate f
09:15:50 <ski> s/p x/p a/
09:16:20 <Jafet>           = head . dropWhile (not.p) . iterate f
09:16:21 <hiptobecubic> :t fmap . fmap
09:16:35 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:16:45 <hiptobecubic> I'm getting better at this :D
09:16:49 <ion> :t fmap fmap fmap
09:16:54 <lambdabot> forall (f :: * -> *) (f1 :: * -> *) a b. (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:16:59 <S11001001> hiptobecubic: do it lots of times!
09:17:02 <ski> @type let (.) = (Prelude..); infixr 9 .:; (.:) = (.) . (.) in (.:)
09:17:03 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:17:07 <beaky> why is Haskell so concise compared to other programming languages?
09:17:07 <hiptobecubic> ion, yes but that's harder to conceptualize
09:17:08 <beaky> like C++
09:17:18 <hiptobecubic> beaky, higher order everything.
09:17:30 <hiptobecubic> except modules
09:17:43 <beaky> aww :(
09:17:45 <ion> C++ is a much lower-level language.
09:17:52 <S11001001> tuple slices
09:18:01 <beaky> what if Haskell had first-class modules? :D
09:18:06 <hiptobecubic> beaky, higher order stuff lets you abstract things to a higher level so you can get a lot of meaning out of short phrases
09:18:27 <hiptobecubic> beaky, it's the same reason C is so concise compared to brainfuck.
09:18:28 <nand`> It's a mixture of type inferencing, high power abstraction and minimalist syntax (white space sensitivity, etc.)
09:18:35 <ski> beaky : if it had higher-order modules, or even first-order ones (like SML and OCaml), it'd be even better
09:18:39 <beaky> pattern matching saves me from cascading if-else bloat :D
09:19:15 <hiptobecubic> pattern matching would be the thing i miss most when i'm in python or C, except the types aren't good enough for it to matter
09:19:18 <ski> pattern-matching is great ! :)
09:19:43 <Lutin`> I've been messing around in APL
09:20:13 <beaky> is the concise syntax and the higher-order functions the only thing that Haskell borrowed from APL?
09:20:25 <rwbarton> what strange questions
09:20:41 <ski> i don't think Haskell really borrowed it from APL
09:21:21 <beaky> ah
09:21:32 <elementz> hi all. i am having problems when trying to upgrade cabal install, please see the output of cabal --version, cabal install cabal-install, and ghc-pkg check in my paste: http://paste.ubuntu.com/1323990/
09:21:45 <Ferdirand> has apl a concise syntax ? or rather a concise lexicon ?
09:21:51 <Ferdirand> or whatever the name is in english
09:21:57 <beaky> APL seems very neat though; APL can do the game of life in one-line :D
09:21:59 <elementz> this proble arises on ubuntu
09:22:01 <Jafet> The syntax is mainly from ML and ISWIM.
09:22:11 <elementz> maybe somebody can help me to resolve this issue?
09:23:02 <Jafet> elementz: you're not supposed to upgrade cabal-install
09:23:03 <Lutin`> Ferdirand: http://www.tryapl.org/
09:23:06 <beaky> Haskell seems heavily inspired by Miranda (registered trademark of Research Software Inc.) as well :D
09:23:19 <mauke> Jafet: since when?
09:23:21 <luite> Jafet: why not?
09:23:32 <Jafet> Isn't it version locked to ghc?
09:23:51 <mauke> wat
09:23:55 <rwbarton> certainly not
09:24:01 <elementz> Jafet: hm. the problem is, i am unable to install pandoc via cabal, please see my question on askubuntu regarding this matter http://askubuntu.com/questions/204122/trying-to-install-pandoc-via-cabal-install-fails
09:24:14 <aleator> elementz: You haven't forcefully removed stuff from .cabal/ ?
09:24:30 <Philippa> beaky: Miranda's another ISWIM descendent, though
09:24:34 <elementz> aleator: actually it seems i did. :/
09:24:46 <Jafet> I thought it was version locked to cabal, which was version locked to ghc
09:25:10 <elementz> aleator: is there any way i can fix this?
09:25:27 <aleator> elementz: Welcome to whole new day of compiling everything again :) Ie. remove the .cabal entirely would be easiest option. (But wait for others)
09:25:30 <Ferdirand> Lutin`: so ? my point is, conciseness seems to come primarily from using one-character tokens
09:25:51 * aleator wants to give money for someone that makes cabal better.
09:25:53 <rwbarton> i think you really want to remove .ghc
09:26:06 <Jafet> elementz: if you remember what you removed from .cabal, you can ghc-pkg unregister them
09:26:11 <elementz> aleator: hm. i already did that; removed the whole .cabal folder earlier, and then tried to reinstall via apt-get purge cabal && apt-get install cabal
09:26:11 <rwbarton> presumably no cabal replacement would be immune to people randomly removing files
09:26:20 <rwbarton> remove .ghc, not .cabal (or both)
09:26:24 <beaky> so ISWIM began the whole attempt to break free of the ALGOL/imperative paradigm?
09:26:42 <nand`> cabal has been working fine for me
09:26:44 <aleator> rwbarton: Is that where the package list lives actually?
09:26:47 <rwbarton> yes
09:26:52 <elementz> Jafet: as i said, I deleted the whole .cabal directory at some point :/
09:26:56 <rwbarton> so you removed the packages themselves, but not the package list which points at them
09:27:05 <aleator> Well, that'd been useful to know yesterday
09:27:14 <Jafet> beaky: yes, it was a life-and-death struggle against the dutch hegemony
09:27:26 <rwbarton> in theory you can install packages to ghc without using cabal
09:27:57 <aleator> rwbarton: Of course. I just assumed that there was some indirection involved here..
09:28:20 <aleator> Usually pandoc compiles quite nicely on ubuntu.
09:28:52 <Jafet> cabal is a nice wrapper around ghc, ghc-pkg and other programs like haddock. Unless it breaks, then it's just a wrapper.
09:28:54 <Mortchek> How can I parse an Int from a String but return a value on error rather than bottom?
09:29:10 <Lutin`> Mortchek: Maybe or Either?
09:29:20 <Jafet> :t reads
09:29:36 <lambdabot> thread killed
09:29:38 <Jafet> reads :: Read a => String -> [(a, String)]
09:29:53 <Mortchek> Aha! Thanks
09:30:23 <nand`> readMaybe
09:30:32 <elementz> ok, i removed .ghc and .cabal, then did a cabal update and then tried cabal install pandoc with the following result Resolving dependencies...
09:30:35 <elementz> cabal: Couldn't read cabal file "pandoc/1.9.4.4/pandoc.cabal"
09:30:40 <elementz> what to do?
09:30:54 <nand`> readMaybe :: Read a => String -> Maybe a
09:31:22 <rwbarton> hm
09:31:28 <Mortchek> nand`, not in the standard library, is it?
09:31:33 <dcoutts> elementz: if you do cabal update now, it should be fixed.
09:31:46 <Lutin`> Mortchek: Text.Read
09:31:46 <rwbarton> that does seem like it should work yes...
09:31:53 <Lutin`> Which is in base
09:32:36 <beaky> Although I've installed cabal-install using my package manager (pacman), I've accidentaly used `cabal install cabal-install`. What should I do now?
09:32:36 <ClaudiusMaximus> i have things like   f, g, h :: forall x z . C x => x -> (forall y . C y => y -> z) -> z  to do things like  f x0 (\x1 -> g x1 (\x2 -> h x2 (\x3 -> show x3)))  but the syntax is awkward - any ideas?
09:32:46 <rwbarton> don't panic
09:32:56 <nand`> it's not imported by default (it's not in Prelude), but it's in the standard library ‘base’
09:33:14 <rwbarton> readMaybe is new in 7.6
09:33:33 <ski> Lutin` : "Can Programming Be Liberated from the von Neumann Style? A Functional Style and Its Algebra of Programs" (Turing award lecture) by John Backus in 1977 at <http://www.thocp.net/biographies/papers/backus_turingaward_lecture.pdf> (also see <http://www.cs.tufts.edu/~nr/backus-lecture.html>) might be interesting
09:33:39 <Lutin`> Mortchek: Also readEither
09:33:57 <Lutin`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/Text-Read.html#readEither
09:34:12 <rwbarton> also new in 7.6
09:34:25 <ski> beaky : also for you ^
09:34:27 <elementz> dcoutts: cabal install pandoc now results in some messed up dependencies... http://paste.ubuntu.com/1324018/
09:34:34 <beaky> ah
09:34:40 <beaky> :D
09:35:06 <Lutin`> hanks ski
09:35:10 <Lutin`> Thanks*
09:35:13 <dcoutts> elementz: see if you can see what that error is saying, it's not just gibberish.
09:35:26 <Jafet> ski: from the creator of FORTRAN
09:35:47 * ski nods solemnly
09:35:47 <Jafet> Sounds like one of those confessional type things
09:36:09 <dcoutts> elementz: it's saying that pandoc-1.9.4.5 requires old-time-1.1.x, but your system has and needs old-time-1.0.x
09:36:32 <dcoutts> elementz: the solution is probably to try installing an older pandoc, that will be compatible with the libs you already have.
09:36:40 <Clint> or to upgrade ghc
09:36:45 <elementz> dcoutts: hmm. thx
09:37:06 <dcoutts> elementz: note that if you install the latest cabal program, it has a cleverer solver and might be able to work this out itself, rather than you having to try each older version in turn
09:37:12 <Mortchek> Hmm, I don't have 7.6, I have 7.4
09:37:42 <nand`> then you'll need to make your own via reads
09:37:43 <elementz> dcoutts: ok, but how do i get the newest cabal version? it seems to not be in the ubuntu repositories
09:37:46 <dcoutts> elementz: the latest solver is much better for the case you're in, where you're having to use older versions of packages, because the latest versions need the latest ghc and other latest libs.
09:37:59 <nand`> (alternatively, upgrade to 7.6)
09:38:14 <dcoutts> elementz: cabal install cabal-install, and make sure $HOME/.cabal/bin is in your $PATH ahead of /usr/bin
09:38:19 <Mortchek> I have been advised against upgrading before
09:38:32 <elementz> dcoutts: ok. thx!
09:38:33 <Mortchek> Since I'm using my distro's version of the platform
09:38:51 <nand`> 7.6 isn't in the platform yet either way
09:38:51 <dcoutts> Mortchek: sticking to the released platform is usually the best plan.
09:38:52 <Clint> several things still don't work with 7.6
09:38:56 <nand`> so you'd have to uninstall the platform and install GHC itself
09:39:01 <nand`> Clint: notably Gtk2hs
09:39:12 <nand`> and lambdabot
09:39:25 <Mortchek> Guess I'm using reads then. Thanks.
09:39:33 <Clint> gwern fixed unlambda at least
09:40:06 <ski> ClaudiusMaximus : hm, reminds me of an idea i had where something like `<expr 0> \@ <expr-pat> -> <expr 1>' would be syntactic sugar for `<expr 0> <expr-pat> (\<expr-pat> -> <expr 1>)'
09:40:30 <paolino> what is the reason for the comonads to have a monad like name ?
09:40:47 <nand`> they're the dual of monads
09:40:54 <ski> ClaudiusMaximus : assuming one had that, one could write `f \@ x -> g \@ x -> h \@ x -> show x'
09:41:00 * paolino looks for dual
09:41:00 <nand`> the ‘co-’ prefix (in names) tends to mean that
09:41:11 <beaky> apart from Monads, what are some other useful abstractions/design patterns that you frequently see in Haskell?
09:41:12 <bxc> paolino: basically means they're related in a particular kind o fway
09:41:16 <rwbarton> a comonad on a category C is a monad on C^op
09:41:23 <nand`> beaky: too many to list
09:41:26 <nand`> speaking of which, lists
09:41:35 <bxc> nand`: typeclassopedia does a good job though...
09:41:45 <bxc> beaky: someone will make the URL for that appear here now
09:41:56 <nand`> Those are just a few type-classes, there are so many more abstractions in use
09:42:05 <beaky> Arrows, Monads, Functors, Categories...
09:42:12 <beaky> all design patterns?
09:42:14 <bxc> nand`: yeah but its a good summary of abstractions that have been captured enough...
09:42:14 <paolino> rwbarton, what is the ^op ?
09:42:15 <rwbarton> functions are pretty useful
09:42:19 <bxc> rwbarton: heh
09:42:25 <rwbarton> paolino: http://en.wikipedia.org/wiki/Opposite_category
09:42:30 <nand`> they're all abstractions, yes; I have no idea what a design pattern is
09:42:33 <beaky> ah yes functions are like bread n' butter :D
09:42:57 <nand`> bxc: they're an introduction to the most common abstractions drawn from category theory, imo
09:43:21 <bxc> nand`: the typeclassopedia?
09:43:33 <beaky> yeah type classes are used to implement lots of the really handy abstractions
09:43:48 <nand`> and data types are used for the rest
09:43:48 <beaky> I love type classes
09:43:51 <nand`> and functions for the others
09:43:57 <bxc> nand`: i'e never really done much with explicitly category theory apart from haskell
09:43:57 <nand`> there are so many ways you can build abstractions
09:44:11 <ski> @botsmack
09:44:14 <bxc> nand`: so I can't really agree or disgree with that...
09:44:39 <nand`> at the end of the day, typeclassopedia is really just an introduction to some of the commonly used more complicated type classes; like its name implies
09:44:43 <beaky> before I started learning Haskell I thought the ``class'' keyword was something like Smalltalk/Java's classes, but oh was I mistaken :D
09:44:45 <nand`> it's not a “list of abstractions” or anything
09:45:21 <beaky> imagine if Haskell had a ``Design Patterns'' textbook equivalent that OOP folks refer to for abstractions
09:45:43 <bxc> then something a bit like typeclassopedia would be part of it.
09:45:48 <beaky> ah
09:45:49 <bxc> (or material related to that)
09:45:57 <nand`> beaky: ironically, they're sort of like interfaces which are themselves just classes (in a model with multiple inheritance)
09:46:09 <beaky> right
09:46:20 <beaky> so typeclasses are a solution to the expression problem?
09:46:41 <nand`> what's the expression problem?
09:47:00 <paolino> smiles
09:47:06 <hughfdjackson> nand`: do you ask this in a leading way?
09:47:11 <nand`> typeclasses were basically introduced as a solution to ad-hoc overloading; “I want to use the same operator to add integers or doubles or whatever”
09:47:13 <hughfdjackson> or is that a genuine Q?
09:47:28 <beaky> It's when you face problems when you begin to extend your data types
09:47:30 <nand`> hughfdjackson: I've heard of it before but I have no idea what it is
09:47:45 <hughfdjackson> ooh, okay :D i think of typeclasses in terms of the expression problem too
09:47:47 <beaky> http://en.wikipedia.org/wiki/Expression_problem
09:47:54 <hughfdjackson> so i was wondering if you had a nugget of enlightenment for me ;)
09:47:56 <nand`> (of course, type classes these days have been used for much more powerful things than that)
09:49:06 <nand`> oh, I think I've heard of that before but the link between the problem and the name vanished in the meantime
09:49:32 <fruitFly> what are the major obstacles of putting web apps into production with haskell?
09:49:51 <nand`> finding people that will let you use Haskell for production web apps
09:50:02 <bxc> ha
09:50:19 <Eduard_Munteanu> nand`++
09:50:34 <hughfdjackson> web apps need (from their back-ends) things that haskell is more than capable of :3 i'm going with nand`'s explanation on this one
09:50:44 <paolino> beaky, typeclasses are a way to index functions
09:50:52 <hughfdjackson> nothing my company does with scala would have been harder in haskell, afaict
09:51:02 <nand`> type classes are a way to abstract over types
09:51:45 <t7> type classes are for teh generics
09:51:50 <beaky> ah
09:51:57 <bxc> type classes are all things to all people
09:52:00 <jfischoff> http://www.haskell.org/haskellwiki/Typeclassopedia
09:52:01 <beaky> and I heard that haskell has types of types i.e. kinds
09:52:12 <nand`> yeah
09:52:14 <beaky> typeception ^^
09:52:15 <clahey> :k Monad
09:52:16 <hughfdjackson> typeclasses are for generically treating types specifically :P
09:52:17 <ski> type classes should generally only be defined when you have at least two instances in mind
09:52:23 <nand`> and types of kinds :P
09:52:26 <nand`> but you don't see those a lot
09:52:28 <bxc> ski: well thats the case for any abstraction....
09:52:34 <nand`> beaky: if that's your thing, you might like Agda
09:52:40 <bxc> ski: more like 3 to make me happy
09:52:43 <ClaudiusMaximus> ski: interesting
09:52:53 <bxc> agda is trippy
09:52:59 <ski> bxc : yes, but you'd be surprised at how newbies here have tried to use them
09:53:02 <beaky> my mind is already busted by Haskell; Agda will make it implode XD
09:53:03 <t7> beaky: yeah thats when you have a type of a List. but a List is made out of things of some type. So 'List Int' or 'List String'. so list is like a function: * -> *
09:53:04 <clahey> :k Num
09:53:06 <nand`> it has types of types, and those types have types, and those types have types, ...
09:53:21 <bxc> ski: i've seen way too much abstractionitis in my life
09:53:26 <bxc> ski: now i deliberately avoid abstracting.
09:53:33 <t7> kinds have sorts, what do sorts have>
09:53:43 <clahey> Oh, LamdbaBot is gone.
09:53:46 <beaky> all problems in CS can be solved by applying an extra layer of abstraction :D
09:53:53 <bxc> or removing a layer
09:53:53 <beaky> :where lambdabot
09:53:56 <ski>   Num :: * -> Constraint
09:54:06 <Philippa> t7: each other, or nothing
09:54:13 <Philippa> that's the point of sorts
09:54:21 <Philippa> they're the 'uppermost' classifications of a pure type system
09:54:23 <bxc> has anyone written much about arbitrary Constraints? All i've seen so far is the ghc manual
09:54:38 <t7> i prefer set universes
09:54:41 <clahey> beaky: I would say that all problems in CS can be solved by either applying an extra layer of abstraction or removing a layer of abstraction.
09:54:46 <Philippa> effectively, "type" and "term" are sorts - or at least, "thing classifying term" and "thing classifying type"
09:54:52 <nand`> type classes are often used where first class functions would have been more appropriate
09:54:54 <Philippa> t7: that's just an infinite tower of sorts
09:55:18 <clahey> nand`: What's an example?
09:55:42 <beaky> what's the difference between first-class and higher-order functions?
09:55:48 <Jafet> clahey: Data.Map
09:56:23 <t7> higher order functions require first class functions, right... ?
09:56:49 <nand`> class Quacker a where quack :: a -> IO () -- vs  data Quacker a = Quack { getQuacker :: a, quack :: IO String }
09:56:49 <nand`> or something like that
09:56:50 <Lutin`> I've flip flopped between ADTs and type classes a few times in my projects
09:57:01 <nand`> actually, that example doesn't use first class functions at all
09:57:19 <Lutin`> nand`: Perhaps you mean GADT vs Typeclass?
09:57:24 <Philippa> t7: not if there are other things that can distinguish 'first-classness'
09:57:25 <fruitFly> hughfdjackson: so everything your scala environment does can be more easily implemented in haskell?
09:57:33 <Philippa> 'first-classness' is really a language-dependent thing
09:57:43 <t7> aah
09:57:48 <ski> beaky : to be able to define a higher-order function (with possibility of both taking a function as argument and returned as result), the simplest is if functions are first-class values
09:57:53 <nand`> class Shape a where area :: a -> Double; move :: a -> (Int, Int) -> a -- vs  data Shape = Shape { area :: Double, move :: (Int, Int) -> Shape } -- here's an example that does
09:57:56 <fruitFly> nand`: are you saying their is an industry bias why why haskell is not in production as frequently?
09:58:25 <ski> t7 : "higher order functions require first class functions" actually not -- but in most "normal cases" you can probably rely on that
09:58:29 <nand`> beaky: as far as I understand, first class functions and higher order functions are the same thing
09:58:35 <Jafet> Hey, PHP gets along just fine without first-class functions
09:58:35 <hughfdjackson> fruitFly: not necessarily *more* easily
09:58:46 <nand`> if you have first class functions you can implement higher order functions; and if you have higher order functions you automatically need first class functions
09:58:50 <Jafet> You just give it the name of the function that happens to be in the environment
09:58:50 <bxc> my experience with getting people to use haskell (or any other language) is they learned their one language they are comfortable with, and they dont' want to change
09:58:51 <hughfdjackson> I'm trying to say that there's not a massive difficulty mismatch
09:58:53 <hughfdjackson> in so far as i can tell
09:58:54 <Philippa> nand`: they're not. They happen to overlap in something like Haskell
09:59:00 <bxc> don't want to move from C -> C++, eg
09:59:23 <beaky> http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html
09:59:26 <Philippa> it's perfectly possible to picture a language where not being able to eg compare functions for equality leads to them not being first-class as such, even if they're a healthy second class
09:59:41 <nand`> Philippa: can you should me an example of a language where they're distinguishable, or is this just a theoretical thing?
09:59:45 <companion_cube> extensional equality ftw!
10:00:18 <companion_cube> (I don't think comparing pure functions is decidable, anyway)
10:00:26 <Jafet> I have used languages with extensional equality, and I can tell you they suck
10:00:27 <copumpkin> companion_cube: depends!
10:00:27 <ski> nand`,t7 : PreScheme has higher-order functions, but all calls to them must be unfoldable at compile-time
10:00:31 <Philippa> nand`: suppose that you've got a parallel language /and you're not allowed to send functions over the wire/, but you've got HOFs locally?
10:00:32 <nand`> fruitFly: yes; the industry certainly uses some languages like C++ or Java more commonly than others
10:00:34 <Jafet> (All total languages)
10:00:37 <tac> companion_cube: it isn't
10:00:40 <Philippa> would you happily call functions first-class in that language?
10:00:46 <copumpkin> Jafet: pfft, and most total languages out there don't have extensional equality
10:00:50 <nand`> so there is a sort of bias, in the sense that it's statistically harder to get a job writing Haskell than to get a job writing Java or C++
10:01:20 <nand`> Philippa: that makes sense; I wouldn't
10:01:31 <copumpkin> intensional equality sux lulz
10:01:45 <copumpkin> real programmers use homotopy type theory
10:02:06 <Jafet> Is that how they came up with the homotopy theory of homotopy theories
10:02:07 <nand`> ski: okay
10:02:08 <clahey> nand`: Why is the structure with pointers better than the type class?
10:02:10 <djahandarie> I got 99 problems but equality ain't one
10:02:13 <paolino> I'me unreal :-/
10:02:14 <clahey> The structure with functions*
10:02:15 * hackagebot tagset-positional 0.2.0 - Positional tags and tagsets  http://hackage.haskell.org/package/tagset-positional-0.2.0 (JakubWaszczuk)
10:02:20 <nand`> that makes sense as well
10:02:31 <tac> djahandarie: I got 99 equalities, but refl is just one of 'em.
10:02:39 <djahandarie> Haha
10:02:49 <Lutin`> clahey: Why is the structure of pointers different from the type class?
10:02:51 <nand`> clahey: try storing a list of shapes in each model
10:03:01 <ski> clahey : depends, but the record of functions is more flexible
10:03:20 <clahey> nand`: Right.
10:03:27 <Philippa> tac: reflmao?...
10:03:31 <clahey> nand`: I just understood the Shape thing.
10:03:37 <ski> (whether that is a good or a bad thing depends)
10:03:42 <nand`> I mean it's possible in the former, but you need existentials and things get hairy
10:03:45 <bxc> |cabal: dependencies conflict: base-3.0.3.2 requires syb ==0.1.0.2 however
10:03:56 <bxc> i thought i could install two versions of same package
10:04:10 <bxc> but it doesn't seem to let me also cabal install syb-0.3.7
10:04:26 <pordan30> @pl \f g k x y -> f (g x) (k y)
10:04:28 <Jafet> base requires syb?
10:04:34 <Lutin`> I would argue that a structure of pointers could very well be an implementation of a type class
10:04:36 <monochrom> you could but you need expert knowledge
10:04:40 <clahey> nand`: One advantage of the typeclasses is that you can define a hierarchy which might be helpful.
10:04:44 <Jafet> Most likely, syb-0.3 requires a different base.
10:04:47 <Lutin`> So I don't see how there is a distinction
10:05:06 <bxc> Jafet: yeah i guess so
10:05:14 <Philippa> another potential advantage of typeclasses is that you get a type -> instance mapping regardless of where you are, of course
10:05:18 <clahey> Lutin`: Well, they make a good point that the system does type checking for the typeclass case which can be good or bad.
10:05:28 <clahey> Philippa: Right.
10:05:28 <Jafet> Lutin: a series of opcodes could very well be an implementation of a type class
10:05:41 <Philippa> of course, sometimes that's a PITMFA instead
10:05:56 <Philippa> and sometimes, of course, you just plain don't want to have to write the evidence down at every call site
10:06:09 <Lutin`> clahey: So the real issue is with type checking
10:06:22 <Lutin`> Jafet: Yes it very well could
10:06:44 <Jafet> So the implementation is irrelevant
10:06:47 <clahey> Philippa: Well, you just always call the constructor function whenever you make an object of your type.
10:06:52 <nand`> clahey: you can do with values too; data Shape = ...; data ColoredShape = ColoredShape { color :: Color, shape :: Shape } -- Shape is like a superclass of ColoredShape; silly example mind
10:06:53 <monochrom> opcodes support first-class type classes :)
10:06:58 <Lutin`> Jafet: That's what I'm saying
10:07:03 <Lutin`> Jafet: precisely.
10:07:05 <clahey> nand`: Not a silly example.
10:07:07 * bxc successfully converts his cabal dependency problem into an apt-get dependency problem.
10:07:11 <Philippa> clahey: yeah, except sometimes they've got a lot of parms. If your constructor has 10 parms, you probably forgot one
10:07:19 <clahey> nand`: So, say you have ColoredPointedShape and want to get the shape.
10:07:22 <Jafet> Wait, who mentioned pointers.
10:07:40 <Jafet> bxc: now you know which rehab centre to visit
10:07:44 <Lutin`> Jafet: clahey?
10:07:50 <tac> Does Hackage keep haddocks for all the packages it hosts?
10:07:53 <monochrom> opcodes also support function pointer equality. there, I said "pointer" :)
10:07:53 <clahey> Jafet: I accidentally said pointer instead of function.
10:07:53 <Lutin`> idk
10:08:02 <Philippa> nand`: encoding subtyping is often a PITA again, though - tolerable if there's only a layer or two, less so if there're more
10:08:03 <clahey> Jafet: Cause I come from Cland.
10:08:11 <nand`> clahey: I think it's silly here because ‘ColoredShape’ doesn't need to know anything about ‘Shape’; a simple improvement would be data Colored a = Colored { color :: Color, it :: a }
10:08:18 <nand`> then you'd have a Colored Shape; a Colored (Pointed Shape), whatever
10:08:21 <Jafet> tac: it builds haddocks whenever it manages to build a library
10:08:26 <bxc> Jafet: well 50 minutes 'till pub
10:08:29 <nand`> Philippa: I agree
10:08:38 <bxc> Jafet: what bette rway to spend it than os upgrades..
10:08:45 <nand`> Philippa: edwardk's makeClassy is actually interesting for that
10:09:00 <clahey> nand`: But you have to decide whether you have a Colored Shape or a Shaped ColoredThing
10:09:04 <Jafet> Heh, Pointed Shape.
10:09:18 <clahey> Jafet: You know, like a square instead of a circle.  :)
10:09:30 <Lutin`> Why not use type classes as adjectives
10:09:37 <Lutin`> And ADTs as nouns
10:09:53 <bxc> still only ghc6 in debian testing?
10:09:58 <clahey> nand`: Ah, so the point is that as we get more complicated like this, typeclasses start to become more relevant, but for simple examples, you should stick with simple things.
10:10:04 <nand`> debian stale
10:10:06 <Clint> bxc: it's had 7.4 for quite some time now
10:10:07 <Philippa> nand`: FWIW, I'm in the "typeclasses are the closest thing we have to tactics and I /will/ use them to save me writing shit down" camp, but I'm an especially lazy coder
10:10:21 <clahey> tactics?
10:10:25 <nand`> clahey: for simple examples, you should definitely stick with simple things; that's a general rule and unrelated to this
10:10:27 <bxc> maybe its just the library filename libghc6...
10:10:37 <Clint> those are transitional dummy packages
10:10:40 <Philippa> clahey: as found in proof assistants. "Try doing this to fill in the blanks"
10:10:47 <Jafet> I use the oldest debian repo, and it has ghc 7.4!
10:10:48 <bxc> yeah i see it getting 7.4.1 now
10:11:00 <lispy> ivanm: cheers!
10:11:00 <bxc> Jafet: whatever i was just using was on 6.12 or something
10:11:04 <bxc> Jafet: squeeze maybe
10:11:07 <tac> Jafet: thanks. I think I found what I was looking for.
10:11:11 <clahey> nand`: I find typeclasses simpler than structures with functions, but that may be because I live in C++ world at work.
10:11:13 <Clint> Jafet: no you don't
10:11:21 <nand`> clahey: imop type classes can be leveraged to abstract out some common patterns, but they're not a catch-all solution to all abstraction problems
10:11:22 <lispy> ivanm: I just read your message about only being a factor of 8x different but doing a full traversal
10:11:22 <nand`> imo*
10:11:22 <nand`> and even with type classes, you have many different approaches
10:11:26 <Jafet> I use sid
10:11:28 <rwbarton> pretty sure debian stable has only ghc 6.12
10:11:29 <nand`> for example, the one used by diagrams works out fairly well in its context
10:11:34 <bxc> rwbarton: yeah i think so
10:11:40 <nand`> which has classes like ‘HasColor’, ‘PathLike’
10:11:42 <bxc> rwbarton: because i think thats what this VM was until just a few minutes ago.
10:12:03 <Philippa> nand`: by definition there is no solution to all abstraction problems. The closest thing is typeless lambda, and we've all seen how that works out, right?
10:12:14 <lispy> Cale: Oy. We really need to disable split-objs in the compiler. Sorry.
10:12:16 * hackagebot crf-chain2-generic 0.1.1 - Second-order, generic, constrained, linear conditional random fields  http://hackage.haskell.org/package/crf-chain2-generic-0.1.1 (JakubWaszczuk)
10:12:16 <bxc> now lets see whats broken
10:12:18 * hackagebot concraft 0.2.0 - Morphosyntactic tagging tool based on constrained CRFs  http://hackage.haskell.org/package/concraft-0.2.0 (JakubWaszczuk)
10:12:35 <Jafet> Heh.
10:12:40 <Jafet> lispy: are you using gold?
10:12:53 <lispy> ?tell Cale I'm getting horrible link times due to split objs. I have it disabled in my ~/.cabal/config and the last time this happened I had to build ghc from sources to fix it :(
10:13:04 <nand`> clahey: part of it depends on how you want to extend; the ‘data Shape’ example lets you add new shapes as you please, but restricts you to a certain number of operations you can do on them (ie. the ones in the record; in my example, ‘area’ and ‘move’); but using a type-class allows you to keep types separate and add more operations for different kinds of shapes
10:13:17 <nand`> there are a lot of trade-offs involved imo
10:13:17 <lispy> Jafet: no, does it handle the split-objs problem in a more reasonable way?
10:13:44 <Jafet> nand: some pointy-haired people call that the expression problem
10:13:48 <nand`> Philippa: yeah; there's another trade-off that's constantly present: power vs safety
10:13:54 <Jafet> lispy: it may or may not
10:13:55 <ski> lispy : lambdabot is sleeping, you could try `/msg MemoServ send Cale ...', i suppose
10:13:59 <lispy> I see that lambdabot is missing too...
10:14:04 <nand`> typeless lambda = lots of power, can abstract a ton of things that a type system could prevent; but basically no safety
10:14:19 * lispy grumbles
10:17:12 <Philippa> nand`: I'm increasingly wondering WTF it isn't easier to do editing with holes that interact neatly with whatever toolchain is relevant
10:17:17 <beaky> what are some sources for Haskell documentation
10:17:26 <Philippa> like, why that's not something any emacs-class editor already has fill-in-the-blanks support for
10:17:37 <Philippa> complete with ability to handle metainfo on chunks of document etc etc
10:17:43 <Philippa> IOW: why IDEs are still a PITA to build
10:18:13 <Cale> beaky: I mostly use the Haddocks which are linked from hackage.
10:18:25 <beaky> ah
10:18:28 <lispy> Cale: hi. Did you read the messages I tried to send you :)
10:18:28 <Cale> beaky: There is also http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
10:18:31 <hiptobecubic> is there anything else really?
10:18:36 <lispy> Cale: looks like I need to rebuild ghc from sources
10:18:42 <Cale> lispy: Yeah, I see
10:18:49 <Cale> The linker is ridiculously slow
10:18:51 <beaky> wish I can type something like `man Data.List` and read all about Haskell lists :D
10:19:06 <nand`> Philippa: what about those newfangled semantics editors that promise us lots of things?
10:19:13 <nand`> semantic editors*
10:19:14 <Cale> beaky: Well, if you go to the link I just gave you
10:19:26 <Philippa> nand`: *shrug* - let me know when they're easy to configure for new langs
10:19:52 <Cale> beaky: and then look for Data.List (say, using in-page search) and then click on it, you get http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/Data-List.html
10:19:56 <Philippa> (what I want is effectively a non-obsessive semantic editor that doesn't mind me spewing crap mid-document, sure)
10:19:57 <lispy> Cale: this is why split-objs sucks
10:20:00 <nand`> that seems to be the problem with semantic editors (and IDEs) in general
10:20:20 <Philippa> some handle it worse than others, but yeah
10:20:37 <clahey> beaky: google Data.List?
10:20:40 <Philippa> one of the reasons I have the interest in syntactic tech that I do: having a known class of grammars that actually behaves sensibly for those purposes would help
10:20:59 <nand`> Philippa: I feel restricted by the semantic editors I've tried; they want to keep everything neat and well-formed and semantically correct; but often times I want the freedom to refactor my function in plaintext
10:21:00 <Jafet> Why is mueval slow, though? Is it also because of split-objs?
10:21:11 <Jafet> I thought those were a .a thing.
10:21:19 <beaky> I want to try out hoogle, but I keep having trouble installing it on my machine :(
10:21:21 <nand`> like, “copy this piece of string, paste it over here, add some wrappers”, etc.
10:21:35 <Cale> beaky: Are you aware that there is a hoogle website?
10:21:40 <clahey> You can install hoogle on your machine?
10:21:43 <nand`> not “copy this semantic block and attempt to paste it into a context in which it's entirely invalid”
10:21:45 <Cale> http://www.haskell.org/hoogle/
10:21:47 <beaky> ah right
10:21:57 <Jafet> That only indexes base, though.
10:22:01 <Jafet> And some other things
10:22:13 <ski> Philippa : considering <http://www.ymeme.com/zmacs-vs-emacs-manual.html> ..
10:22:15 <Philippa> nand`: yeah, I feel similarly
10:22:41 <nand`> Philippa: what I've often thought about is an editor that would let me edit functions in plaintext; but once I've ‘comitted’ it would type-check and load those into its semantic representation again
10:22:50 <Cale> http://holumbus.fh-wedel.de/hayoo/hayoo.html
10:22:51 <nand`> and provide stuff like hlint hints at that point
10:22:53 <nand`> or type annotations
10:22:55 <Cale> will search more
10:23:01 <Philippa> ski: "what if emacs were the entire OS?" :p
10:23:42 <ski> Philippa : still better support for cross-indexing, &c. would be nice
10:24:02 <Philippa> nand`: I'm happy for it to attempt to figure it out as I go so long as it does so incrementally and tries not to bork its existing parses until forced to. Preferably, smart enough to work out that sometimes it's better to backtrack parses for the rest of the text despite having eg accidentally temporarily balanced brackets while editing
10:25:14 <Jafet> If Turbo Pascal was a structured editor, perhaps we wouldn't be complaining that structured editors are restrictive.
10:25:34 <ski> nand` : Alfa sortof can do that (edit functions in plaintext, then commit and type-check)
10:25:40 <nand`> Philippa: my philosophy is that editor feedback should be entirely non-invasive; what I like: type annotations shown somewhere that I can look at for reference; or function documentation that's automatically pulled up; what I don't like: editors that grab my cursor or move my code around for me
10:25:47 <Philippa> Jafet: nah, we've all fucked about on paper with /something/
10:25:51 <nand`> like, I have the freedom to type what I want
10:26:00 <Jafet> What is paper
10:26:02 <Philippa> nand`: yeah, do /not/ fuck with my in-progress activity
10:26:16 <Philippa> Jafet: what we used before ipads :p
10:26:25 <Philippa> (seriously, I still find it useful sometimes)
10:26:57 <Jafet> Wacoms just need to get cheaper.
10:28:25 <Philippa> well, I'm hoping the replacement for this laptop'll have a good touchscreen, but that's a bit dependent on when it dies and what money I have left
10:28:25 <nand`> ski: got a link for Alfa?
10:28:37 <ski> it's the old structural editor for Agda1
10:28:40 <ski> @where Alfa
10:28:40 * lispy starts the build
10:28:43 <nand`> ah
10:28:46 <ski> .. oops
10:28:54 <nand`> (can I use it for Haskell?)
10:29:37 <nand`> my main problem with paper is that I go through it too fast due to my huge handwriting and gratuitous use of space for diagrams and stuff
10:29:50 <nand`> bring on the e-paper
10:30:39 <Philippa> nand`: there're sketchpad apps for ipad and android, dunno if that helps?
10:31:07 <nand`> it would probably help if I had an ipad or android
10:31:24 <Philippa> true
10:31:29 <Cale> nand`: With respect to editors moving code around, there is one thing which I would really like to have, and that's that any edit which moves the first non-whitespace character after a layout keyword ought to cause the rest of the corresponding layout block to move accordingly
10:31:29 * lispy wonders if this build will be possible or if he needs to use the older ghc
10:31:32 <Philippa> getting cheaper these days, but
10:31:35 <ski> Proof editor, using Agda1 proof engine/checker, at <http://www.cse.chalmers.se/~hallgren/Alfa/>,(broken) <http://www.cs.chalmers.se/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested>,<http://ogi.altocumulus.org/~hallgren/untested/for_Linux/alfa-041029-bin-i386-Linux-RedHat9.tar.gz>,<http://ogi.altocumulus.org/~hallgren/untested/Source_code/alfa-050126.src.tar.gz>. Also see `Agda',`Fudgets',`GF'
10:31:41 <ski> nand` ^
10:31:54 <nand`> Cale: you've mentioned that before; and I do think it would be useful
10:31:56 <Philippa> (I'm seriously considering the possibility my next main machine'll be dual-booting android and eg ubuntu though)
10:32:07 * nand` wastes too much time manually aligning things
10:32:10 <Cale> yeah
10:32:11 <nand`> I have a script for it, technically, but I like to do things by hand just to get them the way I want
10:32:26 <Cale> But mostly I agree
10:32:45 <nand`> Cale: but I like to align things like ‘=’ signs in definition blocks, which your idea wouldn't help with
10:33:06 <Cale> I see these editors which try to keep everything syntactically valid all the time, and they always look somewhat awkward to use.
10:33:46 <yitz> Cale: in emacs that kinda works sometimes, if it isn't too complex
10:34:28 <yitz> nand`: emacs does that too. kinda.
10:34:30 <Cale> Chris Done has a bunch of videos on his YouTube channel for the editor that he's working on
10:34:44 <Cale> (well, structural editing mode in emacs)
10:34:47 <ski> nand` : <http://i.imgur.com/Fn6Gr.png> is a screenshot
10:35:09 <ocharles> Hi, I have a heterogenous list, data Edit = Edit [Change], where data Change = forall a. Editable a => Change a. This works fine, but at some point I need to construct [Change] from a database query like 'SELECT type, id FROM blah' -- ideally I don't want a big map of String -> Change and would like to dispatch on 'type' a bit more dynamically
10:35:11 <ocharles> any ideas?
10:36:15 <nand`> ski: funky
10:36:31 <nand`> (..but does it run in a terminal? :P)
10:36:31 <ocharles> I thought about adding a method to the Editable class and then going through all instances with Alternative, but I don't know quite how to get the 'all instances' bit...
10:36:47 <ski> nand` : nope, it doesn't :)
10:37:13 <nand`> how useless :(  what if I need to edit some proofs over ssh?
10:37:27 <ski> there is X forwarding
10:37:34 <nand`> (have the X client connect to a local server via ssh?)
10:37:36 <pmade> I'm working my way through the typeclassopedia exercises and I'm seeing * -> * for the firs time.  Does that mean a function that takes anything and returns anything much like (a -> b)?
10:37:36 <nand`> yeah
10:38:17 <nand`> though I'd need an X server running on windows; there *is* actually a program for that - XMing
10:38:22 <rwbarton> pmade: * -> * is a kind
10:38:33 <ski> pmade : a type having kind `* -> *' means that it is an *incomplete* type
10:38:39 <rwbarton> kinds classify types in the same way that types classify values
10:38:57 <rwbarton> * is the kind of a type with values (like Int)
10:39:02 <pmade> Ah.  Guess I need to go read up on kinds.  Any recommendations?
10:39:06 <ski> pmade : e.g. `Maybe :: * -> *', and therefore `x :: Maybe' is nonsense, you have to say something like `x :: Maybe Int'
10:39:16 <nand`> Values can only have a type with kind *; in the same way types can only have a kind with sort BOX?
10:39:23 <kylcarte> pmade: Lists are a good example
10:39:28 <Philippa> nand`: bingo
10:39:40 <kylcarte> pmade: so, a list by itself isn't a well formed type
10:39:43 <S11001001> looking forward to sorts in ghc
10:39:49 <Philippa> t7 just wants an infinite tower of BOXes :p
10:40:01 <kylcarte> but a list of Ints is
10:40:17 <nand`> S11001001: they're there in 7.6 actually
10:40:26 <S11001001> nand`: hum.
10:40:28 <ski> pmade : note that the type `[Int]' is syntactic sugar for `[] Int' -- here `[] :: * -> *', and `[]' can be pronounced as "list of" -- so similarly, you can't say `x :: []' (`x' is a list of *what* ?), you have to say something like `x :: [] Int'
10:40:28 <rpglover64> S11001001: see http://cis.upenn.edu/~justhsu/docs/nokinds.pdf
10:40:33 <pmade> ski: kylcarte: I'm sort of getting it.
10:40:56 <nand`> S11001001: actually, they probably aren't
10:41:01 <nand`> I just read that in the GHC manual somewhere
10:41:05 <pmade> Is there a way to ask ghci about kinds?
10:41:13 <ski> pmade : a type with kind `* -> *' is a *parameterized* type, a type which takes another type as an *argument*
10:41:16 <nand`> yes, :kind or :k
10:41:18 <kylcarte> pmade: :k
10:41:29 <nand`> :k Maybe
10:41:30 <pmade> nand`: kylcarte: thank you.
10:41:34 <ski> * -> *
10:41:48 <nand`> oh, right, lambdabot
10:42:17 <kylcarte> it's analogous to the term level, like this: you have a function, f :: a -> b, and a value, v :: a
10:42:21 <kylcarte> f v :: b
10:43:00 <kylcarte> on the type level, you have a type constructor, [] :: * -> *, and a type, Int :: *
10:43:01 <pmade> So, `[] :: * -> *' but `[] Int :: *`.  Does that mean the latter is more concrete or something?
10:43:38 <kylcarte> pmade: yes, it is a concrete type, meaning you can have terms of that type
10:43:41 <pmade> Ah, that makes more sense to me, since a type constructor is also a function, right?
10:43:59 <kylcarte> there are no terms of type [], because it isn't concrete
10:44:14 <pmade> So `* -> *' can represent a type constructor that takes one concrete type and returns another.
10:44:24 <kylcarte> precisely
10:44:46 <pmade> In kinds are there other symbols besides `*'?
10:44:54 <rwbarton> there's ->
10:44:55 <rwbarton> :)
10:45:06 <pmade> Ah, of course ;)
10:45:11 <kylcarte> rwbarton, yes, but there are more
10:45:14 <rwbarton> depending
10:45:15 <kylcarte> let me grab a link
10:45:23 <jfischoff> Is there any way to do type level comparison of the characters of the Symbol kind?
10:45:24 <pmade> kylcarte: thanks.
10:45:30 <rwbarton> ghc has # for instance
10:45:32 <jfischoff> I can't see how...
10:45:47 <kylcarte> pmade, rwbarton: http://research.microsoft.com/en-us/people/dimitris/fc-kind-poly.pdf
10:45:58 <rpglover64> Anyone know if there's a preference between using edwardk's keys package or the edwardk's indexed lens?
10:46:20 <pmade> Thanks again everyone.
10:46:24 <kylcarte> it's a relatively new feature that takes steps toward supporting dependent types in haskell
10:46:39 <nand`> a type constructor isn't a ‘function’, but it's sort of like one
10:46:40 <nand`> a type function, so to say
10:46:42 <nand`> but type constructors are a bit more special than just type functions
10:46:45 <nand`> jfischoff: neither can I, same for Nat
10:46:51 <nand`> jfischoff: I think they're just for annotations, GADT-style
10:46:58 <rwbarton> even more like a data constructor
10:47:35 <pmade> nand`: Sure, I can understand that, because you can use the type constructor to also deconstruct a type.
10:47:52 <nand`> pmade: I'm not sure what you mean
10:48:05 <kylcarte> nand`: pattern matching
10:48:21 <pmade> nand`: Right, I don't know the correct phrase, but when pattern matching.
10:48:31 <nand`> (basically, it's because type constructors are always injective: you can't write a type constructor T such that T Int = Char; it would always be ‘T Int’ and distinct from any other types)
10:48:57 <nand`> pmade: oh, you mean like ‘Just’? That's not a type constructor (at least not in this context)
10:49:09 <pmade> Oh wait, that's a value constructor right?
10:49:11 <nand`> yeah
10:49:11 <jfischoff> nand`: I'm finding them unsatisfactory. I think I can achieve something very close using the character based approach in the singletons library with a type quasiquoter.
10:49:46 <nand`> (though I should mention that a newer extension to GHC Haskell, type families, allow more generalized type functions that could let you have T Int = Char)
10:50:28 <beaky> is it good practice to annotate the types of functions in where clauses?
10:50:35 <Lutin`> I know exactly what we need to make Haskell the king of languages
10:50:37 <jfischoff> has anyone thought of a way to make to convert between the GHC Nat and the singletons library Nat?
10:50:44 <nand`> jfischoff: I haven't found much of a use for them either; but I think more work is planned on this in the future or something
10:51:05 <Lutin`> Make it so you can make bacon spinach cheese omelettes with GHCi
10:51:25 <nand`> beaky: I usually don't
10:51:36 <nand`> beaky: but if it helps with clarity, it could be a good idea
10:51:38 <johnw> Lutin`: we're only missing the bacon part in 7.6, right?
10:51:39 <nand`> it's just sometimes impossible
10:51:46 <Lutin`> johnw: I believe so
10:51:53 <nand`> eg. when you'd need -XScopedTypeVariables
10:52:06 <nand`> I heard GHC has bacon in the HEAD
10:52:12 <Lutin`> johnw: We've need to get the common man interested in haskell
10:52:14 <jfischoff> nand`: I have a compelling use case, but they are just not fleshed out enough. The singletons library on the other hand is, but I don't get pretty syntax.
10:52:15 * ski still misses `PatternSignatures' :(
10:52:18 <Lutin`> We need bacon.
10:52:27 <johnw> Lutin`: that has certain trade-offs...
10:52:36 <Lutin`> Well yes...
10:52:40 <nand`> what, bacon?
10:52:42 <Lutin`> We'd have to give up carbs
10:52:45 <nand`> or getting people interested in Haskell?
10:52:52 <Lutin`> Like cabal
10:53:08 <Lutin`> WHich are sweet at first
10:53:16 <Lutin`> But then little cavities start popping up
10:53:41 <Lutin`> whatamisaying idonteven
10:54:41 <johnw> nand`: likely the best answer is "both"
10:54:48 <nand`> jfischoff: I haven't had a look at singletons
10:55:02 <johnw> nand`: make sure you only look at the one
10:55:04 <nand`> johnw: all I can say is “avoid success at all costs”
10:56:28 <Lutin`> I love bacon
10:56:32 <Lutin`> That's all I can say
10:56:40 <johnw> yeah, bacon is kind of the most awesome thing my tongue has ever known
10:57:08 <johnw> thanks, pigs
11:02:04 <byorgey> ivanm: http://byorgey.wordpress.com/2012/11/01/using-multiple-versions-of-ghc-in-parallel-with-gnu-stow/
11:02:33 <johnw> byorgey: i do almost the same thing with homebrew
11:03:15 <byorgey> johnw: cool
11:03:30 <johnw> i just have to also manage ~/.cabal and ~/.ghc
11:03:34 <johnw> so that they never step on each other
11:03:43 <rwbarton> don't those manage themselves?
11:04:16 <rwbarton> for varying ghc versions I mean
11:04:19 <johnw> yes
11:04:25 <johnw> but the documentation can get messed up, can't it?
11:04:39 <johnw> because of needing multiple versions installed, one set for ghc 7.6, one for ghc 7.4.2?
11:04:40 <rwbarton> i suppose so
11:05:07 <johnw> also, when the day comes that I abandon ghc 7.4.2 forever, i want to just drop it in one go
11:05:17 <rwbarton> that seems like sort of a bug
11:05:32 <johnw> at the moment what I do is I use an OS X virtual machine which has GHC 7.4.2 installed instead of 7.6.1, and I use cabal-dev to build stuff there and then rsync it back
11:05:49 <dcoutts> sounds awfully heavyweight
11:05:57 <johnw> that way I get to use threadscope even though I have no 7.4.2 build products otherwise on my machine
11:06:02 <johnw> yeah, it's heavish
11:06:07 <johnw> but I rarely actually need 7.4.2
11:06:10 <dcoutts> I've got 8 versions of ghc installed side by side just fine
11:06:17 <dcoutts> using the normal layout
11:06:18 <johnw> dcoutts: how do you manage them?
11:06:32 <dcoutts> there's nothing to manage, the normal layout means it just works
11:06:41 <johnw> hmm
11:06:41 <dcoutts> ghc installed in /usr/local
11:06:52 <dcoutts> so I have 'ghc' on my path, that's my default version
11:06:54 <Lutin`> Same for me on archlinux
11:06:56 <rwbarton> presumably cabal install --with-compiler=FOO etc.
11:06:58 <dcoutts> and ghc-x.y for the specific version
11:07:05 <Cale> Doesn't all the documentation go into ~/.cabal/share/doc regardless of GHC version?
11:07:10 <dcoutts> rwbarton: righ cabal install -w ghc-7.0.4
11:07:12 <rwbarton> yes
11:07:34 <dcoutts> Cale: by default yes, you can adjust your ~/.cabal/config to make it per-compiler if you care
11:07:43 <rwbarton> though realistically if you install the same version of a package under ghc 7.4 vs. ghc 7.6 is it likely to have different documentation output?
11:07:59 <rwbarton> could happen I suppose
11:08:16 <Cale> rwbarton: Well, no, however, you might have different sets of things installed, so at least the top-level index should look different...
11:08:36 <dcoutts> Cale: documentation is for wusses!
11:08:37 <Cale> (Well, it could happen, but it is unlikely, for the same package)
11:08:40 <dcoutts> Cale: no you're right of course
11:09:13 <rwbarton> I tend to use docs on hackage 99% of the time anyways
11:09:21 <dcoutts> I tend to do development with my default ghc, and just use the others for compat testing
11:09:22 <Cale> dcoutts: Yeah, documentation and profiling, who ever needs that stuff? :)
11:09:27 <johnw> i lack access to hackage too often
11:09:28 <Lutin`> Why not .cabal/share/doc-x.y
11:09:32 <johnw> i use a local hoogle too
11:10:10 <rwbarton> now that sounds pretty useful
11:10:19 <dmwit> As long as we're proposing versioning in .cabal, can I ask for arch versioning?
11:10:20 <Cale> (I also really think that profiling in addition to documentation should default to being generated, and people who think they don't need it can turn it off)
11:10:21 <rwbarton> however i think i'd rather have it index all packages i've ever installed? not sure
11:10:26 <dmwit> .cabal/x86_64, .cabal/i386
11:10:28 <johnw> rwbarton: http://newartisans.com/2012/09/running-a-fully-local-hoogle/
11:10:39 <dcoutts> dmwit: luckily you can do that already
11:10:45 <johnw> Cale: I agree
11:10:46 <dmwit> dcoutts: Wow! How?
11:11:01 <dcoutts> dmarker: $arch is one of the vars you can use
11:11:07 <dcoutts> oops dmwit ^^
11:11:07 <dmwit> dcoutts: Right now I'm just running a script that makes appropriate symlinks in .cabal to my arch-specific stuff.
11:11:19 <dmwit> dcoutts: I see!
11:11:36 * dcoutts notes that this is documented in cabal install --help
11:11:53 <dmwit> I'll update the StackOverflow question related to this to point this out, thanks for the tip!
11:12:05 <lispy> When I work with C++ I kind of feel like: If your problem isn't hard enough to solve on its own, let's throw in a ton of distractions!
11:12:28 <monochrom> wait, "$arch" is documented in cabal install --help ?
11:12:50 * lispy says this C++ apropo of nothing, just debugging some C++
11:12:59 <dmwit> monochrom: sort of =P
11:13:03 <dcoutts> monochrom: I just checked, I was misremembering, it's documented in the context of another flag.
11:13:32 * dcoutts disappears
11:13:42 <dmwit> dcoutts++ yet again
11:15:53 <hiptobecubic> lispy, how so?
11:17:24 <lispy> hiptobecubic: The amount of boilerplate/scaffolding you need in C++ to express the problem is very high. At least in this codebase. Take for example, vectors and the associated traits/allocators
11:17:42 <lispy> hiptobecubic: In a language like Haskell you can focus more on the structure of the problem itself
11:17:44 <hiptobecubic> ah ok sure
11:22:11 <yitz> Cale: why double every complile time just to build an extra set of object files that i never use?
11:23:14 <Cale> yitz: You never profile your programs?
11:23:42 <Cale> yitz: Then you can turn that feature off.
11:23:42 <yitz> Cale: in theory i might, but in practice it's hard for me to remember last time i did it
11:24:37 <Cale> I think it's better to provide profiling support by default, rather than make users go and recompile everything when they suddenly want it.
11:24:41 <nand`> I used to have profiling disabled globally; then I profiled once, and now I have it enabled globally
11:24:51 <yitz> Cale: HP ships on the Mac with profiling enabled by default. rather than trying to figure out how to turn that off, instead i use other computers whenever possible
11:25:35 <yitz> Cale: part of the issue is that i always use only cabal-dev
11:25:47 <Cale> Oh, I haven't even tried cabal-dev
11:26:41 <yitz> Cale: so on the one hand my compiles are already relatively long, and on the other hand the cost of recompiling just one more time if i need profiling isn't very high
11:27:35 <mcstar> i wish i could write so good code that it didnt need profiling
11:28:12 <byorgey> it's usually the best code that DOES need profiling.
11:28:12 <yitz> nand`: i'm not programming in a domain where finely tuned performance is important. my haskell programs are already far more than fast enough.
11:28:31 <lispy> Cale: cabal-dev is quite nice. Sandboxing plus there is a ghci command where it loads the stuff in your .cabal file into ghci
11:28:32 <byorgey> after you profile and make things faster the code gets terrible.
11:28:42 <nand`> yitz: same
11:29:03 <yitz> nand`: and when there's some kind of a bug - strictness leaks or whatever - i never find that it's very hard to find it within a few minutes, with a little practice
11:29:31 <yitz> nand`: tried profiling a few times long ago. just didn't see that messing with that is worth it.
11:30:27 <ClaudiusMaximus> unboxed doubles made some of my code 3x faster, but ## is noisy and (...) everywhere is a pain (as +## *## etc have no fixity declarations)
11:30:27 <johnw> byorgey: although *sometimes*, the simpler code is faster
11:30:37 <johnw> byorgey: it's not a truism that optimal code must be complex
11:30:37 <byorgey> johnw: sometimes, yes
11:30:38 <rwbarton> i guess ideal would be if cabal installed the regular version of the package right away, and then built the profiling version in the background (or deferred to a nightly build or something)
11:31:03 <yitz> rwbarton: yeah something like that would be cool
11:32:16 <lispy> ClaudiusMaximus: sometimes you can get the compiler to do the unboxing for you. That's usually the only time I will resort to it.
11:32:35 <lispy> ClaudiusMaximus: SPECIALIZE and REWRITE are your friend. ghc-core can help you see if it's working.
11:32:44 <lispy> ClaudiusMaximus: maybe you already know all of that
11:36:28 <hpaste> lispy pasted “gdb/python runtime type error -- or why types matter” at http://hpaste.org/77127
11:36:59 <johnw> it's #python who should see that :)
11:37:16 <johnw> i really don't understand the hype about dynamic types anymore
11:37:19 <johnw> and I once thought I did
11:37:21 * hackagebot splot 0.3.6 - A tool for visualizing the lifecycle of many concurrent multi-staged processes.  http://hackage.haskell.org/package/splot-0.3.6 (EugeneKirpichov)
11:37:29 <johnw> i know, let's fool myself into thinking my code works!
11:37:59 <lispy> johnw: oh good point about #python
11:38:15 <lispy> It's annoying me because it means I can't print out my data structures doing my debugging session
11:39:48 <nand`> mcstar: I wish GHC would be so good at optimizing my code that I could write beautiful code without every needing to profile
11:40:39 <mcstar> i dont think it is fair to complain, ghc's profiling tools are good imho
11:41:12 <yitz> johnw: not sure if #python would be worth the bother. if you want to experience rainy weather, try posting something about haskell on the python reddit (even if positive about python)
11:41:37 <johnw> yitz: i more meant that he's preaching to the choir here
11:41:52 <yitz> true
11:42:41 <mcstar> nand`: also, ghc is pretty advanced, and still advancing, doesnt it? it can get closer to what you want
11:43:24 <nand`> mcstar: of course
11:43:46 <nand`> mcstar: I did mention never having needed to profile my code before, didn't I?
11:44:36 <mcstar> then why would you wish for not having to do something, that you actually never had to do?
11:47:08 <nand`> I'm relying on the possibility of having to profile in the future, eg. in case I ever write a performance-critical algorithm
11:47:16 <alpounet> byorgey, well, the best thing is to have optimized code being called by a nicely designed high-level layer (and where most of the high-level layer actually gets inlined, so you get great performances)
11:47:53 <nand`> I've always said it, the best thing is to have others optimize so you don't have to
11:49:06 <johnw> you have optimization slaves?
11:49:33 <mcstar> he means Phd students
11:49:41 <johnw> oh, there's a difference?
11:49:52 <mcstar> well, slave is pejorative
11:50:41 <lpsmith> out of curiousity,  is there any particularly good reason why we need resource management inside conduits/frames?   Why not just use pipes with something like ResourceT?
11:51:05 <johnw> lpsmith: i think you've just described two equivalent things
11:51:18 <johnw> conduit now has a Pipe type, in fact
11:51:44 <lpsmith> johnw, different issue
11:51:51 <johnw> k
11:53:13 <lpsmith> I mean, the resource handling features has been asserted to be necessary in some of snoyberg's blog entries,  but has there actually been anything more than an assertion?
11:54:25 <johnw> that's a good question
11:55:36 <lpsmith> johnw, the issue is how these abstractions handle resource management,  such as closing handles.   Pipes don't do that at all,  but making resource guarantees was one of the original justifications for iteratees.
11:56:02 <johnw> yes, I'm reading about ResourceT in the conduit docs now
11:56:46 <johnw> from http://www.yesodweb.com/blog/2012/03/pipes-like-conduit:
11:56:53 <johnw> "Resource handling. There's a claim that resource management is completely orthogonal to pipes, and can be achieved by using ResourceT. I disagree: while this may ensure that resources are eventually released, there's no guarantee that resources will be freed as early as possible."
11:57:23 <lpsmith> right,  I think that's what I read before
11:58:38 <lpsmith> which,  why isn't resourceT deterministic?
11:58:57 <johnw> i think it's a question of when, not whether, right?
11:59:09 <johnw> you can have high latency yet deterministic resource cleanup
11:59:23 <lpsmith> well, deterministic in terms of time as well
12:03:40 * edwardk waves hello.
12:03:58 <lpsmith> hi edwardk
12:06:14 <mrsolo> is iteratee i/o replacing lazy i/o as default?
12:06:15 * typoclass meows and looks at edwardk skeptically from his place on the window sill
12:06:36 <ousado> other than in extremely restricted environments, why would freeing resources "as early as possible" be a goal?
12:07:06 <lpsmith> ousado, "restricted" environments is relative to what you are trying to do, too
12:07:09 <edwardk> file handles are still a finite resource into this day and age
12:07:10 <klugez> Why would holding onto unnecessary resources be a goal?
12:07:13 <ousado> as opposed to, say "as efficiently as possible"
12:07:25 <Cale> mrsolo: no
12:08:02 <alpounet> meh, lambdabot's gone
12:08:08 <ousado> klugez: it's not, but there might easily be higher priorities
12:08:13 <carter__> anyone else take a gander at the pipes 2.5.0 ?
12:08:46 <lpsmith> carter__, I was just looking at them.  What about?
12:09:00 <klugez> ousado: Sure.
12:09:31 <carter__> lpsmith looks like it retains a lot of the same nicety, but a simpler internal rep + competitive performance
12:09:39 <carter__> i need to do some benchmarks at some point though
12:09:40 <lpsmith> ousado, when dealing with resources,  the two statements are approximately the same thing.
12:09:53 <ousado> lpsmith: no
12:10:02 <lpsmith> Freeing up resources eariler means you use less in total at any given point in time.
12:10:31 <lpsmith> ousado, how do they differ?
12:10:44 <ousado> lpsmith: it might also mean to interrupt things you expect to finish in some certain amount of time without need
12:11:33 <lpsmith> ousado, but that's the point of resource handing,  you don't interrupt anything,  you just get rid of what you don't need anymore (and arrange for that to happen at a relatively deterministic point in time)
12:11:36 <Cale> mrsolo: I still find all the iteratee libraries too awkward to become the default anything. This might be just because they do things at the type level which are still quite unnatural to do in Haskell, and it might also partly be that people just haven't figured out how to nicely abstract these interfaces yet.
12:12:50 <Cale> mrsolo: But it seems that every iteratee library inevitably falls into a pit of type constructors with complicated meanings and which have ridiculous numbers of type parameters.
12:13:36 <Cale> Even pipes, which is probably the nicest one so far
12:14:14 <lpsmith> heh, I don't particularly see how to reduce the number of type parameters, sadly.
12:14:15 <nand`> Cale: I noticed that as well
12:14:28 <mrsolo> hmm
12:14:40 <mrsolo> so something will replace it, most likely?
12:14:51 <nand`> I'll just wait until edwardk writes an iteratees library to rule them all or something
12:14:52 <Cale> (/</) :: (Interact p, Monad m) => (c' -> p b' b x' x m c) -> (b' -> p a' a x' x m b) -> c' -> p a' a x' x m c
12:14:56 <mrsolo> because it's end behavior is extremely desirable
12:15:04 <Cale> ^^ this kind of thing is unacceptable.
12:15:20 <edwardk> @hackage machines
12:15:21 <lambdabot> http://hackage.haskell.org/package/machines
12:15:25 <edwardk> nand`: there you go
12:15:27 <nand`> Cale: heh, yeah
12:15:32 <alpounet> Cale, i like the name of the type parameters
12:15:39 <alpounet> makes what the operator does so obvious
12:15:46 <nand`> edwardk: I forgot to say “and a blog post explaining how it actually works”
12:16:52 <mrsolo> Cale, geez...
12:16:58 <nand`> alpounet: it clearly pa'ax'xmc’s a c'pb'bx'xmc
12:17:23 * hackagebot hashable-generics 1.1.5 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.5 (ClarkGaebel)
12:17:28 <Cale> nand`: Is that Lojban?
12:17:40 <nand`> Cale: probably not
12:17:41 <typoclass> cale: klingon
12:17:41 <Cale> lol
12:17:52 <ousado> lpsmith: well, there are most certainly tradeoffs between freeing resources one by one vs in a bunch
12:18:07 <nand`> next idiom: variable name lojban metaprogramming
12:18:24 <lpsmith> ousado, point take
12:18:27 <lpsmith> taken
12:18:36 <alpounet> Cale, this typesig is from pipes?
12:18:41 <Cale> alpounet: yes
12:19:46 <lpsmith> though OS descriptors don't really have a mechanism to free en masse,  unless you get rid of the whole process at once
12:19:53 <lpsmith> (AFAIK)
12:20:54 <lpsmith> But yeah,  you are right.  Still,  in terms of resource usage arranging for things to be freed en masse does tend to drive resource usage up a bit.
12:21:22 <lpsmith> even though it might save elsewhere
12:21:36 <ousado> is there something like linear/unique types in some haskell-extension?
12:22:29 <typoclass> i think iteratees are an idea worth exploring, and that's what people have been doing so far. things that haven't arrived yet are a consensus which of the implementations is most useful, and in which situations it should replace lazy i/o
12:23:23 <lpsmith> unfortunately I still find myself avoiding lazy IO and hand-writing loops more than I'd like,  when it really matters
12:23:29 <Eduard_Munteanu> ousado: not AFAIK, but mind uniqueness types are a bit of a PITA if you're considering implementing IO in terms of them.
12:24:04 <alpounet> Cale, so pipes still has a long way to go before it becomes some kind of reference
12:24:06 <Mortchek> How can I make runSessionIO prettier? https://github.com/Mortchek/wayfarer/blob/master/Session.hs#L21
12:24:10 <Eduard_Munteanu> You have to pass that World parameter around, might as well use monads.
12:24:16 <Mortchek> Specifically, I think I can eliminate the cases.
12:24:19 <Cale> alpounet: It might have some of the right ideas in it.
12:24:20 <Mortchek> But I'm not sure how.
12:24:53 <alpounet> Cale, yes, but what's been keeping me from using all these libraries is precisely the fact that a lot of stuffs seem overly complicated.
12:25:42 <lpsmith> alpounet, I've been playing with iteratees and related concepts off and on for years and still most of the libraries give me headaches when I actually try to use them.
12:27:04 <alpounet> yeah, same here
12:29:13 <Cale> I can put up with fairly complicated types too, so it's not just that which I think is the problem. I think it's that somehow the type-level things aren't being organised well enough.
12:30:06 <Cale> Maybe as we get all these various fancy type-level data structures, someone will figure out how to bundle all the type parameters into meaningful structures.
12:30:43 <cartertest> Cale you mean extensible records?
12:31:06 <Cale> cartertest: Not so much records in the usual sense
12:31:48 <Cale> But type-level records of which types to use.
12:32:05 <Cale> When you have this problem on the value level, of having functions with too many parameters
12:32:23 <typoclass> Cale: you mean several of those type parameters should be bundled up into one "record"?
12:32:24 <Cale> what you normally do is to define some data structures to bundle the parameters which are logically related somehow
12:32:24 * hackagebot partial-uri 0.1.1 - Datatype for passing around unresolved URIs.  http://hackage.haskell.org/package/partial-uri-0.1.1 (StephenWeber)
12:32:28 <Cale> yeah
12:32:45 <typoclass> Cale: right, interesting idea
12:33:02 <cartertest> so now we just need type universes
12:33:04 <cartertest> and we can do that :)
12:33:08 <Cale> right
12:33:20 <cartertest> straddlign the decidable divide
12:35:15 <beaky> why do recursion and stacks go hand in hand
12:35:33 <Cale> They do? :)
12:35:36 <hiptobecubic> They don't.
12:35:42 <hiptobecubic> Maybe non-tail recursion?
12:35:50 <beaky> ah yes
12:35:58 <Mortchek> Ah, I bet I could use the Monad operations on Either to make my above code nicer
12:35:59 <mauke> because recursion involves function calls, and function calls and stacks go hand in hand
12:36:13 <mauke> hmm, no
12:36:16 <mauke> it's really recursion
12:36:20 <Cale> Function calls and stacks go hand in hand?
12:36:25 <typoclass> beaky: in a language where one call to a function = one item on the stack, you can say recursion (a function calling itself) goes hand in hand with stacks
12:36:30 <mauke> no, just recursion
12:36:39 <beaky> in godel, escher, and bach hofstadter said recursion is all about stacks
12:37:12 <mauke> beaky: when you recurse, you need to remember where you are so you can continue when the recursive call is done
12:37:20 <Cale> beaky: Okay, so there's an implementation of recursion which involves the use of a stack, so that you remember what part of the program is next.
12:37:24 <beaky> ah
12:37:33 <mcstar> it is like a list... which is like a stack
12:37:37 <mcstar> which is like recursion..
12:37:53 <beaky> stacks ftw
12:38:05 <mauke> and since the recursive call can recurse itself, you need a growable list of remembered contexts
12:38:08 <Cale> beaky: GHC doesn't use a call stack
12:38:29 <mauke> if you didn't have recursive functions, you could just use a single memory location associated with the function
12:38:43 <Cale> (but it does actually use a stack, just not for function applications)
12:38:48 <beaky> ah
12:38:53 <mcstar> mauke: what about non-direct recursion?
12:38:59 <mcstar> a calls b calls a
12:39:06 <mauke> i.e. your "stack" wouldn't be tied to the runtime call structure but to the number of functions in total
12:39:22 <mauke> mcstar: that's still recursion :-)
12:39:30 <beaky> recursion ftw
12:39:49 <Cale> beaky: GHC uses a stack to keep track of the case expressions (or other pattern matches) which are waiting for their scrutinee to be sufficiently evaluated to be able to pattern match.
12:40:12 <Sculptor> it's only a recursion, if it ends, eventually
12:40:19 <Cale> Sculptor: oh?
12:40:24 <Cale> > fix (1:)
12:40:30 <lambdabot>   mueval-core: Time limit exceeded
12:40:32 <Cale> lol
12:40:38 <mauke> if it ends, it's tails all the way
12:40:38 <beaky> so stacks are useful anywhere where a LIFO-ordered proessing is needed?
12:40:42 <mauke> er, doesn't end
12:40:44 <Cale> LAMBDABOT Y U SO BROKENED
12:40:48 <Cale> > fix (1:)
12:40:56 <lambdabot>   mueval: ExitFailure 1
12:40:56 <lambdabot>  mueval: Prelude.undefined
12:40:58 <Cale> I guess lispy is recompiling GHC
12:41:02 <mcstar> > show $ fix (1:)
12:41:04 <Cale> so it's going to be pretty unusable
12:41:07 <beaky> what is mueval?
12:41:09 <lambdabot>   mueval: ExitFailure 1
12:41:09 <lambdabot>  mueval: Prelude.undefined
12:41:11 <arcatan> fix isn't fixing it :(
12:41:18 <Cale> mueval is the program which lambdabot uses to evaluate expressions
12:41:33 <nand`> > fix error
12:41:34 <mcstar> it worked before, did lambdabot catch something?
12:41:38 <lambdabot>   mueval-core: Time limit exceeded
12:41:51 <mcstar> hm, maybe someone did unsafe stuff with lambdabot
12:41:51 <beaky> @pl (.)
12:41:52 <lambdabot> (.)
12:42:08 <Cale> Lambdabot limits wall-clock time
12:42:14 <mauke> > 2 + 2
12:42:20 <mcstar> but it doesnt print stuff now
12:42:21 <lambdabot>   mueval: ExitFailure 1
12:42:21 <lambdabot>  mueval: Prelude.undefined
12:42:22 <Cale> and so if the machine it's running on is busy, it can just start failing
12:42:23 <mcstar> it used ot
12:42:25 * hackagebot ghc-events 0.4.2.0 - Library and tool for parsing .eventlog files from GHC  http://hackage.haskell.org/package/ghc-events-0.4.2.0 (MikolajKonarski)
12:42:27 * hackagebot libstackexchange 0.1.0.0 - StackExchange API interface  http://hackage.haskell.org/package/libstackexchange-0.1.0.0 (MatveyAksenov)
12:42:57 <Cale> > 1
12:43:00 <mcstar> oh, it fails on everthing
12:43:01 <lambdabot>   mueval-core: Time limit exceeded
12:43:17 <Cale> It's funny, there are multiple time limits :P
12:43:48 <Sculptor> we need a strike-breaker
12:45:24 <Cale> also, it probably figures in somewhat that the GHC which lispy built the first time was with -split-objs which made the linker very slow
12:45:35 <Cale> (which is why he's rebuilding it)
12:46:20 <Ralith> mueval uses the GHC API right?
12:48:02 <bitonic> ivanm, donri: hey, what is wrong with the cabal files?  for what concerns the bktree package I didn't really look...
12:48:52 <donri> bitonic: descriptions, urls and such
12:49:02 <donri> copied from language-spelling
12:49:08 <bitonic> donri: OK, will fix
12:49:10 <bitonic> thanks
12:49:14 <donri> np
12:49:40 <bitonic> I was coding that for my edification, so yeah I didn't look.  I noticed that those two modules were decoupled anyway and so separated it
12:49:48 <bitonic> donri: btw, the url is right
12:49:54 <bitonic> it's in the same repo
12:50:26 <bitonic> the description seems OK as well
12:50:33 <beaky> in haskell, is it legal to recurse on main?
12:50:40 <mauke> beaky: sure
12:50:41 <Cale> Ralith: yes, via hint
12:50:42 <beaky> it's illegal in C, C++, and Java
12:50:46 <beaky> ah awesome
12:50:47 <mauke> beaky: it's legal in C
12:50:48 <donri> aha
12:50:50 <bitonic> beaky: no, the haskell police will get you
12:50:52 <beaky> it's legal in C?
12:50:52 * Ralith nod
12:50:54 <mauke> are you sure it's illegal in java?
12:51:04 <Cale> Of course it's legal in those other languages.
12:51:04 <beaky> it's illegal in C++ for some reason.
12:51:08 <Cale> what?
12:51:14 <mauke> yes, because main() isn't actually a function in C++
12:51:14 <beaky> error: ISO C++ forbids calling '::main' from within program
12:51:28 <Cale> That is ridiculous.
12:51:42 <mauke> Cale: sort of required because of C++'s other constraints
12:51:42 <jesyspa> Not only are you not allowed to call it, you cannot even take its address.
12:51:48 <mauke> (which are indeed ridiculous)
12:51:51 <jesyspa> Not sure what other constructs require it.
12:52:10 <Ralith> mauke: what constraints require it?
12:52:11 <beaky> Wrapping the body of main in another function and recursing on that works though :D
12:52:22 <mauke> C++ overloading is based on its type-based name mangling
12:52:32 <mauke> so the linker selects the appropriate symbol
12:53:00 <mauke> 'main' can't be overloaded because the entry point has to be "main" exactly, no name mangling
12:53:07 <mauke> so it's special-cased in the compiler
12:53:15 <mauke> also, main has two possible valid types
12:53:30 <mauke> oh, and main has an implicit return at the end, unlikely every normal function
12:53:43 <mauke> an implicit 'return 0', that is
12:53:52 <Cale> mauke: lol, so they let the implementors dictate what the language allows because of some implementation detail in the linker
12:54:08 <mauke> Cale: the whole language is designed that way
12:54:12 <mrlemao> is there a specific reason why haskell won't allow functions with the same name but different type signatures?
12:54:20 <Cale> yeah, I should have added "yet again"
12:54:59 <Cale> mrlemao: Because it breaks type inference.
12:55:11 <Cale> mrlemao: You get a combinatorial explosion of things to try.
12:56:21 <mrlemao> Cale: but wouldnt that be same prob in most ohter languages which support this?
12:56:27 <mauke> id x = x; id x y = x y  -- what now?
12:56:39 <Cale> mrlemao: Yeah, they have shitty type inference.
12:56:45 <mauke> mrlemao: most languages don't have type inference
12:56:47 <Cale> mrlemao: We want good type inference.
12:57:03 <Cale> So we don't allow that.
12:57:26 * hackagebot transformers-free 1.0.1 - Free monad transformers  http://hackage.haskell.org/package/transformers-free-1.0.1 (GabrielGonzalez)
12:57:47 <djahandarie> Languages with shitty type inference, like Agda!
12:57:50 <johnw> Cale himself defends us from such abhorrent things
12:58:04 <Cale> djahandarie: :)
12:58:29 <djahandarie> (I actually hate that you can overload constructors in Agda, most confusing thing ever.)
12:58:50 <mrlemao> Cale: small issue, but annoying sometimes specially for someone coming from the otherside. Same with Record field name collissions
12:58:51 <Cale> djahandarie: I want a dependently typed language which is even a little more Haskellish than Agda.
12:58:56 <Cale> Idris looks interesting
12:59:14 <Cale> mrlemao: Do you know about type classes yet?
12:59:40 <ziman> idris looks very promising
12:59:50 <johnw> mrlemao: you may find that modules also help reduce the pain of name collision quite a bit
13:00:19 <johnw> mrlemao: not every record's members need to be known everywhere, and within a module they can have any non-conflicting name you want, even if that name is used again elsewhere in another module
13:00:19 <Cale> The eager evaluation bothers me
13:01:18 <shergill> Cale: eager evaluation in?
13:01:22 <Cale> Idris
13:01:45 <Cale> and it seems all the other dependently typed languages do this too
13:01:47 <Cale> I don't know why
13:02:12 <shergill> ah. the default lazy evaluation in haskell has always bothered me. not lazy evaluation, but more it being the default
13:02:30 <Cale> Lazy evaluation needs to be the default in order to be useful.
13:02:52 <copumpkin> shergill: http://pchiusano.blogspot.com/2009/05/optional-laziness-doesnt-quite-cut-it.html
13:02:52 <Cale> and moreover, it's more often the thing that you want anyway
13:03:20 <Cale> At least, if you think about the various cases of parts of a program
13:03:43 <shergill> copumpkin: thanks
13:04:03 <Eduard_Munteanu> At least in total language, eager and non-strict semantics are the same.
13:04:06 <mrlemao> Cale: yes, I have used a bit of type classes. Just seems cruft if the only purpose is to have 2+ signatures for a function with same purpose
13:04:08 <Eduard_Munteanu> *languages
13:04:13 <Cale> shergill: You can roughly classify bits of data that a program is managing into "large" and "small" based on whether they have many parts which could in principle be computed separately, or few.
13:04:17 <carter> on the idris list theres bene some chatter about allowing default to be strict or lazy
13:04:44 <Cale> mrlemao: if the functions have nothing to do with each other and/or you don't need that polymorphism, then you have no business naming them the same thing
13:05:08 <shergill> Cale: well the thing that's been biting me lately, oddly enough, is that ghc is too good a memoizer/optimiser. i basically ran into this issue: http://okmij.org/ftp/Haskell/index.html#memo-off
13:06:12 <mrlemao> johnw: that is good to know. I have hit the issue because I was designing a type class with 3 methods (do we call them methods when defined in a type class?) where each method was returning a different record but with same fields
13:06:28 <srhb> mrlemao: No, we do not. :P
13:06:33 <Ralith> carter: recently? no, there hasn't
13:06:35 <mrlemao> Cale: that I don't disagree :-)
13:06:39 <Cale> shergill: and then you can think about computations between those -- small -> small, it doesn't matter if you're lazy or strict, small -> large, you'd rather be lazy about constructing the large bunch of data, because you may not need it all. large -> large, you usually want to be lazy, because you can often process the stuff as a stream
13:06:51 <Ralith> carter: there's been chatter about whether to default to total or partial.
13:07:04 <Cale> large -> small, well, it breaks down into cases based on whether you're searching through the large data or summarizing it somehow
13:07:33 <Cale> But this is basically where you want the strictness to be.
13:07:47 <Cale> Where you're summarizing large structures into small ones.
13:08:41 <Cale> srhb: yes we do
13:08:53 <johnw> mrlemao: i used to think the non-overloading thing was a bit draconian (coming from C++), but now I no longer do, as proper modularization and use of type classes cured most of the places where I had wanted to reach for overloading
13:08:59 <Cale> The report refers to the names defined by a type class as methods.
13:09:02 <shergill> Cale: interesting perspective
13:09:19 <Ralith> 13:02:28 < Cale> Lazy evaluation needs to be the default in order to be useful.
13:09:23 <typoclass> Cale: it is a functional programming language, not a methodical programming language ;-)
13:09:23 <Ralith> Cale: what do you mean by that?
13:09:50 <Cale> Ralith: because the main benefit of lazy evaluation is that programs can be composed in more ways than under strict evaluation
13:10:00 <Cale> or broken down into parts in more ways
13:10:15 <johnw> mrlemao: plus, writing code generically in Haskell is usually not as big a performance loss as it is in C++, where you need to use overloading to provide different implementations for each possible type.  In Haskell I just write in terms of "a -> b", and then upgrade to type classes if needed to know more about "a" or "b"
13:10:28 <Cale> For example, consider the problem of deciding whether some string is a substring of another.
13:10:50 <Cale> (there are much better ways to do this than I'm going to suggest, but bear with me, I just need a simple example here)
13:11:01 <Ralith> that example's actually come up recently
13:11:24 <Ralith> but I don't see how it follows that an eager language is not useful.
13:11:36 <Cale> In Haskell, you can reasonably write  isInfixOf x y = any (isPrefixOf x) (tails y)
13:12:29 <Cale> and this works well, because we have library functions like any, tails, and isPrefixOf which are sufficiently lazy in their operation that it's not completely ridiculous
13:12:39 <Cale> In a strict language, you probably wouldn't even think of this solution.
13:13:02 <Cale> You end up writing recursive things over and over, rather than composing programs out of parts in the libraries.
13:13:22 <johnw> actually, your definition of isInfixOf, rewritten using plain iteration, is close to how I'd solve it in C
13:13:31 <Cale> yes
13:13:43 <Ralith> johnw: his point is that you have to rewrite it to use plain iteration.
13:13:47 <johnw> yes
13:13:58 <johnw> I wanted to make sure that point was heard :)
13:14:01 <Ralith> ^^
13:14:06 <Cale> and the reason you end up writing nested loops or explicit recursion is because even if you have optional laziness, everyone is too *ahem* lazy to actually check if they can effectively use it all the time
13:14:20 <Cale> So your libraries are full of things which are overly strict and which don't compose as well.
13:14:50 <Ralith> I understand the point, but I'm not convinced it's as big an issue as you suggest.
13:15:05 <mauke> Ralith: OCaml has optional laziness
13:15:11 <mauke> how many OCaml modules use it?
13:15:18 <Ralith> mauke: yes, I understand the point.
13:16:47 <Ralith> I don't think I often write haskell that actually depends on laziness, and even then it's usually with an understanding of a similarly convenient but less sensitive approach.
13:16:53 <Ralith> but maybe that's just me.
13:17:30 <Cale> You get some things almost for free, as if by magic. For example, the sort function in the standard list library, if you take the first k elements of the result, the runtime is O(n log k)
13:19:03 <Eduard_Munteanu> Isn't that k log n?
13:19:06 <Ralith> weren't you commenting the other day about how it's usually reasonable to ignore log factors entirely?
13:19:09 <Ralith> or was that someone else
13:19:23 <Cale> Eduard_Munteanu: well, no, you have to look at all the elements of the input to determine the first element
13:19:55 <Cale> I'm normally all for ignoring log factors entirely, but it's rather cute that you can extract an O(n) algorithm for getting the first few elements from the general sort
13:20:21 <Cale> I use the list monad a lot
13:20:25 <Ralith> I agree; it's very cute
13:20:35 <Ralith> but I don't think I've ever written code in which it's anything but cute.
13:20:51 <Cale> I've written a lot of code in the list monad
13:21:13 <Cale> which would be completely broken under strict evaluation
13:21:20 <Ralith> I can see how that might be more prone to it
13:21:29 <Ralith> what do you use the list monad for?
13:21:34 <Ralith> (you specifically, that is)
13:21:46 <Cale> For example, my pipeline scheduler for PPC/Altivec, which was one of the first fairly large programs that I wrote in Haskell
13:21:50 <Eduard_Munteanu> Cale: so head . sort would be O(n log 1) = O(0)?
13:21:54 <Cale> was made a lot lot simpler by laziness
13:22:07 <Ralith> (I am familiar with it, but haven't seen much use for it)
13:22:12 <johnw> Eduard_Munteanu: it would have to be O(n)
13:22:16 <Cale> Eduard_Munteanu: heh, you might have to adjust at the boundary :)
13:22:47 <johnw> Cale: so would binary search be O(1) then? :)
13:22:54 <Cale> Ralith: It's a natural way to do searching. It turns code which looks like a breadth first search into code which is doing a depth-first one.
13:23:05 <Eduard_Munteanu> OTOH, k log n doesn't make sense either for k = 1, as you say, you have to go through it at least once.
13:23:09 <Ralith> interesting; might have to play with that
13:24:41 <Cale> Eduard_Munteanu: it's asymptotic, remember?
13:24:49 <Cale> Eduard_Munteanu: so it doesn't mean much for small arguments
13:25:19 <Eduard_Munteanu> Cale: sure, but I'm fixing one of those numbers by looking at head . sort or similar.
13:25:24 <Cale> yeah
13:25:39 <Cale> You get O(n) behaviour when you take the head
13:25:48 <clahey> So, Arrows and ArrowChoices are designed to work on (,) and Either.  Would it be useful to define lens in terms of arrows instead of functions or not really?
13:26:02 <Eduard_Munteanu> But further matching gives you another O().
13:26:28 <carter> Ralith oh youre right
13:26:28 <johnw> clahey: what would the additional abstraction gain you?
13:27:58 <Eduard_Munteanu> Cale: actually this is about Θ I guess, so it's reasonable to assume changing k yields different asymptotes.
13:28:02 <johnw> can you already compose a monadic lens with a non-monadic one?
13:28:03 <Cale> Eduard_Munteanu: The idea being that you can somehow split up the work such that after the first element is determined, much of the work in finding the second is almost done.
13:28:18 <Eduard_Munteanu> Hrm, yeah.
13:28:22 <clahey> johnw: I don't actually know.
13:28:33 <paolino> what happens when the channel reach 1000 partecipants ?
13:28:57 <Cale> Eduard_Munteanu: and most good sorting algorithms are like that
13:28:58 <clahey> johnw: My one thought was that maybe you could have lenses not know about functors or monads or ... and just use Kleisli arrows.
13:29:05 <clahey> johnw: But I really haven't thought it through.
13:29:45 <Cale> Though you have to be a bit careful to not do a full O(n log n) amount of work to get to the first element.
13:29:49 <typoclass> paolino: free lambdacats for everyone?
13:30:01 <Eduard_Munteanu> Cale: it's weird to reason about it though, you get O(something) in time, but you get O(something bigger) worth of work.
13:30:27 <johnw> clahey: definitely a good question of edwarkd
13:30:46 <johnw> edwardk: ahem, lens, cough
13:30:48 <Cale> Eduard_Munteanu: It's easy for fixed k to imagine an O(n) algorithm for getting the least k elements.
13:30:52 <paolino> typoclass, it's going to happen in 2012
13:31:17 <fmap> johnw: you mean like `[1,2,3] ^! _head . act print'? sure
13:31:58 --- mode: ChanServ set +o Cale
13:32:07 <johnw> ok, then arrows ought to be superfluous, as the monadic type is already abstractetd in the MonadLens, yes?
13:32:48 --- mode: Cale set -o Cale
13:33:25 <Cale> clahey: That would add a lot of complicated mess to the Lens library for relatively low benefit
13:33:33 <Eduard_Munteanu> I could see the red dot over his forehead. :)
13:33:35 <Cale> because not many people use Arrow in its current state
13:33:44 <johnw> Cale: but would it add any benefit at all?
13:34:36 <EvanR> im trying to understand wth 'jaskell' is
13:34:37 <Cale> johnw: I guess it depends on exactly what happens to the interpretation of the lens laws...
13:35:07 <EvanR> i guess it isnt pure or lazy
13:35:23 <Cale> johnw: well, no, it really would add something
13:36:05 <Cale> Once you start programming with arrows, there are structures which are fundamentally only accessible via arrow computations.
13:36:16 <johnw> Cale: such as?
13:38:29 <Cale> Well, you'll end up with things that have structures that you want to lens through on the right of an arrow, like  a ~> MyStructure
13:38:51 <Cale> and I guess you could always do this using an ordinary lens with arr
13:39:04 <Cale> but one could imagine being able to avoid arr somehow as well
13:39:19 <johnw> or make an ArrowLens, without having to propagate arrowness throughout the whole of the lens library
13:40:00 <shergill> johnw: ooc, what do you do for work?
13:40:10 <johnw> shergill: I work on C++ compilers right now
13:40:42 <beaky> C++ compilers? :D
13:40:55 <johnw> yes, several of them
13:41:02 <johnw> but I'm looking to move into Haskell professionally
13:41:12 <Cale> johnw: Who are you working for? :)
13:41:37 <johnw> i have my own company now, my current contract that I'm working on while chatting with you guys is with Texas Instruments
13:41:43 <johnw> they want OpenCL support in their EDG front-end
13:42:10 <johnw> but if all goes well, I will be a full-time Haskell coder by the end of the year
13:42:16 <mauke> johnw: ooh, can you explain the C++ name resolution rules to me?
13:42:34 <johnw> mauke: well, I could certainly, but do you really want to know them? :)
13:42:38 <shergill> johnw: and there too, working for yourself?
13:42:45 <mauke> yes, actually
13:42:55 <johnw> shergill: no, the Haskell job would mean becoming an employee again at another company and giving up my won gig
13:42:57 <johnw> s/won/own
13:43:01 <mauke> because I'm not sure the rules are actually deterministic
13:43:41 <shergill> johnw: so something like galois and the likes?
13:43:47 <johnw> mauke: they are deterministic for sure, but depending on overloading, and if you're in a template, they can be frightfully hard to figure out
13:43:52 <johnw> shergill: close
13:44:00 <johnw> shergill: i'll let you know once I've accepted :)
13:44:31 <johnw> i'm interviewing right now at two places
13:44:35 <shergill> i have wondered how many people at work have the luxury of working in a nice programming language. i'm currently hacking away at scala, and it's not too bad, but it's fugly at times
13:45:03 <shergill> johnw: sweet! yes, do let me know. and hope you find a right fit :)
13:45:11 <johnw> thanks, shergill!
13:45:25 <johnw> i find the prospect of spending all day in Haskell quite an exciting one
13:45:38 <lpsmith> edwardk,  I'm looking at machines right now,  and I'm having trouble inferring the intention/intuition behind the "k" type variable.
13:45:46 <johnw> (I already do so on some days, to the detriment of my C++ contracts!)
13:47:45 <Ralith> johnw: what's the motivation for the switch from contracting to regular employment, if not just the lure of haskell?
13:47:58 <lispy> johnw: oh, ROSE uses EDG
13:48:08 <callen> what are the more expert impressions of Yesod? Snap and Happstack seem too piecemeal for this Haskell noobie.
13:48:09 * lispy is working on fixing bugs in ROSE at the moment
13:48:25 <johnw> Ralith: it's 70% the lure of Haskell, and 30% the lure of not having to manage subcontractors or always be hunting for new work
13:49:07 <stepcut> callen: happstack-foundation is  the integrated solution for happstack
13:49:07 <callen> I'm going to have to agree with johnw, I used to be a contractor. I switched to startups. I'm not sure I actually reduced my stress levels.
13:49:15 <lispy> johnw: where are you located geographically?
13:49:26 <johnw> lispy: about 3 hours due South of Chicago
13:49:28 <lispy> johnw: and how do you feel about working as a subcontractor?
13:49:31 <callen> stepcut: being able to use Warp is pretty appealing.
13:49:36 <stepcut> callen: oh ?
13:49:50 <johnw> lispy: i enjoy being the subcontractor more, actually
13:49:53 <shergill> i'm currently at a startup. i think i'd prefer a startup to contractual work. but i do eventually want to have my own company/startup
13:49:57 <johnw> lispy: business ownership is *very* stressful
13:50:05 <luite> callen: for a very simple framework, yu can use scotty, it's built on wai, so it's still easy to move to the full yesod later if you want full type safety
13:50:21 <callen> luite: the problem is that Scotty, haha, is too minimalist. Although I do like it.
13:50:31 <callen> luite: one issue is that's not clear how to move to proper filesystem templates.
13:50:36 <stepcut> callen: what do you find appealing about warp?
13:51:08 <callen> stepcut: nothing rational.
13:51:15 <stepcut> callen: the name ? :p
13:51:28 <shergill> johnw: wouldn't you still have the issue of having to find new work (if you're a subcontractor)?
13:51:43 <luite> callen: oh i haven't really looked into scotty and templates, it should be possible to hook it up with hamlet
13:51:43 <stepcut> callen: happstack is working on a new backend based on pipes which should be at least as fast and more provably correct
13:52:07 <luite> stepcut: booh pipes is abandoning correctnes now too ;p
13:52:29 <stepcut> luite: yeah..
13:52:52 <stepcut> who needs correctness when you can be fast, AMIRITE!
13:52:56 <johnw> shergill: that all depends; a lot of my contractors keep reusing me for really long periods of time, so I have never been in that boat as a subcontractor
13:52:56 <callen> stepcut: I mostly just want to make things...but in Haskell. I'm not hyper-interested in the plumbing.
13:53:17 <callen> stepcut: I want to learn and benefit from learning Haskell, but I have to be able to be reasonably productive and ship code.
13:53:41 <callen> correctness, etc aren't interesting to me.
13:54:04 <callen> worrying about the correctness/type safety of the web framework is a bit of a canard when you're coming from Python. The base type system is already a massive improvement.
13:54:09 <stepcut> callen: you prefer to ship incorrect code?
13:54:19 <luite> callen: yesod is probably the framework that does the most to get plumbing out of the way, at the cost of more complexity for less common use cases
13:54:26 <callen> it's like an ethiopian complaining about eating plain eggs and rice for dinner when they were starving last week.
13:54:38 <johnw> s/contractors/contract providers
13:54:46 <callen> I have no type system of any sort that really helps me right now. I'd like to change that.
13:55:23 <callen> one problem at a time. I want to be able to reasonably quickly be able to hack up web apps in Haskell and learn Haskell as I go. Next step is extending and harnessing the power of the type system to help me out more.
13:55:35 <stepcut> i would say that happstack-foundation and yesod are pretty darn close
13:57:15 <beaky> I love recursion, but my programs keep ending in stack blowout when I feed large input sizes :(
13:57:25 <beaky> how do I make sure that doesn't happen?
13:57:30 <johnw> it's not recursion that's hurting you
13:57:37 <luite> rewrite your recursion so it doesn't use the stack :)
13:57:48 <hpc> or rewrite your whole algorithm to use less memory
13:58:00 <johnw> it's more likely excessive laziness that's biting you
13:58:21 <typoclass> beaky: hpaste your problematic code and ask in here
13:58:33 <johnw> beaky: the stack blowout thing is something you will definitely get better at fixing over time, but there's no silver bullet
13:59:12 <johnw> my usual Haskell coding plan is "design, implement, test, fix stack blowout, optimize" :)
13:59:28 <callen> Actually, that's a sticking point. The universal recursion is a really difficult thing for me to grapple with.
13:59:35 <callen> I'm used to even Common Lisp having a LOOP macro.
13:59:45 <callen> Not having basic iteration is somewhat crippling.
13:59:49 <mauke> recursion doesn't use the stack
13:59:59 <johnw> callen: i find recursion to be a really good way of partitioning a problem
14:00:34 <johnw> you solve the core idea, and then recursion repeats your solution through the domain
14:01:00 <merijn> callen: tbh I mostly use things like map/fold/filter/etc. rather than hand writing recursion...
14:01:18 <merijn> callen: LOOP macro's mostly only make sense if you have mutable state to update...
14:01:24 <johnw> merijn is write, hand-written recursion becomes somewhat rare
14:01:25 <callen> johnw: uh, sure? it's just that recursing with a function is really apt for some problems (traversing trees) and less apt for others, and when it's less well-suited it becomes a somewhat mentally slippery process to develop a mental model of how exactly to model the traversal as a recursion.
14:01:28 <johnw> s/write/right
14:01:39 <johnw> callen: can you give me an example of where it's not apt?
14:01:46 <callen> johnw: I have somewhat less trouble with this in Clojure for some reason.
14:01:57 <callen> johnw: I don't have something at hand immediately, but it's come up before in Clojure and Haskell for me.
14:02:08 <johnw> next time you find something, came back here and bring it up
14:02:11 <johnw> i'd love to go over it with you
14:02:29 <johnw> at first I felt hobbled by the lack of iteration too
14:02:39 <callen> aye, I will, but I have a feeling it'd turn into: http://www.survivedavis.com/wp-content/uploads/2012/04/owl.jpg
14:02:48 <johnw> but now I don't miss it at all, while I *do* miss lazy maps and folds whenever I'm in C-land
14:03:01 <johnw> haha
14:03:15 <johnw> don't worry, I'm not into that kind of documentation ;)
14:03:16 <callen> johnw: hrm, don't assume the alternative is a C-alike. I come from a predominantly Python and Common Lisp background.
14:03:28 <johnw> i'm also a big Lisp user, and fan of LOOP
14:03:40 <johnw> Python is C-alike enough
14:03:40 <callen> johnw: try to understand that from my point of view, I'm *giving up* ways of expressing myself in exchange for an awesome type system and static binaries. That's the value proposition for me.
14:04:01 <callen> overcoming the disadvantages and discomfort is a goal, but it's still a trade-off.
14:04:14 <johnw> monadic code does have certain kinds of iteration
14:04:23 <johnw> like the equivalent of Python's "for"
14:04:30 * typoclass is trying to think of for or while loops that couldn't be expressed as map or foldr or some other haskellish thing ...
14:04:51 <callen> I'm not saying Haskell isn't turing complete. I'm saying having options eliminated can mean some things are more awkward.
14:05:02 <callen> Static type systems can make some things awkward that are fine in Dynamic type systems.
14:05:07 <callen> that's okay. it's a trade-off. Just be honest about it.
14:05:32 <callen> you don't have to pretend everything about a language is PEACHY OKAY PERFECT YUP YUP YUP like the #go-nuts people.
14:06:03 <johnw> callen: I guess I'd say that the feeling of awkwardness is due to a paradigm mismatch, not because iteration gives you things that you will actually miss once you start using Haskell to solve problems in a functional way
14:06:09 <merijn> callen: Pfft, the only thing that's not perfect is the record syntax :p *ducks*
14:06:09 <typoclass> callen: if you could offer some examples (hpaste), that would help
14:06:16 <merijn> And lack of type level lambda's :<
14:06:44 <johnw> i've not needed iteration, becaues map and fold offer the same behavior in a more functionally oriented package
14:06:49 <mauke> merijn: and modules
14:06:56 <mauke> merijn: and dependent types
14:07:01 <mauke> merijn: and template haskell :-)
14:07:08 <merijn> mauke: Yeah, I recently ran into the lack of module problems for the first time
14:07:20 <merijn> Although, tbh modules would also partially solve the record problem
14:07:41 <Cale> callen: You also have *more* ways to express things too though, because the type information can be used to determine which code you're using.
14:08:03 <merijn> mauke: I'd say that type level lambda gets me sufficiently close to dependent types for now, but I think I need to learn Idriss/Agda if I want those
14:08:06 <Cale> callen: In dynamically typed languages, it's rare to have operations which are polymorphic on their result type.
14:08:23 <callen> Cale: you'd be surprised.
14:08:31 <Cale> callen: i.e. which produce a value in some way which is dependent on which type is required of them
14:08:50 <callen> Cale: a lot of Java and Python code could be improved with a Maybe monad and a bind operator, but what you describe is more common in Python and Ruby than you'd generally think.
14:08:55 <Cale> Because you don't statically have that information and usually can't dynamically construct it either.
14:09:13 <merijn> callen: Not really, there's no way to write it in python
14:09:16 <johnw> callen: for example, if I wanted the equivalent of "for (i = 0; i < 10; i++)" to walk over the first ten elements of a list while knowing what my index was, I'd write: foldl (\idx x -> (idx + 1, f x)) (0,undefined) (take 10 xs).  I can abstract that into a utility function if I end up using that pattern often
14:09:29 <Cale> You can't really do what I'm talking about in python at all.
14:09:38 <Cale> Or non-statically-typed lisps.
14:09:46 <callen> I'm no longer certain what you're talking about.
14:09:55 <Cale> :t read
14:09:57 <merijn> callen: A typeclass like Read/Bounded
14:09:58 <lambdabot> forall a. Read a => String -> a
14:10:00 <Cale> simple example
14:10:02 <merijn> > minBound :: Int
14:10:03 <lambdabot>   -9223372036854775808
14:10:05 <merijn> > minBound :: Bool
14:10:07 <lambdabot>   False
14:10:13 <Cale> > read "[1,2,3]" :: [Integer]
14:10:14 <lambdabot>   [1,2,3]
14:10:25 <johnw> Perl is polymorphic on the return type, and is dynamic
14:10:27 <Cale> The parser to apply is determined by the type which is demanded of the result.
14:10:35 <merijn> Cale: Is there any statically typed lisp/scheme other than Racket?
14:10:43 <johnw> scalar @foo vs. @foo, for example
14:11:07 <johnw> merijn: Common Lisp allows compile-time type annotations
14:11:08 <Cale> johnw: yeah, that's the only example I could think of, and even then, you're putting type information in syntactically around the point where you're using the values
14:11:14 <stelleg> Cale: thats pretty cool
14:11:17 <typoclass> > zipWith (\idx x -> (x, idx)) "lolcatslolcats" [0..9] -- johnw ...?
14:11:18 <lambdabot>   [(0,'l'),(1,'o'),(2,'l'),(3,'c'),(4,'a'),(5,'t'),(6,'s'),(7,'l'),(8,'o'),(9...
14:11:37 <typoclass> uh, wrong way around, but anyway ... :-)
14:11:39 <merijn> stelleg: It's a pretty powerful notion that you don't really get in many other languages :)
14:11:43 <johnw> Cale: the use of "scalar" was just to distinguish; in actual Perl code the interpretation of @foo depends on the "type context" in which it's used, without any annotations provided
14:11:43 <Cale> callen: Incidentally, this is also why monads are not popular in most languages.
14:12:03 <johnw> typoclass: even better!  I'm not yet a big user of zip, so I didn't think of that
14:12:08 <merijn> stelleg: Although I usually think that Bounded is a better example than Read
14:12:15 <callen> Cale: I use monads in Python all the time.
14:12:18 <Cale> johnw: Oh, I suppose that's true... there are some cases. I was thinking of the whole "which sigil you use" distinction, but there's more.
14:12:21 <stelleg> merijn: can you give me an example?
14:12:22 <Cale> callen: Not really :P
14:12:32 <callen> Cale: yes really. Don't tell me how i write my code.
14:12:35 * monochrom rejects sigils
14:12:39 <merijn> stelleg: The problem is that read fails ungracefully when you use it on the wrong input
14:12:41 <Cale> callen: Not unless you've bitten the bullet of passing dictionaries around everywhere.
14:12:41 <callen> Cale: I started using monads in Python expressly because of what I'd learned from Haskell.
14:12:46 <merijn> > read "3" :: Bool
14:12:47 <lambdabot>   *Exception: Prelude.read: no parse
14:12:48 <stelleg> merijn: sure, that makes sense
14:13:00 <callen> Cale: nothing so crude or stupid. It's a lightweight and relatively Pythonic way of doing it.
14:13:00 <merijn> stelleg: Whereas something like Bounded can never fail
14:13:03 <mrlemao> johnw: "upgrade to type classes if needed to know more about "a" or "b"": do you mean that you start with a -> b then if you need to constrain it further you go the "Show a =>  a -> b" route, for instance?
14:13:10 <Cale> callen: There's no point in talking about monads unless you can write code which will work uniformly in any monad.
14:13:33 <callen> Cale: well that's plainly not true. They can be useful in many circumstances and languages even when they don't support them uniformly.
14:13:34 <merijn> stelleg: Although Data.Text now exports "readMaybe :: Read a => String -> Maybe a"
14:13:36 <typoclass> johnw: you're welcome. zip isn't very difficult at all. zipWith is pretty much a Prelude.map that walks over two lists, not one. it cuts off when it reaches the end of the shorter list
14:13:36 <johnw> mrlemao: exactly!
14:13:40 <mrlemao> Cale, johnw: thanks for the feedback
14:14:05 <hiptobecubic> callen, do you have an exmaple? I'm interested
14:14:07 <Cale> callen: You can write libraries where there happens to be a monad structure present, but people have been doing that since the beginning of functional programming.
14:14:13 <stelleg> > readMaybe "45" :: Int
14:14:14 <lambdabot>   Not in scope: `readMaybe'
14:14:22 <Cale> Unless you abstract over all monads, you're not really "programming with monads"
14:14:24 <stelleg> right
14:14:26 <stelleg> duh
14:14:30 <callen> hiptobecubic: I don't really want to post company code, so I'll make a quick example.
14:14:39 <stelleg> merijn: cool, that seems like a better solution
14:14:43 <Cale> You're just using something which you've happened to recognise is a monad and gain nothing in particular from that knowledge.
14:14:44 <merijn> stelleg: One example where you use this would be some code I'm working on right now
14:15:12 <stelleg> merijn: yeah I could see having it in a monad would allow you to a lot more with it
14:15:37 <Cale> Don't get me wrong, there are a lot of good combinator libraries which are still good even if you have to reimplement a large part of Control.Monad every time.
14:15:43 <merijn> stelleg: I'm using FFI bindings to different languages and I need to pass a handle to those bindings, but the type of handle depends on the target language. So I have a generic Handle class that will automatically create the appropriate handle based on the binding I'm using it with
14:16:10 <merijn> stelleg: eh, "a handle" not "a handle to those bindings"
14:16:15 <johnw> callen: I guess one question to ask would be whether iteration offers concepts that *can't* translate to a language like Haskell, or simply that the translate is onerous; and then there is question of whether they *should* be translated, in the presence of other ways of working
14:16:20 <Cale> But yeah, return in particular is the sticking point.
14:16:33 <Cale> Because what return does depends on the result type.
14:16:40 <merijn> stelleg: Yeah end up with a class like: https://github.com/merijn/SNet2.0/blob/master/SNet/Interfaces.hs
14:18:09 <stelleg> > :t (read "3" :: Int)
14:18:10 <lambdabot>   <hint>:1:1: parse error on input `:'
14:18:16 <acowley> Does the machinery exist in Control.Lens.Iso to abstract the pattern of lifting a binary operation to work on newtyped values?
14:18:17 <stelleg> :t (read "3" :: Int)
14:18:19 <lambdabot> Int
14:18:24 <stelleg> :t (read "notanint" :: Int)
14:18:25 <lambdabot> Int
14:18:54 <rwbarton> > import Control.Monad
14:18:55 <lambdabot>   <hint>:1:1: parse error on input `import'
14:19:01 <merijn> stelleg: The type selects which implementation of read to pick, but obviously whichever implementation you pick, it won't work for all Strings
14:19:28 <merijn> stelleg: But if the implementation is failure free like that Handle class or Bounded then it's no problem, because any implementation is guaranteed to work
14:19:40 <merijn> stelleg: read is somewhat like head in that respect
14:19:45 <merijn> > head [1]
14:19:46 <lambdabot>   1
14:19:47 <merijn> > head []
14:19:48 <lambdabot>   *Exception: Prelude.head: empty list
14:19:54 <stelleg> sure
14:19:59 <callen> hiptobecubic: http://dpaste.de/xghTU/
14:20:15 <ion> Extrapolation: all ?ead functions are evil.
14:20:17 <stelleg> is there a version of head that of type [a] -> Maybe a ?
14:20:18 <callen> not really proper monads or anything, but it's an example of the influence haskell has had on my python code.
14:20:23 <stelleg> i mean it would be trivial to implement
14:20:33 <stelleg> just wondering if there is a standard one people use
14:20:39 <merijn> stelleg: I guess you'd want "[String] -> [a]" instead?
14:20:40 <mauke> callen: that doesn't look monadic
14:20:42 <rwbarton> ion: I hear lead is dangerous too.
14:20:44 <johnw> callen: interesting!
14:20:54 <mauke> @hoogle [a] -> Maybe a
14:20:54 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
14:20:55 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
14:20:55 <lambdabot> Prelude head :: [a] -> a
14:20:56 <johnw> callen: it's more an implementation of Maybe than of Monad, but I see the connection
14:21:01 <callen> mauke: it's not supposed to be proper. I had to hack up a dumb example.
14:21:03 <merijn> stelleg: Which you could write by combining "readMaybe" and "listToMaybe"
14:21:04 <callen> johnw: yes, precisely.
14:21:11 <merijn> :t Data.Text.readMaybe
14:21:12 <lambdabot> Not in scope: `Data.Text.readMaybe'
14:21:12 <callen> I'm not trying to implement Haskell in Python
14:21:15 <mauke> callen: it's a dumb example of the wrong thing
14:21:21 <mauke> callen: also, Just Nothing
14:21:25 <stelleg> merijn: oh I was just talking about head
14:21:42 <callen> mauke: I don't really care what you think. I mentioned that Haskell had influenced my Python code, they wanted an example so I made one.
14:21:46 <stelleg> merijn: seems like it would be have a more graceful way to fail with the head function
14:21:50 <stelleg> e.g. head [] = Nothing
14:21:52 <mauke> yes, but it's not monadic code
14:21:54 <mauke> it's Maybe-like code
14:21:57 <callen> mauke: sure.
14:22:01 <callen> why do I care?
14:22:11 <mauke> because Cale was specifically talking about monadic code
14:22:13 <merijn> :t Text.Read.readMaybe
14:22:14 <lambdabot> Not in scope: `Text.Read.readMaybe'
14:22:17 <callen> mauke: why do I care?
14:22:26 <mauke> I don't know. why do you care?
14:22:34 <callen> that's just it, you seem to think I do.
14:22:50 <hiptobecubic> callen, did you see that blog post on monadic python?
14:22:53 <merijn> stelleg: There are people who agree and think head should have that type, yeah
14:22:57 <mauke> callen: yes, because you're talking. why are you still talking?
14:22:58 <callen> hiptobecubic: dustingetz?
14:23:06 <merijn> stelleg: I misread "head" as "read" in your question xD
14:23:13 <k00mi> stelleg: there is a "safe" package that includes what you search
14:23:13 <callen> hiptobecubic: I'm the only person he knows that writes code that way in Python.
14:23:23 <stelleg> k00mi: cool
14:23:24 <Cale> What I'm saying is, is that you can implement many monads in Python, but you can't implement monads in Python :)
14:23:31 <stelleg> merijn: yeah fair enough
14:23:35 <Cale> (at least not with an interface that people will want to use)
14:23:37 <merijn> stelleg: The other solution is to just use pattern matching, rather than head :)
14:23:41 <callen> johnw: the production code I've written is *along* those lines. basically in a pseudo-hungarian sort of way I indicate possibilities in return values and contingencies, use bind and composition HOF to tie it all together.
14:23:48 <hiptobecubic> callen, http://www.valuedlessons.com/2008/01/monads-in-python-with-nice-syntax.html
14:23:51 <startling> you could define .return as a classmethod and .bind as an instance method
14:23:51 <stelleg> merijn: true, head is a less interesting case
14:24:01 <stelleg> merijn: compared to generic parsers
14:24:01 <mauke> Cale: even most monads get super awkward due to lambda/bind syntax
14:24:02 <callen> hiptobecubic: oh that's somebody else.
14:24:16 <johnw> callen: glad to see Haskell's ideas have been useful to you on the imperative side
14:24:28 <merijn> stelleg: Oh, another nice example typeclass is Data.Default
14:24:33 <merijn> > def :: Bool
14:24:34 <lambdabot>   Not in scope: `def'
14:24:34 <lambdabot>  Perhaps you meant one of these:
14:24:34 <lambdabot>    `dff' (imported fro...
14:24:38 <callen> hiptobecubic: could be worse, could be better. My approach is pretty lightweight and just designed to reduce dumb-fucking type errors and make exceptions unnecessary.
14:24:44 <merijn> oh, not in scope :\
14:24:54 <rwbarton> :t dff
14:24:55 <lambdabot> Graph -> Forest Vertex
14:24:56 <mauke> merijn: I'm pretty sure Bool doesn't have an instance
14:25:03 <mauke> or am I wrong?
14:25:10 <merijn> stelleg: Data.Default is a typeclass that has "def :: a" which is a "default" value for that type
14:25:16 <callen> hiptobecubic: I'm not interested in implementing Haskell in Python, as I said. My goal was to make it so I don't have to do try/except/raise very often and to make certain no type errors/None issues arise.
14:25:17 <merijn> mauke: No clue, I was just guessing a simple example
14:25:23 <stelleg> mauke: I don't see one for Bool actually
14:25:34 <stelleg> merijn: yeah that is cool
14:25:47 <mauke> def :: (), def :: Maybe (a -> b)
14:25:52 <hiptobecubic> callen, it's not haskell. It's proper monads with an abstract interface you can reuse
14:26:31 <merijn> stelleg: And you can imagine loads more things like that which are hard or impossible to do in other languages
14:26:36 <callen> hiptobecubic: I know, and I saw, but you can't introduce things like that in an existing Python codebase.
14:26:52 <callen> hiptobecubic: you have to introduce smaller, more confined stylistic differences that educate them on the benefits of FP to begin with.
14:27:07 <hiptobecubic> callen, well that's a different goal altogether
14:27:17 <espringe> Is there a nicer way to write this?
14:27:17 <espringe> (\x -> my_function (fst x) (snd x))
14:27:41 <callen> hiptobecubic: All I really care about is getting better at writing code and improving the code I write.
14:27:45 <mauke> :t uncurry
14:27:46 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:27:54 <callen> hiptobecubic: part of that means incremental improvements that won't make the other people puke.
14:28:30 <fmap> :t \f -> liftA2 f fst snd
14:28:31 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:28:46 <merijn> fmap: Seems a roundabout way to define uncurry
14:28:59 <mauke> :t join (***)
14:29:00 <lambdabot>     Not in scope: `***'
14:29:00 <lambdabot>     Perhaps you meant `**' (imported from Prelude)
14:29:05 <espringe> How would I use uncurry in this case?
14:29:11 <ocharles> :t uncurry
14:29:12 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
14:29:21 <ocharles> oh, mauke did that
14:29:22 <espringe> oh
14:29:22 <ocharles> ignore me :)
14:29:22 <espringe> i see
14:29:23 <espringe> thanks
14:29:24 <merijn> espringe: "uncurry my_function"
14:29:46 <mauke> :t uncurry ?my_function
14:29:46 <lambdabot> forall a b c. (?my_function::a -> b -> c) => (a, b) -> c
14:29:57 <mauke> :t (&&&)
14:29:57 <lambdabot>     Not in scope: `&&&'
14:29:57 <lambdabot>     Perhaps you meant `&&' (imported from Prelude)
14:30:01 <espringe> perfect :D
14:30:05 <merijn> Awww
14:30:14 <mauke> :t (A.&&&)
14:30:15 <lambdabot> Couldn't find qualified module.
14:30:16 <merijn> lambdabot got amnesia about Control.Arrow :(
14:30:18 <fmap> merijn: it's a shame i'm immediately see `liftA2' and not `uncurry', apparently :[
14:30:18 <lispy> Cale: new ghc on the linode. Maybe less trouble linking?
14:31:09 <Luig1> Hi there!
14:31:10 <chrisdone> is there a utility for combining Ordering values? often you want to sort by several fields of an object. if the first is EQ, then you compare the second, etc.
14:31:16 <rwbarton> mappend
14:31:25 <ion> chrisdone: The monoid instance.
14:31:27 <chrisdone> i don't have a Monoid instance here
14:31:37 <rwbarton> the Monoid instance for Ordering
14:31:40 <mauke> import harder
14:31:42 <chrisdone> ah, i had to import Data.Monoid
14:31:43 <Luig1> I was here on Monday doing TryHaskel. I said I'd be here on Tuesday, but... nope.
14:31:46 <typoclass> chrisdone: yes mappend; there was a stack overflow question on that recently
14:31:51 <chrisdone> yay for orphans
14:31:52 <Luig1> So I'm back to continue.
14:32:02 <lispy> > EQ > LT
14:32:04 <lambdabot>   Could not find module `Data.LinearMap'
14:32:04 <lambdabot>  Use -v to see a list of the files s...
14:32:17 <lispy> > 1
14:32:17 <mauke> > sortBy (comparing length `mappend` compare) (words "the quick brown fox jumps over the lazy dog")
14:32:17 <lambdabot>   Could not find module `Data.LinearMap'
14:32:18 <lambdabot>  Use -v to see a list of the files s...
14:32:18 <lambdabot>   Could not find module `Data.LinearMap'
14:32:18 <lambdabot>  Use -v to see a list of the files s...
14:32:24 <lispy> Cale: I think I broke it again
14:32:29 <mauke> :-|
14:32:30 <lispy> Cale: you're welcome :)
14:32:35 * lispy hides
14:34:28 <Cale> > 1
14:34:28 <ocharles> :t comparing length `mappend` compare
14:34:30 <lambdabot> forall a. Ord a => [a] -> [a] -> Ordering
14:34:30 <lambdabot>   Could not find module `Control.Monad.Random'
14:34:30 <lambdabot>  Use -v to see a list of the f...
14:34:41 <ocharles> :t comparing
14:34:42 <lambdabot> forall a b. Ord a => (b -> a) -> b -> b -> Ordering
14:34:50 <djahandarie> > 1
14:34:51 <lambdabot>   Could not find module `Control.Monad.Random'
14:34:51 <lambdabot>  Use -v to see a list of the f...
14:35:12 <Cale> > 1
14:35:12 <lambdabot>   Could not find module `Control.Monad.Random'
14:35:13 <lambdabot>  Use -v to see a list of the f...
14:35:15 <Cale> @undefine
14:35:15 <Cale> > 1
14:35:16 <lambdabot>   Could not find module `Math.OEIS'
14:35:16 <lambdabot>  Use -v to see a list of the files search...
14:36:40 * nand` wonders if this is going to be a GHC upgrade as well
14:37:32 <ocharles> nand`: what is "this"?
14:38:06 <nand`> this lambdabot's GHC being rebuilt
14:38:11 <ocharles> ah
14:40:09 <Cale> > 1
14:40:11 <lambdabot>   Could not find module `Debug.SimpleReflect'
14:40:11 <lambdabot>  Use -v to see a list of the fi...
14:40:33 <Cale> > 1
14:40:35 <lambdabot>   Could not find module `System.Random'
14:40:35 <lambdabot>  Use -v to see a list of the files se...
14:41:02 <Cale> nand`: We're on 7.4 now
14:41:07 <Cale> > 1
14:41:09 <lambdabot>   Could not find module `Data.Number.Symbolic'
14:41:09 <lambdabot>  Use -v to see a list of the f...
14:41:27 <djahandarie> Wouldn't it be a good idea to keep a list of all the cabal packages you need to install after an upgrade?
14:41:40 <Cale> yes, and I probably could have guessed them too
14:41:42 <ocharles> oh wow, that Monoid b => Monoid (a -> b) is new to me, and really handy!
14:41:43 <Cale> but meh
14:41:45 <Cale> lazy
14:41:46 <Cale> > 1
14:41:48 <lambdabot>   Could not find module `Control.Parallel.Strategies'
14:41:48 <lambdabot>  Use -v to see a list o...
14:42:06 <djahandarie> Cale is lazy? :)
14:42:14 <Cale> ocharles: yes, that's a really nice instance
14:43:09 <ocharles> A shame it doesn't combine so well with bool to combine a bunch of predicates with logical and (you'd have to compose All onto each predicate)
14:43:39 <Luig1> Okay, so, what exactly is a list? I guess what I'm really asking is, how is a list different from a tuple?
14:43:47 <Cale> > sortBy (comparing length `mappend` compare) (words "here is a bunch of words to sort by length and then alphabetically")
14:43:49 <lambdabot>   ["a","by","is","of","to","and","here","sort","then","bunch","words","length...
14:43:50 <Luig1> Or is this the wrong place to ask?
14:44:41 <fmap> > [1,2,3] ^. _head
14:44:42 <lambdabot>   Not in scope: `_head'
14:44:43 <lambdabot>  Perhaps you meant one of these:
14:44:43 <lambdabot>    `head' (imported ...
14:44:51 <Cale> Luig1: A list of type [t] is either the empty list [], or it is a nonempty list consisting of a first element x of type t and a tail which is a list of type [t], written (x:xs)
14:44:56 <startling> Luig1: data List a = a : List a | []
14:44:59 <geekosaur> a tuple (a,b,c) is an anoymous ADT no different from "data MyTuple = MyTuple a b c" aside from not needing predeclaration.  a list is a singly linked list, each element of which has a head and a tail
14:45:03 <ocharles> > getAll (((All . (> 5)) `mappend` (All . (> 10))) 20)
14:45:05 <lambdabot>   True
14:45:05 <ocharles> meh that looks awful
14:45:06 <fmap> > over fst succ (1,1)
14:45:07 <lambdabot>   Not in scope: `over'
14:45:12 <fmap> :[
14:45:23 <Cale> Luig1: A pair of type (s,t) is a value (x,y) where x has type s and y has type t
14:45:50 <Cale> Luig1: Tuples have fixed size, and their elements are of specified and possibly distinct types.
14:46:41 <geekosaur> you can define functions on certain tuples but they don't generalize very well:  there is, for example, "snd" which operates on 2-tuples but will fail to typecheck if used with a 3-tuple
14:46:46 <Cale> Luig1: Lists come in many lengths (even infinite) which are not specified by their type, and all the elements have the same type.
14:47:41 <Luig1> Okay, so what I'm getting from this is that lists are lists of elements with the same type, and tuples can have the same type?
14:47:50 <Cale> (but almost nobody ever uses tuples larger than pairs, because at that point you're usually better off defining a proper separate data type to express what you mean)
14:48:03 <Luig1> distinct types*
14:48:09 <Cale> that's right
14:48:19 <Cale> and if I know that a list has type [Integer] say
14:48:24 <Cale> I don't know how long the list is
14:48:27 <Luig1> I see what you mean
14:48:37 <Cale> While if I have a value of type (Integer, Integer), that is exactly a pair
14:48:44 <clahey> It could even be an empty list.
14:48:52 <Cale> (or an infinite list)
14:49:05 <Cale> > let xs :: [Integer]; xs = 1 : xs in xs
14:49:06 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:49:14 <clahey> Cale: You'd already mentioned that.
14:49:14 <acowley> I think http://hackage.haskell.org/packages/archive/lens/3.1/doc/html/Control-Lens-Tuple.html actually makes tuples pretty useful as a representation that you want some flexibility in
14:50:09 <Cale> Luig1: Lists are the data representation of loops. Just as a loop either may never occur (say, because its precondition is unsatisfied), or will consist of a single iteration followed by another loop, a list is either empty, or consists of a single element followed by another list.
14:50:21 <clahey> acowley: I didn't realize that _1 was a type class variable.  Weird!
14:50:21 <Cale> And just as you can have infinite loops, you can have infinite lists :)
14:50:24 <ocharles> 9 dimensional tuples ought to be enough for anyone
14:50:44 <acowley> clahey: It's great since edward's done all the typing already!
14:51:01 <clahey> acowley: Seems like something that TH would be good for.
14:51:02 <Cale> ocharles: b...but string theory :(
14:51:05 <acowley> There is no 10th dimension. That's a myth.
14:51:06 <startling> clahey: how else would two-tuples, three-tuples, etc have it?
14:51:46 <acowley> clahey: It seems like a programmer honeypot actually. You think, "I know, I'll automate this instead of writing it manually!" and then spend longer automating it than writing it would take.
14:51:59 <mcstar> do you guys think, it will be a problem for me to relax a yesod test project's dependencies?
14:52:21 <mcstar> like, it needs bytestring <0.10
14:52:37 <Cale> mcstar: go for it and see what happens
14:52:39 <clahey> acowley: Yes, but have more fun doing it.
14:52:41 <Luig1> acowley, probably more enjoyable that way
14:53:00 <acowley> #haskell: where joy and fun trump productivity
14:53:02 <johnw> ocharles: buckaroo bonzai only needed 8
14:53:18 <Cale> I hate the names of _1 etc.
14:53:21 <clahey> acowley: Also, when someone needs a tenth one, you can provide them with a function.
14:53:27 <Cale> Well, really I just hate underscores in general
14:53:35 <clahey> Cale: I don't particularly disagree.  What should they be?
14:53:38 <acowley> No, we berate the person who asks for _10
14:53:40 <johnw> C_a_l_e!
14:53:45 <Cale> I would have gone with p1, p2, etc.
14:53:50 <startling> _ should be a function that takes an Int.
14:53:52 <clahey> Cale: phead?
14:54:02 <Cale> p for projection
14:54:06 <acowley> $(_ 2)
14:54:07 <mcstar> yay! my first yesod project built
14:54:23 <johnw> Cale: i think I agree with you on _1 vs. p1
14:54:36 <acowley> Cale: the nice thing about the underscore is that it generalizes to the linear package where we have _x, _y, etc.
14:54:49 <Cale> px and py aren't good enough for you?
14:54:51 <acowley> no
14:54:55 <mcstar> also, im not jewish, idk if it is appropriate for me to use it...
14:55:09 <rwbarton> consult the LICENSE file
14:55:20 <mcstar> k
14:55:23 <shergill> mcstar: one can always convert
14:55:38 <acowley> Cale: I actually don't really know. Seems like a bike shed problem.
14:55:41 <merijn> shergill: Not to Judaism, it's notoriously hard
14:55:50 <Cale> acowley: Well, yeah, it is
14:55:56 <merijn> shergill: Jews are to cool for you and you're not allowed to join :p
14:56:02 <shergill> lol
14:56:07 <Cale> acowley: If it were easier to type, I would say π1, π2, πx, πy
14:56:10 <acowley> I was just relieved when he agreed to _x instead of just "x"
14:56:15 <merijn> shergill: (Seriously, it's *really* hard)
14:56:25 <mcstar> do you know clisp? it comes up with the ascii art of a menora by default
14:56:30 <mcstar> fortunately you can turn it off
14:56:37 <johnw> Cale: π is recognized to mean "projection"?
14:56:40 <Cale> yeah
14:56:40 <clahey> Cale: One think in particular that's confusing about it is that, at least in the pong example, he uses _ballPos as the function taking a Pong and returning a Point and makeLenses generates ballPos which is a Lens into a Pong.
14:56:48 <clahey> Cale: One thing*
14:56:55 <clahey> Cale: In one case, the _ means this is a lens.
14:56:58 <johnw> maybe it could be a synonym then
14:57:00 <Cale> johnw: and ι is similarly used for "inclusion" in the other direction
14:57:01 <clahey> In the other, it means this isn't a lens.
14:57:18 <Cale> clahey: yeah
14:57:21 <byorgey> πrojection
14:57:34 <typoclass> pirojection?
14:57:45 <Ralith> it's like projection, except on fire.
14:57:56 <clahey> Cale: I also want .~ to be ~. so that you can have ~.~ and put a setter on the left and a getter on the right.
14:58:13 <rwbarton> type Producer p b m r = () -> p () () () b m r -- delicious
14:58:30 <byorgey> that would be πυρo-jection
14:58:45 <byorgey> not to be confused with a pyromorphism
14:58:58 <Cale> Our infix operators are looking more like emoticons all the time ~.~
14:59:05 <clahey> Cale: But really I'm more concerned with the monadic version which would get really weird.
14:59:09 <acowley> I always read it as ιnjection
14:59:23 <clahey> I'd never heard fish for >=> before I read it today in the typeclassopedia.
14:59:42 <acowley> How often do you hear people trying to verbalize >=>?
14:59:47 <Cale> rwbarton: What is that from?
15:00:01 <acowley> new pipes
15:01:40 <edwardk> clahey: you can change out the _ prefix convention used by makeLenses. i adopted it because it is what the other lens libraries used
15:01:50 <clahey> edwardk: That seems reasonable.
15:02:24 <edwardk> makeLenses can be told to use a different convention though
15:02:29 <clahey> Right, I figured.
15:02:39 <clahey> Use makeLensesWith?
15:02:50 <clahey> edwardk: I think I might kinda understand lenses, sorta.
15:03:05 <clahey> edwardk: I don't understand the actual types, but if I look at the fake types, I sorta get it.
15:03:14 <edwardk> makeLensesWith $ defaultLensRules % lensField .~ \a -> …   or something like that
15:03:31 <edwardk> yeah, that was why i felt the need to put all the fake types in ;)
15:03:33 <ocharles> needs more >.<
15:03:48 <nand`> Cale: like ^+^ ?
15:03:53 <edwardk> hrmm. i don't have a >.< operator yet ;)
15:04:07 <nand`> <<>~ is the best infix operator either way
15:04:11 <nand`> I call it ‘rat’
15:04:19 <startling> <^(__)~
15:04:24 <edwardk> yep
15:04:47 <clahey> edwardk: So, I've realized that an =+= would require lift to be useful.
15:04:56 <edwardk> probably
15:04:58 <Luig1> Oh cool
15:05:04 <Luig1> I figured out how map works
15:05:10 <clahey> edwardk: Since you're not going to be just moving data from one variable to another.
15:05:46 <edwardk> because naively using use would have bad effects if the thing you are reading from is a traversal or overlapped, etc.
15:06:23 <clahey> So you encourage x <- use _x ?
15:06:29 <clahey> Or whatever names you want?
15:06:55 <edwardk> yeah, read with use, or just get the whole state with get and access relative to it using ^.
15:07:02 <nand`> I use ‘x <- use foo’ often when doing State/lens stuff
15:07:30 <nand`> not much different from x <- gets foo
15:07:33 <nand`> or whatever
15:07:42 <edwardk> old <- get; y += old^.dy
15:08:16 <edwardk> that way you can 'get' once, and then do a lot of updates with it as metadata
15:08:24 <clahey> ^. is view?
15:08:28 <edwardk> yep
15:08:33 <edwardk> flipped i think
15:08:36 <acowley> edwardk: If I have a newtype, is there something in lens that lets me use the isomorphism to apply functions on the wrapped type?
15:09:05 <edwardk> acowley: you can use makeIso to make the embedding/projection from the iso, and then use under or over to work with it either way
15:09:19 <acowley> err, I was too vague there. I meant binary functions in particular
15:09:20 <nand`> I still want;  x <~ y  for use y >>= assign x -- or whatever
15:09:21 <nand`> or do we have that?
15:09:21 <nand`> I always forget
15:09:32 <edwardk> over is 'map', under is the version for the other direction of the iso
15:09:41 <clahey> nand`: What is assign?  Is that state?
15:09:51 <clahey> No, it can't be.  State only has one part.
15:09:51 <edwardk> x <~ use y
15:10:05 <nand`> edwardk: oh, yeah; that
15:10:08 <nand`> works too
15:10:12 <clahey> What is <~?
15:10:18 <Luig1> So are strings just implemented as lists of chars, then?
15:10:31 <nand`> stateful assign from action
15:10:33 <nand`> by the looks of it
15:10:37 <edwardk> <~ takes a setter to assign to and a monadic action, runs the action, then assigns it to the setter
15:10:39 <bitonic> Luig1: String is [Char], yes.
15:10:39 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
15:10:58 <clahey> edwardk: And returns a monadic action.
15:11:13 <edwardk> l <~ mx = do x <- use mx; l .= x
15:11:28 <nand`> Luig1: String is [Char] yeah
15:11:30 <clahey> l <~ mx = use mx >>= (l .=)
15:11:32 <clahey> ?
15:11:33 <nand`> Luig1: but depending on the application you might want other representations
15:11:33 <nand`> it's not uncommon to use Text for example, since it's more efficient to store
15:11:48 <nand`> edwardk: without the use, surely
15:11:51 <edwardk> l <~ mx = use mx >>= assign l
15:11:58 <edwardk> nand`: without the use, correct
15:12:02 <edwardk> mx >>= assign l
15:12:06 <clahey> I was confused about the use.
15:12:12 <edwardk> my mistake
15:12:13 <`Jake`> Is there any library function for a cartesian product for an arbitrary amount of lists? because I just wrote one and it took me surprisingly long...
15:12:16 <edwardk> i wrote it a long time ago =)
15:12:41 <rwbarton> > sequence ["abc","123"]
15:12:42 <lambdabot>   ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
15:12:53 <`Jake`> ok, cool
15:13:01 <`Jake`> thanks
15:13:50 <clahey> I love that you accidentally reproduced what nand`  asked for.  :)
15:13:53 <clahey> Oh, I have to run.
15:14:04 <clahey> It was a pleasure as always.  See you all later.
15:14:08 <ramses_> :t sequence
15:14:09 <lambdabot> forall (m :: * -> *) a. Monad m => [m a] -> m [a]
15:15:22 <stelleg> :k Monad
15:15:24 <lambdabot> (* -> *) -> Constraint
15:16:33 <johnw> I've never seen that "-> Constraint" before.  Didn't realize it was part of the kind
15:16:52 <stelleg> mean me neither
15:16:54 * nand` feels that wasn't an accident
15:17:00 <nand`> oh
15:17:04 <nand`> I misunderstood
15:17:44 <edwardk> johnw: its a relatively new addition to the kind system
15:17:51 <johnw> ah, ok
15:17:55 <nand`> 7.4, no?
15:18:40 <edwardk> hrmm, so now that lambdabot is on 7.4 when does it get lens? =)
15:18:49 <stelleg> edwardk: are all typeclasses classes of <something> -> Constraint?
15:18:56 <edwardk> stelleg: yes
15:19:00 <edwardk> :k Eq
15:19:01 <lambdabot> * -> Constraint
15:19:05 <stelleg> edwardk: cool thanks
15:19:09 <johnw> i'm using Lens on a 7.4-built lambdabot and it works just dandy
15:19:27 <stelleg> johnw: Lens?
15:19:29 <edwardk> i'm mostly just prodding cale to add it ;)
15:19:34 <edwardk> @hackage lens
15:19:34 <lambdabot> http://hackage.haskell.org/package/lens
15:19:38 <johnw> Control.Lens, the One Library To Rule Them All
15:19:40 <edwardk> stelleg: a recent package of mine
15:19:58 <`Jake`> Well, at least I've implemented my cartesian product function in the same way ghc does
15:20:01 <stelleg> edwardk: cool, I'll check it out
15:20:01 <nand`> aw, no such thing as a parameterless type class
15:20:01 <johnw> in fact, I think I will reimplement myself as a lens; better composition that way
15:20:11 <edwardk> nand`: sadly
15:20:34 * nand` will reimplement himself as a comonad
15:20:42 * edwardk already did.
15:20:47 <nand`> I have no idea what would happen, but it'll be fun
15:20:54 <stelleg> haha
15:21:01 * nand` will be easy to dismantle, I guess
15:21:04 <nand`> he guesses*
15:21:07 <nand`> screw this third person stuff
15:21:15 <johnw> edwardk: if I extract you, what do I get??
15:21:21 <nand`> johnw: Paper
15:21:32 <nand`> that's an actual type. Probably
15:21:33 <edwardk> johnw: it'll be messy and probably nsfw.
15:21:35 <johnw> generally the stuff I put in me cannot be retrieved, so I'm most certainly monadic
15:21:46 <nand`> programmer :: Idea -> ([Paper], Maybe Result)
15:21:51 <edwardk> extend is similarly self-explanatory
15:22:11 <nand`> add an IO for IRC
15:22:12 <johnw> edwardk: well, it does tell us that you're homomorphic
15:22:35 <zhulikas> Either Paper Result
15:22:49 * zhulikas hides
15:22:51 <alpounet> edwardk is probably a pretty damn huge and deep monad transformers stack
15:22:58 <nand`> type Result = Paper
15:23:16 <zhulikas> type Paper = Result
15:23:18 <edwardk> alpounet: just keep lifting. ;)
15:23:29 <zhulikas> hey, what would happen?
15:23:33 <nand`> edwardk is a recursive automaton; he got set off with some primal idea and every library he builds is just some dependency of that that he had to recurse into to fulfill
15:23:33 <zhulikas> does compiler allow that?
15:23:40 <nand`> zhulikas: no
15:23:44 <zhulikas> great
15:23:55 <nand`> zhulikas: cyclic type synonyms error at compile time
15:24:04 <`Jake`> It's interesting that they wrote stuff like "sequence_ ms = foldr (>>) (return ()) ms" for ghc instead of "sequence_ = foldr (>>) (return ())"
15:24:08 <zhulikas> love the strictness
15:24:44 <nand`> `Jake`: might be an implementation detail; where the semantics are the same but the compiler does different sorts of transformations on it during optimization
15:24:51 <nand`> I don't know an awful lot about GHC's innards
15:25:03 <`Jake`> sounds interesting
15:25:04 <nand`> but that's a likely implementation for a lot of weird “this seems entirely unnecessary” stuff
15:25:10 <nand`> a likely explanation*
15:25:35 <johnw> nand`: I remember reading something not long ago that said something very similar
15:25:49 <johnw> something about pointfree definitions having slightly different semantics under some conditions
15:25:57 <nand`> the only case I know of where you have to eta expand is when dealing with rank 2 types and stuff
15:26:01 <`Jake`> There seems to be quite a bit of inconsistency in general about coding style in ghc, so it might just be a case of that
15:26:07 <nand`> but sequence_ is rank 1
15:26:46 <nand`> that or for the sake of clarity; though I don't know a lot of people who would get confused by eta reduction, and those probably aren't best off reading GHC's innards before some introduction that explains eta reduction
15:27:08 <johnw> edwardk: is there an "unsequence" for Comonad, W [a] -> [W a]?
15:27:18 <edwardk> yes
15:27:24 <edwardk> @hackage distributive
15:27:24 <lambdabot> http://hackage.haskell.org/package/distributive
15:27:33 <edwardk> http://hackage.haskell.org/packages/archive/distributive/0.2.2/doc/html/Data-Distributive.html
15:27:37 <johnw> very cool
15:27:44 <edwardk> it never needs the full comonad though, just functor, for technical reasons
15:27:45 <acowley> It affects rewrite rules, too.
15:28:35 <johnw> did you write all these libraries while you were studying CT, or did all of it come after?
15:28:48 <edwardk> i think i wrote this one later when i needed it
15:28:51 <thoughtpolice> yeah, pointwise/pointfree does have some effect on the inliner behavior, which will affect how/where RULES fire
15:29:36 <johnw> edwardk: someday I would love for you to write down a list of all your CT libraries and what state of freshness they are in; I know some of them are deprecated, but I'm never sure which
15:29:50 <edwardk> @hackage category-extras
15:29:51 <lambdabot> http://hackage.haskell.org/package/category-extras
15:30:11 <edwardk> dmwit put a list of at least what was broken out of category-extras in a big dot-generated gif at the top of that
15:30:19 <johnw> nice!
15:30:42 <johnw> is kan-extensions still non-deprecated?
15:30:43 <edwardk> that provides a solid core at least. there are a lot more
15:30:47 <`Jake`> Looks like the basis for zygohistomorphic prepromorphisms.
15:30:51 <edwardk> i still use kan-extensions regularly
15:31:10 <edwardk> `Jake`: it was
15:31:26 <johnw> another useful thing would be an edwardk meta package in Cabal, so that I can get all your stuff down in one go and keep it updated...
15:31:30 <edwardk> http://hackage.haskell.org/packages/archive/recursion-schemes/3.0/doc/html/Data-Functor-Foldable.html#v:zygoHistoPrepro
15:32:00 <`Jake`> Oh, there it is.
15:32:33 <johnw> edwardk: category-extras fails to build on 7.6.1, btw
15:32:33 <`Jake`> A corrected version? Does that mean the version in the wiki is incorrect?
15:32:33 <edwardk> in category-extras i generalized the standard recursion schemes to make the distributive laws composable. this led to the existence of zygohistomorphic prepromorphisms because you could merge the properties of zygomorphisms, histomorphisms, and prepromorphisms into one recursion scheme
15:32:44 <johnw> src/Control/Morphism/Span.hs:20:14: Unexpected type `~>' where type variable expected
15:33:00 <edwardk> johnw: as it should. category-extras is no longer maintained, the 1.0 package just exists to point people to where things got scattered
15:33:10 <johnw> oh, duh
15:33:12 <johnw> n/m
15:33:12 <`Jake`> edwardk: Has anyone ever used that in practice?
15:33:27 <johnw> but isn't data-lens now deprecated?
15:33:36 <edwardk> `Jake`: no. i made a joke about it in channel and someone made a haskell.org page
15:33:42 <edwardk> data-lens still has users
15:33:52 <edwardk> there are some cases where its more convenient than lens
15:33:55 <`Jake`> edwardk: ok, i see. I like this community.
15:34:09 <johnw> what I mean is, data-lens is no longer the new hotness
15:34:12 <nand`> I think the only use for it is trying to figure out a use for it
15:34:15 <edwardk> johnw: exactly
15:34:15 <johnw> I want a list of the edwarkd hotness!
15:34:20 <Twey> One day I hope to be cool enough to use a zygohistomorphic prepromorphism in real code.
15:34:29 <Twey> It shall be a proud day.
15:35:12 <edwardk> i understand all of the parts of it. i just haven't come up with a usecase. you get semimutual recursion from zygo, you get access to your history from histo, and prepro lets you mix in a natural transformation for each layer
15:35:17 <edwardk> its really not _that_ complicated
15:35:31 <edwardk> zygoHistoPrepro :: (Unfoldable t, Foldable t) => (Base t b -> b) -> (forall c. Base t c -> Base t c) -> (Base t (EnvT b (Cofree (Base t)) a) -> a) -> t -> a
15:35:42 <mauke> I have no idea what any of those are
15:36:06 <johnw> edwardk: the day edwardk says something *is* complicated, I shall run away from it in abject fear
15:36:08 <Twey> edwardk: It's not that complicated, but finding a non-contrived use-case is a challenge :þ
15:36:13 * Twey laughs.
15:36:19 <edwardk> mauke: ultimately i don't think the greek/latin-fetishistic names are that useful.
15:36:39 <edwardk> they mostly serve to make it sound official or something
15:38:01 <edwardk> i tend to the 'fold, unfold, refold' naming convention over 'cata, ana, hylo' and the more complicated greeks are just silly.
15:38:36 <Ralith> but you didn't rename zygoHistoPrepro?
15:38:45 <edwardk> cata, ana, hylo, and maybe para are useful names, they encapsulate interesting ideas, but even by the time you've hit hylo you are turing complete, so there isn't much use to them
15:39:33 <edwardk> i kept the faux-greek/latin convention in recursion-schemes, because they have the various distributive laws and you need _some_ name for the various choices of monad/comonad you parameterize your cata/ana morphisms on
15:40:27 <edwardk> but I actively discouraging programming with complex recursion schemes, especially ones built on hylo
15:41:09 <edwardk> i think the interesting part is spotting the pattern, but you don't derive much utility from using the pattern. the laws you get for hylo fusion kinda suck
15:41:48 <edwardk> the cata-fusion laws are a little more useful
15:41:56 <edwardk> http://comonad.com/haskell/catamorphisms.html -- see cata-fusion in laws
15:47:31 <Saizan> fold felt list-specific a while ago, but i guess that's no more the case now
16:02:44 <nand`> isn't the defining member of Foldable toList?
16:04:19 <gertc> ghcmod M-/ "Completes a name of local symbol" what is a local symbol?
16:06:40 <Saizan> nand`: i don't mean that fold :)
16:07:23 <parcs`> gertc: a sequence of non-whitespace characters pretty much
16:07:41 <edwardk> nand`: toList is actually, amusingly not a member of Foldable, but it is more or less its defining property
16:07:53 <nand`> edwardk: heh
16:08:00 <nand`> I figured I'd be able to provide toList and have everything else default
16:08:24 <nand`> what do I have to actually provide? Monoid m => f m -> m or something?
16:08:32 <edwardk> well, you can do that, and then just push that into its foldr, by passing the args to the actual list foldr over that list
16:08:37 <gertc> ok thx
16:08:58 <edwardk> foldMap :: Monoid m => (a -> m) -> f a -> m  or foldr :: (a -> r -> r) -> a -> f a -> r
16:09:07 <edwardk> either is a complete definition
16:09:31 <gertc> \q
16:10:26 <nand`> (wouldn't it make more sense to have Functor as a superclass and reduce foldMap in terms of that?)
16:11:01 <edwardk> Functor isn't a superclass of Foldable, because many things that are Foldable aren't Functors.
16:11:04 <edwardk> consider Set
16:11:15 <hpaste> NLUL pasted “sort a list” at http://hpaste.org/77134
16:12:12 <NLUL> I opened a file which is a line of 5k words
16:12:21 <NLUL> that I want to sort
16:12:37 <fliip> What does the following definition mean? foo :: Cint a -> Cint b?
16:13:13 <nand`> that's not a definition
16:13:27 <rwbarton> foo is a function that takes an argument of type Cint a and produces a result of type Cint b, for any a and b
16:13:37 <rwbarton> without context I don't know what this "Cint" is
16:13:52 <fliip> Ah I see. Ok thanks.
16:13:53 <Iceland_jack> C integer?
16:13:57 <rwbarton> and yes, it is a type declaration rather than a definition
16:13:59 <mauke> interpreter maybe
16:14:12 <fliip> Church Numerals... Ugh
16:14:24 <rwbarton> slightly different from C integers :)
16:15:43 <nand`> NLUL: the signature for line 12 does not match the function
16:16:11 <_alx86_> hello i m writing interpreter of simple C-like language. I m stuck with expression interpretation, where i have pass expression to evaluate function. Plz, take a look at my code: http://pastebin.com/EB1KYY4L
16:16:15 <mauke> The paste EB1KYY4L has been copied to http://hpaste.org/77136
16:16:34 <nand`> “simple C-like” heh
16:16:58 <mauke> fortunately it's not C-like at all :-)
16:17:03 <_alx86_> nand`: i mean small imperative lang
16:17:14 <_alx86_> *meant
16:17:19 <mauke> you want structural recursion
16:17:58 <kirindave> I'm back for more free monad tutorial begging. :)
16:18:01 <kirindave> Specifically
16:18:11 <kirindave> type Printer a = WriterT [String] (Free StatementFunctor) a
16:18:15 <nand`> “e.g. 1+2 returns 2.”
16:18:18 <kirindave> How the heck do I run it?
16:18:19 <nand`> that doesn't seem very intuitive to me
16:18:33 <_alx86_> nand`: sorry
16:18:38 <ivanm> kirindave: there's probably a function called something like runWriter
16:18:41 <typoclass> kirindave: many monads have a "run" function, "runWriterT" or similar
16:18:46 <kirindave> Okay so
16:18:51 <nand`> kirindave: first step would be runWriterT
16:18:52 <kirindave> I am aware of this
16:19:00 <_alx86_> kirindave: you won't run this, it is just a prt of interpreter, i have omitted parser
16:19:16 <nand`> then.. uh, pattern match on the Free, I guess
16:19:17 <kirindave> But if I run RunWriterT I get the free monad back
16:19:29 <rwbarton> yes
16:19:29 <kirindave> And if I runProgram again, I get writer back
16:19:36 <ivanm> heh
16:19:40 <rwbarton> hmm?
16:19:41 <typoclass> _alx86_: which part of your paste is confusing you?
16:19:52 <Saizan> _alx86_: instead of matching on (ICon exp1) and then rebuilding it a sargument to eval just use a variable there, that clause will still work but be more general
16:19:52 <kirindave> Because my interpreter pretty much as ot be (Free StatementFunctor) a -> Printer a
16:19:58 <kirindave> right?
16:20:04 <kirindave> So what I am asking is
16:20:06 <kirindave> I guess
16:20:08 <rwbarton> that is not really an interpreter
16:20:14 <kirindave> When I match (Free MyTerminalSymbol)
16:20:23 <kirindave> What do I say?
16:20:45 <_alx86_> typoclass: eval function. line 22. where i want to compute (Add expresion expresion) but code doesn't work
16:21:15 <Saizan> _alx86_: same for (ICon exp2) of course
16:21:16 <kirindave> rwbarton: So what _should_ the type of the interpreter be?
16:21:27 <rwbarton> up to you
16:21:32 <kirindave> It seems to me like if I want to use the Writer as I interpret, it has to be that?
16:21:33 <rwbarton> but it should be something useful
16:21:36 <rwbarton> what is the goal
16:21:50 <kirindave> rwbarton: Ultimately using stateT and writerT as I interpret statements from my langauge
16:22:01 <kirindave> But, for now I'd be happy with just writerT to make sure I get it.
16:22:11 <_alx86_> Saizan: if i try : eval (Add (IntExp exp1) (IntExp  exp2)) env = eval exp1 env + eval exp2  env if fail to work of course.
16:22:25 <nand`> kirindave: by the looks of it, you'll be recursing until you eventually hit a Pure
16:22:27 <nand`> but I have no idea what your type or function is doing, so all bets are off
16:22:30 <Saizan> _alx86_: IntExp is not a data constructor
16:22:35 <lispy> Cale++ -- thanks for getting lambdabot working again!
16:22:39 <kirindave> runProgram (Pure r) = return r
16:22:47 <rwbarton> kirindave: was there a paste about this StatementFunctor i missed?
16:22:49 <mauke> > sortBy (comparing length `mappend` compare) (words "the quick brown fox jumps over the lazy dog")
16:22:50 <lambdabot>   ["dog","fox","the","the","lazy","over","brown","jumps","quick"]
16:23:01 <nand`> usually you wouldn't have something like WriterT w (Free f) a but something like Free f a -> WriterT w r -- where r is some result type, possibly a
16:23:10 <kirindave> I'll maek a paste.
16:23:25 <nand`> > mempty :: Ordering
16:23:26 <lambdabot>   EQ
16:23:27 <kirindave> https://gist.github.com/303273dbe7f19a9131d1
16:23:33 <_alx86_> Saizan: yes, but how can i evaluate IntExp? i m stuck at this point
16:23:34 <kirindave> rwbarton & nand` ^^
16:23:34 <Saizan> _alx86_: "eval (Add exp1 exp2) env = eval exp1 env + eval exp2 env" -- that's what you write if you want to recurse on the direct subexpressions of Add
16:23:51 <kirindave> I pulled out most of the interesting stuff. Sorry.
16:24:02 <_alx86_> Saizan: gonna try now
16:24:17 <nand`> “Centocents” O.o
16:24:23 <kirindave> nand`: The lifestyle I lead.
16:24:44 <hpc> nand`: that sounds like some strange CentOS-specific utility
16:25:12 <rwbarton> kirindave: so you want to interpret this free monad into something that actually does something, right
16:25:16 <kirindave> Yes.
16:25:25 <rwbarton> can you describe that something
16:25:27 <kirindave> Infinite recurses are a matter for politics, not my program.
16:25:35 <nand`> kirindave: by the looks of it, you don't want WriterT .. (Free Statement) but just Writer [String] a
16:26:06 <rwbarton> hmm yes, that would be one trivial sort of interpreter
16:26:06 <kirindave> nand`: Oh so I don't have to nest it? I just build the writer actions?
16:26:17 <kirindave> So the interpreter would say, "Build a big writer action."
16:26:21 <nand`> yeah, that's usually the goal with free monad based languages
16:26:25 <nand`> interpret them into some other context
16:26:26 <kirindave> Okay
16:26:31 <rwbarton> in reality you are probably going to want some more complicated thing than Writer
16:26:37 <nand`> the code should work as-is, no?
16:26:37 <rwbarton> State for your accounts or whatever
16:26:38 <kirindave> StateT + WriterT, actually.
16:26:47 <kirindave> rwbarton: I pulled all that.
16:26:49 <kirindave> Sorry.
16:26:57 <_alx86_> Saizan: i have tried:  eval (Add (ICon 1) (ICon 2))  throws me an error:  No instance for (Show (Env -> Integer)) arising from a use of `print'
16:27:18 <rwbarton> okay, well then the type of runProgram should eventually look more like StatementFree a -> WriterT [String] (StateT ???) a
16:27:29 <rwbarton> er, plus some other base monad or minus 'T"
16:27:42 <nand`> like, if you just change the signature
16:27:44 <nand`> you don't appear to be using the (Free Statement) at all; it's just auto-lifted from ‘tell’ and ‘return’
16:27:44 <nand`> what rwbarton said
16:27:55 <Saizan> _alx86_: you've to give it an env to produce an Integer
16:27:57 <mauke> _alx86_: so it's working?
16:28:19 <nand`> there's also no definition of StatementR
16:28:20 <nand`> but you use it at the bottom
16:28:36 <rwbarton> the interpretation is where you define what the constructors of your StatementF "mean", you want to define that meaning in terms of an action in some other monad (for example)
16:30:06 <kirindave> So
16:30:30 <_alx86_> Saizan: oh, of course. cheers a lot. yes it works now mauke
16:31:01 <kirindave> :\
16:31:02 <kirindave> Hmm
16:31:36 <Joebb> what's the difference between hspec and hunit? when would i use one or the other?
16:31:58 <ludamad> My first non-trivial haskell program ! http://www.fpaste.org/Reno/
16:32:13 <ludamad> would appreciate tips especially re: conciseness
16:32:25 <ludamad> (its a brainfuck interpreter if not obvious)
16:33:46 <nand`> lots of questions about language interpreters today :)
16:34:04 <hpc> bfevalImpl could be made into at least 3 smaller functions, imo
16:34:20 <hpc> dunno how i would go about doing it though, it's too late for thinking ;)
16:34:30 <kirindave> Still having issues
16:34:31 <kirindave> https://gist.github.com/303273dbe7f19a9131d1
16:34:34 <koala_man> you could save about 20% of code if you don't prefix everything with bf
16:34:36 <citizen93> hello, I have a small question regarding Generic Programming and matching a Nothing of a datatype like data Expr = WORKS | Nothing | Val Int | Var String | Add Expr Expr using generic deriving, This should be the U1 case I think, but I can't match the function f :: Expr -> Expr, which is f WORKS = Nothing, f Nothing = WORKS, the other cases it just returns the exact same thing. My class looks
16:34:37 <citizen93> like: class Something f a where doSomething :: ( a -> a) -> f b -> f b
16:34:37 * nand` wonders if when constructing a DSL for brainfuck the [ ] pairings could be cycled back into the graph itself, so the interpreter wouldn't have to keep track of them at all
16:34:50 <kirindave> I guess what I don't get is the relationship between StatementFree a and StatementW
16:34:53 <kirindave> I guess I should fix the type to ()
16:34:58 <qwerj> Is there a better way to do this? map (\x -> fst x * snd x) $ zip [1,2,3] [4,5,6]
16:35:06 <ludamad> koala_man: that isnt the kind of conciseness im interested in
16:35:08 <rwbarton> kirindave: runWriterT is not runWriter
16:35:15 <rwbarton> or i guess maybe in new mtl it is
16:35:25 <rwbarton> but mostly not
16:35:33 <kirindave> Yeah well it doesn't change the error.
16:35:37 <kirindave> Good point tho. Corrected
16:35:38 <citizen93> my instance looks like instance Something f a where doSomething f U1 = f U1 (at least I want to apply the f to U1)
16:35:51 <nand`> should still work, but be in Identity; no? :)
16:35:51 <rwbarton> what is "setBudget"
16:35:51 <carter> hey all: a ucb frosh has emailed me about summer haskell internships, and i want to give a reply with good advice
16:35:52 <typoclass> qwerj: you could use zipWith, it's essentially a map function that walks over two lists simultaneously
16:35:54 <citizen93> should I match it on the M1 level?
16:36:06 <rwbarton> oh i can't read
16:36:10 <citizen93> or doesn't that make sense?
16:36:11 <rwbarton> (definitions in ghci, what??)
16:36:11 <typoclass> > zipWith (*) [1,2,3] [4,5,6]
16:36:12 <lambdabot>   [4,10,18]
16:36:19 <qwerj> typoclass: Thx
16:36:21 <kirindave> rwbarton: Sorry
16:36:25 <rwbarton> Pure End should be Pure () or something
16:36:28 <rwbarton> perhaps?
16:36:43 <rwbarton> i don't think that is the problem either
16:37:07 <nand`> (mind that Writer [String] () is essentially [String] so if you don't need the result at the end you can just skip the Writer and return the log directly)
16:37:15 <rwbarton> can you :t setBudget for me
16:37:20 <kirindave> I think my problem
16:37:34 <kirindave> Centocents -> Centocents -> Free ((->) next) (StatementF next)
16:37:41 <kirindave> My problem is runProgram :: StatementFree a -> StatementW a
16:37:41 <rwbarton> well that's obviously wrong :)
16:37:52 <nand`> how is setBudget defined?
16:38:02 <startling> so I've got these trees and I'm working on some rudimentary error-handling. I want to be able to raise errors like "expected a leaf node at [x]" and have te other handlers wrap this in their path. what's the best way to do this?
16:38:03 <rwbarton> it's in the paste in invisible font
16:38:14 <typoclass> ludamad: hello, congratulations on the program :) i think you could combine bfeval and main into something like "fmap (bfevalImpl . bfStartState) getContents"
16:38:20 <nand`> oh
16:38:25 <rwbarton> see what i mean :)
16:38:53 <rwbarton> maybe it's supposed to be liftF $ SetBudge a b (return ())
16:38:53 <kirindave> My gist is updated.
16:39:07 <nand`> at the bottom
16:39:08 <ludamad> typoclass: cool, I just learned about fmap
16:39:09 <nand`> kirindave: eta expand once more before the liftF
16:39:09 <nand`> actually, simpler, just change $ to .
16:39:11 <nand`> liftF :: Functor f => f a -> Free f a
16:39:39 <nand`> liftF $ setBudget a b () would do it, no?
16:39:55 * watwat
16:40:10 <kirindave> Doesn't work
16:40:14 <rwbarton> sounds like it
16:40:23 <rwbarton> i am just guessing randomly for some reason, too lazy to look up liftF
16:40:25 <kirindave> Ah
16:40:29 <kirindave> There we go.
16:40:35 <kirindave> liftF $ SetBudget expect bal ()
16:40:44 <kirindave> Should I ever explicitly be using Pure?
16:40:45 <nand`> yeah
16:40:47 <nand`> uh
16:40:50 <kirindave> end = Pure End
16:40:51 <rwbarton> Pure = return
16:40:56 <rwbarton> right, so no need to
16:41:06 <rwbarton> what is End supposed to be
16:41:09 <rwbarton> you probably don't want it
16:41:23 <ludamad> I suppose I should also encapsulate the index increment, memory update into a function
16:41:26 <nand`> rwbarton: maybe he doesn't, but it could serve a purpose
16:41:32 <rwbarton> it could
16:41:34 <kirindave> hmm
16:41:39 <nand`> Free End >> x = Free End
16:41:40 <nand`> namely that
16:41:45 <nand`> “program terminates here” invariant
16:42:06 <kirindave> That is sort of the idea, yeah
16:42:14 <kirindave> But thanks for helping me get this sorted.
16:42:16 <rwbarton> it's different from return ()
16:42:18 <nand`> but if you don't need that sort of invariant, you can just rely on ‘Pure’ to be the end
16:42:20 <kirindave> I was just missing an argument.
16:42:21 <rwbarton> yeah
16:42:30 <kirindave> Because I misread the tutorial I had which HAS A TYPO. :)
16:42:35 <nand`> hah
16:42:39 <kirindave> Two, actually.
16:42:49 <kirindave> Okay so now I can just build my normal monad stack and make this all work out.
16:42:50 <kirindave> Then
16:42:53 <kirindave> Figuring out parsing.
16:42:54 * nand` likes http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html http://www.haskellforall.com/2012/07/purify-code-using-free-monads.html
16:43:04 <kirindave> But I think I can do that by just making a [StatementF]
16:43:14 <kirindave> Then saying sequence myStatementFArray
16:43:24 <kirindave> err, derp
16:43:26 <kirindave> StatementFree
16:43:52 <nand`> usually you'd use an in-language EDSL for this kind of thing
16:43:59 <nand`> hey maybe you could wrap your free monad on top of ParsecT
16:44:03 * nand` is rambling at this point
16:44:17 <kirindave> yeah well I have non-programmers who will be using this
16:44:24 <kirindave> The EDSL is for me to write fuzz tests.
16:44:31 <kirindave> This is a lab version of a larger algorithm we're developing.
16:44:45 <kirindave> But I want to write an Arbitrary for programs
16:44:50 <kirindave> then have it try and reason about them.
16:45:05 <kirindave> And like say, "Is this budgeting algorithm actually robust in the face of the world of insanity."
16:45:12 <nand`> if you don't need binding then sequence sounds like it should do the trick
16:45:23 <kirindave> It's modeling a language that mutates master state
16:45:28 <kirindave> So yeah, I never use >>=
16:45:31 <nand`> just parse "setBudget 3 4" -> setBudget 3 4 or something
16:45:39 <kirindave> You can see in the comments what i want.
16:45:41 <brainproxy> are monadic functions always 1-ary?
16:46:02 <kirindave> brainproxy: Ha. Tricky.
16:46:08 <nand`> kirindave: write your parser in a logic programming language then run it backwards “find me an algorithm that gets this sort of result”
16:46:20 <kirindave> nand`: Never. ;)
16:46:21 <nand`> bypass the system
16:46:23 <nand`> brainproxy: ‘monadic function’?
16:46:28 <kirindave> Ty very much.
16:46:37 <nand`> oh
16:46:39 <nand`> oh, yes they are
16:46:40 <kirindave> rwbarton & nand`: You guys rule. My thinking is _much_ clearer on this.
16:46:56 <brainproxy> nand`: the function that gets bound to the monadic value
16:47:12 <brainproxy> sorry... I'm coming at this from a non-Haskell background, but figured the haskell folks were the ones to ask
16:47:33 <rwbarton> "m >>= \x -> f x" you mean the "\x -> f x" part?
16:47:43 * hackagebot aws 0.7.5 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.7.5 (AristidBreitkreuz)
16:48:24 <rwbarton> that's the best interpretation of "the function that gets bound to the monadic value" I can come up with
16:49:04 <crdueck> I'm trying to use alter from Data.Lenses. The given example is (somePoint `alter` y) (+1) but i'm getting type errors.
16:49:31 <brainproxy> rwbarton: i think so
16:49:54 <nand`> brainproxy: sorry, got disconnected (I read up on the public logs)
16:49:55 <nand`> brainproxy: usually if you say “monadic function” then I would think monadic not in terms of the haskell Monads but in terms of monadic -> 1-ary; dyadic -> 2-ary, etc.
16:49:57 <nand`> so if it's from a non-Haskell context that might actually be the case
16:49:59 <crdueck> can someone give an example using Data.Lenses.alter?
16:50:28 <brainproxy> nand`: okay
16:50:29 <nand`> > let foo = negate >>= (+) in foo 5
16:50:30 <lambdabot>   0
16:50:39 <nand`> see? not always 1-ary
16:50:58 <typoclass> crdueck: i'm not familiar with Data.Lenses, but i bet the example code would need a record (somePoint) which contains a field named y
16:51:34 * nand` would be thinking ‘y’ would be a lens, not a field name
16:51:39 <nand`> otherwise that's just a getter
16:51:48 <nand`> crdueck: I recommend using ‘lens’ instead
16:52:02 <nand`> it's more up to date, more awesome and you're more likely to get support for it in here
16:52:23 <rwbarton> brainproxy: the idea is the function passed to (>>=) as the second argument accepts "the result" of executing the action passed as the first argument
16:52:38 <crdueck> nand`: okay, i'll check out lens. I have a record for somePoint but it still doesnt work
16:52:55 <ludamad> is there any syntactic sugar for applying a function to a record field (and getting a new record) ?
16:53:27 <c_wraith> ludamad: not really.  that's a large part of the reason why lenses are a big topic.
16:54:24 <typoclass> ludamad: how would you like to pull the "prog" field out of bfstate? if bfevalImpl had 2 arguments, it could look something like this: «bfevalImpl "" bfstate = bfstate» for terminating when the program is done, and «bfevalImpl (instruction:rest) bfstate = ...». you would then do the big «case instruction of ...» that you have, and recursively call «bfevalImpl rest bfstate»
16:55:29 <rwbarton> ludamad, however you could write a helper function to capture that pattern which is repeated many times in bfevalImpl
16:55:48 <ludamad> rwbarton, thats actually what im doing right now :)
16:56:05 * ludamad thinks about typoclass's comment
16:57:09 <ludamad> typoclass, I'm afraid of having the program just be a string (as opposed to ByteString + index) because of the jumps
16:57:39 <nand`> blah, my messages keep not getting sent
16:57:59 <nand`> as I was saying; the closest you can get without lenses would be frob f x = x { field = f (field x) }; but with lenses you could write (field %~ f) and that'd be a function from record to record
16:58:59 <ludamad> Why are they called lenses ?
16:59:26 <ludamad> (important part of me being able to grok things)
16:59:31 <crdueck> nand`: I've imported Control.Lens, but using makeLenses ''Foo gives a "naked expression at top level" error
16:59:41 <nand`> I guess the mnemonic is that they sort of “focus” onto part of a data-structure
16:59:41 <hpc> ludamad: they let you focus on parts of a data structure
16:59:46 <nand`> allowing you to modify that portion of it
16:59:48 <nand`> in isolation
16:59:50 <hpc> like a telescope lens or similar
17:00:06 <nand`> crdueck: {-# LANGUAGE TemplateHaskell #-}
17:00:16 <nand`> if that still doesn't work (old version of GHC?) use $(makeLenses ''Foo)
17:01:08 * nand` often wonders what Haskell would look like if the top level would be treated like a large ‘do block’
17:01:22 <startling> nand`: heh
17:01:39 <nand`> like; imagine a big ‘main = do” in front of the entire file
17:01:53 <startling> it'd be just like ghci, naturally
17:01:53 <hpc> i like to imagine that's what perl6 would be
17:01:59 <nand`> yeah
17:02:10 <nand`> it would be interesting for writing shell-y scripts and stuff
17:02:24 <startling> it'd be neat if there was a shell with Maybe and >>=
17:02:30 <startling> or Either
17:02:36 <rwbarton> but actually writing 'main = do' at the front of the file is hard? :)
17:02:39 <nand`> type-safe shell, basically
17:02:46 <nand`> rwbarton: + indenting every line!
17:02:47 <hpc> powershell has types, i am told
17:03:00 <hpc> through COM objects
17:03:09 <nand`> oh, but that wouldn't quite work out of the box; since you'd need an extra ‘let’ in front of every definition
17:03:11 <nand`> and that could get tiresome
17:03:15 <nand`> I think I'm fine with the current
17:03:17 <nand`> :)
17:03:23 <nand`> hpc: yeah; I've used it before
17:03:35 <nand`> I thought it lives in .NET
17:03:45 <nand`> with processes returning .NET objects
17:04:34 <hpc> one of those; i don't keep track of the latest windows fads :P
17:05:26 <callen> nand`: take a look at Shelly.hs
17:05:36 <nand`> I might've seen that before
17:06:35 <mapreduce> How can I see what >>= looks like for [] ?
17:07:05 <nand`> [] >>= _ = []; or what did you mean?
17:07:07 <mauke> @src [] (>>=)
17:07:07 <lambdabot> xs >>= f     = concatMap f xs
17:07:09 <nand`> oh, you mean the definition of >>= for []?
17:07:20 <hpc> @src concatMap
17:07:20 <lambdabot> concatMap f = foldr ((++) . f) []
17:07:20 <mapreduce> Yes.
17:07:26 <nand`> there you go :)
17:07:34 <hpc> concatMap f = concat . map f
17:07:47 <hpc> but that's manually expanded
17:08:03 <mapreduce> Ok, for educational purposes what's the simplest form?
17:08:10 <nand`> an “expanded version”:  [] >>= _ = []; x:xs >>= f = f x ++ xs >>= f
17:08:15 <nand`> I think
17:08:27 <rwbarton> xs >>= f = concat (map f xs)
17:08:44 <hpc> (f x) ++ (xs >>= f) -- to be unambiguous
17:09:20 <nand`> should work with the precedence in mine, no?
17:09:26 <mapreduce> @src (++)
17:09:26 <lambdabot> []     ++ ys = ys
17:09:26 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:09:26 <lambdabot> -- OR
17:09:26 <lambdabot> xs ++ ys = foldr (:) ys xs
17:09:30 <hpc> i don't remember
17:09:30 <nand`> no
17:09:33 <nand`> >>= is infixl 1
17:09:41 <mapreduce> Excellent, thanks.
17:09:54 <nand`> so f x ++ (xs >>= f) :)
17:10:02 <nand`> but yeah, rwbarton's is probably the simplest to understand
17:10:31 <nand`> interestingly enough
17:10:57 <nand`> it corresponds exactly to xs >>= f = join (fmap f xs)
17:10:57 <nand`> which is how (>>=) can be automatically defined in terms of ‘join’ and ‘fmap’
17:11:08 <typoclass> i wish there was an easy way to look up the instance stuff in the haddocks
17:11:16 <monochrom> with great mapreduce comes great mapconcat
17:11:33 <Lajjla-> mapreduce, is that really implemented like that in GHC or is that low level done?
17:11:39 <nand`> typoclass: usually you'd find an instance on either the page where [] is defined or the page where Monad is defined; then you'd be able to clic-- oh right, no Source links for instances
17:11:52 <typoclass> yeah that's what i mean
17:12:20 <nand`> instance  Monad []  where
17:12:22 <nand`>     m >>= k             = foldr ((++) . k) [] m
17:12:24 <nand`> -- from GHC.Base source
17:19:47 <Cale> Lajjla-: I think maybe you asked the wrong person that question? What are you asking about?
17:20:14 <Lajjla-> cale, my old friend, and well, this:
17:20:17 <Lajjla-> @src (++)
17:20:18 <lambdabot> []     ++ ys = ys
17:20:18 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:20:18 <lambdabot> -- OR
17:20:18 <lambdabot> xs ++ ys = foldr (:) ys xs
17:20:53 <Cale> yes, the first one
17:21:01 <Cale> (++) :: [a] -> [a] -> [a]
17:21:01 <Cale> (++) []     ys = ys
17:21:01 <Cale> (++) (x:xs) ys = x : xs ++ ys
17:21:15 <Cale> From GHC.Base
17:21:43 <Cale> however, there is a rewrite rule:
17:21:45 <Cale> {-# RULES
17:21:45 <Cale> "++"    [~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys
17:21:45 <Cale>   #-}
17:21:51 <lispy> That definition always makes me want to use an @, but then I guess it would be _|_
17:22:19 <nand`> precedence
17:22:23 <nand`> x : (xs ++ ys) ?
17:22:24 <lispy> nand`: yeah
17:22:40 <nand`> I thought ++ would be lower
17:23:17 <Lajjla-> Cale, I had assumed that it was primitively implemented for some reason.
17:23:38 <lispy> > (1 : ([2,3,4] ++ [5,6]), (1 : [2,3,4]) ++ [5,6])
17:23:41 <lambdabot>   ([1,2,3,4,5,6],[1,2,3,4,5,6])
17:23:52 <lispy> heh, that doesn't help
17:24:04 <Lajjla-> cale, also, lo and behold, this is why infix notation is baaaaaaad, I also was a bit confused by x : xs ++ ys at first.
17:24:12 <lispy> > (a : ([b,c,d] ++ [e,f]), (a : [b,c,d]) ++ [e,f])
17:24:14 <lambdabot>   ([a,b,c,d,e,f],[a,b,c,d,e,f])
17:24:17 <lispy> neither does that
17:24:34 <nand`> they're both infixr 5
17:24:37 * lispy isn't sure how to "observe" the precedence here
17:24:42 <nand`> so that would be just right-associativity
17:24:44 <nand`> lispy: ;i
17:24:45 <nand`> :i
17:24:46 <Cale> Lajjla-: yeah, I'd put the parens there
17:25:00 <Lajjla-> cale, we are in unanimous agreement, cool.
17:25:27 <Cale> Lajjla-: I mean, especially as that's all it's doing is reassociating :)
17:25:45 <dolio> It doesn't matter how x : xs ++ ys associates, though. :)
17:25:51 <Cale> right, in general
17:26:03 <Lajjla-> Well, I'm not going to have that discussion again, let's just agree to the fact that my opinion is better but you still disagree because you're jealous as my rich wavy locks of long black shiny hair.
17:26:15 <Lajjla-> Or something like that, I read it in a psychoanalysis primer once.
17:26:21 <nand`> except when defining (++), of course
17:26:23 <Cale> lol
17:26:25 <gertc> what is the difference between cabal install cabal-install and cabal install cabal ?
17:26:35 <lispy> dolio: but, (++) xs ys = xs ++ ys vs. (++) (x:xs) ys = x : (xs ++ ys), it does matter
17:26:42 <nand`> the former installs cabal-install, the latter installs cabal
17:26:46 <nand`> I would guess
17:26:52 <Cale> gertc: Cabal is the library which does the technical work behind cabal-install
17:26:57 <nand`> the two are separate
17:27:00 <lispy> gertc: cabal-install is a command called cabal and Cabal is a library that cabal-install depends on
17:27:03 <monochrom> there is no cabal
17:27:09 <nand`> cabal is a build system for haskell, cabal-install is some program that pretends to be a package manager but actually screws up your installation constantly.
17:27:18 <Cale> wow
17:27:20 <Cale> so negative
17:27:38 <mauke> nand`: so ... it's a package manager? :-)
17:27:44 <lispy> mauke: hehe
17:27:46 <nand`> I hope my stance on cabal-install has been made clear
17:27:59 <Cale> cabal-install actually works reasonably well most of the time, at least for me. I'm not saying I've never struggled with it, but it does a pretty good job mostly.
17:28:00 <lispy> nand`: what do you use? do you use cabal-dev instead?
17:28:05 <typoclass> nand`: i've heard it will get much better with 1.16. haven't tried it yet
17:28:11 <nand`> lispy: I use portage
17:28:20 <lispy> nand`: to build things from hackage?
17:28:27 <nand`> lispy: yes
17:28:29 <dolio> I don't think I've ever had cabal screw things up.
17:28:30 <lispy> huh
17:28:35 <dolio> Or, cabal-install.
17:28:46 <dolio> I must be installing the wrong things.
17:28:50 <hpc> i have screwed things up with cabal, but not the other way around ;)
17:29:05 <lispy> dolio: I have. If you install library A version 1, then install B that depends on A, and then you install A version 2, you will break B
17:29:11 <gertc> but why does cabal update tels me to only update cabal-install ?
17:29:20 <Cale> You guys are spoiled. Go back to 2001 when there were hardly any libraries, and no package management at all.
17:29:21 <monochrom> cabal-install works for me 100%. this is because I wrote http://www.vex.net/~trebla/haskell/sicp.xhtml
17:29:26 <lispy> gertc: because there is a newer version of cabal-install available
17:29:28 <nand`> ‘cabal update’ downloads the latest package list
17:29:38 <nand`> the latest package list includes a newer version of cabal-install (the program you were just running0
17:29:41 <nand`> so it recommends you update itself
17:29:44 <alpounet> carter, apparently, i do need to write a blog post...
17:29:48 <typoclass> gertc: it will automatically install all the prerequisites
17:30:04 <byorgey> lispy: but that only happens now if you explicitly request it with --force-install
17:30:06 <dolio> Cale: That goes for people who complain about how, 'GHC's error messages are so terrible; the suggested fix isn't always the right fix!'
17:30:23 <nand`> Cale: you don't have to go back to 2001, it's as simple as installing slackware
17:30:29 <Cale> nand`: heh
17:30:35 <startling> nand`, what's the difference
17:30:43 <lispy> byorgey: that's good news, but sandboxing is even better
17:30:54 <byorgey> I don't disagree.
17:31:45 <lispy> nothing seemed to be happening to cabal for a long time. Now that it's on github it seems quite active again. This is really positive
17:31:45 <Cale> I'm not totally sure that sandboxing everything is the right solution. It's definitely a solution which ought to be available.
17:31:51 <gertc> ok thx
17:32:03 <Cale> But it's also an obnoxious thing to do to yourself all the time :)
17:32:07 <alpounet> Cale, having per-project sandbox works out wonderfully for me
17:32:19 <gertc> \quit
17:32:26 <monochrom> /quit
17:32:28 <gertc> damit
17:32:34 <alpounet> just replace any call to 'cabal' (the binary) by a call to 'cabal-dev'.
17:32:38 <lispy> Cale: if your objection is the redundant building, you could imagine a cache system that reduces the redundant building. Getting the cache right can be subtle
17:32:39 <monochrom> \quit is a LaTeX command
17:32:47 <alpounet> (and soon it'll be even easier, cf tibbe's comment)
17:33:05 <nand`> sandboxing? is that having a separate version tree for each project?
17:33:07 <nand`> of its dependencies
17:33:28 <lispy> nand`: yeah, cabal-dev has per-directory-tree package databases
17:33:38 <lispy> nand`: and it builds/installs things into that
17:34:03 <nand`> ah
17:34:11 <nand`> but that's a lot of rebuilding
17:34:13 <lispy> it also has the wonderful 'ghci' command that loads your cabalized code into ghci
17:34:17 <nand`> personally, I'm completely fine with “have everything at the latest version”
17:34:28 <nand`> minor annoyances though, eg. Gtk2Hs still doesn't work
17:34:59 <lispy> nand`: in practice the cost of building those things is cheap. It takes maybe 5 minutes when you first build your stuff. But the next build only builds your code
17:34:59 <alpounet> it doesn't work large-scale nand`, in my experience
17:35:00 <dolio> Maybe we should just adopt the NixOS package manager.
17:35:06 <typoclass> dolio: i think you're placing a little too much blame on the users. yes it is possible to find workarounds for cabal's problems. no, it doesn't look good if a newbie installs the platform, then does "cabal install this", "cabal install that", and has ghc-pkg show broken packages
17:35:43 <fliip> If foo f x = f(f x), what does foo foo foo do?
17:35:44 * Polarina wants a IsString instance for { Ptr CString }
17:35:46 <Cale> lispy: You can also imagine a system where the sandboxing wasn't really required in the first place, because package graphs were handled more consistently and things weren't forced to break upon installing new versions.
17:36:03 <hpc> :t let foo f x = f (f x) in foo foo foo
17:36:06 <lambdabot> forall t. (t -> t) -> t -> t
17:36:06 <typoclass> at any rate, it's great that they are so hard at work now, and they deserve huge cheers
17:36:14 <dolio> typoclass: I don't know what you're talking about.
17:36:19 <hpc> > let foo f x = f (f x) in (foo foo foo) succ 0
17:36:20 <lambdabot>   16
17:36:23 <dolio> All I remember saying about cabal-install is that it's never screwed up for me.
17:36:33 <hpc> fliip: apparently applies a function 16 times
17:36:38 <lispy> Cale: maybe? it's really hard to make sure you incorporate all the right inputs to your graph. What if some external thing changes like gcc version and you now need to rebuild the deps?
17:36:42 <fliip> Hmm. Ok thanks.
17:36:44 <alpounet> 1/ maybe we should indeed document more what current solutions we have, or what are the workflows people tend to use not to hit too many problems with cabal 2/ people who just can't stop whining about it in public should actually help fixing that, 'cause the community knows about these problems already
17:36:45 <fliip> I have no idea why.
17:36:45 <fliip> lol
17:36:56 <hpc> fliip: expand it by hand yourself
17:36:59 <dolio> I haven't had to work around anything, because there's never been anything to work around.
17:37:02 <Cale> lispy: Well, you kind of have that problem with sandboxes too
17:37:06 <nand`> alpounet: how large is large scale?
17:37:08 <Taslem> fliip: foo applies a function twice. Applying foo twice will then apply the function twice each.
17:37:08 <nand`> I have a few hundred haskell packages installed on my system, I don't know if that's large or not
17:37:22 <hpc> foo foo x = foo (foo x)
17:37:22 <fliip> Why isnt that just 6?
17:37:23 <hpc> etc
17:37:23 <lispy> Cale: yes, but blowing away my sandbox is cheap/easy because it's just the deps for my current code
17:37:27 <applicative> applying applying applying twice twice twice is applying 16 times
17:37:28 <Cale> lispy: you still need to keep track, and now you have to make sure all your sandboxes are up to date with your system, rather than one environment.
17:37:34 <nand`> alpounet: I'd love to document my portage/haskell workflow sometime
17:37:36 <lispy> Cale: cheap/easy compared to rebuilding everything in the world
17:37:52 <nand`> most of it probably already there, it's a project called ‘Gentoo-Haskell’ that integrates all haskell stuff into the gentoo/portage workflow
17:38:47 <dolio> I think the biggest problem I've ever had was being unable to install Agda because someone was holding off forever on a version of something that was blocking it.
17:38:58 <alpounet> nand`, well, before using sandboxes with cabal-dev, i *always* ended up with conflicts/issues after just a few months. whenever packages with a huge transitive closure of dependencies were involved, bam.
17:39:09 <Cale> lispy: Well, it's sum over sandboxes s of sum over packages p in s of cost of building p  versus  sum over packages p in local world of cost of building p
17:39:10 <dolio> And people had to fork 'foo-ghc76' like packages that were ugly.
17:40:07 <alpounet> and if i was even less lucky, that was exactly the moment when a key package was introducing breaking changes or smth like that and that many other packages hadn't caught up on these changes yet
17:40:44 <Cale> lispy: The first cost is eventually larger, though you don't have to incur it all at once. The same ought to be true of a unified package graph.
17:40:53 <Cale> (but maybe it wouldn't be)
17:41:11 <nand`> alpounet: I've been using this setup for a few months; doing nearly daily updates of all packages and sporadic additions/removals throughout; I've yet to run into any major conflict; usually portage will find a solution that ‘keeps everything happy’ and if something still hard conflicts (eg. one package requires >2.3 and the other requires <2.1 of the same library) then you'd have to resolve it manually
17:41:14 <alpounet> nand`, i have the intention to write something about these stuffs when scoutess 0.1 is out -- advices to users + advices to package maintainers for having an easy and smooth trip in haskell land
17:41:27 <lispy> Cale: I think in the latter case there may be times when you have to rebuild the whole graph, but that's probably rare.
17:41:48 <lispy> Cale: I do agree that conservative optimizations could be applied to the sandbox approach
17:42:15 <lispy> Cale: As is, it does rebuild more often than strictly necessary. For me at the moment, that cost is lower than the hassle of not using sandboxing.
17:42:31 <Cale> Or maybe there ought to be a meta-graph of packages :)
17:43:00 <Cale> Like, GHC will have a notion of these boxes of packages, and they will have dependency relationships :)
17:43:01 <nand`> one thing that I've found portage will never do though is leave you with broken packages; if some upstream update broke downstream packages, it'll rebuild them all
17:43:08 <lispy> We better build a universe of graphs to avoid Girard's paradox
17:43:27 <nand`> (or, if it fails eg. incompatibility with the updated dependency, it'll keep nagging you until you do fix it)
17:43:46 <lispy> nand`: that indeed sounds like a nice property
17:43:52 <alpounet> nand`, but portage doesn't support multiple versions of a package right?
17:44:10 <alpounet> or does it? i don't remember, it's been ages since i have last used gentoo
17:44:17 <lispy> probably the biggest objection to portage is that it's built around Gentoo. What about other distros and other OSs?
17:44:19 <nand`> alpounet: not automatically, no
17:44:29 <nand`> there's a system to do it called slots, but haskell stuff isn't slotted
17:44:38 <peterjoel> hi, is there a primitive way to draw pixels on the screen without relying on FFI?
17:44:43 <nand`> that's more for stuff like different versions of the same library which can coexist (eg. python2 and python3)
17:44:55 <lispy> peterjoel: putStr?
17:45:02 <peterjoel> :)
17:45:10 <peterjoel> I mean writing to video buffer
17:45:19 <nand`> alpounet: come to think of it, it should probably be possible to set up sandboxed portage trees
17:45:27 <nand`> in the spirit of cabal-dev
17:45:45 <lispy> peterjoel: well, GHC basically uses the FFI to implement any of the primitives that do side-effects
17:45:50 <Cale> peterjoel: I guess you can open a connection to the windowing system or whatever yourself.
17:45:56 <lispy> peterjoel: so in some sense, it's not even possible
17:46:01 <peterjoel> ok
17:46:20 <nand`> (but each portage tree would pull in its own ghc and all of ghc's dependencies down to binutils; so you'd have to share them somewhere or redesign the ‘ghc’ package -- actually yeah that last approach would be best
17:46:22 <peterjoel> so it will always rely some other non-haskell dependency
17:46:28 <nand`> oh, I wanted to sleep
17:46:30 <Cale> peterjoel: http://hackage.haskell.org/package/xhb
17:46:31 <lispy> peterjoel: But, you can avoid writing FFI code and use something that already exists. I'm not really sure what your needs are.
17:46:43 <nand`> peterjoel: there's no I/O of any sort without FFI
17:46:55 <peterjoel> it's partly curiosity, and partly wanting to avoid gtk+
17:47:05 <nand`> the only actual low level language construct for real world interaction *are* FFI calls
17:47:16 <Cale> peterjoel: That library is a Haskell implementation of the X11 protocol
17:47:18 <alpounet> peterjoel, there are stuffs like gloss
17:47:24 <lispy> peterjoel: You can't do inline assembly, for instance
17:47:43 <nand`> but I guess if your concern isn't ‘without FFI’ but rather ‘in a pre-made package so I don't have to write the FFI wrapper myself’, there are plenty solutions
17:47:47 <peterjoel> ok, I think my underlying question was answered
17:48:08 <nand`> lispy: that gives me an idea, inline assembly
17:48:26 <fliip> How do you make a new instance declaration using Ord to make a list ascending?
17:48:37 <lispy> nand`: You're not the only one. HalVM could probably be simplified with inline assembly.
17:48:42 <nand`> TemplateHaskell/quasiquoter + some evil unsafePerformIO + memory manipulation code to load its binary representation into memory + an FFI call to that
17:48:51 <nand`> should be doable
17:49:00 <Cale> fliip: Could you rephrase that?
17:49:02 <lispy> nand`: or just use Harpy?
17:49:18 <mauke> nand`: http://hpaste.org/77137
17:49:34 <fliip> I want to make a instance declaration so that ordering on a list is ascending.
17:49:35 <peterjoel> fliip, are you asking if you can enforce ordering of a list at the type level?
17:49:41 <mauke> fliip: what
17:49:43 <lispy> mauke: heh
17:49:49 <fliip> ie instance (Ord a) => Ord [a]...
17:49:58 <Cale> fliip: well, that instance already exists
17:50:02 <mauke> fliip: let me rephrase: WHAT
17:50:05 <alpounet> > [1,2,3] < [1,3,4]
17:50:06 <lambdabot>   True
17:50:18 <lispy> newtype RevList a = [a]; instance (Ord a) => RevList a where ...
17:50:21 <fliip> Oh. Its in the prelude?
17:50:26 <Cale> yes
17:50:29 <fliip> Oh ok. Sorry.
17:50:32 <nand`> that instance isn't ascending or descending; it's .. whatever the word is
17:50:34 <nand`> left to right
17:50:37 <lispy> > sort [5,4..1]
17:50:37 <mauke> lexicographic
17:50:38 <lambdabot>   [1,2,3,4,5]
17:51:12 <nand`> mauke: hey that works
17:51:20 <nand`> mauke: and less evil than I thought, withCString
17:51:22 <nand`> and lexicographic yeah
17:51:42 <lispy> mauke: that is really nice. I didn't realize it would be that simple
17:51:49 <nand`> now just write a quasiquoter for x86 ASM, pass it into harpy, and load that with mauke's trick
18:02:00 <mrlemao`> How do I parse this: "parse error on input `let'"
18:02:27 <startling> mrlemao, what's the code that gave that error?
18:04:43 <hpaste> mrlemao pasted “parse error on input `let'” at http://hpaste.org/77138
18:05:04 <Cale> mrlemao`: You have tabs in your source
18:05:21 <Cale> mrlemao`: configure your text editor to replace them by spaces automatically for you
18:06:00 <Cale> (pretty much any good text editor has an option like that... for vim, it's  set expandtab  in your .vimrc)
18:06:11 <startling> mrlemao`, I can't tell where the `let` is supposed to go at all
18:07:18 <Cale> mrlemao`: If you look at how your code looks on hpaste.org, it should be clear what's wrong, yeah? :)
18:07:26 <mrlemao`> Cale, startling: ok, that fixed it. Can I assume that this error mean tabs/indentation?
18:07:57 <startling> mrlemao`, no. it could be from using let at the top level, too
18:08:04 <mrlemao`> Cale: well, I don't intend to paste code in hpaste to figure this out ;-)
18:08:05 <Cale> mrlemao`: no, the error itself just means that the 'let' keyword occurred somewhere that the compiler wasn't expecting it -- i.e. not where it was expecting an expression
18:08:30 <Cale> mrlemao`: The Haskell compiler will always treat tabs as aligning to the next multiple of 8 spaces
18:08:45 <Cale> (though tbh, I think it should consider them a lexical error)
18:11:59 <mrlemao`> Cale, startling: thanks!
18:13:23 <ion> An editor that doesn’t use a tab stop width of 8 is broken, since the rest of the world has standardized to 8.
18:13:46 <lispy> google is failing me. Do you folks know of any research for doing unit analysis of code? Units as in meters/seconds, inches, etc
18:13:48 <mapreduce> Don't web browsers default to 4?
18:14:01 <lispy> Perhaps papers that cast it as a type checking problem
18:14:20 <startling> lispy, you can do it with phantom types
18:14:32 <startling> I don't know of any research in that regard though
18:14:37 <ion> mapreduce: Firefox doesn’t at least. Defaulting to 4 would be bug report-worthy.
18:14:41 <lispy> startling: I want to do the analysis over a non-haskell input
18:14:44 <startling> ah
18:15:13 <lispy> I think I can come up with it myself for my problem, but I figured finding related work wouldn't hurt
18:15:47 <mapreduce> ion: You're right, sorry.
18:15:57 <lispy> ah, this is the kind of thing I'm looking for: http://onlinelibrary.wiley.com/doi/10.1002/spe.401/abstract
18:17:15 <typoclass> lispy: not sure in general, but in haskell there's one or two packages that do physical dimensions
18:18:13 <qasi> :(
18:18:22 <qasi> *** Exception: Numeric.showIntAtBase: applied to negative number -86400
18:18:27 <typoclass> lispy:  this page has 2-3 relevant links http://www.haskell.org/haskellwiki/Physical_units
18:18:30 <qasi> that's probably in a library I'm using.
18:18:36 <qasi> what's the best way to find out where?
18:19:18 <lispy> typoclass: those are all for haskell
18:19:45 <lispy> typoclass: I want to write a dimensional analysis for fortran
18:19:52 <byorgey> lispy: http://research.microsoft.com/en-us/um/people/akenn/units/
18:20:07 <lispy> byorgey: cool
18:20:08 <typoclass> lispy: oh i see, sorry
18:23:23 <coldpizza72i> Can someone tell me if it looks like I'm headed in the correct direction http://ideone.com/C9zOdy      http://www.cs.rit.edu/usr/local/pub/jeh/courses/FP/Labs/Parser-kladoi/
18:29:17 <Cale> coldpizza72i: Well, your parser combinator implementation is good, but I don't know what's going on in the definition of expr1
18:29:29 <shachaf> @ty both
18:29:30 <lambdabot> Not in scope: `both'
18:29:43 <shachaf> Cale: ☝☹☝
18:30:00 <coldpizza72i> Cale: I kind of got lost their..
18:31:02 <Cale> shachaf: what's that?
18:31:05 <coldpizza72i> Cale: Does it look terriblly off?
18:31:11 <Cale> coldpizza72i: I don't understand the syntax
18:31:19 <shachaf> Cale: A Traversal from "lens"
18:31:38 <typoclass> @let both = 4
18:31:39 <lambdabot>  <local>:2:1:
18:31:39 <lambdabot>      Multiple declarations of `both'
18:31:39 <lambdabot>      Declared at: <local>:...
18:31:45 <typoclass> shachaf: fixed, you're welcome
18:31:52 <shachaf> @ty both
18:31:53 <lambdabot> forall a. Num a => a
18:31:57 <shachaf> > both
18:31:58 <lambdabot>   42
18:32:13 <shachaf> typoclass: Looks like someone else made it 4 too!
18:32:25 <coldpizza72i> Cale: the entire function's syntax or a particular part of it?
18:33:24 <Cale> coldpizza72i: you're parsing many digits, and then opt1 string (where is opt1 defined?), and then opt1 char...
18:34:01 <Cale> coldpizza72i: the syntactic part which is weird is what the heck is going on inside the return
18:34:36 <Cale> It looks like you have some guards in there, but guards are part of declaration syntax and case expressions
18:39:46 <coldpizza72i> Cale: I have added opt1 here http://ideone.com/1A6ylI …Yes I was trying to make a multiple case if statement and wasn't sure how else to do that
18:41:39 <coldpizza72i> ill brb
18:45:14 <coldpizza72i> Cale: does it make more sense now with opt1 implmented?
18:47:56 <Cale> coldpizza72i: Okay, so an expr1 consists of a nonempty string of digits followed by an optional string, followed by an optional single character, followed by two optional expr1s...
18:48:34 <coldpizza72i> many can be empty too
18:48:49 <Cale> oh, yes, it can
18:49:03 <Cale> coldpizza72i: but, this matches things like 372889sssssc72189ssssc789fhdjks
18:49:10 <Cale> what is this for?
18:49:25 <coldpizza72i> an assignment...
18:49:30 <Cale> (also, it's highly ambiguous)
18:49:38 <Cale> yeah, what part of the assignment are you trying to do?
18:50:43 <coldpizza72i> Im trying to implement the Expr production rule given by the CFG
18:51:34 <Cale> coldpizza72i: So first implement parsers for id and literal, and op
18:51:56 <Cale> coldpizza72i: | in the CFG doesn't mean "and", it means "or"
18:52:10 <coldpizza72i> i know
18:52:39 <Cale> Do you understand the parser library that you have in your code?
18:52:48 <Cale> In particular, the implementation of >>=?
18:52:56 <coldpizza72i> no
18:53:09 <Cale> okay, maybe we should go over this
18:53:10 <mrlemao`> is cabal-install-1.16 much faster or am I crazy?
18:53:55 <alpounet> don't forget to use -j if appropriate, too
18:54:33 <Cale> coldpizza72i: Okay, so first of all, let's think about this representation of parsers
18:55:26 <Cale> The Dr. Seuss version of this, is that a parser for things is a function from Strings to lists of pairs of things and Strings.
18:56:08 <Cale> That is, it's going to consume some input String, and produce a list of possible parses of that string, where each parse consists of a value of type a, and a depleted string
18:56:27 <Cale> (which will in general be some suffix of the input string)
18:56:59 <Cale> newtype Parser a = P (String -> [(a,String)])
18:57:01 <typoclass> dr. seuss? gorram haskell where everything requires a phd
18:57:34 <Cale> Now, the first thing I would implement here would be a function to run such a parser on a given input, and get a list of the parses
18:57:44 <Cale> which, due to our choice of representation, is easy
18:57:56 <Cale> runParser :: Parser a -> String -> [(a, String)]
18:58:02 <Cale> runParser (P f) s = f s
18:58:24 <Cale> coldpizza72i: make sense how that works? We just unpack the function and apply it to the input string.
18:58:40 <Cale> (any questions about this representation?)
18:58:48 <coldpizza72i> no
18:58:51 <coldpizza72i> it makes sence
18:58:54 <Cale> okay
18:59:34 <Cale> So, now, we're going to make this type of Parsers an instance of Monad. Have you seen many monads before? Perhaps you've written some programs using IO?
19:00:10 <byorgey> typoclass: dr. seuss didn't have a PhD
19:01:23 <Cale> coldpizza72i: I'm going to explain the steps of this in detail, but I need to know what you know :)
19:01:57 <coldpizza72i> I have seen very basic monads
19:02:08 <Cale> okay
19:02:20 <lispy> byorgey: neither does mr. pibb.
19:02:27 <typoclass> byorgey: what's next? you're going to tell me doctor who doesn't have a phd either!?
19:02:43 <Cale> actually, before I do >>= I might go over satisfy and some others, but let's look at return
19:03:14 <coldpizza72i> k
19:03:15 <Cale> So, return :: a -> Parser a
19:03:45 <Cale> and return v will be a parser which succeeds (in a unique way) without consuming any of the input, and produces the result v
19:03:58 <Cale> return v = ...
19:04:19 <Cale> Well, we know we want a parser, and we don't have many ways to make parsers yet, so we might as well use the data constructor P
19:04:21 <Cale> return v = P ...
19:04:40 <Cale> and P takes a function  String -> [(a, String)]  as its parameter, so that might as well be a lambda
19:04:44 <Cale> return v = P (\s -> ...)
19:05:13 <Cale> now we have our input string s, and we want to produce a list of the resulting parses -- we said that it succeeds uniquely, so we want a list of length 1:
19:05:16 <Cale> return v = P (\s -> [...])
19:05:21 <ludamad> What's the sanest solution for writing a parser (CFG) in haskell ? (Not yet there, but curious)
19:05:39 <Cale> and that list has a pair consisting of the result and depleted input
19:05:50 <Cale> return v = P (\s -> [(v,s)])
19:06:15 <Cale> and our result is v, and our depleted input string is just the input string we were given, because we're not eating anything
19:06:37 <Cale> ludamad: I'm describing the construction of a simple monadic parser combinator library right now
19:06:53 <Cale> ludamad: there are fancier and more efficient versions of this, like Parsec and ReadP
19:07:08 <Cale> ludamad: as well as static parser generators like Happy
19:07:32 <Cale> coldpizza72i: okay with return?
19:07:55 <coldpizza72i> yes
19:07:58 <Cale> Now let's write a parser   satisfy :: (Char -> Bool) -> Parser Char
19:08:19 <Cale> which will try to eat one character of the input, and will succeed only if the character matches the given predicate
19:08:28 <ludamad> I suppose I'm interested in whatever is the cleanest, at least for now
19:09:22 <Cale> ludamad: Well, some parser combinator library. You'll want a different one depending on the exact nature of the parser you're writing most likely, but Parsec is a pretty good bet.
19:09:34 <startling> seconding parsec
19:09:35 <Cale> coldpizza72i: okay, so...
19:09:42 <ludamad> Cale, cool, thanks
19:09:42 <astropirate> Greetings all
19:10:01 <Cale> satisfy p = P ... -- again, we're writing a parser from scratch, so might as well use P
19:10:17 <Cale> satisfy p = P (\s -> ...) -- and might as well use a lambda for the function parameter
19:10:22 <startling> ludamad, if you're looking for a quick introduction, the "functional pearls" paper on monadic parsers is good.
19:11:03 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> ... ) -- now we're going to look at the input, and see if it's nonempty and whether the first character matches the predicate
19:11:53 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> [(x,xs)]; ...) -- and if so, our result is that first character x, and our depleted input string is the remainder of the input xs
19:12:10 <Cale> satisfy p = P (\s -> case s of (x:xs) | p x -> [(x,xs)]; _ -> []) -- otherwise, the parse fails, and we produce an empty list of parses
19:12:27 <Cale> coldpizza72i: follow that?
19:13:17 <astropirate> Anybody bored and looking for a Haskell related project to hack on? :)
19:13:24 <Cale> coldpizza72i: I'm doing things in a somewhat different order than your library does them, which is why my satisfy is a little different from your 'sat'
19:13:30 <Cale> coldpizza72i: but they do the same thing
19:13:59 <ludamad> startling: will look into, thanks!
19:14:11 <Cale> and now in terms of this satisfy, we can write lots of useful little parsers, by plugging in different predicates:
19:14:17 <Cale> digit = satisfy isDigit
19:14:22 <Cale> letter = satisfy isAlpha
19:14:34 <Cale> space = satisfy isSpace
19:14:54 <Cale> coldpizza72i: still here?
19:15:21 <Cale> coldpizza72i: and of course, we can write a parser which matches one specific character:
19:15:29 <Cale> char c = satisfy (== c)
19:15:45 <coldpizza72i> I'm here
19:15:53 <coldpizza72i> 1sec
19:17:16 <Cale> coldpizza72i: okay, let me know when you're back and have caught up :)
19:22:30 <coldpizza72i> Cale: didn't realize my connection dropped… it all makes sense so far
19:22:48 <Cale> coldpizza72i: okay
19:23:15 <Cale> coldpizza72i: So, now we have a handful of simple parsers and we'd like a way to chain them together into more complicated ones.
19:23:32 <Cale> coldpizza72i: We could write a combining function like  (>>) :: Parser a -> Parser b -> Parser b
19:23:57 <coldpizza72i> cool
19:24:09 <Cale> which parsed the beginning of the input with the first parser, discarding its result, and then parsed whatever was left of the input with the second parser, producing its result as the result of the overall parser
19:24:52 <Cale> However, discarding the result of that first parser seems kind of awkward, and we might want to decide how to parse the rest of the input based on what that first result was
19:25:11 <Cale> If we do that, the natural thing to implement would be:
19:25:20 <Cale> (>>=) :: Parser a -> (a -> Parser b) -> Parser b
19:26:16 <Cale> Does it make sense how that'll generally work?
19:26:19 <Cale> x >>= f
19:26:28 <coldpizza72i> yes
19:26:30 <Cale> will be the parser which parses the start of the input with x
19:27:06 <Cale> and then for each result and depleted string (v,s') resulting from x, will run the parser f v on the string s'
19:27:14 <Cale> So let's implement that...
19:27:26 <Cale> x >>= f = P (\s -> ...) -- starting out the same way as before
19:28:01 <chowder> I'm a newbie with haskell and I'm reading lyah right now. I've tried haskell on and off but I never seem to "get it". I'm familiar with languages like C and Java but I don't have much of a functional programming background. I'm trying to learn how to do certain things I'd do in C in haskell. Like right now I'm trying to write a function that takes a number like 123 and returns the numerological sum.  i.e. 123 = 1+2+3. I started out
19:28:24 <Cale> x >>= f = P (\s -> ... runParser x s ... ) -- we know we want to run the parser x on the input string s
19:28:32 <chowder> the problem is that show n returns [Char] when I want [Num] so I can just pass it to sum
19:28:53 <Cale> now, we'll use a list comprehension to choose from the list of parses
19:28:59 <typoclass> chowder: hello, welcome. your first message was cut off after "started out"
19:29:21 <Cale> x >>= f = P (\s -> [ ... | (v,s') <- runParser x s ...] ) -- so we name the result of parsing v, and the depleted string s'
19:30:02 <Cale> x >>= f = P (\s -> [ ... | (v,s') <- runParser x s, (w,s'') <- runParser (f v) s'] ) -- and then we want to run the parser (f v) on the depleted string s'
19:30:16 <Cale> getting a result w and even-more-depleted string s''
19:30:29 <Cale> and then that's the result of the whole thing, so...
19:30:38 <Cale> x >>= f = P (\s -> [ (w,s'') | (v,s') <- runParser x s, (w,s'') <- runParser (f v) s'] )
19:30:49 <chowder> retyping... I started out by doing show n but the problem is that show n returns a reult of type [Char] when I need a result of type [Num]
19:31:31 <Cale> coldpizza72i: is that cool? Any questions?
19:31:58 <Cale> coldpizza72i: we could also have chosen to use the list monad, if you're familiar with that...
19:33:05 <coldpizza72i> i think i understand it… i don't recall a list monad
19:33:09 <Cale> ah, okay
19:33:27 <Cale> Well, that might have been good to go over before all this...
19:33:38 <Cale> but let's just proceed
19:33:53 <Cale> From return and >>= we get many useful things for free
19:34:09 <Cale> This is what the monad abstraction is really all about
19:34:24 <Cale> We get things like sequence :: [Parser a] -> Parser [a]
19:34:38 <ludamad> chowder: show n, is n a number ?
19:34:44 <ludamad> show will 'convert to string'
19:34:47 <ludamad> in a sense
19:34:56 <typoclass> chowder: you're probably interested in the function "read". it's a general-purpose function to converts from a String to anything
19:35:07 <chowder> ludamad: yep. n is  a number. and thanks typoclass
19:35:21 <typoclass> chowder: try writing a function first that takes one Char and gives back an Int. any ideas on that?
19:35:29 <ludamad> chowder: Do you want [num] being the character codes ?
19:35:42 <Cale> and  liftM2 :: (a -> b -> c) -> Parser a -> Parser b -> Parser c
19:35:49 <Cale> and all kinds of other fun things
19:35:51 <rwbarton> "I'm trying to write a function that takes a number like 123 and returns the numerological sum.  i.e. 123 = 1+2+3."
19:35:53 <Cale> for free :)
19:36:12 <typoclass> ludamad: scroll up a little :) he described it very precisely
19:36:16 <Cale> but we can also think about how those things are constructed
19:36:17 <ludamad> ah sorry
19:36:18 <guidj0s> rwbarton: The problem is trivial if you turn the number into a list of digits.
19:36:51 <shachaf> rwbarton: At least they're not calling numerology "number theory", like some people I've met!
19:36:55 <chowder> ludamad: nah I'm really just trying to take a Num "a" and return [a] so it can then be passed to sum. The goal is rwbarton just wrote. I want to turn 123 into 1+2+3. the problem is indeed trivial if I can turn a number into a list of numbers
19:37:20 <ludamad> chowder: You can use map, and ord
19:37:29 <startling> don't do ord.
19:37:34 <Cale> coldpizza72i: let's look at sequence, since it's pretty useful
19:37:36 <ludamad> :)
19:37:43 * ludamad is new to haskell as well
19:37:43 <Cale> sequence [] = return []
19:37:44 <typoclass> > ord '4' -- ludamad, ord won't work very well
19:37:45 <lambdabot>   52
19:37:57 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
19:37:57 <ludamad> oh right
19:37:58 <ludamad> char codes
19:37:59 <ludamad> got it
19:38:05 <chowder> shachaf: horizontal addition is linked to mod 9 arithmetic. there are some very strange patters that arise. try it out! :) the fibonnacci sequence repeats itself infinitely in this manner.
19:38:17 <ludamad> (ord '4') - (ord '0')
19:38:18 <ludamad> :)
19:39:13 <typoclass> chowder: try writing a function of type "Char -> Int". you can use the function "read", which can turn a String into an Int
19:39:54 <Jetbeard> :t Data.Char.digitToInt
19:39:55 <lambdabot> Char -> Int
19:40:18 <chowder> it seems like there's more than one way to do it. I'm gonna have to look more into this but at least I have somewhere to start. thanks for the help guys
19:40:28 <Jetbeard> sum $ (map Data.Char.digitToInt) $ show 123
19:40:34 <Jetbeard> > sum $ (map Data.Char.digitToInt) $ show 123
19:40:35 <lambdabot>   6
19:40:43 <ludamad> chowder, Jetbeard's answer is pretty much what you're looking for imo
19:40:54 <typoclass> Jetbeard: i think it's more useful for him to learn read than to learn a special-purpose thing
19:41:05 <rwbarton> how about learning hoogle :)
19:41:39 <shachaf> read is the devil anyway.
19:41:53 <Cale> chowder: Yeah, that's because when you write a number like 1234 in base b, you really mean 1 * b^3 + 2 * b^2 + 3 * b^1 + 4 * b^0 (so b = 10 for normal decimal numbers), and if you then assume that 10 = 1, that is 9 = 0, that is, you work in the quotient ring Z/9Z, all the powers of 10 become 1 as well, and you get the sum of the digits (modulo 9)
19:42:14 <rwbarton> seen on reddit: "How would you use a NASA API?"
19:42:20 <rwbarton> . o O "unsafeLaunchMissiles"
19:44:48 <ludamad> So who here does haskell as a dayjob ?
19:45:19 <chowder> Cale: right. I really just think the patterns that arise when operating in mod 9 are interesting. like if you look at the multiples of 7 in mod 9 they go 7,5,3,1,8,6,4,2,9...
19:45:32 <chowder> ludamad: for me haskell and programming in general is a hobby
19:45:52 <Cale> ludamad: I have in the past, for iPwn, writing an action RPG and game engine, and will be using Haskell again shortly in my job at skedge.me, since we're rewriting the backend of the web app in Haskell.
19:46:27 <byorgey> chowder: the patterns mod anything are interesting =)
19:46:31 <ludamad> Cale: Did you do a lot(any?) intefacing with other languages for the game engine ?
19:47:10 <chowder> byorgey: I can get so wrapped up in numbers and patterns like Jim Carrey in 23. I'm surprised I haven't started writing on the walls of my apartment.
19:47:11 <shachaf> byorgey: I'm a big fan of the patterns of multiples of 7 mod 7.
19:47:16 <coldpizza72i> Cale: so is "id = many1 char" and "literal = many1 digit"?
19:47:37 <byorgey> chowder: hehe
19:47:43 <byorgey> shachaf: yes, that's a particularly nice one
19:47:57 <Cale> ludamad: There was a bit of C++ code initially which was going to do the low level drawing of bits of animation to the screen and such (to avoid stutter during GCs), but that was looking a bit less likely to be required at the point that the company went on hiatus.
19:48:50 <Cale> coldpizza72i: well, many1 letter
19:49:24 <ludamad> Cale, cool, I assume that would've been because of GC ? (Is there a pauseless GC for haskell ?)
19:50:26 <Cale> ludamad: Yeah, on desktop machines, the effect of GC would hardly be noticeable, but on older generation iPhones, major GCs (every 5 minutes or so) can take up to a third of a second
19:51:39 <Cale> ludamad: However, these things are improving and even by the time we put the game on hold, iPhones were a lot faster than they were when we did those benchmarks, so perhaps it wouldn't be needed.
19:53:14 <chowder> byorgey: I've been on a mod 9 kick lately. multiples of 8: 8,7,6,5,4,3,2,1. I keep thinking there is a way to use mod 9 to find the results of arithmetic operations on huge numbers in an efficient manner. patterns man...it'll keep you awake at night
19:53:50 <coldpizza72i_> Cale and "op = char '*' +++  char '/' +++  char '-' +++  char '+'"?
19:54:04 <Cale> > [(8*n) `mod` 9 | n <- [0..]]
19:54:05 <lambdabot>   [0,8,7,6,5,4,3,2,1,0,8,7,6,5,4,3,2,1,0,8,7,6,5,4,3,2,1,0,8,7,6,5,4,3,2,1,0,...
19:54:36 <Jetbeard> yes, 9 is coprime to 8 and so you get nice behaviour like that
19:54:47 <Cale> chowder: You can find one digit of results of arithmetic operations on what would otherwise be huge numbers
19:55:06 <Cale> chowder: by working modulo 10
19:55:07 <byorgey> chowder: 8 is -1 mod 9 so every time you add 8 it's the same as subtracting 1.
19:55:29 <Cale> coldpizza72i: yeah
19:55:32 <Jetbeard> [(65536*n) `mod` 65537 | n <- [0..]]
19:55:37 <Jetbeard> > [(65536*n) `mod` 65537 | n <- [0..]]
19:55:38 <lambdabot>   [0,65536,65535,65534,65533,65532,65531,65530,65529,65528,65527,65526,65525,...
19:56:00 <chowder> Cale: with horizontal addition the "0" actually becomes a 9. 9*8 mod 9 == 0 but 72 = 7+2 = 9. I've also noticed that byorgey. 8 is like subtraction. 5 divides 1234 and 5678
19:56:06 <chowder> Cale: hmm...I'm gonna try the bot.
19:56:16 <Cale> chowder: I would rather say that 9 becomes 0
19:56:53 <Cale> chowder: The fundamental property of 0 is that adding it to anything leaves that thing unchanged, that is, that for any x, you have 0 + x = x + 0 = x
19:56:56 <chowder> Cale: yea that's the only difference between mod 9 and horizontal addition. horizontal addition omits 0
19:57:05 <Cale> hm?
19:57:16 <Nereid> what the heck is horizontal addition?
19:57:34 <Cale> "horizontal addition" is just reduction modulo 9
19:57:50 <byorgey> Nereid: the dual of vertical addition, of course
19:57:53 <Nereid> lol
19:58:02 <Nereid> vertical coaddition*
19:58:12 <chowder> Cale: in mod 9 9n is always 0 for all n. Nereid, horizontal addition is just 123 = 1+2+3 = 6. its a curiousity
19:58:25 <Nereid> chowder: it's easily explained, as 10 = 1
19:58:27 <Jetbeard> which is just reduction in the category of addofunctors
19:58:28 <Nereid> so 10^n = 1
19:58:53 <chowder> Nereid: you guys are pretty smart. I'm used to people not catching on that quick
19:59:07 <Cale> chowder: Well, I have a degree in mathematics
19:59:11 <Nereid> me too
19:59:12 <Nereid> lol
19:59:28 <chowder> lol dang. I'm working on my bachelor's in IT
19:59:41 <Jetbeard> I'm doing a degree in computer science, I just hang out here because I mostly have to write Java
19:59:44 <chowder> I love mathematics but no degree here.
19:59:52 <Jetbeard> and Haskell's a nice antidote to all that mutability and verbosity
20:00:01 <Nereid> :>
20:00:16 <Cale> chowder: If 10 = 1, then we get 9 = 0, and there's no distinction between 9 and 0 :)
20:00:53 <Cale> chowder: but writing it as 0 is usually preferred anyway, because 0 is the one with the special property :)
20:01:23 <chowder> Cale: right and thats what weirds me out. I was watching a video on something called vortex based math. the dude behind basically claims this form of math will change the world but he really has little to show for it.
20:01:24 <Jetbeard> for any integer n, it's preferred to represent it as "0 (mod n)"
20:01:31 <Nereid> 0 + nZ
20:01:41 <liyang> So, how do you deal with {,Int,Hash}Map in the context of lenses?
20:01:55 <Cale> chowder: I've never heard of that, and he is quite possibly a crank.
20:01:56 <ludamad> I write Java for my day job, C++ for my hobby projects, messing around with haskell ... because it kicks my ass
20:01:58 <Nereid> liyang: there are lenses for those :-)
20:02:09 <qasi> is there a nicer way to do "either fail return"?
20:02:12 <Nereid> "There's a lens for that!"
20:02:14 <qasi> :t either fail return
20:02:15 <lambdabot> forall (m :: * -> *) a. Monad m => Either String a -> m a
20:02:26 <liyang> Nereid: only Set and IntSet as far as I can see.
20:02:47 <liyang> In particular I'm wondering about the various *WithKey functions.
20:03:05 <chowder> Cale: there's youtube videos on it. He arranges the numbers 1-9 in sort of like a circle. I thought it was interesting but you can really come to the same conclusions he's reached with mod 9, pencil, paper, and too much free time.
20:03:20 <Nereid> liyang: have a look at IndexedLens
20:03:36 <Cale> chowder: Oh, so perhaps he's really just describing modular arithmetic again
20:03:37 <coldpizza72i> Cale so does expr1 = id +++ literal +++ (op >>= expr1 >>= expr1) ?
20:03:50 <Cale> coldpizza72i: not quite
20:04:48 <Cale> coldpizza72i: actually, I just realised, you probably want to not just have id (btw, id is a confusing name because it's defined in the Prelude as the identity function) and literal to produce Expr values
20:05:11 <chowder> Cale: well I think there's more to it. there are certain geometrical patterns that appear in multiples of numbers 1-9. I thought it was interesting. Probably worth a look if you're interested. The guy claims that he's close to having one function that can do addition, subtraction, multiplication, and division but I'm not too sure about that. I need to see it to believe it.
20:05:14 <Jetbeard> "Marko Rodin's Vortex Based Mathematics is a revolutionary system involving whole numbers, toroidal constructs and spirituality that explains the science of our Interdimensional Universe."
20:05:33 <Cale> Jetbeard: okay, that's safely ignorable :)
20:05:46 <typoclass> fsvo science ...
20:05:48 <chowder> Jetbeard: yea the guy is kind of kooky. I just like the numbers involved
20:06:01 <coldpizza72i> Cale then what do i want
20:08:11 <Cale> coldpizza72i: so, you can write  literal = do xs <- many1 digit; return (Literal (read xs))
20:08:39 <Cale> coldpizza72i: which, btw, is the same as   literal = many1 digit >>= (\xs -> return (Literal (read xs)))
20:09:02 <Cale> coldpizza72i: do-notation is just syntax sugar for applications of >>=
20:09:12 <coldpizza72i> i like sugar
20:09:28 <Cale> coldpizza72i: and then you can do something similar for the Variable case
20:09:51 <Cale> and then, you had sort of the right idea using +++
20:10:35 <Cale> but you'll want to use something like  do o <- op; e1 <- expr1; e2 <- expr1; return (BinExp o e1 e2)
20:10:36 <Jetbeard> Cale this has changed my life http://vortexmath.webs.com/apps/blog/entries/show/5475132-introduction-to-vortex-based-math-vbm-
20:10:49 <Jetbeard> (changed my life in the sense that now i'm even more late in going to bed and slightly amused)
20:11:32 <Cale> This guy is like a slightly cleverer Time Cube guy.
20:11:48 <typoclass> why don't haddocks read like that :-(
20:12:09 <Cale> typoclass: like what?
20:12:46 <Cale> coldpizza72i: you're also going to want to take care of spaces, I think this will be sort of broken because of that
20:13:35 <Cale> But you can write something like  token p = do v <- p; many1 space; return v
20:14:33 <typoclass> cale: e.g. "Bryan studied all the world's great religions. He decided to take The Most Great Name of Attoparsec (prophet of the Parsec Faith) which is Otto and convert it into code. He did this in an effort to discover the true precise mystical intonation of the The Most Great Name of ParserT ..."
20:14:56 <Cale> typoclass: lol
20:15:00 <typoclass> (adapted from the link)
20:15:45 <Cale> typoclass: That would get tiring quickly, I'll bet
20:18:59 <typoclass> "The significance of the Mayan calender is that 64 is one complete cycle of infinity."
20:21:07 <typoclass> if i buy 64 kg rice, do i get 64 kg or do i get an infinity? if the guy gives me 64 kg, can i sue him since he underdelivered?
20:21:33 <ivanm> typoclass: that statement doesn't mean 64 == infinity
20:21:41 <ivanm> 64 is a complete cycle of infinity
20:21:45 <ivanm> wtf that means, I have nfi :p
20:22:20 <byorgey> typoclass: does the header of  http://hackage.haskell.org/package/split    count? =)
20:22:34 <Nereid> hmm
20:22:56 <Nereid> so with these lens families
20:23:14 <Nereid> http://comonad.com/reader/2012/mirrored-lenses/ <- referring to the "pseudo-haskell" bit
20:23:46 <typoclass> ivanm: we need to find out. it would be fatal if we made any mistakes interpreting the mayan nonsense, otherwise we'd end up with the wrong sort of nonsense, not the original unadulterated nonsense
20:23:59 <ivanm> lol
20:24:22 <typoclass> byorgey: very nice :-D
20:24:26 <Nereid> so simple lens are coalgebras for the comonad corresponding to the adjunction between (,s) and (s ->)
20:24:38 <Nereid> which are both endofunctors of hask
20:24:51 <Nereid> then to generalize to lens families,
20:25:15 <ivanm> byorgey: should "Lo" really be capitalised there?
20:25:25 <Nereid> I guess the "outer" and "inner" things would be objects of Hask^i
20:25:55 <Nereid> and there should be an adjunction between (,inner) and (inner ->), giving a comonad on Hask^i
20:25:57 <Nereid> or something right
20:25:59 <coldpizza72i> Cale I'm still a little confused on how to implement the expr
20:26:41 <byorgey> ivanm: yes
20:26:45 <ivanm> huh
20:26:46 <ivanm> byorgey: in the documentation for chop in Data.List.Split.Internals, is the group example correct?
20:26:58 <ivanm> @type \ xs@(x:_) -> span (==x) xs
20:26:59 <lambdabot> forall a. Eq a => [a] -> ([a], [a])
20:27:03 <ivanm> oh, right, duh
20:27:05 * ivanm facepalms
20:27:07 <rwbarton> @wn thrain
20:27:07 <lambdabot> No match for "thrain".
20:27:10 <ivanm> I was thinking of span as takeWhile
20:27:20 <byorgey> ivanm: you always capitalise Lo when it is functioning as an aorist perogative impersonal intensifier
20:27:27 <ivanm> heh
20:27:31 <byorgey> duh
20:28:20 <rwbarton> I'm going to choose to believe that that documentation change was the only change in version 0.2.0.0.
20:29:10 <rwbarton> Since it clearly merits the version bump.
20:29:15 <byorgey> hehehe
20:29:52 <byorgey> there was also some deprecating of old names and coining of new, as directed by the Supreme Council
20:30:06 <ivanm> for HP-inclusion?
20:30:10 <byorgey> right
20:31:00 <ivanm> Supreme Council == anyone on libraries@ who felt like bitching? :p
20:31:26 <byorgey> in this case, yes =)
20:38:20 * lispy waves
20:38:46 <shachaf> hispy
20:40:22 <ivanm> shachaf: does that make you slaclaf? ;)
20:41:29 <shachaf> ivanm: I once got a package addressed to "SLACLCH BEN-HIHI"
20:41:49 <ivanm> O...K... wtf?
20:42:14 * byorgey gets letters from the Bicycle Coalition of Philadelphia addressed to Brentharm
20:42:20 <byorgey> Brentharm Yorgey
20:42:37 <byorgey> I haven't the faintest idea where they came up with that.
20:42:42 <ivanm> I haven't had anything like that personally
20:42:58 <shachaf> byorgey: Are you sure your last name isn't Byorgey?
20:43:00 <shachaf> Brent Byrogey
20:43:02 <ivanm> but I've had people call my dad Slobodan Milosevic (rather than Slobodan Miljenovic)
20:43:02 <shachaf> Er.
20:43:05 <shachaf> Brent Byorgey.
20:43:21 <byorgey> ivanm: heh, oops.
20:43:27 <rwbarton> byorgey: harm is your middle name
20:43:45 <typoclass> shachaf: i think in england they call it byrogey, in america it's usually ballpointpengey
20:43:48 <ivanm> byorgey: he told them no, that was his uncle in the Hague, but if they needed a hit he could get his uncle to arrange it :p
20:43:55 <ivanm> typoclass: heh
20:44:31 <byorgey> rwbarton: haha, sounds like a line out of some B-grade action movie.
20:44:33 <ivanm> and we had debt collectors knocking on our door for a while because someone in the area had a Yugoslave surname starting with "Mila" and wasn't paying his bills, and thus close enough is good enough, right?
20:44:38 <byorgey> "Harm... is my middle name!"
20:44:59 <ivanm> if Harm was your first name, then you'd be a fighter-pilot-turned-lawyer, right?
20:45:28 <byorgey> ...is that a reference to something?
20:45:54 <shachaf> It's a reference to Harm, the famous fighter-pilot-turned-lawyer.
20:45:58 <statusfailed> from Jag
20:46:01 <statusfailed> JAG
20:46:06 <shachaf> ＪＡＧ
20:46:06 <ivanm> five points to statusfailed!
20:46:12 <statusfailed> five points to google*
20:46:16 <ivanm> heh
20:46:34 <statusfailed> never heard of it :D
20:46:57 <ivanm> precursor show to NCIS
20:46:59 <shachaf> Google has enough points, statusfailed.
20:47:00 <byorgey> JAG.  I see.
20:47:10 <byorgey> is that one of them talking picture shows?
20:47:18 <ivanm> yes, I believe it is
20:47:37 <shachaf> ((talking picture) shows) or (talking (picture shows))?
20:47:42 <shachaf> Hmm, maybe those are the same thing.
20:47:59 <typoclass> shachaf: i think it all has to do with the tv
20:48:02 <coldpizza72i> Cale you still there?
20:48:12 <Nereid> clearly talking, picture, and shows generate an associative subalgebra.
20:48:24 <statusfailed> How to know you're in #haskell....
20:48:36 <Nereid> :c
20:48:39 <statusfailed> :
20:48:41 <statusfailed> :D*
20:48:44 <ivanm> statusfailed: you look at the indicator of which IRC channel you're in? ;)
20:49:03 <statusfailed> hahaha
20:49:41 <shachaf> The quality of the channel is monotonically decreasing?
20:50:26 <statusfailed> only when I chime in
20:50:36 <ivanm> I was about to say that at least that implies it at one point it was of high quality, but realised not necessarily...
21:12:21 <shachaf> Grr, I defined a Show instance in ghci and it was slightly wrong, so I defined another one.
21:12:24 <shachaf> Now they're overlapping.
21:12:32 <shachaf> Is there a way to "shadow" an old instance?
21:12:35 <shachaf> It's just for ghci purposes.
21:12:58 <ivanm> I thought in ghci they overrode the previous one... *shrug*
21:13:00 * hackagebot singletons 0.8.3 - A framework for generating singleton types  http://hackage.haskell.org/package/singletons-0.8.3 (RichardEisenberg)
21:13:00 <ivanm> @hoogle evaluate
21:13:00 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
21:13:00 <lambdabot> Control.Exception evaluate :: a -> IO a
21:13:00 <lambdabot> Control.OldException evaluate :: a -> IO a
21:13:37 <ivanm> OK, that's not what I was hoping for
21:13:52 <shachaf> pureEvaluate :: a -> a
21:13:55 <ben> yo who invented the '>>=' symbol
21:14:18 <lispy> perhaps wadler?
21:14:20 <ivanm> shachaf: nah, I wanted it in IO, but thought it was IO a -> IO a or something
21:14:29 <Nereid> join :: IO (IO a) -> IO a
21:14:32 <sclv> kleene
21:14:44 <lispy> ben: IIRC, it was wadler that suggested using monads for IO in haskell
21:14:45 <ivanm> I just wnated to make sure that the IO value is evaluated
21:14:54 <Nereid> evaluated, or executed?
21:14:57 <sclv> newton
21:15:00 <ben> but that doesn't mean he invented monads :I
21:15:03 <sclv> leibnitz
21:15:09 <byorgey> ben: good question.  maybe http://research.microsoft.com/en-us/um/people/simonpj/papers/history-of-haskell/index.htm  says
21:15:16 <lispy> ben: I thought you asked who invented the notation
21:15:27 <byorgey> ben: the person who invented monads was certainly not the one who invented the >>= notation.
21:15:29 <ivanm> Nereid: as in I'm being a bit paranoid that the value it returns isn't strict :)
21:15:45 <sclv> actually, are we sure it wasn't lawvere or something?
21:16:18 <sclv> like ->->- or the like would be a very reasonable math notation
21:16:23 <ben> lispy: I expect that people notated monads before they tied them to IO
21:16:37 <sclv> and >>= or >>- is just sort of a natural ascii-fication of it
21:16:53 <sclv> >>= is a very ascii/pl notation
21:17:16 <sclv> people knew about substitution forming a monad back in the 60s
21:18:21 <shachaf> Isn't it fun when you're reading code and you think "OK, this code is way too complicated and I don't understand it. I'll just try to write this myself." and then you write it yourself and it's exactly the same?
21:18:25 <byorgey> wadler's original paper "the essence of functional programming" does not use the >>= notation
21:18:28 <shachaf> Except now you understand the original.
21:18:31 <byorgey> it just uses a function called bindM
21:18:42 <byorgey> shachaf: yes, that's fun =)
21:18:50 <shachaf> byorgey: In the darkness?
21:19:10 <byorgey> yep, One Monad to etc.
21:20:06 <lispy> I grew up pronouncing >>= as bind, but I heard someone call it 'then'. (Or was that for >>)
21:20:28 <sclv> >> is then
21:20:35 <sclv> >>= i pronounce "into"
21:20:43 <sclv> and =<< is "from"
21:20:55 <sclv> or "drawn from"
21:20:55 <byorgey> @quote Jacqueline
21:20:55 <lambdabot> No quotes match. That's something I cannot allow to happen.
21:21:08 <shachaf> Uh-oh. printf doesn't work with infinite strings?!
21:21:22 <shachaf> > take 10 $ printf "%s" (repeat 'a') :: String
21:21:30 <lambdabot>   mueval: ExitFailure 1
21:21:30 <lispy> Cale: you managed to get lambdabot working again, so I was thinking, maybe I should upgrade the OS now ;)
21:21:30 <lambdabot>  mueval: Prelude.undefined
21:21:45 <shachaf> lispy: lambdabot isn't working until Control.Lens is imported!
21:21:50 <byorgey> @quote Jacq
21:21:50 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
21:22:02 <lispy> shachaf: I'm sure the appropriate people will accept patches!
21:22:05 <rwbarton> > take 10 $ repeat 'a'
21:22:09 <lambdabot>   mueval-core: Time limit exceeded
21:22:45 <rwbarton> maybe lispy accidentally built ghc with -fstrict
21:23:07 <rwbarton> -fdefer-laziness
21:23:29 <lispy> maybe it's still sucking at linking
21:23:39 <lispy> I don't know if cale rebuilt lambdabot
21:23:42 <rwbarton> > take 10 $ repeat 'a'
21:23:44 <lambdabot>   "aaaaaaaaaa"
21:24:12 <startling> > let f = repeat 'a' in seq f (take 10 f)
21:24:13 <lambdabot>   "aaaaaaaaaa"
21:24:26 <shachaf> I don't believe in the Lazi Ness monster.
21:24:42 <startling> what does seq do in that case?
21:24:52 <shachaf> startling: Not very much.
21:25:11 <shachaf> It forces the first cons cell.
21:25:17 <startling> ah.
21:26:39 <shachaf> rwbarton: I bet you feel like fixing a strictness bug in lens.
21:26:55 <Nereid> > let f = repeat 'a' in seq (last f) (take 10 f)
21:27:00 <lambdabot>   mueval: ExitFailure 1
21:27:00 <lambdabot>  mueval: Prelude.undefined
21:27:02 <o-_-o> Hello I am trying to write a small report about haskell for internal purposes at my work place. What are the libraries worthy of note that need to be mentioned. For example I am going to mention accelerate, repa and conduits.
21:27:14 <Nereid> lens ;)
21:27:26 <Nereid> I dunno.
21:27:30 <o-_-o> Nereid, ok.
21:27:36 <shachaf> u con du it!
21:27:36 <Nereid> don't take advice from me.
21:27:57 <Nereid> don't take any advice from me.
21:28:01 <Nereid> including this one.
21:28:27 <Twey> o-_-o: What do you expect to be using it for?
21:28:55 <lispy> that was odd. My tmux was frozen
21:29:08 <o-_-o> Twey, Actually, I have no idea, my focus was on easing programming for multi-core and GPU kind of architectures.
21:29:38 <o-_-o> But now it has gone beyond my control and this is going to go out to a larger group of people.
21:29:49 <o-_-o> Whose focus might be very different.
21:29:59 <Nereid> lispy: oh, thanks for reminding me. I've been meaning to try out tmux at some point.
21:30:04 <Nereid> all I use is screen.
21:30:23 <bxx> head $ words string <- will this split the string just once?
21:30:23 <Twey> o-_-o: You've covered STM, I take it?
21:30:25 <o-_-o> I just want to write something like "Report on functional programming languages with particular focus on Haskell"
21:30:29 <lispy> Nereid: I just see tmux as a refinement on screen.
21:30:38 <o-_-o> Twey, No, but I plan to.
21:30:46 <o-_-o> Twey, Any documentation on STM.
21:30:52 <o-_-o> s/./?
21:31:05 <Nereid> ?wey, Any etc.
21:31:05 <lambdabot> Unknown command, try @list
21:31:06 <Twey> o-_-o: http://www.haskell.org/haskellwiki/Software_transactional_memory
21:31:26 <Twey> Nereid: Hehe
21:31:27 <Twey> Yes
21:31:33 <Twey> That was my first thought, too.
21:31:44 <byorgey> bxx: you mean operationally?  yes, it will only process the string far enough to find the first word boundary.
21:31:58 <byorgey> > head $ words (repeat "blah ")
21:31:59 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:31:59 <lambdabot>              with actual type...
21:32:06 <byorgey> > head $ words (cycle "blah ")
21:32:07 <lambdabot>   "blah"
21:32:31 <bxx> byorgey ok thought so but I wasn't sure. nice
21:32:32 <o-_-o> Twey, Thank you. :-)
21:32:35 <rwbarton> > head $ words ("blah " ++ undefined)
21:32:38 <lambdabot>   "blah"
21:32:41 <Twey> o-_-o: No problem!
21:33:11 <o-_-o> I am breaking the first rule of Haskell, "Avoid success at all costs".
21:33:24 <o-_-o> By publicising it...
21:33:25 <bxx> rwbarton hah interesting. but how come the compiler doesn't complain about undefined variable?
21:33:29 <lispy> Avoid (success at all costs)
21:33:35 <lispy> o-_-o: the brackets matter
21:33:43 <rwbarton> undefined isn't ... undefined
21:33:44 <rwbarton> er
21:33:47 <rwbarton> @src undefined
21:33:48 <lambdabot> undefined =  error "Prelude.undefined"
21:33:51 <shachaf> bxx: undefined is a defined variable. It's just defined to be an undefined value.
21:33:55 * shachaf may not be helping here.
21:34:01 <bxx> ah I see
21:34:06 <shachaf> > undefined
21:34:07 <lambdabot>   *Exception: Prelude.undefined
21:34:09 <o-_-o> lispy, Hehe...
21:34:09 <shachaf> > blah
21:34:10 <lambdabot>   Not in scope: `blah'
21:34:15 <rwbarton> > head $ words ("blah" ++ undefined)
21:34:16 <lambdabot>   "blah*Exception: Prelude.undefined
21:34:23 <Nereid> in other words
21:34:31 <Nereid> undefined is a value that produces an error when you try to evaluate it.
21:34:43 <rwbarton> not just other, but better
21:34:49 <Nereid> sure.
21:35:22 <Nereid> > words $ "blah blah foo " ++ undefined
21:35:23 <lambdabot>   ["blah","blah","foo"*Exception: Prelude.undefined
21:36:03 <o-_-o> This might be a sensitive topic, but I'll ask anyway apologies in advance.
21:36:29 <o-_-o> I will also be touching upon other FP languages and comparing them to haskell.
21:36:34 <lispy> o-_-o: if you're going to ask for a pony, there is already one on hackage
21:37:27 <o-_-o> lispy, pink pony :-/
21:37:33 <lispy> dang it
21:37:55 <lispy> o-_-o: what was your trolling question?
21:37:58 <Nereid> o-_-o: we don't mind comparisons to other languages because we know you'll find haskell is better :-)
21:38:10 <o-_-o> Anyway, Ocaml does not have as good muti-core support. Erlang is slow for serial programs. Do these still hold good ?
21:38:19 <lispy> ?faq Can haskell beat all the competition?
21:38:19 <lambdabot> The answer is: Yes! Haskell can do that.
21:38:57 <lispy> o-_-o: Haskell scales well to multiple threads within a process.
21:39:31 <lispy> o-_-o: Not sure exactly what you're asking.
21:39:36 <o-_-o> W.r.t haskell reasoning about laziness is harder and cabal needs improvement.
21:39:39 <lispy> o-_-o: have you seen the benchmark game?
21:40:00 <lispy> o-_-o: http://shootout.alioth.debian.org/
21:40:11 <o-_-o> lispy, Yes, the ocaml vm is not multi-threaded or something....?
21:40:53 <lispy> o-_-o: wrt to cabal, I use cabal regularly. I can get non-trivial work done. Is it always pretty? no. Do I complain about cabal? Yes. Do I still use haskell? Yes.
21:41:09 <lispy> reasoning about laziness takes practice
21:41:19 <lispy> It's a new operational model that you're unlikely to be familiar with
21:41:30 <lispy> the natural semantics paper will help
21:41:34 <o-_-o> lispy, Alright.
21:42:08 <Nereid> what paper is that?
21:42:15 <lispy> I may be the wrong person to ask. I'm very entrenched.
21:42:41 <lispy> Nereid: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.35.2016
21:42:53 * Twey never really understood the ‘reasoning about laziness is hard’ complaint
21:42:55 <o-_-o> lispy, no you are very helpful. I will refrence these papers.
21:42:57 <Nereid> thanks
21:43:05 <shachaf> f [] _ = []; f (x:xs) g = Context (g . (:xs)) x : f xs (g . (x:))
21:43:56 <o-_-o> Somewhere I am going to sneak in that the biggest win in Haskell is the awesomely helpful community.
21:44:06 <lispy> heh
21:44:16 <lispy> We pride ourselves on #haskell being actually useful and friendly
21:44:31 <lispy> (the mailing lists and SO as well)
21:44:32 <o-_-o> Quite...
21:45:05 <lispy> o-_-o: if you're doing a language comparison you should checkout the history of haskell paper that byorgey posted
21:45:15 <lispy> I bet it will give you a lot of interesting context
21:45:51 <startling> yeah, the haskell community is great.
21:45:54 <rwbarton> shachaf: is this related to holesOf?
21:46:04 <startling> more so than most languages I've learned.
21:46:08 <shachaf> rwbarton: Yep!
21:46:21 <o-_-o> So how does these new kids like clojure and scala compare.
21:46:28 <o-_-o> s/does/do
21:47:14 <lispy> I can't really comment. I used scala for a term project like 5 years ago and it was terribad in terms of compiler/run-time bugs. I hear that's worked out now.
21:47:29 <lispy> Never looked at clojure
21:47:53 <o-_-o> Yeah, I haven't kept up on them to comment on them.
21:48:27 <Twey> o-_-o: Clojure is dynamically-typed
21:48:49 <Twey> Probably one of my favourite Lisps, but you can't really compare it to Haskell
21:49:20 <rwbarton> @src sequence
21:49:21 <lambdabot> sequence []     = return []
21:49:21 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
21:49:21 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
21:50:08 <rwbarton> shachaf: my solution to that "wiggle" problem that roconnor wrote the holesOf solution to is also not lazy
21:50:25 <rwbarton> (where by "my" i mean "the one i read about in some paper")
21:50:39 <shachaf> I don't think I actually looked at the wiggle problem.
21:50:50 <rwbarton> it's actually the only way I morally understand holesOf
21:51:32 <rwbarton> http://www.reddit.com/r/haskell/comments/11mnw5/wiggling_sums_a_somewhat_interesting_traversable/
21:52:43 * liyang wrote a lens! \^_^/
21:53:31 <shachaf> liyang: Hooray!
21:53:34 <shachaf> Is it a good lens?
21:54:20 <spaceships> interesting, haskell ranks 4 under perl/python/ruby for best library distribution system: http://hammerprinciple.com/therighttool/statements/this-language-has-a-good-library-distribution-mech
21:55:53 <callen> spaceships: clearly they haven't used leiningen. or cabal.
21:56:35 <spaceships> callen: hows leiningen? thats for clojure right?
21:56:55 <espringe> yeah, lein is clojure
21:57:04 <callen> spaceships: lein is freaking amazing.
21:57:22 <espringe> startup time sucks, but other than that lein is good
21:57:27 <o-_-o> http://jnordenberg.blogspot.in/2012/05/my-take-on-haskell-vs-scala.html in this article, the author says Haskell module system is primitive. What does he mean ?
21:57:33 <spaceships> ill have to give it a whirl
21:57:46 <callen> I would kill for a leiningen for Haskell.
21:57:54 <liyang> shachaf: https://github.com/liyang/enumfun/commit/0bb41da1ec2a524119af56bfe1eb2275d2340f74
21:57:57 <callen> it's a hybrid of virtualenv/hsenv and pip/cabal
21:58:00 <callen> it's soooo good.
21:58:10 <lispy> o-_-o: our module system does pretty much the bareminimum
21:58:20 <lispy> o-_-o: no private/protected/public/abstract
21:58:21 <espringe> Yeah, me too. Or even sbt is pretty good
21:58:29 <o-_-o> lispy, Ah...
21:58:29 <espringe> I think its just the per-project sandboxing that makes the big difference
21:58:48 <spaceships> oooh
21:58:53 <espringe> And the fact that lein/sbt manage the compiler and compiler version
21:58:58 <espringe> and will fetch the correct one etc/
21:59:07 <callen> calling clojure a compiler is hilarious
21:59:11 <espringe> and take total control over it, and the libraries, on a project-by-project basis
21:59:12 <liyang> shachaf: took me a couple of hours to understand what was going on. ;_;
21:59:13 <callen> it's just a jar.
21:59:29 <espringe> So what?
21:59:35 <espringe> ghc is just a binary
21:59:42 <shachaf> liyang: Oh, an *indexed* lens.
21:59:58 <lispy> o-_-o: Here is what you can do: a) selectively export names, including types (with or without data constructors), type class names (instances are always exported) b) You can selectively import things and say whether it should be qualified. Imports are lazy so you don't have a problem until actual used names are ambiguous, c) you can rexport entire modules from a different module
21:59:59 <callen> espringe: it's a pretty substantial thing to keep in mind. Clojure has far less control over its runtime than Haskell.
22:00:27 <liyang> I started with a Simple Lens, which was easy enough. Then Nereid pointed out that IndexedLenses exist…
22:01:06 <o-_-o> lispy, Please, can I copy and paste that in my paper :-) ? I can't write it any better.
22:01:49 <lispy> o-_-o: I don't mind if you do, but I would encourage you to use your own words
22:02:23 <o-_-o> lispy, I will, definitely, I was just complimenting... :-)
22:05:42 <o-_-o> Does galois have any products ?
22:05:52 <o-_-o> Something big written in Haskell ?
22:06:00 <liyang> o-_-o: if you need to ask, you can't afford it.
22:06:26 <o-_-o> liyang, No, I am not buying, I want to give an example.
22:06:38 <lispy> o-_-o: cryptol
22:07:08 <o-_-o> lispy, Yes, wasn't there some GPS software or something ?
22:07:25 <lispy> o-_-o: not sure what you're thinking of
22:08:24 <o-_-o> lispy, last time I saw the website, there as a picture of a map software or something.
22:08:44 <o-_-o> Are there any other companies other than Galois ?
22:09:35 <lispy> o-_-o: something on this list? http://corp.galois.com/open-source
22:09:38 <callen> o-_-o: a fair number.
22:09:49 <callen> o-_-o: you shouldn't let other people make decisions for you.
22:10:18 <o-_-o> callen, What ?
22:10:46 <o-_-o> callen, Sorry, I do not understand.
22:11:10 <callen> o-_-o: use it if you like it, don't if you don't.
22:11:39 <lispy> callen: I think o-_-o is trying to get a sense of the commercial impact of the language for a report
22:11:39 <o-_-o> callen, You mean Haskell ?
22:11:57 <lispy> o-_-o: http://industry.haskell.org/partners
22:12:00 <o-_-o> callen, this is for a report, an executive summary of Haskell.
22:12:23 <o-_-o> callen, I want to make sure I cover as much ground as possible. Sorry if I offended you.
22:12:25 <lispy> also of interest: http://www.well-typed.com/
22:12:35 <callen> o-_-o: no offense, I misunderstood your needs.
22:13:00 <callen> o-_-o: http://www.haskell.org/haskellwiki/Haskell_in_industry this is the canonical resource for companies using Haskell. Google is using it as well.
22:13:58 <o-_-o> callen, Thank you.
22:14:44 <callen> o-_-o: let me know if you need some background on what Google's using it for. The main answer is "DevOps"
22:14:58 <callen> there is probably at least one or two googlers lurking here, but they're usually reticent.
22:15:14 <callen> I think Google executes engineers that actually talk about their work or something.
22:15:24 <afshar> callen: something like that :)
22:15:58 <o-_-o> callen, Yeah, my friend who introduced me to Haskell joined Google recently.
22:16:04 <callen> afshar: I'm deeply interested in things like colossus. This is something like being deeply interested in Natalie Portman.
22:16:09 <callen> afshar: I can only hear rumors...
22:16:22 <afshar> callen: I know nothing
22:16:31 <afshar> callen: I know nothing;0
22:16:35 <afshar> oops
22:16:36 <afshar> :)
22:16:40 <callen> yeah, sure, whatever. See no evil, hear no evil.
22:16:51 <afshar> DO no evil, I think it is
22:16:59 <afshar> ;)
22:17:02 <o-_-o> callen, What is colossus ?
22:17:04 <afshar> sorry, I am being silly
22:17:05 <callen> the only people nearly as reticent are Facebookers. Which is even dumber because they don't have near as much bespoke infrastructure.
22:17:20 <callen> o-_-o: an orgasm in the form of a distributed filesystem.
22:17:40 <o-_-o> callen, Is there any information on it ?
22:17:44 <callen> o-_-o: god if only.
22:18:02 <o-_-o> callen, Ah...GFS
22:18:03 * hackagebot dbus 0.10.4 - A client library for the D-Bus IPC system.  http://hackage.haskell.org/package/dbus-0.10.4 (JohnMillikin)
22:18:08 <Nisstyre> Is it worth it to use type arithmetic to check if an integer is positive or not (for a data constructor)? There's no sensible interpretation of a negative value for it, and I don't know how to handle it at runtime...
22:18:16 <callen> you can read the brag-session that takes the form of a white paper, maybe try to piece together a mental picture of it.
22:18:31 <Nisstyre> I suppose I could just use Maybe and have a message bubble up to the user
22:18:35 <o-_-o> callen, link ?
22:18:37 <afshar> callen: I guess it's not a secret, the toys here are pretty incredible
22:18:58 <callen> afshar: you know I actually live 5 minutes away from the plex?
22:19:00 <o-_-o> callen, BigTable ?
22:19:03 <callen> afshar: your people raid my gym regularly.
22:19:16 <afshar> callen: cool, where? I live in Santa Clara
22:19:39 <callen> afshar: mountain view
22:20:04 <lispy> > do no evil
22:20:05 <lambdabot>   Just "evil"
22:20:19 <lolcathost> @type no
22:20:21 <lambdabot> forall a. a -> a
22:20:45 <lispy> :t L.no
22:20:47 <lambdabot> forall a. a -> a
22:20:48 <lispy> :t L.evil
22:20:52 <lambdabot> Maybe [Char]
22:20:54 <o-_-o> callen, Was colossus written in Haskell ?
22:20:56 <lispy> those are just things I set with @let
22:21:18 <callen> o-_-o: haha, no.
22:21:44 <o-_-o> callen, That would've been awesome and scary at the same time.
22:21:50 <afshar> callen: of course a load of haskell geeks at google, as there would be in any high nerd concentration place
22:22:08 <callen> afshar: I guess? there aren't nearly as many haskell enthusiasts at FB from what I can tell.
22:22:19 <afshar> well, no idea about that
22:22:26 <callen> afshar: it seems somewhat specific to Google, partly because they steal more phids.
22:22:40 <afshar> funny, "steal" :P
22:23:33 <callen> afshar: Google doesn't hire people, they accumulate their homo sapien collection. You even employ one of the original engineers that worked on the Macintosh. Plus Ken. Plus Pike. and all the other famous programmers. That's just vanity, come on. :P
22:25:05 <liyang> And the author of Vim.
22:25:20 <callen> Moolenaar?
22:25:34 <liyang> Yeah, I think he works for G.
22:25:45 <callen> not surprising, since they use vim extensively.
22:26:00 <liyang> Any self-respecting programmer would.
22:26:03 <callen> Google is explicitly a vim and dog company. I'm an Emacs and cat person. It's just not a good fit :)
22:26:07 * callen hisses at liyang 
22:26:18 * liyang is vim and cat.
22:33:05 * hackagebot shakespeare 1.0.2 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.2 (MichaelSnoyman)
22:33:06 * hackagebot shakespeare-css 1.0.2 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.2 (MichaelSnoyman)
22:33:09 * hackagebot shakespeare-js 1.0.1 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.1 (MichaelSnoyman)
22:34:07 <startling> so I've got this Monad that's a writer for my Tree and a reader for my Tree
22:34:28 <startling> the idea is that I run a bunch of these on a single Tree and then mappend the outputs.
22:34:59 <startling> I want to be able to have errors that say "expected a directory at ["a", "b", "c"].
22:35:33 <startling> when that error happens, though, the thing only knows "c". how could I best organize things to wrap their paths around errors?
22:36:25 <startling> should I get rid of the MonadReader instance (because local could get around this) and only give one method to alter the input tree that takes care of this?
22:38:17 <shachaf> Aw, it's not a Reader on the same tree it's Writing?
22:39:06 <startling> correct. that'd just be State, no?
22:39:31 <shachaf> Not really.
22:39:44 <shachaf> It would be a strange recursive thing.
22:39:59 <startling> OH, you mean literally reading on the same thing it's writing.
22:40:04 <startling> yeah that'd be weird.
22:41:58 <copumpkin> fibs!
22:42:21 <startling> oh well, I think spelling it out helped me a bunch. thanks anyway!
23:02:57 <startling> @hoogle (a -> m b -> m b) -> [a] -> m b -> m b
23:02:59 <lambdabot> No results found
23:03:06 <startling> any ideas for that?
23:03:27 <Jafet> :t foldr
23:03:29 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
23:03:46 <startling> ...oh, right.
23:04:00 <startling> I was thinking foldM because of the monad constraint, shouldn't have let that trip me up.
23:04:37 <statusfailed> With haddock, how do I link to a module from another package?
23:04:40 <Jafet> @hoogle (a -> m b -> m b) -> m b -> [a] -> m b
23:04:41 <lambdabot> No results found
23:04:43 <hpaste> callen pasted “Cabal/Yesod failing at life again. sigh.” at http://hpaste.org/77140
23:04:48 <Jafet> Wat
23:06:06 <statusfailed> is it even possible? :\
23:06:11 <gienah> callen: cabal says it wants happy
23:06:13 <startling> yeah, it is, sec.
23:06:21 <Jafet> You can link to an identifier as long as it's in scope
23:06:43 <ivanm> which is annoying when you want to link to an identifier you don't actually refer to in your code
23:06:51 <ivanm> so -Wall says the import isn't necessary
23:07:14 <startling> statusfailed: http://www.haskell.org/haddock/doc/html/ch03s08.html#id566267 <-- Linking to a module is done by surrounding the module name with double quotes:
23:07:20 <statusfailed> Jafet: the "pool" link here is broken http://hackage.haskell.org/packages/archive/riak/0.7.0.1/doc/html/Network-Riak-Connection-Pool.html
23:07:31 <statusfailed> I assumed because it was in a different package
23:07:47 <statusfailed> because it tries to link within the same package
23:08:10 <Jafet> @hoogle Data.Pool
23:08:10 <lambdabot> package pool
23:08:10 <lambdabot> package resource-pool
23:08:10 <lambdabot> package resource-pool-catchio
23:08:13 <callen> gienah: why didn't it install happy?
23:08:35 <sopvop> callen: cabal can't track executables
23:08:44 <gienah> callen: I guess its a feature that it wants you to install happy
23:08:45 <statusfailed> Jafet: yeah but I want to fix the link :P
23:09:20 <callen> cabal: The program happy version >=1.18.5 is required but it could not be
23:09:22 <Jafet> You can, uh, hard link to the pool haddocks on hackage
23:09:25 <callen> still no dice.
23:09:26 <Jafet> I don't know
23:09:47 <Jafet> callen: where did you install happy?
23:09:55 <callen> it's not where, it's what.
23:10:00 <callen> it installed, but it's .10
23:10:07 <callen> the retarded ass cabal thinks 10 < 5
23:10:13 <ivanm> statusfailed: latest Haddock lets you specify names for links...
23:10:23 <ivanm> callen: as in it's 1.18.10 ?
23:10:26 <Jafet> u mad callen?
23:10:28 <ivanm> just check: happy --version
23:10:32 <callen> ivanm: yes.
23:10:38 * ivanm bets callen's PATH is wrong
23:10:57 <callen> ivanm: tell me what to do sensei. I was using the distro provided GHC and cabal.
23:10:57 <statusfailed> ivanm: names for links?
23:10:58 * gienah doesn't want to bet against ivanm
23:11:19 <ivanm> statusfailed: I forget the order, but you can do <foo http://blah.com>
23:11:23 <ivanm> callen: happy --version
23:11:40 <callen> hrm, okay. h/o
23:11:57 <statusfailed> ivanm: but I'd still have to hard link to a specific version, right?
23:11:58 <sopvop> callen: check if ~/.cabal/bin/happy exists, what version it is and wherever it is in $PATH
23:12:17 <Jafet> statusfailed: well, you can hardlink to latest/.
23:12:28 <statusfailed> oh right
23:12:36 <statusfailed> ok, i'll do that
23:12:37 <ivanm> callen: so, if that's the wrong version, and your distro doesn't have a newer one and you thus want to use the one from cabal-install, add $HOME/.cabal/bin/ to your PATH
23:12:45 <Jafet> That means the link will break when pool changes, so it gives you incentive to update your wrapper.
23:13:07 <ivanm> statusfailed: which, of course, assumes that the latest version of the package will always keep it's same module structure, etc. :p
23:13:31 <statusfailed> Yeah but broken module structure will break the docs anyway right?
23:13:58 <ivanm> statusfailed: no, because it would have linked to the latest one haddock built your package against
23:14:41 <callen> ivanm: t'was pathing but the situation there is batty. my .bash_profile *had* ~/.cabal/bin in my path to begin with.
23:14:54 <ivanm> callen: use $HOME, not ~/
23:15:03 <ivanm> because tools don't do shell expansions on ~/
23:15:05 <callen> ivanm: I did.
23:15:12 <callen> ivanm: I wasn't trying to be literal.
23:15:16 <ivanm> ahhh
23:15:18 <statusfailed> .. i'm feeling this isn't even worth fixing anymore :p
23:15:19 <callen> $HOME/.cabal/bin:${PATH}
23:15:25 <ivanm> echo $PATH
23:15:34 <ivanm> ^^ check you've set it properly
23:15:40 <callen> ivanm: the path *was* wrong, I'm just saying that I don't understand what's going on with the bash_profile.
23:15:57 <callen> anyway, yesod installed after I manually mutated my path. ick.
23:16:04 <ivanm> come again?
23:16:17 <statusfailed> huh, I used ~/ everywhere in my path and it works fine
23:16:33 <ivanm> statusfailed: it can fail at times when you call something that calls something that tries to use the PATH
23:16:34 <bxx> how can I get this to compile? http://hpaste.org/77141
23:16:40 <statusfailed> oh I think zsh is expanding it
23:16:53 <ivanm> when it sources it? maybe
23:17:13 <callen> 1: Path was wrong, checked via echo. 2: checked .bash_profile, it was setting path properly. 3: Manually sourced ~/.bash_profile, re-attempted `happy --version`, no dice. 4: Manually mutated path in terminal, then it worked.
23:17:18 <callen> ivanm: make sense?
23:17:31 <ivanm> bxx: what is the type of f ?
23:17:34 <sopvop> bxx: `return $ map f files` or `mapM f files` depending if `f` is IO or not
23:17:53 <ivanm> callen: hmmm.... what did you do wrong with setting your PATH?
23:18:01 <ivanm> I'm curious! ;)
23:18:06 * hackagebot whitespace 0.4 - Whitespace, an esoteric programming language.  http://hackage.haskell.org/package/whitespace-0.4 (HaroldLee)
23:18:58 <bxx> ivanm f is t
23:19:21 <ivanm> bxx: that makes no sense...
23:19:27 <ivanm> what kind of type is `t' ?
23:19:34 <bxx> that's what GHCI made it
23:19:43 <ivanm> so it's not even a function? :/
23:19:55 <ivanm> bxx: you wrote that function, what type do you _expect_ f to have?
23:20:04 <callen> ivanm: sigh, OS overrode my bash init.
23:20:12 <ivanm> callen: ahhh, that's always fun :s
23:20:21 <callen> ivanm: anyway, fixed now. Thank you.
23:20:27 <ivanm> np
23:20:31 <bxx> ivanm does it matter when GHC fails to compile it?  but I want it to be a function that can accepts FilePath
23:20:41 <ivanm> bxx: yes, it does matter
23:20:48 <ivanm> because of sopvop's answer
23:21:04 <statusfailed> oh, trufax.
23:21:23 <ivanm> bxx: I highly suggest you get into the habit of writing the type of your functions (like for mapFiles) before you start implementing them
23:21:42 <bxx> why did sopvop's changes made it compile? I don't get it
23:21:50 <ivanm> now, if your "return ()" is correct and you don't want mapFiles to be useless, my guess is that you want mapFiles :: (FilePath -> IO ()) -> FilePath -> IO ()
23:22:02 <bxx> ivanm I do but the tutorial I'm reading said to not type the main function, so I assumed it would apply to all IO functions
23:22:06 <ivanm> bxx: every line in a do-block (ignoring let statements) needs to be monadic
23:22:16 <ivanm> why wouldn't you provide a type sig for main? :/
23:22:22 <statusfailed> bxx: nope- getDirectoryContents has type IO [FilePath]
23:22:28 <ivanm> bxx: your "map f files" function is _not_ in IO
23:22:30 <statusfailed> ivanm: I think bxx means IO ()
23:22:35 <sopvop> bxx: because your do notations is actually 'getDirectoryContents >>= \files -> map f files >>= return ()'
23:22:41 <statusfailed> or maybe not?
23:22:46 <bxx> ivanm no idea but that's what it said. that it's a convention not to type main
23:22:52 <ivanm> mapFiles f dir = do { files <- getDIrectoryContents dir; mapM_ f files}
23:23:01 <ivanm> bxx: which tutorial is that?
23:23:13 <bxx> so every line in a do block has to be an IO, hmm
23:23:16 <Jafet> There are bad tutorials for haskell? Damn, we're totally mainstream now.
23:23:25 <bxx> ivanm Learn you hasker for greater good
23:23:29 <sopvop> bxx: if it's and IO monad
23:23:29 <callen> it's really strange how people will use malapropisms, even in white papers published by Googlers.
23:23:31 <bxx> haskell*
23:23:33 <ivanm> bxx: if it's a do-block for IO, then yes
23:23:49 <ivanm> LYAH said not to give main a type sig? :o
23:23:52 <ivanm> where's that?
23:23:59 <bxx> in the IO chapter
23:24:16 <ivanm> conveniently, BONUS isn't around for us to yell at him about it if it's true...
23:24:19 <bxx> http://learnyouahaskell.com/input-and-output
23:24:24 <Jafet> It is true that no one bothers to write the signature for main, but BONUS shouldn't say that.
23:24:27 <statusfailed> wow, it genuinely does say that
23:24:36 <ivanm> Jafet: I do...
23:24:39 <bxx> "Because of that, main always has a type signature of main :: IO something, where something is some concrete type. By convention, we don't usually specify a type declaration for main."
23:24:58 <statusfailed> ivanm: me too, but only because I inevitably will use mapM instead of mapM_
23:25:03 <o-_-o> Erlang can create a lot of green threads very cheaply. Haskell equivalent of that is...?
23:25:04 <ivanm> doesn't -Wall bitch if you don't specify a type for main?
23:25:09 <ivanm> statusfailed: heh
23:25:18 <ivanm> o-_-o: parMap, STM, etc.
23:25:24 <sopvop> o-_-o: Cheap green threads
23:25:28 <ivanm> @hoogle fork
23:25:29 <lambdabot> Control.Concurrent forkIO :: IO () -> IO ThreadId
23:25:29 <lambdabot> GHC.Conc.Sync forkIO :: IO () -> IO ThreadId
23:25:29 <lambdabot> GHC.Conc forkIO :: IO () -> IO ThreadId
23:25:31 <statusfailed> o-_-o: "The runtime"
23:25:36 <o-_-o> ivanm, ok
23:25:39 <Jafet> GHC can create a lot of green threads very cheaply
23:25:52 <ivanm> there's a way of using OS-level processes, but most people use green threads
23:26:06 <o-_-o> Can these green threads be scheduled on something like the Intel MIC  or GPUs ?
23:26:34 <o-_-o> <Context> I am writing an internal report on Haskell </Context>
23:26:42 <Jafet> No, because no one has done it and it would be hard.
23:26:50 <o-_-o> Jafet, ok.
23:26:58 <statusfailed> What's MIC?
23:27:14 <sopvop> mega-multi-core-thing
23:27:21 <Jafet> A way to not mention "larrabee".
23:27:23 <o-_-o> http://www.google.co.in/url?sa=t&rct=j&q=&esrc=s&source=web&cd=1&cad=rja&ved=0CB8QFjAA&url=http%3A%2F%2Fwww.intel.com%2Fcontent%2Fwww%2Fus%2Fen%2Farchitecture-and-technology%2Fmany-integrated-core%2Fintel-many-integrated-core-architecture.html&ei=sGeTUNGeGYXlyAHc_IDoBA&usg=AFQjCNGHZJUugCWw7yz-C0XwRMw0GXV9iQ
23:27:35 <o-_-o> statusfailed, http://www.intel.com/content/www/us/en/architecture-and-technology/many-integrated-core/intel-many-integrated-core-architecture.html
23:27:38 <statusfailed> I can't get through the marketing gumph on their website, does "ushers in a new era of supercomputing speed, performance, and compatibility" mean "We did what NVIDIA did"?
23:27:45 <ivanm> heh
23:27:47 <bxx> well this compiled but calling it with print and a path did not print anything.   mapFiles f dir = do files <- getDirectoryContents dir; return $ map f files
23:27:58 <ivanm> bxx: because your types are wrong
23:28:09 <o-_-o> statusfailed, pretty much, but it is supposed to be x86 compatible.
23:28:10 <sopvop> But MIC uses x86 instruction set (of sorts)
23:28:17 <bxx> then why am i not getting errors?
23:28:31 <ivanm> as sopvop and I said, the answer depends on what you want to do
23:28:36 <sopvop> :t print
23:28:37 <lambdabot> forall a. Show a => a -> IO ()
23:28:39 <sopvop> :t map
23:28:40 <statusfailed> o-_-o: whyyyyyyyyyyyyyyyyyyyyy :D
23:28:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:28:47 <bxx> I want to print files in a home dir.  mapFiles print "~/"
23:28:49 <ivanm> bxx: in your case, that line would have created a value of type IO [IO ()]
23:28:51 <ivanm> but didn't evaluate it
23:29:00 <Jafet> oo: there are CUDA and OpenCL bindings in Haskell, if you want to use video cards.
23:29:07 <ivanm> bxx: mapFiles :: (FilePath -> IO ()) -> FilePath -> IO ()
23:29:29 <ivanm> mapFiles f dir = do { files <- getDirectoryContents dir; mapM_ f files {
23:29:31 <ivanm> bxx: ^^
23:29:35 <statusfailed> o-_-o: There are also libraries like Accelerate, but basically limited to big numeric operations I think
23:29:38 <ivanm> lrn2use the type system
23:30:05 <Jafet> GPU kernels only run big numeric operations.
23:30:16 <statusfailed> Jafet: yeah that's a fair point :|
23:30:28 <sopvop> Types first - is like unit tests first, but much better!
23:30:35 <bxx> that worked. no idea why, but it did.
23:30:38 <statusfailed> Jafet: I was comparing it in my head to DPH
23:30:38 <o-_-o> statusfailed, Yes, I am writing about that. But I was just wondering if green threads can be scheduled on cores.
23:30:59 <shachaf> They can only be scheduled on pencil and paper, unfortunately.
23:31:06 <ivanm> bxx: OK, let's consider the version with "return $ map f files"
23:31:11 <ivanm> @type map
23:31:12 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
23:31:13 <sopvop> bxx: Stop using `do` notation for now.
23:31:23 <ivanm> ^^ this creates a list of values, in this case [IO ()]
23:31:34 <ivanm> return then puts that into the IO monad: IO [IO ()]
23:31:38 <sopvop> :t map print
23:31:39 <lambdabot> forall a. Show a => [a] -> [IO ()]
23:31:40 <ivanm> but you're not _doing_ anything with that
23:31:46 <ivanm> @type mapM
23:31:47 <lambdabot> forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
23:31:52 <bxx> ah. so that is why it never ran print,
23:31:58 <o-_-o> shachaf, ah :-(
23:32:01 <ivanm> bxx: ^^ mapM says "map these monadic actions over the list"
23:32:04 <ivanm> @type mapM_
23:32:05 <lambdabot> forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m ()
23:32:17 <sopvop> :t mapM_ print
23:32:19 <lambdabot> forall a. Show a => [a] -> IO ()
23:32:21 <ivanm> bxx: ^^ mapM_ "map these monadic actions over the list, but discard the results"
23:32:55 <ivanm> @type map print
23:32:56 <lambdabot> forall a. Show a => [a] -> [IO ()]
23:32:58 <ivanm> @type mapM print
23:32:59 <lambdabot> forall a. Show a => [a] -> IO [()]
23:33:04 <ivanm> @type return . map print
23:33:05 <lambdabot> forall (m :: * -> *) a. (Monad m, Show a) => [a] -> m [IO ()]
23:33:11 <bxx> I actually wanted to write a walk function that walks the tree recursively and calls function on all the files.  would it be more idiomatic to return a list of files instead?
23:33:17 <o-_-o> http://en.wikipedia.org/wiki/Green_threads
23:33:40 <o-_-o> FOr haskell it says citation needed. Is there a citation ?
23:33:42 <shachaf> o-_-o: Where else would they be scheduled, if not on cores?
23:34:03 <o-_-o> shachaf, no can I control the scheduling, was my question.
23:34:13 <Jafet> Maybe you could schedule them in the seeds, or on the rind.
23:34:23 <o-_-o> shachaf, can I say schedule this on 4 cores out of 16 cores.
23:34:23 <shachaf> A little bit.
23:34:29 <shachaf> But why do you want to?
23:34:32 <statusfailed> o-_-o: oh, I think so
23:34:43 <shachaf> (Can you get a nick with less punctuation? :-( )
23:34:52 <ivanm> bxx: you could do a fold over the filesystem tree; see RWH for a chapter on this
23:35:04 <sopvop> o-_-o: Controlled by RTS options, but AFAIK can't be set manually
23:35:10 <statusfailed> o-_-o: http://www.haskell.org/haskellwiki/GHC/Concurrency#GHC_concurrency_specifics
23:35:12 <o-_-o> shachaf, Because I am  in HPC (High-Performance Computing) and sometimes our customers share machines.
23:35:24 <o-_-o> sopvop, Ok.
23:35:35 <ivanm> sopvop: latest GHC lets you set this IIRC
23:35:51 <shachaf> o-_-o: You can tell GHC to use a certain number of OS threads.
23:35:55 <o-_-o> shachaf, Let us say 4 users schedule 4 jobs on a 16 core machine.
23:35:57 <sopvop> ivanm: but you can't say "there threads share 4 cores, and these share 2"
23:36:00 <o-_-o> shachaf, ah...ok
23:36:11 <shachaf> This isn't really related to scheduling green threads *on* OS threads.
23:36:13 <ivanm> sopvop: ahhh, right
23:36:16 <sopvop> o-_-o: http://www.haskell.org/ghc/docs/latest/html/users_guide/using-smp.html#parallel-options
23:36:17 <statusfailed> oh, +RTS -N is threads not cores :\
23:36:20 <o-_-o> shachaf, but can I lock the GHC instance to use a particular set of core.
23:36:23 <o-_-o> cores*
23:36:43 <Jafet> Why do you want to do that? Let your operating system do that.
23:36:49 <statusfailed> Jafet: customers sharing machines
23:36:51 <o-_-o> shachaf, <offtopic> Are you shachaf ben-kiki </offtopic>
23:37:03 <sopvop> o-_-o: try asking in #ghc
23:37:08 <ivanm> o-_-o: I believe he prefers to capitalise his name ;)
23:37:14 <ivanm> most people do, anyway...
23:37:17 <Jafet> statusfailed: then the operating system should do that.
23:37:21 <ivanm> (when used as a name rather than an IRC nick)
23:37:24 <shachaf> o-_-o: Yes -- do I know you?
23:37:29 <o-_-o> ivanm, Sorry Shachaf Ben-Kiki*. :-)
23:37:39 <ivanm> much better! :p
23:37:47 <o-_-o> shachaf, I think we are connected on Google+.
23:37:48 <sopvop> o-_-o: also there is -qa and -qm. check documentation link I posted
23:37:58 * shachaf wonders since when ivanm is the capitalization police.
23:38:19 <ivanm> shachaf: since I'm procrastinating? :p
23:38:22 <Jafet> He capitalized on this capital opportunity
23:38:33 * ivanm groans at Jafet's pun
23:38:40 <statusfailed> *slow clap*
23:38:52 <o-_-o> sopvop, Thank you.
23:39:05 <o-_-o> *groan*
23:43:08 * hackagebot log2json 0.1 - Turn log file records into JSON.  http://hackage.haskell.org/package/log2json-0.1 (HaroldLee)
23:43:09 * hackagebot gitit 0.10.0.2 - Wiki using happstack, git or darcs, and pandoc.  http://hackage.haskell.org/package/gitit-0.10.0.2 (JohnMacFarlane)
23:46:09 <pordan30> is there a collection of combinators capturing the pattern: \f g1 ... gn x1 ... xn -> f (g1 x1) ... (gn xn) - something like a "multi-point" liftM family?
23:46:26 <ivanm> pordan30: Applicative?
23:46:59 <ivanm> @src liftA2
23:46:59 <lambdabot> liftA2 f a b = f <$> a <*> b
23:47:08 <ivanm> ^^ just continue on like that, with more <*> chains
23:47:23 <ivanm> @src liftA3
23:47:23 <lambdabot> Source not found.
23:47:27 <ivanm> bah
23:48:06 <statusfailed> @src liftM3
23:48:06 <lambdabot> liftM3 f m1 m2 m3 = do { x1 <- m1; x2 <- m2; x3 <- m3; return (f x1 x2 x3) }
23:48:20 <statusfailed> where's liftA3 :|
23:48:36 <shachaf> You can probably guess based on liftM3 and liftA2.
23:48:50 <statusfailed> :P
23:49:51 <shachaf> liftA2 > liftA3
23:49:53 <shachaf>    v       v
23:49:55 <shachaf> liftM2 > liftM3
23:50:00 <shachaf> There you go.
23:50:37 <statusfailed> is that one of them fancy category theory diagrams
23:50:42 <startling> haha
23:50:46 <shachaf> No, it's just a regular diagram.
23:52:27 <Jafet> It can't be a category theory diagram, it doesn't have arrows
23:52:35 <shachaf> Jafet: Those are arrows!
23:52:43 <ivanm> Jafet: isn't that what the v and > are meant to be?
23:53:05 <shachaf> liftA2 → liftA3
23:53:06 <shachaf>    ↓       ↓
23:53:08 <shachaf> liftM2 → liftM3
23:53:12 <Jafet> > "v" == "↓"
23:53:13 <lambdabot>   mueval-core: Enum.toEnum{Word8}: tag (56546) is outside of bounds (0,255)
23:53:24 <ivanm> if only zhulikas hadn't joined just then in the middle of the diagram...
23:53:25 <pordan30> ivanm: thanks; i suppose that i'm not comfortable using applicative style with the (-> r) functor; i'll play around with it
23:53:27 <ivanm> ;)
23:53:45 <statusfailed> so to get liftA3 I just need a natural transformation?
23:54:05 <Jafet> shachaf: now you've gone and posted one of those doggoned category theory diagrams
23:54:16 <ivanm> pordan30: there's also the argument to be made if you have that many arguments you want to do that liftM{,2,3,4} don't suffice then maybe you should be more explicit and actually use the variable...
23:54:18 <shachaf> Jafet: That's not a category theory diagram!
23:54:38 <Jafet> pordan30: (-> r) isn't a functor, but ((->) r) is
23:54:43 <statusfailed> shachaf: proof by diagram: http://ncatlab.org/nlab/show/natural+transformation
23:54:47 <statusfailed> it looks the same, therefore it is
23:55:17 <pordan30> Jafet: yes, that's what i meant
23:55:34 <shachaf> statusfailed: Keep going like this and you'll be getting a PROOF BY DIAPHRAGM.
23:55:35 <zhulikas> woops :)
23:55:45 <statusfailed> hahaha
23:56:42 <statusfailed> Is that where you state the theorem so loudly it must be true?
23:57:07 * ivanm prefers proof by intimidation, and proof by iminent authority
23:57:10 <shachaf> That's the one.
23:58:06 <statusfailed> Does proof by intimidation generalize proof by authority?
23:58:36 <ivanm> intellectual intimidation maybe...
23:58:48 <ivanm> oh, and that should have been eminent, not iminent
23:59:02 <statusfailed> oh that makes more sense than imminent
23:59:37 <Nisstyre> {Donald Knuth, Alan Turing, etc...} said it, must be true!
23:59:39 <ivanm> http://www.maths.uwa.edu.au/~berwin/humour/invalid.proofs.html
