00:03:27 <neutrino> if my property has to pass for exactly one input, is it acceptable to make my property something like  prop x = testedFunc [1, 2] == expectedOutput ?
00:04:05 <neutrino> i guess it won't show in the test-framework runner output but i don't see any other simple way
00:11:08 <tikonen_> are there recommended sources or code bases that demonstrate idiomatic haskell use?
00:11:54 <tikonen_> I feel that every author has different way of coding which makes learning from source code hard
00:12:05 <srhb> tikonen_: http://www.haskell.org/haskellwiki/Applications for instance
00:12:06 <shachaf> Maybe it makes learning from source code easy.
00:12:53 <neutrino> tikonen_: i'd say snap framework is good quality code
00:13:48 <tikonen_> thanks, I'll take look into those
00:14:39 <neutrino> @hoogle @?=
00:14:39 <lambdabot> Test.HUnit.Base (
00:14:49 <neutrino> hah
00:15:00 <tikonen_> hardest part is that imports often introduce aliases, overloads etc.. in code namespace and its very hard to know without heavy googling what certain operators and functions are
00:15:41 <tikonen_> and some stuff like !!, <$>, <*>, .|. are hard to lookup with search
00:16:02 <neutrino> yeah that annoys me too
00:16:23 <Rogach> tikonen_: Use hoogle.
00:16:28 <neutrino> that's why you have hoogle which can be accessed here via @hoogle or on a website or by doing /msg lambdabot @hoogle whatever
00:17:22 <tikonen_> thanks, I didn't know about that tool
00:20:39 <neutrino> tikonen_: you also have hayoo which is more thorough but a bit more messy
00:20:52 <neutrino> tikonen_: and of course you can google around the hackage site.
00:22:28 <Nereid> having a local hoogle db is also pretty handy
00:22:36 <tikonen_> neutrino, I've been using mostly hackage
00:22:59 <Nereid> you can tie it in with ghci too
00:23:02 <shachaf> I use mostly Google.
00:23:45 <neutrino> @hoogle .|.
00:23:45 <lambdabot> Data.Bits (.|.) :: Bits a => a -> a -> a
00:23:51 <neutrino> interesting.
00:24:06 <tikonen_> @hoogle <*>
00:24:07 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
00:26:00 <fmap> :t (%%@~)
00:26:02 <lambdabot> Overloaded (Index i) f s t a b -> (i -> a -> f b) -> s -> f t
00:26:20 <Nereid> :i Overloaded
00:26:25 <Nereid> @info Overloaded
00:26:25 <lambdabot> Overloaded
00:26:28 <Nereid> bleh
00:26:30 <Nereid> useless
00:28:07 <fmap> Overloaded is `(c -> f d) `k` (a -> f b)'
00:28:41 <Nereid> oh yeah
00:28:52 <Nereid> I mean I could have looked it up if I was really interested I guess.
00:30:36 <beaky> hello
00:30:48 <beaky> how do you do inheritance in haskell?
00:31:07 <simpson> beaky: Nope.
00:31:17 <beaky> :(
00:31:25 <simpson> beaky: Actually, I could probably be more helpful.
00:31:32 <simpson> beaky: What are you working on or thinking about?
00:31:50 <beaky> thinking of reusing a set of functions
00:31:58 <beaky> while extending a type
00:32:00 <beaky> with a new function
00:32:23 <simpson> Hm. What do you mean by "extending a type?"
00:32:42 <beaky> making a new type that subtypes the old type
00:32:50 <shachaf> There's not such thing.
00:32:52 <beaky> ah
00:33:04 <shachaf> Haskell doesn't have subtyping.
00:33:09 <shachaf> Try asking #anotherlanguage.
00:33:35 <srhb> beaky: If you try to be more concrete about what you want to do, perhaps someone will tell you the Haskell idiom to do so.
00:33:46 <beaky> right I will write up a testcase
00:37:43 <beaky> http://ideone.com/Irc3Rj how do I accomplish that?
00:41:00 <bartavelle> beaky, you probably mean something like OOP inheritance
00:41:05 <beaky> ah right
00:41:09 <simpson> beaky: One way would be to build a typeclass.
00:41:15 <bartavelle> you can do something that mimicks it with a typeclass
00:41:41 <beaky> I read somewhere about some guy facing this type of problem and getting around it using higher-order functions
00:42:58 <Jetbeard> beaky, another way would be to have multiple data constructors: http://ideone.com/4zjtkp
00:43:05 <bartavelle> yes there is probably a more idiomatic way to do it, but I am not seasonned enough to suggest something
00:43:27 <bartavelle> you can reuse accessor names ?
00:43:43 <Jetbeard> I *think* so, I didn't test it
00:43:51 * bartavelle tests it right now
00:43:53 <simpson> You can't reuse those names, AFAIK.
00:44:04 <beaky> yeah it works
00:44:10 <beaky> http://ideone.com/POvh5I
00:44:13 <simpson> Really? Weird.
00:44:15 <Jetbeard> yeah, you can
00:44:45 <Jetbeard> In general you can't, but you can in the limited case of all the things you want to share a name being part of the same datatype
00:45:01 <beaky> yay you solved the expression problem :D
00:45:17 <bartavelle> wow yes it works
00:46:10 <danr> you can reuse field names in records of the same type in the same data type declaration
00:46:17 <shachaf> This is not a solution for the expression problem.
00:46:23 <beaky> it isn't?
00:46:26 <shachaf> Note that thesisGrade is an unsafe function.
00:46:27 <Jetbeard> alternatively, beaky, if you don't need to make a distinction between different types of students, http://ideone.com/ETUQMn
00:46:31 <beaky> ah
00:46:49 <danr> the expression problem also involves "extending the datatype"
00:46:49 <shachaf> It'll crash your program if you use it on a student.
00:46:51 <shachaf> Jetbeard: :-(
00:47:12 <Jetbeard> phantom types + GADTs
00:47:22 <simpson> Or. Or.
00:47:44 <simpson> data Student = Undergrad Int Int | Grad Int Int Int -- Why do you need records?
00:47:50 <bartavelle> test: No match in record selector thesisGrade
00:48:14 <Jetbeard> simpson, you don't need them, but that's now quite confusing unless you write your own accessors
00:48:37 <simpson> Jetbeard: Or I could put a comment next to there, and then continue on with pattern matching.
00:48:45 <beaky> pattern matching ftw
00:48:56 <Jetbeard> data Student = Undergrad { midterm :: D, final :: D } | Graduate { midterm :: D, final :: D, unsafeThesisGrade :: D }
00:49:05 <Jetbeard> thesisGrade :: Student -> Maybe D
00:49:20 <signalsea> floaty question... would you agree most of the handiness of monads depend on their particular implementations of bind?
00:49:28 <Saizan> you can pattern match records too, btw
00:49:28 <simpson> Also: data Grades = Grades Int Int; data Student = Undergrad Grades | Grad Grades Int -- and make Grades a record if you really really want.
00:50:01 <Jetbeard> signalsea, yes: however, for each datatype there's really usually only one implementation that makes sense
00:50:05 <Jetbeard> (ie. satisfies the monad laws)
00:50:39 <Jetbeard> so most of the handiness of monads depends on the specification of monads :)
00:51:39 <shachaf> There are lots of possible instances for some monads.
00:52:54 <signalsea> Jetbeard: Which datatypes are you talking about? yes i get that the "standardization"/overloading is what's useful, but to reiterate my question, is bind essentially the specification's killer feature?
00:54:29 <signalsea> ...because it contains the logic for combining data "annotated" with a particular monad
00:55:58 <Saizan> i think Jetbeard meant the definition of the type of each particular monad by "specification"
00:56:04 <signalsea> ok yes
00:56:24 <Saizan> anyhow yes, (>>=) is reasonably the main part of the Monad interface
00:57:05 <Saizan> it's also what Monad has on top of Applicative
00:57:30 <Jetbeard> http://www.haskell.org/haskellwiki/Functor_hierarchy_proposal this needs to happen
01:00:18 <Saizan> that page has a few problems though
01:03:26 <signalsea> comonads, "a value in context", is this an apt description? can anyone elaborate
01:04:08 <signalsea> i don't get the 'categorical dual' explanation
01:05:11 <srhb> Would having the Functor => Applicative => Monad hierarchy have any practical implications?
01:05:30 <signalsea> btw thanks for answering my other question Jetbeard, Saizan
01:06:38 <signalsea> srhb: less repetitive instance declarations?
01:06:57 <Saizan> instance declarations wouldn't change
01:06:58 <srhb> signalsea: Still one instance for all though, right?
01:07:23 <Saizan> what would change is being able to use Functor or Applicative combinators with just a Monad context
01:07:24 <signalsea> that was just a guess, Saizan likely knows more than i do about the implications
01:07:33 <srhb> True..
01:08:04 <Saizan> (there are also proposals to reduce the overhead of making instances in such situations though)
01:09:42 <Saizan> signalsea: "a value in context" is not a bad start for comonads, but as usual you've to look at the types of the methods and play with some examples of comonads to get the real picture
01:10:22 <Saizan> signalsea: but one shouldn't expect comonads to be a major component in the structure of your code like monads are
01:10:51 <Saizan> signalsea: they are mostly a nice way to deal with extra information about data you are working on
01:11:47 <Saizan> signalsea: if this extra information fits the comonad abstraction :)
01:12:51 <signalsea> Saizan: I wish to do double-dispatch of sorts for inserting ADT 1 into a collection-type field of ADT 2 (a collection of ADT 1) and lenses seem like they'd be indispensible
01:13:09 <signalsea> indispensable, rather
01:14:16 <Saizan> seems like they would help
01:14:58 <neutrino> hey guys, is there a list of all exposed modules by every package?
01:15:02 <signalsea> comonads seem to be a bit of a prerequisite for really getting lenses
01:15:12 <signalsea> in most explanations
01:15:43 <Jafet> > ":\&-\&)"
01:15:45 <lambdabot>   ":-)"
01:16:00 <Saizan> signalsea: i wouldn't think so
01:17:17 <signalsea> Saizan: ok so maybe I am just thinking of ed k's haskell 98 lenses. With Van laarhoven lenses i don't quite see what the functor is for
01:17:28 <neutrino> ooo http://www.fremissant.net/portackage/modules.php
01:17:50 <jimch> Is haskell usable for practical programming?
01:18:12 <randomclown> jimch: No.
01:18:16 <Saizan> signalsea: maybe the derivation would help https://github.com/ekmett/lens/wiki/Derivation
01:18:36 <Saizan> @faq can haskell be used for practical programming?
01:18:37 <lambdabot> The answer is: Yes! Haskell can do that.
01:19:10 <emias> n
01:19:27 * hackagebot project-template 0.1.0.0 - Specify Haskell project templates and generate files  http://hackage.haskell.org/package/project-template-0.1.0.0 (MichaelSnoyman)
01:19:33 <djcoin> Is there a way to get some documentation on functions while being in ghci ?
01:20:38 <bartavelle> djcoin, I suppose you just have to wait a bit for MichaelSnoyman to upload the remaining packages of his IDE ;)
01:20:40 <jimch> I got the impression its more of a academic language, instead of language for real world programming. Am i right?
01:20:45 <Saizan> djcoin: you can use hoogle if you have it installed locally
01:20:51 <Saizan> jimch: nope
01:21:15 <djcoin> bartavelle: Saizan ok thanks for the tips :)
01:21:41 <Saizan> jimch: http://www.haskell.org/haskellwiki/Haskell_in_industry http://industry.haskell.org/
01:21:54 <merijn> jimch: What does "academic language" mean? How do you define "real world programming"?
01:22:03 <pharaun> djcoin: there is haddock and uh i think hoogle
01:22:13 <pharaun> you can tie hoogle in locally i think to your ghci session
01:22:15 <signalsea> Saizan: Does the package use 4 type parameters all over the place to provide polymorphic lenses?
01:22:24 <jimch> merijn: language used to write general purpose programs
01:22:24 <Saizan> signalsea: yep
01:22:28 <merijn> There are people paid to write haskell, and they probably earn quite a bit more than average. Does that qualify as "real world programming"?
01:22:49 <Jafet> Haskell is an abstract research language only used by universities, circuit designers, banks and web services.
01:23:00 <pharaun> hehe
01:23:03 <bartavelle> nice
01:23:14 <startling> signalsea, you can use Simple Something a b to mean Something a a b b
01:23:18 <pharaun> also a few attempts at an kernel in haskell,
01:23:19 <merijn> Jafet: And Google for prototypes...and for statistical analysis by some people :p
01:23:21 <jimch> yes probably. Is haskell suitable for that though? I mean it has some pretry exteme ideas
01:23:21 <bartavelle> (circuit designers?)
01:23:24 <pharaun> also i think a game or two are in haskell also
01:23:32 <startling> xmonad, too.
01:23:33 <pharaun> bartavelle: yes :)
01:23:38 <signalsea> Saizan: Are they to be interpreted as two related pairs of types? which is each type for?
01:23:38 <jimch> lack of mitability. No loops
01:23:44 <Jafet> bartavelle: ok, maybe only one circuit designer (bluespec)
01:23:54 <merijn> bartavelle: The people working in Eindhoven have a circuit design DSL in haskell
01:23:54 <startling> jimch, haskell can have loops and mutability
01:23:56 <pharaun> jimch: what is mitability?
01:24:02 <bartavelle> oh I didn't knew that
01:24:05 <merijn> (Or maybe it was Twente, I forget?)
01:24:08 <jimch> mispelled mutability
01:24:10 <merijn> It compiles/generates VHDL
01:24:23 <startling> loops are common in haskell, we just call them maps or folds or traversals
01:24:30 <jimch> startling: yes? Not what ive heard
01:24:31 <Saizan> signalsea: yes, the first two are about the whole structure, while the second two are about the component of it
01:24:31 <pharaun> jimch: just because its not in your face mutability does not mean it does not exist :)
01:24:46 <pharaun> jimch: storing stuff to a database, storing stuff to a flat file, is a form of mutability
01:24:59 <startling> jimch, ST lets you mutate values safely.
01:25:03 <pharaun> mvars/tvars, ST, etc...
01:25:05 <merijn> pharaun: You're glossing over the existence of IORef's, etc.
01:25:12 <randomclown> Only if they used some syntactial sugar to make the "read/write arrays" in ST less jarring
01:25:24 <startling> it's not common to use them (you don't often need them), but you can.
01:25:32 <signalsea> Saizan: Can you elaborate? I realize the proof's in the pudding but i have seen the docs before and found them terribly accessible
01:25:35 <pharaun> merijn: oh i know :) i was going to get to those also :) i just like to point out that databases/external files can be *considered* mutable state :)
01:25:40 <signalsea> err
01:25:45 <signalsea> not accessible*
01:25:47 <Ralith> jimch: have you considered that "what youve heard" may be a caricature of reality? :P
01:25:58 <merijn> signalsea: The Control.Lens docs, you mean?
01:26:02 <startling> signalsea, shachaf will give you an entire lens tutorial on irc
01:26:02 <Saizan> ?type mapped
01:26:04 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
01:26:23 <Saizan> meh, it expands them
01:26:27 <jimch> Ralith: yes. that is why I'm in here.
01:26:41 <merijn> signalsea: data-lens might be a simpler place to start if you don't need polymorphic update. Once that gets you used to lenses you can more easily get Control.Lens
01:27:09 <signalsea> merijn: Ok, so now i'd like to grok Store, then
01:27:11 <pharaun> jimch: imho to me, what haskell really helps me do, is managing state and managing mutability via all of the tools it provides
01:27:12 <Ralith> jimch: then you will find the most success by listening, and not protesting that the answers to your question disagree with "what youve heard"
01:27:17 <startling> > mapped._1 %~ (+ 20) $ [(0, 'a'), (12, 'b')]
01:27:19 <lambdabot>   [(20,'a'),(32,'b')]
01:27:22 <startling> mapped is so cool.
01:27:38 <pharaun> and by managing these it can go a long way to make my programs more easier to reason about and <insert laundry list of reasons here>
01:27:52 <Jafet> Ralith: but you get fed more that way
01:27:53 <merijn> :t (%~)
01:27:55 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
01:27:55 <jimch> What type of programs do you write in haskell?
01:27:56 <Saizan> signalsea: e.g. "mapped :: Functor f => Setter (f a) (f b) a b" is the lens version of fmap
01:28:00 <startling> merijn, it's over.
01:28:17 <shachaf> startling: By "shachaf" you mean "startling", right?
01:28:24 <startling> merijn, that's the long name of (%~), not a threat.
01:28:43 <Ralith> Jafet: clearly we need to establish a communal food bank to disincentivise such behavior.
01:28:57 <startling> shachaf, not sure how I would make that kind of mistake!
01:29:09 <Saizan> signalsea: it can transform (f a) into (f b) if you tell it how to go from a to b
01:29:29 <randomclown> hmm Control.Lens.Iso has a typo on "isomorphim", missing an s
01:29:50 <merijn> Non-polymorphic over would just be "Setting a a b b -> (b -> b) -> a -> a", right?
01:30:12 <signalsea> Ok i'll have to spend a few moments digesting
01:30:25 <beaky> is there a haskell indent formatter similar to astyle?
01:31:11 <shachaf> randomclown: Thanks! Fixed.
01:31:15 <Ralith> beaky: autoindentation of haskell is not decidable, I think the term is.
01:31:29 <edwardk> shachaf: beat me to it ;)
01:31:48 <beaky> ah
01:31:52 <Ralith> startling: I think the principle is that shachaf explains it to people so as to bootstrap exponential growth of explanations.
01:31:54 <pharaun> jimch: go give the language a try, there's real world haskell, and other examples, look at xmonad, etc :) these are all examples, if you start digging into the tutorials and get stuck we can probably help you
01:31:55 <absence> jimch: just a random example of something real-world: www.leksah.org (not written by me)
01:31:56 <beaky> why not tho
01:32:01 <beaky> though*
01:32:12 <nicoo> Ralith: It's rather that unindented haskell code is ambiguous
01:32:17 <Hail_Spacecake> I want to write a haskell function that takes in a string and transforms it in a way that is not necessarily linear
01:32:28 <nicoo> beaky: Indentation is significant in haskell
01:32:39 <Ralith> nicoo: yes; is that not the implication?
01:32:44 <Hail_Spacecake> so, for instance, sometimes I'll run into a character in the string that requires me to remove characters earlier in the string, that I have already processed
01:32:44 <beaky> ah
01:32:47 <quicksilver> Ralith: that doesn't mean you can't have a prettifier.
01:32:57 <Ralith> quicksilver: certainly, but it won't be "like astyle"
01:32:59 <Hail_Spacecake> so I feel like the standard function x:xs = ... sort of pattern-matching is ill-suitd to the problem
01:33:08 <nicoo> Ralith: Undecidability and ambiguousness are quite different ;)
01:33:08 <quicksilver> Ralith: a prettifier could take haskell code with a "valid" indentation and turn it into a "pretty" indentation (with the same meaning)
01:33:16 <merijn> edwardk: Was I right noting that non-polymorphic "over" would just be "Setting a a b b -> (b -> b) -> a -> a"?
01:33:18 <startling> Hail_Spacecake, are you writing a parser?
01:33:54 <Ralith> nicoo: yes; one concerns the meaning of a particular piece of data, the other concerns decision tasks, right?
01:34:03 <Hail_Spacecake> startling I think a full-blown parser is still more than this project needs
01:34:12 <Hail_Spacecake> basically I want to remove .. in a file path
01:34:29 <Hail_Spacecake> so if I have /home/myname/../file, I want to get rid of .. and whatever is before it
01:34:36 <nicoo> Ralith: roughly, yes
01:34:38 <merijn> Isn't there some existing library function to canonicalise file paths?
01:34:40 <Hail_Spacecake> so, have the function return /home/file
01:34:46 <jimch> absence: Thanks. pharaun I planned on giving it a try, was just curious if it can have a practical benefit too
01:34:52 <startling> Hail_Spacecake: yeah, there's already a thing in System.FilePath
01:34:53 <Ralith> nicoo: was my use of the term not consistent with that?
01:34:55 <nicoo> quicksilver: If you want to normalize indentation, Emacs' haskell-mode can do it
01:35:01 <bartavelle> Hail_Spacecake, there should be a lib function. You can also split by / and pattermatch on (x:"..":xs)
01:35:13 <Ralith> quicksilver: that might be nice.
01:35:14 <bartavelle> well more likely (x:y:"..":xs) ...
01:35:14 <startling> Hail_Spacecake: anyway, the usual way to do this would be to look at two ahead of your place
01:35:16 <Hail_Spacecake> I guess I should see how System.FilePath does it
01:35:24 <nicoo> Ralith: Yes
01:35:30 <Ralith> nicoo: can you elaborate?
01:35:34 <Hail_Spacecake> startling well it's not just looking two ahead, I don't know how many *behind* need to keep track of
01:35:37 <pharaun> jimch: it does, it can be a hard language to get in (depending) but its highly enjoyable :) and it does have some good practical benefits :)
01:35:47 <Hail_Spacecake> at least, not with the standard pattern matching
01:35:51 <quicksilver> nicoo: well I don't want to. I just use haskell-mode to get it consistent in the first place :) I was just remarking that a code formatter isn't an impossible idea.
01:36:03 <nicoo> Ralith: Mind asking me in a few hours (laggish link & lecture doesn't make IRC very useable)
01:36:15 <randomclown> shachaf "An commonly used infix ..." as wel
01:36:17 <bartavelle> Hail_Spacecake, you always only need to remove the previous path element before a .., so if you work on the list of path elements instead of the list of chars, it is simple
01:36:26 <absence> jimch: it is often said that learning haskell makes you a better imperative programmer regardless of whether you end up ever using haskell again, so there's a "catch all" practical benefit in addition to any others :)
01:36:29 <nicoo> ?
01:36:31 <Ralith> nicoo: will be asleep by then; I'll ping you tomorrow if I remember
01:36:32 <Hail_Spacecake> bartavelle ah, that makes sense
01:36:39 <nicoo> Ralith: 'kay
01:36:48 <Ralith> thanks
01:37:15 <bartavelle> Hail_Spacecake, just make sure you don't turn "../../x" into "x"
01:37:30 <edwardk> merijn: you mean over for a simple setter?
01:37:36 <edwardk> :t over . simple
01:37:37 <lambdabot> SimpleLensLike Mutator t b -> (b -> b) -> t -> t
01:37:40 <shachaf> edwardk: Should :<-> move into .Infix?
01:37:43 <shachaf> .Simple, rather.
01:37:44 <edwardk> yep. you are right ;)
01:37:56 <edwardk> shachaf: yes
01:38:00 <merijn> edwardk: Just still trying to figure out how to read the type signatures :p
01:38:23 <bartavelle> absence, that's what I did, but now I am very reluctant to go back to C, even for stuff with important performance constraints (I double the RAM of my workstation to keep doing it in haskell)
01:38:28 <edwardk> crap thats a breaking change. can you just make an issue rather than do the move? we'll push it out in 3.3 but i'd rather do more minor releases first
01:38:57 <absence> bartavelle: that's a side effect ;)
01:39:02 <bartavelle> hehe
01:39:09 <jimch> should i start at learnyouahaskell.com or some haskell.org tutorial (or some other?) currently i know enough to be dangerous in C, C++, C#, Java, python.
01:39:18 <shachaf> Breaking?
01:39:21 <shachaf> Oh compatibility.
01:39:22 <shachaf> OK.
01:39:34 <absence> bartavelle: i'm sure that if you were forced to write C again you'd write better code than before learning haskell
01:39:37 <srhb> (a -> m b) -> (a -> m c) -> m (b, c) -- does this exist?
01:39:40 <bartavelle> jimch, those tutorials are supposed to be pretty good yes
01:39:47 <srhb> Oh, oops.
01:39:56 <absence> jimch: learn you a haskell is great
01:40:03 <bartavelle> absence, ah I am, it is just that I try to do anything in Haskell. I even use Shake instead of make now ...
01:40:20 <canta> another effect might be that one is far more annoyed with non-haskell languages :p
01:40:25 <nicoo> jimch: What do you mean by « dangerous »?
01:40:48 <shachaf> srhb: liftM2 (liftM2 (,))? :-)
01:41:04 <srhb> shachaf: Yes!
01:41:04 <beaky> I love haskell
01:41:05 <edwardk> srhb: You can use (&&&) on a Kleisli arrow to get it
01:41:07 <srhb> :)
01:41:17 <edwardk> :t liftM2 (liftM2 (,))
01:41:18 <lambdabot> (Monad m1, Monad m) => m (m1 a1) -> m (m1 a2) -> m (m1 (a1, a2))
01:41:23 <Hail_Spacecake> wait, what haskell module contains the split function?
01:41:24 <srhb> Oh
01:41:31 <Hail_Spacecake> there's no Data.String.Utils on my system apparently
01:41:50 <edwardk> good one
01:42:05 <srhb> @index split
01:42:05 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
01:42:06 <edwardk> srhb you were missing the last a -> in your type
01:42:12 <srhb> edwardk: Yes, I noticed. :)
01:42:19 <absence> jimch: what you know in those languages may not be all that useful when learning haskell. to me at least it was a bit like relearning programming. it's different, and it takes some time to adjust the brain, but it's good difference that makes you see things in a better way (and that you can bring back to those languages if you don't stay with haskell)
01:42:27 <shachaf> edwardk: This channel has such good type inference that it'll infer the type you meant from the type you wrote.
01:42:30 <srhb> (a -> m b) -> (a -> m c) -> a -> (m (b, c)) is what I meant.
01:43:01 <srhb> shachaf: It's amazing, really. :P
01:43:03 <absence> bartavelle: glad to hear :D
01:44:28 * hackagebot hat 2.7.0.6 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.6 (OlafChitil)
01:44:36 <fmap> :t \f g x -> uncurry (liftM2 (,)) $ f &&& g $ x
01:44:38 <lambdabot> Monad m => (b -> m a1) -> (b -> m a2) -> b -> m (a1, a2)
01:44:53 <merijn> :t return &&& return
01:44:54 <lambdabot> (Monad m1, Monad m) => b -> (m b, m1 b)
01:45:04 <bartavelle> Hail_Spacecake, the haskell platform recently added one
01:45:06 <merijn> :t runKleisli . return &&& return
01:45:08 <lambdabot> (Monad m1, Monad (Kleisli m a)) => b -> (a -> m b, m1 b)
01:45:15 <merijn> hmm, wait...
01:45:16 <shachaf> srhb: If Applicative was defined as in the original paper...
01:45:16 <neutrino> jimch: learn some maths
01:45:23 <Hail_Spacecake> bartavelle a split function?
01:45:39 <merijn> :t runKleisli . (return &&& return)
01:45:40 <lambdabot>     Couldn't match expected type `Kleisli m0 a0 b0'
01:45:41 <lambdabot>                 with actual type `(c0, c'0)'
01:45:41 <lambdabot>     Expected type: a1 b1 (Kleisli m0 a0 b0)
01:45:41 <bartavelle> Hail_Spacecake, http://hackage.haskell.org/package/split
01:45:59 <shachaf> The original definition was something like class Functor f => Applicative f where unit :: f (); pair :: f a -> f b -> f (a, b)
01:46:07 <merijn> fmap: Should be possible to use the Kleisli instance
01:46:16 <bartavelle> Hail_Spacecake, and Data.String.Utils is in missingh
01:46:17 <jimch> absence: yes from the little I've heard haskell is completely different. I am actually struggling to see how you can do anything without real loops, muzability etc. But maybe I'll have fun finding out i guess
01:46:24 <Hail_Spacecake> missingh?
01:46:27 <merijn> :t runKleisli (Kleisli return &&& Kleisli return)
01:46:28 <lambdabot> Monad m => c' -> m (c', c')
01:46:35 <bartavelle> it's a big package with all kind of useful stuff
01:46:39 <merijn> There we go
01:46:40 <Hail_Spacecake> hm, maye I should just write my own split
01:46:46 <Hail_Spacecake> it'd be a good exercise anyway
01:46:56 <merijn> :t on
01:46:57 <srhb> merijn: How so?
01:46:57 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:47:20 <shachaf> @ty on
01:47:22 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
01:47:23 <shachaf> Oh.
01:47:45 <tomeo> Im trying my luck using IO but am having some problems. Could someone please have a look at this function (and compile error) and perhaps point out what I'm doing wrong? http://pastie.org/5339570
01:47:55 <merijn> > \f g -> runKleisli $ (&&&) `on` Kleisli f g
01:47:57 <lambdabot>   Precedence parsing error
01:47:57 <lambdabot>      cannot mix `GHC.Base.$' [infixr 0] and `Data....
01:48:11 <merijn> :t \f g -> runKleisli ((&&&) `on` Kleisli f g)
01:48:12 <lambdabot>     Couldn't match expected type `Kleisli m0 a0 b0'
01:48:13 <lambdabot>                 with actual type `a1 -> a1 -> c0'
01:48:13 <lambdabot>     In the first argument of `runKleisli', namely
01:48:17 <merijn> hmm
01:48:24 <merijn> Clearly my Kleisli-fu is lacking
01:48:34 <absence> jimch: if you can take our word for it that you CAN do anything, you'll have some fun discovering yes :)
01:48:35 <srhb> tomeo: Some code is missing.
01:48:50 <tomeo> awh
01:48:50 <ivanm> srhb: I would say _most_ of the code is missing
01:49:00 <srhb> ivanm: I would not disagree. :P
01:49:00 <ivanm> srhb: no, wait, if you scroll...
01:49:07 <tomeo> ivan\: srhb scroll to the right :/
01:49:13 <tomeo> sorry about that
01:49:21 <ivanm> tomeo: first thing: repeated usage of length and !! is _bad_
01:49:38 <srhb> Huh, I can't scroll to the right there. Use hpaste.org :P
01:49:41 <ivanm> tomeo: secondly, using ">>= return . f" is equivalent to "fmap f"
01:49:48 <quicksilver> tomeo: you can't construct a pure (Phrase -> Phrase) using an IO action like randomRIO
01:50:01 <tomeo> quicksilver: why is that?
01:50:11 <quicksilver> because that is how the type system works.
01:50:23 <quicksilver> randomRIO gives you values 'inside' IO
01:50:45 <quicksilver> so stateOfMind cannot be of the form "return (...blah...)"
01:51:01 <tomeo> quicksilver: so Im way off :)
01:51:32 <fmap> :t \f g -> runKleisli (Kleisli f &&& Kleisli g)
01:51:33 <lambdabot> Monad m => (a -> m c) -> (a -> m c') -> a -> m (c, c')
01:51:34 <quicksilver> yes, you're off in several ways
01:51:41 <quicksilver> and it somewhat feels you're trying to run before you can walk
01:51:43 <srhb> fmap: :)
01:51:57 <tomeo> quicksilver: that is very true :)
01:51:59 <quicksilver> most people find 'do notation' a more comprehensible way to start using IO.
01:52:27 <srhb> I think that's a lie that we keep perpetuating for no good reason.
01:52:38 <quicksilver> well I find it easier to explain, srhb.
01:52:43 <srhb> *nods*
01:52:43 <quicksilver> maybe the fault lies with me.
01:52:46 <ivanm> I think do is easier to explain as well
01:52:59 <ivanm> especially if you take the "let's just teach IO and forget Monads" approach
01:53:10 <ivanm> then slowly build your way up to Monads
01:53:11 <startling> I'm not sure that's a practical approach, though.
01:53:17 <ivanm> and then go "zomg, IO is also a Monad!"
01:53:19 <srhb> Maybe I'm a bad teacher. When I start with do, all code ends up with <- ... for no reason.
01:53:20 <quicksilver> tomeo: the random number is based on some aspect of the 'Phrase' ?
01:53:33 <ivanm> startling: RWH does it that way
01:53:36 <quicksilver> tomeo: it looks like your Phrases are pairs?
01:53:45 <quicksilver> tomeo: really this code needs more context for me to unpick it :)
01:54:00 <quicksilver> tomeo: the definition of Phrase and the type of rulesApply would help.
01:54:16 <tomeo> quicksilver: sec, Ill switch to hpaste
01:57:38 <hpaste> tomeo pasted “code” at http://hpaste.org/77388
01:57:47 <randomclown> I think part of the reason people don't get monads is that practical aspects get introduced too early, people think that <- is some fancy notation for IO code.
01:58:03 <tomeo> quicksilver: http://hpaste.org/77388
01:58:28 <jimch> absence: the thing i like so far is that haskell looks like a dynamic language without the risk of breaking at runtime because you passed an int instead of a stringj
01:59:42 * ivanm wonders why hlint refers to Eta reduction as an error whilst the rest are warnings
02:00:11 <ivanm> tomeo: why do you want stateOfMind to return a function in IO, rather than Phrase -> IO Phrase ?
02:00:55 <randomclown> ivanm: isn't eta reduction removal of the lambda term? How does it apply to that function?
02:01:19 <ivanm> randomclown: look at tomeo's hpaste link; they're all right down underneath
02:01:28 <fmap> ivanm: hlint thinks errors are something you can't resist fixing, but warnings are more arguable
02:01:30 <ivanm> specifically, it's applying it to rulesApply by removing the phr from both sides
02:01:34 <ivanm> fmap: ahhh
02:01:39 <tomeo> ivanm: Thats the definition I've been given. Pretty sure its so it will fit with the rest of the program
02:02:03 <ivanm> tomeo: you were given that type sig? if so, that's a rather weird type sig...
02:02:39 <tomeo> ivanm: well I'm not one to argue with you but yes that's what I was given :)
02:03:30 <tomeo> I tried using this http://rosettacode.org/wiki/Pick_random_element#Haskell
02:04:01 <randomclown> well we could try and pick though the types and then you'll see why it doesn't work in the current state
02:04:18 <tomeo> Can the fact that Im trying to use a lambda expression have anything to do with my problem?
02:04:48 <randomclown> tomeo: No, it's just a type thing
02:05:06 <tomeo> randomclown: Does that mean that Im not way off?
02:05:57 <bxx> my superficial knowledge of monads is catching up with me again.  getting errors:   handleArgs [x] = putStrLn (fromJust =<< findExecutable x)
02:06:35 <ivanm> your usage of fromJust looks wrong there
02:06:37 <startling> bxx: you shouldn't ever use fromJust
02:06:40 <bxx> (fromJust =<< findExecutable x) should give me FilePath, which is a string. why can't I print it?
02:06:49 <bxx> startling ok, but why isn't it compiling?
02:06:50 <ivanm> @type (=<<)
02:06:51 <lambdabot> Monad m => (a -> m b) -> m a -> m b
02:06:55 <ivanm> bxx: ^^ in which Monad? :)
02:07:02 <startling> :t findExecutable
02:07:04 <lambdabot> Not in scope: `findExecutable'
02:07:13 <ivanm> I think you want: findExecutable x >>= putStrLn . fromJust
02:07:23 <startling> yeah ^
02:07:23 <ivanm> startling: and there are valid uses of fromJust IMHO
02:07:31 <ivanm> whether this is one of them is debateable ;-)
02:07:36 <startling> ivanm: yes, but you know if you have one!
02:07:46 <startling> ivanm: by that point you'll be ignoring everyone on irc anyway
02:07:56 <ivanm> heh
02:08:02 <quicksilver> bxx: (fromJust =<< findExecutable x)  wouldn't typecheck
02:08:06 <ivanm> want to see my fromJust-ridden code? ;-)
02:08:14 <quicksilver> bxx: fromJust <$> findExecutable x might do
02:08:26 <ivanm> quicksilver: yeah, but he still can't pass that to putStrLn
02:08:31 <quicksilver> true
02:08:32 <bxx> hmm, why won't it type check?
02:08:32 <ivanm> needs either a do block or <- for that
02:08:46 <ivanm> bxx: play "match the types!" ;-)
02:08:47 <quicksilver> bxx: =<< wants an IO action on the left if it has one on the right
02:08:52 <ivanm> @hoogle findExecutable
02:08:53 <lambdabot> System.Directory findExecutable :: String -> IO (Maybe FilePath)
02:08:54 <startling> bxx, fromJust isn't an a -> IO b
02:09:00 <ivanm> @type (>>=)
02:09:01 <lambdabot> Monad m => m a -> (a -> m b) -> m b
02:09:08 <ivanm> @type (=<<)
02:09:10 <lambdabot> Monad m => (a -> m b) -> m a -> m b
02:09:10 <ivanm> (wrong one)
02:09:13 <ivanm> @type fromJust
02:09:15 <lambdabot> Maybe a -> a
02:09:33 <ivanm> bxx: findExecutable x :: IO (Maybe FilePath)
02:09:55 <absence> jimch: makes for nice, concise code yes. sometimes it's a bit of a challenge to get things to compile (making sure all types match, etc), but when they finally do, it simply works much more often than i've experienced in other languages :)
02:09:59 <ivanm> bxx: in ` f =<< findExecutable x', we need  f :: Maybe FilePath -> IO a (for some a)
02:10:05 <ivanm> but instead we have Maybe a -> a
02:10:11 <ivanm> we have a missing IO!
02:10:19 <hpaste> randomclown annotated “code” with “code (annotation)” at http://hpaste.org/77388#a77389
02:10:50 <bxx> yeah I see
02:10:51 <startling> bxx: you could rewrite it find x = findExecutable x >>= maybe (putStrLn "uh-oh") putStrLn
02:10:55 <randomclown> tomeo: Now you should be able to fix this
02:11:14 <randomclown> tomeo: If you're "not way off"
02:11:32 <bxx> this worked too.  handleArgs [x] = (putStrLn . fromJust) =<< findExecutable x
02:11:38 <tomeo> randomclown: Yes I'm trying to figure out what you mean by that my types are off. Reading my code
02:12:04 <randomclown> randomclown: look at the annotation I posted
02:12:07 <randomclown> tomeo:
02:12:22 <bxx> I'll do fromMaybe "Executable not found" in the actual code
02:12:37 <tomeo> randomclown: thanks, Ill check
02:14:13 <tomeo> Is there a standard way of saying that something is not IO any more?
02:14:28 * hackagebot polimorf 0.4.1 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.4.1 (JakubWaszczuk)
02:14:43 <ivanm> tomeo: give it a different type?
02:14:45 <randomclown> tomeo: IO is herpies, you can't just get rid of it, but you can still have pure computations inside
02:14:55 <ivanm> oh, you mean IO a -> a ?
02:14:56 <ivanm> nope
02:14:59 <ivanm> that's kind of the whole point
02:15:13 <randomclown> Make that monads are herpes
02:15:28 <ivanm> randomclown: even Maybe or lists?
02:15:29 <tomeo> okay randomclown, ivanm. thanks
02:15:48 <Jafet> The dreaded Haskell IO Virus
02:15:54 <startling> bxx: that works
02:16:28 <bxx> by the way do you guys ever use pattern matching for simple CLI args parsing?  like this. http://hpaste.org/77390
02:16:32 <tomeo> The only other way I could see that would rid me of IO is randomizing an element in the list without using IO. However afaik randomizing is kind of the def. of IO.
02:16:33 <randomclown> I think that's how I'll start my monad tutorial
02:16:45 <neutrino> i think we've finally mastered the monad analogy
02:16:54 <randomclown> tomeo: Sec I'll write something out
02:17:09 <neutrino> monads are like herpes, but your space suit protects against burritos
02:17:37 <shachaf> neutrino: Please stop. It's not funny.
02:18:54 * neutrino shrugs
02:21:03 <quicksilver> tomeo: you don't need IO for randomising but you do need *something*. You need to pass in a PRNG state and return the new PRNG state.
02:21:18 <quicksilver> the problem is isomorphic to the IO problem - you can just use a different monad but the issue is the same.
02:21:30 <hpaste> randomclown annotated “code” with “code (annotation) (annotation)” at http://hpaste.org/77388#a77391
02:22:05 <randomclown> umm I meant to type forM not mapM, sorry.
02:22:15 <randomclown> tomeo: but that's close enough
02:22:34 <tomeo> thanks randomclown, Ill have a look
02:23:22 <schattenwesen> hi, have a question there is a pdf describing visual haskell...
02:23:37 <schattenwesen> where is this visual haskell thing http://community.haskell.org/~simonmar/papers/vshaskell.pdf   ?
02:24:20 <tomeo> randomclown: So I can change a monad to a non-monad inside a function?
02:24:36 <startling> tomeo: it depends on the monad.
02:24:40 <tomeo> oh okay
02:24:42 <startling> usually, yes.
02:24:52 <startling> IO is the big exception.
02:25:21 <randomclown> we never really changed a monad to a non-monad
02:25:53 <randomclown> Everything is still in IO, check the types on each expression
02:26:28 <tomeo> oh okay. and I got to learn a new operator $ :)
02:26:58 <Iceland_jack> tomeo: ($) is just a function
02:27:26 <randomclown> :t ($)
02:27:28 <lambdabot> (a -> b) -> a -> b
02:27:31 <Jafet> schattenwesen: probably bitrotted
02:27:46 <Iceland_jack> > head [1,2,3]
02:27:47 <lambdabot>   1
02:27:53 <Iceland_jack> > head $ [1,2,3]
02:27:55 <lambdabot>   1
02:28:14 <Iceland_jack> > head (map succ [1,2,3])
02:28:15 <lambdabot>   2
02:28:18 <Iceland_jack> > head $ map succ [1,2,3]
02:28:20 <lambdabot>   2
02:28:20 <Iceland_jack> Nothing magical
02:28:44 <tomeo> oh okay
02:28:55 <neutrino> schattenwesen: http://stackoverflow.com/questions/2610767/visual-haskell-2008-2010
02:33:45 <Ferdirand> @pl \n -> unfoldr (\l -> (guard.not.null) l >> Just (take n l, drop n l))
02:33:46 <lambdabot> unfoldr . ap ((>>) . guard . not . null) . (Just .) . ap (ap . ((,) .) . take) drop
02:33:54 <Ferdirand> yuck
02:34:34 <shachaf> @ty splitAt
02:34:36 <lambdabot> Int -> [a] -> ([a], [a])
02:35:02 <Pantoufle> :t \n -> unfoldr (\l -> (guard.not.null) l >> Just (take n l, drop n l))
02:35:03 <lambdabot> Int -> [a] -> [[a]]
02:35:36 <Ferdirand> :t  \n -> unfoldr (\l -> (guard.not.null) l >> Just (splitAt n l))
02:35:38 <lambdabot> Int -> [a] -> [[a]]
02:35:40 <Ferdirand> better
02:35:46 <Ferdirand> but yuck still
02:36:07 <tomeo> randomclown: thanks for your help :) now I only have to figure out how to do this in haskell98
02:36:32 <Ferdirand> now to factor out that l using the reader monad, mhhh
02:36:35 <shachaf> @pl unfoldr (\l -> (guard.not.null) l >> Just (splitAt n l))
02:36:35 <lambdabot> unfoldr (ap ((>>) . guard . not . null) (Just . splitAt n))
02:37:03 <randomclown> tomeo: exercise left to reader
02:37:14 <tomeo> randomclown: :)
02:37:34 <Ferdirand> :t \n -> unfoldr ( (guard.not.null) <*> Just.splitAt n )
02:37:36 <lambdabot> Couldn't find qualified module.
02:38:30 <Ferdirand> well that was simpler than expected
02:38:33 <Ferdirand> thanks channel !
02:39:58 <Ferdirand> :t \n -> unfoldr ( (guard.not.null) <*> Just . splitAt n )
02:39:59 <lambdabot>     Couldn't match expected type `Maybe (a0, b0)' with actual type `()'
02:40:00 <lambdabot>     Expected type: Bool -> a1 -> Maybe (a0, b0)
02:40:00 <lambdabot>       Actual type: Bool -> a1 -> ()
02:40:31 <Ferdirand> ah oops
02:41:39 <Ferdirand> :t \n -> unfoldr ( ((>>).guard.not.null) <*> Just . splitAt n )
02:41:40 <lambdabot> Int -> [a] -> [[a]]
02:42:14 <Ferdirand> I'm still surprised there isn't something in Data.List to do that
02:42:36 <Jafet> @hackage split
02:42:36 <lambdabot> http://hackage.haskell.org/package/split
02:43:23 <Jafet> :t \n -> map (take n) . takeWhile (not.null) . iterate (drop n)
02:43:24 <lambdabot> Int -> [a] -> [[a]]
02:45:12 <Ferdirand> .. allright, that's much prettier --'
02:45:28 <Ferdirand> but, it doesn't have monads and applicatives !
02:52:07 <whald> i'm currently having my first try with conduits, and wonder how to make a simple Conduit which counts the bytes that go through a pipe. can s.o. get me started with this?
02:52:22 <randomclown> A split function (Eq a) => a -> [a] -> [[a]], really needs to be in prelude
02:53:15 <whald> (i'm following the second example from http://hackage.haskell.org/packages/archive/http-conduit/1.8.2/doc/html/Network-HTTP-Conduit.html and want to add a progress bar)
02:53:28 <Ralith> the program I want to write really needs to be in prelude
02:53:29 <ivanm> randomclown: split is now in HP
02:53:31 <Ralith> that way I won't have to write it
02:53:36 <ivanm> Ralith: heh
02:53:37 <Ferdirand> :t group
02:53:38 <lambdabot> Eq a => [a] -> [[a]]
02:53:58 <ivanm> there needs to be a dwim :: a -> b function
02:54:01 <ivanm> int he prelude
02:54:57 <Ferdirand> but what threw me off base is that apparently split is not indexed by hoogle ?
02:55:08 <Jafet> ivanm: dwim :: a
02:55:15 <Ralith> whald: your best hope is experimentation and referring to examples.
02:55:31 <Ralith> there don't seem to be a lot of heavy conduit users in here.
02:55:44 <ivanm> Jafet: that would then be "bwiw" (be what I want)
02:55:48 <Jafet> hoogle indexes the standard libraries.
02:55:54 <Jafet> ivanm: do be do be do
02:56:03 <ivanm> I believe by default hoogle indexes the HP
02:56:09 <ivanm> but you can tell it to search other packages as well
02:56:17 <whald> Ralith, is there something wrong with conduit? before I user the curl bindings, but found them a bit clumsy
02:56:43 <Ralith> whald: I think conduit's awesome; it's just that most people don't have the problems it solves.
02:58:15 <whald> Ralith, ok, so I'll try to find out how to do it. thanks for the response!
02:58:48 <Ralith> also, I think at least some people are waiting for edwardk to write his version.
02:59:20 <ivanm> @remember Ralith [why some people don't use conduits/pipes] also, I think at least some people are waiting for edwardk to write his version.
02:59:21 <lambdabot> It is stored.
02:59:29 * hackagebot hspec-expectations 0.3.0.3 - Catchy combinators for HUnit  http://hackage.haskell.org/package/hspec-expectations-0.3.0.3 (SimonHengel)
02:59:53 <Ralith> ^^
03:01:04 <signalsea> what is the purpose of the functor f in "type Lens a b c d = forall f. Functor f => (c -> f d) -> a -> f b", and how exactly do ^$, view etc get an (a -> c) out of a Getting r a b c d, (essentially (c -> r) -> a -> r)?
03:01:26 <hpaste> randomclown pasted “conduits count” at http://hpaste.org/77392
03:01:44 <randomclown> I don't know I'm kinda newb with conduits.
03:01:48 <bartavelle> I have a standalone test.hs executable using persistent TH. When I try to turn this into a proper cabalized library, I get strange compile errors, such as :
03:01:50 <bartavelle> "`Unique' has no constructors (-XEmptyDataDecls permits this)"
03:02:04 <randomclown> whald:
03:02:05 <bartavelle> anybody has an idea of where I should start for debugging this ?
03:02:23 <whald> randomclown, got it, thanks a lot! :-)
03:02:37 <bartavelle> (if I add EmptyDataDecls, ghc seems to never finish compiling and eats a lot of memory)
03:03:32 <bartavelle> I will just get rid of persistent
03:04:55 <bartavelle> argh, there is so much choice, haskelldb, hdbc, hsql ...
03:05:11 <bartavelle> (and persistent)
03:05:24 <ivanm> takusen, {postgresql,mysql}-simple
03:05:33 <ivanm> esquileto (but I think that needs persistent)
03:05:38 <Ralith> signalsea: update your lens package; those type synonyms look old.
03:05:55 <bartavelle> esqueleto is built on top of persistent AFAIK
03:06:50 <bartavelle> let's go with sqlite-simple
03:07:10 <fmap> signalsea: with different functors you get different behaviours
03:07:24 <fmap> http://twanvl.nl/blog/haskell/cps-functional-references might be interesting
03:08:06 <fmap> (and it probably answers your second question)
03:08:19 <signalsea> Ralith: was looking at 2.8 on hackage, switched now
03:08:37 <ivanm> how do I tell Cabal to include my .h file? I already have it listed in Includes: :s
03:08:38 <signalsea> fmap: thanks, i've seen it before but i think i have a bit more of the requisite basics now
03:09:10 <signalsea> fmap: ... so i'll give it a read
03:12:19 <pordan30> can the transitive closure of an arbitrary binary type class with acyclic instances be constructed generically, with a minimum guarantee that type checking is decidable for binary type classes with monomorphic instances? I'm having trouble defining this operation.
03:13:36 <pordan30> (i.e., or does it need to be constructed separately for each class?)
03:14:57 <notdan> Can someone please explain to me, what is the need for this class http://hackage.haskell.org/packages/archive/Boolean/latest/doc/html/Data-Boolean.html ?
03:16:47 <ivanm> notdan: whether there's an actual need is debateable, but _someone_ obviously found a use for it
03:17:04 <pordan30> the class permits the definition of boolean operations over arbitrary types for which the instances make sense? it seems like it could be useful.
03:17:07 <ivanm> there was a discussion earlier that it would be nice if if-then-else, etc. worked for any types with precisely two nullary constructors
03:17:37 <ivanm> I suppose that would make it easier to have custom types for function inputs rather than Bool values
03:18:01 <ivanm> hmmm, I'm beginning to like the concept of that class more and more
03:19:36 <pordan30> it would be really nice to have if-then-else defined: cond :: BoolLike m => (ParamsOfTrueLike m -> r) -> (ParamsOfFalseLike m -> r) -> m -> r, which you could do using type families :)
03:20:04 <pordan30> but that wouldn't be very convenient for true / false, i suppose, because it would require a dummy argument :/
03:20:13 <Ralith> why does the behavior of if-then-else matter so much? Just pretend it doesn't exist and use case instead.
03:20:25 <pordan30> it doesn't
03:20:32 <pordan30> i usually do
03:21:42 <quicksilver> Ralith: although the new multiWayIf is actually quite handy looking
03:21:46 <ivanm> pordan30: "ParamsOfTrueLike" ?
03:22:03 <Ralith> quicksilver: hm?
03:22:31 <pordan30> like: type family ParamsOfTrueLike (m :: *) :: Prod *, or something?
03:22:31 <ivanm> Ralith: it's not just if itself, it's all the other stuff you can do with Bools (namely &&, ||, use them in guards, etc.)
03:22:38 <quicksilver> Ralith: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html#multi-way-if
03:22:57 <Ralith> oh, cool, someone ported cond to haskell.
03:23:02 <quicksilver> sort of
03:23:10 <ivanm> pordan30:  not following why you want that rather than just :: BoolLike b => r -> r -> b -> r
03:23:16 <Ralith> quicksilver: 'sort of'?
03:23:20 <Ralith> looks like a direct port to me.
03:23:21 <ivanm> and I would argue for the first one to be False, as it matches the fold over Bool better
03:23:27 <ivanm> Ralith: cond?
03:23:32 <quicksilver> Ralith: well you could already write cond as a function [(Bool,a)] -> a
03:23:32 <ivanm> @google haskell multiwayif
03:23:33 <pordan30> ivanm: i suppose it would ideally let you generalize the behavior of maybe and either
03:23:36 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/MultiWayIf
03:23:36 <lambdabot> Title: MultiWayIf – Haskell Prime
03:23:39 <ivanm> pordan30: hmmm
03:23:42 <quicksilver> Ralith: and quite a few people did.
03:23:51 <Ralith> ivanm: old, old lisp conditional form.
03:23:53 <quicksilver> Ralith: this makes it a syntactical construct instead of a function.
03:24:09 <Ralith> quicksilver: so, yes :P
03:24:37 <Ralith> ivanm: I'm practicing my smug lisp weenieing.
03:24:48 <ivanm> heh
03:25:48 <Ralith> but yeah, it's sometimes a very useful conditional form indeed.
03:25:57 <Ralith> nice to see it being brought in.
03:26:22 <ivanm> so multi-way if is inline guards via an empty case statement?
03:26:35 <bitonic> Ralith: it's not that useful in haskell, see `case'.
03:26:52 <bitonic> and pattern matching in general
03:27:05 <Ralith> bitonic: it's quite useful to not have to abuse syntax to accomplish your goals.
03:27:14 <Ralith> pattern matching in general doesn't have much to do with it.
03:27:20 <bitonic> Ralith: abuse syntax?
03:27:25 <Ralith> yes.
03:27:26 <int-e> well, saving three tokens does not really seem worth the effort.
03:27:37 <bitonic> Ralith: with case and guards you have a more general cond
03:28:07 <bitonic> I don't see the abuse of syntax
03:28:14 <Ralith> bitonic: turing completeness etc etc
03:28:27 <bitonic> Ralith: what?
03:28:39 <fmap> well if `case undefined of _ | …' isn't syntax abuse then what is?
03:28:43 <int-e> in the same vain 'otherwise' is an abuse of syntax ;-)
03:28:46 <int-e> @src otherwise
03:28:47 <lambdabot> otherwise = True
03:29:09 <bitonic> fmap: 1) why `undefined' 2) you almost never need that in Haskell, which is my original point
03:29:25 <Ralith> bitonic: and you almost never need cond in lisp, but when you do, it's very nice to have.
03:29:45 <bitonic> Ralith: no, in lisp you need it *a lot* more
03:29:52 <Ralith> perhaps you do.
03:29:54 * Ralith doesn't.
03:30:00 <ivanm> int-e: can't recall if I told you or not, but I worked out my GHC config problem
03:30:14 <int-e> ivanm: you told me
03:30:19 <bitonic> because you probably don't have pattern matching.  I guess my point is that pattern matching makes boolean conditional constructs much less used
03:30:22 <bitonic> which is good
03:30:34 <ivanm> OK, so my mind _is_ wandering... :p
03:30:41 <quicksilver> int-e: saving three tokens isn't worth what? I mean, the cost of MultiWayIf seems pretty low.
03:31:11 <Ralith> lots of things can allow you to avoid 'boolean conditional constructs'.
03:31:13 <int-e> quicksilver: the whole process and the added mental burden to haskell beginners
03:31:14 <quicksilver> case () of _ | ... is pretty unaesthetic, it just seems nasty to use () and _ for no purpose.
03:31:37 <quicksilver> and because people found it unaesthetic they used to move things to un-needed where clauses
03:31:53 <quicksilver> foo x where x | ... = blah | .... = blah
03:31:56 <fmap> bitonic: 1) feel free to use () instead of undefined 2) yes
03:32:02 <quicksilver> which is another kind of unaesthetic.
03:32:16 <quicksilver> so, since syntax is all about aesthetics anyway this seems like a (small) plus to me.
03:32:29 <bitonic> quicksilver: I think that adding incompatibilities for what is a corner case is really not worth it
03:32:38 <quicksilver> incompatible with what?
03:32:57 <bitonic> quicksilver: with other compilers or other versions of GHC
03:33:23 <pordan30> not that anyone cares anymore, because the topic is kind of boring, but this is what i'm thinking of: <http://hpaste.org/77395>
03:33:26 <bitonic> or with haskell2010, if you wish
03:33:30 * quicksilver nods
03:33:52 <quicksilver> well it's a fair point, but GHC policy has always been to add extensions freely
03:34:03 <quicksilver> and let people decide whether to use them or standardise them or not
03:34:17 <int-e> quicksilver: Let me put it this way ... I'm not opposed to the change, but I wouldn't invest any time in this.
03:34:23 <ivanm> pordan30: can you add an example on how to use that?
03:34:36 <quicksilver> int-e: probably I agree. Fortunately neither of us had to :)
03:34:51 <quicksilver> int-e: (except we both chose to invest the time required to discuss it. Are we hypocrites then?)
03:35:19 <int-e> quicksilver: Yes, that had occurred to me. Of course we are ;)
03:36:39 <pordan30> ivanm: i annotated the paste with the output of the interpreter with various calls: <http://hpaste.org/77395>
03:37:31 <ivanm> pordan30: OK, I'm confused as to the [*] and '[] usage
03:37:52 <ivanm> is that meant to be type-level lists?
03:38:34 <Ralith> judging by the presence of DataKinds, looks like.
03:38:37 <pordan30> if there's ambiguity, you have to refer to a promoted constructor by prefixing it with a quotation mark
03:39:04 <ivanm> ahhhh
03:39:17 <ivanm> OK, so how would you actually use it if you had more than just a singleton list?
03:39:25 <ivanm> do you have to fold over and use all of those values?
03:40:30 <pordan30> so if you had something like: data MaybeTwo a b = Just a b | Nothing, you would have '[a, b]. the (=>>) family curries the input list so that you can construct the function.
03:42:27 <ivanm> ahhh, so for f :: '[a,b,c] =>> v, f would have to be of type a -> b -> c -> v ?
03:43:24 <pordan30> yeah
03:54:17 <signalsea> type RefF a b = forall f. Functor f => (b -> f b) -> (a -> f a)
03:54:39 <signalsea> get :: RefF a b -> a -> b; get r = getConst . r Const
03:54:51 <signalsea> i expected RefF a b -> a -> a
03:55:04 <signalsea> maybe i am just up too late.. what am i missing?
03:57:05 <signalsea> I thought ((r :: RefF a b) (Const :: b -> Const b)) :: a -> Const a
03:59:20 <Saizan> signalsea: your const lacks an argument
03:59:41 <Saizan> the type, i mean
03:59:58 <Saizan> ((r :: RefF a b) (Const :: b -> Const b b)) :: a -> Const b a
04:00:00 <shachaf> signalsea: The "cool new naming scheme" is type RefF s a = forall f. Functor f => (a -> f a) -> s -> a s
04:00:04 <Saizan> and Const b a ~ b
04:00:23 <shachaf> The "even cooler new naming scheme" is type RefF s t a b = forall f. Functor f => (a -> f b) -> s -> f t
04:00:28 <shachaf> (Er, s/a s/f s/)
04:00:36 <randomclown> Since #math is lacking. If G is cyclic why is aut(G) abelian?
04:03:46 <quicksilver> I don't know a direct proof, randomclown.
04:04:16 <quicksilver> aut(G) has a rather simple form - it's the numbers coprime to |Z| under multiplication
04:04:22 <quicksilver> so it's "obviously" abelian.
04:04:36 <quicksilver> erm |G| not |Z|
04:09:56 <randomclown> automorphism groups and higher order functions...
04:17:30 <yitz> randomclown: if f and g are automorphisms and x is a generator, then f(x)=x^a and g(x)=x^b for some a and b. so (f.g)(x)=(g.f)(x)=x^(a+b). that determines f.g on all other elements too.
04:18:02 <yitz> and g.f
04:19:25 <yitz> oh x^ab. whatever.
04:19:50 <randomclown> yitz: that's a really elegant proof
04:20:13 <yitz> randomclown: thanks. it's pretty straightforward though.
04:20:47 <randomclown> For cyclic groups I should probablly think in terms of generators.
04:22:13 <yitz> randomclown: here on #haskell we would usually prove it differently though. we would create a type for cyclic groups and Arbitrary instances. then we would run quickcheck.
04:22:18 <yitz> but that's neither here nor there.
04:23:39 <shachaf> randomclown would prefer a #agda-style proof.
04:24:08 <randomclown> I'll take prolog thanks
04:24:45 <hpc> sign me up for hoping it works, then making critical systems dependent on unproven code
04:26:17 <Jafet> @quote Jafet hope
04:26:18 <lambdabot> Jafet says: it's more fashionable nowadays to do it [write code] the python way, pretend your code works when you write it and hope it works when you run it
04:29:40 <shachaf> @quote Jafet only
04:29:40 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
04:29:40 <lambdabot> s, phone apps, and web services.
04:30:59 <randomclown> @help
04:30:59 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:31:07 <randomclown> @list
04:31:07 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
04:36:00 <djcoin> I can't understand : drop =<< subtract 10 . length       (taken from http://www.haskell.org/haskellwiki/Simple_unix_tools). First I have a problem with precedence operators (I always struggle to see where are parenthesis needed or not). And second, it seems it passes length of list - 10 to drop, but then where is the list taken from (from the monad I guess?). I would like to rewrite this example using the
04:36:02 <djcoin> more classic >>= (instead of =<<) but struggle too. Any help ? :)
04:36:32 <Jafet> @src (=<<)
04:36:32 <lambdabot> f =<< x = x >>= f
04:37:29 <ivanm> djcoin: in ghci, you can use :info (=<<), etc. to get the precedence of the operators
04:38:14 <ivanm> in this case, (.) has higher precedence than (=<<), so it's equivalent to drop =<< (subtract 10 . length) === (subtract 10 . length) >>= drop
04:38:20 <Jafet> That example may not be completely obvious, because it uses the function monad
04:39:13 <Jafet> @src ((->) e) (>>=)
04:39:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
04:39:19 <Jafet> @src (->) (>>=)
04:39:20 <lambdabot> f >>= k = \ r -> k (f r) r
04:39:46 <ivanm> huh, why does it work for (->), which is _not_ a Monad?
04:39:50 <ivanm> (since the kind is wrong)
04:40:14 <ziarkaen> IS there a better way to do [(a,b,c) | a<-S, b<-S, c<-S] ?
04:40:26 <Jafet> You think @src actually understands any haskell
04:40:31 <shachaf> liftA3 (,,) S S S
04:40:44 <ocharles> or (,,) <$> S <*> S <*> S
04:40:52 <ivanm> Jafet: oh, right, duh
04:40:55 <ocharles> -XTupleSections
04:41:13 <Jafet> I don't see any tuple sections
04:41:16 <ivanm> ocharles: don't need any there
04:41:19 <ocharles> no?
04:41:19 <ivanm> @type (,,)
04:41:21 <lambdabot> a -> b -> c -> (a, b, c)
04:41:25 <ocharles> huh, I did not know that
04:41:32 <ivanm> there's also zip3 rather than liftA3 (,,)
04:41:33 <shachaf> How else would you write (,,)?
04:41:34 <ocharles> I guess I must normally already have a few values for the tuple
04:41:41 <shachaf> ivanm: zip3 is something else.
04:41:49 <ivanm> shachaf: oh, right
04:41:52 <Jafet> \a b c -> (a, b, c), obviously
04:41:55 * ivanm takes this as a sign that he needs to go to bed
04:42:00 <shachaf> @localtime ivanm
04:42:01 <lambdabot> Local time for ivanm is Wed Nov  7 23:41:41
04:42:03 <shachaf> @localtime shachaf
04:42:07 <lambdabot> Local time for shachaf is Wed Nov  7 04:41:44 2012
04:42:11 <shachaf> :-(
04:42:26 <shachaf> @localtime Jafet
04:42:41 <shachaf> Predictable.
04:42:44 <Jafet> I am timeless
04:43:06 <shachaf> @price Jafet
04:43:07 <lambdabot> unexpected "J": expecting number
04:45:00 <ivanm> Jafet: I take it you live right on top of the South Pole then?
04:45:05 <djcoin> sorry ivanm, didn't see your response, thanks ! :)
04:45:09 <ivanm> (seeing as how the North Pole melts during summer)
04:45:27 <ivanm> djcoin: np
04:46:08 <Jafet> It's winter at the north pole.
04:46:29 <gishuel> hi all. what libs haskell have for developing GUI apps? and how about developing on haskell for android and iphone?
04:46:35 <ivanm> Jafet: autumn, actually
04:46:48 <Jafet> Well, it's what some people would call autumn, but we don't have autumny stuff here.
04:47:43 <ivanm> so where do you live when it _is_ summer there?
04:49:20 <Jafet> I moult and migrate
04:49:32 * hackagebot aivika 0.4.3 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.4.3 (DavidSorokin)
04:49:33 <ivanm> and then you _do_ have time?
04:50:16 <Jafet> Nope, unfortunately trans-continental migration takes up all of one's time
04:50:30 <ivanm> *groan*
04:50:45 <shachaf> trans-continental? Which continent?
04:51:58 <Jafet> All of them!
04:52:45 <Jafet> I tend to leave continents as soon as I reach them, lest I spend too much time incontinent.
04:53:04 * ivanm migrates to bed before Jafet cracks any more puns
05:19:32 * hackagebot aivika-experiment 0.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.1 (DavidSorokin)
05:20:46 <beaky> hello
05:21:24 <beaky> http://ideone.com/34rDXK how do I accomplish something similar in haskell?
05:21:36 <beaky> example is in C++
05:22:11 <beaky> I want to add in a bunch of new types, like HighSchoolStudent and KindergartenStudent that reuses all the functions in Student
05:24:25 <randomclown> beaky: you'd use a typeclass
05:24:32 * hackagebot conduit 0.5.4 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.4 (MichaelSnoyman)
05:24:34 * hackagebot resourcet 0.4.2 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.2 (MichaelSnoyman)
05:25:10 <beaky> wouldn't that require that each instance reimplement all the Student functions though?
05:26:15 <beaky> hmm I'll try it out in haskell
05:27:11 <randomclown> beaky: No, because you extend previously declared typeclasses
05:27:17 <fmap> beaky: is there real problem you are trying to solve (as in not writing c++ in haskell)?
05:27:49 <beaky> yes I want to implement a student grader
05:28:54 <Jafet> Does haskell-src-exts supersede haskell-src?
05:31:40 <fmap> beaky: like `studentGrader :: GradableStudent s => s -> Grade'?
05:32:12 <beaky> yes :D
05:32:22 <ocharles> why type class? why not sum type of different types of students?
05:32:32 <beaky> then I can just map studentGrader students
05:32:55 <ocharles> I would just have data Student = HighSchoolStudent | KindergartenStudent, etc
05:33:16 <quicksilver> it's unfortunate that typeclasses contain the 5 letters class in them
05:33:24 <quicksilver> because they're a terrible way to translate C++ classes
05:33:31 <ocharles> and if you have common metadata about them, then data StudentInformation = Student { studentName :: Text, etc } and then data Student = HighSchoolStudent StudentInformation | etc
05:33:41 <beaky> yeah first time I thought they were like smalltalk classes, but then I thought 'ah they are like java interfaces'
05:33:48 <beaky> or C++ abstract classes
05:34:14 <quicksilver> perhaps we should rename them constraintbasedoverloadnamesbutwhateveryoudodontusethemtotranslateaprogramusingcplusplusclasses
05:34:21 <beaky> lol
05:34:22 <quicksilver> not as snappy though.
05:34:33 * hackagebot aivika-experiment-chart 0.1 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.1 (DavidSorokin)
05:34:35 <randomclown> Maybe not translate c++ programs at all
05:34:41 <quicksilver> ocharles's direction is the way I would begin
05:34:49 <quicksilver> based on the limited code you'veshown us
05:34:51 <beaky> I like the name typeclass because its makes it sound like a mathematical group or algebra
05:35:03 <pordan30> can promoted types not be used in class definitions? e.g.: `class T (a :: MyKind) where' will throw: "expected kind `OpenKind' but `a' has kind `MyKind'."
05:35:03 <beaky> mathematical group with an algebra on its objects*
05:37:00 <quicksilver> they are structurally very much like java interfaces, incidentally, but that's not a good way to think of them either.
05:38:57 <quicksilver> typeclasses are there to make overloading possible. in Java that's not relevant because you always have the direct object for your method call present, so there isn't any resolution going on.
05:39:02 <parcs`> pordan30: works for me
05:40:21 <t7> > 270 / 315 * 100
05:40:24 <lambdabot>   85.71428571428571
05:41:11 <pordan30> parcs`: you're right, that was an incomplete example - sorry. it seems to throw the error when `a' is mentioned in a method signature
05:42:15 <parcs`> pordan30: yeah, you can't do that
05:42:42 <parcs`> pordan30: perhaps you want to use 'Proxy a' instead
05:43:39 <pordan30> parcs`: thanks. that's unfortunate. the suggestion to use proxy is helpful, but not really applicable at the moment. :)
05:44:03 <pordan30> (i mean: with the particular problem i'm dealing with)
05:44:46 <beaky> haskell is an awesome programming language imo
05:45:06 <t7> there has not been an awesome programming language yet
05:45:12 <t7> maybe one day
05:45:14 <beaky> no? :(
05:45:16 <Philonous> beaky:  Really, does it inspire awe in you?
05:45:21 <beaky> yes
05:45:21 <parcs`> pordan30: a lifted data constructor is not inhabited by any value
05:45:30 <beaky> I saw the two-liner quicksort
05:45:40 <Philonous> beaky:  Which isn't quicksort
05:45:42 <beaky> right
05:45:50 <beaky> quicksort is a von-neumann hack
05:45:55 <parcs`> pordan30: what is the type of the method signature, and how do you expect the method to work?
05:46:10 <Philonous> beaky:  You can write 2-line quicksort in any language when it's not required to actually be quicksort.
05:46:27 <beaky> languages like haskell are our last hope to break free from the von-neumann programming model
05:46:48 <parcs`> last? i hope not
05:46:56 <zomg> beaky: the what model?
05:46:57 <zomg> :D
05:47:04 <beaky> von-neumann
05:47:25 <beaky> well, not last, but like a great step forward
05:47:43 <ocharles> you can go much further than haskell
05:47:46 <sopvop> all power to multi-tape turing machines!
05:48:10 <ocharles> just look at epigram, agda, coq...
05:48:15 <parcs`> not without losing practicality
05:48:27 <ocharles> sure
05:48:32 <mm_freak> the type system can go further, but for the value level i think that haskell is pretty much the end of the road in the functional world
05:48:39 <ocharles> but i'm just syaing there are other ways to 'escape' that model
05:49:06 <beaky> all other programming languages look like Blub when you program in Haskell
05:49:19 <mm_freak> you may add more syntax sugar and make your type system smart enough that it actually writes your programs for you
05:50:46 <pordan30> parcs`: you're right again, and I see the mistake I was making. I was looking for a variant type, and hoping I could restrict one of the type variables to reflect that it would only be instantiated with such types. i suppose i was confused.
05:51:15 <t7> i there a language with a partial type system?
05:51:23 <t7> maybe a scheme
05:51:28 <bitonic> t7: what does that mean?
05:51:43 <beaky> compare `int i; for (i = 0; i < n; ++i) { xs[i] = xs[i] * xs[i]; }` vs. haskell's `map (\x -> x * x) xs`
05:51:51 <parcs`> pordan30: sounds like something an associated type family can do
05:51:59 <t7> it means you only get a type error when you can prove that 2 things dont unify
05:52:08 <t7> but some std functions can return any type
05:52:09 <pordan30> parcs`: yeah, agreed.
05:52:18 <t7> i read a paper a long time ago
05:52:33 <mm_freak> beaky: that's just a syntax comparison, because you can do the same in C nowadays
05:52:52 <beaky> you can?
05:53:09 <Philonous> beaky:  Haskell isn't the first or the last language that has map
05:53:47 <mm_freak> well, a simple destructive update version:  void map(int (*f)(int), int *array, size_t size);
05:54:00 <beaky> but haskell has broken free from the von-neumann paradigm, whereas all other programming languages are trapped
05:54:06 <quicksilver> that's not the same at all mm_freak
05:54:13 <mm_freak> i know
05:54:15 <beaky> implementing map in those other languages still requires assignment and mutation
05:54:15 <quicksilver> you can only pass named functions to that
05:54:21 <Iceland_jack> beaky: you're being too much of a fanboy
05:54:34 <quicksilver> that's nothing like being able to pass abitrary function expressions
05:54:36 <mm_freak> quicksilver: as said, syntax comparison
05:54:42 <quicksilver> no that's not syntax at all
05:54:45 <quicksilver> that's expressibility
05:55:03 <quicksilver> the fact that C++ doesn't have first-class functions is a deep problem
05:55:05 <Philonous> beaky:  If by "all other languages" you mean "C and Java"
05:55:05 <mm_freak> i mean, it doesn't show the more fundamental things
05:55:09 <quicksilver> not "just syntax comparison"
05:55:24 <mm_freak> haskell gets interesting when you express:  map (^2) [1..]
05:55:39 <mm_freak> not because of the map, but because of the list itself
05:55:47 <quicksilver> that's just your point of view.
05:55:51 <t7> lazyness has its problems too
05:56:02 <quicksilver> I think the ability to construct a function-expression like (^2) is at least as interesting as the infinite list
05:56:11 <mm_freak> i don't think laziness has any more problems than eagerness
05:56:16 <beaky> also, point-free style is impossible in other languages
05:56:18 <quicksilver> in fact, for me that's much more interesting.
05:56:33 <beaky> impossible in von-neumann languages like C and Java*
05:56:49 <mm_freak> quicksilver: imagine a strict haskell dialect…  you would have to write your programs entirely differently
05:56:51 <beaky> whereas it is the norm in a proper, purely-functional language like Haskell
05:56:55 <mm_freak> in particular you wouldn't have an IO monad
05:57:03 <t7> quicksilver: so you are more bothered by syntax than semantics ?
05:57:12 <djcoin> Sorry for this noobish question, but what is the precedence of function application ? Is there a way to get it from ghci, eg: :info (?. I saw it has the highest precedence, hasn't  '.' even superior precedence ?
05:57:42 <quicksilver> t7: I don't think first class functions and the ability to combine expressions into larger functions is a syntactic property.
05:58:03 <mm_freak> djcoin: think of function application having infinite precedence
05:58:09 <Philonous> djcoin:  Function application has the highest precedence. "f x <op> y" is (f x) <op> y
05:58:24 <mm_freak> although that's not quite true…  record syntax has higher precedence
05:59:27 <beaky> yes haskell follows applicative evaluation order
05:59:35 <mm_freak> > runState (return ()) { runState = \s -> ((), s + 1) } 3
05:59:37 <lambdabot>   `Control.Monad.Trans.State.Lazy.runState' is not a record selector
05:59:57 <mm_freak> > runState (return ()) { runStateT = \s -> return ((), s + 1) } 3
05:59:58 <lambdabot>   Ambiguous type variable `t0' in the constraint:
05:59:59 <lambdabot>    (GHC.Base.Monad t0) aris...
06:00:11 <mm_freak> > runState (return ()) { runStateT = \s -> Identity ((), s + 1) } 3
06:00:12 <lambdabot>   Ambiguous type variable `t0' in the constraint:
06:00:13 <lambdabot>    (GHC.Base.Monad t0) aris...
06:00:22 <mm_freak> …
06:00:24 <Philonous> djcoin:  It depends on what you mean by '.', the operator (.) (function application) has lower precedence, in Foo.bar it's just part of the name
06:00:25 <beaky> :D
06:00:52 <Philonous> djcoin:  Excuse me, I meant (.) is function composition, not application
06:00:54 <djcoin> Philonous: I meant (.) for composition.
06:00:57 <beaky> let
06:01:01 <djcoin> (I guess ;))
06:01:22 <Philonous> djcoin:  f x . g is (f x) . g
06:01:35 <Philonous> @type (+) 3 . succ
06:01:37 <lambdabot> (Enum b, Num b) => b -> b
06:02:22 <Neuner> Hey, I'm a Haskell beginner. I have a card object as ghci>c1
06:02:23 <Neuner> Card {rank = Jack, suit = Clubs}
06:02:29 <Neuner> how can I get the rank or suit attribute ?
06:02:36 <djcoin> Philonous: ok, and then as (.) is an infix operator, it is is "turn" to parse the stuff ? Because at first I was wondering why it wasn't (f x .) g which would be a syntax error
06:02:41 <Neuner> fst c1 ? c1.rank ?
06:02:48 <djcoin> s/is is/is his/
06:02:50 <djcoin> its *
06:02:51 <padrian2ss> hello
06:03:12 <Philonous> Neuner:  rank c1
06:03:25 <Neuner> thanks
06:03:43 <padrian2ss> one question about the shorthands (^ 2) in haskell... I know that they replace a lambda expression but the construct is not intuitive
06:04:04 <fmap> @unpl (^ 2)
06:04:04 <lambdabot> (\ a -> a ^ 2)
06:04:10 <padrian2ss> yes
06:04:27 <padrian2ss> fmap: yes (^ 2) => \x -> x ^ 2
06:04:49 <padrian2ss> is this constructed in the compiler grammar?
06:04:52 <yitz> padrian2ss: it's called a "section" - you just leave out one of the arguments.
06:05:13 <padrian2ss> (^2) it's a function
06:05:24 <padrian2ss> so the ^ is a function
06:05:24 <fmap> padrian2ss: that's just syntactic sugar
06:06:04 <FireFly> In what way is it unintuitive?
06:06:07 <yitz> padrian2ss: it is exactly analagous to refering to any partially applied function by its name followed by zero or more of its arguments.
06:06:11 <beaky> > zip [0..] (take 128 ['a'..])
06:06:13 <lambdabot>   [(0,'a'),(1,'b'),(2,'c'),(3,'d'),(4,'e'),(5,'f'),(6,'g'),(7,'h'),(8,'i'),(9...
06:06:25 <beaky> > zip [0..] (take 128 ['\0'..])
06:06:26 <Philonous> djcoin:  I don't know about the details of parsing, but (f x .) g wouldn't even be a syntax error (just not what is meant)
06:06:27 <lambdabot>   [(0,'\NUL'),(1,'\SOH'),(2,'\STX'),(3,'\ETX'),(4,'\EOT'),(5,'\ENQ'),(6,'\ACK...
06:06:33 <padrian2ss> yitz and fmap: yes but I'm trying to understand the concept behind
06:07:36 <padrian2ss> so... (+ 2) == a function + that take 2 and return another function?
06:07:44 <yitz> padrian2ss: are you asking about just section notation for operators, or the concept of partially applied functions in general>
06:07:47 <yitz> ?
06:08:10 <padrian2ss> the section notation.... i know something about partially applied func
06:08:12 <djcoin> Philonous: yeah I was just trying to put (. foo) and (. foo) - and it's great =)
06:08:41 <FireFly> I think yitz' line about it being analogous to partially applied functions is pretty spot-on
06:08:48 <Philonous> djcoin:  Btw. the parens of "(.)" actually make it prefix
06:08:53 <merijn> padrian2ss: Section notation is rather simple "(+2) = \x -> x + 2"
06:09:03 <Philonous> djcoin:  So f . g = (.) f g
06:09:15 <merijn> padrian2ss: And "(2+) = \x -> 2 + x"
06:09:20 <yitz> padrian2ss: (2 +) is syntactic sugar for (+) 2. (+ 2) is syntactic sugar for flip (+) 2.
06:09:21 <Philonous> djcoin:  But maybe I misunderstood what you where saying
06:09:41 <djcoin> Philonous: yep I saw that, this is fun, I already knew you could put (. foo) but not (foo .), this is neat
06:10:20 <padrian2ss> yitz okay so the (+) 2 = like I tought it's a function... thanks
06:10:33 <djcoin> Philonous: My question was, as function application has highest precedence, how come it doesn't "eat" (.) when doing foo x . foo y
06:10:43 <yitz> padrian2ss: and they both make perfect sense. leaving out an argument from an expression like (2 + 3), just like when you partially apply a function in non-operator syntax.
06:11:18 <padrian2ss> I'm watching Philip Wadler class (http://www.youtube.com/watch?feature=player_detailpage&v=XLPDQFZB7Pw) and he is not mentioning about the section notation
06:11:19 <merijn> djcoin: Because the parser knows about operators and thus parses it as you meant
06:11:20 <Philonous> djcoin:  Because it's an infix operator
06:11:38 <merijn> djcoin: If you had written "foo x (.) foo y" it would have happily eaten your (.)
06:12:07 <yitz> djcoin: when not in parens, an operator . is not a symbol that can be eaten. is has special parsing rules, given by infix declarations and their defaults.
06:12:12 <padrian2ss> yitz: yes but I need some name behind the construct since Mr Wadler is calling this shorthand
06:12:24 <padrian2ss> yitz: I needed...
06:12:29 <yitz> padrian2ss: operator sections
06:12:37 <yitz> or just sections
06:12:52 <djcoin> Ok, thanks a lot :) So, and any infix operator benefits from this ?
06:13:16 <padrian2ss> yitz: thanks, http://www.haskell.org/haskellwiki/Section_of_an_infix_operator
06:13:24 <yitz> djcoin: yes, even non-operators made infix with backquotes. like (`mod` 7)
06:13:32 <Philonous> djcoin:  All infix operators are parsed that way, yes.
06:13:48 <djcoin> All right, great, thanks a lot
06:13:51 <FireFly> djcoin: That's pretty much why ($) works for avoiding parens in some cases
06:14:09 <Philonous> djcoin:  There is nothing special about (.). It's just (f . g = \x -> f (g x))
06:15:40 <padrian2ss> yitz: thank you, like allays this chanel is very nice
06:17:19 <padrian2ss> :)
06:18:07 <merijn> lhs2TeX is barfing on some of my LaTeX, any idea at all why it's looking at the non-haskell code anyway?
06:20:14 <kosmikus> merijn: it's interpreting @ and | as special characters, for example
06:20:25 <merijn> Ah, it naively thinks I don't want to use | as a character >.>
06:20:43 <kosmikus> merijn: you can escape | as ||
06:32:11 <beaky> :t add
06:32:12 <lambdabot>     Not in scope: `add'
06:32:12 <lambdabot>     Perhaps you meant one of these:
06:32:12 <lambdabot>       `odd' (imported from Prelude), `and' (imported from Data.List),
06:32:19 <beaky> :t pow
06:32:21 <lambdabot> Not in scope: `pow'
06:33:31 <merijn> beaky: What are you looking for?
06:34:43 <beaky> how do I exponentiate a number
06:34:51 <mm_freak> > 2^1024
06:34:53 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
06:35:03 <EvanR7> > exp 2
06:35:05 <lambdabot>   7.38905609893065
06:35:20 <mm_freak> beaky: what type of exponent?
06:35:35 <beaky> double
06:35:41 <mm_freak> :t (**)
06:35:42 <lambdabot> Floating a => a -> a -> a
06:35:45 <mm_freak> there you go
06:35:55 <EvanR7> > e ** 2
06:35:57 <lambdabot>   e**2
06:36:10 <mm_freak> > 3 ** pi
06:36:12 <lambdabot>   31.54428070019754
06:44:34 * hackagebot fsnotify 0.0.2 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.2 (GregWeber)
06:46:27 <fenton> completely brand spanking new arch system, ala: http://goo.gl/bsEDh, yet darcs cannot install...boo hoo
06:47:38 <beaky> http://ideone.com/CCiwEw anyone want to criticize my code?
06:47:47 <Philonous> > exp pi - pi
06:47:49 <lambdabot>   19.999099979189474
06:47:55 <Philonous> Uh, rounding errors
06:48:12 <Saizan> fenton: arch is known for adopting ghc versions so recent that packages do not build there yet :)
06:48:18 <beaky> right
06:49:07 <fenton> Saizan: ok...hmmm...need to ditch the distro???  wonder what the next move should be???
06:49:16 <beaky> shouldn't the old packages still build on newer versions of ghc though?
06:49:47 <Saizan> fenton: i just install my own ghc from the generic linux tarballs on ghc's website
06:49:50 <beaky> maybe try the ghc included in some other repository (older version of ghc) instead of the one in the official repo?
06:50:38 <fenton> the arch one is 7.6.1, let me check the website versions.
06:51:18 <fenton> hmmm... latest there is same version...7.6.1
06:51:24 <parcs`> there was once a darcs package on arch. not sure why they got rid of that
06:51:32 <Saizan> fenton: right, you don't want the latest
06:51:43 <Saizan> fenton: darcs builds on 7.4.1 apparently
06:52:13 <fenton> Saizan: okay...let me try that.
06:52:21 <parcs`> the question is why doesn't the latest version of darcs build on ghc 7.6.1 yet
06:53:13 <Saizan> the platform is still on 7.4.2, it seems
06:53:57 <fenton> http://darcs.net/Releases/2.8
06:54:36 <fenton> parcs`: it says on that link that 7.4.x
06:54:52 <fenton> is what darcs supports
06:56:02 <quicksilver> beaky: your add/mul etc functions are most repeated code
06:56:38 <beaky> right
06:57:19 <beaky> how do I refactor away the repetition
06:57:52 <quicksilver> beaky: you could have a function called, say, doBinOp which takes two parameters
06:58:09 <quicksilver> one a string (e.g. "+") and one a (Double -> Double -> Double) - e.g. (+)
06:58:52 <quicksilver> obvously sqrt is a bit different.
06:59:32 <beaky> higher-order functions ftw
07:02:57 <beaky> http://ideone.com/fX3PDq refactored :D
07:02:58 <beaky> wow
07:03:46 <beaky> http://ideone.com/OPNToH C++ version for comparison
07:04:20 <fmap> according to colorscheme ideone.com hates haskell
07:04:48 <beaky> GeSHi hates haskell?
07:05:29 <beaky> the new haskell version inspires me to refactor the C++ version
07:05:33 <peteriserins> @djinn ((p -> q) -> p) -> p
07:05:34 <lambdabot> -- f cannot be realized.
07:05:36 <beaky> with templates :D
07:05:48 <beaky> @djinn 1
07:05:48 <lambdabot> Cannot parse command
07:06:05 <quicksilver> beaky: much better, certainl
07:06:09 <peteriserins> @jinn a -> b -> c -> (b -> a -> c)
07:06:09 <nand`> does GHC allow kind synonyms?
07:06:09 <lambdabot> f _ _ a _ _ = a
07:06:29 <peteriserins> @djinn (a -> b -> c) -> (b -> a -> c)
07:06:30 <lambdabot> f a b c = a c b
07:06:43 <beaky> what's djinn?
07:06:49 <nand`> @where djinn
07:06:50 <lambdabot> darcs get http://darcs.augustsson.net/Darcs/Djinn
07:06:51 <peteriserins> beaky: gives you a program that has given type
07:06:58 <beaky> wow
07:07:05 <bartavelle> this is useful
07:07:05 <quicksilver> it uses theorem proving to construct the "canonical" program of a given type
07:07:09 <beaky> it's like prolog?
07:07:18 <quicksilver> which works particularly well for certain kinds of types
07:07:27 <beaky> @djinn Int -> Int -> int
07:07:28 <lambdabot> Error: Undefined type Int
07:07:28 <peteriserins> beaky: it's like constructivist logic inference
07:07:33 <beaky> ah
07:07:50 <nand`> “Djinn interprets a Haskell type as a logic formula using the Curry-Howard isomorphism and then uses a decision procedure for intuitionistic propositional calculus”
07:08:03 <rofer> Is it possible to do a blocking read without openFileBlocking? I'm trying to read from a named pipe and I keep getting EOF because I start the read before a writer is attached.
07:08:41 <quicksilver> haskell reads are normally blocking, rofer
07:09:14 <quicksilver> so that's not your problem
07:09:15 <peteriserins> It's funny that ((p -> q) -> p) -> p has a function if p  = Cont k r
07:09:38 <quicksilver> but I'm not familiar with the semantics of named pipes enough to know how you are supposed to wait for a writer
07:09:52 <peteriserins> @djinn (a -> (b -> c)) -> ((a -> b) -> (a -> c))
07:09:53 <lambdabot> f a b c = a c (b c)
07:09:59 <otters> @pl (\(a,b) -> (b,a))
07:09:59 <lambdabot> uncurry (flip (,))
07:10:02 <merijn> quicksilver: You're not supposed to, I think the writer has to already exist
07:10:14 <peteriserins> :t callCC
07:10:16 <lambdabot> MonadCont m => ((a -> m b) -> m a) -> m a
07:10:29 <merijn> rofer: How come the Writer isn't attached yet?
07:10:34 <Ferdirand> on my system, "mkfifo f; cat f" hangs
07:10:47 <quicksilver> I quote the excellent brandon s allbery : "... POSIX named pipes.  They work, but they don't do what most people think they do, and they're rather annoying to work with in general."
07:10:55 <hiptobecubic> Ferdirand, it's waiting for input.
07:11:12 <hiptobecubic> mkfifo f; echo 1 > f; cat f
07:11:31 <quicksilver> hiptobecubic: the question here is how you wait for a writer if the reader attaches first.
07:11:31 <hiptobecubic> nevermind, also hangs :D
07:11:32 <Ferdirand> hiptobecubic: well it proves that either cat has some built-in logic to detect that, or that reading a fifo blocks when no writer has been attached yet
07:11:59 <quicksilver> rofer hasn't commented since his initial question
07:12:05 <hiptobecubic> ah i see
07:12:11 <quicksilver> but I wonder if a unix domain socket is a better solution
07:12:24 <quicksilver> since that supports 'accept' for (sort-of) this situation
07:12:28 <merijn> The shell always executes the writer first in those examples
07:12:35 <hiptobecubic> Well this toy example only works if the reader attaches first
07:12:56 <hiptobecubic> mkfifo f; cat f & sleep 1 && echo 1 > f
07:13:22 <merijn> Which means that even in those examples the writer will have opened first
07:13:39 <hiptobecubic> i think you're backwards
07:13:44 <merijn> The fact that the writer hasn't written is an unrelated issue. But it has to at least open, afaik
07:13:49 <hiptobecubic> if the reader doesn't open first , then it hangs
07:14:17 <Ferdirand> if the reader doesn't open first, the writer gets sigpipe iirc
07:14:18 <hiptobecubic> the echo 1 there definitely happens *after* the cat
07:15:28 <hiptobecubic> We have a good way to parse C code right?
07:15:37 <hiptobecubic> src-exts or something?
07:15:58 <rwbarton> there is http://hackage.haskell.org/package/language-c
07:16:15 <hiptobecubic> hm
07:16:18 <hiptobecubic> anything for c++
07:16:40 <hiptobecubic> I guess c++ is significantly more difficult, with all the shenanigans it has
07:20:04 <ethercrow> libclang?
07:20:40 <ethercrow> at least python bindings were convenient enough
07:21:06 <quicksilver> hiptobecubic: "significantly" is an understatement.
07:27:39 <hiptobecubic> I'm coming around to C++ a bit. It's still miserable but if you don't get trapped in all the bureaucracy then it it just a std library which isn't awful.
07:27:47 <hiptobecubic> Except for IO, which is still awful
07:28:09 <quicksilver> there is a lot to like about C++
07:28:25 <quicksilver> it's expressive, powerful, gives you lots of interesting tools to solve real problems.
07:28:54 <quicksilver> in the other hand, it gives you copy constructors, lvalues, move-constructors, RAII, smart_ptrs
07:29:02 <hiptobecubic> I am getting sick of all of the emphasis on these design patterns that are supposedly super innovative and clever, but are actually totally obvious to anyone that knows any language other than FORTRAN
07:29:05 <quicksilver> which all feel like solutions to problems I wish didn't exist in the first place.
07:29:24 <yitz> but you have to be extremely disciplined to keep track of memory and buffer overflows. even with smart ptrs of very sorts, etc.
07:29:25 <Jafet> @quote C++
07:29:25 <lambdabot> monochrom says: Welcome to #haskell, where @remember's are in majestic stereo!
07:29:49 <quicksilver> hiptobecubic: design patterns are solutions to particular styles of bad programming which the authors had observed.
07:29:55 <yitz> and that's really hard if "you" is a team of a lot of developers, working across diverse locations in space and time.
07:30:08 <monochrom> @quote c\+\+
07:30:08 <lambdabot> kmc_ says: Haskell may have syntactic sugar, but C++ has syntactic strychnine
07:30:10 <quicksilver> you may not have fallen into those traps but lots of people do especially in large projects.
07:30:42 <Philippa> and it's important to have names to the solutions to help people be able to think about applying them to large clusterfucks
07:30:49 <Philippa> it's easy to refactor 10-20LoC...
07:31:04 <hiptobecubic> quicksilver, sure, but it seems like all but the most complicated ones are solved by design if you just allow something higher order functions, for example
07:31:05 <nand`> @quote unabstracted
07:31:06 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
07:31:08 <nand`> :(
07:31:08 <mroman> @check f a = a == a
07:31:08 <lambdabot>   Parse error at "=" (column 5)
07:31:12 <hiptobecubic> something like*
07:31:15 <nand`> “design patterns are unabstracted abstractions”
07:31:18 <mroman> how does check work again?
07:31:35 <Philippa> hiptobecubic: sure, there's a major issue that they sprung out of an OO culture that tends to think in first-order terms
07:31:47 <nand`> @check \a -> a == a
07:31:49 <lambdabot>   Not in scope: `myquickcheck'
07:31:50 <parcs`> mroman: it's broken currently but
07:31:51 <nand`> lol
07:31:51 <Philippa> which is a problem with the individual patterns rather than the concept of patterns
07:31:59 <hiptobecubic> it's quite hard to follow honesly
07:32:13 <hiptobecubic> Factory factories and delegating visitors and blahblah
07:32:17 <monochrom> https://plus.google.com/102208456519922110915/posts/LXxRByiCMV4
07:33:24 <ski> monochrom : .. Mercury has a few cases of syntactic salt
07:33:42 <monochrom> what is syntactic salt? :)
07:33:54 <quicksilver> hiptobecubic: yes, a large proportion of them would be unlikely to have arisen if the programmers had been comfortable with a higher-order style.
07:33:54 <hiptobecubic> I happen to like salt
07:34:08 <quicksilver> hiptobecubic: but then the book was basically written about smalltalk and has been adopted by C++
07:34:20 <quicksilver> and higher-order programming is not popular in those two languages
07:34:25 <quicksilver> and arguably not "easy"
07:34:40 <hiptobecubic> well C++ finally got lambdas, so that helps a bit
07:34:40 <quicksilver> although I know some people believe that boost makes higher order programming easy in C++.
07:34:43 <ski> monochrom : well, you can have impure predicates and functions in Mercury, but you have to annotate the signature of it with `impure', and also annotate *every* call to it with `impure' (and obviously it's contagious)
07:35:01 <nand`> does C++ have higher order types?
07:35:13 <ski> it's mostly intended for FFI stuff, before you wrap things up in a pure interface
07:35:24 <Philippa> quicksilver: it's fairly easy in Smalltalk
07:35:28 <hiptobecubic> nand`, templating?
07:35:32 <kranius> hey, I have a [(Int, Double)], and I want to sum the Doubles if they have the same Int
07:35:47 <Philippa> it's still a little verbose though
07:35:54 <quicksilver> Philippa: just not popular then I presume. I can't say I've ever met a community of smalltalk developers to evaluate their style :)
07:35:56 <hiptobecubic> :t groupBy
07:35:57 <lambdabot> (a -> a -> Bool) -> [a] -> [[a]]
07:36:04 <hiptobecubic> hmm
07:36:09 <nand`> > group [1,1,2,1,1]
07:36:11 <lambdabot>   [[1,1],[2],[1,1]]
07:36:37 <quicksilver> > groupBy ((==)`on`fst) [(1,1.5),(1,2.5),(2,0.5)]
07:36:39 <lambdabot>   [[(1,1.5),(1,2.5)],[(2,0.5)]]
07:36:40 <kranius> thus [(1, 10), (2, 12), (1, 20)] would give [(1, 30), (2, 12)]
07:36:42 <Philippa> quicksilver: some lean strongly towards higher-order programming, it's just that normally one is expected to wrap things in objects still
07:36:45 <hiptobecubic> quicksilver, yes, that's what i wanted...
07:36:50 <Philippa> but blocks exist, etc etc
07:37:15 <nand`> add sortBy (comparing fst) and map (sum . map snd)
07:37:53 <hiptobecubic> is there some crazy and hideous way to do it with lenses?
07:38:31 <nand`> not that I know of
07:39:59 <hiptobecubic> > map (sum . map snd) . groupBy ((==) `on` fst) . sortBy (comparing fst) $  [(1, 10), (2, 12), (1, 20)]
07:40:01 <lambdabot>   [30,12]
07:40:57 <nand`> So when will we be getting kind classes?
07:41:05 <hiptobecubic> for what
07:41:11 <nand`> abstracting over kinds
07:41:27 <monochrom> first we need class classes :)
07:42:05 <nand`> kind class Num (k :: BOX) where (+) :: k -> k -> k; fromNat :: Nat -> k
07:45:07 <beaky> is there a cleaner way to use IORef?
07:45:21 <beaky> without having readIORef and writeIORef everywhere?
07:45:27 <copumpkin> you could make synonyms for those
07:45:29 <copumpkin> but otherwise no
07:45:41 <beaky> :(
07:45:44 <copumpkin> the syntactic heaviness discourages you from using it except where absolutely necessary ;)
07:45:51 <copumpkin> most of what you do shouldn't need it
07:46:00 <beaky> why is ioref slow?
07:46:01 <copumpkin> sclv agrees
07:46:07 <rwbarton> don't "class classes" already work?
07:46:12 <copumpkin> beaky: what makes you say it's slow?
07:46:31 <beaky> I used it once, but it made everything slower than using accumulating parameters
07:46:34 <beaky> or folds
07:46:42 <copumpkin> probably because it's forced to be boxed
07:46:49 <beaky> ah :(
07:46:58 <beaky> maybe someday we will see an unboxedIORef
07:46:59 <copumpkin> don't use it :)
07:47:05 <copumpkin> there's a library for that, iirc
07:47:08 <rwbarton> also i think ghc can't assume that no one else is modifying the IORef
07:47:08 <bgamari> beaky, What is your use case?
07:47:14 <copumpkin> rwbarton: oh, good point
07:47:16 <beaky> a turing machine
07:47:23 <rwbarton> so it has to slavishly read/write memory where you tell it to
07:47:29 <rwbarton> can't move the IORef into a register
07:47:46 <copumpkin> but the IORef also just points to a regular closure
07:47:52 <bgamari> and why do you want to use a turing machine over say just the State monad?
07:47:53 <copumpkin> which means the value inside can be lazy
07:47:58 <copumpkin> and beaky might not have been forcing it
07:48:03 <copumpkin> beaky: were you forcing it?
07:48:03 <ski> beaky : ooi .. what would "a cleaner way to use IORef" be ?
07:48:06 <beaky> es
07:48:10 <copumpkin> ok
07:48:13 <rwbarton> yeah that too, the strictness analyzer surely cannot see through that
07:48:14 <beaky> ski: something like how Scala does it
07:48:15 <beaky> using var
07:48:30 <copumpkin> by having built-in syntax for mutation?
07:48:36 <copumpkin> and built-in support everywhere for it?
07:48:39 <copumpkin> that's not "Clean" at all
07:48:40 <beaky> yes :(
07:48:48 <copumpkin> it's not something you could add sanely to haskell
07:48:53 <copumpkin> even if people wanted it (which they don't)
07:48:55 <bgamari> nor would you want to
07:49:08 <nand`> cleaner way to use IORefs is not at all
07:49:20 <ski> (i suspect beaky might want second-class support for references)
07:49:23 <beaky> http://ideone.com/5oXq4D
07:49:47 <beaky> without IORefs: http://ideone.com/IWx4lE
07:49:56 <bgamari> oh dear
07:49:57 <beaky> much cleaner without :D
07:50:05 <ski> beaky : you have a lot of code repetition there ..
07:50:14 <beaky> yes
07:50:22 <rwbarton> "why isn't there a more convenient way to use this feature that makes my program go slower"
07:50:24 <bgamari> beaky, it could be made cleaner as well
07:50:38 <copumpkin> could probably be made faster, too
07:50:47 <beaky> http://ideone.com/nv2xUD to be honest I just directly translated the C version
07:51:00 <bgamari> beaky, a zippered list to encode the tape  sounds nice to me
07:51:01 <nand`> an excellent way to generate horrible Haskell programs
07:51:06 <beaky> :D
07:51:16 <beaky> I can write C in any language ^^
07:51:16 * nand` encodes tapes as Top :> [a] :> a
07:51:27 <rwbarton> there was an earlier version with a zipper
07:51:44 <copumpkin> that way you can have a truly infinite tape!
07:51:45 <copumpkin> zomg
07:51:53 <ski> beaky : i suspect using a list zipper would be much nicer in your case
07:52:06 * nand` reminds himself to bug edwardk daily for infinite zippers
07:52:07 <zomg> HAX
07:52:07 <bgamari> nand`, still only finite though
07:52:11 <copumpkin> painfully nice
07:52:23 <beaky> wouldn't list zippers make it slower?
07:52:30 <copumpkin> beaky: ask criterion
07:52:33 <copumpkin> but I doubt it
07:52:34 <bgamari> a) probably not appreciably
07:52:39 <bgamari> b) does it matter?
07:52:50 <ski> beaky : you don't appear to need random-access here anyway
07:52:58 <copumpkin> you'll have slightly worse memory locality
07:52:59 <beaky> ye
07:52:59 <copumpkin> but meh
07:53:09 <rwbarton> as i recall the zipper version was slower
07:53:11 <beaky> I had a list-zipper one but it is like 4 times slower :(
07:53:12 <copumpkin> the whole thing isn't very local
07:53:27 <copumpkin> beaky: keep in mind that "slower" is a function of how you wrote it
07:53:33 <copumpkin> and not necessarily of the technique in question
07:53:34 <beaky> but the list zipper one was more elgant :D
07:54:00 <beaky> http://ideone.com/5PVv1A
07:54:31 <nand`> bgamari: actually, Top :> [a] :> a is infinite as long as you don't rezip it
07:54:36 <rwbarton> moving a zipper takes like eight pointer writes, it is never going to be as fast as "idx + 1"
07:54:44 <nand`> it's only infinite in one direction though
07:56:21 <bgamari> rwbarton, although frankly, given there's a good chance you'll be writing to a hot cacheline, who knows how much that actually costs
07:56:54 <bgamari> although I know relatively little about the memory locality of GHC produced code
07:56:55 <rwbarton> more than incrementing a register!
07:57:30 <beaky> http://ideone.com/f4NYAW what are the basic principles of functional programming?
07:57:31 <bgamari> touche
07:57:40 <quicksilver> rwbarton: the fact that changing 8 pointers (if you're right there) costs more than incrementing a register only matters if that turns out to be the bottleneck.
07:57:47 <rwbarton> come on
07:57:49 <rwbarton> have you read the code?
07:58:00 <rwbarton> this program does *nothing else*
07:58:04 <quicksilver> rwbarton: if the bottleneck is actually memory bandwidth, say, then both are effectively free.
07:58:37 <quicksilver> (but the index still wins then because the tape stored in contiguous memory takes up much less memory)
07:59:09 <bgamari> beaky, It would be interesting if you could run criterion on both approaches
07:59:35 <beaky> ah
08:00:21 <beaky> the first one is faster than the Java version :D
08:00:32 <beaky> second one isn't :(
08:00:41 <rwbarton> what are the first/second ones
08:01:05 <beaky> first one was the one with IOUArrays
08:01:13 <beaky> second one was the long one with zipper lists
08:01:15 <rwbarton> i see
08:01:26 <rwbarton> what data structure was your java program using?
08:01:55 <beaky> an array :D
08:02:16 <rwbarton> here is a fun project for you
08:02:35 <rwbarton> write a Haskell program that reads a turing machine description and compiles it to native code using the LLVM bindings
08:02:40 <beaky> the java version was a direct translation of the C version too: http://ideone.com/2MBvgw
08:02:45 <nand`> @ask edwardk Lens.Zipper does infinite zippers in one direction as long as you don't rezip them; but what about infinite bidirectional zippers?
08:02:46 <lambdabot> Consider it noted.
08:03:16 <beaky> rwbarton: I'll try tto do it :D
08:03:33 <beaky> or did I just do it?
08:04:00 <johnw> what did you just do, beaky?
08:04:15 <bgamari> beaky, You haven't done it yet
08:04:21 <bgamari> beaky, he was suggesting using http://hackage.haskell.org/package/llvm
08:04:30 <johnw> ah
08:04:33 <johnw> Ralith could help you there
08:04:54 <beaky> ah
08:05:37 <beaky> how do I parse things?
08:05:47 <beaky> does haskell have native regexes like ruby?
08:05:55 <johnw> actually, it does
08:05:59 <johnw> but without having to make them "native"
08:06:02 <beaky> ooh
08:06:06 <johnw> see Text.Regex.Posix
08:06:26 <S11001001> bring on the parser brigade; this happened yesterday too
08:06:30 <johnw> you can say if "string" =~ "regex" then ... too :)
08:06:52 <mm_freak> regex-matching is not parsing, though
08:06:53 <Saizan> (=~) is an ungodly abomination
08:07:07 <johnw> i really like =~
08:07:12 <Saizan> but that's just my humble opinion
08:07:16 <Ferdirand> :t (=~)
08:07:16 <beaky> :t (=~(
08:07:18 <lambdabot>     Not in scope: `=~'
08:07:18 <lambdabot>     Perhaps you meant one of these:
08:07:18 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
08:07:18 <lambdabot> parse error (possibly incorrect indentation)
08:07:19 <beaky> :t (=~)
08:07:21 <lambdabot>     Not in scope: `=~'
08:07:21 <lambdabot>     Perhaps you meant one of these:
08:07:22 <lambdabot>       `==' (imported from Data.Eq), `#~' (imported from Control.Lens),
08:07:28 <beaky> lol
08:07:39 <johnw> :t Text.Regex.Posix.(=~)
08:07:40 <lambdabot>     Not in scope: data constructor `Text.Regex.Posix'
08:07:40 <lambdabot>     Not in scope: `=~'
08:07:41 <lambdabot>     Perhaps you meant one of these:
08:07:43 <fmap> :t (#~)
08:07:45 <lambdabot> Loupe s t a b -> b -> s -> t
08:07:53 <rwbarton> Loupe?
08:07:57 <geekosaur> :t (Text.Regex.Posix.=~)
08:07:58 <lambdabot> (Text.Regex.Base.RegexLike.RegexMaker Text.Regex.Posix.Wrap.Regex Text.Regex.Posix.Wrap.CompOption Text.Regex.Posix.Wrap.ExecOption source, Text.Regex.Base.RegexLike.RegexContext Text.Regex.Posix.
08:07:58 <lambdabot> Wrap.Regex source1 target) => source1 -> source -> target
08:08:02 <johnw> ah
08:08:08 <geekosaur> any more questions?
08:08:16 <nand`> mm_freak: isn't searching for a regex basically the same as parsing a language <any-string> <string that matches regex> <any-string> ?
08:08:17 <beaky> how od I install Text.Regex?
08:08:33 <johnw> beaky: cabal install regex-posix
08:08:36 <beaky> ah
08:08:36 <mm_freak> i could never memorize in what order (=~) takes its arguments, so i wind up writing a parser
08:08:46 <nand`> rwbarton: looks like a lens combinator
08:08:49 <nand`> but Loupe?
08:08:51 <nand`> never seen it
08:09:00 <johnw> mm_freak: like every language that has =~, "regex is on the right"
08:09:11 <rwbarton> nand`, yeah
08:09:12 <Ferdirand> Loupe is french for Lens
08:09:12 <mm_freak> nand`: sure it's parsing
08:09:16 <mm_freak> but i'd hardly call it parsing
08:09:22 <mm_freak> for me that's just matching and extracting
08:09:43 <nand`> :t (%~)
08:09:44 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
08:09:48 <mm_freak> johnw: how would i know?  who makes that standard?  perl?  i'm not a perl programmer, and i'll never be
08:09:50 <johnw> isn't parsing really just interpreting structure from a unstructured stream?
08:09:59 <johnw> mm_freak: yeah, Perl did
08:10:05 <beaky> my haskell binaries are huge :( any suggestions for reducing their size?
08:10:05 <johnw> then Ruby followed
08:10:13 <johnw> beaky: strip
08:10:29 <johnw> there is also dynamic linking of modules, but I've never played around with it
08:10:32 <mm_freak> anyway, i almost prefer "match myRegEx myString"
08:10:41 <beaky> my simple calculator one is still like 1 MB large :(
08:10:45 <mm_freak> that's more friendly to higher order functions
08:10:46 <beaky> after strip*
08:10:50 <johnw> mm_freak: yeah, that fits with Python and Emacs Lisp
08:10:56 <monochrom> please don't worry so much about exe size for now
08:10:58 * nand` prefers ‘parse someParser someInput’
08:11:11 <johnw> beaky: did you build with debugging, profiling...?
08:11:13 <mm_freak> nand`: yeah, me too
08:11:17 <beaky> nope
08:11:27 <mm_freak> i don't think i've put a single regex in production
08:11:35 <johnw> i view regexs as just another syntax for writing very simple parsers
08:11:36 * roconnor thinks regular expressions have more to do with graph theory than parsing.
08:11:49 <johnw> and when that syntax gets cumbersome, I upgrade to Parsec and family
08:11:51 * beaky doesn't understand regular expressions or parsing :(
08:11:53 <merijn> beaky: Who cares about the size, though?
08:12:05 <beaky> right, I have terabytes of storage :D
08:12:09 <nand`> I don't think regex is a very pretty language, any regular expressions I've written in it tend to be fairly verbose, ugly, hard to read/understand and/or full of redundancies
08:12:09 <merijn> Why do they have to be smaller?
08:12:18 <johnw> beaky: have you heard of deterministic finite automata?
08:12:29 <beaky> like turing machines?
08:12:33 <mm_freak> beaky: at some point you'll check out parsec, and you'll tell yourself:  "man, parsing is actually really simple!  why didn't i get parsing in other languages?"
08:12:37 <johnw> http://en.wikipedia.org/wiki/Deterministic_finite_automaton
08:12:40 <beaky> ah
08:12:42 <mm_freak> and then we will answer:  in haskell it is actually very simple =)
08:12:48 <johnw> understand those, and you will know regexs to perfection -- just not the syntax :)
08:12:55 <nand`> every time I try to think about what a ‘parser’ is; I come to the conclusion that every Haskell function is a parser
08:13:03 <beaky> what does parse mean?
08:13:27 <johnw> beaky: we "parse" language when we process sounds to infer meaning
08:13:47 <johnw> we do the same in computers when we process bytes or characters to infer the programmer's intention
08:13:56 <mkaito> I guess you could say that parse is related to "understand"
08:14:00 <mkaito> loosely, anyway
08:14:02 <nand`> ‘generating data from data’, though in most usages of the word the input domain is meant to be some sort of string
08:14:06 <beaky> ah
08:14:19 <johnw> "bunch o' formless data" => "comprehended form" == parse
08:14:23 <mm_freak> beaky: the word itself really just means to analyze…  more technically you have a stream of symbols and find structure in that stream
08:14:32 <beaky> right
08:14:34 <nand`> or, arguably, a parser is simply a set of strings that are valid in that language
08:14:37 <roconnor> parse usually refers to converting a string into a data structure.
08:14:48 <beaky> so in haskell I can easily write parsers for anything?
08:14:53 <mm_freak> beaky: think of it as:  parse :: String -> MyDataType
08:14:58 <johnw> beaky: oh yes indeed
08:15:03 <beaky> haskell seems like a perl killer in that case
08:15:07 <mm_freak> beaky: easily, but not easily for anything
08:15:08 <johnw> beaky: in a simpler way than most languages, I've found
08:15:12 <nand`> perl wasn't dead yet?
08:15:24 <johnw> nand`: i still use Perl at the command-line as a better awk
08:15:32 <johnw> and no, awk isn't dead yet either :)
08:15:36 * nand` wants lens on the command line
08:15:39 <nand`> somebody make it happen
08:15:45 <mm_freak> i think perl was never great to begin with, people just didn't realize it
08:15:51 <johnw> nand`: you mean to lens over directories and files?
08:15:58 <nand`> johnw: or strings
08:16:06 <nand`> (think STDIN)
08:16:16 <johnw> mm_freak: Perl 4 was actually pretty great compared to what else was available (gag, Tcl), but Perl 5 was an obfuscatory monster
08:16:27 <johnw> i personally think Perl 5 is what killed Perl
08:16:30 <nand`> man, I just want a Haskell shell. and I mean one that I can use as a drop-in replacement for bash for real work
08:16:41 <johnw> nand`: ooh, nice idea
08:16:57 <johnw> nand`: where you can only make new files, never modify old ones :)
08:17:01 <mm_freak> dunno…  perl is ad hoc, ugly, non-static and highly imperative
08:17:13 <johnw> mm_freak: and damn useful :)
08:17:25 <nand`> ls /foo/bar ^! traverse.delete
08:17:33 <monochrom> "haskell shell" is somewhat ill-defined
08:17:41 <nand`> it is
08:17:45 <nand`> I don't know what it would look like
08:17:49 <mm_freak> johnw: never seen that…  i can't imagine a useful language without ADTs and pattern-matching
08:17:52 <nand`> but it has to be a shell, and it has to be like Haskell
08:18:02 <nand`> mm_freak: lambda calculus? :P
08:18:16 <johnw> mm_freak: then your brain was never wrecked like most of us
08:18:28 <mm_freak> nand`: lambda calculus is not a programming language
08:18:31 <monochrom> lambda calculus is not easy to use
08:18:42 <mm_freak> johnw: it was…  i used to be a C/C++ programmer =)
08:18:54 <quicksilver> there are plenty of useful languages which are not haskell
08:18:59 <nand`> mm_freak: I'll refrain from a discussion on what is or is not a programming language
08:19:03 <quicksilver> which is not to say that haskell doesn't have a bunch of advantages
08:19:18 <johnw> nand`: I too want a Haskell shell, followed by a Haskell OS
08:19:18 <nand`> Haskell will become relevant to the real world when it gets dependant types
08:19:24 <nand`> johnw: definitely
08:19:26 <johnw> Haskell Machines FTW!
08:19:32 <nand`> I want a Haskell kernel so I can write device drivers
08:19:44 <mm_freak> nand`: obviously pure lambda calculus is probably one of the hardest languages after SKI, but i don't see your point
08:19:55 <nand`> I also want to go out and buy graph reducer microchips that I can program (easily) in Haskell
08:19:55 <mm_freak> i never claimed that pure lambda calculus would be useful as a programming language ;)
08:20:08 <nand`> mm_freak: ‘useful’ to whom? for what purpose?
08:20:19 <mm_freak> nand`: writing programs
08:20:39 <mm_freak> you know, computer programs, things that do stuff
08:21:12 <nand`> ah, hrm
08:21:16 <mm_freak> also the day when haskell gets dependent types it will become /less/ relevant to the real world ;)
08:21:20 <nand`> indeed, mainly due to lack of a type system
08:21:33 <mm_freak> no, that's not the problem with lambda calculus
08:21:36 <bartavelle> to me the most glaring of missing haskell feature is easy runtime extension (loading compiled plugins or source code). It is possible but seems horribly complicated and GHC-version dependant
08:21:50 <nand`> speaking of dependent types, jfischoff do you know of a library that implements type ints in the singletons style?
08:21:59 <Jeanne-Kamikaze> I'm still waiting for lambda phone to come out
08:21:59 <bartavelle> and it is incredibly useful
08:22:24 <johnw> i wouldn't mind having ghci on my iPad
08:22:35 <Jeanne-Kamikaze> lambda phone also doesn't stalk you
08:22:35 <ethercrow> maybe we fix haskell editor first?
08:22:41 <mm_freak> bartavelle: not horribly complicated…  actually hint makes that very easy
08:22:50 <mm_freak> at least loading source code
08:22:52 <bartavelle> mm_freak, what is hint ?
08:22:55 <mm_freak> a library
08:22:58 <bartavelle> !!!!!!!
08:23:13 <Jeanne-Kamikaze> what editor ethercrow, leksah ?
08:23:20 <nand`> I don't think runtime extension should be a native thing; I think keeping plugins and such as separate processes and using a language to communicate between them is a better abstraction
08:23:20 <jfischoff> nand`: type-prelude (I think that is what is called) built some type level ints, but I am not sure if it is in the singleton style.
08:23:22 <bartavelle> ok
08:23:32 <Jeanne-Kamikaze> I think it's pretty decent already, just a few minor issues
08:23:36 <mm_freak> i agree with nand` mostly
08:23:38 <bartavelle> to me the most glaring of missing haskell feature is that it isn't well known that "hint" exists
08:23:52 <mm_freak> but haskell is also useful as an embedded scripting language, and for that you can use hint
08:24:02 <ethercrow> I thought about yi
08:24:15 <jfischoff> nand`: I don't think it would be hard to do though
08:24:15 <ethercrow> but the more the merrier
08:24:26 <bartavelle> nand` : it is not acceptable for distribution
08:24:30 <nand`> which actually gives me an idea that goes against what I just said: Haskell-native IPC which shares data by just swapping out pointers; immutability and all
08:24:34 <bartavelle> you can distribute a haskell binary on its own
08:24:43 <nand`> jfischoff: hard no; tedious though
08:24:50 <bartavelle> but if you need ghc + 1688616 packages to include a plugin system ..
08:24:51 * jfischoff nods
08:25:02 <mm_freak> bartavelle: something different, but not completely unrelated:  there is also cloud haskell =)
08:25:27 <bartavelle> my use case is to convert the ruby puppet plugins so that they can be used by my haskell library
08:25:40 <nand`> jfischoff: how does singletons handle type polymorphy? what about typeclass constraints?
08:25:53 <bartavelle> the problem is that they live on production servers that do not have ghc
08:26:07 <bartavelle> mm_freak, cloud haskell will be for later ! :)
08:26:35 <nand`> bartavelle: statically link ghc into the binary? :P
08:26:44 <nand`> (isn't ghc available as library like that?)
08:26:45 <bartavelle> that's the only way I saw
08:26:46 <rwbarton> isn't that what hint does
08:26:50 <rwbarton> in effect
08:26:52 <bartavelle> so I added a lua interpreter and converted them to lua ...
08:26:53 <mm_freak> nand`: hint =)
08:27:04 <bartavelle> I didn't knew about hint
08:27:08 <nand`> me neither
08:27:16 <nand`> ..but I have it in my history; so apparently I just forgot about it
08:27:28 <mm_freak> there is also mueval, if you want lambdabot-style evaluation
08:27:42 <nand`> yeah
08:27:44 <jfischoff> nand`: I am not sure if the library supports those features. I guess polymorphic types could promote to polymorphic kinds, but I'm not sure what typeclass constraints should promote to.
08:27:52 <mm_freak> > fix f
08:27:54 <lambdabot>   Ambiguous type variable `a0' in the constraints:
08:27:54 <lambdabot>    (GHC.Show.Show a0)
08:27:54 <lambdabot>     ...
08:28:00 <mm_freak> > fix f :: Expr
08:28:02 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
08:28:08 <nand`> jfischoff: me neither
08:28:26 <nand`> type-prelude fails on 7.4+
08:28:37 <nand`> so I'm guessing it's not in the DataKinds/TypeFamilies style
08:28:48 <jfischoff> nand`: yeah its uses the new type literals
08:28:56 <jfischoff> which I think was a mistake
08:29:05 <nand`> it fails on 7.6 too though
08:29:14 <jfischoff> oh
08:29:36 * hackagebot aivika-experiment 0.1.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.1.1 (DavidSorokin)
08:29:45 <nand`> (how does it manage to use type literals either way? as far as I can tell there's no way to actually do calculations on them)
08:29:51 <nand`> fairly useless
08:30:02 <nand`> that being said; with kind classes you could overload type literals in interesting ways
08:30:15 <nand`> unfortunately we don't have kind classes
08:30:23 <nand`> jfischoff: it builds on 7.6
08:30:32 <nand`> hackage marks it as ‘build failure’ but that must be incorrect
08:31:05 <jfischoff> nand`: you hit the nail on the head. There isn't really a way to use the literals for computation.
08:31:05 <t7> > fix (+ 1) :: Expr
08:31:12 <lambdabot>   mueval: ExitFailure 1
08:31:12 <lambdabot>  mueval: Prelude.undefined
08:31:26 <jfischoff> nand`: the singleton way is better
08:31:33 <nand`> indeed
08:31:59 <nand`> I recently thought about Nat n+k patterns in type families
08:32:27 <jfischoff> nand`: ?
08:33:08 <nand`> type family Add (n :: Nat) (m :: Nat) :: Nat; type instance Add 0 m = m; type instance Add (1+n) m = 1 + Add n m
08:33:51 <zyg> I'm a bit stuck halfway through for-a-few-monads-more. Is it enough to understand the do notation and keep on reading? I just unwrapped addStuff = \v -> ((\a -> (\w -> (\b -> (\_ -> (a+b))) ((+10) w) w)) ((*2) v)) v   and that, while I can go through it and maybe understand it step by step, it really takes too long time if I do that for every do notation I try to understand.
08:34:33 <jfischoff> nand`: do the n+k achieve anything that we couldn't do without them?
08:34:36 * hackagebot ruff 0.3.2 - relatively useful fractal functions  http://hackage.haskell.org/package/ruff-0.3.2 (ClaudeHeilandAllen)
08:34:38 * hackagebot gruff 0.3.3 - fractal explorer GUI using the ruff library  http://hackage.haskell.org/package/gruff-0.3.3 (ClaudeHeilandAllen)
08:36:02 <nand`> hmm; it still wouldn't be possible to define that ‘Add’ without an existing (+) :: Nat -> Nat -> Nat either way so somewhat of a useless example
08:36:23 <acowley> Anyone have any experience debugging ghc-mod problems?
08:36:41 <nand`> but you could write :: Nat -> MyNat
08:36:46 <nand`> with just those kinds of patterns alone
08:36:53 <jfischoff> nand`: actually i get it. Its just a fancy way to say Succ
08:37:04 <nand`> yeah; given lack of any Succ on Nat
08:37:08 <acowley> In stand-alone files, it's not finding my user package db. In canalized projects, it's not giving me anything at all, and I'm not sure where to look for log message or the like.
08:37:17 <acowley> s/canalized/cabalized
08:37:39 <nand`> the main problem with n+k patterns on a semantic level was the presence of negative numbers in stock number types, I figure that wouldn't be a problem here
08:37:40 <jfischoff> nand`: I think we will get Succ on Nat in 7.8, its just a theory though
08:37:43 <nand`> oh
08:37:45 <nand`> that would work too
08:37:53 * jfischoff nods
08:37:55 <nand`> I really want negative numbers too though
08:38:04 <nand`> actually, I don't care
08:38:16 <nand`> I can implement negative numbers myself as (Nat, Nat)
08:38:44 <dmwit> Have fun with multiplication.
08:38:45 <nand`> you just won't get pretty literals for it, but it's not as bad as having to manually construct the succs, which sucks
08:38:52 <ski> (nand` : as a quotient of that ?)
08:39:21 <nand`> dmwit: (a-b)(x-y) = a(x-y)-b(x-y) = ax-ay-bx+by = (ax+by)-(ay+bx) -- like that?
08:39:27 <dmwit> Oh, I guess multiplication isn't that hard.
08:39:36 <dmwit> Yeah, just sat down and worked out that equation myself. =)
08:39:51 <nand`> I already implemented that last night :P
08:40:10 <dmwit> "sat down"
08:40:18 <nand`> jfischoff: error messages would also be much prettier with type literals
08:40:28 * jfischoff nods
08:40:31 <nand`> “Couldn't match type 'Succ ('Succ ('Succ 'Zero)) with 'Zero”
08:41:15 <nand`> jfischoff: do you know what things are planned for Symbol?
08:41:26 <jfischoff> I wish that instead of given use built in types/kinds we had a way to use the concrete syntax on our own types
08:41:30 <nand`> for example, if I want to build a 'Set Symbol; I'd need the ability to compare them
08:42:01 <nand`> might as well wish for dependent types
08:42:03 <osa1> when is a formal system called calculus ?
08:42:11 <jfischoff> nand`: yeah I had to do the same thing is Oxymoron and I haven't done it elegantly yet
08:44:39 <jfischoff> nand`: https://github.com/jfischoff/oxymoron/blob/master/src/Oxymoron/Description/Program.hs#L19 the :==: is from the singleton library
08:44:57 <nand`> the thing I'm trying to build is a system to overpower F#'s arbitrary ‘units of measure’ system, which works on a symbolic level (rather than being limited to certain pre-defined SI types or something); so a Haskell clone would have to be Symbol as well - thing is, I'd want to represent units as Map Symbol Int; I could use [(Symbol,Int)] instead but then I have no idea how I'd eg. check
08:44:58 <nand`> [("foo",1),("bar",2)] and [("bar",2),("foo",1)] for equality
08:45:04 <nand`> since both represent foo*bar²
08:45:36 <nand`> hmm
08:45:50 <jfischoff> nand`: yeah that is exactly what Oxymoron is doing to make sure that vertex and fragment shaders match
08:46:01 <nand`> if you could abstract that out it'd be useful
08:46:35 <t7> i remember watching this film when i was younger with this two (maybe more) headed bird that is chasing someone (or more people) and the(y) make the heads go different ways so the bird splits in 3 (or more). any idea what it was?
08:47:24 <jfischoff> nand`: I need an associative list. I'll come back to it after I figure how to use regions with openGL correctly ;/
08:47:38 <hiptobecubic> t7, pokémon?
08:47:40 <nand`> associative list?
08:47:57 <jfischoff> nand`: a dictionary
08:48:04 <dmwit> t7: saucer separation in Star Trek, it's the only explanation
08:48:12 * jfischoff hopes he is using the right terms ...
08:48:36 <jfischoff> nand`: I have this new interesting problem that requires so pretty complex type hackery
08:49:36 <dmwit> What do you mean we don't have type-level sets? >:-(
08:49:43 <aciar> can anyone point me to some info on Haskell operators? Messing with xmonad config and totally lost with ||| <=> <+> $ --> <-
08:49:52 <dmwit> aciar: Use hoogle.
08:49:57 <mauke> aciar: those are xmonad operators, not haskell operators
08:50:04 <mauke> except for <-, which is not an operator
08:50:08 <aciar> oh thats why then
08:50:08 <jfischoff> dmwit: I bet they could be created
08:50:10 <dmwit> aciar: http://www.haskell.org/hoogle/?q=(%7C%7C%7C)+%2Bxmonad+%2Bxmonad-contrib
08:50:16 <jfischoff> gate change!
08:50:31 <Phlogistique> mauke: well, $ is defined in the Prelude
08:50:57 <dmwit> Hm, +xmonad seems to mean "don't search the default list of packages", which is a bit annoying.
08:57:10 <DMcGill> does +xmonad +base behave nicely?
08:57:30 <DMcGill> failing that, Hayoo has a wider list of things to search by default
08:57:41 <dmwit> Yes, but base is not the only package it searches by default.
08:58:06 <DMcGill> true, true
08:59:39 <hpaste> bfig pasted “indentation problem” at http://hpaste.org/77401
09:00:21 <bfig> i'm having an indentation problem at l.52, can you see the problem?
09:00:48 <byorgey> bfig: maybe try indenting the 'where' lass
09:00:50 <byorgey> *less
09:01:20 <S11001001> bfig: where's scope is a sequence of alternative definitions?
09:01:59 <bfig> can you rephrase please?
09:02:07 <nand`> jfischoff: so right now I'm sitting on  fromCelsius :: Fractional a => a:@"Celsius" -> a:@Kelvin; but I can't multiply, divide or exponentiate non-SI types
09:02:12 <S11001001> bfig: try putting it after the other removeWith case
09:02:14 <nand`> perhaps that's a good thing
09:02:31 <dmwit> bfig: You're just missing a right parentheses on line 51.
09:02:43 <bfig> ahh yes! :D
09:02:49 <bfig> thanks :)
09:02:50 <S11001001> dmwit: oh :/
09:02:58 <tarik_> map [1,2]
09:03:07 <jfischoff> nand`: interesting
09:03:36 <dmwit> > map (+5) [1,2] -- tarik_
09:03:38 <lambdabot>   [6,7]
09:04:18 <bfig> so, 50 lines of code, let's see if they work :p
09:04:43 <tarik_> [6,7]
09:04:55 <tarik_> reverse "me"
09:04:58 <nand`> jfischoff: I also wonder if DataKinds will allow singletons for Nats and Symbols; so I can write something like f :: a -> SSymbol s -> a:@s
09:05:10 <dmwit> tarik_: Put an angle bracket and a space in front, like this:
09:05:13 <dmwit> > reverse "me"
09:05:14 <lambdabot>   "em"
09:05:19 <nand`> maybe something like '"foo" on the value level
09:05:33 <otters> :t foldr (flip (:))
09:05:37 <lambdabot>     Occurs check: cannot construct the infinite type: b0 = [b0]
09:05:37 <lambdabot>     Expected type: b0 -> [b0] -> b0
09:05:37 <lambdabot>       Actual type: b0 -> [b0] -> [b0]
09:05:41 <tarik_> let increment : :
09:05:43 <otters> whoops
09:05:46 <otters> :t foldl (flip (:))
09:05:47 <lambdabot> [b] -> [b] -> [b]
09:05:51 <jfischoff> nand`: that is what I am doing with the singleton library, I just don't have fancy syntax
09:06:10 <tarik_> let increment [1,2,3,4,5,6,7,8,9]
09:07:03 <nand`> jfischoff: you're right about it feeling ugly for Symbol and Nat to get ‘special treatment’, so to say
09:07:51 <othman_> reverse "hello"
09:08:45 <jfischoff> nand`: I forget the name of the guy that is developing the type lit stuff, but he gave a presentation at ICFP and showed a way the type lits could be used to create user defined types. I bet it will happen … eventually
09:09:07 <dmwit> > "reverse \"hello\"" == "> reverse \"hello\""
09:09:09 <lambdabot>   False
09:09:15 <nand`> jfischoff: would certainly be cool
09:09:19 <tarik_> map toUpper " Let me in"
09:09:24 * jfischoff nods
09:09:46 <dmwit> tarik_: Do you speak English?
09:09:52 <tarik_> yeah
09:10:06 <dmwit> 12:04 < dmwit> tarik_: Put an angle bracket and a space in front, like this:
09:10:09 <mauke> bamberch!
09:10:14 <dmwit> > reverse "me"
09:10:16 <lambdabot>   "em"
09:10:56 <othman_> reverse "me"
09:11:42 <mauke> tarik_, othman_: are you the same person?
09:11:58 <dmwit> I mean, they're connecting from the same computer and making the same queries with the same mistakes...
09:12:08 <tarik_> <dwmit> tarik_
09:12:14 <tarik_> no
09:12:17 <tarik_> why
09:12:45 <mauke> what?
09:12:46 <tarik_> how to know if it is the same computer dwmit_
09:12:54 <mauke> tarik_: /whois tarik_
09:12:56 <mauke> tarik_: /whois othman_
09:13:18 <othman_> mauke no
09:13:24 <othman_> mauke why
09:13:32 <mauke> shows you're both connecting via webchat from 8d0daaaf@gateway/web/freenode/ip.141.13.170.175
09:13:44 <mauke> which is proxy.ub.uni-bamberg.de/141.13.170.175
09:13:44 <othman_> mauke we re in the same place
09:14:01 <othman_> mauke in the university
09:14:45 <tsou> mauke: (the second part of your reasoning seems quite stronger than the host one)
09:15:14 <tsou> even with the "no\nwhy\n" response :P
09:15:49 <Neuner> Hey, I have a data type that looks like this.. data Rank = Numeric Integer | Jack | Queen | King | Ace
09:15:50 <Neuner>             deriving (Eq, Show)
09:15:52 <mauke> yeah, obviously the same person
09:16:06 <Neuner> how can I optimize Numeric Integer in my valueRank function?
09:16:10 <Neuner>  valueRank :: Rank -> Integer
09:16:10 <Neuner>  valueRank r | r == Jack || r == Queen || r == King = 10
09:16:12 <Neuner>              | r == Ace = 11
09:16:13 <Neuner>              | r == Numeric 1 = 1
09:16:15 <Neuner>              | r == Numeric 2 = 2
09:16:17 <Neuner>              | r == Numeric 3 = 3
09:16:18 <Neuner>              | r == Numeric 4 = 4
09:16:19 <Neuner>              | r == Numeric 5 = 5
09:16:21 <rwbarton> uh oh
09:16:21 <Neuner>              | r == Numeric 6 = 6
09:16:21 <dmwit> Neuner: stop
09:16:21 --- mode: ChanServ set +o mauke
09:16:22 --- kick: Neuner was kicked by mauke (Neuner)
09:16:46 <otters> otherwise = (\(Numeric n) -> n) r
09:16:56 <nand`> that function seems backwards to me in the first place
09:17:00 <nand`> why use Eq instead of pattern matching
09:17:04 <rwbarton> indeed
09:17:07 <otters> alternatively, data Numeric { unNumeric :: Int }
09:17:29 <nand`> Neuner: please use hpaste.org for pastes in the future
09:17:34 <geekosaur> don;t paste directly into the channel
09:17:35 <Neuner> ok, sorry
09:17:38 <mauke> valueRank Ace = 11; valueRank (Numeric n) = n; valueRank _ = 10
09:17:56 <nand`> what mauke said
09:18:14 <nand`> though if you want to be pedantic you could pattern match on Jack, Queen and King separately to ensure ‘correct semantics’ in the event of a freak typo
09:18:22 --- mode: mauke set -o mauke
09:23:04 <otters> for some reason my cabal makes GHC compile every file twice, once with .o and once with .p_o (profiling?)
09:23:06 <otters> how do I turn this off?
09:23:57 <rwbarton> find 'library-profiling: true' in your ~/.cabal/config and change to false
09:24:03 <dmwit> ...but don't do that
09:24:35 <otters> why not
09:25:06 <dmwit> because then you'll want to profile something some day and your experience is going to super suck
09:25:40 <otters> no, I won't
09:25:47 <hiptobecubic> yes
09:25:49 <hiptobecubic> leave it
09:25:52 <otters> okay
09:25:56 <hiptobecubic> you will
09:26:12 <hiptobecubic> and your mind will be blown when you realize what a cluster fuck everything is
09:26:22 <otters> I'm used to clusterfucks
09:26:28 <otters> I mean cmon I use cabal
09:26:33 <hiptobecubic> then you have to wipe out your packages and rebuild everything with -p anyway
09:27:13 <otters> I see
09:27:26 <fmap> or just use cabal-dev sandbox with profiling enabled?
09:27:37 <otters> crazy talk
09:28:27 <hiptobecubic> I don't like to rebuild world for every project
09:32:08 <osa1> my alex lexer returns [] when read EOF, how can I make it return [SomeCustomTokenRepresentingEOF] ?
09:33:32 <hiptobecubic> does that make sense? How does it know when to stop?
09:35:30 <osa1> hiptobecubic: it stops after reading EOF and returning [], what I want it to do is returning [mytoken] after reading EOF.
09:35:44 <hiptobecubic> Does it stop for any other reason?
09:35:52 <osa1> hiptobecubic: I'm already doing that by modifying alex generated code by hand
09:36:05 <osa1> um, when encountered a lexical error
09:36:35 <hiptobecubic> So you can't tell the difference between a lexical error and EOF?
09:37:31 <osa1> hiptobecubic: alex throws an exception when a lexical error occurs
09:39:33 <dmwit> osa1: lex s ++ [yourtoken] -- ?
09:39:57 <osa1> dmwit: I thought this is bad for performance
09:40:19 * dmwit nods agreeably
09:41:24 <osa1> it should be easy, I'm doing that by editing alex generated code by hand and it's only one line of change. but I couldn't find how can I tell that to alex
09:43:30 <simpson> osa1: I don't see why you need to do it this way; dmwit's solution would work fine.
09:44:10 <osa1> simpson: like I said I'm worried about performance problems.
09:44:38 <simpson> osa1: reverse (yourtoken:reverse (lex s))
09:44:49 <dmwit> what
09:44:55 <osa1> not sure if joking
09:45:03 <dmwit> must be joking
09:45:28 <simpson> I'm actually kinda hoping that you're joking about worrying about the list concat being a poor performer. How much are you lexing?
09:47:28 <simpson> (Somebody else indicated, a few weeks ago, that the double-reverse was more efficient for unexplained reasons; guess I should forget that.)
09:48:06 <hiptobecubic> Isn't it moot anyway? Can't you eat the front of the list before worring about ++ ?
09:48:28 <nand`> no
09:48:31 <nand`> (++) constructs a new list
09:48:37 <hiptobecubic> ah
09:48:49 <nand`> the double reverse version surely is less lazy though
09:49:06 <dmwit> Really, though, worrying about an O(n) cost when you're (presumably) about to do an O(n^3) parse is silly.
09:49:15 <dmwit> Or whatever parsing technique he's using.
09:49:25 <dmwit> Very few are linear.
09:50:16 <mcstar> @pl \l e -> [e] ++ l)
09:50:16 <lambdabot> (line 1, column 17):
09:50:17 <lambdabot> unexpected ')'
09:50:17 <lambdabot> expecting letter or digit, variable, "(", operator, ":", "++", "<+>" or end of input
09:50:18 <mcstar> @pl \l e -> [e] ++ l
09:50:18 <lambdabot> flip (:)
09:50:29 <simpson> Well, it's impossible to have a sublinear parse, isn't it? And your number of tokens k is (probably) always going to be smaller than the number of characters n that you have as input?
09:51:15 <dmwit> The cost of (++[EOF]) is proportional to the number of tokens, not the number of characters lexed.
09:51:21 <simpson> @pl \e l -> l ++ [e]
09:51:21 <lambdabot> flip (++) . return
09:51:34 <mcstar> > length $ foldl (\l e -> l ++ [e]) [] [1..1000]
09:51:37 <lambdabot>   1000
09:51:40 <mcstar> > length $ foldl (\l e -> l ++ [e]) [] [1..10000]
09:51:43 <simpson> Right, so that cost is dwarfed by your parse time.
09:51:44 <lambdabot>   mueval-core: Time limit exceeded
09:51:54 <dmwit> This is sort of my point, yes.
09:51:54 <mcstar> > length $ foldl (flip (:)) [] [1..10000]
09:51:56 <lambdabot>   10000
09:53:06 <simpson> > length $ foldl (\l e -> reverse (e:reverse l)) [] [1..1000] -- I'm just curious, that's all.
09:53:08 <lambdabot>   1000
09:53:21 <simpson> > length $ foldl (\l e -> reverse (e:reverse l)) [] [1..10000] -- And another zero?
09:53:25 <lambdabot>   mueval-core: Time limit exceeded
09:53:29 <simpson> Heh.
09:54:11 <nand`> mueval is not a great benchmarking tool
09:54:28 <mcstar> cant this 'lex s ++ [yourtoken]' be translated to 'reverse (at the end) : lex s ?
09:54:49 <mcstar> ofc, make that sensical
09:55:13 <mcstar> reverse ... (yourtoken : lex s)
09:55:14 <simpson> > length $ foldl' (\l e -> reverse (e:reverse l)) [] [1..10000] -- Does it get better if strict? Probably not.
09:55:17 <lambdabot>   10000
09:55:19 <pordan30> @pl m1 >>= \x -> m2 >>= \y -> f x y
09:55:20 <lambdabot> (m2 >>=) . f =<< m1
09:56:01 <pordan30> @pl m1 >>= \x -> m2 >>= \y -> m3 >>= \z -> f x y z
09:56:01 <lambdabot> (m2 >>=) . ((m3 >>=) .) . f =<< m1
09:58:38 <mcstar> maybe that works because of some simplification rule? reverse . reverse = id
09:58:56 <mcstar> my example doesnt get faster with foldl'
09:59:02 <mcstar> l ++ [e]
10:00:48 <nand`> reverse . (e:) . reverse is not reverse . reverse
10:01:35 <mcstar> no, ofc
10:01:40 <mcstar> but:
10:02:12 <mcstar> let l' = reverse (e:reverse l'') in reverse (e:reverse l')
10:02:38 <mcstar> reverse (e:reverse (reverse (e:reverse l''))
10:03:54 <nand`> yes that makes sense
10:06:30 <Thunder_> This is Anonymous. We defecated the fucking European Union Chamber of Commerce in China Member Database: http://pastebin.com/TdEmuXZm
10:06:42 <mauke> The paste TdEmuXZm has been copied to http://hpaste.org/77405
10:07:40 <mcstar> why is he called thunder then?
10:07:45 <mcstar> noob
10:09:43 <nand`> I would be highly worried if I started defecating databases
10:10:39 <Peaker> hmm.. ByteString has no instance of arbitrary?
10:11:26 <mcstar> hm, attack succesfull
10:11:34 <mcstar> my emacs is unresponsive
10:11:44 <mcstar> too much text on one line
10:13:10 <mcstar> also, why does mauke help distribute spam?
10:13:44 * edwardk waves hello.
10:13:44 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:13:47 <edwardk> @messages
10:13:48 <lambdabot> nand` asked 2h 11m 2s ago: Lens.Zipper does infinite zippers in one direction as long as you don't rezip them; but what about infinite bidirectional zippers?
10:14:01 <nand`> because he really dislikes pastebin, I guess
10:14:04 <kirindave> I have a parsec question which is totally unrelated to lenses.
10:14:17 <johnw> kirindave: say it isn't so!
10:14:18 <kirindave> I wrote a parsec rule:
10:14:18 <kirindave> tickP = string "tick" *> wspace *> (tick' <$> (try $ number <|> (spaces *> pure 1)))
10:14:30 <edwardk> @tell nand` because it would mean that you are infinitely deep in a structure.
10:14:31 <lambdabot> Consider it noted.
10:14:32 <kirindave> The try is just me noodling, feel free to ginore.
10:14:35 <nand`> I don't see a lot of overlap between parsers and lenses
10:14:36 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
10:14:37 <nand`> parsec*
10:14:42 <nand`> @messages
10:14:42 <lambdabot> edwardk said 11s ago: because it would mean that you are infinitely deep in a structure.
10:14:46 <edwardk> i think he just wanted to grab my attention ;)
10:14:48 <kirindave> And this obviously is wrong
10:15:03 <kirindave> So the intent is I can say "tick" or "tick 1"
10:15:09 <kirindave> But
10:15:29 <kirindave> If I say "tick muhburfschmirk" then the entire parse ceases at "tick"
10:15:33 <kirindave> w/out error.
10:15:40 <nand`> edwardk: I don't see how it would work out too well either; but maybe zippers could be generalized to two traversals, one in each ‘direction’? and you can go infinitely deep in either direction
10:15:44 <kirindave> What I'd like to do is find a way to consume the bad input.
10:15:50 <nand`> though that practically raises the question ‘why not more?’
10:16:18 <edwardk> kirindave: fromMaybe 1 <$> string "tick" *> optional (wspace *> number)
10:16:25 <kirindave> Ah
10:16:27 <kirindave> Thanks
10:17:19 <edwardk> i actually don't like the bidirectional model. the form of zipper i'm using in lens is designed to be a zipper into an actual traversable, at any point when you are walking that structure you are at a finite position. the only hope i have of rezipping infinite traversals relies on this exploration of a finite portion of a traversal
10:17:51 <nand`> edwardk: does that actually type check? I would guess something like fromMaybe 1 <$ string "tick" <*> optional (wscape *> number)
10:17:56 <edwardk> you give up too much to get what you want. i get the ability to walk down into an impossible level that i could never zip
10:18:17 <edwardk> nand`: thats probably it
10:19:06 <edwardk> you probably need a try around the body of the optional or you'll be right back where you started
10:19:33 <edwardk> fromMaybe 1 <$ string "tick" <*> optional (try (wspace *> number))
10:19:50 <edwardk> that way when it fails after the space it backtracks to not consuming the space.
10:20:08 <edwardk> in practice i tend to deal with space as part of the preceding lexeme, (see the lexeme parser in parsec or trifecta)
10:20:22 <edwardk> that way lexeme (string "tick")   -- takes care of the tick and trailing space.
10:20:47 <nand`> isn't that what parsec does
10:20:49 <edwardk> also you don't want to use string, you probably want a 'keyword' parser that goes through and tries to munch trailing identifier characters
10:20:59 <Peaker> In the Gen monad, can I get a "true" random, rather than a random biased to choose duplicated values? I have a domain large enough to assume no collisions, and I don't want to test collisions
10:21:20 <edwardk> string isn't a lexeme parser
10:21:42 <edwardk> it literally parses that string and doesn't check for dangling identifier text, etc.
10:21:43 <nand`> yeah I've never gone down to the ‘lower level’ of parsec when writing language parsers, I use the built-in stuff that does things like Haskell-y languages (with comments, operators, identifiers, keywords and whatnot)
10:22:03 <nand`> edwardk: yes but I mean in parsec the lexeme parsers work the same way
10:22:07 <edwardk> yes, the token parsing stuff is what would make his life suck less here =)
10:22:09 <edwardk> yep
10:22:17 <edwardk> " (see the lexeme parser in parsec or trifecta)"
10:22:30 <nand`> oh, right
10:22:43 <nand`> somehow I only saw trifecta
10:24:39 * hackagebot PrimitiveArray 0.4.0.0 - Efficient multidimensional arrays  http://hackage.haskell.org/package/PrimitiveArray-0.4.0.0 (ChristianHoener)
10:28:15 <neutrino_> hi!
10:29:41 * hackagebot ADPfusion 0.1.0.0 - Efficient, high-level dynamic programming.  http://hackage.haskell.org/package/ADPfusion-0.1.0.0 (ChristianHoener)
10:29:43 * hackagebot Nussinov78 0.1.0.0 - Nussinov78 using the ADPfusion library.  http://hackage.haskell.org/package/Nussinov78-0.1.0.0 (ChristianHoener)
10:33:08 <erasmas> in the following definition, would numberToChar in the where clause be recomputed on each lookup? lookup x = numberToChar ! x where numberToChar = fromList $ zip [1..] alphabet
10:33:08 <neutrino_> @tell mzero thanks for suggesting hunit. i tried quickcheck first but ended up using that.
10:33:09 <lambdabot> Consider it noted.
10:33:36 <erasmas> (fromList coming from Data.Map if that matters)
10:34:41 <mcstar> no, it is a caf
10:34:54 <neutrino_> what does ! mean?
10:35:13 <nand`> :t (!)
10:35:15 <lambdabot> Ix i => Array i e -> i -> e
10:35:22 <nand`> :t (Data.List.!)
10:35:24 <lambdabot>     Not in scope: `Data.List.!'
10:35:24 <erasmas> mcstar: caf?
10:35:24 <lambdabot>     Perhaps you meant one of these:
10:35:24 <lambdabot>       `Data.List.!!' (imported from Data.List),
10:35:30 <nand`> oh
10:35:38 <mcstar> constant applicative form
10:35:48 <mcstar> something, that doesnt take arguments
10:35:48 <erasmas> nand`: in Data.Map it's a way to lookup a key and return a value or error
10:35:54 <mcstar> simply put
10:36:34 <mcstar> consder lookup, if lookup can fail
10:36:35 <bfig> question about GADTs, why are they not polymorphic when using 'phantom' types?
10:37:07 <bfig> for example, data OTree a where { Nil :: Eq a => OTree a }
10:37:25 <nand`> looks polymorphic to me
10:37:29 <bfig> if in ghci i do let x = Nil, i get :t x == OTree ()
10:37:40 <rwbarton> monomorphism restriction
10:37:44 <bfig> if i try to reinterpret the data as OTree Int ...
10:37:58 <mcstar> ghci defaulting
10:38:13 <erasmas> mcstar: thanks, I'll look into cafs (and I know ! isn't safe, but this is a small exercise where I control the input)
10:38:13 <bfig> why does it default? shouldn't that be Ord a => OTree a ?
10:38:22 <nand`> extended defaulting rules
10:38:34 <rwbarton> ":set -XNoMonomorphismRestriction" and try again
10:38:39 <bfig> it is set
10:38:40 <nand`> and monomorphism restriction
10:38:41 <nand`> simply put, disable it
10:38:45 <nand`> works fine for me
10:38:58 <bfig> {-# LANGUAGE TypeSynonymInstances,NoMonomorphismRestriction,GADTs #-}
10:39:10 <rwbarton> needs to be set *in ghci*
10:39:10 <nand`> set it in GHCi as well, since you're defining x in GHCi
10:39:14 <bfig> ohh!
10:39:14 <rwbarton> yes
10:39:25 <nand`> ‘Nil’ is already polymorphic, even with monomorphism restriction
10:39:27 <nand`> that's not the problem
10:39:27 <nand`> the problem is ‘let x =’
10:39:38 <bfig> nice :D
10:39:52 <bfig> with -X... works
10:40:07 <mcstar> ghci should read the language pragma too
10:40:09 <ucefkh> hey functional pro l
10:40:12 <bfig> i don't really understand monomorphism restriction
10:40:13 <mcstar> i think it does
10:40:39 <bfig> i don't think it can be explained with examples like in the docs, but the theoretical explanation is a bit hard to follow
10:41:32 <ion> bfig: A top-level definition that looks like “let a = …” (without any explicit parameters) without a type signature doesn’t get a polymorphic type with the monomorphism restriction.
10:42:12 <ion> bfig: “f :: Num a => a -> a -> a” essentially compiles to something like “f :: Num a -> a -> a -> a” where the first parameter is a dictionary of Num methods.
10:42:39 <bfig> so the no monomorphism restriction locks down the dictionary every declaration?
10:43:20 <bfig> *the monomorphism restriction
10:43:26 <bfig> (?)
10:44:26 <ion> bfig: “x :: Integer” is not a function but “x :: Num a => a” can actually behave like functions do in runtime. The monomorphism restriction forces a definition of “x” that isn’t a function and doesn’t have an explicit type signature to be monomorphic, perhaps :: Integer.
10:44:47 <bfig> ohh i understand now
10:45:14 <bfig> so anything that won't take an explicit parameter will be locked down to a type if the restriction is up?
10:45:31 <ion> Any top-level definition without a type signature, yes.
10:45:41 <rwbarton> if it is polymorphic in a type that has a class context
10:45:51 <ion> Indeed
10:46:03 <bfig> so if you have something like :: concrete or :: Concrete sth
10:46:38 <bfig> even if you it depends for example on the Num instance that fills 'sth'
10:46:50 <bfig> so why was this restriction put?
10:47:48 <bfig> i understand there might be some extra complexities in the compiler, but was there any programmatic purpose for it?
10:48:32 <beaky> what editor is best for Haskell?
10:48:40 <geekosaur> @where dmr
10:48:40 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
10:48:48 <nand`> either vim or emacs, depending on who you ask
10:48:52 <ion> “xs :: [Integer]” can be memoized, “xs :: Num a => [a]” can’t (or can it in some cases? anyone?). If you add the top-level definition “primes = 2 : filter isPrime [3,5..]” without a type signature and expect it to be memoized, it can be surprising if it doesn’t.
10:48:56 <mcstar> emacs, definitely
10:49:03 <nand`> vim, definitely :)
10:49:07 <mcstar> :)
10:49:13 <ion> GRUB 2 IS BETTER THAN KDE.
10:50:33 <ion> bfig: I use NoMonomorphismRestriction in ghci, but i never add that to .hs files. I simply add type signatures to all top level definitions anyway, so monomorphism restriction doesn’t apply.
10:51:34 <Pantoufle> Bon
10:51:37 <Pantoufle> oops
10:51:39 <bfig> ok, awesome
10:51:53 <ucefkh> ce n'est pas bon
10:51:56 <ucefkh> ouff
10:53:54 <ucefkh> Haskell best Programming language
10:53:56 <ucefkh> ?
10:54:37 <ion> Yes. (This answer isn’t biased at all.)
10:54:43 <nand`> what ion said
10:54:50 <nand`> except for diagrams, where it's common to leave off type sigs
10:59:39 * hackagebot timeparsers 0.3.2 - Attoparsec parsers for various Date/Time formats.  http://hackage.haskell.org/package/timeparsers-0.3.2 (PhilipWeaver)
10:59:41 * hackagebot yesod 1.1.3 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.3 (MichaelSnoyman)
11:02:19 <osa1> wow, have anyone else seen this error: http://hpaste.org/77406
11:03:49 <shachaf> @google Irrefutable pattern failed for pattern Data.Maybe.Just (inst_tyvars
11:03:52 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7079
11:03:52 <lambdabot> Title: #7079 (Irrefutable pattern failed for pattern Data.Maybe.Just) – GHC
11:03:58 <shachaf> Apparently!
11:04:40 * hackagebot yesod-core 1.1.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.4 (MichaelSnoyman)
11:09:42 * hackagebot yesod-default 1.1.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.1 (MichaelSnoyman)
11:09:44 * hackagebot yesod-form 1.1.4 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.1.4 (MichaelSnoyman)
11:09:46 * hackagebot yesod-json 1.1.1 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.1.1 (MichaelSnoyman)
11:09:48 * hackagebot yesod-routes 1.1.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.1.1 (MichaelSnoyman)
11:09:50 * hackagebot yesod-static 1.1.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.1 (MichaelSnoyman)
11:14:52 * hackagebot yesod-test 0.3.1 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.3.1 (MichaelSnoyman)
11:15:29 <osa1> why I can't make [Char] instance of a typeclass ?
11:15:56 <typoclass> osa1: do you have the extension enabled that ghc suggests? i think its name is FlexibleInstances
11:16:29 <osa1> typoclass: no. I mean why do I need to enable that, because it looks like a very normal instance declaration to me
11:16:36 <callen> lets say I've got an array of coefficients, and I want the reduction of multiplying the coefficients for every previous value of the array, but not all of them, for each value.
11:16:51 <callen> in an iterative language I'd use an index to backtrack the array or accum the antecedents
11:16:54 <shachaf> osa1: The Report answers that question.
11:17:01 <callen> how would I do this in Haskell?
11:17:18 <typoclass> osa1: not sure, some historical reason :-) you're right that it's one of the straightforward, uncontroversial extensions
11:17:51 <osa1> shachaf: which chapter ?
11:18:03 <shachaf> It's not quite just historical reasons.
11:18:46 <shachaf> I don't know, but I bet I could find it.
11:18:50 <shachaf> @google FlexibleInstances
11:18:52 <lambdabot> http://hackage.haskell.org/trac/haskell-prime/wiki/FlexibleInstances
11:18:53 <lambdabot> Title: FlexibleInstances – Haskell Prime
11:19:26 <callen> should I do a fold? how would I reference the preceding half of the mapped iterable?
11:20:20 <Peaker> In QuickCheck, say I want to verify that   f x == Just (g x),  when f x = Nothing, I want to ignore that (similarly to ==>)
11:20:33 <Peaker> any idea how to do such a thing?
11:20:45 <Peaker> could use sort of an "abort this quick check branch"...
11:20:47 <kirindave> Has anyone made a toolkit to do the brute work of defining a Free monad based interpreter?
11:20:58 <kirindave> Like you have to repeat yourself several times for the standard approach
11:21:05 <kirindave> Seems like an easy win for template haskell.
11:21:16 <Peaker> apparently there's an unexported "rejected" that I want to use
11:21:17 <hpaste> tomeo pasted “How can this give Prelude.(!!): index too large?” at http://hpaste.org/77407
11:21:17 <kirindave> FreeT for that matter as well.
11:22:00 <Peaker> tomeo, y is [] ?
11:22:19 <Peaker> randomRIO (1, 0) gives 0..1
11:22:47 <tomeo> Peaker: It shouldn't be []
11:22:51 <neutrino_> is "do func" the same as "func"?
11:22:53 <shachaf> Peaker: Did you look at the definition of ==>?
11:22:59 <shachaf> (==>) :: Testable prop => Bool -> prop -> Property; False ==> _ = property rejected; True  ==> p = property p
11:23:05 <shachaf> I'm guessing you could do something similar.
11:23:05 <Peaker> tomeo, if there's just one element, you'll include 1 in your range too
11:23:06 <neutrino_> @undo do { foo }
11:23:07 <lambdabot> foo
11:23:10 <neutrino_> hmm
11:23:12 <neutrino_> great
11:23:13 <Peaker> shachaf, yeah, rejected is not exported, apparently?
11:23:41 <Peaker> oh, everything is exported. How terrible :)
11:23:42 <shachaf> Oh.
11:23:45 <tomeo> Peaker: if I have a list with one element woulnt length - 1 be 0 then?
11:24:06 <shachaf> Peaker: Everything is exporte from .Property.
11:24:12 <shachaf> The main module reëxports some of it.
11:24:24 <erasmas> callen: check out accumArray if you're really using Data.Array. you can accumulate into any new type you want (including an array of the same type) and have a combining function that accepts the accumulated value so far and the next value from the array
11:24:35 <erasmas> it can probably be expressed as a fold also, but I'm not sure if there's a fold method in the array package
11:25:26 <fmap> tomeo: randomRIO (1,0) could be 1
11:25:38 <callen> erasmas: it's an algorithm question, not a data one. I misspoke. It could just as well be a list of floats.
11:26:19 <tomeo> fmap: I dont see how that could be a problem. Wouldnt I just try to get element of index 0 then?
11:27:10 <rwbarton> > randomR (1,0) (mkStdGen 17)
11:27:12 <lambdabot>   (1,720252 40692)
11:27:23 <rwbarton> why isn't that an error
11:27:29 <erasmas> callen: well it is a data structure question in that the structure you choose will determine the functions available to you. but what you're describing can be expressed as a fold
11:27:54 <callen> erasmas: okay, my brain is broken. I guess I'll try to think about how to do it with a fold.
11:28:14 <fmap> tomeo: no, if randomRIO (1, 0) is 1, then you will try to get eleent of index 1
11:28:14 <erasmas> callen: if you have a small example you can hpaste I'm sure someone here can help fill in the blanks
11:28:42 <callen> erasmas: I don't have much just yet. I'm still getting the initial map of the coefficients working. After that, it'd just be comments trying to express what I want.
11:28:49 <callen> I don't have broken code, just a broken brain.
11:29:12 <ski> > randomR (1,0) (mkStdGen 0)
11:29:14 <lambdabot>   (1,40014 40692)
11:29:34 <tomeo> thanks fmap
11:29:47 <Peaker> shachaf, yay! got a bit of QuickCheck coverage (I think, haven't looked at arbitrary inputs) of the inference engine for expressions (in bottle)
11:29:47 <johnw> callen: your problem sounds exactly like Comonad solves
11:30:00 <rwbarton> > randomR (100,0) (mkStdGen 0)
11:30:01 <lambdabot>   (25,40014 40692)
11:30:06 <johnw> for each position in the array, compute a value based on all the previous members of the array
11:30:13 <rwbarton> interesting interpretation of the range
11:30:20 <callen> johnw: yeah that's basically it.
11:30:28 <johnw> i've actually seen this problem solved
11:30:29 <johnw> one sec
11:31:24 <sonOfRa> Hi there! I'm quite a newbie to Haskell, and I'm trying to build my own Bitlist type, that also supplies the methods normal lists include, like head,tail etc. If i defined my Bitlist like this:
11:31:29 <sonOfRa> data Bitlist = EmptyList
11:31:29 <sonOfRa> 	           | Bitlist Bit Bitlist
11:31:29 <sonOfRa> 	           deriving Show
11:31:57 <sonOfRa> Would this be a correct implementation of tail? It seems to give the right results, however I am not sure if it is actually the correct way to do it:
11:31:59 <sonOfRa> btail :: Bitlist -> Bitlist
11:32:00 <sonOfRa> btail EmptyList = error "The list is empty"
11:32:00 <sonOfRa> btail (Bitlist x y) = y
11:32:15 <mauke> sonOfRa: yes
11:32:18 <ski> looks fine, as far as tail goes
11:32:22 <mauke> also, don't paste code into the channel
11:32:42 <sonOfRa> right, pastebin. thought it'd be okay for short pasties.
11:32:49 <mm_freak> @where hpaste
11:32:50 <lambdabot> http://hpaste.org/
11:34:00 <callen> sonOfRa: always use hpaste.
11:34:43 <mauke> sonOfRa: 8 lines isn't short
11:34:59 <callen> johnw: if you're curious, this is the problem I'm trying to model in Haskell: http://www.solipsys.co.uk/new/TheBirthdayParadox.html?HN2
11:35:02 <johnw> callen: map sum (inits [1,2,3])
11:35:13 * ski thinks 10 lines isn't long, ymmv
11:35:13 <johnw> > inits [1,2,3]
11:35:15 <lambdabot>   [[],[1],[1,2],[1,2,3]]
11:35:21 <callen> oh that is brilliant.
11:35:28 <johnw> > tails [1,2,3]
11:35:30 <lambdabot>   [[1,2,3],[2,3],[3],[]]
11:35:34 <johnw> one of those is what you want
11:35:38 <callen> johnw: thank you, that is a *big* help.
11:35:42 <callen> inits solves it all for me :)
11:36:02 <johnw> cool!
11:37:32 <callen> I am curious as to how it'd be done with a fold though.
11:37:36 <Peaker> I only actually quick-check the random expressions that type-check, so I think my quick checks aren't yet worth much (since the vast majority will fail to type check)
11:41:56 <neutrino_> @undo do { x <- getArgs; let y = fst x }
11:41:57 <lambdabot>  Parse error at "}" (column 34)
11:42:08 <neutrino_> @undo do { x <- getArgs; let y = fst x; }
11:42:09 <lambdabot>  Parse error at "}" (column 35)
11:42:14 <neutrino_> @undo do { x <- getArgs; let y = fst x; return () }
11:42:15 <lambdabot>  Parse error at "}" (column 45)
11:42:15 <Rc43> Hi, guys.
11:42:23 <neutrino_> i'm doing something wrong aren't i
11:42:31 <neutrino_> hi Rc43
11:42:33 <Rc43> I have strange error with type synonyms and phantom types.
11:42:42 <hpaste> Rc43 pasted “Strange error with type synonyms and phantom types” at http://hpaste.org/77408
11:42:42 <shachaf> @undo do { x <- getArgs; let { y = fst x }; return () }
11:42:43 <lambdabot> getArgs >>= \ x -> let { y = fst x} in return ()
11:42:57 <neutrino_> right
11:43:12 <Peaker> getArgs returns a list, not a tuple, so "fst" on it isn't useful, btw
11:43:22 <Peaker> s/isn't useful/doesn't type-check
11:43:23 <neutrino_> yeah, just wanted any ol function
11:43:24 <shachaf> Rc43: That's the same as class TestClass a where constant :: Int
11:43:31 <shachaf> How can it figure out which instance to use?
11:43:31 <neutrino_> was actually thinking of head
11:43:39 <Rc43> This error disapears if I replace `type Constant a = Int` with `data Constant a = Constant Int`.
11:44:15 <shachaf> Sure.
11:44:27 <shachaf> Because now you have an actual type.
11:44:32 <neutrino_> are you trying to implement type system integers?
11:44:36 <shachaf> You can use newtype rather than data if you prefer.
11:44:37 <nand`> jfischoff: odd, singletons is giving me not in scope errors when I try using ‘singletons’ instead ‘promote’
11:44:40 <Rc43> shachaf, but `constant::Int` doesn't compile (because it must know real type). I thought that phantom type helps with "indexing" this INt.
11:44:40 <hpaste> sonOfRa pasted “Stupid init” at http://hpaste.org/77409
11:44:42 <typoclass> neutrino_: this may or may not be what you wanted, but "fst <$> getArgs'" is also a possibility (supposing getArgs' returns a 2-tuple)
11:44:49 <sonOfRa> So, I'm doing init
11:44:53 <neutrino_> mhm
11:44:57 <sonOfRa> my init is obviousky NOT the right way to do it
11:44:59 <Cale> Rc43: It's because writing Constant Test is the same thing as writing Int
11:45:00 <nand`> oh
11:45:01 <shachaf> Rc43: Yes, the phantom type helps. But with a synonym you don't have a real phantom type.
11:45:02 <sonOfRa> but I cannot think of a proper way
11:45:03 <jfischoff> nand`: I haven't seen that
11:45:05 <nand`> I need to define the data type in the definition
11:45:06 <nand`> my bad
11:45:12 <jfischoff> ah
11:45:26 <Cale> Rc43: You should get the same error message if you write  constant :: Int
11:45:35 <jfischoff> nand`: trying to generalize a type level associative array
11:45:41 <Rc43> shachaf, "with a synonym you don't have a real phantom type" -- why so?
11:45:47 <Cale> Rc43: and perhaps that provides a hint as to why it's hard to say which type a to use
11:45:57 <Rc43> Cale, why one variant can be compiled ant other no?
11:46:01 <Peaker> sonOfRa, Use pattern-matching for the second case too
11:46:06 <shachaf> Rc43: Because type synonyms are approximately on the level of #define
11:46:15 <shachaf> #define CONSTANT(a) Int
11:46:16 <Cale> Rc43: Because data doesn't define synonyms for existing types
11:46:24 <Cale> Rc43: it defines honestly new types
11:46:36 <Peaker> sonOfRa, also, reverse . tail . reverse is less lazy than possible
11:47:07 <Peaker> sonOfRa, what's that type?
11:47:17 <Peaker> where is the "EmptyList" constructor defined?
11:47:34 <hpaste> sonOfRa pasted “Bitlist ” at http://hpaste.org/77410
11:49:41 <Cale> sonOfRa: There's a tab in your code
11:49:55 <callen> tabs are the mark of the devil.
11:49:57 <Cale> sonOfRa: Make sure to configure your text editor to convert tabs to spaces
11:50:19 <sonOfRa> Huh. never had that cause any problems before
11:50:23 <sonOfRa> will do though.
11:51:01 <Cale> sonOfRa: Well, it's "okay" so long as your editor is configured to treat tabs as aligning to the next multiple of 8 spaces
11:51:19 <Cale> But not everyone's editor is, and so you end up with problems.
11:51:31 <sonOfRa> Good to know that.
11:51:41 <Cale> (the compiler will treat them as 8-space tabs)
11:51:51 <Peaker> \x09 is an unstandardized character in the midst of standard unicode/ascii files. I find it difficult to fathom that so many support their use despite all the practical difficulties
11:52:14 <S11001001> I was running out of disk until I converted all my 8-spaces to tabs
11:52:21 <S11001001> now I have stacks of free disk. Thanks, tab!
11:52:43 <Cale> lol
11:52:59 <mroman> @check \a -> a == a
11:53:00 <lambdabot>   Not in scope: `myquickcheck'
11:53:01 <sonOfRa> That sure were a lot of spaces, lol
11:53:26 <shachaf> Here's a nickel, kid. Go buy yourself some real indentation.
11:53:43 <callen> sonOfRa: consider using Emacs or vim.
11:53:49 <Cale> The "blank" part of the disk is filled with spaces, so by replacing them with tabs, you get more room. ;)
11:54:00 <sonOfRa> Currently on Notepad++ on Windoze
11:54:05 <simpson> This sounds like Windows 98 disk compression.
11:54:11 <simpson> (Does anybody else remember that?)
11:54:31 <callen> sonOfRa: I feel like I should grab an NPR correspondent to interview you on what the computational third world is like
11:55:09 <johnw> how do I apply an arbitrary function over a lens traversal?
11:55:19 <johnw> ^! traverse.sum becomes...?
11:55:48 <fmap> :t to
11:55:49 <lambdabot> Gettable f => (s -> a) -> (a -> f a) -> s -> f s
11:56:07 <johnw> so, sumOf (traverse.to tails) [1,2,3]?
11:56:21 <rwbarton> > sumOf (traverse.to tails) [1,2,3]
11:56:23 <lambdabot>   No instances for (GHC.Num.Num [[a0]], GHC.Num.Num [a0])
11:56:23 <lambdabot>    arising from a u...
11:57:09 <neutrino_> is there a way to force test-framework to show colours even when it's being run by "cabal test"?
11:57:31 <neutrino_> i think it has some magical tty discovery and i don't want that
11:57:38 <johnw> oh, tails is being applied to the Num
11:58:06 <johnw> sumOf (traverse.to (+1)) [1,2,3]
11:58:09 <johnw> that works great
12:00:52 <tomeo> Is there a function in Prelude that will take a function and a value and run the function on the value until the value doesnt change any more?
12:01:23 <Cale> tomeo: nope
12:01:26 <shachaf> No.
12:01:30 <simpson> tomeo: fix? It isn't in the Prelude, but it's easy to define.
12:01:40 <Cale> That's not fix
12:01:44 <mapf>  :t fix
12:01:46 <tomeo> simpson: could you elaborate?
12:01:47 <shachaf> fix is a function for finding fixed points, but not really what tomeo asked for.
12:01:54 <mapf> :i fix
12:01:58 <simpson> I guess I don't get what tomeo's asking for.
12:02:00 <Cale> :t fix
12:02:01 <simpson> :t fix
12:02:01 <lambdabot> (a -> a) -> a
12:02:02 <lambdabot> (a -> a) -> a
12:02:08 <nand`> jfischoff: is there a way to define a kind alias?
12:02:11 <tromp__> fix has no starting point
12:02:21 <simpson> Oh, you want something of type (a -> a) -> a -> a
12:02:28 <simpson> Derp.
12:02:32 <tromp__> you want something like itrerate with postprocessing
12:02:33 <shachaf> tomeo's asking for foo f x | x == x' = x | otherwise = foo f x' where x' = f x
12:02:35 <tomeo> I have a function which reduces a string according to some rules. I want to reduce it until I can't reduce it any more.
12:02:36 <mauke> iterate f x, ap zip tail, dropWhile uncurry (/=)
12:02:39 <Cale> simpson: (Eq a) => (a -> a) -> a -> a
12:02:44 <jfischoff> nand`: no idea … can't think of what it would be
12:02:55 <jfischoff> nand`: oh but to answer an earlier question
12:02:56 <nand`> ‘Promotion of type synonym declaration not yet supported’ I guess singleton doesn't know either :P
12:03:07 <neutrino_> hmm is there a way for "cabal test" to pass a command line switch to the binary it executes?
12:03:18 <mauke> :t head . dropWhile (uncurry (/=)) . ap zip tail . iterate ?f
12:03:19 <tromp__> but it's easier to write from scratch
12:03:19 <lambdabot> (?f::b -> b, Eq b) => b -> (b, b)
12:03:28 <mauke> :t fst . head . dropWhile (uncurry (/=)) . ap zip tail . iterate ?f
12:03:29 <lambdabot> (?f::b -> b, Eq b) => b -> b
12:03:31 <neutrino_> either via a setting in the .cabal or command line switch to cabal test
12:03:34 <jfischoff> nand`: it will promote polymorphic code (functions, etc) to kind polymorphic code
12:04:33 <ForSpareParts> How can I expose packages I installed with cabal so that I can import them in GHCi?
12:04:52 <mauke> "expose"?
12:04:53 <shachaf> ForSpareParts: The approach I usually use is "doing nothing".
12:06:03 <johnw> callen: you asked how to do the inits thing with a fold?
12:06:06 <johnw> > scanl (\acc x -> x + acc) 0 [1,2,3]
12:06:08 <lambdabot>   [0,1,3,6]
12:06:13 <johnw> > map sum (inits [1,2,3])
12:06:15 <lambdabot>   [0,1,3,6]
12:06:27 <johnw> > scanl (+) 0 [1,2,3]
12:06:28 <lambdabot>   [0,1,3,6]
12:06:38 <ForSpareParts> shachaf, mauke: I assumed there was a step I was missing -- I installed a package from cabal and couldn't import something I expected to be able to find. I was wrong, though -- looks like I've got the wrong package. My bad.
12:06:46 <johnw> scanl is a fold is that returns all the intermediate accumulators
12:09:30 <monochrom> default is expose. you do nothing. just install
12:11:11 <neutrino_> ooo you can do cabal test --test-option="--color"
12:11:26 <neutrino_> and then you get nice colours
12:11:30 <neutrino_> this is great
12:13:27 <johnw> neutrino_: has no effect for me
12:13:41 <jfischoff> nand`: I keep forgetting I need add deriving(Eq) to get the :==: to be generated :p
12:14:04 <nand`> oh, that exists? sweet
12:14:55 <jfischoff> yeah and Show
12:16:46 <nand`> :==: and ~ seem to have unfortunate fixivity
12:16:59 <nand`> u :==: v ~ True  gets parsed as u :==: (v ~ True) it seems
12:17:37 <johnw> sometimes I want a GHC extension where operators without whitespace around them bind higher than function application: foo x^.member
12:18:13 <nand`> meh
12:18:28 <nand`> that would break lens code where lenses aren't just names
12:18:36 <nand`> eg. stuff that uses Iso
12:18:44 <johnw> i did say "sometimes" :)
12:18:46 <nand`> unless you use a space, of course
12:18:52 <johnw> foo n+1 n+2
12:19:29 <Heffalump> is there any straightforward way to track down the cause of a stack overflow in a large program?
12:19:47 <nand`> jfischoff: oh no, I get a huge type unification error on :==: ... :&& ... :==: ...
12:19:48 <johnw> Heffalump: heap profiling
12:20:02 <nand`> seems like it doesn't reduce, to either True or False
12:20:17 <jfischoff> nand`: that probably means that some type is missing a :==: instance
12:20:33 <johnw> nand`: are you guys doing this in Haskell?
12:20:51 <jfischoff> maybe you forgot a deriving(Eq) or you are comparing something that doesn't have one defined yet
12:21:27 <jfischoff> johnw: surprisingly you can do a vary amount of type level programming in Haskell
12:21:42 <nand`> jfischoff: oh, hurr, I haven't defined :==: on my own Int
12:21:52 <nand`> jfischoff: do you know if I can write an instance Eq Int where ... and have that auto-lifted to :==: ?
12:21:55 <johnw> i was reading pigworker's thoughts on dependent typing in Haskell last night
12:22:00 <johnw> seems like an interesting field of research
12:22:13 <jfischoff> nand`: I doubt it
12:22:30 <Heffalump> johnw: and look for what?
12:22:37 <jfischoff> johnw: link?
12:22:41 <nand`> I wonder how ... deriving Eq  works then, does singletons derive that on its own?
12:22:50 <jfischoff> nand`: exactly
12:22:56 <nand`> I see
12:23:49 <johnw> jfischoff: http://stackoverflow.com/questions/12961651/why-not-be-dependently-typed/13241158#13241158
12:24:14 <johnw> Heffalump: and look for which expression is causing the most allocations
12:24:35 <johnw> it won't be exactly right much of the time, but it will give you an idea where to look
12:26:12 <tomeo> What is the pattern for a non empty list? When I don't want an argument from the list as in (x:xs)
12:26:25 <jfischoff> johnw: the singleton approach to emulating dependent types in Haskell is what nand` and I exploring with the singleton library. It uses TH to avoid some boilerplate.
12:26:32 <Heffalump> I'm a little skeptical, because the default stack is quite small and actual heap allocations would likely outweigh the allocations generating the stack overflow, but I could give it a go
12:26:45 <nand`> jfischoff: .. oh
12:26:55 <nand`> jfischoff: :==: isn't defined for Symbol
12:27:09 <tomeo> ahh, two patterns... x and []
12:27:14 <jfischoff> do you mean the built in GHC Symbol?
12:27:18 <nand`> yes
12:27:37 <jfischoff> oh yeah ignore that thing
12:27:55 <nand`> singletons has its own Symbol?
12:28:36 <jfischoff> sort of. in the singletons examples tarball they build one. I extended it a little bit. one sec...
12:28:49 <nand`> hmm; does it allow using string literals though?
12:29:24 <jfischoff> nand`: no
12:29:27 <jfischoff> https://github.com/jfischoff/oxymoron/blob/master/src/Oxymoron/Description/Symbol.hs#L14
12:29:59 <nand`> that's unfortunate
12:30:07 <jfischoff> nand`: very
12:30:23 <nand`> I guess I'll have to wait for the built-in lits to be improved
12:30:33 <nand`> before I do this the way I really want to
12:30:41 <jfischoff> yeah
12:31:44 <jfischoff> on the other hand, I think showing some neat examples of using a computable Symbol type, could motivate folks to fix things.
12:32:06 <nand`> my use case is and remains units of measure
12:32:12 <nand`> I'm sitting on something that looks like this:
12:33:20 <nand`> I uh.. huh
12:33:29 <jfischoff> If the symbol names are mostly predefined you should be okay
12:33:30 <nand`> ghci is panicing when I'm trying to load the file I wrote last night
12:33:57 <nand`> ‘lookupVers2’ <<details unavailable>>
12:34:26 <jfischoff> I just did premade things like Color, Position, etc. instead of [CO, CL, CO, CR] etc
12:34:42 <jfischoff> err
12:34:42 <jfischoff> CC
12:35:10 <nand`> jfischoff: yeah, but the point here is that it should be extensible
12:35:33 <hpaste> int80_h pasted “fun with http-conduit - part 2” at http://hpaste.org/77413
12:35:33 <jfischoff> nand`: well it still is, just not in a prettiest way
12:35:54 <nand`> either way I'm sitting on something that's going to look like:  Meter/Second = ["m" :-> 1, "s" :-> -1]
12:36:36 <nand`> as kind [Assoc Symbol Integer]; supposing we get computable type-level integers
12:38:33 <jfischoff> right which would look like [[CM] :-> 1, [CS] :-> -1] or type M = [CM] … and then [M :-> 1, S :-> -1]
12:38:54 <nand`> yeah
12:39:36 <jfischoff> Its not great, but it still might work
12:39:38 <nand`> I guess it could work out if I have the user define type aliases for that
12:39:45 <nand`> maybe some TH would be nice for lifting those :P
12:40:04 <nand`> the thing is, the list of units isn't set in stone, users should be able to add their own on a whim; thus the Symbol thing
12:40:13 <nand`> preferably with the least amount of hassle
12:41:46 <m_fulder> hello!
12:42:13 <jfischoff> nand`: I think I have a generic associative array working https://gist.github.com/4034291
12:42:39 <m_fulder> Im using Haskell 6.x and trying to use the function elemIndex (in List) or isNothing (from Maybe) but I just keep getting Not in scope, are they functions new function in the latest haskell or have I installed something wrong?
12:43:31 <jfischoff> nand`: I can't take credit for the reorder function. Richard Eisenberg sent me it to me.
12:43:51 <simon> @pl liftM *** liftM
12:43:52 <lambdabot> fmap *** fmap
12:44:10 <simon> thanks.
12:44:20 <jfischoff> nand`: I imagine a similar approach would work for a Set. Although I am in no way ensure that elements or keys are not duplicated
12:45:00 <monochrom> what is Haskell 6.x? Is that actually GHC 6.x?
12:45:11 <m_fulder> yeah sry I ment GHC
12:45:35 <mauke> m_fulder: Data.List, Data.Maybe
12:46:22 <monochrom> if typing code in file: import List, import Maybe. if typing in ghci: first enter :m + List Maybe
12:46:44 <m_fulder> ah so I need to import them? I thought they would be loaded as standard
12:47:03 <johnw> no, they are not loaded by default by either GHC or GHCi
12:47:25 <S11001001> m_fulder: only one thing is loaded by default, Prelude
12:47:27 <m_fulder> then how come I can create Just / Nothing types and use lists like x:xs ?
12:47:28 <monochrom> beware, "import" != "load"
12:47:39 <m_fulder> aha
12:47:44 <monochrom> because they are in Prelude
12:47:51 <m_fulder> I see :)
12:49:09 <m_fulder> perfectly now it works, thanks a lot guys :)
12:51:42 <nand`> jfischoff: re: Symbol I just remembered we already have an arbitrarily extensible kind, *
12:51:55 <nand`> I'll just use * instead of Symbol and rely on ‘data M; data KG, data S’ etc.
12:52:38 <nand`> though defining the :==: on those is a bit tedious as well
12:53:39 <nand`> ideally I'd want data SI = M | KG | S  ... deriving Eq; but then they all have kind SI instead of kind *
12:54:23 <jfischoff> nand`: Sing (a :: SI) has kind *
12:54:57 <jfischoff> nand`: got to land, ttyl
12:55:00 <nand`> hmm, indeed
12:55:02 <nand`> alright
13:04:18 <hpaste> krey_ pasted “GADTs” at http://hpaste.org/77415
13:04:38 <krey_> can someone explain what's happening here?
13:05:51 <neutrino_> here be dragons
13:06:39 <tac-nap> krey_: sure
13:06:51 <tac-nap> What part are you having confusion about?
13:07:03 <lpvb> @pl \(a,b,c) -> a
13:07:03 <lambdabot> (line 1, column 7):
13:07:03 <lambdabot> unexpected "c"
13:07:03 <lambdabot> ambiguous use of a non associative operator
13:07:16 <Eduard_Munteanu> krey_: knowing you have WatInt, you know what 'a' is. It's an Int.
13:07:17 <neutrino_> tac-nap: i'm guessing he's confused about why the pattern match happens
13:07:29 <neutrino_> or is he?
13:07:38 <neutrino_> no, it's me being confused.
13:07:48 <hpaste> int80_h pasted “Case of the mysteriously closed handle” at http://hpaste.org/77416
13:07:50 <lpvb> what's wrong with the pointless on that lambda?
13:07:52 <krey_> neutrino_, yeah sounds about right
13:07:57 <lpvb> pointfree*
13:08:19 <tac-nap> krey_: WatInt has type Wat Int
13:08:33 <Eduard_Munteanu> @pl \(a,(b,c)) -> a
13:08:33 <lambdabot> fst
13:08:33 <tac-nap> So it matches Wat a (the type you're pattern matching)
13:08:42 <tac-nap> and the variable a MUST be Int
13:09:12 <neutrino_> basically the type of interasding isn't Wat a -> a, it's Wat Int -> Int
13:09:25 <neutrino_> because you have constrained the type of the first parameter elsewhere
13:09:41 <hpaste> tac-tics annotated “GADTs” with “GADTs (annotation)” at http://hpaste.org/77415#a77417
13:09:44 <neutrino_> don't forget a is called a "type variable"
13:09:45 <fmap> lpvb: @pl cannot into big tuples
13:09:46 <Eduard_Munteanu> I don't think that's right.
13:09:55 <neutrino_> and you can solve for that variable
13:09:58 <lpvb> fmap: okay thanks
13:10:05 <neutrino_> in this case you've solved it to be Int
13:11:21 <krey_> but, WatInt itself as a 'piece of data' is essentially useless, no?
13:11:30 <neutrino_> it's thrown away
13:11:44 <neutrino_> however, not entirely
13:11:44 <tac-nap> krey_: correct
13:11:59 <tac-nap> krey_: It's no different than (), really
13:12:02 <tac-nap> (more or less)
13:12:03 <neutrino_> because your function could also become defined for other arguments of type Wat a
13:12:14 <neutrino_> so you could have foo WatInt = 0
13:12:18 <neutrino_> foo x = 1
13:12:37 <neutrino_> in this case the information that the parameter was WatInt is expressed in the return value
13:13:04 <c_wraith> ah, phantom types with GADTs.  They're so handy.
13:13:12 <neutrino_> so as you see it's not "useless", it's just that you've created a very minimal world in which this information cannot be expressed
13:13:15 <Eduard_Munteanu> Mind you *have* to pattern-match.
13:13:18 <Eduard_Munteanu> (I think.)
13:13:38 <ski> krey_ : the purpose of `WatInt' is to communicate that `a' in `Wat a' *must* have been `Int'
13:13:56 <neutrino_> well not only
13:14:03 <neutrino_> what if you had WatInt2 :: Wat Int
13:14:21 <neutrino_> and had interasding WatInt2 = 7
13:14:25 <krey_> so if I define f :: Wat a -> a, f _ = 1, is that ok?
13:14:32 <ski> krey_ : no
13:14:41 <c_wraith> Eduard_Munteanu: yes, you have to pattern match to get the type out of a GADT constructor. With a case statement (or the equivalent in a function definition), too. Otherwise GHC complains about its brain exploding.
13:15:14 <ski> krey_ : you must pattern-match on `WatInt', to uncover the "evidence" that `a' was actually `Int', so that you can return an `Int'
13:15:22 <neutrino_> ski: isn't it ok if he resolves the ambiguity elsewhere in the code?
13:15:30 <Eduard_Munteanu> Think of it another way. forall a. Wat a -> a. That basically says, for all types 'a', if you give me a 'Wat a' I can give you back an 'a'. Now, you can't give me anything other than a 'Wat Int', so the result is an Int.
13:15:43 <neutrino_> after all a is also in the value that f evaluates to, so that can be used to solve it too
13:15:50 <ski> neutrino_ : yes, but assuming `f :: forall a. Wat a -> a', that isn't possible
13:16:07 <neutrino_> i don't see an foralll
13:16:15 <neutrino_> what have i missed?
13:16:21 <monochrom> implicit "forall"
13:16:26 <krey_> uhh, is it possible to not have forall?
13:16:33 <ski> neutrino_ : unless there's already an `a' tyvar in scope, that `forall' is implied
13:16:35 <neutrino_> i don't know, is it?
13:16:48 <Eduard_Munteanu> c_wraith: yeah, TBH, I haven't used GADTs much, just Agda's indexed families.
13:16:54 <ski> krey_ : `a' must be bound *somewhere*
13:16:54 <neutrino_> ski: how can you introduce it?
13:17:09 <ski> neutrino_ : sorry ?
13:17:26 <DanBurton> plus :: let a = Int in a -> a -> a ;)
13:17:27 <monochrom> you must have "forall" somewhere. implicitly at the front, or explicitly at where you want
13:17:41 <neutrino_> nm, too tired :)
13:17:43 <ski> DanBurton : except unfortunately that syntax isn't supported :)
13:17:52 <DanBurton> awwww needs moar extensions
13:18:17 <monochrom> perhaps you like: (a ~ Int) => a -> a -> a
13:18:49 <DanBurton> true point. although ~ constraints for some reason I find to be creepy
13:18:54 <monochrom> customers who bought (a~Int) also bought: type families, constraint kinds
13:18:58 <Eduard_Munteanu> This is more obvious in a DT language... that type reads like (a : *) -> Wat a -> a ~ (a : *, Wat a) -> a. So you don't just get to pick the type, you also provide a proof 'Wat a' is inhabited.
13:19:10 <ski> neutrino_ : anyway, to be able to return `1 :: Int', you must *somehow* discover that the `a' in the type signature is actualyl equal to `Int'
13:19:57 <ski> neutrino_ : and in case we have `f :: forall a. Wat a -> a', the only possible way to do this is to pattern-match on the input argument
13:20:04 <monochrom> actually, I like to explain this way. if the type sig is "WatInt a -> a", the user picks a, the author doesn't
13:20:28 <Eduard_Munteanu> If you picked any other 'a', you'd have a hard time providing a 'Wat a'.
13:20:29 <monochrom> the author has given up rights to say "a is really Int"
13:20:42 <ski> neutrino_ : in case `a' was already in scope, we might know some other value with type mentioning `a', and frobbing that may then uncover `a = Int' as well
13:21:31 <ski> krey_,neutrino_ : and what monochrom said
13:21:51 <monochrom> this is also why I reject the common story "a can be any type". "any" is beside the point. clearly, "caller can pick any type" and "callee can pick any type" both sound like "any" but can't be more contradictory
13:22:28 <nand`> @tell jfischoff I was able to get your TAssociativeArray to work with my types by making them slightly more polymorphic; in particular the right hand side of each tuple can be made polymorphic; since in my use case I'm not using kind * but kind Int I need it that way for :==: to work
13:22:28 <lambdabot> Consider it noted.
13:22:29 <krey_> monochrom: i'm slightly confused, who's the author and user?
13:22:36 <ski> (yes, "any" in english is complicated :)
13:22:37 <monochrom> http://www.vex.net/~trebla/weblog/any-all-some.html
13:22:55 <monochrom> author is callee. user is caller.
13:22:58 <ski> krey_ : the author is the one who writes `f'. the user is the one who calls `f'
13:24:15 <nand`> @tell jfischoff Now I just have to figure out how to do calculations on these, but that Reorder should prove invaluable
13:24:16 <lambdabot> Consider it noted.
13:24:27 <neutrino_> ski: ah
13:24:52 <krey_> thanks for helping guys
13:25:14 * krey_ retires to make a killer ham sandwich
13:25:38 <johnw> hmm.. is that a ham sandwich that kills people?
13:25:47 <johnw> or is it made from a pig that killed people?
13:26:03 <johnw> or is it a ham sandwich preferred by killers?
13:26:09 <ski> "if `n' is any even integer, then `n^2' is even" ~ `(exists n : |Z. even n) -> even (n^2)'
13:27:42 <Eduard_Munteanu> Hmm, does Haskell distinguish indices from parameters in GADTs?
13:27:43 <neutrino_> hey, is there a function which takes a value and list, and removes the first instance of that value?
13:27:51 <clahey> ~ forall n | Z (even n -> even (n^2))
13:28:15 <Eduard_Munteanu> @hoogle delete
13:28:15 <lambdabot> Data.HashTable delete :: HashTable key val -> key -> IO ()
13:28:16 <lambdabot> Data.List delete :: Eq a => a -> [a] -> [a]
13:28:16 <lambdabot> Data.List deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:28:24 <Eduard_Munteanu> @hoogle+
13:28:24 <lambdabot> Data.List deleteFirstsBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
13:28:24 <lambdabot> Network.HTTP.Base DELETE :: RequestMethod
13:28:24 <lambdabot> Data.IntSet delete :: Int -> IntSet -> IntSet
13:28:43 <int80_h> any ideas for my closed handle problem?
13:29:28 <ski> Eduard_Munteanu : iirc, no. (but not for type families)
13:29:29 <Eduard_Munteanu> Actually 'delete' does.
13:29:46 <neutrino_> > delete 'a' "this is abracadabra"
13:29:48 <lambdabot>   "this is bracadabra"
13:29:52 <neutrino_> great, thanks
13:30:01 <monochrom> ski: you have a free variable n, it may be not what you want
13:30:34 <ski> monochrom : i assume some anaphora-inspired generalized scoping rules :)
13:30:47 <monochrom> ok!
13:31:19 <mroman> Can the high-level llvm package generate IR code?
13:31:26 <monochrom> perhaps the reason why some people write quantifiers sloppily is that they use dynamic scope
13:32:07 <mroman> (that is, llvms intermediate representation)
13:32:12 <ski> hm, possibly
13:32:20 <ski> (i do know they use dynamic scope often)
13:32:48 <Ralith> mroman: yes.
13:32:59 <Ralith> mroman: you'll find it awkward and limiting if you're writing anything resembling a compiler, however.
13:34:08 <mroman> So it's not feasible for exactly that?
13:35:41 <ski> ("Delimited Continuations in Natural Language - Quantification and Polarity Sensitivity" by Chung-chieh Shan in 2004 at <http://arxiv.org/abs/cs.CL/0404006> has some discussion about "any", though i don't see a mention of anaphora here)
13:36:31 <Ralith> mroman: I've written a more or less direct wrapping of the C API which lives at https://github.com/Ralith/llvm in the 'base' subdirectory
13:36:59 <Ralith> mroman: there's also potential for a higher-level but non-limiting API, but I haven't found time to put one together yet.
13:37:02 <Eduard_Munteanu> How do you write an equality GADT? data Equals a b where refl :: Equals a a  ?
13:37:33 <ski> Eduard_Munteanu : i would probably write `data Equals a :: * -> * where ...' or `data Equals :: * -> * -> * where ...'
13:37:39 <ski> also, s/refl/Refl/
13:37:46 <Eduard_Munteanu> Erm, right.
13:37:57 <ski> (but yes, with that fix, what you said would also work)
13:38:18 <Eduard_Munteanu> I see.
13:38:25 <mroman> Ralith: Thx.
13:38:43 <ski> generally, i write like `Foo a :: * -> *', if i intend to use `a' as a parameter in the GADT
13:38:52 <Ralith> mroman: it should eventually find its way into hackage, once bos gets around to reviewing/merging it.
13:38:53 <ski> (GHC doesn't care either way, though)
13:39:25 <Ralith> mroman: note that you'll also need the version of llvm-base from that repository; the hackage one is not sufficient.
13:40:18 <mroman> but I guess I'm not going the mile to llvm and just output code to feed to nasm. It's not going to be a huge project. And it certainly won't be a useful project anyway.
13:41:06 <atriq> Why has the behaviour of TypeOperators changed?
13:41:36 <ocharles> What is Refl/GADT equality used for?
13:41:43 <ocharles> I get how it works, i just haven't felt a need for it yet
13:41:45 <Eduard_Munteanu> It kinda makes me wonder why '~' exists, supposedly you could implement it with Equals and implicits, no? Or GHC doesn't infer implicits?
13:43:51 <Eduard_Munteanu> ocharles: not sure, I was merely translating that from Agda.
13:44:16 <Heffalump> ocharles: gives you a concrete witness to the equality of two types, that you can pass around
13:45:24 <Eduard_Munteanu> Also, hm... maybe '~' is definitional rather than propositional? I'm not sure if the difference makes much sense in Haskell though.
13:45:41 <ocharles> Heffalump: sure, that bit again i get. but i can't go from the more abstract "how" to the more practical "why"
13:46:02 <ski> ocharles : one use could be `class Eq1 f where eq1 :: f i -> f j -> Maybe (Equal i j)' with laws `forall (i :: *) (j :: *) (fi :: f i) (fj :: f j). eq1 fi fj = Just Refl => fi = fj' and `forall (i :: *) (j :: *) (fi :: f i) (fj :: f j). eq1 fi fj = Nothing => not (i = j /\ fi = fj)'
13:46:02 <ocharles> but that may be because my dependent typing-fu doesn't go further than indexed vectors :)
13:46:25 <Heffalump> ocharles: there's some examples in the darcs source, if that helps (look for IsEq)
13:47:21 <ski> ocharles : then if we have a GADT `data Foo :: * -> * where FA :: Foo A; FB :: Foo B' we can `instance Eq1 Foo' and then use `lookup1 :: Eq1 f => Map1 f g -> f i -> Maybe (g i)'
13:48:18 <ski> ocharles : iow, we can have an association map where the type of the values depend on the type of the corresponding keys
13:48:38 <ocharles> hmm, it's still fuzzy but less fuzzy :)
13:49:46 <ski> (and to implement `lookup1', you'd need to use `eq1', and thus `Equal')
13:50:45 <Eduard_Munteanu> I wonder how close can you get to Agda's Σ using GADTs and similar trickery.
13:50:59 <Eduard_Munteanu> (well, without existentials if possible)
13:51:40 <hpc> the trick would be lifting everything to the right level to make it possible
13:51:41 <ski> `data Exists f where Wrap :: f a -> Exists f' ?
13:51:51 <nand`> @tell jfischoff Great news, I managed to implement AssocArray merging; eg. [M → 1, S → 2] + [S → 3, M → 1]  :==:  [M → 2, S → 5]
13:51:51 <lambdabot> Consider it noted.
13:52:03 <acowley> ghc-mod problems: In stand-alone files, it's not finding my user package db. In cabalized projects, it's not giving me anything at all, and I'm not sure where to look for log message or the like. Any suggestions?
13:52:16 <hpc> ski: not the right type of Wrap
13:52:32 <ski> which type did you want ?
13:52:34 <acowley> hand`: that's pretty awesome!
13:52:38 <acowley> nand` that is
13:52:54 <Eduard_Munteanu> "Talk to the nand`"! :P
13:53:16 <nand`> acowley: now I just have to pretty it up and perhaps release my first library
13:53:33 <hpc> ski: you're wrapping (forall a. f a)
13:53:37 <acowley> nand` can you put some example code on haste?
13:53:41 <nand`> and what a great way to start, with 14 necessary language extensions
13:53:44 <acowley> hpaste
13:53:53 <hpc> into the type (Exists f)
13:53:53 <acowley> My goodness, I need to turn autocorrect off :/
13:54:17 <ski> hpc : no. what i said is short for writing `Wrap :: forall a. f a -> Exists f' in there, which means `Wrap :: forall a. (f a -> Exists f)'
13:54:31 <hpc> ah
13:54:53 <hpaste> nand` pasted “TAssocArray-based units” at http://hpaste.org/77421
13:54:58 <hpc> i still don't think it's Σ, but i can't really explain why :P
13:55:09 <nand`> acowley: it's very ugly right now, but sure; see the tests at the bottom ^  See also https://gist.github.com/4034291 but note that that file requires a few changes for mine to work
13:55:17 <Eduard_Munteanu> Well, the * is missing.
13:55:33 <Eduard_Munteanu> It's hidden.
13:56:42 <ski> hpc : well, `exists' is blind, but `Σ' isn't
13:57:33 <ski> however, perhaps(?) this is just a consequence of the fact that the former quantifies over a type, while the latter over any value
13:59:04 <Eduard_Munteanu> ski: any thoughts on how Equals differs from '~'?
14:00:24 <ski> Eduard_Munteanu : i suspect `~' is more tied into how (potentially partial) type/data families evaluates
14:00:44 <ski> but i don't think i understand `~' well
14:01:17 <ski> one obvious difference is that `Equal :: * -> * -> *' while (basically) `(~) :: * -> * -> Constraint'
14:01:35 <stepkut> what is a good way to deal with 'getDataDir' during development? Loading code into GHCi is annoying due to it coming from an autogenerated file
14:02:07 <hpc> you can convert between Equal and (~) though, yes?
14:02:09 <Eduard_Munteanu> Hm.
14:02:26 <Saizan> stepkut: something like :set -i dist/build/autogen
14:02:34 <Eduard_Munteanu> hpc: I wonder about that too
14:02:42 <ski> hpc : at least the forward direction should be possible, i think
14:02:53 <Saizan> stepkut: though i guess you need to install at least once for getDataDir to be accurate
14:03:13 <ski> (possibly the backward direction as well)
14:03:28 <hpc> and you can go from (~) to Equal by encoding the dictionary in a type
14:03:56 <Saizan> data Equal a b where Refl a a ?
14:04:01 <hpc> er, wrapping
14:04:28 <stepkut> Saizan: right.. in fact, I would prefer it if getDataDir refered to the local files when I am using ghci during development
14:04:33 <Saizan> Refl :: Equal a a, i mean
14:04:35 <ski>   data Equiv :: * -> * -> * where E :: a ~ b => Equiv a b
14:04:49 <ski> so i suppose we're talking about converting between `Equal' and `Equiv' here
14:04:57 <stepkut> I have done #ifdef CABAL tricks in the past to deal with this
14:04:57 <atriq> I think it's time for me to learn the constraints package
14:05:02 <Saizan> ski: Equiv is the desugaring of Equal
14:05:04 <stepkut> but CPP in my Haskell is gross!
14:05:21 <Eduard_Munteanu> Huh? Interesting.
14:05:32 <ski> Saizan : ok, then both should be straight-forward
14:06:12 <Saizan> stepkut: i think someone is working on a cabal ghci, maybe they also have some workaround
14:06:22 <Saizan> stepkut: in the meantime i mean
14:06:25 <ski> (.. i have the nagging feeling that the partiality of type/data families could be involved in how `~' is treated. perhaps this is unfounded, though)
14:07:18 <ski> (perhaps the openness saves us)
14:07:40 <dcoutts_> Saizan, stepcut: talking about finding data files inplace in the build tree?
14:07:44 <clahey> Is there a good tutorial for GADT?
14:07:46 <Eduard_Munteanu> So basically GADTs desugar from data F a b c ... where Con : X -> Y -> ... Foo X Y ...  to data F a b c ... where Con : (a ~ X, b ~ y, ...) => X -> Y -> ... -> Foo a b c ... ? (or something along those lines)
14:08:09 <dcoutts_> Saizan, stepcut: foo_datadir=. ./dist/build/foo/foo
14:08:42 <Saizan> Eduard_Munteanu: yeah
14:09:12 <Saizan> conor would call them catholic, iirc
14:09:38 <stepkut> dcoutts_: yeah, how to best deal with installed vs in-place datadir and how to make loading into ghci easy
14:09:55 <Eduard_Munteanu> Saizan: so actually, we don't have indexed families, just parametric GADTs?
14:09:58 <stepkut> dcoutts_: seems like no matter what, runhaskell Setup configure, is going to need to be run first, right?
14:10:10 <Eduard_Munteanu> I'm unsure how Agda treats them, though.
14:10:23 <dcoutts_> stepcut: yes, and build, to generate the Paths_foo.hs module
14:10:30 <stepkut> but I could use a .ghci file in the directory to add -dist/build/autogen? so that import Paths_foo ?
14:11:10 <ski> Eduard_Munteanu : yes, the type arguments are outputs, not inputs (in terms of logic programming mode terminology)
14:11:51 <stepkut> dcoutts_: :-/
14:12:00 <Saizan> Eduard_Munteanu: there are a few papers on how they are essentially the same thing
14:12:34 <dcoutts_> stepcut: sure -idist/build/autogen, and sometimes also -optP-include -optPdist/build/autogen/cabal_macros.h
14:13:24 <stepkut> would be nice if I could just provide a static, Paths_foo in my local directory so that ghci didn't require anything funky, and but when building with cabal it would ignore that and use the autogenerated version
14:14:13 <dcoutts_> stepkut: as Saizan said, the solution is cabal ghci, but what I said above is the workaround, a few extra flags to ghci
14:14:51 <atriq> So... a "a => Dict b" is saying, "If I can prove something satisfies a, I know it satisfies b"?
14:15:23 <stepkut> dcoutts_: plus running 'cabal build' first, right ?
14:15:29 <Saizan> atriq: there's no something
14:15:43 <dcoutts_> stepkut: for the workaround yes, to generate the stuff in the autobuild dir
14:15:55 <Saizan> atriq: it's just saying if a is satisfied then i can prove b is
14:16:05 <atriq> ...okay
14:16:16 <KitB_> Has anyone experienced a situation in which ghci on ubuntu 12.04 is unable to find local files to import?
14:16:21 <atriq> How is that different from what I said?
14:17:03 <Saizan> a and b are not :: * -> Constraint, they are :: Constraint
14:17:12 <atriq> Okay
14:17:22 <atriq> So, how do I use this?
14:17:57 <Saizan> you pattern match on it
14:18:27 <ocharles> clahey: I posted a video to /r/haskell introducing GADTs
14:18:31 <ocharles> (if you read that)
14:19:19 <stepkut> ok, next question, I need to use fay to build some of the data files
14:29:44 * hackagebot haskell-bcrypt 0.3.1 - A bcrypt implementation for haskell  http://hackage.haskell.org/package/haskell-bcrypt-0.3.1 (BrettCarter)
14:40:09 <watermind> when using stand alone deriving clauses  is there a way to derive instances of a class to multiple data types?
14:41:06 <watermind> with one deriving instruction that is
14:43:25 <fengshaun_> hi all, is it possible to write a single bit to a file?
14:43:37 <fengshaun_> writeFile only has a ByteString
14:43:47 <mauke> files contain bytes, not bits
14:43:59 <Peaker> interesting to see Carmack tweeting about conal's blog posts
14:44:05 <Peaker> "insightful or insane"?
14:44:07 <fengshaun_> mauke: :(
14:44:08 <geekosaur> ^^ in particular I'm not aware of an OS with bit-level filesystem writes
14:44:08 <fengshaun_> ok
14:44:39 <geekosaur> (there probably is one somewhere, but I am pretty certain there's no haskell compiler for such)
14:45:24 <fengshaun_> lol thanks
14:46:37 <Ralith> fengshaun_: you can't even address individual bits in memory; computers (usually) just physically don't work that way.
14:48:38 <sipa> at the disk level nothing smaller than a sector (512 or 4096 bytes) can be addresses individually even - writes for smaller amounts of data require a read/modify/write cycle
14:50:46 <estulticia> Peaker: url?
14:51:41 <mcstar> hm, i just realized something
14:51:58 <Peaker> estulticia, https://twitter.com/ID_AA_Carmack/status/266209432780820480
14:52:22 <mcstar> is there a reason, (->) cant be an infix function constructor?
14:52:32 <mcstar> i.e. it is syntax
14:53:04 <Peaker> it is a type constructor, you can use it like (->)
14:53:11 <mcstar> yeah i know
14:53:24 <mcstar> but, it is not a 'data' constructor
14:53:33 <mcstar> \ ... -> is special syntax
14:54:26 <estulticia> Peaker: thanks
14:55:40 <mcstar> like, data F a b = F a b, so F would be the function type and data constructor
14:55:50 <int80_h> would anyone care to discuss my closed handle problem? http://hpaste.org/77416
14:55:56 <mcstar> and you could make it infix, ofc
14:56:12 <mcstar> data (a -> b) = a -> b
14:56:41 <Eduard_Munteanu> mcstar: how would that be inhabited?
14:56:51 <mcstar> so, theoretically, could a useful lambda be implemented this way?
14:57:01 <mcstar> or would it be too restrictive in some way?
14:57:14 <shachaf> It's not meaningful enough to be restrictive.
14:57:27 <Cale> mcstar: The thing is, the bit on the left of the -> isn't an expression
14:57:30 <Peaker> mcstar, I'm not sure what you're missing.. you can implement a data type that describes some sort of function (DSL, computation, or what not)
14:57:33 <Cale> It's a pattern which binds variables
14:57:35 <mcstar> since there is no connection between 'a' and 'b'
14:57:45 <Eduard_Munteanu> Your a -> b ~ (a x b)
14:58:10 <mcstar> Peaker: im not missing anything
14:58:36 <mcstar> it just occured to me, if its possible to represent a lambda function without extra syntax
14:58:41 <mcstar> or language fature..
14:59:03 <ion> mcstar: You already have that type, it’s just called (,) instead of (->). Now go ahead and implement lambda using that.
14:59:48 <Eduard_Munteanu> mcstar: you can't replace it by an inductive type.
15:00:41 <Cale> int80_h: hmm... I wonder if you're allowed to split up the ResourceT actions like that
15:00:55 <Cale> int80_h: What happens if you combine those two runResourceT's into one?
15:01:41 <mcstar> k, thanks guys
15:01:45 <Cale> (caveat: I don't know much about conduit at all, and haven't looked at the documentation)
15:02:59 <Cale> However, ResourceT is a monad transformer, and the first parameter to runResourceT is a monad action in a monad transformed by it
15:03:20 <Cale> So you should be able to write something like
15:04:17 <Peaker> runResourceT indeed closes all resources at the end
15:04:21 <Cale> runResourceT $ do Response _ _ _ body' <- http req'' manager; pBody <- body' $$+- sinkParser json
15:04:32 <Peaker> (anything opened during the ResourceT actions.. which explains the issue)
15:04:57 <Peaker> it could be nice to use Oleg-style/ST-like phantom types for regions rather than ResourceT to statically prevent these kinds of bugs
15:05:24 <stepkut> regions!
15:05:29 <Cale> Given how popular ST is and how complicated the types already are, I'm not sure that would be the best move for them though.
15:08:51 <clahey> ocharles: Can't really watch videos right now, but I'm getting closer to getting it.
15:17:48 <kkopiec> good evening
15:18:19 <kkopiec> looking for some advice
15:18:29 <Eduard_Munteanu> kkopiec: hi there
15:19:21 <kkopiec> got assignment to write a parser which is parsing biger and bigger chunks in applicative way
15:19:58 <kkopiec> and got a bunch of functions producing different kinds of parsers
15:21:39 <kkopiec> but then need to parse something like this: ([a],b) of type Line
15:23:22 <kkopiec> I can parse [a] ',' and b but the result of the function should be Parser Line and really feel lost how to lift type Line to the instance of Parser Line since parser for b is of type Parser Expression
15:24:04 <kkopiec> and so that in applicative structure all the thing is lifted to be parser Expression
15:25:03 <Peaker> what is Line?
15:25:15 <kkopiec> can I say (:) <$> bunch_of_parsers <* []
15:25:16 <kkopiec> ?
15:25:41 <kkopiec> type Line ([Patern],Expression)
15:26:04 <kkopiec> Parser got an instance of applicative defined
15:26:18 <Peaker> kkopiec, sequenceA is in Applicative
15:26:46 <Peaker> @type foldr (liftA2 (:)) (pure [])
15:26:48 <lambdabot> Applicative f => [f a] -> f [a]
15:27:40 <kkopiec> ok so (:) <$> stuff <*> that <*> matters <* [] would do ?
15:28:03 <Peaker> Why do you use <* there?
15:28:16 <kkopiec> because [] doesn't matter
15:28:16 <Peaker> <* takes only the "effect" from the right-side, ignoring the value
15:28:36 <Peaker> @type (<* [])
15:28:37 <lambdabot> [a] -> [a]
15:28:57 <Peaker> When you give [] as the right hand side of <* or <*>  then your applicative is [], not Parser
15:29:03 <Peaker> @type (<*)
15:29:04 <lambdabot> Applicative f => f a -> f b -> f a
15:29:13 <kkopiec> and I can bind stuff that matters to pure []
15:29:24 <Peaker> note the "f b" here is instantiated to ([] c)
15:29:51 <Peaker> kkopiec, first, must clear up that if you want to use the Parser applicative,  then <* [] is wrong...
15:30:18 <kkopiec> just trying to find something pure so i can lift all the thing by application
15:30:55 <kkopiec> need to get Parser Line where Line is ordinary type
15:32:05 <kkopiec> Parser is Parser x { parse :: /s-> Either (String, String) (x, String) }
15:32:25 <kkopiec> ow it is newtype Parser x
15:32:44 <Peaker> kkopiec, let's ignore the inside representation of Parser
15:33:02 <kkopiec> ok
15:34:05 <Peaker> kkopiec, Applicative lets you sequence the effects of pre-determined "actions" (in this case you sequence together parsers) while allowing you to combine/compute/ignore the results of any of these effects freely. The only thing you cannot do is choose which parser to sequence based on a previous result
15:34:39 <Peaker> kkopiec, so you wanted to combine parsers to make a list, right? Can you give the type of a few of these parsers, and what the type of the result list that you want?
15:35:14 <kkopiec> yes thats fine i am dealing with it I just wonder how to lift all the thing to be namelu Parser Line
15:35:23 <startling> what stops you from doing a <*> b where a = pure (\x -> if x == 1 then y else z)?
15:36:00 <kkopiec> Line is ([A], B)
15:36:01 <Peaker> startling, you will get f (f a), and then you can't join
15:36:08 <kkopiec> type Line
15:36:10 <clahey> So, I just read that GADT subsume existential types.  Are they generally preferred then?
15:36:16 <startling> Peaker: unless it's a Monad. ah.
15:36:25 <Peaker> startling, it is OK to have a result which is itself an effect, but there's no way to sequence stuff from the "outer layer" with anything from the "inner layer"
15:36:38 <Peaker> startling, yeah, that's the extra power of monads, removing the "phase distinction" of Applicative
15:36:56 <startling> Peaker: makes sense, thanks a bunch. I never understood that.
15:37:15 <kkopiec> startling it is not a monad ( at least at the time of this conversation) since it is sort of live assignment it may change
15:37:32 <startling> kkopiec: sure, understood.
15:37:50 <startling> so this is the CFG == Applicative distinction
15:37:51 <Peaker> startling, awesome! it's my favorite aha in Haskell.. I see the Applicatives/Monads distinction everywhere since :)
15:41:00 <clahey> I get the distinction, but I don't see a lot of Applicatives that aren't also Monads.
15:41:06 <clahey> Or at least I don't remember them.
15:42:06 <startling> clahey, a parser for only CFGS. :)
15:43:07 <clahey> startling: Ah, your parser algorithm only supports CFGs, so you only define the type as an applicative so that you can always combine things and still use your algorithm?
15:43:09 <Peaker> clahey, I had a case just recently -- a composition of the Unit Applicative and the Writer Applicative yields an Applicative
15:43:14 <Peaker> clahey, but it doesn't yield a Monad
15:44:02 <startling> clahey: I think so.
15:44:05 <clahey> Peaker: Can't join A B A B x?
15:44:16 <clahey> Even though you could join A A x or B B x?
15:44:35 * startling wonders whether there's a similar difference between Regular Grammars and CFGs. Can you write regular expressions using only Functor?
15:45:26 <Peaker> clahey, I have:  data Unit a = Unit   which is trivially a monad
15:45:35 <Peaker> clahey, and there's Writer/WriterT which is a monad/transformer
15:45:46 <startling> Peaker, isn't that Const?
15:45:56 <clahey> Peaker: So you did WriterT Unit as a type.
15:45:57 <Peaker> startling, it's Const (), yeah
15:46:04 <startling> Peaker: oh, right.
15:46:05 <clahey> startling: Const a b = a
15:46:09 <Peaker> WriterT w Unit  is a monad, but not the right one
15:46:14 <startling> clahey: yeah.
15:46:22 <Peaker> it's like a WriterT w Maybe   where you initially have a Nothing in there
15:46:43 <Peaker> however, Writer w (Const () a)   is the correct Applicative
15:46:47 <Peaker> you collect all the "tells"
15:47:13 <clahey> Could you have UnitT?
15:47:45 <shachaf> Peaker: Are you writing poker software?
15:47:54 <Peaker> shachaf, heh why?
15:48:00 <clahey> Peaker: I think I'm starting to see.  You have a Writer which contains the other associative instead of a WriterT.
15:48:00 <shachaf> 15:46 <Peaker> you collect all the "tells"
15:48:04 <clahey> Peaker: Because of "tells"
15:48:07 <Peaker> heh
15:48:13 <shachaf> clahey: What would UnitT be?
15:48:45 <shachaf> (Other than a terrible desktop environment.)
15:49:50 <clahey> shachaf: I don't know.  I didn't think it through in any detail.  I don't have a strong idea of how MonadTransformers work right now.
15:50:15 <Peaker> clahey, One nice thing about Applicatives, is that if you need the power of Applicative and not Monad, you don't need transformers at all!
15:50:16 <shachaf> "sporadically"
15:50:26 <johnw> is there a logBase that works with arbitrarily large Integers and returns a Rational?
15:50:39 <shachaf> johnw: A Rational? How does that work?
15:50:47 <johnw> x/y
15:51:03 <shachaf> ?
15:51:06 <johnw> can log not render results as fractions?
15:51:16 <johnw> am I restricted to what can be represented in a Double?
15:51:24 <shachaf> Most logarithms are irrational.
15:51:36 <johnw> ok, are there infinite precision floating point numbers in Haskell?
15:51:39 <kylcarte> shachaf: UnitT would be a transformer that takes a monad and returns the same. So, UnitT State operates identically to State
15:51:43 <shachaf> That doesn't mean you have to use Double, of course.
15:51:48 <johnw> i'm just going to call ceiling on the result
15:51:55 <geekosaur> there are some libraries for them.
15:51:57 <shachaf> johnw: There's at least CReal, but I'm not sure it's actually what you want.
15:52:03 <shachaf> kylcarte: Are you sure you're not thinking of IdentityT?
15:52:17 <shachaf> johnw: If you just want integer logarithm, you should ask for that. :-)
15:52:22 <johnw> oh!
15:52:27 <johnw> ok, consider it asked!
15:52:27 <Peaker> clahey, Applicatives compose directly (liftA2 . liftA2) (pure . pure).   Monads don't compose (e.g: State is a Monad, and IO is a monad, but State . IO  is not
15:52:35 <shachaf> @google integer logarithm haskell
15:52:37 <lambdabot> http://www.haskell.org/ghc/docs/7.4.2/html/libraries/integer-gmp-0.4.0.0/GHC-Integer-Logarithms.html
15:52:38 <lambdabot> Title: GHC.Integer.Logarithms
15:52:47 <johnw> you are a wonder, thanks
15:53:15 <shachaf> That's a bit of a low-level API -- it exposes GMP directly and gives you and Int#
15:53:23 <johnw> how do I use # in an identifier name again?
15:53:24 <tac-nap> Peaker: does a Parser . Parser parse parsers?
15:53:24 <shachaf> I# :: Int# -> Int
15:53:28 <shachaf> {-# LANGUAGE MagicHash #-}
15:54:04 <shachaf> johnw: There are things that wrap this in a higher-level API.
15:54:15 <johnw> such as?
15:54:17 <shachaf> @google integerLogBase
15:54:18 <clahey> Peaker: That makes sense.
15:54:19 <lambdabot> http://hackage.haskell.org/packages/archive/arithmoi/0.1.0.2/doc/html/src/Math-NumberTheory-Logarithms.html
15:54:19 <lambdabot> Title: Math/NumberTheory/Logarithms.hs
15:54:20 <shachaf> That, for example.
15:54:43 <johnw> nice
15:54:43 <Peaker> clahey, so I guess pretty much every   m . n    is an example of an Applicative which is not a Monad :)
15:54:47 * shachaf has no more information about Haskell libraries than you do, at this point. :-)
15:55:19 <Peaker> clahey, but fortunately lots of monads have a different variant (the "transformer" one) which does compose with other monads.. (not all of them though)
15:55:54 <shachaf> Monad transformers are kind of ad-hoc.
15:56:03 <tac-nap> shachaf: how so?
15:59:37 <tac-nap> actually, hold that thought. I gotta run
16:01:25 <hpaste> Jetbeard pasted “Struggling with types in a generic uncurry.” at http://hpaste.org/77424
16:02:04 <Jetbeard> Can anybody help with this? I'm just playing around for fun and have run into a stumbling block
16:03:14 <hpc> you need a functional dependency
16:03:19 <hpc> or associated type
16:03:22 <hpc> something like
16:03:34 <hpc> class Uncurry a where
16:03:47 <hpc>   type f a
16:04:03 <hpc>   uncurry :: a -> f a
16:04:37 <hpc> probably not exactly that, but similar
16:05:36 <hpc> so take the case of (a, b) for instance
16:05:41 <hpc> you can have your instance
16:05:56 <fengshaun_> if I don't put parantheses around a lambda, where does it implicitely end?
16:06:10 <fengshaun_> end of the line, or end of file?
16:06:25 <hpc> and then another one instance Uncurryable (a -> b -> c -> d) (a,b) where f <@> (a,b) = f a b undefined
16:06:49 <hpc> so you need to tell it that given a particular tuple type, this is what function it wants
16:07:10 <neutrino_> yessss my first test suite in haskell passes
16:07:22 <hpc> you sadly can't do the other way, because you could be partially applying the tuple
16:07:24 <neutrino_> and it's not even simple logic
16:07:29 * neutrino_ is happy.
16:07:41 <hpc> er, partially applying the function
16:07:46 <kallisti> fengshaun_: end of expression
16:08:05 <hpaste> “mysterious stranger” annotated “Struggling with types in a generic uncurry.” with “Struggling with types in a generic uncurry. (annotation)” at http://hpaste.org/77424#a77425
16:08:12 <shachaf> Jetbeard: ☝
16:08:19 <Jetbeard> hpc, functional dependencies sound like the kind of thing I'm looking for
16:08:23 <shachaf> That's one way to do it.
16:08:24 <fengshaun_> kallisti: oh, so if I put a lambda in the middle of a Monad expression (chained with >>=), the end is the end of the whole chain?
16:08:29 <neutrino_> now i should (perhaps) check out doctests
16:08:36 <kallisti> fengshaun_: mhm
16:08:49 <kallisti> > let f = \x -> x + 2; y = 3 in f y
16:08:51 <lambdabot>   5
16:08:52 <neutrino_> are there any bad points to doctests?
16:08:58 <neutrino_> anything i should know about?
16:09:03 <Jetbeard> shachaf, brilliant and simple!
16:09:12 <hpc> Jetbeard: if this isn't for learning, i think lens also works
16:09:23 <Jetbeard> this is for learning
16:09:24 <hpc> but i don't know remotely enough about the package to say more than that
16:09:25 <shachaf> hpc: How does lens do it?
16:09:33 <fengshaun_> kallisti: but when put in a >>= chain, it would be ambigious, right?
16:09:37 <hpc> :t _2
16:09:39 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
16:09:47 <hpc> gets the second element of any tuple size
16:09:51 <shachaf> Right.
16:09:54 <shachaf> How does that let you uncurry?
16:10:11 <hpc> uh
16:10:15 <hpc> magic
16:10:16 <hpc> :P
16:10:26 <neutrino_> what does it mean to uncurry a function?
16:10:31 <neutrino_> i thought once it's curried that's it
16:10:34 <hpc> oh, i see
16:10:40 <shachaf> @google what does it mean to uncurry a function?
16:10:42 <lambdabot> http://stackoverflow.com/questions/4754417/type-signature-of-uncurry-function
16:10:42 <lambdabot> Title: haskell - type signature of uncurry function - Stack Overflow
16:10:44 <Jetbeard> :t uncurry
16:10:46 <lambdabot> (a -> b -> c) -> (a, b) -> c
16:10:50 <hpc> :t \f tuple -> f (tuple.^_2) (tuple.^_2)
16:10:52 <lambdabot>     Not in scope: `.^'
16:10:52 <lambdabot>     Perhaps you meant one of these:
16:10:52 <lambdabot>       `.' (line 101), `^' (imported from Prelude),
16:10:56 <neutrino_> oh
16:10:59 <hpc> :t \f tuple -> f (tuple^._2) (tuple.^_2)
16:11:00 <lambdabot>     Not in scope: `.^'
16:11:00 <lambdabot>     Perhaps you meant one of these:
16:11:01 <lambdabot>       `.' (line 101), `^' (imported from Prelude),
16:11:05 <hpc> :t \f tuple -> f (tuple^._2) (tuple^._2)
16:11:07 <lambdabot> (Field2 s t2 a b1, Field2 s t1 a b) => (a -> a -> t) -> s -> t
16:11:15 <hpc> :t \f tuple -> f (tuple^._1) (tuple^._2)
16:11:16 <lambdabot> (Field2 s t2 a1 b1, Field1 s t1 a b) => (a -> a1 -> t) -> s -> t
16:11:19 <hpc> aha!
16:11:28 <shachaf> That takes a function of two arguments and a tuple of "any size".
16:11:46 <shachaf> It ignores the 3-nth elements of the tuple.
16:12:03 * hpc takes note to get more sleep :P
16:13:38 <shachaf> Jetbeard: You could also use functional dependencies to do it, by the way.
16:14:32 <Jetbeard> yeah, I saw those and they looked right for the job, but your solution is nice
16:14:56 <Jetbeard> If it were possible to do it and not have to declare any types in the body of instances then that'd be the holy grail of sorts
16:15:14 <shachaf> Jetbeard: It would require even less change to your code.
16:15:25 <shachaf> class Uncurryable f t r | t r -> f r where (<@>) :: f -> t -> r -- that should be it.
16:16:01 <shachaf> Um, t r -> f
16:16:23 <shachaf> (Well, it'll work either way. But it's t r -> f)
16:18:37 <shachaf> (Also please note that, dmwit's protests notwithstanding, tabs are evil and you should feel bad for using them.)
16:20:03 <dgpratt> grr...this makes no sense; I'm getting a bunch of compile errors trying to cabal install cabal-dev
16:20:08 <Jetbeard> shachaf, unfortunately I was copy-pasting the code into a place where tabs are preserved but multiple spaces are smashed into one
16:20:09 <hpaste> dgpratt pasted “cabal-dev build errors” at http://hpaste.org/77426
16:20:34 <dgpratt> it's almost like the prelude is not in scope
16:21:16 <dgpratt> what would cause Not in scope: `$' ?
16:22:24 <Jetbeard> dgpratt, you may have just answered your question before you even asked it
16:22:41 <davesque_> is there a way to pattern match one value constructor -or- another?  like `myFunc (Add|Sub x y) = ...`?
16:23:35 <davesque_> anyone on that one?
16:23:46 <shachaf> davesque_: No.
16:23:47 <dgpratt> Jetbeard: perhaps, but that'd just get me to questioning why the Prelude was not in scope
16:24:24 <davesque_> okay
16:27:56 <sonOfRa> How is init supposed to function on a one-element list? Empty list, or that same list?
16:28:05 <c_wraith> empty
16:28:09 <sonOfRa> thanks
16:28:19 <c_wraith> the hard part is what to do with an empty list
16:28:23 <davesque_> `init []`
16:28:33 <c_wraith> > init []
16:28:35 <lambdabot>   *Exception: Prelude.init: empty list
16:28:36 <sonOfRa> it's a custom type, we're just mimicking the functions
16:28:39 <davesque_> ahh :)
16:28:44 <sonOfRa> throwing an error for empty list
16:28:55 <c_wraith> > init [1]
16:28:56 <sonOfRa> > tail[]
16:28:57 <lambdabot>   []
16:28:58 <lambdabot>   *Exception: Prelude.tail: empty list
16:29:04 <sonOfRa> > tail['a']
16:29:05 <lambdabot>   ""
16:29:11 <sonOfRa> alright, that bot is ahndy
16:29:14 <sonOfRa> *handy
16:29:32 <c_wraith> Well, but unless you're demonstrating something for someone else, it's better to test those sorts of things in ghci
16:29:50 <sonOfRa> noted.
16:30:16 <c_wraith> you can also private message lambdabot, if you like
16:30:42 <mauke> > deriv (2 * sin + 1) x
16:30:44 <lambdabot>   2 * (1 * cos x)
16:31:03 <ParahSailin> @ty deriv
16:31:04 <lambdabot> (Eq b, Eq a, Num b, Num a) => (Dif a -> Dif b) -> a -> b
16:31:05 <mauke> :smooth_criminal:
16:31:07 <Jetbeard> shachaf, hpc thanks for your help! i'm now reading more about fundeps and type families, this has been an exciting learning experience
16:34:24 <hpc> Jetbeard: :D
16:34:39 <hpc> somehow, i have a feeling i could write a whole package around this function:
16:34:40 <hpc> http://hpaste.org/77428
16:44:31 <dented42> can the llvm haskell binding/library be used to write a code generator?
16:45:50 <ion> yes
16:45:58 <hpc> i doubt this is what ghc does
16:58:14 <Ralith> dented42: the one in hackage isn't appropriate for that use; I've got a fork at https://github.com/Ralith/llvm which includes a more direct binding of the C API.
16:58:50 <Ralith> it should end up on hackage whenever bos gets around to merging it.
17:07:25 <dented42> Ralith: it will eventually replace the existing binding?
17:09:29 <Ralith> dented42: no; the existing binding has other uses, and they can coexist harmlessly.
17:16:31 <tikonen> Hi, is there any way to tell in ghci from what cabal package type was imported?
17:16:59 <c_wraith> not from ghci
17:17:24 <tikonen> my use case is that I see some type or package used in code, and want to check what cabal package I need to install to run it
17:17:25 <ivanm> well, you can tell which module it's from
17:17:45 <ivanm> and you might be able to call ghc-pkg using :! from ghci to determine which package the module is in
17:17:51 <tikonen>  :info tells only module afaik
17:18:01 <ivanm> yup
17:18:06 <c_wraith> but ghc-pkg find-module Data.Foo works
17:18:06 <ivanm> and you need it installed an in scope already
17:18:23 <ivanm> tikonen: the other alternative is to have :hoogle set up to call the hoogle website or something ...
17:18:26 <c_wraith> so you can do it from the command line..  It's just not part of ghci
17:19:05 <ivanm> and you can call command-line apps from ghci!
17:19:13 <ivanm> so you can do it within ghci, just not _with_ ghci ;-)
17:19:41 <tikonen> hmm, the ghc-pkg does the trick if package is already installed
17:19:43 <tikonen> ghc-pkg find-module Data.Convertible
17:19:56 <tikonen> prints: /Users/teemuikonen/.ghc/x86_64-darwin-7.4.2/package.conf.d convertible-1.0.11.1
17:20:15 <c_wraith> if it's not installed, you're out of luck with cabal or ghc
17:20:26 <c_wraith> you need to go with something like hoogle or hayoo in that case
17:20:30 <geekosaur> but there's hoogle or hayoo
17:20:33 <geekosaur> heh
17:20:36 * geekosaur slow
17:20:46 <c_wraith> I've had caffeine today! :)
17:21:02 <tikonen> ok, hoogle sounds good
17:21:15 <c_wraith> hoogle's index is limited to "common" packages by default
17:21:20 <c_wraith> so it might fail to find some things
17:22:07 <tikonen> c_wraith, thanks
17:22:14 <neutrino_> i've just ported a python app to haskell
17:22:34 <neutrino_> well, it's still missing some stuff, but it's 90% done.
17:22:45 <neutrino_> however it's already substantially bigger than the original
17:22:51 <Ralith> dented42: it's quite feasible to grab my fork and use it locally, anyway, and I'm happy to provide advice/merge patches.
17:22:53 <c_wraith> bigger?
17:22:57 <neutrino_> yeah
17:23:03 <Peaker> neutrino_, what needed more code?
17:23:17 <neutrino_> well what i just ported is the cli interface
17:23:27 <neutrino_> so arguments and subcommands
17:23:37 <neutrino_> i guess the subcommands needed some extra but it's not so much
17:25:28 <neutrino_> the amount of characters is actually within 2%
17:25:34 <neutrino_> i don't know why it feels like so much more
17:25:47 <neutrino_> once i add the missing parts it'll certainly be 10-15% over
17:26:24 <c_wraith> are you using one of the argument parsing libraries that handles subcommands?
17:26:31 <neutrino_> oops, wrong, i counted the python one incorrectly
17:26:43 <neutrino_> the haskell version is currently 50% above
17:26:57 <neutrino_> c_wraith: no, but then i need some custom functionality as well
17:27:13 <neutrino_> plus, i looked at several and many of them seemed fairly scary
17:27:16 <Peaker> neutrino_, can you paste some sample python/larger-haskell?
17:31:06 <neutrino_> Peaker: let me see
17:45:57 <jimch> Is it possible to reassign a global variable?
17:46:15 <ivanm> short answer: no
17:46:26 <typoclass> jimch: normally no. stuff in haskell is immutable
17:47:10 <typoclass> jimch: what is often done is to recursively call your function (say "f x = ...") with a new x
17:47:37 <jimch> So how would you have several worker threads adding stuff to a map? Map is not mutable either
17:47:58 <Ralith> you would have each build its own map, and then merge those maps at the end
17:48:10 <neutrino_> nice
17:48:16 <neutrino_> i upload code for peaker and he's gone
17:48:19 <tdammers> or maybe MVars
17:48:29 <Ralith> shared-memory concurrency is generally a bad idea anyway
17:48:49 <ivanm> or TVars if you're using STM
17:48:55 <tdammers> take map from mvar, do your thing, put updated map back in mvar
17:49:01 <Ralith> I don't know your problem, but this way you avoid contention
17:49:17 <ivanm> Ralith: isn't "message passing" in Haskell done using MVars, etc. anyway though?
17:49:21 * neutrino_ hopes peaker shows up today
17:49:32 <typoclass> jimch: the usual way is that the functions for "modifying" stuff (adding one thing to a list, putting something into a Map ...) give back a copy of the same thing, but with the one change made. the previous version continues to exist
17:49:36 <Ralith> ivanm: yes, MVars also aren't shared-memory concurrency
17:49:43 <Ralith> ivanm: but the solution I described doesn't need message passing either.
17:49:57 <ivanm> Ralith: oh, you said that after tdammers suggested MVars, so I thought that's what you were referring to
17:50:03 * Ralith nod
17:50:08 <jimch> You dont have to deal with locks etc that way which is good, but depending on a map size merging several maps is too efficient
17:50:19 <jimch> Is not too efficient
17:50:24 <ivanm> about to say... ;-)
17:50:27 <Ralith> jimch: don't worry about it until you profile.
17:50:31 <tdammers> depends, really
17:51:06 <Ralith> your code will be much simpler and more likely to be correct if the threads are wholly independent, so it's worth trying that way first.
17:51:20 <typoclass> jimch: could you tell us a little more about what you're planning? so far it's hard to tell if we should recommend MVars or something else :-)
17:54:03 <jimch> I am not actually doing anything I was just curious. I started learning haskell yesterday and still trying to get my head haskells immutability
17:54:15 <jimch> +around
17:54:55 <jimch> So merging the threads would be the choice. What if that is too slow?
17:55:09 <jimch> Merging the maps even
17:55:43 <tdammers> depends on the problem
17:55:44 <Ralith> you will have to assemble a map by repeated inserts one way or another; the only difference is if all the worker threads block on eachother to do so, or if they run uninterrupted and leave that work for the end
17:55:49 <hpaste> latro`a pasted “ambiguous type variable” at http://hpaste.org/77433
17:56:01 <latro`a> any ideas how to make that not throw type variable errors?
17:56:05 <Ralith> if that was unacceptable, you would need to use something other than a map.
17:56:11 <tdammers> or maybe the problem doesn't require a map after all
17:56:12 <latro`a> (also pardon the style; this was somewhat quick and dirty)
17:56:14 <tdammers> heh
17:56:18 <typoclass> jimch: maybe throw more threads at the merging operation
17:56:34 <jimch> typoclass: haha
17:56:59 <dibblego> latro`a: what type variable errors?
17:57:04 <tdammers> or maybe you can partition the input data in a way that allows for a more efficient merging afterwards
17:57:11 <latro`a> "ambigous type variable in the constraints" for Ord, Read, Show
17:57:24 <latro`a> which is weird, because I'd think the type would be fixed by readFile's type
17:57:40 <latro`a> oh, I think I know what happened
17:57:46 <latro`a> I need a signature for the read
17:57:58 <dibblego> DMR
17:58:10 <dibblego> although I do not see it for some reason
17:58:39 <typoclass> jimch: if it helps, you'll have this merging problem in any language, i don't see why it'd be haskell-specific
17:59:24 <jimch> typoclass: Well you could use locks and a single mutable map in other languages
17:59:31 <dented42> jimch: if you think of the merge operation by itself then yes, it seems pretty slow
17:59:46 <tdammers> dented42: that's pretty much what the MVar approach does
17:59:48 <Ralith> typoclass: it probably came up because in any other language, jimch could have used a shared map so easily that the performance consequences wouldn't have been considered >_>
18:00:28 <dented42> jimch: but if you look at the amortized time, then merging generally turns out to be not much more expensive.
18:00:31 <jimch> tdammers: yes? How?
18:00:43 <typoclass> jimch: yup that's right, but this way you just have the merging step mixed into the regular work of the threads. so if merging is an expensive operation, you might have all the threads waiting for that one lock
18:00:43 <tdammers> the MVar itself is your lock
18:00:56 <tdammers> and the map inside it is your shared mutable map
18:01:17 <tdammers> it's not semantically mutable, but under the hood, lazy evaluation gets it pretty damn close
18:02:16 <tdammers> that is, when you create a new modified map based on the old one, much of the unchanged parts can be shared
18:02:43 <tdammers> plus much of it might not even be evaluated yet at that point
18:03:06 <jimch> okay I see
18:03:18 <tdammers> if you consider a flat list instead of a map, it becomes more obvious
18:03:47 <tdammers> say (:) is your add-to-list operation
18:03:59 <tdammers> and your old list was xs
18:04:05 <tdammers> then the new list is going to be x:xs
18:04:06 <typoclass> tdammers: hard to imagine, but go on ;-)
18:04:13 <dented42> tdammers: yes, but mvars can be rather icky.
18:04:13 <dented42> jimch: personally, I recommend that you not worry about performance at the start. it's more important that your program behave correctly then it is to have it be really really fast.
18:04:37 <tdammers> my point is, you're not copying the entire list
18:04:47 <tdammers> even though the code suggests so
18:05:07 <tdammers> you're just creating cons cells and pointing them to the previous list head
18:05:35 <dented42> jimch: threads aren't the only way to achieve parallelism, haskell also has something called strategies that a pretty darned cool.
18:05:57 <tdammers> dented42: reminds me... I have to look into those some time...
18:09:07 <dented42> tdammers: unfortunately they are really hard to reason about and debug when they don't behave how you want :P
18:09:18 <jimch> dented42 looks interesting
18:09:37 <jimch> Why?
18:10:15 <Ralith> tdammers: that doesn't seem to have much to do with lazy evaluation, nor is it commonly understood to be copying
18:10:21 <Ralith> linked lists work like that in every language.
18:10:57 <dibblego> Ralith: ever tried writing a strict cons list?
18:11:03 <dented42> jimch: because it basically boils down to performing lazy evaluation concurrently, which means that you have do know a lot about how lazy evaluation (and subtle things like garbage collection) affect your program.
18:11:11 <Ralith> dibblego: yes, I use them regularly.
18:11:17 <dibblego> Ralith: have you written one?
18:11:29 <Ralith> dibblego: ...? perhaps I misunderstand you
18:11:36 <dented42> jimch: the Par monad on the other hand is something that I know less about, but seems interesting
18:11:37 <dibblego> Ralith: it is non-trivial to do
18:11:47 <dented42> jimch: http://community.haskell.org/~simonmar/slides/CUFP.pdf
18:11:50 <Ralith> dibblego: I'm talking about linked lists in general, not in haskell.
18:12:04 <dibblego> Ralith: me too
18:12:15 <Ralith> they're, um, really simple.
18:12:22 <dibblego> No, really, they are not
18:12:31 <Ralith> why do you say that?
18:12:40 <dibblego> they work quite differently when you remove lazy evaluation
18:12:50 <Ralith> yes, everything works differently when you remove lazy evaluation.
18:12:57 <Ralith> that's characteristic of changing evaluation strategies.
18:12:58 <dibblego> specifically, a cons list
18:13:07 <dibblego> e.g. you must keep an updating pointer to tail
18:13:13 <dibblego> er last
18:13:18 <Ralith> whatever for?
18:13:23 <shachaf> To last?
18:13:23 <dibblego> if you don't, you change the complexity of operations
18:13:37 <dibblego> well "whatever for?" is an excellent question that is best answered by "try it"
18:13:53 * shachaf wonders what dibblego means.
18:13:55 <Ralith> singly-linked lists have very predictable computational complexity, that actually has little to do with evaluation strategy in the general case.
18:14:01 * Ralith is fairly mystified.
18:14:03 <dented42> jimch: er, if you're new to haskell I suggest you wrap your head around monads first :P
18:14:04 <dibblego> I used to think that too
18:14:25 <shachaf> OK, try what?
18:14:32 * Ralith delegates to shachaf 
18:14:34 <dibblego> write a cons list in say, java, C# or Scala
18:14:54 <dibblego> scala.List holds an updating pointer to last using ListBuffer
18:15:01 <dibblego> then does copy-on-write
18:15:06 <jimch> dented42: yes very new. I am on 4th chapter in learnyouahaskell.com
18:15:17 <Jafet> dibblego: which operation changes in complexity?
18:15:29 <dibblego> here is one I did in java: https://github.com/functionaljava/functionaljava/blob/master/core/src/main/java/fj/data/List.java
18:15:40 <dibblego> Jafet: I will have to search my memory for that
18:16:17 <diego> hi! first time here
18:16:36 * monochrom is at the Toronto haskell meeting!
18:16:46 <shachaf> hi monochrom
18:16:49 <shachaf> Did Cale show up?
18:17:01 <Jafet> .oO(There's always http://www.vex.net/~trebla/humour/Nightmare.java )
18:17:10 <monochrom> no, he lives too far away
18:17:14 <dented42> diego: feel free to grab a plate and help yourself to the salad bar
18:17:28 <jimch> I love many thins about haskell. typeclasses are cool. Lazy evaluation and infinite lists are awesome. I just still wish it had mutability on top of all that :)
18:17:36 * cmccann wonders if dibblego's argument applies to TChan
18:17:36 <diego> I'm having some problems installing packages via cabal
18:17:56 <diego> i'm trying to install glade but it just wont build
18:17:57 <jimch> and loops :)
18:18:03 <dibblego> I'm starting to think it was a trade between something, complexity and an updating pointer — sorry it was years ago I learned this lesson
18:18:05 <cmccann> jimch, mutability and lazy evaluation together are not awesome at all
18:18:15 <dibblego> jimch: you do not want that, promise
18:18:45 <monochrom> Control.Monad.ST.Lazy supports mutability and a bit of laziness
18:18:53 <jimch> cmccann: mutability and lazy evaluation wouldnt work well together?
18:19:08 <Jafet> > runState 1 $ do { n <- get; put (n + 1); return (); }
18:19:10 <lambdabot>   No instance for (GHC.Num.Num
18:19:11 <lambdabot>                     (Control.Monad.Trans.State...
18:19:29 <Jafet> > flip runState 1 $ do { n <- get; put (n + 1); return (); }
18:19:31 <lambdabot>   ((),2)
18:19:38 <Jafet> Mutability
18:19:48 * hackagebot edge 0.8.4 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.4 (ChristopherHoward)
18:19:51 <ivanm> has bos talked about criterion at any conferences, etc.?  Just trying to work out how to reference it in a paper
18:19:56 <monochrom> but even with Control.Monad.ST, you can writeSTRef v (repeat 0)
18:20:06 <dented42> jimch: well it's hard to coordinate when state should be modified when you don't control when any particular part of your program runs
18:21:01 <typoclass> jimch: short story is, yes, there is some tightly controlled mutability available. but it's one of those things where you think "i'm definitely gonna need plenty of that" when you first start out with haskell, but once you get to the intermediate level, you end up using it rarely :-)
18:21:12 <typoclass> cmccann: can you elaborate?
18:21:15 <monochrom> the height of laziness and mutability is demonstrated in http://www.haskell.org/haskellwiki/MonadFix
18:21:21 <dented42> jimch: if the evaluation order is undefined then you can't be sure that the part of your program that creates a something-or-other executes before the part of the program that reads from it
18:21:42 <cmccann> typoclass, elaborate on what?
18:22:44 <typoclass> cmccann: er never mind, i re-read your comment
18:23:49 <cmccann> anyway, the degree to which mutability and lazy evaluation are not awesome can only be appreciated by learning it the hard way
18:24:23 <Ralith> jimch: mind, Haskell's mutability stuff is awesome when you do need it.
18:24:35 <cmccann> lots of imperative languages these days support various kinds of delayed or on-demand execution, and you can create unbounded amounts of confusion by having lots of side-effects (including mutation) inside such constructs
18:24:56 <callen> Ralith: what *is* Haskell's mutability stuff?
18:24:56 <lambdabot> callen: You have 1 new message. '/msg lambdabot @messages' to read it.
18:25:03 <diego> I'm sorry if I am a little bit annoying, but does anybody know how I can install the glade package? When I try to build it via cabal or from the ArchUserRepository it gives me the same error
18:25:10 <callen> unsafe? STM?
18:25:35 <diego> Graphics/UI/Gtk/Glade/Types.chs:92:1:
18:25:35 <diego>     Unacceptable result type in foreign declaration: CUInt
18:25:35 <diego>     When checking declaration:
18:25:35 <diego>       foreign import ccall unsafe "static glade_xml_get_type" glade_xml_get_type
18:25:35 <diego>         :: CUInt
18:25:55 <Ralith> callen: well, what kind of mutability are you looking for?
18:25:57 <dcoutts> diego: you'll have to stick to ghc-7.4 for now
18:25:57 <geekosaur> that's a ghc 7.6 specific issue; I think you need to build from the repo
18:26:02 <cmccann> diego, you can fix the code so it compiles with a newer GHC I suppose
18:26:03 <geekosaur> or use 7.4
18:26:07 <callen> Ralith: I'm just curious as to what options I have. I want to go ruin somebody's day on github.
18:26:10 <cmccann> or use an older compiler, yeah
18:26:20 <Ralith> callen: do what now?
18:26:20 <cmccann> if memory serves me you just need to add an extra import
18:26:25 <geekosaur> unfortunately, if you're on arch they make it difficult to stick to supported ghc versions, they insist on chasing the bleeding edge
18:26:31 <geekosaur> and you get to keep the bloodstains
18:26:39 <Jafet> unsafePullRequest
18:26:43 <typoclass> diego: hello, welcome. if you have any more things to paste, please use hpaste, thanks
18:26:45 <typoclass> @where hpaste
18:26:45 <lambdabot> http://hpaste.org/
18:26:45 <callen> Ralith: I was joking.
18:26:58 <diego> ohh thanks! I'll downgrade it now :))
18:26:59 <Ralith> callen: right, I just don't understand the joke :P
18:27:15 <Ralith> callen: anyway, I was mostly referring to ST, which is similar to the State monad except that it is safe to implement it with actual mutation.
18:27:21 <callen> Ralith: imagine a mischievous elf running about slipping unsafe functions into Haskell projects.
18:27:24 <Ralith> as a compiler optimization
18:27:30 <Ralith> oh, no
18:27:32 <Ralith> it's quite safe
18:27:33 <Ralith> that's the point
18:27:34 <geekosaur> you might aso note that telling us the error was the trick...
18:27:47 <geekosaur> most of us were waiting to hear what the actua problem was, because we're not mindreaders
18:28:23 <Ralith> I believe the only times you *need* unsafe operations is when constructing safe ones on top of e.g. a FFI binding.
18:28:27 <Jafet> Haskell is stateful. Being Turing-complete, it supports an unlimited amount of state. It's garbage collected so you can replace old state by new state. I don't understand why people troll on about this again and again
18:28:35 <Ralith> which is then ultimately safe, assuming you haven't screwed up
18:28:43 <callen> Jafet: who's trolling?
18:28:55 <cmccann> Jafet, forcing thunks involves a breathtaking amount of mutable state, in fact!
18:29:09 <Jafet> People who say that "Haskell has no state" or "mutation is bad" blah blah
18:29:27 <simpson> Well, mutation's sometimes difficult to reason about.
18:29:33 <callen> Jafet: I think the issue is that it's a "devil you know" problem.
18:29:34 <monochrom> and I have cited counterexamples
18:29:45 <callen> Jafet: they'd rather the mutation they're currently familiar with, than how Haskell boxes up statefulness.
18:29:45 <simpson> But that doesn't make it bad.
18:30:15 <dented42> Jafet: it's not bad as such, it just tends to be… needlessly complicated
18:30:20 <cmccann> rule of thumb: all programming techniques and idioms are bad.
18:30:22 <Rotaerk> mutation can be useful for performance improvement
18:30:39 <callen> cmccann: not true, some of them are mine and therefore excellent.
18:31:02 <cmccann> no, those are just the ones you haven't realized are bad yet
18:31:02 <c_wraith> callen: when you look back at them in 5 years time, you'll change your mind
18:31:06 <diego> one last question, how safe would it be to downgrade ghc to 7.4?
18:31:10 <callen> c_wraith: I already did that vs. 5 years ago
18:31:13 <wks> Hi. Is this function in any libraries in GHC? f m1 m2 = m1 >>= \x1 -> m2 >>= \x2 -> return (x1,x2)
18:31:14 <Jafet> Rule of pinky: to write good code, use your pinky
18:31:25 <callen> c_wraith: my code 5 years ago was either macro-trash Common Lisp or noobface Python.
18:31:33 <Jafet> @pl f m1 m2 = m1 >>= \x1 -> m2 >>= \x2 -> return (x1, x2)
18:31:33 <lambdabot> f = liftM2 (,)
18:31:47 <shachaf> pl++
18:31:55 <callen> Jafet: I'd end up writing all my code in an information-compressed lambda turing tarpit to save keystrokes.
18:32:10 <Jafet> Why wait dude
18:32:18 <cmccann> just learn APL
18:32:29 <Jafet> I think Tromp beat you to it actually
18:32:29 <callen> I'm told there's a special place in hell for people who use APL/J/Q/K
18:32:38 <callen> Jafet: aye...he did... :(
18:34:07 <dented42> diego: as long as you don't mind recompiling your world it's perfectly safe
18:34:10 <callen> johnw: got your message. Danke!
18:34:18 <dented42> diego: though you may have to stick to older versions of some packages
18:34:26 <johnw> callen: :)
18:34:35 <johnw> i just had dinner at a German restaurant :)
18:34:46 <callen> johnw: it's in my *scratch* buffer on Emacs. Funny you mention that, I'm German-American and love German food.
18:34:55 <callen> johnw: I recommend this local German place to everybody I meet.
18:35:05 <typoclass> johnw: somebody let the germans make food? urgh
18:35:05 <johnw> same here!  where are you located?
18:35:07 <callen> johnw: what'd you eat?
18:35:12 <callen> johnw: mountain view!
18:35:16 <wks> @pl liftM2 (,)
18:35:16 <lambdabot> liftM2 (,)
18:35:19 <johnw> a place called Hofbräu
18:35:24 <callen> typoclass: hey. hey. heyyyyy. *scowls*
18:35:25 <johnw> in Peoria, Illinois
18:35:31 <callen> sigh, FIB.
18:35:32 <shachaf> callen: You're in Mountain View?
18:35:33 <johnw> lots of Germans around these parts
18:35:38 <callen> shachaf: yeah.
18:35:43 <callen> johnw: I know, I'm from the midwest.
18:35:47 <callen> johnw: my people is there. :P
18:35:47 <shachaf> callen: Do you go to bahaskell?
18:35:59 <wks> @pl f m1 m2 = m1 >>= \x1 -> m2 >>= \x2 -> return x1
18:36:00 <lambdabot> f = (. ((. (const . return)) . (>>=))) . (>>=)
18:36:02 <typoclass> johnw: er a little embarrassing to tell you, but there's bird droppings on your 'a'
18:36:06 <callen> shachaf: no but a fellow emacs fascist and ex-lisper friend of mine does.
18:36:10 <wks> @pl f m1 m2 = m1 >>= \x1 -> m2 >>= \x2 -> return x2
18:36:10 <lambdabot> f = (. const) . (>>=)
18:36:22 <wks> @pl (*>)
18:36:23 <lambdabot> (*>)
18:36:23 <johnw> typoclass: it's not an a, it's an ä :)
18:36:24 <callen> shachaf: big beard, rides a motorcycle (like me), into emacs (like me), works at Berkeley.
18:36:27 <callen> shachaf: ring a bell?
18:36:47 <shachaf> callen: Aaron?
18:36:54 <callen> shachaf: on the nose )
18:36:59 <callen> shachaf: I worked with him at Affine.
18:37:05 <johnw> callen: you're into Emacs too?  me as well
18:37:25 <johnw> is there any good way to make a list comprehension parallel?
18:37:29 <callen> johnw: I'm into Emacs like a crack addict is into crack. my .emacs.d has 400k loc of elisp :P
18:37:48 <johnw> callen: interesting; do you use Eshell?
18:38:11 <callen> johnw: actually, usually just inferior shell. I keep trying to break into eshell but I've relegated it to the same bucket as gnus. "I'd like to know how to leverage it, but don't yet"
18:38:29 <callen> johnw: I lean most heavily on the programming specific parts of the Emacs community. Stuff like scion, pymacs, etc.
18:38:41 <johnw> very cool
18:38:46 <johnw> i'd suppose we have quite a bit in common :)
18:39:07 <johnw> i'm into Emacs like a crack addict who makes his own crack
18:39:52 <callen> johnw: yeah, I don't use any package managers.
18:40:02 <callen> johnw: I curate and maintain it myself, although I wrote precious little of it.
18:40:02 <clahey> Great, now I'm trying to make my coworkers add functional stuff to our C++ code.  Thanks! guys!
18:40:05 <clahey> :)
18:40:09 <brxmx> johnw heh. what mode do you use for haskell?  I am using plain haskell-mode and I'm not too happy with it
18:40:11 <callen> johnw: I did write my own clone of HackerTyper for Emacs once.
18:40:26 <callen> brxmx: what don't you like about it? Do you have anything to compare it to?
18:40:36 <johnw> brxmx: I use haskell-mode plus ghc-mod plus https://github.com/jwiegley/haskell-config
18:41:52 <brxmx> callen autoindentation doesn't work well, i have to manually indent everything. also I wish there was symbol completion
18:41:59 <typoclass> clahey: i told my old boss the thing about how learning haskell making you a better programmer whether you use haskell or another language. he said learning haskell makes you write incomprehensible code whether you use haskell or another language
18:42:14 <callen> brxmx: symbol completion is largely up to scion, generally speaking. you plug it into your haskell-mode hook.
18:42:30 <shachaf> typoclass: What if you're both correct?!
18:42:41 <callen> brxmx: indentation I cannot speak to. There might be some progress to be made there. You may want to take a keen look at what indentation methods you're using.
18:43:08 <johnw> brxmx: make sure you are using haskell-indentation-mode, and not one of the two older modes
18:43:36 <brxmx> it's possible I don't have something set up correctly. for example if I type if something<enter>then something<enter>else, else is lined up with last something and not with then
18:43:40 <ski> typoclass : blub and all that :)
18:43:54 <johnw> brxmx: yes, that is definitely a misconfig somewhere
18:44:03 <johnw> does else line up when you type TAB?
18:44:17 <callen> typoclass: that's some strong smelling blub PHB right thur.
18:44:34 <johnw> callen: come join #emacs!
18:45:06 <brxmx> johnw if I press tab it lines up with if
18:45:21 <johnw> you mean, if/then/else all begin
18:45:23 <johnw> in the same column?
18:45:45 <callen> brxmx: if you could produce a test case...that would be highly ideal.
18:45:56 <callen> brxmx: then I could try it in my emacs, see if I get the same behavior.
18:47:33 <brxmx> here is an example: http://hpaste.org/77434
18:48:58 <brxmx> I have return binded to (lambda () (interactive) (haskell-newline-and-indent)) by the way
18:49:41 <johnw> same here
18:50:07 <brxmx> and you get proper indentation? else lined up with then?
18:50:14 <callen> brxmx: seems fine to me. turn on haskell-indent-mode
18:50:28 <clahey> shachaf: Someone who writes incomprehensible code isn't a better programmer.
18:50:44 <callen> brxmx: usually ret is newline, and C-j is newline-and-indent in Emacs-land btw...
18:51:02 <johnw> i normally have to hit tab to get then and else to line up
18:51:03 <shachaf> clahey: Depends on your heuristics.
18:51:06 <callen> I *was* able to repro your problem fyi, and it was with haskell-indent-mode off that i got the same problem.
18:51:23 <callen> turned it back on...life was good again.
18:51:55 <callen> brxmx: (add-hook 'haskell-mode-hook 'turn-on-haskell-indent) and haskell-indent-mode :)
18:52:04 <tsou> damn, it'll be painful to learn how to use emacs.. :|
18:52:20 <brxmx> callen yes I have that, and indent mode is on
18:52:21 <callen> tsou: it's not that bad. I intro a lot of my coworkers, friends, etc. to it.
18:52:35 <callen> tsou: it's highly susceptible to concentric circles of learning.
18:52:38 <brxmx> actually I have (add-hook 'haskell-mode-hook 'turn-on-haskell-indentation)
18:52:47 <brxmx> I'll try your version
18:53:23 <callen> brxmx: be careful. my shit is eldritch.
18:53:29 <callen> brxmx: I don't think my haskell-config.el is proper.
18:53:47 <tsou> callen: i've been using vim non-stop for any kind of textediting for the past.. 15 years or so.. it *will* be hard.. but I'm convinced i'll force myself to it
18:54:30 <brxmx> ok something is up. now I am getting Symbol's function definition is void: haskell-newline-and-indent
18:54:36 <callen> tsou: pffft. just use evil.
18:54:38 <brxmx> after restarting emacs
18:54:38 <johnw> tsou: any more painful than learning Haskell?  I think not
18:55:11 <tsou> johnw: hehe learning haskell's been fun.  trying to use non-vim editors has been tiring..
18:55:23 <brxmx> I changed turn-on-haskell-indentation with turn-on-haskell-indent
18:55:38 <johnw> tsou: most cool-but-worthwhile things start out that awy
18:55:45 <tsou> callen: is that one of those things that try to be vim inside emacs?
18:55:55 <johnw> linear algebra is wearing me out right now, but I'm convinced it's worth it
18:56:03 <callen> brxmx: repro'd your problem again, tinkering to test a hypothesis.
18:56:08 <callen> johnw: DETERMINANTS
18:56:12 <johnw> i'm already starting to see problems in terms of vector and matrices that I wouldn't have looked at that way before
18:56:13 <tsou> johnw: haha, use halmos and it won't be a pain anymore :P
18:56:21 <callen> johnw: LA is a big part of our work.
18:56:22 <johnw> i'm reading Halmos right now too
18:56:30 <tsou> johnw: both books?
18:56:35 <johnw> just his set book
18:56:47 <johnw> his proofs have totally lost me now, but this is just a cursory first read
18:56:59 <tsou> johnw: oh that was a breeze to read :)
18:57:09 <tsou> johnw: i was refering to his linear algebra books
18:57:18 <johnw> the idea that "function" can be defined as a subset of a cartesian product of sets has completely turned my world upside down
18:57:25 <tsou> if only halmos had written a book on emacs... :|
18:57:30 <johnw> lol
18:57:41 <callen> tsou: do you want one? I could write a book on Emacs.
18:57:43 <tsou> johnw: the idea that function can be anything else turned my world upside down :P
18:57:49 <johnw> haha
18:57:57 <callen> tsou: it'll be called "RTFM" and the contents will say: "C-h m"
18:58:03 <mm_freak> johnw: functions are relations, and relations can be interpreted as subsets of cartesian products
18:58:08 <tsou> callen: you missed the "Halmos" part
18:58:19 <callen> tsou: actually, his book is like kata for math, yes?
18:58:20 <johnw> mm_freak: yeah, seems so simple in restrospect :)
18:58:33 <mm_freak> johnw: an order is also such a relation, so there is a strong connection between orders and functions =)
18:58:35 <callen> tsou: I'm a big fan of learning through kata/practice and slowly expanding scope/depth
18:58:43 <johnw> mm_freak: i'm just reading about order now
18:59:24 <tsou> callen: he has written plenty of books.. and the ones i've read made me wish he had written on topics i wanted to learn but he hadn't
18:59:48 <mm_freak> johnw: think of prolog, where f(X, Y) means that X and Y are f-related =)
19:00:02 <callen> tsou: which book of his is in context right now? the problem book?
19:00:37 <tsou> johnw: check moschovakis's book on set theory in par with halmos's btw, it's well-worth it
19:00:55 <johnw> tsou: have you read the one on intro to boolean algebras?
19:01:12 <tsou> callen: started talking about the two linear algebra books (the problems.. and the finite-dimensional vector spaces one)
19:01:14 <wks> @pl f m1 f2 = m1 >>= \x1 -> (f2 x1)
19:01:15 <lambdabot> f = (>>=)
19:02:01 <tsou> johnw: no; i've read 4 halmoses so far.. the two lin-alg's, measure theory, and naive set theory..
19:02:16 <tsou> johnw: but when i'll want to look more into boolean algebras i know where i'll start from :P
19:02:38 <callen> tsou: which one should a noob start with?
19:02:47 <tsou> callen: noob in lin-alg?
19:03:37 <callen> tsou: lets go with that, yes.
19:03:45 <tsou> callen: they are meant to be read in parallel, and that worked pretty nice for me
19:03:45 <callen> although realistically I am awful at all the maths :)
19:04:09 <tsou> callen: the problem book is what it says: bunch of problems, that progress through the topics
19:04:24 <tsou> the other book looks more like a math book.. but still; i'd recommend the parallel way
19:04:31 <mm_freak> reading about basic number theory helped me get into the right mindset for both linear algebra, abstract algebra and group theory
19:04:41 <callen> mm_freak: book plz.
19:04:54 <mm_freak> i can only recommend german books
19:05:09 <luite> math sounds better in german anyway ;p
19:05:14 <johnw> callen: I'm reading this one now: http://www.amazon.com/gp/product/0321287134/ref=oh_details_o03_s00_i00
19:05:19 <tsou> callen: now your turn for something very well-written on emacs :P
19:05:28 <johnw> (yes, the older version, because it's dirt cheap)
19:05:40 <callen> tsou: I hate to say this, but I wasn't kidding about the `C-h m` thing.
19:05:54 <callen> tsou: I know it's hard to believe this until you've used it, but once you know the "help" prefix, Emacs is largely self-documenting
19:05:59 <tsou> johnw: witch!  burn it and get the halmos books :P
19:06:01 <callen> tsou: the tutorial that's built in is comparable to the one in vim.
19:06:19 <tsou> callen: i'm used to nicely and very well-documented things; so it's not that hard to believe
19:06:20 <johnw> and this book is proving quite interesting, with less of a "hard core" feel: http://www.amazon.com/gp/product/052171916X/ref=oh_details_o00_s00_i00
19:06:50 <callen> tsou: it's not just that it's nicely documented, it's like an entire self-documented universe of code.
19:07:11 <callen> tsou: there's a deep link between GNU info pages and the way Emacs documentation works.
19:07:30 <callen> tsou: the usual pattern is to do the tutorial, start with a blank .emacs file, and just gradually add things as you go from the EmacsWiki.
19:07:43 <johnw> callen: that deep documentation aspect was actually first used in the Lisp Machines of yore
19:07:43 <tsou> callen: i've never used gnu info pages ;)
19:07:52 <callen> Emacs, ideally, doesn't require a lot of upfront learning unless you want to do srs-face elisp coding.
19:08:02 <callen> johnw: yes yes, symbolics genera and zmacs. I know.
19:08:09 <callen> johnw: ex-CL'er, I've heard the tales of the glory days.
19:08:27 <johnw> :)
19:08:28 <tsou> johnw: this is a very peculiar book, one-of-its-kind ;)
19:08:35 <johnw> tsou: the CT book?
19:08:46 <johnw> is that peculiar in a good way, or a bad one?
19:08:46 <tsou> johnw: yes, lawvere's baby book
19:08:54 <johnw> hahaha
19:08:56 <tsou> johnw: depends on your style :P
19:09:06 <johnw> i am most certainly a math baby
19:09:27 <johnw> i don't even remember how to multiply (a + b) with (a - b)
19:09:42 <johnw> i think it's like a^2 + 2ab - b^2 or something
19:09:49 <johnw> 4ab?
19:09:54 <callen> 2
19:09:57 <johnw> k
19:09:58 <tsou> johnw: you create a thunk and defer the actual multiplication until needed :P
19:10:04 <johnw> awesome :)
19:10:10 <callen> johnw: I'm at about the same tier fyi.
19:10:20 <johnw> callen: i think you're my doppelganger, actually
19:10:44 <callen> johnw: I doubt it. I ride motorcycles, drink scotch, and stockpile surplus Russian ammo.
19:10:51 <tsou> callen: by *the* tutorial, you mean the thing that comes with emacs?
19:10:53 <johnw> ok, maybe not
19:10:55 <callen> tsou: yes.
19:10:57 <brxmx> callen any luck finding out what is going on? I tried to reinstall haskell mode, didn't help
19:11:04 <callen> johnw: I've always got something in my back pocket like that :D
19:11:20 <callen> brxmx: well, I switched my mode to to indentation mode
19:11:28 <callen> brxmx: and it sucked ass and repro'd the problem
19:11:33 <callen> brxmx: so I'm going back to my indent-mode
19:11:45 <johnw> you carry russian ammo in your back pocket?
19:12:00 <callen> brxmx: so if you hate it as much as I do, don't use indentation, use indent.
19:12:14 <johnw> how is indent better than indentation?
19:12:21 <callen> johnw: no, I just have a rucksack of weird hobbies that I can pull like a rabbit out of a hat if I want to differentiate.
19:12:26 <callen> johnw: preference.
19:12:40 <tsou> callen: any of those many coworkers/friends/etc. that you intro'ed to emacs was a heavy-vim user?
19:12:44 <johnw> i 90% like indentation, but i don't like that it won't manage endline layout for function arguments
19:12:54 <johnw> tsou: I was a heavy vi user
19:12:57 <callen> tsou: coworkers/friends no, acquaintances and other IRCers yes.
19:13:10 <brxmx> I have tried using indent earlier, I am getting Symbol's function definition is void: haskell-newline-and-indent
19:13:13 <tsou> johnw: vi or vim?
19:13:18 <callen> tsou: it's worth noting that I use vim a bit too.
19:13:19 <brxmx> after pressing return
19:13:25 <johnw> real honest to goodness SVR3 vi
19:13:31 <johnw> in the days before "m"
19:13:35 <callen> tsou: I know both and have a fairly modern vim setup.
19:13:52 <tsou> callen: i'm not doubting that as far as text-editing goes, i don't want to change vim; it's the rest of the things that i need to use emacs for
19:13:54 <callen> it's more minimalist than it used to be.
19:13:59 <tsou> proof general being one example
19:14:16 <callen> tsou: well lets get more concrete. What do you think you'll lose by going to Emacs?
19:14:19 <callen> tsou: editing fluency?
19:14:55 <tsou> johnw: yes, but what i meant to say, is that heavy-using vi is not so-many things, compared to heavy-using vim.  so if you're a heavy-vim user, you've got more things to interfere with your emacs-learning process
19:15:16 <tsou> callen: yes.  i find typing text that's more than 1-2 lines annoying even on <textarea>s in html forms...
19:15:19 <callen> Evil solves that for vim users.
19:15:24 <callen> tsou: ^^
19:16:03 <tsou> callen: you mentioned it before, and i asked if it's one of those things that tries to be vim inside of emacs
19:16:13 <callen> tsou: there are like 4 or more other vi/vim solutions if you want something lighter-weight.
19:16:22 <callen> tsou: seriously just try them out and pick one, haha.
19:16:36 <tsou> callen: i've tried 2 of them: one was viper, the other one i don't remember but might have been evil indeed
19:16:47 <callen> there's a vi-mode too.
19:17:26 <tsou> callen: the more heavy a vim user are, the more you'll get annoyed by such attempts, cause you'll keep doing things that would work in the real vim, but not in those things
19:17:45 <tsou> i'd rather learn emacs the emacs-way, than try to pretend i'm using vim inside of emacs :P
19:18:30 <callen> tsou: then just use a vanilla emacs stack and do the tutorial to get fluent on the editing side
19:18:43 <callen> tsou: a note on the philosophical difference: Emacs tries to be strategic, not tactical. Vim is tactical.
19:19:00 <tsou> callen: in what sense do you mean those two words?
19:19:02 <callen> tsou: Emacs tries to make the truly time-consuming stuff efficient, not petty things like raw edits/changes.
19:19:27 <callen> tsou: Vim is tactical in the sense that it optimizes for the more obvious components of what a text editor does, but Emacs is more about the problem you're solving (writing code, email, version control)
19:19:52 <callen> I'm not trying to troll, I think they're both legitimate approaches depending on what you prefer.
19:19:59 <tsou> callen: in vim i like the fact that i have a very simple language to talk with my editor, and have it do things for me
19:20:20 <callen> tsou: there's a language to Emacs, but it's more structural and less literal.
19:20:39 <callen> tsou: there's a logic to the prefixes, regions (equivalent to visual-mode 'ish), etc.
19:21:08 <tsou> callen: is it "predictable", in the sense that hmmm let's say that a lot of features of vim, i found out by thinking: "damn it'd be awesome if it could do *that*; and if it could, it'd probably do it if i'd hit those keys."
19:21:15 <tsou> callen: (and then you hit those keys and it actually does it)
19:21:32 <callen> tsou: one of the biggest problems vim has as you try to scale it up to specific needs is that the literal meanings of the 'language' can't be compromised or changed for the sake of the context, so you end up with really awkward stuff like NERDTree.
19:21:48 <callen> I find Emacs very predictable, myself.
19:22:01 <callen> tsou: I think the real conclusion is that you just need to use it and ask questions in #emacs when you have some.
19:22:41 <callen> tsou: if you want a "killer" app, I'd say the scion integration and magit are good places to start. I've got a choice python setup in my dotfiles repo that is quite nice.
19:23:03 <tsou> callen: i was brought to emacs because of proof general
19:23:53 <callen> tsou: I'm not going to lie, that shit looks arcane, but whatever makes you happy. Haha.
19:24:20 <tsou> hehe open to alternatives if you've got any in mind :P
19:24:49 <callen> tsou: I'm not familiar with proof assistants. This is a pretty common thing in Emacs though.
19:25:13 <callen> tsou: elisp is easy enough to use that you'll have freaky unabomber-types and academics who are off in their own little world inventing their own app/universe inside of emacs for solving their problem.
19:25:31 <callen> tsou: it bears more than a passing resemblance to how lispers use macros to "specialize" their code/environ/DSL to a specific problem.
19:26:20 <tsou> callen: yes, the 'revelation' for me was when i came to realize that proof general exists for emacs and not for vim,
19:26:34 <tsou> not because the guys who made it were from the other side of the editor-war
19:26:54 <tsou> but because it's not possible to implement in vim, while it is in emacs..
19:40:05 <callen> brxmx: try simple indent, see if it's what you want.
19:40:20 <callen> brxmx: just did some tinkering, think it might let you more easily do what you want.
20:17:01 <spherox> Can _anyone_ point me to a more complete description of Parsec than RWH has?
20:17:22 <spherox> I desperately want to know how to use GenParser for things other than [Char]
20:18:41 <typoclass> spherox: how about the original paper that described parsec? they say "import Parsec", where today that module has been moved to another place, but this should be easy to figure out
20:19:02 <Ralith> spherox: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html#SeperateScanners
20:19:45 <typoclass> ... i think that's what i mean, thanks ralith
20:19:57 <Ralith> ^^
20:20:20 <spherox> Thanks!
20:24:03 * typoclass . o O ( i feel vaguely warm inside, this has to be some sort of record in terms of helpfulness per second )
20:24:06 <typoclass> ;-)
20:24:38 <otters> so I gather that attoparsec is good for reading incremental input
20:24:49 <otters> if I don't need that, should I just be using parsec?
20:25:42 <ion> Parsec has better error messages (unless that has changed).
20:26:33 <Clint> there's http://hackage.haskell.org/package/attoparsec-parsec
20:27:57 <brxmx> what libraries would one use for webscrapping?
20:28:07 <brxmx> web scraping
20:28:59 <brxmx> which one for fetching a web page, and which one for parsing it?
20:29:11 <Clint> tagsoup?
20:36:23 <johnw> brxmx: i'd probably use Network.Conduit.HTTP.Browser for scraping
20:37:00 <johnw> brxmx: see also http://adit.io/posts/2012-04-14-working_with_HTML_in_haskell.html
20:39:49 <brxmx> thanks
20:43:41 <brxmx> shpider looks interesting too.  http://hackage.haskell.org/package/shpider
20:43:53 <lispy> Hello good people of #haskell! How goes the computational specifications?
20:44:13 <johnw> well!
20:44:20 <johnw> they commute!
20:44:41 <lispy> that always makes it easier to put the cart before the horse
20:46:28 <lispy> I turned a bunch of C++ into a bit of Haskell this week.
20:46:31 <lispy> It was very rewarding.
20:46:44 <johnw> i  bet
20:46:47 <johnw> i like doing that too
20:47:36 <lispy> Most of the Haskell I wrote was there to setup traversals, and as such I'll be getting a lot of mileage out of it
20:50:40 <ion> brxmx: I used HXT.TagSoup for scraping some time ago. https://gist.github.com/1369649
20:56:40 <dmwit> ion: A screenscraper to download electric sheep? Isn't that sort of what the client already is?
20:57:08 <dmwit> Plus they totally make sheep packs available for download, which give you like 100 sheep at once...
20:58:05 <dmwit> http://archive.org/details/electricsheep-packs-244
20:58:58 <ion> dmwit: The client only downloads a bunch of recent sheep. I was also unable to find any new packs. The ones you linked are from 2009.
20:59:58 * dmwit admits he hasn't really messed with electricsheep in a few years
21:00:46 <shachaf> Doesn't dmwit dream of electricsheep?
21:01:04 <shachaf> Hmm, that's backwards.
21:37:04 <lispy> :t fromIntegral . fromEnum
21:37:05 <lambdabot> (Enum a, Num b) => a -> b
21:58:05 <JavaSucksMan> is there something I can put into my .ghci file to increase the ghci history?
22:01:01 <JavaSucksMan> been looking in System.Console.Haskeline.History, but I really don't want to rebuild ghc
22:16:50 <statusfailed> How do I turn one lens (Control.Lens) from a to b into one from a to c?
22:17:12 <edwardk> by composing it with one from b to c with (.)
22:17:34 <statusfailed> edwardk: can I compose it with a pure function?
22:17:34 <edwardk> :t _2._2
22:17:35 <lambdabot> (Functor f, Field2 a b a1 b1, Field2 s t a b) => (a1 -> f b1) -> s -> f t
22:17:43 <statusfailed> :t _2 . (+1)
22:17:44 <lambdabot> (Functor f, Num (f b), Field2 s t a b) => (a -> f b) -> s -> f t
22:17:50 <edwardk> you can get a 'getter' that way with 'to'
22:17:55 <edwardk> :t _2 . to (+1)
22:17:56 <lambdabot> (Num a, Field2 s t a a, Gettable f) => (a -> f a) -> s -> f t
22:18:07 <edwardk> :t ("hello",5)^._2.to (+1)
22:18:09 <lambdabot> Num t => t
22:18:18 <edwardk> but you can't write back to a getter
22:18:25 <edwardk> > ("hello",5)^._2.to (+1)
22:18:28 <lambdabot>   6
22:18:30 <statusfailed> that's cool, I wanted a getter :D
22:18:39 <edwardk> > ("hello",5)^._2^% (+1)
22:18:41 <lambdabot>   6
22:18:45 <edwardk> that also works
22:19:21 <edwardk> if you want one you can write back to you can build it with iso or isos
22:19:22 <statusfailed> :t _2 ^% (+1)
22:19:23 <lambdabot> (Functor f, Num (f t), Field2 s t a b) => (a -> f b) -> s -> f t
22:19:41 <statusfailed> that's not what I want, si it
22:19:42 <edwardk> that doesn't work that way you need, the ^._2^%(+1)
22:19:56 <edwardk> the parens work the other way on that
22:20:00 <statusfailed> ok
22:20:04 <edwardk> (foo^.bar)^%baz
22:20:25 <Nereid> :t (^%)
22:20:27 <lambdabot> a -> (a -> b) -> b
22:20:28 <edwardk> its infixl 8 like ^.
22:20:44 <edwardk> ts just flip ($) with pretty tight precedence, bound infixl
22:20:56 <Nereid> I see that.
22:21:04 <edwardk> you can of course just use foo^.bar + 1
22:21:04 <statusfailed> hang on, so how do I transform one lens using a pure function?
22:21:11 <statusfailed> without using ^.
22:21:25 <edwardk> :t _2.to (+1)
22:21:26 <lambdabot> (Num a, Field2 s t a a, Gettable f) => (a -> f a) -> s -> f t
22:21:35 <statusfailed> oh it has to be a gettable, right
22:22:16 <edwardk> > ("hello",5)^._2 + 1
22:22:18 <lambdabot>   6
22:22:36 <edwardk> ^. is very high precedence, so you can just drop the +1 around the whole thing at the use site usually
22:23:10 <statusfailed> I wanted getters in a list, which is why im doing it elsewhere
22:23:15 <edwardk> fair nuff
22:23:31 <edwardk> you want to actually store the in a [] list?
22:23:33 <statusfailed> for this guy: showSep sep lenses x = concat . intersperse sep . map (x ^.) $ lenses
22:23:45 <statusfailed> is that a terrible way of doing things??
22:23:52 <edwardk> you're going to be disappointed somewhat, they get dumbed down to non-getters by then
22:24:12 <edwardk> lenses, getters, etc don't 'store' well in containers.
22:24:59 <statusfailed> sorry, not really following- what do you mean "dumbed down to non-getters"?
22:25:04 <edwardk> if they aren't lenses. why not just store them in the list as accessors.
22:25:08 <edwardk> i mean as functions
22:25:50 <edwardk> showSep accs x = concat . intersperse sep . map ($x) $ lenses   -- or map (x%)
22:26:06 <edwardk> showSep accs x = concat . intersperse sep . map ($x) accs
22:26:19 <edwardk> then accs just contains a list of functions
22:26:25 <edwardk> no lensy-ness
22:26:55 <statusfailed> .............. derp
22:26:58 <edwardk> they can be written [(^._2.to (+1)), … ] or whatever if you insist ;)
22:27:07 <edwardk> but the getters provide no value here =)
22:27:59 <statusfailed> would there be a better way to build up those functions?
22:30:21 <edwardk> not sure. the (^._2) approach isnt so bad
22:30:38 <edwardk> and i explicitly made ^. bind more loosely than . so you can section a chain of them like that
22:30:51 <edwardk> :t (^._2._2)
22:30:53 <lambdabot> (Field2 a1 b1 a b, Field2 s t a1 b1) => s -> a
22:31:12 <edwardk> :t (^._2._1) ("hello",("world","!!!"))
22:31:14 <lambdabot> [Char]
22:31:52 <edwardk> or i suppose you can write then with view
22:32:02 <edwardk> [view (_2.to(+1)), ...
22:32:08 <JavaSucksMan> is there something I can put into my .ghci file to increase the ghci history?
22:32:33 <notdan> :t view
22:32:35 <lambdabot> Getting a s t a b -> s -> a
22:32:52 <notdan> :t to
22:32:53 <lambdabot> Gettable f => (s -> a) -> (a -> f a) -> s -> f s
22:34:54 <notdan> > view "hello"^._2.to(ord)
22:34:56 <lambdabot>   Couldn't match expected type `Control.Lens.Getter.Getting
22:34:56 <lambdabot>                  ...
22:35:00 <statusfailed> edwardk: view is the same as (^.)
22:35:01 <statusfailed> ?
22:35:08 <notdan> > "hello"^._2
22:35:10 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2
22:35:10 <lambdabot>                      [GHC.Types...
22:35:18 <statusfailed> ok yep, just read docs
22:35:19 <edwardk> statusfailed: (^.) = flip view
22:35:27 <notdan> > ("hello","world")^._2
22:35:29 <lambdabot>   "world"
22:35:50 <statusfailed> oh nice, now I can replace my "map (flip (^.))" haha
22:36:00 <edwardk> statusfailed: =)
22:36:10 <statusfailed> ok now I see why you pointed that out :p
22:36:12 <statusfailed> thanks
22:36:39 <statusfailed> I really need to take the time to go over this library in detail soon :D
22:36:42 <notdan> What does 'to' do?
22:37:34 <edwardk> to converts a function to a 'getter' so it can be used with ^. or view, or with any of the other fold combinators and combined with other getters, folds, traversals, lenses, isomorphisms, etc.
22:37:44 <edwardk> > "hello"^.to length
22:37:47 <lambdabot>   5
22:37:51 <edwardk> > length "hello"
22:37:53 <lambdabot>   5
22:38:04 <notdan> Hm
22:38:05 <edwardk> > "hello"^..to length
22:38:07 <lambdabot>   [5]
22:38:22 <edwardk> > "hello"^..traverse.to toUpper
22:38:24 <notdan> > "hello"^..
22:38:25 <lambdabot>   "HELLO"
22:38:26 <johnw> what in the world does that mean?
22:38:26 <lambdabot>   <hint>:1:11: parse error (possibly incorrect indentation)
22:38:46 <notdan> > "hello"^..id
22:38:48 <lambdabot>   ["hello"]
22:38:57 <johnw> > "hello"^.traverse.to toUpper
22:38:58 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
22:38:59 <lambdabot>    arising from a use o...
22:39:05 <notdan> How the hell did it manage to do that?
22:39:07 <edwardk> ^.. gives back a list of all of the targets of a getter, fold, traversal, etc.
22:39:08 <johnw> > "hello"^..traverse.to id
22:39:10 <lambdabot>   "hello"
22:39:15 <johnw> ah, ^.. is an operator, ok
22:39:15 <notdan> edwardk: ah, thanks
22:39:21 <johnw> very cool
22:39:28 <notdan> edwardk: thought it was a composition on ^.
22:39:41 <edwardk> traverse.to toUpper   is a valid 'fold' which is like a getter with multiple targets
22:39:54 <johnw> > "hello"^.traverse.to id
22:39:54 * hackagebot twill 0.1.0.3 - Twilio API interaction  http://hackage.haskell.org/package/twill-0.1.0.3 (JosephAbrahamson)
22:39:54 <edwardk> :t traverse.to toUpper
22:39:56 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
22:39:56 <lambdabot>    arising from a use o...
22:39:56 <lambdabot> (Applicative f, Traversable t, Gettable f) => (Char -> f Char) -> t Char -> f (t Char)
22:39:58 <notdan> > "hello"^.to toUpper
22:40:00 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:40:00 <lambdabot>              with actual ty...
22:40:12 <notdan> > "hello"^.to length
22:40:15 <lambdabot>   5
22:40:26 <notdan> ok, idgi
22:40:33 <notdan> why doesnt ^.to toUpper doesn't work?
22:40:43 <edwardk> :t ("hello","!!!")^..both.to length
22:40:45 <lambdabot> [Int]
22:40:46 <shachaf> Because it'll operate on the whole list.
22:40:49 <edwardk> > ("hello","!!!")^..both.to length
22:40:51 <astropirate> Hello friends
22:40:51 <lambdabot>   [5,3]
22:40:54 <johnw> "hello"^.to length is monoidally combining 5 1 values, right?
22:41:01 <shachaf> @ty \f x -> x ^. to f
22:41:02 <notdan> shachaf: yeah, and "hello" is a list
22:41:02 <lambdabot> (t -> b) -> t -> b
22:41:05 <edwardk> > "hello"^.to (map toUpper)
22:41:07 <lambdabot>   "HELLO"
22:41:09 <astropirate> Who is looking for a good time?
22:41:13 <shachaf> notdan: Yes, and toUpper takes a Char, not a list.
22:41:16 <Ralith> johnw: of course not
22:41:18 <notdan> ah
22:41:21 <johnw> oh, guess not
22:41:21 <Ralith> johnw: length doesn't accept Char.
22:41:28 <johnw> yeah, i saw that after I typed it :(
22:41:29 <notdan> then why ^..to toUpper work then
22:41:31 <edwardk> johnw: no, "hello"^.to length is just applying the length function to the entire list
22:41:46 <shachaf> If you ever see "^.to" you can be sure that it's a little silly.
22:41:47 <notdan> :t (^..)
22:41:48 <edwardk> ^..traverse.to toUpper
22:41:49 <lambdabot> s -> Getting [a] s t a b -> [a]
22:41:49 <johnw> > "hello"^..to succ
22:41:51 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Char])
22:41:51 <shachaf> ^.to = %
22:41:52 <lambdabot>    arising from a use of `...
22:41:57 <edwardk> its not ^..to toUpper
22:42:02 <johnw> > "hello"^..to toUpper
22:42:04 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
22:42:04 <edwardk> the traverse. is the key tot hat working
22:42:04 <lambdabot>              with actual ty...
22:42:13 <notdan> Ah, yeah, fair enough
22:42:17 <shachaf> > "hello"^..folded.to toUpper
22:42:19 <lambdabot>   "HELLO"
22:42:19 <edwardk> > "hello"^..folded.to toUpper
22:42:22 <lambdabot>   "HELLO"
22:42:33 <notdan> > ("hello","world")^..id
22:42:35 <shachaf> It's a bit misleading because you're starting with a list and ending up with a list, but these lists are unrelated.
22:42:35 <lambdabot>   [("hello","world")]
22:42:40 <johnw> i still don't quite understand what folded does here
22:42:46 <shachaf> Unlike, say, (traverse %~ toUpper) "hello"
22:42:58 <johnw> > "hello"^..folded.to id
22:43:00 <lambdabot>   "hello"
22:43:03 <johnw> > "hello"^..to id
22:43:05 <lambdabot>   ["hello"]
22:43:09 <astropirate> You guys know of a thing called a REPL?
22:43:11 <johnw> > "hello"^.to id
22:43:13 <lambdabot>   "hello"
22:43:15 <johnw> ah
22:43:20 <edwardk> folded gives you a 'Fold' of any Foldable
22:43:25 <shachaf> > ("hello","there")^..both.folded.to toUpper -- example
22:43:28 <lambdabot>   "HELLOTHERE"
22:43:33 <edwardk> astropirate: i've heard rumors of such technology
22:43:35 <Cale> spaces pls
22:43:38 <notdan> What is the point of (^..) if we can just say x^.(\x -> [x])?
22:43:57 <johnw> astropirate: but IRC _is_ my REPL
22:44:02 <shachaf> It's actually getConst and (\x -> Const [x])
22:44:04 <edwardk> notdan:because what you just wrote doesn't work ;)
22:44:32 <shachaf> Cale: Spaces are for function composition. This is record access!
22:44:35 <shachaf> Totally different thing, man.
22:44:40 <Cale> grr
22:44:49 <edwardk> cale wants spaces, omits vowels. =P
22:44:52 <johnw> > ["h", "e", "l", "l", "o"]^.folded
22:44:54 <lambdabot>   "hello"
22:45:11 <johnw> is it doing something like foldMap id there?
22:45:12 <edwardk> ^. on a Fold will try to reduce it with a monoid.
22:45:13 <shachaf> I think the source of the confusion here is that lists are used for too many things.
22:45:19 <johnw> ah
22:45:23 <Cale> I'm sure shachaf has no problem with my vowels
22:45:30 <notdan> > ("hello","there")^..both.id
22:45:33 <lambdabot>   ["hello","there"]
22:45:41 <notdan> > ("hello","there")^..both
22:45:44 <lambdabot>   ["hello","there"]
22:45:48 <edwardk> in general foo.id = foo ;)
22:46:07 <notdan> > ("hello","there")^.both
22:46:09 <lambdabot>   "hellothere"
22:46:10 <johnw> sometimes I think the only way I'll ever really grok the usefulness of lens is to watch you guys golf with it here in channel ;)
22:46:30 <shachaf> @ty view.to
22:46:32 <lambdabot> (t -> b) -> t -> b
22:46:42 <shachaf> "exciting ways to write id"
22:46:50 <edwardk> shachaf: that law is in the docs i think
22:48:08 <shachaf> Aw, it gets eta-expanded.
22:48:14 <shachaf> Then again, I guess ($) is also eta-expanded.
22:49:07 <shachaf> Should I file a GHC issue for the constructor RULES thing?
22:49:48 <edwardk> notdan: you may have noticed that lens code tends to be a bit terse ;)
22:50:10 <JavaSucksMan> is there something I can put into my .ghci file to increase the ghci history?
22:50:27 * shachaf has lrwxrwxrwx 1 shachaf shachaf 9 Sep  6 15:26 .ghc/ghci_history -> /dev/null
22:50:29 <JavaSucksMan> I am triny to figure out how to call stifHistory Nothing
22:50:44 <JavaSucksMan> er.. stifleHistory
22:50:45 <statusfailed> @type both
22:50:47 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
22:51:14 <shachaf> edwardk: Did you see startling's failed attempt to make an isomorphism lens?
22:51:22 <shachaf> It's a bit unfortunate that some things type-check as lenses when they oughtn't.
22:51:23 <edwardk> shachaf: nope
22:51:33 <edwardk> shachaf: what did he do?
22:51:39 <notdan> edwardk: yeah, kinda :)
22:51:52 <JavaSucksMan> @shachaf  kind of want the opposite
22:51:52 <lambdabot> Unknown command, try @list
22:53:19 <shachaf> edwardk: https://gist.github.com/5cbb1119ae0cb2eb2a9f
22:53:39 <shachaf> I guess the confusion came from mixing up iso and isomorphic.
22:53:55 <shachaf> (And CPSing the function for no particular reason.)
22:53:58 <edwardk> yeah
22:54:32 <edwardk> isomorphic is more useful to you or me. iso and isos are the general purpose consumable form of it
22:54:46 <edwardk> > iso (+1) (subtract 1) 12
22:54:48 <lambdabot>   No instance for (GHC.Num.Num (f0 a0))
22:54:49 <lambdabot>    arising from a use of `e_11112'
22:54:49 <lambdabot>  P...
22:55:00 <edwardk> :t iso (+1) (subtract 1)
22:55:02 <lambdabot> (Functor f, Num a, Isomorphic k) => k (a -> f a) (a -> f a)
22:55:07 <edwardk> > isomorphic (+1) (subtract 1) 12
22:55:09 <lambdabot>   13
22:55:12 <edwardk> see even i screw it up ;)
22:55:20 <edwardk> > from (isomorphic (+1) (subtract 1)) 12
22:55:23 <lambdabot>   11
22:58:00 <notdan> Can someone please explain to me why view both ("Hello", "world") == "Helloworld"
22:58:19 <notdan> I thought that wouldn't typecheck, since both needs a function as an argument
22:58:24 <astropirate> Anyone recommend a comprehensive statistics package?
22:58:34 <johnw> astropirate: only most of the time
22:58:40 <astropirate> :p
22:58:54 <astropirate> I need names!
22:59:19 <edwardk> > view both (Sum 1, Sum 2)
22:59:21 <lambdabot>   Sum {getSum = 3}
22:59:34 <johnw> edwardk: good illustration
22:59:55 <edwardk> when you use view or (^.) on a fold, it can visit 0 or more targets. it needs something to generate them. it uses a monoid for this.
23:00:02 <johnw> edwardk: is list a free monoid?
23:00:16 <edwardk> johnw: it is the free monoid, yes =)
23:00:18 <shachaf> > (Sum 1, Sum 2)^..both
23:00:19 <lambdabot>   [Sum {getSum = 1},Sum {getSum = 2}]
23:00:20 <shachaf> > (Sum 1, Sum 2)^.both
23:00:24 <lambdabot>   Sum {getSum = 3}
23:00:27 <astropirate> about to use haskell for a very important project of mine. Make or break moment!!!
23:00:28 <johnw> there is only one?
23:00:41 <notdan> Hm, yeah,but both accepts a function and a pair, I can't really understand what's going on in there
23:00:44 <edwardk> consider the definition of free.
23:01:00 <johnw> i can build a free monoid out of a vector...
23:01:06 <edwardk> its left adjoint to a forgetful functor
23:01:16 <edwardk> adjoints are unique _up to isomorphism_
23:02:00 <edwardk> because we can use those leftAdjunct, rightAdjunct functions we worked through to convert between any two left adjoints to the same functor
23:02:52 <edwardk> notdan: are you familiar with 'traverse' from Data.Traversable?
23:04:39 <johnw> edwardk: how does that relate to the free monoid?
23:05:06 <notdan> edwardk: yes
23:05:12 <johnw> i thought "free" meant that is was not in any way forgetful
23:05:40 <johnw> so the free monoid preserves the meaning of all the elements that have been appended (aka, list)
23:05:46 <edwardk> johnw: the free functor is left adjoint to a forgetful functor. see my reply in https://plus.google.com/u/0/106871002817915335660/posts/g9LASrMjeFS
23:06:13 <edwardk> notdan: have you written instances of Traversable before?
23:06:36 <edwardk> data Foo a = Foo a a; instance Traversable Foo where traverse f (Foo a b) = Foo <$> f a <*> f b
23:06:45 <johnw> ok, but couldn't you have other thing *like* list that are also free monoids, like a vector?  Or maybe not, because I'd be losing the sizes of the appended vectors...
23:07:08 <ski> johnw : `[a]' is the free monoid over the set `a'
23:07:17 <johnw> edwardk: believe it or not, I was actually reading that again earlier today, and will keep reading it
23:07:36 <edwardk> johnw: you can store them however you like. the different choices are all isomorphic! ;)
23:07:37 <johnw> ski: interesting!
23:07:49 <johnw> edwardk: oh, i see what you mean then
23:07:54 <notdan> edwardk: not really, but i have an idea how to do that
23:07:59 <johnw> edwardk: list is just one expression of The Free Monoid
23:08:01 <ski> johnw : e.g. `Nat' is the free monoid over a singleton set
23:08:03 <notdan> I just don't understand how view is composed with both
23:08:12 <edwardk> notdan: both is a generalization of how you'd define 'traverse'
23:08:24 <johnw> edwardk: I thought you meant that [] _was_ "the free monoid", as in the only thing it could be
23:08:25 <edwardk> both f (a,b) = (,) <$> f a <*> f b
23:08:37 <notdan> a gneralization? But it works only on pairs
23:08:57 <edwardk> ok, it is an instantiation of a more general concept than traversable ;)
23:09:16 <notdan> Ok, so when we call 'view both ("hello","world")', which function and which pair is passed to both?
23:09:37 <edwardk> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
23:09:50 <edwardk> both is a 'Traversal'
23:09:54 <ski> `newtype Foo a = MkFoo (a,a)', `instance Traversable Foo where traverse f (MkFoo aa) = MkFoo <$> both f aa'
23:10:00 <edwardk> both :: Traversal (a,a) (b,b) a b
23:10:21 <edwardk> notdan: to figure out the function we need to know about Const. have you used it before?
23:10:24 <edwardk> :t Const
23:10:26 <lambdabot> a -> Const a b
23:10:31 <edwardk> :info Const
23:10:35 <edwardk> @info Const
23:10:35 <lambdabot> Const
23:10:42 <edwardk> @source Const
23:10:43 <lambdabot> Const not available
23:10:43 <shachaf> No :i in lambdabot. :-(
23:10:52 <edwardk> i can never remember how to use the src stuff
23:10:56 <edwardk> @src Const
23:10:57 <lambdabot> Source not found. You speak an infinite deal of nothing
23:10:59 <edwardk> bah
23:11:07 <edwardk> newtype Const a b = Const a
23:11:23 <edwardk> is a Functor. fmap _ (Const a) = Const a; right?
23:11:24 <notdan> It's like const, but for types?
23:11:41 <ski> aye
23:11:48 <edwardk> its also Applicative when 'a' is a Monoid.
23:12:17 <edwardk> instance Monoid a => Applicative (Const a) where pure _ = Const mempty; Const a <*> Const b = Const (mappend a b)
23:12:27 <edwardk> view uses 'Const'
23:12:47 <edwardk> view l = getConst . l Const
23:13:12 <edwardk> so f = Const a  in the above
23:13:24 <Nereid> johnw: list is the free monad because:
23:13:30 <Nereid> @type foldr mappend mempty
23:13:32 <lambdabot> Monoid b => [b] -> b
23:13:41 <edwardk> (a -> Const a b) -> (a,a) -> Const a (b,b)
23:13:42 <Nereid> and other things
23:13:50 <johnw> cool, thanks Nereid
23:13:55 <Nereid> er free monoid*
23:14:01 <edwardk> and the demand for Applicative requires 'a' to be a Monoid
23:14:29 <edwardk> so to 'view both' you need a Monoid on the element type of the pair and for both elements to have the same type.
23:14:38 <edwardk> :t view both
23:14:40 <lambdabot> Monoid a => (a, a) -> a
23:15:00 <johnw> :t view mapped
23:15:01 <lambdabot> (Functor f, Settable (Accessor a)) => f a -> a
23:15:03 <edwardk> :t getConst . both Const
23:15:05 <lambdabot> Monoid b => (b, b) -> b
23:15:10 <Nereid> johnw: to say that the free monoid functor is left adjoint to the forgetful functor is to say that
23:15:32 <edwardk> johnw: there is no instance of Settable Accessor. so that turns into an error when you use it as you'd expect
23:15:47 <Nereid> for an object a and a monoid m, there's an isomorphism between monoid morphisms [a] -> m and functions a -> m
23:15:56 <Nereid> (where the last m is the forgetful functor applied to the monoid m)
23:15:57 <edwardk> > getConst (both Const ("hello","world"))
23:15:59 <lambdabot>   "helloworld"
23:16:02 <Nereid> (and this isomorphism is natural)
23:16:15 <edwardk> > getConst (both Const (Sum 1,Sum 2))
23:16:17 <lambdabot>   Sum {getSum = 3}
23:16:48 <kallisti> @hoogle both
23:16:48 <lambdabot> System.Posix.Terminal BothQueues :: QueueSelector
23:16:48 <lambdabot> Network.Socket ShutdownBoth :: ShutdownCmd
23:16:48 <johnw> Nereid: yeah, I like 15% get that, and edwardk has worked through it all with me, but I'm still intuitionless about adjoints; I know enough to know that I really want to know them, so I'll just keep reading
23:16:57 <Nereid> heh
23:17:19 <johnw> and the forgetful functor is right adjoint to the free monoid, and nothing else?
23:17:19 <Nereid> but that's really all it means to have adjoints.
23:17:21 <ion> > runIdentity (_2 (Identity . length) ("foobar","baz"))
23:17:23 <lambdabot>   ("foobar",3)
23:17:31 <ion> > runIdentity (both (Identity . length) ("foobar","baz"))
23:17:33 <lambdabot>   (6,3)
23:17:39 <Nereid> johnw: adjoints are unique (up to natural isomorphism), yes.
23:17:55 <Nereid> if they exist.
23:18:11 <johnw> natural isomorphism means that for two natural transformations f and g, g . f = id?
23:18:12 <Nereid> because they can be defined in terms of a universal property.
23:18:21 <johnw> err, Identity
23:18:24 <Nereid> yeah, then f and g are natural isomorphisms.
23:18:26 <Nereid> no, not Identity.
23:18:35 <johnw> id?
23:18:39 <Nereid> yes
23:18:44 <Nereid> and f . g = id
23:18:49 <johnw> because id of a functor is that functor?
23:19:15 <Nereid> no, you're composing natural transformations.
23:19:20 <Nereid> functors are not natural transformations.
23:19:25 <johnw> ohh
23:19:29 <johnw> right
23:19:38 <johnw> they are morphisms that map between functors
23:20:00 <edwardk> ion: good eye, Const reads, Identity modifies
23:20:47 <Nereid> johnw: so the exercise is as follows:
23:20:50 <shachaf> Good eye, on.
23:20:57 <johnw> :)
23:21:01 <edwardk> type Setter s t a b = (a -> Identity b) -> s -> Identity t    -- would be a reasonable definition for a setter. (in practice its more complicated for other reasons in the library)
23:21:20 <edwardk> and you can see the connection to Functor when s = f a, t = f a
23:21:24 <shachaf> type Setter s t a b = (a -> b) -> s -> t -- would be a reasonable definition for a setter. (in practice its more complicated for other reasons in the library)
23:21:28 <Nereid> write functions f :: Monoid m => ([a] -> m) -> (a -> m), and g :: Monoid m => (a -> m) -> ([a] -> m), such that
23:21:31 <edwardk> shachaf: =P
23:22:06 <Nereid> g (f h) = h, and f (g k) = k if k is a monoid homomorphism
23:22:34 <Nereid> er
23:22:36 <Nereid> backwards.
23:22:42 <Nereid> swap f and g in that sentence.
23:22:44 <johnw> what is a "monoid homomorphism"?
23:23:06 <Nereid> f :: m -> n is a monoid homomorpism if f mempty = mempty and f x `mappend` f y = f (x `mappend` y)
23:23:13 <Nereid> (m, n Monoids)
23:23:41 <Nereid> the point is that
23:23:55 <Nereid> f and g give a bijection between monoid homomorphisms [a] -> m and functions a -> m
23:24:30 <Nereid> which proves that you have adjoints.
23:24:35 <johnw> meaning, they are isomorphic, right?
23:25:03 <Nereid> yes, the set of monoid homomorphisms [a] -> m is isomorphic to the set of functions a -> m
23:26:00 <Nereid> (and this isomorphism is natural in a and m. which means you have some extra conditions to check. but they're probably free.)
23:26:10 <Nereid> @free f :: ([a] -> m) -> (a -> m)
23:26:10 <lambdabot> h . k = p . $map g => h . f k = f p . g
23:26:30 <johnw> what does @free do?
23:26:40 <Nereid> writes you a free theorem
23:26:43 <statusfailed> There should be something like @pl but for rewriting your code with lenses :D
23:26:49 <edwardk> hah
23:26:55 <Nereid> lol
23:27:02 <pikhq_> @free f :: a -> a
23:27:02 <lambdabot> g . f = f . g
23:27:08 <johnw> there should be @edwardk, for rewriting any statement in category theoretic language
23:27:18 <edwardk> no, thats @dolio
23:27:26 <Nereid> @free g :: (a -> m) -> [a] -> m
23:27:26 <lambdabot> h . k = p . f => h . g k = g p . $map f
23:27:27 <johnw> oh, it's you too, buddy
23:27:29 <statusfailed> johnw: just use "edwardk:" :P
23:27:31 <edwardk> i just rewrite things in terms of my obsession of the moment.
23:28:02 <johnw> in a few years I'm going to read these chat logs again, and I'm going to slap my head and say "Oh, THAT was what he was talking about"
23:28:10 <statusfailed> hahah
23:28:50 <johnw> edwardk: how long does a typical moment last?
23:28:51 <statusfailed> @pl \x -> (x^._2, x)
23:28:51 <lambdabot> (line 1, column 12):
23:28:52 <lambdabot> unexpected '_'
23:28:52 <lambdabot> expecting simple term
23:29:06 <edwardk> obsession wise? 3-4 months
23:29:07 <statusfailed> eh
23:29:48 <johnw> i wouldn't mind a JSON lens
23:29:53 <statusfailed> @pl (\x -> (x ^. _2, x))
23:29:53 <lambdabot> (line 1, column 15):
23:29:54 <lambdabot> unexpected '_'
23:29:54 <lambdabot> expecting simple term
23:29:59 <edwardk> johnw: lens/examples/Aeson.hs
23:30:01 <johnw> so I don't have to fabricate nested records just to decode them into Haskell types
23:30:07 <johnw> edwardk: i don't even have words
23:30:13 <Nereid> lol
23:30:34 <edwardk> its right next to the brainfuck interpreter and the game of pong ;)
23:30:49 <statusfailed> If you can think of a cool project with haskell, edwardk has already implemented it
23:30:53 <edwardk> because every lens library needs a brainfuck interpreter. its how we show we're enterprise ready
23:31:49 <johnw> so, if I have {"json":{"edwardk":[{"obsession": "lenses"}]}}, how would I lens to the word "lenses"?
23:32:03 <edwardk> i don't remember. =)
23:32:46 <johnw> Aeson.hs doesn't actually do anything JSONy
23:32:49 <edwardk> apparently someone packaged better aeson lenses
23:32:50 <edwardk> http://hackage.haskell.org/packages/archive/aeson-lens/0.2.0.0/doc/html/Data-Aeson-Lens.html
23:32:53 <edwardk> neat
23:32:57 <edwardk> i didn't even have to write them
23:32:59 <johnw> sweet!
23:33:01 <Nereid> :D
23:36:18 <edwardk> v^.key "json".key "edwardk"^.nth 0^.key "obsession"
23:36:26 <edwardk> er
23:36:31 <edwardk> v^.key "json".key "edwardk".nth 0.key "obsession"
23:37:02 <sopvop> edwardk: what should I replace Data.Lens getL, setL, modL with when switching to Control.Lens?
23:37:15 <fenton> i'm trying to install an older version of ghc 7.4.2 on my bleeding edge arch, cause 7.6.1 was too new for compiling darcs against.  I'm coming to the conclusion that arch might not be the best linux platform to develop haskell on.
23:37:19 <edwardk> view, set, over
23:37:25 <sopvop> thanks
23:37:37 <fenton> but ghc wont even ./configure
23:37:41 <edwardk> or their infix versions. ^.  .~  and %~
23:37:49 <fenton> is life better over at gentoo?
23:38:10 <Nereid> works fine in gentoo :v
23:38:15 <ion> edwardk: I think demonstrating each lens function independently of anything else in lens might be a good way to introduce it. Starting with something like runIdentity ((\f (a,b) -> (,b) <$> f a) (Identity . length) ("foobar","baz")) and the Const equivalent and showing what’s going on, then using \f (a,b) -> (,) <$> f a <*> f b to demonstrate the power Applicative adds, and finally replacing the parts with
23:38:17 <ion> “_1”/“both”, “view”/“over” in separate steps might be clearer than starting with combinations of two lens functions whose respective type signatures are difficult to grasp at first.
23:38:17 <sopvop> fenton: What ./configure says?
23:38:27 <fenton> libgmp.so.3: cannot open shared
23:38:49 <fenton> libgmp.so.3 is old apparently
23:38:51 <sopvop> do you have libgmp installed? try makeing a symlink
23:39:24 <edwardk> ion: its a tricky balancing act. i'll definitely take patches with more examples though!
23:39:28 <fenton> if u read the web...many many people decry that solution, as the version i have is newer and in fact different...so could have coredumps etc...
23:39:45 <statusfailed> sopvop: oh hey, I took your advice on making my snaplet with HasRiak. Cheers :)
23:39:55 <statusfailed> it's much nicer that way
23:39:55 <fenton> Nereid: ok i'll give it a try in gentoo
23:39:56 <edwardk> the wiki has an examples page i paste into the README occasionally
23:40:35 <sopvop> fenton: You may try compiling ghc from source
23:41:44 <sopvop> fenton: or somehow install correct libgmp and add it to /etc/ld.so.conf or LD_LIBRARY_PATH
23:41:49 <ion> > (both (const . length) ("foobar","baz")) ()
23:41:51 <lambdabot>   (6,3)
23:42:30 <ion> > (both (++)) ("foobar","baz")) "?"
23:42:31 <lambdabot>   <hint>:1:29: parse error on input `)'
23:42:38 <fenton> sopvop: okay, I'll try compiling from source
23:42:38 <ion> > (both (++) ("foobar","baz")) "?"
23:42:40 <lambdabot>   ("foobar?","baz?")
23:48:46 <sopvop> I don't think we will hear fenton soon :)
23:56:22 <neutrino_> hi guys!
23:57:26 <mgsloan> status_failed: So, it's not exactly @pl for lenses, but I've got a WIP dsl for lens  (haven't worked on it in a while, just getting back to it recently).  It can be used like this: 1 == ((0, 1), "") ^. $(lense [e| (\((_, x), _) -> x) |] )
23:58:01 <fenton> well i need ghc to build ghc...so pacman 7.6.1, then build from source then remove 7.6.1?
23:58:03 <mgsloan> a little bit awkward, but it can also be applied to declarations.  For example, it can take the definition of last and make it into a lens
23:59:49 <sopvop> fenton: you don't need to remove it after, just install correct ghc somewhere and add it to front of PATH
