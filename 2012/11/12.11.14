00:00:06 <Saizan> coldpizza72i: also, we like to reserve the term monad for the type constructor, and call "(monadic) actions" the values of type M A where M is a monad
00:00:07 <coldpizza72i> Saizan: whats the difference between >> and >>= again?
00:00:12 <mm_freak> > foldl (+) 0 [2, 3, 7, 1]
00:00:14 <lambdabot>   13
00:00:17 <mm_freak> > scanl (+) 0 [2, 3, 7, 1]
00:00:18 <Axman6> @src (>>)
00:00:18 <lambdabot> m >> k      = m >>= \_ -> k
00:00:19 <lambdabot>   [0,2,5,12,13]
00:00:22 <Saizan> coldpizza72i: but it seems your professor doesn't stick to that either
00:00:53 <mm_freak> in particular foldl f z = last . scanl f z
00:01:01 <coldpizza72i> Saizan: he is just learning functional programming as he teaches us… and from over the summer what he learned
00:01:49 <Saizan> coldpizza72i: (m >> n) doesn't pass the result of m to n, as we can see from the @src (>>) above
00:21:55 <shachaf> So when are we getting Applicative-without-pure as a superclass of Applicative?
00:27:13 <mm_freak> shachaf: really?  you want (<*>) earlier than pure?
00:27:39 <shachaf> mm_freak: Yes.
00:27:52 <shachaf> I'm not sure what use pure on its own is.
00:27:57 <mm_freak> what's the point (lol)?
00:28:18 <shachaf> Applicative-without-pure : Applicative = Semigroup : Monoid
00:28:37 <mm_freak> true
00:29:13 <shachaf> A Traversal that used Applicative-without-pure would guarantee that it traverses at least one element.
00:29:14 <mm_freak> but i rather think that neither (<*>) nor 'pure' are very useful on their own
00:29:24 <mm_freak> i see
00:29:38 <shachaf> Well, Functor+(<*>) seems useful in the context of lens if nothing else.
00:29:52 <shachaf> It lets you combine two values, but not create values from scratch.
00:31:51 <mm_freak> what would you call that class?  Substitute?
00:32:02 <shachaf> edwardk calls it Apply
00:32:15 <shachaf> He has it in Data.Functor.Apply. :-)
00:32:31 <mm_freak> ah
00:35:33 <donri> is "point" in Pointed the same as in "pointfree"?
00:37:35 <pordan30> point or return inserts a value into a context: <http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Functor-Pointed.html>
00:38:15 <donri> i know what they *do*
00:39:02 <shachaf> What are the Pointed laws? :-)
00:39:41 <tomboy64> uhm
00:39:53 <tomboy64> how do i do multi-line input in ghci?
00:40:10 <donri> :{
00:40:14 <donri> :}
00:40:41 <donri> or :set +m
00:41:03 <tomboy64> thanks :)
00:42:05 <shachaf> What would be a name for an equivalent of "sell" for a single Store?
00:42:15 <shachaf> ? : sell = Store : Bazaar
00:42:29 <shachaf> Where a bazaar is a collection of stores.
00:42:29 <donri> tomboy64: or :e to edit in $EDITOR
00:43:08 <donri> trade!
00:43:19 <shachaf> Trade is taken.
00:43:27 <mm_freak> shachaf: fmap f (pure x) = pure (f x)…  that's the only law i can think of =)
00:43:28 <donri> of course it is ^_^
00:43:31 * shachaf wants to give this a name for consistency with Bazaar
00:43:51 <shachaf> (Also because it keeps confusing me.)
00:47:52 <pordan30> "sell" implies a transaction, so "vend" or "barter" could work. perhaps "hawk," but it doesn't fit the analogy as well.
00:48:18 <shachaf> I'd want something "smaller" than sell.
00:48:24 <shachaf> Because a Store is "smaller" than a Bazaar.
00:48:31 <donri> lend?
00:48:37 <donri> rent?
00:48:38 <shachaf> (Well, not necessarily. A bazaar could be empty. But anyway.)
00:49:38 <donri> deal?
00:50:28 <donri> shoplift! :)
00:52:54 <pordan30> a sale is a single transaction, and doesn't imply anything about the size of the location of the sale. you want a synonym for "to sell at one of several points of sale," if i understand. i'm coming up blank, but english.stackexchange is pretty good at this kind of stuff. :/
00:53:25 <donri> or make "sell" larger and use "sell"
00:53:29 <shachaf> data Coil :: * -> * -> * where { Coil :: Coil Top a; Snoc :: Coil h b -> {-# UNPACK #-} !Int -> SimpleLensLike (Bazaar a a) b a -> [b] -> (NonEmpty a -> b) -> [b] -> Coil (h :> b) a }
00:53:55 <Underbyte> hello #haskell
00:54:11 <Underbyte> is anyone up at this time of night?
00:54:30 <Pantoufle> It is not night in Europe
00:54:36 <Underbyte> hmm, thats weird... clients acting up :-/
00:54:55 <Underbyte> well would anyone care to help a newbie with a homework assignment?
00:54:56 <Underbyte> http://codepad.org/iIngR5Mu
00:55:15 <Underbyte> specifically, if you look at line 43-54, you can see what i'm trying to do
00:55:43 <shachaf> Underbyte: You should generally ask first rather than waiting for someone to say they're up. :-)
00:55:44 <Underbyte> its basically a pacman game, and i mapped out a lot of the discrete unctionality > 60
00:55:54 <Underbyte> indeed, good point shachaf
00:56:26 <Underbyte> problem is, that my code quickly became unworkable because i didn't have a unifying data transfer object that was common between all the functions
00:56:40 <Underbyte> so i'm trying to map out some common data elements to simplify the discrete logic steps
00:57:04 <Underbyte> what i'd like to do is have the Gamestate array (gameMap) contain gamePieces, but i'm having trouble getting array to play ball
00:57:10 <Underbyte> *Array to play ball
00:57:34 <Underbyte> Any suggestions?
00:59:19 <Underbyte> ....anyone?
01:01:09 <bartavelle> Underbyte, it is still early !
01:01:31 <Underbyte> haha no worries, I would _greatly_ appreciate any help
01:01:34 <Underbyte> no matter when it comes
01:02:48 <bartavelle> ok
01:02:57 <bartavelle> I am not very good, but I can try
01:03:10 <bartavelle> first, when I saw you used an array, I thought the index would relate to piece positions
01:03:20 <bartavelle> but you GamePiece type seems to contain the position
01:03:30 <bartavelle> is that expected ?
01:05:02 <bartavelle> I mean, what part of the assignment ?
01:05:06 <bartavelle> what is part
01:05:11 <shachaf> mm_freak: For example Control.Lens.Zipper is much more suited to nonempty traversals.
01:06:25 <bartavelle> everything over "YOUR CODE SHOULD COME AFTER THIS POINT", or are other data structures constrained ?
01:07:06 <Underbyte> the consequences is theirs
01:07:12 <Underbyte> everytihng else is mine
01:07:16 <bartavelle> ok
01:07:27 <Underbyte> rawInput is the raw map, but its not quite accurate.
01:07:32 <Underbyte> hold on, i'll show you the real raw input
01:07:35 <bartavelle> you wrote it ?
01:07:38 <bartavelle> ok
01:08:06 <Underbyte> http://codepad.org/VSjPLiav
01:08:46 <Underbyte> so the idea is to take that and to stick that into a "Game State" object that i can then pass back and forth between the heavy lifting functions
01:09:12 <Underbyte> because apparently we are allowed *no* procedural design patterns in the project, so we are forced to do russian-doll style workflow
01:09:35 <bartavelle> erm ok
01:09:36 <bartavelle> so
01:09:52 <bartavelle> do you have to use Array ?
01:10:05 <Underbyte> heh
01:10:11 <Underbyte> no
01:10:18 <bartavelle> ok, then
01:10:25 <Underbyte> i was actually suggested that by a member of this channel back on saturday
01:10:33 <bartavelle> depends on how to use it
01:10:41 <bartavelle> if you use it as a list, it is pointless
01:11:08 <Underbyte> supposedly the really nice things about arrays is that it's easy to get 2d coordinates, and its easy to replace items in the array
01:11:17 <bartavelle> yes ok
01:11:26 * bartavelle is looking at the code
01:11:37 <bartavelle> I will acutally read it instead of trying to guess what might be done
01:12:03 <bartavelle> but to start with, it is probably bad form to use Char instead of an algebraic data type
01:12:40 <Underbyte> where?
01:12:52 <bartavelle> pacman p = head (objectsMatching 'M' p)
01:12:54 <bartavelle> for example
01:13:08 <bartavelle> pacman p = head (objectsMatching PacMan p)   -- might be easier to read
01:13:14 * hackagebot falling-turnip 0.1.0.0 - Falling sand game/cellular automata simulation using regular parallel arrays.  http://hackage.haskell.org/package/falling-turnip-0.1.0.0 (TranMa)
01:13:16 * hackagebot certificate 1.3.2 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.2 (VincentHanquez)
01:13:32 <pordan30> can anyone help me modify this c function in the wxc source, in order to build wxc, so that this error message regarding ambiguous type conversions can be solved? i don't really know what i'm doing here. <http://hpaste.org/77711>
01:14:08 <bartavelle> also writing something like
01:14:09 <Underbyte> updated: http://codepad.org/L5GOyuk9
01:14:45 <Underbyte> well i want to make a GamePiece class that i can stick in the array, but the array wont let me
01:14:51 <bartavelle> ah
01:15:33 <Underbyte> Can i do that?
01:15:45 <bartavelle> it should complain about missing an impelmentation of Ix or something right ?
01:16:22 <pordan30> you probably don't want a gamepiece class, with one instance per gamepiece, because the elements of the array are homogeneous. you probably want an algebraic data type of game pieces: GamePiece = GamePiece1 | GamePiece2 | ..
01:17:08 <quicksilver> "you probably don't want a class" is the correct general rule to remember.
01:17:16 <bartavelle> it is not actually a class in his code, but it is true you do not need to have the coordinates in it
01:17:17 <Underbyte> so GamePiece = Pacman | Ghost | Wall | Border | Empty | etc etc etc
01:17:25 <bartavelle> yes
01:17:39 <bartavelle> you have coordinates from the index in the array
01:18:10 <bartavelle> actually now that the guys that can actually answer questions are up, I will let them ;)
01:19:01 <Underbyte> but i wouldn't be able to have GamePiece that includes the index as part of it?
01:19:09 <Underbyte> i figure that would be hany
01:19:10 <Underbyte> *handy
01:19:17 <bartavelle> why would you need this ?
01:19:30 <bartavelle> I mean
01:19:37 <bartavelle> it is in the array, which has the data you need
01:20:10 <Underbyte> because then i could just pull two GamePieces from the array and compare them seperately, away from the array itself
01:20:18 <Underbyte> if gamePiece1.location == gamePIece2.location, etc
01:20:24 <bartavelle> this can't happen
01:20:35 <bartavelle> because the position is encoded by the array index
01:20:45 <bartavelle> so you can't only have a single item at a specific position
01:20:48 <pordan30> pulling two gamepieces from the array entails knowing their coordinates in the game map!
01:21:40 <Underbyte> pordan30: no i know, i was hoping that if you could do that i would be able to write arguments that accepted GamePIece as an argument, as opposed to ((Integer, Integer), GamePiece)
01:22:05 <pauser> im having difficulty implementing timesNat (multiplication) . Do you guys maybe see the problem here http://hpaste.org/77713
01:22:52 <bartavelle> Underbyte, you probably do not need to do all of this. In order to check for colision you just check for what's at a specific location
01:23:00 <Jafet> Ah, the drunken quantum pawn manoeuvre
01:23:27 <pordan30> pauser: what in particular are you having trouble with? the recursive definition of multiplication, or the implementation?
01:23:38 <Underbyte> hmm, okay
01:23:40 <pauser> implementation
01:24:04 <bartavelle> Underbyte, a Map could fit your data model more easily perhaps ?
01:24:08 <Underbyte> Map?
01:24:10 <bartavelle> Map.Map Position GamePiece
01:24:19 <bartavelle> key-value store ?
01:24:21 <Jafet> pauser: ok, what is the recursive definition of multiplication
01:24:50 <pauser> a+b = a--, b++
01:25:07 <pauser> ah sorry
01:25:12 <bartavelle> that way, when you actually need [(Position,GamePiece)], you just Map.toList
01:25:12 <Underbyte> whats the difference between Map and Array?
01:25:14 <Jafet> wat
01:25:36 <bartavelle> an array is like a contiguous storage data structure
01:25:50 <bartavelle> a map is a key - value store, like a dictionnary in python ?
01:25:56 <Jafet> bartavelle: Array.assocs
01:26:00 <Underbyte> or Objective-C :)
01:26:06 <pauser> Jafet: a*b where a-- , b+b (java)  :D
01:26:07 <Underbyte> (my language of choice)
01:26:42 <Jafet> pauser: so 2+2 = 2--, 2++
01:26:47 <Jafet> I do not understand
01:27:08 <bartavelle> Jafet, ah yes !
01:27:20 <pauser> yes, util a gets 0
01:27:30 <pauser> *until
01:27:57 <Underbyte> how difficult is it to refactor this array jazz into Map
01:28:23 <bartavelle> I am not sure this is important actually ... just a suggestion
01:28:24 <Jafet> Ok, your instructor or tutor needs to decontaminate your mind from "java"
01:28:27 <Jafet> But until then
01:28:36 <Jafet> Try the "a-- b+b" on an example
01:28:41 <Jafet> It is not correct
01:29:30 <pauser> thats what i did here : timesNat (S x) (S y) = timesNat x (plusNat (S y)  (S y) ) , (i think , i did :))
01:29:42 <Underbyte> bartaville: one of the problems i see is constructing the map from the raw informatino
01:30:31 <pordan30> pauser: you only need to recurse on one argument in order to define multiplication. think: what is zero multiplied by a number, and what is a nonzero number multiplied by a number.
01:31:18 <pauser> timesNat Z (S y) = Z, thats zero for me and nonzero timesNat (S x) (S y) = timesNat x (plusNat (S y)  (S y) )
01:32:47 <bartavelle> Underbyte, the trick is knowing the coordinate of the each piece of the raw input as you parse it. You might use `map` and `zip` to associate each char with its coordinate.
01:33:01 <Underbyte> :-S
01:33:03 <bartavelle> > zip "AZRACAFQC" [1..]
01:33:05 <lambdabot>   [('A',1),('Z',2),('R',3),('A',4),('C',5),('A',6),('F',7),('Q',8),('C',9)]
01:33:16 <Jafet> pauser: that is not multiplication
01:33:43 <shachaf> type Nat = forall a. (a -> a) -> a -> a
01:33:45 <atriq> Jafet, that's the second time this minute I've joined a channel just as you've said something worrying
01:33:52 <shachaf> times n m = \f z -> n (m f) z
01:34:11 <Jafet> atriq: I blame (java)  :D
01:34:14 <pordan30> pauser: n * 0 is 0 for /all/ natural numbers n, not just positive ones. similarly, n * S m = n + (m * n) for /all/ natural numbers n and m. you don't need to bother destructing the first argument,.
01:36:30 <sipa> pordan30: all natural numbers, not just positive ones is a tautology :)
01:36:36 <Underbyte> bartavelle: how would you zip a 2d array though?
01:36:51 <pordan30> sipa: nonzero: my bad
01:37:12 <sipa> </pedant>
01:37:44 <Jafet> I hear some zeroes are made in the laboratory.
01:37:58 <pordan30> unless by positive you mean greater than zero, which is a pretty common definition, as far as i know
01:39:56 <bartavelle> Underbyte, with map and zip ;)
01:40:03 <bartavelle> and it's not an array, it is a list of list
01:40:10 <Underbyte> right
01:40:15 <Underbyte> PM
01:43:15 * hackagebot certificate 1.3.3 - Certificates and Key Reader/Writer  http://hackage.haskell.org/package/certificate-1.3.3 (VincentHanquez)
01:44:49 <pordan30> does anyone know how to safely fix this ambiguous type error, or should i ask in a language-appropriate channel? <http://hpaste.org/77711>
01:45:57 <Jafet> error: conversion from ‘int’ to ‘const wxBitmap’
01:46:12 <Jafet> I think that is a more accurate error
01:47:37 <pordan30> do you mean that it is more accurate to report the error as an ambiguous type conversion error, or that the error is more accurate than the output that i pasted?
01:49:39 <Jafet> I think the error should be cut to that
01:50:41 <pordan30> for anyone interested: there are lots of posts on the internet about wxc failing because wx-config fails on debian-based distros that are unanswered. the problem seems to be that aptitude grabs wxwidgets 2.8, and hasn't been updated for a while.
01:51:41 <Jafet> What's so great about 2.9 then
01:51:41 <pordan30> Jafet: thanks; i'll do that
01:52:00 <pordan30> no clue
01:52:11 <Sonderblade> interesting -> http://news.ycombinator.com/item?id=3065672
01:52:15 <Jafet> Presumably the person who wrote that code expected getStipple to be a bitmap
01:52:32 <Jafet> Why not just use 2.8 then
01:52:54 <Jafet> No, Haskell is not The Cure
01:53:01 <Jafet> Please do not hold this misconception
01:53:53 <atriq> Isn't the Cure a band?
01:54:20 <Jafet> Yes. Haskell is not a band.
01:54:30 <Jafet> Although Glasgow Haskell sounds like not a bad name for a band
01:55:02 <pordan30> Jafet: the source for the setup file seems to indicate that 2.9 is required, so that would be the primary reason
01:55:18 <georg_os> Hello there. I'm trying to create something like symmetric group S3 and permutation in it. I have some qustion
01:55:25 <georg_os> s
01:55:30 <Jafet> You can attempt to use an older version of the library.
01:56:43 <Jafet> I have some answers
01:56:49 <georg_os> let s3 = [[x,y,z]| x<-ms,y<-ms,z<-ms,x/=y,y/=z,z/=x] where ms = [1..3]
01:57:11 <georg_os> And then I want to compose two permutations:
01:57:19 <Jafet> > permutations [1..3]
01:57:21 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
01:58:09 <georg_os> let mul x y = [s3 !! y !! s3 !! x !! i|i<-[0..2]]
01:59:07 <georg_os> so I have an error with types: [Int] and [Integer]
01:59:17 <Jafet> :t (!!)
01:59:20 <lambdabot> [a] -> Int -> a
01:59:21 <Jafet> :t genericIndex
01:59:23 <lambdabot> Integral a => [b] -> a -> b
01:59:27 <Jafet> Try that
01:59:57 <pordan30> import Prelude hiding ((!!)); (!!) = Data.List.genericIndex for ease of use
02:03:00 <Jafet> permute p1 p2 = map snd $ sort $ zip p1 p2
02:09:19 <Underbyte> how do i modify a data object?
02:09:34 <Underbyte> say i wanted to increment a integer property within a data object by one
02:10:15 <shachaf> You don't mutate an object, you create a new modified object.
02:10:21 <shachaf> (I'm not sure whether that's what you meant or not.)
02:10:57 <Underbyte> hold on, let me codepad what i have
02:13:35 <Underbyte> shachaf: http://codepad.org/84TlM6LV
02:14:23 <Underbyte> is there some syntatic sugar i can use on line 159 that says "New object = old object except for this one modified property"
02:14:30 <Underbyte> err, 160
02:14:49 <shachaf> Sort of.
02:14:56 <shachaf> You can use lenses.
02:15:10 <shachaf> > set _2 "hello" (1,2,3)
02:15:12 <lambdabot>   (1,"hello",3)
02:15:13 <shachaf> > view _2 "hello" (1,2,3)
02:15:15 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2
02:15:15 <lambdabot>                      [GHC.Types...
02:15:19 <shachaf> Er.
02:15:20 <shachaf> > view _2 (1,2,3)
02:15:22 <lambdabot>   2
02:15:59 <shachaf> > set (_1._2) "hello" ((1,2),(3,4))
02:16:02 <lambdabot>   ((1,"hello"),(3,4))
02:16:11 <shachaf> > view (_1._2) ((1,2),(3,4))
02:16:13 <lambdabot>   2
02:16:26 <shachaf> This is provided by a library, though, not part of the language.
02:17:00 <Underbyte> :-/
02:17:14 <shachaf> > let up = (_2 +~ 1) in up (10,20)
02:17:16 <lambdabot>  Terminated
02:17:18 <shachaf> > let up = (_2 +~ 1) in up (10,20)
02:17:21 <lambdabot>   (10,21)
02:17:39 <shachaf> Anyway I'm not quite sure what question you're asking.
02:17:55 <donri> for records like GameState you can use record update syntax like, someGameState { level = level someGameState + 1 } to increase the "level". lenses make this more beautiful though.
02:17:55 <shachaf> There are probably nicer ways to rewrite your code that don't involve lenses, but I don't know what you're trying to do. :-)
02:18:26 <Underbyte> okay
02:18:27 <Underbyte> http://codepad.org/JwKzDKK9
02:19:00 <shachaf> You keep pasting these 200-line things.
02:19:20 <Underbyte> see how, for example, IncremetCounters is operating on GameState? i want to change one element in the gameState
02:19:24 * shachaf can't comment on all of it. :-)
02:19:53 <bartavelle> = gamestate { field = value } at line 160
02:19:54 <shachaf> Underbyte: You can use record-modification syntax.
02:20:04 <Underbyte> haha, seriously?
02:20:21 <Underbyte> so = gameState {lives = -1}
02:20:25 <Underbyte> or what have you
02:20:26 <bartavelle> well
02:20:44 <bartavelle> = gameState { lives = lives gameState - 1 }
02:24:01 <donri> > first pred (2,3)
02:24:03 <lambdabot>   (1,3)
02:24:09 <donri> > second succ (2,3)
02:24:10 <lambdabot>   (2,4)
02:24:35 <donri> you can this for your left/right/up/down functions
02:24:44 <donri> import Control.Arrow (first, second)
02:25:07 <pordan30> huh, wxcore is giving errors about newtypes in ffi imports. i thought that was a pretty old problem. it looks like it hasn't been updated in a long time. :/
02:25:21 <donri> Underbyte: ^ that was for you btw
02:25:50 <Nereid> > first chr (52,True)
02:25:52 <lambdabot>   ('4',True)
02:25:53 <pordan30> if you don't want to use lenses or arrows, and so forth, there's nothing wrong with defining boilerplate modification functions: modifyMyStuff f (LotsOfStuff ... myStuff ...) = LotsOfStuff ... (f myStuff) ...
02:25:59 <Underbyte> theres no acutal arrows tho donri
02:26:09 <Underbyte> its literally in the data payload the moves that are going to happen
02:26:17 <Underbyte> we get graded on weather or not we pass a testcase
02:26:57 <donri> i'm just saying, those two functions do the same as your coord functions
02:27:03 <Underbyte> really?
02:27:35 <donri> yes. first pred = decrement the first item in the pair
02:27:37 <donri> etc
02:27:54 <Nereid> > over _1 pred (3,6)
02:27:56 <lambdabot>   (2,6)
02:28:42 <Underbyte> > _1
02:28:43 <lambdabot>   Ambiguous type variables `s0', `t0', `a0', `b0' in the constraint:
02:28:44 <lambdabot>    (Cont...
02:28:45 <Underbyte> what is _1?
02:29:05 <Underbyte> > up _1 pred (3,6)
02:29:05 <donri> ...or use lenses, yea. then it works for up to 9-tuples, which would be useful for your triples in incrementCounters. but then you need to learn some lenses ;)
02:29:07 <lambdabot>   The function `Control.Lens.Zipper.up'
02:29:07 <lambdabot>  is applied to three arguments,
02:29:07 <lambdabot>  but ...
02:29:38 <Underbyte> > down _1 pred (3,6)
02:29:40 <lambdabot>   The function `Control.Lens.Zipper.down'
02:29:40 <lambdabot>  is applied to three arguments,
02:29:40 <lambdabot>  bu...
02:29:40 <donri> > (2,3) % _1 -~ 1
02:29:42 <lambdabot>   (1,3)
02:29:42 <Underbyte> :(
02:29:43 <Jafet> :t betwixt
02:29:45 <lambdabot> Not in scope: `betwixt'
02:29:51 <aetcore> > (* 2 4)
02:29:53 <lambdabot>   *Exception: show: No overloading for function
02:30:04 <aetcore> awww
02:30:20 <Underbyte> okay, first things first though...
02:30:21 <Underbyte> http://codepad.org/G2jbODSp
02:30:30 <Underbyte> in line 88
02:30:31 <Jafet> aetcore: {-# LANGUAGE HIPPIE #-}
02:30:38 <Underbyte> i'm trying to convert a list of lists into an array
02:30:44 <georg_os> Thanks a lot!
02:31:06 * shachaf wonders whether an array is really what Underbyte wants.
02:31:07 <Underbyte> for the acutal value stored in the array elements, right now its a char. How do i change this to a GamePiece? keeping in mind that i have a gamePieceFromChar function
02:31:16 <Underbyte> its seriously too late to change it now i fear
02:31:18 <aetcore> Jafet: i was just trying to be in the cool crowd
02:31:28 <Underbyte> i believe an array will work
02:32:36 <fmap> :t (* 2 4)
02:32:38 <lambdabot> Num a => a -> a
02:33:07 <fmap> > (* 2 4) 5
02:33:09 <lambdabot>   10
02:33:23 <aetcore> ahh, any documentation on the lambda bot?
02:33:30 <aetcore> he seems a lot cooler than hubot lol
02:33:33 <donri> @help
02:33:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
02:33:35 <Jafet> > 2 4
02:33:37 <lambdabot>   2
02:33:39 <donri> @list
02:33:39 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
02:33:44 <aetcore> ty
02:33:46 <quicksilver> there is some documentation, but it won't explain how (* 2 4) works.
02:33:55 <donri> @hackage NumInstances
02:33:55 <lambdabot> http://hackage.haskell.org/package/NumInstances
02:34:16 <Underbyte> >mapArray t = listArray ((0,0),((genericLength (t !! 0) - 1),(genericLength t) - 1)) (gamePieceFromChar (concat t)) :: GameMap
02:34:22 <Underbyte> specifically
02:34:25 <Underbyte> thats not working
02:34:40 <bartavelle> t!!0 should not work
02:34:45 <bartavelle> or does it ?
02:34:55 <bartavelle> ah it does
02:34:59 * bartavelle learns something every day
02:35:19 <Underbyte> can i not do listArray with any type?
02:35:21 <bartavelle> t :: [String] right ?
02:36:36 <Botje> Underbyte: the types of your indices must have an Ix instance.
02:36:48 <Underbyte> huh?
02:36:48 <Botje> you're free to choose the type of your values.
02:36:51 <Underbyte> oh
02:36:52 <Underbyte> i see
02:36:56 <Underbyte> hmmm
02:37:21 <Botje> but numbers are generally okay for Ix
02:37:26 <Botje> unless you're using floats ..
02:40:17 <Underbyte> <interactive>:164:25:
02:40:18 <Underbyte>     Couldn't match expected type `[e0]'
02:40:18 <Underbyte>                 with actual type `(a0 -> b0) -> [a0] -> [b0]'
02:40:18 <Underbyte>     In the second argument of `listArray', namely `map'
02:40:18 <Underbyte>     In the expression:
02:40:18 <Underbyte>       listArray ((0, 0), (1, 2)) map (gamePieceFromChar "GGBGBB")
02:40:19 <Underbyte>     In an equation for `it':
02:40:28 <Underbyte>         it = listArray ((0, 0), (1, 2)) map (gamePieceFromChar "GGBGBB")
02:40:29 <Underbyte> weird...
02:40:29 <Underbyte> (sorry about pastespam)
02:40:41 <Botje> Underbyte: can you put the entire code + error on hpaste instead?
02:40:56 <Botje> pasting to channels is not very useful because it scrolls off the screen
02:41:02 <donri> @where hpaste
02:41:03 <lambdabot> http://hpaste.org/
02:41:24 <bartavelle> Underbyte,
02:41:34 <bartavelle> your GameMap is not a data, it is a type
02:41:52 <Underbyte> http://hpaste.org/77714
02:41:55 <Ralith> and 'map' is a Prelude function
02:42:16 * Underbyte stares blankly
02:42:51 <Underbyte> *Main> map gamePieceFromChar "GGBGGB"
02:42:51 <Underbyte> [Ghost,Ghost,Border,Ghost,Ghost,Border]
02:42:54 <Underbyte> that works fine
02:43:19 <Underbyte> listArray is expecting a list, isn't it?
02:43:32 <quicksilver> Underbyte: you are passing 'map' as a function to listArray
02:43:32 <fmap> looks like monomorphism restriction
02:43:35 <mapf> :t Data.Array.listArray
02:43:37 <lambdabot> Ix i => (i, i) -> [e] -> Array i e
02:43:48 <quicksilver> you want listArray ((0,0),(1,2)) (map .....)
02:43:49 <mapf> and bounds
02:43:58 <quicksilver> not listArray ((0,0),(1,2)) map ....
02:44:16 <bartavelle> Underbyte, your problem is that you defined GameMap as a "data" instead of a type synonym, and you lack the "map gamePieceFromChar" in your original paste
02:44:19 <donri> s/he's doing it right in the paste
02:44:25 <quicksilver> oh, sorry
02:44:43 <bartavelle> mapArray t = listArray ((0,0),(genericLength (head t) - 1,genericLength t - 1)) (map gamePieceFromChar (concat t))
02:44:44 <bartavelle> is right
02:44:45 <Botje> Underbyte: try specifying the type: listArray ... :: Array Int GamePiece. that should give a better error
02:45:18 <bartavelle> Botje, he already defined this type as GameMap, but as a "data" instead of an actual type
02:45:51 <bartavelle> same for MapLocation
02:45:59 <bartavelle> unless you really want an Ix constructor ?
02:47:31 <donri> you sure you need IArray? have you tried importing only Data.Array?
02:48:44 <bartavelle> Underbyte, your data MapLocation makes no sense
02:48:48 <bartavelle> you probably wanted to have
02:48:55 <bartavelle> type GameLocation = (Integer, Integer)
02:49:12 <bartavelle> and the type of "toAssocs" (which is useless, as it is just assocs) is
02:49:15 <bartavelle> toAssocs :: GameMap -> [(MapLocation, GamePiece)]
02:49:26 <quicksilver> I think that bombarding Underbyte with successive (although foo) pieces of advice with no response from him is not currently useful :)
02:49:34 <bartavelle> true
02:49:41 <quicksilver> I suggest we wait to see which particular problem he hits next.
02:49:46 <quicksilver> s/foo/good/; # bizarre typo
02:51:09 <bartavelle> that's because you are an experienced haskeller, and very expert one would just have written "a"
02:53:49 <Underbyte> sorry, was coding stuff
02:58:50 <Underbyte> http://hpaste.org/77715
02:58:55 <Underbyte> okay, trying to get the filter right
02:59:20 <mapf> pff, i forget how to run ReadP
02:59:35 <Underbyte> quicksilver: meep
03:00:38 <donri> Underbyte: you forgot to pass it the list
03:00:40 <sopvop> you kind of forgot to supply input
03:00:42 <pordan30> the type of filter is: filter :: (a -> Bool) -> [a] -> [a]. the error message is telling you that filter (\myMap -> snd myMap = Food) is a function from [(a, GamePiece)] to [(a, GamePiece)], which it is. try giving it something to work with
03:00:44 <int-e> @type Text.ParserCombinators.ReadP.readP_to_S
03:00:46 <lambdabot> Text.ParserCombinators.ReadP.ReadP a -> ReadS a
03:00:59 <Underbyte> heh
03:01:15 <mapf> int-e: thanks
03:02:20 <pordan30> also, \x -> snd x = y is (y =) . snd, which you can see more easily by writing it \x -> y = snd x
03:02:37 <Underbyte> sorry guys, i'm not thinking straight
03:02:48 <Underbyte> i'm a little nervous about the time. i think i need to go outside and have a cigarette
03:02:49 <Underbyte> http://codepad.org/fGwHnRSA
03:02:57 <int-e> pordan30: probably not helpful yet :)
03:04:10 <int-e> Underbyte: you have to convert the array to a list - do you mean (assocs myMap) ?
03:04:30 <int-e> Underbyte: rather than just myMap
03:04:34 <Underbyte> aah
03:04:40 <shachaf> Let's say I have a zipper like data Foo a = Foo [a] a [a]
03:04:47 <Underbyte> haha derp
03:04:57 <Underbyte> thanks int-e, pordan30, etc etc
03:05:00 <Underbyte> you guys are the best
03:05:00 <shachaf> If I want to generalize it to data Foo x a = Foo [a] x [a], that stops me from doing a bunch of things, right?
03:05:06 <shachaf> I can't make a Comonad instance for that, for example.
03:06:07 <atriq> instance (a ~ x) => Comonad (Foo a x)?
03:06:12 <atriq> Do constraints work like that?
03:06:16 <quicksilver> yes, but no
03:06:17 <shachaf> atriq: That has the wrong kind.
03:06:23 <atriq> Ach
03:06:30 <quicksilver> constraints can do that but the problem is that Comonad needs exaclty one trailing parameter
03:06:42 <shachaf> I guess I can do data Foo f a = Foo [a] (f a) [a]
03:06:43 <quicksilver> you have to newtype WrappedFoo a = Foo a a
03:06:50 <shachaf> And then instance Comonad (Foo Identity) or so
03:07:02 <shachaf> Probably not worth it.
03:07:05 <atriq> shachaf, and Foo (Const x) gets what you had before?
03:08:01 <shachaf> Right.
03:08:26 <atriq> Anyway, I'm happy because I just found a library that contains PRECISELY what I was looking for
03:08:37 <atriq> Now to remember why I was looking for it...
03:09:07 <Underbyte> int-e http://codepad.org/B6EGvSoU
03:09:11 <Underbyte> also shachaf and etc
03:09:35 <Underbyte> grr, stupid codepad
03:09:53 <bartavelle> Underbyte, this is wrong : data GameMap = Array (Integer, Integer) GamePiece deriving (Show, Eq)
03:10:22 <bartavelle> this declares a new type (GameMap), with a constructor named Array that takes a pair of integers and a GamePiece as parameters
03:10:28 <Underbyte> Aah.
03:10:32 <Underbyte> what shoud i have it as
03:10:43 <bartavelle> type GameMap = Array (Integer, Integer) GamePiece
03:11:05 <bartavelle> same for MapLocation, except what you wrote makes no sense to me, so I am not sure of your original intent
03:11:24 <hpaste> Underbyte pasted “error” at http://hpaste.org/77716
03:11:36 <Underbyte> right, leksah just blew up
03:11:51 <Underbyte> maplocation is supposed to represent a spot on the map
03:11:53 <Underbyte> and whats in it
03:12:05 <bartavelle> type MapLocation = (Integer, Integer) then
03:13:13 <Underbyte> shoudn't it be MapLocation = (Integer, Integer) GamePiece?
03:13:33 <quicksilver> ((Integer,Integer),GamePiece)
03:13:38 <quicksilver> if I understand your code correctly
03:13:50 <quicksilver> but I still don't understand why you're making the gamepiece part of the index
03:14:00 <quicksilver> this is quite possible and legal but does it make sense?
03:14:43 <Underbyte> the map location is one of the cells of the map if you will
03:14:59 <Underbyte> perhaps MapCell would be a better word
03:15:35 <bartavelle> well
03:15:44 <bartavelle> IF you do  type MapLocation = (Integer, Integer)
03:15:55 <bartavelle> then
03:15:58 <bartavelle>  toAssocs :: GameMap -> [(MapLocation, GamePiece)]
03:16:03 <bartavelle> which is probably saner
03:16:59 <Underbyte> but i reference MapLocation a whole bunch of other places
03:17:11 <bartavelle> yes :)
03:17:21 <bartavelle> type MapCell = (MapLocation, GamePiece)
03:17:37 <bartavelle> probably makes more sense to have the location represent just the location
03:20:07 <hpaste> Underbyte pasted “updated program” at http://hpaste.org/77717
03:20:28 <Underbyte> okay, still having problems with that filter statement
03:20:58 <Underbyte> on line 84
03:21:06 <sordina> Hey guys. What's the standard matrix library with compile-checked dimensions at the moment?
03:21:30 <Underbyte> damnit
03:21:35 <Underbyte> i found the issue
03:21:54 <sopvop> does cabal strip symbols from executable when installing?
03:23:21 <sopvop> yup, it does.
03:23:51 <sopvop> If anyone wonders why I asked instead of checking, I don't know why.
03:25:07 <hpaste> Underbyte pasted “No Errors Yay” at http://hpaste.org/77718
03:25:16 <Underbyte> yay, no more errors
03:25:29 <sopvop> Congratulations!
03:25:44 <sopvop> partOneOutput pac = do     print pac -- do is not needed
03:26:15 <bartavelle> Underbyte, does it do what you want now ?
03:26:53 <bartavelle> (also your objectAt function should not be done like that. If you use "assocs" all the time it probably means you just needed a list, not an Array)
03:26:56 <Underbyte> not quite, but the errors on the low level stuff are gone, which means i refactored everything correctly
03:27:27 <sopvop> Refactoring is when it works before and after ;)
03:27:45 <delamonpansie> hello, can somebody help me with gtk2hs ?
03:28:00 <sopvop> delamonspansie: Maybe.
03:28:28 <atriq> delamonpansie, installing or using?
03:28:44 <delamonpansie> atriq: using
03:28:59 <latermus1> :)
03:29:09 <atriq> Then not I, although I anticipate answers hopefully
03:29:48 <delamonpansie> how cat i monitor FileChooserButton ?
03:30:07 <delamonpansie> it has no events attached
03:30:15 <Peaker> cabal clean && cabal configure --enable-{library,executable}-profiling && cabal build && dist/.../myexec +RTS -p    complains my exec was built without "-prof" :(
03:32:03 <typoclass> delamonpansie: i'm not familiar with gtk, but i bet a FileChooserButton inherits from another class (might be called Button). i bet a FileChooserButton can do everything and has all the events that a Button has
03:32:31 <sopvop> it implements FileChooser, so I think you should look there. http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-Selectors-FileChooser.html#t:FileChooser
03:33:27 <delamonpansie> yep. unfortunatly they don't implement that signal either
03:34:30 <sopvop> As I understood it, you should use `toFileChooser button` to get FileChooser, and use it for whatnot
03:34:49 <delamonpansie> sopvop: indeed.
03:35:00 <sopvop> oh
03:35:02 <sopvop> I got it :)
03:35:49 <delamonpansie> sopvop: but there is no signal "user has selected file" in FileChosser either :(
03:36:09 <sopvop> have you checked how it works with C gtk?
03:36:12 <hpaste> Underbyte pasted “newError” at http://hpaste.org/77719
03:36:45 <delamonpansie> sopvop: gtk exports  "file-set" signal for file_chooser_button
03:36:54 <Underbyte> http://pastie.org/5376597 the error
03:37:10 <delamonpansie> http://developer.gnome.org/gtk/2.24/GtkFileChooserButton.html
03:37:18 <sopvop> Maybe there is some generic way to attach callback to event by name?
03:37:33 <delamonpansie> i have this:
03:37:33 <delamonpansie> onFileSet :: FileChooserClass self => self -> IO () -> IO (ConnectId self)
03:37:33 <delamonpansie> onFileSet obj act = connectGeneric "file-set" False obj (failOnGError act)
03:37:51 <delamonpansie> this kinda work on linux. but crashes miserably on windows
03:38:10 <delamonpansie> and here i stuck :(
03:39:41 <Underbyte> couldn't match type [t0] with MapLocation
03:39:42 <Underbyte> any ideas?
03:40:26 <sopvop> Underbyte you feed single item to something expecting a list
03:41:05 <sopvop> what is the type of `location (pacman m)`?
03:41:32 <Underbyte> pacman :: GameMap -> MapCell
03:41:39 <Underbyte> pacman p = head (objectsMatching Pacman p)
03:41:53 <sopvop> also, please post relevant bit of code along with error
03:42:05 <Underbyte> http://hpaste.org/77719
03:42:14 <Underbyte> error is http://pastie.org/5376597
03:42:33 <Nereid> you are encouraged to put the code and the error in the same paste
03:42:36 <sopvop> that's quie a large bit :)
03:42:41 <sopvop> quite
03:43:11 <Nereid> anyway, when you write pac <- something
03:43:11 <sopvop> That is a list comprehenson, `[ pac == gho | pac <- location (pacman m), gho <- locations (ghosts m) ]`
03:43:14 <Nereid> it's expecting something to be a list
03:43:21 <sopvop> Right
03:43:22 <Underbyte> oh ok
03:43:36 <Nereid> if you want, you can write "let pac = location (pacman m)"
03:43:40 <Nereid> instead of that <- thing
03:44:18 <Nereid> isDead m = location (pacman m) `elem` locations (ghosts m)
03:45:03 <Nereid> it seems silly to define locations = map location and then use it only once
03:45:10 <Nereid> why not just write map location where you use it?
03:45:14 <Peaker> hmm.. I can't get cabal 1.16.0.{1,2} to build my executable with profiling support
03:45:44 <Underbyte> sopvop: cool. new warning, hold on
03:45:58 <Underbyte> http://pastie.org/5376627
03:46:24 <shachaf> Peaker: What's going wrong?
03:46:41 <shachaf> You have to configure with executable profiling, presumably.
03:46:42 <Nereid> Underbyte: it is as the warning says
03:46:49 <Peaker> shachaf, I run "cabal clean && cabal configure --enable-{library,executable}-profiling && cabal build && dist/.../myexec +RTS -p"   and the last cmd complains my exec was built without "-prof" :(
03:47:04 <Nereid> Underbyte: maybe you meant to write gameState instead of GameState
03:47:10 <shachaf> Peaker: What does cabal build -v say?
03:47:10 <sopvop> gameState { score = score gameState + 10} -- ugly records, if you want to update, use this syntax
03:47:13 <Peaker> and I see that my executable obj's are being built as .o and not .p_o
03:47:27 <Underbyte> derp
03:47:35 <Nereid> (if lens: gameState % score +~ 10
03:47:37 <Peaker> running with -v now
03:48:02 <Peaker> shachaf, I have a Library and an Executable in my .cabal -- the library is built both ways
03:48:20 <Peaker> the executable is built without -prof
03:48:35 <sopvop> Nereid: and barely understandable errors :)
03:48:37 <Peaker> -v just shows me the ordinary --make cmd and it has no -prof in it
03:48:50 <Underbyte> okay, I only have one real nasty bit remaining, and thats actually moving the "pacman" from one cell to another. The data map should change such that where he moves from should be empty, and he should consume (incrementCounter) the spot that he moves to. Any ideas?
03:48:57 <shachaf> Peaker: Hmm, interesting, I can reproduce that ere.
03:49:24 <shachaf> Peaker: But if I do the same thing with /usr/bin/cabal (0.14.0), it works correctly.
03:49:40 <Peaker> shachaf, can try to bisect, maybe
03:49:45 <Peaker> I'll make a little test&bisect
03:50:01 <Nereid> Underbyte: your consequences function looks broken
03:50:18 <Nereid> it'll crash when you feed it a map that's not 1x1
03:50:53 <Nereid> also,
03:51:03 <Nereid> left (x,y) = (x-1, y) is much clearer
03:51:04 <Marenz> oh ffs. First I can't get the dependencies for a project because it requires filesystem 1.1.3 (or so) and the old ubuntu ghc requires 1.1.2. Now on a different distribution, I can't install cabal-dev because it would downgrade containers and directory which are required by ghc, cabal and a few more.
03:51:25 <shachaf> left = _1 -~ 1
03:51:26 <Marenz> this is frustrating :(
03:51:39 <Nereid> shachaf: I know, right.
03:52:08 <Nereid> I wonder if the name %~ came from "modify" which sounds like "mod" for the C operator %
03:52:19 <Marenz> has anyone of you got ghc-7.6.1 with cabal-dev running?
03:52:33 <typoclass> Nereid: i thought it was because % was next to $ on the keyboard ...
03:52:50 <Nereid> typoclass: I'm talking about %~ and friends, not %
03:52:59 <Nereid> but hmm
03:53:03 <sopvop> Marenz: how about cabal unpack cabal-dev and try lifting upper bounds
03:53:12 <Nereid> that might make more sense
03:53:16 <shachaf> Nereid: It did.
03:53:20 <Nereid> hehe
03:53:23 <shachaf> Nereid: Well, at least edwardk was aware of the pun.
03:53:39 <Marenz> sopvop, I'll try that, thanks
03:53:41 <sopvop> Stop spoiling newbie with your lens
03:53:56 <shachaf> Nereid: % : %~ : %= = - : -~ : -=
03:54:11 <Nereid> yeah
03:55:33 <Trudko> guys how hard is to programme something like this in haskell http://www.youtube.com/watch?v=lDBXbgJbojM
03:56:15 <sopvop> Trudko: you mean turing machine?
03:56:22 <shachaf> Trudko: 14 points.
03:56:31 <Nereid> the turing machine part would be fairly straightforward. I dunno about the GUI part.
03:56:34 <Nereid> I'm scared of GUI programming.
03:57:01 <sopvop> Yeah, I just wrap haskell into python and QT gui :)
03:57:12 * sopvop only done once
03:57:16 <Nereid> in any language.
03:57:23 <Trudko> yeah thats I bit worried about not sure what are possibilities in haskel I am not familiar enough with it and I would like this to be my first project(to learn haskell)
03:57:57 <Nereid> there are haskell bindings to gtk and wxwidgets and so on though
03:58:02 <Nereid> so it's doable
03:58:07 <Nereid> hmm, qt too
03:58:15 <Trudko> the diagram does not have to be that fancy though
03:58:22 <sopvop> qt bindings are bad, because of C++ I guess
03:58:28 <shachaf> Nereid: So you do you understand Lens.Zipper?
03:58:35 <Cale> GUI programming is not much harder in Haskell than in any other language. However, it's also not much easier.
03:58:35 <Nereid> I haven't looked at it ;)
03:58:41 <pordan30> if you don't want to use the frp gui libraries, you can use glade / gtk2hs with haskell
03:58:46 <Trudko> what does it mena it is doable can someone compare the situation to lets say swing in java which I know?
03:59:02 <typoclass> Trudko: then welcome :-) i suggest you start with text mode. write some strings to a console, read some strings. it's *way* easier than gui programming (in any language). once you have a basic grasp, you can move on to guis
03:59:05 <Nereid> haskell is kind of a low priority thing right now, I'm supposed to be working on my thesis
03:59:11 <Peaker> Trudko, maybe if you start out without the nice UI -- just a file configuring all the inputs -- and a printed trace of outputs, that would be a good first project
03:59:11 <Nereid> and also supposed to be in bed right now!
03:59:13 <sopvop> Anything is better than swing!
03:59:26 <Nereid> so, off to bed I go.
03:59:29 <typoclass> Trudko: do you know lyah? it's a good textbook available free of charge
03:59:31 <typoclass> @where lyah
03:59:31 <lambdabot> http://www.learnyouahaskell.com/
03:59:37 <typoclass> sopvop: how do you mean?
03:59:38 <Trudko> Peaker: typoclass yes for sure! I am just curious if it does make sense.
04:00:04 <sopvop> I mean java sucks :)
04:01:22 <sankrant> Are GpH and GcH different dilects, or are part of Haskell Standard?
04:01:24 <shachaf> Hmm, can you come up with a better Foldable instance for data Z a = Z [a] a [a] than the obvious one of rezipping?
04:01:24 <Trudko> sopvop: thats another topic :D but I am just curious if GUi libs in haskell are at least at level of Java swing
04:02:03 <sopvop> Trudko: gtk2hs is type-safer gtk, code pretty much looks like c :)
04:02:23 <Trudko> sopvop: that does not sounds good :D i am java programmer I am scared of C :D :D
04:02:47 <Trudko> sopvop: and what you mean that it looks like C?
04:02:59 <sopvop> Trudko: I mean it is imperative
04:03:17 <Trudko> sopvop: and it is still written in haskel?
04:03:26 <sopvop> Trudko: sure
04:03:33 <hpaste> rodlogic pasted “existentials: what is wrong here?” at http://hpaste.org/77720
04:03:54 <Trudko> hmm isnt that bad? sopvop ? I mean I am used to imperative sure but thats why I want to learn haskell ...
04:04:27 <typoclass> Trudko: haskell doesn't have the typical c problems (memory management, etc.)
04:04:33 <Peaker> shachaf, you said it worked with cabal 1.14? checking out cabal-1.14 branch from github seems to depend on base <2.2, weird!
04:04:41 <sopvop> Trudko: It's neither good nor bad, it's just the way it is :)
04:04:43 <quicksilver> I don't think gtk2hs code looks anything remotely like C.
04:04:57 <quicksilver> gtk is a callback-driven framework
04:05:07 <typoclass> Trudko: i think "haskell code that looks imperative" isn't a problem at all. it's nothing to be scared of
04:05:07 <quicksilver> callbacks are horrifically unpleasant in C, which doesn't have first class functions
04:05:23 <quicksilver> they're trivially easy and much more composable and refactorable in haskell
04:05:23 <shachaf> Peaker: 1.14 is what I got from apt-get
04:05:24 <Peaker> oh, bad flags
04:05:27 <shachaf> It's probably pretty old.
04:05:37 <sankrant> Are GcH and GpH part of the Haskell standard? Or they are different dilects?
04:05:44 <sopvop> quicksilver is right
04:05:54 <Saizan> rodlogic: messageDispatcher's type promises to work for all a's, while d can only work for the specific type hidden inside the MessageDispatcher constructor
04:05:54 <Peaker> shachaf, not THAT old, it has some weird .cabal logic to select a really old base or a new base.. somehow it selected really old
04:06:01 <shachaf> sankrant: The reason no one is answering is that no one know what you're talking about.
04:06:18 <shachaf> sankrant: So you should specify. :-)
04:06:37 <sopvop> Glasgow c-like Haskell, Glasgow pretty Haskell?
04:06:49 <Saizan> Concurrent and Parallel i believe
04:06:55 <sankrant> There is Cloud Haskell... There is Parrlell Haskell
04:07:03 <sankrant> There is Concurrent Haskell
04:07:20 <sopvop> Isn't cloud haskell just a library?
04:07:24 <sankrant> Saizan Right?
04:07:37 <shachaf> You can find out for yourself what's part of the Haskell standard easily enough.
04:07:37 <Marenz> sopvop, so, is that common practice, to change the upper bounds when you get conflicts?
04:07:47 <Saizan> sankrant: all of those are libraries
04:07:49 <Underbyte> can someone explain to me how to incrementally update an array real quick?
04:07:53 <Underbyte> i'm on the verge of panic
04:07:59 <Underbyte> sorry to sound all dramatic, but yeah
04:08:04 <quicksilver> GPH is a separate program.
04:08:05 <shachaf> Underbyte: Why are you panicking?
04:08:07 <sopvop> Marenz: If maintainer has not released updated version, I do it. Then submit patch.
04:08:13 <sopvop> Sometimes submit...
04:08:14 <quicksilver> it hasn't been updated for ages.
04:08:21 <sankrant> Concurrent Haskell is a library?
04:08:22 <quicksilver> concurrent haskell is not in the standard.
04:08:24 <Underbyte> shachaf: this assignment is due in 4 hours and is a large portion of my grade
04:08:28 <Saizan> sankrant: their implementation is heavily reliant on compiler support, but they don't really extend the language
04:08:30 <quicksilver> but it is implemented by GCH.
04:08:46 <quicksilver> it manifests as a library but of course the core of it is RTS semantics.
04:08:57 <quicksilver> s/GCH/GHC/
04:09:25 <sankrant> Ok, so is there any plan to integrate these dilects in the main language standard as library or featur?
04:09:31 <sankrant> e
04:09:39 <shachaf> They're not really dialects.
04:09:54 <sankrant> shachaf: What are they?
04:10:03 <typoclass> quicksilver: when you say 'manifests as a library', that's Control.Concurrent, isn't it
04:10:04 <shachaf> Well, "Concurrent Haskell" is semi-standardized enough that the documentation specifies behavior in things other than GHC.
04:10:18 <quicksilver> sankrant: GpH is obsolete. It's gone. It will never breathe again.
04:10:25 <georg_os> quit
04:10:32 <quicksilver> concurrent haskell is something which could reasonably be standardised
04:10:41 <quicksilver> but since no other implementation has shown any inclination to  implement it
04:10:44 <quicksilver> I don't think anyone will bother.
04:10:49 <Underbyte> shachaf
04:10:50 <Underbyte> pm
04:11:08 <quicksilver> typoclass: yes, and a few other places dotted around.
04:11:11 <shachaf> Underbyte: Probably you should keep questions to the main channel if there's no reason not to. :-)
04:11:17 <atriq> Help I've just forked containers
04:11:38 <Underbyte> :(
04:11:46 <shachaf> Underbyte: It sounds like you might be in trouble in that class.
04:11:50 <sankrant> quicksilver Does Cloud Haskell supplement Concurrent Haskell?
04:11:55 <Underbyte> i am
04:12:11 <Underbyte> and i have 4.5 hours to complete the assignment pretty much
04:12:23 <shachaf> Underbyte: People here are often happy to answer specific questions, but they won't do your homework for you, and in some cases learning Haskell is more than a matter of having answers to specific questions.
04:12:28 <Underbyte> i know
04:12:40 <sopvop> atriq: what? :)
04:12:46 <Underbyte> but you were wondering why i was panicking
04:12:56 <atriq> Wait
04:13:01 <shachaf> (People will also help you "change your mindset", which is the really valuable part of learning the language. But that'll probably take longer than 4 sleep-deprived hours.)
04:13:16 <atriq> I submitted a pull request adding Applicative and Alternative instances to Seq
04:13:54 <Underbyte> well i think i understand the workflow concept, the problem is i'm not sure how to implement certain parts (such as this incremental updating of an array) and at the rate i'm going i fear i wont complete it on time
04:13:55 <quicksilver> sankrant: You could say that.
04:13:59 <atriq> I don't really know github that well
04:14:18 <quicksilver> sankrant: it's rather more ambitious and it only works with GHC, certainly.
04:14:19 <sopvop> What does incrementally updating array means?
04:14:25 <quicksilver> snorble_: it's also very new and not finished.
04:14:29 <Underbyte> http://www.cs.auckland.ac.nz/references/haskell/haskell-intro-html/arrays.html 11.4
04:14:31 <quicksilver> oops, mis-tab.
04:14:31 <typoclass> sankrant: concurrent haskell is pretty popular. it is part of the most popular haskell compiler (named ghc). lots of people use it for lots of things. -- cloud haskell is much newer and much less popular, it came out only this year. as far as i know it's not finished yet
04:14:39 <quicksilver> sankrant: it's also very new and not finished.
04:15:00 <Underbyte> the part i need to complete is the part where 'pacman' actually moves from one cell on the map to another
04:15:12 <Peaker> I wonder if "workflow" is a better name than "monad" for attracting programmers
04:15:21 <latermuse> underbyte: look into state machines
04:15:27 <sankrant> typoclass: But Concurrent Haskell is not part of the Standard. Right?
04:15:42 <quicksilver> Underbyte: this is why people told you not to use an array in the first place :P
04:15:51 <Underbyte> would it of been any better with a list?
04:15:53 <typoclass> Peaker: nice idea actually
04:15:54 <quicksilver> sankrant: Right. I already said that.
04:16:04 <latermuse> sopvop: incrementally updating arrays make a new copy of the array with any changes in it
04:16:09 <quicksilver> Underbyte: it would have been better with a Map.
04:17:06 <sopvop> Underbyte: so    arr // [(oldCoords, Nothing), (newCoords (Just packman))]
04:17:08 <Peaker> bah, bisecting on cabal-install is a lost cause.. too much tight coupling to platform versions
04:17:56 <sankrant> quicksilver: Is there any chance of concurrent Haskell to get into Haskell 2012 standard?
04:18:08 <quicksilver> sankrant: I believe I already answered that too.
04:18:12 <quicksilver> sankrant: No.
04:18:32 * sopvop is amused by this "Learn Haskell in 8 hours and create packman"!
04:19:02 <quicksilver> sankrant: "concurrent haskell is something which could reasonably be standardised but since no other implementation has shown any inclination to  implement it I don't think anyone will bother."
04:19:31 <sankrant> quicksilver : Yup. You said that.
04:19:35 <sankrant> :)
04:20:39 <JuanDaugherty> LOL
04:21:11 <JuanDaugherty> is this actually saying that non haskell would use haskell's concurrency scheme?
04:21:30 <quicksilver> no, JuanDaugherty
04:21:38 <Peaker> cabal-install's newest master is also broken, in addition to the release 1.16.*
04:21:43 <quicksilver> I'm talking about other haskell implementations using GHC's concurrency scheme.
04:21:54 <Ke> does that refer to forkIO or something else?
04:21:58 <sankrant> quicksilver: To summerise ->> Cloud Haskell is a library and Concurrent Haskell is a ? quicksilver, What was that?
04:21:59 <quicksilver> or at least something roughly API-compatible upon which a standard could be built.
04:22:03 <JuanDaugherty> ah OK
04:22:08 <quicksilver> Ke: yes, forkIO.
04:22:09 <Ke> also dislike sched_yield
04:22:38 <quicksilver> sankrant: Cloud Haskell is not a plain haskell library; it's implemented with lots of TH.
04:22:50 <quicksilver> Concurrent Haskell is primarly an extension to the RTS.
04:23:04 <quicksilver> it's API looks like a library but the way it actually works is RTS changes.
04:23:24 <typoclass> sankrant: "concurrent haskell" is described here: http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html also, have a look at the other "Control.Concurrent..." stuff: http://www.haskell.org/ghc/docs/latest/html/libraries/base/index.html
04:23:50 <typoclass> sankrant: it is part of the "base" package, which comes with ghc
04:26:23 <sankrant> Ok, so haskell can also be extended like C++... I suppose
04:28:18 * hackagebot colada 0.5.3 - Colada implements incremental word class class induction  using online LDA  http://hackage.haskell.org/package/colada-0.5.3 (GrzegorzChrupala)
04:29:23 <quicksilver> sankrant: "like C++"?
04:29:41 <quicksilver> haskell development has always been characterised by eager implementaiton of extensions - it's a research language.
04:30:09 <quicksilver> there must have been dozens of extensions to GHC over the years, some have been dropped, some have proved very useful and stayed, and a couple have been standardised.
04:30:29 <quicksilver> other implementations have some extensions too.
04:34:10 <sankrant> So can I say tha "GHC is the standard"...
04:34:21 <Underbyte> okay
04:34:24 <Underbyte> so i feel better now
04:34:26 <Underbyte> i'm much closer
04:34:41 <sankrant> C++ can be extended by libraries like Boost etc...
04:34:56 <atriq> edwardk, Data.Vector.Lens, I came up (independantly) with definitions of _head, _tail, _last, _init that to me look neater
04:35:20 <edwardk> atriq: i'm not wedded to those
04:35:30 <atriq> _head = lens head (flip cons . tail)
04:35:32 <edwardk> especially if you have ones that run faster ;)
04:35:39 <atriq> I don't know about speed
04:35:52 <quicksilver> sankrant: as far as I know, Boost doesn't extend C++.
04:35:53 <edwardk> oh, i try to avoid the use of the 'lens' combinator
04:35:54 <atriq> I honestly have no idea how to test speed
04:35:54 <quicksilver> it's a library.
04:35:56 <shachaf> I think edwardk is wedded to not having any combinators that use "lens" in the library. :-)
04:36:09 <quicksilver> maybe in part it depends on GCC extensions? I'd not heard that.
04:36:11 <edwardk> yeah, no lens in lens. ;)
04:36:24 <edwardk> that is a lot nicer looking i admit
04:36:29 <sankrant> Libraries which introduce concurrency?
04:36:42 <quicksilver> sankrant: why would you say "GHC is the standard"?
04:36:45 <quicksilver> that's not what I said at all.
04:36:56 <edwardk> for vector it is probably fine, since we aren't pattern matching, so its not getting to save work
04:36:59 <quicksilver> I said lots of extensions have been developed for GHC
04:37:03 <quicksilver> and some of these have been standardised.
04:37:07 <quicksilver> (not many, actually)
04:37:15 <sankrant> Is concurrency defined in the Haskell Standard?
04:37:18 <quicksilver> no.
04:37:25 <quicksilver> isn't that the third time I've answered that for you?
04:37:35 <hpaste> Underbyte pasted “So close...” at http://hpaste.org/77721
04:37:46 <Underbyte> okay
04:37:51 <Underbyte> pretty god damn close now
04:37:56 <Underbyte> just have some typing problems
04:37:59 <sankrant> Oh, I thought concurrent Haskell is yet another library...
04:38:19 <sankrant> I am sorry If I repeatedly ask, I was not aware...
04:38:35 <sankrant> I forget easily
04:38:36 <Underbyte> it's probably a syntax issue
04:38:41 <Underbyte> shachaf: meep
04:38:42 <quicksilver> sankrant: concurrent haskell is primarly a RTS extension.
04:38:49 <sankrant> yeah
04:38:54 <quicksilver> sankrant: it happens to have an interface which is a library.
04:39:19 <sankrant> and Cloud Haskell is also an implementation....
04:39:35 <quicksilver> cloud haskell doesn't contain any new extensions itself
04:39:44 <Underbyte> got rid of the second error
04:39:44 <quicksilver> but it relies heavingly on template haskell (which is an extension)
04:39:53 <quicksilver> and perhaps some other stuff (I am not very familiar with it)
04:40:35 <sankrant> BTW it bugs me, how come a functional language does not have defined concurrency... Concurrency is a primary reason my freinds are comming to FP?
04:40:49 <sankrant> and me too....
04:41:56 <quicksilver> concurrency is not a semantic thing
04:41:56 <typoclass> sankrant: ghc *has* concurrency. it's well-defined and stable. everyone uses it for lots of stuff
04:42:03 <quicksilver> it's just a way of getting results faster
04:42:05 <Peaker> ah, cabal's master branch isn't broken, apparently fixed
04:42:18 <quicksilver> so you wouldn't expect it to be a core concept of a language which emphasises denotation.
04:42:28 <Peaker> quicksilver, you're reversing concurrency/parallelism there?
04:42:30 <quicksilver> as typoclass says, GHC does a very good job of it nonetheless.
04:42:47 <quicksilver> Peaker: perhaps. I can rarely be bothered to distinguish.
04:42:51 <hpc> quicksilver: you have concurrent semantics and a parallel implementation
04:42:56 <Peaker> the usual description is that concurrency is about different semantics, and parallelism is about more performance for same semantics
04:43:00 <atriq> edwardk, how about _head f v = (`cons` tail v) <$> f (head v)
04:43:05 <quicksilver> the language extension called 'glasgow concurrent haskell' implements both.
04:43:12 <quicksilver> and that's what sankrant wanted to ask about.
04:43:29 <hpc> concurrency = multiple threads, parallelism = multiple cores
04:43:40 <sankrant> quicksilver: hmmm
04:44:13 <quicksilver> I could amend my initial comment to 'concurrency is only a feature of the IO monad, which has no denotation, so you wouldn't expect it to be a core concept of a language which emphasises denotation', if you like.
04:44:26 <Peaker> where "threads" are semantic things -- not necessarily parallel/kernel threads
04:44:28 <quicksilver> but I'm not sure that makes my remark any more useful :)
04:44:41 <edwardk> i switched to (\a -> v // [(0,a)]) <$> f (head v)  because i didn't want to pay for two vector constructions
04:44:59 <t7> data RGB = RGB { red, green, blue :: Word8 } <- this is valid?
04:45:08 <edwardk> vectors aren't lists. using cons is horrible
04:45:10 * typoclass so far doesn't see what the fuss is about regarding this concurrency-parallelism distinction
04:45:17 <hpc> quicksilver: you can still "fake it"
04:45:17 <atriq> Okay
04:45:26 <shachaf> t7: Valid what? Valid representation of colour?
04:45:29 <hpc> the other day someone wrote a concurrency monad with unsafeInterleaveIO
04:45:41 <t7> i didnt know you could a, b, c :: Type
04:45:44 <shachaf> I bet conal would get mad at you for it.
04:45:50 <shachaf> Ah, valid syntax. Try it out!
04:45:51 <atriq> Didn't realise that, heh
04:46:03 <atriq> Based my intuition on Data.Sequence
04:46:03 <edwardk> atriq: the original patch i received that added Data.Vector.Lens worked the way you described. =)
04:46:14 <edwardk> yeah for Data.Sequence its great
04:48:16 <typoclass> t7: yup you can. same goes for functions "foo, foo2 :: Int -> String", then "foo x = ..." and "foo2 x = ...". only really useful at the beginning, because haddock comments attach to the "foo ::" line afaik. so when a module stabilizes, you'll likely expand "foo, foo2 ::" to two lines
04:49:16 <Philonous> t7:  That even works on record syntax: data Foo = Foo { a, b, c :: !Integer}
04:49:42 <t7> deja vu
04:50:22 <Philonous> t7:  Sorry, didn't see your earlier comment
04:50:27 <t7> :)
04:51:20 <Philonous> t7:  Well, it also works outside records
04:52:57 <Underbyte> ok
04:52:59 <Underbyte> i think i got it
04:53:07 <Underbyte> how do i populate a data model with function arguments?
04:54:27 <b__> after having made only a couple of small changes to 1 or 2 modules in my library, is there a way to do a QUICK cabal install? (ie. not rewriting docs etc)
04:57:12 <Underbyte> as in i have all these arguments as a tuple, and i'm trying to populate a Data with them
04:58:11 <Underbyte> anyone
04:58:11 <Underbyte> ?
04:59:29 <typoclass> Underbyte: could you put them in the Data rightaway? (why put the stuff in one data structure, then take them out again, and put them in another)
04:59:45 <Underbyte> have you seen the file?
05:00:06 <typoclass> sorry, no. looking ...
05:00:17 <quicksilver> Underbyte: Constructor a b c
05:00:21 <quicksilver> is how you 'make' a Data.
05:00:32 <quicksilver> if you have them in a tuple, try pattern matching the tuple
05:00:38 <donri> you can uncurry the constructor, but only for two arguments
05:00:39 <quicksilver> let (a,b,c) = tuple in Constructor a b c
05:00:45 <typoclass> Underbyte: which part of http://hpaste.org/77721 ?
05:00:59 <hpaste> Underbyte pasted “new hotness” at http://hpaste.org/77722
05:01:10 <donri> > uncurry (+) (2,3)
05:01:11 <lambdabot>   5
05:01:36 <shachaf> > sumOf both (2,3)
05:01:38 <lambdabot>   5
05:01:47 <Underbyte> right, so in this assignment the arguments are coming to me in the consequences arguments
05:01:56 <Underbyte> i need to stuff them into GameState
05:02:57 <typoclass> Underbyte: use "GameState { level = ..., score = ... }" to create a GameState value
05:04:20 <gentrilz> http://pastie.org/private/ooz5frt4ybzsrz3gbt4ymq
05:04:30 <gentrilz> Can anyone do it in Haskell? :D
05:04:53 <Iceland_jack> no
05:05:12 <gentrilz> :(
05:05:35 <quicksilver> it's trivial, gentrilz
05:05:39 <quicksilver> why should we do it for you?
05:05:48 <quicksilver> it doesn't look like a very rewarding task to me :)
05:05:51 <gentrilz> quicksilver: I just want to see how it is done in haskell
05:06:08 <atriq> I'm sure there's a Text.Morse module somewhere
05:06:11 <pordan30> heinrich apfelmus has a cool morse code decoder on his blog
05:06:20 <gentrilz> Because i hear stuff can get really short in haskell :P
05:06:23 <gentrilz> length wise
05:06:27 <Underbyte> typoclass: yes, but how do i stuff the argument values into that GameState
05:06:46 <b__> gentrilz, but what would that mean to you if you don't understand it
05:07:02 <soiamso> Underbyte: immutable, you get a new one
05:07:06 <gentrilz> b__: It would mean me learning it
05:07:07 <edwardk> atriq: http://comonad.com/haskell/remorse-1.0/remorse.hs
05:07:12 <gentrilz> and seeing different approaches
05:07:16 <atriq> @hackage MorseCode
05:07:17 <lambdabot> http://hackage.haskell.org/package/MorseCode
05:07:17 <gentrilz> in different langs
05:07:29 <edwardk> the one i linked too is cooler ;)
05:07:37 <atriq> Yes it is
05:08:05 <pordan30> Underbyte: if consequences returns a tuple of arguments, then you can pattern match on the result of consequences, and put them into a GameState.
05:08:21 <pordan30> Underbyte: let consequences a = (b,c,d,e) in GameState b c d e
05:08:42 <Underbyte> can i do that within the actual haskell itself? i thought let was only a GHCI thing
05:08:57 <typoclass> Underbyte: you could write a function of the form "foo x = GameState { level = x, score = ... }"
05:09:48 <quicksilver> pordan30: did you mean let (b,c,d,e) = consequences a in ....
05:09:50 <Underbyte> true
05:09:52 <pordan30> Underbyte: let x = y in z is a predefined language construct, with its own set of special typing and evaluation rules
05:10:00 <quicksilver> let is a very important part of haskell I'd say :)
05:10:00 <pordan30> quicksilver: oh, yeah
05:10:21 <gentrilz> hmmm
05:11:08 <Underbyte> http://pastie.org/5376962
05:11:13 <Underbyte> small problem it seems :x
05:11:42 <Underbyte> i know int to integer conversion isn't hard, my trouble is finding out where to do it
05:11:43 <pordan30> Underbyte: use fromIntegral to convert between integer types, or just parameterize everything by Integral a => ... a ...
05:11:49 <gentrilz> hmmm
05:12:03 <Underbyte> should be line 95
05:13:44 <quicksilver> Underbyte: well 'toRaw' is the only thing in your code to explicitly use Int
05:14:07 <Underbyte> right, so you'd think that i can just change the type def to Integer, Integer, but it doesn't like that
05:14:23 <quicksilver> "it doesn't like that" is not a very helpful piece of information
05:14:39 <gentrilz> anyone?
05:14:41 <quicksilver> I expect you just need to fromIntegral the first argument to splitEvery
05:15:18 <quicksilver> splitEvery (fromIntergal (fst(snd (bounds a)) + 1)) (elems a)
05:16:35 <gentrilz> ?
05:16:50 <typoclass> gentrilz: an outline of your morse decoder could be: use a Map (from module Data.Map) that tells which "." and "-" sequence stands for which letter, then use function "words" on the input string to split it at the spaces, then on each of the words use the "lookup" function to look it up in the Map. when i say "each of the words", that will be done with the "map" function
05:17:54 <gentrilz> hmmm
05:17:58 <b__> gentrilz, have a look at http://rosettacode.org/wiki/Morse_code#Haskell
05:18:43 <gentrilz> b__: Thats the shortest approach?
05:19:37 <quicksilver> well it's much more sophisiticated that your code
05:19:46 <quicksilver> it understands that morse has three different lengths of 'gap'
05:19:54 <quicksilver> and it knows about numbers
05:20:00 <typoclass> gentrilz: no, it's not the shortest :-)
05:20:06 <quicksilver> it could be shortened considerably if you wanted to.
05:20:31 <gentrilz> quicksilver: Well, my code does not need all the other extra stuff ( with regard to challeneg)
05:20:42 <quicksilver> sure. you could remove that.
05:21:05 <b__> gentrilz is this just about short?
05:21:12 <gentrilz> lol >>> toMorse = fromWords . words . weed
05:21:12 <gentrilz> b__: Yes
05:21:42 <b__> then have a look at J maybe?
05:21:51 <b__> or does it have to be in Haskell?
05:22:05 <gentrilz> b__: I have never learnt J
05:22:13 <gentrilz> b__: Any lang :)
05:22:18 <b__> http://rosettacode.org/wiki/Morse_code#J
05:22:49 <gentrilz> Yea to understand that....
05:23:12 <Underbyte> man i am close
05:23:14 <Underbyte> i can smell it
05:23:15 <Underbyte> http://pastie.org/5377011
05:23:51 <Underbyte> any idea?
05:24:06 <typoclass> @where lyah
05:24:06 <Underbyte> oh derp
05:24:06 <lambdabot> http://www.learnyouahaskell.com/
05:24:24 <typoclass> gentrilz: have a look at lyah ^^ it's a good textbook available free of charge
05:24:27 <Underbyte> forgots me a map
05:24:31 <gentrilz> typoclass: What is the shortest in haskell?
05:24:39 <gentrilz> ok
05:24:50 <typoclass> gentrilz: also, try tryhaskell.org and do some messing around :-)
05:26:04 <quicksilver> gentrilz: here is quite a short decoder - http://stackoverflow.com/a/1372904
05:26:08 <quicksilver> it's shorter than your java code.
05:26:26 <quicksilver> if you want it to be short in terms of characters you can just golf it down of course.
05:26:37 <merijn> hmmm, is linkedin tracking IRC nowadays? "You might know.. Edward Kmett and Shachaf Ben-Kiki" :p
05:26:45 <edwardk> hah
05:27:03 <edwardk> feel free to send me a connection request
05:28:17 <edwardk> I find it funny that I have the most endorsements for Haskell of anyone on LinkedIn. I was downright shocked when I passed dons. I don't think anyone else is paying attention though. ;)
05:28:27 <hpc> heh
05:28:29 <typoclass> quicksilver: that's a bit funky isn't it?
05:28:57 <quicksilver> typoclass: it's based on apfelmus's rather clever blog post.
05:29:44 <killy9999> what is the priority of :: ?
05:29:53 <quicksilver> it's syntax, killy9999
05:29:57 <quicksilver> not an operator
05:29:57 <killy9999> well, yes
05:29:59 <atriq> Heh, just searched LinkedIn for Edward Kmett, and there's two results.. edwardk and an intellectual property attorney
05:30:00 <killy9999> but still :)
05:30:08 <killy9999> if I have
05:30:14 <quicksilver> it binds tighter than any binary operator
05:30:15 <edwardk> yeah, the other guy looks like uncle fester
05:30:19 <killy9999> y = 2 * x - 2 :: Int
05:30:25 <killy9999> Ah, OK
05:30:41 <hkBst> what would be (or is) a Haskell-allowable name for a function that converts between Cartesian and polar representations of a complex number?
05:30:41 <killy9999> so the question was whether :: Int applies only to 2 or to whole expression
05:30:56 <killy9999> I understand it applies to everything
05:30:58 <killy9999> great
05:31:32 <Underbyte> quick question: can you treat a list as a stack and pop char's off of it?
05:31:43 <quicksilver> killy9999: no, binds *tighter* than any binary
05:31:44 <nand`> Underbyte: sure
05:31:48 <edwardk> > tail [1,2,3]
05:31:50 <lambdabot>   [2,3]
05:31:53 <quicksilver> killy9999: it applies just to the 2.
05:31:56 <quicksilver> at least, I think so.
05:31:57 <nand`> Underbyte: the canonical representation of a stack in haskell *is* a list
05:31:59 <edwardk> > 0:[1,2,3]
05:32:00 <Underbyte> aah
05:32:00 <quicksilver> maybe I have it backwards
05:32:01 <lambdabot>   [0,1,2,3]
05:32:04 <nand`> > head &&& tail $ [1,2,3,4]
05:32:06 <lambdabot>   (1,[2,3,4])
05:32:08 <edwardk> > head [1,2,3]
05:32:11 <lambdabot>   1
05:32:18 <edwardk> you may recognize pop, push, and top ;)
05:32:27 <quicksilver> > flip (:) [] 0 :: Int
05:32:28 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:32:28 <lambdabot>              with actual type ...
05:32:29 <nand`> usually you'd pattern-match on it though instead of using head or tail
05:32:32 <typoclass> gentrilz: check out the first solution in http://apfelmus.nfshost.com/articles/fun-with-morse-code.html (the rest of the post doesn't seem useful at first glance, i think you can skip that)
05:32:33 <quicksilver> > flip (:) [] 0 :: [Int]
05:32:35 <lambdabot>   [0]
05:32:49 <nand`> > case [1,2,3,4] of [] -> "Empty stack!"; x:xs -> "Popped: " ++ show x ++ "; Rest: " ++ show xs
05:32:51 <lambdabot>   "Popped: 1; Rest: [2,3,4]"
05:33:02 <killy9999> quicksilver: ah, OK
05:33:07 <quicksilver> > let (+) = flip (:) in [] + 0 :: Int
05:33:09 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
05:33:09 <lambdabot>              with actual type ...
05:33:10 <killy9999> so I need parens :/
05:33:13 <quicksilver> > let (+) = flip (:) in [] + 0 :: [Int]
05:33:15 <lambdabot>   [0]
05:33:18 <quicksilver> killy9999: I was wrong.
05:33:26 <quicksilver> killy9999: it binds loose.
05:33:32 <quicksilver> killy9999: doesn't matter eithe rway in your example :)
05:33:46 <quicksilver> annotating the '2' is the same as annotating the whole expression.
05:33:46 <killy9999> ok, I'm not listening to you anymore, gonna check this myself :)
05:34:01 <quicksilver> since every subexpression of your expression must have the same type
05:34:12 <quicksilver> it will have the same result if you annotate the last number or the whole thing.
05:34:13 <killy9999> that's a point
05:34:18 <nand`> I thought :: binds to the whole expression, as long as it isn't in parentheses
05:34:22 <quicksilver> killy9999: you don't need to believe me, I just proved it.
05:34:25 <quicksilver> nand`: yes, you're right.
05:35:49 <Underbyte> okay quick question then, how can i go about saying "until list is empty, do this operation"
05:36:07 <nand`> depends on your meaning of “until” and “do”
05:36:13 <quicksilver> lists are immutable
05:36:20 <nand`> Haskell doesn't have side effects so there's not an awful lot of ways you can interpret ‘doing some operation’
05:36:22 <quicksilver> so it's not empty to start with, it will never become it
05:36:26 <nand`> yes, also immutable lists
05:36:36 <quicksilver> probably what you want is a map or scan or fold
05:36:37 <quicksilver> over the lists.
05:36:58 <Underbyte> oh wait, thats right!
05:37:08 <hkBst> what is the Haskell convention for naming a conversion function like: cartesian->polar ?
05:37:09 <nand`> what you want is probably a fold, an unfold, or some combination thereof :)
05:37:10 <Underbyte> oh wait, thats not right
05:37:14 <Underbyte> i have to recurse
05:37:22 <Underbyte> because these operations are not independant
05:37:26 <nand`> hkBst: I think the canonical representation would be cartesianToPolar but that's a bit verbose
05:37:31 <pordan30> :t mapM_
05:37:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m ()
05:37:33 <pordan30> :t sequence_
05:37:35 <lambdabot> Monad m => [m a] -> m ()
05:37:41 <Underbyte> one iteration of the state is going to depend on the next, etc etc
05:37:59 <nand`> maybe ‘polar’ for the polar form (as implied from cartesian), and ‘cartesian’ for the cartesian form (as implied from polar)
05:38:16 <nand`> Underbyte: ‘operation’?
05:38:25 <nand`> Underbyte: you mean something like printing it to the screen?
05:38:42 <Underbyte> okay so if i was writing this in C, it would be "While (gameState.moveQueue.length > 0) doFunction", etc etc
05:38:58 <nand`> also, if one iteration depends on the next then you'll need to thread a reverse state :P
05:39:15 <nand`> or use a right-fold to build it or something
05:39:34 <Maxdamantus> :t iterate
05:39:35 <lambdabot> (a -> a) -> a -> [a]
05:39:46 <nand`> Underbyte: ‘doFunction’ here is a procedure; one with side effects. Haskell doesn't have side effects; so there's nothing useful that function could possibly be doing
05:39:54 <nand`> you might as well do nothing
05:40:08 <hkBst> nand`: thanks
05:40:24 <Underbyte> right so the idea is that theres a property in my data var gameState that has a "Move List"
05:40:41 <Underbyte> its basically a queue containing the commands to change the state of the game
05:41:05 <killy9999> quicksilver, nand` : Haskell 2010 report, section 3.16
05:41:09 <Underbyte> i need to dequeue (or 'pop') each char off one at a time, and change the gameState depending on what move it was
05:41:23 <killy9999> Type annotation refers to whole expression
05:41:53 <quicksilver> killy9999: I already said that :)
05:41:57 <quicksilver> killy9999: but, yes indeed.
05:42:23 <hpaste> quicksilver pasted “morse decoder” at http://hpaste.org/77724
05:42:34 <quicksilver> gentrilz: ^^ there you are. A short morse decoder.
05:42:34 <typoclass> Underbyte: i think you should write a function that handles the first one of those move commands, makes a new (updated) gameState which has the first move command removed from the list, and then calls itself (recursion), passing the new gameState. when the moveList is empty, you're done
05:43:00 <killy9999> quicksilver: yes, but now we have a source :)
05:43:09 <Underbyte> thats the idea
05:43:10 <nand`> Underbyte: that does sound like a fold; think folodr :: (Action -> State -> State) -> State -> [Action] -> State
05:43:13 <nand`> foldr*
05:43:37 <nand`> or I guess a foldl would be better
05:43:41 <gentrilz> quicksilver: What exactly does it do?
05:43:43 <gentrilz> your one?
05:43:58 <quicksilver> gentrilz: it decodes morse code.
05:44:00 <quicksilver> gentrilz: for example:
05:44:12 <quicksilver> > q ".... .- -.-. -.- ..-. --- .-. ..- -- ..."
05:44:13 <quicksilver> "HACKFORUMS"
05:44:13 <lambdabot>   The function `Debug.SimpleReflect.Vars.q'
05:44:14 <lambdabot>  is applied to one argument,
05:44:14 <lambdabot>  but...
05:44:21 <Underbyte> nand, right... foldr, is kind of like map, but for recursive function trees
05:44:24 <quicksilver> well lambdabot doesn't have it loaded.
05:44:31 <quicksilver> that was rom my ghci.
05:44:51 <gentrilz> quicksilver: sos
05:45:07 <nand`> Underbyte: I don't see much of a connection between fold and map
05:45:09 <gentrilz> quicksilver: Try put in sos
05:45:14 <gentrilz> as input
05:45:46 <typoclass> gentrilz: his version was just a joke. i don't think it's very readable, or that you could learn much from it
05:45:56 <quicksilver> Main> q "... --- ..."
05:45:58 <quicksilver> "SOS"
05:46:12 <quicksilver> typoclass: at one point he claimed that it being short was the important point.
05:46:15 <quicksilver> so I made it short.
05:47:03 <quicksilver> nand`: (the connectioin between fold and map is that map f = foldr ((:).f) []
05:47:31 <nand`> oh, fair point; for lists - I was thinking in terms of fmap
05:47:47 <typoclass> quicksilver: he also said he was trying to learn haskell, which your solution is not helping with
05:47:52 <nand`> fmap and Foldable I guess
05:48:12 <Jafet> . .--. .. -.-. - .-. --- .-.. .-.. .. ... . .--. .. -.-.
05:48:15 <quicksilver> typoclass: sure. I didn't really believe that a particular short morse code decoder was a good way to learn haskell. He'd already been pointed to a nicely formatted longer one.
05:48:15 <b__> typoclass, there are the other examples for him to learn from then
05:48:31 <quicksilver> typoclass: he implied that was rather long, so now he has a shorter one.
05:48:38 <quicksilver> and I've learnt a nice trick from apfelmus.
05:48:40 <quicksilver> everyone wins, right?
05:49:02 <typoclass> b__: i'm aware, i linked him to one
05:49:48 <nand`> typoclass: ‘unwords . map morse . words’ => I can just see this kind of stuff being done much more elegantly with lenses :)
05:49:57 <nand`> I wonder if there's a byWords or whatever lens in HEAD yet
05:50:22 <edwardk> words is only a legal iso if you don't put spaces in the resulting lists
05:50:32 <Jafet> @wn byword
05:50:33 <lambdabot> *** "byword" wn "WordNet (r) 3.0 (2006)"
05:50:33 <lambdabot> byword
05:50:33 <lambdabot>     n 1: a condensed but memorable saying embodying some important
05:50:33 <lambdabot>          fact of experience that is taken as true by many people
05:50:33 <lambdabot>          [syn: {proverb}, {adage}, {saw}, {byword}]
05:50:51 <edwardk> :t iso words unwords
05:50:52 <lambdabot> (Functor f, Isomorphic k) => k ([String] -> f [String]) (String -> f String)
05:51:02 <edwardk> :t iso unwords words
05:51:04 <lambdabot> (Functor f, Isomorphic k) => k (String -> f String) ([String] -> f [String])
05:51:34 <edwardk> thats the main reason why its not in Control.Lens.Iso
05:52:28 <shachaf> > over (iso words unwords . traverse . traverse) toUpper "also   multiple   spaces"
05:52:30 <lambdabot>   "ALSO MULTIPLE SPACES"
05:52:32 <hpaste> jesyspa pasted “Suitable types?” at http://hpaste.org/77725
05:52:32 <jesyspa> I want to write a toy compiler in Haskell, and am trying to come up with a suitable set of types to do it.  Am I asking the right question, and is this close to what I'd want?
05:53:30 <hpaste> b__ pasted “Is there a better way to write this?” at http://hpaste.org/77726
05:53:38 <b__> ^
05:54:35 <quicksilver> b__: maybe (return()) (go.words) input ?
05:54:44 <quicksilver> for the case part
05:54:47 <shachaf> @ty Foldable.mapM_
05:54:49 <lambdabot> Couldn't find qualified module.
05:54:52 <shachaf> @ty Data.Foldable.mapM_
05:54:53 <lambdabot> (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
05:55:02 <quicksilver> getInputLine "# " >>= maybe (return()) (go.words)
05:55:08 <shachaf> Data.Foldable.mapM_ :: Monad m => (a -> m b) -> Maybe a -> m ()
05:56:27 <nand`> edwardk: one idea I had is to treat separate spaces as separate word delimiters
05:56:50 <shachaf> getInputLine "# " >>= mapM_ (go . words)
05:57:00 <shachaf> With the appropriate mapM_ :-)
05:57:06 <b__> yeah shachaf, awesome =]
05:57:12 <edwardk> nand` :the issue is more subtle. if i put a space in i change the number of targets, so it makes me violate traversal laws
05:57:41 <Saizan> jesyspa: looks fine, i don't have any experience with compilers for imperative langs though
05:57:59 <edwardk> you _can_ make a words/lines iso but it comes with caveats about how the original must be in a normalized form, and you aren't allowed to insert spaces or newlines respectively
05:58:47 <nand`> quicksilver: "# " ^! act getInputLine . traverse . to words . act go
05:58:56 <jesyspa> Thanks, will go ahead with it then. :D
05:58:56 <quicksilver> nand`: :)
05:59:06 <DemonWitch> i tried to install cabal and failed, and got asked to run haskell-updater.
05:59:11 <DemonWitch> any idea why this happens?
05:59:15 <nand`> edwardk: did you get my comment just now about consecutive spaces?
05:59:25 <shachaf> nand`: Yes, but that doesn't help you.
05:59:44 <edwardk> sure, but it only helps one side of the problem and doesn't yield the function most people want
05:59:47 <nand`> oh, wait, now I see the problem
05:59:53 <nand`> if the first traversal inserts spaces, it modifies it
06:02:15 <pordan30> jesyspa: someone will probably override this, but if you're committed to distinguishing l-values and r-values, you might want to abstract the definition so that l-values are identified by identifiers, and have addresses, and rvalues are either expressions or lvalues. you could also abstract the notion of an expression and a statement, instead of making rvalue a sum of non-l-values. it might make writing the rest of the compiler ea
06:02:15 <pordan30> sier.
06:03:22 <pordan30> (committed: at the level of the ast you're generating)
06:03:55 <hpaste> b__ annotated “Is there a better way to write this?” with “Is there a better way to write this? (annotation)” at http://hpaste.org/77726#a77729
06:04:18 <jesyspa> pordan30: Hmm, so do you suggest making an Expression datatype?  Where would it fit?
06:06:16 <killy9999> can I have a list of unboxed values?
06:06:23 <killy9999> like unboxed Double?
06:07:13 <luite> only if you make your own custom list type
06:07:23 <killy9999> ok
06:07:27 <atriq> Try Data.Vector.Unboxed, which is kind of similar
06:07:36 <killy9999> atriq: yes, I know about Vector
06:07:55 <killy9999> but I was thinking if I can get rid of unboxing in case of a list
06:09:02 <hpaste> “cabal-install fail” pasted “Marenz” at http://hpaste.org/77730
06:09:09 <Marenz> I can't install cabal-dev
06:09:12 <Marenz> see my paste for the error
06:10:43 <hkBst> given a datatype (data D = A | B) can you define functions of type D -> A, D -> B ?
06:10:43 <sam4> Hi, I want to define a function that uses randomR but I want to hide the generator through state monad
06:11:11 <sam4> Is this possible since I have to define function that takes in only the state and produces (a, state)
06:11:18 <Botje> hve you looked at the random supply monad?
06:11:27 <Underbyte> well
06:11:33 <byorgey> Marenz: hmm, I don't understand why cabal-dev wants older versions of containers and network
06:11:33 <Underbyte> i am so freakishly close it hurts
06:11:37 <sam4> I'm not sure where I should take in the range
06:11:41 <Underbyte> two operations to go and i think i'll be done
06:11:44 <Marenz> me neither.
06:11:46 <byorgey> Marenz: can you paste the output of  cabal install -v3 cabal-dev?
06:12:11 <hkBst> lambdabot: > data D = A | B ; f :: D -> A;
06:12:14 <hpaste> Underbyte pasted “Loading the data model...” at http://hpaste.org/77731
06:12:21 <hpaste> Marenz pasted “cabal install -v3 cabal-dev” at http://hpaste.org/77732
06:12:28 <Marenz> byorgey, ^
06:12:31 <Underbyte> right, so on line 37 i'm trying to load the arguments into the data model
06:12:34 <Underbyte> anyone care to help?
06:12:41 <hkBst> > data D = A | B ; f :: D -> A;
06:12:42 <lambdabot>   <hint>:1:1: parse error on input `data'
06:13:13 <byorgey> Marenz: oh, it's because cabal-dev still requires Cabal < 1.16
06:13:29 <Underbyte> this is the error http://pastie.org/5377180
06:13:37 <byorgey> Marenz: sadly cabal-dev does not seem very actively maintained =(
06:13:54 <byorgey> Marenz: but happily it will soon not matter because cabal-install itself is getting sandboxing features
06:14:29 <byorgey> Marenz: if you like you can edit cabal-dev.cabal and adjust the Cabal upper bound
06:14:35 <byorgey> it will probably (?) work
06:14:58 <byorgey> cabal unpack cabal-dev; cd cabal-dev; edit cabal-dev.cabal; cabal install
06:15:37 <Underbyte> any help? i could very much use it and i would appreciate it
06:16:06 <hpaste> Marenz pasted “after changing cabal upper bound” at http://hpaste.org/77733
06:16:08 <Marenz> byorgey, it has some more problems
06:16:20 <Botje> Underbyte: why do you pattern match on argmap as [[argmap]] ?
06:16:24 <hkBst> > data D = A | B
06:16:25 <lambdabot>   <hint>:1:1: parse error on input `data'
06:16:54 <hpaste> Marenz pasted “after changing more upper bounds” at http://hpaste.org/77734
06:17:06 <Marenz> byorgey, eventually, I ended up with what I just pasted
06:17:12 <Underbyte> botje come again?
06:17:13 <Botje> Underbyte: that will only map a one-element list containingg a one-element list containing an element which you bind to argmap
06:17:40 <Underbyte> aah.
06:17:45 <Botje> :t let [[argmap]] = [['a']] in argmap
06:17:47 <lambdabot> Char
06:17:51 <Underbyte> i see
06:18:00 <hkBst> lambdabot doesn't support data definitions?
06:18:18 <shachaf> hkBst: It only works on the sixth try.
06:18:37 <yiannis_t> Is this http://cale.yi.org/index.php/How_To_Use_Monad_Transformers available somewhere? :-/
06:18:41 <yiannis_t> Cale: ^
06:19:21 <byorgey> Marenz: how did you install things in the first place?  Did you install the Haskell Platform?
06:19:24 <Cale> yiannis_t: On my old hard-drive which I can't get into because I don't have any machines with plain IDE interfaces.
06:19:31 <byorgey> Marenz: can you paste the output of  ghc-pkg list  ?
06:19:40 <yiannis_t> Cale: ohh, ok :)
06:19:43 <Cale> (and which may be failing, seeing as I can't boot the machine which it was in originally)
06:20:11 <hpaste> Marenz pasted “ ghc-pkg list” at http://hpaste.org/77735
06:20:43 <Marenz> byorgey, I installed cabal-install & ghc using my native package manager and then used cabal install cabal-dev (and installed the dependencies by hand)
06:20:43 <shachaf> @google usb ide external
06:20:45 <lambdabot> http://www.newegg.com/Product/Product.aspx?Item=N82E16812232002
06:20:45 <lambdabot> Title: Newegg.com - Vantec 2.5"/3.5"/5.25" SATA/IDE to USB 2.0 Adapter - Model CB-ISATA ...
06:21:30 <fizzbang> hi, i'm using macos 10.6.8 and installed macports hs-platform-ghc, and i'm getting "Could not find module `Data.Vec.Nat'" even though i can import that module in ghci...
06:21:48 <hkBst> given a datatype (data D = A | B) can you define functions of type D -> A, D -> B ? If not how else should you construct the types?
06:21:50 <fizzbang> well, ghci doesn't give an error.. i'm not really sure if it's importing
06:22:07 <shachaf> hkBst: A and B aren't types
06:22:10 <shachaf> Thus you can't construct them.
06:22:20 <pordan30> hkBst: neither A nor B are types. A and B are (nullary) data constructors, whereas D is a (nullary) type constructor.
06:22:39 <sam4> Hi
06:22:41 <byorgey> Marenz: it's bad that you have two versions of bytestring, one in your global package db and one in local
06:22:44 <sam4> can anyone help?
06:23:02 <sam4> I am trying to define a function that uses randomR but I want to hide the generators using the state monads
06:23:04 <byorgey> Marenz: you should uninstall the one in your local package db:  ghc-pkg unregister bytestring-0.10.0.1
06:23:17 <byorgey> Marenz: you will probably also have to uninstall zlib-0.5.4
06:23:19 <sam4> is this possible since you take in the range for randomR?
06:23:31 <byorgey> and uninstall the other bytestring in your local package db too while you're at it
06:23:48 <tomboy64> could someone help me turn this into a working example? (needs Data.AttoBencode)
06:23:51 <tomboy64> http://bpaste.net/show/57960/
06:24:01 <fizzbang> i'm also unable to use "Data.Map.Strict"
06:24:29 <Marenz> byorgey, done
06:24:36 <tomboy64> i get a parsing error (no idea why) and decode refuses to work at all
06:24:45 <byorgey> sam4: see the MonadRandom package
06:24:50 <byorgey> @package MonadRandom
06:24:51 <lambdabot> http://hackage.haskell.org/package/MonadRandom
06:25:24 <Peaker> there's covariant, contravariant, invariant. but what do you call it when it is both covariant and contravariant, not invariant, i.e:  data Trivial a = Trivial deriving (Functor, ContraFunctor)
06:25:53 <byorgey> Peaker: "trivial"
06:25:55 <fizzbang> any haskell users who installed via macports outh there?
06:25:58 <pordan30> tomboy64: you probably want let z = encode (BInt 5)
06:26:14 <byorgey> Peaker: or "constant"
06:26:25 <shachaf> "unvariant" :-)
06:26:28 <byorgey> Peaker: because the only way that can happen is if the argument is completely ignored
06:26:30 <atriq> @info Gettable
06:26:30 <lambdabot> Gettable
06:26:35 <atriq> :t coerce
06:26:36 <lambdabot> Not in scope: `coerce'
06:26:54 <atriq> But it's basically a Gettable from Control.Lens.Internal
06:26:57 <shachaf> @ty Control.Lens.Internal.coerce
06:26:59 <atriq> Unless there's a cooler name
06:26:59 <lambdabot> Gettable f => f a -> f b
06:27:01 <tomboy64> pordan30: yeah, that was it. still, the decode thingy is not working :-/
06:27:26 <edwardk> Peaker: the term i've seen is 'anyvariant'
06:27:33 <edwardk> Peaker: in lens i call it 'Gettable'
06:28:00 <shachaf> edwardk: The only relevant results for that on Google are #haskell logs.
06:28:22 <edwardk> anyvariant? i've seen it in the wild before in jstor somewhere
06:28:27 <sam4> byorgey: when should we use Monad.State and Monad.Random?
06:29:11 <byorgey> sam4: use Monad.State when you have a generic stateful computation.  Use Monad.Random when you specifically want to thread around a random generator.
06:31:08 <sam4> hm... sorry I am very new to monads and I am still not getting the difference
06:31:23 <sam4> so Monad.State is a generic version?
06:31:31 <prophile> yes
06:31:49 <sam4> Oh I see
06:31:51 <Peaker> MonadState lets you carry around an arbitrary value of any type you choose "s"
06:32:26 <Peaker> Monad.Random possibly may not need to exist? Could be a use-case of MonadState?
06:32:44 <byorgey> Peaker: well, of course it's implemented on top of MonadState.
06:32:58 <edwardk> Peaker: it could, but then you lose utility. its nice to be able to call 'random' and still be able to get/put other state
06:32:58 <byorgey> but it gives a much more convenient interface for specifically working with randomness.
06:33:27 <edwardk> without MonadRandom you always have to work around the presence of your seed in your state.
06:33:32 <byorgey> for that matter Monad.State doesn't need to exist, it's just a use-case of functions =P
06:33:59 <shachaf> I,I data Random = ...; makeClassy ''Random
06:34:00 <Peaker> edwardk, ah, I was wondering if the fundeps in mtl could be different such that "get" could go to a different layer in the stack depending on the type of "s"
06:34:16 <edwardk> peaker: doesn't work
06:34:27 <Peaker> byorgey, as a class, I meant -- it could be a bunch of functions using the same MonadState class?
06:34:35 <spaceships> newbie question: if you have a stateful function, what is the next step to make it work as a state monad?
06:34:35 <edwardk> in practice, its best to have one state, one environment, one log, etc. thats why get /= ask ;)
06:35:03 <dmwit> spaceships: rewrite the statefulness in terms of get/put/modify
06:35:04 <Peaker> edwardk, that's assuming you have RWS structure -- if you have some other non-commutative monads in between these layers, it may have different semantics
06:35:07 <edwardk> Peaker: it could but then you always have to mess around with lift. the goal of the mtl in general was to avoid explicit lifting
06:35:13 <byorgey> Peaker: oh, I see.  But yes, I agree with edwardk, that would just make it very inconvenient to use stateful computations which also need randomness
06:35:28 <dmwit> spaceships: (Or use the StateT constructor directly.)
06:35:33 <dmwit> :t StateT
06:35:35 <lambdabot> (s -> m (a, s)) -> StateT s m a
06:35:47 <Peaker> edwardk, Yeah, I prefer explicit lifting since lifting isn't always just about satisfying the type-checker, it can change semantics
06:35:50 <edwardk> Peaker: sure. but by then you've reeached a pretty rarified example ;)
06:36:26 <spaceships> dmwit: rewriting the statefulness in terms of get/put/modify means making it an instance of some class?
06:36:29 <nand`> mtl still gives me the ability to manually lift when nesting transformers
06:36:46 <dmwit> spaceships: No, it means making it typeclass-polymorphic and then using already-existing instances of that class.
06:36:51 <edwardk> i build composite states, and then use lenses to view the part i want. the few things where you need state to survive backtracking, etc. are already problematic enough that they usually get wrapped up with a different api, e.g. the state in parsec.
06:37:05 <Peaker> I also like the explicit lifting as it lets me give useful information in the lifter's name (I almost never use "lift" directly, but wrap it)
06:37:07 <nand`> we need a MonadReverseState
06:37:27 <edwardk> Peaker: i think we've gone round and round on this issue before though ;)
06:37:32 <Peaker> edwardk, I don't really understand why parsec through in StateT
06:37:37 <dmwit> nand`: There's a backward state monad lying around on Hackage somewhere.
06:37:40 <Peaker> threw that is
06:37:45 <nand`> dmwit: yeah, but not an mtl class for it
06:37:50 <nand`> or lens combinators :P
06:38:01 <nand`> or maybe there is
06:38:09 <dmwit> Peaker: Yeah, I don't understand it either. I think it may have predated monad transformers as we know them today...?
06:38:17 <tomboy64> the function i am trying to use (decode) has the type signature: decode :: FromBencode a => Data.ByteString.Internal.ByteString -> Maybe a  --- now ghci complains: Ambiguous type variable `a0' in the constraint: (FromBencode a0) arising from a use of `decode'
06:38:36 <Peaker> dmwit, if I understand edwardk right, he's saying it's because of the need to survive backtracking correctly
06:38:43 <tomboy64> it suggests to add an appropriate type signature - but i am lost as to what to do
06:38:50 <nand`> tomboy64: it doesn't know which ‘a’ to return
06:38:51 <edwardk> i think that was the case. but i could be wrong
06:38:53 <Peaker> edwardk, btw, I do use RWST if I have a reader, writer, state in there, but no mtl :)
06:39:16 <Peaker> edwardk, lens is not that useful for reader/state/etc without the mtl, unfortunately
06:39:20 <nand`> tomboy64: possibly you are using it in some context where it gets further processed to some monomorphic type; so the type-checker can't just infer a polymorphic type like it usually would for such things
06:39:26 <dmwit> ?unmtl StateT s [] a
06:39:26 <lambdabot> s -> [(a, s)]
06:39:36 <edwardk> as i'm stuck maintaining the mtl, i felt duty bound to come to the defense of its 'intended' usage pattern ;)
06:39:38 <Peaker> Maybe I ought to make a lens-transformers that makes concrete transformer values in lens
06:39:42 <dmwit> Throwing StateT on top of non-determinism already lets the state survive correctly.
06:40:02 <Peaker> dmwit, Yeah, it seems wrong now
06:40:34 <shachaf> tomboy64: What's the type of «read "hello"»?
06:40:35 <Peaker> something like:  askl = asks . Lens.view
06:40:55 <tomboy64> nand`: well, i'm not processing it any further - http://bpaste.net/show/57960/
06:40:59 <shachaf> Peaker: query?
06:41:02 <tomboy64> uhm String
06:41:15 <shachaf> ?
06:41:15 <pordan30> tomboy64: try compiling with -XNoMonomorphismRestriction, or adding an explicit type annotation (preferably the latter). in the example you posted, you encode, then decode, but don't do anything with decode; so ghc doesn't have enough information to infer a (monomorphic type) [i think this is right, i defer tothe experts].
06:41:16 <edwardk> dmwit: there is a usecase where you want it to keep the updated state when it backtracks
06:41:18 <Peaker> shachaf, yeah but for transformers rather than mtl
06:41:31 <shachaf> Peaker: Oh, I see.
06:41:33 <edwardk> i don't remember the logic used in parsec for the state parameter though, i ripped it out in trifecta
06:41:34 <Peaker> edwardk, can't you use ParsecT .. State   for that?
06:41:35 <dmwit> edwardk: hm
06:42:17 <Sonderblade> @hoogle FilePath -> [String]
06:42:19 <lambdabot> System.FilePath.Windows splitSearchPath :: String -> [FilePath]
06:42:19 <lambdabot> System.FilePath.Posix splitSearchPath :: String -> [FilePath]
06:42:19 <lambdabot> Prelude lines :: String -> [String]
06:42:26 <quicksilver> edwardk: a parser which remembers updated state during backtracks sounds pretty evil to me. Are you sure that's a usecase not an abusecase?
06:42:33 <edwardk> i'm not a good apologist for the parsec state use. i don't use it ;)
06:42:35 <tomboy64> uhm
06:42:38 <Sonderblade> @hoogle FilePath -> [FilePath]
06:42:39 <lambdabot> System.FilePath.Windows splitDirectories :: FilePath -> [FilePath]
06:42:39 <lambdabot> System.FilePath.Posix splitDirectories :: FilePath -> [FilePath]
06:42:39 <lambdabot> System.FilePath.Windows splitPath :: FilePath -> [FilePath]
06:43:04 <edwardk> aha. its the other way around. it does forget user state on backtracking
06:43:14 <edwardk> BUT you can't apply StateT to parsec and still use the combinators
06:43:27 <edwardk> and ParsecT .. State has the wrong semnatics
06:43:33 <edwardk> that was why
06:43:36 <Cale> I really really wish that attempting to switch to a VT didn't completely hose my machine.
06:43:54 <edwardk> if something like my 'parsers' library had existed at the time, you could have avoided user state in parsect
06:44:17 <shachaf> Cale: If I'm attempting to switch to a VT, it's usually because my machine is already hosed. :-)
06:44:21 <Peaker> edwardk, you can't apply the combinators without a mapStateT you mean?
06:44:41 <edwardk> Peaker: yes, because everyone wants to work with a monstrous pile of mapStateT's sprinkled through their parser
06:45:05 <nand`> tomboy64: you're pressing it further in line 10-12, to the monomorphic type IO ()
06:45:06 <edwardk> :t mapStateT
06:45:08 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
06:45:08 <neutrino_> Cale: can this have to do with bad graphics drivers?
06:45:18 <peopleHands> Has anybody had an issue with ghc-mod running everytime they type in vim?
06:45:29 <spaceships> dmwit: i think i was making it more complicated than it is. thanks for your assistance :)
06:45:30 <Cale> neutrino_: Probably.
06:45:32 <edwardk> also have fun writing things with many and other parser combinators that take parsers like that ;)
06:45:33 <neutrino_> peopleHands: what's... fairly surprising?
06:45:46 <edwardk> it was a pain getting all of those to work right in parsers without a huge api in the class
06:45:52 <neutrino_> peopleHands: do you have the syntastic plugin perhaps?
06:45:56 <peopleHands> Yes!
06:46:09 <neutrino_> peopleHands: turn it off with :SyntasticChangeMode
06:46:10 <Peaker> edwardk, well, I guess the user who needs something other than StateT thrown in there is going to have to find this kind of solution anyway, so might as well try to solve the generic case
06:46:14 <neutrino_> i believe that's the right command
06:46:18 <nand`> tomboy64: since ‘decode’ gives the polymorphic type FromBencode a => Maybe a; and you pattern match on it right after, it never knows what type the ‘a’ is - which can influence whether or not the result is ‘Just <something>’ or Nothing
06:46:24 <edwardk> @hackage parsers
06:46:25 <lambdabot> http://hackage.haskell.org/package/parsers
06:46:27 <edwardk> Peaker: i did =P
06:46:37 <edwardk> like i said, i'm a terrible apologist for the parsec approach because i don't like it
06:46:46 <Peaker> edwardk, ah, cool
06:46:47 <edwardk> but they needed the state in there for the design they had =P
06:46:51 <neutrino_> peopleHands: if you use vim for haskell you might find this little command i made fun.. it lets you select a type, and creates a function for it using djinn
06:47:29 <peopleHands> @neutrino_ I've got a toggle mode for syntastic but no change =/
06:47:29 <lambdabot> Unknown command, try @list
06:47:39 <peopleHands> neutrino_ I've got a toggle mode for syntastic but no change =/
06:47:41 <neutrino_> right toggle is ok
06:48:00 <peopleHands> It's still doing it D:
06:48:09 <hpaste> Underbyte pasted “one more bug” at http://hpaste.org/77737
06:48:09 <neutrino_> try removing it from your vimrc
06:48:24 <Underbyte> if anyone would like to help, i seem to have one more bug that needs fixing
06:48:30 <tomboy64> nand`: well, it should give me a result. i really don't understand the mistake i'm making. :(
06:48:32 <Underbyte> i would greatly appreciate it
06:49:06 <neutrino_> http://hpaste.org/77736
06:49:11 <Underbyte> basically, the counters aren't updating. the incrementCounters function seems to update them correctly, but if you try using calculateNewIndex, they dont update.
06:49:24 <tomboy64> The monomorphism restriction is probably the most annoying and controversial feature of Haskell's type system. All seem to agree that it is evil, but whether or not it is considered a necessary evil depends on who you ask.
06:49:28 <Underbyte> you can setup the program with 'let gameState = setup rawInput'
06:49:28 <tomboy64> hahaha
06:49:36 <tomboy64> gonna do some reading now :)
06:50:07 <nand`> tomboy64: imagine the following: assuming class Decode a where decode :: ByteString -> Maybe a; suppose we write: instance Decode Int where decode _ = Just 5; instance Decode Char where decode _ = Nothing
06:50:28 <Peaker> the MR is supposed to prevent confusion about performance by inserting lots of confusion about type checking
06:50:46 <nand`> what would your code in line 10 return? well, depending on whether or not you're trying to decode Int or Char, it will be ‘Just 5’ or ‘Nothing’; ie. putStrLn "bla" or putStrLn "nix"
06:50:56 <tomboy64> nand`: okay?
06:51:14 <Philippa> nand`: ...we have defaulting for that problem
06:51:38 <nand`> Philippa: since when does the compiler default arbitrary typeclasses?
06:52:57 <Philippa> nand`: eh, nobody's written the extension to allow you to ask it to?
06:53:21 <byorgey> nope
06:53:28 <nand`> even if there's such an extension (I don't know), I doubt tomboy64 would have written defaulting rules for his class then
06:53:34 <Philippa> well that sucks :p
06:53:34 <sam4> In Control.Monad.Random, what is the function that is equivalent to state?
06:53:36 <sam4> :t state
06:53:38 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
06:53:46 <Philippa> nand`: sure. The point is, MR isn't really about defaulting
06:53:55 <nand`> I wasn't talking about the MR
06:53:58 <tomboy64> please, i'm a beginner :-/
06:54:00 <Philippa> fair enough, my bad
06:54:09 <nand`> I was trying to illustrate why he's getting ambiguous type errors
06:54:14 <Philippa> tomboy64: ignore me, listen to nand`
06:54:42 <nand`> tomboy64: anyway it boils down to “the compiler doesn't know which instance you want”
06:54:49 <nand`> add a type signature; for example ‘decode z :: Maybe Int’
06:55:23 <byorgey> sam4: there isn't one
06:55:28 <byorgey> sam4: why do you need it?
06:55:31 <Philippa> edwardk: so I think we have this really sucky situation about interfaces for monadic operations once lifting happens, and I'm wondering if we're starting to acquire the tools to unfuck it properly?
06:55:48 <edwardk> ?
06:55:52 <beaky> hello
06:56:09 <tomboy64> mhmkay
06:56:12 <Philippa> though I suspect the pretty answer needs negated constraints and a sensible way to say "there should not be an instance for..."
06:56:16 <edwardk> oh, the negative position thing?
06:56:40 <Philippa> (then you pick a family of constraints that's "I have a direct implementation" as opposed to "I can build one", negate /those/ for everything but the ones you supplied...)
06:56:50 <sam4> byorgey: I have a function g -> (a,g) and I was wondering if I could change this to Rand g a
06:56:57 <shachaf> Philippa: It can't be done. :-(
06:56:58 <sam4> I am not sure if this is possible
06:57:09 * shachaf is a pessimist about this particular issue.
06:57:18 <beaky> if haskell is based on the lambda calculus (i.e. it essentially implements it), then what are the other programming languages like C and Java based on?
06:57:29 <byorgey> sam4: it is not possible.  My bigger question is, why do you have a function of type  g -> (a,g).  Where did that function come from?
06:57:41 <Philippa> shachaf: I'm assuming willingness to change the type system a little here, FWIW. "There will not be an" instances being a potential tool for utter dickishness, of course
06:57:41 <edwardk> Philippa: i failed to follow the launch of this line of inquiry, so i have no idea what you are talking about
06:57:49 <byorgey> sam4: probably you can instead do whatever that function does but in the Rand monad
06:58:17 <Philippa> beaky: there isn't a simple/obvious answer the same way. Algol was an important predecessor
06:58:20 <beaky> ah
06:58:35 <sam4> byorgey: well I have a function that gives a random values but I wanted to hide the generator state
06:58:40 <Philippa> edwardk: ah. You were complaining about what happens when you slap a StateT on top of parsec?
06:58:40 <pordan30> beaky: have a look at register machines
06:59:00 <Philippa> (and there's a more general problem there, and it's shit: if your monad [transformer layer] isn't part of MTL, things hurt)
06:59:02 <edwardk> Philippa: i thought that was where you were going, but wasn't sure =)
06:59:09 <peopleHands> neutrino_: I just completely removed syntastic and it's still running !ghc-mod everytime I type. Eugh.
06:59:13 <byorgey> sam4: did you write that function yourself?
06:59:16 <mSSM> I am trying to read and "desugar" the do-lines on lines 39 to 46 in this code: https://github.com/aivuk/Simple-Ising/blob/master/ising.hs  is there some program that can help me with that?
06:59:17 <edwardk> anyways the negative position thing is generally a hard problem
06:59:26 <sam4> byorgey: yes
06:59:30 <edwardk> i just give in an write lots of instances
06:59:32 <byorgey> sam4: so just rewrite it using Rand.
06:59:40 <Philippa> pordan30: yep. But also look at the turing machine /as a device that exists to convince us it's a general computer on the assumption a human with infinite pencil and paper is/
06:59:48 <copumpkin> Rand Any
06:59:54 <copumpkin> (whoops, typo)
06:59:57 <copumpkin> GHC.Prim.Ayn
07:00:01 <sam4> byorgey: so I am new to Monad so I am not sure what you mean by rewrite it using Rand
07:00:15 <mSSM> I know that lambdabot can "undo" stuff, but I am not sure how to give it a part of the program + the libraries and function and type declarations it needs.
07:00:29 <beaky> ah
07:00:30 <edwardk> e.g. https://github.com/ekmett/parsers/blob/master/Text/Parser/Combinators.hs#L263
07:00:49 <Philippa> edwardk: yeah, my tolerance for this shit is growing increasingly limited!
07:01:02 <edwardk> mSSM: @undo is a purely syntactic transformation, it needs no type info
07:01:11 <beaky> isn't C so abstracted away from the register machine compared to Haskell, which is just the typed lambda calculus + constants and nice syntax and modularity?
07:01:15 <Philippa> (is my proposed solution clear enough?)
07:01:29 <beaky> and how do objects and classes fit into the concept of register machine/von-neumann machine?
07:01:34 <mSSM> edwardk: cool, I will try it and see what happens then :-)
07:01:37 <beaky> i.e. what theory is behind OOP?
07:01:53 <sam4> byorgey: hpaste.org/77738
07:01:55 <pordan30> Philippa: if you mean that turning machines can be viewed as devices to convince us that register machines are general computers, sure; but then /anything/ equivalent to turing machine can be viewed in the same way, and register machines therefore as devices to convince us that turing machines are general computers =)
07:02:01 <felix2> you should read William Cook's excellent paper about that beaky
07:02:11 <Philippa> beaky: There isn't a single theory behind OOP :-) But one of the nicer ones is that it's not about individual programs-in-the-smallest, it's about many programs communicating by message passing
07:02:21 <felix2> http://www.cs.utexas.edu/~wcook/Drafts/2009/essay.pdf
07:02:22 <edwardk> philippa: i don't know that i comprehend it well enough. its hard because i often have hard decisions to make that aren't obvious when defining those lifting operations, with multiple 'almost-correct-but-for-the-laws' alternatives available to me
07:02:22 <beaky> ah
07:02:48 <Philippa> pordan30: no, I mean that the actual design of the turing machine is a few mathematical transformations away from "I took that infinite pen and paper and replaced the human with a finite state machine"
07:02:56 <felix2> It's probably not exactly you asked for but it's still great
07:03:02 <felix2> +what
07:03:17 <Underbyte> is there an easy way to get the number of indicicies in an array?
07:03:46 <pordan30> Philippa: isn't that the opening argument of turing's paper =)
07:03:55 <Philippa> edwardk: *nod*. Those situations suck, yeah. I'm just proposing to build enough to write a once-and-for-all do-the-dumb-lifting instance by adding neg-instance declarations and then abusing ConstraintKinds etc
07:03:58 <killy9999> wow, GHC goves me linking errors
07:04:06 <killy9999> s/goves/gives/
07:04:08 <Philippa> pordan30: 'xactly. Hence, TMs are constructed for that in a way that, say, PCF isn't
07:04:21 <killy9999> never seen this happen before :/
07:04:34 <edwardk> Philippa: to be honest i don't think it'd work. i'd love to be proven wrong =P
07:05:24 <Philippa> (PCF is simply-typed lambda calculus with nats, bools and fix, for those who don't know)
07:05:38 <Philippa> aaand I appear to be travelling through a not-spot
07:06:27 <mSSM> edwardk: well, @undo does not like to give me a simpler form of lines 39 - 46
07:06:49 <edwardk> @undo is rarely simpler than the do style
07:06:50 <lambdabot>  Parse error at "do" (column 28)
07:06:51 <mSSM> edwardk: it throws parse errors
07:07:05 <edwardk> what are you saying to @undo?
07:07:14 <edwardk> give me the command you told lambdabot
07:07:50 <neutrino_> peopleHands: hmm
07:07:55 <neutrino_> peopleHands: can you post your vimrc?
07:08:17 <edwardk> and why do you want to @undo it anyways?
07:08:20 <byorgey> sam4: http://hpaste.org/77739
07:08:29 <byorgey> untested, but at least it compiles =)
07:08:42 <peopleHands> neutrino_: I solved it (: I had to change let g:neocomplcache_enable_at_startup = 1 to 0
07:08:42 <edwardk> that is mostly done for pedagogical purposes, just to understand the expansion
07:08:48 <beaky> why is functional programming better than OOP if OOP is closer to the way humans understand and think about the real world?
07:08:58 <peopleHands> neutrino: just cloned syntastic into my bundle again and it works fine
07:09:48 <mSSM> edwardk: I don't like the coding style...
07:09:54 <neutrino_> oh, neocomplcache, never used that one
07:10:00 <mSSM> edwardk: I am wondering if there is a nicer way to express things...
07:10:06 <neutrino_> can i see your vimrc anyways? maybe i can learn something new from it
07:10:25 <neutrino_> :)
07:11:03 <edwardk> @undo do rnumber <- random rg ; grid <| (i,j) <== spin (rnumber `mod` 2)
07:11:04 <sam4> byorgey: Oh I see... wow thanks
07:11:04 <lambdabot> random rg >>= \ rnumber -> grid <| (i, j) <== spin (rnumber `mod` 2)
07:11:15 <edwardk> that is the part you can @undo, the rest was a list comprehension around it
07:11:22 <sam4> byorgey: I didn't think of using randomR
07:11:32 <edwardk> [ … | i <- …, j <- … ] was unrelated to the do statement
07:11:38 <sam4> byorgey: I mean getRandomR
07:11:50 <edwardk> it was also a legitimate parse error because of where you'd put the ;
07:11:53 <rwbarton> @undo do { do { this; that } ; theother }
07:11:54 <lambdabot> this >> that >> theother
07:12:00 <peopleHands> neutrino_: here you go http://pastebin.com/VeWugnxg it's my super simple gvimrc :P
07:12:03 <mauke> The paste VeWugnxg has been copied to http://hpaste.org/77740
07:12:07 <Philippa> beaky: loaded question, many of us disagree
07:12:12 <rwbarton> @undo do { this; that; theother }
07:12:13 <lambdabot> this >> that >> theother
07:12:16 <Philippa> Do you really think about the real world as sending messages everywhere?
07:12:19 <Sonderblade> beaky: oop implies state, which is hard
07:12:26 <neutrino_> cool looking
07:12:30 <edwardk> @undo [ do { this; that } | i <- [1..] ]
07:12:31 <rwbarton> @undo [ [ (x, y) | x <- [1..10] | y <- [1..10] ]
07:12:31 <lambdabot> concatMap (\ i -> [this >> that]) [1 ..]
07:12:32 <lambdabot>  Parse error at "|" (column 27)
07:12:32 <pordan30> beaky: my two cents: there's a difference between object-oriented programming and subtype polymorphism. there are functional languages like ocaml and f-sub that implement subtyping in different ways. many people familiar with languages like java or c++ are not familiar with the message-passing style of a language like smalltalk.
07:12:38 <rwbarton> @undo [ [ (x, y) | x <- [1..10]] | y <- [1..10] ]
07:12:39 <lambdabot> concatMap (\ y -> [concatMap (\ x -> [(x, y)]) [1 .. 10]]) [1 .. 10]
07:12:43 <edwardk> it doesn't do list comprehensions etc.
07:12:44 <Philippa> edwardk: I could probably use a list of "this is the shit I find difficult" sometime? But probably to my inbox, and it won't be getting my attention for a lil' while
07:12:49 <rwbarton> it does, i just typod
07:13:05 <Philippa> (today, I am trying to generalise my constraint framework because I gave up and decided to use GHC7.6 anyway)
07:13:25 <beaky> ah
07:13:31 <edwardk> Philippa: well, i don't find it particularly difficult. ;) and i;m not sure the cure would be worse than the disease ;)
07:13:36 <edwardk> er wouldn't be
07:13:42 <neutrino_> peopleHands: that makes it very simple :)
07:13:56 <rwbarton> mSSM: to pass all of lines 39-46 you'd have to de-layout it correctly first
07:14:05 <rwbarton> I'd guess this is where you went wrong
07:14:29 <Philippa> edwardk: so personally, I think *people being stupid with the cure* would be?
07:15:01 <rwbarton> @undo do {g <- U.new $ n*n; grid <- return $ Grid (n, g); let { spin x = x + (x - 1) }; sequence_ [ do rnumber <- random rg; grid <| (i,j) <== spin (rnumber `mod` 2) | i <- [0..n - 1], j <- [0..n - 1] ]; return $ Ising (rg, grid)}
07:15:02 <lambdabot> U.new $ n * n >>= \ g -> return $ Grid (n, g) >>= \ grid -> let { spin x = x + (x - 1)} in sequence_ concatMap (\ i -> concatMap (\ j -> [random rg >>= \ rnumber -> grid <| (i, j) <== spin (rnumber `
07:15:02 <lambdabot> mod` 2)]) [0 .. n - 1]) [0 .. n - 1] >> return $ Ising (rg, grid)
07:15:19 <Philippa> like, making it widely understood that you don't add negative instances for classes that weren't defined for the purposes of having them might be an idea. Hell, maybe add that to the kind/constraint system and see how much it makes Conor puke :p
07:15:31 <Peaker> beaky, There's a nice paper "Why Functional Programming Matters"
07:15:37 <rwbarton> hmm, I guess @undo doesn't know about operator precedence...
07:15:58 <hkBst> > newtype I = Int
07:16:00 <lambdabot>   <hint>:1:1: parse error on input `newtype'
07:16:17 <neutrino_> is there a command-line tool which can perform @pl and @undo?
07:16:41 <S11001001> neutrino_: @pl is independently on hackage somewhere
07:16:56 <neutrino_> @hoogle undo
07:16:56 <lambdabot> package sundown
07:16:59 <neutrino_> no :\
07:17:04 <neutrino_> @hoogle pl
07:17:04 <lambdabot> Foreign.Ptr plusPtr :: Ptr a -> Int -> Ptr b
07:17:04 <lambdabot> package placeholders
07:17:04 <lambdabot> Language.Haskell.TH.Syntax PlainTV :: Name -> TyVarBndr
07:17:08 <beaky> Peaker: right I also read John Backus's paper on why functional programming is better than OOP
07:17:14 <neutrino_> no, lambdabot. No.
07:17:21 <neutrino_> S11001001: let me search for it a bit
07:17:43 <quicksilver> @hoogle pointfree
07:17:43 <lambdabot> package pointfree
07:17:51 <quicksilver> I think.
07:17:58 <hkBst> how to try data definitions with lambdabot?
07:18:03 <quicksilver> http://hackage.haskell.org/package/pointfree
07:18:05 <S11001001> quicksilver: yeah
07:18:08 <quicksilver> you can't, hkBst
07:18:17 <hkBst> quicksilver: how come?
07:18:20 <beaky> how do I get nice lambdabot things like the automatic pointfreeifier and the type querier on my own machine?
07:18:27 <quicksilver> hkBst: because that feature is not implemented.
07:18:42 <S11001001> beaky: :t is a feature of ghci
07:18:43 <quicksilver> beaky: ghci has a type querier
07:18:48 <beaky> ah right
07:18:52 <neutrino_> hmm, what about undo?
07:18:58 <neutrino_> i'll make a command for pl
07:19:00 <neutrino_> for vim
07:19:01 <quicksilver> I don't know.
07:19:03 <neutrino_> that'll be superuseful
07:19:15 <beaky> @undo and @pl are very cool
07:19:16 <lambdabot>  Parse error in expression at end of input
07:19:16 <Peaker> beaky, in imperative programming, including OOP, you communicate via mutating variables instead of passing an argument or returning a value. That means a type-checker can't help you much with code correctness, and it's harder to understand code or compose pieces of code
07:19:21 <quicksilver> There was a project to integrate lambdabot into ghci called goa
07:19:29 <geekosaur> there used to be ... that
07:19:31 <quicksilver> but it's not been well maintained
07:19:36 <neutrino_> i need this to be a command-line tool though
07:19:37 <quicksilver> and I suspect it won't work with recent ghcis
07:19:48 <geekosaur> not that lambdabot's been maintained much better
07:19:55 <neutrino_> :))
07:19:57 <beaky> is there a functional OOP language?
07:20:07 <rwbarton> looks like Undo is just built in to lambdabot
07:20:10 <geekosaur> OCaml?
07:20:21 <neutrino_> rwbarton: i could totally use it as a separate binary.
07:20:29 <neutrino_> btw, since we're at command line tools
07:20:36 <Iceland_jack> F#
07:20:38 <rwbarton> cabal unpack lambdabot and check out Plugin/Undo.hs, it's rather short
07:20:44 <neutrino_> is there a linux command which can tell me what package (installed or not) a module is?
07:20:46 <mapf> Scala?
07:20:49 <beaky> ah
07:20:50 <neutrino_> or even a website that can do it?
07:20:56 <neutrino_> rwbarton: i will, thank you
07:21:03 <beaky> I think hoogle does that
07:21:08 <Iceland_jack> “OOP functional language” → Google → result
07:21:18 <quicksilver> neutrino_: ghc-pkg
07:21:18 <geekosaur> neutrino_, ghc-pkg find-module
07:21:33 <geekosaur> (must be installled though)
07:21:50 <geekosaur> hoogle or hayoo for uninstalled ones
07:21:57 <neutrino_> ohh right
07:21:58 <neutrino_> thank you
07:22:01 <rwbarton> hmm, cabal actually has this information from 00-index.tar doesn't it
07:22:14 <neutrino_> rwbarton: that's what i thought..
07:22:16 <Philippa> Peaker: so there's an old mail Alan Kay sent that's rather interesting on the subject - he says he doesn't actually believe in mutation as a core/object-level operation, that it's a meta-level one
07:22:20 <neutrino_> i'm surprised cabal doesn't tell you that
07:22:25 <rwbarton> aside from flags I guess
07:22:37 <neutrino_> rwbarton: if i could get this info, i could implement immediate documentation lookup in vim
07:22:38 <Peaker> beaky, a lot of OOP is about encapsulating an object's mutable state and an API to mutate it. If you just have abstract types that you manipulate with functions -- you're just ordinary FP, not really "OOP".  You could say "OOP"ness here is subtyping, maybe
07:22:49 <Cale> beaky: I'm going to troll slightly and say Haskell. I honestly do think that while it's not designed specifically for OO, the features that Haskell has are quite sufficient to do a better encoding of OO than most typed imperative OO languages manage.
07:22:51 <neutrino_> that is, if you're on a function, you press K and you are presented with the docs for it on hackage
07:22:58 <Peaker> Philippa, not sure I understand what that means
07:23:12 <Sonderblade> @hoogle getFileSize
07:23:12 <lambdabot> No results found
07:23:33 <beaky> ah
07:23:51 <rwbarton> neutrino_: well if it's in code that builds then presumably you have the package installed, no?
07:24:17 <neutrino_> rwbarton: it's for code that doesn't build.
07:24:22 <rwbarton> I see
07:24:27 <neutrino_> which is a large amount of cases.
07:24:33 <rwbarton> sounds of limited use, but okay...
07:24:54 <neutrino_> imagine you download source of a package and want to understand it without installing all the deps
07:25:01 <Cale> beaky: You have first class functions and IO actions which can serve as methods, and you can form datatypes which collect them together.
07:25:07 <neutrino_> just like you just instructed me to do (cabal unpack lambdabot)
07:25:11 <rwbarton> oh
07:25:22 <neutrino_> see, it's common :)
07:25:28 <beaky> I wonder how something like OOP inheritance and polymorphism can be done in haskell though
07:25:38 <Iceland_jack> Polymorphism?
07:25:45 <merijn> Cale: Wouldn't ocaml be a better OOP functional language?
07:25:48 <Iceland_jack> It has parametric polymorphism
07:25:50 <beaky> like virtual functions
07:25:52 <Cale> Inheritance isn't so easy, but you don't want it anyway :)
07:25:57 <neutrino_> beaky: i wonder why my car doesn't want to eat this straw, all my horses liked it
07:25:59 <strebe> for polymorphism, there are typeclasses
07:26:01 <merijn> Although I've never used structural subtyping
07:26:07 <neutrino_> beaky: how can i make my car eat the straw?
07:26:25 <merijn> beaky: I grow more and more convinced every day that inheritance is one of the *dumbest* ideas *ever*
07:26:28 <beaky> so there are better techniques to achieve subtyping/code reuse tahan inheritance?
07:26:32 <strebe> as for functional OOP languages, the first standardized OO language was common lisp - though I suppose we could debate the 'functional' part
07:26:42 <Cale> beaky: So, a lot of what you need subtyping for in typed OO languages
07:26:43 <neutrino_> yes, they're called code reuse
07:26:45 <Iceland_jack> beaky: For how long have you been programming?
07:26:47 <strebe> beaky: yes. composition, for one
07:26:51 <beaky> Iceland_jack: since last year
07:26:56 <Cale> is the fact that those languages tie method implementations to the class definitions
07:27:02 <Cale> which is, imo, somewhat derpy
07:27:03 <S11001001> installed pointfree; irc now pointless
07:27:13 <neutrino_> rwbarton: is there a place i can add module-finding to a cabal wishlist? :)
07:27:50 <strebe> beaky: inheritance tends to be rather fragile and misused
07:27:58 <Philippa> beaky: that, er, explains a lot :p The questions you're asking aren't daft, but you're probably not entirely at a level to appreciate the answers properly
07:28:08 <beaky> ah
07:28:10 <Cale> beaky: What is an object supposed to be? Well, it's some kind of value which is interacted with via methods/messages, and the way in which it responds to those messages determines what it is.
07:28:21 <neutrino_> beaky: what you normally do is you create typeclasses
07:28:22 <rwbarton> maybe here? https://github.com/haskell/cabal/issues
07:28:31 <rwbarton> bug tracker link from cabal-install.cabal
07:28:33 <Philippa> Cale: zomg, it's a (bastardisation of a) coalgebra!
07:28:39 <Philippa> *dies of shock*
07:28:40 <Cale> right
07:28:41 <neutrino_> of which you can think of as the closest thing you'll get to oop interfaces
07:28:58 <neutrino_> rwbarton: right! thanks..
07:29:01 <neutrino_> i should've seen that
07:29:09 <quicksilver> merijn: to be fair, it's not a dumb idea. That sounds like it was the invention of dumb people. It was the invention of a bunch of smart people, it just turned out to be wrong.
07:29:30 <quicksilver> (admittedly the community at large doesn't agree that it's a settled fact that it was 'wrong' ;)
07:29:37 <Iceland_jack> )
07:29:53 <beaky> inheritance-based OOP seems to work out well, since C++, Java and C# are the most common programming languages in IT
07:30:02 <Iceland_jack> beaky: common != better
07:30:06 <Cale> beaky: The mistake which a lot of OO languages have made is putting the implementations of the methods into the classes rather than the objects. The reason this was done, originally, was that it was the 1950s or so, and we didn't know how to implement first class functions really well, but putting a bunch of code pointers in a statically determined table isn't too hard.
07:30:09 <strebe> beaky: you may find http://en.wikipedia.org/wiki/Liskov_substitution_principle to be an interesting read - it's short
07:30:21 <beaky> ah
07:30:46 <Cale> beaky: And then to make up for that, you had subclasses which let you redefine what the methods did.
07:30:48 <Peaker> beaky, the Java world has reached the sad realization that inheritance is to be discouraged as much as possible..
07:30:59 <strebe> beaky: you'll find a lot of that is because people are very careful in how they use inheritance in those languages (or else the results are bad), lots of failed projects, and that particular language features really aren't the biggest determinants of popularity
07:31:17 <beaky> oh
07:31:19 <strebe> all three of those languages largely piggyback on the success of c (and for the later ones, each other)
07:31:21 <Peaker> Cale, did Smalltalk have that consideration?
07:31:48 <hpaste> efie pasted “how to handle isEOFError?” at http://hpaste.org/77741
07:31:53 <beaky> I think javascript has the method definitions outside the classes
07:32:10 <strebe> Peaker: I'd be surprised, given how you can monkey-patch in smalltalk
07:32:37 <Underbyte> rather urgent question
07:32:38 <Underbyte> http://pastie.org/5377551
07:32:42 <Underbyte> has anyone seen that error before?
07:32:48 <merijn> efie: https://github.com/merijn/SNet2.0/blob/master/SNet.hs
07:32:57 <mSSM> rwbarton: thank you; can you maybe tell me why the let expression in the stuff passed to @undo does not need the `in' part ?
07:32:58 <merijn> efie: Search for globIn, that should give you an idea
07:33:08 <hpaste> Underbyte pasted “ref code” at http://hpaste.org/77742
07:33:12 <Cale> Peaker: Smalltalk had "code blocks" which were basically lambdas, and so didn't need to make that concession.
07:33:14 <felix2> you mean, has anyone ever had a type error? :)
07:33:27 <FireFly> beaky: JavaScript is completely devoid of the concept of classes--it's prototype-oriented rather than class-oriented
07:33:30 <Underbyte> felix2: for the life o me i can't find out whats wrong
07:33:34 <Underbyte> *of
07:33:56 <strebe> beaky: c++ is largely popular due to attempting to address shortcomings in c, which was popular, and being able to get along with c codebases, which were widespread; java and c# both had major corporations behind them, and were rather like attempts to do c++ better
07:34:12 <beaky> right
07:34:15 <efie> merijn: thanks, I will take a look
07:34:52 <merijn> efie: It basically has a loop that reads from stdin until it hits EOF and then reads from an MVar
07:34:54 <Cale> beaky: and right, this is one place where Javascript is actually somewhat sane -- its objects are just collections of procedures (and other fields), and it doesn't even have a notion of classes
07:34:59 <Peaker> Cale, that's where methods got put in classes, wasn't it?
07:34:59 <Underbyte> felix2:  do you know whats going on?
07:35:01 <beaky> seems a language's technical merits are the smallest factor in its popularity vs the availability of mature libraries, availability of programmers, backward-compatibility with other languages, big companies, etc.
07:35:05 <rwbarton> mSSM: "let { pat1 = expr1 ; pat2 = expr2 ; ... } ;" is a valid command in a do-block
07:35:19 <rwbarton> that form is not part of a let-expression
07:35:21 <strebe> beaky: pretty much; see the continued popularity of cobol in some circles
07:35:25 <Iceland_jack> beaky: not the smallest, but not its most significant by far
07:35:34 <merijn> efie: You could instead write to a Chan and then on EOF drain the channel
07:35:51 <geekosaur> Underbyte, what do you think that code should be doing?  it looks confused to me
07:35:58 <mSSM> rwbarton: alright, thanks
07:36:27 <Peaker> C# was the result of MS being banned from doing EEE to Java, afaik
07:36:27 <Cale> beaky: Basically what I'm trying to say is that the main reason for inheritance and subtype polymorphism in the first place is because of this mistake of sticking method implementations into the definition of the *types* of the objects.
07:36:34 <bartavelle> Underbyte, you want ot evaluate an IO action
07:36:36 <Philippa> beaky: not quite smallest, but
07:36:47 <Philippa> technical merits are at least part situational
07:36:48 <Underbyte> geekosaur: its not actually my code
07:36:49 <beaky> right
07:36:50 <merijn> Peaker: Bad mistake by the Java people, C# seems much saner than Java nowadays :p
07:36:53 <Underbyte> its the instructor supplied code
07:36:55 <bartavelle> Underbyte, this is the "scary" part about haskell, just une "read" instead
07:37:08 <Cale> beaky: A much more sensible thing to say is that the type of an object simply determines what the names and types of its methods are.
07:37:17 <bartavelle> Underbyte, well, it depends :)
07:37:27 <Peaker> merijn, when MS does EEE it's not to make their product compete, but to kill both
07:37:31 <Cale> beaky: and then you can produce many different objects of a single type like that, by implementing the methods differently
07:37:36 <beaky> so the only good classes in C++ are abstract ones?
07:37:42 <Cale> yes :)
07:37:50 <Peaker> merijn, preventing it saved Java and probably made C# compete on reasonable terms (which led to a nicer language now)
07:37:57 <sw17ch> Underbyte, in your error, what is yourMain?
07:38:03 <Iceland_jack> Why do you feel the need for such generalizations..
07:38:05 <merijn> Peaker: I have no problem with MS killing Java :p
07:38:06 <Peaker> in C++, you need classes for auto-destructors, which are a nice feature
07:38:13 <Cale> and ideally, you would have a constructor for that abstract class which lets you just plug in all the implementations of the methods
07:38:21 <Peaker> merijn, well, that would have left a big gap in the language-scape of 1996
07:38:24 <t7> c# is bloated as feck
07:38:34 <t7> need to trim the fat
07:38:45 <merijn> t7: Haskell on the other hand is lean as...
07:38:48 <strebe> beaky: for what it's worth, Java came into being because Sun couldn't get a license to do stuff with Smalltalk under reasonable terms
07:38:55 <Underbyte> sw17ch: i put the code on hpaste
07:38:59 <beaky> languages like C++ and Java do too much with classes; classes define a module, a namespace, an interface, data, procedures, etc.
07:39:06 <t7> merijn: i often say we need a lisp -> scheme, haskell -> ?
07:39:17 <Cale> beaky: agreed
07:39:18 <merijn> t7: Agda? Oh...wait...
07:39:24 <sw17ch> Underbyte: ah, i see now.
07:39:39 <t7> i mean common lisp or something bloated like that
07:39:40 <merijn> beaky: To be fair, C++ can do namespaces without classes
07:39:44 <beaky> ah right
07:40:04 <Cale> merijn: But that doesn't mean that it doesn't do them all over again with classes ;)
07:40:16 <Underbyte> what the hell is going on lol
07:40:28 <sw17ch> Underbyte: is the first section provided by your instructor?
07:40:37 <sw17ch> (Things coming before -- YOUR CODE SHOULD … )
07:41:15 <Underbyte> yes
07:41:47 <sw17ch> Underbyte: okay, do you understand what mapTuple is intending to do here?
07:42:00 <Underbyte> its trying to map a string to a touple
07:42:24 <S11001001> t7: core!
07:42:25 <sw17ch> Using the word 'map' here is misleading. It's parsing a string into a tuple.
07:42:41 <Cale> beaky: That said, there are some applications of subtype polymorphism even once you get rid of inheritance and the attachment of implementations to types -- it can be nice to say "oh, this type has a subset of the methods of this one, so you can cast things upward by forgetting some of them"
07:42:58 <Underbyte> do you see the problem?
07:43:00 <Cale> beaky: Which is not something that's automatic in Haskell, but of course, you can make a function which does it.
07:43:01 <sw17ch> > read "(0, 1, 2, [\"Hello Underbyte!\
07:43:03 <lambdabot>   <hint>:1:37:
07:43:03 <lambdabot>      unexpected end-of-file in string/character literal at end...
07:43:09 <Cale> (without much difficulty)
07:43:11 <sw17ch> oops
07:43:27 <sw17ch> > read "(0, 1, 2, [\"Hello Underbyte!\", \"How are you?\"], 'X')"
07:43:29 <lambdabot>   *Exception: Prelude.read: no parse
07:43:36 <Cale> or you can nest your records of methods in such a way that it just amounts to picking out a field
07:43:47 <sw17ch> > show (0, 1, 2, ["Hello Underbyte!", "How are you?"], 'X')
07:43:49 <lambdabot>   "(0,1,2,[\"Hello Underbyte!\",\"How are you?\"],'X')"
07:44:03 <Underbyte> aah i see
07:44:07 <Underbyte> it was a syntax thing
07:44:10 <Underbyte> stupid cod
07:44:12 <Underbyte> +e
07:44:20 * geekosaur suspects the "no parse" really meant "gimme a type"
07:44:28 <sw17ch> Yes. The difference between readIO and read is that it will interact with IO differently
07:44:32 <sw17ch> well, readIO will
07:44:37 <sw17ch> geekosaur: yes, your'e right
07:45:00 <sw17ch> > read "(0, 1, 2, [\"Hello Underbyte!\", \"How are you?\"], 'X')" :: (Int,Int,Int,[[Char]], Char)
07:45:02 <lambdabot>   (0,1,2,["Hello Underbyte!","How are you?"],'X')
07:45:32 <sw17ch> Underbyte: did that help?
07:52:49 <Underbyte> yes
07:58:38 <DMcGill> Is anybody that knows netwire here? In the yampa tutorial, a gun object has a field "fired :: Event ()". In netwire, is that equavilent to a "WireP GameInput ()" that will, at any one time, be inhibiting for notfired and producing () for fired?
07:59:19 * nand` thinks ‘Prelude.read: no parse’ should really have been ‘Ambiguous type a in Read a => a’
07:59:41 <DMcGill> isn't that a misleading error message though?
07:59:43 <Underbyte> real quick
07:59:50 <DMcGill> While it's technically true, it's not helpful most of the time
08:00:00 <typoclass> "Prelude.read: DO NOT WANT"
08:00:00 <Underbyte> i restarted ghci and now after loading my haskell file, all of my functions are out of scope
08:00:13 <DMcGill> :l *File.hs
08:00:15 <Underbyte> how do i change scope in GHCI to access any function? i dont remember
08:00:17 <Underbyte> aah
08:00:25 <Cale> nand`: That's not always the case
08:00:28 <DMcGill> you only need to do that if you've previously compiled
08:00:39 <nand`> Cale: sure; but in this context that's exactly what happened - it defaulted to (), causing the error
08:00:47 <Underbyte> i have previously compiled
08:00:50 <nand`> what I'm saying is that instead of defaulting to (), it should have thrown an ambiguous type error
08:00:53 <Cale> > read "()"
08:00:53 <nand`> to prevent confusing stuff like that
08:00:55 <lambdabot>   ()
08:01:03 <nand`> I don't think defaulting to () has ever come in handy
08:01:14 <nand`> (for me)
08:01:16 <DMcGill> isn't it monomorphism all over again?
08:01:20 <Cale> nand`: Usually it does, but with extended default rules turned on it defaults like that
08:01:21 <rwbarton> > [] -- this is what it's for
08:01:23 <lambdabot>   []
08:01:24 <Underbyte> Prelude> :| *assn2_part1.hs
08:01:24 <Underbyte> unknown command ':|'
08:01:27 <Cale> It's not the MR exactly
08:01:33 <Cale> it's ghci's extended default rules
08:01:33 <Underbyte> DMcGill
08:01:34 <DMcGill> "L" but lowercase
08:01:36 <DMcGill> not |
08:01:38 <Underbyte> ah
08:01:42 <DMcGill> :l is :load
08:02:01 <DMcGill> same for :r and :reload
08:02:04 <DMcGill> and probably more
08:03:00 <Cale> iirc, it just checks whether the thing you put after : is a prefix of exactly one command
08:03:32 <Cale> oh, I guess that can't quite be true
08:03:43 <Cale> because there's :run now
08:04:53 <neutrino_> hey guys can someone give me a complicated piece of haskell code that gets transformed with @pl?
08:05:10 <DMcGill> @pl f x = g (h x) x
08:05:11 <lambdabot> f = g =<< h
08:05:29 <neutrino_> that's not really complicated. got something that would take multiple lines?
08:05:40 <neutrino_> maybe including do or let?
08:06:16 <DMcGill> unless anybody else has suggestions, just do what I did except for multiple lines. It won't be pretty but it'll certainly transform it
08:06:34 <Cale> Does @pl even know about do/let?
08:06:37 <Cale> I didn't think it did
08:06:46 <peopleHands> What's the best method for dealing with IO errors? Is it Control.Exception?
08:06:47 <Cale> @pl \x -> do x; x
08:06:48 <lambdabot> (line 1, column 11):
08:06:48 <lambdabot> unexpected ';'
08:06:48 <lambdabot> expecting variable, "(", operator or end of input
08:06:48 <DMcGill> you may need to transform the do statements into >>= yourself
08:07:05 <Cale> @pl \f -> let x = f x in x
08:07:05 <lambdabot> fix
08:07:12 <Polarina> @pl \f a b c d e -> f a b c d e f
08:07:13 <Cale> okay, it knows about let :)
08:07:13 <lambdabot> flip =<< ((flip . ((flip . ((flip . (flip .)) .)) .)) .)
08:07:32 <DMcGill> it doesn't know about (.:) though :(
08:08:02 <pordan30> @pl \f g x y -> f (g x y)
08:08:02 <lambdabot> (.) . (.)
08:08:41 <S11001001> pordan30: and it gives unexciting things like eyeballs instead of "fmap fmap fmap"
08:09:19 <DMcGill> well what pordan32 was testing was to see if it'd give (.:)
08:09:20 <neutrino_> what is .: ?
08:09:29 <Sonderblade> any idea on how to write this function to size a file better? http://book.realworldhaskell.org/read/io-case-study-a-library-for-searching-the-filesystem.html#find.acquire.use.release
08:09:32 <DMcGill> (.:) = (.) . (.)
08:09:34 <hpaste> Underbyte pasted “moves” at http://hpaste.org/77743
08:09:36 <Underbyte> okay
08:09:42 <Underbyte> one quick problem to solve please
08:09:43 <DMcGill> > succ .: (+) $ 1 2
08:09:43 <neutrino_> what is it useful for?
08:09:45 <lambdabot>   *Exception: show: No overloading for function
08:09:46 <Sonderblade> the rwh example uses deprecated api
08:09:51 <DMcGill> > (succ .: (+)) 1 2
08:09:52 <efie> merijn: thanks! helped a lot
08:09:53 <lambdabot>   4
08:10:13 <neutrino_> got other examples?
08:10:13 <Underbyte> so if you look at line 95, i'm trying to go through the moveList
08:10:14 <DMcGill> it's like (.) except the first function has two arguments
08:10:21 <neutrino_> mhm
08:10:22 <DMcGill> so any time you have f (g x y)
08:10:25 <Underbyte> except that for some reason its not working correctly
08:10:29 <DMcGill> you can make that pointfree with f .: g
08:10:34 <neutrino_> ahh
08:10:36 <pordan30> @pl \h m f e -> g h m f >>= \(h1, a1) -> g h1 m e >== \(h2, a2) -> return (k (r a1 a2) h2)
08:10:39 <lambdabot> (`ap` (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip ((`ap` snd) . (. fst) . ((return .) .) . flip . (k .) . r) . ((flip . (((.) . (>==)) .)) .) . flip . flip g)) . ((flip . (((.) . (>
08:10:39 <lambdabot> >=)) .)) .) . g
08:10:55 <pordan30> i usually alias . to \circ and .: to \star, or whatever. but some people hate unicode in their source
08:10:56 <neutrino_> the pointfree command line tool hangs on this input: \f a b c d e -> f a b c d e f
08:11:22 <neutrino_> it doesn't on \h m f e -> g h m f >>= \(h1, a1) -> g h1 m e >== \(h2, a2) -> return (k (r a1 a2) h2)
08:11:29 <typoclass> Sonderblade: which part is deprecated?
08:11:59 <pordan30> the pointfree command line too seems to be broken; it hangs on lots of simple inputs at the same point in the transformation. you can use -v (or something) to see where it's hanging.
08:12:11 <Sonderblade> typoclass: bracket and handle i think
08:12:48 <neutrino_> @pl fst3 (a, b, c) = a
08:12:48 <lambdabot> (line 1, column 17):
08:12:48 <lambdabot> unexpected " "
08:12:48 <lambdabot> expecting operator
08:12:58 <neutrino_> @pl (a, b, c) -> a
08:12:58 <lambdabot> (line 1, column 13):
08:12:59 <lambdabot> unexpected '>'
08:12:59 <lambdabot> expecting operator
08:13:03 <neutrino_> what's going on?
08:13:10 <DMcGill> pl can't accept lambda functions
08:13:17 <DMcGill> and possibly not tuples it seems
08:13:21 <DMcGill> but to answer your question
08:13:35 <DMcGill> @hoogle (_,_,a) -> a
08:13:36 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
08:13:36 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
08:13:44 <geekosaur> @pl \(a,b,c) -> a
08:13:44 <rwbarton> in general it can't handle pattern matching
08:13:44 <typoclass> neutrino_: well "... = ..." is a definition, which pl doesn't do
08:13:45 <lambdabot> (line 1, column 7):
08:13:45 <lambdabot> unexpected "c"
08:13:45 <lambdabot> ambiguous use of a non associative operator
08:13:45 <DMcGill> in short, there isn't really a fst3
08:13:53 <rwbarton> @pl \(a,b) -> a
08:13:54 <lambdabot> fst
08:13:59 <typoclass> neutrino_: and yes, a lambda needs "\"
08:13:59 <rwbarton> though i guess in some cases it can
08:14:14 <S11001001> DMcGill: there's a library that typeclasses the tuple getters all up
08:14:35 <DMcGill> well it's easy enough to do with TH too, but I wouldn't recommend it
08:14:46 <neutrino_> @pl foo (a, b, c) = a
08:14:47 <lambdabot> (line 1, column 16):
08:14:47 <lambdabot> unexpected " "
08:14:47 <lambdabot> expecting operator
08:14:52 <neutrino_> why does it hang on that?
08:14:55 <DMcGill> might as well use ADTs and record syntax/lenses
08:15:14 <neutrino_> oh
08:15:19 <DMcGill> it seems that pl can't in general do tuples but some functions are hard coded in
08:15:20 <neutrino_> definition, pl doesn't do definitions?
08:15:22 <neutrino_> i didn't know that
08:15:22 <DMcGill> fst, fix and so on
08:15:34 <neutrino_> wait
08:15:36 <typoclass> neutrino_: erm, scroll up about 2 minutes, i told you :-)
08:15:38 <DMcGill> in the same way that hlint will suggest function replacements
08:15:39 <neutrino_> @pl foo x = bar x
08:15:39 <lambdabot> foo = bar
08:15:44 <neutrino_> see it does do definitions
08:15:54 <neutrino_> @pl foo x = x
08:15:54 <lambdabot> foo = id
08:15:59 <rwbarton> but it can't handle pattern match on (a, b, c), what would it produce
08:16:09 <neutrino_> @pl foo x:xs = x
08:16:09 <lambdabot> foo = head
08:16:21 <DMcGill> @pl ((x,_),_) = x
08:16:21 <lambdabot> (line 1, column 4):
08:16:21 <lambdabot> unexpected ","
08:16:21 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
08:16:22 <rwbarton> @pl foo (Foo x) = x -- similarly
08:16:22 <neutrino_> it can pattern-match on other things
08:16:23 <lambdabot> (line 1, column 14):
08:16:23 <lambdabot> unexpected " "
08:16:23 <lambdabot> expecting operator
08:16:40 <neutrino_> see it can pattern-match on lists..
08:16:42 <typoclass> Sonderblade: i dunno, it doesn't seem deprecated to me. http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html mentions those functions just fine. Control.OldException was deprecated for a long time and has recently been removed, but i don't think rwh uses OldException anywhere
08:16:47 <neutrino_> i guess it's some deficiency
08:17:03 <rwbarton> there is no way in general to handle pattern matching
08:17:18 <rwbarton> it happens to know about fst and head and so on so it can handle those cases
08:17:21 <Sonderblade> typoclass: read the comments, the getFileSize example doesn't compile
08:17:46 <geekosaur> typoclass, it doesn;t use Control.OldException; it uses Control.Exception from back when that was the old exceptions system
08:18:05 <typoclass> geekosaur: oooh :-(
08:18:10 <geekosaur> RWH doesn;t know about extensible exceptions at all, they did not exist when it was written
08:19:04 <typoclass> it's kind of evil to rename a module like that, reuse the name and some of the function names
08:19:14 <DMcGill> is there a GHC optimisation to turn data F = F !(Double,Double) into F !Double !Double behind the scenes?
08:19:24 <DMcGill> that way you can unbox them too
08:19:34 <DMcGill> or is that something I'll need to be doing myself?
08:19:48 <rwbarton> well those are different because tuples are not strict
08:20:45 <DMcGill> hmm, I think I'll wait until I start profiling things
08:21:40 <neutrino_> apparently applying pl and pf repeatedly to a line of code can create unreadable haskell
08:22:07 <DMcGill> have you never seen those translate-and-back websites?
08:22:13 <neutrino_> yeah
08:22:31 <geekosaur> "@pl" is an abbreviation for "pointless" for a reason :p
08:22:42 <neutrino_> i know :)
08:24:32 <nand`> apparently applying ghc and coghc repeatedly to a program can create unreadable haskell
08:24:37 <nand`> and very slow binaries
08:24:52 <neutrino_> that's because they're struggling for self-awareness
08:25:23 <JuanDaugherty> the people in glasgow?
08:25:35 <DMcGill> Scottish are technically people too
08:26:55 <b__> is there a site indexing Haskell-related papers?
08:26:57 <JuanDaugherty> well they're devolved
08:27:29 <pordan30> there's the research papers section on haskell.org and also a collection of functional pearls
08:40:55 <b__> @pl f (a:b:c:d:e:f:g:h:i:xs) = a
08:40:56 <lambdabot> f = head
08:41:32 <b__> basdirks@bas-2 ~> pointfree 'f (a:b:c:d:e:f:g:h:i:xs) = a'
08:41:32 <b__> f = ap ((`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . (`ap` tail) . (. head) . const . const . head) tail
08:41:39 <b__> fabulous
08:53:24 * hackagebot hflags 0.1.1 - Command line flag parser, very similar to Google's gflags  http://hackage.haskell.org/package/hflags-0.1.1 (GergelyRisko)
08:55:49 <ivan__> Hello! Is there any Haskell compiler that translates haskell source code into another high-level language (e.g. C++)?
08:56:05 <hiptobecubic> heh
08:56:06 <Cale> ivan__: Does javascript count?
08:57:07 <neutrino_> ivan__: you can write one in Haskell fairly easily
08:57:17 <neutrino_> @hoogle parsec
08:57:17 <lambdabot> Text.Parsec.Prim type Parsec s u = ParsecT s u Identity
08:57:18 <lambdabot> package parsec
08:57:18 <lambdabot> package parsec-extra
08:57:30 <neutrino_> @hoogle attoparsec
08:57:30 <lambdabot> package attoparsec
08:57:30 <lambdabot> package attoparsec-binary
08:57:30 <lambdabot> package attoparsec-enumerator
08:57:42 <neutrino_> here are some parser combinators.. have fun!
08:57:54 <pordan30> i thought that ghc used an intermediate representation based on c? can you extract that representation from the compiler?
08:58:05 <neutrino_> for simple haskell code you shouldn't have much of a problem parsing it and generating C.
08:58:15 <neutrino_> pordan30: nothing further from the truth.
08:58:43 <neutrino_> iirc, there was a C-like at some stage, though
08:59:44 <neutrino_> oh wait, actually it seems you should be able to extract the C-- compilation stage as C code
08:59:52 <pordan30> haskell.org/ghc states that ghc compiles to native code or llvm, but can generate c as an intermediate target
09:00:09 <hiptobecubic> well it no longer does so that should probably change i think
09:00:34 <geekosaur> yeh, the -fvia-C backend was removed
09:00:56 <neutrino_> oh right, that's why i remembered "haskell doesn't compile through C"
09:00:57 <hiptobecubic> i can't imagine it was readable c anyway
09:02:43 <ivan__> I was thinking about C++, plain C is to low-level and Javascript is too high-level
09:02:52 <ivan__> Thank you for suggestions!))
09:03:23 <jesyspa> ivan__: There was a very Haskell-like language that compiled to C++ templates, but I doubt that's what you're looking for.
09:03:31 <jesyspa> (Basically a subset of Haskell, if I remember correctly.)
09:03:56 <Cale> ivan__: What would be the point of compiling to C++ though?
09:04:04 <ivan__> And what is the name of this language&
09:04:23 <tromp__> to enter an obfuscated C++ code contest?
09:04:28 <jesyspa> Trying to remember now.  Something with "fun".
09:05:23 <ivan__> This is a research project to write compiler that can automatically parallelize functional source code
09:05:29 <tromp__> what triggers these bullshot Notices?
09:05:37 <ivan__> And parallelization library is written is C++
09:05:50 <Cale> ivan__: Like all the ones in the 1980s which were basically failures?
09:06:29 <Cale> The problem with automatically parallelising functional programs is that it's really hard to get granularity right.
09:06:58 <neutrino_> recompile online when you detect the granularity is wrong -> problem solved ;)
09:06:58 * Iceland_jack thinks it's strange to call research failure 
09:07:08 <ivan__> This problem is inherent not only to functional languages
09:07:18 <Cale> Iceland_jack: well, we found out exactly how hard it was :)
09:07:27 <Iceland_jack> :)
09:07:28 <neutrino_> Iceland_jack: there's a lot of failed research.
09:07:44 <Iceland_jack> neutrino_: Not in the sense I believe Cale meant it in
09:08:19 <DeadDork> Hi Haskell people! I've been playing around with xmonad for a year or two now, and really, really like it. So much, that I now want to learn Haskell! That said, everyone I talk to is warning me off. I know it's open ended, but I would really appreciate some advice. Thanks!
09:09:32 <Cale> Iceland_jack: I'm saying the research program of automatically parallelising functional languages was basically a failure in that it didn't manage to produce any practical way of doing that.
09:10:05 <b52> does a data type have to start with an uppercase character?
09:10:21 <Iceland_jack> Yeah I gotcha Cale, and that lead to different approaches
09:10:46 <Cale> b52: yes
09:10:46 <hiptobecubic> Cale, what you need is for the compiler to have access to profiling info
09:10:54 <Cale> b52: otherwise, it's a type variable
09:10:55 <hiptobecubic> Like compile, run program, recompile
09:11:09 <sipa> b52: constructors are upper case, variables are lower case; this is true both for types and values
09:11:20 <hiptobecubic> granted this is not practical for a huge collection of cases
09:11:27 <Cale> hiptobecubic: iirc, some of the better failures were like that ;)
09:11:45 <sipa> b52: so a in (Maybe a) is a type (variable), but it's not a type constructor
09:12:05 <Cale> But yeah, that's probably a good place to begin
09:26:34 <ziarkaen> If I evaluate head (map f xs), will f only be evaluated for the first element of xs due to lazy evaluation, or will if be evaluated for all elements of xs?
09:27:14 <geekosaur> the former
09:27:44 <latermuse> when should i use comonads over monads?
09:27:57 <mauke> ... over?
09:28:05 <latermuse> instead of
09:28:10 <latermuse> comonads instead of monads
09:28:13 <mauke> how would that make sense?
09:28:24 <c_wraith> you use each when the api they provide works
09:28:28 <c_wraith> they aren't interchangeable
09:28:34 <Eduard_Munteanu> latermuse: comonads don't replace monads, just like some monads don't replace other monads.
09:28:40 <c_wraith> It's like asking when you should read to a file instead of writing to a file
09:28:56 <c_wraith> *read a file
09:29:22 <latermuse> thanks
09:29:29 <Eduard_Munteanu> latermuse: but that being said, comonads tend to come up less often than monads, at least as far as FP is concerned.
09:29:34 <pordan30> what is the standard method or package for generating pure (pseudo-) random numbers, perhaps in the form of streams or infinite lists?
09:30:07 <johnw> latermuse: comonads let you consume values from a context, monads let you produce values in a context
09:30:36 <latermuse> the difference between monads and comonads is that the arrows are switched, correct?
09:30:37 <rwbarton> pordan30: System.Random (random package) is the standard one
09:30:45 <hiptobecubic> (it's slow)
09:30:56 <johnw> latermuse: the natural transformations are switched
09:31:01 <rwbarton> and has other deficiencies as well
09:31:07 <Eduard_Munteanu> latermuse: well yeah, they're dual to one another but that doesn't say much in itself.
09:31:09 <rwbarton> but mostly slow, yes
09:31:16 <latermuse> which is a commonly used comonad?
09:31:19 <pordan30> thanks. is there a preferred package, then, rather than a standard one?
09:31:27 <johnw> latermuse: the Store comonad
09:31:39 <Eduard_Munteanu> latermuse: zippers are comonadic, for instance.
09:31:55 <latermuse> lenses are comonadic, right?
09:32:01 <latermuse> and vinyl
09:32:14 <Eduard_Munteanu> You can implement lenses as Store comonads.
09:32:56 <latermuse> thanks guys, ever helpful :)
09:33:00 <johnw> latermuse: http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
09:33:49 <Eduard_Munteanu> Costate is just another name for the store comonad.
09:34:11 <johnw> latermuse: also see http://stackoverflow.com/questions/8766246/what-is-the-store-comonad
09:34:12 <Eduard_Munteanu> (since it comes from the same adjunction as the state monad)
09:43:16 <SaaMmY-laptop> hi all
09:43:31 <Eduard_Munteanu> SaaMmY-laptop: hi
09:43:33 <SaaMmY-laptop> haskell functionality is good or not?
09:43:57 <beaky> haskell is a purely functional programming language
09:44:04 <beaky> so it has the best functionality
09:44:06 <Eduard_Munteanu> SaaMmY-laptop: what do you mean by "functionality"? Being a functional language?
09:44:11 <SaaMmY-laptop> I mean some computer programming teacher says it is as unuseful as safe code programming
09:45:02 <Eduard_Munteanu> Safe code programming? Why, or how?
09:45:04 <SaaMmY-laptop> Ye I mean I have nothing against haskell I am seeking some reason more to accept that haskell is the right code to learn
09:45:07 <SaaMmY-laptop> as language
09:45:29 <SaaMmY-laptop> can I post a youtube link?
09:45:33 <SaaMmY-laptop> so all know what I mean
09:45:41 <Eduard_Munteanu> Ok.
09:46:10 <geekosaur> there are multiple definitions of safe.  some poeple will onlu consider the likes of Agda (which can;t do anything useful; usually the point of Agda programs is typechecking them) "safe"
09:46:18 <SaaMmY-laptop> http://www.youtube.com/watch?v=iSmkqocn0o
09:46:31 <SaaMmY-laptop> http://www.youtube.com/watch?v=iSmkqocn0oQ
09:46:34 <SaaMmY-laptop> sorry
09:46:38 <mauke> ...
09:46:55 <mauke> that's not "some computer programming teacher", that's Simon Peyton Jones
09:47:02 <SaaMmY-laptop> lol
09:47:05 <SaaMmY-laptop> sorry
09:47:08 <Iceland_jack> haha
09:47:11 <mauke> one of the designers of Haskell and authors of the principal Haskell compiler ghc
09:47:30 <SaaMmY-laptop> so what?
09:47:35 <SaaMmY-laptop> I am italian
09:47:40 <mauke> so I'm not going to watch it
09:47:44 <SaaMmY-laptop> I don't understood very well
09:47:48 <mauke> he's not going to say that haskell is useless
09:47:58 <SaaMmY-laptop> lol
09:47:59 <k00mi> he does sort of say so
09:48:05 <SaaMmY-laptop> yes
09:48:07 <k00mi> but he's joking
09:48:23 <SaaMmY-laptop> oooooo now I understand
09:48:30 <SaaMmY-laptop> I was in doubt
09:48:35 <SaaMmY-laptop> as italian
09:48:40 <beaky> lol
09:48:54 <k00mi> he basically says haskell starts as being safe but useless and then tries to get usefull, while most other languages start practical and try to get safe after that
09:49:00 <Eduard_Munteanu> I guess it's some sort of British humor. :P
09:49:41 <SaaMmY-laptop> good k00mi thank you for my understanding
09:49:54 <k00mi> no problem
09:50:18 <SaaMmY-laptop> so is haskell the "Nirvana"?
09:50:22 <nand`> no
09:50:23 <SaaMmY-laptop> XD
09:50:25 <nand`> not even close
09:50:30 <SaaMmY-laptop> ah ok
09:50:37 <nand`> Haskell is alright, but it's by no means perfect, and shouldn't be glorified
09:50:41 <nand`> at least that's my opinion
09:51:01 <SaaMmY-laptop> sure
09:51:03 <Eduard_Munteanu> It's got a glorious compiler, though. :P
09:51:09 <nand`> it suffers from too many drawbacks due to attempting to be relevant to real world programming tasks, rather than theoretical wankery only
09:51:12 <nand`> heh
09:51:31 <SaaMmY-laptop> nothing is perfect in real life and so oversurely on digital and artificial life
09:51:33 <nand`> for example the whole thing about unsafe* functions
09:51:38 <Iceland_jack> Shouldn't there be a #haskell-theoretical-wankery channel?
09:51:46 <k00mi> there is #agda
09:51:46 <nand`> Iceland_jack: #agda
09:51:47 <mauke> #haskell-in-depth?
09:51:48 <nand`> :)
09:52:05 <Iceland_jack> Very little is going on there
09:52:17 <nand`> communication is too practical
09:52:21 <Iceland_jack> :)
09:53:32 <SaaMmY-laptop> so c# and others stealt some idea from haskell?
09:53:43 <SaaMmY-laptop> is he saying that
09:53:51 <SaaMmY-laptop> that hairless guy
09:53:54 <Iceland_jack> I wouldn't say “steal”, ideas are borrowed
09:53:57 <Iceland_jack> “That hairless guy”...
09:54:00 <SaaMmY-laptop> lol
09:54:01 <SaaMmY-laptop> ok
09:54:11 <Iceland_jack> A lot of the ideas in LINQ are inspired by Haskell I believe
09:54:41 <coldpizza72i> Does (Num a, Ord a) in a type annotation mean it has to be both or either one?
09:54:42 <nand`> it's impossible to steal an idea
09:54:50 <Eduard_Munteanu> coldpizza72i: both
09:54:53 <nand`> plagiarism shouldn't be a negative thing
09:54:57 <DMcGill> Is anybody that knows netwire here? In the yampa tutorial, a gun object has a field "fired :: Event ()". In netwire, is that equavilent to a "WireP GameInput ()" that will, at any one time, be inhibiting for notfired and producing () for fired?
09:55:06 <SaaMmY-laptop> and can haskell compile with windows and mac and linux outputs?
09:55:20 <Iceland_jack> What is a “linux output”?
09:55:28 <strebe> if you mean binaries, yes
09:55:31 <nand`> I think he means binaries
09:55:33 <Eduard_Munteanu> SaaMmY-laptop: you can compile on any of those platforms.
09:55:34 <nand`> yeah
09:55:51 <SaaMmY-laptop> mmm I mean can haskell be the same language for windows linux and mac
09:55:52 <nand`> Windows, OS X x86 and linux x86 and x86_64 are tier 1 platforms of GHC
09:55:54 <SaaMmY-laptop> or any
09:55:58 <parcs`> DMcGill: yeah, i think so
09:56:09 <nand`> SaaMmY-laptop: Haskell is independent of architectures and implementations
09:56:10 <Eduard_Munteanu> It is portable, if that's what you're asking.
09:56:33 <parcs`> DMcGill: netwire 4 has it's an explicit Event type btw. are you using an older version?
09:56:36 <SaaMmY-laptop> how can haskell copulate with the others languages?
09:56:42 <SaaMmY-laptop> how does it happpen
09:56:45 <Iceland_jack> Copulate......
09:56:49 <nand`> the only non-portable thing in Haskell is the C FFI; so if you're hoping to actually implement it, the implementation needs to provide the appropriate C calls that some programs require eg. for I/O
09:56:58 <byorgey> well, you see, when two programming languages love each other very much...
09:57:22 <Eduard_Munteanu> Hehe.
09:57:31 <SaaMmY-laptop> I mean implementations
09:57:43 <SaaMmY-laptop> sorry I am wrong
09:57:57 <byorgey> SaaMmY-laptop: =)  I am just not sure what you are asking
09:58:00 <Iceland_jack> SaaMmY-laptop: “copulate” means to have sex
09:58:15 <DMcGill> parcs`: yes, I was just making sure I knew how it works
09:58:19 <SaaMmY-laptop> ok no I mean how can haskell implement the others languages
09:58:37 <DMcGill> I guess there's not much difference beteen WireP Input () and Event Input that you ignore the output of
09:58:42 <jmcarthur> haskell isn't quite as portable as i'd like, though. Int and Word are "native" sizes (which although this is a constant at compile time, it still means you have to be careful with, for example, communication between machines of different architecture, etc.)
09:59:06 <parcs`> DMcGill: right
09:59:09 <jmcarthur> and System.Info is a weird module (different values depending on the machine you run your program on, which are not in IO)
09:59:14 <jmcarthur> and so on
09:59:32 <k00mi> SaaMmY-laptop: you mean how do ideas from haskell end up in other languages?
10:00:21 <SaaMmY-laptop> I mean can I write first in java or c++ and then compile them with geany for example and then make an import c++.o intohaskell?
10:01:57 <DMcGill> http://www.haskell.org/haskellwiki/FFI_Introduction
10:01:57 <k00mi> SaaMmY-laptop: no, all you can do is call functions from a c library
10:02:01 <nand`> Haskell has a C FFI
10:02:26 <johnw> or extern "C" functions from a C++ library
10:02:35 <nand`> So you can, in practice, call external C functions; Java or C++ don't use the C ABI so afaik you'd need to write a C ‘wrapper’ to call those with whatever tools are provided by that language's implementation
10:02:45 <nand`> maybe C++ does
10:04:26 <SaaMmY-laptop> ok so libraries
10:04:38 <SaaMmY-laptop> ok I have reached the step33 on tryhaskell.org
10:04:42 <SaaMmY-laptop> how can i continue?
10:04:48 <Iceland_jack> SaaMmY-laptop: Go through Learn You a Haskell
10:04:54 <mauke> @where lyah
10:04:55 <lambdabot> http://www.learnyouahaskell.com/
10:06:12 <SaaMmY-laptop> nice free knowledge
10:06:22 <SaaMmY-laptop> it's exactly what I expeted
10:06:28 <johnw> :)
10:06:35 <niteria> @where rwh
10:06:35 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
10:06:55 <niteria> @where wyasi48
10:06:56 <lambdabot> I know nothing about wyasi48.
10:06:59 <niteria> @where wyasi
10:07:00 <lambdabot> I know nothing about wyasi.
10:07:25 <niteria> @where wyasi48h
10:07:25 <lambdabot> I know nothing about wyasi48h.
10:07:26 <SaaMmY-laptop> my university teacher has filled me up with c++
10:07:40 <niteria> write yourself a scheme in 48h is awesome
10:07:54 <SaaMmY-laptop> I got ballshitted for the first 2 weeks
10:08:00 <SaaMmY-laptop> of his lessons
10:09:32 <nand`> I think I took a quick glance at write yourself a scheme in 48h before deciding I don't like it
10:09:35 <nand`> been a while though
10:10:39 <dgpratt> is there a way to ask lambdabot what are all the valid responses of @where?
10:11:07 <rwbarton> @where where
10:11:08 <lambdabot> ^^^^^^
10:11:18 <rwbarton> thanks lambdabot
10:11:26 <dgpratt> heh
10:11:54 <SaaMmY-laptop> but a lot friends of mine are usual to write programs in c++ or java or python... c#... so I mean shall I be shamed for using haskell?if not why?
10:12:13 <coldpizza72i> Im studying for an exam… is this an adequate way of annotating a filter :: (Bool b) => (a -> b) -> [a] -> [a] instead of filter :: (a -> Bool) -> [a] -> [a]
10:12:22 <johnw> SaaMmY-laptop: if anything you should be proud
10:12:23 <capisce> SaaMmY-laptop: if not what?
10:12:27 <Iceland_jack> SaaMmY-laptop: what?
10:12:28 <rwbarton> coldpizza72i: no
10:12:33 <mauke> coldpizza72i: no, Bool is not a class
10:12:40 <coldpizza72i> o
10:12:52 <jmcarthur> well
10:12:59 <jmcarthur> there is a valid way to say that, with extensions
10:13:09 <jmcarthur> filter :: (Bool ~ b) => (a -> b) -> [a] -> [a]
10:13:12 <rwbarton> @quote rwbarton dog
10:13:13 <lambdabot> rwbarton says: A type class is not a type just like a dog house is not a dog.
10:13:29 <jmcarthur> but don't do what i just did
10:15:36 <SaaMmY-laptop> I have installed haskell ... now I type ghci so it starts and I notice it's 7.4.1 version
10:15:49 <SaaMmY-laptop> shall I get the last versione or it's fine
10:16:13 <geekosaur> we slightly prefer 7.4.2 but 7.4.1 is fine
10:16:38 <geekosaur> the latest version is generally reserved for folks who like hacking the fringes of type theory
10:17:54 <SaaMmY-laptop> nice I type same of tryhaskell.org and it works---- DUMBY HAPPY
10:18:38 <DMcGill> note that in (at least the latest version of) GHCi you can defined types and such in it
10:19:02 <capisce> SaaMmY-laptop: I'm still confused, do you mean "if I'm not shamed for using haskell then why?"
10:19:10 <DMcGill> but if it does give you trouble, make it in a .hs file then give GHCi the command :l File.hs
10:19:13 <capisce> because that doesn't make much sense
10:19:23 <SaaMmY-laptop> yes I am out
10:19:25 <SaaMmY-laptop> you know'
10:19:29 <SaaMmY-laptop> I am not in
10:19:39 <nand`> @google list homomorphism pearl
10:19:40 <lambdabot> http://dl.acm.org/citation.cfm?id=2034824
10:19:41 <lambdabot> Title: Generalising and dualising the third list-homomorphism theorem
10:20:23 <SaaMmY-laptop> the in guy who uses the coolest so thought program language
10:20:29 <SaaMmY-laptop> I am not that guy
10:20:56 <capisce> SaaMmY-laptop: heh, java and c# are definitely not the coolest programming languages
10:21:48 <SaaMmY-laptop> I trust all you but... I hope now only haskell will be the coolest in all thoughts
10:22:08 <SaaMmY-laptop> did you understand? I don't care however
10:22:11 <SaaMmY-laptop> XD
10:23:08 * geekosaur cares about "useful", what is this "coo?
10:23:31 <jmcarthur> haskell is so cool that some people even think of haskellers as elitists, which is not actually all that cool...
10:23:42 <Eduard_Munteanu> @protontorpedo
10:23:43 <lambdabot> syntax ur runing my high
10:24:23 <SaaMmY-laptop> haskell for me is cool just because it uses a very well built tryhaskell.org
10:24:29 <SaaMmY-laptop> that stuff is cool
10:25:01 <SaaMmY-laptop> haskell is all less elitist
10:25:29 <SaaMmY-laptop> because haskell I noticed at first cares to introduce everybody
10:27:21 <SaaMmY-laptop> aannnnndd monad ? wow that stuff is what? monad? ? ? *_*
10:27:58 <centrinia_> ?check const True -- How do you use lambdabot's QuickCheck feature these days?
10:27:59 <capisce> SaaMmY-laptop: take your time
10:28:01 <lambdabot>   Not in scope: `myquickcheck'
10:28:44 <rwbarton> @let myquickcheck = id
10:28:47 <lambdabot>  Defined.
10:28:47 <rwbarton> ?check const True
10:28:50 <lambdabot>   *Exception: show: No overloading for function
10:29:00 <parcs`> ah
10:29:06 <parcs`> why?
10:29:10 <rwbarton> pretty sure this is not how it is supposed to work
10:29:37 <nand`> something about quickCheck producing double output when run normally or something
10:29:37 <Eduard_Munteanu> SaaMmY-laptop: you might want to start with LYAH first...
10:29:39 <rwbarton> I guess some L.hs QuickCheck changes didn't get carried over
10:29:41 <Eduard_Munteanu> @where lyah
10:29:41 <lambdabot> http://www.learnyouahaskell.com/
10:29:42 <nand`> > quickCheck (const True)
10:29:43 <Eduard_Munteanu> SaaMmY-laptop: ^^
10:29:44 <lambdabot>   Not in scope: `quickCheck'
10:29:44 <lambdabot>  Perhaps you meant `myquickcheck' (line 28)
10:29:46 <nand`> ah
10:30:03 <SaaMmY-laptop> capisce I think you should know that your nick "capisce" means exactly the second voice of the verb to understand in italian language
10:30:07 <nand`> > Test.QuickCheck.quickCheck (const True)
10:30:09 <lambdabot>   Not in scope: `Test.QuickCheck.quickCheck'
10:30:13 * nand` gives up
10:30:23 <SaaMmY-laptop> the second voice plural of present
10:30:43 <rwbarton> L.hs from hackage doesn't include any QuickCheck stuff
10:31:10 <nand`> the one I had did; at least my local @check was working (slightly buggily)
10:31:18 <nand`> but that's outdated
10:31:25 <nand`> the newer ones don't even build for me (GHC 7.6.1)
10:31:37 <rwbarton> huh
10:31:37 <capisce> SaaMmY-laptop: yep, I probably should learn some italian with this nick...
10:31:50 <SaaMmY-laptop> Eduard_Munteanu don't worry it's what I am doing but I have matched all possibilities in terminal of linux and I found all the dictionary of haskell language so I think this is awesome
10:32:29 <SaaMmY-laptop> capisce=he understands
10:32:41 <SaaMmY-laptop> or he learns
10:32:57 <SaaMmY-laptop> I was wrong It's the third person of the verb
10:32:59 <SaaMmY-laptop> XD
10:33:13 <capisce> SaaMmY-laptop: right :)
10:33:21 <SaaMmY-laptop> so you are not italian
10:33:25 <SaaMmY-laptop> is it not?
10:33:35 <capisce> no, I am norwegian
10:33:45 <SaaMmY-laptop> well to know
10:34:40 <SaaMmY-laptop> LOOOOOOOL there is ^^ as code
10:35:05 <SaaMmY-laptop> Prelude.^^
10:35:46 <nand`> there are a few operators around various places that look like smileys
10:36:03 <Eduard_Munteanu> :t (.)(.)
10:36:04 <nand`> there's ^.~ somewhere I think
10:36:05 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
10:36:20 <SaaMmY-laptop> hahahahah
10:40:13 <hpaste> DMcGill pasted “Problem with arrow rec notation” at http://hpaste.org/77746
10:40:21 <beaky> what are the functor laws that must be obeyed?
10:40:28 <johnw> fmap id = id
10:40:32 <johnw> fmap f . fmap g = fmap (f . g)
10:40:36 <beaky> is it just that fmap f (fmap g x) = fmap (f.g) x?
10:40:39 <centrinia_> :t fmap id
10:40:41 <lambdabot> Functor f => f b -> f b
10:40:47 <DMcGill> http://www.haskell.org/haskellwiki/Category_theory/Functor
10:41:09 <beaky> is fmap an isomorphism?
10:41:16 <Eduard_Munteanu> No.
10:41:17 <johnw> it's a homomorphism
10:41:19 <beaky> oh
10:41:50 <Eduard_Munteanu> fmap is the arrow mapping part of a functor, it's not generally an isomorphism.
10:42:26 <johnw> I believe that an isomorphism would be fmap plus a function unfmap :: (f a -> f b) -> a -> b
10:42:43 <johnw> such that fmap . unfmap = id, and unfmap . fmap = id
10:43:40 <ion> instance Unfunctor [] where unfmap f a = head (f [a])
10:43:44 <Eduard_Munteanu> Or a functor that's both injective and surjective on arrows, I suspect.
10:44:13 <johnw> does "injective and surjective" mean bijective?
10:44:16 <beaky> http://ideone.com/8HwviH I want to implemnt all the morphisms on my own data structure. is my fmap correct?
10:44:27 <copumpkin> johnw: yeah
10:44:48 <johnw> beaky: yep
10:44:54 <Eduard_Munteanu> Yes, normal categories are Set-enriched and in Set mono+epi = iso.
10:46:14 <copumpkin> oh man, bos is out for blood on precog :P
10:46:24 <johnw> beaky: now prove your functor laws :)
10:46:56 <johnw> you can do it with equational reasoning by just substitution id for "f" in a call to fmap, for example
10:47:06 <beaky> llah
10:47:09 <johnw> and show how the result is identical to the input
10:47:14 <beaky> won't the typehecker prove it for me?
10:47:18 <johnw> no
10:47:25 <johnw> you can write broken Functor instances no problem
10:47:37 <johnw> or, you can write non-Functor Functor instances ;)
10:47:46 <bos> copumpkin: it rubbed me so deeply the wrong way
10:48:08 <trudko_> guys I am reading learning your haskell pleasant book to read, but I would appreciate some excercises so to really test if i understand what i read so far, any tips?
10:48:11 <Eduard_Munteanu> Actually... hm. I wonder if it's enough for the functor to be full and faithful.
10:48:15 <copumpkin> bos: same with a lot of people :) there was a lot of talk about it from @DRMacIver too
10:48:24 <m_fulder> hey, I have a function transformationsApply which I want to use in another function (rulesApply) which is suppose to find a Phrase in an array of phrasepairs .. is this possible by using my transformationsApply function?
10:48:30 * hackagebot dawg 0.3.0 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.3.0 (JakubWaszczuk)
10:48:31 <johnw> trudko_: work through projecteuler.net
10:48:43 <m_fulder> http://pastebin.com/J7Enhmg9  *
10:48:43 <johnw> most of the functions you write for that in Haskell will be quite small
10:48:46 <mauke> The paste J7Enhmg9 has been copied to http://hpaste.org/77747
10:48:53 <nand`> I don't recommend working through projecteuler.net
10:48:54 <sw17ch> copumpkin, bos: i've not really followed what's going on other than a 'working with Precog' page that was full of ass-hatery.
10:49:04 <nand`> it's not a good introduction to Haskell
10:49:09 <rwbarton> there's also that new computational biology problem site
10:49:23 <johnw> what is your recommendation, nand`?
10:49:25 <rwbarton> I haven't tried it but it seems like it might be a more programming-y project euler
10:49:34 <trudko_> johnw: thx for tips frankly I dont like maths problems that much ;D
10:49:44 <johnw> trudko: ok
10:49:46 <bos> sw17ch: that's basically the whole story
10:49:55 <copumpkin> sw17ch: there were several people who commented on it not being cool on twitter at least. Then there was a closely related post on reddit about peter molyneux doing the same thing, and half of /r/programming tore him a new one
10:50:02 <johnw> trudko: here's another approach: take a smallish program you've already in some other language, and port it to Haskell
10:50:04 <copumpkin> very timely!
10:50:20 <johnw> already written*(
10:50:27 <sw17ch> copumpkin: the reddit story was so similar i thought somehow Molyneux was involved with Precog
10:50:33 <copumpkin> bos: I dunno about you, but I'm a rockstar ninja brogrammer and I work 27-hour days in 6-week stretches, and I love it. I also benchpress while coding
10:50:33 <trudko> johnw:  yeah I will probably do that if i dont find something else
10:50:48 <nand`> johnw: I don't have one that I can just throw out; I do agree that writing haskell is the best way to learn haskell (once you have the basics down); but I think projecteuler puts too much emphasis on numerology and the theory of algorithm design; giving you less time to think about “how would I implement this functionally rather than imperatively?”
10:50:56 <centrinia_> copumpkin, do you even lift?
10:50:57 <johnw> trudko: that's how I learned Haskell, fwiw
10:51:06 <nand`> I think it's the basics you need to look at to start with; you can move from there onto complicated systems without ever having to go down the projecteuler road of math
10:51:16 <copumpkin> centrinia_: yeah, over 8000
10:51:18 <beaky> what would be the type of a catamorphism on a binary tree?
10:51:20 <Eduard_Munteanu> Right... an isomorphic fmap would be Hom(A, B) ~ Hom(FA, FB).
10:51:35 <bos> copumpkin: i actually sneak up behind people during code reviews and cut their throats if i find bugs
10:51:36 <copumpkin> beaky: try to figure it out! what is the "base functor" for the binary tree you want?
10:51:41 <sw17ch> > liftM (+) (return 8000) (return 1)
10:51:43 <lambdabot>   Ambiguous type variable `m0' in the constraint:
10:51:43 <copumpkin> bos: wow, that's hardcore. respect dude
10:51:44 <lambdabot>    (GHC.Base.Monad m0) aris...
10:51:59 <beaky> what is a base functor?
10:52:17 <copumpkin> beaky: it lets you "factor the recursion" out of recursive types
10:52:18 <m_fulder> hey, I have a function transformationsApply which I want to use in another function (rulesApply) which is suppose to find a Phrase in an array of phrasepairs .. is this possible by using my transformationsApply function? http://pastebin.com/J7Enhmg9
10:52:18 <mauke> The paste J7Enhmg9 has been copied to http://hpaste.org/77747
10:52:27 <beaky> ah, then it is Empty
10:52:33 <copumpkin> beaky: for list, it's data ListF a b = Nil | Cons a b
10:52:34 <copumpkin> nope
10:52:37 <beaky> oh
10:52:48 <copumpkin> then you have something like Mu tying the knot in the list
10:53:00 <beaky> data BinaryTree a = Empty | T a (BinaryTree a) (BinaryTree a) is wrong?
10:53:11 <nand`> the base functor is a functor f such that Mu f ≅ Tree; where newtype Mu f = Mu (f (Mu f))
10:53:19 <arcatan> Precog's challenge problem seemed interesting, though :P
10:53:19 <beaky> oh
10:53:21 <copumpkin> beaky: nope, you just haven't factored out the recursion there
10:53:25 <copumpkin> it mentions itself
10:53:31 <sw17ch> I'm trying to imagine what sort of code one would write after working for 27 hours straight.
10:53:42 <copumpkin> sw17ch: the most badass code ever conceived
10:53:54 <centrinia_> s/ass//
10:54:03 <copumpkin> centrinia_: do you even lift?
10:54:04 <beaky> GOTO
10:54:15 <centrinia_> copumpkin, 20 pounds. :p
10:54:16 <Eduard_Munteanu> beaky: Mu is a type-level fixed point combinator like fix is for values, in case you're not familiar with it.
10:54:24 <felix2> beaky: a base functor should represent one "step" or "layer" of your type, in a way
10:54:29 <sw17ch> actually, that 27 hour theory explains the state of this IP stack i'm trying to integrate...
10:54:30 <felix2> hum
10:54:32 <copumpkin> so data BTreeF a b = Empty | T a b b
10:54:40 <felix2> I mean, it should be one recursive step
10:55:03 <copumpkin> now, Mu (BTreeF a) ~ BinaryTree a
10:55:24 <felix2> well actually that's probably not a good explanation
10:55:42 <felix2> however I think if you know what fix points are at the value level it's easier to understand
10:55:56 <Eduard_Munteanu> m_fulder: you should ask in here, a lot more people can help
10:56:12 <Eduard_Munteanu> Ah, you did.
10:57:34 <beaky_> hello
10:57:37 <beaky_> oops
10:57:57 <beaky_> why is there an underscore in my nme
10:58:28 <Eduard_Munteanu> beaky_: your IRC client probably reconnected, ghost your other nick
10:58:41 <beaky_> how do I ghost
10:58:42 <sipa> because there's another beaky inline, according to the server
10:59:01 <sipa> it probably didn't notice you disconnected
10:59:08 <beaky_> oh
10:59:22 <Eduard_Munteanu> ^^
10:59:55 <sipa> s/inline/online/
10:59:58 <b__> now you can change =]
11:00:05 <beaky_> so a catamorphism on anything is simply substituting the cunstrocturs by the function?
11:00:12 <b__> s/in/on/
11:00:24 <DMcGill> parcs`: I have leftButtonPress :: EventP GameInfo. I would like to be able to produce object a when leftButtonPressed inhibits and some object b when it produces. object <- pure b <|> (pure a . leftButtonPress) -< gameInfo isn't quite what I want as I'd like to give a and b more info
11:00:31 <johnw> beaky_: huh?
11:01:15 <DMcGill> i.e. proc gameInfo -> do { x <- xPos -< gameInfo; object <- pure (b x) <|> (pure (a x) . leftButtonPress) -< gameInfo} doesn't work.
11:01:45 <DMcGill> ah, I got a and b mixed up there but it doesn't matter
11:02:03 <Eduard_Munteanu> beaky: a catamorphism is a generalized fold, basically.
11:02:29 <centrinia_> It tears down.
11:02:41 <beaky> oh
11:02:57 <johnw> a catamorphism reduces "size", an anamorphism expands it, a hylomorphism first expands then reduces
11:03:11 <johnw> in the Haskell sense, it makes a smaller thing out of a bigger thing, like [a] -> a
11:03:14 <beaky> ah
11:03:52 <parcs`> DMcGill: you might want 'exhibit'
11:03:53 <copumpkin> note that in total languages, the notion of a hylomorphism isn't well-typed
11:03:58 <centrinia_> Wood first expands then reduces?
11:04:04 <beaky> so hylomorphisms is like growing a tree and then picking the fruit?
11:04:19 <johnw> hylomorphism = unfold then fold
11:04:19 <beaky> or catamorphism . anamorphism?
11:04:20 <copumpkin> and you need to search far and wide to even figure out what category hylos make sense in
11:04:23 <felix2> well in practice you deforest
11:04:32 <felix2> so that there's no intermediate structure
11:04:44 <johnw> i believe that MapReduce is a hylomorphism, is that right?
11:05:03 <beaky> maybe
11:05:04 <copumpkin> it doesn't necessarily have an expansion step
11:05:22 <johnw> doesn't it expand [a] -> [(a,b)]?
11:05:26 <felix2> but seriously, unless you're really interested by all this stuff, you should focus on more intersting things
11:05:28 <shergill> what would be an example of a hylomorphism
11:05:52 <johnw> shergill: generating a numeric sequence from a seed, then summing the sequence
11:05:54 <shergill> actually, how are 'expansion' and 'contraction' defined here? as cardinality of the output set?
11:06:05 <shergill> johnw: gotcha
11:06:06 <felix2> If what interests you is applying Haskell to real world problems, I'm not sure you'll use that kind of thing
11:06:27 <johnw> category theory is definitely the brain candy of the Haskell universe though :)
11:06:37 <felix2> but if you're interested in theory then continue
11:06:43 <felix2> yeah
11:06:45 <DMcGill> parcs`: exhibit has a "you probably shouldn't use this function" disclaimer, is there a better way of including an event as part of an object?
11:06:47 <Eduard_Munteanu> Theoretical wankery at its best. :P
11:07:19 <beaky> :D
11:07:36 <copumpkin> shergill: I wouldn't even talk about big or small. Catamorphisms consume a structure and anamorphisms produce one
11:07:45 <DMcGill> Or making some field of an object dependant on if the input wire is blocking or not
11:09:44 <johnw> copumpkin: that's a good way to put it
11:10:05 <copumpkin> I actually have some agda that "shows" how data arises
11:10:16 <copumpkin> it probably won't mean much in isolation, though
11:10:43 <trudko> guys out of curiousity why IS OPP amore popular then it is functional? From what I understand functional programming is more safe which seems like benefit especially in corporate world.
11:11:01 <copumpkin> https://github.com/copumpkin/categories/blob/master/Categories/Functor/Algebras.agda#L107
11:11:35 <c_wraith> trudko: Functional programmer isn't really any safer.  (strongly typed programming might be safer).  But mostly, it's about history.
11:11:40 <c_wraith> *programming
11:13:50 <rAad> I would guess C++ and Java being taught in uni has a lot to do with it
11:13:50 <c_wraith> the dominant methodologies in the late 70s and early 80s weren't all that different from object-oriented programming - So when people showed up and said "Hey, this is better", it was easy to adopt bits and pieces of it slowly.
11:13:54 <trudko> c_wraith: do you have any article about it or would you mind share with me piece of your mind? and isn't it really safe?  i saw people saying that because you dont affec things that much it is less likely to have bug then i nproecedural language
11:14:17 <c_wraith> trudko: that's immutability, not functional programming.
11:15:34 <trudko> yeah I adont remember it corectly so it is probably something else
11:15:42 <coldpizza72i> > (filter (>25)) . reverse . (map (\x -> x^2) [1..15])
11:15:44 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
11:15:45 <lambdabot>    arising from a u...
11:15:49 <trudko> rAad: I would say that is effect rather then cause of it.
11:15:55 <beaky> so a catamorphism on a binary tree should have a type (a -> b) -> (a -> a -> b) -> BinaryTree a -> b ?
11:16:05 <coldpizza72i> why doesn't that work
11:16:12 <beaky> so a catamorphism on a binary tree should have a type (a -> b) -> (a -> a -> b) -> a -> BinaryTree a -> b ?
11:16:15 <beaky> oops
11:16:18 <trudko> Maybe it is because popularity of C? and it then C++ which wants to attrack C programmers
11:16:55 <felix2> no
11:17:28 <c_wraith> coldpizza72i: because the last part of that pipeline isn't a function
11:17:38 <johnw> beaky: (a -> b -> a) -> a -> BinaryTree b -> a
11:17:40 <c_wraith> > (filter (>25)) . reverse . (map (\x -> x^2)) [1..15]
11:17:42 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
11:17:43 <lambdabot>    arising from a u...
11:18:02 <c_wraith> > (filter (>25) . reverse . map (\x -> x^2)) [1..15]
11:18:05 <lambdabot>   [225,196,169,144,121,100,81,64,49,36]
11:18:07 <c_wraith> there.
11:18:09 <johnw> err, b -> a -> a is better
11:18:12 <johnw> by analogy with foldr
11:18:14 <c_wraith> Confused myself with extra parens
11:19:26 <c_wraith> coldpizza72i: (.) creates a function from two functions.  You were passing it an argument that wasn't a function - but GHC was trying valiantly to figure out how it might be
11:19:36 <coldpizza72i> k
11:19:38 <copumpkin> johnw: I don't think that's right
11:19:56 <c_wraith> coldpizza72i: that last part, it trying to figure out how it might be a function, is why you get a confusing error message
11:20:07 <copumpkin> johnw: you get two values at each level
11:20:19 <beaky> is filter a catamorphism?
11:20:28 <copumpkin> no
11:20:32 <johnw> copumpkin: except for leaves
11:20:48 <copumpkin> yeah, but you have the tree fold shaped like a list fold
11:20:51 <johnw> or maybe I mixing up his definition with another one that shachaf posted last inght
11:21:12 <copumpkin> (a -> a -> b -> a) -> a -> BinaryTree b -> a
11:21:14 <felix2> any function you can write using foldr is a catamorphism
11:21:14 <copumpkin> or something like that
11:21:19 <felix2> hum
11:21:21 <beaky> @src foldr
11:21:22 <lambdabot> foldr f z []     = z
11:21:22 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
11:21:23 <felix2> wull
11:21:25 <felix2> *well
11:21:26 <johnw> beaky: when thinking of morphisms in Hask, think about *types*, not values
11:21:29 <copumpkin> no, foldr is the catamorphism
11:21:32 <beaky> oh
11:21:32 <johnw> filter is [a] -> [a], which is not a catamorphism
11:21:55 <copumpkin> you can write all recursive functions on lists with catamorphisms, but that doesn't make everything a catamorphism
11:21:56 <felix2> any function f such that there exists g and z such that f = foldr g z is a catamorphism
11:21:59 <johnw> foldr is roughly [a] -> b, which is
11:22:01 <beaky> so why is  foldl is not a catamorphism even though it has the same types are same as foldr?
11:22:36 <copumpkin> felix2: whose definition?
11:22:53 <felix2> sorry?
11:23:02 <shergill> copumpkin: hmm how do you define structure? i.e., is list an adequate structure? if so is it correct to classify [a] → [a] functions as both a catmorphism and an anamorphism?
11:23:17 <johnw> well, I'd say it is a catamorphism, I'd like to hear copumpkin's answer to your question though
11:23:28 <felix2> no, some functions from [a] -> b are not catamorphisms
11:23:45 <johnw> felix2: why not?
11:23:46 <felix2> same thing for functions a -> [b]
11:23:52 <copumpkin> "the concept of catamorphism denotes the unique homomorphism from an initial algebra into some other algebra"
11:23:59 <johnw> because b could be [a]?
11:24:01 <beaky> foldl (+) 0 [a..e]
11:24:03 <felix2> because if they access the tail of the list they're not catamorphisms
11:24:11 <copumpkin> ...
11:24:16 <johnw> copumpkin: :)
11:24:32 <felix2> I meant I didn't understand your question
11:24:39 <copumpkin> felix2: I'm asking where you're getting these definitions from
11:24:46 <felix2> oh, ok
11:25:21 <felix2> hum I meant a list catamorphism if that's what you're asking about
11:26:28 <felix2> maybe you mean that foldr is a catamorphism, and not a function that is an instance of foldr?
11:26:38 <copumpkin> yes
11:26:41 <shergill> ok cata/ana/hylo-morphisms don't form a complete partitioning of the morphism space, correct?
11:26:45 <felix2> I'm rereading functional programming with bananas etc. to see what they use
11:27:07 <felix2> yeah they seem to use the same terminology as I do
11:27:33 <felix2> page 3, "a list-catamorphism h € A* -> B …"
11:29:33 <johnw> felix2: foldr doesn't access the tail of the list?  doesn't it's terminating condition match on the final []?
11:29:34 <felix2> it's true that it can be unclear how to translate the categorical definition to Haskell
11:29:46 <felix2> hum
11:29:52 <copumpkin> paramorphisms have direct access to the tail
11:29:57 <copumpkin> you can recompute the entire tail with foldr if you want it
11:29:59 <copumpkin> but it's slow
11:30:12 <felix2> what I mean is that it only accesses the result of the recursive call on the tail of the list
11:30:23 <felix2> not the tail itself
11:31:34 <parcs`> DMcGill: instead of pure a <|> pure b . foo why not pure a <|> f . foo ?
11:33:07 <parcs`> DMcGill: that way the 'success' result can depend on the output of the event
11:34:11 <copumpkin> felix2: hmm, alright, fair enough :)
11:34:24 <hpaste> beaky pasted “tree catamorphism” at http://hpaste.org/77751
11:34:36 <beaky> is it correct catamorphism?
11:34:44 <copumpkin> I doubt it
11:34:49 <beaky> right
11:34:51 <copumpkin> the type doesn't look right
11:35:11 <copumpkin> it should only need two cases
11:35:22 <copumpkin> and should have type (a -> b -> b -> b) -> b -> BinaryTree a -> b
11:35:41 <hpaste> DMcGill pasted “Attempted solution with gotEvent” at http://hpaste.org/77752
11:35:42 <beaky> right
11:36:04 <DMcGill> parcs`: that's what I've got now, what would a pointfree solution be?
11:36:06 <felix2> maybe you can try to write a function that sums all the elements of the tree to get some intuition
11:36:28 <beaky> right
11:36:45 <beaky> i should start with the instace, then ork my way to the catamorphism
11:36:54 <beaky> work*
11:42:16 <beaky> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
11:42:23 <beaky> :D yay
11:43:16 <beaky> ah
11:43:26 <beaky> what are monoids and what is mappend
11:44:14 <c_wraith> mappend is a slightly poor name for one of the two monoid operations.
11:44:39 <beaky> :t mappend
11:44:40 <lambdabot> Monoid a => a -> a -> a
11:44:41 <Cale> beaky: In mathematics, a monoid is a set M, together with a binary operation *: M x M -> M (usually called "multiplication"), and an identified element 1 in M, such that the following are true:
11:44:46 <johnw> beaky: http://comonad.com/reader/wp-content/uploads/2009/08/IntroductionToMonoids.pdf
11:44:51 <beaky> oh
11:44:55 <Cale> 1) for any a in M,  1 * a = a
11:45:00 <Cale> 2) for any a in M,  a * 1 = a
11:45:13 <Cale> 3) for any a, b, c in M,  a * (b * c) = (a * b) * c
11:45:21 <c_wraith> @src Monoid
11:45:21 <lambdabot> class Monoid a where
11:45:21 <lambdabot>     mempty  :: a
11:45:21 <lambdabot>     mappend :: a -> a -> a
11:45:21 <lambdabot>     mconcat :: [a] -> a
11:45:37 <Cale> 1 and 2 are called the left and right unit axioms, and 3 is called associativity
11:45:39 <beaky> monoid sounds like monad
11:45:41 <c_wraith> ..  Are there really monoids with better implementations of mconcat?  I guess First.  >_>
11:45:55 <johnw> beaky: careful, the rabbit hole beckons
11:45:56 <Cale> beaky: monad is a portmanteau of monoid and triad
11:45:56 <felix2> there's a link but it's quite complicated
11:46:02 <beaky> oh
11:46:18 <felix2> monoids often appear in mathematics
11:46:29 <felix2> for example, natural numbers, + and 0 make a monoid
11:46:29 <Cale> They often appear in computer science too :)
11:46:38 <felix2> because 0 + x = x, as you know
11:46:47 <Iceland_jack> function composition and the identity function...
11:46:47 <Cale> The theory of formal languages is secretly the theory of monoids.
11:47:01 <companion_cube> but people don't use the concept of monoids in maths that much
11:47:06 <companion_cube> because it's too simple
11:47:17 <neutrino> i would love to see some uses for non-commutative groups
11:47:26 <jesyspa> neutrino: Er, matrices?
11:47:44 <neutrino> that's not really what i meant.
11:48:09 <neutrino> i meant expressing language features as features of a nonabelian group.
11:48:19 <neutrino> or groups.
11:48:27 <nejucomo> I don't understand fail.  Where does the argument string "go" if I'm creating my own monad.
11:48:32 <neutrino> kind of like monads are being used.
11:48:36 <jesyspa> Ahh.  Not aware of that, but am curious.
11:48:38 <c_wraith> nejucomo: just ignore fail. It's terrible
11:48:39 <copumpkin> nejucomo: up whoever designed the class's ass
11:48:45 <nejucomo> Ooooh, nevermind.  It's a typeclass method.
11:49:41 <nejucomo> Ok, but some Monad instances will use fail as part of their API, right?
11:49:47 <c_wraith> they shouldn't
11:50:14 <c_wraith> [] is probably the only one that does in idiomatic code. And I argue that it should stop being idiomatic
11:50:42 <nejucomo> Specifically the Parsec parsing monad relies on fail.
11:50:45 <neutrino> do you suppose that operations on data could be seen as a group?
11:51:24 <nejucomo> I have no idea what fail means in the context of [], but in parsec it's quite obvious.
11:51:44 <DMcGill> can all current instances of fail be replaced with mzero?
11:51:48 <neutrino> a delete is the inverse of an insert, but is an insert the reciprocal of a delete? i don't think so
11:51:52 <DMcGill> or empty or something
11:52:00 <neutrino> unless we can create "negative data"?
11:52:37 <neutrino> when moving data around you can look at the operations as commutative and invertible
11:52:54 <c_wraith> nejucomo: parsec shouldn't use fail for that. It's an abuse of fail. It should use a combinator specifically for that purpose. mzero happens to be specifically for that purpose, for instance
11:53:08 <neutrino> so maybe if you have a data structure, a delete should really be a "move to trash"?
11:53:50 <shergill> where can i read up on the reasoning/motivation for adding fail?
11:54:05 <shergill> or can someone here enlighten me?
11:54:26 <neutrino> in this case you could optimize work quite nicely. suppose you have a slow medium and someone naiively tells the runtime to delete the whole tree, element by element, starting from the furthest. of course, if you look at the whole sequence, you can infer that you just need to delete the root and you're done.
11:54:36 <copumpkin> shergill: it lets you overload what happens with failed pattern matches
11:54:40 <copumpkin> (unfortunately)
11:54:52 <c_wraith> failed pattern matches *in bindings in do blocks*.
11:54:55 <c_wraith> Not in general
11:55:02 <copumpkin> > do x <- [1,2,3]; Just y <- [Just True, Nothing, Just False]; return (x, y)
11:55:03 <lambdabot>   [(1,True),(1,False),(2,True),(2,False),(3,True),(3,False)]
11:55:10 <neutrino> or suppose you had a data manipulation sequence which deleted a piece of data from a set and then re-inserted it. it would become a noop.
11:55:39 <DMcGill> > fail undefined :: [Int]
11:55:41 <lambdabot>   []
11:56:00 <shergill> copumpkin: how was that handled prior to fail?
11:56:12 <copumpkin> > do Nothing <- Just 5; return ()
11:56:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe t0))
11:56:14 <lambdabot>    arising from the lit...
11:56:21 <DMcGill> I would imagine like a runtime error
11:56:21 <copumpkin> > do Nothing <- Just (5 :: Int); return ()
11:56:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
11:56:23 <lambdabot>              with actual type ...
11:56:28 <DMcGill> like any other binding failing to match
11:56:36 <DMcGill> any other pattern match*
11:56:37 <copumpkin> meh
11:56:54 <nejucomo> Uh... why would you ever *overload* pattern match failure?
11:57:09 <DMcGill> let f Nothing = True in f (Just undefined)
11:57:12 <DMcGill> > let f Nothing = True in f (Just undefined)
11:57:14 <lambdabot>   *Exception: <interactive>:3:5-20: Non-exhaustive patterns in function f
11:57:20 <felix2> it's cool, you can feel like you're doing C++ ;)
11:57:21 <c_wraith> mostly for the sake of terrible idioms.
11:57:23 <nejucomo> Actually, I'm pretty unclear on pattern match failures.  I thought those were somehow intrinsic exceptions.
11:57:32 <c_wraith> @src catMaybes
11:57:32 <lambdabot> catMaybes ls = [x | Just x <- ls]
11:57:35 <mapf> 30 slide from that presentation about monoid are great
11:57:37 <rwbarton> it's pretty useful in the list or similar logic-y monads
11:57:46 <neutrino> mapf: got a link?
11:57:48 <mapf> s/monoid/monoids
11:57:59 <c_wraith> I really think the ability to write catMaybes like that is *not* worth having something like fail
11:58:02 <mapf> neutrino: yes
11:58:23 <rwbarton> well list comprehension notation is defined separately anyways
11:58:34 <nejucomo> Hm, I still don't understand how the list monad is overloaded.
11:58:36 * nejucomo experiments.
11:59:08 <c_wraith> in lists, fail _ = []
11:59:15 <nejucomo> Ok, so in the list monad it acts like a filter?
11:59:25 <c_wraith> or tree pruning
11:59:31 <mapf> neutrino: http://comonad.com/reader/wp-content/uploads/2009/08/IntroductionToMonoids.pdf
11:59:32 <beaky_> hello
11:59:35 <geekosaur> it's a branch with no results
11:59:41 <nejucomo> I must say that's pretty surprising.
11:59:47 <c_wraith> if you think of the list monad as evaluating a tree of computations
11:59:55 <geekosaur> then all branches get collapsed together into a resultlist
11:59:57 <rwbarton> or a little constraint programming language
11:59:58 <c_wraith> fail is "stop evaluating this tree"
12:00:06 <nejucomo> But haskell *is* pretty overload-happy, so I suppose it seems consistent.
12:00:07 <beaky_> 'msg nickserv ghost beaky ayeui2idgve
12:00:08 <nejucomo> -ish
12:00:25 <simon> is there a typeclass for things that can be added?
12:00:37 <c_wraith> simon: what kind of added?  like arithmetic?
12:00:50 <nejucomo> c_wraith: Ok, I'll buy that.  But why the string argument in that case?
12:00:54 <neutrino> thank you mapf
12:01:09 <nejucomo> It seems as if it's kind of mashing together two abstractions.
12:01:11 <c_wraith> nejucomo: the argument was intended to be the pattern match failure message
12:01:15 <simon> c_wraith, I just want to use the + or the ++ operator on my own datatype.
12:01:16 <shergill> so what're the issues with fail? or is it just that people feel (As i do) that perhaps it should've been in another typeclass?
12:01:33 <c_wraith> shergill: pretty much, yeah.  No one would complain if it was a different class
12:01:35 <DMcGill> shergill: it is in another typeclass, look at MonadPlus
12:01:46 <mapf> i saw somewhere a little bit more comprehensive version of that slides but i can't find
12:01:55 <nejucomo> c_wraith: Well in that case, that seems rather horrible, by which I mean an instance could really confuse people with the error message.
12:02:18 <sipa> simon: (+) is part of the Num typeclass, so if you implement Num entirely, you can create an instance of (+) for your type
12:02:26 <c_wraith> simon: well, you can implement Num to get (+), but Num is pretty heavy if (+) is all you want
12:02:32 <c_wraith> d'oh.  I lost the race
12:02:55 * nejucomo tries to write a Monad instance and a binding failure to understand more.
12:02:58 <sipa> simon: (++) is specifically for concatenation of lists, so unless your type is a list, that's not possible
12:02:58 <simon> c_wraith, hmm. I'll just stick with lists for ++, then.
12:03:08 <simon> I mean sipa. thanks.
12:03:22 <DMcGill> Enum gives succ, Monoid gives mappend to combine two things and Num gives arithmetic
12:05:44 <SaaMmY-laptop> succ function sucks XD crack joke
12:05:47 <shergill> btw, who here uses twitter? care to post your twitter handles? i'm trying to add a few more interesting feeds
12:06:14 <shergill> (or google+)
12:06:14 <mapf> one really annoying thing with monoids it's packing unpacking newtypes
12:06:29 <rwbarton> simon, it might be sensible to make your type an instance of Monoid then
12:07:01 <rwbarton> and then use mappend, or as of some recent version (7.4 I think?), (<>)
12:09:12 <simon> rwbarton, thanks. I'll think of that
12:10:49 <Philonous> When I have catch(STM.atomically foo) (\e -> ...) is it possible for an exception to be caught there after the atomic operations finishes?
12:11:30 <c_wraith> no
12:11:44 <parcs`> what about an asynchronous exception?
12:12:02 <c_wraith> asynchronous exceptions will come at an allocation
12:12:31 <Philonous> Ah, good to know
12:12:50 <Philonous> Exceptions are darn subtle
12:13:12 <c_wraith> Note that there are still subtleties
12:13:21 <c_wraith> if foo = return undefined, for instance
12:13:31 * hackagebot happstack-fay 0.1.0.0 - Support for using Fay with Happstack  http://hackage.haskell.org/package/happstack-fay-0.1.0.0 (JeremyShaw)
12:13:43 <c_wraith> That will not be caught
12:14:00 <c_wraith> just because the exception won't be raised as part of the evaluation of atomically
12:15:01 <Philonous> c_wraith:  OK, that's "obvious"
12:15:38 <c_wraith> sure, but there are less-obvious analogues
12:15:38 <Philonous> c_wraith:  I'm trying to get some code water-tight in presence of asynchronous exceptions. I'm beginning to thing the correct solution to this is to give up and do something else.
12:15:53 <Philonous> think*
12:15:57 <c_wraith> like ending the block with "return $ f x"
12:16:05 <Philonous> Actually, I'm rather sure of it by now
12:16:29 <c_wraith> For the most part...  Async exceptions and STM don't mix cleanly anyway
12:16:55 <hpaste> beaky pasted “Is this a correct catamorphism on a binary tree?” at http://hpaste.org/77753
12:16:56 <c_wraith> If the exception happens after the transaction, but before any reporting of the result - ick
12:16:58 <Philonous> No? I thought that was the whole idea of transactionality
12:18:06 <beaky> how do I implement an anamorphism?
12:18:30 <neutrino> edwardk
12:18:35 <byorgey> beaky: that is actually not a catamorphism
12:18:42 <edwardk> heya
12:18:55 <neutrino> i don't agree out of order undo is the biggest advantage of abelian groups
12:19:06 <parcs`> @src unfoldr
12:19:06 <lambdabot> unfoldr f b  = case f b of
12:19:06 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
12:19:06 <lambdabot>    Nothing        -> []
12:19:07 <neutrino> i believe resource optimization is
12:19:18 <byorgey> beaky: the "Foldable" class does not give you catamorphisms for anything but lists
12:19:22 <beaky> oh
12:19:24 <edwardk> did i make that claim somewhre?
12:19:32 <beaky> :(
12:19:39 <neutrino> well, no, but you gave some examples in that monoid paper :p
12:19:48 <edwardk> i wrote a monoid paper?
12:19:48 <c_wraith> Philonous: yes, but the point is, the transaction can complete successfully.  After that, the exception could happen, but before anything else.
12:19:53 <byorgey> beaky: see http://www.haskell.org/haskellwiki/Typeclassopedia#Foldable_actually_isn.27t
12:19:57 <sclv> edwardk /= byorgey
12:19:58 <neutrino> and it seems like resource optimization totally beats out of order undo
12:20:12 <neutrino> edwardk: introduction to monoids?
12:20:17 * byorgey wrote a monoid paper, but doesn't remember saying anything about undo and abelian groups
12:20:17 <edwardk> neutrino: it totally depends on your application domain =)
12:20:26 <c_wraith> Philonous: in most cases, you want to do something with the result of the transaction - and losing that is nearly as bad as having it be non-transactional
12:20:30 <sclv> ok now i'm confused too
12:20:32 <neutrino> it says "edward kmett introduction to monoids"
12:20:34 <edwardk> oh, was this the half-line blurb at the end of my slides?
12:20:39 <beaky> are all data structures in haskell purely functional?
12:20:42 <neutrino> i don't think brent is edward
12:20:46 <edwardk> where i went through what you get out of other algebraic data structures?
12:20:55 <neutrino> edwardk: no the table
12:20:55 <neutrino> yeah
12:20:57 <neutrino> that thing
12:20:57 <edwardk> i've now paged in enough context to respond =)
12:21:04 <neutrino> :)
12:21:15 <Philonous> c_wraith:  Ah, ok, well, but that might happen anywhere. That's what mask is for, no?
12:21:24 <neutrino> i think.. resource optimization is a use of groups that must be explored
12:21:33 <edwardk> i spoke over that slide giving a few quick examples of each. i had about 20 seconds to go through 7-8 algebraic structures ;)
12:21:37 <neutrino> and probably the biggest most important thing ever
12:21:58 <neutrino> where were you giving the talk?
12:22:13 <edwardk> i gave the talk at boston haskell, and then later on a version of it at hac phi
12:22:21 <edwardk> about 3 years ago if i had to guess
12:22:31 <edwardk> ear-wormed poor byorgey about the power of monoids ;)
12:22:32 <neutrino> cool
12:22:46 <neutrino> you should ear worm the other ear about groups
12:22:55 <Sonderblade> any release history for ghc? like what features does 6.8.2 lack that current ghc have?
12:22:59 <neutrino> because they totally own
12:23:41 <edwardk> well, sure. i use abelian groups for rolling averages, etc. so in some sense its both about undo and managing my resource consumption, etc.
12:23:43 <neutrino> for example for FRP: if you look at an frp signal chain, and one of the processors decides it will not respond to any signals, you can completely skip computing the preceding processors
12:24:03 <byorgey> Sonderblade: you can go on haskell.org/ghc and look at the release notes for each release
12:24:14 <pordan30> breaky: although foldable doesn't, multirec and a few other libraries /do/ have generic folds, i believe.
12:24:33 <neutrino> edwardk: what i meant by "resource optimization" is like this with signal processing above
12:24:43 <c_wraith> Philonous: yes, that's what mask is for. But if you're going to use it for that, you really need to be scoping it over the call to atomically, in which case - eww.
12:24:43 <byorgey> beaky: a catamorphism for BinaryTree would have type  b -> (a -> b) -> (b -> a -> b -> b) -> BinaryTree a -> b
12:24:45 <edwardk> i don't quite see the group connection there
12:24:52 <edwardk> i can do that just by viewing the chain as a monoid or category
12:24:53 <Sonderblade> byorgey: yeah im thinking more like at what release version was which language extensions introduced?
12:24:55 <c_wraith> Philonous: after all, calls to atomically might block indefinitely
12:25:03 <byorgey> Sonderblade: I don't think there's anything like that
12:25:13 <beaky> byorgey: ah so that function signature covers all cases?
12:25:25 <Philonous> c_wraith:  Blocking calls are automatically unmasked IIRC
12:25:32 <byorgey> beaky: there is one argument for each constructor.  is that what you meant?
12:25:37 <beaky> yes
12:25:39 <byorgey> yep
12:25:39 <neutrino> for example, let's say you have a slider called "x" and you have such a chain: y = foo x; z = bar y; u = baz z; v = 20
12:25:55 <byorgey> beaky: I bet you can implement it given that type signature.
12:26:12 <edwardk> my main application for groups are in things like my column store. i could compute answers, distributed over different servers monoidally, and then if i picked up a delta worth of new information i could insert it into my answer if i had a commutative monoid. if i had an abelian group i could update my answer even if i had deletions
12:26:12 <byorgey> beaky: then, to see the difference, try implementing 'depth' using foldr and using the real cata.
12:26:13 <beaky> I just substitute the ctor with teh functions?
12:26:22 <neutrino> then you can see that v = 20 is a constant and that you don't need to process earlier rules at all..
12:26:26 <byorgey> beaky: that is precisely what a catamorphism is =)
12:26:39 <neutrino> edwardk: yes
12:26:57 <neutrino> edwardk: but your deletions are "move to trash" kind of deletions, right?
12:27:02 <neutrino> as in undoable deletions?
12:27:15 <neutrino> because what is the inverse element of a deletion?
12:28:16 <edwardk> neutrino: they could be any kind of deletion i want. lets just take the source data being a bunch of numbers. and i compute the sum of them. i can delete numbers from the original list, and i can map that onto my result by subtracting their corresponding values from the sum without recalculating the entire list.
12:28:34 <neutrino> right
12:28:43 <edwardk> so i have a mapping from row -> my group. to delete a row i map the row to the group and take its inverse
12:28:44 <neutrino> i was thinking of other manipulations
12:28:52 <edwardk> since its abelian i don't need to think about the relative positioning
12:29:03 <neutrino> let's say you have some data structure (works with any data structure) and updating it costs a lot
12:29:08 <neutrino> let's say it's a set
12:29:24 <edwardk> if its anabelian i need to go through and maintain a huge tree structure, wasting tons of memory to get a log time update
12:29:26 <neutrino> and you have deletion and insertion operations
12:29:53 <Philonous> c_wraith:  According to the documentation,  "STM transactions that do not use retry [are guaranteed not to be interruptible]". I take it that means retry is interruptible.
12:30:06 <neutrino> you can que them up without knowing the actual data structure, and aggregate them
12:30:24 <c_wraith> Philonous: that's plausible
12:30:29 <neutrino> and then only update the data structure with the tiniest delta
12:30:33 <edwardk> sure
12:30:56 <edwardk> i've done this with fingertrees using monoids from the bottom up, or with groups to subtract the delta on the way down, etc.
12:31:12 <neutrino> never used fingertrees
12:31:51 <edwardk> you can ignore the finger-tree and just say its a monoidally annotated 2-3 tree for now, and later on the finger part of a fingertree just gives you O(1) access to the left and rightmost elements of the tree
12:32:14 <neutrino> but what i know is that if you have a tree, and start deleting stuff from it and inserting, then you can look at that as a nonabelian group which can let you optimize a lot of your work
12:32:24 <Cale> and you also don't have to worry that it's specifically a 2-3 tree
12:32:55 <Cale> Thinking about it like a binary tree will work just as well :)
12:33:03 <neutrino> because if you cull a stem at some point then all of the operations on its sub-branches become moot
12:33:06 <shergill> edwardk: do you have a link to the talk in question?
12:33:12 <edwardk> neutrino: sure and i do ;)
12:33:27 <edwardk> shergill: its on comonad.com somewhere. neutrino is probably looking at the link right now though ;)
12:33:46 <neutrino> comonad.com sounds like command.com
12:33:48 <neutrino> DOS
12:33:50 <shergill> neutrino: link please?
12:33:54 <shergill> ew
12:34:08 <Philonous> c_wraith:  I just realized that automatically my original question is moot because exception handlers are masked anyway
12:34:12 <neutrino> shergill: link to what?
12:34:18 <Philonous> -automatically
12:34:31 <shergill> neutrino: the talk/slides that kickstarted this discussion
12:34:40 <c_wraith> Philonous: yeah, there's that. :)
12:34:56 <ion> Interesting. HSQL seems to have a single “SqlBind” class that only works to one direction (from SQL strings to Haskell values).
12:34:57 <neutrino> http://comonad.com/reader/wp-content/uploads/2009/08/IntroductionToMonoids.pdf
12:35:28 <shergill> neutrino: thanks
12:35:43 <neutrino> yw :)
12:35:58 <edwardk> neutrino: for reference http://comonad.com/reader/2010/finger-trees/ uses the monoidal annotations on trees
12:36:04 <ion> Oh. It has toSqlValue and fromSqlValue but they didn’t show up in the Haddock text. ಠ_ಠ
12:36:22 <neutrino> edwardk: is monoidal annotation = (cons, snoc) ?
12:36:58 <coldpizza72i> @undo putStrLn "name?"; name <- getLine; putStrLn "Age?"; age <- getLine; putStrLn (name ++ " is " ++ age)
12:36:58 <lambdabot>  Parse error at ";" (column 17)
12:37:03 <edwardk> no. adding cons and snoc are just the 'reducer' stuff i have. a monoidal annotation would just be keeping some summary in the higher levels of the structure.
12:37:27 <coldpizza72i> how come that doesn't work
12:37:29 <neutrino> @undo do { putStrLn "name?"; name <- getLine; putStrLn "Age?"; age <- getLine; putStrLn (name ++ " is " ++ age) }
12:37:30 <lambdabot> putStrLn "name?" >> getLine >>= \ name -> putStrLn "Age?" >> getLine >>= \ age -> putStrLn (name ++ " is " ++ age)
12:37:31 <edwardk> e.g. data List a = Cons !Int a !(List a) | Nil  -- where the Int is the length of the list
12:37:40 <neutrino> coldpizza72i: i just added do {}
12:37:44 <coldpizza72i> oops
12:38:02 <edwardk> or data Tree a = Bin !Int !(Tree a) a !(Tree a) | Tip -- where the Int is the size of the tree
12:38:07 <edwardk> or you can use other monoids.
12:38:23 <edwardk> http://comonad.com/reader/2009/incremental-folds/
12:38:41 <edwardk> you can annotate with f-algebras, monoids, etc.
12:39:06 <neutrino> why do you need to annotate the size of the tree?
12:39:09 <edwardk> er rather using an f-algebra or with a monoidal reducer, etc.
12:39:19 <edwardk> neutrino: because i may not want to pay O(n) when I can pay O(1)
12:39:35 <neutrino> what does annotating the size of the tree have to do with monoids?
12:39:42 <edwardk> Data.Map uses this kind of annotation internally as it uses sized balanced trees
12:39:50 <edwardk> because the count of children is a monoid =P
12:40:02 <neutrino> is it?
12:40:02 <edwardk> its actually an abelian group =P
12:40:32 <edwardk> its ((+),0,negate) forms the monoid, the reducer is the map 'const 1' =P
12:40:47 <edwardk> er forms the group
12:40:53 <neutrino> what is "negate"?
12:41:02 <neutrino> negate x = 0 - x?
12:41:06 <edwardk> > negate 5
12:41:08 <lambdabot>   -5
12:41:14 <edwardk> yes
12:41:35 <neutrino> how do you get negative child counts?
12:41:48 <neutrino> when deleting a subtree?
12:42:20 <edwardk> neutrino: you don't during construction, but if i delete an element i know to be there i can just subtract one from the size as i walk _down_ to the element rather than add up numbers that will add up to one less as i build it up from the bottom
12:42:26 <edwardk> the group lets me work in reverse
12:42:54 <edwardk> otherwise i have to add up a bunch of numbers and get the number i might already be able to calculate using the abelian group
12:43:20 <edwardk> with fingertrees i can get similar opportunities to exploit negated group elements even when its not abelian, but i'm leaving that as an exercise for the reader
12:43:21 <jmcarthur> i love annotated data structures
12:43:33 <jmcarthur> at least when it's generic enough
12:43:34 <beaky> what should a binarytree anamorphism look like?
12:43:34 <Cale> neutrino: The number of leaves in a tree is the sum of the number of leaves in its children
12:43:34 <Cale> oh, apparently I'm extremely lagged
12:43:36 <ulfdoz> Moment mal, die Argumentation ist kaputt. Wenn Spanien seinen Banken erlaubt, riskante Geschfte zu ttigen und Spanien dann meint, diese retten zu mssen, ist das ihr Bier.
12:43:42 <ulfdoz> ewin
12:43:45 <ulfdoz> aber gnamd.
12:44:13 <Cale> ulfdoz: Wrong channel perhaps?
12:44:15 * byorgey doesn't beleive 'gnamd' is a real German word
12:44:31 <ulfdoz> Cale: For sure. ;)
12:44:40 <johnw> wouldn't it have to me gnamdt?
12:45:48 <edwardk> also there is a bug in my fingertree slides. i'm a bit too strict there ;)
12:45:54 <Philonous> byorgey:  After 3 beer, it is.
12:46:01 <mauke> g'n a'm'd
12:46:02 <byorgey> hehehe
12:46:06 <mauke> guten abend
12:46:17 <byorgey> ah, I see
12:46:37 <edwardk> beaky: you can use the basic idiom from unfoldr
12:46:39 <edwardk> :t unfoldr
12:46:41 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
12:46:44 <beaky> ah
12:46:51 <beaky> @src unfoldr
12:46:51 <lambdabot> unfoldr f b  = case f b of
12:46:51 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
12:46:51 <lambdabot>    Nothing        -> []
12:46:56 <edwardk> (b -> Maybe (b, a, b)) -> b -> Tree a
12:47:11 <edwardk> you get two new seeds 'b' for the children
12:47:15 <byorgey> beaky has Leaf too though
12:47:25 <edwardk> f you have leaves swap from Maybe to Either or something
12:47:34 <edwardk> (b -> Either a (b, b)) -> b -> Tree a
12:47:38 <edwardk> if you have leafy trees
12:47:48 <byorgey> (b -> Maybe (Either a (b,a,b)) -> b -> Tree a
12:47:54 <byorgey> beaky has Empty *and* Leaf
12:47:58 <byorgey> though that's a bit redundant
12:48:00 <beaky> :D
12:48:03 <edwardk> ah.
12:48:20 <byorgey> beaky: you can just represent Leaf a  by  Branch Empty a Empty
12:48:27 <beaky> right
12:48:40 <edwardk> yeah. the slides i gave above for fingertrees motivate leafy and non-leafy trees, and show the two base forms, and separate annotations on each, and the consequences for them as a monad, etc.
12:48:44 <byorgey> I guess it's a tradeoff between economy of representation and annoyingness of reading the output of 'show' =)
12:49:15 <edwardk> clearly show should summarize Branch Empty a Empty as 'tip a'
12:49:17 <edwardk> ;)
12:49:19 <edwardk> problem solved
12:49:56 <edwardk> it would of course make it a little less lazy
12:51:45 <johnw> edwardk!
12:51:53 <edwardk> ?
12:52:06 <johnw> just happy to see you
12:52:07 <neutrino> hey guys
12:52:07 * edwardk looks around for what he did wrong. ;)
12:52:11 <edwardk> ah =)
12:52:21 <johnw> you make this channel feel more abstract just by your presence
12:52:30 <johnw> (which is a positive thing to my mind)
12:52:51 <neutrino> not necessarily a haskell question, but.. is there a command line tool that takes a json object on stdin, and json keys on the arguments, and returns the traversed subobject on stdout?
12:53:02 <johnw> conversation -> Edwardk(conversation) is a mapping from the mundane to the awesome
12:53:14 <johnw> neutrino: it would be trivial to write
12:53:20 <neutrino> i know
12:53:30 <neutrino> but it's even more trivial if it exists
12:53:42 <johnw> neutrino: see my snippet at the bottom of http://lukeplant.me.uk/blog/posts/dynamic-typing-in-a-statically-typed-language/
12:53:47 <johnw> where I use lens to sell the clarity of Haskell :)
12:54:01 <johnw> neutrino: i know of no such, but that means little
12:54:05 <neutrino> eh i'd probably write this in python anyways
12:54:14 <neutrino> but why write when you can use
12:54:55 <mapf> because write in haskell is fun
12:55:07 <neutrino> heh
12:55:24 <johnw> and if you start something in Haskell, then when it needs to get more complicated (and when does it not?), you're already halfway there
12:55:54 <Rc43> Hi, guys.
12:56:04 <johnw> Hi Rc43
12:56:08 <beaky> hello
12:56:17 <johnw> Rc42 says you succ
12:56:21 <johnw> ;)
12:56:32 <beaky> I implemented almost all the morphisms!
12:56:39 <johnw> beaky: prepromorphisms?
12:56:44 <beaky> how do I implement hylomorphism though?
12:56:48 <beaky> what are prepromorphisms?
12:57:01 <johnw> beaky: talk to edwardk before ever thinking that you've seen all the morphisms :)
12:57:09 <beaky> :D
12:57:24 <Rc43> johnw, :D cool!
12:57:30 <johnw> he's famous for his zygohistomorphic prepromorphisms
12:57:39 <johnw> and what they are, I haven't a clue
12:57:55 <edwardk> prepromorphisms just add a natural transformation before each layer. the idea goes back to maarten fokkinga's thesis
12:57:57 <Pranz> @version
12:57:57 <lambdabot> lambdabot 4.2.2.1
12:57:58 <lambdabot> darcs get http://code.haskell.org/lambdabot
12:58:53 <edwardk> sadly the old link on my blog to his dissertation bitrotted.
12:59:22 <pordan30> beaky: you can implement hylomorphisms in terms of anamorphisms and catamorphisms, i believe; so if you have the basic morphisms, then you get it for free.
12:59:34 <beaky> ah
12:59:45 <beaky> so I just say hylo = cata . ana :D
13:00:04 <johnw> pretty much
13:00:29 <johnw> just realize that may be only a subset of the possible hylomorphisms
13:00:41 <johnw> hylo ⊂ cata . ana
13:01:49 <beaky> is this the right Signature for hylomprhism on trees? (a -> Tree b -> Tree b) -> (a -> Maybe (a, b, a)) -> a -> Tree a -> Tree b
13:01:54 <beaky> too complicated :(
13:02:23 <shergill> johnw: your math and english differ
13:02:56 <johnw> oops
13:02:57 <shergill> i think. unless there's a parsing error
13:03:06 <johnw> cata . ana ⊂ hylo
13:03:49 <copumpkin> beaky: no
13:03:58 <pordan30> the bananas and barbed wires paper defines (and proves?) the result, so if the statement is folklore, it would trace back pretty far.
13:03:58 <beaky> hylo :: (a1 -> c -> c) -> c -> (a -> Maybe (a, a1, a)) -> a -> c
13:04:48 <edwardk> johnw: i replied to the guy who replied to your reply or something
13:05:03 <johnw> ooh, reading
13:05:06 <copumpkin> beaky: hylo :: Functor f => (f b -> b) -> (a -> f a) -> a -> b
13:05:06 <bxx> > sortBy (mappend (comparing length) compare) ["z", "aa", "zzz", "a", "zz", "aaa"]
13:05:08 <lambdabot>   ["a","z","aa","zz","aaa","zzz"]
13:05:31 <bxx> what exactly does mappend do to make this work?  I tried reading documentation and it's source but I didn't get it
13:05:47 <edwardk> mappend LT GT
13:05:50 <edwardk> > mappend EQ GT
13:05:53 <lambdabot>   GT
13:05:58 <beaky> ah
13:06:00 <edwardk> > mappend LT undefined
13:06:02 <lambdabot>   LT
13:06:08 <edwardk> > mappend GT undefined
13:06:08 <Peaker> bxx, specifically, it's the Monoid instance of Ordering
13:06:09 <johnw> edwardk: that's a great way to put it: types are unit tests you don't have to write (or run)
13:06:10 <lambdabot>   GT
13:06:39 <edwardk> the monoid for Ordering is the lexicographical ordering of the individual comparisons
13:06:47 <bxx> I see interesting
13:07:16 <edwardk> > compare 'h' 'h' <> compare 'e' 'i'
13:07:18 <lambdabot>   Ambiguous occurrence `<>'
13:07:18 <lambdabot>  It could refer to either `Data.Monoid.<>',
13:07:18 <lambdabot>      ...
13:07:25 <edwardk> > compare 'h' 'h' Data.Monoid.<> compare 'e' 'i'
13:07:26 <lambdabot>   LT
13:07:31 <edwardk> bah, what other (<>) is in scope?
13:07:40 <edwardk> > compare 'h' 'h' `mappend` compare 'e' 'i'
13:07:42 <lambdabot>   LT
13:07:44 <edwardk> doesn't quite have the same ring to it
13:08:35 <shergill> well types take time to construct, but yes i view types as automated tests as well
13:08:52 <shergill> *take time to construct (same as unit tests)
13:09:01 <edwardk> shergill: write the code, compile with -Wall. let the compiler tell them to you =P
13:09:18 <edwardk> :t (["hello","world",(), 5)
13:09:20 <lambdabot> parse error on input `)'
13:09:26 <edwardk> :t (["hello","world"],(), 5)
13:09:28 <lambdabot> Num t => ([[Char]], (), t)
13:09:31 <mauke> edwardk: `Text.PrettyPrint.HughesPJ.<>
13:10:07 <edwardk> @tell Cale can we hide Text.PrettyPrint.HughesPJ.<>   it collides with (<>) from Data.Monoid and is compatible with it
13:10:08 <lambdabot> Consider it noted.
13:10:19 <shergill> edwardk: oh i do. it's mostly for people who view testing as being distinct from compilation (i usually just think about building my program)
13:10:36 <Cale> edwardk: Is Doc already an instance of Monoid?
13:10:36 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
13:10:41 <edwardk> it should be
13:10:46 <mauke> @check 2
13:10:48 <edwardk> > text "hello"
13:10:48 <lambdabot>   2
13:10:50 <lambdabot>   hello
13:10:59 <edwardk> > text "hello" Data.Monoid.<> text "there"
13:11:01 <lambdabot>   hellothere
13:11:03 <Cale> cool
13:11:03 <edwardk> ep
13:11:06 <edwardk> er yep
13:11:18 <Cale> That module was written forever ago, but I guess they updated it :)
13:11:25 <edwardk> it was one of the motivating examples, but also part of the reason it took is 2.5 years to negotiate a fixity for (<>)
13:11:32 <edwardk> er took us
13:12:14 <Cale> also, @check is broken, I'll need to figure out what's going on there
13:12:22 <Cale> @undefine
13:12:32 <Cale> > "hello" <> "world"
13:12:34 <lambdabot>   "helloworld"
13:12:38 <edwardk> yay
13:12:41 <rwbarton> as far as I can see the mystery is that @check ever worked
13:12:45 <Cale> > getSum (Sum 5 <> Sum 7)
13:12:48 <lambdabot>   12
13:12:50 <Cale> rwbarton: lol
13:12:53 <lolcathost> :t Sum
13:12:54 <lambdabot> a -> Sum a
13:12:58 <edwardk> oh, did you have a reaction on my earlier question about adding Numeric.AD?
13:13:03 <edwardk> > diff cos 0
13:13:04 <lambdabot>   Not in scope: `diff'
13:13:05 <lambdabot>  Perhaps you meant `dff' (imported from Data.Graph)
13:13:14 <edwardk> the names shouldn't conflict with anything
13:13:19 <Cale> hmm, okay
13:13:41 <Cale> I guess I'll get rid of Data.Number.Dif
13:13:43 <copumpkin> damn, ala is gone?
13:13:44 <Cale> in exchange
13:13:49 <copumpkin> or rather, it's replaced with edwardkisms
13:13:53 <edwardk> and they may be useful to you over in ##math
13:13:58 <copumpkin> I was trying to use the newtypey one
13:14:36 <edwardk> yeah Dif has the problem that you can easily confuse infinitesimals
13:14:40 <Pranz> why is Sum a type?
13:14:51 <atriq> Pranz, because Product is too
13:15:01 <edwardk> Cale: you'd want to import Numeric.AD  and Numeric.AD.Types
13:15:10 <copumpkin> edwardk: funny you mention that, I just read ccshan's article on that earlier today
13:15:18 <beaky> hello
13:15:18 <copumpkin> but I guess edwardk is always talking about AD
13:15:27 <Cale> I'd also presumably want to install the package ad
13:15:27 <copumpkin> :)
13:15:28 <beaky> @pl \x y z -> x + y + z
13:15:28 <lambdabot> ((+) .) . (+)
13:15:42 <Pranz> atriq, but why does lambdabot have those kind of things?
13:15:42 <edwardk> and Numeric.AD.Classes should probably come only qualified
13:15:46 <Pranz> They don't seem that useful
13:15:46 <edwardk> hah
13:15:48 <edwardk> that too
13:15:55 <atriq> Pranz, Monoid instances
13:16:06 <copumpkin> so wait, did we get rid of the newtype package?
13:16:08 <copumpkin> in lambdabot?
13:16:12 <edwardk> :t extend
13:16:16 <lambdabot> Not in scope: `extend'
13:16:16 <copumpkin> :t ala
13:16:18 <lambdabot> Simple Iso s a -> ((s -> a) -> e -> a) -> e -> s
13:16:20 <copumpkin> :t ala'
13:16:22 <lambdabot>     Not in scope: ala'
13:16:22 <lambdabot>     Perhaps you meant `ala' (imported from Control.Lens)
13:16:23 <edwardk> Control.Comonad would also be awesome ;)
13:16:29 <atriq> > getSum $ mconcat [Sum 1, Sum 2, Sum 7] -- Pranz
13:16:30 <Cale> copumpkin: Yeah, I removed it because I didn't think anyone actually used it
13:16:34 <lambdabot>   mueval-core: Time limit exceeded
13:16:39 <copumpkin> Cale: OMG
13:16:40 * edwardk continues to harass cale =)
13:16:41 <copumpkin> WTF
13:16:41 <atriq> :t mconcat
13:16:45 <boobs_> hi
13:16:46 <lambdabot> Monoid a => [a] -> a
13:16:49 <copumpkin> I USED IT EVERY HOUR OF EVERY DAY
13:16:51 <beaky> http://ideone.com/HgKkd9 how do I implement grow in terms of ana?
13:17:02 <Cale> the more things we import, the more you're going to see timeouts
13:17:04 <atriq> > getSum $ mconcat [Sum 1, Sum 2, Sum 7] :: Int -- Pranz
13:17:08 <lambdabot>   10
13:17:11 <Cale> keep that in mind
13:17:11 <edwardk> true
13:17:18 <copumpkin> > getSum . foldMap Sum $ [1,2,7]
13:17:20 <lambdabot>   Not in scope: `foldMap'
13:17:20 <edwardk> Comonad is used transitively by Lens already
13:17:20 <lambdabot>  Perhaps you meant one of these:
13:17:20 <lambdabot>    `Data.Foldable....
13:17:23 <copumpkin> wah
13:17:23 <Pranz> Ah
13:17:47 <Cale> @undefine
13:17:53 <atriq> > getProduct $ [Product 1, Product 2, Product 7]
13:17:54 <lambdabot>   Could not find module `Numeric.AD.Class'
13:17:55 <lambdabot>  Perhaps you meant Numeric.AD.Type...
13:17:56 <Cale> > diff cos 0
13:17:56 <lambdabot>   Could not find module `Numeric.AD.Class'
13:17:56 <lambdabot>  Perhaps you meant Numeric.AD.Type...
13:17:58 <Cale> hmm
13:18:08 <edwardk> Classes
13:18:10 <edwardk> sorry
13:18:11 <Cale> oh, right
13:18:20 <Cale> @undefine
13:18:27 <Cale> No, my mistake
13:18:30 <Cale> > diff cos 0
13:18:31 <lambdabot>   Could not find module `Numeric.AD.Classes'
13:18:31 <lambdabot>  Perhaps you meant
13:18:31 <lambdabot>    Numeric.AD...
13:18:37 <Cale> umm
13:18:39 <edwardk> > grad (\[x,y] -> x * y + 10) [1,2]
13:18:41 <lambdabot>   Could not find module `Numeric.AD.Classes'
13:18:41 <lambdabot>  Perhaps you meant
13:18:41 <lambdabot>    Numeric.AD...
13:18:53 <Cale> @undefine
13:18:58 <Cale> > diff cos 0
13:19:00 <lambdabot>   -0.0
13:19:03 <lispy> lambdabot is working too well. It must be time to upgrade ghc.
13:19:04 <copumpkin> > grad (\[x,y] -> x * y + 10) [x,y]
13:19:06 <lambdabot>   [0 + (0 + y * (0 + 1 * 1)),0 + (0 + x * (0 + 1 * 1))]
13:19:18 <edwardk> oh. i just killed it in 3.1 i think my bad
13:19:23 <edwardk> i was looking at old haddocks
13:19:26 <copumpkin> look at all that unnecessary computation!
13:19:39 <copumpkin> > grad (\[x,y] -> x * y ^ 2 + 10 * exp x) [x,y]
13:19:41 <lambdabot>   [0 + (0 + y * y * (0 + 1 * 1) + exp x * (0 + 10 * (0 + 1 * 1))),0 + (0 + y ...
13:19:59 <edwardk> copumpkin: you can use a simplifier to get something that sucks less. i think there is one in Debug.Traced
13:20:06 <lispy> copumpkin: If you think that's unnecessary, I'm running progressquest.com in a differnt window :)
13:20:08 <ion> Err. This exports SqlBind(..) but toSqlValue and fromSqlValue are “not visible methods of class SqlBind”.
13:20:27 <edwardk> not sure if there is one in the expression type we use here
13:20:27 <copumpkin> lispy: game? what is game?
13:20:30 <lispy> ion: and the import?
13:20:30 <edwardk> :t a
13:20:32 <lambdabot> Expr
13:21:10 <ion> Oh. I had to import Database.HSQL.Types separately, Database.HSQL only exported SqlBind and one of the methods. ಠ_ಠ
13:21:11 <Cale> It's just the one from simple-reflect
13:21:24 <lispy> copumpkin: it's like a lot like a monad tranformer for your spare time
13:21:27 <edwardk> > headJet $ grads (\[x,y] -> x * y) [x,y]
13:21:29 <lambdabot>   Couldn't match expected type `Numeric.AD.Internal.Jet.Jet f0 a0'
13:21:30 <lambdabot>           ...
13:21:32 <edwardk> > headJet $ get $ grads (\[x,y] -> x * y) [x,y]
13:21:33 <copumpkin> lispy: spare time? what is spare time?
13:21:35 <lambdabot>   No instance for (Control.Monad.State.Class.MonadState
13:21:35 <lambdabot>                     (...
13:21:36 <edwardk> > headJet $ jet $ grads (\[x,y] -> x * y) [x,y]
13:21:38 <lambdabot>   x * y
13:21:43 <edwardk> > headJet $ tailJet $ jet $ grads (\[x,y] -> x * y) [x,y]
13:21:45 <lambdabot>   [y * 1,x * 1]
13:21:46 <copumpkin> > headDesk $ desk $ grads (\[x,y] -> x * y) [x,y]
13:21:48 <lambdabot>   Not in scope: `headDesk'Not in scope: `desk'
13:21:49 <edwardk> > headJet $ tailJet $ tailJet $ jet $ grads (\[x,y] -> x * y) [x,y]
13:21:51 <lambdabot>   [[0,1 * 1],[1 * 1,0]]
13:21:52 * ion notices he accidentally didn’t link the source code. Oh well, found the fix already.
13:21:57 <edwardk> > headJet $ tailJet $ tailJet $ tailJet $ jet $ grads (\[x,y] -> x * y) [x,y]
13:21:58 <lispy> copumpkin: It's that time when you're not doing what you're supposed to be doing.
13:22:00 <lambdabot>   [[[0,0],[0,0]],[[0,0],[0,0]]]
13:22:21 <copumpkin> lispy: does not compute. I always do what I am supposed to do. Like right now, I am supposed to be on IRC
13:22:23 <danr> what is this headJet? :D
13:22:34 <lispy> copumpkin: Oh well. Maybe it's not for you.
13:22:34 <pordan30> has there been any research on drawing (functionally) directed graphs? i'm familiar with force-directed functional drawing algorithms, as well as the functional pearl for tree drawing by kennedy. there is also an iterative algorithm by gansner that shows up on google, with a readable paper alongside it.
13:22:45 <copumpkin> lispy: !
13:23:00 <edwardk> danr: grads gives back a cofree comonad containing the entire 'jet' of all of the partial derivatives of a function. the Jet is the fully unzipped cofree comonad.
13:23:24 <edwardk> data Jet f a = a :- Jet f (f a)
13:23:29 <lispy> jet set, differentiate!
13:23:37 <edwardk> a :- f a :- f (f a) :- f (f (f a)) :- ...
13:23:47 <danr> aha... so the second argument to grads is the variables we're differentiating with?
13:23:55 <edwardk> while the cofree comonad looks like a :< f (a :< f (a :< ...
13:24:25 <edwardk> the values at which we are computing the derivative. here we're using Expr as a numeric type, which gives you a symbolic rather than numeric derivative result
13:24:34 <danr> jet $ grads (\[x,y] -> sin x * cos x) [x,y]
13:24:37 <edwardk> > headJet $ tailJet $ jet $ grads (\[x,y] -> x * y) [3,4]
13:24:39 <lambdabot>   [4,3]
13:24:39 <danr> > jet $ grads (\[x,y] -> sin x * cos x) [x,y]
13:24:41 <lambdabot>   sin x * cos x :- [cos x * (cos x * 1) + sin x * (negate (sin x) * 1),0] :- ...
13:24:51 <lispy> edwardk: So then does Jet require infinitely differentiable functions?
13:25:05 <edwardk> so that gives you the answer :- the first derivatives :- the second derivatives :- the third derivatives :- ...
13:25:09 <lispy> edwardk: or just as differentialble as you 'need'?
13:25:22 <lispy> (need in the call-by-need sense)
13:25:35 <edwardk> it gives you an infinite tower of derivatives. if you use it on a point where the function isn't differentiable it'll start giving you whatever it wants.
13:25:39 <edwardk> > diff abs 0
13:25:42 <lambdabot>   0
13:25:49 <edwardk> > diff abs 1
13:25:50 <lispy> I see
13:25:52 <lambdabot>   1
13:25:59 <edwardk> > diff abs 0.5
13:26:00 <lispy> You should make that part type-safe ;)
13:26:02 <lambdabot>   1.0
13:26:07 <lispy> (not serious)
13:26:26 <edwardk> it would be within its rights to answer anything it wanted to at 0
13:26:38 <edwardk> it'll also give you wonky answers in certain circumstances that require L'Hopital's rule
13:26:51 <edwardk> but for most reasonable functions it gives reasonable answers
13:26:52 <simon> @pl all id
13:26:52 <lambdabot> and
13:27:08 <lispy> Bernoulli's rule*
13:27:55 <edwardk> lispy: I use L'Hôpital. Bernoulli defined too many things ;)
13:28:06 * lispy is one of those fascists that doesn't recognize L'Hopital's purnchase of the mathematics
13:29:39 <edwardk> naming of things in mathematics is sort of like a lottery. ;) The odds of the name going to the person who deserves it are somewhat low
13:30:42 <lispy> edwardk: I'm just feeling punchy, don't mind me
13:32:51 <rwbarton> is there a way to manually feed data into a conduit and get out results incrementally? I want to use the zlib-conduit library without moving my entire program into conduit-land
13:34:42 <beaky> @src maybe
13:34:42 <lambdabot> maybe n _ Nothing  = n
13:34:42 <lambdabot> maybe _ f (Just x) = f x
13:35:17 <lispy> rwbarton: sounds like the normal zlib would be better for you. That one returns a lazy bytestring, IIRC
13:35:38 <rwbarton> I need precise control over the chunking of input/output
13:36:20 <rwbarton> which decompressFlush seems to give me; though I expect (having poked around zlib-bindings internals for a while) that it actually doesn't; however I don't even know how to test it
13:36:21 <sclv_> there's a famous story about something like Hamilton sitting through a seminar and at the end saying "I have one question, what is this Hamiltonian youkeep referring to?"
13:37:16 <sclv_> the actual person was probably different, but that's the gist
13:37:34 <Cale> Heh, in 1st year university, we were explicitly not allowed to use l'Hôpital's rule until it was covered in lectures, and after that point, the next homework assignment had a bunch of limits on it where l'Hôpital's rule applied, but worked out horribly.
13:38:56 <beaky> how do I grow a tree of size n as an anamorphism?
13:39:32 <rwbarton> plant it in soil of depth O(log n)
13:39:43 <beaky> :D
13:41:02 <edwardk> beaky: you need to calculate how many members each path should have as you go. its a bit tricky
13:41:18 <edwardk> rwbarton++
13:41:45 <edwardk> you might use, as a straw man, what depth you are in the tree, and what position you are in the row
13:41:52 <edwardk> and update the seed as you go down
13:42:05 <beaky> right
13:42:05 <edwardk> you can also find a more minimal representation that takes less work
13:42:26 <hpc> maybe n inserts to an empty heap?
13:43:29 <edwardk> hpc: well, he's using the tree anamorphism, so he just has the current seed to work with
13:43:29 <edwardk> so he can only convey information to himself about how he got there using the direct path to the root basically
13:44:43 <beaky> right
13:44:55 <edwardk> basically once you know your position in the row you can know the total number of members of the tree that are above you across all rows, 2^n -1. add your position in the row, and if you want 2^n-1+w elements or more you keep growing this line, otherwise cut it
13:45:51 <edwardk> with a little work you could permute that into an algorithm that gives you a braun tree rather than a left biased one
13:46:41 <jeff_s1> Is there a way to do something like an OR in pattern matches? E.G. in my imaginary syntax: case x of {Nothing || Just x | test x) -> ...}.
13:47:05 <jeff_s1> I missed an opening (.
13:47:42 <fmap> no
13:48:03 <pdxleif> Hey, have any ideas for a "conditional list append"? A sort of  Bool -> a -> [a] -> [a] ?
13:48:33 * hackagebot sssp 1.1.1 - HTTP proxy for S3.  http://hackage.haskell.org/package/sssp-1.1.1 (JasonDusek)
13:48:36 <simpson> :t (\b x xs -> if b then x:xs else xs)
13:48:37 <lambdabot> Bool -> a -> [a] -> [a]
13:48:41 <simpson> pdxleif: ^^
13:48:41 <edwardk> jeff_s1: you can use a view pattern but thats about it
13:48:58 <edwardk> jeff_s1 and then factor the 'or' into the view pattern code
13:49:12 <jeff_s1> Ah well. Thanks anyway.
13:49:20 <pdxleif> That's what we're currently doing.  Just wondering if there was some magic shorthand or whatever.
13:49:24 <edwardk> nope
13:49:34 <edwardk> scala offers it. its horribly broken there, but they offer it
13:50:30 <jeff_s1> OCaml has it in the form of | (Haskell's | guard is "when" in OCaml, iirc).
13:50:56 <rwbarton> how does OCaml deal with the situation where the two clauses bind different sets of variables? or variables at different types?
13:51:10 <edwardk> sure. it does require somw pretty strange unification to make work right
13:51:45 <jeff_s1> rwbarton - good question. I haven't used OCaml recently enough to remember, but you have me curious enough to try.
13:54:04 <Cale> I would expect it to require the types to unify, and at least every variable which is actually used on the RHS to be bound by each possible pattern.
13:57:03 <jeff_s1> I just tried it with type ('a, 'b) either = ..., and OCaml let me do "let x r = match r with Left e | Right e -> ()" without error. It unified the 'a and 'b types.
13:57:30 <pdxleif> In scalaz you can do (list ++ (boolTest ?? newValue.some))
13:57:35 <jeff_s1> I can even return the value.
13:57:59 <Okasu> hello
13:58:28 <jeff_s1> so "Left e -> e; Right e -> e" becomes "Left e | Right e -> e" in OCaml. It looks very strange to me now that I'm so used to Haskell.
13:58:28 <applicative> hello Okasu
13:58:39 <Okasu> http://vpaste.net/wLzOf whats wrong with it? Whe there is Int from nowhere?
13:58:46 <Okasu> why*
13:58:59 <rwbarton> hmm, so does it pretty much just duplicate the right hand side for each case then?
13:59:06 <applicative> yeah, !! takes an Int
13:59:09 <jeff_s1> Okasu: n has to be an int because you're using it with (!!).
13:59:29 <Okasu> ah, can you suggest workaround?
13:59:40 <jeff_s1> Okasu - what do you want n to be?
13:59:53 <Okasu> Integer
13:59:54 <applicative> testData can involve Ints but properly use fromIntegral n
14:00:03 <geekosaur> :t genericAt
14:00:05 <lambdabot> Not in scope: `genericAt'
14:00:33 <jeff_s1> Okasu: use Data.List.genericIndex.
14:00:36 <applicative> oh right generic_
14:00:43 <beaky> how do I use a tree fold to count the binary tree?
14:00:48 <applicative>  filter (\(_,n) -> snd (testData !! n) == fromIntegral n) testData
14:00:50 <geekosaur> :t genericIndex
14:00:51 <lambdabot> Integral a => [b] -> a -> b
14:00:54 <Okasu> thanks
14:01:09 <applicative> no, the other way around, of course
14:01:34 <applicative> filter (\(_,n) -> snd (testData !! fromIntegral  n) == n) testData seems better
14:01:42 <applicative> but genericIndex best
14:01:50 <Okasu> filter (\(_,n) -> snd (genericIndex testData n) == n) testData
14:01:52 <Okasu> fine too
14:02:47 <Nereid> filter (ap (==) (snd . genericIndex testData) . snd) testData
14:03:00 <Nereid> heh that's barely shorter
14:03:05 <applicative> presumably the length of the testData list doesn't exceed maxBound Int, but you're using  Integer, so why no stick with it, using genericIndex
14:03:35 <jeff_s1> That would be an impressive list if it were all in memory with length = maxBound  :: Int.
14:03:37 <navaati> hey
14:03:46 <edwardk> rwbarton: effectively -- it also does unification on all the variables (the same variable names have to occur in each pattern)
14:04:05 <applicative> jeff_s1:  yes, I was thinking of matters of High Principle
14:04:32 <applicative> !! and genericIndex militate a bit  against High Principle of course
14:04:39 <edwardk> as a rule if you need genericIndex you're doing it wrong ;)
14:04:41 <navaati> i've just seen that netwire 4 has been released, but can't find a changelog, does anybody know ?
14:05:06 <applicative> as a rule if you need !! youre doing it wrong
14:05:08 <geekosaur> as a rule if you need !! you are likely doing it wrong
14:05:09 <edwardk> jeff_s1: keep in mind you can actually work with lists that are longer than memory as long as you don't hold onto the head of them.
14:05:16 <edwardk> applicative: that too =)
14:05:22 <applicative> geekosaur is my man
14:05:29 <coldpizza72i> [(a,b) | x<-[0..3], a<-[0..x], b <- [x-a]]… In an imperative language with loops the left most germinator would be the outer loop while the right most one is the inner one correct?
14:05:38 <coldpizza72i> generator^
14:05:45 <beaky> is it correct for a binary tree of depth n to have 2^n - 1 nodes?
14:06:00 <arbn> What's the strategy in the old (Platform) ByteString for going from a string literal to a lazy ByteString?
14:06:27 <applicative> BL.pack
14:06:30 <atriq> arbn, Data.ByteString.Lazy.Char8?
14:06:43 <arbn> atriq: Oooh. Right. Thanks.
14:07:02 <atriq> arbn, and the pack function in there
14:07:13 <applicative> is there an overloadedstring instance there, or IsString
14:07:27 <arbn> atriq: Right. I had just forgot that the lazy bytestring had a Char8. Heh.
14:07:52 <atriq> applicative, there is that, too
14:08:34 * hackagebot zmidi-core 0.4.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.4.0 (StephenTetley)
14:08:37 <jeff_s1> I don't think you can count on Char8 if you can expect non-ascii characters, though.
14:08:53 <linduxed> ok guys, i need some help with the writing of a matrix generation function
14:08:55 <linduxed> first of all, here's the repo for the code i've written so far https://github.com/linduxed/progp-molbio
14:09:01 <atriq> I'm probably the only person who tracks the Haskell tag on Tumblr
14:09:08 <linduxed> in Profile.hs, i need to write the function "generateMatrix :: [MolSeq] -> ProfileMatrix". the only thing that needs to be known about MolSeq is that i'll check the type of it and extract actual sequence (a string) with molSequence
14:09:14 <coldpizza72i> anyone...
14:09:28 <linduxed> the problem is that i don't know how to do this best. i could imagine how to do this with messy explicit recursion, but i hope there's a prettier way.
14:09:30 <linduxed> I've been provided with this "hint code" which does the task, but looks messy https://gist.github.com/4075068
14:09:31 <atriq> It's mainly some guy writing what looks like a Haskell tutorial in Japanese, and pictures of a rugby player
14:09:32 <simpson> coldpizza72i: They're not generators.
14:09:39 <applicative> arbn: there's an IsString in ...Lazy.Char8 for version 0.9
14:10:00 <applicative> instance rather, so you can use OverloadedStrings
14:10:00 <coldpizza72i> simpson: haskell.org disagrees… "Note how each successive generator refines the results of the previous generator. Thus, if the second list is infinite, one will never reach the second element of the first list"
14:10:56 <linduxed> coldpizza72i: if i read that code correctly, then i'd say that yes, you're right
14:11:36 <arbn> applicative: Ah. Yeah. That's easier. Just switched to that approach. Thanks.
14:14:26 <applicative> there's IsString in Data.Text too, then you can convert to ByteString with I forget what function, if you need higher characters.
14:15:31 <zoheb> So I am using ghci and entered the expression
14:15:47 <zoheb> let h x = (x^3 - 12*x^2 + 144x)/40 + (-x^3/3 + 2*x^2+96x)/20
14:15:48 * ion tries HDBC instead of HSQL. Now there’s another problem: i have a SQL file i need to feed to the database to initialize a new one, and it contains transactions. I don’t see a way to prevent HDBC from running my stuff in a transaction of its own.
14:16:02 <zoheb> :t h h :: (Num (a -> a), Fractional a) => a -> a
14:16:04 <lambdabot>     Could not deduce (Show a1, FromExpr a1) arising from a use of `h'
14:16:05 <lambdabot>     from the context (Fractional a)
14:16:05 <lambdabot>       bound by the inferred type of it :: Fractional a => a -> a
14:16:34 <zoheb> How do I fix this
14:17:58 <rwbarton> why are you trying to do "h h"?
14:18:12 <zoheb> sorry
14:18:18 <rwbarton> oh i get it now
14:18:23 <zoheb> The inferred type is Fractional
14:18:32 <rwbarton> "144x" -- this does not mean 144*x
14:18:37 <zoheb> But I can't seem to be able to apss arguments in
14:18:42 <zoheb> like h 12.0
14:18:51 <rwbarton> yes because "144x" means "apply 144 to x"
14:18:56 <zoheb> Its :t h
14:19:02 <zoheb> Not :t h h
14:19:07 <zoheb> oops
14:19:10 <rwbarton> yeah, I figured out that you pasted two lines as one
14:19:25 <Ptival> hello #haskell
14:19:31 <zoheb> wooh that worked
14:19:38 <linduxed> BUMP
14:19:48 <zoheb> thx
14:20:05 <Ptival> how does one having GHC 7.6.1 can install haskell-platform on a reasonable yet-not-Ubuntu-or-Debian linux distribution?
14:20:33 <rwbarton> step 1: install GHC 7.4.2
14:20:40 <Ptival> rwbarton: yeah I was there
14:20:43 <Ptival> but
14:20:48 <Ptival> does not work either...
14:21:27 <Ptival> rwbarton: http://paste.awesom.eu/Jfo
14:23:38 <Ptival> >=4 && <3, of course...
14:23:38 <ion> Heh, a nice kluge that works: runRaw conn "commit"; runRaw conn =<< readFile …; runRaw conn "begin"
14:24:03 <hpc> of course
14:25:24 <SaaMmY-laptop> I got some problem
14:25:58 <SaaMmY-laptop> doing the baby.hs
14:26:10 <SaaMmY-laptop> that code with doubleMe is not working
14:26:26 <SaaMmY-laptop> it says <interactive>:3:1: Not in scope: `doubleMe'
14:27:34 <Eduard_Munteanu> SaaMmY-laptop: pastebin your code
14:27:49 <Eduard_Munteanu> @where hpaste
14:27:49 <lambdabot> http://hpaste.org/
14:27:55 <SaaMmY-laptop> it's very simple
14:28:03 <SaaMmY-laptop> I have already pasted all
14:28:17 <Eduard_Munteanu> Where?
14:28:28 <SaaMmY-laptop> doubleMe 9
14:28:28 <SaaMmY-laptop> <interactive>:3:1: Not in scope: `doubleMe'
14:28:52 <Eduard_Munteanu> Did you define 'doubleMe'?
14:28:53 <pordan30> you need to import or define doubleMe
14:29:26 <SaaMmY-laptop> I am doing what the tutorial is driving me to do
14:29:44 <Cale> which tutorial?
14:29:46 <Eduard_Munteanu> SaaMmY-laptop: link?
14:29:47 <SaaMmY-laptop> http://learnyouahaskell.com/starting-out baby's first functions
14:30:27 <Eduard_Munteanu> SaaMmY-laptop: did you do the   ghci> :l baby   part?
14:30:34 <SaaMmY-laptop> yes
14:30:41 <Cale> and what did it say?
14:30:48 <SaaMmY-laptop> ok I pasteit
14:31:02 <Cale> Show us the contents of your baby.hs file too
14:31:33 <hpaste> sammy pasted “baby” at http://hpaste.org/77758
14:31:35 <pordan30> the tutorial tells you to save the definition in baby.hs, then load baby.hs in ghci using :l baby.hs. did you do this?
14:32:01 <Cale> SaaMmY-laptop: okay, now what's in the file named baby.hs?
14:32:10 <SaaMmY-laptop> nothing
14:32:17 <Cale> there's your problem
14:32:35 <SaaMmY-laptop> what I missed?
14:32:42 <SaaMmY-laptop> or messed up
14:32:47 <Cale> "Save this as baby.hs or something."
14:32:59 <Cale> where "this" means  "doubleMe x = x + x"
14:33:25 <SaaMmY-laptop> so inside the baby.hs I should write doubleMe x = x + x
14:33:27 <SaaMmY-laptop> right?
14:33:43 <Cale> right
14:34:03 <Cale> This defines the function named doubleMe
14:34:36 <Rc43> `fact n = n * (fact $ n - 1)` isn't tail-recursive, right?
14:34:53 <SaaMmY-laptop> by GHCi in terminal of linux how to exit and reenter GHCi
14:34:55 <Rc43> Why it doesn't overflow stack then?
14:35:00 <nooodl> yes it is
14:35:12 <Eduard_Munteanu> SaaMmY-laptop: ctrl+d
14:35:28 <SaaMmY-laptop> ok
14:35:40 <Rc43> nooodl, why it is tail-recursive? Last operation is *.
14:36:34 <geekosaur> isn't (*) strict on Int and Integer?
14:36:56 <Eduard_Munteanu> It is.
14:36:57 <nooodl> wait, err, it isn't, but ghc optimizes it anyway, i think
14:37:02 <hpc> tail recursive would be fact = fact' 1 where fact' n 1 = n; fact' n m = fact' (n * m) (m - 1)
14:37:14 <nooodl> ("it isn't" as in it isn't tail recursive yeah)
14:37:24 <Cale> Rc43: It will overflow stack, but the stack has nothing to do with a call stack.
14:37:31 <Cale> Rc43: There is no call stack
14:37:57 <Cale> Only a stack of pattern matches waiting for their scrutinee to be sufficiently evaluated to pattern match
14:38:01 <hpc> the relevant optimization for that function is strictness analysis, i think?
14:38:10 <Cale> (*) for Int and Integer will pattern match on both its arguments
14:38:23 <SaaMmY-laptop> ok done XD
14:38:37 <Rc43> Hmm, how strictness relates to tail-recursion?
14:38:54 <Rc43> *how does ...
14:38:58 <Eduard_Munteanu> It doesn't.
14:39:00 <linduxed> how would i concatenate two transposed lists?
14:39:20 <Eduard_Munteanu> But forcing the accumulator at every step prevents a stack overflow.
14:39:25 <linduxed> like, instead of 1 row and 7 cols, i've got 7 rows and 1 col
14:39:26 <hpc> linduxed: "transposed"?
14:39:30 <linduxed> i've got two of those lists
14:39:36 <hpc> so they are lists of lists
14:39:51 <linduxed> i want the result to be 1 list, 7 rows 2 cols
14:39:54 <hpc> :t zipWith (++)
14:39:56 <lambdabot> Monoid c => [c] -> [c] -> [c]
14:40:11 <hpc> s/c/[a]/
14:40:12 <linduxed> hpc: aaah yes
14:40:16 <linduxed> that's the one
14:57:38 <KindType> hi, is anyone familiar with "Named Instances for Haskell Type Classes"?
14:57:45 <KindType> http://www.cas.mcmaster.ca/~kahl/Publications/Conf/Kahl-Scheffczyk-2001.pdf
14:58:39 <SaaMmY-laptop> but can I set my functions bu GHCi?
14:58:48 <SaaMmY-laptop> *by
14:59:52 * geekosaur no idea what you just asked
15:01:30 <KindType> to me about "named instances" or about what SaaMmY-laptop said
15:01:31 <KindType> ?
15:01:46 <SaaMmY-laptop> as well as let x = 2 function I would set doubleMe for example by GHCi
15:02:25 <hpc> named instances look a lot like records to me
15:02:43 <copumpkin> they don't seem to address the uniqueness aspect of typeclasses
15:02:52 <rwbarton> SaaMmY-laptop: let doubleMe x = x + x
15:03:03 <hpc> copumpkin: if they're unique, why name them?
15:03:14 <SaaMmY-laptop> lol
15:03:14 <KindType> records and typeclasses and modules all look pretty similar
15:03:17 <SaaMmY-laptop> so easy
15:03:33 <KindType> instances are global now
15:03:42 <copumpkin> hpc: I mean more about dealing with the fact that a Data.Map "depends on the uniqueness of instances. If they aren't unique, it needs to be tagged with which instance was used
15:03:49 <hpc> KindType: you should check out agda, where they're just about unified ;)
15:03:51 <KindType> so if you want a set that is case-sensitive and one that is not, it is not possible with typeclasses
15:04:08 <copumpkin> sure it is
15:04:12 <copumpkin> you just use newtypes
15:04:21 <KindType> yeah, but that kinda sucks right?
15:04:33 <copumpkin> yes, but the alternative does too
15:04:44 <copumpkin> unless these guys have a solution for it
15:04:46 <copumpkin> but I don't see it
15:04:47 <KindType> are you just reading the paper now? or have you seen it before
15:05:01 <hpc> the more useful extension would surely be implicit newtype wrapping (when it can be inferred as "this must be wrapped")
15:05:08 <copumpkin> I just skimmed it looking for them to address my concern with this scheme (a lot of people have talked about it, and scala does basically this)
15:05:29 <hpc> then your magical crazy-code is compatibile with modules that don't enable the extension
15:06:26 <hpc> this all reminds me i have the ghc book on my kindle, waiting for me
15:06:41 <copumpkin> KindType: so if I built a Data.Map using one Ord instance, and want to merge it with one using a different Ord instance, how do I tell that they were built using different instances?
15:06:50 <copumpkin> the current code is more efficient because it can assume that the orderings are consistent
15:06:56 <rwbarton> looks even more like records + implicit parameters
15:07:03 <copumpkin> yeah
15:07:10 <copumpkin> which is what scala does, and Agda
15:07:18 <copumpkin> Agda can deal with the map thing because it's dependent
15:07:28 <KindType> now when you say "Set.fromList ["a","A"]" it uses the global instance of Ord for strings
15:07:31 <KindType> they are saying
15:07:33 <KindType> ...
15:07:37 <KindType> one sec
15:07:45 <SaaMmY-laptop> lolooooooooooooool http://s3.amazonaws.com/lyah/baby.png
15:07:56 <hpc> rwbarton: the fun part is combining that with constraint kinds
15:08:03 <KindType> Set.fromList # CaseInsensitive ["a","A"]
15:08:16 <KindType> which results in {"a"}
15:08:26 <copumpkin> KindType: yes, and then you take the resulting Set and want to merge it with a Set that was constructed differently...
15:08:31 <SaaMmY-laptop> I am building my baby
15:08:32 <SaaMmY-laptop> lol
15:08:37 <beaky> what other languages have haskell-ish ADTs?
15:08:44 <hpc> SaaMmY-laptop: looks like johnny bravo :D
15:08:45 <Eduard_Munteanu> ML
15:08:47 <KindType> the typeclass sticks around as far as i can tell
15:08:57 <beaky> ah was hoping that C++ had them :(
15:09:06 <hpc> beaky: from what i have seen you can fake them a bit in OO languages
15:09:07 <copumpkin> KindType: so I write union :: Set a -> Set a -> Set
15:09:11 <copumpkin> KindType: how do I write it?
15:09:18 <KindType> I understand your question
15:09:21 <hpc> the type is a super-class of the "value" subclasses
15:09:25 <KindType> This is why I am asking about the paper
15:09:26 <espringe> beaky: boost::variant
15:09:27 <SaaMmY-laptop> it's not of mine hpc http://learnyouahaskell.com/starting-out
15:09:29 <pordan30> coq permits named instances using the dependent record based implementation of type classes, so you can parameterize them on ord instances, if i recall correctly. =/
15:09:35 <hpc> SaaMmY-laptop: i know
15:10:06 <copumpkin> KindType: it seems like to be effective, such a proposal would need a new type-level witness for the "identity" of the typeclass in question, and then you'd be able to refer to that identity as a dummy type parameter in data structures that care
15:10:08 <KindType> It appears that they do not get rid of the constraints
15:10:23 <copumpkin> so the Map would acquire an additional type parameter to acknowledge the source of its ordering
15:10:23 <KindType> this is all in the paper
15:10:44 <KindType> nevermind
15:11:06 <KindType> I was just curious to learn more about that particular paper
15:11:54 <KindType> I think I'll send the authors an email to see if they have any advice
15:11:55 <rwbarton> oh, it talks about implicit parameters
15:13:35 <pordan30> most of the papers on drawing (directed) graphs are oriented toward implementation in imperative languages, and are heavy on numerical computation. are there algorithms more suited to implementation in functional languages, and in particular that reduce the computation overhead by eliminating numeric calculations?
15:13:43 * copumpkin shrugs
15:14:25 <beaky> is it possible to write a haskell-to-C compiler?
15:14:34 <copumpkin> we have one
15:14:37 <beaky> oh
15:14:41 <copumpkin> GHC will produce horrendous C if you ask it to
15:14:44 <copumpkin> JHC also does it
15:14:54 <beaky> how do I make my GHC do that?
15:14:57 <copumpkin> GHC only really does it now for porting
15:14:59 <hpc> -fvia-C
15:15:01 <copumpkin> it used to have an option to do it everywhere
15:15:03 <copumpkin> but that's deprecated now
15:15:10 <hpc> er no
15:15:17 <beaky> The -fvia-C flag does nothing; it will be removed in a future GHC release
15:15:19 <beaky> :(
15:17:57 <pordan30> beaky: i believe that idris and epigram compile to an intermediate language called epic, which compiles to c code. you could look at the implementation of epic, i suppose.
15:18:05 <SaaMmY-laptop> what about haskell as website language code?
15:18:25 <hpc> SaaMmY-laptop: my website is haskell cgi, with no framework
15:18:31 <hpc> there's also snap, happstack, and yesod
15:18:47 <hpc> which give varying degrees of expressiveness
15:18:50 <luite> and scotty is a very small framework, perhaps easier to learn
15:19:04 <luite> but doesn't have much convenience of type safety
15:19:26 <hpc> if you want the absolute minimum to get a website started, this magic function is all you really need for inspiration:
15:19:33 <Taslem> I'm looking for an explanation of the foreign function interface which uses an example other than "math.h sin".
15:19:42 <hpc> wrap b a m = do {putStrLn b; m; putStrLn a}
15:19:43 <Taslem> I want to see how it's done if you actually defined the C function yourself.
15:19:49 <SaaMmY-laptop> wow hpc nice to know so if I learn haskell I can build a website... and how to?
15:20:38 <SaaMmY-laptop> cgi
15:20:47 <hpc> SaaMmY-laptop: if you want to learn the most about web development in general, you want happstack
15:21:08 <hpc> if you want to learn how sites are made in other languages, cgi might be more relevant
15:23:04 <Taslem> Anyone any idea of FFI tutorials for me?
15:23:11 <mauke> cgi is never relevant
15:23:25 <hpc> mauke: php
15:23:36 <johnw> Taslem: i'd strongly recommend starting out with a wrapper library, like Bindings-DSL
15:23:43 <SaaMmY-laptop> http://www.haskell.org/haskellwiki/Practical_web_programming_in_Haskell found it very well cool
15:23:44 <johnw> it can make the Haskell FFI a lot simpler to work wih
15:23:58 <mauke> hpc: what
15:25:02 <Taslem> johnw: Is it that hard to import a single function from C?
15:25:11 <Ralith> nope.
15:25:11 <johnw> not at all
15:25:24 <johnw> if you just want a single function, using the regular Haskell FFI
15:25:27 <mauke> @where ffi
15:25:27 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/haskellch8.html
15:25:31 <pordan30> is yesod in general not recommended for web applications, then? there is an entire book on it, now.
15:25:41 <johnw> pordan30: who says not to use Yesod?
15:25:58 <hpc> im not recommending yesod because i haven't used it
15:26:20 <Clint> i'm recommending yesod because i haven't used anything else
15:26:29 <johnw> same as me
15:26:37 <stepcut> I recommend Happstack, because it's awesome
15:26:55 <pordan30> hpc: that makes sense
15:27:05 <pordan30> johnw: nobody in particular; it was the impression i got from the above discussion
15:27:07 <SaaMmY-laptop> I have set with let doublestuff x = x + x + etc but I want to write it on baby.hs
15:27:23 <Clint> i was told to use yesod by a disgruntled happstack user
15:27:37 <stepcut> did they say why they were disgruntled?
15:27:41 <Taslem> Okay, where are the files you're importing from supposed to be located?
15:28:00 <Clint> stepcut: "there are better ways to do things now" or something like that
15:28:33 <pordan30> SaaMmY-laptop: have you defined doublestuff in the file baby.hs, yet? recall that you /must/ use let to define things at the prompt, but don't use let when writing definitions in a file.
15:28:46 <hpc> happstack's different components use a lot of TH
15:28:51 <stepcut> Clint: that is a rather odd complaint. It seems to imply that happstack is using old, obsolete techniques.
15:28:59 <Clint> that is certainly how i inferred it
15:29:00 <stepcut> hpc: not compared to yesod..
15:29:06 <hpc> lol
15:29:49 <stepcut> Clint: there are certainly some parts of happstack which are older..but happstack is constantly evolving. By the next release there will be practically no code that is in Happstack a few years ago
15:30:08 <walkswithpandas> for what it's worth I was talking to someone in industry recently, he preferred snap over yesod
15:30:12 <SaaMmY-laptop> pordan30 so I can't define on prompt writing on file... neither with other that is not let?
15:30:19 <walkswithpandas> haven't used either myself though
15:30:22 <luite> walkswithpandas: was it mighybyte? :p
15:30:33 <walkswithpandas> nah someone at a hackathon
15:30:33 <stepcut> Clint: in my opinion, many of the ways that happstack does things (compared to yesod) are more flexible and powerful.
15:30:51 <rwbarton> SaaMmY-laptop, if you want to write to a file, use a text editor
15:30:56 <rwbarton> ghci is not a text editor
15:31:06 <SaaMmY-laptop> ah ok
15:31:37 <rwbarton> normally people write their definitions in the text file first, and use ":l myfile" or ":r" to load into ghci for testin
15:31:40 <rwbarton> g
15:31:42 <stepcut> Clint: for example, yesod has a simplistic system for defining type-safe urls, whereas happstack has several methods, given you a choice of completely automatic, highly expressive combinators, and other options
15:32:18 <Clint> i guess i should try it for something
15:32:38 <luite> on the other hand, the standard happstack way requires you to repeat your routes three times, while with yesod you list them only once
15:32:47 <stepcut> Clint: the hamlet templating library is rather restrictive and supports on a few basic control structures, HSP gives you the full expressive power of Haskell and an even more XML-ish syntax
15:33:34 <stepcut> luite: no, you can do thing things yesod way with web-routes as well
15:34:28 <stepcut> luite: i generally just derive the routes from the types automatically anyway
15:34:54 <Clint> stepcut: is HSP what i'm seeing at http://www.happstack.com/c/view-page-slug/9/happstack-lite#templates ?
15:35:07 <stepcut> Clint: no that is blaze-html
15:35:36 <startling> blaze-html is super nice if you don't mind compiling your templates in
15:35:44 <stepcut> Clint: this is HSP, http://www.happstack.com/docs/crashcourse/Templates.html#hello-hsp
15:36:07 <luite> stepcut: oh i meant boomerang, but if you can derive the routes, you're back to two times, right?
15:36:22 <startling> wow, that's a lot of dslery
15:36:28 <stepcut> luite: the other time being when you define your routing function?
15:36:32 <luite> yeah
15:36:48 <stepcut> luite: that can be automatically derived as well
15:36:55 <luite> oh how?
15:37:02 <Clint> stepcut: that's kind of scary
15:37:14 <startling> oh, it's not actually valid haskell? that's less scary
15:37:19 <stepcut> luite: I have a patch, I just commit it :)
15:37:25 <luite> ah
15:37:28 <stepcut> Clint: scary in what way?
15:37:37 <Clint> the source transformation
15:37:40 <stepcut> Clint: hamlet (used by yesod) is essentially the same thing, but less flexible
15:37:51 <Clint> hamlet goes into template files
15:38:26 <stepcut> Clint: explain?
15:38:56 <Clint> i mean i have a blah.hamlet file and then i use it with $(widgetFile "blah.hamlet")
15:39:38 <hpaste> neutrino pasted “Haskell library reference in Vim” at http://hpaste.org/77759
15:39:50 <neutrino> enjoy :)
15:40:41 <stepcut> Clint: yes.. that is just using template haskell to suck the template files into Haskell at compile time and compile them. You can do similar things with HSP
15:41:16 <Clint> ok
15:41:41 <stepcut> Clint: support for that could be better, and is high on the TODO list after the current refactoring of HSP is completed
15:42:55 <Clint> stepcut: where's the auth stuff?
15:43:30 <stepcut> Clint: http://hub.darcs.net/stepcut/happstack-authenticate
15:43:43 <fliip> whats the best way to get a list of all pairs of natural numbers?
15:44:32 <simpson> fliip: Did you want them in a certain order?
15:44:44 <startling> > [(a, b) | a <- [1..], b <- [1..]]
15:44:45 <lambdabot>   [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(1,11),(1,12)...
15:44:59 <tromp__> > [(i,j)|(j<-[0..],i<-[0..j-1]]
15:45:01 <lambdabot>   <hint>:1:10: parse error on input `<-'
15:45:12 <tromp__> > [(i,j) | j<-[0..],i<-[0..j-1]]
15:45:14 <lambdabot>   [(0,1),(0,2),(1,2),(0,3),(1,3),(2,3),(0,4),(1,4),(2,4),(3,4),(0,5),(1,5),(2...
15:45:16 <startling> > [(0, 0)..]
15:45:18 <lambdabot>   No instance for (GHC.Enum.Enum (t0, t1))
15:45:18 <lambdabot>    arising from a use of `e_100'
15:45:18 <lambdabot>  ...
15:45:22 <startling> bah
15:45:26 <fliip> Hehe. Thanks =)
15:46:03 <startling> (n, m) where n and m are both enums should have an Enum instance.
15:46:08 <simpson> The Morton trick would be good here, although I don't think there's a speedy way to express it in Haskell.
15:46:12 <Clint> stepcut: anything for proxy passthrough?
15:46:27 <tromp__> mind only gives ordered pairs though
15:46:30 <tromp__> mine
15:46:31 <stepcut> Clint: yes.. what are you looking to do ?
15:46:53 <Clint> stepcut: use a reverse proxy for authentication, then authorize within the app
15:47:09 <tromp__> > [(i,s-i) | s<-[0..],i<-[0..s]]
15:47:11 <lambdabot>   [(0,0),(0,1),(1,0),(0,2),(1,1),(2,0),(0,3),(1,2),(2,1),(3,0),(0,4),(1,3),(2...
15:47:24 <tromp__> that gives all pairs, ordered by their sum
15:47:32 <stepcut> Clint: what would that require of happstack / happstack-authenticate?
15:47:40 <fliip> Ah ok thanks. =)
15:48:06 <Clint> stepcut: parsing one or more http headers, in theory
15:48:56 <Leif_Bork> Hello, does inlining solve the same problem worker/wrapper transformations do?
15:50:04 <startling> Leif_Bork: what's a worker/wrapper transformation?
15:50:19 <stepcut> Clint: I don't understand the details of what you are trying to do to give you an answer. Running happstack behind something like apache via an reverse proxy requires no special code in happstack applications. There is also a Proxy module in happstack itself, http://www.happstack.com/docs/happstack-server-7.0.2/doc/html/happstack-server/Happstack-Server-Proxy.html, for other situations
15:51:08 <startling> Leif_Bork: oh. that looks more like what we call "stream fusion" than inlining
15:52:04 <Clint> stepcut: what i'm saying is that i want to have people authenticate to the reverse proxy using certificates, then Apache (or whatever) can give the identity to the happstack app, and then the happstack app can trust that
15:52:08 <Clint> but i gotta run
15:58:05 <fizzbang> i cannot seem to import some modules.. in particular, Data.Map.Strict and Data.Vec.Nat
15:58:44 <Leif_Bork> startling: I thought, will it ground arguments in the logical sense?
15:59:26 <fizzbang> anyone experienced this problem?
16:00:17 <Leif_Bork> startling: or will you have to define a a new function where the arguments that will be constant are passed?
16:03:22 <startling> Leif_Bork, not sure what you mean.
16:03:23 <pordan30> fizzbang: what version of containers and data.vec do you have installed? it looks like data.map.strict was added in containers 0.5.
16:04:17 <startling> is there some formalization for functions that traverse a structure and then repeat on all of the new structure's self-similar children? I feel like there might be a thing in lens.
16:04:27 <fizzbang> pordan30: i installed with macports, so i don't know how to check that...
16:05:05 <startling> fizzbang, ghc-pkg list | grep containers
16:05:07 <luite> startling: sounds like uniplate kind of things, see Control.Lens.Plated
16:05:18 <startling> luite: oh neat, thanks
16:06:06 <fizzbang> startling: oh, nice.. um.. yes, i have a 0.4.... version
16:06:49 <startling> fizzbang, what does ghc --version say?
16:07:41 <fizzbang> startling: 7.4.1 ... can i use ghc-pkg to upgrade?
16:08:11 <startling> fizzbang, no, but you can use cabal install. cabal update && cabal install containers
16:08:21 <pordan30> fizzbang: you can install the lastest version of a package like containers, e.g.: cabal install containers
16:08:38 <fizzbang> startling: pordan30: thank you both
16:08:49 <fizzbang> i didn't know about cabal-- i'll go read about it
16:09:39 <pordan30> fizzbang: data.vec.nat is in the package called Vec, for reference
16:10:36 <fizzbang> pordan30: thank you
16:11:21 <linduxed> i can't figure out a base case for this code https://gist.github.com/4075765
16:11:48 <Taslem> I have a C file ("test.c") containing  function "mysine". How would I go about icalling it with the FFI?
16:11:56 <linduxed> assmuing that seqStrings is [String] and all String are of same length
16:12:00 <bitonic> edwardk: Bound is pretty awesome.  thanks
16:12:05 <edwardk> thanks =)
16:12:19 <mauke> Taslem: first you write a header file for it
16:12:39 <linduxed> i was thinking of setting the basecase to "genLoop [[]]" but i don't think that's right
16:13:03 <Taslem> mauke: Okay, now has.
16:13:18 <mauke> what's the type of the function?
16:13:27 <bitonic> edwardk: it will probably save me a lot of fiddling in my masters thesis project, I'll let you know how it goes
16:13:30 <Taslem> CDouble -> CDouble.
16:13:35 <Taslem> (also it's pure)
16:14:10 <mauke> foreign import ccall "test.h mysine" mysine :: CDouble -> CDouble
16:14:30 <shachaf> Does "test.h " actually do anything?
16:14:41 <mauke> depends
16:14:50 <mauke> in current ghc, probably not
16:16:49 <Taslem> Okay, I get an error.
16:16:49 <Taslem> Main.o:fake:(.text+0xba): undefined reference to `mysine'
16:16:56 <mauke> from what command?
16:17:17 <Taslem> Just asking it to run. Need I do extra linking first?
16:17:36 <shachaf> "ghc, please run"?
16:17:39 <mauke> what the hell
16:17:41 <Taslem> (that is, when I compile it)
16:17:46 <mauke> WHAT COMMAND
16:18:07 <Taslem> ghc Main.hs
16:18:08 <Taslem> ?
16:18:24 <mauke> ok, try ghc Main.hs test.c
16:18:31 <stepcut> ghc --make
16:18:44 <Peaker> GHC 7 now defaults to --make
16:18:54 <stepcut> :O
16:18:54 <int-e> stepcut: --make is the default, but C dependencies can't be found by parsing hs files
16:18:55 <shachaf> Peaker: Well, not quite.
16:19:05 <shachaf> --make still makes some small difference that I can't recall.
16:19:08 <Taslem> Okay, that appears to work.
16:19:13 <stepcut> craaaazy
16:19:13 <Peaker> oh
16:19:17 <Taslem> Thanks.
16:22:06 <bzm3r> Hello. I am a newbie who is chugging through some tutorials for Haskell. Anyway, I am at the stage where I am creating a new data type, and I'm typing out the constructors, separating them using the | symbol, but it's tedious having to painstakingly select the right number of spaces to indent in a way that looks good (with the | below the initial =) -- is there a recommended IDE that would take care of a lot of this indentation type 
16:22:48 <linduxed> bzm3r: vim does it for me, but if you're not into vim already then it will take a while to learn
16:22:51 <startling> bzm3r, emacs with haskell-mode does it.
16:22:55 <linduxed> bzm3r: what OS are you on btw
16:23:02 <startling> ditto wrt "it will take a while to learn"
16:23:13 <clahey> But not quite as long to learn as vim.
16:23:19 <linduxed> clahey: haha, true
16:23:26 <bzm3r> I'm on Win7 -- I haven't gotten into vim or emacs yet, is it time I bite the bullet and get to it?
16:23:46 <linduxed> bzm3r: well, if you just want to code right now, i think that notepad++ handles what you want
16:24:00 <linduxed> bzm3r: sublimetext 2 i think does it too
16:24:05 <startling> isn't there some haskell-specific ide people use?
16:24:20 <bzm3r> Does it? That's what I have right now (Notepad++), not sure if I have enabled it right then!
16:24:53 <linduxed> bzm3r: but as for "biting the bullet"... well i love vim, fantastic editor, and people using emacs will say the same, but neither is a "jump right in" editor
16:25:11 <clahey> startling: Yes.  haskell-mode.  :)
16:25:16 <linduxed> bzm3r: i'd say it's worth it in the long run, i wouldn't switch for anything now, but it sure takes a while
16:25:17 <bzm3r> linduxed: Yeah :/
16:26:08 <startling> clahey: heh, not really what I was going for
16:26:43 <linduxed> bzm3r: http://stackoverflow.com/questions/734309/haskell-ide-for-windows#734768
16:30:08 <startling> edwardk: why isn't there an IndexedPlated yet???
16:30:33 <edwardk> hadn't needed it
16:30:39 <edwardk> it seems somewhat plausible
16:31:26 <startling> edwardk: yeah, it seems like it'd be useful for indexed trees. I feel like aeson et al could benefit from it
16:32:10 <edwardk> you can walk down with a zipper, and get the path since focus is indexed, but its not quite the same ;)
16:32:33 <startling> edwardk: oh interesting. I need to look at that, then.
16:34:07 <startling> edwardk, btw, is there something in C.L.Plated that traverses a structure and then applies itself to all of the new structure's self-similar children?
16:34:38 <edwardk> you mean editing it from the top down rather than from the bottom up?
16:34:44 <startling> I guess it's 'transform' but top-down
16:34:45 <startling> yeah
16:35:00 <edwardk> there wasn't one in Uniplate, so I didn't add one in Plated
16:35:22 <edwardk> descend can be used recursively in that fashion, but its kinda redundant
16:35:32 <startling> alright. I don't mind writing it, just thought I'd ask first.
16:35:54 <startling> 'transform' might work for my purposes, though. hmm
16:36:02 <edwardk> if you come up with a nice one, feel free to send me a patch
16:36:26 <startling> will do.
16:38:04 <carlos_> Need help... Trying to convert ods file (libreoffice) to a csv file using hxt. Not working...
16:38:42 <carlos_> Does somebody knows some tutorial?
16:39:41 <Cale> carlos_: Well, what's not working?
16:40:50 <Cale> hxt is probably the most detailed and hence complicated to use XML libraries available for Haskell -- you might try and see if you can get away with something simpler like Text.XML.Light
16:41:26 <carlos_> I wrote the code chainning the arrows, but a empty list comes out. Not sure, maybe a namespace issue (isElem >>> hasName "office:document-content" >>>)...
16:42:34 <startling> wow, C.L.Zipper is cool
16:43:16 <Cale> carlos_: Maybe try hasQName?
16:44:06 <carlos_> I'm gonna take a look at it. Thanks...
16:44:22 <Cale> actually using hasNameWith might be easier
16:44:33 <Cale> So you can just take apart the QName and check that it matches
16:44:47 <Cale> Or, you could just go with hasName "document-content"
16:45:04 <Cale> because I think that just tests if the local part of the name matches
16:46:01 <carlos_> Does hasName tests just the local name (the thing after the ":")?
16:46:07 <Cale> I think so
16:46:50 <carlos_> Hum... Gonna rewrite, test, and come back in a minute...
16:46:51 <Cale> You could use hasNameWith (\qn -> namePrefix qn == "office" && localPart qn == "document-content")
16:47:17 <Cale> (I haven't tried that -- it's just an educated guess based on the documentation and source :)
16:48:20 <startling> edwardk: hmm, looks like I need Monad for this
16:48:28 <Cale> Or hasQName (mkName "office:document-content")  might also work
16:48:30 <startling> I've got "recurse fn p = traverse fn p >>= plate (recurse fn)"
16:49:19 <Cale> carlos_: Honestly, the whole business of namespaces, local parts, and namespace URIs is pretty confusing
16:51:29 <edwardk> :t let recurse fn p = traverse fn p >>= plate (recurse fn)
16:51:31 <lambdabot> <no location info>:
16:51:32 <lambdabot>     not an expression: `let recurse fn p = traverse fn p >>= plate (recurse fn)'
16:51:38 <edwardk> :t let recurse fn p = traverse fn p >>= plate (recurse fn) in recurse
16:51:40 <lambdabot> (Monad m, Applicative m, Traversable t, Plated (t b)) => (b -> m b) -> t b -> m (t b)
16:51:46 <edwardk> :t let recurse fn p = mapM fn p >>= plate (recurse fn) in recurse
16:51:47 <lambdabot> (Monad m, Applicative m) => (b -> m b) -> [b] -> m [b]
16:52:01 <edwardk> :t let recurse fn p = mapM fn p >>= mapMOf plate (recurse fn) in recurse
16:52:03 <lambdabot> Monad m => (b -> m b) -> [b] -> m [b]
16:52:26 <edwardk> :t let recurse fn p = Data.Traversable.mapM fn p >>= mapMOf plate (recurse fn) in recurse
16:52:28 <lambdabot> (Monad m, Traversable t, Plated (t b)) => (b -> m b) -> t b -> m (t b)
16:52:58 <startling> it's always fun when I write something that has a type signature longer than its definition.
16:53:47 <edwardk> the Plated t b in there is a little strange
16:53:50 <edwardk> afk a bit
17:02:21 <Cale> startling: let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
17:02:59 <startling> Cale: huh?
17:03:19 <Cale> (ask ghci for the type of that ;)
17:03:43 <startling> :t let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x) in f3
17:03:44 <lambdabot> t -> ((((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t,
17:03:44 <lambdabot>  t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t,
17:03:45 <lambdabot> t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t,
17:03:45 <lambdabot> t))), (((t, t), (t, t)), ((t, t), (t, t))))))), (((((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t,
17:03:45 <lambdabot>  t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))))), ((((((t, t), (t, t)), ((t, t),
17:03:46 <lambdabot> (t, t))), (((t, t), (t, t)), ((t, t), (t, t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))), (((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t,
17:03:48 <lambdabot>  t)))), ((((t, t), (t, t)), ((t, t), (t, t))), (((t, t), (t, t)), ((t, t), (t, t))))))))
17:03:56 <bytbox> wtf
17:03:57 <Cale> Note that I did not say "ask lambdabot for the type of that"
17:04:00 <amatsu> Whoa.
17:04:19 <startling> Cale, I wanted to share with the class.
17:04:28 <amatsu> Cale: but what's it do?
17:04:37 <startling> (I didn't know it would be *that* long, though)
17:05:08 <Cale> amatsu: It's a function which makes a deeply nested tree of pairs all with the same value at the "leaves"
17:05:10 <mapreduce> It's an implementation of Perl.
17:05:31 <startling> mapreduce, oh, is that how pugs worked?
17:05:31 <amatsu> Oh, I see it now
17:05:36 <Cale> (what it does is actually pretty obvious from the type)
17:05:42 <amatsu> lol
17:05:56 <startling> oh, I figured out the best way to do my `recurse`
17:06:03 <startling> :t let recurse fn p = fn p >>= mapMOf plate (recurse fn) in recurse
17:06:05 <lambdabot> (Monad m, Plated b) => (b -> m b) -> b -> m b
17:16:29 <startling> @tell edwardk recurse fn p = fn p >>= mapMOf plate (recurse fn)
17:16:29 <lambdabot> Consider it noted.
17:17:26 <randomclown> There is an irc client for emacs/
17:18:00 <bgamari> randomclown, erc
17:18:18 <bgamari> randomclown, I played around with it for a while; it left much to be desired
17:18:27 <bgamari> oh, I see
17:24:18 <linduxed> hey guys, i'm getting an infinite loop in this code https://gist.github.com/4076038
17:24:33 <linduxed> it's probably due to the base case
17:24:37 <linduxed> in genLoop
17:24:41 <tomeo> f = g N [1..N] where N = 9999, am I using where incorrectly?
17:25:18 <linduxed> it never happens. from what i can tell, tailColumns (on line 13) fails due to head not getting any char anymore
17:25:30 <Vyn> tomeo: Correctly
17:25:34 <simpson> tomeo: Remember that capital letters for identifiers are only for types and constructors.
17:25:44 <Vyn> But yes, what simpson said
17:25:49 <tomeo> simpson: ah then that must be ut :D thanks a lot
17:26:12 <tomeo> yay, compiles :)
17:26:37 <linduxed> so i think that the base case for genLoop needs to match for something like [[],[],[]] but i have no idea how to do that
17:26:43 <linduxed> i mean that's my guess at least
17:26:56 <slack1256> to use syb I just need Data.Data or anything else?
17:31:19 <randomclown> linduxed: are all the strings the same length?
17:31:54 <linduxed> randomclown: yes
17:33:34 <randomclown> If you just want to check of [[],[],[]] you could just filter null and check if the result is an empty string.
17:33:38 <randomclown> s/of/for
17:35:51 <randomclown> > all null [[],[],[]]
17:35:53 <lambdabot>   True
17:38:31 <linduxed> oh wtf
17:38:38 * hackagebot minions 0.1.0.0 - A fast parallel ssh tool  http://hackage.haskell.org/package/minions-0.1.0.0 (JasonHickner)
17:38:51 <linduxed> randomclown: so i did this change https://gist.github.com/4076090
17:39:11 <linduxed> randomclown: now for some weird reason, tailColumns is *always* []
17:39:15 <linduxed> this makes no sens
17:39:41 <linduxed> *sense
17:43:58 <randomclown> if tailColumns is [] then zipping it with anything is []
17:44:27 <randomclown> just return [[],[],[]...] and use that to zip, instead of [], put seqTails
17:45:50 <hpc> see also, the ZipList functor
17:45:58 <hpc> (or applicative, rather)
17:48:05 <linduxed> aaaah
17:48:31 <linduxed> because zip always goes with the shortest list?
17:49:11 <hpc> it zips until it runs out of stuff in one or both lists
17:49:16 <hpc> you can't zip something with nothing, after all
17:49:23 <hpc> :t zip
17:49:24 <lambdabot> [a] -> [b] -> [(a, b)]
17:50:26 <linduxed> ok, new problem then
17:51:36 <linduxed> who do i express "[[],[],[]...repeat as many times as length $ seqStrings...]"
17:51:48 <hpaste> neutrino annotated “Haskell library reference in Vim” with “Haskell library reference in Vim (annotation)” at http://hpaste.org/77759#a77762
17:51:58 <linduxed> redundant $ there, but you get the picture
17:52:36 <cl_away> linduxed: repeat []
17:52:39 <cl_away> > repeat []
17:52:41 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[]...
17:52:50 <cl_away> linduxed: What is it you're trying to do though?
17:53:01 <linduxed> cl_away: check che link above from me
17:53:44 <shapr`> oh hai!
17:53:55 <mapreduce> > take (length "some string") $ repeat []
17:53:57 <lambdabot>   [[],[],[],[],[],[],[],[],[],[],[]]
17:54:01 <linduxed> repeat [] worked!
17:54:24 <linduxed> since it goes with zipWith, i didn't even need to check length and so on
17:54:41 <hpaste> shapr pasted “QuickSort” at http://hpaste.org/77763
17:55:12 <shapr`> I'm making screenshots for my ACM talk on Thursday!
17:55:19 <shapr`> So, taking a picture of hpaste right now.
17:55:30 <cl_away> linduxed: What is generateRow?
17:55:57 <cl_away> linduxed: I still don't understand what the general goal is.
18:00:10 <linduxed> cl_away: i'll give you a link in a second
18:01:21 <cl_away> linduxed: Also, is this for a homework assignment?
18:02:03 <linduxed> not this part specifically, this is groundwork for an assignment
18:02:16 <linduxed> later on, that question would be answered "yes"
18:03:38 * hackagebot hobbes 0.1.0.0 - A small file watcher for OSX  http://hackage.haskell.org/package/hobbes-0.1.0.0 (JasonHickner)
18:04:09 <linduxed> there we go
18:04:10 <cl_away> linduxed: So, it's not a learn haskell assignment?
18:04:11 <linduxed> cl_away: https://github.com/linduxed/progp-molbio
18:04:35 <linduxed> cl_away: the file that i was just editing was Profile.hs
18:05:17 <linduxed> this is an old assignment that I've done about two years ago, that i'm redoing just to get my haskell proficiency up
18:05:55 <linduxed> based upon this code there will be another assignment which will actually be relevant today
18:06:29 <cl_away> What is map generateRow ?
18:06:35 <cl_away> And what is transpose . map generateRow
18:06:55 <cl_away> Oh, wait.
18:06:59 <cl_away> I think I see what you're doing.
18:07:04 <linduxed> erm
18:07:08 <linduxed> i don't see that code?
18:07:10 <linduxed> what?
18:07:11 <cl_away> What is map generateRow . transpose
18:07:18 <linduxed> what line? where?
18:07:22 <cl_away> Oh, I'm suggesting alternate code that you might want to look at.
18:08:04 <linduxed> omfg....
18:08:06 <linduxed> no...
18:08:12 <linduxed> nononono
18:08:19 <linduxed> that's so damn obvious
18:08:23 <linduxed> god damn it
18:08:41 <cl_away> You might need another transpose at the beginning.
18:08:42 <linduxed> i've been fighting with this piece of shit implementation and i could just have done map
18:10:09 <linduxed> well the only redeeming fact is that i can't picture how i'd do it with map
18:10:14 <linduxed> off the top of my head
18:11:00 <cl_away> Hope I was helpful without giving it away too much.
18:11:22 <cl_away> I would have been more circumspect, but I wasn't sure of the answer myself.
18:11:22 <linduxed> yeah, you gave me a different train of thought
18:13:02 <cl_away> Also, your algorithm for generateRow is O(n^2) in the number of strings.  If you sort the transposed strings, you can make an O(n) algorithm to do the compare making for an O(n log n) algorithm overall.
18:14:39 <linduxed> cl_away: while that's a good idea, i need to wrap my head around the map-solution first
18:14:50 <linduxed> cl_away: i'm giving optimization no thought at the moment
18:15:20 <cl_away> Sounds good.
18:15:43 <cl_away> I don't think the map is the important part so much as the pre-transpose is.
18:16:24 <linduxed> cl_away: one of my main objectives is to learn and get used to writing concise code
18:16:29 <linduxed> make it terse
18:16:36 <cl_away> Yeah, I understand.
18:16:43 <cl_away> I just meant as far as understanding, that was the important bit.
18:16:50 <linduxed> yeah thx
18:16:54 <cl_away> Oh, it's going to be tough if you have MolSeqs instead of Strings.
18:17:02 <cl_away> But you can use another application of map to make that not be a problem.
18:19:09 <cl_away> Anyway, I'm actually away now.
18:19:21 <linduxed> yeah, i noticed :-)
18:19:24 <linduxed> thx for the help
18:19:42 <bitonic> edwardk: btw, there are some mistakes in your slides - you probably know this
18:19:49 <edwardk> which slides?
18:19:50 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
18:20:07 <bitonic> edwardk: bound
18:20:35 <edwardk> which mistakes? i'll patch them for when/if i do another version of the talk
18:21:36 <bitonic> edwardk: slide 21, it should be `S' and not `Just'
18:21:43 <edwardk> ah yes
18:21:56 <edwardk> ok, that one i knew =)
18:22:09 <bitonic> I think there was another one, but I might just be tired.
18:22:24 <edwardk> no i had a couple of legit mistakes in there =)
18:22:24 <danharaj> I need to keep an IntMap of things but I also need to be able to find the lowest unused key. What do?
18:23:04 <copumpkin> unused key?
18:24:39 <danharaj> for an IntMap m, the lowest nonzero k such that `member k m` returns False
18:25:29 <simpson> edwardk: Huh. I have a project that would like lens == 3.* but it's kind of unhappy. I asked cabal to install my dependencies and it says, cabal: Couldn't read cabal file "lens/2.7/lens.cabal"
18:25:49 <simpson> Is this a cabal bug? This *is* the previous release of Ubuntu.
18:26:05 <edwardk> that sounds like something got borked in your cabal folder or your .ghc foldr or something
18:26:28 <simpson> Already nuked both of 'em. :3
18:27:44 <edwardk> then i have no idea what got borked in your ghc install ;)
18:27:57 <edwardk> i've seen this happen before with other packages, but i have no idea what the fix is
18:28:18 <simpson> But it's not something busted with lens-2.7?
18:28:27 <edwardk> simpson: it shouldn't be
18:28:28 <Igloo> What command are you running?
18:28:35 <simpson> $ cabal install --only-dependencies
18:28:41 <simpson> I can hpaste the cabal file if you like.
18:28:51 <simpson> This is with a clean .cabal, just updated the package list.
18:29:02 <edwardk> if you 'cabal install lens' what happes?
18:29:17 <Igloo> If you can work out where lens/2.7/lens.cabal is, does the contents look sane?
18:29:19 <simpson> Same error.
18:29:53 <Igloo> Or maybe it's failing to find the file at all? strace might help
18:30:15 <simpson> It's a file inside the hackage list, and it looks sane.
18:30:47 <simpson> It would like cabal >=1.8, and I've got cabal 1.10.1, cabal-install 1.10.2
18:32:04 <hpaste> shapr annotated “QuickSort” with “QuickSort (annotation)” at http://hpaste.org/77763#a77765
18:35:30 <slack1256> simpson: cabal 1.10  is >= than 1.8 because 10 > 8
18:35:54 <simpson> slack1256: Yes, I know.
18:36:44 <slack1256> simpson: sorry what I just said maybe was pedantic. I apologize for that. :)
18:37:03 <lispy> ?pl not . null
18:37:04 <lambdabot> not . null
18:37:05 <simpson> edwardk: A clue! I started deleting stuff out of the hackage package list just for S&G. After removing lens-2.7, it starts complaining about lens-2.7.0.1.
18:37:08 <geekosaur> hm.  someone check the cabal file for that version of lens, that it doesn;'t trigger one of the parser bugs in older cabal?
18:37:13 <simpson> So I remove that, and then it complains about lens-2.8...
18:37:35 <simpson> So I bet that you just started doing something in lens-2.7 that makes certain versions of cabal unhappy.
18:37:36 <lispy> I kind of wish there was already a not . null function, it's not much to type, but I rarely want null. I almost always want not . null.
18:38:12 * simpson shrugs and goes home
18:38:13 <lispy> :t guard . not . null
18:38:15 <lambdabot> MonadPlus m => [a] -> m ()
18:42:10 <edwardk> what version did cabal bench start working in?
18:44:49 <edwardk> if you can let me know what versions of cabal aren't happy i can bump the cabal version requirement
18:45:29 <shapr`> Is there some easy way I can substantiate the fact that Haskell jobs are real and pay actual money?
18:45:45 <shapr`> That is, something I can put in the slides for my ACM talk this Friday?
18:45:46 <dibblego> I have been doing it for years and anything else looks nuts to me
18:45:48 <dmwit> ?wiki haskell in industry
18:45:49 <lambdabot> http://www.haskell.org/haskellwiki/haskell_in_industry
18:46:08 <dmwit> ?wiki industrial haskell group
18:46:08 <lambdabot> http://www.haskell.org/haskellwiki/industrial_haskell_group
18:46:22 <dmwit> don't have a browser, so I can't check that those wiki pages actually exist =P
18:46:34 <edwardk> i write haskell for a living now, so there is at least one job.
18:46:53 <shapr`> edwardk: ok then, Where at?
18:46:56 <djahandarie> edwardk, since when do you write Haskell for a living?
18:47:01 <edwardk> S&P Capital IQ
18:47:03 <shapr`> Huh, AT&T uses Haskell?!
18:47:16 <edwardk> djahandarie: since i decided to rewrite our compiler in Haskell =P
18:47:21 <dmwit> There's also, um... Well-Typed, I think it's called?
18:47:23 <djahandarie> Hah.
18:47:39 <djahandarie> But what about all the interfacing with Java that you need to do?
18:47:48 <shapr`> Facebook uses Haskell?!?!
18:47:59 <sbahra> I use Haskell
18:48:23 <shapr`> Me too!
18:49:05 <Ghoul> Facebook uses haskell?
18:49:11 <shapr`> That's what I said!
18:49:12 <sbahra> I'm hoping to see more Haskell use in the coming months :-P
18:49:16 <frio> i think there's a pretty strong distinction between "uses haskell" and "is a haskell shop"
18:49:20 <frio> you'll probably find lots of the former
18:49:32 <shapr`> frio: Good point, I know there are several Haskell shops though...
18:49:38 <frio> technically, where i work uses haskell, but that's only because i write small tools for myself in it :)
18:49:41 <Ghoul> Minecraft uses haskell
18:49:44 <Ghoul> reliable sources inc.
18:50:24 <shapr`> Ghoul: This is more reliable: http://cufp.galois.com/2009/abstracts.html#ChristopherPiroEugeneLetuchy
18:50:32 <shapr`> Facebook gave a talk on how they use Haskell.
18:51:16 <Ghoul> Its more about Erlang tbh
18:51:22 <Ghoul> They mention haskell once in the blurb :C
18:51:35 <Ghoul> But his huge speech only makes me think of `The Erlang Movie` on youtube
18:51:39 <Ghoul> Which was a waste of my life.
18:51:53 <shapr`> I enjoyed it myself.
18:51:58 <Ghoul> haha
18:52:04 <shapr`> Great bit of humor.
18:52:15 <Ghoul> "So, I see you've fixed the bug then"
18:52:22 <edwardk> there are a bunch of startups in NY using it, there is of course also typlab using it in Silk, FPComplete, etc.
18:53:16 <shapr`> edwardk: So, primarily Haskell shops are FPComplete, Silk, Well-Typed, can you think of any others?
18:54:19 <frio> i think there's a few financial institutions using it
18:54:35 <edwardk> ozataman's startup, galois, bluespec, well-typed, bump (the guys who do the cell phone bumping thing)
18:54:36 <scoles> galois?
18:55:15 <edwardk> http://corp.galois.com/
18:55:25 <edwardk> they were kind of the haskell poster-child for the longest time
18:55:26 <scoles> i was adding it to your list but you beat me to it :)
18:55:52 <edwardk> ah =)
18:57:48 <simon_weber> hey all; I need some help with some ugly machine-generated code: http://pastebin.com/buVtZfHP
18:58:00 <simon_weber> why is x not of type Int?
18:58:20 <copumpkin> return isn't what you think it is
18:58:22 <copumpkin> :t return
18:58:24 <lambdabot> Monad m => a -> m a
18:58:29 <edwardk> and yes, there are tons of financial institutions using it. i presume credit suisse still has some haskell floating around, deutsche bank was using it when they had polakow and sclv there, standard chartered has a bunch of folks, tsuru capital, and i keep getting pinged by recruiters in singapore for other places =P
18:58:36 <Vyn> @def allCombs [] = [[]]; allCombs (x:xs) = c ++ map (x:) c where c = allCombs xs
18:58:36 <lambdabot> Maybe you meant: bf do let
18:58:38 <geekosaur> nor is do what you think it is
18:58:47 <Vyn> @let allCombs [] = [[]]; allCombs (x:xs) = c ++ map (x:) c where c = allCombs xs
18:58:48 <lambdabot>  Defined.
18:59:05 <Vyn> >allCombs [1..5]
18:59:17 <Vyn> > allCombs [1..5]
18:59:20 <lambdabot>   [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,...
18:59:32 <copumpkin> > filterM (const [False, True]) [1..5]
18:59:34 <simon_weber> ok. so how would I rewrite that to be a possibly multi-line function that returns a value at the end?
18:59:34 <lambdabot>   [[],[5],[4],[4,5],[3],[3,5],[3,4],[3,4,5],[2],[2,5],[2,4],[2,4,5],[2,3],[2,...
18:59:40 <simon_weber> I need to strip out the value from return?
18:59:59 <Vyn> copumpkin: Haha, thanks a lot, I'll look up filterM
19:00:01 <rwbarton> can just delete all the do/return stuff
19:00:02 <shapr`> edwardk: Thanks, I'll put in several of those.
19:00:04 <copumpkin> simon_weber: what does it mean to be a multi-line function?
19:00:14 <cmccann> the usual way to make a multi-line function is to stick a few line breaks in the middle of an expression :P
19:00:21 <edwardk> there is also a startup named bayeshive or openbrain working on a haskell-based external dsl for building experimental models/hierarchical bayesian models
19:00:28 <Vyn> Now bye. Thanks again
19:00:33 <copumpkin> Vyn: enjoy!
19:00:43 <simon_weber> basically, I'm attempting to convert an untyped procedural language into haskell code
19:00:45 <rwbarton> thanking time is over
19:01:12 <rwbarton> simon_weber: maybe you want f :: Int -> IO Int then?
19:01:40 <rwbarton> and print =<< foo y
19:02:44 <lispy> edwardk: oh cool
19:03:26 <simon_weber> rwbarton: I only want the IO at the top level. here's the grammar I'm trying to support: http://pastebin.com/EPBiTyjt
19:03:34 <geekosaur> do does not turn off type checking, nor does it let you simply write the same procedural code you'd write in some other language, which is what you appear to be tryingt to do
19:03:35 <simon_weber> it's a stripped-down version of ruby
19:04:06 <simon_weber> geekosaur: right. at the top level, I just want to print out the final resulting value from the converted code
19:04:09 <rwbarton> oh okay, so no side effects
19:04:13 <latermuse> what is the best way to learn how to use the store comonad?
19:04:15 <simon_weber> rwbarton: right
19:04:27 <rwbarton> then ignore what i said
19:04:32 <johnw> latermuse: have you googled for it?
19:04:32 <simon_weber> so I guess procedural was misleading there =) my bad
19:04:37 <rwbarton> yeah, a little :)
19:04:38 <edwardk> latermuse: by analogy to something more interesting, like image manipulation
19:04:40 <johnw> there are a few articles about Store out there
19:04:47 <latermuse> johnw: yes, there arent very many examples
19:05:03 <edwardk> latermuse: consider the store comonad Store (Int,Int) Color  -- pretend its an image with a selected pixel.
19:05:18 <geekosaur> the thing about do notation is that it turns into uses of >>= and >>.  it is NOT simply "pretend you're some other language"
19:05:56 <edwardk> now extract gets the value of that pixel. and extend takes a function from (an entire image with a selected pixel to the new value for that pixel) to a new image where that function has been applied everywhere to build up every pixel in turn
19:05:59 <simon_weber> geekosaur: ah, ok; so semantics are quite different than they are in scheme?
19:06:13 <geekosaur> very
19:06:17 <simon_weber> I see
19:06:57 <simon_weber> well, I guess it would be correct for me to remove all lines except the last...? that gets rid of the do/return
19:07:03 <simon_weber> since there aren't side effects
19:07:12 <simon_weber> aside from assignment/let
19:07:33 <latermuse> edwardk: is it that simple?
19:07:36 <KALLISTI> let is not really a side-effect
19:07:49 <simon_weber> KALLISTI: yes, sorry; I'm aware
19:08:01 <edwardk> latermuse: yes =P
19:08:17 * shapr` hugs johnw 
19:08:22 <latermuse> edwardk: haha thanks :) I think i can handle it now
19:08:25 <johnw> shapr!!
19:08:31 <shapr`> howdy johnw ! How's code?
19:08:33 <simon_weber> I'll ditch do/return and try to prune out useless statements. thanks all
19:08:55 <johnw> shapr`: going well; any day now I'll understand what edwark says to me
19:08:56 <edwardk> latermuse: there are a bunch of examples of it inside of 'lens' as well, there i use an indexed form of Store, it is called 'Context' in that package.
19:09:00 * shapr` laughs
19:09:20 <edwardk> latermuse: i use it for a bunch of combinators like 'holes', and to characterize lenses, etc.
19:09:26 <shapr`> I had two years of lunch time explanations from edwardk, I did make some progress towards understanding in that time.
19:09:40 <shapr`> edwardk: Dude, you should have shown up for my wedding! :-P
19:09:43 <latermuse> edwardk: thanks :)
19:09:56 <edwardk> shapr`: next time i'll buy tickets for the right month =P
19:10:10 <edwardk> shapr`: actually scratch that. i hope there isn't a next time ;)
19:10:23 <shapr`> Yah, me too. I like the wife I have.
19:10:40 <shapr`> She just told me I *better* like the wife I have!
19:10:51 <shapr`> That's what you get for IRCing with your wife looking over your shoulder.
19:11:00 <edwardk> =)
19:11:05 * shapr` mulls further talk revisions
19:11:17 <shapr`> I have about seven minutes of content for a twenty minute talk.
19:11:41 <coldpizza72i> is ($) :: (a->b)->a->b ?
19:11:56 <shapr`> :t ($)
19:11:57 <lambdabot> (a -> b) -> a -> b
19:12:04 <shapr`> coldpizza72i: Yes!
19:12:34 <edwardk> speaking of wives looking over your shoulder, Amy says 'damn right' =P
19:12:38 <shapr`> coldpizza72i: Alternatively, you can use http://www.haskell.org/hoogle/
19:12:50 <johnw> shapr: give a talk on time dilation and just say that you're giving them a practical demonstration
19:13:04 <johnw> hello, Amy!
19:13:12 <shapr`> johnw: I seriously considered talking about how Haskell is lazy and demand driven, and THEN asking if they had any questions.
19:13:24 <johnw> you won't remember me, I sat in Edward's car outside your house for 3 minutes
19:13:39 <shapr`> Bah, I'm jelous, I've never met johnw !
19:13:46 <johnw> where do you live shapr?
19:13:54 <djahandarie> For some reason edwardk driving seems like a scary thought to me.
19:14:01 <shapr`> Florence, AL ... far away from just about anything.
19:14:09 <johnw> djahandarie: we actually walked everywhere that night, or took the train
19:14:13 <copumpkin> damn right she does
19:14:13 <shapr`> djahandarie: I've ridden with edwardk, it really can be that scary.
19:14:14 <johnw> so I haven't actually seen him drive...
19:14:39 <shapr`> I think he does that just so his coworkers will drive him to and from home the rest of the time :-P
19:15:53 <edwardk> it helps. now i have the T, greatly cuts down on my need to menace society =P
19:23:10 <niteria> what does {-# SCC mean?
19:25:13 <geekosaur> {-# ... #-} is a compiler pragma.  The SCC pragma inserts a cost center for profiling
19:25:47 <geekosaur> (so it collects usage data for that spot in the expression)
19:26:23 <shapr`> {-# GO REALLY FAST HERE #-}
19:26:41 <pharaun> {-# RICER #-}
19:33:10 <rwbarton> edwardk: have you thought at all about trying to dualize the notion of lens?
19:33:47 <rwbarton> I just wrote down a bunch of thoughts on the topic
19:34:33 <edwardk> state monad algebras are boring
19:34:46 <rwbarton> that's not the dual i want
19:34:54 <edwardk> k
19:35:15 <rwbarton> http://hpaste.org/77766
19:35:38 <startling> edwardk, shachaf: are you guys still wanting benchmarks or have you got that covered?
19:35:49 <edwardk> more benchmarks are always welcome
19:37:40 <edwardk> rwbarton: hrmm
19:39:04 <edwardk> rwbarton: neat. working my way through the consequences
19:42:55 <Nereid> what are state monad algebras like?
19:44:08 <Nereid> why don't I just work it out.
19:44:39 <shapr`> Is it complete fiction to say that Yesod is vaguely similar to Rails?
19:44:54 <Nereid> no, they both have something to do with the web
19:45:02 <stepcut> shapr`: I think, in fact, that the #1 problem with Yesod is its rails influence :)
19:45:06 <shapr`> heh
19:46:00 <stepcut> shapr`: which results in the use of lots of code generators and scaffolding, when plain old Haskell would provide more power and flexibility
19:47:09 <startling> is there an application of Control.Lens.Zipper somewhere? I don't see how to use it.
19:47:37 <edwardk> startling: check the brainfuck example
19:47:45 <edwardk> its a bit trite though
19:48:10 <rwbarton> edwardk: the vague application I have in mind is to FRP--I might have a Behavior WorldState and want to use lenses to talk about Behaviors for particular pieces of the WorldState; dually(?) I might have an Event MassiveSumOfEvents and want to describe reactions to particular kinds of events
19:48:16 <startling> edwardk: thanks
19:48:41 <edwardk> rwbarton: hrmm
19:49:22 <mm_freak> is there a stream library that performs fusion?
19:50:01 <mm_freak> or am i safer using lists if i want performance?
19:50:05 <rwbarton> another colens example would be "b" as a summand of "(a, b)" for some particular "a0 :: a" (assume "Eq a")
19:51:11 <edwardk> that sounds a lot like a traversal roconnor got me to add
19:51:34 <rwbarton> sort of a dual to Map
19:51:45 <rwbarton> since Map a b is morally a -> b
19:51:47 <rwbarton> or a -> Maybe b
19:52:04 <Nereid> hmm
19:52:08 <zachk> morally? ;)
19:52:38 <Nereid> (1 + b)^a = 1 + C(a,1) b + C(a,2) b^2 + ...
19:52:38 <copumpkin> (Set a, a -> Maybe b) >_>
19:52:43 <slack1256> how long do you take to understand a library? I usually don't get it reading the haddock documentation
19:52:58 <johnw> it all depends on the library
19:53:11 <rwbarton> if the type a has finitely many values, ignoring bottoms, only valid in the lower 48 states, etc. etc.
19:53:24 <Nereid> :p
19:53:41 * hackagebot DAV 0.1 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.1 (ClintAdams)
19:53:59 <slack1256> johnw: how do you usually confront a new library
19:54:12 <slack1256> johnw: for example now I am trying to use 'cmdtheline'
19:54:15 <shapr`> slack1256: I mostly try to write small demonstrations for myself with a new library.
19:54:36 <rwbarton> for example you could imagine using this colens to filter out clicks on a particular GUI element while retaining other information associated to the click
19:55:11 <shapr`> I thought you'd misspelled colons there for a second.
19:55:30 <slack1256> shapr`: doing a exercise first and then integrate to the code base.
19:55:36 <slack1256> cool.
19:55:42 <shapr`> slack1256: Yah, I think that's the best way to learn anything.
19:55:55 <shapr`> Once I write an example for myself to learn a new feature, I save that for future use.
19:56:02 <shapr`> That's how I learn everything to do with programming.
19:56:18 <shapr`> I still have forloop.cpp in ~/src/cpp/
19:56:19 <slack1256> so you a have a directory with an example of every library you have used?
19:56:33 <slack1256> i would pay if you send me that directory
19:56:38 <linduxed> can someone tell me what hlint means with "Use section" for this line of code?   generateMatrix sequences = transpose $ map (flip generateRow seqLetters) (transpose onlyStrings) where
19:56:42 <shapr`> slack1256: my ~/src/ directory is extremely large
19:56:56 <linduxed> it complains right at the start of flip
19:57:07 <shapr`> slack1256: Like a Jedi's lightsaber, you need to build that directory for yourself.
19:57:10 <Nereid> linduxed: (`generateRow` seqLetters)
19:57:15 <Guest21720> Need help with HXT.  Trying to convert ods (libreoffice) to csv. The spreadsheet has rows. And inside rows, columns. Such is the tree. When trying to get the text inside the columns, I get [String]. All the columns get mixed. What I want is [[String]], where Columns = [String] and Rows = [Columns].
19:57:23 <Nereid> linduxed: that's what it wants you to say
19:57:28 <linduxed> ooooh
19:57:31 <linduxed> Nereid: thx
19:57:32 <shapr`> slack1256: Because it's a reference of what you've learned, and you can quickly refresh what you once knew even if you can't remember it right now.
19:57:55 <shapr`> Guest21720: Oh, I totally did that six or seven years ago, but I doubt I can even find the code nowadays.
19:58:05 <slack1256> shapr`: you just lost one buck.
19:58:08 <shapr`> Guest21720: I ended up using HXT's arrow critters, it's a good choice.
19:58:15 <slack1256> shapr`: but i understand what you are saying
19:58:49 <shapr`> Guest21720: I grabbed the ooxml reference and wrote converters, it's a good approach, took me about 12 hours to get it turning ms.doc files into a client's custom xml flavor.
19:59:00 <slack1256> you mostly remember what were you thinking at that time (or at least try). more than understanding the code itself.
19:59:45 <shapr`> slack1256: Sometimes when I think something should work, I can go back and look at my collection of examples.
19:59:52 <typoclass> linduxed: just to be sure -- you don't need to do every single thing that hlint tells you :-) they're just suggestions. look at them, consider them, then use your judgement
19:59:59 <shapr`> slack1256: Sometimes my understanding is broken, sometimes things have changed in the past X years :-)
20:00:21 <slack1256> specially in this language
20:00:24 <startling> I've got ~/code/playingwith/x/, it's fairly comprehensive
20:00:47 <ion> Wow. SmallCheck provides a nice Show (a -> b) instance.
20:00:49 <ion> λ> succ :: Char -> Char
20:00:51 <ion> {'a'->'b';'b'->'c';'c'->'d';'d'->'e'}
20:00:53 <linduxed> typoclass: well, so far every hint it has given me has been for the better
20:01:25 <Guest21720> Guys, does someone knows how to get a list of trees (subtrees) in HXT?
20:01:45 <linduxed> typoclass: i do give it some thought, but i generally like the advice it gives me
20:02:16 <startling> ion, it just enumerates over a couple values or what?
20:02:22 <typoclass> linduxed: alright :-)
20:02:27 <ion> startling: yeah
20:02:32 <startling> ion: that's interesting
20:03:15 <ion> λ> show (map toUpper)
20:03:17 <ion> "\"\"->\n  \"\"\n\"a\"->\n  \"A\"\n\"aa\"->\n  \"AA\"\n\"aaa\"->\n  \"AAA\"\n\"ab\"->\n  \"AB\"\n\"aba\"->\n  \"ABA\"\n\"b\"->\n  \"B\"\n\"ba\"->\n  \"BA\"\n\"baa\"->\n  \"BAA\"\n\"bb\"->\n  \"BB\"\n\"bba\"->\n  \"BBA\"\n\"c\"->\n  \"C\"\n\"ca\"->\n  \"CA\"\n\"caa\"->\n  \"CAA\"\n\"cb\"->\n  \"CB\"\n\"cba\"->\n  \"CBA\"\n"
20:03:54 <rwbarton> sounds a lot more useful than this one
20:03:56 <rwbarton> > show succ
20:03:58 <lambdabot>   Ambiguous type variable `a0' in the constraint:
20:03:59 <lambdabot>    (GHC.Enum.Enum a0) arisi...
20:04:00 <rwbarton> oh
20:04:06 <rwbarton> > show (succ :: Char -> Char)
20:04:08 <lambdabot>   "*Exception: show: No overloading for function
20:04:26 <rwbarton> (also, why did I write "show")
20:10:07 <Guest21720> Guys, does someone knows how to get a list of trees (subtrees) in HXT?
20:10:24 <rwbarton> ion: that's really cool. too bad it doesn't magically catch exceptions so that I can show a function like 'tail', though
20:12:21 <rwbarton> some spoon will take care of that, though
20:15:00 <linduxed> cl_away: much better - https://github.com/linduxed/progp-molbio/commit/34f6d053b63f31e62dac80e351f4d6b37efbad22
20:20:08 <simon_weber> is there a way I can get ghc to compile and run input from stdin?
20:20:31 <latermuse> is there a command to clear the screen in ghci?
20:20:38 <Ralith> ^L
20:20:48 <latermuse> a command that I can run from inside a haskell program
20:20:59 <latermuse> maybe one that clears the terminal screen altogether
20:21:03 <Ralith> why are you running ghci from inside a haskell program
20:21:38 <Ralith> or otherwise trying to control it from one
20:21:38 <rwbarton> I would venture to guess that latermuse is running a haskell program inside ghci
20:22:12 <latermuse> rwbarton: correct
20:22:23 <Ralith> simon_weber: 'runhaskell' will interpret from stdin
20:22:33 <statusfailed> woo I made a probably-useless chrome extension for hackage!
20:22:36 <statusfailed> https://chrome.google.com/webstore/detail/hackage-fu/dnpldbohleinhdgfnhlkofpgkdcfcfmf/related
20:22:40 <simon_weber> Ralith: just what I needed; thanks!
20:22:43 <rwbarton> well putStr "\ESC[H\ESC[J" seems to work
20:23:00 <Ralith> latermuse: why do you want to do that
20:23:19 <rwbarton> assuming you have a vaguely vt100-compatible terminal; or use ncurses or something if you want to do this for real
20:23:24 <latermuse> rwbarton: that does work. thanks
20:26:00 <latermuse> ralith: to run a quick ascii game demo in real time
20:26:19 <Ralith> latermuse: GHCI is not a game engine.
20:27:12 <ion> Manual escape sequences are evil, use http://hackage.haskell.org/package/terminfo
20:27:28 <Nereid> or ncurses
20:27:29 <latermuse> ralith: I know its not, but I am just practicing.
20:30:08 * applicative is planning on using only `ghc -e` for his game engine during Lent.
20:31:14 <Guest21720> Guys, does someone knows how to get a list of trees (subtrees) in HXT?
20:31:23 <Guest21720> Need help with HXT.  Trying to convert ods (libreoffice) to csv. The spreadsheet has rows. And inside rows, columns. Such is the tree. When trying to get the text inside the columns, I get [String]. All the columns get mixed. What I want is [[String]], where Columns = [String] and Rows = [Columns].
20:32:25 <latermuse> applicative: hehe. ;)
20:40:06 <pdxleif> Is the stuff starting at line 403 here along the lines of how iteratees work? http://freeassociation.svn.sourceforge.net/viewvc/freeassociation/trunk/libical/doc/UsingLibical.txt?revision=1001&view=markup
20:40:50 <davesque_> what would be the best way to represent a board (for a board game) in haskell?  i've made a stab, but i think there must be a better way to do it.
20:41:02 <pdxleif> read_stream is a user-defined function basically of type Int -> Handle -> IO String, and it gets passed to icalparser_get_line(parser,read_stream);
20:43:16 <Jafet1> Games, in mah haskell?
20:43:42 * hackagebot minions 0.2.0.0 - A fast parallel ssh tool  http://hackage.haskell.org/package/minions-0.2.0.0 (JasonHickner)
20:46:13 <davesque_> Games?
20:46:47 <davesque_> basically it would be a grid with variable width and size
20:47:02 <startling> davesque_, have you seen Array?
20:47:07 <statusfailed> Why variable width?
20:47:20 <statusfailed> or: how variable? :D
20:47:51 <davesque_> no, haven't looked at that.  it would be variable width so you could specify that it would be a 19x19 board or a 10x10 board or whatever
20:48:07 <davesque_> err variable width and height
20:48:46 <Ralith> that's not variable, that's specified
20:49:08 <davesque_> right, specified once you say what it is...variable in the sense that it's not always the same value.
20:49:22 <statusfailed> ooh sounds like Go
20:49:27 <davesque_> yep :)
20:49:30 <statusfailed> awesome
20:49:34 <dalaing_> indeed
20:49:46 <davesque_> just something i'm doing for fun
20:50:05 <davesque_> so an Array value would be the best way?
20:50:38 <statusfailed> welp, Arrays are immutable
20:50:59 <davesque_> as is everything i would imagine
20:51:12 <statusfailed> fair point :p
20:51:26 <statusfailed> you can do destructive updates in the ST monad
20:51:30 <statusfailed> 'destructive'
20:51:36 <statusfailed> magical
20:51:55 <Ralith> ooooor you could just do without mutability.
20:52:02 <statusfailed> or you could just use a Map
20:52:05 <Ralith> if you're writing go, you don't need it to be blazingly fast.
20:52:09 <Jafet> This game uses a string!
20:52:09 <davesque_> well, it would be nice to have a game history
20:52:12 <Jafet> @let xo s=let[p,q]=(show=<<).(`elemIndices`filter(/='|')s)."XO";i(n,[])=":-"++["(|O"!!(n+1)];i(_,q)=c q."012|345|678"++if w q then" :-)"else"";c q x|x=='|'='|'|elem x p='X'|elem x q='O'|True='.';w p=ap(==)(sort.intersect p)`any`words"012 345 678 036 147 258 048 246";n=first(0-);x a b p q|w p=(1,[])|w q=(-1,[])|True=z$(:p).(['0'..'8']\\union p q)where z[]=(0,[]);z m=foldr y a m;y p a|a<b=max a(fst.n$x(n b)(n a)q p,p)|True=a;in i$x(-1,[])(1,[])q p
20:52:14 <lambdabot>  Defined.
20:52:25 <Jafet> > xo ".X.|...|..."
20:52:28 <lambdabot>   ".X.|...|.O."
20:52:34 <statusfailed> woah
20:52:36 <statusfailed> :D
20:52:47 <pdxleif> destroying information increases entropy, wasting energy and contributing to the head death of the universe.  don't do it, plz
20:52:51 <startling> statusfailed, you can have mutable arrays
20:52:57 <pdxleif> *heat death
20:53:03 <startling> but yeah, you don't really need mutability
20:53:03 <statusfailed> startling: that's with ST or IO right?
20:53:08 <startling> statusfailed: yeah
20:53:11 <statusfailed> yeah, it's only 19x19
20:53:21 <startling> davesque_: oh! I know exactly the thing
20:53:25 <statusfailed> also I forgot Map wouldn't do bounds checking
20:53:37 <davesque_> startling: what is it?
20:53:47 <startling> davesque_: take a look at http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
20:54:04 <davesque_> startling: hmm, okay
20:55:17 <davesque_> yes, it would need bounds checking.  and it would hopefully be easy to get and set a board position by coordinates.
20:56:43 <Clint> wouldn't you want something like a store comonad for go?
20:56:53 <davesque_> so i guess i'll look into Array and Map (you may have guessed i'm somewhat of a beginner)
20:57:26 <Ralith> davesque_: just use an array and don't worry about the rest for now.
20:57:59 <davesque_> cool, i'll get started with this feedback, thanks! :)
20:58:30 * Ralith chides #haskell for making simple questions complicated >_>
20:58:33 <typoclass> davesque_: how about just using good old lists? you can always switch later. when you have worked on your program for a while, you're in a better position to decide
20:58:47 <shachaf> :-(
20:58:47 <Ralith> here we go again
20:58:51 <davesque_> i tried that but it started feeling ugly fast
20:59:04 <davesque_> very inelegant
20:59:21 <startling> yeah, lists-of-lists are kind of annoying
20:59:40 <typoclass> shachaf, ralith: sorry, what did i say?
21:00:16 <startling> davesque_: btw, you want an Array (Int, Int) or whatever
21:00:36 <typoclass> davesque_: ok, that's a good useful bit of experience then :-) "lists feel inelegant here"
21:00:54 <Ralith> typoclass: It just seems like a shame that when newbies show up and ask simple questions, they often get pages of debate instead of the simple answer.
21:01:09 <startling> Ralith, you know, Go is trivially comonadic
21:01:16 <davesque_> typoclass: yeah, i've already started down that path a bit.  got the feeling that it wouldn't work out so well.
21:01:17 <Ralith> that is pretty neat!
21:01:40 <Ralith> comonads are one of those things I've been meaning to poke at sometime
21:01:41 <typoclass> Ralith: oh okay, so you weren't referring to my comment specifically :-) no worries
21:01:45 <startling> (that's not something you'd want to hear as a newcomer, though)
21:01:53 <Ralith> sounds like they might be quite useful for discrete game worlds
21:02:21 <Ralith> typoclass: well, I was referring to your comment insofar as that we'd supplied him an answer and you were (potentially) putting it into question again.
21:05:42 <Guest17147> Need help with HXT.
21:05:47 <ion> If i have two instances of the same string literal in Haskell source, does GHC make them point to the same memory area?
21:05:48 <davesque_> don't worry, i'm not turned off by long winded discussion
21:06:28 <Ralith> davesque_: just so long as you're not confused by the wealth of ambiguously-worthwhile alternatives and high-order abstractions.
21:06:40 <typoclass> Ralith: ok i see. well i my intent was to suggest the simplest possible thing (lists) because it hadn't come up yet, and as an alternative to the 'pages of debate' you criticized. anyway, i don't think there was a lot of harm done
21:06:43 <davesque_> not at all
21:06:45 <Ralith> er, that sounds kind of condescending
21:07:04 <Ralith> but it looks like all is well regardless so ^^
21:07:16 <Ralith> typoclass: indeed.
21:07:29 <Guest17147> Trying to parse a ods file (libreoffice). There are rows... And inside the rows, columns... When a try to get the columns content, is mix it up and apply something like a concat I did'nt want.
21:07:58 <Ralith> (though it's not my experience that representing multidimensional data structures with lists is often simple)
21:10:14 <ion> To answer myself, that seems to depends on -O.
21:16:45 <mm_freak> ion: doubt it, especially when you have OverloadedStrings on…  to make sure use sharing or a CAF
21:32:01 <YayMe> So moving to ubuntu after playing with haskell in windows, I did cabal install yesod-platform and yesod is not in my path, any ideas what I'm missing?
21:32:32 <stepkut> YayMe: is ~/.cabal/bin in your PATH?
21:32:42 <mzero> by default on linux systems, cabal install puts stuff in ~/.cabal/bin
21:32:44 <applicative> member:identifier:guest17147 in the bit of ods content.xml I see, it looks to me like 'columns' is just preliminary style nonsense, the business is a sequence of rows, each a sequence of cells. The cells of the first row are the column headings.
21:32:59 <mzero> you can change the config to have it symlink that stuff into your ~/bin or somewhere else on your PATH
21:33:02 <mzero> or you can put it on your PATH
21:34:32 <applicative> the path is specified in .bashrc in Ubuntu? or what
21:36:37 <YayMe> thanks, I just wasn't sure where it was putting stuff
21:39:59 <hpaste> WraithM pasted “Inserting an element and modifying the rest of the list” at http://hpaste.org/77770
21:40:55 <WraithM> This is a style question. I want to insert an item into a list where it was, modify it, and modify the rest of the list by something else.
21:41:12 <WraithM> Is there a better way to do that than this?
21:42:01 <applicative> what  if it appears many times in the list?
21:42:11 <shachaf> Don't use fromJust. :-(
21:42:44 <applicative> we can get to that
21:42:57 <WraithM> applicative: In this particular case, it doesn't. Though, I guess that's also part of my question. I'm new to Haskell, and I want a better way to do that.
21:43:03 <typoclass> WraithM: how about the 'break' function?
21:43:14 <typoclass> > break (=='c') "lolcats"
21:43:16 <lambdabot>   ("lol","cats")
21:43:41 <shachaf> That is a good function.
21:43:47 <WraithM> ooooh
21:43:50 <WraithM> Nice!
21:44:08 <WraithM> That's wonderful.
21:44:42 <applicative> WraithM: or why not  just a helper function doTrigger c x = if x == c then trigger c else x, then map (doTrigger c) xs will 'modify' each c to its trigger
21:44:45 <applicative> so to say
21:44:56 <WraithM> I guess, I'd do something like: (h, _:s) = break (== 'c') "lolcats" and then reconstruct my list like I did.
21:45:00 <typoclass> WraithM: you'd probably use it something like "(unmodifiedPart, (foundElement : restOfList)) = break (=='c') ..."
21:45:11 <typoclass> erm, yeah :-)
21:47:05 <startling> so I want to write a curses thing where the level of cooperation we need from the terminal is encoded into the types. is this a sane way to do it? https://gist.github.com/f0d3c404bf0903ed0c76
21:47:19 <mm_freak> > splitAt 7 . drop 27 . map head $ cake
21:47:21 <lambdabot>   ("TOOTOOT","ASCIICAT")
21:47:36 <WraithM> > cake
21:47:38 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
21:47:41 <ion> > transpose cake
21:47:43 <lambdabot>   ["OOTFOTOTDFFFFFPFCOAUFANTOATTOOTOOTASCIICAT","nnhonhnwoiiiiiuianlniniwnnww...
21:48:07 <startling> >(^. .^)<  --( Meow )
21:48:23 <WraithM> applicative, typoclass: Thank you for your help!
21:50:03 <pordan30> WraithM: you should ensure that every argument passed to triggerFault occurs in the input list; otherwise your function will fail with pattern match failures. otherwise, you'll need to deal with the possibility of failure.
21:50:58 <typoclass> startling: i dunno, i think i'd say "i'm assuming this sort of terminal with all its features" and be done with it. unless you're writing some sort of cursesish terminfoish library
21:51:30 <startling> typoclass, the latter
21:52:13 <startling> I guess I could just do ansi colors + styles and have a superclass for 256-colors
21:53:03 <typoclass> startling: ooh interesting :-) is there already any code to look at? i'm still thinking about this wacky idea of writing a shell
21:53:11 <WraithM> pordan30: In this particular case it does. I didn't paste the rest of my code, but c is always the maximum of the list.
21:53:24 <startling> typoclass, there's lots of code but I'm at that point where I'm thinking of scrapping it all
21:53:48 <startling> typoclass, https://github.com/startling/curslet
21:54:20 <startling> maybe I should just ignore colors completely and give a way to specify a "stylesheet"
21:54:34 <typoclass> startling: ah thanks for the link :-)
21:54:56 <typoclass> startling: why are you considering scrapping?
21:55:09 <Guest17147> Hey guys. Would you help me with this: http://stackoverflow.com/questions/13392210/haskell-hxt-to-parse-rows-and-columns-and-getting-string-and-not-string ?
21:55:32 <startling> Guest17147, haven't you been asking about that all day?
21:55:34 <pordan30> > let (hs, _ : rs) = break (== 1) [] in rs
21:55:36 <lambdabot>   *Exception: <interactive>:3:5-34: Irrefutable pattern failed for pattern (h...
21:55:50 <hpaste> WraithM pasted “Style critique :)” at http://hpaste.org/77772
21:55:51 <startling> typoclass, because it's kind of unwieldy and there's no clear way to implement colors
21:56:11 <typoclass> i see
21:56:33 <startling> yeah, I think I'm going to provide a pseudo-stylesheet at the beginning and then let each thing query it.
21:57:13 <YayMe> startling: What's so tricky about colors? There are other terminal packages on hackage, I used one in windows that works for both windows and *nix (was only one I think) but it had a pretty simple API, have you looked at how any of the other haskell terminal packages do it?
21:57:57 <YayMe> startling: Like a DSL?
21:58:45 <startling> YayMe, I've looked at (I think?) all of the others; I specifically want an abstraction over curses' terrible init_pair thing and a nicer haskellier api than the others. I also kind of want to do multiple backends so you could compile code using libtcod or whatever without changing it
22:00:07 <YayMe> startling: yeah, there was only one I recall seeing that wasn't just a layer over curses as I understood it; I think it would have had ability for multiple backends as you mention
22:00:21 <WraithM> pordan30: I was actually just about to say that another possibility is for the list to be empty :) however, again, in my particular case, it never will be. I guess I'm looking for ways for my code to be more tollerant to failure.
22:00:47 <YayMe> startling: and if want a haskellian api I don't know that a DSL like a stylesheet is the way to get there, though that's not to say a DSL isn't a good idea for something of that nature
22:01:59 <YayMe> ...haskellian...like reptiallian, but better at math.. :)
22:03:00 <startling> YayMe, I wasn't thinking of a dsl for a stylesheet; I was thinking you'd style things with an (s -> a) , where s is the stylesheet and a is the actual attribute that this type of display looks for.
22:03:34 <startling> YayMe, this way you would only need to change colors/etc in one place.
22:05:23 <pordan30> WraithM: better haskellers than myself may have better advice, but since triggerFault is a distinct partial operation that doesn't depend on the monadic code it's embedded in, i would define it separately and have it return in the maybe type, then take advantage of the fact that maybe is a monad to run the operation with the possibility of failure.
22:06:11 <YayMe> startling: I seem to recall speaking to you about this before and thinking it made sense to have a Pallette typeclass with the various instances you want, why does that not make sense? You can have an instance of a 256 color palette, an 8 color palette, and custom palettes for funky terminals of other types, then all they need to do is switch their particular Palette they're using and it's fine... (sounds basically like the stylesheet
22:06:11 <YayMe> idea you're talking about)
22:07:12 <WraithM> pordan30: That's good advice! Thank you :)
22:07:20 <startling> YayMe: that may have been me but I don't remember it. That's the approach I'm trying to use now, but it leads to huge type signatures and some other annoyances
22:08:15 <YayMe> The huge signature just because the palette needs to be fairied around?
22:08:42 <YayMe> Attoparsec has pretty big type signatures and manages not to be clunky to users
22:09:11 <YayMe> (unless I'm misunderstanding what you mean by large type signatures)
22:09:35 <hpaste> typoclass annotated “Style critique :)” with “firstCell is the same as c, isn't it?” at http://hpaste.org/77772#a77773
22:11:02 <typoclass> ... wait, i'm doing it wrong ...
22:11:41 <WraithM> typoclass: Yes, that's true.
22:12:26 <WraithM> but I guess I'm going to write fancier functions later where I use this sorta thing.
22:13:05 <WraithM> Yeah, I wrote triggerFault in a where, I didn't mean to do that
22:14:11 <mm_freak> @tell DMcGill yes, events are represented as producing/inhibiting wires…  look into the Control.Wire module for a tutorial that explains it
22:14:11 <lambdabot> Consider it noted.
22:15:36 <mm_freak> @tell navaati i haven't announced netwire 4 yet, because i want to write a wrapper around vty first so that you can put it into use immediately…  i'm writing it right now…  however, you don't need to wait, there is a tutorial in the Control.Wire module
22:15:36 <lambdabot> Consider it noted.
22:21:32 <typoclass> WraithM: i annotated http://hpaste.org/77772 . it's just stylistic, but i don't like huge indentation
22:22:19 <WraithM> typoclass: Yes, that's much prettier
22:22:21 <WraithM> :)
22:22:23 <WraithM> Thank you
22:22:46 <typoclass> WraithM: you're welcome
22:31:17 <OceanSpray> @hoogle iterateUntil
22:31:18 <lambdabot> No results found
22:31:31 <OceanSpray> @hoogle (a -> a) -> (a -> Bool) -> a
22:31:32 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
22:31:32 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
22:31:32 <lambdabot> Data.Generics.Aliases extT :: (Typeable a, Typeable b) => (a -> a) -> (b -> b) -> a -> a
22:31:36 <OceanSpray> ah
22:31:50 <typoclass> WraithM: untested, but something like this would work as well http://hpaste.org/77772#a77775 i'm kinda almost as good as sure :-)
22:31:52 <OceanSpray> > until (== 3) succ
22:31:55 <lambdabot>   *Exception: show: No overloading for function
22:31:59 <OceanSpray> > until (== 3) succ 0
22:32:02 <lambdabot>   3
22:32:07 <OceanSpray> yes
22:33:45 * hackagebot alpha 0.995 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.995 (MarcCoiffier)
22:37:12 <WraithM> typoclass: Ah! This is much better. That handles the possibility for failure in a much nicer way.
22:37:23 <WraithM> ... at all, rather
22:37:30 <typoclass> WraithM: ;-)
22:37:32 <WraithM> handles the possibility for failure, at all
22:41:50 <typoclass> WraithM: i thought triggerFault would get easier to read if you separate what it conceptually does from the list plumbing. also, change1 is more general and could plausibly be reused in other programs
22:45:19 <WraithM> Very true. Yeah, I'm trying to figure out ways to reason about when to separate functions.
22:45:28 <hpaste> WraithM pasted “Reasoning about turning this into Haskell” at http://hpaste.org/77776
22:45:34 <WraithM> So, here's another problem
22:46:04 <WraithM> I'm trying to rewrite some programs in Haskell to get better
22:46:15 <WraithM> this one is in C
22:49:34 <startling> is there something like printf that'll get me a string?
22:49:44 <typoclass> startling: sprintf?
22:49:46 <startling> I want to format a Word8 to two hex digits.
22:50:04 <startling> typoclass, is there a sprintf in haskell?
22:50:21 <johnw> startling: Text.Printf
22:50:23 <typoclass> startling: i think there's a showHex function somewhere. not sure about sprintf in haskell :-/ printf is of course there
22:50:42 <startling> johnw, can I make it give me a string somehow?
22:50:56 <sopvop> @hoogle showHex
22:50:57 <lambdabot> Numeric showHex :: Integral a => a -> ShowS
22:51:21 <johnw> startling: see http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Printf.html#v:printf
22:51:34 <johnw> printf returns a String, or IO a, depending on how it's used
22:51:44 <WraithM> So, I guess my question is how do I keep track of certain variables while changing the state of some other parts. I'm probably just not even thinking about the problem correctly.
22:52:09 <startling> johnw: oh weird, thanks
22:52:45 <sopvop> WraithM: for state use State monad
22:53:07 <mm_freak> > printf "%d" (8 :: Integer) :: String
22:53:08 <sopvop> For "while" use forever with Maybe or Either
22:53:09 <lambdabot>   "8"
22:54:03 <startling> > printf "%02x" 255 :: String
22:54:05 <lambdabot>   "ff"
22:54:31 <typoclass> WraithM: does trigger() change the rest of the fault array?
22:54:54 <mm_freak> WraithM: this looks like code that you would write purely in haskell
22:55:08 <mm_freak> i.e. don't translate it literally, but rethink about the problem at hand
22:55:39 <sopvop> like purely get list of things to trigger, then mapM over it with trigger
22:56:04 <WraithM> mm_freak: Yep! that's what I'm trying to do :) I guess that's my question. How do I think about this in the right way?
22:56:40 <sopvop> WraithM: Think in terms of data transformation :)
22:56:54 <WraithM> typoclass: Yes, yes, it does. Sorry, I didn't write this code. It used ugly globals everywhere... I tried to make it explicit, but I missed that.
22:57:13 <WraithM> Change that to trigger(fault, j)
22:57:28 <typoclass> WraithM: right :)
22:57:29 <mm_freak> WraithM: could you summarize what the code does?
22:57:42 <mm_freak> try without programming terms =)
22:57:59 <WraithM> Okay, so this is a really basic physics simulation
22:58:15 <WraithM> This part is calculating the size of an "avalanche"
22:59:06 <WraithM> Basically, I want to find all the cells that "slipped" (ie. fault[j].stress >= finalStress)
22:59:20 <WraithM> and add their contribution to the avalanche
23:00:23 <mm_freak> dStress is that avalanche?
23:00:46 <WraithM> No, total_dStress is
23:00:49 <WraithM> Yeah
23:00:53 <WraithM> Let me start over
23:00:55 <mm_freak> ah, yeah
23:01:28 <mm_freak> i don't know much about physics, but what do trigger() and update() do?
23:02:32 <WraithM> trigger decreases the stress on that particular cell. update gives the stress from that cell to all the other cells.
23:03:23 <WraithM> I have an equilibrium condition (dStress == 0), that means that the avalanche is over.
23:03:31 <mm_freak> and you run that over and over and show the intermediary states to the user?
23:03:47 <mm_freak> until the equilibrium is reached?
23:03:49 <WraithM> I don't really care about the intermediary states.
23:03:56 <WraithM> I really only care about total_dStress
23:04:11 <typoclass> WraithM: ah, so trigger() changes the cell at j, or all the cells from j to the end of the array?
23:04:12 <WraithM> but I do need dStress to calculate total_dStress
23:04:24 <WraithM> trigger only changes the jth cell.
23:04:48 <WraithM> but update changes every cell, except for the jth cell!
23:05:02 <mm_freak> hmm…  seems like this could be implemented as a simple vector
23:05:06 <typoclass> i see
23:06:00 <mm_freak> i have a similar application, a neural network
23:06:40 <mm_freak> at some point it enters a rest phase
23:07:32 <WraithM> Yes, absolutely. Actually, this model can be mapped onto a network to simulate the brain. Another person in my research group published a really neat article recently about avalanches in the brain.
23:07:44 <WraithM> but that's the exact idea
23:07:48 <WraithM> it comes to rest eventually
23:07:56 <WraithM> but I want to count up some properties while I'm going along
23:08:07 <WraithM> before that point
23:09:28 <mm_freak> well, you may gain some inspiration from my neural network code
23:10:04 <WraithM> Would you be willing to share? :)
23:10:18 <mm_freak> http://hackage.haskell.org/packages/archive/instinct/0.1.0/doc/html/src/AI-Instinct-Brain.html#activation
23:10:32 <mm_freak> that's the code for calculating the rest phase activations
23:10:51 <mm_freak> http://hackage.haskell.org/packages/archive/instinct/0.1.0/doc/html/src/AI-Instinct-Train-Delta.html#learnPat
23:11:02 <mm_freak> that's the code for the backprop learning algorithm that uses the same idea
23:11:26 <mm_freak> the basic idea is to use a boxed vector and exploit haskell's laziness
23:11:34 <typoclass> WraithM: how about "dStress = sum (... filter (>= finalStress) allTheStresses)"
23:12:21 <typoclass> (i imagine something like that would be the result of translating lines 9 to 11)
23:13:25 <WraithM> oooo
23:13:32 <WraithM> that makes a lot of sense
23:13:51 <WraithM> what about going until I hit equilibrium?
23:14:35 <WraithM> Well
23:14:37 <WraithM> I guess simply
23:14:41 <WraithM> if dStress == 0
23:14:51 <WraithM> then return total_dStress
23:15:07 <WraithM> else recursion
23:15:19 <typoclass> WraithM: yup, that's a good haskellish way to do it :-)
23:15:55 <mm_freak> repeating a process over and over until some condition is met can often be encoded as a simple lazy value
23:16:07 <mm_freak> only encoding relationships, not the process of updating
23:16:17 <mm_freak> laziness does the rest
23:16:27 <WraithM> Gotta love laziness :)
23:17:18 <typoclass> WraithM: an alternative might be a list of dStresses, and then doing "takeWhile (> 0)" or similar. this might have the advantage because calculating totalDStress could then be "sum $ takeWhile (> 0) allTheDStresses"
23:17:42 <typoclass> (it would of course only evaluate the list of dStresses until you hit the first 0)
23:18:20 <typoclass> ... erm, of course it'd be "/=" instead of ">" :-)
23:18:42 <WraithM> Yes, I was just about to ask about that. That makes a lot of sense.
23:19:14 <WraithM> takeWhile (/= 0) [dStress1, dStress2...]
23:19:18 <WraithM> and then sum
23:19:25 <typoclass> exactly
23:19:37 <WraithM> Ah, that's perfect
23:21:21 <WraithM> You are all gentlemen/gentlewomen and scholars.
23:21:32 <opqdonut> gentlepersons!
23:22:04 <WraithM> Indeed
23:22:36 * typoclass finds that offensive because the faction of cats in #haskell is being excluded
23:23:26 <WraithM> gentlecats are of course welcome
23:24:07 <WraithM> The internet delivered really well on the search for "gentlecats": http://images.fineartamerica.com/images-medium/mr-darcy-regency-gentlecat-tara-fly.jpg
23:26:04 <WraithM> @type cmMap
23:26:06 <lambdabot> Not in scope: `cmMap'
23:29:15 <WraithM> Yeah, this code that I'm trying to convert over to Haskell is a disaster... Physicists have no idea how to write code. I've been working with this code for a while and it drives me nuts, and I decided I'd write it nicely in Haskell.
23:30:38 <WraithM> One giant main(), globals everywhere, shittily named everything... You have no idea the horrors I've seen.
23:51:57 <lleksah> hello
23:55:11 <mapf> hi
