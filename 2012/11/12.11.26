00:37:27 * hackagebot editline 0.2.1.1 - Bindings to the editline library (libedit).  http://hackage.haskell.org/package/editline-0.2.1.1 (JudahJacobson)
00:41:39 <Crockeo> Might I ask a(nother) quick question before I doze off?
00:41:43 <Crockeo> Rather, two questions.
00:42:10 <Crockeo> 1) Is it possible to get the non-IO result of an IO function (like by using <-) in one line
00:42:17 <Crockeo> 2) If so, how might one implement that?
00:42:27 * hackagebot markdown 0.1.1.2 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.1.2 (MichaelSnoyman)
00:43:20 <killy9999> Crockeo: unsafePerformIO ?
00:44:13 <killy9999> @t unsafePerformIO
00:44:13 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
00:44:20 <killy9999> @type unsafePerformIO
00:44:21 <lambdabot> Not in scope: `unsafePerformIO'
00:44:27 <killy9999> :/
00:44:48 <Crockeo> killy9999: Given the conversation about unsafePerformIO in this IRC I'd imagine that's not an especially Haskell-ey way to do things.
00:45:20 <Crockeo> Thank you anyways; I'm too tired to stay long enough to do anything else.
00:45:34 <Crockeo> I may just ask lispy tomorrow.
00:45:41 <Saizan> :t (=<<)
00:45:43 <lambdabot> Monad m => (a -> m b) -> m a -> m b
00:45:53 <Saizan> :t (>>=)
00:45:54 <lambdabot> Monad m => m a -> (a -> m b) -> m b
00:46:20 <killy9999> Crockeo: using unsafePerformIO may be unwise
00:46:32 <Crockeo> killy9999: That's what I was thinking.
00:46:40 <killy9999> but sometimes this may be correct
00:46:47 <killy9999> and only way to do some thigs
00:47:14 <killy9999> also - if I understood your question correctly - what you want to do is also not "especially Haskell-ey
00:47:19 <killy9999> :)
00:47:49 <Crockeo> (Shh, don't tell anyone!)
00:49:38 <Crockeo> Well, time to sleep.
00:49:45 <Crockeo> AFK: Resting my eyes.
01:13:48 <hpaste> edwardk pasted “iso insanity” at http://hpaste.org/78276
01:14:37 <Ghoul_> edwardk: lol'd
01:14:51 <Ghoul_> not even going to try and understand what that's all on about
01:14:56 <edwardk> Ghoul_: sadly that works. the saner alternatives don't ;)
01:15:22 <Ghoul_> MonadReader makes an appearance!
01:16:08 <edwardk> yeah in lens HEAD, we've overloaded view/views, so we can drop peruse/peruses.
01:16:37 <edwardk> so when you're in a monadreader, you can just foo = do x <- view somelens; ..
01:16:44 <edwardk> i wish i'd thought of it a long time ago
01:17:59 <Ghoul_> lol
01:19:32 <Ghoul_> Isos xs sx yt ty . Isos sa as tb bt =
01:19:35 <Ghoul_> What type of syntax is that
01:19:36 <Ghoul_> ._.
01:19:57 <edwardk> thats just defining a function named .
01:19:59 <Botje> it redefines the . operator for two values that have an Isos constructor
01:20:13 <Ghoul_> oh okay
01:20:26 <edwardk> Ghoul_: i don't recommend taking style tips from this
01:20:28 <edwardk> ;)
01:20:28 <Ghoul_> Oh yes, infix definition
01:20:38 <Ghoul_> What you talking about, it's beautiful ;))
01:20:52 <zhulikas> :D
01:20:54 <Ghoul_> stab, lol
01:20:56 <zhulikas> quite cryptic
01:21:02 <Ghoul_> read the arguments from left to right
01:21:11 * zhulikas wonders how edwardk's brain works 
01:21:38 <zhulikas> haha, stab
01:21:42 <zhulikas> subliminal messages to developers
01:21:45 <liyang> Unresolved trauma? D:
01:21:54 <edwardk> hahaha
01:22:10 <shachaf> zhulikas: "stab" is my fault, unfortunately.
01:22:25 * shachaf thinks the renaming turned out well.
01:22:29 <edwardk> i had a rough childhood. sorry for taking it out on the haskell community ;)
01:22:36 <zhulikas> :D
01:22:58 <zhulikas> source code is cry for help
01:22:58 <Saizan> oh, i guess the unsafeCoerce's are just because of that regression wrt f a ~ f b  --> a ~ b
01:23:09 <edwardk> Saizan: yeah =(
01:23:16 <edwardk> the ones for the Category are less excusable
01:23:43 <Saizan> i was talking about those
01:23:50 <edwardk> but they make sense if you look at it from the standpoint that you can't do anything with it if you have a Isos Double Double
01:24:11 <edwardk> Saizan: i thought you meant the ones in from, via, ala, auf, under, etc.
01:24:24 <edwardk> the ones in those are from the fact that you can't get under the f
01:24:53 <edwardk> oh yeah there are two sets in Category
01:25:09 <edwardk> the ones on tb bt, ty, bt are the excusable ones
01:25:19 <edwardk> thats me working around ghc being unduly paranoid
01:25:51 <edwardk> the ones around the whole "Isos" is pretty evil
01:25:57 <Saizan> i see
01:26:09 <Saizan> well, i don't see why they are needed yet :)
01:26:16 <edwardk> try removing them ;)
01:26:27 <edwardk> you can remove the whole Category instance if you must
01:26:33 <edwardk> I _really_ want a fix for this
01:26:57 <Saizan> oh, right, (a -> f a) doesn't unify with x
01:27:09 <edwardk> yeah
01:27:14 <edwardk> that is the evil one on the outside
01:27:43 <edwardk> which is fine, because if i give you a Isos Double Double -- what can you do with it? pattern match? no pattern will match
01:28:21 <edwardk> at least so it seems to me in my 4:30AM reasoning
01:29:27 <edwardk> none of the sites that use an Isos take it with any shape other than the (a -> f b) style args
01:30:57 <Saizan> yeah
01:33:19 <Saizan> you'd need some sort of subkinding :)
01:33:20 <edwardk> i had the idea to make some kind of 'coalgbroid class that just let a -> f b   determine a, f, and b.
01:33:43 <edwardk> that at least would let me get rid of the unsafeCoerce's around bt and tb conversions
01:34:47 <edwardk> then i could do something like that 'Coat' trick we worked with on indexed.
01:34:56 <Saizan> i think newer versions of ghc are supposed to not be so paranoid btw
01:35:12 <edwardk> e.g. take the obligation to show that x and y are a Coalgebroid, and then you can get the functions
01:35:37 <Saizan> oh, you could also replace the unsafeCoerce with an explicit proof
01:36:45 <edwardk> data IsoFamily x y where IsoFamily :: (forall f s t a b. (Coalgebroid x a f b, Coalgebroid y s f t) => (s -> a, a -> s, t -> b, b -> t)) -> IsoFamily x y
01:36:54 <edwardk> is the solution i keep trying to come up with
01:37:46 <edwardk> with something like class Coalgebroid x a f b | x -> a f b, a f b -> x; instance (x ~ (a -> f b)) => Coalgebroid x a f b
01:38:03 <edwardk> that gives the ability to 'destructure' the a -> f b  into components a f and b.
01:38:10 <bartavelle> I can't install hoogle with a recent bytestring. Is there a way to pinpoint which package in hoogle's dependencies is causing my problem ?
01:38:35 <edwardk> and in theory i should be able to use x ~ y  , and Coalgebroid x … Coalgebroid y   to get the field arguments to match
01:39:02 <Saizan> remember that fundeps don't play nice with ~
01:39:19 <edwardk> yeah, it may be that those wind up type families
01:42:24 <edwardk> maybe just
01:42:25 <edwardk> type family A x :: *
01:42:26 <edwardk> type instance A (a -> fb) = a
01:47:30 * hackagebot optparse-applicative 0.4.2 - Utilities and combinators for parsing command line options  http://hackage.haskell.org/package/optparse-applicative-0.4.2 (PaoloCapriotti)
01:48:39 <edwardk> hrmm, the type family thing may be working!
01:49:31 <mutha> can someone suggest how to write this more elegantly? http://hpaste.org/78277
01:50:34 <t7> take n . sequence   ?
01:50:46 <t7> or something
01:51:03 <t7> is  g -> (a, g)  a monad?
01:51:12 <atriq> That's the State Monad
01:51:17 <shachaf> (\a -> g -> (a, g)) is.
01:51:55 <mreh> anyone using UHC on ubuntu that knows how to include other packages in your build
01:52:09 <mreh> cabal doesn't apear to be able to build executables
01:52:15 <mreh> yet
01:52:16 <mutha> t7 was that for me?
01:52:30 <Botje> mutha: why not use the randomRs function?
01:53:20 <mreh> there's a package called MonadRandom
01:54:07 <mreh> or just use randomRs if it's simple
01:54:23 <mutha> Botje: doing it like this seems cleaner if I want to take N random integers and then later some more
01:54:38 <mreh> randomRs gives you an infinite list
01:54:48 <mutha> yes
01:55:04 <Botje> mutha: so split off a new generator, take n . randomRs (x,y) with the new one, return the other one.
01:55:40 <mreh> and use monad random to make it nice and clean!
01:55:44 <mutha> randonRs doesnt return a generator
01:56:07 <mutha> and reseeding it every time doesnt seem wise
01:56:32 <shachaf> randomRs gives you an infinite list, doesn't it?
01:56:35 <mreh> getRandomRs :: Random a => (a, a) -> m [a]
01:56:42 <shachaf> Presumably you don't need a generator.
01:56:47 <mutha> shachaf: yes
01:56:51 <edwardk> Saizan: i can get the id case to go cleanly but it comes at the cost of making the (.) case impossible. iirc from indexed the (.) is really impossible because i need to be able  to know that if x ~ (a -> f b)   is a coalgebroid then IsoFamily will take a coalgebroid to another coalgebroid. s -> f t or back, otherwise i don't have the coalgebroid to discharge the obligation on the middle of IsoFamily (xs,sx,yt,ty) . IsoFamily (sa,as,tb
01:57:26 <edwardk> @hpaste
01:57:26 <lambdabot> Haskell pastebin: http://hpaste.org/
01:57:50 <hpaste> edwardk pasted “for saizan” at http://hpaste.org/78279
01:59:36 <sirStean> i have to decode my bitlist: http://hpaste.org/78278 , but i dont know how to count power, e.g 1*2^2,1*2^3
01:59:48 <sirStean> i have to use fold
01:59:50 <mutha> problem with randomRs is that if you want some other random value later, you have to create a new generator seed instead od continuing where is stopped
02:01:01 <shachaf> sirStean: Try it without fold.
02:02:06 <sirStean> recursion is forbidden, i need to use high order functions
02:03:27 <mutha> still curious if someone can rewrite my code to be more elegant. having both nextGen and nextGen' looks kind of ugly. http://hpaste.org/78277
02:03:45 <shachaf> sirStean: Recursion isn't forbidden for thinking about a problem.
02:04:07 <shachaf> mutha: You could use State or something like State but it hardly seems worth it.
02:04:31 <mreh> I'm not quite sure how to get a UHC program to compile when I've imported Text.Printf for example, it says it's searched the package database, and I can see its installed a base package in the same place where the prelude it uses is installed
02:05:23 <sirStean> normally i would make it with a counter n that i encrease every recursion and sub it with the length of my list
02:09:07 <mutha> btw when using randomRs, I guess you have to take N and then drop N elements from infinite list every time you want to fetch new random values?
02:09:33 <sirStean> i dont know what i could write for calculating the power of 2 in http://hpaste.org/78278
02:10:16 <shachaf> sirStean: Try writing it without using fold.
02:12:32 * hackagebot doctest 0.9.2.1 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.2.1 (SimonHengel)
02:16:02 <hpaste> “sir stean” pasted “same problem” at http://hpaste.org/78280
02:21:11 <sirStean> hm i think its impossible
02:22:08 <mutha> how can randomIO work without mutating global state?
02:22:51 <atriq> > foldl (\acc c -> 2 * acc + if c then 1 else 0) 0 [True, False, False, True]
02:22:53 <lambdabot>   9
02:22:59 <atriq> > foldl (\acc c -> 2 * acc + if c then 1 else 0) 0 [True, False, True, True]
02:23:01 <lambdabot>   11
02:23:04 <atriq> :)
02:23:37 <shachaf> bgamari: Did you work out your issue?
02:24:39 <opqdonut> mutha: it doesn't
02:25:07 <mutha> opqdonut: what does it do?
02:25:41 <opqdonut> see http://hackage.haskell.org/packages/archive/random/latest/doc/html/src/System-Random.html
02:25:59 <opqdonut> it uses getStdRandom
02:26:40 <opqdonut> or rather, read from here onwards: http://hackage.haskell.org/packages/archive/random/latest/doc/html/src/System-Random.html#stdSplit
02:26:45 <mutha> i checked its source, and getStdRandom. didnt really help me undertand what is going on in the big picture
02:26:45 <opqdonut> "The global random number generator"
02:28:53 <mutha> "held in some variable maintained by the IO monad" sure sounds like its mutating it
02:30:06 <mutha> you can mute variables in IO action?
02:30:10 <mutha> mutate
02:30:19 <merijn> mutha: Sure
02:30:29 <merijn> mutha: Well, not variables per se.
02:30:43 <merijn> mutha: But there are things which contain values that you can mutate in IO
02:30:55 <merijn> For example, MVars, Chans and IORefs
02:31:11 <mutha> ok interesting
02:32:13 <merijn> mutha: But the presence IO explicitly encodes when this can possibly happen. There's also STM which lets you use transaction while mutating state
02:36:29 <sirStean> decode (x:xs) = (if x ==O then 0 else 1) + foldr (\a acc -> (acc + if a ==I then 1 else 0) * 2) 0 xs
02:36:41 <sirStean> it works :) , but its not very nice
02:37:33 * hackagebot type-equality 0.1.1 - Type equality, coercion/cast and other operations.  http://hackage.haskell.org/package/type-equality-0.1.1 (ErikHesselink)
02:37:42 <latermuse> Whats the best way to get data between two delimitters? For instance: getBetween "a" "<a>Hello hello</a><b>Bye Bye</b>"  ===  "Hello hello"
02:37:49 <merijn> sirStean: Could probably benefit from a where clause with some good names
02:37:53 <sirStean> can anyone help me making it more beautiful?
02:38:13 <merijn> latermuse: Is the data actually HTML?
02:38:23 <sirStean> jep i could of course
02:38:30 <latermuse> merijn: some of it could be html, but not necessarily all of it is html
02:38:42 <mutha> sirStean: what are I and O?
02:39:24 <ramses_> mutha: I'm guessing the ones and zeros of his bit string
02:39:29 <liyang> I'm guessing 1 and 0 in base-2.
02:39:56 <sirStean> I = 1 and O = 0
02:40:08 <sirStean> data Bit = O | I deriving (Eq, Sh
02:40:15 <merijn> latermuse: That makes the problem harder. html-conduit and xml-conduit are nice for grabbing stuff out of HTML, if you have other data then it becomes icky, unless you know what it is...
02:40:18 <ramses_> sirStean: define some helper functions (possibly in a where clause) to clean it up
02:40:56 <sirStean> ok, but before i ll try to make it shorter
02:41:02 <latermuse> merijn: all of it is in the format <a></a> or <adf></adf>
02:41:13 <latermuse> merijn: and I know what the format is ahead of time
02:42:07 <merijn> latermuse: A parser is the next option. The problem is that it's hard to grab parts of HTML without parsing it, as there's all sorts of ways the "simple" approaches will break
02:42:20 <liyang> > foldl' (\ a b -> a * 2 + if b then 1 else 0) 0 [True, False, True, False, True, False]
02:42:21 <lambdabot>   42
02:42:45 <latermuse> merijn: its more of a flat-txt database with some html-like tags. I guess its similar to xml
02:43:16 <merijn> latermuse: In that case rolling a (very simple) parser with parsec will probably be quite easy
02:43:39 <merijn> latermuse: Assuming you have no weird business like escaped tags inside arguments of tags, etc.
02:43:44 <latermuse> merijn: actually (reading xml wiki now) I think it is xml.
02:44:35 <merijn> latermuse: If it's xml take a look at xml-conduit and its Text.XML.Cursor which let you write things like "give me a list of the contents of each <a> tag"
02:45:05 <latermuse> merijn: great :)
02:45:17 <latermuse> merijn: ill also check out parsec and see which is the easiest route
02:50:47 <latermuse> merijn: when I use (ppContent "<a>Meow</a><b>Bark</b>"), it isnt giving any output. How can I get my string into the correct XML type?
03:03:39 <sirStean> can anyone explain me, what unfoldr does?
03:04:03 <shachaf> It builds up a list using a function.
03:04:19 <shachaf> In roughly the opposite way to how foldr unbuilds a list.
03:05:07 <bartavelle> I must have misunderstood something about hoogle. Do I really need to combine all databases into one file for it to work properly ?
03:05:53 <bartavelle> it fails with "too many open files". I splitted the job into 12 merges, then I merge the 12 resulting databases. It has been running for a while now, consuming 6GB, and using the CPU
03:09:21 <bartavelle> correction, now at 8.6g
03:12:31 <bartavelle> the documentation seems to be entirely outdated too
03:16:41 <xunatai> @src unfoldr
03:16:41 <lambdabot> unfoldr f b  = case f b of
03:16:41 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:16:41 <lambdabot>    Nothing        -> []
03:32:21 <sirStean> i have to write an encode for my Bitlist using unfoldr. Can ya help me ? http://hpaste.org/78287
03:36:18 <sirStean> i do not really understand the unfoldr function :/
03:36:52 <sirStean> can anyone give me an example
03:36:54 <sirStean> ?
03:37:17 <sopvop> > :t unfoldr
03:37:18 <lambdabot>   <hint>:1:1: parse error on input `:'
03:37:25 <sopvop> @ty unfoldr
03:37:26 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:37:36 <shachaf> sirStean: Start by writing it without unfoldr.
03:38:22 <sirStean> ok i ll try sir
03:38:32 <vraid> > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
03:38:33 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
03:39:11 <ion> > unfoldr (\n -> (n, n-1) <$ guard (n /= 0)) 10
03:39:12 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
03:39:56 <ion> > unfoldr (\n -> ("foo" ++ show n, n-1) <$ guard (n /= 0)) 10
03:39:58 <lambdabot>   ["foo10","foo9","foo8","foo7","foo6","foo5","foo4","foo3","foo2","foo1"]
03:41:52 <ijp> unfoldr (\b-> if null b then Nothing else Just (b,tail b)) [1..4]
03:42:50 <ion> > reverse . unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) $ 31337000
03:42:52 <lambdabot>   [3,1,3,3,7,0,0,0]
03:43:00 <sirStean> what does this do= : <$ guard (n /= 0)
03:43:30 <ion> In this case, “a <$ guard b” is the same as “if b then Just a else Nothing”.
03:44:36 <vraid> is <$ a special operator?
03:45:03 <ion> a <$ b = const a <$> b
03:45:14 <kennyd> :t (<$)
03:45:15 <lambdabot> Functor f => a -> f b -> f a
03:45:16 <ion> > guard True :: Maybe ()
03:45:17 <lambdabot>   Just ()
03:45:21 <ion> > guard False :: Maybe ()
03:45:23 <lambdabot>   Nothing
03:45:35 <ion> > "foo" <$ Just 42
03:45:36 <lambdabot>   Just "foo"
03:45:38 <typoclass> :t (<*)
03:45:39 <lambdabot> Applicative f => f a -> f b -> f a
03:47:08 <mutha> vraid: it's a function
03:48:21 <vraid> i got that, though now i wonder what <$> does
03:48:25 <vraid> :t (<$>)
03:48:26 <atriq> Is there a better way of saying "\n f a -> iterate f a !! n"?
03:48:26 <lambdabot> Functor f => (a -> b) -> f a -> f b
03:48:31 <ion> (<$>) = fmap
03:52:09 <vraid> oh, i'll have to learn functors and monads for this
03:54:39 <latermuse> vraid: you basically need to learn monads to do much of anything in haskell
03:57:49 <typoclass> vraid: luckily, there's not much to learn. the definition of the Monad typeclass is only a few a functions. its instances have a variety of uses, but you'll pick that up automatically as you read and write more haskell code
03:57:55 <typoclass> @where typeclassopedia
03:57:56 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
03:57:59 <mm_freak> you don't need to understand "monads" to use specific monads
03:58:09 <mm_freak> understanding how do-notation works is mostly sufficient to use IO
03:58:19 <typoclass> vraid, latermuse: ^^ here is the background information, if you're interested
03:58:26 <typoclass> mm_freak++
03:59:38 <mm_freak> vraid: if you understand how and why Functor, you're halfway to understanding how and why Monad =)
04:00:03 <mm_freak> Category is also an interesting class for that purpose
04:00:12 <mm_freak> those are very simple classes
04:11:03 <hpaste> edwardk pasted “progress on projections” at http://hpaste.org/78288
04:25:49 <ion> The lack of unsafeCoerce is disturbing.
04:27:39 * hackagebot blaze-markup 0.5.1.2 - A blazingly fast markup combinator library for Haskell  http://hackage.haskell.org/package/blaze-markup-0.5.1.2 (JasperVanDerJeugt)
04:27:41 * hackagebot yackage 0.6.0.2 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.6.0.2 (MichaelSnoyman)
04:34:11 <t7> what are typeclasses with the most type variables ?
04:35:04 <Athas> I have a Haskell program that segfaults.  I expect that this is due to poor use of foreign functions.  How should I proceed in debugging?
04:35:16 <Athas> The stack trace from the core file does not contain any information.
04:36:11 <Peaker> Athas, is it easily reproducible?
04:36:36 <typoclass> t7: cale has sometimes complained about the stuff in the pipes package
04:36:49 <Athas> Peaker: not really predictable, but it happens pretty often.  I can recompile the program with different and wait for it to happen again, no doubt.
04:37:01 <edwardk> t7: i had 18 for something before
04:37:18 <shachaf> Athas: gdb?
04:37:32 <shachaf> Is it your own use of the FFI or someone else's?
04:37:34 <Peaker> Athas, I think you can build with full profiling support (and -auto-all) and run with +RTS -xc for stack traces, that might help (I'm not sure though if you get a stack trace with a segfault)
04:37:35 <Athas> shachaf: the stack trace is useless.
04:37:39 <Athas> shachaf: both.
04:37:39 * hackagebot blaze-html 0.5.1.1 - A blazingly fast HTML combinator library for Haskell  http://hackage.haskell.org/package/blaze-html-0.5.1.1 (JasperVanDerJeugt)
04:37:41 <neutrino> how does one obtain the max int? i remember an example in lyah but can't find it anymore
04:37:46 * shachaf writes some Zipper documentation.
04:37:51 <shachaf> (Just a bit.)
04:37:52 <edwardk> maxBound :: Int
04:37:55 <edwardk> > maxBound :: Int
04:37:56 <lambdabot>   9223372036854775807
04:37:57 <edwardk> shachaf: woot!
04:37:59 <neutrino> ah yes
04:38:03 <Athas> The stack trace, as reported by GDB, is just two frames of '???' with very low addresses.
04:38:08 <neutrino> maxBound comes from a class, doesn't it?
04:38:15 <edwardk> :info Bounded
04:38:16 <ppseafield> neutrino: Bounded
04:38:17 <Athas> it looks more like a trampoline to a different stack, but I have little knowledge of how the RTS works at that level.
04:38:19 <neutrino> right
04:38:22 <neutrino> thanks ed
04:38:25 <Peaker> Athas, +RTS -xc should give you a Haskell stack trace.. Also maybe with -O0 the debug info may become more readable
04:38:32 <Peaker> (or at least the stack traces)
04:38:35 <Athas> Peaker: thank you, I will try.
04:39:04 <shachaf> Peaker: A Haskell stack trace for a segfault?
04:39:19 <shachaf> Athas: OK, you want the stack just before it gets messed up or something. :-)
04:39:50 <shachaf> Athas: What's IP at the point that it segfaults?
04:39:50 <Athas> My guess is that some FFI wrapper doesn't check for NULL before dereferencing.
04:39:56 <Athas> A lot of Haskell wrappers are lazy that way.
04:40:08 <Athas> shachaf: yeah, I'm trying to figure it out.  My GDB chops are rusty. :-)
04:40:30 <Peaker> shachaf, I haven't tried it myself, but I was hoping maybe ghc puts a sigsegv handler?
04:40:51 <Peaker> Athas, p $rip
04:41:00 <Peaker> Athas, or p $eip  (for 64/32 bits)
04:41:05 <shachaf> > 64/32
04:41:07 <lambdabot>   2.0
04:41:22 <Athas> Peaker: 0xe565c8.  How do I check what instruction that is?
04:41:30 <neutrino> symbols
04:41:54 <shachaf> Athas: disas?
04:42:09 <shachaf> If disas doesn't tell you anything, you can try x/10i $rip
04:42:51 <shachaf> edwardk: I wonder whether it's worth it to distinguish between lenses and traversals when descending.
04:43:08 <BenediktStean> pad wert list1 list2 = (take finalLen (list1 ++ (repeat wert)), take finalLen  (list2 ++ (repeat wert) ))
04:43:16 <BenediktStean> where finalLen = max (length list1) (length list2)
04:43:28 <BenediktStean> what it wrong with this
04:43:38 <Athas> shachaf: Hm.  "Cannot access memory at address 0xe565c8".  Does that mean the program jumped to invalid code?
04:43:44 <Peaker> Athas, disass $eip    but that's not going to be fun :)  you can use "info registers"
04:43:45 <Athas> This is a core file, mind you.
04:43:47 <shachaf> Something like data p :> a = MultiZipper (Coil p a) Int [a] a [a] | SingleZipper (Coil p a) a, or something vaguely like that.
04:43:53 <shachaf> Athas: Can you run the program in gdb?
04:43:57 <Peaker> Athas, most likely it did
04:44:13 <BenediktStean> it makes an infinite list
04:44:26 <Peaker> Athas, you can still fish for hints in the stack, take a look at $esp and dump some dwords from there, hoping to find ptrs to symbols.. that's assuming you have debug info/symbols at all
04:44:35 <BenediktStean> but i take only the * first elements of it
04:44:36 <shachaf> It's not unheard of for programs to jump into invalid code. :-)
04:44:44 <Athas> shachaf: that'll be more complicated, but I'll give it a try eventually.
04:44:50 <BenediktStean> but its do not stop calc
04:45:01 <Athas> Right, but jumping into invalid code would be incompatible with my FFI bug theory.
04:45:02 <Peaker> Athas, a gdb trick I use to get it to show me symbols, is to cast a ptr I want to dump to be a ptr-to-array-of-func-ptrs, and then print the dereference of it -- and gdb shows the array and decodes the name of each symbol
04:45:40 <Peaker> Athas, something like:   p *(void *(*)[32]) address
04:45:51 <Peaker> (there might be an easier way :) )
04:46:15 * shachaf considers alpha-renaming Zipper.
04:46:29 <shachaf> (h :> s) :> a or something.
04:47:06 <Athas> Urh, according to GDB, the bottommost stack frame is at 0x0.
04:47:10 <Athas> This is probably a corrupt stack.
04:47:15 <shachaf> Probably.
04:49:23 <mutha> how do I get a unique RandomGen every time a program starts?
04:49:33 <Botje> mutha: getStdGen
04:49:40 <hpc> :t getStdGen
04:49:41 <lambdabot> IO StdGen
04:49:47 <Peaker> Athas, what does $esp equal?
04:49:53 <Peaker> Athas, don't trust gdb's stack analysis
04:50:04 <mutha> that is a global rand gen though?
04:50:23 <Botje> yes, and?
04:50:24 <hpc> take note of the fact that it has IO in the type
04:50:52 <mutha> Botje i wanted to use pure functions, like random
04:51:14 <Botje> mutha: you can grab it once and then pass it to the rest of your program.
04:51:41 <Botje> since that's what you were doing anyway, I guess?
04:51:45 <BenediktStean> http://hpaste.org/78289 whats wrong with it
04:51:45 <mutha> what if i have two theads and each one needs its own seed?
04:51:57 <mutha> or RandomGen
04:52:40 * hackagebot persistent-postgresql 1.0.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-1.0.2 (MichaelSnoyman)
04:52:52 <Botje> mutha: then use newStdGen when you first create a thread.
04:53:05 <Botje> that will split the global gen into two independent ones, store one and give you the other one.
04:53:28 <Botje> BenediktStean: does GHC say there is something wrong with it?
04:53:45 <Botje> BenediktStean: or does it match your expectations, in which case: what is epxected/actual result
04:54:08 <Athas> Peaker: $rsp is 0x7fffdf7f0ff8 (this is an AMD64 system).
04:54:41 <Botje> BenediktStean: you are missing a ) at the very last character in your paste, if that helps.
04:55:00 <BenediktStean> it should create two list with the same length, but its dont not stop calculating
04:55:01 <hpc> :t newStdGen
04:55:02 <lambdabot> IO StdGen
04:55:43 <BenediktStean> no the ) do not help :D
04:55:43 <Botje> BenediktStean: are you feeding it infinite lists by accident?
04:55:49 <BenediktStean> jep
04:55:54 <BenediktStean> but i use take
04:56:26 <BenediktStean> i thought it work cause of lazyness
04:56:35 <Botje> BenediktStean: and what is the length of an infinite list?
04:57:26 <BenediktStean> oh no i dont feed it with infinite lists, list1 and list2 arent infinite
04:58:02 <Botje> BenediktStean: can you show how you test it?
04:58:16 <BenediktStean> pad 0 [1,1,1,0,0,1] [1,0,1]
04:58:35 <Botje> BenediktStean: it terminates form e,
04:58:39 <Botje> *Main> pad 0 [1,1,1,0,0,1] [1,0,1]
04:58:39 <Botje> ([1,1,1,0,0,1],[1,0,1,0,0,0])
04:58:46 <Botje> are you perhaps running an older version by accident?
04:58:57 <Botje> like, forgot to reload or something?
04:59:09 <BenediktStean> resuno i did reload
04:59:15 <BenediktStean> hm
04:59:23 <BenediktStean> i used ghci
04:59:47 <Botje> have you tried restarting ghci?
05:00:07 <BenediktStean> i ll try
05:00:35 <Peaker> mutha, then pass the rand gen around?
05:00:50 <BenediktStean> *Main> pad 0 [1,1,1,0,0,1] [1,0,1] (^CInterrupted.
05:00:58 <BenediktStean> dont work
05:01:10 <BenediktStean> maybe my ghci isnt that lazy :/
05:01:33 <Botje> BenediktStean: I think you have a different definition of pad.
05:02:16 <BenediktStean> this is my definition http://hpaste.org/78289 with an ) at the end
05:02:41 * hackagebot unittyped 0.1 - An extendable library for type-safe computations including units.  http://hackage.haskell.org/package/unittyped-0.1 (ThijsAlkemade)
05:02:54 <Botje> BenediktStean: yes, I downloaded that definition and it returns the correct result for me.
05:03:01 <Botje> BenediktStean: which makes me suspect you are loading a different version.
05:03:18 <Botje> BenediktStean: please try saving that exact version in a new file, and load the new file.
05:06:30 <BenediktStean> i works in the new file, but i not in the old one where i need it :(
05:06:42 <BenediktStean> but the old one compiles without any erros
05:06:44 <BenediktStean> erros
05:06:50 <BenediktStean> errors
05:07:42 <Athas> Is it common for GHC to store addresses of values on the stack in registers?
05:12:20 <tonylyliu> tonylyliu
05:15:17 <mutha> thanks all, works nicely
05:16:03 <mutha> i love how you only need IO to get initial RandomGen, while everything else can be pure
05:16:32 <pettter> *boom*
05:20:10 <LispMasterRace> Ohai!
05:21:07 <typoclass> LispMasterRace: hello
05:21:40 <LispMasterRace> how goes it?
05:22:58 <typoclass> LispMasterRace: quite nicely. this channel is for discussing the haskell programming language
05:23:02 <typoclass> @where lyah
05:23:02 <lambdabot> http://www.learnyouahaskell.com/
05:23:08 <typoclass> LispMasterRace: here, have a look ^^
05:23:31 <LispMasterRace> Oh, it's ok. I'm on tryhaskel.org right now, so it's all good :)
05:23:50 <typoclass> LispMasterRace: very good
05:48:16 <tonylyliu> i've used erlang to code a few projects, the basics seems the same
05:48:27 <tonylyliu> just the syntax difference
05:48:51 <SwashBuckla> hi there, I seem to be having a parse error at line 51, column 4 in this source code: ) c = c' `cardBeats` c || handBeats h c
05:48:55 <SwashBuckla>  
05:49:06 <SwashBuckla> sorry, THIS source code: http://pastebin.com/rPYpBWWw
05:49:10 <mauke> The paste rPYpBWWw has been copied to http://hpaste.org/78291
05:49:44 <SwashBuckla> when I load the module, I get "L01B.hs:51:4: parse error on input `where"
05:50:24 <SwashBuckla> I can't see how "where" is wrong at all here
05:50:57 <mauke> missing =
05:51:25 <SwashBuckla> where is there a missing =?
05:52:00 <typoclass> tonylyliu: haskell has types! that's a big difference :-)
05:53:04 <byorgey> SwashBuckla: right after "otherwise"
06:07:45 * hackagebot http-conduit 1.8.4.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.4.3 (MichaelSnoyman)
06:07:47 * hackagebot hledger-interest 1.4.2 - computes interest for a given account  http://hackage.haskell.org/package/hledger-interest-1.4.2 (PeterSimons)
06:08:08 <osa1> hmm does anyone know with how long intervals hackage's haddock bot runs ?
06:10:03 <typoclass> osa1: once every 12 hours or something ...
06:10:06 <typoclass> not sure
06:11:02 <osa1> typoclass: hmm it's been more than 24 hours but my package's docs still not generated
06:11:23 <osa1> typoclass: could it be related with build failures ? (seems like it fails with ghc 7.6, I only tried with 7.4)
06:11:25 <typoclass> osa1: oh. was there a build failure? (see the 'log' link)
06:11:51 <typoclass> osa1: sure, i think haddock only works properly if ghc works
06:12:11 <osa1> ok
06:12:30 <osa1> I'll fix it for 7.6 anyway. lets see if it generates docs after that
06:12:42 <typoclass> osa1: i bet it will
06:34:54 <rizlah> VOT UP
06:35:03 <Botje> SKY.
06:40:10 <TBJoe> hi guys, how can i concatenate two chars? ++ and : doesnt work
06:40:40 <companion_cube> well, concatenating chars does not make much sense
06:40:40 <int-e> TBJoe: [a,b] or a : b : "" (or a : b : [])
06:40:55 <TBJoe> ok thx :)
06:45:19 <atriq> Is there any list-y type with better-than-O(n) reverse?
06:50:06 <danharaj> edwardk: I had a cute idea I'm playing with and it involves something that looks like a Monad, except it's a functor from Hask to a Kleisli category, so it's not an endofunctor. I'm not sure what the laws should look like, or what I should call it. Do you have ideas I can steal?
06:50:08 <danharaj> http://hpaste.org/78292
06:50:50 <rwbarton> atriq: you could use a pair (Data.Seq.Seq, Bool {- am I reversed -}) I guess
06:50:58 <moriarty> whose bot is lambdabot? :)
06:50:59 <rwbarton> or even just a dequeue depending on what operations you need
06:51:04 <danharaj> moriarty: Cale
06:51:35 <bartavelle> is there a wrapper that takes (f :: a -> b) and produces (Sink a (ResourceT IO) b)  ?
06:51:41 <atriq> rwbarton, that sort of works
06:51:43 <moriarty> ah, thanks danharaj :)
06:53:08 <rwbarton> atriq, wrap it up in a newtype and provide your own operations/instances
06:54:52 <Sculptor> hi
06:54:59 <moriarty> shachaf, feel free to bring it to ##econometrics where there are some haskell aficionados :)
06:55:47 <shachaf> moriarty: Hardly. I hate Haskell.
06:56:09 <moriarty> awe
07:02:58 <osa1> is there a way to make cabal-install use multiple cores ?
07:03:26 <Saizan> recent cabal installs have a -j option
07:03:46 <Saizan> it's the number of packages it can build at the same time
07:04:54 <osa1> Saizan: I have "cabal-install version 1.16.0.2" but -j parameter gives "cabal: unrecognised command: -j4 (try --help)"
07:22:41 <killy9999> is there a way to override type signature for a function in a type class when defining an instance?
07:22:52 <shachaf> What does that mean?
07:23:20 <killy9999> shachaf: I have a type class that has some function defined for its instances
07:23:25 <Ololo> @pl a % b = a - floor(a / b) * b
07:23:25 <lambdabot> (line 1, column 8):
07:23:25 <lambdabot> unexpected " "
07:23:25 <lambdabot> expecting operator
07:23:53 <killy9999> that function has a constraint:  fun :: (ABC a) => a -> a -> whatever
07:23:57 <Ololo> @pl (%) a b = a - floor (a / b) * b
07:23:57 <lambdabot> (line 1, column 10):
07:23:57 <lambdabot> unexpected " "
07:23:57 <lambdabot> expecting operator
07:24:01 <Ololo> wtf
07:24:23 <killy9999> I would like to write an instance for some particular instance of ABC
07:24:42 <Ololo> @pl \a b -> a - floor (a / b) * b
07:24:42 <lambdabot> liftM2 (.) (-) (join . (((*) . floor) .) . (/))
07:25:09 <killy9999> so if Double belongs to ABC I'd like to write function: fun :: Double -> Double -> whatever
07:25:14 <stepkut> using Data/Typeable is it possible to get the arity of a constructor?
07:25:27 <rwbarton> so like what, "class Killy9999 whatever where fun :: (ABC a) => a -> a -> whatever"?
07:25:59 <killy9999> yes
07:26:23 <shachaf> stepkut: Looks that way.
07:26:37 <killy9999> actualy "whatever" in class instance declaration does not have to be the same "whatever" returned by fun
07:26:59 <killy9999> the point is how to specialize fun for a particular instance of ABC?
07:27:20 <rwbarton> well the "whatever" in the class instance must appear *somewhere* in the type of fun, at least?
07:27:20 <rwbarton> sounds like you need mptcs
07:27:56 <danharaj> killy9999: fun' :: Double -> Double -> Whatever; fun' = fun
07:28:01 <danharaj> The types unify.
07:28:08 <rwbarton> as you want the definition of fun to depend on the types 'a' and 'whatever' in a way that is not "independent"
07:28:27 <stepkut> shachaf: any hints?
07:28:29 <shachaf> stepkut: Oh, maybe not.
07:28:41 <rwbarton> he means specialise as in provide a custom definition for
07:28:44 <killy9999> danharaj: but I have to implement fun, because class requires it
07:28:55 <danharaj> oh I see now. silly me,.
07:29:01 <shachaf> stepkut: I saw constrFields
07:29:06 <killy9999> rwbarton: I need to think this through, give me a moment
07:29:08 <shachaf> But that's only for named fields or something?
07:29:11 <stepkut> shachaf: yeah, so did I :)
07:29:16 <stepkut> shachaf: yeah, only named fields
07:29:19 <rwbarton> > constrFields (toConstr (Just 'a'))
07:29:21 <lambdabot>   Not in scope: `constrFields'Not in scope: `toConstr'
07:29:34 <stepkut> shachaf: I can use TH to reify the Constr name :-/
07:29:50 <rwbarton> it must be possible
07:30:02 <shachaf> GHC.Generics can certainly do it. :-)
07:30:27 <rwbarton> er, you could use fromConstrM perhaps
07:30:42 <killy9999> rwbarton: you're right, whatever appears in the type of fun
07:30:54 <stepkut> shachaf: GHC.Generics is actually acceptable as well :)
07:31:08 <rwbarton> you have a value? and you want to know the arity of the constructor it was made with? or you just have a Constr
07:31:55 <rwbarton> how about length . gmapQ (return ())
07:32:20 <rwbarton> where by return I mean const
07:32:50 * hackagebot language-lua 0.1.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1.1 (OmerAgacan)
07:35:21 <rwbarton> you can also do it using gunfold
07:35:23 <shachaf> OK, I guess rwbarton's solution would work.
07:35:27 <rwbarton> @type gunfold
07:35:28 <lambdabot>     Not in scope: `gunfold'
07:35:28 <lambdabot>     Perhaps you meant one of these:
07:35:28 <lambdabot>       `unfoldr' (imported from Data.List),
07:35:38 <rwbarton> alas
07:35:59 <shachaf> @ty gmapQ
07:36:00 <lambdabot> Not in scope: `gmapQ'
07:36:03 <shachaf> Hmph.
07:36:07 <shachaf> We have upon but no gmapQ?
07:36:32 <rwbarton> we have upon now?
07:36:34 <rwbarton> @type upon
07:36:35 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f, Indexed Int k) => (s -> a) -> k (a -> f a) (s -> f s)
07:36:43 <atriq> I really ought to learn fgl at some point
07:36:55 <shachaf> > set (upon last) 'Q' "hello world"
07:36:57 <lambdabot>   "hello worlQ"
07:37:16 <shachaf> We also have uponTheDeep!
07:37:25 <atriq> :t uponTheDeep
07:37:26 <lambdabot> (Data.Data.Data a, Data.Data.Data s, Applicative f, Indexed [Int] k) => (s -> a) -> k (a -> f a) (s -> f s)
07:37:33 <atriq> Oh that looks scary
07:38:01 <shachaf> uponTheDeep :: (Data s, Data a) => (s -> a) -> SimpleTraversal s a
07:38:15 <shachaf> upon :: (Data s, Typeable a) => (s -> a) -> SimpleTraversal s a
07:38:32 <shachaf> (And an index. But who cares about the index?)
07:39:46 <rwbarton> I could really use :i in lambdabot
07:39:52 <rwbarton> It's a pity shachaf hasn't finished his lambdabot 2.0 yet
07:40:03 <atriq> @info SimpleTraversal
07:40:03 <lambdabot> SimpleTraversal
07:40:12 <atriq> @info Int
07:40:12 <lambdabot> Int
07:40:18 <atriq> @info Atriq
07:40:18 <lambdabot> Atriq
07:40:28 <atriq> :(
07:40:41 <shachaf> rwbarton: Hey, one of us is an expert in the module that does :t
07:40:45 <shachaf> And it ain't me.
07:41:12 <shachaf> You could probably give Cale a 5-line patch to do :i
07:41:30 <shachaf> You could probably introduce a back door into it pretty easily, too.
07:41:39 <rwbarton> $ ghc -e ":t map"
07:41:39 <rwbarton> map :: (a -> b) -> [a] -> [b]
07:41:47 <shachaf> Then you can take over lispy's machine!
07:41:58 <shachaf> And replace lambdabot with something better.
07:42:31 <rwbarton> when you put it that way...
07:42:50 <stepkut> rwbarton: so, I want to be able to create a type like, data Foo = Bar Int | Baz, and functions like bar and baz and then use a TH function: call :: a -> ExpQ, and be able to do $(call (Bar 1)) which will result in 'bar 1' being spliced in
07:45:24 <rwbarton> I see
07:45:53 <shachaf> Are you sure you want to do that?
07:46:01 <stepkut> shachaf: you got a better idea?
07:46:10 <shachaf> Idea for doing what?
07:46:27 <rwbarton> I can do it for $(call Bar) 1 :P
07:46:41 <stepkut> rwbarton: me too :)
07:47:20 <rwbarton> okay so I guess that's been considered
07:47:23 <rwbarton> but it should not be that much worse, right
07:47:46 <rwbarton> ah. I keep thinking you are passing the TH expression [|Bar 1|]
07:47:49 <rwbarton> but no
07:48:47 <rwbarton> I assume this has something to do with webserver routing?
07:48:54 <stepkut> rwbarton: yes indeed
07:49:17 <rwbarton> hmm, wait
07:49:23 <rwbarton> you need a way to lift the value 1 to the TH [|1|]
07:49:56 <rwbarton> I guess that is the Lift class
07:50:01 <stepkut> yeah
07:50:19 <rwbarton> I forgot that was actually part of TH
07:50:55 <shachaf> I guess that indicates that they named it well!
07:50:57 <rwbarton> I guess you need to write Lift with Data stuf?
07:51:05 <shachaf> (Except for the whole conflict with MonadTrans.)
07:51:13 <xdccemule> !list
07:51:13 <monochrom> xdccemule: http://hpaste.org
07:51:17 <rwbarton> shachaf: actually I remembered that it existed and was called Lift but not that it was actually part of TH as opposed to one of mmorrow's packages
07:52:06 <rwbarton> Is that the first time monochrom's bot has been used?
07:52:52 <Saizan> nope
07:54:46 <neutrino> rwbarton: monochrom's bot?
07:55:01 <rwbarton> see 4 minutes ago
07:55:05 <neutrino> yeah i see that
07:55:09 <neutrino> !list
07:55:09 <monochrom> neutrino: http://hpaste.org
07:55:15 <neutrino> monochrom: wtf :)
07:55:21 <neutrino> rwbarton: xdccemule was a bot too.
07:55:50 <neutrino> it was looking for xdcc bots - usually based off eggdrop - which allow file downloads, like ftp, but via irc instead
07:56:05 <neutrino> the !list is a trigger for all of them to make themselves known
07:56:12 <rwbarton> yes
07:56:40 <neutrino> but i'm surprised why monochrom's script, what ever it is, has this trigger and such a weird reply to it.
07:56:42 <rwbarton> monochrom has helpfully provided them xdccemule with some files to download
07:56:54 <rwbarton> it can also produce hackage and something else
07:56:56 <rwbarton> oleg's site
07:57:23 <neutrino> !list
07:57:23 <monochrom> neutrino: http://okmij.org/ftp
07:57:28 <neutrino> right
07:57:49 <neutrino> that's not something an xdcc scanner would even notice though
07:57:58 <neutrino> they only expect ctcp, msg, or dcc
07:58:25 <rwbarton> are the people who say "ciao" and then "!list" bots or humans?
07:58:36 <neutrino> bots
07:58:55 <neutrino> xdccemule was a bot
07:59:14 <rwbarton> yes but it didn't say "ciao" which is unusual
07:59:23 <rwbarton> how is gfoldl's second argument supposed to do anything?
07:59:59 <neutrino> it depends on who set up the bot, rwbarton
08:00:16 <neutrino> it's always coded by hand
08:00:34 <rwbarton> it apparently gets the constructor (as a function) but it just has type (forall g. g -> c g)
08:01:23 <rwbarton> oh I guess it doesn't matter
08:01:39 <neutrino> :t gfoldl
08:01:41 <lambdabot>     Not in scope: `gfoldl'
08:01:41 <lambdabot>     Perhaps you meant one of these:
08:01:41 <lambdabot>       `foldl' (imported from Data.List),
08:02:15 <rwbarton> stepkut: how about (partly from memory, probably stuff is wrong) \a -> gfoldl (\c d -> AppE c (liftData d)) (stepkut'sLookup (toConstr a)) a
08:02:40 <rwbarton> where liftData is a generic version of lift (which maybe you have to write too) and stepkut'sLookup takes the Constr for Bar and produces the expression [|bar|]
08:03:16 <rwbarton> oh
08:04:18 <rwbarton> that won't quite typecheck, need newtype Const r = Const { unConst :: r } ; \a -> unConst $ gfoldl (\(Const c) d -> Const (AppE c (liftData d))) (Const $ stepkut'sLookup (toConstr a)) a
08:05:03 <shachaf> Great choice of names there.
08:05:09 <shachaf> unConst :: r
08:05:16 <shachaf> Not to be confused with toConstr
08:05:19 <rwbarton> er
08:05:26 <rwbarton> "newtype Const r a = " of course
08:05:27 <rwbarton> heh :)
08:05:42 <shachaf> Well, sure. That's in the standard library anyway.
08:06:07 <rwbarton> is it
08:06:14 <shachaf> const @ty Const
08:06:16 <rwbarton> ah yes
08:06:21 <shachaf> @ty toConstr
08:06:23 <lambdabot> Not in scope: `toConstr'
08:06:23 <shachaf> Er.
08:06:27 <shachaf> @ty Const
08:06:28 <lambdabot> a -> Const a b
08:06:32 <shachaf> It's also in lens!
08:06:43 <rwbarton> "newtype Const r = Const { unConst :: r } ; \a -> unConst" -> "\a -> getConst"
08:07:10 <shachaf> Briefly lens hid the class Gettable inside a module marked unsafe.
08:07:13 <shachaf> Because we were silly.
08:08:17 <Saizan> no longer being evil?
08:08:53 <shachaf> Saizan: Not that particular brand of evil, no.
08:09:00 <danharaj> I was about 12 perturbed when lens moved some implementation details into Unsafe modules and did wizardry.
08:09:07 <danharaj> Because I didn't understand the implementation anymore :[
08:09:16 <shachaf> danharaj: Which details?
08:09:32 <danharaj> Something something unsafeCoerce
08:09:46 <shachaf> I'm sorry, you'll have to be more specific.
08:09:50 <typoclass> Saizan: the nice people from the finance industry looked at it and certified that it is indeed not evil and in fact perfectly benign
08:10:30 <danharaj> shachaf: I don't care to remember the details.
08:11:25 <shachaf> danharaj: I've been slowly working on getting rid of the unsafeCoerces, one at a time.
08:11:34 <shachaf> But edwardk's putting them in faster than I can take them out.
08:11:56 <rwbarton> is the eta stuff something that can be abstracted out somehow? maybe even put in its own package
08:11:58 <stepkut> rwbarton: I feel like this isn't going to work the way I want. Seems like it will generate a function that can only handle the specific value you passed in ?
08:12:05 <rwbarton> i realize that may be difficult without undoing what it achives
08:12:46 <rwbarton> but call is receiving a specific value, right?
08:13:07 <shachaf> rwbarton: You mean the (Identity .) -> unsafeCoerce thing?
08:13:15 <rwbarton> I think so
08:13:23 <rwbarton> is that all that is?
08:13:29 <shachaf> Well, there are a couple of issues.
08:13:44 <shachaf> One is that (Identity .) really is denotationally different from unsafeCoerce
08:13:57 <shachaf> So we made strict composition, (!f) `o` (!g) = \x -> f (g x)
08:13:58 <rwbarton> just a thought that maybe if you can't get rid of the unsafeCoerce completely, perhaps isolating it in its own little package is still an improvement
08:14:05 <rwbarton> right
08:14:11 <shachaf> But then gcc isn't good at optimizing that, so we made a bunch of RULES.
08:14:13 <shachaf> ghc
08:14:25 <rwbarton> gcc is probably even worse
08:14:38 <shachaf> gcc is great at unsafeCoercing.
08:14:50 <shachaf> So then it turns out that GHC doesn't like RULES that involve newtype constructors.
08:15:05 <shachaf> So we can't really use the RULES approach either.
08:15:11 <rwbarton> interesting
08:15:17 <shachaf> Also, lens defines a lot of custom lens-specific types.
08:15:19 <aristid> so unsafeCoerce it is
08:15:24 <shachaf> newtype Mutator a = Mutator a
08:15:32 <rwbarton> right
08:15:45 <shachaf> And you need a special function (or at the very least a RULE, if we manage to make that work) for each of them.
08:15:51 <rwbarton> I meant something that abstracts over newtypes that are newtype X a = X a. I guess that's sort of dumb.
08:16:06 <shachaf> We have a lot of different newtypes.
08:16:11 <shachaf> How would you abstract over that safely?
08:16:21 <rwbarton> I don't know
08:16:35 <rwbarton> are a lot of them just Identity?
08:17:10 <shachaf> I think only one of them is Identity.
08:17:20 <shachaf> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Combinators.hs
08:17:23 <danharaj> I think there's an Identity and a Const and others
08:18:06 <shachaf> We had an amusing bug back when we had an operator called (#), where the same file compiles with and without MagicHash, and behaves the same way, but generates slightly different Core.
08:18:34 <shachaf> Anyway, I'd love a solution to that.
08:18:42 <shachaf> I assume the best solutions will involve changing GHC, though.
08:19:50 <shachaf> Hmm.
08:19:57 <rwbarton> shachaf: Well, it is Magic.
08:20:12 <shachaf> Is it true that lazy composition is associative and has no identity, and strict composition has an identity but isn't associative?
08:20:14 <Peaker_> I'm trying the newest emacs haskell-mode  --  it's failing to show any types except ones defined in the local file with an explicit signature :(
08:20:19 <Peaker_> doesn't seem too useful...
08:21:10 <latermuse> peaker_: dang
08:21:11 <Peaker_> can haskell-mode auto-load the code in ghci and figure out types? It doesn't seem to do any of this out of the box
08:21:15 <shachaf> Cale: Did you shut lambdabot down without @flush? :-(
08:21:19 <shachaf> I think quotes get lost when you do that.
08:21:28 <Peaker_> Every time I try haskell-mode, none of the goodies seem to work for me :(
08:21:33 <rwbarton> lispy shut it down
08:21:36 <rwbarton> shut down the vm
08:21:38 <latermuse> peaker_: did you install it correctly?
08:21:56 <shachaf> Ah.
08:21:58 <Peaker_> latermuse, I git clone'd the newest one, added (load "~/.emacs.d/haskell-mode/haskell-site-file")
08:22:04 <shachaf> I guess people ought to @flush more.
08:22:09 <latermuse> @flush
08:22:09 <lambdabot> Not enough privileges
08:22:13 <latermuse> :(
08:22:13 <shachaf> rwbarton: I bet lambdabot 2.0 autoflushes.
08:22:23 <rwbarton> so I hear
08:22:36 <rwbarton> why wouldn't strict composition be associative
08:22:37 <bgamari> Peaker, I have the same problem unfortunately
08:22:39 <rwbarton> ?
08:22:43 <Peaker_> latermuse, does haskell-mode depend on ghc-mod for all the goodies?
08:22:52 <bgamari> latermuse, Peaker Installing it correctly appears to be a nontrivial process
08:22:55 <latermuse> peaker_: I use vim, not much experience with emacs. sorry. Maybe try reinstalling it?
08:23:01 <bgamari> especially when it needs to interact with evil
08:23:14 <Peaker_> latermuse, I just installed it cleanly, without changing anything (also, not first attempt)
08:23:26 <latermuse> peaker_: does it work correctly on your other machines?
08:23:56 <Peaker_> latermuse, I've never seen it do anything beyond indent stuff in a semi-reasonable way
08:24:29 <latermuse> peaker_: haskell mode words nicely for me in vim. you could try vim?
08:24:30 <Peaker_> I use haskell-mode for a long time, and people speak wonders, but all it ever did successfully was syntax coloring, that, and some type signatures for Prelude stuff that sometimes works
08:24:47 <Peaker_> latermuse, too many years of muscle memory :)
08:24:59 <latermuse> :)
08:25:13 <shachaf> rwbarton: Oh, I think it might've been strict-only-in-the-first-argument composition.
08:25:16 <shachaf> Or something like that.
08:25:21 <bgamari> Peaker, It's not terribly robust. I find that many of the features get in the way, especially when working on projects which don't follow conventional style
08:25:29 <shachaf> I guess strict composition works out.
08:26:48 <Peaker_> I guess I'll get back to work with low expectations of haskell-mode again
08:32:52 * hackagebot liblastfm 0.0.3.8 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.8 (DmitryMalikov)
08:37:53 * hackagebot git-annex 3.20121126 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121126 (JoeyHess)
08:39:42 <stepkut> is there a way to do this without relying on Typeable,        i <- reify (mkName (show (typeOf 'c')))
08:40:54 <Philonous> Peaker_:  Works fine for me. Shows types for anything that's currently in scope for the running ghci session (as you would expect)
08:41:21 <Peaker_> Philonous, "for the running ghci session" -- do I need to explicitly start one?
08:41:34 <Philonous> Peaker_:  AFAIK, Yes
08:41:39 <Peaker_> ah, that might explain things
08:41:50 <latermuse> try it and see
08:41:58 <Peaker_> C-c C-l   I see..  how do I add -i options to the ghci session?
08:42:01 <monochrom> Peaker_: it does not auto-load. but after you load (C-c C-l), C-c C-t asks ghci
08:42:24 <Peaker_> how do you tell it where the "project root" is?
08:42:27 <Peaker_> (so it can find imports)
08:43:13 <rwbarton> that seems to work magically if there is a .cabal file there
08:43:15 <Peaker_> oh, it does seem to have tried to find a root, but found src root ..
08:43:24 <Peaker_> rwbarton, yeah, that's what it did, but I have hs-src-dirs=...
08:43:31 <rwbarton> oh maybe it doesn't know about that
08:43:53 <Philonous> Peaker_:  It uses cabal-dev ghci
08:44:01 <Philonous> So it should find your files for you
08:44:23 <Peaker_> hmm I'm not using cabal-dev, though
08:44:27 <Peaker_> I'll try building with cabal-dev
08:46:25 <monochrom> suppose you have /p/X/Y.hs, which says "module X.Y". then haskell-mode will tell ghci to ":cd /p" correctly
08:46:37 <monochrom> err, I skipped one step
08:47:10 <monochrom> suppose you have /p/X/Y.hs, which says "module X.Y". you C-x C-f /p/X/Y.hs. then haskell-mode will tell ghci to ":cd /p" correctly
08:47:26 <Peaker_> monochrom, so just open all the relevant modules as buffers?
08:47:32 <monochrom> I still skipped one step. C-c C-l
08:47:59 <Peaker_> yay, that works
08:48:01 <Peaker_> thanks
08:48:28 <Peaker_> ok, now it still shows a wrong type when cursor is on something.. C-c C-t shows right type in the session window
08:49:34 <Peaker_> how do you tell haskell-mode to insert the type of a name?
08:49:52 <Philonous> C-u C-c C-t
08:51:38 <Peaker_> Philonous, great, thanks. Finally some value out of this thing :)
08:51:56 <parcs`> stepcut: there's lookupName
08:53:32 <parcs`> stepcut: wait, do you want the type of an arbitrary expression at compile time?
08:53:42 <stepkut> parcs`: yeah.. unfortunately, it looks at what is in context where the splice is being spliced in, but that means that arguments to the template haskell function are not available for lookupNameValue
08:57:22 <parcs`> stepkut: hmm, then you're probably stuck with what you have. you can use lookupTypeName instead of mkName for a little more safety
08:58:01 <hpaste> gmaslov pasted “polymorphic machine epsilon” at http://hpaste.org/78294
08:58:08 <Peaker_> how do you use haskell-mode to figure out subexpression types - when those depend on params/etc?
08:58:12 <stepkut> suck. It wouldn't be so bad if I didn't get "GHC stage restriction: instance for `Typeable Route' is used in a top-level splice or annotation..."
08:59:09 <Peaker_> it's a bit sad to get types only for global-scope stuff?
08:59:36 <gmaslov> so I'm trying to write a machine epsilon constant (epsilon :: RealFloat a => a) that would have a different value depending on if it's read off as a Double or a Float. Unfortunately my attempt http://hpaste.org/78294 produces the same value, 2.22e-16 (the correct value for Double) both ways. Why? Is this type defaulting biting me somewhere?
09:00:19 <Philonous> Peaker_:  I don't think haskell-mode helps with that, but you can copy/paste it into the ghci buffer and abstract over the free variables
09:00:54 <rwbarton> gmaslov, defaulting
09:00:57 <rwbarton> a tricky case
09:01:12 <rwbarton> the epsilon on the RHS is not the same epsilon you are defining
09:01:15 <monochrom> @type floatDigits
09:01:16 <lambdabot> RealFloat a => a -> Int
09:01:21 <monochrom> @type encodeFloat
09:01:22 <lambdabot> RealFloat a => Integer -> Int -> a
09:01:33 <Peaker_> Philonous, bummer..
09:01:43 <Peaker_> Philonous, I don't see how people believe Haskell needs no ide...
09:02:02 <rwbarton> > let epsilon :: RealFloat a => a; epsilon = fix (\x -> encodeFloat 1 (fromIntegral $ 1-floatDigits x)) in (epsilon :: Double, epsilon :: Float)
09:02:04 <lambdabot>   (2.220446049250313e-16,1.1920929e-7)
09:03:23 <rwbarton> that worked because arguments to functions are monomorphic (unless you write a higher-rank type signature)
09:03:24 <Cale> Peaker_: What's wrong with ghci?
09:03:24 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:03:46 <gmaslov> rwbarton: yow, that was clever. thanks.
09:03:47 <Peaker_> Cale, I want to see the type of a sub-expression I'm editing in my editor, which involves stuff defined in a 'where' clause, or params, etc.
09:04:07 <Peaker_> Cale, doing the gymnastics required to get the type from ghci is a lot more than the single gesture it should cost :)
09:04:10 <rwbarton> that'd be pretty cool
09:04:11 <Philonous> Peaker_:  I guess implementing that will be easier once ghc supports holes
09:04:14 <rwbarton> how do you even do it from ghci
09:04:52 <rwbarton> gmaslov, more straightforward would be to use ScopedTypeVariables
09:05:09 <rwbarton> epsilon :: forall a. RealFloat a => a; epsilon = encodeFloat 1 (fromIntegral $ 1-floatDigits (undefined :: a))
09:05:45 <Philonous> Peaker_:  An IDE lacks emacs editing features. It's really either the devil or the deep blue sea.
09:06:17 <parcs`> gmaslov: are you compiling with -Wall? it warns you when defaulting is happening
09:06:42 <Peaker_> Philonous, well, emacs editing features are optimized for text, not code..
09:06:50 <Cale> Well, I can definitely see the usefulness of being able to inspect types of subexpressions. Most of the things that usual IDEs try to do is just obnoxious though.
09:06:55 <Peaker_> Philonous, but I agree most IDE's suck these days (which is why I'm working on one)
09:06:56 <gmaslov> parcs`, ah, no, only -W. but I see the warning now
09:07:40 <parcs`> hmm, what does -Wall enable that -W doesn't?
09:08:02 <parcs`> heh, from the man page "-Wall  enable almost all warnings (details in )"
09:08:13 <gmaslov> yeah, i just saw that. funny :)
09:09:16 <Cale> I think that IDEs and interactive debuggers are in part responsible for some of the worst code in production.
09:09:35 <shergill> Cale: +1
09:09:39 <Peaker_> IDEs try to bolt on meaningful/structural features on top of a text editor. A difficult and error-prone task
09:09:52 <Peaker_> instead, I believe we should just have meaningful/structural editors directly
09:10:02 <shachaf> Hmph.
09:10:40 <Cale> It's not because they're bad at what they do, but because they enable people to operate on code which they don't actually understand
09:10:56 <shachaf> I can't get GHC to turn "foo f m = go m [] where go [] = id; go (x:xs) = (\r -> if f x then x : r else r) . go xs" into filter
09:11:11 <Cale> (and make it even harder to understand as a result)
09:11:13 <shachaf> It keeps passing the [] along.
09:11:14 <tac> Cale: isn't part of what typing does is to remove the need to fully understand what the heck you're doing? :)
09:11:20 <shachaf> For similar code it manages to figure it out.
09:11:45 <Cale> tac: To an extent, but there are limits to that :)
09:12:03 <gmaslov> well, the usual pragmatic argument now is: would you rather have bad code in production doing useful work, or NO code in production because there wasn't time/budget to fully understand it
09:12:19 <Cale> False dichotomy
09:12:33 <tac> The only features I've ever wanted from an IDE are intellisense, tab-complete, and interactive typechecking.
09:12:40 <tac> and maybe a debugger
09:12:52 <monochrom> what is intellisense?
09:13:35 <tac> Basically, I want documentation in front of me as I write, to the extent that's feasible.
09:14:25 <tac> Of course, and IDE alone isn't good enough
09:14:43 <tac> You need library writers to give a shit about documentation.
09:15:27 <gmaslov> Ah, but when we have a perfect type system, the type is the documentation
09:15:40 <gmaslov> for pure things, anyway
09:15:50 <rwbarton> sounds like "the source code is the documentation"
09:15:50 <tac> I'm not so sure about that :P
09:17:42 <gmaslov> sure. with dependent types you can have, say, "blorgnax :: [a] -> Sorted [a]" and be fairly certain that blorgnax = sort. (but now you need the documentation for Sorted... I begin to see a flaw in my plan)
09:18:27 <monochrom> blorgnax _ = []  easily satisfies that type, but is unlikely what you want
09:18:27 <tac> gmaslov: the problem with dependent typed documentation is now instead of hiring coders, you have to hire mathematicians
09:18:52 <tac> For fun, I showed my friend who's learning F# the type of nat_rec.
09:19:01 <tac> He head exploded. We had to go to the E.R.
09:19:19 <gmaslov> heh. true enough :)
09:19:21 <shachaf> What is the type of nat_rec?
09:19:36 <shergill> ask yourself, do you really want to know?
09:19:39 <Saizan> you want (xs :: [a]) -> Sorted xs
09:19:55 <akahn> This code returns type IO (Request m). How can I make it just return the Request? http://hpaste.org/78296
09:20:03 <shachaf> akahn: You can't.
09:20:23 <shachaf> akahn: Instead, run the IO (Request m) to get a Request out of it.
09:20:25 <tac> shachaf: nat_rec : (P : Nat -> Set) -> (base : P 0) -> (induct : (n : Nat) -> P n -> P (succ n)) -> (k : Nat) -> P k
09:20:37 <shachaf> akahn: Which I guess is what you're doing there.
09:20:37 <tac> (If I didn't make a mistake).
09:21:00 <akahn> shachaf: huh. how would I run it?
09:21:01 <shachaf> akahn: Every piece of code that does I/O has to return something of type "IO ..." eventually.
09:21:22 <shachaf> akahn: Just like you're doing there. main = result <- transcriptRequest; ...
09:21:42 <monochrom> you forgot "do"
09:21:44 <akahn> I don't understand why constructing a Request requires IO
09:21:49 <akahn> ok
09:21:53 <quchen> Is there any meta information about how the current Haskell logo came about? I'm asking about how the winner was made, not the logo contest itself. I've found some cool properties in it and would like to not do duplicate work. :-)
09:22:06 <Peaker_> how is it possible that "cabal install foo" fails with a bunch of errors about reinstalling stuff, and then adding "--constraint .." to avoid changing some base package's version makes it succeed without a problem?
09:22:43 <gmaslov> it's a good point though, "parseUrl" _shouldn't_ require IO. i'd consider this a justified use of unsafePeformIO.
09:22:56 <monochrom> because cabal-install does not backtrack in case of needing reinstalls
09:22:57 <rwbarton> I think because the "failure" is not really a failure
09:23:00 <rwbarton> it is "success, but"
09:23:13 <rwbarton> right
09:23:40 <shachaf> Oh, wait.
09:23:41 <shachaf> This isn't IO.
09:24:05 <rwbarton> what's parseUrl
09:24:06 <shachaf> akahn: http://hackage.haskell.org/packages/archive/http-conduit/1.1.0.1/doc/html/Network-HTTP-Conduit.html#v:parseUrl
09:24:16 <rwbarton> oh right
09:24:17 <shachaf> Nothing about IO there.
09:24:17 <latermuse> quchen: There was some sort of competition to decide that logo. There is a website somewhere with all the details and entries.
09:24:22 <rwbarton> this interface looked sort of gross to me
09:24:39 <gmaslov> aha. it's actually a (Maybe Request), no problem
09:24:44 <shachaf> Yep.
09:25:10 <shachaf> akahn: Anyway, that thing return Maybe (Request ...), or (Either HttpException (Request ...)), or a bnch of other things.
09:25:40 <rwbarton> maybe it was just the custom type class rather than a simple Either
09:25:50 <monochrom> eh? at least "Failure HttpException m" tells you about what exception it throws :)
09:26:38 <fryguybob> quchen: There is a metapost file.  I have translated it to Diagrams too.
09:30:12 <Philonous> Is there a way to generate hackage-style package documentation locally?
09:30:41 <shachaf> Philonous: Yep.
09:30:57 <shachaf> Philonous: Put "documentation: True" in ~/.cabal/config
09:31:02 <monochrom> cabal install --enable-documentation
09:31:05 <shachaf> Then cabal-install will generate it automatically when you install things.
09:31:29 <Philonous> Won't that create the same thing as cabal haddock?
09:31:35 <monochrom> cabal configure; cabal build; cabal haddock; cabal copy; cabal register
09:32:35 <ion> (and optionally cabal test)
09:32:52 <Peaker_> test-framework-quickcheck does not cleanly install, as it seems antiquated and dependent on really old stuff... test-framework-quickcheck2 installs.  maybe test-framework-quickcheck can be hidden to avoid confusion?
09:35:24 <Philonous> The haddock output created locally is different from the one on hackage. It lacks the "properties" section in the contents site and containes module description that's not displayed on hackage
09:37:38 <Chaze_> is http://eclipsefp.github.com/ any good?
09:39:42 <rwbarton> mapM_ cabal [configure, build, haddock, copy, register]
09:46:59 <mutha> can someone explain why I'm getting this error? I copy/pasted this code from learn you a haskell tutorial
09:47:05 <mutha> http://hpaste.org/78297
09:48:58 <rwbarton> @let randoms' :: (RandomGen g, Random a) => g -> [a]; randoms' gen = let (value, newGen) = random gen in value:randoms' newGen
09:48:59 <lambdabot>  <local>:6:69:
09:48:59 <lambdabot>      Ambiguous type variable `t0' in the constraint:
09:48:59 <lambdabot>        (R...
09:49:19 <rwbarton> @type random
09:49:20 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
09:49:43 <rwbarton> @let randoms' gen = let (value, newGen) = random gen in value:randoms' newGen
09:49:44 <lambdabot>  <local>:6:20:
09:49:44 <lambdabot>      Ambiguous type variable `t0' in the constraint:
09:49:44 <lambdabot>        (R...
09:50:23 <rwbarton> works for me...
09:50:25 <rwbarton> odd
09:50:36 <mutha> yes
09:50:49 <ion> Hm, NoMonomorphismRestriction seems to break it.
09:51:03 <mutha> i am using ghc 7.4.1
09:51:26 <mutha> I might have enabled that
09:51:51 <mutha> yes I have
09:51:59 <rwbarton> I thought let bindings were monomorphic anyways
09:52:00 <rwbarton> also, wtf
09:52:11 <rwbarton> it shouldn't be generalizing value and newGen independently
09:53:15 <Cale> That is really weird
09:54:10 <Peaker_> every C-c C-l recompiles the world :(
09:55:02 <S11001001> @ty unfoldr (pure . random) (random gen)
09:55:03 <lambdabot>     Not in scope: `gen'
09:55:03 <lambdabot>     Perhaps you meant `get' (imported from Control.Monad.State)
09:55:09 <S11001001> @ty \gen -> unfoldr (pure . random) (random gen)
09:55:10 <lambdabot> (RandomGen g, RandomGen (a1, g), Random a1, Random a) => g -> [a]
09:55:45 <S11001001> oops
09:55:48 <S11001001> @ty \gen -> unfoldr (pure . random) gen
09:55:50 <lambdabot> (RandomGen b, Random a) => b -> [a]
09:57:06 <Cale> mutha: It's worth noting that 'case' works. I have no idea what's going on with 'let' there though. That shouldn't be an error, I think.
09:57:37 <Cale> It'd be interesting to see if that still happens in newer GHCs
09:57:37 <ion> Breaks with fix, too (no pun intended):
09:57:39 <ion> > fix (\f gen -> let (value, newGen) = random gen in value:f newGen)
09:57:40 <lambdabot>   Ambiguous type variable `t0' in the constraint:
09:57:40 <lambdabot>    (System.Random.RandomGen...
09:57:56 <rwbarton> the problem is around "let (value, newGen) ="
09:58:33 <rwbarton> it seems to have done something like transform it into "let value = fst ...; newGen = snd ..."
09:59:03 <Cale> It's as if GHC is reading it as  let (value, _) = random gen; (_, newGen) = random gen in ...
09:59:07 <Cale> yeah
09:59:14 <ion> @type let randoms' gen = value:randoms' newGen where { (value, newGen) = random gen } in randoms'
09:59:15 <lambdabot>     Ambiguous type variable `t0' in the constraint:
09:59:15 <lambdabot>       (Random t0) arising from the ambiguity check for `newGen'
09:59:15 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
09:59:32 <S11001001> if you turn on NoMonomorphismRestriction *and* TypeFamilies that fixes it
09:59:38 <rwbarton> lolwut
09:59:38 <S11001001> both off also works
09:59:40 <Cale> LOL
09:59:50 <rwbarton> how did you even think to try that
09:59:52 <monochrom> "let (x,y) = ..." is non-strict in the tuple. so yes it is the same as fst and snd
09:59:52 <mutha> :)
10:00:05 <S11001001> I vaguely remember something about how TypeFamilies messes with generalization of lets, from SPJ
10:00:37 <ion> @type let randoms' gen = value:randoms' newGen where { !(value, newGen) = random gen } in randoms'
10:00:38 <lambdabot> (RandomGen t, Random a) => t -> [a]
10:00:45 <monochrom> same for "case ... of ~(x,y)"
10:00:45 <rwbarton> :set -XMonoLocalBinds works too but now I'm confused because I thought that was the default
10:01:14 <rwbarton> ("works too" as in works together with NoMonomorphismRestriction, as a replacement for TypeFamilies)
10:01:22 <parcs`> does the program not work in ghci or when compiled or both?
10:01:24 <monochrom> MonoLocalBinds is the default if you turn on some other extension
10:02:03 <rwbarton> but turning off MonoLocalBinds doesn't break it without NoMonomorphismRestriction
10:03:43 <rwbarton> @type let foo :: (a,a); foo = undefined; bar = let (x,y) = foo in x:y in bar
10:03:45 <lambdabot> [a]
10:03:56 <rwbarton> this should not type check IMO
10:04:21 <rwbarton> @type let foo :: (a,a); foo = undefined; bar = let !(x,y) = foo in x:y in bar
10:04:22 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
10:04:22 <lambdabot>     In the second argument of `(:)', namely `y'
10:04:22 <lambdabot>     In the expression: x : y
10:04:28 <monochrom> Peaker_: that's ghci's :load re-compiling. use :reload. but there is no haskell-mode key for that. there used to be.
10:04:29 <ion> Heh, interesting
10:04:34 <rwbarton> but my opinion is not worth much
10:05:22 <Cale> rwbarton: I wholeheartedly agree -- that's totally broken
10:05:33 <rwbarton> that one type checks with no extensions...
10:05:37 <rwbarton> hmm
10:06:06 <rwbarton> anyone have some old versions of ghc to test out? :)
10:06:16 <weasels> there was a post on reddit about extensible records awhile back
10:06:21 <weasels> anybody remember it
10:06:43 <parcs`> looks like the monomorphism restriction isn't so dreaded after all
10:07:28 <mzero> edwardk: you said the other day that it wasn't clear how to encode the new extensible exceptions into the transformers/mtl framework
10:07:57 * hackagebot stm-io-hooks 0.7.5 - STM with IO hooks  http://hackage.haskell.org/package/stm-io-hooks-0.7.5 (PeterRobinson)
10:08:01 <S11001001> parcs`: no, just the lack of TypeFamilies :)
10:08:03 <aninhume1> otters: http://www.reddit.com/r/haskell/comments/12835b/datarecords_extensible_records_using_the_latest/ ?
10:08:12 <mzero> I have an implementation within my own project, and thinking that it would be useful to split it out as either a patch to transfomers or a separate package
10:08:21 <otters> hm
10:08:27 <otters> aninhume1: I don't think so, but it looks similar
10:08:30 <mzero> I'm wondering what was the uncertainty you were thinking of
10:09:06 <otters> unittyped requires ghc 7.6
10:09:16 <parcs`> rwbarton: you should submit a bug report
10:09:23 <otters> that's dumb
10:11:38 <rwbarton> hm
10:14:37 <rwbarton> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#mono-local-binds
10:15:44 <rwbarton> but even with that flag, some of the examples don't work (as in, they type check when they should not)
10:15:48 <rwbarton> the examples from the paper
10:16:22 <rwbarton> maybe it's really "-XIMightNotGeneraliseLocalBinds"?
10:23:40 <dropdrive> Dumb question about https://github.com/HeinrichApfelmus/operational/blob/master/doc/examples/State.hs -- where is actually specified that State is an instance of Monad?
10:27:07 <mauke> dropdrive: https://github.com/HeinrichApfelmus/operational/blob/master/src/Control/Monad/Operational.hs#L192
10:27:32 <rwbarton> oh, MonoLocalBinds is something else. it would stop me from using x or y twice at different types
10:27:36 <rwbarton> but I only use each once
10:27:59 <rwbarton> the issue is that I expected x and y to "share" a type variable
10:28:19 <mzero> dropdrive: https://github.com/HeinrichApfelmus/operational/blob/master/src/Control/Monad/Operational.hs#L192
10:28:27 <rwbarton> as far as I can tell from reading the Report, though, ghc is doing the right thing in my example
10:28:35 <rwbarton> just an unexpected corner case of HM I guess
10:28:59 <mzero> dropdrive: State is a typedef for Program, which is a typedef for ProgramT, which is an instance of Monad
10:29:45 <mzero> mauke: d'oh! - what you said!
10:30:29 <rwbarton> was wondering why mauke posted twice. using my patented "comparing head <> comparing length" scheme for distinguishing nicks
10:30:58 <ion> rwbarton: Their nicks have a different color. :-P
10:31:07 <shanse> their nicks have colour?
10:31:12 <ion> Yes, clearly.
10:31:43 <shachaf> comparing head <> comparing void -- works on infinite lists
10:31:52 <shanse> what is this colour wizardry?
10:31:53 <rwbarton> thachaf
10:32:00 <shachaf> ywbarton
10:32:14 <rwbarton> ... I sure walked into that one.
10:32:38 <Blkt> good evening everyone
10:32:39 <rwbarton> > fst (random (mkStdGen 17))
10:32:40 <ion> – Thank’s
10:32:41 <lambdabot>   7352521803991849760
10:32:43 <ion> – Your welcome
10:32:59 * hackagebot graphics-drawingcombinators 1.4.4 - A functional interface to 2D drawing in OpenGL  http://hackage.haskell.org/package/graphics-drawingcombinators-1.4.4 (EyalLotem)
10:33:04 <rwbarton> so I think the version that "works" with MR is actually using a separate 'random' computation for the newGen
10:33:14 <rwbarton> which is, shall we say, totally wrong
10:33:46 <rwbarton>   randoms  g      = (\(x,g') -> x : randoms g') (random g)
10:34:02 <rwbarton> I guess the author of System.Random was aware of this
10:34:42 <ion> huh
10:34:48 <dropdrive> mauke, mzero: Thanks.
10:35:14 <rwbarton> (it's wrong because it is defaulting to Integer, or something; and that won't necessarily advance the random generator by the right amount)
10:35:51 <rwbarton> > typeOf (fst (random (mkStdGen 17)))
10:35:52 <lambdabot>   Ambiguous type variable `a0' in the constraints:
10:35:52 <lambdabot>    (Data.Typeable.Internal...
10:35:55 <rwbarton> bah
10:36:36 <rwbarton> lol
10:37:05 <hpaste> rwbarton pasted “NMR insanity” at http://hpaste.org/78298
10:37:22 <ion> ~/games/rw
10:37:31 <rwbarton> mm
10:38:09 <shachaf> rwbarton: help
10:38:13 <shachaf> What's going on there?
10:38:25 <rwbarton> I guess 'it = ' is a binding to which MR applies??
10:38:31 <shachaf> Oh.
10:38:36 <rwbarton> but
10:38:50 <rwbarton> that's still really weird
10:39:49 <rwbarton> oh is it because of Show..........
10:40:21 <rwbarton> yes
10:40:30 <rwbarton> sigh
10:40:30 <notdan> Is it the case that (or . map f) is more efficient than (or $ map f list) ?
10:40:51 <Cale> notdan: It should be about the same
10:40:55 <rwbarton> the first one didn't work because it couldn't default (Random a) but the second one did work because it could default (Random a, Show a)
10:41:08 <Cale> notdan: also, you can abbreviate that to  any f
10:41:18 <shachaf> notdan: Those expressions don't do the same thing so it doesn't make sense to talk about which one is more efficient.
10:41:35 <notdan> Cale: yeah, I was just trying to get a grip on haskell's lazy evaluation
10:41:36 <shachaf> It makes sense to compare ((or . map f) list) with (or $ map f list)
10:41:45 <Cale> I'm assuming he meant (or . map f) list vs. (or $ map f list)
10:41:53 <shachaf> Those will be pretty much the same thing in every context.
10:42:06 <notdan> shachaf: well, yeah, I assume you know what I mean. g = or . map f vs g l = or $ map f l
10:42:24 <shachaf> notdan: As far as laziness goes those will behave exactly the same way.
10:42:27 <rwbarton> :t snd . random
10:42:28 <lambdabot>     Ambiguous type variable `a0' in the constraint:
10:42:28 <lambdabot>       (Random a0) arising from a use of `random'
10:42:28 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
10:42:34 <shachaf> As far as GHC optimizing them they'll probably turn into exactly the same thing.
10:42:36 <Cale> I would not be surprised if the compiler produced the same code for both of those.
10:42:39 <Cale> yeah
10:42:52 <notdan> Ok, cool. Thanks
10:42:55 <shachaf> Cale: However, (runIdentity . Identity . f) /= f :-(
10:48:11 <johnw> hey guys
10:48:17 <Cale> hello
10:48:43 <typoclass> johnw: yo
11:00:25 <Sir_K_Houwn> hi, i need to find the minimum of an list and return it plus the rest . Can anyone help me
11:00:34 <Sir_K_Houwn> is think this is the type
11:00:34 <Sir_K_Houwn> deleteFindMin :: Ord a => [a] -> (a ,[a])
11:00:51 <Sir_K_Houwn> i tried to use foldl
11:01:00 <shachaf> Sir_K_Houwn: You should pick a nick and stick with it. :-)
11:01:40 <Sir_K_Houwn> jep, its because i am using webirc at the time
11:03:00 * hackagebot attoparsec-parsec 0.0.2 - An Attoparsec compatibility layer for Parsec  http://hackage.haskell.org/package/attoparsec-parsec-0.0.2 (SimonHengel)
11:13:27 <RichyB> Sir_K_Houwn: you'll need to make two passes over the list. One to find the minimum, second to remove it.
11:14:56 <RichyB> You can't output elements lazily in one pass because you're never sure whether you've seen the minimal element or not yet while moving down the list.
11:15:59 <typoclass> RichyB: hm ... if he's allowed to change the order of the elements, he can do it in one pass i think
11:16:37 <RichyB> typoclass: good point.
11:17:00 <RichyB> If you can change the order of elements, then you should probably use a heap instead of a list. :)
11:22:04 <RichyB> > let deleteFindMin as = (min, remove) where { min = Data.List.minimum as; remove = (\(before, after) -> before ++ tail after) (Data.List.break (==min) as); } -- two passes, doesn't change order of elements, slightly ugly.
11:22:05 <lambdabot>   not an expression: `let deleteFindMin as = (min, remove) where { min = Data...
11:22:22 <gatlin> I'm a bit confused. If I run ghci with -XOverloadedStrings flag, :t "string" => Data.String.IsString a => a. But if I load a haskell file with {-# LANGUAGE OverloadedStrings #-}, :t "string" => [Char]
11:22:31 <gatlin> I was under the impression that these should both do the same thing
11:22:43 <byorgey> gatlin: you were under the wrong impression. =)
11:22:52 <RichyB> > let deleteFindMin as = (min, remove) where { min = Data.List.minimum as; remove = (\(before, after) -> before ++ tail after) (Data.List.break (==min) as); } in Data.List.unfoldr (\l -> if null l then Nothing else Just $ deleteFindMin l) "screaming heebie jeebies" -- really slow sorting algorithm :)
11:22:54 <lambdabot>   "  abbceeeeeeeghiiijmnrss"
11:23:03 <byorgey> gatlin: expressions entered at the ghci prompt are interpreted under whatever flags ghci has turned on.
11:23:04 <gatlin> byorgey: at least I'm sane then
11:23:13 <byorgey> gatlin: flags in a file only affect that file.
11:23:23 <merijn> gatlin: The extension enables it for the code in the file, but not for stuff you type on the ghci commandline
11:23:42 <merijn> Which is sometimes very annoying, as you noticed
11:23:46 <gatlin> Understood. I've been trying to wrap my head around bytestrings and regex, and sometimes it's hard to tell on small datasets if String or ByteString is being used
11:23:58 <gatlin> so ghci was going to be how I knew if ByteStrings were actually being used
11:24:01 <gatlin> oh well :)
11:24:14 <merijn> gatlin: You can just do both while testing/playing around in ghci :)
11:25:13 <gatlin> merijn: if I type {-# LANGUAGE OverloadedStrings #-}, :t "string" => [Char]
11:25:23 <gatlin> but that could also be ...
11:25:27 <gatlin> because it's a comment
11:25:36 <merijn> gatlin: You mean in the ghci prompt?
11:25:39 <gatlin> yes
11:25:51 <merijn> I don't think ghci accepts pragma's?
11:26:07 <gatlin> apparently not
11:26:22 <gatlin> well, at least my idiocy is in the chat log for idiot posterity
11:26:41 <ozgura> gatlin: you know you can pass them as arguments when you first start ghci?
11:26:54 <ozgura> i.e. ghci -XOverloadedStrings
11:27:11 <monochrom>  :set -XOverloadedStrings
11:27:15 <gatlin> ozgura: the point was, I wanted what I'm writing to use overloaded strings regardless of the compile flags
11:27:30 <schellsan> hi all
11:27:32 <gatlin> that's actually how I noticed the issue in my problem statement :)
11:27:37 <merijn> gatlin: In source files you can write that pragma and it'll work
11:27:38 <ozgura> gatlin: ok, I probably missed that part
11:28:03 <merijn> gatlin: It's just that enabling it for a loaded files won't enable it for ghci types things
11:28:09 <schellsan> has anyone had problems updating a yesod project to a new version of yesod?
11:28:44 <gatlin> merijn: that makes perfect sense now. ByteStrings / regex already test my sanity, so I wanted to make sure I haven't gone off the deep end yet
11:28:45 <merijn> gatlin: So you can use the pragma in your code to enable it in your file and use ":set -XOverloadedStrings" to enable them on the ghci prompt, which is what I meant with "do both"
11:30:52 <gatlin> actually, yeah, I'll open this can of worms. Since RWH has broken code examples and it appears all the blog posts I've found are from 2009 or earlier, where can I find information on getting started with ByteStrings and Text.Regex.{PCRE,Posix} ?
11:31:12 <shachaf> gatlin: Which one?
11:31:19 <shachaf> ByteString is pretty straightforward.
11:31:29 <shachaf> Just remember: Bytes aren't the same thing as characters!
11:31:42 <merijn> gatlin: Tbh most people tend to not really use regex here
11:32:01 <gatlin> shachaf: Right, I'm that far. It's just that some blog posts I've found don't work ... so while ByteStrings are straightforward, things just don't work and :-/
11:32:16 <shachaf> gatlin: The ByteString documentation should be up to date. :-)
11:32:25 <shachaf> If you have specific questions you can probably mention them here.
11:32:39 <gatlin> shachaf: it's not bytestring I'm having the trouble with
11:32:53 <shachaf> Text.Regex.*?
11:33:25 <gatlin> it's using Text.Regex with ByteString, specifically. Every example I've found and followed just doesn't work. I suspect there have been some API changes recently
11:33:34 <gatlin> recently = 2009 or later
11:37:02 <schellsan> i'm trying to update an old (yesod 1.1.2) project to the newest yesod and am having lots of package problems, i'm guessing because of the project's cabal file...
11:45:08 <hpaste> o1iver pasted “type constraints” at http://hpaste.org/78299
11:46:06 <o1iver> hi. I am a bit confused about this example I just posted. By does the type constraint have to be explicitely stated with the function if it is already defined for the data type
11:46:09 <o1iver> ?
11:46:16 <o1iver> s/By/Why
11:46:35 <shachaf> o1iver: There's no such thing as defining a constraint for a data type.
11:46:49 <o1iver> ok for the data constructor then
11:46:55 <o1iver> (right?)
11:46:56 <shachaf> (This isn't quite true but it's close enough to true for now. :-) )
11:47:00 <monochrom> because the language definition says that "data Show s => ..." does not buy you that convenience
11:47:05 <typoclass> shachaf: i thought there is such a thing, but it's nearly useless ...?
11:47:05 <shachaf> data Class a => Foo a = ... is deprecated.
11:47:11 <shachaf> It's not in Haskell 2010.
11:47:20 <shachaf> It's not on by default in GHC. It doesn't do anything useful.
11:47:24 <o1iver> shachaf: ah! Is that so?
11:47:31 <shachaf> o1iver: Yep.
11:47:32 <o1iver> But it simplifies my typing...
11:47:47 <o1iver> But they are still used for type classes right?
11:47:59 <shachaf> Now, there *is* something do which will behave sort of like what you think you want.
11:48:07 <shachaf> But I claim what you think you want isn't actually what you want. :-)
11:48:11 <shachaf> o1iver; For type classes?
11:48:15 <o1iver> shachaf: well I don't want to do something that is not standard, rather fix my code then :-p
11:48:18 <monochrom> contrary to your expectation, the language definition says it will not save typing
11:49:46 <o1iver> shachaf: sry I was confused there
11:49:53 <o1iver> monochrom: ok...
11:50:43 <o1iver> monochrom: doesnt feel that way for me since I have to type it for every function that does something with my type instead of just enforcing it with the constructor
11:51:11 <monochrom> OK, have you read Haskell 98?
11:51:17 <o1iver> but in any case that means that I should not do data ( ) => any more..., right?
11:51:18 <shachaf> o1iver: You're not reading what monochrom says correctly.
11:51:32 <o1iver> monochrom: no :(
11:51:35 <shachaf> o1iver: The language definition says it will not save typing *because* the language definition requires a constraint on every function.
11:51:53 <o1iver> shachaf: ok I see :)
11:52:19 <o1iver> ok, well thanks for the info then!
11:52:42 <monochrom> Haskell 98 explicitly says, "data Show s => X s = Ctor [s]", all it does is make sure Ctor :: Show s => ...
11:52:56 <monochrom> "The context in the data declaration has no other effect whatsoever."
11:53:01 <o1iver> monochrom: ok I get it now :-D
11:53:27 <o1iver> i mean that if it had the effect I thought it would then that would save me typing...in any case thanks
11:54:00 <o1iver> *meant
12:06:13 <edwardk> @tell mzero the issue is it requires extensions transformers can't use, being haskell 98, and extensions that aren't currently in use in mtl.
12:06:13 <lambdabot> Consider it noted.
12:08:19 <bammm> what do some say programming in haskell is similar to programming math?
12:13:28 <tominator2> Does anyone know of a package for Haskell which handles Galois Fields?
12:13:43 <schellsan> i'm getting a funky cabal message trying to build my yesod project…anyone run into this?
12:13:43 <schellsan> cabal: At least the following dependencies are missing:
12:13:43 <schellsan> yesod-core >=1.1.2 && <1.2 && ==1.1.1.2
12:14:28 <Peaker> schellsan, ghc-pkg list yesod-core?
12:14:51 <dcoutts_> schellsan: so that constraint is impossible of course
12:15:05 <schellsan> yeah!
12:15:07 <dcoutts_> but instead of simplifying it to False, it shows the full constraint
12:15:22 <dcoutts_> so you have a chance to see where the bits of it came from
12:15:22 <schellsan> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
12:15:26 <schellsan>    yesod-core-1.1.0
12:15:27 <schellsan>    yesod-core-1.1.1.2
12:15:27 <schellsan>    yesod-core-1.1.6
12:15:40 <Peaker> schellsan, are you using --force-reinstalls frequently? :)
12:15:49 <schellsan> i just did
12:15:53 <neutrino> in the IO monad, if i have a >> b >> c >> d, can i do something in b to prevent c and d from executing?
12:16:09 <Peaker> neutrino, you could throw an IO exception
12:16:17 <schellsan> i haven't been able to find any info on updating a project to a new version of yesod...
12:16:18 <schellsan> :(
12:16:26 <neutrino> is it a good idea to do this, Peaker?
12:16:36 <schellsan> work is calling…brb
12:16:39 <Peaker> neutrino, I think it's a very reasonable idea in many circumstances
12:16:46 <neutrino> mhm
12:17:02 <neutrino> how does one work with IO exceptions?
12:18:07 <dcoutts_> neutrino: have you seen Control.Exception ?
12:18:13 <neutrino> no
12:18:18 <neutrino> is that an "IO exception"?
12:18:26 <notdan> neutrino: check out Control.Exception and throwIO
12:18:37 <neutrino> thanks, looking!
12:19:14 <notdan> you can use catch for catching the exceptions too 8)
12:20:15 <neutrino> i guess
12:20:18 <neutrino> let me try :)
12:36:25 <rwbarton> @type bitAt
12:36:26 <lambdabot> (Functor f, Bits b, Indexed Int k) => Int -> k (Bool -> f Bool) (b -> f b)
13:14:53 <hpaste> edwardk pasted “iso and projection in the same framework” at http://hpaste.org/78307
13:17:40 <edwardk> now to simplify that
13:18:44 <zhulikas> that looks simple enough already
13:19:24 <zhulikas> make things as simple as possible, but not any simplier!
13:19:39 <edwardk> well, it has the problem that i can't use an Iso as a Projection, which was the point of the exercise
13:19:51 <hpaste> MrWoohoo pasted “beginner troubles” at http://hpaste.org/78310
13:20:21 <MrWoohoo> could someone help me with this? should be a simple beginner level problem
13:20:32 <mauke> @hoogle deleteFindMax
13:20:32 <lambdabot> Data.IntMap deleteFindMax :: IntMap a -> (a, IntMap a)
13:20:32 <lambdabot> Data.IntSet deleteFindMax :: IntSet -> (Int, IntSet)
13:20:32 <lambdabot> Data.Map deleteFindMax :: Map k a -> ((k, a), Map k a)
13:20:42 <mauke> MrWoohoo: what is ST doing there?
13:20:48 * ocharles wonders what edwardk is working on
13:20:51 <Cale> MrWoohoo: deleteFindMax doesn't require or involve ST
13:20:57 <MrWoohoo> It was an inspired guess ;)
13:20:59 <Cale> MrWoohoo: So you can just use let
13:21:07 <mauke> ...
13:21:14 <monochrom> "as X as possible but not Xer" is redundant. "as X as possible" implies "Xer is impossible"
13:21:14 <edwardk> ocharles: trying to make it so you can compose Iso with Projection and get a Projection, etc.
13:21:16 <ocharles> are you tightening up projections? I think I remember you saying those were the part of lenses you were most unhappy with
13:21:22 <Cale> MrWoohoo: Or even not involve ST in any way...
13:21:24 <edwardk> ocharles: thats exactly what i'm working on
13:21:26 <MrWoohoo> I can use do though to avoid binding it to a new name each time, right?
13:21:27 <ocharles> rad!
13:21:33 <mauke> MrWoohoo: no
13:21:39 <edwardk> they've proven rather tricky =)
13:21:54 <danharaj> I can't read lens signatures anymore :9
13:22:03 <ocharles> i haven't yet wrapped my head around constraint kinds, so i won't pretend to understand this :)
13:22:19 <ocharles> that's a rather handsome collection of extensions though
13:22:19 <edwardk> danharaj: this is kind of the bleeding edge =P
13:22:23 <djahandarie> Could someone familiar with crypto stuff explain what the second paragraph of this answer is saying? http://crypto.stackexchange.com/questions/3946/using-sha-256-with-different-initial-hash-value Totally off-topic, just looking to pick someone's brain :P
13:22:28 <edwardk> and these 'll probably simplify before going in
13:22:31 <edwardk> since these don't work =P
13:22:37 <danharaj> :P
13:22:49 <Cale> MrWoohoo: do notation is used to glue together actions in some monad into more complex actions. You can't just use it anywhere.
13:23:31 <MrWoohoo> I was trying to use it like I saw do used to avoid the same problem generating random numbers
13:23:46 <MrWoohoo> ie naming all the new generators
13:23:57 <Cale> MrWoohoo: Well, what problem are you actually trying to solve here? How would you write the program you want to write without ST?
13:24:22 <Cale> Start by writing the program with all the things named, and then worry about how to factor out any repetitive structure in it.
13:24:27 <ocharles> https://gist.github.com/a73af03e30fbd2895868 any tips on how to avoid UndecidableInstances on line 3?
13:24:38 <MrWoohoo> LOL My objective is to write it in roughly 3-4 lines without extrainous tmp names :)
13:25:01 <edwardk> ocharles: by moving it into your cabal file? =)
13:25:08 <ocharles> edwardk: touche :)
13:25:08 <MrWoohoo> I thought ST was how I was supposed to thread the set ibject through the calls
13:25:36 <ocharles> I'm also not sure if I need to care, as Ref is only defined within this library
13:25:36 <Cale> MrWoohoo: My recommendation is just to write it the clumsy way first, so that you (and the people trying to help) can understand better what it is that you're trying to simplify. :)
13:25:51 <MrWoohoo> fair enough
13:25:55 <ocharles> but i hear enough badness about them to try and avoid them, or atleast understand how to avoid them...
13:26:00 <MrWoohoo> back in 5 :) er, 15-20
13:26:00 <Cale> MrWoohoo: Well, with ST you can have STRefs which are like mutable references to values.
13:26:22 <Cale> MrWoohoo: So, you could have an STRef s (Set a) which gets updated with new sets by various operations
13:26:30 <cygnet> djahandarie: that is quite fun
13:26:47 <Cale> MrWoohoo: But you're still going to have to name the reference
13:27:32 <Cale> MrWoohoo: You could use the State (Set a) monad in order to have actions which implicitly operate on a value of type (Set a)
13:27:32 <MrWoohoo> I'll try the long way first and then revisit those "using random numbers" sections of LYAH and RWH
13:27:40 <schellsan> so i guess now my next step is how to fix cabal package problems
13:27:56 <MrWoohoo> yes! I think that's what I'm trying to do LOL
13:28:51 <Cale> But yeah, *especially* in the case of State, writing it the long way will go a long way in understanding how (and whether) State will help you.
13:30:08 <Cale> If you find yourself writing a lot of functions which take an extra parameter and produce an extra result, and the extra result of the previous computation is always threaded into the corresponding parameter of the next one, that's the pattern that State captures.
13:31:16 <ciaranm> and if it goes into the previous one instead, it's reverse state!
13:32:35 <Cale> ciaranm: That tends to be rare, but yes :)
13:32:50 <ciaranm> and if it goes both forwards and backwards at the same time, it's a tardis!
13:32:58 <ciaranm> i'm still trying to find an excuse to use that
13:33:08 <danharaj> http://hpaste.org/78311
13:33:30 <danharaj> can someone help me determine whether this is garbage or not? :P
13:33:47 <danharaj> In particular which Monad-like thing is the 'right' Monad-like thing.
13:40:11 <hpaste> edwardk pasted “simplifying isos and projections” at http://hpaste.org/78312
13:43:01 <carmin> is there a simple way to debug my compiled code?
13:44:07 <EvanR> Debug.Trace
13:44:31 <EvanR> a simple way to debug compiled code is to debug the source code
13:45:27 <carmin> yeah i mean
13:45:35 <carmin> i wanted to check the steps it go thru
13:45:48 <carmin> when i run the code
13:45:51 <EvanR> the steps it goes through will be incomprehensible
13:46:17 <johnw> carmin: ghci has an interactive debugger
13:46:44 <tac> debugging is a weak-point of lazy evaluation, sadly :<
13:46:54 <johnw> you can watch the sequence of a particular evaluation there, if that evaluation is needed
13:47:11 <ciaranm> that's ok, the type system catches all bugs anyway
13:47:17 <johnw> and you can use :force in ghci to force it to normal form, to assist with debugging
13:47:18 <EvanR> hear hear
13:47:33 <carmin> :force?
13:47:36 <carmin> i'll try
13:47:57 <johnw> see :break, :force, :history and :step, in the ghci docs
13:48:36 <typoclass> carmin: it's not haskell's strongest area. i use a few rules of thumb (no 'head', no 'fromJust' ...), and Debug.Trace, and putting things on hpaste for asking #haskell
13:48:59 <ciaranm> the head is a lie
13:49:32 <tac> head IS a lie
13:49:37 <carmin> thanks johnw
13:49:43 <simpson> head's not a lie, just not total.
13:49:56 <monochrom> head is not a total lie
13:50:01 <tac> half truth, lie same thing.
13:50:06 <monochrom> fromMaybe is a total lie :)
13:51:24 <tdammers> defaultValueIfNothingElseJustTheValue would be more truthful, but apparently fromMaybe won
13:52:06 <tdammers> even though the former has a certain Sally-Albrightesque ring to it
13:52:08 <tac> @type fromMaybe
13:52:09 <lambdabot> a -> Maybe a -> a
13:52:29 <rants> I'd want a proper ide to avoid typing out long fuction names like that
13:54:04 <tdammers> the whole point of using something like Haskell is so you can build abstractions powerful enough to not need an IDE
13:55:17 <monochrom> or write names short enough :)
13:55:30 <gmaslov> tht wy ls mdns
13:55:50 <ciaranm> i feel there should be a form of Alternative where the thing on the right of <|> is outside of the functor
13:55:55 <ciaranm> someone should do that
13:57:09 <ion> Do you mean something like a <| b = a <$> pure b?
13:57:36 <ciaranm> naah, i want the result to be not in the functor
13:58:02 <simpson> ciaranm: What would that mean for e.g. lists as Alternatives?
13:58:10 <ciaranm> it wouldn't!
13:58:20 <ciaranm> or it would take the first item, or something
13:58:29 <simpson> Maybe couldn't do this either. Nor could Either. I don't think most Functors could do this.
13:58:59 <ciaranm> i never claimed that it was a coherent idea. merely that it should exist!
13:59:25 <ion> Whoops, i meant <|>, not <$>
14:01:24 <jmcarthur> ciaranm: sure, it makes sense for incoherent things to exist, of course ;)
14:01:38 <ciaranm> look at #php!
14:01:42 <ciaranm> it exists
14:11:51 <ramses_> > let g a b c = a > b && c > b
14:11:52 <lambdabot>   not an expression: `let g a b c = a > b && c > b'
14:13:31 <deus_rex> array_map("htmlentities", array("#haskell <3 php"))
14:13:31 <deus_rex> :(
14:13:59 <monochrom> wrong channel?
14:14:35 <deus_rex> lamenting my day job
14:19:43 <ramses_> @pl not . any (uncurry (attacks p)) . zip [1..]
14:19:43 <lambdabot> not . any (uncurry (attacks p)) . zip [1..]
14:19:59 <ramses_> @pl (\p -> not . any (uncurry (attacks p)) . zip [1..])
14:19:59 <lambdabot> (not .) . (. zip [1..]) . any . uncurry . attacks
14:20:56 <jmcarthur> @pl \f g -> (f .) . (. g)
14:20:56 <lambdabot> (. flip (.)) . (.) . (.)
14:20:58 <raek> what is the recommended way to use the alex lexer genrator from cabal?
14:21:05 <johnw> cabal install alex
14:21:16 <johnw> oh, USE it
14:21:29 <raek> yeah :)
14:22:16 <johnw> what do you mean by 'recommended' then?
14:23:37 <sheerun> Do you know online haskell worksheet? (like Scala's Eclipse worksheet?)
14:23:53 <EvanR> cheatsheet?
14:24:15 <sheerun> No, something like multiline repo
14:24:18 <sheerun> repl*
14:24:40 <raek> johnw: adding "Build-tools: alex, happy" to my .cabal file seems to work, but I haven't found this in the official docs
14:24:43 * jmcarthur has no idea what a "worksheet" or "multiline repo" means
14:25:06 <donri> scratchpad maybe?
14:25:08 <sheerun> https://github.com/scala-ide/scala-worksheet/
14:25:14 <jmcarthur> sheerun: oh you mean a repl that allows you to enter expressions longer than one line at a time?
14:25:17 <sheerun> https://www.google.pl/search?q=scala+worksheet&hl=en&tbo=d&source=lnms&tbm=isch&sa=X&ei=JuyzUOD1EciXhQf2kIHICg&ved=0CAcQ_AUoAA&biw=1865&bih=986
14:25:32 <sheerun> jmcarthur: yes
14:25:32 <jmcarthur> i just use a file and ghci, personally
14:25:35 <typoclass> sheerun: i guess most people would use a file and do runghc on it. it's not much overhead, you basically just add "main = do" and "print result"
14:25:41 <jmcarthur> emacs makes this pretty convenient, normally
14:25:46 <raek> also, what are the rules regarding module names and "main"?
14:25:49 <jmcarthur> i don't even use main for that
14:25:51 <sheerun> I don't fancy emacs ;)
14:26:15 <jmcarthur> you don't have to. just ghci works fine as well
14:26:16 <sheerun> Vim, if something
14:26:49 <raek> it seems like ghc only accepts my main module if it's called "Main"
14:26:52 <jmcarthur> (but to be honest, i do kind of wish i could enter multiline expressions directly into ghci sometimes)
14:26:55 <sheerun> In ghci I can't declare functions on fly
14:26:57 <monochrom> alex is an exe-only package. you don't usually build-depends on it
14:27:02 <sheerun> I have to use editor and :load
14:27:04 <jmcarthur> raek: yeah, but the file name doesn't have to be Main.hs, at least
14:27:15 <jmcarthur> sheerun: yes you can
14:27:21 <johnw> sheerun: let f x = x + 1
14:27:24 <jmcarthur> sheerun: you can just say   "let foo x = x + 1"
14:27:24 <typoclass> sheerun: yes, but if you have done that once, you can just do ":r" for reload
14:27:28 <sheerun> that's hack
14:27:36 <jmcarthur> it's not a hack
14:27:46 <johnw> sheerun: so, what you meant is that you CAN, it's just not nu-hackish enough for you
14:27:48 <jmcarthur> you just can't do multiline functions, which stinks, but isn't a hack
14:28:20 <sheerun> jmcarthur: exactly. that's why I'm searching for such worksheet
14:28:31 <jmcarthur> files are pretty decent worksheets
14:28:36 <xaimus> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/interactive-evaluation.html
14:28:39 <xaimus> "2.4.3. Multiline input"
14:28:57 <jmcarthur> sorcery!
14:29:00 <monochrom> we have no worksheet
14:29:08 <sheerun> http://www.lighttable.com/ for haskell would be perfect
14:29:20 <sheerun> Even it's on online tool
14:31:20 <sheerun> *not
14:31:32 <Nafai> sheerun: http://fpcomplete.com/designing-the-haskell-ide/
14:32:13 <ciaranm> unix is an ide
14:32:36 <sheerun> ciaranm: screw you ;)
14:34:40 <typoclass> sheerun: honestly, i'd try a simple file. you could define a shortcut in your editor to do "runghc current-file-name.hs"
14:35:28 <sheerun> typoclass: Yeah, that's somewhat good solution too
14:35:47 <sheerun> I was just curious if there's something more advanced
14:38:10 * hackagebot time-compat 0.1.0 - Compatibility with old-time for the time package  http://hackage.haskell.org/package/time-compat-0.1.0 (DagOdenhall)
14:38:21 <tdammers> 30+ years of UI evolution... doesn't get any more advanced than that :P
14:43:10 * hackagebot time-compat 0.1.0.1 - Compatibility with old-time for the time package  http://hackage.haskell.org/package/time-compat-0.1.0.1 (DagOdenhall)
14:46:13 <hpaste> MrWoohoo pasted “Help me clean this ugly function up” at http://hpaste.org/78315
14:46:58 <MrWoohoo> Shouldn't I be able to use the state monad to clean this up?
14:47:07 <MrWoohoo> I can't figure out the types
14:48:14 <niteria> can I jump to next error in ghcmod (vim) ?
14:48:24 <niteria> :cn doesn't seem to work
14:48:54 <Sintendo> how do you declare infix operators?
14:49:34 <typoclass> MrWoohoo: could you also paste the definition of deleteFindMax? the code is a little hard to figure out without it
14:49:56 <MrWoohoo> sorry, it's from data.set
14:50:26 <typoclass> MrWoohoo: ooh i see :)
14:51:09 <MrWoohoo> this is driving me nuts.
14:51:17 <Cale> okay
14:52:00 <Cale> MrWoohoo: so, yeah, you could...
14:53:14 <MrWoohoo> I could?
14:53:52 <typoclass> Sintendo: you can either do "x +++ y = ..." or "(+++) x y = ...". i prefer the latter, i find it clearer because it's exactly like "foo x y = ..."
14:54:26 <Cale> MrWoohoo: Something like  runState (do max1 <- state deleteFindMax; max2 <- state deleteFindMax; modify (insert (max1 - max2)))
14:55:06 <Sintendo> typoclass: am i right to assume you can only do this for functions related to a class?
14:55:25 <Sintendo> or can you do that for any function?
14:55:30 <Cale> Sintendo: Do what?
14:55:56 <Cale> Sintendo: You can define infix functions anywhere. They need not be related to a class.
14:56:20 <Sintendo> Really? I could have sworn I tried it at some point...
14:56:49 <Cale> > let x %$# y = x^2 + y^2 - x - y + 1 in 5 %$# 8
14:56:50 <lambdabot>   77
14:57:39 <ciaranm> > let x ☃ y = x + y in 2 ☃ 3
14:57:39 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:57:43 <ciaranm> awwww
14:57:58 <Cale> That would be valid if unicode worked in lambdabot
14:58:11 * hackagebot usb 1.2 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.2 (BasVanDijk)
14:58:13 * hackagebot usb-iteratee 0.5 - Iteratee enumerators for the usb package  http://hackage.haskell.org/package/usb-iteratee-0.5 (BasVanDijk)
14:58:13 <MrWoohoo> thanks afk
14:58:23 <ciaranm> i always wanted snowman to be an identifier rathe rthan a symbol
14:58:50 <Sintendo> I just tried this: (test) a b = a + b
14:59:03 <Sintendo> 1 test 2 fails for some reason?
14:59:06 <Cale> test is not a string of symbol characters
14:59:19 <hpc> @let (☃) = (+)
14:59:22 <lambdabot>  Defined.
14:59:23 <Cale> If you want to write it infix, you'll have to enclose it in backticks
14:59:32 <hpc> @let .. = 5
14:59:32 <lambdabot>   Parse error: ..
14:59:34 <hpc> :(
14:59:35 <Cale> > let a `test` b = a + b in 5 `test` 9
14:59:37 <lambdabot>   14
14:59:50 <hpc> sometimes i hate putty
14:59:52 <hpc> U+1F3C2 (f0 9f 8f 82): SNOWBOARDER [..]
15:00:02 <Sintendo> Oh, so there is no way to declare a function as being infix, allowing you to leave out the `?
15:00:21 <ciaranm> make its name out of symbols
15:00:52 <Sintendo> That works
15:01:05 <Sintendo> Is there a list of symbols somewhere?
15:01:14 <ciaranm> the unicode standard
15:01:27 <typoclass> Sintendo: nope, that isn't possible. if it's letters, it's prefix, unless you surround it with ` at the call site. if it's symbols, it's infix, unless you surround it with () at the call site
15:01:32 <ciaranm> you have a few thousand to choose from
15:01:48 <typoclass> > generalCategory '/' -- Sintendo, i use Data.Char.generalCategory
15:01:50 <lambdabot>   OtherPunctuation
15:01:56 <ciaranm> probably more now that ELVISH SLIGHTLY SURPRISED SENTENCE PREFIX is in there
15:02:44 <Sintendo> alright, thanks everyone
15:03:31 <hpaste> test pasted “sum” at http://hpaste.org/78316
15:04:48 <johnw> i'd call that add before i'd call it sum
15:05:23 <johnw> you don't really see Σ in math being applied to just two numbers
15:05:30 <kirindave> Is there a "right" way to reset your ghc packages when you bone up a yesod install?
15:05:44 <johnw> "reset"?
15:05:55 <kirindave> johnw: I guess I need to start from scratch.
15:06:06 <johnw> i don't understand your question
15:06:07 <kirindave> Because it's not really possible to disentangle what cabal cheerfully did to itself.
15:06:17 <johnw> ah, that's why I use cabal-dev
15:06:20 <johnw> makes local resets easy
15:06:35 <kirindave> Yeah well it also doesn't work reliably enough for me to tolerate.
15:06:38 <hpc> you can blow away your .ghc
15:06:47 <hpc> assuming you installed to ~
15:06:48 <monochrom> look under $HOME/.ghc , identify the subdirectory to erase
15:07:04 <sm> kirindave: https://gist.github.com/1185421
15:07:07 <kirindave> Those are just the .conf files.
15:07:18 <kirindave> Ahh perfect, sm. Thanks!
15:07:41 <glguy> edwardk: You around?
15:07:45 <edwardk> yeha
15:07:50 <glguy> sweet, can I PM you?
15:07:51 <monochrom> it is precisely the .conf files you want to erase. and the cache file.
15:07:54 <edwardk> sure
15:08:04 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
15:08:50 <kirindave> monochrom: Cute title.
15:08:52 <sm> a robust cleaner built in ghc-pkg/cabal would be good
15:09:35 <dcoutts_> having broken packages installed isn't itself a problem
15:09:45 <dcoutts_> cabal's solver ignores them
15:10:08 <monochrom> ghc doesn't ignore all of them
15:12:01 <kirindave> sm: Being able to get to the part where I can recompile the universe is nice. :)
15:13:11 * hackagebot ls-usb 0.1.0.13 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.0.13 (RoelVanDijk)
15:14:42 <kqr> something strange has happened. i have struggled with the io monad (in particular, monads in general) for quite a while. i just realised I use them fluently now
15:14:45 <kqr> i have no idea what happened
15:14:54 <kqr> there was no flash insight like with lisp macros
15:14:58 <kqr> suddenly, there were just... there
15:15:02 <brunonery> howdy - is there a way to apply a set of functions to a list and get a list of sets?
15:15:17 <lispy> kqr: you've learned to program the semicolon?
15:15:45 <brunonery> like a map :: (A -> B, A -> C, A -> D, …) -> [A] -> [(B, C, D)]
15:18:12 * hackagebot weather-api 0.4.1 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.4.1 (PeterGoncharov)
15:19:12 <ParahSail1n> is there a cool way to write fromIntegral a / fromIntegral b
15:19:55 <kqr> brunonery, as (a, b, c) is a different tuple from (a, b, c, d) there exists no general function like the one you ask
15:20:07 <kqr> brunonery, it would be easy to write one for the particular tuple you need, though
15:20:20 <kqr> brunonery, if you need it for an n-tuple, i would suggest a list of functions instead
15:20:33 <brunonery> but wouldn't the list of functions need to have all the same result type?
15:20:44 <brunonery> kqr
15:20:44 <kqr> true
15:20:48 <kqr> yes
15:20:55 <brunonery> what about template haskell?
15:22:06 <kqr> then you're going way over my head and will have to hope someone else knows
15:22:55 <brunonery> hahaha ok
15:22:57 <Nevor> hello
15:23:05 <brunonery> thanks, kqr
15:23:22 <`nand`> :t (<*>) `asAppliedTo` (undefined :: [Int -> Int])
15:23:23 <lambdabot> [Int -> Int] -> [Int] -> [Int]
15:23:37 <`nand`> brunonery ^ the closest you'll get without involving tuples
15:23:59 <Nevor> I'm running into a problem while updating from cabal 0.14 to cabal 0.16, I always get "setup: Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with
15:23:59 <Nevor> Cabal."  this variable is _not_ set.
15:24:31 <kqr> ParahSail1n, the only thing that comes to mind would be something like a `fdiv` b = fromIntegral a / fromIntegral b
15:24:39 <kqr> ParahSail1n, a quick search on hoogle doesn't turn up anything useful either
15:26:41 <brunonery> interesting: asAppliedTo?
15:26:53 <`nand`> :t asAppliedTo
15:26:55 <lambdabot> (t -> b) -> t -> t -> b
15:27:11 <`nand`> :t id `asAppliedTo` 3
15:27:12 <lambdabot> Num b => b -> b
15:27:36 <alang_> ParahSail1n: you can do fromRational (a % b)
15:27:45 <brunonery> where is asAppliedTo from, `hand`?
15:27:52 <brunonery> `nand`
15:27:59 <`nand`> L.hs, presumably
15:28:04 <monochrom> Nevor: I tried a few days ago. I didn't get that error. In fact I tried both. If I set GHC_PACKAGE_PATH, sure. If I unset it, no error.
15:28:20 <`nand`> (that's lambdabot's own little prelude)
15:28:31 <brunonery> thanks, `nand` - I'll explore it a little bit - I might be able to cook something from it
15:28:32 <hpaste> tomeo pasted “Trying to create infinte list but am not getting a list at all” at http://hpaste.org/78319
15:28:46 <tomeo_> Could someone please have a look at that?
15:28:46 <monochrom> however, be sure you have a strong reason to "update" before you "update"
15:28:47 <`nand`> you won't need asAppliedTo in your code
15:29:02 <tomeo_> Im getting stack overflow
15:29:26 <brunonery> I wanted to look at the implementation, `hand`
15:29:34 <brunonery> `nand` -- damned autocorrect
15:29:44 <`nand`> @src asAppliedto
15:29:44 <lambdabot> Source not found.
15:29:46 <`nand`> @src asAppliedTo
15:29:46 <lambdabot> Source not found. Do you think like you type?
15:30:00 <brunonery> I can't find it on Hoogle :P
15:30:02 <`nand`> asAppliedTo f x = let _ = f x in f
15:30:04 <`nand`> something like that
15:30:22 <`nand`> or just: asAppliedTo = const; with the right type signature
15:31:56 <Nevor> monochrom, I have unseted it (event though it was already absent) but the error remains, anyway, I'm trying some workaround
15:33:13 * hackagebot HLearn-distributions 0.0.1.3 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.0.1.3 (MikeIzbicki)
15:40:08 <kirindave> Oh no.
15:40:24 <kirindave> lens and free disagree.
15:40:33 <kirindave> Err, I mean yesod and free.
15:40:37 <kirindave> And also this is the wrong window.
15:40:40 <kirindave> Fantastic.
15:43:03 <Lutin`> +1 kirindave
15:43:23 <Lutin`> Or -1 whichever you feel you deserve more, haha
15:43:32 <kirindave> Lutin`: Don't blame me my entire world is collapsing. :(
15:43:37 <kirindave> Not sure what to do about this.
15:43:56 <kirindave> I guess I can just rip apart my code's dependence on free. I don't strictly need it.
15:43:57 <monochrom> perhaps try older versions
15:44:11 <kirindave> monochrom: Yeah
15:44:23 <edwardk> hah
15:44:26 <Lutin`> kirindave: How do they disagree?
15:44:28 <kirindave> I need to figure out what the common factor is. I think it's rts.
15:44:41 <edwardk> kirindave what is the disagreement with free?
15:45:20 <edwardk> kirindave: module dependencies?
15:45:29 <kirindave> yeah
15:45:33 <edwardk> if free's dependencies are out of date, let me know
15:45:49 <kirindave> Yeah I'm trying to get exactly what the disagreement is.
15:46:17 <edwardk> free is pretty liberal ;)
15:46:24 <kirindave> yeah
15:46:43 <edwardk> i think it may be that you installed free first and it picked newer stuff than yesod will work with?
15:46:56 <kirindave> In this instance I did it the other way around but
15:47:00 <edwardk> hrmm
15:47:08 <kirindave> It may just be that I forgot to clean once and something flipped out.
15:47:17 <kirindave> because suddenly it's not giving me the broken package error.
15:47:29 <edwardk> hah, well, thats good i guess ;)
15:48:27 <edwardk> let me know if you find an actual problem with free.
15:48:27 <kirindave> It is a better scenario than having those two packages disagree, I agree.
15:52:59 <monochrom> I don't think free and yesod have conflicts. they only have semigroups in common, and they are both happy with 0.8.4.1, which is current
15:54:00 <bgamari> kirindave, highlight-versions is really nice here
15:54:19 <bgamari> kirindave, although ultimately I always end up just looking at the cabal install -v3 output when there's a conflict
16:01:51 <tomeo_> Could someone please have a look at why Im getting stack overflow here? (Trying to create infinite list)
16:01:52 <tomeo_> http://hpaste.org/78319
16:05:29 <monochrom> I am not even convinced that the program should terminate
16:06:42 <djahandarie> You're not always possible to convince that a program should terminate.
16:07:33 <geekosaur> every case in that program reinvokes f24 immediately.  where does it bottom out?
16:08:14 * hackagebot hsc3-graphs 0.12 - Haskell SuperCollider Graphs  http://hackage.haskell.org/package/hsc3-graphs-0.12 (RohanDrape)
16:08:35 <geekosaur> s/in that program/in f24/
16:09:56 <tomeo_> geekosaur: Im trying to create an infinite list, why would I need to bottom it out? I may just be misunderstanding you
16:10:40 <geekosaur> let's put it this way.  your infinite list, to do something other than spin forever, must at some point produce *some* elements
16:10:53 <geekosaur> it never does so.  it *immediately* reinvokes itself in all three branches
16:11:17 <hpaste> tomeo pasted “Bottoming out” at http://hpaste.org/78322
16:11:27 <tomeo_> geekosaur: you mean like that kind of?
16:11:52 <geekosaur> let me rephrase:  nno matter what youy pass f24, the *first* thing it does is call itself
16:12:02 <clahey> tomeo_: That looks like it should generate some content, yeah.
16:12:02 <lambdabot> clahey: You have 1 new message. '/msg lambdabot @messages' to read it.
16:12:06 <hpc> tomeo_: "the top of your syntax tree is always f24"
16:12:35 <geekosaur> to calculate f24 fo any value, you first must calculate f24 of some other value
16:12:40 <tomeo_> clahey: if I run test test [1,0,0,1] I get [0,0,0,1,0*** Exception: test.hs:(1,1)-(4,48): Non-exhaustive patterns in function test
16:13:18 <geekosaur> there is no branch of f24 that starts by returning some elements before reinvoking itself to generate more
16:13:33 <tomeo_> geekosaur: check my second paste, I tried to fix it there
16:13:41 <tomeo_> http://hpaste.org/78322
16:13:44 <geekosaur> so anything requesting a value from f24 will immediately get stuck in abottomless f24 (f24 (f24 (f24 (........
16:13:48 <clahey> tomeo_: Yes, your function creates an infinite list from an infinite list.
16:14:03 <clahey> tomeo_: If you give it a non infinite list, it errors out when it tries to get the next set of elements.
16:14:14 <clahey> tomeo_: What is test []  ?
16:14:28 <tomeo_> clahey: that will never happen as I see it
16:14:39 <tomeo_> Im only adding elements, not removing
16:14:53 <clahey> tomeo_: What do you mean removing?
16:14:53 <geekosaur> for the most recent paste, test [] is cycle [0,0,0,1,0]
16:15:04 <clahey> geekosaur: How so?
16:15:36 <clahey> tomeo_: You've defined a function that takes a list.
16:15:40 <geekosaur> (cycle joins a list to itself to make it infinite:  cycle [0,0,0,1,0] is [0,0,0,1,0,0,0,0,1,0,0,0,0,1,0...]
16:15:48 <tomeo_> geekosaur: after two [0,0,0,1,0] I would have an instance of 0,0,0,0 and go in to my second guard, or wont I?
16:16:21 <clahey> tomeo_: So, imagine a function:
16:16:44 <clahey> > let double x:xs = (2 * x): double xs in double [2, 3, 5, 10]
16:16:45 <lambdabot>   <local>:1:69:
16:16:46 <lambdabot>      Couldn't match type `t' with `v1'
16:16:46 <lambdabot>        `t' is a rigid ...
16:16:51 <pauser> how can i redirect the output of show to a file in ghci. do you maybe know that ?
16:16:58 <geekosaur> hm, right, first iteration should go into the top.  0,0,0,1,0,0,0,0,0,1, then we hit test [] again so start over.  cycle [0,0,0,1,0,0,0,0,0,1]
16:17:19 <clahey> geekosaur: The pattern he has there requires elements.
16:17:27 <kennyd> there is no test []
16:17:33 <clahey> geekosaur: The pattern match happens before the guards happen.  It never reaches the otherwise.
16:17:38 <geekosaur> mmm, right
16:17:52 <clahey> > let double x:xs = (2 * x):(double xs) in double [2, 3, 5, 10]
16:17:53 <lambdabot>   <local>:1:69:
16:17:53 <lambdabot>      Couldn't match type `t' with `v1'
16:17:53 <lambdabot>        `t' is a rigid ...
16:18:04 <geekosaur> I don't know why I'm reading that as a pattern match, aside form that's what a pattern match on numbers trns into
16:18:09 <geekosaur> durr
16:18:42 <clahey> tomeo_: So, I think you somehow think that the result from the first return value of test gets passed into the next iteration of test.
16:18:44 <clahey> But it doesn't.
16:18:45 <geekosaur> so yeh, test [] = exception because no *pattern* matches; the guards dont count
16:19:04 <tomeo_> clahey: thats exactly what I think :)
16:19:16 <tomeo_> now it all makes sense
16:19:19 <clahey> When you pattern match against a:b:c:d:rest, rest becomes the part of the input that you didn't process yet.  Not some part of the output.
16:19:56 <tomeo_> Will I not be able to do what I'm trying to do or am I just doing it the wrong way?
16:21:02 <clahey> tomeo_: In order to understand what you're trying to do, tell me this.
16:21:07 <lispy> > foldr (+) 0 [1..3]
16:21:08 <lambdabot>   <local>:1:69:
16:21:08 <lambdabot>      Couldn't match type `t' with `v1'
16:21:08 <lambdabot>        `t' is a rigid ...
16:21:14 <lispy> Cale: ??
16:21:41 <clahey> What should test [1, 0, 0, 1] be?
16:21:56 <lispy> > foldr (+) 0 [1..3] :: Int
16:21:57 <lambdabot>   <local>:1:69:
16:21:57 <lambdabot>      Couldn't match type `t' with `v1'
16:21:57 <lambdabot>        `t' is a rigid ...
16:23:09 <clahey> The first time through it would fail both matches and give 0, 0, 0, 1, 0, right?
16:23:11 <clahey> What next?
16:23:42 <geekosaur> currently it gives those and then tries to append the result of test []
16:23:56 <geekosaur> test [] has no value; there is no case for a list with fewer than 4 elements
16:24:00 <tomeo_> clahey: yes
16:24:22 <tomeo_> geekosaur: yep
16:24:24 <clahey> tomeo_: Okay, so what should the next match be against?
16:24:35 <clahey> 0, 0, 1, 0?
16:24:47 <clahey> (That being the last 3 digits of the original and the first digit of the result?
16:24:49 <clahey> )
16:24:53 <clahey> Or what?
16:25:45 <tomeo_> clahey: 0,0,0,1
16:26:12 <clahey> The first four digits of the response.
16:26:21 <tomeo_> yes
16:26:32 <geekosaur> ok, that actually should work with a take 5 of the list so the rest shouldn't be requested, I think.  hm, I'm getting fuzzy :(
16:27:01 <clahey> So, now we have 0, 0, 0, 1, 0, 0, 0, 0, 0, 1 as the result ([0, 0, 0, 1, 0] ++ [0, 0, 0, 0, 1])
16:27:06 <clahey> Is that correct?
16:27:27 <clahey> And what should the next check be against?
16:28:01 <tomeo_> I always want to look at the last 4 digits created
16:28:24 <tomeo_> sorry, 5
16:28:53 <tomeo_> well, the guard is on 4
16:29:24 <hpaste> tomeo annotated “Bottoming out” with “Bottoming out (annotation)” at http://hpaste.org/78322#a78325
16:29:34 <tomeo_> made it a bit easier to read
16:35:10 <clahey> tomeo_: So, you want to look at the first 4 digits of the last set of 5.
16:35:40 <tomeo_> clahey: yes
16:36:08 <clahey> tomeo_: I would try rewriting your function to just do the function from one set of digits to the next and using things like concat and iterate instead of doing your own recursion.
16:36:24 <tomeo_> clahey: Ill have a go, thanks
16:36:51 <MrWoohoo> where does the standard State monad live? Control.Monad.State doesn't seem to be it
16:37:16 <hpc> MrWoohoo: "standard"?
16:37:18 <geekosaur> it's not really standard any more
16:37:19 <hpc> @src State
16:37:19 <lambdabot> Source not found. The more you drive -- the dumber you get.
16:37:40 <MrWoohoo> What is the new standard?
16:37:49 <geekosaur> State was a separate monad in mtl1.x; mtl2 has only the transformer versions and "state" builds a StateT s Identity
16:37:53 <hpc> Control.Monad.State has it as a type alias
16:38:21 <geekosaur> there is a type alias but it can't be used in quite the same way
16:38:40 <MrWoohoo> What import statement should I be using?
16:38:52 <MrWoohoo> to get state and modify etc
16:39:04 <hpc> you shouldn't be using the State data constructor anyway, so the internals of State should make no difference
16:39:14 <hpc> :t get
16:39:15 <lambdabot> MonadState s m => m s
16:39:16 <hpc> :t put
16:39:17 <lambdabot> MonadState s m => s -> m ()
16:39:19 <hpc> :t modify
16:39:20 <MrWoohoo> "state" not "State"
16:39:20 <geekosaur> hopefully...
16:39:20 <simpson> :t state
16:39:20 <lambdabot> MonadState s m => (s -> s) -> m ()
16:39:21 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:39:28 <hpc> etc, all in Control.Monad.State
16:39:56 <geekosaur> note that if you look at the documentation for Control.Monad.State it will show up as just re-exporting Control.Monad.State.Lazy
16:40:32 <MrWoohoo> That is confusing me.. is .Lazy the section of documentation I should be looking at?
16:40:51 <geekosaur> http://lambda.haskell.org/platform/doc/current/packages/mtl-2.1.2/doc/html/Control-Monad-State.html
16:41:09 <geekosaur> the documentation says:  module Control.Monad.State.Lazy (with a link to same)
16:41:29 <geekosaur> if you follow that link you get the documentation
16:42:41 <MrWoohoo> Could not find module `Control.Monad.State.Lazy'
16:42:41 <MrWoohoo>     Perhaps you meant Control.Monad.ST.Lazy (from base)
16:42:47 <MrWoohoo> complier hates me
16:43:16 * hackagebot hosc-utils 0.12 - Haskell Open Sound Control Utilities  http://hackage.haskell.org/package/hosc-utils-0.12 (RohanDrape)
16:44:41 <Peaker> MrWoohoo, maybe Control.Monad.Trans.State.Lazy ?
16:52:05 <geekosaur> hm.  what version of ghc is this?
16:52:40 <geekosaur> this does sound like the mtl library is missing
16:52:46 <geekosaur> (ST is indeed in base, not mtl)
17:05:23 <monochrom> @hoogle Control.Monad.State.Lazy
17:05:23 <lambdabot> Control.Monad.State.Lazy module Control.Monad.State.Lazy
17:05:23 <lambdabot> package lazyarray
17:05:23 <lambdabot> package lazyio
17:06:35 <monochrom> the package name is mtl
17:10:05 <clahey> tomeo_: Any progress?
17:10:22 <tomeo_> clahey: think Ill have to make it two functions
17:10:27 <tomeo_> clahey: but have to go to bed :)
17:10:32 <tomeo_> clahey: thanks for your help
17:10:33 <clahey> tomeo_: Is this for homework?
17:11:09 <tomeo_> clahey: well not exactly homework, but I am taking a class in functional programming
17:11:22 <tomeo_> clahey: why you ask?
17:13:19 <rxqkx> hello
17:14:55 <rxqkx> is it possible to use a mix of record and non-record syntax for members of a 'data' declaration ?
17:15:26 <geekosaur> no
17:20:18 <rxqkx> what does it mean to have a member where a field is the constructor name? i.e. "data D = A A | B Word8"
17:20:35 <rxqkx> how would you describe 'A' ?
17:21:06 <rxqkx> 'B' would just contain a Word8, but 'A' ?...
17:21:12 <Kaidelong> A in that context is unrelated to the A in front of it
17:21:22 <Kaidelong> the A in front of a value and the A after it is a type
17:21:44 <Kaidelong> they just happen to have the same name
17:23:12 <rxqkx> hmm... I was getting a "Multiple declarations of `B'" (and same error for A) when I tried to do "data B ... record syntax" "data A ... record syntax" and then "data C = A A | B B"
17:23:38 <rxqkx> if they are different, why is it considered a redeclaration?
17:23:49 <Kaidelong> well you either defined the type or the constructor twice, probably the constructor
17:24:12 <Kaidelong> how do you construct a value of type A?
17:26:22 <sipa> Kaidelong: depends on how type A is defined
17:26:32 <rxqkx> this is what I am trying to do
17:26:35 <rxqkx> http://hpaste.org/78332
17:26:50 <Kaidelong> well there you go
17:27:01 <rxqkx> I want to make a union of data's that are declared with record syntax
17:27:01 <Kaidelong> you define the constructors A and B twice
17:27:13 <Kaidelong> you have an A : Word8 -> A
17:27:17 <sipa> rxqkx: but type A and C have a constructor called A
17:27:18 <Kaidelong> and an A : A -> C
17:27:33 <byorgey> johnw: any chance which lectures could be video taped?
17:28:28 <rxqkx> are you saying I can't have the same constructor name across two data's ?
17:28:33 <sipa> indeed
17:28:52 <rxqkx> oh
17:29:12 <sipa> a constructor is a value like any other
17:29:33 <byorgey> johnw: if you mean the lectures for the class I'm currently teaching, no, because (1) it would be a lot of work to set up, (2) they are not very video-tape-able, and (3) there are only two lectures remaining
17:29:36 <sipa> and every value can only have one definition
17:30:06 <clahey> tomeo_: If it wasn't for a class, I wouldn't give you the final answer.
17:30:07 <rxqkx> so is it considered poor to do what I am trying to do (a data composed of other data's that are record-syntax) ?
17:30:11 <clahey> If it was for a class, I mean.
17:30:13 <byorgey> johnw: if you mean for the intro Haskell course I will teach in the spring, it's a possibility I suppose.  I will look into it.
17:30:29 <rxqkx> instead of just defining them all in one data...
17:30:57 <byorgey> some of the classrooms have the capability to record lectures... though I doubt I will be assigned one
17:31:00 <geekosaur> rxqkx, it's reasonable, although perhaps not the best way to do things in some cases.  you just can't use the same names.  (data C = CA A | CB B)
17:31:47 <Kaidelong> rxqkx: I'd need to know more about the application to say if there is a better way
17:32:02 <geekosaur> ^^
17:32:02 <Kaidelong> you might want a single record with some Maybe or Either values, for example
17:33:16 <Kaidelong> if the two are exactly the same and you just want type errors when they're mismatched, you could declare two newtypes and just cast back to the original type where appropriate
17:37:39 <fengshaun> is there a way to use a function (a -> b) in a >>= statement without using a custom lambda like (\x -> return $ f x) every time?
17:38:11 <fengshaun> I'm looking for something that does f :: Monad m => (a -> b) -> (a -> m b)
17:38:32 <fengshaun> :t fmap
17:38:33 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:39:18 <mauke> :t (.) return
17:39:19 <lambdabot> (Monad m, Functor f) => f a -> f (m a)
17:39:36 <mauke> :t (Prelude..) return
17:39:37 <lambdabot> Monad m => (a -> b) -> a -> m b
17:39:59 <mauke> fengshaun: why do you need >>=?
17:40:13 <fengshaun> I'm transforming a Monad with normal functions
17:40:20 <fengshaun> if that's the right vocabulary
17:40:49 <fengshaun> I have many functions of (a -> b) and I have a Monad.  I use >>= for consistency, mostly.
17:41:38 <mauke> well, stop doing that then
17:41:59 <mgsloan> sure, that's fine vocabulary.  (f >>= return . g)  ought to be the same thing as  (g <$> f)
17:42:12 <mgsloan> (equivalently, fmap g f)
17:42:15 <fengshaun> mauke: thanks, return . f works fine
17:42:47 <fengshaun> mgsloan: so, I can just chain <$>?
17:43:00 <mauke> or fmap, or liftM
17:43:09 <mauke> or liftA
17:43:21 <mgsloan> fengshaun: yup!
17:43:54 <fengshaun> I have something like this: getStdGen >>= return . randomRs (1, 10) >>= return . take 10
17:44:08 <fengshaun> how is the "right" way to write this?
17:44:13 <latro`a> none of that even needs to be monadic :)
17:44:15 <fengshaun> (conventionally right)
17:44:20 <fengshaun> :(
17:44:28 <latro`a> fmap (take 10 . randomRs (1,10)) getStdGen
17:44:44 <fengshaun> oh
17:44:48 <latro`a> by "doesn't need to be monadic" I mean that you don't need the power of >>=, since you are always using return
17:44:54 <fengshaun> :t fmap
17:44:56 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:45:05 <fengshaun> latro`a: fair enough
17:45:07 <fengshaun> thanks
17:45:12 <fengshaun> :t (<$>)
17:45:13 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:45:14 <latro`a> take 10 . randomRs (1,10) <$> getStdGen
17:45:16 <latro`a> is the same exact thing
17:45:22 <latro`a> just infix
17:45:25 <fengshaun> hmmm cool, thanks!
17:45:31 <latro`a> (pretty sure the fixity works out correctly)
17:45:41 <latro`a> :i <$>
17:45:44 <latro`a> damn
17:45:46 <aristid> fengshaun: <$> is typically just used to make formulas more beautiful than with fmap
17:45:59 <mzero> I'm looking fo the current collective idea of best practices concerning transformers & mtl ....
17:45:59 <lambdabot> mzero: You have 1 new message. '/msg lambdabot @messages' to read it.
17:46:10 <latro`a> huh
17:46:15 <latro`a> <$> is actually fairly high precedence
17:46:16 <latro`a> why is that?
17:46:20 <aristid> latro`a: why not?
17:46:29 <latro`a> well, it's meant to sort of parallel $
17:46:37 <mzero> I've got code to add extensible exceptions as a monad tranformer
17:46:38 <latro`a> but their fixities are drastically different
17:46:39 <aristid> is it?
17:46:47 <latro`a> I assume as much, why else would it be written that way
17:46:50 <aristid> latro`a: could also be meant to be like (.)
17:46:53 <mzero> but the somewhat crazy way code is split among mtl and transformers has me flummoxed
17:47:01 <aristid> ok the $ in the name might indicate that $ is the right one
17:47:17 <mzero> I can replicate it (mtl seems to reexport tons of stuff in each module) - but I'm wondering where the direction is heading
17:47:20 <latro`a> . is much *higher* fixity, though
17:47:20 <aristid> mzero: well mtl is basically all the things that require fundeps
17:47:25 <latro`a> it's in between both
17:47:32 <mzero> v
17:47:50 <latro`a> 0 4 9 respectively
17:48:33 <fengshaun> :i <$>
17:48:45 <fengshaun> :info (<$>)
17:52:19 <latro`a> works in ghci and not lambdabot, afaict
17:52:20 <latro`a> :/
17:53:03 <mzero> seems to me that mtl only needs all those fundeps for the "auto lifting" features --- but having a the typeclasses seems like a good idea
17:53:16 <mm21> @info <$>
17:53:16 <lambdabot> (<$>)
17:53:19 * hackagebot edge 0.8.14 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.14 (ChristopherHoward)
17:53:20 <latro`a> oh
17:53:32 <latro`a> well...unhelpful, but it's there at least
17:54:19 <mzero> hmmmm... okay - I'll stop trying to mirror the structure of the code in mtl & transformers --- and add a transformer & mtl-like typeclass and just put them all in one module.
17:54:31 <mzero> trying to mimic the mtl/transformer structure was giving me fits!
18:53:41 <shapr> Is there something like hpaste, but longer term saving of useful Haskell snippets with an explicit open source license?
19:18:29 <gienah> shapr: some ideas: http://hub.darcs.net/ and gists on github
19:27:13 <aaronj1335> i'm getting a n00b error, i was wondering if someone could help me. ghci is telling me "Not in scope: data constructor `State'". i've got a gist here: https://gist.github.com/4152178
19:27:38 <aaronj1335> can anyone tell me what's wrong with that 3rd line?
19:27:54 <Crockeo> You can define datatypes with the keyword data
19:28:01 <Crockeo> but there is no datatype named "State"
19:28:11 <Crockeo> I haven't worked with Control.Monad much, though
19:28:25 <applicative> Crockeo: State is no longer a constructor
19:28:47 <Crockeo> applicative: And that's a more specific answer.
19:28:54 <applicative> you can define your own data State s a = State (s -> (s,a)
19:28:58 <Nereid> aaronj1335: "State" is no longer a constructor in mtl 2, use the function
19:29:11 <applicative> but the transformers lib uses StateT
19:29:46 <applicative> Crockeo: actually there is a state function (lowercase) that should put it where you want
19:30:05 <Crockeo> applicative: Keep in mind that this isn't my question.
19:30:11 <Nereid> applicative: I think you should tell that to aaronj1335 ;)
19:30:18 <aaronj1335> applicative: do i need to import something else for the `state` monad?
19:30:36 <applicative> i just imported what you did
19:30:36 <Nereid> aaronj1335: your imports are fine, just write "state" instead of "State"
19:30:51 <Nereid> :t state
19:30:52 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
19:31:07 <Crockeo> Man, gotta love lambdabot
19:31:12 <Crockeo> what implementation of Haskell is it running?
19:31:15 <Nereid> ghc 7.4.2
19:31:23 <applicative> aaronj1335: it is a little annoying, I keep thinking of writing Control.Monad.Sensible with the old definitions of Reader Writer State etc.
19:31:34 <Crockeo> Nereid: Thank you :D
19:31:48 <aaronj1335> Nereid: when i do `:t state` i get a not in scope error
19:31:57 <Nereid> @hoogle state
19:31:57 <lambdabot> Control.Monad.State module Control.Monad.State
19:31:57 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
19:31:57 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
19:32:01 <Nereid> should work
19:32:05 <Nereid> wait
19:32:07 <applicative> hm what are you using, an old ghc?
19:32:21 <aaronj1335> applicative: GHCi, version 7.4.2
19:32:38 <Nereid> yes it should work
19:32:42 <aaronj1335> hm
19:32:57 <Nereid> and I assume you have a recent mtl too...
19:33:04 <Crockeo> aaronj1335: For future notice the release is GHC, the i just stands for interpreter.
19:33:09 <hpaste> applicative pasted “state” at http://hpaste.org/78335
19:33:13 <Crockeo> GHCi gets your message across, but it's /technically/ not correct.
19:33:27 <Crockeo> And who doesn't like technicalities, amiright?
19:33:28 <aaronj1335> Crockeo: ah, i see
19:33:42 <applicative> aaronj1335: ^^^ is what I did -- in the hpaste
19:33:47 <Nereid> oh
19:33:52 <Nereid> your problem is that you imported it qualified
19:33:54 <Nereid> :D
19:34:21 <Crockeo> Such a simple thing that slipped by so many people.
19:34:57 <applicative> oh yeah I see it now.
19:35:03 <aaronj1335> Nereid: i don't think so, when i ran the paste from applicative i got the following error:
19:35:15 <aaronj1335> Prelude Control.Monad.State> let stateIntString = state fromStoAandS
19:35:16 <aaronj1335> <interactive>:4:22:
19:35:17 <aaronj1335>     Ambiguous type variables `s0', `m0' in the constraint:
19:35:18 <aaronj1335>       (MonadState s0 m0) arising from a use of `state'
19:35:31 <Nereid> oh, that's because of the dmr
19:35:33 <aaronj1335> (sorry for the multi-line copy/paste)
19:35:40 <aaronj1335> what's the dmr?
19:35:42 <Nereid> @where dmr
19:35:42 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
19:35:49 <applicative> :set -XNoMonomorphismRestriction
19:35:53 <applicative> ^^^ paste this is
19:36:00 <applicative> in, rather
19:36:01 <ekipan> does the d stand for damned?
19:36:04 <Nereid> or write an explicit type signature
19:36:07 <applicative> dreaded
19:36:42 <Nereid> so if you wrote let stateInString = ... :: State ...
19:36:44 <Nereid> it would work
19:36:48 <ekipan> I prefer damning awful things instead of dreading them
19:36:53 <ekipan> makes me feel more proactive
19:37:08 <csigusz> mmm. coffee.
19:37:22 <aaronj1335> ah, i see. gotta hop on a flight now. you folks rock, thanks so much!
19:39:36 <applicative> as Nereid says you can use the type synonym State, e.g. let stateIntString = state fromStoAandS :: State Int String
19:40:30 * applicative has finally compiled the new idris 'whitespace' interpreter.  
19:40:57 * applicative wasn't really on the market for a ws interpreter
19:42:45 <MrWoohoo> what am I supposed to be importing to get access to the State type? "import Control.Monad.State" doesn't seem to work (depricated?)
19:43:19 <byorgey> MrWoohoo: can you be more specific? what do you mean when you say "doesn't work"?
19:43:26 <mauke> "doesn't seem to work" ಠ_ಠ
19:43:35 <csigusz> mauke, hehehe
19:44:58 <MrWoohoo> Well, I say "import Control.Monad.State" like the tutorial says, then when I try to use the type State the compiler complains "set.hs:18:15: Not in scope: type constructor or class `State'"
19:45:22 <MrWoohoo> that's what I mean "doesn't work"
19:45:48 <Crockeo> What's funny is we had something rather similar to this moments before you arrived.
19:46:00 <Crockeo> According to those around me, you now use state instead of State
19:46:14 <MrWoohoo> not in type declarations
19:46:20 <MrWoohoo> right?
19:46:48 <monochrom> the type name "State" still exists
19:46:48 <Crockeo> I honestly know nothing about Control.Monad.State, but the same problem was asked moments ago and the correct answer was to decapitalize the s.
19:46:49 <MrWoohoo> the type State is still exported by something somewhere, isn't it?
19:47:26 <MrWoohoo> what was the import statement?
19:47:34 <Crockeo> import Control.Monad.State
19:47:37 <Crockeo> try lowercase state
19:47:38 <edwardk> Crockeo: In mtl before 2.0 it used to be that State and StateT were separate data types. in 2.0 State became StateT Identity, which means to construct one you use the function 'state'
19:47:39 <Crockeo> see if it works
19:47:40 <Crockeo> :t state
19:47:41 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
19:47:42 <monochrom> decapitalizing s can only the correct answer to a slightly different question
19:47:51 <MrWoohoo> import Contol.Monad.state?
19:48:02 <monochrom> and "import Control.Monad.state" can only be a syntax error
19:48:16 <MrWoohoo> yeah, that was what I was thinking
19:48:21 <Nereid> no, use the "state" function in place of the "State" constructor.
19:48:30 <monochrom> show actual code
19:48:33 <fryguybob> MrWoohoo: GHCI doesn't warn you when "import Blah" isn't found.
19:48:37 <Crockeo> What Nereid said.
19:48:42 <Nereid> State is no longer its own data type; it's a type synonym now.
19:48:47 <Nereid> thus the State constructor no longer exists.
19:49:18 <MrWoohoo> what should I be using to get it into the namespace???
19:49:27 <Nereid> import Control.Monad.State as usual
19:49:28 <MrWoohoo> what import
19:49:40 <monochrom> "type constructor or class `State'" implies type expression, not value expression
19:50:00 <fryguybob> MrWoohoo: If it says "Control.Monad.State> " as your prompt you are fine.
19:50:02 <MrWoohoo> Could not find module `Control.Monad.State'
19:50:02 <MrWoohoo>     Perhaps you meant
19:50:04 <MrWoohoo>       Control.Monad.ST (from base)
19:50:24 <fryguybob> MrWoohoo: You should be able to do ":i State" and see the type definition.
19:50:24 <Nereid> well uh.
19:50:27 <MrWoohoo> that's what the compiler says
19:50:33 <Nereid> do you have mtl installed?
19:50:51 <MrWoohoo> Top level: Not in scope: data constructor `State'
19:51:03 <fryguybob> MrWoohoo: cabal install mtl
19:51:06 <monochrom> do you have mtl installed?
19:51:10 <MrWoohoo> mtl? how do I tell if I do have it installed?
19:51:15 <cl1> howdy folks
19:51:21 <Nereid> ghc-pkg list mtl
19:51:23 <monochrom> "ghc-pkg list mtl". show output
19:51:41 <monochrom> show actual output
19:51:44 <applicative> MrWoohoo: it's also in Control.Monad.Trans.State which you do have
19:51:45 <Nereid> if it's installed there will be a line like "    mtl-2.1.2"
19:51:45 <cl1> would a monad be used to handle things like mouse events?
19:52:11 <monochrom> if you use the Haskell Platform, you have mtl
19:52:11 <cl1> i guess I should ask, how do you handle mouse events in haskell?
19:52:56 <cl1> all i've seen is getting text from and putting text on the console
19:53:00 <Crockeo> (What's a good way to 'test' Haskell code? For instance I'm getting a 'no instance' on (Memory -> Memory) but I can't track down (easily) where I'm accidentally returning (Memory -> Memory) instead of just Memory)
19:53:19 <Crockeo> on Show (Memory -> Memory)*
19:53:37 <monochrom> you need a GUI library for mouse events. GLUT or gtk or wx or ...
19:54:17 <monochrom> the "no instance" error message has line numbers
19:54:29 <Cale> @bot
19:54:29 <lambdabot> :)
19:54:35 <Cale> :t unsafeCoerce
19:54:35 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
19:54:36 <lambdabot> Not in scope: `unsafeCoerce'
19:54:36 <cl1> monochrom: what if i wanted to write my own and pass them to haskell?
19:54:36 <Nereid> @human
19:54:36 <lambdabot> Unknown command, try @list
19:54:41 <Cale> hmm
19:54:56 <Cale> > 1
19:54:57 <lambdabot>   1
19:55:04 <Cale> Welp, whatever.
19:55:13 <fryguybob> Crockeo: You should have some line number in the error message that can get you started.
19:55:21 <Crockeo> monochrom, fryguybob: Well, I'm using the interpreter; would a compiled program tell me?
19:55:21 <monochrom> then learn Haskell's FFI so you can write your own GUI library
19:55:29 <Nereid> :)
19:55:43 <monochrom> "no instance" is a compile-time error
19:55:49 <cl1> monochrom: thanks i'll look into it
19:56:01 <monochrom> I mean, you don't even get to an executable
19:56:16 <Crockeo> monochrom: "No instance for (Show (Memory -> Memory))" etc. while it compiles fine
19:57:05 <monochrom> show complete actual message
19:57:25 <Crockeo> To the hpaste!
19:57:31 <Nereid> and the code too
19:58:05 <monochrom> and it does not "compile fine"
19:58:29 <SirSkidmore> I am trying to learn Haskell, is there a good simple project to build to really cement my learning?
19:58:30 <hpaste> applicative pasted “mouse events very simple” at http://hpaste.org/78337
19:58:42 <bzm3r> Hello everyone :)
19:59:11 <hpaste> Crockeo pasted “Interactive Error” at http://hpaste.org/78338
19:59:12 <applicative> cl1:  there's the simplest program controlled by mouse events I know of :) ^^^
19:59:20 <Crockeo> monochrom: There you are!
20:00:16 <Crockeo> Also, monochrom, when I load the program into GHCi, "Ok, modules loaded: Main, ListUtils, Shift."
20:00:17 * applicative advises against adding an instance declaration for (Show (Memory -> Memory))
20:00:25 <monochrom> then "it" is the value having type Memory->Memory. the message tells me that
20:00:33 <bzm3r> I remember a while ago, coming across a website that was basically a "club" formed around predicate calculus, and formal programming methods (stuff inspired by Dijkstra's philosophy) -- they had a good reading list that they recommended for learning formal programming methods. I can't seem to find this website again -- any chance anyone here knows which one it is I am talking about?
20:00:48 <Crockeo> monochrom: well, I know /that/ I just can't track it down.
20:00:50 <monochrom> "<interactive>:66:1" means line 66 column 1
20:01:02 <latermuse> SirSkidmore: Have you tried project euler?
20:01:06 <Nereid> it refers to the line you just typed in ghci
20:01:12 <monochrom> "it" holds the value from a previous command
20:01:13 <Crockeo> Nereid: I know that as well.
20:01:21 <Nereid> I don't know what we learned from this error message.
20:01:25 <Nereid> show more code
20:01:49 <monochrom> for example suppose you enter "1+1", then "it" becomes 2
20:02:05 <monochrom> until you enter "False || True"
20:02:29 <Crockeo> I-
20:02:30 <Crockeo> I think
20:02:31 <Crockeo> my IQ
20:02:32 <Crockeo> may be 0
20:02:32 <monochrom> use the up-arrow to discover previous things you entered
20:02:50 <Crockeo> I was calling the function evalString with only a String
20:02:55 <monochrom> or use the scroll buffer of your terminal
20:03:00 <Crockeo> when I typed it as evalString :: String -> Memory -> Memory
20:03:04 <Crockeo> my IQ is definitely 0
20:03:15 <SirSkidmore> latermuse: nope
20:04:48 * cl1 had to go take out the trash
20:04:57 <cl1> applicative: lol :)
20:05:05 <latermuse> SirSkodmore: Projecteuler.net is a good place to cement basic programming skills in a new language. It should help you learn the basic syntax for haskell, but it wont help much in learning some of the more advanced stuff.
20:05:48 <Crockeo> SirSkodmore: I agree with latermuse on that. Oftentimes when I try to learn a new language I get up to ~problem 10 on Project Euler then try to implement a basic Brainfuck interpreter.
20:05:54 <cl1> i'm going to try to load up the .net runtime from a native program and forward events to haskell, so that i can use WPF as my GUI engine
20:06:16 <monochrom> then evalString "hi" has the compile-time error. of course your Main.hs has no errors, I don't dispute that.
20:06:36 <SirSkidmore> thanks for the suggestions!
20:06:53 <Crockeo> monochrom: What I'm saying is I was calling evalString from GHCi with the wrong arguments.
20:06:54 <cl1> apparently i have to forward events to .net, and then forward them from .net back to the native app (because those are different events) and pass that info to haskell ...
20:07:10 <monochrom> yes
20:07:24 <cl1> i'm thinking that would make more than one entry point into a haskell program
20:07:32 <Crockeo> which therefore means my IQ must be 0, because /I/ defined that function.
20:07:36 <cl1> instead of just a main with IO
20:07:52 <cl1> is that even possible?
20:09:05 <cl1> Crockeo: don't be self defeatist. Enough humans hinder our evolution as a species by doing that.
20:09:20 <monochrom> my IQ is -40
20:09:39 <Crockeo> Good guy(s) #haskell.
20:10:32 <cl1> anywho, i gotta go to bed. nite all
20:16:35 <applicative> cl1:  there are better examples of gloss programs.
20:17:22 <applicative> cl1: but one that prints the position of the mouse gives good evidence that it is easy to make a mouse-dependent program
20:20:28 <latro`a> Crockeo, just for comparison, how long is the argument sequence?
20:20:35 <Crockeo> 2 arguments
20:20:51 <Crockeo> The function was :: String -> Memory -> Memory
21:22:58 <latermuse> is there an easy way to split a string by a certain delimitter? For instance: splitString "<<>>" "Hi<<>>Mr.<<>>Meow" = ["Hi", "Mr.", "Meow"]
21:23:06 <crdueck> is there a nice way to use Control.Lens to apply a function f :: Foo a => a -> b over all the fields of a data structure Bar = Bar { x, y, z :: Foo a => a }?
21:23:51 <Nereid> crdueck: biplate?
21:23:55 <mauke> latermuse: yes
21:24:14 <crdueck> Nereid: i havent used biplate before, I'll look at the hackage docs
21:24:15 <edwardk> crdueck: in general if you need some kind of quantifier in the applied function like that, e.g. like gmapM in Data.Data, Lens can't help you.
21:24:19 <edwardk> i can't generalize over those
21:24:19 <latermuse> mauke: I couldnt find that function in hoogle. Do you know where it might be?
21:24:52 <Nereid> > (48, [65, 99]) & biplate %~ chr
21:24:53 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
21:24:53 <lambdabot>              with actual type ...
21:25:03 <Nereid> er
21:25:16 <crdueck> edwardk: the types of the fields are all different, but the belong to the same class which provides the function f. Theres no way to make it work?
21:25:21 <Nereid> hmm.
21:25:30 <Nereid> ah. yeah.
21:25:49 <mauke> latermuse: Data.List.Split
21:25:59 <crdueck> or rather, they are all instances of a class which provides f
21:26:19 <latermuse> mauke: Oh jeeze. I was just looking at data.list. Forgot about Split.
21:26:50 <latermuse> mauke: thank you mauke. Im quite absentminded sometimes
21:27:28 <scp> @src liftM2
21:27:28 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
21:27:49 <edwardk> crdueck: sadly, no.
21:29:04 <lispy> heyo
21:29:37 <Nereid> ah and biplate is only a simple traversal
21:30:16 <Nereid> which makes sense
21:30:17 <lispy> > 1 + 1
21:30:18 <lambdabot>   2
21:30:31 <lispy> > foldr (+) 0 [1..3] :: Int
21:30:33 <lambdabot>   6
21:30:47 <hpaste> MrWoohoo pasted “Almost there.” at http://hpaste.org/78339
21:31:15 <MrWoohoo> Almost done. Last statement is a problem
21:31:16 <lispy> Cale: any idea what was wrong with lambdabot?
21:31:25 <Nereid> what was wrong with lambdabot?
21:31:55 <djahandarie> Linode blew earlier
21:31:58 <djahandarie> So probably that.
21:32:01 <lispy> Nereid: I was getting some very weird error messages from her
21:32:38 <Nereid> I don't see any linode status issues within the last few days
21:32:45 <Nereid> or do you mean the server itself.
21:33:12 <lispy> Nereid: I don't think it was linode related, FWIW
21:33:43 <Nereid> I wouldn't have thought so.
21:40:46 * hackagebot LambdaCalculator 0.1 - A basic lambda calculator with beta reduction and a REPL  http://hackage.haskell.org/package/LambdaCalculator-0.1 (ThomasDuBuisson)
21:46:21 <NihilistDandy> That seems pretty cool
21:51:57 <Sonarpulse> I am trying to modify a file. Specifically I am adding data to a file, but adding data in such a way that I need to read the entire file (lazily), add the new data, and then write it back
21:52:18 <Sonarpulse> I would like to not have to keep the entire file in memory and take advantage of lazyness/buffering
21:52:45 <Sonarpulse> so it seems like the obvious choice would be to rename the file to a tempory name
21:53:07 <Sonarpulse> do my operation, and then delete the old file
21:53:33 <Sonarpulse> I could of course copy the file to a temporary file, but that adds uneeded work
21:54:09 <Sonarpulse> Right now I am just naively trying to read and write to the file at the same time (without handles), and it's giving me an error
21:54:09 <mauke> did you mean: output to a separate file, then rename over the original
21:54:29 <Sonarpulse> I think that is equivalent
21:54:59 <Sonarpulse> oldFile -> tempFile, tempfile + newStuff -> newFile
21:55:46 <Sonarpulse> or what you say: oldFile + newStuff -> tempFile; tempFile -> newFile
21:55:58 <Sonarpulse> either way, one of those arrows aught to be a new name
21:57:58 <Sonarpulse> if only the garabage collector would work on the filesystem
21:59:32 <rxqkx> wow... it is a true joy to experience writing a ton of haskell code... mostly reasoning about types... and having it all work out in a few trys
22:00:06 <rxqkx> I have never written so much code and have it Just Work
22:00:23 <latermuse> rxqkx: Wait until you master types.
22:09:11 <Sonarpulse> anybody have any guidance for my IO issue?
22:18:10 <neutrino> hi guys
22:18:58 <neutrino> does anyone know if there's an api for the pwd database (which reads /etc/passwd*) and the group database?
22:20:08 <neutrino> python has the pwd module and the grp module for that
22:20:51 <latro`a> I'd suggest fishing around in the POSIX lib
22:21:05 <latro`a> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix.html
22:21:25 <latro`a> (though ideally you'd use the portable API, there are times when that doesn't cut it, obviously
22:21:28 <latro`a> )
22:23:27 <hpaste> Sonarpulse pasted “Modifying a File” at http://hpaste.org/78341
22:24:24 <Sonarpulse> well hlint gives me something
22:24:49 <latro`a> not sure why the internal liftM/return
22:24:54 <latro`a> @ sonarpulse
22:25:01 <Sonarpulse> see the L.readFile ?
22:25:15 <latro`a> (though I might misunderstand)
22:25:41 <latro`a> also, there is no reason to liftM on a liftM
22:25:48 <latro`a> better to merge those
22:26:07 <Sonarpulse> yeah, that's what is sudgests
22:26:12 <Sonarpulse> though now that I think of it
22:26:35 <Sonarpulse> that then should not evaluate to a function
22:27:01 <latro`a> at any right, not a clue what you're doing
22:27:15 <latro`a> seems easier to just do something like this in do notation
22:27:29 <Nereid> do notation is pretty clear
22:27:31 <Sonarpulse> let me get you old revisoin that works
22:27:34 <latro`a> or with smaller pieces in do notation that you chain together
22:28:08 <Sonarpulse> well the other issue is that I am trying to read and write to a file simultaneously
22:28:52 <latro`a> truly simultaneously, or interleaved?
22:29:09 <Sonarpulse> basically the whole program is kind of like tar
22:29:28 <Sonarpulse> but it's a shitty format so to add on some files I am deserializing the original
22:29:30 <Sonarpulse> making my changes
22:29:37 <Sonarpulse> and then serializing back
22:29:39 <Sonarpulse> and writing
22:29:52 <Sonarpulse> I would however, not like to keep the original file all in memory
22:30:00 <Sonarpulse> so I should probably use a temporary file
22:30:24 <neutrino> latro`a: heheh, just found it :)
22:30:32 <latro`a> in posix?
22:31:34 <Sonarpulse> https://github.com/Sonarpulse/CnC-Red-Alert/blob/mixer/Main.hs
22:31:57 <Sonarpulse> here you can see the previous version: I am trying to shrink it a bit as you can see there is some redundant stuff
22:31:58 <rekado> Hi, I want to write an XMPP server component; is there any actively developed/usable XMPP component library I could use?
22:32:52 <latro`a> idk what some of these things are
22:32:58 <latro`a> like mergeSafeRecursiveFile3s
22:33:05 <latro`a> I don't even know its type
22:33:13 <joeyh> rekado: I've been fairly happy with network-protocol-xmpp so far
22:33:44 <mzero> edwardk: if you're interested, here's what I came up with for my mtl/transformers like support for extensible exceptions: https://github.com/mzero/plush/blob/exceptions/src/Control/Monad/Exception.hs
22:33:47 <Sonarpulse> Also, is there a clean way for using =<< with multiple-arugment functions? (curried form)
22:33:59 <latro`a> not sure what you mean "with multiple argument functions"
22:34:16 <Sonarpulse> well :t (=<<)
22:34:23 <Sonarpulse> :t (=<<)
22:34:25 <lambdabot> Monad m => (a -> m b) -> m a -> m b
22:34:25 <latro`a> I know its type
22:34:27 <edwardk> looks kind of like the MonadCatchIO stuff
22:34:30 <latro`a> I don't know what you're saying takes two arguments
22:34:42 <rekado> joeyh: thanks, I'll take a look.
22:34:49 <Sonarpulse> I mean say the firt arugment was (a -> b -> m c)
22:34:55 <latro`a> it can't be
22:35:01 <latro`a> if you mean (foo x) then that's fine
22:35:03 <mzero> Sonarpulse: do you mean you want to apply a function to two arguments, both of which must come from some monad value?
22:35:05 <latro`a> but you can just do that as is
22:35:09 <latro`a> function application is tighter than anything infix
22:35:22 <latro`a> foo x =<< y works fine
22:35:23 <Sonarpulse> I think so
22:35:41 <neutrino> latro`a: yeah
22:35:46 <Sonarpulse> I want: (a -> b -> m c) -> m a -> m b -> mc
22:35:54 <neutrino> latro`a: now trying to locate something to give me the group database
22:35:59 <mzero> :t liftM2
22:36:00 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:36:04 <rekado> joeyh: I think I even used it before, but I found it rather...incomplete.
22:36:11 <latro`a> that is indeed liftM2, yeah
22:36:26 <latro`a> which is itself implemented by essentially using bind and return
22:36:35 <Sonarpulse> wait, then is liftM the same as =<< ?
22:36:39 <Sonarpulse> :t liftM
22:36:39 <latro`a> no
22:36:40 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
22:36:42 <latro`a> liftM is the same as fmap
22:36:48 <mzero> latro`a: well it would have to, no? That is all Monad really gives you! :-)
22:36:52 <rekado> joeyh: it also depends on an experimental gnutls
22:36:57 <latro`a> true mzero
22:37:00 <latro`a> but not doing anything fancy with them
22:37:00 <rekado> *library
22:37:01 <latro`a> jsut
22:37:19 <joeyh> it doesn't have any higher-level protocol stuff, extensions, etc, but it should be possible to build any of that on top of it
22:37:20 <latro`a> *just
22:37:46 <latro`a> eh, nvm
22:38:19 <joeyh> yeah, gnutls is perhaps its main weakness. I found and the author fixed a segfault caused by that. Also, it needs improvements to its certificate checking
22:38:23 <latro`a> actually
22:38:28 <latro`a> what you wrote is slightly different from liftM2
22:38:37 <latro`a> liftM2 has a return; yours does not
22:38:45 <edwardk> mzero: i added an issue to track it https://github.com/ekmett/mtl/issues/3
22:39:07 <latro`a> liftM2 f m n = m >>= \x -> n >>= \y -> return (f x y); your version has no return
22:39:13 <edwardk> not sure if it falls within scope, but i want to make sure its doumented as a concern somewhere =)
22:39:15 <mzero> cool - thanks edwardk
22:39:21 <mzero> I'll keep watch on that
22:39:43 <edwardk> i @mentioned you in it so it'll probably send you updates
22:39:48 <Sonarpulse> hmm? for some reason my ghci instance is refusing to identify liftM
22:39:52 <mzero> one thing I see is that when you add something with non-simple function patterns, you need things like liftCatch throughout the library
22:39:54 <latro`a> it's in Control.Monad
22:40:23 <Sonarpulse> yeah I am importing it, qualified, and using it
22:40:24 <mzero> in this case, we'd need liftMask -- as it is non-trivial!
22:40:28 <Sonarpulse> in some other file
22:40:31 <edwardk> i remember MonadCatchIO-transformers had some craziness and some correctness concerns about how to handle Cont, etc.
22:40:36 <neutrino> ah there it is
22:40:41 <Sonarpulse> i dunno
22:40:42 <edwardk> and yeah, masking safely is nontrivial =)
22:40:48 <Sonarpulse> give me a second to see what is happing with it
22:41:16 <neutrino> just had to find out what system calls the python module was doing, and search for those on hackage
22:41:36 <edwardk> i'm somewhat tempted to leave it to the MonadCatchIO-transformers guys since there are a lot of them and they've been willing to devote a lot of brainpower to the problem. I talked to ezyang about what the motivations were for some of what they were doing last year at Hac Boston
22:42:12 <mzero> Yeah I saw that craziness, and decided that I only needed StateT covered for now - so that is all I did...
22:42:42 <mzero> not sure if I'd end up in the same difficulties as they did -- probably
22:42:54 <edwardk> but in general their package is already the sort of defacto standard way to do it
22:43:31 <edwardk> i need to figure out how to lift the MonadCatchIO operations into my machines library
22:43:45 <mzero> I'll relook at that.... One insight I gained was this: You can't implement bracket in terms of an inner monad's bracket! You need mask as an exposed typeclass fucntion
22:43:53 <edwardk> yep
22:44:10 <mzero> (figured that would have been obvious to you! :-)  )
22:44:37 <edwardk> not obvious, but i'd already been primed by my discussion with ezyang ;)
22:45:38 <edwardk> woot! i was able to get the new projections to work =)
22:46:00 <Sonarpulse> ok, I just +m control.monad
22:46:09 <Sonarpulse> no idea why ghci was not working before
22:46:19 <Sonarpulse> yeah
22:46:45 <Sonarpulse> I see the difference now
22:47:00 <Sonarpulse> and that's the cause of my type error too
22:47:01 <Nereid> fun fact: you can put those commands in .ghc/ghci.conf to load your favourite modules every time
22:47:08 <neutrino> hey guys, how do i catch an exception from getUserEntryForName? for when you pass an invalid user name
22:47:12 <Sonarpulse> thanks for the info
22:47:25 <Sonarpulse> yeah I do need a =<<2 after all
22:47:35 <Sonarpulse> but perhaps that is semantically not possible,
22:47:37 <neutrino> > getUserEntryForName "edwardk"
22:47:38 <neutrino> *** Exception: edwardk: getUserEntryForName: does not exist (no user name)
22:47:39 <lambdabot>   Not in scope: `getUserEntryForName'
22:47:44 <Nereid> neutrino: look up "catch"
22:47:48 <neutrino> i tried using "try"
22:47:58 <Nereid> in Control.Exception
22:47:59 <neutrino> but it needs a constraint specified
22:47:59 <edwardk> we have user entries?
22:48:05 <neutrino> and i'm not sure what to do with that
22:48:09 <neutrino> @ty try
22:48:10 <lambdabot> Not in scope: `try'
22:48:15 <Nereid> @hoogle catch
22:48:15 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
22:48:15 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
22:48:15 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
22:48:19 <neutrino> @ty Control.Exception.try
22:48:21 <lambdabot> GHC.Exception.Exception e => IO a -> IO (Either e a)
22:48:32 <neutrino> Nereid: the manual says "try" is the best in this situation
22:48:36 <Nereid> ok, well
22:48:45 <Nereid> if you know the type of exception you want to catch, then use that
22:48:56 <neutrino> i don't know how to find out the type of the exception
22:48:59 <Nereid> otherwise you can use SomeException to catch any exception
22:49:03 <Sonarpulse> maybe I can use a combination of LiftM =<<
22:49:11 <Sonarpulse> the function is curried after all
22:49:29 <mzero> Nereid: is that function a System.Posix function? if so, they're all IOError exceptions
22:49:34 <Nereid> mzero: what do you need all those things for
22:49:37 <Nereid> er Sonarpulse*
22:49:48 <Nereid> mzero: no, it's all in Control.Exception
22:49:59 <Sonarpulse> I have some System.Directory
22:50:01 <Nereid> er
22:50:06 <mzero> no no, getUserEntryForName
22:50:08 <Nereid> who
22:50:08 <Nereid> oh
22:50:18 <Nereid> so that's not directed at me then.
22:50:20 <mzero> anyhow- bedtime for me
22:50:22 <mzero> night all
22:50:24 <Sonarpulse> good night
22:50:32 <neutrino> ok let's assume it's an IOError exception
22:50:43 <Sonarpulse> for m problem?
22:50:49 <Sonarpulse> it's just IO i can assure you that
22:50:56 <Sonarpulse> https://github.com/Sonarpulse/CnC-Red-Alert/blob/mixer/Main.hs
22:51:02 <Sonarpulse> it type checks in this version
22:51:16 <Sonarpulse> I am doing now is trying to remove redundant statements
22:51:28 <neutrino> not your problem
22:51:31 <neutrino> my problem :)
22:51:34 <Sonarpulse> oh :D
22:51:44 <neutrino> @hoogle IOError
22:51:44 <lambdabot> Prelude type IOError = IOException
22:51:44 <lambdabot> System.IO.Error type IOError = IOException
22:51:44 <lambdabot> Prelude ioError :: IOError -> IO a
22:52:28 <neutrino> @type getUserEntryForName
22:52:29 <lambdabot> Not in scope: `getUserEntryForName'
22:52:42 <neutrino> @type System.Posix.User.getUserEntryForName
22:52:43 <lambdabot> String -> IO System.Posix.User.UserEntry
22:53:05 <neutrino> so i would do try (getUserEntryForName "Nereid") :: IOError e => IO (Either e UserEntry)
22:53:22 <Nereid> no
22:53:25 <Nereid> that doesn't make sense
22:53:30 <Nereid> or wait.
22:53:37 <neutrino> yeah
22:53:41 <Nereid> yeah IOError isn't a typeclass that doesn't make sense.
22:53:47 <neutrino> oh
22:53:51 <Nereid> ... :: IO (Either IOError UserEntry)
22:54:28 <neutrino> right, that worked
22:54:37 <neutrino> if i get an exception, how can i find out its type?
22:54:47 <neutrino> i need a better method of it than ask on irc and hope someone knows
22:55:06 <Nereid> every Exception is a Typeable
22:55:21 <neutrino> let's say i'm in ghci and i can trigger the exception
22:55:31 <Nereid> and also a Show
22:55:48 <neutrino> sure but how do i use that?
22:55:55 <neutrino> if i try :t it doesn't bring much:
22:55:55 <neutrino> > :t getUserEntryForName "Nereid"
22:55:56 <neutrino> getUserEntryForName "Nereid" :: IO UserEntry
22:55:56 <lambdabot>   <hint>:1:1: parse error on input `:'
22:56:09 <Nereid> no, you don't do it in ghci
22:56:17 <Nereid> I mean
22:56:20 <neutrino> what do i do then..
22:56:27 <Nereid> well, if you're catching an IOError, then its type is IOError.
22:56:40 <neutrino> but how do i know it's an IOError????
22:56:47 <Nereid> because you wrote IOError
22:56:53 <neutrino> no i didn't!
22:56:54 <Nereid> it won't catch non-IOError exceptions
22:56:59 <neutrino> i didn't know it's an IOError
22:57:01 <neutrino> look
22:57:04 <neutrino> here's the situation
22:57:10 <Nereid> oh I was confused about what you were asking.
22:57:15 <neutrino> i have a function which throws an exception and i don't know the type
22:57:15 <neutrino> !
22:57:17 <neutrino> :)
22:57:21 <Nereid> I see now.
22:57:23 <Nereid> well uh
22:57:25 <neutrino> :)))
22:57:36 <Nereid> you could catch a SomeException and use Typeable stuff to see what it is.
22:57:42 <neutrino> ohhh
22:57:51 <neutrino> SomeException is a special thing that catches anything, right?
22:57:56 <neutrino> @hoogle SomeException
22:57:56 <lambdabot> Control.Exception.Base SomeException :: e -> SomeException
22:57:56 <lambdabot> Control.Exception SomeException :: e -> SomeException
22:57:56 <lambdabot> Control.Exception.Base data SomeException
22:58:19 <Nereid> I guess you could say that.
23:00:20 <vamega1> Hi
23:00:41 <vamega1> I'm trying to write a tail recursive implementation of the depth function
23:00:49 <vamega1> that operates on a Binary tree
23:01:06 <neutrino> Nereid: mmh, still no idea :/
23:01:17 <vamega1> How could I convert my naieve implemention into one that is tail recursive
23:01:25 <neutrino> i extracted the exception from IO and Either and when i try to type it i get:
23:01:40 <neutrino> e :: SomeException
23:02:19 <luite> vamega1: depth :: Int -> Tree -> Int
23:02:29 <luite> oh hmm
23:02:30 <luite> wait
23:02:32 <luite> sorry
23:02:49 <vamega1> Yeah thats what I currently have
23:02:53 <Nereid> hmm
23:03:02 <vamega1> I'll post it on hpaste in a moment
23:03:35 <neutrino> this looks useful Nereid
23:03:36 <neutrino> http://stackoverflow.com/questions/9799734/is-there-a-way-to-get-the-type-of-an-exception-in-haskell
23:04:13 <neutrino> @type catch
23:04:14 <lambdabot> IO a -> (IOError -> IO a) -> IO a
23:04:15 <neutrino> @type try
23:04:17 <lambdabot> Not in scope: `try'
23:04:22 <neutrino> gah
23:04:38 <luite> the whole exception thing is built around Typeable
23:05:03 <Nereid> neutrino: ah yeah that does it.
23:05:16 <neutrino> now trying to figure out how to do this with try :)
23:05:18 <Nereid> yeah, pattern match on the SomeException constructor and look at its type.
23:05:27 <luite> if you want to know if the thing you have, wrapped in a SomeException, is actually an IOException, you can do  fromException e :: Maybe IOException
23:05:38 <Nereid> if you had an initial guess, sure.
23:05:39 <luite> it will give you Nothing if it's another exception
23:05:45 <neutrino> no i want to know what that thing is
23:05:49 <neutrino> at all
23:06:24 <luite> ah then the typeOf way looks ok
23:06:40 <Nereid> >>> case toException (userError "a") of SomeException e -> typeOf e
23:06:40 <Nereid> IOException
23:06:40 <neutrino> yeah, trying to figure out a oneliner that i can type in ghci
23:06:48 <neutrino> ahh
23:06:56 <hpaste> vamega pasted “Binary Search Tree” at http://hpaste.org/78342
23:07:25 <neutrino> @type toException
23:07:26 <lambdabot> Not in scope: `toException'
23:07:30 <neutrino> huh
23:07:32 <vamega1> I'm trying to convert depth' into a tail recursive version.
23:07:34 <neutrino> @hoogle toException
23:07:34 <lambdabot> Control.Exception.Base toException :: Exception e => e -> SomeException
23:07:34 <lambdabot> Control.Exception toException :: Exception e => e -> SomeException
23:07:36 <Nereid> it's in the Exception class
23:07:44 <neutrino> yeah
23:07:51 <Nereid> just read the docs for Control.Exception :p
23:08:24 <Nereid> obviously you wouldn't use toException yourself, so replace that whole part with the unknown exception
23:08:56 <neutrino> right, you can match on the SomeException constructor
23:08:59 <neutrino> makes sense!
23:09:01 <neutrino> thanks a lot guys
23:09:06 <hpaste> Sonarpulse pasted “Another try at run'” at http://hpaste.org/78343
23:09:30 <Nereid> all I see is a sea of liftMs and =<<s
23:09:45 <Sonarpulse> yes, it's an excelent argument for do notation
23:10:11 <Sonarpulse> basically since there is no =<<2 (analoguous liftM2)
23:10:41 <Sonarpulse> I broke up me \a b -> into \a -> \b ->
23:10:41 <johnw>  Sonarpulse: how would you use =<<2?
23:10:49 <Nereid> and in do notation I'd probably rather write do { x <- m; return (f x) } instead of liftM f m
23:10:53 <mauke> Sonarpulse: why?
23:10:54 <Nereid> in certain cases
23:11:14 <Sonarpulse> Monad m => (a1 -> a2 -> m r) -> m a1 -> m a2 -> m r
23:11:15 <Nereid> mostly if f or m is big
23:13:43 <Sonarpulse> what I am trying to do now is break that function into (m a >>= (a -> m b)) >>= (b -> m c)
23:14:12 <Sonarpulse> is the above valid?
23:14:36 <shachaf> No, it's invalid syntax. Types aren't values.
23:14:45 <Ralith> more's the pity
23:14:46 <Sonarpulse> ok, well i know that
23:14:53 <shachaf> I also don't know what it's trying to say. :-)
23:15:17 * shachaf looks
23:15:20 <shachaf> That hpaste is very difficult to read.
23:15:30 <shachaf> Why are you using all these (=<<)s?
23:15:36 <Sonarpulse> I am trying to similate my hypothetical =<<2 with 2 =<<
23:15:55 <Sonarpulse> I don't really like do notation / this is more educational
23:16:35 <Nereid> do notation exists for a reason
23:16:48 <Sonarpulse> yeah, I am re-discovering it :D
23:16:56 <csigusz> what reason?
23:17:12 <shachaf> Even if do notation didn't exist this code would be convoluted.
23:17:35 <Sonarpulse> also, with do notation I am always afriad I will force some order of opperation that's unneeded
23:17:38 <shachaf> You can write something that looks very similar to do notation without do notation.
23:17:56 <shachaf> Sonarpulse: do notation isn't voodoo
23:18:04 <Nereid> true
23:18:10 <shachaf> And it doesn't force any order of operation.
23:18:12 <Nereid> but everything is all over the place aaaaaaaaa
23:19:25 <Sonarpulse> I don't completely understand the transformation from do-notation, and it certainly does sometimes enforce an order, in that that's half the purpose of monads
23:19:44 <Sonarpulse> here I can see more explicitly what the order is
23:19:59 <Sonarpulse> well, to the extent that anything is clear here ;)
23:20:04 <shachaf> Sonarpulse: "the purpose of monads" doesn't really have to do with order.
23:20:11 <Sonarpulse> um IO?
23:20:12 <shachaf> Any more than the purpose of, say, function composition.
23:20:20 <shachaf> Or lists.
23:20:48 <Nereid> @where do
23:20:48 <lambdabot> http://www.haskell.org/haskellwiki/Do_notation_considered_harmful
23:20:52 <Nereid> lol
23:21:07 <Nereid> ok that doesn't apply here...
23:22:04 <Sonarpulse> https://github.com/Sonarpulse/CnC-Red-Alert/blob/mixer/Main.hs
23:22:26 <Sonarpulse> I'll post it again for you shachaf, since I am not sure when you started looking at this
23:22:35 <Sonarpulse> you can easily find my previous version of the code
23:22:50 <Nereid> fwiw you can name all three record fields mixPath
23:23:20 <Sonarpulse> but then can I have different descriptions for them in help?>
23:23:39 <Nereid> oh fine
23:23:54 <shachaf> That code doesn't seem very readable.
23:24:01 <shachaf> But everything I said before seem applies.
23:24:06 <shachaf> still
23:24:12 <Sonarpulse> more readable than this
23:26:15 <Sonarpulse> ah! got it!
23:26:26 <Sonarpulse> just missed a parenthesis or too
23:26:39 <Sonarpulse> hopefully hlint will remove some of those
23:26:46 <Sonarpulse> nope :(
23:26:50 <Sonarpulse> it didn't
23:26:52 <shachaf> You should try rewriting your code to use do notation.
23:27:06 <Sonarpulse> is there a do notation to normal pre-processor>?
23:28:12 <neutrino> Nereid: thanks again for your help :) i was really stuck
23:32:11 <hpaste> Nereid pasted “do” at http://hpaste.org/78344
23:32:15 <Sonarpulse> ok, if any of you are curious, github now has the fixed version
23:32:30 <Nereid> Sonarpulse: ^  I probably typed something wrong somewhere, but whatever.
23:32:36 <Sonarpulse> ah thanks!
23:32:41 <Sonarpulse> I will use that as a guide
23:32:49 <Nereid> no, you can do better than what I wrote
23:33:13 <Sonarpulse> "guide" :D
23:33:19 <Nereid> "starting point"
23:33:51 <Sonarpulse> ok
23:34:18 <Sonarpulse> if there is a lambda-case
23:34:24 <Sonarpulse> is there a lambda if
23:34:56 <Nereid> I don't see the need for special syntax for such a thing.
23:35:16 <Sonarpulse> actually wait, I remebered it
23:35:26 <Nereid> I would define bool :: a -> a -> Bool -> a; bool x y b = if b then y else x
23:35:40 <Nereid> (but I'm backwards, you might want to define if' = flip bool)
23:35:49 <Nereid> (and don't call it if')
23:35:57 <Sonarpulse> http://hackage.haskell.org/packages/archive/cond/0.3/doc/html/Control-Conditional.html
23:35:59 <Sonarpulse> another if'
23:36:39 <Nereid> oh hey, bool is in there
23:36:39 <Nereid> !!
23:37:12 <Nereid> I swear I've looked at that module before but didn't see it.
23:37:29 <Sonarpulse> well with do notation i will be using <- to "extract" the bool anyways
23:37:44 <Nereid> yeah. there have been some proposals for a monadic if
23:38:02 <Nereid> but look, ifM exists
23:38:07 <Sonarpulse> does if "break out" of  do notation?
23:38:29 <Sonarpulse> oo, I wonder what is keeping this package out of the platform
23:38:33 <mgsloan> sonarpulse: yes, in that if is not treated specially for do
23:38:38 <Sonarpulse> thanks
23:38:40 <mgsloan> just another expression
23:38:52 <Nereid> the lines in a do block are not expressions
23:38:59 <mgsloan> yeah, they're statements
23:39:03 <mgsloan> which can be expressions :)
23:39:07 <Nereid> the things you give to if are expressions
23:39:24 <Nereid> so, short answer "yes"
23:40:11 <Sonarpulse> will it forget my <- from an outer do?
23:40:18 <Sonarpulse> those bindings I mean
23:40:22 <Nereid> no
23:40:22 <mgsloan> Sonarpulse: a nice combinator for ifs without elses is Control.Monad.when
23:40:36 <Nereid> just as they won't forget function arguments if you put them in a function
23:40:42 <Sonarpulse> oh cool, though in this case the elses are always used
23:40:45 <mgsloan> it's common to do "when predicate $ do" and then continue on indented in the condition
23:41:11 <Nereid> although the do block must have return type ()
23:41:32 <Sonarpulse> hmm, it also want's to indent the "then" more than if
23:41:32 <mgsloan> yeah, that's one annoying thing about when
23:41:50 <mgsloan> when should really be Bool -> m a -> m a
23:41:51 <Nereid> I wouldn't call it annoying
23:41:58 <Nereid> no, it shouldn't
23:42:01 <shachaf> mgslaon: Bool -> m a -> m ()?
23:42:01 <mgsloan> yeah nvm
23:42:02 <Nereid> how would you know what a to return if it's False?
23:42:03 <mgsloan> I got it
23:42:14 <Nereid> shachaf: which is as good as Bool -> m () -> m ()
23:42:22 <Nereid> well, no better
23:42:22 <mgsloan> yeah, that could hide mistakes
23:42:27 <shachaf> Nereid: Except for the extra void you have to do.
23:42:36 <Nereid> "have to"
23:42:41 <shachaf> I think there was a proposal for when_ or something like that once.
23:43:03 <Nereid> @hoogle void
23:43:03 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
23:43:03 <lambdabot> Control.Monad void :: Functor f => f a -> f ()
23:43:03 <lambdabot> package void
23:44:10 <mgsloan> @hoogle Bool -> a -> m a -> m a
23:44:11 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec TexCoord3 :: a -> a -> a -> TexCoord3 a
23:44:11 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Normal3 :: a -> a -> a -> Normal3 a
23:44:11 <lambdabot> Graphics.Rendering.OpenGL.GL.VertexSpec Color3 :: a -> a -> a -> Color3 a
23:45:17 <luite> hmm
23:45:32 <Nereid> mgsloan: in that situation I'd just use a regular if with return
23:46:57 <mgsloan> yeaaa, but that's like 10 extra characters ;)
23:47:24 <Nereid> how many times would you save 10 characters over writing a couple lines for an extra function definition
23:47:27 <mgsloan> ohh, more like 16, but I'm kidding :)
23:47:32 <Nereid> :p
23:47:38 <Nereid> also readability
23:50:35 <Sonarpulse> if I return in the inner do
23:50:36 <gatlin> I was told earlier that this crowd doesn't use regex much so my question is a bit general: if I have a big Data.Text Text value how could I effectively text =~ m/[a-z]+/g and capture the matches?
23:50:45 <Sonarpulse> will i get (m m a) ?
23:51:04 <Nereid> m (m a)?
23:51:22 <Sonarpulse> yeah
23:51:25 <Sonarpulse> sorry
23:52:18 <Nereid> so like
23:52:28 <Nereid> return (someIOAction)?
23:52:50 <Nereid> that would have type IO (IO whatever), and the action wouldn't get executed.
23:53:04 <Sonarpulse> well i am  worried the nested do loops will create a problem like that
23:53:13 <Nereid> nested dos are fine
23:54:27 <Ralith> gatlin: usually we write parsers when we need to parse things.
23:55:47 <gatlin> Ralith: Right, and I was hoping to write one
23:56:07 <Ralith> so, you want parser framework recommendations?
23:56:10 <Ralith> parsec is popular.
23:56:22 <gatlin> the regex situation is a bit complicated if you're not using standard strings, but I was hoping someone had some experience perhaps
23:56:24 <Ralith> dunno anything about how it interacts with Text though
23:56:33 <hpaste> Nereid annotated “do” with “do (annotation)” at http://hpaste.org/78344#a78345
23:56:37 <Nereid> Sonarpulse: I did a bit more ^
23:56:49 <fmap> parsec has Text support
23:56:57 <fmap> both strict and lazy
23:57:29 <gatlin> fmap: for this little exercise I was hoping I could do things a bit more simply / keep the number of deep rabbit holes to a minimum :)
23:57:43 <Sonarpulse> oh thanks, you are certainly faster at the do-ing than me
23:57:46 <gatlin> so I figured I'd ask if anyone has successfully used text.regex.* with non strings
23:58:22 <Nereid> look how much shorter and more readable it is compared to the original :p
23:58:37 <Sonarpulse> no arguing with that
23:59:44 <gatlin> also, I didn't think my question was so silly as to necessitate a quip :-/
