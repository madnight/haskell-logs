00:00:22 <neutrino_> mauke: do you see any other issues with it?
00:00:25 <edwardk> that also is constrained to dispatch really well
00:00:48 <sw2wolf> In CL (+ 1/2 1/3) returns 5/6. Can we get the same result using ghc ?
00:00:51 <sopvop> edwardk: that Naming thing in your answer to crisdoner post about Data on reddit. It's a way to attach some metadata to lens, and still use it as lens?
00:01:01 <edwardk> sopvop: yes
00:01:06 <sopvop> Neat
00:01:24 <donri> so is there a makeIso for Wrapped?
00:01:26 <edwardk> sopvop: its a trick we were using for a little while in the 3.7 approach to projections and isomorphisms.
00:02:15 <fmap> > 1/2 + 1/3 :: Rational
00:02:17 <lambdabot>   5 % 6
00:02:25 <edwardk> donri: not yet, but its been talked about as the way to handle makeIso instances
00:02:36 <sw2wolf> fmap: that's great'
00:03:26 <sw2wolf> I want to use haskell to teach kids math
00:03:44 <donri> edwardk: would i then use "wrapped MyNewtype" or would there still be a "myNewtype" iso?
00:03:54 <neutrino_> sw2wolf: nice idea
00:03:59 <edwardk> donri: still open for discussion
00:04:13 <donri> i suppose that'd depend on LensRules?
00:04:16 <neutrino_> sw2wolf: there are lots of people doing work on haskell guis for, among others, drawing math
00:04:22 <neutrino_> i forgot the channel, someone knows
00:04:24 <edwardk> one thought is to have makeIso keep up with the current behavior and a makeWrapped that does the Wrapped instance
00:04:25 <neutrino_> luite does
00:04:26 <sw2wolf> Then the kids donot need to input () ?
00:04:41 <donri> i kind of like the readability of the non-wrapped version, but it does clutter my namespace
00:05:00 <sw2wolf> neutrino_: thanks
00:05:18 <neutrino_> sw2wolf: but i am afraid at the most basic level you'll be spending more time teaching them about programming concepts than maths concepts
00:05:26 <neutrino_> granted, they're similar once you get to the level
00:05:30 <edwardk> there is also a possibility of adding makeProjections for making a projection for each constructor
00:05:30 <donri> like i have a Word Text newtype in my dictionary app, and i want a 'word' lens for a record that holds such a Word
00:05:36 <neutrino_> but that's like college level at least
00:05:43 <sopvop> cdsmith is teaching kids programming and math using haskell. CodeWorld project IIRC
00:06:02 <neutrino_> "programming and math" is much more realistic
00:06:06 <donri> from (wrapped Word) -- kinda ugly though
00:06:06 <sw2wolf> first it is simple math concept at the beginning
00:06:26 * elliott finds the non-wrapped versions more readable in general, even for out of the box stuff
00:06:29 <edwardk> donri: makeClassy ''Word will get you 'word' to find the word in a container
00:06:41 <neutrino_> "but what does it mean when you divide twice by Rational"
00:06:43 <sw2wolf> The kids can use racket to do some thing already
00:06:56 <edwardk> then you can just instance HasWord Foo where word = … for your instances
00:06:57 <donri> ah yea
00:07:13 <donri> but can an Iso be HasWord?
00:07:16 <edwardk> 3.7 makes it possible to use makeClassy even when you have parameters
00:07:32 <neutrino_> sw2wolf: you need to think about conveying as little new information at once as possible
00:07:37 <edwardk> sady word winds up forced to be a lens there, if you think about it it makes sense
00:07:48 <neutrino_> sw2wolf: the ":: Rational" is a very confusing factor there
00:07:49 <donri> yea that's what i feared
00:07:53 <edwardk> because not everything that contains a word will be _isomorphic_ to a word ;)
00:07:54 <sw2wolf> neutrino_: yes
00:08:04 <neutrino_> how are you gong to solve this issue?
00:08:17 <neutrino_> and, why does the number suddenly have percentages, and not division? that's another issue.
00:08:21 <donri> sure, it is sanity even if inconvenient ;)
00:08:25 <sw2wolf> just try
00:08:52 <sw2wolf> 5 % 6 is not so good
00:09:10 <neutrino_> :t 1/2
00:09:12 <lambdabot> Fractional a => a
00:09:26 <sopvop> > 5 Data.Ratio.% 6
00:09:27 <lambdabot>   5 % 6
00:09:57 <donri> <>= in the main import, nice
00:10:04 <neutrino_> how do you go from Rational to a fraction again?
00:10:09 <edwardk> sw2wolf: if you import Data.Ratio   4%5 will just get you a Ratio. if you are sticking to small numbers this is fine
00:10:27 <sw2wolf> yes
00:10:33 <edwardk> donri: moving to wrapped reduced the contents of Data.Monoid.Lens to just the <>= variants
00:10:41 <edwardk> so it make sense to distribute them
00:10:58 <donri> yea, got that from the changelog which mentions that too
00:11:41 <donri> monoid is so ubiquitous so it makes sense to export with main api
00:12:00 <neutrino_> sw2wolf: you could create simple REPL's for every thing that they are supposed to teach
00:12:09 <neutrino_> sw2wolf: that's easy enough with haskell
00:12:19 <edwardk> donri: also because i don't export ++=, etc. in the api
00:12:23 <sw2wolf> create ? why cannot i use ghci directly ?
00:12:33 * hackagebot edge 0.8.16 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.16 (ChristopherHoward)
00:12:45 <neutrino_> well you see obvious issues, you have to annotate types, and what you get back is in unexpected form
00:13:06 <neutrino_> it's probably better to introduce those changes at a later time
00:13:08 <hpaste> b__ pasted “Do these functions (and their SPECIALIZATIONS) make sense like this for general use?” at http://hpaste.org/78533
00:13:20 <neutrino_> if indeed the point of your class is to introduce fractions
00:13:31 <edwardk> neutrino_: with 7.6 it switches on the NoMonomorphismRestriction by default which would greatly reduce the pressure to put in type annotations for entry level code like that
00:13:36 <neutrino_> is it, sw2wolf?
00:13:37 <sw2wolf> i see
00:14:02 <neutrino_> edwardk: does it?
00:14:08 <neutrino_> edwardk: is that what simon quit over?
00:14:11 <neutrino_> ;)
00:14:13 <edwardk> neutrino_: clearly
00:14:19 <basdirks_> I hpasted a bunch of basic Integral functions like 1 minute ago, could someone have a quick peek?
00:15:03 <neutrino_> basdirks_: not sure what to make of that
00:15:11 * neutrino_ isn't the best programmer though.
00:16:14 <sw2wolf> (lcm 10 25) and "lcm 10 25" is same as racket, that's good
00:16:22 <alex73> ciao
00:16:36 <basdirks_> neutrino_, I use those functions often enough to justify putting them down somewhere, but I'm not sure if they are the best way to do what they do, and whether or not the pragmas are optimal
00:17:24 <alex73> !list
00:17:24 <monochrom> alex73: http://hpaste.org
00:17:27 <neutrino_> sw2wolf: yes!
00:17:51 <neutrino_> basdirks_: i suggest, put it on bitbucket, and on hackage, and if someone has an issue then update it.
00:18:11 <neutrino_> put your worries in the readme along with your contact details.
00:18:34 <neutrino_> mauke: have you noticed any issues with engines that use libpcre?
00:18:38 <basdirks_> I'm not sure if I want to pollute hackage with it
00:18:47 <neutrino_> it's polluted already
00:19:06 <basdirks_> yeah but I don't feel like contributing to more pollution, though I appreciate your suggestion
00:19:49 <basdirks_> I'll have a look if the wiki and hackage have what I'm looking for =]
00:19:56 <sopvop> lenses: jerkTo
00:21:01 <edwardk> sopvop: its for a zipper. you can 'tug' the zipper or you can 'jerk' the zipper. tugging it will gently stop at the ends of the zipper.
00:21:08 <sw2wolf> What does `ghci +RTS -M30M -c20` mean ?  From the `top`, i cannot see big difference as `ghci` ?
00:21:10 <edwardk> jerking it will give you back Nothing if you go off the end.
00:22:11 <edwardk> you can tug left, tug right, tugs left 3, tugs right 4, jerks left 10, jerkTo someabsoluteposition, tugTo someabsoluteposition, and go 'farthest left' and 'farthest right'
00:22:14 <sopvop> When you learn English from internet, you never know if some words have 'normal' meaning
00:22:37 <neutrino_> basdirks_: check hoogle and hayoo as well..
00:23:03 <startling> edwardk, you're pretty good at the names thing
00:23:07 <edwardk> they are also compositional, in tat you can say 'tugs (jerks left 2) 10  -- to tug 10 times to the left in 2-step increments and stop when you can't move 2 steps to the left at a time any more
00:23:40 <edwardk> startling: thanks. i go overboard sometimes, i admit, but i try
00:24:50 <hpaste> killy9999 pasted “To curry or not to curry?” at http://hpaste.org/78534
00:24:53 <startling> edwardk: overboard is fun
00:25:08 <edwardk> startling: thats not a combinator (yet) =)
00:25:09 <killy9999> can anyone tell me which is better to use?
00:25:15 <killy9999> f1 or f2?
00:25:27 <startling> edwardk: haha
00:25:46 <hpaste> neutrino pasted “package incompatibilities” at http://hpaste.org/78535
00:25:52 <killy9999> f1 seems more idiomatic (less understandible for unexperienced person)
00:25:59 <startling> edwardk: have you got to port and starboard yet?
00:26:10 <neutrino_> i need to install this package, but cabal says it would break other packages. what should i do?
00:26:35 <edwardk> nah was worried 'port' was too common a name ;)
00:27:08 <edwardk> i very nearly renamed the 'left' and 'right' combinators for working with zipper that way though
00:27:16 <killy9999> neutrino_: it looks that your package needs newer version of mtl, but other packages need the older version
00:27:16 <neutrino_> why port if you could make it bourbon?
00:27:23 <startling> edwardk: how abou clockwise and widdershins?
00:27:24 <edwardk> but tugging to port seemed silly ;)
00:27:55 <sopvop> killy9999: I prefer first style
00:27:56 <startling> killy9999: just use uncurry g
00:28:10 <killy9999> neutrino_: go to hackage ans find which version of regex-base depends on mtl-2.0.1.0 and install that particular version
00:28:10 <startling> killy9999: but you probably don't need to name it regardless
00:28:27 <startling> neutrino_, cross your fingers and turn clockwise three times.
00:28:38 <killy9999> startling: thanks. what do you mean by "don't need to name it"?
00:28:48 <neutrino_> killy9999: in a completely separate user, as a test i installed first regex-tdfa and then test-framework-0.6.1 and cabal mentioned no problems
00:29:18 <killy9999> neutrino_: my *guess* is that it compiled test-framework against new mtl
00:29:33 <neutrino_> yes
00:29:37 <killy9999> the version of test-framework taht you have must have been installed earlier and compiled against older mtl
00:29:48 <neutrino_> it is the same version
00:29:58 <neutrino_> just compiled against older mtl
00:29:58 <startling> killy9999: why do you have g in the first place? why do you think you need to give uncurry g a name?
00:30:03 <killy9999> same version of test-framework?
00:30:08 <neutrino_> yes
00:30:16 <killy9999> neutrino_: exactly, that's the point
00:30:24 <neutrino_> how can i make cabal recompile everything?
00:30:41 <killy9999> cabal can compile test-framework against both version of mtl, but once it is compiled you cannot just replace mtl like that
00:30:50 <neutrino_> at least everything that's going to be "broken"
00:30:55 <killy9999> startling: for benchmarking
00:31:04 <neutrino_> killy9999: can you explain?
00:31:12 <neutrino_> what do you mean by "replace mtl just like that"
00:31:14 <killy9999> neutrino_: I don't know. I don't think cabal can't do that
00:31:24 <startling> neutrino_: cabal --force-reinstall, I think
00:31:30 <startling> neutrino_: be careful though
00:31:51 <killy9999> neutrino_: I meant that you cannot install newer version and hope that packages compiled against older version will work just like that. They would need to be recompiled against newer version
00:32:48 <neutrino_> um
00:32:55 <neutrino_> i've just done du -sh .cabal and it's still counting
00:32:55 <killy9999> startling: so, g is curried function. f1 is used for benchmarking with criterion. I pass all the data for benchmarks in a tuple - hence uncurry
00:33:06 <neutrino_> what the hell is going on
00:33:20 <killy9999> dependency hell I guess
00:34:43 <neutrino_> any idea where i can get info on what --force-reinstalls actually does? i can't find any description anywhere
00:35:12 <johnw> if installing a package would cause another package to be reinstalled, do it
00:35:29 <neutrino_> hmm
00:35:42 <neutrino_> ok, let me back up my .cabal and try
00:35:53 <neutrino_> thanks guys
00:36:00 <startling> neutrino_: cabal install --help | grep force
00:36:49 <neutrino_> ah, i checked cabal --help
00:37:35 <neutrino_> hmm wait
00:37:53 <neutrino_> johnw: what you say is different than the output of startling's command
00:38:18 <neutrino_>     --force-reinstalls              Reinstall packages even if they will most
00:38:18 <neutrino_>                                     likely break other installed packages.
00:39:22 <neutrino_> johnw: who's right?..
00:39:34 <johnw> cabal docs
00:40:56 <neutrino_> johnw: i'm not sure what you mean. are you saying the help output is incorrect, or that it is correct?
00:41:36 <johnw> i don't know anymore
00:41:38 <johnw> i just know when i use it
00:41:48 <neutrino_> ok
00:41:52 <johnw> which is 100% of the time when it awns me
00:41:54 <johnw> warns
00:41:58 <neutrino_> i'll try your suggestion then
00:42:13 <neutrino_> with backup, hopefully nothing bad can happen :)
00:51:28 <sopvop> So, I want to make json representation of data, and "schema" at the same time. Any interesting links out there?
00:51:48 <sopvop> variations of 'self-documenting pretty-printer' does not google anything
00:53:47 <sopvop> I know I need something like  (Desc, a -> Value) and bunch of combinators. But thought maybe there is library to learn from.
00:53:57 <sopvop> Should not be specific to json
00:55:42 <sopvop> GetOpt looks like it, but reversed
00:59:26 <hpaste> killy9999 pasted “yet another type error” at http://hpaste.org/78536
00:59:43 <killy9999> ok, I can't manage with this type error
01:00:09 <killy9999> cana nyne tell me what is going on?
01:00:20 <killy9999> s/cana nyne/can anyone/
01:03:51 <sopvop> No one knows, or my question was bad?
01:04:02 <killy9999> sopvop: I think it was very complex
01:06:20 <sopvop> I guess it was :(
01:06:46 <killy9999> I guess mine is too :/
01:07:20 <killy9999> neutrino_: how your --force-reinstall went?
01:19:42 <mercury^> How do I get a UArray i e out of a MaybeT (ST s) (STUArray s i e)?
01:22:59 <quchen> mercury^: runSTUArray?
01:23:03 <quchen> :t runSTUArray
01:23:05 <lambdabot> Not in scope: `runSTUArray'
01:23:28 * quchen plays Lambdabot: runSTUArray :: Ix i => (forall s. ST s (STUArray s i e)) -> UArray i e
01:23:54 <quchen> Oh wait, it's MaybeT-wrapped, didn't see that
01:24:16 <mercury^> Err, I want a Maybe (UArray i e) of course, also.
01:24:22 <t7> is there a song about monads?
01:24:45 <merijn> t7: If not you should make one!
01:24:50 <simpson> We noticed that "reader writer state transformer" could replace quite a few Daft Punk lyrics, but aside from that, no.
01:24:50 <quchen> You'll first have to unwrap the transformer, giving you a ST (Maybe Array), using runMaybeT. After that, call runSTUArray.
01:25:17 <merijn> simpson: You are my favorite person of the day for pointing that out xD
01:26:01 <merijn> t7: Time for another Bieber parody? "Mo-nad, mo-nad, mo-nad, oooh" :>
01:26:22 <t7> hahah oh god
01:27:05 <mercury^> quchen: how can the argument of runSTUArray match ST s (Maybe (STUArray s i e))?
01:33:59 <quchen> fmap fromMaybe should work
01:34:50 <quchen> Other than this, you can write your own "runMaybeSTUArray" function. runSTUArray is implemented as "runST (st >>= unsafeFreezeSTUArray)
01:34:53 <quchen> "
01:38:59 <statusfailed> Is there a reasonably simple explanation for what the four type variables of Lens are?
01:39:25 <johnw> what, s t a b?
01:39:26 <quchen> Mnemonic ;-)
01:39:44 <zhulikas> subliminal message
01:39:55 <statusfailed> yeah, s t a b
01:40:26 <zhulikas> statusfailed, why do you ask? does it make you feel angry or in any way attracted to using knifes?
01:40:35 <johnw> i'm not sure if my explanation would be reasonably simple
01:40:38 <liyang> source target alpha beta
01:40:42 <johnw> the Store comonad looks like: data Context a b t = Context (b -> t) a
01:40:43 <merijn> statusfailed: You mean the four variables in "Lens a b c d"?
01:40:46 <johnw> that explains three of them
01:41:07 <johnw> if by "explains" you mean: not at all
01:41:12 <statusfailed> lol
01:41:20 <merijn> statusfailed: I finally had my enlightenment about what they mean and why they're actually simple
01:41:23 <hpaste> johnw pasted “context links” at http://hpaste.org/78537
01:41:27 <johnw> try reading those links
01:41:34 <johnw> you might get a feel for what Store means
01:41:53 <johnw> then you just extend it with one more type (what the lens is applied to), and you get Lens
01:41:54 <merijn> Pfft, I can "explain" them without knowing Store and friends at all
01:41:59 <liyang> When a changes to b, s changes to t. If written Lens a b c d , it's not immediately clear which are the related pairs.
01:42:03 <johnw> merijn: you have the floor!
01:42:09 <statusfailed> I'm all ears
01:42:22 <elliott> statusfailed: if you have a lens for the first element of a tuple, it's Lens (a,c) (b,c) a b, does that help?
01:42:36 <elliott> you can get an a out of an (a,c), and if you put a b back in its place, you get a (b,c)
01:42:36 <merijn> statusfailed: You understand the "old" (Data.Lens) definition of "Lens a b" being an accessor for a "b" field inside the "a" type, right?
01:42:53 <elliott> hence s(ource) = (a,c), t(arget) = (b,c)
01:43:00 <statusfailed> elliott: yep
01:43:19 <statusfailed> merijn: I didn't actually use it much, but yeah
01:43:20 <elliott> statusfailed: so this would just be Lens (a,c) a, except that by having four parameters like this we can change the type of the field, which we otherwise wouldn't do
01:43:26 <elliott> *couldn't do
01:43:41 <elliott> you can also say: SimpleLens (a,b) b, which is the same as Lens (a,b) (a,b) b b
01:43:43 <statusfailed> ooh that makes sense
01:43:46 <elliott> for the common case where the type can't change
01:43:53 <merijn> Awwww
01:43:56 <elliott> (but in this case, we can change the type of the field, so we generalise it)
01:44:06 <merijn> elliott stole my story :(
01:44:22 <elliott> oops, I didn't notice merijn was about to explain :p
01:44:26 <statusfailed> rampant plagiarism in #haskell!?
01:44:36 <statusfailed> :D
01:44:38 <elliott> it's ok merijn, you get to do the next two lens-related explanations for free
01:44:55 <elliott> especially if they involve unsafeCoerce and the indexedprojectivelenses that existed for about an hour
01:45:07 <merijn> But I don't understand those bits at all :p
01:45:19 <merijn> Granted, that's never stopped me from trying to explain things
01:45:25 <elliott> well, neither does edwardk. otherwise people wouldn't have been able to derive unsafeCoerce from it :)
01:46:01 <quchen> UnsafeCoerce seems to be quite popular here.
01:46:05 <quchen> I keep hearing about it.
01:46:22 <Nereid> it's evil
01:46:22 <zhulikas> people secretly love javascript. That's why they use unsafeCoerce
01:46:26 <Nereid> haha
01:46:28 <quchen> But apart from the beautiful and concise implementation of fromJust, I haven't seen it used ;-)
01:46:43 <elliott> we like to keep our unsafeCoerces hidden from the public eye
01:46:51 <zhulikas> because it's shameful?
01:46:59 <elliott> to keep up the mystery
01:47:19 <zhulikas> not sure making it look like haskell works magically is a good thing :D
01:47:24 <zhulikas> like
01:47:32 <zhulikas> when you start out with haskell you are forced to use all the types
01:47:45 <zhulikas> and with advanced stuff BAM you magically get javascript
01:48:18 <zhulikas> I love haskell for it's strictness
01:48:21 <quchen> zhulikas: That may be right, but contrary to JS, you have a choice.
01:48:23 <merijn> zhulikas: Well, as long as you stay away from unsafeCoerce you have the advantage of having static correctness guarantees for your javascript :p
01:48:31 <Nereid> zhulikas: but haskell is non-strict!
01:49:11 <quchen> Ba-dum-tsh
01:49:15 <zhulikas> but having a choice is tempting to choose a dark side!
01:50:06 <merijn> zhulikas: Not when you learn the magic of GADTs and RankNTypes, then suddenly you don't need the dark side that often :p
01:50:10 <quchen> I personally have never felt compelled to using IORefs and until instead of recursion. That's very untempting.
01:50:44 <zhulikas> yeah, IORef is like useless
01:51:04 <merijn> Not really
01:51:28 <merijn> Saying IORef is useless is like saying "MVar's that cannot be empty are useless"
01:51:28 <quchen> IORefs are salt. You may need some, but not too much.
01:52:14 <quchen> merijn: What's an example of non-emptiable MVars? Haven't heard of that before.
01:54:29 <merijn> quchen: There's not any such thing in reality, but if you only use atomicallyModifyMVar (or whatever it's called) you avoid blocking people using the MVar for too long. IORef are mostly just MVar's with no empty state, which can be useful sometimes
01:55:16 <quchen> There are atomical MVar functions?!
01:55:29 <bartavelle> isn't that something you should have with STM ?
01:55:56 <quchen> Yeah, that's pretty much exactly what I always use STM for, even in simple cases
01:56:15 <liyang> You should probably start using STM if it's getting to the point where reasoning about MVars gets hairy.
01:56:48 <quchen> Is there a reason not to use STM in certain cases?
01:57:06 <quchen> The main argument against long transactions is that half of them retry when others modify TVars, right?
01:57:14 <quchen> For short transactions, that shouldn't matter much though.
01:57:29 <quchen> In other words: why should I use MVars at all?
01:58:05 <merijn> quchen: They're only atomical if your program is well behaved, they're essentially just "takeMVar mvar >>= putMVar mvar . f"
01:58:06 <zhulikas> I hope this doesn't sound like a troll question, but has anyone ever compared IORef performance with how any other programming language handles variables? Like, it looks like an advanced feature in Haskell so it makes it look like it's something complex and slow. But in reality is it?
01:58:37 <merijn> zhulikas: Well, there's some overhead, but not a lot
01:58:47 <zhulikas> for example if I'd rely solely on IORefs in my haskell program, can I expect similar performance like for example in java?
01:59:14 <zhulikas> this always bugged me
01:59:24 <zhulikas> I mean the IORef thing
01:59:28 <zhulikas> not haskell vs *
01:59:31 <merijn> zhulikas: Probably relatively similar
01:59:33 <quchen> Considering maintainability and the time to write that spaghetti code, yes certainly.
02:00:03 <zhulikas> spaghetti in which language?
02:00:15 <quchen> IORefHaskell/Java
02:00:28 <kliko> Hello, I have a small question, can someone give me an example how the ask and local functions should be implemented of MonadReader?
02:00:51 <zhulikas> I wonder where the overhead lies
02:00:57 <bartavelle> kliko, why don't you look at the actual implementation ?
02:00:57 <merijn> zhulikas: There is some synchronisation overhead for using IORefs, but that's not very costly
02:01:01 <zhulikas> and how significant it is
02:01:09 <zhulikas> ah
02:01:54 <quchen> kliko: The implementation can be found here: http://hackage.haskell.org/packages/archive/transformers/latest/doc/html/src/Control-Monad-Trans-Reader.html#ask
02:02:10 <merijn> zhulikas: read/write needs to be atomic and there's also atomicModify which performs both in one atomic operation
02:02:31 <zhulikas> needs? I doubt it's atomic in other languages
02:02:37 <kliko> I've already looked at it, but it seems like
02:02:40 <kliko> it's only lift ask
02:02:42 <kliko> and id
02:02:43 <merijn> zhulikas: Those things aren't free, of course. But on the other hand it's also not like those require insanely expensive operations
02:03:04 <merijn> zhulikas: What would happen if I only partially write a value? What would that even mean in haskell?
02:03:10 <merijn> zhulikas: Would the RTS crash?
02:03:42 <zhulikas> merijn, so you say haskell gone a step further than most other languages and made reads/writes atomic, right?
02:03:47 <merijn> zhulikas: In C they just say "oh, if you do it concurrently you get undefined bytes in the memory" but lacking a notion of "memory location" how would you define the semantics
02:03:57 <kliko> I'm not quite sure where the "parameters are hidden", so I thought maybe someone has a more pedagogical example
02:04:41 <bartavelle> kliko, for me, understanding how the state monad was implemented was done by looking at the types and implementing it myself
02:04:47 <zhulikas> if that's the only difference, I am very much satisfied with how Haskell handles it
02:05:20 <merijn> zhulikas: There's some more details at the IORef documentation (i.e. read/writes may appear in different orders to different threads)
02:05:38 <zhulikas> well, I guess there could have been STM for atomicity and dangerous operations for IORef, but oh well
02:06:56 <merijn> zhulikas: Anyhoo, to get back to the overhead issue. I would expect overhead similar to atomic primitives in for example C (warning: mostly speculation from my side, profile before deciding, etc!)
02:07:34 <bartavelle> except you never use atomic primitives in C
02:07:43 <bartavelle> you mostly hope for the best
02:08:03 <zhulikas> :D
02:08:45 <merijn> bartavelle: Speak for yourself
02:08:48 <zhulikas> merijn, that answers my question and leaves me in peace
02:08:53 <zhulikas> thanks
02:09:02 <merijn> Especially now that C11 has stdatomic.h!
02:09:09 <zhulikas> of course that's speculation, but I wanted to know wtf is happening inside it
02:12:00 <bartavelle> what, _Atomic type qualifier  ??
02:12:06 <bartavelle> looks really cool
02:12:55 <merijn> bartavelle: Yes, and stdatomic defines simple names and operations for types like int, etc
02:13:45 <bartavelle> how do they get away with that ? is C11 only supported on a subset of the currently supported architecture ?
02:14:36 <bartavelle> I suppose the standards don't have to support the architectures, it should be the other way around
02:15:16 <merijn> bartavelle: atomic is an optional part of C11
02:15:22 <hpaste> sopvop pasted “Json self describing encoder concept” at http://hpaste.org/78538
02:15:28 <sopvop> There!
02:15:32 <merijn> i.e. implementations don't have to support atomics, but if they do they have to follow stdatomic
02:15:35 <sopvop> and no lens
02:15:36 <bartavelle> ok
02:19:00 <sopvop> Though that will be slow encode
02:19:59 <startling> edwardk: have you considered a lens-core with few dependencies?
02:20:11 <elliott> see the lens faq :P
02:20:13 <johnw> heh
02:20:25 <elliott> https://github.com/ekmett/lens/wiki/FAQ#wiki-lens-core
02:20:25 <johnw> he just added that the FAQ today
02:20:43 <johnw> edwardk: are you good with CoQ?
02:20:44 <startling> wow, same name and all.
02:20:46 <johnw> Coq
02:21:28 <mrpantoufle> johnw: maybe asking on #ocaml will bring more answers?
02:21:37 <elliott> lens has not very many dependencies for an edwardk package really :P
02:21:37 <johnw> ooh, #ocaml instead of #coq?
02:21:38 * sopvop hopes to get at least "your idea is shit" or "ok, might work", on that paste 
02:21:44 <startling> oh, I see. lens is his plan to get all his packages in base.
02:21:54 <startling> all your base are belong to edwardk?
02:23:25 <Saizan> sopvop: can you also parse with that?
02:23:48 <sopvop> Saizan: Nope, and I don't need to
02:24:33 <kliko> I have a question regarding the following instance definition: instance (Monad m) => MonadReader r m | m -> r where... I've never seen the | sign in the instance definition. How should I interpret it?
02:24:59 <Saizan> sopvop: it'd be cool :)
02:25:14 <sopvop> With lens-aeson it should work :)
02:25:45 <merijn> kliko: "| m -> r" is a functional dependency, if you google "haskell fundeps" you should find a lot of explanation
02:25:52 <kliko> ty
02:27:07 <Saizan> sopvop: looks interesting, have you benchmarked toRes schema against a hand-writter encoder?
02:27:25 <sopvop> No, but I'm sure it will be much slower.
02:29:02 <Saizan> if only we had partial evaluation :)
02:30:16 <sopvop> haskell is too lazy for that? :)
02:33:57 <startling> @faq haskell is too lazy for that?
02:33:57 <lambdabot> The answer is: Yes! Haskell can do that.
02:35:10 <fmap> partial evaluation is like evaluating only `[' part of `[]'?
02:36:32 <johnw> yay, I did it, proved the distributivity of multiplication!
02:36:45 <johnw> only too me about an hour and a half of banging my head against a wall ;)
02:40:54 <ciaranm> johnw: that's an axiom!
02:41:07 <startling> heh
02:41:17 <johnw> yeah, but I'm in a virgin environment with absolutely nothing given
02:41:53 <johnw> i had to use 4 others theorems i'd proven earlier to do it
02:42:02 <arcatan> proving axioms :)
02:42:04 <johnw> but this was one of the hardest i've done so far
02:42:10 <ciaranm> absolutely nothing? you have to define truth?
02:42:13 <johnw> yes
02:42:18 <arcatan> johnw: are you working through Software Foundations
02:42:27 <johnw> arcatan: how'd you guess? :)
02:42:37 * hackagebot bumper 0.5.0.2 - Automatically bump package versions, also transitively.  http://hackage.haskell.org/package/bumper-0.5.0.2 (BramSchuur)
02:44:08 <ciaranm> it's a good thing b. pierce spells his name the sensible way. otherwise it would get confusing.
02:44:23 <johnw> like pierce?
02:44:26 <johnw> peirce?
02:44:31 <johnw> damn, even my spell checker corrects me
02:45:26 <ciaranm> yeah. was reading a paper that cited something by benjamin pierce and something by benjamin peirce. that was confusing.
02:51:01 <killy9999> is there any particular reason why there is no uncurry3 :: (a -> b -> c -> d) -> (a, b, c) -> d  function?
02:51:55 <elliott> not really
02:52:04 <elliott> you generally don't want to use three-tuples though
02:52:07 <elliott> (or anything higher than two really)
02:52:39 <killy9999> why?
02:53:27 <Ralith> because then you will find yourself needing uncurry3
02:53:33 <Ralith> :D
02:53:53 <killy9999> Ralith: and thd ;)
02:53:54 <Ralith> more seriously, your code rapidly becomes less clear
02:54:15 <elliott> killy9999: well, that's generally the point where you want to be using a data type instead
02:54:16 <Ralith> if you have a C background, you might compare it to using anonymous structs everywhere
02:54:34 <killy9999> I see
02:54:40 <killy9999> well, I use tuples for benchmarking
02:54:55 <killy9999> I create some common data and pass it around to different functions packed in a tuple
02:56:19 <elliott> sounds like you want a data type, then
02:57:11 <killy9999> I think this would be a lot of boilerplate
02:57:37 * hackagebot cpphs 1.15 - A liberalised re-implementation of cpp, the C pre-processor.  http://hackage.haskell.org/package/cpphs-1.15 (MalcolmWallace)
02:58:40 <killy9999> but speaking of data types
02:58:54 <killy9999> I have a function that takes a parameter that must be either 0 or 1
02:59:03 <startling> killy9999, Bool?
02:59:13 <killy9999> and I just pass an Int hoping that no one will ever pass anything different
02:59:22 <statusfailed> Why might replicateM 10 getLine not give me the list until 10 lines have been entered?
02:59:25 <killy9999> startling: I need that to be an instance of Num
02:59:32 <statusfailed> is that expected?
02:59:36 <startling> statusfailed, IO is strict.
02:59:53 <liyang> > fromEnum <$> [False, True]
02:59:55 <lambdabot>   [0,1]
03:00:12 <elliott> the boilerplate would be no more than with a tuple
03:00:14 <statusfailed> startling: but liftM lines getContents works I think?
03:00:16 <killy9999> so, can I create a data type that will take only values of 0 or 1 AND have no impact on performance during runtime?
03:00:34 <elliott> you should use Bool and not require an instance of Num, preferably
03:00:46 <killy9999> elliott: why?
03:01:11 <killy9999> elliott: as for boilerplate I am not convinced, but I'll change my code to use datatypes and see if it gets better :)
03:01:37 <killy9999> elliott: I am using this parameter for computations so it would be problematic to have it as Bool
03:02:06 <elliott> well, I don't know what you're doing... just pass an Int in I guess
03:02:08 <startling> statusfailed, IO is kind of like State internally.
03:02:09 <statusfailed> I guess getContents gives back a lazy list already, so the sequence call is avoided
03:02:30 <killy9999> elliott: that's what I'm doing, but my question stands
03:02:34 <elliott> statusfailed: getContents specifically cheats using unsafe functions
03:02:39 <statusfailed> ah right
03:02:45 <startling> statusfailed: there's a kind of "baton" that gets passed around
03:02:48 <killy9999> can I create my own data type to represent 0/1 and have no impact on runtime performance?
03:02:57 <elliott> (btw, State analogy for IO is misleading -- not only is it a GHC implementation detail, but it is actually just a compiler trick that doesn't get compiled down to state threading)
03:02:59 <startling> statusfailed: if you really want to do it, though, there's unsafeInterleaveIO
03:03:12 <elliott> killy9999: you can create your own data type for which fromInteger errors out if passed something other than 0 or 1, I guess
03:03:28 <startling> elliott: huh, didn't know that, thanks.
03:03:33 <elliott> or just use Bool and convert explicitly and rely on the compiler to inline that -- it would most likely be more idiomatic
03:04:00 <statusfailed> Well, what I want to achieve is a repeated input > response behaviour without resorting to explicit recursion
03:04:11 <startling> killy9999: have you benchmarked your code?
03:04:15 <killy9999> elliott: OK, thanks.
03:04:19 <killy9999> startling: yes
03:04:28 <elliott> startling: (if you're curious, basically the reason it uses a "state" monad is to introduce data dependencies such that GHC optimisation and so on won't reorder the (impure) IO code, because there is a data dependency on the previous "world state" at each step... however this "state" actually gets erased completely during compilation)
03:04:36 <startling> killy9999: okay, so benchmark 0/1 vs Bool
03:04:37 <killy9999> I mean I wrote lots of benchmarks today and am working on more
03:04:49 <startling> elliott, ah, neat.
03:05:10 <startling> elliott: so it's just a dumb trick so that ghc sees they can't be reordered.
03:05:14 <killy9999> startling: I guess the difference will be barely noticable - I think inspecting Core would be better
03:05:31 <startling> killy9999: if the difference is barely noticeable, why do you care about it?
03:06:18 <elliott> startling: pretty clever trick imo :) but it is a shame it looks so much like a state monad, because it misleads people
03:06:40 <killy9999> startling: I don't know, I just care :)
03:12:44 <basdirks_> are there interesting ways (interesting by whatever definition you like) to define \a b = liftM2 (&&) (x <) (< y)?
03:13:04 <elliott> i assume you mean (a <) (< b) :P
03:13:20 <basdirks_> you are correct =D
03:13:43 <basdirks_> python has comparison chaining etc, and I understand why that doesn't work in Haskell
03:13:48 <Ralith> @pl \a b = liftM2 (&&) (x <) (< y)
03:13:49 <lambdabot> (line 1, column 6):
03:13:49 <lambdabot> unexpected "="
03:13:49 <lambdabot> expecting pattern or "->"
03:13:54 <Ralith> er
03:13:58 <Ralith> @pl \a b -> liftM2 (&&) (x <) (< y)
03:13:59 <lambdabot> const (const (liftM2 (&&) (x <) (< y)))
03:14:07 * Ralith facepalm
03:14:12 <Ralith> @pl \a b -> liftM2 (&&) (a <) (< b)
03:14:12 <lambdabot> (. flip (<)) . liftM2 (&&) . (<)
03:14:13 <basdirks_> @pl \ a b -> liftM2 (&&) (a <) (< b)
03:14:14 <lambdabot> (. flip (<)) . liftM2 (&&) . (<)
03:14:28 <Ralith> okay that's actually longer
03:14:29 <basdirks_> yes that's pretty interesting but yeahhhh
03:14:58 <simpson> @pl \b t x -> b < x && x < t
03:14:58 <lambdabot> (. flip (<)) . ap . ((&&) .) . (<)
03:15:07 <basdirks_> there is the super lame \a b -> `elem` [a+1..b-1]
03:15:17 <simpson> Not the same thing.
03:15:18 <basdirks_> but of course it's not the same, much slower, etc
03:15:22 <basdirks_> yeah
03:16:04 <elliott> i think basdirks_'s original formulation is just fine
03:16:22 <elliott> \a b c -> a < c && c < b would be just fine also
03:17:38 * hackagebot base-compat 0.0.0 - Provide new additions to base for older versions of base  http://hackage.haskell.org/package/base-compat-0.0.0 (SimonHengel)
03:25:02 <neutrino_> johnw: hey
03:25:19 <neutrino_> johnw: i tried --force-reinstalls but it didn't recompile the dependents
03:25:42 <neutrino_> johnw: so what i did was to look at the error message that cabal gave me originally listing the packages that would get broken
03:25:48 <neutrino_> johnw: then i used this: cat | while read i; do cabal install --force-reinstalls --reinstall "$i"; done
03:25:56 <neutrino_> and i pasted in that list
03:26:05 <neutrino_> apparently it's in the right order for that
03:26:20 <neutrino_> i wish cabal dll hell would finally go away though
03:26:26 <neutrino_> :'(
03:26:36 <ocharles> any lens'ers around? I have some code that is (foo ^. key "bar" :: Maybe Something), and I want to traverse into that maybe
03:26:52 <ocharles> I thought I could: 'foo ^. key "bar" . traverse (by mbid)' but that is apparently incorrect
03:27:05 <elliott> :t traverse
03:27:07 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:27:10 <johnw> neutrino_: what version of cabal are you using?
03:27:26 <elliott> ocharles: (foo ^.. key "bar" . traverse) will give you a list of the traversal results, you might be able to work from there
03:27:33 <neutrino_> cabal-install version 0.14.0
03:27:34 <neutrino_> using version 1.14.0 of the Cabal library
03:27:37 <elliott> but it doesn't take an argument like that when you're using it with an accessor operator
03:27:42 <ocharles> ah
03:27:50 <johnw> neutrino_: that is the problem there
03:27:57 <neutrino_> why is that a problem?
03:28:06 <johnw> cabal hell is largely gone in 1.16.0.2 (+ Cabal 1.16.0.3)
03:28:15 <johnw> i haven't had a hellish moment in weeks now
03:28:17 <neutrino_> is 1.16 going to be in the new platform?
03:28:28 <johnw> i'm not sure that it is, no
03:28:30 <neutrino_>  1.16.0.4
03:28:34 <neutrino_> er 3
03:28:40 <ocharles> elliott: ah yes, 'foo ^. key "bar" . traverse . by mbid' is what I wanted
03:28:40 <neutrino_> ok
03:28:41 <johnw> but you can: "cabal install cabal-install Cabal" right now
03:28:50 <neutrino_> ewww
03:28:52 <johnw> forcing reinstalls ;)
03:29:04 <elliott> ocharles: :)
03:29:14 <johnw> i'm using said cabal with 7.4.2 and 7.6.1, and having fun with both
03:29:16 <neutrino_> you just want me to break my computer johnw
03:29:19 <neutrino_> :)
03:29:23 <johnw> i do, indeed i do!
03:30:02 <neutrino_> well
03:30:21 <neutrino_> after all this reinstalling, my project still builds
03:30:24 <neutrino_> so i'm fairly happy
03:32:31 <t7> anyone passed byte buffers to haskell from C?
03:32:52 <merijn> t7: Yeah
03:33:06 <t7> can you point me to docs please :)
03:33:45 <merijn> t7: You probably want Foreign.Marshall and Foreign.Marhsall.Array
03:33:59 <merijn> mallocArray :: Storable a => Int -> IO (Ptr a)
03:34:10 <t7> ah cheers
03:35:44 <merijn> t7: Or Foreign.Marhsall.Alloc with "mallocBytes :: Int -> IO (Ptr a)"
03:35:58 <merijn> Or "Foreign.Marshall.Array.newArray :: Storable a => [a] -> IO (Ptr a)"
03:36:11 <t7> nah i need the other way
03:36:25 <t7> Ptr a -> [a] or Vector or w/e
03:36:39 <Ralith> peekArray
03:37:29 <merijn> t7: That also exists
03:51:53 <sopvop> You know what? I should start using TH!
03:54:02 <statusfailed> sopvop: not sure if serious, but I found a nice tutorial
03:54:23 <sopvop> please share, i'm serious. TH is the only way to make what I want run faster
03:54:48 <zhulikas> :)
03:54:52 <statusfailed> ooh, details? or is it supersecret?
03:54:56 <zhulikas> I'd love to master TH
03:55:01 <statusfailed> It's basic, but here: http://www.hyperedsoftware.com/blog/entries/first-stab-th.html
03:55:15 <statusfailed> it's not really a tutorial, more just some really basic stuff
03:55:28 <statusfailed> but I found it useful
03:55:40 <sopvop> I want generate schema and json with same code
03:55:53 <sopvop> Thanks
03:55:57 <statusfailed> np, hope it helps
03:56:09 <statusfailed> schema and json? From what?
03:56:29 <sopvop> from defintion of "toJSON" :) of some sort
03:57:45 <elliott> any desire to master TH will be extinguished by basic proficiency in TH :P
03:58:26 * killy9999 hates writing "f = id" functions only to guide type checker :/
03:58:54 <bitonic> ghc mod doesn’t seem to work for my cabal project
03:59:07 <bitonic> flymake mode is enabled but it doesn’t highlight errors
03:59:19 <bitonic> in general the ghc-mod experience recently has been erratic :P
03:59:35 <bitonic> I think the problem might be that I have an executable target and a library target
04:01:39 <zhulikas> :D
04:02:24 <zhulikas> hey, I did one example with TH!
04:02:24 <zhulikas> I mean, it is complicated and requires to remember lots of things
04:02:24 <zhulikas> but ohh the benefits
04:02:38 * hackagebot netwire 4.0.6 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.6 (ErtugrulSoeylemez)
04:02:50 <tdammers> damn, I've hit a wall
04:03:14 <tdammers> I have this template compiler, and it has def and call statements to make macros
04:03:20 <tdammers> and it expands them at compile time
04:03:32 <tdammers> which is great, except that recursive templates break the compiler
04:03:33 <tdammers> :P
04:05:30 <bitonic> OK, the problem *is* the executable target.
04:08:22 <bitonic> does anybody know how to make ghc-mod skip executable targets?
04:08:32 <mcstar> i was wondering if it possible to match multiple alternatives in case
04:08:37 <mcstar> it is*
04:08:47 <bitonic> the problem is that the executable target needs the library itself, and ghc-mod doesn’t seem to like that
04:08:52 <bitonic> mcstar: what do you mean?
04:09:01 <mcstar> like: case something of pattern1 OR pattern2 -> dothis
04:09:28 <bitonic> mcstar: no.
04:09:32 <bitonic> OCaml can :P
04:09:35 <mcstar> yeah
04:10:06 <bitonic> doing that has certain subtleties - you have to bind variables with the same types etc.  I’m not sure it’s worth it
04:10:16 <t7> my C code is just a huge ladder of DoThing(); if(!thing) goto ERR_THING;  :(
04:10:24 <mcstar> ill work around it
04:11:03 <zhulikas> you may guard it
04:11:10 <mcstar> no, that wont work
04:11:21 <mcstar> i could derive Eq on my data
04:11:29 <mcstar> and just use logical or
04:11:30 <zhulikas> or both patterns may refer same function in their body
04:11:38 <zhulikas> and then where function = ... in the end
04:11:42 <bitonic> mcstar: using Eq instead of patterns is a bad idea most of the times
04:12:07 <bitonic> and you can’t bind when using Eq, which is usually what you want to do
04:12:09 <mcstar> well, it is not a bad choice, the data is like a tag
04:12:18 <mcstar> like a multiple choice bool
04:12:39 <mcstar> they are yesod handler types :)
04:12:47 <mcstar> zhulikas: ^^
04:16:10 <statusfailed> is naming variables the same as their type variables a bad idea/
04:16:22 <mcstar> you cant
04:16:31 <bitonic> statusfailed: no, the scope is different anyway
04:16:35 <bitonic> so there is no ambiguity
04:16:55 <statusfailed> but it is considered uncouth? :D
04:17:12 <hiptobecubic> i think the same is ok
04:17:15 <statusfailed> i'm finding it clearer
04:17:28 <hiptobecubic> don't have 'a' and 'b' in type variables correspond to 'b' and 'a' in value
04:17:37 <bitonic> statusfailed: it’s your choice really, use your taste
04:17:55 <bitonic> but you’ll never shadow variables that way
04:17:56 <statusfailed> bitonic: therein lies the rub :D
04:18:12 <statusfailed> I have no taste!
04:18:15 <statusfailed> just ask my wardrobe
04:18:22 <bitonic> statusfailed: well I wanted to get the technical issues out of the way :)
04:18:39 <statusfailed> haha, cheers :P
04:19:55 <mcstar> the template magic already derivied Eq for me
04:20:01 <mcstar> derived*
04:20:31 <mcstar> isAuthorized handler _ | handler == RootR || handler == QueryR = do
04:20:42 <mcstar> at least, it fits on 1 line
04:20:56 <alessandro>  why should I specify a LICENCE file in a cabal package if I already told the license is MIT?
04:21:03 <alessandro> -s+c
04:21:39 <zhulikas> why don't you define authorization rules in foundation file?
04:21:39 <hiptobecubic> So people know exactly what license you used?
04:21:45 <merijn> alessandro: Because most licenses require you to provide the license in the project, and people will expect you to
04:22:10 <mcstar> zhulikas: if you remember, i told you i dont use scaffolding
04:22:25 <zhulikas> oh, ok. And I don't remember that :)
04:22:31 <mcstar> and it is defined where it should be, part of an instance declaration for the Yesod typeclass
04:23:28 <zhulikas> I'd say pattern match is prettier than this
04:23:57 <mcstar> ok, but the body of isAuthorized is the same for RootR and QueryR
04:24:08 <mcstar> and i dont want to repeat that
04:24:35 <mcstar> other option, is a nested case, which would look worse
04:25:27 <merijn> mcstar: Define a where clause with the body and call that from both guards
04:25:28 <sopvop> ghc need -XCaseFallThroughLikeInC
04:25:52 <mcstar> merijn: yeah...
04:26:05 <mcstar> i think ill stick to ==
04:26:32 <hpaste> b__ pasted “Earlier I asked for ways to write `liftM2 (&&) (x <) (< y)' etc.” at http://hpaste.org/78539
04:28:08 <basdirks_> so now it would be \a b c -> a >. c .< b
04:28:14 <basdirks_> which I realise isn't pretty either
04:28:22 <alessandro> sopvop: what would that mean?
04:29:52 <beaky> hello
04:31:40 <beaky> is there an inverse to map? i.e. something that takes a value of type a and a list of (a -> b), and returns a list of values of type b?
04:32:21 <beaky> @hoogle a -> [a -> b] -> [b]
04:32:22 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
04:32:23 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
04:32:23 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
04:32:27 <beaky> oh
04:32:28 <srhb> :t \a fs -> map ($a) fs
04:32:30 <lambdabot> a -> [a -> b] -> [b]
04:32:32 <srhb> Oh, Applicative
04:32:59 <beaky> 0 <**> [\_ -> 1]
04:33:02 <beaky> > 0 <**> [\_ -> 1]
04:33:04 <lambdabot>   Ambiguous occurrence `<**>'
04:33:04 <lambdabot>  It could refer to either `Control.Applicative....
04:33:39 <beaky> > 0 <*> [\_ -> 1]
04:33:42 <lambdabot>   Could not deduce (GHC.Num.Num [(t0 -> a0) -> b])
04:33:42 <lambdabot>    arising from the ambigu...
04:33:51 <mcstar> change the order
04:33:59 <mcstar> btw, thats const 1
04:34:17 <mcstar> > [const 1] <*> 0
04:34:19 <lambdabot>   No instance for (GHC.Num.Num [a0])
04:34:19 <lambdabot>    arising from the literal `0'
04:34:19 <lambdabot>  Possibl...
04:35:04 <mcstar> oh
04:35:14 <mcstar> thats not good isnt it
04:35:26 <mcstar> <**> would be [a] -> [a -> b] -> [b]
04:36:17 <mcstar> (\a fs -> map ($a) fs) 0 (const 1)
04:36:19 <mcstar> > (\a fs -> map ($a) fs) 0 (const 1)
04:36:21 <lambdabot>   Couldn't match expected type `[a0 -> b0]'
04:36:21 <lambdabot>              with actual type `b1...
04:36:32 <mcstar> > (\a fs -> map ($a) fs) (const 1) 0
04:36:34 <lambdabot>   Could not deduce (GHC.Num.Num [(b0 -> a0) -> b])
04:36:34 <lambdabot>    arising from the ambigu...
04:36:36 <neutrino_> regexdot - haskell package of the month?
04:37:39 <FireFly|> @ty curry inRange
04:37:40 <lambdabot> Ix b => b -> b -> b -> Bool
04:37:43 <mcstar> > (\a fs -> map ($a) fs) 0 [const 1]
04:37:44 <lambdabot>   [1]
04:38:13 <FireFly|> basdirks_: if you limit the function to operate on things in Ix, you could use ^ I think
04:38:36 <sopvop> alessandro: Mean case a of Foo _ _ ->; Bar _ _ -> do Something, no binds :)
04:39:11 <basdirks_> FireFly|, aha, I'll have a look =]
04:39:18 <Spockz> sopvop: to force evaluation?
04:39:46 <GHAI> hey
04:39:55 <neutrino_> hi
04:40:13 <GHAI> i wonder how i can import custom modules that lie in a subfolder
04:40:16 <sopvop> Spockz: Nay, just fall to next pattern match. I don't need it, it was relevant to discussion before that
04:40:22 <GHAI> import custommodule with custommodule in the same folder works
04:40:31 <GHAI> anyhow, 'ld like to load it from a subfolder
04:40:34 <GHAI> or a random folder
04:40:54 <sopvop> import Folder.Folder.Module
04:41:05 <Spockz> sopvop: ah so you can say if this or that or that do yada
04:41:15 <neutrino_> if it's in a subfolder: import Foo.Bar.Baz; it'll import from Foo/Bar/Baz.hs; in that file write "module Foo.Bar.Baz where"
04:41:18 <sopvop> Spockz: yes
04:41:28 <neutrino_> if you want it from a random folder: you have to cabal install that module
04:41:44 <Spockz> sopvop: I believe there is a library for that
04:42:11 <Spockz> sopvop: http://hackage.haskell.org/package/first-class-patterns
04:45:43 <Spiders>  /server irc.blackirc.org 6667
04:46:42 <nerko> @run
04:46:44 <lambdabot>   not an expression: `'
04:46:51 <Spiders> free cc visa master check cc  /server irc.blackirc.org 6667
04:46:56 <Spiders> free cc visa master check cc  /server irc.blackirc.org 6667
04:46:56 <Spiders> free cc visa master check cc  /server irc.blackirc.org 6667
04:46:56 <Spiders> free cc visa master check cc  /server irc.blackirc.org 6667
04:46:57 <Spiders> free cc visa master check cc  /server irc.blackirc.org 6667
04:47:44 <nerko> @run map
04:47:46 <lambdabot>   *Exception: show: No overloading for function
04:48:05 <nerko> @run map  (+1) [1..10]
04:48:07 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
04:48:30 <typoclass> nerko: hello, welcome. lambdabot is also available in private chat
04:48:47 <mSSM> I have a question about stateful computations: in the definition of (>>=) on http://learnyouahaskell.com/for-a-few-monads-more#state , I don't understand why `h' from `(State h)' is a stateful computation. From the type constructor `State a b', shouldn't `h' be a state?
04:49:24 <merijn> mSSM: "h" is the state of the stateful computation "State h"
04:49:52 <merijn> or, stateful computation "State h a" depending how you want to look at things
04:49:55 <mSSM> merijn: Indeed; but how can he apply `s' to `h'?
04:50:16 <merijn> mSSM: Oh, are you maybe confusing the State type constructor with the State data constructor?
04:50:19 <mSSM> merijn: in: (a, newState) = h s
04:50:21 <nerko> @run map (+1)[1..10]
04:50:23 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
04:50:30 <nerko> @type map
04:50:32 <lambdabot> (a -> b) -> [a] -> [b]
04:50:49 <mSSM> merijn: I am not sure :( I am just trying to follow that book.
04:50:56 <merijn> mSSM: That's a data constructor, like Just is a constructor for Maybe.
04:51:05 <merijn> mSSM: State is a constructor for the type State
04:51:17 <statusfailed> is higher fixity more strongly binding?
04:51:24 <merijn> statusfailed: Yes
04:51:27 <statusfailed> cheers
04:51:39 <mSSM> merijn: and it has one field, s -> (a,s)
04:51:48 <mSSM> merijn: so State wraps a function
04:51:52 <merijn> mSSM: Yes
04:52:27 <mSSM> merijn: so what do I get if I specify (State h) ?
04:52:35 <mSSM> merijn: Is h a function?
04:52:48 <mSSM> merijn: Isn't it a partially applied type constructor?
04:53:08 <merijn> mSSM: If "h" has type "Foo" then "State h" is a value of type "State Foo"
04:53:23 <merijn> Actually, that's a bad example
04:53:27 <merijn> Let's take a concrete function
04:54:08 <hpaste> romildo pasted “download.hs” at http://hpaste.org/78540
04:54:14 <romildo> I want to download a page from imdb. To do that I have written the program http://hpaste.org/78540
04:54:23 <merijn> mSSM: Let's say we have a counter (Int) state and a h function that checks whether the value of the counter is even
04:54:35 <romildo> But it fails to get the page contents.
04:54:42 <hpaste> killy9999 pasted “WTF?!” at http://hpaste.org/78541
04:54:50 <romildo> With wget I can get the page without problems.
04:54:53 <romildo> Any clues?
04:54:57 <merijn> mSSM: So "h" has the type "Int -> (Bool, Int)", right? (takes an Int state and returns the Int state + a Bool saying whether it is even)
04:55:13 <killy9999> can anyone tell me what these messages about bailing out mean?
04:55:27 <mSSM> merijn: indeed
04:55:32 <mSSM> merijn: if you define it that way
04:55:48 <merijn> mSSM: Ok, now let's take a look at the State type "newtype State s a = State { runState :: s -> (a,s) }"
04:56:04 <mSSM> merijn: State is a type constructor, right?
04:56:11 <mSSM> merijn: with type parameters s and a
04:56:39 <merijn> mSSM: State is both a type *and* a data constructor. The type constructor has parameters s and a and the data constructor has one parameter of type "s -> (a, s)"
04:56:50 <typoclass> romildo: so, the problem is that line 22 outputs an empty string?
04:56:54 <mSSM> merijn: hmmmmmmm
04:57:10 <mSSM> merijn: So how do I know if I call State as a type constructor as compared to a data constructor?
04:57:21 <romildo> typoclass, yes
04:57:23 <merijn> If "h :: Int -> (Bool, Int)" and "State :: State s a" then "State h :: State Int Bool"
04:57:35 <merijn> mSSM: Type constructors can only appear in type signatures, so it's never ambiguous
04:58:04 <merijn> "State id" <- data constructor "foo :: State Int Bool" <- type constructor
04:58:05 <typoclass> romildo: hmm! try to change line 15, replacing "rspBody" with "show". i'm assuming a Response has a useful Show instance
04:58:55 <mSSM> merijn: ahaaa
04:58:57 <mSSM> ok
04:59:00 <merijn> mSSM: It's common to have a data constructor with a name identical to the type constructor in cases where you have only one data constructor.
04:59:03 <mSSM> merijn: ok, cool
04:59:05 <mSSM> merijn: thanks
04:59:19 <mSSM> merijn: if you say that type constructors can only appear in signatures, then it's cool
04:59:39 <mSSM> merijn: which is automatically the case for newtype
04:59:55 <mSSM> merijn: I mean > It's common to have a data constructor with a name identical to the type constructor in cases where you have only one data constructor.
04:59:58 <merijn> mSSM: signatures or type annotation (which are essentially just inline signatures anyway, i.e. "1 :: Int")
05:00:16 <nand`windows> What type do GHCi macros have again? String -> String or String -> IO String?
05:00:20 <merijn> mSSM: Yes, newtypes can never have more than one, so they're almost always the same there
05:00:56 <mSSM> merijn: Btw, is it wrong if I see newtypes as a restricted version of data?
05:01:03 <mcstar> String->String wouldnt be very useful
05:01:06 <mSSM> merijn: With the only difference being that they are cheaper?
05:01:11 <merijn> :t return :: State Int -- this is a type constructor too
05:01:12 <lambdabot>     Expecting one more argument to `State Int'
05:01:12 <lambdabot>     In an expression type signature: State Int
05:01:12 <lambdabot>     In the expression: return :: State Int
05:01:22 <nand`windows> mSSM: no, newtypes are restricted versions of data; namely with only one constructor and only one field
05:01:23 <romildo> typoclass, with the suggested change the program does not compile: No instance for (Network.TCP.HStream ty0) arising from a use of `simpleHTTP'
05:01:29 <merijn> mSSM: Well, they're subtlely different, but you are mostly correct
05:01:40 <nand`windows> ah, but yes, they have very subtle differences
05:01:43 <mSSM> nand`windows: Didn't I just say that?
05:01:48 <typoclass> romildo: hrmpf
05:01:56 <nand`windows> mSSM: 'no' means 'no it is not wrong'
05:02:06 <mSSM> nand`windows: oh
05:02:14 <nand`windows> mSSM: you can pattern match on a newtype without inspecting the value at all
05:02:18 <mSSM> nand`windows: of course you are semnatically correct :)
05:02:29 <nand`windows> so (\Newtype _ -> foo) _|_ = foo
05:03:01 <merijn> mSSM: "data Foo a = Foo a" this is fine "case Foo undefined of Foo a -> ()" "newtype Foo a = Foo a" this is an exception "case Foo undefined of Foo a -> ()"
05:03:02 <mSSM> nand`windows: this is pseudo code, right?
05:03:19 <nand`windows> mSSM: it's nearly correct
05:03:28 <nand`windows> a correct example could be
05:03:30 <mcstar> > (\(Just _) -> 1) undefined
05:03:32 <lambdabot>   *Exception: Prelude.undefined
05:03:38 <nand`windows> (\(Newtype _) -> foo) undefined == foo
05:03:47 <hpaste> romildo annotated “download.hs” with “download.hs (annotation)” at http://hpaste.org/78540#a78542
05:03:50 <nand`windows> > (\(First _) -> 1) undefined
05:03:53 <lambdabot>   1
05:03:57 <nand`windows> First is a newtype
05:03:59 <merijn> mSSM: i.e. pattern matching on a constructor with an undefined value works for data, but results in undefined for newtypes. That's pretty much the only difference
05:04:02 <mcstar> interesting
05:04:11 <romildo> typoclass, but I have added the action putStrLn (show src) in openURI: http://hpaste.org/78540
05:05:03 <mSSM> merijn: ok, thanks, I will contemplate over that
05:05:05 <mSSM> nand`windows: thank you too
05:05:30 <mSSM> merijn: Just one question.... your example and what nand`windows just gave me are not saying the opposite, are they?
05:05:32 <nand`windows> at the end of the day
05:05:38 <nand`windows> it's a consequence of newtypes having no implementation overhead
05:05:45 <merijn> mSSM: No, they're the same
05:05:53 <mSSM> Coz nand`windows pattern matched a Newtype, resulting in 1
05:05:54 <nand`windows> they're virtual; you can't pattern match on them, they aren't represented differently in memory
05:05:56 <hpaste> romildo pasted “output of download” at http://hpaste.org/78543
05:06:00 <mSSM> whereas the data version got an exception
05:06:04 <romildo> typoclass, and the output is: http://hpaste.org/78543
05:06:05 <hpaste> typoclass annotated “download.hs” with “download.hs (annotation)” at http://hpaste.org/78540#a78544
05:06:05 <nand`windows> the only difference between a newtype and what it wraps is at compile time (excluding instances)
05:06:39 <typoclass> romildo: right. i've run the program now and made an annotation. i think it's pretty clear where the problem is :-)
05:06:39 <merijn> mSSM: It's fairly intuitive. Newtype is discarded at compile time (i.e. it has no constructor representation at runtime) which means there is nothing there to safely "wrap" the undefined
05:07:03 <merijn> mSSM: data has a runtime value representing the constructors which can safely hide undefined values away until you evaluate them
05:07:47 <mSSM> merijn: ah, so the case expression for data will just evaluate to () no matter what
05:08:04 <mSSM> mSSM: whereas the newtype will actually see an undefined
05:08:28 <typoclass> romildo: i wonder now how you can make the HTTP package follow redirects. i've used the alternative http-conduit the other day, and with that i could easily turn that on and off
05:09:16 <romildo> typoclass, it is not that clear to me.
05:09:49 <romildo> typoclass, has this uri been redirected to another uri?
05:10:11 <merijn> mSSM: Yes
05:10:31 <typoclass> romildo: oh sorry. the server is sending a status code 301, meaning "moved permanently". it's giving you a new url that you should contact. the important lines are 29 and 33 in the paste
05:10:40 <merijn> mSSM: All other semantics are the same
05:10:55 <typoclass> romildo: normally, a good http client library can do that for you, but i'm still searching in the haddock of the http package ...
05:11:10 * mcstar wonders if he should change his nick to mcstar`apple when he's eating apples
05:11:44 <mSSM> people with `windows in their name must be looking out of windows :)
05:11:51 <zhulikas> definitely
05:12:03 <typoclass> anyone know how to get the HTTP package to follow redirects? (301, 302 etc.)
05:12:10 <zhulikas> longing for something
05:12:39 <mSSM> but what would name`GNU/Linux mean?
05:13:17 <neutrino_> slashfic title
05:13:45 <zhulikas> mSSM, it's not allowed!
05:14:03 <zhulikas> what doesn't make sense isn't even allowed
05:14:08 <mSSM> zhulikas: Indeed
05:14:14 <mSSM`Gnu\Linux> There
05:14:18 <mSSM`Gnu\Linux> Backslash worx
05:14:22 <zhulikas> hax0r
05:15:04 <typoclass> romildo: hm, at the moment i can't figure out how to turn on redirects in the HTTP package. but here's an alternative: use the package http-conduit. it's very easy to use, and it follows redirects by default http://hackage.haskell.org/packages/archive/http-conduit/1.8.3/doc/html/Network-HTTP-Conduit.html (see first example)
05:16:09 <mcstar> i cant make myself root: /: Erroneous Nickname
05:17:04 <romildo> typoclass, ok, I will take a look at htpp-conduit. thank you for helping.
05:17:31 <ocharles> can anyone help me make sense of https://gist.github.com/038fce968c58287b9734 ?
05:17:43 <typoclass> romildo: you're welcome
05:17:48 <ocharles> does that mean hashable was built against bytestring 0.9.2.1, not bytestring 0.10.2.0?
05:18:40 <ocharles> 'ghc-pkg describe hashable' seems to indicate so - how do I get it to use bytestring-0.10.2.0?
05:25:51 <fmap> reinstall?
05:40:04 <sopvop> my template haskell code looks like lisp
05:40:44 <sopvop> like: appE (varE 'schemaOf) (sigE (varE 'undefined) (return typ))
05:43:47 <Saizan> ... `appE` ..
05:44:44 <sopvop> and ($), (&), (.) :)
05:45:54 <sopvop> varE 'schemaOf & appE $ varE 'undefined `sigE` return typ
05:46:03 <sopvop> nay, don't like it
05:48:12 <mm_freak> sopvop: i don't find that code ugly
05:49:16 <mm_freak> except perhaps for using `appE` i'd leave it as it is
05:49:33 <sopvop> looks ok, just lispy :)
05:54:08 <Saizan> & and $ is too much :)
05:56:28 <sopvop> So TH, I have a record Foo a = Foo { foo :: a }. But type in (VarStrictType) is some kind of a_aRXMr.
05:56:36 <sopvop> How do I get that :: a thing?
05:57:28 <shachaf> ?
05:59:49 <sopvop> hm, I'll do it other way
06:06:24 <ocharles> fmap: i have, it keeps choosing bytestring 0.9
06:07:19 <shachaf> ocharles: Use -v?
06:07:39 <ocharles> 'Dependency bytestring ==0.9.2.1: using bytestring-0.9.2.1'
06:07:55 <shachaf> Well then.
06:07:56 <ocharles> but http://hackage.haskell.org/package/hashable says 1.1.2.5 uses >= 0.9
06:08:02 <ocharles> so i don't quite get what's going on
06:08:28 <shachaf> Which version?
06:08:34 <ocharles> of hashable?
06:08:47 <ocharles> or cabal?
06:08:58 <shachaf> hashable
06:09:03 <ocharles> 1.1.2.5
06:09:11 <shachaf> I bet cabal is telling you some information you're not telling us. :-)
06:09:15 <ocharles> i'll paste -v
06:09:36 <ocharles> https://gist.github.com/35ba90b9b776ad3789ba
06:10:01 <shachaf> OK, maybe -v3
06:10:10 <ocharles> weeeeee
06:10:32 <shachaf> By the way, those packages that it says will probably be broken will probably be broken.
06:10:35 <ocharles> it just seems to try bytestring-0.9.2.1 first and is happy with it
06:10:43 <fmap> wait, 7.4.1?
06:10:50 <ocharles> yea
06:11:01 <ocharles> https://gist.github.com/7423126ab7a80fa857f2 -v3
06:11:10 <shachaf> What do you want bytestring 0.10 for, anyway?
06:11:21 <ocharles> 0.10.2 has toStrict and fromStrict which i'm using
06:11:32 <shachaf> Oh.
06:11:32 <ocharles> i could define them myself but... meh
06:11:38 <ocharles> someone else has already done it :)
06:11:42 <shachaf> I think that requires GHC 7.6 or something.
06:11:47 <ocharles> oh, bah
06:11:55 <ocharles> well it's installed
06:11:56 <shachaf> Just write them yourself. They're one line each.
06:12:00 <ocharles> i have bytestring-0.10.2 installed fine
06:12:05 <shachaf> OK, but it won't be compatible with anything, or something.
06:12:23 <ocharles> but ghc-pkg unregister bytestring-0.10.2 complains that it would break things by unregistering
06:12:24 <shachaf> fromStrict x = L.fromChunks [x]
06:12:29 <ocharles> sure
06:12:41 <shachaf> toStrict = S.concat . L.toChunks
06:12:42 <ocharles> ah wait, i'm lying, unregistering was just fine
06:12:59 <ocharles> well, you've written them now, so I guess a quick C-space C-y is quicker than fixing this :)
06:13:27 <shachaf> This has happened quite a lot recently.
06:14:00 <shachaf> I mean someone coming in, asking how to use bytestring 0.10, and eventually figuring out that all they wanted was toStrict/fromStrict and they were using GHC 7.4.
06:14:10 <shachaf> This should probably be more apparent.
06:14:26 <ocharles> i know how to do it myself
06:14:36 <ocharles> but the point is someone else has done it, so i don't want to do it myself
06:14:41 <shachaf> Right.
06:14:47 <shachaf> The incompatibility should be more apparent.
06:14:51 <ocharles> ah
06:15:21 <shachaf> Oh well. We only have until the next GHC release to have the exact same thing happening with a new version of bytestring!
06:15:28 <ocharles> haha
06:25:02 <Sculptor> friday! hi!
06:26:26 <hpaste> sopvop pasted “TH success!!!” at http://hpaste.org/78546
06:27:03 <sopvop> It's not that hard.
06:35:51 * ocharles wonders what sopvop is working on
06:37:41 * hackagebot hjsmin 0.1.4 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.4 (AlanZimmerman)
06:42:09 <sopvop> ocharles, deriving json and schema for it
06:44:06 <beaky> are there any notable GUI applications in haskell?
06:44:18 <beaky> that ican learn from
06:45:19 <borkdude> is there anything for Haskell in this vein? http://pythontutor.com/visualize.html
06:45:26 <borkdude> preferably online
06:45:52 <neoChat> http://www.neochat.co.uk - New chat community, make it your new home!!!
06:47:17 <quchen> Like there's need for another channel besides #haskell
06:48:36 <mSSM> If I define `pop = State $ \(x:xs) -> (x,xs)', and then chain two pops `pop >>= pop', will the argument given to the second pop simply be ignored? C.f. the definition of >>= here http://learnyouahaskell.com/for-a-few-monads-more#state
06:49:15 <Botje> mSSM: you will get a type error
06:49:37 <mSSM> I.e., when the second pop is invoked on the result of the stateful computation of the first pop
06:49:47 <quchen> mSSM: 1. pop doesn't have an argument, 2. what you want is composition here
06:50:06 <mSSM> quchen: Yes, that's why I am askin.g
06:50:09 <quchen> Something like pop2 = pop >=> pop
06:50:44 <quchen> It often helps me to write everything in do notation to understand what happens. In your case, what you want to do is getting the second element on the stack.
06:50:51 <mSSM> quchen: Oh, yes; I wrote that out the wrong way
06:51:00 <mSSM> quchen: pop >>= \_ -> pop
06:51:03 <quchen> That would make do { x <- pop; y <- pop; return y}
06:51:23 <quchen> eh wait, that example is rubbish above, ignore
06:51:34 <quchen> Oh wait, nevermind, it's not, don't ignore haha
06:52:08 <mSSM> quchen: do { pop ; pop } is just `pop >>= \_ -> pop' ?
06:52:45 <quchen> Desugaring do notation works like this: do { expr } == expr
06:53:09 <quchen> do { expr; more } = expr >> do more
06:53:21 <mSSM> quchen: >> is defined in terms of >>=
06:53:35 <quchen> do { x <- expr; more } == expr >>= \x -> do more
06:54:03 <quchen> Yes it is.
06:54:11 <tdammers> a >> b = a >>= \_ -> b
06:54:11 <mSSM> do { expr; more } == expr >>= \_ -> do more
06:54:21 <tdammers> something like that
06:54:28 <quchen> That's right
06:56:04 <quchen> Wait, so what exactly is it what you want to do?
06:56:07 <quchen> Pop twice?
06:56:18 <mSSM> quchen: Understand the example in LYAH
06:56:32 <mSSM> quchen: by following the definition of >>= for the State monad
06:56:36 <mSSM> and it all works
06:56:38 <mSSM> yay
06:57:16 <mSSM> because in my example above (which was wrong): pop >>= \_ pop will give me (State g) = \_ pop $ a
06:57:23 <mSSM> oops
06:57:31 <mSSM> (State g) = \_ -> pop $ a
06:57:43 <notdan> I am writin a piece of code which involves generating unique ids (like gensym). Should I use ST monad or just pass the list of avaliable symbols around?
06:57:50 <mSSM> where a is the result from the first stateful computation
06:58:05 <mSSM> \_ -> pop $ a   ==  pop
06:58:25 <mSSM> Cool!
06:58:42 <mSSM> Haskell can make sense if it really tries hard!
06:59:15 <byorgey> notdan: ST monad is certainly not necessary.  If you want to use a monad, use something like the  monad-supply  package
06:59:16 <nicoo> mSSM: I would say you ought to use ST.
06:59:25 <quchen> mSSM: Levelup!
06:59:27 <byorgey> notdan: which just automates the process of passing a list of available symbols around
06:59:46 <mSSM> nicoo: what?
06:59:55 <mSSM> nicoo: I should not use the State Monad?
06:59:57 <nicoo> mSSM: Sorry, I was answering notdan
06:59:58 <notdan> byorgey: thanks! i didn't know about such monad
07:06:48 <merijn> mSSM: And thus enlightenment was achieved ;)
07:12:04 <mSSM> merijn: too much enlightenment happneing
07:12:06 <mSSM> it's blinding
07:12:52 <quchen> I think once you understand State you're basically over the monad hill
07:12:53 <mSSM> The naming LYAH uses for states is actually really confusing
07:13:16 <merijn> mSSM: A little bit, yeah
07:13:18 <mSSM> Because the State _monad_ is of course very different from the "state" which he describes
07:13:43 <mSSM> Because the State monad actually holds a stateful computation
07:13:46 <quchen> LYAH uses the State State monad ;-)
07:14:07 <quchen> Well, it's actually kind of hard to talk about "the s in State s".
07:14:15 <quchen> I guess that's where the ambiguity comes from
07:14:18 <mSSM> quchen: but that's the problem
07:14:24 <merijn> mSSM: Well, the State constructors also holds a stateful computation, it's just a very boring one
07:14:31 <mSSM> Confused the holy bejesus outa me
07:14:40 <quchen> I think you could call s the "current state"
07:14:49 <merijn> mSSM: The State monad just lets you chain them together and transport the extra argument through everything
07:14:54 <mSSM> merijn: the State constructor should be called the StatefulComputation constructor
07:15:15 <mSSM> I don't care if it's long
07:15:22 <merijn> mSSM: Yeah, I'll grant you that might be less confusing
07:16:15 <merijn> mSSM: Small word of caution, the State constructor described in LYAH no longer exists (to make using monad transformers easier, you'll get to that later) and is now the "state" function
07:16:19 <merijn> :t state
07:16:21 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:16:30 <merijn> bah, not that one I wanted
07:16:43 <merijn> :t Control.Monad.Trans.State.state
07:16:44 <lambdabot> Monad m => (s -> (a, s)) -> StateT s m a
07:17:20 <merijn> mmm, I thought there was a friendly typed version. Guess I'm wrong
07:17:32 <mSSM> merijn: oh
07:17:35 <mSSM> what does that mean for me?
07:17:48 <mSSM> What's StateT ?
07:17:55 <merijn> mSSM: The only thing it really means in practice is that you use "state f" instead of "State f" :p
07:18:38 <basdirks_> _at k .~ v $ myMap does not set k:v if k does not exist
07:18:52 <quchen> mSSM: Ignore the T and the m. Read it as "state :: (s -> (a, s)) -> State s a"
07:18:54 <merijn> mSSM: It's the state monad transformer (i.e. it transforms a monad into a monad that can use state) but you can use it without understanding the entire transformer business
07:18:56 <mSSM> so state now takes a "stateful computation", wraps the result `a' into the monad `m', and the new state `s' with the `m a` monad-result into the monad StateT
07:19:06 <basdirks_> is there a way to insert k:v regardless of whether k is set?
07:19:34 <mSSM> basdirks_: pattern matching?
07:19:44 <basdirks_> I mean with _at
07:19:46 <basdirks_> and lenses
07:19:48 <merijn> :t Control.Monad.Trans.State.state :: (s -> (a, s)) -> State s a
07:19:50 <lambdabot> (s -> (a, s)) -> State s a
07:20:21 <merijn> mSSM: As you see it still accepts the same type signature you just learned. So you can pretend nothing changed
07:20:39 <rwbarton> you can use "at k .~ Just v"
07:20:49 <shachaf> :t id :: (Int, Double -> Double, String -> ([a], Char)) -> (Int, Double -> Double, String -> ([a], Char))
07:20:50 <lambdabot> (Int, Double -> Double, String -> ([a], Char)) -> (Int, Double -> Double, String -> ([a], Char))
07:20:53 <shachaf> rwbarton: at k ?~ v
07:21:02 <mSSM> merijn: but how is the State class defined now?
07:21:03 <merijn> (aside from the capitalisation of the s, which is important to know, since writing "State f" will produce a compile error that there's no such thing as a "State" constructor)
07:21:08 <mSSM> merijn: type*
07:21:10 <mSSM> sorry
07:21:37 <merijn> mSSM: State is now defined as "type State s a = StateT s Identity a" where Identity is the trivial identity monad that does nothing
07:21:48 <mSSM> wtf
07:22:01 <quchen> mSSM: As long as you're just reading LYAH: that's a good definnition of the state monad there.
07:22:09 <merijn> mSSM: Just forget that part for now and remember "State f" -> "state f"
07:22:34 <rwbarton> @type (?~)
07:22:36 <lambdabot> Setting s t a (Maybe b) -> b -> s -> t
07:22:38 <merijn> mSSM: (when you want to write code using State that is)
07:22:41 <rwbarton> @type (.~)
07:22:42 <lambdabot> Setting s t a b -> b -> s -> t
07:22:53 <fari> hey guys, i could use a hint with this this task, having Gen from  QuicCheck, define sizedInt :: Gen Int just using ask, lift and  System.Random.randomR so it returns radom value
07:22:55 <basdirks_> thanks rwbarton, shachaf
07:23:15 <mSSM> merijn: I think I do need to do that; because what I am doing right now is super ugly.
07:23:25 <quchen> The real implementation of the State monad is complicated, and in some special case (that looks awful when you write it down) it becomes the state monad LYAH uses in its example.
07:23:28 <mSSM> merijn: Don't know how to do it better, but I can tell that there has to be a better way.
07:23:29 <fari> i have been seriously trying to solve it for hours, but no sucess
07:23:36 <merijn> mSSM: I was just trying to preemptively prevent confusion when you try to write code using State and it suddenly complains with an obscure error
07:23:45 <shachaf> l ?~ b = l .~ Just b
07:23:48 <mSSM> merijn: ok
07:23:53 <mSSM> merijn: I will come crying here for help :)
07:23:59 <merijn> mSSM: (i.e. that the State constructor doesn't exist)
07:24:03 <shachaf> It's sort of the counterpart of a ^? b
07:24:51 <mSSM> merijn: ok, so what for example if I were to write down a type for a function, like the pop in LYAH: pop :: State Stack Int
07:25:03 <merijn> mSSM: That will work
07:25:05 <mSSM> merijn: Stack is just some type for [Int], me thinks
07:25:26 <mSSM> merijn: Ah, right, because State is now just a new name for that other stuff
07:25:46 <mSSM> i.e., StateT is the general case
07:26:02 <merijn> mSSM: Exactly, and State "degeneralises" to what you read in LYAH
07:26:03 <quchen> mSSM: Yes, he defines "type Stack = [Int]" somewhere above.
07:26:10 <mSSM> and State is an example with a' = Identity a
07:26:25 <mSSM> Bloody mathematicians.
07:26:39 <mSSM> That's what you get if you let them write a language. :D
07:26:46 <shachaf> What do mathematicians have to do with it?
07:26:54 <shachaf> "State" isn't very mathematiciany.
07:27:02 <mSSM> I don't know; finding general cases for one.
07:27:14 <quchen> Well, coding every special case is very tedious.
07:27:18 <mSSM> i.e. generalizations of*
07:27:22 <`nand`> mathematicians are to blame for all generalizations
07:27:33 <`nand`> to be blamed*
07:27:48 * hackagebot base-compat 0.1.0 - Provides readMaybe, lookupEnv, etc. for older versions of base  http://hackage.haskell.org/package/base-compat-0.1.0 (SimonHengel)
07:28:06 <merijn> mSSM: But since it's just a synonym it can't have constructors, which is why the function "state" is provided to get the functionality of the old constructor back.
07:28:18 <mSSM> that makes sense
07:28:22 <quchen> Imagine this was C and the "id" function had to have a separate instance for every argument. int id(int x), float id(float x), ...
07:28:39 <mSSM> quchen: I didn't complain. :)
07:28:40 <quchen> Haskell does it better and makes "id" derivable from whatever type you use it on.
07:28:46 <mSSM> quchen: I was just swearing at them. :)
07:29:00 <quchen> Oh, well then that's fine I guess
07:29:07 <quchen> I think the Haskell report demands swearing every now and then
07:29:25 <mSSM> merijn: I understand that; it seems messy though.
07:29:46 <mSSM> merijn: i.e. generalizing on one hand, but then the requirement to make a new function for the constructor.
07:29:49 <`nand`> quchen: I hope not. Haskell should be a gentle language :()
07:29:51 <`nand`> :(*
07:29:58 <merijn> mSSM: Once you've played around with this and started playing with transformers you'll be happy with the change :p
07:30:20 <mSSM> Is anyone of you enough of a wizard to use this stuff in daily work?
07:30:25 <mSSM> Or do you just do this for fun?
07:31:01 <djahandarie> I don't use it at my job, but I do use it for 'daily work'.
07:31:07 * `nand` uses Haskell for pretty much every problem. He doesn't work as a programmer though, so that probably doesn't answer your question
07:31:08 <djahandarie> Lots of people do use it for their jobs.
07:31:08 <merijn> mSSM: I use it for my daily work
07:31:22 <shachaf> mSSM: The trick is that generalizing makes things easier to think about, rather than harder.
07:31:40 <`nand`> not for everybody
07:31:57 <mSSM> `nand`: Well, I am not a programmer either; but I have gotten the stupid idea to write my simulations with it...
07:32:10 <S11001001> mSSM: writing boilerplate gets tedious
07:32:18 <`nand`> that being said; the State/StateT generalization is pretty much bread and butter
07:32:20 <mSSM> shachaf: thinking, yes; learning, no
07:32:26 <merijn> mSSM: I have to admit that it took me quite a bit to be comfortable with the large amount of stuff to learn for "practical use", now that I know it it really cuts back on the amount of boilerplate (and code in general) you have to write
07:32:46 <mSSM> I love the use of the word boilerplate
07:32:55 <mSSM> I learned it in this channel yesterday. :D
07:33:23 <mSSM> merijn: That's what I want.
07:33:24 <`nand`> My Haskell curve has been a bit parabolic; starting slowly, getting into increasingly complex and complex systems. Then lenses came and it started regressing to the painfully simple
07:33:31 <quchen> Unfortunately, in Physics I usually need nothing but speed for my computations, and they're heavily array-based with array algorithms for them. But I use Haskell for most other things. :-)
07:33:49 <`nand`> quchen: what do you use? FORTRAN?
07:33:58 <merijn> mSSM: As anecdotal evidence I've reimplemented some C code in haskell and eliminated at least one order of magnitude of code
07:33:59 <mSSM> quchen: MC simulations here right now ...
07:34:00 <quchen> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
07:34:09 <Peaker> mSSM, I used to use Python and C at work. Then after I got comfortable with Haskell I use Haskell and C at work
07:34:14 <Peaker> mSSM, but it's just a personal choice
07:34:22 <mSSM> I don't like Python.
07:34:28 <quchen> I'm using C++ mostly
07:34:31 <mercury^> Hi, I want to run a MaybeT (ST s) a to get an a.  (I think that should be possible.)  My problem is that after the runMaybeT, the s is not universally quantified.  Can someone please help me out?
07:34:33 <mSSM> I don't know, people use it, but I constantly feel like there hsould be types.
07:34:56 <EvanR> pythons pretty bad
07:34:57 <sopvop> I used to love python, now I use it with disgust and fear of AttributeError
07:34:57 <Peaker> mercury^, runMaybeT converts it to: ST s (Maybe a)
07:34:58 <mSSM> Too much magic happening in Python.
07:35:10 * mSSM doesn't like magic.
07:35:22 <quchen> Python does trickery. Magic is what Haskell does.
07:35:22 <parcs`> mercury^: its type would have to be 'MaybeT (forall s. ST s) a'
07:35:23 * mSSM prefers Very No Magic in vim patterns.
07:35:23 <Peaker> If Haskell didn't exist, then for small/medium scale things, I think Python is still (one of) the nicest choice(s)
07:35:24 <mercury^> Peaker: and after that runST gives a type error.
07:35:36 <shachaf> mercury^: What's the problem?
07:35:38 <Peaker> mercury^, can you paste the code? it should work
07:35:40 <parcs`> mercury^: but i think that's an impredicative type, and ghc doesn't like those
07:35:41 <`nand`> Peaker: if Haskell didn't exist I'd probably start learning Agda
07:35:44 <EvanR> haskell isnt magical
07:35:44 <shachaf> runMaybeT :: MaybeT (ST s) a -> ST s (Maybe a)
07:35:45 <sopvop> python is nice for gui
07:35:51 <shachaf> mercury^: Works for me.
07:35:56 <rwbarton> should be fine yeah
07:35:59 <parcs`> but runST :: (forall s. ST s a) -> a
07:36:01 <rwbarton> maybe you need to add a type signature or two
07:36:03 <shachaf> λ> runST $ (runMaybeT :: MaybeT (ST s) a -> ST s (Maybe a)) (return 5)
07:36:18 <quchen> So why did you guys start with Haskell? For me, it was the funny pictures in LYAH.
07:36:26 <shachaf> Works without the signature, too.
07:36:37 <quchen> More precisely, the "Holy shit!" comment made by the sun on the start page.
07:36:56 <shachaf> Yay.
07:37:15 <Saizan> mercury^: try not using (.) or any such combinator btw, stuff gets touchy with higher-rank types
07:37:21 <`nand`> my impression of things has been that my programming language history goes monotonically uphill. Each language I familiarized with has been nicer to work with than the previous. I don't think I could go ‘backwards’ down the slope again, I have to find a language I like even better now
07:37:22 <mercury^> Well, my ghc gives me  Couldn't match type `m0 (Maybe (b0 Int Tile))' with `forall s. ST s (Maybe Grid)'
07:37:33 <mercury^> I do use (.) a lot there, yes.
07:37:35 <Tekmo> edwardk: Are you there?
07:37:36 <Peaker> quchen, because I tried implementing a structural code editor in Python and was designing my own pure functional programming DSL for the GUI composition -- and wanted to see how others solved it. Also, it was painfully slow in Python
07:37:42 <shachaf> mercury^: Is Grid = something Int Tile?
07:37:43 <mercury^> Are there any specific rule I can follow?
07:37:45 <rwbarton> well b0 Int Tile /= Grid (unless Grid is a synonym?)
07:37:51 <parcs`> :t runST . Control.Monad.Trans.Maybe.runMaybeT
07:37:52 <lambdabot>     Couldn't match expected type `forall s. ST s b0'
07:37:53 <lambdabot>                 with actual type `m0 (Maybe a0)'
07:37:53 <lambdabot>     Expected type: Control.Monad.Trans.Maybe.MaybeT m0 a0
07:37:55 <mercury^> shachaf: yeah, UArray Int Tile.
07:38:02 <parcs`> :t \x -> runST (Control.Monad.Trans.Maybe.runMaybeT x)
07:38:04 <lambdabot>     Couldn't match type `t'
07:38:04 <lambdabot>                    with `Control.Monad.Trans.Maybe.MaybeT (ST s) a'
07:38:04 <lambdabot>       `t' is a rigid type variable bound by
07:38:15 <mSSM> quchen: What problems are you working on? I.e. what field in Physics?
07:38:53 <rwbarton> :t let runMaybeST :: (forall s. MaybeT (ST s) a) -> Maybe a; runMaybeST x = runST (Control.Monad.Trans.Maybe.runMaybeT x)) in runMaybeST
07:38:54 <lambdabot> parse error on input `)'
07:38:59 <rwbarton> :t let runMaybeST :: (forall s. MaybeT (ST s) a) -> Maybe a; runMaybeST x = runST (Control.Monad.Trans.Maybe.runMaybeT x) in runMaybeST
07:39:00 <lambdabot>     Not in scope: type constructor or class `MaybeT'
07:39:01 <lambdabot>     Perhaps you meant `Maybe' (imported from Data.Maybe)
07:39:09 <quchen> mSSM: Statistical physics. The goal is finding a definition for entropy production for a Hamiltonian flow. Right now it's mostly analytical work though.
07:39:13 <rwbarton> :t let runMaybeST :: (forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> Maybe a; runMaybeST x = runST (Control.Monad.Trans.Maybe.runMaybeT x) in runMaybeST
07:39:14 <lambdabot> (forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> Maybe a
07:39:21 <rwbarton> Control.Monad.Trans.Maybe.MaybeT, what a catchy name
07:39:26 <parcs`> > runST (Control.Monad.Trans.Maybe.runMaybeT (lift (newSTRef ()) >>= lift . readSTRef))
07:39:29 <lambdabot>   Not in scope: `Control.Monad.Trans.Maybe.runMaybeT'
07:39:36 <parcs`> wat :(
07:39:49 <quchen> mSSM: There's already a definition for entropy in that case, but it seems to have an error in it somehow. My goal is finding a better formula.
07:39:52 <mSSM> quchen: classics?
07:40:04 <quchen> Yes, classical.
07:40:22 <mercury^> So, I suppose that my use of (.) messes things up?
07:40:33 <shachaf> Maybe.
07:40:35 <quchen> I'm starting to be able to think in phase space again ;-)
07:40:45 <Tekmo> mercury^: Yes, it does
07:40:50 <Tekmo> The general rule is to do this:
07:40:55 <mSSM> quchen: Souds very interesting; I wrote you a pm
07:40:56 <Tekmo> foo $ runST $ do ...
07:40:57 <shachaf> mercury^: It's hard to tell without seeing the code. :-)
07:41:01 <mSSM> quchen: Do you maybe have a review paper on arxiv?
07:41:12 <Tekmo> The ($) has a special treatment
07:41:17 <`nand`> rwbarton: still prefer Data.Data.Data
07:41:19 <Tekmo> It plays nice with the higher rank types
07:41:33 <djahandarie> Is there a way to define a (.) that plays nicely with higher rank types?
07:41:38 * djahandarie has never thought about it
07:41:44 <rwbarton> @type (.)
07:41:45 <lambdabot> Functor f => (a -> b) -> f a -> f b
07:41:45 <mercury^> Tekmo: what about things like <=<?
07:41:48 <rwbarton> ahdsahfdsa
07:41:56 <djahandarie> @type (Prelude..)
07:41:57 <lambdabot> (b -> c) -> (a -> b) -> a -> c
07:42:15 <shachaf> Silly lambdabot. Clearly it's (.) :: Category k => (b `k` c) -> (a `k` b) -> a `k` c
07:42:16 <Tekmo> mercury^: Then you do: (f <=< g) $ runST $ do ...
07:42:37 <Tekmo> Anything to the left of the left dollar sign is safe
07:42:43 <rwbarton> mercury^: type inference is not good enough to work out that 'b' in the above type should be a polymorphic type
07:42:49 * hackagebot base-compat 0.1.0.1 - Provides readMaybe, lookupEnv, etc. for older versions of base  http://hackage.haskell.org/package/base-compat-0.1.0.1 (SimonHengel)
07:42:54 <S11001001> shachaf: no clearly it's Functor f => (a -> b) -> f a -> f b :)
07:43:11 <rwbarton> death to the infidels etc.
07:43:34 <mercury^> Ok, let me try to get rid of the (.); if that alone does not do it, can I upload a file to hpaste, instead of copy-pasting?
07:43:37 <shachaf> The fmap generalization doesn't even make any sense. :-(
07:43:47 <shachaf> mercury^: No.
07:43:50 <S11001001> shachaf: ?
07:43:55 <shachaf> If your file is that big you should probably trim it down before hpasting anyway.
07:44:06 <elliott> it's obviously (.) :: (Category k, Composing j) => j (k b c) (j (k a b) (k a c))
07:44:21 <elliott> then you can write other instances of composing like um... Kleisli Identity
07:44:27 <shachaf> (.) :: Dot a => a
07:44:42 <rwbarton> :t ((.) :: (forall b. b -> c) -> (a -> forall b. b) -> a -> c
07:44:43 <lambdabot> parse error (possibly incorrect indentation)
07:44:49 <rwbarton> :t (.) :: (forall b. b -> c) -> (a -> forall b. b) -> a -> c
07:44:50 <lambdabot>     Couldn't match expected type `forall b. b -> c'
07:44:50 <lambdabot>                 with actual type `a0 -> b0'
07:44:50 <lambdabot>     Expected type: (forall b. b -> c) -> (a -> forall b. b) -> a -> c
07:44:51 <`nand`> elliott: :)
07:45:10 <`nand`> gotta love generalizations that exist just to provide the regular instance and.. an equivalent instance with a sillier type
07:45:12 <shachaf> rwbarton: That looks like a pretty strange composition.
07:45:28 <Peaker> Given (.) is an infix operator, it might as well have (a -> b -> c) form and not generalize the (->) part
07:46:36 <`nand`> rwbarton: wouldn't that be (forall b. b -> c) -> (a -> exists b. b) -> a -> c
07:47:02 <`nand`> otherwise the only function you could precompose would be coerce
07:47:03 <rwbarton> oh i dropped some parens
07:47:08 <shachaf> `nand`: That (.) also doesn't make much sense.
07:47:08 <rwbarton> :t (.) :: ((forall b. b) -> c) -> (a -> forall b. b) -> a -> c
07:47:10 <lambdabot> ((forall b. b) -> c) -> (a -> forall b. b) -> a -> c
07:47:13 <rwbarton> oh, that works
07:47:53 <Tekmo> Why shouldn't it work?
07:47:59 <Tekmo> Aren't you just specializing the type?
07:48:25 <shachaf> You could say that about a lot of non-working examples. :-)
07:48:32 <Tekmo> True :)
07:48:45 <shachaf> This is sort of like ImpredicativeTypes.
07:49:08 <rwbarton> :t ((.) :: ((forall s. ST s (Maybe a)) -> Maybe a) -> ((forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> (forall s. ST s (Maybe a))) -> (forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> Maybe a) runST Control.Monad.Trans.Maybe.runMaybeT
07:49:09 <lambdabot>     Couldn't match expected type `forall s.
07:49:09 <lambdabot>                                   Control.Monad.Trans.Maybe.MaybeT (ST s) a0'
07:49:09 <lambdabot>                 with actual type `Control.Monad.Trans.Maybe.MaybeT m0 a1'
07:49:49 <shachaf> Just do it edwardk-style.
07:50:01 <shachaf> http://hpaste.org/78521
07:50:12 <shachaf> I'd like to point out that that file type-checks if you take out all three unsafeCoerces.
07:50:13 <`nand`> haha
07:50:14 <rwbarton> what's that, unsafeCoerce everything to Any -> Any
07:50:17 <shachaf> Not that he even bothered trying.
07:50:26 <hpaste> mercury pasted “Quantification trouble” at http://hpaste.org/78550
07:50:47 <mercury^> The $ have helped already.
07:50:57 <Tekmo> Great!
07:51:41 <mercury^> It still does not compile though. :)
07:51:43 <Peaker> mercury^, don't you need to use runSTArray to get usable arrays?
07:52:07 <shachaf> Peaker: Isn't that just an efficiency thing?
07:52:17 <rwbarton> @type ((.) :: ((forall s. ST s (Maybe a)) -> Maybe a) -> ((forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> (forall s. ST s (Maybe a))) -> (forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> Maybe a) runST (\x -> Control.Monad.Trans.Maybe.runMaybeT x)
07:52:18 <lambdabot> (forall s. Control.Monad.Trans.Maybe.MaybeT (ST s) a) -> Maybe a
07:52:23 <rwbarton> see, (.) works fine :)
07:52:34 <mercury^> I think it is an efficiency thing (equivalent to using unsafe freeze in my case).
07:52:35 <Peaker> @type runSTArray
07:52:37 <lambdabot> Not in scope: `runSTArray'
07:53:02 <Peaker> shachaf, if you return the array as an ST array, I don't think it is usable outside the ST computation (as a pure val)
07:53:10 <Peaker> shachaf, it's kind of like returning an STRef directly
07:53:19 <shachaf> Peaker: Sure, you'll have to freeze it.
07:53:24 <mercury^> Right now I have the choice between the following two errors, depending on whether I comment the type of loop or not:
07:53:27 <shachaf> Which involves a copy.
07:53:33 <rwbarton> @type freeze
07:53:33 <lambdabot> Not in scope: `freeze'
07:53:35 <shachaf> All runSTArray does is save you from copying
07:53:35 <Peaker> oh, he did freeze it inside the ST computation
07:53:40 <rwbarton> that was a little optimistic, I admit
07:53:40 <mercury^>    No instance for (MArray a0 Tile (ST s))
07:53:40 <mercury^>       arising from a use of `freeze'
07:53:40 <mercury^>     The type variable `a0' is ambiguous
07:54:05 <mercury^> That or:    No instance for (MArray (STUArray s0) Tile (ST s))
07:54:06 <mercury^>       arising from a use of `thaw'
07:54:06 <mercury^>     The type variable `s0' is ambiguous
07:54:09 <elliott> has anyone ever implemented those perfect type systems that handle composition of rank-n types correctly that i read about
07:54:16 <elliott> would use
07:54:48 <rwbarton> scoped type variabls is the easy way out
07:54:49 <mercury^> Do I have to use some syntactic extension to smuggle in a forall somewhere?
07:55:14 * shachaf wouldn't call most uses of forall "a syntactic extension".
07:55:37 <Peaker> elliott, I think there's no problem with rank-n in system F (explicit type variables and instantiation)
07:56:22 <Tekmo> Wait
07:56:24 <rwbarton> do you mean lift (thaw g)?
07:56:27 <Tekmo> I'm confused ab out the hpaste
07:56:31 * rwbarton finds this <=< style unnecessarily obtuse
07:56:36 <Tekmo> rwbarton: Evne better: (lift . thaw) $ g
07:56:48 * Peaker loves . and <=< and forming pipelines
07:56:49 <mercury^> Ah, yes.
07:56:58 <mercury^> Thanks for spotting that.
07:57:08 <Tekmo> Do this:
07:57:12 <Tekmo> <=< lift . thaw $ g
07:57:13 <shachaf> My GHCi takes >0.75s to load now.
07:58:10 <ocharles> does anyone have a PDF of 'type classes: an exploration of the design space' that doesn't look like shit?
07:58:18 <mercury^> Ok, still left with the underdetermined a0 in (MArray a0 Tile (ST s))
07:58:25 <ocharles> the one on research.microsoft.com doesn't render properly (or isn't a proper pdf)
07:58:38 <rwbarton> what did line 1 change to?
07:58:40 <shachaf> ocharles: What's wrong with http://research.microsoft.com/en-us/um/people/emeijer/papers/typeclasses.pdf ?
07:58:52 <ocharles> it's really blurry here
07:58:55 <mercury^> line 1 is now: runST $ runMaybeT $ (lift . freeze) <=< work <=< lift . thaw $ g
07:58:56 <ocharles> it displays ok for you?
07:59:03 <shachaf> Looks OK to me.
07:59:08 <ocharles> hmm
07:59:30 <Tekmo> Are you using Adobe Acrobat Reader (C) Software?
07:59:37 <ocharles> mendely and evince both display it badly
07:59:59 <S11001001> don't worry, ocharles, it looks bad to me on adobe too
08:00:23 <Tekmo> :t thaw
08:00:24 <`nand`> the letters look ‘cut off’ for me
08:00:26 <lambdabot> Not in scope: `thaw'
08:00:28 <`nand`> it doesn't look blurry though
08:00:34 <ocharles> yea, that's what I get actually
08:00:38 <ocharles> blurry isn't the right word
08:00:43 <`nand`> it's fine if I zoom to 100% though
08:00:43 <mercury^> Could it be that I have to use an extension so that I can specify the type of loop as Int -> MaybeT (forall s. ST s) (STUArray s Int Tile)?  Or should that really not be necessary?
08:00:47 <`nand`> I can read it fairly readily
08:00:55 <`nand`> by 100% I mean ‘fit to width’
08:00:56 <qwr> chrome built-in pdf plugin seems show it mostly ok, in evince-gtk it was very blurry
08:00:59 <rwbarton> oh, lift is probably causing you more problems
08:01:05 <shachaf> Looks OK in Chrome's PDF viewer
08:01:07 <rwbarton> start over
08:01:11 <ocharles> http://i.imgur.com/c9iOs.png
08:01:17 <rwbarton> computation :: MaybeT (ST s) a
08:01:19 <rwbarton> computation = do ...
08:01:35 <rwbarton> runST $ runMaybeT computation
08:01:37 <ocharles> but anyway, if that's what there is, i'll try and make do
08:01:46 <`nand`> I am viewing it using zathura whch internally uses app-text/poppler
08:01:47 <rwbarton> that way both we and the compiler will be able to understand
08:01:49 <Tekmo> mercury^: What is the type of work?
08:02:07 <shachaf> ocharles: Looks better to me in Chrome's PDF viewer than evince.
08:02:11 <`nand`> no, it doesn't look blurry like that for me
08:02:35 <mercury^> Tekmo: it should be (STUArray s Int Tile) -> MaybeT (ST s) (STUArray s Int Tile)
08:02:48 * ocharles tries on the nexus
08:02:57 <Tekmo> mercury^: Also, you should be using "runSTUArray" instead of "runST"
08:03:09 <ocharles> oh good, it's perfectly readable on my tablet :)
08:03:17 <shachaf> ocharles: Also looks OK in xpdf.
08:03:24 <ocharles> so basically "it's me"
08:03:28 <`nand`> ocharles: http://sadpanda.us/images/1270362-FA5IDLB.png
08:03:37 <ocharles> oh yes, that's much better
08:03:43 <mercury^> Tekmo: I do not think I can, because I cannot get an STUArray but only a Maybe STUArray.
08:03:50 <ocharles> aha, mupdf is ok with it too
08:04:06 <ocharles> so it's a half broken pdf, but at least there are ways to make it readable
08:04:20 <Tekmo> mercury^: Oh yeah
08:04:43 <Tekmo> mercury^: Then handle the maybe and still use STUArray anyway
08:04:48 <Tekmo> :t fromMaybe
08:04:50 <lambdabot> a -> Maybe a -> a
08:05:09 <Tekmo> That unwraps a maybe providing a default value if it has Nothing
08:05:20 <mercury^> Tekmo: but I *want* to return a Maybe UArray.
08:05:45 <`nand`> odd; app-text/evince has a dependency on app-text/poppler for me; they should be using the same rendering engine
08:05:47 <S11001001> @ty id :: forall a. a -> a
08:05:48 <`nand`> I guess evince is just braindead
08:05:49 <lambdabot> a -> a
08:06:17 <S11001001> different font lookup rules?
08:06:20 <ocharles> `nand`: btw, are you running gentoo?
08:06:22 <ocharles> i miss gentoo :(
08:06:25 <Tekmo> mercury^: Alright, I'll work on figuring that out, but in the meantime try what I suggested to see if it type-checks
08:06:29 <`nand`> ocharles: Yes. I don't :)
08:06:53 <ocharles> i switched to arch when i accidently nuked my hard disk and work teasing me about compiling everything got too much :)
08:07:00 <Tekmo> :t runST
08:07:02 <lambdabot> (forall s. ST s a) -> a
08:07:06 <ocharles> but i don't particularly enjoy it
08:07:15 <`nand`> (this should be taken to -blah)
08:07:19 <ocharles> ah
08:07:50 <Tekmo> mercury^: I might be wrong, but I think thep roblem you are encountering is that you are leaking an ST reference outside the scope of the ST block
08:08:01 <Tekmo> In this case the ST reference is the STUArray s ...
08:08:43 <rwbarton> freeze should take care of that
08:08:47 <mercury^> Maybe I should go with rwbarton's suggestion first and split everything into several top level definitions with type signatures.
08:08:55 <mercury^> So that we can more easily track down the culprit.
08:09:17 <mercury^> (Might take a couple of minutes, I'm really tired.)
08:09:21 <rwbarton> it doesn't even have to be a top-level definition, necessarily, you can put that "computation :: MaybeT (ST s) a" after the 'where' and go from there (as long as you can fix the type 'a')
08:10:28 <Tekmo> You shouldn't program tired!
08:10:32 <rwbarton> you want to do whatever that thing is called in logic where you convert between "forall s. e[s]" and "e[s]"
08:10:47 <rwbarton> (specialization/generalization?)
08:11:09 <mercury^> I've learned it as quantifier introduction/elimination.
08:11:30 <rwbarton> once you specialize then type inference should Just Work. but it doesn't work so well on the generalized forms, as you saw with (.)
08:12:04 <mercury^> Is there any recommended way to avoid everything shifting more and more to the right as I introduce a couple of where-clauses?
08:12:49 <rwbarton> Universal Introduction (or Universal Generalization) / Universal Elimination (or Universal Instantiation)
08:13:55 <qwr> ocharles: yes it's usually font issue, where poppler takes some font that it scales and gray-scale antialiases it into blurry mess
08:14:25 <ocharles> mm
08:14:50 <mercury^> Hmm, I still get this error:
08:14:51 <mercury^>     No instance for (MArray (STUArray s0) Tile (ST s))
08:14:51 <mercury^>       arising from a use of `thaw'
08:14:51 <mercury^>     The type variable `s0' is ambiguous
08:15:03 <qwr> ocharles: chrome PDF plugin tends to render more clearly, but it also totally breaks the rendering more often than poppler
08:16:19 <Tekmo> Oh
08:16:24 <Tekmo> mercury^: Is Tile Unboxed?
08:16:37 <Tekmo> Have you tried STArray instead?
08:16:38 <mercury^> Tekmo: yes, it's Word16.
08:16:38 <rwbarton> can you paste your new code?
08:16:43 <Tekmo> Oh, never mind, then
08:17:03 <Tekmo> It's a type synonym for Word16?
08:17:15 <mercury^> Yep.
08:17:21 <rwbarton> the immediate problem is that s0 is not the same as s
08:17:31 <mercury^> Maybe I just paste the whole function?
08:17:32 <rwbarton> whatever those are :)
08:17:43 <rwbarton> the more the merrier
08:17:56 <neutrino> oh that's nice for golf
08:17:58 <neutrino> > let a="2"in a
08:18:00 <lambdabot>   "2"
08:18:12 <bzm3r> why can I not write this: foldr :: (a -> b -> b) -> b -> [a] -> b, as foldr :: (a -> a -> a) -> a -> [a] -> a?
08:18:21 <shachaf> You can.
08:18:28 <shachaf> It's less general, but it'll type-check.
08:18:34 <bzm3r> Why is it less general?
08:18:41 <hpaste> mercury annotated “Quantification trouble” with “Quantification trouble (annotation)” at http://hpaste.org/78550#a78551
08:18:43 <neutrino> > let(*)="2"in(*)
08:18:45 <lambdabot>   "2"
08:18:48 <shachaf> Because it forces you to return the same type as the things in the list.
08:19:00 <bzm3r> Doesn't "a" represent any type?
08:19:04 <rwbarton> mercury^: did you try deleting line 12?
08:19:04 <bzm3r> Ahh.
08:19:11 <rwbarton> that gave you the other error?
08:19:12 <shachaf> Yes, but the two "a"s represent the same type. :-)
08:19:22 <mercury^> rwbarton: yeah, that still gives an error.
08:19:23 <bzm3r> Right, I see what you mean, thank you.
08:19:25 <shachaf> Something needs to be Done about the word "any".
08:19:46 <rwbarton> you can use ScopedTypeVariables now, but it seems like it ought to be unnecessary...
08:19:51 <mercury^> rwbarton: even the same one, iirc, now that computation is annotated.
08:20:03 <Tekmo> Actually, try ScopedTypeVariables just to see what happens
08:20:09 <neutrino> > let(*) ="2" in(*)
08:20:11 <lambdabot>   "2"
08:20:29 <rwbarton> with ScopedTypeVariables put "forall s." before the signature on line 7
08:22:26 <rwbarton> oh
08:22:43 <mercury^> Hmm, do I need ImpredicativeTypes?
08:22:58 <mercury^> (That's what ghc suggests when I write MaybeT (forall s. ST s) Grid
08:23:16 <rwbarton> don't write that
08:23:22 <rwbarton> computation :: forall s. MaybeT (ST s) Grid
08:23:36 <mercury^> Ok, then it's the same error as before.
08:24:09 <mercury^> Oh.
08:24:19 <mercury^> With that and the loop signature it compiled1
08:24:20 <mercury^> !
08:24:21 <mercury^> Yay.
08:24:23 <mercury^> :)
08:24:51 <mercury^> I would love to understand what is going on though.
08:24:59 <mercury^> And why…..
08:25:39 <mercury^> ST uses an extension that makes typechecking undecidable?
08:25:52 <rwbarton> you've told it that the s in the type signature of loop has to be the same as the s in the type signature of computation, however, why it can't figure that out on its own, I don't know
08:26:08 <rwbarton> it's further complicated by the use of type classes in thaw and freeze
08:26:34 <tac> mercury^: it makes type *inference* undecidable.
08:26:34 <mercury^> These kinds of issues are what makes programming in Haskell very annoying for me.
08:26:40 <mercury^> tac: right.
08:26:53 <tac> mercury^: It's not a big deal. Full type inference isn't all that important anyway
08:27:02 <rwbarton> I bet it would have been a lot easier if you had freeze/thaw specialized to STUArray
08:27:08 <rwbarton> and ST
08:27:23 <Tekmo> Yeah, sometimes I think that these libraries should just namespace the functions instead of type classing them
08:27:36 <rwbarton> there's no functional dependency either way between the monad and the type of the array
08:28:34 <shachaf> Type classes: The devil?
08:28:44 <Tekmo> Well, gratuitous use of them
08:29:28 <Tekmo> When people treat them as a name-spacing mechanism is when they get out of hand
08:31:48 <mercury^> Should I specialise lift . freeze and lift . thaw or just freeze and thaw?
08:31:59 <Tekmo> Just freeze and thaw
08:33:22 <rwbarton> @type lift
08:33:23 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
08:36:36 <mercury^> :(, specialising freeze and thaw and putting it back into the original form brings back the errors.
08:37:14 <rwbarton> I'm still a little baffled, I have to admit
08:37:15 <Tekmo> Maybe the problem is with the work function
08:37:29 <rwbarton> your annotation didn't compile, but when you added "forall s. " on line 7, it did compile?
08:37:48 <mercury^> Yes.
08:38:21 <Tekmo> Is this using the same "work m = loop 0" definition?
08:38:30 <mercury^> Tekmo: yep.
08:38:30 <rwbarton> I notice the annotation is cut off at the bottom, are there any more type signatures that mention the variable s?
08:38:36 <mercury^> And loop is still annotated.
08:39:01 <Tekmo> What about annotating work?
08:39:06 <mercury^> rwbarton: no.
08:39:56 <mercury^> Tekmo: same error.
08:40:13 <rwbarton> then I don't get it, because 'computation' is built out of ... <=< work <=< ... $ ..., it has to be in the same monad as work, which is to say loop
08:40:14 <mercury^> And I do not see why ghc would not be able to infer that, given that loop is annotated.
08:40:23 <rwbarton> how can the s's not be forced to agree already
08:40:53 <Tekmo> Maybe the problem has to do with the fact that work does not use its argument
08:40:54 <rwbarton> I *do* understand why you need a type signature on loop, I think
08:41:41 <rwbarton> (it wouldn't know otherwise that there wasn't some other instance MArray (ST s) (...) (STUArray s' ...) it could pick)
08:41:41 <Tekmo> Where does the array that loop generates come from?
08:42:00 <Tekmo> Did you create a new array?
08:42:07 <DrChaos_> how do I use the sum function with a list comprehension? The output function must be the numeral 1 for every element of the list.
08:42:22 <rwbarton> looks like there is no new array, it always returns m
08:42:27 <rwbarton> after possibly fiddling with it
08:42:29 <mercury^> Yeah.
08:42:39 <Tekmo> How can it return m, though?
08:42:45 <Tekmo> Or is loop let bound to have m in scope?
08:42:57 <hayashi> argh, the freebsd haskell package for haddock requires haddock to install
08:43:01 <mercury^> Tekmo: I think it is where bound to have m in scope.
08:43:06 <mercury^> Because m is an argument to work.
08:43:07 <hayashi> as does cabal-install
08:43:08 <Tekmo> Ok, then never mind :)
08:47:13 <hpaste> gabor annotated “TH success!!!” with “TH success!!! (annotation)” at http://hpaste.org/78546#a78553
08:47:33 <mercury^> If you have some preferred service where I can upload a file, I could also share the whole thing with you.
08:47:47 <rwbarton> mercury^: I got it to compile by putting a type annotation on work *instead of* on loop
08:47:48 <Tekmo> Why not hpaste?
08:48:32 <mercury^> Tekmo: I am using a terminal only and don't know how to copy more than can be displayed at once (easily).
08:48:49 <Tekmo> If you have the xsel utility, you can do this:
08:48:55 <Tekmo> xsel --clipboard <file
08:50:37 <mercury^> rwbarton: for me that does not work. :s
08:50:43 <mercury^> Tekmo: I installed it now. :)
08:50:56 <Tekmo> Yeah, it works well
08:51:19 <rwbarton> oh this is very odd
08:51:58 <hpaste> mercury annotated “Quantification trouble” with “Quantification trouble (annotation) (annotation)” at http://hpaste.org/78550#a78554
08:53:13 <mercury^> rwbarton: Ah, I did not really annotate work there of course.
08:53:53 <mercury^> rwbarton: yeah, annotating work works.
08:54:06 <mercury^> But then the argument of loop will be Integer and not Int, right?
08:54:17 <kliko> Dear all, I am wondering if I'm understanding MonadReaders correct, regarding the ask function. The ask function only returns the saved hidden state right?
08:54:37 <rwbarton> mercury^: no, because you pass it to ifp later
08:54:42 <byorgey> kliko: right
08:54:49 <mercury^> rwbarton: ah, right.
08:54:54 <rwbarton> anyways, I am getting some *really* odd behavior with simplifications of your code
08:54:55 <shachaf> FSVO "returns"
08:55:13 <kliko> I see, it does not edit the state, that's what local is for right?
08:55:16 <mercury^> Oh, will you also please tell me the simplifications?
08:55:34 <kliko> (which edits the state locally)
08:56:14 <rwbarton> simplification as in trying to get smaller code that exhibits the same strange type-checking behavior
08:56:17 <rwbarton> not as in code that does the same thing
08:56:26 <kliko> I've completely implemented exercise 2 (http://www.cs.uu.nl/wiki/pub/Afp/Assignments/Assign2.pdf), however the numbers in the example given seem so random
08:56:32 <mercury^> Ah.
08:56:34 <kliko> and I can't figure out how they are connected
08:57:12 <kliko> so my function works, however I will get only 1's in the whole tree structure :(
08:57:30 <Tekmo> kliko: local does not edit anything
08:57:40 <Tekmo> kliko: It just passes in a different value
08:57:41 <kliko> no, it applies a function to the state right?
08:57:47 <kliko> oh..
08:58:28 <kliko> ic
08:58:44 <Tekmo> Remember that Reader a b is just a type synonym for a- > b
08:58:44 <hpaste> rwbarton annotated “Quantification trouble” with “Quantification trouble (annotation) (annotation)” at http://hpaste.org/78550#a78555
08:58:47 <Tekmo> *a -> b
08:59:03 <rwbarton> can someone explain this http://hpaste.org/78555
08:59:04 <Tekmo> So local just passes in a different value for 'a'
08:59:06 <shachaf> It's not a synonym.
08:59:41 <kliko> isn't it MonadReader r m | m -> r?
08:59:46 <kliko> instead of r -> m?
08:59:51 <shachaf> rwbarton: Explain what?
08:59:53 <Tekmo> Oh yeah, they changed that
09:00:03 <shachaf> kliko: No, that's a type class, which is unrelated.
09:00:08 <Tekmo> But it is still isomorphic to a -> b
09:00:14 <shachaf> Changed? I've nver heard of Reader not being a newtype.
09:00:17 <rwbarton> shachaf: the inferred type of work
09:00:21 <shachaf> Well, not it's actually ReaderT
09:00:42 <shachaf> rwbarton: Oh, the s and s1?
09:00:44 <Tekmo> I thought at some point Reader e was a synonym for ((->) e)
09:00:44 <rwbarton> yes
09:01:16 <rwbarton> ghc is pretty lucky that s is a phantom parameter!
09:01:34 <Saizan> seems like the bug glguy found when using lens
09:02:04 <Tekmo> Aha, found it
09:02:10 <Tekmo> not a type synonym, but a newtype
09:02:27 <Tekmo> mtl-1.0 has newtype Reader r a = Reader (r -> a)
09:02:48 <rwbarton> not every day you find a type checker bug that doesn't even use any extensions...
09:02:57 <rwbarton> well, I guess there are some extensions in the imported modules
09:03:09 <shachaf> Rank-2 types are certainly an extension.
09:03:16 <rwbarton> I'm not using any!
09:03:27 <rwbarton> no runST here
09:03:30 <shachaf> Oh, good point.
09:03:30 <rwbarton> just MPTCs
09:03:36 <rwbarton> not even fundeps, I think?
09:03:48 <Tekmo> Can you reduce it any further, rwbarton?
09:04:23 <rwbarton> obvious reductions fail, like getting rid of the second case of 'loop' or replacing buildMask by its definition
09:04:40 <rwbarton> fail = the type checker then rejects the program like it should (I think?)
09:04:45 <shachaf> rwbarton: You can get rid of the first case of loop, though.
09:04:53 <shachaf> And the parameter.
09:04:57 <rwbarton> I was worried that then the type is correct
09:05:01 <rwbarton> because the loop is infinite
09:05:27 <shachaf> Ah.
09:05:35 <shachaf> No, you can make loop nonrecursive.
09:05:35 <Tekmo> What about buildMask >> return m where buildMask = ...?
09:05:41 <shachaf> loop = buildMask >> return m
09:05:46 <rwbarton> ok, that works
09:06:33 <rwbarton> to reduce further i'd want to make my own copies of the type classes involved
09:06:37 <rwbarton> and simplify them down
09:06:54 <shachaf> I suspect it could work without type classes.
09:07:03 <Tekmo> Wait
09:07:04 <Tekmo> Try this
09:07:05 <rwbarton> it seems pretty fragile
09:07:07 <Tekmo> factor out the lift
09:07:16 <hpaste> “Owen Stephens” pasted “GADT constructors with common constraints” at http://hpaste.org/78556
09:07:20 <rwbarton> you mean, move to loop?
09:07:22 <Tekmo> lift (buildMask >> return m) where buildMask = {unlifted version}
09:07:40 <rwbarton> this also works yes
09:07:45 <Tekmo> Works as in fails?
09:07:55 <rwbarton> as in it compiles, and work has the unexpected signature
09:08:04 <owst> Can anywhere tell me where my thinking will lead to problems, thinking about common constraints for GADTs: http://hpaste.org/78556
09:08:17 <Tekmo> and if you remove the lift?
09:08:19 <shachaf> rwbarton: Works fine with readArr :: STUArray s Int Double -> Int -> ST s Double; readArr = readArray
09:08:35 <Tekmo> What if you remove the lift entirely?
09:08:36 <shachaf> rwbarton: Then you can just loop = return m where buildMask = ...
09:08:42 <shachaf> I got rid of MaybeT a while ago. :-)
09:08:50 <shachaf> This looks a lot like glguy's bug.
09:09:11 <Tekmo> loop = buildMask >> return m where buildMask = readArray m 3
09:09:26 <rwbarton> is that on trac already?
09:09:33 <shachaf> Yes.
09:10:21 <Tekmo> What is this bug you are talking about?
09:10:29 <shachaf> @google emertens unsafeCoerce
09:10:31 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/7453
09:10:31 <lambdabot> Title: #7453 (unsafe coerce without extensions) – GHC
09:10:35 <maxsu> HEy all
09:10:40 <Tekmo> Hey!
09:11:16 <rwbarton> does that mean i can use it here? :)
09:11:35 <rwbarton> > let unsafeCoerce v = z where z :: v; z = v where aux = const v in (unsafeCoerce (putStrLn "evil IO action") :: () -> ()) ()
09:11:37 <lambdabot>   Couldn't match type `t' with `v1'
09:11:37 <lambdabot>    `t' is a rigid type variable bound by
09:11:37 <lambdabot> ...
09:12:01 <shachaf> rwbarton: Due to a quirk it doesn't work in lambdabot.
09:12:11 <shachaf> The quirk is that mueval uses GHC 6.12's type checker, or something like that.
09:12:22 <shachaf> @ty let unsafeCoerce v = z where z :: v; z = v where aux = const v in unsafeCoerce
09:12:23 <lambdabot> v -> v1
09:12:29 <rwbarton> that is pretty quirky
09:12:30 <shachaf> > let unsafeCoerce v = z where z :: v; z = v where aux = const v in unsafeCoerce 'a'
09:12:32 <lambdabot>   Couldn't match type `t' with `v2'
09:12:32 <lambdabot>    `t' is a rigid type variable bound by
09:12:32 <lambdabot> ...
09:12:36 <rwbarton> @let unsafeCoerce v = z where z :: v; z = v where aux = const v
09:12:39 <lambdabot>  Defined.
09:12:45 <rwbarton> > (unsafeCoerce (putStrLn "evil IO action") :: () -> ()) ()
09:12:47 <lambdabot>   <local>:2:38:
09:12:47 <lambdabot>      Couldn't match type `t' with `v1'
09:12:47 <lambdabot>        `t' is a rigid ...
09:12:47 <shachaf> Nope, same issue.
09:12:50 * hackagebot libssh2 0.2.0.1 - FFI bindings to libssh2 SSH2 client library (http://libssh2.org/)  http://hackage.haskell.org/package/libssh2-0.2.0.1 (IlyaPortnov)
09:12:59 <rwbarton> :t unsafeCoerce
09:13:00 <lambdabot> v -> v1
09:13:33 <rwbarton> well, this is a satisfying explanation i guess
09:14:15 <maxsu> I'm looking for an eruby-like templating system for HS. Have you guys seen this Textual Haskell Source thing? http://neilmitchell.blogspot.com/2006/08/ths-textual-haskell-source.html
09:14:44 <shachaf> Hah, I simplified it further, I think.
09:15:28 <shachaf> Oh, hmm.
09:16:07 <DrChaos_> how do I use the sum function with a list comprehension?
09:16:14 <shachaf> sum [...]
09:16:22 <Tekmo> > sum [1..4]
09:16:24 <lambdabot>   <local>:2:38:
09:16:24 <lambdabot>      Couldn't match type `t' with `v1'
09:16:24 <lambdabot>        `t' is a rigid ...
09:16:32 <mercury^> Tekmo: :D
09:16:32 <mcstar> @undef
09:16:33 <Tekmo> lol
09:16:33 <rwbarton> lol
09:16:37 <mcstar> > sum [1..4]
09:16:39 <lambdabot>   10
09:16:47 <Tekmo> Well, now we know how to break lambdabot
09:16:49 <Guest7480> [1..4] isnt a list comprehension
09:16:59 <rwbarton> use your imagination :)
09:17:18 <shachaf> Hmm, I have an unsafeCoerce that works in 7.6 and not 7.4
09:17:37 <Guest7480> imagination oriented programming
09:17:41 <Tekmo> Why do you think it requires a list comprehension?
09:18:09 <shachaf> Tekmo: No we don't.
09:18:21 <shachaf> Oh, "break" in the sense that > doesn't work?
09:18:23 <Tekmo> I don't even see how you could even implement it as a list comprehension
09:18:30 <DrChaos_> can I make a function using lambdabot?
09:18:31 <Tekmo> The result of a list comprehension must be a list
09:18:32 <shachaf> That's not breaking.
09:18:41 <Tekmo> But the result of "sum" is a number
09:18:58 <Guest7480> he asked how to use it with, not implement it with
09:19:11 <mcstar> :t sum
09:19:12 <lambdabot> Num a => [a] -> a
09:19:15 <mcstar> it is very obvious
09:19:21 <ololo> http://i50.tinypic.com/346q5mx.jpg
09:19:39 <mcstar> nice
09:19:46 <typoclass> @where ops
09:19:46 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
09:19:53 <Tekmo> I don't see how else to interpret his question
09:20:01 <dcoutts> typoclass: mm?
09:20:08 <typoclass> dcoutts: shocker picture ...
09:20:21 <mcstar> guy had some fat on his neck
09:20:37 --- mode: ChanServ set +o dcoutts
09:20:40 --- kick: ololo was kicked by dcoutts (ololo)
09:20:46 --- mode: dcoutts set +b *!*jhhhgfgh@hst-171-103.balticservers.com
09:20:46 --- kick: ololo was kicked by dcoutts (ololo)
09:20:52 <typoclass> dcoutts: thanks
09:20:54 --- mode: ChanServ set -o dcoutts
09:21:01 <mcstar> that doesnt solve anything
09:21:05 <mcstar> youve seen the picture...
09:21:14 <Guest7480> kicked from #haskell, impressive
09:21:42 <linduxed> takes a special kind of troll to be a pain in this channel
09:21:42 <bgamari> well that was mildly disturbing
09:21:43 <typoclass> mcstar: what do you mean? you were encouraging him
09:22:05 <mcstar> i dont want to encourage him, but i saved the pic
09:22:20 <dcoutts> I don't think he needed any encouragement
09:22:48 <mcstar> i just hate those morgue employees who make these pictures
09:23:50 <typoclass> mcstar: you did say "nice" to him. that's encouraging as far as i can tell
09:24:06 <mcstar> sarcasm
09:24:17 <DrChaos_> myLength [] = 0
09:24:17 <DrChaos_> myLength (x:xs) = myLength xs
09:24:34 <Tekmo> We must exterminate mcstar to prevent the virus from spreading!
09:24:35 <shachaf> DrChaos_: Something is missing...
09:24:48 <mcstar> Tekmo: oh, pls do
09:24:59 <mcstar> Tekmo: but do it type-safely
09:25:01 <Tekmo> :)
09:25:04 <shachaf> THis whole discussion is off-topic.
09:26:23 <DrChaos_> I know. I need the syntax for list comprehensions and what type signature the sum function has
09:26:37 <Tekmo> :t sum
09:26:39 <lambdabot> Num a => [a] -> a
09:27:03 <shachaf> DrChaos_: List comprehensions are overrated.
09:27:06 <Tekmo> > [x + 1 | x <- [1..4]]
09:27:08 <lambdabot>   [2,3,4,5]
09:27:20 <shachaf> Anything you can do with list comprehensions you can do without them, and it's often better. They're not fundamental to Haskell at all.
09:27:39 <typoclass> DrChaos_: a list comprehension is something of the form [ ... | ... ], as Tekmo demonstrated
09:28:04 <shachaf> > [let x | True = 5 in x]
09:28:06 <lambdabot>   [5]
09:28:26 <typoclass> shachaf: thanks for clarifying ;-)
09:31:43 <DrChaos_> well, can I do [ [1] | x <- [1,2] ]
09:31:43 <Eduard_Munteanu> @undo [x + 1 | x <- [1..4]]
09:31:44 <lambdabot> concatMap (\ x -> [x + 1]) [1 .. 4]
09:32:06 <shachaf> You can even do [1 | x <- [1,2]]
09:34:25 <rwbarton> > [ 1 | ]
09:34:27 <lambdabot>   <hint>:1:7: parse error on input `]'
09:35:24 <DrChaos_> :t sum
09:35:26 <lambdabot> Num a => [a] -> a
09:36:01 <ParahSail1n> @pl concatMap (\ x -> [x + 1]) [1 .. 4]
09:36:01 <lambdabot> (1 +) `fmap` [1..4]
09:36:07 <mercury^> Argh, the inline pragma is ignored if a function calls itself!
09:36:14 <mercury^> What if I want to unroll a loop?
09:37:07 <Tekmo> there isa pragma for loop unrolling
09:37:30 <Eduard_Munteanu> It is ignored?
09:37:51 <DrChaos_> huh? I want to implement the length function using a list comprehension and the sum function
09:37:51 <mercury^> Tekmo: which one is that
09:37:58 <Eduard_Munteanu> I suppose GHC could emit an inlined and a non-inlined definition.
09:38:04 <Tekmo> Or I thought there was
09:38:09 <Tekmo> I can't find it any longer
09:39:17 <rwbarton> maybe http://hackage.haskell.org/package/unroll-ghc-plugin, but the associated website is gone
09:40:01 <Tekmo> Ohk found it
09:40:02 <Tekmo> http://hackage.haskell.org/trac/ghc/wiki/Inlining
09:40:10 <Tekmo> I don't know if that is accurate any more
09:40:17 <sebastian__> :t map
09:40:19 <lambdabot> (a -> b) -> [a] -> [b]
09:40:22 <shachaf> http://stackoverflow.com/questions/13645159/loop-and-recursion-unrolling recommends TH :-(
09:40:23 <typoclass> but what would ghc inline? suppose the function is 8 instructions and then the recursive call, it'd be those 8 thingies repeated until ... what? i have a hard time visualizing this
09:40:30 <shachaf> Well, for a specific use case.
09:40:31 <Tekmo> But it describes an UNROLL that you add to an INLINE pragma
09:40:47 <glguy> "<DrChaos_>	 well, can I do [ [1] | x <- [1,2] ]" --> sum [1 | _ <- [1,2]]
09:40:53 <DrChaos_> is this possible? I'm on a blackberry away from home so I can't experiment.
09:41:30 <Tekmo> Is what possible?
09:41:35 <Tekmo> I'm still not sure what the question is
09:41:46 <Tekmo> Oh, never mind
09:41:53 <Tekmo> I found your question
09:42:15 <Tekmo> Yes, it is possible to implement length using sum and a list comprehension
09:42:25 <Tekmo> First, think about what the argument to sum should look lik
09:42:50 <Tekmo> If you were to give your hypothetical funciton the list [5, 6, 1]
09:42:55 <Tekmo> What list would you want to pass to sum?
09:43:43 <Tekmo> length xs = let ys = ... in sum ys
09:43:59 <Tekmo> So if xs = [5, 6, 1], then what should ys =?
09:44:11 <DrChaos_> The list [1,1,1]
09:44:15 <Tekmo> Right
09:44:28 <Tekmo> So you need some function (or a list comprehension, if you prefer) that converts a list to all 1's
09:44:38 <Tekmo> length xs = let ys = someFunction xs in sum ys
09:45:01 <Tekmo> I think some other people have already described how to convert a list to 1's using list comprehensions
09:45:09 <Tekmo> So you would just plug that in there
09:45:17 <Tekmo> length xs = let ys = [that list comprehension] in sum ys
09:45:38 <Tekmo> However, the more idiomatic way to do it in Haskell is to use map
09:45:49 <Tekmo> > map (\_ -> 1) [1..10]
09:45:51 <lambdabot>   [1,1,1,1,1,1,1,1,1,1]
09:46:03 <DrChaos_> how to use map?
09:46:10 <Tekmo> Here are some examples
09:46:16 <Tekmo> map (+ 1) [1, 4, 5]
09:46:19 <Tekmo> > map (+ 1) [1, 4, 5]
09:46:21 <lambdabot>   [2,5,6]
09:46:26 <Tekmo> map show [4, 5]
09:46:29 <Tekmo> > map show [4, 5]
09:46:31 <lambdabot>   ["4","5"]
09:46:34 <mcstar> is it totally uncool to read books these days?
09:46:50 <Tekmo> > map (* 2) [1, 2, 3]
09:46:52 <lambdabot>   [2,4,6]
09:47:03 <Tekmo> "map" applies a function to each element of a list
09:47:17 <Tekmo> So when I type "map (* 2) [1, 2, 3]
09:47:21 <Tekmo> It becomes:
09:47:28 <Tekmo> [1 * 2, 2 * 2, 3 * 2]
09:47:41 <Tekmo> or more generally, if I type something like:
09:47:42 <DrChaos_> it's cool to read books even today for us intellectuals
09:47:53 <Tekmo> map f [a, b, c] = [f a, f b, f c]
09:48:21 <Tekmo> So the easiest way to set a list to all 1's is to apply a function that just always returns 1
09:48:26 <weasels> > map f [a,b,c]
09:48:28 <lambdabot>   Ambiguous type variable `b0' in the constraints:
09:48:28 <lambdabot>    (GHC.Show.Show b0)
09:48:28 <lambdabot>     ...
09:48:34 <DrChaos_> nice!
09:48:36 <Tekmo> map (\_ -> 1) [1, 2, 3, 4]
09:48:41 <Tekmo> > map (\_ -> 1) [1, 2, 3, 4]
09:48:43 <lambdabot>   [1,1,1,1]
09:48:55 <shachaf> Are the things that http://hackage.haskell.org/trac/ghc/wiki/Inlining talks about actually real?
09:49:09 <shachaf> Proposals should be clearly marked as such. :-(
09:49:21 <Tekmo> shachaf: I have no clue.  Never tried it
09:49:40 <clahey> Tekmo: Why do length xs = let ys = whatever in sum ys instead of length xs = sum whatever?
09:49:52 <EvanR_> > map (+1) [a,b,c,d]
09:49:54 <lambdabot>   [a + 1,b + 1,c + 1,d + 1]
09:49:57 <clahey> Tekmo: I mean, I understand it as a way to talk about things, but in the final code, that would be better, no?
09:49:59 <Tekmo> clahey: I was just using the intermediate ys variable just to break down the question
09:50:05 <clahey> Tekmo: Cool.
09:50:05 <Tekmo> clahey: It was just a way to talk about things
09:50:22 <clahey> DrChaos_: Why did you want a list comprehension?  Is it an assignment?
09:50:22 <EvanR_> > a == a
09:50:24 <lambdabot>   True
09:50:32 <Tekmo> The complete solution would just be length xs = sum $ map (\_ -> 1) xs
09:50:55 <Tekmo> Of course, that's not idiomatic Haskell easier
09:50:57 <typoclass> shachaf++ . i also often wonder what ghc version or what year a ghc trac wiki page reflects. and who "we" is ...
09:51:06 <Tekmo> The real idiomatic solution is to use a fold
09:51:26 <Tekmo> sum xs = foldl' (+) 0 xs
09:51:29 <Tekmo> or just:
09:51:32 <Tekmo> sum = foldl' (+) 0
09:51:42 <shachaf> Or just:
09:51:44 <shachaf> sum = sum
09:51:46 <Tekmo> lol
09:51:49 <clahey> length = foldl' (const (+1)) 0
09:52:03 <shachaf> length = lengthOf traverse
09:52:09 <shachaf> Except lengthOf is terrible. :-(
09:52:24 <mercury^> Parse error on input PEEL. :(
09:52:32 <Tekmo> :t fold
09:52:34 <lambdabot> (Foldable t, Monoid m) => t m -> m
09:52:48 <Tekmo> length = fold . map (\_ -> Sum 1)
09:53:00 <shachaf> Yes, that's the terrible one.
09:53:03 <Tekmo> :)
09:53:36 <shachaf> On the other hand a lot of the other lens functions compile into nearly optimal Core these days.
09:53:50 <clahey> length = getSum . foldMap (const (Sum 1))
09:54:01 <shachaf> Oh, yes, there's the getSum
09:54:13 <shachaf> It's terrible now matter how you do it.
09:54:32 <clahey> shachaf: Why is it terrible?
09:54:41 <clahey> shachaf: Is it pretty inefficient?
09:55:03 <mcstar> :t getSum
09:55:05 <lambdabot> Sum a -> a
09:55:17 <shachaf> clahey: It turns into something like foldr (+) 0
09:55:23 <mcstar> @hoogle getsum
09:55:24 <lambdabot> Data.Monoid getSum :: Sum a -> a
09:55:36 <clahey> shachaf: And foldr is worse than foldl'.
09:55:36 <Tekmo> I think because it will leak space
09:56:20 <shachaf> clahey: In this case it'll stack-overflow on large lists etc.
09:56:22 <neutrino> @hoogle mktemp
09:56:23 <lambdabot> No results found
09:56:26 <neutrino> @hoogle mktmp
09:56:27 <lambdabot> No results found
09:57:04 <b__> why does ghc vary its type variable names (a,b,t,t1,etc..) when it suggests a type signature?
09:57:21 <Tekmo> It tries to use the type variables from the original signature when possible
09:57:23 <shachaf> It tries to guess based on the names you used.
09:57:30 <b__> okay
09:57:47 <shachaf> sumOf in lens is also terrible
09:57:58 <shachaf> I don't know what a good way to make it not terrible would be, though.
09:58:14 <shachaf> I guess either foldlOf' or foldrOf' would be better than what it's doing now...
09:58:21 <Tekmo> A sufficiently smart compiler, of course
09:58:25 <shachaf> (But which? It depends on your structure.)
09:59:04 <shachaf> Tekmo: GHC isn't sufficiently-smart to optimize reverse [] into [] :-(
09:59:11 <Tekmo> I know, it was a joke :)
09:59:36 <shachaf> You may know, but I didn't!
10:00:15 <Tekmo> @source reverse
10:00:15 <osfameron> there's no reason why it *shouldn't* do that optimization, is there?
10:00:15 <lambdabot> reverse not available
10:00:31 <shachaf> Well, reverse is defined recursively.
10:00:33 <Tekmo> Well, it depends
10:00:49 <Tekmo> So you could do it if you split into two functions
10:00:55 <osfameron> oic
10:01:02 <shachaf> Into two functions?
10:01:17 <Tekmo> Make the first step non-recursivve
10:01:26 <Tekmo> It then calls a second recursive function
10:01:33 <Tekmo> Then GHC can inline the first step
10:01:36 <Tekmo> and catch that special case
10:01:47 <osfameron> well, you could inline reverse [] => [] anyway couldn't you?
10:01:51 <osfameron> just that it wouldn't be that useful
10:01:52 <shachaf> Tekmo: https://github.com/ekmett/lens/commit/5f6fe96f68eb613aa26545b8331b74585f25679d :-)
10:02:03 <Tekmo> Hold on
10:02:05 <n-dolio> What about reverse [1,2,3]?
10:02:05 <clahey> shachaf: I wonder if there should be a foldMap'.
10:02:14 <Tekmo> I can't select that yet without my mouse.  One second
10:03:03 <shachaf> n-dolio: It'd be nice if it figured that out at compile-time, when the length of list is static, maybe unless it's "too long".
10:03:15 <n-dolio> Right.
10:03:22 <Tekmo> Aha!
10:03:27 <Tekmo> It does exactly what I suggested
10:03:44 <nellthu> @help
10:03:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:04:10 <shachaf> n-dolio: Why are you bothering me about it? This is what I pay the GHC people for!
10:04:25 <Tekmo> While I'm here, I have a pipes API question for you guys
10:04:28 <shachaf> Part of the "GHC tax" with every computer I buy.
10:04:40 <Tekmo> So right now I'm almost done with the 3.0 release except for one decision
10:04:46 <Tekmo> Which is the MFunctor type class
10:04:58 <Tekmo> There are two problems with it:
10:05:02 <Tekmo> 1) It uses Rank2Types
10:05:14 <Tekmo> 2) It slows down the Fast pipes implementation
10:05:35 <Tekmo> I can fix both of these problems by reducing it to a smaller clase that exposes the equivalent of mapT lift
10:05:37 <typoclass> shachaf: is it now a facebook tax?
10:05:52 <Tekmo> So the new method type signature would be:
10:06:10 * shachaf doesn't know anything about Pipe
10:06:37 <Tekmo> hoist? :: (Monad m, MonadTrans t) => t' m r -> t' (t m) r
10:06:51 <n-dolio> shachaf: My point is that special casing [] doesn't solve much.
10:07:07 <shachaf> n-dolio: Oh, sure. I'd like a general solution.
10:07:42 <shachaf> n-dolio: In the case of Lens.Zipper, though, it solves the case of descending and then never moving right, which is every use of descending into a lens.
10:09:39 <neutrino> @undo do { x <- foo; let z = map (bar x) baz; return z; }
10:09:40 <lambdabot>  Parse error at ";" (column 49)
10:10:13 <neutrino> @undo do { x <- foo; let z = map (bar x) baz; return z }
10:10:14 <lambdabot>  Parse error at "}" (column 50)
10:10:22 <neutrino> what am i doing wrong here?
10:10:35 <ParahSail1n> lambdabot doesn't like {};
10:10:44 <rwbarton> @undo do { x <- foo; let { z = map (bar x) baz }; return z }
10:10:44 <lambdabot> foo >>= \ x -> let { z = map (bar x) baz} in return z
10:11:03 <ParahSail1n> oh... lets need braces
10:11:04 <shachaf> lambdabot is a big fan of {};
10:11:14 <Blkt> good evening everyone
10:11:14 <shachaf> ParahSail1n: Yes! Let's!
10:11:25 <neutrino> oh
10:11:33 <neutrino> what's the best way to do what i'm trying to do without using "do"?
10:11:44 <ParahSail1n> @pl foo >>= \ x -> let { z = map (bar x) baz} in return z
10:11:44 <lambdabot> (line 1, column 20):
10:11:44 <lambdabot> unexpected "{"
10:11:44 <lambdabot> expecting "()", natural, identifier or "in"
10:11:50 <typoclass> Blkt: hello
10:11:54 <rwbarton> heh
10:12:09 <Blkt> typoclass: :)
10:12:10 <rwbarton> the braces have outlived their usefulness
10:12:22 <shachaf> @pl foo >>= (\z -> return z) (map (bar x) baz)
10:12:23 <lambdabot> return (map (bar x) baz) =<< foo
10:12:44 <neutrino> @pl foo >>= \ x -> let z = map (bar x) baz in return z
10:12:45 <lambdabot> (flip map baz . bar) `fmap` foo
10:13:26 <neutrino> hmm..
10:14:36 <raek> let f x = map (bar x) baz in fmap f foo
10:20:28 <Tekmo> Ok, let me rephrase my earlier pipes question
10:20:43 <Tekmo> Which would matter more to you: avoiding Rank2Types or providing a more elegant type class?
10:20:59 <atriq> More elegant type class, every time
10:21:58 <Tekmo> Any particular reasoning?
10:22:21 <atriq> Rank2Types seems to be everywhere anyway
10:22:27 <atriq> You can't stop the Rank2Types
10:22:51 <Tekmo> I'm not worried about depending on the extension so much as type inference
10:23:16 <atriq> But if you use it to make a more elegant type class, you're showing how it can be useful, making it slightly more likely to get into the platform
10:23:27 <Tekmo> Alright
10:23:31 <atriq> The type inference stuff, though...
10:23:32 <Tekmo> Then Rank2Types it is!
10:23:47 <atriq> Based on the opinion of one person who doesn't use pipes!
10:23:49 <tristanStrange> /quit
10:23:55 <Tekmo> Haha
10:24:24 <Tekmo> Well, I was fishing for insights about what are the main disadvantages of Rank2Types
10:25:50 <Tekmo> For example, the HaskellPrime page for Rank2Types says that a Con is that Rank2 functions are not first class
10:25:54 <Tekmo> But I'm not sure why that is
10:27:14 <Tekmo> Oh wait, never mind, I see why now
10:27:31 <Tekmo> A rank2 function must be applied to its argument to be used
10:28:08 <jubos> hi, i want to install cabal-dev but I am getting some error in cabal saying that the following packages will be broken by a reinstall.  Most seem ok, but the fact that haskell-platform-2012.4.0.0 is listed is worrisome.  Is there a cabal-dev version that is safe with this version of the haskell platform?
10:28:57 <Tekmo> If I remember correctly, you have to tweak the cabal-dev.cabal file to install it correctly
10:29:05 <Tekmo> Let me go look it up
10:29:32 <jubos> Tekmo: thanks.  Is it the current best practice to just use cabal-dev for everything to avoid the DLL hell?
10:30:16 <Tekmo> I think so, although I don't
10:30:54 <atriq> I avoid the hell by going out there and fixing things
10:30:57 <c_wraith> I normally just blow away ~/.ghci when I have problems.  Seems easier than using cabal-dev
10:31:28 <rwbarton> the real best practice is understanding .cabal files and cabal install error messages
10:31:40 <Tekmo> http://www.reddit.com/r/haskell/comments/137156/this_is_unacceptable_cabal/
10:31:50 <n-dolio> Tekmo: If you want rank-2 functions to be first-class, you need rank-3 types.
10:31:55 <Tekmo> That's the link that has the answer
10:32:15 <jubos> Tekmo: thanks!
10:32:19 <Tekmo> n-dolio: In this case I'm fortunate and I don't need it to be first class
10:32:21 <Tekmo> You're welcome!
10:32:30 <n-dolio> And so on.
10:32:34 <Tekmo> n-dolio: It will always be fully applied in its normal use cases
10:34:06 <shachaf> If you want RankN functions to be first-class, you need RankN+1 types. Unfortunately GHC only supports RankNTypes, not RankN+1Types
10:34:39 <atriq> shachaf, what if you want Rank -1 functions to be first class?
10:34:42 <c_wraith> GHC has RankN+1Types.  Though it's kinda painful to use.  -XImpredicativeTypes
10:34:56 <jubos> rwbarton: this sounds good.  Is the goal to have more people submitting patched .cabal files to get them into hackage.  Perhaps a linting effort would be more effective to prevent versions from ever breaking the latest platform packages
10:35:08 <shachaf> c_wraith: That's not really rank, is it?
10:35:20 <Tekmo> I think Hackage needs a way to let people other than the package maintainer update the .cabal file
10:35:34 <c_wraith> shachaf: well, Rank N types are implied by impredicative instantiation.
10:36:19 <Tekmo> Or at least, a package maintainer should be able to enable an option that lets other people modify their cabal file, if they feel they will not be responsive enough to maintain it themselves
10:36:22 <c_wraith> jubos: I get the feeling most people people who release packages don't use the haskell platform.
10:36:30 <n-dolio> ImpredicativeTypes is just a weird distinction GHC makes.
10:36:53 <jubos> c_wraith: is the better solution to just use ghc and cabal?
10:37:06 <c_wraith> jubos: that combination works better for me.
10:38:49 <jubos> c_wraith: i may give that a go
10:38:50 <Tekmo> I thought package maintainers were supposed to target the Haskell platform, to avoid these problems
10:40:07 <neutrino> if packages pkga and pkgb contain the same module Foo.Bar, and define functions quuxA and quuxB respectively, will importing Foo.Bar give me quuxA, quuxB, or both?
10:40:27 <Tekmo> It will give you a conflict
10:40:30 <neutrino> oh
10:40:40 <neutrino> so modules don't compose like this?
10:40:41 <neutrino> ok
10:40:42 <Tekmo> You will need to hide one of the two package or use an extension to select which package to import
10:40:45 <neutrino> thanks Tekmo
10:40:50 <Tekmo> You're welcome!
10:40:53 <neutrino> that makes sense :)
10:41:00 <rwbarton> or if you are using cabal, specify one of the packages as a dependency
10:41:05 <Tekmo> Oh yeah, that, too!
10:41:09 <neutrino> yeah
10:41:19 <glguy> neutrino: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html "7.3.21. Package-qualified imports"
10:41:29 <neutrino> glguy: thanks
10:41:33 <neutrino> i was just wondering
10:41:34 <glguy> If you need both packages
10:41:46 <neutrino> i have seen a module which does something similar to what i do, extends HUnit assertions
10:42:06 <neutrino> and i'm making a module which does that as well
10:42:06 <Tekmo> Generally you should avoid trampling an existing namespace
10:42:15 <neutrino> right
10:42:32 <Tekmo> Unfortunately, the Haskell community has a bad practice of not giving their library a unique namespace
10:42:50 <Tekmo> Not that I am innocent of that, either
10:43:28 <neutrino> but if there's Test.HUnit exported by the HUnit package, and Test.HUnit.Tools exported by testpack, i could make my own package which exports Test.Hunit.Tools2, right?
10:43:37 <Tekmo> Yes
10:43:45 <neutrino> and that's ok, right?
10:43:56 <node> is the a way to cast and emty list [] to Either [Double][Integer] type?
10:43:57 <Tekmo> Probably :)
10:44:02 <node> *is there
10:44:16 <Tekmo> To be more sure, you could name it: Test.Hunit.Tools.<Your library name>
10:44:17 <rwbarton> there are no "casts" in Haskell, so no
10:44:33 <neutrino> node: you can *construct* your desired type from your given type
10:44:37 <Tekmo> node: use either "Right" or "Left"
10:44:41 <rwbarton> a value of type Either [Double] [Integer] is either a list of Doubles, or a list of Integers
10:44:44 <neutrino> Right and Left are constructors
10:44:56 <rwbarton> labeled with the Left or Right constructor respectively
10:44:56 <neutrino> they both have type Either a b
10:45:11 <node> Tekmo: i have tried []:: Either [Double] [Integer] but no luck
10:45:22 <Tekmo> That's becuase [] is not an Either
10:45:25 <neutrino> no, you don't annotate the type to something else
10:45:28 <neutrino> you have to construct
10:45:30 <rwbarton> "the empty list of Doubles" and "the empty list of Integers" are two different values of your type
10:45:33 <glguy> node: The word “cast” has a specific meaning in Haskell
10:45:34 <neutrino> you call the constructor with your value
10:45:42 <neutrino> you need to wrap your [] into something that'll give you Either a b
10:45:51 <neutrino> you do it like this: Right []
10:45:51 <Tekmo> You probably don't even need to cast it
10:45:54 <neutrino> or: Left []
10:45:55 <Tekmo> What do you want to use it for?
10:46:21 <Tekmo> The reason I say this is because the compiler already knows that "[]" could be any kind of list
10:46:36 <Tekmo> Its type is "[] :: [a]", which means that it could be a list of any kind of value
10:47:00 <node> Tekmo: for calculator which was Integer and Double mode. When i empty stack i pass it to function setStack which requires Either [Double] [Integer] for stack
10:47:14 <neutrino> however, if that list is later extended with some other type like this:
10:47:20 <neutrino> > let x = [] in x ++ [1.2]
10:47:23 <lambdabot>   [1.2]
10:47:25 <Tekmo> node: Explain the setStack function a little bit
10:47:35 <neutrino> then the compiler will *infer* x to be of type [Double]
10:47:38 <Tekmo> node: i.e. why it requires the type Either [Double] [Integer]
10:47:39 <neutrino> or something like that
10:48:05 <Tekmo> node: Or, you could use http://hpaste.org/ to show us the code
10:48:32 <neutrino> node: yeah, show us the coooodeeee
10:48:54 <Tekmo> We'd be more than happy to review your code for you
10:49:10 <kliko> Hey guys, I would like to have a function that does the same as "take 2" (i.e. taking two elements of the list), now that doesn't seem to be really hard, however I want it to be type safe, e.g. if I have a list of smaller than 2 it fails at type checking. Now I've tried implementing something like data Nil = Nil, data Cons a b = Cons a b, the problem here is that I can't change that b to Nil
10:49:10 <kliko> or to another type. Can someone point me to the right direction?
10:49:13 <neutrino> yeah, Tekmo would be more than happy
10:49:17 <neutrino> :p
10:49:41 <Tekmo> :)
10:49:42 <neutrino> kliko: you'd need a special list type
10:50:00 <shachaf> kliko: Maybe (a, Maybe a)
10:50:11 <shachaf> You probably shouldn't really do it that way, though. :-)
10:50:22 <neutrino> kliko: then, you can define the type of lists-n-long with peano arithmetic in the type system
10:50:24 <rwbarton> what's the problem
10:50:26 <neutrino> rwbarton knows how iirc
10:50:29 <neutrino> haha
10:50:32 <rwbarton> take2 :: Cons a (Cons b c) -> (a, b)
10:50:33 <neutrino> i was just typing your nick
10:50:42 <Tekmo> Or even simpler:
10:50:48 <Tekmo> take2 :: (a, (b, c)) -> (a, b)
10:50:48 <node> Tekmo, neutrino http://hpaste.org/78558
10:50:52 <neutrino> rwbarton: that is an even better idea
10:50:59 <rwbarton> it's in his original question :P
10:51:30 <neutrino> heh yeah
10:51:34 <neutrino> it is i guess
10:52:03 <node> Tekmo: stackInt is [Integer] and stack is [Double]
10:52:13 <kliko> Tekmo: my lists can be very long, but (a, (b, c)) doesn't support longer list than three elements does it?
10:52:21 <neutrino> sure it does
10:52:29 <neutrino> c may be a pair again or it may be Nil
10:52:32 <rwbarton> go back to your original
10:52:33 <rwbarton> yes
10:52:39 <rwbarton> what neutrino said
10:52:45 <neutrino> you don't say anywhere that c is a "flat" value
10:52:47 <kliko> Maybe this is simplifying my problem too much
10:52:48 <rwbarton> c can be either Cons foo bar or Nil
10:52:53 <kliko> I am going to show my code
10:52:54 <kliko>  brbr
10:52:54 <Tekmo> kliko: It will type check if you provide it longer nested tuples
10:53:01 <Tekmo> kliko: remember that 'c' can be a tuple itself
10:53:05 <kliko> oh..
10:53:10 <kliko> wait nvm then
10:53:12 <neutrino> @faq is kliko's problem simple?
10:53:13 <kliko> I'm going to try that first
10:53:13 <lambdabot> The answer is: Yes! Haskell can do that.
10:53:20 <kliko> lol
10:53:46 <Tekmo> node: An easier solution is to store two separate stacks
10:54:06 <Tekmo> and just switch which one you refer to
10:54:10 <node> Tekmo: this is that i do, i have 2 stacks in a state
10:54:35 <Tekmo> Oh, ok
10:54:42 <Tekmo> Then you just wrap your [] in Left or Right
10:54:48 <Tekmo> If you wrap it in Left
10:54:59 <Tekmo> then it resets the Double stack
10:55:05 <Tekmo> If you wrap it in a Right, it resets the Integer stack
10:55:10 <kliko> will the empty tuple type check?
10:55:14 <Tekmo> Yes
10:55:22 <kliko> alright thanks!
10:55:23 <node> ok
10:56:12 <Tekmo> You're welcome!
10:57:35 <kliko> Tekmo: one small question, suppose I would like to add an int to your list form
10:57:42 <kliko> like (a) -> (a,b)
10:57:50 <kliko> but then generalized
10:58:07 <kliko> I'm not sure how to do that
10:58:21 <Tekmo> insertInt n (a, b) = (a, (n, b))
10:58:28 <rwbarton> add where?
10:58:42 <kliko> Tekmo: that makes sense
10:58:51 <kliko> Tekmo: but, if I have only one element
10:59:03 <kliko> Tekmo: that would not pattern match
10:59:14 <Tekmo> Thec one-element list is (a, ())
10:59:31 <kliko> oh... darn
10:59:33 <kliko> indeed
10:59:34 <kliko> Thank you!
10:59:41 <kliko> I was confused
10:59:42 <Tekmo> You're welcome!
10:59:43 <kliko> sorry!
11:00:05 <Tekmo> No problem at all
11:00:20 <rwbarton> the Cons/Nil names are maybe a little clearer
11:09:11 <Tekmo> kliko: I forgot to mention that for consistency take2 should be take2 (a, (b, c)) = (a, (b, ()))
11:10:34 <kliko> @Tekmo: would you mind helping me out :(
11:10:35 <lambdabot> Unknown command, try @list
11:10:37 <kliko> I can't get it working
11:11:04 <Tekmo> Ok
11:11:05 <kliko> I've have the following code
11:11:06 <kliko> http://pastebin.com/seWgSPRL
11:11:09 <mauke> The paste seWgSPRL has been copied to http://hpaste.org/78560
11:11:11 <kliko> and I just can't seem to
11:11:18 <Tekmo> Wait just a second
11:11:20 <kliko> fix it :(
11:11:23 <kliko> using type checking
11:11:26 <kliko> I tried everything
11:11:34 <Tekmo> I'm putting my daughter to sleep
11:13:01 <Botje> I bet the monad laws are wonderful for that ;)
11:13:23 <tristanStrange> hey all.... I'm just getting started with haskell and am really having trouble
11:13:36 <tristanStrange> thought i'd try and write some simple algorithms
11:13:57 <kliko>         return a = SplitReader $ \r -> a
11:14:01 <tristanStrange> currently I'm owndering how to find the range of values in a list
11:14:03 <kliko> oeps
11:14:03 <kliko> wrong
11:14:38 <djahandarie> tristanStrange, are you allowed to use functions from the standard library?
11:15:02 <tristanStrange> i guess but i'd rather do it "by hand"
11:15:09 * djahandarie stares at Quix0te
11:15:28 <tristanStrange> trying to understand the functional way of doing things
11:15:29 <djahandarie> tristanStrange, well, there is a question of how 'by hand' you want to do it.
11:15:42 <djahandarie> The functional way of doing things is to do as little by hand as possible :P
11:15:42 <rwbarton> @where ops
11:15:42 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
11:15:52 --- mode: ChanServ set +o dcoutts
11:15:53 <rwbarton> ^ can someone get rid of this Quix0te guy for a bit thanks
11:16:13 <Tekmo> kliko: Ok, I'm back
11:16:17 --- kick: Quix0te was kicked by dcoutts (Quix0te)
11:16:22 <kliko> =)
11:16:25 <Tekmo> I'll write the functions in continuation-passing style, if you don't mind
11:16:32 <Tekmo> *in NON-continuation-passing style
11:16:36 <kliko> ow :(
11:16:37 <kliko> ok
11:16:38 <kliko> :)
11:16:39 <kliko> sure
11:16:39 <shachaf> dcoutts: I have a hunch kicking won't do very much good.
11:16:48 <Tekmo> start = ()
11:17:01 <tristanStrange> well let's say here's the algorithm: http://pastebin.com/tcce8WEZ
11:17:04 <dcoutts> shachaf: me too, but I'm nice the first time :-)
11:17:04 <EvanR> conclusion passing style
11:17:05 <mauke> The paste tcce8WEZ has been copied to http://hpaste.org/78561
11:17:06 <mcstar> whats hunch kicking?
11:17:09 --- mode: dcoutts set +b *!*Quix0te@unaffiliated/quix0te
11:17:09 --- kick: Quix0te was kicked by dcoutts (Quix0te)
11:17:13 <Tekmo> store n l = (n, l)
11:17:16 <tac> Continuations? I'll pass.
11:17:20 <tristanStrange> and i want to do everything using haskells built in functions
11:17:25 <Tekmo> add (x, (y, l)) = (x + y, l)
11:17:35 <Tekmo> mul (x, (y, l)) = (x * y, l)
11:17:39 <djahandarie> > (\xs -> (minimum xs, maximum xs)) [1,2,3,4,5] -- tristanStrange
11:17:41 <lambdabot>   (1,5)
11:17:42 <Tekmo> stop (a, l) = a
11:17:54 <EvanR> note that the built in functions are a library called prelude
11:18:13 <tristanStrange> that's amazing djahandarie!
11:18:34 --- mode: dcoutts set +b Quix0te!*@*
11:19:10 * dcoutts admits he's never really understood the different kinds of irc bans
11:19:12 <djahandarie> tristanStrange, for practice, you could try implementing a function which does that in one pass of the list
11:19:27 <shachaf> dcoutts: It doesn't really matter much in this case.
11:19:53 <typoclass> sorry, but who is "quixote"? he hasn't written any messages at all (that i could see)
11:20:00 <djahandarie> dcoutts, all bans are on a persons mask, which is nick!user@host. So there is only really one type of ban (until you get into weirder freenode-specific stuff like account bans, at least)
11:20:52 <Tekmo> tristanStrange: Another way to write it (which is exactly equivalent) is: range xs = let m1 = minimum xs; m2 = maximum xs in m2 - m1
11:20:57 <kliko> Temko: it almost looks like it's too simple to be true :P, but I'm going to test it =)
11:21:03 <Tekmo> kliko: Try it!
11:21:22 <rwbarton> typoclass: i guess your client doesn't show joins/quits
11:21:24 <kliko> PS: my approach was more like: start f = f ((), ())
11:21:39 --- mode: ChanServ set -o dcoutts
11:21:41 <djahandarie> tristanStrange, the algorithm you linked is imperative and can't really directly be translated into Haskell. At least you wouldn't want to.
11:21:51 <Tekmo> Well, if you meant it to begin with the empty list, you actually want just ()
11:21:53 <typoclass> rwbarton: oooh i see :-) no, it doesn't
11:22:15 <ion> Out of the channels i’m on, Quix0te was doing the same thing on #ubuntu-devel as well.
11:22:39 <Tekmo> Actually, you can translate tristanStrange's algorithm into haskell using a fold
11:22:57 <djahandarie> Tekmo, yes. That's not what I call 'directly'.
11:23:52 <Tekmo> Should I teach him it anyway or not?
11:24:00 <djahandarie> He should figure it out on his own :p
11:24:08 <djahandarie> If he wants to.
11:24:34 <tristanStrange> djahandarie so what would be a functional approach?
11:24:48 <piroko> What does this do? (\s m -> m s)
11:24:52 <Guest30085> piroko: fglip
11:24:53 <Guest30085> flip
11:24:57 <Tekmo> Not quite
11:25:00 <tristanStrange> that's kind of the point of this excercise for me (beside learning haskell)
11:25:03 <rwbarton> tristanStrange: how about just starting by implementing maximum yourself
11:25:09 <Guest30085> well, flip ($)
11:25:10 <Tekmo> @source flip
11:25:10 <rwbarton> have you done that?
11:25:10 <lambdabot> flip not available
11:25:12 * djahandarie agrees with rwbarton
11:25:20 <kliko> Thank you Temko for your insights
11:25:22 <djahandarie> tristanStrange, try implementing the maximum function.
11:25:28 <Tekmo> kliko: You're welcome!
11:25:29 <djahandarie> > maximum [1,2,3,5,7,3,1]
11:25:30 <lambdabot>   7
11:25:33 <djahandarie> That guy.
11:25:36 <tristanStrange> of course. thanks chaps
11:25:48 <Tekmo> (\s m - m s) is a function that takes two arguments, m and s, and applies m to s
11:26:20 <djahandarie> tristanStrange, specifically, try it with explicit recursion first (i.e., where you're pattern matching and destructing the list on the left of the = sign), and then again using foldl'.
11:27:12 <beaky> hello
11:27:20 <Tekmo> Hi
11:27:21 <typoclass> harmless typo: tekmo meant (\s m -> m s)
11:27:27 <Tekmo> Yeah
11:27:42 <babadofar> hi
11:27:44 <beaky> what is the C equivalet of somethink like 'data Foo = Bar | Baz"?
11:27:45 <piroko> hmm
11:27:48 <beaky> euivalent
11:27:51 <Tekmo> a tagged union
11:27:56 <beaky> oh
11:27:59 <shachaf> enum Foo { Bar, Baz };
11:28:06 <Tekmo> Well
11:28:10 <shachaf> Except with more type safety.
11:28:13 <Tekmo> If the constructors are empty, an enumeration will suffice
11:28:20 <shachaf> Yes.
11:28:20 <Tekmo> But if they have fields, then you need a tagged union
11:28:35 <beaky> what about if I make Foo an instance of Show?
11:28:45 <Tekmo> That does not affect the data type
11:29:04 <rwbarton> are you trying to learn C or Haskell here
11:29:06 <beaky> oh
11:29:23 <Tekmo> class instances have no impact on the data type's representation
11:29:29 <beaky> I am translating my haskell skills to C :D
11:29:38 <piroko> Tekmo: Can you give me an example of something that would use that lambda?
11:29:42 <Tekmo> Whenever you define a Show instance, you are basically declaring that there is some "show" function that converts your type to a string
11:29:49 <piroko> Tekmo: I'm having a really hard time wrapping my head around it
11:30:10 <Tekmo> piroko: Let me think
11:30:48 <Tekmo> piroko: Probably the most common occurrency of that function would be in continuations
11:30:56 <rwbarton> const char *showFoo(Foo x) { switch (x) { case Bar: return "Bar"; case "Baz": return "Baz"; default: /* oops */ } }
11:31:31 <Tekmo> piroko: The simplest continuation would be something like the following function:
11:31:32 <mcstar> @pl \(x,y) z -> (max x z,min y z)
11:31:32 <lambdabot> uncurry ((. min) . ap . ((,) .) . max)
11:31:39 <Tekmo> applyTo1 k = k 1
11:32:00 <Tekmo> The "applyTo1" function takes a continuation "k" and applies that continuation to 1
11:32:10 <Tekmo> This is known as "continuation-passing style"
11:32:32 <Tekmo> We could generalize the applyTo1 function to tell it what to apply "k" to
11:32:37 <Tekmo> applyTo n k = k n
11:32:45 <Tekmo> And that is the function you just described
11:32:59 <piroko> hoo boy
11:33:17 <piroko> Alright, thank you :)
11:33:18 <Tekmo> piroko: If you really want to go down the rabbit hole
11:33:26 <Tekmo> That function is "return" for the continuation monad
11:33:30 <rwbarton> > map (\s m -> m s) [sin, cos, tan] 1
11:33:32 <lambdabot>   The function `GHC.Base.map' is applied to three arguments,
11:33:32 <lambdabot>  but its type `(...
11:33:33 <rwbarton> what
11:33:36 <Tekmo> return n k = k n
11:33:42 <Tekmo> except with newtypes
11:33:45 <Tekmo> so it really is
11:33:49 <rwbarton> > map (\s m -> m 1) [sin, cos, tan]
11:33:50 <Tekmo> return n = Cont $ \k -> k n
11:33:51 <lambdabot>   *Exception: showList: No overloading for function
11:34:00 <rwbarton> wow I fail
11:34:01 <djahandarie> @type flip ($)
11:34:02 <lambdabot> b -> (b -> c) -> c
11:34:03 <rwbarton> > map (\m -> m 1) [sin, cos, tan]
11:34:04 <Tekmo> But it still basically the same thing
11:34:04 <lambdabot>   [0.8414709848078965,0.5403023058681398,1.5574077246549023]
11:34:19 <rwbarton> > map ((\s m -> m s) 1) [sin, cos, tan]
11:34:21 <lambdabot>   [0.8414709848078965,0.5403023058681398,1.5574077246549023]
11:34:53 <rwbarton> > let piroko = \s m -> m s in let trigAt x = map (piroko x) [sin, cos, tan] in trigAt 1
11:34:55 <lambdabot>   [0.8414709848078965,0.5403023058681398,1.5574077246549023]
11:35:15 <piroko> lol
11:35:25 <ion> > [sin, cos, tan] <*> pure 1
11:35:27 <lambdabot>   can't find file: L.hs
11:35:29 <ion> > [sin, cos, tan] <*> pure 1
11:35:31 <lambdabot>   [0.8414709848078965,0.5403023058681398,1.5574077246549023]
11:35:35 <ion> > sequence [sin, cos, tan] 1
11:35:36 <lambdabot>   [0.8414709848078965,0.5403023058681398,1.5574077246549023]
11:35:44 <mcstar> > let (|>) = \s m -> m s in 1 |> sin |> cos
11:35:45 <lambdabot>   0.6663667453928805
11:35:54 <Tekmo> piroko: Here is another example
11:35:56 <shachaf> Yay, now's all-the-weird-one-liners-that'll-confuse-the-beginner-o'clock?
11:36:00 <shachaf> I love that time!
11:36:01 <ion> > 1 & sin & cos
11:36:03 <lambdabot>   0.6663667453928805
11:36:06 <Tekmo> piroko: Have youe ver programmed within a framework that requires callbacks?
11:36:27 <mcstar> ion: when did & appear?
11:36:41 <ion> mcstar: Recently.
11:36:46 * mcstar is seeing it the first time
11:37:08 <rwbarton> does lambdabot have it from lens?
11:37:18 <piroko> Tekmo: Yes
11:37:27 <Tekmo> piroko: Callbacks are continuation-passing style
11:37:46 <Tekmo> piroko: When you register a callback, your callback is the continuation
11:37:46 * tac thinks he will just use a giant switch statement.
11:38:23 <Tekmo> piroko: The callback registration function basically takes your callback (i.e. the continuation) and calls it whenever it has an argument ready for your callback
11:38:39 <watermind> theory question... do you have a way to represent an (indexed) weak coproduct of objects A_i, weak in the sense that it corresponds to some lifting of a coproduct, i.e.  ( Σ A_i )_⊥  ...  i.e. in the same way that an haskell sum type is a weak sum
11:38:44 <mcstar> but it is asynchronous
11:38:50 <Tekmo> For example, I could define a "register" function that takes the callback you supply and calls it twice on two different arguments
11:38:51 <mcstar> cps isnt necessarily
11:38:56 <Tekmo> register k = k 3 + k 4
11:39:01 <ion> I dislike the “quux & baz & bar & foo” for the same reason why i find “foo . bar . baz $ quux” better than “foo $ bar $ baz $ quux”, though.
11:39:15 <watermind> or would you just represent such weak coproducts by Σ anyway
11:39:24 <Tekmo> However, you could imagine something more sophisticated where that callback is the function for painting a window or responding to a button click
11:40:05 <Tekmo> registerButton k = forever $ do { x <- waitForButtonClick; k x }
11:40:23 <shapr> shachaf: too much snarky
11:40:25 <Tekmo> That's just a crude example
11:40:49 <rwbarton> i'd rather have the snarky than the examples that'll confuse the beginners
11:40:53 <Tekmo> The continuation monad makes it easier to chain multiple callback functions
11:41:21 <Tekmo> So that instead of writing them in an asynchronous continuation-passing style, you can write them in something that resembles a synchronous programming style
11:41:49 <rwbarton> though i don't think ion's were particularly bad
11:41:50 <shachaf> synchro nus
11:41:54 <Tekmo> Like all monads, there is an "empty" action that corresponds to "return"
11:41:59 <rwbarton> more irrelevant than confusing :P
11:42:04 <b__> anyone with a mac and a  daily need to input math-related symbols with keyboard: what's a practical method for this?
11:42:06 <Tekmo> The "return" continuation just takes your callback and applies it once
11:42:18 <mcstar> elm is advertised as a solution to callback hell using frp
11:42:41 <Tekmo> piroko: Anyway that's just some food for thought for you
11:43:14 <Tekmo> I think FRP is heading in the right direction, but needs more elegance and a clear vision of what FRP is
11:43:38 <mcstar> something sweet, not like spaghetti
11:45:41 <ion> Speak for yourself.
11:45:47 * ion adds some more sugar to his spaghetti.
11:46:44 <node> is there a way to get integer from double? so 1.2 returns 1 of type Integer
11:46:52 <mcstar> floor
11:46:53 <Tekmo> truncate
11:47:01 <Tekmo> :t floor
11:47:03 <Tekmo> :t truncate
11:47:03 <lambdabot> (Integral b, RealFrac a) => a -> b
11:47:04 <lambdabot> (Integral b, RealFrac a) => a -> b
11:47:09 <geekosaur> or ceiling or even round
11:47:16 <node> it is Integral
11:47:25 <node> :t ceiling
11:47:27 <lambdabot> (Integral b, RealFrac a) => a -> b
11:47:33 <Tekmo> node: Integral means it works on lots of things, including integers
11:47:49 <Tekmo> I mean
11:47:58 <rwbarton> the result of any of those functions is any Integral type
11:48:00 <geekosaur> you'll note it's in a context (Integral a ...) =>
11:48:02 <Tekmo> Right
11:48:08 <Tekmo> What rwbarton said
11:48:16 <mcstar> you can specialize it, though
11:48:26 <geekosaur> that means it's a class instead of a type; you can use :i in ghci to see what in-scope types are in a particular in-scope class (or vice versa)
11:48:29 <Tekmo> You don't have to specialize it, though
11:48:38 <Tekmo> If some downstream function expects an Integer
11:48:47 <Tekmo> the result will type-check
11:49:29 <node> ok, there is toInteger method for Integal to return Integer
11:50:44 <rwbarton> you don't need it
11:51:08 <rwbarton> "floor :: (Integral b, RealFrac a) => a -> b" means for example floor :: Double -> Integer
11:51:25 <Tekmo> node, here is an example
11:51:35 <Tekmo> Let's say I define a type-restricted function:
11:51:50 <Tekmo> inc :: Int -> Int
11:51:52 <node> Tekmo: toInteger (truncate (1.2)) works
11:51:54 <Tekmo> inc x = x + 1
11:52:01 <Tekmo> You don't need to Integer, though
11:52:10 <rwbarton> it works, but is unnecessarily complicated
11:52:14 <Tekmo> So, the 'inc' function I just defined expects an 'Int'
11:52:19 <Tekmo> But if I supply it something like:
11:52:19 <node> ok
11:52:22 <Tekmo> inc (floor 2.5)
11:52:25 <Tekmo> it will still type-checki
11:52:53 <node> alright
12:05:19 <RastaTonic> hi, could some help me out with a question about haskell about Maybe types
12:05:41 <Cale> RastaTonic: sure
12:05:42 <beaky_> hello
12:05:50 <beaky_> does C++ have anything like Haskell's typeclasses?
12:06:15 <tac> beaky_: not really, no
12:06:19 <beaky_> :(
12:06:23 <rwbarton> depends on how lenient you are with 'like'
12:06:37 <johnw> beaky_: it got close with C++ concepts, but then backed away slowly
12:06:37 <typoclass> beaky_: i think they tried to add something similar (named "concepts"), but in the end they didn't add it
12:06:44 <parcs`> c++ doesn't need type classe
12:06:56 <tac> typoclass: Oh yeah. I remember reading a sharp criticism of "concepts" somewhere....
12:07:02 <beaky> oh
12:07:11 <parcs`> it has its own techniques for ad hoc polymorphism
12:07:19 <beaky> what is ad hoc polymorphism?
12:07:42 <johnw> type classes
12:07:48 <johnw> implement ad hod polymorphism
12:08:01 <beaky> oh
12:08:24 <johnw> http://en.wikipedia.org/wiki/Ad-hoc_polymorphism
12:08:25 <beaky> how many different kidns of polymorphism are there
12:08:31 <otters> a lot
12:08:47 <beaky> what's so great about polymoprhism?
12:08:54 <rwbarton> nothing is great about anything
12:09:05 <beaky> ah
12:09:06 <RastaTonic> i need to process a list of maybe like [Just 1, Nothing, Just 2, Nothing] and [Just 'a', Nothing, Just 'b'] into [1,' ',2,' '] and ['a',' ', 'b']? but its not working with somehting like helper (Just x) = x
12:09:18 <johnw> beaky: polymorphism can be viewed as way of looking at natural transformations
12:09:29 <koala_man> RastaTonic: fromMaybe ' '
12:09:31 <otters> map (fromMaybe ' ') list
12:09:43 <rwbarton> RastaTonic: the problem is you can't have [1,' ',2,' ']
12:09:55 <rwbarton> or that is one problem, anyways
12:10:21 <johnw> beaky: one sec, i'll find you the reference
12:10:24 <rwbarton> all elements of a list must be of the same type
12:10:29 <RastaTonic> i tries fromMaybe ' ' helper [Just '1', Nothing, Just '2'] but when i try it with [Just 'a', Nothing, Just 'b'] it doesnt work
12:10:43 <kyle__> working my way through "learn you haskell for great good", I decided to make a small method to subtract elements from two lists [9,9,9]-[1,2,3]=[8,7,6] type of thing.
12:10:51 <cjay> “The term "ad hoc" in this context is not intended to be pejorative; it refers simply to the fact that this type of polymorphism is not a fundamental feature of the type system.”
12:10:59 <RastaTonic> i have a ToChar class defined already
12:11:02 <kyle__> It hasn't gotten to maps yet, so I tried this, and get a copilation error:  listsub x y = ((head x)-(head y))++listsub(tail x,tail y)
12:11:02 <RastaTonic> for Char and Int
12:11:03 <cjay> aren't haskell typeclasses a fundamental feature of the type system?
12:11:13 <johnw> beaky: http://lukepalmer.wordpress.com/2008/04/28/whats-a-natural-transformation/
12:11:16 <rwbarton> RastaTonic: well the first one shouldn't have worked either, if that is really what you wrote
12:11:35 <cjay> I think I read here some time ago that typeclasess are not ad-hoc polymorphism
12:12:19 <RastaTonic> the goal is to have a string, where all nothings are spaces, and the values of the just x is the x, wheter they are Chars or Ints
12:12:43 <typoclass> cjay: it's all a bit unclear to me, based on those two wikipedia articles
12:13:23 <johnw> beaky: I may be wrong, but I think of parametric polymorphism as calling the same function with different types, and ad hoc polymorphism as calling different functions with the same name
12:13:41 <rwbarton> kyle__: you have a few syntactical errors there
12:13:50 <cjay> @quote ad-hoc polymorphism
12:13:50 <lambdabot> No quotes for this person. Just what do you think you're doing Dave?
12:13:53 <cjay> hmm
12:13:54 <kyle__> rwbarton: Figured I probably did :)
12:13:56 <rwbarton> you pass multiple arguments to a function like this: listsub (tail x) (tail y)
12:14:02 <beaky> ah
12:14:19 <beaky> I get confused between parametric ad ad-hoc polymorphism as well :(
12:14:23 <rwbarton> (what's really going on is that you are passing listsub the single argument (tail x), and then passing the result the single argument (tail y))
12:15:24 <johnw> parametric: varies in the parameters; ad-hoc: bolted on to the type system
12:17:01 <RastaTonic> so how do i make it work for both Int and Char?
12:17:16 <RastaTonic> i tried using a Typeclass ToChar
12:17:18 <rwbarton> as I recall the "definitions" of parametric/ad-hoc polymorphism on wikipedia are the sort that you would expect to find in a psychology textbook
12:17:33 <RastaTonic> with an instance for both ToChar Int and ToChar Char
12:17:38 <RastaTonic> but that doesnt do it either
12:17:41 <johnw> rwbarton: they relate to how your mother treated you?
12:18:00 <rwbarton> though in a particular setting like in Haskell the distinction is clear-cut
12:18:19 <Cale> RastaTonic: That sounds like you really just want two different functions, or maybe possibly a new typeclass, but that's a bit weird.
12:18:22 <kyle__> rwbarton: Hum.  OK.  And I just realized ++ is wrong, should be : I think... so something more like this?
12:18:25 <kyle__> listsub x y = ((head x)-(head y)):(listsub (tail x) (tail y))
12:18:26 <rwbarton> kyle__: yes, that also
12:18:51 <rwbarton> kyle__: BTW you should be using pattern matching rather than head and tail--but get your version working first, I say.
12:19:07 <rwbarton> Incidentally, most of those parentheses are redundant.
12:19:25 <tomeo> Is there a haskell package that doesn't have to be installed via cabal that helps with memoization?
12:19:55 <rwbarton> RastaTonic: do you have it working for just one type, say Char? it doesn't really sound like it
12:19:55 <kyle__> rwbarton: No one would accuse this of being efficient, just a learning exercise
12:19:59 <b__> anyone with a mac and a daily need to input math-related symbols with keyboard: what's a practical method for this?
12:20:12 <typoclass> rwbarton: yeah, well, wikipedia has many qualities, but being well written isn't among them
12:21:00 <Zedrikov> b__ X server + XCompose ?
12:21:26 <RastaTonic> well the goal is displaying a puzzle so i have to go from [[Just 1,Nothing,Just 1],[Just 2,Nothing,Just 2]] to [[1, ' ',1],[2,' ',2]] using the Puzzel type show function , so i though i could just remove all the Justs and replace all Nothing with a space
12:22:03 <Zedrikov> b__: I have heard that Ukelele can do stuff similar to XCompose. But I am not a Mac user.
12:22:09 <rwbarton> like I said before, you can't have [1,' ',1]
12:22:25 <RastaTonic> but i cant get it to work for both Int and Char, i know why i'm getting the error, cause i'm trying to mix chars and int, but how do i curcumvent this, i have and extra class ToChar with a function tochar for both Int and Char, but how do i integrate it with the Maybe
12:22:49 <rwbarton> did you get it working for just Char?
12:23:02 <RastaTonic> for just Int i did
12:23:05 <RastaTonic> one or the other
12:23:07 <RastaTonic> but not both
12:23:08 <b__> thanks Zedrikov
12:25:13 <RastaTonic> when i use helper Nothing = 0 , helper Just x = x then it will work for Integers
12:25:16 <RastaTonic> but not for Chars
12:25:25 <rwbarton> that doesn't sound like "working"
12:25:30 <rwbarton> but ok
12:25:37 <rwbarton> (don't you need to produce a string?)
12:25:44 <RastaTonic> yes
12:25:59 <b__> Zedrikov, Ukelele does exactly what I want, thanks
12:26:08 <RastaTonic> i thoug i could just replace the nothings and the justs and then flatten the array into a string
12:26:22 <rwbarton> well however you convert an Integer to a Char, you can replace that with a type class method, if you insist
12:27:04 <RastaTonic> i though i could do something like helper Nothing = toChar 0, helper Just x = toChar x
12:27:12 <RastaTonic> for every element in the list
12:27:30 <RastaTonic> but then i get an error saying i'm doing 'Num Char'
12:27:37 <rwbarton> quite so
12:27:57 <RastaTonic> but isnt that exacly why i used the toChar?
12:28:12 <rwbarton> you passed the x from Just x to toChar--x might have been 'a'
12:28:16 <rwbarton> and you also pass 0 to toChar
12:28:24 <rwbarton> why are you doing this anyways
12:28:30 <rwbarton> don't you want a space?
12:28:35 <Chathurga> RastaTonic: Is there no alternate way to represent the list?
12:28:36 <RastaTonic> yes but i have 2 instances of toChar
12:28:42 <RastaTonic> one for Int and one for Char
12:29:10 <RastaTonic> its given this way by my instructors code
12:29:26 <RastaTonic> the goal was to implement a show instance for the puzzle
12:29:31 <rwbarton> yes i know that part
12:29:37 <rwbarton> can you just paste your code?
12:30:00 <Chathurga> With a placeholder -1 if the valid numbers are positive or with a simple tuple like (num :: Int, valid :: Bool)
12:30:23 <shachaf> Chathurga: :-(
12:30:44 <shachaf> Maybe Int is exactly the thing you try to mean by (num :: Int, valid :: Bool)
12:30:44 <monochrom> haha
12:30:56 <Chathurga> Yeah true xD
12:31:04 <Tekmo> This is not Go!
12:31:08 <Tekmo> :)
12:31:09 <RastaTonic> yes i will give a link, its to much for pasting here
12:31:27 <monochrom> (num :: Int, valid :: Bool) would be what you do in inferior languages. and you would expect more bugs
12:32:55 * hackagebot zeromq3-conduit 0.1.0.0 - Conduit bindings for zeromq3-haskell  http://hackage.haskell.org/package/zeromq3-conduit-0.1.0.0 (NicolasTrangez)
12:33:16 <ramses_> RastaTonic: I'm guessing you're not using the type class as you should, all your functions should be polymorphic (I'm working on the same assignment btw :)
12:34:19 <eikke> how long does it tend to take for hackage to render haddocks?
12:34:40 <RastaTonic> http://pastebin.com/6C2e1ibK
12:34:44 <mauke> The paste 6C2e1ibK has been copied to http://hpaste.org/78563
12:34:57 <RastaTonic> ramses_: ja ik weet dat het ergens iets me die typeclasses moet zijn
12:35:07 <RastaTonic> maar haskell is zo enorm rommelig om te leze soms :p
12:35:20 <Tekmo> You don't need a type class for this
12:35:44 <Tekmo> It is as simple as defining one function, let's call it "f"
12:35:51 <Tekmo> f :: Maybe Int -> String
12:35:58 <ramses_> RastaTonic: write type declarations to start with
12:36:19 <Tekmo> f should convert Nothings to " " and Just Int into the integer's string representation
12:36:26 <ramses_> Tekmo: it's a college assignment and the function has to work for all instances of a given class
12:36:33 <startling> eikke: day or two
12:36:39 <eikke> right, thanks
12:36:43 <ciaranm> is there a preferred way of constructing a record when using lenses?
12:36:45 <rwbarton> the mystery to me is still "toChar 0"
12:36:47 <Tekmo> ramses_: So do you mean:
12:36:50 <rwbarton> what purpose could this serve
12:36:57 <Tekmo> f :: (ToChar a) => Maybe a -> Char
12:37:04 <Tekmo> Is that the type signature you want?
12:37:14 <startling> ciaranm: beyond data A { _a :: X, _b :: X }; makeLenses ''A?
12:37:15 <RastaTonic> rwbarton: the reasoing was to avoid the wrong type error, so the output would always be a char
12:37:24 <tomeo> What is the standard approach to memoization in haskell?
12:37:26 <ciaranm> startling: yeah. the _s are horrible.
12:37:26 <edwardk> ciaranm: my usual trick is to make a Data.Default.Default instance fot it, and then use the lens to construct from there
12:37:40 <startling> ciaranm: yeah. :/
12:37:40 <ramses_> Tekmo: he has to construct an instance (ToChar a) => Show (Puzzel a)
12:37:47 <edwardk> ciaranm: def & foo .~ 1 & bar .~ baz & quux .~ quaffle
12:37:50 <Pacoup> ( Try Haskell is awesome! Thanks to whoever made it =D )
12:37:51 <rwbarton> RastaTonic: i don't get it
12:37:58 <rwbarton> don't you know what you want to produce in that case?
12:38:01 <rwbarton> why not just ... write that
12:38:07 <Tekmo> ramses_: Ok, let's start from there.  The type of this function would be:
12:38:10 <rwbarton> where did 0 come from
12:38:12 <ciaranm> edwardk: mmm, that looks fairly painless. thanks.
12:38:39 <edwardk> if makeclassy makes that too polymorphic you can use Foo{} & foo .~ 1 & ...
12:38:46 <koala_man> tomeo: the classic approach is to map over the range you want, and keep referencing that thunk
12:38:49 <RastaTonic> well the zero should be a space charactor
12:38:51 <RastaTonic> *char
12:38:53 <Tekmo> ramses_: Oh wait, before I continue, is 'l' supposed to be an instance of ToChar?
12:39:13 <edwardk> but then you have to be careful to initialize all the fields
12:39:13 <ramses_> RastaTonic: think about what the types of your functions should be first, the implementation will follow from them
12:39:32 <tomeo> koala_man: would you be able to link me an example of what you mean?
12:39:35 <rwbarton> RastaTonic: so why not just write ' '
12:39:42 <rwbarton> instead of all these toChar 0 hoops
12:39:53 <ramses_> Tekmo: yes, as I showed before, the Show instance is for all puzzle types inhabitated by a ToChar instance
12:39:54 <RastaTonic> yes, was a remnant from trying to figure out just the Ints
12:40:15 <rwbarton> it seems like you might have a problem with defaulting with that 0
12:40:24 <rwbarton> fortunately it is useless so that problem is easy to fix
12:40:24 <Tekmo> There is no reason to default at all
12:40:25 <koala_man> tomeo: like http://www.haskell.org/haskellwiki/Memoization#Memoization_with_recursion
12:40:31 <tomeo> thanks koala_man
12:40:32 <Tekmo> Why use an intermediate representation at all?
12:41:07 <monochrom> to postpone solving the real problem
12:41:23 <RastaTonic> well i know you can just use the map, but when i started i just folowed my first idea,
12:41:44 <rwbarton> @where xy
12:41:50 <lambdabot> I know nothing about xy.
12:42:10 <monochrom> http://www.perlmonks.org/index.pl?node_id=542341
12:42:16 <Tekmo> What is the type of the function you have to implement?
12:42:46 <ramses_> Tekmo: instance (ToChar a) => Show (Puzzel a) where ...
12:42:55 <Tekmo> Right, that's the class
12:43:02 <ramses_> Tekmo: that's all
12:43:03 <Tekmo> but I want him to think about the show function's type
12:43:09 <ramses_> Tekmo: ow ok :)
12:43:21 <ramses_> Tekmo: that's what I've been saying
12:43:27 <monochrom> is ToChar absolutely necessary?
12:43:30 <tomeo> koala_man: hm, is it some kind of internal haskell thing that makes memoized fib actually memoized?
12:43:40 <ramses_> monochrom: yes, taht's the assignment
12:43:41 <Tekmo> monochrom: My understanding is that ToChar is hard-wired in because of the assignment
12:43:55 <monochrom> is Show absolutely necessary too?
12:44:01 <tomeo> perhaps map is implemented with memoization?
12:44:07 <ramses_> haha, yes, that's the purpose of the assigment
12:44:10 <Tekmo> The Show instance is the assignment
12:44:31 <monochrom> has anyone seen the assignment, verbatim?
12:44:45 <RastaTonic> well i think it should be this for the show instance instance (ToChar a) => Show (Puzzel a)
12:44:49 <koala_man> tomeo: thunks are only evaluated once
12:44:52 <monochrom> and yes I have an ingrained distrust of student claims
12:44:52 <ramses_> the ToChar is given, the assignment is to write a Show instance with a ToChar constraint
12:45:15 <ramses_> monochrom: I've solved it today as well
12:45:19 <RastaTonic> monochrom, ill give it to you if you know how to speak dutch
12:45:38 <Eelis> > toRational (1/0)
12:45:39 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
12:45:43 <Eelis> what's that about ^
12:45:48 <shapr> Ik begrijp het niet!
12:45:54 <Tekmo> It's printing infinity
12:46:00 <Eelis> nope
12:46:03 <ramses_> Eelis: an approximation of infinity
12:46:06 <Tekmo> Now I know the first 70 digits of infinity
12:46:07 <Tekmo> :)
12:46:21 <Eelis> it seems to me that 1/0 is a much better approximation than this bignumber/1 it uses
12:46:54 <monochrom> > toRational (1/0) == 1/0
12:46:55 <lambdabot>   *Exception: Ratio.%: zero denominator
12:47:02 <monochrom> too bad
12:47:03 <typoclass> > 1 R.% 0
12:47:05 <lambdabot>   *Exception: Ratio.%: zero denominator
12:47:21 <rwbarton> > 2 * toRational (0/0) == 3 * toRational (-1/0)
12:47:23 <lambdabot>   True
12:47:24 <koala_man> tomeo: map creates a list of thunks, and as long as you keep accessing thunks from that resulting list, they too will only evaluate once
12:47:28 <typoclass> i'd have hoped toRational would throw this ^^ exception, instead of giving a bonkers very large number
12:47:29 <rwbarton> ^ a little-known fact about 0/0 and -1/0
12:47:30 <int-e> > 2^1024 == toRational (1/0)
12:47:31 <lambdabot>   True
12:47:44 <Tekmo> You guys only give lambdabot hard problems.  Here, lambdabot, why don't you relax and enjoy this:
12:47:48 <Tekmo> > toRational (4/2)
12:47:50 <lambdabot>   2 % 1
12:48:00 <luite> @hoogle Int -> Int -> Int
12:48:00 <lambdabot> Test.QuickCheck.State computeSize :: State -> Int -> Int -> Int
12:48:00 <lambdabot> Data.Time.Calendar.MonthDay monthAndDayToDayOfYear :: Bool -> Int -> Int -> Int
12:48:00 <lambdabot> Data.Bits (.&.) :: Bits a => a -> a -> a
12:48:07 <tomeo> koala_man: so two equal thunks will both get their value from one calucation?
12:48:11 <monochrom> I sometimes give lambdabot easy problems
12:48:21 <typoclass> :t toRational
12:48:22 <lambdabot> Real a => a -> Rational
12:48:22 <int-e> > ()
12:48:24 <lambdabot>   ()
12:48:31 <Tekmo> > 1
12:48:32 <lambdabot>   1
12:48:33 <int-e> @bot
12:48:33 <lambdabot> :)
12:48:49 <koala_man> tomeo: no, but one thunk will evaluate once, no matter how many times it's referenced
12:49:09 <ramses_> @pl [1..]
12:49:10 <lambdabot> [1..]
12:49:12 <theorbtwo> > toRational sin 3
12:49:13 <lambdabot>   The function `GHC.Real.toRational' is applied to two arguments,
12:49:13 <lambdabot>  but its ty...
12:49:17 <ramses_> @pl \x -> [1..x]
12:49:17 <lambdabot> enumFromTo 1
12:49:27 <theorbtwo> > toRational (sin 3)
12:49:28 <lambdabot>   5084384125703515 % 36028797018963968
12:49:30 <koala_man> tomeo: let foo = f x in foo*foo  will evaluate f x once, while (f x)*(f x) may/will evaluate it twice
12:50:41 <monochrom> use aliasing to obtain memoization
12:50:43 <hpaste> “tristan strange” pasted “finding range of numbers” at http://hpaste.org/78564
12:51:07 <tristanStrange> ok so, i've managed to implement my own function that finds the range of a list of numbers....
12:51:33 <koala_man> tomeo: from there it's a short step to  let t = map f [0..10] in (t !! 3)+(t !! 5)+(t !! 3)+(t !! 3), which will only evalute f 3 once. and then on to that example
12:51:33 <tristanStrange> so is it possible to do this without recursing over the list twice?
12:51:51 <tristanStrange> i.e. once for max and once for min?
12:52:30 <rwbarton> tristanStrange, yes
12:52:50 <Tekmo> tristanStrange: Yes
12:52:52 <RastaTonic> ramses_:  verwerk :: (ToChar a) => [Maybe a] -> [Char] is this correct for type definition in the show instance
12:52:54 <Tekmo> That's what folds are for
12:52:58 <rwbarton> for example you could write a function in the style of your minimum' that returns both the minimum and the maximum
12:52:59 <tristanStrange> do i need to pass current min and max recursively?
12:53:02 <RastaTonic> because i'm getting an error still,
12:53:03 <tomeo> koala_man: okay, but in memoized_fib they create new instances of map. wouldn't that effect memoization?
12:53:34 <tristanStrange> ah ok thanks rwbarton i'll have a think
12:53:43 <monochrom> foldl (\(big, small) y -> (max big x, min small y)) x xs
12:53:50 <ramses_> RastaTonic: load it an see if it type checks :) The class constraint is the way too go
12:53:50 <Tekmo> ^
12:54:03 <tristanStrange> oh tekmo can you explain why this is what folds are for?
12:54:13 <typoclass> so toRational (1/0) is using the Fractional Float instance, isn't it? is that because of defaulting ...?
12:54:26 <rwbarton> should be Double and yes
12:54:35 <Tekmo> tristanStrange: Well, a fold is what you do when you fold a list into a single value
12:54:38 <typoclass> rwbarton: ok, thanks
12:54:40 <rwbarton> at least, Double is the default default
12:54:46 <rwbarton> you can set a non-default default
12:54:51 <Tekmo> tristanStrange: For example, a simple fold is:
12:54:56 <koala_man> tomeo: they don't. memomized_fib is a thunk too!
12:54:58 <Tekmo> sum xs = foldl' (+) 0 xs
12:55:04 <typoclass> rwbarton: er that would be a fault then ...
12:55:05 <typoclass> :)
12:55:28 <tristanStrange> ah monochrom, i'll take a close look ta
12:55:31 <tomeo> koala_man: so nothing is evaluated until all memoized_fib calls have been run?
12:55:38 <tristanStrange> thanks tekmo!
12:55:41 <shachaf> Tekmo: That definition of sum violates the Report.
12:55:44 <Tekmo> tristanStrange: You're welcome!
12:55:45 <tomeo> and then we are left with a bunch of thunks
12:55:49 <tomeo> which are then evaluated
12:56:08 <Tekmo> shachaf: Who said I was defining the Report's sum?
12:56:19 <ramses_> @pl \b h -> map (flip (zipWith Pos) [1..]) (map (replicate b) [1..h])
12:56:19 <lambdabot> (map (flip (zipWith Pos) [1..]) .) . (. enumFromTo 1) . map . replicate
12:56:28 <Zedrikov> Who needs to memoize Fibo ?
12:56:41 <Zedrikov> It is more efficient, not to memoize it
12:56:48 <Zedrikov> and use a matrix instead.
12:56:58 <koala_man> it's about memoization, not fib
12:57:09 <koala_man> tomeo: I don't entirely know what you mean by that
12:57:26 <tomeo> koala_man: sorry, Im finding this difficult to comprehend :)
12:58:25 <monochrom> I think "thunk" misses the point altogether
12:58:33 <koala_man> tomeo: imagine you have let memoized_fib = .. in .. instead, and maybe it's more obvious to see how it refers to itself rather than creating new maps
12:58:50 <ciaranm> runState is backwards.
12:58:57 <monochrom> firstly, "thunk" is just a funky way to say "expression". when you explain numbers, do you say "numbers" or do you say "bits"?
12:59:21 <shachaf> monochrom: As a word for "a part of the graph that may not have been reduced"?
12:59:30 <monochrom> secondly, thunk or expression, whatever. during any evaluation, memoized or not, you work with thunks. totally not about memoization.
12:59:32 <shachaf> monochrom: "expression" is syntactic; do you mean "value"?
13:00:15 <monochrom> I mean expression and it's syntactic and if you prefer to say "expression graph" to emphasize that sharing may happen that's cool
13:00:41 <shachaf> OK.
13:00:51 <hpaste> node pasted “calc” at http://hpaste.org/78565
13:00:53 <monochrom> memoization is when thunks are not thrown away. no memoization is when thunks are thrown away.
13:01:26 <monochrom> so why are thunks not thrown away? because of aliasing. because you still have some identifier referring to that thunk
13:01:53 <node> i have a weird parser error in the code http://hpaste.org/78565
13:01:58 <tomeo> thanks koala_man, I'll have to do some more reading. Thanks for trying :)
13:02:28 <rwbarton> node: what's up with line 22
13:04:27 <node> rwbarton: i wanted to convert integer to double, and then do function on m1 and m2 cause f function takes only double :[
13:04:47 <rwbarton> did you look at your paste?
13:04:57 <rwbarton> line 22 is too far indented by a lot, because some tab characters snuck in
13:05:11 <rwbarton> (do all browsers display tabs the same way?)
13:05:16 <monochrom> why we can just say "expression" without "graph": "let x=2*2 in x" is an expression, and it already tells you the graph
13:05:25 <node> i got rid og them now, but have an error again
13:05:45 <monochrom> it is, emphatically, a different expression from "(2*2)*(2*2)"
13:06:00 <monochrom> and equivalently, a different graph
13:06:03 <typoclass> probably i'm misunderstanding, but why doesn't the toRational function in instance Real Float check if the float is Infinity, and error if it is?
13:06:22 <RastaTonic> any ideas on what i'm doing wrong? http://pastebin.com/index/6C2e1ibK
13:06:23 <mauke> The paste 6C2e1ibK has been copied to http://hpaste.org/78563
13:06:35 <shachaf> typoclass: Doubles will misbehave. Such is life.
13:06:53 <monochrom> typoclass, it is likely a bug, an oversight
13:07:02 <typoclass> shachaf: yes, i consider them the devil, overrated, difficult to work with, etc., but in this case ...
13:07:12 <typoclass> monochrom: oh wow
13:07:26 <shachaf> typoclass: The devil *and* overrated?
13:07:42 <rwbarton> where is that instance defined anyways
13:07:53 <rwbarton> oh nm
13:07:54 <shapr>  shachaf: It does seem like you say those things often.
13:07:54 <typoclass> rwbarton: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Float.html#Real
13:07:56 <rwbarton> GHC.Real
13:08:02 <rwbarton> or not
13:08:13 <shachaf> shapr: They apply to many things.
13:08:21 <rwbarton> > decodeFloat (1/0)
13:08:22 <lambdabot>   (4503599627370496,972)
13:08:28 <typoclass> rwbarton: sorry, the "#..." part was borked, but you can easily find it. it's "instance Real Float"
13:08:33 <rwbarton> yep, thanks
13:08:46 <shapr> shachaf: I think pointing people toward positive things is often a better way.
13:09:17 <typoclass> shapr: i'm considering a haskell wiki page listing things that shachaf considers the devil
13:09:18 <latro`a> :t decodeFloat
13:09:19 <lambdabot> RealFloat a => a -> (Integer, Int)
13:09:25 <latro`a> ...Integer?
13:09:29 * latro`a scratches head
13:09:43 <monochrom> because Int may be too small
13:09:52 <latro`a> under what circumstances?
13:09:58 <shachaf> shapr: I don't really say this so much in the context of people asking about whether to use something.
13:09:58 <latro`a> triple precision floats?
13:10:03 <rwbarton> Double on 32-bit systems?
13:10:04 <tristanStrange> monochrom:  foldl (\(big, small) y -> (max big x, min small y)) x xs isn't working for me...?
13:10:07 <latro`a> (quadruple I guess)
13:10:09 <latro`a> oh hm
13:10:10 <typoclass> latro`a: it decodes it into mantissa and exponent (see ieee specification for floats)
13:10:10 <rwbarton> nothing exotic
13:10:14 <monochrom> consider a computer architecture with 1024-bit float and 16-bit int
13:10:15 <latro`a> I know that
13:10:29 <zhulikas> what architecture has that?
13:10:37 <tristanStrange> how do i use it? apparenty x and xs aren't in scope
13:10:38 <monochrom> I'm exaggerating
13:10:38 <shachaf> The one under consideration.
13:10:39 <latro`a> I suppose I assumed RealFloat was rather specialized, not really any reason for that thinking though
13:10:48 <shachaf> tristanStrange: Well, what are x and xs?
13:11:00 <monochrom> as it stands, we have had 80-bit floats and 32-bit ints
13:11:00 <shapr> shachaf: If doubles misbehave, what's a better option?
13:11:05 <zhulikas> well I guess designers of Haskell considered everything :)
13:11:06 <latro`a> 80 bit?
13:11:07 <latro`a> wut
13:11:21 <typoclass> shapr: in my opinion the world needs moar Ratio. also moar Fixed
13:11:36 <latro`a> as a numerical analyst in training
13:11:38 <latro`a> my response:
13:11:39 <latro`a> what.
13:11:54 <shachaf> For what?
13:12:06 <latro`a> we already just barely get by in numerical analysis with doubles, heh
13:12:24 <latro`a> though actually I guess in some cases we don't
13:12:29 <monochrom> tristanStrange, it's intended to be "range (x:xs) = ... foldl (\(big, small) y -> (max big x, min small y)) x xs ..."
13:14:05 <tristanStrange> ok thats making a bit more sense
13:14:27 <monochrom> 80-bit float and 32-bit int is x86. by float and int I don't mean C type names
13:14:36 <latro`a> oh really?
13:14:37 <rwbarton> if the foldl version is not immediately obvious to you, i recommend writing the direct recursion version first
13:14:49 <latro`a> (@ 80 bit float)
13:14:54 <monochrom> has been like that since 386. where have you been! :)
13:15:04 <latro`a> I don't really do low level stuff
13:15:10 <rwbarton> http://en.wikipedia.org/wiki/Long_double
13:15:21 <parcs`> long double is 128 bits for me
13:15:36 <sipa1024> parcs`: storage size; not useful size
13:15:40 <monochrom> iirc sparc was even 128-bit float and 32-bit int
13:15:50 <ciaranm> sometimes i hate the indenting rules
13:16:06 <parcs`> sipa1024: what do you mean
13:16:43 <parcs`> sipa1024: oh, you mean my long double is padded?
13:16:55 <rwbarton> are you on x86?
13:16:58 <sipa1024> parcs`: yes
13:17:02 <parcs`> x86 64
13:17:13 <rwbarton> yes, then it is different perhaps
13:17:14 <sipa1024> parcs`: x86 pads it to 96 bits, x86-64 to 128
13:18:18 <parcs`> :(
13:18:56 <rwbarton> ah, I see
13:24:24 <ramses_> if I have a WriterT over a list, how can I extract an element of the list in a do block? Is there a method which I can lift through the writer?
13:24:44 <ramses_> s/method/function
13:26:05 <simpson> :t pass -- maybe?
13:26:06 <lambdabot> MonadWriter w m => m (a, w -> w) -> m a
13:26:48 <node> i m stuck at concerting Integer to double in my code. http://hpaste.org/78567 how could it be fixed?
13:27:13 <sipa> :t fromInteger
13:27:14 <lambdabot> Num a => Integer -> a
13:27:31 <sipa> > fromInteger 5 :: Double
13:27:32 <node> *converting
13:27:33 <lambdabot>   5.0
13:28:23 <sipa> node: :: does not convert or cast as you may be used to from other languages
13:28:33 <sipa> node: it simply specifies what type that variable should be
13:29:07 <node> sipa: but then i was doing this in Prelude it worked
13:29:08 <sipa> but stackInts contains ints i guess, so the numbers you get from pattern-matching against it are Ints
13:29:16 <node> sipa: thanks you, it worked!
13:29:34 <monochrom> @type 5
13:29:35 <lambdabot> Num a => a
13:29:46 <monochrom> think over that
13:30:02 <Pranz> > a :: Double where a = 5
13:30:03 <lambdabot>   <hint>:1:13: parse error on input `where'
13:30:17 <sipa> > let a = 5 in a :: Double
13:30:19 <lambdabot>   5.0
13:30:23 <Pranz> ah
13:31:29 <johkke> I know it's a stupid question, but I'm unable to find the answer: how can I merge two arrays [1,2] and [1,1] to [[1,2],[1,1]]
13:31:57 <ciaranm> johkke: uh, [a, b] ?
13:32:19 <glguy> johkke: Those are lists, arrays are different; and what you wrote is the answer :)
13:32:21 <sipa> johkke: DT oefeningen aan het maken? :p
13:32:22 <shachaf> johkke: I think your problem may be underspecified. :-)
13:32:25 <Pranz> > [x, y | x <- [1..3], y <- [1..3]]
13:32:26 <lambdabot>   <hint>:1:7: parse error on input `|'
13:32:26 <shachaf> (Also, those are lists, not arrays.)
13:32:30 <johkke> sipa: Ja :D
13:32:39 <Pranz> Wasn't that how you wrote t?
13:32:44 <Pranz> god i'm awful at haskell syntax
13:32:48 <RastaTonic> iemand da mij kan helpe me die puzzel show dinge:p
13:33:06 <glguy> Pranz: you need either (x,y) or [x,y], but not x,y
13:33:15 <Pranz> [(x, y) | x <- [1..3], y <- [1..3]]
13:33:16 <Pranz> ah right
13:33:30 <Pranz> > [(x, y) | x <- [1..3], y <- [1..3]]
13:33:31 <sipa> don't expect people here to make your homework, but usually they're very helpful if you want to understand things
13:33:31 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:33:34 <Pranz> There
13:33:36 <Pranz> merge
13:33:37 <ramses_> RastaTonic: what do you have?
13:33:48 <RastaTonic> process :: (ToChar a) => Maybe a -> Char
13:33:59 <RastaTonic> process (Just x) = toChar x
13:34:21 <RastaTonic> error =  Ambiguous type variable `a0' in the constraints: (Num a0) arising from the literal `1' at <interactive>:57:15
13:34:36 <RastaTonic> but i dont get it, because i'm saying the a is of type ToChar
13:34:43 <RastaTonic> why does it say the Num
13:34:46 <sipa> RastaTonic: paste your code?
13:34:53 <sipa> (not here, hpaste.org)
13:34:56 <ramses_> RastaTonic: where does that one come from? test input in ghci?
13:35:15 <sipa> RastaTonic: ToChar is not a type, by the way, it's a class
13:35:23 <RastaTonic> http://pastebin.com/yWxhXn1C
13:35:26 <sipa> judging from what you said above
13:35:33 <ramses_> and the ToChar constraint does not pin down the type of a completely, it just says that a is some instance of ToChar, can be any of them
13:35:38 <mauke> The paste yWxhXn1C has been copied to http://hpaste.org/78568
13:35:40 <RastaTonic> yes i tested with verwerk [Just 1, Nothing, Just 2]
13:36:03 <RastaTonic> so how do i tell it to chose the right one?
13:36:14 <RastaTonic> i though that was the whole point that it shoudl be doing this automaticly?
13:36:29 <ramses_> [Just 1, Nothing, Just 2] :: [Maybe Int]
13:36:33 <ramses_> for example
13:36:39 <ramses_> if you have an Int instance in scope
13:36:45 <RastaTonic> yes but thats for testing
13:37:02 <glguy> RastaTonic: The point is to pick the implementation given the types, not to guess the types
13:37:46 <RastaTonic> hmm :s
13:38:05 <glguy> RastaTonic: but in most cases the types can be inferred so you don’t have to help
13:38:34 <RastaTonic> so in this particular example how can i make it work? cause i'm just not getting it
13:38:54 <ramses_> for your test data, add the type annotation I showed you
13:39:52 <RastaTonic> yes now i get an error?
13:40:00 <RastaTonic> Couldn't match expected type `Maybe Int' with actual type `String'
13:40:07 <RastaTonic> verwerk  [Just 1, Nothing, Nothing, Just 2] :: Maybe Int
13:40:35 <sipa> add brackets around it
13:40:36 <ramses_> put brackets around the input
13:40:47 <sipa> now you say that the result of verwerk ... should be Maybe Int
13:40:51 <ramses_> the type annotation annotates the whole expression now
13:41:11 <FireFly|> also, you forgot the [ ].. [Maybe Int] means "list of Maybe Int:s"
13:41:30 <RastaTonic> ok
13:41:32 <RastaTonic> that is working
13:41:50 <RastaTonic> i get why its giving me the error, but i just have no idea how to solve it
13:42:23 <sipa> there's still an error, or it's working now?
13:42:38 <RastaTonic> verwerk  ([Just 'a', Nothing, Nothing, Just 'a']:: [Maybe Char]) gives me "a  a"
13:42:41 <RastaTonic> as it should be
13:42:49 <RastaTonic> so thats working
13:43:32 <RastaTonic> do i need to make multiple instances of the show class? one for Maybe int and one for Maybe Char?
13:43:42 <ramses_> no
13:43:57 <ramses_> you have one for all puzzles which contain an instance of ToChar now
13:44:17 <ramses_> notice how all your functions are polymorphic in the type a
13:44:26 <ramses_> they only require a to be an instance of ToChar
13:44:39 <ramses_> does that make sense?
13:44:41 <FireFly|> You shouldn't need the type annotation in that case. The reason it was necessary with [Just 1, Nothing, Just 2] is that 1 might not necessarily be an integer (it could be anything that is in the Num typeclass)
13:44:55 <FireFly|> whereas 'a' is always of type Char
13:44:56 <RastaTonic> so lose the Maybe a?
13:45:36 <RastaTonic> yes i get that
13:45:43 <FireFly|> oh, okay
13:46:27 <RastaTonic> but so where do i make it chose what type it is? in my code, i guess somewhere in the process function
13:46:40 <ramses_> no, you don't
13:46:54 <ramses_> it is determined from the input
13:47:12 <RastaTonic> well i though i had it like that
13:47:13 <RastaTonic> :s
13:47:15 <ramses_> and it should be made unambiguous by the caller if necessary
13:47:36 <ramses_> that's why you have to add the annotation while testing
13:47:40 <RastaTonic> so my code is fine?
13:47:43 <ramses_> you give ambigous input
13:48:07 <FireFly|> Yeah, I think it's fine
13:48:23 <ramses_> yes, in the sense that it works and has correct types, but is doesn't meet all the assignment's requirements yet
13:48:43 <sipa> RastaTonic: whenever you give a literal number (such as '5', without the quotes) in Haskell, it can be of any numeric type
13:48:57 <monochrom> @type 5
13:48:58 <lambdabot> Num a => a
13:49:01 <sipa> RastaTonic: if the code that uses it does not force it to be a particular type, you can this error about ambiguity
13:49:24 <sipa> > [3,2,5 :: Int]
13:49:25 <lambdabot>   [3,2,5]
13:49:33 <sipa> > [3,2,5 :: Double]
13:49:35 <lambdabot>   [3.0,2.0,5.0]
13:50:02 <sipa> ^ because all members of a list have the same type, specifying the type on one was enough to know what the type of all them has to be
13:50:02 <zhulikas> I just kind of wondered... how to express asynchronous programming in Haskell?
13:50:08 <zhulikas> like-- sort of event based
13:50:14 <simpson> zhulikas: However you like.
13:50:19 <RastaTonic> well i get that
13:50:20 <zhulikas> what are the options?
13:50:31 <zhulikas> like
13:50:32 <clahey> zhulikas: If you want to interact with the outside world, it's going to have to involve IO somewhere.
13:50:33 <zhulikas> gimme a recipe
13:50:34 <simpson> zhulikas: Well, you can build it yourself, or you can use one of the FRP libraries.
13:50:43 <zhulikas> ah, FRP
13:50:45 * zhulikas looks up
13:50:51 <simpson> I personally am not satisfied with any of the options, but I'm weird.
13:51:05 <zhulikas> yeah, you must be homer
13:51:16 <simpson> Boy, I've *never* heard that one before. >:T
13:51:25 <zhulikas> no doubts
13:51:30 * zhulikas is damn hilarious
13:51:31 <RastaTonic> so the process function i wrote: process (Just x) = toChar x is correct?
13:51:51 <mikeplus64> zhulikas: i guess i'd use Control.Concurrent
13:51:58 <ramses_> RastaTonic: could be written more succinct, but yes
13:51:59 <monochrom> I use threads. that's async enough for me. some of my threads may simply read from a message queue and act.
13:52:18 <zhulikas> I remember creating some trivial stuff with Chan
13:52:22 <RastaTonic> then why am i still getting the ambigious error when i use the assignments example :s
13:52:28 <zhulikas> that kinda does look like event-based stuff
13:52:33 <RastaTonic> i know the \n arrent on their place  yet
13:52:40 <ramses_> because the assignment input has ambiguous types
13:52:47 <RastaTonic> ooooh
13:52:48 <ramses_> it was corrected
13:52:50 <RastaTonic> so lol
13:53:04 <RastaTonic> i thought i had the correct pdf
13:53:06 <RastaTonic> wauw
13:53:09 <RastaTonic> all this for nothing hahaha
13:53:12 <zhulikas> when I think of it, actually simpson's original answer was correct
13:53:18 <zhulikas> 'However you like'
13:53:24 * zhulikas just thought of some way
13:53:25 <RastaTonic> but thanks a bunch guys
13:54:11 <FireFly|> ramses_, RastaTonic: where's the problem description located?
13:54:28 <ramses_> RastaTonic: btw, [process x | x <- lijst] === map process lijst
13:54:44 <ramses_> FireFly|: it's a college assignment in dutch, we happen to be in the same class :)
13:54:54 <RastaTonic> yeah i know, i did that to practice my list comprehensions so i dont forget what the syntax is :p
13:55:03 <ramses_> oh ok
13:56:28 <RastaTonic> ok thanks guys, got it working correctly now
14:02:10 <ParahSail1n> im completely stuck-- Couldn't match expected type `SeqData' with actual type `BB.ByteString'
14:02:20 <saml> hey, wanna create a web scale database in haskell?
14:02:26 <saml> how can I implement B+ tree?
14:02:38 <ParahSail1n> SeqData is defined in Bio.Sequence.SeqData as = Data.ByteString.Lazy.ByteString
14:02:39 <saml> efficient B+ tree
14:03:21 <saml> data BPlusTree = BPlusTree    that's what i have so far
14:07:43 <xyz> hi?
14:07:55 <typoclass> xyz: hello
14:08:10 <adimit> boohoo. Y no Traversable.zipWith?
14:08:13 <xyz> I'd need some help with haskell functions..
14:08:47 <xyz> I have a pretty difficult one and I have to understand it ;D
14:09:40 <xyz> here is one of them:
14:09:49 <xyz> scramble :: [[Int] -> [Int]] -> [Int]nscramble = foldl (\s m -> m s) solved . reversen
14:10:09 <xyz> what does this (\s m -> m s) do?
14:10:20 <ramses_> xyz: it's a lambda
14:10:28 <ramses_> an anonymous function
14:10:32 <ParahSail1n> i have a feeling cabal messed something up
14:10:57 <neutrino_> hi
14:10:59 <glguy> :t (\s m -> m s)
14:11:00 <lambdabot> t1 -> (t1 -> t) -> t
14:11:19 <ramses_> > (\s m -> m s) (+1) 2
14:11:20 <lambdabot>   2
14:11:21 <xyz> soo.... what is it doing with my string?
14:11:30 <ramses_> > (\s m -> m s) 2 (+1)
14:11:32 <lambdabot>   3
14:11:44 <dcoutts> ParahSail1n: check if it's a lazy bytestring vs strict bytestring name confusion
14:11:50 <ramses_> :t 2
14:11:51 <lambdabot> Num a => a
14:11:52 <typoclass> xyz: it's an anonymous function. it takes two arguments (s and m), and it applies the function m to the argument s (similar to how you write "sqrt 4" and so on)
14:12:01 <dcoutts> ParahSail1n: ie what is BB.ByteString exactly
14:12:06 <ParahSail1n> dcoutts: i tried checking both ways whether SeqData counts as lazy vs strict
14:12:31 <ParahSail1n> it doesn't accept either way
14:12:44 <dcoutts> ParahSail1n: what is BB.ByteString exactly?
14:12:49 <ParahSail1n> BB is lazy
14:12:52 <xyz> aaaaaa
14:13:01 * hackagebot DSH 0.8.2.3 - Database Supported Haskell  http://hackage.haskell.org/package/DSH-0.8.2.3 (GeorgeGiorgidze)
14:13:15 <xyz> thx!
14:14:09 <dcoutts> ParahSail1n: if you want help, you need to be much more precise, and say what the error is, what the types really expand to etc
14:15:51 <adimit> @pl (a,b) c -> (a,c)
14:15:51 <lambdabot> (line 1, column 11):
14:15:51 <lambdabot> unexpected '>'
14:15:51 <lambdabot> expecting operator
14:16:06 <adimit> @djinn (a,b) c -> (a,c)
14:16:06 <lambdabot> Error: kind error: (KArrow (KVar 2) (KVar 3),KStar)
14:16:29 <clahey> adimit: What would (a,b) c mean?
14:16:37 <adimit> @djinn (a,b) -> c -> (a,c)
14:16:37 <lambdabot> f (a, _) b = (a, b)
14:16:42 <adimit> well, I knew that.
14:16:48 <adimit> clahey: that's me being *very* tired.
14:16:58 <adimit> I thought there'd be a prettier way to do it than a lambda.
14:17:14 <ParahSail1n> dcoutts: import qualified Data.ByteString.Lazy; Data.ByteString.Lazy.unpack . seqdata -- dies with Couldn't match expected type `Data.ByteString.Lazy.ByteString' with actual type `SeqData'
14:17:15 <neutrino_> adimit: in vim, i can type a command and it pastes djinn output under the type i just typed.
14:17:24 <clahey> > second (const c) (a,b)
14:17:25 <lambdabot>   (a,c)
14:17:32 <adimit> neutrino_: gimmie magicks. Where are they?
14:17:33 <clahey> adimit: How's that?
14:17:33 <neutrino_> makes it easy to work with stupid functions like that.
14:17:40 <neutrino_> adimit: 1 sec
14:17:43 <drchaos> I tried to write a function to reverse a list. A reversed list is just the tail of a list tacked onto the head. So: reverse' (x:xs) reverse xs : x
14:17:49 <neutrino_> adimit: let me msg you
14:17:55 <dcoutts> ParahSail1n: and what is the definition of SeqData?
14:17:55 <drchaos> but it doesn't compile
14:17:56 <adimit> neutrino_: I am grateful.
14:17:57 <Ralith> :t second
14:17:58 <clahey> drchaos: What is the type of (:)?
14:17:58 <lambdabot> Arrow a => a b c -> a (d, b) (d, c)
14:18:06 <adimit> clahey: as I feared. Not any more readable! :-D thanks.
14:18:16 <drchaos> :t :
14:18:17 <lambdabot> parse error on input `:'
14:18:24 <ParahSail1n> dcoutts: hehe ok i just did a ghc-pkg list on bytestring-- had an extra version in there
14:18:35 <drchaos> :t (:)
14:18:36 <lambdabot> a -> [a] -> [a]
14:18:37 <clahey> drchaos: You need () around a bare operator to ask questions.
14:18:46 <clahey> drchaos: What is the type of x?
14:18:52 <clahey> And the type of xs?
14:18:55 <ParahSail1n> it would certainly be nice if ghc could tell me im not being a moron, and that cabal fucked up
14:19:15 <clahey> > let constsecond = second . const in constsecond c (a,b)
14:19:17 <lambdabot>   (a,c)
14:19:23 <dcoutts> ParahSail1n: no, it's the other way around, cabal can help you to get a consistent environment with only a single version of each dep
14:19:29 <clahey> adimit: Is that any more helpful?
14:19:50 <adimit> clahey: very, thanks :-) Though I should just give up on finding the prettiest way to do stuff.
14:20:16 <drchaos> the type of xs is a list, the type of x is a list
14:20:17 * Ralith wonders at how nobody's told adimit about lenses yet
14:20:29 <clahey> drchaos: How is the type of x a list.
14:20:29 <drchaos> both lists having any type of element in them
14:20:31 <clahey> Ralith: I was about to.
14:20:46 <drchaos> clahey: oh, x is a single item of the list in that case
14:21:07 <Ralith> > set _2 c (a, b)
14:21:09 <lambdabot>   (a,c)
14:21:13 <Ralith> adimit: ^
14:21:20 <adimit> Ralith: every time I'm in #haskell, someone tells me to check out lenses.
14:21:33 <Ralith> welcome to #haskell
14:21:36 <Ralith> would you like a lens with that?
14:21:57 <clahey> > _2 .~ c (a,b)
14:21:58 <lambdabot>   The function `Debug.SimpleReflect.Vars.c'
14:21:58 <lambdabot>  is applied to one argument,
14:21:58 <lambdabot>  but...
14:21:59 <adimit> Ralith: and every time, I just don't have the time right now, and promise to look into it next weekend. And it's weekend now, and I know I won't have time again.
14:22:09 <ParahSail1n> dcoutts: the other day i had an annoying error that required me to unregister a package
14:22:56 <dcoutts> ParahSail1n: when you're working with lots of packages, and have multiple versions of things, it's often a good idea to make your projects into .cabal packages, even if you never intend to distribute them.
14:23:18 <ParahSail1n> dcoutts: i dont want multiple versions of things
14:23:19 <dcoutts> ParahSail1n: because cabal will ensure that it picks single versions of dependencies when it configures
14:23:51 <clahey> drchaos: Right, so you can't use (:) in that way.
14:24:01 <clahey> drchaos: You might be able to use (++) in some way.
14:24:03 <dcoutts> ParahSail1n: indeed, for any single build of anything you don't want to accidentally use multiple versions, since that's not likely to work, and that's exactly what cabal enforces.
14:24:23 <dcoutts> ParahSail1n: yes, you can also enforce it by never installing multiple versions of anything, but sometimes that's unavoidable.
14:24:43 <clahey> Why would set work and .~ not?
14:24:52 <clahey> I thought they were synonyms.
14:24:56 <clahey> > _2 `set` c (a,b)
14:24:58 <lambdabot>   The function `Debug.SimpleReflect.Vars.c'
14:24:58 <lambdabot>  is applied to one argument,
14:24:58 <lambdabot>  but...
14:25:02 <clahey> > _2 `set` c (a, b)
14:25:03 <lambdabot>   The function `Debug.SimpleReflect.Vars.c'
14:25:03 <lambdabot>  is applied to one argument,
14:25:03 <lambdabot>  but...
14:25:05 <ParahSail1n> so if i make things a cabal package it will do some magic that let's me specify which version of a package ghc will compile with?
14:25:05 <clahey> Oh, I see.
14:25:14 <clahey> > (_2 .~ c) (a,b)
14:25:16 <lambdabot>   (a,c)
14:25:21 <dcoutts> ParahSail1n: yes
14:25:24 <drchaos> clahey: I try reverse' (x:xs) = reverse' xs ++ x
14:25:35 <clahey> drchaos: What's the type of (++)?
14:25:37 <drchaos> and it says that it cannot construct the infinite type a0 = [a0]
14:25:42 <drchaos> :t (++)
14:25:43 <lambdabot> Monoid m => m -> m -> m
14:25:51 <hpaste> “Aaron Stacy (IRC: aaronj1335)” pasted “matching datatype constructurs” at http://hpaste.org/78571
14:26:05 <clahey> Okay, that's annoyingly generalized, isn't it?  :)
14:26:17 <clahey> The right answer is [a] -> [a] -> [a]
14:26:34 <drchaos> ok...
14:26:49 <clahey> drchaos: So in xs ++ x, what are the types of the two parameters to (++)?
14:27:14 <neutrino_> @hoogle Functor f, Monad m => (a -> m b) -> f a -> m f b
14:27:14 <lambdabot> Parse error:
14:27:14 <lambdabot>   Functor f, Monad m => (a -> m b) -> f a -> m f b
14:27:14 <lambdabot>            ^
14:27:22 <aaronj1335> is there a more succinct way to express this pattern matching? http://hpaste.org/78571 basically `f` can accept either of two constructors, but should return `Nothing` on anything else (apologies for bugs in the paste)
14:27:27 <drchaos> xs is a list, and x is a single element
14:27:30 <neutrino_> wait how do you write that
14:27:39 <neutrino_> @hoogle Functor f => Monad m => (a -> m b) -> f a -> m f b
14:27:39 <lambdabot> Parse error:
14:27:39 <lambdabot>   Functor f => Monad m => (a -> m b) -> f a -> m f b
14:27:39 <lambdabot>                        ^
14:27:43 <clahey> drchaos: And you've asked it to call a function that takes two of the same type.
14:27:43 <neutrino_> that's not it either
14:27:58 <clahey> drchaos: So it's looking for a type that has a = [a].
14:28:01 <ramses_> @hoogle (Functor f => Monad m) => (a -> m b) -> f a -> m f b
14:28:01 <lambdabot> Parse error:
14:28:01 <lambdabot>   (Functor f => Monad m) => (a -> m b) -> f a -> m f b
14:28:01 <lambdabot>              ^
14:28:03 <clahey> But that type doesn't exist.
14:28:07 <ramses_> @hoogle (Functor f, Monad m) => (a -> m b) -> f a -> m f b
14:28:07 <lambdabot> No results found
14:28:20 <clahey> drchaos: That sorta explains the error message, though it's not terribly useful.
14:28:24 <drchaos> clahey: ah, I see
14:28:32 <ramses_> neutrino_: parentheses around class constraints
14:28:33 <clahey> drchaos: You know how to turn an a into an [a]?
14:28:40 <drchaos> reverse' (x:xs) = reverse xs ++ [x]
14:28:40 <neutrino_> ramses_: right, thank you
14:28:47 <drchaos> clahey: that's how ^
14:28:59 <clahey> drchaos: That would work, but it's not recursive.  :)
14:28:59 <neutrino_> @hoogle Monad m => (a -> m b) -> [a] -> m [b]
14:28:59 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:28:59 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
14:28:59 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
14:29:14 <drchaos> clahey: not recursive?
14:29:27 <`^_^v> i have an infinite monotonically increasing list. how can i write a list comprehension to the effect of [x | x <- l, x < 100]
14:29:33 <ramses_> clahey: s/reverse/reverse' and it is
14:29:37 <clahey> drchaos: One of the problems with having ' as a valid identifier character.  :)
14:29:41 <clahey> ramses_: I know.
14:29:59 <drchaos> clahey: oh I see
14:30:24 <shachaf> `^_^v: takeWhile (<100) l
14:30:31 <mcstar> takeWhile (<100) infinitemonotonicallyincresinglist
14:30:31 <neutrino_> > let l = [1..100] in [ x | x <- l, x < 10]
14:30:33 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:30:34 <clahey> drchaos: But the smileys are all because yeah, you basically have it.
14:30:37 <martsen> hello. can somebody help me in some haskell funtion?
14:30:38 <neutrino_> seems to work `^_^v
14:30:41 <shachaf> `^_^v: Not everything needs to be a list comprehensions (in fact, most things don't).
14:31:09 <clahey> shachaf: I'm amused though that the answer was the question.
14:31:16 <neutrino_> oh, duh, infinite
14:31:32 <shachaf> clahey: ?
14:31:32 <drchaos> clahey: yep, I just make the reverse' function call itself recursively instead and it all works out
14:31:38 <clahey> shachaf: Nothing, I was wrong.
14:31:46 <neutrino_> yeah, use takewhile
14:31:51 <clahey> But yeah, takeWhile.
14:32:18 <clahey> I really like how you usually don't actually need to write lots of recursive functions in haskell.
14:32:23 <clahey> It's already written.
14:33:08 <zhulikas> there is nothing left to write :(
14:33:09 <adimit> combinators are the single greatest thing since sliced bread :-D
14:34:43 <ciaranm> slicing bread is a zipper
14:39:36 <neutrino_> [] is a Functor, right?
14:39:53 <adimit> yup.
14:40:03 <adimit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Functor
14:41:54 <ramses_> @hoogle (Applicative f, Monad m) => m f a -> f m a
14:41:54 <lambdabot> Data.Map mapKeysMonotonic :: (k1 -> k2) -> Map k1 a -> Map k2 a
14:41:54 <lambdabot> Control.Monad.Trans.Reader withReader :: (r' -> r) -> Reader r a -> Reader r' a
14:41:54 <lambdabot> Control.Monad.Reader withReader :: (r' -> r) -> Reader r a -> Reader r' a
14:49:42 <Ferdirand> so, did many people come tonight asking about a rubik's cube solver ?
14:50:25 <ramses_> Ferdirand: haven't seen any
14:53:01 * hackagebot hermit 0.1.4.0 - Haskell Equational Reasoning Model-to-Implementation Tunnel  http://hackage.haskell.org/package/hermit-0.1.4.0 (AndrewFarmer)
14:56:14 <ciaranm> i want a way of integrating typeclasses and lenses so i don't have to prefix all my lens names
14:57:30 <shachaf> ciaranm: What lens names?
14:58:29 <ciaranm> i have lots of records that should have something named varID in them, but instead have to have exprVarID, varVarID etc
15:07:24 <xunatai> how do i get a blocking read from this? http://hackage.haskell.org/packages/archive/serialport/0.4.5/doc/html/System-Hardware-Serialport.html
15:08:13 <edwardk> ciaranm: you know you can use makeClassy for that
15:08:42 <ciaranm> edwardk: ooh, i did not.
15:09:01 <edwardk> ciaranm: see https://github.com/ekmett/lens/blob/master/examples/Turtle.hs for a short makeClassy example
15:09:10 <ciaranm> thanks
15:09:33 <edwardk> but if nothing else you can always make
15:09:42 <ciaranm> there are too many lens packages! i think i'll write a single grand unified lens package! that will fix it.
15:09:44 <edwardk> class HasVarId t where varId :: Simple Lens t Int
15:10:07 * ciaranm nods
15:10:15 <edwardk> and then just instantiate that for each of your varID containing classes
15:10:23 <edwardk> instance HasVarId Expr where varId = exprVarId
15:11:29 <shachaf> I,I class HasFoos t where foos :: Simple Traversal t Foo
15:11:33 <ciaranm> should i be using lens or data-lens?
15:11:50 <edwardk> lens
15:12:27 <edwardk> data-lens was what i used to recommend, but lens is rather ridiculously more powerful than all the other lens libraries ;)
15:12:59 <edwardk> and is currently experiencing something like 100x the amount of development effort as all the others combined =P
15:13:01 <shachaf> Which editor should I be using, Sam or Acme?
15:13:26 <shachaf> edwardk: It also has ~100× as many unsafeCoerces as all the others combined.
15:13:51 <typoclass> shachaf: which part of 'development effort' was confusing you
15:13:59 <edwardk> shachaf: it may be infinitely x as many since i think the total elsewhere is 0
15:14:19 <shachaf> I generously allowed 1 unsafeCoerce for all the others.
15:14:31 <ciaranm> wow. also, lens has documentation. what a novel concept.
15:14:38 <Cale> Why are there unsafeCoerces in lens?
15:14:40 <edwardk> then its only 87x as many ;)
15:14:59 <edwardk> Cale: because we generate really crappy core for (a -> b) -> (a -> Identity b)  otherwise for instance
15:15:21 <Cale> Oh, are you at least introducing the unsafeCoerces via rewrite rules then?
15:15:23 <edwardk> it makes a rather disappointing 50% performance difference there =(
15:15:36 <edwardk> those ones are hidden behind combinators
15:15:38 <shachaf> Cale: No, because GHC is bad at rewrite rules involving newtype constructors.
15:15:47 <Cale> hmm
15:16:05 <latro`a> 50%
15:16:05 <shachaf> Anyway, those are the more legitimate unsafeCoerces.
15:16:06 <latro`a> wow
15:16:13 <edwardk> there are about 30 others that are forced on us by the fact hat GHC isn't willing to spot a couple of equalities   given a -> f b  ~  s -> f t  it isn't willing to prove b ~ t even when f is bound by a data type definition
15:16:20 <shachaf> 50%? Did you measure that?
15:16:45 <Cale> edwardk: lol
15:16:55 <Cale> That's pretty weird
15:16:58 <edwardk> shachaf: i was basing that statement on my rough recollection from the last time we ran the unsafe benchmark but i could be off quite a bit
15:17:12 <latro`a> is the unsafe one actually provably safe?
15:17:21 <latro`a> *"unsafe"
15:17:33 <latro`a> I guess probably not
15:17:45 <edwardk> latro`a: yes. those ones are just doing what strict . would do
15:17:49 <latro`a> oh
15:17:53 <latro`a> cool then
15:18:11 <edwardk> latro`a: the a -> f b ~ s -> f t  ones should be able to be fixed if we could provide a sufficiently well motivated example to simon
15:18:24 <shachaf> edwardk: Aha!
15:18:29 <shachaf> edit-lenses-0.2/Data/Lens/Edit/List.hs:44:	_ -> unsafeCoerce e
15:18:38 <edwardk> shachaf++
15:18:48 <shachaf> That's the only one I can find.
15:18:50 <edwardk> ok, so we have 87x as many unsafeCoerces as our peers ;)
15:18:54 <neutrino_> --
15:19:05 <Saizan> edwardk: i thought they already reversed the design decision?
15:19:22 <edwardk> Saizan; they who? which decision?
15:19:29 <shachaf> Other unsafeCoerces are just because edwardk feels like sticking them there.
15:19:46 <Saizan> edwardk: the one about not decomposing equalities
15:20:01 <shachaf> edwardk: Whoops, that unsafeCoerce is commented out.
15:20:14 <shachaf> So I guess we're back at infinity.
15:20:28 <Cale> I could be happy, I think, if GHC 7.8 had no new features whatsoever, and just solidified what was already there.
15:20:30 <beer_lover> two cans of beer and I still can't program shi*
15:20:32 <edwardk> oh that was the one caused by the kind refinement stuff. different issue i think
15:20:43 <edwardk> well, probably somewhat related
15:20:47 <Cale> The typechecker has seemed really flaky lately.
15:21:13 <Saizan> edwardk: http://hackage.haskell.org/trac/ghc/ticket/7377
15:21:13 <Cale> Even if you don't count this nonsense with pattern bindings and the ability to write unsafeCoerce by hand.
15:21:27 <edwardk> here its just not able to simplify inside a -> f b ~ s -> f t  to get b ~ t, even though its willing to take f b ~ f t   to b ~ t    and a -> x ~ a -> y    to x ~ y individually
15:21:45 <pqmodn> i'm probably misunderstanding how it should work, but why does unsafeCoerce's type a -> b unify with Show b => a -> b? or (forall a. a -> a) -> b?
15:22:01 <edwardk> Saizan: good then we'll be able to get rid of 30 unsafeCoerce's in about a year and a half
15:22:28 <shachaf> pqmodn: b = forall c. Show c => c; unsafeCoerce :: a -> b
15:22:46 <shachaf> let d = forall e. e -> e; unsafeCoerce :: d -> b
15:22:47 <beer_lover> ] 2 + 2
15:22:51 <edwardk> the remaining 50 or so are just the performance hack for fast casting of functions taking/returning newtypes
15:23:06 <pqmodn> shachaf: but i haven't enabled ImpredicativePolymorphism or whatever it is. how does the second one work?
15:23:09 <beer_lover> please whats that haskell bot inline interpreter symbol again?
15:23:14 <saml> is there database written in haskell?
15:23:24 <saml> or full text search index
15:23:42 <shachaf> pqmodn: I wouldn't be surprised if it doesn't always quite work.
15:24:00 <shachaf> pqmodn: But that's not really impredicative, just rank-2
15:24:12 <beer_lover> i need to desperately find the sum of 2 and 2. sore mood and want to try it with the bot . anyone?
15:24:15 <beer_lover> please?
15:24:20 <snowylike> edwardk: i'm sorry if i'm misunderstanding fundamental things here, but is it correct that "~" means equal to?
15:24:26 <edwardk> snowylike: yes
15:24:48 <beer_lover> > 2 + 2
15:24:49 <lambdabot>   4
15:24:50 <edwardk> :t id :: (a ~ b) => a -> b
15:24:52 <lambdabot>     Illegal equational constraint a ~ b
15:24:52 <lambdabot>     (Use -XGADTs or -XTypeFamilies to permit this)
15:24:52 <lambdabot>     In an expression type signature: a ~ b => a -> b
15:24:53 <beer_lover> :D
15:24:53 <adimit> saml: in haskell, not that I can think of. But there's plenty of bindings into other stuff. if you want full-text search, look at haskell-sphinx-client.
15:25:05 <edwardk> > let id :: (a ~ b) => a -> b; id x = x in id 12
15:25:07 <lambdabot>   12
15:25:07 * beer_lover now i can sleep in peace
15:25:17 <tomeo> Im trying to rid the () from score + (fst alignments), I tried score + $ fst alignments, but it didn't work. Could someone plese give me a suggestion?
15:25:29 <beer_lover> lambdabot: thank you hun
15:25:36 <shachaf> tomeo: score + fst alignments
15:25:55 <snowylike> then it isn't simply reducable to b~t
15:26:13 <tomeo> haha tanks shachaf
15:26:42 <edwardk> snowylike: (a -> f b) ~ (s -> g t)    should derive the supplementary equalities a ~ s, f ~ g, b ~ t
15:26:58 <pqmodn> shachaf: i thought impredicativity was when you instantiate a type variable with a polytype. eg, d = forall ..., but maybe +Rank2Types enables some form of limited impredicativity
15:26:58 <snowylike> yes, that's what i meant
15:27:20 <snowylike> was confused because you only pointed out the last one
15:27:44 <edwardk> snowylike: i was merely talking about the fact that the last equality is the only one i need out of that that isn't being derived ;)
15:27:54 <edwardk> not that the two were equivalent
15:27:59 <snowylike> okay
15:29:39 <edwardk> in theory we could probably write our own hack for  (a -> f b) := (s -> g t) -> b := t   and open the refl back up and get it everywhere we use it
15:29:52 <edwardk> then ~30 unsafeCoerces would become 1
15:30:25 <edwardk> but then shachaf would be able to sleep at night.. and i wouldn't have any company
15:30:54 <glguy> How do you enforce that f or g aren’t type families?
15:31:03 <Saizan> the type system does
15:31:17 <edwardk> glguy: because if you write that as a function, those can't be.
15:31:18 <Saizan> well, the fact you can't pass them around unsaturated
15:31:29 <edwardk> you can't pass around type families polymorphically
15:32:36 <edwardk> twanvl_: simple-reflect makes very nice doctests!
15:32:41 <cmccann> you also can't pattern match on arbitrary function applications! crazy.
15:32:53 <cmccann> though being able to "pattern match" with injective functions would be kinda cool.
15:33:57 <adimit> would 'liftM (listToMaybe . dropWhile p) . mapM f' execute action f only until it emits an output k for which p k == True? In other words, is mapM lazy, and can I just lift a pure function into it whitout destroying that? Also, how would I generally find out whether something like that holds of a function without trying it out?
15:34:01 <adimit> … so many questions.
15:34:38 <adimit> (i think mapM is lazy. I'm not sure about liftM g . mapM f.
15:34:46 <cmccann> adimit, anything like mapM is going to sequence the whole list
15:34:47 <shachaf> adimit: Nope.
15:34:55 <hpaste> ciaranm pasted “how do I remove the need for the 'literal'?” at http://hpaste.org/78573
15:35:24 <shachaf> adimit: Trying things out is a great way to learn about how they work, by the way. :-)
15:35:35 <glguy> > takeWhile (<3) $ concat $ mapM (\x -> return x) [1,2,3,undefined]
15:35:37 <lambdabot>   [1,2]
15:35:44 <adimit> shachaf, cmccann, so no dice. I'll have to use some sort of different way of going through the list until p is satisfied without being eager.
15:35:45 <ciaranm> ^^ in the above, what voodoo do i need to convince ghc that a bare '123' is an Int, and thus a member of the Expr class?
15:36:01 <cmccann> "executing" the entire list can be lazy enough in some monads in some cases
15:36:03 <cmccann> but in general no
15:36:09 <glguy> oh, what I wrote doesn’t help :)
15:36:15 <glguy> > takeWhile (<3) $ concat $ mapM (\x -> x `seq` return x) [1,2,3,undefined]
15:36:16 <lambdabot>   *Exception: Prelude.undefined
15:37:01 <adimit> cmccann: my monad is just an unholy stack of writer, reader, state, and IO.
15:37:25 <cmccann> yeah, obviously with IO it's not gonna work
15:37:47 <cmccann> adimit, you could use something like the stuff in http://hackage.haskell.org/package/monad-loops
15:38:00 <adimit> cmccann: thanks, I'll have a look.
15:38:21 <glguy> adimit: in this case the ‘f’ function could have returned [] which would mean that the whole thing would collapse to no results
15:38:21 <glguy> takeWhile (<3) $ concat $ mapM (\x -> if x >= 3 then [] else return x) [1,2,3,4,undefined]
15:38:34 <glguy> so it has to keep checking
15:38:58 <deus_rex> > takeWhile (<3) $ concat $ mapM (\x -> if x >= 3 then [] else return x) [1,2,3,4,undefined]
15:39:00 <lambdabot>   []
15:39:44 <benmachine> hmm
15:40:07 <adimit> cmccann: you say 'obviously' it won't work in the IO monad, but I'm not sure why. Do you mean that sequence in the IO monad would have to be eager?
15:40:25 <benmachine> I have a package that imports Control.Monad,Error, taking the instance Monad (Either e) from it via Control.Monad.Trans.Error
15:40:31 <benmachine> which comes from transformers
15:40:42 <glguy> adimit: whether or not you use the results, mapM is going to perform all the side-effects of running f a bunch of times
15:40:54 <glguy> in the IO case
15:41:07 <benmachine> therefore I depend not only on mtl >= 2, but mtl must also be built against transformers >= 0.2.2
15:41:08 <adimit> that's due to the implementation specifics of the IO monad?
15:41:08 <cmccann> adimit, yes, it has to "execute" everything in the list, whatever that means
15:41:11 <glguy> unless something threw an exception
15:41:17 <cmccann> in some monads that can be lazy
15:41:20 <benmachine> even though transformers is nominally not a dependency of my package!
15:41:24 <cmccann> but in IO it'll run everything
15:41:39 <benmachine> this is the plague that attends those who re-export imports from their dependencies
15:41:46 <benmachine> which, because of class instances, is everyone
15:41:50 <adimit> ok, I understand (a bit.) Thanks for the help!
15:42:18 <cmccann> on the other hand in State you can actually get away with an infinite mapM as long as you don't inspect the state value afterwards, I think
15:42:50 <c_wraith> *lazy* state, anyway
15:42:56 <cmccann> well yes
15:42:57 <benmachine> I guess I just have to add a dependency on transformers if this is really an issue
15:43:04 <adimit> that sounds like it would make sense in lazy state. Now I can see why it wouldn't work in IO, thanks!
15:43:16 <benmachine> it frightens me though, builds can be broken by /transitive/ dependencies updating, not immediate dependencies
15:43:41 <benmachine> I'm surely not the only one who has noticed this? :P
15:43:49 <adimit> I think I found my saviour in Control.Monad.Loops.iterateWhile
15:43:55 <cmccann> benmachine, package dependencies are a laugh a minute
15:44:02 <benmachine> cmccann: aren't they just?
15:44:21 <cmccann> adimit, there's a nice selection in there to choose from
15:44:23 <benmachine> "here, I wrote some code. it uses twelve other people's code, none of them know about mine or each others'"
15:44:31 <adimit> cmccann: indeed, very useful.
15:45:02 <benmachine> I think I might just submit this patch and let the maintainer worry about it
15:45:11 <cmccann> adimit, the dropWhile is your problem, so you need a loop combinator that lets you combine the mapM with a monad-enabled dropWhile (i.e., with a stopping condition built in)
15:45:13 <benmachine> he doesn't put version bounds on his deps anyway, so whatever
15:45:25 <ciaranm> obviously the fix is to replace imports with typeclasses, and then make the user specify how to glue together all the modules
15:45:55 <rwbarton> class Lens where {- 1000 lines -}
15:46:22 <edwardk> rwbarton: also the need for higher rank instances would be … interesting ;)
15:46:24 <adimit> cmccann: yes! that's why I wasn't sure whether lifting dropWhile into mapM would give me the desired effect (of stopping f, which in my case is a bloody expensive request to a server.)
15:46:41 <cmccann> ciaranm, good idea, maybe dependencies could be converted to Constraints then!
15:47:39 <rwbarton> oh right, I have to list all the dependencies as class arguments or something
15:48:25 <cmccann> adimit, right, and that's what these monad looping combinators are for. I've never understood why something along those lines isn't in Control.Monad, but eh.
15:50:49 <adimit> cmccann: they are useful. Though the *exact* one isn't there, but I can puzzle it together, methinks. I'd need something like mapMUntil :: Monad m => (a -> m b) -> [a] -> Maybe b
15:51:00 <adimit> m (Maybe b), of course.
15:51:37 <edwardk> adimit: can't you just use MaybeT
15:51:42 <adimit> and add a predicate (b -> Bool) in there. Dear god I'm tired.
15:52:01 <edwardk> Data.Traversable.mapM :: (a -> MaybeT m b) -> [a] -> MaybeT m b
15:52:51 <edwardk> or did i misparse your needs?
15:54:04 <adimit> edwardk: interesting… my needs are just this: only execute the monadic action for as many list elements as you need to receive a positive result from a predicate, in which case return Just that result, or Nothing if none of the list elements fulfil that predicate after the monadic action.
15:54:54 * cmccann prefers loop combinators anyway, but that's a matter of taste
15:55:17 <Peaker> I have a     data MyType k = MyType (Map k Foo) ; derive makeBinary ''MyType     which then complains that the Binary instance depends on (Ord k) which is entirely true. Any way to get "derive" to add these constraints?
15:55:36 <adimit> I mean, in imperative terms, that is easy: foreach a in A { if p a then return (Just a); }; return Nothing;
15:56:16 <Peaker> adimit, you could use EitherT
15:56:36 <Peaker> adimit, "Left" to signify "done with result", and "Right ()" to mean ignore, carry on
15:56:42 <cmccann> obviously the real solution is to use ContT and escape via callCC!
15:56:50 <shachaf> @slap cmccann
15:56:50 * lambdabot submits cmccann's email address to a dozen spam lists
15:56:54 <cmccann> hahaha
15:57:00 <edwardk> peaker++ # that was going to be my next suggestion.
15:57:03 <shachaf> EitherT is just as good for escaping as ContT
15:57:10 <shachaf> It's not in mtl, though, is it?
15:57:18 <Peaker> edwardk, I got my "EitherT" package deprecated, btw
15:57:20 <edwardk> no, you need to install 'either' for it
15:57:24 <edwardk> Peaker: thanks =)
15:57:29 <cmccann> shachaf, yes, but the difference is that using EitherT might be sensible, which was not my point
15:57:41 <edwardk> Peaker: it was always a pain explaining that someone shouldn't use EitherT for EitherT ;)
15:57:56 * benmachine <3 ContT
15:58:04 <benmachine> in a kind of lovable-rogue way
15:58:11 <shachaf> So "either" is the package for EitherT?
15:58:13 <Peaker> edwardk, Maybe you could have taken over my package/name, though I understand the overhead of communicating with another author trumps the "writing the code" part
15:58:20 <edwardk> yes
15:58:20 <Peaker> shachaf, yeah
15:58:41 <adimit> … wait, what are the benefits of using EitherT over MaybeT here?
15:58:43 <Peaker> shachaf, "EitherT" was too, and written first, but I didn't maintain it/add features and edwardk made "either" and added more stuff/docs
15:58:56 <shachaf> If only monad transformers weren't the devil, EitherT could be so convenient.
15:58:57 <edwardk> Peaker: at the time i don't think i'd connected your nick with your name, and also i hadn't noticed the other package when i published
15:58:58 <Peaker> adimit, "MaybeT" has the semantics of "carry-on-with-result", or "leave-without-result"
15:59:16 <shachaf> adimit: EitherT gives you early-return-with-a-value or normal-return-with-a-value
15:59:18 <Peaker> adimit, but you need the opposite semantics
15:59:29 <startling> shachaf: can we have a list of things that aren't the devil?
15:59:30 <shachaf> MaybeT gives you early-return-with-no-value or normal-return-with-a-value
15:59:33 <adimit> Peaker, shachaf: understood! Thank you!
15:59:43 <shachaf> startling: Ask typoclass.
16:00:00 <startling> shachaf, maybe there could be a ghc pragma?
16:00:11 <startling> {-# Use Strictchaf -#}
16:00:12 <edwardk> shachaf secretly thinks everything is the devil, except possibly lens, but then unsafeCoerce is in lens, ergo unsafeCoerce is not the devil.
16:00:25 <Peaker> edwardk, yeah, and also what I said.. if it takes 30 minutes to whip up a nice package that you need and upload it to hackage, or 2-days email roundtrip to another author, the former is often appealing :)
16:00:27 <adimit> so, I use package either for that, is what I take from the discussion…
16:00:38 <gwern> edwardk: but can't anything become unsafeCoerce with proper application of unsafeCoerce?
16:00:39 <Peaker> (and that's if the other author replies)
16:00:39 <shachaf> edwardk: Who said lens wasn't the devil?
16:00:49 <edwardk> shachaf: i stand corrected.
16:00:56 <edwardk> ok, shachaf thinks everything is the devil
16:01:16 <shachaf> The devil might not be the devil.
16:01:26 <cmccann> lens is clearly a package of wealth and taste
16:01:41 <Peaker> Generalizing Haskell code after-the-fact is a bit of a PITA (propagating an extra type variable everywhere.. getting broken derived instances...)
16:01:53 <edwardk> cmccann: ಠ_ರೃ quite
16:02:07 <Peaker> Premature generalization to the rescue
16:04:24 <Peaker> I can't wait to have an IDE that does all the type-var propagation for me
16:06:45 <typoclass> startling: so far, kitties and the space station are not the devil. as for anything else, it doesn't look good
16:07:48 <Peaker> Also propagating up new type-class constraint as a result of generalization :(
16:07:52 <startling> typoclass: is the verdict still out for space stations in general?
16:08:35 <typoclass> startling: so-so. not a fan.
16:08:43 <cmccann> I hear the devil has decided to build his own space station, populated entirely by kittens.
16:09:32 <startling> cmccann: uh-oh
16:13:03 <Squarism> a builder pattern doesnt really play well with immutability does it?
16:14:02 <glguy> Squarism: runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
16:14:12 <glguy> This is similar to a builder pattern
16:14:33 <glguy> (or could be used in one)
16:15:46 <Squarism> Actually, i dont know much haskell at all... i couldnt really get that.. dont know why im asking here =D
16:16:09 <deus_rex> glguy: damn
16:16:18 <Squarism> i really wanna learn haskell but i havent found a good way
16:16:24 <deus_rex> Squarism: have you tried learn you a haskell?
16:16:29 * cmccann notes that with shared sub-structures and laziness a builder pattern-ish approach might work fine anyway
16:16:36 <deus_rex> "learn you a haskell", the book
16:16:41 <typoclass> Squarism: good to hear :-) are you aware of lyah?
16:16:44 <typoclass> @where lyah
16:16:44 <lambdabot> http://www.learnyouahaskell.com/
16:16:48 <typoclass> it's free of charge
16:16:57 <glguy> deus_rex: I don’t understand what you mean
16:17:00 <Fuuzetsu> it has pictures!
16:17:15 <Squarism> deus_rex, ive read some tutorials, but ill check out the book
16:17:18 <Fuuzetsu> (I think he meant `I can't think of a project to do in Haskell)
16:17:27 <Fuuzetsu> oh, so he didn't
16:20:06 <lispy> Who was it that liked Shelly?
16:20:16 <lispy> I found what I think to be a pretty serious Shelly bug...
16:20:28 <lispy> the (-|-) operator seems to be unusabel
16:20:44 <clahey> :t (-|-)
16:20:45 <lambdabot>     Not in scope: `-|-'
16:20:45 <lambdabot>     Perhaps you meant one of these:
16:20:45 <lambdabot>       `-\-' (line 100), `-*-' (line 102), `-&-' (line 103)
16:20:57 <lispy> ?hoogle (-|-)
16:20:57 <lambdabot> No results found
16:21:01 <merijn> wut
16:21:06 <merijn> :t (-\-)
16:21:07 <lambdabot> (a) => ((b) => r) -> (a :- b) -> r
16:21:17 * merijn gives up
16:21:21 <lispy> http://hackage.haskell.org/packages/archive/shelly/0.14.3/doc/html/Shelly.html
16:21:25 <lispy> It's on that page
16:21:51 <typoclass> lispy: hm, interesting
16:22:27 <lispy> Everything I've tried gets error messages about resources vanishing in commitAndReleaseBuffer
16:23:07 <Squarism> typoclass, (got sucked up in learnyouahaskell.com here)... lyah? No?
16:23:09 <typoclass> lispy: something like "the program exited, the pipe is closed, nothing can be read from it"? i have no clue
16:23:20 <lispy> shells have to keep the LHS around until the RHS is done. I suspect due to Lazy Text that something like that may need to be done here
16:23:26 <typoclass> Squarism: er yeah, lyah = learn you a haskell :-)
16:23:26 <clahey> Squarism: Learn You A Haskell = lyah
16:23:36 <Squarism> ah
16:23:55 <lispy> There is a workaround mentioned in the docs
16:23:59 <sclv> lispy: yeah makes sense
16:24:07 <lispy> I'm using it, but it's still annoying that (-|-) is so broken
16:24:23 <sclv> shell stuff is hard to wrap right
16:24:32 <sclv> i'm alway suspicious of any library claiming to do it
16:24:42 <sclv> never seen one i've fully trusted, actually...
16:24:46 <sclv> esp. cross platform
16:24:49 <lispy> sclv: right. I took a chance on shelly because others recommended it
16:25:45 <shachaf> lispy: -|- seems to workf or me
16:25:57 <shachaf> Maybe I'm misunderstanding.
16:26:18 <lispy> shachaf: what is your example?
16:26:42 * lispy will try to turn his fail case into an example he can share
16:26:59 <shachaf> lispy: Oh, maybe I'm not doing it properly.
16:27:30 <lispy> I can tell you the essence of what I'm doing
16:28:16 <lispy> silently (exitErr False (run "grep" ["-E", "somepattern"] -|- run "sed" ["s/blah//g"]))
16:28:34 <lispy> You know, piping from grep to sed
16:28:49 <lispy> Oh, and I pass a file name to grep
16:29:05 <sclv> so the issue is prob that grep runs too fast
16:29:06 <sclv> ?
16:29:41 <shachaf> λ> shelly $ silently (run "grep" ["", "file1"] -|- run "sed" ["s/h/Q/g"])
16:29:41 <shachaf> "Qello\nQmm\n"
16:30:11 <sclv> difft OSes?
16:30:28 <lispy> I'm on linux
16:30:42 <shachaf> Is "grep runs too fast" stops it from working, that's a pretty serious bug. But I doubt it's that.
16:31:11 <typoclass> lispy: i'm not familiar with shelly, how will it react if grep or sed exit with an error? does it print their stderr then ...?
16:31:52 <lispy> typoclass: I'm not sure. It has some builtin logging (but I've mostly disabled it)
16:32:14 <lispy> typoclass: grep shouldn't be erroring in this case (it doesn't when I use zsh)
16:32:39 <typoclass> lispy: yeah ... well ... "shouldn't" ...
16:32:40 <typoclass> :-)
16:33:32 <shachaf> I recommend: Apply the usual debugging procedure. Repeat until problem is solved.
16:33:35 <typoclass> lispy: try turning on that logging and error reporting your mentioned
16:33:46 * hackagebot hspec 1.4.2.1 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.2.1 (SimonHengel)
16:34:11 <lispy> typoclass: I can also tell you that when I run _just_ grep from shelly I get the lines
16:34:56 <lispy> shachaf: I don't have the time to fix shelly right now. I've debugged it enough to know that it doesn't work on my machine for the grep/sed combo that I need. Now I have to use the workaround.
16:35:16 <typoclass> lispy: can your sed be invoked with "sed somepattern"? i've always invoked it with "sed -e somepattern", but i'm in no way a sed expert
16:35:32 <shachaf> I have no idea whether shelly is broken or not.
16:37:00 <lispy> typoclass: yes, for my sed, sed s/..../ is the same as sed -e s/.../
16:39:29 <gwern> > 20 * 5 * 4
16:39:30 <lambdabot>   can't find file: L.hs
16:40:15 <rwbarton> 400
16:40:17 <shachaf> gwern: 399.9999995329384723839447
16:40:27 <shachaf> Hmm, I think rwbarton is closer.
16:40:31 <gwern> shachaf: close enough for gwernment
16:40:40 <typoclass> gwern: it depends on what you mean by "*"
16:41:00 <typoclass> (here's a real #haskell kind of answer ...)
16:41:01 <gwern> typoclass: I'm not going to take offense at your insinuations, but I could.
16:41:15 <shachaf> When I use an operator, it means just what I choose it to mean -- no more and no less.
16:41:41 <cmccann> shachaf, well there's glory for you!
16:42:17 * shachaf isn't sure what cmccann means by "glory"
16:42:42 <cmccann> shachaf, well of course you don't.
16:43:14 * cmccann drops the routine before it loops back around to the quote that started it.
16:44:22 <adimit> so, I ended up doing 'liftM (fmap (const())) . runEitherT . mapM (\c -> lift (k c)
16:44:32 <adimit> damn, backspace, why are you next to enter...
16:44:46 <acowley> Tonight's refactoring included choosing a better name for a function I'd previously called "trustMe"
16:45:06 <adimit> so, I ended up doing 'liftM (fmap (const())) . runEitherT . mapM (\c -> lift (f c) >>= \r -> if p r then right () else left r) — it seems that should do the trick…
16:45:48 <adimit> (i'm fmapping the const () because I can't stand the look of [()] in the type signature. It looks like a quadratic vagina.)
16:53:43 <lispy> ah, the problem is the way shelly applies quoting
17:01:12 <johnw> you can disable shelly's quoting for a specific range
17:01:40 <johnw> see "escaping False"
17:11:04 <lispy> johnw: right. I was using that, but now that I see how it 'escapes' things I can work with the escaping.
17:11:16 <lispy> (it doesn't escape things in the way I would have guessed, for certain)
17:12:40 <Sintendo> is there an easy way to turn an infinite list into an infinite list of tuples, like [1,2,3,4,...] -> [(1,2),(3,4),...] ?
17:13:20 <edwardk> > let sintendo (a:b:as) = (a,b):sintendo as; sintendo _ = [] in sintendo [1..]
17:13:22 <lambdabot>   [(1,2),(3,4),(5,6),(7,8),(9,10),(11,12),(13,14),(15,16),(17,18),(19,20),(21...
17:13:37 <lispy> johnw, shachaf: I still think the way shelly reports the error is busted.
17:13:38 <Saizan> > zip`ap`tail $ [1..]
17:13:39 <lambdabot>   [(1,2),(2,3),(3,4),(4,5),(5,6),(6,7),(7,8),(8,9),(9,10),(10,11),(11,12),(12...
17:13:47 <acowley> I bet the function named after me will be a composition of unsafe functions.
17:13:48 <shachaf> lispy: I've never used shelly before.
17:13:53 <shachaf> I don't know nothin' about it.
17:13:59 <Saizan> wrong answer but cute
17:14:02 <lispy> shachaf: You do now :)
17:14:08 <rwbarton> shelly is the devil by default
17:14:10 <lispy> shachaf: you know my opinion of it
17:14:14 <shachaf> acowley: Don't worry, edwardk just composes unsafe functions to show off.
17:14:37 <shachaf> lispy: On the other hand I also know Greg Weber's general opinion of it.
17:14:41 <shachaf> So it balances out, right?
17:14:42 <acowley> I was unsafe before it was cool.
17:15:41 <lispy> shachaf: what does Greg think of Shelly?
17:15:50 <shachaf> I think he has a positive opinion of it.
17:16:22 <acowley> Who is Shelly?
17:16:27 <Sintendo> what's the ap in zip`ap`tail?
17:16:35 <centrinia> :t ap
17:16:36 <lambdabot> Monad m => m (a -> b) -> m a -> m b
17:16:36 <acowley> <*>
17:20:06 <lispy> ?hackage shelly
17:20:06 <lambdabot> http://hackage.haskell.org/package/shelly
17:20:22 <shachaf> Sintendo: ap x y z = x z (y z)
17:20:24 <rwbarton> specifically (r -> a -> b) -> (r -> a) -> (r -> b)
17:21:40 <latermuse> is there a way to write this code to be more compact?
17:21:40 <latermuse> let fiveNotePhrase = [(a,b,c,d,e) | a <- notes, b <- notes, c <- notes, d <- notes, e <- notes] where notes = ['a'..'g']
17:23:41 <lazard> > replicateM 5 ['a'..'g']
17:23:42 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaad","aaaae","aaaaf","aaaag","aaaba","aaabb","a...
17:24:12 <shachaf> > replicateM 5 "abcdefg" -- one character shorter!
17:24:13 <lambdabot>   ["aaaaa","aaaab","aaaac","aaaad","aaaae","aaaaf","aaaag","aaaba","aaabb","a...
17:25:01 <rwbarton> :t join . join
17:25:03 <lambdabot> Monad m => m (m (m a)) -> m a
17:25:16 <Sintendo> why won't this work? [Vect2D x y | (x, y) <- zip `ap` tail $ (randomRs (1,10) seed)]
17:25:18 <FireFly> shachaf: the S combinator?
17:25:23 <shachaf> FireFly: Yep.
17:25:49 <shachaf> Sintendo: Why don't you tell us?
17:26:07 <sipa> :t randomRs
17:26:08 <shachaf> (Also: Are you quite sure zip `ap` tail is what you want there? zip `ap` tail doesn't take pairs of numbers off the list at a time.)
17:26:09 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
17:26:42 <rwbarton> > randomR ((1,1),(10,10)) $ mkStdGen 17
17:26:44 <lambdabot>   No instance for (System.Random.Random (t0, t1))
17:26:44 <lambdabot>    arising from a use of `e...
17:27:02 <crdueck> @src unless
17:27:02 <lambdabot> unless p s = if p then return () else s
17:30:28 <startling> that's handy, never saw that.
17:31:07 <shachaf> @yarr
17:31:07 <lambdabot> Where d' all t' pirates come from?
17:31:07 <lambdabot> Great Yarrmouth!
17:32:02 <Sintendo> > zip `ap` tail $ (randomRs (1,10) (mkStdGen 17))
17:32:04 <lambdabot>   [(2,9),(9,8),(8,5),(5,3),(3,10),(10,8),(8,7),(7,5),(5,10),(10,8),(8,8),(8,5...
17:32:18 <Sintendo> doesn't work on my end?
17:32:51 <Sintendo>     No instance for (Monad ((->) [b0]))
17:32:51 <Sintendo>       arising from a use of `ap'
17:32:51 <Sintendo>     Possible fix: add an instance declaration for (Monad ((->) [b0]))
17:32:51 <Sintendo>     In the expression: zip `ap` tail
17:32:51 <Sintendo>     In the expression: zip `ap` tail $ (randomRs (1, 10) (mkStdGen 17))
17:32:51 <Sintendo>     In an equation for `it':
17:32:51 <Sintendo>         it = zip `ap` tail $ (randomRs (1, 10) (mkStdGen 17))
17:33:02 <byorgey> Sintendo: import Control.Monad.Instances
17:33:39 <Sintendo> thanks
17:34:09 <shachaf> Sintendo: But you know the first value of each of those pairs is the same as the last value of the previous one?
17:34:29 <Sintendo> now that you mention it
17:34:31 <Sintendo> that's no good
17:34:57 <shachaf> I think I've mentioned it at least twice before. :-)
17:35:01 <shachaf> Just do what edwardk said.
17:36:05 <Sintendo> I thought it looked neater, but that doesn't matter if it's not correct.
17:36:09 <Sintendo> Thanks
17:36:38 * cmccann considers telling lambdabot to remember "<shachaf> Just do what edwardk said." for future misuse of the quote
17:37:11 <shachaf> I think #haskell people prefer to play "Simon says".
17:37:19 <Saizan> sorry for the confusion :)
17:37:52 <cmccann> shachaf, but that's only half as fun as it used to be :[
17:38:24 <shachaf> cmccann: Alas.
17:40:08 <latermuse> shachaf: does simon often hang out in this channel?
17:41:29 <shachaf> Which one?
17:43:17 <byorgey> Simon Marlow hangs out on IRC occasionally, as JaffaCake.  SPJ doesn't do IRC.
17:43:17 <wwwww> hi
17:43:26 <byorgey> hi wwwww
17:44:10 <shachaf> byorgey: SPJ has been seen around a few years ago.
17:44:24 <byorgey> oh really?  didn't know that
17:44:39 <shapr> but only twice :-P
17:44:57 <shachaf> Last seen in 2006
17:45:05 <shachaf> Hmm, no, maybe later than that.
17:45:33 <byorgey> ok, so what I said may be *technically* inaccurate but still basically true =P
17:45:35 <typoclass> if i was simon, i'd often come in here as hellokitty22 and ask bizarre nonsense
17:45:43 <shachaf> haskell/12.08.28:23:35:28 <preflex>  simonpj was last seen on #ghc 3 years, 353 days, 15 hours, 27 minutes and 48 seconds ago, saying: Sorry went away for a moment.  I am clueless about branch tagging, but feel free to discuss it anyway!
17:45:43 <byorgey> haha
17:45:49 <byorgey> typoclass: maybe he does!
17:46:04 <shachaf> We should get him back in here! GHC is getting way too many features way too fast.
17:46:26 <byorgey> haha, so we should slow him down by distracting him with IRC?
17:46:30 <sipa> we should celebrate in 12 days, 8 hours, 32 minutes and 12 seconds
17:46:55 <wwwww> I needHelp  For  buffer overflowWith   ollydbg plugins
17:47:00 <shachaf> Sintendo: - the time since Aug 28
17:47:20 <wwwww> I need Help  For  buffer overflow With   ollydbg plugins
17:47:23 <byorgey> wwwww: this is a channel for discussing the Haskell programming language.
17:47:23 <shapr> wwwww: I think you may be in the wrong channel.
17:47:52 <wwwww> tanks
17:48:06 <sipa> please, no tanks
17:48:21 <shapr> wwwww: You should try some other channel.
17:48:30 <byorgey> tanks are better than stabs
17:48:54 <shachaf> byorgey is not a fan of Acting Masta B
17:49:04 <shapr> shachaf: ?
17:49:06 <wwwww> i ned help make trojan with delphi 7
17:49:06 <byorgey> ...apparently not
17:49:24 <shachaf> @ty perform
17:49:25 <lambdabot> Monad m => Acting m a s t a b -> s -> m a
17:49:42 <byorgey> wwwww: go to a different channel, please
17:49:52 <shapr> wwwww: This channel is for learning the Haskell programming language.
17:49:57 --- mode: ChanServ set +o byorgey
17:50:19 <byorgey> woah, what just happened
17:50:31 <shachaf> shapr?
17:50:40 <byorgey> I got a +1 ring of opping
17:50:50 <shapr> I call it delegation :-P
17:51:07 <wwwww> Thank you
17:51:34 <typoclass> i think when bruce banner freaks out, he also transmutes into an op
17:51:59 <shachaf> byorgey: Use your powers only for good, please.
17:52:07 <popl> typoclass: Bruce Banner is too much of a pimp to be hanging out in IRC.
17:52:22 * byorgey bans shachaf for daring to question his motives
17:52:27 <startling> byorgey: only +1? you'd still need a natural twenty to do any real damage.
17:52:38 --- mode: byorgey set -o byorgey
17:52:39 <latermuse> has anyone blogged about "stabs" yet?
17:52:47 <shachaf> byorgey: You should start by banning shapr.
17:52:48 <startling> latermuse: in lens?
17:52:50 <shachaf> Then you'll be invincible.
17:52:53 <latermuse> startling: yeah
17:52:55 <byorgey> hehe
17:53:07 <startling> latermuse: no, but we make bad puns about it every once in a while.
17:53:51 * startling stabs latermuse, sets him overboard
17:54:05 <latermuse> ouch
17:55:13 <latermuse> is there a DES bruteforce algorithm on hackage?
18:00:26 <gnuvince> Quick reminder: does the sum of derivatives = derivative of the sum?
18:00:41 <rwbarton> yes
18:00:45 <gnuvince> Thanks
18:01:30 <deus_rex> it's nice how even naive newbie understanding of haskell translates into writing better code in other languages
18:01:44 <popl> deus_rex: What do you mean?
18:03:00 <deus_rex> for example, i'm writing some sort of complicated ajax JS that can fail in any of several intermediate steps. before it would've been some mess of callbacks, but basic monad grokking has led me to jquery's promises
18:03:08 <deus_rex> and the code is so, so clean
18:03:44 <deus_rex> it's still ugly because it's got js warts everywhere, but it's a lot cleaner than it would've been before i started learning haskell :)
18:04:34 <deus_rex> i think that esr quote about lisp making you a better programmer even if you don't use it a lot applies just as well to haskell
18:05:10 <typoclass> deus_rex: ;-)
18:05:49 <popl> I would venture a step further and suggest doing anything which changes your mental model of something will help you be a better something.
18:11:34 <latermuse> deus_rex: Lisp making you a better programmer is because lisp is a functional language (although not pure).
18:11:51 <latermuse> deus_rex: Learning a new paradigm can definitely make you see things you didnt notice before.
18:12:30 <latermuse> deus_rex: If you grew up only knowing functional programming, and you suddenly took a class in iterative programming, it would make you a better functional programmer.
18:13:20 <popl> I want to learn Smalltalk for this reason.
18:13:36 <latermuse> I used to teach scheme to middle schoolers. It will be fun to see if they get those same "enlightenment" experiences when they learn C in highschool.
18:38:56 <sw2wolf> How to embed a haskell REPL into xmonad ?
18:40:28 <sw2wolf> How to embed a haskell REPl into xmonad ?
18:47:10 <shapr> sw2wolf: Have you asked on #xmonad ?
18:47:39 <sw2wolf> yes, there is already a answer
18:47:50 <sw2wolf> i need to study it
18:49:13 <pdxleif> http://hackage.haskell.org/packages/archive/xmonad-extras/0.10.1.2/doc/html/XMonad-Prompt-Eval.html ?
18:49:27 <sw2wolf> yes
18:51:20 <drchaos> err...what is the proper type signature for this function? see isPalindrome here: http://vpaste.net/6DGFZ
18:51:30 <Tukeke> guampa, :D
18:54:47 <drchaos> ghci says that Bool is applied to too many arguments
18:55:33 <shachaf> drchaos: Bool is a type, not a class.
18:55:48 <shachaf> drchaos: Just comment out the type signature and ask ghci what it should be. :-)
18:58:46 <drchaos> err...my function is broken in general
18:59:31 <drchaos> all I know is what a palidrome basically is is that if a list read forwards and backwards (i.e. "reverse"'d) then it is a palindrome
18:59:55 <shachaf> Sounds good.
19:00:18 <drchaos> I just need the proper syntax
19:00:32 <shachaf> There's a pretty direct way of translating that description into code. :-)
19:00:40 <shachaf> Hint: You don't need to pattern-match.
19:01:33 <drchaos>   6 isPalindrome xs = reverse' xs == xs
19:01:37 <drchaos> just like that?
19:02:30 <drchaos> Mwahahahahahaha! I will rule the world!
19:02:34 <theorbtwo> drchaos: Try it and see?
19:02:40 <drchaos> I mean, it works!
19:02:55 <theorbtwo> drchaos: Well done.
19:15:11 <kristof> sweet Jesus
19:15:25 <kristof> I don't know why anyone ever decided that != should mean "does not equal".
19:15:39 <kristof>  /= makes so much more sense.
19:15:55 <popl> I'm not sure, kristof.
19:16:06 <charliesome>  /= makes me think of divide-equals coming from a c-style background
19:16:16 <deus_rex> who decided that ! should mean "logical negation"
19:16:17 <popl> /= looks like division + assignment
19:16:24 <kristof> charliesome: I understand that, but I'm coming from a mathematical background.
19:17:00 <charliesome> well i guess when you have ! meaning not, != makes sense
19:17:11 <kristof> Eh. Maybe.
19:17:34 <charliesome> you could make the same argument about ==
19:17:46 <charliesome> and how haskell should have = as its quality operator instead
19:17:50 <popl> It's a holdover from C, I think.
19:17:55 <kristof> I remember when I was first getting into programming through python and C, I was told that being very good at math would help me learn programming. And that the reverse would be true in some way; that programming would be fun because it was an extension of math.
19:17:57 <popl> The operator is different in other languages.
19:18:32 <startling> let's just use ≠.
19:18:48 <charliesome> kristof: i think it's more about the mindset. if you're good at maths, you're more likely to be good at programming since you're used to dealing with abstraction
19:18:57 <kristof> The first was true to an extent; I was certainly able to think abstractly and logically, but I wasn't necessarily utilizing anything too math-related.
19:19:01 <kristof> charliesome: Yeah.
19:19:20 <startling> I think mathematicians are likely to be good at code but not vice-versa.
19:19:24 <kristof> However, the second statement was never quite fulfilled.
19:19:26 <popl> http://en.wikipedia.org/wiki/!%3D#Standard_relational_operators
19:19:48 <popl> startling: I don't know about that.
19:19:49 <zachk> hello
19:19:50 <kristof> I liked programming, but imperative and object-oriented styles weren't fun to me because of any relation to math.
19:20:04 <startling> popl: which part?
19:20:15 <popl> startling: The mathematicians being good programmers bit.
19:20:29 <popl> I don't think that follows necessarily.
19:20:41 <kristof> In fact, it disappointed me a little bit. But then I discovered Haskell, and functional programming in general, and I think programming is a lot more enjoyable for me.
19:20:42 <startling> oh, that might be true. There are a lot of terrible TeX packages out there, fr'instance.
19:20:54 <kristof> popl: Mathematicians are far too lazy to be good at imperative styles.
19:20:58 <zachk> depends if they are into Z/R/Q more or C/R ya know :D
19:21:07 <popl> ugh
19:21:27 <popl> startling: Yes, I've dealt with some of them.
19:21:38 <xxxxxx> hi
19:21:59 <johnw> i think we need some imperative features in Haskell, if only because it's too much fun and we don't want the other languages to feel bad
19:22:06 <xxxxxx> help my
19:22:20 <kristof> johnw: Force them to use monads, heh
19:22:35 <johnw> i just use unsafePerformIO on every line
19:22:54 <popl> haha what a funny haskell inside joke that I don't get
19:22:59 <johnw> in fact, i'll just use a preprocessor to change ";" to a call to unsafePerformIO
19:23:52 <zachk> do it up johnw
19:24:41 <shachaf> johnw: Haskell has plenty of imperative features.
19:24:54 <shachaf> unsafePerformIO is not very imperative, though.
19:25:03 <johnw> don't correct even my jokes, shachaf
19:25:26 <startling> ugh, I hate how 'binary' is big-endian by default.
19:25:53 <startling> is cereal like this too? Doesn't seem to say anywhere.
19:26:06 <typoclass> johnw: he wouldn't have to if your jokes were technically accurate
19:26:12 <johnw> lol
19:26:17 <typoclass> ;-)
19:26:29 <johnw> at least my being here gives him stuff to say
19:26:56 <popl> startling: cereal is big-endian?
19:27:05 <popl> o_O
19:27:43 <startling> popl: dunno, that's what I'm asking.
19:27:49 <startling> 'binary' is.
19:28:31 <popl> startling: What kind of cereal?
19:29:20 <startling> popl: the kind the compells people to name their packages with bad puns.
19:41:36 <parcs`> startling: with cereal you have the choice between be or le
19:41:39 <rwbarton> edwardk: your "Projection" seems to be the same as a colens
19:42:06 <startling> parcs`: you do in Binary, too.
19:43:05 <startling> it's just annoying to use getWord32le et al instead of just "get"
19:43:09 <shachaf> Which Projection? The 3.6 thing or one of the 3.7 things?
19:43:27 <shachaf> And how does a colens work?
19:44:18 <rwbarton> the stuff described in the documentation in https://github.com/ekmett/lens/blob/master/src/Control/Lens/Projection.hs
19:44:20 <edwardk> shachaf: your colens is where food goes after stomach testing
19:44:43 <edwardk> rwbarton: good =)
19:45:05 <rwbarton> another fun thing to do with a Colens=SimpleProjection s a is map it to forall r. Lens (s -> r) (a -> r)
19:45:09 <rwbarton> this is also an isomorphism
19:45:25 <rwbarton> I was considering representing colenses this way
19:46:07 <edwardk> Simple Projection s a ~ forall r. Simple Lens (s -> r) (a -> r)
19:46:12 <rwbarton> yes
19:46:48 <edwardk> i guess that makes sense
19:47:20 <rwbarton> and Simple Projection s a is also what you get when you take the naive/first-order definition of lens and read it in Hask^op
19:47:38 <rwbarton> or anyways (a -> s, s -> Either s a) is, and it sounds like you are talking about the same thing
19:47:44 <rwbarton> with some laws of course
19:47:58 <edwardk> yeah
19:48:15 <johnw> 𝐇𝐚𝐬𝐤ºᵖ
19:48:32 <edwardk> (s -> Either t a, b -> t)  -- so what is the indexed version of the Simple Lens version of that?
19:49:07 <rwbarton> i didn't bother to figure out what variables go where :)
19:49:10 <johnw> (s -> Either t a, b -> u)?
19:49:38 <edwardk> the t has to equal u
19:49:46 <johnw> hmm
19:49:52 <rwbarton> you should be able to figure out the only possibility from the variances
19:49:55 <edwardk> the point of it is that you can either get the a out or show you don't need it
19:50:07 <rwbarton> since now it is covariant or contravariant in every argument
19:50:08 <edwardk> rwbarton: yeah i was just trying to save myself the trouble ;)
19:50:10 <startling> why can't I "sequence_ . sequence $ [put . x, put . y]"? "sequence $ [put x . put y]" is a [Put], which is a synonym for PutM () (which is a Monad)
19:50:16 <rwbarton> ok
19:50:16 <shachaf> So what happened to (s -> Either t (a, b -> t), b -> t)?
19:50:18 <edwardk> rwbarton: Iso is now that way too
19:50:30 <startling> given the Reader instance in Control.Monad.Instances, that is.
19:50:32 <edwardk> shachaf: i killed it
19:50:32 <rwbarton> @type lens
19:50:34 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
19:50:37 <edwardk> it was an abomination
19:50:45 <shachaf> edwardk: Great!
19:50:54 <edwardk> you can feel free to simplify your Types list
19:51:06 <shachaf> So now you only have projections where the b -> t gives you what you would have gotten anyway.
19:51:16 <shachaf> edwardk: With great foresight I didn't bother to put projections on it. :-)
19:51:22 <edwardk> yep. which caused it to be obvious that At, etc. shouldn't be projections
19:51:23 <rwbarton> okay so (s -> Either t a, b -> t) is covariant in a and t so it must be Lens (t -> r) (s -> r) (b -> r) (a -> r) I guess?
19:52:27 <edwardk> so some kind of 'embedded :: Projection s t a b -> Lens (t -> r) (s -> r) (b -> r) (a -> r)' combinator seems warranted
19:52:47 <rwbarton> it's even directly useful for defining a function by cases
19:52:50 <edwardk> or embedding, i'd have to check the tense used for similar combinators
19:53:22 <rwbarton> btw projection is a terrible name IMO :P
19:53:26 <startling> @hoogle [a -> m b] -> a -> m [b]
19:53:26 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:53:27 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
19:53:27 <lambdabot> Control.Monad forM :: Monad m => [a] -> (a -> m b) -> m [b]
19:53:28 <rwbarton> since it is really an inclusion a -> s
19:53:35 <rwbarton> which has a maybe-inverse
19:53:47 <edwardk> i'm not wedded to it, i was going with it as the projection side of the embedding/projection pair because it acts as the traversal by default
19:53:54 <rwbarton> well, that name is terrible too
19:54:02 <rwbarton> but i guess standard
19:54:03 <edwardk> so it acts like the b -> Maybe t side more than the a -> s side
19:54:30 <rwbarton> I suppose either one determines the other
19:54:42 <MrWoohoo_> m
19:54:51 <edwardk> i was stuck acting like the traversal to deal with the types
19:55:08 <rwbarton> the arguments are in a better order that way I guess
19:55:14 <edwardk> i was originally going to try to get an Embedding type and a Projection type, but only the Projection one turned out to be readily definable
19:56:05 <edwardk> anyways if there is a better term than embedding-projection pair and a better name for the projection side of it. let me have it ;)
19:56:34 <rwbarton> how about colens :P
19:57:55 <rwbarton> somewhere I have a bunch more examples written down
19:58:10 <rwbarton> (("foo"++), stripPrefix "foo") is one I like
19:58:13 <edwardk> colens is pretty awful
19:58:22 <edwardk> no offense ;)
19:58:26 <edwardk> i love the idea, hate the name
19:58:29 <johnw> colens is really close to talking about colons
19:58:46 <xenocons> damnit, i meant to do ghci and learn you a haskell today, did 2 chapers and got distracted with Ninja terminator again :(
19:59:02 <rwbarton> hm
20:01:30 <johnw> ninja terminator?
20:01:40 <johnw> is that like when a build rule stops the build?
20:01:47 <johnw> or am I just too geeked out?
20:01:54 <xenocons> johnw: http://www.youtube.com/watch?v=bvbfWLQjsdE neg, 1985 very cheesy very funny dub film
20:01:54 <rwbarton> for me Projection has exactly the wrong connotation in the context of lenses: it should be the extraction of a lens A x B -> A
20:02:16 <rwbarton> I will ponder the name some more
20:02:22 <edwardk> please do
20:02:27 <johnw> ok, actual ninjas and actual terminators
20:02:32 <edwardk> i'm pretty neutral on the name we have now
20:02:39 <edwardk> i like it better than Colens, but thats about it ;)
20:02:43 <johnw> edwardk: i would love a lens named "ninja"
20:02:48 <startling> does anyone have a clean way to write `put` for Binary instances?
20:02:53 <edwardk> and it has the right connotation in terms of Embedding/Projection but thats about it
20:03:23 <johnw> when you ninja a value from a list, you get back that value and a version of that list missing the element
20:03:27 <startling> I had a latin teacher who'd make up names for modern technology. projector was "proiector", naturally.
20:03:46 <startling> johnw: we could call it "pickpocket"
20:04:10 <rwbarton> if it was a true ninja the list would never notice its element was missing
20:04:14 <johnw> i've been playing WoW lately, so I scream "damn ninja" often enough to want to do it to my data
20:05:00 <xenocons> heh
20:05:13 <startling> johnw, you take the element out, and later, as the list walks back to its hotel room, it realizes it's missing its wallet.
20:06:20 <edwardk> it does act like a sort of Selector or Matcher or something but those are pretty common names
20:06:23 <johnw> when happens if I compose a ninja with a samurai, though
20:06:29 <johnw> i get bloody arrows
20:08:34 <xenocons> one can only hope it also has dodgey 80s synth music too
20:09:22 <startling> johnw, I don't think Arrow is *that* bad.
20:09:35 <johnw> i have no beef with Arrow
20:09:43 <startling> hehe
20:10:03 <johnw> but it's in the lesser-used part of my toolbox now
20:11:14 <startling> we need Bow and Quiver.
20:11:54 <DanielDiaz> and throwArrow :: Bow -> Arrow -> IO ()
20:12:35 <cmccann> at some point I was going to make an Arrow-based library called "quarrel" which was particularly amusing for reasons I can no longer recall
20:12:52 <startling> quiver :: [Arrow a a] -> a -> a ?
20:13:01 <cmccann> (quarrel = term for the arrows fired by a crossbow)
20:14:44 <johnw> throwArrowAndMiss :: Bow -> Arrow -> IO Arrow
20:19:48 <AfC> startling: -> Target, I should think
20:20:10 <startling> heh
20:29:56 <canta> Is there some tutorial in literate haskell? I read a bit over that feature and wasn't able to find something of that sort.
20:31:12 <shachaf> The Haskell Report specifies it as well as anything.
20:31:15 <shachaf> @where haskell2010
20:31:15 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
20:31:29 <shachaf> http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17900010.4
20:33:28 <canta> I meant if there is some haskell tutorial in the form of a .lhs file per chapter
20:36:08 <canta> I thought that would be kind-of an ideal way to explain concepts
20:36:32 <shachaf> Oh.
20:36:48 <shachaf> Probably not a general-purpose thing. Lots of specific posts and papers and what not are in that format.
20:44:15 <startling> man, why can't I lookeahed in 'binary'?
20:44:56 <startling> I mean, I *can*, it's just unwieldy.
20:46:53 <curious_> I just have a question, is there a better development environment you would recommend than Leksah?
20:49:39 <arfy> Hey there. what GUI libraries do people recommend to use with ghc?
20:51:55 <startling> @hoogle Int -> ByteString -> Word8
20:51:55 <lambdabot> Data.ByteString index :: ByteString -> Int -> Word8
20:51:55 <lambdabot> Data.ByteString.Unsafe unsafeIndex :: ByteString -> Int -> Word8
20:51:55 <lambdabot> Data.Data gmapQi :: Data a => Int -> (forall d. Data d => d -> u) -> a -> u
20:51:59 <startling> aha
21:01:38 <johnw> arfy: a lot of people use wxHaskell, or gtk
21:01:38 <hamishmack> arfy: Gtk2Hs
21:01:52 <johnw> curious_: I prefer Emacs
21:03:27 <arfy> johnw: Thanks, I was investigating wxHaskell
21:03:53 <johnw> i think all the graphical haskell tools I use use gtk2hs
21:05:02 <arfy> uh oh...
21:05:10 <arfy> Configuring wxc-0.90.0.4...
21:05:10 <arfy> setup.exe: wx-config: does not exist
21:05:28 <johnw> do you have the library installed on your system?
21:06:27 <arfy> I don't think so. was just about to head to wxwidgets.org and see if they had a pre-built wx 2.9 for windows. or do I need the sources
21:06:59 <johnw> i think you only need the libraries
21:07:05 <johnw> and wx-config will tell wxHaskell where to find the libraries
21:09:13 <csalive> hi
21:09:18 <johnw> hi!
21:09:28 <startling> how do I make a Word32 out of four Word8s?
21:09:35 <johnw> @faq Can Haskell greet you in 48 languages?
21:09:35 <lambdabot> The answer is: Yes! Haskell can do that.
21:09:43 <csalive> i started learning haskell just now
21:09:46 <startling> I guess fromIntegral and bitshifts. meh.
21:09:50 <csalive> can u suggest some good sites
21:10:00 <startling> @where lyah
21:10:00 <lambdabot> http://www.learnyouahaskell.com/
21:10:03 <johnw> csalive: learnyouahaskell.com, tryhaskell.com
21:10:05 <startling> ^ probably the best
21:10:06 <otters> @faq Can we suggest some good sites?
21:10:06 <lambdabot> The answer is: Yes! Haskell can do that.
21:10:16 <johnw> or is it tryhaskell.org...
21:10:27 <csalive> thanks :)
21:15:54 <startling> better question: I want to get a little-endian Word32 off the head of a bytestring, how should I do it?
21:16:35 <xenocons> :t forever
21:16:37 <lambdabot> Monad m => m a -> m b
21:16:45 <startling> it's a strict bytestring, so "binary" doesn't do it, and I'm already using "binary" so I don't want to pull in cereal.
21:16:56 <startling> @hoogle ByteString -> (Word32, ByteString)
21:16:56 <lambdabot> Data.ByteString.Lazy mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:16:56 <lambdabot> Data.ByteString mapAccumL :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:16:56 <lambdabot> Data.ByteString mapAccumR :: (acc -> Word8 -> (acc, Word8)) -> acc -> ByteString -> (acc, ByteString)
21:18:37 <xenocons> haha
21:18:57 <xenocons> forever $ randomIO >>= \b -> putChar $ if b then '/' else '\\'
21:19:03 <xenocons> (from http://www.reddit.com/r/programming/comments/142jix/10_print_chr_2055_rnd_1_goto_10_how_a_single_line/c79cz2q)
21:19:20 <xenocons> not as pretty as the c64 one
21:25:04 <xenocons> wait until reddit discovers rule 110
21:25:42 <lispy> forever $ randomIO >>= \b -> putChar $ if b then '╱' else '╲'
21:25:55 <lispy> Stupid putty
21:26:01 <xenocons> heh
21:26:10 * xenocons though i saved utf8 settings hmm
21:26:13 <lispy> On my mac I get all the pretty unicode, on windows, I'm lucky if I get a box with a ? in it
21:26:35 <charliesome> haha nice joke, windows and unicode
21:26:50 <xenocons> less unicode = less attack surface. :>
21:27:06 <charliesome> xenocons: how do you figure that?
21:27:20 <xenocons> i dont have a basis for my wild statements sorry
21:28:18 <xenocons> (anyway, windows loves unicode)
21:28:38 <xenocons> its just that most windows programs seem to have strange unicode support
21:28:49 <charliesome> because the win api makes unicode more painful than it needs to be
21:29:01 <xenocons> heh
21:29:10 <xenocons> doesn't winapi make everythign more painful than it needs to be?
21:29:14 <xenocons> thing*
21:29:58 <charliesome> the winapi also encourages the belief what wchar_t is all you need to support unicode
21:30:01 <xenocons> windows unicode = UTF-16LE
21:30:07 <xenocons> oh god
21:30:14 <xenocons> and _TEXT TEXT _T and T
21:30:14 <xenocons> lol
21:30:26 <xenocons> wprintf? L"somestring"
21:30:36 <charliesome> don't forget to #define UNICODE
21:30:40 <xenocons> sigh
21:31:10 <xenocons> i love windows, but using winapi is very much like a completely different world
21:31:15 <jmcarthur> > iterate (1 + id/2) 0 !! 100 -- a neat trick i discovered with numinstances for defining fixpoints that can be solved via iteration
21:31:17 <lambdabot>   2.0
21:31:20 <xenocons> almost as if they made it deliberately confusing
21:31:31 <canta> xenocons: That is on purpose.
21:31:35 <xenocons> :t (!!)
21:31:36 <lambdabot> [a] -> Int -> a
21:31:39 <xenocons> i see
21:31:56 * xenocons needs to not use !! as a custom operator for a b -> (a,b)
21:32:05 <jmcarthur> !! is the boring part of that :P
21:32:07 <xenocons> canta: never knew why though
21:32:20 <Jafet> :t (,)
21:32:21 <lambdabot> a -> b -> (a, b)
21:32:25 <jmcarthur> the interesting bit is the use of id to represent the recursion
21:32:46 <xenocons> is id (a -> a)
21:32:56 <lispy> xenocons: I don't think windows is at fault here. In fact, IIRC putty pushes the codepoints around correctly. When I looked at this last, I think the conclusion was font support.
21:32:58 <jmcarthur> well, yes
21:33:01 <charliesome> Jafet: woah is , actually an infix function when you type (1, 2)
21:33:02 <jmcarthur> :t id
21:33:03 <lambdabot> a -> a
21:33:24 <jmcarthur> charliesome: not quite. it won't parse without the parens, unlike most infix operators
21:33:49 <jmcarthur> charliesome: it's just that there is a prefix version of it in the form of (,) as well
21:33:53 <xenocons> lispy: right, im definetly a windows advocate (F#\MS nerd) , errr what was i going to say..
21:34:12 <xenocons> if you go to settings and click utf-8 in putty, i get more joy out of it
21:34:26 <xenocons> settings>translation>remote character set
21:35:03 <xenocons> jmcarthur: i dont know enough haskell yet to appreciate that function i dont think
21:35:27 <xenocons> the first thing i thought was id/2 should generate some type error
21:35:43 <jmcarthur> > iterate (id^2 - 3*id + 4) 0 !! 100
21:35:45 <canta> xenocons: Well, at least for MS Office formats and such things they make it extremly hard to write converters, so that one must have ms office to be compatible to the world.. also see the adobe photoshop format, they do similar things.. other thing is backwards compatability, which enforces them to carry around every bad decision for ages
21:35:48 <lambdabot>   mueval: ExitFailure 1
21:35:49 <lambdabot>  mueval: Prelude.undefined
21:35:55 <lispy> xenocons: I have that set
21:35:59 <jmcarthur> Prelude.undefined?
21:36:23 <xenocons> canta: right
21:36:33 <xenocons> bad formats\protocols, shudder
21:36:36 <jmcarthur> ah that diverges
21:36:44 <jmcarthur> even though there is a valid fixpoint for it
21:36:48 <xenocons> i hate to think one person was responsible for making components of my career very difficult
21:37:09 <jmcarthur> > id^2 - 3*id + 4 $ 2
21:37:10 <lambdabot>   2
21:37:24 <xenocons> hmm
21:37:29 <lispy> xenocons: I'm pretty sure the problem is that I use Consolas
21:37:36 <charliesome> jmcarthur: how does that even work
21:37:44 * xenocons has no idea how id is supporting ^ 2
21:37:50 <xenocons> lispy: ah
21:37:56 <charliesome> doesn't work in a ghci with nothing imported
21:38:04 <jmcarthur> charliesome, xenocons: lambdabot has this instance:   instance Num b => Num (a -> b)
21:38:05 <xenocons> isnt 'id' a function type?
21:38:10 <jmcarthur> xenocons: yup!
21:38:18 <xenocons> curious
21:38:21 <charliesome> jmcarthur: interesting
21:38:24 <jmcarthur> charliesome: you need the NumInstances package
21:38:27 <lispy> xenocons: I don't know if MS has any fixed width fonts that have good unicode support.
21:38:47 <xenocons> lispy: ive been using Envy Code R (Non MS, but free)
21:38:52 <xenocons> not sure how the unicode support is
21:39:08 <charliesome> to be fair, making a font that supports a good chunk of unicode characters must be time consuming and expensive
21:39:15 <charliesome> still, with all of microsoft's resources...
21:40:13 <xenocons> truetype engine on windows is pretty complicated
21:40:22 <xenocons> s/pretty/amazingly
21:40:48 <xenocons> s/amazingly/enough for really cool bugs to surface/
21:41:56 <xenocons> http://media.blackhat.com/bh-eu-12/Lee/bh-eu-12-Lee-GDI_Font_Fuzzing-WP.pdf for the interested ;p
21:44:26 <jmcarthur> @let sqrt' x = iterate ((id + x/id)/2) 1 !! 50
21:44:28 <lambdabot>  Defined.
21:44:41 <jmcarthur> > sqrt &&& sqrt' $ 5
21:44:44 <lambdabot>   (*Exception: showsPrec: No overloading for function
21:44:54 <jmcarthur> uh
21:44:57 <jmcarthur> :t sqrt'
21:44:58 <lambdabot> Fractional a => (a -> a) -> a
21:45:08 <jmcarthur> oh
21:45:23 <jmcarthur> @undef
21:45:28 <jmcarthur> @let sqrt' x = iterate ((id + pure x / id)/2) 1 !! 50
21:45:31 <lambdabot>  Defined.
21:45:34 <jmcarthur> > sqrt &&& sqrt' $ 5
21:45:36 <lambdabot>   (2.23606797749979,2.23606797749979)
21:45:36 <lispy> xenocons: what do you  use for haskell on windows? givm?
21:45:40 <lispy> er, gvim*
21:46:16 <canta> I never feel like I am in control over the system when it runs windows, one can never be sure what that damn thing does even when looking at it closely
21:46:33 <jmcarthur> i feel that way about anything that isn't unix
21:46:36 <jmcarthur> err
21:46:50 <jmcarthur> i guess os x might count as a unix, but i meant to say that i feel that way about os x too
21:47:07 <jmcarthur> i feel like linux is the only os i really know how to control
21:49:28 <canta> Even if you do not know how to control it, you can find extensiv documentation about everything, and when in doubt read the source
21:50:19 <jmcarthur> does lambdabot have any automatic differentiation in its libraries? that would be a neat thing to demonstrate
21:51:32 <johnw> xenocons: Arial is one of the most complete common unicode fonts too
21:53:38 <xenocons> lispy: ive only been using ghci
21:53:49 <xenocons> but i have notepad++
21:54:05 <xenocons> tbh slightly annoyed i cant use Visual Studio with ghc :(
21:54:29 <xenocons> 95% of my coding is done in REPLs though so its not too bad
21:54:43 <lispy> xenocons: Well....there have been ways to use VS with ghc in the past. I suppose they haven't been maintained though.
21:55:16 <xenocons> yeh Visual Haskell by mr. marlow
21:55:23 <xenocons> unsure if it works with 2012, couldnt find any links
21:55:30 <lispy> xenocons: http://stackoverflow.com/questions/395828/visual-haskell-2008
21:55:56 <xenocons> lispy: yeh looks like evil
21:56:26 <xenocons> pity, i am really happy with F# and the ability to select a piece of code and press Alt+Enter to send it to the REPL for evaluation
21:56:36 <lispy> xenocons: Phyx never released his attempt
21:56:58 <lispy> xenocons: emacs + ghc-mod might give you some of what you're missing
21:57:04 <xenocons> i would say its too much of a pain in the but
21:57:22 <lispy> I guess you'll have to wait for fpcomplete to finish their IDE
21:57:23 <xenocons> emacs is really foreign to me, but i might go that path
21:57:37 <xenocons> but ghci is enough atm
21:58:04 <xenocons> i saw there was some haskell ide that works on windows, but unfortunately requires GTK+ :<
21:58:32 <canta> i think you should be able to make something that evals it when the file is saved and put that out to a console window
21:58:34 <xenocons> not only infecting my system with non ASLR .dlls, but i find GTK+ just sluggish on windows
21:58:57 <xenocons> canta: yeh but you wouldn't want to eval the entire file
21:59:20 <xenocons> advantage of selecting the text then alt + enter is you only send what you have selected to the REPL
21:59:25 <xenocons> this is really awesome for prototyping
21:59:26 <clahey_> Can folks point me toward haskell papers?
22:00:53 <clahey_> I need to write an abstract for a paper about a microxml parser (and an error handling version)
22:01:05 <canta> xenocons: It should be fast enough, why even try something non F#?
22:01:44 <xenocons> canta: good question, I dont exactly know why
22:01:50 <xenocons> but i think F# is the gateway drug to haskell
22:02:15 <canta> :)
22:02:18 <xenocons> you write F# and you think, oh, why is there List.map and Seq.map and Array.map ?
22:02:22 <xenocons> thats kinda stupid
22:02:35 <xenocons> why cant there be a generic map that works on all types that support enumeration?
22:02:43 <xenocons> ... you google and you find type classes heh
22:03:21 <xenocons> (althought Seq.map works on arrays and lists and sequences(lazy), it is a bit different
22:03:24 <xenocons> )
22:04:13 <xenocons> i guess just learning about FP and concepts makes you look at haskell
22:04:15 <xenocons> (for me)
22:05:14 <xenocons> starting at the bottom (von neuman c), then thinking hmm howcan this be abstracted, you look at python
22:05:42 <xenocons> then by looking at python you think, well thats all very well, but its really just syntactic wrapping of the C concepts, how can i abstract the semantics
22:06:18 <xenocons> then you land at functional languages, which are closer to the math (the universal programming language)
22:06:30 <xenocons> </rant>
22:08:30 <canta> did not find that ranty :p
22:09:11 <xenocons> i started off in python about 4 years ago, as my first language, then from python to F#, and for a period of about 3 years i pivoted between SML, OCAML and F#, and C and python
22:09:39 <xenocons> found SML to be the most mind expanding, F# to be the most practical (a balance between doing what i like and what i need) and C the best for understanding 'the computer'
22:09:54 <xenocons> guess ive had haskell in the back of my mind for a year or so now
22:10:34 <canta> yeah, c feels a lot like how assembler felt a decade ago, at least it seems to me that way
22:11:08 <xenocons> ive dabbled in asm (x86 and ppc), it is very similar to C when you think about it
22:11:11 <xenocons> imo
22:12:03 <xenocons> i dont mind C, its frustratingly relevant
22:13:00 <xenocons> i realise the von neumann model is both responsible for a technology revolution and the hinderance of intellectual prosperity, there i said it
22:13:23 <xenocons> NOW i am ranting ;)
22:13:59 <canta> Are there sufficiantly different models that are 'better'?
22:14:06 <jmcarthur> i don't think it's responsible at all. it is a decent model with lots of beneficial properties.
22:14:30 <neutrino_> hey guys
22:14:37 <jmcarthur> the problem isn't with the von neumann architecture. it's with closed mindedness.
22:14:38 <neutrino_> anyone know where "sudo cabal install" puts the files?
22:14:47 <jmcarthur> nowhere i want it to
22:14:57 <xenocons> not that i know of, i am an uneducated assumer :)
22:15:13 <Nereid> haskell is wonderful :)
22:15:15 <jmcarthur> neutrino_: you could try installing something under strace, perhaps
22:15:16 <xenocons> dislike people who think C is the only true model of programming
22:15:16 <neutrino_> i need to know where they go
22:15:32 <neutrino_> jmcarthur: hmm yeah, but i'm worried it'll break something.
22:15:36 <xenocons> jmcarthur: probably true
22:17:35 <xenocons> sometimes i feel like bloody jehovas witness when i tell people i like the functional paradigm heh
22:19:26 <jmcarthur> xenocons: the difference is that jehovas witnesses have a harder time making people say "woah!"
22:19:33 <xenocons> heh
22:20:05 <xenocons> either way, a horrible number of people think functional programming is some LSD inspired 1960s pipedream
22:20:14 <xenocons> (where i come from anyway)
22:20:39 <Vyn> Where is that?
22:20:54 <jmcarthur> i choose not to associate with such people when i can help it. i find their lack of imagination intellectually stifling.
22:21:13 <jmcarthur> not that all people who think that lack imagination. i'm generalizing...
22:21:18 <xenocons> (australia)
22:21:33 <xenocons> jmcarthur: yeah, i agree
22:21:45 <xenocons> why are people so afraid to explore
22:22:23 <xenocons> curiosity is the precursor to learning :(
22:22:34 <jmcarthur> if you are happy with what you know, why accept that the grass could be greener elsewhere?
22:22:51 <jmcarthur> (i'm playing a little devil's advocate here)
22:23:20 <xenocons> not entirely sure why, but it frustrates me that i get ignored to a certain extent based on my choice in programming paradigms
22:23:33 <xenocons> part of me wants peer acceptance i guess
22:24:50 <xenocons> and also it raises a horrible thought, i am not sufficiently smart, otherwise people would look past the paradigm and see it for what it is
22:24:53 <xenocons> heh
22:25:09 <startling> xenocons, maybe you're much smarter than anyone else? that might be equally horrible
22:25:12 <jmcarthur> that came off more negatively than i meant it to. a good example of the kind of thinking i have in mind is a scene in the movie Fearless where jet li's character doesn't want to learn about the differences between various teas because it would make it harder for him to appreciate all teas
22:25:15 <startling> you're doomed forever to work on bad code. :(
22:25:44 <startling> jmcarthur: that's interesting. I do that with tea, too.
22:25:55 <Jafet> All programmers are doomed to work on bad code
22:26:03 <xenocons> jmcarthur: hah nice
22:26:34 <startling> olive oil, too.
22:26:56 <xenocons> well, i certainly dont feel smarter than everyone, part of what drives me i guess... but why am i one of the minority of a minority who thinks functional programming is really relevant
22:27:09 <xenocons> and more than just 'programming, but a way of thinking about problem solving
22:27:19 <xenocons> (im glad im only at the start of my FP journery)
22:27:53 <startling> xenocons, this channel is pretty big.
22:28:00 <startling> one of the biggest on freenode iirc.
22:28:03 <jmcarthur> the scene i'm referring to http://vimeo.com/15687220
22:30:48 <jmcarthur> yeah this channel is in the top 10 (maybe still in the top 5?)
22:31:01 <xenocons> true
22:31:28 <jmcarthur> but i think it overrepresents the userbase of haskell relative to other languages' channels
22:33:10 <startling> I think it's that haskell's community is great, so even if people aren't super into haskell, they like hanging around and a lot of people come to irc specifically for #haskell.
22:33:27 <startling> also, haskell is probably more difficult to learn, so we get more people asking for help. :S
22:36:34 <mgsloan> quality vs quantity, what matters more? :)
22:37:38 <xenocons> haskell is more difficult because you know at compile time that you screwed up
22:39:28 <startling> xenocons: meh. I think it's more difficult because it's so fundamentally foreign to the most popular languages right now.
22:39:42 <startling> I'm not sure it's difficult when starting from a blank slate.
22:39:54 <mgsloan> startling: definitely.   People are used to learning languages by analogy
22:40:13 <startling> "how do you do a loop in haskell?" etc
22:40:35 <startling> what's that really cool argument parsing library?
22:41:08 <mgsloan> what do you mean variables don't change?!?! how does anything happen!
22:41:26 <xenocons> startling: hmm
22:41:42 <xenocons> imo, i blame computer science
22:41:42 <xenocons> haha
22:41:53 <xenocons> haskell is an obvious extension of primary school alegbra
22:41:59 <startling> xenocons, nah.
22:42:02 <xenocons> s/haskell/ML languages
22:42:17 <k0001_> Haskell humbles you. It takes courage, will and patience to be humble.
22:42:25 <jmcarthur> mgsloan: and from the other direction... "how the hell am i supposed to know the value of an identifier if it can just change arbitrarily?"
22:42:46 <xenocons> k0001_: i like being humbled :>
22:43:21 <startling> xenocons: it took like 1700 years to get from "primary school algebra" to lambda calculus. :c
22:43:34 <jmcarthur> i don't like the presentation of haskell being a humbling experience. i think it misrepresents haskell and distracts from the real point.
22:44:19 <xenocons> startling: thats true
22:44:24 <mgsloan> jmcarthur: haha, indeed :)  Put differently "How am I supposed to know other code will care if I change this?!?"
22:44:25 <jmcarthur> frankly, i don't think it is all that humbling. of course those who go in with preconceptions are going to be surprised, but that happens any time you learn something new
22:45:31 <startling> right, I think imperative programming might be more difficult to learn than e.g. haskell without knowing any other languages.
22:45:58 <xenocons> i think so ^
22:46:07 <startling> especially wrt debugging.
22:46:14 <xenocons> yeh
22:47:29 <jmcarthur> i only have a couple data points, but what i've seen so far neither supports nor opposes that claim about learning haskell first
22:47:45 <startling> aha, optparse-applicative
22:48:53 <xenocons> OOP programming is actually very difficult
22:48:56 <xenocons> imo
22:49:09 <jmcarthur> my wife learned haskell first and does get a little confused about imperative languages, but she hasn't spent much serious effort on any programming. a have some friends/coworkers who learned haskell first and aren't very comfortable with a lot of imperative styles, but it may be that they just stick with haskell because it's what they knew first, not necessarily because it would be easier for them in the
22:49:10 <jmcarthur> long run
22:49:14 <xenocons> i am really impressed people can embrace it and sell it
22:49:22 <jmcarthur> s/a have/i have/
22:49:43 <startling> xenocons: I think it's mostly cargo-cult programming. :/
22:49:50 <startling> at least "big OO" like C++ and Java.
22:49:59 <xenocons> yeh and C# i guess
22:50:17 <xenocons> but all these big OO languages start to grow functional features
22:50:21 <startling> I hear that C# is nice, actually, so I deliberately left it out, haha.
22:50:29 <xenocons> C++ with #include <functional>
22:50:36 <xenocons> C# with Linq (thanks erik meijer)
22:50:43 <xenocons> java with... umm
22:50:45 <xenocons> im not sure
22:50:49 <jmcarthur> OOP as a universal paradigm seems cultish to me
22:51:25 <xenocons> Java with the most vulnerable runtime in history while claiming to be typesafe ? hehe
22:51:31 <startling> I don't mind pythonish or luaish oop, but inheritance is pretty annoying.
22:51:34 <jmcarthur> that sentence was hard for me to say at all because i don't believe in paradigms
22:51:53 <xenocons> startling: yes composition > inheritance
22:51:56 <xenocons> imo
22:52:27 <xenocons> jmcarthur: its nice to say you dont believe in paradigms (and to think it)
22:52:46 <xenocons> but in job interviews its always like 'so what programing paradigms are you familiar with'
22:52:52 <xenocons> 'do you know AGILE?'
22:53:03 <jmcarthur> questions like that make me not want to work for that employer
22:53:07 <xenocons> 'are you a SCRUM programmer?'
22:53:08 <xenocons> heh
22:53:10 <xenocons> yeh
22:53:19 <sw2wolf> `cabal install xmonad-extra` error : http://hpaste.org/78586
22:53:46 <jmcarthur> interviews are for you to assess the employer as much as they are for the employer to assess you
22:53:46 <mysticc> Can you splice TH inside where?
22:54:26 <xenocons> jmcarthur: good point
22:54:34 <k0001_> jmcarthur: I agree. I was refering to the humbling learning experience itself if you come from years of programming without thinking about your problems and solutions the way Haskell encourages you to do.
22:54:39 <xenocons> i rate every single employer on the planet as unsatisfactory
22:54:50 <jmcarthur> that seems overboard to me
22:55:15 <jmcarthur> there are some great employers out there. none perfect, but many that are a joy to work with
22:55:55 <jmcarthur> you just have to be willing to say "no" to the bad ones
22:56:07 <xenocons> sure
22:56:16 <xenocons> its the 'all crows are black' argument for me currently
22:56:52 <xenocons> i haven't seen every crow to be able to make a 100% truthful statement, but based on the crows that I have seen so far, i would make the assertion that all are black =p
22:57:26 <canta> it is trivial to find a non-black crow, just grab some paint :p
22:57:41 <Ralith> canta: try to paint a crow and get back to us about 'trivial'
22:57:48 <xenocons> heh
22:58:28 <xenocons> racism can also be semi-justified with this statement though
22:58:36 <canta> I hope white-spotted does satisfy the non-blackness property
22:58:46 <xenocons> im willing to admit there are good places that encourage good programming habbits
22:59:11 <xenocons> and that ijust have not found them yet
22:59:15 <jmcarthur> and of course good programming habits alone do not a good employer make
22:59:18 <xenocons> (is this the E.T argument?)
22:59:28 <xenocons> yeh true
22:59:32 <xenocons> its more complex than that i guess
22:59:45 <Ralith> xenocons: how do you go about looking for jobs?
22:59:55 <xenocons> a) free gourmet lunches!
23:00:23 <xenocons> Ralith: hmm, well i have been unemployed for 4 months, but found a job that i should be signing a contract for next week
23:00:33 <xenocons> every time i have found work in the past has been from knowing someone
23:01:02 <xenocons> apparently they dont mind what language is used internally
23:01:05 <xenocons> ... we will see...
23:01:32 <xenocons> job sites are useless imo, as are recuiters
23:01:57 <xenocons> 'you can hack and write code? boy i have the VISUAL BASIC FINANCE JOB for you!'
23:02:18 <jmcarthur> hey visual basic finance jobs can be nice if you're lucky
23:02:55 <xenocons> i wont completely disregard it, but its not going to be top of my list
23:03:01 <jmcarthur> (not that i would be interested in that tagline...)
23:03:06 <xenocons> hwh
23:03:08 <xenocons> heh*
23:03:20 <k0001_> I might measure lengths in Ångströms now, just to see this type written down in my unicode code. http://hackage.haskell.org/packages/archive/unittyped/0.1/doc/html/UnitTyped-SI-Derived-Length.html#t:-197-ngstr-246-m
23:03:37 <xenocons> must be familiar with AGILE DEVELOPMENT LIFECYCLE
23:03:38 <jmcarthur> my favorites are the ones that need rockstar elite hackers to write html
23:03:43 <xenocons> lol
23:03:44 <xenocons> ^
23:03:45 <xenocons> haha
23:04:22 <arbn> xenocons: Job sites aren't useless. I found my present job from Stack Overflow's career site.
23:04:25 <shapr> I've often wondered what 1mm is in Ångströms.
23:04:35 <jmcarthur> stack overflow isn't the traditional job site, to be fair
23:04:39 <xenocons> arbn: i haven't tried SO job site
23:04:48 <shapr> jmcarthur: How'd you find your job?
23:04:50 <xenocons> only generic mycareer\jobseek ones
23:05:29 <jmcarthur> shapr: well of course i'd heard of my employer from various places, but the job ad i saw that reminded me to apply was on http://functionaljobs.com/
23:05:41 <arbn> GitHub and SO both job services, and I see a lot of cool jobs there. Many for startups, but also some established company. Jane Street uses both, actually. I tend to use the keyword "Haskell". :)
23:05:57 <shapr> arbn: Do you work at Jane Street?
23:06:09 <arbn> shapr: No. I work for a tiny startup, but I use Haskell.
23:06:12 <xenocons> arbn: ahh, jane street...
23:06:20 <xenocons> they are the cream of the drop
23:06:22 <xenocons> crop*
23:06:26 <shapr> arbn: Do they need another Haskeller? :-)
23:06:46 <arbn> shapr: Not yet. But, if we do well, I may be interviewing Haskellers. Wish us luck. :)
23:07:13 <xenocons> didn't know about functionaljobs.com i will bookmark that
23:07:22 <shapr> arbn: Can you say anything about what you use Haskell for?
23:07:22 <jmcarthur> xenocons: my impression is that jane street is a bit more humble than that
23:07:48 <xenocons> jmcarthur: from the ocaml perspective, if you work at jane street that is one of the best places to work
23:08:01 <jmcarthur> well aware
23:08:07 <jmcarthur> jane street is a very nice company
23:08:16 <shapr> I wonder if I know anybody who works at jane street? :-P
23:08:53 <arbn> shapr: We use Haskell for whatever we can realistically use it for. Our area is "digital publishing", broadly speaking.
23:09:32 <shapr> Sounds nifty.
23:09:36 <jmcarthur> xenocons: so did you apply with jane street during your job hunt?
23:09:49 <shapr> arbn: Sounds like you could be working for Silk in Amsterdam
23:10:07 <xenocons> jmcarthur: yeh, i applied for one job there (i think it was an internship?) but they would need to sponsor a visa for me
23:10:18 <jmcarthur> that isn't a problem
23:10:26 <xenocons> tl;dr i never got a response after filling out their generic web-app career form
23:10:35 <arbn> shapr: Except that I'm in New York. :P Silk is cool, though.
23:10:37 <jmcarthur> oh
23:10:57 <shapr> arbn: Ah, ok then. Do you hang out with the NYC Haskellers?
23:11:08 <shapr> I've heard there's an active group there.
23:11:12 <arbn> shapr: I was at the first meeting, and I plan to be at the second. :)
23:11:12 <jmcarthur> yeah!
23:11:55 <shapr> I've started yet another tech meetup in my city, but since it's the *only* tech gathering of any sort, I doubt there will be a Haskell Users Group anytime soon.
23:12:03 <shapr> I've only succeeded in converting one person to Haskell :-(
23:12:12 <shapr> Well, only one person in this town.
23:12:33 <xenocons> one person? that is good
23:12:41 <shapr> I've had more success on the internets though.
23:12:45 <xenocons> i think ive converted -10 people to functional programming
23:12:46 <xenocons> haha
23:12:48 <arbn> NYC seems to be quite a nice for functional programming. Jane Street is here, and various other finance firms using FP, and probably a few other startups use some sort of FP language as well.
23:12:58 <xenocons> (to be fair they already had a pre-disposed ilness)
23:13:00 <arbn> nice place*
23:13:05 <shapr> xenocons: haha
23:13:10 <mgsloan> The first seattle meetup is on the 8th!
23:13:13 <shapr> mgsloan: yay!
23:13:28 <shapr> So that's northwest, northeast and southwest USA has meetups.
23:13:36 <mgsloan> yeah :D  pretty excited. 13 people are signed up
23:13:37 <shapr> NYC, Seattle, and the Bay area.
23:13:55 <shapr> Too bad the Portland crowd is so far away.
23:14:32 <mgsloan> not /too/ far from seattle, heck there's even a bike ride called "Seattle to Portland"
23:14:43 <mgsloan> (then again most people take two days)
23:14:51 <arbn> In my job interview, I was asked about comonads. Sadly, I didn't know anything about them. So, if you want a Haskell job, study up. :P
23:14:58 <shapr> mgsloan: Do you think some of the Portlanders will show up for the Seattle HUG?
23:15:06 <edwardk> arbn: where was this at?
23:15:09 <shapr> arbn: I don't know anything about comonads!
23:15:09 <jmcarthur> xenocons: when did you apply? was it by-chance during or soon after hurricane sandy? jane street had some technical difficulties for a little while after that
23:15:19 <mgsloan> shapr: maybe so!  There's one guy in australia that might show up http://www.meetup.com/SEAHUG/
23:15:20 <shapr> I had to actively resist learning about comonads when I had a job in Boston.
23:15:27 <shapr> It was difficult.
23:15:28 <edwardk> hah
23:15:40 <xenocons> arbn: noted, i will read up on this
23:15:49 <xenocons> jmcarthur: quite likely around the time of hurricane sandy
23:15:53 <arbn> edwardk: A tiny startup. We are still invisible.
23:16:04 <jmcarthur> xenocons: i suspect you might have better luck if you tried again
23:16:30 <xenocons> wouldn't they just brush off someone like me though?
23:16:42 <jmcarthur> i don't know. haven't seen your resume :P
23:16:54 <xenocons> heh, sounds like you work at janestreet
23:16:55 <shapr> xenocons: I'll submit my resume to Jane Street if you submit yours :-P
23:17:24 <xenocons> i have a fear of rejection, and ive never succ obtrained a programming job =p
23:17:36 <xenocons> (private security consultant by trade)
23:17:39 <jmcarthur> i just mean i can't even begin to guess what jane street will think when i don't even know what i think
23:17:45 <shapr> xenocons: Well, best way to get over that is to start submitting resumes, right?
23:18:01 <shapr> xenocons: You can submit your resume to me. I promise to not hire you.
23:18:05 <arbn> xenocons: You have to be rejected many times to have a chance at getting a new job.
23:18:18 <shapr> Mostly because I'm an undergrad in computer science.
23:18:19 <xenocons> well, while i was job hunting, i submitted to about 20 places, and got 0 responses
23:18:47 <jmcarthur> arbn: you were asked about comonads in your job interview for your current job?
23:18:53 <xenocons> i crawled back like a beaten dog to the ethically void carreer of being a security consultant
23:18:54 <jmcarthur> xenocons: yeah that happens
23:18:56 <arbn> jmcarthur: Yes.
23:19:07 <jmcarthur> arbn: sounds like a cool interview :)
23:19:09 <arbn> jmcarthur: And whether I had been exposed to dependent type theory, actually.
23:19:16 <jmcarthur> *2
23:20:11 <jmcarthur> xenocons: why is secutiry consulting ethically void?
23:20:16 <jmcarthur> *security
23:20:29 <xenocons> heh :P
23:20:48 * xenocons chuckles and wonders how to formulate responjse
23:21:12 <arbn> xenocons: Do you have a code portfolio? Some source-code for large programs you've written?
23:21:16 <jmcarthur> my background is in antitamper software. does that count?
23:21:28 <jmcarthur> yeah my resume was mostly open source projects
23:21:39 <xenocons> as it is my only professional career, security consulting is for the most part a grab for cash
23:21:42 <jmcarthur> nailed me an interview for my current job, at least :)
23:22:01 <xenocons> a lot of the time you are playing on peoples paranoia
23:22:08 <jmcarthur> oh that kind of security
23:22:22 <xenocons> arbn: not really, only in house tooling and private projects
23:22:29 <xenocons> some R&D
23:22:58 <xenocons> i try to keep all my code though, its useful
23:23:12 <arbn> xenocons: I think a lot of places want to see your code, to know that you're not an idiot. :)
23:23:40 <xenocons> in my resume under R&D i have 'please enquire for source code' written there
23:23:47 <edwardk> heh, now that comonads are being asked about in interviews i wonder how long it is until lenses become the interview topic ;)
23:23:57 <xenocons> its just it seems most jobs here want 'o u can write enterprise agile java ok?'
23:24:07 <jmcarthur> edwardk: well, that inspires my next interview question i guess :)
23:24:08 <edwardk> 'given this definition for the Bazaar comonad how would you characterize a Traversal'?
23:24:37 <xenocons> so what if i wrote a dodgey vim <=7.2 bruteforcer, doesn't mean i can write enterprise applications
23:24:44 <jmcarthur> edwardk: i don't think i'd quite present it that way :P
23:24:48 <edwardk> =)
23:24:51 <xenocons> (frequency table was the wrong approach btw)
23:24:55 <shapr> edwardk: I promise to learn about lenses over the Christmas break.
23:25:10 <edwardk> shapr: there is #haskell-lens if you want to learn by osmosis ;)
23:25:15 <shapr> oboy
23:25:17 <jmcarthur> i promise to learn about lenses when edwardk comes to nyc for his talk!
23:25:31 <arbn> jmcarthur: Yeah. That's my plan too.
23:25:53 <edwardk> i'm looking forward to being doing the talk where i can actually record it =)
23:25:57 <edwardk> er to doing
23:49:06 <johnw> me too!
23:55:12 <saiko-chriskun> ack why everything in ny
23:55:19 <saiko-chriskun> need to move
23:55:20 <saiko-chriskun> hahah
23:58:37 * hackagebot sym 0.2 - Permutations, patterns, and statistics  http://hackage.haskell.org/package/sym-0.2 (AndersClaesson)
