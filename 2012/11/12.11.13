00:00:01 <edwardk> simpson: yes
00:00:06 <forzabiz> ciao
00:00:07 <simpson> Nifty.
00:00:09 <forzabiz> !list
00:00:09 <monochrom> forzabiz: http://hackage.haskell.org/packages/archive/pkg-list.html
00:00:29 <Saizan> monochrom++
00:00:30 <edwardk> this isn't a law, but it is the way the implementation works and folks would cry foul if it changed i think
00:00:38 <simpson> monochrom: botsnack
00:00:55 <Nereid> edwardk: yeah, I just had a silly moment there.
00:00:58 <simpson> Hm. Maybe that one's busted.
00:01:13 <edwardk> if lambdabot had Data.Set.Lens in scope you can use setOf to build a set from a fold
00:01:50 <edwardk> s/can/could/
00:01:51 <Nereid> wait really
00:01:52 <Nereid> !list
00:01:52 <monochrom> Nereid: http://okmij.org/ftp
00:01:57 <Nereid> huh
00:02:23 <simpson> monochrom: Blurring the line between bot and troll.
00:02:28 <edwardk> !list
00:02:36 <Nereid> eh
00:02:48 <edwardk> heh, had to try =)
00:03:48 <Nereid> that reminds me of how this one channel I'm on banned *.it once.
00:04:10 <Nereid> oh, it's still banned. heh
00:13:16 <bxx> how do I check if (Maybe a) type is Nothing?
00:13:26 <bxx> or object of that type
00:13:31 <ivanm> there's isNOthing
00:13:33 <shachaf> isNothing
00:13:36 <ivanm> but you almost definitely don't want to use it
00:13:42 <typoclass> bxx: use "case m of Nothing -> ... ; Just x -> ..."
00:13:44 <bxx> ivanm why not?
00:13:46 <shachaf> But you should probably pattern-match, as in case foo of Nothing -> ...; Just x -> ...
00:13:53 <ivanm> because most times you probably want to use maybe
00:13:56 <ivanm> @type maybe
00:13:58 <lambdabot> b -> (a -> b) -> Maybe a -> b
00:13:59 <bxx> I tried == Nothing but that required a to be (Eq a)
00:14:01 <ivanm> or some variant there of
00:14:09 <ivanm> @type isNothing
00:14:11 <lambdabot> Maybe a -> Bool
00:14:19 <ivanm> bxx: why do you want isNothing ?
00:14:29 <ivanm> what will you do if the value is a Just?
00:14:56 <typoclass> bxx: pattern matching with case-of is the normal thing to do. an alternative is the function 'maybe' that ivanm showed
00:15:41 <ivanm> typoclass: "normal"?  You mean most people actually do explicit case statements for Maybe values rather than using the maybe function? :/
00:20:08 <Nereid> ah, I can finally install agda now.
00:20:24 <typoclass> ivanm: *shrug* i'd first teach him case-of rather than maybe. he can use it for all kinds of things, whereas maybe is only useful for Maybe
00:21:08 <ivanm> oh, in terms of teaching, etc. maybe
00:21:08 <bxx> I am using isNothing similar to this. seems cleaner than pattern matching (I'd like to be proven wrong though). http://hpaste.org/77638
00:21:23 <ivanm> the way you expressed it though made me suddenly go "have I been doing it wrong all this time?!?" ;-)
00:21:51 <typoclass> ivanm: ah ok i see :-)
00:22:01 <typoclass> bxx: lemme annotate that paste for you ...
00:22:24 <Nereid> do both case and maybe versions
00:22:42 <Nereid> also
00:22:48 <Nereid> using fromJust like that is horrors.
00:23:20 <johnw> Nereid: I installed Coq today
00:23:40 <Nereid> ...
00:23:42 <bxx> well it seems nicer to me than having isNextNothing and justNext, or whatever
00:23:42 <Nereid> apparently I have coq installed.
00:23:45 <Nereid> I don't remember installing it.
00:23:48 <hpaste> ivanm annotated “isNothing” with “isNothing (annotation)” at http://hpaste.org/77638#a77639
00:24:01 <simpson> Must...not...make Coq jokes...
00:24:12 <ivanm> bah, stuffed up the last line
00:24:20 <ivanm> bxx: doesn't help when your example was rather limited :p
00:24:46 <hpaste> ivanm annotated “isNothing” with “don't use isNothing! (fixed maybe example)” at http://hpaste.org/77638#a77640
00:24:49 <Nereid> I dunno why you put the "foo f d x = " stuff, but whatever.
00:25:09 <ivanm> bxx: ^^ that would be cleaner again if the arguments to foo had the `d' and (x:xs) values swapped around
00:25:21 <ivanm> as then the Just case would just be (foo f xs)
00:25:28 <bxx> ivanm do you find either of your version more readable than mine?
00:25:32 <Nereid> you also messed up line 4.
00:25:39 <ivanm> Nereid: bah
00:25:45 <Nereid> :p
00:25:47 <ivanm> Nereid: I was trying to work out a full example
00:25:52 <typoclass> bxx: so as ivanm showed, the advantage is that in your code you had to type 'next' twice, whereas with case-of you need it only once. you can then get rid of the 'where' entirely
00:25:52 <ivanm> bxx: because it says what you're doing
00:25:56 <ivanm> not giving line by line examples
00:26:18 <ivanm> declarative programming ftw!
00:26:35 <Nereid> in general, each time you use some partial function like "fromJust" or "head" or whatever, you should really think about what you're doing
00:26:56 <Nereid> chances are you can replace it with a pattern match or a catamorphism or something
00:27:15 <Ralith> beware replacing partial functions with partial pattern matches, of course
00:27:23 <ivanm> bxx: the maybe function is the fold over Maybe values (analogous to foldr)
00:28:08 <Nereid> Ralith: use -Wall then
00:28:20 <Nereid> ivanm: yes, that's what I meant by catamorphism.
00:28:22 <Nereid> :p
00:28:37 <bxx> ivanm yeah I see. first time I see either maybe or case
00:28:42 <ivanm> Nereid: sure, I just figured I'd explain it in more detail
00:28:46 <Nereid> sure.
00:28:58 <ivanm> bxx: you can do pattern-matching at the function level as well if the incoming value is a Maybe
00:29:02 <typoclass> bxx: anyway, if-then-else may look more natural if you're just starting with haskell. but try case-of a few times :-) i bet you'll get used to it quickly, and find it quite straightforward
00:29:02 * Nereid wants to see a TH thing for deriving a catamorphism for any ADT
00:29:02 <ivanm> which in your case it isn't
00:29:15 * ivanm typically only uses case statements within do blocks
00:29:32 <typoclass> Nereid: how do you mean catamorphism? like maybe for Maybe?
00:29:38 <Nereid> yes
00:30:51 <Nereid> and foldr for [], and either for Either, and
00:30:54 <shachaf> bxx: Something using isNothing is justified.
00:30:56 <Nereid> bool for Bool (if only!)
00:31:03 <shachaf> But you should never ever use fromJust.
00:31:35 * ivanm uses fromJust, but he has good reasons to
00:31:35 <pika> > 1+1
00:31:38 <lambdabot>   2
00:31:49 <pika> > @pl (\x->[x])
00:31:52 <lambdabot>   <hint>:1:1: parse error on input `@'
00:31:57 <pika> > pl (\x->[x])
00:31:59 <lambdabot>   Not in scope: `pl'
00:32:00 <ivanm> @type (:[])
00:32:00 <lambdabot>  Perhaps you meant one of these:
00:32:00 <lambdabot>    `pi' (imported from ...
00:32:01 <ivanm> pika: ^^
00:32:01 <Nereid> just @pl
00:32:01 <lambdabot> a -> [a]
00:32:06 <ivanm> @pl \ x -> [x]
00:32:06 <lambdabot> return
00:32:11 <typoclass> bxx: yeah, you couldn't have known that, but imho it's kinda unfortunate that the fromJust function is in Data.Maybe at all. avoid it.
00:32:11 <Nereid> heh.
00:32:19 <ivanm> pika: but (:[]) is better than return, in case you get your monads mixed up
00:32:56 <bxx> typoclass because it can throw?
00:33:02 <pika> @pl (x y->[x,y])
00:33:02 <lambdabot> (line 1, column 7):
00:33:02 <lambdabot> unexpected '>'
00:33:03 <lambdabot> expecting operator
00:33:05 <ivanm> > fromJust Nothing
00:33:07 <lambdabot>   *Exception: Maybe.fromJust: Nothing
00:33:08 <pika> @pl (\x y->[x,y])
00:33:09 <lambdabot> (. return) . (:)
00:33:20 <typoclass> > (:[]) 42 -- pika: in case that wasn't clear. the mighty robot monkey operator.
00:33:23 <lambdabot>   [42]
00:33:25 <ski> @type fromMaybe (error "foo failed !")  -- is better than `fromJust'
00:33:25 <bxx> yeah I know, but it can't throw in my code
00:33:26 <lambdabot> Maybe a -> a
00:34:02 <ivanm> bxx: in that code sample you just showed, sure
00:34:12 <ivanm> but using a pattern match or maybe is better in that case anyway
00:34:32 * ivanm had some fromJust's he thought were safe, until he found a bug in his code that made values be Nothing
00:34:48 <pika> @pl (\(x,y)->[x,y])
00:34:49 <lambdabot> uncurry ((. return) . (:))
00:34:57 <typoclass> bxx: yeah, well, but every time you use fromJust you have to stop and think if it's safe here :-) so if you write enough code, at some point you'll make a mistake
00:35:19 <typoclass> bxx: it's better to habitually do it in a way that can't go wrong in the first place
00:37:24 <Nereid> @pl (\(x,y) -> cons x (cons y z))
00:37:24 <lambdabot> ap (ap (flip ((.) . cons) . flip cons) fst) snd
00:37:32 * hackagebot cereal-conduit 0.6 - Turn Data.Serialize Gets and Puts into Sources, Sinks, and Conduits  http://hackage.haskell.org/package/cereal-conduit-0.6 (MylesMaxfield)
00:37:33 <Nereid> what, where did z go
00:37:37 <Nereid> @pl \x -> y
00:37:37 <lambdabot> const y
00:37:50 <ivanm> Nereid: yeah, @pl has some weird things like that
00:38:02 <Nereid> @ty ap (ap (flip ((.) . cons) . flip cons) fst) snd
00:38:04 <lambdabot>     Not in scope: `cons'
00:38:04 <lambdabot>     Perhaps you meant one of these:
00:38:04 <lambdabot>       `BS.cons' (imported from Data.ByteString),
00:38:08 <ivanm> pl also loses () (which took me a while to track down when code failed to type check :s)
00:38:10 <Nereid> @ty \cons -> ap (ap (flip ((.) . cons) . flip cons) fst) snd
00:38:11 <lambdabot> (a -> (a, a) -> (a, a)) -> (a, a) -> (a, a)
00:38:27 <Nereid> uhh
00:38:50 <Nereid> what's up with that.
00:39:03 <Nereid> heh
00:44:06 <fmap> @unmtl ContT a m (a, a)
00:44:07 <lambdabot> (a -> a -> m a) -> m a
00:44:41 <fmap> @unmtl ContT a m ((a, a) -> (a, a))
00:44:41 <lambdabot> (((a, a) -> (a, a)) -> m a) -> m a
00:45:18 <fmap> @unmtl ContT ((a, a) -> (a, a)) m a
00:45:19 <lambdabot> (a -> m ((a, a) -> (a, a))) -> m ((a, a) -> (a, a))
00:45:28 <fmap> too early here (
00:49:07 * ski wonders what fmap was pondering
00:50:13 <pika> is there an easy way to convert a list to a list of fixed length windows of that list. that is  for a window of 3  [1,2,3,4,5] -> [[1,2,3],[2,3,4],[3,4,5]]
00:50:49 <ivanm> pika: see the split package for the chunksOf function
00:52:32 * hackagebot ScratchFs 0.1.0.2 - Size limited temp filesystem based on fuse  http://hackage.haskell.org/package/ScratchFs-0.1.0.2 (FalcoHirschenberger)
00:52:55 <Nereid> > map (take 3) . tails $ [1..5] -- not quite
00:52:57 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5],[5],[]]
00:53:37 <typoclass> pika: not that i know of. i've written a helper function "bunch n xs = begin : bunch n end where (begin, end) = splitAt n xs"
00:53:41 <pika> just had a bit of a brain wave
00:53:48 <pika> > (\x-> zip3 x (tail x) (tail $ tail x)) [1,2,3,4,5]
00:53:50 <lambdabot>   [(1,2,3),(2,3,4),(3,4,5)]
00:53:54 <shachaf> Data.List.Split surely has what you want.
00:53:56 <Nereid> ivanm: chunksOf doesn't do it
00:54:00 <shachaf> Data.List.Split has everything.
00:54:09 <ivanm> oh, I see the difference
00:54:26 <shachaf> Oh, maybe what you want is just tails.
00:54:28 <hpaste> jaresim pasted “criterion help” at http://hpaste.org/77641
00:54:31 <shachaf> I was talking about what typoclass wants.
00:54:47 <pika> typoclass: thanks i'll have a look at that
00:54:48 <ivanm> "map (take 3) . tails" to be specific
00:54:52 <typoclass> shachaf: yep, but that's another dependency ...
00:55:12 <typoclass> but yeah i might switch to it one of these days
00:55:20 <ivanm> oh, Nereid already suggested it
00:55:40 <shachaf> typoclass: It's in the Haskell Platform these days.
00:55:54 <ivanm> > reverse . drop 3 . reverse . map (drop 3) . tails $ [1..5]
00:55:57 <lambdabot>   [[4,5],[5],[]]
00:56:05 <simpson> So when will hlint learn of lens?
00:56:08 <ivanm> > reverse . drop 3 . reverse . map (take 3) . tails $ [1..5]
00:56:11 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
00:56:21 <ivanm> simpson: when someone sends Neil patches for it is my guess :p
00:56:26 <Nereid> ivanm: that's expensive though
00:56:27 <edwardk> shortly after you write an extension to it to teach it, i suppose ;)
00:56:32 <typoclass> i kinda wish there was a function like iterate, but for 2-tuples e.g. as produced by splitAt
00:56:33 <ivanm> Nereid: yeah
00:56:35 <Nereid> > reverse . drop 3 . reverse . map (take 3) . tails $ [1..]
00:56:39 <Nereid> too strict
00:56:42 <lambdabot>   mueval: ExitFailure 1
00:56:43 <lambdabot>  mueval: Prelude.undefined
00:56:48 <ChristianS> > filter (\ls -> length ls == 3) . map (take 3) . tails $ [1..5]
00:56:49 <ivanm> Nereid: probably a filter with a smart "atLeastLen" function
00:56:52 <lambdabot>   mueval-core: Time limit exceeded
00:57:10 <ivanm> > filter (not . null . drop (3-1)) . map (take 3) . tails $ [1..]
00:57:12 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
00:57:15 <ivanm> :D
00:57:18 <ivanm> > filter (not . null . drop (3-1)) . map (take 3) . tails $ [1..5]
00:57:20 <Nereid> sure
00:57:21 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
00:57:34 <simpson> And there's still no way to work with Maps or IntMaps, right?
00:57:35 <Nereid> but it would be nice to have a dropLast function or so, that removes from the end
00:57:49 <ivanm> Nereid: how would you implement that though?
00:57:55 <Nereid> that's what I'm pondering right now
00:58:13 <ivanm> one solution: multiple application of init
00:58:17 <typoclass> Nereid: the "O(n)" crowd will harass you
00:58:19 <ChristianS>  > takeWhile (\ls -> length ls == 3) . map (take 3) . tails $ [1..5]
00:58:19 <Nereid> I was just thinking that
00:58:25 <ChristianS> > takeWhile (\ls -> length ls == 3) . map (take 3) . tails $ [1..5]
00:58:27 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
00:58:30 <ivanm> ChristianS: using length isn't really waht you want here
00:59:09 <Nereid> > takeWhile (\case _:_:_:_ -> True; _ -> False) . map (take 3) . tails $ [1..5]
00:59:11 <lambdabot>   <hint>:1:13: parse error on input `case'
00:59:12 <ivanm> @type iterate init !! 3
00:59:13 <Nereid> aw.
00:59:15 <lambdabot>     Couldn't match expected type `[a0]' with actual type `a1 -> [a1]'
00:59:15 <lambdabot>     In the return type of a call of `iterate'
00:59:15 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
00:59:17 <ChristianS> ivanm: because it causes unnecessary list traversals? guess you're right...
00:59:21 <issimus> can anybody explain why my benchmark (http://hpaste.org/77641) isn't correct, how do i prevent computations from being shared? im generating some primes, hashing them, and then doing some searching and testing. i think the primes, and hash table are shared, how would i avoid that, to get an accurate timing?
00:59:31 <ivanm> ChristianS: yeah, see the example I had earlier with not . null . drop (3-1)
00:59:37 <Nereid> > takeWhile (\x -> case x of { _:_:_:_ -> True; _ -> False }) . map (take 3) . tails $ [1..5]
00:59:39 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
00:59:45 <Nereid> can't generalize though
00:59:49 <ivanm> issimus: what's your actual error?
01:00:03 <typoclass> honestly, i'm not convinced by those dozens of variants you guys produced :-) i'd still go with "bunch n xs = begin : bunch n end where (begin, end) = splitAt n xs"
01:00:08 <ivanm> @type iterate
01:00:10 <lambdabot> (a -> a) -> a -> [a]
01:00:19 <ivanm> @type iterate (init .) !! 3
01:00:20 <issimus> ivanm: the benchmark is running too fast, if i time it with a different tool, i get ~800ms, criterion says 24ms
01:00:22 <lambdabot>     Couldn't match expected type `[a0]' with actual type `a1 -> [a1]'
01:00:22 <lambdabot>     In the return type of a call of `iterate'
01:00:22 <lambdabot>     Probable cause: `iterate' is applied to too few arguments
01:00:32 <ivanm> issimus: any particular reason it's in IO?
01:00:39 <ivanm> also, nfIO is probably better than whnfIO
01:01:03 <issimus> ivanm: hashtables are in IO
01:01:12 <ivanm> issimus: why are you using hash tables?
01:01:22 <ivanm> @type iterate init id !! 3
01:01:23 <lambdabot>     Couldn't match expected type `[a0]' with actual type `a1 -> a1'
01:01:24 <lambdabot>     In the second argument of `iterate', namely `id'
01:01:24 <lambdabot>     In the first argument of `(!!)', namely `iterate init id'
01:01:40 <ivanm> dammit... I'm sure I've done this before
01:01:58 <issimus> mostly for learning, i was gonna reimplement with IntSet, which I why I wanted an accurate benchmark
01:02:21 <ivanm> issimus: Hashtables in Haskell are wrong and dodgy
01:02:40 <ivanm> and you haven't said where you're importing it from anyway :)
01:02:59 <issimus> Data.HashTable.IO from hashtables package
01:03:07 <ivanm> oh, that one might be better
01:03:12 <ivanm> still, not sure why you're using that
01:03:18 <ivanm> and I can't work out what you're doing in your code
01:03:49 <ivanm> issimus: anyway, use nfIO rather than whnfIO
01:04:00 <fmap> simpson: there is, see Control.Lens.IndexedLens for example
01:04:07 <simpson> fmap: Yeah, I'm just finding it.
01:04:07 <ivanm> > let windowsOf n = (iterate (init .) id !! n) . map (take n) . inits $ [1..5]
01:04:10 <lambdabot>   not an expression: `let windowsOf n = (iterate (init .) id !! n) . map (tak...
01:04:20 <ivanm> > let windowsOf n = (iterate (init .) id !! n) . map (take n) . inits in windowsOf 3 [1..5]
01:04:22 <lambdabot>   [[],[1],[1,2]]
01:04:37 <ivanm> > let windowsOf n = (iterate (init .) id !! n) . map (take n) . tails in windowsOf 3 [1..5]
01:04:40 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5]]
01:04:42 <ivanm> mwahahaha!
01:05:19 <ion> That’s this strange function ending in “Of” that doesn’t take a lens as a parameter?
01:05:19 <edwardk> > M.fromList [("hello",2)] % at "world" ?~ 3
01:05:22 <lambdabot>   fromList [("hello",2),("world",3)]
01:05:23 <fmap> ski: I'm not sure, similarity of types probably
01:05:31 <edwardk> > M.fromList [("hello",2)] % at "world" .~ Just 3
01:05:34 <lambdabot>   fromList [("hello",2),("world",3)]
01:05:41 <edwardk> > M.fromList [("hello",2)] % at "hello" .~ Nothing
01:05:43 <lambdabot>   fromList []
01:05:53 <issimus> ivanm: hmmm same result, maybe its correct, and the shell timing util is really wrong, thanks for the help
01:05:54 <edwardk> simpson: at works with maps, intmaps and hashmaps
01:06:09 <edwardk> contains works with sets, intsets and hashsets
01:06:11 <ski> > (zipWith const `ap` drop 3) "abcdefgh"  -- Nereid ?
01:06:13 <lambdabot>   "abcde"
01:06:55 <ivanm> issimus: I still think you're doing something wrong for using hashtables
01:07:07 <ski> fmap : why `(a,a) -> (a,a)` ?
01:07:10 <ivanm> how are you timing it yourself?
01:07:27 <sopvop> edwardk: why does  `newtype Stored a = Stored a ; makeIso ''Stored` results in A single-constructor single-argument data type is required
01:07:33 <ivanm> ski: ooohhhhh.....
01:07:47 <shachaf> sopvop: Due to a bug.
01:07:48 <edwardk> sopvop: bug in 3.2. its fixed in HEAD
01:07:57 <ski> ivanm ?
01:08:09 <sopvop> is it on hackage?
01:08:10 <ivanm> ski: your way of dropping from the end
01:08:25 <sopvop> Nope it is not
01:08:27 <edwardk> you can work around it i think with makeLensesWith $ isoRules % handleSingletons .~ True
01:08:35 <fmap> ski: for type to be like in Nereid's example above
01:08:35 <ski> ivanm : actually, someone else in here (i forget who) came up with it
01:08:38 <issimus> ivanm: wrong? as in not haskell-y, or wrong as in logic error, because the code returns the correct result. i'm timing it using powershell Measure-Command
01:08:38 <edwardk> sopvop: not yet
01:08:49 <edwardk> we'll probably push out 3.3 in a day or two
01:09:02 <ivanm> issimus: not Haskelly, and I don't see the point in using a Hashtable when your keys are Ints
01:09:22 <ivanm> issimus: as for timing: I assume you're compiling?
01:09:47 <simpson> edwardk: I kind of want to map over Maps, but I figure that maybe I should just use a combinator from Data.Map for this.
01:10:14 <edwardk> simpson: you can use mapped or itraverse, etc. all of them work with Map
01:10:28 <issimus> ivanm: yeah i'm abusing the hashtable, for constant lookups since the values are just (), which i was going to compare to a set implementation next. yes i'm compiling
01:10:43 <edwardk> and mapped for Map is efficient, it calls fmap, which is defined in Map to use Map.map ;)
01:10:53 <edwardk> thats a tongue twister =P
01:11:10 <shachaf> If you're lucky, "over mapped" will even compile directly to Map.map!
01:11:14 <simpson> edwardk: Well, I have an IntMap MyType, and I want to do (Maybe MyType -> Maybe MyType) -> IntMap MyType -> IntMap MyType
01:11:29 <simpson> So maybe I should just use the correct thing from Data.Map.
01:11:32 <ivanm> if you want O(1) lookups, use a Vector or something...
01:11:36 <edwardk> two Maybes?
01:11:45 <edwardk> where does it magic up the mytypes from?
01:12:06 <simpson> There's some extra stuff curried in.
01:12:08 <edwardk> or did you just mean the second aybe?
01:12:22 <edwardk> :t M.adjust
01:12:24 <lambdabot> Ord k => (a -> a) -> k -> M.Map k a -> M.Map k a
01:12:25 <edwardk> :t M.update
01:12:27 <lambdabot> Ord k => (a -> Maybe a) -> k -> M.Map k a -> M.Map k a
01:13:05 <simpson> Ah, the updater is allowed to create something from nothing.
01:13:42 <simpson> Int -> Maybe MyType -> Maybe Mytype -- and it's curried with an initial Int.
01:14:03 <edwardk> yeah go with the one-off combinators, thats a mess
01:15:23 <shachaf> @ty M.alter
01:15:25 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
01:16:55 <issimus> ivanm: vector is no good, i'm not interested in mapping indexes to values, my keys are prime numbers, not contiguous integers
01:17:03 <ivanm> oh, right
01:20:25 <Nereid> so if I use view patterns like
01:20:40 <Nereid> f (view -> False) = ...; f (view -> True) = ...
01:20:51 <Nereid> won't the result of view get computed twice (in the worst case)?
01:21:02 <ivanm> hmmm, not sure
01:21:17 <ivanm> probably depends upon how view patterns are implemented in GHC
01:21:27 <Nereid> I guess there's Debug.Trace to tell :p
01:21:32 <ivanm> heh, yeah
01:22:10 <ivanm> of course, when using it for Bool's you can just convert it into an if-statement or something... ;-)
01:22:32 <Nereid> it was just an example :p
01:23:21 <fmap> Nereid: you can probably check Core it compiles to
01:24:09 <Nereid> blah, then I'd have to figure out core. :p
01:24:18 <Nereid> anyway, trace tells me it only gets computed once?
01:25:06 <ivanm> *shrug*
01:25:13 <ivanm> ghc-core is maintained again though... ;-)
01:25:18 <Nereid> :)
01:25:20 <Nereid> I'm installing it now.
01:25:32 <shachaf> I'm done with ghc-core, man.
01:25:40 <Nereid> haha
01:25:51 <shachaf> It's ivanm's job now.
01:25:56 <edwardk> once
01:25:58 * ivanm passes
01:26:03 <ski> Nereid : you saw the `dropLast' above ?
01:26:04 <shachaf> Actually there are a few things I might add later.
01:26:23 <ivanm> the most I've had to do with ghc-core was try and install it years ago, and bitch at dons for having "base < 5" dep when it didn't even build with base-4
01:26:28 <edwardk> it should factor those out like any repeated pattern
01:26:35 <ivanm> (as cabal-install at the time defaulted to base-3 on 6.10, so he never tested it with base-4)
01:26:48 <Nereid> ski: I did now. cute :D
01:26:54 * Nereid thinks about how it works
01:27:14 <shachaf> Where?
01:27:15 <shachaf> Is it
01:27:17 <shachaf> @where sneaky
01:27:18 <lambdabot> dropFromEnd n xs = zipWith const xs (drop n xs)
01:27:22 <Nereid> ahh I see.
01:27:23 <edwardk> that said, that means it may recompute if you have foo (v -> a) (v -> b) = …; foo [] (v -> b) = … foo (v -> a) [] = …; foo [] [] = …
01:27:25 <ski> yes, that
01:27:39 <ski> shachaf : do you know who invented it ?
01:27:45 <ivanm> why is that under "sneaky"? :/
01:27:51 <shachaf> ivanm: Because it's sneaky.
01:28:08 <shachaf> rwbarton mentioned it in here before, but I don't know where it's originally from.
01:28:11 <ski> @where+ dropFromEnd see `sneaky'
01:28:12 <lambdabot> I will never forget.
01:28:12 <shachaf> Maybe he does.
01:28:13 <edwardk> hah thats good
01:28:40 <shachaf> Just another piece of #haskell lore.
01:28:41 <ski> @ask rwbarton do you know who invented the trick under `@where sneaky' ?
01:28:41 <lambdabot> Consider it noted.
01:28:54 <shachaf> @where sneaky2
01:28:55 <lambdabot> lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
01:29:27 <Nereid> > (\xs -> zipWith const xs (drop 5 xs)) [1..]
01:29:29 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
01:29:39 <Nereid> > (\xs -> zipWith const xs (drop 10000000 xs)) [1..]
01:29:40 <ivanm> how is that any lazier? :/
01:29:43 <ivanm> @where sneaky3
01:29:46 <lambdabot> I know nothing about sneaky3.
01:29:46 <lambdabot>   mueval: Prelude.undefined
01:29:58 <Nereid> eh, no surprise I guesse.
01:30:00 <Nereid> -e
01:30:03 <shachaf> ivanm: lazyReverse (repeat ()) = repeat undefined
01:30:13 <ivanm> hmmmmmm
01:30:21 <shachaf> I.e. it gives you the spine of the list immediately, before it finishes traversing it.
01:30:27 <Nereid> interesting.
01:30:33 <ivanm> because it determines when there _should_ be a value, even if it doesn't know what it is?
01:30:35 <shachaf> But it has to traverse it (up to a certain point) if you ask for any of the values.
01:30:49 <shachaf> Right. Because if it saw N conses from the beginning, it knows the result will have at least length N
01:31:01 <ivanm> well, if you want any values don't you have to traverse the entire thing?
01:31:15 <ski> yes
01:31:32 <shachaf> Well, if you want the *first* value you have to traverse the entire thing.
01:31:40 <ivanm> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in null $ lazyReverse (1:2:3:undefined)
01:31:44 <lambdabot>   False
01:31:51 <ivanm> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in lazyReverse (1:2:3:undefined)
01:31:53 <lambdabot>   [*Exception: Prelude.undefined
01:32:06 <ski> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in length (take 2 (lazyReverse (0:1:undefined)))
01:32:08 <lambdabot>   2
01:32:13 <ivanm> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in lazyReverse $ lazyReverse (1:2:3:undefined)
01:32:15 <lambdabot>   [*Exception: Prelude.undefined
01:32:23 <ski> > let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = [] in map (const ()) (lazyReverse (0:1:undefined))
01:32:25 <lambdabot>   [(),()*Exception: Prelude.undefined
01:32:26 <ivanm> yeah, didn't think it would like that
01:33:14 <Nereid> @ let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
01:33:19 <Nereid> @let lazyReverse xs = go xs (reverse xs) where go (_:xs) ~(y:ys) = y : go xs ys; go [] ~[] = []
01:33:23 <lambdabot>  Defined.
01:33:58 <Nereid> hmm.
01:34:09 <Nereid> shachaf: wouldn't you have to traverse the entire thing to get any values?
01:35:16 <shachaf> Nereid: Oh, that's true.
01:35:24 <shachaf> Since you need to know the length.
01:35:26 <shachaf> Ignore my silliness.
01:43:05 <Nereid> ah, so it factors stuff like
01:43:16 <Nereid> foo p q = ...; foo p q' = ...
01:43:17 <Nereid> into
01:43:28 <Nereid> foo p x = case x of q -> ...; q' -> ...
01:43:29 <Nereid> ?
01:43:38 <Nereid> or something.
01:43:41 <Nereid> what am I saying.
01:44:02 <shachaf> Who?
01:44:05 <Nereid> this has nothing to do with view patterns.
01:44:25 <Nereid> I'm wondering why f (v -> False) = ...; f (v -> True) = ... only computes v once.
01:44:31 <shachaf> Nereid: Exercise: Write takeFromEnd in a nice way.
01:44:44 <Nereid> what defines "nice"?
01:44:47 <shachaf> Nereid: Ah. I think it's specified to.
01:44:52 <shachaf> Nereid: Your sense of niceness.
01:45:18 <Nereid> hmm
01:45:19 <mapf_> Nereid: why view pattern should compute it twice?
01:45:28 <Nereid> I'm not saiyng it should.
01:45:45 <shachaf> mapf_: The naïve implementation presumably would, since it would apply the function each time.
01:45:51 <Nereid> this.
01:46:10 <shachaf> But I think it's specified in some manual somewhere that it'll only do it once.
01:46:19 <Nereid> but it becomes
01:46:29 <shachaf> Not that this has anything to do with the semantics of Haskell. :-)
01:46:30 <Nereid> f x = case v x of False -> ...; True -> ...
01:46:48 <Nereid> hmm
01:46:50 <shachaf> What about more complicated cases?
01:46:53 <Nereid> yeah.
01:46:55 <Nereid> I don't know.
01:47:24 <shachaf> f True (v -> False) = ...; f True (v -> True) = ...; f False (v -> False) = ...; f False (v -> True) = ...
01:47:58 <mapf_> though each time i tried to use view pattern in my code code i find them pretty useless and boilerblatish
01:48:08 * shachaf likes view patterns.
01:48:16 <shachaf> I don't like them as much as I'd like to like them.
01:48:22 <shachaf> But I don't know what a good alternative would be.
01:48:22 <Nereid> I used them for the first time today.
01:48:29 <shachaf> Maybe the special-case Maybe patterns would be nice.
01:48:32 <Nereid> f ((`divMod` 2) -> (q,r)) = ...
01:48:37 <shachaf> On the other hand maybe not.
01:48:42 <shachaf> Nereid: You can often use pattern guards instead.
01:48:47 <Nereid> hmm.
01:48:47 <quicksilver> beause it's very very common to repeat the 'view' over multiple cases
01:48:53 <mapf_> shachaf: you mean monadish guards?
01:48:57 <quicksilver> in fact, that's pretty much the main use of them
01:48:58 <Nereid> f x | (q,r) <- x `divMod` 2 = ...
01:49:02 <tdammers> anyone have any experience with haskell on freebsd?
01:49:03 <Nereid> hmm
01:49:05 <shachaf> No, I mean what Nereid said.
01:49:11 <quicksilver> I expect they specifically told it to lift the views out (and only compute them once)
01:49:14 <Nereid> but then I have to name x.
01:49:20 <shachaf> Yep.
01:49:32 * shachaf thinks (`divMod` 2) is a bit of an abuse of view patterns.
01:49:35 <shachaf> But if it works for you. :-)
01:49:50 <Nereid> oh but I have more guards on the right of that.
01:49:59 <mapf_> shachaf: oh, i too slow
01:50:00 <Nereid> depending on the value of r.
01:50:02 <quicksilver> I'm vaguely uncomfortable with the notion of "computation on the left"
01:50:10 <quicksilver> (left of the = or | in an equation)
01:50:18 <quicksilver> but it is handy sometimes
01:50:50 <shachaf> Hmm, lens view patterns might be nice.
01:51:04 <shachaf> foo (view (blah.blam) -> ...) = ...
01:51:16 <shachaf> They *are* called "view" patterns, after all.
01:52:09 <hpaste> Nereid pasted “view patterns” at http://hpaste.org/77643
01:52:11 <Nereid> this is where I used it
01:52:18 <Nereid> just as an example say
01:52:22 <Nereid> oops
01:52:25 <ski> @google view from the left mcbride
01:52:27 <Nereid> that's not it.
01:52:27 <lambdabot> http://strictlypositive.org/view.ps.gz
01:52:41 <hpaste> Nereid annotated “view patterns” with “I meant this” at http://hpaste.org/77643#a77644
01:52:52 <johnw> shachaf: that would be pretty sweet
01:52:59 <shachaf> What would be?
01:53:01 <Nereid> the top one is obviously not going to work.
01:53:09 <johnw> foo (view (blah.balm) -> ...) = ...
01:53:16 <shachaf> johnw: That works.
01:53:23 <shachaf> {-# LANGUAGE ViewPatterns #-} -- done
01:53:54 <Nereid> so how would I rewrite that with pattern guards?
01:53:56 <johnw> hold on, i've gotta try this
01:54:03 <Nereid> without writing the divMod stuff twice?
01:55:33 <Nereid> (also I don't see why that should be an "abuse" of view patterns?)
01:57:34 * hackagebot hsparql 0.2.2 - A SPARQL query generator and DSL, and a client to query a SPARQL server.  http://hackage.haskell.org/package/hsparql-0.2.2 (RobStewart)
01:57:47 <hpaste> johnw pasted “views.hs” at http://hpaste.org/77645
01:57:57 <johnw> shachaf: I'm getting No instance for (Field2 (a, b) (a, b0) Foo b0)
01:58:20 <Nereid> well yes
01:58:24 <Nereid> foo :: (a,Foo) -> ...
01:58:32 <johnw> ah, sure
01:58:38 <johnw> how can it pattern match against a generic type...
01:58:41 <Nereid> :P
01:59:25 <Nereid> actually, broader question
01:59:36 <atriq> To get roughly what you want, I'd use Data.Typeable
01:59:39 <johnw> wow, it works
01:59:43 <johnw> color me blown away
01:59:45 <Nereid> is there a nicer way to write takeBits generally?
01:59:54 <Nereid> (view patterns or otherwise)
02:00:51 <shachaf> What's takeBits?
02:00:55 <Nereid> http://hpaste.org/77644
02:01:11 <Nereid> I couldn't think of a better name.
02:01:28 <johnw> why is that not general enough?
02:01:36 <johnw> oh, that's not what you mean by generally
02:01:40 <Nereid> no, I don't mean that
02:01:40 <Nereid> :p
02:01:52 <Nereid> I mean general improvements.
02:02:33 <shachaf> Nereid: How about foo :: Integral a => a -> [Bool]
02:02:37 <shachaf> And then zip and filter?
02:02:41 <manju>  BS.words $ xs
02:02:41 <shachaf> Or something like that.
02:02:45 <johnw> you can use viewpatterns to deconstruct the results of a computation?  that's amazing.  How come these aren't used more often?
02:02:49 <manju> sorry wrong window
02:02:55 <Nereid> shachaf: hmm
02:03:30 <shachaf> johnw: I use them sometimes.
02:03:46 <shachaf> View patterns are pretty simple -- they just apply a function and let you match on the result.
02:03:59 <johnw> i'd heard of them, but i thought it was just an idea
02:04:10 <johnw> but they sound very useful
02:05:21 <johnw> i've already worked around there absence on a couple of occasions, with let bindings and local functions
02:06:14 <ski> @type catMaybes .:: zipWith
02:06:16 <lambdabot> (a1 -> b -> Maybe a) -> [a1] -> [b] -> [a]
02:06:47 <hpaste> Nereid pasted “what I was using takeBits for” at http://hpaste.org/77646
02:07:04 <Nereid> I keep implementing pow over and over again.
02:07:07 <Nereid> in different ways.
02:09:13 <johnw> shachaf: i always wonder about using features like view patterns
02:09:43 <atriq> :t \a -> lens ($ a) (\f b a' -> if a == a' then b else f a')
02:09:45 <lambdabot> (Eq a, Functor f) => a -> (b -> f b) -> (a -> b) -> f (a -> b)
02:10:03 <johnw> the fact that this is a GHC extension and not in the 2010 report, that means it could change at all, disappear entirely, or somebody become part of the next published report...
02:10:13 <johnw> maybe I'm just too used to living in a standardized world
02:10:24 <shachaf> View patterns are probably among the more stable GHC extensions?
02:10:26 <shachaf> I don't know.
02:10:29 <shachaf> I guess they're pretty recent.
02:10:34 <Nereid> when were they introduced?
02:10:42 <shachaf> I wouldn't be too worried about using them.
02:10:48 <opqdonut> yeah they should be fine
02:11:36 <shachaf> In the worst case they'd be deprecated and you'd get a few releases of GHC where they cause "this will go away" warnings.
02:11:45 <shachaf> And it's a pretty mechanical process to get rid of them.
02:11:57 <shachaf> But they probably won't be barring some pretty major reason for the change.
02:12:15 <johnw> it's so cool you can apply the view pattern to substructures of a pattern match: bar (Just ((+1) -> 2)) = print "It's a 1"
02:12:35 <johnw> this is my new favorite feature this week
02:13:20 <Nereid> LambdaCase is also in
02:13:43 <johnw> with these you can implement n+k patterns
02:13:54 <johnw> ((+k) -> n)
02:14:06 <Nereid> not quite, (subtract k) -> n
02:14:08 * shachaf doesn't like LambdaCase.
02:14:12 <johnw> oh yeah
02:14:14 <johnw> shachaf: hush!
02:15:01 <shachaf> > case 1 of (\x -> x -> x) -> x
02:15:03 <lambdabot>   1
02:15:16 <Nereid> what
02:15:25 <Ralith> view pattern!
02:15:31 <Nereid> oh
02:15:33 <Ralith> ^^
02:15:33 <Nereid> haha
02:15:40 <shachaf> johnw: You don't want to encourage code like that, do you?
02:15:50 <johnw> i would have thought parens would be required
02:16:00 <johnw> > case 1 of (\(x -> x) -> x) -> x
02:16:03 <lambdabot>   <hint>:1:12: Parse error in pattern: \ (x -> x) -> x
02:16:07 --- mode: asimov.freenode.net set +o ChanServ
02:16:10 <Nereid> > (\case {False -> 0; True -> 1}) False
02:16:12 <lambdabot>   <hint>:1:3: parse error on input `case'
02:16:14 <Nereid> aw.
02:16:24 <johnw> I don't think lambdabot runs on 7.6
02:16:43 <shachaf> Correct.
02:17:49 <shachaf> > let f (view both -> []) = "empty"; f (view both -> xs) = "blah " ++ show (length xs) in [f ("",""), f ("hi",""), f ("","there"), f ("hi","there")]
02:17:52 <lambdabot>   ["empty","blah 2","blah 5","blah 7"]
02:18:09 <shachaf> view both = uncurry mappend, I guess.
02:18:10 <johnw> heh: map f (x : map f -> xs) = f x : xs
02:18:23 <Nereid> view both is shorter though
02:18:24 <johnw> that's kind of cute, but getting into too cute territory
02:18:35 <Nereid> and the meaning is a bit more obvious?
02:18:41 <shachaf> johnw: Where they're really useful is for actual abstract views of data types.
02:18:45 <shachaf> As in viewl and all that.
02:18:49 <Nereid> johnw: that is uh
02:18:51 <Nereid> oh dear
02:19:05 <Nereid> (I'd rename xs to ys though)
02:19:20 <Nereid> biut yes, too cute.
02:19:27 <Nereid> fat fingers.
02:19:32 <shachaf> I'd call it allTheRestOfTheElementsAfterYou'veMapped'f'overThem
02:19:53 <johnw> shachaf is a closet Java programmer
02:20:10 <shachaf> Today I introduced (\oldVal -> state (unconsWithDefault oldVal)) into an edwardk codebase.
02:20:16 <shachaf> Instead of (state . unconsWithDefault)
02:20:29 <shachaf> Maybe he'll take away my commit bit for that.
02:20:48 <Nereid> I don't understand this strictness business.
02:20:54 <Nereid> with what you're doing.
02:22:19 --- mode: asimov.freenode.net set +o Igloo
02:22:20 --- mode: asimov.freenode.net set +o ChanServ
02:22:20 <johnw> shachaf: what's an example of using viewl?  do you mean viewl from Data.Sequence?
02:22:55 <shachaf> Yes.
02:23:05 <shachaf> > Seq.singleton 5
02:23:07 <lambdabot>   fromList [5]
02:24:21 <shachaf> > let f (viewl -> EmptyL) = "empty"; f (viewl -> x Seq.:< xs) = show x ++ " " ++ show xs in [f (Seq.fromList [1,2,3,4]), f Seq.empty]
02:24:23 <lambdabot>   Not in scope: `viewl'
02:24:24 <lambdabot>  Perhaps you meant one of these:
02:24:24 <lambdabot>    `Seq.viewl' (impo...
02:24:42 <shachaf> > let f (Seq.viewl -> Seq.EmptyL) = "empty"; f (Seq.viewl -> x Seq.:< xs) = show x ++ " " ++ show xs in [f (Seq.fromList [1,2,3,4]), f Seq.empty]
02:24:44 <lambdabot>   ["1 fromList [2,3,4]","empty"]
02:24:51 <Nereid> mhm
02:27:39 --- mode: asimov.freenode.net set +o Igloo
02:27:39 --- mode: asimov.freenode.net set +o ChanServ
02:27:40 <Nereid> sure is netsplit around here.
02:28:14 <Nereid> > let takeFromEnd n xs = go (drop n xs) xs where go [] ys = ys; go (_:xs) (_:ys) = go xs ys in takeFromEnd 3 [1..20]
02:28:16 <lambdabot>   [18,19,20]
02:29:01 <Nereid> I can't think of anything nicer than that.
02:29:17 <Nereid> oh shachaf was lost in the netsplit too.
02:29:32 <Nereid> > let takeFromEnd n xs = go (drop n xs) xs where go [] ys = ys; go (_:xs) (_:ys) = go xs ys in takeFromEnd 3 [1..20]
02:29:34 <lambdabot>   [18,19,20]
02:29:43 <Nereid> I should go to bed.
02:29:48 <shachaf> hi Nereid
02:29:59 <Nereid> I missed you.
02:31:01 <shachaf> I think rwbarton brought up a zipWith analogue that let you write takeFromEnd nicely once?
02:31:44 <espringe> How would I do this:
02:31:44 <espringe> class FixedArray a =
02:31:44 <espringe>     arrayLength :: Integer      -- note how this doesn't use 'a'
02:31:55 <shachaf> You wouldn't.
02:32:01 <espringe> There's no way to do that?
02:32:06 <atriq> Docs for Control.Lens.Setter are wrong
02:32:06 <Nereid> if you *really* want to,
02:32:12 <Nereid> data Proxy = Proxy a
02:32:19 <Nereid> class FixedArray a where arrayLength :: Proxy a -> Integer
02:32:22 <Nereid> er
02:32:22 <espringe> And somewould would have to call it, like:  (arrayLength::MyType) or something
02:32:24 <Nereid> data Proxy a = Proxy
02:32:26 <shachaf> atriq: ?
02:32:34 <Nereid> arrayLength (Proxy :: Proxy MyType)
02:32:35 <atriq> It claims "set l y (set l x a) ≡ set l x a", when actually "set l y (set l x a) ≡ set l y a"
02:32:47 <shachaf> atriq: Good point!
02:32:50 <shachaf> I bet that's my fault.
02:32:56 <atriq> :)
02:33:09 <atriq> Control.Lens.Type is right about that
02:34:07 <shachaf> atriq: Fixed. Thanks!
02:34:13 <atriq> NO problem
02:34:35 <johnw> i kind of don't see how "case" instead of "x -> case x of" is enough of a savings to get excited about
02:34:48 <Nereid> saves you from having to name something
02:34:49 * shachaf likes the *idea* of \case
02:34:52 <shachaf> Just not the syntax.
02:34:55 <johnw> i mean, it's not giving me any additional functionality, it's just saving some keystrokes
02:34:58 <Nereid> what syntax would you like?
02:35:02 <shachaf> I don't know. :-(
02:35:03 <Nereid> johnw: you could argue that view patterns do the same
02:35:15 <shachaf> johnw: Not having to name things is a big thing.
02:35:16 <johnw> in that case it's a lot more keystrokes
02:35:21 <shachaf> You can only keep a few names in your head at a time.
02:35:24 <johnw> ok, the not naming thing makes sense
02:35:33 <johnw> i sometimes have x, x' x'' and x''' in a function :)
02:35:34 <shachaf> (At least, I can.)
02:35:51 <johnw> (mainly to separate generations of x in a do block)
02:35:55 <Nereid> although in \x -> case x of ..., the x only appears twice, and always in the same place
02:36:04 * Ralith liked Cale's proposed syntax
02:36:12 <johnw> shachaf: how would you write LambdaCase?
02:36:18 <yitz> Nereid: i call your go "takeLike". i use it all the time.
02:36:19 <Nereid> Ralith: what was it?
02:36:32 <ion> case of { … }
02:36:37 <yitz> Nereid: oh. no. at the head though.
02:36:51 <Nereid> yitz: sure, and then it's zipWith const
02:37:16 <Nereid> ion: that makes it highly non-obvious that you're creating a function
02:37:18 <Nereid> imo
02:37:43 <yitz> zipWith (flip const)
02:38:13 <Nereid> yitz: almost the same thing :p
02:38:29 <ski> SML has `fn NONE => ... | SOME a => ..a..', OCaml has `function None -> ... | Some a -> ..a..'
02:38:51 <atriq> What I would like is data Foo f a = Foo a | Bar (f (Foo  f a)) deriving ((Show a, Show (f (Foo f a))) => Show)
02:39:01 <Peaker> Haskell has:   looooongName Nothing = ..    looooooongName (Just x) = ...
02:39:07 <yitz> so dropLike. and i use that all the time too.
02:39:14 <shachaf> atriq: You can use standalone deriving for that.
02:39:20 <atriq> You can!?
02:39:22 <atriq> Wow!
02:39:44 <shachaf> atriq: (Foo = Free)
02:40:01 <Peaker> JohnBat26, if you have so many x''s just use StateT?
02:40:17 <Nereid> johnw: ^
02:40:33 <atriq> shachaf, that was just the first example I could think of
02:41:28 <atriq> Loosely based on me writing brainfuck interpreters when I'm bored
02:41:46 <atriq> (the f was meant to be foldable, I believe)
02:42:34 <shachaf> atriq: That type is called Free.
02:42:42 <johnw> Peaker: they could all just be x and not lose any meaning, but I get warnings about shadowed variables and I think it makes the data flow harder to follow
02:42:43 <Peaker> xchat really sucks :(  is there a nice GUI IRC client?
02:42:50 <atriq> I know, I've messed with Free a lot in the past
02:42:54 <Nereid> Peaker: I use kvirc
02:42:55 <shachaf> f is usually Functor, but anyway.
02:43:30 <Peaker> Nereid, does it have sane name completions that considers recency of messages/etc?
02:43:31 <johnw> has anyone written an article on type-level programming in GHC 7.6?  All the stuff I've found so far is pretty tortuous since it lacks DataKinds
02:43:36 <Nereid> nope
02:43:39 <Peaker> doh
02:43:40 <Nereid> at least, not that I know of
02:43:49 <Nereid> would be nice
02:43:49 <Peaker> johnw, shadowing is a big source of bugs IME, I like that awrning
02:43:54 <Nereid> irssi seems to be doing it
02:44:09 <johnw> Peaker: yeah, that's why I don't turn it off or ignore it :)
02:44:15 <atriq> type Maybe = Free Proxy, type Identity = Cofree Proxy, type NonEmpty = Cofree Maybe, type List = Compose Maybe List
02:44:16 <Peaker> I think xchat has some configuration that makes it sane, but it is of course insane by default, which is a common OSS default
02:44:25 <johnw> I like the immutability of 'x' to be represented by the immutability of x in my source code
02:44:42 <Peaker> johnw, so why not StateT? it's exactly an abstraction of the x/x'/x'' pattern
02:44:44 <Nereid> atriq: the last one is not like the others
02:44:59 <Peaker> johnw, and does the shadowing you want by default, and expresses the intent, etc.
02:45:08 <johnw> Peaker: in the cases where I do this kind of thing (and it's not too often), StateT would be a bit overkill
02:45:36 <Peaker> johnw, (`runStateT` init) $ do ...          and a few "lift"s is not that much kill :)
02:45:54 <johnw> i hate lift more than I hate '
02:46:00 <Cale> StateT is overused, imo.
02:46:06 <atriq> * type List = Compose Maybe Nonempty
02:46:22 <Peaker> Cale, why?
02:46:32 <Nereid> atriq: ok :)
02:46:44 <atriq> Thinko
02:46:50 <Peaker> johnw, what monad are you typically abstracting over? IO I presume?  Could use the lifted-base operations maybe
02:46:57 <Ralith> Cale: why do you say that?
02:47:02 <johnw> yeah, it's usually IO
02:47:07 <Cale> Peaker: Well, mainly because it's used over things like IO which already have lots of facilities for state.
02:47:26 <Ralith> oh, that does seem silly
02:48:02 <Nereid> johnw: what about chaining thigns with >=> ?
02:48:20 <Cale> and the reason is that people don't want to explicitly pass a parameter, and instead, they end up explicitly lifting all their IO actions
02:48:24 <Peaker> Cale, I don't think I have much StateT over IO in practice.. mostly around other monads
02:48:25 <johnw> Nereid: I do that too
02:48:42 <johnw> i rather like >=> and <=<
02:48:47 <Cale> StateT over list or some other nondeterminism monad is fine
02:48:48 <Nereid> x' <- f x; x'' <- g x'; x''' <- h x''
02:48:54 <Nereid> could be replaced with
02:48:57 <Peaker> Cale, it is nice to avoid explicit params, also to see more information in type
02:49:05 <Nereid> yeah well you get it
02:49:06 <johnw> Nereid: oh, it's never as simple as that
02:49:08 <Nereid> :p
02:49:20 <Nereid> yeah, I guess if you stick things in between
02:49:21 <Peaker> Cale, I use a lot of restricted-IO monads -- so StateT over those is nice
02:50:51 <atriq> Okay, I'm worried
02:51:05 <atriq> I stopped half-way through writing a function because I couldn't work out what I wanted to do
02:51:10 <atriq> And forgot aboutit
02:51:16 <atriq> And it type-checks
02:51:57 <Cale> Peaker: Well, if I'm working in IO anyway, I would much rather have function parameters telling me where things are going. I've found through experience that it's often much nicer to pass around the read and write ends of an IORef as parameters than doing some half-baked monad transformer stuff. I think monad transformers are something you ought to use to save a little time when you wouldn't really mind hand-coding a monad for your library, and hiding the imple
02:51:57 <Cale> mentation from your users.
02:52:35 <Cale> i.e. newtype and wrap all the appropriate functionality to the point where you don't need to be lifting things
02:52:43 <Peaker> Cale, I use one-off monad transformers all over the place...
02:53:08 <Peaker> I guess it's a matter of style
02:53:13 <Cale> yeah
02:53:57 <Peaker> If I can have roughly the same amount of code in two forms -- but one has a larger percentage of real code, and the other a larger percentage of boilerplate, I'd prefer the latter
02:54:16 <Sonderblade> on Windows, i'm getting a getAddrInfo: does not exist (error 10093) error from Network.HTTP.Conduit.simpleHttp
02:54:43 <quicksilver> Cale: having a custom monad is nice when you start thinking in terms of a DSL of high level operations (which might be implemented behind the scenes with IORefs or a StateT or they might be done some other way)
02:55:07 <quicksilver> Cale: in other words - it's a possible abstraction choice, to abstract away the specfic choice/manner of parameter passing.
02:55:09 <atriq> It doesn't do what I want, which is somewhat relieving
02:55:10 <Cale> quicksilver: Right -- but that's not quite what I'm talking about
02:55:37 <atriq> @hoogle (a -> m b) -> m a
02:55:39 <lambdabot> Control.Monad.Fix mfix :: MonadFix m => (a -> m a) -> m a
02:55:39 <lambdabot> System.IO fixIO :: (a -> IO a) -> IO a
02:55:39 <lambdabot> Control.Monad.Trans.Cont runContT :: ContT r m a -> (a -> m r) -> m r
02:55:49 <Cale> The thing which annoys me is where the use of StateT is showing.
02:55:55 <atriq> @hoogle (a -> m b) -> a -> m a
02:55:56 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
02:55:56 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
02:55:56 <lambdabot> Data.Foldable traverse_ :: (Foldable t, Applicative f) => (a -> f b) -> t a -> f ()
02:56:07 <Nereid> atriq: what are you looking for?
02:56:17 <atriq> Execute the action and return the input
02:56:20 <Cale> If you've done a good enough job of abstracting things that I can't tell you've used StateT, then I don't care whether you've used it or not :)
02:56:51 <Nereid> atriq: well you need some a first of all, then
02:57:11 <atriq> :t \f a -> do {f a >> return a}
02:57:12 <Nereid> @ty \f x -> f x >> return x
02:57:13 <lambdabot> Monad m => (b -> m a) -> b -> m b
02:57:14 <Cale> One thing which is nice about passing around  readIORef r :: IO a  and  writeIORef r :: a -> IO ()  (possibly bundled into some data structures, if you have a bunch of such configuration), is that the semantics of communication via this channel can be configured from the top level of the program.
02:57:14 <lambdabot> Monad m => (b -> m a) -> b -> m b
02:57:25 <atriq> @pl \f a -> f a >> return a
02:57:26 <lambdabot> (`ap` return) . ((>>) .)
02:57:35 <atriq> @pl \f a -> f a *> pure a
02:57:36 <lambdabot> (`ap` pure) . ((*>) .)
02:57:46 <atriq> @pl \a -> f a *> pure a
02:57:47 <lambdabot> liftM2 (*>) f pure
02:58:40 <Nereid> @ty \f -> liftM snd . liftM2 (,) . (f &&& return)
02:58:41 <lambdabot> (Monad m, Monad ((,) a)) => (b -> a) -> b -> (a, a2) -> (m b, a2)
02:58:44 <Nereid> oops
02:58:58 <atriq> Yes, that works
02:59:03 <Cale> You can replace this with a Chan or SampleVar or various things built on STM and get different blocking semantics, and you can do things like logging the changes and so on very easily, without affecting the client code at all.
02:59:06 <Nereid> it clearly doesn't.
02:59:07 <Nereid> :p
02:59:08 <atriq> liftA2 (*>) f pure
02:59:18 <Nereid> but use >> and return
02:59:22 <Cale> and you also get a nice way of controlling which parts of the code have permission to read or write
02:59:58 <atriq> Nereid, I'd rather use the least powerful thing, because it works for Applicatives as well as Monads
03:00:07 <atriq> :t \f -> liftA2 (*>) f pure
03:00:09 <lambdabot> Applicative f => (b -> f a) -> b -> f b
03:00:35 <Nereid> if only all Monads were necessarily Applicatives
03:00:44 <atriq> The one I'm using is
03:00:51 <espringe> What I want to do, is write a function that takes a type -- and return a Integer. Kind of like how the mempty of + is a 0, and the mempty of * is 1. Here's my attempt, which fails really badly:
03:00:52 <espringe> http://hpaste.org/77647
03:00:59 <Nereid> ah, well if you're using a specific one then it doesn't matter.
03:01:02 <atriq> And if you find a Monad that isn't an Applicative, complain
03:01:44 <Nereid> of course I'd complain :p
03:02:03 <Nereid> espringe: Proxy q makes no sense.
03:02:05 <Nereid> (Proxy :: Proxy q) does.
03:02:07 <atriq> For instance, Data.Sequence.Seq
03:02:12 <shachaf> liftA2 (*>) f pure === pure?
03:02:21 <Nereid> no
03:02:25 <shachaf> Er, not pure.
03:02:26 <atriq> shachaf, no, because it executes f first
03:02:33 <espringe> Nereid: where does (Proxy :: Proxy q) make sense ?
03:02:35 * hackagebot yesod-core 1.1.4.2 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.4.2 (MichaelSnoyman)
03:02:36 <espringe> where should i put it
03:02:38 <Nereid> espringe: last line
03:02:39 <shachaf> Ah, I see.
03:02:44 <Nereid> where you have Proxy q
03:02:46 <shachaf> I was just looking at the effects.
03:02:49 <shachaf> Too much lens.
03:02:53 <johnw> lol
03:03:16 <Nereid> espringe: Proxy q makes no sense because q isn't a value and the Proxy constructor takes no argument.
03:03:16 <atriq> > map (liftA2 (*>) (\x -> if x == 0 then Nothing else Just ()) pure) [0, 1]
03:03:18 <lambdabot>   [Nothing,Just 1]
03:03:48 <mentus> hello everybody
03:03:55 <atriq> Hello, mentus
03:04:30 <espringe> Nereid: I now get    Ambiguous type variable `a0' in the constraint:      (FixedArray a0) arising from a use of `fixedLength'
03:04:30 <mentus> one question: is it possible to use liftIO inside of simple State Monad (without having to change it to StateT) ?
03:04:37 <atriq> No
03:04:44 <atriq> Because State doesn't have access to IO
03:04:58 <Nereid> espringe: on what line?
03:04:58 <atriq> It'd have to be StateT IO or something like that
03:05:07 <mentus> ok
03:05:07 <espringe> Nereid: the last line
03:05:18 <Nereid> hmm
03:05:21 <Nereid> what about
03:05:29 <mentus> so what's the difference between lift and liftIO inside State a IO b ?
03:05:31 <Nereid> getSize v = (fixedLength :: Proxy q -> Integer) Proxy
03:05:37 <ivanm> @type lift
03:05:39 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
03:05:48 <Nereid> mentus: none, in that case.
03:05:56 <mentus> ok...
03:06:04 <Nereid> mentus: but if you have a stack of transformers, 'lift' lifts once, and 'liftIO' lifts all the way to where IO is.
03:06:08 <atriq> @hoogle m a -> (a -> b -> c) -> b -> c
03:06:09 <lambdabot> Prelude flip :: (a -> b -> c) -> b -> a -> c
03:06:09 <lambdabot> Data.Function flip :: (a -> b -> c) -> b -> a -> c
03:06:10 <lambdabot> Data.Foldable foldr :: Foldable t => (a -> b -> b) -> b -> t a -> b
03:06:13 <espringe> Nereid: now its   Could not deduce (FixedArray q1)   arising from a use of `fixedLength'
03:06:18 <Nereid> oh.
03:06:24 <atriq> Wait
03:06:27 <atriq> That's just fmap
03:06:28 <mentus> Nereid: oh ok, that a good hint
03:06:33 <Nereid> espringe: ok my first suggestion works if you -XScopedTypeVariables.
03:06:39 <atriq> No it isn't
03:06:50 <atriq> @hoogle m (a -> b) -> a -> m b
03:06:51 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
03:06:51 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
03:06:51 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
03:06:58 <Nereid> I wish ScopedTypeVariables was on by default but whatever.
03:07:07 <Peaker> mentus, State s a   is represented by:   (s -> (a, s))   there's no way for this type to represent IO actions
03:07:17 <mentus> ok...
03:07:34 <Nereid> mentus: I assumed you meant to write StateT a IO b.
03:07:37 * hackagebot yesod-form 1.1.4.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.1.4.1 (MichaelSnoyman)
03:07:39 <Peaker> mentus, and "lift" or "liftIO" are not magic they just wrap monad types by transformed-monad types so they are usable by the ordinary monadic composition
03:08:07 <mentus> Nereid: yes, i meant StateT a IO b
03:08:08 <espringe> Nereid: I'm using {-# LANGUAGE ScopedTypeVariable #-} and the line:  "getSize v = fixedLength (Proxy :: Proxy q)"   -- but still failing with "Ambigious type variable"
03:08:28 <Nereid> espringe: hmm, let me actually load ghci then.
03:08:28 <Nereid> :p
03:09:19 <hpaste> mentus pasted “Snippet from GPS code” at http://hpaste.org/77648
03:09:36 <mentus> please consider these two functions
03:09:50 <mentus> they are mutually calling each other and are both in the State Monad
03:10:10 <ivanm> mentus: what are we looking at there?
03:10:11 <mentus> now i want to print a line in applyOS
03:10:24 <Nereid> espringe: hmm. I don't know what's up then
03:10:26 <ivanm> I bet you don't really
03:10:32 <ivanm> mentus: are you wanting it for debugging purposes?
03:10:44 <ivanm> or does your program logic really require you to print something as part of your recursion?
03:11:03 <mentus> yes, i need it to print explicitely
03:11:08 <mentus> as part of the solution
03:11:14 <espringe> Nereid: any pointers on how to solve this?
03:11:21 <Nereid> espringe: I don't know what's up. :v
03:11:22 <mentus> so i am basically performing IO only in applyOpS
03:11:29 <ivanm> mentus: do you need to print as it's working?
03:11:33 <ivanm> or afterwards?
03:11:37 <mentus> yes, as it's working
03:12:04 <Nereid> mentus: well first of all, nothing in the types of applyOpS and such indicates that it can do IO
03:12:10 <mentus> yes
03:12:20 <mentus> i know that i should change it to StateT
03:12:21 <Nereid> so do you want StateT ProgState IO Bool for that?
03:12:23 <Nereid> ok
03:12:33 <mentus> but then i have to do the same for achieveS
03:12:50 <Nereid> no, for that you can just write Monad m => StateT ProgState m Bool
03:12:54 <mentus> but i don't really want, as it is not explicetly doing any IO
03:13:18 <ivanm> mentus: it's calling something that does IO
03:13:21 <ivanm> ergo, it does IO
03:13:32 <mentus> ok...
03:13:33 <ivanm> main = doStuff; doStuff :: IO () ....
03:13:39 <ivanm> ^^ main isn't doing any IO! ;-)
03:13:43 <Nereid> mentus: so you generalize the type of achieveS to be a StateT over any base monad.
03:13:52 <Nereid> if you don't want it to do IO.
03:14:04 <ivanm> Nereid: he can't if he's calling applyOpS, which _is_ StateT ProgState IO Bool
03:14:18 <Nereid> oh I didn't read the body.
03:14:18 <Nereid> :p
03:14:28 <mentus> ivanm: yes, that's my basic quesion
03:14:29 <Nereid> ok, then you need IO.
03:14:31 <ion> > let satisfy p = do { x:xs <- get; guard (p x); x <$ put xs }; end = guard . null =<< get in runStateT (do a <- StateT reads; satisfy (==','); b <- StateT reads; end; return (a :: Integer, b :: String)) "42,\"foo\""
03:14:33 <lambdabot>   [((42,"foo"),"")]
03:14:42 <Nereid> because it *is* explicitly doing IO, by running applyOpS
03:14:49 <ivanm> mentus: your function might not be doing IO _directly_, but if it's calling something that does IO then it's doing IO
03:14:51 <mentus> ok, so i must have both functions returning StateT ProgState IO Bool ?
03:14:58 <mentus> no other way around it thus
03:15:00 <Nereid> yes
03:15:15 <ivanm> if you must print stuff, then yes
03:15:19 <espringe> Nereid: I randomly changed the signature to: getSize :: forall q. FixedArray q => q -> Integer
03:15:20 <espringe>  and it compiles. Any insights?
03:15:32 <mentus> ok, makes sense
03:15:32 <ivanm> that looks like insufficient separation of concerns to me though
03:15:37 <Nereid> espringe: weird. ok
03:15:57 * Ralith is amused to read mentus's type so soon after Cale's complaints
03:16:05 <mentus> yes, insufficient separation of concerns. What can i improve on that ?
03:17:29 <Nereid> espringe: that is weird,
03:17:59 <Nereid> ah wait.
03:18:11 <Nereid> yeah, just read the doc for scoped type variables.
03:18:26 <Nereid> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#scoped-type-variables
03:19:09 <espringe> Nereid: Ultimately though, I would like the function to work without accepting a value. Basically I want the signature to be:
03:19:09 <espringe> getSize :: (FixedArray a) -> Integer
03:19:13 <Nereid> so writing "forall q" brings q into scope for stuff below.
03:19:20 <espringe> Not sure how you'd call that function though..
03:19:40 <Nereid> espringe: but that issue is exactly why we brought the Proxy into the class method
03:19:42 <bartavelle> how can I profile what takes TIME at a specific moment of the program execution ?
03:20:08 <bartavelle> it is all fine and dandy for memory profiling, but it seems you only get aggregated data for time
03:20:17 <Nereid> espringe: I don't know of a way to get aroudn it.
03:20:20 <espringe> Nereid: but see how getSize still takes a value
03:20:37 <Nereid> sure, so use fixedLength
03:21:07 <Nereid> fixedLength (Proxy :: Proxy MD5)
03:21:35 <espringe> True, thanks
03:21:37 <Nereid> although you know
03:21:39 <espringe> this should actually work :D
03:21:43 <Nereid> something I see often is
03:21:53 <Nereid> it's a bit less safe, I guess, but
03:22:03 <Nereid> class FixedArray a where fixedLength :: a -> Int
03:22:09 <espringe> (I'm using this for serialization, where I need to first create a schema that requires me to know the sie of the thing
03:22:10 <Nereid> instance FixedArray MD5 where fixedLength _ = 128
03:22:20 <Nereid> and then you can run fixedLength (undefined :: MD5)
03:22:34 <espringe> True, that could work too
03:22:43 <Nereid> but this feels less safe because it's not encoded in the types that fixedLength can't use any particular value
03:22:43 <espringe> Thanks
03:23:11 <Nereid> also Proxy is a thing, defined in Data.Proxy from tagged
03:23:12 <charliesome> is there a parsec combinator that i can give a predicate function which is passed the next token in the stream?
03:23:43 <ivanm> charliesome: you mean you parse a function and apply it?
03:24:44 <charliesome> ivanm: as in, i can pass a function to this combinator, the combinator calls the function with the next token, and if it returns True then that token is accepted
03:24:57 <Nereid> accepted and consumed?
03:25:01 <charliesome> yes
03:25:04 <Nereid> and the parser fails with False?
03:25:07 <shachaf> OK, now my → key isn't working either.
03:25:11 <charliesome> not accepted and not consumed
03:25:30 <Nereid> what do you mean by "accepted"
03:26:17 <charliesome> well '3' will be accepted by oneOf "1234", and '5' won't be
03:26:19 <charliesome> as an example
03:26:28 <ivanm> so you have a tokenParser already?
03:26:48 <charliesome> i have a lexer that gives me [Token]
03:26:57 <ivanm> in Parsec, isn't that: try (checkToken <$> parseToken) <|> doSomethingElse ?
03:28:41 <Nereid> I see a satisfy for Char, but ...
03:29:02 <charliesome> so one of my Tokens is 'TokenKeyword String'
03:29:10 <charliesome> and in my parser i'd like to be able to write something like
03:29:13 <charliesome> token "var"
03:29:45 <charliesome> and 'token' would make sure the next token in the input stream is a TokenKeyword, and that the field equals "var"
03:33:22 <charliesome> Nereid: ah yeah 'satisfy' looks like what i want
03:33:27 <charliesome> but it's for Char, as you noted
03:33:34 <charliesome> is there a generic version?
03:39:22 <charliesome> i suppose i could rip the implementation to satisfy and make it generic myself
03:41:27 <quicksilver> I thought the basic parsec primitive was satisfy
03:41:29 <Nereid> charliesome: yeah I didn't see one :(
03:41:29 <quicksilver> or something like it
03:43:41 <quicksilver> token/tokenPrim pretty much are
03:43:48 <quicksilver> although they have more bells and whistles
03:44:27 <charliesome> looks like i can cobble my own together with tokenPrim
03:45:41 <Nereid> @pl \f a -> if f a then Just a else Nothing
03:45:42 <lambdabot> flip flip Nothing . (`ap` Just) . (if' .)
03:45:51 <Nereid> @pl \a -> if f a then Just a else Nothing
03:45:51 <lambdabot> flip (liftM2 if' f Just) Nothing
03:45:56 <Nereid> blah
03:46:32 <Nereid> but yeah tokenProm could be used to write it.
03:47:15 <Nereid> Prim.
03:47:19 <Nereid> but then satisfy is defined in terms of it.
03:50:13 <Nereid> well, bedtime.
03:57:27 <Philonous> What makes for a better interface, a bunch of functions of the form (connection -> IO a) or wrapping them in a newtyped ReaderT ?
03:57:46 <atriq> The former
03:57:52 <atriq> Wait
03:57:55 <atriq> No, the latter
03:58:04 <atriq> Follow your heart
03:59:56 <Philonous> And now I'm none the wiser
04:00:24 <nicoo> Philonous: Follow your heart and unlock the triforce.
04:00:35 <Philonous> nicoo:  Been there, done that,.
04:01:07 <atriq> If there's only one connection in a program, probably the latter
04:02:19 <Philonous> It's about the library that provides the connection functions. If I just had to use it I'd go with a ReaderT no questions asked
04:02:41 <typoclass> Philonous: implicit params could be an alternative ...
04:02:43 <Cale> Philonous: It depends on how you picture the library being used. If you invent a new monad, then you'll force users to lift other IO actions into it.
04:02:53 <pauser> hi, im writing a function that converts the numbers to negative base binary number but im having some troubles, http://pastebin.com/p8jdmKtW .  It tells me the error *** Does not match : [a]
04:02:56 <mauke> The paste p8jdmKtW has been copied to http://hpaste.org/77652
04:03:30 <Philonous> typoclass:  You mean the type class hack?
04:03:45 <Cale> If you have a rich enough bunch of actions in your new monad that you expect users should be able to write most of their programs without doing too much lifting (or you don't want to provide lifting at all!), then the new-monad sort of way of doing things might be nice.
04:04:39 <Philonous> I should probably check how the DB libraries do it
04:04:50 <Cale> If you expect that users of your library are fundamentally going to be writing other IO actions mostly, and the use of your library is going to be some smaller part of whatever else it is that is going on, then taking function parameters is much nicer.
04:05:05 <Cale> (Does that make sense?)
04:05:23 <Philonous> Yes, perfectly.
04:07:28 <djcoin> I'm struggling with this monad sequence, if I remove the parenthesis in the middle I got an error, but if I leave it this way, the 'a' variable is not in scope, how should I change the parenthesis ? let addStuf = (*2) >>= (\a z -> 10 + z) >>= \b w ->
04:07:39 <djcoin> b
04:08:11 <shachaf> What are you trying to do?
04:08:30 <shachaf> I bet you want the second >>= to be inside the parentheses. But that won't solve your problem.
04:08:51 <djcoin> I want the second >>= to have access to the a variable
04:09:20 <typoclass> Philonous: i meant the ImplicitParameters extension. you could have a function "withConnection" that does let ?connection = ..., and some functions that use the ?connection, like foo :: (?connection :: Conn) => IO a. i think that should work
04:09:26 <notdan> pauser: try (show $ ceiling (n `mod` (-2))) ++ ...
04:09:34 <ski> where should `10 + z' go ? to `b' ?
04:09:39 <atriq> I'm tempted to run about making lenses for everything I can think of
04:09:59 <shachaf> djcoin: Please refer to my first question. :-)
04:10:12 <typoclass> atriq: don't we have several people who're on it? ;-)
04:10:38 <typoclass> Philonous: other possibility -- i sometimes have "fetch :: Connection -> IO a", then write the setupConnection function so that it gives back a curried "fetch" ready for use
04:10:45 <notdan> pauser: also a bunch of other parens are missing
04:11:04 <djcoin> shachaf: well, I'm just practicing (deconstructing a do notation). I want to do >>= \b _ -> return (a + b)
04:11:18 <pauser> notdan: like
04:11:47 <ski> djcoin : what is the corresponding `do'-expression ?
04:12:14 * shachaf gets vaguely tempted to go into conal.moed
04:12:31 <djcoin> ski: addStuff = do  { a <- (*2); b <- (+10); return (a+b) }
04:12:37 * ski . o O ( "moed" ? )
04:13:01 <Philonous> typoclass:  I'd like to avoid implicit parameters, it's another extension and it get's really ugly when you try to use two connections at once
04:13:23 <ski> djcoin : you shouldn't need to introduce any new variable names
04:13:48 <Philonous> typoclass:  The pre-applied function would be easy to do yourself: (in monadic code:) let foo' = foo connection; foo
04:14:12 <djcoin> This is not my point, I'm jsut trying to understand how should I put parenthesis
04:14:13 <Philonous> typoclass:  But that get's messy when there is more than a couple of them
04:14:15 <typoclass> Philonous: well you can structure it so that library users don't have to enable ImplicitParams, only your modules have to
04:14:46 <typoclass> Philonous: that's true, if you have lots of functions, you'd have to use a record or something
04:14:46 <Philonous> typoclass:  Well, what would the type of the foo function look like, then?
04:16:55 * djcoin whatever.. :<
04:19:28 <Philonous> djcoin:  Maybe like this: let addStuf = (*2) >>= \a 0> (\z -> 10 + z) >>= \b -> ( \w -> ...
04:19:59 <Philonous> s/0>/->/
04:20:52 <shachaf> I think you must be getting errors because of "Stuf"
04:21:37 <djcoin> Philonous: it works indeed thanks. I'm looking for the use of 'where', might help
04:22:15 <Philonous> Was probably supposed to be spelled "S.t.u.f.", but full stops are not allowed in names
04:22:21 <HugoDaniel> these warnings are so boring...   Warning: Top-level binding with no type signature
04:23:17 <typoclass> Philonous: you can *use* a "foobar :: (?verbose :: Bool) => ..." without enabling ImplicitParams (it's necessary only for defining). for example, i've used a function verboseOn, which just does "let ?verbose = True", in this way: "import Foobar ; main = verboseOn $ do ... foobar ...". that module with the main function doesn't need ImplicitParams enabled
04:24:27 <typoclass> HugoDaniel: can i interest you in -fno-warn-missing-signatures ?
04:24:30 <Philonous> typoclass:  Fair enough. But juggling two connections becomes a real pain
04:25:02 <HugoDaniel> typoclass: yes, thank you very much :D
04:25:10 <typoclass> Philonous: yeah, i don't have an obvious answer for that :-)
04:27:10 <Philonous> Maybe we should just lift all IO functions to MonadIO, then adding transformers becomes painless :>
04:30:19 <Peaker> Need serializable closures, so I'm defining a huge-ugly sum type that manually captures all the lexical scope :(
04:31:37 <Philonous> Peaker:  Doesn't the cloud haskell package already solve that problem with TH?
04:32:06 <Peaker> Philonous, I'm not sure but it would be nice.. is it a standalone thingie one can use?
04:33:41 <Philonous> Peaker:  http://hackage.haskell.org/packages/archive/distributed-process/0.4.0.2/doc/html/Control-Distributed-Process-Closure.html
04:34:18 <HugoDaniel> ive been playing with software transactional memory
04:34:21 <HugoDaniel> its amazingly simple
04:34:31 <quicksilver> and simply amazing?
04:34:37 <HugoDaniel> ahah yes :D
04:34:45 <HugoDaniel> it makes me wonder in which cave have i been all this long
04:34:56 <Peaker> doesn't seem to be stand-alone
04:35:36 <Philonous> Peaker:  It's BSD3, just "borrow" whatever you need?
04:35:58 <Peaker> Philonous, hmm.. already half-way through my ugly transform, I'll look into it as a potential cleanup afterwards, thanks :)
04:36:12 <ion> instance MonadIO ((->) a) where liftIO = const . unsafePerformIO
04:38:05 <shachaf> data Nonoid a = NLeaf a | NEmpty | NAppend (Nonoid a) (Nonoid a)
04:38:13 <shachaf> Isn't that a great type?
04:38:30 <typoclass> s/Nonoid/Nomoid
04:38:46 <shachaf> Omnomnomoid?
04:38:59 <shachaf> Was it ski that I spoke to about that type before?
04:47:01 <ski> djcoin : any luck ?
04:50:17 <tdammers> shachaf: I'd actually love to see an implementation of Omnomnoid
04:51:44 <djcoin> ski: no, I surrendered since although it may not be so complicated !
04:52:14 <typoclass> > (\(a:b:c:d) -> c:b:a:d) "monoid"
04:52:16 <lambdabot>   "nomoid"
04:53:46 <shachaf> > partsOf (taking 3 traverse) %~ reverse $ "monoid"
04:53:48 <lambdabot>   "nomoid"
04:55:33 <shachaf> Surely there's a better way to write that?
04:55:53 <signalsea> question... in the academic sense, what is said to be implied by Cxt in "xyz :: Cxt => X "?
04:56:16 <Ferdirand> @type partsOf
04:56:17 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
04:56:22 <Ferdirand> @type taking
04:56:23 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
04:56:39 <fmap> helpful types
04:56:54 <ion> I should try to figure partsOf out some time.
04:56:55 <typoclass> signalsea: in a haskell type signature, i don't read "=>" as implication, it's just the thing that separates the typeclass constraints from the signature itself
04:57:15 <shachaf> ion: It's quite simple, really.
04:57:16 <typoclass> (not sure if that's academically correct)
04:57:31 <shachaf> ion: You know half of it already -- toListOf
04:57:52 <byorgey> signalsea: it is implication in the same generalized sense that function arrows are implication
04:57:56 <byorgey> "given this, that"
04:57:58 <shachaf> > view (partsOf (both.traverse)) ("hello","there")
04:58:00 <lambdabot>   "hellothere"
04:58:18 <shachaf> The other half does the opposite -- it takes an input list and fills in the traversed elements with it.
04:58:22 <Ferdirand> @type both
04:58:24 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
04:58:27 <ion> shachaf: Hmm, ok.
04:58:35 <shachaf> > set (partsOf (both.traverse)) "blah blam " ("hello","there")
04:58:37 <lambdabot>   ("blah ","blam ")
04:58:44 <signalsea> then is to to say that type X is inhabited?
04:59:07 * Ferdirand 's brain reboots
04:59:10 <signalsea> typoclass: I recognize that, i'm just curious as to the origins of the syntax
04:59:13 <shachaf> ion: If you don't give it enough elements, it reuses the old ones, so it has to have the same type:
04:59:16 <shachaf> @ty partsOf
04:59:18 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
04:59:25 <shachaf> Ignore the Bazaar thing.
05:00:05 <byorgey> signalsea: I don't understand your question about type X
05:00:08 <shachaf> partsOf :: Traversal s t a a -> Lens s t [a] [a]
05:00:13 <signalsea> byorgey: what generalized sense is that? is there a word for it?
05:00:24 <shachaf> There's also an unsafe version which you *have* to provide with enough items:
05:00:29 <shachaf> @ty unsafePartsOf
05:00:31 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a b) s t a b -> ([a] -> f [b]) -> s -> f t
05:00:36 <shachaf> OK, that didn't help.
05:00:44 <byorgey> signalsea: "the Curry-Howard isomorphism"
05:00:44 <shachaf> unsafePartsOf :: Traversal s t a b -> Lens s t [a] [b]
05:00:53 <signalsea> byorgey: nevermind that question about type X, i'm probably misusing "inhabited"
05:00:56 <shachaf> ion: Exercise: Implement partsOf
05:01:04 <ion> shachaf: Yeah, i was thinking of doing exactly that.
05:01:31 <byorgey> signalsea: note that type classes are implemeted in GHC by passing a dictionary, i.e. a record of type class methods
05:01:37 <byorgey> signalsea: so => really gets translated into ->
05:01:45 <ski> shachaf : i think of `=>' in *type signatures* as "presupposition"
05:01:46 <byorgey> signalsea: which I think is probably the origin of the notation.
05:01:55 <shachaf> ski: ?
05:02:19 <typoclass> signalsea: not sure about the history of the => symbol in haskell. but if you find out, tell us :) i've sometimes wondered about it. i didn't exactly find it intuitive when i first learned it
05:02:20 <shachaf> ion: Do you know Bazaar?
05:02:44 <ion> shachaf: Nope, didn’t get around to studying it yet.
05:02:52 <ski> shachaf : auxilary assumptions you have to make to guarantee the expression is meaningful
05:03:06 <shachaf> ski: I don't disagree, but what's the context here? :-)
05:03:16 <ski> .. er
05:03:28 <ski> s/shachaf/signalsea/
05:03:30 <ski> (:
05:03:38 <shachaf> ion: Bazaar a b t ~~ exists s. (s, Traversal s t a b)
05:03:40 <ski> signalsea : see above
05:03:41 <typoclass> shachaf: it's anything between "::" and "=>", dude
05:04:48 <ski> djcoin : i think you're probably making it more complicated than it is (no doubt not by intent !)
05:05:18 <ski> djcoin : you shouldn't need any `z' or `w' variables in the desugaring of the `do'-notation into calls of `(>>=)'
05:06:12 <ion> shachaf: Could you give a simple example of where exists s. (s, Traversal s t a b) is useful?
05:06:38 <shachaf> ion: It's just a Traversal that's already been preapplied to a structure.
05:06:49 <shachaf> ion: You know how Lens s t a b ~~ s -> (a, b -> t)?
05:07:34 * Cale considers the possibility of implementing the better part of the functionality of the Gnome 2 panel and the applets that he uses in order to become mostly-free from the obnoxious direction that desktop environments have taken.
05:07:35 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
05:07:45 <signalsea> byorgey: i knew that about typeclasses... on a related note, is that dictionary mechanism exposed to haskell users somehow? they are basically singletons aren't they?
05:07:47 <ion> shachaf: Yeah
05:08:00 <shachaf> ion: So if you apply it to some "s", you get the (a, b -> t) part.
05:08:09 <shachaf> That's called Context: data Context a b t = Context a (b -> t)
05:08:18 <ion> ok
05:08:18 <shachaf> Lens : Traversal = Context : Bazaar
05:08:24 <ion> alright
05:08:44 <shachaf> So data Bazaar a b t = Bazaar [a] ([b] -> t)
05:08:49 <shachaf> Where the two lists must be the same length.
05:08:50 <signalsea> byorgey: ... that is, there is only ever one value of some record (Functor y), correct?
05:08:55 <ion> The “exists s. …” notation was throwing me off a bit, but that makes sense.
05:09:11 <shachaf> ion: "exists s." just means that the only thing you can do with it is traverse. :-)
05:09:22 <typoclass> cale: i've sometimes thought about that too! i.e. an xmonad module that draws that sort of bar
05:09:34 <typoclass> cale: which parts of the gnome panel do you use?
05:10:11 <signalsea> (... for some y)
05:10:18 <shachaf> ion: Another definition of Bazaar: data Bazaar a b t = Buy t | Trade a (Bazaar a b (b -> t))
05:10:22 <ski>   data Bazaar a b t = Lambdas t | Apply (Bazaar a b (b -> t)) a
05:11:28 <shachaf> ion: That one is rather more confusing at first sight, though. :-)
05:11:49 <Cale> The main things I use are: 3 volume control applets (Master/PCM/Headphone), the System Monitor applet (graphical CPU, Memory, Network(in/out/local), HDD(read/write)), CPU temperature/scaling, and the world weather/clock applet (show local weather and time, and show a configurable list of other places when clicked)
05:11:50 <ion> Yeah, i get Bazaar [a] ([b] -> t), but i’ll have to think about that one a bit.
05:12:13 <shachaf> @google twanvl funlist
05:12:15 <lambdabot> http://twanvl.nl/blog/haskell/non-regular2.lhs
05:12:19 <shachaf> ion: ☝
05:12:21 <shachaf> Hmm, no.
05:12:28 <shachaf> http://twanvl.nl/blog/haskell/non-regular1.lhs
05:12:30 <Cale> I also use a long list of launchers, but most WMs have that sort of thing covered well enough.
05:12:37 <shachaf> http://twanvl.nl/blog/haskell/non-regular1
05:12:38 <shachaf> There.
05:12:44 <ion> shachaf: Ok, thanks
05:12:46 <typoclass> cale: right
05:14:31 <Cale> (things like screenshot and an xkill equivalent I have applets for, but they don't really need to be applets)
05:14:59 <ski> shachaf : it's just an accumulator-passing predicate :)
05:15:09 <Cale> A pager would also be nice, but unless you're going to do a really good job of it like E16's snapshotting pager, it's not as important to me.
05:15:15 <shachaf> ski: What is?
05:15:27 <ski> `Bazaar'/`FunList'
05:16:05 <shachaf> ion: By the way, you don't need Bazaar to write partsOf
05:16:16 <ion> shachaf: aye
05:16:16 <Philonous> Cale:  What's wrong with using e.g. xfce4-panel ?
05:16:35 <Cale> tbh, I need to try XFCE and see how well it has things covered
05:16:49 <Philonous> Cale:  I only use the panel.
05:17:22 <Cale> I've spent a lot of time and energy mucking about with Gnome 3 Shell and Cinnamon, and sort of got tired of attempting to get things into a state which made me happy.
05:17:27 <Philonous> Cale:  You can install it on its own, so it doesn't ppull in the whole shebang of XFCE
05:17:31 <Cale> right
05:17:41 <ski>   fun_list(TypeA,TypeB,done(ValB)        ) :- TypeB(ValB).
05:17:42 <ski>   fun_list(TypeA,TypeB,more(ValA,FunList)) :- TypeA(ValA),fun_list(TypeA,(TypeA => TypeB),FunList)
05:17:47 <ski> basically
05:17:47 <Cale> I might not mind using XFCE wholesale for that matter though.
05:18:08 <Sonderblade> what emacs mode do you use to edit haskell?
05:18:20 <shachaf> php-mode
05:18:25 <ski> @where haskell-mode
05:18:25 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:18:26 <typoclass> cale: hm yeah, what i had hacked up was more like xmobar, but as an xmonad module and within the xmonad process. i was sick of assembling bits of xmonad state into a string in a complicated way, shipping it to xmobar, then taking it apart again with a dubious ad-hoc parser ...
05:19:07 <Cale> Yeah, what I want definitely isn't possible to cover with just a string.
05:19:14 <Sonderblade> i've been using haskell-mode too, but it seem to handle identation in a very strange way
05:19:38 <typoclass> cale: and yeah, the good thing about the xfce stuff is that you can sensibly use it in isolation (unlike how gnome-anything tends to depend on gnome-everything)
05:20:18 <Cale> typoclass: In that regard -- do you have any idea how reasonable it is to try to use Nautilus without the rest of Gnome?
05:20:31 <Cale> Well...
05:20:46 <Cale> I don't even know whether I like the newer versions of Nautilus, I forget.
05:20:48 <shachaf> What's a good way to implement partsOf without Bazaar, anyway?
05:20:51 <shachaf> I bet Cale knows.
05:20:58 <shachaf> I think the obvious way loses some sharing.
05:21:04 <Cale> shachaf: What's the type of partsOf?
05:21:07 <Peaker> interesting that f x = \[] -> ..   is ok, but  f x [] = ...   generates a non-totality warning
05:21:16 <Nimatek> Dolphin > Nautilus
05:21:19 <shachaf> Cale: Approximately, Traversal s t a b -> Lens s t [a] [b]
05:21:21 <Peaker> I wonder if hlint will bust my balls over these lambdas
05:21:37 <typoclass> cale: not sure :-) i seem to recall it's doable, but slightly weird. the first nautilus you start will go into a special mode and draw the desktop picture + icons, any subsequent nautilus shows the regular file manager window
05:21:55 <Cale> typoclass: right
05:22:18 <Philonous> Cale:  Why not mc? (I think this is going way OT, though)
05:22:45 <shachaf> Peaker: Yes, it's a bit of a wart.
05:22:58 <typoclass> cale: but give thunar a whirl :-) it's much more standalone. if you wish you can install one or two extra packages that give you "thunar-thingy-that-automounts-flash-drives" etc.
05:23:04 <shachaf> Sometimes I wish Haskell was stricter about wanting totality.
05:23:35 <nand`> I think I would be fine with using some Serializable-like interface to pass data between xmobar and xmonad; rather than having it necessarily all live in the same process
05:23:38 <Cale> Philonous: Isn't mc just text?
05:23:57 <typoclass> nand`: hm, interesting!
05:23:58 <Cale> Philonous: If I'm not going to have graphical previews of stuff, I'd rather just use the commandline.
05:23:58 <Peaker> shachaf, I'm using "variadic arg" encoding using lists, with partiality intended.. need to get ghc and hlint both to not bust my balls over it
05:24:18 <Philonous> Cale:  Yes. If you want previews I guess it's not a good choice
05:24:27 <shachaf> Peaker: You could add ~
05:24:42 * shachaf attempts to function without → and End keys.
05:24:50 <Cale> The *one* thing which makes Nautilus more attractive than just using the commandline for me is the image previews of various types of media, and the ability to do things like set directory icons for my music collection.
05:25:17 <typoclass> shachaf: use moar ctrl-e and ctrl-f?
05:25:33 <shachaf> typoclass: Doesn't work in my IRC client...
05:25:34 <Cale> and most of the rest of the time, I just use terminals anyway
05:25:40 <shachaf> Well, ^E does.
05:25:47 <shachaf> But it doesn't work in my GUI programs.
05:26:02 <haskellBeginner> hi everyone! i got a little problem. i have a data structure "data Matrix = Matrix [[Bool]]" and want to access the elements, but the !!-operator does not work here. any hints for me?
05:26:07 <Peaker> shachaf, thanks, good idea
05:26:44 <shachaf> Of course, the fact that GHC doesn't give you nontotality warnings with ~ is a bit suspect in itself.
05:27:48 <Philonous> haskellBeginner:  You need to unwrap the constructor to get to the lists. For example getRow (Matrix xs) i = xs !! i and (m `getRow` 3) !! 2 to get to the 2nd column, 3rd row
05:27:57 <Peaker> Yeah, it could be nice to get non-totality warnings everywhere, even in do-block pattern-matches
05:28:54 <Philonous> haskellBeginner:  You could also define your data type with record syntax : data Matrix = Matrix {fromMatrix :: [[Bool]]} and then (fromMatrix matrix !! 3) !! 2
05:30:22 <typoclass> cale: i haven't paid particular attention to image previews and stuff, but try out thunar sometime. i'd describe it as a nautilus that isn't entangled with gnome, and more relying on standard stuff like shell scripts instead of weird gnome mechanisms
05:31:22 <Philonous> Peaker:  Partial pattern binding in do notation should be outright disallowed except for MonadZero / MonadPlus
05:32:27 <Peaker> Philonous, yeah, probably.. unless maybe you use ~ to indicate you want a partial match with no "fail" but with "erroR"
05:32:34 <shachaf> Cale doesn't like lenses. :-(
05:32:35 <shachaf> Alas.
05:32:54 <shachaf> Peaker: ~ means something other than "will always succeed", though.
05:33:01 <Philonous> Peaker:  Yes. Same goes for lambda, IMO
05:33:34 <Peaker> yeah, good point
05:33:49 <Peaker> maybe it should just be disallowed as Philonous said, also in lambdas
05:41:04 <KBme> hello
05:41:12 <KBme> on this page http://hackage.haskell.org/packages/archive/HDBC/2.2.3/doc/html/Database-HDBC.html#v%3Aprepare
05:41:23 <KBme> it says prepare can throw an sql exception
05:41:30 <KBme> I would like to catch that
05:42:16 <KBme> hmmm nvm ☺
05:42:23 <Peaker> KBme, use Control.Exception.catch ?
05:42:59 <u_quark> @pl \x y z -> x && y && z
05:43:00 <lambdabot> (. (&&)) . (.) . (&&)
05:43:18 <KBme> well
05:43:22 <KBme> I just use handleSql
05:43:23 <u_quark> is there a way to write that point-free in a saner way, maybe arrows?
05:43:35 <Peaker> u_quark, and [x,y,z]
05:43:36 <shachaf> and [x,y,z]
05:43:46 <shachaf> Not that that's very point-free.
05:44:06 <Peaker> if you can replace the multiple args with a list, it becomes "and"
05:44:50 <atriq> Is there anything like "NonEmpty Seq" about?
05:45:03 <shachaf> Seq as in Data.Sequence?
05:45:07 <shachaf> Or just a nonempty list?
05:45:14 <atriq> The former
05:45:32 <shachaf> I doubt it.
05:45:34 <atriq> Anything good for queues'd be good
05:45:42 <shachaf> edwardk: There is another way to achieve foldMapOfWith, of course.
05:46:01 <shachaf> Something like data Nonoid a = NLeaf a | NEmpty | NAppend (Nonoid a) (Nonoid a)
05:46:39 <edwardk> shachaf: sure
05:47:04 <edwardk> you start with the free unital magma, and then run it
05:47:13 <shachaf> Right.
05:47:27 <shachaf> Unital magma?
05:47:54 <shachaf> Well, it depends on how you implement it, I guess.
05:48:21 <edwardk> magma gives you the binary operator, then you have the unit law for it, guess its not the unital magma, just a magma with a distinguished element we'll quotient out of consideration later
05:48:23 <u_quark> Peaker: I think it can be done with arrows...
05:48:58 <edwardk> the annoying part is the interpretive overhead on that version
05:49:04 <edwardk> but it avoids reflection
05:49:10 <shachaf> Right.
05:49:34 <edwardk> good thinking
05:50:55 <Cale> shachaf: I like lenses, but haven't really used them much.
05:50:55 <fmap> :t (.:)
05:50:57 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
05:51:17 <fmap> @check \x y z -> join (.:) (&&) x y z == x && y && z
05:51:19 <lambdabot>   Not in scope: `myquickcheck'
05:51:31 <edwardk> atriq: i have one in a small library i used locally, but i never bothered to package it
05:51:35 <Cale> shachaf: And I prefer more prefix notation and use of ordinary function composition over the funny operators that lens provides.
05:51:45 <shachaf> Cale: Well, lens provides both.
05:51:59 <shachaf> edwardk: By the way, I figured out that view patterns were designed to be used with lens.
05:52:04 <edwardk> cale: You can add liyang to your minimalist rebellion ;)
05:52:07 <shachaf> f (view (blah.blah) -> ...) = ...
05:52:09 <edwardk> shachaf: =)
05:52:11 <Peaker> I just learned of the existence of DeriveFoldable/DeriveTraversable
05:52:13 <edwardk> yep =)
05:52:17 <shachaf> Why else would it be called a view pattern?
05:52:22 <edwardk> thats one reason why i went with the name view ;)
05:52:23 <Peaker> (instead of the derive packages which sports unhygenic TH)
05:52:28 <shachaf> Oh.
05:52:31 <edwardk> that and of course viewing through a lens
05:52:56 <tomboy64> ok, complete newbie here
05:52:56 <edwardk> and the fact that 'get' was taken by MonadState
05:53:05 <Peaker> in my code: f (Lens.view (...)) -> ..
05:53:11 <edwardk> so i was already thrown off the get/set symmetry
05:53:48 <shachaf> Is there a name for view . from?
05:54:08 <edwardk> nope
05:54:14 <edwardk> :t view . from
05:54:16 <lambdabot> Isomorphism (s -> Accessor a t) (a -> Accessor a b) -> s -> a
05:54:25 <shachaf> > (view . from) identity (Identity 5)
05:54:28 <lambdabot>   5
05:54:29 <dgpratt> my goodness this has been a journey, but I think I am close to figuring out this cabal-dev build problem I'm having
05:54:32 <edwardk> i have 'over', maybe i should add it
05:54:35 <edwardk> :t over
05:54:37 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
05:54:41 <shachaf> @ty under -- ?
05:54:41 <tomboy64> i want to use attoparsec bencode. i have bytestring (utf8) but can't seem to get the conversion right to run it via decode
05:54:43 <lambdabot> Isomorphism (a -> Mutator b) (s -> Mutator t) -> (s -> t) -> a -> b
05:54:44 <edwardk> :t under
05:54:46 <lambdabot> Isomorphism (a -> Mutator b) (s -> Mutator t) -> (s -> t) -> a -> b
05:54:52 <edwardk> yeah
05:54:56 <rwbarton> @type here
05:54:58 <lambdabot> Not in scope: `here'
05:55:11 <tomboy64> http://hackage.haskell.org/packages/archive/AttoBencode/0.2/doc/html/Data-AttoBencode.html <--- this is the haddock page
05:55:35 <tomboy64> and i want to run decode somebvalue
05:55:46 <tomboy64> what am i doing wrong?
05:56:07 <fmap> tomboy64: is your bytestring lazy?
05:56:16 <shachaf> sovietView = view . from
05:56:25 <dgpratt> Setup.hs is build against the latest available Cabal library, yes? Is there a way to control which version it gets built against if there are multiple available?
05:56:27 <edwardk> shachaf: =P
05:56:35 <edwardk> trying to think of an appropriate preposition ;)
05:56:48 <tomboy64> fmap: i don't think so. i'm using Data.ByteString's readFile
05:57:10 <shachaf> What happens when you look in through the wrong end of a telescope?
05:57:20 <shachaf> "telescope" would be a good name for a traversal if it wasn't called a traversal.
05:57:42 <edwardk> telescope is in cofree
05:58:03 <atriq> shachaf, edwardk, how about weiv = view . from
05:58:08 <edwardk> it takes a list of lenses and gives you a lens into the cofree comonad
05:58:21 <shachaf> lenses are in free now?
05:58:21 <edwardk> atriq: i've avoided reversed words in the api so far
05:58:29 <edwardk> shachaf: without a dependency
05:58:32 <atriq> I wasn't entirely serious
05:58:44 <quicksilver> edwardk is a machine whose purpose is to ensure that every noun, abstract or otherwise, exists as a categorically-motivated haskell function.
05:58:47 <shachaf> Ah, with the trademark type signature in a comment.
05:58:49 <mapf> snoc-snoc-snoc
05:59:01 <u_quark> fmap: where can I find (.:)
05:59:19 <rwbarton> @where hpaste
05:59:20 <lambdabot> http://hpaste.org/
05:59:23 <mapf> quicksilver: Function.Pointless
05:59:31 <rwbarton> tomboy64: ^^ can you paste your error? and ideally the code as well
05:59:31 <lambdabot> rwbarton: You have 1 new message. '/msg lambdabot @messages' to read it.
05:59:44 <atriq> @hackage pointless-fun
05:59:45 <lambdabot> http://hackage.haskell.org/package/pointless-fun
06:00:00 <tomboy64> rwbarton: i am just toying around in ghci
06:00:04 <fmap> u_quark: you can define it yourself, it's `fmap . fmap'
06:00:08 <shachaf> rwbarton: Oh, I was wondering why you weren't getting the @tell. But you were speaking exclusively in lambdabot commands.
06:00:17 * tomboy64 sighs
06:00:21 <rwbarton> oh, me too :)
06:00:21 <shachaf> That's how we know rwbarton is more evolved than the rest of us who still use English.
06:00:32 <tomboy64> ok, let's make a source file
06:00:37 <u_quark> ok
06:00:47 <rwbarton> tomboy64: well still the error from ghci should be helpful
06:00:54 <u_quark> tnx all
06:01:11 <typoclass> dgpratt: you might want to hang around until dcoutts_ is around and ask him, he's the resident cabal expert
06:01:13 <tomboy64> rwbarton: Couldn't match expected type `ByteString'
06:01:15 <tomboy64>                 with actual type `Maybe a0'
06:01:24 <dgpratt> typoclass: ok, thanks
06:01:43 <tomboy64> i am trying: decode $ fromBencode meta
06:01:50 <dcoutts_> dgpratt: you can only specify the minimum version it's built against, no other control.
06:01:55 <tomboy64> with meta being my bytestring
06:02:05 <rwbarton> shouldn't it just be: decode meta
06:02:09 <dgpratt> dcoutts_: ok, hmm
06:02:34 <dcoutts_> dgpratt: consider that for distros, compiling the Setup.hs is the first thing they have to do, so there's not a lot of opportunity for conditional compilation etc. The distros have to be able to just ghc --make and go.
06:02:57 <edwardk> behind ? beyond ? versus ? visavis?
06:03:05 <dcoutts_> dgpratt: this is inherited from the original cabal spec which makes the Setup.hs the primary interface for interating with packages.
06:03:16 <dcoutts_> interating/interacting
06:03:25 <dgpratt> dcoutts_: I see
06:03:40 <mapreduce> Are there any efforts to implement something like static typing just using the standard features available in dynamic languages, i.e., checking functions and assigning/verifying a type for them when they're loaded etc.?
06:04:11 <mapreduce> Google just gives me really badly informed articles about the contrasts between static and dynamic typing so I thought I'd ask here.
06:04:19 <edwardk> opposite, outside
06:04:51 <shachaf> None of those are really the opposite of view.
06:04:59 <edwardk> sure
06:05:04 <shachaf> Not that view is a preposition.
06:05:27 <lispy> mapreduce: cmucl (and it's descedent sbcl) do static types for common lisp. There the goal is optimization though.
06:05:40 <edwardk> i'm mostly looking for something that stands on its own. 'the opposite of view' isn't right here, since we want to view 'back'
06:05:49 <edwardk> its more like spotting the spotter ;)
06:05:51 <shachaf> Fair enough.
06:05:56 <shachaf> mirror?
06:05:59 <mapreduce> lispy: I'll take a look but I think that's done in a separate pass rather than being 'part of the program'.  Do you agree?
06:06:00 <lispy> mapreduce: People have done static types for restricted subsets of python
06:06:11 <edwardk> mirror and reflect are pretty overloaded
06:06:22 <atriq> turnAround?
06:06:25 <mapreduce> E.g., to extend a language within the language rather than hacking at the runtime.
06:06:32 <atriq> counterEspionage?
06:06:47 <edwardk> refract? =)
06:06:50 <mapreduce> edwardk: I don't have context but I think the word might be invert.
06:06:50 <shachaf> reflection?
06:07:04 <nicoo> lispy: Like RPython, yes
06:07:20 <edwardk> mapreduce: i'm consciously avoiding that one. word frequency is too high on hackage
06:07:31 <edwardk> hence my goal of mining prepositions
06:09:36 <shachaf> viewed?
06:09:36 <edwardk> so far i like visavis foo    it has the right conversational tone, i also like opposite, but the frequency would be higher
06:09:45 <shachaf> Hmm.
06:09:49 <edwardk> =/ i don't like ed flipping meaning
06:09:54 <edwardk> er -ed =)
06:09:58 <shachaf> Right, that's confusing.
06:09:59 <edwardk> i'll flip it all i want ;)
06:10:22 <shachaf> visàvis
06:10:51 <edwardk> clear it should be abaft
06:11:10 <shachaf> This would typically be used to "de-newtype" things, right?
06:11:37 <shachaf> Well, one use, anyway.
06:12:24 <shachaf> Maybe you can just call it betwixt and be done with it.
06:12:48 <edwardk> i kind of want to save betwixt for something epic. like athwart ;)
06:13:26 <mapreduce> viewee
06:14:11 <Sonderblade> what is the best haskell argument parsing library?
06:14:28 <bgamari> Sonderblade, I like optparse-applicative quite a bit
06:14:42 <t7> Anyone know of a paper on type inference with recursive types ?
06:14:50 <dgpratt> dcoutts_: the latest version of Cabal I have is 1.16.0.2; I believe the problem I'm having relates to what is going on in "Distribution\Simple\Build\PathsModule.hs"; there's some code being generated there that has an explicit Prelude import that doesn't include everything it needs to include
06:14:58 <shachaf> t7: As in equirecursive?
06:15:52 <t7> like  μ abstraction
06:16:00 <dcoutts_> dgpratt: can you give me more context or details?
06:16:26 <shachaf> Clearly they should be called víew and vìew
06:16:51 <dgpratt> dcoutts_: yes, just thinking about the best angle to explain this :)
06:16:55 <t7>  μ x. (Int, x)
06:17:00 <mzero> dcoutts_: at what version of cabal did it finally get the ability for an executable in a project to include a library from the same project w/o just compiling all the library files into the executable directly?
06:17:04 <edwardk> clearly 'fornent' which is an archaic preposition for 'opposite to' should be used =P
06:17:19 <edwardk> it is definitely unused in hackage
06:17:33 <edwardk> and gives you a name, and expands users vocabularies in interesting ways =P
06:18:12 <dgpratt> dcoutts_: it appears that 1.16.0.2 had a bug in that module that was fixed in 1.16.0.3
06:18:24 <mapreduce> You could pluck identifiers from other languages.  Spanish is a good one but latin gives you more umph.
06:18:28 <shachaf> counterview
06:18:57 <shachaf> opposition?
06:19:13 <mapreduce> 'opuesto', 'contra'
06:19:16 <typoclass> mapreduce: don't give him ideas
06:20:01 <shachaf> converse?
06:20:08 <lispy> allstars?
06:20:15 <Sonderblade> bgamari: looks nice but seem to be missing some features, like being able to specify that an argument must be a filename or a number for example
06:20:18 <dgpratt> dcoutts_: alas there are two things that are preventing me from updating Cabal: (1) "cabal update && cabal install cabal-install" only installs v1.16.0.2 (?) shouldn't it install .03? (2) due to the bug (I think) the cabal I have cannot build cabal (I think)
06:20:25 <mzero> weiv  !
06:20:37 <hiptobecubic> i like fornent, or ferninst
06:21:01 <shachaf> converse is sort of nice, if it's unused.
06:21:22 <lispy> dgpratt: can you request 0.3 on the command line: cabal install cabal-install-1.16.0.3
06:21:42 <atriq> shachaf, converse does not appear on Hayoo
06:22:16 <dcoutts_> dgpratt: by default it doesn't upgrade dependencies if they're not needed. So you can just do: cabal install Cabal cabal-install, to get the latest of both.
06:22:42 <atriq> Aaargh, why did nobody tell me Yesod.Auth.OAuth exists?
06:22:48 <geekosaur> someone is confused
06:22:58 <geekosaur> cabal-install is at 1.16.0.2
06:23:02 <Philonous> edwardk:  Why not Greek? μέσος = between.
06:23:07 <geekosaur> Cabal the library is at 1.16.0.3
06:23:13 <edwardk> heh
06:23:21 <t7> shachaf: yes equirecursive is correct
06:23:26 <geekosaur> there *is* no cabal-install 1.16.0.3
06:23:29 <atriq> > let μέσος = 1 in μέσος
06:23:30 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
06:23:39 <atriq> There goes that idea
06:23:48 <dcoutts_> geekosaur: no, there's nothing wrong.
06:23:57 <shachaf> atriq: It works fine. lambdabot is just broken.
06:23:59 <Philonous> Ah, so you better not be greek if you want to program haskell
06:23:59 <geekosaur> I should not bother
06:24:07 <geekosaur> dcoutts_, I am not the one claiming something is wrong
06:24:15 <atriq> shachaf, ah, so it does
06:24:23 <geekosaur> someone in backscroll is trying desperately to fix cabal by installing cabal-install 1.16.0.3
06:24:34 <geekosaur> which afaict does not exist, that's the library version
06:24:43 <dcoutts_> geekosaur: oh ok, sorry I thought you were the one who was surprised by it
06:25:11 <geekosaur> (dgpratt, I think)
06:25:52 <shachaf> preview?
06:26:04 <dgpratt> geekosaur: yes, I conflated Cabal with cabal-install
06:26:12 <bgamari> Sonderblade, It should be perfectly possible to specify that it's a number
06:26:16 <edwardk> outOf ?
06:26:29 <bgamari> Sonderblade, It's determined by the type of the field
06:26:33 <shachaf> It's not really Ofy, is it?
06:26:38 <dgpratt> nevertheless I do think there's a problem with Cabal 1.16.0.2
06:26:42 <shachaf> Well, maybe.
06:26:43 <atriq> Why does Yesod depend on an old version of tls-extra?
06:26:46 <edwardk> > let outOf = view . from in outOf identity (Identity 12)
06:26:49 <lambdabot>   12
06:26:50 <bgamari> Sonderblade, I don't believe there is a parser for files, but that could be fixed easily enough
06:27:02 <shachaf> > let un = view . from in un identity (Ideneity 12)
06:27:04 <lambdabot>   Not in scope: data constructor `Ideneity'
06:27:04 <lambdabot>  Perhaps you meant `Identity' (im...
06:27:08 <edwardk> > let outOf = foldOf . from in outOf identity (Identity 12)
06:27:09 <dcoutts_> dgpratt: yes, the Prelude bug there is real, and one of the reasons for the .0.3 bug fix release
06:27:10 <lambdabot>   12
06:27:14 <bgamari> Sonderblade, I suspect a patch adding such functionality would be accepted
06:27:27 <edwardk> view = foldOf, there are other aliases for view
06:27:36 <edwardk> so lets target one of those aliases ;)
06:27:38 <shachaf> Right, and over = fmapOf and so on.
06:27:58 <shachaf> @ty let into = view in into Identity 5
06:28:00 <lambdabot>     Couldn't match expected type `s0 -> Accessor a0 t0'
06:28:00 <lambdabot>                 with actual type `Identity (a0 -> Accessor a0 b0)'
06:28:00 <lambdabot>     Expected type: Getting a0 s0 t0 a0 b0
06:28:10 <shachaf> @ty let into = view in into identity 5
06:28:11 <lambdabot> Num s => Identity s
06:28:20 <shachaf> That justifies outOf. :-)
06:28:34 <edwardk> =P
06:28:47 <shachaf> Actually that'll help me remember which direction isomorphisms lens in.
06:28:55 <edwardk> i'm oka with it in isolation without a direct opposite
06:29:06 <edwardk> i don't want any ore aliases for view, we have tons
06:29:19 <edwardk> (^$), view, (^.), foldOf, etc.
06:29:23 <edwardk> it gets old =)
06:29:24 <dgpratt> dcoutts_: what to do about the fact that the cabal-install I have (built against Cabal 1.16.0.2) is now not able to (re)build cabal-install?
06:29:48 <byorgey> edwardk: careful, you'll have to take all those out when lens is proposed for inclusion in the HP =P
06:30:04 <atriq> Who do I complain about  Yesod to?
06:30:10 <dcoutts_> dgpratt: can it build anything? or is it just Cabal, or cabal-install it can't?
06:30:14 <shachaf> atriq: #yesod, presumably.
06:30:15 <edwardk> byorgey: i think my reaction would be similar to bos's response to weber when he wanted to make all those changes to text =P
06:30:24 <shachaf> > let without = view . from in without identity (Identity 5)
06:30:26 <byorgey> edwardk: which was?
06:30:26 <lambdabot>   5
06:30:38 <byorgey> I mean, I only remember in a general sense
06:30:41 <edwardk> i think he more or less told weber to die in a fire ;)
06:30:44 <byorgey> hehehe
06:31:08 <byorgey> well, in any case, I was referring to split =)
06:31:22 <dgpratt> dcoutts_: I just built Cabal, it's cabal-install that's the problem
06:31:38 <Suprano> I just discovered that I can install cabal-dev using cabal
06:31:46 <dcoutts_> dgpratt: ok then, cabal unpack cabal-install, and install that one manually
06:32:04 <mapf> hm, ghci don't want to see my local package.
06:32:07 <edwardk> byorgey: https://github.com/bos/text/issues/23#issuecomment-4911924
06:32:19 <dgpratt> dcoutts_: ok, I'll try that in a bit, thanks for the help
06:32:39 <mapf> when i reinstall my old packages i have them in ghci but with fresh package i can't
06:32:58 <mapf> strange things happens out there
06:33:07 <byorgey> hehehe
06:39:21 <Marenz> trying to compile a project that has a .cabal file. The makefile does cabal-dev configure --cabal-install-arg='-fblaze_html_0_5' which fails  saying that dependencies are missing.. shouldn't that command install the missing dependencies?
06:40:00 <kranius> cabhell
06:40:11 <shachaf> Did I ever tell you that Edward A. K. / Had twenty-three types, and he named them all "a"?
06:41:29 <Marenz> ah, install-deps.
06:41:34 <Marenz> let's see what happens
06:41:37 <atriq> When I'm older I want to be edwardk
06:41:43 <rwbarton> Marenz: only if they are haskell library dependencies, as opposed to C libraries or executables
06:41:54 <atriq> Naming every one of my types "a"
06:42:07 <atriq> Aaargh, that doesn't scan
06:42:15 <edwardk> atriq: so you too can sit around all day trying to think up synonyms and antonyms?
06:42:15 <hpaste> Marenz pasted “Make prep fails” at http://hpaste.org/77657
06:42:27 <atriq> edwardk, precisely
06:42:37 <Marenz> there is actually cabal-dev install-deps, but it fails with the ujst pasted error
06:42:46 <Marenz> any idea what is going on there?
06:43:46 <atriq> Hang on, on that list of things going to be broken by the reinstalls is ghc-7.6.1
06:43:51 <atriq> I don't think I'll install that, then
06:44:52 <dgpratt> dcoutts_: one more question before I try this: do you agree with this approach: (1) cabal configure && cabal build (2) fix the broken auto-generated file (3) build manually via ghc (4) cabal install ?
06:45:44 <mapf> why ghc package is hidden?
06:46:19 <dever> is there a library that will efficiently split a list in half, something like a join list
06:46:33 <dever> there is data.join list, but that's not balanced
06:46:34 <atriq> mapf, because it contains only stuff that aren't relevant to people who just want to write some code
06:47:26 <rwbarton> also the module names aren't in any hierarchy or anything
06:48:20 <mapf> atriq: ok, how can i unhide the package then?
06:48:33 <mapf> i guess ghc-pkg is related?
06:48:58 <rwbarton> ghc-pkg expose or ghci -package ghc or use a .cabal file for your project
06:50:07 <shachaf> Probably ghc-pkg expose isn't really what you want.
06:50:19 <Marenz> cabal-dev install-deps fails with this error, any ideas? http://hpaste.org/77657
06:50:22 <shachaf> Well, if it's what you want, you ought to already know about it. :-)
06:50:26 <rwbarton> yes, those are in increasing order of goodness
06:51:02 <mapf> damn reconnections
06:51:04 <byorgey> dever: Data.Sequence ?
06:51:07 <geekosaur> mapf, why do you want the package to be visible?  generally, if you need it then you know what to do about it already
06:51:41 <byorgey> dever: it can do  splitAt i  in  O(log(min(i,n-i)))
06:52:23 <Marenz> hm even that fails: cabal install fsnotify   -> cabal: Couldn't read cabal file "fsnotify/0.0.1/fsnotify.cabal"
06:52:33 <atriq> Why doesn't Wordeger exist.
06:52:35 <mapf> geekosaur: heh, you are right. i just need to runGhc since a haddock function returns Ghc monad.
06:52:58 <atriq> Wordeger should exist.
06:53:19 <byorgey> atriq: what?
06:53:46 <byorgey> dever: http://hackage.haskell.org/packages/archive/containers/latest/doc/html/Data-Sequence.html
06:53:50 <atriq> byorgey, unbounded Word type
06:54:11 <atriq> Nat may work, but isn't it inefficient spacewise?
06:54:21 <byorgey> atriq: it depends how you define Nat.
06:54:25 <byorgey> there is no standard Nat.
06:54:44 <byorgey> if you use the "traditional" Peano construction, yes, it is very inefficient
06:55:06 <byorgey> atriq: so you want a nonnegative Integer type?
06:55:11 <atriq> Yes
06:55:45 <atriq> Numeric.Natural, is that good?
06:56:55 <byorgey> what package is that from?
06:57:00 <atriq> semigroups
06:57:07 <atriq> Where it really doesn't belong
06:57:12 <dever> byorgey: that might be what i'm looking for, though something non-finite/strict would be desirable. can't have everything though, thanks!
06:57:42 <byorgey> dever: non-finite/strict?
06:58:36 <byorgey> atriq: sure.  it is just a wrapper around Integer with dynamic checks though.
06:58:53 <atriq> Know of anything better?
06:59:00 <byorgey> dever: can you elaborate?  I'm not sure I know what you mean.
06:59:03 <scp> byorgey: I think that was non-(finite/strict)
06:59:03 <byorgey> atriq: nope.
06:59:15 <byorgey> scp: ah, that would make more sense
06:59:18 <dever> scp: has it
06:59:31 <dever> parentheses are important in all contexts
06:59:31 <byorgey> but how on earth do you expect to split something infinite in half?
06:59:50 <shachaf> byorgey: Down the middle, of course.
07:00:06 <byorgey> right, silly me
07:00:06 <typoclass> byorgey: just use a lens
07:00:20 <dever> sorry, that should be potentially infinite i guess.
07:00:24 <shachaf> Well, if you have a "list zipper" which is infinite in both directions, you can split it into two infinite lists easily.
07:00:30 <byorgey> import Control.Lens.Magic.HalfOfInfinity
07:00:47 <simpson> Also parity.
07:01:04 <shachaf> Cale: You should add FMList to lambdabot!
07:01:32 <edwardk> atriq: i had a good reason for shoenhorning it down in there at the time
07:01:36 <edwardk> er shoehorning
07:01:46 <Marenz> does installing fsnotify using cabal? work for you?
07:01:49 <Marenz> -?
07:04:27 <shachaf> edwardk: Don't feel bad about the Setter law thing -- I got it wrong when I alpha-renamed.
07:04:35 <edwardk> hahahah
07:04:43 <edwardk> fair nuff
07:05:04 <shachaf> It was a big patch with lots of names floating around!
07:05:28 <edwardk> dropping the split lenses. split already provides a little dsl for building them up
07:05:46 <typoclass> Marenz: does the file exist that is mentioned in line 6 of your paste?
07:05:49 <edwardk> yeah, it was enough to bump me off my perch at the top of the impact list ;)
07:05:50 <shachaf> It does?
07:05:52 <Sonderblade> bgamari: doesnt seem to have support for default arguments either, it cant be the best argument parsing library haskell has :)
07:06:02 <edwardk> :t Data.List.Split.condense
07:06:04 <bgamari> Sonderblade, It does
07:06:04 <lambdabot> Couldn't find qualified module.
07:06:20 <edwardk> it has lots of Splitter a -> Splitter a -- combinators
07:06:52 <Marenz> typoclass, not in the current path.. I am not sure what other path it might be relative to.
07:06:53 <bgamari> Sonderblade, Options.Applicative.Builder.value
07:07:13 <byorgey> Marenz: works for me.  Looks like your hackage.tar is corrupted, perhaps?
07:07:18 <bgamari> Sonderblade, In case you didn't get my earlier message, it is most certainly type safe
07:07:21 <byorgey> Marenz: try doing 'cabal update'
07:07:21 <Marenz> typoclass, not that I have the same error when I simply do cabal install fsnotify
07:07:33 <Marenz> bylzz, I did that before, doing it again now
07:07:43 <Marenz> I mean byorgey, sorry bylzz
07:07:52 <mapf> it seems that forbidding of non-explicit imports solves this problem: http://www.haskell.org/haskellwiki/Package_versioning_policy#Adding_new_modules
07:08:02 <mapf> and some others possible too
07:08:19 <edwardk> found all the split combinators in Fold. i'd missed them. maybe i'll keep split in. need to lensify the name though
07:08:24 <pauser> hi, i still can not find the problem here, http://hpaste.org/77658 . does anyone see what im doing wrong please ?
07:08:40 <typoclass> Marenz: hm ... what is "make prep"?
07:08:46 <bgamari> Sonderblade, looking at it adding a file parser could be a bit tricky as you don't have the ability to do IO in the parser (which I would argue is a good thing)
07:08:55 <typoclass> (is it part of fsnotify?)
07:09:10 <byorgey> pauser: (/)  can only be used on floating-point values, not on Integers
07:09:16 <mapf> pauser: Integer is not an instance of RealFrac
07:09:20 <Philippa> "snotify" - lovely image!
07:09:21 <byorgey> pauser: try  fromIntegral n / (-2)
07:09:27 <Marenz> typoclass, byorgey weird.. doing cabal update did make a difference now. make prep is just cabal-dev install-deps --cabal-install-arg='-fblaze_html_0_5'
07:09:39 <Marenz> cabal install fsnotify works now
07:09:49 <Marenz> make prep still had an error
07:11:22 <Peaker> Philonous, the closure stuff in distributed-process seems very tightly-coupled with everything in there :(
07:11:25 <Marenz> hmm dependencie conflict.
07:11:31 <Marenz> and compile error for fsnotify-0.0.1
07:11:37 <Peaker> separating it into its own little closure package could be nice
07:12:00 <dcoutts_> Peaker: it *is* separated
07:12:07 <pauser> ok here we go to the  next error, Cannot justify constraints in explicitly typed binding
07:12:15 <typoclass> Marenz: not sure if that plays a role, but the complaint was about the .cabal file of fsnotify 0.0.1, while 0.0.3 is the current version. after 'cabal update' it should at least try to get 0.0.3
07:12:30 <Peaker> dcoutts_, it seems coupled with all the remoting business
07:13:09 <Peaker> dcoutts_, I need to be able to serialize a function with its captured lexical scope into a data type, and then deserialize back into the function
07:13:19 <Peaker> dcoutts_, (regardless of distributed-process)
07:13:19 <dcoutts_> Peaker: the distributed stuff does rely on the closure stuff
07:13:35 <dcoutts_> Peaker: http://hackage.haskell.org/package/distributed-static
07:14:44 <dcoutts_> Peaker: and we separated because another project wanted to use it
07:14:45 <Peaker> dcoutts_, not sure why all the "Remote" related stuff is appropriate in that package?
07:15:11 <Peaker> or maybe that's just the documentation not up-to-date with the separation?
07:15:31 <pauser> sorry again but do you maybe know why is this happening http://hpaste.org/77660 .
07:15:33 <dcoutts_> Peaker: it talks about RemoteTable, do you mean anything else?
07:15:57 <Peaker> dcoutts_, yeah, I don't have anything related to "Remote" stuff, just need to serialize functions?
07:16:21 <dcoutts_> Peaker: well you need a function table (called here RemoteTable) to be able to serialise closures
07:17:25 <dcoutts_> Peaker: and you need this because we don't have the 'static' language extension.
07:17:27 <Peaker> I'll read the documentation for that
07:18:26 <dgpratt> phew! I think I have managed to extracate myself from the tarpit of Cabal-1.16.0.2!
07:18:41 <dgpratt> thanks again for your help, dcoutts_
07:18:50 <dcoutts_> phew
07:19:39 <Peaker> where's the TH stuff for static?
07:20:12 <dgpratt> alas my problems with the network package persist <sad_trombone.wav>
07:22:03 <dgpratt> anyone have an interpretation of this error: Loading package network-2.3.2.0 ... linking ... ghc.exe: C:\...\HSnetwork-2.3.2.0.o: unknown symbol `_acceptNewSock'
07:24:28 <Peaker> dcoutts_, all the automatic free-variable capture stuff via TH is in the distributed-process package, isn't it?
07:24:35 <Peaker> (that's the actually interesting part I need)
07:25:12 <dcoutts_> Peaker: well copy it. There's several ways to do that, so that part is not forced on everyone.
07:25:33 <sclv> there isn't really automatic free capture, I think?
07:25:58 <sclv> at least not how I think of it?
07:26:19 <sclv> since it only works on top level expressions with at most one bound parameter?
07:26:33 <sclv> Peaker: what are you trying to build exactly?
07:26:37 <dcoutts_> right, there's no magic
07:27:19 <Peaker> sclv, I want to cache lots of arbitrary computations in my project -- so I have a big LRU ByteString->ByteString store I update for the cache
07:27:34 <Peaker> sclv, with a Typeable/Binary wrapper around that to make it nice to cache arbitrary keys/value types
07:27:45 <Peaker> sclv, some of my values have functions inside them
07:28:18 <Peaker> I could cache in-memory and just use Typeable, then I could cache functions as well, but I want the caching framework to support persisting caches as well
07:28:35 <sclv> ah, gotcha. yeah. if you can declare those functions at the top level then you can do it.
07:28:47 <pauser> why does haskell give me this error Cannot justify constraints in explicitly typed binding in here http://hpaste.org/77662
07:29:05 <sclv> but you could also build something more flexible for your purposes by forcing the functions you want to cache to be tagged with, e.g., a unique string.
07:29:17 <Peaker> sclv, ah, all of those don't even have bound params, they're all in the form of:  \[someData...] -> ... free variables used here ...
07:29:50 <geekosaur> pauser, (1) that looks like hugs? (2) you're using parentheses wrong, invoking a numtiparameter funtion is not f(x, y, ...) it is (f x y ...)
07:29:58 <geekosaur> s/numtip/multip/
07:30:04 <Peaker> sclv, this is how I currently solve it: https://github.com/Peaker/bottle/blob/master/codeedit/Editor/Data/Infer.hs#L112  :-(
07:30:22 <Peaker> Along with: https://github.com/Peaker/bottle/blob/master/codeedit/Editor/Data/Infer.hs#L688
07:30:24 <Peaker> (yuck)
07:30:33 <rwbarton> pauser, you have parentheses in the wrong place anyways
07:31:15 <Peaker> This is before the closure transform: https://github.com/Peaker/bottle/blob/2d14dd20d119d93efa58e04c3abd3dd446a45520/codeedit/Editor/Data/Infer.hs#L280
07:31:20 <rwbarton> in any case I think you can just replace the whole thing by a use of quot
07:31:25 <rwbarton> > 3 `quot` (-2)
07:31:27 <lambdabot>   -1
07:31:31 <rwbarton> er
07:31:34 <rwbarton> > 3 `div` (-2)
07:31:35 <lambdabot>   -2
07:31:39 <rwbarton> div I guess
07:31:40 <sclv> Peaker: yep, yuck! :-)
07:31:55 <Cale> pauser: You're applying floor to fromIntegral, and in order to apply floor to a function parameter, you'd need an instance of the RealFrac class for functions.
07:32:14 <Cale> pauser: (but more or less, it doesn't make too much sense to do that)
07:32:26 <monochrom> if you're flooring anyway, skip fromIntegral
07:32:30 <Peaker> sclv, so it could be nice to just $(mkClosure ..) on that lambda and store that
07:32:39 <monochrom> err, nevermind, mistake
07:32:47 <sclv> if you could lift it so it took the free data as a parameter then sure...
07:32:58 <Marenz> Sigh. The problem comes down to ubuntu having only ghc 7.0.3 which requires filepath 1.2.0.0  while the package I try to install requires filepath == 1.3
07:33:04 <Peaker> sclv, ah, the closure stuff only works with explicit params?
07:33:18 <pauser> Cale: does not fromIntegral do that or how do i round in another way ?
07:33:27 <Marenz> and there seems to be no ppa for ubuntu uneiric
07:33:31 <Marenz> for a latter ghc
07:33:35 <Marenz> darn
07:33:54 <monochrom> this is why I completely skip ubuntu's ghc
07:33:55 <sclv> yeah -- it really generates a name, then serializes the "explicit environment" which is the first argument, and then you can just send the name + environment across the wire
07:34:15 <Marenz> monochrom, you install without package manager?
07:34:52 <monochrom> that's right. ./configure --prefix=/usr/local/ghc-7.4.2 is the new package manager
07:34:54 <rwbarton> pauser: if you're going to do it this way you need to apply fromIntegral before trying to divide by -2... you can't use (/) on Integers
07:35:07 <sclv> i imagine the same approach could make your stuff cleaner too, though...
07:35:11 <typoclass> Marenz: i'm not an ubuntu user, but i've heard it's very easy to install the regular binary fromt the ghc webpage
07:35:24 <Marenz> hmm
07:35:33 <Cale> pauser: If you want to do integer division, you probably want div or quot
07:36:02 <Peaker> sclv, maybe I ought to write some TH to find free variables, and serialize those
07:36:04 <Cale> pauser: What you're doing here is converting to some floating point representation (Double by default), dividing, and then rounding down
07:36:04 <pauser> this should work, right ? rounded n = floor $ fromIntegral n/(-2)
07:36:14 <monochrom> if you envision testing your stuff over several ghc versions, you will skip the universal repo, too
07:36:23 <Cale> yes, that should work
07:36:25 <sclv> Peaker: yeah, that sounds like a good approach. but I dunno how hard it is to find free variables with TH?
07:36:40 <Cale> (but I'm not sure it's really what you're trying to do)
07:36:48 <sclv> on the other hand, if you could, then that could be a better approach for distributed-process too?
07:37:01 <Peaker> sclv, it's not the only difficulty -- since I have many different types of closures, I need to somehow identify the specific closure and be able to dispatch to it from some global table, despite it not being top-level
07:37:36 <Peaker> I wonder if I have TH code deep inside somewhere, can it generate code in top-level context as well?
07:38:28 <sclv> don't think so -- it splices where it lives.
07:39:00 <sclv> if you have a monadic traversal, you can return all that stuff up in a state or writer...
07:39:06 <sclv> (and use the state to generate freshnames as you go)
07:40:00 <Peaker> sclv, I need to generate a global table and have access to it from all the nested slices
07:40:04 <Peaker> my TH foo is weak
07:40:15 <mapf> is it Reader? http://www.haskell.org/ghc/docs/7.2.1/html/libraries/ghc-7.2.1/src/Outputable.html#SDoc
07:40:30 <monochrom> no, not that one
07:40:38 <Peaker> is even TH invocation just an independent Q-on-IO monad computation, with no real way to "communicate" between them?
07:40:44 <Peaker> s/even/every
07:40:48 <monochrom> oh, maybe it is
07:40:51 <mapf> monochrom: why?
07:40:53 <pauser> Cale: Im trying to convert a number to a negative base number (base -2) http://en.wikipedia.org/wiki/Negative_base
07:41:08 <monochrom> because I misread the question
07:41:29 <Cale> pauser: You should probably be using divMod in that case
07:41:34 <mapf> ^_^
07:41:38 <Cale> > divMod 10 (-2)
07:41:40 <lambdabot>   (-5,0)
07:41:57 <Cale> > divMod 11 (-2)
07:41:59 <lambdabot>   (-6,-1)
07:42:02 <sclv> Peaker: erm I think so… you can cheat though since you have IO :-)
07:42:13 <Cale> > quotRem 11 (-2)
07:42:13 <sclv> So you can write to/read from some external store
07:42:15 <lambdabot>   (-5,1)
07:42:17 <mapf> because i cannot into english articles i guess...
07:42:21 <Peaker> sclv, yikes :)
07:42:32 <Peaker> sclv, can maybe unsafePerformIO newIORef or such, heh
07:42:33 <sclv> I recall that edwardk used this trick when he was doing TH for i18n
07:42:33 <Cale> maybe quotRem would be better, depending on how you want to treat the negative case
07:43:23 <Peaker> sclv, where is that code?
07:43:25 <sclv> I was thinking a file in /tmp even
07:43:38 <sclv> no idea.. i only heard about it, never saw it
07:44:00 <sclv> but you just remember that you have MonadIO and see what follows logically
07:44:16 <Peaker> I don't really want to use files or a hack like that
07:44:20 <Peaker> I might as well keep the sum type hack
07:44:31 <sclv> you can do hybrid things though -- use TH to extract the free variables (assuming you can)
07:44:39 <sclv> and then use runtime computation to act on them
07:45:01 <sclv> only some things need to be done at the base layer of staging
07:45:22 <sclv> on the other hand, if it ain't broke..
07:45:34 <Peaker> will reify work on a non-top-level thing?
07:45:45 <Peaker> I guess I can do the top-level approach..
07:45:55 <sclv> it should -- TH is interleaved with typechecking as I recall
07:45:55 <Peaker> floating functions outwards is not hacky, just boilerplatey
07:46:11 <sclv> QQ on the other hand run during the naming pass
07:46:16 <sclv> which give them their power but also their limits
07:47:19 <Peaker> for now maybe I'll just extract the awful boilerplate to its own module
07:47:52 * hackagebot hat 2.7.0.12 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.12 (OlafChitil)
07:48:04 <sclv> I'm just browsing the code for your project now -- looks fun
07:48:05 <edwardk> Peaker: i used a separate module that had a top level mutable mvar or ioref, then had the template haskell refernce that module, which stays loaded through the entire compilation process
07:48:19 <edwardk> that let me make splices for expressions and declarations share metainfo
07:48:24 <edwardk> within a module was all i needed
07:48:30 <edwardk> beyond a module this is unsound
07:49:01 <Peaker> ah, did you need unsafePerformIO newIORef?
07:49:11 <edwardk> yeah, with a NOINLINE wrapper
07:49:19 <Peaker> bummer
07:49:33 <edwardk> i used that and the current module name to get isolation
07:50:37 * Peaker nuked ~/.ghc just to enable profiling=True globally
07:51:02 <donri> can't you just cabal install --enable-library-profiling world
07:51:15 <Peaker> donri, reinstalls
07:51:22 <Peaker> cabal doesn't do them well
07:53:20 <monochrom> cleaning is better. why do you want unused old versions to stay around
07:56:29 <monochrom> @remember shapr hylo! That's the category theorist greeting.
07:56:30 <lambdabot> Done.
08:01:15 <mSSM> When doing a qualified import, modules which are not ambiguous can be called without the name given to the import? E.g. 'import qualified foo as f' gives me a module bar, but bar is not provided anywhere else, so I don't need to write 'f.bar' ?
08:01:36 <mauke> what
08:01:44 <mauke> first off, 'import qualified foo' is a syntax error
08:01:56 <mauke> second, what do you mean by "module"?
08:03:08 <otters> mauke: because foo doesn't start with a capital letter, or what?
08:03:20 <mauke> yes
08:03:44 <mSSM> mauke: sorry, I meant s/module/function
08:03:47 <otters> mSSM: when you import qualified everything you imported from that module must be prefixed with the prefix you gave it
08:03:56 <otters> s/qualified/qualified,/
08:04:08 <Cale> mSSM: Using qualified means that you must explicitly qualify the names imported by that line.
08:04:10 <typoclass> mSSM: hello, if you do "import qualified Foo as F", you'll have to write "F.abc" everywhere. if you do "import Foo as F", you can use both "F.abc" and "abc". (supposing abc isn't ambiguous)
08:05:10 <shapr`> dgpratt: It's looking for that symbol and can't find it in the .o file, not like that helps any :-)
08:05:41 <mSSM> otters: I am looking at some code, which uses the data structure MVector without giving the name.
08:06:22 <mSSM> otters: i.e., after a qualified import from Data.Vector.Unboxed.Mutable as U
08:06:57 <shachaf> What a pity that you're the only one looking at that code.
08:06:58 <otters> Really
08:07:16 <typoclass> mSSM: note that you can import the same module several times. so you could use "import X (somethingAmbiguous) ; import Foo hiding (somethingAmbiguous) ; import qualified Foo as F"
08:07:46 <mSSM> meh, pasting doesnt work: https://github.com/aivuk/Simple-Ising/master/ising.hs   look at line 11
08:08:02 <mSSM> oops
08:08:11 <quicksilver> apparently that's not the webpage you were looking for
08:08:12 <mSSM> meh, pasting doesnt work: https://github.com/aivuk/Simple-Ising/blob/master/ising.hs   look at line 11
08:08:14 <mSSM> now it works
08:08:29 <srhb`> mSSM: Not qualified.
08:08:29 <shachaf> I don't see the word "qualified" anywhere on that page.
08:08:34 <mSSM> Oh
08:08:34 <quicksilver> mSSM: note the absence of the word 'qualified'
08:08:40 <srhb`> Echo echo echo
08:08:42 <srhb`> :P
08:08:43 * mSSM hides in a corner.
08:08:46 <quicksilver> :)
08:08:52 <srhb`> mSSM: No wait, we'll find some more people to yell at us
08:08:56 <mSSM> Sorry :(
08:09:13 <otters> after searching on google, this is the only place I found another instance of the error I got
08:09:15 <otters> http://hpaste.org/76710
08:09:18 <typoclass> mSSM: don't worry :)
08:09:20 <mSSM> srhb`: I didn't yell :(
08:09:24 <otters> can't install bmp, anybody have ideas
08:09:28 <srhb`> mSSM: Sorry, I meant yell at YOU. :P
08:09:32 <srhb`> mSSM: And no, don't worry.
08:10:14 <mSSM> So the absensce of the word qualified when importing makes it s.t. I only need to use the name if there is ambiguity?
08:10:24 <Cale> mSSM: right
08:10:24 <srhb`> mSSM: Right.
08:10:29 <mSSM> Thanks :)
08:10:37 <Cale> mSSM: which is the default behaviour even if you didn't use 'as'
08:10:52 <Cale> ('as' just renames the import for when you do choose to qualify things)
08:11:57 <Cale> mSSM: It's also common to import some things twice
08:12:01 <Cale> mSSM: for example
08:12:09 <Cale> import qualified Data.Set as S
08:12:22 <Cale> import Data.Set (Set)
08:12:36 <Cale> Which avoids having to qualify the type name
08:14:12 <mSSM> Alright, cool
08:14:37 <mSSM> Cale: what's the point though?
08:15:12 <mSSM> Cale: to make sure to qualify the type name except for one function?
08:15:16 <Cale> mSSM: I guess it's just that qualified names in types are kind of ugly.
08:15:32 <otters> http://hpaste.org/76710
08:15:35 <geekosaur> otters: that should be in Data.ByteString.Lazy{,.Char8}
08:15:36 <mSSM> Ok, my wording was wrong ^^
08:15:36 <Cale> and a lot of the other stuff from that module conflicts with Prelude
08:15:41 <otters> yeah
08:15:42 <Cale> (and other modules like Data.Map)
08:15:47 <otters> I guess I'll take a look at the source of bmp
08:16:05 <monochrom> see my http://www.vex.net/~trebla/haskell/module.xhtml for the true meaning of "qualified"
08:16:07 <typoclass> mSSM: have you seen my previous example? "import X (somethingAmbiguous) ; import Foo hiding (somethingAmbiguous) ; import qualified Foo as F"
08:16:18 * geekosaur kinda snowed under with local stuff, sorry
08:16:43 <Cale> mSSM: If you import it normally, then you don't only have to qualify the uses of Set-things, you have to qualify the uses of Prelude-things, which sucks to have to do.
08:17:02 <typoclass> otters: BSL could refer to lazy bytestrings ... so maybe some version mismatch?
08:17:19 <otters> Guess we'll find out
08:17:58 <Peaker> interesting, after nuking ~/.ghc, cabal install OpenGL fails due to some type synonym instance issue
08:18:53 <monochrom> fromStrict is in Data.Text.Lazy only, these days. perhaps very old bytestring used to have fromStrict
08:18:55 <mSSM> typoclass: so you import somethingAmbiguous from X, then all Foo without somethingAbiguous, and finally you give everything from Foo the additional name F ?
08:19:39 <Cale> Personally, I preferred the way that the old versions of FiniteMap and Set used suffixes on names :P
08:19:46 <typoclass> mSSM: yes exactly. you can then use "F.somethingAmbiguous". you can also use the rest of Foo without "F."
08:19:51 <otters> @pl \x -> init x <$ listToMaybe x
08:19:52 <lambdabot> liftM2 (<$) init listToMaybe
08:20:01 <otters> well that's longer ;/
08:21:00 <mSSM> A different question: can I read up on PrimState somewhere? I have RealWorld Haskell next to me, but it doesn't go into primitives (which it seems to be a type in)
08:21:06 <scp> :t (<$)
08:21:08 <lambdabot> Functor f => a -> f b -> f a
08:21:22 <Cale> mSSM: What are you referring to by PrimState?
08:21:34 <scp> @src (<$)
08:21:35 <lambdabot> (<$) = (<$>) . const
08:21:44 <scp> :t <$>
08:21:46 <lambdabot> parse error on input `<$>'
08:21:47 <scp> :t (<$>)
08:21:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:21:53 <simpson> @where fix-cabal
08:21:53 <lambdabot> I know nothing about fix-cabal.
08:21:56 <simpson> Pfft.
08:22:34 <mSSM> Cale: The argument to MVector (being a constructor IOVector)
08:22:42 <dmwit> simpson: To fix cabal, throw money at dcoutts.
08:23:07 <dmwit> (or patches)
08:23:13 <Cale> mSSM: hmm
08:23:15 <shachaf> dmwit: How do I find my nearest dcoutts_ representative?
08:23:26 <dcoutts_> heh
08:23:36 <Cale> ah, that's apparently from here: http://hackage.haskell.org/packages/archive/primitive/0.5.0.1/doc/html/Control-Monad-Primitive.html
08:24:10 <Cale> I'm not sure you want to deal with that at all
08:24:32 <Cale> I'm not sure why MVector exposes it like that
08:25:38 <simpson> dmwit: I just wanted the magic incantation for "This thing that I have a .cabal file for, I wish to tell cabal to obtain a single set of working packages that I can build it against."
08:25:43 <mSSM> Cale: I am trying to understand the code I linked to above, which creates a newtype Grid = Grid { unG :: (Int, MVector (PrimState IO) Int) }
08:26:04 <dcoutts> simpson: cabal install --dry-run --only-dependencies
08:26:16 <simpson> dcoutts: Aha.
08:26:29 <simpson> Hm. Apparently the problem is that cereal-conduit is broken! Not cabal's fault.
08:26:32 <Cale> mSSM: yeah, just ignore that (PrimState IO) parameter -- it should just amount to meaning that the mutable vector is usable from IO
08:27:04 <Cale> I don't really understand why it's MVector (PrimState IO) Int and not MVector IO Int, but that's some detail about the design of the vector library.
08:28:25 <dmwit> simpson: The more I learn about cabal, the more often I find myself saying, "Oh, it's not cabal's fault.".
08:28:32 <mSSM> Cale: Found something stackexchange saying: MVector (PrimState IO) = MVector RealWorld = IOVector ... I guess I leave it at that
08:28:37 <Cale> In any case, it's just an implementation detail which is oddly leaking out in the types.
08:28:41 <mSSM> mSSM: Although I am not satisfied not knowing what's happening :D
08:29:00 <dgpratt> I've managed to solve my network package issue, too, I think, by doing the unpack/configure/build/register process manually
08:29:09 <simpson> dmwit: I find myself really wishing that Haskell packaging had implicit soname-like guarantees about API.
08:29:21 <Cale> mSSM: It's something which probably ought not to be happening, in this case.
08:29:34 <simpson> I mean, yeah, people make fun of libav.so.67, but you know what? *Nobody's* gonna link against the wrong libav.
08:29:42 <Cale> I don't see any good reason why it couldn't be parameterised directly on the monad being used.
08:30:12 <Peaker> How hard is getting GHC to identify packages by some unique hash of their dep unique hashes + its own version - rather than the version only as it is now?
08:30:38 <dmwit> Peaker: There was a GSoC doing exactly that.
08:30:42 <dgpratt> not sure why that worked, though; my best guess is that maybe the package cannot be built correctly under Cygwin and when I attempted to install under MSYS, some of the bad bits were not replaced until I did the manual process
08:31:08 <Peaker> dmwit, failed? in progress?
08:31:10 <simpson> Peaker: I'm thinking of dependencies. "I depend on bytestring ~api42, regardless of package version."
08:31:53 <monochrom> simpson: we are the last people to make fun of "libav.so.67". we have "HTTP-4000.2.5"
08:32:17 <rwbarton> how is that different from depending on bytestring == 0.42.*
08:32:25 <monochrom> exactly my point
08:32:52 * hackagebot awesomium-raw 0.1.0.0 - Low-level Awesomium bindings.  http://hackage.haskell.org/package/awesomium-raw-0.1.0.0 (MaksymilianOwsianny)
08:32:58 <monochrom> or >= 0.42, or <= 0.42, depending on what you mean
08:33:08 <simpson> rwbarton: bytestring's versioning doesn't actually work that way, does it? Also nobody writes their dependencies that way.
08:33:15 <typoclass> Peaker: i thought a new feature of cabal 1.16 was something with hashes?
08:33:31 <rwbarton> that is the way versioning is supposed to work and the way people are supposed to write their constraints
08:33:35 <simpson> Well, okay, some library authors do, and I appreciate it, but... :T
08:33:38 <Peaker> typoclass, the problem is in ghc, not cabal, where same package, same version, cannot be installed twice (For differing dep versions)
08:33:44 <rwbarton> @where PVP
08:33:45 <lambdabot> http://www.haskell.org/haskellwiki/Package_versioning_policy
08:33:54 <Peaker> Ideally you could depend on API signature (names, types, instances here)
08:34:02 <Peaker> rather than depending on particular implementations
08:34:03 <typoclass> Peaker: right
08:34:04 <Peaker> or version ranges
08:34:44 <monochrom> hashes have been with us since GHC 6.12
08:35:09 <Peaker> monochrom, do they also hash the dep hashes?
08:36:30 <Peaker> if so, what's the difficulty w.r.t same-version install of differing deps?
08:37:55 <monochrom> I don't know how to answer that. depends on your definition. with sufficiently aggressive optimizations, if X imports Y, X.hi has stuff from Y.hi, therefore X's hash is affected by Y's hash already
08:38:06 <t7> does idris have termination checking yet?
08:38:40 <KBme> hi again
08:38:54 <KBme> I don't understand how to handle an error with hdbc's prepare function
08:39:20 <KBme> I'm supposed to create a function that takes an error, and returns a hdbc statement, or … what are my alternatives?
08:40:12 <monochrom> the problem with same-version multiple instances: are you going to type in "import "OpenGL-2.6.0.1-107141f782eb8d6423de8c05cb4e51c9" Graphics.Rendering.OpenGL"?
08:41:13 <monochrom> also, 107141f782eb8d6423de8c05cb4e51c9 changes if you change one of: 32-bit vs 64-bit, optimization flags
08:41:44 <apfel> hi, i have some Problems with haskell, for example "function::[a]->[a]->Float" this function expects two lists as parameter and should return a float, or what does this mean exactly?
08:42:08 <quicksilver> apfel: that sounds correct, yes.
08:42:21 <quicksilver> two lists as parameters and returns a float.
08:42:34 <atriq> It means, if you give the function a list, it gives you another function, which if you give it a list, it gives you a float (which is a kind of number)
08:43:01 <quicksilver> which is the same thing. But mostly we talk about it as a function with two parameters.
08:43:12 <Peaker> monochrom, the import selection can be done as a flag to ghc, perhaps? which means it is a cabal rather than ghc issue?
08:43:15 <apfel> ah ok like in common lisp
08:43:18 <atriq> If at any point you give it the wrong type of thing, you probably won't even be able to compile it
08:43:27 <rwbarton> also the two lists have to have the same type of elements
08:43:40 <rwbarton> and that type can be any time the caller desires
08:44:24 <ski> apfel : note that the function can't actually look at the elements of the list, with that type signature. if you want the pass list of e.g. numbers which the function should be able to use, you'd need to change the type signature somewhat
08:44:57 <monochrom> a flag to GHC, sure, are you going to type in "ghc -package OpenGL-2.6.0.1-107141f782eb8d6423de8c05cb4e51c9"? or a line in myprog.cabal, sure, are you going to type in "depends: OpenGL-2.6.0.1-107141f782eb8d6423de8c05cb4e51c9"?
08:46:00 <efie> right now I have "import qualified Data.Vector.Unboxed.Mutable as MV and a function of type MV.IOVector Int -> IO (MV.IOVector Int)". The library also offers "STVector" ... I don't really know how ST works, if I used STVector instead of IOVector, would the function still have type IO ( ... ) as a result?
08:46:02 <apfel> ski: and how? or what do you mean exactly?
08:46:37 <rwbarton> I guess the intended use is to allow cabal to build a dependency foo-0.2 of my project against different versions of deps from the foo-0.2 I already have installed... then maybe cabal can hide the new foo-0.2
08:46:49 <Philonous> apfel:  [a] is a list of elements of a type which you don't know. If you want to do something with it, for example add them up, you need to have a more specific type
08:47:05 <rwbarton> though that hiding isn't really right I guess
08:47:06 <Philonous> apfel:  For example Num a => [a] or [Integer[
08:47:17 <rwbarton> if a future project wants to use both this project and foo-0.2 directly
08:47:17 <ski> apfel : when you write `function :: [a] -> [a] -> Float', you're promising that this function will work, regardless of what actual type the *caller* wants to use in place of the type variable `a'
08:47:21 <Philonous> [Integer]*
08:47:46 <ski> apfel : e.g. the caller might decide in one call to `function' that s/he want to pass two lists of strings, so `a' is `String' in that case
08:47:47 <apfel> ah ok
08:47:53 * hackagebot urlencoded 0.4.0 - Generate or process x-www-urlencoded data  http://hackage.haskell.org/package/urlencoded-0.4.0 (PhilipWeaver)
08:48:44 <ski> (the effective type signature for *that* call would then be `function :: [String] -> [String] -> Float')
08:49:03 <ski> apfel : in another case, s/he might decide to pass two list of integers, so `a' would in that call be `Integer' (and the effective type signature for that call would then be `function :: [Integer] -> [Integer] -> Float')
08:49:46 <ski> apfel : in each call, the *caller* decides on the type `a' (by passing a list with elements of some type) -- and in each call the two lists must have the same type -- though different calls can pass different pairs of lists
08:49:54 <ski> apfel : *however*
08:49:55 <dgpratt> if I have two packages of the same version, one installed globally, the other locally, is there potential harm in unregistering the local one?
08:50:43 <ski> apfel : while functions in Haskell can be *polymorphic*, i.e. they can work over multiple types, there's actually no way to *determine* (at run-time) what type an argument is
08:50:56 <monochrom> some other local package may have been built against the local one. that's the only breakage. but I do support nuking them all
08:51:15 <taneli> cabal can't install certificate-1.2.2: http://pastebin.com/gStd4jXS
08:51:18 <mauke> The paste gStd4jXS has been copied to http://hpaste.org/77667
08:51:21 <taneli> known problem, any solutions?
08:51:39 <ski> apfel : either the type signature already tells you the type of the argument, or it includes type variables, like the argument type `[a]' for function -- then the *only* thing `function' can know is that it's passed a list of some things -- it *can't* determine what type `a' is
08:52:35 <ski> apfel : this can often be a good thing, in that you can *know*, just by looking at the *type signature*, that the function can't "touch" some arguments (anymore than passing them around)
08:52:45 <dgpratt> monochrom: ok, thanks
08:53:06 <ski> apfel : .. and, if you really want to, there *are* ways to get around this (though usually one doesn't tend to want that)
08:53:20 <ski> apfel : anyway .. the end point
08:53:57 <ski> apfel : *if* you wanted to only pass a pair of lists of `Float's, then you have to say `function :: [Float] -> [Float] -> Float'
08:54:11 <dgpratt> I don't suppose there is a way to query what installed packages depend on package X? I've asked this before and gotten no answer, which makes me think the answer is "no".
08:54:13 <ski> apfel : *if* you wanted to only pass a pair of lists of `Integer's, then you have to say `function :: [Integer] -> [Integer] -> Float'
08:55:20 <ion> shachaf: Mkay, i managed to implement Bazaar and unsafePartsOf. Dunno if this implementation sucks in some way, but it seems to work. https://gist.github.com/4066949
08:55:31 <apfel> ski: ok thank you
08:55:59 <ski> apfel : if you wanted to allow both those, then one way is to say `function :: Num a => [a] -> [a] -> Float' -- the `Num a => ' part here means that the function promises to work for every type `a' which is in the type class `Num' -- roughly : it promises to work for every "numeric type" (types supporting addition, subtraction, multiplication (but not necessarily division), and a few more operations)
08:56:11 <taneli> dgpratt, "ghc-pkg dot" and then some grepping?
08:56:26 <ski> apfel : ok, i'm done. unless you have any questions re what i said (or anything else, really)
08:56:53 <shachaf> ion: Hah, you implemented partsOf in terms of FunList-style Bazaar?
08:57:05 <apfel> ski: thank you very much, i think i got it :)
08:57:11 <hpaste> efie pasted “STVector vs IOVector” at http://hpaste.org/77668
08:57:22 <dgpratt> taneli: an interesting idea, thanks; clearly this information is available, too bad it can't be queried in a more direct fashion
08:57:48 <ski> apfel : i'm not sure whether you need to use any of this yet. and possibly you didn't grasp it all yet. but it might be good to have some rough idea of what using type variables in type signatures mean, and what you can do depending on what you want
08:58:06 <taneli> might as well be, today's the first time I ever used ghc or cabal ...
08:58:20 <shachaf> ion: I guess that works. That implementation looks reasonable to me.
08:58:30 <quicksilver> efie: yes you can write it without IO in the signature.
08:58:38 <quicksilver> efie: you'll have ST in the signature instead.
08:58:50 <shachaf> ion: You can also do it directly with the normal Bazaar, i.e. newtype Bazaar a b t = Bazaar { runBazaar :: forall f. Applicative f => (a -> f b) -> f t }
08:58:57 <shachaf> I think it ends up being more efficient or something.
08:59:13 <quicksilver> if an IOVector operation has a type like write :: a -> IO v then the ST equivalent will be a -> ST v
08:59:24 <ion> shachaf: Oh, huh. That type looks more elegant, too.
08:59:52 <shachaf> ion: You can see that it's just a flipped Traversal: type Traversal s t a b = s -> forall f. Applicative f => (a -> f b) -> f t
09:00:11 <shachaf> Just like we had Lens s t a b = s -> Context a b t, Traversal s t a b = s -> Bazaar a b t
09:00:16 <rwbarton> taneli: looks like crypto-pubkey-types-0.2.0 broke certificate, try "cabal install certificate crypto-pubkey-types-0.1.1"
09:01:11 <Eduard_Munteanu> efie: you'd use it in the ST monad, then either extract a value from it or 'freeze' it to an immutable vector
09:01:49 <Philonous> rwbarton:  Do you know whether vinzenthz is in IRC?
09:01:52 * ski wonders whether `exists f. Applicative f *> (s,a -> f b)' would be useful
09:03:08 <rwbarton> i don't know
09:03:27 <vod1k> whats the ghc extension called that i can define types in classes/instances?
09:03:33 <efie> quicksilver: will I have ST Vectors2 in the type signature, or is ST hidden inside the declaration Vector2?
09:03:35 <vod1k> not sure if i worded that right
09:03:36 <shachaf> ski: Did you invent *>, by the way?
09:03:46 <monochrom> TypeFamilies
09:03:49 <vod1k> ty
09:04:04 <efie> I don't know what to replace s with in "type STVector s = MVector s"
09:04:36 <Eduard_Munteanu> efie: you don't, you simply type it like that
09:04:37 <rwbarton> don't replace it
09:07:13 <Eduard_Munteanu> efie: are you familiar with the ST monad? Perhaps you should start there.
09:07:31 <efie> no, I'm not :)
09:07:47 <ski> is `Souk' defined by `newtype Souk b t a = MkSouk {runSouk :: forall i. Applicative i => (a -> f b) -> f t}' an indexed applicative functor ?
09:08:37 <quicksilver> efie: you could define type Vector2 = ST Vector if you wanted
09:08:59 <quicksilver> efie: but that isn't what you want, because that won't be the type of parameters, only return values.
09:09:31 <quicksilver> ST is just as bad as IO in terms of "polluting" all your types and mandating a monadic style - because it's really mutation, it works the same way.
09:09:34 <Eduard_Munteanu> efie: http://www.haskell.org/haskellwiki/Monad/ST   -- this might help
09:09:42 <quicksilver> the advantage of ST is that you can run it purely, using runST
09:09:53 <rwbarton> ski: forall i. ... f ... f ?
09:09:56 <quicksilver> and "outside" the runST commands there will be no ST types.
09:10:29 <Peaker> bummer, lens-using code needs explicit type signatures because of Rank2..
09:10:32 <ski> oops, incomplete name change, rename whichever to the other
09:10:39 <Peaker> (without directly using any rank2 stuff)
09:10:49 <edwardk> Peaker: you can work around it with cloneLens carefully applied
09:10:59 <edwardk> or with the combinators from Control.Lens.Loupe
09:11:25 <Peaker> edwardk, I don't mind the types, just spent about 10 minutes wondering why my code doesn't type-check, when the MR is not relevant :)
09:11:51 <Peaker> edwardk, especially with lens, I don't really fully understand all the types you use there -- so I often just use the values I know are correct and try to see if ghc's guess is good enough
09:12:04 <edwardk> the only time you need to use rank2 types is when you actually reuse the lens multiple times inside the function in different capacities. that actually turns out to be a sign you probably wanted a different lens combinator that covered both how you read and wrote ;)
09:12:16 <Peaker> edwardk, indeed, that might be :)
09:12:39 <Peaker> edwardk, I have: data Property m a = Property { pGet :: a, pSet :: a -> m () }
09:12:39 <edwardk> when in doubt, if you use a lens 'l' multiple times in a function, cloneLens it at each call site, and it'll just work
09:13:08 <Peaker> edwardk, I have a composeLens :: SimpleLens b a -> Property m a -> Property m b
09:13:38 <edwardk> hrmm trying to understand how that works
09:14:01 <edwardk> get can get an a out of the b, and to set we do what?
09:14:09 <ski> s/pGet :: a/pGet :: m a/ ?
09:14:13 <taneli> rwbarton, thanks now it compiles ok
09:14:15 <efie> At first I had a normal, unmutable Vector and whenever I had to modify it I used runST ( ... thawing, using mutable write function, freezing ) which looked nicer, but then I tried using mutable IOVector and put all the functions in IO which is ugly, but twice as fast ... ?
09:14:39 <Peaker> edwardk, Property's are immutable/single-shot, it's "pValue", not "pGet" actually
09:14:51 <ski> efie : possibly since the thawing and freezing copies it
09:14:52 <efie> I didn't do any freezing and thawing
09:14:53 <Peaker> edwardk, and set is just some monadic action to set the value (for the next iteration which will regenerate the property)
09:15:15 <efie> ski: um yes, I also tried usnafeThaw, but it did not help
09:15:24 <efie> respectivly still was slower
09:15:24 <edwardk> trying to understand how your new set works though.
09:15:35 <Peaker> edwardk, ah, it uses the old value for background
09:15:46 <Peaker> Property (Lens.view lens val) (setter . flip (Lens.set lens) val)
09:16:05 <Peaker> (val is the pVal, setter is the PSet)
09:16:21 <edwardk> ok, lets edit this then
09:16:40 <edwardk> you can use Property (Lens.view (cloneLens lens) val) (setter . flip (Lens.set (cloneLens lens)) val)  -- or
09:16:43 <Eduard_Munteanu> efie: unsafeFreeze too?
09:17:02 <ski> @hoogle runSTArray
09:17:02 <lambdabot> Data.Array.ST runSTArray :: Ix i => (forall s. ST s (STArray s i e)) -> Array i e
09:17:08 <Peaker> edwardk, yeah, got a weird context thing in my type then :)
09:17:09 <ski> is there any equivalent for vectors ?
09:17:14 <efie> Eduard_Munteanu: yes
09:17:16 <edwardk> we can use Property (val^#lens) (setter . flip (storing lens val))
09:17:38 <Peaker> edwardk, so ^# and storing are like view and set that clone lens?
09:17:49 <edwardk> ^# and storing are designed so they work on the same lens without cloning first
09:18:05 <edwardk> basically ^#foo = ^.cloneLens foo
09:18:06 <Peaker> Loupe?
09:18:15 <edwardk> type Loupe s t a b = LensLike (Context a b) s t a b
09:18:29 <edwardk> its just a Lens that has already picked its functor to be one that characterizes the entire lens
09:18:30 <atriq> Loupe is a magic lenslike that's actually equivalent to a lens
09:18:36 <Peaker> edwardk, quite a types' build up in there :)
09:18:44 <edwardk> you can cloneLens to promote a Loupe to a Lens
09:19:15 <Peaker> I'm just using the explicit type: composeLens :: Lens.SimpleLens s a -> Property m s -> Property m a
09:19:21 <edwardk> type Loupe s t a b = (a -> Context a b b) -> s -> Context a b t
09:19:47 <edwardk> i'd pass SimpleLoupe s a  -- that avoids the rank 2 type requirement, and lets you compose easier without rank2 types elsewhere
09:19:50 <ManoloMtnez> Hello, I am having problems using cabal to install packages. I'm using 1.16.0. To be sure it's not some problem of my install, I rm -r .cabal and .ghc; run cabal update, then cabal install pandoc, and the outcome is this:  http://sprunge.us/VXee
09:19:54 <edwardk> any Lens can be used as a Loupe
09:20:16 <edwardk> any Loupe can be cloned to repromote it to a Lens, but it can also be returned in a list, or monad, while a lens being higher rank would require impredicative types
09:20:31 <Peaker> edwardk, What's a Context?
09:21:05 <edwardk> data Context c d a = Context (d -> a) c  -- is the indexed version of the store or state-in-context comonad
09:21:44 <edwardk> basically passing a Loupe "Context id" as its argument gives you s -> Context a b t -- which is a data-lens style lens
09:22:01 <rwbarton> ManoloMtnez: I think pandoc just does not support ghc-7.6 yet
09:22:43 <efie> Eduard_Munteanu: but to check if I get you right; STVector is as bad as IOVector in terms of pullting the types (to quote quicksilver), theres no real difference concerning this - runST can be used on any other Vector types, for example the normal, unmutable vector, to allow to do modifications niclier. it does not require a Data.Vector.Mutable like IOVector or STVector, this is not related at all?
09:22:47 <ManoloMtnez> rwbarton: oh, ok. I should downgrade ghc and start again, right?
09:22:58 <edwardk> the combinators in Control.Lens.Loupe exist because some folks don't need the good interop between lenses and traversals, and would rather have the ability to stuff lenses in containers or reuse it without the signatures or explicit cloning.
09:23:06 <rwbarton> ManoloMtnez: yes, that will be much easier
09:23:13 <ManoloMtnez> rwbarton: thanks
09:25:32 <edwardk> the name is a pun on a 'jeweler's loupe' -- a simplified portable set up for using a lens that doesn't offer much functionality, but is very portable ;)
09:26:00 <edwardk> its also blessedly short compared to ConcreteLens or whatever =P
09:26:07 <edwardk> which sounds pretty opaque to me anyways
09:26:25 <atriq> I've found a bug in -Wall
09:26:47 <atriq> It's to do with shadowing in nested case expressions
09:27:59 <Peaker> edwardk, ok, thanks for the help :)
09:30:02 <mapf> -Wall is pretty annoying sometimes
09:30:38 <simpson> :t (.=)
09:30:39 <lambdabot> MonadState s m => Setting s s a b -> b -> m ()
09:31:28 <atriq> It says I'm shadowing something which isn't in scope
09:32:41 <Peaker> (view f &&& view g)  is nicer as...?
09:32:47 <atriq> http://hpaste.org/77671
09:33:10 <atriq> ^^^ the (unfinished) program where the bug occurred
09:33:21 <atriq> :t (view ?f &&& view ?g)
09:33:23 <lambdabot> (?f::Getting c b t c b1, ?g::Getting c' b t1 c' b2) => b -> (c, c')
09:35:30 <shachaf> atriq: What's the bug?
09:35:51 <shachaf> Not that I'd blame GHC for getting confused, with code like that.
09:36:11 <atriq> Heh, I know my code is awful
09:36:22 <atriq> May I paste -Wall's warning in the channel? it's three lines
09:36:26 <rwbarton> it is shadowed
09:36:29 <shachaf> But there is a case of remainder2 being shadowed there.
09:36:37 <shachaf> Defined on line 83 and again on 86
09:36:38 <rwbarton> on lines 83/86
09:37:02 <atriq> If you rename it to remainder3 on line 86, remainder2 is not in scope later in the line
09:37:17 <atriq> Oh wait
09:37:27 <atriq> I didn't see 83
09:37:32 <shachaf> tibbe: inline isn't in GHC.Prim
09:37:38 <shachaf> Try GHC.Exts (or GHC.Magic)
09:37:40 <atriq> It's my stupidity, not -Wall, to blame
09:38:08 <tibbe> shachaf: bah, the docs are bad then
09:38:18 <dmwit> Peaker: It was successful as far as I know. There's a talk about it on YouTube somewhere, searching...
09:38:35 <Peaker> dmwit, we still have a problem with same-pkg-same-ver though?
09:38:46 <atriq> Thanks for putting up with my idiocy
09:38:53 <shachaf> tibbe: GHC.Prim docs are pretty terrible because it's not a real module.
09:39:02 <shachaf> Well, not that that's too much of an excuse.
09:39:15 <tibbe> shachaf: I know
09:39:20 <shachaf> tibbe: Anyway, GHC.Magic is a module that exists only to define inline. But the documentation in .Magic says to import it from .Exts.
09:39:22 <tibbe> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/special-ids.html
09:39:31 <dmwit> Peaker: No, he also hacked on GHC itself.
09:39:42 <tibbe> ^^ those docs suggests that inline might be in Prim
09:39:43 <dmwit> Peaker: http://www.youtube.com/watch?v=h4QmkyN28Qs
09:39:52 <shachaf> tibbe: Ah, I see. Yep, looks wrong.
09:40:02 <tibbe> Igloo: Could we fix http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/special-ids.html to describe how to actually use these magic functions?
09:40:33 <Peaker> dmwit, so that problem has moved to cabal?
09:40:36 <shachaf> tibbe: To be fair, they *are* descired in the .Prim documentation.
09:40:43 <shachaf> They're just not defined there. :-)
09:40:44 <dmwit> Peaker: huh?
09:40:46 <shachaf> Pretty unhelpful.
09:40:54 <tibbe> shachaf: right
09:41:02 <Peaker> dmwit, Well, afaik, we still cannot reinstall a package just to be built with different dependency versions and have that coexist
09:41:04 <tibbe> shachaf: but that makes it even more confusing!
09:41:17 <dmwit> Peaker: Yes, that will change Real Soon Now.
09:41:24 <Peaker> dmwit, oh, awesome
09:41:26 <shachaf> tibbe: This is why I import every module I might ever possibly have a use for in my .ghci
09:41:33 <shachaf> Then I can :i foo to find out where foo realy comes from.
09:41:55 <shachaf> I suppose it's just a poor man's Hoogle.
09:42:06 <johnw> shachaf: doesn't that make ghci annoying to use because of conflicts in "map", etc?
09:42:11 <Peaker> it should make the conservative version constraints much more usable
09:42:21 <shachaf> johnw: I import things like that qualified.
09:42:30 <Peaker> shachaf, :i Word8  will not say Data.Word but GHC.something :(
09:42:37 <johnw> shachaf: that's not a bad idea
09:42:40 <shachaf> Peaker: I know! It's terrible.
09:42:47 <shachaf> Peaker: And GHC has that information available, too.
09:43:00 <shachaf> You can get error messages where it says "blah, import from ..., defined in ..."
09:43:16 <shachaf> Peaker: I looked into patching ghci to add that information, but got lost in GHC code.
09:43:36 <shachaf> I ended up accidentally reading type checker code for a while.
09:43:45 <Peaker> hehe
09:44:55 <dmwit> ?ask Igloo if he's changed the file permissions on the Trac installation so dcoutts can give me permissions on the gtk2hs Trac
09:44:55 <lambdabot> Consider it noted.
09:46:13 <hiptobecubic> Why does the C++ community refer to a "function object" (read: struct with operator()) as a "functor". It's not the same as we use the term is it? Am I missing the relationship? To me it just looks like a function.
09:46:35 <johnw> in C++, functor = callable object
09:46:39 <johnw> it is very unfortunate, yes
09:46:46 <hiptobecubic> gross
09:47:20 <johnw> it would be as though Haskell had called the first argument to fmap the "afunctor"
09:47:53 <monochrom> God, "cabal remove"
09:47:57 <hiptobecubic> No i see. It's terrible. yes.
09:48:27 <shachaf> johnw: It would be like confusing the object map part of the functor with the morphism map part of the functor!
09:48:35 * shachaf actually has no idea what's being discussed.
09:48:38 <johnw> yes, exactly
09:48:49 <johnw> but even worse
09:48:59 <hiptobecubic> I'm confused about why haskell doesn't use nix to manage packages. It seems like exactly the right thing
09:49:03 <johnw> since in C++ the functor isn't the mapper between categories, it's the thing mapped -- and only for morphisms!
09:49:06 <Nimatek> The C++ terminology is very confusing in that regard.
09:49:13 <typoclass> it would be like having a keyword "class" for something that is entirely different from the well-established sense of "class" ;-)
09:49:21 <hiptobecubic> johnw, what do you mean?
09:49:24 <johnw> typoclass: lol
09:49:54 <Nimatek> But you have to forgive them, they're trying to adopt as many functional concepts as they can get. Some cargo culting happens.
09:50:13 <dmwit> typoclass: Yeah, C++ classes aren't proper classes at all! Much more like plain old sets.
09:50:20 <simpson> They're structs.
09:50:37 <johnw> hiptobecubic: a functor maps a->b to F(a->b).  Well, you pass a C++ "functor" to std::for_each, to apply it to every element of a vector.  This is like a functor mapping of the function (here called "functor") onto the vector
09:50:44 <simpson> By spec, the only difference between a struct and a class, in C++, is that structs are public by default, and classes are private.
09:51:12 <hiptobecubic> hmm
09:51:37 <dagano> i have a small question...
09:51:47 <shachaf> johnw: I don't think the usage is related.
09:51:52 <johnw> dagano: we have a combinatorially large answer
09:51:59 <shachaf> But anyway this sounds like a great topic for ##make-fun-of-c++
09:52:01 <johnw> shachaf: no, it's really not, because types aren't involved in any way
09:52:10 <dagano> why does zipWith (+) [1..10] [10..1] give me the empty list?
09:52:18 <johnw> shachaf: I'm just trying to envision what the ultra-thin connection could have been
09:52:21 <Eduard_Munteanu> > [10..1]
09:52:22 <lambdabot>   []
09:52:26 <dmwit> > [10,9..1]
09:52:27 <lambdabot>   [10,9,8,7,6,5,4,3,2,1]
09:52:29 <nyc> dagano: [10..1] is empty
09:52:39 <dagano> woah it is?
09:52:46 <hiptobecubic> :t fmap
09:52:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
09:52:48 <johnw> [10,9..1]
09:52:51 <johnw> that's what you wanted
09:52:54 <johnw> as dmwit said
09:52:56 <dagano> ah yes duuurrh
09:53:01 <dagano> thanks
09:54:06 <hiptobecubic> so if the vector is the actual functor, what is fmap/for_each?
09:55:16 <dmwit> The vector and the for_each together are the functor.
09:55:26 <hiptobecubic> ah
09:55:34 <hiptobecubic> (fmap f)
09:55:41 <hiptobecubic> is a functor then?
09:55:49 <hiptobecubic> sorry
09:55:51 <hiptobecubic> otherway
09:55:58 <dmwit> A functor has two pieces: a piece mapping types to types, and a piece mapping functions to functions.
09:55:58 <johnw> hiptobecubic: as long you don't mean the vector is the functor, but the vector template
09:56:15 <johnw> template <class T> std::vector<T> would be the object mapper part of the functor
09:56:37 <dmwit> In Haskell, this is represented in an instance Functor declaration by giving a type constructor in the instance head and an implementation of fmap in the class body.
09:56:38 <johnw> std::for_each() could in some way be considered the morphism mapper
09:56:41 <hiptobecubic> because it goes from T to f T?
09:56:53 <johnw> however, std::for_each won't change T, so it's not
09:56:58 <johnw> hiptobecubic: exactly
09:57:16 <johnw> std::for_each is only a mapper for endomorphisms of T
09:57:22 <hiptobecubic> and for_each is only endo
09:57:26 <hiptobecubic> yes
09:57:47 <shachaf> And *also* for_each has very little to do with the C++ use of the word "functor".
09:57:57 <shachaf> Lots of things are called "functors" even if they're not passed to for_each.
09:58:47 <hiptobecubic> well there's actually "transform" which i think is more like an actual functor (together with vector<T>)
09:58:56 <johnw> shachaf: yeah, that's a great point
09:59:06 <hiptobecubic> it can also change types
09:59:15 <johnw> and you could make an argument for functor laws too, if you don't use mutation at all, and you define a composition utility; but as shachaf said, this only works for a limited subset of uses of the word "functor"
09:59:34 <hiptobecubic> What else is called a 'functor' then?
09:59:43 <johnw> any callable thing, actually
09:59:45 <hiptobecubic> Because i feel like i understood this before
09:59:47 <hiptobecubic> and now i don't
09:59:50 <shachaf> It has nothing to do with category theory!
09:59:52 <hiptobecubic> or so really... just function
09:59:56 <johnw> yep
09:59:59 <hiptobecubic> or... callable rather
10:00:04 <johnw> C++ functor == CT arrow
10:00:04 <shachaf> They just happened to recycle a word. People do that all the time.
10:00:15 <shachaf> No, not really.
10:00:17 <hiptobecubic> That is terrible. What was wrong with 'function' ?
10:00:19 <johnw> no?
10:00:29 <shachaf> At least, I don't know what kind of category you're thinking of here.
10:00:32 <johnw> hiptobecubic: nowadays we do use std::function and lambda "functions"
10:00:42 <shachaf> But that's enough C++ in #haskell for one day for me.
10:00:54 <johnw> shachaf: I'm thinking of the category of Cpp
10:01:04 <hiptobecubic> It was more an algebra question :)
10:01:15 <johnw> hiptobecubic: yeah, if you want to discuss this further, meet me in ##categorytheory
10:01:19 * shachaf >=>
10:02:05 <apfel> i got: ERROR "onlyNonSquares.hs":6 - Syntax error in declaration (unexpected `}', possibly due to bad layout), but there is no line 6 in this File, i reopend the file and rewrote it somewhere else but without success, what could that be? im using hugs on linux
10:02:50 <ski> @where on-functors
10:02:50 <lambdabot> "On Functors" (in C++,Standard ML,Haskell,Prolog) by James Coplien in 2010-05-17 at <http://www.catonmat.net/blog/on-functors/>
10:02:53 <ski> hiptobecubic ^
10:03:39 <rwbarton> apfel: is there a line 5?
10:03:48 <hiptobecubic> ski, thanks
10:06:37 <Cale> hiptobecubic: There's no good reason for function objects to be called functors in C++
10:06:52 <johnw> Cale: join us in ##categorytheory!
10:09:59 <Tehnix> does anybody know how to convert from type MD5Digest to String?
10:10:16 <hiptobecubic> Tehnix, does it have a Show instance?
10:10:33 <Tehnix> the MD5Digest?
10:11:00 <simpson> Yes.
10:11:15 <simpson> If it does, then show :: MD5Digest -> String -- would work just fine.
10:11:56 <Tehnix> argh -.-, yeah, heh completely overlooked that fact, thanks :)
10:12:02 <apfel> rwbarton: yes but there is no "}"
10:12:18 <dmwit> apfel: (possibly due to bad layout)
10:12:22 <rwbarton> apfel: probably you have unbalanced parentheses or something like that
10:12:36 <dmwit> Why not just paste the file to hpaste or similar?
10:12:41 <dmwit> If there's no line 6, it can't be that long.
10:14:05 <malik> can someone explain why this happens, and if it's ok to use -XNoMonomorphismRestriction flag to suppress it?  http://hpaste.org/77672
10:14:29 <dmwit> ?wiki MonomorphismRestriction
10:14:29 <lambdabot> http://www.haskell.org/haskellwiki/MonomorphismRestriction
10:14:35 <hpaste> apfel pasted “onlyNonSquares” at http://hpaste.org/77673
10:14:44 <byorgey> malik: yes, it's fine to use NoMonomorphismRestriction
10:14:58 <byorgey> In fact, for beginners I recommend always turning it on.
10:15:15 <dmwit> apfel: otherwise needs an = after
10:15:29 <dmwit> apfel: There's miscellaneous other bugs as well, but at least that will get it to parse.
10:15:36 <byorgey> for experts I recommending also using NoMonomorphismRestriction unless you understand why you want the MR
10:15:54 <apfel> dmwit: thanks
10:16:07 <ski> malik : you can add `{-# LANGUAGE NoMonomorphismRestriction #-}' to the top of a file to disable it in that file
10:16:26 <malik> byorgey: ski thanks
10:16:40 <simpson> @test \depth -> 2 ^ depth / 2 ^ (depth + 1) - 1 == -1/2
10:16:40 <lambdabot> Maybe you meant: let list tell
10:16:52 <simpson> Bleh.
10:16:57 <malik> ski is that the prefered way ?
10:17:17 <ski> @check \depth -> abs ((2 ^ depth / 2 ^ (depth + 1) - 1) - (-1/2)) < 10 ^ (-7)
10:17:19 <lambdabot>   Not in scope: `myquickcheck'
10:17:36 <ski> malik : if you want to disable it per-file, yes
10:17:55 * hackagebot awesomium 0.1.0.0 - High-level Awesomium bindings.  http://hackage.haskell.org/package/awesomium-0.1.0.0 (MaksymilianOwsianny)
10:18:00 <simpson> ski: I'm not reading that wrong though, right? That's always going to result in -1/2 for integral depth? I think that somebody forgot some parens.
10:19:15 <ski> malik : the other two options to defuse it is to either (a) add a type signature for  insert'  ; or (b) eta-expand the definition into  insert' a as = insertBy' compare a as  (adding at least one argument pattern to the left of `=' suffices)
10:19:50 <dmwit> Cale: ?check doesn't seem to be working
10:20:26 <ski> simpson : `2 ^ depth / 2 ^ (depth + 1)' looks like it should be `1 / 2', yes
10:20:46 <Peaker> can I compose "fmap" itself as a lens to see into a Functor?
10:20:49 <simpson> ski: Mm. git confirms that I wrote that; I should have picked a better time than 2AM to do maths.
10:20:52 <Peaker> I have:  Lens.over x . fmap . Lens.over
10:21:02 <ski> simpson : perhaps `2 ^ depth / (2 ^ (depth + 1) - 1)' (or something else ?) was wanted ?
10:21:04 <Peaker> oops:  Lens.over x . fmap . Lens.over y  <-- can I compose it nicely?
10:21:54 <ski> > [2 ^ depth / 2 ^ (depth + 1) - 1 | depth <- [0 .. 3]]
10:21:56 <lambdabot>   [-0.5,-0.5,-0.5,-0.5]
10:22:39 <simpson> > [2 ^ depth / (2 ^ (depth + 1) - 1) | depth <- [0 .. 3]]
10:22:40 <lambdabot>   [1.0,0.6666666666666666,0.5714285714285714,0.5333333333333333]
10:23:44 <simpson> > [1/1, 2/3, 4/7, 8/15]
10:23:46 <lambdabot>   [1.0,0.6666666666666666,0.5714285714285714,0.5333333333333333]
10:23:53 <simpson> Welp, that does it.
10:24:37 <ski> > [2 ^ depth / 2 ^ (depth + 1) - 1 :: Rational | depth <- [0 .. 3]]
10:24:38 <lambdabot>   [(-1) % 2,(-1) % 2,(-1) % 2,(-1) % 2]
10:24:47 <ski> > [2 ^ depth / (2 ^ (depth + 1) - 1) :: Rational | depth <- [0 .. 3]]
10:24:49 <lambdabot>   [1 % 1,2 % 3,4 % 7,8 % 15]
10:25:23 <simpson> I'm scaling numbers with max [1, 1.5, 1.75, 1.825, ...]
10:25:28 <simpson> So that would work just fine.
10:25:53 <Cale> dmwit: Yeah, I heard
10:26:05 <Cale> I'll have to look at that at some point
10:26:33 <dmwit> okay, sorry for the noise, then
10:27:25 <jmcarthur> Peaker: i can't imagine fmap alone being sufficient to create a lens. lenses need to be able to project information out, too, not just modify in place.
10:27:39 <Peaker> jmcarthur, I realized I just need Lens.sets fmap
10:27:46 <Peaker> @type sets fmap
10:27:47 <lambdabot> (Functor f1, Settable f) => (a -> f b) -> f1 a -> f (f1 b)
10:29:18 <Peaker> jmcarthur, you have get-only/set-only lens as well
10:29:26 <Peaker> (just for nice composition)
10:30:04 <scp> Does the following "count" as pointfree?
10:30:25 <scp> f = g a where a = someExpr
10:31:03 <ski> i suppose `someExpr' mentions `a'
10:31:26 <scp> does the answer change depending on whether it does?
10:31:34 <ski> i don't think so
10:31:57 <scp> I guess, a more succinct version of my question is, does "point free" mean "without lambdas"?
10:31:58 <ski>   f = g . fix $ \a -> someExpr  -- alternate way of saying the same thing
10:32:14 <Philippa> what's the preferred way to take the Platform and then upgrade your GHC version (rebuilding the libs) on Windows?
10:32:24 <ski> it means you don't talk about "points" iow individuals
10:32:57 <ski> whether you would could a (extra) function argument a "point" is partly a matter of taste, i think
10:33:04 <ski> s/could/count/
10:33:09 <apfel> can someone give me some hints? -> http://hpaste.org/77674
10:34:21 <rwbarton> looks like you pasted the wrong code
10:35:23 <ski> apfel : s/otherwise/otherwise =/
10:36:16 <ski> apfel : also, are you sure you want to return a list of numbers of a different type than you pass in (yes or no) ?
10:36:29 <apfel> yes
10:36:49 <ski> finally, instead of saying
10:37:05 <ski>   onlyNonSquares xl = ..(head xl)..(drop 1 xl)..
10:37:12 <scp> onlyNonSquares = filter (not . ((==) =<< (join (*) . floor . sqrt . fromIntegral)))
10:37:13 <ski> you ought to say something like
10:37:24 <edwardk> Peaker:  Lens.over (x.mapped.y)
10:37:31 <ski>   onlyNonSquares (x:xl) = ..xl..xl..
10:37:36 <Peaker> edwardk, mapped = sets fmap?
10:37:39 <edwardk> sets fmap = mapped
10:37:41 <ski> er
10:37:41 <edwardk> yeah
10:37:44 <Peaker> cool
10:37:49 <ski>   onlyNonSquares (x:xl) = ..x..xl..  -- apfel, this i meant
10:37:55 * hackagebot hatt 1.5.0.2 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.5.0.2 (BenedictEastaugh)
10:38:02 <edwardk> x.mapped.y %~ reverse $ ...
10:38:03 <edwardk> =)
10:38:15 <ski> apfel : iow, replacing every `head xl' with `x' and every `drop 1 xl' with `xl'
10:38:27 <rwbarton> all good advice but apfel has pasted code that can't even parse, and yet there is apparently a typechecking error
10:38:30 <apfel> ski: ok i try it
10:38:35 <ski> apfel : .. though it's common to call it `xs' instead of `xl' :)
10:38:37 <edwardk> i realize you import everything in a sort of manicly qualified form, so that doesn't work so well for you, but thats the usual pattern
10:38:41 <rwbarton> so gettin the actual version of the code would be good...
10:39:21 <ski> apfel : .. note that this won't fix all your problems, though. so don't despair if it still doesn't work after fixing this
10:40:25 <Peaker> edwardk, is there an equivalent for liftM?
10:40:40 <edwardk> Peaker: example?
10:40:51 <Peaker> edwardk, same as fmap, but have Monad instance, not Functor
10:41:03 <ski> apfel : when you feel ready to present your improved code, use the "Annotate" button on your paste to annotate it with the update
10:41:03 <Peaker> mapped = sets fmap,   ?? = sets liftM
10:41:06 <edwardk> oh you want to use a monad. good catch. no
10:41:12 <edwardk> i should add something
10:41:15 <edwardk> just needs a good named =)
10:41:22 <edwardk> er name
10:41:36 <nand`> mappedM? :P
10:41:39 <monochrom> monstor
10:41:41 <edwardk> *groan*
10:41:53 <johnw> mappedM is not bad at all
10:41:56 <nand`> lifted!
10:42:00 <aristid> Peaker: for when you have an ill-behaved non-Functorial monad?
10:42:01 <johnw> heh
10:42:02 <johnw> or that ;)
10:42:03 <ski> `liftedM' ?
10:42:09 <edwardk> johnw: i've avoided all single letter manglings in lens so far =P
10:42:10 <johnw> liftedM ftw!
10:42:12 <nand`> liftM'd
10:42:14 <monochrom> AbstractMappableFactory
10:42:14 <Peaker> aristid, nah, for when I have a polymorphic Monad
10:42:23 <johnw> call it :), for the feeling you get when calling it
10:42:23 <edwardk> lifted might not be bad
10:42:26 <aristid> Peaker: then just add Functor to the constraint :P
10:42:27 <nand`> monochrom's sounds good
10:42:31 <Peaker> aristid, and I want to use the idiomatic Monad constraint rather than some weird stuff
10:42:37 <Peaker> aristid, that'll pollute a lot of code
10:42:42 <edwardk> call it :( for the feeling you get when you call it. it shouldn't be necessary =P
10:42:42 <aristid> Peaker: :/
10:42:44 <johnw> oh, I guess smileys are value constructors
10:42:46 <Peaker> I do have "MonadF" which is an alias for Functor+Monad
10:42:49 <nand`> add an ‘I’, we don't want to alienate the C# crowd
10:42:51 <aristid> edwardk: haha
10:42:52 <Peaker> but I'd rather be idiomatic most of the time
10:43:08 <ski> aristid : "then just add Functor to the constraint" -- not always possible
10:43:14 <edwardk> Peaker: *nods*. i can add lifted to 3.3
10:43:36 <monochrom> there is something common between the C# crowd and the Apple crowd. IWhack... :)
10:43:42 <Peaker> edwardk, I'm cleaning up our own project's TH for records to replace it with lens, just tidying up but it's not a big deal :)
10:43:43 <shachaf> I think liftedM for compatibility with liftM sounds reasonable.
10:43:44 <Peaker> edwardk, thanks
10:43:56 <shachaf> It's immediately obvious what it is, whereas who knows what "lifted" might means.
10:44:06 <monochrom> http://ars.userfriendly.org/cartoons/?id=19980920
10:44:10 <shachaf> mapMOf is precedent enough. :-)
10:44:10 <johnw> shachaf: is there a foldedM?
10:44:39 <shachaf> johnw: Nope.
10:45:02 <johnw> then why liftedM instead of lifted?
10:45:05 <Peaker> edwardk, if I have a sum-type of records, and some _fieldName is in some of the constructors, but not all of them, will the LensTH generate a common lens that modifies it or ignores its inexistence?
10:45:09 <ski> @type lift
10:45:11 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:45:16 <ski> @type liftA
10:45:17 <johnw> bbiab
10:45:17 <lambdabot> Applicative f => (a -> b) -> f a -> f b
10:45:31 <Peaker> data T = A { _x :: Int } | B { _x :: Int } | C
10:45:32 <shachaf> johnw: "lifted" is such a common word in Haskell.
10:45:35 <edwardk> Peaker: it'll generate a traversal that modifies it or ignores its existence
10:45:46 <Peaker> edwardk, ah, cool
10:45:57 <Peaker> So I can fully get rid of our TH Then :)
10:45:58 <edwardk> it can't generate a lens, because its not there in all branches
10:46:05 <edwardk> but you can read it with ^? and it'll tell you if it found it
10:46:38 <Peaker> great, much nicer than partiality
10:46:40 <shachaf> Hooray for not generating partial functions like some people.
10:47:03 <edwardk> it was partial until mgsloan put in the effort to fix it ;)
10:47:12 <shachaf> mgsloan++
10:47:12 * ski would prefer it with some more descriptive name than `unsafeBlah'
10:47:24 * nand` .oO( `anyOf` const true )
10:47:40 <edwardk> now, if you have complex types for those fields that are often largely unrelated you may need to finish the unifier in Control.Lens.TH we broke it out so we _could_ unify types for different fields, but its not yet done.
10:49:32 <Peaker> edwardk, if I have a field name that I don't use, and I also don't need the lens, do you add double underscore prefix as a convention?
10:50:04 <edwardk> if you use a __ i'll turn it into a single _ named lens. ;)
10:50:08 <edwardk> you can modify the function that gets used though
10:50:59 <Peaker> edwardk, that's ok, a single _ named lens won't issue an unused name warning
10:51:27 <Peaker> just a bit weird, so was wondering if others had solved this some other way
10:51:50 <edwardk> makeLensesWith $ lensRules % lensField %~ dropDouble where dropDouble f  ('_':'_':_) = Nothing; dropDouble f xs = f xs
10:52:20 <edwardk> a lot of folks like naming lenses with prefix _'s these days, so double __'s in the field names arent that uncommon now
10:52:55 <lightquake> edwardk: to avoid name conflicts?
10:53:16 <edwardk> nand`: nullOf
10:53:20 <edwardk> :t nullOf
10:53:22 <lambdabot> Getting All s t a b -> s -> Bool
10:53:24 <shachaf> > let __ = 5 in __
10:53:26 <lambdabot>   5
10:53:27 <rwbarton> there is an identifier in the linux source that starts with nine _s
10:53:41 <shachaf> rwbarton: And it only goes downhill from there?
10:53:47 <lightquake> … why?
10:54:05 <edwardk> i guess you need to negate that
10:54:07 <rwbarton> https://github.com/torvalds/linux/blob/v3.6/include/linux/rcupdate.h#L474
10:54:30 <shachaf> Hmm, if you make a field called __, Lens.TH will dutifully create a lens called _
10:54:37 <shachaf> I can't figure out how to use it, though.
10:54:41 <edwardk> shachaf: hahahaha
10:54:43 <shachaf> But :bro confirms it.
10:54:47 <lightquake> shachaf: … wow
10:55:01 <rwbarton> maybe you can use it from some other TH splice
10:55:14 <edwardk> rwbarton: sounds plausible
10:55:22 <b52> anyone interested in using light table with haskell?
10:55:38 <shachaf> Hmm, yes. Even directly: "$_" gives me a type error about using the lens as a Q
10:55:38 <edwardk> b52: thats basically what fpcomplete is building. something like light table for haskell code
10:56:06 <edwardk> shachaf: you just want $_ so you can feel more perly
10:56:14 <nand`> edwardk: sounds interesting
10:56:25 <b52> edwardk: fpcomplete ?
10:56:29 <nand`> light table does look like it brings some useful features to the table; not that they're new, just that they're all in one package
10:56:52 <edwardk> b52: commercial haskell company started by an ex-microsoft guy who used to run the visual studio team
10:57:06 <ion> shachaf: Ok, seems to work. https://gist.github.com/4066949
10:57:21 <nand`> I.. oh
10:57:25 <edwardk> b52: http://www.youtube.com/watch?v=IM_OSykXKxM&feature=g-crec-u is a video of gregg talking about what they are doing at fp complete
10:57:58 <edwardk> my apologies for the crappy camera positioning
10:58:08 <ion> feature=g-gregg-u
10:58:22 <shachaf> ion: Great!
10:58:26 <shachaf> That looks reasonable to me.
10:58:35 <shachaf> But I haven't slept in quite a while so you shouldn't trust me.
10:58:36 <luite> oh i didn't know he was a microsoft guy :)
10:58:44 <shachaf> It probably looks reasonable to edwardk too, though.
10:58:52 <edwardk> luite: aaron contorer is
10:58:53 <ion> luite: It’s a requirement in Haskell.
10:59:05 <monochrom> haha
10:59:15 <shachaf> @ty (<%= tail)
10:59:17 <lambdabot> MonadState s m => LensLike ((,) [a]) s s [a] [a] -> m [a]
10:59:22 <monochrom> Microsoft Haskell 7.8
10:59:36 <ion> Haskell.NET
10:59:37 <shachaf> @ty id <%= tail
10:59:39 <lambdabot> MonadState [a] m => m [a]
10:59:46 <shachaf> Hmm, no.
11:00:13 <neutrino_> unsafePerformMicrosoft
11:00:16 <ion> @type head <%= tail
11:00:17 <lambdabot>     Couldn't match expected type `a0 -> (b0, b0)'
11:00:18 <lambdabot>                 with actual type `[a1]'
11:00:18 <lambdabot>     Expected type: LensLike ((,) b0) s0 s0 a0 b0
11:00:26 <edwardk> ion: looking
11:00:47 <monochrom> a long time ago, Microsoft Pascal was a pretty good compiler
11:01:05 <shachaf> ion was asking about partsOf/Bazaar so I gave them as an exercise.
11:01:06 <edwardk> ion: your bazaar type, and its functor/applicative look right
11:02:12 <edwardk> ins and outs match your bazOut and bazIn pretty closely
11:02:15 <edwardk> ion: looks good
11:02:35 <ion> Thanks for the review. :-)
11:02:41 <shachaf> ion: Your partsOf is called unsafePartsOf in lens (because it's unsafe).
11:02:50 <edwardk> ion: you skipped the fun part
11:03:10 <edwardk> instance a ~ b => Comonad (Bazaar a b) where
11:03:43 <ion> shachaf: Yeah, i know it’s unsafe. I could do something with the parameter to “st” i ignore at the moment, but meh.
11:04:21 <ion> edwardk: Hmm, that does sound like a good exercise, i haven’t written a single Comonad instance so far.
11:04:26 <edwardk> in lens partsOf grabs the extras from the state when it runs out of user-supplied updates, but that requires partsOf to go from [a] [a]
11:04:34 <shachaf> ion: The safe version in lens gives you Lens s t [a] [a], so it can fill in elements from the old structure if it needs to.
11:04:39 <edwardk> ion: i warn you its a hard one
11:04:47 <shachaf> extractBazaar :: Bazaar a a t -> t
11:05:02 <shachaf> duplicateBazaar :: Bazaar a c t -> Bazaar a b (Bazaar b c t)
11:05:04 <shachaf> Something like that.
11:05:10 <neutrino_> hey guys
11:05:12 <hpaste> apfel annotated “onlyNonSquares” with “onlyNonSquares (annotation)” at http://hpaste.org/77675#a77676
11:05:24 <neutrino_> is it possible to call python code directly from haskell?
11:05:28 <edwardk> > partsOf (both.traverse) .~ "notenough" $ ("world","togoaround")
11:05:31 <lambdabot>   ("noten","ougharound")
11:05:31 <ion> edwardk: Well, trivial exercises aren’t that useful anyway. :-)
11:05:59 <edwardk> the key with the comonad is trying to figure out what functors you can use remember you get to choose
11:06:03 <neutrino_> kind of like a C FFI but a python ffi, is there something of this form?
11:06:28 <shachaf> You could probably cheat and use the isomorphism to the Buy/Trade Bazaar.
11:07:15 <b52> edwardk: whats the state of their development?
11:07:26 <ski> shachaf : using `Identity' ?
11:08:49 <ion> I’ll try take a look at the Comonad instance tomorrow, i’m getting a bit too tired to think. I’ve been awake for 22½ hours or so.
11:09:39 * shachaf , too!
11:10:26 <ski> (.. only ?)
11:10:46 <coldpizza72i> http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework02/homework02.html I'm trying to do number 1  this is what i have fnRepeat 0 f = f;  fnRepeat n f = f $ fnRepeat n-1 f
11:11:07 <coldpizza72i> is it possible to do it similar to what i have
11:11:32 <ski> coldpizza72i : not having looked at the page yet, perhaps you wanted `fnRepeat n f = f (fnRepeat (n-1) f)' ?
11:11:35 <Cale> You want parens around n-1
11:11:59 <Cale> fnRepeat n-1 f means  (fnRepeat n) - (1 f)
11:12:05 <Cale> which isn't what you wanted :)
11:13:02 <ski> > recip n-1 e
11:13:04 <lambdabot>   recip n - 1
11:13:21 <Blkt> good evening everyone
11:14:04 <coldpizza72i> ski: http://ideone.com/96NooV
11:14:24 <coldpizza72i> oops typo
11:14:34 <coldpizza72i> wait nevermind
11:14:38 <coldpizza72i> no typo
11:14:54 <rwbarton> dynamic typo
11:15:29 <coldpizza72i> i need a . after the first term
11:15:55 <ski> perhaps :)
11:16:55 <coldpizza72i> hmm its applying the function n+1 times
11:17:28 <monochrom> fnRepeat 0 f = id
11:17:37 <coldpizza72i> id?
11:17:48 <monochrom> > id "hello"
11:17:48 <ski> @src id
11:17:48 <lambdabot> id x = x
11:17:50 <lambdabot>   "hello"
11:18:06 <ski> > id (id "hello")
11:18:08 <lambdabot>   "hello"
11:18:08 <coldpizza72i> identity?
11:18:17 <ski> > (id id) (id "hello")
11:18:19 <ski> yes
11:18:19 <lambdabot>   "hello"
11:18:22 <monochrom> id satisfies: f . id = f, id . f = f
11:18:27 <coldpizza72i> cool
11:18:34 <kennyd> > id id id id "hello"
11:18:35 <lambdabot>   "hello"
11:18:39 <monochrom> the name is misleading
11:18:53 <coldpizza72i> monochrom: why is that
11:19:13 <osfameron> > let unf = id in unf unf unf unf unf "hello"
11:19:14 <lambdabot>   "hello"
11:19:31 <tac_> @type unf
11:19:33 <lambdabot> Not in scope: `unf'
11:19:37 <monochrom> "student identity card" does not mean "student function-that-maps-x-to-x card"
11:19:46 <ski> > id const const id const const "sinister" "dexter"
11:19:47 <lambdabot>   "sinister"
11:20:03 <ski> @type let unf = id in unf unf unf unf unf "hello" in unf
11:20:04 <lambdabot> parse error on input `in'
11:20:10 <monochrom> and id does not mean "the purpose of student identity card"
11:20:15 <ski> @type let unf = id in unf   -- oh
11:20:17 <lambdabot> a -> a
11:20:29 <monochrom> names are misleading. laws are not. f . id = f, id . f = f
11:24:52 <ion> > let foo ta tb f (a,b) = (,) <$> ta f a <*> tb f b in over (foo id both) length ("foobar", ("baz", "quux"))
11:24:54 <lambdabot>   (6,(3,4))
11:25:01 <ion> edwardk: Is there a function like that in lens?
11:25:33 <edwardk> ion: liyang has a request for it, but i haven't checked the laws
11:25:48 <ion> I am the law.
11:25:54 <edwardk> https://github.com/ekmett/lens/pull/84
11:26:17 <ion> ok
11:26:20 <edwardk> i find it highly plausible at least =)
11:27:54 <merijn> Question for the math inclined haskellers: How would you parse/parenthesise this? ∀o.OR[o] = ∅ ⇒ ∀n.n∈N \{l} ⇒ sets(n)[o] = ∅
11:27:56 * hackagebot TypeCompose 0.9.7 - Type composition classes & instances  http://hackage.haskell.org/package/TypeCompose-0.9.7 (ConalElliott)
11:28:02 <hpaste> apfel annotated “onlyNonSquares” with “onlyNonSquares (annotation) (annotation)” at http://hpaste.org/77675#a77679
11:28:07 <apfel_> can someone take a look please, i don't know whats going on
11:29:23 <rwbarton> ∀o.((OR[o] = ∅) ⇒ ∀n.((n∈N \{l}) ⇒ (sets(n)[o] = ∅)))
11:29:25 <rwbarton> is that enough parens
11:29:28 <malik> is there a way to set language flags globally, so that both ghci and ghc use it by default?
11:29:53 <monochrom> for all o, (OR[o] = ∅) ⇒ (for all n, (n∈N \{l}) ⇒ (sets(n)[o] = ∅))
11:30:03 <neutrino_> rwbarton: you should start using the better quantifier syntax, then you can just use slashes.
11:30:05 <osfameron> that's a very pretty letter
11:30:10 <osfameron> ∅) I mean
11:30:11 <rwbarton> who me what
11:30:13 <Cale> n in N\{l}
11:30:21 <neutrino_> forall = /\, exists = \/
11:30:23 <Cale> Is that space intentional?
11:30:34 <Cale> before the \
11:30:49 <rwbarton> i assume it means N\{l} (or N \ {l})
11:30:54 <Cale> It made me wonder if suddenly I was dealing with a lambda term
11:31:12 <rwbarton> me too but when i pasted it into a non-monospaced window suddenly I understood
11:31:34 <monochrom> this is why I use non-monospace for IRC, too
11:32:08 <rwbarton> @type round
11:32:10 <lambdabot> (Integral b, RealFrac a) => a -> b
11:32:11 <monochrom> like when was the last time you needed absolutely fixed width font for ascii-art to make sense in IRC
11:32:20 <bos> how does one happily deal with existentials and GADTs?
11:32:47 <monochrom> I think I would just let GADT to subsume existentials
11:32:50 <merijn> rwbarton, monochrom: Ok, good then I don't have to drown the thing in parenthesis to get my meaning across
11:32:51 <rwbarton> monochrom: good point. maybe output of @src but i can read it well enough without
11:33:14 <rwbarton> merijn: oh yeah, the original is clear, i felt a bit silly putting in all those parens
11:33:27 <monochrom> until @src depends critically on indentation, you are not needing monospace for it either
11:33:44 <rwbarton> right, maybe it does for something, not sure
11:33:48 <merijn> rwbarton: I don't write Z notation often enough to be completely confident an expression means what I think it means :)
11:34:26 <merijn> Cale: No, the spacing of \ is a bit awkward because I copied LaTeX output from a PDF
11:34:29 <rwbarton> apfel_: first problem: you are trying to take sqrt of something that is only in Num
11:34:45 <rwbarton> this can't work, for instance Integer is Num, you can't sqrt an Integer
11:34:47 <rwbarton> @type sqrt
11:34:48 <lambdabot> Floating a => a -> a
11:34:58 <merijn> In the LaTeX it has a small space on both sides
11:35:12 <monochrom> I have been sans-serif-ing IRC for years. in this channel. it's absolutely better. especially for the occasional Chinese and Japanese. monospace makes them too small
11:35:18 <rwbarton> second problem: you are comparing x to the result of round, but round can only produce things that are an instance of Integral
11:35:27 <rwbarton> not every type that is Num is Integral, e.g., Double
11:35:30 <merijn> monochrom: I use sans-serif monospace in here
11:36:04 <merijn> monochrom: Your problem is probably that most popular monospace fonts are ridiculously tiny
11:36:15 <rwbarton> monochrom: I agree but my IRC is in a screen session inside a terminal... not sure how well that would work with a variable-width font
11:36:25 <monochrom> because you want - – — to be all the same width?
11:36:41 <merijn> monochrom: They differ here, but all fit in one char
11:36:45 <johnw> monochrom: you're right, I just switched from Courier to Lucida Grande, and this is much nicer
11:36:45 <rwbarton> whenever I try a variable-width font inside a terminal the result is a mess
11:36:52 <merijn> Menlo is a lovely font <3
11:37:17 <merijn> For those without OSX the new open source Adobe monospace font looks promising
11:37:21 <monochrom> don't use a terminal. don't use screen. use a bouncer and a GUI
11:37:26 <johnw> eh, menlo isn't as pretty to me
11:37:39 <apfel_> but round (sqrt 5) is wokring in the hugs command line
11:37:57 <rwbarton> apfel_, yes
11:38:03 <apfel_> and 5 is an integer
11:38:03 <edwardk> ok, next name game. figure out a better name for ~*~
11:38:07 <rwbarton> there 5 is inferred to have type Double
11:38:17 <edwardk> i think i don't want it to be an operater
11:38:20 <rwbarton> try round (sqrt (5 :: Integer)) if you like
11:38:20 <mm_freak> i hate monospace, yet i use irssi, because i love irssi
11:38:22 <edwardk> er operator
11:38:23 <monochrom> what does ~*~ denote?
11:38:34 <rwbarton> flying asterisk
11:38:37 <johnw> ~*~ is a pair of traversals, right?
11:38:51 <johnw> or is it a composition of lenses?
11:38:54 <monochrom> bipedal
11:39:01 <edwardk> yeah, takes a pair of traversals and gives you a traversal of the product.
11:39:02 <mm_freak> ~*~?  it's an electron together with its probability wave
11:39:02 <apfel_> a, 5 is casted to double in this case
11:39:04 <rwbarton> some kind of bat perhaps
11:39:12 <monochrom> hahaha mm_freak++
11:39:19 <edwardk> > foo x y f (a,b) = (,) <$> x f a <*> x f b
11:39:21 <lambdabot>   <hint>:1:17: parse error on input `='
11:39:29 <edwardk> er, foo x y f (a,b) = (,) <$> x f a <*> y f b
11:39:55 <rwbarton> :t 5 -- apfel_:
11:39:56 <lambdabot> Num a => a
11:40:00 <mm_freak> edwardk: also yeah, best get rid of all operators surrounded by ~ =)
11:40:00 <edwardk> the asWellAs is about the best i have so far =P
11:40:08 <coldpizza72i> i put the parens here to fix the error but I'm getting non exhaustive patterns
11:40:10 <coldpizza72i> http://ideone.com/Du5zOQ
11:40:31 <johnw> ~%%~?
11:40:38 <monochrom> size (x:xs) = 1 + size xs
11:40:38 <johnw> and =%%=
11:41:05 <johnw> no, ~ is an update
11:41:10 <coldpizza72i> monochrom: i put the parenthesis in and I'm getting non exhaustive patterns
11:41:12 <rwbarton> apfel_: it's not really "cast"; numeric literals like 5 are overloaded, and are used at whatever type is inferred from the context
11:41:20 <edwardk> mm_freak: i don't have any
11:41:29 <mm_freak> good =)
11:41:31 <johnw> .*.?
11:41:32 <monochrom> I don't get non exhaustive patterns
11:41:40 <coldpizza72i> i get it at runtime
11:41:42 <rwbarton> coldpizza72i, no you don't, or they are elsewhere, read the whole error
11:41:52 <rwbarton> or you've pasted the wrong code, etc., can't you just reproduce the error on ideone
11:41:52 <monochrom> I don't get it at runtime
11:41:53 <coldpizza72i> rwbarton: Non-exhaustive patterns in function size
11:41:59 <johnw> or *.
11:42:08 <coldpizza72i> ok 1sec
11:42:14 <johnw> foo*.bar is the composed product of lenses foo and bar
11:42:29 <johnw> i think .*. is perhaps better fro that
11:42:46 <Iceland_jack> Or (./*\.)
11:42:52 <rwbarton> or perhaps you are entering multiple let commands into ghci
11:42:56 <monochrom> cannot reproduce the error
11:42:59 <Iceland_jack> it would be like a high five
11:43:18 <johnw> (a,(b,c)) ^. _1.*._2
11:43:26 <monochrom> help me reproduce the error. tell me everything
11:43:36 <edwardk> this was a proposed operator from liyang
11:43:36 <edwardk> its a nicer version of alongside in many ways
11:43:36 <edwardk> beside could work
11:43:36 <edwardk> nah, the problem there is the .*, *. combinators collide with WAAY too many libs
11:43:39 <ski> apfel_ : note that with `onlyNonSquares :: Num a => [a] -> [a]' the numbers in the input list must have the same type as the numbers in the output list -- in case you don't want this, you should probably say so
11:43:48 <johnw> ah
11:43:57 <johnw> "the lens product"
11:44:17 <johnw> *..?
11:44:17 <clahey> edwardk: How often do you have get togethers in Cambridge?
11:44:24 <monochrom> a composition of lenses is a camera
11:44:26 <johnw> as a correlate wit ^..
11:44:33 <rwbarton> apfel_: Haskell's numeric classes can be a bit fiddly to work with if you're not used to them, maybe it is easiest to try to get it working for some specific types first, then generalize
11:44:40 <coldpizza72i> i get a different error on ideone
11:44:41 <edwardk> ("hello",["world","!!!"])^.beside id traverse
11:44:41 <edwardk> i'd rather take another preposition than clutter the operator space. the former isn't nearly as precious
11:44:46 <coldpizza72i> http://ideone.com/KtNDww
11:44:46 <edwardk> clahey: every couple of months or so
11:44:54 <johnw> edwardk: i agree with you there
11:44:55 <clahey> edwardk: I regret missing the last one, that's all.
11:45:02 <johnw> edwardk: i doubt it will be used enough to justify an operator, actually
11:45:09 <johnw> and that can always be added later
11:45:12 <edwardk> johnw: hence 'beside'
11:45:14 <edwardk> =)
11:45:18 <rwbarton> coldpizza72i: do you use vi
11:45:25 <monochrom> main = print (listEx1 odd [2,4,5,6,8])
11:45:29 <coldpizza72i> rwbarton: vim
11:45:33 <ski> coldpizza72i : `size x:xs' is parsed as `(size x):xs' -- presumably you wanted `size (x:xs)'
11:45:35 <rwbarton> you know how i guessed
11:45:37 <johnw> beside is fine
11:45:45 <rwbarton> size [] = 0
11:45:45 <rwbarton> sizei (x:xs) = 1 + size xs
11:46:10 <monochrom> ha, what the hell is sizei?
11:46:27 <coldpizza72i> here is my error http://ideone.com/53M2cz
11:46:36 <coldpizza72i> ohh oops
11:46:37 <johnw> i could use some cold pizza right now
11:46:38 <monochrom> and why is vi or vim relevant?
11:46:38 <coldpizza72i> wow
11:46:38 <Jafet> It's not sizea.
11:46:45 <coldpizza72i> ughhhh
11:50:12 <hpaste> apfel_ annotated “onlyNonSquares” with “onlyNonSquares (annotation) (annotation) (annotation)” at http://hpaste.org/77675#a77681
11:50:49 <monochrom> @type sqrt
11:50:51 <lambdabot> Floating a => a -> a
11:50:57 <monochrom> Num is not enough
11:51:23 <scp> Anyone know a good starter guide for OCaml?
11:51:29 <scp> I asked #ocaml, they aren't responding =[
11:51:31 <edwardk> @tell liyang (~*~) is in as 'beside'
11:51:31 <lambdabot> Consider it noted.
11:51:34 <monochrom> either just claim "Double -> Double", or use type inference
11:52:03 <monochrom> ocaml comes with its tutorial. comprehensive.
11:52:30 <monochrom> if you can't find it on your hard disk, find it on ocaml's website
11:52:43 <ski> apfel_ : you can use `fromIntegral' to convert from `Integer' to `Float' (or `Double' if you prefer) -- note that `round' would go in the opposite direction
11:52:49 <rwbarton> is that really the hugs error message? ouch
11:53:26 <rwbarton> "You need an instance Integral Double, but I won't tell you why"
11:54:47 <mm_freak> suppose i have two unboxed vectors of length n and concatenate them…  how much memory will that use before the original vectors are garbage-collected?  3*n or 4*n?  or is there some clever way to do this with 2*n?
11:55:52 <xplat> is there a way to access hires (microsecond or nanosecond) mtime and ctime from haskell?
11:56:17 <xplat> (aside from roll-your-own ffi, which is my second line of offense)
11:56:44 <monochrom> does the posix thing have it?
11:57:10 <atriq> xplat, Data.Time.getCurrentTime ?
11:57:20 <johnw> mm_freak: wouldn't it have to be 4*n to maintain referential transparency?
11:57:23 <atriq> 10^-12 second precision
11:57:47 <Clint> getCurrentTime won't get you mtime or ctime
11:58:31 <xplat> monochrom: the rosetta code examples didn't show that level of resolution, so i asked
11:58:33 <apfel_> it's working now, thanks a lot
11:59:11 <sipa> how would you access hires mtime outside of haskell?
11:59:17 <monochrom> the posix thing probably doesn't have it
12:00:16 <sipa> stat only has second resolution
12:01:05 <xplat> C posix does have it now (st_mtim, st_ctim as of 2008) but i'm not confident haskell's posix thingy was overhauled on that level since then especially since it's a portability headache to older systems and base maintainers probably have more interesting things to do
12:01:36 <Clint> sipa: depends on the platform
12:01:56 <sipa> oh yes, didn't know that
12:02:40 <ski> apfel_ : yw
12:02:57 * hackagebot awesomium-glut 0.1.0.0 - Utilities for using Awesomium with GLUT.  http://hackage.haskell.org/package/awesomium-glut-0.1.0.0 (MaksymilianOwsianny)
12:02:59 * hackagebot parsec-extra 0.1.0.3 - Some miscellaneous basic string parsers.  http://hackage.haskell.org/package/parsec-extra-0.1.0.3 (AriePeterson)
12:03:08 <geekosaur> haskell's POSIX stuff doesn't even support st_blocks / st_blksize which are much older
12:03:08 <mm_freak> johnw: nope
12:03:09 <rwbarton> interesting, so there are more fields in struct stat than strace knows about even with -v
12:03:09 <monochrom> I was referring to haskell's System.Posix. and it looks like just seconds
12:03:24 <mm_freak> johnw: vectors are pointers to memory slices
12:03:39 <ski> apfel_ : finally, `x:(onlyNonSquares xl)' can be written simply as `x : onlyNonSquares xl', and `foo * foo' can be shortened to `foo ^ 2'
12:04:04 <edwardk> @let beside l r f (s,s') = (,) <$> l f s <*> r f s'
12:04:05 <lambdabot>  Defined.
12:04:26 <edwardk> > ("hello",["world","!!!"])^..beside id traverse
12:04:28 <lambdabot>   ["hello","world","!!!"]
12:04:48 <edwardk> > ("hello",["world","!!!"]) % beside id traverse %~ length
12:04:50 <lambdabot>   (5,[5,3])
12:05:22 <xplat> O_o
12:05:44 <xplat> oh, ^.. vs %.  nm.
12:05:51 <edwardk> > ("hello",["world","!!!"]) % biplate %~ (length :: String -> Int)
12:05:52 <johnw> > ("hello",["world","!!!"]) % traverse %~ length
12:05:52 <lambdabot>   Couldn't match expected type `GHC.Base.String'
12:05:53 <lambdabot>              with actual typ...
12:05:53 <lambdabot>   can't find file: L.hs
12:06:08 <edwardk> oh, i can't typechange with biplate
12:07:12 <edwardk> > ("hello",["world","!!!"])^.beside id traverse
12:07:13 <lambdabot>   "helloworld!!!"
12:08:00 <hpaste> alansmithee pasted “certificate-1.2.2 fails to build on ubuntu 12.10” at http://hpaste.org/77684
12:08:35 <TobiasTheCommie> heh, that's nice. that would be me posting that.
12:08:44 <rwbarton> ... someone also just had the same issue a few hours ago
12:08:48 <xplat> looks like it's either FFI, C, or Python.  sigh.
12:09:14 <TobiasTheCommie> trying to install git-annex, works fine on debian unstable. but i get the above for two ubuntu machines. i have googled around for about an hour to no avail.
12:09:15 <rwbarton> xplat: or external stat process
12:10:04 <xplat> rwbarton: going to be statting too many times for fork/exec overhead to be acceptable, and anything more efficient would be harder than FFI
12:10:23 <TobiasTheCommie> tried nuking my .cabal and starting from clean slate. also no joy.
12:10:26 <rwbarton> TobiasTheCommie: try: cabal install --only-dependencies . crypto-pubkey-types-0.1.1 (not sure of syntax)
12:10:39 <rwbarton> actually that probably doesn't work
12:10:55 <TobiasTheCommie> i'll try anyways
12:11:00 <rwbarton> cabal install certificate-1.2.2 crypto-pubkey-types-0.1.1; cabal install --only-dependencies
12:11:51 <TobiasTheCommie> no joy on second line.
12:11:55 <dcoutts> rwbarton: more like: cabal install --only-dependencies ./ --constraint=certificate==1.2.2 --constraint=crypto-pubkey-types==0.1.1
12:11:59 <xplat> well, i guess a for-loop over argv and xargs to supply items wouldn't be too bad
12:12:00 <rwbarton> i see, thanks
12:12:03 <dcoutts> ie as a single command
12:12:10 <dcoutts> so the solver can see everything that you want, in one go
12:12:25 <rwbarton> that was what I was groping for yeah
12:12:57 <rwbarton> not sure why cabal doesn't want the newer certificate with a correct crypto-pubkey-types constraint
12:13:17 <TobiasTheCommie> seems like it's working
12:14:57 <merijn> xplat: Why not have a longlived stat process? Just communicate over unix socket to request/receive stat results
12:15:13 * TobiasTheCommie hopes this fixes the issues he has with the statical linux git-annex package.
12:16:14 <TobiasTheCommie> yay. it worked. thanks dcoutts and rwbarton
12:16:22 <xplat> merijn: more complicated than ffi, still multiplies the number of syscalls by as much as 3 (not that important for me, but), and too ugly for reusability
12:16:25 <mm_freak> for loops…  the greatest nightmare of the 20th century, and we're still having it today
12:16:59 <monochrom> you know how nuking .cabal does not give you a clean start
12:17:01 <merijn> xplat: Submit a patch for the System libraries? :>
12:17:10 <xplat> merijn: if i'm going to do a terrible, non-reusable hack it had best at least be easy :)
12:17:28 <merijn> mm_freak: for-loops the greatest nightmare of the 20th century? wut.
12:17:41 <merijn> mm_freak: Clearly you don't maintain C code very often...
12:18:17 <xplat> i thought the greatest nightmare of the 20th century was null pointers.  i mean pthreads.  i mean hitler.  defnitely hitler.  or pthreads.
12:19:16 <merijn> pointers and pthreads are a pretty awful combination...
12:19:20 <TobiasTheCommie> monochrom: yeah, i've learned that before. i just renamed the dir to test. if it did anything. also did some 20 other different things.
12:19:54 <rwbarton> this time it was the fault of a missing package version upper bound
12:20:10 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml for a more scientific, less magic approach
12:20:36 <xplat> (and actually if you must know it was the nuclear freaking bomb, not for lack of competition)
12:21:43 <monochrom> the nuclear freaking bomb is the greatest invention. for cleaning out packages. just make sure you apply it to .ghc, not .cabal
12:22:31 <monochrom> when you apply it to .cabal, it becomes the nuclear fizzling bomb
12:23:16 <rwbarton> this is another source of problems relating to cabal, too loose version constraints, and once you publish a package with a too loose constraint there is often nothing you can do to recover
12:23:44 * dcoutts is working on the latter problem
12:23:50 <rwbarton> great
12:23:56 <mm_freak> merijn: i did in the past
12:24:23 <mm_freak> for loops are always monolithic, the exact opposite of compositional programming
12:24:38 <monochrom> I don't think the problem is solvable. the problem "does not exist" in linux distros because of the huge man-hours spent on the problem.
12:24:38 <rwbarton> what's the approach? blacklisting like mentioned in that recent haskell@ thread could help
12:24:46 <mm_freak> above a certain size they are hard to read and maintain, and very prone to bugs
12:25:01 <dcoutts> rwbarton: just fixing the metadata after release
12:25:09 <rwbarton> okay, I see
12:25:45 <dcoutts> people like the maintainer, or other hackage "trustees" will be able to make certain adjustments to the metadata to make it match reality
12:25:52 <dcoutts> this is the sort of thing distros do
12:26:07 <dcoutts> though they can also patch the code, we'll not be doing that
12:26:10 <monochrom> just ask yourself how many people work on choosing just one set of consistent versions to go into "debian testing", for example
12:26:23 <dcoutts> indeed, it's huge
12:26:41 <ciaranm> *cough* slotting *cough*
12:26:42 <rwbarton> yes... independently of that snoyberg post I had the idea of "debian for hackage"
12:26:53 <dcoutts> ciaranm: we've had that for ever
12:26:56 <monochrom> so nevermind hackage where you try to allow ranges, not just one choice
12:27:09 <ciaranm> dcoutts: debian, i mean
12:27:15 <dcoutts> ciaranm: oh ok
12:27:35 <dcoutts> ciaranm: btw, it turns out you actually need more than that. You need to be able to install multiple instances of the same version, not just multiple different versions.
12:27:47 <dcoutts> ciaranm: something I never realised when I was working on gentoo
12:27:52 <rwbarton> but I have only experienced debian as a user, not as a maintainer to any significant degree
12:28:09 <ciaranm> dcoutts: yeah, that's not something gentoo can do. my baby can handle it, though.
12:28:34 <dcoutts> ciaranm: you're still working on that? good.
12:28:42 <ciaranm> dcoutts: intermittently...
12:29:04 <rwbarton> patches to source seem very useful too... think of the 7.6 Control.OldException or FFI data constructor issues
12:29:21 <dcoutts> rwbarton: just upload a point release! :-)
12:29:27 <rwbarton> but who?
12:29:38 <dcoutts> rwbarton: anyone in the maintainer group.
12:29:42 <monochrom> dcoutts: if we are to change constraints in-situ, we have to both: on hackage, and allow me to do it in my package db
12:29:57 <neutrino_> hey guys i have a question
12:29:58 <monochrom> err, nevermind, does not need the second one
12:30:21 <neutrino_> is there a command to go from Module.Name to the package that contains it?
12:30:28 <neutrino_> perhaps the hoogle command line tool has something?
12:30:39 <neutrino_> i can't find anything that does that
12:30:43 <Saizan> ghc-pkg find-module if it's installed
12:30:47 <monochrom> hackage has a search box. enter module name there
12:30:48 <neutrino_> oh
12:30:51 <neutrino_> let me try that
12:30:59 <rwbarton> dcoutts: okay, I guess that works. I suppose needing to maintain patches across a range of versions should not normally be an issue, because if the maintainer is active they can be encouraged to merge
12:31:01 <neutrino_> what about something that isn't installed?
12:31:07 <neutrino_> is there a website that does that?
12:31:22 <monochrom> hackage has a search box. enter module name there
12:41:50 <TobiasTheCommie> awesomeness, bug fixed by not using the git-annex standalone tarball.
12:41:55 <TobiasTheCommie> thanks for your help.
12:47:12 <jason84> can someone tell me why this returns a non-exaustive pattern error? : myTailMatch (x:xs)	| null (x:xs) == False = xs 				| otherwise = []
12:47:20 <Peaker> Does anyone know if there's a lens operation like "over" but monadic?
12:47:49 <mauke> jason84: because you haven't defined what happens for myTailMatch []
12:47:54 <luite> jason84: (x:xs) is never Null, you pattern match on the (:) constructor
12:47:59 <luite> uh, never null
12:48:12 <luite> jason84: so it only matches if the list has at least one element
12:48:24 <b52> luite: yop
12:48:28 <jason84> darn thanks never thought of that
12:48:34 <Jafet> You could use ~(x:xs)
12:48:45 <mauke> Jafet: wat
12:48:54 <b52> Jafet: is that new`?
12:49:07 <Jafet> Hm wait
12:49:43 <lightquake> b52: nah, lazy pattern matches aren't new
12:50:00 <Jafet> Heh, actually you can
12:50:06 <Jafet> > let ~(x:xs) = [] in null (x:xs)
12:50:07 <lambdabot>   False
12:50:15 <jason84> i thought otherwise would always turn true if
12:50:24 <rwbarton> why do monads-tf and mtl provide identical versions of Control.Monad.Trans when all that module does is reexport things from transformers
12:50:37 <Jafet> jason: both the null guard and otherwise guard are part of the equation for (x:xs).
12:50:56 <b52> Jafet: where can i read something about the ~ thingy
12:50:57 <Philonous> jason84:  An empty list won't be matched as (x:xs) to begin with
12:51:03 <rwbarton> I guess it would be a pain at this point to move that module to transformers?
12:51:06 <mauke> > let myTailMatch ~(x:xs) | null (x:xs) == False = xs | otherwise = [] in myTailMatch [
12:51:07 <lambdabot>   <hint>:1:86: parse error (possibly incorrect indentation)
12:51:10 <mauke> > let myTailMatch ~(x:xs) | null (x:xs) == False = xs | otherwise = [] in myTailMatch []
12:51:11 <lambdabot>   *Exception: <interactive>:3:5-68: Irrefutable pattern failed for pattern (x...
12:51:15 <linduxed> hey guys, i've got a bit of a problem
12:51:24 <tomboy64> how would i convert a Char/String into a Bytestring?
12:51:37 <linduxed> i'm not sure what the best way would be to implement a certain matrix
12:51:46 <linduxed> the description of the project is here https://github.com/linduxed/progp-molbio
12:51:59 <Peaker> tomboy64, A String is a list of unicode code points. A ByteString is a list of bytes. You need to use an encoding
12:52:01 <linduxed> basically, the text under "Profile implementation"
12:52:13 <Peaker> s/list of bytes/sequence of bytes
12:52:16 <jason84> thank u guys
12:52:16 <Jafet> tomboy: Data.Text.Encoding
12:52:39 <Philonous> tomboy64:  You might want to use utf8-string (if you want UTF8, obviously)
12:52:41 <linduxed> my first idea is to just have [[Int]], but that feels a bit... i don't know
12:52:41 <Peaker> tomboy64, utf8 is the most common encoding everything is converging to
12:52:56 <tomboy64> actually, i do
12:52:57 <luite> except text :)
12:52:59 <Peaker> linduxed, There are some existing libraries to work with matrices?
12:53:04 <b52> does anyone know when there will be a first version of fpcompletes ide ?
12:53:07 <linduxed> Peaker: oh?
12:53:21 <Peaker> linduxed, There's the "hmatrix" library, IIRC
12:53:22 <luite> b52: i heard they're aiming for Q1 next year
12:53:36 <Jafet> Peaker: Text uses utf-16, you insensitive clod
12:54:06 <Peaker> Jafet, and that's a very poor decision indeed...
12:54:22 <Philonous> @hackage utf8-string tombocy
12:54:22 <lambdabot> http://hackage.haskell.org/package/utf8-string tombocy
12:54:41 <Philonous> tomboy64 *
12:54:57 <rwbarton> Text also includes utf8 encoding to/decoding from ByteString
12:56:48 <rwbarton> is there any platform-only way to do it?
12:57:08 <rwbarton> oh i didn't read far enough, text is in HP now
12:58:27 <dcoutts> Peaker: a lot of people say that, but the text developers actually did both and measured it.
12:58:39 <Jafet> It's a bit silly that the way to do String encoding with standard libraries is B.fromChunks . map encodeUTF8 . T.toChunks . T.pack.
12:58:50 <Jafet> (as far as I know)
12:59:23 <Peaker> dcoutts, what was the difference?
12:59:46 <dcoutts> Peaker: the utf16 was faster
13:00:18 <Peaker> dcoutts, that's surprising
13:00:25 <Peaker> what was the benchmark?
13:00:35 <bitonic> Peaker: see jaspervdj gsoc
13:00:53 <rwbarton> there is an encodeUtf8 for strict Text too
13:01:03 <bitonic> Peaker: <http://jaspervdj.be/posts/2011-08-19-text-utf8-the-aftermath.html>
13:01:24 <bitonic> utf16 is not faster
13:01:43 <bitonic> but utf8 is not fast enough to justify the switch
13:01:54 <bitonic> so choosing utf16 was a poor decision
13:01:59 <bitonic> (imo)
13:02:14 <dcoutts> bitonic: it was certainly faster the first time the lib was implemented.
13:02:31 <dcoutts> bitonic: I know because I supervised the student, he did all 3 encodings: utf8, 16, 32
13:02:46 <jmcarthur> b52: you can think of   let ~(x:xs) = [] in null (x:xs)   as being roughly the same as   let xs = [] in null (head xs : tail xs)
13:03:04 <bitonic> dcoutts: well that blog post says what I wrote here, more or less
13:03:32 <dcoutts> bitonic: you're referring to the original implementation though
13:03:50 <dcoutts> ie why it was utf16 in the first place
13:04:16 <jmcarthur> b52: so,  head xs = _|_  , and  tail xs = _|_  , but since  null (_|_ : _|_)  is False, so is  null (head xs : tail xs)
13:04:18 <dcoutts> Jafet: surely just (T.encodeUtf8 . T.pack) :: String -> ByteString
13:04:23 <bitonic> dcoutts: ? you mean *you* are referring to the original implementation?  that gsoc is from last summer
13:04:30 <bitonic> I am not sure about the original implementation
13:04:44 <Jafet> Basically, it sucks that the original author wasn't precognizant
13:05:03 <Jafet> dcoutts: for a strict bytestring
13:05:06 <bitonic> Jafet: well of course my comment was to be read "In hindsight..."
13:05:16 <dcoutts> Jafet: Data.Text.Lazy.Encoding
13:05:23 <bitonic> and anyway, the compatibility argument is a very strong one in favour of UTF8
13:05:25 <Jafet> Ok, I didn't know that one
13:05:50 <dcoutts> bitonic: that's irrelevant, it's an abstract type, it provides encoding functions from all the UTF encodings
13:06:20 <Jafet> Compatibility with what
13:06:22 <bitonic> dcoutts: sure but I guess that would matter in terms of performance, no?
13:06:56 <dcoutts> bitonic: when you said "choosing utf16 was a poor decision", I assume you were referring to the original implementation, since you summarise the conclusion as the switch not being worth it and hence it's the original decision that you think was at fault.
13:07:25 <b52> > let ~(x:xs) = [] in null (x:xs)
13:07:27 <lambdabot>   False
13:07:34 <dcoutts> bitonic: well then we're back to performance, not compatibility
13:07:38 <b52> jmcarthur: that doesnt make sense
13:07:44 <b52> > head []
13:07:45 <lambdabot>   *Exception: Prelude.head: empty list
13:07:48 <bitonic> dcoutts: I didn't want to give blame - I just think UTF8 would have been better
13:08:00 <jmcarthur> b52: yes, head [] is _|_
13:08:05 <jmcarthur> b52: it just never gets evaluated
13:08:18 <b52> how come?
13:08:19 <Jafet> bitonic: to see whether performance matters, you do a benchmark...
13:08:25 <jmcarthur> > null (undefined : undefined)
13:08:27 <lambdabot>   False
13:08:29 <jmcarthur> b52: ^^
13:08:33 <Peaker> dcoutts, how can utf16 be faster than utf8? utf16 takes the variable-sized'ness of utf8, adds to it doubling of the size (destroying cache lines)
13:08:34 <bitonic> dcoutts: you gave Peaker the impression that UTF16 is faster, which is untrue, I just wanted to point that out
13:08:47 <bitonic> see above.
13:08:50 <b52> thats some weird shit :D
13:08:50 <Peaker> and destroys compatibility as well
13:08:52 <jmcarthur> b52: all null cares about is whether it see (:)
13:08:54 <jmcarthur> *sees
13:09:02 <dcoutts> bitonic: it was when we originally benchmarked it.
13:09:12 <dcoutts> bitonic: apparently now they're similar, which is good
13:09:24 <jmcarthur> b52: well, to be more specific, it cares whether it sees (:) or []
13:09:30 <dcoutts> Peaker: depends on the costs of conditionals vs memory loads
13:09:34 <jmcarthur> @src null
13:09:34 <lambdabot> null []     = True
13:09:34 <lambdabot> null (_:_)  = False
13:09:34 <bitonic> dcoutts: UTF8 is marginally faster.  what changed from then to now anyway?
13:09:41 <dcoutts> bitonic: ghc changed
13:09:43 <Peaker> dcoutts, does utf16 save conditionals?
13:09:52 <jmcarthur> b52: ^^ note that null never uses the arguments to (:)
13:09:56 <dcoutts> Peaker: it's a considerably simpler decoder
13:10:04 <jmcarthur> s/arguments to/fields of/
13:10:26 <Philonous> b52:  That's what "haskell is nonstrict" means
13:11:13 <dcoutts> bitonic: and perhaps people spent even more time with low level hackery
13:11:28 <bitonic> dcoutts: you mean last time they tried?
13:11:34 <dcoutts> bitonic: right
13:12:04 <bitonic> mhm
13:12:13 <dcoutts> bitonic: my intuition is also that utf8 ought to be the right choice, but one does have to be objective and follow the measurements
13:12:26 <b52> Philonous, jmcarthur: I'll wrap my head around this tomorrow, good night.
13:13:02 <bitonic> dcoutts: I don't have that strong opinions either...  but UTF8 seems to dominate more and more
13:13:14 <dcoutts> bitonic: as an external encoding, yes.
13:14:07 <Sonderblade> how do you use the Data.Hash.MD5 module on a string?
13:15:25 <bitonic> Sonderblade: module from where?  is it a `ByteString -> ByteString' kind of thing?
13:15:28 <Jafet> You can't. MD5 operates on bytes, not unicode values
13:15:46 <bitonic> ...you can, you need to serialise your String in some way.
13:15:57 <Jafet> Yes, you need to make it not a string
13:16:13 <bitonic> Jafet: do you really think "You can't" is the right answer here?  come on.
13:16:33 <Jafet> @faq are there things Haskell can't do?
13:16:33 <lambdabot> The answer is: Yes! Haskell can do that.
13:16:54 <kranius> lol
13:17:03 <bitonic> let's keep #haskell helpful
13:17:17 <bitonic> Sonderblade: anyhow.  you need to decide how to convert your String to a ByteString
13:17:32 <rwbarton> it is sort of the right answer, the real right answer is "more information needed"
13:18:00 <mauke> how do you use the length function on an int?
13:18:22 <Jafet> mauke: default Nat
13:18:29 <Sonderblade> the type signature is: md5s :: MD5 a => a -> String, it doesn't say whether a is a ByteString or something else
13:18:46 <bitonic> Sonderblade: can you link to the module?
13:18:58 <Sonderblade> http://hackage.haskell.org/packages/archive/MissingH/1.1.0.3/doc/html/Data-Hash-MD5.html
13:19:00 <bitonic> you can probably click on `MD5' anyway.
13:19:34 <clahey> MD5 is a typeclass.  Click on it and you'll get a description of what functions it supports and a list of instances.
13:19:44 <bitonic> yes, you can.  and guess what, String is an instance of `MD5'!  Jafet: it must be magic!
13:19:59 <Jafet> That is a really bad instance
13:20:01 <rwbarton> actually it's not
13:20:04 <clahey> bitonic: Not quite.
13:20:19 <bitonic> clahey: it's just a newtype wrapping a String.
13:21:02 <clahey> bitonic: Right, so md5s :: String -> String isn't available.
13:21:12 <clahey> bitonic: You need to do md5s . Str :: String -> String
13:21:16 <bitonic> clahey: ...OK.
13:21:40 <clahey> That type class seems weird to me.
13:21:46 <rwbarton> this code is doing something weird too
13:21:58 <rwbarton> foldr (\c w -> shiftL w 8 + (fromIntegral.ord) c) 0 s
13:22:15 <Jafet> I don't know what that code does
13:22:18 <Sonderblade> as far as i can figure out from the non-existent braindead documentation md5s operates on MD5 instances, MD5 Str is an instance -> Str is a synonym of String, so md5s "foo" should work but doesnt
13:22:32 <bitonic> right, so it's cutting off non-ASCII chars
13:22:34 <rwbarton> Str's not a synonym, it's a newtype
13:22:43 <bitonic> Sonderblade: don't use that module.  Str is a newtype
13:22:51 <rwbarton> except it doesn't even cut off, it just hopes
13:22:58 <bitonic> oh, right
13:23:03 <rwbarton> anyways I agree with "don't use this module"
13:23:08 <rwbarton> it is probably really old
13:23:18 <bitonic> Sonderblade: <http://hackage.haskell.org/package/pureMD5> this should be better
13:23:51 <Sonderblade> thanks, ill try that one instead
13:25:30 <Philonous> There's also http://hackage.haskell.org/package/cryptohash
13:25:53 <bitonic> you still need to convert the String to bytes.  this <http://hackage.haskell.org/package/utf8-string> should turn out useful for that purpose, but be sure to know what you're doing - the first step is to understand the difference between String and ByteString
13:25:56 <bitonic> Sonderblade:
13:26:24 <bitonic> also, everybody who hashes needs to agree on how, obviously.
13:29:49 <rwbarton> for "how do I convert Char to Int" we need test-based search
13:29:58 <rwbarton> @hoogle \f -> f '1' == 1
13:29:58 <lambdabot> Parse error:
13:29:59 <lambdabot>   \f -> f '1' == 1
13:29:59 <lambdabot>   ^
13:30:56 <Jafet> > fromEnum '1'
13:30:58 <lambdabot>   49
13:31:02 <mm_freak> it would be great to have concurrency primitives for ST
13:31:04 <Jafet> Lies
13:31:08 <mm_freak> similar to monad-par
13:31:52 <rwbarton> that would somewhat defeat the purpose of ST... though there is unsafeInterleaveST already
13:32:09 <mm_freak> you mean because of the strictness?
13:32:31 <copumpkin> because concurrency introduces nondeterminism
13:32:41 <rwbarton> because of the determinacy
13:33:02 <Jafet> monad-par are concurrency primitives?
13:34:04 <mm_freak> the result of a Par computation is deterministic…  couldn't you put those primitives into ST?
13:35:47 <rwbarton> what would be the point, if they access shared state, then it is no longer deterministic, if they don't, then you can put ST into each computation
13:37:13 <Nereid> first-class patterns would be neat
13:37:28 <Jafet> How much do they cost?
13:37:42 <copumpkin> $53
13:37:49 <Nereid> I dunno what they'd look like though
13:39:40 <Nereid> and then you could write some function match :: Pat a -> a -> Bool or something like that, for instance
13:40:00 <Nereid> Pat a would probably have to be more complicated though to handle bindings ??
13:40:15 <Philippa> how do I yoink as much of the Platform's package set as I can for a newer GHC version?
13:40:35 <Philippa> or am I going to have to find out which packages I actually use the hard way?
13:40:50 <edwardk> Does anyone have suggestions for reading material for working with stochastic differential-algebraic equations? (SDAE's in particular are my current interest, but good stochastic ODE reading material i can refer folks to would be great)
13:41:08 <edwardk> (sorry for the crosspost for anyone on ##math as well)
13:42:16 <rwbarton> I just read about stochastic differential equations today, is this a coincidence?
13:42:36 <rwbarton> have you seen http://www.azimuthproject.org/azimuth/show/Stochastic+differential+equation ?
13:43:57 <qasi> Is there any Framework that allows me to write Server/Client-Code (via TCP) without much Boilerplate? For example, I want it to transparently handle any marshalling and stuff like that, I don't need to implement my own protocol by hand.
13:44:17 <edwardk> i was working on a toy project for modeling with them this weekend
13:44:50 <copumpkin> rwbarton: it's all that crazy rentech stuff you're doing, right? ;)
13:44:54 <rwbarton> ah. there was a post on http://johncarlosbaez.wordpress.com today
13:44:56 <SaaMmY-laptop> hi all
13:45:00 <rwbarton> copumpkin: ;)
13:46:19 <SaaMmY-laptop> is good haskell for robot codes programming?
13:47:59 * hackagebot GLUtil 0.3.0 - Miscellaneous OpenGL utilities.  http://hackage.haskell.org/package/GLUtil-0.3.0 (AnthonyCowley)
13:48:07 <efie> I call getLine to get a line from the user. if the line is not a EOF (CTRL+D) I want to proceed and repeatedly call getLine again. If EOF is received, the program should terminate. how can I check if a Char / String is EOF? I only found isEOF which does not help me
13:48:31 <mauke> what do you mean, "is EOF"?
13:48:31 <edwardk> rwbarton: so, when do you want to come to boston haskell and give a talk? =)
13:48:36 <mauke> EOF is a state, not a thing
13:48:55 <rwbarton> not sure. I can do the first one though, when is the next one?
13:49:03 <edwardk> pick
13:49:14 <mauke> who are you calling a pick?!
13:49:15 <edwardk> i need to get speakers
13:49:23 <SaaMmY-laptop> is good haskell for robot codes programming?
13:49:25 <copumpkin> rwbarton: dammit! I'll be really annoyed if you show up just as I leave
13:49:39 <edwardk> i suppose i should see if we can get a hac boston going this year
13:49:40 <efie> mauke: if CTRL+D was entered it should terminate
13:49:47 <Nereid> efie: you would want to catch the right IO exception
13:49:50 <mauke> efie: you already said that
13:49:50 <c_wraith> SaaMmY-laptop: I'm really not sure if anyone knows what you're asking.
13:49:51 <rwbarton> copumpkin: when is that?
13:49:54 <Philippa> mauke: There's an EOF character in many charsets
13:50:00 <mauke> Philippa: which ones?
13:50:05 <Philippa> ASCII, for one
13:50:13 <copumpkin> rwbarton: next few weeks, probably won't make it to the next boston haskell :(
13:50:13 <mauke> Philippa: I don't see it
13:50:14 * copumpkin weeps
13:50:22 <rwbarton> alas
13:50:25 <copumpkin> and alack
13:50:30 <rwbarton> yes, that too
13:50:35 <copumpkin> woe, woe
13:50:39 <copumpkin> fie!
13:50:39 <ousado> edwardk: what do you mean by "working with"? something more specific than just material explaining them?
13:50:43 <Philippa> mauke: sorry, my bad, skimmed the docs when I went looking
13:51:28 <Philippa> there're chars that're interpreted as EOF by particular systems, of course
13:51:48 <Philippa> (ASCII 04, ASCII 26...)
13:51:53 <Nereid> efie: getLine throws an exception when it sees EOF
13:52:02 <mauke> more like keys
13:52:22 <edwardk> ousado: in particular numerical solvers for SDAEs with good convergence, and tools for classifying them, etc.
13:52:32 <mauke> ok, it's a weird in-between
13:52:35 <Philippa> mauke: sometimes it crosses the keycode/char boundary
13:52:51 <mauke> in unix it's a terminal setting which byte makes read() return
13:53:01 * hackagebot pcd-loader 0.2.0 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.2.0 (AnthonyCowley)
13:53:03 * hackagebot ply-loader 0.1.1.1 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.1.1.1 (AnthonyCowley)
13:53:06 <ousado> edwardk: ah ok.
13:53:08 <mauke> in windows, files opened in text mode treat ^Z as EOF IIRC
13:53:20 <Nereid> efie: see System.Exception and also System.IO.Error.isEOFError
13:53:25 <rwbarton> if I copy an ASCII 4 character (how?) and paste it into urxvt will it be treated as end-of-file?
13:53:31 <edwardk> basically i spent this weekend going through modelica at the urging of alexey radul, and started wondering what a modelica-style model would look like with stochastic noise, things sampled at times with estimated errors, etc.
13:53:34 <rwbarton> assuming the terminal is running cat or whatever
13:53:50 <Mirakelbananen> Hello
13:54:08 <mauke> rwbarton: I suspect the answer is yes
13:54:09 <efie> Nereid: thanks
13:54:40 <sclv> edwardk: one source of  classic stochastic ode stuff is all the different black-scholes derived models
13:54:43 <edwardk> i can map them onto a haskell or haskell-like dsl, rather than the oop like reuse of modelica, (and this works with or without the stochastic component) but it'd be nice to have something that could deal with both
13:55:00 <sclv> i guess its easy enough to add algebraic constraints
13:55:05 <sclv> like price doesn't go below zero
13:55:16 <Peaker> edwardk, is there a monadic "over"?
13:55:16 <sclv> or otherwise external constraints
13:55:22 <edwardk> sclv: i'm okay from the model front with examples. i'm mostly looking for tools for classifying models
13:55:25 <edwardk> :t mapMOf
13:55:27 <lambdabot> LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
13:55:27 <sclv> aha
13:56:02 <sclv> ok, but you need to expand what you mean by 'classifying models'
13:56:02 <edwardk> e.g. DAE's have all these different ways to index them based on how hard they are, etc.
13:56:07 <mauke> rwbarton: I tested it and I was right
13:56:08 <sclv> ah
13:56:17 <mauke> echo $'\x4' | xclip
13:56:21 <rwbarton> aha
13:56:27 <edwardk> well, i'd like to find out what tools there are for spotting if a DAE is structurally non-singular, etc.
13:56:47 <edwardk> i'm still in the exploratory phase of a project, so i'm not yet to the point where i can speak with much rigor ;)
13:56:50 <rwbarton> oh right, that is a thing configured through stty
13:57:11 <Peaker> edwardk, thanks
13:57:23 <sclv> yeah i don't know anything like that. the only process i know is 'look at the equation, read some papers, think very hard'
13:57:59 * hackagebot dawg 0.2.0 - DAWG  http://hackage.haskell.org/package/dawg-0.2.0 (JakubWaszczuk)
13:58:10 <sclv> but i sort of suspect that the traditional tools for working with fancy DEs just translate over when you add the stochastic term.
13:58:12 <copumpkin> yo DAWG
13:58:19 <sclv> hah
13:58:25 <copumpkin> I wanted to write DAWGs back when I first learned haskell
13:58:27 <copumpkin> then I forgot about it
13:58:52 <edwardk> sclv: well, there are methods for working with stochastic ODEs. euler-murayama, and runge-kutta variants, etc. those translate well, but most of the others don't so much
13:59:06 <sclv> solvers, yeah.
13:59:08 <edwardk> but i'm more interested in DAEs then ODEs, and that complicates things
13:59:12 <sclv> i mean like mathematical methods
13:59:15 * shapr boings cheerfully
13:59:20 <edwardk> oh, for exact solutions?
13:59:24 <sclv> for classifying
13:59:27 <edwardk> ah
13:59:34 <shapr> Yay! People like my GSoC project! They want to make it work with Python/Ruby/C++
13:59:57 <sclv> oh, edwardk, shapr, btw i pinged ezyang about doing a monad reader on SoC projects
14:00:03 <sclv> and then he asked me for more details
14:00:05 <shapr> Oh that would be cool!
14:00:07 <rwbarton> insert "DAWG" 1 empty
14:00:09 <sclv> and i didn't reply :-P
14:00:23 <edwardk> yeah, i don't know much about what classes of stochastic DAEs there are. i've found a few recent-ish papers on the topic of working with certain restricted forms of them, which of course makes me afraid i bit off a very big problem domain ;)
14:00:25 <sclv> so ppl should get back at him and help him figure out how to make it happen
14:00:27 <shapr> I'd certainly love to write a summary about my GSoC
14:04:14 <sclv> shapr: and I'd love for you to do so. I think the project needs more publicity to get more uptake
14:06:02 <shapr> yah, dysinger hadn't heard of it
14:06:11 <shapr> sclv: It also needs bugfixes to get more uptake :-(
14:06:25 <shapr> byorgey did some testing and it's not up to using in his Haskell course yet :-(
14:06:25 <sclv> that sounds like a solvable problem
14:06:31 <sclv> :-(
14:06:48 <sclv> i went to a python conf and was impresse how 95% of the presentations all used ipython notebooks online
14:06:56 <sclv> it really changed their culture.
14:07:39 <shapr> It is a solvable problem, but not with the amount of spare time I have during school.
14:07:59 * hackagebot curl 1.3.8 - Haskell binding to libcurl  http://hackage.haskell.org/package/curl-1.3.8 (IavorDiatchki)
14:08:01 <shapr> And next term I'm taking cal 1 and 360 assembly language in the same term, so I'll have even less free time.
14:08:19 <sclv> clearly you should make it yr. senior thesis eventually -)
14:08:40 <shapr> good idea :-)
14:09:07 <shapr> I'd love to fold ghcLiVE into luite's wolfgang
14:12:11 <rwbarton> what will happen if I try to ghc-pkg unregister a package that other packages depend on?
14:12:32 <monochrom> it will abort and warn you. it will tell you how to override
14:12:37 <rwbarton> cool
14:12:59 * hackagebot vector-strategies 0.4 - A parallel evaluation strategy for boxed vectors  http://hackage.haskell.org/package/vector-strategies-0.4 (ThomasDuBuisson)
14:15:03 <sclv> edwardk: yeah my sense is there are as many types of DAEs as there are ways to arrange algebraic symbols :-) Loose impression, but instead of a theory of everything, you just have different stabs at 'subsets' driven by problems under consideration.
14:15:38 <sclv> another of those things where you have a general method (some type of hill climbing :-P) and then just individual tricks to take advantage of special structures.
14:19:45 <edwardk> sclv: im okay with that. i'm mostly curious how bad the general purpose solvers do, and how much work would go into getting something reasonably nice into a DSL
14:19:56 <edwardk> and how much worse they get when you add the stochastic component
14:22:50 <edwardk> its currently only at the 'how the heck would this look?' phase of development =P
14:23:05 <sclv> haha hmm...
14:23:21 <Peaker> TH is such a compile time hog
14:23:28 <Peaker> importing everything :(
14:25:48 <jamii> Who's for climbing today?
14:30:45 <shapr> jamii: Are you climbing the ladder of Haskell understanding?
14:30:54 <sclv> man, terms that come up in differential calculus are probably the closest to the made-up ones on star trek & co.
14:31:05 <sclv> that's probably where they steal them all form
14:31:10 <jamii> shapr: aha, thats why autocomplete was bring up the wrong names
14:31:21 <jamii> shapr: right next door to #hackerschool
14:31:26 <jamii> :)
14:31:38 <shapr> jamii: Oh cool, I know darius is going to #hackerschool I've heard it's really amazing.
14:31:47 <shapr> jamii: Is Haskell mentioned there much?
14:32:21 <jamii> shapr: It's amazing. Haskell is mentioned mostly in fear, though :)
14:32:47 <shapr> Huh, I dunno why :-)
14:33:43 <shapr> jamii: I despair of ever truly understanding types as values in a programming language. But I guess I despaired of ever understanding Haskell at some point too.
14:34:22 <jamii> shapr: Haskell was my first ever language. I used to be a mathematician, now I'm writing clojure. How I've fallen!
14:34:57 <hiptobecubic> is clojure typed?
14:35:06 <hiptobecubic> because i'm hating scheme right now
14:35:08 <sclv> no
14:35:16 <sclv> but they're adding a success typing layer like erlang
14:35:18 <sclv> at some point
14:35:27 <hiptobecubic> ah
14:35:38 <jamii> There is an experimental library for typed clojure. Haven't tried it out.
14:35:47 <sclv> i skimmed the paper
14:35:48 <jamii> I haven't really missed types much.
14:35:51 <sclv> it looked like overkill
14:36:03 <sclv> like trying too much to type existing clojure
14:36:15 <sclv> instead of just doing sane, simple typing to a huge subset of clojure
14:36:24 <sclv> the typical problem when people try to type dynamic PLs
14:36:43 <sclv> I much prefer the soft-typing/blame approach
14:37:04 <hiptobecubic> ?
14:37:23 <shapr> jamii: Wow, that's cool! I wish I'd learn Haskell first!
14:37:55 <jamii> shapr: It definitely leads to good habits.
14:38:00 <hiptobecubic> Well my experience with untyped scheme so far has been something like, come up with beautiful solution in five minutes, spend 1.5 hours figuring out where you accidentally quoted something or added extra parentheses that completely changed the semantics.
14:38:21 <sclv> hiptobecubic: was that at me?
14:38:36 <hiptobecubic> sure
14:38:50 <hiptobecubic> or jamii
14:39:01 <sclv> the blame approach is wadler's stuff and derived
14:39:03 <hiptobecubic> whoever will listen to my complaining
14:39:24 <sclv> i meant was the "?" at me?
14:39:33 <hiptobecubic> sclv, yes
14:39:46 <hiptobecubic> What is the soft-typing/blame approach?
14:39:53 <sclv> ok yeah, so wadler's approach is in "well typed programs can't be blamed"
14:40:01 <sclv> so you have a typed and untyped layer
14:40:06 <sclv> and the interface has contracts
14:40:25 <sclv> then you can have an oasis of typed code in a mess of untyped stuff
14:40:28 <sclv> and handle the boundaries well
14:40:41 <jamii> hiptobecubic: I haven't had so much of that with clojure. I think partly I just write less code these days, leaving less space for errors.
14:40:42 <sclv> he alternative is you just sort of try to type everything as best you can
14:40:50 <jamii> hiptobecubic: Also haskell trained my brain into thinking in types.
14:40:52 <sclv> at which point you have to let pass way too much bad stuff
14:40:59 <sclv> b/c there is a sense in which it 'types'
14:41:02 <hiptobecubic> jamii, not ruined. saved
14:41:16 <hiptobecubic> jamii, oh sorry. you said trained.
14:41:21 <sclv> like the problem with adding union and intersection types everywhere -- eventually you can type too much
14:41:27 <sclv> and most of it means very little
14:41:31 <hiptobecubic> sclv, yes
14:41:37 <sclv> and also you can't really reconstruct
14:41:52 <sclv> blame typing lets you do v. good type reconstruction/inference for sane code
14:41:55 <jamii> sclv: I found success typing (in the form of dialyzer) really helpful in erlang. It was surprising how many bugs it caught once we cleaned up our include files.
14:42:11 <sclv> yeah i think the dialyzer looks good. haven't used it in anger
14:42:18 <sclv> the theory is sound and fits with erlangishness
14:42:36 <jamii> sclv: On a ~50kloc codebase
14:43:17 <jamii> sclv: Mostly it falls down with message passing. Having first class channels would really help with that. You just need something to assign  a message type too.
14:44:08 <sclv> ah, makes sense
14:44:51 <sclv> can't google the typed clojure right now (crummy connection) but it shoudl be easy enough to find
14:45:44 <sclv> my sense is that it tries to do a whole lot more than the dialyzer. so i find it quite scary.
14:47:00 <jmcarthur> jamii: i suppose i know you :)
14:47:55 <jamii> jmcarthur: why?
14:49:13 <jmcarthur> are you jamie brandon?
14:49:23 <jamii> jmcarthur: yes
14:49:31 <jmcarthur> i'm jake mcarthur
14:49:38 <ciaranm> and he's stalking you
14:49:44 <jmcarthur> most definitely
14:49:45 <ciaranm> he has some of your hair
14:49:46 <hiptobecubic> this is a bit weird, yes
14:50:00 <jmcarthur> we worked together this summer
14:50:33 <jamii> jmcarthur: ah! I was frantically googling jmcarthur, was sure I recognised that name.
14:50:35 <jmcarthur> hackerschool and clojure was enough to tip me off
14:50:54 <jamii> I started working on the bloom stuff - https://github.com/jamii/droplet
14:51:08 <jamii> and https://github.com/jamii/strucjure
14:51:31 <jamii> How did the nile stuff work out?
14:52:06 <jmcarthur> it's still a work in progress, but not vaporware
14:52:51 <sclv> here's the paper on the typed clojure work btw: https://s3.amazonaws.com/github/downloads/frenchy64/papers/paper.pdf
14:53:05 <sclv> there's definitely much of interest there.
14:53:18 <jamii> sclv: Yeah, its going on the stack. Which means I'll probably be reading it this time next year :)
14:53:56 <jmcarthur> no idea why we always use stacks for papers. queues would make much more sense
14:54:03 <sclv> i wish my stack actually meant i got around to reading things. i have more of a heap, i suspect :-P or perhaps just a pile.
14:55:23 <jamii> jmcarthur: have you ever tried to pick up a fifo queue?
14:55:28 <jamii> messy business
14:55:37 <ciaranm> you can do it using two stacks
14:56:08 <jmcarthur> mkfifo is not so hard :P
14:56:23 <jmcarthur> okay okay, using it can be tougher
14:56:42 <jamii> ciaranm: like flipping a pancake!
14:56:46 <Sonderblade> how do you run map on an action like: Int -> Int -> IO [String]?
14:56:56 <ciaranm> in that everything ends up on the floor?
14:56:57 <Sonderblade> i mean what map variant to choose?
14:57:02 <hiptobecubic> mapM ?
14:57:04 <hiptobecubic> :t mapM
14:57:07 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
14:57:20 <jamii> ciaranm: yes, exactly
14:57:34 <ciaranm> @hoogle Monad m => a -> a -> m[b]
14:57:35 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
14:57:35 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
14:57:35 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap rangeFM :: Ord a => FiniteMap a b -> a -> a -> [b]
14:59:25 <Sonderblade> hiptobecubic: that gives Couldn't match expected type `[a0]' with actual type `IO [String]
14:59:45 <jmcarthur> Sonderblade: i don't understand your question
14:59:52 <hiptobecubic> Sonderblade, we need more context then
14:59:55 <jmcarthur> Sonderblade: what types of values to you have, what type of value do you want?
14:59:59 <Peaker> yay, converted whole of bottle to use lens instead of our own TH
15:01:30 <Sonderblade> i got it :) it was mapM but something else was erroring out
15:15:49 <WarDaft> So, um, what can you do about unresolved dependencies on base?
15:17:14 <bgamari> WarDaft, Loosen the bounds on base of whichever package is too strict?
15:33:04 <archwes> I'm having issues understanding the type system in haskell, specifically with numbers. I found this chart: blogs.msdn.com/cfs-filesystemfile.ashx/__key/communityserver-components-postattachments/00-09-47-71-68/Haskell-Class-Hierarchy.png but I am not really seeing a "heirarchy"
15:35:01 <hpc> archwes: draw arrows from top to bottom
15:35:28 <ousado> @tell edwardk I asked a friend, she said she mostly read standard literature like Bernt Øksendal, but she'll look it up
15:35:29 <lambdabot> Consider it noted.
15:36:43 <rwbarton> and the hierarchy is for type classes, not for types
15:37:05 <archwes> rwbarton: oh dear. whats the difference?
15:37:38 <rwbarton> well Integer and Double are types
15:37:52 <rwbarton> there is no hierarchical relation between types
15:38:22 <sipa> archwes: you may be used to systems where every class defines a type (the type of objects derived from that class)
15:38:31 <rwbarton> Num and Fractional and so on are type classes, types can belong to type classes, there is a hierarchy where we say C is a superclass of D if every instance of D must be an instance of C
15:38:35 <sipa> archwes: in Haskell, classes are really just collections of types that have some property
15:39:24 <hpc> archwes: in a sense, they "classify" types
15:41:32 <sipa> archwes: for example, the collection of all types that can be serialized to a string using show, belong to the class Show
15:42:57 <archwes> sipa: so Integer, Int, Double, and Float are all "Show-able"?
15:43:15 <sipa> yes, and many more
15:43:26 <sipa> but 'Show' on itself is not a type
15:43:41 <archwes> sipa: its a typeclass? right?
15:43:57 <sipa> yes
15:47:07 <Nereid> so for a lawful lens or traversal l, we should have modify l id = id, right?
15:47:16 <edwardk> yes
15:47:16 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
15:47:21 <edwardk> @messages
15:47:21 <lambdabot> ousado said 11m 52s ago: I asked a friend, she said she mostly read standard literature like Bernt Øksendal, but she'll look it up
15:47:22 <anshul> archwes: If you are familiar with Java, think of typeclasses as interfaces. If you implement them, you become a "type" of that interface and have to implement their functions.
15:47:26 <Nereid> yeah
15:47:38 <edwardk> @tell ousado thanks!
15:47:38 <lambdabot> Consider it noted.
15:47:58 <Nereid> and by modify I mean over
15:48:30 <edwardk> *nods*
15:48:40 <Nereid> or any setter. oh that's one of the setter laws.
15:48:50 <edwardk> over l f . over l g = over l (f . g); over l id = id
15:48:54 <Nereid> yeah
15:48:57 <edwardk> yep, precisely
15:49:13 <edwardk> the statement of the law for lenses or traversals is harder and involves Compose and some fmaping
15:49:27 <Nereid> so the things in aeson-lens are not valid lenses then.
15:50:08 <edwardk> possibly not. i admit i didn't bother checking them as i didn't write them ;)
15:50:20 <Nereid> :p
15:50:38 <edwardk> so what counter-example comes to mind?
15:50:48 <edwardk> i'd like to have it for issue reporting
15:51:08 <archwes> does an Integral type implement the behaviours of the Real, Num and Show classes?
15:51:21 <edwardk> @info Integral
15:51:21 <lambdabot> Integral
15:51:25 <edwardk> @src Integral
15:51:25 <lambdabot> class  (Real a, Enum a) => Integral a  where
15:51:25 <lambdabot>     quot, rem, div, mod :: a -> a -> a
15:51:25 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
15:51:25 <lambdabot>     toInteger           :: a -> Integer
15:51:32 <edwardk> @src Real
15:51:32 <lambdabot> class  (Num a, Ord a) => Real a  where
15:51:32 <lambdabot>     toRational      ::  a -> Rational
15:51:34 <Nereid> well if you have some x :: Maybe Value that's say not a Nothing or Just Bool
15:51:46 <edwardk> not Show any more it seems
15:51:52 <Nereid> then x % asBool %~ id = Nothing
15:52:15 <archwes> edwardk: oh man, that doesn't help at all, I'm kind of a beginner.
15:52:17 <edwardk> Integral entails Real and Enum, Real entails Num and Ord
15:52:39 <edwardk> archwes: in GHC before 7.4 Num entailed 'Show' but no longer
15:53:24 <edwardk> archwes: in theory Integral _should_ have the Show constraint that Num abdicated, because Integral is all about being precisely a Int-like type with no extra data in it
15:53:36 <edwardk> but it doesn't
15:53:36 <Nereid> yes, so you can still write showIntegral = show . fromIntegral
15:53:42 <Nereid> well, almost
15:53:48 <edwardk> Nereid: exactly
15:53:59 <edwardk> show . toInteger
15:54:05 <Nereid> better.
15:54:10 <edwardk> no defaulting ;)
15:55:46 <edwardk> Nereid: hrmm. let me install aeson-lens. there should be a way to make that okay x % asBool %~ id  should be x when its not a Bool
15:58:08 <fmap> whoa
15:58:16 <Nereid> whoa
15:58:17 <edwardk> https://github.com/tanakh/aeson-lens/issues/3
15:58:21 <fmap> edwardk: I'd like see the fix for asX then
15:58:34 <fmap> my lens writing skills are pathetic
15:58:50 <edwardk> fmap: fair nuff
15:59:27 <edwardk> hrmm. ok, i think i just proved to myself it can't work =
16:00:07 <edwardk> maybe not
16:00:26 <edwardk> my counter-example required me to step out of what i have laws covering
16:00:52 <Nereid> well maybe it has to just be a Traversal or something, not a Lens
16:01:26 <hpaste> fengshaun pasted “testing state monad” at http://hpaste.org/77697
16:01:32 <edwardk> the traversal stuff is probably easier to make sound.
16:01:45 <fengshaun> is this a proper way to write a state monad? ^^^
16:02:04 <edwardk> fengshaun: no
16:02:08 <fengshaun> :(
16:02:18 <fengshaun> what's a proper way then?
16:02:36 <fengshaun> I mean, conventionally acceptable way
16:02:41 <edwardk> you'd probably have something like enqueue :: a -> State (Queue a) ()
16:02:57 <hpaste> hpc annotated “testing state monad” with “testing state monad (annotation)” at http://hpaste.org/77697#a77698
16:03:01 <hpc> ^
16:03:18 <edwardk> enqueue x = State $ \ (Queue xs) -> … hpc beat me to it
16:03:25 <hpc> :D
16:03:28 <fengshaun> hpc, hmm I don't quite understand that
16:03:29 <edwardk> even better you wouldn't use the explicit state or State constructor.
16:03:58 <fengshaun> so, enqueue x should return a function wrapped in a State?
16:04:02 <hpc> fengshaun: (State s a) is represented as an output of (a, s)
16:04:07 <hpc> but it also depends on the previous state
16:04:11 <hpc> so you get
16:04:13 <edwardk> enqueue x = modify $ \ (Queue xs) -> Queue (x:xs)
16:04:14 <hpc> @unmtl State s a
16:04:14 <lambdabot> s -> (a, s)
16:04:39 <edwardk> or if Queue is just a list, then why have the newtype?
16:04:43 <fengshaun> so State s a is (a, s) which depends on some previous s!
16:04:45 <edwardk> enqueue x = modify (x:)
16:04:49 <hpc> fengshaun: yep
16:04:53 <fengshaun> so it has to go through "transformation"
16:05:15 <fengshaun> at
16:05:19 <fengshaun> :t modify
16:05:20 <lambdabot> MonadState s m => (s -> s) -> m ()
16:05:22 <edwardk> fengshaun: newtype State s a = State (s -> (a, s))     the state 'wrapper' holds a function from s to a product, not a product directly like you wrote
16:05:36 <hpc> and if you are thinking about it at a higher level, the enqueue takes the element you want to enqueue, and gets the rest of the queue from the state
16:05:42 <Nereid> modify $ under queueIso (x:)
16:05:45 <edwardk> now, if you use the mtl, the constructor for State is more complicated.
16:05:49 <hpc> it's a State action, but returns nothing in particular
16:05:50 <edwardk> Nereid: =)
16:05:59 <Nereid> or over? depends on which way it goes I guess
16:05:59 <hpc> so you get a -> State (Queue a) ()
16:06:01 <fengshaun> edwardk, then what about State (Queue a) ()?  (Queue a () is not a function
16:06:07 <fengshaun> oh man, that's the *type*
16:06:15 <edwardk> Nereid: from queue %~ (x:)
16:06:45 <Nereid> hmm
16:07:01 <fengshaun> so, as I understand, the type is State s a, but the value is State (s -> (a, s))?
16:07:11 <edwardk> Nereid: or better enqueue x = x =: from queue
16:07:19 <Nereid> heh
16:07:24 <fengshaun> Then if I want to construct a state, I do it with a function!
16:07:27 <hpc> fengshaun: the value is some function of type (s -> (a, s)), wrapped behind the State constructor
16:07:34 <edwardk> thats pretty obfuscated though
16:07:37 <fengshaun> hpc, ohhh now I get it
16:07:51 <edwardk> i'm probably going to remove the ~: and =: combinators, they are just too ugly
16:07:58 <Nereid> they do look pretty ugly.
16:08:00 <fengshaun> hpc, so a State value is really a State modifier!
16:08:01 * hackagebot AttoBencode 0.2.0.1 - Fast Bencode encoding and parsing library  http://hackage.haskell.org/package/AttoBencode-0.2.0.1 (FlorianHartwig)
16:08:07 <hpc> fengshaun: yep
16:08:13 <hpc> a computation, of sorts
16:08:17 <fengshaun> hpc, edwardk: thanks a lot!
16:08:27 <fengshaun> hpc, yes, a "stateful computation"
16:08:30 <hpc> and it doesn't actually yield anything until you pass the initial state to that wrapped function
16:08:33 <Nereid> fengshaun: a State s a is a "computation that uses the state to produce an a, as well as modify the state"
16:08:34 <fengshaun> what's inside a State is really a computation
16:08:37 <Nereid> so s -> (a,s)
16:08:41 <fengshaun> that depends on some state
16:08:51 <fengshaun> awesome
16:08:52 <Nereid> yeah
16:09:04 <hpc> you've just passed what was a major stumbling block for me
16:09:05 <fengshaun> so, what's the talk about modify and other infix ops?
16:09:16 <hpc> fengshaun: mental masturbation
16:09:19 <Nereid> haha
16:09:21 <fengshaun> hpc, yes, it is!
16:09:21 <hpc> but you do want to be using modify
16:09:26 <fengshaun> why?
16:09:31 <Nereid> fengshaun: modify is a library function for working with State
16:09:39 <fengshaun> I'm gonna do it explicitely just a few times before I go all lazy on this
16:09:44 <Nereid> for modifying the state by some function
16:09:46 <fengshaun> :t modify
16:09:47 <lambdabot> MonadState s m => (s -> s) -> m ()
16:09:52 <Nereid> where m = State s
16:10:16 <hpc> yeah, do it explicitly a few times, but modify is preferred for real code :D
16:10:26 <fengshaun> okay!
16:10:28 <Nereid> those funny-looking operators are lens things
16:10:29 <fengshaun> how do I use modify?
16:10:38 <fengshaun> just give it a function that modifies a state?
16:10:40 <hpc> @src modify
16:10:40 <Nereid> yep
16:10:40 <lambdabot> Source not found. Maybe you made a typo?
16:10:45 <hpc> yeah
16:10:53 <fengshaun> and then how do I get a value?
16:11:00 <fengshaun> like dequeue, for example
16:11:01 <Nereid> get
16:11:04 <hpc> :t get
16:11:05 <lambdabot> MonadState s m => m s
16:11:14 <Nereid> :t put
16:11:15 <fengshaun> this is getting worse :(
16:11:15 <lambdabot> MonadState s m => s -> m ()
16:11:24 <hpc> if you want the dequeue to modify the queue, you also need to do another modify for that
16:11:26 <edwardk> fengshaun: they grow on you =)
16:11:34 <hpc> get is more of a peek, otherwise
16:11:38 <edwardk> because they work in other monads than just the simple State monad you have right now
16:11:49 <Nereid> :t state (\(x:xs) -> (x,xs))
16:11:51 <lambdabot> MonadState [a] m => m a
16:11:52 <fengshaun> ah ok
16:12:17 <fengshaun> :t modify (x:)
16:12:19 <lambdabot> MonadState [Expr] m => m ()
16:12:23 <edwardk> :t gets null
16:12:25 <lambdabot> MonadState [a] m => m Bool
16:12:27 <Nereid> :t get head <* modify tail
16:12:29 <lambdabot> (Applicative f, MonadState [a2] f, MonadState (f a) ((->) ([a1] -> a1))) => f a
16:12:33 <Nereid> oops
16:12:35 <fengshaun> woah
16:12:43 <Nereid> lots of noise but whatever
16:12:50 <fengshaun> anyway, thanks!
16:12:54 <Nereid> oh oops
16:12:56 <edwardk> :t gets head <* modify tail
16:12:58 <Nereid> :t gets head <* modify tail
16:12:58 <lambdabot> (Applicative f, MonadState [a] f) => f a
16:13:00 <lambdabot> (Applicative f, MonadState [a] f) => f a
16:13:00 <fengshaun> I'm gonna look up some modify docs!
16:13:01 <Nereid> there we go.
16:13:03 <edwardk> is probably what you wanted =)
16:13:17 <fengshaun> after I get a hang of State itself
16:13:20 <linduxed> so i've got this list [Molecule]. Molecule is defined as "data Molecule = DNA | Protein deriving (Show, Eq)"
16:13:34 <edwardk> :t state (head && head . tail)
16:13:36 <lambdabot>     Couldn't match expected type `s0 -> (a0, s0)'
16:13:36 <lambdabot>                 with actual type `Bool'
16:13:36 <linduxed> all i care is whether *every* element in that list is of the same type
16:13:36 <lambdabot>     In the first argument of `state', namely `(head && head . tail)'
16:13:39 <edwardk> :t state (head &&& head . tail)
16:13:39 <mauke> Molecule ~ Bool
16:13:40 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
16:13:41 <lambdabot>     Expected type: [a0] -> [[a0]]
16:13:41 <lambdabot>       Actual type: [a0] -> [a0]
16:13:57 <mauke> linduxed: they are
16:13:58 <edwardk> :t state (head &&& tail)
16:14:00 <lambdabot> MonadState [a] m => m a
16:14:02 <edwardk> there
16:14:10 <hpc> linduxed: do you mean you want all DNA or all Protein?
16:14:22 <linduxed> hpc: yes! sorry, meant that
16:14:34 <Nereid> all isDNA list || all isProtein list
16:14:35 <Nereid> :t all
16:14:37 <linduxed> "type" is probably not the right word then...
16:14:37 <lambdabot> (a -> Bool) -> [a] -> Bool
16:14:46 <rwbarton> "value"
16:14:55 <edwardk> :t let pop = state (head &&& tail); push x = modify (x:); isEmpty = gets null; top :: gets head in (pop, push, isEmpty, top)
16:14:57 <lambdabot>     The type signature for `top' lacks an accompanying binding
16:14:57 <lambdabot>       (The type signature must be given where `top' is declared)
16:15:02 <mauke> :t (== 1) . length . nub
16:15:03 <edwardk> :t let pop = state (head &&& tail); push x = modify (x:); isEmpty = gets null; top = gets head in (pop, push, isEmpty, top)
16:15:03 <lambdabot> Eq a => [a] -> Bool
16:15:04 <Nereid> where isDNA = (DNA ==) ...
16:15:04 <lambdabot> (MonadState [a3] m3, MonadState [a2] m2, MonadState [a1] m1, MonadState [a] m) => (m a, a1 -> m1 (), m2 Bool, m3 a3)
16:15:17 <mauke> :t (<= 1) . length . nub
16:15:18 <lambdabot> Eq a => [a] -> Bool
16:15:20 <edwardk> those are all stack operations, not queue operations though
16:15:32 <mauke> :t null . drop 1 . length . nub
16:15:33 <lambdabot>     Couldn't match expected type `[a0]' with actual type `Int'
16:15:34 <lambdabot>     Expected type: [a1] -> [a0]
16:15:34 <lambdabot>       Actual type: [a1] -> Int
16:15:34 <linduxed> Nereid: that sounds ok
16:15:34 <hpc> edwardk: lol totally missed that
16:15:40 <mauke> :t null . drop 1 . nub
16:15:42 <lambdabot> Eq a => [a] -> Bool
16:15:44 <mauke> perfect
16:15:48 <Nereid> cute
16:16:29 <hpc> i would take the head, then filter by (not equal to that)
16:16:40 <hpc> then you can drop out as soon as you hit a differing element
16:16:45 <Nereid> but what if your list was empty?
16:16:53 <hpc> base case!
16:16:58 <Nereid> :p
16:17:04 <mauke> hpc: my code does that, no?
16:17:11 <hpc> uh
16:17:16 <hpc> yes it does
16:17:20 <hpc> shuddup :P
16:17:36 <fengshaun> hpc, Not in scope: data constructor `State'?
16:17:43 <fengshaun> how can I create a state then?
16:17:55 <fengshaun> I have imported Control.Monad.State
16:18:07 <fengshaun> the types work fine
16:18:21 <Nereid> fengshaun: the State type is an alias for some StateT
16:18:25 <Nereid> fengshaun: use the "state" function instead
16:18:30 <Nereid> :t state
16:18:31 <fengshaun> :t state
16:18:32 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:18:33 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:18:35 <fengshaun> thanks
16:19:14 <Nereid> :t \f -> StateT (return . f)
16:19:16 <lambdabot> Monad m => (s -> (a, s)) -> StateT s m a
16:19:38 <fengshaun> what if I just use StateT?
16:19:52 <yoyo12> Hi
16:20:01 <hpc> fengshaun: State is a funny thing in mtl (the package Control.Monad.State lives in)
16:20:14 <hpc> @src State
16:20:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
16:20:17 <hpc> blah
16:20:24 <rwbarton> StateT is the constructor for the StateT monad transformer so you will need to insert Identity (or return) to take care of the inner monad
16:20:25 <hpc> type State s a = StateT s Identity a
16:20:40 <fengshaun> oh
16:20:40 <yoyo12> say i have a list of lists, i.e. [[1,2],[3]] how can i get the tail of the main list?
16:20:41 <edwardk> fengshaun: if you use StateT then you need to explicitly 'return' i don't recommend it as a way to learn your way around state.
16:20:44 <hpc> data Identity a = Identity a -- the simplest monad
16:20:59 <mauke> yoyo12: tail
16:21:00 <edwardk> hpc: newtype, but, yes
16:21:03 <fengshaun> oh man, so much stuff to keep track of
16:21:22 <edwardk> fengshaun: it becomes second nature soon enough ;)
16:21:29 <yoyo12> can't do sometrhing like (x:xs):ys ??
16:21:46 <mauke> wat
16:21:50 <fengshaun> edwardk, I hope so
16:21:53 <fengshaun> :t state
16:21:55 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
16:21:59 <rwbarton> sure you can "do something like (x:xs):ys", but what relation does that have to your question
16:22:10 <mauke> > tail [[1,2],[3]]
16:22:12 <lambdabot>   [[3]]
16:22:20 <yoyo12> i'm basically try to sum all the numbers
16:22:33 <mauke> > sum (concat [[1,2],[3]])
16:22:34 <edwardk> > sumOf (folded.folded) [[1,2],[3]
16:22:35 <lambdabot>   6
16:22:36 <lambdabot>   <hint>:1:33: parse error (possibly incorrect indentation)
16:22:40 <yoyo12> [[1,2],[3]] would be 6
16:22:41 <edwardk> > sumOf (folded.folded) [[1,2],[3]]
16:22:43 <lambdabot>   6
16:22:46 <fengshaun> YES, finally working
16:22:57 <edwardk> that isn't how i'd recommend it to a newbie i admit
16:23:18 <Nereid> :p
16:23:21 <yoyo12> oh and i can't use any haskell built-in functions, or if/then/else
16:23:34 <edwardk> > getSum $ foldMap (foldMap Sum) [[1,2],[3]]
16:23:34 <hpc> fengshaun: anyhoo, the reason State is defined that way is because you can slip a different monad in for Identity
16:23:36 <Nereid> > sum . map sum $ [[1,2],[3]]
16:23:36 <lambdabot>   Not in scope: `foldMap'
16:23:36 <lambdabot>  Perhaps you meant one of these:
16:23:36 <lambdabot>    `Data.Foldable....
16:23:37 <hpc> like say, IO
16:23:38 <lambdabot>   6
16:23:47 <mauke> yoyo12: so define 'sum' and 'concat' yourself
16:23:56 <edwardk> > getSum $ Data.Foldable.foldMap (Data.Foldable.foldMap Sum) [[1,2],[3]]
16:23:57 <lambdabot>   6
16:24:17 <edwardk> @tell cale can we import Data.Foldable.foldMap and fold on lambdabot?
16:24:17 <lambdabot> Consider it noted.
16:24:19 <yoyo12> i've define sum for just a list of integers, but i'm having trouble defining sum for a list of lists of integers.
16:24:36 <mauke> yoyo12: you don't define sum for a list of list of integers
16:24:37 <fengshaun> hpc, yea, I have read a few lines about monad transformers
16:24:39 <mauke> you define concat
16:24:58 <edwardk> yoyo12: just define your fold for a list of list of integers to use your other fold or build something that flattens the list of lists to a list and then sum that
16:24:59 <mauke> or map
16:25:09 <mauke> :t sum . map sum
16:25:10 <lambdabot> Num b => [[b]] -> b
16:25:26 <edwardk> map runs afoul of his 'no built in function' rule
16:25:32 <edwardk> as does (.)
16:25:33 <edwardk> =)
16:25:42 <tomeo> Is there a function that will take from a list until the element I try to take doesn't fit a given predicate?
16:25:43 <mauke> yes, but maybe 'map' is easier to define than 'concat'
16:25:48 <mauke> and the . is incidental
16:25:51 <hpc> #include <Prelude.hs>
16:26:02 <mauke> tomeo: takeWhile
16:26:06 <tomeo> thanks mapf
16:26:10 <tomeo> mauke: :)
16:26:17 <Nereid> map and sum and concat (and (++)) are all easily defined via foldr
16:26:19 <Nereid> so just write foldr
16:26:20 <Nereid> :p
16:26:27 <yoyo12> thanks for the suggestions, i'll try it :)
16:27:18 <Nereid> :t (\f -> foldr (\x y -> f x:y) [], foldr (+) 0, foldr (++) [], \x y -> foldr (:) y x)
16:27:19 <lambdabot> Num b => ((a -> a1) -> [a] -> [a1], [b] -> b, [[a2]] -> [a2], [a3] -> [a3] -> [a3])
16:28:07 <Nereid> (+) is a built in function btw ;)
16:28:14 <mauke> o shi-
16:28:26 <Nereid> time to define your own integer type
16:28:27 <hpc> unless you feel like defining your own nats?
16:28:28 <mauke> 0 is fromInteger 0!
16:28:42 <hpc> yo dawg, i heard you like zero
16:29:07 <Nereid> > minBound + maxBound
16:29:09 <lambdabot>   Ambiguous type variable `a0' in the constraints:
16:29:09 <lambdabot>    (GHC.Enum.Bounded a0)
16:29:09 <lambdabot>  ...
16:29:10 <Nereid> > minBound + maxBound :: Int
16:29:13 <lambdabot>   -1
16:31:39 <archwes> i just did ":t (-) (/)" in an attempt to save typing, but it gave me something really funky different from each individual tupe
16:31:48 <Nereid> haha
16:31:52 <parcs`> lambdabot needs to enable ExtendedDefaultRules
16:31:56 <Nereid> :t ((-),(/))
16:31:58 <lambdabot> (Fractional a1, Num a) => (a -> a -> a, a1 -> a1 -> a1)
16:32:01 <Nereid> :t (-) (/)
16:32:02 <lambdabot> Fractional a => (a -> a -> a) -> a -> a -> a
16:32:08 <Nereid> hehe
16:32:19 <archwes> what on earth is that supposed to mean?
16:32:22 <Nereid> :t (/) - 5
16:32:24 <lambdabot> Fractional a => a -> a -> a
16:32:38 <Nereid> > ((/) - 5) 42 6
16:32:40 <lambdabot>   2.0
16:32:48 <rwbarton> archwes: you applied the function (-) to the function (/)
16:33:05 <archwes> rwbarton: haha what?
16:33:09 <mauke> archwes: precisely
16:33:12 <rwbarton> ":t (-) (/)"
16:33:29 <rwbarton> just like ":t sin 3"
16:33:37 <mauke> :t sin 3
16:33:39 <lambdabot> Floating a => a
16:33:41 <Nereid> :t 3 sin
16:33:43 <lambdabot> Num t => t
16:33:44 <rwbarton> ... only different, of course
16:33:46 <mauke> :t sin (/)
16:33:48 <lambdabot> Floating a => a -> a -> a
16:33:58 <Nereid> > sin (/) pi 2
16:34:00 <lambdabot>   1.0
16:34:21 <archwes> rwbarton: neither operator (/ or -) can take a fucntion as an argument, so how is that even possible?
16:34:34 <Nereid> arcatan: but they can, if you have a Num instance for functions!
16:34:41 <rwbarton> it's possible because type classes are open
16:34:45 <Nereid> which you don't by default, but lambdabot has them
16:34:49 <Nereid> (and you can too, with NumInstances)
16:34:52 <copumpkin> >(sin^2 + cos^2) 363
16:34:54 <edwardk> @tell cale hrmm. what do you think about exporting Numeric.AD from lambdabot?
16:34:54 <lambdabot> Consider it noted.
16:34:55 <copumpkin> > (sin^2 + cos^2) 363
16:34:57 <lambdabot>   1.0
16:35:02 <copumpkin> edwardkbot
16:35:07 <edwardk> hah
16:36:17 <archwes> well how would one use ((/) (-))?
16:36:21 <edwardk> the methods from Numeric.AD don't conflict with anyone and are pretty useful
16:36:34 <Nereid> archwes: (/) (-) x = (-) / x
16:36:40 <rwbarton> :t (-)
16:36:41 <Nereid> which is another function:
16:36:42 <lambdabot> Num a => a -> a -> a
16:37:03 <Nereid> (/) (-) x y z = ((-) / x) y z = (y - z) / (x y z)
16:37:11 <rwbarton> archwes: if you defined f = (/) (-) then I could define instance Floating (Double -> Double -> Double) where ... and use your f
16:37:15 <jmcarthur> > (/) (-) a b c
16:37:16 <lambdabot>   Couldn't match expected type `a0 -> a0 -> a0'
16:37:16 <lambdabot>              with actual type...
16:37:25 <Nereid> > (/) (-) f g a :: Expr
16:37:27 <lambdabot>   (g - a) * recip (f g a)
16:37:37 <Nereid> heh
16:37:42 <rwbarton> and lambdabot actually has such instances
16:37:47 <monochrom> one day, it will become too hard to use lambdabot for beginner examples
16:37:50 <edwardk> > (/) (-) (+) 2 1
16:37:52 <lambdabot>   0.3333333333333333
16:37:56 <Nereid> :p
16:37:59 <c_wraith> one day?
16:38:04 <edwardk> thats (2 - 1) / (2 + 1)
16:38:05 <c_wraith> was that day like 2 years ago?
16:38:05 <archwes> Nereid: what is that (x y z) at the end?
16:38:11 <jmcarthur> it already sucks sometimes
16:38:13 <Nereid> archwes: function application
16:38:13 <jmcarthur> :t (.)
16:38:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
16:38:18 <edwardk> archwes: x is the first parameter you pass to (/) (-)
16:38:27 <Nereid> :t (/) (-)
16:38:28 <lambdabot> Fractional a => (a -> a -> a) -> a -> a -> a
16:38:29 <edwardk> in my version it was a (+)
16:38:31 <Nereid> see, it takes 3 arguments.
16:38:33 <Nereid> so I'm giving it 3 arguments.
16:38:53 <Nereid> oh, the x at the end?
16:38:54 <Nereid> x is a function
16:38:57 <Nereid> and I'm applying it to y and z
16:39:29 <rwbarton> in practice you should ignore all this and know if you see (Floating (a -> a -> a)) in a context that probably indicates that you made a mistake
16:39:35 <Nereid> ^
16:39:39 <edwardk> archwes: nobody in their right mind would program this way ;)
16:40:00 <monochrom> time to move on to ghclive
16:40:01 <jmcarthur> i love NumInstances :(
16:40:03 <edwardk> archwes: and the instance Num a => Num (e -> a)    that makes this possible isn't in haskell in general.
16:40:06 <jmcarthur> but this is an awful example
16:40:10 <Nereid> archwes: if you did it in ghci it would fail. unless you imported NumInstances.
16:40:22 <Nereid> (or wrote your own instances)
16:40:33 <rwbarton> but :t (/) (-) won't fail, it will just have a funny type
16:40:42 <Nereid> oh, true.
16:40:49 <Nereid> but you couldn't use it.
16:41:14 <archwes> you guys lost me a long time ago
16:41:53 <edwardk> archwes: the meaning of (/) (-)   follows from the existence of some fancy types that enable us to add subtract and multiply functions.
16:42:07 <edwardk> > (sin + cos) 10
16:42:09 <lambdabot>   -1.383092639965822
16:42:25 <edwardk> that becomes
16:42:38 <edwardk> > (\x -> sin x + cos x) 10
16:42:40 <lambdabot>   -1.383092639965822
16:42:50 <edwardk> > sin 10 + cos 10
16:42:52 <lambdabot>   -1.383092639965822
16:43:27 <jmcarthur> NumInstances is great for cases like this:   data Vector2 = Vector2 { vecx :: Double, vecy :: Double };   magnitude = sqrt $ vecx^2 + vecy^2
16:43:53 <archwes> so ((/) (-)) takes another function and some numbers?
16:44:08 <edwardk> with the (/) (-)   example something similar happens. you need to supply another function. in my example it was plus. then ((/) (-) (+))  = \x y -> (x - y) / (x + y)
16:44:09 <jmcarthur> :t (/) (-)
16:44:10 <lambdabot> Fractional a => (a -> a -> a) -> a -> a -> a
16:44:13 <edwardk> archwes: yes
16:44:43 <edwardk> it used the 'a function that takes an argument is also a numeric type' conversion twice to get two arguments.
16:44:50 <jmcarthur> :t sqrt $ fst^2 + snd^2
16:44:51 <lambdabot> Floating a => (a, a) -> a
16:45:11 <archwes> good lord, this language is awesome
16:45:15 <edwardk> jmcarthur: cute example
16:45:45 <yoyo12> hi i'm back
16:45:50 <rwbarton> and again this is stuff you can implement in Haskell that lambdabot has that doesn't exist by default
16:45:52 <yoyo12> so i found a solution
16:46:11 <jmcarthur> rwbarton: but all you have to do is import a module from an existing package
16:46:13 <yoyo12> not sure if it's the best one, probably not considering i"m a n00b
16:46:22 <yoyo12> sumlist :: [[Integer]] -> Integer sumlist [[]] = 0 sumlist [(x:xs)] = x + sumlist [xs] sumlist ((x:xs):ys) = x + sumlist [xs] + sumlist ys
16:46:31 <yoyo12> it works
16:46:58 <monochrom> sumlist [] = ?
16:47:29 <spherox> Does anyone know of a good "example project" for haskell
16:47:31 <edwardk> yoyo12: you can do so by breaking the problem down into parts. first write the function to sumInts :: [Integer] -> Integer;   and then write sumIntLists :: [[Integer] -> Integer by calling the former on each sublist
16:47:40 <spherox> like, a real world project that I can look at to see how it's done
16:47:45 <edwardk> sumIntLists (x:xs) = sumInts x + ...
16:48:07 <edwardk> then you don't have to deal with weird nested pattern matches. you just write two very simple functions, where the second looks a lot like the first
16:48:30 <Nereid> I want to set my ghci prompt so that the input line is a different colour :(
16:48:51 <edwardk> Nereid: raw escape codes in the prompt don't work?
16:48:57 <Nereid> it does, but then that continues to the output
16:49:03 <edwardk> oh i guess that doesn't help much because, yeah
16:49:06 <edwardk> gotta run
16:49:08 <Nereid> cu
16:49:18 <monochrom> you need more escape codes to say "end of colour"
16:49:40 <Nereid> yes, and how to output them *after* I enter my input?
16:49:52 <jmcarthur> :t curry . sqrt $ abs (fst.fst - fst.snd) + abs (snd.fst - snd.snd)   -- taking it too far
16:49:53 <lambdabot> Floating a => (a, a) -> (a, a) -> a
16:50:01 <jmcarthur> doh
16:50:14 <jmcarthur> :t curry . sqrt $ (fst.fst - fst.snd)^2 + (snd.fst - snd.snd)^2   -- taking it too far more correctly
16:50:16 <lambdabot> Floating a => (a, a) -> (a, a) -> a
16:51:00 <Nereid> I guess I could colour the prompt itself and not my input.
16:51:12 <spherox> jmcarthur, you're blowing my mind right now
16:51:17 <spherox> how is it that
16:51:23 <spherox> :t fst^2
16:51:24 <lambdabot> Num a => (a, b) -> a
16:51:42 <spherox> I can understand :t fst.(^2)
16:51:46 <spherox> :t fst.(^2)
16:51:48 <lambdabot> (Num b, Num b1) => (b, b1) -> b
16:51:51 <spherox> err
16:51:51 <Nereid> :t (^2).fst
16:51:53 <lambdabot> Num b => (b, b1) -> b
16:51:58 <spherox> :t (^2).fst
16:52:00 <lambdabot> Num b => (b, b1) -> b
16:52:01 <spherox> ya, that makes sense
16:52:57 <Nereid> :t sumOf
16:52:59 <lambdabot> Getting (Sum a) s t a b -> s -> a
16:53:01 <Nereid> oh ok
16:53:16 <Nereid> > sumOf both (5,8)
16:53:18 <lambdabot>   13
16:53:52 <spherox> :t read*2
16:53:53 <lambdabot> (Num a, Read a) => String -> a
16:53:59 <JoeyA> I'm trying to make install GHC HEAD on Windows, and I get "driver/ghci/ghc.mk:56: *** removeFiles: Got leading slash: /usr/local/bin/ghcii.sh.  Stop."  Anyone else running into this?
16:54:06 <spherox> what is going on here, can anyone explain?
16:54:17 <JoeyA> :t read
16:54:19 <lambdabot> Read a => String -> a
16:54:35 <Nereid> spherox: NumInstances is going on
16:54:53 <JoeyA> Here's what I get in ghci: read*2 :: (Num (String -> a), Read a) => String -> a
16:55:34 <Nereid> and NumInstances gives you an instance Num a => Num (b -> a)
16:55:44 <spherox> ohhh, I see
16:56:00 <spherox> whew, thought I was going crazy
16:56:51 <tomeo> Can't I use where in list comprehensions?
16:57:14 <rwbarton> no but you can use let
16:57:25 <geekosaur> where is part of bindings, not general expressions
16:57:37 <rwbarton> [ ... | ..., let y = x * x, ... ]
16:57:55 <tomeo> thanks rwbarton
16:58:05 <Nereid> :set prompt "^[[31;1m>>> ^[[0m"
16:58:09 <Nereid> this looks nice.
16:59:08 <spherox> > [x | let foo = bar where bar = [1, 2, 3], x <- foo]
16:59:09 <lambdabot>   [1,2,3]
16:59:26 <archwes> what does "Could not deduce (b ~ a)" mean?
16:59:27 <spherox> tomeo, ^^
16:59:33 <jmcarthur> > read * 2 $ "500"    -- spherox :)
16:59:34 <Nereid> archwes: ~ is type equality
16:59:35 <lambdabot>   1000
16:59:40 <tomeo> thanks spherox
17:00:08 <spherox> jmcarthur, diabolical
17:00:24 <archwes> Nereid: ghc wanted them to be the same type but they weren't?
17:00:46 <Nereid> it couldn't unify them, yeah.
17:01:13 <fengshaun> :source (>>)
17:01:17 <Nereid> @src (>>)
17:01:17 <lambdabot> m >> k      = m >>= \_ -> k
17:01:20 <fengshaun> tahnks
17:01:53 <spherox> is there a way to change what modules are imported by ghci at startup
17:01:58 <spherox> im sick of typing import Control.Monad
17:02:05 <Nereid> put that in .ghci
17:02:09 <JoeyA> !google ghci automatically import modules
17:02:14 <JoeyA> @google ghci automatically import modules
17:02:18 <lambdabot> http://stackoverflow.com/questions/3518619/how-to-configure-ghci-to-automatically-import-modules
17:02:18 <lambdabot> Title: haskell - How to configure GHCi to automatically import modules - Stack Overflow
17:02:25 <hpc> answer: .ghci
17:02:40 <hpc> oh, /me lrns2scrollback
17:02:54 <JoeyA> Change ~/.ghc/ghci.conf , whatever it is called on your system.
17:03:27 <jmcarthur> > (curry $ fst.fst - fst.snd &&& snd.fst - snd.snd) (5, 5) (3, 2)
17:03:28 <lambdabot>   (2,3)
17:03:41 <archwes> Haha, I have been trying to get this function to work for the past 2 hours, then I replaced / with `div` and now it works fine XD
17:03:50 <uniquenick> https://github.com/bluepeppers/haskell-libtcod/blob/master/UI/TCOD/Console/Types.hsc#L252  <- is it possible to OR those together if they are defined like that?
17:04:14 <hpc> $ ghci
17:04:18 <hpc> "both"
17:04:18 <hpc> "should work"
17:04:30 <hpc> (those strings split between the two files)
17:05:11 <hpc> so on my system at least, it's .ghci followed by ghci.conf
17:05:37 <Nereid> but theres ~/.ghci and ./.ghci
17:05:42 <Nereid> there's.
17:05:49 <hpc> ah, yeah i tested with ~
17:08:43 <archwes> thanks to everyone for the help and for being so nice :)
17:09:32 <JoeyA> pay it forward :-)
17:11:15 <archwes> JoeyA: I will when I'm able, which might not be for a very long time haha
17:13:43 <adimit> man… attoparsec is *weird*. Like, super-weird.
17:14:21 <mm_freak> adimit: how?
17:15:29 <adimit> mm_freak: well, it never seems to want to actually return real results, except by feeding it an empty string in the end. That's one. And the other is: in my current program, and a bug I've been hunting for for half a day now, it just sits there, gobbling up gigs of ram, even though it should've failed *ages* ago, on one million different lines.
17:15:49 <adimit> I just… simply… don't understand it. And I understand parsers in general. Just not attoparsec.
17:16:01 <mm_freak> adimit: attoparsec is incremental
17:16:04 <adimit> maybe I don't understand parsers in general.
17:16:20 <adimit> mm_freak: yeah, I get it. Which is nice, you can turn it into an iteratee really easily.
17:16:21 <mm_freak> adimit: when the input string ends it doesn't just assume that's EOF
17:16:26 <mm_freak> yeah
17:16:26 <hpc> you are probably admitting the possibility of alternate parses somewhere there shouldn't be
17:16:32 <hpc> or something
17:16:37 <mm_freak> see attoparsec-{conduit,enumerator,iteratee}
17:16:42 <adimit> hpc: might be it.
17:16:43 <mm_freak> there's probably something for pipes as well
17:16:59 <mm_freak> in fact using an iteratee interface is the simplest way to run an attoparsec parser =)
17:17:05 <adimit> I'm sorry I'm not providing a condensed example, it's just difficult to extract it from the bigger code structure.
17:17:12 <rwbarton> (or, you know, you can just give it the whole input)
17:17:22 <hpc> rwbarton: beat me to it ;)
17:17:25 <adimit> rwbarton: the whole input is 30GB. that doesn't fit into ram.
17:17:33 <adimit> (not into mine, at least.)
17:17:33 <mm_freak> rwbarton: it will still not result
17:17:47 <rwbarton> with the "I'm passing you the whole input" function it will
17:18:21 <adimit> the reason i'm using attoparsec at all is because it can do incremental (i.e. constant space) parsing & processing together with iteratees nicely.
17:18:25 <rwbarton> anyways if you want to use the incremental version then you have to tell it when you are done, sure
17:18:28 <mm_freak> indeed, there is parseOnly and parseWith
17:19:08 <mm_freak> adimit: also check out trifecta, if you want good diagnostics
17:19:18 <JoeyA> My mental model for tackling attoparsec stems from the way I like to write parsers in C: bool parse_Thing(const char **sp, Thing **out)
17:19:21 <mm_freak> attoparsec is really meant for high speed low footprint parsing
17:19:25 <galois_> hi
17:19:49 <JoeyA> Namely, if the parse succeeds, advance *sp to the end of the parsed piece, and set *out to the value.
17:20:18 <adimit> mm_freak: trifecta seems nice. Though I don't want to switch atm.
17:20:25 <JoeyA> Here's my JSON parser written in this style: http://git.ozlabs.org/?p=ccan;a=blob;f=ccan/json/json.c;h=2f0452aebe568277f554072eff7685bdd6b33fc9;hb=HEAD#l623
17:20:31 <adimit> lemme cook up some example.
17:22:48 <hpc> aargh, that url bugs me for some reason
17:22:59 <hpc> probably because it breaks spec to use ; instead of &
17:27:07 <geekosaur> ; was introduced by some Java stuff IIRC, and Perl's CGI module defaulted to using it for a while on the mistaken theory that it would get rammed through as a standard
17:27:22 <hpc> heh
17:27:34 <hpc> that's sadly the least of what's wrong with CGI.pm
17:28:37 <geekosaur> actually looks like it still does
17:29:40 <hpc> also seeing "json.c" in a url was fairly confusing, but it makes sense for a git site
17:30:16 <geekosaur> hrm.  actually it looks like an XHTML-ism because XHTML is pedantic about ampersands in links
17:30:29 <guidj0s> hpc: What's a `git site`?
17:30:48 <geekosaur> (in practice I think this is one of the XHTMLisms that is rarely if ever handled strictly)
17:30:53 <hpc> guidj0s: for browsing a public repo
17:31:03 <guidj0s> Oh.
17:31:06 <hpc> git/svn/darcs/whatever
17:31:08 <hpc> but this one was git
17:31:40 <hpc> geekosaur: i still can't get over that one java XML library everyone used, which would download the DTD from the internet before parsing
17:31:58 <hpc> and use it in such a way that you can root a machine with a malicious file
17:34:56 <danharaj> is there a way to make hp2ps not cut off key names? Even with -M it truncates them.
17:35:37 <adimit> so, that's what I get for badmouthing a perfectly good package: the bug is somewhere else entirely, and it seems to be either related to laziness, or my poor understanding of iteratees. YAY.
17:35:56 <danharaj> oh wait, the aux file itself truncates the names :|
17:38:05 <c_wraith> danharaj: there's a ghc runtime option to make it allow longer names
17:38:41 <danharaj> c_wraith: ok, I'll go look there. This time I managed to figure out the names of interest from the .prof file. Thanks.
17:40:51 <danharaj> I should write a script for doing profiling :\
17:41:01 <danharaj> instead of referring to real world haskell every time I need to do it
17:43:13 <dmwit> I feel like "refer to RWH" is a pretty good script, albeit not written in one of the usual scripting languages.
17:43:44 <adimit> that language has a slow interpreter. Me.
17:43:59 <dmwit> =)
17:44:11 <fryguybob> At least it is faster then Ruby =P
17:44:17 <danharaj> zing
17:48:05 * hackagebot fsnotify 0.0.4 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.4 (MarkDittmer)
17:48:19 <parcs`> what's the name of the data-reify-like package that works for GADTs
17:51:49 <parcs`> data-treify
17:53:54 * geekosaur wonders if the Safe version is called shochet
17:58:44 <mm_freak> i'm shocked that an unboxed vector of type Vector () actually allocates array memory
17:59:08 <luite> a zero length array?
17:59:37 <mm_freak> i don't know what it allocates, but the size is about the same as a vector of the same length of type Vector Bool
18:00:19 <mm_freak> > Vu.replicate 10000000 () `seq` return ()
18:00:19 <mm_freak> (0.35 secs, 480994008 bytes)
18:00:22 <lambdabot>   Not in scope: `Vu.replicate'
18:00:22 <lambdabot>  Perhaps you meant one of these:
18:00:22 <lambdabot>    `P.replica...
18:10:48 <mm_freak> weird…  it doesn't do that when compiled
18:15:42 <parcs`> rewrite rules probably aren't being fired
18:16:38 <nicoo> mm_freak: There are lots of optimizations & code transformations GHCi dosn't apply
18:17:24 <parcs`> according to the source code Vector () is indeed represented by an Int
18:18:13 <spherox> so, is it typical for Haskell to blow ocaml out of the water?
18:18:20 <spherox> performance-wise
18:19:11 <johnw> @faq Can Haskell blow OCaml out of the water?
18:19:12 <lambdabot> The answer is: Yes! Haskell can do that.
18:19:17 <copumpkin> I wouldn't expect it to blow it out of the water
18:19:46 <copumpkin> but I wouldn't expect it to be noticeably worse, or better, except in places where it actually does less work due to laziness
18:19:48 <uniquenick> if I need to store a collection of modifiable things in two different ways for performance reasons, so that each individual thing is shared (like two different arrays of pointers to the same structs), does IORef do what I want?
18:19:52 <johnw> i've heard OCaml is pretty fast too
18:19:53 <copumpkin> which is sort of cheating anyway
18:19:58 <copumpkin> yep
18:20:12 <parcs`> http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=ocaml&lang2=ghc
18:20:18 <parcs`> quite the opposite
18:21:01 <nicoo> johnw: Under which criterion ?
18:21:06 <nicoo> Speed ?
18:21:12 <johnw> nicoo: yes
18:21:20 <johnw> parcs`: is that against a recent GHC?
18:21:42 <parcs`> yep, 7.6.1
18:21:55 <parcs`> against ocaml 4
18:22:41 <nicoo> OCaml has an advantage : it is easy to reason about the time taken by the compiled code.
18:23:13 <mm_freak> copumpkin: for me haskell sometimes beats C performancewise, especially when it comes to Integer calculations and parallelization, but of course that takes some experience
18:23:54 <sw17ch> .
18:24:00 <mm_freak> uniquenick: would IxSet do what you want?
18:24:34 <spherox> hmm
18:24:52 <spherox> one second
18:27:31 <spherox> Can anyone guess why this ocaml (http://pastebin.com/nUN7Fh5x) doesn't even scratch this haskell (http://hpaste.org/77700) ?
18:28:05 * hackagebot hOpenPGP 0.5.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.5.1 (ClintAdams)
18:28:16 <sw17ch> @seen dons
18:28:16 <lambdabot> Unknown command, try @list
18:28:22 <sw17ch> @list
18:28:22 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
18:28:31 <sw17ch> @seen
18:28:31 <lambdabot> Unknown command, try @list
18:29:54 <mm_freak> spherox: whatever "doesn't even scratch" means
18:30:53 <spherox> I mean that the native-code-compiled ocaml version is slower than the interpreted haskell version
18:31:26 <cmccann> that sounds implausible, gonna guess you're doing something wrong with the ocaml :P
18:31:41 <spherox> ya, maybe I should ask in the ocaml channel x_X
18:33:09 <danharaj> what type is (->*) in a heap profile?
18:34:08 <mm_freak> spherox: i don't know ocaml, but the haskell version trial-divides only to the square root…  the ocaml version doesn't seem to do that
18:34:19 <mm_freak> so you may be comparing two different algorithms
18:36:00 <spherox> mm_freak... aha! That's depressing =[
18:36:11 <spherox> thanks x_X
18:37:12 <mm_freak> isn't there a vector-algorithms counterpart for immutable vectors?  the sorting algorithms and binary search are very fast, but they only work for mutable vectors
18:45:24 <pordan30> when cabal reports that installing a package would result in one or more packages being installed, which would likely break already installed packages, what is the proper course of action?
18:47:46 <cmccann> flip the table
18:49:15 <byorgey> pordan30: it depends
18:49:49 <byorgey> pordan30: if you paste that report we could advise you on the proper course of action in this particular case
18:55:50 <pordan30> well, the particular case is that using cabal to install the grapefruit libraries would break diagrams and several monad libraries: <http://hpaste.org/77701>
18:56:58 <byorgey> looks like grapefruit requires an older version of 'containers' and so it wants to recompile everything with that older version of containers
18:57:01 <byorgey> don't do it!
18:57:08 <byorgey> it really will break everything
18:57:44 <byorgey> you can try getting the grapefruit source and adjusting the upper bound in containers in the .cabal file
18:58:12 <byorgey> containers-0.5 didn't introduce many breaking changes over 0.4 that I know of, so probably it will Just Work
18:59:59 <pordan30> that sounds reasonable. if there weren't any major changes in the containers api, i don't see what could go wrong (that means something will go wrong, most likely). thank you
19:04:34 <danharaj> is there an easy way to figure out what source function corresponds to a thunk in an hd profile?
19:12:40 <xplat> nicoo: there are times it's easier to analyze performance with laziness; for example, persistent structures with amortized bounds, when actually used persistently
19:15:31 <xplat> nicoo: time and space performance are *usually* easier to analyze in a strict language, but it's not some kind of absolute
19:18:21 <coldpizza72i> Can someone help me out with this http://ideone.com/BgxyYT
19:19:55 <mauke> NonNil
19:21:22 <coldpizza72i> didn't work
19:22:00 <coldpizza72i> aListUncons (NonNil (Append (Sing a) (NonNil b))) = Just (a, b) im assuming you mean
19:22:32 <mauke> bad assumption
19:23:07 * hackagebot lzma-conduit 0.5.2.2 - Conduit interface for lzma/xz compression.  http://hackage.haskell.org/package/lzma-conduit-0.5.2.2 (NathanHowell)
19:23:21 <coldpizza72i> mauke: thank you
19:27:35 <rwbarton> ion: where's your gist with ghc/platform install instructions?
19:31:07 <rwbarton> aha, found it: https://gist.github.com/2815423
19:40:39 <monochrom> see also mine: http://www.vex.net/~trebla/haskell/haskell-platform.xhtml
19:55:59 <gwern> @quote raisins
19:55:59 <lambdabot> No quotes match. The more you drive -- the dumber you get.
20:00:25 <fengshaun> is there a function that breaks a list based on an accumulator and not on individual elements (like break does)?
20:00:56 <fengshaun> I want to take the first sorted sublist of a list
20:01:03 <fengshaun> and the leftover part
20:04:06 <fengshaun> oh, takeWhileList from Data.List.Util;w
20:05:18 <jmcarthur> fengshaun: you could use a scan and then use break
20:05:44 <rwbarton> or in this case, perhaps a zip and break
20:07:18 <fengshaun> :t scan
20:07:19 <lambdabot>     Not in scope: `scan'
20:07:19 <lambdabot>     Perhaps you meant one of these:
20:07:19 <lambdabot>       `scanl' (imported from Data.List),
20:07:23 <fengshaun> :t scanl
20:07:24 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
20:07:32 <fengshaun> :t foldl
20:07:34 <lambdabot> (a -> b -> a) -> a -> [b] -> a
20:07:45 <fengshaun> :t break
20:07:46 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
20:07:57 <fengshaun> jmcarthur, how would that work out?
20:08:38 <lolcathost> > break even [1,3,5,6,9,10]
20:08:39 <lambdabot>   ([1,3,5],[6,9,10])
20:08:47 <lolcathost> Ah.
20:09:20 <rwbarton> > break error
20:09:22 <lambdabot>   *Exception: show: No overloading for function
20:09:42 <lolcathost> > break undefined [1,undefined,2]
20:09:44 <lambdabot>   *Exception: Prelude.undefined
20:09:52 <lolcathost> lol
20:10:05 <rwbarton> what is that "No overloading for function" from anyways
20:10:12 <lolcathost> :t error
20:10:14 <lambdabot> [Char] -> a
20:10:32 <lolcathost> :t break error
20:10:34 <lambdabot> [[Char]] -> ([[Char]], [[Char]])
20:10:43 <rwbarton> > id
20:10:44 <lolcathost> rwbarton: I do not think that type implements Show. :-|
20:10:45 <lambdabot>   *Exception: show: No overloading for function
20:10:55 <rwbarton> apparently it does in lambdabot, though
20:11:04 <rwbarton> but in a particularly useless way
20:11:06 <lolcathost> wat
20:11:59 * lolcathost always knew you guys made weird type class instances just to show them off via lambdabot, but... wat???
20:12:07 <lolcathost> s/via/using/
20:12:37 <jmcarthur> :t scanl
20:12:39 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
20:13:20 <fengshaun> how do I install data.list.utils?
20:13:24 <jmcarthur> :t mapAccumL
20:13:26 <lambdabot> (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:13:34 <lolcathost> > scanl (:) 'a' ["bcd","efg"]
20:13:36 <lambdabot>   Couldn't match type `[GHC.Types.Char]' with `GHC.Types.Char'
20:13:39 <fengshaun> cabal install data-list-utils or Data.List.Utils is not helping
20:14:07 <lolcathost> Oh, dang, I read the signature wrong.
20:14:16 <lolcathost> a -> b -> *a*
20:14:21 <rwbarton> > id == id
20:14:23 <lambdabot>   *Exception: (==): No overloading for function
20:14:28 <jmcarthur> the idea is to do your accumulation using the scan or mapAccum or something to annotate each element with the accumulator, then do the break, then use map to remove the accumulator from the result
20:14:30 <rwbarton> > id >= id
20:14:32 <lambdabot>   *Exception: (==): No overloading for function
20:14:55 <lolcathost> rwbarton: You cannot meaningfully implement Eq for function types in a Turing-complete language, me thinks.
20:15:01 <fengshaun> jmcarthur, makes sense, thanks!
20:15:18 <fengshaun> but how do I install modules with cabal now?
20:15:37 <fengshaun> data.list.utils can't be installed with cabal install data.list.utils
20:15:38 <rwbarton> you install packages, not modules
20:15:41 <fengshaun> or with s/-/.
20:15:47 <fengshaun> s/./-*
20:15:55 <rwbarton> however I don't particularly recommend MissingH
20:16:11 <rwbarton> (also I don't see how it solves your problem)
20:16:56 <fengshaun> rwbarton, it has a takeWhileList function
20:17:10 <fengshaun> but that's just an example
20:17:22 <rwbarton> I see that, but it doesn't look like what you want
20:17:31 <johnw> rwbarton: why not?  (recommend MissingH)
20:17:32 <fengshaun> cabal install MissingH works fine!
20:17:35 <fengshaun> let me double check
20:17:41 <rwbarton> johnw: just generally very old
20:18:08 <fengshaun> rwbarton, you're right, not the function I wanted
20:18:37 <johnw> huh, reddit is overloaded
20:18:39 <johnw> hadn't seen that before
20:18:51 <rwbarton> johnw: it does about 100 different things and by now there are probably better ways to do about 80 of them
20:19:06 <johnw> rwbarton: I mostly agree; I've never used it personally
20:19:27 <johnw> but I also mislike it when 5 different packages reinvent the same simple utilities because the Prelude didn't have them
20:20:00 <johnw> I had to post an example of using lens to http://lukeplant.me.uk/blog/posts/dynamic-typing-in-a-statically-typed-language/
20:20:44 <johnw> it bugs me when people write gross Haskell and then indirectly blame it on Haskell: "If I were cleverer, and knew Haskell better, I could perhaps write a cleverer, shorter solution, which would also be proportionately more difficult for someone else to understand, so I'm not particularly interested in making this code shorter..."
20:21:23 <johnw> so, he's assuming that someone who knew Haskell better would actually write less clear code, when he already has is quite unclear
20:21:37 <johnw> s/when/when what
20:26:28 <rwbarton> I think he encountered some real issues (though not having anything to do with static vs. dynamic typing)
20:26:44 <rwbarton> mainly to do with maturity of haskell libraries
20:27:23 <rwbarton> (too many libraries doing the same thing, too hard for the user to know which to pick, too little documentation for how to actually use that package)
20:33:55 <johnw> it is hard to know which one of many is currently the "respected way"
20:34:59 <hpaste> JimC pasted “hint 0.3.3.5” at http://hpaste.org/77704
20:35:32 <johnw> the haskell platform should come with an IRC client
20:38:32 <Yojimbo-san> I'm a haskell/cabal newbie, having a problem installing stuff: apparently hint-0.3.3.5 won't build ... http://hpaste.org/77704
20:39:06 <Yojimbo-san> Can I fix this, or is it an upstream error?
20:39:42 <Saizan> Yojimbo-san: that version of hint is probably not meant to build on your version of ghc
20:39:47 <rwbarton> it just built for me very recently, what version of ghc are you using?
20:39:59 <Yojimbo-san> it came in as a dependency for xmonad-extras, which is what I was really wanting
20:40:20 <Yojimbo-san> ghc-7.4.1 -- on raspbian and on Ubuntu
20:40:33 <rwbarton> odd
20:41:09 <Yojimbo-san> I installed xmonad-extras on a differe3nt ubuntu machine a couple of days ago, no problems ...
20:41:18 <Yojimbo-san> but today, two machines, both with the same problem
20:43:41 <Saizan> there's a lot of #if __GLASGOW_HASKELL__ > .. in those modules, i wonder if something could be messing with it
20:43:53 <rwbarton> can you hpaste the output of cabal install -v3 hint ?
20:45:25 <johnw> Yojimbo-san: if you're a Haskell newbie, what do you want to do with hint?
20:45:42 <Yojimbo-san> johnw: it's included by xmonad-extras :-)
20:45:45 <johnw> ahh
20:45:45 <mauke> <Yojimbo-san> it came in as a dependency for xmonad-extras, which is what I was really wanting
20:45:46 <johnw> xmonad
20:45:51 <mauke> no, xmonad-extras
20:46:45 <Clint> it's an optional dependency
20:47:36 <hpaste> JimC pasted “cabal install -v3 hint” at http://hpaste.org/77705
20:49:31 <Yojimbo-san> I just noticed c2hs wasn't installed ... but that didn't help me :-(
20:49:51 <coldpizza72i> Is it possible to define an infinite list similar to nnss = [1,2,2,3,3,3..]
20:50:05 <Clint> Yojimbo-san: which modules from xmonad-extra do you want?
20:50:12 <simpson> coldpizza72i: Anything's possible.
20:50:16 * simpson thinks on that one
20:50:26 <Nafai> are there any good web scraping libraries written in Haskell?
20:50:31 <coldpizza72i> simpson: i meant more along the approach i was taking
20:50:42 <Nafai> I want to be able to do things like write automation to download my bank statements, etc
20:50:53 <Nereid> Nafai: tagsoup?
20:50:53 <Clint> is tagsoup not good?
20:50:54 <coldpizza72i> simpson: don't tell me a solution yet
20:51:06 <Nereid> I'm not very familiar with it though
20:51:13 <simpson> coldpizza72i: Oh, homework.
20:51:19 <coldpizza72i> no studying
20:51:21 <Yojimbo-san> Clint: only the not-terribly-important XMonad.Actions.Volume one, that controls alsa's volume :=-
20:51:50 <Clint> Yojimbo-san: then you should be able to switch off the with_hint flag and avoid the problem
20:51:58 * Nafai looks at tagsoup
20:52:54 <rwbarton> tagsoup is just for parsing a single web page afaik, you would need to write your own recursive scraper if that's what you need
20:53:40 <johnw> Nafai: I would look at the http-conduit browser
20:53:49 <Yojimbo-san> Clint: OK ... how do I do that?
20:53:58 <johnw> Nafai: http://hackage.haskell.org/packages/archive/http-conduit/1.4.1.2/doc/html/Network-HTTP-Conduit-Browser.html
20:54:12 <johnw> that will do things like carry login cookies across pages, for example
20:54:18 <Nereid> for the actual downloading, perhaps.
20:54:20 <Nereid> it won
20:54:25 <Nereid> t' help any for parsing the pages
20:54:26 <Clint> Yojimbo-san: cabal install -f-with_hint xmonad-extras or something
20:54:49 <Nafai> I basically want to reproduce this python script: https://github.com/travisbhartwell/Presentations/blob/master/2011-04-14_utpy-web-automation/examples/statement_downloader.py
20:55:08 <johnw> mechanize is in the same space as the browser I linked above
20:55:26 <johnw> tagsoup is just for HTML parsing
20:55:44 <Yojimbo-san> (it takes a while to try this, compiling on a raspberry pi ... :-)
20:55:48 <Nafai> k, cool
20:56:02 <Clint> if only banks just exposed a standard ofx interface
20:56:06 <Clint> and we had a working ofx library
20:56:44 <coldpizza72i> simpson: nnss = [1] ++ helper 2; helper n = (take n [n,n..n]) ++ helper (n+1)   …this works
20:58:18 <Yojimbo-san> Clint: excellent, that seems to have worked around the problem successfully :-)
20:59:04 * Clint nods.
20:59:27 <Clint> although isn't this stuff in raspbian?
21:00:11 <Yojimbo-san> Clint: I'm getting this problem on raspbian and on ubuntu ... (
21:00:58 <Clint> http://archive.raspbian.org/raspbian/pool/main/h/haskell-hint/
21:00:58 <Clint> i guess not
21:01:03 <rwbarton> is it an architecture thing? maybe GHC doesn't support dynamic code loading on ARM for some reason? what architecture is the ubuntu machine?
21:01:15 <simpson> > concatMap (\n -> take n $ repeat n) [1..] -- coldpizza72i <<
21:01:17 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:01:42 <rwbarton> though then I would think that all kinds of things like ghci and TH wouldn't work either
21:02:18 <Clint> oh right
21:02:23 <Clint> there's no ghci
21:02:34 <Yojimbo-san> The Ubuntu box is a standard amd64 ... but it's an old 11.10 that I'm trying to upgrade to 12.04 or 12.10 later on this week
21:03:17 <Yojimbo-san> hey, I'm happy that I have a workaround at the moment! I don't have the time to debug further today, but I'll have a hunt for a mailing list to talk to later on
21:03:22 <Nereid> simpson: take n . repeat = replicate n
21:03:34 <simpson> Nereid: So it is.
21:09:14 <jmcarthur> > concatMap (join replicate) [1..]
21:09:16 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:09:31 <jmcarthur> > join replicate =<< [1..]
21:09:33 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:15:10 <johnw> that's pretty nifty, jmcarthur
21:15:29 <johnw> the list monad is something I have yet to fully wrap my head around
21:16:09 <johnw> the fact that join (as called by =<<) is mconcat is the clue here
21:16:13 <johnw> that is, there are two joins at work
21:16:26 <johnw> your join in the function monad with replicate, and then join in the list monad implied by >>=
21:16:40 <shachaf> johnw: It's just, like, nondeterministic choice, man.
21:16:53 <johnw> all of these things are easy to say, shachaf :)
21:17:04 <johnw> i want those DNA-level intuitions
21:17:18 <mm_freak> johnw: it's list comprehension in disguise
21:17:23 <shachaf> Identity : [] = Lens : Traversal
21:17:36 <mm_freak> > do x <- [1,2,3]; y <- [10,20,30]; return (x + y)
21:17:37 <lambdabot>   [11,21,31,12,22,32,13,23,33]
21:17:52 <johnw> mm_freak: i didn't mean at that basic of a level
21:18:09 <mm_freak> johnw: basic?  it's the only level
21:18:13 <johnw> i meant the kind of intuition that would have led me to instinctly realize that concatMap == >>= in jmcarthur's example
21:18:42 <jmcarthur> that's just because that's what >>= is for lists
21:18:48 <jmcarthur> no intuition there, just knowledge
21:18:54 <mm_freak> well, you have a list of values and a function that produces a list of values…  your goal is a list of values
21:19:17 <shachaf> (>>=) is too complicated anyway.
21:19:27 <shachaf> fmap/join/return is almost always simpler.
21:19:35 <johnw> shachaf: very much agreed
21:19:41 <mm_freak> there are some ways to do that and the usual list monad simply uses concatMap
21:19:56 <johnw> i now always write my monads with return/join/fmap now, and then write >>= if it optimizes better
21:20:21 <shachaf> johnw: Did you write instance Monad (Codensity f) yet?
21:20:23 <mm_freak> (>>=) is easier for non-data-like monads
21:20:36 <mm_freak> State, Reader, etc.
21:20:37 <shachaf> mm_freak: For example?
21:20:47 <johnw> shachaf: no, did we talk about that?
21:20:53 <shachaf> johnw: I don't think so.
21:21:00 <shachaf> johnw: http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
21:21:02 <johnw> I'll add it to my learning list though
21:21:15 <shachaf> join f = \x -> f x x -- simple
21:22:06 <johnw> yeah, that one I knew, and use quite often
21:22:11 <shachaf> johnw: Also did you figure out Traversal to your satisfaction?
21:22:22 <johnw> Traversal?  You mean, aka Context?
21:22:43 <shachaf> I mean Traversal.
21:22:52 * shachaf doesn't remember which one you were having trouble with anymore.
21:22:55 <johnw> oh, you mean, how to use lens traversals?
21:23:05 <johnw> i'm not having any particular difficulty just now
21:23:15 <johnw> I'm in the "settling" stage on that stuff, letting it sink in for a time
21:23:29 <johnw> at the moment my main thrust is CT and abstract algebra
21:24:12 <shachaf> type AbstractAlgebra a = Abstract a -> a
21:24:52 <johnw> you mean, Abstract (a -> a)?
21:24:56 <Saizan> @remember shachaf type AbstractAlgebra a = Abstract a -> a
21:24:56 <lambdabot> I will remember.
21:25:07 <jmcarthur> > (fmap join . fmap . join $ replicate) [1..]
21:25:10 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:25:38 <jmcarthur> i'm an awful person
21:26:43 <johnw> (>>=) = join .: flip fmap
21:26:54 <jmcarthur> .: is terrible
21:27:00 <latro`a> does that fix it here?
21:27:04 <latro`a> the joins aren't the same join
21:27:06 <Saizan> johnw: it's a pun on the fact that an F-algebra is a morphism F A -> A for some A
21:27:07 <johnw> (join .) . flip fmap is better?
21:27:14 <jmcarthur> no
21:27:31 <johnw> i like .:
21:27:37 <johnw> for the same reason I like join on functions
21:27:59 <jmcarthur> @let result = (.)
21:28:01 <lambdabot>  Defined.
21:28:04 <jmcarthur> :t (result.result) join fmap
21:28:05 <latro`a> ...
21:28:05 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
21:28:07 <shachaf> > fmap (fmap fmap fmap fmap (fmap fmap) fmap join) fmap fmap join replicate [1..]
21:28:09 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:28:14 <latro`a> what.
21:28:17 <jmcarthur> shachaf: beauty
21:28:18 <Nereid> shachaf +1
21:28:27 <jmcarthur> he just replaced (.) with fmap
21:28:30 <shachaf> jmcarthur: Who's the awful person now, huh?!
21:29:00 <shachaf> > fmap fmap fmap fmap (fmap fmap fmap fmap (fmap fmap)) fmap join fmap fmap join replicate [1..]
21:29:04 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
21:29:22 <johnw> now you've gotten him satrted
21:29:33 <donri> because fmap is more point-free than (.), right
21:29:37 <Nereid> :D
21:29:39 <rwbarton> :t fmap fmap fmap fmap (fmap fmap fmap fmap (fmap fmap))
21:29:41 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => f (a -> b) -> f (f1 (f2 (f3 a)) -> f1 (f2 (f3 b)))
21:30:02 <delamonpansie> hello
21:30:15 <delamonpansie> can somebody help me with gtk2hs ?
21:30:59 <Eduard_Munteanu> delamonpansie: hi, what about it?
21:31:27 <Nereid> if you need help installing gtk2hs with ghc 7.6.1, type 1. for all other inquiries, type 2.
21:31:49 <shachaf> 12
21:32:01 <latro`a> parse error
21:32:14 <shachaf> 1 2 base 8 which 10 base 10 and you take away 3 that's 7
21:32:25 <latro`a> wot
21:32:30 <delamonpansie> Eduard_Munteanu: how can i monitor "file-set" event of fileChooserButton ?
21:33:44 <delamonpansie> Eduard_Munteanu: or how i am supposed to write callback which fires then user select file?
21:34:07 <delamonpansie> i did try to
21:34:07 <delamonpansie> onFileSet :: FileChooserClass self => self -> IO () -> IO (ConnectId self)
21:34:07 <delamonpansie> onFileSet obj act = connectGeneric "file-set" False obj (failOnGError act)
21:34:19 <delamonpansie> but it fails miserably
21:35:08 <Eduard_Munteanu> Maybe someone else has an idea.
21:36:45 <delamonpansie> ookay
21:36:55 <delamonpansie> is there a protable way to check file size ?
21:37:52 <Nereid> @hoogle filesize
21:37:53 <lambdabot> System.Posix.Files fileSize :: FileStatus -> FileOffset
21:37:53 <lambdabot> System.Posix.Files FileSizeBits :: PathVar
21:37:53 <lambdabot> System.Posix.Signals fileSizeLimitExceeded :: Signal
21:38:00 <Nereid> @hoogle hFileSize
21:38:00 <lambdabot> System.IO hFileSize :: Handle -> IO Integer
21:38:01 <lambdabot> GHC.IO.Handle hFileSize :: Handle -> IO Integer
21:39:01 <delamonpansie> where is no System.Posix on Windows
21:39:05 <Nereid> hFileSize is probably portable
21:39:12 <Nereid> but you have to be able to open the file
21:39:22 <delamonpansie> getFileSize :: FilePath -> IO Integer
21:39:22 <delamonpansie> getFileSize x = do
21:39:22 <delamonpansie>   handle <- openFile x ReadMode
21:39:22 <delamonpansie>   size <- hFileSize handle
21:39:22 <delamonpansie>   hClose handle
21:39:22 <delamonpansie>   return size
21:39:24 <Nereid> because windows isn't a posix system :)
21:39:34 <delamonpansie> but this is ugly.
21:39:40 <Nereid> indeed
21:40:18 <rwbarton> I'm surprised there isn't one in directory
21:40:26 <Nereid> me too, that's the first place I looked
21:40:41 <Nereid> you can get modification time but not size ???
21:41:15 <delamonpansie> feel my pain
21:41:37 * delamonpansie trying to write portable gtk app
21:42:20 <donri> http://hackage.haskell.org/packages/archive/unix-compat/0.4.0.0/doc/html/System-PosixCompat-Files.html#g:6
21:42:44 <Nereid> aha
21:43:57 <Nereid> except that effectively does the same thing
21:44:05 <Nereid> just a bit safer (it uses bracket) ...
21:44:24 <donri> aha
21:45:33 * Nereid mentally records the fact that unix-compat exists
21:45:45 <donri> what's wrong with hFileSize then? does it actually consume the file or something?
21:45:54 <Nereid> you have to be able to read the file
21:46:05 <Nereid> so if you don't have read permissions then you can't
21:46:12 <rwbarton> also it takes five lines instead of one
21:46:16 <Nereid> although I imagine most of the time it's not a problem
21:46:19 <doctau> I haven't used gtk with haskell, but in C you would use g_file_query_info and then look at G_FILE_ATTRIBUTE_STANDARD_SIZE
21:46:27 <donri> but you can get the size for unreadable files portably?
21:46:32 <donri> "in theory"?
21:46:36 <Nereid> yes, I was imagining there was something in gio you could use.
21:47:15 <donri> yea if it's for gtk you probably should stick to gio to make it work over networks and such
21:47:26 <Nereid> there's a fileInfoGetSize
21:47:33 <doctau> cf http://developer.gnome.org/gio/2.32/GFileInfo.html
21:49:27 <delamonpansie> as far as i can understand building posix-compat requires msys
21:50:53 <Nereid> building a lot of things on windows requires mingw/msys
21:58:09 <Nereid> I should probably learn how to use *some* gui library at some point.
21:58:39 <Nereid> gtk seems like a reasonable place to start.
21:59:16 <Nereid> they just all look so intimidating.
22:00:39 <pordan30> after failing miserably to install reactive banana dependencies, i tried working with grapefruit: that's a steep learning curve!
22:03:05 <mm_freak> pordan30: you could try netwire as an alternative
22:09:09 <jmcarthur> > fmap (fmap (fmap (fmap join (fmap (fmap fmap fmap snd (fmap (fmap fmap ap zip) fmap repeat length)))) fix) (fmap (pure mempty :))) (zipWith (++)) $ fmap repeat pure ()
22:09:12 <lambdabot>   [1,2,2,3,3,3,4,4,4,4,5,5,5,5,5,6,6,6,6,6,6,7,7,7,7,7,7,7,8,8,8,8,8,8,8,8,9,...
22:09:24 <jmcarthur> shachaf: now who's awful?
22:09:44 <jmcarthur> this can go on forever
22:09:56 <shachaf> jmcarthur: The goal was to get rid of all the parentheses.
22:09:58 <shachaf> Not to add more!
22:10:18 <jmcarthur> i added more opportunities to get rid of them
22:10:31 <nicoo> jmcarthur: Nicely argued.
22:10:52 * jmcarthur goes to bed
22:11:44 <shachaf> jmcarthur: If you were ddarius you would link to that paper on flattening combinators and I would probably once again not read it.
22:11:47 <shachaf> Where is ddarius, anyway?
22:13:01 <nicoo> jmcarthur: Good night.
22:13:46 <Ghoul> Well, actually
22:13:55 <Ghoul> jmcarthur's thing can probably done with fix
22:14:09 <typoclass> shachaf: i've got you beat. you claim you would not read that paper on flattening combinators, i can claim i have not read papers on all sorts of things
22:14:43 <shachaf> typoclass: I've never read a paper in my life!
22:14:46 <shachaf> In fact, I don't know how to read.
22:15:07 <shachaf> I only know how to write, and the only thing I know how to write is frowns.
22:15:10 <shachaf> johnw can confirm it.
22:15:24 <typoclass> shachaf: welcome to irc then!
22:15:40 <johnw> haha
22:16:09 <johnw> shachaf is Writer, not State
22:16:21 <shachaf> johnw: Did you see my great Monoid instance?
22:16:27 <johnw> no!  where?
22:16:44 <nicoo> johnw: Yet many Writers concern themselves with issues of State, imaginary or real.
22:16:47 <shachaf> data Nonoid a = NLeaf a | NEmpty | NAppend (Nonoid a) (Nonoid a)
22:17:09 <johnw> aka Tree?
22:17:15 <shachaf> Pretty much.
22:17:15 <typoclass> @remember nicoo Yet many Writers concern themselves with issues of State, imaginary or real
22:17:15 <lambdabot> Okay.
22:17:19 <shachaf> Well, it's a bit of a weird tree.
22:48:43 <shachaf> @yarr
22:48:44 <lambdabot> May the clap make ye incapable of Cracking Jenny's Tea Cup.
22:48:51 <shachaf> @nixon
22:48:52 <lambdabot> Always remember that others may hate you but those who hate you don't win unless you hate them. And then you destroy yourself.
22:53:16 <coldpizza72i> whats drSpace in drawBoard http://www.cs.rit.edu/~mtf/teaching/20113/psfp/homeworks/homework04/soln/GTicTacToe04.hs
22:54:02 <coldpizza72i> ohhh nevermind
22:54:16 <coldpizza72i> i didn't know you can have multiple thing in where like that
22:55:36 <typoclass> coldpizza72i: yup :) you can have multiple things. but the indentation needs to be correct (note how "h" is aligned with all the "d"s)
23:03:08 <aetcore> Has nayone come across this lately? https://gist.github.com/3bc5cd0a75f49ea6e145
23:10:05 <Nereid> aetcore: it's probably more helpful if you post full build logs
23:14:18 <aetcore> Nereid: https://gist.github.com/786b3cd9c1c459b4103b Im trying to build Conduit, and it dies at that point, i have also cleared the packages incase it was a corrupt tar file
23:16:17 <Nereid> hmm that's it?
23:16:33 <Nereid> "ExitFailure 9" is unusual...
23:16:38 <Nereid> out of memory?
23:17:02 <aetcore> oh really
23:17:08 <Nereid> maybe?
23:17:15 <aetcore> i will admit this is being compiled on a AWS Micro
23:17:19 <Nereid> heh
23:17:30 <Nereid> watch the memory usage perhaps
23:18:15 <aetcore> yeah doing that now, have htop going at the same time
23:21:33 <aetcore> lol
23:21:38 <aetcore> good guess :)
23:25:40 <pauser> hello, im having some troubles with recursive data types, i dont know why it makes me problems http://hpaste.org/77707 . What is the way to iterate through all elements or add 2 of them or something
23:26:14 <shachaf> pauser: What's showw supposed to do?
23:26:29 <pauser> just to iterate the elements
23:26:35 <shachaf> What elements?
23:26:48 <shachaf> showw has type Nat -> Nat
23:26:53 <pauser> f.e. S S S Z
23:27:12 <statusfailed> Is there a license for the haskell logo?
23:27:15 <shachaf> You give showw a natural number and it gives you one back.
23:27:50 <pordan30> showw :: Nat -> Nat but S :: Nat -> Nat, so showw S implies that showw :: (Nat -> Nat) -> Nat
23:28:14 <statusfailed> oh it's public domain, cool
23:28:45 <pauser> pordan30: wow thats too damn high for me now
23:29:23 <shachaf> Like the rent?
23:31:12 <pordan30> if you intend showw to be an identity function over Nat, then in the recursive case, you will need to construct the term by applying S to the result of calling showw on the value inside S. you can do this via pattern matching, most easily.
23:32:31 <shachaf> Are we playing the mind-reading game?
23:33:00 <shachaf> pauser hasn't said what they want, so guessing random things that happen to match the type is a bit silly. :-)
23:33:26 <mm_freak> for unboxed mutable vectors i guess that "unsafeThaw (fromList xs)" is safe, isn't it?  no sharing of the original immutable vector
23:33:47 <pordan30> he said: "what is the way to iterate through all the elements or add 2 of them or something" so i chose the first disjunct =)
23:34:06 <shachaf> It seems to me like an attempt at mind-reading.
23:34:19 <shachaf> The thing about mind-reading is that even if you succeed, you only train people to ask vague questions.
23:36:27 <pordan30> we could be all post-neo-post-kantian about it, and say that we're always mind-reading all the time
23:36:37 <shachaf> Let's don't.
23:39:28 <Saizan> it's not always helpful to confront someone in a position of cognitive dissonance with demands to resolve it, a corpus of sensible code and reasoning might be a better approach
23:39:56 <pauser> ok, here i have a concrete question, how do i add 2 Nats like here http://hpaste.org/77708
23:40:28 <shachaf> I agree. But I think attempted mind reading is worse than nothing.
23:40:32 <aetcore> Is Haskell a good language for Network Operations? for example telnetting into a Router to make modifications etc? Google doesnt seem to know my specific use case
23:40:39 <shachaf> See, now pauser is asking a much clearer question. :-)
23:40:53 <Bynbo7> aetcore: can't see why not
23:41:19 <Saizan> pauser: http://hpaste.org/77708
23:41:30 <Saizan> pauser: the annotation, i mean
23:41:59 <aetcore> i like haskell over C++ or most of the other Compiled Languages, but i have never really done any Networking inside Haskell, so i this exercise will be productive
23:42:31 <aetcore> so i hope this exercise will be productive**
23:43:21 <Axman6> is telnet anything more than just opening a socket and sending text (and presumably some controll characters) over it?
23:43:21 <lambdabot> Axman6: You have 1 new message. '/msg lambdabot @messages' to read it.
23:43:29 <Axman6> @messages
23:43:29 <lambdabot> ivanm said 7d 5h 6m 16s ago: oh, happy birthday for Monday! *blames phone for not telling him sooner*
23:43:39 <shachaf> You can write network programs just fine in Haskell.
23:43:44 <pauser> Saizan: Thanks very much, now im trying to get what you did here ;)
23:43:50 <shachaf> It's not materially different from any other language.
23:44:01 <Saizan> pauser: "pattern matching", mainly
23:44:06 <aetcore> Axman6: my understanding is the same as yours
23:45:38 <aetcore> shachaf: thanks im actually kind of excited, im also learning, and reading Learn you a good Haskell at the same time, hopefully in a couple of months im a little more fluid with Haskell
23:47:08 <Axman6> Haskell is an awesome language for writing network servers (it handles concurrency very well)
23:47:21 <mm_freak> aetcore: haskell is one of the best languages for writing network applications
23:47:27 <aetcore> so in future please excuse my trivial questions :)
23:47:36 <Axman6> aetcore: we welcome them!
23:47:56 <pauser> Saizan: do you that im learning here more that at the university :D
23:50:22 <Saizan> pauser: it happens :)
23:50:57 <Axman6> it's also not the fault of the university. at uni, haskell is a tool for learning other topics, not the topic to be learnt
23:51:13 <pauser> very true
23:53:13 * hackagebot quickset 0.1.0 - Very fast and memory-compact query-only set and map structures  http://hackage.haskell.org/package/quickset-0.1.0 (ErtugrulSoeylemez)
23:53:46 <Moggle> Could some awesome person tell me how exactly Haskell calls something like
23:53:50 <Moggle> fib n = fibs !! n
23:53:51 <Moggle>         where fibs = 0 : scanl (+) 1 fibs
23:53:53 <Moggle>         -- 0,1,1,2,3,5,...
23:54:06 <shachaf> What do you mean?
23:54:12 <mm_freak> Moggle: could you rephrase that question?
23:54:22 <Axman6> do you mean how it's executed?
23:54:28 <Moggle> I am having a hard time writing a trace for it just to try and figure out how it works exactly
23:54:36 <Moggle> I understand how scanl works, but in this case
23:54:40 <Moggle> fibs returns an infinite list
23:54:47 <Moggle> and so the thing is doing scanl at each level of recursion
23:54:48 <Axman6> laziness!
23:54:50 <shachaf> OK, so you mean how GHC evaluated it. :-)
23:54:52 <Moggle> and I am having a hard time wrapping my brain around it
23:54:53 <mm_freak> Moggle: fibs /is/ an infinite list
23:55:06 <Moggle> I'm trying to figure out how hard for scanl goes, mm_freak
23:55:11 <shachaf> Moggle: Just take it one step at a time.
23:55:16 <shachaf> First take the list on its own:
23:55:24 <shachaf> > let fibs = 0 : scanl (+) 1 fibs in fibs
23:55:24 <mm_freak> Moggle: do you know how to define a list recursively?
23:55:26 <mm_freak> like…
23:55:26 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
23:55:32 <mm_freak> > let ones = 1 : ones in ones
23:55:34 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:56:08 <Moggle> ones = 1 : ones
23:56:11 <Moggle> makes perfect sense
23:56:20 <Moggle> not entirely sure how to apply it to this bit here though
23:56:26 <coldpizza72i> on my study cheat my professor bulleted "monads, specifically use of the binding operators and how do blocks translate to monad calls"
23:56:29 <Moggle> when it calls fibs, will it initially give it a list [0]
23:56:43 <coldpizza72i> Aren't do blacks monads…. i don't get what he's going after...
23:56:47 <coldpizza72i> blocks*
23:56:52 <Moggle> For example
23:56:53 <Axman6> fibs = 0 : scanl (+) 1 (0 : scanl (+) 1 (...)) ==> fibs = 0 : 1 : scanl (+) (1 : scan...) ==> fibs = 0 : 1 : 1 : scanl (+) 2 (1 : scan...)
23:57:00 <mm_freak> Moggle: fibs is the infinite list all the time…  there is really nothing special going on…  that combination just happens to be the fibonacci numbers
23:57:15 <mm_freak> Moggle: don't think too operationally
23:57:19 <Moggle> Alright o.O
23:57:27 <mm_freak> i.e. don't think in steps, but in relations
23:57:32 <Moggle> It's hard coming from the huge amount of imperative languages I know
23:57:39 <coldpizza72i> Anyone have an ideas?
23:57:42 <coldpizza72i> idea*
23:57:45 <Axman6> Moggle: isn't it fun!
23:57:45 <Moggle> but that's why I'm enjoying Haskell so much :D
23:57:49 <Moggle> yes, it is SUPER fun
23:57:52 <Moggle> an amazing new way to look at things
23:58:13 <Moggle> My problem was just that I thought scanl would keep scanning over and over in the initial list but I guess that's the point and D:
23:58:18 <Moggle> thanks for all your help guys!
23:58:37 <Saizan> @undo do x <- foo; y <- bar x; baz x y
23:58:37 <lambdabot> foo >>= \ x -> bar x >>= \ y -> baz x y
23:58:40 <Axman6> Moggle: remember that scanl also drops elements from the input list each time it recurses
23:58:44 <Saizan> coldpizza72i: the above ^^^
23:58:53 <mm_freak> Moggle: i don't know who came up with the name, but scanl is really just foldl returning the list of all intermediary elements instead of just the result =)
23:59:23 <shachaf> > scanr1 const "hello"
23:59:25 <lambdabot>   "hello"
