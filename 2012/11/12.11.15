00:02:13 <hpaste> neutrino pasted “Haskell reference in Vim” at http://hpaste.org/77778
00:10:01 <fmap> neutrino: does this hang vim until holumbus.fh-wedel.de responds?
00:25:05 <neutrino> fmap: yes
00:25:42 <neutrino> fmap: it's instant on my end. by that i mean there's not even a split second loading time between pressing K and showing the selection menu.
00:26:37 <SamanthaAD> Hello!
00:27:03 <neutrino> hi SamanthaAD
00:28:10 <SamanthaAD> I came here because I need help with a reading list. I got interested in learning Haskell while reading the Structure and Interpretation of Computer Programs. Anyway, to make a long story short I was trying to learn the theory behind monads and I'm thoroughly flummoxed.
00:28:52 <neutrino> why are you learning it? to use monads, or to write your own?
00:29:29 <SamanthaAD> I'm trying to learn it because I really want to understand what is going on in the computer when I use them.
00:31:46 <SamanthaAD> ... that and I've come to the realization that I don't understand a lot of what is written when I read about functional data structures
00:32:02 <SamanthaAD> ... of which a monad is a type, of course
00:33:43 <neutrino> SamanthaAD: hmm, got any specific questions?
00:34:15 <shachaf> SamanthaAD: Did you see the FAQ's section on monads?
00:34:17 <shachaf> @where faq
00:34:18 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:34:52 <shachaf> The short answer is that you probably shouldn't really worry about "understanding monads" for a while. :-)
00:35:44 <shachaf> "monad" is the name of an API that abstracts many individual things.
00:35:58 <SamanthaAD> shachaf: Alright... I had read the FAQ. I guess I'm just overthinking things
00:36:02 <startling> SamanthaAD, http://blog.sigfpe.com/2007/04/trivial-monad.html helped me a lot
00:36:05 <neutrino> SamanthaAD: what is your background? do you know any algebra, or category theory?
00:36:34 <startling> SamanthaAD: it's nowhere near as hard as people think it is, though. My advice is to read that link and then rewrite Maybe and its monad instance
00:36:45 <shachaf> SamanthaAD: People make a big fuss about "monads" but it's really not as fundamental to understanding Haskell as a lot of things.
00:37:09 <shachaf> (You don't need to know any category theory, certainly. :-) )
00:37:22 <SamanthaAD> neutrino: I have some undergraduate mathematics. I I'm comfortable with algebra and I've had everything up to my first year of calculus. I've had no discreet mathematics, though.
00:37:47 <startling> oh, you only took the load and obvious kind? ;)
00:37:51 <startling> *loud
00:38:00 <Sonderblade> is there any haskell library for recursively visiting each file in a directory tree?
00:38:37 <shachaf> People don't usually talk about discreet mathematics in public.
00:38:42 <AfC> Sonderblade: yes
00:39:37 <SamanthaAD> startling: thank you for the link! I've not yet seen that one yet. I will read it.
00:40:03 <AfC> Sonderblade: http://hackage.haskell.org/package/filemanip
00:40:09 <neutrino> SamanthaAD: if you just want to be able to write haskell code that works, you don't need to understand monads. if you're really interested in what makes them tick, ask Cale about it when he's around, he seems to really like the topic.
00:40:34 <startling> SamanthaAD, http://acm.wustl.edu/functional/haskell.php also helped me a lot for general language-learning
00:40:39 <AfC> Sonderblade: takes a bit to get your brain around (like most of bos's work, it's sadly lacking in examples) but it's really nice to use
00:41:52 <SamanthaAD> neutrino: thank you, I'll make sure to ask him. In the mean time I think I'm going to order Epp's book and read it and then read this paper I found on the theory of monads. I find the math interesting anyway and maybe it will help me write better code, or at least enjoy it more.
00:42:03 <neutrino> what is Epp's book?
00:42:39 <Sonderblade> AfC: yeah that's not a lot of documentation
00:42:39 <SamanthaAD> neutrino: "Discrete Mathematics with Applications"
00:43:15 <SamanthaAD> neutrino: I've heard it's an easy book to parse for someone who new to discreet math and I want to understand it so I can understand functional data structures.
00:43:46 <neutrino> i think i've had that in my hands at one point
00:44:11 <neutrino> you might find this presentation i stumbled upon yesterday interesting http://comonad.com/reader/wp-content/uploads/2009/08/IntroductionToMonoids.pdf
00:44:46 <SamanthaAD> neutrino: monoid... I was under the impression that Monoids are slightly different than monads but I guess I might be wrong...
00:44:52 <neutrino> yes
00:44:53 <neutrino> they are
00:44:58 <shachaf> Samantha: I suspect that learning about discrete mathematics would be both fun and not the most helpful thing for learning about purely functional data structures. :-)
00:45:28 <neutrino> it touches on monoids and then, at the very end, shows a comparison of different mathematical structures
00:45:40 <neutrino> if you can't read the whole thing, just look at the table at the end that compares them
00:45:55 <SamanthaAD> neutrino: thank you! I will!
00:46:23 <neutrino> yw SamanthaAD
00:46:26 <neutrino> good luck
00:47:55 <SamanthaAD> shachaf: Maybe... I was just told that it would help with reading "Purely FUnctional Data Structures" by Okasaki
00:48:33 <startling> SamanthaAD, seconding that more math isn't necessarily the answer
00:48:42 <shachaf> It seems like a pretty roundabout way to go about reading that book.
00:48:56 <SamanthaAD> shachaf: you recemmond just diving into it then?
00:51:04 <shachaf> Into Okasaki? You could try it. :-)
00:51:32 <SamanthaAD> shachaf: alright! I'll do that then!
00:51:38 <shachaf> It might have prerequisites but I'm not sure that you'll find them in an algebra book.
00:52:25 <SamanthaAD> thanks for your time, I guess if I get confused I can alaways put it back on the shelf and come back to it once I've brushed up on the prereqs rather than doing everything backwards.
00:52:58 <SamanthaAD> Thanks for everyone's time and help. I really appreciate it.
00:53:37 <shachaf> I don't think purely functional data structures have that much to do with monads, for that matter.
00:54:30 <startling> > take 3 . map (`mod` 0x100) . iterate (`div` 0x10) $ 0xffffff
00:54:33 <lambdabot>   [255,255,255]
00:54:36 <startling> :D
00:55:07 <shachaf> startling: ?
00:55:24 <SamanthaAD> Anyway, I have to go now. My partner is trying to sleep and the light from my screen is bothering her, I think.
00:55:32 <startling> shachaf, Num instance for my Color.
00:55:41 <shachaf> > take 3 . map (`mod` 0x100) . iterate (`div` 0x10) $ 0x0000ff
00:55:44 <lambdabot>   [255,15,0]
00:55:50 <shachaf> Are you sure that's the instance you want?
00:55:50 <startling> ...oh.
00:55:58 <SamanthaAD> goodnight!
00:56:47 <startling> Oh, I see what it's doing.
01:10:26 <startling> can I get a Word4 somewhere?
01:10:46 <AfC> 1986, maybe?
01:11:02 <mapf> startling: for what?
01:11:15 <bartavelle> hex encoding I'd guess
01:11:22 <startling> mapf, indexing into the 24 ansi colors.
01:11:38 <startling> er, 16 ansi colors
01:12:05 <startling> I also want something to index into the 24-color grayscale ramp, but you know.
01:13:14 <mapf> i guess you can define appropriate data type
01:13:33 <startling> yeah, I can just do a huge enum.
01:14:03 <bartavelle> data Word4 = Word4 Bit Bit Bit Bit   :)
01:14:13 <shachaf> Or you can define a Word4 type that wraps a bigger number.
01:14:47 <startling> bartavelle: thought about that. :D
01:15:39 <bartavelle> startling, actually, if you are going to do that, an indexed array would make more sense at operation implementation should be more compact
01:15:59 <bartavelle> but it would be more compact even with just Int ...
01:16:13 <startling> I think I'll just define a higher-level type and marshal two and from Word8 explicitly
01:16:24 <startling> *to, of course
01:16:48 <shachaf> @src Word8
01:16:49 <lambdabot> Source not found. Wrong!  You cheating scum!
01:16:57 <zhulikas> whoa
01:17:02 <zhulikas> lambdabot is angry today
01:17:05 <shachaf> @src Int16
01:17:06 <lambdabot> data Int16 = I16# Int#
01:21:32 <bartavelle> is that legal to use # types in regular haskell ?
01:21:55 <mapf> bartavelle: there are extension to this
01:21:56 <quicksilver> well # is just a character.
01:22:04 <quicksilver> in standard haskell # is an operator character.
01:22:13 <startling> > let (#) = (+) in 12 # 13
01:22:15 <lambdabot>   <hint>:1:7: parse error on input `)'
01:22:22 <quicksilver> GHC has an extension to make # instead part of an 'alphabetic' operator
01:22:34 <quicksilver> and then - just as a convention - GHC names internal functions and internal types with #
01:23:59 <startling> can I make haskell-mode use cabal ghci ?
01:24:18 <mapf> bartavelle: http://www.haskell.org/ghc/docs/6.12.2/html/users_guide/syntax-extns.html#magic-hash  it's related?
01:24:40 <shachaf> quicksilver: Sometimes # can take the magic role of being both an infix symbol and an "alphabetic" symbol.
01:24:44 <startling> mapf: that's it
01:24:48 <shachaf> So you can define infix (#) and also foo#
01:24:51 <quicksilver> shachaf: yes, that's even more confusing :)
01:25:07 <startling> > let foo# = (+) in foo# 1 2
01:25:08 <lambdabot>   3
01:25:09 <shachaf> quicksilver: That led to an amusing pseudo-bug in lens recently.
01:25:14 <startling> shachaf: haha
01:25:15 <quicksilver> but anyway, the point is to separate the GHC syntactic extension - whch is about using # when it's not normally allowed.
01:25:28 <quicksilver> from the actual magic primitives like Int#
01:25:38 <shachaf> We declared (#) and "foo", and "foo#" as a special optimized version of (foo #)
01:25:45 <quicksilver> which are magic in the sense that they can't be defined - they're primitive.
01:25:46 <shachaf> The same file compiles with and without MagicHash, but differently.
01:25:55 <quicksilver> shachaf: hah :)
01:27:13 <shachaf> Sadly, the only working definition for "foo#" that I could figure out was "unsafeCoerce". :-(
01:27:14 <Sonderblade> any builtin function that is equivalent to (\x -> return x)?
01:27:19 <shachaf> Sonderblade: Yes, return
01:27:30 <Sonderblade> ah yes :)
01:27:37 <startling> heh
01:27:39 <luite> :)
01:38:49 <startling> I've got one of those dumb bitfields from C. what's the way to check whether some n is in the bitfield?
01:39:44 <fmap> :t (.&.)
01:39:46 <lambdabot> Bits a => a -> a -> a
01:40:29 <startling> ah, &, right.
01:40:38 <fmap> :t testBit
01:40:39 <lambdabot> Bits a => a -> Int -> Bool
01:40:53 <fmap> that's probably more convenient
01:41:13 <startling> hm, maybe
01:41:37 <shachaf> Not if you already have masks.
01:41:49 <startling> yeah, I've already got masks.
01:41:51 <shachaf> You should probably be using masks. :-)
01:43:49 * hackagebot hakyll 3.5.1.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.5.1.0 (JasperVanDerJeugt)
01:49:35 <tomboy64> are [Char] and String equal?
01:49:51 <zomg> tomboy64: iirc String is just a type synonym for [Char]
01:49:58 <startling> @src String
01:49:58 <lambdabot> type String = [Char]
01:50:33 <tomboy64> e.g. when one function returns a String, can i use it as input for a function that takes [Char]?
01:50:57 <flux> tomboy64, yes
01:51:12 <tomboy64> thanks :)
01:53:22 <yitz> the ghc parsing rules for # really are crufty. it is alphabetic *and* operator *and* delimiter. when the context makes it unclear what you mean, good luck.
01:53:45 <yitz> i guess that's one good way to make it de facto reserved for internal use ;)
01:54:26 <mapf> is it possible to make hscolour and ghc/runhaskell/cabal work together? it should be nice to highlight error messages
01:54:55 <neutrino> yitz: what is #?
01:55:10 <Eduard_Munteanu> The magic hash.
01:55:30 <yitz> neutrino: a unicode character, whose meaning in ghc is different than in the haskell standard.
01:55:43 <neutrino> can you explain this a bit more?
01:55:45 <yitz> neutrino: when used in haskell source code.
01:57:06 <yitz> > let foo# = (+) in f00# 1 2 -- as startling wrote above
01:57:08 <lambdabot>   Not in scope: `f00#'
01:57:16 <yitz> > let foo# = (+) in foo# 1 2 -- as startling wrote above
01:57:18 <lambdabot>   3
01:57:28 <yitz> > let x# = 5; x = 20; (#*) = (+) in (x#*4, x #*4)
01:57:30 <lambdabot>   (20,24)
01:58:25 <neutrino> when is it a delimiter?
01:58:37 <startling> shachaf, what do you think about a `bitfield` lens in Data.Bits.Lens that takes a mask and gets you a Bits b => Simple Lens b Bool ?
01:59:09 <yitz> neutrino: with the MagicHash extension, there are brackets like (# .. #) for unboxed tuples
01:59:30 <neutrino> mhm
01:59:51 <shachaf> startling: There's already bitAt
02:00:01 <startling> shachaf, that's different though
02:00:02 <shachaf> What doe your proposed lens do if you give it a mask with more than one 1?
02:00:35 <startling> shachaf, it works
02:01:27 <shachaf> Works?
02:01:43 <startling> is 'bitfield' the wrong term here? I'm talking about things like A_BOLD and A_BLINK from ncurses, that you OR together to get the attribute you want.
02:02:00 <shachaf> Yes, but what if you give it 3?
02:02:11 <startling> shachaf, then you get nonsense, I guess.
02:02:23 <shachaf> That doesn't really sound like a lens. :-)
02:02:37 <startling> shachaf, it's a valid lens! it just doesn't have any semantic meaning
02:03:28 <Ralith> it seems like bitAt is already all you'd want
02:03:41 <luite> it could return True x `or` mask /= 0?
02:03:46 <luite> +if
02:03:54 <shachaf> startling: It sounds more like a traversal to me.
02:03:56 <hkBst> do you need to use an extension to GHC to enable something like this: data RealsXReals   real_type = RxR  {real :: real_type} {imag :: real_type}
02:04:09 <shachaf> Because it can focus on more than one bit.
02:04:25 <shachaf> startling: How is it a valid lens?
02:04:28 <Eduard_Munteanu> hkBst: no, but that syntax isn't valid
02:04:39 <hkBst> Eduard_Munteanu: ah, how so?
02:04:40 <shachaf> startling: What's view (bitfieldLens 0x03) 0xff?
02:04:58 <applicative> data RealsXReals  real_type = RxR  {real :: real_type, imag :: real_type}
02:05:31 <hkBst> applicative: ah, can't believe I did not notice that :) thanks
02:05:38 <startling> shachaf, True
02:06:43 <shachaf> startling: Maybe you should just write the code because I'm not quite sure what you're describing. :-)
02:07:22 <startling> shachaf: I wrote it! one second
02:08:41 <Nereid> startling: what does getting and then putting back do?
02:08:57 <startling> Nereid: it ORs, so nothing.
02:09:08 <Nereid> are you sure?
02:09:19 <startling> yes
02:09:28 <Nereid> suppose I get a True.
02:09:31 <Nereid> what happens when you put a True?
02:09:51 <startling> Nereid, you get the original .|. the mask, so nothing changes.
02:10:05 <Nereid> yes something changes.
02:10:08 <Nereid> you don't get the original.
02:10:09 <Nereid> hence, not a lens
02:10:51 <Nereid> well, what exactly does getting do?
02:10:55 <startling> > 0xff .|. 0x03 == 0xff
02:10:57 <lambdabot>   True
02:11:11 <Nereid> say my bit field is 01
02:11:13 <Nereid> and my mask is 11
02:11:17 <startling> OR-ing with a mask that a field already contains doesn't change it
02:11:17 <Nereid> what's the result of getting?
02:11:28 <startling> is that binary?
02:11:30 <Nereid> yes
02:11:34 <hvr> > 0xff .|. (-2)
02:11:36 <lambdabot>   -1
02:12:17 <startling> Nereid, True
02:12:22 <startling> hvr, hmm, good point
02:12:29 <Nereid> ok, and so if I put True in
02:12:34 <Nereid> then we get 01 | 11 = 11
02:12:38 * shachaf suspects that if startling has the code, it would be simpler to just look at the code.
02:12:41 <Nereid> which is not 01 which we started with.
02:12:55 <Nereid> hence not a lens
02:13:02 <Nereid> it can't be a lens.
02:13:28 <startling> Nereid: oh, yeah, you're right.
02:13:37 <Nereid> you could modify it so that getting then putting is id
02:13:48 <Nereid> but then you'd lose that setting twice is the same as setting once
02:14:03 <startling> yes
02:14:36 <startling> shachaf, here's my code https://gist.github.com/17fa3e23c07e2d92bac0
02:14:36 <Nereid> it's certainly a traversal though
02:14:49 <startling> sure
02:14:53 <Nereid> and the traversal does basically what you want it to do
02:15:11 <Nereid> if you get with the Or monoid
02:15:25 <Nereid> or whatever it's called
02:15:32 <Nereid> Bool with (<>) = (||)
02:15:34 <shachaf> Nereid: Except for being slightly less convenient when you're sure your mask only has one thing.
02:15:37 <shachaf> anyOf
02:15:54 <Nereid> shachaf: nah
02:15:59 <Nereid> it's better
02:16:21 <shachaf> There's no infix operator for anyOf!
02:16:30 <Nereid> you don't need one
02:16:37 <Nereid> remember how you can get any traversal into a monoid?
02:16:47 <shachaf> Anyway, I agree that what startling described isn't a lens.
02:16:52 <shachaf> Oh, wait, there's some code. :-)
02:16:58 <shachaf> Nereid: ?
02:17:07 <Nereid> ah, I'm lookinag at the Any monoid
02:17:25 <Sonderblade> i have a type that is an instance of Traversable, how do i use traverse to iterate through it?
02:17:33 <Nereid> Sonderblade: define "iterate"
02:17:43 <Sonderblade> print all items in it
02:17:59 <startling> Sonderblade: traverse print
02:18:39 <startling> so, can I pretend it is a valid lens if I know that all my masks are mutually exclusive?
02:18:42 <Sonderblade> thanks
02:19:03 <shachaf> startling: What if you know that all your masks are powers of 2?
02:19:03 <Nereid> startling: you can pretend it's a valid lens if all your masks have exactly one bit set
02:19:36 <startling> shachaf, what if they're all mardi gras masks?
02:19:52 <Ralith> startling: why do you want this? What's a usecase it serves that bitAt doesn't?
02:20:03 <shachaf> startling: Anyway, your thing certainly breaks the lens laws as it is with arbitrary masks.
02:20:16 <startling> Ralith, I'm binding to a C thing that has the masks defined in the header
02:20:26 <Ralith> yes, and?
02:20:50 * shachaf thinks masks are a bit nicer.
02:21:20 <startling> Ralith: so I'm using hsc2hs to get those values rather than assuming everyones' ncurses have the same headers
02:21:31 <Ralith> if those masks aren't single-bit, the lib author should be smacked and you should paper over the difference in the haskell wrapper :P
02:22:59 <shachaf> Ralith: Where do you get the bit values from?
02:23:36 <Ralith> shachaf: what bit values?
02:23:57 <shachaf> The arguments you pass to bitAt.
02:24:12 * Ralith wasn't imagining bitAt being used.
02:24:18 <startling> Ralith, I mean, I could iterate through using bitAt and then compare using bitAt
02:24:21 <shachaf> 02:19 <Ralith> startling: why do you want this? What's a usecase it serves that bitAt doesn't?
02:24:27 <startling> haha
02:24:34 <Ralith> shachaf: yes, then he answered the question.
02:24:35 <Ralith> :P
02:24:48 <shachaf> Ah.
02:24:54 <shachaf> Anyway, as a traversal this might be sort of nice.
02:25:06 * Ralith isn't sure what the point would be
02:25:17 <shachaf> Of a traverseMask?
02:25:51 <shachaf> I guess in practice most uses of it would be better expressed as bitwise operations with the mask directly.
02:27:22 <Nereid> ok, say we ignore this newtype Any business
02:27:33 <Nereid> and suppose we wrote instance Monoid Bool where mempty = False; mappend = (||)
02:27:42 <Nereid> then your traversal would be very nice
02:27:52 <Nereid> er, you could use it in a nice way
02:28:00 <Nereid> [False,True] ^. traverse = True, for instance
02:28:02 <spacekitteh> so like. i'm trying to install hmatrix by cabal install hmatrix, and then it complains  that it can't find lapack. however, i have lapack installed, and i tried linking it with cabal install hmatrix --configure-option=link:libreflapack but it doesn't work still. anyone know how i can get this damn thing installed? D:
02:28:16 <shachaf> JaffaCake: Have you considered adding the nice utility functions from "spawn" to async?
02:28:29 <shachaf> For example spawn :: IO a -> IO (IO a); spawn = fmap wait . async
02:28:30 <Nereid> > [False,True] % traverse .~ True
02:28:32 <lambdabot>   [True,True]
02:28:53 <shachaf> Nereid: Sure.
02:28:59 <shachaf> This is what anyOf does.
02:29:04 <Nereid> yes
02:29:20 <Nereid> except anyOf doesn't let you put back
02:29:22 <shachaf> Hmm, async already has an equivalent of parMapIO
02:29:27 <hkBst> what does this mean: Illegal datatype context (use -XDatatypeContexts): Real real_type =>
02:29:32 <shachaf> Nereid: Sure, it's only used for getting.
02:29:40 <shachaf> hkBst: It means never write "data Context blah => ... = ..."
02:29:48 <JaffaCake> shachaf: spawn seems a bit small to add, I'm not sure
02:29:58 <merijn> hkBst: That code most likely won't do what you want
02:30:14 <merijn> hkBst: What are you trying to do?
02:30:17 <hkBst> shachaf: but http://www.haskell.org/onlinereport/decls.html#datatype-decls contains example       data Eq a => Set a = NilSet | ConsSet a (Set a)
02:30:26 <Nereid> hkBst: yes, it's a bad example
02:30:32 <Nereid> don't do it
02:30:39 <shachaf> hkBst: Yes, but it's deprecated and I think not in Haskell 2010.
02:30:55 <shachaf> JaffaCake: It's such a nice helper function, though. :-)
02:30:58 <shachaf> Maybe it's not worth it.
02:31:23 <hkBst> hmm, is Haskell 2010 a real report? If so, why isn't _that_ on that website?
02:31:33 <shachaf> hkBst: It's on
02:31:35 <shachaf> @google haskell 2010
02:31:37 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/
02:31:40 <JaffaCake> shachaf: do you have an example where it helps?
02:31:52 <Nereid> it's in 2010
02:32:02 <hkBst> merijn: I'm trying to define a datatype with multiple representations
02:32:21 <Nereid> hkBst: putting a constraint in the data declaration gains you nothing
02:32:24 <Nereid> except pain
02:32:52 <Nereid> because you're going to have to put it wherever you use it anyway
02:32:52 <shachaf> JaffaCake: I assume that in any context where spawn is useful, you can inline the definition of spawn directly into the code.
02:33:09 <shachaf> Since it's just one more function. So maybe there's no point.
02:33:27 <JaffaCake> yes, that's what I'm thinking
02:33:45 <JaffaCake> but if there's an example that gets significantly clearer with spawn, I'd be interested
02:34:19 <hpaste> hkBst pasted “Complex with Representations” at http://hpaste.org/77779
02:35:15 <shachaf> It seems like a more elegant API since you don't have to think about irrelevant types, just IO actions. But I guess in practice it comes down to one more token anyway.
02:36:20 <Nereid> hkBst: yes, you need to put a constraint on the real_type on your type signatures for polar and cartesian
02:36:31 <tomboy64> what's the advantage of Control.Monad's when over a simple "if ... then ... else"?
02:36:35 <Nereid> polar :: Num real_type => ..
02:36:36 <hkBst> Nereid: aha :)
02:36:41 <Nereid> because
02:36:43 <shachaf> JaffaCake: What about mapConcurrently_?
02:36:47 <Nereid> look at the types of modu and friends
02:36:59 <shachaf> (Which I guess would use Foldable rather than Traversable.)
02:38:38 <merijn> tomboy64: when is a function, so you can use it pointfree
02:39:00 <hkBst> is Fractional the new Real?
02:39:07 <tomboy64> merijn: pointfree meaning?
02:39:10 <merijn> tomboy64: So "bar = when . foo" for example
02:39:11 <shachaf> The other useful thing it provides is pool :: Int -> IO (IO a -> IO a), but that doesn't quite have to do with spawning threads at all.
02:39:21 <donri> is DatatypeContexts different from gadts with contexts?
02:39:34 <merijn> tomboy64: pointfree expressions are expressions without names
02:39:37 <shachaf> donri: Yes.
02:39:41 <mapf> donri: yes
02:39:56 <donri> how?
02:40:30 <tomboy64> merijn: so i couldn't use if in a do-block?
02:40:34 <shachaf> donri: One of them does something useful.
02:40:41 <donri> ^_^
02:41:29 <mapf> with gadt you can have different types for different constructors. with DataTypeContext you are not, and this is deprecated
02:41:48 <shachaf> Even if you only have a single constructor it's different.
02:41:54 <SaaMmY-laptop> good morning
02:41:59 <shachaf> The dictionary will be stored as part of the value.
02:42:06 <shachaf> When you match on it you gain the extra context.
02:42:09 <mapf> and gadt give you ExistensialQuantification, DataTypeContexts are not
02:42:20 <neutrino> tomboy64: you can use if's in do blocks. do { let x = 2; let y = if x > 2 then 3 else 4; return y }
02:42:33 <merijn> tomboy64: You can, but if is not a function, so you can't use function composition to change things about it's behaviour
02:42:37 <SaaMmY-laptop> I wish to get the same link I was using yesterday for tutorial a sort of www.haskell.org/starting out/
02:42:50 <shachaf> donri: I think you're asking about the difference between "data Show a => Foo a = Foo a" and "data Foo a = Show a => Foo a"
02:42:51 <merijn> tomboy64: Since when is just a function you can use it as any other function
02:43:03 <neutrino> SaaMmY-laptop: have you checked the logs?
02:43:06 <merijn> :t map when [True,False]
02:43:08 <lambdabot> Monad m => [m () -> m ()]
02:43:15 <SaaMmY-laptop> oh found it
02:43:18 <tomboy64> ok. reading up about pointfree now. thanks.
02:43:25 <neutrino> SaaMmY-laptop: look in the topic for a link to logs of the channel
02:43:36 <donri> shachaf: maybe
02:43:38 <SaaMmY-laptop> no thnks I don'tneed
02:43:43 <neutrino> ok :)
02:43:54 <SaaMmY-laptop> second chapter now I save the link
02:53:58 <Eduard_Munteanu> @where lyah
02:53:58 <lambdabot> http://www.learnyouahaskell.com/
02:54:03 <Eduard_Munteanu> SaaMmY-laptop: that one? ^
03:03:22 <SaaMmY-laptop> yes
03:06:53 <smartviking> Is there a function that'll convert a floating-ish type value into a string in human readable form? No numbers like this: 3.2547950174967403e-4
03:09:01 <Iceland_jack> Something like printf "%f"
03:09:15 <Iceland_jack> > printf "%f" 3.2547950174967403e-4
03:09:16 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:09:17 <lambdabot>    (GHC.Show.Show a0)
03:09:17 <lambdabot>     ...
03:09:21 <Iceland_jack> hm
03:09:29 <Nereid> > show 3.2547950174967403e-4
03:09:31 <lambdabot>   "3.2547950174967403e-4"
03:09:47 <Iceland_jack> Prelude Text.Printf> printf "%f\n" 3.2547950174967403e-4
03:09:47 <Iceland_jack> 0.00032547950174967403
03:10:03 <Nereid> thanks to ghci defaulting
03:10:34 <Nereid> > printf "%0.5f" (3.2547950174967403e-4 :: Double)
03:10:36 <lambdabot>   Ambiguous type variable `a0' in the constraints:
03:10:37 <lambdabot>    (GHC.Show.Show a0)
03:10:37 <lambdabot>     ...
03:10:52 <Nereid> > printf "%0.5f" 3.2547950174967403e-4 :: String
03:10:54 <lambdabot>   "0.00033"
03:10:58 <smartviking> Thank you
03:12:37 <Nereid> > printf "%d %d" 3 :: String
03:12:39 <lambdabot>   "3 *Exception: Printf.printf: argument list ended prematurely
03:12:46 <Nereid> > printf "%d %d" 3 3 3 :: String
03:12:48 <lambdabot>   "3 3*Exception: Printf.printf: formatting string ended prematurely
03:18:50 * hackagebot arbtt 0.6.4.1 - Automatic Rule-Based Time Tracker  http://hackage.haskell.org/package/arbtt-0.6.4.1 (JoachimBreitner)
03:23:02 <mapf> why cabal build won't call postBuild user hook?
03:26:35 <Saizan> mapf: have you set build-type: Custom in your .cabal file?
03:28:44 <tdammers> airplanes are seriously limited
03:29:06 <typoclass> tdammers: a bold declaration! thanks for making that clear ;-)
03:29:17 <tdammers> if you have serious amounts of cargo, the capacity of even an international airport maxes out in no time
03:30:39 <tdammers> oh wait, wrong channel
03:30:48 <typoclass> ;-)
03:33:07 <alang> @src max
03:33:08 <lambdabot> max x y = if x <= y then y else x
03:39:03 <charliesome> is there any way to use exceptions without -XDeriveDataTypeable
03:40:33 <Jafet> Because you're a masochist and want to write the instance yourself
03:41:15 <charliesome> well i'd like to be able to compile some exception using code cleanly
03:41:19 <charliesome> without adding random flags to ghc
03:42:02 <Jafet> wat
03:42:25 <Jafet> Add it to the file, then
03:42:33 <Jafet> {-# LANGUAGE DeriveDataTypeable #-}
03:42:57 <charliesome> there's no better way?
03:43:28 <Jafet> What are you talking about
03:43:47 <Jafet> DeriveDataTypeable is used when the program derives Data or Typeable.
03:44:15 <charliesome> yeah but why does that need it's own language/compiler flag/whatevert
03:44:25 <typoclass> charliesome: it's very normal that haskell code starts with {-# LANGUAGE #-} and a bunch of extensions, then a bunch of imports. it's common practice, unless you have some particular reason why you want to support only haskell98, or some restriction like that
03:44:46 <charliesome> hmm ok
03:44:47 <Jafet> Because it isn't in standard haskell.
03:53:47 <mapf> Saizan: thanks
04:03:51 * hackagebot haskheap 0.1.0 - Haskell bindings to refheap.  http://hackage.haskell.org/package/haskheap-0.1.0 (AnthonyGrimes)
04:06:58 <hkBst> :t Fractional
04:07:00 <lambdabot> Not in scope: data constructor `Fractional'
04:07:22 <Elemir> :k Fractional
04:07:23 <lambdabot> * -> Constraint
04:08:04 <hkBst> :k Constraint
04:08:06 <lambdabot> BOX
04:08:16 <Elemir> Heh
04:08:31 <hkBst> :k BOX
04:08:32 <lambdabot> Not in scope: type constructor or class `BOX'
04:09:21 <hkBst> what is the definition of Fractional?
04:09:27 <mapf> :k Set
04:09:28 <lambdabot>     Not in scope: type constructor or class `Set'
04:09:29 <lambdabot>     Perhaps you meant one of these:
04:09:29 <lambdabot>       `S.Set' (imported from Data.Set),
04:09:38 <mapf> :k S.Set
04:09:40 <lambdabot> * -> *
04:10:30 <flux> 23
04:10:37 <flux> (oops, carry on)
04:10:48 <Jafet> 85
04:11:08 <flux> damnit, jafet won
04:12:11 <hkBst> is reading the Haskell report 2010 recommended or is it more a reference work?
04:12:28 <Jafet> @google haskell class fractional
04:12:30 <lambdabot> http://www.haskell.org/tutorial/numbers.html
04:12:30 <lambdabot> Title: A Gentle Introduction to Haskell: Numbers
04:12:58 <Box_> :k *
04:13:00 <lambdabot> parse error on input `*'
04:13:52 * hackagebot hspec 1.4.2 - Behavior-Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.2 (SimonHengel)
04:15:51 <djcoin> What is the syntax to add type annotation inline ? (and not in a previous line). I'm on the repl trying to do some "let addOne :: Int -> Int =  succ" but obviously it's not working
04:19:04 <sopvop> let addOne = succ :: Int -> Int
04:19:30 <flux> hmm, is that telling the addOne signature or telling the signature of succ?
04:19:59 <mapf> flux: neigher one
04:20:14 <typoclass> djcoin: iirc that kind of thing will indeed work if you turn on ScopedTypeVariables
04:20:40 <mapf> *neither
04:20:42 <typoclass> djcoin: i.e. {-# LANGUAGE ScopedTypeVariables #-} at the start of the file
04:20:59 <sopvop> It's a type of expression
04:21:31 <djcoin> All right, thanks :)
04:21:43 <typoclass> flux: it nails down the type of the expression "succ", but by inference that will also become the type of addOne
04:23:16 <mapf> cucumber-driven development
04:24:09 <djcoin> typoclass: ghci -XScopedTypeVariable works too (in fact, I just happen to follow the instruction ghci told me after having failed to parse the type signature)
04:24:15 <djcoin> Thanks !
04:25:40 <mapf> djcoin: you can also :set -XScopedTypeVariables
04:26:06 <djcoin> oh great
04:26:08 <djcoin> thanks
04:40:48 <startling> is there some way to tell cabal an executable is optional?
04:41:08 <donri> flags
04:41:09 <dcoutts> you can make it buildable conditional on a flag
04:41:22 <startling> ah
04:44:38 <nand`> hkBst: I've never read it in full; I usually just refer to it when I'm curious about some particular issue
04:45:24 <nand`> but I've certainly heard of people that picked up Haskell primarily from reading the report
04:46:11 <merijn> Learning haskell from the report sounds marginally more fun than learning C from the standard
04:46:23 <merijn> (That's not a positive thing :p)
04:47:01 <nand`> the report is fairly readable; though I'd imagine you'll have difficulties without prior exposure to pure functional or nonstrict languages
04:47:21 <merijn> nand`: Hence why I said marginally more fun than the C standard
04:47:56 <merijn> It's fairly readable, but doesn't really prioritise subjects in any nice way for learning
04:49:20 <startling> hmmm, how do I make an entire executable conditional with a flag? if I put if flag(myflag) on the top-level, I get "Construct not supported at this position: IfBlock 22"
04:50:01 <merijn> startling: There's a "buildable" option
04:50:12 <merijn> Toggle that based on the if statement inside the Executable block
04:50:23 <startling> ah
04:50:52 <merijn> I think the cabal manual has some examples of exactly this
04:51:18 <startling> All I see is toggling ghc options, but I'd love to be proven wrong.
04:51:46 <nand`> toggle -fno-code then :P
04:51:48 * nand` is joking
04:52:19 <hkBst> nand`: what if I already understand the non-strict part?
04:52:52 <startling> hkBst, all of it??
04:53:37 <Sonderblade> any way to write this predicate more nicely: where myPred (Dir ('.':_) _) = False ; myPred (File n _) = takeExtension n == ".hs" ; myPred _ = True ?
04:54:20 <startling> so how do I give the flag to `cabal build`?
04:55:00 <fmap> you give flags to cabal configure
04:55:07 <startling> oh, I see
04:55:40 <hkBst> startling: I seem to struggle mostly with Haskell syntax and other particulars. I am familiar with the semantics. At last as far as discussed in guides for beginners.
04:56:15 <latermuse> hkBst: the syntax takes a while to get used to
04:57:13 <merijn> hkBst: Have you tried going over the first couple chapters of Real World Haskell?
04:57:24 <hkBst> I guess I'll just start reading the report and see if that suits my needs.
04:57:58 <hkBst> merijn: no I haven't yet tried that, but that also sounds like a very good suggestion
04:58:46 * nand` had no problems adjusting to the syntax; coming from the horrible C style
04:59:11 <merijn> hkBst: There's also LYAH, but that starts of a bit slow and easy. If you've been reading and understanding the report then RWH's first chapters might be better. They provide sort of a quickstart haskell syntax tutorial
04:59:27 <latermuse> i personally read everything i could about haskell for about a month before i could begin to understand how to put things together and get actual work done in haskell
04:59:57 <latermuse> and i was reading research papers, and high-level math theory along with the beginner syntax stuff and the learn haskell books
05:00:39 <Iceland_jack> Never heard of high-level math theory before :)
05:00:57 * nand` 's math theory is at level 34
05:00:57 <latermuse> category theory mostly
05:01:09 <startling> Iceland_jack, it's got garbage collection
05:01:26 <Iceland_jack> heh
05:01:32 <nand`> startling: surely that's a NOOP ;)
05:01:53 <jesyspa> hkBst: I found wrapping all operators and function applications in () made it look enough like Lisp to keep me happy until I got used to it.
05:02:21 * jesyspa isn't sure anyone else becomes happy from Lisp syntax.
05:02:51 <merijn> jesyspa: heh, never considered that, but that should work just fine, yeah :D
05:03:06 * nand` is allergic to parentheses
05:03:27 <Iceland_jack> I prefer Lisp syntax to the Haskell one
05:07:55 <hkBst> jesyspa: it's mostly the non-expression code that does it :)
05:08:20 <jesyspa> hkBst: Hm, I don't have much of that.  Could you give an example?
05:08:43 <hkBst> jesyspa: for example, how to write an Instance declaration of Fractional
05:08:52 <merijn> jesyspa: I guess he means data, class and instance declarations
05:09:21 <jesyspa> Ah, okay, yeah.
05:09:24 <jesyspa> They're rather strange.
05:09:26 <merijn> hkBst: Not that hard, though :) "instance Fractional YourType where {- function definitions here -}"
05:09:44 <jesyspa> s/strange/unlike anything I've seen in any other language/
05:11:16 <hkBst> merijn: and how about when YourType depends on a type parameter?
05:11:51 <merijn> hkBst: Is the type parameter fixed? Or is it a type variable?
05:12:04 <jesyspa> Then YourType is actually some T a, so you write T a.
05:12:06 <jesyspa> (I think...)
05:12:08 <hkBst> merijn: variable
05:12:25 <merijn> "instance Fractional (YourType a) where" :)
05:12:46 <hkBst> ah, no forAll ?
05:13:00 <merijn> If you want to define the instance *only* if a is fractional too, then "instance Fractional a => Fractional (YourType a) where"
05:13:10 <merijn> hkBst: No, the forall is implied
05:13:46 <merijn> (The last one I wrote basically says "YourType a" is fractional *only* if a is fractional)
05:13:49 <hkBst> do people usually code in a module and indent everything or use some syntax to not have to indent?
05:14:23 <merijn> hkBst: You don't have to indent in a module
05:14:49 <hkBst> merijn: ah, it is module per file rule?
05:14:57 <merijn> hkBst: Yes
05:20:31 <nand`> Can I use ‘hiding’ in module export lists? Say I define 20 values in a module, and I want to export all but one of them; can I just write module ... hiding (foo) where ... ?
05:21:58 <startling> nand`: nope
05:22:20 <dmwit> You can do something funny, I think.
05:22:27 <dmwit> You can import ThisModule hiding (foo)
05:22:31 <dmwit> and export module ThisModule
05:22:37 <dmwit> Let's test that...
05:24:20 <dmwit> Hm, seems to require an hs-boot file, which will nullify the win.
05:25:48 <hpc> if you have less than 62 functions in the file, you can do (f, g, h, ...) = (foo, bar, baz, ...) where hidingThisFunction = ...
05:25:55 <hpc> ;)
05:26:19 <nand`> that's just as much typing redundancy; and why 62?
05:26:37 <nand`> either way, I think that would be a straightforward and useful addition to Haskell
05:26:47 <hpc> nand`: that's the limit on tuple size
05:26:48 <hpc> ;)
05:26:52 <nand`> hpc: in Haskell?
05:26:55 <hpc> ghc
05:27:03 <nand`> who cares about GHC? ;)
05:27:05 <hpc> i was not even remotely serious with that suggestion btw
05:27:43 <dmwit> In fact, I can't even find a way to have a module import itself at all, even with hs-boot files.
05:28:45 <dmwit> Oh, it does work!
05:28:53 <dmwit> nand`: Okay, here's how you do it.
05:28:58 <dmwit> ...uh
05:29:13 <dmwit> Well, importing yourself works, but hiding didn't work. So never mind after all. =P
05:31:47 <donri> dmwit: module export with hiding should work without boot file?
05:32:05 <donri> if it's a separate module anyway
05:32:14 <dmwit> It isn't.
05:33:21 <dmwit> Of course, that's one way to do it, I guess: make two modules, one called .Internal that isn't exposed by your package and one without the .Internal that does nothing but import hiding (whatever) and export the .Internal module.
05:38:50 <ski> nand`,hpc : SML's `local <decls> in <decls> end' would be handy for that ..
05:39:17 <nand`> yeah; or something like a declaration-level ‘let..in’
05:39:24 <ski> yes, that's what it is
05:41:01 <tomeo_> Hi
05:41:33 <ski> hello
05:42:58 <ski> jesyspa : sexps have a certain attraction :)
05:43:29 <jesyspa> Definitely. :D
05:44:15 <tomeo_> I'm trying to get rid of the if/else in this expression. [if x == s then subst else [s] | s <- str]. I was thinking of using predicates, but realized that I can't get the same behavior that way. Could someone please give me a clue?
05:46:05 <Raynes> What does one use to programmatically determine which operating system one is currently operating in?
05:46:29 <nand`> that's a can of worms
05:46:56 <Saizan> determining which OS you were compiled for can be done with System.Info
05:48:54 <Raynes> Saizan: Thanks!
05:49:41 <Digihash> Hello
05:49:56 <Digihash> I'm new to Haskell and hope to learn it well
05:50:52 <Sonderblade> you can only learn haskell by graduating from the SCHOOL OF HARDKNOCKS
05:51:17 <typoclass> Digihash: hello, welcome. lyah is a good textbook available free of charge
05:51:19 <typoclass> @where lyah
05:51:19 <lambdabot> http://www.learnyouahaskell.com/
05:51:41 <tomeo_> That book is very good
05:52:00 <Digihash> Yes, I found your channel through this book. I think I'll buy it.
05:52:21 <tomeo_> Did someone here write it btw?
05:52:50 <typoclass> tomeo_: he uses the nickname 'bonus', but i haven't seen him on irc in a while
05:53:44 <Saizan> BONUS, but he hasn't been here in a while
05:54:19 <tomeo_> oh okay
05:54:33 <tomeo_> I enjoy the illustrations :D
05:54:50 <tomeo_> Gordon Freeman for Lambdas and whatnot
05:57:34 <ski> tomeo_ : perhaps something like `blah .. = ..[t s | s <- str].. where t s | x == s    = [s]   | otherwise = subst'
05:58:05 <tomeo_> thanks ski
05:58:42 <tomeo_> ski, would that be considered a pretty way of doing it?
05:59:11 <ski> not sure
05:59:55 <ski> i would probably go for the `if'-`then'-`else' solution -- unless your context (which i don't know) would allow some other rephrasing
06:00:18 <ski> (i suspect you have a `concat' somewhere in there, no ?)
06:02:18 <ski> > do c <- "a b"; case c of 'a' -> "b a b"; 'b' -> "a b a"; ' ' -> "  "; c -> [c]
06:02:19 <lambdabot>   "b a b  a b a"
06:03:15 <tomeo_> ski, yes Im using concat
06:03:32 * delamonpansie wrote his first haskell program
06:03:59 * Clint developed a passionate hatred for system-filepath
06:06:16 <ski> tomeo_ : then instead of `concat [..s.. | s <- ...]' you can say `[x | s <- ...; x <- ..s..]' .. or `do s <- ...; ..s..'
06:06:37 <ski> (or you can say `concatMap (\s -> ..s..) (...)')
06:06:54 <Raynes> How does one send EOF to a process created with createProcess?
06:07:10 <ski> delamonpansie : nice :)
06:07:30 <Botje> Raynes: have you tried closing the handle connected to its input handle?
06:07:44 <Raynes> I did not, but that sounds reasonable. I'll give it a shot. :>
06:17:42 <hpaste> hkBst pasted “no show?” at http://hpaste.org/77781
06:18:28 <Botje> hkBst: stick a 'deriving Show' after your data declarations
06:23:35 <ski> hkBst : .. perhaps you meant to have explicit `Show' instances for `RealsXReals real_type' and `RealsXSphere1 real_type' as well
06:24:00 <hpaste> hkBst annotated “no show?” with “no show? (again)” at http://hpaste.org/77781#a77782
06:24:17 <hkBst> ski: indeed
06:24:24 <ski> hkBst : .. or maybe you meant for `polar' and `cartesian' to give result in `Complex real_type'
06:24:35 <hkBst> ski: Nooooooooooooooooooooooooooo
06:24:46 * ski grins
06:24:49 <hkBst> ski: that's the whole purpose of the exercise :)
06:25:18 <ski> anyway, you should not have *both* a `deriving Show' *and* an `instance ... => Show (...)' for a data type
06:25:42 <ski> if you want to keep the three explicit instances, then remove the `deriving' clauses
06:26:19 <hkBst> ski: thanks
06:26:33 <hkBst> and it finally works ;D
06:27:46 * hkBst is glad to not be irc-shy
06:28:23 <hkBst> in other words, #gentoo-haskell thanks a lot already
06:28:54 * hackagebot MissingM 0.0.4 - findM and other missing 'M's  http://hackage.haskell.org/package/MissingM-0.0.4 (DylanJust)
06:29:59 <hkBst> ski: is there any way to avoid the ``double packaging''?
06:37:37 <hkBst> ski: your silence speaks volumes ;P (Sorry to have directed that question so directly btw, I'll try not to do it too often)
06:40:01 <hkBst> can anyone comment on the necessity of the ``double packaging'' in “no show? (again)” at http://hpaste.org/77781#a77782 modulo type errors?
06:42:47 <mSSM> I am trying to use the mwc-random package, and I am confused about how to create a (uniform) value: v <- uniform gen   doesn't work and I am not sure about how to add the type signature here
06:47:01 <b__> other than the SPJ paper on Contracts, does anyone know of other papers on Haskell and quantitive finance?
06:48:43 <tomeo_> How would I randomize a RealFrac? I can't even get ghci to accept the existence of RealFrac yet I thought it was part of Prelude
06:49:02 <byorgey> tomeo_: first of all, RealFrac is not a type
06:49:06 <byorgey> it is a type class
06:49:12 <byorgey> so what type do you actually want?
06:49:30 <byorgey> Double?
06:49:37 <tomeo_> bylzz, Float
06:50:09 <tomeo_> Really just looking for a random number 0-1
06:50:31 <tomeo_> byorgey,
06:51:10 <byorgey> tomeo_: randomRIO (0,1)
06:51:35 <tomeo_> byorgey, yes I did that but I want to use RandomIO
06:52:33 <byorgey> what's RandomIO ?
06:53:10 <tomeo_> byorgey, sorry, randomIO
06:53:51 <Rogach> Hello!
06:54:16 <byorgey> tomeo_: ok, randomIO should work fine.  so what's the problem?
06:54:19 <byorgey> hi Rogach!
06:54:20 <hpaste> Rogach pasted “Simple X11 window” at http://hpaste.org/77783
06:54:31 * startling .oO( does randomIO execute a random IO action? )
06:54:48 <byorgey> @type randomIO
06:54:49 <lambdabot> Random a => IO a
06:54:58 <cornihilio> does anyone know how I might fix this issue? https://gist.github.com/4079011 I'm getting this https://admin.fedoraproject.org/pkgdb/apps/search/zlib?_csrf_token=6dd3ea096bef8a97f90e09b8582774ed0104e9e2 and the haskell-cafe answer I found didn't seem to help
06:55:13 <Rogach> Can somebody help me with my X11 code? For some reason, the created window is not positioned properly, and the drawing doesn't happen.
06:55:20 <Rogach> http://hpaste.org/77783
06:55:25 <mSSM> I rephrase my question: how do I generate a random float in (0,1] using the uniform function from mwc-random?
06:57:34 <tomeo_> byorgey, think I solved it. thanks anyway
07:00:40 <ski> hkBst : sorry, didn't notice you said something
07:01:01 <ski> hkBst : i would probably change your two first `Show' instances to instead define
07:01:49 <ski>   showsPrec p (RxR real imag) = showParen (p > 6) $ showsPrec 6 real . showString " + " . showsPrec 7 imag . showString " * i"
07:01:53 <ski> resp.
07:01:55 <ski>   showsPrec p (RxS1 mod arg) = showParen (p > 7) $ showsPrec 7 mod . showString " * exp (" . showsPrec 7 arg . showString " * i)"
07:02:30 <ski> hkBst : what do you mean by "double packaging" `
07:02:40 <ski> s/`/?/
07:03:01 <hkBst> ski: I mean having to type (RepRxR (RxR 1 2)) for 1+2i
07:03:50 <saml> is sudo fixed point?
07:03:55 <saml> sudo sudo sudo sudo sudo echo
07:04:14 <saml> sudo sudo echo = sudo echo = echo
07:04:30 * ski wonders whether saml meant "is `sudo' idempotent ?"
07:04:31 <Cale> sudo p is not equivalent to p though
07:04:44 <Cale> and yeah, the word you're looking for is idempotent
07:04:53 <saml> ah thanks
07:05:05 <osfameron> does sudo "lift" the command to a root context?
07:05:12 <ski> saml : that `f' is idempotent means that for every `x' `f (f x)' is equal to `f x'
07:05:23 <FireFly> Is sudo broken? "fix sudo"
07:06:43 <ski> hkBst : do you intend to use `RealsXReals' and `RealsXSphere1' much (apart from inside `Complex') ?
07:06:46 <hkBst> ski: thanks, I'll keep those for later consideration.
07:07:06 <hkBst> ski: not really, it is entirely theoretical at this point and likely to remain so :)
07:07:43 <ski> hkBst : `showParen' will automatically add wrapping brackets in case the context precedent (`p') is larger than the precedence of `+'/`*' (which is `6'/`7' above)
07:08:39 <ski> if i want to print `e0 + e1', i pass `6' to the `showPrec' for `e0' and `7' for `e1', because `+' is `infixl 6'
07:09:08 <ski> for `e0 ^ e1', it would be `9' for `e0' and `8' for `e1', because `+' is `infixr 8'
07:09:42 <ski> er, because `^' is `infixr 8'
07:09:56 <ski> and for `e0 == e1', it would be `5' for `e0' and `5' for `e1', because `==' is `infix 4'
07:10:04 <hkBst> ski: hah, sophistication unsought for, but much appreciated
07:10:48 <Marenz> What does this mean?  rejecting: blaze-html-0.5.1.0/installed-ef1..., 0.5.1.0, 0.5.0.0 (conflict: pandoc-1.9.4.5:blaze_html_0_5 => blaze-html>=0.4.3.0 && <0.5)
07:11:03 <Marenz> especially the notation "pandoc-1.9.4.5:blaze_html_0_5"
07:11:05 <ski> hkBst : you could define `realsXReals real imag = RealsXReals (RxR real imag)' as shortcut ..
07:14:08 <Marenz> I mean, I would think htat the notation above would bean pandoc-1.9.4.5 with flag blaze_html_0_5
07:14:18 <Marenz> but pandoc with that flag does have different dependencies
07:14:20 <Marenz> so I am confused
07:14:32 <hkBst> ski: ah of course. That may just take the tedium out of it too.
07:20:27 <nand`> mm_freak: how straightforward would it be to use netwire to provide a higher level binding for some C library? The API I'm exposed to is basically something like update (&foo) and then values are fields of foo; the idea here would be to have each individual field of ‘foo’ as a wire - with ‘update’ running once per instant
07:20:37 <mSSM> If a function has the type signature uniform :: PrimMonad m => Gen (PrimState m) -> m a , how do I tell it that a is supposed to be a float?
07:20:40 <nand`> I have zero clue how I would get that into netwire
07:21:32 <startling> mSSM: you don't have to, just give it a float
07:21:38 <Cale> mSSM: by using the result at a floating point type
07:21:51 <Cale> (it doesn't take a parameter of type a)
07:21:53 <ski> mSSM : is this a method of a type class ?
07:22:03 <mSSM> ski: I think so
07:22:15 <mSSM> ski: from here http://hackage.haskell.org/packages/archive/mersenne-random/1.0.0.1/doc/html/System-Random-Mersenne.html
07:22:17 <mSSM> oh
07:22:19 <mSSM> no
07:22:21 <mSSM> wrong linke
07:22:36 <mSSM> ski: this one: http://hackage.haskell.org/packages/archive/mwc-random/0.12.0.1/doc/html/System-Random-MWC.html#v:uniform
07:23:01 <mSSM> Cale: I am just playing around with it in ghci
07:23:10 <Cale> So the full type is  uniform :: (Variate a, PrimMonad m) => Gen (PrimState m) -> m a
07:23:17 <ski> ok, so it's really `uniform :: (Variate a,PrimMonad m) => Gen (PrimState m) -> m a', then
07:23:55 <ski> .. and i see there's an instance for `Variate Float'
07:24:04 <mSSM> There is
07:24:16 <mSSM> I saw all that... I guess I am not sure how to apply this
07:24:35 <Cale> mSSM: Right, ordinarily you should just be able to use the result as a Float to tell it which generator to use.
07:24:43 <Cale> But also you could give an explicit type signature
07:24:49 <mSSM> Cale: That's what I want!
07:24:52 <mSSM> D:
07:24:53 <Cale> uniform g :: IO Double
07:25:54 <mSSM> Cale: how could I have told that IO is the right type here?
07:26:25 <Cale> mSSM: Well, the only instances of PrimMonad are IO and ST s
07:26:50 <Cale> and I figure if you wanted to use ST, you'd have said something about it
07:27:19 <startling> haha
07:27:23 <mSSM> Cale: alright; I guess I will need to read up on PrimMonad (and ST)
07:28:03 <mSSM> Cale: btw, this goes back to yesterday where I asked about Primstate and RealWorld; I don't understand those things :(
07:28:07 <Cale> mSSM: It's a low-level detail which is just used to abstract over IO and ST in a few cases
07:28:13 <rwbarton> @type at
07:28:15 <lambdabot> (Functor f, At k m, Indexed k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))
07:29:12 <Cale> Basically the only thing you need to know here is that IO and ST are both instances of that class, you're not likely to want to use the operations ('primitive' and 'internal') that it provides.
07:29:29 <rwbarton> > let f = (\x -> Just (x+1)) % at 3 .~ Just 8 in (f 2, f 3)
07:29:31 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe a0),
07:29:31 <lambdabot>                    GHC...
07:29:40 <mSSM> Cale: alright, thank you; that works for me for now
07:29:56 <rwbarton> > let f = (\x -> Just (x+1)) % at 3 .~ 8 in (f 2, f 3)
07:29:58 <lambdabot>   No instances for (GHC.Num.Num
07:29:59 <lambdabot>                      (Data.Maybe.Maybe (Data....
07:31:17 <rwbarton> > let f = (\x -> Just (x+1)) % at 3 ?~ Just 8 in (f 2, f 3)
07:31:20 <lambdabot>   No instances for (Control.Lens.IndexedLens.At k0 ((->) a0),
07:31:22 <lambdabot>                ...
07:31:31 <nand`> :t (?~)
07:31:33 <lambdabot> Setting s t a (Maybe b) -> b -> s -> t
07:31:40 <rwbarton> what if I want to update my functions!
07:33:36 <nand`> I'm not sure how functions would fit into At; either you'd have to provide a newtype for the Maybe thing, or you'd have to figure out some way of handling Nothing
07:34:30 <rwbarton> for functions I would rather have a version without the Maybe anyways
07:36:40 <rwbarton> @let fat x = lens (\f -> f x) (\f y' -> \x1 -> if x1 == x then y' else f x1)
07:36:43 <lambdabot>  Defined.
07:37:04 <edwardk> :t fat
07:37:06 <lambdabot> (Eq a, Functor f) => a -> (b -> f b) -> (a -> b) -> f (a -> b)
07:37:07 <rwbarton> > let f = (\x -> Just (x+1)) % fat 3 .~ 8 in (f 2, f 3)
07:37:09 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe a0),
07:37:10 <rwbarton> oops
07:37:10 <lambdabot>                    GHC...
07:37:14 <rwbarton> > let f = (\x -> x+1) % fat 3 .~ 8 in (f 2, f 3)
07:37:17 <lambdabot>   (3,8)
07:37:21 <edwardk> :t resultAt
07:37:23 <lambdabot> (Eq e, Functor f) => e -> (a -> f a) -> (e -> a) -> f (e -> a)
07:37:27 <rwbarton> oh
07:37:39 <rwbarton> > let f = (\x -> x+1) % resultAt 3 .~ 8 in (f 2, f 3)
07:37:42 <lambdabot>   (4,8)
07:37:54 <rwbarton> > let f = (\x -> x+1) % inputAt 3 .~ 8 in (f 2, f 3)
07:37:56 <lambdabot>   Not in scope: `inputAt'
07:38:05 <rwbarton> what did resultAt do?
07:38:27 <edwardk> made a new function that compared the input to the requested one, and then changed the answer accordingly
07:38:42 <rwbarton> then where did the 4 come from?
07:38:58 <edwardk> not sure =)
07:39:23 <rwbarton> heh :)
07:39:52 <rwbarton> > let f = (\x -> x*10) % inputAt 3 .~ 8 in (f 2, f 3)
07:39:54 <lambdabot>   Not in scope: `inputAt'
07:39:58 <rwbarton> > let f = (\x -> x*10) % resultAt 3 .~ 8 in (f 2, f 3)
07:40:00 <lambdabot>   (30,8)
07:40:17 <rwbarton> > let f = (\x -> x*10) % resultAt 3 .~ 8 in (f 1, f 3)
07:40:19 <lambdabot>   (30,8)
07:40:29 <rwbarton> looks like you must call f on the wrong thing
07:40:36 <edwardk> probably
07:40:45 <nand`> lens is getting quite fat
07:41:41 <startling> nand`, I've been doing my part to trim it down
07:42:27 <edwardk> https://github.com/ekmett/lens/issues/92
07:42:32 <edwardk> i'll fix it at the office
07:42:55 <tomeo_> Is there a function in prelude that will take a list of tuples and return snd on a tuple if fst matches some kind of filter?
07:43:18 <startling> tomeo_: `lookup` is a specific case of that
07:43:26 <hiptobecubic> github needs to work on their time resolution, "ekmett opened this issue in a few seconds"
07:43:32 <hiptobecubic> unless they just mean you did it really quickly :)
07:43:51 <startling> hiptobecubic, you haven't learned lens yet?
07:43:59 <edwardk> i should also probably make it an indexed lens
07:44:38 <hiptobecubic> startling, i've "learned" it in the same way someone "learns" c++
07:45:00 <startling> :t \fn -> foldr (\a b -> if fn a then Just a else b) Nothing
07:45:02 <lambdabot> (a -> Bool) -> [a] -> Maybe a
07:45:27 <startling> :t \fn -> foldr (\(a, b) c -> if fn a then Just b else c) Nothing
07:45:28 <lambdabot> (t -> Bool) -> [(t, a)] -> Maybe a
07:45:41 <rwbarton> tomeo_, you can also just build it out of filter and map
07:45:45 <startling> tomeo_: ^^
07:45:56 <rwbarton> @type lookup
07:45:58 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
07:46:03 <rwbarton> @type lookupBy
07:46:05 <lambdabot>     Not in scope: `lookupBy'
07:46:05 <lambdabot>     Perhaps you meant one of these:
07:46:05 <lambdabot>       `lookup' (imported from Data.List),
07:46:30 <startling> :t Data.List.lookupBy
07:46:32 <lambdabot>     Not in scope: `Data.List.lookupBy'
07:46:32 <lambdabot>     Perhaps you meant one of these:
07:46:32 <lambdabot>       `Data.List.lookup' (imported from Data.List),
07:47:44 <tomeo_> thanks startling
07:50:40 <startling> @pl \(a, b) c -> if fn a then Just b else c
07:50:40 <lambdabot> uncurry ((. Just) . if' . fn)
07:59:02 <sw17ch> Any one able to point me at Agda resources? Preferably a tutorial targeted at people who know Haskell already.
07:59:06 <nand`> anybody feel like writing FFI bindings for libxwiimote?
08:00:27 <startling> nand`: heh, what are you doing?
08:01:13 <sw17ch> nand`: looks like a pretty simple interface to write one for
08:01:23 <nand`> startling: nothing in particular; just trying to interface with the wiimote from Haskell
08:01:36 <sw17ch> nand`: or are you referring to something other than this: https://github.com/dvdhrm/xwiimote/blob/master/lib/xwiimote.h
08:02:39 <startling> nand`: I would totally do this if I knew where my wiimote was. :/
08:02:53 <startling> but yeah, it looks exceedingly simple
08:03:11 <nand`> sw17ch: that looks like it could be it
08:03:27 <sw17ch> nand`: have you written FFI bindings before? this looks trivial to implement.
08:03:33 <nand`> well, if somebody wants to write FFI bindings for that and upload it somewhere I'd be grateful; and do my best to provide a higher level abstraction on top of it
08:03:44 <nand`> my ulterior goal is to get something like an orientation :: IO (Vector R3)
08:04:12 <nand`> sw17ch: no, I've never written FFI bindings before; I don't plan on doing so either
08:04:21 <sw17ch> why not? :)
08:05:37 <startling> nand`: it's a lot easier than FFI in any other language I know, fwiw
08:06:57 <sw17ch> if you don't, i might do this. i've not FFI'd in a while. it's fun.
08:07:01 <nand`> sw17ch: it's a can of worms I can live without opening. I browsed through the documentation and examples on the haskell wiki and all of it looks like such a major clusterfuck that I'd probably get a headache just thinking about it
08:07:09 <Raynes> How can I make a piece of code only run if on Windows? I see some libraries doing stuff with #if. Where is that documented?
08:07:14 <sw17ch> nah, it's really simple nand`
08:07:33 <sw17ch> well, it's simple if you have a reasonably strong understanding of Haskell
08:07:35 <sw17ch> and C
08:07:41 <startling> Raynes, it's the c preprocessor.
08:07:43 <luite> Raynes: you have have a CPP define only for windows
08:07:47 <luite> with the cabal file
08:07:53 <startling> Raynes: you can do {-# Language CPP #-}
08:07:54 <nand`> I have a reasonable understanding of Haskell, but I don't know a word of C
08:08:19 <startling> Raynes, it might be better to do it with conditionals in your cabal file, though
08:08:49 <sw17ch> nand`: ah, okay then. that does make it more difficult.
08:08:59 <startling> nand`: looks like this thing might be linux-only, so that counts me out. :/
08:09:05 <Raynes> startling: Well, the code is mixed with other code.
08:09:18 <sw17ch> I don't have a Wii, but perhaps this would be an excuse :P
08:09:51 <Jeanne-Kamikaze> Raynes, in hsc you can do #ifdef and shit
08:10:03 <nand`> (you don't need a wii for libxwiimote; just a .. wiimote)
08:10:56 <Jeanne-Kamikaze> with {-# LANGUAGE CPP #-} as has already been suggested
08:11:24 <startling> you don't need to do it in hsc
08:11:53 <Jeanne-Kamikaze> ah, good to know
08:13:04 <jmcarthur> for those who know C, the haskell FFI is amazing
08:13:24 <rwbarton> nand`: when you learn C, watch out for the keyword "return", it doesn't do what you'd expect
08:13:36 <S11001001> rwbarton: :]
08:13:56 <nand`> rwbarton: ah; is it like the ‘return’ in the inexplicably popular language C#?
08:14:42 <leimy> gosub
08:16:15 <bartavelle> rwbarton :)))
08:17:45 <startling> rwbarton: heh
08:18:16 <startling> nand`, I can give you the five-minute version if you like. you don't need to read C, just those function signatures
08:18:46 <nand`> startling: maybe some other time
08:18:51 <startling> alright
08:20:00 <Eduard_Munteanu> Yeah, shame on C's creators for picking such a random name out of context and using it as a keyword. Heresy, to subvert the unit of a monad like that...
08:21:25 <cornihilio> does anyone know how I might fix this issue? https://gist.github.com/4079011 I'm getting this https://admin.fedoraproject.org/pkgdb/apps/search/zlib?_csrf_token=6dd3ea096bef8a97f90e09b8582774ed0104e9e2 and the haskell-cafe answer I found didn't seem to help
08:21:45 <atriq> Doesn't C's return have something to do with callCC? I'm sure I read that once...
08:21:45 <lambdabot> atriq: You have 1 new message. '/msg lambdabot @messages' to read it.
08:22:41 <startling> @remember rwbarton when you learn C, watch out for the keyword "return", it doesn't do what you'd expect
08:22:42 <lambdabot> Done.
08:23:01 <nand`> Eduard_Munteanu: main() { print ("foo"); eta 0; }
08:23:23 <rwbarton> cornihilio: it means you need to install your distro zlib development package. i take it you are using fedora but on debian/ubuntu you would do "sudo apt-get install zlib1g-dev"
08:24:58 <Eduard_Munteanu> @undo do { print ("foo"); eta 0; }
08:24:59 <lambdabot> print ("foo") >> eta 0
08:27:47 <Philonous> atriq:  C's return is \x -> shift (\_ -> return x)  with a reset around the function body
08:28:19 <bartavelle> is lambdabot something that would be a nice building block for a general purpose xmpp bot, or is it too specialized ?
08:28:58 <nand`> I know it comes in multiple backends; one of them being a console
08:29:19 <nand`> so, failing all else, it should be rather trivial to just wrap the console commands/output into XMPP - I'm sure you can improve on that though
08:30:27 <bartavelle> what about the plugin system ? Can I for example forkIO some persistant thing that talks, for example, through Channel, and access this from  the plugins ?
08:31:39 <nand`> no idea
08:32:15 <Cale> lambdabot's plugin system is somewhat broken -- they're all just statically compiled in atm
08:32:39 <Cale> If you wanted to fix it today, you'd want to use something like hint rather than the plugins package that it used before.
08:32:57 <bartavelle> it's ok that they are statically linked
08:33:08 <bartavelle> and I couldn't use Hint to do what I wanted
08:33:09 <aristid> Cale: does lambdabot really need dynamic plugins for the purposes of #haskell? i would think the list of plugins is fairly static these days
08:33:33 <Cale> aristid: Right, it is
08:33:55 <Cale> aristid: Which is why they're statically compiled like that :)
08:33:57 * hackagebot safecopy 0.7.2 - Binary serialization with version control.  http://hackage.haskell.org/package/safecopy-0.7.2 (DavidHimmelstrup)
08:35:06 <Cale> bartavelle: I wouldn't really hold lambdabot up as an example of a well-engineered project at this point. It's had way too many years of random hackery.
08:35:15 <crdueck> @hoogle (a -> b -> c) -> (a, b) -> c
08:35:16 <lambdabot> Prelude uncurry :: (a -> b -> c) -> ((a, b) -> c)
08:35:16 <lambdabot> Data.Tuple uncurry :: (a -> b -> c) -> ((a, b) -> c)
08:35:16 <lambdabot> Data.IntMap fromAscListWith :: (a -> a -> a) -> [(Key, a)] -> IntMap a
08:35:39 <bartavelle> Cale, ok, that is what I needed to know
08:35:43 <Philonous> bartavelle:  Not that the existing XMPP libraries have some problems. None of them conform to rfc6120
08:35:52 <bartavelle> argh :(
08:36:21 <bartavelle> Philonous, you mean there are 4 non functionnal XMPP libraries on hackage right now ?
08:36:47 <Philonous> bartavelle:  Well, they partially support rfc 3920
08:37:01 <Philonous> bartavelle:  None of them has both TLS and proper SASL support
08:37:23 <bartavelle> well I could have guessed that, as it is not even in the tls package
08:37:37 <Marenz> What does this mean?  rejecting: blaze-html-0.5.1.0/installed-ef1..., 0.5.1.0, 0.5.0.0 (conflict: pandoc-1.9.4.5:blaze_html_0_5 => blaze-html>=0.4.3.0 && <0.5)
08:37:44 <Marenz> I mean, I would think htat the notation above would bean pandoc-1.9.4.5 with flag blaze_html_0_5
08:37:49 <Marenz> but pandoc with that flag does have different dependencies
08:37:54 <Philonous> bartavelle:  I hope we'll be releasing https://github.com/jonkri/pontarius-xmpp soon, though
08:38:19 <bartavelle> ah good news then !
08:38:59 * hackagebot clippard 0.1.0 - A simple Haskell library for copying text to the clipboard in a cross-platform way.  http://hackage.haskell.org/package/clippard-0.1.0 (AnthonyGrimes)
08:39:38 <bartavelle> is somebody familiar (or maintaining!) the tls package ? it lacks client authentication, which is a problem to me. Is somebody working on it, or am I the only user of such functionnality ?
08:39:52 <Jeanne-Kamikaze> that clippard thing looks pretty cool
08:42:16 <Sonderblade> any document that describes the guidelines on how to name haskell modules somewhere?
08:43:13 <Philonous> bartavelle:  vincenthz added client certificates a few weeks ago, should be in the hackage version
08:43:20 <bartavelle> !!!
08:43:23 <Cale> Philonous: https://github.com/jonkri/pontarius-xmpp/commit/bcb0f9177b953c35f0a148d340995fe3e8ad5c02 -- It's good to see that you agree with me ;)
08:43:25 <bartavelle> awesome will check this right now
08:43:51 <Cale> (about ReaderT over IO :)
08:45:06 <`Jake`> > let x = exp 999 in (x, round x)
08:45:08 <lambdabot>   (Infinity,17976931348623159077293051907890247336179769789423065727343008115...
08:45:18 <Philonous> Cale:  Yes, and it actually made most of the code simpler
08:45:54 <bartavelle> Client authentification in tls is marvelous.
08:45:59 <bartavelle> authentication even
08:46:28 <nand`> > round (1/0)
08:46:29 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:46:31 <nand`> > round (0/0)
08:46:33 <lambdabot>   -26965397022934738615939577861835371004269654684134598591014512173659901370...
08:46:50 <`Jake`> ok, i didn't expect that. Now it makes more sense.
08:46:53 <Cale> round does some weird things on divergent floating point values
08:47:21 <Cale> Maybe it ought to just error out
08:47:40 <`Jake`> I'm gonna have to look at the source code now.
08:47:50 <rwbarton> > round (-1/0)
08:47:52 <lambdabot>   -17976931348623159077293051907890247336179769789423065727343008115773267580...
08:47:59 <Cale> Though for the infinities, giving some integer value which is larger than the largest possible value than a defined floating point number would be reasonable.
08:48:08 <Cale> NaN is hard to deal with though
08:48:15 <rwbarton> the round (0/0) seems particularly unreasonable, yeah
08:48:24 <`Jake`> maxBound :: Int
08:48:25 <nand`> :t round
08:48:26 <lambdabot> (Integral b, RealFrac a) => a -> b
08:48:28 <`Jake`> > maxBound :: Int
08:48:28 <Cale> bleh, that sentence was awful
08:48:29 <lambdabot>   9223372036854775807
08:48:42 <rwbarton> > round (0/0) :: Int
08:48:42 <`Jake`> round (1/0) :: Int
08:48:44 <lambdabot>   0
08:48:50 <`Jake`> > round (1/0) :: Int
08:48:52 <lambdabot>   0
08:48:57 <Cale> heh
08:48:59 <`Jake`> > round (1/0) :: Integer
08:49:01 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:49:02 <rwbarton> > length . show $ round (0/0)
08:49:04 <Cale> makes sense
08:49:05 <lambdabot>   310
08:49:05 <`Jake`> > round (1/0) :: Word64
08:49:07 <lambdabot>   0
08:49:09 <rwbarton> > length . show $ round (-1/0)
08:49:12 <lambdabot>   310
08:49:12 * nand` would be in favor of ‘| isNan n = error ...’
08:49:18 <Cale> Int reduces modulo a small power of 2
08:49:22 <rwbarton> so hmm
08:49:24 <atriq> edwardk, is there a particular reason Control.Lens.Internal defines its own Max a and Min a etc which are equivalent to Data.Semigroup's Option (Max a) etc?
08:49:31 <nand`> IEEE floats have awful enough properties as it is; we don't need to add that sort of confusion as well
08:49:32 <rwbarton> > round (0/0) `compare` round (-1/0)
08:49:35 <lambdabot>   LT
08:49:48 <edwardk> mostly because Option (Min a) and Option (Max a) are slightly more expensive
08:49:57 <Cale> > round (-1/0) :: Int
08:49:58 <atriq> Fair enough
08:49:59 <lambdabot>   0
08:50:05 <nand`> it's always better to error than to produce a nonsensical result; even if erroring itself is practically a crime
08:50:10 <rwbarton> > realToFrac $ round (0/0) Data.Ratio.% round (-1/0)
08:50:12 <lambdabot>   Not in scope: `Data.Ratio.%'
08:50:22 <rwbarton> OH NO
08:50:25 <rwbarton> > realToFrac $ round (0/0) % round (-1/0)
08:50:28 <lambdabot>   No instance for (GHC.Real.Integral (a1 -> a0))
08:50:28 <lambdabot>    arising from a use of `GH...
08:50:43 <`Jake`> > truncate (1/0) :: Int
08:50:45 <lambdabot>   0
08:50:46 <atriq> > :t (Data.Ratio.:%)
08:50:48 <`Jake`> > truncate (1/0) :: Integer
08:50:48 <lambdabot>   <hint>:1:1: parse error on input `:'
08:50:49 <lambdabot>   179769313486231590772930519078902473361797697894230657273430081157732675805...
08:50:50 <atriq> :t (Data.Ratio.:%)
08:50:52 <lambdabot> Not in scope: data constructor `Data.Ratio.:%'
08:51:00 <`Jake`> :t (%)
08:51:00 <rwbarton> > realToFrac $ (fromInteger (round (0/0)) / fromInteger (round (-1/0)) :: Ratio Integer)
08:51:02 <lambdabot> a -> (a -> b) -> b
08:51:03 <lambdabot>   1.5
08:51:03 <rwbarton> how awful
08:51:12 <rwbarton> > realToFrac $ (fromInteger (round (0/0)) / fromInteger (round (-1/0)) :: Ratio Integer) :: CReal
08:51:14 <lambdabot>   1.5
08:51:32 <rwbarton> > round (0/0) - 3 * round (-1/0) `div` 2
08:51:34 <lambdabot>   0
08:51:41 <rwbarton> > 2 * round (0/0) - 3 * round (-1/0)
08:51:43 <lambdabot>   0
08:51:45 <rwbarton> good to know
08:53:00 <`Jake`> :source truncate
08:53:06 <`Jake`> @source truncate
08:53:07 <lambdabot> truncate not available
08:53:12 <`Jake`> dang
08:54:20 <`Jake`> It's kinda hard to understand the implementation in GHC.Real because it's all over the file...
08:56:10 <killy9999> Is there a way to rewrtie something like this more elegantly: (\(a,b,c) -> (f a, f b, f c)) ?
08:56:21 <killy9999> It turns out that (,,) is not an instance of functor
08:56:33 <nicoo> @type (,,)
08:56:34 <johnw> @pl \(a,b,c) -> (f a, f b, f c)
08:56:35 <lambdabot> a -> b -> c -> (a, b, c)
08:56:35 <lambdabot> (line 1, column 7):
08:56:35 <lambdabot> unexpected "c"
08:56:35 <lambdabot> ambiguous use of a non associative operator
08:56:43 <nand`> edwardk !!
08:56:45 <opqdonut> killy9999: no, not realy
08:56:59 <johnw> if it were a 2-element tuple lens can do it handily
08:57:00 <opqdonut> killy9999: you can always define "instance Functor (a,a,a)" :)
08:57:09 <nand`> killy9999 wants allThree :: Lens (a,a,a) (b,b,b) a b
08:57:11 <nand`> uh
08:57:11 <typoclass> killy9999: i bet there's some lens stuff, but i'd just write a helper function
08:57:12 <nand`> Traversal
08:57:17 <johnw> i'm not sure if he has an equivalent of `both' for three-member tuples
08:57:28 <Ferdirand> opqdonut: but (a,a,a) is not of kind * -> *
08:57:30 <edwardk> nand`: hah
08:57:34 <killy9999> ok, I guess I'll live with a simple lambda
08:57:41 <typoclass> killy9999: note that the Functor (,) instance doesn't touch both of the elements:
08:57:43 <killy9999> but I wonder why (,) is a Functor and (,,) isn't
08:57:48 <typoclass> > fmap succ (2,7)
08:57:50 <lambdabot>   (2,8)
08:57:55 <nand`> (,) isn't a functor
08:57:56 <edwardk> all3 f (a,b,c) = (,,) <$> f a <*> f b <*> f c
08:57:59 <nand`> wrong kind
08:58:02 <killy9999> typoclass: oh, I didn't know that
08:58:18 <edwardk> (,) e  is a functor
08:58:26 <nand`> ‘(,) a’ is a functor; you could make ‘(,,) a b’ a functor as well
08:58:30 <typoclass> edwardk: well, shouldn't that be called both3 ;-)
08:58:30 <nand`> but neither of those would help you with what you want
08:58:31 <opqdonut> Ferdirand: right, of course
08:58:44 <edwardk> typoclass: =P
08:58:49 <`Jake`> 1000 people in #haskell!
08:58:53 <`Jake`> not anymore :(
08:59:10 <nand`> are we going to celebrate that every time it happens?
08:59:16 <`Jake`> maybe
08:59:46 <atriq> bos, you are the thousandth person to visit this channel! You win a prize!
08:59:52 <atriq> Just email me your bank details!
09:00:09 <Sculptor> bet 417 scam ever
09:00:11 <Sculptor> besyt
09:00:13 <Sculptor> best
09:00:20 <atriq> (disclaimer: there is no prize, please don't email me your bank details)
09:00:29 <Marenz> I take them!
09:00:30 <Sculptor> 419
09:00:34 <killy9999> I like edward's all3 :)
09:02:27 <mapf> nand`: heh
09:02:32 <DMcGill> so #Haskell has 1k users while ##programming has 300
09:02:32 <lambdabot> DMcGill: You have 1 new message. '/msg lambdabot @messages' to read it.
09:02:50 <mapf> haskell more than programming?
09:03:01 <`Jake`> #cplusplus
09:03:03 <`Jake`> oops
09:03:06 <`Jake`> wanted to join
09:03:11 <Saizan> DMcGill: it's not like anyone here programs in haskell
09:04:34 <johnw> wait, we have to know Haskell to be here?
09:04:35 <DMcGill> I'll ask here then: does anybody have any nice papers I should read before trying to implement a physics engine?
09:04:51 <edwardk> saizan is conditioned to that response from working in agda and hanging out on #agda all day. Nobody there runs programs in agda either ;)
09:04:51 <nicoo> DMcGill: What kind of « physics engine »
09:05:09 <atriq> edwardk, is there much point in making both an indexed traversal, where the index is 0 or 1?
09:05:17 <nand`> iirc edwardk has done some interesting stuff re: physics engines in the past
09:05:24 <nand`> something something coalgebras, the details are fuzzy
09:05:37 <edwardk> atriq: not really since i don't offer the corresponding indexing function
09:05:45 <nand`> make _everything_ an indexed traversal
09:05:51 <edwardk> nand`: =P
09:06:03 <nand`> we should have type Ordinal for indices either way
09:06:20 <edwardk> i make indexed traversals mostly when they are literally things like traverseWithKey  or when they correspond to the key for such an traversal
09:06:21 <Saizan> edwardk: something like that :)
09:06:42 <DMcGill> the plan was to make it a) 3D and b) in FRP. Beyond that, it's quite open - I like the idea of using a simulation method with differential equations but I'm open to ideas. I'm making it with the aim of oneday turning it into a full game engine a la unity or XNA.
09:06:55 <nand`> DMcGill: any plans on what FRP lib you're using?
09:07:09 * Cale considers hanging around in ##programming and answering people's questions in Haskell regardless of which language they happened to be using.
09:07:25 <Nimatek> Cale: Productive trolling.
09:07:27 <edwardk> nand`: i have a small physics package that was really just a bunch of linear algebra primitives, so acowley shamed me into splitting that out into 'linear' ;)
09:07:31 <nand`> Cale: well-written Haskell is indistinguishable from pseudocode
09:07:34 <atriq> to :: (a -> b) -> SimpleIndexedTraversal Void a b
09:07:54 <typoclass> nand`:  _1.mapped._2.mapped %~ succ $ ([(42, "hello")],"world")
09:08:02 <DMcGill> either Yampa or netwire,  I'm trying to decide which - my supervisor has worked on Yampa so he's very famility with it but then I like the idea of not having to deal with all those switching statements
09:08:19 <atriq> Poorly written Haskell is indistinguishable from something I've written
09:08:21 <edwardk> that uses lenses as the representation of representable functors, so you can model vector spaces nicely, index them with lenses. foo^._x, etc.
09:08:21 <nand`> atriq: that isn't a traversal though
09:08:26 <nand`> or is it?
09:08:33 <monochrom> /msg ##programming how do I write a haskell interpreter in c?
09:08:40 <atriq> nand`, I was joking, probably
09:08:52 <nand`> SimpleIndexedGetter () a b
09:08:58 * hackagebot clippard 0.1.1 - A simple Haskell library for copying text to the clipboard in a cross-platform way.  http://hackage.haskell.org/package/clippard-0.1.1 (AnthonyGrimes)
09:09:16 <edwardk> nand`: he was using the Void to prevent you from modifying it, but it doesn't work because you also can't read that way
09:09:32 <edwardk> you can pretty much index anything though
09:09:33 <edwardk> :t indexed
09:09:35 <lambdabot> Indexed Int k => ((a -> Control.Lens.Internal.Indexing f b) -> s -> Control.Lens.Internal.Indexing f t) -> k (a -> f b) (s -> f t)
09:09:42 <atriq> Yeah, the (->) instance of Indexed
09:09:44 <edwardk> :t indexed traverse
09:09:45 <lambdabot> (Applicative f, Traversable t, Indexed Int k) => k (a -> f b) (t a -> f (t b))
09:09:56 <edwardk> :t withIndex (indexed traverse)
09:09:57 <lambdabot> (Applicative f, Traversable t) => (Int -> a -> f b) -> t a -> f (t b)
09:10:42 <Saizan> :t withIndex
09:10:43 <lambdabot> Index i a b -> (i -> a) -> b
09:10:59 <edwardk> that gives you a traversal with the numbers assigned starting from 0, increasing by one for each position, where you can use that key for elementOf of the same traversal to update it
09:11:25 <edwardk> newtype Index i a b = Index { withIndex : (i -> a) -> b }
09:11:52 <edwardk> instance i ~ j => Indexed i (Index j)
09:16:35 <arcatan> hmm, if i want to use http-conduit and oauth, is authenticate-oauth the library i need?
09:17:22 <atriq> arcatan, it's the one I have
09:17:34 <atriq> hoauth definitely isn't.
09:18:53 <arcatan> yeah
09:20:00 <atriq> I haven't gotten very far, but authenticate-oauth works well
09:25:38 <x7> yo guys!
09:25:46 <x7> haskell rocks ^_^
09:25:47 <atriq> Yo!
09:25:51 <atriq> Indeed it does.
09:25:53 <saml> no it does not
09:25:59 <x7> whaa
09:26:08 <x7> you wanna sort it out?? :DD
09:32:47 <bgamari> tibbe, Well done with the attoparsec changes!
09:32:57 <tibbe> bgamari: thanks, I think I can still do more
09:33:17 <tibbe> bgamari: There's a Haskell meet-up this evening. Perhaps I will get to hack some then.
09:33:21 <edwardk> ooh, attoparsec updates?
09:33:41 <tibbe> edwardk: https://github.com/bos/attoparsec/pull/28
09:33:52 <tibbe> edwardk: I made it almost twice as fast on some microbenchmarks
09:33:56 <edwardk> score
09:34:00 <tibbe> edwardk: I'm working on improving the space behavior
09:34:17 <tibbe> edwardk: and generally going over the code with a very fine comb
09:34:30 <tibbe> edwardk: I think I have figured out how to make CPS code fast
09:34:36 <tibbe> (although not quite optimal)
09:34:42 <edwardk> there is one combinator i need in attoparsec to make an instance for my parsers classes at last check. i think it was lookAhead
09:34:52 <tibbe> the Issue is that there's a lot of code like this:
09:35:11 <edwardk> then folks could write to parsers and use attoparsec, parsec or trifecta interchangeably in their code depending on the features they need
09:35:26 <tibbe> ensure n ks = if bufLen < n then getMoreInput >> ks else ks
09:35:36 <tibbe> where ks is the success continuation of the parser
09:35:45 <tibbe> the issue is that since ks is used twice it's not getting inlined
09:35:52 <tibbe> causing all kinds of closures to get allocated
09:35:59 <tibbe> in the common case
09:36:12 <tibbe> so I found my first ever use case for the GHC magic inline function
09:36:21 <edwardk> so you need to pull it forward, and let binding it possibly forcing it?
09:36:37 <tibbe> ensure n ks = if bufLen < n then getMoreInput >> ks else inline ks
09:36:47 <edwardk> ahhh
09:36:50 <tibbe> so we're telling GHC that we're fine with duplicating the code
09:37:05 <tibbe> not quite optimal, I'd like to have GHC un-CPS the code and tie the knot into a loop
09:37:07 <edwardk> i need to sprinkle that liberally in trifecta
09:37:11 <tibbe> but it's much better than what we have today
09:37:51 <tibbe> oh
09:38:00 <tibbe> the second thing I did was to make sure ensure wasn't recursive
09:38:16 <tibbe> before it was something like: ensure n ks = if bufLen < n then getMoreInput >> ensure n ks else ks
09:38:26 <tibbe> so it couldn't be inlined
09:38:31 <tibbe> I made it into something like:
09:38:32 <edwardk> *nods*
09:38:40 <tibbe> ensure n ks = if bufLen < n then getMoreInput >> go else ks
09:38:54 <tibbe>   where go =  bufLen < n then getMoreInput >> go
09:38:58 <tibbe> basically unrolled it once
09:39:12 <tibbe> now the bounds check can be inlined
09:39:18 <tibbe> Core looks really nice
09:39:39 <edwardk> i sadly had to write a bunch of unsafeCoerce's into lens to make nice core =(
09:40:07 <atriq> I feel like a master of unsafeCoerce
09:40:19 <atriq> I use it for recursion
09:40:20 <tibbe> :/
09:40:26 <tibbe> I've never used one
09:40:27 <atriq> When I'm feeling evil
09:40:37 <tibbe> but I have committed an unsafePtrEquality# sin
09:40:45 <edwardk> i had a lot of foo l f = takeNewtypeOff . l (putNewtypeOn . f)   -- like code in there.   but (putNewtypeOn . f)    turns into \x -> f x    -- not f when ghc gets done making things vanish
09:40:58 <tibbe> my first sin was: ptrEq = reallyUnsafePtrEquality#
09:40:58 <edwardk> this means you always have this anoying eta-expansion wrapper around it
09:41:09 <tibbe> right
09:41:43 <tibbe> The ptrEq turned out to be useful to preserve sharing and avoiding allocation in unordered-containers
09:41:55 <edwardk> so lens now has a bunch of foo# :: (a -> b) -> a -> Foo b; foo# = unsafeCoerce; unfoo# :: (a -> Foo b) -> a -> b; unfoo# = unsafeCoerce wrappers for casting functions
09:42:11 <tibbe> for example, if you implement delete :: k -> Map k v -> Map k v you can avoid any allocation if the key is not in the map
09:42:54 <edwardk> so that becomes foo l f = unfoo# (l (foo# f)) -- and the core vanishes. so a lot of stuff just becomes calls to map cast to the right type, etc.
09:43:01 <tibbe> right
09:43:28 <edwardk> it sadly makes a ~40-50% speed difference on a lot of stuff
09:43:29 <rwbarton> you could also implement that with GeneralizedNewtypeDeriving I guess
09:43:40 <edwardk> rwbarton: thats what i used to use for this sort of thing
09:43:47 <rwbarton> sounds like a pain though
09:43:50 <edwardk> but then i'm making instances for lots of third party types, etc.
09:44:04 <edwardk> also i expect them to eventually close that loophole ;)
09:45:17 <rwbarton> I thought some day we were going to get separate kind (->) constructors for things that do/don't preserve isos
09:47:04 <latermuse> are there ffmpeg bindings in haskell?
09:53:15 <bitonic`> edwardk: it would be nice to have a set of combinators to traverse Scope while keeping a context, unless I'm missing something it's a bit fiddly
09:54:29 <arbn> Hmm. Isn't "writeFIle" supposed to create a file if it doesn't exist? I'm getting a "openFile: does not exist (No such file or directory)" message.
09:54:52 <bitonic> edwardk: specifically if I need to keep a context while traversing inside binders
09:55:10 <bitonic> so I need to have bounded variables at various levels in the context
09:55:41 <rwbarton> arbn: maybe you tried to writeFile a file in a directory that doesn't exist
09:56:07 <edwardk> bitonic: use fromScope and toScope. see the whnf definition in the Simple.hs example
09:56:43 <edwardk> then you can carry whatever context you need for the new 'free' variable notion
09:57:03 <arbn> rwbarton: Gah. Thanks. That was it. I thought Haskell would be OK with '~' as a path alias. Apparently not.
09:57:14 <rwbarton> that is the shell's business
09:57:26 <lispy> No place like $HOME
09:58:04 <bitonic> edwardk: yes but I was wondering if there is a nice abstraction to encode that
09:59:31 <tibbe> bgamari: btw, I'm about to release a new streaming API for cassava that should let you do O(1) space parsing
09:59:48 <tibbe> bgamari: I'm still going to fix your issue though
09:59:48 <tibbe> bgamari: just thought you might be interested
10:04:24 <eacameron1> I want to write a function that takes [a] groups it by a list of functions. So the return type is somewhat recursive: if there is one function to group by, it's type is [(v -> k)] -> [v] -> [(k, [v])]. If there are two functions, it's [(v -> k)] -> [v] -> [(k, [(k, [v])])], etc. Is this even possible in Haskell?
10:07:55 <lispy> eacameron: Hmm...I think it's probably possible. We can have types that are recursive.
10:08:12 <lispy> eacameron: You might get some ideas from the faking dependent types paper, let me get a link
10:09:03 <lispy> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.22.2636
10:11:43 <edwardk> bitonic: i don't have one, but if you work something out, let me know ;)
10:12:01 <bitonic> edwardk: OK
10:21:57 <victorm> hello everyone!
10:22:24 <victorm> what you guys think is a good, simple tutorial to haskell?
10:22:37 <Iceland_jack> Learn You a Haskell
10:22:45 <typoclass> @where lyah
10:22:46 <eacameron> learn you a haskell for great good
10:22:46 <lambdabot> http://www.learnyouahaskell.com/
10:22:54 <typoclass> victorm: hello, welcome. try this ^^ :-)
10:23:26 <victorm> typoclass: thank you :)
10:23:44 <eacameron> Is it possible to describe [(a,b)] recursively? such that b can also be a [(a, b)]?
10:24:00 * hackagebot lens 3.3 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.3 (EdwardKmett)
10:25:03 <rwbarton> eacameron, you can define your own data type of course
10:25:05 <rwbarton> some kind of tree
10:25:27 <eacameron> rwbarton: so it can't be done with normal lists and tuples?
10:25:30 <S11001001> eacameron: you can't literally just use list and tuple; you need a recursive structure.  Free (Compose [] ((,) a)) b would be one example, but you might prefer just writing your own tree.
10:26:16 <eacameron> S11001001: What is that Free thing?
10:26:31 <S11001001> @hoogle free
10:26:32 <lambdabot> Foreign.Marshal.Alloc free :: Ptr a -> IO ()
10:26:33 <lambdabot> Foreign.Ptr freeHaskellFunPtr :: FunPtr a -> IO ()
10:26:33 <lambdabot> Foreign.Marshal.Pool freePool :: Pool -> IO ()
10:26:36 <S11001001> oh come on
10:26:47 <rwbarton> just write it explicitly
10:26:49 <S11001001> http://hackage.haskell.org/package/free
10:27:07 <rwbarton> newtype Eacameron a b = Eacameron [(a, Either b (Eacameron a b))]
10:27:48 <eacameron> rwbarton: Thank you! That is been driving me crazy
10:27:51 <rwbarton> or you might want to put the Either on the outside
10:27:56 <rwbarton> and use a data instead of newtype
10:28:15 <rwbarton> data EacameronTree a b = Leaf b | Branch [(a, EacameronTree a b)] -- looks more like a traditional tree
10:28:16 <eacameron> rwbarton: why newtype and not data?
10:28:38 <rwbarton> no particular reason
10:28:44 <eacameron> thanks
10:30:04 <rwbarton> for your earlier question you might want the non-regular recursion kind of tree instead... or no recursion at all
10:30:07 <rwbarton> hard to tell
10:30:45 <rwbarton> does your input really honestly need to be a list, that is, length unknown at compile time
10:31:33 <rwbarton> often people think "length not fixed -> use a list" and then make their life a lot more complicated and people here give them correspondingly complicated solutions
10:33:48 <eacameron> how would you have a un-fixed list? One whose length is known at compile time?
10:34:00 <eacameron> *rather a "fixed" list
10:34:03 <eacameron> @rwbarton
10:34:04 <lambdabot> Unknown command, try @list
10:34:04 <rwbarton> don't use a list
10:34:42 <rwbarton> for example, use an idiom like f <$> arg1 <*> arg2 <*> ... <*> argN
10:34:50 <tibbe> bgamari: could you relax the dependencies of legos to allow for bytestring-0.9, containers-0.4, and base-4.5
10:34:54 <rwbarton> works for any number of arguments, yet no lists
10:35:00 <tibbe> bgamari: it builds with those as well
10:35:18 <tibbe> bgamari: that way I don't have to patch the repo on every machine I try it on :)
10:35:33 <eacameron> rwbarton: I'm really just trying to copy a function from python into haskell...the python impl uses dictionaries and lists
10:35:54 <rwbarton> you asked a classic "type depending on values" sort of question
10:36:09 <rwbarton> one solution is make the type not depend on the values, that's this tree solution
10:36:41 <rwbarton> a single tree type for trees with any number of branches
10:37:03 <eacameron> rwbarton: not sure I understand the "type depending on values" phrase
10:37:18 <rwbarton> < eacameron1> I want to write a function that takes [a] groups it by a list of functions. So the return type is somewhat recursive: if there is one function to group by, it's type is [(v -> k)] -> [v] -> [(k, [v])]. If there are two functions, it's [(v -> k)] -> [v] -> [(k, [(k, [v])])], etc. Is this even possible in Haskell?
10:37:49 <eacameron> rwbarton: ahh
10:37:54 <eacameron> yes...that is true
10:38:44 <rwbarton> the other possible solution, if you actually know the number of functions at any particular use site, is to solve the problem for a single function
10:38:56 <eacameron> rwbarton: I've done that
10:39:09 <rwbarton> then do something like classify f1 . map (classify f2) . ... . map (classify fn)
10:39:14 <rwbarton> not sure how well that would work here
10:39:40 <eacameron> I'll see what I can come up with...maybe post a gist when I'm done
10:39:55 <rwbarton> possibly you can come up with some combinators that are more appropriate than (.)/map
10:40:08 <johnw> is there a way to download the haddock docs for all packages on Hackage?
10:40:36 <fmapE> Hey all. I'm using virthualenv with ghc-7.6. The occasional package fails with the following error:
10:40:40 <edwardk> rwbarton: resultAt is fixed
10:41:00 <edwardk> @tell cale (new lens release) ;)
10:41:00 <lambdabot> Consider it noted.
10:41:01 <fmapE> Use of GHC's environment variable GHC_PACKAGE_PATH is incompatible with
10:41:01 <fmapE> Cabal. Use the flag --package-db to specify a package database (it can be used
10:41:01 <fmapE> multiple times).
10:41:13 <Cale> edwardk: heh, okay
10:41:13 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:41:35 <fmapE> Why don't all of my packages fail this way? Virthualenv sets this environment variable globally.
10:41:39 <rwbarton> eacameron: for example: define foo :: (v -> k) -> [v] -> (v -> v') -> [(k, v')]
10:42:09 <rwbarton> oops, better be foo :: (v -> k) -> (v -> v') -> [v] -> [(k, v')]
10:42:21 <eacameron> rwbarton:  I thought of that too...
10:42:23 <rwbarton> (foo f1 $ foo f2 $ ... foo fn) v
10:42:26 <rwbarton> wouldn't that work?
10:43:15 <rwbarton> @let foo :: (v -> k) -> [v] -> (v -> v') -> [(k, v')] ; foo = undefined
10:43:18 <lambdabot>  Defined.
10:43:30 <rwbarton> :t (foo ?f1 $ foo ?f2 $ foo ?f3 $ id) v
10:43:32 <lambdabot>     Couldn't match expected type `[v0]' with actual type `a0 -> a0'
10:43:33 <lambdabot>     In the second argument of `($)', namely `id'
10:43:33 <lambdabot>     In the second argument of `($)', namely `foo ?f3 $ id'
10:43:38 <rwbarton> :t (foo ?f1 $ foo ?f2 $ foo ?f3 $ id) ?v
10:43:39 <lambdabot>     Couldn't match expected type `[v0]' with actual type `a0 -> a0'
10:43:40 <lambdabot>     In the second argument of `($)', namely `id'
10:43:40 <lambdabot>     In the second argument of `($)', namely `foo ?f3 $ id'
10:44:00 <rwbarton> oh, oops
10:44:03 <rwbarton> @undefine
10:44:08 <rwbarton> @let foo :: (v -> k) -> [v] -> (v -> v') -> [(k, [v'])] ; foo = undefined
10:44:10 <lambdabot>  Defined.
10:44:14 <rwbarton> :t (foo ?f1 $ foo ?f2 $ foo ?f3 $ id) ?v
10:44:16 <lambdabot>     Couldn't match expected type `[v0]' with actual type `a0 -> a0'
10:44:17 <lambdabot>     In the second argument of `($)', namely `id'
10:44:17 <lambdabot>     In the second argument of `($)', namely `foo ?f3 $ id'
10:44:28 <rwbarton> :t foo ?f1 id ?v
10:44:30 <lambdabot>     Couldn't match expected type `[v0]' with actual type `a0 -> a0'
10:44:30 <lambdabot>     In the second argument of `foo', namely `id'
10:44:30 <lambdabot>     In the expression: foo ?f1 id ?v
10:44:35 <ski> do you want `id' there ?
10:44:41 <rwbarton> oh i messed up the order yet again
10:44:44 <rwbarton> @undefine
10:44:54 <rwbarton> @let foo :: (v -> k) -> (v -> v') -> [v] -> [(k, [v'])] ; foo = undefined
10:44:56 <lambdabot>  Defined.
10:45:09 * ski scratches head
10:45:22 <rwbarton> :t (foo ?f1 $ foo ?f2 $ foo ?f3 $ id) ?v
10:45:24 <lambdabot> (?f1::[[v']] -> k, ?f2::[v'] -> k1, ?f3::v' -> k2, ?v::[[[v']]]) => [(k, [[(k1, [[(k2, [v'])]])]])]
10:45:39 <rwbarton> well that looks not quite right, but close
10:45:44 <Cale> edwardk: btw, it's usually okay to send me a pm before you use @tell
10:45:50 <Cale> edwardk: I don't often lose pms
10:46:58 <rwbarton> @undefine
10:47:04 <edwardk> cale: fair nuff
10:47:10 <rwbarton> @let foo :: (v -> k) -> ([v] -> v') -> [v] -> [(k, v')] ; foo = undefined
10:47:11 <edwardk> @tell cale will do =)
10:47:15 <lambdabot>  Defined.
10:47:15 <lambdabot> Consider it noted.
10:47:17 <rwbarton> :t (foo ?f1 $ foo ?f2 $ foo ?f3 $ id) ?v
10:47:19 <lambdabot> (?f1::v -> k, ?f2::v -> k1, ?f3::v -> k2, ?v::[v]) => [(k, [(k1, [(k2, [v])])])]
10:47:25 <rwbarton> there
10:47:44 <Cale> lol
10:47:44 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
10:47:50 <edwardk> lolwut
10:47:52 <rwbarton> eacameron: see, now there is no longer any list of functions
10:47:56 <copumpkin> wutlol
10:49:06 <mapf> is fmap succ an endofunctor in Hask?
10:49:32 <johnw> "fmap succ" is a function mapped by an endofunctor in Hask
10:49:43 <johnw> and all functors in Hask are endofunctors
10:49:57 <johnw> (try mapping to something outside of Haskell and you'll see why :)
10:50:15 <ski> (s/functors/instances of `Functor'/)
10:51:12 <johnw> ski: being an instance of Functor alone doesn't make you a functor :)
10:51:47 <ski> yes, and being a functor alone doesn't make you an instance of `Functor'
10:51:52 <johnw> yep
10:52:46 <b__> what are my options in terms of libraries for spawning/forking external processes?
10:52:55 <mapf> hm, then contravariant functor is cofmap :: (a -> b) -> f b -> f a
10:52:56 <mapf> ?
10:53:12 <johnw> yes
10:53:29 <johnw> edwardk has that type class in a library somewhere...
10:53:37 <mapf> is it exist actuall?...
10:53:42 <johnw> sure
10:53:59 <ski> johnw : e.g. if you define `newtype Tree f a = T (f (Node f a)); data Node f a = Leaf a | Branch (f (Tree f a))', then `Tree :: (* -> *) -> (* -> *)' is a functor, but can't be an instance of `Functor'
10:54:04 <johnw> if it's related to category theory, and you can imagine it in Hask, there's a good change it exists
10:54:08 <johnw> chance*
10:54:42 <jmcarthur> one example of a contrafunctor is   newtype T r a = T (a -> r)
10:55:05 <jmcarthur> that is, you can define   instance Contrafunctor (T r) where ...
10:56:46 <ski> another example is `data IOWriteRef a = forall b. IOWR (a -> b) (IORef b)'
10:57:46 <sm> tibbe's comment at http://www.reddit.com/r/haskell/comments/138qdr/understanding_cabals_conflict_reports/ is interesting.. does having Default: in a cabal flag definition always disable cabal's automatic flag toggling ?
10:57:59 <pmade> Where does hslint come from?  haskell-mode for Emacs wants it, but I can't find any OS or Haskell package with that name.
10:58:24 * sm thought it was hlint
10:58:39 <pmade> Well, that would explain it ;)
10:58:55 <luite> hehe
10:59:10 <tibbe> sm: I think it does, but dcoutts or kosmikus would know for use.
10:59:12 <tibbe> sure*
11:00:48 <sm> tibbe: +1 also for your cabal error message bug report, I think there's still a lot of pain that can be removed "just" with better error messages
11:01:20 <Tekmo> That applies to almost any project
11:01:20 <tibbe> sm: I think so too. I think we even regressed a bit. The old solver included more info about why certain choices of package versions were made.
11:01:21 <lambdabot> Tekmo: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:01:38 <Tekmo> Attention to detail, documentation, and error messages greatly improves the user experience
11:02:18 <tibbe> Tekmo: absolutely
11:02:32 <tibbe> Tekmo: I try to give lot of attention to it in my libraries
11:02:38 <Tekmo> I notice :)
11:02:43 <bgamari> tibbe, Sure
11:04:03 <ParahSail1n> conduits or pipes?
11:05:22 <lispy> b__: there is the process library, I think it's System.Process
11:05:41 <lispy> ?hoogle runInteractiveProcess
11:05:42 <lambdabot> System.Process runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
11:06:00 <bgamari> tibbe, Done
11:06:01 <lispy> b__: that's one of the more general ones, but there are several entry points
11:06:15 <tibbe> bgamari: thanks
11:06:16 <b__> lispy, thank you, looks good =]
11:16:32 <edwardk> :t resultAt
11:16:33 <lambdabot> (Eq e, Functor f, Indexed e k) => e -> k (a -> f a) ((e -> a) -> f (e -> a))
11:16:53 <Igloo> sm: Default just sets the default. "manual: True" disables the automatic toggling
11:17:20 * Igloo isn't quite sure what the new solver does, though. kosmikus would know more.
11:18:06 <shachaf> Oh, 3.3 is out?
11:18:28 <edwardk> shachaf: merry christmas
11:18:45 <edwardk> it had accumulated enough real bugfixes that i wanted to get it out
11:19:05 <shachaf> Makes sense.
11:19:21 <neutrino> hi
11:19:25 * shachaf doesn't remember Christmas being every time edwardk releases a package...
11:19:40 <neutrino> is there a function a -> [a] -> Bool which tells me if every element of the list is equal to the first argument?
11:19:51 <neutrino> for example, "is this string made out of spaces only?"
11:20:01 <monochrom> you need Eq a
11:20:10 <sw17ch> :t all
11:20:12 <lambdabot> (a -> Bool) -> [a] -> Bool
11:20:22 <monochrom> @type \x xs -> all (x ==) xs
11:20:24 <lambdabot> Eq a => a -> [a] -> Bool
11:20:26 <sw17ch> > all (== ' ') (take 10 $ repeat ' ')
11:20:31 <lambdabot>   True
11:20:33 <sw17ch> neutrino: ^^
11:21:01 <neutrino> :t all
11:21:03 <tromp> > all ( == error "oops") []
11:21:03 <lambdabot> (a -> Bool) -> [a] -> Bool
11:21:05 <lambdabot>   True
11:21:11 <neutrino> hmm i guess that works
11:21:13 <neutrino> thanks
11:21:20 <sw17ch> :)
11:22:31 <neutrino> :)
11:24:34 <rAad> :)
11:24:34 <neutrino> wow guys
11:24:51 <neutrino> since i added basic refactoring support to vim that makes it so much easier to write code that makes sense
11:25:20 <sm> hey, I want refactoring support too
11:25:27 <rAad> yeah, what are you talking about?
11:25:40 <sm> Igloo: ah, that makes sense!
11:25:41 <neutrino> for example i wrote this line to remove the first and last elements of a list that are spaces-only strings
11:25:44 <neutrino>         truncateEmptyLines x = dropWhile isSpaces (reverse ( dropWhile isSpaces ( reverse x)))
11:25:56 <neutrino> and then i ran pl on it by selecting and doing :Pl
11:26:03 <neutrino> it changed to :
11:26:09 <neutrino> @pl        truncateEmptyLines x = dropWhile isSpaces (reverse ( dropWhile isSpaces ( reverse x)))
11:26:09 <lambdabot> truncateEmptyLines = dropWhile isSpaces . reverse . dropWhile isSpaces . reverse
11:26:30 <neutrino> that makes it painfully visible that it's just two times dropWhile isSpaces . reverse
11:26:45 <rAad> is that a plugin?
11:26:58 <neutrino> i wrote a small script i put in my vimrc, 1 sec
11:28:00 * sm 's refactoring support is emacs macros, [tags-] search and replace, and rgrep
11:28:07 <hpaste> neutrino pasted “haskell vim stuff” at http://hpaste.org/77787
11:28:23 <neutrino> this is like super-basic right now
11:28:42 <neutrino> i'm hoping to put lambdabot's undo in a separate library soon so that it can be used too
11:28:54 <neutrino> and then maybe it would be possible to use some stuff from HaRe
11:29:42 <neutrino> witing support for K was really fun
11:30:13 <neutrino> i think i might improve it still by preselecting the most likely module
11:30:15 <rAad> oh wow, cool
11:30:32 <rAad> I'm still far too much of a haskell newb though
11:30:40 <neutrino> so am i
11:30:46 <neutrino> those things really help with learning
11:30:48 <neutrino> especially K
11:34:05 <OceanSpray> @hoogle zipWithM
11:34:06 <lambdabot> Control.Monad zipWithM :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m [c]
11:34:06 <lambdabot> Control.Monad zipWithM_ :: Monad m => (a -> b -> m c) -> [a] -> [b] -> m ()
11:34:06 <lambdabot> Data.Generics.Twins gzipWithM :: Monad m => GenericQ (GenericM m) -> GenericQ (GenericM m)
11:34:16 <luqui> Hey, I'm having some trouble with type families.  Here's an example: https://gist.github.com/08823f005f5e0467f6b0
11:34:17 <lambdabot> luqui: You have 1 new message. '/msg lambdabot @messages' to read it.
11:34:37 <luqui> is there any way to refer to 'doit' at all?
11:34:43 <neutrino> luqui: you can choose you type friends.. you can't choose your type family!
11:35:24 <rwbarton> luqui: no
11:35:34 <aristid> i wish there wasn't just Integer, but also the same without negative numbers :/
11:35:39 <rwbarton> not as you have it now
11:35:47 <rwbarton> because the type Under a does not determine the type a
11:36:00 <Eduard_Munteanu> Hopefully you don't pick asstype friends. :P
11:36:01 <luqui> yeah I'd need to use a data family, right?
11:36:17 <neutrino> @hoogle Ord a => [a] -> a
11:36:17 <lambdabot> Prelude maximum :: Ord a => [a] -> a
11:36:18 <lambdabot> Data.List maximum :: Ord a => [a] -> a
11:36:18 <lambdabot> Prelude minimum :: Ord a => [a] -> a
11:36:24 <luqui> hmmm….
11:36:40 <rwbarton> either that or change the type of doit to Label a (Under a) / proxy a -> Under a / etc.
11:36:53 <neutrino> Eduard_Munteanu: what's an asstype?
11:37:15 <Eduard_Munteanu> neutrino: associated type families
11:37:16 <luqui> rwbarton: what is this Label?
11:37:30 <rwbarton> newtype Label l a = Label a
11:37:36 <luqui> ok thought so
11:37:41 <luqui> that may be the way, thanks
11:37:46 <Eduard_Munteanu> "asstype" is a popular short for it, like "fundeps".
11:37:46 <neutrino> Eduard_Munteanu: ok
11:41:03 <neutrino> Eduard_Munteanu: thank you
11:41:58 <ciaranm> what's the correct generalisation for being able to turn Maybe into lots of other monads?
11:44:13 <copumpkin> ciaranm: ?
11:44:30 <rwbarton> well what you want is mzero without mplus
11:44:53 <ciaranm> hrm, possibly
11:46:28 <ciaranm> a lot of these polynomial-looking functors that don't have any additional rules look like they might support some kind of canonical conversions between them in certain directions
11:48:30 <luqui> but are there any laws about mzero that don't involve mplus
11:48:47 <luqui> other than parametricity from the very general type, i guess
11:48:54 <copumpkin> whoa, luqui on IRC again
11:48:58 * copumpkin blinks
11:49:03 <luqui> :-)
11:49:11 <luqui> yeah back engineering again.  i hadn't touched code for a few months
11:49:15 <luqui> had to eat though
11:49:17 <copumpkin> oh man, he's in CO too.
11:49:30 <copumpkin> which means that we know why he's hungry
11:49:50 <copumpkin> :)
11:49:55 <luqui> i… don't get it
11:50:50 <neutrino> @pl flipDropMargin x = map (drop (marginSize x)) x
11:50:50 <lambdabot> flipDropMargin = map =<< drop . marginSize
11:51:02 <neutrino> is this... correct? i didn't expect to see =<< there.
11:51:10 <luqui> yeah it's in (-> r) monad
11:51:18 <luqui> er, (r ->)
11:51:38 <copumpkin> luqui: referring to the recent legalization of certain things
11:51:43 <copumpkin> just being silly :P
11:51:45 <neutrino> luqui: sorry?
11:51:45 <luqui> ahahahahaha
11:52:02 <luqui> it hasn't taken effect yet so everybody else thinks its a bigger deal than we do
11:52:06 <copumpkin> oh ok
11:52:38 <luqui> neutrino: (f =<< x) r = (f r) (x r)
11:52:42 <Cale> same-sex marriage?
11:52:48 <luqui> hungry for LOVE
11:52:58 <luqui> no we don't have that yet though, IIRC
11:52:59 <neutrino> @src =<<
11:53:00 <lambdabot> f =<< x = x >>= f
11:53:07 <neutrino> @src >>=
11:53:08 <lambdabot> Source not found. There are some things that I just don't know.
11:53:23 <luqui> @src (->) >>=
11:53:23 <ski> @wiki MonadPlus
11:53:24 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus
11:53:24 <lambdabot> Source not found. Maybe you made a typo?
11:53:27 <ski> @wiki MonadPlus reform proposal
11:53:28 <lambdabot> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
11:53:39 <luqui> i forget how to ask for the source from a specific instance
11:53:43 <Cale> (maybe that wasn't Colorado, which would spoil my joke :)
11:53:46 <ski> @src (->) (>>=)
11:53:46 <lambdabot> f >>= k = \ r -> k (f r) r
11:54:12 <OceanSpray> Data.Set is not traversable?
11:54:13 <neutrino> @src (->) (=<<)
11:54:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
11:54:22 <neutrino> ok, what is (->) here?
11:54:25 <shachaf> OceanSpray: Correct.
11:54:37 <neutrino> :t >>=
11:54:39 <lambdabot> parse error on input `>>='
11:54:41 <luqui> neutrino: the type of functions
11:54:42 <OceanSpray> well ain't that a jar of pickles
11:54:43 <ski> neutrino : the `->' in `ord :: Char -> Int'
11:54:45 <neutrino> :t (>>=)
11:54:46 <ciaranm> neutrino: a pointy thing
11:54:47 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:54:49 <luqui> er, type *constructor* of functions, specifically
11:54:57 <shachaf> OceanSpray: It's not even a Functor!
11:55:02 <neutrino> so here m is (->) ?
11:55:17 <ski> no, `m' is `(r ->)'
11:55:19 <luqui> m is (->) r,  functions from a specific thing
11:55:20 <ciaranm> (->) isn't a monad. (a->) is.
11:55:41 <neutrino> why is (a ->) a monad?
11:55:55 <neutrino> and does it have a name?
11:55:56 <ski> because `Reader a' is one
11:56:03 <aristid> neutrino: because the instance conforms to the monad laws :)
11:56:08 <neutrino> mhm
11:56:11 <aristid> that's all the reason there needs to be
11:56:22 <ciaranm> neutrino: because of the yoneda lemma, but backwards
11:56:26 <luqui> it's an important one though… kind of the first one you might think of if you were thinking a certain way
11:56:38 <luqui> i don't know how to say it any more lucid way
11:57:05 <neutrino> ciaranm: i have no idea what the yoneda lemma is :\
11:57:11 <shachaf> You don't need to.
11:57:17 <shachaf> aristid's answer is sufficient.
11:57:20 <luqui> nah nevermind, Identity is more important
11:57:35 <neutrino> what does the do syntax do in that monad?
11:57:38 <shachaf> luqui: Cont is clearly the most important monad.
11:57:47 <ciaranm> neutrino: it's yellow and says that any locally small category can be embedded in Set in a nice way
11:57:57 <ciaranm> no, wait, that's the yoneda lemon
11:58:12 <Cale> > (do x <- id; y <- reverse; z <- map toUpper; return (x,y,z)) "hello"
11:58:13 <luqui> why is there no eye-roll emoticon!
11:58:14 <neutrino> haha
11:58:14 <lambdabot>   ("hello","olleh","HELLO")
11:58:27 <Cale> > (do x <- id; y <- reverse; z <- (++ y); return (x,y,z)) "hello"
11:58:32 <lambdabot>   mueval-core: Time limit exceeded
11:58:38 <Cale> wat
11:58:38 <Cale> > (do x <- id; y <- reverse; z <- (++ y); return (x,y,z)) "hello"
11:58:41 <lambdabot>   ("hello","olleh","helloolleh")
11:58:48 <OceanSpray> I like that "const" and "\_ ->" have the exact same number of characters
11:58:49 <neutrino> Cale: oh, hm
11:58:59 <shachaf> @ (\_->())
11:58:59 <ciaranm> OceanSpray: "pure" is one fewer
11:59:04 <OceanSpray> :t pure
11:59:06 <lambdabot> Applicative f => a -> f a
11:59:08 <OceanSpray> :t const
11:59:10 <lambdabot> a -> b -> a
11:59:13 <shachaf> @ty (\_->())
11:59:15 <lambdabot> t -> ()
11:59:16 <neutrino> Cale: that's pretty cool
11:59:16 <luqui> @src (->) pure
11:59:17 <lambdabot> pure = const
11:59:19 <ciaranm> > (pure 3) 4
11:59:21 <lambdabot>   3
11:59:21 <shachaf> \_-> also
11:59:24 <OceanSpray> oh rite
11:59:27 <shachaf> k is only a single character!
11:59:33 <neutrino> Cale: by the way, have you ever used HaRe or any other haskell refactoring tools?
11:59:47 <Cale> neutrino: Yeah, it's pretty straightforward to write (>>=) and such once you know what do-notation is supposed to be as well
11:59:55 <Cale> I have not used HaRe
12:00:09 <neutrino> i've looked at the paper and it has some cool things in it..
12:00:11 <Cale> I have watched a couple of demos of it being used
12:00:14 <neutrino> i wonder how modular it was made
12:00:38 <neutrino> because adding Pl and Unpl and Djinn and Hayoo to vim yielded very encouraging results
12:01:16 <neutrino> next up i'll try to extract undo from lambdabot
12:01:30 <neutrino> and put it in a command line program
12:06:30 <OceanSpray> I got "pure Nothing" all over my code now
12:06:52 <c_wraith> If you use it that much, might be worth giving it a name.
12:06:58 <c_wraith> That's shorter, that is
12:10:10 <sipa> merijn: really?
12:10:26 <sipa> oh, my screen buffer was scrolled 9 hours up
12:19:15 <Refried__> hi... why is `sequence` called `sequence`?
12:19:29 <danharaj> :t sequence
12:19:31 <lambdabot> Monad m => [m a] -> m [a]
12:19:37 <Refried__> yeah that's the one
12:19:41 <Refried__> why is it called sequence
12:19:44 <monochrom> because "sequence [a,b,c]" is do {a; b; c}
12:19:51 <Refried__> oh
12:19:52 <Refried__> thanks
12:19:55 <danharaj> not quite
12:20:03 <danharaj> :t sequence_
12:20:05 <lambdabot> Monad m => [m a] -> m ()
12:20:14 <monochrom> do {x<-a; y<-b; z<-c; return [x,y,z]}
12:20:22 <danharaj> yeah
12:20:29 <Refried__> gotcha, thanks!
12:20:52 <arbn> Most of the those names are inspired by the List example, it seems. join and mappend feel that way to me, too.
12:21:25 <Refried__> yeah I was going to ask next — where can I found it more... a lot of names are meaningless without context
12:21:28 <mapf> :t sequenceA
12:21:29 <lambdabot>     Not in scope: `sequenceA'
12:21:29 <lambdabot>     Perhaps you meant one of these:
12:21:29 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
12:21:44 <mapf> :t Data.Traversable.sequenceA
12:21:46 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
12:22:05 <Refried__> A for Applicative?
12:22:14 <mapf> any exsample then it's useful?
12:22:20 <atriq> Refried__, yes
12:22:32 <mapf> for exsample i have a tree for traversable
12:24:20 <akan01n> hi, is it possible to do this ? I need to do again the `where' clause but I dont know how, code: http://hpaste.org/77789
12:24:21 <merijn> sipa: Wait, what was that replying too? Now I'm curious :p
12:25:17 <ski> @type \f m -> Data.Foldable.mapM_ f (m `asTypeOf` Nothing)
12:25:19 <lambdabot> Monad m => (a -> m b) -> Maybe a -> m ()
12:25:41 <notdan> akan01n: and what is the error?
12:25:57 <akan01n> line 3: i have if ... then ... ; w, I need to call the where again with this w at the end.
12:26:01 <mapf> :i asTypeOf
12:26:06 <mapf> :t asTypeOf
12:26:07 <akan01n> unexpected symbol 'w'
12:26:07 <lambdabot> a -> a -> a
12:26:18 <monochrom> then do { evalExp c env; w }
12:26:47 <ski> akan01n : s/(evalExp c env) ; w/do evalExp c env ; w/
12:26:50 <akan01n> ok, let me try. thanks
12:29:50 <akan01n> doing ... then { evalExp c env ; w } this result an error, unexpected `{', possibly to due to bad layout, let me try the ski solution
12:30:18 <rwbarton> you did not copy what monochrom wrote accurately
12:30:36 <akan01n> ahnnn.. yeah.. sorry
12:31:32 <akan01n> its working now.. thanks!
12:35:43 <adimit> So… I've been trying to make an Iteratee that *flattens* a nested list (or anything ListLike/Nullable) but so far, I haven't been able to. I've pasted some code:
12:35:45 <hpaste> adimit pasted “Iteratee to flatten lists” at http://hpaste.org/77790
12:36:30 <hpaste> sonOfRa pasted “Intersection” at http://hpaste.org/77791
12:36:48 <sonOfRa> Hi. I have a question concerning the very last part of that paste. the caseDiff.
12:36:53 <adimit> but that only returns "abc". As I understand it, idone is the only way to "yield" a value, but then I don't know how to *continue*
12:37:50 <sonOfRa> It was done by another student for an exercise, and I was wondering, if I couldn't simply use the first guard as the casediff, as it should evaluate to false if the case under the second guard happens
12:39:00 <geekosaur> looks right to me
12:39:32 <sonOfRa> He claims that someone during lecture said, that there can be some problems with multiple '&&' in one statement, but I can't seem to find anything about that
12:41:40 <luqui> sonOfRa: I think you could
12:41:59 <rwbarton> for that matter just write caseDiff = (0 <= px && px <= 1) && (0 <= py && py <= 1)
12:42:06 <luqui> x | foo = True | not foo = False   is equivalent to x = foo
12:42:31 <sonOfRa> yeah, that is what I though, rwbarton, luqui
12:42:57 <rwbarton> also: x1 = fst (pointFromObj (fst pairOne)) -- etc. yuck
12:42:59 <saml> what should i blog about? give me ideas
12:43:20 <saml> i wanna learn and blog about serious stuff to get many traffic
12:43:21 <rwbarton> how about intersect (o1, o2) (o3, o4) = ... where (x1, y1) = pointFromObj o1; ...
12:43:27 <luqui> saml: modularity problems
12:43:35 <saml> let me google. thanks
12:44:05 <saml> google doesn't yield good
12:44:19 <saml> haskell modules?
12:44:37 <Jeanne-Kamikaze> you could write a monad tutorial
12:44:42 <luqui> similarities and differences between ML functors and typeclasses
12:44:46 <luqui> Jeanne-Kamikaze: lol
12:44:48 <Ralith> why would you want to blog about something that is already adequately documented by the results of one minute of googling
12:44:59 <adimit> you should wiret a blog post on how to flatten a list in an iteratee.
12:45:03 <Ralith> no, wait, that was 30 seconds
12:45:07 <Jeanne-Kamikaze> a monad tutorial for java programmers then
12:45:21 <tac> A java tutorial for monad programmers
12:45:21 <luqui> a monad tutorial for php programmers
12:45:26 <happyhippy> hi there
12:45:29 <tac> luqui: :P
12:45:34 <ion> A PHP tutorial for monad programmers
12:45:35 <luqui> a categorial perspective on perl programming
12:45:37 <saml> oh man.. give me interesting topic
12:45:38 <Ralith> a tutorial java for programming monads
12:45:41 <happyhippy> about PHP ...
12:45:42 <saml> something unique
12:45:43 <Jeanne-Kamikaze> chmod 777 Control.Monad
12:45:49 <happyhippy> I actually have a question about PHP
12:45:50 <luqui> saml: a lot of these are unique
12:45:55 <Taslem> What compiler does GHC use when you import C functions using FFI?
12:46:01 <mapf> php monads tutorial
12:46:04 <happyhippy> I have some PHP code I would like to transform to idiomatic haskell
12:46:05 <Ralith> a monad java for programming tutorials
12:46:12 <adimit> zygohistomorphic prepromorphisms for English majors!
12:46:28 <happyhippy> I feel a fold coming ... but I am not quite there yet...
12:46:37 <tac> Popular trends for blogging lately seem to be 1) Hating on Cabal, 2) Holy crap, Yesod! 3) Lens are the lenses through which programmers program functional functions, and 4) What the fuck are dependent types?
12:46:44 <Ralith> Taslem: what compiler does ghc use when you eat an apple?
12:46:58 <Taslem> Ralith: That's not helpful.
12:46:59 <edwardk> haha
12:47:05 <luqui> saml: to get people in the haskell community to like your blog, you will probably have to write about something that is interesting to haskell programmers -- i.e. not something that we all already know
12:47:17 <happyhippy>         $days = floor($seconds / (60*60*24));
12:47:17 <happyhippy>         $seconds -= $days * (60*60*24);
12:47:17 <happyhippy>         $hours = floor($seconds / (60*60));
12:47:17 <happyhippy>         $seconds -= $hours * (60*60);
12:47:17 <happyhippy>         $minutes = floor($seconds / 60);
12:47:18 <happyhippy>         $seconds -= $minutes * 60;
12:47:25 <Ralith> Taslem: your question does not make sense!
12:47:25 <parcs`> no
12:47:46 <tac> Why is it that Haskell produces exactly two kinds of publications: research papers, the highest level of human thought, and blog posts, the lowest level of human thought.
12:47:54 <tac> (scratch that, I forgot about twitter)
12:48:11 <happyhippy> so ... I start with seconds ... and want to get days ... hours ... minutes aso
12:48:14 <ciaranm> tac obviously hasn't read many research papers
12:48:17 <tac> Let's invent a FPL that reports all type errors to you via twitter.
12:48:22 <Taslem> Ralith: Using the foreign function interface, you can use GHC to compile C programs. Does GHC function as a C compiler or is it calling another program?
12:48:26 <ousado> .. and the wrong blogs
12:48:26 <lambdabot> ousado: You have 1 new message. '/msg lambdabot @messages' to read it.
12:48:37 <parcs`> Taslem: the system linker is used to link the C symbols referenced in the haskell code to the C library
12:48:45 <c_wraith> Oh, hey, anyone know offhand how the RTS interacts with native code doing interrupt-driven callbacks?
12:48:46 <happyhippy> anyone?
12:48:47 <happyhippy> : )
12:48:51 <Ralith> Taslem: how do you compile C with the FFI?
12:48:53 <tac> ousado: I'm angry from re-reading a yegge this morning about how static typing isn't good enough because it's not a silver bullet
12:49:30 <luqui> happyhippy, the way I would approach it would be to write a generalized base conversion function
12:49:39 <Taslem> Perhaps I am confused.
12:49:51 <parcs`> Taslem: oh, in that case the system c compiler is used to create an object file from the c code and then like that
12:49:55 <parcs`> link that*
12:49:57 <happyhippy> you mean base 60 would be my base?
12:50:02 <luqui> so I would use it like this:  [days, hours, minutes, seconds] = baseConvert [24, 12, 60, 60] seconds or something like that
12:50:42 <Taslem> parcs`: What exactly is the system c compiler?
12:50:53 <luqui> i haven't thought through how exactly it should work, but that would be my approach
12:50:55 <happyhippy> luqui hmmmm ... this looks great
12:51:19 <happyhippy> luqui now i will have to make it work though : )
12:51:23 <tac> luqui: did you return from the dead? I haven't seen an update on your blog in a while.
12:51:23 <luqui> :-)
12:51:26 <parcs`> Taslem: the compiler that ghc was told to use when it was built
12:51:29 <happyhippy> luqui thx for the pointer
12:51:53 <luqui> tac: yeah, i spent a few months doing music only, but i needed money so i got a programming job again, and thus my mind is active again
12:51:55 <Taslem> parcs`: How would I determine which that is?
12:51:57 <luqui> i mean programming-active
12:52:02 <kosmikus> sm, Igloo: what Igloo said about the solver and default/manual is true. although 0.14.0 had a bug in handling manual flags, which is fixed in 1.16.0
12:52:28 <parcs`> Taslem: ghc --info
12:52:32 <tac> luqui: yeah. I feel you on that. I burn out from time to time on FP, too
12:52:48 <tac> Then some jerk on Reddit mentions continuations and it's got me again.
12:53:03 <Taslem> parcs`: Thanks. Looks like MinGW/gcc
12:53:24 <luqui> nice to be here again
12:53:35 <luqui> and this channel is amazing.  you guys are so much nicer than #lisp
12:53:57 <saml> you are permanently banned from #lisp
12:53:59 <sw17ch> I like #haskell because it reminds me the Internet isn't full of jerks.
12:54:10 <saml> oh crap. i was being a jerk. sorry
12:54:16 <luqui> haha
12:55:37 <happyhippy> luqui ... this baseConvert is recursive ... right? the next iteration gets the init of the factors ((24:12:60), (24:12) ...) and in case this runs out ... we are done right?
12:56:43 <saml> baseConvert :: Integer -> [a] -> [a]  ?
12:56:43 <luqui> happyhippy: a few different ways to write it, recursive is one way
12:57:05 <saml> baseConvert 42 ['a' .. 'z']
12:57:14 <luqui> saml: probably [Integer] -> Integer -> [Integer]
12:57:44 <luqui> happyhippy: try to make it so you pull things off the head of the list instead of the end.  more idiomatic & efficient & plays nicer with infinity
12:57:46 <parcs`> :t showIntAtBase
12:57:48 <lambdabot> (Integral a, Show a) => a -> (Int -> Char) -> a -> ShowS
12:58:10 <saml> where is that method?
12:58:15 <luqui> lunchtime!
12:58:26 <tac> Haskell is hard on you. #haskell has to be nice, or else no one would use it ever.
12:58:50 <ciaranm> you say like it's a bad thing
12:59:07 <happyhippy> thank you
12:59:33 <saml> > showIntAtBase 24 (\x -> 'a') 2
12:59:35 <lambdabot>   *Exception: show: No overloading for function
12:59:59 * happyhippy playing with ghci
13:00:08 <saml> i wanna start haskell cookbook
13:00:34 <happyhippy> want to cook "pure" meals??
13:01:14 <Ralith> sometimes I cook immutable food
13:01:17 <rwbarton> what we really need IMO is hackage cookbook
13:01:23 <Ralith> it's hard to digest
13:01:53 <ciaranm> what's an okbook?
13:01:55 <happyhippy> we would be probably be better off with some infinite food structure...
13:02:11 <ciaranm> why don't you make a cogoodbook?
13:02:19 <rwbarton> Ralith: try these: http://hackage.haskell.org/package/digestive-functors
13:03:23 <nand`> tac: Haskell is very gentle :(
13:04:52 <tac> nand`: why sadface?
13:05:21 <Ralith> he wanted it to be rough
13:05:36 <nand`> because giving off the impression that Haskell is somehow harder than other languages makes me :(
13:05:43 <tac> That's what #lisp is for. All the functional programming Haskell has. None of the safewords.
13:05:55 <ciaranm> nand` likes it when his programming language chokes him like a bitch. that's why he's dating c++ on the side.
13:06:05 <fmap> is there a reason why template-haskell's Name isn't an instance of IsString with fromString = mkName?
13:06:07 <tac> nand`: blame the category theorists in the room :)
13:08:06 <sw17ch> nand`: agreed. Haskell isn't really hard unless you're only used to doing it a different way. it's no harder to learn (at least the basics) of Haskell than it was to learn the basics of most other languages.
13:08:15 <sw17ch> it was just weird to have to put effort into it again when i was learning Haskell the first time.
13:08:21 <tac> the hard parts tend to be social things, IMO.
13:08:42 <tac> The social pressure to always favor clever functional solutions when the imperative solution would do the trick.
13:08:48 <tac> (imperative meaning in IO)
13:09:32 <Ralith> so what're people's opinions of trifecta
13:09:37 * nand` thinks it's a good thing for a community to favor, clean, elegant, idiomatic code over “getting the job done”
13:09:39 <tac> cleverness should happen in response to some barrier (code doesn't scale, isn't maintainable, etc)
13:09:41 <nand`> the latter is what got us into this 21st century mess in the first place
13:09:48 <tac> for sure
13:09:54 <nand`> Ralith: my opinion is that there aren't enough blog posts about it
13:09:55 <tac> But there's a balance to be had
13:10:13 <nand`> so I can't actually formulate a proper opinion, due to not knowing the context, motivation or how to use it
13:10:14 <tac> Going full purity is a good way never to produce a working line of code.
13:10:35 <tac> Going full imperativeness is a good way to get code that works only until tomorrow.
13:10:52 <nand`> tac: I go by the maxime ‘as pure as possible, but no purer’
13:11:11 <nand`> IO stuff is kept in IO
13:11:18 <tac> I'm motivated to write about the idea of impedance mismatch and applications in functional programming.
13:12:09 <tac> Types never perfectly match your problem. It's a judgment call to decide how much unsafety is allowable in your program.
13:12:14 <edwardk> i'm fond of it for some reason
13:12:30 <Ralith> can't imagine why
13:13:17 * Ralith is quite attracted by the promise of detailed diagnostics
13:13:29 <Ralith> kitchen sinks, too!
13:13:34 <atriq> With viewpatterns, can you do something like "foo (viewl -> a :< b@(viewl -> c :< d))"?
13:13:34 <edwardk> basically trifecta gives you a form of parsec you can pile monad transformers on top of with much prettier error messages, without certain bugs that can relocate your error messages, in exchange for the cost that you have to be able to fit your entire input into memory
13:13:43 <edwardk> atriq: yes
13:13:52 <atriq> Oh, that will make my code much neater
13:13:58 <Ralith> aw, there's no support for streaming parsing?
13:14:01 <atriq> Still about as unreadable
13:14:08 <Ralith> still useful but streams are nice
13:14:10 <edwardk> not currently, but it isn't intrinsic to the design
13:14:10 <hpc> atriq: defining function composition with views?
13:14:16 <Ralith> ah
13:14:23 <Ralith> so not strictly 'in exchange for'
13:14:26 <atriq> hpc, a view pattern within a view pattern
13:14:32 <Ralith> but rather it's just not implemented
13:14:33 <edwardk> in theory a secondary parser could be provided that didn't support mark/release but offered streaming parsing
13:14:36 <atriq> :t Seq.viewl
13:14:38 <lambdabot> Seq.Seq a -> Seq.ViewL a
13:14:44 <nand`> this is why we need those generalized quasipatterns or whatever the heck they were called
13:14:55 <edwardk> i just didn't need it
13:14:59 * Ralith nod
13:15:00 <nand`> so you can just match on a :< b without needing to viewl it explicitly
13:15:08 <Ralith> one generally doesn't
13:15:24 <Ralith> but it's fun
13:15:32 <edwardk> my goal with 'parsers' was to make a framework you could define whatever parser you wanted and then use it with parsec, trifecta, attoparsec, etc. depending on your needs
13:15:40 <edwardk> @hackage parsers
13:15:40 <lambdabot> http://hackage.haskell.org/package/parsers
13:15:47 <edwardk> trifecta is switching to parsers soon
13:16:09 <edwardk> the HEAD branch is vastly simplified as a result
13:16:13 <Ralith> neat
13:16:39 <atriq> nand`, that would make "foo a = ..." ambiguous
13:16:49 <atriq> And heaven help you if the viewing function is evil
13:19:03 * hackagebot DAV 0.2 - RFC 4918 WebDAV support  http://hackage.haskell.org/package/DAV-0.2 (ClintAdams)
13:21:13 <happyhippy> luqui?
13:21:22 <happyhippy> are you there?
13:21:53 <saml> i'm here
13:21:55 <saml> ask me
13:22:01 <happyhippy> k
13:22:02 <happyhippy> baseConvert :: [Integer] -> Integer -> [Integer]
13:22:02 <happyhippy> baseConvert [] seconds = seconds : []
13:22:02 <happyhippy> baseConvert (x:xs) seconds = result : baseConvert xs remaining
13:22:02 <happyhippy>     where remaining = seconds - result * x
13:22:02 <happyhippy>           result = floor $ fromInteger seconds / fromInteger x
13:22:08 <happyhippy> this is what i got ...
13:22:19 <scp> @src foldr
13:22:19 <lambdabot> foldr f z []     = z
13:22:20 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
13:22:20 <saml> give me example input and output
13:22:26 <aninhumer> Hmm, I'm trying to work out if there's a better way to use lenses here: http://hpaste.org/77794
13:22:26 <happyhippy> but ... the list for factors is reverted to work
13:22:32 <saml> baseConvert [1] 1  ==>  ?
13:22:46 <happyhippy> baseConvert [60, 60, 24] 60
13:23:01 <saml> happyhippy,   you proabbly awnt `div` instead of /
13:23:02 <happyhippy> gives [1,0,0,0]
13:23:13 <edwardk> syncBlock = asks (syncs . ordinal ref)  -- no lens needed
13:23:18 <rAad> is there a good blogpost/article that explains what lenses are in plain english? A high level overview is fine.
13:23:41 <ski> happyhippy : (result,remaining) = seconds `divMod` x
13:23:42 <happyhippy> this is oke ... but the solution luqui mentioned has the first argument list reversed
13:23:44 <Ralith> rAad: 'a composable way to access and manipulate data structures'
13:23:53 <linduxed> ok so i've got two matrices, same size
13:24:09 <edwardk> rAad: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio check my reply there
13:24:14 <ski> > 18 `divMod` 7
13:24:15 <happyhippy> oke ...hmmm ...
13:24:16 <lambdabot>   (2,4)
13:24:20 <ski> > 19 `divMod` 7
13:24:20 <rAad> nice tx :)
13:24:22 <lambdabot>   (2,5)
13:24:24 <edwardk> that goes into a pretty good overview of what the design tradeoffs are for lenses
13:24:33 <linduxed> i want to take take the elementwise difference between the matrices, and then summarize all of those differences
13:24:43 <rAad> I see the term all the time and just wanted to know what they are
13:24:52 <rAad> still working through learn you a haskell...
13:24:55 <edwardk> its a functional 'getter/setter' pair.
13:25:14 <nand`> rAad: the christian bible has a good overview on them; something about the fruit from the tree of knowledge
13:25:21 <linduxed> so i'd take (a(1,1) - b(1,1)) + (a(2,1) - b(2,1))......
13:25:21 <happyhippy> would it be a "problem" in an idiomatic/readable way that the lists are reversed from the ones proposed by luqui?
13:25:43 <edwardk> data Lens a b = Lens { get :: a -> b, set :: a -> b -> a }  -- would be a perfectly cromulent lens you could build a library around, but i've gone in other directions for reasons explained in that reply
13:25:45 <rAad> nand`: that's a box i don't want to open
13:25:52 <linduxed> i'm getting a feeling that this could be made quite short if done right
13:26:29 <ciaranm> is there a good blog post / article that explains what lenses are in abstract nonsense? higher categories are fine
13:27:02 <rAad> more symbols the better
13:27:15 <edwardk> ciaranm: my talk, which will be next month in NYC will spend quite a bit of time deriving them from first principles and laws
13:27:39 <nand`> ciaranm: they can be seen as natural transformations between state monads
13:27:46 <ciaranm> edwardk: how near to LA is NY?
13:27:53 <ciaranm> edwardk: also when next month?
13:28:08 <edwardk> ciaranm: clearly you should have gone to the talk i did last month in san francisco ;)
13:28:19 <edwardk> the 12th. sclv was sending out the announcement just now
13:28:38 <ciaranm> i'm only going to be in the US for a few days :(
13:28:49 <edwardk> ah
13:28:55 <sclv> We will have video for this one :-)
13:28:58 <edwardk> well, fly me out somewhere and i'll do a lens talk ;)
13:29:06 <edwardk> i like to talk
13:29:17 <ciaranm> heh. maybe next year when i have MILLIONS OF POUNDS OF FUNDING
13:30:03 <happyhippy> saml good point ... this doesnt make sense ... baseConvert [1] 1 .....
13:30:27 <happyhippy> ski quite short ... thx :-)
13:30:43 <saml> > let bc alphabet base10 = let base = length alphabet; (x,i) = base10 `divMod` base; d = alphabet !! i in if x == 0 then [d] else d : bc alphabet x in bc ['a' .. 'z'] 2343
13:30:45 <lambdabot>   "dmd"
13:32:19 <saml> you have to reverse it actually
13:33:43 <saml> no .. i'm wrong
13:37:17 <nand`> > replicateM 3 ['a'..'z'] !! 2343
13:37:18 <lambdabot>   "dmd"
13:37:31 <atriq> That was an unexpected result
13:37:56 <saml> how can I recursively apply divMod  to an integer?
13:38:04 <saml> > scanl (\(x,i) -> x divMod 10) 3 [34]
13:38:06 <lambdabot>   Occurs check: cannot construct the infinite type:
13:38:06 <lambdabot>    t0 = b0 -> ((a0 -> a0 ...
13:39:18 <nand`> > let bc a n = replicateM (ceiling $ logBase (genericLength a) n) a !! n in bc ['a'..'z'] 2343
13:39:20 <lambdabot>   No instance for (GHC.Float.Floating GHC.Types.Int)
13:39:20 <lambdabot>    arising from a use of...
13:39:30 <nand`> > let bc a n = replicateM (ceiling $ logBase (genericLength a) (fromIntegral n)) a !! n in bc ['a'..'z'] 2343
13:39:32 <lambdabot>   "dmd"
13:39:49 <nand`> not particularly pretty though
13:40:00 <saml> when do you use scanl?
13:40:16 <atriq> > replicateM 5 ['a'..'z'] !! 345660
13:40:18 <lambdabot>   "atriq"
13:40:34 <parcs`> saml: when the intermediate values of a fold are important to you
13:40:36 <nand`> when you want to iteratively generate sequences by accumulating
13:40:46 <nand`> for example, the fibonacci sequence makes an idea candidate
13:40:54 <tac> @type scanl
13:40:56 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
13:41:03 <dgpratt> I started a discussion the other day on r/haskell about 'the cabal problem' and Simon Marlow chimed in to say this: "GHC does attach the package name, version, and module name to every symbol"
13:41:04 <nand`> oh, I guess it's more general than that
13:41:06 <tac> scanl is the recursor on lists, isn't it?
13:41:09 <nand`> mine was just an example
13:41:11 <saml> how does replicateM work?
13:41:22 <nand`> > let fibs = scanl (+) 0 (1 : fibs) in fibs
13:41:24 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
13:41:27 <saml> > replicateM 3 ['0' .. '9'] !! 3435
13:41:29 <lambdabot>   "*Exception: Prelude.(!!): index too large
13:41:32 <dgpratt> his comment didn't get a lot of reaction, so I suppose this is old news, but I was very surprised
13:41:46 <ski> @src replicateM
13:41:46 <lambdabot> replicateM n x = sequence (replicate n x)
13:42:00 <saml> oh man too terse
13:42:10 <ski> it's the list monad
13:42:19 <nand`> > replicateM 4 ['0'..'9') !! 3435
13:42:21 <lambdabot>   <hint>:1:23: parse error on input `)'
13:42:24 <nand`> > replicateM 4 ['0'..'9'] !! 3435
13:42:26 <lambdabot>   "3435"
13:42:39 <nand`> > replicateM 50 ['0'..'9'] !! 3435
13:42:41 <lambdabot>   "00000000000000000000000000000000000000000000003435"
13:43:22 <ski> saml : `sequence [act0,act1,act2] = do val0 <- act0; val1 <- act1; val2 <- act2; return [val1,val2,val3]'
13:43:44 <saml> oh i see
13:43:53 <saml> replcate 3 'a' ==> "aaa"
13:44:14 <nand`> there must be some super elegant way to define a function like f "01" = ["0","1","10","11","100","101", ...]
13:44:16 <ski> saml : `replicateM 3 "abc"  =  sequence (replicate 3 "abc")  =  sequence ["abc","abc",abc"]  =  do val0 <- "abc"; val1 <- "abc"; val2 <- "abc"; return [val1,val2,val3]'
13:44:17 <dgpratt> in light of this, I don't understand why some folks are trying to identify internal vs external package dependencies
13:44:20 <saml> replicateM 3 ['0' .. '9'] ==> "012..9012...9012..9"
13:44:24 <ski> > do val0 <- "abc"; val1 <- "abc"; val2 <- "abc"; return [val1,val2,val3]
13:44:25 <lambdabot>   Not in scope: `val3'
13:44:26 <lambdabot>  Perhaps you meant one of these:
13:44:26 <lambdabot>    `val0' (line 1), `...
13:44:29 <ski> er
13:44:34 <ski> > do val0 <- "abc"; val1 <- "abc"; val2 <- "abc"; return [val0,val1,val2]
13:44:37 <lambdabot>   ["aaa","aab","aac","aba","abb","abc","aca","acb","acc","baa","bab","bac","b...
13:44:58 <saml> what is this?
13:45:03 <saml> is this list monad specific?
13:45:06 <saml> all permutation?
13:45:07 <nand`> yes
13:45:07 <ski> yes
13:45:12 <ski> > do val0 <- "ab"; val1 <- "ab"; val2 <- "ab"; return [val0,val1,val2]
13:45:14 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
13:45:23 <nand`> well, replicateM isn't
13:45:34 <nand`> > replicateM 3 (Just "foo")
13:45:36 <lambdabot>   Just ["foo","foo","foo"]
13:45:38 <nand`> > replicateM 3 Nothing
13:45:40 <lambdabot>   Nothing
13:45:42 <ski> > [[val0,val1,val2] | val0 <- "ab" , val1 <- "ab" , val2 <- "ab"]
13:45:44 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
13:45:50 * saml googles for list monad
13:46:24 <saml> oh i see
13:46:34 <saml> it's like for expression in scala
13:46:39 <ski> saml : in the list monad, `do x <- list; ..x..' means : take each element `x' of `list', and compute a list of each corresponding `do ..x..' result
13:46:56 <nand`> I can't show it here, but in GHCi you could try ‘replicateM 3 getLine’
13:46:58 <ion> In Monad [], (=<<) = concatMap
13:47:05 <ski> > do c <- "ab"; n <- "012"; return [c,n]
13:47:07 <lambdabot>   ["a0","a1","a2","b0","b1","b2"]
13:47:20 <ski> > [[c,n] | c <- "ab" , n <- "012"]
13:47:21 <lambdabot>   ["a0","a1","a2","b0","b1","b2"]
13:47:25 <saml> so replicateM  is for repeating stuff n times
13:47:31 <ski> yes :)
13:47:31 <saml> like a loop
13:47:35 <saml> for loop
13:47:35 <nand`> yes, and sequencing
13:47:49 <tromp> > replicateM 2 "foo"
13:47:51 <ion> > map (\a -> map (\b -> map (\c -> [a,b,c]) "ab") "ab") "ab"
13:47:51 <lambdabot>   ["ff","fo","fo","of","oo","oo","of","oo","oo"]
13:47:52 <lambdabot>   [[["aaa","aab"],["aba","abb"]],[["baa","bab"],["bba","bbb"]]]
13:48:11 <ion> > concatMap (\a -> map (\b -> map (\c -> [a,b,c]) "ab") "ab") "ab"
13:48:13 <lambdabot>   [["aaa","aab"],["aba","abb"],["baa","bab"],["bba","bbb"]]
13:48:20 <ion> > concatMap (\a -> concatMap (\b -> concatMap (\c -> [a,b,c]) "ab") "ab") "ab"
13:48:22 <lambdabot>   "aaaaababaabbbaababbbabbb"
13:48:41 <nand`> that was probably one too many
13:48:41 <ion> Forgot “return”.
13:48:46 <nand`> oh, or that
13:48:46 <ion> return a = [a]
13:48:48 <saml> so you guys don't have a problem of reading  replicateM 3 ['0' .. '9'] !! 343
13:48:59 <ion> > let myReturn a = [a] in concatMap (\a -> concatMap (\b -> concatMap (\c -> myReturn [a,b,c]) "ab") "ab") "ab"
13:49:01 <lambdabot>   ["aaa","aab","aba","abb","baa","bab","bba","bbb"]
13:49:02 <saml> i just need to get used to available functions and idioms
13:49:14 <nand`> I know from experience that ‘replicateM’ in [] generates combinations
13:49:15 <saml> it took me a long time and help of you to understand what that expression did
13:49:16 <ski>   replicateM 3 (putStrLn "foo")  =  do u0 <- putStrLn "foo"; u2 <- putStrLn "foo"; u2 <- putStrLn "foo"; return [u0,u1,u2]
13:49:19 <ski>                                  =  do () <- putStrLn "foo"; () <- putStrLn "foo"; () <- putStrLn "foo"; return [(),(),()]
13:49:21 <nand`> so the rest is pretty clear
13:49:35 <ski>   replicateM_ 3 (putStrLn "foo")  =  do putStrLn "foo"; putStrLn "foo"; putStrLn "foo"; return ()
13:49:48 <nand`> I think it would in theory be fine code; but in this case I don't like it because of the ugly ‘3’
13:50:03 <saml> nand`, how did you come up with taking list !! i   will give you base conversion?
13:50:27 <saml> list  is combinations of alphabet replicated
13:50:43 <ski> saml : .. well, `(!!)' suggests you're using lists when you shouldn't
13:51:02 <saml> ski what do you mean?
13:51:05 <saml> i should never use !!?
13:51:15 <saml> i mean.. not never.. but !! is anti-pattern?
13:51:36 <ski> lists are for accessing elements in a sequential fashion, one after another
13:51:40 <ion> If you need to get an element by an index, you shouldn’t use a data structure for which that is an O(i) operator.
13:51:42 <ion> operation
13:51:48 <saml> ah i see
13:51:49 <ski> if you want random access, there's better data structures available
13:52:06 <nand`> saml: because due to the way the combinations are generated, the resulting list (of replicateM) is effectively counting up; so if you're starting at 0 ("aaa"), which is the 0th element in the list; you can just count ‘n’ elements to get to the nth combination, or the combination representing the number n
13:52:49 <ski> saml : however, often newbies use `!!' when they could just as well (with more experience) have accessed the list sequentially
13:53:08 <nand`> the same way that ["zero", "one", "two", "three", ...] !! n will get the name for the number n
13:53:25 <ski> (presumably they do so because they're thinking of lists like of arrays in other languages)
13:53:50 <saml> nand`, ah that makes sense
13:54:13 <saml> so, would you write base conversion that way?
13:54:27 <saml> !! makes sense with replicateM  to convert base
13:54:37 <ion> Still O(n)
13:54:40 <linduxed> > let a = [[1,2,3,4,5],[2,3,4,5,6]]
13:54:42 <lambdabot>   not an expression: `let a = [[1,2,3,4,5],[2,3,4,5,6]]'
13:54:47 <saml> hrm.. base conversion is log n, right?
13:54:52 <ski> better to use `divMod' for base conversion
13:55:01 <linduxed> > a = [[1,2,3,4,5],[2,3,4,5,6]]
13:55:03 <lambdabot>   <hint>:1:3: parse error on input `='
13:55:11 <nand`> saml: I wouldn't, no
13:55:13 <linduxed> errrm
13:55:17 <andsens> I am writing a function which seems oddly familiar, but I can't find anything on it: https://gist.github.com/4081575
13:55:18 <atriq> What's so bad about Monad Comprehensions?
13:55:26 <geekosaur> what do you think you;re trying to do, linduxed?
13:55:29 <nand`> atriq: I guess the [ ] syntax
13:55:34 <nand`> but other than that; I don't see anything wrong with them
13:55:36 <ski> @let linduxed's_a = [[1,2,3,4,5],[2,3,4,5,6]]
13:55:38 <lambdabot>  Defined.
13:55:43 <simpson> atriq: I don't think anybody in here feels that monad comprehensions are bad as-is.
13:55:49 <ski> > sequence linduxed's_a
13:55:50 <linduxed> geekosaur: just store one [[Int]]
13:55:51 <lambdabot>   [[1,2],[1,3],[1,4],[1,5],[1,6],[2,2],[2,3],[2,4],[2,5],[2,6],[3,2],[3,3],[3...
13:56:01 <linduxed> omg?
13:56:09 <ion> > unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) 12345
13:56:10 <simpson> andsens: Well, that kind of function can't be total, right?
13:56:11 <lambdabot>   [5,4,3,2,1]
13:56:13 * ski has no idea what linduxed wanted to do with that list
13:56:18 <ion> > unfoldr (\n -> swap (n `quotRem` 2) <$ guard (n /= 0)) 12345
13:56:19 <lambdabot>   [1,0,0,1,1,1,0,0,0,0,0,0,1,1]
13:56:20 <andsens> Something tells me I need the identity
13:56:32 <ski> > transpose linduxed's_a
13:56:33 <geekosaur> andsens, see "maybe"
13:56:34 <lambdabot>   [[1,2],[2,3],[3,4],[4,5],[5,6]]
13:56:35 <andsens> simpson: No, and it isn't working yet :-)
13:56:40 <atriq> :t maybe
13:56:41 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:56:50 <simpson> andsens: Well, why do you want something with that type?
13:57:05 <andsens> I want it for two different operations
13:57:22 <atriq> :t \m f c -> maybe c (`f` c) m
13:57:22 <andsens> prepend a Maybe to a list and prepend something to a maybe list
13:57:24 <lambdabot> Maybe a -> (a -> b -> b) -> b -> b
13:58:06 <nand`> :t \c -> fromMaybe c .: fmap
13:58:07 <andsens> which is why I need the c
13:58:11 <lambdabot> b -> (a -> b) -> Maybe a -> b
13:58:24 <simpson> :t maybeToList
13:58:26 <lambdabot> Maybe a -> [a]
13:58:30 <andsens> I don't know if the return type is in the maybe or not
13:58:30 <shachaf> @ty flip (flip . foldr) . maybeToList
13:58:32 <lambdabot> Maybe a -> (a -> c -> c) -> c -> c
13:58:33 <rwbarton> atriq: any time you have MonadComprehensions on but you just want to use an ordinary list comprehension you pay a price in how easy your program is to understand
13:58:38 <ion> > unfoldr (\n -> swap (n `quotRem` 16) <$ guard (n /= 0)) 0x1234abcd
13:58:39 <lambdabot>   [13,12,11,10,4,3,2,1]
13:58:42 <rwbarton> atriq: they also don't gain you much over do notation
13:59:02 <atriq> Okay
13:59:17 <andsens> simpson: Yest the maybeToList would solve one part
13:59:19 <rwbarton> atriq: I saw a benchmark where with MonadComprehensions enabled some code using list comprehensions was 2-3x as slow
13:59:19 <shachaf> It would be nice if monad comprehensions translated to Applicative.
13:59:31 <shachaf> They have the implicit "return", unlike do-notation.
13:59:39 <Sonarpulse> I want to create a typeclass instance for [[Char]]. Without using ghc extensions is my only choice to wrap [[Char]] in an a data structure?
13:59:39 <shachaf> Which would make it a bit more reasonable to do it.
13:59:51 <nand`> rwbarton: would gratuitous applications of SPECIALIZE help?
14:00:01 <rwbarton> maybe... I didn't investigate
14:00:02 <shachaf> Sonarpulse: You can do what Text.Printf does.
14:00:09 <Sonarpulse> what is that?
14:00:21 <rwbarton> but I'm pretty sure the monad comprehension was used monomorphically at []
14:00:23 <shachaf> class IsChar a where fromChar :: Char -> a; toChar :: a -> Char
14:00:27 <ski> shachaf : perhaps using "parallel list comprehension" syntax ?
14:00:28 <atriq> rwbarton, yuck
14:00:44 <rwbarton> shachaf: you mean magically if you don't break the "applicative scoping rules"?
14:00:46 <nand`> then that seems a bit odd; I would expect monad comprehensions that are known to be in [] to just straight up desugar like the normal list comprehensions
14:01:00 <shachaf> rwbarton: Which rules?
14:01:10 <shachaf> You mean not doing things like [... | x <- y, z <- x]?
14:01:19 <rwbarton> yes
14:01:28 <rwbarton> that rule :)
14:01:28 <shachaf> Yes, it would have to be restricted.
14:01:43 <shachaf> Though ski's suggestion might work...
14:01:46 <rwbarton> or (if Applicative were a superclass of Monad, ha ha) it could "just work"
14:01:53 <Sonarpulse> chaf? so i create a datatype and make a "from[[Char]]" ?
14:01:57 <ion> rwbarton: Indeed :-)
14:02:04 <nand`> parallel comprehensions is MonadZip, no?
14:02:08 <Sonarpulse> *shachaf
14:02:14 <shachaf> rwbarton: Right, the suggestion is assuming a reasonable hierarchy.
14:02:22 <shachaf> Sonarpulse: Not sure exactly what you're doing.
14:02:27 <rwbarton> yeah, so it could use Monad if necessary, and Applicative if not
14:02:29 <shachaf> Look at Text.Printf for inspiration.
14:02:44 <ski> > getZipList (liftA2 (+) (ZipList [0,1,2]) (ZipList [200,100,000]))
14:02:44 <ski> > [a + b | a <- [0,1,2] | b <- [200,100,000]]
14:02:46 <lambdabot>   [200,101,2]
14:02:46 <lambdabot>   can't find file: L.hs
14:02:51 <ski> > [a + b | a <- [0,1,2] | b <- [200,100,000]]
14:02:52 <lambdabot>   [200,101,2]
14:02:57 <simpson> Sonarpulse: Which typeclass are you trying to make an instance for?
14:03:02 <Sonarpulse> I am implementing Binary (as usuall :)
14:03:07 <saml> is there something like  until but gives list?
14:03:12 <shachaf> I guess ParallelListComprehensions already have the correct scoping.
14:03:27 <shachaf> rwbarton: This could make for nice Applicative syntax, except for the "guard" part of list comprehensions.
14:03:28 <nand`> does ZipList still now have a Show instance?
14:03:29 <saml> (a -> Bool) -> (a -> a) -> a -> [a]
14:03:30 <nand`> still not*
14:03:33 <mroman> saml: scanl?
14:03:34 <Sonarpulse> Somebody designed a basic datastructure of back-to-back CStrings and some meta data at type
14:03:37 <shachaf> I guess you can always use _ <-
14:03:45 <ski> > getZipList (liftA3 id (ZipList [(+),(*),(^)]) (ZipList [0,1,2]) (ZipList [200,100,000]))
14:03:45 <rwbarton> guard can be ApplicativeZero or whatever class we are making up
14:03:47 <lambdabot>   [200,100,1]
14:03:55 <Sonarpulse> I have written the instance to (de)serialize it all the way to a linked list of strings
14:03:56 <rwbarton> while we're daydreaming
14:03:59 <ski> > [f a b | f <- [(+),(*),(^)] | a <- [0,1,2] | b <- [200,100,000]]
14:03:59 <mroman> hm no.
14:04:01 <lambdabot>   [200,100,1]
14:04:06 <mroman> @src until
14:04:06 <lambdabot> until p f x | p x       = x
14:04:06 <lambdabot>             | otherwise = until p f (f x)
14:04:10 <rwbarton> can use it for failed pattern matches also
14:04:28 <shachaf> Sure, but it's not a nice default for most Applicative-syntaxed things. Maybe.
14:04:33 * shachaf may not be making any sense.
14:04:38 <mroman> saml: iterate
14:04:50 <rwbarton> there's that ado quasiquoter on hackage
14:04:52 <ski> rwbarton : though for "Monad if necessary, and Applicative if not", we really want `Monad m' to imply `Applicative m'
14:04:52 * shachaf considers how Applicative comprehension notation would look for, say, parsers.
14:05:01 * nand` just mistyped MonadZip on hoogle as ‘MonadZap’
14:05:10 <mroman> > takeWhile (<=128) $ iterate (*2) 2
14:05:11 <lambdabot>   [2,4,8,16,32,64,128]
14:05:31 <mroman> > until (>=128) (*2) 2
14:05:33 <lambdabot>   128
14:05:36 <shachaf> rwbarton: Also I want Applicative-without-pure to be a superclass of Applicative.
14:05:40 <shachaf> Can we add that to the daydream?
14:05:49 <nand`> shachaf: [f x | _ <- foo, x <- something, _ <- bar ] ?
14:05:55 <mroman> Is that what you were looking for?
14:05:55 <saml> mroman, thanks
14:05:57 <rwbarton> sure
14:05:58 <shachaf> nand`: Yep.
14:06:01 <rwbarton> the dream is extensible
14:06:19 <nand`> I think I prefer f <$ foo <*> something <* bar for that particular example
14:06:21 <shachaf> nand`: Or [f x | _ <- foo | x <- something | _ <- bar] with ski's notation.
14:06:38 <rwbarton> oh i get what you are saying about the guard stuff now
14:06:54 * nand` wonders if there's a sensible instance of MonadZip other than [] out there
14:07:01 <nand`> ...and ZipList :)
14:07:11 <atriq> ZipList... isn't a Monad?
14:07:25 <shachaf> It's not.
14:07:25 <nand`> oh, yes, you're right
14:07:26 * ski isn't sure `[f x | _ <- foo | x <- something | _ <- bar]' would be preferable to `[f x | _ <- foo, x <- something, _ <- bar ]' ..
14:07:46 <atriq> Vector could be, I think
14:08:04 <ski> i thought `ZipList' was a monad -- in a sortof sneaky way ?
14:08:11 <rwbarton> @type ?f <$ ?foo <*> ?something <* ?bar
14:08:13 <lambdabot> (?f::a1 -> a, ?foo::f b1, ?something::f a1, ?bar::f b, Applicative f) => f a
14:08:18 <andsens> Do you know of any functions have the type signature: Maybe a -> [a] -> [a]. Hoogle is no help. I am looking for a "prependMaybe"
14:08:19 <rwbarton> @type ?f <$> ?foo *> ?something <* ?bar
14:08:22 <lambdabot> (?f::a2 -> a1, ?foo::f a2, ?something::f a, ?bar::f b, Applicative f) => f a
14:08:38 <rwbarton> ski, that turned out to be a lie
14:08:45 <nand`> ski: I thought that for a while as well, apparently that still isn't the case
14:08:55 <rwbarton> at least for the sneaky way I heard about
14:08:56 <ski> ok, so how does it fail ?
14:09:08 <rwbarton> quickcheck can tell you
14:09:27 <rwbarton> or maybe dolio :)
14:09:36 <rwbarton> I forget the details
14:09:50 <ski> with `ma :: ZipList a; amb :: a -> ZipList b', then given `fmap amb ma :: ZipList (ZipList a)' we want `join :: ZipList (ZipList a) -> a' -- the "obvious" way it to take the diagonal -- but this fails the associativity law, iirc
14:10:10 <simpson> :t \ma xs -> case ma of { Maybe x -> x:xs; _ -> xs } -- andsens
14:10:12 <lambdabot> Not in scope: data constructor `Maybe'
14:10:19 <simpson> :t \ma xs -> case ma of { Just x -> x:xs; _ -> xs } -- derp
14:10:21 <lambdabot> Maybe a -> [a] -> [a]
14:10:27 <ski> before including an element on the diagonal in the result, one can make sure that the column "above" it exists -- and this i heard claimed would work
14:11:07 <nand`> :t (++) . listToMaybe
14:11:07 <jmcarthur> ski: taking the diagonal does work if you have a guarantee that all the lists have the same length
14:11:08 <lambdabot> Monoid a => [a] -> Maybe a -> Maybe a
14:11:22 <ski> jmcarthur : yes, i know. i'm expressly not assuming that
14:11:25 <nand`> uh
14:11:26 <jmcarthur> okay
14:11:30 <nand`> :t (++) . maybeToList
14:11:32 <lambdabot> Maybe a -> [a] -> [a]
14:11:35 <andsens> Thanks simpson, a lambda is nice. I just hope it maybe was included in prelude or something, too bad.
14:11:41 <ski> (`(^ n)' is a monad, for any natural number `n')
14:11:45 <simpson> andsens: I like nand` 's approach.
14:11:58 <simpson> andsens: Also no, there are many simple combinators not in the Prelude simply because.
14:12:07 <shachaf> ski: And also for unnatural numbers!
14:12:08 <mapf> matrices are morphisms?
14:12:12 <shachaf> Like fix Succ.
14:12:34 <ciaranm> mapf: linear mappings are morphisms
14:12:56 <mapf> ciaranm: i don't familiar with linear mappings
14:12:57 <ciaranm> unless you're talking about that funky category where the objects are all matrices
14:13:28 <ski> shachaf : how about the supernaturals ?
14:13:49 <shachaf> ski: How about us?
14:13:51 <andsens> band`: That's kinda cool. Should I be concerned about using ++ instead of : in this case?
14:13:56 <andsens> *nand`
14:14:04 * hackagebot alpha 0.999 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.999 (MarcCoiffier)
14:14:14 <ski> mapf : matrices correspond to linear transformations between finite-dimensional vector spaces
14:14:18 <hpaste> “Ben Gamari” pasted “Stack overflow (yes, another)” at http://hpaste.org/77795
14:14:29 <Sonarpulse> ok, well doesn anybody know how to make emacs start ghci with some extensions availible?
14:14:36 <bgamari> Does anyone see the stack overflow in the above?
14:14:41 <bgamari> It's a full test case
14:14:56 <bgamari> I swear this code used to work; nothing changed but now it overflows
14:15:05 <mapf> ski: ok, yes. i find out that i don't familiar with english termins
14:15:11 <bgamari> (nothing changed other than the dependent libraries rather)
14:15:24 <ski> shachaf : you are a member of <http://en.wikipedia.org/wiki/Supernatural_numbers> ?
14:15:48 <shachaf> ski: Oh, that's a thing.
14:16:04 <happyhippy> saml and ski ... finally desired behaviour
14:16:06 <bgamari> The state should be state, although forcing both the put and return arguments doesn't seem to help
14:16:26 <mapf> it's even possible to express it in haskell with type level arithemic
14:16:27 <ski> happyhippy : ok ?
14:16:32 <happyhippy> baseConvert'' :: [Integer] -> Integer -> [Integer]
14:16:32 <happyhippy> baseConvert'' [] number = [number]
14:16:33 <happyhippy> baseConvert'' (x:xs) number = result : baseConvert'' xs remainder
14:16:33 <happyhippy>     where (result, remainder) = number `divMod` product (x:xs)
14:16:39 <ski> @paste
14:16:39 <lambdabot> Haskell pastebin: http://hpaste.org/
14:16:50 <nand`> andsens: hardly; [a] ++ xs is practically the same as a : xs
14:16:50 <happyhippy> oh... paste?
14:17:03 <ski> happyhippy : you can use that for pasting long snippets of code
14:17:18 <happyhippy> ah ... ok :-)
14:17:23 <happyhippy> thanks
14:17:51 <nand`> andsens: just needs two pattern matches; one for a : xs and then one for []
14:18:12 <happyhippy> ski : this version of baseConvert does what I wanted to achieve ... generating a list wanted thanks
14:18:13 <ski> happyhippy : the first argument is a list of bases for each desired digit ?
14:18:43 <ski> @let baseConvert'' [] number = [number]; baseConvert'' (x:xs) number = result : baseConvert'' xs remainder where (result, remainder) = number `divMod` product (x:xs)
14:18:44 <lambdabot>  Defined.
14:18:53 <andsens> ah, of course. ++ uses :
14:18:54 <merijn> Sonarpulse: You can make a .ghci file in your home dir and ghci will execute the commands in there on startup. That includes enabling extensions
14:18:57 <happyhippy> ski : well the problem is that I want (based on the total amout of seconds between two dates) to extract the amount of days inbetween
14:19:00 <shachaf> ski: What about the hypernaturals?
14:19:30 <nand`> shachaf: hypernaturals? Is that ℕ with infinity?
14:19:35 <monochrom> bgamari: it's just mapM. to wit, try Control.Monad.Trans.State.Lazy. yes, this will mess with your mind!
14:19:42 <happyhippy> ski : luqui came up with the baseConvert functio name : )
14:19:45 * nand` has only heard of the hyperreals, ℝ with infinity and 1/infinity
14:19:59 <Sonarpulse> thanks
14:20:04 <shachaf> nand`: That's not really what the hyperreals are.
14:20:10 <Sonarpulse> and how does {#- ... } work?
14:20:16 <shachaf> I mean, they have infinite and infinitesimal values, but not just one of each.
14:20:16 <ciaranm> MAGIC
14:20:17 <happyhippy> ski : so ... I am not sure if  the first argument is a list of bases for each desired digit ...
14:20:25 <Sonarpulse> isn't that a better way to do extensions ( i just realized)
14:20:52 <bgamari> monochrom, oh man, yep, it no longer crashes with lazy. It takes quite a bit of memory, but that's probably expected for this testcase
14:20:58 <ski> happyhippy : i was hoping you knew what function you wanted to write :)
14:20:58 <merijn> Sonarpulse: You mean "{-# LANGUAGE extensionhere #-}"?
14:20:59 <bgamari> we'll see what happens in the real code
14:21:02 <Sonarpulse> yeah
14:21:06 <tomeo> Why doesnt this list comprehension terminate once x > 10? [x | x <- [1..], x < 10]
14:21:12 <Sonarpulse> I just tried{-# LANGUAGE TypeSynonymInstances #-}
14:21:13 <merijn> Sonarpulse: Yeah, for modules that's the best way
14:21:14 <Sonarpulse> and it didn't work
14:21:32 <ski> tomeo : because it doesn't know that there'll not be any number less than ten later in the list
14:21:41 <happyhippy> ski : well ... I wanted a functional equivalent of a imperative code snippet ...
14:21:42 <nand`> shachaf: well, aren't all infinitesimals in *ℝ representable by ‘n + 1/infinity’ for some n∈ℝ ?
14:21:48 <Sonarpulse> for reference, ghci in the error message told me : "Use -XTypeSynonymInstances if you want to disable this.)"
14:21:52 <tomeo> ski: is there any way to tell a list comprehension to terminate in case something happens?
14:21:53 <Cale> tomeo: Because there might be more elements of [1..] which are less than 10, which it can't prove isn't the case
14:21:55 <ski> happyhippy : computing *what* ? :)
14:22:02 <simpson> > [x | x <- [1..], x < 10]
14:22:06 <rwbarton> bgamari: you can convince yourself that this has nothing to do with vector at all by replacing the whole body of f with 'get'
14:22:06 <lambdabot>   mueval-core: Time limit exceeded
14:22:07 <merijn> Sonarpulse: What do you mean by "didn't work"?
14:22:11 <atriq> Sonarpulse, :set -XTypeSynonymInstances
14:22:12 <ski> tomeo : not really .. you can use `takeWhile' instead
14:22:15 <simpson> Aw, it doesn't return any of the first ones.
14:22:16 <rwbarton> in fact, you never examine any vectors in your test case
14:22:20 <shachaf> nand`: What's "1/infinity"?
14:22:21 <saml> how can I takeUntil ?
14:22:22 <ski> > takeWhile (< 10) [1 ..]
14:22:24 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:22:37 <parcs`> > 1 / (1/0)
14:22:38 <lambdabot>   0.0
14:22:45 <ski> @let takeUntil p = takeWhile (not . p)
14:22:47 <lambdabot>  Defined.
14:22:53 <ski> > takeUntil (>= 10) [1 ..]
14:22:55 <merijn> Sonarpulse: Enabling the extension in a module like that will make ghci accept the module code, but trying to use extension enabled things on the ghci prompt will complain if you don't also enable it in ghci
14:22:56 <lambdabot>   [1,2,3,4,5,6,7,8,9]
14:22:57 <nand`> “a number greater than 0 but smaller than any real number > 0” ?
14:23:02 <rwbarton> 0, but a little bigger
14:23:10 <Sonarpulse> I put {-# LANGUAGE TypeSynonymInstances #-} in the module
14:23:12 <nand`> (I should probably just sleep now)
14:23:20 <Sonarpulse> I didn't :set anything or modify .ghci
14:23:21 <shachaf> nand`: OK, let's start with "what's infinity?".
14:23:22 <merijn> IEEE754 says 0, apparently
14:23:37 <merijn> Sonarpulse: Before the "module Foo where" line?
14:23:38 * ski . o O ( `{-# LANGUAGE SyntheticDifferentialGeometry #-}' )
14:23:39 <nand`> shachaf: “a number larger than any real number” ?
14:23:47 <Sonarpulse> oh :D
14:23:59 <saml> i want to takeWhile   but include that element where predicate returns false
14:24:00 <happyhippy> ski : http://hpaste.org/77797
14:24:03 <merijn> Sonarpulse: extensions pragma's should go before the module line
14:24:25 <Sonarpulse> ok
14:24:28 <Sonarpulse> now it's working
14:24:32 <Sonarpulse> but i'll need FlexibleInstances
14:24:34 <Sonarpulse> too
14:24:39 <happyhippy> ski : this was the original code I wrote quite some time ago ... and I was wondering how to do the calculation in a functional way ... preferably haskell ;-P
14:24:43 <nand`> that definition doesn't capture any properties outside of ordering, though
14:24:49 <nand`> so it's not very useful
14:24:51 <Sonarpulse> ok works
14:24:53 <shachaf> nand`: That's not really how the hyperreals work, unless I'm wrong.
14:24:57 <merijn> Sonarpulse: Because some extensions affect the parsing and what syntax is valid, so GHC needs to know before parsing the module
14:25:10 <Sonarpulse> but I feel like a sinner enabling all these
14:25:17 <Sonarpulse> thanks for the help and rational
14:25:22 <bgamari> rwbarton, that is true, I suppose I don't
14:25:25 <Sonarpulse> that makes a lot of sense
14:25:28 <shachaf> Though maybe you could make it work by letting infinity be some particular infinite hyperreal?
14:25:29 <merijn> Sonarpulse: FlexibleInstances is fine, the haskell standard is awfully uptight about what it considers valid instance definitions
14:25:37 <happyhippy> ski : so ... how would you name it if I may ask? : )
14:25:38 <bgamari> I guess I'm just never ran into this failing case
14:25:52 <bgamari> Unfortunately it seems the real code still overflows, even with a lazy state
14:25:54 <Sonarpulse> and the moral support too then :D
14:25:57 <merijn> Sonarpulse: I think FlexibleInstances is one the least controversial extensions :)
14:25:58 <nand`> shachaf: yes, that was the idea
14:26:02 <bgamari> so it looks like my test case isn't quite right
14:26:06 <nand`> but you're right; hyperreal contains multiple infinities
14:26:19 <LambdaDusk> I just updated my cabal-install to 1.16.0.2 and all I get now is "Command.optionToFieldDescr: feature not implemented"... any tips there?
14:26:20 <monochrom> mapM is expensive
14:26:23 <nand`> there being defined as a number greater than anything of the form ”1+1+1+1+1....+1”
14:26:35 <merijn> Sonarpulse: http://stackoverflow.com/questions/10845179/which-haskell-ghc-extensions-should-users-use-avoid
14:27:08 <shachaf> nand`: SO for example (infinity * 2) /= infinity
14:27:12 <shachaf> s/O/o/
14:27:25 <bgamari> monochrom, apparently
14:27:31 <bgamari> monochrom, Do you see any better approach here?
14:27:44 <merijn> Sonarpulse: That gives a nice list of which extensions are considered good, etc. Although some of those entries are contested, most people seem to agree with the majority of the list
14:27:53 <ciaranm> why isn't the MonadPlus instance for [] what i want it to be?
14:28:01 <sclv> omg brent's factor diagrams killing it on proggit
14:28:06 <sclv> haskell ftw
14:28:13 <jmcarthur> ciaranm: what do you want it to be?
14:28:14 <ski> happyhippy : hm .. not sure. maybe `heterogenousBase :: (Integral i,Real r) => [r] -> r -> ([i],r)'
14:28:28 <nand`> shachaf: it becomes clear to me what was missing for the hyper reals to actually work; different infinitesimals, differing not just in the number that's before them but also in their infinitesimality; eg. 1 / infinity vs 1 / infinity²
14:28:34 <ion> sclv: URL?
14:28:42 <bgamari> unfortunately the difference between the testcase and the real code isn't profiling
14:28:48 <ion> 999 users on #haskell?
14:28:48 <merijn> Sonarpulse: and also: http://stackoverflow.com/questions/10830757/is-there-a-list-of-ghc-extensions-that-are-considered-safe
14:28:50 <nand`> which is what allows them to eg. replace limit calculus for differentiations
14:28:50 <sclv> currently top post http://www.reddit.com/r/programming/comments/138q4q/number_porn_animated_factorisation_diagrams/
14:28:51 <ciaranm> jmcarthur: i want [] `mplus` [x] to be [x] and [a] `mplus` [x] to be [a]
14:29:09 <ion> 1000.
14:29:13 <jmcarthur> ciaranm: what about [a,b] `mplus` [c,d] ?
14:29:35 <shachaf> nand`: There's usually no particular thing called "infinity" when discussing hyperreals.
14:29:39 <ciaranm> jmcarthur: [a, b]
14:29:53 <jmcarthur> ciaranm: it sounds like you just want Maybe's mplus, to me
14:30:03 <ciaranm> jmcarthur: yeah. except on lists.
14:30:07 <shachaf> There are infinite hyperreals but I don't know of a particular one that people choose to give a special name to.
14:30:08 <monochrom> "under the iron fist of shapr, #haskell has unlocked achievement: 1000 users"
14:30:14 <happyhippy> ski : googling heterogeneous base leads me to biodiesel! lol
14:30:31 <monochrom> "plus or minus a few bots"
14:30:36 <ciaranm> really i want to hop around arbitrarily between maybes, lists and other things
14:30:39 <Sonarpulse> excellent
14:30:42 <Sonarpulse> thanks for the links
14:30:57 <bgamari> rwbarton, monochrom, What would be your next guess if the same function overflows even with lazy state?
14:31:31 <monochrom> "let (a,b) = blah" may be better off as "case blah of (a,b) ->"
14:32:05 <happyhippy> ski : what would that return type contain? ... whats in the tuple?
14:32:09 <byorgey> sclv: heh, yeah, those animated ones someone made are nice
14:32:09 <nand`> shachaf: oh; seems I had misremembered that then; seems like the differentiation example just assumes dx to be ‘some infinitesimal’; meaning it works for any
14:32:10 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
14:32:15 <byorgey> sclv: not written in Haskell, unfortunately
14:32:17 <edwardk> > diff cos 1
14:32:19 <lambdabot>   -0.8414709848078965
14:32:23 <shachaf> monochrom: "case blah of (a,b) -> in ..."? That's a syntax error!
14:32:24 <bgamari> monochrom, those should be identical, no?
14:32:31 <sclv> we can fix it :-P
14:32:32 <ski> happyhippy : i was thinking : `(listOfDigitsInRespectiveBases,remainder)'
14:32:34 <monochrom> of course not
14:32:35 * ski is pondering it
14:32:36 <bgamari> monique__, They both force the tuple but not its constituents, correct?
14:32:42 <Sonarpulse> I through in safe too
14:32:49 <bgamari> monochrom, rather
14:32:52 <shachaf> > let (x,y) = undefined in 5
14:32:54 <lambdabot>   5
14:32:57 <Sonarpulse> and it still compiles so I guess that is also a good litmus test
14:32:58 <rwbarton> let does not force anything
14:33:00 <merijn> Sonarpulse: If you stick to the good list (until you really understand the consequence of the non-good ones) you'll be fine, though. Those extensions are perfectly type safe and some of them will almost certainly increase the safety/sanity of your code
14:33:01 <sclv> byorgey: open invitation to you or any of the philly crew btw to come to NY and give a talk at the meetup!
14:33:06 <rwbarton> it just allows :)
14:33:12 <byorgey> sclv: when's the meetup?
14:33:13 <bgamari> oh dear
14:33:17 <shachaf> > let !(x,y) = undefined in ()
14:33:19 <lambdabot>   *Exception: Prelude.undefined
14:33:19 <nand`> let bindings are irrefutable by default
14:33:21 <sclv> whenever we want
14:33:23 <monochrom> "let (a,b)" = "case ~(a,b)"
14:33:32 <sclv> just had the first one last night, ~60 attendees
14:33:38 <byorgey> sclv: ah, cool
14:33:39 <monochrom> err, "case ... of ~(a,b)"
14:33:40 <sclv> going to be monthly, probably third wednesday of each month
14:33:42 <happyhippy> ski : oooh ... thats why the word heterogeneous came up ...now i got it
14:33:46 <sclv> although we're 2nd wed now
14:33:48 <happyhippy> ski : its late here : P
14:33:56 <Sonarpulse> yeah, making a one-field datatype before just forced additional bocing wheras now I at least give the compiler some choice
14:33:57 <merijn> Sonarpulse: (for example, GADTs and ScopedTypeVariables are so inherently sane I think about half my code ends up using them xD)
14:33:57 <sclv> edwardk will be giving the next talk
14:34:02 <shachaf> sclv: Third Wed of the month? That's the same time as bahaskell meetings!
14:34:20 <shachaf> We should combine them into transcontinental ultra-meetings.
14:34:20 <sclv> shachaf: all the more awesome
14:34:23 <sclv> global haskell dominance
14:34:30 <byorgey> sclv: cool, I'll keep it in mind.
14:34:47 <bgamari> monochrom, What do you think it is that is overflowing, a or b?
14:34:50 <sclv> i took a survey of the room and like 90% of attendees thought they knew what monads were, so much higher level than i feared
14:34:52 <edwardk> shachaf: i figured it was safe because all you guys already saw my talk ;)
14:35:12 <shachaf> edwardk: Yes, but everyone was confused because it hadn't yet been alpha-renamed!
14:35:22 <edwardk> sclv: we'll have to see if you can beat the turnout of the SF guys ;)
14:35:23 <ciaranm> sclv: how many of them wrote blog posts "explaining" what monads "are"?
14:35:24 <sclv> btw, byorgey did my notes to you seem not entirely insane?
14:35:45 <sclv> none, i hope
14:35:54 <sclv> i also asked if they thought jquery was a monad and not one hand went up
14:36:04 <sclv> i may have telegraphed the answer I wanted though :-P
14:36:17 <happyhippy> ski : thank you really much ...
14:36:19 <byorgey> sclv: yes
14:36:22 * happyhippy just got happier
14:36:26 <shachaf> sclv: jquery is more of a contravariant functor.
14:36:43 <sclv> i'll take your word for it
14:36:46 <byorgey> sclv: though I haven't yet had time to think about them more carefully
14:37:06 <Sonarpulse> thanks again everybody
14:37:20 <sclv> ah, no problem. i'm now trying to page out 90% of what i know about cloud haskell so i can get back to other projects :-P
14:37:24 <atriq> I might learn loads of category theory and right a blog post explaining what monads actually are
14:37:37 <ski> @let inHeterogenousBase :: Integral i => [i] -> i -> ([i],i); inHeterogenousBase [] n = ([],n); inHeterogenousBase (b:bs) n = (r:rs,r0) where (q,r) = n `divMod` b ; (rs,r0) = inHeterogenousBase bs q
14:37:39 <atriq> Then another one saying how on earth this is relevant to Haskell
14:37:39 <lambdabot>  Defined.
14:37:41 <shachaf> atriq: There's no way to right such a post. You can only wrong it.
14:37:42 <ski> > 13 + 60 * (15 + 60 * (4 + 24 * 9))
14:37:42 <ski> > inHeterogenousBase [60,60,24] 792913
14:37:43 <lambdabot>   792913
14:37:45 <lambdabot>   ([13,15,4],9)
14:37:53 <ski> happyhippy : that seems to be one way
14:38:06 <bgamari> monochrom, rwbarton unfortunately even "case V.span (<end) $ snd $ V.span (<start) ts of (a,b) -> put b >> return a" seems to overflow
14:38:13 <ski> (thirteen seconds, fifteen minutes, four hours, and nine days)
14:38:16 <shachaf> > inHeterogenousBase (cycle [10]) 792913
14:38:18 <lambdabot>   ([3,1,9,2,9,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
14:39:32 <happyhippy> >  inHeterogenousBase [24,60,60] 792913
14:39:35 <lambdabot>   ([1,38,10],9)
14:39:44 <tomeo> Could someone please help me figure out how to make this stop executing at some point? Perhaps when x > n or something
14:39:46 <tomeo> http://pastie.org/5384770
14:39:53 <happyhippy> ski : lambdabot eh?
14:40:10 <andsens> Something is really tripping me up here: https://gist.github.com/4081958
14:40:17 <happyhippy> ski : great
14:40:39 <andsens> I want to prepend a String to a List of Strings.
14:40:50 <andsens> Somehow ghc expects a Char
14:40:54 <ion> (:)
14:41:24 <shachaf> ion: That's a scary dual-mouthed smiley.
14:42:13 <andsens> *updated the gist
14:42:34 <happyhippy> ski : lot to digest : )
14:44:34 <happyhippy> I think I will hang out here more often ... this tickles my mind : )
14:45:09 <ski> good idea :)
14:46:09 <andsens> :t maybeToList
14:46:11 <lambdabot> Maybe a -> [a]
14:46:29 <andsens> argh! FFFffffuu…. now I get it. Nevermind guys
14:48:07 <happyhippy> nice
14:48:13 <happyhippy> I will go to sleep here
14:48:15 <happyhippy> bb
14:48:16 <happyhippy> hf!
14:49:05 * hackagebot pcd-loader 0.2.2 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.2.2 (AnthonyCowley)
14:49:26 <ski> tomeo : it
14:49:34 <ski> s not clear what you want to do
14:49:49 <tomeo> ski: sorry, Im trying to find the largest prime factor of n
14:50:09 <tomeo> ski: I find it, quite quickly. but my script never terminates :)
14:50:55 <ski> tomeo : perhaps find all prime factors (in order), and take the last one ?
14:51:22 <ski> hm
14:51:27 <linduxed> if i use record syntax
14:51:43 <pordan30> in the paper "a notation for comonads," the author defines cobind for a labeled graph comonad, G a = G [(a,[Int])] Int as: extend f (G xs c) = G (fmap (\c' -> (f $ G xs c', snd $ xs !! c)) [0..length xs]) c. i don't understand why the second element of the pair is c rather than c'? shouldn't label be computed in each context, without altering the connected vertices?
14:51:43 <linduxed> like { name :: String, age :: Int }
14:51:56 <linduxed> can i both have accessors and not have them?
14:52:06 <simpson> linduxed: How so?
14:52:08 <linduxed> like doing { String, age :: Int ]
14:52:11 <linduxed> }
14:52:28 <simpson> I think you have to define all of the accessor names for records. I think.
14:52:38 <linduxed> yeah, i thought so
14:52:44 <simpson> But note that you can still work with those types using normal pattern matching.
14:52:46 <tomeo> ski: well Im doing that. But as I'm doing it by list comprehension it never stops looking for a larger one :)
14:53:00 <linduxed> simpson: oh yes, i know that
14:53:19 <linduxed> simpson: it's mostly the fact that i did record syntax for one data type
14:54:36 <linduxed> and i'm not using most of the accessors, so hlint is getting angry :-)
14:54:37 <Overload> Hi, can anyone suggest me a good editor/IDE with autocompletion and jump to definition?
14:54:37 <ski> tomeo : i think it would be nicer at least to do
14:54:55 <tomeo> ski: to do what?
14:54:57 <linduxed> Overload: vim
14:55:13 <ski>   problem3 = sieve n [y | y <- [2..n] , n `rem` y == 0] where n = 600851475143
14:55:13 <linduxed> Overload: i'm pretty sure emacs has it as well
14:55:15 <ski> well
14:55:19 <ski>   problem3 = sieve [y | y <- [2..n] , n `rem` y == 0] where n = 600851475143
14:55:22 <ski> and
14:55:46 <ski>   sieve [    ] = []
14:55:46 <ski>   sieve (x:xs) =  x : sieve [y | y <- xs, y `rem` x /= 0]
14:55:51 <simpson> linduxed: You can always build a single accessor by hand, for a given field and type.
14:56:17 <Overload> linduxed: i tryed emacs, but it takes quite some time to load after you add some scripts, i'll try vim, thx
14:56:22 <ski> iow, only do the  n `rem` y == 0  test *once* for each `y' in the list (instead of many times, as yours did)
14:56:37 <tomeo> ski: okay, sure. but it will still run forever?
14:57:18 <ski> tomeo : also, i suspect "it never stops looking for a larger one" really is "it takes a very long time to determine there are no more prime factors after the greatest one
14:57:20 <ski> "
14:58:07 <ski> tomeo : probably it would be nice if you only checked up to `floor (sqrt n)', instead of up to `n' (and if there's no prime factors there, then `n' is a prime itself)
14:59:31 <saml> > let bc alpha num = let n = length alpha; l = reverse $ drop 1 $ take (2 + (floor $ logBase (fromIntegral n) (fromIntegral num))) $ iterate (\(x,_) -> divMod x n) (num,0) in map (\ (_, i) -> alpha !! i) l in bc "0123456789" 0
14:59:32 <lambdabot>   "0"
14:59:43 <bgamari> this overflow can't possibly be happening where the profiler claims it is
14:59:49 <ski> hm
15:00:11 <bgamari> the mapM is only mapping over 12 elements
15:00:18 <tomeo> ski thanks
15:01:01 <ski> hm, i think your code also returns `2' in the list .. which isn't a divisor of your `n'
15:02:06 <centrinia> @let isPrime n = all [n `mod` m /= 0 | m <- [2..n-1]]
15:02:08 <lambdabot>  <local>:6:17:
15:02:08 <lambdabot>      Couldn't match expected type `a0 -> Bool' with actual typ...
15:02:12 <Jafet> > showIntAtBase 10 (['0'..'9']!!) 123 ""
15:02:14 <lambdabot>   "123"
15:02:22 <ski> tomeo : hm, now i'm doubting whether moving the  n `rem` y == 0  out will work
15:02:32 <centrinia> @let isPrime n = and [n `mod` m /= 0 | m <- [2..n-1]]
15:02:34 <lambdabot>  Defined.
15:02:45 <centrinia> > [n | n <- [2..], isPrime n]
15:02:47 <lambdabot>   [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101...
15:02:57 <centrinia>  :D
15:03:14 <centrinia> @let thePrimes =  [n | n <- [2..], isPrime n]
15:03:16 <lambdabot>  Defined.
15:03:17 <tomeo> centrinia: is that in prelude?
15:03:19 <pordan30> is it possible to import the binary tree used internally in data.map and data.set? i want arbitrary selection from a map / set, e.g., by pattern matching on the root of the tree. apparently neither module exports a constant time access function =/
15:03:27 <tomeo> ah
15:03:27 <centrinia> tomeo, I don't think so.
15:03:29 <lispy> ?hoogle isPRime
15:03:29 <lambdabot> No results found
15:03:31 <lispy> ?hoogle isPrime
15:03:31 <lambdabot> No results found
15:04:37 <Jafet> > isPrime 1
15:04:40 <lambdabot>   True
15:05:15 <centrinia> > isPrime [-10..]
15:05:17 <lambdabot>   No instance for (GHC.Real.Integral [t0])
15:05:17 <lambdabot>    arising from a use of `L.isPrim...
15:05:17 <centrinia> > map isPrime [-10..]
15:05:20 <lambdabot>   [True,True,True,True,True,True,True,True,True,True,True,True,True,True,Fals...
15:05:58 <ski> (centrinia : there's also `all' ..)
15:09:48 <lispy> > all isPrime [-10..]
15:09:50 <lambdabot>   False
15:10:28 <andsens> whoa: GHCi runtime linker: fatal error: I found a duplicate definition for symbol __hs_text_decode_utf8
15:10:57 <lispy> pordan30: What is it that you want to do?
15:11:10 <ski>   and [..m.. | m <- ...]  =  all (\m -> ..m..) (...)
15:11:12 <lispy> pordan30: you want to pattern match on the root node of Data.Map?
15:11:16 <bgamari> monochrom, rwbarton, if either of you can think of a more robust way to accomplish the task implemented in that hpaste, I'd be very happy to hear it
15:11:24 <tomeo> Can't I use show in a list comprehension?
15:11:24 * bgamari is really at a loss
15:11:41 <bgamari> tomeo, What do you mean?
15:11:45 <lispy> > [ show x | x <- [1..3] ]
15:11:47 <lambdabot>   ["1","2","3"]
15:12:15 <tomeo> bgamari: I was missing () :)
15:12:19 <tomeo> thanks
15:12:47 <bgamari> tomeo, ahh
15:13:26 <pordan30> lispy: yes, in order to quickly select an arbitrary element of the map. for instance: get m@(Bin n k a l r) = Just (a, delete k m); get Tip = Nothing, and equivalently for set.
15:15:57 <Phlogistique> putain
15:16:04 <andsens> I think I found a bug in either Text.XML or Text.JSON
15:16:06 <andsens> https://gist.github.com/4082228
15:16:06 <Phlogistique> oops wrong chan
15:16:17 <andsens> Seems like you can't use them together
15:17:01 <andsens> What can I do?
15:18:17 <heatsink> andsens, are there any warnings when you build and link?
15:18:28 <andsens> I use homebrew
15:18:28 <heatsink> It could be due to dependences on two versions of the same package
15:18:37 <tomeo> Are there any other functions than read that will convert "123" to 123?
15:19:10 <andsens> I'l check if there is a build log
15:19:15 <simpson> tomeo: Why?
15:19:17 <Athas> tomeo: you mean an integer parser?
15:19:18 <pordan30> > read "123" :: Int
15:19:20 <lambdabot>   123
15:19:22 <rwbarton> tomeo: sounds like you have something in mind?
15:19:42 <heatsink> andsens, if you know the package names, then you can use ghc-pkg to find package dependences
15:19:44 <ion> > evalStateT (state (reads :: Read Integer) <* do { [] <- get; return () }) "123"
15:19:46 <lambdabot>   Predicate `GHC.Read.Read GHC.Integer.Type.Integer' used as a type
15:19:53 <ion> > evalStateT (state (reads :: ReadS Integer) <* do { [] <- get; return () }) "123"
15:19:54 <lambdabot>   Couldn't match expected type `(a0, GHC.Base.String)'
15:19:54 <lambdabot>              with actu...
15:20:00 <ion> bleh
15:20:01 <tomeo> rwbarton: simpson I'm trying this http://pastie.org/5384949
15:20:04 <Athas> tomeo: psychic guess: use reads in order to get easier error handling than throwing an exception.
15:20:05 <tomeo> but can't get it working
15:20:11 <tomeo> in ghci
15:20:20 <tomeo> Im trying to find palindrome numbers
15:20:26 <ion> Ah, duh.
15:20:34 <ion> > evalStateT (StateT (reads :: ReadS Integer) <* do { [] <- get; return () }) "123"
15:20:36 <lambdabot>   [123]
15:20:51 <rwbarton> tomeo: well i <- (e :: Int) is surely wrong
15:21:14 <tomeo> ah yes it is!
15:21:20 <tomeo> because Im giving it a list
15:21:27 <simpson> tomeo: I don't understand why you're reading after showing.
15:21:29 <rwbarton> yep, that too
15:21:43 <simpson> Surely you could manage to isolate the showing and palindrome check.
15:22:00 <shachaf> There is no point to the show on the left side of the |
15:22:07 <andsens> Aha: ghc-pkg describe json depends on text-0.11.2.3
15:22:08 <tomeo> shachaf: true!
15:22:19 <andsens> Aha: ghc-pkg describe xml depends on text-0.11.2.0
15:22:29 <shachaf> Also I hope this isn't ProjectEuler.
15:22:36 <heatsink> Ok, that's the reason for the duplicate symbols
15:22:40 <simpson> > let isPal i = show i == reverse (show i) in isPal 123
15:22:41 <lambdabot>   False
15:22:41 <pordan30> why do you have all those shows and reads in there?
15:22:45 <simpson> > let isPal i = show i == reverse (show i) in isPal 123321
15:22:47 <lambdabot>   True
15:22:51 <andsens> what do, heatsink?
15:22:52 <tomeo> pordan30: trying to learn :)
15:23:20 <rwbarton> andsens: you can try "cabal install json xml" to get compatible versions of json and xml
15:23:20 <heatsink> You can reinstall one of the packages with cabal install
15:23:36 <shachaf> > maximum [p | x <- [0..9], y <- [0..9], z <- [0..9], let p = x*y*z, let s = show p, s == reverse s]
15:23:38 <lambdabot>   343
15:23:50 <andsens> xml-1.3.12 (reinstall) changes: text-0.11.2.0 -> 0.11.2.3
15:23:55 <andsens> Yes! Thank you!
15:24:17 <tomeo> shachaf: yes I got that now too when I removed the show on the left of |
15:24:19 <tomeo> thanks
15:24:52 <lispy> pordan30: ah. I bet you'd have to add a new function to Data.Map and .Set to get hta
15:24:55 <lispy> that*
15:27:19 <pordan30> lispy: that doesn't sound like something that is approved =) that's too bad.
15:29:44 <rwbarton> pordan30: if you're desperate you can copy the definition of Map from Data.Map into your own module and unsafeCoerce between the two
15:30:12 <rwbarton> you must build with -O though, otherwise it won't unpack the field that is supposed to be unpacked and that will end badly
15:37:06 <bgamari> I give up, just time to run with -K100M I guess
15:37:06 <pordan30> rwbarton: i'm not desperate enough to do that yet, but i'll keep it in mind. it appears that something like \m -> if null m then Nothing else Just $ deleteFindMin m would be a decent alternative.
15:38:48 <tomeo> [x+y | x, y <- [1..10]] Is there any way to initiate two variables to the same list (kind of like this)?
15:39:07 <heatsink> tomeo, what are the x,y values you should get from that list?
15:39:33 <tomeo> heatsink: I want to get the same behavior as x <- [1..10], y <- [1..10]
15:39:41 <tomeo> but Id like to write it in a shorter way if that's possible
15:39:52 <simpson> > [x + y | let l = [1..10], x <- l, y <- l]
15:39:54 <sipa> > [x+y | x <- l, y <- l, let l = [1..3]]
15:39:54 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:39:55 <lambdabot>   Couldn't match expected type `[t0]'
15:39:56 <lambdabot>              with actual type `Debug.Si...
15:40:18 <monochrom> this may use more memory than you think
15:40:32 <tomeo> okay, so let is my only option :) thanks
15:40:37 <monochrom> I mean, consider [1..10000000] instead of [1..10]
15:41:06 <ski> > [x + y | x@y <- [1 .. 10]]
15:41:07 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
15:41:16 <shachaf> monochrom: :-(
15:41:27 <ski> > [x + y | (x,y) <- liftM2 (,) `join` [1 .. 10]]
15:41:29 <lambdabot>   [2,3,4,5,6,7,8,9,10,11,3,4,5,6,7,8,9,10,11,12,4,5,6,7,8,9,10,11,12,13,5,6,7...
15:41:43 <monochrom> #define same [1..10]
15:41:46 <rwbarton> speaking of which has anyone used ghc-dup?
15:41:52 <monochrom> ... [x+y | x<-same, y<-same]
15:42:02 <monochrom> this will use the same amount of memory as before
15:42:45 <shachaf> rwbarton: Hadn't heard of it. Looks suspicious -- I'd assume that both dup and deepDup are the wrong depth level for most things.
15:43:14 <tomeo> monochrom: are you saying that let would increase the memory usage?
15:43:58 <monochrom> that question is ambiguous. I am not comfortable in answering either yes or no
15:44:20 <monochrom> not all uses of "let" increase memory
15:44:46 <heatsink> I think the fact that the output list has N^2 elements is the more important effect
15:44:58 <heatsink> on memory use
15:45:09 <shachaf> heatsink: Not if you consume it lazily.
15:45:18 <shachaf> The issue is that the input list won't be GCed.
15:45:47 <monochrom> yeah, do not think, measure.
15:45:59 <simpson> Well, you've gotta keep the entire list around at *some* point, since you have to add something at the beginning of the list to something at the end of the list, right?
15:46:21 <rwbarton> not if you use two copies of the list
15:46:56 <shachaf> Two copies of the list -> less memory use.
15:46:57 <shachaf> It's obvious.
15:47:34 <ClaudiusMaximus> erm, but [x + y | x <- big1, y <- big2] has to keep big2 around anyway...
15:47:36 <heatsink> simpson, the [f x y | x <- [1..10], y <- [1..10]] form evaluates [1..10] a total of 11 times, instead of keeping it in memory.
15:48:29 <ClaudiusMaximus> heatsink: i think it evaluates it twice, the first time lazily for x, the second once for the first y and then keeps it around for the next ys
15:48:29 <simpson> Hm. So you're saying that, for [1..10], the behavior is to scroll to that 10 at the end, discarding everything that it goes past?
15:48:31 <Sonarpusel> what do you do if there is overlapping instances for a function defined in a typeclass, even after you have specified it's exact type signiture?
15:48:44 <shachaf> Sonarpusel: You change your class.
15:48:54 <Sonarpusel> hmm?
15:48:57 <ClaudiusMaximus> modulo confusing references to variables...
15:48:59 <shachaf> Why are you using a class in the first place? You probably shouldn't.
15:49:04 <Sonarpusel> this is the same probablem as before
15:49:31 <heatsink> Well, [x + y | x <- [1..10], y <- [1..x]] certainly reevaluates [1..x].  I think the same thing happens for [1..10].
15:49:40 <Sonarpusel> I am defining binary for a synonym of [[Char]] using -XFlexibleInstances
15:50:18 <shachaf> If you want a better answer you'll have to ask a better question.
15:50:20 <Sonarpusel> the problem is Binary itself is defined using that same extension and has an instance for "Binary a => Binary [a]
15:50:25 <shachaf> s/better/more precise/g, if you prefer.
15:50:35 <ClaudiusMaximus> heatsink: right, but i've definitely had space leaks that i eliminated with x <- [1..100000], y <- [{- begin hack -}x + 1 - x{- end hack -} .. 100000]
15:50:40 <shachaf> Sonarpusel: Then you probably shouldn't be doing it.
15:51:05 <rwbarton> you can use a newtype, or just not define an instance at all
15:51:08 <Sonarpusel> my previous solution was to make a data structure just containing one field of [[Char]]
15:51:20 <rwbarton> yep, that is the newtype solution
15:51:34 <shachaf> That's how instances work, man. :-(
15:51:46 <Jafet> @undo [x+y | x <- [1..10], y <- [1..10]]
15:51:47 <lambdabot> concatMap (\ x -> concatMap (\ y -> [x + y]) [1 .. 10]) [1 .. 10]
15:51:54 <heatsink> ClaudiusMaximus, that's probably an indication that GHC has some not-safe-for-work CSE transformations
15:52:15 <Sonarpusel> well, if that is my best solution
15:52:18 <Jafet> = concatMap (\x -> concatMap (\y -> [x + y]) (enumFromTo 1 10)) (enumFromTo 1 10)
15:52:28 <rwbarton> it might not be the best solution! there is also "don't write an instance"
15:52:29 <pordan30> i thought that overlapping instances chooses the most specific resolvable instance, so that the instance for [[Char]] would be preferred to Binary a => [[a]]?
15:52:45 <heatsink> No list elements are skipped, simpson
15:52:47 <Jafet> heatsink: (enumFromTo 1 10) only needs to be evaluated once, so it is evaluated once.
15:53:08 <shachaf> But how do I abstraction without types and classes and instances?!
15:53:09 <Jafet> If you changed it to (enumFromTo 1 x), it would be evaluated once for each x.
15:53:34 <Sonarpusel> I don't come from OO land, I value pure functions too
15:54:08 <Sonarpusel> and IMO, it would be nicer if you could just define functions twice with different signitures
15:54:18 <Sonarpusel> as opposed to using type clases
15:54:22 <rwbarton> you can
15:54:30 <rwbarton> however, you have to give them different names
15:54:42 <Jafet> shachaf: be the lensman
15:54:48 <Sonarpusel> same name is what i meant
15:54:50 <rwbarton> putSonarpusel :: [[Char]] -> Put; getSonarpusel :: Get [[Char]]
15:55:00 <rwbarton> do with these whatever you like
15:55:20 <shachaf> A gift from rwbarton.
15:55:25 <Cale> Sonarpusel: But then you immediately have a problem with type inference.
15:55:25 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:55:31 <heatsink> Jafet, in general, Haskell implementations don't save the result of a function call and reuse them the next time the function is called with the same arguments.  GHC only does CSE in limited situations.
15:55:35 <ClaudiusMaximus> heatsink: it's not CSE, it's just laziness keeping the value around as it's already been computed for x=1, then reuses the same value for x=2 -  x<-"hello", y<-[1..1000000]  would have the ssame problem
15:55:56 <Sonarpusel> Cale: you mean having two functions with the same name and different signitures?
15:56:01 <Cale> Sonarpusel: yes
15:56:09 <rwbarton> don't you want two functions with the same name and the same signature
15:56:15 <Jafet> heatsink: in (\x -> x + x) y, y is computed once in x.
15:56:20 <rwbarton> after all, you already have the newtype solution as an alternative
15:56:35 <tac> Type inference isn't such a big deal. The real problem is when you don't just have two versions, but an infinity.
15:56:37 <Jafet> In concatMap f [1..10], [1..10] is computed once
15:56:37 <heatsink> Jafet, this is enumFromTo 1 10 >>= (\x -> enumFromTo 1 10 >>= (\y -> [y + x]))
15:56:49 <Cale> tac: well, there's that too
15:56:50 <heatsink> Note that the second 'enumFromTo' is inside a function that will be called 10 times
15:56:58 <Cale> Sonarpusel: Now suppose I use a bunch of things with multiple definitions like this, and I use them together in an expression
15:57:18 <Cale> Sonarpusel: Does the typechecker try all the possibilities?
15:57:26 <Cale> until it finds one which typechecks?
15:57:34 <Sonarpusel> I mean the same dictoionary passing thing with type classes could be used for conflicting function definitions, but i get that is probably too much syntactic sugar for some people
15:57:36 <Jafet> It should!
15:57:43 <Cale> You get into all sorts of trouble like that
15:58:03 <Cale> Sonarpusel: You have to think about the type!
15:58:11 <rwbarton> Sonarpusel: I don't understand how what you are proposing differs from writing an instance for a newtype
15:58:13 <Cale> Sonarpusel: Suppose we have:
15:58:14 <Sonarpusel> I kinda agree with Jafet there
15:58:16 <Cale> x :: Char
15:58:18 <Cale> x = 'c'
15:58:21 <Cale> x :: Int
15:58:23 <Cale> x = 5
15:58:33 <Cale> What is the type of (x,x) ?
15:59:01 <Sonarpusel> ambiguous
15:59:13 <Sonarpusel> but you an already to ambigous things and it throws and error and it's fine
15:59:23 <Sonarpusel> I am not saying some new semantics would be nice
15:59:28 <Cale> Well, if we have a typeclass:
15:59:33 <Cale> class X a where
15:59:35 <Cale>   x :: a
15:59:41 <Cale> instance X Char where
15:59:42 <Sonarpusel> anyways, what is the syntax for the "newtype" solution
15:59:43 <Cale>   x = 'c'
15:59:47 <Cale> instance X Int where
15:59:50 <Cale>   x = 5
15:59:50 <Sonarpusel> I just define a plain datatype right now
15:59:59 <Sonarpusel> and if it means less { and } that would be nice
15:59:59 <Cale> then (x,x) :: (X a, X b) => (a,b)
16:00:03 <Cale> see?
16:00:18 <rwbarton> newtype Sonarpusel = Sonarpusel [[Char]]; instance Binary Sonarpusel where put (Sonarypusel whatever) = ...; get = ...
16:00:21 <Cale> So, you actually can give types to things because you have a name for the collection of instances.
16:00:34 <Sonarpusel> oh, duh
16:00:51 <Sonarpusel> and i could have done that with data ME = ME [[Char]] too
16:00:58 <rwbarton> can make as many as you like
16:01:02 <rwbarton> oh, data
16:01:07 <sykora> Anyone know a way to configure a test-suite section of my cabal file to always pass a given value of the --test-options flag when running tests? I want to pass --color to htf by default.
16:01:14 <rwbarton> sure, I guess, normally one uses newtype as it's more economical
16:01:51 <rwbarton> data adds extra laziness which you normally don't want
16:01:57 <rwbarton> for this kind of application
16:02:04 <shachaf> newtypes, newproblems
16:03:26 <rwbarton> monads, moproblems
16:03:36 <Sonarpusel> Cale, you could also ideally do (x,x) :: (Char,Int)
16:03:39 <Sonarpusel> with the original version
16:03:54 <Sonarpusel> and the compiler would still have enough information
16:04:18 <Cale> Sonarpusel: Yeah, but with typeclasses, you can just write (x,x) without any explicit type signature, and get a well-typed thing.
16:04:50 <Cale> (which can then be used to define perhaps yet another polymorphic thing)
16:04:57 <Sonarpusel> you still had to do (X a, X b)
16:05:09 <Cale> The compiler will infer that type
16:05:19 <Cale> (X a, X b) => (a,b)
16:05:29 <shachaf> (forall a. X a => a, forall a. X a => a)
16:06:03 <monochrom> @type let (e,е) = (4, '4') in (e,е)
16:06:04 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
16:06:09 <monochrom> foiled!
16:06:13 <rwbarton> haha
16:06:19 <rwbarton> lambdabot is on to your tricks
16:06:30 <monochrom> stupid lambdabot doesn't do UTF-8 internationalization
16:06:37 <shachaf> More like off to your tricks. :-(
16:06:41 <Sonarpusel> well (X a,X a) and (X b,X b) (and other combos) are still both valid unless there is some other contstraint
16:08:00 <Cale> Sonarpusel: uhhh
16:08:02 <shachaf> What's (X a,X a)? A redundant constraint?
16:08:02 <Cale> Sonarpusel: no
16:08:10 <Cale> Sonarpusel: yeah, that's redundant
16:08:27 <Cale> You wouldn't write (X a, X a, X b) => (a,b), because it's silly
16:08:30 <shachaf> @show é
16:08:31 <lambdabot> "\195\169"
16:08:52 <Cale> Or (X a, X a) => a
16:09:32 <rwbarton> Sonarpusel: one thing that type classes give you that your suggestion wouldn't is the ability both to say that a value is overloaded and also that a value is *not* overloaded
16:11:00 <rwbarton> C++ can get away with its style of overloading because it doesn't support overloading on the return type and the type inference is unidirectional
16:12:20 <mauke> you can fake return-type-based overloading with proxy objects
16:12:36 <mauke> (I've written a polymorphic malloc, for example)
16:21:36 <Sonarpusel> hmm, say if it is not overloaded?
16:21:45 <Sonarpusel> what exactly do you mean
16:23:21 <rwbarton> the compiler does not have to worry that I will later write 'reverse :: Seq a -> Seq a'
16:23:30 <rwbarton> so when it sees reverse :: f a -> f a, it knows f = []
16:24:03 <rwbarton> if any value can be overloaded later at any type then type inference goes out the window
16:25:23 <andsens> I am trying to find the offsets of substrings that match "{{([^}]+)}}", how do I do that?
16:25:31 <rwbarton> type classes give up opt-in explicit overloading, which keeps things under control
16:25:43 <rwbarton> *give us
16:27:57 <andsens> should I just use plain old pattern matching?
16:28:06 <Sonarpusel> I don't really see the problem
16:28:13 <Sonarpusel> at least for compiled code
16:29:10 <andsens> ok, thought so. Especially because the prefix is so short, right?
16:29:17 <Sonarpusel> I can fax-overload a value  imported unqualified
16:29:30 <Sonarpusel> and then ghci just balks and asks me to pick which one i want
16:29:40 <andsens> ah ok. he wasn't talking to me
16:29:59 <andsens> talking to myself now… that's fine, not awkward...
16:30:29 <Sonarpusel> andsens: sorry I would help
16:30:36 <Sonarpusel> but I haven't used list comprehensions yet
16:30:43 <andsens> no worries mate, kind of solved it myself
16:30:44 <Sonarpusel> I come from lisp and
16:30:46 <Sonarpusel> that's good
16:30:59 <Sonarpusel> no such thinggys there
16:31:25 <andsens> well. I got 99 problems put parens ain't one.
16:31:30 <rwbarton> shachaf: I installed ghc-dup but I can't load it in ghci
16:31:30 <andsens> :-D
16:31:34 <shachaf> I don't see any list comprehensions mentioned.
16:31:40 <hpc> i got (( problems but a shift ain't one
16:31:48 <Sonarpusel> I got 99 problems and "template scheme" isn't one
16:31:56 <Sonarpusel> :D
16:32:11 <shachaf> I have approximately 1000 problems and they're all in #haskell.
16:32:23 <johnw> shachaf: but your problems love you, don't we
16:32:26 <rwbarton> <interactive>: /home/rwbarton/.cabal/lib/ghc-dup-0.1/ghc-7.4.2/HSghc-dup-0.1.o: unknown symbol `era' /// ghc: unable to load package `array-0.4.0.0'
16:32:46 <shachaf> rwbarton: Hmm, loads for me
16:32:47 <Tehnix> how would you convert getCurrentTime which returns IO UTCTime to just UTCTime?
16:33:06 <rwbarton> let me try compiled
16:33:06 <hpc> Tehnix: a time machine that makes your entire program run in infinitessimal time
16:33:12 <shachaf> rwbarton: Oh, no.
16:33:18 <shachaf> It doesn't work when I actually use it.
16:33:20 <rwbarton> right, see :)
16:33:24 <rwbarton> I forgot to mention that part, yeah.
16:33:27 <johnw> do a <- getCurrentTime; return $ f a
16:33:34 <johnw> or, f<$> getCurrentTime
16:33:41 <johnw> pick your poison(ed monad)
16:33:54 <hpc> Tehnix: (getCurrentTime :: IO UTCTime) means a computation that gets the current time of the world
16:33:57 <rwbarton> shachaf: same error message?
16:34:01 <shachaf> rwbarton: Yep.
16:34:10 <hpc> (someTimeValue :: UTCTime) is a constant time value that never changes
16:34:14 <Jafet> @hackage acme-now -- Tehnix
16:34:15 <lambdabot> http://hackage.haskell.org/package/acme-now -- Tehnix
16:34:25 <hpc> what johnw said would be a useful solution for you
16:34:35 <hpc> instead of taking things out of IO, put the rest of your program into it
16:34:40 <hpc> with some combination of combinators
16:35:01 <shachaf> rwbarton: Doesn't give that error when compiled.
16:35:08 <rwbarton> yes
16:35:14 <rwbarton> worked here too
16:35:15 <shachaf> I do get "Static closure passed to dup!", but I assume that's because I passed a static closure to dup.
16:35:18 <rwbarton> fsvo "work"
16:35:20 <rwbarton> yep, me too :)
16:35:34 * nyc just shot up on cam in a G+ hangout.
16:35:59 <nyc> woops, wrong channel
16:36:08 <rwbarton> I got it not to print that message
16:36:13 <rwbarton> however, it segfaulted instead
16:36:35 <shachaf> How did you get that?
16:36:54 <hpaste> rwbarton pasted “ghc-dup” at http://hpaste.org/77799
16:36:58 <johnw> Haskell programs don't segfault, they translate to core
16:37:10 <mauke> hahaha
16:37:42 <shachaf> Yep, segfaults here.
16:38:21 <rwbarton> I was a little surprised to see the NOINLINE made a difference even with -O0
16:38:31 <shachaf> Are you using GHC 7.6?
16:38:43 <rwbarton> 7.4.2
16:38:55 <shachaf> OK, then I won't bother trying on 7.4
16:39:16 <rwbarton> what confuses me is that as far as I can tell this code basically just exposes some primops
16:39:36 <rwbarton> or hmm
16:39:42 <rwbarton> guess I should look at the full .tar.gz
16:39:58 <shachaf> It has cbits
16:39:59 <rwbarton> oh, there is C stuff too
16:40:09 <shachaf> The segfault itself happens in dupClosure, though.
16:40:12 <shachaf> Which I think is GHC code.
16:40:23 <shachaf> Oh, no, it's not.
16:40:25 <shachaf> It's just cmm
16:40:26 <rwbarton> don't you think it's ...
16:40:27 <rwbarton> yes
16:40:38 <luqui> Anybody know what's going on with this ConstraintKinds thing? https://gist.github.com/fe33612bcbbbe813f523
16:40:47 * shachaf is cmm-blind
16:40:56 <rwbarton> this has to be the least reassuring package I have ever seen on hackage
16:41:05 <luqui> oops that was a half-modified version
16:41:22 <shachaf> luqui: You need to import GHC.Exts or something.
16:41:39 <shachaf> Constraint isn't in scope, just like it says. :-)
16:42:01 <rwbarton> maybe i'm not supposed to dup whatever sort of thing trace returns?
16:42:20 <shachaf> Then what are you supposed to dup?
16:42:32 <rwbarton> well, even without the trace it didn't work
16:42:40 <rwbarton> i dunno, thought maybe unsafePerformIO was too magical for it somehow
16:42:40 <luqui> shachaf: yeah, ghc docs don't say anything about it… http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/constraint-kind.html
16:42:42 <luqui> thanks
16:43:57 <shachaf> Does cmm generate nice debugging information for gdb?
16:46:06 <rwbarton> well it calls some C functions, so I could printf debug those
16:46:11 <rwbarton> maybe even set gdb breakpoints on them?
16:46:27 <andsens> Argh. Can't I do this: findOpenMustache '{':'{':xs = Just findCloseMustache xs "" ??
16:47:17 <shachaf> andsens: case takeWhile (/= '}') xs of '}':'}':xs' -> ...; _ -> ...?
16:47:27 <shachaf> Based on vague recollections of what you case before.
16:47:38 <shachaf> You could just use regexps if you want to use regexps.
16:48:00 <shachaf> (Of course, regexps are typically not very good at this sort of thing.)
16:48:02 <rwbarton> andsens: you need more ()s in what you wrote
16:48:13 <shachaf> And that too.
16:48:23 <shachaf> Er, and I don't mean takeWhile
16:48:26 <shachaf> I mean break/span/something
16:48:29 <andsens> I always need more of those, the parse keeps telling me as well
16:48:37 <andsens> :-) thank you shachaf
16:49:07 <monochrom> use http://bm380.user.srcf.net/prettyparsetree.cgi for correct parenthesizing
16:49:28 <shachaf> The only thing that URL is missing is a non-80 port number.
16:49:42 <hpc> lol
16:50:23 <andsens> mayber gopher://
16:50:25 <andsens> :-)
16:50:54 <andsens> huh, thats nifty!
16:51:35 <hpc> cgi is still fine for simple things :P
16:52:23 <andsens> It's just the protocol in between that will rape you if you aren't careful
16:53:04 <andsens> But modern web server should take care of that
16:53:58 <shachaf> cmm is just different enough to be annoying.
16:54:58 <edwardk> given the terrible nigh-typeless ad hoc nature of cmm, it always amazes me how stable the RTS is ;)
16:55:52 <shachaf> Except when it's not.
16:56:02 <JoeyA> getContents >>= mapM_ . atomically . writeTChan chan
16:56:07 <JoeyA> Boom, nested STM (I hypothesize)
16:56:55 <andsens> The hell is wrong with this: findOpenMustache :: String -> Maybe (Name, StrPos) ???
16:57:10 <shachaf> Why don't you tell us?
16:57:11 <andsens> I think I should go to bed now, can't even figure out the simplest stuff
16:57:23 <shachaf> Oh, it's the question marks.
16:57:36 <nejucomo> :t m a -> m b -> m (a, b)
16:57:39 <lambdabot> parse error on input `->'
16:57:44 <Jafet> You need five question marks there
16:57:48 <nejucomo> I'll bet it's some applicative thingy.
16:57:51 <andsens> hold on… Name a, StrPos b => Maybe (a,b) ??
16:57:52 <dibblego> it is
16:57:57 <geekosaur> it already *is* a type
16:58:03 <Jafet> @mtl m a -> m b -> m (a, b)
16:58:03 <geekosaur> what's :t supposed to tell you?
16:58:04 <lambdabot> Maybe you meant: ft map msg pl unmtl url
16:58:11 <shachaf> liftA2 (,)
16:58:13 <dibblego> m a -> m b -> m (a, b) ≈ Applicative
16:58:31 <dibblego> s/Applicative/Apply
16:58:40 <nicoo> @src Apply
16:58:41 <lambdabot> Source not found. Just try something else.
16:58:42 <nejucomo> Or arrow?
16:58:45 <nicoo> @src Applicative
16:58:46 <lambdabot> class Functor f => Applicative f where
16:58:46 <lambdabot>     pure  :: a -> f a
16:58:46 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:58:55 <shachaf> Apply :-(
16:59:01 <dibblego> class Functor f => Apply f where (<*>) :: f (a -> b) -> f a -> f b
16:59:03 <shachaf> Would be nice if that existed.
16:59:22 <dibblego> yepper
17:00:03 <rwbarton> where can I find the definition of HP_CHK_GEN?
17:00:09 <dibblego> there is class Functor f => FZip where fzip :: f a -> f b -> f (a, b) somewhere, but you can recover Apply
17:00:25 <shachaf> rwbarton: includes/Cmm.h
17:00:32 <shachaf> (In the GHC code.)
17:01:17 <rwbarton> I don't see it
17:01:28 <shachaf> Oh, that's _TICKY
17:01:43 <rwbarton> yeah
17:01:59 <shachaf> Oh, in the Cmm parser.
17:01:59 <rwbarton> oh maybe it is a cmm built-in
17:02:04 <shachaf> Yep.
17:02:18 <rwbarton> this just keeps getting weirder
17:02:33 <shachaf> ?
17:02:36 <andsens> good night all. And thanks for the help! I appreciate it!
17:02:50 <rwbarton> no google, I do not want to search for ipChicken
17:03:27 <rwbarton> well I'm trying to relate this Cmm code to the disassembly I see in gdb
17:03:32 <rwbarton> it's not easy
17:04:04 <shachaf> That's what I said!
17:04:33 <shachaf> There ought to be a way to get debugging symbols in there or something.
17:05:16 <shachaf> Poor JaffaCake.
17:05:26 <rwbarton> well I guess I can insert random foreign "C" calls and rebuild
17:05:29 <rwbarton> to see where they end up
17:05:39 <rwbarton> that's like debugging symbols, right
17:05:48 <JoeyA> Compile-time traces!
17:05:49 <shachaf> Or you can insert special nops.
17:05:53 <rwbarton> ooh
17:06:04 <rwbarton> I do appreciate a good nop
17:06:08 <shachaf> mov %rcx,%rcx and so on.
17:06:08 <edwardk> shachaf: what do you mean if it existed?
17:06:17 <shachaf> edwardk: As a superclass of Applicative. :-)
17:06:22 <edwardk> =)
17:06:25 <rwbarton> can I write inline assembly in here somehow?
17:06:33 <shachaf> edwardk: In particular <dibblego> class Functor f => Apply f where (<*>) :: f (a -> b) -> f a -> f b
17:06:49 <hpc> rwbarton: ive seen bytestrings coerced to IO () before
17:06:51 <edwardk> i wonder how incoherently my reply about Apply/Bind vs Pointed turned out. i sent it by my phone, so it was hard to check
17:07:08 <dibblego> shachaf: I think edwardk's point is that it exists (semigroupoids -- a package that I almost always depend on)
17:07:09 <nejucomo> I may have an unusual haskell style, but I often which I could define types inside definitions relevant only in the value expressions or related where clauses.
17:07:10 <shachaf> rwbarton: Maybe you can "x += 123; x -= 123;"
17:07:17 <shachaf> How much of an optimizer does Cmm have?
17:07:19 <rwbarton> yeah...
17:07:40 <nejucomo> Probably because I tend to write few top-level definitions filled with deeply nested where-clauses.
17:07:43 <edwardk> i lean on apply and bind a lot less now that ComonadApply is split out separately
17:08:31 * shachaf needs to go.
17:08:41 <edwardk> i look forward to the day when i can build real product and sum categories
17:08:46 <rwbarton> just going to add some dummy functions in the dup.c
17:08:47 <shachaf> rwbarton: Tell me how it turned out!
17:08:48 <edwardk> then i can retire most of my remaining uses for them
17:08:49 <rwbarton> yep
17:08:57 <redj0hn> has anyone here used eclipsefp with cabal-dev?
17:09:17 <rwbarton> heh, there is already dupDebugPtr which is exactly what I was about to write
17:09:21 <parcs`> edwardk: what is left to do to put the 'rounded' library in a usable state? i'm willing to put in the work
17:09:35 <sw17ch> nand`: still here?
17:10:01 <edwardk> parcs`: it needs to work correctly with ghci. i have no !@#(* idea how to get that to work right. copumpkin and i spent days on it and it just links symbols to garbage in places.
17:10:56 <edwardk> i've since moved on from taylor models of DAEs and ODEs to stochastic ones, so that actually killed my personal need for MPFR for now, so if you want it to work, its all you ;)
17:11:21 <edwardk> for me its moved from the critical path of a side-project well out onto the sidelines
17:11:24 <rwbarton> preflex: zdec ghczmdupzm0zi1_GHCziDup_deepDupFun_closure
17:11:30 <rwbarton> oh no preflex
17:11:35 <parcs`> alrighty!
17:11:46 <shachaf> Is there a zenc/zdec package on Hackage?
17:11:51 <mauke> yes
17:11:51 <shachaf> There should be.
17:12:07 <shachaf> Does it come with a command line program?
17:12:11 <mauke> Text.Encoding.Z
17:12:16 <shachaf> Well, I guess you can just use it from ghci
17:12:23 <mauke> @hackage zenc
17:12:23 <lambdabot> http://hackage.haskell.org/package/zenc
17:12:31 <edwardk> parcs`: if you load it up and do some basic calculations it'll crap out because the memory locations it links to for the GMP allocator goes to the wrong place or something IIRC
17:13:07 <rwbarton> oh great, the source has its own version number baked in
17:13:19 <edwardk> or rather it makes a space in memory to write the address to, and then before using it makes sure its populated, but the address it gets is out in unmapped memory somewhere, not in a ,bss segment like i'd expect
17:14:01 <edwardk> so i have a sinking suspicion it has something to do with the ad hoc linker that is buried down in the RTS. copumpkin and i spent a long time trying to chase down the bug
17:14:51 <saml> haskell has bugs
17:14:52 <edwardk> talking to luite he mentioned there was a case where they were mmapping memory with a 32 bit pointer instead of a 64 bit one by mistake so it was getting truncated and put in the wrong place or some such once before in another place inside that linker, so it is possible that we found another such bug
17:15:20 <edwardk> saml: 'rounded' does horrible things that take it pretty far outside of warrantee ;)
17:15:26 <luite> it's the offsets in the OS X structure for the segments that are 32 bit
17:15:39 <edwardk> what luite said ;)
17:16:35 <edwardk> parcs`: that is my best guess as to what is going wrong. i think copumpkin's version of the repo is at the best state to resume work, mine was loaded with one-off debugging hacks at last check
17:16:54 <lispy> shachaf: send me patches, zenc should be on github
17:17:08 <lispy> shachaf: https://github.com/dagit/zenc
17:17:36 * bgamari wishes we could kill the RTS linker
17:17:39 <simpson> lispy: Oh snap, you live in Portland? I'm down in Corvallis at the OSL.
17:17:51 <bgamari> it's a huge investment to write a linker for a new platform
17:17:52 <lispy> simpson: cool. Corvallis is a nice place.
17:17:59 <simpson> lispy: Yep. Nice and quiet.
17:18:15 <bgamari> given the 64-bit ARM systems that are coming down the line, we'll have to write another one soon as well
17:18:24 <lispy> bgamari: yeah, and the RTS linker doesn't seem to work on win64 yet :(
17:18:46 <bgamari> ouch
17:18:50 <lispy> bgamari: it works for many things but not enough to link the network package
17:19:06 <nyc> I used to live in Portland, but am now in the city corresponding to my initials.
17:19:30 <lispy> nyc: that's one way to choose your home :)
17:19:47 <hpc> my initials are JMQ
17:19:51 <hpc> i live in a distant galaxy
17:19:52 <nyc> lispy: I chose my name for the city not vice-versa.
17:20:07 <saml> my initials are WS
17:23:45 <lispy> shachaf: I threw that package on hackage simply because I needed it for something else. It would be great for it to see some use (maybe a lambdabot plugin?)
17:27:34 <parcs`> edwardk: ok, thanks. though i'm getting erroneous results for 'main = print (pi :: Rounded TowardZero Double)' when running the compiled executable
17:27:52 <edwardk> parcs`: what platform are you on?
17:28:07 <parcs`> linux, x86-64
17:28:45 <edwardk> i have no idea if the system we're using to hack the build together will work for linux at all
17:28:57 <edwardk> that was something we were going to fix after osx
17:29:19 <parcs`> ah, ok
17:29:45 <edwardk> because we were basically trying to piggy-back on the original autoconf. using its autconf to build most of the settings for the platform, and then getting it to spit out a custom buildinfo for haskell
17:29:59 <edwardk> and then building the files the rest of the way from there
17:30:28 <edwardk> by letting cabal link them all in using the flags we learned from autoconf with some tweaking
17:31:14 <edwardk> a couple of patches ago you'll find a version that tries to run the autoconf to build a slightly patched copy of mpfr completely and then tries to move the object files into the right archive
17:31:23 <edwardk> we decided we didn't like that approach so much
17:31:35 <edwardk> (mainly because we never got it to work!)
17:32:10 <parcs`> why do you need to patch mpfr?
17:32:13 <edwardk> so what we got was a library where the code worked, but it referenced a library/archive that was in the cabal install dir
17:32:35 <edwardk> because mpfr internally maintains a number of caches for things like pi, log 2, e, etc.
17:32:51 <edwardk> and it allocated them by calling the GMP custom allocator
17:33:01 <edwardk> but GHC never sees those internal high precision caches
17:33:19 <edwardk> so its hooked allocator starts throwing away the backing stores for those caches
17:33:42 <edwardk> remember we hook the GMP allocator for GHCs purposes
17:34:20 <edwardk> so copumpkin hacked up mpfr to manage the caches more explicitly using malloc to allocate the limbs, etc for the caches. rather than the GMP allocator.
17:34:25 <edwardk> this means those caches are safe
17:34:37 <edwardk> but it required a custom MPFR build
17:36:05 <edwardk> previously he had made a custom allocation hook for GMP and was installing that by hand. the problem _there_ is that ghci doesn't call initializers for c++ libraries, etc. when it loads something, so we couldn't hook the library so that when you linked in rounded that the GHC allocator was swapped out for the hacked GHC allocator that included exceptions for the caches
17:36:46 <edwardk> also we had crazy loading-order issues when we tried to use it in ghc rather than ghci. copumpkin figured out a hack that seemed to work, but we never had a proof
17:37:00 <aristid> sounds like fun
17:37:21 <luite> btw anyone interested in writing a gmp clone in javascript ;)
17:37:24 <parcs`> i see
17:37:30 <parcs`> (what have i gotten myself into :P)
17:37:33 <aristid> luite: um
17:37:52 <aristid> luite: i guess in order to support Integer in ghcjs?
17:38:03 <luite> yes
17:38:15 <JoeyA> Just add big integer support to the browsers!
17:38:19 <hpaste> rwbarton annotated “ghc-dup” with “ghc-dup (annotation)” at http://hpaste.org/77799#a77801
17:38:28 <edwardk> parcs`: we expended quite a bit of brainpower on this thing, to little productive gain i admit
17:38:33 <rwbarton> @tell shachaf got it to do something http://hpaste.org/77799#a77801
17:38:34 <lambdabot> Consider it noted.
17:39:32 <luite> yay after a day of debugging, ghcjs now gives the right answer for  length "abc"
17:39:35 <aristid> edwardk: there's no alternative to mpfr that is less problematic?
17:39:53 <edwardk> nada
17:39:53 <rwbarton> luite: what answer did it give before
17:39:57 <aristid> luite: what did it give before?
17:40:08 <aristid> rwbarton: oO
17:40:14 <luite> uh, exception, pointer expected at 10004
17:40:16 <edwardk> in theory if we could get the MPFR guys to manage their caches like we do we could avoid the custom build at least.
17:40:30 <edwardk> that would require getting something like copumpkin's mpfr patches into MPFR mainline
17:40:42 <aristid> luite: sounds like something you don't usually want to happene.
17:40:44 <edwardk> they'd probably need to be cleaned up and documented and better motivated
17:40:53 <luite> rwbarton: that line is actually more complex than it looks, because it involves the whole utf8 decoding of a cstring to a list
17:41:11 <rwbarton> right
17:41:37 <edwardk> parcs`: i think at this point that may be the best path forward, honestly. then the build process for rounded becomes trivial
17:44:20 <aristid> edwardk: the problem with gmp floats is that they round wrong, i guess? (just guessing because mpfr advertises correct rounding)
17:44:34 <edwardk> aristid: yes
17:44:58 <edwardk> my issue is i need properly rounded floating point for interval arithmetic, otherwise the interval is more of a guideline than a real bound
17:46:18 <edwardk> you round up the calculation on the upper bound, down the calculation on the lower bound and then the answers lie in the middle
17:47:09 <edwardk> of course interval arithmetic sucks, so we instead like to work with truncated taylor series approximations of functions, where the remaining slop is captured in an interval rather than work with intervals directly
17:48:01 <mm_freak> edwardk: sounds like you're trying to implement naive arithmetic coding
17:48:41 <edwardk> nah, its more like complicated solve differential equations with very tight bounds on the answers
17:49:26 <edwardk> these models have lots of uses in physics where you can have millions of terms canceling nearly completely
17:50:44 <edwardk> martin berz won all sorts of awards for using them for solving problems like this that arise when working with particle accelerators
17:51:07 <Sonarpulse> I read somewhere that module names also represent a special sort of type, can anybody explain what's going on?
17:51:23 <edwardk> sadly the main library he has for this is closed source and academic only, etc. so i've been forced to reinvent everything =(
17:51:46 <mm_freak> edwardk: does the range not suffice or the precision?
17:52:01 <JoeyA> Sonarpulse: Was that about Haskell?
17:52:59 <mm_freak> Sonarpulse: if that's about haskell, then nothing…  modules are really just separate units of compilation with their own namespaces
17:53:37 <geekosaur> Module names do not represent a sort of type; they do however live in a related namespace to types, insofar as they must start with uppercase letters
17:53:45 <Sonarpulse> ok
17:54:23 <edwardk> mm_freak: well, you just tune the number of terms you take from the taylor series to avoid the error blowing up too badly. the error in interval arithmetic grows linearly with the number of additions, and more explosively for other operations, but with the taylor model that is a vanishingly small interval to start with, so we can bound the errors in practice by just taking enough terms and using enough bits to cover the accreted error
17:54:23 <Sonarpulse> http://www.haskell.org/tutorial/modules.html
17:54:33 <Sonarpulse> this is what I saw
17:54:40 <edwardk> but the goal is to know the answer lies in the resulting interval and make the interval as small as possible
17:54:46 <Sonarpulse> it talks about modules and "abstract data types"
17:55:19 <edwardk> the range is fine though
17:55:59 <edwardk> the worst thing that can happen is you get an answer that the answer is within the entire universe, and you add more bits or more terms =P
17:56:26 <rwbarton> Sonarpulse: you can make a type abstract by hiding its definition inside a module and only exporting particular functions that work with the type
17:56:35 <rwbarton> that doesn't mean the module is itself any kind of type though
17:56:50 <Sonarpulse> ok, so it's just a single use of hiding stuff then
17:57:00 <Sonarpulse> that makes more sense
17:57:03 <edwardk> more terms means more derivatives, which is why i added the 'dense' mode to my 'ad' package, to optimize the amount of work done for high derivatives of k-ary functions
17:57:37 <Sonarpulse> reading it more closely this time I'm not sure why the page would consider that a "distinct purpose"
18:01:38 <Sonarpulse> thanks
18:02:41 <mm_freak> nand`: if the underlying C library uses destructive update, you can't really encode this as a wire nicely
18:02:52 <mm_freak> so netwire is probably the wrong choice there
18:06:57 <alang> edwardk: do you have a github repo for this stuff you're working on?
18:07:12 <edwardk> which stuff? the taylor model stuff?
18:08:00 <alang> yes
18:08:24 <mm_freak> nand`: however, you can have impure wires by using the underlying monads…  for an example of such a wire see the noiseM wire in Control.Wire.Prefab.Noise
18:08:31 <edwardk> the taylor model work hasn't yet hit github. i'm thinking about releasing something with a DSL for playing with ito processes or DAEs, but I haven't gotten to a point where i like any API =/
18:09:00 <YayMe> Does anybody here have experience with nearlyfreespeech.net hosting?
18:09:52 <edwardk> DAEs are nice for things like modelica where they can wire them up by defining connectors, etc. but that doesn't fit the functional model as well, and once you throw in the stochastic component they get messy
18:10:48 <alang> hmm I see
18:11:06 <edwardk> also, frankly the code i have for taylor models is pretty horrid because i never got around to finishing it, due to the lack of a usable MPFR binding
18:11:17 <edwardk> hence why i was shaving that yak
18:11:19 <edwardk> =)
18:12:02 <edwardk> once i give up and go stochastic, it becomes relevant to entirely different domains of course, and i no longer care about proper rounding, as i can't give certified answer envelopes anymore, etc.
18:12:18 <edwardk> so the need for taylor models goes out the window
18:13:41 <edwardk> but i'm still getting my head around what the impact of switching to stochastic ODEs/DAEs have on the taylor series approximations. the nice thing about those was i could just throw AD at the problem.
18:13:47 <aristid> edwardk: this is all for financial models i presume? i mean, capital iq != cosmology iq
18:14:02 <edwardk> aristid: this isn't for capital iq. this is for me being bored at home.
18:14:08 <aristid> edwardk: oh
18:14:18 <edwardk> capital iq might have guys somewhere who care about this stuff, but i'm not on that team ;)
18:14:46 <JoeyA> Ah, so that's why you need to learn differential equations to do computer science!
18:14:55 <aristid> edwardk: why would you do things that involve mpfr for fun? :P
18:14:58 <JoeyA> Something to do on a rainy day :-)
18:14:59 <liyang> YayMe: yes, I recommend it.
18:14:59 <lambdabot> liyang: You have 1 new message. '/msg lambdabot @messages' to read it.
18:15:14 <nyc> edwardk: Stochastic DAE's and PDAE's have very different sorts of error bounds.
18:15:35 <edwardk> nyc: so i've been learning =)
18:16:01 <nyc> edwardk: Also different and (to me) difficult convergence, asymptotics, et al.
18:16:07 <edwardk> i only recently decided to get serious about exploring the state of stochastic DAEs. I knew enough to muddle through the stochastic ODE stuff before
18:16:23 <edwardk> so i'm still looking for literature
18:16:44 <edwardk> i'm also relatively new to DAEs in general.
18:17:01 <nyc> edwardk: I'm mostly still lost in stochastic ODE territory. I'm also rather ignorant of DAE's.
18:17:05 <copumpkin> http://www.reddit.com/r/DAE
18:17:15 * copumpkin runs
18:17:29 <monochrom> haha
18:17:32 <liyang> edwardk: oh, I saw that. Thanks!
18:17:40 <cmccann> copumpkin, that was terrible and you should feel terrible
18:17:48 <cmccann> :P
18:17:52 <monochrom> should we post there "does anybody else use Haskell?"?
18:17:53 <copumpkin> YayMe: I recommend it too
18:18:06 <copumpkin> does anybody else use differential algebraic equations?
18:18:13 <copumpkin> (probably not)
18:18:18 <aristid> cmccann: as far as weird copumpkin links goes, this one is rather harmless
18:18:26 * cmccann can't argue with that
18:18:44 <edwardk> heretofore what little i've neeeded i've been able to keep in ODE/PDE territory, but after the last boston haskell, alexey radul earwormed me about Modelica, which was great timing for me, because the design is like a much more mature version of a little DSL i keep playing with.
18:18:45 <monochrom> "does anybody else reply to exactly those who don't reply to themselves on reddit/r/DAE?"
18:18:50 <YayMe> copumpkin liyang: It supports "fastcgi" so I'm assuming it means it supports yesod? Do you know which server they use; nginx or apache?
18:19:09 <copumpkin> I'm not sure you could run yesod on there
18:19:11 <YayMe> I'm trying to start setting up my local to put together a site I plan to host with them, want to make sure I put it together locally correctly
18:19:17 <liyang> YayMe: ah, no. I don't believe in dynamic websites.
18:19:40 <copumpkin> static types, static sites
18:19:47 * copumpkin sits still
18:19:49 <liyang> copumpkin: yes, I eat strategically.
18:19:49 <YayMe> copumpkin: You only use static with them?
18:20:07 <copumpkin> YayMe: yeah, and they don't let you run arbitrary processes so I doubt you could do yesod
18:20:07 <monochrom> does anybody else believe in dynamic websites?
18:20:14 <YayMe> They're the only host I've found that claims to support haskell without doing a VPS
18:20:24 <copumpkin> oh really?
18:20:29 <YayMe> it says it supports haskell with FastCGI
18:20:31 <copumpkin> I haven't looked carefully in a couple of years
18:20:37 <copumpkin> I guess I'm wrong :)
18:20:44 <YayMe> the only haskell FastCGI ties I know are yesods but I'm guessing their may be others
18:20:53 <liyang> YayMe: I'm not against client-side AJAX &c., just against server-side dynamic websites that don't need to be.
18:21:12 <copumpkin> liyang: but dude, I have a CMS to run my blog
18:21:15 <copumpkin> !!!
18:21:16 <aristid> YayMe: why not just do a VPS?
18:21:28 <YayMe> aristid: nearlyfreespeech is much cheaper
18:21:32 <aristid> copumpkin: you should use hakyll and s3 for your blags
18:21:56 <copumpkin> if only I had a blog!
18:22:15 <YayMe> aristid: shared compute space means it's only costing the CPU cycles it uses, VPS means it uses CPU cycles when idle
18:22:51 <aristid> YayMe: while that is true, a vps also means you can decide which version of ghc to run...
18:23:22 <YayMe> aristid: while that is true, I'm not talking a difference of a few bucks, I'm talking a difference of $3-4 a month vs $40-80 a month
18:23:39 <aristid> YayMe: wait a moment, a VPS does NOT cost $40
18:23:46 <copumpkin> lol
18:23:56 <YayMe> aristic: last time I tried to price one out it came somewhere in that range
18:24:10 <YayMe> aristid: If you know something i don't, *please* share
18:24:10 <copumpkin> I pay $20 for slicehost
18:24:17 <copumpkin> and I was paying less than that for prgmr
18:24:26 <copumpkin> much less
18:24:34 <monochrom> $20 and $4 still a big gap
18:25:03 <YayMe> copumpkin: And that's always up? I don't mean like guaranteed uptime, I just mean that amount monthly meant you got your vps to be on full time?
18:25:11 <copumpkin> yup
18:25:17 <copumpkin> it's been on nonstop for the past several years
18:25:22 <aristid> YayMe: when did you last research this stuff?
18:25:24 <copumpkin> I barely use it but some friends use it regularly
18:25:32 <aristid> hi shapr
18:25:35 <copumpkin> so I keep paying for their sake
18:26:01 <YayMe> aristid: I didn't dig *too* deeply, but I also may have been confused by the bloody terrible salesmanship of the vps stuff I looked at (it was *really* not clear how much it would cost)
18:26:27 <aristid> YayMe: while not cheap, this one is good: www.linode.com
18:26:32 * liyang liked NFS's approach on that aspect.
18:26:39 <aristid> and still only $20
18:26:51 <liyang> They tell you exactly what you get and that's what you pay for.
18:27:14 <copumpkin> prgmr is $5/mo for 64mb/1.5g//10g/mo
18:27:23 <copumpkin> or $48 if you prepay for a year
18:27:27 <YayMe> aristid: I don't want good, I want cheap. I want a site that has a database backend with haskell front end and is up 24/7 without having to self-host.
18:27:42 <aristid> YayMe: and the database is tiny?
18:27:46 <rwbarton> 64mb? of ram?
18:27:49 <YayMe> aristid: yep
18:27:49 <copumpkin> yeah
18:28:00 <aristid> YayMe: then prgmr might work
18:28:02 <copumpkin> rwbarton: you can pay more for more RAM :P
18:28:06 <rwbarton> yeah
18:28:14 <copumpkin> for $8 a month you get a respectable 245
18:28:15 <rwbarton> rackspace is $16/mo for 512 MB
18:28:15 <copumpkin> 256
18:28:24 <YayMe> aristid: Personal use junk, if I wanted something for more than personal use I'd make sure to secure an income stream for it to get a real host
18:28:44 <rwbarton> copumpkin: I was hoping it was really 245
18:28:50 <YayMe> ....maybe I should just self-host...
18:28:53 <rwbarton> like my amazon micro instance had 908 MB I think
18:28:56 <copumpkin> lol
18:28:57 <copumpkin> weird
18:29:00 <rwbarton> yeah
18:29:37 <YayMe> aristid: 64mb of what? Disk? 1.5g of ram? 10g of bandwidth?
18:29:41 <aristid> ram
18:29:53 <aristid> YayMe: also ask copumpkin, not me, he quoted those numbers
18:30:02 <rwbarton> EC2 was such a pain though because I kept doing dumb things to minimize disk accesses
18:30:03 <copumpkin> prgmr.com
18:30:05 <YayMe> rwbarton: how much does your micro cost if left on 24/7?
18:30:10 <rwbarton> I forget
18:30:14 <rwbarton> I shut it down
18:30:25 <aristid> YayMe: a micro can be made much cheaper by using reserved instances
18:30:27 * shapr grumbles
18:30:35 <rwbarton> but somewhere in $10-20/mo I think?
18:30:37 <aristid> YayMe: but that requires prepaying for a significant amount of time
18:30:51 <shapr> I seriously have to sit in the hallway to get wifi at this conference, no internet in my hotel room :-(
18:30:52 <aristid> an on-demand micro is about $15-$20, yea
18:30:57 <rwbarton> EC2 support is nightmarish
18:30:57 <YayMe> aristid: but it's still considerably more expensive than the few bucks a month nearly free speech costs? (which as I established does support haskell)
18:31:18 <aristid> YayMe: ec2 micro will NOT be the cheapest option
18:31:28 <YayMe> k
18:31:46 <rwbarton> except if they still have that free for a year deal
18:31:51 <aristid> i'm typing these words from a micro tho
18:31:55 <aristid> oh yeah they do
18:32:05 <aristid> YayMe: you can just take the ec2 micro and then move on
18:32:09 <YayMe> I think I'll just e-mail nearly free speech and ask them if their "fastCGI Haskell support" means yesod, and if so I can put my site together with yesod and figure out the hosting after it's made
18:32:10 <rwbarton> then it will be the cheapest for a year :)
18:32:37 <YayMe> decide if I want to use nearly free speech or this prgmr after it's made if nearly free speech supports yesod
18:32:47 <aristid> rwbarton: i always forget that because i signed up to aws before the free for a year deal came up
18:32:58 <aristid> rwbarton: i was actually quite annoyed at getting in on it :D
18:33:04 <aristid> *at NOT
18:33:52 <aristid> YayMe: there are other very cheap vps by the way. well, but on the other hand nfs is reputable, right? many of these cheap vps hosts are not
18:34:17 <simpson> TANSTAAFL.
18:34:48 <shapr> How can I write Haskell code witout wifis?!
18:34:55 <YayMe> yeah, there is the reputable thing, reading through nfs they sound like a great company
18:35:12 <aristid> shapr: by downloading the whole hackage onto your hard disk first!@
18:35:29 <YayMe> shapr: imagine what the code would do if it worked?
18:35:44 <shapr> I like aristid's suggestion better :-P
18:35:48 <monochrom> a long time ago, Richard Bird wrote Haskell code without wifi. he also wrote pointfree Haskell code. perhaps that's his secret!
18:36:25 <shapr> Yah, but he wrote a book first, and then he could read the book to himself, right?
18:36:28 <monochrom> Phil Wadler wrote monad code without wifi
18:36:53 <shapr> monochrom: point
18:38:00 * shapr frees the point
18:39:13 <aristid> shapr: the puns, they are lazy but infinite .oO(bad one :/)
18:39:50 <shapr> haha
18:41:24 <YayMe> Anyone here have much experience with yesod?
18:43:03 <aristid> YayMe: there's #yesod :)
18:43:18 <YayMe> Yeah, in there now heh
18:46:43 <YayMe> after a little further thought, I'm pondering to myself why I don't just self-host?
18:47:00 <YayMe> Not like I'm expecting any form of real traffic...
18:48:08 <aristid> YayMe: do you have a machine that's running 24/7?
18:49:10 * hackagebot repa 3.2.2.3 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.2.3 (BenLippmeier)
18:49:12 * hackagebot repa-algorithms 3.2.2.3 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.2.3 (BenLippmeier)
18:50:21 <YayMe> aristid: for $60 I could
18:51:43 <YayMe> aristid: hell if yesod will run on arm and mysql will I could just use an rPi
18:53:48 <aristid> YayMe: do you pay for your own power? :P
18:54:10 * hackagebot repa-io 3.2.2.3 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.2.3 (BenLippmeier)
18:55:50 <aristid> YayMe: just asking because if you pay $5 in power costs, you may as well get a $5 vps instead ;)
19:05:07 <YayMe> true
19:09:10 * hackagebot gloss 1.7.6.6 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.6.6 (BenLippmeier)
19:14:12 * hackagebot gloss-raster 1.7.7.2 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.7.2 (BenLippmeier)
19:14:14 * hackagebot gloss-examples 1.7.7.2 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.7.2 (BenLippmeier)
19:16:26 <yoyo12> hi folks
19:17:09 <yoyo12> i'm a noob. when compiling i get "Non-exhaustive patterns in function". Using guards doesn't protect against this?
19:18:24 <rwbarton> not in general, why would it?
19:18:53 <rwbarton> depending on how you write your guards the compiler may not be able to tell that the function is in fact exhaustive
19:19:09 <yoyo12> i'm trying to define my own "insert" but doesn't seem to work
19:19:21 <yoyo12> myinsert :: ([Integer], Integer, Integer) -> [Integer] myinsert_helper :: ([Integer], Integer, Integer, Integer, [Integer]) -> [Integer]  myinsert (listL, objectX, positionK) = myinsert_helper(listL, objectX, positionK, 0, []) myinsert_helper(l1:l1s, x, k, i, l2)      | i < k     = myinsert_helper(l1s, x, k, i + 1, l1:l2)     | i == k    = myinsert_helper(l1s, x, k, i + 1, l1:(x:l2))      | otherwise = []
19:19:54 <rwbarton> doesn't the compiler tell you what case you are missing?
19:20:08 <ParahSailin> @ty combine
19:20:10 <lambdabot> Not in scope: `combine'
19:20:22 <ParahSailin> @hoo combine
19:20:22 <lambdabot> Maybe you meant: hoogle hoogle+ do show todo yow
19:20:30 <yoyo12> whoops my bad, it compiles fine. but when i run the file that's when i get the non-exhaustive
19:20:30 <ParahSailin> @hoogle combine
19:20:31 <lambdabot> Graphics.Rendering.OpenGL.GL.Texturing.Environments Combine :: TextureFunction
19:20:31 <rwbarton> also please use @hpaste for pasting more than one line
19:20:31 <lambdabot> System.FilePath.Windows combine :: FilePath -> FilePath -> FilePath
19:20:31 <lambdabot> System.FilePath.Posix combine :: FilePath -> FilePath -> FilePath
19:20:35 <rwbarton> @where hpaste
19:20:35 <lambdabot> http://hpaste.org/
19:20:45 <rwbarton> ah, I see
19:20:50 <rwbarton> try compiling with -Wall, then it will tell you :)
19:21:46 <yoyo12> using ghc
19:22:01 <yoyo12> ghc -o lab2 lab2.hs -Wall  but nothing prints
19:22:31 <rwbarton> because you didn't modify the file I guess, either re-save lab.hs or build with -fforce-recomp
19:23:04 <monochrom> ghci -Wall lab2.hs
19:23:12 <rwbarton> -i
19:23:18 <danharaj> I have a strange problem where if I read an IO action from an IORef and execute it, it is only executed once.
19:23:39 <danharaj> even if I repeatedly read from it.
19:23:55 <rwbarton> or I guess you can use ghci -Wall too
19:24:07 <JoeyA> danharaj: Could you post a code sample demonstrating the problem?
19:24:10 <danharaj> nope
19:24:13 <hpaste> yoyo12 pasted “output error” at http://hpaste.org/77802
19:24:16 <danharaj> it is too complicatedly embedded :|
19:24:17 <JoeyA> Are you using unsafePerformIO or unsafeInterleaveIO?
19:24:19 <danharaj> no.
19:24:37 <monochrom> "Patterns not matched: ([], _, _, _, _)"
19:24:59 <yoyo12> Ah ok!
19:25:06 <ion> When you find yourself using 5-tuples you probably should not be using tuples.
19:25:12 <yoyo12> forgot to count the empty list
19:25:30 <monochrom> I just echo the error message
19:25:41 <monochrom> I am just a computer
19:25:43 <JoeyA> danharaj: If you have time, please do try to narrow down the problem.  It will likely be something very simple.
19:26:25 <geekosaur> or maybe the 5-tuple is because they are still treating haskell like other languages in terms of how functions work
19:26:49 <ion> What i said would still apply. :-P
19:28:10 <monochrom> perhaps currying is a very uncommon idea
19:28:59 <JoeyA> danharaj: Some things to try: 1) Different versions of GHC  2) -O0 or -O2  3) -fno-state-hack
19:31:05 <monochrom> recently I encountered -fno-state-hack too, but it was just for (evaluate ((x:undefined) `deepseq` putStrLn "hi"))
19:32:13 <JoeyA> Eww, that fails?
19:32:53 <monochrom> it did not run into the undefined, unless -fno-state-hack
19:34:11 * hackagebot husk-scheme 3.6.1 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.6.1 (JustinEthier)
19:34:57 <monochrom> http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/22766/focus=22792
19:36:01 <monochrom> of course, I do not write such code for real
19:38:07 <danharaj> maybe I can provide context as I go, because everything I try to extract the problem makes it disappear.
19:38:26 <danharaj> http://hpaste.org/77803
19:38:55 <danharaj> The problem is: I have a loop that should call line 30 repeatedly, but only calls it once.
19:39:15 <danharaj> the loop is forever $ do ...; view w; ...
19:41:36 <danharaj> I tried to make a simpler version but it didn't break ._.
19:42:20 <startling> > foldr (+) a [b, c, d]
19:42:22 <lambdabot>   b + (c + (d + a))
19:42:35 <startling> > foldl (+) a [b, c, d]
19:42:37 <lambdabot>   a + b + c + d
19:43:06 <monochrom> you are saying you expect "test" printed many times? but that's a wrong expectation
19:43:43 <monochrom> desugar <$> to see why
19:44:03 <monochrom> x <- liftIO (print "test" >> atomicModifyIORef' h (\g -> (g, extract g)))
19:44:05 <monochrom> ...
19:44:11 * hackagebot chu2 2012.11.16 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.16 (JinjingWang)
19:44:11 <monochrom> return (Widget x ...)
19:44:13 * hackagebot chu2 2012.11.16.1 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.16.1 (JinjingWang)
19:44:22 <monochrom> that's what you have after desugaring <$>
19:45:06 <danharaj> monochrom: yes, and the first argument to Widget is a monadic value.
19:45:27 <monochrom> but what is in that value?
19:45:55 <monochrom> something to do with g0, w0. but I don't see (print "test") in g0, w0
19:46:30 <statusfailed> Where's the MonadPlus instance for [] ?
19:46:50 <danharaj> Yes, but I'm taking the x in (Widget x ...) out with `view` and using it in an IO loop.
19:47:15 <monochrom> I'm saying, that x does not contain (print "test")
19:47:34 <danharaj> oh I see now.
19:47:39 <danharaj> derp.
19:47:40 <statusfailed> oh, Control.Monad
19:49:04 <danharaj> This is what happens when you refactor code in a confused way.
19:49:15 <danharaj> (I had a working alternative implementation 10 minutes ago)
19:49:42 <monochrom> refactor is good. use symbolic, mechanical methods to refactor. do not "understand"
19:51:15 <monochrom> symbolic, mechanical methods are based on program transformation laws that are proved correct
19:51:23 <danharaj> It was more of a rewrite than a refactor
19:51:32 <monochrom> "understanding" is based on ambiguous natural languages that are proved incorrect
19:51:51 <monochrom> that's fine, s/refactor/rewrite/
19:52:22 <statusfailed> What's the category-theoretic name for (f a -> f' a)? is it a natural transformation?
19:52:45 <cmccann> alternatively, you can refactor without automation OR understanding, a surprisingly common practice
19:52:54 <cmccann> and an excellent way to fix working code until it breaks
19:53:01 <monochrom> haha
19:53:26 <monochrom> but symbolic, mechanical does not require automation. you can do it by hand
19:53:44 <cmccann> well yeah, true
19:53:44 <monochrom> "map f . map g = map (f . g)" is an example
19:53:57 <rwbarton> statusfailed: assuming f and f' are fixed Functors and a is universally quantified, yes
19:54:46 <statusfailed> rwbarton: so in Haskell I need to write forall a. (Functor f, Functor f') => f a -> f' a ?
19:54:57 <statusfailed> Why do I need the forall?
19:55:01 <rwbarton> more like... forall a. Maybe a -> [a]
19:55:10 <rwbarton> is a natural transformation from Maybe to []
19:55:11 <danharaj> monochrom: alternatively, I peeled a layer of monad in the wrong way.
19:56:17 <statusfailed> rwbarton: yeah, I remembered listToMaybe was one :)
19:56:20 <rwbarton> statusfailed: or in haskell you can write: newtype Nat f f' = Nat (forall a. f a -> f' a)
19:56:34 <statusfailed> ok now you'v elost me :p
19:56:43 <statusfailed> oh no I get you
19:56:50 <rwbarton> then Nat f f' is the type of natural transformation from f to f', for any particular f and f'
19:58:00 <danharaj> monochrom: What I wrote peeled a layer off at the time Widget is made. What I wanted was (join (liftIO (atomicModifyIORef'...))) which is correct.
19:59:12 <rolling> 4342580006590251 0413 400 DECLINED! BANK: | VISA | BANK OF AMERICA | DEBIT | CLASSIC | UNITED STATES | USA | 840 | WWW.BANKOFAMERICA.COM/ | (800) 869-3557 | | |
20:10:00 <lispy> hello
20:11:03 <danharaj> hi
20:12:08 <lispy> I always thought (until recently) that having a small core internal language was more about elegance and giving up what you don't need.
20:12:27 <lispy> I've recently realized, it also has a lot to do with economy of time needed to implement tools for your language.
20:12:33 <simpson> Yes.
20:12:49 <shachaf> @messages
20:12:49 <lambdabot> rwbarton said 2h 34m 15s ago: got it to do something http://hpaste.org/77799#a77801
20:12:55 <shachaf> rwbarton: do something = hang?
20:13:19 <lispy> ?let something = text "hang"
20:13:20 <lispy> > do something
20:13:21 <lambdabot>  Defined.
20:13:23 <lambdabot>   hang
20:13:25 <lispy> shachaf: looks like
20:13:35 <shachaf> > let something = something in do something
20:13:39 <lambdabot>   mueval-core: Time limit exceeded
20:13:42 <shachaf> That's more what I'm seeing.
20:14:39 <lispy> I've been working with a generic term representation for the abstract syntax of Fortran
20:14:46 <lispy> Sometimes I feel like it's death by cases
20:15:05 <lispy> Partly because I'm not using a proper ADT
20:15:55 <lispy> I would probably be happier if I converted my generic aterm representation into a concrete Haskell ADT and then processed that. I could, for example, "desugar" it and also throw away things I don't need.
20:16:24 <lispy> When I was that that point in my design I thought, "Nah, it's faster to just keep working with aterm"
20:21:17 <rwbarton> shachaf: no, it did what I would expect
20:21:25 <rwbarton> did you enter a number?
20:22:00 <shachaf> rwbarton: ...OK, that was silly of me.
20:22:04 * shachaf didn't actually read the code.
20:22:29 <rwbarton> i got sick of trying to get the compiler not to move things to top-level
20:22:39 <rwbarton> (rather quickly)
20:22:52 <shachaf> OK, so it works with -prof
20:22:56 <rwbarton> yep
20:23:00 <shachaf> And segfaults without -prof
20:23:19 <rwbarton> i divined that it might by printf-debugging the problem down to a Cmm primop that had something to do with profiling
20:23:23 <parcs`> @check True
20:23:25 <lambdabot>   Not in scope: `myquickcheck'
20:23:59 <rwbarton> if you're curious, it was whatever the third line of that ALLOC_something macro did
20:24:17 <rwbarton> oh yeah, apparently CCS stands for call-center stack or so
20:24:51 <shachaf> rwbarton++ # printf-debugging so I don't have to
20:25:06 <shachaf> I think I won't start using ghc-dup in my code just yet.
20:25:25 <rwbarton> but it totally worked! after only an hour or so
20:25:37 <rwbarton> and once I used a test case that was exactly like the one in the paper
20:27:34 <rwbarton> I think deepDup still didn't work, though. I forget
21:12:56 <hpaste> statusfailed pasted “can't get maybeM function to typecheck” at http://hpaste.org/77804
21:13:07 <statusfailed> Can anyone help me get that to typecheck?
21:13:52 <statusfailed> I'm trying to write a "slightly more general" version of the "maybe" function (but I don't think it's useful anymore :P)
21:14:28 <SamanthaAD> I just wanted to thank the people who helped me yesterday. I finally think I understand how monads are used in the language, though I still don't grasp how they preserve Haskell's functional purity.
21:17:21 <startling> SamanthaAD, it's really simple. IO doesn't do anything special, it just makes a tree of computations to perform later. Making the tree is pure.
21:17:48 <startling> SamanthaAD, then the compiler finds the root of the tree ("main") and compiles it into a program.
21:18:15 <startling> Monads aren't inherently special, IO is special-cased.
21:18:35 <arbn> SamanthaAD: It's kind of a hack. Describing the IO is pure, so the "language" is pure. The program obviously isn't purely functional, but we described it with only pure functions.
21:18:42 <SamanthaAD> startling: So what you're saying is that the function that creates the IO monad is still pure because the IO monad hasn't actually been executed yet. It just passes the monad back AS AN OBJECT and because the funtion would have passed the exact same monad back every single time it's still pure...
21:18:54 <startling> SamanthaAD: yes
21:19:15 <SamanthaAD> ... I think I finally am beginning to understand it!
21:19:31 <startling> Monad isn't special, it's just a really nice way to compose a tree of computations.
21:19:40 <SamanthaAD> I've been struggling with the "what" regarding a monad for the last week and I've got a shaky understanding of what they are but I never understood the why
21:19:50 <statusfailed> bos: Did you get my email about the riak package by any chance?
21:20:49 <SamanthaAD> So... in Haskell you can have impure parts of the code--that is parts of the code that are imperitive. What the IO monad does is it allows us to create impure code in a pure environment which can then be spat out of the pure functional environment, executed, and sent back in.
21:21:20 <startling> not quite. it's more like the impure code calls into the pure code
21:21:37 <SamanthaAD> startling: damn, now I'm confused again
21:22:12 <SamanthaAD> startling: do you mean that the impure code is returned from the pure code, executed, and then the impure code then calls more pure code?
21:24:17 <arbn> SamanthaAD: Everything in the Haskell language is a pure function. There is no impure part of a Haskell program. However, we can use pure functions to instruct an impure computation, so it gets its orders from our monadic, pure description of something impure.
21:25:20 <SamanthaAD> arbn: Alright, that makes a bit of sense. Thank you.
21:25:44 <johnw> SamanthaAD: Thank of the `main' function, which is in the IO monad, as using pure code to "construct" a composite IO action.  Once this is done, there is a executor behind the scenes -- which you never see -- that renders the IO action down to its final value, by doing things that are invisible to pure code.
21:27:50 <johnw> that not exactly what happens in your final compiled executable -- there is "VM" here -- but it can be viewed that way.  A function that return IO Int is not an impure function "doing something", it's a pure function that constructs an IO "action" that yields an Int, which will be executed at runtime to produce that integer
21:27:59 <johnw> s/is no "VM"
21:28:03 <johnw> man, I really can't type tonight
21:28:43 <Cale> Not everything in Haskell is a pure function
21:28:49 <Cale> Because not everything in Haskell is a function.
21:28:55 <Cale> main is not a function, it's an IO action
21:29:05 <johnw> ah, yes, you're right
21:29:11 <johnw> i keep making that mistake from my C background
21:29:16 <SamanthaAD> johnw: I think I understand what you're saying. We can create the IO monad purely because functional code will always create the same monad with the same contents because the functions have the same parameters each time. But then that monad is able to get passed behind-the-scenes where it can do impure things before returning a value.
21:29:16 <johnw> main is a value
21:29:21 <johnw> er, the name of a value
21:29:37 <johnw> SamanthaAD: exactly!
21:29:50 <SamanthaAD> johnw: Hooray!
21:29:51 <johnw> the "intent" of the IO action will always be identical
21:30:18 <johnw> btw, you might want to say "monadic value"
21:30:26 <SamanthaAD> johnw: That is a very elegant way of getting things done!
21:30:45 <Cale> yeah, "monad" refers to the type constructor -- IO is a monad, but getLine, for example, isn't
21:30:48 <johnw> "the monad" is IO itself, not specific actions of type IO a
21:30:52 <SamanthaAD> johnw: right, because the IO monad doesn't return a value, it just adds a value inside of it. (sorry if that's a bit convoluted)
21:31:36 <johnw> and just to further clarify, thinking of these things as "actions" is a good intuition for IO, but it may not serve you well when it comes to thinking of the other monads in Haskell
21:31:39 <Cale> The monad itself consists of three things: a type constructor M, a function return :: a -> M a, and a function (>>=) :: M a -> (a -> M b) -> M b
21:32:08 <johnw> SamanthaAD: right, values never escape from IO
21:32:14 <Cale> but usually when we say that "X is a monad" the X is the type constructor, and it's implicit that these operations are coming along with it
21:32:21 <SamanthaAD> Cale: Right, it has a type, a thingy to inject stuff with, and a thingy that spits things out.
21:32:36 <johnw> there is no thingy to spit things out
21:32:42 <SamanthaAD> Cale: sorry, a thingy that lets you chain it with another monad
21:32:50 <johnw> another monadic value, yes :)
21:32:53 <Cale> not another monad ;)
21:33:04 <Cale> There's only one monad here, which is M :)
21:33:06 <SamanthaAD> an interface to plug it with another monad
21:33:12 <johnw> not another monad
21:33:19 <johnw> another monad would like Maybe or []
21:33:25 <SamanthaAD> okay...
21:33:26 <Cale> (I know what you mean, I'm just being picky about words)
21:33:29 <johnw> IO values can only chain to other IO values
21:33:37 <johnw> yeah, it actually helps to be picky with words
21:33:45 <johnw> because then you can ask more efficient questions the next time around! :A)
21:34:00 <arbn> johnw: Which monads do you think are not well served by thinking of them as "actions" or contexts for computations?
21:34:08 <johnw> the Identity monad
21:34:09 <SamanthaAD> Cale: picky about words is good. I think I have what I need now. What I really needed to understand was the "why" behind the inclusion of the IO monad in Haskell. I'm really new to the concept and the language.
21:34:20 <arbn> johnw: Ahh. I see. Yeah.
21:34:24 <johnw> and the (,) e monad :)
21:34:38 <Cale> SamanthaAD: By the way, the fact that IO happens to be a monad is a bit of a red herring, if you ask me
21:34:52 <Cale> SamanthaAD: The important thing is that we have values which describe actions to be performed.
21:35:09 <SamanthaAD> Cale: from what I've seen Monads seem to be useful for doing purely functional things, too, and that IO is more of a hack using an already useful concept...
21:35:10 <johnw> arbn: oh, and most importantly, the Free Monad
21:35:13 <Cale> and the execution of those actions is separate from the evaluation of expressions
21:35:29 <johnw> the Free Monad is just that monad which does _not_ do any computation, by definition
21:35:48 <Cale> Um...
21:35:59 <johnw> am I wrong, Cale?
21:36:28 <Cale> johnw: That's in a way not wrong, but it's also probably not the most useful way to think of it.
21:36:39 <simpson> I thought that "free" was a specific property from category theory.
21:36:42 <johnw> I think of Free as a way to defer the *intent* behind "join"
21:36:44 <Cale> You can just as well think of values of the free monad as describing computations
21:36:53 <johnw> simpson: it is
21:37:01 <Cale> Or of *a* free monad, I should say, there are lots of them
21:37:06 <simpson> I remember edwardk once explained it as the simplest and most flexible structure, in some sense, which could still be a monad.
21:37:20 <johnw> Cale: true, describing computations, just not acting upon them
21:37:22 <startling> SamanthaAD, sorry, phone call. Take a look at Reader and State which also chain computations purely. State is pretty similar to IO
21:37:25 <johnw> which is what I thought arbn was asking
21:37:30 <arbn> I think the first monad one should learn would be something like State. Once I implemented State, I felt like I "got" monads 3x better.
21:37:38 <johnw> simpson: that's exactly right
21:37:44 <Cale> johnw: But then, a lot of monads can be thought of like that, and yet they might not be free.
21:37:52 <startling> arbn: yeah, me too.
21:37:53 <johnw> ah, that's a good point
21:38:04 <statusfailed> What's the definition of a free monad? :D
21:38:13 <SamanthaAD> startling: no worries, I had to leave last night before I wanted to, too. Johnw, arbn, and Cale have been really helpful!
21:38:35 <johnw> arbn: I would argue for Reader, and then State -- since State expands on the implementation of Reader
21:38:55 <arbn> johnw: Makes sense!
21:38:59 <arbn> johnw: I must admit I've not yet looked at any Free Monad. I probably should.
21:39:14 <SamanthaAD> startling: now they're off talking about something confusing that I don't understand again but which I can probably put off understanding until I feel comfortable with the basics.
21:39:27 <startling> SamanthaAD: that happens a lot in this channel. :)
21:39:40 <Cale> Yeah, I'd kind of rather discuss this point about IO and basic monads
21:39:58 <johnw> arbn: the Free Monad can be very powerful, since it lets you build a "two-pass" computation
21:40:35 <Cale> SamanthaAD: So, the Monad class can be thought of as just an API that lots of libraries happen to satisfy
21:40:42 <johnw> the "first pass" builds a description of the computation, as Cale stated, and then you can apply a "second pass" to interpret that description (maybe by rendering it into IO to achieve side-effects, who knows)
21:41:07 <johnw> SamanthaAD: you can most definitely put off learning about "free" things
21:41:29 <Cale> SamanthaAD: A lot of the libraries we write are of the form where we have some notion of a specific type of computation that we're discussing, in some domain.
21:41:35 <johnw> arbn: it's like having a language-level parser for any EDSL you want
21:41:41 <Cale> SamanthaAD: For example, let's say parsers
21:41:52 <startling> parsers are a really good example
21:41:54 <SamanthaAD> Cale: Yes, I'm starting to see that. Yesterday I came on the channel asking about what mathematical background I should be trying to pick up so I could understand the theory behind monads so maybe I could understand how they fixed the purity problem. I'm starting to see why people were able to tell me that I really don't need to understand the THEORY while still being able to understand the theory of their use.
21:42:05 <arbn> johnw: OK. I assume there's some blog post of wiki article about it. I'll have a look, with your description in mind. :)
21:42:11 <arbn> post or wiki*
21:42:22 <startling> SamanthaAD, that Monad is also a kind of mathematical object is a bit of a coincidence
21:42:32 <johnw> arbn: I wrote one: http://newartisans.com/2012/08/meta-programming-with-the-free-monad/
21:42:44 <Cale> SamanthaAD: and quite often those computations can have results, and we have some type constructor, like in our example of parsing, perhaps we have for each type t, some type Parser t, for parsers whose result has type t
21:43:13 <arbn> johnw: Aha. Thanks.
21:43:40 <johnw> SamanthaAD: if you find abstraction beautiful, you will love category theory.  Monad is not the place to start, however.  First go for "Functor"; when you're really comfortable with that, go for "Adjunction", and then let that lead you to "Monad".  Cale is still helping me to fully grasp Monads from the ground up
21:43:40 <Cale> SamanthaAD: and then in addition to that, we have some way to take an arbitrary value, and produce a computation which "does nothing" (whatever that means in context), and produces that result as its value
21:43:51 <Cale> produces that value as its result*
21:44:06 <Cale> and that's what "return" is
21:44:16 <SamanthaAD> Clae: That last thing would be kind of like the return monad?
21:44:24 <Cale> return isn't a monad
21:44:34 <SamanthaAD> Cale: eer, right...
21:44:40 <Cale> The type constructor, for example Parser in this case
21:44:41 <Cale> is the monad
21:44:44 <SamanthaAD> Cale: return creates a monad
21:44:49 <Cale> It doesn't
21:45:03 <Cale> return is part of the definition which makes Parser into a monad
21:45:10 <Cale> Monads live at the level of types
21:45:12 <Cale> not of values
21:45:17 <Cale> If something is a value, it's not a monad
21:45:35 <Cale> But it might have a type which involves a monad in some way
21:45:49 <Cale> For example, it might be a parser
21:45:51 <SamanthaAD> I see
21:46:02 <Cale> whose type is Parser Statement, say
21:46:10 <Cale> and Parser, at the type level, is a monad
21:46:13 <SamanthaAD> Cale: a value is a part of a monad (but a value can live without being inside a monad so the latter does not exclusively follow the former)
21:46:18 <johnw> SamanthaAD: return maps a -> m a, so on the level of usage it appears to "embed" a value in the current monad
21:46:45 <Cale> don't think of it like that though
21:46:49 <Cale> please :)
21:47:06 <johnw> Cale: why not?
21:47:08 <Cale> return takes a value, and makes a computation which "does nothing" except to produce that value as its result
21:47:19 <SamanthaAD> Cale: Don't think of a value as part of a monad? Or don't think of return as a thingy that embeds values in monads?
21:47:41 <johnw> I was thinking that embed here = makes a computation which "does nothing" except to produce that value as its result
21:48:29 <SamanthaAD> Cale: Oh, you beat me to it. Of course, I shouldn't think of return as embedding anything.
21:48:40 <johnw> but maybe you're right, it makes the notion of "current monad" much too vague
21:48:40 <Cale> Don't think of return as something which embeds values in monads -- it kind of does in a way, but it's better to think of it as something more specific
21:48:48 <johnw> ok
21:48:52 <startling> SamanthaAD, have you seen Maybe?
21:49:04 <Cale> Using terms like "lift" and "embed" etc. is great if you already know what you mean
21:49:13 <Cale> But it's unhelpful when trying to understand for the first time
21:49:14 <SamanthaAD> startling: I've seen it but I don't understand it yet.
21:49:17 <startling> SamanthaAD, data Maybe a = Just a | Nothing <- this represents a computation that can fail
21:49:27 <startling> SamanthaAD, return for Maybe is just Just.
21:49:32 <johnw> SamanthaAD: for the List monad, "return 10" creates the monadic value [10], which fits Cale's description
21:49:44 <johnw> Cale: I see, will do
21:50:07 <Cale> So, in the case of parsers, for example,
21:50:11 <Cale> return :: a -> Parser a
21:50:20 <startling> SamanthaAD, so return in Maybe creates a computation that's allowed to fail but never does
21:50:20 <Cale> is a function which takes a value
21:50:37 <Cale> and produces a parser which succeeds unconditionally without consuming any input
21:50:44 <Cale> and produces that value as its result
21:50:50 <johnw> SamanthaAD: maybe you have learned by now never to ask #haskell what a monad is ;)
21:51:27 <johnw> Cale: you are missing a piece in that description, though
21:51:34 <Cale> am I?
21:51:38 <Cale> I need bind still
21:51:39 <johnw> Cale: you're assuming the function which "runs the parser"
21:52:01 <SamanthaAD> johnw: that made me laugh. Actually, I learned a lot. I finally got a satesfactory explanation of how the IO monad fits in with functional programming and I got a roadmap of what I should study to understand monads in theory.
21:52:02 <Cale> I'm describing the meaning of this parser
21:52:19 <Cale> So, yes, there will be a function which runs the parsers
21:52:37 <johnw> and produces a parser which, when invoked later by "runParser", will succeed unconditionally without consuming any input
21:53:04 <Cale> Well, yes, a parser won't do anything if you don't run it
21:53:31 <johnw> Cale: it's just that the "running the parser" part doesn't have much to do with what makes it a Monad
21:54:17 <Cale> Well, sure, it's an important part of our parsing library though, of course.
21:54:21 <johnw> yes
21:55:00 <johnw> but since it's not part of the Monad interface, some Monads will never let you "get back" the value you hand to return, such as IO; you can only carry that value forward into the future by binding it
21:55:02 <Cale> SamanthaAD: okay, now that I think johnw is done sidetracking me, there's one more part of our parsing library's API that we need in order to have a monad
21:55:11 <Cale> :)
21:55:24 <johnw> hey, you were the stickler for precision, not me! ;)
21:55:39 <SamanthaAD> Cale: We have our monadic type, our injector, and our thingy that lets us get a value out of the monad (sort of)
21:55:57 <SamanthaAD> Cale: maybe I should call the third thing the monad's interface.
21:55:59 <Cale> "injector" is a weird term for the operation which makes a parser which does nothing
21:56:16 <Cale> (except to produce a given result)
21:56:36 <johnw> SamanthaAD: the thingy that gets the value out of the monad is not part of its being a Monad, that's part of its being a Parser in this case
21:57:19 <hpaste> statusfailed annotated “can't get maybeM function to typecheck” with “can't get maybeM function to typecheck (annotation)” at http://hpaste.org/77804#a77805
21:57:26 <Cale> Let me describe the last part -- it doesn't quite let you get a final result, but instead is going to combine a parser and a function which gets to decide how to continue parsing from the result of the first one, to get a new parser.
21:57:31 <statusfailed> Ok so I fixed it, but i'm not sure why it worked :D
21:57:51 <statusfailed> rwbarton: still around? I can't figure out why your newtype solution helped here
21:58:08 <rwbarton> my what now? remind me
21:58:25 <SamanthaAD> Cale: I sort of understand that but I think that maybe by reading more about these things it will solidify.
21:58:38 <statusfailed> rwbarton: newtype NT f f' = NT (forall a. f a -> f' a)
21:58:41 <Cale> SamanthaAD: Okay, I'll describe it more carefully
21:58:41 <johnw> SamanthaAD: I know exactly how you feel
21:58:49 <Cale> actually, let's go to #haskell-overflow
21:59:01 <Cale> because this is kind of noisy
21:59:05 <rwbarton> statusfailed: oh yeah
21:59:09 <rwbarton> helped compared to what?
21:59:17 <statusfailed> it doesn't work without the newtype
21:59:32 <rwbarton> does it complain about higher rank types?
21:59:35 <statusfailed> i.e., doing => forall t. (f' t -> f t)
22:00:16 <statusfailed> I get Could not deduce (t ~ f a)
22:01:12 * lispy is not found of that error. Seems like maybe the errors were better pre-7
22:02:00 <statusfailed> rwbarton: I could paste the error if you want?
22:02:21 <rwbarton> yeah, and I am not totally sure what code you are talking about either
22:02:38 <statusfailed> oh sorry, it's this: http://hpaste.org/77804#a77805
22:04:24 <rwbarton> statusfailed: you've got the parens in the wrong place
22:04:33 <rwbarton> needs to be (forall t. f' t -> f t)
22:04:40 <rwbarton> then it worked for me
22:05:22 <statusfailed> oh balls
22:05:23 <statusfailed> hahah
22:05:25 <statusfailed> thanks :D
22:06:20 <statusfailed> I was always confused about where to put the "forall"
22:16:09 <sw17ch> @tell nand` I got a start on the xwiimote bindings we discussed earlier: https://github.com/sw17ch/hsxwiimote
22:16:09 <lambdabot> Consider it noted.
22:19:37 <neutrino> hi
22:20:26 <johnw> hi neutrino
22:21:08 <neutrino> hi johnw
22:32:57 <SamanthaAD> neutrino: Hello! I'm in overflow getting a lecture.
22:44:23 <neutrino> SamanthaAD: hi. what's overflow?
22:45:53 <neutrino> hey guys, does anyone know if hoogle has an api for its search?
22:45:55 <SamanthaAD> #haskell-overflow
22:46:06 <neutrino> SamanthaAD: cool, let me join :)
22:59:25 <neutrino_> hey, guys, does anyone know if hoogle has a json api for its search results, like hayoo? hayoo's search results are broken
22:59:50 <johnw> neutrino_: why not just get the hoogle sources and see how the command-line tool for it works?
23:00:34 <neutrino_> because i want search results for packages i don't have installed
23:02:10 <Sonarpulse> it's me working with Data.Binary again
23:02:56 <Sonarpulse> that module comes with various little endian and big endian functions such as getWord32le
23:03:02 <Sonarpulse> getWord8be
23:03:45 <Sonarpulse> and I am having trouble as they don't seem to work at all how they should
23:04:06 <neutrino_> have you checked the test suite?
23:07:00 <statusfailed> Is there an easy way to get Aeson to treat a missing field :: Maybe a as Nothing?
23:07:10 <statusfailed> (missing from the json, that is)
23:15:40 <ion> I wonder if there exists a variant of ErrorT whose (<|>) and mplus collect the errors with mappend so you could combine that with StateT [t] [] a and get Parsec-style error messages like “expected space, ')' or alpha”?
23:17:43 <afgho> how to generate all possibles lists with a list of 16 values in the range 0..32? found some examples like f = [[a, b] | a <- [0..32], b <- [0..32]] but don't know how to expand this to generate for N values
23:17:57 <ion> replicateM 16 [0..32]
23:18:14 <Sonarpulse> nutrino_ test sweet?
23:18:25 <Sonarpulse> neutrino_
23:20:40 <neutrino_> Sonarpulse: say what?
23:21:48 <Sonarpulse> were you talking to me when you said "have you checked the test sweet"?
23:21:49 <latermuse> afgho: try permutations
23:22:13 <popl> suite :)
23:22:41 <exDM69> https://github.com/rikusalminen/funfun  here's a toy programming language project I've been working on
23:23:25 <exDM69> so far I've got a parser, dependency analysis and type checking
23:23:27 <latermuse> afgho: permutations $ [[a,b] | a<-[0..32], b<-[0..32]]
23:23:45 <neutrino_> Sonarpulse: yes, although i said "suite"
23:23:56 <Sonarpulse> whoops
23:24:03 <Sonarpulse> well what do you mean?
23:24:04 <neutrino_> you've confused me there
23:24:10 <neutrino_> when you write code, you test it
23:24:21 <neutrino_> the tests display expected behaviour and check actual behaviour against it
23:24:22 <Sonarpulse> is there one in the mondule?
23:24:30 <statusfailed> How do I put predicates in instance declarations again?
23:24:33 <Sonarpulse> do all packages have this?
23:24:39 <neutrino_> Sonarpulse: most do
23:25:01 <neutrino_> do "cabal unpack mypackage" to get the source, the tests might be in a subdirectory called test or somewhere else
23:25:52 <Sonarpulse> say you installed the package via apt?
23:26:03 <Sonarpulse> in my case I think it came by default with ghc
23:26:05 <statusfailed> oops, found it
23:26:24 <exDM69> LLVM bindings still don't work in GHCi :(  Apparently something is hard with linking to projects written in C++
23:27:23 <afgho> latermuse: that is what i did but i don't know how to automate it for N values so i don't have to use 16 vars for example
23:30:21 <ion> isTrue (Atom (IntValue x)) = x /= 0; isTrue (Atom (FloatValue x)) = x /= 0.0; isTrue (Atom (StringValue x)) = not . null $ x
23:30:23 * ion cringes. :-P
23:30:27 <ion> Hi PHP.
23:31:15 <neutrino_> ion: where's that code from?
23:31:27 <ion> https://github.com/rikusalminen/funfun
23:31:50 <Jafet> You just can't handle the truth
23:32:04 <neutrino_> that's terrible ion
23:32:58 <pordan30> is there a difference between an attributed graph and a labeled graph, in the sense of the functional graph library?
23:36:04 <pordan30> it doesn't appear that the fgl libraries assume that labels are members of a class like real, so my impression is that there isn't.
23:40:19 <afgho> ah replicateM work great, thank
23:44:27 <Sonarpulse> looking at hackage I don't think there is a test suite
23:44:36 <Sonarpulse> has anybody here used Data.Binary ?
23:46:35 <neutrino_> Sonarpulse: you have not done what i told you to though
23:46:49 <ion> sonarpulse: cereal is nicer.
23:47:24 <Sonarpulse> neutrino: using cabal?
23:47:33 <neutrino_> yes
23:47:40 <Sonarpulse> ion: maybe, but my problem now is it's just not working as avertised
23:47:53 <Sonarpulse> redoing everything would take a while
23:48:08 <Sonarpulse> neutrino: no but what could Cabal do if the test suite isn't written?
23:48:26 <Sonarpulse> I could install cabal and hackage platform and all that
23:48:32 <Sonarpulse> but that would be quite a lot of work
23:48:45 <Sonarpulse> making sure it didn't conflict with the apt versions
23:51:18 <Sonarpulse> ion: is cereal very manual when it comes to packing/alignment and endianness?
23:51:48 <ion> It’s quite similar to binary, but it lets you handle parse failures gracefully.
23:52:58 <Sonarpulse> Ok, not an issue atm but interesting
23:53:09 <Sonarpulse> and then what is Data.Serialize?
23:53:24 <ion> @hackage cereal
23:53:25 <lambdabot> http://hackage.haskell.org/package/cereal
23:54:01 <shachaf> If TH generated a whole bunch of code, is there a way to get the generated code in a form that I can paste into a .hs file and use?
23:57:23 <luite> shachaf: do i hear a volunteer for mainainership of the zeroth package? ;)
23:58:41 <shachaf> luite: zeroth?
23:58:56 <shachaf> This isn't even my code.
23:58:59 <luite> shachaf: yeah that evaluates TH code and inserts it back into the original file
23:59:06 <shachaf> Hmm.
23:59:08 <shachaf> But it's broken?
23:59:42 <luite> yeah latest version is from 2009
