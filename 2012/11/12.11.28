00:01:25 <Nereid> @free id
00:01:26 <lambdabot> f . id = id . f
00:02:06 <johnw> @free const
00:02:07 <lambdabot> f . const x = const (f x) . g
00:02:36 <johnw> what does @free do?
00:02:51 <DT`> free theorems, I guess.
00:02:56 <DT`> @free map
00:02:57 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
00:03:09 <johnw> yeah, i still don't get what those are
00:03:26 <Nereid> johnw: time to read some papers on parametricity then
00:03:37 <DT`> theorems that you get for free from the parametricity in the type signature.
00:03:38 <johnw> have any recommendations?
00:03:49 <DT`> "theorems for free"
00:03:53 <Nereid> by Wadler
00:04:00 <johnw> ah, I have that one
00:04:06 <Nereid> ah, the free theorem for id is enough to prove id x = x
00:04:19 <Nereid> id x = id (const x y) = const x (id y) = x
00:04:33 <Nereid> of course.
00:05:22 <Nereid> (so, any function of type forall a. a -> a is equal to id. ignoring partial functions or things involving seq)
00:07:16 <Nereid> more generally, f . h = h . f holds for any h :: forall a. a -> a if f is strict and total
00:07:55 <Nereid> I guess.
00:07:57 <Nereid> http://www-ps.iai.uni-bonn.de/cgi-bin/free-theorems-webui.cgi
00:08:05 <johnw> is that a way of saying f is automorphic?
00:08:15 <Nereid> what?
00:08:26 <johnw> n/m
00:08:27 <Nereid> it just means f x = _|_ if and only if x = _|_
00:09:17 <Nereid> ("if" is strict, "only if" is total)
00:09:40 <johnw> interesting!
00:09:40 <Nereid> time to go to bed.
00:09:49 <johnw> sleep well, Nereid
00:11:22 * hackagebot yesod 1.1.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.4.1 (MichaelSnoyman)
00:11:24 * hackagebot yesod-auth 1.1.2 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.2 (MichaelSnoyman)
00:11:26 * hackagebot yesod-core 1.1.6.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.6.1 (MichaelSnoyman)
00:13:28 <hrr> guy what are the main reasons to use haskell? what is its main purpuose? (script, web etc)
00:13:38 <johnw> it's general purpose
00:14:06 <shachaf> See the FAQ on this.
00:14:07 <shachaf> @where faq
00:14:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
00:15:32 <hrr> thx
00:24:52 <liyang> @faq Can Haskell be used to bring about world peace?
00:24:52 <lambdabot> The answer is: Yes! Haskell can do that.
00:25:12 <johnw> @faq Can Haskell create a rock too heavy for it to evaluate?
00:25:13 <lambdabot> The answer is: Yes! Haskell can do that.
00:25:22 <liyang> hrr: hope that helps.
00:26:57 <DT`> what's the type of bringWorldPeace?
00:27:51 <tufflax> World a => a -> a
00:28:12 <shachaf> What's with all the type classes, man?
00:28:46 <tufflax> Dunno :p I'm new to Haskell :P
00:29:27 <shachaf> In Haskell we're allowed to define a type Foo instead of a type class.  :-)
00:51:23 * hackagebot haddock 2.11.1 - A documentation-generation tool for Haskell libraries  http://hackage.haskell.org/package/haddock-2.11.1 (SimonHengel)
00:59:55 <osa1> did that package become standard in ghc 7.6: http://hackage.haskell.org/package/syb-0.3.7 ?
01:00:49 <fmap> ?
01:03:15 <osa1> fmap: I mean is it a part of the latest haskell platform? seems like it is: http://lambda.haskell.org/platform/doc/current/index.html
01:03:28 <osa1> fmap: http://lambda.haskell.org/platform/doc/current/packages/syb-0.3.7/doc/html/Data-Generics.html
01:04:45 <fmap> osa1: but latest HP doesn't have ghc 7.6
01:06:14 <osa1> fmap: hmm, which ghc does it have ?
01:07:01 <osa1> 7.4.2
01:08:17 <osa1> ok, that explains. I don't have complete haskell platform installed on my machine.
01:10:52 <latermuse> is it worth upgrading to 7.6 yet?
01:11:20 <osa1> latermuse: I couldn't manage to make cabal-dev work with 7.6. so I'm using 7.4.2
01:11:32 <latermuse> yeah, I heard not everything is ported yet
01:12:11 <fmap> osa1: did you try installing from git?
01:13:55 <pd_snipe> So I am new to haskell and I am learning it for a class.  I have run into a problem involving Test.HUnit and was wondering if anyone could help me.
01:14:34 <shachaf> Not if you don't ask your question.
01:15:26 <osa1> fmap: no. I tried `cabal install`
01:15:35 <pd_snipe> my problem is during compiling. when i try to compile i get the error Could not find module `Test.HUnit'
01:15:51 <shachaf> Is HUnit installed?
01:15:55 <luite> should the cabal-dev git version work with 7.6.1? I installed it, but get cabal: ghcInvocation: the programVersion must not be Nothing
01:16:23 * hackagebot hackport 0.3.1 - Hackage and Portage integration tool  http://hackage.haskell.org/package/hackport-0.3.1 (SergeiTrofimovich)
01:16:24 <pd_snipe> does HUnit come with the standard libraries?
01:16:37 <shachaf> I don't know.
01:16:39 <shachaf> Probably not?
01:17:20 <pd_snipe> I though it did. after googling this issue for a while i could find anywhere to get just HUnit
01:19:42 <johnw> pd_snipe: normally one would use the command; cabal install HUnit
01:22:19 <hamid> At first I thought recursivness is an aweful way to express things! actually i feel guilty because of that :D
01:22:29 <pd_snipe> didnt know about cabal
01:22:34 <pd_snipe> its pretty cool
01:22:43 <pd_snipe> thx johnw
01:23:17 <donri> hunit comes with haskell-platform but not with ghc
01:25:05 <pd_snipe> problem solved
01:51:24 * hackagebot uhc-util 0.1.0.1 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.0.1 (AtzeDijkstra)
01:56:25 * hackagebot pushme 1.1.0 - Tool to synchronize multiple directories with rsync, zfs or git-annex  http://hackage.haskell.org/package/pushme-1.1.0 (JohnWiegley)
02:07:45 <statusfailed> It would be nice if you could write (f _ x y) to mean (\z -> f z x y )
02:08:32 <donri> statusfailed: that syntax is stolen by type holes though
02:09:01 <statusfailed> donri: aww
02:09:21 <donri> there's a preproc somewhere that does that though
02:09:32 <donri> duno it's name
02:09:35 <donri> its
02:09:44 <bzmer> Hey guys, I have an emacs haskell-mode question for you: C-c C-b starts a buffer with an interpreter -- in this interpreter, how can I cycle through previously entered commands? (if I was in a terminal for instance, hitting the up or down arrow key would let me cycle)
02:10:04 <statusfailed> Hmm, tempting
02:10:12 <statusfailed> not sure if it's a good idea though :D
02:12:27 <donri> statusfailed: in you particular case though: (`f` x y)
02:13:43 <fmap> ;w
02:13:45 <statusfailed> donri: I knew I was going to pick a bad example :P
02:13:48 <fmap> =(
02:13:53 <statusfailed> neat trick though, wouldn't have thought of it
02:13:54 <donri> hehe
02:15:18 <MrWoohoo> um, is there a cabal command to remove a package?
02:15:32 <donri> no
02:15:49 <luite> not a cabal command, you can do ghc-pkg unregister, though that will not remove the installed files
02:15:53 <donri> ghc-pkg unregister it instead
02:16:16 <donri> @hackage cabal-uninstall
02:16:16 <lambdabot> http://hackage.haskell.org/package/cabal-uninstall
02:16:33 <donri> duno how well that works though
02:22:59 <sopvop> is there function in base such what  (Alternative f) => [f a] -> f a, like  [a,b,c] = a<|> b<|> c?
02:23:24 <shachaf> foldr (<|>) empty?
02:23:45 <mauke> http://www.haskell.org/hoogle/?hoogle=%28Alternative%20f%29%20%3D%3E%20%5Bf%20a%5D%20-%3E%20f%20a
02:24:45 <sopvop> Thanks
02:24:50 <liyang> > compare (0/0) (0/0)
02:24:51 <lambdabot>   GT
02:29:34 <zhulikas> <liyang> > compare (0/0) (0/0)
02:29:35 <zhulikas> wat
02:41:26 * hackagebot yesod-platform 1.1.5 - Meta package for Yesod  http://hackage.haskell.org/package/yesod-platform-1.1.5 (MichaelSnoyman)
03:02:41 <ocharles> if I want to upload to hackage do I have to do anything other than 'cabal upload -u=OliverCharles dist/digestive-functors-aeson-1.0.0.tar.gz' ?
03:02:44 <ocharles> I keep getting 401 unauthorized :(
03:04:06 <ocharles> ah, -u=OliverCharles is nonsense :)
03:06:26 * hackagebot digestive-functors-aeson 1.0.0 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.0.0 (OliverCharles)
03:07:43 <ocharles> yay
03:09:08 <m3ga> ocharles: well done!
03:18:03 <ocharles> :)
03:18:34 <sopvop> ocharles! why not 5 months ago? :)
03:18:56 <ocharles> sopvop: cause I wasn't getting paid to write haskell 5 months ago. it took my 5 months to get to that point ;)
03:19:10 <sopvop> looks... simplistic
03:19:26 <ocharles> the library? that's very simple, but i didn't have a need for it then
03:20:33 <sopvop> I now want self-describing json validator and pretty-printer.
03:24:34 <sopvop> digestive-functors are only for web, my json validator is much cooler.
03:25:25 <sopvop> my is like
03:25:57 <sopvop> my is like reform, but even more general. I also validate query parameters with it
03:26:42 * sopvop is boasting
03:26:57 <neutrino_> good for you
03:30:17 <KBme> hi
03:30:50 <KBme> I'm using the cryptohash library for hashing, and I'm trying to get an output similar to the *sum shell utilities in unix
03:31:38 <KBme> B.unpack $ SHA3.hash 512 $ B.pack "foo" -- doesn't do what I would expect it to do, the string it gives me is garbled‚Ä¶
03:33:17 <shachaf> You shouldn't be using ByteString.Char8. :-(
03:33:39 <shachaf> Anyway, I assume this library gives you the actual bytes in the ByteString, not a hexadecimal representation.
03:33:44 <shachaf> What's garbled about it?
03:34:03 <KBme> well, I mean it's all jumbled, not hex
03:34:22 <shachaf> Why would it be?
03:34:41 <KBme> I shouldn't be using ByteString? so what? cryptohash expects a ByteString.
03:34:57 <shachaf> I didn't say you shouldn't be using ByteString.
03:35:41 <KBme> oh, Char8? what would you use instead?
03:35:49 <KBme> shachaf?
03:36:04 <shachaf> ByteString
03:36:11 <sopvop> KBme: I think you should convert ByteString of bytes into string of hex.
03:36:17 <KBme> but that uses some word8 type I don't know
03:36:28 <shachaf> Well, you can encode text into ByteString.
03:36:31 <KBme> sopvop, yes! I should!
03:36:33 <shachaf> A ByteString holds bytes, not text. :-)
03:36:41 <KBme> huh
03:36:51 <shachaf> ?
03:36:54 <KBme> so it would be B.pack $ T.pack "mystring"?
03:37:10 <KBme> looks funky
03:37:15 <shachaf> Probably TE.encodeSomething, not B.pack
03:37:20 <shachaf> Depending on what encoding you want to use.
03:37:26 <shachaf> (Probably UTF-8.)
03:37:37 <KBme> ok, so Data.Text gives me Bytestrings aswell?
03:37:44 <KBme> yeah, unicode ftw
03:37:55 <sopvop> T.encodeUtf8 $ T.pack "myString" -> ByteString of bytes of utf8 encoded text
03:38:06 <KBme> oh
03:38:10 <KBme> all right
03:38:10 <shachaf> Data.Text is different from Data.ByteString.
03:38:18 <shachaf> But you can encode Text into a ByteString, if you know which encoding you want.
03:38:51 <KBme> ok
03:39:10 <KBme> last thing is what would be simplest to convert this bytestring cryptohash gives me to hex?
03:39:12 <shachaf> This is unrelated to your other question, though that one is also about encoding.
03:39:55 <shachaf> What's "hex"?
03:40:01 <shachaf> What's the type of a "hex", I mean.
03:40:23 <KBme> I just want a string, really
03:40:26 <sopvop> Word4?
03:40:54 <shachaf> Maybe (concatMap (printf "%02x") . B.unpack)
03:40:56 <shachaf> I don't know.
03:41:27 * hackagebot digestive-functors-aeson 1.0.1 - Run digestive-functors forms against JSON  http://hackage.haskell.org/package/digestive-functors-aeson-1.0.1 (OliverCharles)
03:42:37 <KBme> shachaf, you got it mixed up, Maybe is the type, you want Just (concatMap (printf "%02x") . B.unpack) ;)
03:42:40 <KBme> anyways, thanks
03:43:38 <sopvop> KBme: I think shachaf meant: Maybe (..code..), I don't know
03:44:41 <KBme> it was supposed to be a joke about Maybe, Just and Nothing, but I guess it wasn't funny
03:52:30 <shachaf> > someByteString ^. bytes.to (printf "%02x" `asTypeOf` show)
03:52:32 <lambdabot>   "41614161"
03:54:33 <donri> > someByteString
03:54:35 <lambdabot>   "AaAa"
03:55:13 <sopvop> > foldMap showHes (B.unpack someByteString) $ ""
03:55:14 <lambdabot>   Not in scope: `showHes'
03:55:14 <lambdabot>  Perhaps you meant one of these:
03:55:14 <lambdabot>    `showHex' (impo...
03:55:22 <sopvop> > foldMap showHex (B.unpack someByteString) $ ""
03:55:23 <lambdabot>   Not in scope: `B.unpack'
03:55:23 <lambdabot>  Perhaps you meant one of these:
03:55:23 <lambdabot>    `BS.unpack' (i...
03:55:29 <sopvop> > foldMap showHex (BS.unpack someByteString) $ ""
03:55:31 <lambdabot>   "41614161"
03:56:45 <mutha> is there a standard function for trimming white space characters from the beginning and end of the string?
03:57:18 <KBme> oh there is a showhex function?
03:57:23 <shachaf> > foldMap showHex (BS.unpack someOtherByteString) $ ""
03:57:24 <KBme> where is it imported from?
03:57:25 <lambdabot>   "156162"
03:57:30 <shachaf> > someOtherByteString
03:57:31 <lambdabot>   "\SOH\ENQab"
03:57:34 <sopvop> Numeric
03:57:34 <KBme> > :i showHex
03:57:36 <lambdabot>   <hint>:1:1: parse error on input `:'
03:57:39 <fmap> mutha: Data.Text.strip
03:57:42 <shachaf> You don't want showHex
03:57:58 <shachaf> At least not the way sopvop used it.
03:59:22 <mauke> import Text.Printf.Mauke
03:59:34 <mauke> printf "%*v02x" "" str
03:59:38 <mutha> Data.Text.Strip accepts Text not a string
03:59:39 <mauke> what were we doing?
04:01:03 <shachaf> mauke: printf-mauke's TH.hs compiles with some warnings, by the way.
04:03:02 <mutha> > let strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace
04:03:04 <lambdabot>   not an expression: `let strip = reverse . dropWhile isSpace . reverse . dro...
04:03:28 <sopvop> > foldMap showHex [0, 16, 255 :: Word8] $ ""
04:03:29 <lambdabot>   "010ff"
04:03:38 <sopvop> yup, that is shit
04:03:57 <mutha> > let strip text = reverse . dropWhile isSpace . reverse . dropWhile isSpace $ text
04:03:58 <lambdabot>   not an expression: `let strip text = reverse . dropWhile isSpace . reverse ...
04:04:06 <mutha> whatever
04:05:40 <FireFly> @let strip = reverse . dropWhile isSpace . reverse . dropWhile isSpace
04:05:42 <lambdabot>  Defined.
04:06:04 <latermuse> > strip "  meow  "
04:06:06 <lambdabot>   "meow"
04:06:13 <mauke> needs more join
04:06:27 * hackagebot yesod-fay 0.1.0.4 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.0.4 (MichaelSnoyman)
04:06:35 <mauke> :t join (.) $ dropWhile isSpace
04:06:36 <lambdabot> [Char] -> [Char]
04:06:43 <sopvop> > Data.ByteString.Base16.encode "FooBar"
04:06:44 <lambdabot>   Not in scope: `Data.ByteString.Base16.encode'
04:06:51 <mauke> :t join (.) $ reverse . dropWhile isSpace
04:06:53 <lambdabot> [Char] -> [Char]
04:06:59 <shachaf> sopvop: That looks like the wrong direction.
04:07:05 <shachaf> And also looks like a bad module.
04:07:34 <shachaf> (Didn't we just a short version of the Unicode conversation? :-) )
04:08:33 <sopvop> "FooBar" are valid word8s :)
04:08:46 <sopvop> and I don't like anything printf
04:09:07 <sopvop> Also, module by bos can't be bad.
04:10:14 <shachaf> sopvop: "FooBar" :: [Char]
04:10:24 <shachaf> You don't have to use printf if you don't want to.
04:10:46 <sopvop> lambdabot does not have -XOverloadedStrings?
04:11:02 <shachaf> The IsString instance for ByteString is bad.
04:11:23 <shachaf> Anyway, encode :: ByteString -> ByteString, which makes no sense, and also KBme said they wanted a String.
04:13:49 <hpaste> sopvop pasted ‚ÄúSort of like that‚Äù at http://hpaste.org/78400
04:13:51 <maukf> printf "%*v02x" "" :: ByteString -> String
04:14:28 <sopvop> Haskell, where there are more imports than code.
04:15:15 <shachaf> ByteString.Char8 :-(
04:16:06 <sopvop> why? Is not 0-9, a-f in char8 range?
04:17:47 <maukf> you know you want to use printf
04:18:10 * sopvop does not want
04:18:57 <maukf> it is delicious printf, you must eat it
04:19:08 <neutrino_> wait
04:19:18 <neutrino_> you can import qualified two different things onto the same name?
04:19:24 <neutrino_> what happens then, do they just get summed?
04:19:29 <sopvop> printf will make you fat
04:19:51 <neutrino_> i've just lost 20 kilo, i don't want to get fat again.
04:19:55 <shachaf> > let showOne w = [(intToDigit.fromIntegral) (w `div` 8), (intToDigit.fromIntegral) (w `mod` 8)] in foldMap showOne (BS.unpack someOtherByteString)
04:19:57 <lambdabot>   "0105c1c2"
04:19:58 <sopvop> neutrino_ if you have conflicting names in modules, you will get ambiguity
04:20:10 <neutrino_> sure
04:20:24 <neutrino_> but if you don't use those conflicting names, it's ok, right?
04:20:30 <maukf> neutrino_: same thing as for unqualified imports
04:20:33 <sopvop> neutrino_: Right, its just an alias
04:20:39 <neutrino_> nice sopvop
04:20:44 <neutrino_> thank you
04:20:51 <sopvop> you are welcome :)
04:20:54 <neutrino_> :)
04:21:10 <neutrino_> it's so nice because i never use unqualified imports
04:21:21 <neutrino_> so it's good to know i can mix the modules like this..
04:21:31 <sopvop> shachaf: how about adding hex Iso to lens? ;)
04:22:02 <shachaf> That doesn't sound very isomorphic.
04:22:14 <shachaf> Maybe a projection?
04:22:22 <shachaf> Anyway, don't take it up with me.
04:23:01 <maukf> printfomorphism
04:23:32 <sopvop> printfo-scanfo-morphism
04:23:55 <shachaf> maukf: Do you even lens?
04:24:00 <maukf> I don't believe in scanf
04:24:09 <maukf> shachaf: no :-(
04:24:15 <sopvop> @hoogle scanf
04:24:15 <lambdabot> No results found
04:24:22 <sopvop> so does hoogle
04:25:01 <shachaf> maukf: You should!
04:25:20 <maukf> shachaf: do you have a video tutorial?
04:25:54 <shachaf> maukf: Unfortunately not. Google policy.
04:27:18 <byorgey> oh, 'lens' an intransitive verb now?
04:27:20 <sopvop> edwardk promised video of lens talk though. After seeing his slides, I have no hopes to understand any of it.
04:27:53 <byorgey> sopvop: with that attitude, you sure don't
04:28:01 <tdammers> lens or be lensed
04:28:16 <edwardk> sopvop: they work a hell of a lot better with me talking over them ;)
04:28:28 <edwardk> they aren't intended to be followed without actual words going over them =)
04:28:41 <shachaf> Also they're more stabby now!
04:28:52 <sopvop> we put lens on your lens, so you can traverse while you traverse
04:29:44 <shachaf> sopvop: The point of the trickiness behind lens is to make all these types unify: http://slbkbs.org/lens.txt
04:30:44 * edwardk feels a bit like Jack Torrance in the Shining. Shachaf made me write "stab stab stab stab stab stab" a few hundred times in my slides. Not surprisingly, this made me want to kill someone ;)
04:31:22 <maukf> i s t a b, u s t a b
04:32:00 <osfameron> we all stab for icestab
04:33:11 <sopvop> I still don't get userId :: Functor f => (a0 UserId -> f (a1 UserId)) -> User a0 -> f (User a1) -- and how it composes with plain (.) :)
04:36:28 * hackagebot monad-logger 0.2.3.1 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.2.3.1 (MichaelSnoyman)
04:38:13 <basdirks_> is it considered best practice to specify the types and functions to be imported from a module?
04:38:33 <shachaf> Sometimes.
04:40:52 <cameron_> aaa
04:44:19 <zhulikas> basdirks_, you may accidently import functions with same names from different modules
04:44:53 <zhulikas> so unless you specify functions in import, or make a qualified import, you'll get a compilation error
04:44:58 <basdirks_> yeah
04:45:20 <tdammers> ...which is a good thing, because the compiler is telling you that you're being ambiguous, rather than second-guessing you
04:45:52 <zhulikas> I'm not suggesting compilation error is bad ;)
04:45:58 <zhulikas> well, my strategy is to keep it tidy
04:46:08 <zhulikas> import only what's needed
04:47:34 <basdirks_> could someone point me to an example use of `at` (from Control.Lens)?
04:48:03 <ion> > Map.fromList [("foo", 42), ("bar", 5)] ^. at "foo"
04:48:04 <lambdabot>   Not in scope: `Map.fromList'
04:48:04 <lambdabot>  Perhaps you meant one of these:
04:48:04 <lambdabot>    `M.fromLis...
04:48:06 <shachaf> > M.fromList [("hello",5),("hi",3)] & at "hello" +~ 1
04:48:07 <ion> > M.fromList [("foo", 42), ("bar", 5)] ^. at "foo"
04:48:08 <lambdabot>   can't find file: L.hs
04:48:08 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
04:48:08 <lambdabot>    arising from a use o...
04:48:12 <shachaf> > M.fromList [("hello",5),("hi",3)] & at "hello" +~ 1
04:48:14 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe a0))
04:48:14 <lambdabot>    arising from a use o...
04:48:16 <ion> > M.fromList [("foo", 42), ("bar", 5)] ^. at "foo"
04:48:16 <shachaf> Whoops.
04:48:18 <lambdabot>   Just 42
04:48:19 <shachaf> > M.fromList [("hello",5),("hi",3)] & _at "hello" +~ 1
04:48:21 <lambdabot>   fromList [("hello",6),("hi",3)]
04:48:44 <shachaf> > M.fromList [("hello",5),("hi",3)] ^? at "hi"
04:48:46 <lambdabot>   Just (Just 3)
04:48:49 <shachaf> Er.
04:48:52 <shachaf> > M.fromList [("hello",5),("hi",3)] ^. at "hi"
04:48:53 <lambdabot>   Just 3
04:48:55 <zhulikas> > M.fromList [("foo", 42), ("bar", 5)] ^. at "can i get an error?"
04:48:57 <lambdabot>   Nothing
04:49:02 <ion> > Map.fromList [("foo", 42), ("bar", 5)] ^? _at "foo"
04:49:04 <lambdabot>   Not in scope: `Map.fromList'
04:49:04 <lambdabot>  Perhaps you meant one of these:
04:49:04 <lambdabot>    `M.fromLis...
04:49:08 <zhulikas> ohh, that's a Maybe in here, right
04:49:08 <ion> > M.fromList [("foo", 42), ("bar", 5)] ^? _at "foo"
04:49:09 <lambdabot>   Just 42
04:49:31 <zhulikas> this is pretty cool
04:49:35 <shachaf> > M.fromList [("foo", 42), ("bar", 5), ("vaz", 114)] ^?! _at "oops"
04:49:37 <lambdabot>   *Exception: (^?!): empty Fold
04:49:49 <ion> > M.fromList [("foo", 42), ("bar", 5)] & at "foo" %~ fmap (+1)
04:49:51 <lambdabot>   fromList [("bar",5),("foo",43)]
04:50:05 <shachaf> Kind of silly to use fmap
04:50:14 <ion> Sure
04:50:21 <shachaf> > M.fromList [("foo", 42), ("bar", 5)] & at "foo".mapped %~ (+1)
04:50:23 <lambdabot>   fromList [("bar",5),("foo",43)]
04:50:26 <shachaf> > M.fromList [("foo", 42), ("bar", 5)] & _at "foo" %~ (+1)
04:50:28 <lambdabot>   fromList [("bar",5),("foo",43)]
04:51:53 <shachaf> The code generated for at makes me sad. :-(
04:52:42 <zhulikas> where is it?
04:55:00 <basdirks_> thanks ion, shachaf, zhulikas
04:55:14 <zhulikas> no thanks to me! I have no idea how lens works!
04:55:38 <zhulikas> and, just for the record, that wasn't a request for explanation :D
04:55:46 <edwardk> > M.fromList [("foo", 42), ("bar", 5)] & _at "foo" +~ 1
04:55:48 <lambdabot>   fromList [("bar",5),("foo",43)]
04:56:02 * zhulikas is forced to work with very different technologies atm 
04:57:43 <zhulikas> @type _at
04:57:44 <lambdabot> (Applicative f, At k m, Indexed k k1) => k -> k1 (v -> f v) (m v -> f (m v))
04:57:50 <zhulikas> ohh, lovely
04:58:13 <edwardk> zhulikas: it is a little easier if you strip out the noise
04:58:21 <shachaf> _at :: At k m => k -> SimpleIndexedTraversal k (m v) v
04:58:23 <zhulikas> well, implementation makes sense though
04:58:27 <edwardk> :t id . _at ?k
04:58:29 <lambdabot> (?k::k, Functor (k1 (v -> f v)), Applicative f, At k m, Indexed k k1) => k1 (v -> f v) (m v -> f (m v))
04:58:38 <edwardk> :t simple . _at ?k
04:58:39 <lambdabot> (?k::k, Functor (k1 (v -> f v)), Applicative f, At k m, Indexed k k1) => k1 (v -> f v) (m v -> f (m v))
04:58:47 <shachaf> I don't think you're helping your case there.
04:58:50 <edwardk> ok, that doesn't help ;)
04:59:22 <basdirks_> :t (&)
04:59:23 <lambdabot> a -> (a -> b) -> b
04:59:41 <edwardk> at :: Functor f => Int -> (Maybe a -> f (Maybe a)) -> IntMap a -> f (IntMap a)
04:59:50 <ion> ‚Äústrip out the noise‚Äù ‚Äú(?k::k, Functor (k1 (v -> f v)), Applicative f, At k m, Indexed k k1) => k1 (v -> f v) (m v -> f (m v))‚Äù
04:59:51 <edwardk> is a commonly used type for it
05:00:01 <edwardk> ion: worked for me!
05:00:12 <neutrino_> come to think of it, edwardk used to be an upstanding citizen like you and me.
05:00:27 <shachaf> Int -> Simple Lens (IntMap a) a
05:00:31 <edwardk> i was? er.. yes. of course i was!
05:00:32 <shachaf> Not so bad!
05:00:33 <zhulikas> :D
05:00:35 <neutrino_> :p
05:00:54 <neutrino_> edwardk: just never move to Belize.
05:01:04 <hpaste> killy9999 pasted ‚ÄúProblems with inlining‚Äù at http://hpaste.org/78407
05:01:11 <mSSM> hacking on some haskell code and feeling like a code monkey ... could someone comment on the following code? http://hpaste.org/78406 I especially wonder if there is a way to get those sums in one go...
05:01:16 <edwardk> do they have a warrant for my arrest i don't know about?
05:01:27 <edwardk> i hate it when that happens
05:01:32 <killy9999> can anyone gove me a hint why in one case higher order function gets inlined and in another it doesn't?
05:01:35 <neutrino_> hahaha
05:01:48 <shachaf> edwardk: Has it happened to you often?
05:01:52 <neutrino_> they have a warrant against people who skip on their gym!
05:01:53 <shachaf> Only happened to me once, as far as I know.
05:02:14 <hpc> :t foldr
05:02:15 <lambdabot> (a -> b -> b) -> b -> [a] -> b
05:02:18 <hpc> er
05:02:20 <hpc> :t foldl'
05:02:21 <lambdabot> (a -> b -> a) -> a -> [b] -> a
05:02:32 <edwardk> I've been told I should plead the fifth
05:02:48 <neutrino_> haha
05:03:02 <hpc> > foldl' (\(x,y) (x',y') -> (x+x', y+y')) (0,0) [(0,1), (1,2), (4, 5)]
05:03:04 <lambdabot>   (5,8)
05:03:09 <hpc> mSSM: ^
05:04:12 <zhulikas> @pl \(x,y) (x',y') -> (x+x', y+y')
05:04:12 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))
05:04:22 <zhulikas> flip flop magic! \o/
05:04:26 <mSSM> omg
05:04:34 <neutrino_> yeah sometimes those get out of hand.
05:05:02 <Botje> mSSM: i'd write it at least as let (tms, tes) = unzip both \n return (sum tms, sum tes)
05:05:07 <zhulikas> > foldl' (uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. (+)) . flip . (((.) . (,)) .) . (+))) (0,0) [(0,1), (1,2), (4, 5)]
05:05:09 <lambdabot>   (5,8)
05:05:12 <zhulikas> yup, that looks about right
05:05:18 <zhulikas> enjoy your optimized version!
05:05:26 <hpc> haha
05:05:27 <mSSM> zhulikas: Is that really optmizied?
05:05:29 <mSSM> :D
05:05:40 <mSSM> s/optimizied/optimized
05:05:49 <zhulikas> mSSM, I have no idea what the hell is this for
05:05:54 <killy9999> can anyone help me with my inlinng problem?
05:05:55 <edwardk> mSSM: @pl stands for 'pointless' for a reason
05:05:58 <zhulikas> all i know is that people love to mess with it
05:06:02 <killy9999> http://hpaste.org/78407
05:06:04 <zhulikas> ahh, so that's what it does!
05:06:20 <edwardk> @pl \x -> foo (bar x)
05:06:20 <lambdabot> foo . bar
05:06:48 <edwardk> it gets rid of the function arguments by simple program transformations. the end result may or may not be pleasant
05:06:49 <mSSM> hpc: Do you prefer to bind that to some value with let foo = ... and then return foo, or should I just return $ foldl' ...   ?
05:07:17 <mSSM> Botje: But you would prefer hpc's version?
05:07:23 <hpc> mSSM: do what Botje said, i think
05:07:35 <hpc> laziness should make them both the same
05:07:45 <hpc> maybe
05:07:49 <Botje> mSSM: mine is just a restatement of your lines 8--10
05:07:50 <zhulikas> so, what is the record for @pl ?
05:08:06 <hpc> zhulikas: 60-something @mores
05:08:12 <hpc> is the largest i have seen
05:08:20 <hpc> it comes from using a poorly typed expression
05:08:23 <zhulikas> do you remember the original function for it?
05:08:23 <Botje> mSSM: but let (tms, tes) = unzip ... better explains your data
05:08:38 <mSSM> Botje: ok, thanks; then I will do that
05:08:51 <hpc> @pl \a b c d e f g h i j k l m n o p q r s t u v w x y z -> a b c e f h a x c d e  g t r e e e e e e e e e e e e e e e e q
05:08:54 <lambdabot> (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .)
05:08:55 <lambdabot> .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((const .) .) .) .) .) .) .) . (((((((((const .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . ((((((((((const .)
05:08:55 <lambdabot>  .) .) .) .) .) .) .) .) .) . ((((((((((const .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((((((const .) .) .) .) .) .) .) .) .) .) .) . (((((((flip .) .)
05:08:55 <lambdabot>  .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((ap .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .
05:08:55 <lambdabot> ) .) . ((((((flip .) .) .) .) .) .) . (((((((flip .) .) .) .) .) .) .) . ((((((((flip .) .) .) .) .) .) .) .) . (((((((((flip .) .) .) .) .) .) .) .) .) . flip (flip . (flip .) . ((flip .) .) . (((
05:08:57 <lambdabot> [23 @more lines]
05:08:58 <lambdabot> optimization suspended, use @pl-resume to continue.
05:09:02 <hpc> it was something like that
05:09:02 <zhulikas> ohhh, nice
05:09:03 <zhulikas> :D
05:09:06 <zhulikas> @pl \a -> \b -> \c -> a b c
05:09:06 <lambdabot> id
05:09:10 <zhulikas> darn it!!!
05:09:12 <zhulikas> I failed
05:09:12 <ion> ‚Äúoptimization‚Äù
05:09:56 <hayashi> @pl \a b c -> a(b(c))
05:09:56 <lambdabot> (.)
05:10:04 <Chousuke> hm, it's kind of hard to write haskell when I can't type backticks
05:10:09 <zhulikas> can you make it disappear?
05:10:26 <Chousuke> should probably configure emacs to not be confused by my keyboard layout
05:10:36 <mSSM> Botje: I am confused ... if you write  unzip foo \n return (sum a, sum b), isn't that lambda incomplete?
05:10:45 <hpc> Chousuke: `fmap` == <$>
05:10:47 <mSSM> Botje: unzip foo ->
05:10:48 <Botje> mSSM: I meant \n as in "put a new line here"
05:10:49 <hpc> `ap` == <*>
05:10:50 <hpc> etc
05:10:56 <sopvop> @pl \a b c -> c (b(a))
05:10:56 <lambdabot> (flip id .) . flip id
05:11:06 <mSSM> Botje: aaaah
05:11:08 <mSSM> Botje: thanks :?)
05:11:24 <ion> chousuke: ‚ÄúEnglish (international AltGr dead keys)‚Äù is a very nice layout.
05:11:54 <mSSM> ion: Using that
05:11:59 <`nand`> you can write Haskell just fine without needing backticks, for that matter
05:12:05 <`nand`> ion: us-intl-nodeadkeys is better
05:12:07 <`nand`> who wants dead keys? :)
05:12:24 <`nand`> the stupid thing about deadkeys is that eg. if you type "abc" it comes out as √§bc
05:12:51 <shachaf> Wait, which one is which?
05:12:53 <mSSM> Oh, I lied; I am just using altgr-intl
05:12:56 <neutrino_> hpc: if i stare long enough at it, i can see patterns emerge.
05:13:02 <neutrino_> hpc: then, the walls start closing in.
05:13:20 <shachaf> ion: If deadkeys is the one where "abc" -> √§bc", then I take back anything good I said about it before.
05:13:39 <`nand`> shachaf: that's what deadkeys are - at least, not all deadkeys layouts don't necessarily have to have " as a dead key
05:13:48 <`nand`> but that's what the ‚ÄúUS International AltGr dead keys‚Äù layouts I've come across did
05:13:57 <ion> shachaf: You only get them with AltGr and certain keys nearby Return. I have never once typed one accidentally.
05:14:08 <`nand`> technically, a dead key is any key that isn't a modifier and doesn't immediately produce output
05:14:17 <`nand`> (or special key)
05:14:20 <zomg> oh interesting
05:14:24 <zomg> first time I hear about dead keys
05:14:25 <Chousuke> ion: I need to type Finnish a lot. convenient to have √§ and √∂ easily accessible at least. hmm.
05:14:36 <shachaf> ion: How do you type ¬´"abc">?
05:14:37 <`nand`> √§ is Alt Gr + q for me
05:14:43 <zomg> finnish keyboard has dead ¬®
05:14:43 <ion> chousuke: √§: alt-q, √∂: alt-p
05:14:49 <ion> chousuke: Err. altgr
05:14:49 <`nand`> ¬´ is Alt Gr + [ for me
05:14:51 <zomg> Chousuke: get a finnish keyboard :P
05:14:58 <Chousuke> I have one :P
05:14:59 <`nand`> ion: yes, exactly :)
05:15:01 <tdammers> in vim: Ctrl-K, :, a
05:15:05 <shachaf> ion: Oh, wait.
05:15:08 <`nand`> ion: but that's the ‚ÄúInternational‚Äù part, not the ‚Äúdead keys‚Äù part
05:15:08 <ion> shachaf: Wat?
05:15:13 <zomg> Ah right, the minority that needs to type finnish would probably have those
05:15:14 <shachaf> AltGr deadkeys is the good one.
05:15:15 <ion> nand: yes
05:15:19 <zomg> Nobody else would want to write it anyway
05:15:20 <zomg> lol
05:15:25 <shachaf> ion: Never mind.
05:15:34 <`nand`> shachaf: which operating system, mind?
05:15:42 <shachaf> All of them at once!
05:15:53 <shachaf> But mostly VMS.
05:15:57 <`nand`> The ‚ÄúUS international deadkeys‚Äù layout in Windows 7 has " as a dead key
05:16:21 <`nand`> I made my own keymap after noticing that
05:16:23 <Chousuke> ion: having to use modifiers for √§ and √∂ would get tedious quickly. they're rather common.
05:16:45 <zomg> Yep, must have own keys for those for finnish
05:16:46 <`nand`> Chousuke: it's not worse than capitalizing
05:16:51 <zomg> I just switch between english and finnish layouts
05:16:53 <Chousuke> I could switch between layouts of course but that also gets tedious :P
05:16:57 <shachaf> I suspect ion knows how common √§ and √∂ are in Finnish.
05:17:10 <`nand`> it just gets a tad more tiring when you need to write capital letters with diareses; eg. √Ñ
05:17:11 <tdammers> `nand`: there's a similar keymap on most linux distros
05:17:13 <zomg> I tend to use english unless I need to type correct finnish :P
05:17:18 <ion> chousuke: I used to switch layouts between fi and us depending on what language i was typing, but i found just using this one and altgr-{q,p} for √§ and √∂ more convenient.
05:17:20 <Philonous_> Chousuke:  I have √§√∂√º on AltGr + ';[ respectively (that's where the umlauts are on the German keyboard) and it's not tedious at all
05:17:31 <tdammers> I use that for when I have to type German or Dutch
05:17:41 <`nand`> how common are √§√∂√º in Finnish compared with German?
05:17:48 <Chousuke> I suppose it might work.
05:17:54 <tdammers> I'd say a bit more common
05:17:58 <hpc> if you happen to be on windows, you can change keyboard layouts with alt-shift and ctrl-shift
05:18:04 <tdammers> not that I speak finnish
05:18:07 <Chousuke> how many finns are there on this channel :|
05:18:08 <basdirks_> on recent models of macbook one can hold vowel-char keys to insert variations
05:18:15 <ion> chousuke: For me, that‚Äôs a lesser evil than the pain with typing characters like ` [ ] \ with the fi layout.
05:18:21 <basdirks_> √†√°√¢√§√¶√£√•ƒÅ
05:18:23 <tdammers> hpc: if you happen to be using one of my machines, Ctrl-Alt-K switches keyboard layouts
05:18:41 <Philonous_> basdirks_:  That's what the compose key is for, no?
05:18:47 <mSSM> If you use the XkbVariant altgr-intl, your Umlauts are all going to be located around their "basic" letter, e.g.: R_Alt + a = √° , R_Alt + w = √•, R_Alt q = √§
05:19:06 <mSSM> √≠√≥√∂≈ì√∏
05:19:07 <hpc> real men use the combining characters :D
05:19:07 <basdirks_> Philonous_, it works ok if the variants are exceptions rather than the rule
05:19:23 <tdammers> mSSM: I find the deadkey ones easier to remember though
05:19:37 <mSSM> tdammers: I don't like deadkeys ^^
05:19:39 <sopvop> Be glad your alphabets are based on latin.
05:19:42 <mSSM> tdammers: is that a special variant?
05:19:47 <mSSM> tdammers: how is it called?
05:19:57 <hpc> sopvop: greek isn't so bad
05:19:57 <`nand`> mSSM: I replaced the useless keybinds on those other keys by interesting things like Œ± (AltGr + a), ≈ç (AltGr + o) and ≈´ (AltGr + u), though :)
05:19:59 <tdammers> lemme check
05:20:21 <mSSM> `nand`: Yeah, I am going to do that as well at some point.
05:20:21 <Chousuke> sopvop: I also know japanese. It's actually less of a pain to type than most programming languages
05:20:29 <mSSM> `nand`: Currently, I am using vim digraphs for that
05:20:45 * FireFly has important characters such as ‚àÄ and ‚àò on altgr+letters
05:20:47 <hpc> japanese is also really easy to do speech recognition on
05:20:59 <`nand`> mSSM: feel free to use my keymap as a starting point, it has lots of useful stuff (‚Ñö,‚Ñù,‚Ñ§,‚Ñï,‚Üí,‚áí,‚áî,‚ä•,‚ä§ ...)
05:20:59 <Philonous_> Oh, snap, I though this was -blah
05:21:04 <sopvop> But with latin and that fancy layouts you don't need to switch layout when changing language.
05:21:04 <mSSM> `nand`: I.e., in insert mode: Alt-k *a gives alpha
05:21:11 <hpc> Philonous_: nope; that's where we discuss haskell ;)
05:21:12 <Chousuke> hpc: I tried google's once on my android phone. got a good laugh out of it
05:21:29 <mSSM> `nand`: feel free to provide me with your keymap :D
05:21:29 <Philonous_> hpc:  Impossible, too much noise with all the lens discussion
05:21:33 <`nand`> also stuff like ‚àÉ‚àÄ‚âÖ‚äÜ‚äá‚äà‚äâ‚äÇ‚äÉ‚äÑ‚äÖ‚àà‚àâ‚ôÇ‚ôÄ in very convenient positions
05:21:35 <Chousuke> hpc: and it only got worse since it started interpreting my laughs as speech as well
05:21:36 <FireFly> `nand`: where is it located?
05:21:43 <`nand`> mSSM: FireFly: https://raw.github.com/nandykins/gentoo-conf/master/.Xmodmap
05:21:46 <FireFly> `nand`: seen the space-cadet keyboard? :P
05:21:54 <`nand`> you also have ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ... ¬π¬≤¬≥‚Å¥‚Åµ... :)
05:21:55 <mSSM> `nand`: I am thinking of putting AltGR R_Super and R_CTRL to good use
05:22:10 <mSSM> H,, although my HHKB doesn't have R_CTRL
05:22:12 <Philonous_> Actually, maybe we should take it to -blah
05:22:15 <edwardk> Philonous_: we moved most of it off to #haskell-lens
05:22:28 <`nand`> √ó√∑¬±‚âà‚â†¬∑‚àò‚àÖ‚â§‚â•‚ü®‚ü©¬¨œÄ‚Å∫ to list a few more useful things :)
05:22:46 <mSSM> `nand`: So you are writing a lot of utf-8 latex? I.e., xelatex, lualatex ?
05:23:03 <`nand`> mSSM: R_Super is a brilliant idea; I don't have that doing anything useful at all; nor R_CTRL
05:23:13 <`nand`> I don't have L_Super doing anything useful either, for that matter
05:23:14 <hpc> https://dl.dropbox.com/u/37707/math.klc -- relevant to windows users
05:23:16 <`nand`> mSSM: no, just IRC
05:23:20 <hpc> (open in MS keyboard layout editor)
05:23:35 <mSSM> `nand`: I use L_Super for xmonad
05:23:39 <`nand`> oh, it also comes with ‚Äú ‚Äù and ‚Äò ‚Äô which are very useful
05:23:42 <`nand`> mSSM: I use capslock for xmonad
05:23:51 <mSSM> `nand`: Caps-Lock is my super
05:23:53 <mSSM> err
05:23:55 <`nand`> ..mine too
05:23:55 <mSSM> CTRL
05:23:59 <`nand`> oh
05:24:11 <`nand`> Capslock is actually mapped to L_Super for me; but I could map the left ‚Äòwindows‚Äô key to something other
05:24:15 <mSSM> `nand`: I use vim a lot; it's nicer to have CTRL there
05:24:24 <`nand`> I use vim a lot too; I hardly ever use ctrl
05:24:25 * FireFly sudo mv mSSM /channels/#haskell-blah
05:24:33 * `nand` apologizes for the off-topicness
05:24:34 <hpc> [sudo] password for FireFly
05:24:37 <mSSM> sry
05:25:14 <FireFly> hpc: hunter2
05:27:21 <Mortchek> FireFly, sorry, try again.
05:27:27 <basdirks_> are there unicode symbols for open and close, or something similar?
05:27:37 <basdirks_> something similar as in start and end
05:27:52 <FireFly> Mortchek: oh you
05:28:23 <Mortchek> FireFly, I am curious - does NickServ notify you of failed attempts at ghosting? :P
05:28:40 <hpc> it does for me
05:28:48 <hpc> 08:28 -NickServ(NickServ@services.)- You may not ghost yourself.
05:29:01 <zhulikas> :D
05:29:16 <Mortchek> That would be a creative way of quitting.
05:30:00 <neutrino> you used to be able to get free /kill's on enterthegame
05:30:12 <neutrino> or was it quakenet
05:30:16 <FireFly>  NickServ: Mortchek!~danny@unaffiliated/mortchek failed to login to FireFly.
05:30:19 <mSSM> What are lenses?
05:30:19 <Mortchek> :D
05:30:21 <FireFly> Mortchek: so, yes. :P
05:30:42 <hpc> mSSM: you stare into them, and they stare back at you
05:31:01 <`nand`> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
05:31:03 <`nand`> mSSM ^
05:31:24 <Chousuke> mSSM: btw, for calculating the sums in your problem the best I could come up with was (sum *** sum) $ unzip both
05:32:47 <Chousuke> code golf in haskell is a lot of fun. I am constantly experiencing small epiphanies when I try to use all the weird operators.
05:32:51 <mSSM> Chousuke: I am looking at *** and I have no idea what that is?
05:33:05 <mSSM> (i.e. hoogle)
05:33:16 <hpc> :t (***)
05:33:17 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:33:26 <`nand`> I wonder if t (f a b) -> f (t a) (t b) is some useful generalization, like Traversable
05:33:31 <hpc> :t (***) `asAppliedTo` const
05:33:32 <lambdabot> (b -> b1 -> b) -> (b' -> c') -> (b, b') -> (b1 -> b, c')
05:33:40 <`nand`> for the [(a,b)] -> ([a], [b]) thing
05:34:02 <hpc> :t (***) `asAppliedTo` fix ($)
05:34:04 <lambdabot> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
05:34:09 <edwardk> mSSM: a lens is basically a tricky way for fusing together a couple of functions. one for getting part of a whole: a -> b, and one for taking a new part, and replacing it in the whole b -> a -> a
05:34:10 <hpc> there we go
05:34:13 <akamaus> hi all. I need to find a certain pattern of bytes inside a bytestring. The pattern is a byte sequence with some gaps with unknown bytes. What's the most idiomatic way of writing such a routine? I've made a sketch atto-parsec but looks like my way of finding a substring is ineffective. http://hpaste.org/78408
05:34:15 <Chousuke> `nand`: that looks like some sort of "reversal" operation
05:34:19 <hpc> you can treat that as the effective type of (***)
05:34:33 <edwardk> mSSM: given these you can compose them, so you can have chained 'references' to parts of parts, but it remains a pure functional program
05:34:49 <mSSM> edwardk: and how is that useful?
05:35:19 <edwardk> mSSM: the trick is you can pass them to functions for reading or writing to.from them, and there are a lot of generalizations of the idea that are also compatible with those functions, so you get a very 'do what i mean' -like API that is also principled
05:35:35 <edwardk> > ("hello","world")^._2
05:35:37 <lambdabot>   "world"
05:35:49 <mSSM> hpc: I still have no idea how that *** helps me in that example
05:35:52 <edwardk> that uses the lens _2 like it was a field accessor in an imperative language
05:35:54 <FireFly> :t asAppliedTo
05:35:56 <lambdabot> (t -> b) -> t -> t -> b
05:36:00 <edwardk> > ("hello",("world","!!!"))^._2._1
05:36:02 <lambdabot>   "world"
05:36:14 <mSSM> edwardk: cool, thanks
05:36:33 <edwardk> notice how i'm composing using (.) but the meaning is pretty intuitive to someone coming from an imperative background? they compose the way you'd expect
05:36:47 <edwardk> > ("hello",("world","!!!")) & _2._1 .~ "mSSM"
05:36:49 <lambdabot>   ("hello",("mSSM","!!!"))
05:37:02 <edwardk> and you can update them, even deep inside a structure like that
05:37:17 <edwardk> in a mutable language you think nothing of writing: foo.bar.baz += 12
05:37:35 <edwardk> in an language that favors immutable objects that is a much harder thing to do
05:37:35 <`nand`> > let both = ([1,2,3], [4,5,6]) in both %~ sum
05:37:37 <lambdabot>   Couldn't match expected type `Control.Lens.Setter.Setting
05:37:37 <lambdabot>                  ...
05:37:44 <`nand`> oh
05:38:04 <mSSM> edwardk: ok
05:38:15 <`nand`> > ([1,2,3], [4,5,6]) % both %~ sum
05:38:16 <lambdabot>   Not in scope: `%'
05:38:16 <lambdabot>  Perhaps you meant `R.%' (imported from Data.Ratio)
05:38:18 <edwardk> > sumOf (both.folded) ([1,2,3], [4,5,6])
05:38:19 <lambdabot>  Terminated
05:38:20 <`nand`> > ([1,2,3], [4,5,6]) & both %~ sum
05:38:22 <lambdabot>   (6,15)
05:38:26 <edwardk> > sumOf (both.folded) ([1,2,3], [4,5,6])
05:38:27 <lambdabot>   21
05:38:32 <`nand`> that's not what he wants
05:38:39 <edwardk> ah
05:38:47 <mSSM> (my lens question and the first thing have nothing to do with each other)
05:38:50 <`nand`> ok
05:38:52 <`nand`> :)
05:39:00 <`nand`> but it's a nice solution to your problem, other than the (***) thing
05:39:04 <shachaf> What's the first question?
05:39:15 <`nand`> how to reduce the boilerplate in http://hpaste.org/78406
05:39:52 <mSSM> What's a boilerplate?
05:40:02 * mSSM = codemonkey :/
05:40:13 <`nand`> redundant crap you're forced to write by whatever braindead system is limiting you
05:40:19 <`nand`> loosely speaking
05:40:49 <Chousuke> boilerplate is code that the language forces you to write even though it has no real "meaning" to what your application actually does
05:41:11 <mSSM> `nand`: hoogle doesn't know what %~ is :(
05:41:36 <shachaf> mSSM: Hayoo does!
05:41:42 <Chousuke> a good example would be having to write a class and a method in java just to print out "hello world"
05:41:52 <`nand`> mSSM: http://ekmett.github.com/lens/Control-Lens-Setter.html#g:4
05:42:03 <csigusz> ahhh
05:42:15 <`nand`> not to be confused with biplates
05:42:24 <csigusz> that isn't the definition of boilerplate wiki has but that's good to know
05:42:37 <mSSM> `nand`: ok, I think I am not going to use that, although it's cool
05:42:37 <csigusz> maybe wiki's def is wrong :)
05:42:45 <`nand`> > ([1,2,3], ("hello", [4,5,6], "world")) & biplate +~ 1
05:42:47 <lambdabot>   ([2,3,4],("hello",[5,6,7],"world"))
05:43:10 <csigusz> why does haskell have to be so purdy
05:43:17 <`nand`> blame edwardk
05:43:22 <zhulikas> how the hell does it work
05:43:27 <`nand`> :t biplate
05:43:28 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
05:43:28 <zhulikas> @type biplate
05:43:29 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
05:43:37 <zhulikas> damn you, edwardk!
05:43:40 <`nand`> good ol' Data.Data.Data
05:43:59 <`nand`> either way, Typeable is what makes the mixed typing work it seems
05:44:23 <zhulikas> I'll probably stick to vanilla haskell data access
05:44:24 <sopvop> Using Typeable is admitting defeat.
05:44:31 <`nand`> :)
05:44:33 <csigusz> edwardk is pretending to be away from his computer
05:44:38 <csigusz> he's a sneaky sneak
05:45:06 <`nand`> > universe [1..3]
05:45:08 <lambdabot>   [[1,2,3],[2,3],[3],[]]
05:45:15 <art2art> hi all
05:45:24 <sopvop> zhulikas: view, set, over in lens are less scary and very useful. Of course there are operators...
05:45:38 <latro`a> :t universe
05:45:40 <lambdabot> Plated a => a -> [a]
05:45:41 <mSSM> So this (sum *** sum) $ unzip both simply is `(***) sum sum $ unzip both'
05:45:51 <`nand`> yes
05:46:06 <`nand`> the ( ) is redundant around (sum *** sum)
05:46:06 <zhulikas> sopvop, it's just so far from what haskell used to be :D
05:46:08 <shachaf> (*) ((***) sum sum) (unzip both)
05:46:12 <shachaf> Er
05:46:14 <shachaf> ($) ((***) sum sum) (unzip both)
05:46:36 <`nand`> (($) (((***) sum) sum)) (unzip both))
05:47:06 <sopvop> zhulicas: I use lens as replacement for fugly record update syntax. And don't touch anything else. Besides Iso also, Isos are nice.
05:47:13 <`nand`> missing a (
05:47:28 <mSSM> I am just not sure how to read the definition of *** on hoogle
05:47:37 <mSSM> :t (***)
05:47:38 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
05:47:38 <`nand`> lens has a lot of interesting operators
05:47:55 <`nand`> mSSM: perhaps it would help to note that there's an instance Arrow (->)
05:47:57 <`nand`> so that can be seen as
05:48:02 <`nand`> :t (***) `asAppliedTo` fix ($)
05:48:03 <lambdabot> (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
05:48:35 <mSSM> `nand`: can you explain to me what that arrow in here actually is?
05:48:52 <`nand`> you mean, what Arrow is?
05:48:55 <mSSM> yes
05:48:59 <`nand`> http://www.haskell.org/haskellwiki/Typeclassopedia#Arrow
05:49:32 <Nereid> heh, I found a ghc bug
05:49:36 <Nereid> http://hackage.haskell.org/trac/ghc/ticket/7368#comment:5
05:49:56 <Chousuke> Data.Data.Data? ehh
05:50:52 <Nereid> oh, turns out I can replace f (Bad f) with f a and it still does the same thing
05:51:22 <mSSM> `nand`: Ok, cool; I think I am understanding this
05:51:37 <Nereid> don't worry about Arrow too much
05:51:47 <mSSM> `nand`: so this is actually a straight forward way to make a new function
05:51:49 <mSSM> in a way..
05:51:50 <Nereid> but it's good to understand how the Arrow methods apply to (->)
05:52:05 <`nand`> mSSM: yes; Arrow is a generalization of functions
05:52:14 <Nereid> :t asAppliedTo
05:52:16 <lambdabot> (t -> b) -> t -> t -> b
05:52:22 <mSSM> So you basically combine two sums a -> a', b -> b' to get (a,b) -> (a',b')
05:52:29 <`nand`> correct
05:52:43 <`nand`> or in this case; [a] -> a; [b] -> b to get ([a], [b]) -> (a, b)
05:52:55 <Chousuke> is this asAppliedTo function only useful for type queries?
05:53:04 <mSSM> And for my simple problem, does it make sense to use this? I really like this syntax.
05:53:13 <`nand`> Chousuke: sometimes you can use it to avoid having to use ScopedTypeVariables
05:53:19 <`nand`> in cases where some type would otherwise be ambiguous
05:53:23 <Nereid> but I like ScopedTypeVariables.
05:54:13 <`nand`> :t \a -> const () (mempty `asTypeOf` a)
05:54:14 <lambdabot> Monoid b => b -> ()
05:54:19 <`nand`> :t \a -> const () mempty
05:54:20 <lambdabot>     Ambiguous type variable `b0' in the constraint:
05:54:20 <lambdabot>       (Monoid b0) arising from a use of `mempty'
05:54:20 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
05:54:39 <Nereid> what a silly function
05:54:53 <Nereid> :p
05:55:20 <`nand`> :t \a -> show (read "123" `asTypeOf` a)
05:55:21 <lambdabot> (Read a, Show a) => a -> String
05:55:42 <Nereid> slightly more useful :p
05:56:15 <Nereid> :t  \a -> show (read "123" :: a) :: forall a. a -> String
05:56:16 <lambdabot>     Couldn't match expected type `a -> String'
05:56:17 <lambdabot>                 with actual type `String'
05:56:17 <lambdabot>     In the return type of a call of `show'
05:56:27 <Nereid> :t (\a -> show (read "123" :: a)) :: forall a. a -> String
05:56:29 <lambdabot>     No instance for (Show a1)
05:56:29 <lambdabot>       arising from a use of `show'
05:56:29 <lambdabot>     In the expression: show (read "123" :: a)
05:56:38 <Nereid> :t (\a -> show (read "123" :: a)) :: forall a. (Read a, Show a) => a -> String
05:56:40 <lambdabot> (Read a, Show a) => a -> String
05:57:26 <Nereid> I didn't know :: was tighter than lambda.
05:57:40 <Nereid> :t over both sum
05:57:41 <lambdabot> Num b => ([b], [b]) -> (b, b)
05:59:32 <yaw> is there a compose operator where the second function takes 2 arguments?
05:59:39 <yaw> e.g. c2 f g a b = f (g a b)
06:00:25 <Botje> isn't that .: ?
06:00:33 <Botje> @pl f g a b = f (g a b)
06:00:33 <lambdabot> f = fix ((.) . (.))
06:00:42 <Botje> oh, bleh.
06:01:00 <yaw> hah
06:01:06 <Nereid> fix???
06:01:16 <zhulikas> does it work the other way around?
06:01:18 <Nereid> oh yeah heh
06:01:27 <Nereid> @pl \f g a b -> f (g a b)
06:01:27 <lambdabot> (.) . (.)
06:01:31 <zhulikas> @uglify fix ((.) . (.))
06:01:31 <lambdabot> Unknown command, try @list
06:01:37 <Botje> yeah, I missed someting.
06:01:46 <Botje> @pl p f g a b = f (g a b)
06:01:46 <lambdabot> p = (.) . (.)
06:01:52 <Botje> :t (.:)
06:01:53 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
06:01:57 <Nereid> or, (f .) . g
06:02:03 <zhulikas> :t (:D)
06:02:04 <lambdabot> Not in scope: data constructor `D'
06:02:08 <zhulikas> oh, ok :/
06:02:16 <zhulikas> I guess Haskell is no joke
06:02:20 <yaw> ok, the boobs is what i'm after :)
06:02:26 <Nereid> ((f .) . g) x y = ((f .) (g x)) y = (f . g x y) = f (g x y)
06:02:33 <yaw> (.).(.)
06:02:45 <Nereid> "((f .) . g) composes f with the function returned by g"
06:03:03 <Nereid> :t (.)(.)
06:03:04 <lambdabot> (Functor f1, Functor f) => f (a -> b) -> f (f1 a -> f1 b)
06:03:15 <Nereid> :t let (.) = (Prelude..) in (.)(.)
06:03:16 <lambdabot> (a -> b -> c) -> a -> (a1 -> b) -> a1 -> c
06:03:28 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)
06:03:29 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
06:03:32 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)
06:03:33 <lambdabot> (a -> a1 -> b -> c) -> a -> a1 -> (a2 -> b) -> a2 -> c
06:03:35 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)(.)
06:03:36 <lambdabot> (b1 -> c) -> (b -> b1) -> (a -> b) -> a -> c
06:03:40 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)(.)(.)
06:03:41 <lambdabot> (b -> b1 -> c) -> (a -> b) -> a -> (a1 -> b1) -> a1 -> c
06:03:47 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)(.)(.)(.)(.)(.)(.)
06:03:48 <lambdabot> (b1 -> b -> c) -> (a -> b1) -> a -> (a1 -> b) -> a1 -> c
06:03:57 <Nereid> proof that 6 = 10
06:03:58 <zhulikas> does it turn you on?
06:04:14 <shachaf> Nereid: First you have to show that there's only one inhabitant of each type!
06:04:27 <Nereid> :p
06:04:35 <shachaf> Well, "of that ype".
06:04:36 <shachaf> t
06:05:02 <shachaf> (Which isn't very hard to show.)
06:05:03 <Nereid> well you can prove that (.)^6 = (.)^10 directly
06:05:07 <yaw> (.).(.)  "of of of". just doesn't parse in my head.
06:05:08 <shachaf> Sure.
06:05:19 <shachaf> (.) isn't really pronounced "of"
06:05:21 <Nereid> :t let (.) = (Prelude..) in (.)(.)(.)(.)(.)(.)(.)(.)(.)
06:05:23 <lambdabot> (a -> a1 -> a2 -> b -> c) -> a -> a1 -> a2 -> (a3 -> b) -> a3 -> c
06:05:34 <yaw> compose of compose?
06:05:41 <shachaf> compose composed with compose
06:05:52 <yaw> hehe
06:10:00 <miasma> i read this elsewhere: "I believe functional languages are better suited for this purpose, because it's easier to reason about the code" "it's impossible to reason about code that lacks a notion of storage duration. you can reason perfectly well about how it behaves in an abstract mathematical world on an infinite tape but you can't reason at all about how it behaves on a finite machine"
06:10:37 <miasma> this guy is claiming that C is better suited for reliable software engineering (e.g. critical security systems) than haskell
06:11:30 * hackagebot shuffle 0.1.0.0 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.0.0 (JeroenBransen)
06:11:37 <zomg> miasma: the argumentation seems about as reasonable as the argumentation I've heard for FP, such as "it's impossible to reason about OOP code"
06:11:56 <zomg> not exact quote, it was phrased in a somewhat more intellectual fashion but the point was the same =)
06:12:06 <DT`> miasma, he's probably talking about GC.
06:12:19 <Nereid> what a silly argument
06:12:22 <bitonic> miasma: I think it‚Äôs main point is that with C you can do explicit memory management, which is a safeguard against many things - and in fact critical software on embedded platform is going to be in C with very explicit and ‚Äúbrutal‚Äù memory allocation
06:12:22 <lambdabot> bitonic: You have 1 new message. '/msg lambdabot @messages' to read it.
06:12:24 <DT`> (because, well, real time GCs don't exist)
06:12:57 <miasma> in this case it doesn't matter wheter the GC is realtime or not
06:13:00 <Nereid> although it's hard to say for sure unless you say what "this purpose" is
06:13:07 <bitonic> miasma: e.g. they allocate a buffer at the beginning and that‚Äôs all they use - see for example the JPL coding standards.  however this does not mean that functional concepts are not valuable
06:13:07 <miasma> just the reliability = does it ever crash or run out of memory
06:13:21 <Nereid> it's easier to verify correctness of haskell code
06:13:37 <bitonic> Nereid: his point is not ‚Äúcorrectness‚Äù but reliability
06:13:38 <Nereid> but harder to reason about its performance characteristics
06:13:43 <Nereid> I'd say.
06:13:49 <bitonic> and it‚Äôs easier to write reliable C code, in that sense
06:13:52 <Nereid> though not extremely hard.
06:14:09 <bitonic> so I don‚Äôt think it‚Äôs a bad point
06:14:11 <miasma> of course if you only have a handful of C, it's even possible to prove it correct
06:14:20 <Nereid> sure, in some situations it might matter a lot.
06:14:47 <Nereid> which is why I want to know what "this purpose" is.
06:14:48 <bitonic> moreover there are *a lot* of static analysis tools available for C, and tools to prove correctness
06:15:09 <miasma> but if we are talking about systems with 1 MLOC. maybe it's even possible to set an upper bound for memory use in such case and improve the sw robustness (in the context of FPLs)? e.g. limiting the memory of subroutines, ensuring the main routine can always allocate
06:16:22 <Nereid> in any case that doesn't look like an argument against FP specifically
06:16:58 <bitonic> no, I agree that it‚Äôs not about FP.  a lot FP concepts are applied in reliable concepts - immutability, message passing
06:16:59 <RenJuan> oh
06:17:26 <RenJuan> we're having an argument against FP in #haskell?
06:17:40 <miasma> is it really that hard to analyze the storage duration and storage requirements for functional code?
06:18:00 <miasma> assuming you have some restricted subset of the language
06:18:30 <Nereid> it's not too hard, but it's not as easy as looking at where you write malloc and free
06:19:42 <bitonic> miasma: it‚Äôs not really about how ‚Äúfunctional‚Äù the code is, but how high level it is
06:19:50 <miasma> you could explicitly allocate such memory and only allow in-place modifications with uniqueness types
06:20:01 <miasma> then you'd only need to worry about the stack
06:20:09 <bitonic> miasma: the higher level it is the harder it will be to reason about its low level behaviour
06:23:12 <miasma> the original argument = "this purpose" was about operating systems and high level language virtual machines
06:31:00 <basdirks_> why would I get "ambiguous occurrence `<&>'" for "infix 7 <&>"?
06:31:13 <Nereid> more context please
06:31:37 <Nereid> or, did you define your own <&> while it is also imported from some module?
06:31:50 <basdirks_> good question, let me check
06:32:16 <basdirks_> yes I did define it
06:32:20 <Nereid> although I would expect it would tell you more detail
06:32:49 <basdirks_> aha sorry yes, you are right, it's also exported from lens
06:32:56 <Nereid> it is
06:33:09 <basdirks_> ironically an hour ago I was asking whether it was considered good practice to do explicit imports
06:33:12 <basdirks_> I guess this answers it
06:33:48 <typoclass> basdirks_: you only need to add do "hiding ((<&>))"
06:34:21 <basdirks_> yeah =]
06:34:55 <basdirks_> in other contexts I would have understood "ambiguous" to mean multiple definitions
06:35:33 <basdirks_> but I don't yet know all the lens operators
06:35:55 <shachaf> ghci can tell you.
06:36:06 <shachaf> ghci foo.hs; :i <&>
06:36:11 <basdirks_> okay
06:36:31 <Nereid> :t ?x <&> ?f
06:36:32 <lambdabot> (?x::f a, ?f::a -> b, Functor f) => f b
06:36:33 <basdirks_> ghci did tell me about the ambiguity issue through vim
06:36:38 <Nereid> :t ?x & mapped %~ ?f
06:36:39 <lambdabot> (?x::f a, ?f::a -> b, Functor f) => f b
06:37:15 <basdirks_> ah cool
06:37:18 <shachaf> Hmm, I think <&> was previously used internally but no longer.
06:37:24 <shachaf> Maybe it shouldn't be exported at all.
06:37:33 <Nereid> why should it be used internally?
06:38:12 <shachaf> ?
06:38:49 <Nereid> I mean
06:38:59 <Nereid> why would it have been?
06:39:01 <shachaf> @ask edwardk Should (<&>) be exported? It was only added for the implementation of upon, so now it's not used at all.
06:39:01 <lambdabot> Consider it noted.
06:42:13 <isturdy> @pl insHead (l:t) i = (i:l):t
06:42:13 <lambdabot> insHead = ap (flip . ((:) .) . flip (:) . head) tail
06:42:30 <quchen> :t ?
06:42:31 <lambdabot> parse error on input `?'
06:42:33 <quchen> :t ?x
06:42:34 <lambdabot> (?x::t) => t
06:42:59 <typoclass> quchen: it's the implicit parameters extension
06:43:31 <quchen> Thanks, was about to ask that - it doesn't work in GHCi. Should I just start it with -XImplicitParameters or something?
06:43:55 <typoclass> quchen: i think you can just do ":set -XImpli<tab>"
06:44:09 <Nereid> :t \ls i -> ls & _head (i:)
06:44:10 <lambdabot>     Not in scope: `_head'
06:44:10 <lambdabot>     Perhaps you meant one of these:
06:44:10 <lambdabot>       `head' (imported from Data.List),
06:44:13 <Nereid> bah
06:44:52 <quchen> typoclass: Therer are too many ImplicitP(relude) parameters ;-)
06:45:15 <quchen> Are there any drawbacks when using this? Is it safe to add it to my ghci.conf?
06:45:30 <Nereid> should be safe
06:45:32 <Nereid> I did it
06:45:33 <Nereid> ;)
06:45:41 <Nereid> along with a bunch of other extensions
06:45:52 <Nereid> (like turning off the dmr...)
06:45:58 <quchen> Which ones, if you don't mind me asking? I was about to add bang patterns as well
06:46:01 <quchen> DMR?
06:46:08 <Nereid> dreaded monomorphism restriction
06:47:04 <quchen> Haha. I haven't understood yet why it's evil and when it makes trouble though.
06:48:24 <Nereid> @where dmr
06:48:24 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
06:50:25 <quchen> Another question: Can I somehow color text in GHCi? I tried assigning some colors to the prompt, so I can easily spot where I typed in the last calculation, but it didn't work using Bash codes.
06:50:42 <shachaf> quchen: Not really.
06:50:42 <quchen> I'm not talking about syntax highlighting, just having "Prelude >" in red for example.
06:50:48 <Nereid> I did that.
06:50:55 <shachaf> Oh, maybe you can use ANSI color codes for just the prompt.
06:51:20 <Nereid> :set prompt "^[[31;1m>>> ^[[0m"
06:51:32 <shachaf> Yep.
06:51:35 <quchen> Aaah, I used \e...
06:52:34 <quchen> Hmm, doesn't work. :-( It just uses that color code instead of "Prelude >".
06:52:47 <Nereid> oh well yes, my prompt is just >>>
06:53:01 <Nereid> you can put %s where you want your module list though
06:53:14 <tomeo_> is it possible to write a pattern for a function that takes two strings which matches only when the two strings are equal?
06:53:18 <quchen> No, I meant "It's printing [[31,1..."
06:53:19 <dmwit> > -abs (-3)
06:53:21 <lambdabot>   -3
06:53:21 <shachaf> quchen: Use \27
06:53:28 <Nereid> tomeo_: f x y | x == y = ...
06:53:31 <shachaf> quchen: I suspect Nereid meant a literal Esc character, not ^ followed by [
06:53:37 <Nereid> I did mean that, yes.
06:53:45 <quchen> Ah.
06:53:48 <tomeo_> Nereid: isnt that a guard not a pattern?
06:53:52 <quchen> ^ is generally interpreted as ESC? Good to know.
06:54:00 <Nereid> tomeo_: yes. you can't do it with patterns alone
06:54:05 <Nereid> quchen: no, ^[ is ESC
06:54:13 <Nereid> in fact, you can type ctrl-[ to input esc
06:54:13 <tomeo_> Nereid: right, thats what I wanted to know. Thanks :)
06:54:25 <quchen> Works! Wonderful, thank you.
06:55:16 <Nereid> and of course you can look up the commands if you want different colours or whatever.
06:55:20 <Nereid> I like my bold red though.
06:55:51 <Nereid> I wish I could also set the input text to a different colour but oh well
06:55:59 <Nereid> (like the stuff you actually type)
06:56:09 <Nereid> (you can do that, but the output gets coloured the same way)
06:56:38 <Nereid> ah
06:56:52 <Nereid> instead of inserting a literal ESC into the file, you can also just type \ESC
07:03:56 <FireFly> > ord '[' - 27
07:03:58 <lambdabot>   64
07:04:11 <shachaf> Or \27
07:06:44 <tomeo_> When I use _ in a pattern, I can't access that paramter in the function right? I couldn't for example return the length of whatever comes on _
07:06:59 <dmwit> correct
07:07:14 <tomeo_> thanks
07:10:40 <wwall> hello
07:11:22 <elliott> tomeo_: yeah, that is the point of _ :)
07:11:56 <tomeo_> In math I could say f(x) = g(x) = x^2 for example. But f x = g x = x^2 doesn't seem to work in Haskell. Is that correct or am I just missing parenthesis?
07:12:02 <typoclass> wwall: hi
07:12:09 <dmwit> tomeo_: That's correct, there is no way to do that.
07:12:27 <dmwit> tomeo_: However, you can write "f x = x^2; g = f".
07:12:28 <elliott> f x = x^2; g = f
07:12:37 <elliott> dmwit: snap
07:12:45 <tomeo_> dmwit: thats what I've done. trying to make it prettier though :)
07:12:58 <elliott> that's prettier than the mathematical version imo :)
07:13:11 <quchen> Using multiple = in one line is soooo C
07:14:23 <wwall> I was going to ask a question, but then I just solved it.
07:15:06 <dmwit> wwall++
07:15:17 <shachaf> (f,g) = join (,) (\x -> x^2)
07:15:48 <elliott> shachaf: You mean (f,g) = (\x -> x^2) ^. remit both.
07:15:48 <quchen> shachaf: At top level?
07:15:50 <elliott> (Does that work?)
07:15:58 <elliott> (Don't do either of these.)
07:16:23 <quchen> :t join join (,) (\x -> x^2)
07:16:24 <lambdabot>     Couldn't match expected type `t0 -> t1' with actual type `(a0, a0)'
07:16:24 <lambdabot>     Expected type: a0 -> a0 -> t0 -> t1
07:16:24 <lambdabot>       Actual type: a0 -> a0 -> (a0, a0)
07:16:26 <dmwit> quchen: Yes, top-level definitions can use pattern matching.
07:16:27 <shachaf> elliott: both is a projection now?
07:16:27 <quchen> :t join (,) (\x -> x^2)
07:16:28 <lambdabot> Num a => (a -> a, a -> a)
07:16:41 <elliott> shachaf: Well, why shouldn't it be?
07:16:48 <dmwit> Though class method definitions can't. =(
07:16:58 <quchen> dmwit: Didn't know that, thanks. Man, coming here without questions answers so many things every time.
07:16:59 <shachaf> I thought Projection s t a b = (s -> Maybe a, b -> t)
07:17:06 <elliott> shachaf: Hmm.
07:17:25 <shachaf> quchen: I wasn't serious about that. :-)
07:17:29 <shachaf> But it ought to work.
07:18:15 <quchen> shachaf: That's what I always say when I obfuscate my code ;-)
07:18:18 <dmwit> I tried "instance (Monad m, Num a) => Num (m a) where [(+), (-), (*)] = map liftM2 [(+), (-), (*)]" once but it doesn't work. =/
07:19:06 <dmwit> (I don't think there's any fundamental reason for this -- probably just an oversight.)
07:19:08 <shachaf> > Endo { appEndo x = x } -- :-(
07:19:09 <lambdabot>   <hint>:1:16: parse error on input `x'
07:19:21 <dmwit> shachaf: Yes, that one is super-annoying, too.
07:19:33 <shachaf> dmwit: Pattern matching in instances sounds pretty evil to me.
07:19:47 <dmwit> Though perhaps more reasonable, since if that worked you would want some syntax for { appEndo True = False; appEndo False = True } which could get a bit awkward.
07:19:52 <elliott> dmwit: oversight, or precaution?
07:20:06 <dmwit> If it were precaution, why would it be allowed at the top level?
07:20:22 <dmwit> What's different about "module ... where" compared to "class ... where"?
07:20:25 <Joe____> First time in this Channel.
07:20:28 <dmwit> err... "instance ... where", I mean
07:20:29 <Joe____> First time using Haskell!
07:20:36 <dmwit> Joe____: Welcome!
07:20:45 <Joe____> Got a quick question, wondering if someone can answer for me :)
07:20:50 <Joe____> or point me in the right direction!
07:20:55 <shachaf> dmwit: You can define arbitrary names in a module.
07:21:24 <Joe____> I'm creating an application, which will actually need to use Rational Numbers (Ratio Integer), Doubles and Integers around the application.
07:21:32 <dmwit> Alright. I'm not sure how that's relevant, but it is a difference.
07:21:50 <Joe____> I've currently created my own genericnumber data type to work with these three types
07:22:29 <Joe____> However, to make my types work with the normal mathematical inflix operators
07:22:41 <Joe____> I am unsure how to extend these operators to work with my new data type
07:22:52 <dmwit> Strange. I would thing Rational was already a pretty good generic number type. It certainly subsumes Double and Integer.
07:23:02 <dmwit> Anyway, for the operators, you just implement the appropriate type class.
07:23:07 <shachaf> Rational subsumes Double?
07:23:09 <dmwit> e.g. for (+), (-), and (*), implement Num
07:23:14 <shachaf> > pi :: Rational
07:23:15 <lambdabot>   No instance for (GHC.Float.Floating GHC.Real.Rational)
07:23:15 <lambdabot>    arising from a us...
07:23:17 <dmwit> for (/) implement... Floating?
07:23:26 <dmwit> shachaf: pi :: Double is a lie anyway
07:23:44 <osfameron> the pie is a lie?
07:23:58 <shachaf> dmwit: Yes, but there's one optimal lie.
07:24:04 <shachaf> Who knows which lie to tell for Rational?
07:24:04 <rwbarton> Fractional
07:24:20 <dmwit> rwbarton: thanks
07:24:36 <Joe____> Ok thanks. I'll check that out.
07:25:12 <dmwit> shachaf: Give it 100 digits. That's enough to calculate the circumference of the observable universe (given its current radius) to within a hundredth the width of an electron.
07:25:31 <dmwit> Those numbers made up on the spot but probably not too far wrong.
07:26:50 <vraid> i thought it was way less
07:27:20 <dmwit> Yeah, Wolfram Alpha tells be 44 digits is enough for that.
07:27:37 <dmwit> Also I apparently mistype 'b' for 'm' a lot -- at least twice in the last two days.
07:27:38 <elliott> if you are using Rational you are probably the kind of person who does not care for things like the universe :P
07:27:47 <mSSM> I have a question about stateful computations: I have the following type: newtype Ising = Ising { unI :: (GenIO, Grid, Int, Int) }
07:28:03 <mSSM> (Ignore this part, not complete message)
07:28:09 <bitonic> mSSM: why a newtype?
07:29:53 <mSSM> I have newtype Ising = Ising { unI :: (GenIO, Grid, Int, Int) }, where Grid is a mutable, unboxed vector, which gets constantly updated during the run of the program; now, I want to update the Ints as well, like x = x + delta; that means that I have to make the Int's mutable as well, right?
07:30:11 <mSSM> bitonic: Because that made the most sense... I am not defining a new type, am I?
07:30:29 <elliott> (You should use data, not newtype.)
07:30:33 <elliott> data Ising = Ising GenIO Grid Int Int
07:30:54 <mSSM> elliott: Why?
07:31:36 <rwbarton> why not?
07:31:37 <dmwit> There's no benefit to using a newtype (you still get the (,,,) constructor) and it's syntactically heavier at use sites.
07:32:13 <elliott> mSSM: because newtype is for when you want to wrap one single type.
07:32:32 <elliott> The data form is more idiomatic, less visual noise to construct/deconstruct, and can be tweaked (e.g. to make some of the fields strict) much more easily.
07:33:11 <mSSM> dmwit: I read in RWH that newtype is more efficient then data
07:33:31 <dmwit> mSSM: "you still get the (,,,) constructor"
07:33:34 <yitz> mSSM: Int is not mutable. use a reference, STRef Int or IORef Int
07:33:41 <rwbarton> but then you went an un-efficiented it
07:33:45 <rwbarton> *and
07:33:58 <rwbarton> there is no "more" or "less efficient" version of what you are doing
07:34:00 <dmwit> mSSM: So, data Foo = Foo (Bar, Baz) is less efficient than newtype Foo = Foo (Bar, Baz), but data Foo = Foo Bar Baz and newtype Foo = Foo (Bar, Baz) are identical.
07:34:03 <elliott> mSSM: Then you misunderstood it.
07:34:06 <rwbarton> as far as newtype/data is concerned
07:34:22 <elliott> newtype is more efficient than data in many circumstances. The two types being compared here is not such an instance: they are equivalent
07:34:23 <yitz> mSSM: in my opinion you have gone down a bad road that will lead to very ugly code. why are using all that mutable stuff?
07:34:25 <rwbarton> right, what dmwit said
07:35:10 <rwbarton> anyways, can't you just produce a new Ising? rather than use STRef s Int or whatever
07:36:12 <mSSM> yitz: Well, I have a a grid (a Vector here), with n*n entries (n being some int), and the value at each entry can flip from +1 to -1 (and vise versa) depending on some probability.
07:36:39 <mSSM> I thought it's more efficient to just flip that value in memory as compared to creating an entirely new grid.
07:37:28 <copumpkin> mSSM: depending on how you're accessing the grid, cache will start having a noticeable effect :P
07:37:42 <yitz> mSSM: "more efficient" is relative. you might gain a tiny bit of speed by using mutability, at the cost of making a total wreck out of your code. are you sure this isn't premature optimization>
07:37:46 <yitz> ?
07:37:46 <copumpkin> but keep in mind that Vector stuff fuses
07:37:59 <copumpkin> so you might be able to avoid doing anything mutable and still get a pretty efficient implementation
07:38:06 <rwbarton> yitz, how can you possibly know that it is "tiny"
07:38:09 <copumpkin> note that it won't do any fusion if you do things mutably
07:38:46 <yitz> rwbarton: well it is certainly tiny for each access. obviously it depends on scale, algorithms, etc.
07:39:05 <mSSM> yitz: It breaks down to this: If I have e.g. a grid of 64*64 entries with one value each, at the next step I might have a grid with the same size but completely different values.
07:39:11 <copumpkin> mSSM: most Vector operations, when chained, will not make an "entirely new grid"
07:39:43 <rwbarton> if you are doing something (or considering doing something) to every value of the grid in one pass, then mutability does not gain you anything
07:40:27 <yitz> rwbarton: but you would never start out with a mutable approach unless either you have tried writing normal code, encountered a terrible performance problem, and, after studying it, determined that mutability is the best way to solve the problem.
07:40:34 <rwbarton> ...
07:40:46 <yitz> or if you already have enough experience in the problem space to know that this is necessary
07:41:23 <mSSM> Ok, let's say: I have read a program in C where it's obviously implemented that way, and then I went and found some similar program online.
07:41:26 <mSSM> And now I am playing with it.
07:41:36 <copumpkin> but what if I need to run the disjoint set algorithm over a huge dataset!?!?
07:41:46 <yitz> mSSM: try it the regular way. if you encounter problems, then come back here and ask.
07:42:25 <mSSM> yitz: so do you suggest I should use e.g. a list?
07:42:35 <copumpkin> Vector is good
07:42:39 <copumpkin> depending on how you use it
07:42:45 <dmwit> rwbarton: That's not precise. Mutability still saves you one Vector allocation, even if it doesn't save you any per-element computation time.
07:42:49 <copumpkin> if you find yourself consing onto Vector, you probably don't want to use it
07:42:56 <dmwit> um... maybe
07:42:59 <rwbarton> dmwit: yes, it can save a factor of 2 memory usage
07:42:59 <copumpkin> dmwit: fusion?
07:43:02 <yitz> mSSM: porting a C program in that way is probably not very useful. you would do it differently in haskell. so you're not learning idiomatic haskell, and you're ending up with a program that is worse than the original C program.
07:43:05 <dmwit> maybe it saves you one Vector allocation, if fusion doesn't fire
07:43:16 * copumpkin performs the fusion dance with dmwit 
07:43:51 <copumwit> oh noes
07:43:57 <copumpkin> lol
07:44:14 <rwbarton> but it won't save a factor of a million, like updating a single element of a 1M-long mutable vector will over updating a single element of a 1M-long immutable vector
07:44:16 <yitz> a 64x64 grid is not very big
07:44:55 <rwbarton> yes, as it turns out
07:45:12 <copumpkin> http://www.youtube.com/watch?v=YcrocgMBBDI
07:45:36 <yitz> depending on what this program does, it could very well be that [[Integer]] would work out just fine
07:47:09 <rwbarton> yitz, I think I misread what you wrote above, as "you might gain, at best, a tiny bit of speed by using mutability, at the cost of (certainly) making a total wreck out of your code"
07:47:27 <rwbarton> when now I think you intended "it might be the case that: you gain a tiny bit of speed while making a total wreck out of your code"
07:47:53 <yitz> rwbarton: right. actually quite likely in practice, from experience. but you never know.
07:47:54 <rwbarton> I would certainly agree with the latter, but not the former.
07:48:04 <mSSM> Well, I am going to start changing this beast then
07:48:11 <mSSM> Let's see what I come up with.
07:49:32 <mSSM> For what it's worth: it's this code: https://github.com/aivuk/Simple-Ising/blob/master/ising.hs the interesting stateful computation happens in lines 55 to 64, and of course 16 to 21
07:49:47 <yitz> rwbarton: it would be kind of like writing your C program to begin with using islands of asm for the inner loops, manual control of registers, etc., before you have any idea that you really need those things.
07:50:03 <mSSM> If someone has a rough sketch of how I should approach this, I would welcome it.
07:50:13 <hiptobecubic> functions
07:51:15 <radox1> Hello
07:51:35 <radox1> Has anyone used Glade with gtkhs?
07:51:55 <radox1> I am looking to add a radioMenuItem but can't seem to find how to do this within Glade
07:52:47 <rwbarton> yitz, I would disagree that choosing between a mutable and immutable data structure when there is an entire order-n asymptotic complexity difference is analogous to any of those things.
07:53:01 <shachaf> Ising, Ibrowse, Itellfacts, Idownload, Isearch
07:53:06 <shachaf> I am Bonzi Buddy
07:53:10 <rwbarton> iSing
07:53:19 <shachaf> http://upload.wikimedia.org/wikipedia/en/c/c3/Bonzi_buddy.jpg
07:53:33 <mSSM> shachaf: iSing predates Imac
07:54:54 <rwbarton> at least, if you are going to suggest an immutable data structure, make it be something like a Map or a Seq
07:57:44 <mSSM> Is it a wrong assumption, btw, that if I have an immutable data structure, I will end up with lots of copies of that structure?
07:57:51 <elliott> yes
07:58:06 <elliott> fusion optimisations are all about preventing that
07:59:11 <nicoo> mSSM: Depends how you modify it
07:59:25 <Chousuke> mSSM: immutable data structures can also share structure, so even making those copies can be cheap.
07:59:49 <rwbarton> if you don't retain a reference to the old version, it will be garbage collected -- even if there is no fusion going on
07:59:49 <nicoo> But most of the time, most of time, most of the structure is reused.
08:00:17 <copumpkin> mSSM: it's also worth remarking that allocations in GHC are almost free
08:00:20 <shachaf> rwbarton: That depends on whether you treat "copies" as a verb or a noun. :-)
08:00:26 <rwbarton> right
08:00:27 <copumpkin> much closer to alloca than malloc, if that means anything to you
08:00:44 <shachaf> Allocations are almost free, but GC isn't. :-(
08:00:44 <basdirks_> @unpl ((get >>=) . (put .))
08:00:45 <lambdabot> (\ e -> get >>= \ h -> put (e h))
08:00:49 <rwbarton> you may end up with many copies at different times, but only a few copies at any particular time
08:00:56 <basdirks_> @pl (\ e -> get >>= \ h -> put (e h))
08:00:56 <lambdabot> (get >>=) . (put .)
08:01:00 <rwbarton> and the copies may not be full copies, for the reason Chousuke mentioned
08:01:07 <basdirks_> bleh
08:01:11 <yitz> GC is wicked wicked fast in GHC compared to most runtimes you've used in other languages
08:01:38 <rwbarton> @@ @hoogle @type ((get >>=) . (put .))
08:01:39 <lambdabot>  Control.Monad.State.Class modify :: MonadState s m => (s -> s) -> m ()
08:01:39 <lambdabot> Control.Monad.State.Lazy modify :: MonadState s m => (s -> s) -> m ()
08:01:39 <lambdabot> Control.Monad.State.Strict modify :: MonadState s m => (s -> s) -> m ()
08:02:10 <yitz> rwbarton: heh
08:02:25 <rwbarton> it's like @pl but it might be a total lie :)
08:02:33 <rwbarton> but this time it's not!
08:02:41 <shachaf> Sometimes @pl is a total lie.
08:02:44 <basdirks_> oh wow, I should use the tools that are available. =[
08:02:45 <basdirks_> thx
08:03:03 <shachaf> @hoogle Int -> ([String],Double)
08:03:03 <lambdabot> No results found
08:03:05 <yitz> order-n asymptotic complexity difference arise from algorithm choices, not from whether you choose immutable or mutable data structures.
08:03:09 <shachaf> What happened to always giving you unsafeCoerce?
08:03:12 <yitz> rwbarton: ^
08:03:42 <rwbarton> ? surely the choice of data structure is part of the algorithm choice
08:04:14 <basdirks_> @unpl ((snd .) .)
08:04:14 <lambdabot> (\ b e h -> snd (b e h))
08:04:24 <yitz> rwbarton: it's true that direct memory access sometimes hides a log N factor by using hardware parallelization, but that's rarely significant
08:04:59 <yitz> rwbarton: you can choose the mutable or immutable version of a data structure with the same basic semantics
08:04:59 <basdirks_> @pl (\ b e h -> snd (b e h))
08:04:59 <lambdabot> ((snd .) .)
08:05:22 <rwbarton> I am talking about the order N difference between updating one element of a mutable array and copying an entire immutable array to change one element.
08:05:28 <basdirks_> @@ @hoogle @type ((snd .) .)
08:05:29 <lambdabot>  Data.Data dataCast2 :: (Data a, Typeable2 t) => (forall d e. (Data d, Data e) => c (t d e)) -> Maybe (c a)
08:05:30 <lambdabot> Data.Graph.Inductive.Monad isEmptyM :: GraphM m gr => m (gr a b) -> m Bool
08:05:30 <lambdabot> Data.Graph.Inductive.Monad noNodesM :: GraphM m gr => m (gr a b) -> m Int
08:05:42 <basdirks_> hehe
08:06:04 <yitz> rwbarton: those are two different algorithms. it's not a fair comparison.
08:06:14 <rwbarton> yes, and you should CHOOSE THE RIGHT ALGORITHM
08:06:29 <yitz> rwbarton: yes. use Data.Sequence, for instance.
08:06:45 <rwbarton> okay but earlier people were saying "use immutable vectors and fusion will magically fix everything"
08:06:48 <rwbarton> which is totally false
08:07:03 <rwbarton> for a general problem that can be solved efficiently with mutable arrays
08:07:09 <rwbarton> for specific problems, yes
08:07:19 <Chousuke> if the basic operations of your two alternative data structures have the same algorithmic complexity then they might be equivalent as far as your algorithm using them is concerned.
08:07:42 <rwbarton> whatever you want to call it, algorithm or data structure, making a choice up front of whether to use a mutable vector or immutable vector is not something to consider lightly
08:08:05 <Chousuke> but if eg. insert is O(n) instead of O(1), that is obviously going to affect your algorithm
08:08:15 <rwbarton> and performance is not so unpredictable that it is unusual to know that an extra factor of n is going to be too much
08:08:38 <yitz> rwbarton: fusion is a very specific tool that can be applied in certain ways. it requires some advanced knowledge. i really don't think talking about either fusion or mutable data structures was helpful at all to mSSM.
08:08:49 <rwbarton> wtf man
08:08:51 <nicoo> rwbarton: Depending of the order of magnitude of n, asymptotic might be very usefull
08:08:54 <rwbarton> this is hopeless
08:09:25 <nicoo> yitz: Eh, no; fusion happens implicitely *all the time* :o
08:09:27 <yitz> just learn haskell first
08:10:07 <yitz> nicoo: true. so does breathing. it's usually not too productive to spend time studying it.
08:10:36 <smarechal> actually if you want to do any kind of sports it is quite productive
08:10:42 <smarechal> but that's off topic
08:10:44 <yitz> smarechal: ok there you go
08:10:48 <smarechal> ;)
08:11:42 <mSSM> yitz: I didn't really read through all that stuff.
08:11:52 <yitz> mSSM: i know :)
08:12:37 <radox1> I have multiple radiobuttons in a menubar
08:12:42 <yitz> mSSM: that stuff is fun, and it is certainly useful when you need it. but just not appropriate in your case, in my opinion.
08:12:47 <radox1> But currently they are all selectable
08:12:56 <Philippa_> mSSM: so the #1 thing to know is that when you evaluate a constructor it doesn't have to copy its parms
08:13:55 <nicoo> yitz: He didn't want to precisely study fusion; he wanted to know whether immutability costes lots of memory
08:13:59 <nicoo> costs*
08:14:14 <mSSM> yitz: It started off completely different :D
08:14:17 <mSSM> nicoo: *
08:14:20 <mSSM> ^
08:14:31 <yitz> ok. :)
08:14:36 * Philippa_ points out that the person to first mention fusion did a hit and run
08:14:53 <nicoo> mSSM: Ok; arrived mid-discussion
08:14:57 <mSSM> yitz: I am going to try to model my problem using basic lists now; I am not very sure if that makes sense.
08:15:03 <mSSM> But I guess it's easier.
08:15:10 <Philippa_> mSSM: it makes /some/ sense, the question is whether you might have to remodel later
08:15:17 <Philippa_> it helps to use more rather than fewer functions
08:15:39 <Philippa_> that way you can probably find a core that maps more readily to other data structures
08:15:59 <Philippa_> (I use association lists as maps all the time because I'm lazy: I try to remember to wrap cons calls though!)
08:16:08 <nicoo> mSSM: User-defined datatypes have the advantage of readability and matching (almost) exactly your model
08:16:33 <radox1> It seems I need to put the radiobuttons into a group
08:16:41 <radox1> Does anyone have know how to do this
08:16:47 <nicoo> Depending on the complexity of what you are doing, using directly lists might be a bad idea.
08:16:52 <Philippa_> nicoo: that depends a lot on what the lists're being used to model. Sometimes, you've got a lot of sequential structures
08:17:11 <dmwit> radox1: gtk? wx? qt?
08:17:15 <Philippa_> if n is small(ish), you also probably don't need to care about complexity all that much. When I say small, 1000 is a /tiny/ number these days
08:17:18 <radox1> gtk
08:17:24 <shachaf> > 2^1000
08:17:26 <lambdabot>   107150860718626732094842504906000181056140481170553360744375038837035105112...
08:17:45 <Philippa_> shachaf: why not feed it to Ackermann while you're at it? :p
08:17:47 <nicoo> Philippa_: I wasm't talking about algorithmic complexity anymore
08:17:52 <radox1> Currently have 3 gtkradiomenuitrms
08:18:05 <mSSM> Philippa_: with Haskell, I feel like I need to get myself a private tutor who babysits me
08:18:05 <dmwit> radox1: http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-Buttons-RadioButton.html#v:radioButtonSetGroup
08:18:13 <nicoo> (and anyways, I usually use a mix of user-defined and lists)
08:18:46 <dmwit> radox1: or use the radioButtonGroup attribute, probably more forward-compatible
08:19:03 <radox1> dmwit: do you know if this can be done in glade/xml?
08:19:15 <Philippa_> mSSM: it'd probably help people trying to advise you if we knew a little more about the problem you want to model, btw. As nicoo is suggesting, you need more explicit structure when you model bigger problems to help keep everything tractable
08:19:18 <josephle> nicoo: technically, if he just uses enough typeclasses he'll have something general enough to make data structure swapping mostly painless :P
08:19:47 <Philippa_> josephle: you don't /actually/ need typeclasses to do that. I harvest classes from existing structures all the time :-)
08:20:09 <josephle> true, true
08:20:37 <nicoo> Bool * Bool
08:20:43 <dmwit> radox1: I don't know anything about glade.
08:21:01 <dmwit> (But I would be surprised if it wasn't possible.)
08:21:01 <radox1> That makes two of us :)
08:22:03 <josephle> nicoo: get that ML notation out of here. This is default non-strict evaluation territory :P
08:22:30 <shachaf> Type classes are the devil.
08:22:55 <Philippa_> shachaf: lack of a proper module system is the devil. Type classes are just so close it's frustrating :p
08:23:38 <nicoo> josephle: Troll so successful :]
08:28:30 <mSSM> Philippa_: Ok, basically, what I want is this: I have quadratic 2D structure of fixed size (n*n) that I project onto a 1D [Int] ; each point in that lattice has a value, initialized with a random +1 or -1 ; the initial "energy" = sum (product of next_neighbours of each point), during each step of the simulation, there is a random chance that in this list, each +1/-1 gets flipped to -1/+1, respectively,
08:28:32 <mSSM> depending on if e_init gets lowered depending on some delta_energy calculated after each flip. I want to sample the energy of the entire system after each step.
08:29:38 <Philippa_> mSSM: lists aren't ideal, but also aren't disastrous for that because you're mostly traversing fairly linearly
08:29:58 <Philippa_> what kind of order of magnitude will n be reaching?
08:30:14 <Philippa_> (similarly, how many iterations and how fast do you really care about it running?)
08:30:38 <mSSM> Philippa_: starting from 2^3, preferrably as big as possible; 2^10 would be nice
08:30:53 <mSSM> Philippa_: iterations: 10^4
08:31:12 <mSSM> Philippa_: and each set of iterations, about 10^3 times
08:31:43 <mSSM> Philippa_: time: fast enough to not send it to a Supercomputer :)
08:31:45 <Philippa_> *nod* That's big enough I'd be tempted to use immutable arrays
08:32:06 <Philippa_> so a few minutes is okay so long as you can see progress, a few hours is damn annoying, days is right out? :-)
08:32:15 <mSSM> Indeed
08:32:41 <mSSM> Philippa_: I wouldn't mind to model this with lists.
08:32:48 <mSSM> Guess that would help me leanr Haskell
08:32:52 <Philippa_> mmm. Try that first and see how fast it's running
08:33:01 <Philippa_> after all, you don't have to do the entire run at once
08:33:30 <mSSM> I currently have issues seeing where I need to use Monads, and where a stateful computation comes in
08:33:35 <Philippa_> (and you're not going to make your total allocated-and-not-GCable data go boom)
08:34:06 <Philippa_> so you could use one for this, but I'd be inclined not to because you're going to be actively working on the 'state' the whole time in ways that fit existing iteration patterns
08:34:43 <radox1> dmwit: Thank you got it working now in Glade :)
08:35:04 <Philippa_> monadic state's most useful when you can either conveniently tweak small bits of it at a time (nested records, say) or you're spending significant time doing things that need to propagate state but don't actually manipulate it
08:35:15 <dmwit> radox1: I'm glad to hear it. =)
08:36:15 <krey_> o/, this is slightly off-topic, but can someone tell me the name of that online scratchpad thing that people use communicate diagrams (and text) to eachother online?
08:36:28 <yitz> i might have modeled this as a kind of 2D zipper. you can get to the neigbors in one step, modify individual cells sparsely in constant time, and easily iterate over the whole thing to sample the energy.
08:37:18 <yitz> takes several times the memory, but it doesn't sound like that will be a problem, though it will start to blow you out of the cache.
08:37:45 <Joe____> When creating an instance of Read for a custom datatype. Is it possible to allow the instance declaration to allow additional parameters to the read. Such as [read ("3%1" :: GenericNumber) param_p ] WHERE param_p specifies the mode GenericNumber is currently in?
08:38:03 <mSSM> yitz: I can circumvent iterating over the whole energy by only calculating the local change in energy
08:38:24 <mSSM> yitz: (since the change in energy odes not involve the entire grid, but only a subpart)
08:38:33 <yitz> Joe____: no. you would use separate functions for that, not the standard Read class.
08:38:53 <dmwit> yitz: I thought 2d zippers were sort of an open research problem
08:38:58 <yitz> mSSM: that's helpful
08:39:19 <osfameron> thinking about 2d zippers makes my brain hurt
08:40:01 <dmwit> I have a post lying around about a particular 2d zipper for square matrices, but it doesn't get you horizontal and vertical neighbors, it gets you diagonal neighbors.
08:40:21 <dmwit> I should really finish it up and post to reddit.
08:40:40 <yitz> osfameron: i don't mean anything fancy. each node has data plus four pointers.
08:40:59 <Joe____> Currently: data GenericNumber =     Integer Integer   | Rational Rational   | Double Double             To implement a Read for GenericNumber, I should create a separate read for each Integer, Rational and Double and call it depending which number mode I am currently working with?
08:41:03 <dmwit> Oh, we're returning to a mutable data type?
08:41:20 <yitz> dmwit: maybe you are, i'm not
08:41:53 <dmwit> yitz: In the data structure you suggested, there are multiple paths to some nodes, and you must update them all. You lose the efficiency benefits that zippers are supposed to give you.
08:41:53 <latermuse> how do i uninstall a hackage package that I installed from source?
08:41:59 <dmwit> latermuse: sorry mate
08:42:12 <dmwit> Joe____: reads is allowed to return more than one result in case a parse is ambiguous
08:42:15 <latermuse> sorry?
08:42:28 * dmwit nods sadly at latermuse
08:42:38 <applicative> latermuse: you can 'unregister' it with ghc-pkg unregister pony
08:42:46 <latermuse> applicative: thats good enough for me!
08:43:21 <latermuse> applicative: is 'pony' the name of the package?
08:43:27 <applicative> latermuse: then you can delete the library by going into .cabal/lib/ghc-blah.... and the like.  I don't recommend it really
08:43:48 <applicative> yes pony was the package
08:43:51 <dmwit> latermuse: Perhaps we should ask why you want to uninstall it. Generally speaking that's not necessary or desirable.
08:44:32 <applicative> latermuse I think its a drag trying to 'uninstall' as dmwit says, but unregistering I do all the time
08:44:49 <latermuse> i am trying to install darcs
08:44:53 <latermuse> and i just got this message: Setup: At least the following dependencies are missing:
08:44:56 <latermuse> regex-compat >=0.71 && <0.94
08:45:09 <latermuse> i installed regex-compat 0.95
08:45:23 <latermuse> so i need to unregister it and install 93
08:45:40 <josephle> it's always dependency hell, isn't it?
08:45:43 <yitz> dmwit: hmm
08:46:11 <isturdy> You should be able to have two versions of regex-compat, so long as you do not need to link against both in one project. (And I doubt you are linking against Darcs?).
08:46:16 <latermuse> now I understand what all that hum-haw about cabal was the past few weeks
08:47:11 <applicative> latermuse: are you building an older version of darcs?
08:47:25 <tomeo_> If I let type AlignmentType = (String, String) because I want a return type of [AlignmentType] for a function... Why wouldn't I just put the return type as [(String,String)]? Is there any other reason apart from perhaps readability?
08:47:40 <shachaf> Nope.
08:48:08 <latermuse> applicative: yes. im bootstrapping GHC from version 6.12 to 7.4
08:48:09 <dmwit> latermuse: You don't need to uninstall regex-compat 0.95 to install regex-compat 0.93.
08:48:42 <latermuse> my gcc wont compiled version 7.4. so i used it to compile 6.12, then im going to use 6.12 to compile 7.4
08:48:53 <dmwit> Also, I find your claim about understanding the cabal hum-haw a bit suspect, given this misunderstanding.
08:48:59 <applicative> what platform are you on?
08:49:13 <latermuse> dmwit: yes Im new, so I dont know much about the behind the scenes stuff
08:49:44 <dmwit> latermuse: Instead of building and using Setup.[l]hs, just type "cabal install".
08:49:48 <latermuse> applicative: i develop on a macbook air, which runs haskell platform beautifully. but my development server is running centos
08:49:51 <isturdy> Why do you need Darcs to upgrade GHC?
08:49:52 <dmwit> I bet you'll be pleasantly surprised.
08:50:01 <applicative> centos hm
08:50:13 <latermuse> http://klevstul.posterous.com/haskell-ghc-702-on-centos-55
08:50:15 <latermuse> im following these directions
08:50:19 <yitz> unfortunately the cabal hum-haw has been going on for a lot longer than a few weeks.
08:51:33 * hackagebot bash 0.1.6 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.6 (JasonDusek)
08:52:13 <isturdy> Why are you not using the HP on the server?
08:52:29 <dmwit> latermuse: Modern cabal-install is easier to use than Setup.hs. Just "cabal install" instead of "runhaskell Setup configure && runhaskell Setup build && runhaskell Setup install".
08:52:55 <dmwit> latermuse: Additionally, since cabal-install does dependency management for you, you can skip straight to the packages you want instead of doing that for each of its dependencies first.
08:53:07 <latermuse> dmwit: I havent installed cabal on this server yet
08:53:12 <dmwit> latermuse: So just "cabal install darcs", for example, instead of this long-winded instructions.
08:53:24 <dmwit> latermuse: Okay, so install cabal. Unpack the tar and run bootstrap.sh.
08:53:30 <dmwit> It really couldn't be much easier.
08:53:32 <latermuse> ok
08:53:36 <applicative> latermuse: this thread seems a bit more recent http://www.haskell.org/pipermail/haskell-cafe/2012-June/102023.html
08:54:00 <latermuse> well im almost finished installing this server. ill use the cabal method for my next servers
08:54:19 <latermuse> bootstrapping is a learning experience, but im glad i dont have to do it again
08:56:13 <latermuse> installing on centos isnt very easy. is there a reason nobody maintains a package for specifically for centos?
08:56:19 <killy9999> is it possible to applky INLINE pragam to more than one function at once?
08:56:35 <killy9999> {-# INLINE f, g #-} or something like that?
08:56:46 <killy9999> I mean this is not possible - I realized that
08:56:56 <killy9999> the question is is there any other notation that does that?
09:01:00 <parcs`> nope
09:04:43 <killy9999> :9
09:04:45 <killy9999> :(
09:04:52 <Joe____> How would a polymorphic type be declared in Haskell?
09:05:08 <Joe____> For example, (Following on from above).. a GenericNumber type
09:05:30 <Clint> what are you trying to do?
09:05:31 <notdan> data GenericNumber = forall a. Num a => N a
09:05:36 <notdan> something like that probably
09:05:41 <Joe____> which can subsumes Integer, Double and Rational
09:06:02 <notdan> Joe____: but yeah, what are you trying to do exactly?
09:06:14 <notdan> if you are writing a function I'd recommend using Num constraint
09:06:16 <shachaf> notdan: Probably not something like that.
09:06:33 * hackagebot hsndfile 0.5.3 - Haskell bindings for libsndfile  http://hackage.haskell.org/package/hsndfile-0.5.3 (StefanKersten)
09:06:37 <andsens> my god. I wrote a traverser for a tree containing six different data types, each requiring a different action on 17 lines. Zippers are awesome!
09:06:52 <Joe____> Creating a Graphical Calculator, which can switch to Rational Number, Double or Integer Mode.
09:07:00 <andsens> I was wondering if somebody would like to take a look and offer suggestions for improvement?
09:07:08 <Joe____> With this, I would like to be able to pass these numbers around the program as efficiently as possible
09:07:08 <shachaf> andsens: Not if you don't paste your code.
09:07:20 <Joe____> without having to recreate functions for Rationals..et.al
09:07:22 <andsens> hehe, I was about to :-)
09:07:36 <shachaf> andsens: If you wait for people to say "I'll help", and then they can't help, they'll feel bad. No one wants to feel bad.
09:08:12 <andsens> shachaf: Right, I'll remember that
09:08:46 <Joe____> So, can (Read "3%2" :: RationalType) - RationalType being subsumed within a generic Type.. so that this rationalType can then be passed around the program
09:09:17 <notdan> shachaf: why not?
09:09:59 <Crockeo> No one wants to feel bad and they should feel bad... or something.
09:10:13 <hpaste> andsens pasted ‚ÄúTreeTraversal‚Äù at http://hpaste.org/78412
09:10:24 <mSSM> If i have `do rand <- (uniform gen :: IO Int)' (uniform from System.Random.MWC), what type is rand? It should be of type Int, right?
09:10:48 <notdan> Joe____: well, you can have function calc with the following signature : calc :: (Num a, Num b) => a -> .. -> b
09:10:52 <notdan> :t (+)
09:10:53 <lambdabot> Num a => a -> a -> a
09:10:58 <andsens> I haven't had a chance to run the traverser yet, I hope there arent any errors. Problem is that I wrote it top down‚Ä¶.
09:11:14 <shachaf> notdan: Because exists a. Num a *> a is pretty useless.
09:12:18 <notdan> shachaf: I am sorry, I don't understand your notation. What does *> mean?
09:12:27 <andsens> huh, somehow the syntax highlighting is missing in my paste
09:12:37 <Joe____> notdan: Thanks, would my new generic number type be of type num?
09:12:54 <notdan> Also my def does work as a general container for "numbers"
09:13:00 <shachaf> notdan: data SomeNum = forall a. Num a => SomeNum a is pretty useless
09:13:09 <notdan> Joe____: Num is a typeclass: http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Num
09:13:23 <shachaf> notdan: Your definition is of very little use to anyone wanting to do something with it.
09:13:28 <notdan> shachaf: well, I am not saying it's usefull
09:13:31 <shachaf> What can you do with a SomeNum?
09:14:03 <ParahSail1n> i have a long, lazy list of Ints, and i'd like to find the highest n items
09:14:18 <notdan> Nothing much besides the usual Num operations; but that's not the point. It is useless and that's why I asked Joe____ what exactly does he want to do
09:14:48 <shachaf> ParahSail1n: If you're lucky you might be able to take n . sortBy (flip compare)
09:14:52 <yitz> ParahSail1n: to find maxima you need to look at all of the data, so it won't be lazt
09:14:56 <yitz> *lazy
09:14:57 <shachaf> But I'm not sure you'll actually be lucky.
09:15:16 <shachaf> yitz: Sure, but I assume ParahSail1n wants to consume the list while accumulating a set of the N biggest numbers seen.
09:15:51 <ParahSail1n> shachaf: yes
09:16:01 <andsens> has anybody had a chance to look at my paste?
09:16:02 <yitz> ParahSail1n: do you need to do anything with these other than just finding the highest n items?
09:16:10 <ParahSail1n> only need highest n
09:16:34 * hackagebot hako 1.0.0 - A mako-like quasi-quoter template library  http://hackage.haskell.org/package/hako-1.0.0 (TobiasDammers)
09:16:36 * hackagebot fb 0.13.2 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13.2 (FelipeLessa)
09:16:39 <fmap> notdan: I guess you can't even add 2 SomeNums?
09:16:56 <shachaf> andsens: Does that file type check as is?
09:17:02 <fmap> so only abs, negate and signum
09:17:27 <andsens> shachaf: I am mocking some stuff right now to be sure
09:17:38 <shachaf> OK, so that's pseudocode.
09:17:51 <shachaf> Yes, now I see.
09:17:54 <applicative> mSSM: yes it's an Int variable
09:18:08 <andsens> yeah, you know what. Hold off on it, I will post a type checked version in a sec
09:18:38 <shachaf> length subtree == 0 :-(
09:18:51 <hbegott> intmax = 2^16 = 65536, what happens if i add to that? id like to wraparound, is there some way to know if there is an overflow?
09:18:51 <mSSM> applicative: why does the following do block then not work? `do { rand <- (uniform gen :: IO Int); return rand }' ?
09:18:59 <shachaf> andsens: You really ought to avoid length, head, tail, and all those.
09:19:26 <yitz> ParahSail1n: shachaf's solution is the easiest. optimal would probably be something like pushing them one by one into a priority queue of size n, discarding the currents smallest one each time.
09:19:42 <andsens> shachaf: Agreed, but how can avoid that. I couldn't figure it out
09:19:50 <hbegott> what is INTMAX is hanskelL?
09:20:08 <yitz> > maxBound :: Int
09:20:10 <lambdabot>   9223372036854775807
09:20:23 <ParahSail1n> yeah, priority queue is what i'm using, just checking if that's the best
09:20:24 <mSSM> applicative: it says: Expected type: IO Int -> (Int -> IO Int) -> Int ; Actual type: IO Int -> (Int -> IO Int) -> IO Int
09:20:26 <shachaf> andsens: case field x of [] -> ...; x:xs -> ...
09:20:38 <andsens> ah, of course
09:20:42 <shachaf> Well, probably with a different name than x
09:20:42 <yitz> hbegott: depends on the platform you are running on. Integer has no upper bound.
09:20:57 <shachaf> andsens: But also length is especially bad.
09:21:02 <shachaf> Use null or something instead.
09:21:03 <yitz> > 2^63
09:21:04 <lambdabot>   9223372036854775808
09:21:10 <elliott> null is bad too!
09:21:31 <shachaf> elliott: Yes, but it's better than length l == 0
09:21:41 <andsens> I was actually trying to avoid "nil" if that is what you meant
09:21:49 <shachaf> What's "nil"?
09:22:34 <andsens> I think I might be confusing stuff right now. I though nil was null in haskell
09:22:43 <shachaf> @ty null
09:22:44 <lambdabot> [a] -> Bool
09:22:55 <shachaf> null [] = True; null (_:_) = False
09:23:01 <shachaf> But don't use it!
09:23:04 <shachaf> Use pattern matching.
09:23:20 <andsens> on it :-)
09:23:39 <applicative> mSSM: where are you getting 'gen' from?  It should be something like :  do {gen <- create ; rand <- (uniform gen :: IO Int); return rand }
09:23:58 <shachaf> andsens: (Also, please write type signatures.)
09:24:19 <mSSM> applicative: My fualt; I gave it the type GenIO -> Int instead of GenIO -> IO Int  ... :(
09:24:21 <mSSM> applicative: sorry and thanks
09:24:45 <andsens> I was waiting with that until it works, then just use ghc-mod
09:25:11 <andsens> I can highlight a function and press cmd+shift+i and the type is inserted above :-)
09:25:36 <shachaf> andsens: The types are for poor saps like us who are trying to read your code.
09:25:43 <shachaf> @quote rwbarton inference
09:25:44 <lambdabot> rwbarton says: type inference is supposed to be the compiler's job, not the reader's job
09:26:20 <andsens> shachaf, sorry. I think I should have double checked everything before pasting it
09:26:36 <andsens> Why can't I do this: (Crumb [] x xs, [])
09:26:41 <radox1> dmwit: Any idea how what function gets called when a menu radio item is sellected? I have checked the docs here http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-MenuComboToolbar-RadioMenuItem.html#t:RadioMenuItem
09:26:45 <radox1> but it doesnt seem to say
09:26:47 <andsens> I though  ,  was least binding?
09:27:21 <shachaf> I don't know what "do this" means.
09:27:26 <shachaf> Or "can't", for that matter.
09:27:46 <andsens> Create a tuple and not have parens around the first Constructor
09:27:58 <shachaf> Just syntactially, "resolve x:xs = siblings ( ([], []) (Crumb [] x xs, []) )" is missing a couple of parentheses and a comma.
09:28:16 <rwbarton> is there a way to see how much heap my program is currently using?
09:28:21 <rwbarton> from within the program
09:28:47 <shachaf> Wait, maybe it has extra parentheses.
09:28:53 <shachaf> I have no idea what you're trying to do. :-)
09:29:39 <andsens> Ah yes, this actually annoys me a great deal. Why are parens necessary when pattern matching a list, while the function has no other parameters?
09:30:08 <shachaf> andsens: Because "a b:c" is "(a b):(c)"
09:30:16 <shachaf> In declarations and expressions alike.
09:30:38 <andsens> Oh! That makes sense
09:31:13 <andsens> Some operator precedence would be nifty sometimes
09:31:29 <shachaf> Haskell has operator precedence.
09:32:01 <radox1> Does anyone know what methods RadioMenuItem has?
09:36:07 <andsens> shachaf: ok, wasn't sure about it. In that caseI am annoyed by : being of low precedence, hehe
09:37:26 <shachaf> andsens: Haskell has a simple rule where function application binds tighter than (almost) anything else.
09:37:30 <shachaf> It's a great rule.
09:38:18 <andsens> Naaah, it sucks‚Ä¶ stupid. :-D
09:38:34 <andsens> no, hehe. I'm sure there are good reasons
09:38:52 <rwbarton> "operator precedence is supposed to be the compiler's job, not the reader's job"
09:39:39 <quchen> shachaf: Why "almost"? Is there anything but SP that has fixity 10?
09:39:49 <quchen> but -> besides
09:39:59 <mSSM> Is there a function `IO Int -> IO [Int] -> IO [Int]', essentially a cons acting on the value in IO? I can't seem to get it right.
09:40:14 <glguy> :t liftM2 (:)
09:40:15 <lambdabot> Monad m => m a1 -> m [a1] -> m [a1]
09:41:24 <glguy> ?src liftM2
09:41:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:41:36 <glguy> mSSM: That's for you :)
09:41:40 <mSSM> glguy: yes, thanks
09:41:45 <mSSM> glguy: that's great
09:42:02 <S11001001> mSSM: liftA2 is also available for other situations
09:42:59 <S11001001> in haskell''''' liftM2 will be eliminated in favor of liftA2
09:44:11 <Crockeo> Whilst procrastinating I've realized something: Why I find Haskell so hard is only in part due to my background with imperative programming; it also has to do with how much harder it is in Haskell to make bad code.
09:44:11 <Crockeo> Rather
09:44:20 <Crockeo> how much easier it is to recognize bad code, even for a beginner.
09:44:45 <glguy> Don't worry, Crockeo. You'll find it perfectly easy to write bad code in Haskell, too :)
09:45:28 <hpaste> andsens annotated ‚ÄúTreeTraversal‚Äù with ‚ÄúTreeTraversal (annotation)‚Äù at http://hpaste.org/78412#a78418
09:45:32 <Crockeo> glguy: Well, barring the use of do in every function.
09:45:47 <andsens> there we go, care to take another look shachaf?
09:45:59 <Crockeo> glguy: I suppose all you have to do in Haskell to make bad code is to /use/ do all the time.
09:46:03 <mSSM> Well, for one, I do know that my code is bad, and for another, it doesn't work :D
09:46:11 <Ralith> Crockeo: there's nothing wrong with do; it's just syntatic sugar.
09:46:37 <Crockeo> Ralith: But using it in every function goes against Haskell as I know it (AKA as LYAH teaches it)
09:46:54 <andsens> huh? LYAH teaches the do notation
09:46:54 <Ralith> it'd be pretty weird, but not bad
09:47:25 <Ralith> I expect you'd realize pretty quick that mostly you don't do anything differently with it
09:47:43 <Crockeo> Isn't the whole thing about Haskell that order of evaluation shouldn't affect the result?
09:48:18 <Crockeo> And do is syntactic sugar for saying "Fuck that."
09:48:25 <elliott> that isn't what do is at all, no
09:49:01 <Crockeo> elliott: I'd be more than happy to learn, it's definitely more fun than learning about matricies.
09:49:13 <Crockeo> matrices*
09:49:20 <elliott> do is just syntactic sugar for the monad operations
09:49:26 <mSSM> matrices is easier than haskelll....
09:49:27 <elliott> and monads have nothing to do with evaluation order at all, really
09:49:27 <mSSM> are*
09:50:01 <Crockeo> mSSM: But they're not more fun!
09:50:27 <Crockeo> elliott: I was under the impression the 'do' command was syntactic sugar for making statements evaluate one after another.
09:50:53 <Chousuke> do is syntactic sugar for using bind
09:51:04 <Chousuke> and bind can be defined to force a certain evaluation order
09:51:19 <Chousuke> it can be sequential, reversed, or back and forth :P
09:51:42 <ocharles> anyone here going to the London Haskell user group meetup tonight?
09:51:43 <elliott> well, even (>>=) is not really about evaluation order at all
09:51:53 <glguy> It defines evaluation order as much as any other Haskell function does
09:52:15 <Crockeo> Hmmmm, do more math or continue reader LYAH so I don't keep making a fool of myself...
09:52:15 <typoclass> Crockeo: in the most popular monad (IO), that's true
09:52:25 <Crockeo> reading LYAH*
09:53:23 <mSSM> Ok, I am trying to generate a IO [Int], but making a complete fool of myself: can somebody tell me what's wrong here? http://hpaste.org/78420
09:54:03 <Chousuke> mSSM: your function is returning a plain list of ints?
09:54:18 <xunatai> GenIO -> Int -> IO [Int]
09:54:25 <Chousuke> :P
09:54:26 <elliott> well actually IO is not about forcing evaluation order either.
09:54:39 <elliott> it is about composing actions... the resulting actions respect an /execution/ order, but still nothing about evaluation really
09:54:52 <Chousuke> hmm
09:55:01 <glguy> liftM2 (:) (initNode gen) (initIsing gen (n-1))
09:55:02 <mSSM> Chousuke: http://hpaste.org/78421
09:55:09 <mSSM> Chousuke: sorry, this one is more concise
09:55:30 <mSSM> Chousuke: not concise... compelte
09:56:21 <Chousuke> mSSM: I'm pretty sure you need to return IO [Int] from initIsing
09:56:33 <mSSM> xunatai, glguy : oh wow, that was simple
09:56:46 <joeyh> if a library needs c2hs to build, how should that be expressed in its cabal file?
09:56:49 <glguy> More importantly, do you see what it's doing?
09:56:50 <mSSM> Chousuke: yeah, that was one problem
09:57:14 <dcoutts> joeyh: build-tools: c2hs   and optionally >= 0.16.3  or whatever
09:57:17 <mSSM> glguy: probably not
09:57:37 <mSSM> glguy: ah, yes
09:57:42 <mSSM> glguy: now I actually have IO Int
09:57:47 <mSSM> glguy: before I just had Int
09:57:50 <Chousuke> elliott: I guess you should say that IO (or State, really) arranges the dependencies between different actions so that it results in a linear execution order regardless of how Haskell chooses to evaluate it.
09:58:00 <joeyh> so, I'm looking at gnuidn, which has the build-tools, and at a user report of cabal install failing
09:58:03 <elliott> sort of
09:58:04 <mSSM> glguy: which doesnt fwork with liftM2
09:58:15 <elliott> it's more like execution and evaluation order are unrelated things :)
09:58:19 <joeyh> seems cabal did not ensure build-tools was satisfied
09:58:23 <elliott> but it means that evaluation order is irrelevant, sure
09:58:29 <elliott> (well, sort of again...)
09:58:44 <dcoutts> joeyh: currently cabal-install only automatically installs Haskell libraries, not build tools, not C libs, not (etc etc...)
09:59:11 <joeyh> would putting c2hs in build-depends be a useful workaround?
09:59:25 <mSSM> glguy: http://hpaste.org/78422
10:00:14 <dcoutts> joeyh: no, because it's not a library
10:02:36 <Chousuke> Crockeo: https://github.com/DanBurton/tardis take a look at this. Should instantly dispel all ideas that monads are only sequential.
10:02:53 <Crockeo> Chousuke: On it!
10:03:21 <Chousuke> Crockeo: be careful though, the example may overload your brain like it did mine :P
10:03:39 <Crockeo> Chousuke: I'll get my lifealert...
10:04:15 <Chousuke> At this point I can sort of understand what the example does, but not quite how
10:05:17 <temoto> Hello. I have this quickcheck data generator for comment strings: commentStrings = do { s <- Q.arbitrary; return $ "#" ++ s }    How to instruct arbitrary to avoid newline characters?
10:05:51 <Crockeo> Waitwaitwaitwaiwtwaitwaitait
10:05:52 <Crockeo> So
10:05:54 <Crockeo> you're saying
10:06:00 <Crockeo> I can set the value of something
10:06:05 <Crockeo> and everything that I did with it before
10:06:09 <Crockeo> will have been done with that value?
10:06:14 <Crockeo> I-
10:06:15 <Crockeo> mind-
10:06:25 <Crockeo> I'll be over here having my mind explode.
10:06:35 <Chousuke> Crockeo: not quite like that I think. You can explicitly send things to the past and retrieve them
10:07:07 <Crockeo> Yeah but the point is this is time travel.
10:07:11 <Chousuke> so eg. in loop 1 you would fetch stuff sent from the future, then as you recur into loop 2, you send that stuff to the past
10:07:12 <Crockeo> Ergo the name Tardis, I guess.
10:07:41 <Crockeo> I'm gonna call witchcraft
10:07:41 <Crockeo> this guy
10:07:45 <Crockeo> is obviously a wizard.
10:08:05 <zhulikas> wut
10:09:10 <nicoo> Crockeo: There is no such thing as time travel (except in Dr Who); there is fixed-point, though.
10:10:05 <Crockeo> nicoo: I dunno man this guy seems to have discovered time travel. :P
10:10:18 <Chousuke> Crockeo: the way I think it works is that any "future" value you refer to becomes just a thunk, and only when you actually have progressed far enough to the future will that thunk become realisable. Therefore, as long as the future value that will become real at one point does not depend on the past value that depends on the future value (as is the case in this example) there is
10:10:19 <xunatai> you mean: there's no such thing as backwards time travel
10:10:24 <Chousuke> no problem
10:10:25 <niteria> Can it be rewritten to be nicer: do { a <- b; case a of ...} ?
10:11:34 <Crockeo> Okay, so it's just thinking, "There /will/ be a future value, and I /will/ catch it." or..?
10:12:13 <Chousuke> Crockeo: I don't claim to understand how it works, but it's a clever application of monads and laziness that looks like time travel but it actually isn't.
10:12:39 <Chousuke> Crockeo: it would explode if you had actual circular dependencies between past and future values
10:13:07 <Crockeo> Chousuke: From now on whenever anyone asks why lazy evaluation is useful I'm going to link them that
10:13:11 <Crockeo> and watch their mind explode.
10:13:25 <Chousuke> Crockeo: well, it's not exactly the best example of "useful" :P
10:13:39 <Crockeo> Yeah but it's cool, which they'll equate with useful.
10:13:59 <Crockeo> I mean, come on, if you're programming for a hobby cool is what's useful to you.
10:14:00 <Chousuke> many people don't do that. don't scare them too much
10:14:19 <Crockeo> Maybe I should wait until they're a few weeks in?
10:14:28 <Chousuke> maybe
10:14:42 <Chousuke> the main benefit you get from laziness is composability.
10:15:02 <S11001001> case in point: maybe
10:15:32 <smarechal> you don't need haskell to go back in time. I do that all the time with ruby, makes me feel like I'm back on my good old P90
10:18:27 <parcs`> > iterate (sqrt 2 **) 1 !! 1000
10:18:29 <lambdabot>   2.0000000000000004
10:20:38 <Chousuke> Crockeo: to give a simple example, with laziness it's trivial to write a function like sum $ take 3 $ filter (< 5) [5, 1, 8, 3, 11, 13, 77, 4, 3]
10:20:42 <mSSM> How do I create a Generator from withSystemRandom from mwc-random? http://hackage.haskell.org/packages/archive/mwc-random/0.12.0.1/doc/html/System-Random-MWC.html#v:withSystemRandom
10:21:00 <mSSM> It doesn't create a generator at all, does it?
10:21:19 <niteria> any small package with a nice .cabal file?
10:21:41 <Crockeo> Chousuke: How would it be different in a non-lazy language? I'd probably just use a lot more parens.
10:21:56 <niteria> parsec is not nice, haskell-src-exts is too big
10:21:58 <dmwit> niteria: The acme hello-world package, whatever it's called.
10:22:03 <Chousuke> Crockeo: in that case, filter only needs to produce so many elements as take  wants
10:22:07 <merijn> niteria: You mean as an example to start writing your own .cabal file?
10:22:13 <Chousuke> crockeo: so it doesn't have to go through the entire list
10:22:23 <dmwit> niteria: If you're just looking for an example to copy for your own project, you might like "cabal init".
10:22:32 <Crockeo> Chousuke: Oh, okay. You meant efficiency, not simplicity;
10:22:45 <Crockeo> I thought you meant it would be easier to write that function in a lazy programming language.
10:22:46 <Chousuke> crockeo: and if you have more operations in the middle, eg, map (+1) or something, you would have to go over the lists multiple times
10:23:09 <Crockeo> Chousuke: While in a lazy programming language you get a fantastic performance boost.
10:23:16 <Chousuke> Crockeo: in the simple example it may not be apparent but it actually is simpler too.
10:23:31 <Chousuke> I can't quite think of a good example off the top of my head though.
10:23:46 <niteria> dmwit: cabal init is what I was looking for
10:25:22 <dmwit> ?tell radox1 http://hackage.haskell.org/packages/archive/gtk/0.12.3.1/doc/html/Graphics-UI-Gtk-Buttons-ToggleButton.html#v:toggled
10:25:22 <lambdabot> Consider it noted.
10:25:57 <Chousuke> Crockeo: say you want to search for a value in a tree
10:26:25 <Crockeo> You don't have to evaluate the whole tree, just up to where you want?
10:26:26 <Chousuke> Crockeo: in haskell you might write a function that walks through every node in the tree and applies a function to it.
10:26:57 <Chousuke> Crockeo: then you would call that function with some parameter isThisTheOneIWant
10:27:22 <Chousuke> Crockeo: so you'd get out a list of falses and trues and then you just drop falses until you get the first true
10:27:27 <Chousuke> and now you know your item is in the tree
10:27:39 <lpsmith> ok, I'm trying to read from /dev/urandom,  and I do it infrequently enough that I just open the file descriptor every time I want some more random bits.
10:27:48 <bzm3r> Does anyone here use haskell-mode for emacs?
10:27:57 <johnw> i do
10:27:57 <lambdabot> johnw: You have 1 new message. '/msg lambdabot @messages' to read it.
10:28:12 <lpsmith> The problem is that strace shows that I'm reading 8096 bytes at a time instead of just the 16 bytes at a time,  which means I'm wasting a bunch of entropy
10:28:28 <ryanos> bzm3: yes, the prelude version (on mac osx)
10:28:37 <niteria> can't cabal deduce build-depends automagically?
10:28:43 <Chousuke> Crockeo: in a strict language, the tree-walker would continue walking even if it had already found the first thing that matches your predicate. Hopefully you can see how it affects composability.
10:28:43 <lpsmith> And I'm even trying to use IO.hSetBuffering to NoBuffering
10:28:55 <dmwit> Crockeo, Chousuke: http://stackoverflow.com/a/7868790/791604
10:30:12 <Crockeo> dmwit: Thank you!
10:30:41 <bzm3r> johnw, ryanos I just learned the basics of emacs, and I have haskell-mode installed. I read through the included documentation, so I have an idea of the basics (how to start an interpreter, navigating, setting up indentation, etc.). I am wondering though, is there anything else I really need to know about setting haskell-mode up? Any good introductory setup guides on the internet? Or is the documentation basically it?
10:31:01 <johnw> bzm3r: my setup is here: github.com/jwiegley/haskell-config
10:31:24 <bzm3r> johnw: okay, thanks -- I'll have a look at it :)
10:32:16 <Chousuke> dmwit: that was pretty interesting.
10:33:05 <lpsmith> http://hpaste.org/78424
10:33:06 <foeniks> hi
10:33:29 <andsens> I got a problem with "ghc-mod type". It returns "Dummy:0:0:Error:SafeList". Anybody know what that meanse?
10:33:33 <andsens> *means
10:33:41 <foeniks> I found this code http://poorlytyped.blogspot.com/2010/01/haskell-ray-tracing-parallel.html
10:33:45 <Chousuke> re guis, it seems there are lots of libraries for writing UIs in haskell but I have no idea which ones are the most "haskell-y"
10:33:52 <foeniks> and wonder there the Vector3 class is defined
10:34:05 <foeniks> there seem to have been a library change
10:34:09 <lpsmith> so, does anybody have an idea about how to avoid the buffered read without dropping down to C?   (which I suppose really wouldn't be too bad here.)
10:34:29 <Ankhers> Could there be any issues with me downloading and installing GHC 7.6.1 instead of 7.4.2 that currently comes with the haskell-platform?
10:34:47 <Chousuke> I've been trying to figure out FRP lately and it might help if I could just write some simple interactive program using FRP and some UI library but I have no idea what would be a good combination of libraries to start with :P
10:34:50 <johnw> Ankhers: yes, I wouldn't recommend doing that
10:34:55 <xunatai> foeniks: hSetBuffering <handle> NoBuffering
10:35:01 <glguy> Ankhers: The issue would be that some libraries wouldn't support 7.6.1 yet
10:35:02 <lpsmith> ankhers:  I install every ghc in /usr/local/hs/ghc-7.4.2  for example
10:35:04 <xunatai> er
10:35:08 <xunatai> wrong ping
10:35:11 <lpsmith> then I have a little bash command that'll fix my path for me
10:35:18 <xunatai> lpsmith: foeniks: hSetBuffering <handle> NoBuffering
10:35:21 <xunatai> gah
10:35:28 <lpsmith> xunatai, already doing that :)
10:35:39 <xunatai> so..
10:35:59 <xunatai> then, what's the problem exactly
10:36:21 <lpsmith> xunatai, the problem is that I'm reading in 8096 bytes,  not 16
10:36:36 <lpsmith> and thus depleting far more entropy than I should be
10:36:45 <xunatai> hm
10:36:58 <Ankhers> Alright... thanks...
10:37:08 <glguy> lpsmith: Write the part you don't use back to the device :-p (No, I'm not contributing useful information.)
10:39:27 <lpsmith> glguy, =)
10:40:34 <xunatai> BlockBuffering $ Just 16 .... maybe
10:41:25 <hpaste> mmcdermo pasted ‚Äúundefined called from System.Plugins‚Äù at http://hpaste.org/78425
10:41:49 <mmcdermo> So, I'm trying to use the 'plugins' package. When I attempt to load a trivial module, it calls undefined. http://hpaste.org/78425
10:41:57 <mmcdermo> I'm probably missing something fairly basic.
10:42:33 <lpsmith> xunatai:  good idea,  unfortunately I'm still reading in 8096 bytes into a buffer
10:42:47 <hpaste> mmcdermo annotated ‚Äúundefined called from System.Plugins‚Äù with ‚Äúundefined called from System.Plugins (annotation) w/ output‚Äù at http://hpaste.org/78425#a78426
10:45:17 * lpsmith is curious if the same behavior occurs with other versions of ghc
10:46:29 <xunatai> maybe show a snippet of code?
10:56:41 <temoto> Hello. I have this quickcheck data generator for comment strings: commentStrings = do { s <- Q.arbitrary; return $ "#" ++ s }    How to instruct arbitrary to avoid newline characters?
11:01:17 <parcs`> can't you just filter the newline characters?
11:03:27 <yitz> lpsmith: did you try a strict bytestring? in fact - why are you using a lazy one here?
11:04:09 <yitz> ah because Get needs that type maybe
11:04:17 <lpsmith> yeah, because get needs lazy bytestrings
11:04:43 <yitz> so then try using a strict one to read from /dev/urandom, then convert to a lazy one for Get. see if that helps.
11:05:01 <lpsmith> I'm reading the source to ByteString, I don't think that'll help
11:05:04 <glguy> Lazy bytestring's hGet just calls strict bytestring's hget
11:05:17 <glguy> the behavior comes from hGetBuf
11:05:17 <lpsmith> I just finished with the lazy bytestring's hGet
11:05:31 <glguy> (and its dependencies)
11:06:32 <yitz> glguy: where's that, in Foreign?
11:06:51 <lpsmith> System.IO
11:06:52 <glguy> I don't remember, I just clicked through the source links on Hackage
11:07:02 <glguy> Oh, yeah, hGetBuf was System.IO
11:07:04 <lpsmith> System.IO.hGetBuf
11:07:11 <glguy> but the implementation goes deeper into GHC.*
11:07:27 <ParahSail1n> can an IO [a] be consumed lazily?
11:07:29 <Eelis> what does the error "module `X' is a package module" mean when hint fails to load a module?
11:07:39 <MrWoohoo> I was going to make Data.MultiSet a monad instance and was noticing something about the Ord type constraint‚Ä¶ In order to be a monad it needs to be able to contain instances of itself (see join).. does this mean I need to make MultiSet itself an Ord instance?
11:08:11 <ParahSail1n> ie, i want to do it in constant memory
11:08:37 <warpy> hello
11:08:42 <MrWoohoo> hello
11:08:44 <glguy> MrWoohoo: you won't be able to make a monad instance for it if the operations have an Ord constraint
11:09:02 <glguy> Monad works for all types
11:09:06 <warpy> http://stackoverflow.com/questions/tagged/haskell+scheduler
11:09:12 <MrWoohoo> hmmm
11:09:20 <warpy> haskell doesnt have a task scheduler library?
11:09:56 <MrWoohoo> so type constraints of any sort mean a type can't be a monad?
11:10:08 <warpy> googling certainly doesnt yield one
11:10:56 <S11001001> MrWoohoo: yes, because you can't satisfy f <$> g <$> x = f . g <$> x with constraints.
11:11:07 <Ankhers> Is there a way to tell which build (32/64bit) of GHC I have installed?
11:11:55 <S11001001> MrWoohoo: not to mention the type sigs.
11:11:56 <yitz> lpsmith: yep, looks like hGetBuf always uses a buffer
11:11:58 <lpsmith> yitz, glguy whatever this issue is,  I'd say it appears to be with GHC and not ByteString.
11:12:12 <yitz> lpsmith: it's in System.IO
11:12:33 <monochrom> Ankhers: perhaps System.Info.arch
11:12:38 <yitz> lpsmith: maybe hGetCh ?
11:12:38 <S11001001> MrWoohoo: but the fusion example demonstrates that even in languages where you can fake it, like keys on maps in scala, you don't get a real functor.
11:13:24 <warpy> how do i execute a task at a particular future time?
11:13:31 <lpsmith> yitz, I think I'd just write a little C helper function at that point
11:13:39 <Ankhers> monochrom: Thank you... you just solved all my problems...
11:14:35 <yitz> lpsmith: yeah hGetChar goes through all the encoding stuff, yuck
11:14:41 <MrWoohoo> Argh, I'm just trying to use Multiset's API in a do block‚Ä¶ Right now I'm reduced to wrapping it in a State and writing little glue functions
11:15:13 <lpsmith> not to mention,  needing 16 system calls instead of 1,  if hGetCh is appropriately unbuffered
11:15:25 <yitz> lpsmith: maybe bring this up to ghc hq. quick, before simon leaves.
11:17:19 <S11001001> MrWoohoo: you can write ??? => ([a] -> [b]) -> MS a -> MS b, right?
11:17:47 <yitz> ParahSail1n: yes, if the source of the IO [a] is lazy IO.
11:17:48 <MrWoohoo> not sure what you're getting at.
11:18:07 <S11001001> MrWoohoo: lifts a list transformer into a multiset transformer.
11:18:27 <MrWoohoo> ah‚Ä¶ um‚Ä¶ I think LOL
11:18:43 <yitz> ParahSail1n: for example, readFile and getContents from the Prelude use lazy IO. also if it comes from reading lazy text or bytestring.
11:19:16 <MrWoohoo> I think I can write fmap and join for Multiset and with that implement >>=
11:19:24 <S11001001> no, you can't write fmap for multiset.
11:20:03 <glguy> :t fmap
11:20:04 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:20:10 <S11001001> @type (<$> Just 42)
11:20:11 <lambdabot> Num a => (a -> b) -> Maybe b
11:20:29 <S11001001> MrWoohoo: that's forall a, forall b.
11:20:52 <glguy> MrWoohoo: You can't write a Functor instance for MultiSet because MultiSets can only hold things that satisfy an Ord constraint
11:20:55 <ParahSail1n> the source of IO [a] in this case is Data.HashTable.IO.toList
11:20:59 <yitz> MrWoohoo: in what way do you want to use it in a do block? being pure makes the API more flexible, not less flexible.
11:21:32 <yitz> ParahSail1n: from unordered-containers?
11:21:36 * hackagebot dawg 0.8.1 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.8.1 (JakubWaszczuk)
11:21:54 <ParahSail1n> hashtables
11:22:03 <MrWoohoo> I didn't want to pass intermediate multisets around thru tmp vars etc. Just learning haskell. This has been a great exercise tho :)
11:22:04 <yitz> ParahSail1n: sounds like there is no way that could be lazy, no.
11:22:45 <glguy> MrWoohoo: You can write a function that is like bind and one that is like fmap for MultiSet, they just won't have the same type as bind and fmap
11:23:04 <glguy> ?type Data.Set.map
11:23:05 <lambdabot> (Ord b, Ord a) => (a -> b) -> S.Set a -> S.Set b
11:23:13 <ParahSail1n> yitz: then am i stuck allocating an entire list?
11:23:36 <S11001001> I thought that problem was only in Map
11:24:01 <Clint> is there anything i can do about acid-state sucking up ridiculous amounts of ram?
11:24:25 <isturdy> Clint: How much are you trying to store in it?
11:24:41 <Clint> isturdy: the checkpoint was a little over 100 megs
11:24:44 <yitz> ParahSail1n: you've already allocated the entire hashtable, so all the data is already in memory. could be the list nodes themselves will in fact be allocated lazily, but that may not help you much.
11:24:54 <MrWoohoo> Well, thanks for the great help. I will press on until I discover the wall :) learning experience
11:24:55 <c_wraith> acid-state is not especially memory-efficient.
11:25:21 <ParahSail1n> yitz: yeah im fine with that part obviously, i just dont want the list nodes to be all allocated at once
11:26:36 * hackagebot nerf 0.2.2 - Nerf, the named entity recognition tool based on linear-chain CRFs  http://hackage.haskell.org/package/nerf-0.2.2 (JakubWaszczuk)
11:26:39 * hackagebot polimorf 0.6.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.6.0 (JakubWaszczuk)
11:26:53 <isturdy> Clint: Since it keeps its tables in memory, if you have 100 megs of data (in whatever internal representation it uses) there is no way around it. Do you know how much the structure you are storing takes on its own?
11:27:10 <MrWoohoo> S11001001: what was only a problem in map?
11:27:31 <S11001001> @ty Data.Map.Lazy.map
11:27:32 <lambdabot> Couldn't find qualified module.
11:27:35 <yitz> ParahSail1n: so if that part is important, i'm not sure.
11:27:37 <S11001001> @ty Data.Map.map
11:27:39 <lambdabot> (a -> b) -> M.Map k a -> M.Map k b
11:27:45 <S11001001> er
11:27:51 <S11001001> @ty Data.Map.mapKeys
11:27:52 <lambdabot> Ord k2 => (k1 -> k2) -> M.Map k1 a -> M.Map k2 a
11:27:59 <Clint> isturdy: i do not, but it's sucking up several gigs of ram
11:28:02 <S11001001> MrWoohoo: note only Ord k2, no Ord k1
11:28:16 <MrWoohoo> ah!
11:28:35 <MrWoohoo> um, I think ;)
11:29:03 <ParahSail1n> yitz: seems unsafePerformIO might be a way to make sure?
11:29:18 <yitz> ParahSail1n: i don't think that's the issue.
11:29:41 <S11001001> MrWoohoo: you can write Ord a => Set a -> Map a () totally, so...
11:29:54 <yitz> ParahSail1n: it just depends on how greg implemented toList.
11:30:37 <ParahSail1n> yitz: yeah im looking at how his foldM works
11:30:55 <ParahSail1n> yitz: i think ill just try that way
11:31:04 <yitz> ParahSail1n: sounds good
11:31:45 <Clint> so i guess the answer is "don't use acid-state"
11:42:03 <hpaste> Qgel pasted ‚ÄúPCP‚Äù at http://hpaste.org/78436
11:42:52 <qgel> I'm trying to solve the post correspondence problem (ie. find a solution if there is one), but my implementation is way to slow. I'm relatively new to haskell, any tips?
11:43:11 <lpsmith> yitz, I haven't dug through GHC.IO in sufficient detail yet,  but it appears that everything is buffered to some extent,  I don't see why hGetBuf would be buffered and hGetCh wouldn't.
11:45:30 <lpsmith> qgel,   two suggestions,  first store your lists in reverse order,  as l ++[x] is slow
11:45:43 <lpsmith> second,  consider something other than lists
11:45:50 <merijn> Clint: acid-state is mostly meant for "live" program state that needs to persist through crashes/restarts, not really for dumping lots of data
11:46:34 <lpsmith> I'm sure there are other optimizations,  but I'm guessing that storing the working candidates in reverse order will help a whole bunch
11:47:18 <lpsmith> qgel, also,  concatCards should definitely be a foldr not foldl
11:47:27 <applicative> how do I decide what N to give cabal install --jobs=N ?
11:47:32 <lpsmith> that's leading to quadratic time behavior
11:47:34 <qgel> lpsmith: If I store them in reverse order, I would have to check for idetical suffixes instead of pefixes. Would that not force me to reverse the lists to do this (which in turn takes a hit on performance)
11:47:46 <dcoutts> applicative: same as you would for make -jN
11:47:46 <johnw> applicative: why give any N?  just use -j
11:48:08 <applicative> johnw yeah I was using -j, I just wondered
11:48:27 <lpsmith> yeah,  you'd need to be clever about that.  Probably want to store lengths as well,  that way you can drop the right number of elements off of the longer list and then compare the difference
11:48:36 <dcoutts> johnw: that can mean running a very large number of processes at once, not so good if you're memory constrained
11:48:44 <johnw> true
11:48:47 <lpsmith> but you also want to avoid comparing parts of the list that you know are equal already
11:48:48 <applicative> or what the difference was.   -j seems quite happy to use everything available
11:49:12 <applicative> somehow pandoc is still taking forever
11:49:20 <dcoutts> applicative: with make, the usual recommendation is num cores + 1 or 2
11:49:41 <johnw> i'm not sure if -j takes hyper-threads into accoutn
11:49:43 <applicative> dcoutts: is that what -j defaults to?
11:50:06 <qgel> lpsmith: I guess I could just drop everything thats equal and not even store it and just keep track of the cards that have been used. Thanks
11:50:16 <dcoutts> applicative: actually now that I come to think of it, yes
11:50:31 <merijn> johnw: -j just spawns processes, so if you have hyper threads you just spawn more and let the OS worry about it
11:50:31 <dcoutts> so what I said to johnw is wrong, it doesn't work the same way as make
11:50:43 <dcoutts> make -j means run as many as possible, given the dep graph
11:50:51 <dcoutts> which is usually a bad idea
11:51:57 <applicative> i wonder is there a giant round of haddocking at the end? the last thing to be install, pandoc, must have taken almost 10 minutes by now ... the usual nightmare , the syntax highlighting package was 'iinstalled' some time ago
11:52:09 <applicative> I should have asked for more verbosity
11:52:15 <hiptobecubic> if you have fast IO, then +1 is no longer a good idea
11:53:53 <applicative> dcoutts: so were you saying that with 2 cores I should do jobs=3 or the like?
11:54:28 <dcoutts> applicative: yes, 2 or 3, as hiptobecubic says, it's somewhat dependent on the disk latency
11:54:37 <gnuvince> When I try to load an Emacs buffer in inf-haskell (C-c C-l), I get a waiting cursor and the file is never loaded. Anyone ever had that?
11:54:45 <applicative> I think that can't be the problem though, ghc has been down to one process in the os process reader thingy
11:55:01 <applicative> 'Activity Monitor.app'
11:55:11 <Crockeo_> Purely academic question: How would one go about implementing a linked list in Haskell?
11:55:15 <hiptobecubic> applicative, if you have an ssd or are building in memory, then doing more than numcores can be slower.
11:55:30 <Crockeo_> Rather, how would one define the end of a linked list?
11:55:50 <hiptobecubic> Crockeo_, data List = Nil | Cons List
11:55:54 <johnw> Crockeo_: data List a = Nil | Cons a (List a)
11:56:12 <hiptobecubic> if you want values at the nodes then sure :)
11:56:25 <applicative> hiptobecubic:  hm. Anyway, the install broke down, mutely since I didn't demand a verbose build
11:56:26 <hiptobecubic> i prefer to do everything by counting in unary!
11:56:29 <Crockeo_> hiptobecubic, johnw: Now that's much more elegant than what I was going about.
11:56:34 <Crockeo_> Thank you.
12:03:33 <Lorenzino> sera
12:03:47 <Lorenzino> !list>
12:05:45 <Clint> merijn: ah, i seem to have misunderstood as a replacement for various sql libraries
12:09:36 <tac> @type arr
12:09:37 <lambdabot> Arrow a => (b -> c) -> a b c
12:09:58 <tac> (God bless typos, God bless @type)
12:12:33 <merijn> Clint: Well, it can be used in place of SQL in some applications, but it depends on your usecase. For example, a simple blog site with not much data could easily be implemented as a Map type data structure and acid-state
12:12:56 <phoenix__> helloguys
12:14:01 <merijn> Clint: Or servers that have some sort of persistent state you want to keep through potential server crashes would be another example, in many scenarios requiring an SQL database can be overkill/overly complicated, but if your use case is "huge amounts of data to selectively query" than you'll want to keep SQL
12:14:36 <merijn> (Other examples would be application configuration that things like firefox store in SQLite, you could easily persist that using acid-state)
12:18:04 <Clint> merijn: right, i want a queryable cache of a lot of data
12:18:41 <phoenix__> i know Haskell since today, and i begin to learn. I don't understand why this list doesn't work [ x/y | x <- [7], y <- [1,2..100], x `mod` y == 0] Can someone help me? Thank you
12:19:10 <merijn> Clint: Yeah, then you should just stick to some form of SQL :)
12:19:27 <Clint> merijn: dammit
12:25:23 <zomg> Anyone happen to know if there's some way to know why JSON parsing failed when using Aeson?
12:25:54 <zomg> Kinda hard to debug it when it just gives you a Nothing on failure
12:27:28 <c_wraith> zomg: you can use the parsers provided, json or json', and look at the failure messages.  It *may* help
12:27:48 <zomg> Ah of course, thanks
12:34:02 <applicative> hm, with --jobs=2 it takes cabal 5+ minutes to build pandoc + extra platform dependencies; with no --jobs, three and a half minutes...
12:35:06 <c_wraith> maybe the process is IO bound in such a way that having two going at once really kills IO scheduling on your hard drive?
12:35:49 <applicative> ah, but with just -j it takes 2 m 16s altogether 14 packages
12:36:01 <c_wraith> by the way, never copy two large files off a CD at the same time. Takes like 15x longer than doing them in sequence :)
12:36:02 <xunatai> dafuq
12:36:21 <xunatai> hm
12:36:29 <xunatai> applicative: probably due to caching
12:36:38 * hackagebot esqueleto 0.2.9 - Bare bones, type-safe EDSL for SQL queries on persistent backends.  http://hackage.haskell.org/package/esqueleto-0.2.9 (FelipeLessa)
12:37:15 <applicative> xunatai: what is being cached?
12:37:42 <applicative> 200 modules worth of binary blah?
12:37:58 <xunatai> stuff
12:38:05 <xunatai> try running it again with --jobs
12:38:26 <applicative> instead of -j  ?
12:38:33 <xunatai> yes
12:40:48 <zomg> c_wraith: well at least doing that confirms the JSON is valid, but apparently my data types which I'm attempting to convert said data to do not match what Aeson expects them to be
12:42:31 <applicative> xunatai: youre more than right; i forgot to do cabal clean with the -j experiment
12:42:34 <tac_> Does anyone know of papers on the topic of local subtyping?
12:42:44 <ntp_> hello, i would like to use hoogle on the command line, I installed it with cabal, but entering "hoogle" on the terminal does not work. i saw that hoogle was installed to ~/.cabal/bin, which is not in my PATH, is this the problem?
12:42:52 <rwbarton> yes
12:43:49 <rwbarton> you can add ~/.cabal/bin to your PATH, or run hoogle from ~/.cabal/bin explicitly, or symlink it to somewhere on your path
12:44:19 <Eduard_Munteanu> ntp_: add something like   export PATH=$PATH:/home/ntp/.cabal/bin   in your ~/.bashrc
12:45:14 <applicative> on osx   export PATH=$PATH:/Users/<yournamehere>/.cabal/bin  to your ~/.profile
12:45:16 <typoclass> ntp_: if you add things to .bashrc (or zsh's equivalent), you need to restart all the shells so that it'll work
12:45:59 <ntp_> thank you very much
13:01:39 * hackagebot aeson-pretty 0.7 - JSON pretty-printing library and command-line tool.  http://hackage.haskell.org/package/aeson-pretty-0.7 (FalkoPeters)
13:05:55 <b__> I feel a bit silly for asking this, as it was answered already earlier this afternoon by about three people at the same time, but how does one use at/_at to lookup a k:v pair in a Map?
13:06:40 <b__> to lookup a value actually
13:07:49 <b__> and yes I have now enabled logging in my irc client to prevent this form happening again =D
13:08:40 <b__> aha I have found the public logs for this channel, please ignore my last 3 lines =]
13:10:05 <monochrom> wait, the function is called "at"?
13:10:35 <applicative> > M.fromList [(1,"hello"),(2,"goodbye")] ^.at 2
13:10:37 <lambdabot>   Just "goodbye"
13:10:59 <b__> is there a lens that gives me the x in Just x?
13:11:03 <applicative> hahaha
13:11:11 <monochrom> oh! it's a lens thing. nevermind me then.
13:11:20 <applicative> b__ that would be wrong
13:11:32 <b__> like an implicit fromJust
13:11:36 <b__> =[
13:11:49 <monochrom> I think there is an "unsafe lens" for that
13:12:13 <monochrom> but all "unsafe" things are pretty taboo in this channel :)
13:12:54 <b__> ok, but I don't mind my process failing on this point
13:13:09 <b__> I'll go with fromJust or fromMaybe then
13:13:45 <fengshaun_> hi all, how can I pretty print a nested list?
13:14:28 <rwbarton> :t (^?!)
13:14:29 <lambdabot> s -> Getting (First a) s t a b -> a
13:14:44 <rwbarton> > M.fromList [(1,"hello"),(2,"goodbye")] ^?! at 2
13:14:46 <lambdabot>   Just "goodbye"
13:14:54 <rwbarton> hm
13:15:35 <rwbarton> > M.fromList [(1,"hello"),(2,"goodbye")] ^?! at 2.traverse
13:15:37 <lambdabot>   "goodbye"
13:15:42 <rwbarton> > M.fromList [(1,"hello"),(2,"goodbye")] ^?! at 3.traverse
13:15:44 <lambdabot>   "*Exception: (^?!): empty Fold
13:15:53 <rwbarton> > M.fromList [(1,"hello"),(2,"goodbye")] ^?! traverseAt 2
13:15:55 <lambdabot>   Not in scope: `traverseAt'
13:15:55 <lambdabot>  Perhaps you meant one of these:
13:15:55 <lambdabot>    `traverse' (...
13:16:01 <rwbarton> > M.fromList [(1,"hello"),(2,"goodbye")] ^?! _at 2
13:16:03 <lambdabot>   "goodbye"
13:16:13 <rwbarton> @type _at
13:16:13 <b__> oha =]
13:16:14 <applicative> oooh
13:16:14 <lambdabot> (Applicative f, At k m, Indexed k k1) => k -> k1 (v -> f v) (m v -> f (m v))
13:16:50 <applicative> > M.fromList [(1,"hello"),(2,"goodbye")] ^?! _at 15
13:16:52 <lambdabot>   "*Exception: (^?!): empty Fold
13:16:54 <rwbarton> those are pretty new
13:17:12 <tac_> @hoogle Monad m => (a -> m b) -> ma -> mb
13:17:13 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
13:17:13 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
13:17:13 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
13:17:39 <applicative> is there some easy way do to something like maybe or whatever, with a default value
13:17:40 <tac_> oh, it's just flip bind
13:18:03 <applicative> =<< is really ugly. It depresses me
13:18:07 <neutrino> yeah you want =<<
13:18:10 <neutrino> applicative: why
13:18:18 <neutrino> stop seeing smileys everywhere.
13:18:36 <applicative> i go for join . liftM f
13:18:41 <applicative> or whatever
13:19:07 <jerojasro> neutrino: have you read this: http://briancarper.net/blog/439/ ?
13:19:28 <applicative> I want =<< when I'm thinking about the matter in an unsequential sort of way, but =<< somehow forces the sequence on me, just written backwards
13:21:02 <xunatai> Heterogeneous Parallel Programming began today on coursera, for those interested: https://www.coursera.org/course/hetero
13:21:08 <hiptobecubic> oh right
13:21:13 <applicative> concatMap doesn't give me an impression of 'sequencing' but   show =<< [1,2,3]  does
13:21:14 <hiptobecubic> i think i'm signed up for that actually
13:23:04 <neutrino> jerojasro: haha, i love the comments
13:23:21 <neutrino> xunatai: the url is a bit ..
13:23:50 <xunatai> the what
13:24:05 <neutrino> the url.
13:24:18 <xunatai> what about it
13:24:47 <neutrino> it looks like a stab at gay people
13:24:59 <simpson> It does?
13:25:02 <neutrino> yes.
13:25:04 <merijn> wut?
13:25:07 <applicative> > let (\^.^/) = id in  (+1) \^.^/ 2
13:25:07 <xunatai> "hetero" is a generic prefix
13:25:08 <b__> no way
13:25:08 <lambdabot>   3
13:25:29 <neutrino> of course it is
13:25:46 <neutrino> but here, it's not part of a word, it's a word on its own
13:25:52 <neutrino> which has a very specific meaning
13:25:55 <neutrino> anyways, never mind
13:25:57 <merijn> neutrino: Please stop trolling
13:26:14 <applicative> > let (\^.^/) = fmap  in  even  \^.^/  [1,2,3]
13:26:16 <lambdabot>   [False,True,False]
13:26:26 <b__> would /homo be a stab at heterosexual people?
13:26:31 <xunatai> nope
13:27:07 <neutrino> merijn: i'm not trolling.
13:27:16 <neutrino> merijn: and, i said "never mind"
13:27:34 <neutrino> so please stop being disdainful? i guess.
13:33:08 <Marina> hi
13:33:39 <simpson> Howdy.
13:34:30 <eacameron> Is there a function that acts like splitAt but takes (a -> Bool) instead of Int (i.e. a function to split by instead of a position)?
13:34:47 <geekosaur> :t splitBy
13:34:49 <lambdabot>     Not in scope: `splitBy'
13:34:49 <lambdabot>     Perhaps you meant one of these:
13:34:49 <lambdabot>       `splitAt' (imported from Data.List),
13:34:59 <simpson> :t splitAt
13:35:00 <lambdabot> Int -> [a] -> ([a], [a])
13:35:28 <simpson> @hoogle (a -> Bool) -> [a] -> ([a], [a])
13:35:29 <lambdabot> Prelude break :: (a -> Bool) -> [a] -> ([a], [a])
13:35:29 <lambdabot> Data.List break :: (a -> Bool) -> [a] -> ([a], [a])
13:35:29 <lambdabot> Prelude span :: (a -> Bool) -> [a] -> ([a], [a])
13:35:48 <simpson> > break (>= 5) [1..10]
13:35:49 <lambdabot>   ([1,2,3,4],[5,6,7,8,9,10])
13:35:55 <simpson> eacameron: ^^^?
13:36:19 <xunatai> @src break
13:36:19 <lambdabot> break p =  span (not . p)
13:36:29 <xunatai> @src span
13:36:29 <lambdabot> span _ xs@[]                     =  (xs, xs)
13:36:29 <lambdabot> span p xs@(x:xs') | p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
13:36:29 <lambdabot>                   | otherwise    =  ([],xs)
13:36:43 <xunatai> guh
13:37:00 <xunatai> @src (@)
13:37:00 <lambdabot> Source not found. My pet ferret can type better than you!
13:37:40 <eacameron> simpson: ahh yes...thank you. I tried those at first but I was mistaken: they work
13:38:22 <simpson> eacameron: No worries.
13:38:39 <simpson> eacameron: I wanted to outline how I'd go about answering the question, too, since I didn't know the answer offhand.
13:39:06 <eacameron> simpson: that is helpful, thank you
13:39:19 <simpson> eacameron: I try! :3
13:41:01 <Marina> Is there a painless way to use Yesod in Windows than dual boot or a standalone Linux?
13:41:39 * hackagebot fb 0.13.3 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13.3 (FelipeLessa)
13:41:40 <simpson> Marina: TBH I've only done Yesod on Linux. I hear that it works on Windows, but I'm not sure how painless it is.
13:42:08 <simpson> I *do* like winghci and the other platform goodies for Windows, but I've only dicked around with it for a grand total of maybe eight minutes.
13:42:36 <Marina> simpson: huh...thank you
13:43:02 <simpson> Marina: Sure. Best of luck! Also, there's a dedicated Yesod channel. #yesod IIRC.
13:43:03 <Marina> problems with cabal installation
13:45:12 <DrSyzygy> What do I need to add to Build-Depends for my Network.AMQP-dependent app to build cleanly?
13:45:31 <DrSyzygy> I tried adding amqp, but it claims -- even after a successful cabal install amqp -- that it cannot find that package.
13:57:44 <luqui> Is there a standard newtype that will give me a monoid from an applicative; i.e. mappend = liftA2 mappend ?
13:58:04 <clahey> xunatai: You could try hoogle.
13:58:12 <xunatai> yes
13:58:17 <xunatai> i'm just lazy
13:58:31 <clahey> xunatai: But a@pattern means match against the pattern, but include a as a name for the passed in value.
13:58:46 <xunatai> ahh
13:58:49 <xunatai> thanks
14:00:19 <clahey> xunatai: The difference between  test a@x:xs = a  and  test x:xs = x:xs  is that the second may end up allocating a second copy of the pointers, whereas the first is guaranteed to just return the original value.
14:00:20 <clahey> I think.
14:00:32 <clahey> Denotationally, they're the same.
14:01:45 <tromp> > 41.5/36
14:01:45 <monochrom> you need more parentheses. a@(x:xs). but ok.
14:01:46 <lambdabot>   1.1527777777777777
14:05:16 <malorie> is there a way to have cyclic type synonyms?
14:06:22 <atriq> You mean like type Foo = Bar Foo?
14:06:23 <atriq> No
14:06:27 <atriq> Use a newtype
14:06:33 <sclv> there's got to be a topological name for this sort of thing https://gist.github.com/4162375
14:06:46 <malorie> hrm :\
14:06:47 <Philippa_> atriq: hell, use a newtype fixpoint operator!
14:07:01 <sclv> it's the one point compactification to extend a data type with 1
14:07:18 <sclv> but what is it to extend a data type with a Pure constructor?
14:12:59 <tomeo_> Is it possible to write a pattern match which matches only for a string of length 1?
14:13:14 <atriq> ['a'
14:13:15 <koala_man> tomeo_: [x]
14:13:15 <atriq> ]
14:13:27 <tomeo_> koala_man: wouldnt that match any string as a string is a list?
14:13:54 <koala_man> tomeo_: x would match any string. [x] would match any list with one element.
14:14:01 <tomeo_> ah
14:14:02 <tomeo_> thanks koala_man
14:14:15 <koala_man> or [_] of course, if you don't care about the actual value
14:17:44 <monochrom> [x] matches ['b'] but not ['b', 'c']
14:18:01 <monochrom> "bc" is euphemism for ['b', 'c']
14:20:20 <dafis> Is there any way to force GHC to perform a (short) sequence of computations in a specific order? I have something like { r += q; q *= a; r -= q; q *= a; } and I can't get GHC to do it like that, using only three floating point registers and four instructions. GHC always throws in a couple of `movss %xmm1,%xmm0` and that's killing performance.
14:22:53 <acowley> Has anything changed in the wild, wacky world of generating pseudo random numbers lately?
14:23:33 <acowley> Hackage always sends me mixed signals when I periodically check for related packages, and I end up using System.Random and feeling like a schlub.
14:26:48 <sclv> acowley: if randomness is a bottleneck you should consider mwc-random
14:27:03 <acowley> It's not a bottleneck, I'm just looking for convenience, frankly.
14:27:11 <sclv> ah, then system.random it is :-P
14:27:34 <acowley> But folks with a horse in the crypto race frequently say things that make me feel guilty about using System.Random
14:27:44 <MrWoohoo> what are block comments in haskell?
14:27:45 <acowley> It's peer pressure that drives me to higher quality PRNGs.
14:27:50 <sclv> as i recall you use it linearly and its fine.
14:27:52 <sclv> hahaha
14:27:52 <acowley> {- -}
14:28:01 <MrWoohoo> thanks
14:28:02 <sclv> splitting has some funny properties
14:28:20 <sclv> oh, you were answering a question. i thought that was a strange new emoticon
14:28:26 <sipa> acowley: you about havaged?
14:28:32 <sclv> like fry ish
14:28:37 <acowley> sclv: I was addressing both of you
14:28:59 <sipa> acowley: haveged, sorry
14:29:27 <sclv> crypto prngs are totally different in terms of what you want than prngs for statistics or prngs for simulations or whatever anyway
14:29:58 <acowley> Have GED, will Haskell?
14:30:27 <sclv> you only care about predictable randomness if you have an actual adversary, not a made up adversarial whatever in algoland
14:30:28 <sipa> acowley: i case you were asking something haskell-specific, no idea
14:31:04 * geekosaur is using haveged on his test VMs, fwiw
14:31:05 <acowley> sclv: I have definitely lazied myself into a corner by not-as-random-as-I-thought simulations in the past
14:31:40 <acowley> I'd never heard of haveged! I thought sipa was having an episode :/
14:32:24 <sipa> acowley: not this time, sorry
14:32:36 <sipa> it's a daemon that implements the HAVEGE algorithm
14:32:58 <acowley> Yes, I was just looking at the web page. This is why I'm not a medical doctor.
14:33:15 <sclv> havage does sound quite serious
14:42:35 <acowley> Hrm, I want to mapM through a lens and now am lost in the land of lens
14:43:03 <merijn> acowley: I hear that if you look into a mirror and say "lens" three times edwardk appears
14:43:28 <typoclass> (i bet after much research and digging through typeclass variables the solution will be some three-symbol thingy like ^!$ )
14:43:40 <acowley> And he is indeed the best combination of djinn, hoogle, and haddock we have
14:43:56 <acowley> I should just hold shift and bang away at the number keys until it type checks
14:44:30 <typoclass> acowley: a traditional method of software development
14:44:32 <fmap> :t traverseOf
14:44:33 <elliott> :t mapMOf
14:44:33 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
14:44:34 <lambdabot> LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
14:44:57 <elliott> :t mapMOf both putStrLn (1,2)
14:44:58 <lambdabot>     No instance for (Num String)
14:44:58 <lambdabot>       arising from the literal `1'
14:44:58 <lambdabot>     Possible fix: add an instance declaration for (Num String)
14:45:04 <elliott> :t mapMOf both print (1,2)
14:45:05 <lambdabot> IO ((), ())
14:45:11 <elliott> heh
14:45:12 <elliott> :t mapMOf_ both print (1,2)
14:45:13 <lambdabot> IO ()
14:45:41 <radox1> Hi
14:45:41 <lambdabot> radox1: You have 1 new message. '/msg lambdabot @messages' to read it.
14:45:54 <quchen> :t both
14:45:56 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
14:46:07 <glguy> :t both print
14:46:08 <lambdabot> Show a => (a, a) -> IO ((), ())
14:46:20 <quchen> Where's both defined?
14:46:26 <glguy> Control.Lens
14:46:27 <typoclass> quchen: in lens
14:46:40 <quchen> Oh, that one again. Should've known that myself
14:46:47 <radox1> Whats the easiest way to kill a thread?
14:46:47 <elliott> I think mapMOf is in fact just id, were Applicative a superclass of Monad.
14:46:51 <elliott> :t both
14:46:52 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
14:46:58 <elliott> fits (a -> IO b) -> (a, a) -> IO (b, b)
14:47:02 <radox1> I tried killThread but it did not seem to work
14:47:02 <acowley> Yeah, I just wanted mapMOf havage (T.mapM notAnEpisode)
14:47:30 <elliott> Isn't it HAVEGE? At least Google suggests so.
14:47:57 <acowley> Yes, but havage is the medical condition
14:48:08 <acowley> Well, it is now, at least
14:53:20 <radox1> hello
14:53:48 <quchen> Hello sir!
14:54:24 <acowley> That's a gender-neutral "sir"!
14:54:44 * shapr bounces cheerfully
14:54:50 <shapr> Good evening #haskell! How's code?
14:55:22 <Philippa_> er. I'm cursing the fact we /still/ can't have nice autolifting instances for monad transformers
14:55:39 <Philippa_> (rather, ones that're nice for whoever's stuck maintaining the set of transformers to write)
14:56:00 <acowley> Whatever became of the zipper work with MTs?
14:56:07 <acowley> Has that seen much up-take?
14:56:12 <Philippa_> not that I'm aware of
14:56:23 <Philippa_> (but I wouldn't be)
14:56:47 * typoclass purrs in the direction of shapr
14:58:53 <ParahSail1n> im having a really hard time getting ByteString to be an instance of Hashable
14:58:54 <shapr> Howdy typoclass !
15:00:10 <acowley> ParahSail1n: hpaste some code!
15:00:23 <dmwit> radox1: You're going to have to do better than that.
15:00:37 <dmwit> "It didn't work." isn't a real problem description. =)
15:00:47 <Philippa_> acowley: I suspect the problem with the zipper'd be that the typing's a bitch
15:01:07 <dmwit> radox1: Also, if you're asking about threading and gtk so close to each other, I feel obligated to point you to
15:01:10 <dmwit> http://dmwit.com/gtk2hs
15:02:17 * dmwit purrs in no particular direction
15:02:37 <radox1> :(
15:03:10 <ParahSail1n> acowley: with Hashable imported, it should be an instance already
15:03:52 <acowley> ParahSail1n: So what's going wrong?
15:04:36 <ParahSail1n> acowley: ghc tells me << No instance for (hashable-1.1.2.3:Data.Hashable.Hashable BC.ByteString)
15:04:49 <dmwit> Oooo, I know this!
15:04:51 <ParahSail1n> acowley: im wondering if i screwed something up with cabal
15:04:57 <dmwit> ghc-pkg list hashable and get a surprise!
15:05:18 <ParahSail1n> dmwit: hehe awesome
15:05:27 <acowley> Not the good kind of surprise :(
15:05:31 <ParahSail1n> dmwit: how do i get rid of that old one
15:05:36 <dmwit> ghc-pkg unregister
15:05:41 <dmwit> then ghc-pkg check to see what you broke
15:05:51 <dmwit> (Note: I didn't not say "see if you broke something". =)
15:05:55 <dmwit> uh
15:05:57 <dmwit> s/not//
15:06:00 <aavogt> dmwit: how long did you struggle with a problem like that?
15:06:16 <dmwit> Ugh, the first time probably 30-45 minutes.
15:06:33 * aavogt too probably
15:06:38 <dmwit> But now just seeing a package version number in an error is enough to tell me exactly what happened. =)
15:07:11 <acowley> I throw out my computer as soon as I see a package version number. It's the only way to be sure.
15:07:21 <dmwit> =)
15:07:29 <ParahSail1n> dmwit: aw crap now everything's broken
15:07:33 <aavogt> ghc has gotten better at spelling things out for you. It even has a spell-checker now!
15:08:30 <dmwit> ParahSail1n: cabal install all the broken things and the new thing you want along with a constraint on the version of hashable that you want, all in one command.
15:08:48 <dmwit> oops, gotta run
15:08:50 <ParahSail1n> dmwit: just figured that out, working now
15:08:53 <acowley> cabal install's new -j support makes CPU investment pay off when version numbers appear
15:08:57 <dmwit> Lots of knowledgable people in here, though.
15:09:00 <ParahSail1n> cabal is scary
15:09:20 <acowley> It just wants to be loved
15:10:01 * sm loves cabal -j, just don't max out your ram and lock up your machine
15:10:27 <acowley> GHC is awesome at maxing out RAM
15:10:44 <sm> ld is even better
15:10:48 <nyc> I'm just an ignorant incompetent idiot.
15:11:23 <ParahSail1n> what's -j?
15:11:41 * hackagebot wraparound 0.0.2 - Convenient handling of points on a seamless 2-dimensional plane  http://hackage.haskell.org/package/wraparound-0.0.2 (ChristopherHoward)
15:12:45 <sm> install things in parallel
15:13:22 <acowley> sm: Yes, and -j lets ghc and ld dance like an ocean wave romanced!
15:13:50 <elliott> cabal locks up my system without any help from -j at all
15:13:50 * sm needs a new computer for all these cabal installs
15:13:51 <acowley> ParahSail1n: It cleverly cabal-installs things in parallel wherever possible using the given number of processes.
15:14:01 <acowley> sm: This laptop has 2GB of RAM
15:14:06 <sm> mine too
15:14:19 <acowley> Hurts, don't it?
15:14:28 <sm> yeah!
15:14:32 <acowley> I keep having to close my browser to finish linking the thing I'm working on
15:14:49 <sm> have you tried gold ?
15:14:56 <elliott> i have 4 and it still freezes
15:15:44 <acowley> I even use python as a repl calculator some times because GHCi uses too much RAM
15:15:47 <acowley> sm: no
15:15:56 <acowley> sm: is it hard to setup on a mac?
15:16:33 <sm> acowley: I haven't tried it
15:16:47 <andsens> Does parsec prepend new elements when using the combinator `many'?
15:16:49 <ParahSail1n> i've switched to ghci from python as my repl calculator so that i can save on parens
15:16:55 <pckt> ipython makes the best calculator
15:16:59 <andsens> Cause I've got all my elements in the reverse order
15:17:24 <koala_man> andsens: 'many' gives them in parsed order
15:17:46 <andsens> So the head is the first one parsed?
15:19:39 <geekosaur> gold won';t work on a mac, it's elf format only
15:19:55 <andsens> koala_man: Does that mean the head is the first one parsed?
15:19:58 <geekosaur> macs use mach-o executable / shared object format
15:20:13 <sm> pckt: better than mathematica 9 ?
15:20:19 <glguy> andsens: yes, many returns the list in the order parsed, first element is first parsed
15:20:44 <andsens> dayum, I got a problem then, haha
15:20:45 <luqui> are hs-boot files still the only way to have recursive modules?
15:20:46 <pckt> Haven't tried mathematica 9 yet, but it's pretty good
15:21:08 * sm has a bad case of mathematica envy
15:21:21 <quchen> Mathematica 8 with stochastic DEs? I'm in! HEY University, update your downloads already
15:30:24 <Joe9119> I am wanting to fork a thread on button press, to perform a long calculation, then kill the thread on another button press. I have tried [ forkIO function_name ] but when trying to kill this thread, it wouldn't work.. the thread_id's used in the computation kept increasing. Does anyone know why the thread Ids would keep increasing during the computation?
15:32:06 <glguy> every time you forkIO you'll get a new thread id
15:33:07 <Joe9119> I only called forkIO once, but it seems to make a lot more threads. The function is recursive, currently it is just to generate a Fibbonaci sequence
15:33:41 <quchen> Well, there should only be a single new (Haskell) thread per call to forkIO.
15:33:50 <glguy> if you recursively call forkIO you 'll just get a bunch of unrelated threads
15:34:13 <glguy> Can you paste your code to http://hpaste.org ?
15:35:40 <merijn> glguy: I think he's evaluating forkIO once, but running the action it returns multiple times
15:36:01 <glguy> good guess
15:36:02 <merijn> i.e. something like "let foo = forkIO bar in foo >>= killThread"
15:36:21 <merijn> spawning and killing on thread on every killThread execution :p
15:36:23 <Joe9119> http://hpaste.org/78443
15:36:48 <elliott>           let thread = (forkIO preformLongTask)
15:36:51 <elliott> this does not do what you think
15:37:19 <elliott> that means you have thread :: IO ThreadId
15:37:25 <elliott> which is an action which, when run, spawns that thread and returns its id
15:37:33 <elliott> you probably want: threadId <- forkIO performLongTask
15:37:48 <elliott> or I guess myThreadId or something since you have threadId as a field name already
15:38:00 <nyc> I usually do do { tid <- forkIO task ; ... ; killThread tid }
15:38:57 <Joe9119> Ok Thanks.. I'll change that now and check the result :)
15:39:19 <quchen> (Why is everyone here killing their threads when they finish?)
15:39:40 <quchen> (Sounds like sending -SIGTERM every time a program was closed.)
15:39:58 <koala_man> to, shall we say, wrap up loose ends
15:40:39 <quchen> merijn: What's wrong with 'let foo = forkIO bar in foo >>= killThread'?
15:41:37 <quchen> koala_man: How is a finished thread a loose end? The thing shouldn't compute bottom anyway
15:42:03 <Ralith> Joe9119: perhaps you would be interested in the Async lib
15:42:28 <Ralith> Joe9119: http://hackage.haskell.org/packages/archive/async/2.0.1.4/doc/html/Control-Concurrent-Async.html
15:44:50 <Joe9119> Thanks for the help. Got it working the way I wanted.. Even if it's not a perfect solution, it's just to test some basic understanding :)
15:45:30 <Joe9119> I'll upload what I did.. but I'm sure there are 1000 better ways of doing this :D
15:45:56 <Joe9119> http://hpaste.org/78443  -- Bottom source
15:50:51 <quchen> Joe9119: I'm surprised this typechecks. You bind an Int (the thread id) to 'thread', and then update an IORef sr to contain 'return thread', which has type 'm Int'.
15:51:10 <quchen> Don't you want to save the thread id only? As in only 'thread' of type 'Int'?
15:51:43 <glguy> (ThreadId isn't Int)
15:52:07 <quchen> Oh.
15:52:08 <quchen> Nevermind.
15:52:33 <glguy> But your point that the type of the "threadId" field is wrong would seem to be right
16:06:31 <quchen> It's awfully quiet here after disabling join/part messages. Anyway, good night everyone.
16:15:54 <niteria> @hoogle [Maybe a] -> Maybe a
16:15:55 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
16:15:55 <lambdabot> Data.Generics.Aliases orElse :: Maybe a -> Maybe a -> Maybe a
16:15:55 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
16:16:23 <niteria> > msum [Nothing, Nothing, Just 3, Nothing]
16:16:25 <lambdabot>   Just 3
16:19:12 <tomboy64> what's haskeline?
16:19:31 <tomboy64> ghc 7.6 throws a few warnings during build of it
16:20:07 <elliott> @hackage haskeline
16:20:07 <lambdabot> http://hackage.haskell.org/package/haskeline
16:21:49 <andsens> How can I pattern match a data record without getting any of its members?
16:22:09 <elliott> Foo{}
16:22:13 <andsens> Something like Stuff {_}, no matter how many fields there are
16:22:16 <andsens> oh
16:22:20 <elliott> > let isJust Just{} = True; isJust Nothing = False in isJust (Just ())
16:22:22 <lambdabot>   True
16:22:23 <andsens> cool, thanks elliott
16:22:25 <elliott> np
16:22:33 <tomboy64> ^^ thanks
16:24:55 <hpc> . o O (isJust = unsafeCoerce)
16:30:21 <tomeo> I have a list [(String,String)] and would like to give it to a function which filters it according to a given function. I want this function to look at the values of each fst and snd in each tuple of the list to determine if it stays or goes. Kind of like filter' (eq' x y) myList, but I don't understand how I give eq' the values from each tuple. Could someone please guide me in the right direction?
16:30:27 <glguy> hpc: unsafe means something else
16:30:46 <tomeo> x and y would be fst and snd
16:31:46 <hpc> > filter (\(x,y) -> x == y) [(0,0), (0,1), (1,0), (1,1)]
16:31:48 <lambdabot>   [(0,0),(1,1)]
16:32:10 <hpc> tomeo: ^
16:32:17 <tomeo> hpc: thanks, Ill give that a go :)
16:35:04 <tomeo> oh, I can't nest where statements? like where foo = 1 + opt where opt = 2
16:35:11 <tomeo> or am I just using the wrong syntax?
16:35:34 <rwbarton> you can do exactly that
16:35:40 <rwbarton> however in this case you don't need to
16:35:47 <rwbarton> where foo = 1 + opt
16:35:49 <rwbarton>       opt = 2
16:35:59 <tomeo> I don't need the second where?
16:36:24 <rwbarton> you can put several bindings in a where block
16:36:25 <hpc> you actually get more power out of not having the extra "where"
16:36:38 <monochrom> you can nest where statements
16:36:40 <tomeo> I like power
16:36:42 <rwbarton> if you use a second where, it must be more indented than "foo"
16:36:50 <monochrom> or, I guess I mean: I can
16:37:00 <tomeo> monochrom: I can soon too I hope :D
16:37:03 <rwbarton> nested where is useful in another situation... when foo is a function, and opt depends on its arguments
16:37:13 <monochrom> > let {x=y where y=z where z=4} in x
16:37:15 <lambdabot>   4
16:37:18 <monochrom> works for me
16:37:19 <tomeo> it compiles!
16:37:26 <elliott> rwbarton: also useful for writing unsafeCoerce I hear
16:37:39 <hpc> > let {x=y where z=4 where y=z} in x
16:37:40 <lambdabot>   y
16:37:53 <hpc> > let {x=y; z=4; y=z} in x
16:37:54 <lambdabot>   4
16:38:10 <hpc> (that second example should have warned about y not being in scope)
16:38:24 <hpc> (("first" being monochrom's))
16:38:44 <monochrom> @type y
16:38:45 <lambdabot> Expr
16:38:48 <monochrom> that is y
16:38:52 <monochrom> (pun!)
16:39:03 <hpc> > y y
16:39:05 <lambdabot>   The function `Debug.SimpleReflect.Vars.y'
16:39:05 <lambdabot>  is applied to one argument,
16:39:05 <lambdabot>  but...
16:39:58 <tomboy64> eva
17:03:03 <shachaf> andsens: Did you figure it out?
17:03:17 <andsens> yes, I think so shachaf
17:03:44 <andsens> It's my master thesis I'm working on.
17:03:59 <andsens> It's pretty cool actually (in my opinion :-))
17:04:23 <andsens> I parse html templates written with mustache and generate jQuery selectors for those variables
17:04:50 <andsens> Meaning, once the html is sent to the client, you can run some javascript and retrieve all the original values
17:11:33 <LAMMJohnson> Hey, guys. I've been Hoogling around and I can't seem to find the correct module for expanding raw filepaths.
17:11:55 <LAMMJohnson> e.g. "~/whatever.txt" to "/home/johnson/whatever.txt"
17:12:19 <LAMMJohnson> Can anyone advise? Hoogle-fu skill improvement suggestions welcome.
17:13:43 <LAMMJohnson> Or, rather, I seem to have found it in System.Posix.ByteString but it seems to be limited to POSIX systems.
17:14:00 <LAMMJohnson> Which I'm personally fine with, but curious as to whether there's a platform agnostic way.
17:14:38 <shachaf> What would it do on other platforms?
17:15:09 <LAMMJohnson> I have no idea how Windows users cope with such things. Windows provides users with home directories, right?
17:16:15 <shachaf> Not really, in the sense of "~".
17:16:26 <LAMMJohnson> How awful.
17:17:20 <arbn> Windows isn't really intended as a multi-user system. Multiple user support is kind of tacked on.
17:18:37 <Nereid> ~ isn't a thing in windows
17:19:15 <Nereid> there is a %HOME% environment variable though
17:19:22 <geekosaur> windows has various functional directories, but the notion of an overarching user homedir is foreign, yeh
17:19:23 <typoclass> LAMMJohnson: well, "~" is a thing that shells do. other programs might try to mimick it a little, but that's all
17:19:29 <Nereid> oh no there isn't.
17:19:37 <Nereid> there's something though
17:19:41 <shachaf> There are several things.
17:19:51 <Nereid> yes
17:20:10 <shachaf> Including C:\{Documents and Settings,Users}\yourname, that \Application Data, that \My Documents, and other things.
17:20:20 <Nereid> oh it's split up as %HOMEDRIVE% and %HOMEPATH%. and yeah there are those.
17:20:29 <shachaf> I think it distinguishes all the different places that files can go, which seems reasonable to me.
17:20:29 <koala_man> arbn: at least it was before Windows NT
17:20:31 <geekosaur> (there is for example often a directory that contains the various user functional directories; it is however not really considered part of the user configuration but more an administrative organization
17:20:32 <typoclass> LAMMJohnson: try this http://www.haskell.org/ghc/docs/latest/html/libraries/directory-1.2.0.0/System-Directory.html , in particular getHomeDirectory
17:20:56 <typoclass> arbn: 1994 called, they want their prejudices back ...
17:21:13 <LAMMJohnson> typoclass: Ah, that's excellent. Exactly what I was looking for.
17:21:13 <jojo_> Beginner's question: Can operators in Haskell only be defined in typeclasses?
17:21:21 <sipa> jojo_: no
17:21:35 <Philippa_> > let a ++++ b = a * b in 1 ++++ 2
17:21:37 <lambdabot>   2
17:22:02 <sipa> let (~%&!*) = (+) in 5 ~%&!* 3
17:22:03 <arbn> typoclass: Oh? I haven't messed with Windows too much. I guess I didn't dig deep enough to see the user-specific permissions and stuff. My apologies.
17:22:06 <sipa> > let (~%&!*) = (+) in 5 ~%&!* 3
17:22:08 <lambdabot>   8
17:22:32 <Philippa_> on an abstract level, operators are just identifiers - "operator overloading" isn't really a concept in haskell
17:22:37 <elliott> sipa: isn't that a lens operator
17:22:40 <Nereid> haha
17:22:46 <kpwn> hi
17:22:46 <jojo_> I see. Can they be defined just as like a normal function would, outside of a typeclass?
17:22:50 <Nereid> yes
17:22:52 <typoclass> jojo_: nope, they are more or less regular functions. the only difference is, if it's made up of symbols (not letters), it's infix by default. that means the function name (operator name) is written between the two arguments
17:22:53 <shachaf> arbn: As far as I know Windows handles "user-specific permissions and stuff" much better than UNIX.
17:23:04 <Nereid> operators are just functions with symbol names
17:23:08 <shachaf> Anyway, this isn't the place or time. I don't use Windows anyway so I don't know.
17:23:11 <Nereid> (and different syntax)
17:23:13 <Philippa_> arbn: You would've had a point for the 9x branch. Not so much the NT family
17:24:51 <koala_man> http://oi41.tinypic.com/2mdp9bp.jpg demonstrates the tacked on user concept in win9x
17:27:25 <Nereid> haha :)
17:29:06 <shachaf> Good old animated GIFs that end in .jpg
17:29:31 <koala_man> shachaf: the mime type clearly states image/gif
17:30:19 <shachaf> My browser clearly requested a jpg.
17:31:16 <typoclass> koala_man: i hear that ~17 years ago, in stark contrast to windows, linux was absolutely perfect and no fiddling was necessary at all
17:32:16 <shachaf> This Windows/UNIX discussion was offtopic since it started.
17:32:36 <koala_man> typoclass: yes, the difference is stunning.
17:32:41 <LAMMJohnson> Sorry, guys. Should have known better than to ask about cross-platform stuff on IRC.
17:33:19 <Nereid> no it's not your fault, LAMMJohnson
17:33:26 <typoclass> LAMMJohnson: your question was perfectly okay, don't worry
17:33:28 <shachaf> LAMMJohnson: You asked a reasonable question. I'd just prefer that reasonable questions wouldn't cause flame wars. :-)
17:33:31 <Nereid> :p
17:34:40 <arbn> LAMMJohnson: Hmm? There was no flaming. I was incorrect, and people were prompt to inform me. No harm.
17:35:22 <Nereid> if only everyone was like you, arbn :)
17:36:37 <sipa> no harm? what will become of you if you keep letting people change your mind through reason and objective truths?
17:36:45 <sipa> grow a spine!
17:37:13 <LAMMJohnson> Hah. Don't worry, I wasn't genuinely thinking I'd caused problems. Just being a bit light-hearted and flippant about the nature of discussion on IRC.
17:37:31 <LAMMJohnson> I might swing by ##c a bit later and ask a C++ question.
17:37:43 <andsens> koala_man: http://farm1.static.flickr.com/250/454344324_29ab19ef28.jpg
17:38:00 <arbn> LAMMJohnson: You should go to #vim and ask for help with an Emacs mode.
17:38:05 <andsens> another windows quirk
17:38:13 <LAMMJohnson> viper-mode
17:38:16 <sipa> LAMMJohnson: go claim that c is the same as c++, and if they argue, show them a program that tests (c==c++) :p
17:38:48 <LAMMJohnson> "C is a subset of C++ so why would you ever *not* use C++?" is guaranteed kickban.
17:39:23 <LAMMJohnson> I actually use viper-mode in Emacs. I'm hated by both sides as a traitor.
17:39:31 <Nereid> traitor!
17:40:16 <koala_man> I don't hate. I just think it's sad that you feel you have to live a lie
17:40:22 <LAMMJohnson> Harsh but fair.
17:40:52 <LAMMJohnson> I like Emacs as a platform for scripting and extending and I think vi keys are the most efficient way to edit text.
17:41:40 <Nereid> fair
17:41:42 <andsens> LammJohnson: Ever tried SublimeText? It's not terminal, but has some awesom features + vi mode
17:41:48 <sipa> nothing beats EDLIN.COM
17:42:15 <LAMMJohnson> andsens: I am aware of it. I'd rather use FOSS when it's available, though, and ST2 doesn't seem to offer much beyond that.
17:42:29 <LAMMJohnson> And I do edit over tramp or via ssh occasionally.
17:42:49 <andsens> Yeah, the closed source thing sucks. But I would argue that it has loads of stuff to offer.
17:42:58 <andsens> But not nearly as much as vim or emacs, true
17:43:34 <LAMMJohnson> I'm not sure I could even use another editor now without feeling hopelessly constrained.
17:43:49 <LAMMJohnson> haskell-mode in Emacs is very nice, too.
17:44:02 <andsens> I will never ever go away from multiselect. That is a killer feature
17:44:02 <arbn> I switched to Emacs for haskell-mode, yeah.
17:44:48 <LAMMJohnson> andsens: I've heard about it but never used it. What would you even use it for?
17:45:58 <Philippa_> is there a version of classes like MonadState that plays nice when someone wants to treat it as an Applicative only?
17:46:04 <andsens> lots of stuff. When you have nicely aligned code you can simply press cmd+alt+up/down, to mark the next line in the same column, the you write on multiple lines at once.
17:46:12 <Philippa_> (which is to say: won't dump an unwanted Monad constraint on me)
17:46:19 <Cale> koala_man: heh, I remember discovering that one myself
17:46:47 <andsens> Multiselect 5 areas copy and highlight 5 new areas. The stuff will be pasted into each new selection the way you expect it to
17:47:38 <andsens> cmd+d mark the next occurence of the highlighted word (great for refactoring)
17:48:05 <andsens> oh, and you got the minimap
17:48:13 <LAMMJohnson> Hrm. Different ways fo working, I guess.
17:48:20 <LAMMJohnson> Do you use the mouse a lot when editing?
17:48:22 <andsens> probably
17:49:08 <andsens> I didn't use to, but I realized that I will always have to use the mouse no matter how hard I try, so I went all in and customized the hell out of it.
17:49:12 <andsens> So yes, now I do
17:49:18 <Cale> I use vim, but I too use the mouse quite a bit.
17:49:56 <LAMMJohnson> It always just felt totally natural to me to just slowly use the mouse less and less and less until I wasn't using it at all.
17:50:13 <LAMMJohnson> But lots of people say the same thing.
17:50:30 <LAMMJohnson> I know quite a few Vim and Emacs users who make considerable use of the mouse.
17:50:54 <LAMMJohnson> And I know yet more who struggle to work efficiently because not using the mouse is a point of pride.
17:50:55 <andsens> I get that. But I actually use the web while writing code (dual screen), so it's hard not to use the mouse with that workflow
17:51:13 <Nereid> I use it mostly just to move the cursor around.
17:51:27 <andsens> that's a valid use of a mouse
17:51:46 <andsens> Oh! The cursor! I thought you meant the mouse cursor. haha
17:51:51 <Nereid> haha
17:52:01 <andsens> d'uuh
17:53:48 <niteria> is there a haskell package with nicely written typechecker somewhere?
17:54:05 <niteria> preferably for imperative language
17:54:12 <andsens> mmh, this is nice. I recently set my cursor to stop blinking and be a little wider. So much less eyestrain
17:55:09 <niteria> recently I had to add source position to my lookupVar function to make error reporting better and I think there must be a better way
17:55:46 <andsens> niteria: what do you use for parsing?
17:56:16 <niteria> parsec, but I've already finished that
17:56:38 <niteria> I have a nice AST parametrized with annotation
17:57:01 <andsens> why don't you just add the SourcePos to your Records?
17:57:11 <niteria> which Records?
17:57:24 <andsens> Well, the ones that make up your AST
17:57:30 <niteria> my AST has SourcePos
17:57:50 <andsens> oh, I think I misunderstood the thing about lookupVar then
17:58:05 <niteria> but say I want to check if a var is declared, I use lookupVar for that
17:58:21 <niteria> lookupVar :: env -> id -> Either Type Error
17:58:24 <andsens> ah, ok. I get it now.
17:58:51 <andsens> hm, haven't had to do that stuff before, can't really help you. sry
17:58:56 <kristof> Isn't ":" the same as "++"?
17:59:02 <copumpkin> no
17:59:03 <hpc> :t (:)
17:59:04 <lambdabot> a -> [a] -> [a]
17:59:05 <andsens> kristof: not at all
17:59:11 <hpc> :t (Prelude.++)
17:59:12 <lambdabot> [a] -> [a] -> [a]
17:59:17 <niteria> a : b == [a] ++ b
17:59:18 <andsens> : prepends a single element
17:59:19 <kristof> Hmm.
17:59:20 <hpc> @src (++)
17:59:20 <lambdabot> []     ++ ys = ys
17:59:20 <lambdabot> (x:xs) ++ ys = x : (xs ++ ys)
17:59:20 <lambdabot> -- OR
17:59:20 <lambdabot> xs ++ ys = foldr (:) ys xs
17:59:30 <kristof> I can't do xs:x, can I?
17:59:33 <hpc> kristof: (++) is defined in terms of (:)
17:59:34 <andsens> nope
17:59:36 <arthurdent> is it possible to make a "binary" data type with just 0 and 1 as options?
17:59:41 <hpc> and the list type itself is defined in terms of (:)
17:59:47 <hpc> (and [])
17:59:50 <andsens> arthurdent: you mean Bool?
17:59:55 <kristof> So if I'm appending something it's better to use ++?
17:59:58 <arthurdent> andsens: yes but with 0 and 1 instead of True and False
18:00:06 <andsens> kristof: you can't use anything else
18:00:19 <shachaf> kristof: It's not possible to append something with (:).
18:00:27 <shachaf> It's usually better not to append something at all, though.
18:00:29 <kristof> Questions answered. Thanks!
18:00:33 <kristof> Oh, but, why is that?
18:00:41 <andsens> arthurdent: If I remember correctly your instances cannot begin with a digit
18:00:42 <niteria> andsens: data Bin = One | Zero
18:00:51 <Nereid> appending to the end of a list takes time proportional to the length of the list
18:00:52 <shachaf> kristof: It's inefficient, if nothing else.
18:01:07 <andsens> You have to copy the entire list, kristof
18:01:09 <hpc> kristof: doing n appends is going to end up being O(n^2)
18:01:12 <hpc> or something along those lines
18:01:27 <kristof> And why is prepending so special?
18:01:36 <shachaf> hpc: Assuming n = the length of the list. :-)
18:01:41 <elliott> kristof:because that's how the list structure is defined
18:01:47 <kristof> Hm. Ok.
18:01:50 <andsens> kristof: because you simply create a new element and point that element to the list you are prepending to
18:01:56 <kristof> Oh!
18:01:58 <hpc> > (1 : (2 : (3 : [])))
18:01:59 <lambdabot>   [1,2,3]
18:02:03 <hpc> > 0 : (1 : (2 : (3 : [])))
18:02:04 <elliott> data List a = Nil | Cons a (List a) -- you can think of [a] as this
18:02:05 <lambdabot>   [0,1,2,3]
18:02:07 <elliott> but Nil is [] and Cons is (:)
18:02:12 <kristof> But why can't the list be pointed toward the element?
18:02:13 <elliott> (in fact that is exactly what it is :))
18:02:24 <andsens> kristof: haskell never changes existing values
18:02:35 <Nereid> kristof: there is something along those lines, called a difference list
18:02:41 <kristof> I see. Okay, *now* my questions are answered.
18:02:49 <Nereid> which has O(1) append and such
18:02:55 <hpc> difference lists are another whole bag of questions ;)
18:02:58 <Nereid> true
18:03:01 <niteria> is there guard for Either?
18:03:09 <Nereid> niteria: what do you mean?
18:03:12 <hpc> :t guard
18:03:13 <lambdabot> MonadPlus m => Bool -> m ()
18:03:16 <hpc> niteria: should be
18:03:20 <Nereid> oh
18:03:23 <hpc> er
18:03:24 <Nereid> that guard
18:03:32 <hpc> yeah, should be
18:03:32 <Nereid> ?
18:03:35 <niteria> what's mzero for Either?
18:03:48 <hpc> niteria: presumably something along the lines of (fail "mzero")
18:03:58 <Nereid> @instances MonadPlus
18:03:59 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
18:04:02 <Nereid> hmm
18:04:12 <hpc> what lambdabot doesn't mention is the context on e
18:04:15 <Nereid> ah
18:04:51 <Nereid> it would have to be a monoid or so?
18:05:08 <niteria> > mzero :: Either (Integer, String) ()
18:05:09 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error
18:05:09 <lambdabot>                     (GHC.I...
18:05:12 <Nereid> :t mzero :: Either ?a ?b
18:05:13 <lambdabot> parse error on input `?a'
18:05:13 <hpc> i think Exception
18:05:15 <Nereid> oops duh
18:05:24 <Nereid> mzero :: Either () ()
18:05:26 <Nereid> > mzero :: Either () ()
18:05:27 <lambdabot>   No instance for (Control.Monad.Trans.Error.Error ())
18:05:28 <lambdabot>    arising from a use ...
18:05:28 <hpc> oh
18:05:29 <hpc> http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-Error-Class.html#t:Error
18:05:31 <Nereid> oh, Error.
18:05:32 <hpc> Error
18:05:35 <monochrom> e is an instance of Error. it means that there is a method of type String -> e
18:05:36 <shachaf> Error
18:05:46 <andsens> Error?
18:05:49 <Nereid> Error.
18:05:59 <hpc> > fix "Error "++
18:06:00 <lambdabot>   <hint>:1:15: parse error (possibly incorrect indentation)
18:06:05 <hpc> > fix ("Error "++)
18:06:06 <lambdabot>   "Error Error Error Error Error Error Error Error Error Error Error Error Er...
18:06:17 <andsens> hahaha
18:06:21 <Nereid> > fix error
18:06:22 <charliesome> :t fix
18:06:22 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
18:06:23 <lambdabot> (a -> a) -> a
18:06:38 <andsens> turtles all the way down
18:06:39 <niteria> maybe I actuall don't wan't Either, maybe ErrorT does what I want
18:07:33 <charliesome> > fix id
18:07:37 <lambdabot>   mueval-core: Time limit exceeded
18:07:53 <charliesome> lol wat
18:08:15 <niteria> I want to be able to say guard (a == b) (line, "a != b")
18:09:04 <monochrom> that is not what guard does
18:10:45 <niteria> I want haskell'ish way of saying if (a == b) then return false
18:10:56 <sclv> a/=b
18:11:00 <sclv> ?ty a/=b
18:11:01 <lambdabot> Bool
18:11:12 <sclv> ?ty (/=)
18:11:13 <lambdabot> Eq a => a -> a -> Bool
18:11:18 <niteria> in same kind of error monad
18:12:11 <niteria> :t error
18:12:12 <lambdabot> [Char] -> a
18:12:24 <niteria> :t fail
18:12:25 <lambdabot> Monad m => String -> m a
18:13:01 <monochrom> unless (a==b) (throwError (strMsg "line 45: a!=b"))
18:13:02 <Nereid> why not use an error monad?
18:13:06 <Nereid> :t throwError
18:13:07 <lambdabot> MonadError e m => e -> m a
18:13:25 <Nereid> yeah like ErrorT
18:13:37 <monochrom> but I have no reason to believe that this answers your real question, since there is no real question
18:15:23 <niteria> I can formulate a question as: is Either a good mechanism for error reporting
18:15:43 <monochrom> that is vague and ambiguous. "good"? but ok. yes.
18:17:10 <Nereid> in any case Control.Monad.Error has some handy things regardless of whether you use Either or ErrorT or ...
18:17:54 <niteria> I've just figured out I sometimes need to catch errors
18:17:54 <Nereid> > throwError "hi" :: Either String ()
18:17:56 <lambdabot>   Left "hi"
18:18:17 <Nereid> :t catchError
18:18:18 <lambdabot> MonadError e m => m a -> (e -> m a) -> m a
18:18:22 <niteria> and I can't do that easily with Either, right?
18:18:27 <Nereid> sure you can
18:18:36 <niteria> I mean I can pattern match
18:18:36 <monochrom> it is easy
18:18:46 <monochrom> at least IMO
18:18:54 <Nereid> > catchError (Left "hi") (\e -> return ("error: " ++ e))
18:18:56 <lambdabot>   Right "error: hi"
18:19:58 <niteria> I'll go with MonadError / ErrorT
18:20:08 <Nereid> remember, Either String is an instance of MonadError
18:20:20 <Nereid> well, Either e for any instance e of Error
18:20:33 <Nereid> so you can still use the MonadError stuff for it.
18:20:44 <niteria> oh, cool
18:20:53 <Nereid> ErrorT is the corresponding monad transformer.
18:22:51 <Nereid> :t (`catchError` Left)
18:22:52 <lambdabot> Error e => Either e a -> Either e a
18:23:00 <Nereid> isn't that just id
18:23:45 <hpaste> node pasted ‚Äúcalcul‚Äù at http://hpaste.org/78446
18:24:12 <niteria> :t fail
18:24:13 <lambdabot> Monad m => String -> m a
18:24:19 <node> hello guys. I m implementing RPN calculator. just for now I have a stack array of Double which looks like this http://hpaste.org/78446. Wat to find a way to have stack with Integer
18:24:34 <niteria> so throwError is more general fail
18:24:46 <Ralith> niteria: [Either Double Integer]
18:24:49 <Ralith> er
18:24:50 <Ralith> node:
18:24:59 <Ralith> assuming you want them intermixed
18:25:44 <niteria> @source fail :: Either a
18:25:44 <lambdabot> fail :: Either a not available
18:26:05 <niteria> @source throwError :: Either a
18:26:05 <lambdabot> throwError :: Either a not available
18:26:48 <node> Ralith: gonna be cool if it works, cause i want to switch modes between int and float mode and perform say modulus on intergers only and division on floats and in
18:27:38 <node> * on floats and integers
18:27:57 <Ralith> node: so you don't want them intermixed?
18:29:22 <niteria> is there a way to find what Either is an instance of?
18:29:55 <charliesome> case e of; Left a -> ‚Ä¶; Right a -> ...
18:30:02 <niteria> some instances are in Data.Either, some somewhere else
18:30:13 <node> Ralith: i think no. but will Either work for my case?
18:30:40 <hpaste> andsens pasted ‚Äúclunky‚Äù at http://hpaste.org/78447
18:30:54 <andsens> Is there a snappier way to do what I just pasted?
18:31:07 <ebpanic> is there an equivalent function to guard that can be applied to Either or Maybe?..
18:31:28 <andsens> ebpanic, you just pattern match
18:31:47 <Ralith> node: well, then you might want Either [Double] [Integer]
18:31:57 <ebpanic> andsens, how do you mean? I'm new to Haskell..
18:32:16 <node> Ralith: ok, gonna try
18:32:52 <ebpanic> andsens, is it correct to say that guard is like if/else, but for functions?
18:33:22 <monochrom> it is incorrect
18:33:48 <andsens> yep, that is not it
18:33:50 <monochrom> "when" and "unless" are closer to if/else
18:33:59 <andsens> trying to find a good pattern matching example.
18:34:10 <andsens> if/else is closest I would say
18:34:14 <andsens> :-D
18:34:50 <niteria> :t when
18:34:52 <lambdabot> Monad m => Bool -> m () -> m ()
18:35:56 <niteria> :t when (False) (throwError
18:35:57 <lambdabot> parse error (possibly incorrect indentation)
18:36:03 <niteria> :t when (False) (throwError "err")
18:36:04 <lambdabot> MonadError [Char] m => m ()
18:36:17 <Nereid> :t when ?b (throwError ?e)
18:36:19 <lambdabot> (?b::Bool, ?e::e, MonadError e m) => m ()
18:36:53 <niteria> ?e::e ?
18:36:53 <lambdabot> Unknown command, try @list
18:36:59 <ebpanic> thanks guys! I think that points me in the right direction...
18:37:00 <Nereid> -XImplicitParams
18:37:48 <donri> guard is like a guard!
18:37:54 <Nereid> indeed
18:38:06 <Nereid> > [ x | x <- [1..], even x ]
18:38:07 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
18:38:13 <Nereid> > do {x <- [1..]; guard (even x); return x}
18:38:15 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
18:38:43 <donri> monad comprehensions even translate to that
18:38:48 <Nereid> indeed
18:39:08 <node> Ralith: ok, then i initiallise my state for calculator how can i use Either to initialise my stack. just for now i have this code: http://hpaste.org/78448
18:40:05 <Ralith> :t Left
18:40:06 <lambdabot> a -> Either a b
18:40:10 <Ralith> :t Right
18:40:12 <lambdabot> b -> Either a b
18:40:38 <Nereid> :t either Left Right
18:40:39 <lambdabot> Either a b -> Either a b
18:40:39 <donri> hey doesn't 'when' generalize to monoid? when x a = if x then a else mempty
18:40:40 <monochrom> "use Either to initialise your stack"? why do you use Either for a stack at all?
18:41:03 <Nereid> donri: sure. m () is a monoid for any monad m
18:41:44 <monochrom> "stack = []" looks like already initialising the stack
18:41:58 <donri> @hoogle Monoid m => Bool -> m -> m
18:41:59 <lambdabot> Control.Exception.Base assert :: Bool -> a -> a
18:41:59 <lambdabot> Control.Exception assert :: Bool -> a -> a
18:41:59 <lambdabot> Control.OldException assert :: Bool -> a -> a
18:42:03 <node> monochrom: i want float mode and integre mode for my calculator. stack is in a data structure for state of calculator
18:42:24 <Nereid> @let bool f t b = if b then t else f
18:42:26 <lambdabot>  Defined.
18:42:31 <Nereid> :t flip (bool mempty)
18:42:32 <lambdabot> Monoid c => Bool -> c -> c
18:42:33 <niteria> do people use Implicit parameters? Are they the same concept as Scala's implicits?
18:42:38 <node> node: i have radio button to switch between them
18:42:53 <donri> Nereid: just a bit surprised it doesn't seem to be defined anywhere
18:43:31 <Nereid> where would you use it?
18:43:46 <aristid> :t bool
18:43:46 <donri> the argument order of 'bool' seemed odd to me but i guess it's for symmetry with 'maybe'?
18:43:47 <lambdabot> t -> t -> Bool -> t
18:43:52 <Nereid> yes
18:44:02 <Nereid> bool False True = id
18:44:30 <Nereid> also I think it's more "useful" in this order
18:44:57 <donri> Nereid: isn't that a bit like asking "where would you use 'when'"
18:45:08 <Nereid> yes, but people use when.
18:45:16 <donri> because it's defined ;)
18:45:19 <Nereid> heh
18:45:33 <monochrom> @type if'
18:45:34 <lambdabot>     Not in scope: if'
18:45:34 <lambdabot>     Perhaps you meant f' (imported from Debug.SimpleReflect)
18:45:39 <Nereid> it's defined in http://hackage.haskell.org/packages/archive/cond/latest/doc/html/Control-Conditional.html
18:45:46 <Nereid> (?<>) :: (ToBool bool, Monoid a) => bool -> a -> a
18:46:01 <monochrom> haha, Control.Conditional. why not Data.Bool?
18:46:06 <Nereid> heh
18:46:15 <Nereid> well it defines a ToBool class, so it's a bit more general
18:46:39 <donri> ToBool is begging to be abused ^_^
18:46:43 <Nereid> too bad it doesn't have ToBool instances for Maybe or Either
18:47:25 <andsens> dang. It's 03:46 here in DK, I think I should sleep now
18:47:37 <andsens> good night
18:47:42 <andsens> and thanks for all the help guys!
18:48:46 <monochrom> if I define ToUnit class (class ToUnit t where tu :: t -> ()) and the utility function "always :: () -> t -> t", is that going to be called Control.Unconditional? :)
18:49:00 <node> Ralith: where will i use Left | Right for integer or double stack. i m bit lost here :\
18:49:02 <Nereid> haha, t <| p |> f
18:49:13 <niteria> wouldn't it make sense to use implicits to pass Env?
18:49:49 <Nereid> I would prefer explicit passing
18:49:56 <donri> hey isn't (?) in cond the same as (&) in lens
18:49:57 <Nereid> monochrom: haha, do it :)
18:50:05 <edwardk> cond?
18:50:18 <donri> edwardk: http://hackage.haskell.org/packages/archive/cond/latest/doc/html/Control-Conditional.html#g:7
18:50:20 <Nereid> donri: different fixity though
18:50:28 <Nereid> well, no fixity declaration
18:50:32 <Nereid> oh wait
18:50:33 <donri> heh
18:50:34 <Nereid> it's infixr 9
18:50:40 <Nereid> what's & ?
18:51:00 <donri> no it√§s infixr 0
18:51:06 <Nereid> oh I'm blind.
18:51:11 <Nereid> meanwhile & is infixl 1
18:51:25 <edwardk> it has the wrong fixity. infixr 0 ?; infixl 1 &
18:54:19 <niteria> I have a [(,,,,,,,,)], I want to query it with queries like give me 2nd and 3rd elem of tuple where 5th elem satisifies p
18:54:38 <niteria> what would be a good data structure for that
18:54:48 <niteria> I don't care about performance
18:54:57 <johnw> i would use lenses for that
18:54:59 <Ralith> node: what is the type of your stack?
18:54:59 <niteria> just the ease of use
18:55:28 <johnw> if x^._5 then Just (x^._2,x^._3) else Nothing
18:55:49 <niteria> johnw: what package?
18:55:51 <node> Ralith: just now it is implemented as an array of Double
18:55:55 <johnw> well, call "p (x^._5)"
18:55:56 <edwardk> niteria: 'lens'
18:56:08 <donri> @hackage lens
18:56:08 <lambdabot> http://hackage.haskell.org/package/lens
18:56:39 <edwardk> niteria: https://github.com/ekmett/lens#examples is a fairly gentle crash course in how to use it
18:56:48 <Nereid> but why do you have such large tuples?
18:57:04 <Nereid> (I rarely even see people use 3-tuples)
18:57:04 <shapr> tsou: oh hai
18:57:15 <johnw> i want a 57-tuple
18:57:22 <Nereid> you can make one
18:57:42 <aristid> johnw: no you don't want it
18:58:09 <johnw> data Heinz a = (a,a,a...)
18:58:16 <Nereid> lol
18:58:46 <niteria> I have a table of operators: (opname, opsymbol, associativity, precedence)
18:58:52 <Nereid> oh, I was wondering what happened to your github but it's back now.
18:58:59 <Nereid> niteria: use a record for that :p
18:59:01 <niteria> and type
18:59:17 <Nereid> johnw's github
18:59:30 <johnw> huh, it disappeared?
18:59:41 <Nereid> it was disable for spam or something but it's back now
19:00:47 <johnw> spam?  what, like my commits were trying to sell viarga?
19:00:52 * shapr blinks
19:00:54 <Nereid> I have no idea
19:01:45 <tsou> shapr: hej! ;)
19:02:19 <shapr> hah, salut!
19:02:23 <niteria> records are better that tuples, but I'd still need to write map (\x -> (opname x, opsymbol x) $ filter (\x -> precedence x > 7) ops, a lot
19:03:51 <Nereid> sure, or map (opname &&& opsymbol) $ filter ((> 7) . precedence) ops
19:04:10 <Nereid> don't think you can really do much better?
19:04:14 <niteria> :t (&&&)
19:04:15 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
19:04:57 <niteria> :t ?a &&& ?b &&& ?c
19:04:58 <lambdabot> (?a::a b c, ?b::a b c1, ?c::a b c', Arrow a) => a b (c, (c1, c'))
19:07:38 <Mathnerd314_> that reminds me, what happened to (~>)? is it gone forever?
19:07:46 <niteria> lenses are pretty cool
19:08:07 <edwardk> niteria: =)
19:09:20 <johnw> niteria: edwardk is the author of that lens library :)
19:10:04 <niteria> that hierarchy looks scary
19:10:31 <edwardk> niteria: the types in lens are scary, but the api itself is designed to be pretty easy to use
19:11:11 <edwardk> basically if you grab for any lens-like thing you should be able to compose it with any lens-like thing with (.), and if you go to use it with one of the combinators it should just do the right thing.
19:11:25 <edwardk> > ("hello","world") & _2 .~ 5
19:11:27 <lambdabot>   ("hello",5)
19:11:37 <edwardk> > ("hello","world") & both .~ 5
19:11:39 <lambdabot>   (5,5)
19:11:41 <node> say i have stack of type Either [Double] [Integer] how can i initlise stack to be of type [Integer] ?
19:11:45 <edwardk> > ("hello","world") & _2 %~ length
19:11:47 <lambdabot>   ("hello",5)
19:11:53 <edwardk> > ("hello","world") & both %~ length
19:11:54 <niteria> node: Right []
19:11:55 <lambdabot>   (5,5)
19:13:02 <m3ga> :t formatTime
19:13:03 <lambdabot> Not in scope: `formatTime'
19:14:03 <niteria> lenses remind me of apl
19:15:20 <m3ga> the formatTime function http://hackage.haskell.org/packages/archive/time/latest/doc/html/Data-Time-Format.html#v:formatTime take a TimeLocale parameter and TimeLocal is supplied by the old-locale package. is the a new locale package i should be using instead?
19:15:28 <node> niteria: (Right stack) = [] doesn't work
19:15:31 <Nereid> Mathnerd314_: yep, it's now a type *variable* now
19:15:38 <edwardk> one of the main issue with APL is that extensions to APL didn't feel like APL. fortunately we don't have that issue here. that said, you don't have to work with symbols like i did there.
19:15:40 <Nereid> now now
19:15:50 <edwardk> > set both 5 ("hello","world")
19:15:52 <lambdabot>   (5,5)
19:15:59 <Nereid> er no
19:16:00 <Nereid> the thing that's not a variable
19:16:20 <Nereid> node: obviously ;)
19:19:06 <Mathnerd314_> Nereid: right, (~>) is apparently considered to be a type constructor. I'm wondering if there's any way to write an infix type variable now
19:19:40 <shachaf> Mathnerd314_: yes, with `backticks`
19:19:48 <shachaf> But not for a symbol.
19:20:37 <Mathnerd314_> ah, so e.g. (Category c) => a `c` b works
19:20:40 <node> Nereid: will stack = Right []  work?
19:21:08 <Nereid> node: what's the type of stack?
19:21:46 <node> Nereid: say Integer
19:21:56 <Nereid> your stack is an Integer?
19:22:24 <node> Nereid: list of integers
19:22:47 <Nereid> so you wrote stack :: [Integer]
19:22:53 <Nereid> ?
19:23:28 <Nereid> you could then just set it to the empty list. stack = []
19:24:15 <node> Nereid: no no. i made it stack :: Either [Double] [Integer] and then initialised it stack = Right []
19:24:28 <Nereid> ok
19:24:40 <Nereid> (you know that then you can't mix doubles and integers)
19:26:40 <node> Nereid: yeah. well, if i have a list of integers i can't add double
19:26:52 <Nereid> maybe the stack type should be a parameter then
19:27:19 <Nereid> (what if you later wanted to add support for Rational or CReal or ...)
19:28:24 <node> Nereid: ok. if it is possible how to make type a parameter?
19:28:52 <Nereid> show some more code
19:29:56 <node> ok, just a min
19:33:05 <node> Nereid: http://hpaste.org/78450
19:33:25 <node> Nereid: some code i have omitted which deals with gui
19:35:35 <Nereid> well,
19:35:50 <Nereid> data CalcState a = CalcState { ..., stack :: [a], ... }
19:35:54 <Nereid> puts in a type parameter.
19:36:07 <Nereid> so CalcState Double would give you the old thing.
19:36:46 * hackagebot sbv 2.8 - SMT Based Verification: Symbolic Haskell theorem prover using SMT solving.  http://hackage.haskell.org/package/sbv-2.8 (LeventErkok)
19:37:52 <node> Nereid: ok, a type is like generics
19:38:10 <Nereid> and a monad is like a burrito
19:39:40 <sclv> time flies like an arrow
19:39:49 <simpson> Fruit flies like a banana.
19:39:54 <Nereid> :)
19:40:01 <node> Nereid: but when i want to change state, how can i change stack type?
19:40:03 <shachaf> @quote monochrom flies.like
19:40:03 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
19:40:06 <sclv> simpson: drat, beat me to it :-P
19:40:08 <shachaf> @quote monochrom flies.like
19:40:08 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
19:40:10 <shachaf> @quote monochrom flies.like
19:40:10 <lambdabot> monochrom says: Time flies like an Arrow. Space leaks like a Monad.
19:40:11 <shachaf> Hmm.
19:40:18 <Nereid> you can't "change" the stack type.
19:40:22 <Nereid> well
19:40:26 <shachaf> @quote flies.like.a.banana
19:40:26 <lambdabot> monochrom says: Time flies like an arrow.  Fruit flies like a banana.  Syntax rules like a macro.
19:40:29 <Nereid> any more than you can't change the stack, I guess.
19:40:49 <Nereid> oh right. you can't change the type of something in an IORef.
19:41:06 <node> Nereid: well yes, is is [a] type. i meant how to make it [Integer] ?
19:41:21 <Nereid> you write CalcState Integer where you used CalcState before.
19:41:50 <Nereid> would be nice if you separated the calculator code from the gui code I guess.
19:42:31 <node> Nereid: well the gui is in xml
19:43:14 <Nereid> I mean it's not the button's job to fiddle with the stack directly.
19:59:47 <node> then i make stack :: [a]  interpreter thows not in scope type variable a
20:50:34 <latermuse> I had a dream last night where I was a monadic transformer computing my way through a bunch of data.
20:51:33 <latermuse> It doesnt make a whole lot of sense now, but it was quite a lucid experience.
20:51:44 <ParahSailin> dreams form a monoid on waking
20:54:00 <shapr> latermuse: When I first learned monads I dreamed the whole world was structured that way and I was using unsafePerformIO to see five seconds into the future.
20:57:59 <arbn> ParahSailin: Really? How?
20:59:38 <arbn> A dream isn't a transformation from waking to waking, but rather from sleeping to waking.
21:03:09 <latermuse> shapr: If we are living in the singularity now, its possible that our world was structured on monads.
21:09:49 <hpaste> ‚ÄúJonathan Fischoff‚Äù pasted ‚ÄúMonomials‚Äù at http://hpaste.org/78451
21:10:28 <jfischoff> ^ I'm curious to know what anyone thinks of my "simplify" function
21:11:20 <arthurdent> why does GHCi never release memory?
21:11:32 <arthurdent> and can i force it to without restarting?
21:12:59 <latermuse> athurdent: what version of ghci do you use? I was under the assumption that that bug has been fixed.
21:14:05 <Ashlyn> Hello
21:14:16 <Ashlyn> Help me to chose something for js
21:14:37 <Ashlyn> I were thinking about dart but then there is fay
21:14:41 <Ashlyn> and then there is http://www.haskell.org/haskellwiki/The_JavaScript_Problem
21:14:45 <johnw> and there is also ghcjs
21:14:50 <Ashlyn> A lot of projects!
21:15:08 <Ashlyn> johnw: and other...
21:15:27 <Ashlyn> maybe someone has tryied them all LOL
21:15:31 <Ashlyn> no?
21:15:57 <latermuse> Ashlyn: Fay is really intuitive, but it is still in alpha development; there are a lot of things it cant do still
21:16:39 <Ashlyn> latermuse: so there are a lot of alternatives, even haskell-alike.
21:17:01 <Ashlyn> latermuse: maybe I can drop some RIP projects
21:17:06 <Ashlyn> that will help to chose
21:17:17 <latermuse> I really enjoyed this line from that wiki page: There are various ways to do it, but we ought to opt for compiling an existing language, Haskell, to JavaScript, because we do not have time to learn or teach other people a new language, garner a new library set and a new type checker and all that Haskell implementations provide.
21:23:10 <Ashlyn> and roy
21:26:51 <arbn> Ashlyn: http://www.yesodweb.com/blog/2012/10/yesod-fay-js <-- I found this post interesting. I think Fay has the most promise, personally. It looks easy for us to write bindings from it to JavaScript libraries and frameworks.
21:27:12 <arbn> for it to*
21:27:35 <Ashlyn> arbn: oh, thank you
21:27:38 <arbn> And, for the most part, It's Just Haskell, which is nice.
21:29:09 <lpvb> has anyone tried haskell development on android or iOS?
21:29:28 <arbn> lpvb: People have done it on iOS, I believe. Not me, though.
21:29:45 <lpvb> how would you even use any of the native apis if you don't have FFI?
21:31:19 <lpvb> oh, I guess it's possible
21:31:27 <lpvb> would like to know of any instabilities though
21:31:55 <Ashlyn> arbn: reviewed haste?
21:33:22 <arbn> Ashlyn: Nope.
21:33:43 <Ashlyn> arbn: hm, ok
21:33:57 <arbn> lpvb: I know Cale was working at a startup that was developing a game in Haskell for the iPhone.
21:34:03 <arbn> lpvb: So, you could ask him.
21:35:26 <arbn> lpvb: As for Android, I'm pretty sure it's not possible. When I use Android, I use Scala. I'd *rather* use Frege, but I'm pretty sure that's not working yet.
21:36:42 <arbn> Ashlyn: If you need to have something production-ready in a hurry, I'd advise just using JavaScript for now. The Haskell, solutions, as promising as they are, aren't ready for production use.
21:36:55 <arbn> The Haskell solutions*
21:37:09 <Ashlyn> arbn: what about dart?
21:38:19 <theorbtwo> The haskell -> llvm -> js route sounds like the best one, IMHO, but it sounds like working on porting the runtime to it hasn't even begun.
21:39:00 <johnw>  theorbtwo: what is the haskell -> llvm -> js route?
21:39:07 <arbn> Ashlyn: Do you find Dart better than JavaScript?
21:39:26 <arbn> Ashlyn: Personally, I don't.
21:40:08 <Lamen> newbie question, is there any module I can use for escaping unicode characters to '\uHHHH' sequence? :) TIA
21:40:25 <Ashlyn> arbn: I'm to newby in js world to answe this question
21:40:40 <theorbtwo> http://www.haskell.org/haskellwiki/The_JavaScript_Problem mentions it other "others" -- ghc already outputs llvm, emscripten is an llvm->javascript compiler.
21:41:37 <theorbtwo> s/other "/under "/
21:41:37 <mzero> Lamen: do you need to do this w.r.t. JSON?
21:41:49 <stepcut> arbn: check out this as well, http://www.happstack.com/c/view-page-slug/15/happstack-fay-acid-state-shared-datatypes-are-awesome
21:41:58 <Lamen> mzero: yes, that exactly what I am doing.
21:42:07 <monochrom> U+1D4D0 ùìê cannot be expressed in the '\uHHHH' form. but perhaps you accept '\u1D4D0'
21:42:13 <mzero> Ah - what you want is the aeson package
21:42:20 <Ashlyn> arbn: dev-haskell/language-ecmascript huh, what is it?
21:42:45 <mzero> especially since Unicode escapes in JSON probably aren't what you think they are!
21:42:51 <theorbtwo> monochrom: Yeah.  Failure of the specification.
21:42:55 <shachaf> Œª> show "ùìê"
21:42:55 <shachaf> "\"\\120016\""
21:43:41 <johnw> F : ùìí ‚Üí ùìì
21:43:42 <johnw> cool
21:43:59 * theorbtwo personally likes \x{1d4d0} as a format.
21:44:04 <arbn> Ashlyn: Data-types and such for representing JavaScript, I think. For writing parsers and such.
21:44:05 <johnw> i get to add this to Agda input mode, since it didn't have a way to enter these
21:44:08 <shachaf> \& is the best escape sequence.
21:44:28 <Lamen> Yes, I've already found aeson, but when I print then encoded result out, it doesn't look like escaped chars to meÖ
21:44:32 <Ashlyn> arbn: can't find it on hackport
21:45:05 <Ashlyn> arbn: damn on hackage I mean )
21:45:38 <Ashlyn> arbn: ah found it! )
21:45:51 <arbn> Ashlyn: OK. Was just about to link it. :)
21:46:00 <mmcdermo> Anyone have experience with the 'plugins' package? I'm getting a rather unexpected error. http://hpaste.org/78425
21:46:04 <arbn> stepcut: Pretty cool. I should play around with acid-state.
21:46:18 <stepcut> arbn: It's pretty cool
21:46:38 <Ashlyn> pretty-show
21:46:42 <arbn> I've read about it, but not used it in a project yet.
21:46:43 <Ashlyn> yet another mess !
21:46:43 <johnw> ah, ùíû is better
21:46:49 * hackagebot wai-extra 1.3.0.5 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.0.5 (MichaelSnoyman)
21:46:50 <stepcut> mmcdermo: hmm..
21:47:04 <johnw> ùîÖ
21:47:05 <shachaf> johnw: Stop it. :-(
21:47:17 <shachaf> Those things are unreadable.
21:47:24 <Lamen> Here the code I wrote: http://hpaste.org/78452
21:47:26 <johnw> you can't see fraktur B?  interesting
21:47:31 <shachaf> johnw: No, I can see it.
21:47:39 <shachaf> I just don't like the chracter.
21:47:46 <johnw> dude, lighten up
21:47:49 <shachaf> I hope you don't use it in any actual code.
21:48:44 <Ashlyn> arbn: https://gist.github.com/4167047 LOL, let me test it :D
21:49:07 <arbn> Uh oh. There's no page for acid-state anymore.
21:49:10 <lpvb> arbn: I thought you could use JHS for android? I want to make a cross platform game in a functional language between iOS and android
21:49:13 <Lamen> basically a toy utility, using sqlite(charset: UTF-8)Öbut I am not sure if a single 'encode' call is enoughÖ :(
21:49:52 <arbn> lpvb: Can you? I've never heard of that.
21:49:56 <hpaste> mmcdermo annotated ‚Äúundefined called from System.Plugins‚Äù with ‚ÄúSystem.Plugins - Using dynamic loading‚Äù at http://hpaste.org/78425#a78453
21:50:15 <stepcut> arbn: Yeah, I just noticed that earlier tonight. I complained to Lemmih. You can use these docs in the meantime, http://www.happstack.com/docs/crashcourse/AcidState.html#acid_state
21:50:35 <arbn> stepcut: OK. Thanks.
21:50:54 <arbn> lpvb: Oh, with the Android NDK? I guess that would work.
21:51:00 <stepcut> mmcdermo: undefined does not appear anywhere in the plugins source..
21:51:21 <mmcdermo> stepcut: I thought that was strange, which is why I reduced the program to that minimal example.
21:51:50 <lpvb> arbn: and it's a multiplayer game, so I need something scalable to distributed computing, you think erlang is a better choice for that?
21:51:58 <stepcut> mmcdermo: I don't suppose that deleting test1.o and test1.hi fixes anything?
21:51:59 <lpvb> (than haskell)
21:52:08 <lpvb> uh
21:52:12 <lpvb> talking about a server
21:52:25 <mmcdermo> stepcut: :) unfortuantely not.
21:52:27 <arbn> lpvb: What do you mean? Your server will be distributed?
21:52:52 <mmcdermo> stepcut: pdynload seems more appropriate for my purposes anyway, but that gives ghc: -ohi can only be used when compiling a single source file.
21:53:17 <mzero> mmcdermo: I eventually got plugins to work, but it was a major effort! See https://github.com/mzero/barley/tree/master/src/Barley
21:53:28 <mzero> the file Loader.hs has the code that loads things
21:53:28 <lpvb> arbn: shouldn't it be if I want to scale it?
21:53:38 <mmcdermo> mzero: Thanks, I'll try and replicate your efforts!
21:53:50 <mzero> the file AltLoad.hs is a patched version of some of the loader package
21:54:02 <arbn> lpvb: Anyway, Cloud Haskell is a nice core, and it's ready, so I'd advise you to look at it, and see if you feel up to building on top of that. If not, Erlang is a more mature environment, of course.
21:54:04 <lpvb> or is a distributed server for applications that are not parallelizable?
21:54:13 <mzero> in my case, I needed to be able to compile code, and run one of possibly three different entry points - without crashing
21:55:07 <lpvb> arbn: okay, thanks
21:55:24 <mmcdermo> mzero: Hmm, interesting. Otherwise altload's functionality is the same as System.Plugins.load?
21:55:43 <mzero> yes
21:55:58 <arbn> lpvb: Building higher-level abstractions on top of Cloud Haskell is a big need right now, so if you do build something cool with it, share the useful parts as libraries. :)
21:56:08 <mzero> see the comment at the top - it is just to expose an internal function
21:57:21 <stepcut> mmcdermo: rename test1.hs to Test1.hs
21:57:24 <mmcdermo> mzero: Should have read. Thank you. Was hunting for some working plugins code!
21:57:28 <stepcut> and change Main.hs to reflect that change
21:58:22 <mmcdermo> stepcut: dynamic loading still gives the error. One sec while I test 'load'
21:59:46 <hpaste> stepcut annotated ‚Äúundefined called from System.Plugins‚Äù with ‚Äúundefined called from System.Plugins (annotation) w/ output (annotation)‚Äù at http://hpaste.org/78425#a78454
22:00:21 <stepcut> mzero: you should send me some patches for plugins ;)
22:01:10 <mmcdermo> stepcut: Hmm. unfortunately still undefined's
22:01:18 <stepcut> works for me..
22:01:19 <johnw> shachaf: http://j.mp/UtnlYM
22:01:31 <stepcut> are the files named Main.hs and Test1.hs ?
22:01:34 <mzero> stepcut: I didn't realize that someone had taken it up since Don abandoned it
22:01:36 <mmcdermo> stepcut: Errr wait. I didn't add the module declaration.
22:01:37 <stepcut> with that capitilization?
22:01:54 <mzero> I had discussed all those changes with Don way back... but then he didn't move plugins forward
22:02:18 <stepcut> mzero: right. I did a while back. Haven't had much time to add new features, but I do keep it building and I do actually apply patches that people send :)
22:02:53 <stepcut> mzero: it is an essential feature of clckwrks, though we have not quite reached that point yet
22:03:37 <mmcdermo> stepcut: Thank you! With the capitalization and the module declaration as in your annotation it works perfectly.
22:03:43 <mzero> I see. Well, good - I'll try to pull together a patch -
22:04:10 <mzero> btw - those code pieces were from Barley - my Haskell IDE for web pages.. in a web page!
22:04:18 <sopvop> so, in lens 3.7 view becomes monad reader thing, and there are no composable getter?
22:04:22 <stepcut> mmcdermo: sweet! Sorry plugins is so fragile :-/ I hope to fix that eventually, but I inherited the code as-is and have not had the opportunity to improve it much yet
22:04:35 <stepcut> mzero: \o/
22:04:36 <edwardk> sopvop: erm, (->) is a Reader.
22:04:41 <sopvop> Oh
22:04:44 <edwardk> =)
22:04:46 <sopvop> no way it is!
22:04:54 <edwardk> > ask 1
22:04:55 <lambdabot>   1
22:04:58 <mmcdermo> stepcut: Thank you for maintaining it at all - dynamically loading haskell code is a sweet feature.
22:05:08 <shachaf> @ty [ask, asks, ($), id]
22:05:09 <lambdabot> [(r -> a) -> r -> a]
22:05:22 <sopvop> and where is teh monad?
22:05:23 <edwardk> he haddocks for view describe the generalization
22:05:43 <stepcut> mmcdermo: yup! Quite useful1
22:05:43 <edwardk> its in base now. it used to be in Control.Monad.Instances
22:06:00 <edwardk> it is now way down in the bowels where Monad is defined
22:06:12 <sopvop> btw, I understood now lens compose. The trick is to add braces
22:06:24 <edwardk> yeah
22:06:34 <edwardk> its just functions between values of type (a -> f b)
22:06:46 <edwardk> we just put different constraints on 'f' to get the different lens types
22:06:48 <sopvop> you should add braces to slides :)
22:06:51 <shachaf> Braces?
22:07:06 <edwardk> i prefer not to write prophylactic parens anywhere =P
22:07:12 <stepcut> mmcdermo: you might consider checking out plugins-auto as well. One thing it does is use a little bit of template haskell to ensure all the types actually match up -- which might help prevent errors like that one
22:07:13 <sopvop> parens
22:07:16 <shachaf> Where?
22:07:30 <edwardk> shachaf: he was meaning around the (a -> f b) -> (s -> f t)   in my slides
22:07:35 <shachaf> Oh.
22:07:41 <sopvop> Yup
22:07:55 <edwardk> i may do so for one slide in the deck
22:07:57 <shachaf> I think being used to a -> b -> c ~~ a -> (b -> c) is a prerequisite.
22:08:00 <edwardk> to talk about it
22:08:24 <shachaf> (->) ((->) a (f b)) ((->) s (f t))
22:09:31 <mmcdermo> stepcut: Will do! It didn't look as maintained or documented - I'll peruse the source and try to build it.
22:10:40 <stepcut> mmcdermo: I wrote it.. but someone else took over maintainership. I am a bit vague on the status as well. But if they have abandon it, I will retake maintainership
22:12:22 <stepcut> mmcdermo: plugins itself does not change very often (sadly?) so plugins-auto is probably still functional.. or very close to
22:12:30 * stepcut is testing now
22:13:02 <stepcut> mmcdermo: I know the maintainer of plugins-auto was recently looking at how to use the portable inotify library that was developed for GSoC
22:13:28 <stepcut> mmcdermo: it seemed to install for me :)
22:13:30 <mmcdermo> mmcdermo: The auto-reloading is really neat. My application can definitely use it.
22:13:58 <stepcut> yeah
22:14:00 <gseitz> edwardk: re your ad-hoc turtle graphics port: is Point itself an instance of HasPoint via id?
22:14:10 <stepcut> mmcdermo: auto reloading is way cool
22:14:13 <edwardk> yep
22:14:20 <edwardk> makeClassy makes that instance by default
22:14:30 <stepcut> mmcdermo: I am planning to use it in a wordpress-type application
22:15:02 <mmcdermo> stepcut: compiled for me as well. Are you talking about clkworks? I've heard mention of it.
22:15:12 <stepcut> mmcdermo: so that people can one-click install themes and plugins, or modify themes they already have installed
22:15:16 <edwardk> gseitz: fyi- given your prediliction for lenses you may be interested in #haskell-lens ;)
22:15:29 <stepcut> mmcdermo: yeah, clckwrks.. sorry about the missing vowels.. all the other domains were registered :p
22:15:37 <gseitz> edwardk: ooohhh, shiny! thanks :)
22:15:53 <edwardk> but feel free to talk about them here. i just usually move discussions of gory gory details over there ;)
22:16:04 <gseitz> hehe
22:16:15 <stepcut> mmcdermo: a new version should be coming out in the next week or so that completely overhauls the clckwrks plugin system and makes thing waaaay less obtuse
22:16:17 <mmcdermo> stepcut: that's awesome! With plugins and auto-reloading it'd make haskell web dev on par with the dynamic languages
22:16:48 <stepcut> mmcdermo: no.. better. Because we can detect many incompatible changes at compile time and reject them instead of hosing your live server ;)
22:24:22 <mzero> heh - now if we could only make loading and unloading both safe and not memory gobbling..... :-p
22:24:27 <mmcdermo> stepcut: Heh that is better. I've had WP crash horribly due to plugin problems.
22:24:41 * sopvop almost undertrands what Getting a stab means.
22:24:43 * hackagebot happstack-plugins 7.0.2 - The haskell application server stack + reload  http://hackage.haskell.org/package/happstack-plugins-7.0.2 (JeremyShaw)
22:24:45 <sopvop> rank2types are quite hard to understand from reading code
22:24:47 <stepcut> mmcdermo: yup.. I'm pretty sure all WP users have :)
22:26:07 <statusfailed> Woah, lens has its own channel now? :D
22:26:15 <sopvop> where?
22:26:24 <mmcdermo> stepcut: Having trouble finding anything on clkwrks. Is there a github / hackage package?
22:26:49 <stepcut> mmcdermo: the website is here: http://clckwrks.com/
22:27:08 <stepcut> mmcdermo: the dev version is here, http://hub.darcs.net/stepcut/clckwrks
22:27:15 <edwardk> sopvop: #haskell-lens. its mostly the implementation details, build-bot reports, etc.
22:27:16 <statusfailed> sopvop: #haskell-lens
22:27:33 <stepcut> mmcdermo: it is pretty much ready for release except I need to upgrade 4 or 5 sites to the new version of clckwrks
22:28:04 <statusfailed> edwardk: Is it possible to write an Arrowic interface for (possibly a subset of) Data.Machine? I was having a look and it seemed like the answer might be no
22:28:05 <stepcut> mmcdermo: check out example-dot-org or clckwrks-dot-com
22:28:42 <mmcdermo> stepcut: Argh was searching for clkwrks instead of clckwrks. Is a memorable name though.
22:29:00 <stepcut> mmcdermo: its like clockworks minus the OO :)
22:29:06 <stepcut> it's
22:29:11 <edwardk> statusfailed: pretty much no
22:29:39 <stepcut> mmcdermo: http://i.imgur.com/OdYxZ.jpg
22:29:57 <stepcut> "clckwrks, taking the OO out of web development" :p
22:30:03 <statusfailed> hahaha
22:30:12 <mmcdermo>  stepcut: Haha that's sweet!
22:31:17 <mmcdermo> stepcut: Should put that slogan on the site.
22:31:47 * sopvop never though OO is appropriate in webdev
22:31:52 <sopvop> thought
22:31:53 <stepcut> mmcdermo: it's still pretty alpha. The code base has crap for documentation, and there are some really stupid UI issues. But it does work reliably. I use it for 5 or so sites at the moment
22:32:27 <stepcut> sopvop: indeed. I think that is one reason why Haskell + web is appealing -- you don't have to try to fight OO-ness (unlike GUI development where most of the toolkits are OO based these days).
22:33:23 <sopvop> OO is well suited for guis
22:33:53 <stepcut> sopvop: As much as I would like to disagree.. I can't :)
22:34:03 <mmcdermo> stepcut: I imagine being written in haskell on top of happstack it's quite stable reliable.
22:34:18 <mmcdermo> minus one adjective.
22:35:18 <stepcut> mmcdermo: right. It powers both happstack.com and clckwrks.com and they have never crashed on me
22:36:18 <stepcut> mmcdermo: once I pushed the dev version most of the remaining issues will be stupid things -- like when a user logs in, they can see the admin menus, even though they don't actually have permissions to click on any of those entries
22:36:34 <stepcut> mmcdermo: which is clearly wrong -- just have not had time to write the extra code needed to to the right thing :)
22:38:09 <mmcdermo> stepcut: Well, I can imagine that given the awesome haskell community you might end up with a pretty big stack of patches and willing developers.
22:38:36 <stepcut> mmcdermo: perhaps. It would help if I hyped clckwrks more.. but I hate hyping things that I know are below my standards
22:38:36 <mmcdermo> stepcut: Any changes that people actually need for their sites would probably spawn patches rapidly.
22:39:34 <mmcdermo> stepcut: Well if you look at the ratio of hype to quality of WP, say, I think you still have some headroom ;)
22:39:41 <stepcut> mmcdermo: :)
22:40:09 <stepcut> mmcdermo: once this dev version goes live I will feel a lot better about hyping it
22:40:30 <stepcut> mmcdermo: and once I clean up a few other annoyances (6 or so minor things) then I will feel pretty darn good
22:42:15 <mmcdermo> stepcut: I look forward to it! The haskell ecosystem's definitely shaping up to be great for the web. Between Fay and now clckwrks I'm pretty excited.
22:43:03 <stepcut> mmcdermo: me too :) Though, ghcjs is pretty appealing as well.. not quite sure why Fay has gotten more traction
22:43:53 <sopvop> Fay got more hype?
22:44:06 <mmcdermo> stepcut: probably because chrisdone posts to reddit abt Fay more frequently :p
22:44:09 <johnw> Fay has a really convenient ffi mechanism
22:44:42 <stepcut> sopvop: quite possibly.. which is.. unfortunate. I like to pretend that Haskell users evaluate things based on merit, not hype, which does not appear to be true in reality
22:45:17 <shachaf> Haskell users tend to behave like people.
22:45:22 <shachaf> (Most of them *are* people.)
22:45:29 <stepcut> shachaf: exactly
22:45:43 <johnw> some are merely isomorphic to people
22:45:51 <shachaf> It's a shame. This channel would be less interesting if it only contained lambdabot, though.
22:47:33 <sopvop> You cant evaluate something you don't know about
22:48:26 <stepcut> sopvop: yup. Also, most Haskell users do not actually have enough experience to accurately evaluate their own needs
22:48:28 <sopvop> ghcjs requirements: 3.5GB RAM (JavaScript linker is memory hungry)
22:49:12 <sopvop> That means I'll have to close browser when compiling, else hit cache
22:49:24 <stepcut> sopvop: right.. ghcjs has some major short term issues, fay got something that is simple to install and easy to start using, but has major long term issues
22:50:17 <johnw> i think it's better to just wait until edwardk creates lenscript
22:50:24 <stepcut> though, I am not advocating that anybody stop working on either project :)
22:50:24 <sopvop> Fays lack of type classes is serious problem
22:50:25 <sopvop> But the biggest problem of javascript in haskell is javascript.
22:50:51 <stepcut> sopvop: yeah, W3C sucks balls. WHY U NO GIVE US VM!
22:50:52 <sopvop> No, first edwardk should make sqllens, or lensdb
22:50:54 <Lee_> anyone here who use sublime text 2 for haskell can advice on indentation?? I keep getting irritating parse indentation errors.
22:51:13 <edwardk> i've been thinking about how to do a nice sql dsl using lenses off and on
22:51:19 <Lee_> should i use tab or spaces
22:51:24 <stepcut> edwardk: :p
22:51:26 <johnw> edwardk: categorical databases!
22:51:37 <edwardk> even before chris done went and posted something similar to what i want
22:51:38 <stepcut> edwardk: lens + acid-state would be a lot easier ;)
22:51:46 <edwardk> probably ;)
22:52:14 <stepcut> the big issues with lens and acid-state is really about how to make datatypes like ixset work correctly with lenses :-/
22:52:25 <arbn> stepcut: Other than the lack of typeclasses, what longterm issues do you see with Fay?
22:52:28 <edwardk> but the general HasFoo pattern makes it a lot more tolerable for working with types you'd get from joins, etc.
22:52:56 <edwardk> i may take a whack at lens-based ixset at some point
22:52:59 <stepcut> arbn: lack of everything else that GHC has.. like GADTs, QQ, DataKinds, etc
22:53:19 <stepcut> edwardk: there is a (broken) ixset lens :-/
22:53:44 <edwardk> well, i mean for specifying indices, etc
22:54:19 <stepcut> edwardk: there is also an ixset alternative in the works.. though I dont' remember the name at the moment .. something generic like data-store
22:55:15 <stepcut> arbn: basically, fay will forever be playing catchup to GHC.. which is both good and bad
22:55:40 <edwardk> stepcut: thats basically what i was looking for/wanting
22:56:14 <edwardk> woot. it looks like we can kill 'isos' in lens 3.7!
22:56:42 <stepcut> ooo
22:56:43 <shachaf> Hooray!
22:56:44 <edwardk> he new projection/iso plumbing led to guts that only need (s -> a, b -> t) instead of two isomorphism pairs.
22:56:53 <edwardk> shachaf++
22:57:00 <shachaf> And it only a few dozen unsafeCoerces.
22:57:03 <shachaf> cost
22:57:14 <edwardk> for shaming about the current situation ;)
22:57:22 <stepcut> edwardk: the biggest, small issue with acid-state is definitely the lack of a really nice multiple index pure haskell set-type
22:57:36 <stepcut> edwardk: which is, in most regards, not acid-state specific in any way
22:57:51 <stepcut> edwardk: we have Set, and Map, but nothing (aside from IxSet) that supports multiple indexes?
22:58:22 <stepcut> edwardk: there are a few kdmap/kdtree implementations, and this other new library.. but nothing you can really point to as 'the thing to use'
22:58:25 <edwardk> stepcut: the trick is finding a version of the API that doesn't suck
22:58:32 <stepcut> edwardk: yup
22:58:47 <stepcut> edwardk: and.. getting the right big-O
22:59:17 <edwardk> i've done enough real database implementation stuff i'm not worried about the back end, just how to get a nice API on top ;)
22:59:22 <stepcut> edwardk: making a nice interface for kdmap is not that hard.. but balance the trees.. is still worthy of a PhD :p
23:00:27 <stepcut> edwardk: right.. a vast majority of DB users are not taxing their systems in the least bit.. the biggest issues is the cost of developing the site
23:00:38 <stepcut> and maintaining it
23:01:34 <stepcut> there is a lot of hype about what Haskell framework is the 'fastest', yet a majority of them can do more than 10,000 requests per second.. which is more than most Haskell-based websites around today will get in an entire year
23:02:43 <stepcut> or more sensible measure would be response time.. that is relevant even with only a few visitors
23:04:55 <stepcut> s/or more/a more/
23:06:42 <edwardk> My name is Edward and I'm a releaseaholic. It has been 5 days since my last release.
23:06:51 * hackagebot language-java 0.2.1 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.1 (VincentHanquez)
23:07:59 <Lee_> hi anyone know if haskell use spaces or tabs
23:08:06 <shachaf> Spaces.
23:08:11 <Lee_> how many ?
23:08:22 <shachaf> As many as you like.
23:08:38 <Ralith> eleven.
23:08:49 <Ralith> you have to be very conesrvative with them.
23:08:53 <Ralith> conservative*
23:09:20 <shachaf> edwardk uses two spaces, so that his CPSed programs fit into 160 columns.
23:09:35 <edwardk> =)
23:10:09 <edwardk> i pretty much hard cap at 200 columns, not 160. too hard to fit it all on the screen otherwise ;)
23:10:38 <shachaf> Looks like my terminal is 211 columns.
23:10:50 <mzero> you are all very silly!
23:11:10 <shachaf> edwardk: By the way, remember to zoom your demonstrations in NY way in.
23:11:23 <shachaf> The text in the terminal in the Scala video was almost unreadable.
23:11:28 <edwardk> shachaf: yeah, i zoomed it a bit better than the ones i showed you guys in SF =)
23:11:38 <shachaf> Well, not just the slides but the terminal.
23:11:47 <shachaf> (If you use that.)
23:11:48 <Sgeo__> When is this NY presentation?
23:11:49 <edwardk> and yeah the scala video was pretty tiny
23:11:54 <edwardk> the 12th
23:12:07 <hpaste> Lee pasted ‚ÄúWhat is wrong with the indentation ?‚Äù at http://hpaste.org/78455
23:12:24 <mzero> Lee_: consider following tibbe's style guide: https://github.com/tibbe/haskell-style-guide/blob/master/haskell-style.md
23:12:25 <edwardk> i gave a quick teaser of how lens compares with the 'shapeless' lenses in scala at the end of seth tisue's lens talk
23:12:27 <latermuse> Do modules load differently from ghc versions 7.4 and 7.0?
23:12:49 <mzero> Lee_: you can't have a where clause in the middle of an if expression
23:13:27 <edwardk> i mostly agree with tibbe's guidelines modulo the very retro 80 column limit, and my penchant for 2 character indentation
23:13:41 <hpaste> Lee annotated ‚ÄúWhat is wrong with the indentation ?‚Äù with ‚ÄúWhat is wrong with the indentation ? (annotation)‚Äù at http://hpaste.org/78455#a78456
23:13:42 <edwardk> i've been able to use 132 columns in a terminal since my vt220 days =P
23:14:00 * mzero wonders if edwardk's newspapers are printed with one column accross the width of the whole page....
23:14:16 <shachaf> code /= english
23:14:46 <mzero> no, but the mechanics of reading text on lines stays the same!
23:14:50 * sopvop prefers two 80 panels side-by-side in emacs
23:14:52 <edwardk> i literally can't paste some hyperlinks into the code under an 80 column limit. ;)
23:15:14 <Lee_> @mzero then where should i put 'where' ?
23:15:14 <lambdabot> Unknown command, try @list
23:15:16 <edwardk> but i understand that some people feel religiously about it.
23:15:29 <tibbe> shachaf: but our eyes are still the same :)
23:15:31 <Lee_> mzero: then where should i put 'where'?
23:15:38 <edwardk> Lee_: don't prefix comments to people wiht @ on irc, or you'll tell the bot to do stuff =)
23:15:43 <hpaste> mzero annotated ‚ÄúWhat is wrong with the indentation ?‚Äù with ‚ÄúWhat is wrong with the indentation ? (annotation) (annotation)‚Äù at http://hpaste.org/78455#a78457
23:15:49 <tibbe> shachaf: long lines are quite wasteful in that unless every line is long, you're wasting a lot of space
23:15:50 <Lee_> edwardk: sry
23:16:00 <shachaf> tibbe: My eyes are the same, but I don't read code the same way I read English.
23:16:18 * tibbe wonders why he's even discussing this. Back to GHC hacking! :)
23:16:26 <tibbe> ghc just finished compiling
23:16:27 <mzero> of course I'm sure edwardk's lines are all out to 160 columns!!!
23:16:58 <mzero> shachaf: your eyes don't have saccades?
23:17:22 <mzero> indeed - back to my 80 column lines....
23:17:25 <edwardk> tibbe: in all seriousness i don't push for upping it much. just to the 132 columns i've been able to use in every smart terminal i've had since 1989.
23:17:50 <edwardk> i understand why some folks feel religiously about 80 and when working on a project i try to fit the surrounding style.
23:18:01 <shachaf> (<@.)  :: forall i k f a b x y s t. IndexedProjective i k => IndexedProject i (x -> f y) (s -> f t) -> ((a -> f b) -> (x -> f y)) -> k (a -> f b) (s -> f t)
23:18:06 <tibbe> edwardk: that's almost a doubling. research on reading shows that 60-70 chars is good, depending on line spacing
23:18:12 <shachaf> That's the longest line of code in lens.
23:18:15 <shachaf> idroppingWhile p l = indexing $ \ f -> fst . ifoldrOf l (\i a r -> let s = f i a *> snd r in if p i a then (fst r, s) else (s, s)) (noEffect, noEffect)
23:18:21 <shachaf> Hmm, that second one is mine, isn't it. :-(
23:18:24 <edwardk> shachaf: thats also commented out
23:18:33 <shachaf> edwardk: Oh.
23:18:35 <edwardk> it was a placeholder for how it might work
23:18:41 <shachaf> I guess I'm responsible for the longest line of code in lens, then?
23:18:49 <edwardk> shachaf: yep
23:18:49 <tibbe> also keeping lines shorter is a good rule of thumb that forces you to name intermediates before the code goes crazy
23:19:11 <edwardk> that one could be problem on the lambda without pain
23:19:27 <shachaf> Should probably split that lambda out.
23:19:29 <edwardk> i presume it was just copying the style of the one elsewhere
23:19:33 <johnw> tibbe: except that mosdwardk's variables are one letter long, so the code isn't necessarily helped by introducing more intermediates
23:19:42 <edwardk> johnw: =P
23:19:43 <shachaf> edwardk: It's annoying how you indexing $ \f -> prevents you from using where.
23:20:24 <edwardk> most of my more egregious code fragments are heavily cps'd guts of things
23:20:27 <johnw> edwardk: you are responsible for most of the quotes in today's Haskell Weekly
23:20:37 <edwardk> i should go look
23:20:45 <johnw> (either directly or indirectly)
23:21:02 <johnw> did you just alpha-reduce yourself?
23:23:59 <edwardk> unlike beta-rediction, alpha-reduction is a well-founded terminating process. =P
23:24:12 <edwardk> er reduction
23:24:25 <edwardk> eventually you hit single character names
23:24:42 <edwardk> and then sort them so they come earlier in the alphabet
23:24:59 <shachaf> You could probably get away with using de Bruijn indices for everything.
23:25:10 <shachaf> I doubt you get past 9 that often?
23:25:18 <edwardk> shachaf: i do. have you seen bound? i don't even have names for most things any more ;)
23:25:48 <shachaf> Bound? You mean eak208?
23:27:32 <sopvop> Even google does not know what are you talking about
23:27:41 <edwardk> poor mgsloan had to write the Wrapped instances back when he had to write a constructor or deconstructor 8 times. now its 2. ;)
23:27:57 <edwardk> sopvop: bound?
23:28:00 <edwardk> @hackage bound
23:28:00 <lambdabot> http://hackage.haskell.org/package/bound
23:28:10 <sopvop> and that eak208?
23:28:41 <edwardk> ask shachaf. i took it as a stab at the number of packages i have =P
23:29:02 <shachaf> It was in the spirit of not having names for things.
23:29:15 <sopvop> getting a stab!
23:30:08 <shachaf> Gettin Gangsta B
23:39:29 <hpaste> Lee pasted ‚ÄúCould someone advice?‚Äù at http://hpaste.org/78458
23:52:02 <luite> sopvop: i don't think that 3.5GB memorey requirement is true anymore for the new code generator (gen2 branch)
23:53:12 <luite> sopvop: only problem is that that branch is not quite ready
23:54:21 <sopvop> luite: good. any work on "ffi"?
23:54:51 * shapr yawns
23:55:08 <luite> sopvop: no %1.%2 ffi patterns yet
