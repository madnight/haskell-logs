00:00:06 <Nereid> and then that
00:00:38 <Nereid> I should put some default imports into my .ghci
00:01:25 * nyc wonders where to start on sparse linear algebra.
00:02:18 * nyc looks for a project manager who knows something about the subject.
00:05:14 <Nereid> I was bored so I wrote some thing that, given the vertices of a polygon P and a number m, finds the number b such that the line y = mx + b cuts P into two pieces of equal area.
00:05:59 <Nereid> the code is a complete mess because I don't really care. I can't even be bothered to package it up. anyway https://dl.dropbox.com/u/33903796/bisectPolygon/BisectPolygon.html
00:06:54 <Nereid> also I just learned how to use haddock, hooray.
00:07:44 <nyc> I'm not entirely sure how to use haddock.
00:07:54 <nyc> I should update ghc or some such.
00:08:17 <nyc> I'm on 7.4.1
00:08:28 <ivanm> Nereid: as in how to write haddock markup?
00:08:32 <Nereid> ivanm: yeah.
00:08:36 <ivanm> ahh, right
00:08:38 <Nereid> although it took like 5 seconds to figure out
00:08:46 <ivanm> about to say: haddock is actually usable without Cabal? :o
00:08:58 <Nereid> yeah I used cabal to generate the html doc
00:09:03 <Nereid> well, cabal-dev
00:09:13 <Nereid> because why would I dirty my .ghc with this mess
00:09:14 <shachaf> Hey, you can write {-# CORE "blah" #-} to get searchable notes in Core.
00:09:28 <Nereid> fun
00:10:14 <nyc> Hmm, haskell-platform for maverick looks outdated.
00:11:19 <Nereid> I thought my trimRefined implementation was clever. and at the same time extremely dumb.
00:11:27 <ivanm> nyc: the latest version of HP is currently in RC status
00:11:33 <ivanm> will be out later this week IIUC
00:11:51 <Nereid> it basically squishes the side we don't want into a line
00:11:51 <ivanm> I take it back, I just checked my emails and it's out
00:12:09 <nyc> ivanm: It doesn't look like ubuntu releases go as far back as 10.10
00:12:17 <Nereid> ah, new HP is still on 7.4
00:12:46 <Nereid> makes sense, 7.6 still is a bit of a pain
00:12:46 <ivanm> Nereid: seeing as how darcs is one of the Haskell "success" stories and it can't build on 7.6 yet... :s
00:12:51 <Nereid> what, really
00:13:02 <Nereid> oh yeah
00:13:04 * ivanm is trying to bump all the Exherbo packages for 7.6.1 now
00:13:05 <shachaf> Darcs is a success story?
00:13:08 <Nereid> I remember now.
00:13:10 <Nereid> haha shachaf
00:13:18 <ivanm> shachaf: as in "here's an app written in Haskell that some people outside of Haskell use"
00:13:23 <Nereid> lol
00:13:30 <ivanm> hence why I had success in quotes :)
00:13:35 <shachaf> Not for long, I hope.
00:13:41 <ivanm> why not?
00:13:44 * ivanm <3 darcs
00:14:00 <Nereid> I found darcs cool until I tried to use it
00:14:03 <shachaf> Well...
00:14:30 <ivanm> I find darcs a hell of a lot easier and nicer to use than git
00:14:59 <Nereid> although the only thing I can judge it on is how long darcs get takes
00:15:27 <shachaf> Nereid: Because darcs get still hasn't finished, so you can't try any of the other operations?
00:15:34 <Nereid> haha
00:15:42 <shachaf> Any day now, though.
00:16:39 <startling> haha
00:18:23 * nyc is at a loss for introductory material on sparse numerical linear algebra.
00:18:53 <osa1> can anyone help me, if I don't comment line 17, I'm getting overlapping instances error. I was expecting a behavior like pattern matching. and if I comment that line, this time code like this: `:t append (undefined :: Int :=: Int :=: Int) (undefined :: TNil)` can't find a complete solution (gives `Append Int TNil zs => Int :=: (Int :=: zs)`
00:18:56 <osa1> http://hpaste.org/77305
00:19:26 <ivanm> the irony: the Cabal team didn't write their .cabal file properly! https://github.com/haskell/cabal/issues/1102
00:19:26 <Nereid> osa1: well yes, which instance should TNil TNil a use?
00:19:38 <Nereid> if you don't comment 17
00:20:02 <osa1> Nereid: I know but isn't that the point of UndecidableInstances ? it could use either one, result will be the same
00:20:07 <ivanm> osa1: UndecidableInstances is usually a big indicator that you're doing Something Wrong
00:20:14 <osa1> hmm
00:20:38 <Nereid> there's OverlappingInstances if you want to make it shut up about that
00:21:01 <startling> ivanm: are you wearing the armor, or that boring guy?
00:21:11 <Nereid> as for the other one, hmm
00:21:20 <ivanm> startling: come again?
00:21:35 <startling> ivanm, i ended up on your github page.
00:21:41 <ivanm> oh
00:21:52 <osa1> ok, it works fine with OverlappingInstances but I'm wondering if there's a way to do this without OverlappingInstances and UndecidableInstances
00:21:53 <startling> ;)
00:21:56 <ivanm> the armor is a set of armor in a museum/metalworks in Toledo, Spain
00:21:58 <shachaf> startling: ivanm is wearing the boring guy.
00:22:21 <startling> shachaf: it all makes sense
00:22:24 <ivanm> that was "I need a pic of myself for gravatar's, etc.; which picture do I have that you can actually see _me_ in"
00:22:40 <shachaf> I like the profile picture I use.
00:22:48 <startling> ivanm: so are you wearing the armor or not??
00:22:54 <shachaf> You can see me* very clearly.
00:22:58 <shachaf> * artist's rendition
00:23:00 <ivanm> startling: nah, not enough time to get in on; the tour bus was going to go
00:23:07 <startling> ivanm: too bad!
00:23:27 <shachaf> Toledo, Spain is a nice place.
00:23:42 <augur> byorgey: your fold is monoids thing is surely the expected result
00:23:54 <ivanm> yup
00:24:02 <ivanm> should have done the full-day tour rather than the half day
00:24:08 <ivanm> much more interesting than Madrid was
00:25:47 <Nereid> bedtime.
00:28:30 <startling> shachaf: so you're not actually a free-floating abstract shape?
00:28:53 <shachaf> startling: I am.
00:29:04 <shachaf> That's why the artist renditioned me that way.
00:29:28 <startling> ah, makes sense.
00:29:35 <startling> "rendered", btw
00:30:48 <shachaf> No.
00:31:01 <sopvop> what's the best way to replace `('a':xs) -> foo xs; xs -> bar xs` with Data.Text?
00:31:01 <shachaf> It's a rendition, and the artist renditioned it.
00:32:17 <ivanm> sopvop: I forget the name, but there's a function that returns the head with the tail
00:32:20 <startling> shachaf: wiktionary says the verb is only the sense of "To surrender or hand over (a person or thing); especially, for one jurisdiction to do so to another."
00:32:23 <startling> so ha
00:32:37 <sopvop> stripPrefix is more appropriate for me here
00:32:39 <shachaf> I think I'm the one who's haing here.
00:32:51 * sopvop found answer, thanks
00:32:55 <startling> shachaf, oh, so you got it from him by force?
00:33:48 <jaspervdj> c_wraith: Could you bump lrucache to depend on containes >= 0.5? Otherwise you don't have Data.Map.Strict
00:37:24 <shachaf> I have no idea how this code is even compiling.
00:38:20 <shachaf> Oh, hah.
00:38:36 <shachaf> He forgot to add {-# LANGUAGE MagicHash #-}
00:38:48 <shachaf> And he had an infix identifier called (#)
00:38:59 <shachaf> So (foo# bar) turned into (foo # bar), which typechecked.
00:40:24 <startling> haha what
00:40:38 <ion> :-D
00:40:57 <startling> does {-# Language MagicHash #-} give you the lace your pot with acid or something?
00:41:04 <startling> s/give you the//
00:41:29 <ion> {-# LANGUAGE MagicQuotes #-}
00:41:34 <shachaf> @slap ion
00:41:42 <shachaf> lambdabot isn't here so you'll be spared today.
00:42:01 <ion> Darn, i was looking forward to some slappy goodness.
00:42:17 <nicoo> Ahah
00:42:51 <startling> is there some abstraction that lets me turn an fn :: a -> Maybe b into a [a] -> ([a], [b])?
00:43:31 <Ralith> looks like a twoliner
00:43:42 <Nereid> startling: what is the [a] result supposed to be?
00:43:43 <startling> fair enough
00:43:48 <startling> Nereid: the Nothings
00:43:49 <Nereid> everything that mapped to Nothing?
00:43:50 <Nereid> yeah
00:44:05 <ion> @type \f as -> (as, (catMaybes . map f) as)
00:44:12 <nicoo> startling: Is f pure ?
00:44:20 <shachaf> ion: That's not the right as.
00:44:27 <shachaf> nicoo: Of course it is.
00:44:32 <ion> shachaf: Its type is right, it must be correct.
00:44:39 <simpson> Well, lambdabot's not in here...
00:44:43 <Nereid> filter (isNothing . fn) &&& catMaybes (map fn)
00:44:56 <shachaf> @type \_ _ -> ([],[])
00:45:00 <Nereid> although that goes through the list twice
00:45:09 <startling> nicoo: yeah.
00:45:16 <Ralith> yawn, constant factors
00:45:33 <shachaf> Ralith: Also "not GCing the list as you use it up".
00:45:35 <startling> Nereid: that's a neat way to do it.
00:45:48 <shachaf> There's an easy one-pass way.
00:46:47 <shachaf> @type (\f -> partitionEithers . map (\x -> maybe (Left x) Right (f x)))
00:46:47 <startling> oh, foldMap
00:47:18 <shachaf> Is that right?
00:47:20 <shachaf> I think it's right.
00:47:38 <Nereid> well
00:47:53 <Nereid> we want a -> Either a b
00:48:05 <clahey> Left?
00:48:12 <Nereid> and \a -> maybe (Left a) (Right (f a)) does it
00:48:15 <Nereid> so yeah
00:48:27 <Nereid> errrr
00:48:27 <Nereid> no
00:48:32 <shachaf> Without the (). :-)
00:48:32 <Nereid> maybe Left (Right . f)
00:48:48 <shachaf> No.
00:48:51 <clahey> (Perhaps I shouldn't jump into the middle of a conversation.)
00:49:00 <shachaf> clahey: 00:42 <startling> is there some abstraction that lets me turn an fn :: a -> Maybe b into a [a] -> ([a], [b])?
00:49:07 <Nereid> ugh
00:49:18 <Nereid> I'm confused about everything.
00:49:44 <startling> why does \fn -> foldMap $ \a -> maybe a id (fn a) constrain fn to (m -> Maybe m)?
00:49:52 <Nereid> \a -> maybe (Left a) (Right . f) a
00:49:58 <startling> oh, I see.
00:50:15 <Nereid> ghci confirms it.
00:50:28 <shachaf> Nereid: Not quite.
00:50:40 <shachaf> What you want is what I wrote above. :-)
00:50:46 <Nereid> oh ffs
00:51:19 <startling> \fn = foldMap $ \a -> maybe ([a], []) (\n -> ([], [n])) (fn a)
00:51:22 <Nereid> no, what you wrote above doesn't typecheck.
00:51:33 <shachaf> Yes it does?
00:51:38 <startling> that's not so great because of mappend, but meh
00:51:39 <Nereid> oh
00:51:42 <Nereid> I can't copy things.
00:51:54 <Nereid> I inserted parentheses where there weren'ta ny.
00:51:55 <ion> startling: What’s wrong with mappend?
00:52:02 <Nereid> clearly a sign that I should have gone to bed.
00:52:10 <shachaf> @localtime Nereid
00:52:16 <Nereid> 0:51
00:52:24 <ion> @localtime shachaf
00:52:27 <clahey> id &&& map fn % filter (/= Nothing) % map fromJust
00:52:27 <startling> ion, it's O(n) when it doesn't need to be
00:52:28 <shachaf> Hey, that's *my* localtime!
00:52:37 <clahey> Does that work?
00:52:39 <startling> I'm adding single-element lists to long lists
00:52:42 <shachaf> startling: It's O(size of the thing on the left)
00:52:56 <startling> shachaf, what do you have against short variable names?
00:52:59 <shachaf> Are you appending to the right?
00:53:07 <startling> my example does.
00:53:11 <Nereid> bye then
00:53:21 <shachaf> @location Nereid
00:53:32 <startling> heh
00:53:35 <Nereid> Vancouver
00:53:37 <Nereid> :v
00:53:50 <clahey> Does my code work there?
00:54:06 <clahey> I'm not at a computer.
00:54:15 <startling> clahey, no. The [a] should be the list of elements that returned Nothing
00:54:38 <startling> oh wait
00:54:38 <Nereid> clearly you're looking for const ([], [])
00:54:48 <startling> Nereid: that's it!
00:54:58 <clahey> startling: ah, okay.
00:56:40 <clahey> startling: your solution seems fairly good then.
00:57:33 <Nereid> I didn't know partitionEithers existed though, thanks
00:58:47 <lightquake> I wonder how hard it'd be to add quasiquoter support to haskell-mode
01:08:57 * hackagebot conduit 0.5.3 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.3 (MichaelSnoyman)
01:12:21 <osa1_> how can I define a default method for a typeclass ?
01:13:27 <pordan30> in the type class definition, define the default implementation
01:17:31 <Palmik> Hi guys... does anybody here have an idea since when are GADTs, TypeFamilies and DataKinds part of GHC?
01:18:42 <startling> man, the one bad thing about lens is that sometimes your function typechecks, but it's this ridiculous huge useless type.
01:18:52 <fmap> DataKinds work properly only since 7.6.1 =(
01:19:06 <shachaf> startling: edwardk did a thing to help with that a bit.
01:19:13 <shachaf> Unfortuantely it only helps in a few cases.
01:19:33 <startling> yeah.
01:23:50 <pordan30> palmik: i think that type families are < 7.4.something and gadts are greater than 6.2.something, according to a quick survey of the user's guides
01:24:21 <ivanm> TFs were about 6.12 IIRC
01:24:34 <ivanm> check the ICFP papers! :p
01:26:17 <pordan30> oh, right - i guess 7.4 still called them a new extension, and i incorrectly inferred they were new to 7.4
01:26:20 <osa1_> so does anyone know what is parameter c in here https://github.com/ekmett/type-int/blob/master/Data/Type/Binary/Internals.hs#L240 stands for ?
01:27:12 <ivanm> does it have to stand for anything?
01:27:30 <shachaf> It probably stands for "the letter in the alphabet after a and b"
01:27:34 <shachaf> ekmett-style
01:27:46 <ivanm> heh
01:27:52 <ivanm> after all, what do the "a" and "b" stand for?
01:27:54 <fmap> is it "guess the author" game?
01:28:12 <ivanm> fmap: seeing as how the author is in the URL... ;-)
01:28:21 <ion> after a, b and ɓ
01:29:07 <pordan30> the definition of TNF a b | a -> b states that TNF is TNF' without the additional reduction parameter. A reasonable inference is that c in TNF' a b c | a -> b c is the reduction parameter, as indicated in the comments (it tracks whether further reductions are necessary)
01:31:52 <shachaf> Cale: lambdabot :-(
01:31:53 <osa1_> pordan30: ok, why is it T in this case: `instance TNF' (I F) (I F) T` ? I don't understand how can more reductions be made on it
01:32:39 <pordan30> i have no idea, since i have no idea what the normal form of a binary number is. sorry.
01:40:20 <Jafet> http://hackage.haskell.org/
01:41:04 <pordan30> what is the meaning of a functional dependency without any determining types, for instance class E a | -> a?
01:41:30 <quicksilver> it's a highlander class
01:41:43 <quicksilver> there can be only one
01:41:49 <Palmik> pordan30: thanks, I will try to find it in the respective release notes. :)
01:42:18 <Palmik> fmap: thanks. :)
01:42:35 <pordan30> quicksilver: haha, and thanks. makes sense
01:42:35 <shachaf> quicksilver: That's almost like a nullary class! :-(
01:43:29 <ivanm> the test suite here is commented out, right? so why is Cabal trying to depend upon Diff, etc.? :s http://hackage.haskell.org/packages/archive/pandoc/1.9.4.5/pandoc.cabal
01:44:22 <Jafet> Weird, my proxy can't connect to hackage
01:44:33 <osa1_> how's a class with only one instance (and can't be extended) useful ?
01:45:20 <shachaf> How is it useful to disallow it?
01:48:03 <quicksilver> It's not obvious to me that it's useful, but then FDs allow all kinds of funky stuff and it's not all obviously useful :)
01:48:32 <shachaf> quicksilver: Nullary classes can arguably have some uses.
01:48:52 <shachaf> class Riemann'sHypothesis; foo :: Riemann'sHypothesis => ...
01:49:02 <shachaf> class Unsafe; unsafePerformIO :: Unsafe => IO a -> a
01:49:58 <pordan30> osa1_: it's used in the package you linked to in the definition of type-class maybe
01:50:52 <quicksilver> shachaf: but since they're trivially discharged, they wouldn't appear in constraints.
01:51:17 <quicksilver> haskell constraint propagation elides satisfied constraints.
01:51:40 <shachaf> quicksilver: They might not be satisfied at the definition site.
01:51:53 <pordan30> but this is haskell: f :: ReimannHypothesis; f = _|_
01:51:59 <quicksilver> what would they be satisfied by? an import?
01:52:15 <shachaf> quicksilver: The person who's using them could use them only if they have an instance in scope.
01:52:31 * quicksilver nods
01:52:59 <shachaf> At any rate it's silly to allow MPTCs and explicitly disallow ZPTCs.
01:53:08 <shachaf> Adding ZPTC support to GHC consists of removing a few lines of code.
01:53:27 <ozgura> hi. is there a ghc flag to limit memory usage? I am on OSX where ulimit ignores many options.
01:53:55 <quicksilver> there is, ozgura, but it's not very pleasant to use
01:54:07 <ozgura> not ghc's own memory usage btw, limit the memory usage of a ghc compiled binary
01:54:14 <ClaudiusMaximus> compile with -rtsopts and use +RTS -? for more information
01:54:25 <quicksilver> or read the manual
01:54:41 <quicksilver> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/runtime-control.html
01:54:42 <ClaudiusMaximus> there's also -with-rtsopts to bake in default values
01:54:46 <quicksilver> -M is a maximum heap size
01:55:09 <quicksilver> however hard heap limits tend to cause painful GC thrashing as you get close
01:55:34 <ClaudiusMaximus> which is more convenient than the old way of linking with special symbols
01:55:58 <ozgura> ClaudiusMaximus: thanks! +RTS -? is very helpful indeed.
01:57:23 <ozgura> quicksilver: why did you think this wasn't pleasant to use? Is it not just a single flag?
01:57:37 <ozgura> or did you mean the trashing behaviour of GC
01:59:15 <ClaudiusMaximus> +RTS -M100M -RTS is a bit verbose if you have to remember it every time
01:59:44 <ozgura> oh I see
01:59:56 <ozgura> I am happy if that'd be the only inconvenience :)
02:05:12 <quicksilver> ozgura: I meant the GHC trhashing
02:05:56 <ozgura> quicksilver: ok thanks. I'll see how it effects my app.
02:09:06 <neutrino> hey guys
02:09:14 <neutrino> is there something for haskell like 4clojure?
02:09:57 <shachaf> 4haskell?
02:10:10 <hvr> neutrino: sounds a bit like http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
02:10:22 <fujisan> hello can i run haskell in terminal?
02:10:30 <hvr> fujisan: yes
02:10:31 <fujisan> hvr hi
02:10:35 <fujisan> ok ty
02:10:57 <fujisan> shachaf:  sorry about all the lamdabot messages
02:13:44 <c_wraith> jaspervdj: it only imports Data.Map.Strict on ghc 7.6+ . Are you somehow running ghc 7.6 with continers < 0.5? I tested it on 7.4 and 7.6
02:13:51 <neutrino> hvr: mm yeah now if we had an interactive form that automatically checked it all
02:14:04 <neutrino> and the ability to rank users and see others' solutions
02:14:08 <neutrino> that would then be great
02:16:54 <Jafet> neutrino: sounds like a fun project for you
02:18:33 <neutrino> if i were going to do this, i would make it generic so that people could hook up their own backends and write their own problems.
02:18:52 <neutrino> there are many different pages like this. for example there's one for vim.
02:19:29 <neutrino> there's of course project euler (although what would the backend be for that?) and you can easily imagine that for all programming languages
02:19:56 <Jafet> Writing just one "backend" is work enough
02:21:34 <Axman6> fujisan: what're you doing here?
02:21:41 <shachaf> Trolling, I assume.
02:21:55 <fujisan> no i am not trolling shachaf
02:22:08 <fujisan> Axman6:  im interested in haskell
02:22:23 <shachaf> If the bot was in here I'd @where ops
02:22:31 <fujisan> huh?
02:22:43 <fujisan> i don't get what you mean shachaf
02:22:44 <Axman6> I've know fujisan for a long time, he lives on the thin line between trolling and ignorance :P
02:23:27 <shachaf> Axman6: He's been spamming me for the past few weeks over lambdabot @tell after being explicitly banned from #haskell{,-blah}
02:23:39 <shachaf> E.g. 16:40 <lambdabot> fujisan said 2m 24s ago: please unban me orelse i will have to send this message every second of everyday kthanks
02:23:57 <Axman6> fujisan: quit being a dick
02:23:57 <jaspervdj> c_wraith: Yeah I am somewhow running it that way... I think it's my fault
02:24:13 <fujisan> shachaf yes
02:24:15 <fujisan> true
02:24:19 <fujisan> i kept my promise
02:24:23 <fujisan> and for that im sorry
02:24:41 <hvr> fujisan: would you pass the turing test?
02:24:49 <fujisan> but i never spammed you shachaf
02:24:53 <fujisan> the bot did it
02:24:55 <c_wraith> jaspervdj: I'll update the CPP conditional to check the version of containers rather than the ghc version, if that's possible.. But I don't know what tools I have.
02:25:10 <fujisan> hvr probably not
02:25:23 <fujisan> shachaf and what was i banned for again
02:25:26 <startling> fujisan, he's got a point.
02:25:28 <fujisan> talking too much i reckon
02:25:31 <shachaf> I don't care, fujisan
02:25:34 <startling> fujisan, this is all lambdabot's fault.
02:25:37 <startling> err
02:25:40 <startling> shachaf: ^^
02:25:43 <fujisan> see that is why i did it shachaf
02:25:56 <fujisan> im just a lonely guy trying to talk to folks in an offtopic channel
02:26:07 <fujisan> that's my crime
02:26:14 <Axman6> fujisan: you're not fooling anyone man :\
02:26:14 <fujisan> and then i was angry that you banned me
02:26:16 <fujisan> so i did that
02:26:24 <Axman6> you're not the victim here
02:26:56 <fujisan> i just told the bot to help me take revenge
02:26:58 <fujisan> that's all
02:27:03 <fujisan> godbless technology
02:27:22 <fujisan> and now i will leave enough drama for the day i expect a ban and im fine with that
02:27:37 <fujisan> but still banning someone for just talking in an offtopic channel is even worse
02:27:42 <fujisan> so bye
02:27:47 <c_wraith> Hmm.  Looks like there *is* a CPP macro for that.
02:33:33 <jaspervdj> c_wraith: something like #if MIN_VERSION_containers(...)
02:34:06 <c_wraith> mostly works
02:34:09 <c_wraith> except..
02:34:10 <c_wraith>      error: missing binary operator before token "("
02:34:21 <c_wraith> when running the code via runghc
02:34:27 <c_wraith> which didn't have troubles before
02:34:57 <c_wraith> phase `C pre-processor' failed (exitcode = 1)
02:35:03 <c_wraith> on both 7.4.2 and 7.6.1
02:35:15 <c_wraith> both compile fine - only blow up like that when used with runghc
02:35:30 <c_wraith> I don't know what to make of that
02:36:17 <c_wraith> oh, yes I do
02:36:38 <c_wraith> those values are only set when cabal runs CPP, not when GHC does it autonomously
02:37:41 <c_wraith> hmm.  too late to think about this now.
02:41:52 <jaspervdj> Yeah, it's kind of annoying that you can't use ghci then
02:50:42 <[Bergi]> Hi, where can I find Lambdabot?
02:51:09 <startling> [Bergi]: we dunno, we're looking for her too.
02:51:23 <Phlogistique> [Bergi]: on Google
02:52:26 <sopvop> I thought lambdabot is male.
02:56:29 <startling> sopvop: me too!
02:57:00 <ChristianS> sopvop, startling: well, now you know better
03:01:22 <tikonen> Hi, newbie with a problem: http://pastebin.com/B9BFErWG . I cant get this code to compile but cant figure out why
03:01:29 <startling> why is unsafeInterleaveIO unsafe?
03:02:16 <startling> tikonen, you only imported the type, not the constructor
03:02:29 <startling> write Handler(..) to import the type and all its constructors.
03:02:50 <tikonen> startling, right so the type and constructor have same name?
03:02:56 <startling> tikonen: yes
03:03:01 <tikonen> thanks!
03:03:09 <sopvop> because with LazyIO you can get IOError in pure code
03:03:24 <shachaf> startling: Because it gives you a "thunk" such that forcing it will cause IO to happen.
03:03:26 <startling> well, I assume so, I don't actually know anything about Control.Exception
03:03:38 <startling> shachaf: so things happen unpredictably?
03:03:40 <shachaf> Normally forcing a thunk isn't supposed to cause outside effects to happen.
03:03:41 <tikonen> startling, it works now. thanks again
03:03:55 <startling> oh, so it's not *really* unsafe
03:04:03 <shachaf> It's pretty unsafe.
03:04:04 <startling> just unpredictable.
03:04:09 <shachaf> Well, uh, is unsafePerformIO unsafe?
03:04:11 <Jafet> That's the spirit, startling.
03:04:11 <shachaf> It's not *really* unsafe.
03:04:34 <startling> shachaf, yes it is! it breaks type-checking.
03:04:37 <sopvop> semi-usafe?
03:04:50 <startling> kindOfUnsafeInterleaveIO
03:06:10 <TheRedMoodwin> Hello :)
03:06:21 <Jafet> It's funny how many consistency checks are done by the unsafe functions to ensure that their uses are safe.
03:06:22 <TheRedMoodwin> Trying out haskell for the first time :)
03:07:01 <shachaf> Jafet: Except for reallyUnsafePtrEquality#, that is.
03:07:07 <shachaf> That one is *really* unsafe.
03:07:11 <Jafet> Well duh. It's really unsafe.
03:07:13 <TheRedMoodwin> I heard that you people where: Funky, crazy, on meth, geniuoses, mathemtical evolutionists.
03:07:18 <TheRedMoodwin> X3
03:07:29 <Jafet> I think I've propagated at least one of those falsehoods
03:07:33 <TheRedMoodwin> So I am feeling kind of unqualifed to even touch this language
03:07:45 <startling> TheRedMoodwin: we're pretty funky. dunno about mathematical evolutionists
03:08:16 <startling> last time I tried to breed Abelian Groups, crazy things happened.
03:08:23 <sopvop> on math, not on meth
03:08:29 <TheRedMoodwin> X3
03:08:30 <TheRedMoodwin> :)
03:08:43 <TheRedMoodwin> Well, I just think that your logo
03:08:51 <TheRedMoodwin> Reminds me of something really clinical and unhuman
03:08:59 <TheRedMoodwin> But the overall picture I got of the language
03:09:01 <TheRedMoodwin> and the community
03:09:16 <TheRedMoodwin> is this: http://learnyouahaskell.com/
03:09:19 <TheRedMoodwin> :D
03:10:38 <Sonderblade> can any of you haskellers solve this question: http://stackoverflow.com/questions/13247750/navigating-json-objects-in-a-generic-way-in-haskell ?
03:10:48 <Sonderblade> also, can you make the solution shorter than the python one? :)
03:11:12 <TheRedMoodwin> Hmm, am I stupid for asking what hasell is used for? Can it be used for servers? Like making people connect to a running server on my machine?
03:11:41 <shachaf> Yes.
03:11:42 <sopvop> TheRedMoodwin: which part of 'general purpose language' you don't understand?
03:12:17 <TheRedMoodwin> sopvop: :) python is also a general purpose programming lanugage.
03:12:27 <TheRedMoodwin> But still if I had to deal with tons of data processing
03:12:32 <TheRedMoodwin> I would use c
03:12:42 <sopvop> TheRedMoodwin: What can you do with python, you can do with haskell then. Right?
03:12:55 <TheRedMoodwin> sopvop so they share the exact same fields of strength?
03:12:58 <TheRedMoodwin> that is nice :)
03:13:06 <startling> TheRedMoodwin: why would you use C?
03:13:06 <sopvop> Eh...
03:13:17 <Jafet> Well, you can't program like a retard
03:13:20 <lolcathost> Python does not particularly shine in the correctness department.
03:13:28 <TheRedMoodwin> startling: Because as far as I know C is quite a lot faster than python.
03:13:44 <Sonderblade> TheRedMoodwin: http://stackoverflow.com/questions/1604790/what-is-haskell-actually-useful-for
03:13:48 <TheRedMoodwin> Jafet: Ohh :o I never though of not programming as one.
03:13:48 <lolcathost> TheRedMoodwin: Languages are not intrinsically fast or slow. Speed is a property of implementations.
03:13:56 <Jafet> It has been long proved that nothing can go faster than c.
03:13:59 * hackagebot regex-pcre-builtin 0.94.4.0.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.0.8.31 (AudreyTang)
03:14:00 <TheRedMoodwin> Jafet: Thanks! :D I will try that next time i am trying to make something.
03:14:01 <fmap> Sonderblade: well, Data.Aeson.Value is pretty much as untyped as python
03:14:06 <startling> Jafet, uh.
03:14:13 <fmap> not sure what the question is
03:14:50 <fmap> s/as python/as python hashes/
03:15:09 * bxc growls at no annoucenment f next london hug date
03:15:15 <TheRedMoodwin> lolcathost: I will point to what Jafet said. I know that this is not for common software, but for sometasks no matter how you implement the language is going to play a role in how fast it runs.
03:15:21 <Jafet> tikonen: you imported the Handler type, but not the Handler constructor
03:15:45 <Jafet> Uh oops, that popped out from my history
03:16:16 <Sonderblade> fmap: see the example run at the bottom. it's what im trying to accomplish in haskell
03:16:42 <TheRedMoodwin> thanks Sonderblade :D
03:17:28 <Sonderblade> fmap: im trying to "fill in" the parts of the code marked with ???
03:17:28 <lolcathost> TheRedMoodwin: Besides laziness, I do not think there is anything about the Haskell programming language that prevents anyone from making a implementation comparable in speed to that of a systems programming language, although that is hardly the main focus of the Haskell community.
03:17:51 <lolcathost> s/a implementation/an implementation
03:17:55 <lolcathost>  //
03:18:07 <Jafet> I don't think there is any point in talking about implementations that don't exist, and aren't likely to exist in the foreseeable future
03:18:08 <merijn> aww...no 7.6 in HP :(
03:18:19 <Jafet> Except socratically
03:18:25 <TheRedMoodwin> lolcathost: Are you saying that you can get haskell to run faster than C? With the same algorythems being used?
03:18:51 <TheRedMoodwin> And I am starting to feel like I am under qualifed to even speak in this channel X3
03:18:55 <shachaf> Haskell does not have algorythem support.
03:19:00 * lolcathost sighs, gives up.
03:19:00 <shachaf> @quote einstein
03:19:05 <shachaf> Bah, bot.
03:19:15 <sopvop> yup, HE is missing
03:19:20 <fmap> Sonderblade: yeah, your comments "value is an array" and "value is a map" should suggest you to pattern match value on Data.Aeson.Value constructors
03:19:21 <Jafet> Algos'r'us
03:19:23 <lolcathost> Where is lambdabot?
03:19:40 <TheRedMoodwin> :o Does it have to support it? Isen't an alogrythem just a set of instructions to repeate until a condition is met?
03:20:20 <bxc> now i just starte dimplementing stuff with Text.JSOn and now i have to see if aeson is better or worse
03:21:13 <sopvop> No one will take you seriously in this channel until you understand what zygohistomorphic prepromorphisms is. Oh, and monads.
03:21:29 <Jafet> Algorithms tend to be more popular than alogrythems
03:21:42 <TheRedMoodwin> Ohh
03:21:49 <[Bergi]> lolcathost: He seems to have taken the day off :-( I wanted to ask him for a simple point-free function, too...
03:21:59 <TheRedMoodwin> Sorry, you will have to excuse my english. It is not very good.
03:22:29 <PatrickRobotham> I'm having trouble loading the package Data.Traversable. How do you do it?
03:22:39 <Sonderblade> fmap: i dont know how or what value constructors aeson has
03:22:52 <PatrickRobotham> I get the error message "<no location info>: module `Data.Traversable' is a package module
03:22:53 <PatrickRobotham> Failed, modules loaded: none."
03:23:22 <fmap> Sonderblade: you can check aeson documentation for that: http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson.html#t:Value
03:23:25 <sopvop> PatrickRobotham: It is supposed to be in base. Guess you messed up package-db or something.
03:23:51 <fujisan> what is a good haskell tutorial or beginners guide or booklet?
03:23:52 <sopvop> PatrickRobotham: how do you load it?
03:24:30 <PatrickRobotham> Sorry, I've fixedit.
03:24:30 <TheRedMoodwin> fujisan: I like learn you some haskell
03:24:33 <TheRedMoodwin> It is nice :D
03:24:40 <PatrickRobotham> I typed in :l when it should have been :m
03:25:50 <fmap> PatrickRobotham: with ghc >= 7.4 you can just type "import Data.Traversable" into ghci
03:26:02 <fujisan> TheRedMoodwin:  ok ty
03:26:04 <fmap> (not if that is a good idea)
03:26:07 <PatrickRobotham> fmap cool
03:26:19 <TheRedMoodwin> fujisan: A pleasure :)
03:27:31 <Jafet> fmap: you have been able to do that since 6.x
03:27:41 <TheRedMoodwin> Hey hey.....
03:27:54 <TheRedMoodwin> in the tryhaskell.org website
03:27:56 <TheRedMoodwin> there is a reset button
03:28:15 <TheRedMoodwin> And when I click, it says that I will lose my current state.
03:28:15 <shachaf> They should take the #haskell button out of tryhaskell.org
03:28:26 <TheRedMoodwin> I didn't think haskell had any states=
03:30:14 <Sonderblade> fmap: but how do i get from Data.Aeson.Object to an ordinary haskell Map?
03:31:03 <gal_bolle> is it possible to have an equivalent of "make -k" for cabal build: when I change a type somewhere, I'd like to be able to see as many type error as possible (at least in the case where I have a lot of mutually independent modules depending on the module where I changed the type)
03:33:47 <fmap> Sonderblade: you don't need to. `Object' is a `HashMap Text Value', you can ask HashMap to give you value for the key directly
03:34:06 <fmap> Sonderblade: http://hackage.haskell.org/packages/archive/unordered-containers/0.2.1.0/doc/html/Data-HashMap-Strict.html#v:lookup
03:36:52 <sopvop> gal_bolle: It should recompile everything automatically. Maybe you mean packages, not modules?
03:37:42 <sopvop> cabal build in the end calls 'ghc -make' IIRC
03:38:54 <Jafet> It recompiles everything automatically until something fails, then it stops
03:38:57 <fmap> Jafet: interesting, didn't know that import statements were here before full-powered import syntax was introduced (in 7.0.1, no 7.4 :[)
03:39:10 <Jafet> I wish cabal-install did that actually
03:40:03 <sopvop> Like parallel module compilation?
03:41:11 <Maxdamantus> `[a] -> a` is the type of something that, for all types `a`, takes a list of type `a` and returns something of type `a`
03:41:23 <Maxdamantus> er, wrong channel.
03:42:00 <Jafet> Good to know
03:42:31 <Maxdamantus> What? The meaning of the type, or that I said it in the wrong channel?
03:42:55 <Jafet> No, sopvop, I wish it stopped after the first damn build failure
03:43:04 <Maxdamantus> Ah.
03:43:28 <Jafet> Max: "yes"
03:44:09 <gal_bolle> sopvop: yes: i'd like it to compile every module that does not depend on one that has not failed yet
03:44:19 <gal_bolle> one that has failed yet
03:51:03 <burbul> Is there a nice way of writing this without the do block?
03:51:03 <burbul> http://hpaste.org/77307
03:52:18 <ivanm> burbul: GHC-7.6.1 has anonymous case statements
03:52:23 <Jafet> get >>= \b -> case f b of
03:53:10 <Jafet> get >>= (\case -> ...) . f
03:53:18 <Jafet> That's horrible actually
03:53:28 <Jafet> get >>= f >>> \case ->
03:53:28 <burbul> ivanm: sounds interesting...  where can I read about them?
03:53:35 <ivanm> Jafet: or gets f ?
03:53:43 <ivanm> burbul: ummm.... release notes for 7.6.1?
03:53:58 <sopvop> like  getting :: (s -> StateT s m a) -> StateT s m a
03:54:01 <ivanm> IIRC, it's something like: foo >>= \ case of ...
03:54:02 <Jafet> Ok, well, that works for get
03:54:28 <burbul> thanks, all!
03:56:16 <quicksilver> "There is a new syntactic construct (enabled by the LambdaCase extension) for creating an anonymous function out of a case expression"
03:56:20 <quicksilver> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/release-7-6-1.html
03:56:22 <burbul> yup, found it
03:56:29 <burbul> http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/syntax-extns.html#lambda-case
03:56:32 <quicksilver> multiwayif, as well
03:56:40 <quicksilver> they are really hitting up the syntax enhancements
03:56:51 <quicksilver> it's just a shame about the IfThenElse layout rule :-(
03:57:24 <Jafet> So we should brace ourselves?
03:57:36 <quicksilver> for what?
03:57:45 <hpc> if-then-else is an unfortunate bit of syntax anyway :P
04:09:32 <pordan30> it would be nice to have if-then-else desugar to a function like cond, overloaded on all two-element types :(
04:10:05 <ivanm> pordan30: but which one would be equivalent to True?
04:10:28 <bxc> big red Post Office van with no royal mail branding
04:10:32 <bxc> kinda looks like an armoured car
04:10:43 <bxc> umm wrong channel
04:10:45 <bxc> heh
04:10:49 <ivanm> class BoolLike b where trueIsh :: b -> Bool ?
04:10:56 <pordan30> the first one
04:11:01 <ivanm> @src Bool
04:11:08 <ivanm> pordan30: that rules out Bool then!
04:11:09 <ivanm> ;-)
04:11:14 <ivanm> oh, no bot
04:11:18 <ivanm> data Bool = False | True
04:11:47 <pordan30> :)
04:12:06 <Jafet> pordan: if' b t f = [t, f] !! fromEnum b
04:12:25 <pordan30> yeah, something like deriving bool. i think coq manages this by overloading if-then-else on sums, no?
04:13:20 <Jafet>                   | length [minBound .. maxBound `asTypeOf` b] /= 2 = error "if': Type error"
04:14:07 <Jafet> ivanm: clearly False is the zeroth one
04:14:12 <ivanm> heh
04:14:31 <Jafet> (and True is the first zero?)
04:19:55 <quest> hi, what does this mean? the question spec asked us to type in this way,  instance Show Expr where show = ... but when i code it out, error 'ambiguous occurence' happened
04:20:22 <ivanm> quest: do you have any other Show instances?
04:20:39 <Saizan> quest: full error please
04:20:42 <ivanm> because it sounds like another Show instance is clashing with your Expr one
04:20:44 <quest> ok
04:20:48 <ivanm> but yes, a full error would be more useful
04:21:37 <quest> it could refer to either 'calculus.show' (my file) define in line bla bal, or 'prelude.show' imported from prelude at 1:8-15 originally defined in 'ghc.show'
04:21:44 <quest> thats the full error
04:21:58 <ivanm> quest: because you've defined a function called show
04:22:00 <ivanm> when you shouldn't have
04:22:04 <ivanm> as it's a class method
04:22:13 <pordan30> you have show defined in two places, and ghc can't resolve which one to use. import your definition qualified
04:22:16 <ivanm> possibly you haven't indented the definition of your Show instance
04:22:28 <quest> owh
04:22:30 <quest> i didnt indent
04:22:32 <quest> all the shows
04:23:07 <quest> owh it worked now! thans
04:23:42 <ivanm> quest: in future, it might be easier (and more comprehensible) if you paste your code + error up on a site like hpaste rather than try and type it out yourself here :)
04:24:30 <quest> alright ivanm :) will do it the next round i can paste codes but errors still need to type out.
04:24:41 <ivanm> copy/paste? ;-)
04:25:49 <quest> cant copy paste the terminal :o
04:26:48 <bxc> what terminal? windows?
04:26:56 <pordan30> can't you select the text, then copy it?
04:27:11 <quest> windows
04:27:14 <quest> cant select the text
04:27:29 <quest> im using git bash...
04:28:45 <strg> right click -> then select mark, select the text and press enter?
04:28:56 <merijn> quest: Sure you can, click on the icon in the left of the title bar, select "mark" from the dropdown menu, select the text then right click to copy
04:28:59 <Jafet> Take a screenshot!
04:29:52 <TheRedMoodwin> Why do people have to have such bad choice of subjects?
04:29:59 <TheRedMoodwin> I have to attend to "nynorsk" instead of doign math.
04:30:06 <TheRedMoodwin> What a waste :/
04:30:11 <quest> thanks merijn yay it worked!
04:30:32 <TheRedMoodwin> :D
04:30:34 <TheRedMoodwin> !
04:31:23 <pordan30> because learning linguistic standards is important: who knows?
04:31:49 <TheRedMoodwin> Well
04:31:50 <TheRedMoodwin> Not really
04:31:55 <TheRedMoodwin> The language is dieing out
04:32:04 <TheRedMoodwin> the main language, Norwegian is important to learn
04:32:06 <merijn> Quick LaTeX question: If I'm writing a bunch of "oldState -> newState" transitions in a display math environment, what's the neatest way to show local definition/preconditions for that transition?
04:32:09 <TheRedMoodwin> I agree on that
04:32:32 <TheRedMoodwin> But having to learn some obscene, good for nothing language that is just clung to by a few poepl in our country
04:32:37 <merijn> hmm, that should've gone to #-blah, but feel free to answer here :p
04:32:38 <TheRedMoodwin> Is a complete waste.
04:34:26 <srhb> Topic needs a bump!
04:34:31 <TheRedMoodwin> :o
04:38:20 <Jafet> What is a topic again
04:38:34 <TheRedMoodwin> Are haskell and lisp related?
04:38:36 <TheRedMoodwin> In anyway?
04:38:37 <TheRedMoodwin> :o
04:38:46 <srhb> TheRedMoodwin: They're both functional?
04:38:52 <TheRedMoodwin> Is lisp function?
04:38:56 <TheRedMoodwin> Functional*
04:39:22 <srhb> Jafet: I meant the IRC channel topic. Platform was just released, after all.
04:39:48 <srhb> TheRedMoodwin: Well, it certainly supports a functional style, if you want to do that.
04:39:53 <srhb> Or "they" do.
04:40:35 <TheRedMoodwin> Yeah
04:40:40 <pordan30> some argue that lisp isn't functional. see: <http://letoverlambda.com/index.cl/guest/chap5.html>
04:40:42 <TheRedMoodwin> But is it functional?
04:40:50 <srhb> TheRedMoodwin: Define functional.
04:41:27 <TheRedMoodwin> :o You can not reasign a value. if X is something then it isen't later something else
04:41:31 <TheRedMoodwin> That is how I was explained it
04:41:56 <srhb> TheRedMoodwin: No, most lisps are not that kind of functional.
04:42:21 <TheRedMoodwin> But haskell is that way right?
04:42:24 <srhb> TheRedMoodwin: Destructive changes are allowed, and functions need not be side-effect free.
04:42:28 <srhb> TheRedMoodwin: Sure (no)
04:42:32 <TheRedMoodwin> :o
04:42:33 <TheRedMoodwin> okey
04:42:42 <srhb> TheRedMoodwin: As long as you avoid unsafeDoSomething.. ;)
04:42:43 <TheRedMoodwin> I will have to read up on it then
04:42:55 <TheRedMoodwin> :o
04:43:00 <TheRedMoodwin> This is all so confusing x3
04:43:09 <fmap> language is functional when comments start with --
04:43:10 <TheRedMoodwin> It is really fun thinking about programming in another way
04:43:20 <TheRedMoodwin> got it.
04:44:35 <Jafet> Lisp is: "Multi-paradigm: functional, procedural, reflective, meta"
04:44:42 <hpaste> quest pasted “question” at http://hpaste.org/77309
04:44:43 <Jafet> Haskell is: "functional, lazy/non-strict, modular"
04:44:56 <Jafet> What does modular mean
04:44:57 <srhb> Pfff. :P
04:45:06 <srhb> It's just hot air.
04:45:14 <quest> i pasted my homework, i do not intend to get the easy way out here, just hope someone can tell me how should i start off
04:45:16 <Jafet> Is it like Miss Modular
04:45:28 <quest> cuz im pretty confused and lag behind in class
04:46:31 <Jafet> You could ask someone who is not behind, or ask a teacher.
04:47:25 <tdammers> fmap: you mean like ANSI SQL?
04:47:27 <srhb> quest: You could start by considering simple expressions like (App "+" [Id "x", Id "x"]) and see if you gain any insight
04:47:37 <Jafet> That homework code looks beautiful, and by that I mean it doesn't.
04:47:49 <srhb> Jafet: Because of the Strings?
04:48:01 <srhb> Jafet: Or rather, that App takes a String
04:48:01 <Jafet> Because of the lisp
04:48:13 <srhb> What lisp?
04:48:57 <Jafet> Expr are (almost) s-expressions
04:49:10 <srhb> Seems practical enough.
04:49:16 <srhb> How would you do it?
04:50:37 <pordan30> have you made a list of the rules you wish to apply? you could start by determining which rules should apply, in which order, and whether the application of one rule will require you do differentiate after the application. then you can define a better representation of the input expressions, if you want to, and finally define the function recursively by pattern matching (you should be able to do this, because your algorithm should
04:50:37 <pordan30>  be syntax-oriented).
04:50:49 <Jafet> Well, practically speaking, I would use the ad package
04:51:15 <srhb> Jafet: That's not a very instructive package :P
04:51:55 <srhb> Plus, it's not even symbolic differentiation, so I don't see how it helps.
04:52:03 <sshine> I'm trying to determine if this is a bug in the Alex documentation on http://www.haskell.org/alex/doc/html/introduction.html : it gives the example [a-zA-Z], but that is interpreted as literal brackets unless I use [ a-zA-Z ].
04:53:15 <sshine> we found out by accident because of a syntax where brackets are directly next to identifiers, and it seemed to make them a part of the identifier.
04:53:23 <quest> i will paste my current progress.....
04:53:33 <hpaste> quest pasted “progress” at http://hpaste.org/77310
04:54:01 * hackagebot hat 2.7.0.5 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.5 (OlafChitil)
04:57:01 <Jafet> http://en.wikipedia.org/wiki/Differentiation_rules
04:58:23 <Jafet> quest: diff (Num x) x is not a valid pattern.
04:58:41 <quest> jafet why?
04:58:44 <Jafet> diff (Num x) v is
04:58:49 <quest> owh
04:58:51 <quest> :o
04:59:27 <pordan30> fyi: don't use may / fromJust : instead, return in the maybe type; you can define chg in one place : in this case, a finite map would provide logarithmic lookup; you can use a lambda do define eval', instead of a where clause
05:00:10 <pordan30> also, you can pattern match on strings
05:00:18 <hpaste> quest pasted “trial 2” at http://hpaste.org/77311
05:00:45 <Jafet> I wonder if you can submit: diff e x = App ("d/d" ++ x) [e]
05:01:13 <quest> pordan30 im sorry i couldnt grasp what you are trying to explain. ._.
05:01:55 <Jafet> On another note, neither 0, 1, 2, nor "2x" are of the type Expr.
05:02:48 <quest> Jafet owh yeah! so i should write Num 1, Num 2...app + (Num 2, Id x)
05:02:49 <quest> ?
05:03:12 <Jafet> Maybe. Do you know the rules for differentiation?
05:03:15 <quest> pordan3- i get what you mean in define chg in another place now.
05:03:29 <quest> Jafet well i know how to differentiate
05:05:06 <Jafet> If you write down all the rules that contain two subexpressions, you have probably finished the assignment.
05:05:30 <srhb> sshine: I don't experience that behaviour.
05:05:47 <quest> pordan30 i wanted to define chg outside but I dont knwo what is the type in the output, because it is all + - * /........
05:07:21 <pordan30> it's a function : chg :: Num a => String -> (a -> a -> a). on another note, you can eliminate it altogether and pattern match on "+", "*", "sin", etc.
05:08:05 <srhb> sshine: Can you show a minimal case?
05:08:39 <pordan30> or i guess you're using floats, so float -> float -> float
05:09:16 <hpaste> quest pasted “trial 3” at http://hpaste.org/77312
05:09:31 <edsko> which machine does the code builds on Hackage? anyone know?
05:09:43 <edsko> in particular, can I find out somewhere which versions of C libraries are installed there?
05:11:59 <tomboy64> is ncurses recommended for creating console applications with haskell?
05:12:16 <tomboy64> or is there a more haskell-native approachß
05:12:17 <tomboy64> ?
05:12:27 <Jafet> forall n. n curses
05:12:33 <ivanm> there's also vty
05:12:42 <ivanm> I think there's a few ncurses bindings on hackage
05:12:45 <fmap> tomboy64: I use vty-ui
05:14:17 <tomboy64> hmm
05:14:30 <tomboy64> vty seems to be what i'm looking for
05:14:54 <tomboy64> any infos whether how it fares on windows?
05:15:56 <tomboy64> oh
05:15:56 <fmap> I think it's limited to linux and bsds
05:15:58 <Jafet> The position that Windows doesn't really have a terminal has always worked for me
05:16:15 <tomboy64> vty and vty-ui are different?
05:16:31 <fmap> vty-ui is widgets on top of vty
05:17:29 <tomboy64> ah, kay
05:17:32 <tomboy64> thx
05:18:26 <pordan30> quest: using your datatype, you basically want a function that looks like this: <http://hpaste.org/77313> you're making your assignment a little too complicated, and the underlying datatype isn't helping you out.
05:20:14 <hpaste> quest pasted “trial 4” at http://hpaste.org/77314
05:20:42 <quest> pordan30 owh i get what you meant now, trial 4 was what i had been doing.....i guess its way too redundant
05:21:14 <Jafet> I have a feeling this homework was stolen from http://mitpress.mit.edu/sicp/full-text/book/book-Z-H-16.html#%_sec_2.3.2
05:21:42 <quest> im from imperial london
05:23:27 <pordan30> i thought the empire died out years ago
05:23:59 <Jafet> Naw, it's just resting.
05:24:38 <quest> im terribad in programming, fresher 5th week then they throw in these assessments, all my classmates had submitted T_T haskell exam next week.
05:30:37 <bitonic> quest: where are you sitting?  I'm at the round tables :D
05:30:46 <quest> im at home
05:30:50 <quest> you finished your homework?
05:30:54 <quest> wait, are you fresher??
05:31:03 <bitonic> oh.  I'm always at the round tables anyway.  you can ask me about Haskell
05:31:05 <bitonic> no, 4th year
05:31:06 <quest> as in, at southside hall...
05:31:13 <quest> owh yay!!!!!!!
05:31:44 <quest> can i have your id for email?
05:31:59 <quest> mine is yn412, then i can ask you question or even identify your location in lab?
05:32:18 <quest> doc.ic.ac.uk/labmap is useful :p
05:33:49 <bitonic> yeah it's quite cool, anyway I'm always at the round tables you can just ask me directly, just ask me via IRC when you are in the labs
05:33:55 <bitonic> well not *always* :P
05:34:25 <deech> Hi all, I see the words "{un}decidable" and "{non}-terminating" a fair amount in context of type systems. Is there a source that explains what that means?
05:34:51 <Jafet> http://en.wikipedia.org/wiki/Rice's_theorem
05:35:13 <pordan30> http://en.wikipedia.org/wiki/Undecidable_problem
05:36:00 <Jafet> You just googled "undecidable", didn't you
05:36:35 <deech> Jafet: yes and I've read the wikipedia article. I just don't know how to apply it to type systems.
05:36:37 <fujisan2> not able to be firmly established or refuted. << no google dictionary builtin OS X
05:37:00 <bitonic> deech: well undecidable usually refers to two things: inference is undecidable, which means that there is no algorithm that correctly identifies the (most principal) type for every expression
05:37:03 <pordan30> no, i wikipedia-ed for hte page :)
05:37:11 <fujisan2> the OS X dictionary even has wikipedia integrated
05:37:19 <bitonic> deech: and type checking, which means that some expression cannot be type checked
05:38:24 <pordan30> in any case: if you don't know what an undecidable problem is, you probably don't know what the computable functions, and therefore probably don't have the background necessary to understand what rice's theorem is; it provides a nicer introduction.
05:38:27 <Jafet> There aren't many type systems where type checking is undecidable
05:38:30 <deech> bitonic: So an extension like UndecidableInstances means that there are some type class instances that can't be verified?
05:38:31 <pordan30> *functions are
05:38:43 <bitonic> deech: terminating in the same field usually refers to calculi that have a finite number of computation step before reaching a normal form (that is, the "final" term)
05:38:55 <Jafet> No, it means that choosing the correct instance is undecidable.
05:39:03 <merijn> deech: Are you familiar with the halting problem?
05:39:43 <bitonic> deech: what Jafet says.  Jafet: there are interesting type systems where type checking is undecidable
05:39:54 <deech> merijn: On a broad level, namely you can't write a function that determines if another function will go into an infinite loop, right?
05:39:59 <quicksilver> well, not quite
05:40:26 <quicksilver> UndecidableInstances actually means "remove certain rather simplistic cut-offs that GHC uses to keep instance resolution decidable"
05:40:44 <quicksilver> the benefit of those cut-offs is they mean you can't send the compiler into an infinite loop
05:40:58 <quicksilver> so, with the flag set, it becomes possible to write programs which make GHC fail to terminate
05:41:04 <quicksilver> (at compile-time)
05:41:15 <hpaste> quest pasted “trial 5” at http://hpaste.org/77315
05:41:22 <quicksilver> but the *actual* instances you go on to write in useful programs will of course be decidable ones.
05:41:45 <quest> pordan30 Jafet how about this? am i on the right way? i couldnt think of exp and ^
05:41:47 <Jafet> It's effectively undecidable, because if GHC doesn't do it then it's likely that you won't bother
05:42:33 <pordan30> deech: it depends on the class of functions that you're considering. for instance, the constant function "terminates x = True" decides whether a member of a terminating class of functions terminates :) a classic example is the simply typed lambda calculus and the calculus of constructions.
05:42:51 <merijn> deech: I was going to try and explain by analogy, but then I realised either my analogy was bad, or my ability to explain it was not up to par, so I give up
05:42:55 <notdan> quest: the pattern matching looks funny
05:43:21 <notdan> For example, what about (App "+" [1,2,3])?
05:43:58 <Jafet> Well, I'd just add a final case `diff e x = App ("d/d"++x) [e]'
05:44:01 <notdan> I'd say diff (App "+" ls) = App "+" $ map diff ls
05:44:04 <Jafet> But that's me
05:44:16 <notdan> o
05:44:24 <quest> i dont understand @.@
05:44:49 <Jafet> notdan: SICP does it this way, who are you to judge man
05:45:29 <Jafet> deech: the GHC manual has an example of looping instances
05:45:46 <notdan> Jafet: sorry, I don't remember the SICP's solution, but the pattern matchng just doesnt look right, it doesnt check all the cases
05:45:49 <deech> That's a lot to think about I'll go read the page on the extension and see if I get more out of it. So far I've been adding pragmas because GHC told me to.
05:45:59 <notdan> Sorry for bad typing, got an awful keyboard in my lass
05:46:04 <notdan> *class
05:46:05 <Jafet> and how -XUndecidableInstances lets you turn ghc into a room heater
05:46:09 <mrlemao`> installed the new Hs platform. Now uninstall-hs wants to remove all my ~/Libraries/Haskell/bin, which includes executables I installed with cabal
05:46:25 <Jafet> (unless context-stack prevents this?)
05:46:33 <mrlemao`> does that mean I have to recompile all my libs/exes when upgrading the platform?
05:46:57 <cgaebel> mrlemao`: I think so. Just leave it running in a screen session.
05:46:58 <notdan> quest: ok, what about d(sin3x)/dx? According to your definition it is cos(3x)
05:46:59 <Jafet> mrlemao: you have to rebuild most packages when upgrading ghc anyway
05:47:14 <quest> owh yeah
05:47:30 <fmap> mrlemao`: you need not recompile executables though (in most cases)
05:47:46 <notdan> quest: did you write the definition for Expr yourself or was it given to you?
05:47:48 <bgamari> Does anyone know how to use Hamlet's case expressions with records?
05:47:50 <Jafet> And if your executables are linked to shared libs from packages you might need to, I don't know how stable that is
05:47:56 <quest> it was given
05:48:22 <bgamari> It seems the syntax supports neither the { } syntax nor @
05:48:22 <quest> data Expr = Num Float | Id String | App String [ Expr ]             deriving (Eq, Ord)
05:48:47 <bgamari> Meaning the only way to unpack an ADT is to pattern match against every field
05:50:01 <mrlemao`> that is a bit of a pain
05:50:41 <mrlemao`> I have installed N packages/executables. How do I get to a state where I have the same libs/exes without going through it one by one?
05:51:03 <mrlemao`> I don't mind if I have to wait, I just don't want to babysit it
05:52:43 <Jafet> cabal install world
05:56:06 <mrlemao`> Jafet: thanks. I didnt see this option in the cabal help. Is that documented somewhere?
05:56:29 <dcoutts> it's not documented because it doesn't really work well yet
05:56:39 <Jafet> It's documented by #haskell
05:56:54 <Jafet> We have elders who pass this down through oral tradition
05:57:23 <Jafet> You can also look in the file named world, which is the list of the packages that cabal install world installs
05:57:49 <mrlemao`> dcoutts, Jafet: not complaining here, but was checking if this was another case of RTFM for me
05:58:19 <mrlemao`> dcoutts, Jafet: ok, it gives me a "cabal: Could not resolve dependencies" plus a list of deps
05:59:10 <Peaker> where's lambdabot?
05:59:19 <Jafet> It would be nice if cabal-install had documentation.
05:59:19 <Peaker> @bot
05:59:48 <Jafet>     :(
05:59:51 <Peaker> dcoutts, hey, I might have some time to spare on cabal-install. I was thinking of changing all the Verbosity values being passed around to some Env or such -- so that I can add more flags that propagate everywhere
06:00:15 <Peaker> (that way I can work on the progress reports for cabal update I wanted way back when)
06:00:28 <quicksilver> this is the cabal install manual isn't it?
06:00:29 <quicksilver> http://www.haskell.org/haskellwiki/Cabal-Install
06:01:25 <Peaker> Data.Map.deleteFindMin :: Map k a -> ((k, a), Map k a)      -- I wonder how to compose this with a lens.  I could wrap it in a State constructor. anything else?
06:02:11 <Jafet> It definitely has the potential to be
06:02:29 <donri> hm wasn'd 7.4.1 in previous platform?
06:05:54 <mrlemao`> cabal install world is rejecting some dependencies. Is there a way to force it or even hack the world file?
06:09:02 * hackagebot polimorf 0.4.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.4.0 (JakubWaszczuk)
06:09:59 <Jafet> Just install the packages that you want from the world file then
06:12:02 <nand`> do type signatures have to be included in export lists?
06:12:04 <nand`> uh
06:12:06 <nand`> type aliases*
06:12:33 <Peaker> type synonyms?
06:12:52 <Peaker> nand`, any name you want to be exported, yeah, including synonyms.
06:13:04 <Jafet> Have to be? No
06:13:23 <nand`> that was a fairly bad question
06:13:31 <nand`> but Peaker guessed my intent, thanks
06:13:39 <arbn> Peaker: Can't you reference the type if you exported a function with that signature?
06:13:51 <arbn> With the type in its signature, I mean.
06:13:51 <Peaker> arbn, the type, yeah, the synonym, no
06:13:58 <Peaker> arbn, or rather, you can refer to anything that exported names let you
06:14:18 <Peaker> if missing exported names, you might even have trouble referring to types you get as actual results
06:14:49 <arbn> If I export f, and f :: Apple -> Orange, and Orange is a synonym to X, can I use Orange as a type-name outside the module, or must I use X?
06:15:15 <Peaker> arbn, you can only use Orange or X according to each of theirs exported status
06:15:59 <arbn> OK. Makes sense. Exporting a function doesn't implicitly export the types its over. You might have trouble, as you said.
06:16:14 <arbn> it's over*
06:16:39 <Jafet> It's not over yet!
06:16:55 <arbn> Hehe.
06:17:26 <Peaker> a bit frustrating that building Cabal requires compiling every part of it, twice
06:19:03 * hackagebot ply-loader 0.1.0.1 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.1.0.1 (AnthonyCowley)
06:22:07 <Cale> It is somewhat unfortunate that type synonyms don't interact better with the module system.
06:23:27 <nand`> hmm
06:23:33 <nand`> TardisT isn't on hackage?
06:24:17 <nand`> oh, it is
06:24:18 <typoclass> nand`: the zip file is only 300k from the outside, but much bigger inside
06:24:23 <nand`> hoogle just didn't index it
06:24:41 <Cale> It would be nice in some ways if you could export the name of a synonym, but not the equality constraint that it represents.
06:25:11 <Peaker> newtype?
06:25:14 <Jafet> Isn't that known as a newtype
06:25:26 <Cale> Well, yes, but internal to the module it certainly looks different.
06:25:28 <Jafet> Maybe for instance resolution
06:26:14 <Cale> i.e. at the module boundary it would become as if you'd used a newtype
06:29:03 * hackagebot concurrent-supply 0.1.2 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.2 (EdwardKmett)
06:33:29 <tikonen> What is good way to use global variable? My use case is that I need to assign unique id for sockets created in separate forkIO threads. Now I'm using newTVarIO
06:35:22 <Cale> tikonen: TVars are good. You don't usually need global variables -- you're creating the threads presumably in somewhere close to the same place, so you can create a TVar or MVar or whatever just before the forkIO, and use it in the construction of the IO action you're forking.
06:36:58 <tikonen> Cale, that would be the optimal case, but my code gets called by external library so I have no control in what thread and when it gets called
06:38:03 <tikonen> but thanks for confirming that TVars are ok for that purpose
06:38:25 <t7> topic is out of date!
06:39:03 * hackagebot bindings-sc3 0.4.1 - Low-level bindings to the SuperCollider synthesis engine library.  http://hackage.haskell.org/package/bindings-sc3-0.4.1 (StefanKersten)
06:40:06 <Cale> I'd usually tend to prefer any solution which avoided using unsafePerformIO to create top level mutable state, especially in the context of a library.
06:40:28 <Cale> But I don't know exactly what you're trying to do.
06:42:12 <tikonen> Cale, I'm writing create/destroy functions for using Data.Pool
06:42:21 <tikonen> I need to pool sockets
06:43:59 <Cale> If you can have a data structure representing the pool of sockets, then the problem is easy :)
06:50:04 <qnikst> how to get back leftovers in conduit, i.e. if I have sink: CB.lines =$ CL.take 1; it will consume all lines and not only first one, is there a way to consume only first one?
06:51:14 <Sonderblade> String, ByteString, LazyByteString, Text... there are so many string types in haskell :)
06:51:26 <edwardk> Sonderblade: for good reason
06:52:00 <edwardk> you have them in other languages too you know. =) most people just don't choose to use anything but the array of bytes version ;)
06:53:33 <Sonderblade> edwardk: e.g. in python every module uses unicode, but in haskell the modules mix and match so you have to pack and unpack the strings back and forth
06:53:34 <Peaker> edwardk, Hey, lens question: I want to use Map.deleteFindMin on a record field which is a Map, while also keeping the extra output. Currently the best way I figured is to wrap deleteFindMin with a StateT and then use "zoom". Is there a more direct way?
06:54:23 <edwardk> :t Map.deleteFindMin
06:54:40 <Peaker> Sonderblade, I think String is kinda phasing out (for "serious" code) and replaced with Text.  And ByteString/Text are really different things
06:54:42 <typoclass> Sonderblade: ByteString is a bunch of bytes. String and Text are a bunch of unicode characters
06:54:44 <Peaker> Data.Map.deleteFindMin :: Data.Map.Map k a -> ((k, a), Data.Map.Map k a)
06:54:55 <edwardk> :t traverseMin
06:55:07 <edwardk> :t Control.Lens.IndexedTraversal.traverseMin
06:55:40 <edwardk> that doesn't let you delete it though
06:56:05 <Peaker> I want to "pop" it off (it's for an LRU cache)
06:56:07 <edwardk> oh, duh, you can just use %%~
06:56:09 <edwardk> :t (%%~)
06:56:26 <Peaker> (%%~) :: LensLike f a b c d -> (c -> f d) -> a -> f b
06:56:38 <edwardk> choose f = (,) (k,a)
06:56:40 * Peaker is a manual lambdabot :)
06:57:04 <edwardk> foo %%~ deleteFindMin
06:57:21 <edwardk> or better yet
06:57:23 <edwardk> foo deleteFindMin
06:57:25 <edwardk> %%~ = id
06:57:29 <edwardk> ;)
06:57:36 <edwardk> :t _2 deleteFindMin
06:58:02 <edwardk> :t traverse deleteFindMin  etc.
06:58:05 <Peaker> hard for me to read these types, so many of them :)
06:58:18 <Sonderblade> Peaker: really? all tutorials and guides are using String. and the functions in Prelude operate on String not Text
06:58:35 <Peaker> Sonderblade, Prelude is bound by legacy. Tutorials are not "serious" code
06:59:06 <Peaker> I think some of the alternative preludes popping up are replacing String with Text
06:59:21 <nand`> @hoogle (a -> b -> m c) -> m a -> m b -> m c
06:59:24 <edwardk> it is much easier to 'think' in string. but when you need to bolt together huge chunks of text, lazy text has its uses
06:59:33 <nand`> any more elegant way to do this other than \f -> join .: liftM2 f
06:59:35 <rwbarton> (what happened to lambdabot?)
06:59:43 <Peaker> nand`, join after liftM2's 3 args
06:59:47 <tdammers> basically, String is convenient because it's always there, but Text is "better", technically speaking, and if the project is serious, the minimal extra effort pays off
06:59:57 <edwardk> nand`: not really
07:00:10 <nand`> I guess I could do
07:00:13 <nand`> join $ a <$> b <*> c
07:00:31 <edwardk> i disagree that text is better. it is better for some usecases. if you build it up character by character you'd be silly to use text for that
07:00:41 <tdammers> yeah, well
07:00:45 <tdammers> hence the quotes
07:01:00 <tdammers> I actually use String for a lot of things
07:01:21 <tdammers> stuff where performance absolutely doesn't matter at all
07:01:22 <Peaker> edwardk, if you build char by char you might still store it long-term or have other requirements which prefer Text
07:01:24 <typoclass> Sonderblade: in my opinion, String is fine for plenty of things. fot other things you need the alternative (Text)
07:01:32 <edwardk> if the values are opaque and won't be manipulated i almost always use text of bytestring.
07:01:41 <edwardk> Peaker: sure. i may convert it to text when i'm done
07:01:51 <edwardk> er text or bytestring
07:02:06 <t7> > 123
07:02:16 <t7> where is lambdabot :(
07:02:23 <Sonderblade> why not just change String then so that it uses lazy values internally? for one who is using String it doesnt matter how it is implemented
07:02:32 <t7> i have to use /eval now which is a javascript repl :(
07:04:02 <geekosaur> String is plenty lazy, that's not the problem. the problem is String is a linked list; high overhead, but easy to work with.  (You can't pattern match a Text directly, for example.)
07:05:02 <typoclass> geekosaur: pattern matching is not for serious programs! ;-)
07:06:04 <Sonderblade> but it shouldn't matter how the adt for string is implemented, should it? in many languages you have lists which are implemented as arrays for example
07:06:59 <rwbarton> but String = [Char] is just one instance of [a]
07:07:14 <rwbarton> and functions can work polymorphically on [a] for all a
07:07:45 <Jafet> You mean like python?
07:08:03 <Sonderblade> or java or c#
07:08:16 <Jafet> Go use those then
07:09:22 <rwbarton> as far as i can see you can't design a data structure that is as lazy as [a] without essentially reproducing the representation GHC uses
07:09:26 <beaky> hello
07:09:32 <beaky> hello
07:09:33 <Cale> Sonderblade: String isn't abstract.
07:09:45 <Cale> Sonderblade: String is just a synonym for [Char]
07:10:02 <Cale> and lists aren't abstract either
07:10:12 <quicksilver> maybe that's a mistake, maybe it should have been abstract - but it's really convenient being able to use list functions on Strings.
07:10:17 <beaky> is there a function for two lists equivalent to [(i, j) | i <- xs, j <- ys] ?
07:10:31 <quicksilver> beaky: liftM2 (,)
07:10:46 <quest_> hi.....is the 4th year imperial student still here? im in the lab now :(
07:10:47 <qnikst> or zipWith ,
07:10:48 <beaky> > liftM2 (,) [1..10] [1..10]
07:10:52 <beaky> :(
07:11:07 <qnikst> > zipWith (,) [1..10] [10..1]
07:11:12 <beaky> qnikst: ah thanks
07:11:12 <quicksilver> qnikst: "or" in the sense of "or, if you want something completely different, you could use zipWith (,)"
07:11:14 <rwbarton> []
07:11:17 <byorgey> qnikst: zipWith (,) = zip, but that's actually not the same thing
07:11:17 <rwbarton> that one i can do :)
07:11:35 <beaky> how do I get all the 36 possible outcomes of rolling two six-sided dice that way?
07:11:36 <typoclass> Sonderblade: in an ideal world, you could maybe change String in radical ways. but big changes always mean risk, unforeseen consequences, relearning, people getting confused. there's quite some value in having a stable, well-understood thing
07:11:46 <quicksilver> beaky: liftM2 (,) [1..6] [1..6]
07:11:48 <rwbarton> beaky: what quicksilver said and you tried first
07:11:53 <byorgey> zip [1,2] [1,2] == [(1,1), (2,2)], but  liftM2 (,) [1,2] [1,2] == [(1,1), (1,2), (2,1), (2,2)]
07:12:07 <qnikst> quicksilver: ok
07:12:28 <rwbarton> beaky: however you need to be in an alternative universe with a working lambdabot
07:12:28 <byorgey> you can get even fancier and do   replicateM 2 [1..6]
07:12:30 <quicksilver> Cale: where's your bot?
07:12:35 <byorgey> that lets you generalize to rolling more than 2 dice
07:12:42 <beaky> :D
07:13:16 <Cale> quicksilver: Don't know, I'll restart it
07:13:16 <quicksilver> [0..] >>= flip replicateM [1..6] -- this lets you roll all possible numbers of dice.
07:13:31 <beaky> why is the liftM2 version diferent from the listcomp I put first?
07:13:32 <rwbarton> "is your lambdabot running?"
07:13:41 <beaky> or the zipwith?
07:13:45 <quicksilver> beaky: it isn't different, except possibly by ordering.
07:13:47 <typoclass> (cale called her an "it" :-(  )
07:13:49 <quicksilver> but zipWith is quite different.
07:13:58 <beaky> ah right
07:14:24 <Sonderblade> typoclass: i thought that behind the scenes, haskell was smart enough to use arrays for most lists.
07:14:35 <qnikst> maybe somebody have an idea how to correclty consume only one line using conduits?
07:15:03 <quicksilver> Sonderblade: I'm afraid you were mistaken.
07:15:12 <quicksilver> Sonderblade: it's also not clear that that is always "smart".
07:15:20 <quicksilver> arrays can't be infinite and arrays can't share tails.
07:16:21 <mauke> Sonderblade: how are arrays "smart"?
07:18:07 <tdammers> Haskell doesn't use arrays for lists, but lazy evaluation avoids many of the typical performance problems
07:18:34 <tdammers> such as how a fully evaluated linked list of something small has a lot of memory overhead
07:19:03 <beaky> how does purely-functional IO work?
07:19:04 * hackagebot concurrent-supply 0.1.3 - A fast concurrent unique identifier supply with a pure API  http://hackage.haskell.org/package/concurrent-supply-0.1.3 (EdwardKmett)
07:19:08 <beaky> I want to replicate it in C++
07:19:14 <simon> how do I combine two predicates using logical and, in a pointfree style?
07:19:18 <Sonderblade> mauke: if you have a list [5, 4, 3, 2, 1], then it is short, finite and does not share a tail. a smart compiler would then decide to allocate it as an arraylist
07:19:19 <t7> beaky: oh lordy
07:19:25 <beaky> simon: liftM2 (&&)
07:19:39 <beaky> liftM2 (&&) :: Monad m => m Bool -> m Bool -> m Bool
07:19:43 <mauke> Sonderblade: why?
07:19:51 <mauke> Sonderblade: and what the hell is an "arraylist"?
07:19:56 <edwardk> beaky: let m = (->) a
07:19:56 <simon> beaky, thanks!
07:20:02 <edwardk> er simon
07:20:06 <tdammers> Sonderblade: if it's short, it doesn't make sense to optimize for memory overhead anyway
07:20:34 <tdammers> whether you allocate 40 bytes or 80 doesn't really make much of a difference
07:20:51 <aninhumer> mauke: I'd guess they're referring to the Java class, a variable sized list based on an array
07:20:52 <Sonderblade> mauke: a value that is a list implemented using an array
07:21:03 <edwardk> Sonderblade: a smart compiler might be wrong if it has some other features. in haskell those numbers are overloaded. they could be things other than natural numbers.
07:21:06 <mauke> Sonderblade: how is that different from an array?
07:21:10 <tdammers> but 'List' in Java means something entirely different than in Haskell
07:21:11 <beaky> > filter (liftM2 (&&) (>3) (/= 6)) [1..10]
07:21:13 <lambdabot>   [4,5,7,8,9,10]
07:21:17 <beaky> :D
07:21:25 <beaky> lambdabot is working
07:21:26 <edwardk> Sonderblade: they might have non-trivial conversion costs from Int, and the sharing may exceed the utility of 80 bytes of memory
07:21:41 <tdammers> Java List is an interface that describes the public interface of list-like collections
07:22:06 <tdammers> in FP land, "list" is usually taken to refer to a linked list
07:22:33 <edwardk> i would vote strongly _against_ such an optimization in general. Now. lets look at strings in haskell. if you have the string "foo" as a literal in haskell source code if you loo at the compiled c-- that results it _does_ that optimization.
07:22:58 <edwardk> it generates a flat array, and then puts a computation in that translates its to a string
07:23:18 <edwardk> this translation can vanish for the most part by the time the inliner is done with it. so its much better than you think
07:23:28 <aninhumer> Hmm, I guess the more general form would kind of be like tail call optimisation for data types?
07:23:49 <edwardk> Sonderblade: so your major complaint against strings is that it doesn't do an optimization that it does do ;)
07:23:58 <aninhumer> i.e. if the type has one recursion, append it in the same location
07:24:16 <aninhumer> Not suggesting it's a good idea, just thought that was interesting
07:24:16 <statusfailed> I have a weird error when I try to install pandoc: cabal: Codec.Compression.Zlib: premature end of compressed stream
07:24:51 <statusfailed> I think it's to do with my stupid apartment wifi's web proxy mangling data, but i'm not sure
07:26:18 <Sonderblade> edwardk: but is it only for string literals or does it work for strings read from input too?
07:27:16 <edwardk> lets look at that. the ones you read from input are read internally as bytestrings or text and then converted to a string by the reader, just like i described, so the "huge string overhead" is transient. we're lazy remember?
07:27:53 <edwardk> think of string as a facade that doesn't have to be constructed in its entirety. laziness takes care of almost all of your cost concerns here
07:28:08 <rwbarton> as long as you don't retain the input somewhere
07:28:11 <edwardk> sure
07:28:17 <edwardk> then you pay for the string for a while
07:28:24 <edwardk> and it goes away when you don't use it any more
07:28:57 <edwardk> but in general laziness makes strings a hell of a lot more efficient than you'd expect
07:29:16 <Sonderblade> great, so it *looks like* a linked list, but in reality it almost never is?
07:29:40 <mauke> define "reality"
07:29:40 <edwardk> well, it is even better its a linked list when it needs to be ;) i can cons onto it quite cheaply
07:29:49 <geekosaur> ^^ they're space-inefficient but they tend to fuse *very* well so performance is often very good and if they fuse properly the space penalty may also vanish because it never has to allocate the whole thing
07:29:59 <edwardk> and when i get down to that tail its slurping from the text chunk again
07:30:04 <typoclass> Sonderblade: it is a linked list if you would evaluate it fully. but often you don't
07:30:19 <edwardk> this is why String should never die
07:30:58 <typoclass> > take 3 $ [0..] -- Sonderblade, this for example wouldn't be possible if [0..] was a linked list that has been fully evaluated
07:31:00 <lambdabot>   [0,1,2]
07:31:43 <donri> > take 3 $! [0..]
07:31:45 <lambdabot>   [0,1,2]
07:31:50 <donri> > take 3 $ deepseq [0..]
07:31:52 <lambdabot>   Not in scope: `deepseq'
07:31:52 <lambdabot>  Perhaps you meant `rdeepseq' (imported from Contro...
07:32:02 <edwardk> donri: that ($!) only forces the head
07:32:07 <donri> i know
07:33:21 <hpaste> “error #1” pasted “quest” at http://hpaste.org/77319
07:33:36 <Sonderblade> but if String works like that.. why Text?
07:33:43 <statusfailed> Is there something wrong with the latest pandoc package on hackage?
07:33:47 <quest_> pordan30
07:33:55 <statusfailed> oh derp, build failure
07:34:28 <quest_> i have an error in my coding
07:34:29 <quest_> :(
07:34:33 <quest_> can anyone help me check?
07:34:40 <quest_> check why*?
07:35:12 <Cale> Sonderblade: Even if the whole String is not all in memory at once, each cell is pretty costly in terms of the work spent in allocation and deallocation compared to the overhead in Text.
07:35:22 <edwardk> Sonderblade: because text is better for some things as a back end representation. and some times you want to work with a string in a manner that isn't walking it hand-over-hand, char-over-char
07:35:31 <rwbarton> quest_: App "/" [[ already looks like an error
07:35:55 <edwardk> and text is cheaper for some operations, comparison, c interop, etc.
07:36:18 <quest_> Jafet
07:36:31 <quest_> rwbarton why so?
07:36:34 <Cale> Using a list to represent something is like saying "I only intend to access this data linearly"
07:36:58 <rwbarton> well it is hard to be sure without the definition of App
07:36:59 <edwardk> the way i described it the storage overhead for strings is largely solved by having conversions from bytestring and text. the performance considerations are not so much. there is still a raw constant speed advantage to text for some operations and an _asymptotic_ slowdown in others.
07:37:08 <rwbarton> but it looks like you expect App :: String -> [Expr] -> Expr
07:37:11 <jtk_> hi
07:37:13 <rwbarton> but you are passing a list of lists
07:37:29 <Sonderblade> edwardk: actually it is really seldom i've had a use for iterating a string char-by-char
07:37:43 <typoclass> quest_: [42] is a list that contains one element (the number 42). [[42]] is a list that contains one element, which is another list, which contains one element, which is 42
07:37:51 <pordan30> quest: the type error means that ghc is expecting an expr, but has been given a list. you need to combine the inner expressions using an App.
07:37:59 <Cale> I always say that a list is a loop which hasn't happened yet. Just as a loop either doesn't occur (because its precondition isn't met), or consists of a single iteration followed by another loop, a list is either empty or consists of a single element followed by another list.
07:38:13 <edwardk> Sonderblade: parsing walks it hand over hand like that, mapping, lots of operations we use in haskell ultimately do work that way
07:38:22 <edwardk> > map toUpper "hello"
07:38:24 <lambdabot>   "HELLO"
07:38:37 <edwardk> > read "10" :: Int
07:38:38 <lambdabot>   10
07:38:40 <rwbarton> length
07:38:43 <Cale> Nevermind printing to the screen works like that :)
07:38:51 <edwardk> each of those worked in the manner i described
07:39:08 <rwbarton> of course your language may pick the twenty most common things to do and hand you those in a standard library
07:39:18 <edwardk> its only when you start slicing at exact character count offsets, etc. that text starts getting asymptotic wins, and it loses asymptotically for cons, etc.
07:39:20 <rwbarton> same with Text, etc.
07:40:08 <edwardk> cons is incredibly common in haskell though. enough that we gave up (:) for it for lists/strings ;)
07:40:13 <Cale> All this having been said, it might have been good to use something like Text as the representation of String, but Text is a relatively new library.
07:40:30 <edwardk> induction/coinduction is how you reason about almost everything here. making that hard and slow is a bad idea.
07:40:44 <quest_> pordan30 found it! i actually had 1 extra square brackets that made it became a list.
07:40:53 <pordan30> yup :)
07:41:45 <Cale> But yeah, even if we had Text as the standard representation of strings, a lot of things would still work by converting to a list of Char.
07:41:56 <edwardk> the main thing i love about haskell is that laziness as a default is beautiful. you can take two unrelated algorithms compose them and get asymptotic gains. you get this with string, you _may_ get this with some text operations in limited scenarios if the fusion stuff is turned on, but you definitely get it with strings
07:41:57 <Cale> Because that's just how you loop over the elements of a Text.
07:42:27 <edwardk> 'take 10 . sort'    becomes an asymptoticaly optimal k-selection sort
07:42:33 <Cale> If you want to know why lists are popular in Haskell, you could also ask yourself why loops are popular in imperative settings.
07:42:57 <ion> funroll all the loops
07:43:09 <bartavelle> Cale, aren't map and fold optimized in Text to work on the chunks ?
07:43:13 <donri> loops are overrated, goto ftw.
07:43:21 <Nisstyre> if you want to know why lists are useful then learn Scheme
07:43:40 <Nisstyre> or read SICP or something
07:43:48 <Cale> Scheme has a weirdly deficient list library
07:43:56 <Nisstyre> meh, I use Racket
07:44:02 <Nisstyre> which has an immaculate list library
07:44:23 <rwbarton> what more do you need than cons, car, cdr, caar, cadr, cdar, cddr, caaar, ...
07:44:28 <cgaebel> I use haskell, which has a much nicer library. :)
07:44:40 <t7> whats caaar ?
07:44:44 <Nisstyre> rwbarton: you forgot cadaaar
07:45:02 <Nisstyre> t7: (car (car (car xs)))
07:45:08 <rwbarton> my irc client broke my fingers after caaar
07:45:12 <Jafet> It's like those stretched limousines
07:45:20 <edwardk> rwbarton: ouch
07:45:53 <arbn> Those are pretty awesome when you take into account that they historicaly were ops on registers.
07:46:12 <t7> > let cons = (:); nil = []; car = head; cdr = tail in car (cons 1 (cons 2 nil))
07:46:14 <lambdabot>   1
07:46:29 <Cale> Nisstyre: I forget which operations exactly it was missing, but I found myself surprised about things that I couldn't seem to find. Perhaps an equivalent of groupBy was one of them?
07:47:12 <Nisstyre> http://docs.racket-lang.org/unstable/list.html?q=group%20by#(def._((lib._unstable/list..rkt)._group-by))
07:47:28 <mrlemao`> cabal 1.16 is much faster than 1.14
07:47:30 <fari> hi everybody, i'd like to ask you for help woth following problem
07:47:39 <hpaste> quest pasted “error #2” at http://hpaste.org/77320
07:48:01 <quest_> im encountering another error, can anyone help me?
07:48:30 <rwbarton> quest_, you should learn to read ghc error messages
07:48:34 <rwbarton> the error is very much like the first one
07:49:02 <quest_> it means it was expecting not a list, but i gave a list?
07:49:21 <rwbarton> no, you didn't, read the rest of the error
07:49:23 <cgaebel> quest_: not for the first App
07:49:49 <cgaebel> in the second argument of App (the first one) GHC is expecting a list of Expr
07:49:52 <cgaebel> you gave it an Expr
07:50:09 <cgaebel> The simple solution for this is to enclose the second App in a singleton list
07:50:14 <cgaebel> unless, of course, that's not what you intended
07:51:48 <fari> i have been trying to do lazy input frome file, but i can't make that working. What I am tryinng to do is i have bunch of files on disk, every file contains name of another file. I would like to write a function String -> IO [String] which gets a first file and returns list of names of others in order they are read, but i would like to read just first few of that files and ignore that at some point further the file of given name does not exists. Can anyone hel 
07:52:09 <nand`> is there some lazy :: IO [Word8] that doesn't read chunk-wise like ByteStrings do?
07:52:45 <fari> I made some attemps with difrent source codes, but it did not help. Can you suggest some article or page? Thx
07:53:42 <nand`> oh, Lazy ByteString with the right input buffering should work
07:55:04 <fari> tha
07:55:39 <fari> the Lazy ByteString is solution to my problem or is it to something completelly different?
07:56:43 <quest_> thankyou cgaebel
07:57:10 <Cale> fari: I'm not sure I understand what it is that you're having trouble with.
07:57:17 <nand`> fari: unrelated
07:57:33 <Cale> fari: What have you tried?
07:58:21 <fari> well, few approaches, i can put source code somwhere. Shoild i paste it directly here, or link to some web page?
07:58:30 <beekor> can i bind <- everywhere or just in a do-block ?  i'm trying to impose logic on the question and i'm not sure still.
07:58:52 <Cale> beekor: <- is part of the syntax of do-expressions
07:58:58 <beekor> okay. thanks.
07:59:03 <Cale> beekor: It's also used in a couple other places in the Haskell syntax
08:00:16 <beekor> i've got a small function that connects to a DB and ends up with   result <- fetchAllRows state   .    and I'm trying to separate my processing of out from the DB-get.
08:00:34 <beekor> i'm trying to determine how best to pass it to another function.
08:00:54 <Cale> Well, what's the type of result?
08:00:59 <beekor> my instinct was to return result, which gives me an IO result,
08:01:03 <beekor> which i think is not what i want.
08:01:32 <Cale> Well, you're more likely to want to pass result as the parameter to some function which will compute something else, which you either return, or do some output based on.
08:02:17 <Cale> Consider the program:   do x <- getLine; putStrLn (reverse x)
08:02:18 <beekor> i guess my Q then was that i'm not sure how to get that function to give 'result'
08:02:26 <Cale> reverse :: String -> String  is a pure function.
08:02:26 <fari> Cale: this is piece of code, which shows my problem: http://files.farka.eu/pub/test.hs , rather my misuderstanding i'd say
08:02:37 <beekor> okay.  considering.
08:03:04 <beekor> that goes in String and out IO, i'd say.
08:03:04 <Cale> reverse doesn't need to know or care that the string we're giving it is the result of doing I/O
08:03:22 <beekor> hmm k
08:03:32 <Cale> and it also doesn't need to know that we're going to print its result back to the terminal
08:03:43 <Cale> It is just taking a String and producing a String
08:03:51 <beekor> in isolation.  gotcha.
08:04:25 <Cale> The IO action we're staring at is using it -- passing it a String obtained from the user, and then doing some output based on its result
08:05:53 <beekor> my    <- fetchAllRows comes out with IO [SQlValue], which i guess i'm  hmmmm
08:06:07 <Cale> So result :: [SqlValue]
08:06:16 <nand`> I'm confused. This test programs works fine: http://bpaste.net/show/56225/ (I get output immediately after every keystroke) but in my larger program, it doesn't work; even though I'm using the same Data.ByteString.Lazy.getContents, Data.ByteString.Lazy.putStr and hSetBuffering
08:06:36 <beekor> always nice to talk out a problem.  i was having problems figuring out how to get out from IO to a solid String, and I was trying to bind, hence my initial thoughts.
08:06:52 <beekor> but I realize i have a function that uses fromSql 's
08:06:57 <Cale> beekor: To get a String, you run the IO action.
08:07:13 <Cale> oh, well, yeah
08:07:15 <nand`> in my larger program, if I set buffering to NoBuffering I don't get any output at all (I don't know the cause); and if I leave it default or set it to LineBuffering, I get output on EOF (^D)
08:07:17 <nand`> but not on linebreak
08:07:17 <beekor> run IO.  as in more than binding in a do ?
08:07:29 <Cale> You'll need to mess around with that list of SqlValues
08:07:38 <beekor> yeah, i got that, and it surprisingly works.
08:07:44 <Cale> Because apparently you don't know that it's a String yet :)
08:07:52 <beekor> i'm still not good with the structure.
08:07:54 <beekor> haaa
08:08:01 <Cale> But yeah, if you have an IO String
08:08:02 <beekor> hey, i'm getting there.
08:08:07 <Cale> Say, x :: IO String
08:08:08 <quicksilver> nand`: your behaviour is nothing to do with the hSetBuffering kind of buffering.
08:08:13 <Cale> and you write  v <- x  in a do-block
08:08:15 <Cale> then  v :: String
08:08:19 <nand`> quicksilver: okay, then I misunderstood
08:08:29 <beekor> yeah, that was my goal right there.  hmm.
08:08:39 <Cale> and you can pass it off to something which doesn't need to know or care that it had anything to do with IO
08:08:47 <quicksilver> nand`: what your code would normally say, if getContents wasn't composed of pure evil, is "get all of the stream, and then print it"
08:08:48 <beekor> i guess i didn't think i needed a do there.  hmmm.  okay.
08:08:54 <Cale> and then do some more IO with the result of whatever that was
08:08:55 <quicksilver> nand`: so in that case you'd see nothing until EOF>
08:09:08 <Cale> because otherwise, what's the point? :)
08:09:08 <beekor> yeah gotcha.  thanks for the talk-out, eh.
08:09:20 <quicksilver> nand`: however, getContents uses interleaved IO to build up a lazy bytestring which putStr can consume bit by bit.
08:09:33 <quicksilver> nand`: but you get *no* guarantees as to how that interleaving works.
08:09:47 <quicksilver> nand`: it could quite reasonably be anything.
08:09:52 <quicksilver> interleaved IO is not controllable.
08:10:00 <Cale> fari: I'm still pretty confused about what the problem is here. If you run this, of course, it's going to try to read both of the files. There's nothing here to suggest that it shouldn't.
08:10:10 <quicksilver> nand`: does that help?
08:10:14 <typoclass> nand`: not sure if it's related, but if you do stuff like "grep ... | yourprogram", you often won't get input because grep is buffering it. some tools have a switch to reduce output buffering (e.g. for grep it's --line-buffered or some such)
08:10:38 <rwbarton> nand`, maybe your program is just not that lazy in its input String?
08:10:59 <rwbarton> hSetBuffering stdin  NoBuffering is voodoo, it actually changes terminal flags and such
08:11:13 <rwbarton> to put the terminal in raw mode rather than cooked mode
08:11:20 <rwbarton> i don't know what effect that has on ctrl-D
08:12:21 <rwbarton> looks like it causes ctrl-D to literally send a ctrl-D character
08:13:06 <rwbarton> so all of your observed behavior would be consistent with your larger program demanding all its input before being able to produce output
08:13:24 <fari> Cale: ok, then i would like to write such a code, which allows me to read just the first few of resulting list, regardless of whether following files exists or does not exists. Is there a way how to write such a function resulting "lazy list of contents of the files"?
08:13:42 <nand`> rwbarton: that may be possible; I'm not sure how exactly I could figure this out - semantically, it *shouldn't* - basically, the program is an interpreter for a language and I'm running that language's version of a ‘cat’ program (read from a file); so the interpreter is doing something like readChar >> writeChar >> readChar >> ...; where ‘readChar’ is deconsing the input [Word8] and ‘writeChar’
08:13:44 <nand`> is appending to the output [Word8]
08:14:01 <quicksilver> I think your problems will be clearer if you avoid interleaved IO.
08:14:06 <rwbarton> not really
08:14:07 <Cale> fari: There's a way to do it, but it's not the usual way to do anything.
08:14:07 <nand`> the former of which is lazily obtained from unpack <$> BS.getContents; and the latter is (lazily?) written using BS.putStr . pack
08:14:12 <quicksilver> if you ditch the interleaved IO then it's up to you to choose when the IO happens
08:14:17 <rwbarton> is the interpreter a pure function String -> String? (or ByteString or whatever)
08:14:19 <quicksilver> so your problems are at least your own fault.
08:14:39 <rwbarton> oh Word8, ok
08:14:41 <nand`> the interpreter is basically [Word8] -> [Word8]
08:14:45 <rwbarton> okay, good
08:14:50 <nand`> but it *should* be relatively lazy in those
08:14:52 <rwbarton> then try calling it on something like (0:undefined)
08:14:54 <rwbarton> to test laziness
08:14:58 <nand`> yeah, I'll do that
08:15:19 <Cale> fari: You could write   do xs <- unsafeInterleaveIO (readFile "file1"); ys <- unsafeInterleaveIO (readFile "file2); return [xs, ys]
08:15:34 <typoclass> nand`: just for testing, try to hGetContents from a file, not stdin. i still think it could be some pipe buffering snafu (i've wasted hours on that kind of thing)
08:15:36 <Cale> oops, missed a quotation mark
08:16:31 <Cale> fari: But this isn't the sort of thing to take lightly.
08:17:12 <Cale> It would be better to just catch the error from opening the second file and produce an empty list as the result in that case.
08:17:26 <Cale> (or something like that)
08:17:40 <nand`> rwbarton: f [1,2,3,undefined] => [1,2,3*** Exception: Prelude.undefined
08:17:49 <rwbarton> that's not the same
08:18:10 <rwbarton> the whole spine is well-defined there, just an element is undefined
08:18:16 <nand`> oh
08:18:16 <rwbarton> try f (1:2:3:undefined) too
08:18:22 <nand`> you're right
08:18:32 <nand`> same result
08:18:51 <rwbarton> hmm, odd
08:18:58 <rwbarton> well
08:19:04 <rwbarton> what does pack do, I wonder
08:19:21 <rwbarton> using lazy pack right?
08:19:32 <nand`> yeah
08:20:17 <nand`> let me test swapping out ‘print’ for LBS.putStr . LBS.pack
08:20:47 <nand`> same thing, waits until EOF to print out the entire list
08:20:48 <rwbarton> pack uses chunks of size 32
08:20:55 <rwbarton> it looks like
08:21:20 <rwbarton> how big is your test input?
08:21:26 <nand`> I tried inputting ~80 characters in one line, still waits until ^D
08:21:36 <nand`> rwbarton: arbitrary, I'm just typing out characters here
08:21:40 <rwbarton> oh you're using getContents, that is chunks of a large size
08:21:42 <rwbarton> like a few kilobytes
08:21:46 <nand`> oh
08:21:47 <rwbarton> but wait
08:21:52 <rwbarton> hmm
08:21:55 <rwbarton> why did your test program work then
08:22:06 <nand`> yes
08:22:13 <rwbarton> well
08:22:17 <nand`> if I input a few thousand characters at once I get output somewhere in the middle
08:22:18 <fari> Cale: thx, I am probably just taking wrong approach to the problem. I'll try to describe how did I get to the problem, maybe you can give me some hint.
08:22:29 <rwbarton> just for kicks, try all your unpack <$> BS.getContents / BS.putStr . pack stuff in a test program
08:22:35 <rwbarton> with id as your "interpreter"
08:22:39 <rofer> If I have an older version of base installed than a package requires is it possible to install this package without installing a newer version of GHC?
08:23:14 <sclv_> no
08:23:21 <typoclass> nand`: yeah, that's pipe buffering. some buffer waits until it has 4096 bytes input or whatever, then passes it on all at once
08:23:23 <t7> > 1000 / 5
08:23:25 <lambdabot>   200.0
08:23:31 <sclv_> but depending on the package you can patch it to work with an older base
08:23:55 <rofer> sclv_: Thanks
08:24:19 <sclv_> some packages may work with an older base anyway and just be restrictive in .cabal deps
08:24:21 <typoclass> nand`: honestly, you'll make your life easier if you just read it from a file :-)
08:25:10 <rwbarton> can you just use ordinary getContents / putStr?
08:25:53 <nand`> rwbarton: here you go
08:26:15 <hpaste> nand` pasted “LBS.getContents example” at http://hpaste.org/77323
08:26:27 <nand`> this one outputs on EOF or a few thousand chars
08:26:49 <nand`> rwbarton: I could use ordinary getcontents / putStr but I'd like to avoid unicode mangling or stuff; multi-byte characters should be fed byte per byte
08:27:10 <nand`> the domain of the program is really a stream of bytes, not a stream of characters
08:27:23 <rwbarton> ok right
08:27:37 <rwbarton> somehow i had the idea you were using .Char8, but you're not
08:30:39 <atriq> Is there a cool list of "Packages that aren't in the Platform but you need to know about" lurking anywhere?
08:32:29 <typoclass> atriq: i don't know about a list like that, but if you find, one tell us :-) sounds quite useful
08:32:42 <nand`> (alternatively, I could just go ahead and wrap them modulo 256 with fromIntegral . ord; there's not really a fully valid specification on this thing I'm writing so both would be equally wrong)
08:32:46 <atriq> Sounds like an oppurtunity
08:32:50 <typoclass> er, comma, wrong place
08:33:47 <rwbarton> nand`, your http://hpaste.org/77323 works for me as expected if I add the hSetBuf incantations, though
08:34:17 <rwbarton> as in, outputs after every input keypress
08:34:46 <hpaste> nand` annotated “LBS.getContents example” with “LBS.getContents example (annotation)” at http://hpaste.org/77323#a77324
08:34:48 <nand`> rwbarton: like that? ^
08:34:53 <nand`> this program doesn't output anything for me
08:34:59 <rwbarton> add output too
08:35:13 <rwbarton> because otherwise output is line-buffered by default, and you don't ever produce a newline
08:35:19 <rwbarton> stdout i mean
08:35:31 <fari> Cale: I was playing with tagsoup library for parsing html pages. The thing is i have the web page, list of articles, 10 articles by page and pager with next page of the list. What i would like to do is get a "lazy list" of articles, so I can have a names of let's say first 15. But of course i don't want to load all pages of the list with all the articles, but first 20 pages. I originally though such a code I have presented coul'd do the trik, but I probably mis
08:35:37 <nand`> (oh, it does output something after what I can only assume is 4k characters)
08:35:50 <nand`> (but ignores ^D, which is not the intent either)
08:35:52 <rwbarton> that is because you hit the limit of the output buffer
08:35:58 <rwbarton> and that is because the terminal is in raw mode
08:36:02 <Cale> fari: your message ended with "but I probably mi"
08:36:11 <rwbarton> Cale: next letter is s
08:36:15 <nand`> ah yes, with stdout as well it works
08:36:56 <fari> Cale: but I probably miss something :)
08:38:31 <donri> fari: note that tagsoup is best for tag soup, not so much for html pages
08:39:24 <nand`> actually, now that I think about it, I'm fine with ^D being interpreted literally
08:39:31 <nand`> EOF should be the stream being closed
08:39:37 <fari> donri: txt, i just play around with haskell and this was first library for parsing html i liked :)
08:40:21 <nand`> rwbarton: so apparently now my program works (with hSetBuffering on both); but this is still the version with ‘print’. Let me see if changing ‘print’ to the old BS.putStr . BS.pack re-breaks it
08:41:31 <nand`> ah, bingo
08:41:49 <rwbarton> yeah, BS.pack seems to be not very lazy
08:42:02 <rwbarton> > 1
08:42:03 <lambdabot>   1
08:42:14 <rwbarton> > LBS.pack [0]
08:42:15 <lambdabot>   Not in scope: `LBS.pack'
08:42:16 <lambdabot>  Perhaps you meant one of these:
08:42:16 <lambdabot>    `BS.pack' (imp...
08:42:24 <nand`> > BSL.pack [0]
08:42:24 <rwbarton> i probably didn't!
08:42:25 <lambdabot>   Chunk "\NUL" Empty
08:42:26 <rwbarton> thanks
08:42:42 <rwbarton> > BSL.pack $ replicate 1000 [0] ++ undefined
08:42:44 <lambdabot>   Couldn't match expected type `GHC.Word.Word8'
08:42:44 <lambdabot>              with actual type...
08:42:54 <rwbarton> > BSL.pack $ replicate 1000 0 ++ undefined
08:42:56 <lambdabot>   *Exception: Prelude.undefined
08:43:00 <rwbarton> > BSL.pack $ replicate 4000 0 ++ undefined
08:43:02 <lambdabot>   *Exception: Prelude.undefined
08:43:05 <rwbarton> > BSL.pack $ replicate 10000 0 ++ undefined
08:43:07 <lambdabot>   *Exception: Prelude.undefined
08:43:13 <rwbarton> hm
08:43:15 <nand`> well there's your problem
08:43:19 <rwbarton> > BSL.pack $ replicate 1000000 0 ++ undefined
08:43:21 <lambdabot>   Chunk "\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL...
08:43:28 <rwbarton> indeed
08:44:02 <nand`> > BS.fromChunks . map (BS.pack . return) $ replicate 10 0 ++ undefined
08:44:04 <lambdabot>   Not in scope: `BS.fromChunks'
08:44:04 <lambdabot>  Perhaps you meant one of these:
08:44:04 <lambdabot>    `BSL.from...
08:44:08 <nand`> > BSL.fromChunks . map (BS.pack . return) $ replicate 10 0 ++ undefined
08:44:10 <lambdabot>   Chunk "\NUL" (Chunk "\NUL" (Chunk "\NUL" (Chunk "\NUL" (Chunk "\NUL" (Chunk...
08:44:23 <rwbarton> anyways you could write something like mapM_ (\w -> BS.putStr $ BS. ... yeah that works too
08:44:45 <nand`> @hoogle Word8 -> IO ()
08:44:46 <lambdabot> GHC.IO.Buffer writeWord8Buf :: RawBuffer Word8 -> Int -> Word8 -> IO ()
08:44:46 <lambdabot> Control.Concurrent.SampleVar writeSampleVar :: SampleVar a -> a -> IO ()
08:44:46 <lambdabot> Foreign.Storable poke :: Storable a => Ptr a -> a -> IO ()
08:47:13 <neutrino> hey guys
08:47:29 <neutrino> i have a constructor which I use often, in another module, it's called, say, X.Flummox
08:47:36 <neutrino> can I somehow alias it to just F?
08:48:02 <ChristianS> F = X.Flummox
08:48:16 <rwbarton> no
08:48:28 <neutrino> nope, doesn't work
08:48:37 <neutrino> i tried that before
08:48:45 <neutrino> i also tried type F = X.Flummox
08:48:59 <rwbarton> you mean a data constructor right
08:49:02 <neutrino> yes
08:49:16 <rwbarton> yeah, you can't rename it for pattern-matching purposes
08:49:29 <neutrino> i just want to construct values of it
08:49:31 <rwbarton> you can rename it as a value, to a value name
08:49:34 <rwbarton> f = X.Flummox
08:49:38 <neutrino> hmm
08:50:00 <ChristianS> oh, right
08:50:33 <nand`> hmm, it seems the rest of my program is not lazy as I would like it to be in another aspect; the function that builds the interpreter itself
08:51:59 <rwbarton> i see, default chunk size for pack in 7.4 was a little less than 32k but i was looking at 7.6 source
08:52:23 <rwbarton> which uses 32 bytes for the first chunk and then scales upward
08:53:03 <rwbarton> i need LXR for hackage
08:54:51 <nand`> :(
08:55:01 <nand`> the reason my program was not as lazy as it ought to be was because I was using lenses in a specific way
08:55:20 <nand`> let (a,b) = g x in (f a, b)
08:55:30 <nand`> versus:  _1 %~ f $ g x
08:55:48 <S11001001> nand`: maybe not; edwardk loves strictness and side effects, and lens is insidious
08:57:01 <rwbarton> _1 could be lazyified i guess
08:58:36 <nand`> it could
08:58:45 <nand`> I reimplemented it with ~(a,b) instead of (a,b)
08:58:47 <nand`> and it works fine
08:58:50 <rwbarton> though that would probably be bad for some other common uses
08:59:23 <nand`> @ask edwardk could _1 be lazified to ~(a,b)? A certain program of mine is too strict due to use of that lens, but with the irrefutable match it works as expected
08:59:24 <lambdabot> Consider it noted.
09:01:26 <neutrino> right rwbarton that worked, thanks a lot
09:02:07 <nand`> I'll switch to the let-bound version
09:02:16 <nand`> probably clearer, definitely clearer than rolling my own lens
09:07:38 <nand`> rwbarton: I'm still trying to figure out a nice, lazy way of printing the [Word8]; I imagine building a bunch of size-1 bytestrings then combining them with fromChunks is probably not the most awfully efficient or clean way to do things
09:08:04 <nand`> surely there must be some Word8 -> IO () analogous to BS.putStr . BS.pack . return
09:12:33 <neutrino> hey, guys
09:12:57 <neutrino> i need to do some testing on my program. in specific i want to define some inputs and expected outputs and be able to run all tests for the module. how do i do that?
09:13:29 <neutrino> this logic is somewhat non-obvious and i need to have some tests
09:13:57 --- mode: ChanServ set +o mauke
09:13:57 --- topic: set to '["GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.4: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by mauke
09:14:33 <mzero> neutrino: see HUnit and QuckCheck packages
09:14:46 <neutrino> why would i use one over the other?
09:14:49 <neutrino> i heard of quickcheck
09:14:57 <neutrino> not heard of hunit
09:15:01 <neutrino> never used either
09:15:14 <nand`> I guess hunit is for unit testing; QuickCheck is for property testing
09:15:17 <S11001001> quickcheck is more exciting
09:15:26 <mzero> Hunit is more like traditional unit tests - you define test cases of computation and expected output
09:15:57 --- mode: mauke set -o mauke
09:16:08 <mzero> quickcheck you define properties for arbitrary input (like "after running frooble over [Int], there should be no odd numbers over 10") and it generates all the test cases auto-magically
09:16:10 <neutrino> quickcheck does some sort of fuzzing that i know of
09:16:27 <nand`> QuickCheck randomly generates inputs
09:16:27 <neutrino> but does quickcheck not allow you to specify inputs?
09:16:32 <neutrino> at all?
09:16:37 <nand`> not that I know of
09:16:43 <Cale> Of course it does
09:16:45 <mzero> but for starters, you can often just define a module local only function that has input, compares to expected otuput and then just run it in ghci
09:16:56 <neutrino> well because this thing has to take specific inputs for "success"
09:17:05 <neutrino> it's a command-line parser
09:17:08 <mzero> neutrino: you need both, generally, for a full testing solution
09:17:09 <neutrino> so obviously it'll only "work"
09:17:18 <neutrino> Cale: do you concur with mzero?
09:17:29 <Cale> You can not only use Boolean values as tests, but also you can specify random generators to use.
09:17:32 <mzero> many people use only QuickChek , though
09:17:46 <Cale> Both what?
09:17:52 <otters> does 2012.4 correspond to GHC 7.4.2
09:18:15 <Cale> Oh, no, QuickCheck is enough. Unit tests are just the special case of QuickCheck tests with no parameters.
09:18:18 <nand`> looks like ByteString uses hPutBuf under the hood
09:18:37 <neutrino> Cale: yeah, but can i use quickcheck to check that foo "frob" "zuuw" will equal 2 whereas foo "frob" quax for any quax will equal 3?
09:18:54 <Cale> yes
09:19:05 <neutrino> does quickcheck come with a "runner"?
09:19:25 <neutrino> some sort of invocation from bash to show me which tests work and which fail?
09:19:30 <neutrino> in that case i'd check out quickcheck
09:19:47 <typoclass> neutrino: i'm a fan of doctest. it's dead easy to use. you just write ">>>" inside a {- | haddock comment -}, put in the function call or whatever, and the expected output. the great thing is that they also are examples that show up in the haddock html output. and you test stuff with "doctest yourfile.hs"
09:19:57 <S11001001> neutrino: there are properties even in something like that. For example, given a set of legal options, should it be legal to specify any of the powerset of that set?  If so, you can test that with quickcheck.
09:20:14 <Cale> prop_fooFrobZuuw = foo "frob" "zuuw" == 2 -- no parameters here
09:20:39 <Cale> prop_fooFrobX = x /= "zuuw" ==> foo "frob" x == 3
09:20:43 <Cale> oh
09:20:47 <Cale> prop_fooFrobX x = x /= "zuuw" ==> foo "frob" x == 3
09:21:04 <neutrino> that's pretty cool
09:21:04 <Cale> Or you could combine them
09:21:11 <Cale> But it's better to have them separate
09:21:14 <neutrino> combine with "if then else"?
09:21:24 <quicksilver> doctest isn't incompatible with quickcheck, of course
09:21:25 <Cale> More likely using ||
09:21:26 <neutrino> or some combinator
09:21:32 <neutrino> ok
09:21:35 <quicksilver> it's perfectly reasonable to put quickcheck tests in your doctests
09:21:42 <neutrino> interesting
09:21:43 <quicksilver> and there is a module/library for that
09:21:55 <neutrino> i think i'll start with pure quickcheck and see where that gets me, then try doctests
09:22:01 <neutrino> speaking of haddock documentation
09:22:11 <quicksilver> really there are two orthogonal question (1) great ways of writing tests and (2) frameworks for collecting your tests and getting them run
09:22:17 <neutrino> i'm translating a simple command line app from python toh askell
09:22:27 <quicksilver> quickcheck is a great answer to (1) for certain kinds of program but doesn't even try to answer (2)
09:22:46 <neutrino> and in the python version, each of my subcommands is a function with a docstring. when i run myprog --help, the first line of each docstring gets printed next to the command names.
09:22:58 <neutrino> how can i extract the haddock docstring like this?
09:23:09 <neutrino> i tried googling but can't find jack
09:23:56 <mzero> neutrino: there is no equivalent for "docstrings" -- if you have many many sub commands
09:23:56 <typoclass> neutrino: i don't think that's possible, sorry. unless you want to get into template haskell territory
09:24:15 <mzero> rather than define each subcommand like so:      subcommandFoo :: [String] -> IO ()
09:24:21 <neutrino> i was told the ghci api can somehow extract haddocks
09:24:44 <mzero> instead, define it as a tuple:         subcommandFoo :: (String, String, [String] -> IO ())
09:25:14 <mzero>       so       subcommandFoo = ("foo", "does the foo thing… lots of doc here", subcommandFooExec) ......
09:25:23 <neutrino> mzero: that's what i do. however, the help string in that tuple is going to be a duplicate of the function's haddock. and i would like to prevent that.
09:25:37 <mzero> ah
09:25:40 <neutrino> specifically because it'll probably lead to trouble.
09:26:12 <mzero> hmmm… well, the haddock parser is just a Haskell module … but I'm not sure you want to go to all that trouble!
09:26:35 <neutrino> well hopefully there's some clever way of doing it that isn't too obvious
09:27:43 <bookerz> Is there a preferred way to do floating-point math on numbers whose exponents are larger than "Double" supports?
09:29:00 <quicksilver> there are a number of arbitrary precision arithmetic libs
09:29:10 <quicksilver> they're all pretty slow, compared to Double
09:29:25 <bookerz> MPFR and BigFloat (from numbers) will allow for arbitrary-precision mantissas, but I don't see evidence that the size of the exponent can be set
09:30:56 <quicksilver> bookerz: I think BigFloat has an Integer exponent (effectively unbounded)
09:31:29 <nand`> there's always CReal for arbitrary-precision floating point math
09:31:47 <nand`> but it's slooooow
09:31:54 <quicksilver> that's going to be slower than MPFR and BigFloat though I would strongly expect
09:32:07 <nand`> oh, it's in numbers too; didn't realize
09:32:25 <quicksilver> MPFR's exponent I really don't know - whatever the underlying GMP lib uses I suppose
09:32:34 <quicksilver> perhaps exponent limited to machine integer?
09:33:08 <nand`> whoa, I just realized ‘numbers’ has lots of cool stuff
09:33:16 <dada-cetacean> could anybody tell me why this is giving me a "permission denied" error? replaceFile filepath oldstring newstring = do y <- openFile filepath ReadWriteMode; x <- hGetContents y; writeFile filepath (replace oldstring newstring x)
09:33:33 <bookerz> That could be -- the MPFR faq notes that it's at least got some limit
09:33:57 <neutrino> dada-cetacean: no write permission to your file?
09:33:59 <typoclass> neutrino: i think it shows good judgement that you're concerned about code duplication. unfortunately haddock comments aren't really accessible easily
09:34:26 <quicksilver> dada-cetacean: the file is still open, so you can't write to it
09:34:30 <typoclass> neutrino: so i'd probably just do «fooHelp = "The foo command does this and that"», and in the next line start the haddock {- | ... -} and copy-paste the help string. obviously it's easier to keep stuff in sync if it's right next to each other
09:34:31 <neutrino> typoclass: it's been on my todo list for some time to investigate how to get haddocks out of values
09:34:41 <quicksilver> can't overwrite it, I mean
09:35:54 <nand`> this is why we need a more powerful module system with first class documentation :P
09:36:08 <typoclass> neutrino: if you're interested, here's a small bug discussion that seems related http://hackage.haskell.org/trac/ghc/ticket/5467 . but doesn't seem to include patches so far :-)
09:36:56 <dada-cetacean> quicksilver: thanks, I inserted an hClose statement and it worked :)
09:37:01 <quicksilver> nand`: I'm not sure I'd want documentation existing at runtime in the most general case.
09:37:23 <quicksilver> but it would be anice to have a way to do this
09:37:42 <Cale> dada-cetacean: Did you apply hClose to a Handle which had hGetContents applied to it? That's not usually the right thing to do.
09:38:01 <nand`> quicksilver: I don't think I'd like to have documentation at runtime either; I meant first class in the ‘part of module semantics, compiler understands it’ sense
09:38:11 <nand`> and I guess ‘computable at compile time’
09:38:19 * quicksilver nods
09:38:46 <neutrino> typoclass: i don't really think that belongs in Template Haskell, does it?
09:38:54 <neutrino> i think it belongs more in ghc or ghci
09:39:20 <neutrino> what if we had a magical typeclass, say Doc, and everything we wanted to access the doc of we could just put in that typeclass?
09:39:32 <neutrino> in fact, why couldn't it be the default?
09:39:54 <neutrino> i'm sure there's enough space in the internal representation of haskell values to fit in a humble string..
09:39:57 <nand`> one thing that would be interesting is if TH had the ability to print the source code of some binding's definition verbatim; and include that anywhere you want it with TH (including inside comments in this hypothetical ‘compiler-recognized comments’ system)
09:40:05 <Cale> neutrino: what?
09:40:19 <neutrino> Cale: what are you asking about?
09:40:29 <Cale> <neutrino> i'm sure there's enough space in the internal representation of haskell values to fit in a humble string..
09:40:31 <nand`> so you can write documentation that updates itself to reflect the definition, if you want to include it for the sake of clarity (eg. in package lens it's done a lot)
09:40:46 <Cale> The representation of Haskell values is a pointer to code
09:41:02 <typoclass> neutrino: not sure what you mean with the typeclass :-) i meant, you could have some th quasiquoter [doc|This is the foo command ...|] which then inserts a String, for your program to access, and the same content as a haddock comment
09:41:06 <neutrino> Cale: mmh, let's make it (pointer to code, pointer to doc, pointer to source) :-)
09:41:26 <Cale> and even the low order bits of the pointer are already used for tagging which constructor it was when it was evaluated
09:41:35 <Cale> (in the case of small datatypes)
09:41:51 <neutrino> i'm happy with this only working on x64
09:41:57 <neutrino> ;-)
09:42:07 <Cale> Yeah, there's no additional room
09:42:27 <neutrino> i know. this is kind of sad.
09:42:38 <Cale> You'd have to multiply the amount of space that Haskell programs used by some fairly sizeable factor if you wanted to tag all the values like that.
09:43:09 <neutrino> ok, what about storing this somewhere else?
09:43:19 <neutrino> not all values are going to have docs, for example
09:43:26 <neutrino> (skip the ones that don't)
09:43:48 <neutrino> and since values are immutable you don't need to worry about keeping track of discrepancies, right?
09:43:51 <neutrino> except in the case of GC
09:49:10 <Sonderblade> this works: doit (A.Object obj) = obj M.! "key", so why does not this work: let cmd = (obj :: A.Object) M.! "key" ?
09:49:20 <neutrino> or am i completely making that up Cale :)
09:49:54 <fryguybob> Sonderblade: One is a pattern match the other is a type assertion.
09:49:59 <neutrino> Sonderblade: in the first one you're pattern matching, the other one you're casting
09:50:06 <neutrino> or what he said
09:50:44 <mauke> >casting ಠ_ಠ
09:50:48 <Sonderblade> and how do i make it work?
09:50:58 <nand`> A.Object is a constructor in your first example, and a type in the latter
09:51:01 <fryguybob> Sonderblade: use a function on obj.
09:51:02 <nand`> not the same ‘A.Object’
09:51:06 <mauke> Sonderblade: define "it" and "work"
09:51:15 <typoclass> Sonderblade: it's valid syntax to say "let (A.Object obj) = ...", which will create the name "obj"
09:51:15 <Cale> neutrino: Why do you want runtime representations of documentation?
09:51:47 <Cale> neutrino: It doesn't make much sense to keep something like that around after compilation.
09:51:48 <neutrino> Cale: so that i can extract useful information from the documentation.
09:52:01 <neutrino> Cale: in this case, so that i can use it in command line help
09:52:20 <fryguybob> Sonderblade: specifically the function  f (A.Object obj) = obj
09:52:21 <Cale> Well, the command line is a completely different thing. You have the source code, just use that.
09:52:24 <neutrino> but otherwise, so that i can e.g. use it in ghci. accessing the docs from within ghci would be great in itself.
09:52:34 <neutrino> Cale: how?
09:53:29 <Cale> Well, what are you asking how to do?
09:53:40 <Cale> You don't need to put all the documentation in the values themselves.
09:53:50 <neutrino> you said "just use the source code". how do i do that?
09:54:00 <Saizan> it could be handy to have it in the .hi files
09:54:11 <Cale> By parsing it and locating the relevant comments and so on.
09:54:13 <typoclass> cale: he wants to put stuff inside of {- | ... -}, and then in the program use this "..." (e.g. to print out usage when a --help flag is present)
09:54:25 <neutrino> Cale: how would i do that?
09:54:30 <Saizan> but otherwise you can build a hoogle index and use that with --info
09:54:40 <Cale> neutrino: The same way that Haddock does it.
09:54:53 <mauke> Cale: haddock doesn't access its own source
09:55:02 <neutrino> that's the thing
09:55:16 <Cale> mauke: Neither does ghci
09:55:20 <Sonderblade> typoclass: ah ok, i need to "declare" the type of obj? but then shouldn't let cmd = (A.Object obj) M.! "key" work too?
09:55:21 <neutrino> i would still need to store the result of this "same way that haddock does it" in the original source somewhere
09:55:35 <Cale> neutrino: what?
09:55:36 <Cale> Why?!
09:55:48 <neutrino> well what happens if i relocate the binary?
09:56:06 <Cale> You don't need to access the documentation from a compiled binary
09:56:07 <neutrino> are you suggesting i put the help to the program in a file separate to the binary?
09:56:24 <neutrino> and when i do program --help i read that help file?
09:56:26 <mauke> Cale: then how am I going to --help?
09:56:26 <typoclass> Sonderblade: yeah -- no, that's not 'declaring' the type :-) "let (A.Object obj) = ..." pattern-matches an A.Object, i.e. it unwraps an A.Object
09:56:29 <Cale> Maybe I misunderstand what you're trying to do
09:56:45 <typoclass> > let Just x = (Just 123) in x+3
09:56:47 <lambdabot>   126
09:56:48 <Cale> Are you trying to document a library API in a way that people can access it from ghci?
09:56:53 <mauke> no
09:56:59 <neutrino> Cale: my program has a function. this function has a haddock comment. when i do program --help, i want to display that comment. how do i do this?
09:57:13 <Cale> By turning the comment into a String.
09:57:13 <typoclass> Sonderblade: ^^ this example is a little silly, but you can see how a "Just 123" is built, and then taken apart
09:57:19 <neutrino> Cale: oh, well, that's as an aside. but a completely separate problem.
09:57:21 <mauke> Cale: show the same information in haddock and --help output
09:57:28 <neutrino> Cale: but then that String doesn't show up in haddock.
09:57:47 <osfameron> ah, you're trying to do same as https://metacpan.org/module/Pod::Usage for Perl
09:58:08 <Cale> Is this a library or an executable/
09:58:10 <Cale> ?
09:58:33 <Cale> I guess it's possible to build haddock documentation for an executable
09:58:34 <typoclass> neutrino: i think you had a creative idea, but i'm not yet convinced that all haddock everywhere needs to be available at runtime. i think your time is best invested if you work on a quasiquoter as i mentioned above. it'd have to write a haskell value into the source code, and write the same string into a haddock comment
09:58:37 <neutrino> it is an executable
09:58:38 <Cale> Just a bit weird
09:58:53 <Eduard_Munteanu> It might be fun to let Template Haskell inspect comments, I guess.
09:59:10 <Cale> typoclass: Does haddock run TH splices?
09:59:20 <neutrino> Cale: well, it is an executable that uses a library.
09:59:25 <Sonderblade> typoclass: ok but can't i do the pattern-matching/unwrapping inline?
09:59:30 <neutrino> i want to have haddock for the library and --help for the executable.
09:59:42 <neutrino> and i want to be able to relocate the executable.
10:00:03 <typoclass> cale: i found a bug ticket where they're discussing adding that to th
10:00:17 <neutrino> i was just going to mention that to you Eduard_Munteanu
10:01:34 <neutrino> typoclass: being able to access the docs immediately could be a very good debugging help
10:01:55 <typoclass> Sonderblade: you can do pattern matching when you define a function "foo (Just x) = ...", in "case j of (Just x) -> ...", in let, and where (i think that's all the popular possibilities)
10:02:02 <neutrino> if you forget how to use something, just instantiate it and look it up.. no browsing around
10:02:11 <neutrino> possibly even from within the editor you are using
10:02:50 <typoclass> neutrino: hm yeah, could be ... incidentally, you know about hoogle's command line tool? it's pretty handy for that. you could check out how they get at the documentation
10:03:11 <neutrino> i didn't know they had a command line tool
10:04:08 * hackagebot classy-prelude 0.4.0 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.4.0 (MichaelSnoyman)
10:04:08 <Sonderblade> typoclass: but not mixed in on a function call?
10:04:10 * hackagebot classy-prelude-conduit 0.4.0 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.4.0 (MichaelSnoyman)
10:04:12 <Cale> Sonderblade: case expressions let you pattern match...
10:04:34 <Eduard_Munteanu> Also on the lhs of <- in do syntax.
10:04:44 <neutrino> generally on the lhs
10:04:45 <neutrino> :)
10:05:03 <Eduard_Munteanu> Sonderblade: what do you mean?
10:05:28 <neutrino> typoclass: is it going to be installed by the hoogle package?
10:05:30 <typoclass> Sonderblade: not really, sorry. but if you put your code on hpaste, you'll get plenty of suggestions from #haskell
10:05:58 <typoclass> neutrino: i think so, but i'm not sure. but that should be easy to google :)
10:06:02 <neutrino> :)
10:06:26 <neutrino> wow this is heavy
10:07:04 <Sonderblade> Eduard_Munteanu: i want to write let cmd = (something obj) M.! "key" and have haskell understand that obj is A.Object and not A.Value so that calling M.! works
10:07:08 <typoclass> Sonderblade: (suggestions relating to how to make your code shorter, more straightforward, more idiomatic)
10:07:47 <typoclass> Sonderblade: something like that isn't possible, but you can always move the pattern match to the place where you're defining obj
10:07:58 <neutrino> the hoogle command downloads the packages i think
10:08:12 <Eduard_Munteanu> Sonderblade: what should it do when you have an A.Value?
10:09:16 <Sonderblade> Eduard_Munteanu: fail :). i thought the example was similar to the "fromJust" function but apparently not
10:09:31 <typoclass> Sonderblade: where do you get the "obj" from?
10:09:54 <typoclass> you can put the A.Object pattern match in that place
10:10:00 <fryguybob> Sonderblade: Why do you object to having a function to get the obj you want?
10:10:00 <Eduard_Munteanu> let cmd x@(A.Object ...) = x M.! "key"
10:11:21 <Sonderblade> typoclass: from parsing json, and the parsing function can return any type of json data ofcourse
10:11:56 <jfischoff> is there anyway to use Control.Lens with types that have kinds other than * (i.e. promoted datatypes)?
10:12:11 <Cale> jfischoff: What would that even mean?
10:12:24 <typoclass> Sonderblade: as i said, you can put the A.Object pattern match in the place where you define obj. we can help you with the exact syntax, but you have to show us the relevant lines of code (use hpaste)
10:12:25 <otters> Oh jesus
10:12:28 <typoclass> @where hpaste
10:12:28 <lambdabot> http://hpaste.org/
10:12:35 <otters> installing lambdabot is "likely to break" haskell-platform-2012.4.0.0
10:12:37 <otters> has anybody tried it yet?
10:12:39 <Cale> jfischoff: oh, you want to apply lens functions at compile time at the type level?
10:12:41 <jfischoff> Cale: everything
10:12:45 <jfischoff> no no
10:14:01 <Cale> jfischoff: What kind do you want it to work on, and what would the types of things be?
10:14:16 <jfischoff> let me through a example on hpaste
10:14:19 <jfischoff> one sec
10:14:58 <otters> screw it, force-reinstalls has never caused me problems
10:15:28 <neutrino> sorry i have become disconnected
10:15:43 <hpaste> Sonderblade pasted “json parsing” at http://hpaste.org/77331
10:15:43 <neutrino> i think i will for now abandon the haddock hackery and concentrate on getting my program under quicktest
10:15:51 <Sonderblade> typoclass: ^^
10:16:03 <Cale> jfischoff: After all, kinds other than * don't have any values, do they?
10:16:28 <Cale> jfischoff: So it doesn't really make sense to extract and modify fields of values which don't exist.
10:16:39 <jfischoff> one sec...
10:16:45 <neutrino> but isn't foo :: a -> a going to be a value of the kind * -> * ?
10:18:34 <typoclass> Sonderblade: looks good to me. you could write a function "fromObj (A.Object o) = o", and use that in the 3 places. i'm not familiar with the json library that you use; it might already offer a function like that
10:19:03 <otters> :t \x -> x x
10:19:05 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
10:19:05 <lambdabot>     In the first argument of `x', namely `x'
10:19:05 <lambdabot>     In the expression: x x
10:19:08 <otters> @pl \x -> x x
10:19:09 <lambdabot> join id
10:19:35 <nicoo> @type join
10:19:36 <lambdabot> Monad m => m (m a) -> m a
10:19:40 <nicoo> :)
10:22:42 <gertc> i have a Main.hs that creates a file ./database where should this stuff go as a cabal --user?
10:23:02 <Sonderblade> typoclass: it's the creation of the intermediate variables that is annoying
10:23:32 <fryguybob> Sonderblade: They are not variables if that helps.
10:23:40 <typoclass> Sonderblade: agreed
10:23:40 <hpaste> “Jonathan Fischoff” pasted “Lens with Singletons” at http://hpaste.org/77332
10:23:50 <typoclass> Sonderblade: which library are you using? maybe it offers an easier way
10:24:07 <Sonderblade> typoclass: aeson
10:24:08 <mzero> gertc: it depends on how cabal is configure on your system --- which OS are you on?
10:24:15 <jfischoff> Cale: http://hpaste.org/77332
10:25:45 <dcoutts> mzero: good work on the release
10:25:57 <dcoutts> mzero: btw, I submitted an HCAR entry for the platform
10:26:13 <gertc> mzero: linux, i was thinking .cabal/share but the package name has a version number so it changes every time ?
10:26:15 <mzero> oh - thanks! this one was easy…. next one I want to be more aggressive in how many packages we add
10:26:41 <dcoutts> mzero: do we have many lined up already?
10:26:49 <mzero> gertc - there is an option to symlink the executable into the bin directory of your choice … you can add this to your .cabal file
10:26:51 * typoclass hugs the platform people ... thanks for the work guys!
10:27:08 <mzero> dcoutts: no - but we should start drumming up the process
10:27:43 * mzero admits he doesn't know what HCAR is….
10:27:53 <typoclass> community activities report
10:27:53 <mzero> oh
10:27:56 <dcoutts> mzero: tibbe and I should revamp the process, and the steering committee, so we have committee members responsible for steering each new proposal through
10:27:57 <mzero> d'oh!
10:28:02 <Cale> jfischoff: So... view testLens :: Test a b -> b
10:28:14 <jfischoff> yeah
10:28:16 <bfig> hello, i'm having trouble using GADTs with typeclass constraints. I want to set a GADT that only takes Ord a, and then infer the Ord out of it. is this possible? let me put an example
10:28:30 <jfischoff> but it is the setting I am not sure if it is possible
10:28:32 <dcoutts> gertc: are you just asking where data files should go?
10:28:34 <mzero> yes, and I should get off my ass and write the "responsibilities of a package maintainer for haskell platform packages"
10:28:38 <edwardk> i should probably have written something about lens for the CAR
10:28:38 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
10:28:39 <Cale> jfischoff: But b :: OtherThing, and so b = Foo or b = Bar, but there are no values of type Foo or Bar
10:28:48 <edwardk> @messages
10:28:48 <lambdabot> nand` asked 1h 29m 25s ago: could _1 be lazified to ~(a,b)? A certain program of mine is too strict due to use of that lens, but with the irrefutable match it works as expected
10:28:50 <dcoutts> gertc: and do you mean data files installed with the app, or data files generated by your app?
10:28:53 <Cale> jfischoff: So this function can't be very useful
10:28:59 <mzero> I'd like to be clear what folks are signing up for when they signup to have their package distributed in the platform
10:29:06 <hpaste> gertc pasted “how to symlink to bin?” at http://hpaste.org/77333
10:29:31 <edwardk> nand`: hrmm. i could see that
10:29:48 <dcoutts> mzero: yes. Don and I wrote some stuff about that, but it's not been very prominent. And we have the legacy of packages grandfathered in.
10:29:53 <jfischoff> Cale: yes
10:29:57 <Cale> jfischoff: However, you could use the singletons
10:29:59 <bfig> Branch :: Ord a => a -> OTree a -> OTree a -> OTree a; lookup :: b -> (b -> a -> Ordering) -> OTree a -> Maybe a; search :: a -> OTree a -> Maybe a; search a t = lookup a compare t;
10:30:21 <gertc> dcoutts: the app creates the database
10:30:21 <yitz> mzero: congrats!
10:30:29 <mzero> gertc: add   "symlink-bindir: /home/gertc/bin" or some such to your ~/.cabal/config file
10:30:30 <Cale> jfischoff: and make  testLens :: Lens (Test a b) (Test a z) (SOtherThing b) (SOtherThing z)
10:30:31 <Cale> maybe
10:30:41 <jfischoff> yes
10:30:45 <jfischoff> good call
10:31:09 <bfig> as long as i use the OTree without specifying any particular constructor i won't be able to infer that a is of type Ord (in search)
10:31:14 <dcoutts> gertc: then probably you just want to use System.Directory.getAppUserDataDirectory
10:31:17 <jfischoff> Cale: I think that will work
10:31:20 <bfig> is there any way to get around this?
10:31:21 <yitz> mzero: since we just barely missed 7.6, will that affect the coming release sched in any way?
10:31:24 <typoclass> Sonderblade: have you looked at this way of doing things? might be an alternative https://github.com/bos/aeson/blob/master/examples/Simplest.hs (from aeson's example directory)
10:31:55 <dcoutts> gertc: e.g. getAppUserDataDirectory "foo" will give you "/home/you/.foo/" on unix systems, and the appropriate equiv on windows
10:32:32 <jfischoff> Cale: yeah that was it
10:32:34 <dcoutts> gertc: where to put files made at runtime isn't something that cabal gets involved with. Cabal only cares about data files installed with the app.
10:32:35 <jfischoff> thanks
10:32:49 <Cale> jfischoff: no problem
10:32:55 <dcoutts> gertc: or rather, those are the only ones that cabal has to worry about
10:33:03 <beekor> in my error message it mentions:  expected type [t0] .  what exactly does the t indicate ?
10:33:09 <mzero> yitz - not sure what you mean - I'm only worried in that SPJ seemed to indicate that 7.6.1 was the last of the 7.6 line and they were already off and running on 7.8! (what about 7.7? aren't odd releases for unstable stuff....?)
10:33:15 <hpaste> bfig pasted “can't infer context” at http://hpaste.org/77334
10:33:15 <typoclass> Sonderblade: (what i mean specifically is how he chains the .: calls together with <$> and <*>. that looks elegant enough to me)
10:33:21 <merijn> beekor: It's an automatically inferred name for a type
10:33:41 <mzero> so if 7.8 comes out at end of year ---- then that doesn't give it much time to stablize, or for hackage packages to adapt to the new base (and other packages that are tied to GHC)
10:33:43 <beekor> hmm.
10:33:50 <merijn> beekor: i.e. if you have a polymorphic list GHC needs to assign it a type variable to use during typechecking
10:33:50 <neutrino> ok so quicksilver you suggest using "doctest" for "(2) frameworks for collecting your tests and getting them run" yes?
10:34:03 <gertc> dcoutts, where would you put a web database file?
10:34:07 <merijn> beekor: Those are usually things like a,a0,a1,t,t0,t1, etc
10:34:07 <neutrino> quicksilver: if you're still there at all
10:34:12 <dcoutts> mzero: yes it's unclear if there will be a 7.6.2. If so, it might be released more or less at the same time as 7.8.1, but for details ask Igloo
10:34:15 <beekor> okay, I think that makes sense.
10:34:18 * nand` wonders what it would be like if pattern matches on any data types with only one constructor would be irrefutable, like newtypes; eg. (\() -> x) undefined = x
10:34:20 <Sonderblade> typoclass: i dont understand that syntax, but he doesn't seem to be using nested json structures which i am
10:34:20 <yitz> mzero: hmm yeah. well most people consider 7.6 very significant in many ways, so we definitely want that asap. i'd say it's ready now even.
10:34:40 <beekor> i understood the a's and b's after being confused a bit, just wondering if t had any special significance
10:34:51 <yitz> mzero: not sure if we can do a point for a major ghc version bump tho
10:34:57 <neutrino> general question to everyone: what do you guys suggest as a test running framework that uses quicktest?
10:35:00 <dcoutts> yitz: no, can't
10:35:08 <neutrino> does quicktest come with its own runner?
10:35:11 <merijn> beekor: Well, presumably it has *some* significance, as ghc seems to prefer some names in some contexts, but it's mostly an implementation detail of the type checking
10:35:17 <otters> > let f = () in (\() -> 3) f
10:35:19 <lambdabot>   3
10:35:33 <otters> > let f = () in (\() -> 3) undefined
10:35:35 <lambdabot>   *Exception: Prelude.undefined
10:35:36 <dcoutts> yitz: I think people just need to relax, allow for the longer stabilisation process from new ghc released through to platform releases.
10:35:43 <beekor> okay.  thanks merijn.
10:35:47 <nand`> > (\(~()) -> 3) undefined
10:35:49 <lambdabot>   3
10:36:17 <Igloo> mzero: 7.7 is what's in HEAD now. 7.8 will be forked off of it at some point
10:36:20 <yitz> dcoutts: yes a stabilization period is important. it's just a shame that we missed by so little for such an important ghc bump.
10:36:28 <Igloo> mzero: The plan is to make a 7.6.2 at some point
10:36:34 <edwardk> nand`: its in HEAD now
10:36:40 <nand`> edwardk: sweet
10:36:46 <nand`> now I can go back to the more elegant version of this algorithm :)
10:36:48 <edwardk> nand`: it'll go out probably in a little bit. i want to add the Loupe code from my snap branch to it
10:36:51 <merijn> Please tell me next platform will be 7.8 so I get holes :<
10:37:06 <bfig> http://hpaste.org/77334 <- halp please!
10:37:16 <dcoutts> gertc: if it's important, make it configurable. E.g. for the hackage-server we stick the state dir in ./state/ but we also have a --state-dir= flag so you can override that.
10:37:23 <mzero> iff 7.8 comes out in enough time to be stable … AND … for popular packages on hackage to update to it
10:37:24 <bfig> (last line won't work, Ord cannot be inferred from the context)
10:37:38 <merijn> bfig: Quick remark: GADTSyntax is redudant if you use GADTs
10:37:57 <mzero> as long as 7.6.2 is out by early February, we should be good for that
10:38:11 <dcoutts> Igloo, mzero: then (depending on timing), 7.6.2 sounds like the thing to aim for.
10:38:13 <nand`> (‘more elegant’ here loosely being defined as ‘making heavier use of lenses’)
10:38:22 <merijn> bfig: Also, the Ord a constraint on Nil is redundant as well
10:38:23 <mzero> if 7.8 is ready, say mid-Jan, then it might have a chance (given the speed with which packages adpat)
10:38:27 <edwardk> nand`: of course =)
10:38:45 <nand`> edwardk: any updates on the cycleRight/wrapRight/whatever thing?
10:38:53 <bfig> really? can't i make an OTree of something that is not Ord through Nil if i remove the constraint?
10:39:04 <edwardk> nand`: do you have that brainfuck interpreter handy?
10:39:05 <gertc> dcoutts: ok thx
10:39:10 <merijn> bfig: You can only make empty trees that are not Ord instances in that scenario
10:39:16 <mzero> if 7.6.2 comes out, and then 7.8 immediately after - we (HP team) will need to be vocal to get traction on getting package maintainers to make things stable on 7.6.2
10:39:22 <nand`> edwardk: http://hub.darcs.net/nand/brainfuck
10:39:24 <edwardk> nand`: and would you like it to be added as an example? i don't remember how much lens stuff it uses
10:39:28 <yitz> mzero: but that's not a reason for hq to push it out any faster though. stability!
10:39:29 <merijn> bfig: Because the constraint on Branch means any non-empty tree has to be Ord anyway
10:39:32 <mauke> bfig: why do you have Ord constraints in OTree?
10:39:32 <nand`> it doesn't actually use that much right now
10:39:37 <edwardk> oh its been split into multiple files and stuff
10:39:39 <edwardk> nm
10:39:42 <nand`> your call, it's probably less of a fitting lens example
10:39:56 <edwardk> when it was one file like the pong interpreter it was a pretty good zipper example
10:40:02 <bfig> mauke, i don't understand your question... are you asking me what am i going to use the structure for?
10:40:05 <Cale> bfig: You need to pattern match the constructors of OTree in order to unpack the Ord dictionary.
10:40:11 <merijn> bfig: I don't really see why you'd need Ord in the first place, though. And what the error/problem you have is
10:40:15 <nand`> there's still a one-file version on hpaste but a few lines have been changed since then
10:40:17 <mzero> yitz: no, not at all! I want stability for the GHC in the HP --- it was only a gentle nudge to GHC central that the HP team would like to know their projected schedule as soon as they know it
10:40:20 <nand`> I could cat them together if you'd like it
10:40:20 <mauke> bfig: I'm asking why you put "Ord a => " in there
10:40:23 <mzero> :-)
10:40:28 <bfig> i want to make an ordered tree
10:40:29 <Cale> (but yes, this is weird)
10:40:36 <mauke> bfig: go on?
10:40:39 <gertc> what does @pl do?
10:40:42 <edwardk> sure. if you do that. i'd happily toss it in the examples folder
10:40:49 <Cale> bfig: You probably want  search :: (Ord a) => a -> OTree a -> Maybe a
10:40:50 <edwardk> its a pretty trivial use of a zipper, but it is a zipper ;)
10:40:57 <dcoutts> mzero: yes, once we are more certain about the timing of 7.6.2 then we should make it very clear to everyone that that's what we'll be targeting, not a 7.8.x
10:41:11 <Igloo> mzero: FWIW, I was under the impression that 7.6 was going to be included, given the October 1st mentioned in http://projects.haskell.org/pipermail/haskell-platform/2012-August/002136.html
10:41:12 <kirindave> Is there a reason that Control.Monad doesn't have a true/false conditional execution thing? It has when.
10:41:14 <merijn> dcoutts: :(
10:41:15 <yitz> mzero: we really seem to be just off in our synch. that's why i was hinting that it might make sense to do the next major HP a little earlier, to get 7.6.2 while it's hot yet before everyone is drooling for 7.8.
10:41:17 <kirindave> It's not hard to write
10:41:18 <bfig> yes, sure that would work, but i was wondering if there was a way to make it automatically infer that a was Ord
10:41:24 <kirindave> It's just odd that something so simple isn't there. Is it breaking a rule?
10:41:30 <dcoutts> merijn: hmm?
10:41:30 <Cale> kirindave: ?
10:41:36 <Cale> kirindave: when/unless
10:41:43 <edwardk> kirindave: it has when and unless and you can always use 'if' ;)
10:41:43 <merijn> dcoutts: That means I have to wait for my holes support :(
10:41:44 <bfig> because it makes sense if i only let the trees be created with Ords that it could infer that
10:41:58 <kirindave> yeah you can just use if.
10:41:59 <dcoutts> merijn: does it? I thought that was in 7.6.1 already
10:42:00 <edwardk> :t when
10:42:02 <lambdabot> Monad m => Bool -> m () -> m ()
10:42:08 <kirindave> No I know what when is. :\
10:42:12 <Igloo> mzero: But you won't generally find me complaining about the HP being conservative in taking new releases. Better it be high quality than have all the latest toys
10:42:15 <bfig> mauke, i want to make some tree structure that uses an ordering to build a binary search tree (and then add some extra behavior)
10:42:16 <merijn> dcoutts: I was under the impression it was in HEAD
10:42:24 <gertc> :pl help
10:42:37 <edwardk> my point is without the default for one of the branches there is nothing to distinguish such a function from 'if' other than a ham-handed restricted type signature
10:42:38 <mauke> bfig: type signatures are all or nothing
10:42:48 <merijn> dcoutts: I didn't read about it in GHC7.6 docs, but I hope I'm wrong. Because then I could use them now \o/
10:43:00 <bfig> ok, that answered my question :p
10:43:02 <kirindave> edwardk: Fair enough
10:43:04 <nand`> edwardk: what would be more idiomatic these days? x % l %~ f  vs l %~ f $ x
10:43:06 <bfig> removed and didf ine :p
10:43:22 <kirindave> edwardk: My hands are fairly hammy, to my chagrin.
10:43:25 <edwardk> nand`: if they are short like that? over l f x =)
10:43:26 <bfig> but this raises another question, how can i make sure the OTree a is never built with something that is not Ord a ?
10:43:39 <mauke> bfig: you can't
10:43:43 <gertc> :pl \x -> x
10:43:57 <mauke> bfig: why does it matter, though?
10:44:05 <nand`> edwardk: it's bracket cs xs % _1 %~ f x
10:44:13 <merijn> dcoutts: Nope, 7.8.1 is the first "This feature was implemented by Simon Peyton Jones, Sean Leather and Thijs Alkemade, and is scheduled to be released with GHC 7.8.1"
10:44:13 <mauke> bfig: lookup is fine with non-Ord a trees
10:44:21 <edwardk> nand`: thats probably the version i'd use.
10:44:22 <Cale> nand`: I'd write  over l f x
10:44:43 <nand`> but ‘over’ does look nice perhaps for other use cases
10:44:50 <gertc> @pl \x -> x x
10:44:51 <lambdabot> join id
10:44:57 <edwardk> i use over quite a bit more than i did when i started writing lens code
10:45:00 <bfig> well, i'm going to add insert/remove that rely on the Ord now, so it will be a meaningless structure without them
10:45:06 <Cale> over _1 f $ bracket cs xs
10:45:06 <gertc> :pl \x -> x x
10:45:07 <parcs`> @check \x -> x * 0 == 0
10:45:09 <lambdabot>   Not in scope: `myquickcheck'
10:45:09 <Cale> errrr
10:45:20 <Cale> over _1 (f x) $ bracket cs xs
10:45:21 <edwardk> he's got the f x in there
10:45:27 <merijn> bfig: So what, if insert/remove use Ord then you can only make Ord trees anyway
10:45:31 <dcoutts> merijn: to some extent the job of the HP release managers is to resist pressure from eager people like you, clamouring about the latest and greatest feature, and to make sure we release boring good quality stable stuff :-)
10:45:38 <edwardk> once you start putting parens in i tend towards using the % stuff
10:45:51 <gertc> :t \x -> x x
10:45:53 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
10:45:53 <lambdabot>     In the first argument of `x', namely `x'
10:45:53 <lambdabot>     In the expression: x x
10:45:54 <Cale> I dislike the % stuff because it reads backwards
10:46:02 <edwardk> bracket cs xs % _1 %~ f x       or _1 %~ f x $ bracket cs xs
10:46:08 <dcoutts> yitz: btw, yes we are out of sync, but that's a feature not a bug.
10:46:25 <nand`> I don't think it reads backwards; necessarily
10:46:31 <edwardk> there i tend to prefer the $ because % and %~ admittedly look funny when mixed
10:46:45 <bfig> well anyway, thanks for clarifying how this works
10:46:47 <dcoutts> yitz: the cycles not being synchronised is a good thing. The HP is time based while GHC releases are not so much.
10:46:48 <typoclass> dcoutts: fwiw, i'm very happy that there's a group putting more emphasis on good quality and stability. kudos!
10:47:01 <nand`> perhaps the opposite order from what you'd expect as a functional programmer, but if you try reading it out:  “this is foo, but with bar modified by x”
10:47:28 <nand`> not unlike record syntax
10:47:48 <Cale> Yeah, but the record syntax is kinda backwards too :P
10:48:38 <Cale> Or I guess you could claim that function application is the wrong way around to begin with, but that's not something that's likely to change :P
10:48:54 <edwardk> obk hounded me until i added a |>'alike to lens. I like it as an extra grammatical option at least, but I can see why it is the sort of thing that pushes people into camps ;)
10:48:58 <mauke> 2 dup inc add print
10:50:46 <hpaste> nand` pasted “Brainfuck interpreter, single file version” at http://hpaste.org/77337
10:50:51 <nand`> edwardk: Here's a version that works with the strictness change in _1
10:51:28 <Cale> It reminds me of the original code that was in that PLEAC site for Haskell -- seems someone's sanitised it now.
10:51:49 <Cale> The code which replaced (.) with flip ($)
10:51:52 <edwardk> nand`: nice. i'll toss that in.
10:51:53 <nand`> (it ‘works’ without it too, but “compile” is strict so you don't actually get any output until EOF, so you'd want to remove the hSetBuffering stdin NoBuffering since that makes ^D interpreted as literal char and not as EOF)
10:52:13 <nand`> come to think of it, the ‘stdout’ buffering could be pulled to the top of ‘main’ as well
10:54:00 <nand`> Cale: of course, now you don't need to do that :P
10:54:12 <edwardk> the       hSetBuffering stdin  NoBuffering;      hSetBuffering stdout NoBuffering  lines?
10:54:19 <nand`> foo^.to(f).to(g).to(h)
10:54:35 <edwardk> foo^%f^%g^%h
10:55:03 <Cale> Also: when did people stop writing spaces around infix operators?
10:55:04 <nand`> don't tell me ^% is another silly alias for (%)
10:55:06 <mauke> w%$#@tf
10:55:14 <edwardk> ^% is % with the fixity of ^.
10:55:19 <nand`> heh
10:55:23 <edwardk> so you can mix and match them
10:55:25 <nand`> lens, the true master of giving names to ‘id’
10:55:29 <edwardk> =)
10:55:30 <nand`> or flip id
10:55:31 <edwardk> thats flip id!
10:55:34 <edwardk> yep
10:56:06 <nand`> I only omit the spaces when using (.) to compose lenses, personally
10:56:12 <nand`> I keep them in for ^%, %, %~ etc.
10:56:17 <nand`> too much noise otherwise
10:56:31 <edwardk> sure, me too
10:56:38 <nand`> edwardk: I'd preferably want to keep the hSetBuffering stuff since that makes for a really cool “lazy evaluation” feature -> the brainfuck code is interpreted and output is generated as soon as possible
10:56:52 <edwardk> just wanted to write something that looked like i was swearing or speaking qbertese
10:56:54 <nand`> so you can run brainfuck interactively, you hit a ‘.’ and get output immediately; it only pauses if you have unmatched opening brackets
10:57:22 <edwardk> sure
10:57:25 <nand`> really the only change that's needed is the _1 strictness
10:57:59 <gabor> edwardk: can you have a look at the comment starting l. 64 (https://github.com/ggreif/indexed/blob/f243a42f8a5550b5cdfce60fa402d4fdcd931262/src/Indexed/Parser.hs#L64) Does this make sense? Also, please ignore the rest of the file :-)
10:58:11 <edwardk> which Data.Stream is that?
10:58:14 <Sonderblade> any way to make a list that contains either Ints or Strings?
10:58:36 <nand`> (come to think of it, it would be interesting to include a ‘debug’ command which prints out the first few memory cells, or perhaps a few memory cells around the focus, since it would demonstrate usage of zippers a bit more)
10:58:37 <mauke> Sonderblade: [Either Int String]
10:58:47 <edwardk> i honestly still don't understand where you are going with IParser ;)
10:59:11 * edwardk hurries to get the interpreter added so nand` can work his magic with patches ;)
10:59:50 <nand`> how would I do that with zippers? ‘retrieve the few cells around the current focus’ <- since it's a list, an easy way to get the position of the current focus (can Tape or whatever do that) then just drop whatever - some offset
11:00:24 <edwardk> i think there is an internal lens to get the level. not sure if i export it
11:00:34 <edwardk> nand`: which stream library is Data.Stream from?
11:00:50 <nand`> edwardk: I'll tell you once hoogle loads
11:00:53 <edwardk> =)
11:00:54 <nand`> ah, there we go; package Stream
11:01:10 <nand`> http://hackage.haskell.org/package/Stream <- if there's something better I could use, don't hesitate to let me know
11:01:18 <edwardk> oh, good then i can adapt it to use the streams package ;)
11:01:50 <edwardk> http://hackage.haskell.org/packages/archive/streams/0.8.2/doc/html/Data-Stream-Infinite.html
11:02:18 <nand`> ah, works for me
11:02:21 <nand`> I just went with what hoogle picked up
11:02:28 <nand`> better constructor on that too
11:07:10 <nand`> ‘Future’ looks like NonEmpty
11:07:45 <edwardk> Future is just like NonEmpty except it doesn't waste time putting on and tearing off the constructor
11:08:17 <nand`> the infinite stream zipper looks useful too; I tried using a Control.Lens.Zipper on an infinite traversal and it didn't work out too well
11:08:41 <edwardk> yeah i have an open issue to try to deal with zipping infinite structures more gracefully
11:08:44 <nand`> (I tried implementing ‘infinite memory’ in the most trivial way)
11:08:59 <gabor> edwardk: what I want is a position-aware parsing where each parsed object has a proof of where it came into existence
11:09:02 <nand`> namely s/replicate 30000 0/repeat 0/ :P
11:09:04 <edwardk> https://github.com/ekmett/lens/issues?page=1&state=open
11:09:14 <edwardk> https://github.com/ekmett/lens/issues/81
11:09:18 <edwardk> er that not the issue list
11:09:24 <mizu_no_oto> So osxmonad lets xmonad work with Quartz instead of just X?
11:09:42 <edwardk> you can descend into a zipper that is infinite, but you can't put it back together
11:09:52 <nand`> whoa, traverseBits looks really cool there
11:10:06 <nand`> edwardk: okay
11:10:07 <edwardk> =)
11:10:31 <edwardk> > zipper 1 % fromWithin traverseBits % focus .~ False % right1 % focus .~ True % rezip :: Int
11:10:34 <lambdabot>   2
11:10:46 <edwardk> > zipper 1 % fromWithin traverseBits % focus .~ False % rightmost % focus .~ True % rezip :: Int
11:10:48 <lambdabot>   -9223372036854775808
11:10:52 <nand`> heh
11:11:04 <nand`> WordN might've been better for that
11:11:09 <edwardk> > zipper 1 % fromWithin traverseBits % focus .~ False % rightmost % focus .~ True % rezip :: Word16
11:11:11 <lambdabot>   32768
11:11:52 <nand`> > 0 % traverseBits .~ True :: Word16
11:11:54 <lambdabot>   65535
11:12:22 <nand`> > 12345 % traverseBits %~ not :: Word16
11:12:24 <edwardk> > 12 % traverseBits %~ not :: Word16
11:12:24 <lambdabot>   53190
11:12:25 <edwardk> hah
11:12:26 <lambdabot>   65523
11:12:38 <nand`> :)
11:12:59 <edwardk> > 12345^..traverseBits
11:13:01 <lambdabot>   [True,False,False,True,True,True,False,False,False,False,False,False,True,T...
11:13:11 <nand`> I keep forgetting about those handy aliases
11:13:17 <nand`> > toListOf traversebits 12345
11:13:17 <edwardk> that gives back an infinite traversal on Integer
11:13:19 <lambdabot>   Not in scope: `traversebits'
11:13:19 <lambdabot>  Perhaps you meant one of these:
11:13:19 <lambdabot>    `traverseB...
11:13:52 <nand`> that is interesting
11:14:05 <edwardk> > toListOf traverseBits 12345
11:14:06 <nand`> (what's the rational behind ^.. anyway?)
11:14:07 <lambdabot>   [True,False,False,True,True,True,False,False,False,False,False,False,True,T...
11:14:14 <nand`> nothing about that operator screams ‘toListOf’ to me
11:14:15 <edwardk> [1 ..  5]
11:14:18 <nand`> oh
11:14:23 <nand`> yes now I remember
11:15:55 <hiptobecubic> :t toListOf
11:15:57 <lambdabot> Getting [a] s t a b -> s -> [a]
11:16:09 <mauke> Getting s t a b b e d
11:16:14 <edwardk> =)
11:16:20 <hiptobecubic> Getting?
11:16:53 <edwardk> Getting r s t a b = (a -> Accessor r b) -> s -> Accessor r t  -- where Accessor is a renamed Const
11:17:07 <nand`> mauke: heh
11:17:20 <edwardk> > [1,2,3]^.mapped
11:17:22 <lambdabot>   No instance for (Control.Lens.Internal.Settable
11:17:23 <lambdabot>                     (Contro...
11:17:35 <edwardk> it gives an error 'no instance for Settable Accessor'
11:17:39 <edwardk> when you go to get from a setter.
11:17:46 <edwardk> rather than a bit unification error.
11:17:49 <nand`> edwardk: re: ‘lots of ugly type variables’ the stuff on magnify/zoom is pretty hefty
11:18:01 <edwardk> its part of the internal trickery in lens
11:18:25 <edwardk> nand`: yeah, but without them you get the crappy version that can only work on the outside of the transformer stack like you get in data-lens, etc.
11:18:59 <edwardk> this lets it zoom in on state that occurs way down in the monad transformer stack -- and it lets it work correctly with traversals, running the monadic action multiple times and accumulating a monoidal summary of the results.
11:20:07 <edwardk> nand`: re infinite zippers. in theory i could peel off elements from the zipper more carefully, track how far down the list i've actually gone, and then put those back more carefully and take the remaining infinite tail unmodified
11:20:17 <edwardk> that would let me 'rezip' an infinite structure safely
11:20:27 <edwardk> in practice thats pretty damn hard =)
11:20:32 <nand`> speaking of monoids, I've always wondered if there's some kind of variant on Writer that has efficient append, sort of like a Writer (DList a) but without the need to do all of the conversions manually; with the primitive function being something like log :: a -> Log a ()
11:20:40 <nand`> where Log a ≅ Writer [a]
11:20:51 <edwardk> nand`: just use Seq
11:20:57 <nand`> oh right, Seq
11:21:05 <nand`> I keep forgetting about that
11:21:31 <nand`> edwardk: would be interesting if you could manage to implement it :)
11:21:43 <nand`> I want to show off with generalized all-purpose zippers
11:23:10 <edwardk> yeah its an open issue because i haven't figure out the right incantation
11:27:38 <nand`> ‘streams’ has some pretty old dependencies
11:27:45 <nand`> on stuff like semigroupoids or comonad
11:27:48 <edwardk> just started patching those =)
11:28:09 <nand`> conflicts with groupoids, kan-extensions and profunctors
11:28:14 <edwardk> yep
11:28:16 <nand`> I can't use it
11:28:18 <edwardk> and lens, and all sorts of things
11:28:21 <edwardk> i'm fixing it up now
11:28:27 <nand`> alright
11:34:10 * hackagebot hinotify 0.3.5 - Haskell binding to inotify  http://hackage.haskell.org/package/hinotify-0.3.5 (LennartKolmodin)
11:34:23 <edwardk> nand`: taking a few minutes because there are a lot of changes to make =)
11:37:16 <edwardk> nand`: ok, streams-3.0 released. pushed to hackage. incurring _that_ dependency now =)
11:37:28 <jix> /w 20
11:39:10 * hackagebot streams 3.0 - Various Haskell 2010 stream comonads  http://hackage.haskell.org/package/streams-3.0 (EdwardKmett)
11:39:11 <nand`> edwardk: updated, hackported, emerged, updated, built, pushed to darcshub :)
11:39:25 <edwardk> =)
11:41:14 <neutrino> hey guys
11:41:28 <neutrino> is there something like test-framework which supports quickcheck 2?
11:42:03 <edwardk> http://hackage.haskell.org/package/test-framework-quickcheck2
11:42:05 <edwardk> =)
11:42:24 <edwardk> its just another plugin like the base quickcheck one
11:49:10 <neutrino> edwardk: i've seen that, but apparently that page says the test reports come out garbled?
11:49:21 <edwardk> i've never used it
11:49:22 <neutrino> edwardk: have you ever used it? is it "serious"?
11:49:25 <neutrino> ok
11:49:31 <edwardk> i just saw that it was there
11:49:40 <neutrino> yeah
11:49:44 <neutrino> it is.
11:50:09 <edwardk> the only quickchecks i have anymore are run directly now that i look at it
11:50:29 <neutrino> how do you run it directly?
11:50:40 <neutrino> i'm still not sure how to structure my whole project so that i can execute tests etc
11:50:56 <neutrino> what i have right now is a single .hs file
11:50:56 <nand`> me neither
11:51:07 <edwardk> neutrino: https://github.com/ekmett/lens/blob/master/lens.cabal#L247
11:51:28 * nand` has never used cabal, haddock, written a test framework or published a library :(
11:51:36 <edwardk> neutrino: https://github.com/ekmett/lens/blob/master/tests/properties.hs#L87
11:52:10 <typoclass> nand`: cabal is dead simple, you just do "cabal init" and answer the questions :-) then you can "cabal install" (without parameters)
11:52:36 <nand`> but I don't have cabal-install :P
11:52:43 <neutrino> right, once you have this line in your .cabal how do you invoke it?
11:52:45 <nand`> I'd need to create the Setup.hs manually I guess
11:52:50 <nand`> and I have no idea how to edit .cabal files
11:52:52 <neutrino> something like "cabal test"?
11:53:06 <neutrino> i have never used .cabal files either but i'll figure it out eventually ...
11:53:30 <osa1> can anyone recommend me some texts for understanding basic logic topics related with type theory, type systems, programming language etc.
11:53:33 <dcoutts> nand`: cabal init makes the default Setup.hs
11:53:49 <merijn> nand`: Cabal files are pretty simple to edit by hand
11:53:55 <merijn> nand`: THey're mostly trivially obvious
11:54:05 <rwbarton> wait you've never used cabal-install?
11:54:11 <merijn> osa1: Types and Programming Language?
11:54:15 <merijn> @where tapl
11:54:16 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
11:54:22 <edwardk> nand`: ok i pushed the interpreter into lens-examples, along with a bunch of your brainfuck test scripts. they all seem to work
11:54:30 <rwbarton> or just never used cabal-install for your own projects
11:54:33 <merijn> osa1: Or *just* logic?
11:54:45 <hpaste> Shammah pasted “Composition Fail” at http://hpaste.org/77338
11:54:45 <neutrino> osa1: google for "this ftp site"
11:54:54 <edwardk> that took a bit longer than i expected ;)
11:55:06 <Shammah> Hey everybody, I'm trying to write something in point free style but I can't get it to work properly, http://hpaste.org/77338
11:55:16 <osa1> neutrino: does that site have introductory texts ?
11:55:24 <Shammah> somehow the (.) composition fails to ocmply and I can't figure it why it's wrong
11:55:24 <neutrino> fsvo
11:55:29 <Shammah> *compile
11:55:38 <mauke> Shammah: it tells you why
11:55:41 <mauke> the types don't match
11:55:47 <boris``> is there a way i can have ghci use a compiled part of some of my code, purely for performance?
11:55:54 <edwardk> Shammah: (.) there is trying to match up with the wrong argument ;)
11:55:57 <Shammah> Well that's exactly what I don't get, how do the types not match?
11:55:58 <mauke> compositionFail = rev . test
11:56:05 <mauke> compositionFail x = rev (test x)
11:56:06 <osa1> merijn: I'm already reading that but that book doesn't help for logic. ie it mentions to "constructive logic", "predicate logic", "unification" etc. but doesn't actually explains them
11:56:10 <Shammah> I mean, test returns a [Int], what is required by rev
11:56:10 <mauke> rev takes a list
11:56:17 <mauke> Shammah: no, it doesn't
11:56:18 <Shammah> yes, but test returns a list?
11:56:27 <mauke> Shammah: test returns a function Double -> [Int]
11:56:40 <edwardk> lets pointfree compositionSuccess; compositionGood x = rev . test x
11:56:48 <edwardk> you tried to remove two arguments in one step.
11:56:50 <neutrino> ok, let me start with cabalizing my thing
11:56:57 <Shammah> but shouldn't compositionFail x a work aswell then?
11:57:01 <Shammah> giving the composition 2 arguments
11:57:03 <neutrino> and then try to put it under quickcheck with test-framework-quickcheck2
11:57:12 <mauke> Shammah: compositionFail x a = rev (test x) a
11:57:15 <edwardk> no. if you remove another argument now you need to start messing with the .
11:57:18 <mauke> now you're calling rev with two arguments
11:57:30 <Shammah> oh
11:57:30 <edwardk> @pl \x -> rev . test x
11:57:31 <lambdabot> (rev .) . test
11:57:35 <edwardk> which is ugly
11:57:39 <edwardk> its better with just one arg pointfree
11:57:52 <edwardk> @pl \x a -> rev $ test x a
11:57:53 <lambdabot> (rev .) . test
11:58:10 <edwardk> @pl \a -> rev $ test x a
11:58:11 <lambdabot> rev . test x
11:59:23 <atriq> I'm annoyed at the new TypeOperators
11:59:31 <Shammah> ah yes, now I undersyand
11:59:34 <Shammah> *understand
12:00:44 <atriq> :(
12:00:47 <Shammah> (rev .) . test works indeed, but it is quite ugly
12:01:26 <Shammah> I'll do some tinkering around, thanks for the help :)
12:03:07 <edwardk> Shammah: i'd recommend the middle version with one arg
12:03:31 <edwardk> you can play games to make that version a little less ugly using the (.) = fmap notion
12:03:36 <edwardk> fmap rev <$> test
12:03:43 <edwardk> but its getting silly
12:03:48 <Shammah> well, this is just a simple test case, my real function has 5 arguments
12:03:52 <Shammah> it gets rather ugly
12:04:06 <edwardk> i don't recommend using pointfree style to remove more than one argument.
12:04:25 <neutrino> what does this text mean in the .cabal file? "modules included in this executable, other than Main"
12:04:26 <Shammah> indeed, it's shorter now but definately not any more readable
12:04:36 <neutrino> what does it mean that a module is included in an executable?
12:05:42 <edwardk> neutrino: it means you used it
12:05:51 <Rc43> Hi, guys.
12:05:52 <edwardk> neutrino: what are the modules Main depends on
12:06:30 <Rc43> Why toEnum and fromEnum operates with Int but not Integer? It forbids infinite types.
12:06:47 <neutrino> oh
12:06:55 <neutrino> so if i use Data.Lens then i put it there?
12:07:10 <neutrino> why does the .cabal file need that info?
12:07:13 <edwardk> neutrino: no. if you had another local .hs file that Main used.
12:07:17 <neutrino> oh
12:07:24 <Rc43> Hmm, but Integer is instance of Enum ...
12:07:30 <edwardk> like you had Main.hs  and also Foo.hs and Bar.hs
12:07:48 <neutrino> and in Main i would use "import Foo" to load code from Foo.hs?
12:07:49 <kirindave> Hrrrmmmm.
12:07:56 <neutrino> then i'd put Foo in there?
12:08:03 <neutrino> or src/Foo.hs ?
12:08:46 * neutrino has never written a haskell program bigger than 1 file
12:08:49 <neutrino> :D
12:09:52 <edwardk> you'd probably say hs-src-dirs: src and then say 'Foo' in there
12:10:00 <kirindave> Hum.
12:10:04 <edwardk> er hs-source-dirs: src
12:10:11 <neutrino> gotcha
12:10:12 <Rc43> And is it true that because of Int in signature of toEnum/fromEnum it is impossible to define proper List instance of Enum?
12:10:16 <neutrino> thanks
12:10:38 <Rc43> I tried but stuck with these functions.
12:10:41 <rahul_> does anyone know the ubuntu/debian package name for extralibs? libghc6-library-dev doesn't seem to work
12:11:10 <kirindave> edwardk: Pardon me.
12:11:26 <kirindave> edwardk: What's the right type for something like: traversalHelper lens maction = (lens .=) =<< mapM maction =<< use lens
12:11:39 <kirindave> I write this in my monadic actions (or code identical after sugar)
12:11:52 <kirindave> And it works
12:12:07 <kirindave> but when I try to break it out into its own helper "Getting" and "Setting" have a fight in the types.
12:12:34 <edwardk> you can do x <- use l;  l <~ mapM maction x
12:12:38 <edwardk> lets see if we can do better though
12:12:40 <kirindave> I do precisely that.
12:12:58 <rwbarton> :t \lens maction -> (lens .=) =<< mapM maction =<< use lens
12:12:58 <edwardk> oh the type for l?
12:12:59 <lambdabot>     Couldn't match expected type `Accessor [a0] b0'
12:12:59 <lambdabot>                 with actual type `Mutator [b1]'
12:12:59 <lambdabot>     Expected type: Getting [a0] s1 t0 [a0] b0
12:13:07 <kirindave> edwardk: Precisely.
12:13:09 <edwardk> that has to be an honest to goodness Lens
12:13:13 <rwbarton> is this what clone is for?
12:13:20 <edwardk> you have to put a real signature on it or use cloneLens
12:13:24 <kirindave> edwardk: I'm using things made by madeLenses.
12:13:30 <kirindave> err, makeLenses
12:13:32 <edwardk> :t \l x -> do x <- use cloneLens l;  cloneLens l <~ mapM maction x
12:13:34 <lambdabot> Not in scope: `maction'
12:13:40 <edwardk> :t \l x maction -> do x <- use cloneLens l;  cloneLens l <~ mapM maction x
12:13:42 <lambdabot>     Couldn't match expected type `Accessor
12:13:42 <lambdabot>                                     (a0 -> Control.Lens.Internal.Context a0 b1 b1) b0'
12:13:42 <lambdabot>                 with actual type `s0 -> Control.Lens.Internal.Context a0 b1 t0'
12:13:50 <edwardk> :t \l x maction -> do x <- use (cloneLens l);  cloneLens l <~ mapM maction x
12:13:51 <lambdabot> MonadState s m => LensLike (Control.Lens.Internal.Context [a] [b]) s s [a] [b] -> t -> (a -> m b) -> m ()
12:14:04 <edwardk> :t \l x maction -> do x <- use (cloneLens l);  cloneLens l <~ Data.Traversabe.mapM maction x
12:14:06 <lambdabot> Couldn't find qualified module.
12:14:09 <edwardk> :t \l x maction -> do x <- use (cloneLens l);  cloneLens l <~ Data.Traversable.mapM maction x
12:14:11 <lambdabot> (Traversable t1, MonadState s m) => LensLike (Control.Lens.Internal.Context (t1 a) (t1 b)) s s (t1 a) (t1 b) -> t -> (a -> m b) -> m ()
12:14:27 <kirindave> Ah. Cool.
12:14:49 <edwardk> you can rip the cloneLenses off if you write the signature directly using Len
12:15:03 <edwardk>  (Traversable t1, MonadState s m) => Lens s s (t1 a) (t1 b) -> t -> (a -> m b) -> m ()
12:15:20 <byorgey> discussion in #haskell these days seems to be entirely about lens =)
12:15:34 <edwardk> that enables it to be instantiated to both Accessor and Mutator for its two use sites
12:15:40 <edwardk> byorgey: sorry =)
12:15:45 <byorgey> not that there's anything wrong with that, it's just amusing =)
12:15:55 <byorgey> edwardk: don't be sorry for writing an awesome library that everyone wants to use!
12:16:04 <kirindave> edwardk: That's what I was struggling with. I know there has to be a valid type to write to make it work, since it appears in sugared code.
12:16:10 <kirindave> edwardk: Thanks!
12:16:55 <edwardk> lambdabot even knows about constraints now =)
12:17:04 <edwardk> :t cls :: Ord a :- Eq a
12:17:06 <lambdabot> Ord a :- Eq a
12:17:14 <hpc> :t cls
12:17:16 <lambdabot> Class b h => h :- b
12:17:33 <edwardk> :t ins :: Ord a :- Ord [a]
12:17:35 <lambdabot> Ord a :- Ord [a]
12:17:47 <hpc> :k (:-)
12:17:48 <lambdabot> Constraint -> Constraint -> *
12:18:01 <edwardk> :t trans ins cls :: Ord a :- Eq [a]
12:18:03 <lambdabot> Ord a :- Eq [a]
12:18:17 <atriq> Constraints are something I need to learn
12:18:18 <edwardk> hpc: its a notion of entailment
12:18:26 <edwardk> read it like |- in the logical sense
12:18:52 <hpc> i forget what entaailment is
12:18:55 <edwardk> cls is the witness that a having a dictionary for a class entails the dictionaries of its superclasses
12:20:48 <edwardk> hpc: are you familiar with capturing a dictionary in a GADT? e.g. data Showable = forall a. Show a => Showable a
12:20:55 <hpc> yes
12:20:56 <danharaj> edwardk: do the lens generation templates add INLINE pragmas or anything?
12:21:24 <edwardk> e.g. data Ordered a where Ordered :: Ord a => Ordered a
12:21:26 <edwardk> danharaj: they do!
12:21:52 <hpc> Class b h captures (b => h)
12:21:54 <edwardk> data Equatable a where Equatable :: Eq a => Equatable a
12:22:09 <edwardk> Class b h captures the knowledge that b is the superclass of h
12:22:26 <edwardk> there is a similar type for capturing instance information
12:22:27 <hpc> sounds like flip (implies)
12:22:39 <edwardk> eg. instance Ord a => Ord [a]   also provides information you can use
12:23:46 <edwardk> constraints provides two simple types using the new constraint kinds that let me avoid making custom data types for every class
12:23:57 <edwardk> data Dict p where Dict :: p => Dict p
12:24:04 <edwardk> that generalizes 'Ordered' and 'Equatable'
12:24:29 <edwardk> so 'Dict (Ord a)' and 'Dict (Eq Int)'  capture information about the existence of a dictionary
12:24:47 <edwardk> and we can pattern match on that Dict constructor to bring that knowledge into scope
12:25:10 <edwardk> newtype a :- b = Sub (a => Dict b)   -- captures the fact that if you know 'a' then you can generate a dictionary for b
12:25:20 <edwardk> :t Sub Dict :: Ord a :- Eq a
12:25:23 <lambdabot> Ord a :- Eq a
12:25:26 <edwardk> :t Sub Dict :: Ord a :- Eq [a]
12:25:28 <lambdabot> Ord a :- Eq [a]
12:25:30 <edwardk> :t Sub Dict :: Ord a :- Eq [[a]]
12:25:32 <lambdabot> Ord a :- Eq [[a]]
12:25:36 <edwardk> :t Sub Dict :: Ord a :- Eq b
12:25:37 <lambdabot>     Could not deduce (Eq b1) arising from a use of `Dict'
12:25:38 <lambdabot>     from the context (Ord a1)
12:25:38 <lambdabot>       bound by a type expected by the context: Ord a1 => Dict (Eq b1)
12:25:53 <neutrino> edwardk: how do you invoke the tests from that cabal file you posted?
12:25:55 <edwardk> given Ord a, we can generate Eq a, since Eq is the superclass of Ord.
12:26:11 <hpc> edwardk: what's entails? that is the part i dont get
12:26:13 <neutrino> i guess cabal test?
12:26:18 <edwardk> neutrino: 'cabal install --enable-tests' or cabal configure --enable-tests; cabal build; cabal test
12:26:29 <hpc> i get constraintkinds just fine :P
12:26:55 <edwardk> hpc: entailment is the logical property that you can prove the latter given the former
12:27:02 <neutrino> thank you
12:27:48 <edwardk> http://en.wikipedia.org/wiki/Entailment
12:28:17 <hpc> edwardk: so it's implies, then?
12:28:18 <nand`> so will we be getting type-level computation of Nats?
12:28:23 <edwardk> yes
12:28:26 <nand`> or perhaps a version with negative literals as well
12:28:46 <edwardk> nand`: i think its just nats
12:28:56 <edwardk> which is kinda silly. since it is more total if you include the negative numbers ;)
12:29:07 <neutrino> "totaler"
12:29:11 <neutrino> ;)
12:29:17 <hpc> 'Integer!
12:29:46 <nand`> hpc: :)
12:30:00 <nand`> well, without the ', since that would be a kind anyways
12:30:14 <taylanub> Are monads a type class ?
12:30:25 <nand`> @src Monad
12:30:25 <lambdabot> class  Monad m  where
12:30:25 <lambdabot>     (>>=)       :: forall a b. m a -> (a -> m b) -> m b
12:30:25 <lambdabot>     (>>)        :: forall a b. m a -> m b -> m b
12:30:25 <lambdabot>     return      :: a -> m a
12:30:25 <lambdabot>     fail        :: String -> m a
12:30:39 <taylanub> Is that a yes ?
12:30:53 <taylanub> I assume so, because it looks like one.
12:31:22 <nand`> that's the definition of a type class, yeah; though I just wasn't sure what to answer since ‘monads’ aren't just around in Haskell; though Monad is indeed a type-class in Haskell
12:31:29 <neutrino> edwardk: is there a reason why you're using exitcode-stdio-1.0 and not any other test interface?
12:31:32 <nand`> thought I'd show the definition to be absolute :)
12:31:42 <edwardk> neutrino: sure. show me another one that works ;)
12:31:54 <taylanub> Wikipedia uses the phrasing "arrows are a type class," so I thought I'd use the same.
12:32:31 <taylanub> Although it doesn't speak about Haskell specifically there.  The page on monads doesn't even include phrase "type class."
12:32:31 <nand`> I'm not sure I'd agree with that if I was being pedantic; arrows are again used in lots of other ways than the Arrow type class in Haskell
12:32:53 <edwardk> maybe 'Arrow is a typeclass'
12:32:54 <nand`> (and in different contexts, incidentally, eg. ‘arrow’ as used instead of ‘morphism’ in CT)
12:33:03 <nand`> edwardk: yeah that I would agree with
12:33:15 <taylanub> I understand.
12:33:56 <nand`> what was that library for type-level computation of integers called again?
12:36:38 <rwbarton> type-level
12:37:14 <neutrino> edwardk: thx
12:37:28 <rwbarton> probably there are others too
12:37:57 <nand`> sounds good
12:38:14 <taylanub> Would it be accurate to say that, with contrast to most other OO languages ("class-based" ones like Java), Haskell ditches "classes" and purely uses "interfaces" (aka protocols, aka contracts), and calls them (type) classes ?
12:38:27 <Ralith> haskell is not an OO language.
12:38:40 <taylanub> That's actually just semantics if you ask me. :P
12:38:47 <Ralith> nor are typeclasses interfaces.
12:39:01 <neutrino> i don't think you can say haskell is oriented at all
12:39:03 <shergill> semantics are everything =/
12:39:24 <taylanub> They seemed to me like a concept most akin to interfaces.
12:39:51 <neutrino> typeclasses do seem like interfaces to me too
12:39:58 <neutrino> i'm not sure why you'd say they're not
12:40:14 <nand`> isn't there one that uses type families and DataKinds stuff?
12:40:17 <taylanub> Declaring that certain functions are defined over the type .. that's certainly what interfaces do from all I know.  (I actually don't know Java, but Objective-C.  I assume "protocols" as Objective-C calls them are exactly the same thing as interfaces in Java.)
12:40:24 <nand`> (or is that not as simple as I'm thinking it is?)
12:40:27 <neutrino> especially since they show up in the "composing contracts" paper
12:40:32 <neutrino> read that one taylanub
12:40:38 <neutrino> i think it's by spj
12:40:53 <Jeanne-Kamikaze> it is
12:41:58 <taylanub> I'm phobic to papers.  I usually don't get them.
12:42:04 <Jeanne-Kamikaze> it's not exactly an interface like in Java though
12:42:49 <nand`> the difference between the interface system as I'm familiar with it and type classes is that type classes don't represent concrete types, they represent constraints - meanwhile, interfaced classes are actually subtyped and can be coerced to the interface type
12:42:58 <nand`> interfaces is just restricted subtyping
12:43:35 <Jeanne-Kamikaze> ^ what he said
12:43:40 <neutrino> i think you're just use to an implementation detail of interfaces in some language
12:43:53 <nand`> another big difference between something like Haskell classes and Java is that not only does Haskell have higher order values, it has higher order /types/ as well; you can't write an interface Monad
12:44:01 <neutrino> in general an interface in an oo language means "if this class supports that interface, it has those methods defined"
12:44:17 <nand`> neutrino: that's possible; I meant to emphasize “interface system as I'm familiar with it”
12:44:34 <neutrino> well what does coercing a class to an interface actually do?
12:45:06 <nand`> limits what you can do with it, I guess
12:45:07 <taylanub> Maybe my assumption on the equivalence of ObjC protocols and Java interfaces was wrong.  In ObjC, a protocol is a series of method and property declarations (properties really just come down to getter and setter method too in the end), and any class can be declared to conform to a protocol, in its definition.
12:45:16 <neutrino> right
12:45:25 <neutrino> but it does not let you do *more*
12:45:51 <taylanub> What do type classes provide over this ?
12:45:59 <neutrino> therefore coercing is not relevant to the contract of support, the part that we are actually interested in
12:46:22 <neutrino> taylanub: that's basically what an interface is.
12:46:38 <neutrino> now read the "composing contracts" paper
12:46:43 <Ralith> nand`: in fact, you've accurately described every interface system; neutrino is moving the goalposts :P
12:46:55 <nand`> the main thing that seems to be conflicted in peoples' definitions of ‘object-orientation’ is whether behaviors are associated with types or objects; the latter is what the term was “supposed to have meant”, the former is what Java does
12:46:56 <Nereid> ahh, it's cute to use [x | b] for if b then [x] else []
12:46:57 <Nereid> :D
12:47:05 <neutrino> Ralith: php does not have interface coercing
12:47:14 <Ralith> ah, php.
12:47:27 <nand`> type classes allow for values to be associated with types
12:47:31 <nand`> and data structure fields allow the opposite
12:47:48 <Ralith> a relavant example to any serious discussion of PL design :P
12:48:02 <neutrino> yes
12:48:08 <nand`> “avoid imitating PHP at all costs”
12:48:08 <Rc43> How can I constain values in fields? E.g. I want `newtype AsciiChar = AsciiChar { data :: Char }` and constrain `data` to be ascii.
12:48:14 <taylanub> neutrino: I'm afraid I would need to learn many other things first before being able to understand a paper like that.
12:48:19 <nand`> you can't
12:48:26 <neutrino> also a quick example to shoot down any arguments that say "every language does X"
12:48:36 <neutrino> taylanub: skim over it
12:48:41 <taylanub> Is there a concise summary as to what type classes provide over protocols as described above ?
12:48:44 <nand`> there's no pretty way to do it Rc43, you have to roll your own type
12:49:08 * nand` .oO( Word7 )
12:49:09 <neutrino> Rc43: i think with a lens you can specify the accessors. although not sure.
12:49:29 <neutrino> edwardk will know more.
12:49:34 <nand`> Rc43: or, if you can live with the ugliness, don't export the constructors and define your own :: Char -> AsciiChar
12:49:45 <nand`> or Char -> Maybe AsciiChar
12:49:53 <Ralith> taylanub: it is not a question of "what do they provide" so much as "what are they"
12:49:59 <Ralith> taylanub: what does an orange provide over an apple?
12:50:33 <nand`> type classes are a means to an end, I think you need to know an end before you can discuss the means
12:50:34 <neutrino> Ralith: more vitamin C, less fiber
12:50:41 <taylanub> Ralith: Perception of the color orange, a different feeling of the surface, more water, ...
12:50:45 <neutrino> Ralith: more popular taste
12:51:15 <taylanub> :P
12:51:45 <Ralith> taylanub: indeed; they are different, not a superset.
12:52:00 <taylanub> By the way a Google search for "composing contracts" reveals papers on finance.
12:52:17 <neutrino> by simon peyton jones
12:52:31 <neutrino> iirc it was used in a finance setting
12:52:33 <danharaj> ezyang: attempts to isolate the problem haven't been fruitful. I'm going to give up for now since replacing the INLINE pragma with INLINABLE resolves the issue. Once I am done with the project I'll try harder to get a tight test case.
12:52:46 <taylanub> Oh, then I guess it was the right one already.  Thanks.
12:53:44 <ezyang> danharaj: OK. It is true that minimizing test-cases is fairly time consuming.
12:59:37 <taylanub> Does Java have a variable type that can hold any class ?  (Like `id' in Objective-C, or a bit like a void pointer in C.)
13:00:01 <taylanub> (The question arises from me reading http://blog.tmorris.net/type-classes-are-nothing-like-interfaces/ .)
13:00:18 <byorgey> taylanub: Object
13:00:40 <danharaj> ezyang: every reduction I try to do seems to make the problem disappear, so I can't extract the problematic term from its context.
13:01:09 <ezyang> danharaj: What kind of reductions are you doing?
13:01:30 <taylanub> Then I don't get (yet) why that article would rave about type classes and interfaces having *nothing* to do in common.  I shall read on (or re-read).
13:01:44 <danharaj> ezyang: replacing an ST action with a stub action, trying to put all the dependencies in one module
13:02:34 <shergill> taylanub: it's possible that that's not a very good article. if you haven't already, i would recommend learn you a haskell, followed by typeclassopedia and real world haskell
13:02:38 <ezyang> Can you paste the code somewhere?
13:05:11 <byorgey> taylanub: I don't think it's true that type classes are *nothing* like interfaces.
13:05:17 <byorgey> taylanub: but there are significant differences.
13:05:28 <danharaj> ezyang: I'm about to leave the computer unfortunately. I have one last hunch.
13:05:37 <byorgey> taylanub: but what does Object have to do with it?
13:05:47 <Ralith> so what's the relationship between mtl and transformers?
13:06:27 <atriq> Ralith, mtl is a library which takes transformers and adds some more advanced features to it
13:07:01 <neutrino> can you define multiple modules in a single .hs file?
13:08:03 <atriq> Ralith, these features rely on GHC extensions (such as Functional Dependencies)
13:08:24 <Ralith> transformers is pure Haskell98?
13:09:08 <atriq> I believe so
13:09:37 <atriq> But mtl is very stable
13:09:43 <atriq> Don't be afraid of using it
13:10:06 <danharaj> ezyang: here is the top level code and something I just discovered about it: http://hpaste.org/77341
13:10:24 <danharaj> ezyang: perhaps later I can piece together all the dependencies to see exactly what the hell is going on.
13:11:28 <taylanub> byorgey: If there were no "void" type to hold any class, one couldn't e.g. declare a function to be defined over all objects conforming to an interface; one would have to further limit it to a class.  I thought the author might have been thinking about that.
13:13:51 <taylanub> The author was a bit excited over the matter I guess.  I noted the one difference ey mentioned though: One needn't list all classes a type belongs to in its declaration, but can do this later, incrementally.
13:14:04 <byorgey> yes, that's one big difference
13:16:20 <merijn> taylanub: Another important difference is the ability to be polymorphic in function return values and values rather than just parameters
13:17:13 <merijn> taylanub: Think of (for example) the "read :: Read a => String -> a" function. That couldn't work with interfaces as the interfaces usually use the input parameter to decide which actual code to run
13:17:58 <merijn> taylanub: Or minBound/maxBound which have type "Bounded a => a" (i.e. polymorphic values, instead of functions)
13:18:33 <merijn> taylanub: Finally, typeclass can use more than 1 of the input types to select an implementation
13:19:34 <merijn> taylanub: Take for example the (silly) typeclass "class Combiner a b c where combine :: a -> b -> c" the exact implementation of combine is decided by all 3 parameters of the combine function, instead of just one
13:20:42 <taylanub> I see.
13:22:09 <efie> I don't see how I can turn the string "\\8211" into "\8211" so that I can putStrLn to print >  –  < to the terminal, could someone help?
13:22:42 <merijn> > read "\\8211" :: String
13:22:44 <Nereid> > read "\"\\8211\"" :: String
13:22:44 <lambdabot>   "*Exception: Prelude.read: no parse
13:22:45 <lambdabot>   "\8211"
13:22:55 <merijn> hmm
13:23:19 <merijn> > read "\'\\8211\'" :: Char
13:23:20 <lambdabot>   '\8211'
13:23:37 <Nereid> > read "'\\8211'" :: Char
13:23:39 <lambdabot>   '\8211'
13:23:41 <Nereid> no need to escape ' there
13:24:04 <vininim_> madness
13:24:14 <merijn> oh, duh
13:26:50 <efie> thanks
13:32:30 <neutrino> edwardk: why do you put your tests under tests/ and not under src/ with the other modules?
13:32:51 <edwardk> neutrino: because then it becomes a more obvious error when the code in src accidentally refers to a test module
13:33:06 <edwardk> otherwise it succeeds until i upload it to hackage whereupon it breaks for third party users
13:33:21 <neutrino> why does it break?
13:33:59 <edwardk> because i probably wouldn't list those test modules as an actual other-module: in the library, so the files might not get uploaded, etc.
13:34:05 <edwardk> its just a separation of concerns
13:34:15 <edwardk> and avoids a class of errors =)
13:34:20 <frio> putting tests in test/ is a pretty standard idiom
13:34:38 <neutrino> oh ok
13:34:46 <neutrino> frio: why?
13:35:07 <frio> separation of concerns, i guess
13:35:32 <frio> it's a patter you'll see repeated across pretty much any language/build system (java/mvn, clojure/lein, javascript/grunt, etc. etc.)
13:35:40 <frio> *pattern
13:35:47 <edwardk> makes it easier to spot what code is really test code and what isn't. makes sure that the other src doesn't depend accidentally on the test code which often has much more baroque dependencies, etc.
13:36:08 <neutrino> but what if my test code is all under */Test/ ?
13:36:35 <edwardk> you are free to deal with this differently in your own packages of course ;)
13:37:05 <edwardk> then perhaps you should just move it all up into the top level directory and not bother with such distinctions
13:38:19 <neutrino> do files under src/ get treated specially somehow?
13:38:24 <edwardk> no
13:38:26 <neutrino> like eg every file gets installed
13:38:37 <neutrino> i understand i normally wouldn't want test code installed
13:38:42 <edwardk> its just that i included an hs-source-dirs: src command to tell ghc to look in there for source files.
13:39:00 <Jello_Raptor> ... well that was annoying. They're trying to teach us functional programming in school with OCaml. I keep on finding myself using haskellisms, and having a hell of time debugging, since my brain doesn't register them as syntax errors.
13:39:12 <edwardk> nothing that isnt referred to by the cabal file in some fashion either as an exposed-modules: or other-modules: or as a main for a test, etc. gets installed
13:39:23 <edwardk> src isn't magic
13:39:37 <neutrino> mhm
13:39:46 <byorgey> any advice: what's the state-of-the-art in making Haskell bindings to a json-based web API?
13:40:02 <mauke> Jello_Raptor: at least you're intimately familiar with autocurrying :-)
13:40:14 <byorgey> are there any tools to help with that (beyond json parsing + serializing)?
13:40:56 <neutrino> thanks edwardk you're great help
13:41:01 <edwardk> np
13:42:06 <Jello_Raptor> mauke: yeah, there is that :P classmates are having a hell of time with stuff i breeze through quickly. I am quite glad i got to learn functional programming on my own, and with a language more strict than ocaml.
13:42:11 <espringe> What's the right way of doing this:
13:42:12 <espringe> last $ [eval a env, eval b env]
13:42:12 <espringe> And I need that to happen in a strict sense. i.e. the eval function called on a, then called on b. And then I return the result of the second invocation. If the first call to eval has any Trace statements, they should happen. Or of "eval a env" is an infinite loop, I don't want it to proceed to the "eval b env" etc.
13:43:37 <mauke> eval a env `seq` eval b env may work
13:44:08 <mauke> or (eval a env `seq` id) (eval b env)
13:44:13 * hackagebot ply-loader 0.1.0.3 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.1.0.3 (AnthonyCowley)
13:44:37 <espringe> Cool, thanks mauke! I'll try both
13:45:19 <byorgey> that will not guarantee that all calls to 'trace' in eval a env will happen
13:45:31 <byorgey> because seq only evaluates to weak head normal form
13:45:39 <byorgey> it depends what type is returned by eval
13:45:46 <mauke> oh, true
13:46:17 <mauke> replace ｢eval a env｣ by ｢length (show (eval a env))｣
13:46:29 <byorgey> hehe, that works =)
13:46:34 <byorgey> poor man's deepSeq
13:47:23 <espringe> (The return type of my "eval" function is a "atom" (a 'any' type in my languague))
13:47:41 <espringe> I'll do the length of show :D
13:47:59 <byorgey> espringe: yes, that's probably necessary
13:50:08 <mauke> module Poor where deepSeq = seq . length . show; pseq = flip seq id
13:50:21 <nand`> is there an implementation of type-level integers that uses DataKinds and type families instead of ugly classes and * kinds?
13:50:28 <Nereid> mauke: haha
13:51:03 <rwbarton> @unpl flip seq id
13:51:04 <lambdabot> (\ c -> seq c (\ d -> d))
13:51:05 <nand`> failing that, what's the best way to extend peano naturals to negative integers, while avoiding duplicates (eg. only one way to encode any integer)?
13:51:15 <Nereid> :t flip seq id
13:51:16 <lambdabot> a -> a1 -> a1
13:52:14 <Nereid> nand`: well an integer is either nonnegative or negative, so ...
13:52:23 <Nereid> it might be a bit ugly though
13:52:55 <simpson> Nereid: Well, if N negates, then NSO is -1, NSSO is -2, SNSSO is also -1?
13:53:03 <nand`> I've seen an approach like N1 = One | S N1; N0 = Zero | N1 N1; Int = Neg N1 | Pos N0
13:53:11 <merijn> nand`: 7.6 has promoted literals, but not yet any type level operators for them
13:53:13 <Nereid> SimonRC: but NSO = SNO
13:53:23 <Nereid> and we don't want duplicates
13:53:30 <j4hr0m> hi room
13:53:35 <simpson> Nereid: Yes, that's why I was saying that a negation is wrong.
13:53:38 <nand`> merijn: 1. those don't allow nonnegative literals, 2. without type-level addition they are useless to me
13:53:38 <byorgey> hi j4hr0m
13:53:39 <mauke> >room
13:53:39 <simpson> Also I'm not simon. :3
13:53:48 <Nereid> oops
13:53:52 <mSSM> I have found some interesting code online which contains "import qualified Data.Vector.Storable.Mutable as V", for which however ghc gives me: "Could not find module `Data.Vector.Storable.Mutable'" - what's up with that?
13:53:58 <merijn> nand`: They're don't allow negative values? Ah, bah...
13:54:10 <nand`> merijn: kind Nat
13:54:12 <Nereid> nand`: I mean Int is like Either Nat Nat, where Reft n is -1-n and Right n is n
13:54:17 <byorgey> mSSM: presumably you do not have the package with that module installed
13:54:28 <Nereid> Left*
13:54:30 <Nereid> haha Reft.
13:54:50 <byorgey> mSSM: it's probably from the 'vector' package
13:54:53 <byorgey> @package vector
13:54:54 <lambdabot> http://hackage.haskell.org/package/vector
13:54:55 <j4hr0m> i wonder why :t (*3), :t (/3), :t (+3) is giving me another type as :t (-3)
13:54:59 <merijn> Nereid: Eh, why not "Left n = -n"?
13:55:09 <Nereid> j4hr0m: because (-3) is the number "negative 3"
13:55:17 <Nereid> merijn: because Left 0 and Right 0
13:55:18 <nand`> merijn: because Left 0 vs Right 0
13:55:33 <byorgey> j4hr0m: this is an ugly corner case of Haskell syntax.  if you want the function that subtracts 3, use (subtract 3)
13:55:35 <Nereid> j4hr0m:
13:55:37 <Nereid> :t subtract 3
13:55:38 <lambdabot> Num a => a -> a
13:55:44 <byorgey> j4hr0m: the function 'subtract' is provided for exactly this reason
13:55:46 <nand`> ‘Left 0’ would be -1; and what the function on that would look like scares me
13:55:51 <j4hr0m> Nereid: thanks
13:56:02 <nand`> I think the N1/N0 approach is the most straightforward to implement
13:56:04 <byorgey> nand`: why do you want to avoid duplicates?
13:56:05 <merijn> Nereid: What's problematic about having 2 zeros?
13:56:14 <Nereid> merijn: he just said he doesn't want duplicates.
13:56:15 <nand`> byorgey: so I can use equality constraints
13:56:51 <Nereid> nand`: ah that's probably better
13:57:02 <Nereid> well, it's the same
13:57:07 <nand`> yes
13:57:08 <simpson> nand`: Out of curiosity, why do you want negatives?
13:57:10 <byorgey> nand`: aha, but if you use a pair of naturals (n1,n2) interpreted as  (n1 - n2), you can check equality of  (n1,n2) and (m1,m2) by  (Add n1 m2 ~ Add n2 m1)
13:57:32 <Nereid> byorgey: but he can't write (n1,n2) ~ (m1,m2) to mean that
13:58:45 <nand`> simpson: I'm trying to implement a 7.6-esque ‘SI units’ system; with (+) :: Num a => a:@u -> a:@u -> a:@u;  and (*) :: Num a => a:@u -> a:@v -> a:@(u*v); (:@) :: * -> SI -> *; and SI :: Int -> Int -> Int -> ... -> SI
13:59:04 <nand`> byorgey: that could work
13:59:11 <simpson> Hm.
13:59:15 <nand`> simpson: each Nat represents the exponent of that particular unit
13:59:36 <nand`> multiplying numbers is equivalent to adding the exponents, taking the reciprocal (eg. dividing) is equivalent to negating the exponents
13:59:41 <nand`> err, each Int
13:59:54 <byorgey> Nereid: right, of course not, but why is that important?
14:00:06 <rwbarton> if you want to have a type family indexed on integers
14:00:09 <merijn> nand`: Why not implement equality/comparisons using typeclasses?
14:00:25 <Nereid> byorgey: I don't know, it's nand`'s thing
14:00:26 <nand`> that's possible, but I think it's uglier
14:00:36 <merijn> nand`: Why is it uglier?
14:00:37 <byorgey> nand`: in the representation I said, addition is just done pairwise
14:00:45 <byorgey> and multiplication is not hard to work out either
14:00:58 <byorgey> the really nice thing is that you don't have to do case analysis anywhere
14:01:17 <Nereid> but the not-so-nice thing is that you don't get a unique representative for each integer
14:01:24 <nand`> byorgey: that sounds interesting
14:01:39 <nand`> merijn: I don't know, perception thing I guess?
14:01:52 <nand`> I've never liked MPTCs
14:01:54 <merijn> You can write a class like "class (m :: Nat) :<= (n :: Nat)"
14:02:10 <Nereid> although you could write a thing that picks out a canonical representative I guess
14:02:26 <merijn> That lets you write "foo :: (m <:= n) => Bar n -> Bar m -> Baz"
14:02:31 <merijn> eh
14:02:37 <merijn> (m :<= n)
14:02:46 <byorgey> Nereid: yes, a canonicalization function is quite easy to write
14:02:51 <Nereid> yes
14:02:59 <byorgey> the canonical representative of any given integer is always of the form (0,n) or (n,0)
14:03:02 <Nereid> yes
14:03:45 <Nereid> and then you could make sure the type operators you expose always canonicalize their results
14:03:46 <nand`> (I don't ever need multiplication either way, so the simple pairwise addition works out great)
14:04:19 <Nereid> but type families are ugh so I wonder if you'd encounter any issues with all that
14:04:32 <nand`> maybe some UndecidableInstances
14:04:33 <byorgey> yeah, I don't know how it would all work out in practice.
14:05:11 <merijn> Nereid: What's wrong with type families?
14:05:33 <johnw> When I run "yesod devel" (which hsenv, GHC 7.6 and cabal 1.16), I get this:
14:05:34 <hpaste> johnw pasted “yesod erro” at http://hpaste.org/77353
14:05:40 <johnw> has anyone seen this before?
14:06:18 <donri> edwardk: 0.8.2 -> 3.0? :)
14:07:04 <edwardk> donri: i aligned it with all the other packages
14:07:10 <luite> johnw: are you using virthualenv or something similar?
14:07:24 <johnw> hsenv, which virthualenv became
14:07:36 <donri> ah
14:07:40 <edwardk> donri: there are similar jumps in about a third of my packages
14:07:41 <luite> johnw: ah, that changes the dist dir, doesn't it?
14:07:47 <Nereid> merijn: they don't always do what you want them to do
14:07:48 <johnw> yes
14:07:48 <Nereid> :)
14:07:52 <donri> hsenv, y u no hackage
14:07:55 <johnw> i can try this in the main cabal
14:08:08 <edwardk> some of them like representable-functors had gotten up into that territory. when i went to update comonad, i did a big global version sync on most of my packages to bring them to 3.0
14:08:13 <edwardk> i apparently missed streams
14:08:31 <donri> i see
14:08:35 <luite> johnw: yeah, symlink dist to the real dist dir i think, the current version on github has an option to change the dist dir location (command line ooption or env var), but it still needs a bit more testing, so it's not yet released
14:08:59 <johnw> hmm.. it wants downgrade my unix-compat from 0.4.0.0 to 0.3.0.2, which is why I didn't want to install this in my main repository
14:10:03 <luite> johnw: oh that's interesting, maybe some stuff in your cabal file is outdated? the latest yesod-platform depends on 0.4.0.0
14:10:16 <johnw> let me make sure I'm not out of date
14:10:53 <johnw> yesod-platform 1.1.1.4?
14:11:24 <luite> 1.1.4.1 is the latest
14:11:32 <edwardk> so i brought it inline with the others when i added a brainfuck example to lens
14:11:34 <johnw> yeah, that's what I meant
14:11:55 <johnw> yesod 1.1.2 changes unix-compat to 0.3.0.2.  maybe yesod init created some old dependencies
14:13:09 <luite> hm, i wonder if yesod init should get the scaffold files directly from github instead of using possibly outdated baked in things
14:13:39 <johnw> yeah, no matter what I try it wants to install unix-compat 0.3.0.2
14:13:51 <johnw> yesod-1.1.2 does this
14:13:53 <luite> you can try --constraint=unix-compat==0.4.0.0
14:14:02 <johnw> ok, i'll try that
14:14:14 * hackagebot parsec-utils 0.1.0.0 - Utility functions and combinators for Text.Parsec  http://hackage.haskell.org/package/parsec-utils-0.1.0.0 (RemcoNiemeijer)
14:14:15 <luite> probably something will fail, but at least you know why :)
14:15:13 <johnw> huh
14:15:34 <johnw> if i then install yesod-platform again, it wants to bump unix-compat to 0.40..0, but wants to downgrade warp
14:15:39 <johnw> cabal can get so confusing
14:16:09 <luite> hm, yesod-platform has a single version for all dependencies, it might not yet have been updated for the latest warp
14:16:20 <johnw> or the latest yesod-auth, apparently
14:16:30 <johnw> or the latest wai-app-static
14:17:13 <johnw> so, this is very weird
14:17:29 <johnw> you can cabal install yesod-platform and also cabal install a project made with "yesod init" by that platform
14:17:32 <johnw> s/can/cannot
14:18:10 <luite> johnw: hm why not?
14:18:20 <johnw> one sec, i'll show you
14:18:55 <hpaste> johnw pasted “yesod hell” at http://hpaste.org/77356
14:19:15 <johnw> so, i did "cabal install --force-reinstalls" to get my demo app to install (created by yesod init)
14:19:17 <tac-nap> johnw: that's called recursion.
14:19:31 <tac-nap> To install yesod, you have to installed all the dependencies. To install those, you need to install their dependencies.
14:19:35 <johnw> then I tried "cabal install yesod-platform"
14:19:38 <johnw> then I forced that
14:19:47 <tac-nap> But unlike well-founded recursion, it ends in sadness and stack overflows :P
14:19:51 <johnw> then I tried "cabal install" in my sample app again
14:19:52 <rwbarton> did you cabal configure in "reddit"?
14:19:58 <rwbarton> is that automatic?
14:20:12 <rwbarton> hmm
14:20:21 <dcoutts_> johnw: don't do it! don't keep switching back and forth. Ask once, to install all the things you need simultaneously.
14:20:39 <johnw> dcoutts_: unfrotunatley, i'm not the only "saker"
14:20:44 <dcoutts_> johnw: e.g. cabal install --dry-run ./ yesod-platform
14:20:45 <johnw> yesod devel runs cabal too
14:21:23 <johnw> dcoutts: your command is rejected by cabal
14:21:53 <johnw> so, i'm just going to uninstall yesod-platform
14:21:54 <luite> johnw: hm, i wonder why it wants to downgrade unix-compat, what does it say if you do a --force=unix-compat==0.4.0.0 for your project?
14:22:09 <dcoutts_> johnw: hmm, you don't have a really old version of cabal do you? what version?
14:22:16 <johnw> dcoutts_: the very latest
14:22:29 <luite> johnw: i mean --constraint
14:22:31 <luite> not --force
14:22:33 <luite> sorry
14:22:41 <johnw> i'd love to solve this, but I have another pressing problem
14:22:54 <johnw> uninstalling yesod-platform frees up the "dependency lock" enough for me to continue
14:22:55 <dcoutts_> johnw: then it's valid syntax, I'm not sure what you mean when you say it's rejected
14:23:12 <dcoutts_> johnw: unless you mean that the solver can't find a solution
14:23:19 <dcoutts_> which is rather the point
14:23:20 <hpaste> johnw pasted “cabal failure for dcoutts” at http://hpaste.org/77358
14:23:42 <johnw> also, ghc-pkg check is broken now either for yesod-platform or for my yesod project
14:23:55 <johnw> so, in favor of my project, i'll remove the platform for now
14:24:04 <dcoutts_> johnw: ok then when you said you can't use yesod-platform and the result of yesod init, you're quite right
14:24:14 <johnw> luite: but I'd recommend "round-tripping" yesod-platform as a sanity check
14:24:27 <dcoutts_> johnw: but you can only tell that when you try to install both together
14:25:00 <dcoutts_> johnw: and it's perhaps worth double-checking by using --max-backjumps=-1
14:25:08 <johnw> dcoutts_: test: cabal install yesod-platform && yesod init && cd foo && cabal install, if it fails, then yesod-platform is broken
14:25:53 <dcoutts_> johnw: that's only true if yesod init makes your app depend on a specific version of yesod-platform
14:26:07 <dcoutts_> well, some version, not a specific version
14:26:09 <johnw> dcoutts_: but it doesn't
14:26:22 <johnw> what I'm saying is that the yesod-platform installs dependencies different from those required by a yesod init'd project
14:26:48 <dcoutts_> johnw: that's (probably) true but you can only see that if you try to install both simultaneously
14:26:53 <mSSM> byorgey: thanks
14:27:00 <dcoutts_> installing them sequentially like that tells you very little
14:27:02 <mSSM> byorgey: you were right :) I should have checked that myself
14:27:18 <johnw> dcoutts_: installing them sequentially forces me to use --force-reinstalls; that is what I believe is the bug here
14:27:32 <dcoutts_> johnw: one last try: cabal install --dry-run ./ yesod-platform --max-backjumps=-1
14:27:35 <johnw> if yesod-platform is meant to work with cabal, then a yesod init'd project should install cleanly
14:27:39 <mSSM> Other question: what do I do if I need a package (gloss, in this case), but cabal tells me that some packages are likely to be broken (among them, ghc-7.6.1)
14:27:55 <johnw> dcoutts_: sorry, i'm past this now, this has already eaten up too much time.  i have my cabal project running at last
14:28:06 <byorgey> mSSM: don't do it!
14:28:16 <mSSM> byorgey: that was my first intuition :)
14:28:19 <byorgey> mSSM: you definitely don't want to break the ghc package.
14:28:28 <byorgey> mSSM: are you installing with the --global flag?
14:28:43 <mSSM> byorgey: no, I am not using any flags
14:28:49 <byorgey> (you shouldn't be)
14:28:52 <byorgey> ok
14:29:21 <dcoutts_> johnw: that's true of course, but the the right way to do it is to make the app depend on yesod-platform. If users are installing things sequentially and using --force-reinstalls then there's something wrong
14:29:55 <byorgey> mSSM: gloss depends on GLUT, which was only recently updated to build under GHC 7.6
14:30:20 <byorgey> mSSM: and gloss has not yet been updated to note that it's OK to use the latest version of GLUT
14:30:50 <byorgey> mSSM: if you're the adventurous type you can download the gloss source, tweak the upper bound on GLUT (since it will probably work) and build your tweaked version
14:31:04 <mSSM> byorgey: oh well; I am not that adventurous
14:31:19 <mSSM> just going to read the code then without checking what it does ^^
14:31:27 <OceanSpray> how do I uninstall ghc if I installed it with the tarball?
14:31:53 <mSSM> It's a pity there are so few physics simulations implemented in haskell (even of the basic type).
14:32:39 <dcoutts_> mSSM: we've got people from Los Alamos who are doing high energy physics using parallel and distributed Haskell
14:32:45 <monochrom> hunt down ghc's files under /usr/local, erase those files
14:33:13 <mSSM> dcoutts_: I read that; even a monte carlo simulation. But the main author apparently left Los Alamos and is working for a privat company.
14:33:30 <monochrom> this is why I always do instead ./configure --prefix=/usr/local/ghc-12.18.19, so I just need to erase one directory
14:33:47 <dcoutts_> mSSM: one of the two authors did leave, the other is still there and has working code
14:34:22 <mSSM> dcoutts_: do you have a link to a git repository?
14:34:47 <dcoutts_> I'm not sure they've got release permission yet
14:35:06 <mSSM> Well, I guess I can take the university route...
14:35:15 <mSSM> I am not working in HEP, so I hope that would be fine.
14:35:32 <dcoutts_> but we'll be writing up the final results soonish, including any public code
14:35:37 <mSSM> Then again I don't want to start messing with NDAs.
14:35:54 <mSSM> dcoutts_: You are on boat?
14:35:57 <mSSM> board*
14:36:11 <efie> sorry for this newbish questions ... I would like to get the string "\a" by concatenating \ and a, how to do this? '\' does not work and '\\' : "a" gives "\\a"
14:36:35 <geekosaur> you're using show to see the result?  or ghci's implicit show?
14:36:41 <dcoutts_> mSSM: I'm running the overall project, but I'm not the main contact for the LANL chaps
14:37:03 <geekosaur> Prelude> putStrLn $ '\\' : 'a' : []
14:37:04 <geekosaur> \a
14:38:01 <mSSM> dcoutts_: do you have some "sandbox" code? e.g. implementing fancy (clustering) versions of ising models?
14:38:20 <efie> geekosaur: I have strings likes this: "a\\288aa\\288a" and to display it with putStrLn properly, I have to turn it into "a\288a\288a" first, right?
14:38:22 <monochrom> "\\a" is correct. it's the Show instance adding more \s. trust putStrLn
14:38:39 <geekosaur> efie, make sure the show instance is not what's making it look like \\
14:38:44 <dcoutts_> mSSM: I'm not sure what you mean exactly, "ising"?
14:38:55 <mSSM> dcoutts_: oh, you are not a physics guy? :D)
14:38:56 <monochrom> the Show instance tells you how to enter source code, not how the thing really looks like
14:39:02 <dcoutts_> mSSM: nope :-)
14:39:33 <mSSM> dcoutts_: sorry, it's a simple model to study (anti-)ferromagnetic systems
14:39:43 <dcoutts_> mSSM: we've got a Haskell reference impl, the legacy C++ impl adjusted to give the same results as the Haskell one, the SMP parallel Haskell version, an MPI Haskell version and a Cloud Haskell distributed version.
14:40:15 <efie> geekosaur: is there no way to turn  "a\\288aa" into  "a\288aa"?
14:40:23 <mSSM> dcoutts_: are you happy with the result?
14:40:31 <geekosaur> there is, the point is you probably do not need to unless you;re building that string incorrectlt
14:40:44 <dcoutts_> mSSM: the chap writing the code is happy
14:41:01 <geekosaur> (specifically you can use read :: String -> String)
14:41:10 <geekosaur> but make sure you need to first
14:41:28 <geekosaur> most of the ways you would use to look at a value of a string will go through show and will double backslashes
14:41:41 <monochrom> have you actually tried putStrLn "a\\288aa"?
14:41:56 <geekosaur> ^^
14:42:02 <mSSM> dcoutts_: I am currently working on my Master Thesis, which is just a modification of existing simulations. I might end up continuing this for my PhD, at which point I would think about making the code runable on distributed computers.
14:42:13 <rwbarton> > "a\288aa"
14:42:14 <lambdabot>   "a\288aa"
14:42:18 <rwbarton> oh right
14:42:34 <monochrom> lambdabot is stuck with Show, too
14:42:51 <dcoutts_> mSSM: I can put you in touch with the guy at LANL, he's fairly enthusiastic
14:43:27 <mSSM> dcoutts_: that would be awesome! I might get back to you on that offer though, when I actually have something to show for myself. :)
14:43:38 <dcoutts_> mSSM: in principle, cloud haskell should be quite a bit nicer to use than MPI (even via the Haskell MPI bindings)
14:43:50 <napping> dcoutts_: I've been annoyed lately at papers about parallelising stuff that don't have a credible single-threaded baseline, but it sounds like you're good
14:44:14 * hackagebot lrucache 1.1.1.3 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1.1.3 (CarlHowells)
14:44:17 <dcoutts_> napping: yes, the C++ is about 2x faster single-threaded, but the Haskell one scales quite nicely.
14:44:21 <efie> geekosaur: I will do this later, I would like to have a quick solution first- um, read "a\\228a" :: String does not work for me "no parse"
14:44:33 <rwbarton> efie: what are you trying to do
14:44:39 <geekosaur> you would need to wrap it in quotes
14:45:02 <rwbarton> what string do you think a\288aa represents anyways
14:45:10 <monochrom> I would like you to have a quick solution first too, but I don't understand the question
14:45:26 <rwbarton> or \a
14:45:27 <efie> rwbarton: I have strings like this: ""a\\288aa" and I want to turn it into "a\288aa"
14:46:06 <monochrom> OK, first, how you do know you have a string like "a\\288aa". did you use putStrLn to confirm.
14:46:15 <monochrom> don't trust the REPL. trust putStrLn only
14:46:19 <rwbarton> so you want to turn the string a\288aa into aĠaa
14:46:22 <rwbarton> yes?
14:47:10 <efie> a\288aa represents aäaa
14:47:13 <rwbarton> you are reading the seven characters a \ 2 8 8 a a and writing the four characters a Ġ a a
14:47:27 <efie> ups
14:47:28 <efie> you are right
14:47:33 <efie> Ġ
14:47:52 <j4hr0m> could please anyone explain the type of (==>) to me in http://pastebin.com/Jibny7Gp
14:47:55 <mauke> The paste Jibny7Gp has been copied to http://hpaste.org/77361
14:48:15 <shachaf> j4hr0m: I suspect ghci could do it.
14:48:39 <rwbarton> efie: okay, if this is really what you want to do then maybe wrap in " " and pass to read
14:48:45 <rwbarton> however, wasn't this suggested earlier?
14:48:45 <j4hr0m> shachaf: i can print the type out, but i dont understand why it is this type
14:49:03 <efie> rwbarton: I have the string a\\288a and want to turn it into a\288a, so that putStrLn prints a\288a as a Ġ a a
14:49:09 <shachaf> What type do you expect it to have?
14:49:20 <rwbarton> > let efie s = read ("\"" ++ s ++ "\"") :: String in efie "a\\288aa"
14:49:22 <lambdabot>   "a\288aa"
14:50:19 <j4hr0m> implication should be something like bool -> bool -> bool
14:50:37 <shachaf> What's bool?
14:50:58 <monochrom> t -> t1 -> t is a generalization of bool->bool->bool. you'll do fine
14:51:06 <efie> thanks :)
14:51:10 <rwbarton> is there a json library that accepts (invalid) json missing quotes around the keys of an object? [:(]
14:51:16 <j4hr0m> i don't get it
14:51:18 <monochrom> P.S. you will run into something funny with the Y combinator
14:52:05 <shachaf> rwbarton: Sure, YAML parsers!
14:52:08 <shachaf> (Sometimes.)
14:52:11 <rwbarton> mmm
14:52:15 <rwbarton> good idea
14:52:49 <shachaf> YAML claims to be a superset of JSON but in fact it's not quite.
14:52:56 <nand`> can I provide fixivity declarations for type operators?
14:53:03 <shachaf> Do you know how JSON escapes non-BMP codepoints?
14:53:22 <rwbarton> I think you mentioned it before
14:53:30 <FireFly> On that point ISTR JSON not quite being a JS subset
14:53:50 <shachaf> Oh, I didn't hear that part.
14:54:08 <FireFly> http://timelessrepo.com/json-isnt-a-javascript-subset
14:54:14 * hackagebot nano-cryptr 0.1.1.3 - A threadsafe binding to glibc's crypt_r function  http://hackage.haskell.org/package/nano-cryptr-0.1.1.3 (CarlHowells)
14:54:16 * hackagebot hoogle 4.2.14 - Haskell API Search  http://hackage.haskell.org/package/hoogle-4.2.14 (NeilMitchell)
14:54:18 <shachaf> hi FireFly
14:54:27 <hpaste> j4hr0m pasted “implication” at http://hpaste.org/77362
14:54:29 <hpaste> nand` pasted “Type-level units of measure” at http://hpaste.org/77363
14:54:38 <j4hr0m> why can the expression true be there? \ has only two arguments??
14:54:48 <FireFly> Hi shachaf
14:56:13 <nand`> one thing I can't seem to do in this model though is exponentiation, since eg. m^2 would have type Num a => a :@ (Meter^I2); but m^3 would have type ... :@ (Meter^I3); it seems to me I would need full dependent types to realize that
14:56:15 <monochrom> j4hr0m, haskell is different from untyped lambda calculus, you get surprising types or type errors if you just copy untyped lambda calculus things to haskell
14:56:44 <nand`> I guess I could encode the exponent myself somehow
14:56:52 <shachaf> FireFly: OK, fair enough.
14:56:59 <j4hr0m> monochrom: i understand nothing, what you said ^^
14:57:00 <nand`> using a GADT and phantom type or so
14:57:32 <monochrom> no, I think you understand, you just deny it
14:58:10 <shachaf> Search your feelings, j4hr0m.
14:58:36 <shachaf> You know it to be const.
14:58:43 <j4hr0m> how can this be? (==>) = (\ x y -> x y true)     i think, it should be (==>) = (\ x y -> true x y)
14:58:56 <shachaf> Why don't you try it out?
14:59:13 <j4hr0m> i get no instance of Show...
14:59:36 <shachaf> Well, I recommend listening to monochrom.
14:59:40 <shachaf> monochrom "knows what's up"
15:00:34 <j4hr0m> i will never get it
15:02:14 <hpaste> “http://blog.fogus.me/2011/08/14/perlis-languages/” pasted “perlis sierpinski” at http://hpaste.org/77364
15:03:24 <j4hr0m> this is insane
15:04:01 <johnw> is there any way to get Aeson to be more forthcoming about why the parse failed?
15:04:15 * hackagebot lens 3.2 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.2 (EdwardKmett)
15:04:15 <ivanm> johnw: put in more error messages yourself?
15:04:31 <johnw> i'm using deriveJSON, so there's nowhere to put error messages
15:04:32 <ivanm> but one of the reasons aeson is so much more efficient than parsec is that it doesn't keep as much info around as parsec does
15:04:39 <ivanm> yay :s
15:04:57 <ivanm> for some reason I can't build haddock-2.13.1, even though it built on Hackage :s
15:05:02 <ivanm> anyone else been able to build it?
15:08:40 <ivanm> nvm, I have a newer version of Cabal than what shipped with 7.6.1
15:09:07 <edwardk> @tell cale lens 3.2 is out. it includes a bunch of stuff, but if you bump lambdabot's dep, it removes the (:=>) and (:->) aliases that i think you were hiding from the old lens. (it put them in another module it doesn't export by default to reduce conflicts)
15:09:08 <lambdabot> Consider it noted.
15:09:34 <Cale> Was I hiding those?
15:09:35 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
15:09:42 <hpaste> nand` annotated “Type-level units of measure” with “Type-level units of measure (with exponentiation)” at http://hpaste.org/77363#a77365
15:09:51 <schovi> data Query a = ESvalue a => IdsQuery [a]
15:09:51 <schovi> idsQuery = IdsQuery [1,2,3,4,5]
15:09:52 <schovi> How to bring somothing like this to alive.
15:10:17 <schovi> ESValue is declared for Int and Bool, but the data syntax is wrong :S
15:10:40 <johnw> what does Aeson think {} is?
15:10:46 <ivanm> schovi: you probably don't want the ESvalue constraint in there
15:11:11 <edwardk> i think you hid (:=>) because it collided with constraints
15:11:19 <ivanm> schovi: consider say Map or Set: they don't have any constraints on the data type, just on the functions
15:11:24 <schovi> ivanm: i dont know if there, but i want to specify the 'a' in Arrays for IdsQuery to be instance of ESvalue :)
15:11:41 <ivanm> schovi: have that constraint in your functions then
15:11:50 <hpaste> magusapollo pasted “perlis sierpinski” at http://hpaste.org/77366
15:11:53 <edwardk> the main changes in 3.2 are that its more pedantic about strictness in a lot of places, and deals with infinite structures better
15:12:20 <magusapollo> So after figuring out how hpaste works
15:12:21 <danharaj> nitpicking strictness? lens must be a mature library now :)
15:12:37 <Cale> I'm not hiding anything from the lens package...
15:12:41 <edwardk> danharaj: just pay no attention to how the sausage is made ;)
15:12:45 <rwbarton> :t (:=>)
15:12:49 <lambdabot>     Not in scope: data constructor `:=>'
15:12:49 <lambdabot>     Perhaps you meant `Seq.:>' (imported from Data.Sequence)
15:12:49 <edwardk> Cale: then it should be an easier update ;)
15:12:53 <Cale> :k (:=>)
15:12:55 <lambdabot>     Ambiguous occurrence `:=>'
15:12:55 <espringe> Someone's told me in haskell you can do "compile time subtyping" but googling it I can't find anything. Is there a term for this, I should be looking up?
15:12:55 <lambdabot>     It could refer to either `Lens.:=>',
15:12:55 <lambdabot>                              imported from `Control.Lens' at State/L.hs:83:1-19
15:13:01 <Cale> oh, heh
15:13:03 <hiptobecubic> what is :k?
15:13:07 <edwardk> kind of
15:13:15 <edwardk> :k (->0
15:13:15 <hiptobecubic> ah
15:13:16 <edwardk> :k (->)
15:13:17 <lambdabot> parse error on input `0'
15:13:18 <lambdabot> * -> * -> *
15:13:18 <schovi> ivanm: I get it. But. I am in first part of program, where i declaring an "dsl" for building some queries and i hoped this will help me to restrict which types can be where.
15:13:22 <edwardk> :k Eq
15:13:24 <lambdabot> * -> Constraint
15:13:24 <edwardk> :k Monad []
15:13:26 <lambdabot> Constraint
15:13:42 <hiptobecubic> Why is [] a Constraint?
15:13:50 <edwardk> :k Monad
15:13:51 <edwardk> :k []
15:13:53 <edwardk> :k Monad []
15:13:57 <rwbarton> why do you think [] is a Constraint?
15:14:00 <lambdabot> * -> *
15:14:00 <lambdabot> (* -> *) -> Constraint
15:14:00 <lambdabot> Constraint
15:14:00 <ivanm> schovi: nope; you will still need to have the constraint in all your functions, but will limit what you can do with your data type
15:14:15 * hackagebot hlint 1.8.34 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.34 (NeilMitchell)
15:14:23 <Cale> heh, the lag is because I'm compiling the new lens
15:14:28 <monochrom> haha
15:14:39 <edwardk> Monad is a type of kind (* -> *) -> Constraint. [] is a type of kind * -> *, so Monad [] :: Constraint
15:14:40 <rwbarton> schovi: the type stored in the list is already "restricted" because it's "a", a parameter of Query
15:14:45 <Cale> :k (:=>)
15:14:48 <lambdabot> Constraint -> Constraint -> Constraint
15:14:54 <danharaj> edwardk: speaking of sausages, I noticed you have a TODO for throwing a unification algorithm into Lens.TH :P
15:14:59 <hiptobecubic> edwardk, yes i see how that part works, but ok new question then. Why is [] a (* -> *)?
15:15:11 <hiptobecubic> i mean
15:15:12 <Cale> hiptobecubic: because it takes a type, and produces a type
15:15:15 <schovi> rwbarton: ok Thanks :)
15:15:16 <magusapollo> I'm trying to parse the rosettacode Haskell entry for a Sierpinski triangle generator, and what I have currently just infinitely loops: http://hpaste.org/77366
15:15:17 <schovi> ivanm: too
15:15:19 <Cale> > [1,2,3] :: [] Integer
15:15:21 <hiptobecubic> -> Constraint
15:15:21 <edwardk> hiptobecubic: thats the [] at the type level, not the term level
15:15:24 <lambdabot>   [1,2,3]
15:15:28 <hiptobecubic> oh
15:15:29 <magusapollo> I may be interpreting it incorrectly
15:15:39 <hiptobecubic> I see
15:15:42 <edwardk> danharaj: i welcome patches ;)
15:15:49 <edwardk> danharaj: its just annoyingly painful to write
15:16:16 <edwardk> danharaj: the place where it goes is already separated out, etc.
15:16:30 <danharaj> edwardk: The TH module scares me. I just peaked in to see what pragmas it added to definitions since it seems lens inlining and speccing is important to my problem.
15:16:45 <Cale> magusapollo: You might be happier to replace those occurrences of map by list comprehensions?
15:16:54 <danharaj> magusapollo: shouldn't down terminate if you pass it 0?
15:16:59 <Cale> Or maybe just to replace the compositions by lambdas?
15:17:03 <danharaj> you don't have a base case in your recursion in any case.
15:17:06 <magusapollo> aha
15:17:07 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/TH.hs#L573 is where the unification would go
15:17:09 <hiptobecubic> Why does monad end in Constraint then?
15:17:19 <Cale> map ((space ++) . (++ space)) = map (\xs -> space ++ xs ++ space)
15:17:31 <edwardk> hiptobecubic: anything that goes on the left side of => in a type is a constraint
15:17:33 <edwardk> :t (+)
15:17:36 <lambdabot> Num a => a -> a -> a
15:17:39 <edwardk> :k Num
15:17:41 <lambdabot> * -> Constraint
15:17:54 <j4hr0m> monochrom: could you please explain, what you meant by "P.S. you will run into something funny with the Y combinator" i don't get it how one can define true / false this way..
15:17:54 <danharaj> :k Int => a
15:17:55 <Cale> magusapollo: oh, I see what you were trying to do...
15:17:56 <lambdabot>     Type of kind * used as a constraint
15:17:56 <lambdabot>     In a type in a GHCi command: Int => a
15:18:10 <edwardk> :k Num Int => a
15:18:12 <lambdabot> *
15:18:21 <danharaj> :k (Num Int =>)
15:18:23 <lambdabot> parse error on input `)'
15:18:23 <hiptobecubic> edwardk, ah ok
15:18:28 <danharaj> (Darn)
15:18:29 <nand`> oh, my last paste is incorrect, EqI incorrectly implemented
15:18:33 <edwardk> danharaj: (=>) doesn't section ;)
15:18:51 <danharaj> edwardk: maybe it ought to :P
15:19:35 <danharaj> I'm sure an embedding of Constraints into (* -> *) is useful to someone.
15:19:43 <magusapollo> danharaj: okies, actually putting a base case in terminates it. I feel smart
15:19:59 <danharaj> magusapollo: I wish I felt smart.
15:20:10 <hpaste> Cale annotated “perlis sierpinski” with “perlis sierpinski (annotation)” at http://hpaste.org/77366#a77367
15:20:16 <danharaj> Instead I make compilers explode in my face :|
15:21:10 <napping> I like the one built around iterate (\l -> zipWith (/=) (False:l) (l++[False])) [True]
15:23:55 <magusapollo> Cale: yeah, cleaned mine up to get that
15:24:15 * hackagebot pcd-loader 0.1.1.0 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.1.1.0 (AnthonyCowley)
15:24:34 <magusapollo> would one have to add an argument to the function definition to keep the currently built list?
15:24:45 <magusapollo> or just use anonymous functions?
15:29:15 * hackagebot pcd-loader 0.1.1.1 - PCD file loader.  http://hackage.haskell.org/package/pcd-loader-0.1.1.1 (AnthonyCowley)
15:42:27 <johnw> I have a yesod handler that needs to run for several seconds, but Yesod is apparently only allowing it a few hundred milliseconds before returning ResponseTimeout.  Is this something configurable, or does it indicate I'm doing something else wrong?
15:44:10 <j4hr0m> gn8
15:44:21 <Ralith> johnw: I don't know the answer, but I am curious under what circumstance you want a handler to run that long
15:44:36 <luite> johnw: looks like an exception from http-conduit?
15:44:44 <johnw> i'm grabbing a list of all the articles on reddit.com/hot, and repackaging them
15:45:09 <johnw> luite: Status: 500 Internal Server Error. /reddit/hot
15:45:24 <johnw> i put in liftIO print statements, and it dies during: json <- simpleHttp "http://www.reddit.com/hot.json"
15:45:26 <luite> yeah probably because you didn't catch that exception
15:45:29 <johnw> which works fine if I run this as a main program
15:45:33 <johnw> ah, ok, good idea
15:45:44 <luite> you can set the timeout value if you do a non-simple request
15:45:54 <johnw> luite: how do I do that?
15:45:56 <luite> the responseTimeout field in Request
15:47:04 <johnw> forgive me, this is my first day with yesod, where would I make that change?  in routes, or in my route handler?
15:47:39 <luite> johnw: it's not a yesod thing, Request from http-conduit
15:47:52 <johnw> oh, I see what you mean
15:47:59 <johnw> it works fine from command-line
15:48:19 <luite> i suspect that it might be something else
15:48:25 <luite> are you using yesod devel and OS X?
15:48:26 <johnw> going to print out the exception now
15:48:28 <johnw> luite: yes
15:48:36 <luite> ghc 7.6.x?
15:48:39 <johnw> yes
15:48:54 <luite> then you might be hitting a threadDelay bug in GHC, triggering the timeout immediately
15:49:05 <johnw> ah, that sounds like ti
15:49:09 <hpaste> int80_h pasted “inspecting spliced code” at http://hpaste.org/77369
15:50:30 <johnw> luite: any known workarounds?
15:50:58 <luite> not really, if you compile to an executable it works fine
15:51:12 <luite> ghci is affected (and yesod devel uses ghci)
15:51:14 <johnw> you mean, with "cabal install", instead of "yesod devel"?
15:51:20 <luite> yeah
15:51:28 <johnw> that's somewhat of a bummer
15:51:32 <rwbarton> int80_h, there is no "spliced code", there is a default implementation in ToJSON
15:51:34 <luite> but that will not really help you during development
15:51:44 <luite> johnw: maybe there's a way to disable the timeout altogether
15:51:57 <luite> oh btw, you'll probably see yesod devel using 100% cpu because of this
15:52:26 <rwbarton> int80_h, no spliced code for ToJSON anyways
15:53:11 <johnw> luite: if I "cabal build", instead of cabal install, where should the resulting server be?
15:53:24 <luite> ./dist/build/executablename
15:53:24 <johnw> it's not dist/build/reddit/reddit, that one is really old
15:53:43 <int80_h> rwbarton: ah okay I will read that
15:53:44 <luite> yeah unless you have a custom dist directory due to hsenv
15:53:50 <johnw> i am no longer using hsenv
15:54:07 <luite> oh you need to reconfigure if you want to build the executable
15:54:11 <johnw> ok
15:54:18 <luite> yesod devel does a non-executable configure (-flibrary-only)
15:54:21 <johnw> i did a cabal clean, then cabal configure, then cabal build
15:54:28 <luite> oh then it should work fine
15:54:46 <johnw> it works!
15:54:55 <johnw> ok, so how do I disable the thread delay?
15:55:46 <luite> set the responseTimeout field to Nothing
15:56:12 <luite> but that means you have to switch from simpleHttp to http
15:56:49 <johnw> you mean, parseUrl+withManager+http request?
15:57:34 <luite> yeah
16:03:08 <johnw> luite: that worked, thanks so much!
16:08:01 <donri> hate hate hate ghc 7.6 type operators why did they have to go and do that
16:08:14 <johnw> luite: one strange thing: I have to refresh my webpage multiple times before I see the HTML+CSS all formatted correctly
16:08:31 <johnw> during refreshes I see 4 different page states, in afgct
16:08:39 <johnw> fact, before I get to the one I know is the right one
16:11:27 <parcs`> > 0**(0 :+ 1)
16:11:29 <lambdabot>   NaN :+ NaN
16:12:31 <Jafet> "Not an imaginary number"
16:13:30 <zeiris> Hi. I'm playing with 'cabal configure --prefix=/usr/foo' builds, in an effort to reduce install size on target machines by distributing binaries. I'm finding that if package A depends on package B, building A with /usr/foo prefix seems to static link B with ~/.cabal/... prefix. Does that sound about right, or am I lost?
16:14:45 <geekosaur> if you're planning to distribute binaries you probably want to use --global
16:15:19 <dada-cetacean> is there a simpler way to write this function without using a foldr? http://hpaste.org/77372
16:18:40 <Jafet> You could use foldl
16:19:58 <dada-cetacean> Jafet: sorry, meant without an explicit fold
16:20:11 <donri> dada-cetacean: foldr (.) id
16:20:20 <donri> dada-cetacean: getEndo . foldMap Endo
16:20:24 <rwbarton> also: newlines
16:20:29 <Jafet> foldl' (uncurry replace) (zip oldstrings newstrings) y
16:20:37 <donri> dada-cetacean: foldr1 (.)
16:23:03 <donri> ah i'm not answering your actual question :)
16:23:44 <Jafet> foldl' (flip id) y $ zipWith replace oldstrings newstrings
16:26:55 <dada-cetacean> heh, I should have remembered the id function in the first place instead of doing that last/init nonsense
16:29:32 <donri> dada-cetacean: also foldr1 does that last/init nonsense for you
16:30:52 <Jafet> :t (init, last, head, tail)
16:30:54 <lambdabot> ([a] -> [a], [a1] -> a1, [a2] -> a2, [a3] -> [a3])
16:33:32 <monochrom> Toronto Haskell meeting tomorrow! around this time
16:34:07 <monochrom> (but I guess whoever wants to come already knows)
16:34:14 <Cale> :S   I need to learn to drive.
16:35:15 <monochrom> it's still a long distance from your home. I wouldn't want to inflict driving that long distance on you :)
16:35:51 <monochrom> we should instead try once at McMaster so everyone must travel!
16:35:56 <luite> I need to learn to fly ;)
16:36:38 <ivanm> so I finally upgraded GHC to 7.6.1, fixed all the broken distro packages and switched over to Strict Maps
16:36:40 <donri> hm can't existentials be used for old-style type operator variables in 7.6? data (~>) a b = forall cat. Category cat => cat a b
16:37:05 <ivanm> in my benchmarks, I find that the nf version is slightly faster, but the whnf is slightly slower :s
16:37:35 <monochrom> whnf version is slower than nonstrict version?
16:38:03 <luite> hm i didn't know there was an nf version
16:38:38 <monochrom> Strict Map means that in "Map k v" we're strict on v, is that right?
16:38:39 <byorgey> donri: no, because if you have several of those you have no guarantee that they are using the same cat
16:38:57 <luite> monochrom: yeah
16:39:17 <luite> it's not really a different Map, just the functions force v
16:39:18 <ivanm> luite: in Criterion I meant
16:39:33 <luite> ivanm: ah
16:39:46 <donri> byorgey: ah! thanks
16:40:52 <donri> why did they have to go and break type operators ಠ_ಠ *feelin' whiny tonight*
16:53:34 <monochrom> eh? split is in new haskell platform!
16:54:02 <monochrom> haha, haskell-src still uses -fglasgow-exts?!
16:55:13 <Cale> -fglasow-exts goot extension
16:56:01 <donri> haha, platform still ships haskell-src?
16:56:37 <monochrom> yeah
16:57:25 <monochrom> I mean haha
16:58:23 <HugoDaniel> hi
17:02:54 <startling> question: it's not safe to traverse an infinite structure, is it?
17:02:55 <Peaker_> any cabal-install dev at hand?
17:03:14 <startling> > traverse Just (repeat 10)
17:03:16 <lambdabot>   *Exception: stack overflow
17:03:23 <startling> yeah, ugh.
17:03:39 <shachaf> startling: That depends on what you mean by traverse.
17:03:51 <startling> shachaf: I mean the literal function 'traverse'
17:03:55 <shachaf> > runIdentity $ traverse pure (repeat 10)
17:03:56 <lambdabot>   [10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10,10...
17:04:03 <monochrom> depends on how much you traverse
17:04:21 <simpson> :t traverse
17:04:22 <monochrom> well, I guess what shachaf says is better
17:04:23 <startling> oh, so it depends on (<*>)'s definition
17:04:23 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
17:04:25 <startling> makes sense.
17:04:58 <startling> but it seems like for most Monads, it won't work.
17:05:02 <hpc> very casually, (traverse Just) has to go through the whole infinite list to determine that there's no Nothing lurking about
17:05:29 <monochrom> \∩/ new haskell platform built
17:05:30 <startling> right. and IO has that hidden state-passing thing going on to prevent effects from interleaving
17:05:45 <byorgey> but if there IS a Nothing lurking about, it can stop early!
17:05:46 <shachaf> startling: It depends.
17:06:13 <monochrom> clearly, IO must not prevent effects from interleaving, if it is to support concurrency
17:06:28 <shachaf> You might still care about the effects of the traversal.
17:06:29 <monochrom> and it supports concurrency since 2000
17:06:42 <startling> monochrom: right, but (>>=) (and (<*>) presumably) don't let effects interleave
17:06:49 <hpc> > traverse (guard . (< 3)) [1,2,3,4,5] :: Maybe [Int]
17:06:51 <lambdabot>   Couldn't match expected type `GHC.Types.Int' with actual type `()'
17:06:56 <shachaf> Sure they could.
17:06:59 <hpc> > traverse (guard . (< 3)) [1,2,3,4,5] :: Maybe [()]
17:07:02 <lambdabot>   Nothing
17:07:08 <shachaf> I think startling is thinking of unsafeInterleaveIO-style interleaving.
17:07:12 <shachaf> Which is unsafe. :-)
17:07:27 <startling> right. anyway, yeah, I think I've got my answer.
17:07:31 <monochrom> you should say more precisely: in m>>n, m and n do not interleave. unless you go getContents, etc
17:07:58 <hpc> shachaf: i love the subtle difference between unsafeInterleaveIO and full-on concurrency :D
17:08:28 <shachaf> It's not all that subtle.
17:08:36 <hpc> if you squint ;)
17:08:49 <monochrom> that is inspiring. I'm thinking concurrency based on unsafeInterleaveIO
17:09:30 <hpc> unsafeInterleaveIO guarantees that a value will be computed when it is needed
17:09:37 <hpc> concurrency doesn't, unless you use blocking
17:09:53 <hpc> there's no guarantees about how your threads are scheduled
17:10:07 <hpc> so for all you know, forkIO could be equal to unsafeInterleaveIO
17:10:30 <shachaf> I can't figure out how to interpret what you said.
17:10:30 <hpc> it would be a pretty damn useless definition, but technically valid
17:11:05 <hpc> shachaf: just try and figure out what rules are broken if forkIO = unsafeInterleaveIO
17:11:28 <monochrom> hpc, I'm combining unsafeInterleaveIO and seq
17:11:52 <startling> @hoogle (Traversable t, Applicative f) => (a -> Bool) -> (a -> f b) -> (a -> b) -> t a -> t b
17:11:53 <lambdabot> Control.Parallel.Strategies (.|) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
17:11:53 <lambdabot> Control.Parallel.Strategies (.||) :: (b -> c) -> Strategy b -> (a -> b) -> (a -> c)
17:11:53 <lambdabot> Control.Parallel.Strategies (-|) :: (a -> b) -> Strategy b -> (b -> c) -> (a -> c)
17:11:56 <startling> err
17:12:04 <startling> @hoogle (Traversable t, Applicative f) => (a -> Bool) -> (a -> f b) -> (a -> b) -> t a -> f (t b)
17:12:05 <lambdabot> No results found
17:12:20 <monochrom> and CPS
17:12:26 <hpc> heh, i like it
17:12:37 <hpc> i assume this would be fork()/join()-style concurrency?
17:12:40 <monochrom> I'll call it unsafeInterleavIO-passing style!
17:13:04 * shachaf wonders what startling is looking for.
17:13:12 <hpc> also, you get extra credit if join() = Monad.join
17:13:31 <monochrom> my invention is too sick for that
17:13:31 <shachaf> hpc: It is, when you use Control.Concurrent.Spawn!
17:13:47 <shachaf> spawn :: IO a -> IO (IO a)
17:13:53 <hpc> shachaf: yep; one of my favorite strange language kooks
17:14:08 <shachaf> Who is, kmc?
17:14:09 <hpc> and spawn is a quite nice function
17:14:36 <startling> shachaf, I'm trying to apply some (a -> IO b) on one particular element of an infinite structure.
17:14:56 <shachaf> startling: What's that (a -> b) thing?
17:15:15 <startling> shachaf, applies to every other element to keep the types correct
17:15:31 <startling> so I don't need to do (a -> IO a)
17:17:56 <mrlemao``> :
17:18:02 <startling> the problem is that, as this is an infinite structure, I don't want it to diverge.
17:18:13 <shachaf> Seems like you'd traverse with (\x -> if p x then blah x else pure (f x)) or something.
17:19:21 <startling> > traverse (\x -> if x == 1 then print 'a' else pure 'b') [1..]
17:19:24 <lambdabot>   Couldn't match expected type `()' with actual type `GHC.Types.Char'
17:19:35 <startling> oh, right
17:19:50 <startling>  > traverse (\x -> if x == 1 then print 'a' >> pure 'a' else pure 'b') [1..]
17:20:04 <startling> > traverse (\x -> if x == 1 then print 'a' >> pure 'a' else pure 'b') [1..]
17:20:06 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO [GHC.Types.Char]))
17:20:06 <lambdabot>    arising ...
17:20:28 <startling> oh well. I'm pretty sure that's unproductive?
17:20:42 <shachaf> ?
17:20:57 <shachaf> You mean it has to complete all the effects on an infinite list before giving you a result?
17:21:02 <startling> yeah.
17:21:08 <shachaf> Well, yes.
17:21:13 <shachaf> That is the nature of IO.
17:21:41 <startling> I'm wondering whether I can write a traversal that doesn't do that.
17:21:55 <shachaf> With IO?
17:22:02 <shachaf> Only using something like unsafeInterleaveIO.
17:22:11 <startling> shachaf: really? darn.
17:22:36 <Ralith> startling: why do you want that?
17:22:40 <shachaf> startling: Well, what effects would you want it to have?
17:22:50 <hpc> obviously you would spawn an infinitude of threads
17:23:11 <Ralith> startling: shouldn't you section out the stuff that you want to process and *then* perform IO on it?
17:23:52 <startling> shachaf, I want it to display the player's point of view and get some move from it, while the rest of the monsters make decisions deterministically.
17:23:54 <startling> Ralith: ^
17:24:58 <saiko-chriskun> tryin' to load the postgres-simple package.. getting this error:
17:25:00 <saiko-chriskun> no suitable image found.  Did find: /usr/lib/libpq.dylib: mach-o, but wrong architecture
17:25:05 <Ralith> startling: that .. doesn't seem to involve printing infinite lists.
17:25:23 <saiko-chriskun> libpq.dylib is x86_64...... any ideas?
17:25:32 <startling> Ralith, displaying the player's point-of-view is effectively in IO. my world is infinite
17:25:46 <Ralith> startling: but you aren't displaying the entire world, you're just displaying the parts the player can see.
17:26:08 <Ralith> startling: filter down to those, obtain finite data structure, display.
17:26:17 <startling> Ralith, sure, but I need to traverse the whole world and let everything move
17:26:37 <startling> otherwise I've got to repeatedly search for the player and re-center on the player, which is what I'm doing now.
17:26:51 <Ralith> I thought the player was effectively the origin?
17:27:21 <monochrom> hpc: http://hpaste.org/77374
17:27:28 <monochrom> and everyone :)
17:27:39 <startling> Ralith, no. right now I've got moveThings :: Direction -> World -> World, where the first argument is the player's movement and the rest of the monsters have their make-decisions function run.
17:28:11 <Ralith> startling: what is 'World'?
17:28:20 <startling> Ralith, a zipper of [Monster]
17:28:34 <startling> where data Monster = Player | SomethingElse right now.
17:28:48 <Ralith> no idea what movement means there
17:29:02 <Peaker> a zipper implies World points at a particular Monster hole and can meaningfully point at some other monster hole
17:29:21 <hpc> monochrom: it's beautiful
17:29:25 <monochrom> thanks!
17:29:30 <startling> Peaker, right, but after the player moves I need to re-center on the player somehow.
17:30:01 <Peaker> startling, why do you need a zipper there? Why not just a product of the various game states?
17:30:38 <startling> Peaker, the world is infinite.
17:30:51 <startling> so I need to leverage laziness as much as I can.
17:31:20 <Peaker> startling, hmm.. then visited parts of the world can never be GC'd?
17:32:26 <startling> Peaker: correct. I'm going to try and write a caching/serialization layer, though.
17:33:52 <startling> oh well, hard to explain, lemme try to hack on it for a bit more.
17:36:52 <gertc> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r what does r mean?
17:37:05 <startling> gertc, whatever you want
17:37:06 <copumpkin> any type
17:37:18 <Nereid> forall r. FilePath -> IOMode -> (Handle -> IO r) -> IO r
17:37:27 <startling> you give it some function that takes a Handle, it returns the result of that function.
17:37:31 <monochrom> r means whatever you wish to return
17:37:32 <Nereid> gertc: same thing as what a means in id :: a -> a
17:37:43 <monochrom> perhaps you may like an example
17:37:56 <typoclass> gertc: it can be any type, the only restriction is both of the r's need to be the same type
17:38:10 <dmwit> ?wn magis
17:38:11 <lambdabot> No match for "magis".
17:38:25 <gertc> i expected IO () or IO Handle
17:38:42 <monochrom> withFile "myfile" ReadMode (\h -> do { s <- getLine; return length s })  here r becomes Int
17:39:06 <monochrom> do not return the Handle. just don't. please.
17:39:22 <byorgey> magis is the plural of magi
17:39:23 <Nereid> haha
17:39:28 <hpc> monochrom: well if it would just encode that in the type, maybe i wouldn't!
17:39:35 <Nereid> :v
17:39:51 <startling> gertc, you use it to wrap the thing that uses a handle, opening it before and closing it afterwards.
17:40:21 <typoclass> gertc: the point of withFile is that you give it an action (function), and it opens the file, runs your action on it, and then closes it
17:40:54 <monochrom> sorry, my example is boring, here is a better one
17:40:57 <typoclass> gertc: in the type that you pasted, the part (Handle -> IO r) is this function you're giving it
17:41:02 <monochrom> withFile "myfile" ReadMode (\h -> do { s <- hGetLine h; return length s })  here r becomes Int
17:41:26 <monochrom> and it misses parentheses. return (length s)
17:41:28 <gertc> ok thx example made sens :)
17:42:04 <monochrom> I should go back to injecting mistakes into my defense prep as opposed to into #haskell!
17:46:10 <gertc> one more thing withfile does this exception stuff for me right like u' <- liftIO (try $ FB.usr  (C.pack "code", code) :: IO (Either SomeException FB.User))
17:46:36 <gertc> damn wrong line f' <- liftIO ( try $ B.readFile p :: IO (Either SomeException B.ByteString) )
17:47:59 <gertc> so for example if the fiel does not exist it wil just close it and move on?
17:51:11 <startling> gertc: I don't think it can create a handle at all if the file does not exist
17:51:52 <gertc> ok
17:53:25 <gertc> by the way why can i not replcase the liftIO ( try with liftIO $ try ?
17:55:07 <byorgey> gertc: probably because then the type annotation scopes over the whole thing including the liftIO
17:56:16 <kirindave> Allright.
17:56:22 <kirindave> I got an entire interpreter for my algorithm
17:56:36 <kirindave> And I did it with free monads.
17:56:44 <guidj0s> Free as in free beer? :-)
17:56:47 <kirindave> And yet, I still do not understand haskell. :\
17:56:54 <kirindave> guidj0s: Oh the cost is extreme. :)
17:57:03 <kirindave> Even got kan-extensions "improve"
17:57:23 <dmwit> [beer, speech] ++ [monads]
17:57:30 <kirindave> Speaking of that
17:57:38 <kirindave> It's definitely time to get home and play the election drinking game.
17:57:47 <kirindave> I just wanted to #humblebrag you know?
17:58:50 <copumpkin> yeah, I hear you (from the back seat of my rolls royce)
18:08:27 <liyang> Is there already something in lens along the lines of this?
18:08:28 <liyang> foo :: Simple Setter a c -> Simple Setter b c -> Simple Setter (a, b) c
18:08:28 <liyang> foo l r f (a, b) = (,) <$> l f a <*> r f b
18:12:08 <liyang> Europe is asleep I guess. :-/
18:12:30 * typoclass yawns in liyang's general direction
18:13:01 <thirsteh> are "Seq.index 0 s" for head and "Seq.index (Seq.length s - 1) s" really how you get the first and last items of a Sequence?
18:14:15 <ivanm> thirsteh: there's left view and right view operations
18:14:15 <liyang> thirsteh: no, you should really use Seq.viewl or Seq.viewr
18:14:38 <thirsteh> thank you, somehow I managed to miss that
18:14:46 <thirsteh> was driving myself nuts looking for "head" and co
18:15:15 <ivanm> ViewPatterns works nicely with them
18:15:19 <luite> liyang: not all of europe!
18:15:41 <liyang> (And the Americas are probably glued to the election.)
18:15:59 <simpson> (It's true, we are. We're really hoping that we don't screw over the world again.)
18:16:00 <thirsteh> ivanm: ah, cool
18:16:07 <ivanm> zipSeqs (viewl -> (a :< as)) (viewl -> (b :< bs)) = (a,as) : zipSeqs as bs
18:16:19 <cgc17> hey everyone... I'm new to Haskell (working my way through learnyouahaskell.com) and was wondering if someone could explain further why [3,2,1] > [2,10,100] evaluates true?
18:16:29 <ivanm> cgc17: 3 > 2
18:16:36 <ivanm> @src [] compare
18:16:36 <lambdabot> Source not found. That's something I cannot allow to happen.
18:16:39 <ivanm> @src [a] compare
18:16:40 <lambdabot> Source not found. Are you on drugs?
18:16:42 <ivanm> bah
18:16:46 <hpc> cgc17: same way "cba" > "banana"
18:17:12 <hpc> lists get compared by dictionary ordering
18:17:13 <ivanm> compare (a:as) (b:bs) = case compare a b of EQ -> compare as bs; c -> c
18:17:24 <ivanm> ^^ something like that for the recursive case
18:17:51 <cgc17> got it. so it's not trying to tell me that 2>10 :)
18:18:01 <ivanm> heh, no
18:19:24 <Philippa> cgc17: were you expecting it to be all the items in one list being greater? Useful operation, but not a total ordering on lists
18:19:46 <applicative> > [3,error "not a number", undefined] > [2,20000,1000000]
18:19:48 <lambdabot>   True
18:19:54 <cgc17> Philippa, yeah I guess I was. No reasoning behind that, it's just the first thing that popped in my head
18:20:10 <thirsteh> > sum [3,2,1] > sum [2,10,100]
18:20:12 <lambdabot>   False
18:26:08 <hpaste> liyang pasted “Generalised Pair Traversal” at http://hpaste.org/77375
18:28:01 <mm_freak> ivanm: as a useful side note Ordering is a monoid =)
18:28:15 <mm_freak> compare (a:as) (b:bs) = compare a b `mappend` compare as bs
18:28:26 <ivanm> oh, right
18:28:28 <sclv> > and $ zipWith (>) [3,2,1] [2,10,100]
18:28:30 <lambdabot>   False
18:28:39 <ivanm> I tend to forget about that
18:29:12 <johnw> i think you meant to name that function mcompare
18:29:39 <mm_freak> :t compare
18:29:40 <lambdabot> Ord a => a -> a -> Ordering
18:29:45 <mm_freak> no, i didn't
18:29:58 <johnw> are you using overloading then?
18:30:16 <mm_freak> i'm writing an Ord instance for (Ord a) => [a]
18:30:16 <johnw> you are calling compare with two elements, and then calling compare with two lists
18:30:42 <mm_freak> yeah, what's wrong with that?
18:31:01 <johnw> how can you overload a function name?
18:31:17 <geekosaur> :t compare
18:31:18 <lambdabot> Ord a => a -> a -> Ordering
18:31:26 <johnw> oh
18:31:26 <mm_freak> you can't, but you can define class instances
18:31:32 <johnw> got it
18:32:05 <mm_freak> (well, you can have multiple functions with the same name in scope, but it's not overloading in the sense of ad hoc polymorphism)
18:34:18 <et09> what does polymorphism mean in haskell
18:34:35 <johnw> "a thing can take on many forms"
18:34:41 <et09> well yes
18:34:44 <et09> but what thing
18:34:50 <startling> et09: a type
18:34:50 <et09> a function?
18:35:04 <et09> a type..can you give me an example?
18:35:15 <startling> et09: Integers and Floats are both Nums
18:35:20 <johnw> parametric polymorphism means a function can adapt to different inferred argument types; ad-hoc polymorphism means many types can behave as if they were aspects of the same type class
18:35:32 <et09> so a type can be "instantiated" into another type?
18:35:35 <johnw> wording is probably terrible
18:35:40 <et09> i thought num was a typeclass but i guess not
18:35:47 <johnw> where is shachaf when I'm trying to define things...
18:35:48 <startling> et09: no, Num is a typeclass
18:35:53 <et09> oh
18:36:02 <et09>  well i guessed right then - good news for me
18:36:04 <startling> et09, a typeclass can have many forms which are types
18:36:05 <applicative> @type (reverse,fst,snd)
18:36:07 <lambdabot> ([a] -> [a], (a1, b) -> a1, (a2, b1) -> b1)
18:36:15 <et09> can a type have multiple typeclasses?
18:36:15 <c_wraith> johnw: parametric polymorphism means that the code cannot depend on the type the variable is instantiated with.  ad hoc polymorphism means it can.
18:36:16 <johnw> so, foo :: a -> b, foo is parametrically polymorphic in its argument and return type
18:36:23 <startling> et09: sure
18:36:23 <applicative> ^^ all pretty polymorphic et09
18:36:50 <applicative> > (ord,chr, 'a')
18:36:52 <lambdabot>   (*Exception: showsPrec: No overloading for function
18:36:57 <johnw> c_wraith: well, it can depend on it in the monomorphic case too
18:37:00 <startling> :t \n -> show (n + 1)
18:37:02 <lambdabot> (Num a, Show a) => a -> String
18:37:08 <startling> et09: ^ see?
18:37:10 <applicative> @type (ord,chr, 'a')
18:37:12 <lambdabot> (Char -> Int, Int -> Char, Char)
18:37:23 <applicative> ^^^ highly monomorphic et09
18:37:31 <c_wraith> johnw: yes, but..  monomorphism isn't polymorphism.
18:37:33 <et09> ah i see
18:37:48 <et09> i'm used to polymorphic associations from ruby on rails
18:38:04 <et09> where a type can be associated with objects from -many- other types
18:38:11 <et09> an object of type can be*
18:39:14 <applicative> @type id
18:39:16 <lambdabot> a -> a
18:39:19 * hackagebot Win32-notify 0.2 - A binding to part of the Win32 library for file notification  http://hackage.haskell.org/package/Win32-notify-0.2 (MarkDittmer)
18:39:25 <et09> > id 3
18:39:26 <applicative> this can be associatedwith many types
18:39:27 <lambdabot>   3
18:39:30 <et09> ah ok
18:39:45 <et09> @hoogle id
18:39:46 <lambdabot> Prelude id :: a -> a
18:39:46 <lambdabot> Data.Function id :: a -> a
18:39:47 <lambdabot> Control.Category id :: Category cat => cat a a
18:39:54 <gertc> withFile p ReadMode (\h -> do { s <- hGetLine h; WS.sendBinaryData s }) this going to be allot more complicated to use withFile right?
18:39:56 <et09> where do i get the source?
18:39:59 <startling> @src id
18:40:00 <lambdabot> id x = x
18:40:07 <et09> what a complicated function
18:40:32 <startling> indeed.
18:40:42 <applicative> the idea  is pretty simple, polymorphism proper, I'm not sure I'd try to approach it with analogies.  Type classes give us partial polymorphism, so to say; its a little harder
18:40:47 <ivanm> how do I get the pretty charts and stuff from criterion?
18:41:21 <johnw> ivanm: good question
18:41:31 <startling> applicative: that's a good distinction to make
18:43:39 <Philippa> applicative: though both get much simpler if you introduce the lambdas and applications the type system hides from us!
18:44:25 <dmwit> Down with sneaky type systems!
18:44:27 <Philippa> (why yes, I did read that post of Conor's on SO)
18:44:54 <Philippa> dmwit: eh, I'm happy so long as I've got tools that'll fill the details back in without making me read everything in ANF
18:44:57 <ivanm> johnw: well, it's depending upon hastache for a reason...
18:48:29 <mm_freak> gertc: i don't understand your question
18:49:51 <applicative> Philippa: whats this post of C. McB. on SO?
18:50:01 <mm_freak> without regions withFile is usually the way to go, unless you need some form of open file handle management, in which case regions (or ResourceT) are the way to go
18:51:23 <gertc> WS.sendBinaryData $ withFile p ReadMode (\h -> do { s <- hGetLine h;return s})
18:51:54 <mm_freak> withFile p ReadMode hGetLine >>= WS.sendBinaryData
18:51:56 <applicative> that cant be right can it?
18:51:56 <gertc> the problem is tha sendBinaryData expects somethin like readFile
18:52:14 <applicative> what package is it from>
18:52:15 <applicative> ?
18:52:31 <gertc> websockets
18:52:40 <Philippa> applicative: http://stackoverflow.com/questions/12961651/why-not-be-dependently-typed/13241158#13241158
18:52:50 <johnw> luite: you still around?
18:53:04 <gertc> so this will not work  WS.sendBinaryData "helloworld"
18:53:16 <mm_freak> gertc: you can't use it that way, yes
18:53:21 <applicative> ah thanks Philippa  looks awesome
18:53:33 <luite> johnw: yeah
18:53:39 <mm_freak> but WebSockets is a MonadIO
18:53:56 <mm_freak> so you can write:  liftIO (withFile path ReadMode hGetLine) >>= WS.sendBinaryData
18:54:25 <johnw> luite: i have a form with @{RedditLoginR}, and I have "/reddit/login RedditLoginR POST" in config/routes, and I have postRedditLoginR in the same file that's creating the form, but ghc keeps telling me that RedditLoginR is not a known data constructor
18:54:31 <gertc> aha :)
18:54:33 <johnw> what piece am I missing?
18:55:26 <mm_freak> gertc: as a style note:  "do x <- c; return x" is the same as "c"
18:55:35 <applicative> man, even ulfnorell is getting in on the act with pigworker
18:55:35 <Clint> johnw: importing the handler?
18:55:35 <mm_freak> and "\x -> f x" is the same as "f"
18:55:41 <Clint> er
18:55:42 <Clint> nevermind
18:55:58 <gertc> Couldn't match type `IO' with `WS.WebSockets WS.Hybi10'
18:56:13 <johnw> Clint: I'm importing this in Application.hs
18:56:17 <gertc> o wait forgot liftIO
18:56:25 <johnw> the other handler in the same file (a get handler) works fine
18:56:50 <luite> johnw: hm, did it recompile Application.hs after you saved routes?
18:57:00 <johnw> hmm.. who knows
18:57:02 <johnw> i'll clean and rebuild
18:57:06 <mm_freak> gertc: so "\h -> do x <- hGetLine h; return x" first becomes "\h -> hGetLine h" and that one becomes just "hGetLine"
18:57:14 <luite> it should, but sometimes it seems to miss a few things :)
18:57:20 <johnw> well, i'm not using yesod devel now
18:57:24 <johnw> because it doesn't render correctly
18:57:27 <luite> oh ok
18:57:32 <luite> also check for typos :p
18:58:50 <bxx> how can I make this working? pathDirs = (getEnv "path") >>= (splitOn ";")
18:59:07 <johnw> return . (splitOn ";")?
18:59:09 <ivanm> bxx: splitOn ";" <$> getEnv "path" ?
18:59:13 <johnw> err, s/.//
18:59:19 <johnw> ivanm's is more better
18:59:24 <mm_freak> bxx: pathDirs <- fmap (splitOn ";") (getEnv "path")
18:59:40 <ivanm> I'm guessing this is on Windows
18:59:44 <johnw> mm_freak: fmap over <$>, really? :)
18:59:46 <bxx> thanks. still no idea why my code didn't work
18:59:51 <ivanm> doesn't FilePath have a variable for the separator to make it OS-agnostic?
18:59:54 <mm_freak> johnw: yeah, i usually prefer fmap
18:59:56 <johnw> pathDirs <- splitOn ";" <$> getEnv "path"
18:59:58 <ivanm> bxx: because the types are wrong?
18:59:59 <johnw> much cleaner imo
19:00:21 <ivanm> bxx: compare the type of (splitOn ";") with the type expected
19:00:30 <ivanm> > type \ f -> (getEnv "path") >>= f
19:00:33 <lambdabot>   <hint>:1:1: parse error on input `type'
19:00:36 <mm_freak> johnw: (<$>) makes code flat in the same way ($) does, and flat code is bad for maintainance
19:00:37 <ivanm> @type \ f -> (getEnv "path") >>= f
19:00:39 <lambdabot>     Not in scope: `getEnv'
19:00:39 <lambdabot>     Perhaps you meant `getAny' (imported from Data.Monoid)
19:00:43 <bxx> I see, it returns [String] and I need to return IO [String]
19:00:47 <ivanm> mm_freak: "flat" ?
19:00:47 <johnw> mm_freak: flat?
19:00:51 <ivanm> bxx: yup
19:01:10 <mm_freak> parentheses add lexical structure
19:01:29 <mm_freak> not doing so i call "flat" code
19:01:53 <johnw> well, i pretty strongly disagree with you
19:02:01 <ivanm> johnw: looks like -o is used to get the html report
19:02:03 <shachaf> hi johnw
19:02:06 <johnw> hi shachaf
19:02:08 <ivanm> (from criterion)
19:02:10 <mm_freak> and i avoid flat code in haskell for the same reason i avoid "if (p1) if (p2) if (p3) x else y else z else w" in C
19:02:13 <shachaf> What happen?
19:02:23 <johnw> shachaf: frown-worthy things
19:02:26 <ivanm> I wish there was a way to just get _images_ from criterion
19:02:32 <shachaf> :-(
19:02:49 <mm_freak> ivanm: i found that writing parenthesized code makes it easier to read months later
19:03:20 <ivanm> hmmmmm
19:03:23 <mm_freak> i only use ($) and (<$>), when the second argument is indented and multiline
19:03:33 <mm_freak> because then the indentation adds the structure
19:04:16 <mm_freak> and honestly "print (sin x)" is simply more beautiful than "print $ sin x" or, as some people would even write, "print . sin $ x"
19:05:47 <bxx_> how come same <$> is in both Data.Functor and Control.Applicative
19:05:57 <hpaste> gertc pasted “>>=” at http://hpaste.org/77378
19:06:12 <applicative> bxx_: it's in Data.Functor, it's fmap
19:06:20 <mm_freak> bxx_: you find that all over haskell…  in general you would import Control.Applicative
19:06:26 <applicative> Control.Applicative re-eports
19:06:30 <applicative> exports
19:06:44 <mm_freak> if you use fmap, you need no imports
19:09:01 <hpaste> gertc annotated “>>=” with “this works” at http://hpaste.org/77378#a77379
19:09:10 <applicative> bxx_:  I don't think Data.Functor is often imported but thats where both fmap and <$> defined; but the Prelude re-exports the first, Control.Applicative the second
19:09:29 <applicative> where they are both defined, rather
19:10:00 <bxx_> okay I see. I was just curious
19:10:10 <mm_freak> gertc: i suspect that you assume that "return ()" will stop the rest of the computation, but it won't
19:10:25 <mm_freak> gertc: "return ()" is precisely the computation that does nothing and proceeds
19:10:59 <gertc> no i dont :) WS.receiveData is holding the loop until it recieves data
19:11:17 <mm_freak> gertc: ah, ok =)
19:11:34 <gertc> can i get rit of retrun?
19:11:42 <mm_freak> not really
19:11:47 <mm_freak> but you can use 'either'
19:11:51 <gertc> or do i need to put somthing else ?
19:12:03 <mm_freak> either (const $ return ()) WS.sendBinaryData f'
19:12:08 <mm_freak> instead of the 'case' construct
19:13:26 <gertc> ok and what about using withFile?
19:13:50 <gertc> or is readFile the way to go in this case?
19:14:11 <mm_freak> well, if reading fails, then your 'try' buys you nothing
19:14:22 <mm_freak> because readFile is lazy
19:14:45 <mm_freak> you should probably use a strict ByteString version of readFile
19:15:09 <mm_freak> sendBinaryData can probably handle ByteString as well as String, if not better
19:16:23 <mm_freak> yes, it does
19:16:27 <gertc> if read fails it does not do the receiveData and trows a exception that stops the loop
19:16:55 <gertc> so i must do try on new fiels that do not exist
19:16:56 <mm_freak> correct…  reading your code i assume that if reading fails you want to do nothing (return ()) and continue the loop
19:17:30 <mm_freak> the 'try' only covers the case when /opening/ the file fails
19:17:48 <mm_freak> the actual reading occurs outside the 'try' because readFile performs lazy I/O
19:18:06 <mm_freak> so if reading fails the exception will be thrown later while executing sendBinaryData
19:18:32 <mm_freak> to solve the problem and get a large speed bonus you have to use a strict ByteString variant
19:20:03 <mm_freak> however the best way to do it (to save RAM as well) you have to use a streaming abstraction like conduit, enumerator or pipes
19:21:15 <gertc> actually it should always read incomming data the first part just send the old stuff that gets overwritten
19:22:42 <gertc> i should rename the loop write3 or something
19:26:56 <gertc> ok looking into conduit, enumerator or pipes but conclusion is that this would never work withFile right?
19:28:39 <Clint> Data.Conduit.Binary.sourceFile
19:28:48 <gertc> (withFile p ReadMode hGetLine) >>= WS.sendBinaryData only works in loop :: String -> IO
19:29:23 <gertc> not String -> monadstuff
19:34:20 * hackagebot edge 0.8.2 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.2 (ChristopherHoward)
19:48:43 <hpaste> liyang annotated “Generalised Pair Traversal” with “Generalised Pair Traversal (annotation)” at http://hpaste.org/77375#a77380
19:52:17 * copumpkin highlights edwardk 
19:52:24 <edwardk> ?
19:52:24 <lambdabot> edwardk: You have 1 new message. '/msg lambdabot @messages' to read it.
19:52:28 <edwardk> @messages
19:52:28 <lambdabot> liyang asked 1h 23m 48s ago: Does this exist in lens? http://hpaste.org/77375
19:52:52 <edwardk> @tell liyang alongside
19:52:52 <lambdabot> Consider it noted.
19:52:59 <edwardk> @type alongside
19:53:01 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Context a b) s t a b -> LensLike (Control.Lens.Internal.Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
19:53:06 <copumpkin> waahh
19:53:07 <Ghoul> Out of interest, why does Haskell even need a GC
19:53:17 <copumpkin> Ghoul: because it produces a crapton of garbage
19:53:23 <edwardk> Ghoul: laziness plays hell with object lifetimes
19:53:28 <rwbarton> how well does hoogle cope with the types in lens?
19:53:29 <Ghoul> Why can't it be statically compiled down
19:53:33 <Ghoul> :|
19:53:35 <edwardk> rwbarton: no idea
19:53:56 <copumpkin> Ghoul: nobody knows how to do that reliably :) there's talk of doing it in some places, but it's a hard research problem
19:54:06 <edwardk> Ghoul: read mads tofte's region retrospective, regions were the best hope for it, it doesn't work in practice
19:54:09 <typoclass> Ghoul: i think the choice is really either gc, or manually managing memory (lots of calls to malloc and free)
19:54:21 * hackagebot Cabal 1.16.0.3 - A framework for packaging Haskell software  http://hackage.haskell.org/package/Cabal-1.16.0.3 (JohanTibell)
19:54:24 <Ghoul> Hmm, okay, thanks! :)
19:55:57 <edwardk> i can write trivial examples that have very hard object lifetimes to evaluate in haskell. you can even derive them in strict languages, but the simplest way to think about it is that lambdas capture arbitrary portions of the environment, and they keep them alive as long as anything needs it… and you _need_ sharing between them or you devolve from call-by-need to call-by-name, which makes your code asymptotically slower
19:59:00 <johnw> anyone know how to info http-conduit about a specific C
19:59:02 <johnw> A cert?
19:59:10 <johnw> i'm trying to use mitmproxy to debug a communications problem
19:59:15 <johnw> (for an SSL connection)
19:59:26 <johnw> s/info/inform
20:01:19 <lpvb> Is it impossible for haskell to operate only on the stack efficiently (to within 1000x less efficient than GHC)?
20:01:54 <johnw> that's a very hard sentence to parse, lpvb
20:03:15 <lpvb> Ghoul thinks you can use haskell with only the stack, my question is whether that is possible
20:03:23 <lpvb> no heap allocations
20:06:19 <liyang> edwardk: aaah. Thanks! I'm still a bit confused though. Can you write "both" in terms of "alongside"?
20:06:20 <lambdabot> liyang: You have 1 new message. '/msg lambdabot @messages' to read it.
20:06:52 <edwardk> no. both is a traversal. alongside takes two lenses and builds a lens
20:07:18 <edwardk> > alongside _1 _2 +~ 1 $ ((1,2),(3,4))
20:07:20 <lambdabot>   ((2,2),(3,5))
20:07:32 <liyang> okay…
20:07:40 <edwardk> well, the +~ is cheap there
20:07:43 <edwardk> > (1,2) + 1
20:07:45 <lambdabot>   (2,3)
20:07:47 <edwardk> =)
20:10:23 <liyang> Hmm… I'm using mapped in one of the arguments to alongside. That's not going to work is it?
20:11:07 <liyang> Setters are not LensLike, if I understand correctly?
20:11:40 <edwardk> liyang: nope. alongside needs an honest to goodness lens
20:11:45 <edwardk> not just a lenslike
20:11:49 <edwardk> @type alongside
20:11:51 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Context a b) s t a b -> LensLike (Control.Lens.Internal.Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
20:12:03 <copumpkin> those type sigs are a tad unfortunate
20:12:05 <edwardk> a LensLike (Context …)  is an actual Lens. that isn't settable, etc.
20:12:23 <liyang> oh okay. :-/
20:12:23 <edwardk> yeah. i wish ghc was better at keeping the type aliases on them
20:12:50 <edwardk> lets back up and try to understand what it is you want to do
20:13:04 <liyang> So how about http://hpaste.org/77375 as a generalised version of "both"?
20:14:03 <edwardk> iirc the laws fail
20:14:10 <liyang> I want to set something in both parts of a pair.
20:14:18 <edwardk> yeah sadly what you want doesn't pass the laws
20:14:41 <liyang> Due to the Applicative sequencing?
20:14:49 <edwardk> yep
20:15:06 <edwardk> the traversal laws preclude a lot of weird stuff
20:15:29 <liyang> Doesn't "both" fall into that category too?
20:15:42 <edwardk> :t both
20:15:44 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
20:15:46 <edwardk> both is still sound
20:16:06 <edwardk> both f (a,b) = (,) <$> f a <*> f b
20:17:55 <edwardk> afk a bit (wife wants to watch election stuff)
20:18:25 <liyang> And foo l r f (a, b) = (,) <$> l f a <*> r f b is bad because of the "l f" and "r f"? (I'm trying to understand what breaks…)
20:21:07 <edwardk> lets look at foo both both -- you now no longer have enough places to put the values you got to pass the traversal laws. you get a cross product of results out of there instead of a set of result. you'd expect it to give back n + m results if it was valid but it gives n * m
20:21:42 * liyang stares intently
20:25:01 <danharaj> unsafeElectBarackObama
20:29:42 <pharaun> ++
20:30:16 * ivanm directs danharaj to -blah
20:30:56 <pharaun> :)
20:32:50 <liyang> edwardk: if foo only combined Setters, that'd be okay right?
20:33:03 <edwardk> liyang: i think so
20:33:39 <edwardk> liyang: not sure though. i'd have to run through it
20:36:11 <hpaste> liyang annotated “Generalised Pair Traversal” with “Generalised Pair Traversal (annotation) (annotation)” at http://hpaste.org/77375#a77381
20:39:32 <johnw> if I want to send a POST via http-conduit, do I just parseUrl "http://foo/page?key=value" and set the method to "POST" and it will setup the requestBody for me?  Because when I set the url to "http://foo/page" and the requestBody to "key=value" manually, it does not seem to work
20:40:33 <liyang> edwardk: I'll send you a pull request to remind you. :)
20:41:06 <edwardk> i actually think it doesn't pass the laws, i just don't remember why =P
20:41:15 <edwardk> and i'm distracted IRL
20:41:24 <edwardk> so i haven't given it its due consideration yet
20:42:20 <edwardk> i could also be over thinking this )
20:42:49 <edwardk> it would be nice if i could optimize alongside to work with everything
20:43:23 <liyang> Well, I'll send that request and meanwhile you can take your time being distracted with the fate of the world. :)
20:44:22 <edwardk> i'm starting to think it actually works
20:45:37 <Nereid> silly question, what would forall f. Monad f => (s -> f t) -> (a -> f b) be
20:45:41 <edwardk> in the same sense that you can make newtype f :& g a = (f a) :& (g a)    can be made Traverasble for f and g traversable.
20:45:57 <edwardk> Nereid: the monad doesn't really help usefully
20:46:21 <Nereid> i.e. are there any useful things that are that but not quite a Traversal
20:46:27 <edwardk> if you look at something like Traversable, that provides traverse and mapM but the mapM definition must be definable in terms of traverse
20:46:54 <edwardk> if you need the monad structure you can't get any useful approximation of the traversable laws
20:46:57 <Nereid> well sure, something that takes any Applicative must also take a Monad.
20:47:06 <Nereid> I know. you'll have something weaker than a traversal.
20:47:42 <Nereid> oh I got the variables backwards.
20:47:47 <edwardk> sure. but the thing is the split between functor and traversable means that you went from being able to update uncountably many targets to only being able to update countably many.
20:48:25 <Nereid> I don't follow.
20:49:07 <Nereid> well whatever, it was just a random thought.
20:49:11 <edwardk> the monad gives you context sensitivity in some sense, that you can pick and choose your way through the structure based on some of the other parts of the structure.
20:49:11 <johnw> Nereid: descendMOf :: Monad m => LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t
20:49:20 <johnw> is the closest I found to your signature
20:49:46 <Nereid> johnw: yeah but that doesn't tell anyone anything.
20:49:53 <Nereid> edwardk: mhm.
20:49:58 <edwardk> he issue is, there used to be a FunctorM class that some folks used before applicatives came along, but nobody can point to any useful instances of it that aren't traversable
20:50:10 <Nereid> heh
20:59:31 <edwardk> liyang: i think it'll work actually, in general even for traversals
21:01:24 <neutrino> hi guys
21:04:35 <edwardk> actually my analogy failed
21:04:43 <edwardk> i'm back to doubting you ;)
21:07:22 <rwbarton> shachaf: I ended up using language-javascript.
21:07:48 <randomclown> Is it me or is lens with records is only useful with the template-haskell thing?
21:07:53 <shachaf> rwbarton: For what?
21:08:00 <shachaf> Oh, the unquoted JSON thing.
21:08:04 <rwbarton> the invalid JSON I was parsing yeah
21:08:11 <rwbarton> it was a pain
21:09:43 <edwardk> randomclown: the TH stuff is what makes it tolerable. yes
21:10:09 <randomclown> waiting for deriving (lens)
21:10:30 <shachaf> randomclown: What would that be?
21:11:22 <typoclass> shachaf: mails source to edwardk, waits for upload to hackage
21:11:42 <edwardk> typoclass =)
21:12:12 <shachaf> edwardk: That's a faster turnaround than takes GHC to compile some code.
21:12:18 <shachaf> s/edwardk/typoclass/
21:19:23 * hackagebot cabal-install 1.16.0.2 - The command-line interface for Cabal and Hackage.  http://hackage.haskell.org/package/cabal-install-1.16.0.2 (JohanTibell)
21:22:28 <johnw> do I need to do anything in particular to be able to use #Text in a Yesod route?  I'm getting "Not in scope: type constructor or class `Text'"
21:22:51 <johnw> which is odd, because the Yesod book uses #Text...
21:23:14 <stepcut> import Data.Text
21:23:14 <stepcut> ?
21:23:32 <lpvb> does read not work with bytestrings?
21:23:37 <johnw> yeah, I had tried import Text.Shakespeare.Text
21:23:41 <lpvb> I'm trying to do read bytestring :: Int
21:23:46 <johnw> but actually import Data.Text.Lazy (Text) did work
21:23:47 <lpvb> and it says it expects a [Char]
21:23:59 <shachaf> lpvb: A bytestring isn't made of characters, so how could you read it?
21:24:35 <lpvb> well, how would I parse a bytestring?
21:24:53 <shachaf> I don't know. What does that mean?
21:25:05 <johnw> lpvb: there's readInteger
21:25:20 <shachaf> That's in .Char8
21:25:23 <johnw> @hoogle Data.ByteString.Char8.ReadInteger
21:25:24 <lambdabot> Data.ByteString.Char8 readInteger :: ByteString -> Maybe (Integer, ByteString)
21:25:24 <lambdabot> Data.ByteString.Lazy.Char8 readInteger :: ByteString -> Maybe (Integer, ByteString)
21:25:29 <shachaf> But I think lpvb should figure out what they actually mean first.
21:25:34 <johnw> true
21:35:38 <johnw> is there a good example anywhere of using cookies with http-conduit?
21:36:34 <johnw> i'm logging into Reddit, but my up-vote request isn't seeing the cookie that the login should have set...
21:42:13 <johnw> aha
21:42:24 <johnw> Network.HTTP.Conduit.Browser2, behaves like a browser in this regard
22:06:03 <augur> is there an O mona
22:06:04 <augur> d
22:06:09 <augur> not an IO monad, but just an O monad
22:06:20 <johnw> um
22:06:24 <johnw> @hoogle O
22:06:24 <lambdabot> Prelude odd :: Integral a => a -> Bool
22:06:24 <lambdabot> Prelude or :: [Bool] -> Bool
22:06:25 <lambdabot> Data.List or :: [Bool] -> Bool
22:06:25 <augur> which presumably comes with functions O a -> a
22:06:35 <johnw> you mean, output only?
22:06:38 <augur> yes
22:06:53 <johnw> O a -> a would be for input
22:06:54 <augur> one would hope thats what you get from my second message :P
22:06:58 <johnw> a -> O a would be for output
22:06:59 <augur> no surely not
22:07:06 <augur> O a -> a would be for output
22:07:10 <johnw> how?
22:07:22 <augur> because something which is an a-with-possibly-arbitrary-outputs is still just an a
22:07:34 <augur> so you can always reveal what the a-value is, regardless of its output effects
22:07:40 <augur> a -> O a is all monads
22:07:43 <augur> so thats irrelevant
22:08:15 <johnw> hmm
22:08:26 <johnw> i think i see what you're saying, but i'd have to think more
22:08:36 <augur> the lack of input means that the actual content of the output is irrelevant
22:08:49 <augur> so the a-value cant possible depend on the state of the world
22:09:05 <augur> so you should always be able to extract the a-value since only pure computations can change it
22:09:10 <johnw> then why is there O context on the input value at all?
22:09:34 <augur> because O is a monad?
22:09:39 <augur> i mean, presumably.
22:09:45 <augur> Monad O
22:09:56 <augur> but you'd want a way to drop out of the monad whenever you want
22:09:57 <johnw> if functions are of the form O a -> a, then it's a Comonad
22:10:03 <augur> uh
22:10:04 <augur> no.
22:10:18 <augur> the mere existence of m a -> a is not sufficient for a comonad
22:10:25 <augur> you need the dual of _all_ of the monad laws
22:10:29 <johnw> sure
22:10:32 <augur> i said ADDITIONALLY you have O a -> a
22:10:59 <augur> you still have return :: a -> O a, (>>=) :: O a -> (a -> O b) -> O b
22:29:24 * hackagebot ply-loader 0.1.1.0 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.1.1.0 (AnthonyCowley)
22:34:38 <o-_-o> Hello
22:34:47 <o-_-o> I have a file with numbers.
22:34:57 <o-_-o> 1 on each line.
22:35:30 <o-_-o> Rather, the file is a pgm image.
22:35:36 <o-_-o> the format is
22:36:07 <o-_-o> width height, next line max value, value as 1 number per line.
22:36:16 <o-_-o> width height
22:36:19 <o-_-o> max value
22:36:24 <o-_-o> 1st pixel
22:36:28 <o-_-o> 2nd pixel
22:36:29 <o-_-o> etc.,
22:36:40 <o-_-o> Now when I read the file, I want to traspose it
22:36:45 <o-_-o> tanspose it
22:36:53 <ivanm> there are a view pgm importers available I believe
22:36:58 <ivanm> (on hackage)
22:37:03 <ivanm> @hoogle pgm
22:37:04 <lambdabot> package pgm
22:37:04 <lambdabot> package bindings-gpgme
22:37:04 <lambdabot> package hs-pgms
22:37:08 <shachaf> Where does the Haskell part come into it?
22:37:16 <o-_-o> Yeah, so wait
22:37:19 <ivanm> shachaf: the reading the file and transposing it?
22:37:22 <o-_-o> I know that.
22:37:37 <shachaf> ivanm: I haven't seen a question yet.
22:37:43 <o-_-o> if my image is 4 4
22:37:46 <shachaf> Just a description of a file format. :-)
22:37:54 <ivanm> shachaf: and hwat he wants to do with it
22:38:15 <o-_-o> I want to read the 1 pixel value, the 5th pixel value in next and so on into a list.
22:38:27 <o-_-o> How do I do this ? Efficiently.
22:38:39 <ivanm> o-_-o: depends on the format it's read into
22:38:53 <o-_-o> ivanm, let us it is a Vector
22:38:59 <o-_-o> Data.Vector
22:39:07 <ivanm> o-_-o: or let us instead say you tell us which one you're using
22:39:18 <o-_-o> Ok, here is the code.
22:39:48 <ivanm> but, since a Vector is meant to be O(1) lookup: map (getPixelOf image) $ enumFromThen 1 5
22:40:16 <shachaf> "here is the code" sounds good.
22:40:24 <o-_-o> http://code.google.com/p/my-haskell-fft/source/browse/dft.hs
22:40:26 <shachaf> In fact, that should probably come first. :-)
22:40:34 <o-_-o> ivanm, I am doing it.
22:40:45 <o-_-o> I want to speed up the above code.
22:40:50 <ivanm> we also already have FFT implementations I believe
22:41:09 <o-_-o> ivanm, I know, I want to write one, so I can learn. -_-
22:41:16 <ivanm> o-_-o: type sigs!
22:41:30 <o-_-o> ivanm: Sorry.
22:42:01 <ivanm> and I have no idea what you're doing there, so it's difficult to tell what you want us to look at
22:42:07 <ivanm> too many functions with similar names ;-)
22:42:55 <o-_-o> DV.enumFromStepN 0 1 cols
22:43:06 <o-_-o> This is how I am doing the transpose.
22:43:17 <o-_-o> Anyway, I forgot what I wanted to ask.
22:43:21 <ivanm> o-_-o: are you representing an image as a 1-D Vector?
22:43:34 <o-_-o> ivanm: yes
22:43:45 <o-_-o> This code works.
22:44:09 <o-_-o> If you give a pgm file, it takes a fft on the file and then reconverts it back to the same image.
22:44:10 <ivanm> I would have thought you would have re-shaped it (repa?), transposed, and then put it back into a list if you had to
22:44:46 <o-_-o> ivanm, No, the point of this exercise is to learn to write fast Haskell code.
22:45:14 <ivanm> I fail to see what I said precluded that
22:45:37 <ivanm> though I would have thought a better way of learning to write fast code would be to pick a problem, write a solution, benchmark/profile, improve, repeat
22:45:54 <o-_-o> ivanm, I did that.
22:46:01 <o-_-o> This runs in ~8 secs
22:46:09 <o-_-o> it was taking a lot more.
22:46:17 <o-_-o> But I am kinda stuck.
22:46:29 <ivanm> I meant rather than picking something that already has an existing solution (namely, FFT implementation)
22:46:46 <o-_-o> Yeah...
22:47:00 <neutrino> @hoogle testCase
22:47:00 <lambdabot> Test.HUnit.Base TestCase :: Assertion -> Test
22:47:01 <lambdabot> Test.HUnit.Base testCaseCount :: Test -> Int
22:47:01 <lambdabot> Test.HUnit.Base testCasePaths :: Test -> [Path]
22:47:10 <neutrino> wtf..
22:47:35 <ivanm> neutrino: what?
22:47:40 <neutrino> can the "testCase" here be undefined? https://github.com/batterseapower/test-framework/blob/master/example/Test/Framework/Example.lhs
22:47:51 <neutrino> this is the "official test-framework example"
22:48:39 <ivanm> why would you think it's undefined?
22:48:41 <shachaf> neutrino: I don't know. Can it?
22:49:01 <shachaf> If you have a problem, you should probably mention why. For example, an error message is good, if you have one.
22:49:03 <ivanm> it might be that HUnit has had a version bump and thus the import is no longer correct
22:49:13 <ivanm> or maybe you also need test-framework-hunit installed
22:50:02 <neutrino> ivanm: but it's not found on hoogle?
22:50:04 <ivanm> neutrino: note also that lambdabot only gives three hoogle results
22:50:09 <neutrino> ohhh
22:50:18 <ivanm> neutrino: and hoogle doesn't search every package by default
22:50:19 <neutrino> that solves it
22:50:26 <ivanm> @where hoogle
22:50:27 <lambdabot> http://haskell.org/hoogle
22:50:28 <ivanm> @where hayoo
22:50:29 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
22:50:45 <ivanm> neutrino: you could also load that file into ghci, then do ":info testCase" :)
22:51:07 <neutrino> hmm guess i could
22:54:25 <neutrino> oh yeah it's in Test.Framework.Providers.HUnit
22:54:38 <neutrino> but it kind of sucks that hoogle doesn't search every package, why is that so?
22:54:45 <neutrino> it's not an unpopular package by any measure
22:54:49 <ivanm> because there are so damn many
22:55:00 <ivanm> Hayoo searches every package on hackage
22:55:03 <ivanm> the results are a mess
22:55:04 <shachaf> neutrino: You should try this sort of thing out yourself saying it doesn't work.
22:55:17 <ivanm> and it's quite often hard to find the actual function you're looking for
22:55:36 <ivanm> neutrino: I forget the syntax, but it is possible to tell hoogle to search more packages (or a specific package)
22:55:47 <neutrino> shachaf: what?
22:55:49 <ivanm> note that @hoogle is just a cut-down interface; you really should use the website
22:56:00 <neutrino> ivanm: ohh
22:56:02 <ivanm> neutrino: shachaf means something like "try stuff out rather than bitching that it doesn't work"
22:56:13 <neutrino> i tried it out and it didn't work
22:56:21 <ivanm> you tried running that code?
22:56:22 <neutrino> hence bitching
22:56:22 <kfish> neutrino, or just install your own local hoogle :) http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
22:56:29 <ivanm> hey kfish
22:56:37 <neutrino> i tried hoogle, and it "doesn't work"
22:56:43 <ivanm> neutrino: no, try the _code_
22:56:48 <kfish> huzzah ivanm
22:56:52 <neutrino> the code runs
22:56:53 <neutrino> i did that too
22:56:58 <ivanm> kfish: worked out whether you're coming to LCA yet?
22:57:09 <ivanm> neutrino: then how can you say that the function is undefined?
22:57:12 <shachaf> Lowest Common Ancestor?
22:57:15 <neutrino> i never said that
22:57:18 <neutrino> my complaint was:
22:57:24 <neutrino> 07:54 < neutrino> but it kind of sucks that hoogle doesn't search every package, why is that so?
22:57:27 <neutrino> 07:54 < neutrino> it's not an unpopular package by any measure
22:57:31 <ivanm> <neutrino> wtf..
22:57:36 <ivanm> <neutrino> can the "testCase" here be undefined? https://github.com/batterseapower/test-framework/blob/master/example/Test/Framework/Example.lhs
22:57:49 <neutrino> yeah, at that point i didn't remember i could use :info :)
22:57:52 <ivanm> that's not what you started with
22:57:53 <neutrino> thanks for the tip
22:58:03 <ivanm> shachaf: linux.conf.au
22:58:03 <kfish> ivanm, no, but probably
22:58:06 <neutrino> yeah, topics of conversation change over time :)
22:58:20 <ivanm> neutrino: you could also have expressed your question better/more politely
22:58:32 <ivanm> "why is it that the @hoogle results didn't include that function?"
22:58:33 <neutrino> i'm sorry if you felt i was impolite
22:58:39 <ivanm> or "why doesn't hoogle index all packages"
22:58:57 <ivanm> neutrino: you're saying that "it kind of sucks" is polite terminology?
22:59:03 <neutrino> yeah.
22:59:16 <kfish> ivanm, i was thinking about trolling the proglang miniconf with a talk about how everyone is actually using category theory without realizing it
22:59:25 <ivanm> kfish: heh, nice
22:59:38 <neutrino> why would you think otherwise?
22:59:40 <ivanm> Axman6 was thinking about doing a parallel haskell talk at the miniconf, but then decided to get a job
22:59:50 <kfish> ivanm, haha
23:00:05 <ivanm> neutrino: I would not consider "sucks" to be a term that's used in what is euphemistically referred to as "polite company"
23:00:18 <neutrino> we're not in a church ..
23:00:19 <ivanm> <insert obligatory "kids these days" comment>
23:00:26 <ivanm> neutrino: still doesn't make it polite
23:00:30 <neutrino> i'll make sure to flog myself later
23:00:33 <neutrino> :)
23:00:35 <ivanm> not saying that
23:00:43 <ivanm> it's not necessarily considered rude
23:00:56 <neutrino> relax :) it's ok
23:00:56 <ivanm> neutrino: but the impression you gave off was "how dare these haskell tools not do what I want"
23:01:05 <neutrino> i shall crush them
23:01:06 <ivanm> rather than "why isn't this doing what I expect?"
23:01:26 <ivanm> kfish: I believe the CFP for the miniconf is still open
23:01:30 * ivanm has inside sources >_>
23:01:34 <kfish> kewl
23:04:45 <ivanm> dammit, why can't I create a standalone image of criterion results any more... yes, the html report is nice, but it's a bit hard to embed that within a paper...
23:04:54 <startling> can I write a written :: (MonadWriter o m, Functor f) => (w -> f w) -> m a -> f (m a) ? I don't think so (I think you need runWriter/whatever) but I'd love to be proven wrong.
23:05:49 <shachaf> What's that function supposed to do?
23:05:55 <ivanm> startling: where does the w come from?
23:06:05 <startling> errr, miswrote that
23:06:09 <ivanm> no, really? :p
23:06:21 <startling> (MonadWriter w m, Functor f) => (w -> f w) -> m a -> f (m a)
23:06:35 <startling> it's supposed to traverse the written things.
23:07:59 <neutrino> ivanm: html2ps?
23:08:26 <neutrino> or even html2pdf and then use tkpdf to concatenate
23:08:33 <ivanm> neutrino: I want one specific part of the report, not the entire page
23:08:48 <neutrino> select the text in firefox and print selection
23:08:53 <neutrino> to a pdf printer
23:08:55 <ivanm> and I think it uses JS to make the pretty images, and not sure how well that would play with any html* tool
23:09:03 <ivanm> sure, I could do it the manual way
23:09:14 <ivanm> cups_pdf, etc.
23:09:15 <neutrino> i guess having generative papers is worthwhile though
23:09:29 <luite> ivanm: you use your iphone to take a picture of your browser
23:09:39 <luite> and then embed it through instagram
23:09:40 <neutrino> it always irks me when papers show outdated data
23:10:17 <ivanm> luite: then print it off, put it on a wooden table and take another photo of it?
23:11:31 <luite> ivanm: printing? what century are you from? though if it's lomography it's acceptable i guess
23:11:44 <ivanm> heh
23:13:08 <startling> I guess turning an m a into a f (m a) isn't really feasible using the monad operations (other than the trivial `pure someAction`)
23:19:33 <startling> yeah, I don't think it's possible at all. :(
23:32:08 <neutrino> hey guys! any idea why this test fails? it says "arguments exhausted after 0 tests": prop_nubbin7 xs = (length xs == 200) ==> (length (take 2 xs) == 2). replacing the 200 with 20 or 2 makes it pass with a message saying "arguments exhausted after <n> tests"
23:32:30 <shachaf> 23:31 <shachaf> neutrino: I bet the arguments got exhausted.
23:32:35 <shachaf> 23:31 <shachaf> What's the likelihood that a randomly-generated list will have length 200?
23:33:01 <neutrino> so if the predicate is not satisfied then the test is not counted as having been run?
23:33:25 <neutrino> that makes sense i guess
23:33:28 <shachaf> Do you know what "arguments exhausted" means?
23:33:37 <shachaf> When you see an error message like that, it can help to look it up. :-)
23:33:50 <shachaf> I'm just making conjectures here.
23:34:25 <startling> shachaf's right.
23:34:25 * hackagebot regex-pcre-builtin 0.94.4.1.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.1.8.31 (AudreyTang)
23:34:29 <startling> that's the whole point.
23:34:44 <shachaf> startling: ?
23:34:56 <startling> that's the whole point of that kind of proposition.
23:35:08 <neutrino> i try to program in pointless style
23:35:08 <shachaf> I know.
23:35:30 <ivanm> neutrino: programming in pointless style is rather pointless if you're doing it for the sake of it
23:35:30 <Jafet> It means you've gotten tired of explaining the same thing again
23:35:48 <neutrino> ivanm: art does not need utility.
23:36:01 <ivanm> except pointless code is quite often fuglier than pointful code
23:36:10 <neutrino> i was just joking around :)
23:36:43 <ivanm> neutrino: foo ==> bar means only run bar if foo is True; however, QC keeps track of how many inputs it generates fail said checks, and if it gets too many (the number of which is configurable) then it gives up
23:37:01 <neutrino> yeah, that's what i reasoned
23:38:10 <neutrino> i guess i got hung up on the difference of "test" vs "case"
23:38:29 <neutrino> i guess in QC a test is an input
23:38:41 <neutrino> whereas bar is the "property"
23:38:58 <shachaf> A test is a test.
23:38:59 * ivanm had to explain that to a Haskell tutor that wrote a tutorial that ==> to try and do function equality testing
23:39:01 <neutrino> or, rather, a "test" is an input that satisfies foo
23:39:05 <ivanm> (I was another tutor, but not writing material)
23:39:16 <shachaf> No.
23:39:26 <shachaf> Well, sort of.
23:39:37 <neutrino> sort of maybe?
23:40:15 <neutrino> can i somehow give QC cues as to what values to create for a specific property?
23:40:17 <ivanm> sort `on` maybe? :p
23:40:23 <neutrino> for example, only lists of 200 ints
23:40:30 <ivanm> neutrino: that's the point of the Arbitrary instance
23:40:37 <neutrino> mhm
23:40:37 <shachaf> neutrino: Yes.
23:40:41 <shachaf> Homework: Figure out how to do it.
23:40:47 <ivanm> there's a function called vector I believe that lets you create lists of specific length
23:40:55 <neutrino> neat.
23:41:42 * ivanm heads off to go burn some dead kangaroo
23:42:06 <ivanm> the RSPCA tends to complain if I do it to a live one :(
23:42:59 <neutrino> that's not polite
23:44:25 * hackagebot yesod-fay 0.1.0.0 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.0.0 (MichaelSnoyman)
23:59:26 * hackagebot twill 0.1.0.0 - Twilio API interaction  http://hackage.haskell.org/package/twill-0.1.0.0 (JosephAbrahamson)
