00:03:55 <Nereid> Cale: are you sure that Delta is what you said it should be?
00:04:11 <Nereid> as opposed to the simplex category
00:04:37 <Cale> oh, actually, yeah, I want all the monotone maps, don't I
00:05:04 <Nereid> so where are you using the monoidal category structure
00:06:16 <Nereid> although in any case it looks like what you're trying to do is just give a different definition for monoid objects in the category of endofunctors.
00:06:29 <Cale> Yeah, so really this is a 2-category with one object, the 1-cells are natural numbers, and the 2-cells n -> m are monotone maps {0,...,n-1} -> {0,...,m-1}
00:06:49 <Nereid> why 2-categorify things, instead of just say "a monoid on C is a functor Delta -> C"
00:06:54 <Nereid> er  monad on C
00:07:06 <Nereid> not that I agree that it's true
00:07:21 <Cale> Well, it wouldn't be to C
00:07:28 <Nereid> no, the 1-category Delta.
00:07:32 <Cale> It would be to [C,C] maybe
00:07:36 <Nereid> er.
00:07:42 <Nereid> alright yes.
00:08:58 <Nereid> but there's nothing special about End(C) that makes that work.
00:11:21 <Cale> The monotone maps [n+1] -> [n] get sent to the various ways of applying mu to go from T^n -> T^(n-1)
00:11:53 <Cale> and the ones [n] -> [n+1] get sent to the various ways of using eta to go the other way
00:11:58 <Nereid> yes.
00:12:08 <Nereid> but the same thing can be used to describe a monoid object in any category.
00:12:13 <Nereid> monoidal category.
00:13:29 <Cale> Well, I would hope most ways of describing monads would generalise in that way :)
00:16:44 <Cale> actually, no index shifting
00:17:27 <Cale> So when beginners ask why there's no function IO a -> a, we can ask them to go off and construct a monotone map {0} -> {}
00:18:08 <startling> Cale, there is a function IO a -> a though
00:18:35 <Nereid> startling: total? safe?
00:19:01 <startling> Nereid: well, it has "unsafe" in the name.
00:19:05 <Cale> Yeah, there's undefined
00:19:06 <Nereid> there you go.
00:19:08 <Cale> and const undefined
00:19:21 <Nereid> is there any difference between undefined and const undefined?
00:19:26 <Cale> unsafePerformIO doesn't count because it's not a function
00:19:34 <Cale> Nereid: unfortunately, there is
00:19:40 <Cale> (seq can tell them apart)
00:19:41 <Nereid> (:
00:19:41 <Nereid> :(
00:19:52 <Nereid> what is it
00:19:57 <Cale> > const undefined `seq` 0
00:19:58 <lambdabot>   0
00:20:00 <ivanm> Cale: how is unsafePerformIO not a function?
00:20:01 <Cale> >  undefined `seq` 0
00:20:02 <lambdabot>   *Exception: Prelude.undefined
00:20:04 <Nereid> oh, damn seq
00:20:20 <Nereid> > const undefined `seq` ()
00:20:23 <lambdabot>   ()
00:20:24 <startling> makes sense. const a is defined for any a.
00:20:37 <Nereid> > (undefined :: a -> b -> a) `seq` ()
00:20:39 <lambdabot>   *Exception: Prelude.undefined
00:20:43 <Cale> ivanm: A function A -> B associates to each element of A exactly one element of B.
00:21:08 <ivanm> oh, right, mathematical rather than Haskell definition
00:21:26 <Nereid> Cale: and when are two functions equal?
00:21:27 <startling> Cale, how does unsafePerformIO not follow that?
00:21:34 <Nereid> that too
00:21:37 <Cale> startling: because unsafePerformIO getLine
00:21:44 <startling> Cale: ahhh
00:21:47 <Nereid> that too
00:21:51 <lispy> if f is a function, then a = b => f a = f b.
00:22:04 <lispy> Can do you do that with unsafePerformIO?
00:22:08 <Nereid> unsafePerformIO getLine isn't exactly a function :V
00:22:22 <Cale> unsafePerformIO getLine is a "String"
00:22:26 <Nereid> never mind.
00:22:27 <startling> Nereid, it associates getLine with many possible values
00:22:34 <Nereid> I said never mind.
00:22:35 <Cale> but it's not really a proper string
00:23:10 <startling> lispy, unsafePerformIO getLine /= unsafePerformIO getline (most of the time)
00:23:39 <Cale> unless the compiler comes along and does CSE :)
00:23:48 <startling> shhhh
00:24:20 <Cale> (which it usually won't)
00:24:53 <Cale> I wonder if you can get it to collapse multiple unsafePerformIOs by creating one of the few situations where GHC will actually do CSE
00:25:10 <lispy> assuming, data F = F !Float !Float, foo (F x y) = ..., putting a bang on x or y is redundant and, hence, not useful right?
00:25:17 <Cale> > case unsafePerformIO getLine of [] -> case unsafePerformIO getLine of [] -> 0
00:25:18 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `unsafePerformIO'
00:25:35 <Nereid> huh
00:25:41 <Nereid> nice message.
00:26:41 <Nereid> lispy: I believe so.
00:26:43 <Cale> nope, it doesn't seem to eliminate that
00:27:07 <Nereid> ah I think I understand those ! things now.
00:27:16 <Nereid> all those mean is that forcing F x y forces x and y, right
00:27:24 <Cale> right
00:27:31 <Nereid> right.
00:27:56 <Cale> Actually, maybe it's a little more subtle
00:28:03 <Nereid> maybe.
00:28:12 <Cale> They're defined by a translation of applications of the constructor
00:28:30 <Nereid> that's what I had thought earlier.
00:28:42 <Cale> that data declaration will mean that  F x y  gets translated to  seq x (seq y (F x y))
00:28:51 <Nereid> mhm.
00:29:00 <Nereid> so what about the partially applied F x
00:29:00 <Cale> which will have a similar effect to what you said
00:29:11 <shachaf> Not seq y (seq x (F x)) y?
00:29:17 <shachaf> Er.
00:29:37 <Nereid> I guess F x is always \y -> F x y
00:29:47 <Cale> maybe I should look in the Report :)
00:30:02 * shachaf assumes Cale's version is the reasonable one.
00:30:07 <Cale> A declaration of the form
00:30:10 <Cale> data cx => T u1 ... uk = ... | K s1 ... sn | ...
00:30:17 <Cale> where each si is either of the form ! ti or ti, replaces every occurrence of K in an expression by
00:30:21 <Cale> (\ x1 ... xn -> ( ((K op1 x1) op2 x2) ... ) opn xn)
00:30:25 <Cale> where opi is the non-strict apply function $ if si is of the form ti, and opi is the strict apply function $! (see Section 6.2) if si is of the form ! ti. Pattern matching on K is not affected by strictness flags.
00:30:50 <Cale> heh
00:30:55 <Cale> so that's even more fun
00:31:01 <Nereid> alright.
00:31:23 <Nereid> hmm, this could be handy: "The pattern F {} matches any value built with constructor F, whether or not F was declared with record syntax."
00:31:24 <Cale> You can get weird things happening I guess if you alternate ! and non-! fields
00:31:30 <Cale> yes, it is
00:31:36 <shachaf> data Foo = Foo !Int !Int
00:31:39 <shachaf> Œª> (Foo 5) `seq` ()
00:31:39 <shachaf> ()
00:31:48 <shachaf> I guess not.
00:32:00 <Cale> shachaf: right, because it's still a lambda :)
00:32:03 <Nereid> well yes, Foo 5 = \y -> Foo 5 y
00:32:15 <Nereid> but why didn't you try Foo undefined?
00:32:22 <Cale> \y -> (Foo $! 5) $! y
00:32:26 <shachaf> Cale: No one responded to the actual strictness bug I found in GHC. :-(
00:32:33 <Cale> shachaf: What's that?
00:32:51 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7364
00:32:59 <Cale> See, they have to explicitly left associate the application because $ and $! have the wrong associativity ;)
00:33:08 <Nereid> heh.
00:33:12 <Nereid> Cale: heh.
00:33:20 <shachaf> I don't trust GHC's opinions on strictness and eta-expansion anymore.
00:34:18 <Cale> shachaf: interesting
00:34:25 <Cale> is the id . f  important?
00:34:45 <shachaf> Cale: Well, it works with foo !f = \x -> f x too.
00:34:58 <Nereid> works as in triggers the bug?
00:35:05 <shachaf> Er, yes.
00:35:12 <Nereid> fun.
00:35:13 <shachaf> But the place where this is actually relevant has code of the form (id . x)
00:35:16 <shachaf> Well, runIdentity . x
00:35:25 <Nereid> what about f . id?
00:35:30 <shachaf> The issue is that (runIdentity . Identity . f) /= f
00:35:38 <shachaf> Nereid: I'm pretty sure that also triggers the bug.
00:36:51 <Cale> shachaf: The bug occurs in 7.4.1 as well
00:36:54 <shachaf> Cale: See https://github.com/ekmett/lens/issues/75 for more context.
00:37:03 <shachaf> Yep, I tried 7.{4,6}.1
00:37:25 <ion> ‚àÄx. 7.x.1
00:37:43 <shachaf> ‚àÄ x.7.x.1
00:38:05 <startling> shachaf: do you and edwardk just communicate via irc logs?
00:38:18 <shachaf> startling: Pretty much.
00:38:30 <shachaf> startling: When I want to send him an email, I write it in the form of IRC logs.
00:38:31 * edwardk looks at the log.
00:38:38 <edwardk> yes.
00:39:07 <Cale> shachaf: Do you write edwardk's responses in your email?
00:39:18 <edwardk> startling: proof: https://github.com/ekmett/lens/issues/75
00:39:21 <startling> Cale, they write each other's responses
00:39:33 <startling> edwardk, that's what prompted the question. :)
00:39:38 <edwardk> =)
00:39:44 <shachaf> Cale: I make up a character. <shachaf> ... <socrates> ... <shachaf> ...
00:40:15 * ion is a character made up by shachaf.
00:40:17 <edwardk> i was on vacation and he kept yammering at me. so i just kept pasting the logs into the issue report ;)
00:40:18 <Cale> I make up a character. ÔøΩ
00:40:33 <shachaf> Oh, you were on vacation?
00:40:36 <startling> Cale: haha
00:41:05 <edwardk> shachaf: yeah i think was down in florida when that started
00:41:20 <fenton> if i want to reset all haskell everything on my system do i do the following: https://gist.github.com/4010749
00:41:36 <Nereid> rm -rf /*
00:41:42 <lispy> Cale: I was just reading. So having strict fields doesn't mean GHC will infer that when you pattern match the fields are strict?
00:41:47 <fenton> Nereid: ha ha
00:41:53 <lispy> Cale: so I may need to have bangs when I define foo?
00:41:55 * ion ewws at deleting anything under /usr manually.
00:42:03 <Cale> lispy: Well, unlikely
00:42:10 <shachaf> lispy: ?
00:42:18 <shachaf> lispy: When you define foo?
00:42:27 <lispy> assuming, data F = F !Float !Float, foo (F x y) = ..., putting a bang on x or y is redundant and, hence, not useful right?
00:42:32 <Nereid> ion: why just deleting?
00:42:36 <fenton> basically do i delete my ~/.cabal directory and my ghc package directories to reset haskell?
00:42:37 <lispy> shachaf: that was my original Q
00:42:44 <shachaf> lispy: That shouldn't do anything.
00:42:45 <Cale> lispy: Because the place where you used the constructor in the first place will have been replaced with that function which strictifies (some of) its arguments
00:42:49 <ion> nereid: That‚Äôs what he is doing in the paste.
00:42:56 <Nereid> sure.
00:42:57 <shachaf> Because x and y are already evaluated by the time you can get hold of an F.
00:43:06 <Nereid> ion: but nothing should *write* to that either.
00:43:09 <Nereid> besides the package manager.
00:43:13 <Cale> lispy: and so it should be impossible to make a value of the given type without forcing that evaluation
00:43:16 <ion> sure
00:43:25 <lispy> Cale: I'm more interesting in ensuring that the strictness analyzer thinks x and y are strict and then unboxes fires.
00:43:35 <lispy> interested*
00:43:43 <shachaf> lispy: The Report just talks about the semantics here.
00:43:56 <shachaf> lispy: As long as GHC respects the strictness semantics it can whatever it wants.
00:44:01 * lispy wants unboxing
00:44:05 <shachaf> (Sometimes it does whatever it wants without respecting semantics!)
00:44:10 <Nereid> shachaf: although evidently yeah :p
00:44:16 <shachaf> lispy: If you want F to be unboxed, then use {-# UNPACK #-}. :-)
00:44:38 <lispy> shachaf: I did
00:44:46 <lispy> shachaf: so maybe I'm worried about nothing
00:44:57 <shachaf> lispy: If you're worried about something, write correct code, look at the Core, rewrite.
00:45:06 <shachaf> As always. :-)
00:45:09 <lispy> ghc-core doesn't build on windows
00:45:14 <lispy> That's my excuse for not checking the core
00:45:19 <shachaf> ghc -ddump-simpl
00:45:40 <lispy> maybe tomorrow. It's late :)
00:45:45 <shachaf> @let hi = succ; nat = 7
00:45:47 <lambdabot>  Defined.
00:45:48 <shachaf> > hi nat
00:45:50 <lambdabot>   8
00:46:19 <lispy> > do no evil
00:46:20 <lambdabot>   Not in scope: `no'
00:46:21 <lambdabot>  Perhaps you meant one of these:
00:46:21 <lambdabot>    `not' (imported from...
00:46:39 <lispy> > let no = id
00:46:40 <lambdabot>   not an expression: `let no = id'
00:46:47 <lispy> > let evil = "evil"
00:46:49 <lambdabot>   not an expression: `let evil = "evil"'
00:46:52 <lispy> @let no = id
00:46:54 <lambdabot>  Defined.
00:46:55 <lispy> @let evil = "evil"
00:46:57 <lambdabot>  Defined.
00:46:57 <lispy> > do no evil
00:47:00 <lambdabot>   "evil"
00:47:05 <lolcathost> @src no
00:47:05 <lambdabot> Source not found. You untyped fool!
00:47:19 <Nereid> please let @src see @let bindings.
00:47:33 <lispy> that's a good idea
00:47:34 <c_wraith> that'd be a lot of work
00:47:38 <shachaf> Nereid: I'm glad you're volunteering!
00:47:43 * lispy goes to bed
00:47:45 <Nereid> lol
00:54:14 <baguasquirrel> lispy: that made my night. i will go sleep happy now :)
00:59:37 <Mgccl> Does google or Facebook have any project using Haskell?
01:00:21 <shachaf> Yes.
01:03:05 <Mgccl> shachaf: examples?
01:03:13 <Iceland_jack> Not in any real sense afaik
01:03:19 <shachaf> @google facebook haskell
01:03:21 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_industry
01:03:22 <lambdabot> Title: Haskell in industry - HaskellWiki
01:03:29 <shachaf> Look at that! :-)
01:04:46 <Mgccl> Cool thanks!
01:05:12 <ion> @google intercal in industry
01:05:12 <shachaf> Someone should make a web app version of @google
01:05:13 <lambdabot> http://www.intercall.com/about-us/press-releases_110301.php
01:05:14 <lambdabot> Title: InterCall Press Release | Conferencing Product Launches
01:26:05 * hackagebot http-reverse-proxy 0.1.0.5 - Reverse proxy HTTP requests, either over raw sockets or with WAI  http://hackage.haskell.org/package/http-reverse-proxy-0.1.0.5 (MichaelSnoyman)
01:26:54 <Iceland_jack> I may be doing something wrong, why does: elemIndex 0 [fst $ randomR (0, 1) (mkStdGen i) | i <- [1..]] return (Just 53667)?
01:27:28 <Iceland_jack> I.e. randomR (0, 1) (mkStdGen i) only returns 1's for the first 53666 generators
01:27:45 <shachaf> Because mkStdGen is bad.
01:27:54 <shachaf> (If I remember correctly.)
01:28:00 <Iceland_jack> Oh
01:28:17 <c_wraith> you remember correctly
01:28:21 <c_wraith> mkStdGen is terrible
01:28:24 <Iceland_jack> So I'm not using it incorrectly?
01:28:31 <c_wraith> well, you might be.
01:28:35 <Iceland_jack> ;)
01:28:39 <shachaf> Looks OK to me.
01:28:48 <shachaf> But you probably shouldn't be using it at all. :-)
01:28:54 <Iceland_jack> I wasn't expecting to pass any cryptographic randomness tests but come on...
01:29:13 <c_wraith> well, the thing is, you're not looking at the output of a single prng sequence
01:29:21 <shachaf> http://forums.ninja250.org/uploads/265965.jpg
01:29:23 <Iceland_jack> No that's right
01:29:24 <c_wraith> you're looking at the first value of a bunch of independent prngs
01:29:39 <c_wraith> it so happens that the initialization mechanism isn't very good
01:29:45 <Iceland_jack> Fair enough
01:29:56 <c_wraith> but the sequences will diverge pretty rapidly after you pull a few values out of each
01:30:25 <Iceland_jack> Yeah I imagine so, thank you for your help :)
01:30:46 <Iceland_jack> just needed a quick sanity check
01:49:04 <lightquake> mutation is hard
01:49:14 <shachaf> ¬µtation
01:49:26 <Ralith> so what does that make œÉtation
01:49:45 <shachaf> segmentation?
01:51:33 <lightquake> the problem that i'm running into is that i have a bunch of entities whose AI can cause changes in their own state, but can also mutate the world as a whole (such as when they attack)
01:51:59 <lightquake> which can mean that i'm mutating the list of entities as i'm iterating over it
01:53:17 <Cale> lightquake: The way to maintain sanity there is to stage things per frame
01:53:25 <lightquake> what do you mean?
01:53:34 <Ralith> everything reads from previous state, writes to next state
01:53:40 <Cale> right
01:53:51 <raek> one interesting approach is to let the function that wants to update the world instead return a piece of data that describes the update (instead of actually performing it)
01:53:54 <Cale> (or current/next)
01:54:06 <lightquake> raek: right, that's what i have
01:54:19 <lightquake> i have data EntityAction = MoveTo Position | Attack [Attack] | ...
01:54:51 <Ralith> so take current state, extract a list of actions, apply list of actions to generate next state, loop
01:54:56 <lightquake> right
01:55:16 <lightquake> the problem is: what if Entity A destroys Entity B?
01:55:47 <lightquake> this is a turn-based game so if that happens, the player will wind up noticing
01:55:56 <c_wraith> that's a general policy question.  games have, historically, chosen all kinds of answers to that.
01:55:57 <Cale> lightquake: oh, it's turn based?
01:56:04 <c_wraith> sometimes, all the actions take place anyway
01:56:08 <lightquake> Cale: yeah
01:56:18 <c_wraith> sometimes, actions are enforced in an apparently-random order
01:56:28 <c_wraith> sometimes there's a strictly-enforced order
01:56:55 <lightquake> i'm fine with there being no defined order in which entities act
01:57:18 <Ralith> everything acting simultaneous seems fairest
01:57:29 <Ralith> otherwise you get people winning/losing due to unpredictable engine internals
01:57:49 <lightquake> well, my idea for that was that the player always acts before any monster
01:57:49 <bd_> Ralith: but that requires that the rules allow any combination of actions to take place in a round
01:57:55 <Ralith> bd_: yes.
01:58:05 <lightquake> oh, i should mention, this is a roguelike
01:58:08 <bd_> which of course is possible, depending on how you define the rules
01:58:27 <bd_> that said, it does allow for interesting things like having two monsters kill each other in the same turn
01:58:54 <Ralith> which is quite reasonable, really
01:59:03 <Saizan> or an entity killing itself :)
01:59:15 <lightquake> i'll just have to figure out how to represent that in the combat logs
01:59:25 <Ralith> what's wrong with the obvious approach?
01:59:38 <lightquake> "A shoots B! B blows up! B shoots A! A blows up!"
01:59:54 <Ralith> ah.
01:59:56 <Ralith> easy solution:
01:00:03 <Ralith> sort death messages to end-of-round.
01:00:19 <bd_> "A attacks B! B does a cross-counter! It's a double KO!"
01:00:19 <lightquake> looks kind of weird, though
01:00:21 <Ralith> bonus: this lets players easily skim to see what, if anything, died
01:00:29 <Ralith> does it?
01:00:39 <lightquake> Ralith: yeah, it makes it harder to see *why* something died
01:00:47 <Ralith> nah
01:00:54 <lightquake> bd_: that's true, i could special-case it
01:00:55 <Ralith> color code them, or start with the name
01:01:13 <Ralith> unless you have thousands of things happening it should be fine
01:01:28 <Ralith> and if you have thousands of things happening you're kind of without hope as far as easily readable logs of that nature go anyway :P
01:01:33 <bd_> lightquake: What roguelike is complete without all kinds of complicated special-casing? :)
01:01:38 <lightquake> hahaha
01:02:47 <pixyn> @pl let f x = 5 + 8 / x in f
01:02:48 <lambdabot> (5 +) . (8 /)
01:03:12 <pixyn> @pl let f x = ((nub x) == x) in f
01:03:12 <lambdabot> (==) =<< nub
01:03:21 <pixyn> @type =<<
01:03:23 <lambdabot> parse error on input `=<<'
01:03:32 <pixyn> @type (=<<)
01:03:34 <lambdabot> Monad m => (a -> m b) -> m a -> m b
01:04:34 <Ralith> if only lambdabot was not on life support, someone could add a feature whereby it could remind people that it accepts PMs.
01:05:26 <lambdabot> pssst, i accept pms
01:06:06 <spacekitteh> aw man, i usually idle with another channel open (my city's channel)
01:06:19 <spacekitteh> i thought that suddenly, the people i live with have gained some intelligence
01:06:42 <Iceland_jack> oh Sophie..
01:06:49 <spacekitteh> shut up baldur
01:06:57 <Iceland_jack> ts
01:07:35 <lightquake> the other problem is how i deal with mutation of the individual entities
01:08:41 <lightquake> i'm storing them in an IntMap, so i could just index into the new world's map and mutate on that, but that seems hacky
01:10:00 <shachaf> Mmm, mutato.
01:11:25 <lightquake> hm, maybe if i pick apart the lens library i can figure something out
01:11:51 <lightquake> based on the idea of 'transferring' the lens from the old world to the new one
01:18:55 <lightquake> alternately, i could separate 'self-mutating' and 'global-mutating' actions
01:19:38 <lightquake> ‚Ä¶ the problem with that is global-mutating actions can sometimes mutate the self, like if they cost some resource to use
01:26:12 <lightquake> i think i'm going to let 'dead' enemies act and do something like 'A shoots B! With its last ounce of energy, B shoots A! B dies! A dies!'
01:27:00 <shachaf> You should do a paintball-roguelike!
01:27:09 <shachaf> "A shoots B! B shoots A! B dyes! A dyes!"
01:27:17 <lightquake> haha
01:27:28 <bd_> lightquake:  so what happens if A kill B, B kill C, C kills D, and then D kills A, all in one turn?
01:28:07 <lightquake> A shoots B! With its last ounce of energy, B shoots C! With its last ounce of energy, C shoots D! With its last ounce of energy, D shoots A! D dies! C dies! B dies! A dies!
01:28:32 <lightquake> but i think disentangling the log messages like that is going to be something i put off
01:28:51 <lightquake> for now i'm going to just live with 'A shoots B! B shoots A! A dies! B dies!'
01:28:52 <shachaf> Why have ounces of energy, rather than going through all the players, figuring out their actions, and then applying the actions "at once"?
01:29:06 <lightquake> shachaf: what do you mean?
01:29:18 <shachaf> I'm not sure. :-)
01:29:18 <lightquake> the 'ounce of energy' thing is just flavor
01:29:23 <lightquake> i could take it or leave it
01:29:29 <Ralith> looks nice to me
01:29:41 <Ralith> though it implies that simultaneous actions are serial
01:29:50 <lightquake> i mean, they *are* in the underlying engine
01:29:56 <shachaf> Right, why?
01:30:51 <lightquake> because right now the way i'm thinking of doing a round of actions is that each entity comes up with a list of actions (MoveTo (8, 9), Attack (Melee 20))
01:31:12 <lightquake> and then the engine goes through and processes each action
01:31:22 <shachaf> OK, so that doesn't seem serial to me.
01:31:30 <Cale> An ounce is quite a lot of energy. 2.5 petajoules.
01:31:57 <lightquake> shachaf: what would you consider serial?
01:32:12 <shachaf> If B could use the information that it's being shot by A to decide on what to do, I guess.
01:32:17 <lightquake> ah
01:32:28 <shachaf> Which your description seems to imply.
01:32:34 <lightquake> yeah, i see your point
01:32:34 <shachaf> Cale: Why is Œµ afraid of Œ∂?
01:32:43 <delboy`> Hi, I've a question on the difference between type inference used in a 'normal' function definition and one used when using a lambda
01:32:51 <delboy`> e.g. add x y = x + y
01:32:54 <delboy`> :t add
01:32:55 <lambdabot>     Not in scope: `add'
01:32:56 <lambdabot>     Perhaps you meant one of these:
01:32:56 <lambdabot>       `odd' (imported from Prelude), `and' (imported from Data.List),
01:33:05 <delboy`> add :: Num a => a -> a -> a
01:33:10 <delboy`> whereas
01:33:17 <delboy`> add' = \x y -> x + y
01:33:19 <Cale> Because Œ∂Œ∑Œ∏?
01:33:24 <shachaf> delboy`: Look up "monomorphism restriction".
01:33:26 <shachaf> @where dmr
01:33:27 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
01:33:30 <delboy`> :t add'
01:33:31 <delboy`> add' :: Integer -> Integer -> Integer
01:33:32 <lambdabot> Not in scope: add'
01:33:36 <shachaf> delboy`: that article will answer your questions.
01:33:38 <raek> shachaf: Cale: hahaha!
01:33:39 <delboy`> Thanks
01:33:45 <danr> shachaf: Cale: ^^
01:34:50 <lightquake> shachaf: well, if B can use the fact that it was shot by A, then that solves the issue since it can go 'well I'm dead, so just don't do anything'
01:35:10 <mikeplus64> is there a generalization of catMaybes?
01:35:11 <shachaf> lightquake: Yes, but that's not too realistic.
01:35:19 <delboy`> exit
01:35:21 <delboy`> :q
01:35:37 <lightquake> mikeplus64: generalized how?
01:36:03 <mikeplus64> lightquake: not necessarily Maybe, and/or not necessarily [a]
01:36:29 <lightquake> like‚Ä¶ you could think about it as the fact that you can write f :: Maybe a -> [a], and then catMaybes is just join . map f
01:38:53 <kc8qvp_> can you make a function that takes an n-tuple?
01:39:11 <lightquake> kc8qvp_: for varying n? no
01:39:22 <lightquake> @type map toList . join
01:39:23 <lambdabot>     Not in scope: `toList'
01:39:23 <lambdabot>     Perhaps you meant one of these:
01:39:23 <lambdabot>       `Data.Foldable.toList' (imported from Data.Foldable),
01:39:30 <lightquake> @type map Data.Foldable.toList . join
01:39:31 <mikeplus64> kc8qvp_: without TH, class Foo a where foo :: a -> b; instance Foo (a,b) where foo ... etc
01:39:31 <lambdabot> Data.Foldable.Foldable t => [[t a]] -> [[a]]
01:39:37 <lightquake> oh, that's backwards
01:39:41 <lightquake> @type join . map Data.Foldable.toList
01:39:42 <lambdabot> Data.Foldable.Foldable t => [t a] -> [a]
01:39:54 <mikeplus64> lightquake: aha i was looking at foldable just now, but you beat me
01:40:33 <lightquake> i wonder if ghc is smart enough to recognize that toList is id on lists
01:40:36 <nicoo> lightquake: Curse mathematicians for having written function composition in the bad order ;)
01:41:16 <srhb> lightquake: Wouldn't you expect it to be [[]]?
01:41:26 <lightquake> srhb: ?
01:41:32 <srhb> I guess not. :P
01:41:51 <mikeplus64> lightquake: doubt it, unless there's a rule for it
01:42:04 <Cale> #ifdef __GLASGOW_HASKELL__
01:42:04 <Cale> toList t = build (\ c n -> foldr c n t)
01:42:04 <Cale> #else
01:42:04 <Cale> toList = foldr (:) []
01:42:04 <Cale> #endif
01:42:23 <lightquake> right, so the question is: does it recognise that foldr (:) [] is id on lists
01:42:38 <Cale> foldr and build will fuse
01:43:01 <shachaf> What happened to the Stream Fusion thing?
01:43:30 <Cale> hmm
01:43:45 <Cale> Well, the normal way for foldr and build to fuse is the other way
01:52:18 <Cale> lightquake: It generates identical code
01:52:31 <lightquake> with the toList and without? cool
01:52:34 <Cale> yeah
01:54:30 <lightquake> anyway, hm, i guess i could keep the status of the 'new world' in a StateT and iterate over the old world, settings parts of the new world as i go
01:54:49 <Cale> (or at least, the core is identical up to alpha conversion)
01:57:19 <lightquake> but that seems‚Ä¶ poor. i wish i could do a lens-y iteration over the old world and get the lens that drills down to that specific element so i could use that lens to mutate the new world
02:00:39 <lightquake> i can do an indexed traversal and then use that index to get a lens into the new state using element
02:19:03 <hpaste> roSievers pasted ‚Äútypeclass troubles‚Äù at http://hpaste.org/77239
02:19:10 <roSievers> Hi, I'm trying to define a ‚Äúderivable‚Äù typeclass, but have troubles adding a function (a -> a) to the class. (haven't done much with typeclasses)
02:19:39 <ivanm> roSievers: you can't define new type classes for the "deriving" mechanism
02:19:50 <shachaf> roSievers: Well, you could try using -XFlexibleInstances, like it suggests.
02:20:01 <shachaf> But I'm not sure what you're trying to do is what you want...
02:20:08 <ivanm> oh, that's not what you meant
02:20:16 <roSievers> I want to differentiate a function
02:20:22 <roSievers> any function
02:20:41 <ivanm> roSievers: I would just have a derivate function that takes in any such function
02:20:47 <ivanm> I don't see why it needs to be a type class
02:21:20 <roSievers> I have some code that implements one derivate funcion for any such function and another one that takes any Vector function t -> Vector t
02:21:47 <Cale> roSievers: also, wouldn't it be Differentiable and derivative?
02:22:08 <roSievers> some friend read this code (hasn't used haskell) asked me about it, I'd like too see if I can get it in a typeclasss
02:22:23 <ivanm> roSievers: can you show us your two functions?
02:22:27 <roSievers> Cale, thanks I'll rename them
02:23:42 <hpaste> roSievers pasted ‚Äúmy two derivative functions‚Äù at http://hpaste.org/77240
02:24:41 <thirsteh> how is "synchronization of thunk evaluations" managed in Concurrent Haskell / GHC? Is there such a thing? If I share something that has yet to be evaluated between multiple threads, and they all evaluate it, do they all evaluate it, or does only one/a few?
02:24:58 <ivanm> roSievers: compare the type sigs...
02:24:59 <shachaf> @google lazy blackholes
02:25:01 <lambdabot> http://mainisusuallyafunction.blogspot.com/2011/10/thunks-and-lazy-blackholes-introduction.html
02:25:02 <shachaf> thirsteh: ‚òù
02:25:06 <ivanm> the closest you can get is some fundep or something
02:25:39 <thirsteh> shachaf: thanks! looks like exactly what I was looking for
02:25:43 <ivanm> class Differentiatiable t c | t -> c where derivative :: c -> (c -> t) -> c -> t
02:26:18 <ivanm> roSievers: why use 0.5/h for one, and /(2*h) for the other?
02:27:33 <roSievers> ivanm: no special reason, but I don't have a function to divide a Vector by a field element
02:28:05 <ivanm> roSievers: sure, but why not 1/(2*h) ?
02:28:53 <ivanm> unless you're going to be creating larger functions using your class method, I would be tempted not to bother writing a class
02:29:12 <roSievers> Never thought about it, they look about the same to me
02:29:57 <roSievers> I'm not even sure I'll use it again but I'd like to know how to do s.th like that
02:30:04 <ivanm> it just looks weird to me to have 0.5/h
02:30:23 <ivanm> roSievers: anyway, your actual class instance doesn't seem to have anything to do with functions
02:30:39 <thirsteh> shachaf: perfect, so if I understand what I've read so far correctly, a thunk has a "lazy mutex" -- other threads will eventually see the update
02:31:04 <roSievers> also, I'm not sure what the ‚Äú| t -> c‚Äù means, but I think I should just look that up
02:31:32 <shachaf> thirsteh: Sort of?
02:31:40 <ivanm> roSievers: Functional Dependency
02:31:41 <shachaf> roSievers: "functional dependencies" is the term.
02:31:45 <ivanm> AKA fundep
02:31:56 <thirsteh> shachaf: Yeah, I realize the analogy is a bit off. Anyway, very clever, and pretty much what I was hoping it did. Thanks again
02:43:07 <hpaste> roSievers pasted ‚ÄúDifferentiable works now‚Äù at http://hpaste.org/77241
02:43:26 <roSievers> ivanm: thank you
02:44:51 <ivanm> roSievers: you'd be better off having explicit instances for Double, Float, etc. rather than using (Fractional a) => ...
02:45:06 <ivanm> then you wouldn't need FlexibleInstances
02:45:15 <ivanm> and it'd be possible to have a custom implementation for some type
02:45:40 <roSievers> ok, I'll keep that in mind
03:10:36 <Shapeshifter> Hi. I just noticed something interesting. pi*10000000000000000000 prints 3.141592653589793e19 and pi*1000000000000000000000 prints 3.141592653589793e21, but pi*100000000000000000000 prints 3.1415926535897933e20, with an additional "3" at the end.
03:11:53 <Shapeshifter> pi*100000000000000000000000 prints 3.1415926535897926e23 ...
03:12:07 <ion> > pi*100000000000000000000000 :: CReal
03:12:08 <lambdabot>   can't find file: L.hs
03:12:10 <Shapeshifter> it's always rounding differently
03:12:10 <ion> > pi*100000000000000000000000 :: CReal
03:12:12 <lambdabot>   314159265358979323846264.3383279502884197169399375105820974944592
03:12:58 <Cale> Shapeshifter: That's because multiplying by 10 does weird stuff in base 2
03:12:59 <shachaf> @google floating point arithmetic
03:13:03 <lambdabot> http://en.wikipedia.org/wiki/Floating_point
03:13:03 <lambdabot> Title: Floating point - Wikipedia, the free encyclopedia
03:13:21 <shachaf> This is completely unrelated to Haskell. :-)
03:14:24 <Shapeshifter> Ah yes, interesting. python gives exactly the same representations. cool.
03:18:11 <ion> An IEEE-7something float encodes the sign with 1 bit, an exponent with a certain number of bits and a mantissa with a certain number of bits where n = (‚àí1)^sign ¬∑ 2^(exponent ‚àí offset) ¬∑ 1.mantissa. In Double, the total number of bits is 64, which sets a limit for the precision you‚Äôll get for pi*anything.
03:24:04 <Jafet> > text $ printf "%f" $ pi * (10^100)
03:24:06 <lambdabot>   314159265358979400000000000000000000000000000000000000000000000000000000000...
03:56:18 * hackagebot http-conduit-browser 1.6.4 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.4 (MikhailKuddah)
04:04:43 <efie> why does this not work? read "["a"]" :: [String]
04:05:52 <Botje> you can't nest "" like that.
04:05:57 <Botje> try "[\"a\"]|
04:06:00 <Botje> try "[\"a\"]"
04:06:54 <Jafet> Cut his allowance man
04:07:11 <efie> ah ok
04:15:12 <srhb> I'm still bothered by the lack of a "clean method" of producing infinite IO lists that are lazy given that the n+1th item depends on item n. Can we talk about that again? :P
04:15:29 <srhb> Is it just that the monadic IO concept gets in the way?
04:16:16 <shachaf> srhb: It's because you're not supposed to be able to make a lazy value such that forcing it has an observable effect.
04:16:20 * hackagebot websockets 0.7.1.0 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.1.0 (JasperVanDerJeugt)
04:16:41 <srhb> But that's annoying!
04:16:57 <shachaf> Oh.
04:16:59 <Jafet> @quote oasis
04:17:00 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
04:17:02 <shachaf> Well, in *that* case...
04:17:08 <srhb> :P
04:17:42 <srhb> It annoys me because my use case felt like the _perfect_ candidate for lazy IO lists. An infinite stream of webpages where each depends on the previous by the "next" link on it.
04:18:01 <srhb> pages >>= return . take 3 -- is just a gorgeous way of encapsulating that.
04:18:50 <Jafet> You don't need lazy IO to make the pages.
04:19:21 <srhb> Of course, if I can specify how many pages I want in advance.
04:19:45 <byorgey> srhb: but why do your webpages need to use IO?
04:20:10 <srhb> byorgey: Hm? It's a client application that gets web pages via http
04:20:29 <Jafet> let pages n = ("<html><body><a href=\"page?n=" ++ show (n+1) ++ "\">" ++ show (n+1) ++ "</a></body></html>") : pages (n+1) in pages 0
04:20:48 <Jafet> lambdabot, would you... never mind
04:21:00 <byorgey> OK.  But in that case it's just weird that the result of the program can depend on exactly when/if some thunk gets evaluated.
04:21:11 <srhb> How so?
04:21:39 <Jafet> I should read oleg's paper on how call/cc is, like, WEBSCALE
04:21:41 <srhb> And isn't that the case for any IO at any time?
04:21:43 <byorgey> because Haskell implementations are allowed to evaluate thunks at any time, or multiple times, or not at all, as long as it's non-strict
04:22:10 <byorgey> as shachaf said, just evaluating some thunk should not have observable effects.
04:22:23 <srhb> I guess I don't understand what shachaf said.
04:22:56 <srhb> Evaluating the thunk that gets one page clearly has observable effects. Why is it a problem that evaluating the thunk for the second page depends on the first?
04:23:33 <byorgey> it has nothing to do with whether the second page depends on the first.
04:23:37 <srhb> Hm.
04:24:28 <byorgey> even if you have a list  of  [IO Html]  which are all independent, you can't turn it into an IO [Html] in such a way that the web pages are generated lazily.
04:24:34 <byorgey> not without using unsafeInterleaveIO.
04:25:01 <srhb> And that's clever because...?
04:25:27 <byorgey> Clever? I don't understand what you're asking
04:25:39 <srhb> I guess I'm asking "why can't I do that"
04:25:54 <srhb> And why is it smart that I can't do that.
04:26:08 <bitonic> srhb: this would mean that forcing the Html, maybe in some pure code, would have effects on the rest of the world.  that is not nice
04:26:25 <srhb> I don't understand that.
04:26:49 <byorgey> you don't understand why that would happen? or you don't understand why it's not nice?
04:28:42 <srhb> I don't understand why it's not nice. I mean, even if we strictly evaluate the whole list the result is unsafe and depends on whether or not the webchanges were altered during the evaluation
04:28:42 <byorgey> Haskell has this nice property that evaluating a function of type, say,  Html -> Html  will not cause stuff to get printed on the screen or missiles to be launched or whatever.
04:29:07 <byorgey> that's a different meaning of "unsafe".
04:29:21 * ivanm has long idly thought of getting those USB missiles and writing a damn "unsafeLaunchMissiles" function
04:29:41 <bitonic> srhb: so let's say that you have some `foo :: IO [Html]' that generates pages.  at each generation, a database record is deleted.  now, let's say that I do `do (page1 : _) <- foo; return (bar page1)', where `bar :: Html -> Html'.  evaluating `bar' might or might not causes database records to be deleted.  this goes against a core value of Haskell
04:30:25 <srhb> Um..
04:30:41 <Sonderblade> in an arrow like tstamp <- this ! "data-timestamp" >>> arr read -< el, how do you specify that "arr read" should return an int?
04:31:19 <bitonic> Sonderblade: `ScopedTypeVariables'?  and then `arr read :: a String Int' for some arrow `a'
04:31:24 <bitonic> or even
04:31:29 <byorgey> srhb: now, if you can guarantee that (1) the IO actions which generate your web pages only do reading operations (i.e. they don't do any destructive updates like what bitonic said), and (2) you don't care about the fact that you have no control over when these reading operations will take place, then you may be justified in using unsafeInterleaveIO
04:31:29 <bitonic> `arr (read :: String -> Int)'
04:31:33 <srhb> OK, I guess I sort of maybe see it.
04:31:36 <srhb> Thanks byorgey and bitonic
04:32:16 <ivanm> bitonic: not sure if you answered this the other day: is there any particular reason you implemented a bk-trees type/package rather than using the existing one?
04:32:28 <Sonderblade> bitonic: thanks
04:32:41 <bitonic> ivanm: the reason is that I did it to learn something, and I realised later that I could split the packages
04:32:47 <bitonic> I think I did answer
04:32:49 <byorgey> srhb: I do agree that what you want could be quite convenient.  Just trying to help you see why it is not automatically allowed in general.
04:33:02 <ivanm> bitonic: mebbe; in that case I just missed it :p
04:33:15 <ivanm> tbh, I don't see any particular reason to use your package over the other one
04:33:22 <ivanm> since your implementation has less features
04:33:59 <bitonic> ivanm: you are probably right.  I can add a link saying "this is probably better"
04:34:33 * ivanm grumbles at GHC 7.6.1 source tarball taking so long to download
04:34:55 <ivanm> bitonic: or you improve yours so that it's better than the other one! :p
04:35:07 <bitonic> ivanm: mine does what I need :)
04:35:58 <ivanm> heh, fair enough
04:40:09 <bitonic> Sonderblade, srhb: yw :)
05:19:07 <neutrino> hi!
05:19:52 <neutrino> i was wondering what libraries you guys would suggest for command arg parsing with subcommands, which is simple to use and doesn't require a lot of boiler plate
05:20:08 <hpc> @hoogle getArgs
05:20:08 <lambdabot> System.Environment getArgs :: IO [String]
05:20:08 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
05:20:14 <hpc> er
05:20:18 <hpc> @hoogle getOpts
05:20:19 <lambdabot> No results found
05:20:21 <hpc> @hoogle getOpt
05:20:22 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
05:20:22 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
05:20:22 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
05:20:31 <hpc> that's in base iirc
05:20:52 <neutrino> i do believe it's missing some crucial features
05:20:56 <mauke> and has nothing to do with subcommands
05:21:04 <neutrino> help formatting, validation, short and long options
05:21:14 <hpc> ah
05:21:35 <mauke> I'm pretty sure it does that, though
05:21:46 <neutrino> so does any turing machine
05:21:56 <mauke> GetOpt isn't turing complete
05:22:09 <hpc> yeah, it does everything you ask except subcommands
05:22:23 <neutrino> subcommands are fairly important for me though
05:22:47 <hpc> it does give back an ordered list of [a] from reading the commands
05:23:00 <hpc> so perhaps you could treat it as a "lexer" of sorts, and parse the resulting list on your own
05:23:19 <neutrino> eh, doesn't sound that fun :(
05:23:19 <hpc> it would be more complex though
05:23:23 <neutrino> yeah
05:23:42 <hpc> perhaps an example of subcommands would help?
05:23:52 <mauke> git commit -a
05:23:55 <hpc> all i can think of is imagemagick's parens for layers
05:23:57 <hpc> aaaah
05:24:04 <neutrino> yeah
05:24:20 <hpc> oh, that's easy actually
05:24:21 <neutrino> cabal [whatever], aptitude [whatever]
05:24:27 <hpc> getArgs gives you the ordered list of commands
05:24:31 <hpc> so read the first element
05:24:38 <hpc> if it's a subcommand, do whatever with the tail
05:24:41 <neutrino> what about git -v commit
05:24:47 <hpc> note that you are passing the arg list to getOpt
05:25:00 <hpc> oh, didn't even know that worked
05:25:22 <mauke> neutrino: depends on whether you want it to behave differently than git commit -v
05:25:33 <neutrino> mauke: no
05:25:56 <hpc> getOpt returns a list of non-options
05:25:58 <hpc> perhaps that would help?
05:26:07 <neutrino> i was thinking of something like this
05:26:09 <mauke> well, then GetOpt should just work
05:26:34 <neutrino> hmm
05:26:35 <hpc> i don't actually remember any other libraries that do --option parsing
05:26:41 <neutrino> let me try GetOpt then
05:27:10 <gienah> cmdargs supports subcommands and is magical (uses template haskell)
05:27:23 <hpc> oh, you can also give the following ArgOrder:
05:27:24 <hpc> ReturnInOrder (String -> a)	
05:27:25 <hpc> wrap non-options into options
05:27:43 <hpc> so when GetOpt encounters say, a bare "commit" string
05:27:53 <hpc> it turns it into (Bareword "commit") or something like that
05:28:04 <mauke> hpc: why bother?
05:28:30 <neutrino> i don't know getopt well but i am not sure about the value of that
05:28:31 <mauke> just use Permute
05:28:41 <neutrino> what would Permute do?
05:28:54 <hpc> lets you provide args in any order
05:28:56 <mauke> pick out the options from between other arguments
05:29:02 <hpc> it's just another one of the constructors for that type
05:29:16 <neutrino> ahhh
05:29:16 <neutrino> ok
05:29:22 <mauke> foo -x bar -y baz -z ==> ['x', 'y', 'z'], ["bar", "baz"]
05:29:32 <mauke> pseudodescription :-)
05:29:46 <mauke> you'd get a list of whatever your option values are, plus a list of remaining arguments
05:29:47 <neutrino> does that also allow options with values?
05:29:52 <mauke> the first of which would be the sub command
05:29:52 <hpc> yes
05:30:00 <neutrino> e.g. git ci -m "message"
05:30:03 <hpc> --cmd=ls # that kind of thing
05:30:08 <hpc> and that too
05:30:11 <neutrino> oh, ok
05:30:18 <neutrino> and it does --help automatically?
05:30:18 <hpc> there's a small catch, actually
05:30:23 <hpc> optional arguments
05:30:28 <neutrino> oh?
05:30:34 <hpc> so for git -m commit
05:30:37 <neutrino> some of my arguments are optional indeed..
05:30:38 <hpc> does it pass "commit" to -m?
05:30:55 <hpc> getOpt will probably decide that yes, it does
05:30:56 <neutrino> yes, it "passes" the string to -m
05:31:04 <mauke> Option "m" ["message"] (ReqArg Message "MESSAGE") "commit message"
05:31:53 <mauke> neutrino: not quite, but it provides usageInfo, which gives you the text
05:32:32 <mauke> what this scheme doesn't do is handle subcommand-specific options
05:32:35 <hpc> i would be interested in seeing a version of getOpt that is lifted into a monad
05:32:39 <hpc> so you can use it as a state machine
05:32:55 <hpc> or DSL
05:34:58 <neutrino> mauke: i believe if a command-specific suboption is used without the command, i could just error out
05:35:05 <neutrino> that would make it OK, right?
05:35:10 <mauke> sure
05:35:21 <neutrino> i think that's what i currently do (in the python version of the program)
05:38:57 <mm_freak> what to do if "cabal upload" reports an error, but apparently the package is successfully uploaded on hackage?
05:39:42 <Clint> become confused
05:39:56 <mm_freak> it's the second time this happens
05:40:11 <mm_freak> cabal gives me a 500 internal server error, but the package is online
05:40:47 <hpc> presumably, hackage got the files and put them up, then arbitrarily crashed afterward
05:41:20 <mm_freak> if the hackage page and download work, can i just ignore this?
05:41:36 <mm_freak> or is it safe to retry?
05:42:25 <mm_freak> no, it's not‚Ä¶  hackage complains that the version is already online
05:43:48 <statusfailed> Is there a way to get the left-over bytestring to Serialize (cereal package)?
05:43:56 <statusfailed> left-over input*
05:44:33 <Clint> what do you mean, left-over?
05:44:51 <mm_freak> statusfailed: runGetState
05:44:57 <statusfailed> mm_freak: hahah I literally just saw that
05:44:59 <statusfailed> thanks :D
05:45:30 <bitonic> mm_freak: it happens often lately
05:45:38 <bitonic> the package is uploaded correctly
05:45:54 <mm_freak> ok
05:45:59 <mm_freak> next time i'll run with -v3
05:46:04 <mm_freak> to see what's going on
05:46:25 * hackagebot netwire 4.0.4 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.4 (ErtugrulSoeylemez)
05:46:35 <mm_freak> ah, there is the announcement =)
05:47:22 <statusfailed> mm_freak: oh, you released 4?
05:47:36 <statusfailed> cool :)
05:47:36 <hpc> 4.0.4 version not found
05:48:01 <mm_freak> hpc: did you cabal update?
05:48:07 <hpc> bad joke
05:48:18 <mm_freak> ah, i see =)
05:48:24 <mm_freak> statusfailed: yeah, for some time now =)
05:48:39 <mm_freak> i just haven't announced it yet to wait for feedback from the current users
05:50:11 <fenton>  /quit
05:53:40 <papyrus> hello,..i have a question.
05:53:55 <mm_freak> hi there, just ask
05:54:15 <papyrus> in the utf-8 , Type name (upper case) issue
05:56:31 <papyrus> is there escape code saying this is initial upper case character (like  data MyData , in korean, data ≥ªµ•¿Ã≈Õ)
05:57:04 <mauke> I don't understand what you mean by "escape code"
05:57:10 <mauke> also, that message was garbled
05:57:21 <mauke> U+00B3 (c2 b3): SUPERSCRIPT THREE [¬≥]; U+00BB (c2 bb): RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK [¬ª]; U+00B5 (c2 b5): MICRO SIGN [¬µ]; U+00A5 (c2 a5): YEN SIGN [¬•]; U+00C0 (c3 80): LATIN CAPITAL LETTER A WITH GRAVE [√Ä]; U+00CC (c3 8c): LATIN CAPITAL LETTER I WITH GRAVE [√å]; U+00C5 (c3 85): LATIN CAPITAL LETTER A WITH RING ABOVE [√Ö]; U+00CD
05:57:27 <mauke>  (c3 8d): LATIN CAPITAL LETTER I WITH ACUTE [√ç]
05:58:05 <rwbarton> I guess papyrus wants some way to define a type/data constructor with a Korean name
05:58:07 <papyrus> ah~~....
05:58:13 <papyrus> yes .
05:58:27 <mauke> > isUpper '„Öû'
05:58:27 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
05:58:30 <papyrus> rwbarton. you right ( i am sorry , my poor english)
05:58:31 <mauke> ...
05:59:28 <rwbarton> > generalCategory 'A'
05:59:30 <lambdabot>   UppercaseLetter
05:59:47 <mauke> > generalCategory '„Öû'
05:59:48 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
05:59:59 <rwbarton> oh, it is OtherLetter
06:00:28 <rwbarton> seems to count as lowercase though
06:00:31 <mauke> yeah, neither upper nor lowercase
06:00:39 <rwbarton> for identifier purposes
06:00:46 <rwbarton> let „Öû x = x -- works
06:00:47 <papyrus> yes.
06:00:52 <rwbarton> hmm
06:01:37 <mauke> workaround: prepend T everywhere
06:01:40 <mauke> :-/
06:01:54 <papyrus> ah.....
06:01:59 <papyrus> good :-)
06:02:50 <rwbarton> T for type constructor D for data constructor :)
06:03:00 <papyrus> not bad... :-) , thanks manuke ~
06:03:22 <papyrus> thanks rwbarton. good .
06:16:27 <tomeo> hi
06:16:27 * hackagebot html-conduit 0.1.0.3 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.1.0.3 (MichaelSnoyman)
06:16:29 * hackagebot xml-conduit 1.0.3.2 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.3.2 (MichaelSnoyman)
06:21:28 * hackagebot xml-hamlet 0.4.0.2 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.2 (MichaelSnoyman)
06:25:08 <byorgey> hi tomeo
06:56:30 * hackagebot console-program 0.3.0.0 - Interprets command line arguments and the contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.0.0 (AriePeterson)
07:01:30 <Sonderblade> is there a way to add deriving (Generic) to a builtin type like System.Time.ClockTime?
07:01:49 <rwbarton> with StandaloneDeriving yes
07:02:21 <rwbarton> "deriving instance Generic System.Time.ClockTime" -- as long as the constructors of ClockTime are exported
07:11:03 <starx> How do I run a haskell program with hugs?  I have no runhugs executable, only hugs
07:12:51 <geekosaur> hugs is an interpreter; "hugs" *is* runhugs
07:13:13 <geekosaur> it's the ghc-equivalent that doesn't exist
07:14:48 <mauke> I have runhugs
07:25:24 <starx> There is no runhugs in here. I've installed hugs 98 on iphone from cydia. It is pretty outdated (from 2006)
07:36:41 <byorgey> starx: why did you install hugs?
07:37:12 <srhb> I assume there's no GHC for iPhone.
07:38:06 <starx> It is the only haskell I found on cydia
07:38:27 <byorgey> ah
07:38:55 <byorgey> in any case, it's not just the version of hugs on cydia that's outdated.  hugs itself has not seen any new development since 2006.
07:44:37 <thirsteh> how do you parse a date with http://hackage.haskell.org/packages/archive/time-http/0.5/doc/html/Data-Time-Format-HTTP.html ?
07:46:20 <thirsteh>  / is there another library for converting a HTTP date to UTCTime?
07:47:15 <byorgey> thirsteh: looks like you use the 'convertAttempt' function
07:47:22 <byorgey> http://hackage.haskell.org/packages/archive/convertible-text/0.4.0.1/doc/html/Data-Convertible-Base.html#t:ConvertAttempt
07:47:55 <byorgey> given the  ConvertAttempt Ascii (Tagged HTTP UTCTime)  instance
07:48:04 <thirsteh> byorgey: Ah, thanks. I'd missed the API docs for Convertible. Was totally lost.
07:48:30 <byorgey> the lesson is to pay careful attention to lists of instances.
07:48:41 <byorgey> there's often way more functionality there than meets the eye =)
07:48:58 <thirsteh> I don't buy that it's necessary here, though
07:49:01 <thirsteh> most other packages have much saner APIs
07:49:13 <thirsteh> but I don't deny that my understanding of the type system is lackluster at best
07:49:17 <byorgey> at the very least, I totally agree that the Haddock documentation sucks
07:49:26 <byorgey> it needs more actual examples and some explanation
07:49:31 <thirsteh> it would be fine if an example for parsing was provided, not just one for spitting out a date
07:49:33 <thirsteh> yep
07:49:37 <byorgey> but it seems like a sane way to organize the actual API itself
07:51:01 <thirsteh> Ascii seems to be deprecated. Hmm.
07:56:11 <thirsteh> using Data.Time.Format to parse the RFC1123 format is probably easier
07:56:30 <thirsteh> thanks anyway, Convertible is interesting
08:01:02 <starx> When should I use foldl' over foldl?
08:02:12 <hpc> most of the time
08:03:06 <EvanR7> its funny, in ruby you have to use reduce to sum an array of numbers, no 'sum' method
08:03:09 <starx> Then in what cases should I use foldl?
08:03:26 <hpc> when foldl' doesn't work, maybe?
08:03:26 <tsou> starx: when you have an infinite list, i think..
08:03:31 <copumpkin> no
08:03:34 <hpc> foldl still wouldn't work on an infinite list
08:03:37 <EvanR7> doesnt foldl crash on infinite list
08:03:48 <tsou> ah sorry
08:04:05 <copumpkin> foldl is "useful" if you have a list that contains bottoms and your folded function isn't strict in the left argument
08:04:07 <hpc> the difference between the two is just strictness; if one doesn't work you can try the other, etc
08:04:21 <hpc> but you generally default to foldl'
08:04:31 <EvanR7> i default to foldr ;)
08:04:55 <starx> Do you have an example when one or the other wouldnt work?
08:05:02 <hpc> not handy
08:05:14 <copumpkin> > foldl (+) 0 (replicate 1000000 1)
08:05:16 <rwbarton> i imagine the haskell wiki page on foldr vs foldl vs foldl' does
08:05:16 <lambdabot>   *Exception: stack overflow
08:05:19 <copumpkin> > foldl' (+) 0 (replicate 1000000 1)
08:05:22 <lambdabot>   1000000
08:05:49 <hpc> typically you want foldr anyway
08:05:52 <monochrom> foldr (&&) blah (False : undefined)
08:05:55 <hpc> for any interesting list processing
08:06:07 <starx> interesting. What about the reverse, foldl working and foldl' not
08:06:12 <copumpkin> > foldl' (flip (&&)) True [undefined, False]
08:06:13 <lambdabot>   *Exception: Prelude.undefined
08:06:15 <copumpkin> > foldl (flip (&&)) True [undefined, False]
08:06:17 <lambdabot>   False
08:06:38 <copumpkin> they're much rarer
08:08:20 <monochrom> http://article.gmane.org/gmane.comp.lang.haskell.cafe/88120/ :)
08:08:20 <mrpantoufle> :t undefined
08:08:22 <lambdabot> a
08:08:56 <hpc> this isn't a stock lambdabot...
08:09:08 <EvanR7> forall a. a
08:09:20 <monochrom> :t id
08:09:22 <lambdabot> a -> a
08:09:32 <mauke> :t fmap
08:09:34 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:09:51 <monochrom> @type (.)
08:09:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
08:11:05 <mauke> :t (***)
08:11:06 <monochrom> yeah, it had forall's just yesterday
08:11:07 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
08:11:13 <copumpkin> byorgey: I made a grothendieck group in Agda if you want to play with virtual species, btw
08:11:17 <monochrom> then again, I don't mind either way
08:11:33 <hpc> im just trying to come up with a way to make lambdabot give a preflex command :P
08:16:32 <dgpratt> tried to install cabal-dev, but it requires a new version of the network package; installed the network package following these instructions: http://neilmitchell.blogspot.com/2010/12/installing-haskell-network-library-on.html
08:16:58 <starx> copumpkin: That failed because foldl' forces evaluation of both arguments while foldl doesnt?
08:17:33 <dgpratt> seemed to work, but now trying to install cabal-dev reports a link error: unknown symbol `_acceptNewSock'
08:17:47 <starx> :t undefined
08:17:48 <lambdabot> a
08:18:00 <dgpratt> what is the likely cause/resolution of such an error?
08:19:27 <starx> > True && undefined
08:19:28 <lambdabot>   *Exception: Prelude.undefined
08:19:37 <EvanR7> > False && undefined
08:19:39 <lambdabot>   False
08:19:50 <monochrom> wait, why is cabal-dev wanting a newer network, but an older mtl? is this trying to cause more problems than it solves?
08:19:53 <hpc> dgpratt: pick a specific version of cabal-dev
08:20:06 <hpc> what ghc/cabal?
08:20:17 <copumpkin> > foldl f z [a,b,c] :: Expr
08:20:19 <lambdabot>   f (f (f z a) b) c
08:20:54 <dgpratt> hpc: ghc: 7.4.1, cabal: 0.14 (?)
08:21:00 <copumpkin> > (undefined && True) && False
08:21:02 <lambdabot>   *Exception: Prelude.undefined
08:21:10 <hpc> hmm
08:21:11 <copumpkin> dammit
08:21:17 <hpc> im on 0.16.1 here
08:21:23 <hpc> and working cabal-dev
08:21:25 <copumpkin> > False && (True && undefined)
08:21:26 <lambdabot>   False
08:21:40 <copumpkin> starx: that's what the foldl might expand to
08:21:53 <dgpratt> hpc: ok, I'll see if I can upgrade
08:22:12 <starx> And foldl' ?
08:22:25 <dgpratt> or is that a bad idea if I'm using the platform?
08:22:45 <hpc> you can upgrade cabal just fine
08:22:50 <dgpratt> ok
08:23:08 <copumpkin> @src foldl'
08:23:09 <lambdabot> foldl' f a []     = a
08:23:09 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:23:16 <hpc> i remember it being tricky though
08:23:25 <copumpkin> so before proceeding with the recursion, it forces the accumulator
08:23:56 <copumpkin> note that in my case, the f is flip (&&)
08:24:05 <copumpkin> which means that it's strict in its right argument
08:24:17 <jmcarthur> the examples you guys have been using kind of makes me wish lambdabot had lub
08:24:37 <copumpkin> jmcarthur wubs lub
08:24:54 <jmcarthur> a more general version of unamb
08:25:22 <hpc> haskell dubstep:
08:25:31 <hpc> > wub lub lub flip zip lub
08:25:33 <lambdabot>   Not in scope: `wub'
08:25:33 <lambdabot>  Perhaps you meant `nub' (imported from Data.List)Not i...
08:25:37 <jmcarthur> ("foo", undefined) `lub` (undefined, 5)  =  ("foo", 5)
08:25:40 <hpc> haha, nub
08:26:21 <neutrino> guys
08:26:34 <neutrino> what happened o the System module in new versions of base? i forgot where it went
08:26:35 <jmcarthur> (\x -> undefined) `lub` (\x -> x+1) = (\x -> x+1)
08:26:37 <jmcarthur> and so on
08:26:45 <neutrino> @hoogle getopt
08:26:46 <lambdabot> System.Console.GetOpt getOpt :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String])
08:26:46 <lambdabot> System.Console.GetOpt getOpt' :: ArgOrder a -> [OptDescr a] -> [String] -> ([a], [String], [String], [String])
08:26:46 <lambdabot> System.Console.GetOpt module System.Console.GetOpt
08:27:13 <jmcarthur> neutrino: what are you looking for? getArgs?
08:27:15 <neutrino> @hoogle getargs
08:27:15 <lambdabot> System.Environment getArgs :: IO [String]
08:27:15 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
08:27:17 <neutrino> yes
08:27:19 <neutrino> found it :)
08:27:21 <jmcarthur> there it is
08:28:25 <ryanos> >1+1
08:28:50 <jmcarthur> > 1+1
08:28:52 <lambdabot>   2
08:28:56 <monochrom> I see, cabal-dev wants an old transformers
08:29:03 <ryanos> > 1+1
08:29:04 <lambdabot>   2
08:30:56 <mcstar> haskell has the weirdest stuff...
08:31:02 <jmcarthur> ?
08:32:02 <ryanos> !
08:35:39 <jmcarthur> mcstar: what are you talking about?
08:36:00 <mcstar> i just perused lub's and unamb's descriptions
08:36:02 <jmcarthur> ah
08:36:35 * hackagebot hashable-generics 1.1.8 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.8 (ClarkGaebel)
08:36:48 <jmcarthur> lub is pretty nice, although i think very few people are used to working with it. also its implementation is pretty unfortunate
08:40:17 <hpaste> jtlien pasted ‚Äúquick and dirty iota‚Äù at http://hpaste.org/77246
08:49:50 <mcstar> hm, so a typeclass dictionary is just a simple
08:49:54 <mcstar> 'data'
08:50:10 * mcstar hates accidental newlines
08:51:31 <dgpratt> *sigh* I'll be very happy when someone smarter than I am sorts out these cabal issues
08:52:22 <dgpratt> trying to install latest of cabal-install results in several compilation errors
08:53:06 <dgpratt> and trying to install cabal-dev --global tries to install network-2.3.2.0, even though it's already installed --global
08:55:23 <mcstar> could the typeclass mechanism be fully implemented by a user?
08:55:40 <mcstar> or, is there someting special to it, thats built into the compiler?
08:56:07 <EvanR7> you pass around values with their instances
08:56:12 <EvanR7> in the form of a record
08:56:18 <mcstar> well, one thing that comes to mind, is that instances are truly global
08:56:33 <EvanR7> yeah so if you did what i said it would be more flexible than classes ;)
08:56:39 <copumpkin> or not
08:56:44 <copumpkin> since the globalness is a virtue, too
08:56:45 <mcstar> also, more verbose :)
08:57:13 <EvanR7> copumpkin: like, conventionalness?
08:57:17 <copumpkin> yup
08:57:26 <copumpkin> the usual example floating around is Data.Map
08:57:32 <EvanR7> yeah but thats not prelcuded by passing dictionaries
08:57:49 <copumpkin> of course not, since that's how it's implemented behind the scenes anyway
08:57:55 <copumpkin> but it does prevent you from doing some operations efficiently
08:58:02 <mcstar> i dont think 'dictionary' is a good term
08:58:03 <copumpkin> if you can't assume that two maps you have were ordered by the same criterion
08:58:35 <EvanR7> im not really serious
08:59:03 <EvanR7> "i understand copumkins argument, but the fact of the matter is i dont believe what hes arguing about anymore"
08:59:07 <EvanR7> haha
08:59:11 <mcstar> copumpkin: why does that matter, if you *have* to pass the dictionaries?
08:59:44 <copumpkin> mcstar: say I want to merge two ordered lists efficiently, maintaining the order
08:59:45 <mcstar> you obviously have to keep track of what to pass and when
08:59:57 <mcstar> copumpkin: i understand you
09:00:18 <copumpkin> well, the difference is that you either have to cross your fingers and hope that your ordered lists used the same ordering
09:00:23 <copumpkin> or you can have the compiler guarantee that
09:00:26 <mcstar> this is only an issue, i believe, when this passing is done behind the scenes
09:00:28 <copumpkin> the thing is, you often can't assume that
09:00:40 <EvanR7> compilers arent the only source of convention
09:00:52 <EvanR7> its finger crossing either way
09:00:53 <copumpkin> mcstar: no? it isn't an issue when the passing is behind the scenes
09:00:56 <EvanR7> in an absolute sense
09:01:09 <copumpkin> I have a guarantee in haskell that my two lists were ordered in the same way
09:01:14 <copumpkin> so I can use a linear algorithm to merge them
09:01:21 <copumpkin> rather than having to do it in nlogn
09:01:52 <EvanR7> a library that advertised such a policy is the same difference
09:02:11 <EvanR7> the compiler is just like a library in that respect
09:02:23 <copumpkin> what if some other library returns ordered lists?
09:02:45 <EvanR7> if you use them wrong youre fucked
09:02:58 <copumpkin> that's what we like type systems to avoid
09:03:14 <copumpkin> especially since you can't compare the dictionaries at runtime
09:03:19 <copumpkin> in a meaningful way, anyway
09:03:22 <EvanR7> on that note, do we have a way in the type system to guarantee an ordered list
09:03:52 <copumpkin> not really, but sort of, if you're willing to reflect a lot of crap into the types
09:04:02 <copumpkin> not really worth it in haskell
09:04:07 <EvanR7> yeah
09:04:21 <mcstar> you can guarantee an ordered list if you cant deconstruct it
09:04:32 <mcstar> in this case, construct it
09:04:43 <copumpkin> sure, abstraction does it, but I'm talking about the type system
09:04:49 <copumpkin> you could still have a buggy abstract implementation
09:05:04 <EvanR7> or a buggy compiler ;)
09:05:09 <mauke> you could have a buggy type
09:05:28 <rwbarton> buggy keyboard
09:05:29 <copumpkin> sigh, the point is to reduce surface area of potential bugs
09:05:45 <EvanR7> buggy end users
09:06:03 <EvanR7> i always get those
09:13:42 <Sonderblade> any haskell module for parsing and unparsing urls?
09:19:39 <starx> Is Data.Map mutable?
09:19:54 <simpson> starx: No.
09:20:08 <donri> hah, SafeHaskell allows OPTIONS_GHC pragmas, including things like -F -pgmF that causes external programs to be run
09:20:14 <starx> Then how can insert be O(log n) ?
09:21:23 <mcstar> thats an open question
09:21:53 <mauke> starx: why wouldn't it be?
09:23:44 <starx> How can you construct a new tree without copying all the nodes?
09:24:04 <mcstar> you dont copy it
09:24:14 <mauke> by copying only what you change
09:24:19 <mauke> which is O(log n) nodes
09:25:31 <thirsteh> immutability means you can just re-use most of the map
09:25:39 <thirsteh> can somebody help me understand http://hpaste.org/77248 ?
09:26:17 <starx> But how can you reuse a node when it points to the old node, and not the one you just created
09:26:47 <mauke> thirsteh: incomplete code
09:26:55 <mauke> starx: you can't
09:27:07 <starx> As far as I can see it has to recreate everything from head to the node you inserted
09:27:17 <mauke> I don't see how
09:27:28 <mauke> most nodes don't point to the stuff you're creating
09:27:50 <rwbarton> "As far as I can see it has to recreate everything from head to the node you inserted" -- yes; which is O(log n) nodes
09:28:05 <mauke> oh, misread. sorry
09:28:43 <starx> rwbarton: yeah I see it now
09:29:07 <mauke> if you're spending O(log n) time to find a path from the root to the right node, you may as well allocate a few nodes on the way back up
09:33:44 <sauf> hi,  if f [x,y,z] [u,v] = [(x,u),(y,v)] then f = zip . How is called f when ...
09:33:49 <thirsteh> mauke: thanks. find was from Data.Text, not Data.List which I hadn't imported. Ironically that shows in the example :p
09:34:16 <sauf> f [x,y,z] [u,v] = [(x,u),(x,v),(y,u),(y,v),(z,u),(z,v)]
09:34:19 <thirsteh> mauke: or no, no Data.Text there. Anyway, thanks.
09:34:41 <rwbarton> > liftA2 (,) [x,y,z] [u,v]
09:34:43 <lambdabot>   [(x,u),(x,v),(y,u),(y,v),(z,u),(z,v)]
09:34:55 <monochrom> well, Data.Text.find wants Char->Bool
09:35:11 <sauf> thx rwbarton
09:35:19 <thirsteh> for some reason I assumed it was in the prelude
09:35:33 <thirsteh> monochrom: yes, hence the error
09:35:52 <monochrom> BC.find also wants Char->Bool
09:36:04 <mauke> :t find
09:36:06 <lambdabot> (a -> Bool) -> [a] -> Maybe a
09:36:08 <thirsteh> monochrom: I'm not using BC.find
09:36:12 <thirsteh> monochrom: It's Data.List.find
09:36:21 <hamid> @src seq
09:36:22 <lambdabot> Source not found. My pet ferret can type better than you!
09:36:45 <monochrom> perhaps you should use findSubstring?
09:37:09 <spaceships> is there a plugin for ghci to give snarky comebacks like lambdabot?
09:37:22 <rwbarton> hehe
09:37:31 <thirsteh> monochrom: I'm using find on a list of bytestrings
09:38:31 <thirsteh> just to be clear, I found the cause of the problem: I had imported Data.Text (and its find) and thought find was in the prelude (so I would have gotten an ambiguity error), but I was mistaken. I did not import Data.List.
09:40:04 <monochrom> I am all for posting a reduced version of actual code, don't get me wrong. I don't want to read long code either
09:40:17 <monochrom> but you've got to first test the code you post
09:41:07 <thirsteh> monochrom: thanks for the tip
09:41:54 <monochrom> indeed, if you tested, you would get "not in scope: find", and that would tell you it's not in Prelude
09:42:20 <thirsteh> like I said, I had imported Data.Text, which is why I got an error I didn't understand
09:42:56 <monochrom> yes, I'm saying testing the posted version (which does not import Data.Text) exposes exactly that
09:43:52 <thirsteh> monochrom: thanks, you've been very helpful
09:46:58 <pordan30> is it better to use type classes or type families to group often used class constraints into manageable collections?
09:49:21 <c_wraith> that's something you can do with type families?
09:49:36 <Sonderblade> @hoogle ByteString -> String
09:49:36 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
09:49:36 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
09:49:36 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
09:50:05 <c_wraith> pordan30: if you don't mind restricting yourself only to newer versions of GHC, I think using the ConstraintKinds extension is the best
09:51:13 <bxx> http://hpaste.org/77249  <- curious how this will work under the hood. from my understanding it won't read entire file into memory?
09:51:16 <Sonderblade> @hoogle Lazy.ByteString -> String
09:51:17 <lambdabot> Parse error:
09:51:17 <lambdabot>   Lazy.ByteString -> String
09:51:17 <lambdabot>       ^
09:51:27 <byorgey> copumpkin: cool (re: Grothendieck group).  link?
09:51:28 <pordan30> c_wraith: as far as i know, you can use type families to construct a constraint synonym, then use the constraint synonym in constraining contexts
09:51:51 <copumpkin> byorgey: https://gist.github.com/4010366 just supply your own commutative monoid!
09:51:52 <c_wraith> pordan30: I don't think type families can do that. But it's what the ConstraintKinds extension allows.
09:52:13 <copumpkin> byorgey: get virtual species for free! and if you call now, I'll throw in more crap for you that you don't want
09:52:36 <Sonderblade> @hoogle [GHC.Word.Word8] -> [Char]
09:52:37 <lambdabot> Parse error:
09:52:37 <lambdabot>   [GHC.Word.Word8] -> [Char]
09:52:37 <lambdabot>       ^
09:52:39 <pordan30> c_wraith: i didn't realize that you could access the constraint kind in such a way without using type families; interesting
09:52:47 <Sonderblade> @hoogle [Word8] -> [Char]
09:52:47 <lambdabot> Data.Generics.Text gshow :: Data a => a -> String
09:52:48 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
09:52:48 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
09:52:51 <byorgey> copumpkin: awesome, thanks!
09:53:10 <copumpkin> byorgey: it's really not all that exciting, as far as proofs go. Mostly just annoying wiggling of commutativities and associativities
09:54:19 <byorgey> sure, makes sense
09:54:48 <c_wraith> pordan30: you've probably seen examples of the two being used together - But without the ConstraintKinds extension, type families can't refer to classes, since they're not types.
09:55:52 <c_wraith> pordan30: anyway, getting back to your original question, it depends on how compatible you want to be. Making a new class is Haskell98 compatible. Using ConstraintKinds limits your code to newer versions of GHC, but is somewhat cleaner.
09:58:13 <pordan30> c_wraith: after referring to the documentation, i see that constraint synonymous can be declared with the constraintkinds extension. you're correct that previously seen constraint kinds only used with type families. since haskell98 compatibility isn't an issue, it sounds like the latter choice is best. thank you
10:01:21 <DMcGill> I'm looking to get Graphics.UI.GLUT working with freeglut on windows. Is this as simple as replacing the glut32.dll?
10:03:00 <DMcGill> or I guess getting it working on linux would be a fine alternative
10:03:49 <DMcGill> I found a guide but it's from 4 years ago: http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
10:05:39 <hiptobecubic> ugh, unicode source
10:07:09 <qasi> hiptobecubic, you must not like Agda, then
10:07:53 <hiptobecubic> does the language *require* it?
10:09:03 <qasi> hiptobecubic, there might be some kind of way to go around it, but I'm not sure it's really feasible...
10:09:37 <hiptobecubic> then you are right
10:11:32 <byorgey> hiptobecubic: are you complaining about the encoding used for some source file?   or the fact that it contains non-ASCII characters?
10:11:50 <jmcarthur> i don't think agda requires it, but the culture encourages it for sure
10:12:11 <qasi> hiptobecubic, well, it does make beautiful code.
10:12:28 <byorgey> it would be possible to write Agda with only ASCII, but difficult because you couldn't use the standard library.
10:13:24 <qasi> Also, Agda is mostly meant to be used from within emacs anyway, isn't it? And with emacs' Unicode support and the input methods there, there's really no reason not to.
10:13:47 <byorgey> indeed.
10:14:08 <dolio> You could extend it to other editors, but no one's putting in the work.
10:14:17 <dolio> Also the backend may still be pretty geared toward emacs.
10:14:24 <hiptobecubic> it's just annoying to read anywhere else
10:14:25 <dolio> I think at one point it was just emitting elisp.
10:14:32 <qasi>     map : {A B : Set} {P : A ‚Üí Set} {Q : B ‚Üí Set}
10:14:32 <qasi>           (f : A ‚Üí B) ‚Üí (‚àÄ {x} ‚Üí P x ‚Üí Q (f x)) ‚Üí
10:14:38 <qasi>     Foo : {A : Set} (p‚ÇÅ p‚ÇÇ : A √ó A) ‚Üí proj‚ÇÅ p‚ÇÅ ‚â° proj‚ÇÅ p‚ÇÇ ‚Üí Set‚ÇÅ
10:14:47 <qasi> I think Agda would be more annoying without Unicode 8)
10:15:12 <jfischoff> has anyone tried to make a type level prelude utilizing type families and data families?
10:15:26 <qasi> dolio, since Emacs is my editor of choice anyway, I didn't really look for other backends... I quite enjoyed how Agda and Emacs tied together.
10:16:28 <EvanR7> > []
10:16:29 <lambdabot>   []
10:16:35 <EvanR7> > [] :: [Char]
10:16:37 <lambdabot>   ""
10:16:42 <EvanR7> spooky
10:17:12 <hiptobecubic> jfischoff, i think so actually
10:17:27 <jfischoff> is it on hack age?
10:17:39 <jfischoff> *hackage
10:20:54 <hiptobecubic> I don't know how far they got
10:21:01 <hiptobecubic> and now i can't even find the link
10:21:43 <jfischoff> I doubt you can get that far, but it would still be nice to have
10:22:37 <pordan30> there is the type-prelude package on hackage, but it doesn't implement the entire standard prelude: http://hackage.haskell.org/package/type-prelude
10:23:00 <bartavelle> hello, I have this long question : http://pastebin.com/Xu9WMjUX
10:23:02 <jfischoff> oh cool
10:23:03 <mauke> The paste Xu9WMjUX has been copied to http://hpaste.org/77251
10:23:17 <jfischoff> too bad haddock craps out with things  '[]
10:23:45 <bartavelle> (do look at the pastebin paste, the hpaste is unreadable)
10:25:05 <mauke> no, I don't visit pastebin.com
10:25:44 <bartavelle> I should have phrased that as a suggestion
10:26:08 <bartavelle> but hpaste doesn't line wrap, which is nice for code, but not for prose
10:26:11 <jfischoff> pordan30: looks pretty good, but I am surprised they are using the type level Symbol type. You can't do anything with as far as I can tell
10:27:04 <Sonderblade> how would you add Generic to Data.Map? this: deriving instance Generic (Map String String) does not work
10:27:36 <parcs`> Sonderblade: you can't, Map's constructors are not exposed
10:27:44 <jfischoff> also I think generic can work for * and * -> * types
10:27:58 <jfischoff> which I guess Map String Int is ...
10:29:01 <tcsavage> hey guys, I'm getting regular "memory allocation failed (requested 2097152 bytes)" errors when I run my (rather computationally intensive) program. I assume it's because the system's run out of memory?
10:29:17 <Sonderblade> parcs`: that's odd.. i need them to be generic so that i can convert them to json
10:30:04 <EvanR7> tcsavage: or your program has a leak
10:31:15 <EvanR7> Sonderblade: all the json libs let you convert Data.Maps to json
10:31:24 <tcsavage> EvanR7: what's the best method of tracking leaks down?
10:31:32 <EvanR7> valgrind
10:31:41 <osa1> how does that code work: http://hpaste.org/77252 it doesn't have XCons and XListUnit type constructors
10:31:43 <mcstar> oh, i just realized most of the ghc extensions are quite old?
10:31:59 <EvanR7> tcsavage: its not easy in haskell, theres profiling stuff though
10:32:04 <mcstar> how many are added on average with each major release of ghc?
10:33:53 <jmcarthur> a handful, i'd say
10:34:41 <mcstar> so, that is more than a couple?
10:34:46 <mcstar> but less then a dozen
10:34:52 <Sonderblade> EvanR7: yeah you're right, i just had to declare the map as Map String String
10:34:55 <mcstar> basically, some
10:36:00 <osa1> also, is a function like f possible in second code: http://hpaste.org/77252
10:37:57 <Sonarpulse> Looking at this, there seems to built-ins for reading unsigned multibyte integers, but not signed http://hackage.haskell.org/packages/archive/binary/0.5.0.2/doc/html/Data-Binary-Get.html
10:38:04 <Sonarpulse> does anybody know a work around?
10:40:04 <dmwit> Sonarpulse: Read an unsigned and convert?
10:40:24 <dmwit> > fromIntegral (2^32+1 :: Word64) :: Int32
10:40:26 <lambdabot>   1
10:40:41 <dmwit> > 2^32+1 :: Word64
10:40:43 <lambdabot>   4294967297
10:40:51 <dmwit> Oh, right.
10:40:58 <dmwit> > fromIntegral (2^32-1 :: Word64) :: Int32
10:41:00 <lambdabot>   -1
10:41:19 <Sonarpulse> can I just use fromIntegral to go from Word32 to Int32 ?
10:41:41 <dmwit> > fromIntegral (2^32-1 :: Word32) :: Int32
10:41:43 <lambdabot>   -1
10:41:44 * hackagebot darcs 2.8.3 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-2.8.3 (GaneshSittampalam)
10:41:44 <dmwit> ;-)
10:42:37 <dmwit> > fromIntegral (-1 :: Word32) :: Int32
10:42:38 <lambdabot>   -1
10:42:42 <Sonarpulse> yea!
10:43:11 <Sonarpulse> wait how could you have -1 in a Word32 anyways?
10:43:24 <Rotaerk_> word up !
10:43:24 <dmwit> > -1 :: Word32
10:43:25 <lambdabot>   4294967295
10:43:52 <Sonarpulse> oh, so there is an implicit Int32 -> Word32
10:44:01 <Sonarpulse> or does haskell just overflow automatically?
10:44:02 <dmwit> osa1: Yes, as a typeclass, or just use GADTs instead.
10:44:15 <dmwit> There is no implicit Int32 to Word32 conversion.
10:44:18 <mauke> Sonarpulse: there's an implicit Integer -> whatever
10:44:22 <mauke> for literals
10:44:33 <Sonarpulse> ok
10:45:04 <Sonarpulse> hmm, now i am getting a weird error
10:45:07 <Sonarpulse> I can do functional
10:45:12 <Sonarpulse> I am starting to get monads
10:45:34 <Sonarpulse> but binary.Get has classes with monads, and I don't get classes
10:45:51 <Sonarpulse> btw does anybody know select all in emacs?
10:46:42 <mauke> you can't get monads without classes
10:46:45 <mauke> Monad is a class
10:46:56 <mauke> (and that's all it is)
10:47:07 <Sonarpulse> ok, that helps
10:47:15 <Sonarpulse> let me put this in a pastebin however
10:47:25 <jfischoff> is it possible to make a Storable instance for HList (assuming all of the types in the list are Storable)?
10:48:14 <hpaste> Sonarpulse pasted ‚ÄúCnCMix‚Äù at http://hpaste.org/77254
10:48:28 <Sonarpulse> hmm, clever
10:50:20 <dmwit> Don't forget to paste the error.
10:50:38 <Sonarpulse> ok
10:50:55 <Sonarpulse> though i think I just figured it out: parens aroudn the return
10:51:11 <dmwit> yes
10:51:50 <dmwit> get = liftM2 TopHeader (fromIntegral <$> getWord16le) (fromIntegral <$> getWord32le)
10:52:42 <Sonarpulse> hmm
10:52:57 <Sonarpulse> @type <$>
10:52:58 <lambdabot> parse error on input `<$>'
10:53:02 <dmwit> :t (<$>)
10:53:03 <Sonarpulse> oh well
10:53:03 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:53:12 <dmwit> :t fmap
10:53:14 <lambdabot> Functor f => (a -> b) -> f a -> f b
10:53:15 <dmwit> :t liftM
10:53:16 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
10:53:21 <Sonarpulse> what is a functor again?
10:53:32 <dmwit> It's a monad that's not as awesome.
10:53:44 <Sonarpulse> ok
10:54:28 <Sonarpulse> ok, found another missing paren, it works!
10:54:34 <Sonarpulse> I will now use the <$>
10:54:36 <hpaste> gertc pasted ‚Äú"me" does not work anymore?‚Äù at http://hpaste.org/77255
10:54:42 <Sonarpulse> higher order way
10:55:21 <Sonarpulse> btw what would be the default indentation for get
10:55:27 <nexion> if something is a Monad, is it also a Functor?
10:55:41 <Sonarpulse> emacs doesn't seem to like the 8 spaces I have now
10:55:59 <nexion> or usually but not always?
10:56:22 <Sonarpulse> it says <$> is not in scope
10:56:47 <dmwit> nexion: A monad is always a functor; a Monad is not always a Functor.
10:56:49 <mcstar> C-x h ?
10:57:08 <lispy> is it just windows, or does the new cabal --jobs=n feature cause bogus error messages when n > 1 ?
10:57:21 <donri> lispy: fixed in git
10:57:27 <nexion> dmwit, please explain :)
10:57:27 <lispy> I'm seeing it report things that are not the actual error messages that you would see with --jobs=1
10:57:32 <lispy> donri: cool
10:57:42 <dmwit> nexion: (That is, you can make an instance of the Monad type class without making that type an instance of the Functor class, but only by historical accident.)
10:57:46 <donri> lispy: if you mean that the output is missing whitespace
10:58:27 <donri> e.g. the nice indentation in ghc type errors etc
10:58:29 <nexion> dmwit: I see, so it's almost always the case, but there is a technicality where a Monad can be not a Functor
10:58:34 <lispy> donri: nope. I'm seeing different error messages. So, with --jobs=8, I might see an error related to module imports. With --jobs=1 I'll see a type error that has nothing to do with imports.
10:58:38 <dmwit> nexion: correct
10:59:02 <rwbarton> does the error occur in a different module?
10:59:19 <ceii> nexion: actually, if we're talking about the underlying concepts then a monad always is a functor, period
10:59:19 <lispy> rwbarton: I just have one module
10:59:26 <rwbarton> oh hm
10:59:29 <donri> lispy: well, with jobs>1 it redirects the output to .cabal/logs and shows the ten last lines for failing packages
10:59:32 <ceii> but Haskell doesn't force you to write that Functor instance
10:59:32 <rwbarton> (why are you building with --jobs=8 then :P)
10:59:33 <lispy> --jobs=8 shouldn't even be doing anything special here :)
10:59:34 <Sonarpulse> Also, is there anyways I can "instace Binary __
10:59:47 <lispy> rwbarton: it's just in my ~/.cabal/config that way
10:59:51 <Sonarpulse>  twice so that I put the puts and get in different sections?
10:59:51 <rwbarton> i see
11:00:18 <lispy> last 10 lines seems useless, also
11:00:20 <dmwit> Sonarpulse: No; however, you can write instance Binary Foo where put = putImpl; get = getImpl and write putImpl and getImpl in separate modules.
11:00:24 <rwbarton> Sonarpulse: you can write "instance Binary Foo where put = putFoo; get = getFoo" and then define putFoo and getFoo wherever you like
11:00:25 <donri> lispy: so with --jobs=1 you're seeing the full output, with --jobs=8 you're only seeing a small bit of it
11:00:31 <lispy> Everytime I got a failed build I had to redo it with --jobs=1
11:00:34 <donri> yea it's not perfect
11:00:37 * dmwit high fives rwbarton
11:00:41 <Sonarpulse> ok
11:00:47 <rwbarton> @arr
11:00:47 <lambdabot> Smartly me lass
11:00:58 <Sonarpulse> Codec.Archive.Tar had them in seperate modules
11:01:18 <Sonarpulse> but it reinvents the wheel more than I, so I think one module for read/write is fine
11:01:24 <donri> lispy: you can still view logs for individual packages in ~/.cabal/logs
11:01:31 <Sonarpulse> (though I am doing everythinging one file for hackability now)
11:01:58 <dmwit> nexion: Additionally, if you have a Monad instance, you can write a Functor instance completely generically as instance Functor Foo where fmap f m = do { a <- m; return (f a) }
11:02:28 <donri> or, fmap = liftM
11:03:20 <Torgen> How do I write a constraint that says I accept an instance of MArray where the value type is universally quantified? e.g. IOArray is fine, but IOUArray is not.
11:03:42 <nexion> dmwit, does this mean functors aren't really useful since we have monads, or is there something they're better for?
11:04:40 <donri> nexion: there are functors that aren't and can't be monads, but are and can be functors
11:04:44 <dmwit> nexion: There are functors which aren't monads.
11:05:02 <rwbarton> Torgen, you can't, unfortunately
11:05:17 <donri> nexion: and functions that only require functor, and thus is more general e.g. 'void'
11:06:45 * hackagebot distributed-process-p2p 0.1.0.0 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.0.0 (AlexanderBondarenko)
11:06:47 * hackagebot freetype2 0.1.1 - Haskell binding for FreeType 2 library  http://hackage.haskell.org/package/freetype2-0.1.1 (JasonDagit)
11:08:27 <Sonderblade> @hoogle openUrl
11:08:27 <lambdabot> No results found
11:09:39 <jonathn> I'm having trouble installing the connection library and was wondering if anybody might be able to help.  (1) "Building pem-0.1.1... Data/PEM/Parser.hs:39:13: Ambiguous occurrence `many'" (2) "Compiling Crypto.Cipher.AES...Error: no such instruction: `aesenc %xmm10,%xmm1'"
11:10:15 <seliopou> Anybody around that's familiar with Haskell generics?
11:10:34 <dmwit> seliopou: Don't ask to ask, just ask.
11:10:58 <dmwit> jonathn: (1) change the import list, I guess, but hard to say how exactly without the full error
11:11:01 <nexion> donri: for understanding, 'void' is implemented as a functor to support both functors and almost all monads. but technically, a Monad 'void' would be just as easy to implement, where it wouldn't support Functors which are not Monads. So since there are functors that are not monads, does this imply functor being able to do something that monads cannot? or in general, functor having any advantages?
11:11:09 <dmwit> (2) perhaps buy a new processor =)
11:11:24 <seliopou> dmwit: I think this is pretty obscure so I thought I'd preface my question
11:11:47 <nexion> also longest single message award goes to.... me
11:12:05 <dmwit> nexion: Anything a functor can do, a monad can do, too: all monads are functors!
11:12:19 <seliopou> I bascially want to do something like an everywhere transformation, except I want to change the constructor type, so imagine the argument to everybody being of type (forall a b. Data a, Data b => a -> b)
11:12:23 <dmwit> nexion: The advantage of functors is that there are *more things* that are functors.
11:12:23 <seliopou> does such a thing exist?
11:12:39 <nexion> dmwit, for historical reasons only, correct?
11:12:55 * mzero sings: "Anything Functor can do, Monad can do better..." "No, it can't" "Yes it can...."
11:12:56 <dmwit> nexion: Neither of my last two sentences have anything to do with history.
11:12:59 <hpaste> Sonarpulse pasted ‚Äúrepeating a monad‚Äù at http://hpaste.org/77256
11:13:23 <dmwit> nexion: I will henceforth use "monad" for the idea from math, and "Monad" for the thing in Haskell (similarly with "functor" and "Functor").
11:13:34 <Sonarpulse> I need to do a repeated get and put the values in a linked  list
11:13:39 <jonathn> dmwit: haha, well a new processor isn't an option so am I out of luck?
11:13:40 <dmwit> nexion: (this applies retroactively to all my messages in the last, say... six months)
11:13:56 <Sonarpulse> I know whatever I have there must be very wrong, but hopefull the idea is sound
11:13:59 <seliopou> :t replicate
11:14:01 <lambdabot> Int -> a -> [a]
11:14:07 <dmwit> jonathn: I don't know. You could find out what that instruction does and see if you can create/enable an alternate code path for processors that don't have it.
11:14:15 <EvanR7> in attoparsec can i parse 'a line' (bytes followed by a newline (\r\n) or endoffile)
11:14:23 <seliopou> :t \n -> sequence . (replicate n)
11:14:25 <lambdabot> Monad m => Int -> m a -> m [a]
11:14:35 <dmwit> :t replicateM
11:14:36 <lambdabot> Monad m => Int -> m a -> m [a]
11:14:39 <seliopou> there we go
11:14:44 <nexion> dmwit: now it makes sense, thanks!
11:15:03 <Sonarpulse> will state be passed from one invocation of the monad to the next?
11:15:24 <mcstar> [] is not Int
11:15:52 <mcstar> also, int is not Int
11:15:54 <mzero> Sonarpulse: that sounds like a suspicous need. That is to say, either you are doing list processing in way that doesn't seem 'natural' --- or perhaps you are doing something for efficency, in which case perhaps a Vector is what you want
11:16:12 <copumpkin> :t (+) :: int -> int -> int
11:16:14 <lambdabot>     No instance for (Num int1)
11:16:14 <lambdabot>       arising from a use of `+'
11:16:14 <lambdabot>     In the expression: (+) :: int -> int -> int
11:16:16 <copumpkin> damn!
11:16:27 <dmwit> Sonarpulse: I'm not sure I understand the question, in part because your language is a bit sloppy.
11:16:29 <Sonarpulse> mzero: I am writing a parser for a Tar like file format
11:16:33 <dmwit> Sonarpulse: What do you mean by "invocation of the monad"?
11:16:43 <merijn> dmwit: The downside of void being functor is that (lacking a "Functor m => Monad m" constraint on the class) you know need two constraints for functions using void :\
11:16:47 <Sonarpulse> well to remove my abstraction
11:16:51 <Paprikachu> what do i have to import for <*>?
11:16:59 <dmwit> ?hoogle (<*>)
11:17:00 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
11:17:02 <merijn> Paprikachu: Control.Applicative, most likely
11:17:07 <Paprikachu> thanks
11:17:10 <mzero> Sonarpulse: that doesn't sound like something that needs re-writing of list elements....
11:17:21 <dmwit> Learn how to ask your question in a way that can be mechanically answered. ;-)
11:17:23 <merijn> Paprikachu: You can also use Hoogle/Hayoo to locate these things :)
11:17:36 <Sonarpulse> the Mix format I am dealing with contains a variable number of headers for every file within the archive
11:17:44 <seliopou> Sonarpulse: I suspect that if you use replicateM, it'll do what you want it to
11:18:02 <Sonarpulse> Maybe, I don't know of that
11:18:13 <Paprikachu> why doesn't this work: main = (print . length . words) <*> getContents
11:18:16 <Sonarpulse> I have done functional programming before, but not haskell
11:18:17 <mcstar> is none bothered by his type sig, beside me?
11:18:28 <mcstar> noone
11:18:37 <Sonarpulse> so I don't know the higher order shortcuts for Monads
11:18:47 <dmwit> Paprikachu: Perhaps you wanted (<$>) instead of (<*>).
11:18:48 <mzero> Sonarpulse: perhaps what you have from the parse is a list of tripes  (FileName, HeaderName, String) --- generate a list of all of them, then use something like Data.Map's fromListWith to combine them, doing the shuffling and "rewriting" you envision
11:19:08 <Sonarpulse> let me just make a pastebin from what I have so far
11:19:08 <parcs`> Paprikachu: why should it work?
11:19:12 <merijn> :t (<*>)
11:19:14 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:19:17 <dmwit> mcstar: What makes you think nobody is bothered by it?
11:19:21 <Sonarpulse> then you can see the non-serialized data definition I alrleady made
11:19:23 <Paprikachu> then i don't get the difference between <*> and <$> :(
11:19:29 <merijn> Paprikachu: <*> expects a function *inside* the f
11:19:33 <parcs`> <$> doesn't work there either
11:19:35 <parcs`> you want =<<
11:19:36 <rwbarton> actually you wanted =<<
11:19:42 <Sonarpulse> and either advice me on how to revive is, or best Put and Get to and from it
11:19:51 <srhb> parcs`: Why not?
11:19:53 <dmwit> Works for me. =)
11:20:00 <merijn> Paprikachu: Look at the first argument "f (a -> b)" vs "(a -> b)" (i.e. function inside functor vs just a function)
11:20:01 <mcstar> dmwit: well, i expected everyone would suggest, fix that first, then lets work on the algorithm :)
11:20:05 <Paprikachu> ?hoogle +<<
11:20:06 <lambdabot> No results found
11:20:08 <parcs`> srhb: because print
11:20:08 <Paprikachu> ?hoogle =<<
11:20:09 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
11:20:09 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
11:20:17 <merijn> Paprikachu: =<< is just >>= but reversed :p
11:20:23 <hpaste> Sonarpulse pasted ‚ÄúCnCMix‚Äù at http://hpaste.org/77257
11:20:31 <Paprikachu> i know neither of them
11:20:40 <lispy> ?tell edwardk New OpenGL/OpenGLRaw with type aliases is uploaded
11:20:40 <lambdabot> Consider it noted.
11:20:42 <donri> nexion: as an example, (a,) is a Functor: fmap (+1) (1,2) == (1,3), but if you try to write a Monad instance you get stuck at return a = (???,a)
11:20:45 <bartavelle> is there a problem when doing something like : type ListenerMonad a = CME.ErrorT ListenerExit (CMSL.StateT (ResourceID, Event) GameMonad) a       where GameMonad is a RWS monad ?
11:21:05 <merijn> Paprikachu: Ah, >>= takes a monadic value and applies a function that returns a monadic value (like print) to it
11:21:11 <merijn> :t (>>=)
11:21:13 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:21:17 <Paprikachu> i don't even know what a monad is...
11:21:21 <dmwit> bartavelle: You tell us. Is there a problem?
11:21:34 <bartavelle> dmwit, yes, strange error message when using throwError
11:21:46 * hackagebot OpenGLRaw 1.3.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGLRaw-1.3.0.0 (JasonDagit)
11:21:49 <bartavelle> by "strange" i mean the error message you get when you don't lift
11:21:52 <merijn> Paprikachu: Oh, that is entirely different issue then :) What book/whatever are you using to learn haskell?
11:22:06 <bartavelle> except I have no clue on why I should lift throwError
11:22:06 <Paprikachu> learnyouahaskell
11:22:10 <dmwit> bartavelle: Post some code and the error, instead of making us try to guess what's in your head.
11:22:16 <Sonarpulse> so what should I use?
11:22:25 <Paprikachu> i'm at the chapter 'applicative functors'
11:22:28 <bartavelle> 2s
11:22:36 <merijn> Paprikachu: Ah, I think monads are covered after that one?
11:22:46 <Paprikachu> yeah
11:23:02 <john_r_watson> Is there a flag I need to pass to ghci to get it to parse the "C++"-looking preprocessor directives like #if __GLASGOW_HASKELL__ < 704.  Right now it's complaining about "lexical character 'i'" on that line
11:23:12 <dmwit> bartavelle: Perhaps ListenerExit is not an instance of the Error type class.
11:23:32 <seliopou> Sonarpulse: are you trying to parse the EntryHeaders given numFiles you got from the TopHeader?
11:23:37 <dmwit> john_r_watson: -XCPP or use {-# LANGUAGE CPP #-} at the top of the file.
11:23:42 <Sonarpulse> exactly!
11:23:45 <merijn> Paprikachu: Oh, in that case you might want to ignore all helpful remarks and go on until you reach that chapter, at which point all of the previous suggestions should make sense
11:23:54 <john_r_watson> dmwit: thanks
11:24:01 <bartavelle> dmwit, http://hpaste.org/77258
11:24:10 <Paprikachu> i'm still confused by <*> and <$>
11:24:15 <Sonarpulse> and put them in a list, as that seems most appropriate for my high level representation
11:24:17 <bartavelle> an excerpt of (I hope) the relevant parts
11:24:25 <merijn> Paprikachu: That's easy to show :)
11:24:31 <Paprikachu> i thought <*> is like fmap
11:24:37 <merijn> > succ <$> Just 1
11:24:39 <lambdabot>   Just 2
11:24:44 <merijn> Which is the same as
11:24:49 <merijn> > fmap succ (Just 1)
11:24:51 <lambdabot>   Just 2
11:24:54 <dmwit> bartavelle: Error looks pretty clear to me. "No instance for (CME.Error ListenerExit)... Possible fix: add an instance declaration for (CME.Error ListenerExit)".
11:24:58 <merijn> The use case for <*> is this
11:25:12 <Sonarpulse> I am hoping smart compilation + laziness will mean that my internal non-serialized data definition is not too important performance-wise
11:25:12 <merijn> > Just succ <*> Just 1
11:25:14 <lambdabot>   Just 2
11:25:20 <bartavelle> dmwit, well this is entirely unclear to me, and the reason I asked the question is that I hoped this would be clear to someone.
11:25:26 <bartavelle> Glad I found someone ...
11:25:33 <dmwit> bartavelle: Do you know about type classes?
11:25:37 <bartavelle> yes
11:25:39 <merijn> Paprikachu: The difference is that in the second case my function is *also* in the functor (in this case Maybe)
11:25:41 <Paprikachu> i see
11:25:54 <dmwit> bartavelle: Okay. What don't you understand, then?
11:25:59 <merijn> You can then use it for things like this
11:26:08 <seliopou> Sonarpulse: so you were starting to write an instance for TopHeader, and see how you named it a?
11:26:13 <merijn> :t (+) <$> Just 1
11:26:15 <lambdabot> Num a => Maybe (a -> a)
11:26:15 <Paprikachu> and =<< applies a function on the left to the thing on the right?
11:26:27 <merijn> > (+) <$> Just 1 <*> Just 2
11:26:29 <lambdabot>   Just 3
11:26:44 <seliopou> do something like this: b <- replicateM (numFiles a) get
11:26:48 * hackagebot GLURaw 1.3.0.0 - A raw binding for the OpenGL graphics system  http://hackage.haskell.org/package/GLURaw-1.3.0.0 (JasonDagit)
11:26:50 * hackagebot OpenGL 2.6.0.0 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.6.0.0 (JasonDagit)
11:26:52 * hackagebot GLUT 2.3.1.0 - A binding for the OpenGL Utility Toolkit  http://hackage.haskell.org/package/GLUT-2.3.1.0 (JasonDagit)
11:26:54 <Paprikachu> so how is this expression evaluated?
11:26:55 <Sonarpulse> I named it a, because I figured the same recursion would be usefull for putting those EntryHeaders back in a lazy byte string
11:27:02 <Paprikachu> (+) <$> Just 1 first?
11:27:12 <merijn> Paprikachu: As you can see "(+) <$>" return "Maybe (a -> a)", so if you want to apply the second argument you run into problems when trying to run <$>
11:27:19 <Paprikachu> which turns it into Just (1+)
11:27:24 <vetesnik> Hello, does anyone know good practicing grounds for a newbie besides the 99 questions page?
11:27:25 <merijn> Paprikachu: Yes
11:27:40 <Paprikachu> > Just (1+) <*> Just 2
11:27:41 <lambdabot>   Just 3
11:27:45 <dmwit> vetesnik: code kata
11:27:53 <bartavelle> why it is asking me to do this. I run in (ErrorT ListenerExit m a), why should I write instances of (Error ListenerExit) for throwing errors ? isn't what the error transformer is about ? I do not even understand what this instance should be
11:28:14 <merijn> Paprikachu: The answer to "how is this evaluated" in case of operators is to run ":i (<*>)" in ghci, which will tell you if it's left to right (infixl) or right to left (infixr)
11:28:15 <dmwit> It is asking you to do this because the type of throwError says to.
11:28:17 <dmwit> :t throwError
11:28:19 <lambdabot> MonadError e m => e -> m a
11:28:22 <Paprikachu> :i <*>
11:28:35 <dmwit> Well, okay, because the instance of MonadError for ErrorT says to. =)
11:28:37 <merijn> Paprikachu: Doesn't work in lambdabot, unfortunately
11:28:54 <Sonarpulse> seliopou: replicateM is not in scope, what should I  include?
11:29:03 <dmwit> bartavelle: instance (Monad m, Error e) => MonadError e (ErrorT e m)
11:29:03 <bartavelle> :/
11:29:05 <seliopou> ?hoogle replicateM
11:29:06 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
11:29:06 <lambdabot> Control.Monad replicateM_ :: Monad m => Int -> m a -> m ()
11:29:06 <lambdabot> Data.Sequence replicateM :: Monad m => Int -> m a -> m (Seq a)
11:29:10 <merijn> Paprikachu: If you had done "Just (1+) <$> Just 2" you would have gotten an error because the first argument of <$> is (a -> b), not "f (a-> b)"
11:29:20 <seliopou> Sonarpulse: Control.Monad
11:29:21 <seliopou> :)
11:29:24 <Sonarpulse> thanks!
11:29:49 <bartavelle> AHHHHHH
11:29:56 <seliopou> Sonarpulse: you also have a bunch of type errors in there
11:30:01 <Paprikachu> > Just (1+) <*> Just 2
11:30:03 <lambdabot>   Just 3
11:30:09 <seliopou> but the compiler should point those out for you :)
11:30:12 <merijn> Paprikachu: As for what =<< does, I would just forget about it until the monad chapter of LYAH. =<< is a monad operator (similar to how <$> and all are Functor/Applicative operators)
11:30:24 <bartavelle> dmwit, this makes sense, I always used ErrorT String without thinking about it
11:30:27 <bartavelle> thanks
11:30:27 <merijn> > Just (1+) <$> Just 2
11:30:30 <lambdabot>   Couldn't match expected type `a0 -> b0'
11:30:30 <lambdabot>              with actual type `Data...
11:30:47 <vetesnik> dmwit: ok thanks (code kata)
11:31:20 <dmwit> vetesnik: The other standard suggestions which I didn't make (expecting others to) are Project Euler, make a raytracer, build an IRC bot, and implement the untyped lambda calculus.
11:31:28 <Paprikachu> > length <*> getContents
11:31:29 <lambdabot>   Couldn't match expected type `a0 -> b0'
11:31:29 <lambdabot>              with actual type `GHC....
11:31:42 <Paprikachu> > length <$> getContents
11:31:44 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Int))
11:31:44 <lambdabot>    arising fro...
11:31:52 <merijn> Paprikachu: getContents doesn't work in lambdabot, because lambdabot doesn't do IO
11:31:58 <merijn> :t length <$> getContents
11:32:00 <lambdabot> IO Int
11:32:05 <merijn> :t length <*> getContents
11:32:06 <lambdabot>     Couldn't match expected type `a0 -> b0' with actual type `Int'
11:32:06 <lambdabot>     Expected type: [a1] -> a0 -> b0
11:32:07 <lambdabot>       Actual type: [a1] -> Int
11:32:22 <Paprikachu> :t print . length . words <$> getContents
11:32:24 <lambdabot> IO (IO ())
11:32:31 <Paprikachu> what
11:32:38 <merijn> Paprikachu: Print unfortunately won't work this way
11:32:40 <bartavelle> dmwit, I defined the instance, but what is the point of this ? When do strMsg or noMsg get used ?
11:32:52 <Paprikachu> :t show . length . words <$> getContents
11:32:53 <lambdabot> IO String
11:33:04 <vetesnik> dmwit: I haven't finished the learnyouhaskell book yet, I'm in the middle of it but I keep forgetting what I read earlier :/
11:33:09 <Paprikachu> :t putStrLn . show . length . words <$> getContents
11:33:11 <lambdabot> IO (IO ())
11:33:14 <Paprikachu> i don't get it
11:33:25 <Paprikachu> what is IO (IO ()) even?
11:33:28 <dmwit> bartavelle: strMsg is used in fail, I guess
11:33:30 <merijn> Paprikachu: Ok, let's look at the types
11:33:39 <merijn> :t getContents
11:33:40 <lambdabot> IO String
11:33:47 <merijn> :t (<$>)
11:33:49 <lambdabot> Functor f => (a -> b) -> f a -> f b
11:34:15 <bartavelle> ah probably yes
11:34:19 <merijn> So, "<$>" takes (a -> b) and returns "f a -> f b" for all functors (IO happens to be a functor)
11:34:23 <Sonarpulse> seliopou: what about extracting the filles themselves
11:34:25 <merijn> :t print
11:34:27 <lambdabot> Show a => a -> IO ()
11:34:44 <seliopou> Sonarpulse: I don't know the file format, that's up to you!
11:35:07 <Sonarpulse> well I can map length on Entry header to the list of lengths
11:35:11 <merijn> Paprikachu: Print happens to take any Showable type and returns an IO action that will print that value "a -> IO ()", now if we replace "a -> b" in the type of <$> we get this:
11:35:22 <Sonarpulse> and then I need to getBytestring for each length
11:35:44 <merijn> Paprikachu: "(<$>) :: (a -> IO ()) -> IO a -> IO (IO ())"
11:36:02 <Sonarpulse> well getLazyByteString to be precise
11:36:19 <Sonarpulse> I think I will need something more powerfull then replicateM for that
11:36:28 <merijn> Paprikachu: You can think og fmap/<$> as "executing a function *inside* a monad", i.e. the function is inserted in the monad, modifies the data inside and we're done.
11:36:47 <merijn> Paprikachu: Actually replace monad with Functor in that sentence
11:37:15 <koda> from a data type of this kind "data Person = Name String | Surname String" how do you extract the String value?
11:37:22 * lispy needs to write a script that does cabal uploads based on github tags
11:37:34 <koda> using person of type Person
11:37:37 <merijn> Paprikachu: The problem is, that that's now what you want to do. You want to take something out of the functor, and do something with it. The problem is that functor doesn't support an operation that takes a value out
11:37:53 <lispy> that way I could just tag something in my github and have a 'service in the cloud' that watches my github and does the cabal upload.
11:38:14 <koda> i tried let (Name String) = person but it didn't work
11:38:33 <seliopou> Sonarpulse: sounds plausible
11:38:53 <Paprikachu> but i can take the value out by binding it to a name, right?
11:39:09 <Paprikachu> line <- getContents; foo line
11:39:24 <Paprikachu> and that's what i want to do, just in one line
11:39:37 <merijn> Paprikachu: What you want to do is something like take your "print :: a -> IO ()" and your "IO String" and get an "IO ()" i.e. print the result. So instead of "<$> :: Functor f => (a -> b) -> f a -> f b" you want something like "bind :: Functor f => (a -> f b) -> f a -> f b"
11:39:43 <Sonarpulse> I think I need foldM
11:40:02 <seliopou> :t foldM
11:40:03 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
11:40:11 <merijn> Paprikachu: That bind function exists, but not for functor's (because functor's can't do that), it is a monad function. Luckily, IO is a monad as well as a functor
11:40:16 <seliopou> Sonarpulse: what about mapM?
11:40:18 <seliopou> :t mapM
11:40:19 <merijn> :t (>>=)
11:40:19 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
11:40:21 <lambdabot> Monad m => m a -> (a -> m b) -> m b
11:40:44 <Sonarpulse> I can only do it im parrallell if I pass the size of each file and the offet
11:40:46 <Paprikachu> :t bind (print . length . words) getContents
11:40:47 <lambdabot>     Not in scope: `bind'
11:40:47 <lambdabot>     Perhaps you meant one of these:
11:40:47 <lambdabot>       `find' (imported from Data.List),
11:41:07 <Sonarpulse> but I can do "map offet entries" too
11:41:11 <merijn> Paprikachu: bind is actually called >>= in haskell. So if we look at our "print :: a -> IO ()" and "IO String" we get this:
11:41:15 <Sonarpulse> (a is now top, b is entries)
11:41:23 <Sonarpulse> * "map offset entries"
11:41:23 <merijn> :t (>>= print)
11:41:25 <lambdabot> Show a => IO a -> IO ()
11:41:37 <merijn> :t getContents >>= print
11:41:39 <lambdabot> IO ()
11:41:43 <seliopou> Sonarpulse: depends on the meaning of offset, you know better than I.
11:41:47 <merijn> :t getContents >>= print . length
11:41:49 <lambdabot> IO ()
11:42:24 <Sonarpulse> well the files are storied sequentially in the bytestring
11:42:43 <merijn> Paprikachu: =<< is just >>= but with the argument reversed, so "(>>=) :: Monad m => m a -> (a -> m b) -> m b" and "(=<<) :: (a -> m b) -> m a -> m b"
11:42:51 <Sonarpulse> so to extract with map, I need to pass a starting and ending adress to getLazyBytesting (or something like it
11:42:58 <merijn> :t print . length =<< getContents
11:43:00 <lambdabot> IO ()
11:43:25 <Sonarpulse> fold is explicitly recursive so will instead pull the files in order which is probably easier
11:43:33 <merijn> Paprikachu: The do syntax you mentioned "line <- getContents" is actually implemented using >>=, as the next LYAH chapter should explain
11:43:33 <ParahSailin> @src (=<<)
11:43:33 <lambdabot> f =<< x = x >>= f
11:44:04 <Sonarpulse> (one outstanding issue is I bet certain things are aligned in the file, not packed as in my naive implementation)
11:44:10 <Paprikachu> @src >>=
11:44:11 <lambdabot> Source not found. You speak an infinite deal of nothing
11:44:18 <Paprikachu> @src (>>=)
11:44:18 <lambdabot> Source not found. Take a stress pill and think things over.
11:44:22 <Sonarpulse> is there like a mapM2? that maps two lists?
11:45:06 <ParahSailin> @src [] >>=
11:45:06 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
11:45:18 <geekosaur> you could zip two lists together and map over that, if that's what you mean
11:45:35 <merijn> Paprikachu: >>= doesn't have a source, since the implementation depends on the monad you are using
11:45:43 <fryguybob> @hoogle zipWith
11:45:43 <ParahSailin> @src [] (>>=)
11:45:44 <lambdabot> Prelude zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:45:44 <lambdabot> Data.List zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
11:45:44 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
11:45:44 <lambdabot> xs >>= f     = concatMap f xs
11:45:51 <merijn> For example >>= for Maybe works different than for lists
11:45:55 <ParahSailin> @src IO (>>=)
11:45:55 <lambdabot> m >>= k     = bindIO m k
11:46:10 <Paprikachu> @src bindIO
11:46:10 <lambdabot> Source not found. My brain just exploded
11:46:27 <ParahSailin> that source is internal ghc prolly
11:46:32 <Paprikachu> @src Maybe >>=
11:46:32 <lambdabot> Source not found.
11:46:36 <Paprikachu> @src Maybe (>>=)
11:46:36 <lambdabot> (Just x) >>= k      = k x
11:46:36 <lambdabot> Nothing  >>= _      = Nothing
11:47:25 <merijn> Paprikachu: You can use it to combine multiple "a -> Maybe b" functions together with short-circuiting behaviour (i.e. if one returns Nothing then the entire combination returns Nothing)
11:50:42 <Sonderblade> @hoogle IO String -> String
11:50:42 <lambdabot> Data.Data tyconModule :: String -> String
11:50:42 <lambdabot> Data.Data tyconUQname :: String -> String
11:50:42 <lambdabot> Test.QuickCheck.Text bold :: String -> String
11:51:12 <merijn> Sonderblade: There is no "IO a -> a" function
11:51:28 <merijn> You most likely want fmap, >>= or do notation
11:51:31 <Paprikachu> is IO Maybe Int a valid type?
11:51:38 <atriq> IO (Maybe Int)
11:51:43 <merijn> Paprikachu: Sure
11:51:46 <atriq> IO Maybe Int is a kind error
11:51:54 <Paprikachu> ?
11:51:59 <atriq> :k IO
11:52:00 <lambdabot> * -> *
11:52:01 <merijn> Paprikachu: Given the appropriate parenthesis as atriq mentions
11:52:10 <atriq> :k Maybe
11:52:12 <lambdabot> * -> *
11:52:16 <atriq> :k Int
11:52:17 <merijn> IO Maybe Int == (IO Maybe) Int, which is wrong
11:52:17 <lambdabot> *
11:52:26 <merijn> But "IO (Maybe Int)" is just fine
11:52:30 <Paprikachu> i see.
11:52:39 <atriq> foo Maybe Int would need foo :: (* -> *) -> * -> *
11:52:50 <merijn> "IO (Maybe Int)" is no different from "Maybe (Maybe Int)" or "[Maybe Int]"
11:52:56 <Paprikachu> does IO (IO X)) make sense?
11:53:14 <atriq> It's an IO action that, when executed, gives you an IO action
11:53:15 <merijn> atriq: Kind signatures might be a bit over his/her head if monads are still unfamiliar
11:53:19 <atriq> Which you can execute
11:53:27 <merijn> Paprikachu: It makes sense, but it's not what you wanted to do :)
11:53:28 <Paprikachu> why would i need such a thing?
11:53:35 <atriq> You wouldn't
11:53:38 <atriq> :t join
11:53:39 <lambdabot> Monad m => m (m a) -> m a
11:53:43 <merijn> atriq: Not true
11:53:47 <atriq> Okay
11:53:52 <ceii> sure you would
11:53:53 <merijn> "IO (IO a)" can be very useful
11:54:12 <ceii> for example, an action which initializes some functionality, and gives ou back another action that uses it
11:54:39 <merijn> Paprikachu: It's essentially a callback, the actual action doesn't get executed until you use something like join/fmap/>>=
11:54:49 <Paprikachu> what if i have a functions that reads some input from the user and returns the IO function entered?
11:55:02 <Paprikachu> would that function be a IO (IO X)) function?
11:55:17 <ceii> yes it would
11:55:17 <merijn> Lemme give you a somewhat simpler example
11:55:26 <merijn> :t map print [1..10]
11:55:28 <lambdabot> [IO ()]
11:55:58 <merijn> Paprikachu: "map print [1..10]" returns a list of actions that print a number, it doesn't actually *print* said numbers
11:56:14 <merijn> You can then later decide to selectively only print a few of them
11:56:53 <merijn> "(map print [1..10]) !! 5" will only return the fifth print action, if you decide to execute it, only that number will get printed
11:57:34 <merijn> Paprikachu: You can try it in ghci, it will print just "6"
11:57:57 <Paprikachu> and to print all numbers, i'd have to use sequence?
11:58:16 <Paprikachu> :t sequence
11:58:17 <lambdabot> Monad m => [m a] -> m [a]
11:58:23 <Sonarpulse> wait, what order does replicate M cons things onto a list?
11:58:30 <parcs`> you'd probably use sequence_
11:58:37 <Paprikachu> :t sequence_
11:58:39 <lambdabot> Monad m => [m a] -> m ()
11:59:01 <Paprikachu> huh
11:59:18 <Sonarpulse> is that at me?
11:59:37 <Sonarpulse> I actually want to return a list so replicateM is what I am looking for
11:59:48 <Paprikachu> :t sequence $ map print [1..10]
11:59:49 <lambdabot> IO [()]
12:00:02 <Paprikachu> :t sequence_ $ map print [1..10]
12:00:04 <lambdabot> IO ()
12:00:18 <Paprikachu> does sequence_ discard the result?
12:02:16 <Sonarpulse> looks like it
12:02:29 * Polarina spilled some coffee while reading the OpenGL package update announcement.
12:02:34 <Paprikachu> @src sequence_
12:02:34 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:03:25 <Sonarpulse> @src mapM
12:03:25 <lambdabot> mapM f as = sequence (map f as)
12:03:58 <Sonarpulse> is MapM guaranteeed not parallel?
12:04:07 <Paprikachu> :t mapM print [1..10]
12:04:08 <lambdabot> IO [()]
12:04:14 <Paprikachu> :t mapM_ print [1..10]
12:04:15 <lambdabot> IO ()
12:04:42 <Paprikachu>  finally understand something
12:05:11 <Sonarpulse> from scheme, I have always thought of map as something you use for parallel only
12:05:59 <Sonarpulse> :t sequence
12:06:00 <lambdabot> Monad m => [m a] -> m [a]
12:06:06 <Sonarpulse> :t replicate
12:06:07 <lambdabot> Int -> a -> [a]
12:06:12 <Botje> map is for applying a function to an entire list
12:06:19 <lispy> Polarina: why is that?
12:06:25 <Botje> the fact that map does not impose an order is indeed very handy for parallellism :)
12:06:41 <Sonarpulse> :t replicateM
12:06:42 <lambdabot> Monad m => Int -> m a -> m [a]
12:06:48 <Botje> Sonarpulse: actually, scheme's map is more like all versions of zipWithN together.
12:07:17 <Botje> since you can do (map (lambda (a b) ...) as bs) === zipWith (\ a b -> ... ) as bs
12:07:17 <Sonarpulse> you mean it is defined recursively?
12:07:36 <Polarina> lispy, all the GLfoo types are now type synonims instead of newtypes. Saves me lots of casting, like everywhere.
12:07:38 <Botje> and if you give it three lists it turns into zipWith3, etc
12:07:47 <lispy> Polarina: yay!
12:08:22 <Polarina> lispy, you have no idea how frustrating it is to actually work with those... :/
12:09:02 <Sonarpulse> well I don't know zipWith but I'll take your word for it
12:09:19 <Sonarpulse> oh, maybe you mean how it supports mapping multiple lists simultaneously?
12:09:24 <lispy> Polarina: I do actually :) I'm the OpenGL maintainer
12:09:28 <Polarina> For example, glClear takse a GLbitfield, but all the relevant macros are GLenum (gl_COLOR_BUFFER_BIT, etc.). That's another required cast there..
12:09:35 <Polarina> lispy, cool. :)
12:10:53 <lispy> It was a nice try at type safety, but experience shows it was not worth it
12:11:21 <Paprikachu> @src return
12:11:22 <lambdabot> Source not found.
12:11:28 <Taneb> @src return []
12:11:28 <lambdabot> Source not found. Where did you learn to type?
12:11:32 <Taneb> @src [] return
12:11:32 <lambdabot> return x    = [x]
12:11:38 <Taneb> @src Maybe return
12:11:38 <lambdabot> return              = Just
12:11:42 <Paprikachu> @src IO return
12:11:42 <lambdabot> return x    = returnIO x
12:11:48 * hackagebot network-data 0.5 - Library for network data structures and their serialization.  http://hackage.haskell.org/package/network-data-0.5 (ThomasDuBuisson)
12:11:58 <DMcGill> so this tutorial has a reference to "ghc-6.10.1/gcc-lib" but that doesn't exist in my Haskell Platform installation. What can I use as an alternative?
12:12:02 <Taneb> @src ((,) w) return
12:12:02 <lambdabot> Source not found. Where did you learn to type?
12:12:10 <Paprikachu> @src returnIO
12:12:10 <lambdabot> Source not found. You untyped fool!
12:12:17 <Taneb> @src (Either e) return
12:12:18 <lambdabot> Source not found. :(
12:12:25 <Polarina> lispy, mhm. Thanks again. :)
12:12:29 <Taneb> > return 10 >> Left ()
12:12:31 <lambdabot>   Left ()
12:12:38 <mzero> DMcGill: really? what is it using ghc-6.10.1/gcc-lib for?
12:12:46 <DMcGill> http://netsuperbrain.com/blog/posts/freeglut-windows-hopengl-hglut/
12:12:50 <lispy> Polarina: you're welcome. I was worried I was the only one that wanted the type synonyms back
12:12:54 <DMcGill> I'm trying to replace my glut with freeglut
12:13:10 <mzero> ah
12:13:13 <mzero> on Windows
12:13:20 <DMcGill> and just finding all instances of glut32.dll and replacing them with the freeglut version isn't working
12:13:23 <lispy> DMcGill: better yet, skip GLUT and go to GLFW-b
12:13:31 <mzero> well, do you have a /c/ghc/ghc-xxx/gcc-lib directory?
12:13:35 <mzero> where xxx is a different version?
12:13:36 <DMcGill> I'd like to use yampa-glut
12:13:42 <Polarina> DMcGill, you can use the DLL from here: http://www.transmissionzero.co.uk/software/freeglut-devel/
12:13:46 <geekosaur> I don't think windows ghc ships with a gcc any more?
12:13:48 <Polarina> DMcGill, put it where the executable is.
12:13:54 <DMcGill> unless yampa is easy to use with glfw-b?
12:14:18 <lispy> geekosaur: it does as of 7.6.1
12:14:34 <Polarina> DMcGill, out of curiosity, why are you using Yampa?
12:14:39 <lispy> DMcGill: probably not.
12:14:58 <DMcGill> I want to make a game in a function style rather than an iterative one
12:15:05 <DMcGill> is there a good alternative?
12:15:07 <sorressean> Would someone mind explaining this? I'm reading "learn you a haskell for great good," b ut it doesn't really bopther to explain the syntax. [x*2 | x <- [1..10]]
12:15:29 <Polarina> DMcGill, take a look at netwire. It's new, but good and simpler.
12:15:55 <lispy> gloss is also nice (but still requires GLUT)
12:16:00 <Iceland_jack> sorressean: [1..10] is the list of numbers from 1 to 10
12:16:09 * sorressean nods.
12:16:18 <sorressean> I think it's the | and <- that threw me off
12:16:18 <Iceland_jack> and it takes every number
12:16:29 <Iceland_jack> calls it x, and multiplies x by 2
12:16:39 <Sonarpulse> ok, I think I have cornered my confusion
12:17:06 <Sonarpulse> in a type like Monad m => m a
12:17:08 <Iceland_jack> sorressean: Yeah, that makes sense
12:17:12 <jrajav> sorressean: Read it as "Make a list from [1..10] where each element x is replaced by x*2
12:17:14 <Sonarpulse> what exactly does m a mean
12:17:31 <Polarina> lispy, to be honest, I could live with GLenum and those still being newtypes, not that it matters to me, but for Floats and Ints, those are the most pain-causing things.
12:17:31 <Iceland_jack> If you're familiar with ‚Äòmap‚Äô then this is the same as: map (*2) [1..10]
12:17:32 <Sonarpulse> I get that what constraints like __ a => od
12:17:40 <Iceland_jack> Just a different style
12:18:01 <Sonarpulse> but does m a return an a? take an a?
12:18:05 <sorressean> Iceland_jack:  naw. haven't gotten that high in math yet. I kind of have an idea of comprehentions from python, that's what I[m working off of.
12:18:29 <Iceland_jack> These are analogous to list comprehensions from Python, yes
12:18:59 <jrajav> sorressean: map is basically saying "apply this function to every element of the list and return the new list that results"
12:19:18 <sorressean> awesome. so that's the <-? it applies the comprehention to the following list?
12:19:40 <sorressean> so instead of a list I could use any sort of function that would return a list.
12:19:43 <Iceland_jack> x <- [1,2,3] means assign x to values 1, 2 and 3
12:19:46 <Iceland_jack> sure
12:20:00 * sorressean nods. and the |?
12:20:09 <DMcGill> think of it as "such that"
12:20:10 <Iceland_jack> It's kind of idiosyncratic in the sense that it's only used in list comphrehensions
12:20:21 <sorressean> ah. gotcha.
12:20:27 <DMcGill> [x | even x]
12:20:40 <lispy> it's also used in patterns
12:20:42 <sorressean> thanks. :)
12:20:45 <DMcGill> [x | x <- [1..10], even x] I mean
12:20:47 <lispy> foo x | even x = x
12:21:50 <sorressean> so it basically means x such that x is any number between 1 and 10. except the *2 is done before the such that, but whatever. closest I can get.
12:22:03 <sorressean> helps me understand it, anyway
12:22:16 <Iceland_jack> Eh I guess you could put it that way
12:22:37 <Iceland_jack> Play around with it using different generating lists
12:22:43 * sorressean nods.
12:23:00 <Iceland_jack> you'll get the hang of it, for example: [ x | x <- list ] equals list
12:23:39 <sorressean> thanks for the help. :)
12:23:47 <Iceland_jack> No problem :) best of luck to you
12:24:05 <sorressean> I think part of my issue is that I've not gotten very far with math. Kind of hoping I can learn more with functional programming.
12:24:58 <Iceland_jack> I'd say that being familiar with abstraction is far more important than being good at mathematics for learning functional programming
12:25:33 <Iceland_jack> But of course a foundation in mathematics does not hurt
12:26:19 <DMcGill> but trying to learn math using functional programming isn't a very good way of going about it imo
12:26:30 <DMcGill> maaaybe you learn some names/laws of some objects
12:26:35 <DMcGill> functors, monoids and so on
12:26:49 * hackagebot gloss-devil 0.2 - Display images in Gloss using libdevil for decoding  http://hackage.haskell.org/package/gloss-devil-0.2 (ThomasDuBuisson)
12:26:51 * sorressean nods.
12:26:54 <DMcGill> and, of course, you get used to abstraction but that's about it
12:27:29 <Iceland_jack> I think DMcGill is right, personally I dislike the amount of emphasis people in certain communities put on learning various lambda calculi and category theory in order to learn the programming languages
12:27:38 <Iceland_jack> But that's me
12:31:23 <hpaste> gertc annotated ‚Äú"me" does not work anymore?‚Äù with ‚Äúfixed but hlint says return is redundant?‚Äù at http://hpaste.org/77255#a77259
12:32:16 <starx> Is there any naming convention for global constants?
12:32:19 <chrisbuchholz> whats the best haskell ctags generator out there?
12:32:42 <sorressean> hrm. is there a way to chain if statements together? like nested statements? it's sort of hard since everything requires an else.
12:33:01 <neutrino_> hi
12:33:04 <gertc> chrisbuchholz: ghc-mod i think
12:33:15 <neutrino_> how can i use a variable field name when updating a record?
12:33:38 <neutrino_> i want to do something like myRecord { field = val } but "field" can change
12:33:48 <neutrino_> it's a parameter to the function
12:35:16 <Philonous> neutrino_:  You can't instead pass a function
12:35:29 <Iceland_jack> sorressean: What do you want to do
12:35:30 <Iceland_jack> ?
12:35:55 <pordan30> sorressean: cond :: Bool -> a -> a -> a and dnoc :: a -> a -> Bool -> a are useful functions
12:35:56 <sorressean> Iceland_jack:  ever seen FizzBuzz? I was kind of trying to do that with comprehensions.
12:36:28 <sorressean> pordan30:  uh. what?
12:36:35 <Philonous> neutrino_:  For example in "data Foo = Foo {bar :: Bar}" you would pass "(\f b -> f{bar = b})"
12:36:49 <DMcGill> sorressean: use a helper function instead of trying to do everything inside the comprehension
12:36:59 <neutrino_> Philonous: i can't make sense out of that the second line
12:37:10 <neutrino_> can you explain please
12:37:16 <Philonous> neutrino_:  I missed a comma in the first message, I meant "you can't, pass a function instead"
12:37:31 <DMcGill> fizzbuzz x | x `mod` 3 == 0 = ...
12:37:36 <DMcGill>          | x `mod` 5 == 0 = ...
12:37:40 <neutrino_> yeah
12:37:44 <sorressean> Iceland_jack:  so something like [if x `mod` 3 && x `mod` 5 then "fizz buzz"... but I still have to check for mod3 and mod5 separately.
12:37:46 <neutrino_> the second line still doesn't make sense
12:38:12 <Iceland_jack> sorressean: look at DMcGill's suggestion
12:38:19 <neutrino_> my issue is i sometimes need to update one field, sometimes another, and the fact of what field my function updates needs to be passed by parameter
12:38:19 * sorressean nods.
12:38:36 <neutrino_> is that what you understood?
12:38:42 <hiptobecubic> i saw a really clever fizzbuzz in here once, but now i can't remember it
12:39:08 <Philonous> neutrino_:  Yes.
12:39:10 <DMcGill> neutrino_: look at http://hackage.haskell.org/package/data-lens
12:39:24 <Iceland_jack> sorressean: http://www.haskell.org/haskellwiki/Haskell_Quiz/FizzBuzz/Solution_Ninju here's a solution
12:39:27 <neutrino_> Philonous: ok so how would you do that?
12:39:35 <neutrino_> i didn't understand your code with \f in it
12:39:41 <Sonarpulse> look that this:
12:39:47 <Sonarpulse> :t getLF a b = (getLazyByteString b) : a
12:39:48 <lambdabot> parse error on input `='
12:39:58 <sorressean> Iceland_jack:  o, sweet, thanks. I'll copy it and look at it when I finished mine to see how they compare. I have an idea for how to do it.
12:40:23 <DMcGill> :t \b a -> (getLazyByteString b) : a
12:40:25 <lambdabot> Not in scope: `getLazyByteString'
12:40:32 <Sonarpulse> thanks
12:40:32 <Iceland_jack> Ok :) sounds good, there is also a version using a list comphrehension
12:40:39 <Sonarpulse> my erc history borke
12:40:45 <ion> > let f modulo text num = text <$ guard (num `mod` modulo == 0) in map (\n -> maybe (show n) (f 3 "fizz" n `mappend` f 5 "buzz" n)) [0..]
12:40:46 <lambdabot>   No instance for (Control.Monad.MonadPlus ((->) a0))
12:40:46 <lambdabot>    arising from a use o...
12:40:50 <chrisbuchholz> gertc: how do you generate a tags file with ghc-mod?
12:40:59 <Taneb> Is there a channel for Haddock help?
12:41:11 <Philonous> neutrino_:  So, instead of "update s fieldname = s{<fieldname> = bar}" you would take an accessor function like this: "update s accessor = accessor s bar" where "accessor s b = s{fieldname = b}"
12:41:51 <Sonarpulse> well the problem is I get ... -> [get L.Bytestring] when I think i want ... -> get [L.Bytestring]
12:41:51 * hackagebot JuicyPixels-repa 0.5 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.5 (ThomasDuBuisson)
12:42:22 <neutrino_> Philonous: but then i have to write a separate "accessor" for each field i want to update, right?
12:42:45 <Philonous> neutrino_:  Unfortunately that is true. But various lens packages automate that part for you with some template haskell
12:43:15 <neutrino_> wait but i thought the field names in the record were actually functions themselves
12:43:16 <ion> > let f modulo text num = text <$ guard (num `mod` modulo == 0) in map (\n -> fromMaybe (show n) (f 3 "fizz" n `mappend` f 5 "buzz" n)) [0..]
12:43:17 <lambdabot>   ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fi...
12:43:23 <neutrino_> aren't they the accessors i want?
12:44:16 <Philonous> neutrino_:  No, they only return the value from the field, you can't use them to update it
12:44:26 <neutrino_> ok
12:44:42 <Sonarpulse> @src foldM
12:44:42 <lambdabot> foldM _ a []     = return a
12:44:42 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
12:44:49 <merijn> neutrino_: <mandatory lens plug>
12:44:52 <Philonous> neutrino_:  It's such a common problem that there is a bunch of packages to solve it
12:45:11 <merijn> neutrino_: Lenses are basically composable getter/setter combinations
12:45:24 <neutrino_> yeah maybe i should look into lenses
12:45:31 <neutrino_> what do you guys suggest?
12:45:47 <ion> @hackage lens
12:45:48 <lambdabot> http://hackage.haskell.org/package/lens
12:45:54 <Philonous> neutrino_:  http://hackage.haskell.org/package/lens is the latest and (presumably) greatest
12:45:59 <neutrino_> ok
12:46:29 <neutrino_> thanks, i'll check it out
12:48:14 <Sonarpulse> can I use liftM to go from [m a] to m [a] ?
12:48:23 <gertc> chrisbuchholz: you are right what about http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/ghci-commands.html
12:48:27 <ion> @type sequence -- sonarpulse
12:48:29 <lambdabot> Monad m => [m a] -> m [a]
12:48:51 <Sonarpulse> shit, so it was seqence all along i needed
12:49:15 <Sonarpulse> hopefully I will be able to someday understand all you guy's answers when you first say them
12:51:08 <starx> Is there something like doc strings in haskell
12:51:13 <Sonarpulse> uh on, now foldM expects m [m a]
12:51:47 <Philonous> @type foldr (liftM (:)) $ return []
12:51:48 <lambdabot> [([a1] -> [a1]) -> a1] -> [a1] -> [a1]
12:51:56 <Philonous> @type foldr (liftM2 (:)) $ return []
12:51:57 <lambdabot> Monad m => [m a1] -> m [a1]
12:51:59 <chrisbuchholz> gertc: seems to only be available via the repl, not via a single command, right?
12:52:39 <gertc> dont know never tried otherwise :)
12:52:51 <chrisbuchholz> gertc: all right ;)
12:54:43 <tomeo> http://pastie.org/5183899 I don't understand why this wont compile "parse error on input `='" on line 3. Could someone please have a look?
12:55:24 <geekosaur> not sure why you expect that to work
12:56:34 <Sonarpulse> is there an unsequence?
12:56:46 <Ralith> @where lyah
12:56:46 <lambdabot> http://www.learnyouahaskell.com/
12:56:48 <Ralith> tomeo: ^
12:56:54 <gertc> chrisbuchholz: maybe ghc -e :ctags
12:57:01 <starx> how can I convert Double to Int ?
12:57:05 <Sonarpulse> I need to cons m a onto m [a]
12:57:26 <Philonous> @hoogle Double -> Int
12:57:26 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
12:57:26 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
12:57:26 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
12:57:29 <tomeo> Ralith: I already have a book. I understood it like this would work
12:57:46 <Ralith> tomeo: perhaps it is the wrong book for you, then!
12:57:53 <merijn> Sonarpulse: You're probably looking for liftM2
12:57:57 <merijn> :t liftM2
12:57:59 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
12:57:59 <Philonous> starx:  ceiling, floor, round take your pic
12:58:03 <merijn> :t liftM2 (:)
12:58:04 <lambdabot> Monad m => m a1 -> m [a1] -> m [a1]
12:58:17 <ion> > let fizzbuzz = fromMaybe <$> show <*> mconcat [f "fizz" 3, f "buzz" 5, f "bam" 7]; f str m n = str <$ guard (n `mod` m == 0) in (unwords . map fizzbuzz) [1..]
12:58:18 <Philonous> pick*
12:58:19 <lambdabot>   "1 2 fizz 4 buzz fizz bam 8 fizz buzz 11 fizz 13 bam fizzbuzz 16 17 fizz 19...
12:58:20 <starx> Thanks
12:58:27 <Sonarpulse> well the basic problem is I need to fold a list into a new list
12:58:53 <Sonarpulse> I think I should actually used foldl and not foldM
12:58:53 <tomeo> Ralith: maybe, but could you please point out what is so wrong about this? Im just trying to give my match function a base case
12:59:21 <Sonarpulse> I think I just need to liftM [] or seomthing
13:00:00 <Ralith> tomeo: you are trying to put a function declaration inside a do expression; that is not where function declarations go.
13:00:47 <koala_man> how can I open a module in ghci and use the non-exported functions interactively?
13:00:52 <tomeo> thanks a lot Ralith
13:02:41 <rhodesd> tomeo: this works, http://pastie.org/5183986 - but it's not pretty.
13:03:25 <tomeo> rhodesd: oh, I have to actually write out the "Just" in front of []?
13:03:45 <geekosaur> a list is not a Maybe
13:04:03 <rhodesd> or Nothing, it needs a Constructor out front.
13:04:35 <S11001001> :t pure :: a -> Maybe a
13:04:36 <Philonous> tomeo:  Nothing != Just []
13:04:36 <lambdabot> a -> Maybe a
13:04:48 <tomeo> I know Philonous
13:04:58 <tomeo> but thanks
13:06:51 <DMcGill> in ghci
13:07:03 <DMcGill> how can I do something like "import Prelude hiding ((.).id)"?
13:07:52 <merijn> DMcGill: "import Prelude hiding ((.), id)" :)
13:08:17 <DMcGill> :D
13:08:23 <Iceland_jack> Is this
13:08:25 <Iceland_jack> a joke to you??
13:08:45 <DMcGill> I hadn't realise that full import syntax was now in ghci
13:08:55 <merijn> DMcGill: oh, ghci
13:09:17 <DMcGill> it works in ghci btw - :i (.) shows only one instance defined from Control.Category
13:09:19 <merijn> Didn't see that, but it still works :p
13:09:25 <typoclass> DMcGill: yeah it's somewhat new. i think ghc versions from last year didn't have it
13:11:55 <gertc> can i just delete the return line in a `do a<- something ;b <- something; return b` statement?
13:12:01 <Botje> yep.
13:12:03 <geekosaur> no
13:12:06 <DMcGill> also delete the "b <- "
13:12:09 <geekosaur> ^^
13:12:15 <gertc> aha
13:12:20 <gertc> thx
13:12:21 <DMcGill> do {a <- something; something}
13:12:26 <sipa> that'd be equivalent to a >> b
13:12:33 <gertc> thx
13:12:34 <geekosaur> return is not a statement, it is a function with a purpose; the "x <- ...; return x' that can be reduced to just '...'
13:12:52 <geekosaur> but 'return x' by itself is different from 'x'
13:12:53 <DMcGill> the result of a do-block is the last statement in it
13:13:29 <DMcGill> which needs to be a value in the monad
13:13:46 <DMcGill> hence why return is often used - it's a function that puts something in said monad
13:15:50 <Sonarpulse> so while map can be parrallelized, mapM is strictly sequential?
13:16:02 <Sonarpulse> because mapM = map . sequence ?
13:16:33 <DMcGill> Sonarpulse: I believe so. The monad ensure that the operations happen in order
13:17:13 <Sonarpulse> That is good for me then, do you know how map monads in parallell then?
13:17:33 <Sonarpulse> I don't need it but mapM serialness begs the question
13:17:45 <DMcGill> well some monads need order
13:17:53 <DMcGill> think of using MVars
13:18:20 <DMcGill> {x <- get mvar; put mvar (x+1)} can't really be parallelised
13:18:28 <S11001001> Sonarpulse: it's pretty complicated; only general statement is that sequenceA has better sharing properties
13:18:35 <Sonarpulse> ok
13:18:41 <Sonarpulse> well back to the task at hand
13:19:20 <donri> mm_freak: the example for OverloadedStrings uses no string literals (netwire)!
13:19:30 <Sonarpulse> I am having the problem that the impartive nature of do syntax makes it hard to examine the type variables insides
13:20:21 <DMcGill> what do you mean? The best way to real with do notation is to make your functions elsewhere and just call them inside the notation
13:20:30 <DMcGill> that way as many functions as possible are pure
13:21:12 <Sonarpulse> I think I have done that so far
13:21:26 <twmb> If I am understanding it correctly, the "let in" binding is to define a temporary function seen only by that local scope?
13:21:52 <DMcGill> yes
13:21:58 <Sonarpulse> I guess, when I return the resalt of calling a data constructor,
13:22:18 <Sonarpulse> what are the types that are passed to the data constructor?
13:22:20 <typoclass> twmb: yes, with "let x = 123 in ...", the x will only be seen in of "..." and nowhere else
13:22:26 <Sonarpulse> so like
13:22:42 <DMcGill> well, that's not quite true typoclass - the x will also be seen inside the "123"
13:22:57 <typoclass> DMcGill: er right, sure 8-/
13:22:59 <DMcGill> so "let x = 1:x in ..." is perfectly valid
13:23:14 <Sonarpulse> I tried to do \x y z -> return("constructor" x y z)
13:23:17 <twmb> wut
13:23:20 <typoclass> yes, as is "let y = 2*x ; x = 123 in ..."
13:23:36 <twmb> that makes more sense
13:23:59 <Sonarpulse> but that didn't work because
13:24:09 <Sonarpulse> I never specified a type of monad
13:24:28 <neutrino_> hey guys i have a question about lens
13:24:29 <neutrino_> https://github.com/ekmett/lens/wiki/Examples
13:24:39 <DMcGill> Sonarpulse: we could give you much more specific help if you post your code on hpaste :)
13:24:39 <Taneb> Shoot
13:24:42 <DMcGill> @where hpaste
13:24:42 <lambdabot> http://hpaste.org/
13:24:44 <neutrino_> i only see code for looking up the nth element of a data structure
13:24:45 <typoclass> twmb: if you have multiple names you're defining (as i did with y and x), then they can see each other. a more clever thing is that x can even refer to itself (as DMcGill did)
13:24:54 <Sonarpulse> sure, I'll do that again
13:24:55 <neutrino_> how can i have data with keywords?
13:25:01 <neutrino_> like a record, hash, etc
13:25:32 <Taneb> neutrino_, http://hackage.haskell.org/packages/archive/lens/3.1/doc/html/Control-Lens-IndexedLens.html#g:2
13:25:44 <hpaste> Sonarpulse pasted ‚ÄúCnCMix‚Äù at http://hpaste.org/77260
13:25:51 <Taneb> neutrino_, the At class may be what you want
13:25:53 <typoclass> neutrino_: there's several ways, here's one:
13:25:54 <twmb> typoclass: is that basically like redefining x right then and there, just like "x = x + 1;" in any other language (so, if x were [2, 3], in that let it would then become [1, 2, 3] for the "in" part?)
13:26:02 <typoclass> > lookup "mouse" [("dog", 42), ("cat", 37)]
13:26:03 <lambdabot>   Nothing
13:26:06 <typoclass> > lookup "cat" [("dog", 42), ("cat", 37)]
13:26:08 <lambdabot>   Just 37
13:26:42 <typoclass> > let x = 1:x in x -- twmb: try it :-)
13:26:43 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:26:58 <DMcGill> Sonarpulse: which bit is the problem?
13:27:03 <twmb> man
13:27:05 <twmb> screw that
13:27:08 <typoclass> ... in other words, it's an infinite list of ones. (x is not being redefined or changed)
13:27:10 <twmb> I can't stop the ghci in windows
13:27:15 <DMcGill> Also, check the errors/warnings hpaste has given you
13:27:18 <typoclass> twmb: ctrl-c ?
13:27:22 <Sonarpulse> well it first complains with sizes
13:27:26 <twmb> doesn't stop it
13:27:26 <Iceland_jack> > take 5 (fix (1:))
13:27:27 <Sonarpulse> but I think i actually got it
13:27:28 <lambdabot>   [1,1,1,1,1]
13:28:10 <Sonarpulse> I inlined sizes by doing
13:28:15 <startling> how would I compose a Simple Lens p l and a Simple Lens l l to get a Simple Lens p p ?
13:28:21 <Sonarpulse> map (fromIntegral . size) entries
13:28:28 <Sonarpulse> and the removed some of the commented out stuff
13:28:34 <Sonarpulse> and it works!
13:28:36 <neutrino_> typoclass / Taneb ok but i can also update them, right?
13:28:43 <Taneb> Yes
13:28:54 <parcs`> startling: you mean l p?
13:28:54 <twmb> so typoclass the way I see it now is that it is recursively defining it as 1:x, which x is 1:x .... etc?
13:29:12 <startling> parcs`, no, I mean p p
13:29:22 <typoclass> twmb: sorry, i could have sworn ctrl-c worked in windows :-( if you want to be sure in the future, you can do "take 100 $ ..."
13:29:51 <lispy> typoclass: you have to use ghcii.sh to be able to ctrl-c in ghci (wait, is that what you're talking about?)
13:29:55 <parcs`> startling: Simple Lens p p should be id
13:30:16 <typoclass> lispy: i have not much clue about windows, but suppose he printed [1..] in ghci?
13:30:31 <lispy> then I hope he ran ghcii.sh
13:30:34 <Taneb> neutrino_, set (at "foo") (Just "Magic") (Map.fromList []) = fromList [("foo","Magic")]
13:30:37 <startling> parcs`, not necessarily?
13:31:18 <EvanR7> control Z in windows
13:31:24 <EvanR7> maybe
13:31:25 <lispy> typoclass: IIRC, ctrl-c in windows doesn't generate the normal sigint so ghcii.sh translates whatever ctrl-c does generate into sigint
13:31:43 <startling> parcs`: like, I could have tail fn (a:b) = (a:) <$> fn b
13:31:47 <DMcGill> Polarina, is there a guide to using netwire with OpenGL or GLFW-b somewhere?
13:31:48 <startling> :t _tail
13:31:50 <lambdabot>     Not in scope: `_tail'
13:31:50 <lambdabot>     Perhaps you meant one of these:
13:31:50 <lambdabot>       `tail' (imported from Data.List),
13:32:01 <typoclass> neutrino_: yes, although that is done in the normal haskell way, which is the update function gives back a new list with the one element added (or changed)
13:32:03 <merijn> twmb: I guess you'll have to kill it from the task manager?
13:32:16 <EvanR7> twmb: try control Z
13:32:33 <twmb> merijn: yeah I found that out yesterday when I exited the console 4 times and then found my laptop running slower
13:32:33 <neutrino_> yeah
13:32:37 <seliopou> Is there any, using generics, to transform one type into another with in a ADT?
13:32:40 <Sonarpulse> yeah! I have all my gets and puts written!
13:32:47 <typoclass> twmb: have you tried ctrl-break?
13:32:54 <seliopou> of course, I'm imagining a situation in which a functor will not suffice
13:32:54 <neutrino_> is there no better way than "set" or .~?
13:32:54 <twmb> EvanR7: C, Z, D don't work
13:33:01 <twmb> typoclass: break?
13:33:07 <fryguybob> twmb: Just kill it with task manager.
13:33:07 <EvanR7> pause|break key
13:33:33 <startling> > (tail' fn (a:b) = (a:) <$> fn b) :: Simple Lens [b] [b]
13:33:34 <lambdabot>   <hint>:1:17: parse error on input `='
13:33:37 <twmb> next time I accidentally infinitely loop
13:33:42 <startling> er
13:33:48 <merijn> twmb: You might want to figure out how Windows does task interruption in the command line, I suspect not many people here know, unfortunately
13:34:03 <startling> > :t (\fn (a:b) = (a:) <$> fn b) :: Simple Lens [b] [b]
13:34:04 <lambdabot>   <hint>:1:1: parse error on input `:'
13:34:06 <startling> bah
13:34:11 <twmb> I use cygwin
13:34:12 <startling> :t (\fn (a:b) = (a:) <$> fn b) :: Simple Lens [b] [b]
13:34:13 <Sonarpulse> so within a do loop, each line is serialized
13:34:13 <neutrino_> i'm looking for something like ((), "bar") <thing i'm looking for> _1 <more of the thing> "foo", and this line should return ("foo", "bar").
13:34:13 <lambdabot> parse error on input `='
13:34:16 <edwardk> :t Data.List.Lens._tail
13:34:18 <lambdabot> Functor f => ([a] -> f [a]) -> [a] -> f [a]
13:34:21 <startling> well, you get the point
13:34:24 <startling> edwardk: ah
13:34:24 <Sonarpulse> but within each line things are evaluated as normal?
13:34:25 <twmb> It's got some problems but it's what I can use for now
13:34:28 <fryguybob> twmb: I would recommend not using cygwin for ghci.
13:34:28 <Sonarpulse> * do syntax block
13:34:42 <twmb> fryguybob: the lack of history is the worst part
13:34:45 <startling> edwardk: I was trying to show parcs` that a Simple Lens p p is not necessarily id.
13:34:45 <merijn> Sonarpulse: It's much simpler even
13:34:49 <neutrino_> edwardk: wake up :p
13:34:53 <merijn> Sonarpulse: Are you familiar with >>= and >> ?
13:35:01 <Sonarpulse> a bit
13:35:11 <edwardk> neutrino_: ?
13:35:14 <merijn> Sonarpulse: do notation is very simple syntactic sugar for those two
13:35:15 <Sonarpulse> one does assignement, the other simply passes state?
13:35:18 * edwardk looks up
13:35:20 <startling> edwardk, speaking of which, how would I compose a Simple Lens p l and a Simple Lens l l to get a Simle Lens p p?
13:35:22 <neutrino_> edwardk: hi :)
13:35:27 <parcs`> startling: ah, right
13:35:30 <merijn> @undo do { x <- foo; bar f; baz }
13:35:30 <lambdabot> foo >>= \ x -> bar f >> baz
13:35:35 <Sonarpulse> so between each of those  things are normal?
13:35:36 <edwardk> startling: magic?
13:35:41 <EvanR7> Sonarpulse: its not assignment, >>= is the one that passes something
13:35:51 <rwbarton> :t _head
13:35:52 <lambdabot>     Not in scope: `_head'
13:35:52 <lambdabot>     Perhaps you meant one of these:
13:35:53 <lambdabot>       `head' (imported from Data.List),
13:36:00 <rwbarton> :t _1
13:36:01 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
13:36:02 <Sonarpulse> ok
13:36:08 <edwardk> > ((), "bar") % _1 .~ "foo"
13:36:10 <lambdabot>   ("foo","bar")
13:36:12 <Sonarpulse> I think I might just have gotten them backwards
13:36:14 <edwardk> that?
13:36:30 <neutrino_> edwardk: i knew i could count on you :)
13:36:30 <rwbarton> i'm trying to remember which way the parameters to Simple Lens go
13:36:34 <edwardk> :t (%)
13:36:36 <lambdabot> a -> (a -> b) -> b
13:36:38 <merijn> Sonarpulse: Basically "x <- foo" introduces a new lambda with variable x and uses >>= to pass the initial monadic value to that lambda. ; are just interpreted as >>
13:36:48 <edwardk> rwbarton: pretend its a function, whole -> part
13:36:59 <rwbarton> okay good
13:37:02 <merijn> Sonarpulse: It can help to first write code explicitly using >>= and >> and then translate it to do notation later, to get a feeling for what's going on
13:37:16 <fryguybob> twmb: cmd and Powershell both have history.  ghci has its own history.
13:37:54 <Sonarpulse> ok cool
13:37:58 <Sonarpulse> I should probably do that
13:38:09 <merijn> Sonarpulse: Because there's really no magic there, do notation is just a nicer way to write code using lots of >>= and >>
13:38:10 <Sonarpulse> I get the idea of keeping state in tupplets
13:38:24 <Sonarpulse> or whatever data structure monads use
13:38:39 <merijn> But any code written using do can also be written without it
13:39:01 <Sonarpulse> purely functional...
13:39:02 <merijn> Sonarpulse: If you want to keep state you might also want to check out the State monad?
13:39:10 <startling> edwardk, I'm pretty sure you can do it in the general case, gimme a second to write it out
13:39:15 <edwardk> startling: what would the l p, p p  -> p p lens do?
13:39:16 <Sonarpulse> now i don't, but eventually sure
13:39:27 <parcs`> startling: how would the setter and getter of that Lens behave?
13:39:35 <startling> edwardk: errrr, I mean l p, p p -> l l, sorry
13:39:50 <edwardk> how are you getting back down to an l?
13:39:57 <neutrino_> edwardk: can i add that to the "examples" wiki page for lens?
13:39:59 <edwardk> you'll fail a law O
13:40:03 <edwardk> er =P
13:40:04 <merijn> Sonarpulse: it basically lets you pass state from function to function without requiring the state to explicitly be an input/output of all your functions :)
13:40:05 <edwardk> neutrino_: sure
13:40:21 <startling> edwardk, hmm, I guess the first one needs to be an isomorphism?
13:40:29 <edwardk> startling: now its possible
13:40:41 <Sonarpulse> isn't that the basic idea for monads in general?
13:40:52 <edwardk> foo . bar . from foo
13:40:56 <sorressean> anyone mind looking at this? it errors on the first line, says it expects an =. http://pastebin.com/sYcyim7H
13:40:58 <EvanR7> Sonarpulse: no, monads in general arent about state, or about any particular data structure
13:41:16 <startling> :t f . b . from f
13:41:18 <lambdabot>     Couldn't match expected type `a1 -> a0' with actual type `Expr'
13:41:18 <lambdabot>     In the first argument of `(.)', namely `b'
13:41:18 <EvanR7> or imperative progrmaming, despite the do notation
13:41:18 <lambdabot>     In the second argument of `(.)', namely `b . from f'
13:41:32 <Sonarpulse> interesting
13:41:42 <startling> Sonarpulse, have you dissected Maybe?
13:42:05 <EvanR7> > Just 3 >> Just 19
13:42:07 <lambdabot>   Just 19
13:42:12 <EvanR7> > Nothing >> Just 19
13:42:13 <lambdabot>   Nothing
13:42:14 <edwardk> :t \f b -> f . b . from f
13:42:16 <lambdabot>     Couldn't match expected type `Isomorphism a0 b0'
13:42:16 <lambdabot>                 with actual type `a1 -> b1'
13:42:17 <lambdabot>     In the first argument of `from', namely `f'
13:42:26 <Sonarpulse> no, the main thing I did was read http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
13:42:30 <edwardk> you need a higher ran type on that one to make it type check
13:42:40 <startling> edwardk: ah
13:42:46 <startling> Sonarpulse, take a look at
13:42:48 <startling> @src Maybe
13:42:48 <lambdabot> data Maybe a = Nothing | Just a
13:42:54 <startling> @src Maybe Monad
13:42:54 <lambdabot> Source not found. You speak an infinite deal of nothing
13:43:06 <startling> hmm I forget the way to do it.
13:43:09 <edwardk> @type via
13:43:11 <lambdabot> Isomorphic k => Isomorphism a b -> k a b
13:43:18 <edwardk> :t \f b -> via f . b . from f
13:43:20 <lambdabot> (Functor (k b), Isomorphic k) => Isomorphism a b -> (a -> a) -> k b b
13:43:24 <edwardk> there ya go ;)
13:43:34 <startling> edwardk: excellent! thanks
13:43:46 <edwardk> without the 'via' you need the rank 2 type
13:44:17 <parcs`> is that really a lens though
13:44:44 <edwardk> parcs: lenses are functions from values of the form a -> f b    to values of the form    c -> f d
13:44:57 <edwardk> so instantiate the a and b with (x -> f y)     in that type
13:45:06 <edwardk> . via and from aren't lens specific
13:45:27 <rwbarton> you should be able to wrap it in ReifiedLens to check, right
13:45:44 <rwbarton> that it has the right form at least
13:45:51 <edwardk> :t \f b -> cloneLens (via f . b . from f)
13:45:53 <lambdabot> Functor f => Isomorphism a1 (a -> Control.Lens.Internal.Context a b b) -> (a1 -> a1) -> (a -> f b) -> a -> f b
13:46:09 <startling> oh, that's cool. it fails on non-lenses?
13:46:15 <edwardk> cloneLens?
13:46:17 <edwardk> yeah
13:46:19 <startling> yeah.
13:46:25 <parcs`> :t cloneLens
13:47:06 <parcs`> edwardk: but then the type of the isomorphism will be 'Isomorphism (x -> f y) (x -> f y)'
13:47:22 <edwardk> parcs: that is correct
13:47:29 <edwardk> that is what Iso looks like ;)
13:47:47 <startling> edwardk: what's the best way to write an isomorphism?
13:47:58 <pandragon> Hi
13:48:11 <edwardk> type Iso s t a b = forall k f. (Isomorphic k, Functor f) => k (a -> f b) (s -> f t)
13:48:56 <edwardk> when you it as a lens it chooses k to be (->)
13:49:00 <Taneb> Is there any point of Iso s t a b where a and b are different, and s and t are different
13:49:04 <parcs`> and that's a lens isomorphism?
13:49:30 <edwardk> parcs: i would rather say it is an isomorphism lens. a lens isomorphism would entail something different to me
13:49:39 <mami__> heyho
13:49:43 <Taneb> Hey
13:49:43 <edwardk> :t _identity
13:49:45 <lambdabot>     Not in scope: `_identity'
13:49:45 <lambdabot>     Perhaps you meant `identity' (imported from Control.Lens)
13:49:49 <edwardk> :t identity
13:50:00 <edwardk> :t Control.Lens.Iso.identity
13:50:02 <mami__> just started learning haskell with learn you a haskell
13:50:02 <lambdabot> (Functor f, Isomorphic k) => k (Identity a -> f (Identity b)) (a -> f b)
13:50:08 <mami__> why do i have to do:
13:50:09 <Taneb> Lambdabot has lens now?
13:50:09 <mami__> ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
13:50:11 <edwardk> that is an iso with changing types
13:50:12 <mami__> ghci> [ [ x | x <- xs, even x ] | xs <- xxs]
13:50:14 <mami__> ghci> let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
13:50:29 <startling> Taneb: welcome to the future!
13:50:30 <mami__> ghci> [ [ x | x <- xss, even x ]] though is invalid
13:50:42 <edwardk> Taneb: you should always be _able_ to instantiate your lens or iso with a = b, s = t, if you can't its a good sign its not a lens
13:50:58 <parcs`> oh, okay. very neat
13:50:58 <merijn> mami__: Oh, rather simple. What's the type of element in xxs?
13:51:10 <Taneb> edwardk, can you give an example of when you can make it so a /= b and s /= t
13:51:16 <Taneb> But is still useful and makes sense and stuff?
13:51:23 <edwardk> Taneb: the identity iso i just linked. =)
13:51:28 <edwardk> :t _const
13:51:38 <edwardk> :t Control.Lens.Iso._const
13:51:38 <mami__> merijn: its integers
13:51:40 <lambdabot> (Functor f, Isomorphic k) => k (Const a c -> f (Const b d)) (a -> f b)
13:51:53 <edwardk> > 5^._const
13:51:55 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.Const s0 c0))
13:51:55 <lambdabot>    arisin...
13:51:57 * hackagebot idiii 0.1.3.3 - ID3v2 (tagging standard for MP3 files) library  http://hackage.haskell.org/package/idiii-0.1.3.3 (BartonMassey)
13:52:07 <mami__> but since i project xxs to xs it should come out as the same right?
13:52:08 <edwardk> > 5^._const.from _const
13:52:10 <startling> Nisstyre: hey ^^
13:52:11 <lambdabot>   5
13:52:17 <merijn> mami__: No, the type of xs is integers, the type of xxs is [[Int]]. i.e. it's a list of lists of integers
13:52:30 <mami__> ah
13:52:33 <startling> Nisstyre: oh, you're already using that, aren't you
13:52:33 <merijn> eh, type of xs is list of integer
13:52:35 <Taneb> edwardk, okay, that makes sense
13:52:46 <edwardk> :t iso
13:52:53 <mami__> merijn: so i project one list from xxs to xs after another?
13:52:55 <edwardk> :t Control.Lens.Iso.iso
13:52:57 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (a -> s) -> k (a -> f a) (s -> f s)
13:52:58 <edwardk> :t Control.Lens.Iso.isos
13:53:00 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (a -> s) -> (t -> b) -> (b -> t) -> k (a -> f b) (s -> f t)
13:53:01 <merijn> mami__: So the [x | x <- xxs, even x] fails because it tries to apply even to [Int]
13:53:13 <edwardk> in general you just repeat yourself when writing isos
13:53:30 <merijn> mami__: Yes, list comprehensions just unwrap the outermost list
13:53:35 <mami__> aha
13:53:37 <mami__> good
13:53:38 <mami__> thanks
13:53:49 <ivanm> I'm trying to build ghc 7.6.1, but I get an error "make[1]: *** No rule to make target `inplace/bin/mkUserGuidePart', needed by `docs/users_guide/users_guide.xml'.  Stop."
13:53:55 <merijn> mami__: Which is why the double one works, you first unwrap the outer list, then the inner
13:53:55 <ivanm> does anyone have any ideas what's going on?
13:53:56 <shachaf> > let xss = [[1,2,3],[4,5,6]] in [x | xs <- xss, x <- xs, even x] -- mami__
13:53:57 <lambdabot>   [2,4,6]
13:54:17 <parcs`> that is very cool
13:54:19 <shachaf> mami__: But with that said, don't worry too much about list comprehensions. They're not a very important part of Haskell.
13:54:31 <merijn> mami__: Alternatively, you could use "filter even" and map to achieve the same result
13:54:50 <merijn> :t concat . map (filter even)
13:54:51 <lambdabot> Integral a => [[a]] -> [a]
13:54:58 <mcstar> filter even . concat
13:55:18 <merijn> > concat (map (filter even) [1..20])
13:55:20 <lambdabot>   No instances for (GHC.Enum.Enum [a0], GHC.Num.Num [a0])
13:55:20 <lambdabot>    arising from a u...
13:55:26 <merijn> heh
13:55:32 <merijn> oh, duh
13:55:53 <merijn> > concat (map (filter even) [[1..20], [1,3..10]])
13:55:54 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
13:56:25 <Sonarpulse> In scheme, I need to use a nested function to encapsulate a recursive function that always takes the same initial value as one of it's arguements
13:56:43 <Sonarpulse> can I use parameter-polymorphism in haskell instead?
13:56:46 <merijn> mami__: filter filters (obviously :)) elements out of a list, "map" applies the filter to every list in a list of lists. concat then fuses all the lists together
13:56:52 <hpc> you would use currying
13:57:20 <hpc> > let f = (/ 2) in (f 5, f 10)
13:57:22 <lambdabot>   (2.5,5.0)
13:57:30 <mcstar> merijn: you dont like my solution?
13:57:37 <shachaf> > over traverse (filter even) [[1..20],[1,3..10]]^.folded
13:57:38 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
13:57:43 <merijn> hpc: I mcstar Oh, guess that works too
13:57:49 <mami__> merijn: cool, will try
13:57:50 <hpc> > let f = intersperse ',' in (f "hello", f "goodbye")
13:57:51 <lambdabot>   ("h,e,l,l,o","g,o,o,d,b,y,e")
13:57:58 <hpc> :t intersperse
13:57:59 <lambdabot> a -> [a] -> [a]
13:58:02 <merijn> shachaf: I get the distinct impression the addition of Control.Lens will not make things clearer for newbies ;)
13:58:10 <Sonarpulse> hpc: I use curring to make the "wrapper function"
13:58:13 <edwardk> merijn: =P
13:58:17 <merijn> mami__: mcstar's proposal of "filter even . concat" is also nice :)
13:58:24 <Sonarpulse> I guess you are saying make the real function nested with let?
13:58:30 <merijn> mami__: That first fuses all lists together and *then* filters the result
13:58:37 <hpc> er strictly speaking, it's partial application
13:58:38 <merijn> Sonarpulse: Or where
13:58:42 <edwardk> over both (intersperse ',') ("hello","goodbye")
13:58:44 <edwardk> > over both (intersperse ',') ("hello","goodbye")
13:58:44 <Sonarpulse> (right now I am just poluting the name space  with it)
13:58:46 <lambdabot>   ("h,e,l,l,o","g,o,o,d,b,y,e")
13:59:02 <hpc> Sonarpulse: you wouldn't "make a nested function" as such, you would just not supply every parameter
13:59:14 <Sonarpulse> ok, if I will need a let/where, how bad is polluting the name space when I  will only export something anyways
13:59:17 <merijn> edwardk: I'm mad at you for using both, now I'll never convince people to add "both = join (***)" to Control.Arrow :(
13:59:17 <edwardk> > both %~ intersperse ',' $  ("hello","goodbye")
13:59:19 <lambdabot>   ("h,e,l,l,o","g,o,o,d,b,y,e")
13:59:22 <edwardk> merijn: =P
13:59:25 <edwardk> i prefer mine =P
13:59:35 <hpc> Sonarpulse: i don't really worry about it, and make as much top-level as i can
13:59:37 <edwardk> :t join (***)
13:59:38 <merijn> You coud've used _both >.>
13:59:39 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
13:59:46 <mcstar> edwardk: did you ever auditioned for America's got talent?
13:59:51 <Sonarpulse> ok, soudns good
13:59:52 <edwardk> you can use 'diag' from one of my libraries ;)
13:59:55 <Sonarpulse> that's what modules are for
14:00:02 <Nisstyre> startling: yes I am using idiii
14:00:03 <edwardk> mcstar: not that i can remember =)
14:00:13 <merijn> edwardk: Not as nicely semantically named, though :\
14:00:17 <mcstar> edwardk: you would blew the judges away... XD
14:00:37 <edwardk> watch my amazing functional programming skills! live in vegas!
14:00:44 <mcstar> hehe
14:00:54 <gertc> `url = liftIO $ withManager $ \manager -> FB.runFacebookT app manager $ FB.getUserAccessTokenStep1 rrl perms` i still get stuck with IO Text instead of Text or Maybe Text
14:01:04 <Taneb> If someone did that on X Factor or whatever, I might actually watch
14:01:08 <mami__> merijn, mcstar thank you very much
14:01:18 <mami__> nice stuff
14:01:22 <mcstar> np, have fun learning
14:01:27 <mami__> need to build my vocabulary
14:01:40 <mami__> just started out but have been already impressed
14:01:49 <mami__> much nicer than c or python
14:01:55 <merijn> mami__: You usually end up composing functions like that instead of list comprehensions. That's usually more readable too :)
14:02:04 <shachaf> > toListOf (traverse.traverse.filtered even) [[1..20],[1,3..10]]
14:02:04 <mami__> yeah, guess so
14:02:06 <lambdabot>   [2,4,6,8,10,12,14,16,18,20]
14:02:17 <shachaf> What happened to the thing that used to be called filtered?
14:02:30 <mami__> merijn: but it was so nice to just have some features that i already knew from linear algebra
14:02:37 <mami__> so i could just apply what i already new
14:02:40 <edwardk> shachaf: you compose with the new filtered to get it
14:02:41 <edwardk> :t filtered
14:02:43 <lambdabot> Applicative f => (a -> Bool) -> SimpleLensLike f a a
14:02:57 <edwardk> :t traverse.filtered even
14:02:59 <lambdabot> (Integral b, Applicative f, Traversable t) => (b -> f b) -> t b -> f (t b)
14:03:00 <shachaf> Despite it being a bad lens? :-)
14:03:09 <edwardk> its not a lens. its a fold, ;)
14:03:17 <merijn> I guess tell just mappend's for when using the monoid instance of writer?
14:03:19 <shachaf> OK, so my use of it there was valid?
14:03:21 <edwardk> LensLIKE, not lens ;)
14:03:26 <edwardk> yep
14:03:34 <shachaf> Since it doesn't modify the elements so it can't break the laws.
14:03:34 <edwardk> toListOf takes a fold
14:03:36 <shachaf> Fair enough.
14:03:38 <edwardk> yep
14:04:01 <Sonarpulse> ok, would would be the cannonical haskell name for a function like "get list of x"
14:04:13 <edwardk> :t repeat
14:04:15 <lambdabot> a -> [a]
14:04:24 <edwardk> > repeat 1
14:04:26 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:04:39 <shachaf> Maybe "roger" or "andrew", depending on what kind of list.
14:04:40 <hpc> > replicate 15 "fifteen" -- also this
14:04:42 <lambdabot>   ["fifteen","fifteen","fifteen","fifteen","fifteen","fifteen","fifteen","fif...
14:04:45 <edwardk> > 1^.iterated id
14:04:46 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:04:47 <lambdabot>    (GHC.Num.Num a0)
14:04:47 <lambdabot>      a...
14:04:50 <parcs`> :t repeat repeat
14:04:51 <lambdabot> [a -> [a]]
14:04:52 <edwardk> shucks
14:05:01 <Taneb> edwardk, stop trying to sho off
14:05:04 <Taneb> *show
14:05:07 <edwardk> =)
14:05:14 <hpc> :t repeat repeat <*> repeat repeat
14:05:16 <lambdabot> [[a -> [a]]]
14:05:21 <edwardk> :t repeated
14:05:24 <lambdabot> (Applicative f, Gettable f) => (a -> f a) -> a -> f a
14:05:29 <edwardk> > 1^.repeated
14:05:31 <lambdabot>   Ambiguous type variable `a0' in the constraints:
14:05:31 <lambdabot>    (GHC.Num.Num a0)
14:05:31 <lambdabot>      a...
14:05:39 <edwardk> > 1^..repeated
14:05:42 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:06:02 <parcs`> > Data.Foldable.fold (repeat repeat) ()
14:06:02 <shachaf> Ah, ^.. is toListOf?
14:06:03 <lambdabot>   [(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),(),()...
14:06:09 <edwardk> shachaf: yep
14:06:22 <shachaf> Yay.
14:06:33 <edwardk> like how ^? is headOf
14:06:34 <shachaf> One day I'll remember all the lens operators.
14:07:15 <int-e> Can ghc-6.12.1 compile ghc-7.4.2?
14:07:30 <hpc> int-e: quite likely
14:07:56 <Taneb> Is there GHC for Haiku?
14:08:16 <int-e> hpc: thanks. I'll give it a try :)
14:09:09 <ivanm> Taneb: you'd be better off asking the Haiku users if anyone has built GHC for Haiku
14:09:15 <ivanm> it isn't a supported platform last I checked
14:09:19 <Taneb> Okay
14:09:27 <Taneb> That's pretty much my last reason for not using Haiku
14:09:37 <Taneb> That and WINE
14:10:36 <Taneb> And the fact that I've been awake far too long now to be messing with my computer
14:11:56 <ivanm> heh
14:12:07 <Sonarpulse> well I think I am pretty good to go
14:12:12 <Sonarpulse> Thanks everybody!
14:12:33 <S11001001> @ty join (fmap fmap fmap)
14:12:33 <Taneb> (18th birthday yesterday, had a long party thing)
14:12:35 <lambdabot> Functor f => (a -> f a) -> a -> f (f a)
14:13:02 <mcstar> last time i asked someone why would they use haiku, they coudlnt give me a sane reason
14:13:09 <mcstar> i think it is 'hip', thats all
14:13:17 <Taneb> My reason isn't sane
14:13:22 <Taneb> It's to annoy my brother
14:13:32 <mcstar> oh, then, go ahead
14:13:33 <startling> mcstar, OS development is cool
14:13:43 <mrpantoufle> @help @ty
14:13:43 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:13:46 <mrpantoufle> @help ty
14:13:46 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:13:47 <startling> mcstar, people like to be parts of things like that
14:13:57 <startling> @help type
14:13:57 <lambdabot> type <expr>. Return the type of a value
14:14:05 <mcstar> startling: lets cross that out, THAT i could understand
14:14:30 <S11001001> > join (fmap.fmap) (:[])
14:14:32 <lambdabot>   *Exception: show: No overloading for function
14:14:38 <S11001001> > join (fmap.fmap) (:[]) 42
14:14:40 <lambdabot>   [[42]]
14:14:59 <gertc> why must i `do text <- liftIO myfunc` and can not do the liftIO part in `myfunc = liftIO ...` so this would work `do text <- myfunc`
14:15:13 <shachaf> gertc: You can.
14:15:14 <startling> gertc, you can
14:15:18 <shachaf> Try -XNoMonomorphismRestriction
14:15:25 <shachaf> @where dmr -- and read this page
14:15:25 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
14:15:40 <ivanm> why is that under "dmr"? for Damn ?
14:15:41 <mcstar> jesus, im getting better, i provisioned the answer
14:15:46 <merijn> ivanm: Dread
14:15:46 <mcstar> my haskell gut is getting better
14:16:01 <merijn> And/or Dreaded
14:16:27 <shachaf> It's Dreaded.
14:16:32 <mcstar> again
14:18:14 <twmb> so i just got to the part on higher order functions in haskell and i gotta say this is pretty cool
14:18:24 <twmb> lyah*
14:19:37 <mcstar> *** Exception: <<loop>>
14:19:54 <mcstar> heh, it runs for quite long, before throws the exception
14:21:52 <gertc> ok so the reason it does not work is myfunc :: IO Text needs to be somthing els for it to work right?
14:24:33 <gertc> the compiler expects m Text so i tried Maybe Text but that does need a controle... instance
14:39:03 <gertc> ps de NoMonomorphismRestriction works but that just means my type `myfunc :: IO Text` is wrong :)
14:41:19 <startling> we need a @lens, that takes a lens type and turns uses synonyms
14:41:25 <startling> s/turns //
14:41:28 <edwardk> startling: =)
14:42:44 <merijn> gertc: Can you paste the code + error at hpaste.org?
14:42:58 <gertc> on it
14:44:34 <startling> edwardk, so I had an invert :: d -> d, so I could turn my d -> Simple Lens a a into a d -> Simple Iso a a. Is there a formalization of this kind of thing?
14:45:04 <edwardk> not parsing that =)
14:46:09 <hpaste> gertc pasted ‚Äúurl :: IO Text‚Äù at http://hpaste.org/77263
14:46:16 <startling> fair enough! basically I can turn my lens into an isomorphism with `\d -> ismorphic (myLens d) (myLens $ invert d)
14:46:22 <gertc> no error :)
14:47:23 <gertc> just the url :: IO Text needs to be url :: Text or somthing so i can do x <- url and not x <- liftIO url
14:48:59 <merijn> If there's no error, what's the problem?
14:49:37 <gertc> url :: IO Text ? i expected url :: Text
14:49:54 <gertc> i dont understand why
14:50:08 <merijn> Why would you expect Text?
14:50:08 <startling> gertc, you can't produce a non-monadic value from a monadic value in general
14:50:13 <gertc> or url :: Maybe Text
14:50:26 <gertc> everything except IO Text :)
14:50:48 <merijn> :t liftIO
14:50:50 <lambdabot> MonadIO m => IO a -> m a
14:51:00 <rwbarton> do you know what a value of type IO Text is?
14:51:12 <merijn> liftIO lifts things into MonadIO, not any generic monad
14:51:14 <monochrom> not sure what you want liftIO for
14:51:34 <merijn> gertc: Why did you think you needed liftIO?
14:51:58 <monochrom> but I'm a logician rather than intuitionist
14:52:03 <gertc> ok going to past the second part of the thing that actually uses the url thing
14:55:51 <hpaste> gertc annotated ‚Äúurl :: IO Text‚Äù with ‚Äúurl <- liftIO FB.url‚Äù at http://hpaste.org/77263#a77264
14:57:08 <merijn> gertc: That should work if you change "url :: IO Text" to "url :: MonadIO m => m Text"
14:57:38 <gertc> aaaaa now we are talking :)
14:57:44 <gertc> thx
14:57:53 <gertc> no way i would figure that out
14:58:04 <merijn> gertc: That WebSockets thing is basically a wrapper around the IO monad
14:58:33 <merijn> gertc: liftIO lifts "IO a" into "m a" for all m that are IO wrappers (i.e. the MonadIO typeclass)
14:59:10 <merijn> gertc: And that code needs to run in the WebSockets monad, rather than IO, hence why you have to liftIO it
15:01:05 <gertc> ok i am processing what you just said hang on
15:02:39 <gertc> by wrapper you mean monad transformer?
15:02:46 <merijn> gertc: Yeah
15:05:40 <merijn> i.e. if you have the monad "ReaderT Int IO" and you would like to run an IO action inside you could use lift, but for more complicated monad stacks that becomes cumbersome. liftIO is a way to automatically use the right number of lifts
15:06:58 <Clint> what is lens used for in the real world?
15:07:32 <Nereid> anything!
15:07:54 <Ghoul> Is Data.Serialize fast?
15:08:00 <monochrom> I use lens to get the first item of a list
15:08:08 <Clint> Ghoul: sure, why not?
15:08:10 <Ghoul> oor, could I use bitshifting to deconstruct packets
15:08:19 <Ghoul> I need to get equivalent performance to C
15:08:28 <Ghoul> for deconstructing packets into several variables :|
15:09:28 <Ghoul> Clint: well, it looks like alot of method calls
15:09:30 <Ghoul> to do very little
15:09:36 <Ghoul> not sure how GHC is going to handle that
15:10:06 <typoclass> Ghoul: are you sure that this is indeed the bottleneck? have you measured it? (performance is often surprising and counterintuitive)
15:10:23 <gertc> merijn, thx i need to make a few test examples the lift way before i know if i got it or not. I will return if my examples do not match your explenation :)
15:10:52 <Ghoul> typoclass: I'm just getting a feel for performance before I port over all the HUGE amount of data
15:10:53 <Ghoul> to one method
15:11:20 <Ghoul> typoclass: Clint: This is the beginning of my serialize implementation https://gist.github.com/3844340
15:13:02 <Ghoul> In C one would just setup an enumerator and then shift data into it, but haskells serialize looks much much much slower than that
15:13:19 <Ghoul> Maybe I could shift left in haskell the same way..
15:15:13 <Clint> what are you shifting?
15:15:31 <Ghoul> In both C and haskell packets come in as ByteString-like objects
15:15:46 <Ghoul> in C you'd decompose a packet made of lots of bytes of material like this:
15:16:00 <Ghoul> header << packet;
15:16:31 <Ghoul> switch(header) { blah blah blah functions } ... functionForSomething { var1 << var2 << var3 << var4 << packet; }
15:16:45 <merijn> That doesn't like C, unless your packets are int sized...
15:18:14 <merijn> Ghoul: Also, realise that GHC does massive amounts of code transformation/inlining on functions. So "a lot of function calls" is often likely to evaporate into "almost nothing"
15:18:42 <Ghoul> Hmm, okay.
15:18:57 <typoclass> Ghoul: honestly, i would write the simplest possible thing, then profile the program. this allows you to optimize based on evidence instead of guesses
15:19:30 <typoclass> Ghoul:  (i think that otherwise, you'll waste your time, like my old boss who demanded optimization of a 3-millisecond function that was called once, but did nothing about the server taking 40 seconds to send a reply, which were needed constantly)
15:20:01 <monochrom> scientific method vs opinionative method
15:20:04 <Ghoul> Hmm, I guess you're right
15:20:19 <Ghoul> I'll finish writing it up and then I'll profile it
15:20:26 <nicoo> typoclass: And what did the boss do when faced with profiling data ?
15:20:28 <typoclass> Ghoul: yup, good plan :-)
15:21:32 <nicoo> Btw, if you count ¬´ using algos with lower asymptotic complexity ¬ª as optimization, then the opiniative method can have some merits ;)
15:22:52 <typoclass> nicoo: the boss rambled about how you absolutely can't reverse an array in the naive way, because in 1982, he was writing assembler code for some steam-driven cogwheel computer to reverse an array or something, and back then ...
15:23:14 <nicoo> ;_;
15:23:40 * nicoo has know the pain and boredom brought by such rants.
15:23:48 <nicoo> known*
15:23:54 <hiptobecubic> @nixon
15:23:54 <lambdabot> They're not like us. They smell different, they look different, they act different.  The trouble is, you can't find one that's honest.
15:24:43 <typoclass> nicoo: possibly, but i'm not really convinced. the O notation will be important for the list containing 3000 bazillion elements, but probably won't tell you anything about a 100-element list
15:25:28 <koninkje> Though O notation on other data structures (e.g., trees) pays off very quickly
15:25:35 <koninkje> lists are kinda special/weird
15:25:57 <Ghoul> Hmm
15:26:04 <Ghoul> I need to store chunks
15:26:07 <parcs`> typoclass: is the naive way the quadratic complexity way??
15:26:10 <Ghoul> There are like thousands of them
15:26:14 <nicoo> typoclass: On size 100, all non-broken algos are usually fast enough (except for exotic problems that are in n-EXPTIME and such)
15:26:19 <Ghoul> I guess O is important then?
15:27:03 <Ghoul> Is there a list which has BNT lookup?
15:27:15 <nicoo> Ghoul: Depends where; depends on what your program is doing. I don't have a definitive answer
15:27:28 <typoclass> parcs`: i don't recall, it was a simple for loop or something
15:28:01 <nicoo> Ghoul: BNT ?
15:28:53 <typoclass> parcs`: and anyway, if someone does something about the damn server taking half a minute, i'm perfectly happy if reversing the 30-element array takes 0.1 ms longer because it's quadratic or whatever
15:29:57 <tomeo> http://pastie.org/5185876 is it possible to define my variable res in a more traditonal way? (ie, before I use it) I find this way of writing it a tad confusing
15:30:01 <Ghoul> nicoo: binary node tree
15:30:46 <KirinDave> Didn't GHC 7.6 introduce some new tuple inlining feature for register allocation?
15:30:52 <KirinDave> Or am I mis-remembering something.
15:31:20 <nicoo> Ghoul: I don't see what you mean by ¬´ BNT lookup ¬ª. Are you confusing lists and search trees ?
15:31:36 <monochrom> tomeo: case singleWildcardMatch (wc:ps) xs of { Just y -> Just (x : y); Nothing -> longerWildcardMatch (wc:ps) xs }
15:32:08 <monochrom> you can replace {;} by indentations and newlines
15:32:31 <Ghoul> nicoo: Probably
15:33:04 <tomeo> monochrom: thanks but I find that even harder to read :)
15:33:31 <tomeo> which is probably due to me not knowing enough Haskell
15:33:41 <monochrom> let res = singleWildcardMatch (wc:ps) xs in case res of ...
15:34:06 <typoclass> tomeo: hello, it is indeed normal haskell style to write "blah blah x where x = ...". if you wish, you can replace that with "let x = ... in blah blah x". note that haskell does not usually evaluate one line after another, it evaluates when you ask for something, as far as necessary
15:34:08 <monochrom> you can break lines between "in" and "case"
15:34:26 <typoclass> tomeo: ... and instead of if-then-else, we often use pattern matching as monochrom demonstrated :-)
15:34:26 <tomeo> I thought let was only used in GHCI
15:34:41 <monochrom> anyway my real point is you should use pattern-matching, not this isJust-fromJust business
15:35:05 <tomeo> monochrom: so I should read this? http://www.haskell.org/tutorial/patterns.html
15:35:11 <monochrom> save your isJust-fromJust for inferior languages such as php, scheme, lisp
15:35:14 <typoclass> @where lyah
15:35:14 <lambdabot> http://www.learnyouahaskell.com/
15:35:16 <monochrom> yes
15:35:25 <typoclass> tomeo: lyah is a good book available free of charge ^^
15:35:32 <Ghoul> are patterns optimised by GHC better than switch statements
15:35:35 <S11001001> @ty maybe
15:35:36 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:35:39 <S11001001> @ty fromMaybe
15:35:41 <lambdabot> a -> Maybe a -> a
15:35:49 <ivanm> Ghoul: you mean case statements?
15:35:58 <Ghoul> ivanm: yes
15:35:58 <S11001001> @ty (<$>) :: (a -> b) -> Maybe a -> Maybe b
15:36:00 <lambdabot> (a -> b) -> Maybe a -> Maybe b
15:36:14 <monochrom> patterns and case expressions are optimized the same way
15:36:16 <ivanm> Ghoul: pattern-matching on the function level is de-sugared to case-statements by GHC
15:36:16 <S11001001> @ty (>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
15:36:17 <lambdabot> Maybe a -> (a -> Maybe b) -> Maybe b
15:36:23 <Nereid> tomeo: yes, it's much preferred to pattern match on a Maybe value than to test it with isJust and so on.
15:36:28 <Ghoul> oh okay
15:36:51 <tomeo> Nereid: I'll have to read about that :)
15:36:52 <S11001001> @ty (<*>) :: Maybe (a -> b) -> Maybe a -> Maybe b
15:36:53 <lambdabot> Maybe (a -> b) -> Maybe a -> Maybe b
15:37:09 <tomeo> Is that learn you a haskell book not available for free as a pdf?
15:37:14 <monochrom> I don't actually speak against isJust, provided you won't be using fromJust
15:37:25 <Nereid> tomeo: just as html
15:37:38 <Nereid> monochrom: fair.
15:37:55 <typoclass> tomeo: yes, it's free, click "read it online for free"
15:38:14 <tomeo> typoclass: I know. I was hoping I could get it as a pdf so I can tead it on my nexus :)
15:38:42 <typoclass> tomeo: oh i see :-) don't know about a pdf version
15:38:43 <Ghoul> Your nexus browser has a read offline feature
15:38:46 <ivanm> tomeo: there are some unofficial PDFs available around
15:38:50 <ivanm> but you're meant to buy the ebook
15:38:56 <tomeo> Ghoul: oh nice. didnt know that
15:38:57 <Ghoul> If you go onto the site and click the 3 dots at the top right hand side
15:39:02 <Ghoul> then click "safe offline for later"
15:39:07 <Ghoul> then you can access it via your bookmarks page
15:39:08 <ivanm> Ghoul: will it save the entire website though? or just that page?
15:39:13 <Ghoul> Just that page
15:39:14 <S11001001> tomeo: dozens of ordinary functions are available for working with Maybes safely; above are just a few of the examples
15:39:15 <mapreduce> a quick google suggests http://www.cs.utexas.edu/~cannata/cs345/Class%20Notes/09%20learnyouahaskell.pdf
15:39:15 <Nereid> you could also print the pages to pdf or something
15:39:30 <Ghoul> I feel so evil
15:39:36 <Ghoul> the LYAH guy is a great guy :C
15:39:37 <Nereid> mapreduce: that doesn't have any of the cute pictures.
15:39:44 * ivanm isn't ashamed to admit that he uses a fair amount of fromJust, but then his use case is probably rather different from tomeo's
15:40:05 <tomeo> ivan\: my use case is just learning haskell. I started today
15:40:11 <typoclass> tomeo: i think the book will only be half as useful if you read. you should try out stuff and mess around in ghci along the way :-)
15:40:15 <ivanm> that's what I meant :)
15:40:27 <monochrom> and my opposition to isJust-fromJust is not even about safety or partial functions. the program can be proved correct and total, what's so unsafe or partial about it
15:40:32 <hpaste> typoclass pasted ‚Äútomeo's code revisited‚Äù at http://hpaste.org/77265
15:40:43 <mapreduce> typoclass: That sounds harder to do offline on a nexus. :)
15:40:44 <tomeo> But even though Im very green I should still go for patterns instead of if/else?
15:40:45 <typoclass> tomeo: i think monochrom's suggestion becomes clearer with indentation ^^
15:40:47 <monochrom> my opposition is that isJust-fromJust is the IRC equivalent of asking to ask
15:40:59 <Nereid> haha
15:41:00 <typoclass> mapreduce: yup exactly :-) that's what i mean
15:42:46 <Nereid> any particular reason why it's (wc:ps) everywhere?
15:43:02 <ivanm> monochrom: or you have functions that are being safe and returning Maybe-based values when it's possible a sensible answer might not be possible, but you're using them in cases you _know_ it will be possible...
15:44:00 <monochrom> if you are very green, you will not have heard of Maybe, isJust, fromJust to begin with
15:44:03 <typoclass> tomeo: i've put an update on http://hpaste.org/77265 ... just a little more whitespace so you can see how the stuff groups
15:44:13 <tomeo> thanks typoclass
15:44:21 <Cale> tomeo: fromJust makes things harder to get right, because you have to be very careful that the thing you're applying it to isn't Nothing, and your program will die completely if it is
15:44:51 <Nereid> boo non-total functions
15:44:52 <monochrom> if you have heard of Maybe, then the case expression for Maybe is more fundamental than isJust, fromJust.
15:45:12 <Nereid> indeed, inJust and fromJust are defined by pattern matching.
15:45:19 <Cale> tomeo: So, pattern matching will help you organise things better to ensure that all the cases are handled, and it usually produces clearer code as well
15:45:21 <Nereid> isJust*
15:45:25 <ivanm> (admittedly, I also use fromMaybe (error "function: problem") when I'm less certain that something won't go wrong
15:45:34 <Nereid> @src fromJust
15:45:34 <lambdabot> fromJust Nothing  = undefined
15:45:35 <lambdabot> fromJust (Just x) = x
15:45:40 <Nereid> ^ that undefined is scariness.
15:45:46 <tomeo> thanks Cale
15:45:48 <Ghoul> http://hpaste.org/77267 :)
15:45:48 <ivanm> > fromJust Nothing
15:45:50 <lambdabot>   *Exception: Maybe.fromJust: Nothing
15:45:53 <merijn> Clearly fromJust should be "fromJust :: Maybe a -> Maybe a" :>
15:45:57 <ivanm> ^^ the undefined is a lie!
15:46:01 <Nereid> merijn: :>
15:46:03 <ivanm> @slap merijn
15:46:03 * lambdabot would never hurt merijn!
15:46:09 <merijn> Ha!
15:46:10 <typoclass> (it still bugs me that fromJust and fromMaybe look so similar, but one is perfectly fine and the other one would nearly warrant an "unsafe" in the name)
15:46:20 <Nereid> @type fromMaybe
15:46:21 <monochrom> @quote monochrom fromJust
15:46:21 <lambdabot> a -> Maybe a -> a
15:46:22 <lambdabot> No quotes match. The more you drive -- the dumber you get.
15:46:29 <mapreduce> :t fromJust
15:46:29 <monochrom> @quote monochrom safeFromJust
15:46:30 <lambdabot> No quotes match. Are you on drugs?
15:46:30 <lambdabot> Maybe a -> a
15:46:44 <Nereid> @type flip maybe id
15:46:44 <typoclass> Nereid: fromMaybe is a default value and a Maybe
15:46:45 <lambdabot> a -> Maybe a -> a
15:46:46 <mapreduce> > fromJust Nothing
15:46:47 <lambdabot>   *Exception: Maybe.fromJust: Nothing
15:46:55 <Nereid> typoclass: as is obvious from the type. :p
15:47:22 <ivanm> Nereid: not really; it could be equivalent to const!
15:47:30 <shachaf> fromMaybe is unsafe, because it loses information!
15:47:33 <ivanm> @djinn a -> Maybe a -> a
15:47:33 <lambdabot> f a b =
15:47:34 <lambdabot>     case b of
15:47:34 <lambdabot>     Nothing -> a
15:47:34 <lambdabot>     Just c -> c
15:47:36 <Nereid> yes but fromMaybe is more interesting than const
15:47:40 <shachaf> "maybe" is the future!
15:47:40 <typoclass> fromMaybe _ _ = ()
15:47:42 <typoclass> :)
15:47:50 <ivanm> typoclass: that doesn't type-match
15:47:57 <Nereid> you can tell because const has a more general type
15:48:10 <monochrom> wait, losing information is safe. gaining too much information is unsafe. and fromJust gains too much information, rather than losing information
15:48:19 <Nereid> fromAnything _ = undefined
15:48:31 <Nereid> or ()
15:48:34 <shachaf> What information does fromJust gain?
15:48:34 <ivanm> dwim _ = undefined
15:48:52 <ivanm> shachaf: if it succeeds that the input was a Just value?
15:48:57 <monochrom> it gains an extra witness for the type 'a'
15:49:11 <shachaf> Ah, I see.
15:49:19 <Ghoul> is this valid syntax
15:49:20 <Ghoul> http://hpaste.org/77267
15:49:24 <shachaf> Gaining false information is unsafe.
15:49:25 <monochrom> but I'm weird
15:49:36 <Nereid> Ghoul: yeah, that's better
15:49:45 <Nereid> although @(wc:ps) doesn't look necessary at all
15:49:45 <Cale> Ghoul: seems okay
15:50:09 <Ghoul> I thought for optimisation maybe
15:50:12 <Cale> Well, the @(wc:ps) affects what gets matched by this case
15:50:14 <shachaf> You could probably do something nice with tails.
15:50:16 <Ghoul> since a:b is a list appendation
15:50:16 <monochrom> because I understand that denotational people say that ‚ä• is the least information, so if you have f such that f Nothing = ‚ä•, that loses information
15:50:20 <shachaf> Or with zip <*> tail
15:50:24 <Nereid> Cale: sure, but whether it's needed...
15:50:32 <Nereid> and if it really is, write a@(_:_)
15:50:49 <ivanm> shachaf: is that the non-Aztec version of zip`ap`tail? :p
15:50:50 <int-e> hpc: ok, compiling ghc 7.4.2 with ghc 6.12.1 worked like a charm :)
15:51:07 <Ghoul> I would compile it again lol
15:51:08 <Saizan> information (Either a b) = information a `min` information b  -- ?
15:51:13 <shachaf> No, zip <*> tail is wrong.
15:51:16 <Ghoul> it might speed up alot :o
15:51:25 <Cale> I'd probably write a@(p:ps) since I have something weird against underscores.
15:51:29 <ivanm> @type (<*>)
15:51:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
15:51:32 <ivanm> @type ap
15:51:33 <Nereid> Cale: you're weird. :>
15:51:34 <lambdabot> Monad m => m (a -> b) -> m a -> m b
15:51:35 <Cale> (not for any technical reason)
15:51:35 <rwbarton> a@(:){}
15:51:40 <Nereid> hah
15:51:41 <Cale> Just typographically
15:51:46 <ivanm> @type zip <*> tail
15:51:48 <lambdabot> [b] -> [(b, b)]
15:51:51 <monochrom> _a@(_p:_ps)
15:51:54 <ivanm> shachaf: ^^ how is it wrong?
15:52:02 <shachaf> ivanm: It doesn't help Ghoul.
15:52:05 <Nereid> > (\[] {} -> 5) []
15:52:06 <ivanm> oh, right
15:52:06 <lambdabot>   5
15:52:11 <Nereid> wow that works with nullary constructors too.
15:52:14 <Nereid> :V
15:52:30 <shachaf> monochrom: I meant that if you have, say, a (Maybe Bool), and you fromMaybe it, you're going from three possible values to two possible values.
15:52:34 <Nereid> well, not surprised
15:52:37 <Nereid> just fun
15:52:43 <monochrom> yeah
15:52:54 <shachaf> There's no argument you can give fromMaybe that would allow three possible results.
15:53:06 <shachaf> (This is all disregarding ‚ä•.)
15:53:45 <Nereid> zip <*> tail is really lucky I think.
15:53:55 <Nereid> that it works on the empty list.
15:54:01 <shachaf> Yep.
15:54:20 <shachaf> You can use zip <*> drop 1 if you prefer.
15:54:28 <Nereid> I might.
15:54:29 <Nereid> > flip zip <*> tail $ []
15:54:31 <lambdabot>   *Exception: Prelude.tail: empty list
15:54:34 <Nereid> > flip zip <*> drop 1 $ []
15:54:35 <lambdabot>   []
15:54:40 <Nereid> > flip zip <*> tail $ [1..5]
15:54:41 <lambdabot>   [(2,1),(3,2),(4,3),(5,4)]
15:54:48 <monochrom> even :: Int -> Bool loses way more information, and it is safe. No, you have to regard ‚ä• to argue for unsafety
15:55:55 <shachaf> even is also unsafe by my new definition.
15:56:02 <Nereid> lol
15:56:10 <rwbarton> i like it
15:56:13 <monochrom> I guess sum is unsafe too
15:56:23 <shachaf> Almost everything is unsafe.
15:56:23 <Nereid> as is const
15:56:26 <rwbarton> you better believe it is!
15:56:31 <rwbarton> > sum $ repeat 1
15:56:35 <lambdabot>   mueval-core: Time limit exceeded
15:56:53 <Nereid> gaining information should also be unsafe, then.
15:56:58 <Nereid> the only safe function is id!
15:57:08 <monochrom> OK, all useful programs are unsafe
15:57:12 <Nereid> :p
15:57:27 <Saizan> either Right Left is fine too
15:57:36 <Nereid> I know.
15:57:40 <Nereid> as is flip.
15:57:42 <monochrom> @type either
15:57:46 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
15:57:48 <shachaf> > sumOf repeated 1
15:57:52 <lambdabot>   mueval-core: Time limit exceeded
15:58:01 <Nereid> @type repeated
15:58:02 <monochrom> either RIght Left? either Left Right?
15:58:03 <lambdabot> (Applicative f, Gettable f) => (a -> f a) -> a -> f a
15:58:04 <shachaf> monochrom: Only isomorphisms are safe.
15:58:18 <shachaf> Fortunately all of mathematics is the study of isomorphisms.
15:58:23 <shachaf> So mathematical programs are safe.
15:58:33 <monochrom> no, integrators are unsafe
15:58:36 * typoclass finds it slightly unsafe to be around you guys for too long
15:58:40 <Nereid> I dunno, shachaf.
15:58:54 <Ghoul> > iterate
15:58:56 <lambdabot>   *Exception: show: No overloading for function
15:59:01 <Nereid> much interesting mathematics looks at how much things fail to be isomorphisms.
15:59:01 * Saizan wonders if shachaf is channeling someone
15:59:03 <shachaf> > sumOf (replicated 5) 1
15:59:04 <monochrom> finding the class number of a field/ring is unsafe
15:59:05 <lambdabot>   5
15:59:07 <Ghoul> @type iterate
15:59:08 <lambdabot> (a -> a) -> a -> [a]
15:59:14 <shachaf> monochrom: Then don't do that!
15:59:17 <Nereid> @type replicated
15:59:31 <Nereid> @type fmap -- did this get fixed?
15:59:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:59:34 <Nereid> heh
15:59:38 <Ghoul> > iterate (*2) 10
15:59:38 <Nereid> @type replicated
15:59:40 <lambdabot>   [10,20,40,80,160,320,640,1280,2560,5120,10240,20480,40960,81920,163840,3276...
15:59:43 <Saizan> shachaf: you'll make forgetful functors cry
15:59:45 <Nereid> hey. what's going on.
15:59:49 <Ghoul> > iterate (*2) 1
15:59:51 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
16:00:02 <shachaf> Saizan: What's the opposite of a forgetful functor?
16:00:05 <shachaf> An elephantine functor?
16:00:12 <Ghoul> > tail $ take 64 $ iterate (*2) 1
16:00:13 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
16:00:16 <EvanR7> whats all this talk about forgetful functors
16:00:20 <Nereid> forgetful functors actually "gain" you information
16:00:23 <Nereid> er, *gain*
16:00:28 <Ghoul> > tail . take 64 $ iterate (*2) 1
16:00:31 <lambdabot>   [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,26...
16:00:35 <Ghoul> whaat
16:00:39 <Ghoul> Shouldm
16:00:46 <Ghoul> it return 2.1 billion something
16:00:51 <shachaf> @@ @show @type replicated
16:00:53 <lambdabot>  ""
16:00:58 <shachaf> Nereid: Hey, this is great.
16:01:00 <Nereid> Ghoul: maybe if you used "last" instead of "tail"
16:01:00 <startling> Ghoul: what makes you think that?
16:01:04 <shachaf> @@ @show @type iterated
16:01:05 <lambdabot>  ""
16:01:06 <typoclass> Ghoul: i think you mean 'drop' instead of 'take'
16:01:06 <shachaf> @@ @show @type repeated
16:01:07 <lambdabot>  "(Applicative f, Gettable f) => (a -> f a) -> a -> f a"
16:01:10 <monochrom> it is possible that @type doesn't tell you about errors
16:01:17 <Nereid> or that
16:01:18 <Ghoul> > last . take 64 $ iterate (*2) 1
16:01:19 <startling> oh yeah, drop/take is probably it.
16:01:20 <lambdabot>   9223372036854775808
16:01:27 <Ghoul> Oh that looks correct
16:01:38 <Nereid> > iterate (*2) 1 !! 64
16:01:39 <lambdabot>   18446744073709551616
16:01:46 <Nereid> >2^64
16:01:48 <Nereid> > 2^64
16:01:49 <lambdabot>   18446744073709551616
16:02:00 <Ghoul> What's !!
16:02:04 * hackagebot JuicyPixels-repa 0.5.1 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.5.1 (ThomasDuBuisson)
16:02:05 <Nereid> > [a,b,c,d,e] !! 3
16:02:07 <lambdabot>   d
16:02:19 <typoclass> > iterate (*2) 1 !! 63
16:02:20 <Ghoul> iterate (*2) 1 !! 65
16:02:20 <lambdabot>   9223372036854775808
16:02:31 <Ghoul> iterate (*2) 1 !! 0
16:02:34 <Nereid> you forgot the >
16:02:41 <Ghoul> > iterate (*2) 1 !! 0
16:02:42 <lambdabot>   1
16:02:48 <startling> > [] !! 1
16:02:49 <lambdabot>   *Exception: Prelude.(!!): index too large
16:02:53 <Ghoul> > iterate (*2) 1 !! 65
16:02:54 <lambdabot>   36893488147419103232
16:03:11 <Ghoul> hax
16:03:20 <Nereid> x !! n = head (drop n x)
16:03:21 <Ghoul> !type !!
16:03:24 <Ghoul> @type !!
16:03:24 <Nereid> @type (!!)
16:03:25 <lambdabot> parse error on input `!!'
16:03:26 <lambdabot> [a] -> Int -> a
16:03:46 <Ghoul> oh
16:03:50 <Ghoul> head (drop n x) heh
16:05:24 <Nereid> > iterate (*2) 1 ^. element 64
16:05:26 <lambdabot>   *Exception: stack overflow
16:05:30 <Nereid> wait wh?
16:05:40 <Nereid> > [0..] ^. element 64
16:05:42 <lambdabot>   *Exception: stack overflow
16:05:46 <Nereid> > [0..64] ^. element 64
16:05:48 <lambdabot>   64
16:05:49 <Nereid> ????
16:06:00 <rwbarton> needs moar lazy
16:06:07 <Nereid> > [0..10000] ^. element 64
16:06:09 <lambdabot>   64
16:06:13 <Nereid> what's up with that
16:06:19 <rwbarton> ask shachaf!
16:06:24 <Nereid> shachaf!
16:06:26 <Nereid> what's up with that
16:06:30 <shachaf> With what?
16:06:34 <Nereid> stack overflow
16:06:36 <Ghoul> > [0..10000] 2^. element 64
16:06:38 <lambdabot>   The function `[0 .. 10000]' is applied to one argument,
16:06:38 <lambdabot>  but its type `[t0]...
16:06:51 <Ghoul> > [0..10000] (2^) element 64
16:06:52 <lambdabot>   The function `[0 .. 10000]' is applied to three arguments,
16:06:52 <lambdabot>  but its type `[...
16:07:02 <Nereid> Ghoul: ^. is lens stuff
16:07:07 <dino-> Trying to install something that needs gtk2hs-buildtools, which is failing to build for me. Getting those "Unacceptable result type in foreign declaration: CInt" errors..
16:07:13 <espringe> I've got something like: data Foo= Blah1 String String | Blah2 String String.  -- is it possible to have a [Blah2 _ _] ? (Like a list of Foo's, but all the have been constructed via Blah2 )
16:07:14 <Nereid> as is element
16:07:15 <dino-> I see there's activity about this, but not sure what to do about it
16:07:28 <shachaf> Nereid: Oh, that doesn't look good, does it.
16:07:30 <Nereid> dino-: yes, it won't work on 7.6.1
16:07:48 <Nereid> dino-: there's a patched one that does, though http://patch-tag.com/r/hamish/gtk2hs
16:08:03 <dino-> Nereid: Fantastic, thank you.
16:08:25 <startling> > [1] ^. element 0
16:08:27 <lambdabot>   1
16:09:03 <Nereid> yeah, getting an element spins forever in ghci
16:09:04 <startling> > element 1 .~ 0 $ [1]
16:09:06 <lambdabot>   *Exception: elementOf: index out of range
16:09:13 <DMcGill> how would I decide on Yampa vs Netwire?
16:09:20 <Nereid> > element 1 .~ 0 $ [1..5]
16:09:22 <lambdabot>   [1,0,3,4,5]
16:10:10 <shachaf> Nereid: Looks like it has some code to handle multiple results or something like that?
16:10:13 <shachaf> It's a bit odd.
16:10:25 <Nereid> I'll leave it to you. :p
16:10:28 <Nereid> gotta go.
16:10:35 <shachaf> Nereid: You should post it on the bug tracker!
16:10:39 <shachaf> If it's a bug.
16:10:40 <startling> > [1] ^. at 0
16:10:42 <lambdabot>   No instance for (Control.Lens.IndexedLens.At k0 [])
16:10:42 <lambdabot>    arising from a use o...
16:10:47 <startling> oh, meh.
16:10:52 <Nereid> shachaf: I'll do it later, then.
16:11:46 <Ghoul> Is there a list somewhere which libraries are purely functional
16:11:55 <Ghoul> ie: only use haskell
16:12:10 <startling> Ghoul, uh
16:14:08 <afshar> hi everyone, I wonder if this could be better expressed, I have: data A = X B | Y B | Z B | ...
16:15:15 <Ghoul> startling: :)?
16:15:40 <DMcGill> Ghoul, ones with no C deps?
16:16:02 <DMcGill> besides, Haskell get compiled into C so what do you care if the time package called the C getCurrentTime or whatever?
16:16:09 <shachaf> afshar: You can write data Tag = X | Y | Z | ...; data A = A Tag B
16:16:50 <Ghoul> DMcGill: Friend told me that purely functional ones benefit from fusion
16:16:55 <Ghoul> by ghc
16:17:05 * hackagebot fsutils 0.1.0 - File system utilities for Haskell that are missing from built in libraries.  http://hackage.haskell.org/package/fsutils-0.1.0 (AnthonySimpson)
16:17:30 <DMcGill> most of the operations you'd be looking to fuse are fusable, I wouldn't worry about it at all
16:17:52 <DMcGill> remember the golden rule: "premature optimisation is the root of all evil"
16:18:03 <Ghoul> I repent, I repent D:
16:18:14 <afshar> shachaf: ah yes, thanks
16:18:26 <DMcGill> ~ Donald Knuth
16:18:39 <DMcGill> I should source my quotes more often
16:19:10 <sipa> "Who are you and what are you doing in my home?"
16:23:07 <jrajav> Ohh xkcd
16:23:12 <jrajav> The monty python of nerds
16:23:13 <jrajav> :P
16:23:34 <startling> jrajav, that's like saying "the haskell of programming"
16:23:55 <jrajav> I.. guess?
16:24:27 <dino-> Nereid: Thanks again for the gtk2hs for 7.6.x. Excellent that it was on patch-tag too and not some *hub blah blah
16:27:08 <Nereid> I used to think that that pigeonhole argument that if you have two kinds of socks then you can always get a matching pair by grabbing 3 was a bit contrived.
16:27:08 <Nereid> but I use it all the time now. :s
16:28:04 <Nereid> because all my socks are the same colour and it's hard to tell the two kinds apart without looking closely.
16:28:16 <EvanR7> thats such a great idea
16:28:27 <Boney> no it doesn't work, the 3rd sock you pickup might be the same kind as the 2 you're already holding.
16:28:27 <EvanR7> will now reduce my socks to two kinds
16:28:27 <Cale> I usually end up just taking a pair which are similar enough.
16:28:52 <Nereid> Boney: yeah but then the first two would already be a matching pair :p
16:29:02 <Boney> but yes. I solve this problem by owning only black socks, and I'm half blind so this works pretty well.
16:29:12 <Boney> Nereid: oh my mistake.
16:29:19 <Nereid> I have two kinds of black socks though.
16:29:31 <fengshaun_> is there a book that goes through what lyah doesn't (like arrows and more advanced stuff)?
16:29:38 <Boney> i was trying to pick two distinct socks which isn't helpful.
16:29:43 <Nereid> heh.
16:29:57 <fengshaun_> Boney, it's always better to match the socks you're picking!
16:30:03 <dino-> I pair them all and fold them together as part of finishing laundry. Socks whose mate has somehow fallen into a rip in the fabric of spacetime go into a special pile of their own.
16:30:12 <Boney> anyway. having only one kind solves my problem since all (most men's) socks look alike to me.
16:30:16 <DMcGill> fengshaun_ by that point I think you're better off looking at specific tutorials rather than a book
16:30:19 <Nereid> dino-: I'm too lazy to do that. :p
16:30:40 <EvanR7> now it sounds like a computer science theorem: its impossible to get heterosocks by picking 3 and having only 2 kinds
16:30:43 <fengshaun_> DMcGill, well, the thing is, I wouldn't know what I should be searching for!
16:30:54 <Cale> fengshaun_: I think the best thing is to start looking at papers by Simon Peyton Jones and others. Many of them have sections which are very casually readable.
16:30:56 <Boney> that said. I might have more than one type of sock in my drawer and I may be ignorant of it.
16:31:00 <fengshaun_> I had only passively heard of arrows on this channel
16:31:09 <DMcGill> I don't know any off the top of my head, but the Arrows page on  HaskellWiki is usually a good place to start
16:31:18 <shachaf> You don't need to care about Arrow much.
16:31:31 <fengshaun_> shachaf, that was just an example
16:31:36 <Nereid> lots of arrows come from monads, though
16:31:37 <Cale> Learn about Arrow once you find a library which uses it :)
16:31:42 <Nereid> ^
16:31:44 <startling> (&&&) is much more useful than Arrow.
16:31:49 <DMcGill> well the answer is still the same: HaskellWiki's page on a topic is usually a good place to start
16:31:52 <fengshaun_> Cale, fair point
16:31:55 <Nereid> sure, the arrow functions are pretty useful just for the (->) arrow.
16:31:57 <fengshaun_> startling, what is &&&?
16:32:04 <DMcGill> :t (&&&)
16:32:05 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:32:06 <Nereid> @type (&&&)
16:32:08 <Cale> (&&&) is one of the Arrow combinators
16:32:08 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
16:32:11 <startling> > ((+ 1) &&& (+ 2)) 0
16:32:13 <lambdabot>   (1,2)
16:32:19 <shachaf> Man, remember DRMacIver?
16:32:21 <dalaing> fengshaun_: are you after arrows in particular, or just a next step after LYAH?
16:32:30 <Cale> fengshaun_: It can be nice to know that (->) is an instance of Arrow, and just look at how the stuff in Control.Arrow specialises
16:32:36 <fengshaun_> dalaing, next step after lyah!
16:32:43 <Nereid> ...
16:32:43 <Nereid> for the (->) arrow, it's
16:32:43 <Nereid> (b -> c) -> (b -> c') -> b -> (c,c')
16:32:50 <Nereid> oh whoa, I lagged a bunch.
16:32:55 <dalaing> fengshaun_: I found "write yourself a scheme in 48 hours" pretty useful after LYAH
16:32:58 <Cale> fengshaun_: Because there are some handy things in there for working with pairs, once you specialise to the case of functions.
16:33:07 <fengshaun_> dalaing, thanks a lot!
16:33:25 <fengshaun_> Cale, thanks for the pointer
16:33:28 <dalaing> fengshaun_: and also intro to functional programming by Bird and Wadler (print book) because it has exercises - it's been updated now I think
16:33:42 <fengshaun_> dalaing, awesome!  thanks! :D
16:33:43 <dalaing> fengshaun_: and if you haven't read Typeclassopedia yet it's also great
16:33:48 <DMcGill> oh yes
16:33:57 <DMcGill> Typeclassopedia is amazing, and a great next step
16:34:00 <DMcGill> @where typeclassopedia
16:34:00 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
16:34:09 <DMcGill> also comes with lots of exercises (which you should do all of)
16:34:10 <fengshaun_> how about RWH?
16:34:18 <fengshaun_> real world haskell
16:34:38 <Cale> The "Composable memory transactions" paper here is a particularly good one, about a library for thread communication in concurrency which is implemented in GHC: http://research.microsoft.com/en-us/um/people/simonpj/papers/stm/index.htm#composable
16:34:39 <Nereid> I thought it was worth reading.
16:34:42 <Nereid> @where rhw
16:34:42 <lambdabot> I know nothing about rhw.
16:34:42 <dalaing> fengshaun_: I struggled with it early on, for me some of it wasn't well ordered or motivated - was excellent when I came back later
16:34:43 <Nereid> @where rwh
16:34:43 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
16:34:44 <Cale> RWH is good
16:34:54 <Nereid> it's a bit dated though
16:35:01 <Cale> Also I think there could be something a lot better.
16:35:12 <Cale> I just need to write it :P
16:35:13 <Cale> lol
16:35:13 <dalaing> fengshaun_: I highly recommend it - although I try to insert caveats when people talk about doing it straight after LYAH
16:35:15 <Nereid> lol
16:35:18 <fengshaun_> it's good for quick tutorial-style reading, I guess
16:35:38 <fengshaun_> dalaing, I'll keep that in mind
16:36:21 <dalaing> fengshaun_: I found it good for a deep, thorough, end to end read to get my "strategic thinking" going once I already knew a lot of the smaller concepts to deal with the "tactical thinking"
16:36:45 <dalaing> fengshaun_: but I'm still very newbish so others probably have more / better to say
16:36:50 <dino-> How important is it to know Scheme ahead of time for that?
16:37:04 <fengshaun_> thanks all!
16:37:06 <fengshaun_> :D
16:37:07 <dalaing> although TAPL is only a book or two away from the front of my reading queue...
16:37:16 <dalaing> dino-: for which?
16:37:36 <dino-> For that "Write Yourself A Scheme.."
16:37:54 <dalaing> dino-: not at all, for the most part - I had passing familiarity with bits of lisp ahead of time
16:38:25 <dalaing> I've been working through SICP since then to try to get my functional thinking foo up, so that might have muddled my memories on that front
16:38:47 <dino-> dalaing: ok, thanks
16:39:00 <fengshaun_> dalaing, TAPL?
16:39:15 <dalaing> fengshaun_: Types and Programming Languages
16:39:24 <fengshaun_> thanks
16:39:35 <dalaing> fengshaun_: my impression is that one is for later on
16:40:20 <fengshaun_> woah, way too abstract for my taste!
16:41:50 <dalaing> fengshaun_: I've just seen so much magic from others and decided I wanted to get into it, so I've been mathsing / reading up in order to comes up to speed with a few of the theory heavy topics
16:42:13 <fengshaun_> interesting
16:42:32 <dalaing> fengshaun_: I seem to go from considering stuff "abstract" to "must learn" in the space of one or two blog posts showing practical applications of the theory
16:43:00 <uniquenick> how can I use a function that returns "IO Bool" in an if statement?
16:43:01 <Cale> fengshaun_: many of Wadler's papers are also relevant and interesting: http://homepages.inf.ed.ac.uk/wadler/
16:43:14 <Hail_Spacecake> how do I map a function from FilePath -> IO () to a list of strings?
16:43:23 <Raynes> Peaker: Wow, that was quick work. :p
16:43:30 <dalaing> +1 on Wadler's papers
16:43:39 <Hail_Spacecake> specifically I have a list of strings and I want to call createDirectory on each string
16:43:47 <Peaker> Raynes, heh :)
16:43:49 <Cale> uniquenick: run the action beforehand, and use if on the Bool result.
16:43:50 <Hail_Spacecake> to do that IO action a bunch of times
16:44:00 <Cale> Hail_Spacecake: mapM_
16:44:04 <Hail_Spacecake> but in genreal I don't understnad why I can't just use map
16:44:10 <Cale> Hail_Spacecake: Well, if you use map...
16:44:16 <Peaker> Raynes, I kept rewriting those same functions myself! So when I saw the hackage announce here I checked it out.. github makes contributions easy
16:44:17 <Cale> map :: (a -> b) -> [a] -> [b]
16:44:39 <Cale> So  map createDirectory :: [FilePath] -> [IO ()]
16:44:46 <Hail_Spacecake> Cale: right, but what's wrong with having a list of IO () ?
16:44:54 <Cale> Hail_Spacecake: So you end up with a list of IO actions, and you want to run each of them
16:45:02 <Hail_Spacecake> I mean, it's not useful, the IO effect is what I care about
16:45:07 <Hail_Spacecake> ooh
16:45:13 <Cale> So we could write a function to combine those IO actions into a single one:
16:45:17 <Cale> sequence [] = return []
16:45:29 <Cale> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
16:45:33 <fengshaun_> Hail_Spacecake, by using map, you're not actually "doing" the action
16:45:45 <Hail_Spacecake> aah, okay
16:45:46 <Raynes> Peaker: Thanks for the contributions! I haven't touched Haskell in like 3 years, so reviews are nice. :)
16:45:46 <Hail_Spacecake> that makes sense
16:45:57 <Cale> sequence :: [IO a] -> IO [a]
16:46:17 <Cale> and running the action which is the result of the sequence will run all the actions and produce a list of their results
16:46:19 <Hail_Spacecake> Cale: so once I have that list of IO actions, I can call sequence on it to actually run them?
16:46:23 <Cale> yes
16:46:26 <Cale> so we define
16:46:36 <Cale> mapM f xs = sequence (map f xs)
16:46:48 <Hail_Spacecake> ah
16:46:58 <Cale> Also, sometimes, like in this case, we're not actually interested in the results of the individual actions
16:47:04 <Cale> So there's a variant which discards them
16:47:05 <Peaker> Raynes, hlint is really nice.. tells you about things like using:  foo >>= return . ...  being fmap, etc
16:47:09 <Hail_Spacecake> so that's mapM vs mapM_
16:47:09 <Hail_Spacecake> okay
16:47:12 <Cale> yeah
16:47:15 <EvanR7> mapM = sequence .: map
16:47:27 <Peaker> mapM = (fmap . fmap) sequence map
16:47:32 <Hail_Spacecake> so, hm, mapM_ can't be defined in temrs of squence, if I understand correctly
16:47:38 <Raynes> Yeah, definitely going to use hlint.
16:47:41 <Peaker> or    fmap sequence . map
16:47:42 <Raynes> Cool stuff.
16:47:53 <Hail_Spacecake> because sequence has to return that list of [()]'s
16:47:58 <Peaker> it even finds code duplication! which is pretty awesome
16:47:59 <Eduard_Munteanu> mapM = ((.) . (.)) sequence map
16:48:07 <Cale> Hail_Spacecake: Right, so we can just define a simplified sequence_
16:48:13 <Cale> sequence_ [] = return ()
16:48:22 <Cale> sequence_ (x:xs) = x >> sequence_ xs
16:48:41 <Peaker> I hate the trailing underscore functions.. especially in parsers. you have to duplicate all code just to ignore the results
16:48:44 <DMcGill> mapM_ f xs = const () <$> (mapM f xs) right?
16:48:44 <Cale> Or:  sequence_ (x:xs) = do x; sequence_ xs
16:48:46 <Eduard_Munteanu> @unpl ((.) . (.)) sequence map
16:48:46 <lambdabot> (\ c f -> sequence (map c f))
16:49:03 <DMcGill> or mapM_ = const () .: mapM of course
16:49:03 * EvanR7 gets washed away in unreadable functional programming
16:49:33 <Cale> DMcGill: semantically, yeah, though there's a performance difference
16:49:47 <EvanR7> Peaker: can you just use void
16:50:07 <Peaker> EvanR, it would be nice if you could do that and GHC removed the results piling up in memory
16:50:31 <Peaker> EvanR, I think it doesn't optimize that, so you still have to duplicate code :(
16:50:46 <EvanR7> template haskell 2 the rescue
16:50:48 <Cale> Hail_Spacecake: So, that's the nice thing about IO actions being first class values. Practically any control structure we could possibly want can be implemented as a library function.
16:51:14 <Cale> Hail_Spacecake: and you can glue the IO actions together very safely without worrying about the effects going off at the wrong time
16:51:20 <Peaker> DMcGill, x <$ y = const x <$> y
16:51:51 <Peaker> DMcGill, so mapM_ f xs = () <$ mapM f xs   (except for a performance hit).  And also:  void = (() <$)    so it's    void $ mapM f xs
16:51:59 <DMcGill> I think I need to spend more time messing around with the applicative stuff before I realise internalise it
16:52:05 <DMcGill> s/realise/really
16:52:36 <Peaker> DMcGill, that's just Functor stuff
16:52:41 <Peaker> @type (<$)
16:52:43 <lambdabot> Functor f => a -> f b -> f a
16:52:46 <Cale> Heh, it's a bit funny though, that since there are so many variations of loop constructs, we actually implement very few of them, just because explicit recursion usually wins out over trying to remember what all the variations mean.
16:53:14 <Cale> It can be helpful to note that fix works very nicely as a generalised sort of looping primitive
16:53:17 <Peaker> Cale, you mean stuff like unfoldr, foldAcc, etc?
16:53:30 <hiptobecubic> Cale, no it doesn't. It works hideously.
16:53:32 <EvanR7> whileM
16:53:40 <Cale> Peaker: I mean like things analogous to while and such
16:53:53 <Cale> hiptobecubic: How so?
16:53:56 <edwardk> the best thing about the curry-howard correspondence. logically fallacies become useful combinators. fix is 'assuming the hypothesis'. loeb's paradox works kinda like a spreadsheet, etc.
16:54:00 <Peaker> I find that I very rarely need whileM though
16:54:16 <hiptobecubic> Cale, because anytime someone solves something with fix, it takes ten minutes to figure out what they were trying to do.
16:54:28 <edwardk> > fix error
16:54:30 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
16:55:35 <Cale> hiptobecubic: fix $ \loop -> do ... ; loop   is the same as  let loop = do ... loop in loop
16:56:03 <monochrom> anytime someone solves something with haskell, it takes ten days to figure out haskell. for those people who haven't learned haskell
16:56:03 <Cale> hiptobecubic: and it works if you add parameters to the loop
16:56:23 <Cale> fix $ \loop n -> do ... ; loop (n-1)
16:56:33 <monochrom> this is supposed to conclude that haskell is hideous
16:56:50 <Cale> well, you'll need to fill those parameters with initial values after
16:56:56 <monochrom> anyway, http://www.vex.net/~trebla/haskell/fix.xhtml . it's a solved problem.
16:57:17 <hiptobecubic> ok, if you use it very tamely and in a way like you're describing, then it's understandable, but why use it instead of a let construct in that case
16:57:44 <Cale> hiptobecubic: Well, because it can be awkward to define the thing with a let block immediately before using it exactly once
16:58:11 <Cale> and because you're in a do-block, you maybe want to capture the local values of variables bound earlier in the action
16:58:28 <Cale> and so separating the thing off into a 'where' often isn't so great either
16:58:40 <Cale> (you end up with lots of extra function parameters)
16:58:49 <Cale> I'm not saying you'll need it all the time
16:58:53 <hiptobecubic> Cale, I don't see how your fix loop example is better than the let loop = do... example
16:59:05 <hiptobecubic> Cale, it's not shorter, nor is it more clear
16:59:09 <Cale> It's a bit clearer if it's not all on one line
16:59:33 <Cale> (what the difference is)
16:59:41 <Cale> But I'll admit it's not a big difference
16:59:52 <hiptobecubic> The let construct would also be more clear though
16:59:55 <koninkje> hiptobecubic: the benefit of fix over recursive let is that fix is first-class
17:00:31 <hiptobecubic> the let block is an expression too, not magical
17:00:39 <koninkje> In general, when you can eliminate syntax and make things first-class, that's a good thing; even if most people will only ever use the syntax
17:01:15 <Cale> It's possible to imagine that the compiler turns recursion in let into uses of fix
17:01:18 <dalaing> I was bracing for a discussion about how passing around a partially applied fix function leads to perfectly clear code
17:01:53 <Cale> dalaing: Well, fix only has one parameter, so that would be fully applied :)
17:01:53 <hiptobecubic> Cale, maybe so, but the compiler does a lot of things you wouldn't want to write (or read).
17:02:09 <koninkje> dalaing: well, if you want to have the non-recursive version of the function on hand anyways...
17:02:26 <Cale> hiptobecubic: Sure.
17:02:50 <Cale> hiptobecubic: But it's nice to have mental models of how things operate, which are usable at the level of expressions
17:03:28 <b44> How would you calc n in N that is 2^i for i in N such that n mod 3 = 0 ?
17:04:20 <Cale> b44: You're asking for powers of two which are divisible by 3? There are not many of those.
17:04:33 <dalaing> Cale: I was more worried about fix with a series of flips and and argument about clarity
17:04:51 <dalaing> Cale: actually, I was really just worried about papers being cited and my reading queue doubling again
17:04:54 <DMcGill> [n | i <- [1..], let n = 2^i, n `mod` 3 == 0]
17:04:57 <dalaing> sigh
17:04:59 <DMcGill> or a shorter version: []
17:05:40 <b44> Cale: there aren't infinite many?
17:05:45 <DMcGill> ‚àÖ for the math people out there
17:06:03 <DMcGill> b44: every power of 2 can be written as 2x2x2x2x...
17:06:04 <b44> hmm
17:06:25 <DMcGill> to be divisible by 3, one of its factors needs to be 3
17:06:31 <DMcGill> this isn't the case, as they're all 2
17:06:37 <b44> ah... thanks, I see
17:06:58 <Cale> If you were asking for i to be divisible by 3
17:07:01 <Cale> then there are lots
17:10:46 <mm_freak> @tell donri it was rather for Num literals, but i might add string literals as well =)
17:10:46 <lambdabot> Consider it noted.
17:10:59 * ezyang hasn't quite figured out how to avoid marching cases when each failure case is its own ADT 
17:11:23 <shachaf> Marching cases?
17:11:41 <ezyang> Where you have case of ... and the indentation keeps increasing
17:11:58 <shachaf> Ah, that.
17:12:04 <hpc> ezyang: so you have lots of different error types?
17:12:08 * hackagebot netwire 4.0.5 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.5 (ErtugrulSoeylemez)
17:12:18 <ezyang> hpc: Yep
17:12:18 <DMcGill> ezyang: helper functions?
17:12:38 <ezyang> DMcGill: Maybe.
17:12:59 <ezyang> But I still need a short-circuiting IO monad
17:13:55 <hpc> is it a fixed set of lots of error types?
17:14:03 <hpc> or would you expect to be writing more?
17:14:13 <hpc> you can do a stack of ErrorT
17:14:20 <ezyang> Eww.
17:14:50 <shachaf> Can you give an example of the code involved here?
17:15:24 <ezyang> For example, suppose I'm using 'plugins'. I need to build a file and then load it.
17:15:34 <ezyang> that's two case matches
17:16:00 <DMcGill> this does sound like a classic case for MaybeT, EitherT or ErrorT
17:16:15 <uniquenick> has anyone here tried using the libtcod haskell module?
17:24:30 <XWNH> how do I tell the compiler which type I want? Data.Map.fromList is interpreting its argument as an integer instead of an int
17:24:46 <DMcGill> XWNH: "3 :: Int"
17:24:54 <DMcGill> with brackets as needed
17:25:20 <shachaf> Or by giving a type to something somewhere.
17:25:30 <DMcGill> "[1,2,3] :: [Int]" or "[1,2,3 :: Int]"
17:25:33 <EvanR7> put top level type signatures or something
17:25:37 <shachaf> foo :: Map String Int; foo = M.fromList [("a",5),("b",3)]
17:26:25 <XWNH> alright, thanks everyone
17:33:13 <fenton> I'm having problems resetting my haskell environment, could someone have a look: http://goo.gl/HdVQH
17:34:01 <monochrom> you forgot: ~/.ghc
17:34:16 <ivanm> I wouldn't delete ~/.cabal before you backed up ~/.cabal/config
17:34:32 <monochrom> in fact it was unnecessary to erase /usr/lib/ghc-7.6.1/package.conf.d . now you have to re-install GHC
17:34:36 <rwbarton> these are weird instructions
17:34:43 <ivanm> and if GHC was installed with your package manager, you shouldn't delete /usr/lib/ghc-7.6.1/package.conf.d
17:34:47 <fenton> rwbarton: i just made them up myself!
17:34:47 <ivanm> rwbarton: agreed
17:34:59 <monochrom> oh, you did not forget ~/.ghc
17:35:05 <ivanm> some package managers might complain if you delete files it installed
17:35:17 <fenton> ivanm: pacman didn't say anything...
17:35:28 <ivanm> fenton: still better not to
17:35:28 <monochrom> but you do have to re-install GHC now because you have damaged it
17:35:35 <ivanm> also, doesn't pacman have cabal-install?
17:36:01 <ivanm> fenton: but my guess is that you deleted packages from your global install
17:36:05 <ivanm> monochrom: yup
17:36:25 <monochrom> next time you should read my http://www.vex.net/~trebla/haskell/sicp.xhtml
17:36:30 <fenton> ivanm: srry, u might want to refresh page...i did re-install ghc.
17:36:42 <fenton> monochrom: ok let me have a look at yours...
17:37:53 <monochrom> perhaps pacman does not re-install ghc. and why should it, it doesn't know that you have damaged ghc
17:38:14 * ivanm still begs to differs with parts of monochrom's SICP
17:38:23 <Nereid> fenton: don't touch /usr
17:38:45 <ivanm> Nereid: with the exception of /usr/local ;-)
17:38:51 <Nereid> sure.
17:38:57 <monochrom> don't touch /usr/lib
17:39:11 <ivanm> fenton: you'd be better off uninstalling ghc, then deleting /usr/lib/ghc-<version> if it still exists, then re-installing ghc
17:39:31 <Nereid> % touch /usr
17:39:31 <Nereid> touch: setting times of ‚Äò/usr‚Äô: Permission denied
17:39:32 <Nereid> aww.
17:40:00 <ivanm> heh
17:40:23 <Nereid> I guess I need to sudo touch /usr !
17:40:25 <fenton> okay, pacman didn't complain, but i agree with the ordering of -ghc, rm dirs, +ghc.
17:40:25 <koala_man> how can I check if stdout is a tty? I found isTerminal in GHC.IO.Device, but I can't figure out how to use it
17:40:52 <Nereid> koala_man: hIsTerminalDevice
17:40:53 <monochrom> pacman and apt-get and yum etc clearly do not go out of their way to verify file presence and integrity to decide whether to re-install
17:41:38 <monochrom> conclusion: do not think of package managers to be omnipotent, omniscient, benevolent, omnipresent
17:41:53 <monochrom> there is no flying spaghetti package manager
17:42:25 <koala_man> Nereid: awesome, thanks!
17:42:26 <monochrom> so yes, there are a whole lot of simple problems that package managers will not detect or complain
17:44:03 <Nereid> fwiw gentoo keeps track of files and mtimes and such when it installs a package
17:44:06 <monochrom> pacman cannot even defeat ghosts when not given the pill
17:45:26 * gienah vaguely recalls pacman has an option to check an installed pkg
17:46:04 <fenton> does anyone have vetted un-install instructions?
17:46:10 <Nereid> but in general, don't step on your package manager's toes :>
17:47:09 <monochrom> there is actually a superb reason to exempt /usr/lib/ghc-7.6.1/package.conf.d from, say, mtime checks and hash checks. it keeps changing
17:47:59 <monochrom> well, I guess some files under /usr/lib/ghc-7.6.1/package.conf.d could be checked, they do not change
17:48:07 <Nereid> I only ever install packages in user, so.
17:48:17 <Ghoul> @typeof hIsTerminalDevice
17:48:18 <lambdabot> Not in scope: `hIsTerminalDevice'
17:48:28 <Ghoul> @typeof GHC.IO.hIsTerminalDevice
17:48:29 <lambdabot> Not in scope: `GHC.IO.hIsTerminalDevice'
17:48:31 <Nereid> @hoogle hIsTerminalDevice
17:48:32 <lambdabot> System.IO hIsTerminalDevice :: Handle -> IO Bool
17:48:32 <lambdabot> GHC.IO.Handle hIsTerminalDevice :: Handle -> IO Bool
17:48:43 <ivanm> Ghoul: @type doesn't always work, as not everything is in scope
17:48:51 <Ghoul> hm
17:48:55 <monochrom> you mean you don't even ask pacman for parsec?
17:48:58 <Nereid> import AbsolutelyEverything
17:49:14 <Nereid> monochrom: me? (I don't use arch but) yeah
17:49:25 <ivanm> monochrom: Portage and Paludis will both force a re-installation if you tell it to
17:49:35 <ivanm> rather than just going "oh, it's installed, I won't do so again"
17:49:45 <Nereid> which is sane
17:49:58 <Nereid> pacman doesn't have any way to force reinstallation?
17:50:11 * ivanm has never used pacman, so has nfi
17:50:16 * Nereid either
17:50:31 <monochrom> and I'm on ubuntu, and I don't use ubuntu's ghc
17:50:34 <fenton> Nereid: well u can uninstall and re-install
17:50:42 <fenton> -R = remove, -S = install
17:50:46 <Nereid> sure
17:51:29 <fenton> a bit odd that there wouldn't be un-install instructions somewhere.
17:51:29 <Nereid> and portage's idea of install is "install, but remove any previous versions first"
17:51:30 <Nereid> which is sane
17:52:01 * ivanm always finds it weird when GHC throws warnings about its own source code
17:52:09 <Nereid> but yeah, if I wanted a clean reinstall
17:52:14 <Nereid> I'd uninstall everything
17:52:21 <Nereid> and *then* delete /usr/lib/ghc-blah and so on
17:52:22 <monochrom> format C:
17:52:24 <fenton> I've been using cabal install to install things too.
17:52:41 <fenton> monochrom: wont do much on linux...thankfully!
17:53:03 <Nereid> I'd keep .cabal/{config,world} and world some things in .cabal/bin though
17:53:08 <Ghoul> after exams Im going to try and do a seamless archlinux thing using virtualbox
17:53:10 <fenton> Nereid:  why?
17:53:21 <ivanm> fenton: well, keep config so you have your config settings
17:53:28 <ivanm> world so you know which packages you want to re-install
17:53:37 <monochrom> because .cabal/config is a config file, and .cabal/bin has useful programs
17:53:45 <ivanm> bin/ so that you won't get errors about needing alex, etc.
17:53:52 <fenton> ivanm: oh just as a backup reference?
17:54:00 <ivanm> and thanks to static linking, they're independent of GHC version
17:54:16 <ivanm> fenton: I don't reference config, I just re-use it
17:54:24 <monochrom> and the rest of .cabal, if you erase things, you're just reclaiming disk space, you're not really solving any consistency problem
17:54:31 <fenton> ivanm: at this point I'm just trying to get a working system, and I don't care about a full re-install, i'm happy to do that to get a working ssytem.
17:55:01 <Nereid> I have cabal-install in .cabal/bin, and I'd kepe it so that I don't have to track down all its dependencies to reinstall it again.
17:55:10 <Nereid> keep.
17:55:14 <ivanm> monochrom: I think there used to be some errors caused by a dodgy download of corrupted 00-index.tar.gz files
17:55:15 <monochrom> .ghc is where all the consistency problems are
17:55:32 <fenton> monochrom: let me look to see if that is still around...
17:56:53 <fenton> monochrom: it was still there...removing and reinstalling ghc/cabal-install...we'll see what happens!
17:57:10 * hackagebot flat-mcmc 0.1.0.0 - Painless general-purpose sampling.  http://hackage.haskell.org/package/flat-mcmc-0.1.0.0 (JaredTobin)
17:57:48 <ivanm> why "painless"? is there actually a package that provides _painful_ general-purpose sampling?
17:58:14 <Nereid> :V
17:58:21 <monochrom> perhaps everyone should use cabal-dev or virthual-env
17:58:41 <ivanm> I might start using sandboxing when cabal-install supports it
17:58:42 <stepcut> >:8
17:58:48 <ivanm> but I've had no need of it so far
17:58:55 <stepcut> perhaps we should fix cabal :)
17:58:57 <ivanm> especially since all my packages tend to be interconnected
17:59:23 <Nereid> hmm, haven't heard of virthualenv.
17:59:23 <monochrom> it is actually pretty easy to sandbox by hand
17:59:54 <monochrom> export GHC_PACKAGE_PATH=/sandbox:
18:00:11 <monochrom> cabal install --prefix=/sandbox --package-db=/sandbox
18:00:36 <Nereid> laziness though
18:00:48 <monochrom> (don't forget the ":" in the GHC_PACKAGE_PATH line)
18:01:24 <monochrom> but yes, automation is less work and less error-prone. do not trust humans
18:01:43 <Nereid> least of all yourself
18:01:44 <Nereid> :p
18:01:58 <monochrom> I have denounced my humanship. don't you worry
18:02:15 <Nereid> lol
18:02:32 <monochrom> e.g., whereas you people say \o/ , I say \‚à©/
18:02:59 <ivanm> monochrom: you're wearing a helmet?
18:03:07 <monochrom> that's a robot's head!
18:03:07 <spaceships> monochrom: denouncing your humanship is not a good way to pass a turing test
18:03:44 <hpc> whenever someone does /o\, i just think they have one giant testicle
18:04:09 <monochrom> turing test: https://plus.google.com/u/0/102208456519922110915/posts/RdfEqPNZgwT
18:04:15 <Jetbeard> you know, i was just thinking to myself "#haskell isn't discussing testicles enough"
18:04:54 <hpc> Jetbeard: it's true; just the one
18:05:13 <monochrom> the turing test is superseded by the monochrom test
18:05:53 <monochrom> the monochrom test: you ask the candidate 290384903+12098392 to determine whether it is a human or a computer
18:06:03 <Jafet> http://uncyclopedia.org/wiki/Turing_Duck_Test
18:06:36 <monochrom> this is based on: Intelligence: ... 5. the ability to perform computer functions. (webster)
18:07:04 <Jetbeard> monochrom, does this test differentiate between a computer and a human with access to a computer? (is the distinction even philosophically relevant?)
18:07:29 <monochrom> it has a chance to differentiate them. the human may have typos
18:07:58 <hpc> monochrom: the answer is obviously 95
18:07:59 <monochrom> but if you say, the human has a usb 3.0 connection with the computer, then the test does not differentiate
18:08:40 <spaceships> i tend to just ask everyone whether they are a robot directly
18:09:06 <monochrom> there is also the #haskell test
18:09:20 <monochrom> the #haskell test is done as follows:
18:09:21 <monochrom> @bots
18:09:22 <lambdabot> :)
18:09:25 <monochrom> @humans
18:09:25 <lambdabot> Unknown command, try @list
18:09:38 <spaceships> @src monochrom
18:09:39 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
18:09:46 <monochrom> umm, you guys are supposed to reply ":)" :)
18:10:03 <geekosaur> didn't PKD cover that one?
18:10:14 <monochrom> PKD?
18:10:25 <Jafet> :*** Exception: stack overflow
18:10:33 <simpson> :3
18:10:36 <geekosaur> Philip K. Dick, "The Impostor"
18:11:03 <monochrom> search through #haskell logs. there was once someone saying @humans, and a whole bunch of us replying :)
18:11:21 <monochrom> or maybe @human
18:11:22 <Peaker> the process conduit does not seem to parallelize reading from the process with writing to its input :( nor does it support inheriting stdin... I think I'll use a manual forkIO-with-some-reads solution
18:12:05 <monochrom> I have not read or seen The Imposter
18:15:18 <fenton> monochrom: thanks 'rm -rf ~/.ghc' nailed it!!! thanks again all for your help: ivanm, etc...
18:15:27 <startling> @pl \a b c -> a b (c b)
18:15:27 <lambdabot> (`ap` flip id) . ((.) .)
18:15:28 <monochrom> you're welcome
18:15:35 <monochrom> I mean \‚à©/
18:15:42 <dibblego> startling: a <*> c
18:15:55 <dibblego> @pl \a c b -> a b (c b)
18:15:56 <lambdabot> ap
18:16:10 <startling> dibblego: oh neat
18:16:31 <Nereid> @unpl \a b c -> (a `ap` c) b
18:16:31 <lambdabot> \ a b c -> (a >>= \ e -> c >>= \ d -> return (e d)) b
18:16:35 <Nereid> ...
18:17:22 <startling> Nereid: oh! it all makes sense now!
18:17:37 <Nereid> I hope not because of that last line.
18:17:47 <Nereid> er, the response.
18:18:12 <Nereid> ap = (<*>) though
18:18:24 <startling> Nereid: ;)
18:18:33 <Nereid> also known as the S combinator
18:25:56 <startling> Nereid, what was that? the sparrow?
18:27:35 <monochrom> heh
18:28:26 <mm_freak> Nereid: the S combinator is a specific instance of (<*>)
18:33:32 <fenton> hmmmm... pacman: ghc + cabal-install ok.  cabal update and cabal install cabal-install, ok.  cabal install xmonad, ok. cabal install darcs, die...:(
18:34:32 <Saizan> fenton: use pacman for darcs
18:34:45 <fenton> Saizan: ok
18:35:24 <monochrom> I wonder if you really need cabal install cabal-install
18:35:35 <Ghoul> Does haskell have nice osx support?
18:35:42 <Ghoul> if I use cabal and such
18:35:48 <Ghoul> Because Im about to install osx on my machine
18:35:49 <mzero> it works great on osx
18:35:59 <Ghoul> Great, thanks :)
18:35:59 <mzero> but there isn't much osx native lib support
18:36:18 <mzero> i reccomend installing via haskell platform
18:36:28 <mzero> (though I'm somewhat biased on that... :-)  )
18:36:29 <fenton> monochrom: I'm just trying to use as much created by cabal itself, versus arch packages...
18:36:30 <Ghoul> Okay
18:36:53 <mzero> fair warning: we are due to release a new version of Haskell platform tomorrow (!)
18:37:04 <rwbarton> for 7.6?
18:37:06 <mzero> but the current release is fine, so get that
18:37:07 <shachaf> mzero: Is the 32-bit OS X crash fixed?
18:37:12 <monochrom> this changes everything. again
18:37:17 <shachaf> The thing with rounding floating point numbers.
18:37:28 <mzero> no - ghc 7.6 came out too close to this release for us to include it in the platform
18:37:38 <rwbarton> ah ok
18:37:38 <mzero> shachaf... what 32-bit OS X crash!?!?!?!!
18:37:45 <monochrom> I guess 7.4.2 is good enough for now
18:37:55 <shachaf> mzero: The one a few people have reported. I don't use OS X so I can't tell you myself.
18:38:01 <mzero> is that in 7.4.1 or 7.4.2 or both
18:38:02 <shachaf> mzero: Something like a bug with (round (-3.5))?
18:38:04 <rwbarton> floor doesn't work or something
18:38:06 <shachaf> Both, I think.
18:38:20 <mzero> well then, no!
18:38:29 <shachaf> :-(
18:38:36 <shachaf> Seems like a pretty significant bug.
18:38:51 <rwbarton> it is a ghc bug presumably?
18:38:57 <mzero> well... 7.6 doesn't yet have enough stability or hackage package support....
18:39:00 <rwbarton> is it in ghc trac?
18:39:06 <shachaf> I think it's there.
18:39:13 <mzero> so, yes, ghc bug - and that means that we've all been living with it for a year
18:39:22 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/7043
18:39:38 <shachaf> Yes, that.
18:40:33 <shachaf> Seems like a pretty significant known bug to release a new platform with.
18:40:43 <shachaf> But I suppose none of the alternatives are particularly good either...
18:40:59 <shachaf> It's even in 7.6.1.
18:41:18 <mzero> well then - not much I can do about it, eh?
18:41:55 <mzero> seems like the regression suite must be lacking if that got through
18:42:20 <shachaf> Well, I mean, who'd round a *negative* number, right?
18:42:58 <mzero> well - they seem to know about it -
18:43:11 <mzero> no I don't know what to do - suggest 64-bit? that has other bugs
18:43:28 <monochrom> best of both worlds. 48-bit :)
18:43:36 <ivanm> GHC 7.6.1 seems to be taking longer to build than previous versions...
18:43:48 <rwbarton> implement round with decodeFloat
18:43:56 <rwbarton> or maybe that is where the segfault is
18:44:22 <mzero> this bug plauges the 64-bit osx build: http://hackage.haskell.org/trac/ghc/ticket/7040
18:44:50 <rwbarton> run a server in a 64-bit vm for rounding negative numbers
18:47:07 <cmears> rounding as a service
18:49:05 <monochrom> at least the 64-bit bug is fixed
18:49:26 <mzero> true - but only in 7.6.1
18:49:36 <shachaf> monochrom: I think AMD decided on the same 48-bit compromise.
18:50:32 <gwern> what's the MIME type for haskell files anyway?
18:50:40 <gwern> text/plain? text/haskell? text/x-haskell?
18:50:41 <shachaf> text/plain
18:50:52 <shachaf> ...OK, it's not text/plain.
18:50:58 <shachaf> But my browser is stupid, so please text/plain.
18:51:08 <monochrom> one moment, I may be able to find out
18:51:25 <shachaf> code.haskell.org serves it as text/x-haskell
18:51:30 <ivanm> which is a PITA
18:51:35 <Ghoul> http://hackage.haskell.org/trac/ghc/ticket/1371
18:51:37 <Ghoul> pls
18:51:42 <Ghoul> lol, I wonder if it will ever get done
18:51:48 <monochrom> ok, what shachaf says, text/x-haskell
18:51:57 <ivanm> I wish c.h.o served them as text/plain
18:52:16 <monochrom> however, I configure my web pages to give you text/plain
18:52:34 <ivanm> monochrom: \o/
18:52:36 <ivanm> monochrom++
18:52:45 <gwern> gnome seems to prefer text/x-haskell
18:52:56 <geekosaur> ideally it should be something like text/plain; x-source-code=haskell
18:52:58 <monochrom> but I'm on the losing side. x-haskell is getting really popular, someone made it a default everywhere
18:53:12 <ivanm> gwern: yes, but wtf would gnome know?
18:53:22 <ivanm> monochrom: which makes it a PITA to read code online
18:53:23 <gwern> standards are better than nothing
18:53:51 <ivanm> until we have our source code saved as ASTs, we should recognise that source code is plain text
18:54:05 <monochrom> ast/x-haskell :)
18:54:09 <shachaf> My source code is definitely plain text, not haskell text.
18:54:34 <shachaf> My compiled binaries have a text section too, so I serve them as text/x86
18:54:38 <monochrom> application/haskell+xml :)
18:54:47 <ivanm> shachaf: heh
18:57:26 <hpc> monochrom: what kind of webserver sends plain text? we should be sending awesome text instead!
18:58:18 <monochrom> ast/x-haskell = awesome text haskell
18:58:42 <hpc> "ast" => "awesome super-text"
18:58:53 <rwbarton> worst are agda source files served without content-encoding
18:58:56 <monochrom> awe some text
18:58:58 <hpc> brought to you by the makers of hypertext
18:59:19 <hpc> rwbarton: oh god, yes
18:59:31 <hpc> and browsers that assume ascii by default
18:59:51 <hpc> when assuming utf-8 is a strict superset
19:00:00 <rwbarton> oh i can fix that in my browser
19:00:10 <rwbarton> default encoding
19:00:11 <ivanm> whereas I've seen sites that seem to serve files as utf8, but the content is actually the windows one, so all these characters are black diamonds... :s
19:00:21 <geekosaur> but it's not the default.  in 2012
19:00:25 <rwbarton> right
19:00:29 <rwbarton> it should be the default default
19:00:36 <hpc> ivanm: i had no idea people still used code pages
19:00:43 <rwbarton> but i guess it is not very windows-friendly
19:00:50 <rwbarton> or old-content-friendly
19:01:00 <shachaf> rwbarton: It is the default default, for most people.
19:01:11 <rwbarton> utf-8?
19:01:12 <shachaf> It's just Microsoft, or something.
19:01:16 <shachaf> It ought to be the default default default.
19:01:21 <hpc> rwbarton: old content assumes ascii if it has no content encoding
19:01:22 <monochrom> chinese webpages using big5, marked as latin-1
19:01:22 <ivanm> ISO-8859-1
19:01:24 <ivanm> that's the one
19:01:29 <hpc> so it's going to be just as broken after as before
19:01:36 <hpc> ivanm: oh, latin1
19:01:38 <shachaf> ivanm: Windows-1252 /= ISO-8859-1
19:01:41 <shachaf> That would be too easy.
19:01:56 <ivanm> shachaf: I didn't say Windows-1252
19:02:08 <shachaf> Oh, you said "the windows one"
19:02:13 <ivanm> but AFAIK, no-one else uses 8859-1
19:02:18 <ivanm> except Windows people
19:02:50 <monochrom> old linux uses latin-1. old ghc uses latin-1
19:02:55 <ivanm> :o
19:03:30 <ivanm> fine then: no-one creates new content using latin-1 except windows people :p
19:03:40 <mzero> heh - don't get tripped up ... our delightful standards folks have now defined that the web encoding "latin1" IS windows-1252
19:03:41 <mzero> http://dvcs.w3.org/hg/encoding/raw-file/tip/Overview.html
19:03:43 <monochrom> windows uses both latin-1 and windows-125x, it depends on specific programs
19:04:57 <mzero> aslo "iso8859-1" and all varients - all must be interpreted as Windows-1252
19:05:02 * mzero goes to cry in his beer
19:05:06 <shachaf> Sometimes Windows uses iso-8859-8.
19:07:34 <monochrom> wikipedia says this difference between windows-1252 and iso-8859-1: windows-1252 has displayable stuff in 80-9F
19:08:11 <mzero> that is correct
19:08:17 <ivanm> so to be accurate, windows-1252 should be interpreted as latin1 rather than the other way round?
19:08:31 <mzero> iso-8859-1 has 32 more control codes there (like we even use the 32 ASCII has... ! )
19:08:38 <Clint> to be accurate, any charset should be interpreted as that charset
19:09:22 <mzero> to be accurate, the WHATWG now declares that web user agents must interpret content labeled "iso8859-1" (and all the variants) as encoded in Windows-1252
19:09:27 <Ghoul> oh wow
19:09:32 <Ghoul> the new codegen looks scarily prototype
19:09:46 <Ghoul> I wonder how far GHC will come before midway next year
19:10:06 <monochrom> well here is the problem. ‚Äú ‚Äù are among those in 80-9F in windows-1252. so if you mislabel as iso-8859-1, you're confusing your audience
19:12:16 <shergill> Ghoul: care to elaborate?
19:15:22 <gienah> ivanm: ok
19:30:36 <bxx> hello. why isn't this workin?  map (read :: Int) ["123", "456", "789"]
19:30:46 <bxx> +g
19:30:55 <startling> bxx, because read isn't an Int.
19:31:30 <startling> you can either do map (read :: String -> Int) [...] or (map read [...]) :: [Int]
19:32:01 <bxx> ok thanks
19:32:29 <startling> > map (read :: String -> Int) ["123", "456", "789"]
19:32:31 <lambdabot>   [123,456,789]
19:35:52 <bimozx> Hello, I hope you guys can help me with a problem I have.
19:36:17 <bimozx> I'm trying to install cabal-dev, but it kept failing on me on the transformer and unix package.
19:36:28 <bimozx> Here is the log.
19:36:30 <bimozx> http://pastie.org/5181226
19:37:09 <bimozx> Is there anything I can do about it?
19:37:54 <ivanm> bimozx: use a newer version of transformers
19:38:03 * ivanm wonders why 0.2.2.0 is being brought in
19:38:40 <ivanm> have you done a cabal update recently?
19:38:45 <ivanm> that version of unix is also really old
19:38:45 <bimozx> Yeah.
19:38:50 <bimozx> I've done it.
19:39:04 * gwern finishes writing a Pandoc program to look at codeblocks and warn you when lines are >110 characters
19:39:05 <bimozx> I've repeat the whole process.
19:39:19 <bimozx> rm -rf ~/.ghc ~/.cabal
19:39:24 <bimozx> Then cabal update
19:39:30 <bimozx> And cabal install cabal-dev.
19:39:31 <gwern> Pandoc should warn you when fixed lines are so wide they'll force browsers to scroll :(
19:39:31 <ivanm> gwern: as in a pre-processor?
19:39:38 <gwern> ivanm: no, think lint
19:40:17 <gwern> ivanm: I'll see if john is open to including it as one of the parser warnings, if not I guess I have another static Markdown checking tool
19:40:22 <ivanm> *nod*
19:40:52 <hpaste> gwern pasted ‚ÄúMarkdown lint: checking for lines so long they force browsers to scroll‚Äù at http://hpaste.org/77268
19:41:10 <fenton> how to install darcs with pacman?  which repo r u referencing?
19:41:41 <ivanm> fenton: there's an #arch-haskell channel or something which might be more relevant
19:41:56 <ivanm> bimozx: oh, cabal-dev hasn't been updated for ghc-7.6.1 by the looks of things
19:42:14 <bimozx> ivanm: That's what I'm afraid of.
19:42:27 <ivanm> bimozx: grab it from github; looks like it's been updated there
19:42:30 <ivanm> just not released yet
19:42:34 <Saizan> fenton: i was sure it was there, it seems i'm wrong though
19:42:37 <bimozx> Cause the unix package is looking for Signals.h and I heard that it's been moved somewhere.
19:42:45 <bimozx> Okay, will do.
19:44:19 <fruitFly> how do I make connections with a no sql database?
19:44:36 <ivanm> fruitFly: you mean with Haskell?
19:44:43 <fruitFly> yes
19:44:59 <rking> That line-lenth-checker is not a great advertisement for Haskell. The ratio of text to essential text is really high.
19:45:03 <ivanm> do you mean "which Haskell libraries let me use a nosql database", or "how do I use said library to connect to my actual database" ?
19:45:04 <rking> s/len/&g
19:45:22 <ivanm> it also depends upon which no-sql db you want to use
19:45:50 <fruitFly> ivanm... mongo, maybe? I'm just trying something
19:46:11 <ivanm> looking on hackage, there's mongoDB
19:46:21 <ivanm> persistent has a mongoDB backend
19:46:28 <ivanm> structured-mongoDB
19:46:40 <ivanm> and snaplet support
19:46:53 <fruitFly> thanks ivanm:
19:47:05 <fenton> ivanm: thx...i'll ask over there.
19:47:31 <gwern> rking: eh, it's not supposed to be great
19:47:40 <fruitFly> so I'm new to haskell and I want to create a webservice and put it in production... what should I know
19:47:40 <gwern> just supposed to work
19:48:07 <rking> gwern: I mean‚Ä¶ perl -ne 'die $_ if /.{110}/'
19:48:13 <ivanm> fruitFly: how to use Haskell? :p
19:48:18 <gwern> rking: what does that do?
19:48:38 <fruitFly> ivanm: I guess that's a good answer
19:49:00 <rking> gwern: The -n flag wraps the arg to -e in a read-each-line loop. So it will run "die $_" whenever /.{110}/ matches.
19:49:11 * ivanm doesn't do any web stuff, so can't really help you
19:49:12 <gwern> rking: what does that match?
19:49:28 <ivanm> gwern: I'm guessing lines with 110 characters in them
19:49:36 <geekosaur> ^^
19:49:45 <ivanm> rking: note that what gwern has done is only check those sections in markdown files that are designated as code blocks
19:49:48 <ivanm> _not_ the entire document
19:49:51 <geekosaur> but it's unanchored, so at least 110 characters
19:49:59 <gwern> rking: that's completely useless then. markdown lines are *usually* more than 110 characters. the only problem is in code blocks
19:50:17 <parcs`> aren't all code blocks in markdown prefixed with > ?
19:50:24 <ivanm> parcs`: nope
19:50:30 <ivanm> not in pandoc-flavoured markdown, anyway
19:50:38 <ivanm> > is used for quotes
19:50:40 <lambdabot>   Not in scope: `is'
19:50:40 <lambdabot>  Perhaps you meant one of these:
19:50:40 <lambdabot>    `id' (imported from ...
19:50:57 <ivanm> ~~~\n<code>\n~~~ is used for code blocks
19:50:57 <parcs`> oh right 4 spaces means it's code
19:51:07 <gwern> parcs`: they are prefixed with >=4 leading spaces, or they exist inside ~~~\n...\n~~~ pairs (where ~~~ is of arbitrary ~s >=3)
19:51:09 <bimozx> ivanm: Thanks the cabal-dev from Github works, I appreciate the help. :)
19:51:15 <ivanm> bimozx: np
19:51:16 <rking> gwern: Any line with ‚â•110 chars.
19:51:16 <parcs`> ah
19:51:31 <gwern> parcs`: and I dunno what other edge cases there are. hence the parsing and AST walking
19:51:36 <parcs`> yeah
19:52:03 <fruitFly> I've always imagine people registering for my web service and their profiles as objects, might anyone be able to help me imagine what type of abstractions a functional language uses to distinguish users
19:52:09 <gwern> now, if perl could parse the markdown, walk the AST for that particular semantic element, run the predicate, and arbot with an informative message - then I would be very impressed by rking's code
19:52:16 <ivanm> it's definitely annoying when someone chooses one of those thin-middle-section-for-text blog themes but then have wide lines of code
19:52:22 <gwern> ivanm: exactly
19:52:22 <rking> gwern: Well, the gist is using a library as well.
19:52:26 <ivanm> especially when you're like me and have a default zoom level
19:52:30 <ivanm> or are viewing it on a phone
19:52:46 <gwern> rking: yes, my hpasted program is using a library, but a library still takes space
19:52:52 <gwern> * a call to a library
19:53:40 <ivanm> rking: which gist?
19:53:57 <rking> ivanm: Sorry, hpaste: http://hpaste.org/77268
19:54:11 <ivanm> gwern: maybe allow an optional line length as an argument?
19:54:18 <ivanm> rking: aren't gists on github though? ;-)
19:54:35 <gwern> ivanm: eh. I could do that but it's more work
19:54:35 <ivanm> (since after all, github can't call them _pastes_ or anything; that's too generic!)
19:55:00 <ivanm> oh, right, arg mangling
19:55:06 <rking> "<rking> ivanm: Sorry, hpaste" ‚Üê I was apologizing for misremembering the code as being hosted on gist.github.com, not hpaste.org. =P
19:55:14 <ivanm> ahhh, fair enough :)
19:55:37 <hpaste> gwern annotated ‚ÄúMarkdown lint: checking for lines so long they force browsers to scroll‚Äù with ‚ÄúMarkdown lint: checking for lines so long they force browsers to scroll (annotation)‚Äù at http://hpaste.org/77268#a77269
19:55:51 <ivanm> gwern: why not just have lineCheck do IO () ?
19:56:33 <rking> gwern: I just mean that the code, if you look at it with C-Ray vision*, has many lines/tokens that don't seem to contribute to the essential problem. (* C-Ray Vision: Sorting out essential complexity from incidental complexity)
19:56:45 <gwern> ivanm: iirc, because then it's not returning any kind of Block, because then it's not a piece of the Pandoc ADT which the generics know, and then I lose the AST walking from bottomUpM
19:57:03 <ivanm> oh, bottomUpM traverses through the entire tree?
19:57:07 <ivanm> nice!
19:57:10 <ivanm> @hoogle bottomUpM
19:57:11 <lambdabot> No results found
19:57:16 <ivanm> didn't think that would work
19:57:19 <gwern> ivanm: yeah. there's also topDown which differs in minor ways
19:57:54 <Jafet> > [ () | let Just 1 = Nothing ]
19:57:55 <lambdabot>   [()]
19:58:07 <Jafet> > [ x | let Just x = Nothing ]
19:58:09 <lambdabot>   [*Exception: <interactive>:3:11-26: Irrefutable pattern failed for pattern ...
19:58:14 <ivanm> oh, it uses generics
19:59:30 <gwern> rking: I dunno what you're complaining about. there's 8 lines of code like 3 of which could be eliminated if you didn't care much about readability. how do you expect to parse args, do IO, custom munge it, parse into markdown, walk the AST, run the predicate, and do nothing or throw an informative error?
20:01:08 <rking> gwern: I can clarify, but it seems like I'm stepping on toes.
20:01:24 * gwern thinks rking just isn't appreciating how much is being done
20:01:51 <ivanm> the only suggestion I could make - which would muck the logic up a bit - would be to only print the filename if there's an error
20:02:26 <ivanm> rking: I'm interested in how you think that could be improved
20:02:37 <ivanm> oh, and processLint should take in a FilePath, not a String :p
20:02:51 <rking> gwern: If you remove comments and blank lines, you're at 17 lines of code. 3 of which are purely type-related, which is a helper to the programmer, but not essential to the problem.
20:02:55 <ivanm> sorry, my mistake, processLint takes in the file contents
20:03:18 <ivanm> rking: well, the "let statement" could be removed if you wanted to cut line length
20:03:19 <hpaste> gwern annotated ‚ÄúMarkdown lint: checking for lines so long they force browsers to scroll‚Äù with ‚ÄúMarkdown lint: checking for lines so long they force browsers to scroll (annotation) (annotation)‚Äù at http://hpaste.org/77268#a77270
20:03:42 <rking> gwern: The drop 3 is pretty hackish.
20:03:46 <ivanm> gwern: also, you use find, but only consider the first file it finds
20:03:54 <ivanm> methinks you want a mapM_
20:04:18 <gwern> rking: unfortunately, the more principled approach, drawing on the hakyll parsing code, would take more effort sine I'm not too familiar with that part of hakyll
20:04:26 <Jafet> -- default: looks for lines >110 characters long
20:04:28 <gwern> ivanm: no, the first too-long line triggers an error remember?
20:04:35 <Jafet> when (length a >= 110) (error a)
20:04:39 <parcs`> rking is begging us to golf this thing
20:04:42 <gwern> ivanm: and the find command works fine...
20:04:47 <rking> Things like "return ()" and "lineCheck x = return x" are also just writing things to make the computer happy
20:04:58 <ivanm> gwern: I meant "only print the filename if there's an error"
20:05:16 <ivanm> oh, are you running the -exec for _each_ result?
20:05:20 * ivanm misread the find command
20:05:25 <gwern> ivanm: that's how exec works, is it not?
20:05:32 <dibblego> null . snd . splitAt 110
20:05:32 <ivanm> yeah, I thought you were piping it in though
20:06:07 <gwern> dibblego: splitAt doesn't seem appropriate here?
20:06:11 <Jafet> not . null . drop 110
20:06:21 <dibblego> yeah drop
20:06:22 <ivanm> gwern: rather than calculating the length, in case the line length is huge
20:06:41 <rwbarton> FilePath on line 12 should be String, had me confused
20:06:57 <ivanm> rwbarton: yeah, that was my mistake, I was wrong
20:07:05 <gwern> rwbarton: true, I was foolishly following ivanm's dictate
20:07:06 <ivanm> I thought gwern was reading the file there but he's not
20:07:17 <gwern> Jafet: how does 'drop 110' do anything helpful?
20:07:24 <rwbarton> oh yes i see it was already mentioned sorry
20:07:32 <dibblego> gwern: it won't traverse the entire line
20:07:40 <ivanm> gwern: if the line is longer than 110 chars, then not . null . drop 110 will return True
20:07:51 <dibblego> gwern: to determine if a list has a length >= n, there is only a need to traverse n
20:07:52 <ivanm> > not . null . drop 110 $ repeat 'a'
20:07:54 <lambdabot>   True
20:08:12 <gwern> so it's a foolish micro-optimization. never mind then.
20:08:26 <dibblego> it's not foolish and it is more than optimisation
20:08:37 <rwbarton> it's not a micro-optimization, consider a one-line 100MB file
20:08:38 <ivanm> rking: yes, some things like "return x" are just to make the compiler happy, but I don't know of any way to have that be done automatically
20:09:03 <gwern> ivanm: well, this is an obvious sort of approach to provide a helper function/special case for
20:09:05 <dibblego> imo, calling length is foolish, almost always
20:09:22 <ivanm> oh, good, you said "almost always" ;-)
20:09:24 <gwern> ivanm: one can think of many other predicates to run besides 'look for too-long lines inside a CodeBlock'
20:09:30 <ivanm> yup
20:09:52 <gwern> ivanm: and they all have the same pattern of a read-only visit of each node of the AST
20:10:12 <gwern> (well, not 'each' since in this case no Inline is relevant, but you see what i mean)
20:10:29 <ivanm> yup
20:10:42 <gwern> rwbarton: that's a microoptimization. consider the case where you need to add 1+1 a bazillion times!!11!!1
20:10:48 <rwbarton> lol
20:11:03 <ivanm> so unless you golf it even more (e.g. replace the do block with a usage of >>), you can't really reduce that any more
20:11:06 <dibblego> consider the case where you want your program to produce a result
20:11:15 <gwern> BUT WE MIGHT NEED TO ADD 1+! A BAZILLION TIMES SO LET'S WRITE IT THIS WAY WHICH IS A BAZILLION TIMES HARDER TO UNDERSTAND
20:11:21 <rwbarton> wtf man
20:11:21 <ivanm> dibblego: I think gwern is saying that for his use case, it's not reallly that important
20:11:30 <dibblego> this less "optimising code" and more "taking messy code and making it tidy"
20:11:46 <dibblego> I am not even interested in the algorithmic complexity improvement ‚Äî I just thought it was easier to compel
20:12:01 <ivanm> I've written an atLeast :: Int -> [a] -> Bool function, which basically does the not . null . drop routine
20:12:04 <ivanm> which thus makes it more readable
20:12:12 <gwern> dibblego: replacing a 'length a >= 110' with 'not . null . drop 110' is your idea of *tidy*?
20:12:15 <dibblego> not calling length makes it more readable
20:12:22 <parcs`> what about length (take 110 a) == a
20:12:25 <parcs`> er, == 110
20:12:28 <dibblego> gwern: I do not wish to discuss this anymore ‚Äî go right ahead
20:12:32 <parcs`> that's pretty tidy
20:12:37 <ivanm> parcs`: well, it traverses the list twice
20:12:54 <parcs`> meh. constant factor
20:12:57 <gwern> ivanm: well, if there were an 'atLeast' available, I'd definitely use that
20:12:59 <Jafet> This is a micro-optimization because the real optimization is to use Text.
20:13:14 <dibblego> Jafet++
20:13:19 <ivanm> Jafet: except Pandoc doesn't use Text atm
20:13:41 <shachaf> Data.Text.length is O(n) :-(
20:13:41 <ivanm> is Text O(1) for length?
20:13:47 <ivanm> yeah, that's what I thought
20:14:08 <gwern> shachaf: huh. why's that? didn't want to increment the counter on updates or something?
20:14:16 <shachaf> gwern: Because it's UTF-16
20:14:25 <gwern> oh
20:14:25 <shachaf> It knows the number of bytes, just not the number of characters.
20:14:29 <ivanm> multibyte chars, etc.
20:15:39 <Jafet> Hey, counting bytes produces an accurate result most of the time. That's good enough
20:15:56 <Jafet> In any case, counting characters is hard and outside the scope of Text
20:16:03 <rwbarton> the length >= 110 thing doesn't seem exactly scientific in the first place
20:16:04 <ivanm> yeah, screw non-ASCII encodings! :p
20:16:21 <ivanm> rwbarton: well, no, but this is a quick`n`dirty hack gwern put together for something (IIUC)
20:16:21 <Jafet> UTF-16, so you can handle much of the BMP.
20:16:22 <shachaf> ivanm: More like "non-BMP characters", in the case of Text.
20:17:23 <Jafet> And to count characters, you need to take into account the non-displaying and combining codepoints, characters normally displayed as double-width, and other things
20:17:56 <shachaf> Not to mention the double-height characters!
20:18:05 <rwbarton> why isn't there just a RULE for length xs >= n (and length xs <= n, etc.)
20:18:25 <shachaf> Are RULES really supposed to change semantics?
20:18:29 <ivanm> rwbarton: because you haven't submitted a proposal to libraries@ yet! ;-)
20:18:30 <gwern> rwbarton: yeah, the 110 bit is a little temporary. I should figure out what length will cause 800px wide browser windows on gwern.net to resort to scrolling
20:18:43 <gwern> rwbarton: but 110 will catch the worse offenders in my writings
20:18:53 <rwbarton> i guess not but it seems like this would only change semantics in the direction of "more what the user meant"
20:19:07 <rwbarton> also i'm pretty sure there are existing RULES that do change semantics like this
20:19:14 <ivanm> or you use genericLength with lazy naturals, and you get the best of both worlds! ;-)
20:19:24 <ivanm> (except for maybe performance, but who cares about that? :p)
20:19:35 <Jafet> A lazy natural is a... list
20:19:37 <applicative> don't people often use length implicitly to force the list, or its spine.
20:19:43 <gwern> ivanm: one could write a play, _Waiting for Nat'ral_...
20:19:59 <dibblego> length :: [a] -> [()]; 110 :: [()]
20:20:03 <rwbarton> probably not in the context "length xs >= n" though
20:20:22 <shachaf> Well, you might assume that it's all forced after that.
20:20:37 <ivanm> Jafet: true
20:20:44 <rwbarton> i suppose.....
20:20:51 <ivanm> map (const ()) xs <= replicate 110 ()
20:21:00 <ivanm> * >=
20:21:20 <shachaf> > void [1,2,3]
20:21:22 <lambdabot>   [(),(),()]
20:21:30 <ivanm> oooohhhhhh
20:21:43 <ivanm> > void (repeat 'a') >= replicate 110 ()
20:21:44 <lambdabot>   True
20:21:54 <shachaf> > void (repeat 'a') >= void [1..110]
20:21:56 <lambdabot>   True
20:22:07 <shachaf> @ty compare `on` void
20:22:08 <lambdabot> (Functor f, Ord (f ())) => f a -> f a -> Ordering
20:22:31 <Nereid> :t void
20:22:32 <lambdabot> Functor f => f a -> f ()
20:22:39 <Nereid> why is that called void
20:22:51 <shachaf> It's like "(void) ..." in C, I guess?
20:23:02 <Nereid> unit :: a -> ()
20:23:02 <gwern> shachaf: yep. that's where the name comes from
20:23:03 <Nereid> fmap unit
20:23:06 <ivanm> yeah, I think so
20:23:08 <koninkje> rwbarton: see http://hackage.haskell.org/packages/archive/list-extras/0.4.1.1/doc/html/Data-List-Extras-LazyLength.html
20:23:22 <rwbarton> look i'm sure there are a lot of great ways to write this :)
20:23:22 <gwern> shachaf: it was originally in the Foreign library, and it was easier to get library@ consensus under 'void' than anything else
20:23:30 <koninkje> rwbarton: I initially had RULES in there, but removed them specifically because of complaints about changing semantics
20:23:38 <Jafet> > length "import Data.List.Extras.LazyLength;"
20:23:39 <lambdabot>   35
20:23:39 <shachaf> @ty compare `on` null ++ compare `on` void
20:23:41 <lambdabot>     Couldn't match expected type `Bool'
20:23:41 <applicative> I'm not sure it beats  return ()
20:23:41 <lambdabot>                 with actual type `[a0] -> Ordering'
20:23:41 <lambdabot>     Expected type: [a0] -> Bool
20:24:41 <ivanm> applicative: except it's actually fmap (const ())
20:24:43 <gwern> applicative: my original usecase was in threads. before you would write something like 'newThread(x >> return ())' all over the place. cleaner is 'newThread(void x)'
20:24:44 <ivanm> not return ()
20:24:59 <gwern> forkThread? spawnThread? wow it's been so long I don't even remember
20:25:42 <shachaf> forkIO?
20:26:03 <applicative> ivanm:   I was thinking of the hlint error.
20:26:23 <gwern> shachaf: maybe
20:26:33 <ivanm> applicative: oh, that's instead of the >> return ()
20:26:45 <parcs`> > id $ () <$ do Just 5
20:26:46 <lambdabot>   Just ()
20:26:50 <applicative> yeah I should have put >> return ()
20:26:51 <dibblego> @type \x -> x >> return () -- void
20:26:52 <ivanm> for the list monad, void is different from >> return () ...
20:26:53 <lambdabot> Monad m => m a -> m ()
20:27:06 <ivanm> > void [1,2,3]
20:27:08 <lambdabot>   [(),(),()]
20:27:10 <parcs`> ivanm: it is?
20:27:16 <ivanm> oh, duh, no it isn't
20:27:19 * ivanm is slow today
20:27:21 <dibblego> ivanm: it better not be, for any monad
20:27:27 * hackagebot fsutils 0.1.1 - File system utilities for Haskell that are missing from built in libraries.  http://hackage.haskell.org/package/fsutils-0.1.1 (AnthonySimpson)
20:27:52 <applicative> > [1,2,3] >> return ()
20:27:54 <lambdabot>   [(),(),()]
20:27:54 * ivanm blames GHC-7.6.1 for not building and thus being forced to look at repeated lines and lines of build output trying to find the error
20:31:08 <Nereid> fmap (const ()) m = liftM (const ()) m = m >>= (return . const ()) = m >>= const (return ()) = m >> return ()
20:31:08 <Nereid> etc.
20:31:24 <ivanm> yeah, yeah, I get it, I stuffed up, get over it already!
20:31:27 <Nereid> :p
20:31:51 <shachaf> m >>= (return . const ()) = m >>= const (return ()) ?
20:31:58 <Nereid> f . const x = const (f x)
20:32:06 <Nereid> it's probably a free theorem
20:32:37 <rwbarton> @free const
20:32:38 <lambdabot> f . const x = const (f x) . g
20:32:42 <Nereid> heh.
20:32:46 <Nereid> (where g = id)
20:32:48 <rwbarton> half a free theorem
20:33:06 <Nereid> a corollary to a free theorem.
20:33:11 <shachaf> 50% off theorem?
20:33:17 <Nereid> lol
20:34:34 <parcs`> is there an implementation of a lazy binary numeral around?
20:35:01 <Nereid> lazy in what way?
20:35:34 <parcs`> in the way that peano integers are lazy
20:36:31 <Nereid> so like an infinite list of bits?
20:37:18 <rwbarton> looks like Haskell for Maths has some p-adic stuff
20:37:21 <parcs`> it could be represented that way or a binary tree i guess
20:37:33 <Nereid> well I guess you'd want them to be finite.
20:37:45 <shachaf> Maybe you want skew binary numbers!
20:37:49 <shachaf> I heard those are the future.
20:38:27 <Nereid> interesting.
20:38:39 <parcs`> so that eg n >= n will only require log n comparisons instead of n
20:39:08 <rwbarton> how exactly would it differ from Integer
20:40:07 <parcs`> genericLength [1..] > 1024 won't time out
20:40:12 <Nereid> shachaf: I guess you could let the types enforce the constraint that there be only one 2, as the first digit.
20:40:42 <rwbarton> i see
20:40:54 <shachaf> How would it not time out?
20:41:26 <shachaf> I mean, how would you know what the least significant bit is without computing the whole length?
20:41:32 <shachaf> Unless you have some fancy scheme in mind.
20:41:33 <Nereid> parcs`: for that example you wouldn't be any better off than with naturals.
20:41:44 <Nereid> shachaf: store the lsb first
20:41:46 <parcs`> Nereid: that's true
20:41:52 <shachaf> Nereid: And?
20:41:56 <Nereid> I dunno
20:42:02 <rwbarton> well there is no "lsb" of genericLength [1..]
20:42:06 <shachaf> Right.
20:42:10 <Nereid> true
20:42:11 <shachaf> So what encoding would you use?
20:42:22 <rwbarton> actually i think skew binary numbers might be exactly what you want
20:42:35 <parcs`> you would compare the most significant bits no?
20:42:50 <Nereid> how would you know where the most significant bit is?
20:43:08 <Nereid> eh never mind. I guess it could work.
20:43:24 <parcs`> well you'll reach the most significant bit of 1024 before you reach that of the LHS
20:44:33 <shachaf> rwbarton: Hmm, how do skew binary numbers help?
20:44:40 <parcs`> anyway, just a thought *shrug*
20:44:48 <Jafet> parcs: what is length [1..]
20:44:59 <rwbarton> well i'm not really sure but i am trying to imagine how this could work
20:45:15 <rwbarton> somehow you need to arrange that fix (1+) = [_|_, _|_, ...]
20:45:23 <Nereid> Jafet: the point is that with lazy naturals, length [1..] would be Succ (Succ (Succ ...)) which will always compare larger than any finite natural in finite time
20:45:30 <shachaf> You want something such that after you pass a certain point the "least significant bits" don't change anymore. Or something.
20:45:48 <Jafet> length [1..] :: Nat = fix Succ, length [1..] :: BNat = ?
20:45:58 <Nereid> indeed
20:46:03 <rwbarton> hmm, i suppose that is a possibility too
20:46:04 <shachaf> fix BSucc
20:46:10 <Nereid> :p
20:46:31 <Nereid> maybe store the number of bits as a Nat
20:46:35 <Nereid> or so
20:46:42 <Taslem> Anyone know of a well-documented library intended for game design?
20:46:55 <Nereid> I dunno, it's something to think about I guess.
20:47:07 <rwbarton> it is interesting yeah
20:47:26 <copumpkin> Taslem: don't even know of a poorly documented one
20:48:34 <Nereid> shachaf: how fast is skew binary multiplication?
20:48:55 <KirinDave> Hmm. I've come to believe I don't know how to use criterion to reliably benchmark pure code.
20:48:57 <shachaf> I don't know.
20:49:11 <Jafet> I wonder if BNat = [Integer]
20:49:26 <rwbarton> actually this sounds impossible to me now
20:49:36 <copumpkin> Nereid: I doubt it's particularly fast
20:49:43 <copumpkin> I haven't tried implementing it though
20:49:52 <copumpkin> doesn't seem like the representation would help out much there though
20:49:53 <Jafet> bsucc (a:b:ns) | 2*a < b = (a+1:b:ns) | otherwise = (a+1:a:b:ns)
20:49:59 <Nereid> copumpkin: yeah that's what I was wondering.
20:50:01 <shachaf> rwbarton: For anything number system other than Nat?
20:50:07 <rwbarton> yes
20:50:10 <Jafet> Well, that BNat can't be infinite
20:50:21 <shachaf> s/thing//
20:50:48 <rwbarton> because fix succ is going to be the limit of the sequence _|_, succ _|_, succ (succ _|_), ...
20:51:01 <rwbarton> obviously succ _|_ will need to be different from _|_
20:51:10 <rwbarton> but there's no way for the next succ to observe this difference
20:51:56 <rwbarton> so {- handwaving -} I don't see anything succ can do besides wrap a constructor around its argument
20:52:08 <rwbarton> can't pattern match to any extent by the first thing i said
20:52:49 <rwbarton> you would need lub or something
20:52:53 <rwbarton> then maybe you could do it
20:52:58 <shachaf> all you need is lub
20:54:11 <shachaf> What if you just pattern-matched on the spine of the list, rather than the bits?
20:54:19 <shachaf> You'd be able to know that the number is bigger than 2^n
20:54:36 <Jafet> shachaf: succ undefined > 0
20:54:50 <Jafet> succ cannot pattern match on anything
20:55:08 <shachaf> Ah, yes.
20:55:14 <prezjordan> I have a strange request.
20:55:38 <rwbarton> the same argument should apply to any representation, basically it says that if fix succ /= _|_ then succ (succ (... (succ 0)...)) needs order n constructors
20:56:14 <prezjordan> I spent this past weekend learning some more Haskell - in fact I had a blast building a binary search tree module, and expanding that to a huffman coding module. Can anyone recommend a small project (< 3 hrs) to hack around with?
20:56:20 <shachaf> Right.
20:56:29 <prezjordan> I'm having a tough time finding things to build!
20:56:54 <rwbarton> or more simply, at least n
20:57:33 <Ralith> prezjordan: I have some fun suggestions, but they're all closer to 10 hours.
20:57:55 <prezjordan> Ralith: such as? nothing *too* difficult but I'm willing to at least start something :)
20:58:12 <KirinDave> prezjordan: Have you done a lot of stuff involving TVar and TChan yet?
20:58:16 <shachaf> prezjordan: Haskell compiler.
20:58:19 <Ralith> IRC bot, raytracer, a certain procedural image generator
20:58:24 <shachaf> You learn Haskell at double-speed that way!
20:58:28 <Ralith> (algorithm, that is)
20:58:32 <prezjordan> KirinSave - unfamiliar with the concepts :)
20:58:44 <KirinDave> prezjordan: Well then
20:58:55 <prezjordan> ray-tracer sounds fun, is that a rite of passage for programmers? I have yet to build one
20:59:06 <KirinDave> prezjordan: Try writing a MUD.
20:59:15 <KirinDave> prezjordan: A basic thing shouldn't take too long.
20:59:27 <KirinDave> And it's a good practice for TChan, TVar, etc.
20:59:27 <prezjordan> KirinDave: fairly un-google-able, what is that if I may ask
20:59:32 <shachaf> Those all sound very real-worldy.
20:59:35 <Ralith> prezjordan: not a rite of passage per se; it's just easy and fun and rewarding.
20:59:42 <shachaf> @google what is a mud
20:59:43 <lambdabot> http://en.wikipedia.org/wiki/MUD
20:59:43 <lambdabot> Title: MUD - Wikipedia, the free encyclopedia
20:59:45 <KirinDave> shachaf: Heaven forbid I represet.
20:59:53 <KirinDave> erhem, represent
21:00:22 <prezjordan> haha very interesting - I'm not an RPG player though :(
21:00:28 <KirinDave> So?
21:00:30 <Ralith> prezjordan: it certainly qualifies as evidence that you're not incompetent, but you're learning Haskell on what I presume to be your own initiative, so that's already adequately demonstrated.
21:00:35 <prezjordan> but interesting nevertheless
21:01:00 <prezjordan> Ralith - I still like the idea of a raytracer, pretty neat
21:01:05 <Ralith> raytracers are also nice because you can keep stacking on the features
21:01:05 <shachaf> Learning Haskell on your own initiative demonstrates that you're not incompetent?
21:01:28 <Ralith> start with shading; add reflection, refraction, soft shadows, path tracing, GI, ...
21:01:29 <Jafet> It makes you fitter, healthier, happier.
21:01:41 <Ralith> shachaf: correlates highly with that, at any rate.
21:01:48 <prezjordan> any project ideas that really show off haskell's strengths? I mean when I think ray-tracer I would think of building it in python
21:01:51 <Jafet> Ralith: somewhere in between that you end up rewriting it in C++
21:01:58 <statusfailed> prezjordan: not C?
21:02:02 <Ralith> Jafet: oh really? :P
21:02:07 <prezjordan> statusfailed: I'm a poor C programmer :)
21:02:22 <Ralith> prezjordan: python's hardly got anything going for it, raytracer-wise.
21:02:23 <statusfailed> fair enough :P
21:02:26 <Jafet> Hm, does python have real concurrency now?
21:02:29 * hackagebot GLFW-b 0.1.0.5 - GLFW bindings  http://hackage.haskell.org/package/GLFW-b-0.1.0.5 (BrianLewis)
21:02:39 <KirinDave> prezjordan: An IRC server.
21:02:52 <statusfailed> An IRC server simulator
21:02:56 <prezjordan> haha
21:03:01 <prezjordan> not a bad idea
21:03:03 <KirinDave> prezjordan: I am gonna keep saying things that involve actual concurrency and a lot of I/O. :P
21:03:18 <prezjordan> KirinDave: strengths of Haskell? or just your interests?
21:03:21 <chatsiri> Example link in where topic as incorrect condition : http://learnyouahaskell.com/syntax-in-functions
21:03:22 <shachaf> I/O is boring.
21:03:51 <statusfailed> hahaha
21:03:59 <KirinDave> prezjordan: It's very interesting. And Haskell is actually pretty good at it despite a lot of outdated data to the contrary.
21:04:24 <prezjordan> KirinDave: interesting, I'll have to check out some concurrency stuff
21:04:44 <statusfailed> on this subjec, forkIO starts a green thread right?
21:04:50 <statusfailed> not an OS thread
21:05:13 <KirinDave> statusfailed: There are OS threads backing them if you run -threaded
21:05:14 <prezjordan> many sources are suggesting writing a parser in haskell - is this a viable exercise?
21:05:30 <statusfailed> KirinDave: Sure, I just meant it doesn't do a whole OS thread for each forkIO
21:05:36 <statusfailed> prezjordan: oooh yeah
21:05:44 <statusfailed> prezjordan: hold that thought
21:05:48 <prezjordan> holding!
21:05:51 <statusfailed> prezjordan: http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
21:06:03 <statusfailed> prezjordan: you may released the thought
21:06:15 <KirinDave> prezjordan: It's somewhat trivial.
21:06:15 <Jafet> :t fix (forever . forkIO)
21:06:17 <lambdabot> Not in scope: `forkIO'
21:06:29 <startling> prezjordan, yeah, parsing in haskell is really nice.
21:06:30 <prezjordan> I'm a big fan of racket, this looks perfect
21:06:31 <applicative> prezjordan: you will certainly want to study one of the parsing libs soon
21:06:41 <statusfailed> I cannot recommend that book highly enough
21:06:41 <Ralith> prezjordan: I second the 'write a scheme' recommendation as well.
21:06:53 <KirinDave> attoparsec being the inscrutable speed queen and parsec being the workhorse.
21:06:53 <prezjordan> statusfailed: thank you very much
21:06:57 <Ralith> everyone needs to have implemented at least one programming language.
21:07:05 <Ralith> even if it's a toy
21:07:22 <KirinDave> Free monad time.
21:08:05 <prezjordan> Ralith: in my programming languages classes we wrote an L-language (variables, labels, gotos, if's) interpreter in scheme
21:08:26 <Ralith> prezjordan: what, no lambda?
21:08:49 <prezjordan> Ralith: no lambda, just macros
21:08:53 <Ralith> a toy language should have lambda if that's the only thing it has!
21:09:00 * Ralith waits
21:09:15 <josephle> prezjordan: I feel like from there, you're a register allocator and codegen away from a compiler
21:09:20 <startling> Ralith, unlambda?
21:09:34 <Ralith> startling: no, dammit, the untyped lambda calculus :P
21:09:47 <shachaf> KirinDave: The best monads in life are free.
21:10:15 <Jafet> startling: the name "unlambda" should give you a clue
21:10:16 <josephle> Ralith: my programming language class made me do a cross compiler from untyped lambda calculus to SKI-calculus -_-
21:10:17 <prezjordan> jospehle: codegen seems like a pretty huge step ;)
21:10:45 <Jafet> @let eval=let e s@(_:'\\':v:'.':l)=let(x,')':t)=e$d l in(take 4 s++x++")",t);e('(':s)=let(x,t)=e s;(y,')':u)=e$d t in(a x y,u);e s=splitAt 1$d s;d=snd.span(==' ');a(_:'\\':v:_:l)s=let f x|x==v=s|1>0=[x]in fst.e$init l>>=f;a f x='(':f++" "++x++")"in e
21:10:46 <lambdabot>  <local>:9:1:
21:10:46 <lambdabot>      Multiple declarations of `eval'
21:10:46 <lambdabot>      Declared at: <local>:...
21:10:59 <startling> :t eval
21:11:01 <lambdabot> [Char] -> ([Char], [Char])
21:11:02 <Ralith> josephle: that sounds fun!
21:11:08 <josephle> prezjordan: maybe for if statements, but all your other features have a one-to-one correspondence to assembly constructs :P
21:11:13 <shachaf> @where+ eval eval=let e s@(_:'\\':v:'.':l)=let(x,')':t)=e$d l in(take 4 s++x++")",t);e('(':s)=let(x,t)=e s;(y,')':u)=e$d t in(a x y,u);e s=splitAt 1$d s;d=snd.span(==' ');a(_:'\\':v:_:l)s=let f  x|x==v=s|1>0=[x]in fst.e$init l>>=f;a f x='(':f++" "++x++")"in e
21:11:13 <lambdabot> Good to know.
21:11:19 <startling> where's `eval` from?
21:11:26 <Jafet> > eval "((\\x. (x x)) y)"
21:11:28 <lambdabot>   ("(y y)","")
21:11:37 <prezjordan> as context: I'm a RoR developer professionally (well, I'm currently a student) but I just love learning programming languages. functional languages have always struck a nerve with me, and haskell's given me the same "wow programming is awesome" feeling I had when I was younger
21:11:42 <Ralith> that is a frightening oneliner
21:12:03 <prezjordan> josephle: hm, very interesting
21:12:25 <statusfailed> prezjordan: +1 the final clause :)
21:13:07 <josephle> Ralith: my test for the cross-compiler was the factorial function. I have never seen a screen so full of S's, K's, and I's
21:13:10 <Ralith> prezjordan: anyway, I've always found programs that generate images to be the most rewarding toy projects because of the rapid, visual feedback they can provide.
21:13:14 <Ralith> josephle: haha
21:13:28 <Jafet> You had I's? Back in my day, son...
21:13:42 <prezjordan> Ralith: I can respect that - are you a game programmer? (many of them have said the same thing)
21:13:52 <josephle> yes, I know I's are definable and we can reduce to SK
21:13:57 <Ralith> josephle: shouldn't you have tested with something sufficiently small that you could verify it manually?
21:14:02 <niteria> > eval "((\\x. (x x)) (\\x (x x)))"
21:14:04 <lambdabot>   ("*Exception: <local>:3:97-111: Irrefutable pattern failed for pattern (y, ...
21:14:09 <Ralith> prezjordan: mostly I work on compilers
21:14:15 <niteria> > eval "((\\x. (x x)) (\\x. (x x)))"
21:14:19 <lambdabot>   mueval-core: Time limit exceeded
21:14:20 <prezjordan> Ralith: very neat
21:14:20 <Ralith> I do want to play with gamedev at some point in the future, though
21:14:28 <josephle> I did verify it with small cases. I started messing with stress tests later
21:14:35 <Ralith> I'm currently employed for opengl work, actually
21:14:48 <josephle> oh yeah, they also made us cross-compile from SKI to untyped lambda
21:14:53 <prezjordan> Ralith: oh, excellent!
21:15:03 <josephle> so there was some way to check your compiler was mostly sane
21:15:09 <prezjordan> I feel like once I wrap my head around monads I'll have a 100% fonder appreciation for the language
21:15:40 <Ralith> that is entirely plausible
21:15:42 <Ralith> monads are awesome
21:15:43 <statusfailed> prezjordan: the "Write a Scheme" book should help with that :)
21:15:44 <josephle> as my professor Bob Harper once said: Monads makes haskell the best imperative programming language
21:15:50 <Ralith> ^
21:16:12 <Ralith> well
21:16:20 <Ralith> the funnest, and perhaps most expressive, anyway
21:16:30 <josephle> that I can agree with
21:16:48 <prezjordan> haha great, and looking forward to it - statusfailed - I've already got it loaded on my iPad
21:16:49 * Ralith still wants finer-grained control over memory, but isn't really sure how to get it.
21:17:22 <Ralith> prezjordan: I'd definitely endorse learning monads before beginning a project.
21:17:25 <Jafet> Ralith: import Foreign.Storable; ...
21:17:30 * hackagebot plot-gtk 0.2 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.2 (VivianMcPhail)
21:17:39 <Ralith> Jafet: it's a start, at least.
21:17:43 <prezjordan> Ralith: I'll do some more reading
21:17:51 <Jafet> (That is the worst way, but it always works)
21:17:57 <josephle> ugh, category theory hw is such a drag.
21:18:04 <josephle> this is probably why I'm wasting time here instead
21:18:07 <Ralith> prezjordan: (except insofar as that the scheme project might teach you monads)
21:18:22 <Nereid> I didn't know there were actually courses in category theory.
21:18:25 <prezjordan> Ralith: basic++ understanding won't hurt :)
21:18:45 <Ralith> I found the easiest way to learn monads was to use/implement them
21:18:52 <Ralith> but reading certainly can't make it harder.
21:19:09 <Jafet> Nereid: where do all the grad students come from!
21:19:25 <josephle> Nereid: it's old enough to have its own courses. Of course having Awodey as part of your philosophy department doesn't hurt
21:19:36 <Nereid> josephle: haha, that might do it.
21:20:25 <josephle> one day I'll figure out why the yoneda embedding on internal group structures is important to programming languages or something
21:20:28 <Nereid> Jafet: I thought everyone just picked up the basic terminology in the course of doing other things, and then learned the rest on their own?
21:20:37 <Nereid> :c
21:22:00 <josephle> Nereid: learning the rest on your own is a big task. This stuff gets super abstract way too fast :/
21:22:09 <Nereid> I'm not entirely serious.
21:22:13 <Nereid> but that's what I did I guess.
21:22:27 <Nereid> but I'm a math student so.
21:23:06 <rwbarton> I think that is pretty much normal. assuming "everyone" ranges over math grad students in an area that uses category theory
21:23:44 <rwbarton> but I have heard of at least one pure introductory category theory course
21:24:03 <Nereid> I guess in calgary there was a computer science course taught in the CS department.
21:24:04 <Nereid> er
21:24:07 <Nereid> category theory course.
21:24:13 <Nereid> heh.
21:24:16 <josephle> I can see why that would work. Most people probably don't need to know all the machinery of category theory. Definitely not all of maclane, at least
21:27:04 <statusfailed> prezjordan: good to hear :)
21:27:17 <Ralith> CS in a CS dept?
21:27:19 <Ralith> unheard of!
21:27:30 * hackagebot plot-gtk 0.2.0.1 - GTK plots and interaction with GHCi  http://hackage.haskell.org/package/plot-gtk-0.2.0.1 (VivianMcPhail)
21:29:21 <Nereid> I'm looking at the course notes.
21:29:26 <Nereid> adjoints and monads before limits.
21:29:39 <Nereid> I guess that would make sense for CS maybe.
21:29:56 <Nereid> except
21:29:57 <Nereid> no.
21:30:20 <josephle> yeah
21:30:32 <rwbarton> adjoints before limits seems sensible in a bourbaki kind of way
21:30:51 <Nereid> sure.
21:31:20 <Nereid> and yoneda even before that.
21:31:21 <Nereid> ???
21:31:38 <josephle> next you'll tell me they learn all of these before exponentials
21:31:40 * shachaf should probably learn some category theory.
21:31:41 <Nereid> but why would you want to talk about yoneda before limits.
21:31:47 <rwbarton> well it's nice to insert a theorem every now and then in the sea of definitions :)
21:32:22 * josephle thinks that the universal mapping property is a good enough theorem, that appears for almost every definition
21:32:46 <Nereid> the notes are here, anyway. http://pages.cpsc.ucalgary.ca/~robin/class/617/notes.pdf
21:33:48 <Nereid> I haven't through them
21:34:33 <rwbarton> some of this stuff in chapter 1 is pretty arcane
21:34:42 <rwbarton> i wonder if it is being developed for some particular aim
21:35:13 <rwbarton> well really just the whole section 1.3
21:36:35 <Nereid> mm
21:36:48 <KirinDave> Ugh. I guess the problem is not my code. :\
21:36:55 <KirinDave> I was trying to get this code to not cons at all
21:37:04 <KirinDave> But I think primality testing above a certain value requires it.
21:37:05 <shachaf> The problem is not in my code, it's in my head?
21:37:19 <shachaf> Why are you doing primality testing?
21:37:36 <KirinDave> shachaf: I am trying to clean up my Project Euler 58 solution before I publish my blog post
21:37:43 <shachaf> Uh oh.
21:38:20 <KirinDave> shachaf: https://gist.github.com/dc270c1b45e585ec3ae6
21:40:48 <shachaf> Why don't you write types. :-(
21:40:58 <KirinDave> I did almost everywhere but one omission. :P
21:41:37 <KirinDave> shachaf: I added the one missing type signature.
21:42:01 <shachaf> Hmm, that's not the type it got inferred at.
21:42:10 <KirinDave> Yeah
21:42:24 <KirinDave> This is an older gist.
21:42:40 <shachaf> I have a habit of writing at least two identical type signatures for every value.
21:42:48 <shachaf> People tell me I should stop stereotyping but it's hard. :-(
21:42:57 <cmears> ...
21:43:32 <mzero> KirinDave: huh - that's, er, a lot of code!
21:43:42 <KirinDave> mzero: Is it?
21:43:51 <mzero> my solution to 58 is 4 lines long
21:44:05 <mzero> er, 5
21:44:20 <KirinDave> mzero: I have seen very short versions, but most of them use mutable values and are pretty inscrutable.
21:44:37 <KirinDave> mzero: This one was written for readability first, then the best performance I could get from that.
21:44:41 <mzero> I'm not sure my is scrutable... but it most definitely is not mutable!
21:44:51 <shachaf> What's the problem, anyway?
21:45:12 <mzero> http://projecteuler.net/problem=58
21:45:43 <KirinDave> mzero: I think most of the length comes from how I did the corner calculation.
21:47:00 <rwbarton> this code is just generally sort of ... broken into very small pieces
21:47:08 <KirinDave> Yep
21:47:22 <rwbarton> many of which are used only once anyways
21:47:30 <rwbarton> (maybe even all of which?)
21:47:35 <KirinDave> Yes.
21:48:01 <mzero> huh - I generate all the corner integers in one line:
21:48:11 <KirinDave> Doing multiples of N?
21:48:20 <mzero> > let spiralDiagonals = scanl (+) 1 $ concatMap (replicate 4) [2,4..] in take 20 spiralDiagonals
21:48:23 <lambdabot>   [1,3,5,7,9,13,17,21,25,31,37,43,49,57,65,73,81,91,101,111]
21:48:26 <KirinDave> yes.
21:48:36 <KirinDave> My original solution did that. :\
21:48:56 <KirinDave> Explaining that to someone who is new to haskell is pretty tough.
21:49:28 <shachaf>  Oh, that's a nice way of doing it.
21:50:04 <rwbarton> that's pretty clever yeah, i probably would have written a dumb 1 : concat [ [f1 n, f2 n, f3 n, f4 n] | n <- [2..] ] after spending some time and paper working out f1..f4
21:51:09 <shachaf> f2 n = f1 n + 2*n?
21:51:11 <shachaf> Or something like that.
21:51:23 <KirinDave> Anyways
21:51:26 <KirinDave> One thing I am sure of
21:51:28 <rwbarton> various things like tha tyes
21:51:31 <KirinDave> Criterion is NOT benchmarking my code right.
21:51:35 <KirinDave> It says 350us
21:51:41 <rwbarton> then don't you have to be a little careful to only take four numbers at a time, though
21:51:42 <KirinDave> But the entire run takes 0.22s
21:52:19 <KirinDave> So obviously I am using criterion wrong. Which is to say slavishly copying the example. :\
21:53:50 <rwbarton> what's with lines 14-15 of the output... if the low is 372 us and the high is 380 us then how can the std dev be 20 us
21:54:03 <KirinDave> Yeah.
21:54:10 <KirinDave> It's eliminating outliers?
21:54:12 <rwbarton> or
21:54:22 <rwbarton> ohhh those are confidence intervals
21:54:38 <KirinDave> Anyways, it _must_ be taking longer than that.
21:55:02 <rwbarton> anyways my guess would be ghc is sharing something
21:55:08 <rwbarton> and it's only getting computed the first time
21:55:34 <rwbarton> the answer is something with 6 or 7 digits, right
21:55:46 <KirinDave> 5 I think?
21:56:46 <cmears> only 5
21:57:14 <rwbarton> still 376 us to test primality of 40000 numbers is too low
21:57:19 <cmears> less than a millisecond seems a bit low
21:57:40 <KirinDave> I agree.
21:58:06 <KirinDave> I mean it's _possible_ if the full primality tests never gets invoked and everything takes place in cache.
21:58:18 <KirinDave> Then it _could_ be that fast.
21:58:30 <rwbarton> isn't 40000 cycles already more than 376 us, or am i dividing wrong
21:59:24 <KirinDave> But yes I think 376us is too low.
21:59:47 <rwbarton> probably whnf dimensionPassingThreshold 0.10 is being shared
21:59:49 <KirinDave> But sadly there is like no advice on how to fix the benchmark forthcoming. :)
21:59:51 <Jafet> > 376e-6 * 2e9
21:59:53 <lambdabot>   752000.0
21:59:57 <Jafet> What's the problem.
22:00:12 <rwbarton> problem is i divided wrong :)
22:00:19 <Nereid> 20 cycles to test primality still sounds fast
22:00:31 <Jafet> > 376e-6 * 2e9 / 40000
22:00:33 <lambdabot>   18.8
22:00:58 <bxx> is there a read equivalent that returns default value instead of throwing error?
22:01:14 <copumpkin> eww default values
22:01:20 <copumpkin> :t reads
22:01:22 <lambdabot> Read a => ReadS a
22:01:26 <Nereid> bxx: try reads, yeah.
22:01:28 <rwbarton> i think criterion documentation might have some tips on avoiding this kind of sharing
22:01:30 <Jafet> bxx: what is a default value
22:01:30 <shachaf> @ty readMaybe
22:01:32 <lambdabot> Not in scope: `readMaybe'
22:01:36 <cmears> it seems likely that "windingSums" is not being recalculated at each test, since it is a constant
22:01:39 <shachaf> Text.Read has readMaybe :: String -> Maybe a
22:01:57 <bxx> thanks.  Jafet the one I pass
22:02:20 <shachaf> collecting 100 samples, 1 iterations each, in estimated 14.24768 s
22:02:31 <Nereid> shachaf: I wish it exported readEither
22:02:32 <shachaf> If it estimates by running the code once, that's almost certainly a sharing issue.
22:02:47 <Jafet> One iterations.
22:03:03 <shachaf> Nereid: Surprise!
22:03:13 <Nereid> ??
22:03:25 <shachaf> readEither :: forall a. Read a => String -> Either String a -- Defined in `Text.Read'
22:03:29 <Nereid> yes, but it's not exported
22:03:39 <Nereid> or is it
22:03:41 <shachaf> Nereid: That's a quote from ghci
22:03:41 <Jafet> What is a readEither
22:04:42 <Nereid> whoa, that's new then.
22:04:50 <shachaf> As new as readMaybe
22:04:53 <rwbarton> yes, new in 7.6
22:04:58 <Nereid> but
22:05:09 <Nereid> I'm pretty sure something exported readMaybe but not readEither.
22:05:21 <Nereid> maybe I'm going crazy.
22:05:24 <rwbarton> maybe safe package
22:05:37 <rwbarton> or some other hackage thing
22:07:05 <Nereid> I can't remember why I wanted readEither, either.
22:07:19 <Nereid> maybe I'm just thinking of something totally different.
22:07:20 <rwbarton> KirinDave: one thing you could try is having the benchmarked code read the value 0.10 from an IORef
22:07:46 <rwbarton> that will probably outsmart GHC
22:09:37 <shachaf> help my compiler is making my code too fast :(
22:09:53 <Jafet> -frollback-loops
22:11:01 <shachaf> -fmultiple-frame-pointers
22:12:30 <Nereid> is there a version of readline that builds on 7.6.1?
22:13:52 <ivanm> isn't readline written in C?
22:13:56 <neutrino_> hi
22:14:13 <Nereid> ivanm: there's a readline package on hackage.
22:14:16 <shachaf> Isn't GMP written in C?
22:14:18 <Nereid> that's what I'm talking about.
22:14:23 <neutrino_> with lenses i can do the following:
22:14:24 <neutrino_> > ((), "world") % _1 .~ "hello"
22:14:26 <lambdabot>   ("hello","world")
22:14:36 <neutrino_> however, what about indexed lenses? how can i set indexed lenses?
22:14:50 <ivanm> Nereid: oh, right
22:14:58 <neutrino_> i have Map.fromList [("foo", "bar")] and i want to get [("foo", "baz")]
22:15:22 <rwbarton> was there some kind of deprecation process for the FFI change in 7.6?
22:15:35 <shachaf> > (at "foo" .~ Just "baz") $ M.fromList [("foo", "bar")]
22:15:37 <lambdabot>   fromList [("foo","baz")]
22:15:43 <Nereid> rwbarton: some foreign types were accepted but deprecated in 7.4
22:15:44 <gienah> Nereid: yeah, emerge dev-haskell/readline from the Gentoo Haskell overlay
22:15:59 <rwbarton> @type at
22:16:13 <Nereid> rwbarton: lambdabot is being weird.
22:16:21 <rwbarton> :(
22:16:22 <neutrino_> right but what about a rhs setter?
22:16:41 <shachaf> rwbarton: class At k m | m -> k where at :: forall v. k -> SimpleIndexedLens k (m v) (Maybe v)
22:16:41 <rwbarton> @type is anyone out there
22:16:42 <lambdabot>     Not in scope: `is'
22:16:43 <lambdabot>     Perhaps you meant one of these:
22:16:43 <lambdabot>       `id' (imported from Data.Function),
22:16:49 <neutrino_> oh i just got it
22:16:50 <shachaf> @@ @show @type at
22:16:51 <lambdabot>  ""
22:16:57 <shachaf> @@ @show @type fmap
22:16:59 <lambdabot>  "Functor f => (a -> b) -> f a -> f b"
22:17:04 <neutrino_> > (Map.fromList [("aaa","hello")]) % at "aaa" ?~ "hi"
22:17:05 <bxx> safe package is awesome. there's readMay in there and a bunch of other things
22:17:06 <lambdabot>   Not in scope: `Map.fromList'
22:17:07 <lambdabot>  Perhaps you meant one of these:
22:17:07 <lambdabot>    `M.fromLis...
22:17:07 <gienah> Nereid: or readline needs a patch for ghc 7.6.1: https://github.com/gentoo-haskell/gentoo-haskell/blob/master/dev-haskell/readline/files/readline-1.0.1.0-ghc-7.6.patch
22:17:08 <rwbarton> @type fmap
22:17:10 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:17:19 <rwbarton> i am unimpressed by your @@ @show
22:17:19 <Nereid> gienah: thanks
22:17:28 <neutrino_> > (fromList [("aaa","hello")]) % at "aaa" ?~ "hi"
22:17:30 <lambdabot>  Terminated
22:17:34 <neutrino_> amazing
22:17:37 <neutrino_> anyways, it works
22:19:10 <bxx> > readDef 0 "foo"
22:19:11 <lambdabot>   Not in scope: `readDef'
22:19:11 <lambdabot>  Perhaps you meant one of these:
22:19:11 <lambdabot>    `readDec' (impo...
22:19:13 <rwbarton> oh i see, the @@ @show is to demonstrate that lambdabot is not just dropping the request on the floor
22:19:19 <shachaf> Right.
22:20:50 <rwbarton> presumably there is an error that got dropped or sent somewhere useless
22:21:31 <rwbarton> does it do this with any non-lens functions?
22:21:47 <shachaf> what's a "non-lens functions"
22:22:03 <rwbarton> things that were imported from a module other than Control.Lens
22:22:03 <shachaf> Sounds like a kind of heresy.
22:22:22 <shachaf> I haven't figured it out.
22:22:37 <shachaf> It does it with more functions than "at", at least.
22:22:41 <shachaf> Cale: Do you know what's going on with this?
22:22:42 <shachaf> @type at
22:22:45 <shachaf> @@ @show @type at
22:22:47 <lambdabot>  ""
22:22:59 <shachaf> @@ @show @type replicated
22:23:00 <lambdabot>  ""
22:23:01 <rwbarton> it does it with traverse too but that is sort of a lens function
22:23:01 <shachaf> @@ @show @type repeated
22:23:03 <lambdabot>  "(Applicative f, Gettable f) => (a -> f a) -> a -> f a"
22:23:08 <shachaf> @@ @show @type traverse
22:23:09 <lambdabot>  ""
22:23:13 <Cale> no
22:23:21 <Cale> You know about as well as I do :)
22:23:26 <shachaf> traverse is so not a lens function!
22:23:36 <shachaf> Cale: Well, I don't have access to lambdabot's stderr!
22:23:40 <Cale> hmm
22:23:47 <rwbarton> doesn't lens export it though
22:23:52 <shachaf> Yes.
22:23:52 <shachaf> @@ @show @type Data.Traversable.traverse
22:23:54 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
22:23:57 <shachaf> whoa, dude
22:24:04 <rwbarton> hmm!
22:24:05 <shachaf> @@ @show @type Control.Lens.traverse
22:24:07 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
22:24:10 <shachaf> @@ @show @type traverse
22:24:11 <rwbarton> hmm?
22:24:11 <lambdabot>  ""
22:24:20 <Cale> nothing obviously interesting on lambdabot's terminal
22:24:36 <shachaf> @@ @show @type Control.Lens.Traversal.traverse
22:24:37 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
22:24:44 <shachaf> Magic.
22:24:54 <rwbarton> @type Control.Lens.at
22:24:56 <lambdabot> (Functor f, At k m, Indexed k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))
22:25:35 <Cale> Ah, wonderful, Ubuntu has pulled support for natty finally, so now I no longer get security patches. Oh well.
22:25:48 <rwbarton> it can't be an ambiguity thing can it?
22:25:54 <shachaf> Not really...
22:25:58 <rwbarton> @undefine
22:26:05 <shachaf> @let at = "hi"
22:26:05 <rwbarton> @@ @show @type at
22:26:07 <lambdabot>  Defined.
22:26:08 <lambdabot>  "    Ambiguous occurrence `at'\n    It could refer to either `L.at', defined at <local>:1:1\n                          or `Lens.at',\n"
22:26:08 <shachaf> Oops.
22:26:08 <rwbarton> oh, good
22:26:15 <shachaf> @undefine
22:26:15 <rwbarton> well, that actually worked
22:26:20 <Cale> What does @show do again?
22:26:23 <shachaf> @@ @show @type Lens.at
22:26:24 <lambdabot>  "(Functor f, At k m, Indexed k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))"
22:26:36 <shachaf> Cale: The same thing as the Haskell function. :-)
22:26:38 <shachaf> @show hello
22:26:38 <lambdabot> "hello"
22:27:18 <rwbarton> oh does this mean i can get more of errors
22:27:19 <Cale> Why are you composing it with @type?
22:27:28 <rwbarton> @let at = "hi"
22:27:30 <lambdabot>  Defined.
22:27:31 <Cale> :t traverse
22:27:36 <Cale> hmm
22:27:39 <rwbarton> @@ @run words . unwords $ (@show @type at)
22:27:41 <lambdabot>   Couldn't match expected type `GHC.Base.String'
22:27:42 <lambdabot>              with actual typ...
22:27:42 <rwbarton> er
22:27:46 <rwbarton> @@ @run unwords . words $ (@show @type at)
22:27:49 <lambdabot>   "Ambiguous occurrence `at' It could refer to either `L.at', defined at <loc...
22:28:15 <rwbarton> i guess not
22:28:19 <shachaf> @@ @run drop 30 $ unwords . words $ (@show @type at)
22:28:22 <rwbarton> hehe
22:28:23 <lambdabot>   "ould refer to either `L.at', defined at <local>:1:1 or `Lens.at',"
22:28:24 <Cale> Ok, modules loaded: L.
22:28:24 <Cale> *L> :t traverse
22:28:24 <Cale> traverse
22:28:24 <Cale>   :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:28:28 <Cale> ^^ loooool
22:28:45 <shachaf> ?
22:29:07 <Cale> What do you want to bet that the reason you're getting an empty result is that the prettyprinter is insane?
22:29:12 <rwbarton> how about :t Data.Traversable.traverse
22:29:23 <shachaf> Cale: Oh...
22:29:31 <rwbarton> wouldn't that be equally bad
22:29:46 <shachaf> Hmm.
22:29:51 <shachaf> @ty scanl1Of
22:29:52 <lambdabot> LensLike (Control.Applicative.Backwards.Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t
22:29:57 <shachaf> That's a pretty long type.
22:29:58 <Cale> rwbarton: hmm
22:30:01 <neutrino_> what is module L?
22:30:15 <shachaf> Lambdabot
22:30:28 <Cale> L is the local module which lambdabot uses when evaluating your expressions
22:30:36 <neutrino_> oh ok
22:30:47 <Cale> It has lots of imports, anything that people define with @let, and a bunch of other things
22:30:50 <rwbarton> more fun
22:30:50 <Cale> > cake
22:30:52 <lambdabot>   ["One 18.25 ounce package chocolate cake mix.","One can prepared coconut pe...
22:30:57 <rwbarton> @@ @show @type traverse
22:30:58 <lambdabot>  ""
22:30:59 <neutrino_> is L Caleskell
22:30:59 <rwbarton> @@ @show @type id traverse
22:31:01 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
22:31:07 <Cale> neutrino_: I guess
22:31:16 <neutrino_> cool
22:31:20 <Nereid> Cale: oh man, is that why.
22:31:20 <Nereid> haha
22:31:29 <neutrino_> can i get it off hackage?
22:31:36 <shachaf> Yes.
22:31:40 * neutrino_ googles
22:31:42 <Cale> neutrino_: Maybe not my exact version of it?
22:31:44 <Cale> I don't know
22:31:50 <shachaf> You can get L.hs from lambdabot.
22:31:52 <Cale> yeah
22:32:02 <shachaf> Cale should publish a recent lambdabot state.
22:32:09 <shachaf> Lots of quotes and things to be lost if you don't!
22:32:13 <neutrino_> is it LMain?
22:32:24 <Cale> It's just State/L.hs
22:32:25 <rwbarton> @@ @show @type (traverse)
22:32:26 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
22:32:33 <rwbarton> something very odd is going on here
22:32:39 <neutrino_> i am looking here: http://hackage.haskell.org/package/lambdabot
22:32:39 <shachaf> aw@@ @show @type     traverse
22:32:42 <neutrino_> but i don't see L
22:32:42 <shachaf> @@ @show @type     traverse
22:32:43 <lambdabot>  ""
22:33:01 <Cale> neutrino_: Do you see State/Pristine.hs?
22:33:14 <shachaf> @let travers = traverse
22:33:14 <Nereid> neutrino_: you have to downloda it
22:33:15 <lambdabot>  Defined.
22:33:18 <shachaf> @@ @show @type travers
22:33:19 <lambdabot>  ""
22:33:25 <neutrino_> well, no. but i see Plugin.State
22:33:25 <Nereid> ????
22:33:26 <rwbarton> ...
22:33:27 <shachaf> @undefine
22:33:33 <shachaf> @let travers = Lens.traverse
22:33:35 <lambdabot>  Defined.
22:33:38 <shachaf> @@ @show @type travers
22:33:39 <lambdabot>  ""
22:33:42 <Nereid> ????????
22:33:42 <shachaf> Hmm.
22:33:43 <rwbarton> @@ @show @type (traves)
22:33:44 <lambdabot>  "    Not in scope: `traves'\n    Perhaps you meant one of these:\n      `travers' (line 1), `traverse' (imported from Control.Lens),\n"
22:33:45 <rwbarton> @@ @show @type (travers)
22:33:46 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
22:33:51 <Cale> Two words about @type's behaviour: regular expressions
22:33:52 <Nereid> what is going on.
22:33:54 <neutrino_> what i want tbh is to be able to load a module into ghci and have it have everything that lambdabot has
22:33:55 <Nereid> lol
22:34:10 <neutrino_> :)
22:34:21 <rwbarton> @undefine
22:34:23 <Nereid> neutrino_: then download lambdabot and look at State/L.hs
22:34:25 <rwbarton> @let travers = id
22:34:27 <lambdabot>  Defined.
22:34:27 <neutrino_> ok :)
22:34:30 <neutrino_> thanks
22:34:31 <rwbarton> @@ @show @type travers
22:34:32 <lambdabot>  "a -> a"
22:34:34 <neutrino_> btw
22:34:46 <neutrino_> is there a way to somehow print out something that doesn't have an instance of Show?
22:34:51 <neutrino_> like say a record
22:34:54 <rwbarton> W T F
22:35:03 <Cale> neutrino_: By defining a function which turns it into a String yourself, yes.
22:35:14 <neutrino_> yeah but i want it for debugging only
22:35:22 <liyang> @slap neutrino_ including this?
22:35:22 * lambdabot is overcome by a sudden desire to hurt neutrino_ including this?
22:35:23 <Cale> neutrino_: Or just adding  'deriving Show' to its data declaration
22:35:27 <neutrino_> isn't there anything that just shows me a constructor?
22:35:42 <Cale> Show is primarily for debugging
22:36:03 <Cale> So, you tend to want to derive show for your types
22:36:06 <neutrino_> mmm ok
22:36:14 <neutrino_> makes sense, thank you
22:36:19 <liyang> Although some people also insist on read . show == id.
22:36:25 <rwbarton> @undefine
22:36:30 <rwbarton> @let travers = id traverse
22:36:32 <lambdabot>  Defined.
22:36:35 <rwbarton> @@ @show @type travers
22:36:36 <lambdabot>  ""
22:36:44 <rwbarton> @undefine
22:36:58 * liyang wouldn't encourage making use of read . show == id
22:37:04 <rwbarton> @let travers = undefined :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
22:37:06 <lambdabot>  Defined.
22:37:12 <rwbarton> @@ @show @type travers
22:37:13 <lambdabot>  ""
22:37:30 <shachaf> @ty mapM
22:37:31 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
22:37:47 <shachaf> @@ @show @type mapMOf
22:37:48 <Cale> Where is Pesco Hamburg?
22:37:48 <lambdabot>  ""
22:37:59 <rwbarton> @@ @show @type id mapMOf
22:38:01 <lambdabot>  "LensLike (WrappedMonad m) s t a b -> (a -> m b) -> s -> m t"
22:38:20 <rwbarton> so nothing to do with class constraints
22:38:34 <notdan> Can somebody link me to a tutorial about lenses?
22:38:52 <startling> notdan, usually we just get edwardk to teach us here
22:38:58 <notdan> Oh, heh
22:39:20 <startling> notdan: https://github.com/ekmett/lens/wiki/Overview is a good starting point
22:40:56 <yitz> it's a good idea to stick to read.show=id if at all posssible. being able to serialize/deserialize without fuss is often really useful. many times i've kicked myself later for being sloppy about that.
22:41:40 <shachaf> @type "hi" {- {
22:41:41 <lambdabot> [Char]
22:41:53 <startling> yitz, it's not always possible (or reasonable) though
22:41:58 <yitz> lambdabot knows about lenses now?
22:42:01 <shachaf> Yep.
22:42:38 <yitz> startling: not always. but usually it is possible, and it's a mistake to stray away from it gratuitously.
22:43:08 <yitz> even if it takes a tad more work.
22:44:23 <Cale> ugggh, the problem is this regex bullshit that @type uses
22:44:30 <shachaf> https://bitbucket.org/zeekay/lambdabot/src/0e7b40d401e7/Plugin/Type.hs
22:44:31 <rwbarton> it seems to be sensitive to whether the @type argument is all letters
22:44:38 <rwbarton> if i put a digit in the identifier it works
22:44:39 <shachaf> That code sure makes me confident about lambdabot!
22:45:03 <Cale> shachaf: Isn't it beautiful?
22:45:05 <Cale> lol
22:45:16 <shachaf> Fortuantely rwbarton will be replacing it soon.
22:45:39 <rwbarton> @unpl "^(\\*?[A-Z][_a-zA-Z0-9]*(\\*?[A-Z][_a-zA-Z0-9]*)*>)? *(.*[       -=:].*)"
22:45:40 <lambdabot> "^(\\*?[A-Z][_a-zA-Z0-9]*(\\*?[A-Z][_a-zA-Z0-9]*)*>)? *(.*[       -=:].*)"
22:45:42 <rwbarton> :(
22:45:48 <yitz> Cale: google says that pesco mare is a pizzeria in hamburg
22:46:31 <rwbarton> (' ':':':':':' ':_)
22:46:35 <rwbarton> good
22:46:49 <yitz> regex? in lambdabot's @type plugin? horrors!
22:47:09 <shachaf> I'm uncomfortable with how it just feeds it to ghci.
22:47:17 <shachaf> stripComments ('\n':_)    = [] -- drop any newwline and rest. *security*
22:47:24 <notdan> startling: thanks
22:47:27 <Cale> shachaf: I don't think it does...
22:47:44 <shachaf> Well, not "juts"
22:47:51 <Cale> oh, well, maybe it does
22:47:51 <rwbarton> you don't think it uses hugs like the comment says do you :P
22:47:52 <shachaf> But I thought it went through the same mechanism as @run
22:48:03 <Cale> Not quite, no
22:48:20 <Cale> Really, it ought to use mueval, but I'm more and more doubtful
22:48:30 <neutrino_> hmmm
22:48:41 <startling> notdan, if you've got specific questions, lots of us here are fluent
22:48:45 <neutrino_> how can i use GetOpt with an IndexedLens ?
22:48:49 <neutrino_> i don't see a way
22:48:53 <Cale> oh, it looks like mueval really doesn't have that feature
22:48:55 <Cale> huh
22:49:08 <shachaf> Wait, is the version on Hackage really the same as the version that's running?
22:49:16 <Cale> no?
22:49:28 <shachaf> Can you @paste Plugin/Type.hs?
22:49:48 <Cale> oh, well, that's the same
22:50:07 <shachaf> Ah.
22:50:31 <Cale> I had to add FlexibleInstances to the LANGUAGE pragmas in a bunch of places
22:50:40 <Cale> and maybe some other little things
22:51:54 <Cale> I also just removed the stupid blocks of commented out code and the chunk dealing with imports.h which is now blank
22:52:07 <Cale> but I haven't recompiled
22:52:29 <Nereid> Cale: which ghc did you build it on?
22:52:39 <Cale> 7.4.2
22:53:18 <Nereid> you should make it build on 7.6.1 :p
22:53:26 <rwbarton> what on earth is signature_regex supposed to do
22:53:31 <Cale> *you* should make it build on 7.6.1
22:53:34 <Nereid> lol
22:53:47 <shachaf> gienah already did that, no?
22:53:58 <Cale> No, didn't manage, apparently
22:54:02 <Cale> and doesn't have time for it
22:54:31 <shachaf> Cale: How about I explain lazy evaluation to a couple of people and you fix lambdabot in the meanwhile?
22:54:32 <Cale> rwbarton: Is shachaf fibbing or are you actually writing a new bot?
22:54:41 <rwbarton> OH that is the prompt
22:54:57 <shachaf> rwbarton: Oh, hah.
22:55:18 <Cale> why are there so many spaces inside those square brackets?
22:55:30 <rwbarton> i assume there is a tab in there
22:55:35 <rwbarton> hopefully you didn't untabify it!!
22:55:35 <Cale> there is not
22:55:46 <lightquake> why is there no Map lens? is there a deep theoretical reason for it?
22:55:48 <rwbarton> well i bet there used to be
22:55:57 <Nereid> lightquake: there is, it's Indexed
22:55:57 <rwbarton> because otherwise, yeah
22:55:58 <Cale> why wouldn't it be \t ?
22:55:59 <shachaf> rwbarton: Because IndexedLens.
22:56:29 <rwbarton> was that to me
22:56:33 <Nereid> nope
22:56:42 <lightquake> Nereid: oh, you're right
22:57:04 <shachaf> s/rwbarton/lightquake/
22:57:05 <rwbarton> Cale: I am not actually writing a new bot at this point in time
22:57:16 <Nereid> I would like to see a new bot.
22:57:28 <rwbarton> but this one has so many wonders
22:57:35 <Nereid> :p
22:57:42 <elliott> i thought i was the designated person who is going to rewrite lambdabot one day
22:57:42 <rwbarton> i still don't understand what (.*[       -=:].*) is supposed to achieve
22:57:43 <shachaf> <rwbarton> I have absolutely no ambition in that direction.
22:57:53 <elliott> are you usurping me rwbarton???
22:58:05 <rwbarton> no, please, go ahead
22:58:12 <elliott> excellent, I will go ahead and not write it
22:58:18 <shachaf> who will be the greatest procrastinator of them all
22:58:18 <Nereid> everyone wants it, but no one wants to do it.
22:58:19 <Nereid> :p
23:00:25 <elliott> well the last time i went to write the perfect haskell irc bot i ran into the issue of i didn't like acid-state and i forget why
23:00:36 <elliott> so i started porting durus to haskell but it was lots of work and i gave up
23:00:46 <elliott> someone should go do that for me
23:01:46 <tac> @type guard
23:01:47 <lambdabot> MonadPlus m => Bool -> m ()
23:02:18 <tac> @let foo x y = do guard (y /= 0); Just $ x / y
23:02:20 <lambdabot>  Defined.
23:02:25 <tac> > foo 1 2
23:02:27 <lambdabot>   Just 0.5
23:02:27 <tac> > foo 1 0
23:02:29 <lambdabot>   Nothing
23:03:15 <elliott> alternatively someone should write a haskell implementation that supports disk storage of objects
23:03:18 <elliott> then i will write lambdabot 2
23:03:24 <elliott> or is it already at 2? lambdabot 7
23:03:37 <tac> Lambdabot'
23:03:48 <tac> @faq does Haskell support disk storage of objects?
23:03:48 <lambdabot> The answer is: Yes! Haskell can do that.
23:04:30 <Cale> elliott: It would be nice to know what problem you had with acid-state
23:05:15 <elliott> Cale: i wish i could remember myself :) iirc it was basically a matter of taste -- you had to declare too much up-front or something
23:05:44 <elliott> Cale: oh, right -- it was the having to declare every "transaction" in a fixed system
23:05:59 <elliott> (i understand this is fundamental to how acid-state stores stuff, of course... just not how i'd prefer it)
23:07:06 <elliott> Cale: (i.e., the second argument to makeAcidic)
23:08:26 <Cale> elliott: hmm... perhaps it's just something I don't understand well enough about acid-state, but aren't those pretty much always going to be the same thing?
23:09:01 <elliott> Cale: hm, what would be the same thing? i'm not parsing your question
23:09:31 <Cale> I mean, your state is a single Haskell value, no?
23:09:46 <elliott> Cale: right
23:10:08 <elliott> Cale: but you want the A part of ACID, right? the second argument to makeAcidic is all the Query/Update values you'll be using.
23:10:18 <elliott> Cale: you can't combine two Updates atomically or whatever -- you declare your transaction boundaries up-front
23:10:23 <elliott> so it's not composable in the way, e.g. STM is
23:10:39 <Cale> hmm
23:10:59 <elliott> you define your data, and the atomic operations on your data, and that's all the atomicity you get -- so you can't just define a "trivial" update (of "replace just this field" or "replace the entire value" or whatever) unless you want to sacrifice atomicity entirely
23:11:25 <Cale> Don't you just replace the whole value?
23:11:31 <Cale> What's wrong with that?
23:11:34 <elliott> this is because underneath the hood, acid-state stores your data by storing a log of all the updates you run on it (plus snapshots), which is how it gets is guarantees (this may have changed, but it's how it was last time i used it iirc)
23:11:52 <Cale> hmm
23:11:54 <elliott> Cale: well, then you can't do concurrency
23:12:02 <elliott> because two separate updates will replace the whole thing
23:12:05 <elliott> you'd need a global lock!
23:12:12 <elliott> and also the log will be huge
23:12:18 <elliott> because it won't store incremental updates -- it'll store your entire state every single time
23:12:19 <Cale> Ah, I suppose so
23:13:50 <elliott> Cale: anyway i'm sure acid-state is just fine for lots of stuff... it just felt too restrictive for me
23:14:05 <elliott> not that I have any better suggestions :)
23:14:06 <rwbarton> (.*[       -=:].*) -- just noticed this is actually a range
23:14:28 <shachaf> rwbarton: I guess it's looking for lines with :: or -> or =>?
23:14:30 <shachaf> Or something like that?
23:14:32 <elliott> rwbarton: is this some kind of lambdabot bug
23:14:40 <rwbarton> yes
23:14:40 <shachaf> Seems a bit broken.
23:14:43 <elliott> what is the bug
23:14:45 <Cale> :t traverse
23:14:46 <elliott> it sounds exciting
23:14:51 <Cale> ^^ that is the bug
23:14:52 <shachaf> @@ @show @type traverse
23:14:53 <lambdabot>  ""
23:15:11 <rwbarton> there is a bug where if you do :t on an expression consisting of only letters and the output is too long then it drops the output
23:15:14 <rwbarton> approximately
23:15:20 <shachaf> @let blah = scanl1Of
23:15:21 <elliott> wow
23:15:23 <lambdabot>  Defined.
23:15:25 <elliott> that's the stupidest bug i've ever heard of
23:15:25 <shachaf> @@ @show @type blah
23:15:27 <lambdabot>  ""
23:15:40 <rwbarton> well when you see the code, you will understand
23:15:47 <rwbarton> @@ @show @type scanl1Of
23:15:48 <elliott> i'm not sure i want to see the code
23:15:48 <lambdabot>  "LensLike (Control.Applicative.Backwards.Backwards (State (Maybe a))) s t a a -> (a -> a -> a) -> s -> t"
23:15:59 <shachaf> Cale: Can you run ghci with lambdabot's exact command line arguments and type in :t traverse etc.?
23:16:11 <rwbarton> well let's just say it includes the regular expression "^(\\*?[A-Z][_a-zA-Z0-9]*(\\*?[A-Z][_a-zA-Z0-9]*)*>)? *(.*[       -=:].*)"
23:16:29 <elliott> rwbarton: that looks like a lot more than two problems
23:16:34 <elliott> something like 20 problems??
23:16:44 <Cale> elliott: tbh, for something like Lambdabot, I would just use safecopy and not worry about concurrency
23:16:54 <rwbarton> just [       -=:] itself is a significant number of problems
23:17:08 <shachaf> [                        )-=:]
23:17:21 <elliott> Cale: well, if you just use safecopy itself, then you have to handle all the file storage code and so on... but yeah, that could work
23:17:41 <elliott> lambdabot is fairly laggy if a bunch of people queue up queries though -- concurrency would really help there imo
23:17:59 <Cale> elliott: The file storage code is just dumping everything out to a file and then reading it back again
23:19:27 <rwbarton> or if you could build this plugin with extract_signatures defined as Just that would be super helpful
23:19:53 <Cale> cale@codersbase:~/.lambdabot$ ghci -v0 -XImplicitParams -XScopedTypeVariables -XUnboxedTuples -XFlexibleContexts -XMagicHash -XPatternGuards -XRankNTypes -XTypeOperators -XNoTemplateHaskell -iState -iscripts -XNoMonomorphismRestriction
23:19:53 <Cale> Prelude> :load State/L.hs
23:19:53 <Cale> *L> :t traverse
23:19:53 <Cale> traverse
23:19:55 <Cale>   :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:20:01 <elliott> so is it the newline
23:20:18 <shachaf> Cale: What about Data.Traversable.traverse?
23:20:20 <rwbarton> technically you should pipe in that input on the command line i think
23:20:34 <rwbarton> it is something to do with letters
23:20:36 <Cale> *L> :t Data.Traversable.traverse
23:20:36 <Cale> Data.Traversable.traverse
23:20:36 <Cale>   :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:20:40 <rwbarton> @let travers3 = traverse
23:20:42 <lambdabot>  Defined.
23:20:49 <rwbarton> @@ @show @type travers3
23:20:50 <lambdabot>  "(Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)"
23:21:06 <rwbarton> i doubt ghc is producing output that differs in other than the obvious way for that
23:21:09 <elliott> finally a use for leetspeak
23:21:12 <rwbarton> ghci even
23:21:14 <Cale> *L> :t travers3
23:21:15 <Cale> travers3
23:21:15 <Cale>   :: (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:21:25 <tac> @where MonadIO
23:21:26 <lambdabot> I know nothing about monadio.
23:21:31 <tac> hmm
23:21:42 <Cale> tac: Control.Monad.Trans
23:21:43 <tac> Next version of Haskellbot should be more helpful
23:21:44 <tac> thank you
23:22:07 <shachaf> rwbarton: Make sure to hardwire a message about MonadIO into lambdabot 2.0 source code.
23:22:10 <shachaf> In the lambdabot tradition.
23:22:19 <tac> it's kinda obnoxious how Google is so fond of taking me to out-of-date documentation
23:22:31 <elliott> guys apparently lambdabot is on version 4
23:22:36 <elliott> so lambdabot 2 was probably really awful
23:22:45 <Cale> Actually, it might have been better
23:23:24 <Cale> There was a period where lambdabot hadn't reached the too-much-organic-growth stage and actually worked rather well
23:23:59 <elliott> well now we get to move onto the next phase: second system syndrome
23:24:39 <Cale> Well, there wasn't a clear line
23:24:44 <Cale> It just grew
23:25:01 <Cale> The code is pretty much the same codebase, afaik
23:25:02 <rwbarton> oh here is an observation
23:25:14 <rwbarton> parens and digits are in the range " -="
23:25:22 <rwbarton> so that probably explains ... something
23:25:31 <elliott> what i really want from lambdabot is a @bf that works
23:25:34 <elliott> or did it get fixed
23:25:49 <Cale> try it
23:25:53 <shachaf> rwbarton: Oh, when you said range you meant range.
23:25:53 <rwbarton> oh i get it
23:25:56 <rwbarton> yes!!!
23:26:00 <rwbarton> isn't it odd
23:26:05 <shachaf> > [' '..'=']
23:26:06 <lambdabot>   " !\"#$%&'()*+,-./0123456789:;<="
23:26:12 <shachaf> Do regexps use ASCII order?
23:26:23 <rwbarton> they use the order specified by locale probably
23:26:31 <rwbarton> anyways here is the explanation
23:26:42 <elliott> @bf ,[.,]!hello
23:26:43 <lambdabot>  Done.
23:26:45 <elliott> @bf ++++++.
23:26:45 <lambdabot>  Done.
23:26:48 <elliott> @bf +[]
23:26:53 <lambdabot>  Done.
23:26:53 <rwbarton> the first line with 'traverse' doesn't match the regular expression
23:26:57 <elliott> okay i guess that is a brainfuck interpreter
23:27:04 <elliott> for sufficiently lenient definitions of all those words
23:27:06 <rwbarton> so it is thrown away
23:27:12 <Cale> elliott: lol
23:27:25 <rwbarton> the other output lines get leading whitespace trimmed on line 91
23:27:40 <rwbarton> that means the result of unwords begins with ":: ..."
23:27:53 <rwbarton> but the fmap reverse . removeExp . reverse dance looks for " :: "
23:27:58 <rwbarton> so it doesn't match
23:28:17 <Cale> elliott: Those programs don't exactly print much which is visible...
23:28:49 <rwbarton> fix is shoot whoever wrote (.*[       -=:].*), and replace it with (.*)
23:28:54 <Cale> @bf ++++++++++++++++++++++++++++++++++++++++++++++++.
23:28:54 <lambdabot>   0
23:28:57 <elliott> > ord 'a'
23:28:59 <lambdabot>   97
23:29:05 <elliott> @bf ++++++++++++[>++++++++<-]>+.
23:29:06 <lambdabot>   a
23:29:09 <elliott> okay i admit defeat
23:29:19 <elliott> however i bad it has suboptimal wrapping behaviour
23:29:21 <elliott> bet it
23:30:14 <shachaf> rwbarton: Any explanation at all for the  -= thing?
23:30:28 <rwbarton> you mean why did someone write that in the first place
23:30:28 <Cale> elliott: I'll try that
23:30:32 <Cale> errr
23:30:36 <Cale> rwbarton: I'll try that
23:31:02 <rwbarton> at the moment i cannot imagine why
23:31:08 <elliott> in a hilarious twist ending it turns out that rwbarton actually wrote it years ago
23:31:16 <Cale> Maybe it was someone's cat
23:31:20 <elliott> Cale shoots him and the film ends
23:31:29 <Cale> using their keyboard to jump to a windowsill
23:31:41 <shachaf> Well, we have darcs logs.
23:33:08 <sudochop> how would I go about using function composition with the following? foldr (++) "" (map myshow l)
23:33:19 <sudochop> ghci keeps bugging me about it
23:33:56 <mzero> concatMap myshow l
23:34:03 <elliott> sudochop: (f . g) x = f (g x)
23:34:08 <elliott> here we have f = foldr (++) ""
23:34:12 <elliott> g = map myshow
23:34:14 <elliott> x = l
23:34:18 <elliott> can you figure out the answer from that?
23:34:35 <elliott> -- but as mzero points out, there's a premade function for foldr (++) "" -- concat -- and a premade function for composing concat and a map together
23:34:36 <shachaf> Unfortunately darcs's UI is too complicated to be able to extract any information from it.
23:34:37 <sudochop> lets see..
23:34:44 <elliott> so you should probably use that in practice
23:36:06 <sudochop> ok. thanks for that advice. lets see if I cant figure out the compositional approach..
23:38:00 <rwbarton> is it really possible to have " :: " inside a type signature btw
23:38:27 <shachaf> @ty (>>=)
23:38:32 <lambdabot> Monad m => m a -> (a -> m b) -> m b
23:38:34 <shachaf> Hey, what happened to explicit foralls?
23:38:40 <shachaf>   :: forall (m :: * -> *) a b. Monad m => m a -> (a -> m b) -> m b
23:38:52 <rwbarton> i guess -fglasgow-exts was responsible for them
23:38:56 <rwbarton> also, good example
23:39:02 <sudochop> so just?: (foldr (++) "" . map myshow) l
23:39:23 <elliott> so why does lambdabot strip out the function name
23:39:25 <elliott> that seems dumb
23:39:44 <shachaf> It's an expression, not a function name.
23:39:44 <rwbarton> well the expression could be really long
23:39:56 <shachaf> Also the expression could have a :: in it.
23:39:56 <mzero> sudochop: sure
23:40:06 <shachaf> Œª> :t id :: Char -> Char
23:40:06 <shachaf> id :: Char -> Char :: Char -> Char
23:40:16 <rwbarton> the funny thing about this removeExp' function is that n will always be nonpositive
23:40:28 <elliott> :t (:)
23:40:28 <rwbarton> because it parses the string backwards, so it will see ) before (
23:40:30 <lambdabot> a -> [a] -> [a]
23:40:48 <elliott> what lambdabot needs is syntax highlighting
23:41:04 <Nereid> it could be done, too
23:41:06 <Cale> lol
23:41:07 <shachaf> rwbarton: I bet lambdabot has a security hole.
23:41:11 <Cale> mIRC colours
23:41:12 <shachaf> Do you really trust that \n-stripping?
23:41:17 <shachaf> What about \r?
23:41:21 <Nereid> lol
23:41:29 <Nereid> ??
23:41:34 <rwbarton> :t a
23:41:36 <rwbarton> oop
23:41:37 <rwbarton> s
23:41:45 <Nereid> :t a
23:41:51 <rwbarton> i was trying to type a \r
23:41:53 <lambdabot> Expr
23:41:58 <Cale> :t traverse
23:42:04 <elliott> i should totally add mirc colours to lambdabot 5
23:42:06 <Nereid> :::::::::::::)
23:42:06 <elliott> what could possibly go wrong
23:42:06 <rwbarton> hmm that doesn't look good
23:42:07 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
23:42:09 <rwbarton> oh
23:42:13 <Nereid> oh
23:42:19 <elliott> :t both
23:42:25 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
23:42:25 <shachaf> Actually I managed to send it a \r before using IRC-through-telnet, and it turned it into \n
23:42:26 <startling> :t element
23:42:29 <shachaf> Unless I'm wrong.
23:42:30 <Nereid> :t fmap
23:42:31 <lambdabot> (Functor f, Traversable t) => Int -> (a -> f a) -> t a -> f (t a)
23:42:37 <lambdabot> Functor f => (a -> b) -> f a -> f b
23:42:43 <elliott> edwardk should rewrite lenses so that both both so works as (a -> b) -> (a, a) -> (b, b)
23:42:48 <elliott> like let f be an arbitrary type function!
23:42:52 <rwbarton> :t rwbartoneleven
23:42:55 <elliott> and by lenses i mean lens
23:42:59 <lambdabot> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a -> a
23:43:03 <startling> :t both
23:43:09 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
23:43:21 <shachaf> @ty id `asTypeIn` (\i -> i id id id id id id id id id id id id id id id id id)
23:43:21 <Nereid> > rwbartoneleven 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
23:43:29 <rwbarton> joke's on you
23:43:31 <lambdabot>   mueval-core: Time limit exceeded
23:43:34 <Nereid> lol
23:43:38 <startling> ???
23:43:41 <lambdabot> thread killed
23:43:45 <rwbarton> rwbartoneleven = undefined
23:43:50 <Nereid> haha.
23:44:03 <shachaf> @ty id `asTypeIn` (\i -> i id id id id id id id id id id id id id id id id id)
23:44:08 <shachaf> @ty id `asTypeIn` (\i -> i id id id id id id id id id id id)
23:44:12 <elliott> > zipper ("hello","world") % down both % fromWithin traverse % focus .~ 'q' % rezip
23:44:19 <lambdabot>   No instance for (Control.Applicative.Applicative
23:44:24 <Nereid> rwbarton: or maybe it spins for a while and then returns the 8th argument
23:44:25 <lambdabot> thread killed
23:44:27 <lambdabot>                     (Contr...
23:44:33 <Nereid> depending on whether the riemann hypothesis is true
23:44:35 <Nereid> who knows!
23:44:42 <elliott> > zipper ("hello","world") % down both % fromWithin traverse % focus .~ 'q' % rezip
23:44:49 <lambdabot>   No instance for (Control.Applicative.Applicative
23:44:54 <shachaf> You can't down both, elliott.
23:44:55 <rwbarton> :t a; b
23:44:55 <lambdabot>                     (Contr...
23:44:58 <elliott> but i want to down both
23:45:00 <Nereid> what
23:45:01 <lambdabot> parse error on input `;'
23:45:03 <shachaf> BUT YOU CAN'T
23:45:05 <elliott> but i want to down both
23:45:05 <Cale> rwbarton: lol
23:45:17 <shachaf> Hmm, can it be made so you can down both?
23:45:17 <elliott> lambdabot just parse errored that
23:45:20 <elliott> it was just slow at giving my error
23:45:20 <rwbarton> :t "a\
23:45:23 <elliott> :t down
23:45:27 <lambdabot>     unexpected end-of-file in string/character literal at end of input
23:45:33 <lambdabot> SimpleLensLike (Control.Lens.Internal.Context c c) b c -> (a :> b) -> (a :> b) :> c
23:45:35 <Nereid> what are we doing to lambdabot
23:45:38 <shachaf> focus would have to be a Traversal instead of a Lens
23:45:40 <elliott> > zipper ("hello","world") % fromWithin both % fromWithin traverse % focus .~ 'q' % rezip
23:45:47 <lambdabot>   ("qello","world")
23:45:49 <rwbarton> :t "--"
23:45:56 <shachaf> Oh, well, that's not the same.
23:45:57 <lambdabot>     lexical error in string/character literal at end of input
23:46:15 <Cale> wat!
23:46:19 <elliott> "Step down into a Lens. This is a constrained form of fromWithin for when you know there is precisely one target."
23:46:20 <Nereid> haha
23:46:27 <elliott> and within/fromWithin just take the leftmost
23:46:37 <Cale> oh, because of all the comment stripping junk
23:46:41 <shachaf> > "hello {- -} there"
23:46:42 <lambdabot>   "hello {- -} there"
23:46:47 <elliott> so what extensions does lambdabot have now
23:46:49 <rwbarton> :t :{
23:46:50 <lambdabot> parse error on input `:'
23:47:02 <elliott> it should let you say > {-# LANGUAGE Blah #-} ...
23:47:10 <elliott> except it should disallow all the nasty unsafe ones :/
23:47:19 <rwbarton> :t :set -XGeneralizedNewtypeDeriving
23:47:20 <Nereid> > {-# LANGUAGE Blah #-} 5
23:47:20 <lambdabot> parse error on input `:'
23:47:22 <lambdabot>   5
23:47:25 <rwbarton> what is this parse error from
23:47:27 <rwbarton> oh right, :t
23:47:44 <Nereid> > {-# LANGUAGE TupleSections #-} (,5) 1
23:47:45 <lambdabot>   Illegal tuple section: use -XTupleSections
23:48:02 <shachaf> @ty "hi {- -} there"
23:48:03 <lambdabot> [Char]
23:48:07 <shachaf> Hah, it only works with @type
23:48:17 <rwbarton> :t "hi {- -} there"
23:48:18 <lambdabot> [Char]
23:48:27 <Nereid> :t "--"
23:48:29 <lambdabot>     lexical error in string/character literal at end of input
23:48:29 <elliott> more features lambdabot 5 should have: running hpastes???
23:48:29 <Nereid> @ty "--"
23:48:31 <lambdabot>     lexical error in string/character literal at end of input
23:48:32 <Cale> :t "hi {- there"
23:48:33 <lambdabot>     lexical error in string/character literal at end of input
23:48:37 <rwbarton> but it is really doing :t "hi  there"
23:48:40 <ivanm> elliott: noooo!!!
23:48:41 <Nereid> > "hi {- -} there"
23:48:42 <lambdabot>   "hi {- -} there"
23:48:44 <shachaf> elliott: Your new type-level hackery challenge: Find an unsafeCoerce *so unsafe* that even looking at its type crashes the program.
23:48:47 <Nereid> > "hi {- "
23:48:49 <lambdabot>   "hi {- "
23:48:52 <Nereid> :t "hi {- "
23:48:53 <lambdabot>     lexical error in string/character literal at end of input
23:48:56 <Nereid> cool./
23:48:57 <Cale> :t "hi {- there" -}"
23:48:58 <lambdabot> [Char]
23:48:59 <elliott> > "hello {- world" test -}"
23:49:00 <lambdabot>   <hint>:1:24: parse error on input `}'
23:49:02 <elliott> :t "hello {- world" test -}"
23:49:03 <lambdabot> [Char]
23:49:12 <rwbarton> i wonder how long until we have FFI for type families
23:49:18 <Cale> so broken
23:49:24 <elliott> ivanm: wait, what's the noooo :)
23:49:30 <shachaf> rwbarton: Not long enough. :-(
23:49:38 <elliott> rwbarton: well you don't need an FFI for type families directly
23:49:43 <ivanm> elliott: running hpastes
23:49:45 <elliott> just auto-lifting of haskell functions to type families & then you can reuse the ffi
23:49:48 <ivanm> that sounds like a recipe for disaster
23:49:53 <ivanm> and auto-spamming in the channel
23:50:02 <elliott> ivanm: pfft, that's what they said about exposing a haskell interpreter over irc
23:50:04 <elliott> probably
23:50:09 <shachaf> Does ghci respect Unicode newlines?
23:50:18 <elliott> well i was thinking it'd instead load the definitions into an environment
23:50:23 <elliott> so you could use them from your own personal lambdabot >
23:50:33 <elliott> get everyone using subtly different environments to maximise confusion
23:50:34 <shachaf> Like NEW SECTION and THOUGHTFUL INTERLUDE
23:50:40 <rwbarton> how do i type "\v"
23:50:46 <shachaf> U+3F49C   PREGNANT PAUSE
23:51:16 <lightquake> i still don't get lenses :<
23:51:31 <elliott> there's barely anything to get
23:51:33 <Nereid> lightquake: do you get getter/setter pairs?
23:51:38 <lightquake> well i mean i get them
23:51:43 <lightquake> i don't get edwardk's lens library
23:51:47 <shachaf> Traversals are the thing you need to get.
23:51:54 <shachaf> Lenses are just a special case of traversals.
23:52:13 <Nereid> lightquake: do you get the (a -> f b) -> (s -> f t) stuff?
23:52:17 <lightquake> yeah
23:52:25 <elliott> lightquake: firstField (a,b) f = (,b) <$> f a
23:52:27 <shachaf> What else is there to get?
23:52:32 <elliott> secondField (a,b) f = (a,) <$> f b
23:52:37 <elliott> maybe that will help to some degree
23:52:43 <elliott> so you can see how it "gets" the value out, and also puts it back into the whole
23:53:09 <elliott> randomFieldOfMyRecord myRec f = (\newFieldValue -> myRec { randomField = newFieldValue }) <$> f (randomField myRec)
23:53:12 <rwbarton> ghci doesn't even treat \r as a newline
23:53:40 <Nereid> I wouldn't be surprised if it just discarded all '\r's
23:53:41 <shachaf> Oh.
23:53:56 <rwbarton> yes it seems to have turned it into a space
23:54:05 <Nereid> or that
23:54:07 <elliott> lightquake: then you can generalise this to multiple fields -- for instance, something that gives you access to both fields of a tuple
23:54:12 <elliott> both f (a,b) = (,) <$> f a <*> f b
23:54:19 <lightquake> well, for example, i want to go deep into some structure and get its list of Entities, apply some function to each Entity, and get the results
23:54:29 <elliott> lightquake: the pattern is simple: you extract parts from a value, apply the given "f" to them, and stitch the original value back together in some (maybe applicative) functor f
23:54:40 <elliott> except with f (er, the value, not the functor) providing the new values
23:55:35 <elliott> lightquake: well, that depends how you define the lenses for your structure :)
23:55:54 <shachaf> world.monsters.traverse.appendages.traverse.position.x += 1
23:56:33 <lightquake> no, i'm not mutating the world
23:56:38 <Cale> What's with all this writing compositions without putting spaces around the dots?
23:56:56 <shachaf> Cale: It's OO-style, man.
23:56:59 <Cale> NO
23:57:03 <shachaf> YES
23:57:05 <Cale> They're honest compositions
23:57:12 <shachaf> You can't deny your nature, man.
23:57:15 <Cale> No different from any other function compositions
23:57:16 <Nereid> lol
23:57:22 <shachaf> It's field access. It's mutation.
23:57:22 <elliott> it's so weird how lens composes lenses backwards to all the libraries before it
23:57:33 <Cale> elliott: Not that weird
23:57:34 <elliott> of course it is a nicer order
23:57:38 <elliott> but it is so weird that it works like that
23:57:40 <Nereid> a lucky accident
23:57:41 <Cale> It's explicitly inverting control
23:57:43 <shachaf> Is it actually a nicer order?
23:57:44 <elliott> mm
23:57:49 <elliott> shachaf: yes because record.field
23:57:50 <Cale> It's a worse order, I think.
23:57:57 <elliott> well it is a more convenient order
23:58:00 <shachaf> elliott: It's the opposite order of function application.
23:58:08 <Cale> But that's okay
23:58:12 <elliott> shachaf: but java
23:58:26 <shachaf> elliott: but apl
23:58:30 <Cale> It would be nicer if the order coincided with the compositional order of the getters
23:58:34 <Nereid> but brainfuck
23:58:41 <lightquake> for example, suppose i have some threat :: Entity -> Integer, and i want to get a list of pairs of (index of entity in map, threat)
23:58:44 <Cale> So that  view (f . g) = view f . view g
23:58:50 <shachaf> rwbarton++ for fixing lambdabot, by the way.
23:58:58 <elliott> lightquake: you probably actually want threat :: SimpleLens Entity Integer
23:58:59 <Cale> but meh, contravariant
23:59:12 <Nereid> it exposes the contravariant nature of things!
23:59:21 <elliott> lightquake: or at least threat :: SimpleGetter Entity Integer
23:59:26 <Nereid> ~things~
23:59:29 <Cale> It's not really exposing anything *too* fundamental...
23:59:35 <Cale> You could invert it again
23:59:40 <lightquake> elliott: in this case there's no setter, so i can't build a true lens
23:59:41 <shachaf> elliott: What's a SimpleGetter?
23:59:43 <Cale> by CPSing another time
23:59:53 <shachaf> type SimpleGetter s = Getter s s
