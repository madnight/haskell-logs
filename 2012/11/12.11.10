00:01:27 <johnw> startling: ?
00:01:39 <startling> ;)
00:02:29 <ion> heh
00:02:56 <johnw> shachaf: come on, Anna Karenina was one of my favorite books; this is all about enjoyment, not usefulness!!
00:03:03 <johnw> if I wanted usefulness, I'd be in #java
00:03:24 <johnw> "I believe because it is absurd."
00:04:02 <ion> usefulness: http://svn.codehaus.org/grails-plugins/grails-searchable/branches/0_5_5_1/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/mapping/SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator.java public class SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator implements SearchableGrailsDomainClassMappingConfigurator, Ordered {
00:16:00 * hackagebot hsc3-auditor 0.12 - Haskell SuperCollider Auditor  http://hackage.haskell.org/package/hsc3-auditor-0.12 (RohanDrape)
00:16:02 * hackagebot JuicyPixels-repa 0.6 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.6 (ThomasDuBuisson)
00:16:04 * hackagebot hcg-minus-cairo 0.12 - haskell cg (minus) (cairo rendering)  http://hackage.haskell.org/package/hcg-minus-cairo-0.12 (RohanDrape)
00:21:00 * hackagebot hsharc 0.12 - Haskell SHARC bindings  http://hackage.haskell.org/package/hsharc-0.12 (RohanDrape)
00:22:44 <manju> In Criterion, what does ci mean ?
00:23:05 <manju> std dev: 3.072357 ms, lb 1.559997 ms, ub 4.253486 ms, ci 0.950
00:23:08 <manju> What is ci ?
00:23:18 <shachaf> confidence interval?
00:23:24 <manju> What is that ?
00:23:32 <shachaf> @google what is a confidencce interval?
00:23:33 <lambdabot> http://en.wikipedia.org/wiki/Confidence_interval
00:23:34 <lambdabot> Title: Confidence interval - Wikipedia, the free encyclopedia
00:23:50 <manju> Doesn't it show something like wallclock time ?
00:24:23 <johnw> does an ideal ci == 1.0?
00:24:54 <Saizan> the time is one of the other numbers you haven't pasted, i think
00:25:26 <manju> mean: 82.67957 ms, lb 77.99956 ms, ub 87.35955 ms, ci 0.950
00:25:31 <manju> Yeah, I figured that
00:25:40 <manju> one other thing, I am doing something like
00:26:00 * hackagebot hspear 0.12 - Haskell Spear Parser  http://hackage.haskell.org/package/hspear-0.12 (RohanDrape)
00:26:00 <nyc> 95% confidence interval for benchmark performance?
00:26:30 <manju> defaultMainWith  [ bench "16x16" $ show . dftN [0,1] blah ]
00:26:31 <cinimod> I am just about to write a simulation of n-bodies. Should I use Data.Vector or Data.Array.Repa?
00:26:51 <johnw> so, it means there's a 5% that it will an outlier in either the positive or negative direction?
00:26:55 <johnw> change^
00:26:59 <manju> I want to remove show and send the output of dftN to null, in haskell code, is it possible ?
00:27:19 <johnw> manju: why are you using show at all?
00:27:47 <manju> because bench complains that it doesn't know how to handle the output of dftN
00:28:05 <manju>     No instance for (Benchmarkable
00:28:06 <manju>                        (CArray (Int, Int) (Complex Double)))
00:28:23 <srhb> cinimod: Where each entity is just a mass and position? Vector should do fine.
00:28:25 <johnw> did you say: whnf (dftN [0,1]) blah?
00:28:43 <manju> No, bench "16x16" $ (dftN [0,1] blah)
00:28:55 <johnw> you need whnf (dftN [0,1]) blah
00:28:59 <johnw> or nf (dftN [0.1]) blah
00:29:22 <johnw> depending on how much evaluation of the result you want to benchmark
00:30:03 <Nereid> I made a picture with diagrams
00:30:04 <Nereid> https://dl.dropbox.com/u/33903796/pictures/2adic.png
00:30:13 <Nereid> isn't it beautiful.
00:30:20 <johnw> for example, if dftN returns (x,y), whnf will only benchmark how long it takes dftN to create the thunks for "x" and "y".  Using nf will force the evaluation of both members of the tuple
00:30:44 <johnw> Nereid: what does it represent?
00:30:59 <Nereid> it's a picture of the 2-adic integers
00:31:14 <Nereid> idea from http://en.wikipedia.org/w/index.php?title=File:2-adic_integers_with_dual_colorings.svg
00:31:15 <johnw> what are 2-adic integers?
00:31:35 <Nereid> http://en.wikipedia.org/wiki/P-adic_number
00:31:39 <johnw> yeah, just got there ):
00:31:42 <Nereid> heh
00:31:46 <Nereid> :)
00:32:18 <johnw> i should write an IRC client mod to look up each word you guys say that's not in the dictionary on Wikipedia in the background
00:33:11 <Nereid> haha
00:33:30 <manju> johnw, When I replace bench with whnf
00:33:38 <johnw> no, not bench
00:33:50 <johnw> defaultMainWith  [ bench "16x16" $ whnf (dftN [0,1]) blah ]
00:33:55 <manju> Ah...
00:34:41 <cinimod> srhb: Ok but are there no advantages to using repa? I am going to use the leapfrog method which I will probably code via the costate comonad. Could I not expect to get some performance improvements from parallelism? Note I haven't thought very hard about this.
00:36:07 <manju> 78 us ?
00:36:14 <manju> is that microseconds ?
00:36:16 <johnw> yes
00:36:20 <manju> Damn
00:36:26 <johnw> if it seems to fast, use "nf" instead of "whnf"
00:36:29 <srhb> cinimod: I haven't the foggiest! But it seems to me that since you need to fully evaluate each new array of bodies from the full old one (don't you?) Vector will do just fine.
00:36:54 <johnw> you have to make sure you're evaluating exactly what you want to benchmark
00:37:57 <manju> defaultMainWith  [ bench "16x16" $ nf (dftN [0,1]) blah ]
00:38:02 <manju> this doesn't work ?
00:38:05 <cinimod> srhb: But I can calculate the forces on a particle from the other partciles in parallel
00:38:08 <osa1> I'm looking for a way to use $+$ combinator in Text.PrettyPrint with nesting but in a way that `a $+$ mynest 3 b $+$ c` prints b with 3 level indentation but prints c with the indentation it was before. do I need to write it myself (I can't find it in Text.PrettyPrint API)
00:38:20 <cinimod> srhb: and then sum them together
00:38:32 <cinimod> srhb: What's the downside from using repa?
00:38:35 <manju> johnw, Again it says     No instance for (Control.DeepSeq.NFData
00:38:35 <manju>                        (CArray (Int, Int) (Complex Double)))
00:38:37 <srhb> cinimod: But that would only need some use of `par`, wouldn't it - regardless
00:38:41 <srhb> cinimod: Nothing. :)
00:39:16 <cinimod> srhb: less fights with the type system? ;-)
00:40:03 <srhb> cinimod: I don't think it's that bad, really. Either way it's a great way to learn to use REPA, so why not. I was commenting on it from the "how big guns do you need" pov :P
00:40:43 <srhb> cinimod: I'd love to see your result, by the way, if I could convince you to write my name down and share the source once you're done. :)
00:41:44 <manju> johnw, thanks figured it out.
00:42:11 <cinimod> srhb: I'll try and blog the result
00:42:14 <johnw> yeah, defining NFData is usually trivial and feels like a waste of time
00:42:17 <srhb> cinimod: Awesome. :)
00:42:24 <ivanm> manju: that's what the nf and whnf functions in Criterion are for
00:42:58 <manju> ivanm, Yeah, trying to grok my way around.
00:42:58 <johnw> ivanm: does it have an hnf too?
00:43:04 <ivanm> and if you're using defaultMainWith, you need to provide a Config and a monadic action, the latter of which will probably be return ()
00:43:26 <cinimod> srhb: It will take me a few weeks probably (since I have work and other commitments). I guess I can let you know if and when I have done it on this channel?
00:44:14 <srhb> cinimod: Absolutely, I'd be very happy if you would. :)
00:46:00 * hackagebot cryptohash 0.7.8 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.8 (VincentHanquez)
00:52:44 <manju> ivanm, defaultMain defaultConfig (return ()) [ ... ]
00:53:03 <ivanm> manju: ummm, if you're using defaultMain then you don't specify the config...
00:53:05 <ivanm> or the action
00:53:23 <Nereid> > 5^8
00:53:24 <lambdabot>   390625
00:53:30 <ivanm> and my IRC connection was playing up when I said that, and I just noticed that 15 min had passed after you last said something that I saw :s
00:53:46 <manju> ivanm, Sorry, trying to figure out this.
00:54:30 <ivanm> manju: if you have a pure function, the general layout of a benchmark is: bench "name" $ <nf|whnf> function argument
00:54:31 <Nereid> > sum (map (5^) [0..8])
00:54:33 <lambdabot>   488281
00:54:41 <Nereid> that is a lot of circles
00:54:59 <ivanm> nf evaluates to normal form (i.e. force the entire value); whnf evaluates to weak head normal form (just make sure the outer-most constructor is evaluated)
00:55:37 <ivanm> so you have something like: main = defaultMain [bench "name" $ nf func x ]
00:55:41 <manju> ivanm, in my case I have a show . dftN with nf
00:55:52 <Nereid> oops I ran out of ram
00:55:56 <manju> nf (show . dftN)
00:55:56 <ivanm> manju: as in: nf (show . dftN) x ?
00:55:59 <ivanm> why bother with the show?
00:56:08 <ivanm> unless you're benchmarking the show as part of it
00:56:10 <johnw> ivanm: we've actually been through all of this already
00:56:21 <ivanm> johnw: right, as I said, my IRC connection was dodgy earlier
00:56:37 <manju> ivanm, because nf can't understand the return type of dftN which is ((Int, Int), (Int, Int)) [ Complex Double ]
00:56:39 <johnw> main = defaultMain  [ bench "16x16" $ nf (dftN [0,1]) blah ]
00:56:43 <johnw> that will do just what you want, manju
00:57:01 <ivanm> that's not a valid type...
00:57:19 <johnw> not a valid type?
00:57:26 <manju> johnw, I get this error test.hs:9:38:
00:57:27 <manju>     No instance for (Control.DeepSeq.NFData
00:57:27 <manju>                        (CArray (Int, Int) (Complex Double)))
00:57:31 <ivanm> johnw: ((Int, Int), (Int, Int)) [ Complex Double ]
00:57:38 <ivanm> oh, he didn't specify the CArray
00:57:43 <manju> Sorry, pasted it twice.
00:57:48 <johnw> manju: you need to implement the instance of NFData
00:57:59 <johnw> instance NFData CArray where rnf a = a `seq` ()
00:58:03 <ivanm> or convert it to IO and use the IO instance of Benchable
00:58:16 <ivanm> johnw: which is an absolutely rnf definition ;-)
00:58:36 <johnw> yeah, I figure he wants normal form
00:58:40 <srhb> What's the general process when writing Unbox instances? Is there a guide somewhere?
00:58:55 <srhb> (And can I write Unbox instances for any fixed-size data type?)
00:59:07 <ivanm> you'd want something like: rnf = rnf . toList
01:00:42 <manju> test.hs:9:30: `nf' is not a (visible) method of class `NFData'
01:00:51 <johnw> rnf, not nf
01:00:51 <ivanm> rnf
01:00:53 <ivanm> not nf
01:01:03 <johnw> we are isomorphic!
01:01:04 <manju> Same error with rnf too
01:01:11 <ivanm> O RLY?
01:01:19 <ivanm> @src NFData
01:01:20 <lambdabot> Source not found. My pet ferret can type better than you!
01:01:22 <ivanm> bah
01:01:24 <johnw> import           Control.DeepSeq ( NFData(..) )
01:01:31 <johnw> you'll need that in your file, manju
01:01:36 <ivanm> class NFData a where rnf :: a -> ()
01:01:43 <johnw> or that
01:01:51 <ivanm> you wouldn't want that
01:01:55 <ivanm> you want the _real_ NFData
01:02:11 <ivanm> would it be because Criterion re-exports the NFData class, but not its methods?
01:02:17 <johnw> hmm
01:02:19 <ivanm> otherwise, I can't see how NFData would be in scope but not rnf :s
01:02:20 <johnw> dunno
01:02:45 <johnw> maybe there was another error he didn't show us
01:04:05 <manju> test.hs:10:17:
01:04:05 <manju>     Expecting two more arguments to `CArray'
01:04:05 <manju>     In the instance declaration for `NFData CArray'
01:04:23 <ivanm> instance NFData (CArray i e) where ...
01:04:30 <ivanm> with the appropriate constraints on i and e
01:04:43 <ivanm> you need to specify the entire type (i.e. kind *)
01:05:10 <johnw> wow, seems like a lot of work just to benchmark a function!
01:06:08 <manju> johnw, Finally it worked!
01:06:15 <manju> But it says it takes 75 ms
01:06:23 <johnw> why is that bad?
01:07:09 <manju> I am just shocked.
01:07:14 <johnw> good shocked, or bad shocked?
01:07:22 <manju> The program I wrote in Haskell takes 8 secs
01:07:40 <johnw> you lost me
01:07:47 <manju> This FFT which is a FFI wrapper around FFTW takes 75 us
01:08:03 <johnw> how does the 8 seconds relate to the 75 ms?
01:08:07 <ivanm> yes, C-based array mangling can be faster than pure Haskell-based array mangling
01:08:18 <manju> I wrote an FFT in pure haskell, takes 8 secs and the C library takes 75 us
01:08:37 <johnw> you mean ms, or us?
01:08:42 <ivanm> manju: now go compare an existing Haskell FFT implementation that's actually been tuned, rather than your initial attempt
01:08:46 <manju> us
01:08:48 <ivanm> @hoogle fft
01:08:49 <lambdabot> package fft
01:08:49 <lambdabot> Data.Time.Clock data DiffTime
01:08:49 <lambdabot> Data.Time.Clock data NominalDiffTime
01:09:27 <manju> ivanm, Ok...
01:10:02 <manju> That is like 10000 times faster
01:10:08 <ivanm> which I think I was recommending when you first started trying to write your own FFT the other day... :p
01:10:15 <manju> Back to the drawing board then
01:11:07 <manju> ivanm, I was talking to a customer and he was telling me the problems they are facing writing code for parallel and vector architectures
01:11:14 <johnw> manju: for comparison: http://rosettacode.org/wiki/Fast_Fourier_transform#Haskell
01:11:43 <manju> ivanm, I mentioned Haskell to him and he said that if they started writing everything from scratch how is the performance compared to C or C++, so this experiment.
01:12:08 <johnw> well, you really need to tune that Haskell then
01:12:20 <ivanm> manju: a better comparison would be for you to port your FFT implementation to C and then benchmark against that
01:12:21 <johnw> have you profiled it?
01:12:32 <manju> ivanm, If they tomorrow switch over to Haskell and retrain all their engineers, would it be worth their effort, time and money.
01:12:33 <ivanm> similar data structures, algorithms, etc.
01:12:53 <manju> johnw, Not yet, I was shooting for a naive implementation.
01:13:14 <ivanm> manju: but you can't really compare a simple implementation in one language to a highly tuned implementation in another language and use that as the basis of your comparison
01:13:18 <johnw> it's easy to write slow naive implementations in Haskell
01:13:23 <manju> Just used Data.Vector etc., some basic changes.
01:13:30 <manju> johnw, Yeah :-(
01:13:31 <johnw> you might be using a lot of heap, for example
01:13:38 <ivanm> tell people to do the same task in different languages, and see how fast the results are and how long it took in both languages
01:13:43 <manju> ivanm, I agree, I am not.
01:14:08 <startling> manju: did you use -02?
01:14:10 <manju> ivanm, I need to still make it faster, this is the second step.
01:14:13 <manju> startling yes
01:14:20 <johnw> i'm not saying that fast Haskell code needs to be complex, but it does need to pay attention to when strictness is needed, make sure to take advantage of tail recursion and stream fusion, etc.
01:14:32 <manju> johnw, Yeah.
01:14:35 <johnw> manju: can you show us your code?
01:14:43 <manju> johnw, sure
01:14:59 * ivanm is upset though that his naive and stupid C implementation of one function from his code is 15-25x the speed of his tuned Haskell one :(
01:15:00 <manju> johnw, please go easy this is my first program in haskell
01:15:15 <johnw> ivanm: show me the C and Haskell functions please
01:15:15 <ivanm> manju: which is why I was questioning how you could do such a comparison :)
01:15:26 <johnw> manju: i'm just a big teddy bear
01:15:30 <manju> ivanm, No this is a first cut comparison.
01:15:40 <manju> I plan to make the haskell one faster.
01:15:52 <manju> http://code.google.com/p/my-haskell-fft/source/checkout
01:15:58 <manju> There is a file called dft.hs
01:16:11 <ivanm> johnw: benchMatchBud.hsc vs bench_match_bud.{c,h} here: http://hub.darcs.net/ivanm/dangd/browse/utils/
01:16:20 <manju> Everything is in there. It is really stupid code, so apologies in advance.
01:16:41 <johnw> youch, tl;dr
01:16:45 <johnw> sorry, ivanm
01:16:53 <ivanm> heh, yeah
01:17:23 <ivanm> the actual Haskell function is from line 380 in the hsc
01:17:40 <ivanm> the rest is the marshalling, etc. so that I could pass the value on to C
01:18:13 <johnw> manju: so, first step is to cabal configure --enable-library-profiling --enable-executable-profiling
01:18:17 <johnw> rebuild
01:18:24 <johnw> run with +RTS -hc -p
01:18:30 <srhb> How would I write an Unbox instance for some data type that has, say, four fields of the same type?
01:18:42 <ivanm> @hoogle Unbox
01:18:43 <lambdabot> Data.Array.Unboxed module Data.Array.Unboxed
01:18:43 <lambdabot> package unboxed-containers
01:18:43 <lambdabot> Language.Haskell.TH.Syntax UnboxedTupE :: [Exp] -> Exp
01:18:45 <johnw> check out the heap usage patterns; if it's going into the megabyte range, strictness is needed (unless your data set is really that big)
01:19:12 <manju> johnw, ok
01:19:32 <ivanm> johnw: I think fundamentally my slowdown is using two Maps in Haskell vs two mutating arrays in C
01:19:50 <ivanm> so lots of log n stuff piling up
01:20:06 <johnw> yeah
01:20:17 <johnw> Data.Vector.Unboxed is pretty darn quick
01:20:36 <johnw> and allows mutation if you really need to do that... just don't let anyone here know you used it :)
01:20:36 <ivanm> johnw: but that's O(n) every time I change a value, isn't it?
01:20:40 <ivanm> heh
01:21:09 <ivanm> over summer I'm hoping to actually sit down and start writing out my new graph library since I think I've worked out how to do everything
01:21:30 <johnw> ivanm: http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed-Mutable.html
01:21:33 <ivanm> and it will have monad support, so I could more easily change to using an ST-based array
01:21:36 <johnw> the write function is not O(n)
01:21:43 <johnw> it should be O(1)
01:21:55 <ivanm> johnw: yeah, but that will require re-writing my data structure library and then my code
01:22:03 <ivanm> when I should have finished this project 6 months ago :s
01:22:04 <ivanm> (at least)
01:22:08 <johnw> ah, true enough
01:22:12 <johnw> ok, plan B
01:22:19 <johnw> wrap your C function in an FFI library :)
01:22:30 <ivanm> heh
01:25:31 <johnw> manju: DV.map (xs DV.!) (DV.enumFromStepN 0 2 m) -- is this just getting all the even members?
01:26:21 <ivanm> I think there's a function that's meant to be better/faster than (xs DV.!) for getting certain values from a Vector
01:26:28 <ivanm> from my perusal of the docs the other day
01:26:30 <johnw> try: DV.ifoldr' (\i x rest -> if even i then x : rest else rest)
01:26:44 <lagagoose> anyone know how to convince the government that i have neural implants?
01:26:56 <ivanm> (before I decided that I didn't have the time to try and experiment with O(n) insertion and O(1) lookup vs O(log n) insertion and lookup)
01:26:59 <johnw> lagagoose: operate computers nearby without touching them
01:27:10 <manju> johnw, Yeah.
01:27:24 <lagagoose> johnw: is there an easier way?
01:27:26 <johnw> enumFromStepN actually has to make the whole vector
01:27:28 <ivanm> lagagoose: dig up the surgeon that did so, plans for your implants, get an MRI done, etc.
01:27:36 <johnw> so that's a huge memory waste if you're just iterating over the contents
01:27:37 <ivanm> lagagoose: and stop lying :p
01:27:56 <Nereid> I made some more pictures. https://dl.dropbox.com/u/33903796/pictures/3adic.png
01:27:58 <lagagoose> ivam: if i have neural implants, shouldn't they scan me at a secure facility?
01:28:00 <manju> johnw, Yeah
01:28:03 <Nereid> also try replacing the (last) 3 in the URL with 4 or 5.
01:28:24 <ivanm> johnw: even better than using backpermute?
01:28:26 <johnw> manju: and since yo'ure doing that 3 times per call in two different highly recursive functions, that is going to make things sloooow
01:28:40 <manju> johnw, Ok.
01:28:44 <lagagoose> you know, let's go scanning this guy for neural implants at the local hospital
01:28:58 <johnw> ivanm: I would say yes, because backpermute wants another vector
01:28:58 <ivanm> lagagoose: rather than just laughing you off as a crank?
01:29:12 <lagagoose> hopefully some idiot doctor picks up on the fact that this technology exists so they can go around torturing someone else
01:29:33 <Nereid> lagagoose: would you like to explain how that's on topic?
01:29:43 <manju> I am going to sleep for sometime now.
01:30:14 <manju> But I will save this chat log and make those changes.
01:30:17 <johnw> manju: have a good rest!
01:30:23 <manju> johnw, thank you.
01:31:28 <lagagoose> Nereid: i'm fairly sure i'm being tortured by some kind of cult
01:31:54 <lagagoose> i'm trying to figure out of the FBI is capable of detecting those threats
01:32:07 <Nereid> and what does that have to do with haskell?
01:32:22 <ivanm> lagagoose: if you're being tortured by a cult, stop opening the door and letting them into your house!
01:32:22 <lagagoose> where can i contact the FBI?
01:32:24 <lagagoose> or the CIA/
01:32:33 * Ralith suggests #fbi
01:32:38 <Ralith> but probably not #cia
01:32:43 <ivanm> there's this wonderful little invention called a "phone book"
01:32:53 <johnw> you probably already have contacted them by now, by talking about this
01:32:55 <ivanm> it's not _quite_ as good as sliced bread, but it's not bad
01:33:00 <johnw> what you want is for them to contact you
01:33:04 <ion> CIA is down anyway. http://cia.vc/
01:33:09 <ivanm> ion: heh
01:33:16 <ivanm> isn't it replaced by KGB?
01:33:20 <Ralith> that was the joke :P
01:34:28 <ivanm> in that case, you don't contact the KGB about neural implants in your head, because they'll implant _you_!
01:34:40 <Ralith> haha
01:34:41 <Ralith> nicely done
01:34:43 <ivanm> OK, that was an atrociously mangled attempt at a Soviet Russia joke
01:34:56 <johnw> well, your name IS ivan
01:34:58 <johnw> so it's allowed
01:35:03 * ivanm isn't Russian
01:35:05 <lagagoose> i see static, hear voices
01:35:07 <Ralith> I thought it was funny!
01:35:13 <lagagoose> i see pulsating over bright lights
01:35:21 <ivanm> lagagoose: better get your TV repaired then
01:35:21 <lagagoose> my memory is non-linear
01:35:30 <ivanm> Ralith: which just means your sense of humour is worse than mine :p
01:35:32 <johnw> my memory isn't even partially ordered
01:35:36 <ivanm> lagagoose: ZOMG, you remember the future!?!?!? :o
01:35:40 <Ralith> ivanm: oh well; there are worse afflictions.
01:35:51 <ivanm> true
01:35:52 <lagagoose> ivanm: some asshole is preventing me from doing so
01:36:13 <ivanm> how, pray tell?
01:36:31 <lagagoose> eh?
01:36:41 <ivanm> how is some asshole preventing you from remembering the future?
01:36:46 <ivanm> or from getting your TV repaired
01:36:53 <ivanm> whichever question of mine you were answering ;-)
01:37:52 <lagagoose> how do I get my TV repaired?
01:38:00 <lagagoose> is there something i need to do?
01:38:19 <ivanm> look in your phone book again and search for TV repairers
01:38:25 <ivanm> or you could try contacting the manufacturer directly
01:38:35 <lagagoose> how can i contact the manufacturer?
01:38:35 <ivanm> depending on the age of the TV, it might be cheaper/easier to just buy a new one however
01:38:44 <ivanm> using a telephone
01:38:45 <ivanm> or email
01:38:50 <ivanm> snail-mail
01:38:52 <ivanm> fax
01:39:08 <ivanm> nowadays, twitter and facebook are also probably valid options
01:40:37 <johnw> did I enter a different channel without knowing it?
01:41:21 <beaky> hello
01:41:35 <johnw> hi beaky!
01:41:39 <johnw> are you in Europe?
01:41:43 <beaky> what are thunks and what is thunking?
01:41:49 <beaky> europe?
01:41:57 <johnw> thunks are stand-ins for a evaluation-yet-to-be-performed
01:42:05 <beaky> ah
01:42:31 <beaky> how do i do thuking?
01:42:45 <beaky> or is it automatic in haskell?
01:42:45 <johnw> but more generally a thunk is a thing that proxies itself between the caller of a function call and the value that the caller sees as the result
01:42:49 <johnw> it is automatic
01:42:49 <ivanm> beaky: automatic
01:43:06 <johnw> s/function call/function
01:43:09 <beaky> right
01:43:19 <Cale> Thunk is just a word for the specific datastructure used to represent expressions at runtime
01:43:43 <Cale> You probably don't need to even think at that level, because thinking in terms of expression rewriting is usually more than enough.
01:43:52 <johnw> in Windows land, a DLL thunk is a "jump off" function that turns around and calls the actual function in the DLL
01:44:01 <johnw> but the general idea is the same
01:45:14 <johnw> beaky: do you know C++11?
01:45:35 <Cale> Is the idea the same?
01:45:43 <Cale> I don't know about that.
01:46:13 <Cale> There are several things which are called thunks, and apart from having something to do with pointers to code, they're mostly unrelated, I think
01:47:53 <beaky> ive only played with parts of C++11 :D
01:47:58 <johnw> I think of it as a kind of proxy for a function's value; and where that proxies behavior (postpone evaluation, call another function through a pointer, etc.) is invisible to the caller
01:48:35 <beaky> so thunks are like burittos
01:48:36 <johnw> beaky: std::future is a way to manually create the sort of thunks we generally talk about here
01:48:44 <johnw> lol
01:48:47 <beaky> inside theme are computations
01:48:56 <Ralith> welcome to #haskell
01:48:59 <Ralith> it's like a burrito
01:49:07 <johnw> beaky: you don't need to know what's inside them
01:49:11 <beaky> oh
01:49:21 <beaky> could be anything inside  thunk?
01:49:25 <Saizan> i've been here for years and never had a burrito
01:49:41 <johnw> it could be a memoized lookup
01:50:00 <johnw> you just need to know what the value from the function is when you need to know it
01:50:57 <johnw> but mostly they are computations :)
01:51:10 <johnw> i'm just trying to steer you away from thinking of Haskell execution in terms of a particular machine model
01:51:19 <beaky> haskell does a lot automatically; currying, memory management, thunking, what else? ^^
01:51:37 <startling> type-checking
01:51:42 <beaky> ah
01:51:42 <johnw> beaky: type inference
01:53:06 <beaky> @genie Int -> Int -> Int -> (Int,Int,Int)
01:53:07 <lambdabot> Unknown command, try @list
01:53:10 <beaky> :(
01:53:16 <johnw> try djinn
01:53:21 <startling> @djinn Int -> Int -> Int -> (Int,Int,Int)
01:53:21 <lambdabot> Error: Undefined type Int
01:53:25 <ivanm> beaky: (,,,) ?
01:53:27 <ivanm> @type (,,,)
01:53:28 <startling> haha
01:53:29 <lambdabot> a -> b -> c -> d -> (a, b, c, d)
01:53:29 <johnw> use type variables
01:53:35 <beaky> oh
01:53:36 <ivanm> @type (,,)
01:53:38 <lambdabot> a -> b -> c -> (a, b, c)
01:53:43 <startling> beaky: that's a pretty funny error to make
01:53:44 <ivanm> too many commas...
01:53:49 <johnw> @djinn a -> b -> c -> (a,b,c)
01:53:50 <lambdabot> f a b c = (a, b, c)
01:53:54 <beaky> @djinn a->a->a->(a,a,a)
01:53:55 <lambdabot> f a b c = (c, b, a)
01:54:04 <ivanm> lol @ djinn output
01:54:17 <johnw> hoogle works well too
01:54:22 <johnw> @hoogle a -> b -> c -> (a,b,c)
01:54:23 <lambdabot> Data.Sequence zip3 :: Seq a -> Seq b -> Seq c -> Seq (a, b, c)
01:54:24 <lambdabot> Prelude zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
01:54:24 <lambdabot> Data.List zip3 :: [a] -> [b] -> [c] -> [(a, b, c)]
01:54:27 <beaky> wow haskell even writes programs for you :D
01:54:58 <johnw> there you go, it'll even fetch your slippers in the mornincg
01:54:59 <ivanm> except Hoogle doesn't consider (,,)
01:55:18 <johnw> is (,,) actually a function?
01:55:21 <startling> @djinn a -> b -> c -> (c, b, (a, a))
01:55:21 <lambdabot> f a b c = (c, b, (a, a))
01:55:26 <johnw> or is that a tuple section?
01:55:34 <startling> johnw: actually a function
01:55:39 <johnw> oh, ok
01:56:01 <startling> (a, b, c, d) syntax is magic and desugars to (,,,) a b c d iirc.
01:56:03 <ivanm> no, I've just been referring to it and getting lambdabot to show it's type for no reason ;-)
01:56:13 <beaky> in a functional programing language, everythng is a function :D
01:56:25 <ivanm> beaky: Nothing isn't a function
01:56:40 <ivanm> nor is True, False, etc.
01:56:47 <doomlord> nothing isn't evertthing
01:56:51 <ivanm> (integral constants _could_ be functions though... :p)
01:56:57 <doomlord> everythig isn't nothing :)
01:57:01 <ivanm> s/constants/literals/
01:57:22 <beaky> i thought nothing was a Value ctor, which is a function?
01:57:42 <doomlord> nothing is nothing, whatever it is.. it isn't important
01:57:51 <beaky> right
01:58:02 <doomlord> :)
01:58:04 <ivanm> beaky: it's a nullary constructor
01:58:18 <ivanm> for it to be a funciton, it has to have a type of a -> b, for some a and b
01:58:30 <ivanm> Just is a function; Nothing is a constant
01:58:32 <beaky> :t Nothing
01:58:34 <lambdabot> Maybe a
01:58:45 <beaky> :t Just
01:58:47 <lambdabot> a -> Maybe a
01:58:50 <beaky> ah
02:01:49 <johnw> beaky: "const Nothing" is a function that returns Nothing no matter what its argument is
02:02:46 <johnw> "Nothing isn't a function".  Is that the same as saying everything is a function?
02:03:05 <abizern> I know this is a Haskell room, but is this the right place to ask about problems with cabal?
02:03:06 <beaky> :D
02:03:31 <johnw> abizern: sure
02:04:07 <abizern> cabal update keeps telling me to run cabal install cabal-install
02:04:17 <ivanm> so do so!
02:04:19 <johnw> that's because tehre is a newer version of cabal-install available
02:04:25 <johnw> it's dead sexy
02:04:28 <abizern> I update it, but it still keeps saying I need to update it.
02:04:35 <ivanm> and check that $HOME/.cabal/bin is in your PATH
02:05:17 <abizern> ooh - I don't think it is in my path - I was more worried about getting ghc on my path.
02:05:24 <ivanm> heh
02:05:52 <johnw> night all
02:10:55 <neothemachine> hey guys, I just noticed that hackage says build failure for ghc-7.6 but I can't see the real root cause in the logs except that it couldn't build a package (but no details on that). am I missing something? http://hackage.haskell.org/packages/archive/adp-multi/0.1.1/logs/failure/ghc-7.6
02:13:06 <ivanm> boy that build log is long...
02:13:26 <ivanm> OK, monadiccp failed
02:14:02 <neothemachine> right, but how do I find out why it failed?
02:14:12 <ivanm> search through the logs for monadiccp
02:14:24 <ivanm> and you'll find three instances of Illegal polymorphic or qualified type: MkEval m
02:14:34 <ivanm> it needs RankNTypes or Rank2Types by the look of things
02:14:41 <ivanm> in Control.Search.Combinator.Misc
02:15:01 <neothemachine> oh I must have missed that... yes it needs Rank2 I think
02:18:30 <neothemachine> hmm but why could I install monadiccp on my machine without any extra flags? I got 7.4
02:18:45 <ivanm> I'm guessing something changed in 7.6.1 *shrugs*
02:18:58 <ivanm> or maybe there's been a newer version of monadiccp that fixes that issue since that package failed to build on hackage
02:19:50 <neothemachine> hm no I use the newest which is from march and that's why I wonder because there's no failure on http://hackage.haskell.org/package/monadiccp
02:20:20 <ivanm> adp-multi was released in November
02:20:37 <ivanm> so if monadiccp was able to build in March, it did so before 7.6.1 came out
02:21:02 <neothemachine> ah, I see, so hackage doesn't rebuild packages with new ghc versions
02:21:07 <ivanm> nope
02:22:49 <neothemachine> https://github.com/snoyberg/conduit/issues/70 this seems to be the same problem... well, then I'll better write to the monadiccp guys
02:32:17 <abizern> ivanm: Okay I've made sure that ~/.cabal.bin is on my PATH and did cabal install cabal-install. But I don't have a ~/.cabal/bin directory, and cabal is installed in ~/Library/Haskell/ghc-7.4.2/lib/cabal-install-1.16.0.2/bin
02:32:47 <ivanm> oh, is this OSX?
02:32:57 <abizern> Yep. sorry.
02:33:19 <ivanm> at the end of "cabal help" it says where the config file is located
02:33:45 <ivanm> in there check what bindir under "install-dirs user" is set to
02:33:46 <abizern> I have a config in ~/.cabal/config
02:33:51 <ivanm> by default, it's $prefix/bin
02:34:21 <ivanm> I'm not sure what the value of $prefix is for OSX though
02:34:37 <Underbyte> okay first of all, haskell is literally digital acid
02:34:46 <ivanm> abizern: you _are_ using the default per-user installation for cabal-install, right? rather than --global?
02:34:48 <Underbyte> its awesome, but also kind of uncomfortable and scary
02:34:58 <ivanm> Underbyte: as in it literally eats through digital metal?
02:35:04 <Underbyte> anyway, If someone could help me with this small problem i would greatly appreciate it: http://codepad.org/kRxQWtNv
02:35:23 <ivanm> what's your problem?
02:35:27 <ivanm> and is this homework?
02:35:29 <Underbyte> line 25
02:35:38 <Underbyte> honestly yes it is.
02:35:40 <abizern> ivanm: Yep. Clean install of Haskell
02:35:54 <ivanm> OK, I take it that's the explanation of dodgy type sigs? :p
02:35:55 <Underbyte> we are allowed to get help so long as we list the help we have gotten
02:36:01 <ivanm> abizern: not sure how it works on OSX, sorry :s
02:36:27 <Underbyte> ivan: if you're talking about my codepad, yeah i'm erm... lol
02:36:36 <ivanm> Underbyte: so locationsOf is meant to return every co-ord that has a value of q ?
02:36:39 <Underbyte> i know its not correct fancy haskell code, but its working
02:36:41 <Underbyte> exactly
02:36:51 <Underbyte> let me give you our input real quick
02:37:01 <ivanm> Underbyte: first of all, consider line 24
02:37:47 <ivanm> either you want the value to test to be a Char - in which case, why is there a `b' there? - or you want your locationsOf function to be polymorphic in the type of values that may be stored in your 2D grid, in which case the Char type is wrong
02:37:59 <ivanm> (and you want locationsOf :: (Eq b) => b -> ... )
02:38:08 <Underbyte> http://codepad.org/ADDklE1f
02:38:11 <Underbyte> updated
02:38:26 <Underbyte> no it should not be polymorphic
02:39:02 <Underbyte> its testing against a 'char', i'm just not up to snuff about the weird semantic syntax of function declarations yet in haskell
02:39:17 <Underbyte> (i mean they are very cool, dont get me wrong... but to a C guy... its a bit like mars.)
02:39:23 <ivanm> Underbyte: let's break it down:
02:39:34 <ivanm> (Integer, Integer) is a pair of values, presumably your co-ordinates
02:39:43 <Underbyte> correct
02:39:58 <ivanm> ((Integer, Integer), b) is your co-ords matched up with some kind of value at those co-ords of type `b'
02:40:03 <ivanm> where `b' can be any type
02:40:13 <Underbyte> yep, that should be a char only. I just corrected that.
02:40:14 <ivanm> (it starts with a lower-case letter, so it's a type variable)
02:40:24 <ivanm> OK
02:40:30 <Underbyte> s/b/Char
02:40:52 <ivanm> [[((Integer, Integer), Char)]] is a list of lists of those co-ord/char pairings
02:40:57 <ivanm> presumably matching your 2D structure
02:40:58 <Underbyte> (god i cant even to a regex sub-string correctly... my brain IS fried)
02:41:03 <Underbyte> yes
02:41:13 <ivanm> (in which case, your co-ords are a bit redundant, but nvm)
02:41:43 <ivanm> now, you have: map (filter (...))
02:42:22 <ivanm> that says, for every sub-list in my list of lists, keep only those co-ord/Char pairs where the Char is the one I want
02:42:29 <ivanm> however, you're still keeping the Char there
02:42:46 <Underbyte> the reason i did that is to add unique keys to each element. There is a problem later in the assignment where you have to list ghosts ("G"), and there are multiple ones. To be unambiguous, i chose to do it like this so i can uniquely identify each ghost as (2,3),'G' , etc
02:42:54 <ivanm> if you want to get rid of the Char, you'll probably want to do a map inside that map
02:43:24 <Underbyte> right
02:43:56 <Underbyte> the way i'm understanding "map" is much like a block enumerator in ObjC or Ruby
02:43:57 <ivanm> so: map (\ subList -> map (\(coOrd, char) -> coOrd) (filter (...) subList))
02:44:01 <Underbyte> it says "Do this over each element"
02:44:05 <ivanm> yup
02:44:07 <Underbyte> okay
02:44:24 <Underbyte> (thank god i got really familiar with block enumeration DP's recently at work)
02:44:27 <ivanm> alternatively, you can do this with a list comprehension if it's clearer for you
02:44:39 <Underbyte> list comprehension is still very much 'here be dragons' for me
02:44:45 <ivanm> OK
02:44:49 <ivanm> anyway, that's what you want to do
02:45:00 <ivanm> you can either do it right after the filter, or you can do it after the concat
02:45:00 <Underbyte> but if you would like to walk me through it real quick, i would greatly appreciate it, as it sounds like this could be made much simpler with them
02:45:03 <ivanm> take your pick
02:45:27 <Underbyte> oh god damn
02:45:32 <Underbyte> ...i see the problem.
02:45:35 <ivanm> heh :)
02:45:36 <Underbyte> god, what a freshman mistake.
02:45:43 <Underbyte> i forgot the char in the return type
02:45:51 <ivanm> oh, you _wnat_ the Char in the return type?
02:45:56 <ivanm> I thought you just wanted the co-ord
02:46:33 <nand`> [ a | b <- c, d ]  =>  map (\b -> a) . filter (\b -> d) $ c
02:46:42 <Underbyte> i'll just write a function coord :: ((Int, Int), Char) -> (Int, Int)
02:47:00 <nand`> [ x^2 | x <- [0..], even x ]
02:47:03 <nand`> > [ x^2 | x <- [0..], even x ]
02:47:04 <lambdabot>   [0,4,16,36,64,100,144,196,256,324,400,484,576,676,784,900,1024,1156,1296,14...
02:47:08 <ivanm> nand`: that's not quite right
02:47:18 <ivanm> well, your transformation isn't
02:47:40 <nand`> how so?
02:47:52 <ivanm> [ f b | b <- c, d b ] ==> map f (filter d c)
02:47:59 <Underbyte> in reality this would of been better done with some typedefs
02:48:03 <Underbyte> saved me a lot of typing
02:48:08 <ivanm> type aliases you mean?
02:48:10 <Underbyte> yeah
02:48:21 <Underbyte> (sorry, i've been very much brainwashed by the man.)
02:48:21 <ivanm> Underbyte: if you're allowed to, here's a hint for your helper function:
02:48:24 <ivanm> @type fst
02:48:26 <lambdabot> (a, b) -> a
02:48:28 <ivanm> :)
02:48:32 <Underbyte> interesting
02:48:44 <Underbyte> oh yeah
02:48:51 <Underbyte> i see what your doing, exactly
02:49:02 <Underbyte> okay quick thing
02:49:16 <Underbyte> whats the difference betwen functionFoo :: <stuff>
02:49:27 <Underbyte> and functionFoo arg1 arg2 = <stuff>
02:49:35 <nand`> ivanm: I'm not seeing the difference
02:49:50 <Underbyte> should i think of it in terms of definition and implementation?
02:49:52 <ion> The former is a type signature, the latter is a definition of a value.
02:49:58 <Underbyte> aah.
02:50:05 <Underbyte> do i always need to have both?
02:50:07 <nand`> no
02:50:18 <nand`> you always need to have a definition, but you can safely leave off the type signature in most cases
02:50:19 <ivanm> nand`: you hav emagic a, d, etc. values in yours :)
02:50:31 <Underbyte> nand`: yeah i thought so
02:50:32 <ion> No, types are inferred by the compiler. But type signatures are great documentation for at least top-level values.
02:50:35 <ivanm> Underbyte: the type signatures are helpful though
02:50:40 <Underbyte> i agree
02:50:45 <ivanm> 1) they provide documentation
02:50:56 <ivanm> 2) if you write them first and then your implementation, they help pick up mistakes in your implementation
02:51:02 <Underbyte> okay, so whats the difference between def's (in .hs files) and "let foo = bar" in GHCI?
02:51:29 <nand`> there are also some cases where you need a type signature other than that; eg. if you don't disable the monomorphism restriction, or if you start using rank-2 or higher types
02:51:51 <ion> “foo” is only available after “let foo = bar” in GHCi; definitions in .hs files are available within the scope before and after the definition.
02:51:53 <nand`> it's a good idea to put type signatures on every top level definition due to the former of those two
02:52:05 <Underbyte> i see.
02:52:41 <mapf> Distribution.TestSuite + QuickCheck + test-suite { type: detailed-* }      is a modern way to test package?
02:53:01 <beaky> > (sum . (filter even) . (takeWhile (< 4000000)) . (map fst)) (iterate (\(x,y)->(y,x+y)) (0,1))
02:53:03 <lambdabot>   4613732
02:53:24 <Underbyte> i'm just trying to wrap my head around the whole 'there is no such fucking thing as mutables here, you totally to define aliases (list of ghosts ('G') for example) as a function'
02:53:39 <Underbyte> kind of a problem with iterative OOP... you tend to think in mutables
02:53:41 <nand`> lots of unnecessary parentheses there
02:53:44 <nand`> makes my eyes hurt :(
02:53:52 <ion> > (sum . filter even . takeWhile (< 4000000) . map fst . iterate (\(x,y) -> (y,x+y))) (0,1)
02:53:54 <lambdabot>   4613732
02:54:02 <beaky> I didn't know they were unnecessary
02:54:48 <ivanm> > sum . filter even . takeWhile (< 4000000) . map fst . iterate (fst &&& uncurry (+)) $  (0,1)
02:54:53 <lambdabot>   mueval-core: Time limit exceeded
02:55:04 <ion> > let f (x, y) = (y, x+y) in (sum . filter even . takeWhile (< 4000000) . map fst . iterate f) (0,1)
02:55:08 <ivanm> huh, why did lambdabot not like it when I ran it?
02:55:08 <lambdabot>   4613732
02:55:11 <nand`> > let fibs = scanl (+) 0 (1:fibs) in sum . filter even $ takeWhile (<4000000) fibs
02:55:14 <lambdabot>   4613732
02:56:01 <mapf> actually i don't understand why explicit separation to pure and impure tests are remove from cabal
02:56:25 <ivanm> mapf: I think I failed to parse what you just said... :s
02:56:31 <mapf> )
02:56:57 <ivanm> are you saying you would prefer Cabal to distinguish between pure (e.g. QC) and impure (HUnit, etc.) test suites?
02:57:39 <mapf> http://www.haskell.org/ghc/docs/7.0.4/html/libraries/Cabal/Distribution-TestSuite.html here we have pure/impure
02:57:50 <mapf> http://www.haskell.org/ghc/docs/7.6.1/html/libraries/Cabal-1.16.0/Distribution-TestSuite.html here we have not
02:58:02 <mapf> ivanm: yep
02:58:33 <ivanm> my guess is that now you typically have some kind of executable running the test suite for you
02:58:41 <ivanm> rather than allowing/requiring Cabal to somehow do so
02:58:52 <ivanm> (thus preventing you from choosing which testing framework to use)
02:59:01 <ivanm> and as such there's no real distinction any more
02:59:17 <ivanm> (and you can use the same testing framework to run _all_ of your tests for you, rather than needing multiple testing executables)
03:21:16 <Suprano> oh noes. I reached the last lesson of tryhaskell
03:21:25 <Marenz> this is not acceptable
03:22:30 <ion> Now you can’t write a line of Haskell code ever again.
03:27:55 <ivanm> "here endeth the lesson"? ;-)
03:31:40 <Marenz> yah
03:31:49 <Marenz> anything you can personally recommend to continue?
03:31:56 <shachaf> @where faq
03:31:56 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:32:01 <Marenz> I know there are tons of tutorials
03:32:08 <Nafai> @where lyah
03:32:08 <lambdabot> http://www.learnyouahaskell.com/
03:32:22 <Marenz> I wouldn't have said personally if I wanted the general answers for everyone ;)
03:32:35 <Marenz> something that you yourself had good experience with
03:32:40 <ion> @where faq
03:32:40 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:32:42 <ion> @where lyah
03:32:42 <lambdabot> http://www.learnyouahaskell.com/
03:32:45 <Marenz> sigh
03:32:47 <Marenz> nevermind3
03:33:11 <ivanm> Marenz: I learnt from craft of functional programming
03:33:12 <ivanm> and RWH
03:33:14 <ivanm> and hacking on stuff
03:33:34 <shachaf> Did you actually look at the FAQ?
03:33:43 <Marenz> I read the FAQ several times acutally
03:34:48 <ion> Two people have said LYAH as a response to your question about personal recommendations; you say “sigh, never mind”?
03:34:49 <nand`> ‘something that you yourself had good experience with’ <- lyah
03:34:55 <ion> three
03:35:21 <shachaf> I've had only bad experiences with LYAH>
03:35:29 <nand`> you say ‘no general answers’ but I would recommend the same to everyone, unless I know them better
03:35:33 <Marenz> well, the fact that you just called some bot-commands made it appear more like "read those default answers like everyone should"
03:35:48 <shachaf> Yes. You should read those default answers like everyone should.
03:35:55 <Marenz> ok
03:36:13 <shachaf> We know nothing about you, so we can hardly give personalized recommendations. :-)
03:36:23 <Marenz> it was about yoru personality ;)
03:36:29 <shachaf> Why value the answers of random people who happen to be in the channel over people who cared enough to write up a FAQ?
03:37:12 <Marenz> BEcause the people in the IRC know that I just complete the tryhaskell lessons and mgiht know where to continue from there on without repeating the just learned
03:37:44 <Marenz> but really, I don't mean to make this such a big issue ;)
03:37:49 * Marenz just reads now
03:37:49 <Underbyte> quick question guys
03:37:50 <Underbyte> isDead map = any location (pacman map) ==  location (ghosts map)
03:37:54 <Underbyte> what am i doing wrong here?
03:38:08 <shachaf> 2.3 How can I get started with Haskell right now? Check out Try Haskell. 2.4 What should I read for learning Haskell? The most popular resources are Learn You a Haskell and Real World Haskell. Each is available online for free, or can be purchased in hardcopy.
03:38:13 <ivanm> Underbyte: depends on what the error is
03:38:16 <shachaf> Seems pretty straightforward to me. :-) I wonder how the FAQ can be improved, though.
03:38:21 <abizern> Marenz: Rather than just follow tutorials - how about looking at general problems and trying to solve them with Haskell.
03:38:32 <ivanm> Marenz: since none of us know you or how you learn, we can't really provide personalised recommendations
03:38:43 <shachaf> abizern: Sounds like a bad idea, if you know nothing about Haskell.
03:38:50 <shachaf> You'll get confused straight away.
03:38:50 <Marenz> Really guys, it's okay, let's just leave this topic now :)
03:38:53 <Underbyte> ivanm: http://codepad.org/I2ntjgLA
03:39:16 <nand`> I learned what I know of Haskell by writing Haskell
03:39:21 <nand`> it's the best recommendation I can give
03:39:23 <abizern> shachaf: My personal experience is that solving some of the easier problems with Haskell was a great help
03:39:32 <pordan30> :t any
03:39:34 <lambdabot> (a -> Bool) -> [a] -> Bool
03:39:35 <shachaf> Sure, but after you know the syntax.
03:39:38 <ion> underbyte: location has the type [((Integer,Integer),Char)] -> [(Integer,Integer)] but any expects ((Integer,Integer),Char) -> Bool.
03:39:39 <shachaf> Anyway, do it as you will.
03:39:43 <nand`> yes, I started *after* LYAH
03:39:47 <ion> @type any
03:39:49 <lambdabot> (a -> Bool) -> [a] -> Bool
03:39:49 <nand`> writing programs, that is
03:40:13 <Underbyte> yeah, i hear you
03:40:19 <abizern> shachaf: Once you learn the syntax and want to start writing functions it's a good place to go IMHO.
03:41:00 <abizern> And I can see the progress I've made between newbie Haskell and slightly more exprienced Haskell.
03:41:11 <Underbyte> okay so i should be thinking of isDead = any ( == location (pacman map)) ghosts map
03:41:29 <Underbyte> ?
03:41:52 <ion> underbyte: Perhaps you mean “or ((==) <$> location (pacman map) <*> location (ghosts map))”.
03:41:59 <abizern> For Example - My first try at solving a Haskell problem https://gist.github.com/2368757
03:42:16 <Underbyte> what are those fancy things?
03:42:29 <abizern> Which I managed to rewrite once I was more comfortable with Monads - https://gist.github.com/3986006
03:42:42 <ivanm> @hoogle intersect
03:42:43 <lambdabot> Data.List intersect :: Eq a => [a] -> [a] -> [a]
03:42:44 <lambdabot> Data.List intersectBy :: (a -> a -> Bool) -> [a] -> [a] -> [a]
03:42:44 <lambdabot> System.Posix.Files intersectFileModes :: FileMode -> FileMode -> FileMode
03:42:50 <ion> underbyte: “or [ pac == gho | pac <- location (pacman map), gho <- location (ghosts map) ]”
03:43:05 <shachaf> @arr
03:43:06 <lambdabot> Aye
03:43:34 <ivanm> Underbyte: not . null $ intersect (location $ pacman map) (location $ ghosts map)
03:43:42 <mapf> hm, it seems detailed test-suites isn't supported yet
03:43:56 <Underbyte> ion thanks
03:44:13 <mapf> premature documentation =<<
03:44:20 <ivanm> mapf: heh
03:44:37 <ivanm> hmmm.... let's play golf!
03:44:45 <ion> perfection = average cabal edwardk
03:45:28 <ivanm> not . null $ liftM2 (intersec `on` location) pacman ghosts map
03:45:29 <ivanm> ;-)
03:47:25 <ion> @@ @pl @undo \location pacman ghosts map -> or (do pac <- location (pacman map); gho <- location (ghosts map); return (pac == gho))
03:47:26 <lambdabot>  (((or .) .) .) . ap (flip . (((.) . liftM2 (>>=)) .) . (.)) (flip flip ((return .) . (==)) . ((flip . (((.) . (>>=)) .)) .) . (.))
03:47:41 <mikeplus64> you monster
03:48:52 <mikeplus64> i wonder if all those .s and flips would make a difference in performance or if ghc would "optimize them out"
03:49:32 <mikeplus64> in simple cases like (f . g) x then it is trivial, but that is a big scary mess above
03:51:47 <ion> underbyte: You don’t really want to represent a maze using [String]. Create a data type for the various kinds of tiles it can have.
03:52:03 <Underbyte> i dont really have that option
03:52:09 <Underbyte> part of the HW assignment
03:53:32 <ion> The assignment says “do not use your own data type to represent the maze”?
03:54:19 <Underbyte> kind of, but in any case i dont really have time to refactor now
03:56:12 <Underbyte> http://codepad.org/Xgq6JaMU what should i be thinking of here?
03:56:28 <Underbyte> basically saying "given this coord pair, give me the object at it"
03:56:43 <nand`> Can I define a template haskell function :: -> Q [Dec] and use it at the top level in the same module?
03:56:50 <nand`> or do I have to factor it out
03:56:54 <ivanm> factor it out
03:57:19 <ivanm> Underbyte: have a look at the find function
03:57:26 <ivanm> and the lookup function
03:57:50 <ion> Or use a better representation of the data.
03:57:57 <ivanm> but, if you're going to tag values with their co-ords, I think it makes a lot more sense to just have [((Integer,Integer), Char)] rather than nested lists
03:58:17 <ivanm> ion: for beginners, using lists of lists is rather common for assignments, etc.
03:58:30 <Underbyte> yeah, that's how the data is presented to me
03:58:46 <Underbyte> i'm just using the coords as more or less a static ref
03:59:16 <Underbyte> unless theres an easy way to refactor the code so i can look that up dynamically
03:59:50 <Underbyte> http://codepad.org/hV14rcCy <-- full code
04:00:05 <merijn> If you're using (Integer, Integer) as key you might want to just go all the way and use Map. Although lists and lookup work fine as initial attempt
04:01:30 <ion> underbyte: Since it’s homework, perhaps add a comment “-- got this verbatim from #haskell before telling them this is homework” above the line. :-P
04:01:41 <Underbyte> :p
04:02:01 <merijn> Underbyte: Actually...looks like something more easily modelled by using an array...
04:02:02 <Underbyte> i will (and have to) mention that i got lots of help from #haskell
04:02:50 <Underbyte> merijn: i know its a shitty thing to say, but part of my problem is that i literally dont have the time to refactor that, not knowing what i'm doing. This is due at roughly 10:30a
04:03:05 <merijn> @localtime Underbyte
04:03:06 <lambdabot> Local time for Underbyte is 2012-11-10 12:02:47 +0000
04:03:30 <merijn> About 10 hours left, it seems :p
04:03:38 <Underbyte> its 6am
04:03:41 <Underbyte> so about 4
04:04:19 <Underbyte> CDT = UTC - 6
04:05:45 <mapf> test-framework seems as good replacement for cabal test suites though
04:06:13 <Underbyte> anyway, the big question is "how do i get the location of a member given its indicies, and how do i manipulate them" so like "(x+1, y)" , etc
04:06:31 <Underbyte> s/location/full value/
04:06:35 <Underbyte> s/location/full value/
04:06:49 <merijn> Underbyte: With your current approach I think you have to map over all lists to update a specific member
04:07:09 <Underbyte> yeah, probably.
04:07:22 <merijn> mapf: I was under the impression that cabal test suites are supposed to be used by testing frameworks to expose tests to cabal, not to use directly as programmer
04:07:45 <merijn> (Hence why I mentioned arrays, they can do index based lookups)
04:08:03 <Underbyte> *Main> playMap !! 1 !! 2
04:08:04 <Underbyte> ((1,2),'F')
04:08:06 <Underbyte> looks like that works okay
04:09:20 <mapf> merijn: it's pretty reasonable, heh
04:09:44 <Underbyte> so heres the issue i'm having right now -- http://codepad.org/DrL33B4c
04:09:50 <Underbyte> trying to work with the specific index
04:10:04 <Underbyte> i know theres a fancy way to assign this right, but i just dont know it.
04:10:16 * Underbyte is slowly getting more and more neurotic :-s
04:10:35 <merijn> Underbyte: lists don't really (and by don't really I think I mean "really don't") provide a way to update a specific index
04:11:04 <Underbyte> so what you're saying is i'm probably going to run into serious problems trying to do mutations here
04:11:31 <merijn> I would just map over it and "if fst val == myIndex then modifyValue else unmodifiedValue"
04:11:37 <merijn> Underbyte: Yes
04:12:05 <Underbyte> what would you suggest?
04:12:21 <ion> Map perhaps.
04:13:10 <merijn> Underbyte: It might really be worth investing 10 mins into looking at Data.Array, which has a fairly simple interface and lets you do "oldArray // [(myIndex, newVal)]" to return a new array with the value at myIndex set to newVal
04:13:20 <fmap> > [1..5] % element 2 .~ 10
04:13:22 <lambdabot>   [1,2,10,4,5]
04:13:28 <merijn> Underbyte: http://hackage.haskell.org/packages/archive/array/latest/doc/html/Data-Array.html#t:Array
04:13:32 <Underbyte> does data.array support 2d natively?
04:13:38 <merijn> Underbyte: Yes
04:13:49 <Underbyte> so no array of arrays
04:14:07 <merijn> Underbyte: It works for any type that is an instance of Ix and "(Integer, Integer)" is an instance of Ix
04:14:18 <merijn> So you can just index the array by tuples
04:14:31 <nand`> whoa, this TH code compiles much faster than expected, even though it's generating some thousand type family instances
04:14:39 <ion> > replicate 3 [1..5] % element 1 . element 2 .~ 10
04:14:41 <lambdabot>   [[1,2,3,4,5],[1,2,10,4,5],[1,2,3,4,5]]
04:14:45 <jrm2k6> Hi, if I am using HStringTemplate, what is the way to create a template on multiline
04:14:49 <osa1> I'm looking for a way to put a newline between two Doc's but if neither one is empty (Text.PrettyPrint), how can I do that ?
04:14:56 <merijn> fmap: Learning COntrol.Lens might not be the best approach with 4 hours to go :)
04:14:58 <jrm2k6> i tried to add \n but it is not interpreted
04:17:22 <jrm2k6> how to make a string interpret \n?
04:19:12 <ion> Judging from the example code in http://www.haskell.org/haskellwiki/HStringTemplate it handles newlines just as another character.
04:20:29 <jrm2k6> hm
04:21:50 <fmap> merijn: yeah, and even knowing Control.Lens I'd go with arrays
04:22:03 <nand`> Control.Lens has lenses for arrays, no?
04:22:04 <nand`> :t ix
04:22:06 <lambdabot>     Not in scope: `ix'
04:22:06 <lambdabot>     Perhaps you meant one of these:
04:22:06 <lambdabot>       `id' (imported from Data.Function),
04:22:08 <nand`> :(
04:22:13 <nand`> :t at
04:22:15 <lambdabot> (Functor f, At k m, Indexed k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))
04:22:27 <nand`> though I think ‘at’ is only for maps
04:22:44 <ion> merijn: The lens example was just a joke. Using it like that would be evil. :-P
04:22:54 <jrm2k6> ion: i cannot see it
04:23:04 <jrm2k6> moreover if i have a strin
04:23:09 <jrm2k6> "hello \n lol"
04:23:15 <jrm2k6> it wont be on two lines
04:23:23 <ion> putStrLn "foo\nbar"
04:23:36 <shachaf> Oh, it's a feature of Haskell that it doesn't support annoying acronyms.
04:23:50 * shachaf sighs. Should stop.
04:24:13 <ion> shachaf: was?
04:31:29 <jrm2k6>  map (\x -> putStrLn x) (snd result) with a list like that ["import box1; \n test","isjjds \n lolololol"] -> No instance for (Show (IO ())) in an interactive ghci session
04:32:19 <ion> mapM_ putStrLn (snd result)
04:32:29 <jrm2k6> hm
04:32:48 <jrm2k6> ok i should really read more about monads , grr
04:32:49 <merijn> :t map putStrLn
04:32:50 <lambdabot> [String] -> [IO ()]
04:32:57 <merijn> :t mapM_ putStrLn
04:32:58 <lambdabot> [String] -> IO ()
04:34:19 <abizern> ivanm: Thanks for your help earlier, it was a paths problem. But not with .cabal, but the ghc binaries. You pointed me in the right direction.
04:35:20 <ion> jrm2k6: Is 2k6 a reference to the magazine, the Atari, the synthesizer or something else? :-)
04:35:33 <jrm2k6> ion: something else :D
04:35:38 <jrm2k6> but stupid
04:36:23 <jrm2k6> my name is jeremy, and in 2006 i was playing some online videos games, and i needed a nickname, and here we are
04:36:35 <jrm2k6> but i like oyur idea about the Atari
04:42:02 <nand`> awesome
04:42:24 <nand`> I can now drop the silly (u :==: v) ~ True constraint
04:43:15 <neutrino> ion: it's not like there was "the" arp 2600. they had more different revisions than any other synthesizer.
04:43:58 <ion> heh
04:49:37 <neutrino> neutrino: most notably the "pre-ambiguous-legal-action-by-bob-moog filter" and "post-ambiguous-legal-action-by-bob-moog filter"
04:50:45 <Marenz> > head [1..]
04:50:47 <lambdabot>   1
04:53:12 <ion> ion: ok
05:00:38 <beaky> how do I do a regex replace in haskell
05:01:40 <zomg> beaky: use the module Text.Regex or such
05:04:17 <beaky> should I use Text.Regex.Base or Text.Regex.Posix?
05:04:48 <zomg> just Text.Regex
05:05:05 <zomg> I mean whatever works, use that
05:05:06 <zomg> =)
05:05:16 <beaky> I don't have Text.Regex :( just those two
05:05:54 <zomg> posix is probably the most common regex flavor so you'd prob want that
05:06:08 <beaky> right
05:06:18 <zomg> I don't think base provides any functions for matching, it's just a base used by the other regex modules
05:07:20 <beaky> right
05:07:35 <beaky> is Text.Regex et al included in the stdlib?
05:07:39 <beaky> or is it some experimental hackage thing?
05:08:16 <nand`> by ‘stdlib’ do you mean base?
05:08:19 <beaky> yes
05:08:19 <zomg> No idea, check hackage and you'll probably find out
05:08:26 <nand`> I highly doubt it's in there
05:09:39 <nand`> Is there a good resource for learning how to package a library properly, including eg. how to use Cabal / write a .cabal file and how to document with haddock?
05:10:00 <nand`> also versioning policies I guess
05:13:07 <merijn> nand`: Google for haskell/hackage pvp (package version policy) and you should find the versioning policy
05:13:31 <nand`> merijn: ah, thanks
05:13:41 <merijn> nand`: I also found just running "cabal init" and filling in the questions a good way to get started with a .cabal file
05:13:57 <merijn> nand`: Most fields are rather self-explanatory and the rest is easy to Google :)
05:14:10 <beaky> :t flip
05:14:12 <lambdabot> (a -> b -> c) -> b -> a -> c
05:15:05 <ion> I like the PCRE dialect more than the POSIX one. That said, i don’t think i have needed regexps in Haskell even once so far. Parsec has been a better replacement for everything i’ve needed.
05:17:00 <nand`> what ion said
05:17:08 <nand`> the only reason you'd want regex in Haskell is for user-facing stuff
05:17:18 <Underbyte> hey guys
05:17:20 <Underbyte> quick thing
05:17:20 <Underbyte> http://pastebin.com/VBrKT5ZR
05:17:23 <Underbyte> any suggestions?
05:17:24 <mauke> The paste VBrKT5ZR has been copied to http://hpaste.org/77530
05:17:33 <shachaf> mauke's suggestion is good.
05:17:49 <ion> Hear, hear.
05:18:05 <shachaf> Anyway, try an explicit type signature.
05:18:21 <Underbyte> i'm having trouble implementing an listArray
05:19:54 <nand`> merijn: I'll try that; I guess I need cabal-install?
05:20:42 <merijn> nand`: You should already have cabal-install, no?
05:21:03 <nand`> I just installed it
05:21:34 <beaky> http://ideone.com/xN0E1H anyone want to criticize my code? :D solution to http://www.reddit.com/r/dailyprogrammer/comments/12qi5b/1162012_challenge_111_easy_star_delete/
05:23:46 <hpc> ideone says you're using 6.8
05:23:58 <hpc> either you or the site badly needs to update :P
05:25:41 <beaky> beaky@archive ~ % ghc --version
05:25:42 <beaky> The Glorious Glasgow Haskell Compilation System, version 7.6.1
05:25:50 <beaky> :D
05:26:12 <hpc> i bet naming your machine "archive" gets confusing at times ;)
05:26:19 <osa1> is there a way to import data types that are not exported by library ?
05:26:34 <merijn> osa1: Modify the library, that's about it, I think
05:27:17 <osa1> merijn: that's what I've done but I don't want to distribute that library with my program
05:27:44 <merijn> osa1: Send a change request to the maintainer with a "pretty please with a cherry on top"?
05:27:55 <merijn> osa1: That's about your only option, I think?
05:28:21 <osa1> yeah. the library last updates in april 2011. let's see if maintainer is still interested
05:38:22 <Underbyte> quick question
05:38:28 <Underbyte> are bindings made by reference?
05:38:54 <Underbyte> so looking at http://codepad.org/R3wtmmi1 for example
05:39:22 <Underbyte> lets say that i was to do in main 'let arr = mapArray rawInput'
05:39:35 <osa1> merijn: I got this as a response of the email I sent to the maintainer: "Delivery to the following recipient failed permanently" :D
05:39:39 <Underbyte> and i changed arr, would that change be reflected in rawInput
05:39:40 <Underbyte> ?
05:40:54 <manju> So when I evaluate a function using Criterion bench, it returns in nanoseconds.
05:41:02 <manju> I don't think it is doing anything.
05:41:18 <manju> I mean it is being lazy. How do I make bench actually evalute it
05:41:44 <merijn> osa1: You could decide to fork the library, make your changes and upload it under a different name?
05:45:21 <jmcarthur> Underbyte: how would you change it at all?
05:46:39 <Underbyte> good point
05:50:48 <atriq> Well, I appear to be making a library to access the Tumblr API
05:51:44 <manju> (\x -> fft2D width height x) I have a function like this
05:51:52 <manju> Is it possible to make this strict
05:52:00 <atriq> Strict in x?
05:52:10 <manju> strict in what it returns.
05:52:29 <manju> So it must run. Not be bypassed due to laziness
05:52:29 <atriq> Hmm
05:52:48 <hpc> it's already strict in what it returns
05:53:11 <hpc> when you evaluate the return value of that function, you evaluate the return value of that function
05:53:43 <hpc> what you probably want is for /calls to that function/ to force the value
05:53:51 <hpc> if i am understanding the question
05:54:12 <manju> the return value is being given to whnf of criterion.
05:54:42 <hpc> and you want it in normal form?
05:55:36 <manju> I don't know what a normal form ?
05:55:43 <manju> +is
05:56:06 <hpc> you know what whnf is?
05:56:07 <manju> defaultMain [ bench "Output " $ nf (fft2D width height) xs0 ]
05:56:22 <manju> no
05:56:35 <manju> rather I know the expansion is, but no idea what it is
05:57:02 <hpc> oh, if you're using nf you already have what you want
05:57:16 <hpc> (fft2D width height xs0) is getting evaluated completely in your benchmark
05:57:23 <manju> ok
05:57:26 <hpc> because you are using nf
05:57:31 <manju> Ok.
05:59:12 <manju> mean is 194.2309 ns (13 iterations)
05:59:20 <manju> I am kind of surprised it is so fast.
05:59:31 <hpc> FAST fourier transform
05:59:31 <hpc> ;)
06:01:04 <atriq> It's faster than sft
06:01:20 <atriq> But slower than efft
06:03:09 <manju> There is something wrong.
06:03:19 <Underbyte> how the hell do you search for elements in a 2d array?
06:03:27 <Underbyte> (Data.Arrays)
06:03:43 <manju> My naive implementation of fft in haskell is as fast as ffw ^_-
06:03:54 <manju> fftw*
06:04:36 <manju> Hi ivanm
06:05:04 <manju> SO i benchmarked my naive implementation of fft against the fftw (haskell bindings to fftw rather)
06:05:18 <manju> and my implementation if 8 ns slower
06:05:21 <hpc> manju: try it on larger samples, in the hundreds of millions of data points :P
06:05:22 <manju> it is almost as fast.
06:05:33 <manju> hpc, ah...good point
06:06:06 <Jafet> main = do r <- newIORef xs0; defaultMain [ bench "Output " $ nfIO $ readIORef r >>= fft2D width height ]
06:06:32 <magicman> @hoogle [a] -> [([a],[a])]
06:06:33 <lambdabot> Network.CGI.Protocol formDecode :: String -> [(String, String)]
06:06:33 <lambdabot> Network.CGI formDecode :: String -> [(String, String)]
06:06:33 <lambdabot> Network.CGI.Cookie readCookies :: String -> [(String, String)]
06:06:56 <hpc> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html
06:07:36 * Underbyte cries
06:07:40 <Underbyte> why did i use arrays
06:07:53 <atriq> Underbyte, what are you using them for?
06:08:24 <Underbyte> http://codepad.org/Ov2C7lAK
06:08:27 <jmcarthur> Underbyte: by "search" do you mean "index"?
06:08:56 <Underbyte> no i mean 'find element with value of "X" and return it' (so i can find its index using 'fst foo'
06:09:13 <jmcarthur> err...
06:09:21 <jmcarthur> so you want it to return a tuple of index and value?
06:09:42 <Underbyte> ((4,0),'B')
06:09:48 <Underbyte> thats how i understand they are stored
06:10:01 <jmcarthur> no, that's not how they are stored
06:10:07 <jmcarthur> they are stored as an actual array
06:10:46 <jmcarthur> the only way i know of is to write a function to do the search yourself
06:11:07 <Underbyte> god damnit.
06:11:14 <Underbyte> i knew i shouldn't of used these.
06:11:15 <jmcarthur> and the easiest way would probably be to just use assocs
06:11:19 <jmcarthur> to get a list
06:11:23 <jmcarthur> and then use list functions
06:12:03 <fmap> I guess unsafeCoerce is safe when I want to wrap/unwrap a newtype layer (or 2..)?
06:12:12 <hpc> Underbyte: the main consideration between arrays and lists is memory consumption and if you want fast random access
06:12:24 <jmcarthur> fmap: it "should" be
06:12:26 <hpc> or if you want easy definitions of various maps and folds
06:12:47 <jmcarthur> but for the latter there's vector :)
06:12:48 <hpc> if you're looking up by value instead of index, there's other structures you might like better
06:12:57 <hpc> jmcarthur: :P
06:13:11 <jmcarthur> but vector doesn't natively support 2d indexing
06:13:35 <jmcarthur> Underbyte: i don't think this function would be so hard to write for arrays
06:14:05 <Underbyte> actually its not so bad.
06:14:38 <jmcarthur> @type \x -> lookup x . map swap . assocs
06:14:39 <lambdabot> (Eq a, Ix b) => a -> Array b a -> Maybe b
06:15:22 <jmcarthur> it takes linear time, of course, but you probably expected that anyway
06:20:54 <shachaf> Igloo: foldl and foldl' in Data.Foldable are done?
06:21:03 <shachaf> Those are separate from the ones in Data.List.
06:22:53 <nand`> odd, I'm getting a ‘haddock: internal error: renameType’ when trying to generate documentation
06:23:18 <nand`> version 2.13.1
06:23:25 <Igloo> shachaf: Where are you looking that makes you think they aren't done?
06:24:12 <merijn> nand`: GHC 7.6?
06:24:15 <nand`> merijn: yes
06:24:19 <merijn> nand`: Using DataKinds?
06:24:22 <nand`> merijn: yes
06:24:39 <merijn> nand`: It's broken, there's a bug report already and I think it's fixed in the newer version
06:25:01 <shachaf> Igloo: Ah, I wasn't looking, I just thought it was a case of people talking about two different modules. :-)
06:25:05 <shachaf> I see that it's fixed in both, never mind.
06:27:34 <shachaf> Thanks for fixing it!
06:30:45 <dimka> Why ¬ breaks cabal description? How can I print ¬ in cabal description?
06:30:47 <nand`> Can't I put headings inside regular haddock comments as well? I usually group my functions and put (non-haddock) headings in front of them, it'd be a bit silly to double them all in the export list
06:31:19 <nand`> merijn: I tried building from HEAD, ‘could not find module `Control.DeepSeq`’
06:31:21 <dimka> package description in generated haddock, I mean
06:31:31 <nand`> and other than HEAD that was the newest version of haddock I have on my system
06:31:44 <merijn> nand`: I would personally just live with broken haddock until the new GHC is released
06:32:01 <nand`> but I want to see what documentation looks like for this package
06:32:06 <merijn> It only breaks for DataKinds anyway
06:32:38 <Taslem> Would there be a way of making a function { first x y } which will return whichever of 'x' and 'y' evaluate first? Probably of type first :: IO a -> IO a -> IO a?
06:33:09 <jmcarthur> Taslem: the async package as a version of that. so does unamb. also check out lub, which is a generalization of unamb
06:33:52 <jmcarthur> Taslem: unamb is for pure values and has a precondition on using it. the version in async is for IO actions
06:34:07 <jmcarthur> the unamb precondition is that if both values are not _|_, they must agree
06:34:10 <shachaf> race with IO is completely different from unamb
06:34:25 <shachaf> Even if they happen to have an identical implementation. :-)
06:34:32 <jmcarthur> shachaf: yeah. i was mentioning both because it wasn't clear what Taslem really wanted
06:34:58 <shachaf> True enough. "evaluate first" suggests unamb
06:35:16 <Taslem> Okay, I'm pretty sure that's more or less what I wanted.
06:35:34 <jmcarthur> which? async's race function or unamb?
06:36:07 <shachaf> jmcarthur: Whichever one Taslem happened to read first!
06:36:14 <Taslem> Both. I needed async's race now but I was looking into something else that needed unamb.
06:36:42 <shachaf> The package "spawn" doesn't do this but as it happens it's still pretty nice.
06:36:50 <shachaf> spawn :: IO a -> IO (IO a)
06:36:54 <Taslem> Oh, unamb also includes the "amb" function.
06:37:00 <atriq> Ugh
06:37:30 <atriq> The Tumblr API feels silly
06:37:39 <jmcarthur> yeah, unamb is actually just a combination of unsafePerformIO, evaluate, and amb
06:37:44 <atriq> But as its the first API to a website I've used I don't really know
06:37:49 <Jeanne-Kamikaze> is there something like the hashtables package but where the hash table can eventually be frozen ?
06:38:57 <jmcarthur> Jeanne-Kamikaze: that would be an excellent feature for hashtables to have!
06:39:06 <Jeanne-Kamikaze> yeah....
06:39:14 <Jeanne-Kamikaze> but I need it now :(
06:40:06 <chrisdone> anyone done any work on totality proofs in haskell?
06:40:57 <chrisdone> e.g. f :: PureHaskellProgram -> Either DunnoButHere'sWhatWeFound Proof
06:42:26 <chrisdone> my interwebs can't handle web browsing but can just about manage IRC
06:42:57 <beaky> programming in haskell ftw
06:43:16 <luite> chrisdone: does that help your programming? fewer distractions!
06:43:17 <atriq> "ftw"? more like "wtf"
06:43:23 <atriq> @hackage tardist
06:43:24 <lambdabot> http://hackage.haskell.org/package/tardist
06:43:35 <atriq> I mean
06:43:39 <atriq> @hackage tardis
06:43:40 <lambdabot> http://hackage.haskell.org/package/tardis
06:43:54 <atriq> Haskell is awesome because it lets that sort of thing be a thing
06:44:07 <hpc> chrisdone: i am sure there's a combination of vacuum and some evaluation timeout that would work
06:44:10 <bitonic> chrisdone: totality proofs seem to amount to call with smaller arguments in recursive calls in dep. typed languages
06:44:33 <luite> hpc: hm, vacuum doesn't sound like the right tool for the job
06:44:34 <chrisdone> hpc: i mean statically doing it
06:44:36 <bitonic> chrisdone: the problem is that you can express much more on "where" you are in the algorithm in those languages
06:44:39 <hpc> ah
06:45:12 <bitonic> + full pattern coverage obviously
06:45:20 <atriq> Okay, I'm not sure how to do this
06:45:33 <hpc> haskell won't be particularly useful for proofs until you can disable turing-completeness
06:45:41 <chrisdone> bitonic: even partial analysis is ok
06:45:47 <hpc> (fsvo "proof")
06:45:53 <chrisdone> hpc: i'm fine with that
06:45:56 <atriq> I want to send a HTTP GET thingy that I know will give me a 301 redirect, but I don't want to redirect!
06:46:06 <atriq> I want to stop there
06:46:10 <luite> chrisdone: hm, do you care about looping? or only exceptions?
06:46:11 <hpc> what library are you using?
06:46:20 <hpc> atriq: ^
06:46:20 <bitonic> chrisdone: well I guess it wouldn't be too hard for some software to check that you're calling with structurally small arguments, but then writing your functions might be awkward :P
06:46:32 <atriq> hpc, I'm really just beginning, but I'm using http-conduit at the moment
06:46:47 <atriq> I'm very new to it, though
06:46:52 <chrisdone> foldr should be easy to prove right?
06:47:03 <bitonic> chrisdone: but with dependent types you have a bag of tricks to show that your program terminates that you don't have in Haskell
06:47:05 <chrisdone> bitonic: well in haskell we use map/foldr and stuff like that which pass the 'structurally smaller arguments' test afaik
06:47:12 <bitonic> chrisdone: yes that's easy
06:47:19 <chrisdone> yeah, i don't care about dependent types, i care about haskell :]
06:47:21 <bitonic> assuming that the functions passed in are terminating
06:47:30 <hpc> atriq: does http not do what you want?
06:47:31 <hpc> http://hackage.haskell.org/packages/archive/http-conduit/1.8.2.1/doc/html/Network-HTTP-Conduit.html#g:1
06:47:33 <bitonic> chrisdone: well but dependent types help you prove termination
06:47:44 <chrisdone> they do, but i asked about haskell -_-
06:47:44 <shachaf> Where do I email to say that I'm taking over maintainership of a package (with the author's blessing)?
06:47:55 <shachaf> I seem to recall that there was some list for that sort of thing.
06:47:59 <hpc> atriq: ooh, hey! http://hackage.haskell.org/packages/archive/http-conduit/1.8.2.1/doc/html/Network-HTTP-Conduit.html#v:redirectCount
06:48:00 <atriq> hpc, probably, when I figure it out
06:48:05 <bitonic> shachaf: haskell-cafe!
06:48:12 <atriq> Wow
06:48:36 <hpc> atriq: it's a record on the Request type
06:48:39 <atriq> Are they record settings? The library's weird like that
06:48:39 <beaky> Anyone here an archlinux user? Should I install the ghc provided in the official repos, or should I install the unoffial haskell-platform?
06:48:48 <shachaf> bitonic: -cafe@? Are you sure?
06:48:57 <shachaf> I guess anything goes on -cafe@.
06:49:03 <bitonic> shachaf: yes, pretty sure, and you should ask before
06:49:07 <hpc> yeah, i dunno what's up with haddock but that's definitely a record
06:49:12 <bitonic> unless you've got permission of course
06:49:42 <shachaf> bitonic: http://twitter.com/donsbot/status/267060717843279872 should be sufficient?
06:49:55 <bitonic> but the usual thing for packages with unactive maintainers is to post on haskell-cafe, wait 2 weeks or so, then acquire
06:50:15 <bitonic> shachaf: sure
06:50:40 <atriq> hpc, it's exporting the accessors separate to the constructor?
06:51:08 * hackagebot lifted-async 0.1.0 - Run lifted IO operations asynchronously and wait for their results  http://hackage.haskell.org/package/lifted-async-0.1.0 (MitsutoshiAoe)
06:52:44 <shachaf> What's the right thing to do for "import Prelude hiding (catch)"?
06:53:08 <shachaf> I want my program to use Control.Exception.catch in both 7.4 and 7.6, but in 7.4 Prelude exports "catch" and in 7.6 it doesn't.
06:53:15 <shachaf> I'd rather not use an ifdef...
06:53:42 <hpc> shachaf: import qualified Control.Exception as E
06:53:48 <ClaudiusMaximus> shachaf: live with the warning, or (guessing) import Control.Exception as E ; ... E.catch ...
06:54:13 <shachaf> Yes, that's what I was thinking. :-(
06:54:14 <mauke> import Prelude ()
06:55:07 <shachaf> That works except that I don't want to explicitly name every function that's used from the Prelude.
06:57:19 <atriq> hpc, thanks
07:03:21 <dimka> Does haddock markup support list inside list definition?
07:16:09 * hackagebot libstackexchange 0.2.0.0 - StackExchange API interface  http://hackage.haskell.org/package/libstackexchange-0.2.0.0 (MatveyAksenov)
07:16:53 <mapf> how to attach a name to a property in quickcheck? i have a hierarchy of properties and i want to see detailed "stacktrace" when property falsifiabled
07:17:07 <atriq> hpc, on inspection that errors out when it runs out of redirects. I want to get the body of the 301 response?
07:18:28 <mapf> for exsample monoid have three property -- left identity, right identity and associativity
07:19:02 <mapf> and i want one combined property from these three, so i can see which one failed
07:19:26 <mapf> label seems doesn't work
07:19:33 <mapf> :t label
07:19:35 <lambdabot> Not in scope: `label'
07:19:36 <byorgey> mapf: just use a testing framework like test-framework + test-framework-quickcheck2
07:19:36 <lambdabot> byorgey: You have 1 new message. '/msg lambdabot @messages' to read it.
07:19:45 <byorgey> mapf: it lets you group tests and so on
07:20:17 <mapf> mapf: so i should have a three test instead of three properties?
07:20:41 <byorgey> no, you can keep your properties
07:20:52 <byorgey> it just lets you group several properties into a single "test" with a name
07:20:59 <byorgey> and it will tell you which one(s) failed
07:21:13 <mapf> i use test-framework and ...
07:21:20 <hpc> atriq: hmm, the docs are lying maybe?
07:21:23 <mapf> one sec, i bring exsample
07:21:30 <hpc> or you aren't on the same version as the docs
07:21:35 <shapr> The quickcheck label operator is something like =? but I forget exactly what.
07:22:58 <atriq> hpc, I think this is intended behaviour: it makes sense as that
07:23:06 <atriq> (loop escape and whatnot)
07:23:17 <atriq> It's just annoying for me
07:27:11 <Taslem> I tried to install SDL and I ran into an issue. (On Windows)
07:27:31 <bitonic> Taslem: yes, old story.
07:27:37 <Taslem> Any idea of a fix?
07:27:44 <bitonic> you can probably find ample literature on google, I've heard that a lot heer
07:27:46 <bitonic> *here
07:27:55 <atriq> hcp, I'm gonna take a look at some other libraries and see how they go
07:28:29 <bitonic> @google haskell sdl windows
07:28:32 <lambdabot> http://www.haskell.org/haskellwiki/SDL
07:28:33 <lambdabot> Title: SDL - HaskellWiki
07:28:38 <bitonic> Taslem: ^^^
07:28:43 <Taslem> It doesn't address the issue I'm having.
07:29:04 <hpaste> mapf pasted “property labels” at http://hpaste.org/77533
07:29:12 <bitonic> Taslem: did you check out this: <http://jpmoresmau.blogspot.it/2010/05/haskell-sdl-on-windows-check-hacking.html> and this <http://www.animal-machine.com/blog/2010/04/a-haskell-adventure-in-windows/>?
07:29:37 <Taslem> The former doesn't address my issue.,
07:29:43 <bitonic> ...what about the latter?
07:29:43 <Taslem> I'm not sur eif I checked the latter.
07:30:03 <mapf> printTestCase doesn't seems to work as well
07:32:56 <mapf> shapr: =? is from HUnit i guess
07:34:32 <shapr> OH right, my mistake
07:35:47 <manju> hpc, Are you around ?
07:36:59 <mapf> i can return a Test instead of Property of course but why Prop contains Rose tree then...
07:37:29 <manju> There is something very wrong.
07:38:03 <manju> Took a large file, ran my naively written fft on it and the fft interface of haskell fftw on it. My code is faster.
07:38:24 <manju> That is too good to be true.
07:38:25 <hpc> how faster?
07:38:28 <manju> It is twice as faster.
07:38:36 <ghansham> hii
07:38:40 <hpc> hmm
07:38:47 <manju> nf is doing nothing...
07:38:49 <mm_freak> manju: are you forcing your result enough?
07:38:59 <manju> mm_freak, I don't know how.
07:39:05 <ghansham> what r the advatages of haskel
07:39:08 <ghansham> ??
07:39:09 <mm_freak> manju: a safe way is to print it
07:39:24 <manju> mm_freak, But I am using Criterion to benchmark it.
07:39:52 <mm_freak> manju: i haven't used criterion, so i can't tell what you're doing
07:40:07 <manju> mm_freak, yeah...totally understand.
07:40:10 <mm_freak> manju: just saying, beware of haskell's laziness, when doing benchmarks
07:40:25 <ghansham> plz tell me the advantages over another?
07:40:28 <manju> mm_freak, yeah, that is what I am worried about.
07:40:44 <manju> ghansham, did you try doing a google search ?
07:40:48 <hpc> mm_freak: criterion has an "nf" function that forces the result while benchmarking
07:40:49 <byorgey> ghansham: a strong static type system, first-class functions, lots of powerful abstraction
07:41:00 <mm_freak> ghansham: http://hammerprinciple.com/therighttool/items/haskell
07:41:03 <hpc> so assuming a correct instance of NFData there shouldn't be a problem there
07:41:03 <ghansham> k...i ll do it
07:41:33 <manju> hpc, I am using the nf function, I tried this with a large file like you said and it says it takes the same amount of time.
07:41:54 <nand`> a great community
07:42:23 <mm_freak> manju: did you verify that your algorithm gives the correct result?
07:42:35 <manju> mm_freak, yeah, that I've verified.
07:42:56 <manju> mm_freak, I wrote a inverse dft and ran it on an image and got the original back.
07:43:01 <mm_freak> well, then the benchmark is probably valid =)
07:43:03 <manju> s/a/an
07:43:04 <nand`> “This language makes it easy to shoot yourself in the foot” <- #1 criticism about Haskell of Agda programmers worldwide?
07:43:12 <nand`> wait no, that would be ‘no dependent types’
07:43:23 <manju> mm_freak, I dont think so, I think Criterion is broken.
07:43:43 <mm_freak> nand`: the page is a bit misleading…  haskell was ranked /low/ for that one
07:43:46 <hpc> manju: if you really want to be sure, you can benchmark both libraries with (unfft (fft i) == i)
07:43:54 <nand`> oh
07:43:55 <nand`> I see now
07:44:01 <manju> hpc...hmmm
07:44:13 <hpc> but yeah, the benchmark is probably valid
07:44:36 <manju> how can a 16x16 image and 4288x3716 image take the same amount of time ?
07:44:43 <beaky> is it possible to do procedural programming / OOP in haskell?
07:44:53 <hpc> the only thing i could imagine is that you are using Int or something and it's doing happy CPU operations
07:45:09 <mm_freak> beaky: procedural yes, smalltalk-OO yes, java-OO rather no
07:45:14 <beaky> ah
07:45:16 <manju> hpc, No my input itself is Complex Double
07:45:28 <beaky> how does smalltalk OO work?
07:45:31 <beaky> in haskel*
07:45:32 <mm_freak> beaky: in fact haskell is about the best procedural language out there =)
07:45:41 <mm_freak> beaky: see haskell's concurrency system
07:45:44 <beaky> better than go? :D
07:45:49 <mm_freak> yes
07:45:58 <hpc> there's many things in the world that are better than go
07:46:03 <mm_freak> go isn't compositional, your IO monad is
07:46:05 <mapf> in fact haskell is about the best language out there =>
07:47:52 <beaky> I want to try out OOP
07:48:24 <mm_freak> beaky: what kind of OOP?
07:48:40 <t7> the one oriented toward objects
07:48:42 <beaky> yes
07:49:04 <beaky> what does the classical smalltalk examplelook like in haskell
07:49:08 <hpc> beaky: honestly, one of the best languages for OOP is javascript
07:49:13 <mm_freak> smalltalk-style (message-oriented) or java-style (encapsulation-oriented)?
07:50:28 <beaky> can both be done in haskell?
07:50:57 <mm_freak> beaky: yes, but you don't want to
07:51:05 <beaky> ah
07:51:28 <mm_freak> haskell uses smalltalk-style OO for its concurrency…  otherwise you use functional programming and composition
07:51:28 <nand`> I think the best approach is to forget about what ‘OOP’ is and how you implement it in Haskell
07:52:06 <nand`> instead, consider the problem itself; and find a solution for that, instead of trying to find an implementation strategy for another solution model for the problem
07:56:40 <manju> So I ran it with time fftw.exe
07:56:57 <manju> and it is pegging a core to 100% for a long time now.
07:57:13 <manju> So it is working, just that Criterion is not.
08:06:47 <otters> can't ghc compile with multiple cores
08:08:22 <Matthias|PC> Hi, I need to write a function that calculates faculty using list comprehension, so far I managed to write a version that works without list comprehension but I have no idea how to do it with
08:09:07 <Matthias|PC> since it's stateless I can't do something like x = [ n * x | n <- [1..5];
08:09:08 <Matthias|PC> or so
08:09:13 <Matthias|PC> oops, ]]
08:09:16 <Matthias|PC> and no ;
08:14:43 <byorgey> Matthias|PC: why do you need to do it with a list comprehension?
08:14:57 <Matthias|PC> homework-ish thing :p
08:15:15 <Matthias|PC> I can give you my other version to prove I'm not really asking for code, but I have no clue how to start with list comprehension
08:15:24 <byorgey> Matthias|PC: if you show us the code you have already written perhaps we can give some pointers.  otherwise it's impossible to know how to help.
08:15:32 <Matthias|PC> alright, hold on :)
08:15:54 <byorgey> list comprehension basically gives you  concat + map + filter
08:17:52 <Matthias|PC> http://pastebin.com/7unncQua
08:17:55 <mauke> The paste 7unncQua has been copied to http://hpaste.org/77534
08:18:36 <byorgey> Matthias|PC: and that code you pasted does what it is supposed to do?
08:18:45 <Matthias|PC> nope :p
08:18:50 <Matthias|PC> the third line is kinda entirely wrong
08:18:57 <Matthias|PC> but didn't get a lot further than that
08:19:10 <byorgey> Matthias|PC: oh, I meant, can you paste the version you wrote that works without a list comprehension?
08:19:20 <byorgey> I have no idea what the function is supposed to do.
08:19:36 <Matthias|PC> supposed to caculate faculty
08:19:40 <Matthias|PC> and yep
08:19:47 <FireFly> factorial* ;-)
08:19:52 <Matthias|PC> oh crap, sorry
08:20:00 <Matthias|PC> my English isn't that great :p
08:20:01 <FireFly> I used to make the same mistake
08:20:02 <Matthias|PC> Belgian, sorry :)
08:20:09 <Matthias|PC> http://pastebin.com/yDrZrZCi working version
08:20:13 <mauke> The paste yDrZrZCi has been copied to http://hpaste.org/77535
08:21:28 <cornihilio> dcoutts_: I'm pretty sure I should be modifying this function: https://gist.github.com/4046718 but it's in Cabal/Distribution/Simple/Configure.hs, and I know you said fixing this issue shouldn't have to modify Cabal code
08:22:19 <byorgey> ohhhh, factorial, hehe =)
08:22:54 <FireFly> I can't say using a list comprehension for that makes a lot of sense though :\
08:23:01 <Matthias|PC> any ideas on how to do that using list comprehension?
08:23:02 <Matthias|PC> yeah I agree
08:23:07 <nand`> do what? factorial?
08:23:12 <byorgey> yes
08:23:13 <FireFly> Yes
08:23:18 <nand`> there's a lot of versions here :P http://www.willamette.edu/~fruehr/haskell/evolution.html#cartesian
08:23:18 <Matthias|PC> also, can I ask something (no offence of course haha), but what is the point of functional languages exactly?
08:23:21 <Matthias|PC> is there any big upside?
08:23:21 <nand`> none with list comprehension though I think
08:23:39 <startling> you could do a fold on a list comprehension I guess.
08:23:44 <Matthias|PC> holy shit that's a lot of things I don't understand
08:23:46 <byorgey> Matthias|PC: much better facilities for high-level abstraction
08:23:47 <nand`> oh, scroll to the top of the page though, I mislinked
08:23:56 <Matthias|PC> hm I see
08:24:03 <Matthias|PC> such as the [1..10]-ish thing?
08:24:12 <byorgey> Matthias|PC: also a much better model for programming with parallelism and concurrency
08:24:17 <nand`> note: that page is offered for amusement only, you shouldn't take half of it too seriously
08:24:27 <nand`> the best version is imo; factorial n = product [1..n]
08:24:28 <byorgey> Matthias|PC: such as first-class functions
08:24:50 <byorgey> Matthias|PC: [1..10] has little to do with functional programming, you could have that in any language
08:24:51 <FireFly> Matthias|PC: compare something like "filter odd xs" vs. a C-style for-loop to filter out the odd elements of a list
08:25:03 <Matthias|PC> hm I see
08:25:06 <FireFly> the "filter odd xs" allows you to express the intent on a higher level
08:25:11 <Matthias|PC> (yeah sorry, this is my first little experience with function languages)
08:25:17 <Matthias|PC> i come from all imperative ones :)
08:25:28 <Matthias|PC> Odd to learn Haskell though, it's like learning everything over again :p
08:25:29 <Underbyte> quick question, #haskell
08:25:35 <dcoutts_> cornihilio: you don't need to change that function
08:25:45 <dcoutts_> cornihilio: you can just reinterpret the PackageDBStack
08:25:49 <FireFly> Matthias|PC: IMO those languages are the best ones, where you have to learn everything over again
08:26:04 <FireFly> It helps with expanding your mind :3
08:26:04 <Matthias|PC> It's a lot fun, definitely :). And extremly interesting
08:26:05 <dcoutts_> cornihilio: or use a local function to turn the flags into a PackageDBStack
08:26:08 <nand`> anything else is the same language with different syntax
08:26:28 <nand`> (though of course there are different degrees to which you have to re-learn)
08:26:31 <cornihilio> what do you mean 'reinterpret the PackageDBStack"?
08:26:37 <Underbyte> is there any way in hell do to "do this then that and finally this" in haskell at all? or do you _have_ to have a bottoms-up, recursive flow path in a haskell program?
08:27:10 <nand`> Underbyte: I'm not sure what you mean; ‘do’?
08:27:12 <nand`> are you talking about IO?
08:27:15 <rwbarton> or 'then'
08:27:18 <Jafet> do this; that `finally` this
08:27:22 <jrajav> Underbyte: http://en.wikibooks.org/wiki/Haskell/do_Notation
08:27:25 <startling> Underbyte, a >> b >> c
08:27:32 <Matthias|PC> I think he's talking about if something then bla else bla and finally execute bar
08:28:04 <nand`> but that has little to do with recursion
08:28:11 <Underbyte> well its just frusterating to sit here and have to have this massive hierarchy payload because every step in the recursion chain needs to add baggage to the function that calls it
08:28:26 <Pantoufle> Underbyte: do you know tail-call recursion?
08:28:26 <Underbyte> so as you go up the recursion chain these function have more and more arguments. its actually kind of silly.
08:28:33 <Jafet> Welcome to the haskell party. We always have bottoms-up flow.
08:28:34 <byorgey> Matthias|PC: anyway, sadly for you, doing factorial with a list comprehension really makes little to no sense.  It doesn't really involve a list at all unless you want to make a list of all the number from 1 to n and then take their product.
08:28:53 <Matthias|PC> byorgey: thought so :/
08:28:56 <joeyh> does something like this seem too pointless-ized, or is it generally readable? (x <$>) . y . z
08:28:58 <byorgey> Matthias|PC: which you can just do with product [1..n]  which is not really a list comprehension
08:29:01 <cornihilio> dcoutts_: I'm not sure how I'm supposed to create/modify a PackageDBStack. Since it's just a [PackageDB] which is either just the GlobalPackageDB or including the user one as well
08:29:02 * Underbyte is an Obj-C SE by trade. We are very very *very* top down, abstract design.
08:29:12 <Jafet> joeyh: fmap x is shorter?
08:29:13 <Matthias|PC> I'll just skip this question then, thanks :)
08:29:19 <byorgey> sure =)
08:29:23 <Underbyte> Pantoufle: i've probably heard about it, but my brain is kind of fried
08:29:23 <joeyh> ah, true.. I'm too fond of <$> :)
08:29:38 <nand`> fmap x . y . z -- is fine
08:29:50 <Pantoufle> Underbyte: then you should rest :)
08:29:52 <nand`> (x <$>) I would avoid using simply because you have to stop and think about it for a second
08:30:01 <joeyh> for some reason my brain still can read <$> better than fmap. silly brain
08:30:10 <Underbyte> well technically my HW project is due in about 60 seconds
08:30:13 <Underbyte> ....thats not going to happen.
08:30:16 * byorgey doesn't have to stop and think about (x <$>) for a second
08:30:34 <Underbyte> http://codepad.org/OAaZ4iV9 <-- what i've got done so far
08:30:39 <Jafet> I avoid using it simply because it's horrible to type on a qwerty
08:30:49 <byorgey> but I agree with nand`'s general advice to use things that make the most sense to you.
08:31:01 <nand`> (x <$>) is just syntax noise to me at first; then I recognize ‘<$>’ as fmap and see that it's just (<$>) x
08:31:09 <Underbyte> i think i've laid out much of the "logic layer" (AKA controller logic if you're thinking MVC), but i have no idea how to actually build the state machine
08:31:11 <Underbyte> zero clue
08:31:16 <nand`> ‘fmap’ on the other hand I recognize almost instantly, the brain has this uncanny ability to do that with words
08:31:32 <nand`> also, ( ) involves two parentheses two many :)
08:31:37 <Matthias|PC> how do you say a function will return a list? somefunc :: Integer -> [] or [a] does not work
08:31:50 <rwbarton> a list of what
08:31:53 <Jafet> Phmap phmap
08:31:55 <Matthias|PC> integers
08:32:02 <joeyh> all good points. I'm gonna use fmap, perhaps more of it in my code will better train the neural networks
08:32:07 <rwbarton> somefunc :: Integer -> [Integer]
08:32:34 <Matthias|PC> ah, thanks
08:32:46 <cornihilio> dcoutts_: I just don't get what you mean by specifying the PackageDBStack, since it can only contain these 3 kinds of PackageDB's: https://gist.github.com/4051598
08:33:03 <byorgey> ah, the old "brains recognize words better than symbols" argument
08:33:07 <byorgey> guess what, words are just symbols
08:33:09 <cornihilio> dcoutts_: sorry if I am bugging you too much, it's just that this isn't all that clear to me
08:34:03 <nand`> byorgey: I would argue that my brain is many times more trained on roman letters and sequences of them than it is on strings like (<$>)
08:34:39 <byorgey> well, my brain happens to recognize <$> faster than fmap
08:34:42 <fliip> If you have a lambda function (pred)(n) = n-1 how would you go about proving that using infuction?
08:34:43 <Jafet> b70R93y
08:34:46 <startling> mine too, I think.
08:34:48 <byorgey> it all depends what you've spent time practicing
08:34:50 <fliip> induction*
08:35:26 <rwbarton> fliip: proving what
08:36:10 * hackagebot kevin 0.1.5.4 - a dAmn  IRC proxy  http://hackage.haskell.org/package/kevin-0.1.5.4 (JoelTaylor)
08:36:12 * hackagebot JuicyPixels-repa 0.6.1 - Convenience functions to obtain array representations of images.  http://hackage.haskell.org/package/JuicyPixels-repa-0.6.1 (ThomasDuBuisson)
08:36:17 <fliip> That a specific lambda function is the say successor function.
08:36:21 <nand`> What would be the simplest way to add a minimal test-suite (to .cabal) that just compiles and succeeds immediately, without doing any testing?
08:36:25 <fliip> or the pred function.
08:36:53 <nand`> fliip: I guess you would need to work the evaluation rules of the lambda calculus into your logical system
08:36:59 <Jafet> I need to find a good moment to use "infuction"
08:36:59 <nand`> as well as equality
08:37:08 <jmcarthur> i, too, find (<$>) to be just as easy or easier to immediately recognize than fmap. it's visual, whereas fmap is just a word.
08:37:24 <Jafet> Anyway, haskell isn't a formal proof language so there is no way to answer that question
08:37:25 <fliip> Sorry, nand. What do you mean? equality?
08:38:11 <fliip> The trouble is n is a function, and not just a number.
08:38:26 <fliip> Well a representation of a number, so im confused how to go about induction.
08:38:44 <Jafet> Does this have anything at all to do with haskell
08:39:18 <fliip> Do you know what Lambda Calculus is?
08:39:29 <Jafet> That's a no, then
08:39:51 <fliip> Haskall is based on Lambda calculus.
08:40:03 <fliip> haskell*
08:40:17 <Jafet> Even if it was, which it's not, it's not relevant
08:40:22 <fliip> So the same principles apply to both.
08:40:24 <fliip> Yes it is.
08:40:25 <bitonic> Haskell is based on computation
08:41:10 <kranius> transforming stuff into another stuff
08:41:10 <fliip> Most functional programming languages are based on the Lambda Calculus...
08:41:49 <bitonic> fliip: they're based on computation too.  they often run on computers
08:42:04 <fliip> Sorry, someone asked what relevance lambda calculus had in here...
08:42:09 <fliip> I was answering his question.
08:42:25 <Adeon\SIGSEGV> haskell is based on english
08:42:30 <Adeon\SIGSEGV> many names originate from the english language
08:42:32 <Jafet> Not that your question has much to do with the lambda calculus either
08:42:59 <Jafet> Basically you have some weird definition of natural numbers that happens to use symbols from lambda calculus
08:43:09 <Jafet> And you want to prove something about it
08:43:15 <nand`> fliip: extensional equality; f = g iff ∀x. f x = g x
08:43:32 <fliip> Ah ok thanks nand.
08:43:40 <fliip> At least some people in here are helpful and not anal.
08:43:49 * cmccann belatedly notes that for readability he prefers fmap for stuff like (fmap f) or (liftA2 fmap), but (<$>) otherwise 
08:43:51 <bitonic> fliip: you can't prove that in Haskell
08:43:55 <bitonic> *in* haskell
08:44:03 <Jafet> Anal, huh
08:44:04 <nand`> I use f <$> x instead of fmap f $ x, for example
08:44:11 <fliip> Yes anal.
08:44:13 <Jafet> Ok then, you can troll some help out of the other people in the channel
08:44:27 <fliip> Troll? What? I just asked a question?!
08:44:41 <fliip> Im sorry there is no lambda calculus room...
08:44:50 <fliip> Jesus...
08:44:55 <nand`> there might actually be
08:45:03 <cmccann> why are we being antagonistic here? :T
08:45:16 <jmcarthur> calm down guys. i think lambda calculus questions are reasonable here
08:45:21 <fliip> Thank you.
08:45:31 <nand`> I don't know. I think Jafet's criticism is a bit out of place; but I don't want to argue about it any more than already has been
08:45:34 <rwbarton> certainly more reasonable than useless discussion about that haskell is "based on"
08:45:40 <rwbarton> *what
08:45:41 <nand`> I agree that lambda calculus seems relevant in here
08:45:41 <cmccann> I've use GHCi as an overly elaborate lambda calculus interpreter many times
08:45:58 <bitonic> I think that the issue here is that the question is not clear
08:45:59 <Jafet> I wasn't criticising anything
08:46:08 <nand`> wrong word, I guess
08:46:24 <jmcarthur> yeah i also don't understand the question
08:46:33 <bitonic> fliip: what exactly do you need?  do you need to prove properties about functions *in* Haskell?  or do you want to reason about Haskell programs?  or do you want to prove things about lambda-calculus terms?
08:47:09 <nand`> it sounded fairly understandable to me; ‘I defined some lambda function, say, ‘pred’, and I want to prove that pred x = x-1’ <- I'm assuming he has some representation of numbers and subtraction in the lambda calculus and wants to prove that his ‘pred’ function works as expected
08:47:18 <monochrom> but ghci doesn't do all of untyped lambda calculus per se. you have problems with λx. x x
08:47:24 <Jafet> But I would send some emails to these people's lecturers if I had their addresses
08:47:43 <fliip> Im trying to understand lambda calculus and proofs. I was trying to understand how you apply induction to say a term works a a predecessor function but i wasnt sure how to do that as nuerals are expressed as functions.
08:48:00 <bitonic> nand`: so you want show that `pred x' reduces to some canonical lambda term for `x - 1'?
08:48:34 <cmccann> monochrom, a typed lambda calculus interpreter, then. for untyped I'd probably use a scheme repl of some sort...
08:48:35 <nand`> bitonic: as far as I understood it, yes; judging by fliip's recent remark I think it's a bit more general than that, ie. how to prove two functions in the lambda calculus are the same thing
08:49:07 <cmccann> fliip, are you using church numerals?
08:49:08 <monochrom> ah, except that scheme does call-by-value, so the Y combinator doesn't work there :)
08:49:17 <fliip> I am yes.
08:49:25 <bitonic> nand`: because that question heavily depends on what lambda calculus are you in and how you evaluate things - it is still very vague
08:49:38 <nand`> bitonic: there are more than one?
08:49:55 <fliip> For example how would you prove the succ function "succ n = n+1" using inducton?
08:49:56 <monochrom> at the end, I wrote my own untype lambda interpreter. oh wait, it does call-by-value too...
08:50:05 <bitonic> fliip: what's `+'?
08:50:07 <fliip> Where succ = (\nfx.f(nfx))
08:50:21 <Jafet> nand: they come up with a new one every tuesday
08:50:21 <fliip> + is plus
08:50:28 <bitonic> fliip: what plus?
08:50:31 <rwbarton> you should translate your statement into more precise language and then it will become obvious
08:50:34 <fliip> So (fx.fx) = (fx.f(fx))
08:51:10 <fliip> Or rather (\nfx.f(nfx))(fx.fx) = (fx.f(fx))
08:51:19 <bitonic> nand`: well depending on your evaluation strategy you might have different terms in a normal form that both represent `2' or whatever
08:51:20 * cmccann has been meaning to write some manner of linear typed lambda calculus interpreter
08:51:29 <rwbarton> "succ n = n+1 Where succ = (\nfx.f(nfx))" -- you are mixing levels here
08:51:55 <monochrom> I do not know the definition of "n+1" in this question. please don't just tell me "addition as in daily life". clearly this question is not about daily life.
08:52:10 * monochrom should not get involved to begin with
08:52:53 <fliip> Erm. Sorry. I dont know how else to explain it.
08:55:11 <Jafet> In these things, I usually begin by proving false
08:55:12 <bitonic> fliip: so it seems that you don't really know what you're asking either, you should do what rwbarton said
08:55:34 <Jafet> If possible, it makes everything a lot simpler
08:55:48 <rwbarton> well here is an issue to reflect upon, you say "+ is plus", assuming you mean addition of regular integers, then when you write "succ n = n+1" you have some problems, since succ is a lambda calculus term, but n is an integer
08:56:03 <monochrom> I think some of my students do that. prove false first. :)
08:56:08 <rwbarton> so you should figure out what you really mean by "succ n = n+1"
08:56:13 <fliip> Sorry, I meant n is a number expressed as a church numeral.
08:56:20 <Jafet> If they do it correctly, what grade do they get?
08:56:27 <rwbarton> okay! this is better
08:56:39 <bitonic> fliip: OK so `+' must be some operation on church numerals
08:56:49 <rwbarton> however it would still be clearer to distinguish the number n and the church numeral
08:57:13 <fliip> Ok.
08:58:07 <jmcarthur> Jafet: fame
08:58:38 <fliip> So do I have to find a function for + in lambda?
08:58:44 <monochrom> http://ro-che.info/ccc/14.html  hehe
08:58:48 <Jafet> Clay should totally make it a millenium prize problem
08:59:01 <Jafet> Prove false in ZFC
08:59:10 <rwbarton> here is a suggestion: write [n] for "the church numeral representing the integer n"
08:59:43 <fliip> Ok thanks! hmm.
09:00:01 <bitonic> fliip: I don't understand what the issue here is in the first place.  I suspect that what you want is that there is a correspondence between those lambda terms and naturals, and between `succ, pred : Term -> Term' and `+1, -1 : Nat -> Nat'
09:00:25 <nand`> how does Cabal handle test suites which fail to compile? Does that count as a ‘failure’ or does that abort the entire build process?
09:00:40 <rwbarton> your statement is of the form "for every nonnegative integer n, <something>" -- and you can try to prove it by regular induction on the integer n
09:00:47 <Jafet> It counts as a failure, which aborts the build process
09:00:50 <cornihilio> could someone recommend a good tutorial to getting tags working with emacs and haskell?
09:00:54 <rwbarton> just because you learn about church numerals does not mean you have to forget everything you know about math
09:01:18 <Jafet> Well, a build failure, perhaps you meant a test failure
09:01:24 <cornihilio> it seems like the tags lookup for haskell is really not working for me
09:01:35 <fliip> Im not very good at math in the first place. I think this is the problem.
09:01:36 <fliip> =(
09:02:03 <bitonic> fliip: nah, you're most likely good enough for this.  the issue is that you haven't framed your problem :P
09:02:05 <nand`> Jafet: I meant a test failure
09:02:39 <Jafet> It's whatever type of failure that aborts the build process
09:03:00 <fliip> Well I dont want to ask the question im trying to answer. Im trying to give examples similar so I can learn and then apply it to the question im trying to answer.
09:03:28 <fliip> If that makes sense...
09:04:36 <fliip> And no its not marked or anything. Im just trying to learn...
09:04:51 <bitonic> fliip: I really think that what you want to establish here is that church numerals "behave" like the natural numbers with respect to their increment/decrement operations
09:05:12 <fliip> can I pm you bitonic please? I will try to explain better?
09:05:32 <bitonic> no let's keep it here, I won't be here for long and I'm not that great anyway :)
09:06:02 <osfameron> keeping help in channel helps more people learn, its the preferred way on most channels
09:06:28 <osfameron> possibly all
09:06:46 <fliip> I'm more trying to prove that the successor function (\nfx.f(nfx)) applied to a church numeral, equals that church numeral plus one expressed also as a church numeral?
09:07:11 <bitonic> fliip: but what's the difference between that function and "plus one"?  what's "plus one"?
09:08:04 <fliip> So for n plus one would be: (\fx.f(n fx))
09:08:09 <fliip> I ghink ghzgx fight.
09:08:16 <fliip> I think thats right*
09:09:08 <fliip> Oh. That is the plus one function I guess.
09:09:09 <bitonic> OK, so you want to prove that for all `n', `succ n' is equal to `\f x . f (n f x)'?  that looks pretty easy given your definition of `succ'.
09:09:12 <fliip> Its the successor function.
09:09:23 <bitonic> yeah
09:09:47 <fliip> Do I reduce the lambda term somehow?
09:10:57 <bitonic> fliip: well, the only reduction rule for lambda calculus is beta-reduction.  it doesn't look like we can reduce much there.
09:11:30 <fliip> Ok.
09:11:45 <bitonic> the only candidate for reductions is `n', but that `n' is implicitly quantified as well in your reasoning :)
09:11:54 <atriq> Ugh
09:12:01 <atriq> I don't like the curl library
09:12:16 <atriq> But http-conduit doesn't want to work for what I need, I think
09:12:43 <fliip> Sorry, I dont understand what you're saying.
09:13:09 <fliip> My terminology is poor. What does implicitly quantified mean?
09:13:24 <atriq> Aaah
09:13:27 <atriq> I see what I need
09:14:32 <cornihilio> why would you have this in your code?: import qualified Data.Map as Map; import Data.Map (Map)
09:14:55 <cornihilio> isn't that redundant?
09:14:59 <atriq> cornihilio, it gives you the Map name as "Map", and all the functions as "Map.function"
09:15:01 <geekosaur> no
09:15:10 <atriq> The second import only gives you the type
09:15:17 <geekosaur> so your data types don't have to be declared as Map.Map foo
09:15:21 <atriq> But unqualified
09:16:07 <fliip> Oh. I understand! Thanks bitonic!
09:16:20 <fliip> and everyone else.
09:16:21 <fliip> =)
09:16:45 <dmwit> ?unmtl WriterT [done]
09:16:46 <lambdabot> Plugin `unmtl' failed with: `WriterT [done]' is not applied to enough arguments, giving `/\A B. A (B, [done])'
09:16:47 <dmwit> uh
09:17:11 <dmwit> ?unmtl WriterT [done] (EitherT err (StateT s m a))
09:17:12 <lambdabot> Plugin `unmtl' failed with: `WriterT [done] (EitherT err (s -> m (a, s)))' is not applied to enough arguments, giving `/\A. EitherT err (s -> m (a, s)) (A, [done])'
09:17:51 <dmwit> ?unmtl WriterT [done] (EitherT err (StateT s m)) a
09:17:52 <lambdabot> EitherT err (StateT s m) (a, [done])
09:18:25 <rwbarton> ?unmtl ErrorT e m a
09:18:25 <lambdabot> m (Either e a)
09:18:30 <dmwit> thx
09:18:36 <dmwit> ?unmtl WriterT [done] (ErrorT err (StateT s m)) a
09:18:37 <lambdabot> s -> m (Either err (a, [done]), s)
09:18:56 <mapf> wow
09:19:35 <dmwit> ?unmtl ErrorT err (StateT ([done],[unprocessed]) m) a
09:19:36 <lambdabot> [done] -> [unprocessed] -> m (Either err a, [done], [unprocessed])
09:20:02 <bitonic> fliip: yw
09:20:08 <dmwit> zat looks gut
09:24:28 <otters> so I just upgraded my cabal and got this https://gist.github.com/4023181
09:25:36 <Pantoufle> Oh
09:25:38 <apfm> otters: gentoo?
09:25:42 <otters> no, OSX
09:26:02 <otters> oh, there's also a bug on the github cabal-dev tracker that was most recently updated six days ago
09:26:22 <doomlord>  /join #hardware
09:26:37 <Sculptor_>  no thanks
09:27:50 <apfm> otters: strange thing, but this link refers to my gist :[
09:28:10 <mapf> otters: hi, dmitry.
09:28:20 <otters> apfm: yeah, I just googled the problem and found a bunch of gists
09:28:39 <otters> so I was like "hey, might as well save time, just use one of these"
09:28:45 <otters> but my cabal-dev has been built with cabal 1.14
09:28:47 <otters> this is confusing
09:29:12 <otters> of course ghc-pkg doesn't think cabal-dev exists
09:29:28 <apfm> version of cabal-dev?
09:29:33 <otters> 0.9.1
09:29:35 <geekosaur> or just build cabal-dev from its repo
09:29:36 <otters> built with 1.14.0
09:29:40 <otters> I just upgraded to 1.16.0.3
09:29:46 <otters> so I'll reinstall cabal-dev
09:30:03 <apfm> Seems like cabal-dev is broken with new cabal
09:31:02 <otters> yeah, cabal-dev --version says it was built with Cabal 1.14.0
09:34:42 <monochrom> perhaps it is not so wise to upgrade Cabal or cabal-install
09:35:05 <geekosaur> I just installed cabal-dev from github and it worked.  apparently they haven't released yet
09:35:33 <applicative> the bug report has a patch, i guess you saw? https://github.com/dagit/cabal-dev
09:35:39 <geekosaur> (Lion, latest HP then upgraded cabal/cabal-install to 1.16.0.2/3)
09:36:11 * hackagebot bash 0.1.4 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.4 (JasonDusek)
09:37:24 <fmap> how about zsh?
09:37:52 <monochrom> waiting to be written
09:38:06 <monochrom> this is how lazy programming works
09:40:15 <demir> so many haskell lovers here
09:40:19 <cornihilio> where is the event file that traceEventIO logs to? should it be in folder where the binary is run?
09:41:18 <atriq> Well, this is working
09:42:33 <nooodl> demir: nah, most of us only pretend to like haskell
09:43:26 <edwardk> shachaf shachaf shachaf i invoke thee.
09:43:36 <demir> what are the applications of haskell, this doesn't seem like a server-side language
09:43:50 <jmcarthur> it's general purpose
09:43:50 <edwardk> demir: haskell can be used for anything its a general purpose programming language.
09:43:52 <otters> pretty much anything
09:43:56 <jmcarthur> you can use it for whatever you want
09:43:57 <atriq> Time travel
09:44:02 <atriq> For example
09:44:11 <atriq> (only sort of)
09:44:11 <monochrom> haskell is used both server side and not server side
09:44:27 <atriq> @faq Can Haskell do what demir wants to use it for?
09:44:28 <lambdabot> The answer is: Yes! Haskell can do that.
09:45:00 <demir> this channel is really fun guys :)
09:45:09 <edwardk> demir: it gets used for everything from web frameworks (yesod, snap, happstack) to version control to financial number crunching (at standard chartered, here and elsewhere) to designing circuits (bluespec, kansas lava) to sat solving to cryptography (at galois, mitre) to ...
09:46:00 <nand`> demir: I use it for basically everything I want to write
09:46:11 <edwardk> demir: computer vision (at upenn), drawing diagrams, all sorts of things fall into the scope of haskell. its just a nice language to think in that runs really fast and makes some things that are crazy difficult in other languages easy.
09:46:22 <jmcarthur> same here. if i want to write something, haskell is my first tool
09:46:54 <jmcarthur> about the only thing it hasn't replaced for me is shell scripting
09:47:01 <edwardk> @tell shachaf interestingly if we never use . and eta-expand everything to begin with in the definitions we don't wind up with the eta-expansions in the resulting core
09:47:02 <demir> I mean, what are the advantages or differences over any other language like C for example
09:47:02 <lambdabot> Consider it noted.
09:47:23 <Pantoufle> Hum
09:47:26 <Pantoufle> oops
09:48:21 <demir> javascript is my first choice most of the time
09:48:31 <nand`> don't forget about ‘writing operating systems’
09:48:34 <edwardk> demir: in c you can have side-effects everywhere. this sounds like a win for c, right? but it also means you have a harder time reasoning about the resulting code since almost anything can do anything
09:48:35 <jmcarthur> demir: it's a very different way of thinking about programming. it's actually pretty hard to enumerate the differences. i would say that the most significant difference that influences most other differences is purity
09:49:16 <jmcarthur> demir: where "purity" roughly means that your code isn't going to be subject to crazy side effects coming at you from the side
09:49:27 <edwardk> that latter property turns out to be more valuable. parallelizing c code is a rather epic endeavor involving smart people and something you engineer for from the ground up. parallelizing haskell code can be as simple as sprinkling a few `par` connectives through the code
09:49:49 <edwardk> we still have those side-effects, we just contain them within the IO "monad"
09:50:07 <edwardk> and so we can cleanly demark the portions of the code that need trickier reasoning
09:50:10 <cornihilio> where is the event file that traceEventIO logs to? should it be in folder where the binary is run?
09:50:14 <mog_> c = manutention of memory, haskell = describe how objects a rerelated, it'd very different
09:50:15 * jmcarthur would call those "effects" instead of "side-effects"
09:50:22 <mog_> related*
09:50:25 <jmcarthur> although i guess the IO monad blurs the two a bit
09:50:38 <cornihilio> I have this in my .cabal:     ghc-options:        -Wall -threaded -eventlog
09:50:38 <demir> well, maybe I should give it a try. Can you suggest any starting-guide or something.
09:50:42 <mog_> and it's*, wow, can't use a keyboard tonight ~~
09:50:45 <jmcarthur> @where lyah
09:50:46 <lambdabot> http://www.learnyouahaskell.com/
09:50:46 <edwardk> @where lyah
09:50:46 <lambdabot> http://www.learnyouahaskell.com/
09:50:49 <atriq> Ugh, OpenAuth
09:50:50 <jmcarthur> demir: ^^
09:50:51 <demir> other than the tryhaskell.org
09:50:51 <bitonic> jmcarthur: well you need effects in any useful program.  you can definitely program "effets" in haskell
09:50:57 <edwardk> learn you a haskell is a nice tutorial that is very gentle
09:51:00 <edwardk> @where rwh
09:51:01 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:51:16 <edwardk> real world haskell on the other hand assumes you already know how to program and want to start getting stuff done right away
09:51:18 <jmcarthur> bitonic: i think the need for effects in useful programs depends on what is meant by effects at all
09:51:24 <edwardk> the two approaches complement each other nicely
09:51:33 <bitonic> jmcarthur: interaction with the world, launchMissiles etc.
09:51:49 <edwardk> so if you go through one and the pace seems off pick up the other, or if you get stuck flip, etc.
09:52:01 <jmcarthur> bitonic: there are many programs which are mostly purely functional anyway, and would be purely functional if the OS was solely responsible for feeding them input and output instead of the programs themselves
09:52:12 <arkantos> Hi, just to let you know guys, Im a full time Python developer, and I found Haskell learning a rewrite to my brain code, its fun, challenging and makes you think in different and efficient ways to solve hard problems, since I'm learning Haskell I find myself a better Python developer and my love for this new (at least for me) language and paradigm is increasing over the time as well. Simply a perfect brain booster!
09:52:13 <jmcarthur> *and reading the output
09:52:29 <jmcarthur> arkantos: awesome! :)
09:52:36 <monochrom> use more lambdas in your python!
09:52:45 <edwardk> arkantos: great to hear =)
09:52:49 <bitonic> jmcarthur: well if you are arguing for some program of the type `String -> String', sure
09:52:58 <bitonic> but you are still interacting
09:53:01 <monochrom> also there is no need to deny the tenary expression
09:53:03 <bitonic> it's just hidden from you
09:53:09 <jmcarthur> bitonic: i'm thinking more along the lines of tangible values
09:53:18 <bitonic> jmcarthur: mhm?
09:53:40 <edwardk> speaking of python, guido van rossum showed up at my lens talk in california =)
09:53:40 <jmcarthur> bitonic: http://conal.net/papers/Eros/
09:54:03 <demir> I'll take a look at these links thank you all :)
09:54:07 <atriq> edwardk, next thing you know, Lenses in Python
09:54:25 <edwardk> atriq: meh, lenses are easy. give me traversals and all the crazy stuff
09:54:26 <bitonic> jmcarthur: whatever - what I'm saying is that you *have* to interact at some point.  so I think "side effect" is clearer
09:54:30 <jmcarthur> bitonic: basically the idea is that programs work with rich content, but you control the inputs and outputs
09:54:33 <Matthias|PC> http://pastebin.com/VAhhgyE0 why doesn't that work? I get the last error on executing fiblijst, the other functions do work
09:54:36 <mauke> The paste VAhhgyE0 has been copied to http://hpaste.org/77541
09:54:37 <monochrom> it will be interesting to watch how Guido butchers and distorts lenses
09:54:41 <demir> @arkantos your words made me excite
09:54:42 <lambdabot> Unknown command, try @list
09:54:51 <edwardk> hey, he's trying
09:54:53 <cornihilio> where is the event file that traceEventIO logs to? should it be in folder where the binary is run?
09:55:02 <arkantos> demir, LOL
09:55:08 <edwardk> but, er. yes, it will
09:55:29 <luite> edwardk: oh did he? i ddidn't see him. I missed my chance to finally talk some dutch there!
09:55:45 <edwardk> luite: =) he was off to my right in the crowd
09:56:09 <jmcarthur> bitonic: i'm just trying to say that i can't think of any reason that programs intended to be used interactively must treat that interaction as some sort of side effect.
09:56:19 <mog_> Matthias|PC: you call fiblijst with one parameter only, it needs two else it returns a function
09:56:30 <mog_> try fiblijst 6 5
09:56:32 <jmcarthur> bitonic: maybe it would help if i defined effect and side-effect as i intent them
09:56:33 <edwardk> looks like i'll probably be doing an updated version of the talk next month for NY Haskell. So I should be able to record it this time.
09:56:37 <jmcarthur> *intend
09:56:39 <Matthias|PC> hmm okay, ty will try :)
09:56:56 <Matthias|PC> ooooh of course
09:56:58 <Matthias|PC> thank you
09:57:01 <Matthias|PC> silly of me
09:57:10 <jmcarthur> bitonic: i usually take "side-effect" to mean that effects are driven by evaluation
09:57:14 <mog_> you're welcome
09:57:20 <edwardk> jmcarthur: you're going to be free on december 12th, right? =)
09:57:38 <jmcarthur> edwardk: what's dec 12?
09:57:42 <luite> edwardk: ah, i might not show up this time ;p
09:57:47 <edwardk> me coming down to NY to talk =)
09:57:52 <jmcarthur> ah!
09:57:55 <jmcarthur> i probably will be, yes
09:58:19 <edwardk> lenses, traversals, folds, uniplate, zippers, and other awesomesauce
09:58:35 <jmcarthur> exactly the talk i want to see
09:58:40 <edwardk> i have yet to add the awesomesauce typeclass, but when i do it'll be awesome
09:58:46 <edwardk> =)
09:58:58 <jmcarthur> i've been neglecting the world of lenses, etc., and i feel a bit left behind now
09:58:58 <atriq> I wait in eager anticipation
09:59:04 <cornihilio> hello? am I being /ignored or is my question too stupid?
09:59:23 <atriq> cornihilio, nah, you just got drowned out
09:59:23 <jmcarthur> cornihilio: sometimes nobody knows the answer. sometimes you get lost in the fray
09:59:29 <edwardk> cornihilio: it more likely got lost in the spam
09:59:41 <edwardk> i don't know the answer
09:59:42 <jmcarthur> cornihilio: i think it goes to your current working directory
09:59:59 <jmcarthur> cornihilio: and i think your program has to be built a certain way, or run with certain runtime flags
10:00:15 <jmcarthur> cornihilio: there may also be some rts flags to specify where it should go, too
10:00:19 <edwardk> > traverse.both +~ 1 $ [(1,2),(3,4)]
10:00:23 <lambdabot>   [(2,3),(4,5)]
10:00:24 <bitonic> cornihilio: http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html#id549141
10:00:29 <bitonic> cornihilio: see -eventlog
10:00:36 <cornihilio> sorry for being desperate for attention, I was just kind of worried for a bit, and I don't like repasting on this channel, so I couldn't tlel
10:00:42 <jmcarthur> :t both
10:00:44 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
10:00:49 <mog_> well now you got plenty of answers
10:00:50 <mog_> :)
10:01:08 <edwardk> both f (a,b) = (,) <$> f a <*> f b -- should like like 'traverse' for an appropriate non-existent functor
10:01:15 <edwardk> er should look like
10:01:44 <jmcarthur> sometimes i feel like i'm the only person who likes the liftA* family of functions
10:02:02 <edwardk> over l f = runIdentity . l (Identity . f) -- gives you something like map
10:02:04 <edwardk> :t over both
10:02:06 <lambdabot> (a -> b) -> (a, a) -> (b, b)
10:02:09 <bitonic> cornihilio: also <http://www.haskell.org/ghc/docs/latest/html/users_guide/runtime-control.html#rts-profiling>
10:02:12 <edwardk> :t mapMOf both
10:02:14 <lambdabot> Monad m => (a -> m b) -> (a, a) -> m (b, b)
10:02:17 <atriq> > over both (+ 1) (7, 9)
10:02:19 <lambdabot>   (8,10)
10:02:21 <edwardk> :t anyOf both
10:02:23 <lambdabot> (a -> Bool) -> (a, a) -> Bool
10:02:46 <atriq> > anyOf both (> 6)  (3, 8)
10:02:48 <lambdabot>   True
10:03:06 <edwardk> the basic pattern is <combinator you know how to use from Data.Foldable, Data.Traversable, etc.>Of ;)
10:03:11 <parcs`> :t anyOf
10:03:12 <lambdabot> Getting Any s t a b -> (a -> Bool) -> s -> Bool
10:03:19 <atriq> > mapMOf both (\x -> [x, x + 1]) (1, 2)
10:03:22 <lambdabot>   [(1,2),(1,3),(2,2),(2,3)]
10:03:23 <fmap> :t toListOf both
10:03:25 <lambdabot> (a, a) -> [a]
10:03:41 <edwardk> > ("hello","world")^..both
10:03:43 <lambdabot>   ["hello","world"]
10:04:00 <edwardk> > ("hello","world")^._2
10:04:02 <lambdabot>   "world"
10:04:05 <edwardk> > ("hello","world")^.both
10:04:07 <lambdabot>   "helloworld"
10:04:24 <fmap> edwardk: why toListOf and not simply listOf?
10:04:24 <edwardk> its just stuff you know how to use, mashed into a slightly more composable form
10:04:25 <atriq> I'm annoyed now
10:04:35 <edwardk> :t Data.Foldable.toList
10:04:37 <lambdabot> Data.Foldable.Foldable t => t a -> [a]
10:04:42 <edwardk> to fit that
10:05:08 <edwardk> and i usually use the ^.. infix version anyways
10:05:39 <edwardk> > M.fromList [("hello",1), ("world",2)] ^.at "hello"
10:05:42 <lambdabot>   Just 1
10:05:46 <cornihilio> um, in the eventlog example there is this: $ ./A +RTS -l but I don't get how to use that with my code, since my binary parses the arguments and doesn't recognize "-l"
10:05:47 <luite> you should patch hlint to give suggestions for using lens functions :)
10:06:05 <monochrom> have you tried?
10:06:08 <cornihilio> the example is here: http://hackage.haskell.org/trac/ghc/wiki/EventLog
10:06:14 <jmcarthur> cornihilio: it will do +RTS stuff before giving control to your program
10:06:28 <enolan> > exp (0:+1 *pi)
10:06:29 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
10:06:35 <monochrom> indeed, your code will not even see "+RTS" or "-l"
10:06:47 <jmcarthur> cornihilio: +RTS indicates that the following flags are for the runtime system, not for your program to see
10:06:57 <enolan> wait what?
10:06:59 <jmcarthur> cornihilio: and you can also end a series of RTS flags, optionally, with -RTS
10:07:10 <byorgey> enolan: what's wrong?
10:07:11 <enolan> > exp (pi*0:+1)
10:07:11 <jmcarthur> cornihilio: so you could also say this instead:   ./A +RTS -l -RTS
10:07:13 <lambdabot>   0.5403023058681398 :+ 0.8414709848078965
10:07:22 <enolan> why are those different?
10:07:28 <jmcarthur> > exp (pi * (0 :+ 1))
10:07:28 <cornihilio> jmcarthur: thank you!
10:07:29 <lambdabot>   (-1.0) :+ 1.2246467991473532e-16
10:07:29 <monochrom> anyway, you should try it before saying it will run into a problem
10:07:46 <byorgey> enolan: * has higher precedence than :+
10:08:10 <jmcarthur> > exp (pi * (0 :+ 1)) :: Complex CReal
10:08:12 <lambdabot>   (-1.0) :+ 0.0
10:08:32 <enolan> Why would it work that way? That seems very unintuitive...
10:08:46 <byorgey> enolan: multiplication usually has higher precedence than addition.
10:08:53 <byorgey> enolan: quick, what's 2 + 3 * 5 ?
10:08:53 <jmcarthur> enolan: (*) usually binds more tightly than (+). why should it be different for (:+)?
10:08:57 <cornihilio> wtf, is the eventlog format a binary format?
10:09:13 <jmcarthur> cornihilio: that would make sense since it needs to be fast
10:09:21 <enolan> in my head :+ is a data constructor and should bind more tightly...
10:09:39 <jmcarthur> data constructors aren't really different from functions here
10:09:44 <latro`a_> constructors are just functions yeah
10:09:44 <monochrom> now you have to correct your head
10:09:57 <geekosaur> tbh I agree with enolan on this, :+ is not normal addition.  (let me put it this way:  does the imaginary part make any sense by itself?)
10:10:07 <geekosaur> if not then :+ is constructor nature, not addition nature
10:10:22 <enolan> monochrom: I reject your precedence and substitute my own! ;)
10:10:23 <latro`a_> but the point is that constructors are just like functions, so if you make them infix their precedence can be lowered
10:10:36 <byorgey> I agree there is an argument that can be made for :+ to have higher precedence.  but, it doesn't.
10:10:42 <jmcarthur> geekosaur: yes, imaginary numbers make plenty of sense by themselves, IMO
10:10:55 <latro`a_> jmcarthur, the point is that an imaginary number is 0 :+ ...
10:10:56 <enolan> I understand infix functions
10:10:56 <byorgey> and there's no mechanism to make all constructors have higher precedence than anythingelse.
10:10:57 <latro`a_> which is a valid point
10:10:57 <monochrom> (:+) makes sense by itself. (:+ 4) also makes sense by itself. I don't understand geekosaur's question
10:11:11 <jmcarthur> latro`a_: that's just a certain way of representing complex numbers
10:11:13 <geekosaur> jmcarthur, in haskell, as is?  what makes the imaginary part of x:+y imaginary, if not the :+?
10:11:31 <jmcarthur> latro`a_: i think it also would make sense to say   pi * i  is a fine complex number
10:11:32 <latro`a_> it's a representation but it is also the representation we use
10:11:51 <latro`a_> but i internally is 0 :+ 1
10:12:06 <geekosaur> ok fine, :+ is completely normal addition and the thing on the right is some kind of implicit complex type that we can't tell from the type system is a complex type.  correct?
10:12:16 <jmcarthur> latro`a_: if Complex was an opaque type and we just exposed an  i  value, would your argument be the same?
10:12:24 <latro`a_> fair enough
10:13:59 <monochrom> the distinction is not so much "constructor vs non-constructor value", but rather "infix operator vs non-infix whatever, and if infix, what precedence"
10:14:02 <jmcarthur> geekosaur: in (a + b*i), (+) is completely normal addition, but a and b are both complex numbers
10:14:19 <geekosaur> jmcarthur, I think you just successfully missed my point completely
10:14:24 <jmcarthur> quite possibly
10:14:38 <latro`a_> that's actually an interesting point....
10:14:42 <jmcarthur> geekosaur: i'm trying to argue that there is no implicit complex type here
10:14:43 <latro`a_> (1 :: Double) + i
10:14:46 <latro`a_> doesn't actually make sense
10:14:48 <monochrom> in "E :+ F", :+ is clearly an infix operator, so the question is what precedence would you like. I don't see why it matters whether it is a constructor or not
10:14:58 <geekosaur> it is claimed that + and :+ are "the same thing".  so how do I tell that the right side of :+ has a different effective type from the thing on the left?
10:15:13 <geekosaur> or are we claiming that Complex is just a tuple with a Num instance?
10:15:15 <jmcarthur> that's not quite my claim
10:15:37 <geekosaur> enough so that they should have the same precedence
10:15:48 <monochrom> especially, I don't see why: just because :+ is a bit different from +, why :+ therefore must have a lower precedence than *
10:16:03 <monochrom> and again, I don't care that :+ is a constructor
10:16:08 <jmcarthur> geekosaur: i'm claiming that (a :+ b) can be thought of as nothing more than sugar for (a + b*i). that the actual representation is the former is irrelevant
10:16:28 <latro`a_> the problem is that the types don't line up
10:16:31 <geekosaur> this is a lost cause.  complex numbers are supposed to be difficult to use in haskell
10:16:39 <jmcarthur> ?
10:16:42 <latro`a_> if a is a Double and b*i is a Complex then a + b*i is a type error
10:16:52 <latro`a_> *a Complex Double
10:16:52 <geekosaur> this is all I can conclude from the points you two are making
10:17:03 <enolan> geekosaur: why are we making things difficult on purpose?
10:17:23 <geekosaur> complex numbers are supposed to be nonintuitive as indicated by :+'s precedence being set by the fact thjat it looks like addition
10:17:30 <jmcarthur> latro`a_: that seems to be a strawman. i'm not trying to say anything about what the types are
10:17:30 <monochrom> you are ignoring my point. or maybe you agree with my point, and raise no objection
10:17:40 * byorgey doesn't understand any of the points anyone is making.
10:18:02 <enolan> geekosaur: I don't understand if you're criticizing the design or not
10:18:04 <atriq> My point is that I'm being forced to use two separate librarys for HTTP-ness
10:18:07 <geekosaur> byorgey, that's more or less where I am at the moment
10:18:07 <latro`a_> it's sorta unhelpful for "a" in "a+b*i" to itself be a Complex, because then how do you build a Complex in the first place
10:18:21 <jmcarthur> latro`a_: how do you build a Double?
10:18:28 <latro`a_> I guess using the hidden fromRational or what have you, yeah
10:18:46 <byorgey> this conversation is fairly ridiculous.  The precedence of :+ is what it is.  If you don't like it, define your own synonym with a different precedence.
10:19:40 <geekosaur> enolan, yes, I noticed this is a lost cause.  it makes sense to someone, I'm sure.
10:20:13 <monochrom> import Prelude hiding (+)
10:20:18 <cornihilio> why am I getting "Cannot find gtk2hsC2hs" when I have "export PATH=$HOME/.cabal/bin:$PATH" in my .bashrc?
10:20:19 <geekosaur> I tend to think constructing a numeric type should try to avoid needing to separate it with extra parens from the surrounding expression, but I'm sure someone will then raise fromIntegral as a counterexample
10:20:22 <monochrom> (+) = (:+)
10:20:28 <monochrom> infixl 8 +
10:20:53 <geekosaur> because on some theoretical level that's totally the same thing
10:20:56 <byorgey> cornihilio: and is gtk2hsC2hs in .cabal/bin ?
10:21:00 <jmcarthur> how would a mathematician write it?
10:21:18 <cornihilio> byorgey: nope...
10:21:26 <byorgey> cornihilio: well, that would be why.
10:21:28 <geekosaur> cornihilio, did you add that and then start a new shell, or did you add it and expect the current shell to pick it up automatically
10:21:30 <geekosaur> oh
10:21:38 <byorgey> cornihilio: cabal install gtk2hs-buildtools
10:21:39 <cornihilio> I started a new shell
10:22:00 <cornihilio> why doesn't cabal install gtk know that's a dependency?
10:22:08 <geekosaur> cornihilio, cabal-install can't detect that pacages consisting solely of executables are installed
10:22:27 <geekosaur> because it uses ghc-pkg to determine what is installed in your compiler, and ghc-pkg only understands libraries
10:22:41 <cornihilio> ah, okay
10:22:43 <geekosaur> and it would be Bad if cabal-install tried to keep its own list and then got out of sync with ghc-pkg
10:22:46 <cornihilio> thanks for clearing that up!
10:23:00 <nand`> the interface I would be envision is ‘a + b*i’
10:23:07 <otters> > let (!x,y) = (undefined,3) in y
10:23:09 <lambdabot>   *Exception: Prelude.undefined
10:23:10 <nand`> where ‘i’ is the only primitive way to get an imaginary unit
10:23:14 <otters> > let (x,y) = (undefined,3) in y
10:23:16 <lambdabot>   3
10:23:53 <latro`a_> one downside to that interface is that it's slower, I suspect
10:24:07 <nand`> perhaps
10:24:09 <latro`a_> well...assuming the loss doesn't get optimized away, which it might
10:24:19 <latro`a_> but if it doesn't then you have to build i internally, then multiply, then add
10:24:23 <latro`a_> as opposed to just building
10:24:29 <geekosaur> I also wonder how difficult the type of (+) becomes if you do that
10:24:32 <nand`> Are multiplications with 1 optimized away in the general case?
10:24:41 <latro`a_> probably not
10:24:42 <nand`> like if the compiler sees something like (*) (fromInteger 1)
10:24:49 <jmcarthur> i don't think ghc does much arithmetic statically
10:25:10 <jmcarthur> it would only work for certain types anyway
10:25:24 <jmcarthur> since Num has no real properties of its own
10:25:29 <jmcarthur> :(
10:25:37 <nand`> yeah I suppose so
10:25:46 <rwbarton> the backend code generator might do it after specialization
10:25:57 <jmcarthur> i would expect llvm to do some
10:26:24 <parcs`> > i
10:26:26 <lambdabot>   i
10:26:28 <nand`> I'm mainly worried about the polymorphic case
10:26:48 <nand`> like if I have something like x :: Num a => a; x = 1*1*1/1*1/(1*1/1)
10:26:58 <nand`> Fractional*
10:26:59 <monochrom> geekosaur: Suppose I have this definition (/+) = (:+), and I ask you to choose the precedence for (/+), and by the way, this is a chance for you to revise the precedence of (:+) too. are you saying that just because one of them is a non-constructor and the other is a constructor, therefore they should have difference precedences?
10:28:02 <rwbarton> nand`: you could add a RULE I guess (but then you could also just write "x = 1" if that's what you meant)
10:28:13 <monochrom> and what if I use the perspective that (/+) is a smart constructor, and so (/+) is a kind of constructor?
10:28:17 <rwbarton> otherwise the compiler is helpless
10:28:30 <rwbarton> unless x gets inlined and specialized
10:28:32 <nand`> rwbarton: okay. The thing is, it's not actually ‘1’ everywhere, they have names, and carry phantom types
10:28:35 <rwbarton> (or just SPECIALIZED)
10:28:36 <rwbarton> oh i see
10:28:49 <Eduard_Munteanu> Mm, can you specialize normal definitions?
10:28:58 <nand`> stuff like kilogram*meter/second
10:29:01 <nand`> which are all 1
10:29:03 <Eduard_Munteanu> (i.e. not typeclass methods)
10:30:09 <rwbarton> in that you can write f :: Num a => a -> a; f = ...; {-# SPECIALIZE f :: Double -> Double #-} and it will produce a Double-specific version of the function and use it at sites where it knows a = Double
10:30:53 <nart> hi
10:31:21 <nart> i would like to write a prolog interpreter in haskell, do you know any good resources ?
10:31:37 <rwbarton> Eduard_Munteanu: basically it is a special kind of RULE that you can't get wrong
10:33:20 <akamaus> Hi. I'm trying to get the IP of a client in my yesod app. I found reqWaiRequest returning a Request type which among other things has remoteHost :: SockAddr. But will it work in case my application is behind a reverse proxy, say, nginx?
10:34:39 <startling> akamaus, I'm pretty sure it would. can you try it?
10:35:15 <akamaus> startling, of course. I'm busy doing this
10:35:20 <johnw> yes, request headers are suppose to pass through transparently, that's kind of the idea behind a reverse proxy
10:35:46 <geekosaur> monochrom, maybe I shoul put it this way:  when you see complex numbers in math texts, do you normally need parentheses to distinguisyh x+yi from x + y?
10:35:50 <rwbarton> but SockAddr sounds like it could come from the actual socket
10:35:58 <ziman> not that I've worked with yesod but i'd expect a well-behaved reverse proxy to include client information somewhere in the http headers; do they contain anything interesting?
10:38:08 <monochrom> perhaps I don't understand the question. both x+yi and x+y need no parenthesizing. but I observe that a*x+yi is not a*(x+yi)
10:38:33 <Spin1987> hello does someone know a free survey tool without login ?
10:39:16 <cornihilio> is there a tutorial that explains how threadscope can display traceEvent/traceEventIO stuff?
10:39:29 <lazythunk> @Spin1987 you can use a google doc form to setup surveys
10:39:29 <lambdabot> Unknown command, try @list
10:39:53 <nand`> rwbarton: hrm; does it make sense to specialize a value? for example; if I have x :: Num a => a; x = 1; {-# SPECIALIZE x :: Double #-} -- will that optimize uses of ‘x’ in Double contexts?
10:40:28 <Spin1987> lazythunk: and everybody can vote? without an google acc?
10:40:29 <enolan> the original question was why
10:40:32 <enolan> > exp (pi * (0:+1)) :: (Complex CReal)
10:40:34 <lambdabot>   (-1.0) :+ 0.0
10:40:35 <enolan> works, but
10:40:41 <enolan> > exp (pi * (0:+1)) :: Sym (Complex CReal)
10:40:43 <lambdabot>   Couldn't match expected type `Data.Number.Symbolic.Sym
10:40:43 <lambdabot>                     ...
10:40:48 <enolan> doesn't.
10:40:54 <jmcarthur> Sym?
10:40:56 <lazythunk> Spin1987 yup
10:41:02 <Spin1987> :)
10:41:22 <jmcarthur> > exp (pi * (0:+1)) :: Complex (Sym CReal)
10:41:23 <lambdabot>   cos pi :+ sin pi
10:41:24 <nand`> presumably because 0:+1 doesn't have type Sym (Complex a)
10:41:25 <rwbarton> nand`, I suppose so
10:41:27 <nand`> oh
10:41:36 <enolan> exact symbolic arithmetic. like typing sqrt 2 into a fancy TI and getting sqrt 2 back
10:41:44 <nand`> yeah there you go
10:41:59 <monochrom> I haven't heard of Sym. I don't know what it can't do
10:42:22 <enolan> it lives in numbers, next to CReal
10:42:24 <jmcarthur> > 1/3 :: Sym CReal
10:42:26 <lambdabot>   0.3333333333333333333333333333333333333333
10:42:37 <jmcarthur> so no magical rationals then
10:42:48 <nand`> > 1/3 :: Sym Rational
10:42:50 <lambdabot>   1 % 3
10:42:54 <jmcarthur> > 1/pi :: Sym CReal
10:42:55 <lambdabot>   1.0/pi
10:43:00 <nand`> but those don't have pi etc. then I'm guessing
10:43:13 <nand`> > 1/pi :: Sym Rational
10:43:14 <lambdabot>   No instance for (GHC.Float.Floating
10:43:15 <lambdabot>                     (GHC.Real.Ratio GHC...
10:43:23 <monochrom> Sym City
10:43:59 <jmcarthur> > sin 0.7 / cos 0.7 :: Sym CReal
10:44:01 <lambdabot>   0.8422883804630794481281350022129377171872
10:44:07 <akamaus> startling, johnw, it indeed works as expected :)
10:44:24 <jmcarthur> > sin a / cos a :: Sym Exp
10:44:24 <byorgey> someone should design a language based around symbolic computation, and call it SymPL
10:44:25 <lambdabot>   Not in scope: type constructor or class `Exp'
10:44:26 <lambdabot>  Perhaps you meant `Expr' (im...
10:44:27 <jmcarthur> > sin a / cos a :: Sym Expr
10:44:28 <lambdabot>   Couldn't match expected type `Data.Number.Symbolic.Sym
10:44:29 <lambdabot>                     ...
10:44:44 <monochrom> haha, SymPL is a great name
10:46:07 <cornihilio> is there a tutorial that explains how threadscope can display traceEvent/traceEventIO stuff?
10:46:26 <aninhumer> Hmm, perhaps GHC should suggest -XScopedTypeVariables if you have an error resulting from a free variable with the same name as a variable in the type declaration?
10:46:46 <aninhumer> *free type variable
10:47:53 <aninhumer> I just spent quite a few minutes working that out, and I only solved it because I vaguely remembered an extension like that
10:48:15 <byorgey> aninhumer: sounds reasonable, why don't you file a feature request on the GHC trac
10:49:52 <nand`> can I get a running changelog of what's new in GHC 7.7 over 7.6 somewhere?
10:51:43 <startling> akamaus: good to know!
10:51:48 <byorgey> nand`: https://github.com/ghc/ghc ?
10:52:38 <byorgey> unless you mean you want a nicely curated list which filters out trivial things and explains what the changes mean
10:52:55 <byorgey> I'm not sure if that sort of thing is constructed incrementally, or only in a heroic effort right before each release
10:53:31 <cornihilio> are traceEvents supposed to show up as bookmarks in threadscope?
10:53:40 <nand`> right, that's basically what I meant
10:53:52 <nand`> I'll just have to dig through the commit history I guess
11:03:17 <BMeph> BBL - updating mIRC...
11:03:36 <Eduard_Munteanu> Does that thing still exist?
11:03:49 <hpaste> dmwit pasted “funny use of constraints” at http://hpaste.org/77543
11:03:51 <Ralith> apparently!
11:04:29 <dmwit> edwardk: Is there a way to get something like the above without having to write an explicit type signature on "witness"?
11:04:37 <edwardk> ?
11:05:23 <Matthias|PC> how do you remove a specific index from the list? I tried with filter but I can only manage to delete a value
11:05:36 <edwardk> oh, not really. you might make a type alias that a least encapsulates type Witness a = (Show a, Unwrappable a) :- (Show (Unwrap a), Unwrappable (Unwrap a))
11:05:42 <pythonsnake> hey
11:05:45 <edwardk> then you can shorten it but otherwise no
11:05:50 <dmwit> That's not a bad idea.
11:05:59 <pythonsnake> can anyone recommend me a good haskell book/tuto please?
11:06:07 <dmwit> ?where gentle
11:06:08 <lambdabot> http://www.haskell.org/tutorial/
11:06:09 <dmwit> ?where lyah
11:06:10 <lambdabot> http://www.learnyouahaskell.com/
11:06:11 <dmwit> ?where rwh
11:06:12 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
11:06:33 <dmwit> hm
11:06:41 <Eduard_Munteanu> pythonsnake: you probably want to start with LYAH
11:06:43 <dmwit> ?where tutorial
11:06:43 <lambdabot> http://www.haskell.org/tutorial/
11:06:48 <dmwit> ?where tutorials
11:06:49 <lambdabot> http://haskell.org/haskellwiki/Tutorials
11:07:03 <dmwit> Oh, that's much better. I'll use that from now on.
11:09:10 <byorgey> Matthias|PC: why do you want to do that?  lists aren't really designed to make that easy
11:09:30 <Matthias|PC> byorgey: homework :(
11:09:32 <byorgey> Matthias|PC: but in general you'd have to use something like 'splitAt' to take the list apart and then put it back together without the element you want to delete
11:09:38 <pythonsnake> Eduard_Munteanu, dmwit: thnak you
11:09:40 <byorgey> oh, right =(
11:09:55 <Matthias|PC> I find this so extremely confusing
11:10:05 <byorgey> Matthias|PC: well, I'd also suggest just doing it directly with recursion
11:10:08 <cornihilio> okay, this is in GUI.hs for threadscope: https://gist.github.com/4052174
11:10:30 <byorgey> Matthias|PC: deleteAt _ [] = ...  ;  deleteAt 0 (x:xs) = ...;  deleteAt n (x:xs) = ...
11:11:01 <byorgey> ignore what I said before, it's not actually that hard
11:11:15 <Matthias|PC> hm, undefined variable deleteAt
11:11:16 <Philonous> > let del i = fst . unzip . filter ((/= i) . snd ) . zip [0..] in del 3 [1..5]
11:11:18 <lambdabot>   [0,1,3,4]
11:11:24 <Matthias|PC> do I need to import it somehow?
11:11:28 <byorgey> Matthias|PC: no, I'm suggesting that you define deleteAt
11:11:36 <EvanR7> Matthias|PC: deleteAt n xs = take (n-1) xs ++ drop (n+1) xs
11:11:49 <Philonous> > let del i = snd . unzip . filter ((/= i) . fst ) . zip [0..] in del 3 [1..5]
11:11:50 <byorgey> EvanR7: don't do people's homework for them, please.
11:11:51 <lambdabot>   [1,2,3,5]
11:12:00 <EvanR7> byorgey: what, youre all doing that
11:12:02 <cornihilio> wait what the hell is a traceMarker...
11:12:15 <EvanR7> theres been at least 3 other such functions defined already
11:12:27 <EvanR7> also mines wrong even
11:12:29 <byorgey> EvanR7: if everyone jumped off a cliff, etc. etc.
11:12:31 <Matthias|PC> ah like that, wow
11:12:41 <EvanR7> byorgey: please berate Philonous now thx
11:13:04 <byorgey> Philonous: stop using other people's homework as an excuse for showing off and confusing them
11:13:19 <byorgey> how was that
11:13:34 <EvanR7> boss
11:13:34 <Philonous> poignant
11:14:05 <Matthias|PC> is there a difference between defining a function like this: someFunc x y = x + y and someFunc :: Integer -> Integer = x + y except that you don't define types?
11:14:32 <rwbarton> the latter is invalid in several ways
11:14:38 <Matthias|PC> err
11:14:41 <Matthias|PC> I ment
11:14:44 <Matthias|PC> someFunc :: Integer -> Integer
11:15:03 <Matthias|PC> hmm wait
11:15:05 <latro`a_> I think you meant Integer -> Integer -> Integer
11:15:06 <Matthias|PC> yeah I fail
11:15:13 <Eduard_Munteanu> The type of the former is more general.
11:15:26 <Matthias|PC> and how do you define the body of the second type?
11:15:37 <Matthias|PC> someFunc m = x + y?
11:15:43 <EvanR7> :t \x y -> x y
11:15:45 <lambdabot> (t1 -> t) -> t1 -> t
11:15:47 <EvanR7> :t \x y -> x + y
11:15:48 <rwbarton> no, exactly like the first
11:15:49 <lambdabot> Num a => a -> a -> a
11:16:21 <Matthias|PC> hmm
11:16:30 <Eduard_Munteanu> However, I think someFunc = \x y -> x + y should be equivalent to the latter, even without a signature.
11:16:30 <rwbarton> unless for some reason you want to write "someFunc = (\x y -> x + y) :: Integer -> Integer -> Integer"
11:16:45 <EvanR7> :t (+)
11:16:47 <lambdabot> Num a => a -> a -> a
11:16:47 <latro`a_> assuming you turn on NoMR
11:17:11 <Eduard_Munteanu> latro`a_: actually, in the presence of MR
11:17:19 <latro`a_> oh, yeah, right
11:17:34 <latro`a_> sorry, I tend to associate lambdas on the right side with MR fail, but that function is already monomorphic\
11:17:50 <Eduard_Munteanu> (plus the fortunate coincidence with defaulting rules)
11:17:51 <Matthias|PC> Haskell being functional, does that mean you can't do this in a function: a = [] 1:a
11:17:51 <Matthias|PC> ?
11:18:03 <Matthias|PC> since you're changing the state of a then?
11:18:17 <latro`a_> not sure what that's supposed to say
11:18:18 <Eduard_Munteanu> > let a = 1 : a in a
11:18:19 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
11:18:30 <latro`a_> but you can do that, it's just not a state change, but rather a recursive definitino
11:18:32 <latro`a_> *definition
11:18:48 <latro`a_> indeed, the result is that "a" and "1:a" are actually the same thing
11:19:07 <Matthias|PC> o.O really?
11:19:22 <mauke> > let a = [] in 1 : a
11:19:22 <latro`a_> imagine putting a 1 at the front of an infinite list of 1s
11:19:23 <lambdabot>   [1]
11:19:24 <latro`a_> did you change anything?
11:19:35 <Matthias|PC> you use let to define a var?
11:19:47 <Matthias|PC> god this is confusing
11:19:47 <latro`a_> it's a local definition; you can't define things at top level in lambdabot
11:19:57 <Eduard_Munteanu> It's not a "variable".
11:20:01 <cornihilio> do a lot of people use leksah?
11:20:01 <Matthias|PC> what is it then?
11:20:05 <mauke> it's totally a variable :-)
11:20:17 <Eduard_Munteanu> A plain definition.
11:20:24 <latro`a_> "a = 1:a" is a valid top level definition, however
11:20:31 <parcs`> > let a = 1:b; b = 2:a in a
11:20:33 <lambdabot>   [1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,...
11:20:35 <mauke> Matthias|PC: you use 'let' for local definitions, as in 'let DEFINITIONS in BODY'
11:20:44 <Matthias|PC> ah I see
11:21:16 <Matthias|PC> but I really gotta run, will look at it further tomorrow
11:21:17 <mauke> > let foo = 1 in (let foo = 2 in foo, foo)
11:21:18 <Matthias|PC> thanks for the help everyone :)
11:21:19 <lambdabot>   (2,1)
11:21:27 <mauke> (because shadowing is fun)
11:22:49 <parcs`> > let ?a = 1 in let ?a = ?a + 1 in ?a
11:22:51 <lambdabot>   2
11:25:23 <Eduard_Munteanu> latro`a_: actually, you can define top-level stuff with @let
11:25:29 <latro`a_> true
11:33:03 <cornihilio> hello? does anyone have any experience with threadscope/traceEvent?
11:43:01 <johnw> cornihilio: i've used threadscope, but I'm not sure that's what you're asking
11:44:50 <cornihilio> johnw: have you viewed traceEvent/traceEventIO logs with threadscope?
11:44:56 <cornihilio> from Debug.Trace?
11:45:00 <johnw> ah, no I havent'
11:45:06 <johnw> i've just used it in its simplest form
11:45:10 <johnw> -event or whatnot
11:46:25 <cornihilio> dang it, I can't figure out how the heck I'm supposed to look at traceEvent stuff
11:46:50 <cornihilio> I was hoping they would be under the bookmark part of threadscope, but apparently that doesn't happen (or I'm doing something wrong, which is more likely)
11:47:35 <cornihilio> is this a real book?: http://community.haskell.org/~simonmar/par-tutorial.pdf
11:47:54 <cornihilio> I was hoping I could find more info in there, but I can't tell if it's going to be published soon or what
11:48:12 <johnw> also see: http://research.microsoft.com/pubs/80976/ghc-parallel-tuning2.pdf
11:49:22 <cornihilio> no mention of traceEvent in there though :(
11:49:28 <johnw> sadly, no
11:49:29 <cornihilio> but I'll take a look! thanks for the suggestion
12:32:01 <atriq> Is there anyone here who's successfully used the hoauth package?
12:33:26 <atriq> Because I'm struggling
12:34:00 <Jeanne-Kamikaze> take the silence as a no
12:34:28 <atriq> :(
12:34:32 <Philonous> Maybe the right people just haven't seen it yet
12:34:57 <atriq> I don't think the right people ever will
12:35:09 <Jeanne-Kamikaze> that too; you just need to wait for the lurking eyes to catch you
12:35:35 <johnw> <delurk>Never used it</delurk>
12:37:55 <edwardk> ?
12:38:04 <johnw> hoauth
12:38:08 <johnw> hey edwark!
12:38:11 <edwardk> oh
12:38:18 <Jeanne-Kamikaze> I meant catching his question
12:38:40 <edwardk> heya johnw
12:38:57 <johnw> started reading Awodey last night
12:39:04 <edwardk> good times =)
12:39:06 <cmccann> "lurking eye" sounds like some sort of videogame monster
12:39:20 <johnw> yeah, it's kind of bizarre to me how cool this stuff is
12:39:29 <johnw> who knew the purely abstract could be so intriguing
12:39:35 <edwardk> > north      Oh, no! You have walked into the slavering fangs of a lurking eye!
12:39:37 <lambdabot>   <hint>:1:14: parse error on input `,'
12:39:54 <edwardk> hah woops
12:40:00 <cmccann> heh
12:40:19 <johnw> lurkingEye ^. pupil => utter blackness
12:40:35 <atriq> If only I were hung up on the purely abstract.
12:40:39 <cmccann> sounds like the kind of thing that paralyzes you if you look at it
12:40:49 <cmccann> and then you get nibbled to death by a newt on dungeon level 3
12:40:52 <edwardk> yeah, some kind of beholderkin
12:41:00 <atriq> Instead it is the practical I found myself in difficulties with.
12:41:05 <johnw> or meet your own ghost on level 4 and then have two ghosts to contend with
12:41:09 <edwardk> practical is overrated.
12:41:18 * cmccann has played too much nethack
12:41:30 <Jeanne-Kamikaze> nethack does all that ?
12:41:35 <Philonous> cmccann:  Can't you write elbereth even while blind?
12:41:52 <cmccann> not if you're paralyzed from hitting a floating eye
12:41:54 <edwardk> cmccann: so that explains why when you came over you spent all your time kicking the sink. ;)
12:42:00 <Philonous> cmccann:  Right
12:42:01 <cmccann> heh
12:42:16 <johnw> we should make hhack, where the ultimate goal is slay the Monad beast at the end by being able to write a comprehensible tutorial for it
12:42:22 <edwardk> Jeanne-Kamikaze: thats a slow day in nethack ;)
12:42:25 <johnw> it will just end up being the Burrito Beast
12:42:58 <cmccann> johnw, did you see my user profile here when I linked it last time gamedev.stackexchange.com/users/983/c-a-mccann ? :D
12:43:03 <johnw> whoever came up with the burrito analogy has won himself a place in our hearts
12:43:05 <Philonous> johnw:  With Functors and Applicatives as minibosses and a DLC that features their indexed variants
12:43:14 <cmccann> johnw, that was byorgey I think
12:43:19 <edwardk> I think in hhack the goal is to retrieve the Amulet of Wadler
12:43:25 <johnw> Philonous: and Adjunctions as the magical spell that rips the Monad beast apart, but no one can learn
12:44:10 <johnw> cmccann: that's awesome!  I was just kidding!
12:44:25 <edwardk> while you are down there you might find such wonderful artifacts as the hair shirt and the wand of (>>=)ing.
12:44:31 <johnw> what does "up to isomorphism" mean?
12:44:38 <johnw> I don't follow what the "up to" refers to
12:44:55 <cmccann> last time I linked that I think there was a discussion which concluded that a wand of callcc was overpowered
12:45:02 <cmccann> maybe scrolls of shift and reset or something instead
12:45:10 <nand`> I guess if something holds ‘up to isomorphism’ it holds if you consider two things that are isomorphic as being equivalent
12:45:14 <johnw> the Staff of ContT can be used to build any other staff
12:45:24 <Philonous> edwardk:  And when you find the secret room, Oleg gives you his old set of delimited continuations.
12:45:28 <latro`a> "x and y are the same up to z" is essentially "x and y are equivalent in the sense of z"
12:45:38 <latro`a> so "x and y are the same up to z" is "x and y are isomorphic"
12:45:40 <latro`a> erm
12:45:42 <latro`a> bah
12:45:51 <latro`a> "x and y are the same up to isomorphism" is "x and y are isomorphic"
12:45:55 <johnw> so "up to" doesn't imply a scale of equivalence; initially it made me thinking of a sloping curve on a graph
12:46:03 <latro`a> "x and y are the same up to homotopy" is "x and y are homotopy equivalent"
12:46:11 <edwardk> Philonous: for some reason that made me think of http://xkcd.com/297/
12:46:25 <cmccann> johnw, btw: http://en.wikipedia.org/wiki/Up_to
12:46:32 <Philonous> edwardk:  Ha, that's exactly what I was thinking of.
12:46:33 <johnw> cmccann: thank you
12:46:46 <johnw> i just need to read all of wikipedia; be back when that's done
12:46:50 <cmccann> heh
12:48:00 <edwardk> johnw: up to isomorphism is used mostly when you want to talk about a whole chain of relationships between things and don't want to keep replacing = with 'is isomorphic to'.
12:48:36 <edwardk> category theory gets hard in 2-category theory and above precisely because you wind up with a preponderance of different equalities, so you waste all your time talking about what notion of equality you are talking about =P
12:49:03 <johnw> so what does "an adjoint functor is unique up to isomorphism" mean?
12:49:46 <edwardk> (,) e  is left adjoint to (->) e   --- but given data Pair e a = Pair a e        you could have also chosen Pair e -| (->) e
12:50:26 <edwardk> the values 'Pair x y'  and (y, x) contain the same amount of information. they are isomorphic. you convert back and forth without losing any information in either direction
12:50:31 <johnw> so, it's still unique because (,) e is isomorphic to Pair e?
12:50:35 <edwardk> yes
12:50:39 <johnw> great!
12:50:47 <edwardk> its unique up as long as you consider two isomorphic things to be the same thing
12:50:53 <johnw> ahh
12:50:56 <edwardk> s/up/
12:51:00 <johnw> that's what the "up to" means
12:51:03 <edwardk> yep
12:51:07 <johnw> thanks, edwardk
12:51:32 <cmccann> sort of a formalized way of shrugging and saying "eh, same diff" :P
12:51:43 <johnw> now, why is Hom right adjoint to Prod, and not left adjoint to it?
12:51:48 <edwardk> up to isomorphism is a fancy way to rewrite all the assertions that "something is = to something else" to be 'something is isomorphic to something else'
12:52:25 <edwardk> f -| g   means that   f a -> b is isomorphic to  a -> g b          (for arrows in the appropriate categories)
12:52:40 <johnw> omg
12:52:47 <edwardk> (e, a) -> b      is isomorphic to a -> e -> b
12:52:50 <johnw> that one sentence is the clearest thing I've ever read about adjunctions
12:53:08 <johnw> @remember edwardk f -| g   means that   f a -> b is isomorphic to  a -> g b (for arrows in the appropriate categories)
12:53:09 <lambdabot> Okay.
12:53:36 <johnw> you should have just said that like 2000 words ago :)
12:53:43 <edwardk> i said it when you visited ;)
12:54:13 <johnw> i guess it was my ear that needed to develop then
12:54:26 <cmccann> johnw, that's often the case
12:54:50 <edwardk> class (Functor f, Functor g) => Adjunction f g | f -> g, g -> f where leftAdjunct :: (f a -> b) -> a -> g b; rightAdjunct :: (a -> g b) -> f a -> b
12:55:13 <edwardk> where leftAdjunct . rightAdjunct = id; rightAdjunct . leftAdjunct = id
12:55:15 <cmccann> in fact, I think that's exactly what byorgey blamed for the burrito-style monad tutorials. people's ears develop enough and then the next thing they hear makes it all click
12:55:19 <johnw> this looks interesting: http://www.ellerman.org/Davids-Stuff/Maths/Ellerman-Theory%20of%20Adjoint%20Functors-Reprint.pdf
12:55:24 <cmccann> and then they assume that whatever that thing was is the key to figuring it all out :P
12:55:29 <edwardk> cmccann: =)
12:55:59 <edwardk> i think since we're on irc and i doubt you use a screenreader that it was your eyes that needed time to develop ;)
12:57:22 <edwardk> johnw: http://hackage.haskell.org/packages/archive/adjunctions/3.0.0.1/doc/html/src/Data-Functor-Adjunction.html
12:57:33 <johnw> this page looks like it could be interesting, but I'm incapable of reading it now: http://math.stackexchange.com/questions/25455/why-should-i-care-about-adjoint-functors
12:57:48 <johnw> edwardk: I read your words to myself in my head, old habit
12:57:55 <edwardk> =)
12:58:14 <edwardk> so "you should have just said that like 2000 words ago :)" =)
12:58:33 <hiptobecubic> When things start getting crazy I usually read it out loud.
12:58:38 <cmccann> johnw, so listening to edwardk talk and reading what he types are equivalent up to isomorphism?
12:59:06 <Jeanne-Kamikaze> what is exactly a burrito-style monad tutorial ?
12:59:19 <johnw> cmccann: exactly
12:59:21 <cmccann> ones based on contrived and contorted analogies
12:59:37 <johnw> cmccann: I swear I'm right adjoint to edwardk.  What starts as nonsense, he makes sense of, then I render it back to nonsense for myself
12:59:51 <Ralith> ones wrapped in a tortilla and served with rice
13:00:04 <edwardk> johnw: now that you grok the (f a -> b) ~ (a -> g b)    relationship for f -| g. lets look at a galois connection.    replace -> with <= .
13:00:12 <johnw> Jeanne-Kamikaze: it's the standard style approved by Haskellers everywhere
13:00:25 <johnw> what is "<="?
13:00:27 <edwardk> (f a <= b) is equivalent to a <= g b  -- try to find some f's and g's ;)
13:00:33 <edwardk> > 3 < 5
13:00:34 <lambdabot>   True
13:00:35 <edwardk> > 3 <= 5
13:00:37 <lambdabot>   True
13:00:40 <edwardk> =)
13:00:41 <johnw> oh, I thought it was a special type operator
13:00:50 <johnw> you mean an ordering relation
13:00:54 <edwardk> 1 + a <= b      -- g = ?
13:00:56 <nand`> @quote astronaut
13:00:57 <lambdabot> No quotes match. Maybe you made a typo?
13:00:59 <nand`> :(
13:01:04 <cmccann> @quote spacesuit
13:01:04 <nand`> oh, no
13:01:04 <lambdabot> syntaxglitch says: a monad is an endospacesuit on a burrito category
13:01:10 <johnw> one sec, let me work on that in another buffer
13:01:11 <nand`> I was about to type that :(
13:01:21 <nand`> but wasn't there another one
13:01:23 <nand`> @quote space.suite
13:01:23 <lambdabot> dons says: Think of a monad as a spacesuite full of nuclear waste in the ocean next to a container of apples. now, you can't put oranges in the space suite or the nucelar waste falls in the ocean, *
13:01:24 <lambdabot> but* the apples are carried around anyway, and you just take what you need.
13:01:29 <nand`> that's the one
13:01:30 <cmccann> :D
13:01:49 <edwardk> 2 * a <= b   -- g = ?
13:02:14 <johnw> 1 + a <= b  ===  a <= b - 1
13:02:26 <johnw> 2 * a <= b  ===  a <= b / 2
13:02:33 <edwardk> congratulations you've now found your first galois connections
13:02:44 <edwardk> those are just adjunctions on partial orders
13:02:46 <johnw> 2 * a <= b  ===  a <= b * 1/2
13:02:52 <johnw> interesting
13:04:38 <edwardk> we can make them more interesting when we start putting in other operators like floor, etc. changing between integers and reals, etc.
13:04:46 <chipotle79> Is an Arbitrary instance for Set defined anywhere?
13:04:58 <chipotle79> (I've already checked Hoogle...)
13:05:03 <edwardk> then we get 'closure' operators from going back and forth through the adjunction that act like monads.
13:05:21 <edwardk> which you'd expect since each adjunction gives you a monad and a comonad.
13:05:54 <padrian2ss> hello
13:06:20 <johnw> chipotle79: by Arbitrary you mean..?
13:06:21 <edwardk> (real n <= x) iff (x <= floor x)
13:06:47 <edwardk> so real(floor x)  and floor(real x) are interesting
13:07:02 <johnw> edwardk: when you wrote: type Nat f g = forall x. f x -> g x
13:07:06 <johnw> why did you use "forall x"?
13:07:26 <chipotle79> johnw: I'm referring to QuickCheck.  Daan Leijen seems to have defined such an instance in Data.Set, but I can't find it in my local version of that lib.
13:07:32 <johnw> edwardk: is "iff" part of the Galois connection, or is that a special case?
13:08:07 <edwardk> iff here is the special case, its where isomorphism we usually use goes
13:08:13 <cmccann> chipotle79, seems like something you might want to define on your own anyway
13:08:22 <cmccann> for whatever specific type you need a Set of
13:08:52 <chipotle79> cmcann: no, only one implementation is needed, as Set is parameterized.
13:09:13 <edwardk> its slightly stronger. the isomorphism would allow us to change the True to False and False to True as long as we did so consistently, right?
13:09:24 <johnw> yes
13:09:24 <cmccann> depends on what you want the generated Sets to look like
13:09:42 <edwardk> so we could change from <= to >= or some other ordering
13:09:59 <cmccann> obvious generic Arbitrary instances for collection types aren't always the most useful
13:10:03 <chipotle79> cmccann: I'm afraid I don't follow.  The internal representation of a Set is immaterial to me.
13:10:20 <edwardk> the inequality from real n <= x    is working with reals. the one from n <= floor x is working with integers
13:10:56 <edwardk> real (floor x) is taking a real, round tripping it through the naturals and coming back.
13:11:07 <edwardk> floor (real n) = n  , right?
13:11:08 * cmccann shrugs
13:11:22 <cmccann> anyway, I don't think people would appreciate either QuickCheck or containers depending on the other
13:11:46 <johnw> edwardk: yes
13:12:11 <chipotle79> cmccann: That kind of dependency would not be necessary, as orphan instances would be acceptable to me.
13:12:16 <edwardk> so how do we make a monad out of this adjunction?  we look at real . floor    and we note that we can apply it to a number x and get a new number, but what is real . floor . real . floor  when applied to that same x?
13:12:24 <edwardk> well, we already know that floor . real = id
13:12:38 <johnw> it equals real . floor
13:12:39 <edwardk> so real . floor . real . floor = real . id . floor = real . floor
13:12:42 <edwardk> yep
13:13:00 <johnw> is it "isomorphic up to composition"?
13:13:03 <edwardk> so we can take an x and get RealFloor x, and take RealFloor (RealFloor x) to RealFloor x
13:13:16 <edwardk> to abuse a sort of haskelly notation
13:13:18 <johnw> ah, and there are unit join
13:13:52 <cmccann> chipotle79, orphan instances aren't popular either though
13:14:07 <cmccann> there's an instance in https://github.com/haskell/containers/blob/master/tests/set-properties.hs if you want though
13:14:20 <johnw> edwardk: I've got to run now but thank you, this is has been tremendously helpful in my effort to grok adjoints!
13:14:25 <edwardk> and this plays the role of a sort of closure operator
13:14:30 <edwardk> np
13:14:33 <edwardk> catch you later
13:14:43 <johnw> remind me to ask you next time about "closure operator"
13:14:51 <edwardk> http://en.wikipedia.org/wiki/Closure_operator
13:14:52 <johnw> since I probably have bastardized notions of what "closure" means
13:15:02 <johnw> ok, adding to my reading list
13:15:06 <johnw> thank goodness for my new iPad :)
13:15:20 <Cale> Closure in this sense has nothing whatsoever to do with the data structure.
13:15:24 <johnw> now I just need to walk around with 3 computer in an impossible slim briefcase like you do :)
13:15:55 <edwardk> x <= cl(x)   x <= y implies cl(x) <= cl(y), cl(cl(x)) = cl(x)
13:16:19 <edwardk> hah
13:16:47 <johnw> i think my next task is to recreate your Adjunction Prod Hom instance without referring to your code
13:16:59 <johnw> and then to see what happens if I try to make instance Adjunction Hom Prod
13:17:44 <edwardk> a really fun one is to work out: instance (Adjunction f g, Adjunction f' g') => Adjunction (Compose f' f) (Compose g g')
13:18:19 <johnw> I don't adjunction is reflexive (counterexample: the free monoid and the forgetful functor), but does a -| b mean there cannot be b -| a?
13:18:24 <chipotle79> cmccann: Thanks, cmccann, but it looks like that's the code I'd already found.
13:18:32 <edwardk> no
13:18:35 <edwardk> counter example:
13:18:42 <edwardk> instance Adjunction Identity Identity
13:18:48 <edwardk> Identity a -> b   ~  a -> Identity b
13:18:51 <johnw> ah, of course
13:18:52 <cmccann> chipotle79, that's probably all you're going to find, I suspect
13:19:09 <chipotle79> cmccann: I'll make do somehow.  Anyway, thanks for the help.
13:19:21 <cmccann> no prob
13:19:23 <johnw> because my guess is that Prod -| Hom === Hom -| Prod
13:19:47 <edwardk> nah, putting Hom on the left would be weird =)
13:20:01 <johnw> although, Hom_C(X,Y) is a subset of Prod(X,Y)
13:20:01 <edwardk> (e -> a) -> b  ~    a -> ???? b
13:20:29 <johnw> ok
13:20:36 <johnw> i'll try to work it out and failing should be instructive
13:21:13 <johnw> don't you mean (e -> a) -> b ~ (e, ??? b)?
13:21:30 <johnw> why not (e -> a) -> b ~ (e, (a, b))?  anyway, I'll have to try it and see
13:21:34 <edwardk> no, i didn't prejudge that the right adjoint of (->) e was  (,) e ;)
13:21:46 <johnw> ah
13:22:19 <rwbarton> having an adjoint on a specific side is a very strong condition on a functor
13:22:31 <edwardk> rwbarton++
13:22:44 <johnw> and given any Adjunction, deriving a Monad instance from it should be somewhat automatic, yes?
13:22:50 <edwardk> yep
13:22:52 <rwbarton> so once you know a little more about adjoints it will be obvious that (->) e cannot have a right adjoint
13:23:09 <johnw> so, we could further obfuscate Haskell for people by only talking about Monads in terms of their Adjoints :)
13:23:36 <edwardk> being a left adjoint is pretty crippling
13:24:04 <edwardk> in Hask especially
13:24:27 <edwardk> if we limit e to something isomorphic to () you can meet the requirement ;)
13:24:38 <edwardk> but thats just the Identity case we already talked about
13:26:10 <johnw> edwardk: how well do you know 2-categories?
13:26:24 <edwardk> i know them well enough to just bounce all questions to dolio ;)
13:26:34 <cmccann> that's a good level of knowledge
13:26:40 <edwardk> i've outsourced that portion of my brain
13:26:46 <johnw> lol
13:27:18 <Saizan> cyberpunk folks would be proud
13:28:04 <edwardk> i didn't need my childhood anyways
13:29:03 <chipotle79> cmccann: Actually, it seems to me that the following one-liner suffices: arbitrary = liftM fromList $ listOf arbitrary
13:29:30 <cmccann> probably not the most efficient but ought to work
13:29:56 <rwbarton> why not just liftM fromList arbitrary?
13:29:59 <chipotle79> cmcann: can you say more about its efficiency?
13:30:16 <chipotle79> rwbarton: because I'm not just interested in singleton sets
13:30:26 <rwbarton> ?
13:30:28 <chipotle79> rwbarton: ah, wait.
13:30:39 <rwbarton> isn't there an Arbitrary a => Arbitrary [a] instance
13:30:50 <chipotle79> rwbarton: indeed, thanks for the tip.
13:30:55 <rwbarton> i assume it would amount to what you wrote, just slightly shorter
13:31:56 <chipotle79> But cmccann, I'm still not sure about inefficiency.  Isn't this operation linear time, or n log n at worst?
13:32:58 <cmccann> if the list contains duplicates that's not helpful for constructing a Set, that's all
13:38:58 <lagagoose> damn.
13:42:44 <lagagoose> maybe i think you're an actor
13:42:50 <lagagoose> the other half of my brain
13:45:17 <mcstar> someone said cyberpunk?
13:45:30 <lagagoose> dowizzle
13:45:48 <mcstar> oh
13:45:56 <lagagoose> the glove n0de
13:46:11 <lagagoose> ahh i see
13:46:17 * hackagebot yesod-auth 1.1.1.5 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.5 (RaphaelJavaux)
13:46:19 * hackagebot opentheory 1.76 - The Haskell base  http://hackage.haskell.org/package/opentheory-1.76 (JoeHurd)
13:46:21 * hackagebot opentheory-parser 1.117 - Stream parsers  http://hackage.haskell.org/package/opentheory-parser-1.117 (JoeHurd)
13:46:23 * hackagebot opentheory-char 1.41 - Unicode characters  http://hackage.haskell.org/package/opentheory-char-1.41 (JoeHurd)
13:49:07 <atriq> Augh
13:49:15 <atriq> hoauth is impossible!
13:49:28 <magicman> > case "asdf" of {(:){}->()}
13:49:29 <lambdabot>   ()
13:49:35 <magicman> Why? Because.
13:50:01 <nand`> I didn't know that worked
13:50:22 <nand`> the empty record-matching syntax for non-record constructors
13:50:49 <magicman> Oh, that works. I was kinda surprised to see it working for non-record infix as well.
13:50:59 <mcstar> it is so that you can omit patterns
13:51:05 <magicman> ... Can you hae record infix? Oh, man.
13:51:25 * hackagebot opentheory-prime 1.23 - Prime numbers  http://hackage.haskell.org/package/opentheory-prime-1.23 (JoeHurd)
13:51:30 <magicman> *have
13:51:31 * magicman tries
13:51:44 <mcstar> nand`: imagine, you want to pattern match on a contructor with multiple fields, but you are not really interested in binding the fields
13:51:47 <monochrom> (:){} is the same as _:_
13:51:52 <mcstar> so, instead of _ you use {}
13:52:04 <nand`> yes, I know what it's doing; I just didn't know it was possible
13:52:14 <mcstar> well, i did :)
13:52:23 <monochrom> I saw it here a few days ago
13:52:37 <parcs`> haskell is a very regular language
13:52:39 <nand`> Actually, thinking back, I've used it before; but not for an infix constructor
13:52:53 <nand`> f Foo{}  vs f (Foo _ _ _ _)
13:52:55 <magicman> data Foo = (:*){a :: Int, b :: Int} is legal.
13:52:58 <geekosaur> hah.  it compiles...
13:53:02 <magicman> I'm not surprised, but I kinda am.
13:53:03 <geekosaur> ^^ that, yes
13:53:06 <parcs`> you can even do 'class Foo a | ->, ->, -> a where' even though all those fundeps are meaningless
13:53:29 <monochrom> > case pi*(0:+1) of (:+){} -> "hi"
13:53:32 <lambdabot>   "hi"
13:53:41 <parcs`> wait actually i think '-> a' is meaningful
13:53:48 <parcs`> 'a ->' isn't though
13:53:53 <nand`> ‘there can only be one instance’?
13:54:04 <nand`> like; nothing is needed to completely determine a?
13:54:06 <atriq> This is like Highlander
13:54:41 <parcs`> nand`: yeah
13:56:54 <alkabetz`> Anybody familiar with the ConfigFile package?  I'm getting some strange "functional dependencies" errors.
14:01:09 <hpc> @where hpaste
14:01:09 <lambdabot> http://hpaste.org/
14:01:12 <alkabetz`> Ah, never mind, figured it out.  I was mixing my monads. :/
14:01:22 <lagagoose> so uhh
14:01:25 <lagagoose> is there anyway to remove the static?
14:01:31 <lagagoose> starting to fuck up my memory
14:01:41 <lagagoose> can't really recall anything anymroe
14:01:58 <lagagoose> it's like my brain is actively being scramble
14:02:10 <hpc> lagagoose: i think you want #java ;)
14:02:11 <lagagoose> can someone fucking help?
14:02:19 <lagagoose> i can assure you it's the product of neural implants
14:02:43 <hpc> @where ops
14:02:43 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
14:02:44 <mcstar> it is called tinnitus, not a mental problem
14:02:49 <mcstar> but neurological
14:03:20 <mcstar> maybe you were listening to prolonged loud music
14:03:23 <lagagoose> tinnitus?
14:03:28 <mcstar> yes
14:03:29 <lagagoose> are you out of your mind?
14:03:31 <lagagoose> i see static bro
14:03:32 <nand`> #haskell-blah
14:03:53 <mcstar> ah, see, not hear, i see
14:04:16 --- mode: ChanServ set +o Igloo
14:04:22 <hpc> lagagoose: when asking for medical advice in a programming channel, it helps to be polite
14:04:36 <hpc> lagagoose: more importantly, it helps to be somewhere else
14:05:00 <hpc> where someone can actually help
14:05:17 <lagagoose> i'm pretty sure someone is hacking my brain
14:05:29 --- mode: Igloo set +b *!*@ool-182e02bb.dyn.optonline.net
14:05:31 --- kick: lagagoose was kicked by Igloo (lagagoose)
14:05:52 <mcstar> oh, i just wanted to guide him to a specialist http://www.healthgrades.com/neurology-directory/ok-oklahoma/haskell
14:06:06 <gertc> who is the ceo of haskell?
14:06:21 <mroman> ?
14:06:38 <gertc> like or key figure :) like linus for linux
14:06:47 <mroman> Oh.
14:06:54 <mroman> John Hughes
14:06:56 <mroman> probably
14:07:02 <mroman> Simon Peyton Jones
14:07:05 <mroman> don't know.
14:07:30 <sipa> Haskell Curry?
14:07:33 <gertc> are they on irc?
14:07:44 <mcstar> don steward?
14:07:48 <mroman> Well.
14:07:49 <gertc> mean haskel chanel?
14:07:51 <nand`> Haskell doesn't have a religious leader
14:08:16 <mcstar> doesnt have a BDFL
14:08:36 <parcs`> philip wadler
14:08:56 <parcs`> he introduced monads to haskell i think
14:08:59 <nand`> Haskell is governed by a committee, no?
14:09:04 <simon> I haven't seen Haskell Curry around #haskell in a while. I wonder what happened to him.
14:09:08 <Saizan> lambdabot is our overlord
14:09:13 <mcstar> ah, not comittee, i think
14:09:15 <nand`> Saizan++
14:09:18 <KALLISTI> all hail Oleg
14:09:23 <mcstar> but a bunch of interested people
14:09:25 <parcs`> iirc wadler also introduced type classes
14:09:35 <Ralith> simon: I hear he's just got caught up in his research.
14:09:50 <simon> Ralith, that's mathematicians for you.
14:10:05 <Saizan> mcstar: it was designed by a committee of people interested in lazy functional languages
14:10:11 <nand`> :t curry -- he's right there
14:10:12 <lambdabot> ((a, b) -> c) -> a -> b -> c
14:10:28 <nand`> Haskell curry
14:10:46 <mcstar> Saizan: but haskell reports and language development are actually being done, a comittee doesnt accomplish anything, usually
14:11:27 <Saizan> mcstar: but it was one of people who knew how to force thunks
14:11:38 <mcstar> :)
14:18:22 <gertc> haskell is the first language where i actualy need a irc to figure things out. Documentation great, syntax also but somehow not made for mortals. So it would be nice to know the ceo of haskell keep his staff on the haskell channel :)
14:18:43 <hiptobecubic> Hey guys i know this has been asked to death, but is there a comparison of use cases for vector vs array somewhere?
14:18:59 <mcstar> dont call it ceo, really
14:19:03 <mcstar> doesnt make any sense
14:19:16 <mcstar> not just in the case of haskell
14:19:25 <mmos> How I check the installed versions of libraries?
14:19:32 <simon> gertc, well, people here are generally helpful.
14:20:45 <mcstar> hiptobecubic: one thing, that first comes to mind, is array is multidimensional
14:21:00 <hiptobecubic> mcstar, then why use vector, ever?
14:21:02 <ivanm> mmos: ghc-pkg list
14:21:02 <gertc> yes but what worries me, i need them. and i can not imagine i am the only one
14:21:13 <rwbarton> vector has lots of crazy fusion magic
14:21:17 <nand`> I think I read some SO answers to the effect of ‘vector can be faster’
14:21:18 <mcstar> yeah
14:21:25 <hiptobecubic> ah
14:21:26 <mcstar> 'can be'
14:21:29 <hiptobecubic> array doesn't fuse at all?
14:21:29 <ivanm> hiptobecubic: nowadays, use-cases of array is mainly older code
14:21:37 <rwbarton> it's better to think of vector as a [] replacement than an array replacement imo
14:21:42 <ivanm> though the Ix stuff can be useful for custom bounds, etc.
14:22:11 <mcstar> i dont think array is outdated at all
14:22:31 <hpc> arrays are a perfectly relevant container type
14:22:41 <mmos> ivnam: Okay, so I think I see a problem. I have two installed versions of HaXml. how do I unintall the older one?
14:22:42 <hiptobecubic> It seems like it would be trivial to write a mutlidimensional indexer on a vector, so what benefit is that?
14:23:03 <hpc> sometimes an algorithm just really doesn't want to be made functional, and you have to resort to STArray
14:23:20 <hpc> or you are dealing with FFI, and IOArray is needed
14:23:29 <hiptobecubic> there are also mutable vectors
14:24:56 <ivanm> mmos: ghc-pkg unregister HaXml-<version>
14:25:05 <ivanm> (will still be on disk, but ghc won't know about it)
14:25:07 <mmos> ivanm: thanks
14:28:00 <rwbarton> for normal random access mutable array stuff I just use array because I don't see any advantage to vector
14:28:23 <rwbarton> what vector is really good at is generating very fast code for stuff like "sum [1..1000000]"
14:42:05 <gertc> what happend to b? forM_ :: Monad m => [a] -> (a -> m b) -> m ()
14:42:34 <shachaf> gertc: Nothin'.
14:42:49 <mog_> forM_ is about side effects
14:42:56 <hiptobecubic> rwbarton, but why *not* use vector and just have one well known interface for all your code?
14:43:06 <rwbarton> array is better known to me :)
14:43:22 <rwbarton> i hardly ever use vector
14:43:34 <gertc> ok so b is Nothing, so we just drop it
14:43:50 <shachaf> b is unimportant.
14:43:53 <Jafet> They are sent to http://blog.shimer.edu/.a/6a010534b2c34a970c016768d3285d970b-320wi
14:44:08 <atriq> b could be PicturesOfDogsPlayingDiminishingWhist
14:44:17 <atriq> For all you need to care
14:44:52 <gertc> :t ()
14:44:54 <lambdabot> ()
14:45:07 <atriq> () is a type with one value, also called ()
14:45:29 <atriq> This lends it some interesting properties
14:45:32 <atriq> > () <> ()
14:45:34 <lambdabot>   Ambiguous occurrence `<>'
14:45:34 <lambdabot>  It could refer to either `Data.Monoid.<>',
14:45:34 <lambdabot>      ...
14:45:40 <atriq> > () `mappend` ()
14:45:42 <lambdabot>   ()
14:45:49 <atriq> It's a monoid, for example
14:46:13 <atriq> However, it's most useful for when you don't care what the value is, but there has to be a value
14:46:22 <ivanm> I thought the pretty definition of <> was now mappend :s
14:46:33 <gertc> :t (5)
14:46:34 <lambdabot> Num a => a
14:46:43 <gertc> :t (b)
14:46:44 <lambdabot> Expr
14:46:45 <atriq> :t (<>)
14:46:46 <lambdabot>     Ambiguous occurrence `<>'
14:46:47 <lambdabot>     It could refer to either `Data.Monoid.<>',
14:46:47 <lambdabot>                              imported from `Data.Monoid' at State/L.hs:35:1-18
14:46:51 <gertc> :t ('b')
14:46:53 <lambdabot> Char
14:52:08 <gertc> you can not believe how much () confuses imperative people :)
14:54:04 <Hermit> does it?
14:54:21 <Hermit> (does it really confuse people?)
14:55:06 <SLi> Well, when I was really new to Haskell, I was confused by IO () and generally by (), but I did know that () is the unit value. But then I had O'Caml background...
14:55:08 <gertc> i vote for (_) :)
14:55:14 <hpc> gertc: it makes perfect sense to perl-ers ;)
14:55:33 <SLi> But generally my heuristics were something like () is still understandable, but when affixed to anything like IO (), it meant magic :)
14:55:57 <SLi> But that was like after 2 or 3 days of head-scratching.
14:55:58 <mcstar> why? same logic as f ()
14:56:04 <mcstar> you dont say it is affixed to f
14:56:34 <SLi> Well, obviously it also had to do with the fact that IO is a monad, and everybody said that monads are weird beings.
14:57:15 <SLi> In value-space () is much more understandable than type-space. Hmm. Maybe, just *maybe* it might be because it doesn't look anything like the other types.
14:57:58 <Hermit> SLi: well, I'm still relatively new to haskell, () never confused me. My background is lisp. I've been scratching my head quite a while figuring out how the heck to get a function to sequence actions using the elements of a list (something like mapc)
14:58:00 <SLi> In o'caml the type of () is unit.
14:58:08 <Hermit> finally got it working but it's not something I'd call intuitive
14:58:20 <mcstar> :t ()
14:58:22 <lambdabot> ()
14:58:29 <hpc> i expect part of it is that () is useless in almost every situation a beginning haskell programmer finds themselves
14:58:42 <mcstar> whats the difference? Unit is inhabited by unit
14:58:47 <mcstar> i think thats the terminology
14:59:12 <gertc> would it not make more sense if :t () gives _ as result?
14:59:28 <mcstar> _ is an unnamed placeholder
14:59:36 <Hermit> gertc: and what would _ be then?
15:00:04 <gertc> ~ :)
15:00:07 <Hermit> () is like nil
15:00:15 <Hermit> (car nil) -> nil
15:00:39 <hpc> () is like a burrito :P
15:00:50 <hpc> it's round and delicious
15:00:50 <dmwit> Hermit:
15:00:52 <dmwit> :t mapM
15:00:54 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:00:57 <mcstar> > car ()
15:00:58 <lambdabot>   Not in scope: `car'
15:00:58 <lambdabot>  Perhaps you meant one of these:
15:00:59 <lambdabot>    `chr' (imported fro...
15:01:09 <SLi> mcstar, I'm not sure, but maybe it's confusing because it's the only type where the name of the type is the same as one of the inhabitants.
15:01:18 <dmwit> Hermit: (re "how the heck to get a function to sequence eactions using the elements of a list")
15:01:40 <hpc> SLi: Maybe gives people trouble too
15:01:45 <FireFly> SLi: isn't that the case with [a] too?
15:01:46 <SLi> mcstar, generally I think with every other type you can tell by looking at a string if it's a type or a value, but not with ().
15:01:50 <mcstar> SLi: but it is like in ocaml
15:01:57 <FireFly> I mean, it could be used both as a value and a type
15:02:00 <mcstar> the only difference it is not written as unit
15:02:16 <hpc> FireFly: beginners tend to not realize you can do [] at the type level
15:02:20 <SLi> mcstar, yes, but in ocaml () is the value and "unit" is the type. In Haskell () is the value and () is the type.
15:02:24 <hpc> until shown explicitly
15:02:33 <mcstar> SLi: thats exactly what i said
15:02:48 <mcstar> at least had in mind
15:02:51 <SLi> Ok :)
15:03:12 <Hermit> dmwit: yeah, got it, I'm thinking about it's type signature. What I was trying to do is draw a path using cairo. This Path was [Atom] where Atom is an ADT including Point Bezier and others. I was trying to draw inside a Render () monad
15:03:24 <Hermit> dmwit: not sure if mapM would do in this case, but I'll try
15:03:26 <SLi> But I wouldn't really consider () as one of the most confusing things in learning Haskell. But then Haskell was not nearly the first functional language for me.
15:03:34 <gertc> say haskell would just change the name of the type () would that break everything?
15:03:50 <mcstar> yes
15:04:03 <dmwit> Hermit: If each Atom can be handled independently of the others, then yes, mapM will do. If you need to look at two Atom's at a time or something like that, you'll need a bit more work.
15:04:24 <dmwit> Also, "independently" is a very slippery word when used in the context of monads.
15:04:27 <dmwit> I
15:04:50 <rwbarton> "in the pattern captured by mapM"
15:05:14 <dmwit> I say "handled independently" to mean "produce a monadic action independently", not necessarily "produce an action that is unaffected by the side effects produced by the other actions".
15:05:36 <Hermit> dmwit: what I did was recurse doing: drawpath (a:rest) = draw a >> drawpath rest
15:05:47 <dmwit> Okay, then yes, mapM will handle that nicely.
15:05:52 <dmwit> drawpath = mapM draw
15:06:01 * Hermit edits the code
15:06:09 <mcstar> also, theres nothing wrong with above recursive definition
15:06:14 <dmwit> Right.
15:06:21 <Hermit> oh
15:06:32 <Hermit> forgot one thing, on [] it calls closePath
15:06:41 <mcstar> yes, we knew
15:06:43 <mcstar> :)
15:06:49 <Hermit> should I do it like this?:  drawpath = mapM draw >> closePath
15:06:51 <dmwit> drawpath p = mapM draw p >> closePath -- =)
15:06:58 <dmwit> You were pretty close. =)
15:06:59 * cmccann thinks that looks more like a use for mapM_
15:07:01 <Hermit> err, yeah
15:08:18 <Hermit> nice
15:08:21 <SLi> drawpath = (>> closePath) . mapM draw -- :p
15:08:40 <SLi> If you want to be pointlessly pointless.
15:08:41 <Sonderblade> is there a difference between: let (Just foo) = blah and let foo = (fromJust blah) ?
15:08:59 <rwbarton> a practical difference yes
15:09:04 <Hermit> SLi: that could have the damned monomorphic restriction kicking in
15:09:04 <dmwit> Hermit: It's probably worth taking a second to see if you can implement mapM yourself. It's not too hard of an exercise, once you've done some instantiations like drawpath yourself.
15:09:08 <mcstar> prefer the 1st one
15:09:34 <mcstar> or, go with a case
15:09:42 <rwbarton> the first will give you a useful runtime error
15:09:52 <rwbarton> or more useful, anyways
15:09:55 <dmwit> Sonderblade: The first one will give an error pointing at the line doing the match; the second one will give an error pointing at the source code for fromJust.
15:10:27 <dmwit> I don't consider the case where it never gives an error likely enough to be worth considering.
15:10:46 <shachaf> dmwit: What a pessimist.
15:10:48 <mcstar> you just considered it
15:11:06 <dmwit> mcstar: Yes, but it wasn't worth it.
15:11:36 <Sonderblade> right, but it is almost always the same thign then?
15:11:43 <rwbarton> if you take the safeFoo stuff seriously you will often have to write stuff like let Just foo = safeWhatever bar
15:11:59 <shachaf> Which is much nicer, error-message-wise.
15:14:26 <dmwit> Sonderblade: No, it is not almost always the same thing. It is almost never the same thing.
15:15:05 <dmwit> It is the same thing just when blah is always a Just, that is to say, almost never.
15:15:06 <rwbarton> they differ only in the practical aspect of what ghc will print if your code is wrong
15:17:11 * dmwit decides he must be feeling grumpy
15:17:14 <Hermit> dmwit: mapm fn (a:as) = fn a >> mapm fn as
15:17:52 <dmwit> > let mapm fn (a:as) = fn a >> mapm fn as in mapm return [3,4,5] :: [[Int]]
15:17:55 <lambdabot>   *Exception: <interactive>:3:5-39: Non-exhaustive patterns in function mapm
15:18:03 <dmwit> Hermit: Close, but not quite. =)
15:18:05 <gertc> works https://github.com/gertcuykens/haskell-design/blob/master/Main.hs but i am trying to do this now broadcast :: MonadIO m => T.Text -> [Client] -> m (IO ())
15:18:23 <Hermit> hmm
15:18:31 <gertc> what does the m (IO ()) need to eb ?
15:18:31 <mcstar> :t mapM
15:18:33 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
15:18:38 <mcstar> make sure you make a list
15:18:43 <dmwit> Hermit: Actually, it's close to mapM_, but not very close to mapM.
15:22:23 * shapr bops cheerfully
15:23:28 <Hermit> I don't want to cheat looking at mapM's source, but I'm banging my head against the wall here
15:23:41 <Hermit> fly-style
15:23:53 <dmwit> Show us what you've got. Maybe we can give you some hints that will save your head from hull breach.
15:24:10 <gertc> does this mae sence broadcast :: MonadIO m => T.Text -> [Client] -> m (); broadcast m l = T.putStrLn m >> liftIO (forM_ l $ \(_, k) -> WS.sendSink k $ WS.textData m)
15:24:57 <Hermit> 2 lines paste is ok?
15:25:09 <dmwit> 2 lines is ok
15:25:11 <Hermit> so far I've got this:
15:25:13 <Hermit> mapm _ [] = return []
15:25:15 <Hermit> mapm fn (a:as) = fn a >> mapm fn as
15:25:29 <dmwit> ah, okay!
15:25:48 <dmwit> Well, you'll need to remember the value returned by "fn a", so that you can include it in the list you return.
15:26:03 <dmwit> Similar thing for "mapm fn as" in the recursive call -- you'll need to remember the list it produces.
15:26:12 <dmwit> You can use (>>=) to name the results of these things.
15:26:18 <dmwit> :t (>>=)
15:26:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
15:26:27 <Hermit> oh, right
15:26:29 * Hermit tries again
15:29:15 <fliip> How would you show a function defines equality?
15:31:18 <dmwit> fliip: I'm not sure I understand the question.
15:31:41 <fliip> Nor am I.
15:31:42 <fliip> lol
15:32:37 <fliip> I have created a very long function in lambda calculus, and at the end of the question, it says "and now show that function f defines equality".
15:33:12 <mcstar> show ~ prove
15:33:43 <fliip> How would I prove it?
15:33:46 <fliip> Prove it for n?
15:34:06 <dmwit> Can you show us the assignment in full?
15:34:08 <atriq> If it's just equality on church numbers, you can use induction?
15:34:22 <dmwit> I feel like there's not enough context here to really know what the question is supposed to mean.
15:37:07 <parcs`> > () `mappend` undefined
15:37:09 <lambdabot>   ()
15:37:14 <parcs`> > undefined `mappend` ()
15:37:16 <lambdabot>   ()
15:38:05 <atriq> > undefined `mappend` undefined :: ()
15:38:07 <lambdabot>   ()
15:40:29 <nand`> > undefined `mappend` undefined
15:40:31 <lambdabot>   ()
15:40:37 <gertc> victorie :) broadcast t l = liftIO (T.putStrLn t) >> liftIO (forM_ l $ \(_, k) -> WS.sendSink k $ WS.textData t)
15:42:34 <gertc> btw can you write the above line better?
15:43:47 <nand`> l^!traverse._2.act (`sendSink` textData t)
15:43:52 <nand`> or something like that
15:45:10 <gertc> hold on decoding :)
15:48:04 <gertc> damn i could actully understand it :)
15:52:26 <Hermit> =/
15:52:50 <Hermit> I'll read more about monads and charge again
15:53:52 <Hermit> I reached the (frustration) point where I'm aimlessly trying different possibilities without really knowing what the f*** is going on
15:54:01 <Hermit> so I'll leave it alone for today
15:54:12 <Hermit> or for a while at least
16:00:51 <gertc> hmm importing _2 feels a bit static?
16:01:46 <gertc> but it works doh broadcast t l = liftIO (T.putStrLn t) >> liftIO (l^!traverse._2.act (`WS.sendSink` WS.textData t))
16:01:54 <crdueck> if i have an equation for a line in point-slope form, how can I write a function to return a list of points on that line at equal intervals?
16:03:48 <gertc> is there a better liftIO solution for that line?
16:05:07 <neutrino> map liftIO sequence?
16:05:22 <neutrino> those are kinda out of order.
16:06:28 <nand`> surely liftIO a >> liftIO b = liftIO (a >> b)
16:06:33 <nand`> (not sure if that's an actual law)
16:08:07 <nand`> liftIO (m >>= f) = liftIO m >>= (liftIO . f);  with f = const g that transforms to liftIO (m >> g) = liftIO m >> liftIO g
16:08:08 <gertc> hmm i thought l ( a >> b) was not possible, testing
16:08:23 <nand`> (the former is the actual law as stated by class MonadIO)
16:10:30 <nand`> I would probably write that as liftIO $ do { T.putStrLn t; l ^! traverse ... }
16:10:34 <nand`> (on separate lines)
16:11:20 <gertc> i tried to avoid do to keep my brain in function mode
16:11:52 <nand`> that being said; I would probably separate the ‘broadcasting’ from the ‘logging to stdout’
16:11:58 <nand`> (if I infer your function's purpose correctly)
16:12:21 <nand`> then it would be f t l = putStrLn t >> broadcast t l
16:12:26 <gertc> works broadcast t l = liftIO $ T.putStrLn t >> l^!traverse._2.act (`WS.sendSink` WS.textData t)
16:12:50 <nand`> you could possibly also pull the liftIO out into the ‘f’ then and eta-reduce ‘broadcast’ to make it even more elegant :)
16:13:53 <gertc> hmm yes probably not a bad idea
16:13:56 <nand`> then it would be: broadcast t = perform $ traverse._2.act (... t)
16:14:24 <nand`> or perhaps
16:14:36 <nand`> broadcast t = liftIO .: perform $ traverse._2.act (... t)
16:14:50 <nand`> but that's longer than the eta-expanded ver
16:17:27 <Hermit> dmwit: yay! solved it
16:17:31 <gertc> wait where does htis .: come from its not a lens thing right?
16:18:02 <Hermit> dmwit: mapm _ [] = return []
16:18:04 <Hermit> mapm fn (a:as) = fn a >>= (\x -> mapm fn as >>= (\r -> return (x : r)))
16:18:57 <Hermit> dmwit: it does what it's supposed to, right?
16:24:24 <Hermit> dmwit: http://pastebin.com/A6Nn8HXZ  <-- formatted it
16:24:36 <mauke> The paste A6Nn8HXZ has been copied to http://hpaste.org/77548
16:25:03 <Hermit> nice
16:25:38 <Hermit> but I screwed up, changed the name of the fn from mapm to mapM and forgot to change the recursive call. Should have used mass replace but...
16:27:33 <hpaste> Hermit pasted “mapM” at http://hpaste.org/77549
16:27:39 <Hermit> fixed
16:28:23 <nand`> why don't you use do-notation?
16:29:26 <nand`> one piece of advice I would have is to separate mapM into map and sequence
16:29:26 <Hermit> well, just got it working with >>= and all, haven't tried yet with do
16:29:55 <Hermit> oh, didn't know about sequence
16:30:06 <hpaste> nand` annotated “mapM” with “mapM (annotation)” at http://hpaste.org/77549#a77550
16:30:14 <nand`> here's what it would look like with do notation; not that much difference
16:30:18 <nand`> but much cleaner :)
16:32:36 <Hermit> nand`: it looks way cleaner
16:32:59 <Hermit> thanks for the advice :D
16:33:04 <nand`> there's also a transformation you can do on that which becomes obvious in that representation
16:33:10 <nand`> @src liftM2
16:33:11 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
16:33:13 <gertc> where does .: come from?
16:33:19 <nand`> gertc: Data.Function.Pointless
16:33:38 <nand`> or, if you want to define it yourself, (.).(.)
16:33:39 <gertc> hmm somthing new
16:33:55 <Hermit> :t liftM2
16:33:56 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
16:34:12 <Hermit> I see
16:34:23 <Hermit> just for the sake of it...:
16:34:27 <Hermit> @src mapM
16:34:27 <lambdabot> mapM f as = sequence (map f as)
16:34:33 <nand`> :)
16:34:55 <Hermit> this simplifies things a lot
16:34:59 <Hermit> @src mapM_
16:35:00 <lambdabot> mapM_ f as = sequence_ (map f as)
16:35:01 <nand`> so yeah, you could rewrite that as liftM2 (:) (fn a) (mapM' fn as)
16:35:12 <Hermit> yeah
16:35:25 <nand`> (you can also write sequence very easily in terms of liftM2)
16:35:27 <Hermit> one single step, no do notation, no monadic notation
16:35:42 <Hermit> :t sequence
16:35:44 <lambdabot> Monad m => [m a] -> m [a]
16:36:03 <Hermit> I'll have to practice a lot more
16:36:30 <Hermit> this monad stuff still gets me banging my head against the wall from time to time
16:37:27 <nand`> sequence = sequence . id = sequence . map id = mapM id; so you should be able to write ‘sequence’ trivially by removing ‘fn’ from your current code, incidentally
16:38:33 <Hermit> that equality chain is enlightening
16:40:09 <Hermit> anyway, I'll continue with this tomorrow
16:40:24 <Hermit> been hooked up longer than expected
16:42:26 <Hermit> anyway, thanks nand` and dmwit for the assistance. I appreciate it :¬)
16:46:21 * hackagebot alloy 1.1.0 - Generic programming library  http://hackage.haskell.org/package/alloy-1.1.0 (MattGlazar)
16:52:14 <gertc> can you right this with just . because i having problems understaning it, but it works do broadcast t = liftIO .: perform $ traverse._2.act (`WS.sendSink` WS.textData t)
16:54:31 <gertc> i was think broadcast t = liftIO `(perform $ traverse._2.act (`WS.sendSink` WS.textData t))` or somthing :)
16:57:19 <gertc> (f .: g) x y = f (g x y)
16:58:36 <gertc> i expected (f .: g) x y = f g (x y)
17:00:45 <Nereid> gertc: you expected wrong :p
17:01:03 <Nereid> @type (.:)
17:01:05 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
17:01:07 <gertc> a wait i have abetter question where does the l fit in if i would put it back? broadcast t l = liftIO .: perform $ traverse._2.act (`WS.sendSink` WS.textData t)
17:01:08 <Nereid> urgh.
17:01:42 <Nereid> f .: g = (f .) . g
17:01:54 <Nereid> but that doesn't help much.
17:02:13 <Nereid> @type (.:) :: (a -> b) -> (c -> d -> a) -> (c -> d -> b)
17:02:15 <lambdabot> (a -> b) -> (c -> d -> a) -> c -> d -> b
17:02:21 <Nereid> that's all it does.
17:02:38 <Nereid> composes any function with a function of 2 arguments.
17:04:10 <Nereid> (f .: g) x y = ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
17:04:48 <Nereid> @type fmap fmap fmap
17:04:50 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:04:54 <Nereid> :)))))))))))))
17:05:52 <gertc> man i am still not good at understanding haskel jokes :) do not even try to exaplain it to me :)
17:06:49 <Nereid> it's a quote from the typeclassopedia.
17:06:54 <Nereid> "Someone in the #haskell IRC channel used (***), and when I asked lambdabot to tell me its type, it printed out scary gobbledygook that didn’t even fit on one line! Then someone used fmap fmap fmap and my brain exploded."
17:07:15 <Nereid> @type (***)
17:07:16 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
17:07:21 <int-e> @type (.)
17:07:23 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:07:27 <Nereid> caleskell
17:07:34 <int-e> @type \f g x -> f (g x)
17:07:36 <lambdabot> (t1 -> t) -> (t2 -> t1) -> t2 -> t
17:07:45 <Nereid> @type \f g x y -> f (g x y)
17:07:46 <lambdabot> (t1 -> t) -> (t2 -> t3 -> t1) -> t2 -> t3 -> t
17:08:04 <int-e> (showing that Functor f => (a -> b) -> f a -> f b generalizes (t1 -> t) -> (t2 -> t1) -> t2 -> t is left as an exercise to the interested reader.)
17:08:08 <Nereid> @type let (.) = (Prelude..) in (.) . (.)
17:08:09 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:08:21 <Nereid> @type let (.) = (Prelude..) in (.) . (.) . (.) . (.)
17:08:23 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> b) -> a -> a1 -> a2 -> a3 -> c
17:09:15 <int-e> @type (Control.Category..)
17:09:17 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
17:09:30 <int-e> @type (Control.Category..)(Control.Category..)(Control.Category..)
17:09:32 <lambdabot> Control.Category.Category cat => cat b c -> (a -> cat a1 b) -> a -> cat a1 c
17:09:40 <shachaf> @arr
17:09:40 <lambdabot> Keelhaul the swabs!
17:09:52 <Nereid> @type let (.) = (Control.Category..) in (.) . (.) . (.) . (.)
17:09:53 <lambdabot> Control.Category.Category cat => cat b c -> (a -> a1 -> a2 -> cat a3 b) -> a -> a1 -> a2 -> cat a3 c
17:10:15 <int-e> @type (Prelude..)(.)(Control.Category..)
17:10:17 <lambdabot> (Functor f, Control.Category.Category cat) => cat b c -> f (cat a b) -> f (cat a c)
17:10:20 <Nereid> @type \f g -> curry (f . uncurry g)
17:10:23 <lambdabot> (a1 -> c) -> (a -> b -> a1) -> a -> b -> c
17:10:31 <Nereid> @pl \f g -> curry (f . uncurry g)
17:10:31 <lambdabot> (curry .) . (. uncurry) . (.)
17:11:20 <Nereid> @type fmap . (Control.Category..)
17:11:21 <lambdabot> (Functor f, Control.Category.Category cat) => cat b c -> f (cat a b) -> f (cat a c)
17:11:24 <Nereid> @type (Control.Category..) . fmap
17:11:25 <lambdabot> Functor f => (a1 -> b) -> (a -> f a1) -> a -> f b
17:11:29 <Nereid> heh
17:11:47 <Okasu> @type fmap fmap fmap fmap
17:11:48 <lambdabot> (Functor f2, Functor f1, Functor f) => f (f1 (a -> b)) -> f (f1 (f2 a -> f2 b))
17:11:53 <Nereid> @type fmap fmap fmap fmap fmap fmap
17:11:55 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
17:11:56 <Nereid> @type fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
17:11:57 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
17:12:02 <Nereid> ;)
17:12:02 <Okasu> :P
17:12:18 <Nereid> if you have some time to kill, prove that fmap^6 and fmap^10 are equal.
17:12:31 <Okasu> for what?
17:12:36 <Nereid> for fun.
17:12:38 <shachaf> One of them composes left-associatively and the other composes right-associatively, right?
17:12:52 <Nereid> eh?
17:12:53 <shachaf> So it winds up being the same thing.
17:13:13 <Okasu> nah, useless crap isn't funny at all, i'd better learn some spanish :P
17:13:16 <Nereid> lol
17:16:44 <gertc> aha broadcast t = (liftIO .) . perform $ traverse._2.act (`WS.sendSink` WS.textData t)
17:16:59 <shachaf> @ty fmap (fmap fmap) . fmap
17:17:00 <lambdabot> (Functor f1, Functor f) => (a1 -> a -> b) -> f a1 -> f (f1 a -> f1 b)
17:18:22 <gertc> still do not understand why this should not work either broadcast t = liftIO . perform $ traverse._2.act (`WS.sendSink` WS.textData t)
17:18:46 <shachaf> @ty fmap fmap (fmap fmap)
17:18:47 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
17:19:04 <Nereid> @ty fmap . fmap fmap
17:19:05 <lambdabot> (Functor f1, Functor f) => (a -> a1 -> b) -> f a -> f (f1 a1 -> f1 b)
17:19:23 <Sonderblade> (+1) 5 works, but how do you get (-1) 5 to work too?
17:19:31 <Nereid> > (subtract 1) 5
17:19:31 <FireFly> use substract
17:19:33 <lambdabot>   4
17:19:47 <Nereid> > (-1) 0
17:19:49 <lambdabot>   -1
17:19:50 <Nereid> works for me!!
17:19:51 <FireFly> -1 is literal syntax for 1 negated
17:20:32 <Nereid> > subtract a b
17:20:34 <lambdabot>   b - a
17:20:46 <Okasu> > (-) 1 5
17:20:47 <lambdabot>   -4
17:21:18 <Nereid> > (-3) liftA2 "hello"
17:21:19 <lambdabot>   Ambiguous type variable `f0' in the constraint:
17:21:19 <lambdabot>    (Control.Applicative.App...
17:21:22 <Nereid> aw.
17:21:37 <Sonderblade> thanks
17:22:45 <Sonderblade> oh.. succ and pred are nice
17:24:02 <Nereid> > succ False
17:24:04 <lambdabot>   True
17:24:56 <Nereid> @let safeSucc = listToMaybe . drop 1 . enumFrom
17:24:58 <lambdabot>  Defined.
17:25:04 <Nereid> > safeSucc False
17:25:06 <lambdabot>   Just True
17:25:06 <Nereid> > safeSucc True
17:25:08 <lambdabot>   Nothing
17:25:09 <Nereid> > succ True
17:25:10 <lambdabot>   *Exception: Prelude.Enum.Bool.succ: bad argument
17:25:19 <Okasu> geez, its awfully wrong, it remainds me c/cpp enums: when you add "banana" to "potato" you'll get "tomato"
17:25:23 <Sonderblade> > succ it
17:25:25 <lambdabot>   Not in scope: `it'
17:25:25 <lambdabot>  Perhaps you meant one of these:
17:25:25 <lambdabot>    `id' (imported from ...
17:25:29 <Sonderblade> hehe
17:25:47 <Nereid> Okasu: you can't add enums
17:26:02 <Okasu> Nereid: i can add integers representing enums
17:26:11 <Nereid> yes, but then you're adding integers, not enums
17:26:14 <mikeplus64> Nereid: i wonder if the overhead of list -> Maybe is greater or less than trying to catch the exception raised by succ True
17:26:31 <Nereid> mikeplus64: I wonder. I can't do the latter in lambdabot though
17:26:44 <shachaf> mikeplus64: Who knows if the list will ever even be created?
17:26:52 <mikeplus64> ghc
17:27:08 <Nereid> > safeSucc (maxBound :: Int)
17:27:10 <lambdabot>   Nothing
17:27:40 <ivasilov_> can anyone share a snippet for benchmarking pure functions?
17:28:05 <shachaf> safePred x = listToMaybe (drop 1 (enumFromThen x (pred x))) -- la la la
17:28:14 <Nereid> shachaf: lol
17:28:31 <Okasu> Nereid: nope, i can represent integer as enum elem and vise versa so i add enums
17:28:32 <Ghoul> lpvb: hey
17:28:40 <Okasu> in Ada you can't do such stuff
17:28:45 <Nereid> Okasu: neither in Haskell
17:28:56 <fryguybob> ivasilov_: https://github.com/bos/criterion/blob/master/examples/Fibber.hs
17:29:54 <ivasilov_> fryguybob: I ran into Criterion before. I was hoping for some quick and dirty function
17:31:07 <Nereid> > (catMaybes . takeWhile isJust . iterate (>>= safeSucc) . Just) LT
17:31:09 <lambdabot>   [LT,EQ,GT]
17:31:18 <Nereid> > (catMaybes . takeWhile isJust . iterate (>>= safeSucc) . Just) (0 :: Int)
17:31:20 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
17:32:07 <Nereid> Enum is annoying. :(
17:32:10 <shachaf> Is it guaranteed that [x..]!!1 == succ x?
17:32:39 <monochrom> > [() ..]
17:32:41 <lambdabot>  Terminated
17:33:01 <Okasu> Nereid: "succ False = True" what a ill logic is this in that case?
17:33:02 <monochrom> > [() ..]
17:33:04 <lambdabot>   [()]
17:33:09 <Okasu> ah, forget about it...
17:33:20 <Nereid> Okasu: it's fine
17:33:26 <Nereid> True is the next boolean value after False
17:33:42 <Nereid> there's no arithmetic happening
17:34:27 <Nereid> shachaf: I don't think anything is guaranteed about Enum instances.
17:34:37 <Nereid> it makes me sad.
17:35:38 <shachaf> Yes. :-(
17:35:50 <Okasu> Nereid: huh, what is "next"? n + 1?
17:36:04 <Nereid> Okasu: Bool is defined as the data type that has two values, False and True.
17:36:07 <Nereid> where False comes before True.
17:36:32 <shachaf> @src Bool
17:36:32 <lambdabot> data Bool = False | True deriving (Eq, Ord)
17:36:34 <Nereid> Okasu: Bool has an Enum instance, where succ False = True.
17:36:56 <Okasu> Nereid: who cares about underlying haskell problems? Its just wrong, there is no such "next" thing https://en.wikipedia.org/wiki/Boolean_algebra
17:37:14 <Nereid> Okasu: what?
17:37:24 <Nereid> there's a very standard ordering on boolean values
17:37:28 <Nereid> where False < True
17:37:44 <Nereid> (which extends to a partial ordering on any boolean algebra)
17:38:17 <Hermit> Okasu: succ False = True   (underlined part is a function with pattern match, where a Bool constructor is matched"
17:38:38 <Hermit> Okasu: if False is provided to succ, it will return True, what ill logic are you talking about?
17:39:24 <geekosaur> Okasu seems to think the Ruby model makes more sense, where False and True are different types?
17:39:33 <Nereid> they are!?
17:40:13 <Nereid> then again "types" doesn't mean much in such a language
17:40:14 <geekosaur> Ruby has a somewhat different notion of type than Haskell does; they're different classes
17:40:45 <Nereid> ruby also doesn't have algebraic data types
17:40:51 <geekosaur> False is the constructor for FalseClass, True the constructor for TrueClass, both classes respond to messages implementing the standard Boolean behavior.
17:40:56 <Nereid> so how else would you implement it
17:41:11 <Okasu> geekosaur: ruby is completly unrelated language, why do you try to offtopic here about ruby?
17:41:30 <Nereid> anyway, the point is that "succ False = True" makes perfect sense
17:41:38 <Nereid> and is completely reasonable
17:41:48 <Okasu> Nereid: in your haskell little world :)
17:41:51 <monochrom> I don't understand why "there is no such next thing"
17:41:53 <geekosaur> because it implements False not being comparable to True, as you seem to think is sane.  it's the usual way to do so, in fact.
17:41:53 <Nereid> ("True is the smallest boolean value larger than False")
17:42:01 <Hermit> Okasu: think of Bool as a C union of True and False
17:42:06 <geekosaur> in languages which make False and True values in the same type, they are ordered
17:42:13 <Nereid> Hermit: no don't
17:42:27 <monochrom> but now everyone is speaking, so no one will notice that I say something
17:42:29 <mauke> a union?!
17:42:34 <geekosaur> more like an enum
17:42:43 <geekosaur> union would be closer to the Ruby sense
17:43:22 <Nereid> Okasu: no, just from a mathematical point of view
17:43:50 <Nereid> "True is the smallest boolean value bigger than False" makes exactly as much sense as "5 is the smallest integer larger than 4"
17:44:20 <Okasu> Nereid: integer and boolean are different types, you can't compare them
17:44:27 <tsou> Nereid: F < T is not the only ordering that makes sense on truth values..
17:44:31 <mauke> Okasu: ... you just compared them
17:44:39 <Nereid> tsou: it isn't?
17:44:46 <Okasu> mauke: nope
17:44:46 <Nereid> tsou: in whose world is F > T?
17:44:56 <Okasu> mauke: where, point me at this
17:45:00 <simon> has anyone here implemented a type checker in Haskell and wants to share their repo? I'm looking at GHC's type checker, but it's a bit complicated
17:45:07 <Nereid> mauke: I'm not comparing boolean values with integers.
17:45:11 <Nereid> er, Okasu: ^
17:45:14 <mauke> Okasu: "integer and boolean are different types" <- that's a comparison
17:45:26 <Nereid> Okasu: Bool and Int are both totally ordered.
17:45:30 <monochrom> F<T is not the only ordering. but that's fine. pick your ordering. then you have succ, too
17:45:36 <tsou> Nereid: the two most common orderings on truth values are the "truth" one and the "knowledge" one
17:45:38 <Nereid> and whenever you have a totally ordered set, it makes perfect sense to ask if something has a successor.
17:46:02 <Nereid> tsou: "two most common" as if there are more than two. and what "knowledge" one?
17:46:08 <Okasu> mauke: nope, it's differentiation
17:46:20 <byorgey> Nereid: there is a nontrivial automorphism that sense False to True and True to False.  So in some sense "which one is False" and "which one" is True is arbitrary.  Hence the ordering is arbitrary too.
17:46:28 <byorgey> Nereid: the same is not true for the natural numbers.
17:46:29 <Okasu> aw, times up, sorry about this mess
17:46:29 <Nereid> byorgey: automorphism of what? sets?
17:46:35 <byorgey> Nereid: of boolean algebras.
17:46:39 <Nereid> no
17:46:41 * Okasu still didn't learnt his spanish
17:46:46 <tsou> Nereid: i mean in more than two-valued logics
17:46:57 <Nereid> byorgey: any automorphism of boolean algebras (or even lattices) must preserve the minimum element.
17:47:12 <Nereid> tsou: do you see more than two values in Bool? (_|_ doesn't count)
17:47:21 <tsou> Nereid: i don't see why bottom doesn't count
17:47:22 <byorgey> Nereid: maybe I mean "homomorphism".  I mean if you reinterpret True as False and && as || and vice versa
17:47:37 <gertc> .: was already in use and qualified it as P how do i write P..: ?
17:47:45 <tsou> Nereid: it's pretty much the standard 3rd value for such logics in which bot < F, bot < T, and F and T are non-comparable
17:47:47 <byorgey> Nereid: but there's no way you can switch 4 and 5 and reinterpret the arithmetic operations to make it work.
17:47:56 <Nereid> byorgey: ok, sure, you get a dual algebra.
17:48:10 <Nereid> but that hardly gives you an isomorphism in general.
17:48:20 <Nereid> tsou: yes, but we're not talking about that ordering.
17:48:29 <byorgey> I'm just trying to make the point that False < True feels much more arbitrary than 4 < 5.
17:48:33 <gertc> import qualified Data.Function.Pointless as P ((.:))
17:48:33 * geekosaur thinks #haskell has successfully been trolled...
17:48:39 <simon> I'm making it monadic and am currently using a State monad to contain both variable tables for individual modules and a call graph for the entire check, and I feel I could re-structure it in some slightly more complicated way that separates temporary variable tables from the call graph I'll use in the subsequent type checking stage.
17:48:54 <Nereid> byorgey: it does? why can't 4 > 5?
17:48:54 <tsou> Nereid: you aren't
17:49:03 <Nereid> (actually there's a good reason)
17:49:13 <Nereid> tsou: no one is besides you?
17:49:35 <simon> Nereid, I think it is related to N being infinite.
17:49:37 <tsou> Nereid: you only see one ordering, the one you have in mind.  All i'm saying is that there are others.
17:49:52 <Nereid> tsou: you've been missing the context of this discussion, then.
17:50:00 <Nereid> which is "does it make sense that succ False = True?"
17:50:21 <Nereid> simon: no, it's because that's the only way to make integers ordered ring.
17:50:25 <Nereid> an ordered ring.
17:50:41 <Tehnix> is there any way to remove all packages install by cabal and start from fresh?
17:50:58 <Nereid> Tehnix: delete $/.ghc
17:50:59 <apfm> Tehnix: rm ~/.cabal/ -rf ?
17:51:01 <Nereid> ~/.ghc
17:51:03 <tsou> Nereid: I saw that, and I'm saying that for me, by default, it doesn't
17:51:09 <monochrom> yes, see my http://www.vex.net/~trebla/haskell/sicp.xhtml#remove
17:51:42 <monochrom> note that "rm -r ~/.cabal" does almost nothing
17:51:58 <Nereid> tsou: but that semantic ordering isn't internal
17:52:27 <Nereid> you can't write a program that compares _|_ and False, say
17:52:44 <Nereid> tsou: so there is a very big difference
17:53:40 <gertc> import qualified Data.Function.Pointless as P ((.:)) do you cal it like P.(.:)?
17:53:46 <Nereid> (P..:)
17:53:58 <gertc> thx
17:54:05 <Nereid> ..:)
17:54:06 <Nereid> smile
17:55:19 <tsou> Nereid: i agree that there is a very big difference...  I'm just not sure that this is a good reason to have False < True, and succ False = True
17:55:44 <Nereid> tsou: my argument is that every boolean algebra (including {False,True}) comes with an ordering
17:55:47 <Nereid> (partial ordering)
17:55:50 <mauke> enum Boolean { True, False, FileNotFound };
17:55:53 <Nereid> defined by a <= b iff a = ab
17:56:04 <Nereid> (a = a and b)
17:56:18 <Nereid> also given by implication ( a <= b iff a implies b)
17:56:25 <Nereid> and under this, False <= True.
17:56:30 <monochrom> . o O ( why can't we get along )
17:56:52 <tsou> Nereid: yes, under this :)
17:57:57 <monochrom> I see a law. When two persons both say, "look at how math does it properly", they are bound to be in great disagreement.
17:58:00 <geekosaur> can you communicate meaningfully with people using other Boolean algebras when you each don't know which rules the other(s) are using?
17:58:16 <Nereid> are there any other rules?
17:58:21 <Nereid> rule sets
17:58:37 <geekosaur> if not, then it's time to accept that there needs to be a common convention for a programming language to be usable in practice
17:58:53 <geekosaur> it happens that this convention has useful properties
17:59:04 <Nereid> as noted above, in any programming language where boolean values can be compared, one has false < true.
17:59:21 <Nereid> sounds pretty common.
17:59:51 <tsou> Nereid: thanks for reminding me of the name of the type.  I agree now :P
18:00:09 <Nereid> ok. (type?)
18:00:16 <tsou> Bool(ean)
18:00:43 <tsou> as in, it has to be a boolean algebra
18:00:47 <gertc> with this funrion does not like liftIO? close' :: MonadIO m => AcidState KeyValue -> m (); close' = liftIO (P..:) closeAcidState
18:01:08 <Nereid> gertc: it does not make sense to liftIO (P..:)
18:02:03 <shachaf> More like P..:(
18:02:04 <gertc> but it takes a parameter AcidState KeyValue does it not mean to use the .:
18:02:09 <Nereid> well, for one thing, to use an operator like P..: infix, you just write a P..: b
18:02:19 <Tehnix> monochrom: thanks, have it fixed now :)
18:02:45 <Nereid> second, closeAcidState is not a function fo two arguments
18:02:59 <Nereid> so you just want liftIO . closeAcidState
18:03:15 <shachaf> Nereid: Too easy.
18:03:55 <gertc> hmm thinking
18:03:57 <geekosaur> as written (liftIO (P..:) closeAcidState) that doesn't make much sense; you are lifting P..: into IO and the result is expected to be a function which takes coseAcidState as a parameter.  the AcidState is passed to *that*
18:04:02 <geekosaur> (the whole thing)
18:06:21 <gertc> ok this works close' = liftIO . closeAcidState but it still messes with my mind
18:06:29 <Nereid> look at the types
18:06:42 <Nereid> closeAcidState :: AcidState st -> IO ()
18:06:49 <Nereid> liftIO :: MonadIO m => IO () -> m ()
18:06:57 <Nereid> so you compose them
18:07:08 <Nereid> liftIO . closeAcidState :: MonadIO m => AcidState st -> m ()
18:07:13 <Nereid> => is not ->
18:07:42 <Nereid> in fact, you may as well ignore the "MonadIO m =>" part
18:08:10 <Nereid> (it's a typeclass constraint)
18:08:36 <Nereid> also
18:08:51 <Nereid> you can also write close' in a pointful way:
18:08:57 <Nereid> close' s = liftIO (closeAcidState s)
18:09:14 <Nereid> so if s is some AcidState st,
18:09:18 <Nereid> then closeAcidState :: IO ()
18:09:27 <Nereid> which you can then liftIO to any MonadIO.
18:09:28 <Nereid> er
18:09:32 <Nereid> closeAcidState s :: IO ()
18:10:14 <ben___> @pl hamming s1 =  sum . (zipWith (\x y -> if x /= y then 1 else 0) s1)
18:10:15 <lambdabot> hamming = (sum .) . zipWith (flip flip 0 . flip flip 1 . (if' .) . (/=))
18:10:59 <gertc> a ok this one had 2 parameters broadcast :: MonadIO m => T.Text -> [Client] -> m ()
18:11:05 <mauke> :t abs . signum .: (-)
18:11:07 <lambdabot> Num b => b -> b -> b
18:11:52 <mauke> :t fromEnum .: (/=)
18:11:54 <lambdabot> Eq a => a -> a -> Int
18:12:36 <Nereid> :t fromIntegral . fromEnum .: (/=)
18:12:37 <lambdabot> (Eq a, Integral (a -> Int), Num b) => a -> b
18:12:41 <Nereid> ergh
18:12:50 <Nereid> :t (fromIntegral . fromEnum) .: (/=)
18:12:52 <lambdabot> (Eq a, Num b) => a -> a -> b
18:13:12 <Nereid> :t (abs . signum) .: (-)
18:13:14 <lambdabot> Num b => b -> b -> b
18:14:50 <Nereid> :t signum .: (-)
18:14:51 <lambdabot> Num b => b -> b -> b
18:15:09 <Nereid> mauke: saved by NumInstances.
18:18:51 <mikeplus64> where is drop_drop# defined? (i'm reading ghc-core)
18:19:19 <shachaf> mikeplus64: Context?
18:21:02 <hpaste> mike pasted “drop_drop#?” at http://hpaste.org/77551
18:21:08 <mikeplus64> shachaf:
18:21:16 <mikeplus64> testing if it allocates a list :)
18:21:37 <mikeplus64> (it does, but it doesn't allocate the Maybe part, afaik)
18:24:15 <acowley> shachaf: Thank you for taking over ghc-core! I'm excited to have it revived.
18:24:48 <lispy> hello
18:25:01 <lispy> acowley: oh, get it working on windows please
18:25:04 <Eduard_Munteanu> ohai
18:25:06 <lispy> er wait
18:25:08 <lispy> shachaf: ^^
18:25:12 <acowley> hah!
18:25:25 <shachaf> lispy: I don't use Windows!
18:25:26 <lispy> I fail at keyboard!
18:25:28 <c_wraith> mikeplus64: it's in GHC.List
18:25:34 <mikeplus64> c_wraith: thanks
18:25:35 <shachaf> But I'll gladly take patches. :-)
18:25:43 <lispy> shachaf: boo hiss!
18:25:48 <c_wraith> mikeplus64: the implementation of drop declares a function named drop# in a where clause
18:25:49 <acowley> I wanted to use it recently, had to patch it to make it work, then I couldn't get colors working (OS X) and it tried to delete . and .. in the current directory
18:25:57 <lispy> shachaf: we need a windows build server where folks can try out things
18:25:59 <c_wraith> mikeplus64: which gets the name drop_drop# in core
18:26:05 <mikeplus64> ah
18:26:06 <shachaf> mikeplus64: It's drop = ... where drop# = ..., so it gets named drop_drop#
18:26:13 <acowley> Does haskell.org have money for an EC2 Windows instance?
18:26:15 <shachaf> Oh, what c_wraith just said.
18:26:31 <shachaf> lispy: Are there even pagers in Windows?
18:26:31 <lispy> acowley: how much are those?
18:26:44 <lispy> shachaf: I have mingw so I get less
18:26:55 <shachaf> haskell.org has money?
18:26:57 <lispy> shachaf: Sadly, you pretty much have to assume mingw
18:26:59 <lispy> yes
18:27:04 <shachaf> Weird.
18:27:05 <luite> can't ms research get some azure instances for that?
18:27:12 <acowley> lispy: http://aws.amazon.com/windows/
18:27:17 <lispy> shachaf: Most of the money comes from GSoC.
18:27:41 <Eduard_Munteanu> So you don't pay the mentors the $500 (?)? :)
18:28:31 <luite> they should pay me for hosting hdiff and a hackage mirror!
18:29:07 <lispy> what is hdiff and what is this hackage mirror?
18:29:18 <luite> http://hdiff.luite.com/
18:29:21 <shachaf> lispy: They are one and the same!
18:29:48 <lispy> luite: Maybe this should be at hdiff.haskell.org?
18:29:49 <acowley> luite saves the day when hackage goes kaput
18:30:17 <lispy> luite: Or at least, accessibly via that domain name
18:30:21 <luite> lispy: point the subdomain to the same ip if you want, i'll adjust teh http config
18:30:22 <acowley> Once when I was traveling internationally, haskell.org was blocked and luite saved my bacon
18:30:49 <lispy> luite: I don't have such authority, but I'll try to figure out who does. I suspect it's Igloo
18:30:50 <mikeplus64> acowley: what monstrous place would block haskell.org?!
18:31:05 <acowley> Well, I don't know who was responsible. I was in China, and lots of things were blocked.
18:31:41 <luite> i'm happy to hear that i'm less of a threat to china than haskell!
18:31:42 <mikeplus64> when i was in china few weeks ago haskell.org was working
18:31:43 <Eduard_Munteanu> I guess in communist China, government is the fascist type system.
18:31:45 <mikeplus64> maybe they changed their mind
18:31:47 <lispy> AFAICT, when in china you can be blocked either side. I know lots of companies will blacklist ips from china.
18:32:32 <luite> baidu is by far the most active hdiff visitor :)
18:32:34 <acowley> Yeah, I'm not pointing any fingers. I just remember desperately trying luite's mirror and getting things going for a demo the next day.
18:32:55 <acowley> Maybe a hotel chain has an anti-haskell agenda
18:33:16 <luite> you booked one of those cheap php hotels right?
18:33:59 <apfm> How are you guys creating slides with pictures for your presentations? I'm tired of tex → pdf, tex is overkill
18:34:13 <Eduard_Munteanu> But then they should be glad to allow a mediawiki-powered website :)
18:35:00 <geekosaur> someone had downloaded an encryption package?
18:35:27 <luite> hm, do they block that? hackage does have some crypto of course
18:35:33 <Eduard_Munteanu> apfm: mm, maybe you can use Libreoffice or something equivalent to Powerpoint, if you don't like LaTeX.
18:35:49 <acowley> apfm: I've used Keynote the past few years. I'm not proud.
18:35:58 <acowley> apfm: You could try Racket's slideshow language
18:36:08 <acowley> I've used that for a talk before, but only the once
18:36:14 <otters> keynote is pretty good
18:36:38 <apfm> Eduard_Munteanu: well, libreoffice is just an tool, not a markup language
18:36:52 <apfm> I'm fine with my vim and don't wanna use something else
18:38:16 <acowley> I am surprised there aren't more slideshow-focused languages.
18:38:20 <apfm> I've tried pandoc with beamer, but there is some cyrillic problem
18:40:57 <Nereid> acowley: write a slideshow EDSL in haskell!
18:41:11 <acowley> Nereid: I was hoping someone else would volunteer :/
18:41:14 <Nereid> haha
18:41:22 <apfm> Sure
18:41:43 <acowley> It doesn't sound like a very reward project, to be honest. Lots of awkwardness, lack of portability, etc.
18:41:47 <apfm> Let's hope together
18:41:50 <acowley> s/reward/rewarding
18:42:10 <Nereid> actually I wish TeX was not so annoying to work in.
18:42:27 <Eduard_Munteanu> Yeah, I wish there were viable alternatives.
18:42:46 <acowley> TeX is glorious!
18:43:06 <apfm> TeX is not so annoying, but if you create another presentation twice a year - you just copy and paste from the previous one, not creating something new
18:43:13 <acowley> The power of TeX is best experienced when you contemplate writing a TeX competitor.
18:43:28 <Nereid> don't do that, write another language that compiles to TeX.
18:43:35 <Nereid> :v
18:43:57 <apfm> I mean, tex is really fast-forgetible, markdown is super-intuitive
18:44:07 <acowley> I bet if you did that the TeX escape hatch you provide in your language would be its most-used feature.
18:44:15 <Nereid> haha
18:44:21 <acowley> Yeah, I write a few papers a year and have to relearn TeX every time.
18:45:15 <Nereid> I use it pretty regularly so it's not like I find it difficult or anything, but little things always bother me.
18:45:58 <apfm> It's not hard, it's heavy
18:46:39 <apfm> acowley: could I use unicode symbols in racket slideshow?
18:46:43 <acowley> Oh yes, don't get me wrong, when I said "glorious" I was assuming we've all actually used TeX: TeX is absurdly baroque and arguably badly designed.
18:46:47 <acowley> apfm: Yes!
18:47:06 <apfm> Without any escaping or $#01941; stuff?
18:47:21 <acowley> Right
18:47:30 <acowley> They have a pseudo tex input method in DrRacket
18:47:43 <acowley> which happily takes in the usual greek characters
18:48:17 <apfm> So for α I could write α instead of $\alpha$ ?
18:48:20 <acowley> If Racket were Haskell, slideshow would be exactly the answer you're looking for.
18:48:42 <acowley> apfm: I believe so, but I am not an authority.
18:49:01 <acowley> apfm: When I used it, I had no problems with characters.
18:49:31 <apfm> Maybe there are some must-read links about that except http://docs.racket-lang.org/slideshow/index.html ?
18:51:19 <acowley> apfm: There's the paper they link, but I don't know of anything beyond that
18:51:50 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/Main.hs should i use conduit for the incoming websocket data or does the websocket it self do the conduit stuff?
18:55:26 <amalloy> does haskell have something like a hash table? i'm aware of Data.Map, but it requires Ord on its keys and is O(log2(n)) for most operations; it would be nice to have something like clojure's PersistentHashMap, which only requires the keys be hashable and takes O(log32(n))
18:57:06 <Eduard_Munteanu> @hoogle hashmap
18:57:06 <lambdabot> package hashmap
18:57:16 <Eduard_Munteanu> @hackage hashmap
18:57:17 <lambdabot> http://hackage.haskell.org/package/hashmap
18:59:13 <luite> IntSet can also be useful if you has Int keys
18:59:14 <luite> have
18:59:19 <amalloy> sweet, thanks. i started trying to implement it myself as an exercise; it will be interesting to see the right way around all the problems i was having
18:59:20 <luite> IntMap
18:59:30 <luite> uses a trie
19:06:23 <gertc> should i use conduit in combination with websockets?
19:07:12 <ivanm> amalloy: note that IntMap might not be as good as "Map Int" if you get the size of the Map a lot, as for IntMap it's O(n) rather than O(1)
19:08:12 <Nereid> although you could wrap an IntMap to store its size on the side if you really had to
19:08:48 <amalloy> ivanm: i'm not really planning to use either of them at the moment, just trying to explore how Hashable fits into the type system. i had a go at defining a simple Hashable myself and ran into all kinds of problems
19:09:09 <ivanm> Nereid: true, though you'd have to be careful with various functions (M.merge, etc.)
19:10:17 <Nereid> yeah those would become somewhat more expensive
19:10:23 <Nereid> so there'd be some tradeoff
19:15:18 <ivanm> I think that's why my attempt at using Data.IntMap was slightly less performant than Data.Map (even without the caching of the size)
19:24:13 <bxx> is there a nicer way to write this, without a lambda?  (\x -> mod x 3 == 0)
19:24:46 <bxx> (I'd like to see it even if it isn't nicer :) )
19:25:00 <sclv> @pl \x -> mod x 3 == 0
19:25:00 <lambdabot> (0 ==) . flip mod 3
19:25:13 <copumpkin> (0 ==) . (`mod` 3)
19:25:43 <bxx> I want offline functionality of that bot
19:25:46 <gertc> what is the pl thing?
19:25:49 <sclv> you can
19:25:52 <gertc> hlint?
19:25:55 <sclv> cabal install pointless i think
19:26:19 <sclv> pl is "pointless" -- it renders arbitrary expressions pointfree
19:26:30 <sclv> originally an augustuss project as i recall
19:27:01 <sclv> when i was getting started with haskell i went overboard with it
19:27:37 <otters> you kinda figure out how to write it without using the plugin
19:27:42 <otters> and then you realize you don't really need or want to dothat
19:28:13 <gertc> but there are no points in (\x -> mod x 3 == 0) ? :)
19:28:16 <Taslem> I'm trying to make a roguelike on the terminal. The issue I'm running into is that it sort of "flickers" when strings/chars are printed to it. Is there a way to force the whole terminal to update simultaneously?
19:29:11 <cmccann> here's where @pl is from: http://hackage.haskell.org/package/pointfree
19:30:03 <cmccann> don't think that was augustss though, maybe you're thinking of http://hackage.haskell.org/package/djinn
19:30:10 <cmccann> which is also great
19:31:24 * hackagebot hsc3-rec 0.12 - Haskell SuperCollider Record Variants  http://hackage.haskell.org/package/hsc3-rec-0.12 (RohanDrape)
19:31:26 * hackagebot hsc3-sf 0.12 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-0.12 (RohanDrape)
19:32:39 <sclv> cmccann: you're right, thanks for clearing that up
19:33:01 <bxx> how about the entire functionality of a bot as an offline program, is it available?
19:33:12 <sclv> that's the link cmccann just gave
19:33:18 <sclv> oh, wait that's just pkl
19:33:22 <bxx> yes
19:33:30 <cmccann> you can run lambdabot locally as well
19:33:36 <cmccann> but last I heard it's tricky to get working
19:33:37 <amalloy> gertc: the parameter x is a point
19:33:45 <cmccann> lambdabot is kind of... antique these days
19:33:49 <sclv> there was a project called ghc on acid that integrated \bot into ghci too, but i think it really bitrotted
19:33:58 <gertc> a ok i found this https://github.com/benmachine/pointfree
19:34:16 <gertc> er this http://www.haskell.org/haskellwiki/Pointfree
19:34:50 <sclv> the only other cute \bot trick that i wouldn't mind in an executable is @undo
19:36:54 <sclv> oh, and @free, but I think that's around somewhere
19:37:45 <gertc> sugest changing the name to point style because there are more actully . in point free style :)
19:38:06 <latro`a> eurm
19:38:07 <latro`a> *erm
19:38:11 <latro`a> that's not the sense of "point" that is meant
19:39:31 <gertc> point as in a c pointer to a memory adress?
19:39:47 <amalloy> point as in a named local value
19:39:53 <latro`a> yeah
19:40:00 <latro`a> what amalloy said
19:40:50 <latro`a> it's similar to notions from mathematics where we deal only with collections of objects and functions on objects without reference to the objects themselves
19:41:04 <Taslem> Anyone know how to fix tearing/print delay on the terminal?
19:42:03 <gertc> if you do not know math in haskell you are so screwed...
19:42:13 <latro`a> nah
19:42:37 <latro`a> it is actually somewhat irritating when conventions in haskell and FP in general differ from their mathematical counterparts
19:42:40 <latro`a> or vice versa
19:43:07 <amalloy> Taslem: i imagine there's a haskell lib that links with something like ncurses. are you using that, or treating the terminal as a stream of characters?
19:43:12 <latro`a> monads are a big example of this; in particular we only occasionally get a meaningful comonad from a monad because usually the comonad is on a different category from Hask
19:43:17 <latro`a> which isn't what Monad (with a capital M) means
19:43:30 <latro`a> erm, isn't what Comonad (with a capital C) means
19:43:36 <Taslem> amalloy: I am using a System.Console.ANSI which is a hybrid between something like curses/character stream
19:44:35 <Taslem> Basically you get a fancy new "print string" function + text color + cursor location + title changer etc. misc.
19:44:50 <Taslem> Do you think I should go with ncurses instead?
19:44:55 <geekosaur> at a guess, output is line buffered but you're using cursor positioning instead of newlines.
19:45:07 <geekosaur> :t hSetBuffering
19:45:09 <lambdabot> Not in scope: `hSetBuffering'
19:45:11 <geekosaur> bah
19:45:28 <Taslem> I have stdout set to NoBuffering already.
19:45:39 <Taslem> It's possible that that is broken on Windows. I know it's broken for stdin
19:46:24 * hackagebot hsc3-unsafe 0.12 - Unsafe Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-unsafe-0.12 (RohanDrape)
19:48:34 <gertc> any conduit salesman online?
19:48:46 <johnw>  what issues are you facing with conduit?
19:48:59 <gertc> nothing just want to know if i need it :)
19:49:14 <johnw> if you don't need timely resource closure, just go with lazy streams
19:49:15 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/Main.hs
19:49:42 <gertc> i only use wbsockets
19:49:50 <johnw> do you use tons of them concurrently?
19:50:15 <gertc> is kind of a webserver so i guess maybe ?
19:50:26 <Taslem> amalloy: Do you know what that library is called?
19:50:26 <johnw> then you may actually want conduits
19:50:39 <johnw> conduits give you determinstic resource deallocation when the stream is no longer needed
19:51:03 <johnw> as in, you can be more certain that unused sockets are not left open for longer than they need to be
19:51:07 <amalloy> Taslem: no, i'm fairly useless; just wanted to make sure you weren't trying to do all this work by just outputting 80*24 characters every tick
19:51:23 <johnw> and likewise in the presence of exceptions during stream processing
19:51:26 * hackagebot hsc3-plot 0.12 - Haskell SuperCollider Plotting  http://hackage.haskell.org/package/hsc3-plot-0.12 (RohanDrape)
19:51:36 <gertc> but does websockets already does that job of closing conections ?
19:51:44 <johnw> sure
19:51:47 <johnw> but *when* is the question
19:51:58 <gertc> aha good point
19:52:27 <johnw> if you use a regular lazy stream, you are dependent on whenever the garbage collector decides to finalize the socket handle
19:52:40 <johnw> otherwise, you have to wrap stuff in `bracket' and close the socket yourself
19:53:13 <johnw> conduits abstract the eager closing of resources
19:55:19 <gertc> WS.WebSockets WS.Hybi10 is just a protoclo inplementaion right? no eager closing stuff in it right?
19:55:39 <johnw> can you give me a link to the documentation?
19:55:44 <gertc> yes
19:56:03 <gertc> http://hackage.haskell.org/package/websockets-0.6.0.3
19:57:05 <johnw> when the docs start with "Get an enumerator/iteratee pair from your favorite web server", that indicates to me they are thinking about resources
19:57:22 <johnw> because that's one of the key problems solved by enumerators/iteratees
19:57:37 <gertc> aha i uses happstack
19:58:02 <gertc> so the webserver is actually doing the conduit part
19:58:15 <gertc> and haspstack need http conduit :)
19:58:16 <johnw> from my cursory glance I would say so
19:58:30 <johnw> http-conduit uses conduit, yeah
19:58:40 <johnw> websockets uses the enumerator library
19:58:59 <gertc> a ok thats somthing els then
19:59:02 <johnw> if you read here: http://hackage.haskell.org/package/enumerator-0.4.19
19:59:09 <johnw> it talks about the exact same resource thing I was describing
19:59:19 <johnw> "However, lazy I/O has several shortcomings. Most notably, resources such as memory and file handles can be retained for arbitrarily long periods of time, causing unpredictable performance and error conditions."
19:59:27 <johnw> so, it's another conduit analogue
20:01:04 <gertc> ok so i need conduit
20:01:13 <gertc> if using lazy stuff
20:01:29 <johnw> for a highly concurrent webserver, I'd strongly recommend it from what I've read
20:01:46 <luite> happstack itself does not use enumerators yet
20:01:46 <johnw> otherwise, you're performance characteristics under load will be unpredictable
20:02:06 <luite> i thought it also didn't support websockets, but i might be wrong :)
20:03:07 <gertc> yea you are right i was wrong i only use it for static files :)
20:03:50 <sclv> johnw: it is possible to write lazyio code with predictable performance characteristics. it is just tricky.
20:04:04 <sclv> whether it is more or less tricky than enumerator is another issue
20:04:12 <sclv> but another approach is just do do strict, chunked io
20:04:28 <Nereid> lazy IO is downright scary.
20:04:37 <johnw> sure, enumerators themselves are one of those ways :)
20:04:46 <johnw> lazy IO is magical!
20:04:52 <Nereid> magic is scary
20:04:58 <johnw> that's what makes it coll
20:05:00 <johnw> cool
20:05:06 <Nereid> no, lazy IO isn't cool.
20:05:06 <gertc> yea but the sombody upload a hd movie and my server dies
20:05:24 <Nereid> open a file
20:05:27 <sclv> that's not a problem with lazy io
20:05:28 <johnw> that's why he said "strict, chunked"
20:05:30 <Nereid> bind something to hGetContents
20:05:32 <Nereid> close the handle
20:05:36 <Nereid> try to read that string now
20:05:38 <Nereid> whoops!
20:05:44 <sclv> so don't do that then
20:05:55 <Nereid> I shouldn't be able to do that.
20:06:13 <sclv> and you're not!
20:06:14 <gertc> a i forgot strickt chunks
20:06:14 <sclv> it breaks!
20:06:22 <Nereid> but I can still write the code and it compiles!
20:06:30 <gertc> indeed that solves everything
20:06:32 <sclv> i can write code that reformats my hard drive
20:06:54 <Nereid> my point is that lazy IO is scary.
20:07:03 <sclv> no it isn't
20:07:09 <sclv> you're just scaring people about it
20:07:14 <Nereid> I know.
20:08:06 <Nereid> strict chunked IO. with conduits/pipes/enumerators/iteratees/whatever.
20:09:01 <Nereid> anyway
20:09:04 <Nereid> it's still a problem.
20:09:10 <archeyDevil> http://ix.io/3mu
20:09:16 <Nereid> I pass what I get from hGetContents to something else
20:09:22 <Nereid> I don't know when it'll do what
20:09:27 <Nereid> but at some point I want to close the handle
20:09:53 <archeyDevil> Anyone here understand what this error means when it comes to installing hpodder- I don't see why HaXml doesn't want to compile?
20:10:00 <Nereid> but I can't do that unless I'm sure that something else is completely done with what I pass it
20:10:27 <sclv> so don't use hGetContents then without managing the consumer of it
20:10:42 <Nereid> indeed.
20:10:50 <sclv> and you don't need conduits or anything else to do strict chunked io
20:10:56 <sclv> you can just write it on the raw io layer
20:11:06 <Nereid> but that's annoying.
20:11:13 <Nereid> where did the abstraction go.
20:11:25 * hackagebot ghc-core 0.5.5 - Display GHC's core and assembly output in a pager  http://hackage.haskell.org/package/ghc-core-0.5.5 (ShachafBenKiki)
20:11:30 <sclv> abstraction, predictability, control. pick two.
20:11:53 <Nereid> or use conduits and pick all three?
20:11:57 <archeyDevil> @src hpodder
20:11:58 <lambdabot> Source not found. My brain just exploded
20:12:03 <archeyDevil> Lol
20:12:13 <gertc> ok so in stricked chuncked everything get closed as soon as possible anyway?
20:12:24 <Nereid> anyway, whatever
20:12:32 <sclv> archeyDevil: eek. that version of haxml looks old
20:12:43 <sclv> i'd check whether hpodder has an upper bound on the haxml it uses
20:12:49 <sclv> and see if you can remove it
20:12:51 <Nereid> @hackage hpodder
20:12:51 <lambdabot> http://hackage.haskell.org/package/hpodder
20:12:53 <archeyDevil> sclv: I've updated?
20:13:02 <Nereid> yup it does
20:13:17 <Nereid> and it's unmaintained
20:13:34 <sclv> just cabal fetch it, fix the dep, and try to install
20:13:36 <sclv> i bet it works
20:13:40 <Nereid> if you're lucky
20:13:54 <sclv> also what makes you think that hpodder is unmaintained?
20:14:01 <Nereid> "John Goerzen no longer listens to podcasts, and doesn’t have much time to maintain this software. A new maintainer is being sought. In the interim, well-tested patches may still be applied but there isn’t enough time for anything else."
20:14:08 <Nereid> sounds pretty unmaintained to me.
20:14:11 <sclv> that's not unmaintained
20:14:18 <sclv> that's not under active development
20:14:37 <sclv> like if you ask him to fix the bitrot he probably will
20:14:38 <Nereid> ok, the last commit was 9 months ago.
20:14:41 <Nereid> :p
20:14:41 <sclv> yes
20:14:53 <sclv> because probably nobody told him there was bitrot
20:14:58 <archeyDevil> sclv: I'm somewhat new to haskell.... Never compiled a package manually.
20:15:05 <sclv> i have packages i don't use and don't actively update on hackage
20:15:06 <archeyDevil> What file to edit to fix the dep?
20:15:09 <sclv> that haven't been updated for years
20:15:15 <sclv> or even that i do use and haven't been updated
20:15:17 <Nereid> archeyDevil: cabal unpack it, edit the cabal file, and then cabal install from there
20:15:18 <sclv> because they still work
20:15:27 <gertc> what is the best chunked strickt webserver for static files?
20:15:49 <archeyDevil> Nereid: Which file?
20:15:54 <Nereid> the .cabal file
20:15:59 <Nereid> inside wherever you unpacked it
20:16:15 <Nereid> has a build-depends haxml-1.20.* somewhere
20:16:24 <Nereid> er, haxml == 1.20.*
20:16:28 <archeyDevil> no .cabal file....
20:16:32 <Nereid> what?
20:16:44 <archeyDevil> There is no .cabal
20:16:48 <archeyDevil> oh hpodder.cabal?
20:16:48 <Nereid> cabal unpack hpodder
20:16:51 <Nereid> yes
20:17:01 * archeyDevil read it as just ".cabal"
20:17:03 <archeyDevil> lol
20:17:21 <Nereid> ok
20:17:28 <Nereid> so it says HaXml >= 1.20 && < 1.21
20:17:38 <Nereid> change that to just HaXml >= 1.20
20:17:41 <Nereid> and see if it still builds
20:17:47 <Nereid> (run "cabal install" from that directory)
20:18:35 <archeyDevil> Seems to be working
20:18:42 <archeyDevil> But can't know if it's gonna compile
20:18:52 <archeyDevil> HaXml is working away
20:19:13 <Nereid> sure, haxml should build fine. the question is whether hpodder still builds against the newer haxml
20:19:35 <archeyDevil> I know. Just said that HaXml hasn't had any errors compiling :P
20:19:41 <archeyDevil> (yet)
20:21:17 <Nereid> and if it all works, let jgoerzen know :p
20:21:33 <archeyDevil> How to?
20:21:39 <archeyDevil> Email address in cabal file?
20:22:10 <Nereid> I guess
20:22:24 <archeyDevil> Okay
20:22:33 <archeyDevil> I might email him ^_^
20:27:26 <archeyDevil> Build fail :(
20:27:30 <archeyDevil> Utils.hs:82:8: Not in scope: `catch'
20:27:33 <archeyDevil> Utils.hs:123:21: Not in scope: `catch'
20:27:35 <archeyDevil> Failed to install hpodder-1.1.6
20:27:47 <archeyDevil>  
20:29:18 <archeyDevil> Nereid: :(
20:31:13 <sclv> archeyDevil: blah. needs to be updated to work with the new exceptions library
20:31:33 <jimch> LYAH tutorial implemented maximum with foldr. wouldn't it be better to implement it with foldl?
20:31:39 <sclv> the quick fix i bet is to import the Control.OldExceptions library at the top of that file
20:31:48 <sclv> but it might need a bit more attention
20:32:04 <archeyDevil> the util file.. just add import Control.OldExceptions ?
20:32:16 <sclv> OldException
20:32:18 <monochrom> foldl isn't much better than foldr for this
20:32:22 <sclv> not sure that'll work
20:32:23 <archeyDevil> import Control.OldExceptions
20:32:23 <archeyDevil> import Control.Exception(finally)
20:32:29 <archeyDevil> sclv: Both together?
20:32:38 <sclv> erm i don't think so
20:32:48 <archeyDevil> (finally) copy that to the old?
20:32:59 <jimch> monochrom: well we avoid iterating the list twice, no?
20:33:02 <sclv> actually maybe you should just import catch from Control.Exception and ignore my other advie
20:33:12 <monochrom> neither iterates the list twice
20:33:31 <archeyDevil>    45 import Control.Exception (finally catch)
20:33:32 <archeyDevil> ?
20:33:37 <sclv> finally, catch
20:33:41 <jimch> monochrom: how so when foldr has to start from the end?
20:34:01 <archeyDevil> cabal install. waiting
20:34:02 <archeyDevil> Naww
20:34:05 <monochrom> foldr does not start from the end. you just imagine so
20:34:13 <latro`a> foldr does not really "start from the end", but yes, since you *must* traverse the whole list foldl' is ideal
20:34:16 <archeyDevil> http://ix.io/3mv
20:34:18 <sclv> fixing something like this isn't hard, but if you're still working on getting import syntax right, maybe its a bit much...
20:34:23 <archeyDevil> sclv: What you think now? :'(
20:34:25 <jimch> huh? i imagined it?
20:34:35 <monochrom> latro`a, the comparison is with foldl, not foldl'
20:34:48 <latro`a> in comparing with foldl it makes basically no difference
20:34:51 <sclv> archeyDevil: aha now switch to OldException
20:34:56 <latro`a> but yes, jimch, foldr does not actually proceed from the right
20:35:00 <monochrom> precisely what I say
20:35:28 <archeyDevil> sclv: lolk
20:35:40 <latro`a> it can be thought of as doing so if the folding function is strict, but even then that is observational semantics rather than denotational semantics
20:35:53 <archeyDevil>     Could not find module `Control.OldException'
20:35:55 <gertc> damit websockets do not send chunked packages guess i need conduit http://stackoverflow.com/questions/13010354/chunking-websocket-transmission
20:35:56 <archeyDevil> lol
20:36:02 <jimch> latro`a: not getting it.
20:36:08 <monochrom> > foldr (||) True (repeat False)
20:36:13 <lambdabot>   mueval-core: Time limit exceeded
20:36:23 <monochrom> oh, typo
20:36:40 <archeyDevil> sclv: Where to get OldException?
20:36:43 <cinolt> Sup dawgs. I'm a beginner using GHCi. I'm trying to use the map function with Char.toUpper, but this jawn ain't lettin' me do dis. This is what I input (map Char.toUpper "hi") without parentheses. It says (Failed to load interface for 'Char') wat do?
20:36:43 <monochrom> > True || False
20:36:45 <lambdabot>   True
20:37:11 <latro`a> jimch: the recursive case in the definition of foldr is a call to f, with a recursive call to foldr only in one of the arguments
20:37:12 <monochrom> > foldr (||) True (repeat True)
20:37:13 <lambdabot>   True
20:37:14 <archeyDevil> > False && True || False
20:37:16 <lambdabot>   False
20:37:24 <cinolt> Dawgs, how you gon' ignore muh ass like that
20:37:28 <monochrom> does not start from the end. (infinite list, no end)
20:37:28 <archeyDevil> > False || True && False
20:37:28 <cinolt> I'm asking a simpleass question dawg
20:37:30 <lambdabot>   False
20:37:37 <archeyDevil> > False || True || False
20:37:38 <lambdabot>   True
20:37:44 <latro`a> this means that if f is not strict, you can do things like what monochrom just did
20:37:54 <cinolt> How you gon' play a brotha like that?
20:37:56 <archeyDevil> > False || True || False && True || False && True
20:37:57 <latro`a> if it is strict then an infinite list will never terminate
20:37:58 <lambdabot>   True
20:38:04 * archeyDevil is bored. :(
20:38:11 <cinolt> Then answer my question.
20:38:13 <archeyDevil> sclv: Any suggestions to hpodder?
20:38:13 <Eduard_Munteanu> cinolt: yo ass should be waitin' for an answah, dawg.
20:38:45 <cinolt> I'm pretty sure it's a simpleass solution, it's just a matter that I don't know it and you experienced people do.
20:38:52 <cinolt> Google didn't come up with anything obvious.
20:39:00 <sclv> archeyDevil: they got rid of oldexpression in the last base
20:39:04 <sclv> your ghc must be bleeding edge
20:39:07 <sclv> not sure where it is on hackage
20:39:11 <monochrom> I don't understand "jawn"
20:39:22 <cinolt> Neither do you know how to spell "monochrome"
20:39:27 <cinolt> biyatch
20:39:32 <sclv> the other thing to do is to switch it to use the normal new standard exception library
20:39:35 <sclv> @where ops
20:39:35 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
20:39:50 <cinolt> Imperialist English only plz
20:39:55 --- mode: ChanServ set +o monochrom
20:40:00 --- mode: monochrom set +b *!*@gateway/web/freenode/ip.66.71.87.158
20:40:00 --- kick: cinolt was kicked by monochrom (cinolt)
20:40:05 --- mode: monochrom set -o monochrom
20:40:05 <johnw> thank you
20:40:07 <archeyDevil> sclv: bleeding edge as archlinux :|
20:40:08 <archeyDevil> haha
20:40:42 <latro`a> his question was reasonable now that I think about it >.>
20:40:55 <latro`a> not sure why he thought it was called Char.toUpper, however
20:40:57 <sclv> archeyDevil: the "right thing" is to make it work with new exceptions
20:41:01 <monochrom> he started insulted people
20:41:05 <sclv> which means giving explicit types to the catch stuff
20:41:11 <latro`a> yes, he did
20:41:14 <latro`a> I agree with the decision
20:41:18 <latro`a> but still, was a reasonable question
20:41:29 <Eduard_Munteanu> Informed troll :).
20:41:32 <jimch> foldr goes from the end if passed function is strict?
20:41:39 <monochrom> there is limited resource in the world. some questions will be missed
20:41:39 <archeyDevil> sclv: Can you please patch?
20:41:44 * archeyDevil doesn't know enough haskell. :(
20:41:57 <lispy> > foldr (+) z [a,b,c,d]
20:41:58 <lambdabot>   a + (b + (c + (d + z)))
20:42:02 <lispy> jimch: ^^
20:42:02 <sclv> sorry, too late for me to do even light hacking tonight :-(
20:42:19 <sclv> a polite friendly note to jgoerzen would probably be fine
20:42:20 <Eduard_Munteanu> jimch: no, but the function will force that whole thunk
20:42:28 <sclv> but he may take a while to get to it
20:42:32 <Eduard_Munteanu> If strict.
20:42:37 <jimch> ok I am confused as hell now
20:42:43 <monochrom> a*(b*c) does not mean "start with b*c first". 0*(9389304*3908234), do you start with 9389304*3908234 first?
20:43:17 <lispy> > foldl (+) z [a,b,c,d]
20:43:18 <lambdabot>   z + a + b + c + d
20:43:23 <lispy> does that help at all?
20:43:27 <Nereid> (((z + a) + b) + c) + d
20:43:57 <monochrom> instead, foldr (||) x [True, ...] = True || foldr (||) x [...] = True, you don't even get to see more elements of the list
20:44:18 <johnw> > foldr (*) 0 [1..]
20:44:20 <lambdabot>   *Exception: stack overflow
20:44:27 <Nereid> > foldl' (*) 0 [1..]
20:44:30 <monochrom> well, our * is not as smart as ||
20:44:31 <lambdabot>   mueval-core: Time limit exceeded
20:44:32 <archeyDevil> sclv: Thanks anyway..
20:44:36 <Nereid> * is strict in both arguments
20:44:37 <archeyDevil> Anyone else mind patching for me?
20:44:38 <johnw> well, that isn't what I expected
20:44:43 <johnw> oh
20:44:47 <johnw> then I guess it is
20:45:02 <johnw> funny, I'd think * wouldn't be, just for this reason
20:45:14 <monochrom> but you, as human, does not start with 9389304*3908234 first
20:45:23 <Nereid> johnw: well, you could write your own instance of Num where it isn't
20:45:38 <Nereid> but * on Integers is always strict
20:45:46 <monochrom> my first point is, even for humans, a*(b*c) does not mean start with b*c
20:45:51 <Eduard_Munteanu> jimch: if your function is strict, you most likely want to use foldl'.
20:46:16 <Eduard_Munteanu> jimch: foldr is nice when your function can lazily produce intermediate results.
20:46:32 <monochrom> if you don't even start with b*c yourself, then "foldr starts from the end" comes from nowhere
20:46:43 <Nereid> > foldr (\x:xs -> x:x:xs) [] [1..]
20:46:45 <lambdabot>   <hint>:1:10: parse error on input `:'
20:46:49 <Nereid> > foldr (\(x:xs) -> x:x:xs) [] [1..]
20:46:50 <lambdabot>   Couldn't match expected type `b0 -> b0' with actual type `[a0]'
20:46:58 <Nereid> oops.
20:47:00 <monochrom> anyway, all confusions come from making wrong assumptions and facing facts
20:47:01 <Nereid> > foldr (\x xs -> x:x:xs) [] [1..]
20:47:02 <lambdabot>   [1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,14,14,15,15,16...
20:47:27 <lispy> I guess you could argue that foldr doesn't know anything about evaluating the list or result. It's really up to the consumer to "need" part of it.
20:47:40 <monochrom> consider either retracting assumptions or retracting facts
20:47:52 <Jafet> lispy: it's all a series of tubes
20:48:03 <jimch> i know what foldr does. i am just not sure how you would implement it without staring from the end. and if tou start from the end you have to iterate the list twicegoing through the list twice
20:48:22 <monochrom> @src foldr
20:48:22 <jimch> sorry for repeating
20:48:23 <lambdabot> foldr f z []     = z
20:48:23 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:48:35 <monochrom> that source code still doesn't say "start from the end"
20:48:37 <Jafet> @where stepeval
20:48:37 <lambdabot> http://www.srcf.ucam.org/~bm380/cgi-bin/stepeval.cgi
20:49:13 <Jafet> http://bm380.user.srcf.net/cgi-bin/stepeval.cgi?expr=foldr+%28%2B%29+0+[1%2C2%2C3%2C4]
20:50:40 <jmcarthur> jimch: take the second line from the definition   f x (foldr f z xs)  ... the first thing that will be evaluated in ghc is  f <something> <something>  . keep in mind that the somethings are not necessarily evaluated yet.
20:50:49 <monochrom> don't be too fast in asserting that you know what foldr does
20:51:02 <jimch> it actually starts from the end, we recurse until the last element before we do anything else. or am i missing something?
20:51:17 <johnw> it's right associative, not that it starts from the end
20:51:18 <monochrom> your description is flawed
20:51:20 <Nereid> jimch: evaluating f x y doesn't necessarily evalate x and y first.
20:51:20 <jmcarthur> jimch: so if f is lazy in its second argument (the second <something> isn't evaluated) then there is no need to go to the end first
20:51:27 <johnw> foldr (:) [] [1..] does not "start at the end"
20:51:54 <monochrom> explain why foldr (||) True (repeat True) is not an infinite loop. then maybe you do know what foldr does
20:52:35 <johnw> because || isn't strict in its arguments, but I'm not sure if that's the nuance you're aiming for
20:52:38 <jimch> monochrom: how is it flawed? second argument to f is recursion, which keeps recursing until xs is []
20:52:42 <applicative> archeyDevil: did you figure out the hpodder trouble?
20:52:48 <johnw> jimch: keep laziness in mind
20:53:00 <jmcarthur> jimch: the recursive application of foldr is *lazily* applied
20:53:01 <monochrom> where is [] in (repeat True)?
20:53:15 <johnw> the second argument isn't evaluated unless it's value is needed
20:53:18 <tsou> where are those fold-related figures Cale posted recently when you need them? :P
20:53:24 <monochrom> explain why foldr (||) True (repeat True) is not an infinite loop. (repeat True) does not have []
20:53:42 <jmcarthur> > last (repeat True)
20:53:47 <lambdabot>   mueval: ExitFailure 1
20:53:47 <lambdabot>  mueval: Prelude.undefined
20:53:55 <jmcarthur> > foldr (||) True (repeat True)
20:53:56 <lambdabot>   True
20:54:01 <jimch> ok. so if the second argument has to be evaluated does foldr recurse until []?
20:54:14 <archeyDevil> applicative: Exception module update broke hpodder :(
20:54:19 <monochrom> then yes
20:54:24 <johnw> yep
20:54:33 <jmcarthur> if f is strict in the second argument then yes, evaluation will proceed to the end of the list
20:54:41 <jimch> and max has to evaluate both arguments, no?
20:54:47 <johnw> jimch: another way of saying that is, "if f is strict in its second argument"
20:54:49 <monochrom> usually
20:54:56 <johnw> heh
20:54:56 <archeyDevil> applicative: Could you manage to patch hpodder so it supports the new Exception module?
20:55:05 <archeyDevil> Seems to be just the catch function
20:55:19 <jimch> so how is maximum not better implemented with foldl instead of foldr?
20:55:20 <jmcarthur> jimch: max can have a lazily implementation for some types
20:55:25 <jmcarthur> *lazy
20:55:33 <jmcarthur> @src maximum
20:55:33 <lambdabot> maximum [] = undefined
20:55:34 <lambdabot> maximum xs = foldl1 max xs
20:55:39 <jmcarthur> it's a left fold
20:55:48 <monochrom> > foldr max True (repeat True)
20:55:50 <lambdabot>   *Exception: stack overflow
20:55:54 <monochrom> too bad
20:55:56 <applicative> archeyDevil: it was trying to install an ancient haxml this will cause trouble
20:56:00 <Nereid> > max True undefined
20:56:02 <lambdabot>   *Exception: Prelude.undefined
20:56:03 <Nereid> > max undefined True
20:56:05 <lambdabot>   *Exception: Prelude.undefined
20:56:06 <Nereid> aw.
20:56:16 <Nereid> dumb derived Ord instances
20:56:45 <monochrom> because max for Bool is so close to (||) :)
20:57:01 <jimch> as far as i can see using foldl to implement maximum is more efficient (that is what started this whole discussion, LYAH tutorial implemented maximum with foldr)
20:57:16 <applicative> archeyDevil: I see it's the Prelude catch nonsense
20:57:22 <monochrom> you see wrong. foldl is not more efficient
20:57:40 <jmcarthur> jimch: consider this definition of natural numbers and max:   data Nat = Z | S Nat;  S m `max` S n = S (m `max` n); m `max` Z = m; Z `max` n = n
20:57:46 <jmcarthur> err
20:57:53 <jmcarthur> that's not what i had in mind
20:57:55 <jmcarthur> ignore me
20:57:57 <monochrom> perhaps time to whip out my http://www.vex.net/~trebla/haskell/lazy.xhtml , completely destroys your hypotheses
20:58:07 <Jafet> maximum is strict for any type that does not have a top
20:58:10 <shachaf> @ty let sam = min; n = (&&&) in (sam `n` max)
20:58:11 <lambdabot> Ord b => b -> (b -> b, b -> b)
20:58:45 <archeyDevil> applicative: If you patch the hpodder.cabal to ignore the version of HaXml it works but still get the catch issue
20:58:47 <monochrom> in scheme, foldl would be more efficient than foldr
20:58:57 <Nereid> jmcarthur: I think you'd want to put the successor case last
20:59:07 <jmcarthur> Nereid: even then it's not quite what i wanted
20:59:17 <Nereid> and don't put S around the result of max
20:59:18 <Nereid> :p
20:59:23 <Nereid> wait nm
20:59:27 <jmcarthur> Nereid: the S is needed
20:59:28 <Nereid> I was thinking <
20:59:31 <jmcarthur> right
20:59:32 <Nereid> lol
20:59:41 <monochrom> but neither iterates the list twice. all four cases, scheme/haskell, foldl/foldr, do not iterate the list twice
21:01:07 <manju> How to print using unsafePerformIO ?
21:01:17 <johnw> unsafePerformIO $ print "Hello"
21:01:17 <manju> nevermind
21:01:24 <shachaf> If you can't figure it out, you shouldn't use unsafePerformIO. :-)
21:01:27 <jmcarthur> foldl' captures strict tail recursion. foldr captures lazy non-tail recursion. these are nice. however, lazy tail recursion and strict non-tail recursion are not so nice.
21:01:37 <johnw> you can also use Debug.Trace.trace, if that's what you wanted
21:01:48 <monochrom> I use unsafeInterleavIO to print things, too
21:01:50 <johnw> yeah, never using unsafePerformIO is something of a virtue
21:02:01 <johnw> hi shachaf
21:02:07 <Nereid> never use it directly.
21:02:08 <shachaf> hi johnw
21:02:16 <Nereid> write things like Debug.Trace.trace to use it in a controlled manner.
21:02:17 <Nereid> :p
21:02:27 <jmcarthur> should i feel bad for using unsafePerformIO so often in libraries that i write? :P
21:02:47 <shachaf> jmcarthur: You should make edwardk feel bad for using unsafeCoerce.
21:03:02 <jmcarthur> i just used unsafeCoerce in the last library i released
21:03:06 <edwardk> it is impossible to make me feel bad. that would imply that i have a conscience.
21:03:09 <johnw> jmcarthur: every time you do, a puppy dies
21:03:36 <Jafet> Puppies are nothing
21:03:36 <shachaf> edwardk: Who said anything about a conscience?
21:03:41 <shachaf> You have a utility function.
21:03:45 <Jafet> @quote milliolegs
21:03:46 <lambdabot> olsner says: < kmc> i think 250 milliolegs is enough to kill an elephant  < olsner> kmc: ... to kill an elephant - in the type system!
21:04:23 * edwardk has visions of oleg wrestling an elephant to the ground.
21:04:30 <monochrom> @quote isJust
21:04:31 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
21:05:16 <manju> So I have a function in which I put a trace statement.
21:05:23 <manju> I gave this function to Criterion
21:05:35 <jmcarthur> oleg carries around a quiver of Arrows just for that purpose
21:05:35 <manju> as in nf $ runDFT
21:05:41 <manju> and it didn't print anything
21:06:03 <manju> so it is safe to say that, the function is not being called due to laziness ?
21:07:37 <monochrom> http://hpaste.org/77374#a77457
21:08:05 <Jafet> You should, like, upload this to hackage
21:08:12 <monochrom> haha
21:28:20 <jimch> whoa, maximum' = foldl1' max  is an order of magnitude faster than maximum in standard library. why didnt they use foldl' ?
21:29:33 <shachaf> jimch: Are you compiling with -O2?
21:29:48 <jimch> no I am testing in ghci
21:29:51 <shachaf> (Also: Because it changes semantics.)
21:29:53 <shachaf> Well then.
21:30:32 <jmcarthur> jimch: if you compile with -O2 i think they are the same
21:30:34 <Cale> It is fairly meaningless to compare performance in GHCi or without optimisations turned on in general
21:30:58 <jmcarthur> at least for the strict numeric types. not sure about anything else
21:31:34 <shachaf> For things where they aren't the same, I should hope that they won't be the same.
21:31:45 <shachaf> (That is, in terms of semantics.)
21:31:59 <jimch> foldl' is tail recursive so it should still be faster i believe. what is the reason they used foldl over foldl'?
21:32:26 <shapr>  troll is troll
21:32:40 <lispy> trollest troll is best troll
21:32:49 <jimch> Huh, how am I trolling
21:33:13 <lispy> jimch: tail recursion isn't an obvious win in haskell, unlike in so many other languages
21:33:27 <rwbarton> context....
21:33:55 <lispy> jimch: reasons for foldl vs. foldl' are often history, but also foldl' can be too strict.
21:33:57 <typoclass> guys, the rule of thumb that i was told is "either use foldr or foldl', there is rarely any point to foldl". i don't know why you find the question "why did they use foldl" obviously malicious
21:34:42 <trolling> jimch isn't trolling
21:34:44 <trolling> I'm trolling
21:35:13 <shachaf> Ahem. I believe the morally-superior term is "directry prime".
21:35:21 <shachaf> Wait, that doesn't even exist. :-(
21:35:23 * shachaf sighs.
21:35:40 <typoclass> trolling: no, you haven't said anything for at least 30 min. they did accuse jimch, as far as i can tell
21:35:48 <rwbarton> foldl' wasn't even in the Haskell 98 report for whatever reason, so maximum could not be defined in terms of it
21:36:36 <typoclass> rwbarton: thank you for the factual comment
21:36:59 <rwbarton> there are two questions: (1) why does ghc define maximum = foldl sum (2) why does the haskell report define maximum = foldl sum
21:37:11 <rwbarton> for (1) the answer is "that's what the report says", for (2) you have to ask the report authors
21:37:27 <applicative> archeyDevil: this may or may not work, it's pretty out of date https://github.com/michaelt/hpodder
21:37:27 <rwbarton> uh, not sum
21:37:29 * rwbarton is tired
21:38:54 <trolling> typoclass: i'm simply concerned that jimch is stealing my identity
21:39:05 <shachaf> jimch is not trolling, as far as I can tell.
21:39:16 <trolling> yes, that's what I'm saying
21:39:20 <shachaf> rwbarton: However, with -O2 GHC can often figure out that the function is strict and do something clever.
21:39:21 <typoclass> shapr: the same opinion is given on the haskellwiki. "Conclusion -- Usually the choice is between foldr and foldl'"
21:39:35 <lispy> trolling is on first?
21:39:59 <rwbarton> it's possible that the report authors anticipated that compilers would be able to transform foldl1 max to foldl1' max when appropriate, as ghc can in fact do when optimizations are enabled yes
21:40:07 <lispy> shachaf: I thought the strictness analysis wasn't very good (and that's why we have bang patterns)
21:40:09 <bgamari> rwbarton, To sleep with you!
21:40:14 <rwbarton> yes, quite.
21:41:36 <shachaf> lispy: Try it out!
21:41:39 <shachaf> It's quite possible that I'm wrong.
21:41:47 * shachaf is thinking of sum rather than maximum, for that it's worth.
21:42:15 <jimch> I spent half an hour pondering in the channel why maximum using foldl wouldn't be faster than the one using foldr. I must have done that to prepare trolling about maximum not using foldl' :)
21:42:21 <lispy> shachaf: TBH, I'm not sure what good examples would look like
21:42:42 <trolling> I was not properly prepared
21:43:00 <rwbarton> how about just "main = print (maximum [1..10000000] :: Double)" or whatever
21:43:05 <shachaf> lispy: Well, you'd expect a stack overflow with foldl (+) 0 [1..bignumber], and not with foldl' (+) 0 [1..bignumber]
21:43:06 <lispy> Yes, but to be fair trolling is rarely properly prepared
21:43:20 <trolling> I suffered a maximum-induce stack overflow only yesterday
21:43:24 <trolling> *maximum-induced
21:43:34 <shachaf> trolling: Are you trolling?
21:43:39 <popl> trolling: I hope you cleaned up afterwards.
21:44:20 <lispy> I'm not sure who is trolling right now, but it seems that someone is.
21:44:21 <trolling> shachaf: of course, that's tautological
21:44:23 <bxx> d
21:44:25 <bxx> so the reason is historical, there was no foldl' in haskell 98? what's stopping them from changing maximum implementation? it wouldn't break anything
21:44:30 <trolling> popl: naturally
21:44:37 <trolling> lispy: hello
21:44:46 <typoclass> jimch: the haskellwiki supports your question why foldl was used (http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' says the choice is usually between foldr and foldl'). fwiw, i didn't think you were trolling, and frankly i don't see why those jerks said you were
21:44:56 <lispy> trolling: howdy!
21:45:04 * trolling waves
21:45:24 <shachaf> typoclass: I never said jimch was trolling.
21:45:40 <shachaf> I don't *think* shapr meant it, either, though who knows what shapr means.
21:45:57 <lispy> typoclass: I know why those jerks said it. They lacked proper conversational context as rwbarton pointed out.
21:46:42 <typoclass> shachaf: yes sure, you didn't say jimch was a troll
21:46:46 <lispy> typoclass: Either way, someone here is clearly trolling and it's not jimch as far as I can tell.
21:46:58 <typoclass> shachaf: i agree, who knows what shapr meant, but he didn't apologize either
21:47:10 <shachaf> shapr isn't even here.
21:47:12 <shachaf> @get-shapr
21:47:12 <lambdabot> shapr!!
21:47:19 <typoclass> lispy: what do you mean by lacking conversational context?
21:48:25 <lispy> typoclass: I would be willing to bet shapr didn't read enough of the scroll back before saying something. It's an easy mistake to make. Either that, or he was joking.
21:49:00 <lispy> But, I'm making assumptions about shapr because I've interacted with him enough in the past to know him a little bit.
21:49:26 * lispy goes back to rating games on greenlight
21:52:47 <typoclass> lispy: i agree, not reading enough of the scrollback has happened to everyone. i agree that it's a trivial, harmless mistake if you (say) give someone the lyah link even though someone 60 sec ago gave him the lyah link already
21:53:20 <typoclass> lispy: however i disagree that it is equally trivial and harmless if you throw around accusations of maliciousness. if you want to call people names, in my opinion the decent thing is to invest an additional minute to read the scrollback
21:53:45 <applicative> bxx there is a rule that makes maximum use   foldl1'  for Int and Integer, or maybe you saw it
21:53:47 <shachaf> At least let shapr get back before you start accusing him, man.
21:56:27 * hackagebot alpha 0.9.9.5 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9.9.5 (MarcCoiffier)
21:57:32 <applicative> edwardk: is the unsafeCoerce all over lens now supposed to make it faster?  I see it came up abov
21:57:36 <applicative> above
21:57:40 <latermuse> hey guys, I have a quick question. is there a module or an easily-built command that can do this: input = ((1, 13), (2, 493), (2, 384), (1, 231), (3,18))   input = ((1, 13), (2, 493), (2, 384), (1, 231), (3,18))
21:57:47 <edwardk> applicative: yeah
21:57:54 <edwardk> it avoids a bunch of eta-expansion in the resulting core
21:58:04 <latermuse> woops
21:58:11 <latermuse> hey guys, I have a quick question. is there a module or an easily-built command that can do this: input = ((1, 13), (2, 493), (2, 384), (1, 231), (3,18))   output = [(1,[13, 231]), (2,[493, 384]), (3, [13])]
21:58:12 <latermuse> i mean this
21:58:14 <edwardk> we're experimenting with different implementation strategies still
21:58:32 <edwardk> the core design is solid, its just quibbling about that eta-expansion and slight strictness differences
21:58:53 <archeyDevil> applicative: ohai. sorry went afk
21:59:28 <applicative> latermuse: there must be a brilliant pointfree solution ...
22:00:01 <latermuse> applicative: could you enlighten me?
22:01:33 <luite> pointfree doesn't have to be brilliant
22:01:38 <luite> here
22:01:46 <luite> sortBy, groupBy, map would work
22:01:53 <typoclass> latermuse: hello, you could use http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map-Strict.html . in particular, look at the documentation of functions unionWith and insertWith
22:02:48 <luite> latermuse: input is a list, right, not a tuple?
22:03:06 <latermuse> yeah my mistake, its a list of tuples
22:03:35 <applicative> >   groupBy (\(a,b) (c,d) -> a == c)$sort [(1, 13), (2, 493), (2, 384), (1, 231), (3,18)]
22:03:37 <lambdabot>   [[(1,13),(1,231)],[(2,384),(2,493)],[(3,18)]]
22:03:53 <applicative> latermuse: well that's pretty close ^^^
22:04:04 <luite> applicative: that messes up the order of 493 and 384
22:04:10 <applicative> oh
22:04:34 <luite> sortBy works though :)
22:04:42 <applicative> sortBy ah
22:05:03 <luite> and (==) `on` fst
22:06:06 <latermuse> im not understanding, substituting sortBy for groupBy doesnt seem to work for me
22:06:09 <archeyDevil> 0% [22.8 5MB/203MB 2%] [22.6 5MB/137MB 3%]                       488KB/s 10h49m
22:06:15 <archeyDevil> applicative: hpodder is working ^_^
22:06:18 <archeyDevil> Thanks for the link.
22:06:44 * archeyDevil shall leave this running for days ^_^
22:06:49 <jmcarthur> > map (fst . head &&& map snd) . groupOn fst . sortOn fst $ [(1, 13), (2, 493), (2, 384), (1, 231), (3,18)]
22:06:50 <luite> latermuse: nah i meant, if you use sortBy (compare `on` fst), instead of just sort, the order of the tuples with the same first numbers is kept stable
22:06:51 <lambdabot>   [(1,[13,231]),(2,[493,384]),(3,[18])]
22:07:09 <luite> :info groupOn
22:07:14 <jmcarthur> sortOn f = map snd . sortBy (comparing fst) . map (f &&& id)
22:07:15 <jmcarthur> groupOn f = (map.map) snd . groupBy ((==) `on` fst) . map (f &&& id)
22:07:28 <manju> is there a function in haskell like gettimeofday ?
22:07:34 <applicative> archeyDevil: there was a substantive change I had to make to take account of the newer haxml, so I'm not sure there won't be nonsense. But you'll find out
22:07:39 <luite> risky function name, it's probably trademarked ;)
22:07:52 <Clint> manju: yes
22:07:53 <typoclass> manju: you might be interested in getZonedTime from the Data.Time module
22:08:19 <archeyDevil> archey@devil: ~/.hpodder/enclosurexfer % mplayer 48bbdc7312cba9b702ecf0d65e29e089
22:08:19 <latermuse> jmcarthur: wow that seems to work well
22:08:22 <archeyDevil> Hehehe
22:08:26 <jmcarthur> i like sortOn and groupOn, but they aren't in Data.List :(
22:08:27 <archeyDevil> Downloading and I'm watching ^_^
22:08:32 <jmcarthur> @hoogle sortOn
22:08:32 <lambdabot> No results found
22:08:38 <jmcarthur> @hoogle groupOn
22:08:38 <lambdabot> No results found
22:08:47 <applicative> latermuse: I knew that if I had a go at it, luite jmcarthur and suchlike people would figure it out....
22:08:55 <jmcarthur> @. hoogle type sortOn
22:08:57 <lambdabot> Parse error:
22:08:57 <lambdabot>   Ord a => (b -> a) -> [b] -> [b]
22:08:57 <lambdabot>  
22:09:02 <latermuse> applicative: haha :)
22:09:08 <jmcarthur> @. @hoogle @type sortOn
22:09:08 <lambdabot> Plugin `compose' failed with: Unknown command: "@hoogle"
22:09:11 <jmcarthur> bah
22:09:23 <jmcarthur> @hoogle Ord a => (b -> a) -> [b] -> [b]
22:09:23 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
22:09:24 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
22:09:24 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
22:09:36 <jmcarthur> sortWith is the one that exists
22:09:40 <jmcarthur> ... in GHC.Exts...
22:10:37 <jmcarthur> @hoogle Eq a => (b -> a) -> [b] -> [[b]]
22:10:38 <lambdabot> GHC.Exts groupWith :: Ord b => (a -> b) -> [a] -> [[a]]
22:10:38 <lambdabot> GHC.Exts sortWith :: Ord b => (a -> b) -> [a] -> [a]
22:10:38 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
22:10:44 <jmcarthur> that exists too!
22:10:44 <latermuse> jmcarthur: so sortWith should substitute sorton?
22:11:09 <jmcarthur> well the problem with those is that they are in GHC.Exts, which is a silly thing to import for such a function
22:11:36 <archeyDevil> Wow old episode from season 1 <3
22:11:41 <jmcarthur> wait, groupWith uses Ord?
22:11:48 <shachaf> GHC.Exts has all sorts of great functions!
22:11:51 <shachaf> @ty GHC.Exts.the
22:11:53 <lambdabot> Eq a => [a] -> a
22:12:06 <jmcarthur> "the"? ...
22:12:46 <typoclass> > M.fromListWith (++) $ map (second (:[])) [(1, 13), (2, 493), (2, 384), (1, 231), (3,18)] -- latermuse, here is a solution involving Data.Map
22:12:48 <lambdabot>   fromList [(1,[231,13]),(2,[384,493]),(3,[18])]
22:12:56 <shachaf> the (x:xs) | all (== x) xs = x; the _ = _|_
22:14:58 <jmcarthur> > map (fst . head &&& map snd) . groupBy ((==) `on` fst) . sortBy (comparing fst) . map (f &&& id) $ [(1, 13), (2, 493), (2, 384), (1, 231), (3,18)]   -- stuff you can just get from Data.List
22:15:00 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:15:00 <lambdabot>    (GHC.Classes.Ord a0)
22:15:00 <lambdabot>   ...
22:15:08 <jmcarthur> nooo
22:15:25 <archeyDevil> lol jmcarthur
22:15:30 <jmcarthur> > map (fst . head &&& map snd) . (map.map) snd . groupBy ((==) `on` fst) . sortBy (comparing fst) . map (f &&& id) $ [(1, 13), (2, 493), (2, 384), (1, 231), (3,18)]   -- stuff you can just get from Data.List
22:15:32 <latermuse> hehe
22:15:32 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:15:32 <lambdabot>    (GHC.Classes.Eq a0)
22:15:32 <lambdabot>    ...
22:15:35 <jmcarthur> awful
22:15:39 <jmcarthur> must actually think
22:16:57 <typoclass> jmcarthur: bah, by the time you're done with this thing 'thinking', i've already tried 18 lines of code in lambdabot, thrashing around aimlessly ;-)
22:17:23 <jmcarthur> eh i already wrote the one with sortOn and groupOn, which i like more anyway
22:17:36 <padrian2s> hello, how come tuples are not immutable??
22:17:40 <jmcarthur> just trying to avoid defining the extra things
22:17:45 <johnw> padrian2s: um, how are they not?
22:17:46 <jmcarthur> padrian2s: tuples are immutable
22:18:19 <padrian2s> everything in haskell is immutable
22:18:27 <padrian2s> Haskell tuples aren't immutable lists, from the http://book.realworldhaskell.org/read/types-and-functions.html
22:18:39 <johnw> ah
22:18:45 <johnw> that doesn't mean they're not immutable
22:18:46 <manju> if I do this
22:18:49 <johnw> just that they're not immutable lists
22:18:54 <mapf> our world are immutable as well. it's just copied every moment, once and again
22:18:56 <jmcarthur> padrian2s: they aren't lists
22:19:00 <manju> let !blah = foldr (+) 0 [0....100000]
22:19:04 <tsou> padrian2s: a banana is not a yellow lemon.  that doesn't mean it's not yellow :P
22:19:09 <manju> then blah is evalutated strictly right ?
22:19:23 <typoclass> padrian2s: ah, what they mean is "haskell tuples aren't lists"
22:19:47 <applicative> padrian2s: that is a pretty misleading formulation
22:20:04 <jmcarthur> padrian2s: i think they focused unnecessarily on the immutability because they are trying to compare and contrast with python tuples
22:20:11 <padrian2s> hmm, list compared to immutable is silly term
22:20:29 <jmcarthur> in python, tuples are basically immutable lists
22:20:56 <manju> let !blah = foldr (+) 0 [0....100000] -- <- this is evaluated strictly right ?
22:21:05 <typoclass> padrian2s: i agree that the way they wrote it is a little unclear, but also, i'm not familiar with python's datastructures :-) it might be a useful comparison to make, no idea.
22:21:45 <padrian2s> so the faith in haskell restored :) everything is immutable
22:21:55 <mapf> manju: i think in this particular exsample there are no difference
22:21:58 <startling> padrian2s: welll
22:22:34 <manju> mapf, meaning ? It is not strict ?
22:22:43 <typoclass> padrian2s: anyway, in haskell, a list consists of elements which all must have the same type. a tuple consists of elements which can have different types. both of them are immutable
22:23:15 <manju> My laptop might shutdown
22:23:33 <manju> When I run my haskell prog an a large image the laptop goes off
22:23:55 <mapf> manju: are you familiar with whnf?
22:24:03 <manju> mapf, yes
22:24:12 <manju> mapf, it is not working either
22:24:14 <mapf> btw bang pattern do not force anything
22:24:29 <manju> How to do strict evaluation ?
22:24:35 <padrian2s> typoclass: my understanding of immutable term is similar from java string, once you have alter that variable or a list or a tuple a new copy return
22:24:51 <mikeplus64> manju: use foldl'
22:25:08 <startling> padrian2s: that's correct
22:25:18 <manju> mikeplus64, no that was just an example, I have a function, which needs to be run strictly
22:25:30 <manju> mikeplus64, it is more complicated than foldl
22:25:41 <padrian2s> typoclass: like doing user/password management in some immutable data types, hehehe, sound silly, right...
22:25:42 <mapf> mikeplus64: see deepseq
22:25:45 <typoclass> padrian2s: yes, that is the normal thing in haskell. when you add something to a list, you get back a "new" list that is exactly like the old one plus the additional element
22:25:57 <mapf> oh, manju
22:26:24 <mikeplus64> manju: let !x = ... in x will evaluate x strictly yes, but not "deeply" (listen to mapf)
22:26:42 <mapf> manju: there is no way to make a function 'strict'
22:26:50 <manju> Sorry if I am being dense.
22:26:54 <manju> manju: ok
22:26:57 <manju> mapf, ok
22:27:03 <padrian2s> thanks everyone for the kind response :)
22:27:09 <mapf> computation 'points' are constructors not a functions
22:27:10 <manju> Ok laptop is getting hot
22:27:19 <typoclass> padrian2s: you're welcome :)
22:27:33 <manju> my problem is haskell is faster than optimized C
22:27:43 <mapf> it's a general rule about reasoning i think
22:27:49 <manju> mapf, ok
22:28:04 <mikeplus64> > seq (unsafePerformIO $ do putStrLn "functions can be strictish, mapf"; return (\x -> x)) ()
22:28:06 <lambdabot>   Not in scope: `unsafePerformIO'
22:30:12 <manju> Offtopic is there  a way to switch on the laptop fan manually ?
22:30:39 <johnw> which laptop?
22:30:43 <manju> HP
22:30:46 <mapf> mikeplus64: i don't completely understand. i mean we can't just (mkStrict myFun) to get a strict function (e.g. applicative order or something
22:30:51 <johnw> there probably is a fan utility
22:30:57 <johnw> i can do it on Mac, so I bet you can too
22:30:59 <manju> When I run my haskell code, it heats up and switches off :-(
22:31:05 <manju> johnw, ok
22:31:14 <johnw> good thing shachaf's machine doesn't do that
22:31:24 <johnw> he's been using haskell to turn electricity into heat
22:32:00 <manju> johnw, haha...
22:32:12 <covi> Why is it that 'fix reverse' or 'fix id' produces no output? What's behind the scene?
22:32:39 <manju> I think it is working
22:32:47 <manju> It takes 9 secs to run my function
22:32:57 <manju> So I think it is working.
22:34:23 <mikeplus64> mapf: yeah i don't think there is a proper deepseq for functions, but you can still force at least some things to be computed before you apply all the arguments
22:36:58 <manju> Currently switched on the ceiling fan to max, standing on a stool with laptop upside down below the fan, to let my haskell prog complete -_-
22:37:37 <jojo_> Hello, I have kind of an important question, if anyone is willing to help
22:38:19 <mikeplus64> jojo_: ask away, it's the only way you'll get an answer :)
22:38:36 <jojo_> Well, sort of a question, it won't *really* be stated as a question but
22:38:47 <jojo_> I can't figure out whether Haskell uses reserved words, keywords, or both
22:38:53 <jojo_> And what uses which
22:39:56 <jojo_> For example: Are data type names like "Char", "Bool", etc. reserved words?
22:40:08 <mapf> jojo_: http://www.haskell.org/haskellwiki/Keywords ?
22:40:11 <jojo_> I can't seem to find this out in the Haskell report
22:40:35 <mapf> jojo_: no, Char and Bool it's just ordinary type identifiers
22:40:39 <manju> Haskell func takes 275.3620 secs! :-)
22:41:32 <mapf> jojo_: all haskell data type names are ordinary name which can be fully qualified for exsample
22:41:58 <typoclass> jojo_: hello, no, those are ordinary names that are defined in the ordinary way. you could make your own "data Charr = ..." and get people to include it in ghc and add it to the Prelude module, and then Charr would have exactly the same status as Char
22:42:33 <mapf> you can even define you own Char
22:42:35 <jojo_> Oh okay, I get it
22:42:36 <shachaf> You could define a data type called Char.
22:42:51 <shachaf> typoclass: If anything, exactly the reverse of what you said is true. :-)
22:43:08 <shachaf> Prelude.Char has special status because 'a' :: Prelude.Char no matter what you do.
22:43:09 <typoclass> shachaf: how do you mean?
22:43:11 <jojo_> So Char can be... what's the term... overridden? Overwritten?
22:43:11 <mapf> but when you use it, you should avoid ambiguity
22:43:19 <Wilduck> Hey, I'm trying to find a function that takes a char, and gives a string containing just that character. For whatever reason, hoogle is failing me. The purpose is to lift a `Parser String` out of `noneOf "\""`.
22:43:43 <otters> return?
22:43:49 <bxx> wilduck [char]
22:43:49 <otters> (:[])?
22:43:58 <typoclass> shachaf: oh right :) good point. i was thinking in terms of the name "Char" and how it shows up in function signatures and so on. it doesn't have special status there afaik.
22:44:35 <mapf> jojo_: it's ordinary name, just like data T = T.
22:44:56 <mapf> list is special though
22:45:08 <covi> Why is it that 'fix reverse' or 'fix id' produces no output? What's behind the scene?
22:45:41 <lispy> covi: recursion
22:46:08 <Wilduck> otters, I'm trying to inline a parser combinator (I'm not using do syntax), and I don't think return works here
22:46:18 <typoclass> shachaf: in my defense, he was asking about the name Char and Bool, not the relation between 'a' and Char
22:46:27 <jojo_> Okay, thank you very much for the help. I'm still trying to learn the ins and outs of this language, the first time I've tried for a language before. So I'm super n00bish at this.
22:46:31 <lispy> covi: specifically, there is no point of return
22:46:31 <Wilduck> box, I need something that I can pass to liftM, not sure how [char] would work
22:46:34 <Wilduck> *bxx
22:46:59 <mapf> jojo_: stay tuned)
22:47:00 <covi> lispy: does the evaluation go on forever?
22:47:04 <Wilduck> Also, I'm not entirely sure how to express this. I could very easily be doing something silly
22:47:12 <typoclass> jojo_: good luck :-) do you have a textbook? you're not trying to learn haskell from the Report alone, are you?
22:47:12 <Wilduck> I'm pretty new at this whole monad thing
22:47:14 <typoclass> @where lyah
22:47:15 <lambdabot> http://www.learnyouahaskell.com/
22:47:17 <lispy> covi: sometimes you can still get output even if the recursion goes on forever.
22:47:19 <lispy> > fix show
22:47:21 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
22:47:26 <typoclass> jojo_: ^^ this is a good textbook available free of charge
22:47:33 <jojo_> I have Learn You a Haskell and Real World Haskell that I've been reading
22:47:57 <bxx> Wilduck perhaps I don't even understand your problem, but you asked how to get a string out of a char. [char] does that.  ['o'] == "o"
22:48:05 <jojo_> Plus the report and history of haskell documents, and the actual haskell website of course
22:48:25 <manju> My arms got tired :-(
22:48:32 <shachaf> monochrom: How do you extract the [Char] out of Char?
22:48:44 <manju> head [Char] ?
22:48:49 <covi> lispy: why does fix show output sth and why does it output a bunch of '\'
22:48:53 <Wilduck> box, I'm not sure I understand my problem 100% either. What I need is a function that I could use like this: `liftM <somefunction> $ noneOf "\""`
22:48:58 <typoclass> shachaf: trick question? same way you extract the file listing out of /bin/ls?
22:49:11 <Wilduck> *bxx (darn colloquy autocorrect)
22:49:16 <lispy> covi: what is the type of fix show?
22:49:16 <manju> echo [Char]|sed ?
22:50:17 <bxx> Wilduck I'll let someone more knowledgeable  help you
22:50:39 <otters> Wilduck: yes it does
22:50:49 <covi> lispy: String
22:51:02 <otters> :t return 'c' :: String
22:51:03 <lambdabot> String
22:51:06 <otters> it's a string
22:51:10 <lispy> covi: When you show a string, what is the first thing that is shown?
22:51:20 <mapf> i'm thinking about groups in context of document changes. it seems that we have Euclidean group for some sorts of vector objects transformations and we can doing/undoing actions upon document in elegant way. and with very low memory consumption.
22:51:36 <covi> lispy: the first character of it?
22:51:37 <lispy> > show "this is a string"
22:51:39 <lambdabot>   "\"this is a string\""
22:51:42 <lispy> covi: nope
22:51:46 <lispy> covi: a double quote
22:51:47 <mapf> so we have a binary relation  combineAction :: Action -> Action -> Action
22:51:51 <jimch> going to sleep, good night. typoclass thanks for backing me up
22:51:55 <manju> Wow...for a large dataset, the C function runs in ~ 4 secs
22:52:00 <typoclass> jimch: you're welcome
22:52:17 <mapf> and inverse :: Action -> Action
22:52:22 <manju> versus the mildly optimized haskell which runs in 275 secs
22:52:27 <lispy> covi: let's look at the definition of fix
22:52:30 <lispy> ?src fix
22:52:30 <lambdabot> fix f = let x = f x in x
22:52:31 <manju> interesting
22:52:42 <lispy> covi: fix show = let x = show x in x
22:52:58 <padrian2s> ?src liftA2
22:52:58 <lambdabot> liftA2 f a b = f <$> a <*> b
22:53:12 <covi> lispy: btw i'm really confused by this def. i understand fix f = f (fix f) thought
22:53:18 <padrian2s> ?src (||)
22:53:18 <lambdabot> True  || _ =  True
22:53:18 <lambdabot> False || x =  x
22:53:26 <mapf> we can make sorta undoing here: combine a (inverse a)
22:53:32 <covi> lispy: what i don't understand is where does the 'x' after 'show' come from
22:53:38 <Wilduck> otters, I may be unclear on what return does exactly (I'm new at this), but I have a character in a Parser monad, and I need to lift the character out, turn it into a string and put it back in. Isn't liftM the way to do this, not return? Or am I missing something about how monads work?
22:53:49 <padrian2s> how come we don't have ?src in ghci ? :)
22:53:54 <lispy> :t let fix' f = f (fix' f) in fix'
22:53:55 <lambdabot> (t -> t) -> t
22:54:08 <padrian2s> or is there a such tool in the packages?
22:54:22 <lispy> covi: Well, to figure out where that x comes from we have to expand out the definition again
22:54:50 <typoclass> > (:[]) 'f' -- Wilduck, it sounds like you want this
22:54:51 <lambdabot>   "f"
22:55:06 <lispy> covi: your version is probably easier to reason with
22:55:09 <otters> Wilduck: I would recommend return <$> anyChar
22:55:14 <typoclass> (note the ' changed to ", indicating it's now a String)
22:55:14 <otters> or char 'c' or whatever you're using
22:55:19 <lispy> covi: fix show = show (fix show)
22:55:22 <otters> which turns a Parser Char into a Parser String
22:55:33 <lispy> covi: fix show = show (fix show) = show (show (fix show))
22:55:37 <lispy> covi: and so on
22:56:06 <typoclass> Wilduck: do you know hpaste? you can use it to share your code to the folks in here. it makes things a great deal easier :-)
22:56:09 <typoclass> @where hpaste
22:56:09 <lambdabot> http://hpaste.org/
22:56:17 <lispy> covi: and since the final type is String, each of those "show ..." things knows it wants to produce a double quote followed by the string
22:56:48 <Wilduck> typo class I didn't, good to know. I think (:[]) is exactly what I'm looking for
22:56:49 <lispy> > length . take 10 . group . fix $ show
22:56:51 <lambdabot>   10
22:56:55 <lispy> > map length . take 10 . group . fix $ show
22:56:57 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
22:57:04 <Wilduck> although I'm going to look at what otters suggested as well
22:57:09 <Wilduck> thank you both for your help
22:57:17 <lispy> covi: notice how the length of the groups increase by almost doubling.
22:57:39 <covi> @src group
22:57:39 <lambdabot> group = groupBy (==)
22:57:42 <covi> @src groupBy
22:57:43 <lambdabot> groupBy _  []       =  []
22:57:43 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
22:57:43 <lambdabot>     where (ys,zs) = span (eq x) xs
22:57:49 <lispy> > group . fix $ show
22:57:51 <lambdabot>   ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\...
22:58:31 <mapf> lispy: nice
22:59:20 <typoclass> Wilduck: ok. the way (: []) works is the same as "(+ 3)", i.e. (+) is operator that takes 2 arguments, and we give it a 3, meaning (+ 3) is a function that expects one more argument. (this is called a section.) and i'm sure you've come across [], which is the empty list, and : is the operator that adds one element to a list
22:59:47 <lispy> When you 'fix show', it first appears quite broken but then a subtle elegance emerges.
23:00:01 <Wilduck> typoclass that makes perfect sense.
23:00:08 <Wilduck> thank you
23:00:14 <typoclass> Wilduck: you're welcome :)
23:01:01 <covi> lispy: I'm trying to understand why the strings are different in group . fix $ show
23:01:21 <covi> lispy: right now I understand the first one in the String is "\""
23:05:32 <lispy> > foldr (const show) "base" [1..3] -- covi, does this help?
23:05:33 <lambdabot>   "\"\\\"\\\\\\\"base\\\\\\\"\\\"\""
23:06:07 <lispy> > map length . take 10 . group $ foldr (const show) "base" [1..]
23:06:09 <lambdabot>   [1,1,1,3,1,7,1,15,1,31]
23:07:25 <lispy> hmm.. so is fix f = foldr (const f) undefined [1..] ?
23:08:39 <mapf> lispy: it's like when you express map through foldl
23:08:41 <lispy> > let fix' f = foldr (const f) undefined [1..] in fix' $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
23:08:43 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
23:08:44 <mapf> i guess
23:09:16 <mapf> oh, no
23:10:34 <lispy> > let fix' f = foldr (const f) (fix' id) [1..] in fix' $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
23:10:35 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
23:10:42 <lispy> I don't even need undefined :)
23:11:12 <mapf> so fix id is undefined :)
23:11:19 <lispy> very much so
23:11:29 <lispy> :t fix id
23:11:30 <lambdabot> a
23:13:57 <lispy> TIL foldr + letrec = fix
23:14:04 <padrian2s> ?src <$>
23:14:05 <lambdabot> f <$> a = fmap f a
23:14:12 <padrian2s> ?src <*>
23:14:13 <lambdabot> Source not found. I am sorry.
23:14:23 <lispy> :t <*>
23:14:25 <lambdabot> parse error on input `<*>'
23:14:29 <lispy> :t (<*>)
23:14:30 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
23:15:04 <lispy> easier to think about if you add the explicit parens: f (a -> b) -> (f a -> f b)
23:15:10 <lispy> now it should be pretty obvious what it does
23:15:27 <scoles> I'm using haskellmode-vim and am trying to use the built in hoogle search functionality, but I can't seem to figure out the command.  The help says '_?1'  what in the hell kind of key combo is that? _?? doesn't work, and _? is already bound.
23:17:05 <scoles> ah i see i just have to be really quick about hitting the 1
23:17:07 <scoles> never mind :)
23:17:20 <typoclass> scoles: hello, i'm not familiar with the _?1 command, but things like _t work for me. it's those two literally ...
23:17:23 <typoclass> er yeah :)
23:18:05 <typoclass> scoles: i think you can adjust that timeout. check the vim help on config settings
23:18:25 <scoles> yeah i'm doing that right now :)
23:22:03 <enderw> how do i perform a mathematical operation after taking two input variables? to spit out the result as a float.
23:22:36 <lispy> covi: I hope those examples help. I'm out.
23:22:38 * lispy heads to bed
23:24:47 <shapr> Whoa, I didn't even mean to imply that jimch was trolling.
23:25:27 <shapr> I was talking about cinolt earlier.
23:37:57 <typoclass> shapr: hm ok i apologize then :-/ i had been in the channel only about 25 mins at the time. looking at tunes.org, i see now that you were referring to someone else 50 mins earlier
23:41:45 <applicative> enderw: can you say more about what you mean?
23:43:22 <applicative> enderw: e.g. are the 'two input variables' user input
23:49:01 <Moggle> Hi there! I'm going through a Haskell tutorial and this bit of code popped up:
23:49:06 <Moggle>     ghci> map ($ 3) [(4+), (10*), (^2), sqrt]
23:49:08 <Moggle>     [7.0,30.0,9.0,1.7320508075688772]
23:49:20 <Moggle> I'm curious, can someone explain how the heck $ 3 acts as a function in this context?
23:49:31 <shachaf> Well, take it apart in ghci.
23:49:38 <shachaf> You can look at ($ 3) alone:
23:49:40 <mm_freak> Moggle: it's the function that takes a function and applies 3 to it
23:49:41 <shachaf> :t ($ 3)
23:49:42 <lambdabot> Num a => (a -> b) -> b
23:49:49 <shachaf> You know how (+ 3) becomes (\x -> x + 3)?
23:50:00 <mm_freak> > ($ 3) sin
23:50:01 <lambdabot>   0.1411200080598672
23:50:11 <Moggle> yes, shachaf!
23:50:20 <Moggle> that part makes perfect sense
23:50:28 <mm_freak> s/applies 3 to it/applies it to 3/
23:50:30 <Moggle> not sure how $ applies there because typically you do <function here> $ 3
23:50:45 <mm_freak> Moggle: that's regular section syntax
23:50:49 <mm_freak> > (+ 3) 5
23:50:51 <lambdabot>   8
23:50:56 <mm_freak> > ($ 3) sin
23:50:57 <lambdabot>   0.1411200080598672
23:51:39 <Moggle> I see now!
23:51:48 <Moggle> It is still slightly messing with my mind, but that makes way more sense
23:51:51 <enderw> applicative: yes. they're taken as input to calculate a final result that must be rounded off to a certain number of decimal numbers.
23:51:52 <Moggle> Thanks everyone!
