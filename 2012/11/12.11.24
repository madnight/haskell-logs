00:00:06 <mm_freak_> but that only happens when you enable UndecidableInstances
00:00:48 <Nereid> no, I'm wondering for no particular reason.
00:00:54 <mm_freak_> ah
00:01:52 <mm_freak_> anyway, is there a gloss-like library for small test programs?  gloss itself would be fine, but i can't get it to build on GHC 7.6 without destroying my other packages
00:09:55 * hackagebot lens 3.6 - Lenses, Folds and Traversals  http://hackage.haskell.org/package/lens-3.6 (EdwardKmett)
00:10:26 <shachaf> All y'all upgrade.
00:10:37 <otters> oh shet
00:11:06 <edwardk> =)
00:12:28 <edwardk> this should be a pretty stable point in the release cycle. all open issues are things that can be added as minor revisions for the forseeable future
00:12:43 <edwardk> and are all feature requests
00:13:04 <shachaf> ion is going to write some nice Zipper benchmarks.
00:30:09 <edwardk> > anyOf biplate (=="world") ("hello",(),[(2::Int,"world")])
00:30:11 <lambdabot>   True
00:56:17 <shachaf> Cale: You can upgrade lens now.
01:22:47 <jamil_1> hi all
01:23:02 <jamil_1> I am looking for a comparison for type theory and set theory
01:23:14 <jamil_1> hints, references ?
01:58:31 <deus_rex> @type liftM
01:58:32 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
01:59:03 <shachaf> @ty fmap
01:59:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
01:59:12 <shachaf> Why is GHC using terrible names types like that?
01:59:37 <shachaf> Wait, it's not.
01:59:44 <shachaf> Control.Monad defined liftM with that awful type.
01:59:45 <shachaf> @ty liftA
01:59:48 <lambdabot> Applicative f => (a -> b) -> f a -> f b
01:59:50 <shachaf> @ty liftA
01:59:51 <shachaf> @ty liftA2
01:59:52 <lambdabot> Applicative f => (a -> b) -> f a -> f b
01:59:53 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:00:01 <shachaf> How could you, Control.Monad?
02:02:25 <Saizan> with a1?
02:02:34 <Saizan> sounds auto-generated
02:02:44 <shachaf> Saizan: Maybe, but it's right there in the file.
02:18:19 <bxx> why does this code block?  http://hpaste.org/78146
02:20:31 <shachaf> bxx: See the documentation for Ord
02:20:55 <shachaf> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Ord
02:36:52 <m3ga> is there a way to convert a String to a type name for use in a type signature inside a function?
02:37:13 <shachaf> Eugh. I should hope not.
02:38:07 <m3ga> shachaf: i've found a place where it makes some sort of sense :-)
02:39:01 <shachaf> Instead of asking about the thing, ask about the place.
02:41:09 <Saizan> mmh, with string literals in types it might not be so out of place
02:41:44 <tdammers> I'm guessing some sort of metaprogramming or compilation
02:41:54 <hpaste> m3ga pasted “type trickery” at http://hpaste.org/78147
02:42:26 <m3ga> shachaf: the queryRowCount function is what i'd like to do.
02:43:14 <shachaf> A type parameter or a value parameter?
02:43:30 <shachaf> I don't know what's going on in that code.
02:45:55 <m3ga> shachaf: this uses Database.Persist to generated two SQL tables, User and Project. queryUserCount uses Esqueleto to get the number of rows in the User table. what i'd like a a function that can get the row count of any table.
02:46:42 <m3ga> for getUserCount the table is set by the 'Entity User' part of the internal type sig.
03:18:03 <sp3ctum> is it possible to use the ghci breakpoints so that i can stop execution and execute arbitratry expressions?
03:18:31 <sp3ctum> i think, mixed with purity, that would be powerful
03:19:20 <dcoutts> sp3ctum: yes, that's what the ghci debugger lets you do
03:20:16 <dcoutts> when you stop at a breakpoint you're still in a ghci session, you can still execute arbitrary IO action at the ghci prompt
03:20:31 <dcoutts> it's just you're now in the context of the breakpoint, can see local bindings etc
03:20:45 <Ralith> that's a thing?
03:20:50 <Ralith> why didn't anybody tell me that was a thing
03:21:51 <dcoutts> Ralith: probably because very few people use it :-)
03:21:55 <dcoutts> chicken & egg
03:22:14 <dcoutts> the experienced Haskell hackers grew up with no debugger, and now they don't use one
03:22:18 <dcoutts> even now that one exists
03:22:19 <Ralith> where's it documented?
03:22:25 <dcoutts> ghc users guide
03:22:29 <Ralith> kk
03:22:35 * Ralith grew up with SLIME
03:22:41 * Ralith likes having a debugger.
03:25:15 <Eidel> How do I create a function which takes no arguments?
03:25:27 <shachaf> Eidel: No such thing.
03:25:29 <dcoutts> Eidel: we call that a value, not a function
03:25:30 <sp3ctum> thanks dcoutts !
03:25:48 <Eidel> shachaf: dcoutts: Ok
03:25:50 <dcoutts> Eidel: and you do it in just the same way you define a function, but you just don't list any arguments
03:25:55 <Ralith> Eidel: how do I create a water bottle that doesn't hold water?
03:26:03 <shachaf> dcoutts: We also call functions value. :-)
03:26:07 <shachaf> s
03:26:23 <Eidel> Ralith: you dont put any water in it...
03:26:39 <dcoutts> shachaf: yes yes :-)
03:27:08 <Ralith> Eidel: in this context, "doesn't" means "is incapable of"
03:27:08 <shachaf> I guess what you said was true, though.
03:27:26 <dcoutts> shachaf: calling everything a value isn't helpful when you're learning
03:27:31 <shachaf> How do I create an analogy that doesn't hold water?
03:27:37 <shachaf> dcoutts: Agreed. That wasn't helpful.
03:28:16 <luite> go easy on the analogies, he's just getting his feet wet
03:28:25 <Ralith> shachaf: well, first you take a turtle and the text of Hamlet...
03:33:09 <Saizan> shachaf: a bit of logic mixup there too, it's perfectly consistent to say some value is not a function even if every function is a value
03:33:22 <shachaf> Saizan: Right.
03:33:33 <shachaf> As I said, I was both wrong and unhelpful.
03:33:42 * shachaf might as well leave forever now.
03:34:34 <edwardk> stay. who else will field lens bug reports while i sleep?
03:35:14 <alang_> edwardk: you sleep?
03:36:12 <edwardk> i think so. there are times when i sit at my computer and i can't account for what i've been doing for a few hours, but then i look and i find that i've started some new project =P
03:37:37 <alang_> haha
03:40:24 * Saizan wonders where edwardk gets all that energy
03:41:35 <edwardk> i can usually keep going as long as i'm not bored
03:43:04 <Chathurga> If I was doing "data Thing a = ..." how would I specify that the "a" must be an Ord?
03:43:35 <edwardk> Chathurga: this is a fairy common question, and it has three answers. the right answer is "you don't".
03:43:46 <bxx> Eidel every function in haskell takes just one argument
03:44:10 <edwardk> Chathurga: how much haskell do you know?
03:44:50 <edwardk> Chathurga: the way you do this idiomatically in haskell is put the constraints that are needed on 'a' at each usage site.
03:45:07 <Chathurga> That's what I was thinking
03:45:15 <Rc43> Hi, guys.
03:45:32 <edwardk> e.g. i'm willing to bet that you don't need 'Ord' in order to resolve 'Show' for your Thing. or its 'Eq' instance can work with just Eq on a, etc.
03:45:49 <Chathurga> I've only been learning for maybe a month, but it's taking over my life
03:46:07 <Rc43> Am I right, that number of all summand decompositions of N is just 2^(N-1)?
03:46:25 <edwardk> so you tend to find that these 'this field must always instantiate this class!' constraints that you are used to from other languages are a bad design decision in Haskell.
03:47:09 <edwardk> Now. I said that is the right answer. There are a couple of other things you _can_ do (or used to be able to do in one case). I'll mention them so you can have a complete picture.
03:47:11 <Chathurga> edwardk: Ah okay. I had two functions for the data type that are essential and one require an Ord and the other an Eq, was just wondering if I could force the contraint at a higher level
03:48:23 <edwardk> in the olden days you could make a pretty useless constraint " data RealFloat a => Complex a = a :+ a " which says exactly what you asked for, but not what you want t can't construct a Complex a without a being an instance of RealFloat.
03:48:37 <Rc43> E.g. #3 = [[1,#2],[2,#1],[3]]=2+1+1=4=2^(3-1); #2 = #[[1,1],[2]]=2=2^(2-1)
03:48:53 <edwardk> but the thing is, that doing so, doesn't let you _use_ this fact anywhere, it just incurs an obligation on construction, it doesn't give you back those instances when you go to use it later.
03:49:23 <edwardk> it existed because way way back in the day it was necessarily in order to use the class that used to contain seq.
03:49:56 <edwardk> (fields with bang patterns had to have a type that was an instance of Seq, and so you had a hard language requirement driving that feature initially
03:50:28 <edwardk> but the world moved on and way back in haskell pre-history that Seq class was eliminated, but the feature was misused in various places, like Complex until it was removed in 2010
03:50:31 <alang_> Rc43: are you counting with reordering? [1,2] and [2,1] both appear there
03:50:40 <Chathurga> Aaah I see
03:50:43 <alang_> Rc43: also I don't think this is a haskell question
03:51:14 <edwardk> so that makes up 2 of 3 answers. the correct 'you don't' answer. and the technically correct but useless 'you used to' answer
03:51:25 <Rc43> alang_, yep, it is not a haskell question; just don't know where else can I ask and get answer.
03:51:31 <edwardk> the third answer is that you can capture a dictionary with a GADT.
03:51:55 <shachaf> You don't need a GADT, just an "existential" context.
03:51:56 <edwardk> data Foo a = Ord a => Foo a
03:52:01 <shachaf> Well, it's not really existential.
03:52:16 <alang_> Rc43: well if you want [2,1] and [1,2] to be distinct, then your answer seems right
03:52:21 <edwardk> i was simplifying slightly =P
03:53:07 <shachaf> It would be nice if GADT syntax was simplified enough that the regular syntax had no brevity advantage over it.
03:53:33 <edwardk> now, this gives you a usable form of what you ask for, and it'll even work.
03:53:51 <Rc43> alang_, reordering isn't important for me, because I am trying to calculate N and give it to user with a function which given i from [1..N] returns i'th decomposition.
03:54:00 <edwardk> but i maintain that the right answer is to keep the constraint there in those couple of critical functions
03:54:19 <edwardk> otherwise you lose a LOT of functionality very easily
03:54:22 <shachaf> E.g. you used to be able to say data Foo a where { Blah { x :: Int, y :: Int } :: Foo Int }
03:54:22 <Rc43> alang_, and it seems to be simple without reordering.
03:54:45 <edwardk> e.g. with data Foo a = Ord a => Foo a -- you can't make Foo an instance of Functor, Foldable, Traversable, Applicative, Monad, ....
03:55:02 <edwardk> and as you get better at Haskell youll find you want those things more and more often!
03:55:14 <Chathurga> Ah right I'll go with the first answer then
03:55:23 <edwardk> =)
03:55:43 <Rc43> alang_, but maybe just a lazy list is the simplest
03:55:49 <Chathurga> As long as I know I'm not being needlessly verbose but rather more correct!
03:56:13 <edwardk> i just didn't want you to feel i was blowing off your desires in exchange for an academic 'but you shouldn't do that' bit of prescriptivist nonsense ;)
03:56:21 <edwardk> exactly =)
03:56:45 <Chathurga> Honestly after 5 years of JS and PHP I think I want more nos
03:56:53 <edwardk> ahahaha
03:56:56 <edwardk> well said
03:57:37 <jamil_1> edwardk: any pointers on comparison between type theoy and set theory ?
03:58:47 <b__> why does ghc suggest (for example for an alias of const) konst :: forall t t1. t -> t1 -> t, whereas :t const shows const :: a -> b -> a?
03:59:33 <edwardk> sure, go dig up something on per martin loef type theory. http://en.wikipedia.org/wiki/Intuitionistic_type_theory
04:00:17 <shachaf> hi alang_ :-)
04:01:00 <edwardk> what you'll find is that type theories/systems are almost all intuitionistic ('constructive') -- which is great since you can program with them, but bad because you can't prove everything you are used to proving in them
04:02:04 <jamil_1> edwardk: right, I am currently learning a set theory based declarative language
04:02:08 <shachaf> Where would partsOf belong in the lens hierarchy?
04:02:25 <edwardk> shachaf: in theory it works with Fold now
04:02:30 <jamil_1> edwardk: called Alloy http://alloy.mit.edu/alloy/
04:02:39 <edwardk> well, i guess it also works with Getter, etc. ;)
04:02:40 <bitonic> edwardk, jamil_1: you can still do classical proofs but you can’t extract programs from them
04:02:45 <edwardk> i wouldn't include it in the diagram though
04:02:54 <shachaf> No, but I was wondering.
04:02:57 <edwardk> the diagram skips a lot of functions
04:03:05 <shachaf> You can also set with it.
04:03:06 <jamil_1> edwardk: I was wondering how can we compare expressive power of lanagues based on set theory and those based on type thoery
04:03:17 <edwardk> i'd probably put it down under fold
04:03:33 <edwardk> and then copy it to traversal, showing the more liberal type
04:03:51 <bxx> why does map (map (+10)) [] work but map (fmap (+10)) [] doesn't?
04:04:28 <bitonic> jamil_1: what’s a language based on set theory?
04:04:30 <shachaf> > map (fmap (+10)) []
04:04:32 <edwardk> jamil_1: #agda or ##logic might be a better forum with folks who are interested in those questions. in practice i don't think it makes much of a difference. if its a language, you have certain inherent constructive limitations =P
04:04:32 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
04:04:32 <lambdabot>    arising from a use of `M66736226...
04:04:38 <shachaf> > map (fmap (+10)) [] :: [Maybe Int]
04:04:40 <lambdabot>   []
04:04:45 <bxx> ahh
04:04:46 <bxx> thanks
04:05:15 <edwardk> now within that framework you may have limitations of course, if you want to prove things you usually toss out turing completeness pretty early on =P
04:06:29 <shachaf> @quote kmc howard
04:06:30 <lambdabot> kmc says: "Haskell is great, because Curry-Howard!  Proving things in the type system.  We can prove that, uh, Ints exist, unless they're ⊥."
04:07:40 <jamil_1> bitonic: where each value belongs to a set rather a type
04:08:15 <bitonic> jamil_1: it really depends what you are trying to do anyway.  depending on what you want to prove your type theory might lose good proprieties on the computational side of things
04:08:57 <jamil_1> bitonic: any good reference to read about the limitations ?
04:09:02 <bitonic> for example in intensional type theories you can’t prove that `forall x. f x = g x -> f = g'
04:09:14 <bitonic> jamil_1: mhm I’d suggest ttfp
04:09:16 <bitonic> @where ttfp
04:09:17 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
04:09:58 <jamil_1> bitonic: thanks
04:09:59 <bitonic> jamil_1: there you’ll learn why you’re going to have a constructive logic and why you can’t have extensionality (what I was referring above), for example
04:11:14 <bitonic> where “can’t” means “can’t if you want a well behaved theory computationally” :P
04:11:43 <jamil_1> and "well behaved theory" is ?
04:12:07 <bitonic> jamil_1: something where proofs correspond to terminating programs, for example
04:12:26 <bitonic> or something where proofs correspond to programs, period
04:13:21 <jamil_1> right
04:13:36 <bxx> how do I fix these errors?  http://hpaste.org/78148
04:14:04 <bitonic> bxx: why the `fmap'?
04:14:24 <bxx> fmap works with Maybe
04:14:44 <Philonous> bxx:  It should either be (a -> b) -> [Maybe a] -> [Maybe b] or you need to loose the fmap
04:14:53 <shachaf> bxx: f already works with Maybe
04:15:47 <bxx> oops, yes dropping maybe works
04:17:13 <bitonic> jamil_1: I don’t know how much you know about Curry-Howard, but it’s quite easy to see that `forall a. a \/ -a' does not have a corresponding program, while for example `forall a b c. (a -> b) -> (b -> c) -> (a -> c)' does
04:18:09 <shachaf> bitonic doesn't believe in continuations. :-(
04:18:10 <jamil_1> former one is law of excluded middle right
04:18:33 <jamil_1> and later one is function composition ?
04:18:41 <bitonic> jamil_1: yes.  logics without EM are called intuitionistic/constructivist
04:18:44 <bitonic> jamil_1: yep
04:19:19 <jamil_1> so, can we have type theory which is not constructive ?
04:19:27 <bitonic> jamil_1: not having EM also implies not having double negation, and not having all formulas equivalent to EM in general :P
04:19:47 <bitonic> jamil_1: well you can postulate EM, but you won’t be able to compute proofs that use it
04:19:54 <bitonic> because it has no computational meaning
04:20:04 <jamil_1> so how do people get around this ?
04:20:40 <jamil_1> it seems that proofs contradiction are out
04:20:48 <jamil_1> *by*
04:21:09 <bitonic> jamil_1: no, they’re not, you still have `forall a. _|_ -> a’
04:21:39 <jamil_1> _|_ is bottom ?
04:22:01 <bitonic> and most of the times you don’t need EM.  if you really do you can embed it but again it won’t compute, there are papers about this, like “Classical Mathematics for a Constructive World” by roconnor
04:22:05 <jamil_1> i.e false -> a
04:22:15 <bitonic> but I don’t know much about that, I am interested in the programming side mostly
04:22:32 <bitonic> jamil_1: yeah _|_ is the type with no inhabitants, or falsity in logic
04:23:25 <bitonic> there was also some other shorter paper by Martin Escardo about classical proofs in ITT, I think.  but again I don’t know much.
04:24:04 <shachaf> twanvl++ # patch
04:24:17 <jamil_1> you don't know much but you can cite papers :P
04:24:27 <bitonic> jamil_1: I read abstracts :P
04:25:22 <bitonic> anyway TTFP is a good start, I think.  you can also read one of the Coq books/courses, like the Chipatla one or the Pierce one
04:25:55 <bitonic> this <http://adam.chlipala.net/cpdt/> and this <http://www.cis.upenn.edu/~bcpierce/sf/>
04:26:05 <bitonic> I can’t spell Chlipala
04:27:15 <jamil_1> content of TTFP looks really good/relevant
04:27:22 <jamil_1> TTFP seems like a good start
04:46:39 <Rc43> Can anybody look at my code?
04:46:41 <hpaste> Rc43 pasted “Summand decomposition (review)” at http://hpaste.org/78149
04:49:25 <parcs`> > 2^11 * logBase 10 2
04:49:27 <lambdabot>   616.5094311198334
05:07:30 <Iceland_jack> Is there a way of getting the types of arguments, interim variables or functions?
05:07:48 <luite> runtime? in the editor? where?
05:07:59 <Iceland_jack> possibly in ghci or in haskell-mode
05:08:14 <luite> yeah with ghc-mod
05:08:45 <Iceland_jack> Will it be obvious from Googling ghc-mod or do you have any reference materials?
05:09:06 <luite> it's a hackage package
05:09:20 <bxx> is there a differene between `ghc main' and `ghc --make main' ?
05:09:55 <shachaf> bxx: Not really, these days.
05:10:02 <shachaf> I think there's some small difference.
05:10:06 <shachaf> It used to be important.
05:22:09 <Philonous> --make is the default now AFAIK
05:24:39 <Philonous> bxx:  from the docs "This mode is the default if there are any Haskell source files mentioned on the command line, and in this case the ––make option can be omitted. "
05:25:13 <Philonous> (http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/modes.html)
05:35:47 <Eelis> what do i do if i need Traversable's mapM on a Data.Map except that the mapped function also needs to see the keys?
05:37:10 <luite> traverseWithKey in Data.Map ?
05:37:31 <Eelis> luite: that works with Applicative, not Monad
05:37:43 <luite> hm right
05:39:00 <Eelis> hm, maybe that's all i need though
05:39:04 * Eelis doesn't use Applicative often
05:39:44 <shachaf> Eelis: You can turn any Monad into Applicative
05:39:52 <Eelis> yeah, i just noticed IO is applicative, too :)
05:39:54 <Eelis> thanks!
05:40:36 <shachaf> lens has mapMOf which turns a traversal into a mapM
05:40:47 <shachaf> But I guess that's not relevant for you. :-)
05:47:15 <fmap> :t imapM
05:47:18 <lambdabot> (Monad m, TraversableWithIndex i t) => (i -> a -> m b) -> t a -> m (t b)
05:52:29 <beaky> hello
05:52:34 <beaky> does haskell have a debugger
05:55:40 <Philippa> beaky: There's a whole section in the GHC manual about the GHCi debugger, IIRC
06:10:51 <borkdude> I'm reading Real World Haskell, on page 144 the $ sign is introduced without explanation. Where do I find good examples of its use?
06:11:50 <shachaf> Hoogle probably has some documentation.
06:11:54 <shachaf> f $ x = f x
06:12:32 <tdammers> shachaf: that last one isn't exactly helpful, is it?
06:12:42 <tdammers> f $ g x = f (g x)
06:12:50 <borkdude> ok
06:13:10 <tdammers> (f . g) x
06:13:11 <borkdude> I get it, it's there to be explicit about grouping things?
06:13:20 <tdammers> sort of
06:13:22 <shachaf> tdammers: I was going to add but I got distracted hunting down the page in RWH. :-)
06:13:33 <tdammers> :)
06:13:52 <shachaf> Yes, they use $ without introducing it.
06:13:56 <borkdude> shachaf it's here: http://book.realworldhaskell.org/read/using-typeclasses.html and then search for putStrLn $ show [("hi", 1), ("there", 3)]
06:14:00 <shachaf> That's pretty terrible in an introductory book.
06:14:05 <tdammers> definitely
06:14:09 <shachaf> I don't think RWH is meant as an introductory book, though?
06:14:43 <aristid> shachaf: RWH also fails to introduce a number of other things
06:14:51 <aristid> it isn't 100% foolproof :D
06:15:11 * aristid remembers struggling with some chapters, but in the end it was very instructive anyways
06:16:12 <borkdude> so far it's been a good read
06:21:57 <Philippa> what does newtype deriving do when there are multiple plausible instances of a class to derive?
06:22:02 <Philippa> Does it give you the lot?
06:22:12 <Heffalump> what do you mean by plausible?
06:22:24 <Heffalump> AFAIK it just uses the instance for the underlying type with lots of coercions
06:22:39 <Philippa> ah, is it single parm classes only?
06:22:54 <Heffalump> ah, right. I think so.
06:23:20 <Heffalump> TBH it's so unsafe I wonder if it should exist at all, albeit that it is quite convenient!
06:23:35 <rwbarton> I think it gives you the one that involves your newtype as the last type class argument
06:23:47 <rwbarton> so in that sense, it is single parameter classes only
06:24:35 <Philippa> *RTFMs* yeah, except in this case that does give me what I want so long as it gives me /all/ instances satisfying that
06:24:55 <Philippa> (I want to lift through the equivalent of MonadState for several different state types)
06:25:04 <rwbarton> e.g. newtype PhilippaState s a = ... deriving (MonadState s)
06:25:11 <rwbarton> hm
06:25:15 <beaky> hello
06:25:15 <Heffalump> I'm not really clear what you mean by all instances.
06:25:18 <rwbarton> so like that, but no s variable on the left?
06:25:19 <Philippa> ah, yeah, I don't have so many that I need the wildcard
06:25:23 <rwbarton> oh
06:25:33 <rwbarton> you can list them, (MonadState s, MonadState s', ...), I think
06:25:51 <rwbarton> sorry, there "s" and "s'" are intended to be instantiated to particular types
06:25:54 <Philippa> yeah. It'd be nice to pick up the equivalent of MonadState *, but I can live without
06:26:00 <rwbarton> yeah, I see
06:26:02 <Philippa> (* not a kind, there!)
06:26:39 <rwbarton> what happens if you just write MonadState s? it might derive an instance "(MonadState s UnderlyingThing) => (MonadState s PhilippaState)"
06:27:08 <shachaf> Some parts of lens generate pretty terrible Core.
06:27:21 <shachaf> I bet rwbarton feels like fixing that.
06:27:29 <rwbarton> not today anyways
06:27:31 <shachaf> @ty indexed
06:27:33 <lambdabot> Indexed Int k => ((a -> Control.Lens.Internal.Indexing f b) -> s -> Control.Lens.Internal.Indexing f t) -> k (a -> f b) (s -> f t)
06:27:34 <rwbarton> sorry
06:27:37 <shachaf> How hard can it be?
06:27:54 * shachaf should go to sleep.
06:28:12 <Philippa> rwbarton: huh. The spec in TFM reads like that should work, might try it in a bit
06:28:18 <borkdude> nice question on SO http://stackoverflow.com/questions/940382/haskell-difference-between-dot-and-dollar-sign
06:28:30 <borkdude> (referring back to the $)
06:28:38 <Philippa> Heffalump: sorry if I've not cleared up what I meant sufficiently btw - any ambiguities you reckon I might want to know about?
06:29:42 <Heffalump> I think I understand what you meant now.
06:30:09 <Heffalump> it's unsafe (a) with associated types and (b) with abstraction layers
06:30:33 <Heffalump> for example with (a) you can trick it into coercing Int to Bool if the associated type for the underlying type is Int and for the newtype is Bool
06:30:50 <shachaf> I think you can do it with GADTs too.
06:30:55 <mutha> is there an interactByLine function in standard library? I find that I repeat interact + unlines / map / lines pattern almost every time I use interact
06:30:56 <Heffalump> and (b) you can get it to coerce Set Int into Set (Down Int) or whatever without reversing the internal representation
06:31:25 <Philippa> mmm. I'm happy for it to only work where there aren't any coercion constraints involved
06:31:35 <Philippa> but yeah
06:31:37 <borkdude> why do I need parenthesis around the anonymous function in this expression? \x -> x + 1 $ 2
06:31:55 <Philippa> because $ is an ordinary operator
06:32:18 <elliott> borkdude: just like (\x -> x + 1) isn't ((\x -> x) + 1) but (\x -> (x + 1)), your example is (\x -> ((x + 1) $ 2))
06:32:48 <borkdude> ah, tnx
06:36:34 <Peaker> interesting, I have a module that GHC 7.6.1 can compile with -O2 but hangs when trying to compile it with -O0
06:37:02 <hpc> huh
06:37:21 <hpc> if you can reduce it to a simple test case, it could be an infinite loop?
06:37:27 <rwbarton> well done :)
06:37:56 <shachaf> Peaker: Sounds like the optimizer is doing a great job.
06:38:43 <Peaker> hpc, I can try...
06:45:09 <beaky> what is the most convoluted type signature you guys have encountered
06:45:13 <beaky> :t (***)
06:45:15 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
06:45:21 * Peaker is slowly deleting stuff from the .hs file to see what makes it hang
06:45:25 <atriq> :t partsOf
06:45:26 <beaky> :t (->)
06:45:27 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
06:45:28 <lambdabot> parse error on input `->'
06:45:35 <Peaker> @type _2
06:45:36 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
06:45:49 <beaky> O.o
06:46:00 <atriq> lens has some really weird type signatures
06:46:15 <beaky> :t liftM5
06:46:17 <lambdabot> Monad m => (a1 -> a2 -> a3 -> a4 -> a5 -> r) -> m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m r
06:46:27 <beaky> how do you use that
06:46:27 <atriq> I think it may have been better to ask, "what is the most convoluted type signature you guys have encountered, excluding lens?"
06:46:56 <atriq> :t liftM5 (,,,,)
06:46:58 <lambdabot> Monad m => m a1 -> m a2 -> m a3 -> m a4 -> m a5 -> m (a1, a2, a3, a4, a5)
06:47:03 <beaky> oh
06:47:05 <eikke> beaky: that liftM5 should be obvious, but might be easier to "get" liftM2
06:47:23 <atriq> > liftM5 (,,,,) "abc" "def" "ghi" "jkl" "mno"
06:47:25 <lambdabot>   [('a','d','g','j','m'),('a','d','g','j','n'),('a','d','g','j','o'),('a','d'...
06:47:26 <beaky> liftM is essentially fmap
06:47:42 <aristid> atriq: or, what is the most convoluted type signatures you have generated yourself - would be another nice question ;)
06:47:52 <atriq> Ooh, I've got a good one
06:48:11 <eikke> beaky: "given a function f of arity N, liftMN will take N monadic actions, fetch their 'result', and pass it to f, then return it inside the monad"
06:48:21 <beaky> ah
06:48:22 <atriq> tumblrPosts :: (HasAPIKey k, MonadBaseControl IO m, MonadResource m, MonadReader k m) => BaseHostname -> Maybe PostType -> Maybe Int -> Maybe String -> Maybe Int -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe PostFilter -> Manager -> m Value
06:48:38 <beaky> so liftMN is very powerful
06:48:39 <atriq> I'm in the process of refactoring that function a lot
06:48:45 <beaky> @src liftM2
06:48:46 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:49:30 <Philippa> aristid: or "how bad would it be if you ditched your newtypes?"
06:49:37 <beaky> @src liftM2 (&&) (>1) (<2)
06:49:38 <lambdabot> Source not found. Take a stress pill and think things over.
06:49:44 <aristid> Philippa: i know! i'd just use data
06:49:45 <beaky> > liftM2 (&&) (>1) (<2) 3
06:49:47 <lambdabot>   False
06:49:49 <eikke> zrevrangebyscoreWithscoresLimit :: RedisCtx m f => ByteString -> Double -> Double -> Integer -> Integer -> m (f [(ByteString, Double)])
06:50:28 <mm_freak_> that looks like the Direct3D API
06:51:38 <aristid> eikke: the worst port is the inconsistent capitalisation
06:52:27 <aristid> this would be my contender for now: unsafeAws :: (ResponseConsumer r a, Monoid (ResponseMetadata a), Loggable (ResponseMetadata a), SignQuery r) => Configuration -> ServiceConfiguration r NormalQuery -> HTTP.Manager -> r -> ResourceT IO (Response (ResponseMetadata a) a)
06:52:58 <Philippa> beaky: you only actually need liftM and ap, aka <$> and <*> when both're defined
06:53:21 <eikke> aristid: ZREVRANGEBYSCORE is a Redis command and the lib API keeps all of those lowercase at all times. The command takes some optional arguments, so the lib API has actions for these different argument combinations, and uses Camelcase to distinguish those, it seems
06:53:50 <hpaste> Peaker pasted “Minimal example that sends ghc 7.6.1 (-O0) into a loop” at http://hpaste.org/78150
06:53:58 <aristid> eikke: yes, i'm not sure if that's the best way to go
06:54:11 <Peaker> can someone try compiling this with same ghc to reproduce, or with older ghc as well?
06:54:33 <rwbarton> this code is making me loop as well :)
06:54:48 <Peaker> rwbarton, which ghc version?
06:54:53 <rwbarton> not ghc, me
06:54:57 <Peaker> heh
06:55:04 <eikke> aristid: I don't know, only been using the lib since yesterday so I don't really have an opinion yet :-) and it looks like it's the only maintained redis lib around...
06:55:09 <rwbarton> btw ghc -O0 ignores {-# UNPACK #-} so that may be relevant
06:55:12 <Peaker> rwbarton, it's not actual code, it's a reduction of hundreds of lines of real code into these only :)
06:55:30 <Peaker> rwbarton, if I remove the UNPACK pragma, it doesn't loop
06:55:31 <aristid> eikke: who's the author?:)
06:55:44 <eikke> aristid: Falko Peters
06:55:56 <Peaker> I guess bug report it is
06:56:46 <danr> Peaker: it loops on my ghc 7.6.1 as well, but only with -O2
06:56:51 <danr> -v says it's in the typechecker/renamer
06:57:06 <danr> err--- but only with -O0
06:57:19 <Peaker> Doh! Pressed Ctrl-R on an HTML form by accident, lost everything I entered
06:57:27 <danr> Peaker: drat!
06:57:28 <Peaker> danr, yeah, same as here
06:58:19 <mm_freak_> Peaker: happened with Ctrl-W a few times for me (emacs user)
06:58:51 <Peaker> mm_freak_, though if you Ctrl+Shift+T to restore tab after that, you can usually get your form back
06:58:53 <rwbarton> Peaker: doesn't loop for me with -O0 with ghc 7.4.2 (I added a "main = return ()")
06:58:54 <Peaker> after reload, I don't think you can
06:59:03 <rwbarton> so it looks like a regression
06:59:06 <Peaker> rwbarton, if I remove any of the loop-causing things I get that error about main too
06:59:20 <eikke> Peaker: with -O0, loops in 7.6.1, not with 7.0.4 or 7.4.1
06:59:31 <Peaker> eikke, thanks
06:59:32 <rwbarton> right, okay, then it doesn't loop without the main either
06:59:37 <rwbarton> in 7.4.2
06:59:54 <fryguybob> Peaker: I can't get it to loop with my 7.6.1
06:59:56 <mm_freak_> Peaker: i don't keep my browser windows open forever like most people do…  most windows are really short-lived for me…  in other words, chances are that Ctrl-Shift-T/N won't restore the tab
07:00:13 <eikke> Peaker: I did add a "module Main where" and "main = return ()" for ghc --make to be happy
07:00:48 <Peaker> fryguybob, do you run: ghc7.6.1 -O0 file.hs ?
07:01:21 <fryguybob> Peaker: Yes, my 7.6.1 was built from the 7.6 branch on 10-27
07:01:39 <danr> I'm using 7.6.1 built for Arch Linux
07:06:40 <Peaker> simpler reproducing example now
07:06:47 <Peaker> http://hackage.haskell.org/trac/ghc/attachment/ticket/7446/Data.hs
07:09:39 <Peaker> hah, much simpler now: data V = V {-# UNPACK #-} !L ; data L = L V
07:10:23 <eikke> I can imagine the compiler has a hard time getting that to work
07:10:31 <Peaker> or even: data V = V {-# UNPACK #-} !V
07:10:40 <Peaker> but the former is "legal"
07:13:11 <hpaste> Peaker annotated “Minimal example that sends ghc 7.6.1 (-O0) into a loop” with “Minimal example that sends ghc 7.6.1 (-O0) into a loop (annotation)” at http://hpaste.org/78150#a78151
07:15:33 <aninhumer> Hmm "Could not deduce (At Name (M.Map Name))", M.Map is definitely Data.Map, and Name definitely has an Ord instance, not sure what's wrong
07:15:43 <aninhumer> This is in Control.Lens
07:16:06 <rwbarton> :t at
07:16:08 <lambdabot> (Functor f, At k m, Indexed k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))
07:16:30 <parcs`> Peaker: does the last annotation loop with -O2 ?
07:16:40 <eikke> :i At
07:16:47 <eikke> oh :(
07:17:17 <aninhumer> Notably :info At doesn't list any instances for me in ghci, not sure if it's supposed to
07:17:59 <int-e> Peaker: interesting. besides the loop it's also strange that with -O1, ghc deems the UNPACK pragma to be useless.
07:19:59 <mutha> is there an interactByLine function in standard library? I find that I repeat interact + unlines / map / lines pattern almost every time I use interact
07:21:06 <parcs`> Peaker: it doesn't loop in ghc 7.7
07:21:19 <byorgey> mutha: no, but you can write yourself one =)
07:21:34 <Peaker> parcs`, I only get loops with -O0 on 7.6.1, not on any other optimization level
07:21:38 <byorgey> put it in a file called MuthaFunctions.hs
07:22:03 <Saizan> aninhumer: :i Map should list instance Ord k => At k (Map k)
07:22:47 <Saizan> aninhumer: otherwise it might be that you've two versions of containers installed
07:23:02 <mutha> byorgey: I have already, just wondered if I reinvented the wheel
07:23:48 <aninhumer> Saizan: Indeed I do, thanks
07:24:43 <aninhumer> I should perhaps not just upgrade random libraries without a good reason...
07:25:20 <aninhumer> Yeah fixed now, thanks
07:27:14 <hpaste> int-e annotated “Minimal example that sends ghc 7.6.1 (-O0) into a loop” with “why does the presence of the .hi file make a difference?” at http://hpaste.org/78150#a78152
07:28:24 <efraglebagga> hey, another newbie here. I thought I got the basics but have been bashing my head against the screen trying to understand what happens when I do "flip const 1 2" ?
07:28:56 <aninhumer> >flip const 1 2
07:29:05 <geekosaur> > flip const a b
07:29:07 <lambdabot>   b
07:29:25 <Heffalump> efraglebagga: the definition of 'flip' is flip f x y = f y x, and the definition of 'const' is 'const a b = a'
07:29:47 <Heffalump> efraglebagga: so, start from flip as it's the "outermost" thing, i.e. the first function that will be applied
07:29:48 <vraid> :t const
07:29:50 <lambdabot> a -> b -> a
07:30:02 <Heffalump> flip const 1 2 = const 2 1 -- from the definition of flip
07:30:03 <efraglebagga> mhm
07:30:09 <Heffalump> const 2 1 = 2 -- from the definition of const
07:30:39 <beaky> why is it so much faster to compute 100000!, but not sum [1..100000] ?
07:31:10 <Botje> @src sum
07:31:11 <lambdabot> sum = foldl (+) 0
07:31:17 <Botje> note foldl instead of foldl'
07:31:17 <beaky> @src product
07:31:18 <lambdabot> product = foldl (*) 1
07:31:22 <efraglebagga> ok, I was kinda guessing that that's the way it works, but then "reverse head [1..5]" fails
07:31:36 <Botje> efraglebagga: "reverse head" is nonsense
07:31:55 <geekosaur> :t flip
07:31:57 <lambdabot> (a -> b -> c) -> b -> a -> c
07:32:13 <geekosaur> :t reverse
07:32:15 <lambdabot> [a] -> [a]
07:32:18 <aninhumer> efraglebagga: flip operates on functions, reverse operates on lists, so you want: "head (reverse [1..5])" I'm guessing
07:32:20 <geekosaur> notice a difference there?
07:32:31 <efraglebagga> I know, but shouldn't flip take const as a first argument if reverse head is nonsense? as I understand flip const 1 2 = const ( flip 1 2 )
07:32:47 <geekosaur> efraglebagga, look at the type of flip, and the type of reverse
07:32:50 <Heffalump> efraglebagga: no, that's not right. It works like I described above.
07:32:59 <vraid> flip flips the arguments of the following function?
07:33:06 <geekosaur> evaluation goes by types, not by something happening to look vaguely similar
07:33:51 <aninhumer> efraglebagga: flip 1 2 is nonsense in the opposite way to reverse head :)
07:34:01 <vraid> efraglebagga: reverse works on lists, head returns a non-list
07:34:03 <efraglebagga> ok ok ok
07:34:05 <Heffalump> geekosaur: types don't drive evaluation
07:34:19 <Heffalump> they get erased before evaluation happens :-)
07:34:24 <efraglebagga> it just dawned on me, that I didn't understand what flip does and just guessed it's meaning
07:34:38 <geekosaur> Heffalump, they do to the extent that a sequence of tokens 'a b c d' has a meaning determined by the types of the tokens
07:34:48 <efraglebagga> sorry, about that
07:35:13 <vraid> > flip (-) 5 3
07:35:16 <lambdabot>   -2
07:35:17 <geekosaur> so I guess strictly speaking they drive parsing, not evaluation; but not sure I want to explain *that*
07:35:22 <Heffalump> geekosaur: I disagree, it's determined by the definitions of the tokens. The types are another thing that are determined by those definitions but are largely orthogonal.
07:35:36 <aninhumer> efraglebagga: what you were thinking of is more like swap
07:35:39 <aninhumer> :t swap
07:35:40 <lambdabot> (a, b) -> (b, a)
07:35:50 <Heffalump> the fixities do drive parsing, of course
07:36:15 <efraglebagga> aninhumer: yeah, I realised that now
07:36:15 <beaky> I love parsing
07:36:29 <vraid> > (-) $ swap 5 3
07:36:31 <lambdabot>   The function `Data.Tuple.swap' is applied to two arguments,
07:36:31 <lambdabot>  but its type `...
07:37:59 <aninhumer> > uncurry (-) $ swap 5 3
07:38:01 <lambdabot>   The function `Data.Tuple.swap' is applied to two arguments,
07:38:01 <lambdabot>  but its type `...
07:38:11 <aninhumer> > uncurry (-) $ swap (5,3)
07:38:12 <lambdabot>   -2
07:38:17 <vraid> thanks!
07:41:38 <vraid> > curry swap 5 3
07:41:40 <lambdabot>   (3,5)
07:42:07 <sipa> :t uncurry
07:42:09 <lambdabot> (a -> b -> c) -> (a, b) -> c
07:42:37 <sipa> > uncurry id $ curry swap 5 3
07:42:38 <lambdabot>   3
07:43:02 <vraid> :t id
07:43:04 <lambdabot> a -> a
07:43:27 <sipa> @pl \x y -> uncurry id $ curry swap x y
07:43:27 <lambdabot> (uncurry id .) . curry swap
07:44:13 <sipa> :t (\x y -> uncurry id $ curry swap x y)
07:44:14 <lambdabot> b -> (b -> c) -> c
07:45:19 * hackagebot hledger 0.19.2 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.19.2 (SimonMichael)
07:47:02 <TomHashNL> meow
07:47:27 <TomHashNL> can I combine 2 parsers with <*> ? It's giving me an error =P
07:47:56 <ion> Yes.
07:48:08 <TomHashNL> *Main> :t (second <*> second)
07:48:14 <atriq> Yes, but not in the way you think
07:48:17 <TomHashNL> Couldn't match expected type `a0 -> b0' with actual type `Second'
07:48:29 <ion> (,) <$> second <*> second
07:48:31 <ion> second <* second
07:48:33 <ion> second *> second
07:48:34 <TomHashNL> hmm
07:48:38 <TomHashNL> that sounds obvious xD
07:48:56 <TomHashNL> thanks bro's /pro's
07:49:13 <atriq> No problem
07:49:25 <mutha> how do a make a module that can be imported from everywhere, not just from files in the same directory?
07:49:26 <atriq> Why am I saying that
07:49:30 <atriq> ion did all the hard work
07:49:33 <atriq> Well done, ion
07:50:19 * hackagebot hledger-web 0.19.1 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.19.1 (SimonMichael)
07:50:39 <geekosaur> mutha, it needs to be registered with the compiler.  The easiest way to do that is to use cabal to build and install the module; see http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
07:50:40 <ion> The first one parses as ((,) <$> second) <*> second, in which (,) <$> second has the type Parser (Something -> (Something,Something)) and second has the type Parser Something, which is exactly what <*> accepts as parameters.
07:50:57 <mutha> geekosaur: thanks
07:51:22 <TomHashNL> thnx =]
07:51:28 <geekosaur> or more detail at http://www.haskell.org/cabal/users-guide/developing-packages.html
07:51:49 <ion> <*> draws the function Foo -> (Foo,Foo) out of the first parser, a Foo out of the second one and returns a parser of (Foo,Foo)
07:52:02 <ion> in which the result of the first one has been applied to the result of the second one
07:52:42 <zrxy> There seem to be several options for tab-completion of functions, types, etc. Is there a best one?
07:52:56 <TomHashNL> ^__^ awesome
07:53:01 <shapr> zrxy: What are the options?
07:53:15 <ion> pa <* pb = (\a _ -> a) <$> pa <*> pb
07:53:22 <ion> pa *> pb = (\_ b -> b) <$> pa <*> pb
07:53:51 <TomHashNL> hmm good =]
07:54:45 <zrxy> shapr: ghc-mode, haskell-emacs, haskell-mode with flags
07:55:06 <zrxy> ... and static TAGS file
07:55:25 <zrxy> ... and ghc-mod
07:55:27 <shapr> zrxy: Oh, how can I do tab completion from a TAGS file? I'd love that!
07:56:06 <zrxy> shapr: I was looking at http://stackoverflow.com/questions/3424697/haskell-autocompletion-in-gnu-emacs/3427712#3427712
07:56:50 <zrxy> I would much prefer actual queries to ghci for completion
07:57:07 <zrxy> as Lisp/slime does
07:57:21 <zrxy> does that exist?
07:57:54 <shapr> Does ghc-mod do that?
07:58:37 <shapr> Seems like it would be easy enough to generate a Haskell source file that has all the current imports, and then run :info or something to ask about everything that's in scope.
07:59:16 <JuanDaugherty> easy enough
08:00:14 <zrxy> I don't know anything about any of the completion stuff.
08:00:27 <shapr> zrxy: I mostly use hippie-expand, which is an extended meta-dabbrev-expand.
08:00:50 <shapr> I use it to the point that I've rebound capslock to hippie-expand :-)
08:03:08 <shapr> zrxy: dabbrev-expand and hippie-expand are not language specific, so I use them everywhere. I don't know about haskell-specific options.
08:03:13 <zrxy> shapr: I thought you were making a meta joke until I looked up hippie expand. That goes off static data, right? No ghci queries?
08:04:11 <shapr> hah, that does sound like a meta joke in retrospect
08:04:36 <atriq> Control.Lens.TH could do with some better docs...
08:06:04 <hpaste> shapr pasted “hippie-expand config” at http://hpaste.org/78153
08:06:07 * JuanDaugherty has a hard time seeing how that's useful, compared to something like intellisense, is the database of disambig actually manually input?
08:07:08 <zrxy> After I define a function blah x y z, I want the emacs mini-buffer to show "blah x y z" after I type "blah".
08:07:23 <JuanDaugherty> but yeah something like that for Haskell would be something
08:07:25 <shapr> You want docs? or intellisense-style completion?
08:07:37 <fmap> atriq: patches are always welcome ;)
08:07:37 <zrxy> ... and highlight the x and y and z as I type them -- this is basic lisp/slime functionality
08:07:38 * `nand` wants automatic docs, but no completion
08:07:39 <shapr> There's eldoc-mode, but that's static info
08:08:16 <JuanDaugherty> umm, if it's my option full bore intellisense, maybe hooked up to leksah or what have you
08:10:25 * hackagebot hledger-lib 0.19.3 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.19.3 (SimonMichael)
08:10:27 * hackagebot hledger 0.19.3 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.19.3 (SimonMichael)
08:10:29 * hackagebot hledger-web 0.19.3 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.19.3 (SimonMichael)
08:11:50 <shapr> zrxy: If you find something interesting about tab completion of Haskell functions, I'd like to hear about it!
08:12:57 <atriq> fmap, the biggest problem for me writing a patch to add docs for that is I have no idea how it works
08:13:08 <neutrino_> shapr: what editor do you use?
08:13:42 <shapr> neutrino_: I use emacs
08:13:46 <shapr> neutrino_: What do you use?
08:13:52 <neutrino_> i mostly use vim
08:13:55 <tomboy64> which package would you guys recommend for cli-options-parsing?
08:14:05 <neutrino_> i made a thing for it where you can look up the manual for a function on hackage
08:14:10 <neutrino_> if you press K
08:14:14 <shapr> Oh that's neat.
08:14:17 <neutrino_> yeah
08:14:24 <neutrino_> it uses lynx and some hackery
08:14:34 <shapr> I wish there were an easy way to look up functions locally in my ~/.cabal/ dir
08:14:40 <shapr> That is, look up the docs there.
08:14:42 <neutrino_> it actually uses a python script in a bash command in a python script in a vim script.
08:14:46 <shapr> ha
08:14:48 <neutrino_> because you couldn't make it any easier.
08:14:52 <dcoutts_> shapr: you can use hoogle locally
08:14:59 <shapr> Oh that's a good idea.
08:15:10 * shapr installs hoogle
08:15:13 <neutrino_> the idea is to use hoogle nonlocally
08:15:17 <neutrino_> by the way,
08:15:32 <neutrino_> doing this i found out that you can have lynx execute system commands
08:15:39 <shapr> That's scary.
08:15:50 <dcoutts_> shapr: also, does the haddock contents contain a full list for all packages, or is it that just a full list of modules?
08:15:51 <neutrino_> you can build a whole graphical shell using html.
08:16:33 <neutrino_> shapr: you have to enable it explicitly btw
08:16:44 <neutrino_> just so you know :-)
08:17:11 <neutrino_> anyways it's pretty neat using lynx for online docs lookup because it integrates so well.. it's like an alternative to manpages.
08:17:45 <neutrino_> don't need to break your flow and use kludgy gui browsers with their modeless interfaces and thousands of font sizes.
08:18:29 <`nand`> neutrino_: you may be interested in firefox
08:19:19 <tdammers> `nand`: isn't firefox like the exact opposite of lynx?
08:19:40 <neutrino_> `nand`: i'm not interested in firefox
08:19:41 <neutrino_> :p
08:19:46 <tdammers> also, getting lynx to execute system commands is like a beginner's exercise
08:20:07 <shapr> tdammers: huh?
08:20:08 <neutrino_> how would you do that tdammers
08:20:14 <tdammers> simple
08:20:16 <tdammers> go to settings
08:20:17 <neutrino_> how
08:20:25 <tdammers> change the "editor" setting to something malicious
08:20:34 <`nand`> tdammers: well, judging by the two desires he implied it seems to be a good fit
08:20:48 <tdammers> sure
08:21:00 <tdammers> it's not dangerous for the user
08:21:01 <neutrino_> that's not a beginner's exercise, that's a beginner's approach to solving something that already has explicit support
08:21:03 <neutrino_> :P
08:21:14 <tdammers> I meant, a beginner's exercise in hacking
08:21:17 <`nand`> I can hardly tell the difference between firefox and a terminal these days; except of course for the fact that it displays images as well
08:21:31 <tdammers> e.g., when sysadmins try to restrict your account by setting your shell to lynx
08:21:34 <neutrino_> `nand`: but firefox uses so many font sizes
08:21:52 <tdammers> neutrino_: you can disable that
08:21:56 <neutrino_> tdammers: lol, those must be some lame admins
08:22:11 <tdammers> used to be commonplace a few years ago
08:22:15 <`nand`> neutrino_: only uses one for me
08:22:27 <tdammers> on shared hosting services and such
08:22:33 <neutrino_> `nand`: the only font size i accept as valid is "half-width"
08:23:06 <tdammers> also, a Real Mens' Web Browser is netcat
08:23:15 <`nand`> neutrino_: it respects fontconfig settings and whatnot, you can force everything to live in the exact fonts you want them to
08:23:42 <shapr> tdammers: Good luck with that :-)
08:23:45 <`nand`> for example, I force everything to be terminus-12; though I allow fallbacks for unicode characters and such. I also allow full-width characters, because cjk
08:24:04 <`nand`> terminus-14 I think actually, I keep forgetting
08:31:44 <danr> is there no javascript engine in lynx?
08:34:23 <geekosaur> not by default, at least
08:34:50 <geekosaur> maybe try links/elinks?
08:36:13 <int-e> elinks, as an experimental feature. http://elinks.or.cz/features.html
08:36:28 <danr> interesting, thanks
08:43:54 <JuanDaugherty> so hoogle integrated with yi oder woulda been the thing
08:45:26 * hackagebot yesod-fay 0.1.0.3 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.0.3 (MichaelSnoyman)
08:45:56 <beaky> I love Haskell
08:46:02 <beaky> how do I develop a GUI using it
08:46:07 <atriq> Hehe
08:46:22 <atriq> Many have ventured down that path, and returned horribly scarred
08:46:29 <atriq> More seriously, you've got a few choices
08:46:34 <beaky> :(
08:46:39 <atriq> Depending on how high-level you want
08:46:47 <beaky> interesting ot do a GUI in a purely-functional manner
08:47:00 <atriq> http://www.haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries
08:48:50 <atriq> beaky, also, have a look at http://www.haskell.org/haskellwiki/Reactive-banana
08:50:27 * hackagebot http-conduit 1.8.4.2 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.4.2 (MichaelSnoyman)
08:53:16 <neutrino_> danr: i'm not sure, i think probably not
08:53:34 <neutrino_> danr: i prefer lynx as a generally better browser than [e]links
08:58:49 <mzero> am I right in thinking that MonadError (from mtl) hasn't caught up with extensible exceptions in Control.Exception?
08:59:25 <edwardk> mzero: correct. its not clear what the right thing would be to do to better interact with the exception hierarchy
09:00:05 <bxx> is there something like words that keeps quoted substring intact?
09:00:28 <mzero> hmmm.... sigh! I have a monad stack transformer that sits on top of a monad that may, or may not, be IO --- I want to provide exception handling - and was doing it with MonadError -- but that is a more impoversihed interface that Control.Exception
09:00:32 <edwardk> since most MonadError instances aren't crazy open Typeable-based hierarchies ;)
09:00:33 <mzero> and not sure how to proceed
09:00:55 <mzero> yeah - in my case, I'm abstracting IO (!)
09:01:17 <edwardk> http://hackage.haskell.org/package/MonadCatchIO-transformers is popular
09:01:21 <mzero> so I want to have all the joy... but I guess that I can't have pretty things today!
09:01:26 <JuanDaugherty> why would you program the end thing for a dev feature?
09:01:31 <edwardk> it plays nice with the mtl too
09:01:41 <JuanDaugherty> (such as MonadError)
09:02:02 <zrxy> I wish I could define stuff that is local to my instance block, like with a 'where' clause.
09:02:04 <edwardk> JuanDaugherty: ?
09:02:04 <mzero> edwardk: that looks perfect
09:02:16 <atriq> edwardk, I fixed the lens wiki for the bits things (issue #123)
09:02:23 <edwardk> atriq: thanks =)
09:02:40 <JuanDaugherty> edwardk, mean mzero
09:02:46 <JuanDaugherty> *meant
09:03:00 <edwardk> JuanDaugherty: i meant you. wasn't sure what you meant
09:03:10 <merijn> zrxy: Why not just define unexported functions in the module with the instance?
09:03:39 <edwardk> atriq: i'll copy the wiki edits to README.md
09:03:42 <JuanDaugherty> I meant that having the end program depend on MonadError seemed odd
09:03:56 <atriq> edwardk, :)
09:04:02 <edwardk> MonadError gets used in a lot of code in libraries, user packages, etc.
09:04:13 <atriq> edwardk, btw, I'm "Taneb" on GitHub
09:04:15 <edwardk> ny time you want to have an exceptional case
09:04:19 <edwardk> k
09:04:19 <JuanDaugherty> as opposed to something like your suggestion or direct interaction with the exception pkg
09:04:20 <mzero> I'm not sure what JuanDaugherty meant either....   I'm writing a POSIX shell (!) and I want to be able to run the shell either in IO - or in a pure monad which never touches your system (can't as it isn't in IO!)
09:04:21 <atriq> And... pretty much anywhere except IRC
09:04:28 <zrxy> merijn: yes of course, I just half-expected "where" to work inside "instance".
09:04:49 <edwardk> JuanDaugherty: ErrorT has nothing to do with IO errors for instance
09:05:28 <mzero> so I have a typeclass PosixLike which has all the POSIX operations the shell (and utilities) use -- and there are instances for IO (mostly trivial) and for a TextExec environment ---- where I implement all of POSIX in pure Haskell (!!!!!)
09:05:31 <edwardk> JuanDaugherty: when you have a deep monad transformer stack, MonadError can be very handy
09:05:45 <mzero> okay - not _all_ -- just all that a shell and it's utilities need
09:05:51 <edwardk> MonadCatchIO is the generalization to the extensible extensions hierarchy
09:08:03 <mzero> zrxy: I've occasionally wanted that too...
09:09:32 <zrxy> I tend to see "where" more often than "let" -- is this true? "where" seems less natural to me, as it reverses the order of definitions.
09:09:55 <atriq> I tend to use "let" for values and "where" for functions
09:10:20 <JuanDaugherty> perhaps the production vs. development distinction is lost in Haskell
09:10:25 <edwardk> zrxy: where has the benefit that it doesn't require the awkward in terminator and it is traditionally used to move the "unimportant stuff"  out of the way so you can see the core operations being performed
09:10:47 <edwardk> in practice it gets used almost exclusively except when you can't ;)
09:11:05 <edwardk> JuanDaugherty: i really really have no idea how you see this as a production/development issue
09:13:12 <geekosaur> this is the coding style that says exceptions only happen during development, maybe?  (which mens utter hell for us systems types when the real world demonstrates otherwise, but production code "knows" there couldn't possibly be an exception there....)
09:13:33 <geekosaur> haskell doesn't like to let you get away with that kind of blinkered vision
09:14:39 <illissius> I'm reading the paper "Type are Calling Conventions" and there's this interesting tidbit: "[in GHC] since every heap object needs a header word to guide the garbage collector, it costs nothing to allow an evaluated Int to be enterable. In effect, a heap object of type Int can also be used to represent a value of type {Int} [an Int thunk], an idea we call auto-lifting."
09:14:47 <illissius> anyone know where I might read more about this, or what to search for? googling doesn't turn up much, maybe because GHC doesn't call it "auto-lifting"
09:15:10 <edwardk> this isn't for exceptions in the defensive programming sense. its not like turning on a bunch of conditional rules for checking your array bounds everywhere except in production where it matters. these are for things like file handles being closed, or killing a process or generally reading from something that isn't there
09:15:39 <edwardk> sure you _can_ write some conditional compilation flags to turn on debugging, etc. but that has absolutely nothing to do with the functionality provided by either of those two packages
09:16:19 <edwardk> We don't have much of the C 'assert-only-in-dev' defensive programming culture here.
09:17:30 <mzero> types are Haskell's assert!
09:17:38 <edwardk> mzero: there is that =)
09:18:07 <merijn> illissius: I've heard the term auto-lifting before, so I think that is the name used by GHC, but I don't know more
09:18:21 <merijn> illissius: Maybe try asking in #ghc?
09:18:32 <mzero> in any event - when coding a program that is primarily aimed at manipulating the user's system - exceptions are inevitable - and must be exposed
09:18:32 <atriq> assert-everywhere-all-the-time-otherwise-sjp-will-kill-you-in-your-sleep
09:18:50 <atriq> sjp is, of course, spj's evil twin
09:19:02 <atriq> And totally not a typo
09:19:09 <mzero> though, I agree, many of our System.Posix interfaces are a little to slavish to POSIX and use exceptions where Either or Maybe would have been more appropritate
09:19:39 <edwardk> its hard to do anything posix without allowing an entire universe of exceptions out, because there are a TON of corner cases there
09:19:39 <merijn> mzero: spoon is what you want to remedy that ;)
09:19:50 <merijn> :t spoon
09:19:52 <lambdabot> Not in scope: `spoon'
09:19:57 * JuanDaugherty was so dumbfounded, rocked back on his haunches but a "really really", that he was utterly silenced.
09:20:01 <merijn> That's what I expected :p
09:20:04 <merijn> @hoogle spoon
09:20:04 <lambdabot> package spoon
09:20:05 <lambdabot> package spoonutil
09:20:10 <bgamari> illissius, I think they are just referring to the fact that (almost) all values are lifted in GHC
09:20:13 <atriq> @hackage spoon
09:20:13 <lambdabot> http://hackage.haskell.org/package/spoon
09:20:14 <rwbarton> no, catch is what you want
09:21:06 <mzero> merijn:  that only handles haskell pure computation exceptions
09:21:06 <JuanDaugherty> *by a
09:21:08 <edwardk> if you assume you know all the exceptions almost any posix call can make, you're probably making a mistake ;)
09:21:29 <bgamari> illissius, By lifted, I mean that the value can be bottom (as the thunk may not terminate)
09:21:51 <illissius> merijn: in the few hits google did find which weren't the paper itself, it was used to refer to auto-lifting a pure computation to a monad, and to auto-lifting term-level things to type-level ones... but yeah, maybe I'll try asking there too
09:21:52 <edwardk> JuanDaugherty: heh, well, it was actually a typo/thinko, but it made my point pretty strongly so i left it ;)
09:22:10 <JuanDaugherty> :)
09:22:26 * JuanDaugherty afk, srsly
09:22:48 <Crockeo> edwardk: :O Your smileys match up
09:22:52 <Crockeo> this is sorcery.
09:23:18 <mzero> alas, edwardk is right - almost every POSIX function imaginable can error with any of a dozens of errors --- the POSIX way, of returning an special value result (-1, 0, NULL, etc..) and then looking at the global errno is not, thankfully, the way they were encoded in System.Posix
09:23:27 <mzero> instead, they are all turned into exceptions
09:24:03 <mzero> but sometimes I wish they had been    Either IOException a
09:24:35 <mzero> and in others maybe just      Maybe a    but that would have meant a judgement call for which calls is the error information never useful ---
09:24:53 <illissius> bgamari: I dunno, it's talking about runtime representations, and my reading is that somehow the presence of the extra header word for GC makes it possible for an evaluated-Int to look like an unevaluated-Int to things that were expecting a latter... but I don't see why/how or what the header word has to do with it all, which is what I'd like to read more about
09:25:02 <illissius> *the latter
09:25:03 <mzero> my own PosixLike abstraction makes some of these judgement calls... but I'm still refining it - and intend to make more
09:25:13 <mzero> perhaps I'll rename it   SanerPosixLike
09:25:27 <bgamari> illissius, Well, the point is that both evaluated and unevaluated thunks have the same representation
09:25:48 <edwardk> Crockeo: What, you mean you don't try to go out your way to ensure each smiley lines up with every other!? ;)
09:25:55 <beaky> >>=
09:26:16 <bgamari> (in my reading of the sentence)
09:26:18 <Crockeo> edwardk: Apparently it's just skill, then.
09:26:29 <Crockeo> edwardk: Also, howl ong did it take you to line that one up? :P
09:26:35 <edwardk> hahahaha
09:27:09 <edwardk> Crockeo: It is an art, a skill some of us are born to, and others hone carefully by typing replies in vim. ;)
09:27:13 <illissius> bgamari: but why is the header relevant..? :)
09:27:15 <shapr> haha
09:27:28 <hpaste> geekosaur annotated “xmobar config” with “xmobar config (fix template)” at http://hpaste.org/78155#a78156
09:27:49 <geekosaur> oops
09:28:34 <Crockeo> Just take 20 minutes to write a vim script then have magical ;)s everywhere.
09:28:39 <bgamari> illissius, It is written a bit strangely
09:29:08 <edwardk> Crockeo: I might just do that, for now I'll be lazy.                                                       ;)
09:29:45 <Crockeo> I'd say spamming spaces isn't lazy.
09:29:53 <mzero> awwwww. crap! Just realized that MonadIO m => MonadCatchIO m  ----  One of my two base monads _isn't_ MonadIO
09:30:01 <mzero> sunk and back to the drawing board
09:30:02 <bgamari> illissius, But I think the point is "we need this header for GC anyways, so let's also use it to denote unevaluated thunks and enjoy the benefits of having very natural lazy evaluation"
09:30:02 <mzero> fie
09:30:13 <edwardk> mzero: what do you use as base monads?
09:30:16 <bgamari> illissius, but I could be very wrong ;)
09:30:49 <mzero> I have two    IO    and     TestExec (which is a pure State monad)
09:31:19 <edwardk> ah, and MonadCatchIO needs to be able to lift IO actions to do things like bracket, etc.
09:32:13 <mzero> really - I just want bracket, finally and onException constructs ---- so I can provide those based on MonadError ---- but I realize they will be inferior to the ones in Control.Exception and MonadCatchIO
09:32:56 <illissius> bgamari: ah, could be. I always wondered how it could tell the difference between "pointer to an Int" and "pointer to a thunk that returns/evaluates to an Int", so maybe that's it (or maybe it's pointer-tagging or something else entirely)
09:33:15 <illissius> I'll ask #ghc
09:33:26 <k0ral> hey
09:33:42 <copumpkin> illissius: GHC just cares about pointer or non-pointer. There's a convention that all valid pointers point to a region of memory that has a description of some sort
09:33:51 <mzero> illissius: doesn't the STG Machine paper have all those details in it?
09:33:52 <copumpkin> I missed the context though
09:34:49 <edwardk> illissius: pointer tagging is only an aid to that discrimination its not required. you can 'jump into' an Int, and it evaluates to itself
09:34:53 <k0ral> to the gtk2hs maintainers: thank you for updating gtk to work with GHC 7.6, however, would you please check out why the pango package still oesn't compile ?
09:34:58 <edwardk> if its untagged that happens.
09:35:52 <illissius> mzero: possibly! I haven't read that yet, I'll check it out.
09:36:17 <fmap> k0ral: "doesn't compile"?
09:36:42 <mzero> ah - that paper is what gelled how it all works for me "The Spineless Tagless G-Machine" -- not sure different GHC is now from what is in that paper - but I think it is mostly still correct
09:36:50 <edwardk> an Int, gets represented by the int constructor (a pointer to the code that returns itself), and the payload int basically (plus rts overhead) the int constructor points to code, and the data describing the shape of the int constructor, which fields are data and which are ptrs is in that info table
09:37:35 <gwern> @quote
09:37:35 <lambdabot> saml says: For a couple of years, I used my real full name as an id. That didn't stop me from trolling. But, when people stopped replying to my comments, I stopped trolling. Just my experience.
09:37:48 <edwardk> the three best references i can think of for thinking about the RTS are the dynamic pointer tagging paper, the GHC code commentary and rob ennals' thesis. even though in that he is describing a complicated extension TO the RTS, he has to explain the existing one really well to get there.
09:38:47 <edwardk> i just find that by using my full name as my id, any trolling i do had better be high quality stuff, since people will be able to trace it back to me for decades.
09:41:47 <illissius> edwardk: sorry, I'm having trouble parsing this part "and the payload int basically (plus rts overhead) the int constructor points to code, and the data describing...", could you rephrase?
09:43:41 <copumpkin> illissius: all GHC-allocated memory on the heap has a little descriptor struct before it
09:43:46 <edwardk> illissius: in ghc each thunk is represented by a pointer to the code + info table, a forwarding pointer and by some environment data. so if i have a thunk that will evaluate to 2 + 3, it starts out as a pointer to code that will do that and replace the forwarding pointer wiht a pointer to the answer and then replace the code pointer with the 'follow the forwarding pointer' function ptr. ;)
09:44:29 <chersanya> hi all!) How to filter a monadic list? I mean such function: (a->b) -> m [a] -> m [a], and can't find it
09:44:39 <edwardk> the Int itself is a data constructor so the forwarding pointer isn't there (its already evaluated) so its just the code pointer in case someone asks you to evaluate it which happily just hands you back itself, and the actual machine integer.
09:44:50 <zrxy> Is there a plan to make 'deriving' extensible, or will it always be a special-case thing for certain classes?
09:45:18 <ion> chersanya: fmap . fmap
09:45:39 <neutrino_> chersanya: i think you meant b in the last bit
09:45:58 <neutrino_> yeah, what ion said.
09:45:59 <geekosaur> or they meant Bool instead of b
09:46:06 <geekosaur> in which case it;s fmap filter
09:46:08 <chersanya> neutrino_: i mistyped, Bool instead of b was meant
09:46:09 <geekosaur> roughly
09:46:10 <neutrino_> oh
09:46:16 <neutrino_> geekosaur: nice catch
09:46:26 <ion> Yeah, fmap . filter
09:46:41 <neutrino_> ion not fmap filter?
09:46:55 <ion> @type fmap . filter
09:46:56 <lambdabot> Functor f => (a -> Bool) -> f [a] -> f [a]
09:46:56 <geekosaur> no, it's fmap (filter foo) or fmap . filter
09:47:00 <ion> @type \f -> fmap (filter f)
09:47:01 <lambdabot> Functor f => (a -> Bool) -> f [a] -> f [a]
09:47:04 <neutrino_> mhm
09:47:20 <chersanya> thanks))
09:47:23 <neutrino_> @type fmap filter
09:47:25 <lambdabot> Functor f => f (a -> Bool) -> f ([a] -> [a])
09:47:30 <ion> chersanya: Just out of curiosity, are you from Russia?
09:47:37 <neutrino_> i was just going to ask
09:47:38 <neutrino_> haha
09:47:43 <chersanya> ion: yes))
09:48:02 <neutrino_> chersanya: around peter?
09:48:25 <ion> neutrino: Is this smiley thing that localized?))))))))))))))))))
09:48:31 <chersanya> neutrino_: no, near moscow - exactly Dolgoprudny, study in MIPT
09:48:46 <neutrino_> ion: almost))
09:48:53 <rwbarton> in soviet russia the colon key makes a close parenthesis
09:49:13 <edwardk> foo(self) { compute 2 + 3; result = new { action = int-constructor, env = 5 }, self->fwd; self->action = follow_fwd; return result on the ghc stack };  then 2 + 3 becomes { action = foo, fwd = null, … no environment, id didn't capture anything needed by foo }, evaluating that jumps into foo, which calculates the anwer, allocates it on the heap, and hands back a reference to it. evaluting it a second time, finds that follow_fwd thing
09:49:13 <edwardk>  just gives you back the ptr it is forwarded to as the answer. it was already solved.
09:49:16 <neutrino_> chersanya: nice. do they teach you to use haskell there?
09:49:31 <edwardk> thats pseudo-code, not the actual way its done
09:49:47 <chersanya> neutrino_: it would be interesting, but not
09:49:58 <neutrino_> chersanya: oh ok, why are you learning it then
09:50:01 <neutrino_> :)
09:50:08 <neutrino_> curiosity?
09:50:42 <chersanya> neutrino_: yes, mostly - it's so different, opposite to other (imperative) languages
09:51:34 <chersanya> btw, aren't closing parens used as smileys in other countries?
09:51:59 <edwardk> chersanya: depends on the country ^_^
09:52:11 <ion> I have seen this)))))))) only from Russia so far.
09:52:15 <quchen> (: Australia
09:52:36 <chersanya> ion: yes, here it's extremely popular
09:52:38 <efraglebagga> britain
09:53:05 <atriq> efraglebagga, nah, we need eyes to smiley
09:53:25 <quchen> A good way of evaluating the quality of a smiley is imagining Microsoft Sam reading it
09:53:31 <ion> atriq: And probably a single mouth?
09:53:35 <atriq> Nah
09:53:37 <atriq> ;
09:53:45 <efraglebagga> :
09:53:51 <atriq> B
09:53:52 <ion> quchen: soisoisoisoisoisoisoisoisoisoisoisoi
09:54:08 <efraglebagga> that twinkle in the eyes
09:54:44 <quchen> soi?
09:55:06 <quchen> I remember that he loved # (NumbrrSIIn)
09:55:17 <ion> quchen: http://youtu.be/3B0joNsmWUQ
09:55:20 <fmap> :t iso iso
09:55:22 <lambdabot> (Functor f1, Functor f, Isomorphic k1, Isomorphic k) => (((a -> s) -> k1 (a -> f1 a) (s -> f1 s)) -> s -> a) -> k (((a -> s) -> k1 (a -> f1 a) (s -> f1 s)) -> f ((a -> s) -> k1 (a -> f1 a) (s -> f1
09:55:23 <lambdabot> s))) ((s -> a) -> f (s -> a))
09:55:32 <ion> :t iso iso iso
09:55:34 <lambdabot>     Occurs check: cannot construct the infinite type:
09:55:34 <lambdabot>       a0
09:55:34 <lambdabot>       =
09:55:53 <quchen> ion: Haha, clever
09:56:04 <quchen> :t iso
09:56:05 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (a -> s) -> k (a -> f a) (s -> f s)
09:56:11 <quchen> The fuck
09:56:15 <edwardk> :t iso (+1) (-1)
09:56:17 <lambdabot> (Functor f, Num a, Isomorphic k) => k (a -> f a) (a -> f a)
09:56:22 <edwardk> :t 5 ^. iso (+1) (-1)
09:56:24 <lambdabot> Num b => b
09:56:27 <edwardk> > 5 ^. iso (+1) (-1)
09:56:29 <lambdabot>   6
09:56:32 <edwardk> > 5 ^. from (iso (+1) (-1))
09:56:34 <lambdabot>   -1
09:56:40 <edwardk> hahahaha
09:56:44 <ion> :-D
09:56:44 <edwardk> > 5 ^. from (iso (+1) (subtract 1))
09:56:45 <illissius> edwardk: ah, thanks! the "follow the forwarding pointer" function pointer was one of pieces I was missing. now I don't understand what the forwarding pointer is used for :-). things that aren't all like "evaluate yourself!" will instead check whether the forwarding pointer has been set and if so get the result directly?
09:56:46 <lambdabot>   4
09:56:54 <quchen> :i iso
09:57:03 <quchen> Hm.
09:57:09 <quchen> What module is iso coming from?
09:57:15 <quchen> Something with isomorphisms?
09:57:17 <ion> Data.Lens
09:57:22 <ion> err
09:57:23 <edwardk> illissius: you have to replace yourself with an answer, but the answer might be bigger than your closure so you can't over write it
09:57:24 <ion> Control.Lens
09:57:26 <edwardk> Control.Lens
09:57:47 <edwardk> an 'Iso' is a 'Lens'  you can run backwards
09:57:56 <edwardk> it composes with other lenses though with just .
09:58:04 <lispy> Snel?
09:58:11 <luite> even the forwarding pointer might be bigger :)
09:58:16 <edwardk> @let plus1 = iso (+1) (subtract 1)
09:58:17 <quchen> I see. So isomorphism wasn't too far off
09:58:18 <lambdabot>  Defined.
09:58:35 <edwardk> quchen: yeah its built on a type that forms an isomorphism directly to get overloaded functions you can turn around
09:58:38 <edwardk> :t isomorphic
09:58:40 <lambdabot> Isomorphic k => (a -> b) -> (b -> a) -> k a b
09:58:45 <edwardk> there are two instances of Isomorphic.
09:58:52 <edwardk> one for (->) where isomorphic = const
09:59:18 <edwardk> and another for data Isomorphism a b = Isomorphism (a -> b) (b -> a) -- where isomorphic = Isomorphism
09:59:19 <quchen> What's the package called then? There's so many lenses :s
09:59:21 <edwardk> this lets me do things like
09:59:29 <edwardk> quchen: 'lens'
09:59:29 <ion> @let double = iso (*2) (/2)
09:59:31 <lambdabot>  Defined.
09:59:38 <ion> > 42 & double +~ 1
09:59:40 <lambdabot>   Ambiguous occurrence `double'
09:59:40 <lambdabot>  It could refer to either `L.double', defined...
09:59:54 <quchen> Oh. Doesn't seem to be in Hoogle yet.
09:59:54 <edwardk> > 42 & L.double +~ 1
09:59:57 <lambdabot>   42.5
10:00:06 <ion> > 42 & from L.double +~ 1
10:00:06 <edwardk> > 42 ^. L.double
10:00:09 <lambdabot>   can't find file: L.hs
10:00:10 <lambdabot>   84.0
10:00:14 <ion> > 42 & from L.double +~ 1
10:00:17 <lambdabot>   44.0
10:00:22 <aninhumer> quchen: http://hackage.haskell.org/package/lens
10:00:30 <aninhumer> pretty sure it should be in hoogle though?
10:00:32 <edwardk> > 42 ^. from L.double
10:00:35 <lambdabot>   21.0
10:00:50 <aninhumer> Ah no, you're right
10:00:54 <ion> > (2 :+ 3) & imaginary +~ 1
10:00:56 <lambdabot>   Not in scope: `imaginary'
10:00:59 <edwardk> quchen: try hayoo
10:01:11 <edwardk> or aninhumer 's link
10:01:22 <illissius> edwardk: ah, so the forwarding pointer is used _only_ by the follow_the_forwarding_pointer function-pointer, and it's needed because it has to know where to find the answer, and it can't be stored directly because it might not fit. whereas for data constructors you _can_ store it directly because you know how big it is.
10:01:38 <quchen> edwardk: Hayoo works, yes. I just thought it was in one of the many lens packages that Hoogle returns.
10:02:02 <illissius> (and the code isn't follow-the-fwd-pointer but return-the-data)
10:02:07 * lispy never knows when hayoo or hoogle is the right search
10:02:10 <edwardk> illissius: yeah
10:02:26 <illissius> alright, thanks a bunch :)
10:02:36 <edwardk> lispy: i've used each about 2-3 times in the last 6 years ;)
10:03:04 <chersanya> @pl f (a, b) = not (null a) && not (null b)
10:03:05 <lambdabot> f = uncurry ((. (not . null)) . (&&) . not . null)
10:03:30 <edwardk> ion: Data.Complex.Lens isn't in scope
10:03:38 <ion> edwardk: I noticed.
10:04:34 <lispy> edwardk: I have chrome set so that if I type 'h' followed by a query it does the search at hoogle. Which makes it really nice when I can't remember which module something lives in
10:05:08 <edwardk> illissius: i glossed over some details. the code there has hooks to store everything it uses to the ghc stack, run gc if needed, there is some lazy blackholing done by the RTS, etc. but the core of the explanation is sound =)
10:05:55 <edwardk> quchen: anyways i don't recommend starting to learn lens from Iso, but rather from something like Lens or Traversal.
10:05:57 <Crockeo> What's the standard for tab-spacing in Haskell?
10:06:03 <Crockeo> Rather, tabs vs spaces and size.
10:06:17 <edwardk> Crockeo: hard tabs are 8 spaces, though their use is pretty discouraged
10:06:17 <lispy> Crockeo: we don't use tabs
10:06:39 <edwardk> the rigorous spacing on hard tabs matters because of layout
10:06:47 <Crockeo> Alright, and spaces?
10:06:49 <quchen> edwardk: Learning lenses right now feels like learning comonads :( I hope there are going to be some tutorials soon
10:06:54 <lispy> Crockeo: this frees us up to debate about left-to-right and right-to-left composition
10:07:01 <edwardk> i tend to indent by 2 spaces each time, but conventions vary a lot
10:07:04 <ion> (Not that hard tabs are anything other than 8 spaces anywhere outside misconfigured editors.)
10:07:09 <lispy> Crockeo: I indent 2 spaces, some people indent up to about 4
10:07:19 <edwardk> quchen: i wrote a post on how to derive the new lenses from first principles in the lens wiki
10:07:25 <Crockeo> Alright, I've been using 4 for a while, so I was just wondering.
10:07:27 <edwardk> there are some tutorials starting to come out too
10:07:40 <ion> Lens tutorial is the new monad tutorial.
10:07:47 <edwardk> https://github.com/ekmett/lens/wiki/Derivation
10:08:05 <quchen> Thank you sir
10:08:13 <ion> edwardk: nice
10:08:18 <luite> oh if the result for a computation is known, the whole heap object is overwritten by and IND object, which contains the pointer to the actual result
10:08:37 <illissius> zrxy: there isn't a plan, but people have suggested it before
10:08:40 <edwardk> quchen: i'm giving a talk in 2.5 weeks in New York which will be a 2 hour crash course in how lenses work. We'll be recording it and posting it to youtube.
10:08:43 <bgamari> Crockeo, https://github.com/tibbe/haskell-style-guide
10:09:04 <quchen> edwardk: That would be awesome.
10:09:04 <edwardk> I did a version of it in San Francisco last month that went over alarmingly well, but we couldn't record =(
10:09:06 <Crockeo> bgamari: Thank you, I'll look at that.
10:09:46 <quchen> I think the biggest problem with large packages like lenses is usually that they solve something you can hack your way around if you don't know them, and when you finally find them you don't really see where you could practically apply them - you have your hacks, after all
10:09:49 <ion> bgamari: My style has quite a few differences to that. :-)
10:10:18 <quchen> Haven't seen myself craving for lenses yet. It'll take some time getting used to that.
10:10:22 <edwardk> quchen: the goal with lens is to help you build a vocabulary for decomposing big problems like that.
10:10:33 <edwardk> quchen: have you used traverse?
10:10:36 <edwardk> :t traverse
10:10:38 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
10:10:52 <quchen> Not really
10:11:01 <edwardk> mapM?
10:11:12 <edwardk> :t mapM
10:11:14 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
10:11:15 <quchen> Yes, I'm fairly familiar wit monads.
10:11:24 <edwardk> ok, great. traverse is just a generalization of mapM
10:11:29 <edwardk> :t mapM.mapM
10:11:31 <lambdabot> Monad m => (a -> m b) -> [[a]] -> m [[b]]
10:11:36 <edwardk> notice how that went two levels deep?
10:11:41 <edwardk> :t mapM.mapM.mapM
10:11:43 <lambdabot> Monad m => (a -> m b) -> [[[a]]] -> m [[[b]]]
10:11:56 <edwardk> :t traverse.traverse
10:11:58 <quchen> That's like map.map to map over a matrix
10:11:58 <lambdabot> (Applicative f, Traversable t1, Traversable t) => (a -> f b) -> t (t1 a) -> f (t (t1 b))
10:12:05 <edwardk> exactly like map.map
10:12:15 <quchen> I see
10:12:20 <edwardk> now, the lens package generalizes this pattern
10:12:37 <quchen> It parameterizes concatenations of "apply" functions?
10:12:52 <edwardk> > (1,2) ^. _2
10:12:54 <lambdabot>   2
10:13:05 <edwardk> > (1,(2,3)) ^. _2._1
10:13:07 <lambdabot>   2
10:13:09 <ion> > view _2 (1,2)
10:13:11 <lambdabot>   2
10:13:17 <ion> > view (_2._1) (1,(2,3))
10:13:19 <lambdabot>   2
10:13:23 <quchen> That looks a little like Mathematica's Part function.
10:13:25 <edwardk> > anyOf traverse (=='c') "chello"
10:13:28 <lambdabot>   True
10:13:36 <quchen> :t ^.
10:13:37 <edwardk> > anyOf (traverse.traverse) (=='c') ["chello","world"]
10:13:37 <lambdabot> parse error on input `^.'
10:13:40 <lambdabot>   True
10:13:41 <quchen> :t (^.)
10:13:42 <lambdabot> s -> Getting a s t a b -> a
10:13:58 <quchen> Thank you, lambdabot
10:14:00 <edwardk> a ^. l = getConst (l Const a)
10:14:02 <efraglebagga> wait, are lenses the same thing as in that bananas, lenses, envelopes article?
10:14:14 <edwardk> efraglebagga: no relation
10:14:38 <edwardk> the lenses in that are due to a notational resemblance between [(    and a concave lens
10:14:38 <atriq> Hmm
10:14:47 <atriq> I can't see to compile gtk
10:15:13 <edwardk> :t getConst . traverse Const
10:15:14 <lambdabot> (Traversable t, Monoid b) => t b -> b
10:15:20 <edwardk> :t foldMap
10:15:22 <lambdabot> (Foldable t, Monoid m) => (a -> m) -> t a -> m
10:15:27 <edwardk> :t fold
10:15:30 <lambdabot> (Foldable t, Monoid m) => t m -> m
10:15:30 <efraglebagga> edwardk: yeah, was just a wild guess, have been meaning to read that for a while. kinda captures attention with the title :>>
10:15:40 <edwardk> notice the relationship between ^. traverse  and fold
10:15:53 <edwardk> :t Data.Traversable.foldMapDefault
10:15:54 <lambdabot> (Traversable t, Monoid m) => (a -> m) -> t a -> m
10:16:03 <edwardk> :t views traverse
10:16:05 <lambdabot> (Traversable t, Monoid r) => (a -> r) -> t a -> r
10:16:34 <edwardk> all lens does is take the functions you know how to (or will learn how to) use from Traversable, and Foldable and generalize them to other kinds of traversals.
10:16:40 <quchen> Too much information - ugh. I think I should get more familiar with Foldable/Traversable first (Typeclassopedia?)
10:16:43 <edwardk> and every lens is a value traversal.
10:16:48 <edwardk> er valid
10:17:19 <edwardk> quchen: in practice you can pick up pretty much any lens, traversal, fold, isomorphism, getter, setter, and pass it to any lens combinator and it'll do the right thing.
10:17:33 <edwardk> and they just compose with (.) from the prelude.
10:18:06 <edwardk> > traverse.both %~ length $ [("hello","world"),("and","quchen")]
10:18:08 <lambdabot>   [(5,5),(3,6)]
10:18:23 <newsham> edk: so sorta like http://fffff.at/free-universal-construction-kit/ ?
10:18:38 <edwardk> thats like an fmap that went into lists of pairs and edited each half of each pair
10:18:50 <ion> That page’s color scheme gave me cancer.
10:18:54 <edwardk> newsham: very much =)
10:19:09 <newsham> ion: sorry.. try more seafood?
10:19:09 <quchen> edwardk: Seems magical. Is there Template Haskell involved?
10:19:15 <edwardk> not in this
10:19:21 <quchen> Especially your pattern earlier, "^. _2", looked like it
10:19:45 <ion> (^.) is just an operator, _2 is just a function.
10:19:49 <c_wraith> well, _2 involves a typeclass, because that's the only way it can be polymorphic the way it is
10:19:50 <newsham> ?type _2
10:19:52 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
10:20:05 <quchen> _2 is a valid identifier?
10:20:12 <JuanDaugherty> don't joke like that, color scheme's are serious biz
10:20:14 <edwardk> we can pretend _2 is just _2 f (a,b) = (,) a <$> f b  -- for discussion though
10:20:16 <ion> _2 l (a,b) = (a,) <$> f b
10:20:23 <JuanDaugherty> *schemes
10:20:25 <Eduard_Munteanu> "the Kit encourages totally new forms of intercourse between otherwise closed systems" -- er, what?
10:20:31 <ion> err. l b
10:20:56 <edwardk> quchen: yeah i used it because its in a very underutilized portion of the namespace and it was far better given how prevalent its use is to have a short odd name than a long one
10:21:45 <ion> It’s underutilized because its meaning is “this value will not be used”. ;-)
10:21:54 * Philippa realises to her annoyance that she'd rather be writing this code in Frank
10:22:28 <edwardk> so (3,4)^._2 = getConst (_2 Const (3,4)) = getConst ((3,) <$> Const 4) = getConst (Const 4) = 4
10:22:42 <quchen> edwardk: And I'm guessing you don't use it in pattern matching, so there's no clash with _x being "anything"?
10:23:13 <quchen> Well, if it's a function it doesn't appear in patterns of course, nevermind
10:23:19 <edwardk> yeah
10:23:45 <edwardk> a lot of lens versions of functions are just the original prefixed with _
10:23:55 <edwardk> which weirds some people out but makes easy naming ;)
10:24:18 <quchen> Using those qualified will be fun
10:24:30 <quchen> (1,2) L.^. L._2
10:25:02 <zrxy> what is the motivation behind the ghc-only readPrec?
10:25:04 <edwardk> quchen: the goal of lens was to make it so the core library could be used unqualified by the vast majority of users. to that end when putting it together originally i actually did an operator and word frequency search on hackage before naming the core combinators
10:25:19 <edwardk> zrxy: it sucks a lot less to write than the traditional one
10:25:30 * hackagebot console-program 0.3.1.0 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.1.0 (AriePeterson)
10:25:48 <quchen> edwardk: I see. Are there any plans of making it a standard package (as in platform)?
10:26:11 <edwardk> quchen: so the names use _ as prefixes, and tend to use a lot of prepositions, past tenses and gerundive nominals in its vocabulary
10:26:27 <edwardk> it makes the api sound more declarative and those tend to be under populated portions of the namespace
10:26:58 <edwardk> quchen: the goal with lens is to have it provide lenses for the platform, but i think it'd be premature to fossilize it down to a twice yearly platform-like update cycle
10:27:15 <edwardk> going into the platform has a lot of costs and few benefits
10:27:28 <edwardk> also it depends on a few packages for its own internals that aren't in the platform
10:27:50 <edwardk> and those matter enough performance wise that its not worth fighting the fight =P
10:28:22 <quchen> It seems to be a pretty young idea to use lenses anyway. Well, giving it some time, maybe it'll become standard.
10:28:38 <quchen> I mean the benefit seems to be quite large, once you know when to use them.
10:28:47 <edwardk> i'm more concerned with 'defacto' standard than platform standard.
10:29:12 <ion> edwardk: “(though they compose backwards)” – is the backwards supposed to be `backwards`?
10:29:12 <edwardk> lens will continue to cover the last 2-3 platform versions at any given time
10:29:31 <edwardk> ion: where?
10:29:35 <ion> https://github.com/ekmett/lens/wiki/Derivation
10:30:00 <edwardk> prolly not, feel free to patch ;)
10:30:23 <edwardk> i think it was double quoted and got turned into backticks
10:32:11 <quchen> I guess I'll have to wait for http://newartisans.com/2012/11/getting-started-with-lenses/ for a working knowledge, and dig my way through Traversable somehow
10:33:59 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y' & rezip
10:34:02 <lambdabot>   ("jelly","world")
10:34:30 <ion> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'j' & rightmost & focus .~ 'y' & up & up & focus . both . iwhere even %~ toUpper & rezip
10:34:33 <lambdabot>   ("JeLlY","WoRlD")
10:34:39 <edwardk> ion: hahaha
10:35:16 <quchen> :t (&)
10:35:17 <lambdabot> t1 -> (t1 -> t) -> t
10:35:19 <Entroacceptor> wat?
10:35:36 <quchen> & == flip ($)?
10:35:37 <edwardk> quchen: its just flipped ($)
10:35:39 <edwardk> yeah
10:35:43 <edwardk> :t down _1
10:35:44 <atriq> Hey, I'm trying to install gtk2hs, and I'm getting a pretty scary error
10:35:45 <atriq> http://hpaste.org/78159
10:35:45 <lambdabot> Field1 b b c c => (a :> b) -> (a :> b) :> c
10:36:14 <edwardk> :t fromWithin traverse
10:36:15 <lambdabot> Traversable t => (a :> t c) -> (a :> t c) :> c
10:36:20 <newsham> when are we just going to get a whole vocabulary of ops that go from right to left?
10:36:26 <edwardk> the :> is like a breadcrumb trail
10:36:30 <newsham> =<<, flip ($), <<<, etc..
10:36:38 <edwardk> :t zipper
10:36:40 <lambdabot> a -> Top :> a
10:36:44 <luite> atriq: hm, it probably has already been fixed in the darcs (git?) repo
10:36:45 <edwardk> zipper starts you at the top
10:36:58 <luite> atriq: but it means that you have to import the data constructor for CULong
10:37:13 <edwardk> then down goes into a lens, focus is the lens to view the current target of the zipper, and you can move left and right through traversals in the lens zipper
10:37:14 <quchen> edwardk: & down _1 gets me "into" the zipper?
10:37:37 <edwardk> :t zipper ("hello","world") & down _1
10:37:39 <lambdabot> (Top :> ([Char], [Char])) :> [Char]
10:37:43 <atriq> luite, so if I find the cutting edge versions...?
10:37:48 <quchen> :t (:>)
10:37:48 <edwardk> that is a zipper starting at the top, that goes down into a string
10:37:49 <lambdabot>     Not in scope: data constructor `:>'
10:37:49 <lambdabot>     Perhaps you meant one of these:
10:37:49 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
10:38:01 <edwardk> :t zipper ("hello","world") & down _1 & fromWithin traverse
10:38:03 <lambdabot> ((Top :> ([Char], [Char])) :> [Char]) :> Char
10:38:08 <edwardk> :t zipper ("hello","world") & down _1 & fromWithin traverse & view focus
10:38:10 <lambdabot> Char
10:38:13 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & view focus
10:38:16 <lambdabot>   'h'
10:38:22 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & right1 & view focus
10:38:24 <lambdabot>   'e'
10:38:32 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & right1 & up & view focus
10:38:34 <lambdabot>   "hello"
10:38:47 <luite> atriq: yeah... i thought they had already been released to hackage though, make sure you cabal update and have the latest version
10:38:48 <edwardk> > zipper ("hello","world") & fromWithin both & fromWithin traverse & right1 & up & view focus
10:38:51 <lambdabot>   "hello"
10:38:57 <edwardk> > zipper ("hello","world") & fromWithin both & fromWithin traverse & right1 & up & right1 & view focus
10:38:59 <lambdabot>   "world"
10:39:01 <quchen> Sooo here's my shot at what's happening: down _1 focusses inside the zipper, i.e. the tuple.
10:39:10 <edwardk> yep
10:39:16 <quchen> fromWithin traverse traverses the tuple?
10:39:26 <quchen> Or is it focussing inside the tuple at some point
10:39:32 <edwardk> down adds one layer to the breadcrumb trail. fromWithin is a generalized form of down that goes down into a traversal
10:39:49 <edwardk> > zipper ("hello","world") & fromWithin _1 & fromWithin traverse & right1 & view focus
10:39:51 <lambdabot>   'e'
10:40:06 <quchen> :t zipper ("hello","world") & fromWithin _1
10:40:07 <edwardk> fromWithin works fine with _1 as well, its just down is always safe, and fromWithin assumes the traversal is nonempty
10:40:07 <lambdabot> (Top :> ([Char], [Char])) :> [Char]
10:40:22 <edwardk> :t within
10:40:24 <lambdabot> SimpleLensLike (Control.Lens.Internal.Bazaar c c) b c -> (a :> b) -> Maybe ((a :> b) :> c)
10:40:45 <edwardk> you can't go down into an empty list safely. fromWithin assumes you know what you are doing. its fromJust . within
10:40:58 <edwardk> :t within traverse
10:41:00 <lambdabot> Traversable t => (a :> t c) -> Maybe ((a :> t c) :> c)
10:41:04 <edwardk> :t within _2
10:41:06 <quchen> Ah. usafeDown so to speak.
10:41:06 <lambdabot> Field2 b b c c => (a :> b) -> Maybe ((a :> b) :> c)
10:41:20 <quchen> > zipper ("hello","world") & fromWithin _1
10:41:22 <lambdabot>   No instance for (GHC.Show.Show
10:41:22 <lambdabot>                     ((Control.Lens.Zipper.To...
10:41:32 <ion> > zipper ("hello","world") & fromWithin _1 & rezip
10:41:35 <lambdabot>   ("hello","world")
10:41:43 <ion> > zipper ("hello","world") & fromWithin _1 & view focus
10:41:45 <lambdabot>   "hello"
10:42:19 <edwardk> zipper (2 :: Int) & fromwithin traverseBits & focus .~ True & rezip
10:42:21 <edwardk> > zipper (2 :: Int) & fromwithin traverseBits & focus .~ True & rezip
10:42:23 <lambdabot>   Not in scope: `fromwithin'
10:42:23 <lambdabot>  Perhaps you meant `fromWithin' (imported from C...
10:42:26 <edwardk> > zipper (2 :: Int) & fromWithin traverseBits & focus .~ True & rezip
10:42:28 <lambdabot>   3
10:42:32 <quchen> I still don't get the whole thing. To me it looks like you're focussing on the tuple first. The next step is this "fromWithin" business.
10:42:37 <quchen> Is that lensing down another level?
10:42:51 <quchen> So you're in the tuple?
10:42:57 <edwardk> > zipper (2 :: Int) & fromWithin traverseBits & focus %~ not & right1 & view focus
10:42:59 <lambdabot>   True
10:43:51 <ion> You start at ("hello","world"). down _1 focuses to "hello". fromWithin traverse focuses to the start of the traversal of "hello", 'h'.
10:43:56 <edwardk> you can use any (non-empty) traversal or lens to move down, you can move left or right within the traversal. (moving let or right in a lens will just fail)
10:44:21 <edwardk> he breadcrumb trail tracks how deep you are and what up means
10:44:27 <quchen> ion: Oh, I thought the down _1 focusses me on the content of the zipper, i.e. the whole tuple, instead of a tuple entry
10:44:42 <ion> > view _1 ("hello", "world")
10:44:44 <lambdabot>   "hello"
10:44:45 <ion> > view _2 ("hello", "world")
10:44:47 <lambdabot>   "world"
10:45:04 <edwardk> :t zipper ("hello,"world") & down _1 & fromWithin traverse
10:45:05 <lambdabot>     lexical error in string/character literal at end of input
10:45:19 <edwardk> :t zipper ("hello","world") & down _1 & fromWithin traverse
10:45:20 <quchen> So "fromWithin traverse" says "start lensing, and by the way, you're looking at a traversable"?
10:45:22 <lambdabot> ((Top :> ([Char], [Char])) :> [Char]) :> Char
10:45:29 <edwardk> :t zipper ("hello","world") & fromWithin (_1.traverse)
10:45:32 <lambdabot> (Top :> ([Char], [Char])) :> Char
10:46:00 <edwardk> there i'm saying to down to the characters in the first string 'in one step'. going up will take me all the way back to the tuple
10:46:10 <edwardk> :t zipper ("hello","world") & down _1 & fromWithin traverse & up
10:46:12 <lambdabot> (Top :> ([Char], [Char])) :> [Char]
10:46:16 <edwardk> :t zipper ("hello","world") & fromWithin (_1.traverse) & up
10:46:17 <lambdabot> Top :> ([Char], [Char])
10:46:51 <quchen> Ah, you're combinging focussing into one focus event
10:47:09 <edwardk> > zipper ("hello","world") & fromWithin (both.traverse) & focus .~ 'j' & rightmost & focus .~ 'y' & rezip
10:47:12 <lambdabot>   ("jello","worly")
10:47:20 <edwardk> notice how it cut across both strings
10:47:41 <donri> guys there's a nice chapter on zippers in lyah if anyone is confused
10:48:09 <edwardk> > zipper ("hello","world") & fromWithin (both.traverse) & focus .~ 'j' & rightmost & focus .~ 'y' & up & partsOf (focus.both.traverse) %~ reverse & rezip
10:48:11 <lambdabot>   ("ylrow","ollej")
10:48:16 <quchen> donri: Well, that's very very basic
10:48:22 <donri> sure
10:49:04 <quchen> edwardk: fromWithin (both . traverse) combines two traversables (here: the two strings contained in the tuple) into one?
10:49:06 <edwardk> > zipper ("hello","world") & fromWithin (both.traverse) & focus .~ 'j' & rightmost & focus .~ 'y' & up & focus.both.iwhere even %~ toUpper & rezip
10:49:09 <lambdabot>   ("JeLlO","WoRlY")
10:49:15 <quchen> You can basically walk over the tuple comma freely?
10:49:17 <atriq> luite, no, that doesn't seem to be it
10:49:24 <edwardk> quchen: yep
10:49:35 <quchen> :t (.~)
10:49:37 <lambdabot> Setting s t a b -> b -> s -> t
10:49:46 <edwardk> > zipper ("hello","world") & fromWithin (both.traverse) & focus .~ 'j' & rights1 7 & view focus
10:49:49 <lambdabot>   'r'
10:50:01 <quchen> .~ is "set/overwrite"?
10:50:06 <edwardk> yeah
10:50:17 <edwardk> > zipper ("hello","world") & fromWithin (both.traverse) & set focus 'j' & rezip
10:50:19 <lambdabot>   ("jello","world")
10:50:22 <edwardk> set = (.~)
10:50:26 <quchen> focus is a reference to the currently focussed element? (Don't hurt me for using 'reference')
10:50:37 <edwardk> thats exactly what it is
10:50:44 <edwardk> the original term for lens was 'functional reference'
10:50:58 <edwardk> the ones used by the lens package generalize this notion somewhat severely
10:51:18 <edwardk> %~ is like 'modify'
10:51:25 <quchen> > zipper ("hello", "world") & fromWithin (_1 . traverse) & right1 & right1 & focus.~ 'L' & rezip
10:51:26 <edwardk> it is called over in prefix form
10:51:27 <lambdabot>   ("heLlo","world")
10:51:29 <quchen> HA!
10:51:44 <quchen> Wonderful.
10:51:45 <donri> "somewhat severly" <3
10:51:47 <edwardk> > zipper ("hello", "world") & fromWithin (_1 . traverse) & right1 & right1 & focus %~ toUpper & rezip
10:51:51 <lambdabot>   ("heLlo","world")
10:51:58 <quchen> :t zipper ("hello", "world") & fromWithin (_1 . traverse) & right1 & right1 & focus.~ 'L' & view focus
10:51:59 <lambdabot> Char
10:52:05 <quchen> :t zipper ("hello", "world") & fromWithin (_1 . traverse) & right1 & right1 & focus.~ 'L' & up & view focus
10:52:07 <lambdabot> ([Char], [Char])
10:52:08 <atriq> luite, I have no idea what's wrong
10:52:15 <quchen> :t zipper ("hello", "world") & fromWithin (_1 . traverse) & right1 & right1 & focus.~ 'L' & up & up & view focus
10:52:17 <lambdabot>     Couldn't match expected type `Top' with actual type `a0 :> b0'
10:52:17 <lambdabot>     Expected type: (Top :> ([Char], [Char])) -> t10
10:52:17 <lambdabot>       Actual type: ((a0 :> b0) :> c0) -> a0 :> b0
10:52:27 <atriq> Could it be a GHC 7.6 thing?
10:52:29 <edwardk> you can't go up past the Top ;)
10:52:35 <donri> set = over . const ?
10:52:37 <quchen> rezip = iterate up until top?
10:52:42 <edwardk> donri: effectively
10:52:52 <luite> atriq: yes, FFI things changed in 7.6, in 7.4 it was just a warning
10:52:56 <edwardk> quchen: yep with some annoying type family stuff to make that sound
10:53:16 <quchen> I have to say this is amazing
10:53:17 <mreh> can someone explain why "hello" . for 3 === for 3 . "hello" in netwire?
10:53:17 <lambdabot> mreh: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:53:18 <edwardk> (it also has to get out of the zipper at the end)
10:53:20 <atriq> luite, any advice?
10:53:31 <luite> atriq: yeah use the darcs version or use ghc 7.4
10:53:33 <quchen> (How the hell does the compiler infer the type of that monster)
10:54:00 <zrxy> So in retrospect readsPrec is kind of ad hoc with the [(x,string)] thing, and readPrec makes it more formal?
10:54:09 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Internal/Zipper.hs#L242 its not so bad
10:54:17 <quchen> :t zipper
10:54:18 <lambdabot> a -> Top :> a
10:54:41 <edwardk> zipper a = Zipper Coil (Level 0 [] a [])
10:54:52 <edwardk> starts with an empty path down, and a level with one entry
10:55:03 <quchen> Is it part of your lens package?
10:55:04 <edwardk> at position 0
10:55:06 <edwardk> yes
10:55:20 <edwardk> import Control.Lens and the zipper code comes with it
10:55:22 <quchen> Ah, I was already wondering because the Hoogle "zipper" had another API
10:55:55 <edwardk> http://hackage.haskell.org/packages/archive/lens/3.6/doc/html/Control-Lens-Zipper.html is the API for zippers
10:56:32 <donri> edwardk: how do lib authors know when to put INLINE on things? seems performance lib put them on almost, but not quite, every function
10:56:33 <quchen> Are zippers some kind of a canonical example of when lenses are useful?
10:56:55 <donri> edwardk: and why are they needed at all, wouldn't ghc inline most of them anyway?
10:57:36 <edwardk> quchen yeah, well they are now. one of the reasons i put together the zipper module was because they are particularly powerful when you add traversals, etc. ;)
10:57:39 <donri> quchen: lenses are very useful without zippers too
10:57:58 <donri> and lens-free zippers can be useful as well
10:58:08 <quchen> :t farthest right
10:58:09 <lambdabot> Not in scope: `farthest'
10:58:10 <lambdabot>     Ambiguous occurrence `right'
10:58:10 <lambdabot>     It could refer to either `Control.Arrow.right',
10:58:11 <donri> killer combo, though, i guess
10:58:12 <quchen> :t rightmost
10:58:14 <lambdabot> (a :> b) -> a :> b
10:58:17 <edwardk> donri: aggressive inlining can bloat executable size, and you can only link stuff across module boundaries that makes it into the .hi file. without the INLINE or INLINEABLE pragmas the code doesn't go in the .hi unless its 'small'
10:58:28 <atriq> luite, darcs version still fails, and I don't really want to switch to 7.4, because I like lambdacase too much
10:58:49 <edwardk> quchen: farthest is in 3.6, but lambdabot is still on 3.3
10:58:59 <edwardk> the API for zippers was streamlined a bit
10:59:05 <quchen> Ah, ok. So is rightmost == farthest right?
10:59:13 <edwardk> and the name conflicts with third party packages were reduced
10:59:16 <edwardk> yep
10:59:22 <thoughtpolice> donri: i think it's mostly intuition on how it's going to be used. i normally use INLINEABLE since it's less of a massive hammer than INLINE, and let's GHC control what happens at the call site
10:59:30 <luite> atriq: in that case, find the import for CULong, and change it to CULong(..)
10:59:34 <edwardk> farthest just iterates a function (a -> Maybe a) until it returns Nothing, giving the last answer
10:59:37 <thoughtpolice> INLINE pretty much tells GHC it has no option. but sometimes that's the best thing to do
10:59:39 <donri> edwardk: yea ok but, what makes the functions in lens and such worth inlining more than any other function?
10:59:39 <edwardk> :t right
10:59:41 <lambdabot>     Ambiguous occurrence `right'
10:59:41 <lambdabot>     It could refer to either `Control.Arrow.right',
10:59:41 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
10:59:52 <edwardk> :t Control.Lens.right
10:59:54 <lambdabot> (a :> b) -> Maybe (a :> b)
10:59:55 <thoughtpolice> (vector-algorithms is pretty susceptible to this, from what I remember of talking with edwardk dolio and copumpkin once)
11:00:32 * hackagebot xcb-types 0.6.3 - Parses XML files used by the XCB project  http://hackage.haskell.org/package/xcb-types-0.6.3 (AntoineLatter)
11:00:33 <quchen> Can you give me an example where lenses are useful without zippers?
11:00:48 <edwardk> donri: the compelling use case is that the functions in lens are almost always picked at the use site and not passed around so much. inlining lets the compiler use the fact that you are using ^._2   and turn that into the same code as 'snd'
11:01:19 <donri> aha
11:01:23 <edwardk> quchen: there is a fully working pong example in the lens examples folder that plays with gloss. there it uses lenses to manipulate the ballstate.
11:01:49 <edwardk> e.g. ballSpeed.both *= speedMultiplier
11:02:12 <edwardk> ballSpeed is a lens to a pair of x and y deltas, both is a lens.
11:02:30 <Chathurga> hah pretty smooth
11:02:48 <edwardk> *= takes a lens into the current state of a MonadState and a value and multiplies the target of the lens by that value before putting it back. here its being used on a traversal so both targets get updated
11:03:11 <quchen> Oh wow.
11:03:15 <edwardk> now *= lets you borrow intuition from imperative code, but moreover it generalizes it, because here its updating _two_ targets.
11:03:55 <edwardk> the game state is defined like data Pong = Pong { _ballSpeed :: (Int,Int), _whatever }; makeLenses ''Pong
11:04:00 <newsham> > _1 + _2
11:04:02 <lambdabot>   No instance for (GHC.Num.Num (f0 t0))
11:04:02 <lambdabot>    arising from a use of `e_112'
11:04:02 <lambdabot>  Pos...
11:04:09 <edwardk> that makes  ballSpeed :: Simple Lens Pong (Int,Int)
11:04:09 <quchen> A Brainfuck interpreter in Haskell
11:04:11 <quchen> Haha
11:04:24 <quchen> That's like visiting both ends of the abstraction spectrum
11:04:34 <beaky> are there any proprietary haskell implementations?
11:04:42 <edwardk> it uses a zipper to move back and forth through the memory
11:05:19 <edwardk> beaky: yes. hbc has been used behind closed doors for lots of things
11:05:35 <beaky> ah
11:05:36 <donri> it's enlightening to desugar lens-using code to their lens-less variants, the result is usually more verbose and harder to compose and refactor
11:05:45 <thoughtpolice> there are definitely copies of GHC around with mods too, i bet.
11:05:47 <edwardk> beaky: we also have a haskell-like language we use here at S&P Capital IQ.
11:05:57 <beaky> wow
11:05:57 <thoughtpolice> there are definitely a few not-quite-haskell-but-proprietary languages
11:06:08 <thoughtpolice> like stanchart & muhaskell
11:06:59 <edwardk> yeah, standard chartered uses Mu, which is a neither properly strict nor lazy haskell-ish thing that they optimize the bejeezus out of ;)
11:07:03 <newsham> edk: blah, more talented people wasting their time on financial modelling? :(
11:07:20 <donri> modify $ \pong@Pong { ballSpeed = (a,b) } -> pong { ballSpeed = (a * speedMultiplier,b * speedMultiplier) } -- the lens-less version would be something like this
11:07:35 <thoughtpolice> edwardk: but you can program excel with it!
11:07:53 <thoughtpolice> the possibilities truly become endless
11:07:54 <quchen> My Haskell self esteem (TM) goes like tan(t)
11:08:02 <quchen> Lenses just crashed me again
11:08:13 <edwardk> thoughtpolice: been toying with an interpreter for ermine that runs in excel. gives you a proper lazy language =P
11:08:29 <edwardk> quchen: heh
11:08:33 <thoughtpolice> edwardk: ermine?
11:08:45 <edwardk> thoughtpolice the haskell-like language i work on here
11:09:00 <thoughtpolice> ah, with all the row-typed fanciness still?
11:09:04 <efie> why has the fromList function in Data.PQueue.Max costs of O(n * log n) when insert has O(1)?
11:09:04 <edwardk> yeah
11:09:34 <thoughtpolice> i was playing with ur again recently, the row typing mechanics/record features are so much fun.
11:09:45 <thoughtpolice> are there any other languages with row polymorphism like that?
11:10:04 <edwardk> ur is at a pretty neat sweet spot that is pretty under-occupied
11:10:07 <thoughtpolice> (well, maybe not quite like ur, but row polymorphism in general)
11:10:58 <thoughtpolice> edwardk: opa seemed to be in kind of a similar space when it was first released. then they went to add some very imperative syntactic sugar and made it compile to node.js :P
11:11:12 <thoughtpolice> i think it still has functional-y features, but i liked it more when it was like ocaml, of course :P
11:11:26 <edwardk> quchen: basically the lens package takes the stuff you already know how to use Functors, Foldables, Traversables and functions and recasts them as Setters, Folds, Traversals and Getters in such a way that they can just be composed with (.) and where the same combinators work on all of them.
11:12:05 <edwardk> then a lens becomes just a legal Traversal that is also a legal Getter. so you can pass a lens anywhere you could say 'traverse' in existing code
11:12:48 <edwardk> and then once you have those you can use the combinators for them which are just generalizations of the existing Foldable, Traversable, etc. combinators where they take the notion of the traversal or fold directly as an argument rather than get it from a class.
11:13:02 <quchen> Hmm, OK. I'm reading the docs on the git page right now, doesn't seem as scary there.
11:13:07 <edwardk> fold = getConst . traverse Const    -- foldOf l = getConst . l Const
11:13:47 <edwardk> any f = getAny . foldMap (Any . f)      anyOf l f = getAny . foldMapOf l (Any . f)
11:13:50 <edwardk> etc.
11:14:12 <edwardk> this lets you work with things like mapping over  Data.Text which is a monomorphic container.
11:14:16 <edwardk> :t Data.Text.Lens.text
11:14:18 <lambdabot> (Applicative f, Indexed Int k, Data.Text.Lens.IsText t) => k (Char -> f Char) (t -> f t)
11:14:56 <edwardk> :t anyOf Data.Text.Strict.Lens.text (=='c') ("chello"^.Data.Text.Strict.Lens.packed)
11:14:58 <lambdabot> Bool
11:15:03 <edwardk> > anyOf Data.Text.Strict.Lens.text (=='c') ("chello"^.Data.Text.Strict.Lens.packed)
11:15:06 <lambdabot>   Not in scope: `Data.Text.Strict.Lens.text'Not in scope: `Data.Text.Strict.L...
11:15:12 <edwardk> i don't think thats in scope though ;)
11:15:50 <lispy> also, all lens tutorials are mandadeted to use the world "hello" in string examples ;)
11:15:54 <lispy> word*
11:16:27 <newsham> monad:burrito::lens:?
11:16:28 <edwardk> i admit i'm pretty unimaginative in my example choices ;)
11:16:51 <lispy> newsham: monad:burrito::traversal:lens
11:17:11 <edwardk> well, monads are burritos, but lenses are awesome ;)
11:17:24 <lispy> ah, an unbiased opinion ;)
11:17:36 * lispy is lens neutral having not used them yet
11:17:41 <edwardk> tacos?
11:17:48 <lispy> But, they be seem to have potential
11:17:56 * otters is lens-positive but does not think he has any practical uses
11:18:04 <edwardk> they are a nifty treat but you don't want to think too much about the stuff that goes into them
11:18:07 <lispy> lens+
11:18:17 <quchen> edwardk: Your new example words are "mustard" and "rhythm".
11:18:20 <edwardk> lispy has a lens ion
11:18:27 <otters> me too
11:18:50 <quchen> That being said, I have to leave. Thanks for the lens introduction, let's see how long it takes me to get used to using lenses.
11:18:55 <edwardk> > ("mustard","rhythm") & partsOf (both.traverse) %~ reverse
11:18:58 <lambdabot>   ("mhtyhrd","ratsum")
11:19:08 <quchen> See? Looks awesome!
11:19:11 <otters> what
11:19:18 <otters> :t (&)
11:19:20 <lambdabot> t1 -> (t1 -> t) -> t
11:19:24 <otters> :t partsOf
11:19:26 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
11:19:36 <lispy> > let ratsum = sum (map ord "rat") in ratsum
11:19:37 <lambdabot>   327
11:19:40 <edwardk> > (1,2) ^. partsOf both
11:19:41 <quchen> Compare that with ("olleh", "dlrow")
11:19:43 <lambdabot>   [1,2]
11:19:47 <quchen> Anyway, bye.
11:20:08 <ion> edwardk: wat
11:20:26 <edwardk> partsOf takes a traversal and gives you a slightly questionable lens that views all of its target as a list  you shouldn't change the length of
11:21:32 <edwardk> > ("mustard","rhythm",2 :: Int, ["and","blues"]) ^. partsOf biplate :: [String]
11:21:34 <lambdabot>   ["mustard","rhythm","and","blues"]
11:21:41 <edwardk> > ("mustard","rhythm",2 :: Int, ["and","blues"]) ^. partsOf biplate :: [Char]
11:21:43 <lambdabot>   "mustardrhythmandblues"
11:21:52 <edwardk> > ("mustard","rhythm",2 :: Int, ["and","blues"]) ^. partsOf biplate :: [Int]
11:21:54 <lambdabot>   [2]
11:22:04 <otters> ...
11:22:09 <lispy> :t biplate
11:22:10 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
11:22:25 <edwardk> biplate is the 'DWIM' lens
11:22:26 <otters> I like that constraint
11:22:28 <ion> ("mustard","rhythm",2 :: Int, ["and","blues"]) & partsOf biplate %~ reverse
11:22:30 <ion> > ("mustard","rhythm",2 :: Int, ["and","blues"]) & partsOf biplate %~ reverse
11:22:32 <lambdabot>   Ambiguous type variable `a0' in the constraint:
11:22:32 <lambdabot>    (Data.Typeable.Internal....
11:22:40 <ion> > ("mustard","rhythm",2 :: Int, ["and","blues"]) & partsOf biplate %~ (reverse :: String -> String)
11:22:42 <lambdabot>   ("seulbdn","amhtyh",2,["rdr","atsum"])
11:22:55 <otters> holy cap
11:22:57 <otters> crap
11:23:06 <otters> it reversed the entire string and updated the structure
11:23:11 <Chathurga> How can it do that?
11:23:21 <copumpkin> by being ridiculous
11:23:22 <edwardk> :t mapMOf biplate putStrLn ("mustard","rhythm",2 :: Int, ["and","blues"])
11:23:24 <lambdabot>     Couldn't match expected type `String' with actual type `()'
11:23:24 <lambdabot>     Expected type: String -> IO String
11:23:25 <lambdabot>       Actual type: String -> IO ()
11:23:27 <edwardk> :t mapMOf_ biplate putStrLn ("mustard","rhythm",2 :: Int, ["and","blues"])
11:23:30 <lambdabot> IO ()
11:23:33 <copumpkin> > ("mustard","rhythm",2 :: Int, ["and","blues"]) & partsOf biplate %~ (reverse :: [String] -> [String])
11:23:36 <lambdabot>   ("blues","and",2,["rhythm","mustard"])
11:24:29 <edwardk> biplate is a generalization of biplate from neil mitchell's uniplate library, updated to just be a traversal.. as a side-effect it got a lot faster
11:24:52 <edwardk> it uses generic programming to figure out what portions of the structure can contain something of the target type and avoids walking the parts that can't
11:24:57 <Saizan> :t biplate
11:24:59 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
11:25:31 <edwardk> > ("mustard","rhythm",2 :: Int, ["and","blues"])  & biplate %~ toUpper
11:25:34 <lambdabot>   ("MUSTARD","RHYTHM",2,["AND","BLUES"])
11:25:52 <otters> oh, generic programming
11:25:55 <Saizan> why did it got faster as a Traversal?
11:25:55 <otters> that makes a lot more sense
11:25:56 <barrucadu> :t (%~)
11:25:57 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
11:26:26 <edwardk> uniplate spent a lot of time building up a structure and then tearing it down. lens just holds it in the environment.
11:26:37 <edwardk> we avoid all that initial encoding overhead and are safer
11:26:44 <ion> edwardk: Did “s t a b” spelling “stab” factor into why those letters were chosen?
11:27:56 <edwardk> ion: a small factor. they were originally a b c d but people gave me crap. this way the type of traverse :: Traversable t => Traversal (t a) (t b) a b  works out such that the a and b are the same a and b in a -> f b from traverse's signature
11:28:07 <ion> Yeah, i remember a b c d. :-)
11:28:24 <edwardk> :t (%=)
11:28:27 <lambdabot> MonadState s m => Setting s s a b -> (a -> b) -> m ()
11:28:32 <ion> And i get why “s t a b” apart from what word they form. :-)
11:28:34 <edwardk> this puts 's' for the state parameter this way
11:29:48 <ion> Also, “source”, “target”
11:29:55 <edwardk> also shachaf was willing to do all the alpha renaming for it
11:35:36 <edwardk> i'll admit i hadn't considered the s t mnemonics that way. i'll use it though ;)
11:35:39 <atriq> luite, it changes it back during preprocessing!
11:35:43 <atriq> I'm scared now
11:38:17 <Crockeo> What would you guys suggest for a  good GUI framework for Haskell?
11:39:31 <donri> gtk2hs
11:39:42 * dcoutts_ seconds that
11:39:57 <Crockeo> donri: Thank you!
11:41:44 <luite> atriq: oh! perhaps you need to reinstall the latest version of ghk2hs-buildtools ?
11:42:12 <zrxy> Does it ever make sense for a readsPrec parser to return two tuples? [(x,remx), (y,remy)] ?
11:42:49 <zrxy> I don't quite understand the motivation of [] meaning failure and [(x,str)] meaning success.
11:43:08 <atriq> zrxy, some people use [] when they mean Mayve
11:43:11 <atriq> *Maybe
11:43:14 <byorgey> zrxy: yes, if there are multiple possible parses
11:43:19 <byorgey> i.e. if the grammar is ambiguous
11:43:32 <edwardk> zrxy: readsPrec supports ambiguity
11:43:51 <byorgey> [(x,str)] actually means *unambiguous* success.
11:43:52 <Eelis> are there any opengl bindings that have a monad to represent opengl side effects?
11:44:02 <zrxy> ok thanks all
11:45:42 <simpson> Eelis: The standard bindings in the opengl package use IO.
11:45:43 <Eelis> i'd like to do something like   drawShinyThing :: Size -> GL ()   instead of   drawShinyThing :: Size -> IO (), so that i can see from the type that drawShinyThing isn't doing any file I/O for example
11:45:52 <Eelis> simpson: see above ^_^
11:46:07 <edwardk> zrxy: you may want to google for "turning failure into a list of successes" for the paper on this style of parsing
11:46:15 <simpson> Eelis: Ah. You could create your own.
11:46:30 <simpson> Eelis: I should point out that e.g. file I/O *does* happen when you do GL. :3
11:46:31 <Eelis> simpson: right, but that'd be a lot of work :)
11:46:36 <edwardk> its nice for ambiguous grammars, its bad for error reporting ;)
11:46:48 <Eelis> simpson: isn't there some subset of opengl that truly only affects the opengl state?
11:46:49 <`nand`> Eelis: type GL = IO ;)
11:46:54 <atriq> Aaargh
11:47:05 <`nand`> Eelis: you don't know whether something is doing I/O or not based on the type
11:47:09 <Eelis> `nand`: i want something compiler-checked :)
11:47:15 <Eelis> now what
11:47:17 <atriq> I haven't got ~/.cabal/bin in my PATH and I don't know how to fix it
11:47:17 <`nand`> you know the moment you bind it to ‘main’ (perhaps transitively)
11:47:18 <geekosaur> Eelis, the GL state lives outside of Haskell, it therefore lives in IO
11:47:28 <simpson> Eelis: GL is pure as long as you don't actually render anything. :3
11:47:28 <Eelis> geekosaur: that doesn't mean you couldn't make a GL monad
11:47:29 <`nand`> in fact, often you don't know even that
11:47:37 <`nand`> ByteString uses unsafePerformIO internally
11:47:43 <`nand`> but would you realize that, working with it? Probably not
11:47:45 <Eelis> `nand`: all that is beside the point
11:48:01 <`nand`> Sorry, I jumped into the conversation prematurely
11:48:05 <simpson> Eelis: Feel free to make something like newtype GL a = GL { unGL :: IO a }
11:48:16 <edwardk> Eelis: you could make a GL monad that is just a restricted IO, but eventually you want to do other things in that monad. which means using MonadIO or something, and then lifting all your other actions
11:48:19 <Eelis> simpson: again, way too much work
11:48:34 <Eelis> edwardk: makes sense
11:48:34 <simpson> Eelis: But when you do GL work, you're acknowledging that things like dynamic loading of drivers is happening.
11:48:40 <edwardk> Eelis: which is why the GL bindings don't do that ;)
11:49:09 <Eelis> edwardk: isn't this similar to how you need StateT in addition to State?
11:49:13 <`nand`> you could encode an embedding of GL actions without ever ‘performing it’; delegating that performing to some interpreter
11:49:19 <Eelis> `nand`: exactly
11:49:24 <`nand`> for example, using a free monad
11:49:45 <`nand`> (which goes a bit against what simpson and edwardk suggested)
11:49:53 <edwardk> Eelis: the utility of such a monad would be that you could do something to start off the one true GL monad, and wouldn't have to worry about out of thread OpenGL access, the disutility is the overhead
11:49:56 <simpson> That would be really cool, actually!
11:50:09 <simpson> But that would lead to eventually rewriting all of, say, Mesa and Gallium in Haskell.
11:50:15 <simpson> 'Cause you'd want to manage your own state.
11:50:31 <simpson> GL state is *expensive* and you don't want to round-trip across the FFI barrier repeatedly to mess with it.
11:50:44 <`nand`> I don't see a problem with writing everything from the microcode and graphics drivers to the high level abstractions in Haskell ;)
11:51:11 <simpson> The only obstacle is that there's only a few people that have the chops to do it, and most of them are busy with other stuff. :c
11:52:25 <edwardk> i don't do much opengl in haskell because of the historically broken GLfloat silliness
11:52:35 <Eelis> o_O
11:53:01 <Eelis> anything i should be aware of?
11:53:20 <edwardk> now that that is fixed. i may start using the standard bindings
11:53:27 <`nand`> I do OpenGL in Haskell transitively
11:53:30 <`nand`> via gloss
11:53:38 <`nand`> or other higher level abstractions, where available
11:53:39 <thoughtpolice> `nand`: ditto, i almost never do raw opengl stuff
11:53:46 <thoughtpolice> or i use GLFW or something
11:53:55 <edwardk> Eelis: prior to 1.3 they were unexported newtypes, which meant every conversion had to go through realFrac
11:53:56 <Eelis> glfw only gives you a context, doesn't it?
11:53:57 <geekosaur> Eelis: GLfloat used to do a stupidly expensive conversion between Haskell and FFI representations.  that was fixed.
11:54:16 <Eelis> ah, starting to ring a bell. but yeah, that's been fixed
11:54:23 <edwardk> Eelis: this led to abominably bad code where you lost orders of magnitude of performance
11:54:40 <parcs`> that just required a RULE, didn't it?
11:54:44 <thoughtpolice> Eelis: it's just a more convenient API, without going all the way to e.g. gloss, is my thing
11:54:58 <edwardk> parcs`: which may or may not fire
11:55:07 <DMcGill> gloss is 2D only right?
11:55:09 <Eelis> i'm using glut only because i'd never heard of glfw 5 years when i started this program :)
11:55:11 <Eelis> *ago
11:55:20 <parcs`> edwardk: hmm, any particular circumstances?
11:55:29 <`nand`> DMcGill: vector graphics only
11:55:41 <thoughtpolice> Eelis: :)
11:55:43 <edwardk> parcs`: sure. just pass 'realFrac' to someone else and have them apply it. instant semantic changes
11:55:58 <zrxy> I'm not sure what to do with the precedent integer argument to readsPrec. I'm reading atom-like things in which precedence doesn't seem to apply. OK to ignore it?
11:56:00 <parcs`> ah
11:56:30 <edwardk> the current 'just use RULES to fix realFrac approach is crap.
11:56:54 <edwardk> i gave in long ago and just added FromDouble and ToDouble, etc. classes to my types =P
11:56:56 <c_wraith> zrxy: It will only even be set to something meaningful if you do so - so ignoring it if you don't is fine
11:56:59 <BMeph> So, does anyone know how "WebGL" compares with "real" GL, and whether making a Haskell binding would be useful for the effort? :)
11:57:11 <edwardk> BMeph: its pretty good these days
11:57:18 <zrxy> ok thanks
11:57:23 <simpson> BMeph: WebGL is just GLES in JS.
11:58:17 <Eelis> yeah, the real trickery is in compiling Haskell to JS
11:58:28 <edwardk> BMeph: you should work wtih luite on getting webgl support for OpenGL to work with ghcjs ;)
11:58:28 <Eelis> if you can do that better than existing programs, that'd be very nice
11:59:22 <parcs`> is nacl a thing yet?
12:00:03 <thoughtpolice> you could run JHC compiled programs on native client :)
12:00:48 <thoughtpolice> as for the javascript story, i kind of hate how many alternatives there are. ghcjs is by far the most complete and robust from a features standpoint at least, and i think most people would love that in GHC proper. it DOES compile programs, but now all the boring stuff has to be done
12:01:00 <thoughtpolice> like making the build process not insane, and cabal/build system tweaks to support that stuff
12:01:03 <thoughtpolice> etc
12:01:21 <thoughtpolice> and overall that's probably a pretty sizeable amount of effort on its own
12:01:27 <luite> yes
12:01:46 <luite> edwardk: ah i wanted to make that a gsoc project for next year :)
12:01:48 <`nand`> the main thing that would suck about going to JS for me is that you lose a lot of awesome libraries
12:01:58 <`nand`> that rely on FFI or unsafePerformIO internally
12:02:11 <simpson> `nand`: Are you sure that the main thing that sucks isn't just *writing things in JS*? :3
12:02:19 <thoughtpolice> heh
12:02:23 <`nand`> simpson: I meant Haskell -> JS
12:02:52 <`nand`> who in their right mind would write things in a compilation target language? ;)
12:02:57 <simpson> `nand`: Why not say that the entire scenario sucks?
12:03:21 <thoughtpolice> `nand`: i think it's understood that stuff just comes with the territory. ghcjs at least already does have a JS FFI. and some things could probably be replicated, e.g. bytestring only uses FFI for like, calling into a memcpy equivalent
12:03:26 <`nand`> simpson: that it does; interactive web pages should support some virtual machine bytecode imo
12:03:27 <parcs`> why wouldn't unsafePerformIO work in something like ghcjs?
12:03:30 <simpson> What's so wrong about standing up and decrying JS? It's a stupid language and we shouldn't have to put up with it.
12:03:32 <thoughtpolice> which you could shim out pretty easily. it'd take some work but i imagine you could get a lot of stuff working
12:03:51 <DMcGill> so when do we genealise ghc* and make the language API simply an argument? :p
12:04:00 <`nand`> parcs`: because how would you translate GHC's IO into JavaScript? How do you, say, call a C function in an external library in JavaScript?
12:04:22 <luite> thoughtpolice: yeah i made a shim repository yesterday, with simple config files. you can say which .js files you need linked in if you use some package
12:04:32 <thoughtpolice> `nand`: you don't. you rewrite parts of the runtime in JS, and have different semantics at the codegen level for what that implies. nobody expects you to use C files directly from javascript :)
12:04:36 <thoughtpolice> unless you use emscripten, of course
12:04:53 <edwardk> luite: ah nice!
12:04:57 <thoughtpolice> `nand`: and GHC JS already does all this, IIRC
12:05:00 <parcs`> `nand`: you wouldn't, but how do you go from 'not being able to call a C function' to 'not being able to use unsafePerformIO'?
12:05:03 <thoughtpolice> it even has it's own trampolining
12:05:07 <`nand`> DMcGill: support hotplugging GHC with some module that generates the result code from some simplified core
12:05:09 <thoughtpolice> and will even compile everything into one mega-JS file
12:05:37 <luite> mega means your program will be a 3MB javascript download :p
12:05:42 <thoughtpolice> yeah :P
12:05:47 <thoughtpolice> but like i said, GHC JS is actually very feature complete and usable. it just needs a lot of polish
12:05:57 <thoughtpolice> i got scared the moment i saw the steps to build it
12:06:06 <thoughtpolice> and i've written patches for GHC :P
12:06:26 <`nand`> parcs`: oh; I was talking about libraries that use unsafePerformIO on the sort of I/O action you can't reasonably translate to javascript
12:06:27 <luite> thoughtpolice: yeah, one problem is that i started from scratch a few months ago to improve performance, and the new branch doesn't yet have all the features
12:06:34 <zrxy> I coulda sworn that on emacs hitting TAB on an empty line duplicated the function name, so hitting tab underneath "foo :: Bar" would insert "foo".
12:06:43 <zrxy> But it seems to not happen anymore.
12:06:45 <luite> and the other branch isn't seeing much activity atm
12:06:53 <parcs`> `nand`: oh.
12:07:01 <`nand`> I mean, stuff like Foreign.Ptr and so on can still be translate to operations on some virtual heap in javascript; so you wouldn't necessarily lose stuff like ByteString
12:07:14 <thoughtpolice> luite: oh, cool. i've been wrestling with GHC on ARM (and now TI's OMAP is dead...) lately, and i'm not a web guy by trade (but of course i'd still love Haskell -> JS, then maybe i'd be a web programmer! :)
12:07:17 <Eelis> yeah, that's how they compile C/C++ to JS
12:07:26 <`nand`> but you'd lose something like Integer that calls an external library for its hardware. (Of course, Integer is in Prelude and so would be implemented independently by ghcjs either way)
12:07:31 <`nand`> s/hardware/hard work/
12:07:37 <luite> `nand`: ByteString translates to Addr# in GHC, which is implemented with javascript ArrayBuffer and DataView (typed arrays)
12:08:06 <thoughtpolice> `nand`: sure you can. just use integer-simple, it's written in Haskell
12:08:10 <parcs`> `nand`: there is a pure-haskell implementation of integer actually
12:08:21 <luite> integer-simple is really slow
12:08:28 <`nand`> thoughtpolice: parcs`: my point is; you still lose the original library. You have to find, or write, an alternative
12:08:35 <luite> ghcjs supports integer-gmp with some reimplementation of the gmp functions in js
12:08:39 <Eelis> i would *love* to be able to compile my opengl haskell programs to webgl-using-JS
12:08:57 <luite> but the new code generator will probably get a rewrite of the integer-gmp support to make it less hacky
12:09:10 <thoughtpolice> `nand`: sure, and like i said, i think it's understood that comes with the territory. i don't think anyone expected it to all come for free
12:09:11 <luite> but i'm still looking for volunteers ;)
12:09:26 <parcs`> `nand`: that's true. not only does integer-gmp call external libraries, it is also riddled with hand-written cmm
12:09:32 <thoughtpolice> or for everything to match up, picture perfect
12:09:45 <parcs`> luite: does ghcjs use cmm anywhere?
12:09:54 <thoughtpolice> oh, that's a good question actually. luite - does GHC JS go from core -> js, or cmm -> js
12:09:57 <thoughtpolice> i imagine cmm, since it's a bit easier
12:10:01 <luite> no, all cmm has been replaced with javascript (jmacro)
12:10:06 <luite> stg -> js
12:10:20 <`nand`> thoughtpolice: right; which is the reason I'm hesitant about Haskell -> JS implementations in general; they won't be as nice as working with GHC Haskell -> x86 (or similar)
12:10:34 <`nand`> but wait
12:10:49 <`nand`> there's no reason we can't run these C libs in a virtual machine in JS, right?
12:10:52 <Shapeshifter> Hi. How can I make a guard that checks if the string in question can be read to a float? i.e. myfun (s:xs) | read s :: Float = ...
12:11:04 <luite> I was thinking of doing Cmm -> JS, but that means that you have to implement the heap etc exactly as the native GHC
12:11:05 <`nand`> implement an x86 interpreter that runs gmp
12:11:19 <thoughtpolice> `nand`: well, there are x86 interpreters in JS already, yeah
12:11:19 <luite> `nand`: emscripten would be a more logical choice
12:11:26 <thoughtpolice> but emscripten is a bitter route
12:11:33 <luite> gmp is even in the emscripten repository
12:11:34 <bitonic> Shapeshifter: use reads
12:11:39 <bitonic> @google reads
12:11:41 <thoughtpolice> it won't handle things that use hand written assembly or anything
12:11:43 <bitonic> @type reads
12:11:43 <lambdabot> http://reads.lib.overdrive.com/
12:11:43 <DMcGill> :t reads
12:11:43 <lambdabot> Title: Regional eBook & Audiobook Download System
12:11:45 <lambdabot> Read a => ReadS a
12:11:45 <lambdabot> Read a => ReadS a
12:11:49 * bitonic is tired
12:11:51 <thoughtpolice> but GMP for example and lots of optimized libs have fallbacks and stuff that will work
12:11:54 <Shapeshifter> thanks
12:11:57 <thoughtpolice> i think someone even got openssl etc working
12:12:00 <luite> but i think it makes more sense to just reimplement the GMP functions that GHC requires
12:12:00 <DMcGill> ReadS = String -> [(a, String)]
12:12:01 <geekosaur> readMaybe in recent ghc?
12:12:08 <luite> in javascript, using the typed arrays directly
12:12:17 <luite> you cannot do the crazy asm optimizations anyway
12:12:21 <thoughtpolice> luite: i am inclined to agree.
12:12:38 <DMcGill> > case (reads "str" :: Float) of [] -> "failed"; _ -> "succeeded"
12:12:40 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
12:12:40 <lambdabot>              with actual typ...
12:12:42 <luite> perhaps multiplication would still be slower than emscripten gmp, since it would probably be a naive algorithm at first
12:12:43 * bitonic thinks that given how things are now compiling something like Haskell to JS is too much of a mess anyay
12:12:47 <luite> ant not a fancy FFT thing or something
12:12:53 <luite> and
12:13:06 <DMcGill> > case reads "str" of ([] :: [Float]) -> "failed"; _ -> "succeeded"
12:13:07 <atriq> Aaargh
12:13:08 <lambdabot>   Couldn't match expected type `GHC.Types.Float'
12:13:08 <lambdabot>              with actual typ...
12:13:16 <atriq> I'm still struggling to install gtk2hs
12:13:27 <luite> but people are probably not going to do really huge integer stuff in js :)
12:13:30 <thoughtpolice> luite: so do you have a skeleton RTS in JS, too?
12:13:31 <donri> hey if ghc can do some strictness analysis, couldn't it also/instead do "parallelization analysis"?
12:13:32 <DMcGill> > case (reads "str" :: ReadS Float) of [] -> "failed"; _ -> "succeeded"
12:13:33 <lambdabot>   Couldn't match expected type `Text.ParserCombinators.ReadP.ReadS
12:13:34 <lambdabot>           ...
12:13:49 <DMcGill> pft, I give up
12:13:54 <DMcGill> that's about right anyway
12:13:59 <thoughtpolice> donri: it could, but in general that's pretty difficult because it means the compiler has to determine what expressions are worth evaluating in parallel
12:14:04 <`nand`> > readMaybe "str" :: Maybe Float
12:14:06 <lambdabot>   Not in scope: `readMaybe'
12:14:07 <`nand`> yuck
12:14:09 <thoughtpolice> SPJ did some research on profile-driven implicit parallelism years ago
12:14:41 <DMcGill> readMaybe = fst <$> . listToMaybe . readS
12:14:43 <`nand`> > case reads "str" of ([] :: [(Float, String)]) -> "failed"; _ -> "succeeded"
12:14:45 <lambdabot>   "failed"
12:15:00 <donri> aha
12:15:10 <luite> thoughtpolice: the RTS itself is a scheduler, garbage collector and a lot of stg support funtions (function application, try/catch etc). the gc might be replaced later by something that only does reachability checking for cafs and weak refs
12:15:23 <luite> thoughtpolice: and the rest is lots of shims for foreign calls
12:15:29 <thoughtpolice> luite: oh, sure. i was just wondering more how much you had to implement
12:15:40 <thoughtpolice> for LHC we had a very small substrate that did very very little (no scheduler or anything)
12:15:50 <thoughtpolice> so overall it was probably pretty close to the approach you did
12:16:15 <luite> it's pretty big, mainly because of all the autogenerated (jmacro) apply functions
12:16:24 <luite> like stg_ap_ppppv_fat
12:16:25 <thoughtpolice> i wasn't sure if e.g. webworkers and stuff were part of the scheduler
12:16:26 <luite> fast
12:16:28 <thoughtpolice> or if that's all just FFI stuff
12:16:38 <thoughtpolice> (at least in hamish's original code)
12:16:54 <luite> nah the scheduler schedules stuff in one javascript thread, no web workers involved
12:16:57 <`nand`> an interesting approach, I think, would be to allow C calls technically, but call into a ‘super-library’ that translates a bunch of known C calls to javascript implementations of the same
12:16:59 <luite> it's hard to share data between workers
12:17:11 <`nand`> (and perhaps the rest could run through emscripten ;)
12:17:15 <thoughtpolice> that's the impression i get, it's basically just inter-thread message passing
12:17:21 <thoughtpolice> as your only communication form
12:17:28 <luite> thoughtpolice: yep, have to serialize everything
12:17:47 <luite> thoughtpolice: interestingly, with the new code generator, everything can be serialized
12:18:02 <luite> if you have the same javascript source in the worker
12:18:11 <thoughtpolice> oh, cool
12:18:11 <luite> since all closures are now explicit on the heap
12:18:29 <luite> you can just use the gc script to collect every heap object required by some computation, serialize it, and move it over
12:18:59 <Rogach> Hello! I'm in a simple trouble - I can't multiply Int and Float.
12:18:59 <luite> dunno if that will be useful :)
12:19:03 <Rogach> > let i = 1 :: Int
12:19:06 <lambdabot>   not an expression: `let i = 1 :: Int'
12:19:28 <Rogach> > i * 0.1
12:19:30 <lambdabot>   i * 0.1
12:19:54 <geekosaur> Rogach, lambdabot is not ghci
12:19:58 <Rogach> Well, on my machine that complains about the absence of (Fractional Integer).
12:20:02 <Rogach> geekosaur: Sorry :(
12:20:11 <geekosaur> [24 20:18] <Rogach> > let i = 1 :: Int
12:20:11 <geekosaur> [24 20:18] <lambdabot>   not an expression: `let i = 1 :: Int'
12:20:30 <geekosaur> and yes, you will get that error.  haskell is not perl, it does not autoconvert types
12:20:44 <Rogach> geekosaur: What would be the right conversion there?
12:20:59 <luite> `nand`: most packages don't need that many foreign C calls, it's probably easier to just add a shim for them
12:21:01 <geekosaur> let i = 1 :: Int in fromIntegral i * 0.1
12:21:05 <geekosaur> > let i = 1 :: Int in fromIntegral i * 0.1
12:21:07 <lambdabot>   0.1
12:21:14 <geekosaur> > let i = 2 :: Int in fromIntegral i * 0.1
12:21:17 <lambdabot>   0.2
12:21:17 <`nand`> geekosaur: except when it does ;)
12:21:50 <luite> and i kind of think that it's better to have good support for haskell platform, some frp libs and otherwise mostly pure haskell (little FFI) stuff, than to try to support everything on hackage
12:21:51 <Rogach> geekosaur: Thanks!
12:21:51 <`nand`> well, that's not automatic either technically
12:21:55 <`nand`> it's just behind some abstraction layer
12:22:03 <`nand`> I take my injection back
12:22:26 <`nand`> luite: support lens
12:22:28 <`nand`> at the very least
12:22:41 <`nand`> in fact, that should be a design goal
12:22:41 <luite> lens is easy, no FFI
12:22:44 <`nand`> ah
12:22:46 <`nand`> okay
12:22:51 <edwardk> lens is a little inline happy for ghcjs ;)
12:23:03 <thoughtpolice> luite: no, i demand you support all my libraries. they are all FFI bindings :D
12:23:23 <`nand`> is something like.. say, netwire supported?
12:23:26 <thoughtpolice> actually funny enough
12:23:34 <thoughtpolice> most of them would probably work totally fine, via emscripten
12:23:41 <luite> `nand`: well not yet, but that's a goal
12:23:41 <edwardk> luite: is there a tutorial on ghcjs anywhere?
12:23:55 <`nand`> luite: would certainly be nice for stuff like FRP-based JS stuff
12:23:57 <edwardk> i'm mostly curious how you do the build process, what you hook, etc.
12:24:01 <luite> edwardk: it's a bit early for that, i'm still trying to get the new generator working
12:24:19 <thoughtpolice> edwardk: you can check out hamish's original work in the mean time
12:24:24 <luite> next goal is stdout/stderr, so that i can run the ghc test suite
12:24:57 <edwardk> my main reason is that i have a similar project i'd been working on off and on, taking ghc core from there back to another target, but hadnt figured out a nice way to deal with hooking ghc at the right time to do packages, etc.
12:25:17 <thoughtpolice> isn't a lot of that cabal, too?
12:25:26 <edwardk> in my case its for doing whitebox fuzzing in a 'quickproof' style
12:25:32 <luite> edwardk: oh, well, there are two approaches currently in the ghcjs repo
12:25:37 <edwardk> thoughtpolice: hence my curiosity about how ghcjs is doing packages
12:25:52 <luite> edwardk: one is an integrated build, basically a minor patch to the ghc source tree to generate a .js file for every .o produced
12:26:01 <thoughtpolice> edwardk: ah, right :) it's a bit of both, i think
12:26:09 * thoughtpolice shuts up and lets luite do the talking
12:26:50 <edwardk> then you move the .js files around by hand, etc?
12:26:54 <luite> edwardk: the other one is standalone, where the GHC API is used to generate the stuff, and it comes with a few executables to wrap cabal ghc-pkg, and one to 'boot' the compiler, build the core libs (ghc-prim, integer-gmp, base) from a ghc source tree
12:27:21 <luite> the cabal wrapper collects them atm, but i'm not terribly happy with that approach
12:27:35 <edwardk> aha
12:27:57 <edwardk> so to do my quickproof hack, i'd probably want to do something like that
12:27:59 <thoughtpolice> edwardk: i'd direct you to LHC since it has some level of package support from cabal (thanks to lemmih,) but i wrote some of the initial code to do libraries and stuff. let's say i was very young, very new to haskell, and it's not very pretty :)
12:28:28 <thoughtpolice> also, it may be difficult to get any copy of the source repo these days. Lemmih has a copy still i think
12:28:29 <edwardk> thoughtpolice: i went through the lhc cabal integration code. it was sufficiently hellish that i started writing my own compiler from scratch with 0 ghc integration =P
12:28:50 <thoughtpolice> edwardk: yes, it's pretty nuts. that Setup.hs script is perhaps one of the most awful things i have ever written
12:28:56 <thoughtpolice> along with the shims to make it CLI compatible with GHC
12:28:57 * thoughtpolice shivers
12:29:02 <luite> there is a bit of annoyingness involved because javascript cannot do 64 bit integers, and if you have a 64 bit host compiler, the GHC API will generate 64-bit specific code for some things
12:29:06 <luite> (like Typeable hashes)
12:29:14 <luite> i;m not quite sure how to solve that
12:30:11 <thoughtpolice> luite: google's closure library has a 64bit Long type, which is probably faster than just using a raw js bigint type
12:30:18 <edwardk> basically what i want is 'all the core' for installed packages so i can do abstract interpretation over it
12:30:23 <thoughtpolice> but i don't know if you'd have to also ship closure, or you clould snip it out
12:30:27 <thoughtpolice> luite: http://closure-library.googlecode.com/svn/docs/class_goog_math_Long.html
12:30:29 <Rogach> Q: Is there some function on lists like .sliding in Scala? (sliding 2 [1,2,3,4] = [[1,2],[2,3],[3,4]])
12:30:36 <edwardk> in theory that same approach would work for you
12:31:00 <Ferdirand> > map (take 2) . iterate tail $ [1,2,3,4]
12:31:03 <lambdabot>   [[1,2],[2,3],[3,4],[4],[],*Exception: Prelude.tail: empty list
12:31:08 <thoughtpolice> edwardk: so, there's this flag in GHC that will magically unfold every definition into interface files, SPJ added it years ago, and i don't even think it's documented
12:31:15 <k0ral> fmap: what about "doesn't compile" ?
12:31:22 <thoughtpolice> edwardk: one of my Evil Ideas has been to recompile all of stage2 with that flag, then use a core plugin to slurp up everything
12:31:24 <edwardk> thoughtpolice: hrmmmmm
12:31:26 <thoughtpolice> which i think would basically give you WPO
12:31:30 <luite> edwardk: yeah, though for ghcjs it would be better to keep package databases separate, so you can build with GHCJS-specific #defines
12:31:34 <edwardk> thoughtpolice++
12:31:41 <thoughtpolice> :D
12:31:44 <Chathurga> Rogach: (zip <*> tail) xs will give you [(1,2), (2,3)...]
12:31:55 <thoughtpolice> edwardk: unfortunately the plugin may be a little nasty
12:32:08 <thoughtpolice> you'd probably have to wait until you got your Main module, then traverse all the deps to slurp up interfaces
12:32:11 <Chathurga> that's the same as zip xs (tail xs)
12:32:11 <Rogach> @hoogle <*>
12:32:12 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
12:32:13 <thoughtpolice> but the approach is simple
12:32:20 <edwardk> i could live with that
12:32:23 <thoughtpolice> and ideally you could hack GHC a little to make that easier (better CoreM APIs, etc)
12:32:36 <Rogach> Chathurga: Thanks!
12:32:38 <edwardk> i just need to be able to chase everything i'm given
12:32:51 <thoughtpolice> right, i believe that should be quite doable.
12:32:55 <edwardk> since basically i'm looking at a quickcheck property and need to be able to introspect on it all the way down
12:33:02 <Ferdirand> > (zipWith (:) <*> (map (:[]) . tail)) [1,2,3,4]
12:33:04 <lambdabot>   [[1,2],[2,3],[3,4]]
12:33:05 <Chathurga> np, I really like that function
12:33:12 <thoughtpolice> edwardk: i think the flag is uh, -fexpose-all-unfoldings ? it may be buggy, like i said it's very undocumented
12:33:17 <edwardk> then i can do abstract interpretation on it to try to figure out how to force other branches
12:33:23 <thoughtpolice> SPJ added it for "Supercompiler or whole program like things" and it was left there
12:34:26 <thoughtpolice> edwardk: like i said i've been meaning to try this for a while, maybe since i actually have time this weekend i'll try it. if you try it, i'd be interested to hear about it too :P
12:34:38 <fmap> k0ral: well, the latest pango compiles fine here so I was unsure what did you ask gtk2hs maintainers about
12:35:09 <edwardk> if you can some how get me a core-like syntax tree for all the bindings used by a program, i will worship at your feet for at least a day or two
12:35:16 <luite> hehe
12:35:19 <thoughtpolice> hah
12:35:42 <edwardk> and you can get your name up all in lights on my next crazy project idea ;)
12:36:16 <thoughtpolice> worship from edwardk? my name in lights? broadway?
12:36:20 <thoughtpolice> i need no other motivators
12:36:47 <edwardk> sure. make it to new york for the next I <Haskell> NY meetup, and broadway it is ;)
12:36:58 <Rogach> Q: And is there something like zipWithIndex (zipWithIndex ["a","b"] = [("a",0), ("b",1)
12:37:02 <Rogach> ])
12:37:27 <Chathurga> xs `zip` [0..]
12:37:30 <edwardk> > zip [1..] ["hello","world"]
12:37:31 <lambdabot>   [(1,"hello"),(2,"world")]
12:37:35 <edwardk> > zip [0..] ["hello","world"]
12:37:37 <lambdabot>   [(0,"hello"),(1,"world")]
12:37:41 <Rogach> Wow!
12:37:42 <edwardk> pick your starting ordinal
12:38:00 <Rogach> edwardk: Chathurga: Thanks, that's awesome!
12:38:01 <sipa> @pl \x -> zip x [0..]
12:38:01 <lambdabot> flip zip [0..]
12:38:23 <edwardk> :t ["hello","world"]^..withIndices
12:38:25 <lambdabot> [(Int, [Char])]
12:38:28 <edwardk> > ["hello","world"]^..withIndices
12:38:30 <lambdabot>   [(0,"hello"),(1,"world")]
12:38:39 <edwardk> (couldn't resist)
12:38:41 <Chathurga> I dabbled in a little Scala first before haskell, really enjoyed the zip [0..] too :D
12:38:55 <Chathurga> when looking for withIndex
12:39:11 <edwardk> > itoList ["hello","world"]
12:39:13 <lambdabot>   [(0,"hello"),(1,"world")]
12:39:20 <edwardk> > itoListOf traverse ["hello","world"]
12:39:22 <lambdabot>   Couldn't match expected type `Control.Lens.IndexedGetter.IndexedGetting
12:39:23 <lambdabot>    ...
12:39:28 <edwardk> > itoListOf itraversed ["hello","world"]
12:39:28 <sipa> :t withIndex
12:39:29 <lambdabot> Index i a b -> (i -> a) -> b
12:39:30 <lambdabot>   [(0,"hello"),(1,"world")]
12:39:40 <sipa> :t withIndices
12:39:42 <lambdabot> (Applicative f1, FoldableWithIndex i f, Gettable f1) => ((i, a) -> f1 (i, a)) -> f a -> f1 (f a)
12:39:50 <edwardk> :t itoList
12:39:52 <lambdabot> FoldableWithIndex i f => f a -> [(i, a)]
12:40:29 <edwardk> > itoList $ M.fromList [("jello",2),("world",4)]
12:40:31 <lambdabot>   [("jello",2),("world",4)]
12:40:59 <thoughtpolice> edwardk: i'm thinking of visting boston for a few days just to work remotely and travel a little some time after the new year, so i'll hold you to that one :P
12:41:20 <edwardk> sounds good. i'll practice my adoring gaze
12:42:22 <ion> I have only used GLFW in C, but yeah, it’s nice.
12:42:30 <ion> Re: earlier discussion
12:42:51 <Rc43> Hi, guys/
12:43:13 <applicative> hi Rc43
12:43:15 <ion> edwardk: Huh. I thought “source” and “target” is where they originated. :-)
12:43:26 <edwardk> ion: nope, t comes after s ;)
12:43:33 <atriq> Yeah, I'm really struggling installing gtk2hs
12:43:46 <atriq> Anyone willing to give some time to help me?
12:44:24 <hpaste> Rc43 pasted “DatatypeContexts” at http://hpaste.org/78163
12:44:31 <Rc43> How should it be implemented?
12:44:46 <Rc43> Now DatatypeContexts considered misfeature.
12:44:58 <Rc43> But I want enforce that parameter must be RandomGen.
12:45:45 <Rc43> Ideally it is without any parameters, like; rand :: RandomGen g => g; but it is impossible, because it will be different g then in `pack` function.
12:45:50 <fmap> atriq: ghc 7.6?
12:46:05 <atriq> Yeah
12:46:16 <atriq> Please don't say downgrade
12:46:17 <merijn> Rc43: You could use GADTs
12:46:19 <fmap> atriq: did you upgrade gtk2hs-buildtools?
12:46:32 <atriq> fmap, it's the newest version from cabal...
12:46:45 <merijn> Rc43: Your functions would still require the RandomGen constraint, though
12:47:11 <fmap> atriq: okay, paste errors
12:47:26 <Rc43> merijn, I got it; but is it real to implement without any parameters?
12:47:33 <merijn> Rc43: Can you give a more specific/elaborate use case?
12:48:36 <Rc43> merijin, context doesn't make sense; I just want to store my RandomGen.
12:49:13 <atriq> fmap, http://hpaste.org/78164
12:49:54 <merijn> Rc43: Yes, but why would that require a DatatypeContext?
12:50:24 <fmap> atriq: I'm not sure $HOME is expanded
12:50:36 <Rc43> merijin, because I want ot enforce that parameter of datatype must be RandomGen, so I put it in the datatype's context.
12:51:01 <fmap> atriq: what `which gtk2hsC2hs' says?
12:51:09 <merijn> Rc43: Why do you want to enforce it? Map and Set don't enforce their typeclass restrictions either
12:51:56 <atriq> fmap, nothing.
12:52:02 <atriq> I think that's my problem, then
12:52:05 <merijn> :t Data.Set.empty
12:52:06 <lambdabot> S.Set a
12:52:11 <merijn> :t Data.Map.empty
12:52:13 <lambdabot> M.Map k a
12:52:18 <burbul> Is there a nicer way of writing
12:52:19 <burbul> filter (liftM2 (||) isDigit (== '.')) s
12:52:19 <burbul> ?
12:52:34 <merijn> Rc43: No Ord constraints there either, so why would yours need a RandomGen constraint?
12:52:42 <Rc43> merijn, I am not planning to use it with other types; in my context this type is "data Session = Session { table :: Map Int Int; random :: <random> }".
12:53:27 <Rc43> merijn, perhaps, I don't need this type at all; but just interesting how to do it.
12:53:40 <geekosaur> gah
12:54:01 <geekosaur> so, it looks to me like atriq's $PATH setting is singlequoted so $HOME is not being expanded
12:54:11 <geekosaur> doublequotes are more appropriate usually
12:54:13 <merijn> Rc43: Well, you could use ExistentialQuantification or GADTs (which is essentially EQ, but with a prettier syntax, imo)
12:54:57 <byorgey> burbul: not using only stuff from standard libraries
12:55:06 <byorgey> burbul: but you can easily define  (<||>) = liftM2 (||)
12:55:18 <k0ral> fmap: well hackage agrees with me: no successful compilation with ghc 7.6
12:55:20 <geekosaur> @tell atriq looks like your PATH setting is wrapped in single quotes?  use double quotes instead ("" vs. '') so $HOME etc. will be expanded
12:55:21 <lambdabot> Consider it noted.
12:55:25 <ion> M :-(
12:55:36 <thoughtpolice> Rc43: it's worth noting that DatatypeContexts is widely considered a misfeature, because it really doesn't buy you a lot. the constraint for the type context isnt propogated as you would expect intuitively. if you had data Eq a => Bar a, you'd think you could say 'f :: Bar a -> ...' without mentioning Eq
12:55:38 * hackagebot fay 0.10.1.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.10.1.0 (ChrisDone)
12:55:53 <thoughtpolice> but you can't. so it hasn't really bought you anything in brevity or clarity, in cases where you need the constraint, you still need it
12:55:56 <merijn> Rc43: "data Session = forall g . RandomGen g => Session (Map Int Int) g", but then you can never know which randomgen you have
12:56:41 <merijn> Or, GADT style "data Session where Session :: RandomGen g => Map Int Int -> g -> Session"
12:56:51 <merijn> Neither of which really help all that much, I think
12:57:49 <Rc43> merijn, look like what I want
12:58:09 <burbul> @byorgey: thanks
12:58:09 <lambdabot> Unknown command, try @list
12:58:19 <fmap> k0ral: that's probably because the process of installing gtk2hs is somewhat involved, one need manually upgrade gtk2hs-buildtools before installing other libs
12:58:34 <fmap> (and nobody had done this on hackage)
12:59:20 * thoughtpolice thinks he's maybe the only person who uses the type-equality style syntax for GADTs
12:59:42 <merijn> thoughtpolice: What do you mean by that?
13:01:01 <thoughtpolice> instead of 'data Eq a b where Refl :: Eq a a' or whatever, you can say 'data Eq a b = (a ~ b) => Refl a b' - this is basically how GHC translates the GADT witness into an equality constraint anyway. i like it because i think it makes it a bit clear what equalities a GADT imposes
13:01:08 <thoughtpolice> also, i like it because i'm a rebel :P
13:01:25 <atriq> fmap, okay, gtk2hsC2hs runs if I type it in, but doesn't give anything for which
13:01:25 <lambdabot> atriq: You have 1 new message. '/msg lambdabot @messages' to read it.
13:02:31 <thoughtpolice> merijn: and of course that extends to multiple constructors as you'd expect: 'data Foo ... = (... ~ ...) => Con1 ... | (... ~ ...) => Con2 | ...' where each type equality constraint matches what you want, obviously
13:02:43 <atriq> geekosaur, it was in double quotes...
13:03:03 <atriq> But I've manually expanded it now (I'm the only user on this computer...)
13:03:55 <geekosaur> um.  where was it then?  Shells expand variables in doublequotes.  Something like /etc/environment might not
13:04:11 <geekosaur> (but setting this kind of thing there is probably not wise)
13:04:12 <atriq> It was /etc/environment, yeah
13:04:24 <atriq> I don't really know what I'm doing
13:04:35 <geekosaur> maybe use a file in /etc/profile.d to add stuff to the environment instead
13:05:09 <geekosaur> that's alos more robust against system upgrades etc.
13:05:25 <atriq> So, how would I do that?
13:07:10 <neutrino_> in a cabal file, i have several binaries that import the same module. the module comes from the same package. can i specify its build depends only once, or do i have to list them for every binary i build?
13:08:50 <neutrino_> can i somehow list build dependencies only for the module in question?
13:09:17 <geekosaur> atriq, put your $PATH change in a file in /etc/profile.d; that file should have an extension of .sh, and should be executable
13:10:38 <geekosaur> so something like /etc/profile.d/localpath.sh, and run "sudo chmod +x /etc/profile.d/localpath.sh" after creating it
13:11:10 <hpaste> autthor pasted “title” at http://hpaste.org/78165
13:11:24 * geekosaur was looking for quick web references but the top hit for arch has a remarkable amunt of misinformation in it.  someone does not get the difference between $PATH and $LD_LIBRARY_PATH
13:12:47 <neutrino_> hey guys
13:12:51 <neutrino_> why is Set not a monad?
13:12:57 <atriq> Ord requirements
13:13:12 <neutrino_> what do you mean atriq?
13:13:26 <atriq> :t S.map
13:13:27 <lambdabot> (Ord b, Ord a) => (a -> b) -> S.Set a -> S.Set b
13:13:27 <ion> *cough* http://hpaste.org/50278
13:13:44 <neutrino_> right
13:13:50 <neutrino_> but why does that stop it from being a monad?
13:13:59 <atriq> :t liftM
13:14:00 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
13:14:05 <atriq> No Ords
13:14:32 <atriq> Or you could cheat and do what ion just linked
13:14:56 <ion> (Pro tip: it typechecks, but it won’t work. Seriously.)
13:15:00 <atriq> But that can have disastrous results
13:15:00 <neutrino_> how does that cheat work
13:15:07 <atriq> It doesn't, pretty much
13:15:48 <neutrino_> haha
13:15:49 <neutrino_> ok.
13:16:20 <ion> It will result in Sets like:
13:16:23 <thoughtpolice> ion: ew :P
13:16:26 <ion> > S.fromList [0,1,2,0,1,2]
13:16:28 <lambdabot>   fromList [0,1,2]
13:16:35 <ion> whoops
13:16:40 <ion> > S.fromDistinctAscList [0,1,2,0,1,2]
13:16:42 <lambdabot>   fromList [0,1,2,0,1,2]
13:17:04 <neutrino_> haha.
13:17:16 <hpaste> autthor pasted “title” at http://hpaste.org/78166
13:17:27 <neutrino_> ok but
13:17:48 <neutrino_> why is it bad that Set has Ord requirements?
13:18:06 <neutrino_> i realize liftM hasn't got them but why can't you have a liftM with them?
13:18:45 <ion> Type families would make that possible, but Functor, Applicative and Monad classes predate type families.
13:18:50 <jesyspa> So, hang on, the problem is that you can only store certain things in sets, while a monad requires you to be able to store anything?
13:18:52 <pauser> hi, im having an unusual error at here http://hpaste.org/78166 . ERROR "Aufgabe6.hs":21 - Instance of Num [Int] required for definition of helpShow . do you maybe know why does it come so ?
13:19:11 <osa1> how does Extra-source-files work in cabal ? I specify modules as extra because I don't want users to import that packages, but then my package doesn't work because that packages are not compiled to .hi (or some other required format) when `cabal install` .
13:19:16 <ion> jesyspa: Not exactly.
13:19:18 <neutrino_> ion: can they be possibly rewritten using type families?
13:19:36 <ion> neutrino: Alas, that would break backwards compatibility.
13:19:49 <neutrino_> sure
13:19:51 <neutrino_> but
13:19:52 <fmap> osa1: you want other-modules: section, not extra-source-files:
13:19:54 <dcoutts_> osa1: extra-source-files is basically for extra things to stick into the sdist, but that the main build system is not otherwise aware of
13:19:58 <neutrino_> fail at all cost, right ion?
13:20:16 <osa1> aha
13:20:27 <ion> I’m all for fixing the issues with the type classes, but i’m not the one in charge. :-P
13:20:52 <jesyspa> ion: Could you explain what the issue is, then?
13:21:28 <thoughtpolice> jesyspa: imagine this, i want to 'map' over a Set. but Set carries the 'Ord a' requirement, while 'map' does not. it would also be nice if i could map lists still, too. so i need a type like, 'map :: ??? => (a -> b) -> ...' where the ??? is a constraint filled in, based on the type you are applying it to
13:21:42 <neutrino_> jesyspa: it looks like some kind of incompatibility due to too narrow typing of liftM.
13:21:52 <neutrino_> which could have been made more slack if type classes were used.
13:21:56 <thoughtpolice> jesyspa: basically, you aren't carrying around the necessary constraints in places you need them. you can't make Set a monad, or a functor, because it's impossible to have e.g. fmap/return/bind mention the Ord constraints
13:22:10 <osa1> fmap: in which field should I put extra license files ?
13:22:15 <shachaf> And you especially can't make Set Applicative.
13:22:18 <parcs`> :t S.map
13:22:20 <lambdabot> (Ord b, Ord a) => (a -> b) -> S.Set a -> S.Set b
13:22:24 <shachaf> Because <*> doens't even type-check.
13:22:27 <thoughtpolice> you can fix this using ConstraintKinds, which allow you to abstract over the constraint language. but GHC has only been able to do that *really* recently, and in 7.4.x it was buggy
13:22:28 <parcs`> i wonder what the Ord a constraint is for
13:22:28 <ion> jesyspa: fmap :: Functor f => (a -> b) -> f a -> f b. You could make an implementation where f is Set, but you can’t add an “Ord a, Ord b” constraint.
13:22:43 <jesyspa> Ahh, I see.
13:22:52 <jesyspa> Yes, I get it, thanks.
13:23:08 <hpaste> Crockeo pasted “Interactive Test” at http://hpaste.org/78167
13:23:25 <Crockeo> (Nothing special, I just finished a little learning-program and I wanted to show it off :D)
13:24:08 <neutrino_> parcs`: so that you know where to put your new element.
13:24:29 <jesyspa> Crockeo: Can't input be implemented as determineDirection <*> getChar?
13:24:34 <parcs`> neutrino_: that's what the Ord b constraint does
13:24:47 <neutrino_> oh, you mean on map?
13:24:50 <parcs`> yeah
13:25:10 <Crockeo> jesyspa: <*>?
13:25:21 <neutrino_> ord a there is because S.Set a has Ord a
13:25:28 <thoughtpolice> and like ion said, you could overload a lot of the standard type classes to support this like monad/functor, but it destroys backwards compatibility, and it introduces pretty high-level features for people who might not be ready
13:25:28 <jesyspa> Crockeo: Applicative A => A (a -> b) -> A a -> A b
13:25:59 <thoughtpolice> i think edwardk also had some complaints against this (using CKs + ATs for monad/functor etc, i think he said it destroys certain kinds of polymorphic abstraction?)
13:25:59 <parcs`> neutrino_: that's not true. for example
13:26:01 <jesyspa> (And IO is applicative, I'm fairly sure, as it's a monad.)
13:26:17 <parcs`> :t (S.empty, S.singleton) -- neither of those have an Ord constraint
13:26:18 <lambdabot> (S.Set a, a1 -> S.Set a1)
13:26:25 <edwardk> polymorphic recursion
13:26:26 <ion> jesyspa: (<*>) isn’t the right operator here.
13:26:28 <neutrino_> parcs`: hmm
13:26:36 <neutrino_> parcs`: i suck at types :)
13:26:38 <parcs`> looking at the source code, the Ord a constraint is entirely superfluous given how map is defined
13:26:40 <jesyspa> Hm, indeed, <$>
13:26:57 <parcs`> Set.map f = fromList . Prelude.map f . toList
13:26:59 <jesyspa> ion: Right?
13:27:01 <neutrino_> parcs`: wait, i think i know
13:27:03 <ion> yeah
13:27:13 <neutrino_> to create a set Set b you need b to be Ord b, right?
13:27:26 <donri> is there a good resource for when to enable -O2 ?
13:27:29 <parcs`> :t S.mapMonotonic
13:27:29 <Crockeo> jesyspa, ion: Thank you! Anything else you'd change in there?
13:27:30 <lambdabot> (a -> b) -> S.Set a -> S.Set b
13:27:44 <sacundim> Crockeo, I'd look at the Control.Monad package
13:27:48 <neutrino_> but how will you create a type Ord b => b from a type which is !(Ord a) => a? you can't, i think.
13:27:55 <parcs`> donri: when you can tolerate the compile times :P
13:27:56 <Crockeo> sacundim: Will do captain!
13:28:00 <sacundim> it has many very useful reusable fucntions
13:28:22 <edwardk> thoughtpolice: even things like Data.Traversable die horribly
13:28:25 <neutrino_> parcs`: think i'm onto something?
13:28:36 <edwardk> thoughtpolice: it works fine as everything you want to do is boring and first order
13:28:40 <sacundim> for example, your input function is this: liftM determineDirection getChar
13:29:19 <sacundim> i'm sure there's a function in Control.Monad that can help you write your loop function cleaner too
13:29:21 <parcs`> neutrino_: i don't follow
13:29:24 <jesyspa> Crockeo: ['#'] looks weird to me, as it's just "#", but that might just be me.
13:29:36 <neutrino_> parcs`: you have a function which spits out an ordered type
13:29:40 <edwardk> thoughtpolice: lens also doesnt work ;)
13:29:42 <jesyspa> sacundim: Should liftM be preferred over fmap if the type implements Functor as well as Monad?
13:29:47 <neutrino_> parcs`: it needs to consume an ordered type too.
13:29:55 <edwardk> jesyspa: use fmap if you can, liftM when you have to
13:29:59 <sacundim> jeyspa, no, but i'm keeping it simple for Crockeo right now
13:30:02 <neutrino_> parcs`: otherwise it doesn't "make sense" to map from an unordered to an ordered type.
13:30:09 <jesyspa> Ah, okay.
13:30:13 <Rc43> What are the rules of memoization in ghc? And are they different from ghci?
13:30:18 <edwardk> jesyspa: liftM is a valid implementation of fmap, but fmap can be implemented more efficiently
13:30:18 <Crockeo> jesyspa: I suppose it does, but I'd imagine (considering String /is/ just [Char]) that it's equivalent.
13:30:50 <Rc43> E.g. will be memoized long_calc in this: func = somthing where long_calc = ... ?
13:31:02 <ion> @type \f -> S.fromList . map f . S.toList
13:31:03 <lambdabot> Ord a => (a1 -> a) -> S.Set a1 -> S.Set a
13:31:06 <jesyspa> Crockeo: Yeah, I think it's the same thing.
13:31:13 <Rc43> ghci memoizes
13:31:20 <ion> neutrino: ↑
13:31:28 <sacundim> talking about set monads, i saw this package the other day and I was curious what the general opinion is: http://hackage.haskell.org/package/set-monad
13:31:41 <Crockeo> Also, while we're on the topic of improving it is there a way I can get character input without also having to grab the newline char?
13:31:50 <edwardk> Rc43: ghc remembers the result of values, not of functions. if you say let x = 2 + 3 in ( …x… x… x) -- then the first time you need x it'll be calculated, and then when the other references use it they'll use the calculated value.
13:31:51 <sacundim> i saw some mailing list discussion that was concerned about performance issues in a particular use pattern
13:32:19 <Crockeo> It makes it inconvenient for the user and it also makes it output the thing twice.
13:32:31 <edwardk> Rc43: ghci does the same thing. now that said, turning on/off the monomorphism restriction can change what it means for that value to be memoized
13:32:40 <neutrino_> ion: sure, but i think still some semantic value is lost
13:32:43 <parcs`> neutrino_: the Ord a constraint will come naturally if you perform other set operations on the original set that actually require the elements to have an Ord constraint, like Set.insert or Set.delete.
13:32:49 <edwardk> and ghci 7.6 defaults to turning off the MR.
13:32:55 <sacundim> crockeo, i don't understand your question.  do you mean something like suppress echo of '\n'?
13:33:01 <edwardk> this can lead to slighly reduced sharing if you aren't careful
13:33:12 <jesyspa> Crockeo: Also, on line 17, you could use ['%' | _ <- [1..num]], and I think there's a function for making a list of n of the same thing.
13:33:15 <Crockeo> sacundim: With normal getChar you enter the character and press enter.
13:33:18 <parcs`> neutrino_: but given that 'Set.empty :: Set a' and 'Set.singleton :: a -> Set a', neither of which have an Ord constraint, 'Set.map' shouldn't have an Ord a constaint
13:33:26 <edwardk> :t replicate
13:33:28 <lambdabot> Int -> a -> [a]
13:33:33 <ion> edwardk: Oh, i didn’t know 7.6 defaults to NMR. Interesting.
13:33:34 <edwardk> > replicate 4 '%'
13:33:36 <lambdabot>   "%%%%"
13:33:50 <Crockeo> edwardk: I was looking for a function like that. Thank you.
13:34:08 <sacundim> Crockeo: Data.List
13:34:39 <Crockeo> Man
13:34:41 <Crockeo> Haskell has such a large library.
13:35:03 <jesyspa> Crockeo: I think in the move function, you could define it as move Leftward player = moveLeft player \ move Rightward player ...
13:35:04 <Rc43> edwardk, thanks for explanation; btw, simple test I used to:
13:35:05 <hpaste> Rc43 pasted “test of memoization” at http://hpaste.org/78169
13:35:10 <jesyspa> Not sure if that'd be better; it'd be shorter.
13:35:36 <edwardk> Crockeo: it "feels" large because the functions are sitting there naked and not hiding in objects somewhere mostly. also we encourage highly compositional libraries
13:35:47 <Rc43> edwardk, have you example when monomosphism restriction changes something?
13:36:28 <edwardk> :t  let foo = sum [1..100000] in foo
13:36:28 <ion> rc43: fibs :: Num a => [a] vs. fibs :: [Integer]
13:36:30 <lambdabot> (Enum a, Num a) => a
13:36:31 <edwardk> lets start there
13:37:05 <thoughtpolice> edwardk: back. and yeah, i think i see what you mean. if you enforce all those constraints everywhere, you basically murder polymorphic recursion, since the constraint basically ensures you can't recurse over the new type
13:37:08 <edwardk> with the MR that will make foo monomorphic so if you use it twice the two 'a's will have to be the same
13:37:22 <thoughtpolice> s/new type/new polymorphic type/
13:37:38 <edwardk> this means that the values are the same, but what happens when one use is a Complex number? the other would just use defaulting to become an Integer. so they can't be the same value
13:37:52 <edwardk> now you have two sums being run, in different numeric types, with no sharing
13:37:59 <pauser> can i define many constants like in here : http://hpaste.org/78171
13:38:01 <neutrino_> parcs`: hmm
13:38:03 <sacundim> Crockeo: try this: http://compgroups.net/comp.lang.functional/-haskell-getchar-without-echo/1051800
13:38:09 <edwardk> once you destroy sharing on valuesi can make th relative runtime degrade exponentially
13:38:15 <parcs`> neutrino_: ignoring the semantic argument there is probably a performance impact with passing around an unused constraint
13:38:17 <neutrino_> parcs`: parcs` indeed, and that's weird
13:38:20 <Crockeo> sacundim: ty.
13:38:51 <jesyspa> Crockeo: About your getChar problem, it sounds like you want to turn off stdin buffering.
13:38:55 <edwardk> thoughtpolice: the death of even simple things like Traversable and Foldable are a good sign that its a bad idea ;)
13:39:06 <Crockeo> jessyspa: Ty as well.
13:39:08 <ion> pauser: What are you trying to do?
13:39:18 <thoughtpolice> edwardk: noted :)
13:39:19 <k0ral> fmap: right, by rebuilding the buildtools, it compiles, thanks
13:39:41 <sacundim> Crockeo: i think you also have to turn off buffering
13:40:09 <jesyspa> Crockeo: That requires System.Environment and the command is hSetBuffering stdin NoBuffering
13:40:13 <pauser> ion: just trying to learn "where" . because im having some problems here http://hpaste.org/78166 it says Aufgabe6.hs":21 - Instance of Num [Int] required for definition of helpShow
13:40:22 <Crockeo> jesyspa: I tried that, but it didn't seem to work :(
13:40:24 <parcs`> neutrino_: also one can argue that removing the 'Ord a' constraint makes the function easier to reason about, much like 'Map.intersection :: Ord k => Map k a -> Map k b -> Map k a' is easier to reason about than 'Map.intersection :: Ord k => Map k a -> Map k a -> Map k a'
13:40:27 <jesyspa> Or maybe System.IO)
13:40:41 <jesyspa> Hm, command is the general term for IO (), right?
13:40:44 <Crockeo> (Then I removed it after it didn't work)
13:40:52 <sacundim> System.IO
13:41:03 <sacundim> i'm trying it here, and no success
13:41:05 <anshul> I am hoping somebody can help me understand "associated type synonyms"
13:41:17 <Crockeo> Everyone: I'll be implementing the changes all of you suggested.
13:41:21 <sacundim> gee, i kinda get monads but IO stumps me :-P
13:41:58 <ion> pauser: Line 21 seems to be helpShow 1= "I"
13:42:01 <jesyspa> Crockeo: You can also get hlint, which will suggest some basic changes.
13:42:05 <thoughtpolice> sacundim: maybe you should eat a burrito? :P
13:42:12 <atriq> Thanks, people who helped me with gtk2hs
13:42:25 <Crockeo> jesyspa: Thank you yet again.
13:42:27 <atriq> It seems to be working now
13:42:30 <pauser> ion: yeah but why is it wrong ?
13:42:54 <neutrino_> parcs`: mhm
13:42:54 <ion> pauser: It doesn’t seem to be wrong. Are you sure the error message is from that exact file in the hpaste?
13:43:46 <hpaste> sacundim pasted “For Crockeo” at http://hpaste.org/78172
13:43:47 <pauser> ion: 100% sure, but it worked before i defined where
13:43:47 <jesyspa> I think the step from applicative functor to monad isn't that large.
13:43:59 <sacundim> not exactly what you want, but this program echoes each character one by one
13:44:11 <donri> are there ghc extensions that cause different parse results of the source code? i'm curious if ghc works by first parsing with all extensions turned on, so to speak, and only then does a second pass to fail for code requiring an extension not enabled
13:44:26 <donri> that seems to be a common practice with haskell-src-exts
13:45:27 <donri> hm i imagine TH changes the parse for things involving $
13:45:53 <illissius> donri: IIRC GHC gave me parse errors for code that used MagicHash without specifying it
13:46:12 <donri> illissius: but maybe it fakes that by post-processing the AST?
13:46:32 <anshul> Anyone? Help needed with Associated Type Synonyms http://pastebin.com/kzAXjbfA
13:46:36 <hpaste> sacundim pasted “For Crockeo, same example, but simplified a bit” at http://hpaste.org/78174
13:47:06 <donri> hm and any extension that steals a keyword should change the parse ...
13:47:07 <illissius> donri: I dunno, I remember them being of the form "what the heck does this error even mean?" until I realized that it was because GHC was trying to interpret the code without knowing about my MagicHashing
13:47:13 <illissius> so i don't think so
13:47:17 <Crockeo> Ty sacundim!
13:47:38 <donri> what confuses me is that haskell-src-exts seems to consist of a single parser that doesn't really know about extensions, but somehow this isn't a problem o?O
13:48:01 <illissius> donri: well, GHC /= haskell-src-exts :)
13:48:12 * illissius dunno nothing about h-s-e
13:48:13 <donri> yea but both parse GHC haskell with extensions
13:48:36 <jesyspa> sacundim: I think disabling output buffering would make more sense than calling hFlush like that.
13:48:38 <illissius> could be they do it different ways
13:49:19 <sacundim> jesyspa: likely, yeah, i' m still trying to figure it out
13:49:46 <zrxy> I have a cascade of case statements for parsing, each of which matching [] and [(x,y)]. There's a nice way to monadify this, no?
13:49:50 <sacundim> let me try that
13:50:18 <illissius> zrxy: ...is there ever more than one element in the list? :p
13:50:30 <zrxy> nope
13:50:35 <illissius> then why not use Maybe?
13:50:46 <anshul> Hello all. I am wondering if anyone can help me with "Type Families" http://pastebin.com/kzAXjbfA
13:50:47 <hpaste> sacundim pasted “With output buffering disabled” at http://hpaste.org/78176
13:50:59 <sacundim> yeah, thanks jesyspa
13:50:59 <zrxy> illissius: because it hooks into readsPrec
13:51:26 <mauke> The paste kzAXjbfA has been copied to http://hpaste.org/78177
13:51:38 <`nand`> mauke stopped copying pastebin links?
13:51:39 <`nand`> oh
13:52:09 <donri> illissius: ignore me, the parser does know about extensions (checkEnabled)
13:53:11 <illissius> zrxy: if your [] branches are all [] -> [] then if it were Maybe instead you could use the Maybe monad, I'm not sure (because I've never bothered to _really_ understand it) whether the list monad is equivalent to the maybe monad for the cases where length is max 1
13:53:15 <illissius> but maybe.
13:54:33 <illissius> > Nothing >> Just 3
13:54:34 <lambdabot>   Nothing
13:54:39 <zrxy> illissius: I can't change the [], because I do readsPrec prec = myParser
13:54:42 <illissius> > [] >> [3]
13:54:44 <lambdabot>   []
13:54:51 <illissius> > Just 3 >> Nothing
13:54:52 <lambdabot>   Nothing
13:54:57 <illissius> > [3] >> []
13:54:58 <applicative> sacundim: is that your paste; the error is due the the m in  toList m
13:54:59 <lambdabot>   []
13:55:35 <neutrino_> parcs`: do you think the evidence leads to believe that Set.map was given extra constraints in order to sabotage its ability to become a monad?
13:55:51 <sacundim> uh, what paste
13:55:58 <applicative> wait  that was anshul 's paste
13:56:17 * sacundim sees the paste, and its not his
13:56:41 <anshul> @sacundim :: now that you see it ...
13:56:41 <lambdabot> Unknown command, try @list
13:56:48 <anshul> :)
13:58:28 <zrxy> there isn't a monad to combine readsPrec-type parsers?
13:58:48 <zrxy> or is it the list monad?
13:59:14 <illissius> zrxy: so I'm pretty sure the List monad is equivalent to Maybe for length <= 1
13:59:22 <OceanSpray> is there a Debug.Trace that can be turned on or off depending on whether it's a debug build or something
13:59:24 <illissius> zrxy: are your [] branches all -> []?
13:59:39 <zrxy> illissius: yes
13:59:52 <osa1> duh. is this real ? http://hackage.haskell.org/packages/accounts.html why we don't have a register form ?
13:59:55 <applicative> anshul: it's just that m is not used on the right hand side, so kill it on the left or use it on the right
14:00:03 <zrxy> illissius: I thought you lambdabot experiment failed -- doesn't [3] have to survive to [3] instead of []?
14:00:34 <applicative> osa1: Ross Patterson is an excellent register form
14:00:36 <illissius> zrxy: nah, the point was the it did the same thing as the Maybe version
14:01:06 <anshul> @applicative ... are you looking at http://hpaste.org/78177 ?
14:01:06 <lambdabot> Unknown command, try @list
14:01:32 <applicative> anshul: yes
14:01:32 <illissius> zrxy: (and join for [] is concat, which after analyzing the 3 possible cases seems to do the same exact thing as join for Maybe if length <= 1)
14:01:35 <bootcode> hi!
14:02:03 <applicative> hi bootcode
14:02:39 <bootcode> a quick question before I can get to sleep in peace: where is the transformers RWST (or State for the matter) defined to be an mtl MonadState instance?
14:02:46 <illissius> zrxy: SO getting to the point, instead of case foo x of [] -> []; [a] -> case bar a of [] -> []; [b] -> ... you can: do { a <- foo x; b <- bar a; ... }
14:02:47 <applicative> anshul: I was saying, 'toList m = M.assocs . snkPinMap` should be `toList = M.assocs . snkPinMap`
14:03:15 <illissius> zrxy: but test it out to make sure I'm not talking crazy. :)
14:03:16 <anshul> applicative ... thanks !! Error was not about associated types at all! Silly me. Thansk
14:04:11 <`nand`> it took me quite a bit longer to realize it, but I came to the same conclusion as applicative :)
14:04:19 <`nand`> this is why points are bad
14:04:25 <bootcode> checking the hackage apidoc for mtl's MonadState seems to only define instances for mtl RWS. In the transformer RWS apidoc I don't see such instance declared.
14:05:49 <zrxy> illissius: thanks I'll give it a stab
14:07:59 <illissius> @check True == True
14:08:01 <lambdabot>   Not in scope: `myquickcheck'
14:08:10 <illissius> when did that break? :( or am I doing it wrong?
14:08:28 <DMcGill>  @check myquickcheck = True == True
14:09:41 <efie> when I compile with the -prof flag I get "/usr/bin/ld: cannot find -lHStime-1.4_p collect2: ld returned 1 exit status" after the linking step. did someone came across this?
14:10:07 <dsantiago> When someone says something runs in constant memory in Haskell (as in the first example here under "Connect" http://www.yesodweb.com/book/conduits ) does that mean that a chunk of memory is getting reused, or are they just approximating the long-run average under GC? I've seen people say things are constant-memory before in Haskell.
14:10:07 <shachaf> It broke when GHC was upgraded.
14:10:50 <applicative> bootcode: I seem to see it here http://hackage.haskell.org/packages/archive/mtl/2.1.2/doc/html/src/Control-Monad-State-Class.html
14:11:07 <watermind> is a naive quicksort supposedly worse than a version with an intermediate tree structure?
14:12:27 <watermind> the 1st is supposedly the deforested version of the latter, but it seems like it ends up constructing much more intermediate  structures
14:12:54 <monochrom> deforesting is not always automatic
14:13:06 <zrxy> illissius: yep that worked. The pattern I used is (foo, rem) <- parseFoo initial ; (bar, rem) <- parse Bar rem ; ...
14:13:08 <zrxy> thanks
14:13:58 <applicative> monochrom: but its  'deforested'  because no tree type appears anywhere, no?
14:14:09 <illissius> welcome
14:14:31 <watermind> monochrom: yes I understand that, I'm not thinking of any atomation here
14:15:00 <bootcode> applicative: ah, so mtl just reexports the RWS and State monads from transformer?
14:15:16 <applicative> bootcode: yes
14:15:19 <watermind> monochrom: just wondering if the version without an intermediate tree should be much better than the one with a tree, given that it builds a bunch of intermediate lists anyway
14:15:31 <applicative> bootcode: though the whole thing is a bit hard to penetrate
14:15:32 <monochrom> then I don't know
14:15:32 <bootcode> applicative: thank you, that wasn't obvious for me
14:16:15 <applicative> bootcode: this was the resolution of a much more gruesome state of affairs with flatly contradictory transformer libraries
14:18:07 <watermind> at every level of recursion we'd have n elements total, and there are log n levels, that is n*log n  with lists
14:18:08 <applicative> bootcode: transformers makes the real types; mtl just piles up classes.  some people disapprove of the latter. the real downside is that lots of tutorials fail since e.g. State s a is now a synonym for StateT s Identity a -- which sort of means you cant understand monads til you understand monad transformers
14:21:11 <parcs`> dsantiago: what does "long run average under GC" mean?
14:21:54 <watermind> while the tree has n nodes and therefore n-1 edges
14:22:03 <dsantiago> parcs`: Well, when I hear "constant memory," I think of some buffer that is being written to numerous times or something like that. But it could also be the case that it is allocating new objects over and over and disposing of them fast enough that the GC, as it runs, keeps memory at around the same level over time.
14:22:26 <watermind> which means the version with lists should produce log n times more intermediate structure
14:22:36 <watermind> unless I'm missing something
14:27:03 <applicative> bootcode: here is a historical overview that sort of got me comprehending it http://www.haskell.org/pipermail/libraries/2012-April/017702.html
14:27:33 <monochrom> we count "allocate then GC then allocate then GC ..." as constant memory, too
14:27:36 <parcs`> dsantiago: well the rts allocates chunks of memory at a time and then uses that chunk of memory to store objects. so it's a little bit of both i guess
14:28:14 <dsantiago> OK. I'd have been interested if there was some mechanism or optimization that allowed a piece of memory to be reused like that. Thanks.
14:29:53 <zrxy> emacs doesn't seem to understand case statements -- underneath "case foo of", it doesn't indent the cursor below it (no matter how many TAB hits I make)
14:30:08 <zrxy> I thought this worked before
14:30:37 <zrxy> Like the auto-insert of "foo" below "foo :: Bar" I thought was working, but now is not
14:30:53 <aristid> zrxy: maybe you have a syntax error above that confuses the parser?
14:31:10 <zrxy> aristid: no, it compiles fine
14:31:20 <zrxy> This is for foo x y = case x of
14:31:32 <zrxy> it does indent if there's no whitespace before the case
14:31:33 <aristid> zrxy: which version of haskell-mode?
14:31:55 <aristid> zrxy: keep in mind it doesn't have a _real_ parser under the hood
14:33:28 <monochrom> after "foo x y = case x of", it indents, just not as far as "case". it may be configurable
14:34:23 <zrxy> aristid: I have 2.8.0. I'm looking at the github version but haven't figured out what the latest number is yet
14:34:38 <aristid> zrxy: there are no numbered releases since 2.8.0
14:34:53 <aristid> zrxy: i use marmalade and package.el to get a recent version
14:34:55 <parcs`> dsantiago: that's called "destructive updates" and ghc doesn't do it. but clean certainly does, and i think mercury does too
14:35:31 <aristid> zrxy: sorry i mean i use melpa
14:35:36 <dsantiago> parcs`: Yeah, I didn't think it did. But I was reading about this conduits package, and I thought it might be implemented with some FFI stuff that uses memory not in GHC's heap. Things like that are possible in Java, for example.
14:36:20 <Ralith> dsantiago: ST, and foreign stuff handled carefully wrapped with unsafeIOToST, can enable that.
14:36:32 <dsantiago> What is ST?
14:36:43 <Ralith> in short, a state monad with destructive updates
14:36:46 <zrxy> aristid: I'm putting off having to revamp my whole emacs setup. I want to get real interaction, with the minibuffer showing my functions and arguments as I type them. Something must do that, just need to investigate.
14:36:53 <dsantiago> Ah, OK.
14:36:59 <Ralith> it is pure and safe to use
14:37:03 <Ralith> thanks to some clever use of the type system
14:37:52 <zrxy> I'll be a little depressed if I can get something resembling slime with regard to functions I define.
14:37:55 <applicative> dsantiago: if you want 'destructive updates' look into ST , STRef, STArray, Data.Vector.Unboxed.Mutable etc.
14:38:00 <Ralith> specifically, it's built such that you can do impure things inside it, but the actual execution of an action is guaranteed to be pure
14:38:23 <Ralith> very elegant
14:38:29 <Ralith> good for implementing things like A*
14:38:30 * applicative agrees
14:38:42 <carmin> hey guys, how can i call a recursive function after an if? Without the return of the function be a list?
14:38:55 <dsantiago> Hm, OK. Might be a bit out of my reach directly now, but I'll keep that in mind.
14:38:59 * Ralith made his team's ICFP entry an order of magnitude or two faster thanks to that
14:39:31 <applicative> carmin: maybe an example to paste would   make things clearer?
14:40:27 <Ralith> f :: Int -> Int; f n = if n > 0 then f (n - 1) else 42
14:41:21 <hpaste> carmin pasted “if” at http://hpaste.org/78181
14:42:07 <carmin> i mean
14:42:14 <carmin> wait let me redo it
14:43:09 <carmin> applicative http://hpaste.org/78182
14:44:47 <monochrom> "confereL b" has too few parameters
14:45:03 <carmin> yeah just an example
14:45:09 <monochrom> but it will be cf _ _ = confereL undefined b
14:45:43 * hackagebot dsmc 0.1.0.1 - DSMC library for rarefied gas dynamics  http://hackage.haskell.org/package/dsmc-0.1.0.1 (DmitryDzhus)
14:46:46 <Cale> carmin: First of all, b == True is often times the same thing as b
14:47:06 <Cale> ah you rewrote that already :)
14:48:34 <Eelis> is there an arithmetic mean function in the base libraries somewhere?
14:48:50 <monochrom> I don't see the rewrite
14:50:36 <koala_man> does the process of solving the satisfiability problem of an expression like x < y && y < z && z < x have a name I can google?
14:50:49 <hiptobecubic> Eelis, don't think so.
14:51:14 <hiptobecubic> Eelis, make sure you calculate length as part of the same fold
14:55:24 <pauser> how can i export any output of hugs to a file like java app > myoutput.txt
14:56:08 <geekosaur> does that not work?
14:56:52 <geekosaur> (well, some things might come out on standard error, but that's also true of java apps.  usually you want to append ' 2>&1' to capture that as well as standard output)
14:57:18 <parcs`> koala_man: *wild guess* smt solver?
15:01:43 <bitonic> SMT solver sounds right :)
15:02:12 <koala_man> parcs`: great, thanks!
15:02:15 <zrxy> Is this thing possible? http://hpaste.org/78184
15:02:58 <ion> zrxy: allElems :: (Enum a, Bounded a) => [a]; allElems = [minBound..]
15:03:27 <zrxy> ion: oh of course, thanks
15:04:14 <ion> Your code would probably have worked with ScopedTypeVariables, but it can be done without any extensions.
15:05:14 <zrxy> ion: yeah it compiles with ScopedTypeVariables
15:05:25 <monochrom> "minBound :: a" means the same thing as "minBound :: t". hope you accept this fact and see its implications to your plan
15:05:44 * hackagebot dsmc-tools 0.1.0.1 - DSMC toolkit for rarefied gas dynamics  http://hackage.haskell.org/package/dsmc-tools-0.1.0.1 (DmitryDzhus)
15:15:25 <burbul> This is not meant to be a complaint, but why are Haskell executables very large (compared to e.g. C++ executables)?
15:15:30 <burbul> Is it that there is a lot of stuff statically linked in?
15:16:13 <Cale> burbul: yes
15:17:49 <gienah> burbul: but maybe not for much longer, dynamic linking is enabled in ghc 7.7 and makes ghc 150MB smaller on gentoo
15:17:57 <Ralith> Cale: is it just that the linker is indiscriminate, or does ghc tend to perform inlining and instantiation to the extent that it creates very large binaries?
15:18:01 <burbul> ok -- thanks
15:19:38 <applicative> burbul: it used to make them smaller if you used a 'strip' utility, but I think that may be default now?
15:21:20 <burbul> ok -- thanks
15:22:04 <applicative> heres an out of date discussion that may nevertheless be of use http://stackoverflow.com/questions/699908/making-small-haskell-executables
15:24:25 <gienah> ghc dynlinking by default with ghc head is in the gentoo haskell overlay: gentoohaskell.wordpress.com/2012/11/24/eapi5-ghc-7-6-and-other-goodies/
15:24:28 <burbul> I'm just looking through the documentation to see that --strip-unneeded  flag is still current
15:24:30 <applicative> we are to take comfort from the fact that hello world take 25MB in SBCL
15:24:37 <burbul> SBCL?
15:24:53 <bgamari> What do people use to generate tags?
15:25:01 <applicative> common lisp, its discussed at the end of theold SO question
15:25:17 <bgamari> It seems hasktags has great difficulties bringing one to the right location
15:26:44 <burbul> strip definitely helps -- 9MB -> 5MB
15:28:45 <applicative> ah, cabal install has an    --enable-executable-stripping  which is the default
15:29:08 <Eelis> hiptobecubic: thanks
15:31:20 <Guest42886> haskell newbie here
15:31:38 <Guest42886> I am trying to serialize a binary instance and send it out a bytestring socket
15:32:23 <Guest42886> I am getting the error "Couldn't match expected type 'Data.ByteString.Char8.ByteString' with actual type 'Data.ByteString.Lazy.Internal.ByteString'
15:32:38 <Guest42886> can someone help me understand this type mismatch?
15:33:08 <luite> the second ByteString is lazy
15:33:28 <luite> i mean the actual one
15:33:47 <luite> a lazy ByteString is implemented as a list of strict ByteString
15:34:10 <luite> you can use toChunks to get the list
15:34:36 <zrxy> I wrote the tool I wanted: generate a Read instance for a Show Bounded Enum class. http://hpaste.org/78185 Is there a canonical way to do this? (Of course deriving(Read) works in the example, but assume that it doesn't.)
15:34:55 <Guest42886> hmm maybe there is a strict Data.Binary
15:35:09 <zrxy> Or any thoughts on how to make it prettier
15:35:24 <rwbarton> Guest42886: there is, Data.Serialize (package cereal)
15:35:46 <luite> Guest42886: the other way around is fromChunks
15:36:33 <applicative> Guest42886: if  you are using the new Bytestring, there is 'toStrict'/'fromStrict'
15:36:44 <applicative> or whatever theyre called
15:37:58 <Guest42886> thank you!
15:39:31 <applicative> Data.ByteString.Lazy.Char8.toStrict :: Data.ByteString.Lazy.Internal.ByteString -> Data.ByteString.Internal.ByteString
15:43:57 <zrxy> What did people do without ScopedTypeVariables? Was there a lot of cut & paste, or template haskell?
15:44:13 <`nand`> uh
15:44:18 <`nand`> you leave out the type signatures
15:44:27 <`nand`> I've never needed that extension, honestly
15:45:11 <rwbarton> you can use tricks like asTypeOf
15:45:31 <Guest42886> Couldn't match expected type `Data.ByteString.Lazy.Char8.ByteString' with actual type 'bytestring-0.9.2.1:Data.ByteString.Lazy.Internal.ByteString'
15:45:48 <zrxy> Can this be done without ScopedTypeVariables? http://hpaste.org/78185
15:45:54 <shachaf> Lazy ByteString /= strict ByteString
15:46:06 <shachaf> Oh, wait, those are both lazy.
15:46:14 <shachaf> Guest42886: Looks like you have two different versions of the package.
15:46:46 <parcs`> zrxy: yes, scopedtypevariables is never (?) necessary
15:46:55 <rwbarton> @src Reads
15:46:56 <lambdabot> Source not found. Take a stress pill and think things over.
15:46:59 <rwbarton> @src ReadS
15:46:59 <lambdabot> Source not found. Just what do you think you're doing Dave?
15:47:11 <`nand`> zrxy: yes, you uh.. leave out the type signature
15:47:22 <rwbarton> ([minBound..] `asTypeOf` [elem])
15:47:39 <rwbarton> though yes in this case don't you not need the signature?
15:47:41 <`nand`> [minBound..] suffices
15:47:51 <rwbarton> but if you did need it, that is how you could work around it
15:48:10 <`nand`> I can only see it needed where you would get an ambiguous type error otherwise
15:48:42 <Guest42886> shachaf: any idea how to find and remove the older pkg?
15:49:01 <shachaf> You might figure out why it's being used. I can't help you much without context.
15:49:10 <dsantiago> applicative, Ralith, just read Lazy Functional State Threads, think I have a better idea of how mutable state works in Haskell now, thanks.
15:49:11 <shachaf> ghc-pkg {list,hide,unregister} might be useful.
15:50:39 <Guest42886> ghc-pkg shows the mismatch between bytestring versions... how would I resolve this?
15:50:57 <shachaf> Figure out what you're doing and why it's using multiple versions of ByteString.
15:51:30 <Guest42886> one function is in the newer version of the pkg
15:51:48 <Guest42886> two imports... maybe they are pulling from different versions?
15:52:14 <shachaf> You could try hiding the old version and seeing what happens.
15:54:22 <Guest42886> ghc-pkg hide pkg doesn't do it.. yikes
15:56:38 <Peaker> Guest42886, what does: ghc-pkg list bytestring   say?
15:57:04 <Guest42886> /var/lib/ghc/package.conf.d
15:57:04 <Guest42886>    bytestring-0.9.2.1
15:57:04 <Guest42886> /home/brian/.ghc/x86_64-linux-7.4.1/package.conf.d
15:57:04 <Guest42886>    bytestring-0.10.0.1
15:57:17 <Guest42886> the 0.9.2.1 bytestring is hidden
15:57:32 <Guest42886> but still produces the error when compilling
15:57:34 <shachaf> Hmm, is bytestring one of the packages you're not supposed to upgrade?
15:57:48 <rwbarton> possibly you are importing some other package which is built against the old bytestring
15:57:56 <Guest42886> i did 'cabal install bytestring' to get the newer version
15:58:57 <neutrino_> hey guys, can a list (or set) have more elements than intmax?
15:59:00 <Guest42886> rwbarton: possibly the binary package... I am trying to convert a lazy bytestring from binary.encode to a strict bytestring to send out a socket
15:59:24 <geekosaur> :t length
15:59:26 <lambdabot> [a] -> Int
15:59:34 <geekosaur> I think that's your answer for lists
15:59:50 <neutrino_> no, it doesn't answer my question
16:00:10 <neutrino_> i don't know if you can not have longer lists or the length function will just break
16:00:16 <geekosaur> :t Data.Set.size
16:00:17 <neutrino_> both seem plausible
16:00:17 <lambdabot> S.Set a -> Int
16:00:22 <neutrino_> yeah
16:00:22 <neutrino_> still
16:00:35 <rwbarton> well you can have an infinite list
16:00:47 * hackagebot hatt 1.5.0.3 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.5.0.3 (BenedictEastaugh)
16:00:48 <neutrino_> i mean finite ones
16:00:52 <rwbarton> however you can't store more than intmax cells of it at once in memory
16:01:04 <neutrino_> oh
16:01:05 <rwbarton> you can have a really long finite list too: [1..10000000000000000000]
16:01:30 <neutrino_> mhm
16:01:32 <geekosaur> I suppose arguably list scould be of any length, as long as you don't try to traverse the whole thing.
16:01:49 <neutrino_> wait
16:01:55 <geekosaur> sets are more dependent on the implementation.
16:01:58 <neutrino_> when traversing i don't need all the sells to be in memory at once
16:02:03 <neutrino_> only a single
16:02:07 <neutrino_> *cells
16:02:22 <geekosaur> I would note that in practice, a machine word is going to be the unit of addressibility for any CPU that GHC runs on
16:02:36 <neutrino_> right
16:02:42 <geekosaur> so an address must fit in an Int... this limits the size of both of them
16:02:52 <neutrino_> good point
16:03:26 <neutrino_> :)
16:03:32 <shachaf> geekosaur: A list can be bigger than Int on a 32-bit machine pretty easily, I would assume.
16:04:44 <geekosaur> right, the flip side of that is that a perfectly fused list may be infinite size but take up only a single cons cell :)
16:05:10 <neutrino_> what does "perfectly fused" mean here?
16:05:15 <shachaf> I can give you an infinite set that takes constant space!
16:05:22 <neutrino_> does this have to do with type fusion?
16:05:49 <Maxdamantus> > let f 1 = [()]; f n = f (n - 1) ++ f (n - 1) in length $ f 32
16:05:53 <lambdabot>   mueval-core: Time limit exceeded
16:06:14 <geekosaur> no, it has to do with ghc realizing it doesn;t need to allocate space for any but the one list value it's working with at the moment:  prior ones are discarded and their memory reused immeditely, and later ones not generated yet and not taking up storage
16:06:40 <shachaf> Yep.
16:07:35 <parcs`> how much memory does 'take 1000 (repeat True)' occupy?
16:07:53 <geekosaur> that's the other complication
16:08:44 <geekosaur> it takes up the memory needed to "describe"/perform the computation, until something uses it... how much of the list that something needs to hold in memory can't be answered when you don't know what that something is
16:08:50 <Maxdamantus> > let v = take 1000 (repeat True) in length $ v
16:08:52 <lambdabot>   1000
16:08:54 <rwbarton> it depends on how you evaluate the list and how long you retain the list
16:09:01 <geekosaur> this gets complicated quick :)
16:10:57 <Peaker> Guest42886, it's better to hide/remove the newer bytestring -- don't "shadow" system-level packages (the ones in /var/lib/ghc) with ones in your home
16:11:58 <Guest42886> Peaker: the newer bytestring has toStrict/fromStrict that I need... I guess I will pull the source in
16:12:17 <shachaf> Guest42886: Just use fromChunks/toChunks and concat
16:12:33 <Peaker> Guest42886, or you could upgrade your ghc to have a newer bytestring built-in
16:12:36 <shachaf> Or upgrade GHC.
16:13:14 <Guest42886> oh... head $ toChunks $ encode MyData
16:13:24 <shachaf> Guest42886: Not head
16:13:42 <shachaf> Well, unless you just want some random chunk, or possibly failure.
16:13:53 <shachaf> @ty Data.ByteString.concat
16:13:55 <lambdabot> [BSC.ByteString] -> BSC.ByteString
16:15:44 <Guest42886> okay. wow. finally resolved
16:15:47 <Guest42886> thank you for the help
16:16:07 <Guest42886> sendAll sock $ BS.concat $ L.toChunks $ encode (Data 1, 2, 3)
16:17:10 <donri> silly question: does Dual do anything for commutative monoids?
16:18:05 <shachaf> Nope.
16:20:12 <Cale> You could pretty much take it as a definition of a commutative monoid that   getDual (Dual x `mappend` Dual y) = x `mappend` y
16:20:43 <donri> yea i was just pondering if that'd be a sensible way to say, quickcheck for commutativity
16:21:07 <Cale> Not particularly sensible...
16:21:25 <Cale> You could just write  \x y -> mappend x y == mappend y x
16:22:44 <donri> well, sure ;)
16:25:49 * hackagebot dawg 0.7.1 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.7.1 (JakubWaszczuk)
16:25:51 * hackagebot ConstraintKinds 0.0.1 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-0.0.1 (MikeIzbicki)
16:25:53 * hackagebot ConstraintKinds 0.0.1.1 - Repackages standard type classes with the ConstraintKinds extension  http://hackage.haskell.org/package/ConstraintKinds-0.0.1.1 (MikeIzbicki)
16:26:09 <hpaste> applicative pasted “pure inplace qsort” at http://hpaste.org/78186
16:26:22 <applicative> dsantiago: here, I just came across a simple STVector quicksort ^^^
16:28:44 <dsantiago> That still looks nicer than the C version.
16:30:01 <dsantiago> applicative: Isn't this one violating the typesafety of the ST mechanism with the unsafeFreeze, though?
16:30:14 <dsantiago> Something can still read this vector while it's being modified, no?
16:30:33 <donri> ST is pure?
16:30:41 <Peaker> what does unstablePartition do?
16:30:49 * hackagebot HLearn-algebra 0.0.1 - Algebraic foundation for the homomorphic learning  http://hackage.haskell.org/package/HLearn-algebra-0.0.1 (MikeIzbicki)
16:36:29 <applicative> oh, unstablePartition moves everytthing that fails the predicate to the end, or the other way around, if I remember
16:36:42 <applicative> Peaker: ^^^
16:40:31 <fliip> Can someone explain why I get "Equations give different arities" for the following please?
16:40:35 <fliip> > addPositionsFast :: Maze -> [(Place, Path)] -> Direction -> [Place] -> ([(Place, Path)], [Place])
16:40:35 <fliip> > addPositionsFast maze [] d visited = ([], visited)
16:40:37 <lambdabot>   <hint>:1:36: parse error on input `='
16:40:37 <lambdabot>   can't find file: L.hs
16:41:46 <fliip> Nevermind...
16:41:48 <fliip> Sorry.
16:45:30 <applicative> dsantiago: unsafeFreeze and unsafeThaw don't copy the vector so the commentary The mutable array should not be modified after unsafeFreeze, and the immutable array should not be used after unsafeThaw
16:45:47 <applicative> dsantiago: thus that commentary rather
16:46:27 <dsantiago> Right, it's leaving it up to the programmer to do that right.
16:50:50 <applicative> I see there is a copyArray function to make a mutable vector that has the same elements as a 'pure' one
16:50:50 * hackagebot HLearn-distributions 0.0.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.0.1 (MikeIzbicki)
16:52:07 <applicative> dsantiago: wait, of course there's plain freeze and thaw and copy already in Data.Vector.Unboxed
16:52:11 <dsantiago> In my mind, the programmer calling this quicksort would be the one to choose to use the unsafe variant or not depending on his needs. By having the function assume it, doesn't it force potentially risky or surprising behavior that can't be caught by the type-checker? But perhaps I am misunderstanding the mechanism.
16:55:25 <applicative> dsantiago, similarly there are safe read and write functions; in that case the difference is that they do bounds checking
16:56:20 <dsantiago> applicative: In my understanding, wouldn't the safe version of freezeArray make a copy before returning the value? So that this function could instead return the ST instance and let the caller call either freezeArray or unsafeFreezeArray to get what he wants?
16:57:45 <Taslem> Is there some way to generalize a list to be a list of values whose types are all part of some typeclass?
17:02:30 <geekosaur> Taslem, you can use a forall-ed type wrapper, but it erases the original type; the only thing you can ever do with the contents is use the typeclass's methods
17:02:50 <geekosaur> in general you want to find some other way to do it
17:03:31 <Taslem> Yeah, that's what I figured.
17:04:50 <zrxy> Can card be written without ScopedTypeVariables? And/or some nicer way?
17:07:55 <zrxy> oops! forgot the link. http://hpaste.org/78189 Can card be written without ScopedTypeVariables? And/or some nicer way?
17:09:17 <hpaste> geekosaur annotated “card” with “card (annotation)” at http://hpaste.org/78189#a78190
17:09:20 <Cale> zrxy: card x = (maxBound - minBound + 1) `asTypeOf` x
17:09:24 <Cale> errr
17:09:26 <geekosaur> or that
17:09:33 <Cale> not quite that :)
17:09:36 <geekosaur> yeh
17:10:04 <Cale> zrxy: card x = fromEnum (maxBound `asTypeOf` x) - fromEnum (minBound `asTypeOf` x) + 1
17:10:23 <Cale> But this is sort of a weird thing to do
17:10:37 <Cale> Enum doesn't really mean "an enumeration of all the values of this type"
17:10:51 * hackagebot HLearn-distributions 0.0.1.1 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.0.1.1 (MikeIzbicki)
17:11:01 <Cale> It's really more something along the lines of "a definition of how the [a,b..c] and related syntaxes work"
17:11:59 <Cale> I think fromEnum and toEnum are a bit weird, and probably shouldn't be there.
17:16:41 <zrxy> Will types ever be accepted as parameters? It would make it easy to attach properties like card to a type. Maybe passing type T could even be translated to passing undefined::T.
17:21:02 <mgsloan> zrxy: You could define a shorter version of undefined, maybe "__".  They'll never be used undecorated,  because there are different namespaces for types and values (constructors can be the same name as types).
17:25:40 <zrxy> mgsloan: yes I forgot about overlapping names. I guess "card T" where T is a type is too weird, though presumably one could invent some type signature for card.
17:25:57 <donri> @hackage tagged -- see this zrxy
17:26:12 <donri> O lambdabot where art thou
17:26:32 <monochrom> @botsnack
17:26:32 <lambdabot> :)
17:26:43 <monochrom> perhaps @hackage is removed
17:26:49 <donri> zrxy: http://hackage.haskell.org/packages/archive/tagged/0.4.4/doc/html/Data-Proxy.html
17:26:59 <donri> @hackage tagged
17:26:59 <lambdabot> http://hackage.haskell.org/package/tagged
17:27:05 <zrxy> donri: thanks. I was wondering about making dummy types to disambiguate.
17:27:08 <donri> did i screw that up somehow
17:27:23 <monochrom> @hackage tagged -- syntax error?
17:27:24 <lambdabot> http://hackage.haskell.org/package/tagged -- syntax error?
17:27:34 <monochrom> I don't know what's going on!
17:29:52 <donri> @hackage tagged -- maybe it was the space at the end
17:29:52 <lambdabot> http://hackage.haskell.org/package/tagged -- maybe it was the space at the end
17:29:59 <donri> nope
17:35:43 <Peaker> s/-O2/-O0 improves compile times by a factor of 2 with no noticeable effect on runtime performance
17:44:40 <donri> Peaker: surely there are cases where that's not true? i'm curious if libs that enforce -O2 in cabal really benefit from that, though
17:44:55 <donri> edwardk: e.g. why does lens use -O2?
17:45:20 <jerojasr1> I'm having a silly issue with this code: http://pastebin.com/iBVbCVq0
17:45:23 <mauke> The paste iBVbCVq0 has been copied to http://hpaste.org/78192
17:45:41 <jerojasr1> it yields the following error message: http://pastebin.com/0E7u0SWX
17:45:44 <mauke> The paste 0E7u0SWX has been copied to http://hpaste.org/78193
17:45:45 <jerojasr1> any ideas?
17:46:25 <edwardk> donri: because without -O2 you don't want to use lens ;)
17:46:51 <donri> edwardk: so -O isn't enough to get sufficient optimization?
17:46:56 <rwbarton>     where (rxs, g) = fisherYates g xs
17:47:05 <rwbarton> jerojasr1: ^ this is recursive and not what you meant
17:47:18 <rwbarton> fix it and your problem should disappear
17:48:02 <Peaker> accidental recursion is a problem in Haskell code, imo
17:48:11 <Peaker> (it's nice to have to use "let rec" or such)
17:48:28 <rwbarton> with -Wall you would have had a shadowing warning--unless that can't happen when there is a type error too
17:48:33 <donri> Peaker: oh i misread your -O0 as -O aka -O1
17:48:37 <Peaker> yeah, that's a big annoyance too
17:48:50 <rwbarton> I imagine it can still generate that warning
17:49:24 <jerojasr1> rwbarton: oh, stupid me, that g!
17:49:26 <jerojasr1> rwbarton: thanks
17:51:04 <donri> ghc manual says "At the moment, -O2 is unlikely to produce better code than -O.", but I keep seeing people using -O2 and many of those people are smart people :)
17:51:29 <Peaker> donri, it's a reasonable assumption to make that -O2 will be faster :)
17:51:36 <rwbarton> just in case, you know!
17:51:59 <carmin> lets say i have this function http://hpaste.org/78194 can anyone point me how can i get the list that is being created to compare with the current point and see if it exists?
17:52:18 <donri> Peaker: well it seems the choice of where an optimization goes is about how long it takes to compile, not how effective it is.
17:53:08 <edwardk> donri: no, i really need constructor specialization, etc.
17:54:36 <donri> but presumably, e.g. snap adding -O2 to their app template (IIRC) is a bit wantonly?
17:57:46 <sohum> :t flip id
17:57:47 <lambdabot> b -> (b -> c) -> c
17:57:51 <sohum> oh
17:58:18 <sohum> :t ($)
17:58:19 <lambdabot> (a -> b) -> a -> b
17:58:31 <donri> :t (&)
17:58:32 <lambdabot> t1 -> (t1 -> t) -> t
17:58:49 <sohum> cute!
17:59:05 <bgamari> Is it possible that wrapping a bunch of objects in newtype causes GHC to emit code with higher memory churn?
18:00:00 <bgamari> I would have thought that a newtype would have been entirely erased during compilation
18:00:16 <bgamari> but somehow the space performance of my code is now far worse
18:00:31 <donri> bgamari: there are obscure edge cases at least, e.g. not triggering rewrite rules for the wrapped type
18:00:46 <bgamari> donri, hmm, uh oh
18:00:52 <shachaf> bgamari: newtype constructor and accessor turn into id, but lots of other things could happen
18:01:01 <shachaf> For example, map id /= id
18:01:06 <shachaf> (id . f) /= f
18:01:11 <shachaf> Etc.
18:01:17 <bgamari> There were a fair number of mechanical changes down during the transition to the newtype
18:01:19 <donri> for example, newtype Name = Name Text deriving IsString -- the IsString instance will not trigger the straight-to-Text rewrite rule
18:01:39 <bgamari> it's possible although not likely that I screwed up something minor
18:02:09 <bgamari> but the semantics of the code are unchanged
18:02:18 <bgamari> and it compiles
18:02:23 <bgamari> so chances are it's correct
18:02:39 <bgamari> the profile turns up lots of increased heap usage everywhere
18:02:42 <zrxy> I still need to pass the Tagged constructor a value, e.g. Tagged (undefined :: Foo). I thought the purpose of Tagged would be to hide the undefined hack.
18:02:52 <donri> zrxy: use Proxy, not Tagged
18:03:05 <donri> same package, different module
18:03:38 <zrxy> ok thanks
18:04:44 <rwbarton> which package?
18:05:58 <donri> rwbarton: tagged
18:06:08 <shachaf> Cale: The new version of lens is out and now edwardk aims to keep the API pretty stable.
18:06:11 <shachaf> So you should upgrade.
18:06:31 <rwbarton> I don't understand "Tagged (undefined :: Foo)" then
18:06:33 <donri> next day: lens 4.0
18:06:47 <rwbarton> shouldn't it be Tagged whatever :: Tagged Foo whatever'
18:06:48 <edwardk> donri: =)
18:07:09 <edwardk> i plan to refuse any api breaking changes until at least december ;)
18:07:51 <donri> i'm not entirely against that seeing as half the patches for my toy project are "new lens version"
18:08:01 <edwardk> donri: hahahaha
18:08:12 <donri> (using lens since 0.1)
18:08:20 <shachaf> donri: You think that's bad? Look at edwardk's toy project!
18:08:25 <zrxy> donri: you're saying Proxy can remove the "undefined" appearing in my code?
18:08:28 <shachaf> donri: Every single patch there has to do with a new version of lens.
18:08:33 <applicative> donri:  everyone says that remark in the ghc manual should be scrapped
18:08:38 <donri> zrxy: i don't know your code :)
18:08:44 <edwardk> the 3.4 -> 3.5.1 -> 3.6 changes were because of security/safety guarantees and a much cleaner implementation. 3.6 made a lot of breaking API changes to get them out of the way
18:08:55 <rwbarton> Tagged is to remove undefined too
18:09:26 <carmin> can i nest where's ?
18:09:36 <shachaf> Yep.
18:09:38 <edwardk> zrxyl yes, pass Proxy :: Proxy Foo   rather than an undefined :: Foo
18:09:38 <donri> zrxy: basically a proxy lets you talk about a type at the value level, with (Proxy :: Proxy TheType)
18:09:54 <edwardk> zrxy: then you don't have to worry about accidentally using it
18:10:01 <applicative> donri: the manual remark is from 10 years ago
18:10:07 <donri> applicative: ok :)
18:10:39 <applicative> oh here is dons on 02 http://stackoverflow.com/questions/11108746/difference-between-ghcs-o-and-o2
18:10:45 <donri> thanks
18:11:35 <applicative> oh and Daniel Fischer siding with him
18:11:58 <donri> would it be a good idea to compile the core libraries / the platform with -O2, say for a linux distro?
18:11:59 <xunatai> @src $
18:11:59 <lambdabot> f $ x = f x
18:14:14 <zrxy> horray I figured it out http://hpaste.org/78195
18:15:01 <zrxy> It would have been so much easier if Proxy had just one example, imo
18:16:13 <donri> tagged is from edwardk's pre-documentation era
18:16:17 <zrxy> I'm not sure this is an improvement, because 'asTypeOf' still compiles and gives the wrong answer.
18:16:21 <edwardk> i take patches
18:16:22 <hpaste> Nereid annotated “card proxy” with “card proxy (annotation)” at http://hpaste.org/78195#a78196
18:16:25 <donri> :)
18:16:48 <zrxy> I was getting the number 1 instead of 3 -- I had 'asTypeOf' instead of 'asTaggedTypeOf'.
18:17:02 <zrxy> ... for cardD
18:17:20 <Nereid> oops I can't type.
18:17:22 <zrxy> Couldn't that be made to not compile?
18:17:24 <Nereid> ScoedTypeVariables
18:18:53 <zrxy> why is Proxy Bounded?
18:18:58 <edwardk> the main reason i use proxy over tagged is that proxy is easier to plumb the types around, you can often avoid ScopedTypeVariables
18:19:00 <edwardk> because it can be
18:19:29 <xunatai> is there an infixl version of ($)?
18:19:33 <Nereid> if only!
18:19:37 <edwardk> xunatai: no
18:20:28 <xunatai> so, i always have to do something like: "mod 10 (6 + 2)" instead of something like "mod 10 $$ 6 + 2"?
18:20:40 <edwardk> mod 10 $ 6 + 2 works
18:20:44 <xunatai> er
18:21:02 <c_wraith> > mod 10 $ 6 + 2
18:21:03 <xunatai> herp
18:21:03 <lambdabot>   2
18:21:18 <Nereid> but
18:21:24 <Nereid> mod $ 2 + 8 $ 6 + 2 does not.
18:21:26 <edwardk> the benefit to an infixl $ would be you could do   callfoo $ withArg1 … $ withArg2 … $ ...
18:21:36 <zrxy> edwardk: could Proxy be rigged to refuse to work with asTypeOf? That was the source of my run-time, no-warning bug.
18:21:48 <edwardk> zrxy no, it can't
18:21:55 <edwardk> asTypeOf is fully polymorphic
18:22:20 <c_wraith> well.  It's fully rank-1 polymorphic.
18:22:28 <edwardk> it is very rare that you find yourself in the situation you did. the cures you suggest are all worse than the disease =P
18:22:57 <c_wraith> the type variable in asTypeOf can't be instantiated with a polymorphic type! :)
18:23:14 <edwardk> fromEnum (maxBound …. )  is a pretty awkward situation fraught with peril
18:23:21 <c_wraith> yikes.
18:23:33 <binroot> hey, in haskell what does the <|> and <$> syntax mean?
18:23:44 <c_wraith> binroot: they're just functions
18:23:53 <edwardk> <$> is an infix version of fmap.   <|> is the 'alternative choise' combinator in Alternative.
18:23:53 <Nereid> binroot: <|> comes from Alternative, and (<$>) = fmap
18:23:55 <c_wraith> binroot: both are from Control.Applicative
18:24:00 <edwardk> er choice
18:24:04 <binroot> thanks edwardk!
18:24:15 <binroot> thanks c_wraith, i'll look that up
18:24:16 <zrxy> Well I'd be using the Finite class if it existed!
18:24:26 <zrxy> enum is a hack to count the elements
18:24:33 <Nereid> Enum is a hack
18:24:46 <c_wraith> (actually, <$> got moved to Data.Functor, but it's still re-exported by Control.Applicative)
18:25:01 <edwardk> Data.Functor is quite happy-making
18:25:13 <edwardk> <$ being in Functor tempts me to all sorts of evilness though
18:25:22 <c_wraith> :t fmap . const
18:25:24 <lambdabot> Functor f => b -> f a -> f b
18:25:30 <Nereid> whoa
18:25:36 <Nereid> I didn't know <$ was a Functor method.
18:25:42 <c_wraith> why wouldn't that be in Functor?
18:25:44 <edwardk> i often have optimizations i can provide for <$ that require more constraints on the type than the <$> would
18:25:55 <c_wraith> Oh, it was moved to the class?
18:25:56 <c_wraith> That's nice
18:26:01 <edwardk> c_wraith: yeah it is
18:26:41 <edwardk> for representable functors i can abuse 'pure' which often gives me better sharing, hence the temptation and evil
18:26:47 <c_wraith> I mean, uu-parsinglib had its own implementation of most of Control.Applicative just because it could make things more efficient by adding extra class methods
18:26:51 <zrxy> My wish is: data D = D1 | D2 | D3 deriving(Finite), and then card :: D gives me 3.
18:27:05 <edwardk> c_wraith: thats how we got *> and <*, etc.
18:27:26 <edwardk> i too needed them =)
18:27:38 <zrxy> Surely I am not the only one that wants to count elements in types?
18:27:59 <edwardk> zrxy: you're not, but its pretty easy to do with scopedtypevariables
18:28:15 <c_wraith> isn't uu-parsinglib more or less the library (well, a successor to the library) that was responsible for the creation of Applicative anyway?
18:28:42 <edwardk> i don't know that i would credit it for that
18:29:44 <zrxy> edwardk: yes my first version used STV. But I still need Enum, right?
18:29:52 <c_wraith> I seem to recall Doaitse Swierstra being responsible for people using Applicative.  But maybe I crossed a wire somewhere in my memory.
18:30:12 <edwardk> yes, Enum, Bounded, scoped type variables, 2 lines of code, done ;)
18:30:42 <donri> easy!
18:31:01 <edwardk> > fromEnum (maxBound :: Ordering) - fromEnum (minBound :: Ordering) + 1
18:31:02 <lambdabot>   3
18:31:35 <shachaf> fromEnum (maxBound :: Double) - fromEnum (minBound :: Double) + 1
18:31:42 <edwardk> > card (Proxy :: Proxy a) = fromEnum (maxBound :: a) - fromEnum (minBound :: a) + 1
18:31:42 <shachaf> > fromEnum (maxBound :: Double) - fromEnum (minBound :: Double) + 1
18:31:43 <lambdabot>   <hint>:1:25: parse error on input `='
18:31:45 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
18:31:45 <lambdabot>    arising from a use o...
18:31:49 <shachaf> Oh, yes.
18:32:02 <shachaf> > fromEnum ((1/0) :: Double) - fromEnum ((-1/0) :: Double) + 1
18:32:04 <lambdabot>   1
18:32:07 <edwardk> now, the issue is when you fill Int ;)
18:32:11 <edwardk> like shachaf showed
18:32:29 <edwardk> card (Proxy :: Proxy a) = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a) + 1)
18:32:38 <edwardk> card (Proxy :: Proxy a) = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1
18:32:55 <edwardk> then you can    card (Proxy :: Proxy D)
18:33:21 <edwardk> you can go one step farther and follow the proxy-less version i tend to use
18:33:33 <donri> zrxy: is there any particular reason you're trying to make 'card' polymorphic, though?
18:33:36 <edwardk> :t let card (_ :: p a) = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card
18:33:38 <lambdabot>     Expecting an ordinary type, but found a type of kind k_a5W0
18:33:38 <lambdabot>     In an expression type signature: a
18:33:38 <lambdabot>     In the first argument of `fromEnum', namely `(maxBound :: a)'
18:34:02 <edwardk> :t let card :: (Enum a, Bounded a) => p a -> Int; card (_ :: p a) = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card
18:34:03 <lambdabot>     Couldn't match expected type `Int' with actual type `Integer'
18:34:03 <lambdabot>     In the return type of a call of `toInteger'
18:34:03 <lambdabot>     In the first argument of `(-)', namely
18:34:18 <edwardk> :t let card :: (Enum a, Bounded a) => p a -> Integer; card (_ :: p a) = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card
18:34:20 <lambdabot>     Expecting an ordinary type, but found a type of kind k_a5YQ
18:34:20 <lambdabot>     In an expression type signature: a
18:34:21 <lambdabot>     In the first argument of `fromEnum', namely `(maxBound :: a)'
18:34:40 <edwardk> :t let card :: forall a. (Enum a, Bounded a) => p a -> Integer; card _ = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card
18:34:41 <lambdabot> Not in scope: type variable `p'
18:34:46 <edwardk> :t let card :: forall p a. (Enum a, Bounded a) => p a -> Integer; card _ = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card
18:34:47 <lambdabot> (Bounded a, Enum a) => p a -> Integer
18:34:53 <edwardk> ok, that was spammy. sorry
18:35:08 <edwardk> > let card :: forall p a. (Enum a, Bounded a) => p a -> Integer; card _ = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card (undefined :: Maybe Ordering)
18:35:10 <lambdabot>   3
18:35:16 <edwardk> > let card :: forall p a. (Enum a, Bounded a) => p a -> Integer; card _ = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card (undefined :: Maybe Double)
18:35:18 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Types.Double)
18:35:18 <lambdabot>    arising from a use o...
18:35:19 <edwardk> > let card :: forall p a. (Enum a, Bounded a) => p a -> Integer; card _ = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card (undefined :: Maybe Int)
18:35:22 <lambdabot>   18446744073709551616
18:35:24 <zrxy> donri: not particularly, just cleanliness. Instead of cardFoo, cardBar.
18:35:32 <xunatai> just private message lambdabot
18:35:49 <edwardk> i'm using Maybe instead of Proxy there because lambdabot doesn't load Data.Proxy
18:36:05 <edwardk> xunatai: i kept expecting to be done with the next use ;)
18:36:10 <donri> zrxy: but will you have multiple card types?
18:36:27 <xunatai> edwardk: that's how spam happens
18:36:33 <edwardk> zrxy: anyways that code will do exactly what you want
18:39:05 <lispy> Welcome to #lambdabot-responses, please stay on topic.
18:39:32 <lispy> ?faq Can Haskell spam the channel?
18:39:33 <lambdabot> The answer is: Yes! Haskell can do that.
18:40:31 <zrxy> donri: I'll be passing different Proxy types to card -- does that answer your question?
18:40:53 <donri> yep
18:41:00 <zrxy> instead of cardFoo, cardBar, it looks like card (Proxy :: Proxy Foo)
18:41:40 <donri> not just that, it's reusable
18:46:11 <zrxy> edwardk: what is point of Proxy or Maybe when ScopedTypedVariables is enabled? My first run (given above) looked like http://hpaste.org/78189 which is the same but simpler
18:46:37 <edwardk> zrxy: because here you aren't passing an undefined variable around that you might accidentally apply to a function.
18:46:54 <edwardk> but i wouldn't object to your aTypeOf version
18:47:14 <zrxy> edwardk: ok right
18:47:31 <edwardk> its pretty simple and gets the point across
18:47:31 <edwardk> and you can easily pass an examplar to your version. card D1
18:47:55 <edwardk> the usecases for Proxy are when it gets a lot more abstract and there is greater risk of using the type
18:48:03 <zrxy> edwardk: but the peril with Proxy being everything seems just as bad, giving me wrong answers for a misplaced asTypeOf
18:48:17 <edwardk> honestly it gave you exactly what you asked for =P
18:48:43 <zrxy> as long as Proxy is never mixed with asTypeOf -- which is not necessary with STV -- then it makes sense
18:50:52 <edwardk> the major advantage of Proxy as a discipline is you never lie to GHC and tell it you have a Foo, when all you have is the type.
18:51:02 <edwardk> you merely tell it you have that type.
18:51:08 <zrxy> edwardk: I understand, thanks. I was just kind of shocked to see the wrong answer being given for card. But asTypeOf is not needed there, so there is no necessary danger.
18:51:12 <edwardk> now, you pay for it a bit in complexity
18:51:39 <edwardk> but you get, usually, safety. here you happened to be using a combination of things that happened to type check ;)
18:53:05 <edwardk> my usual approach is to write functions that consume a proxy using scoped type variables, in the fashion i described above, taking 'p a' instead of 'a'. then i know nothing about 'p' so i can't use it.
18:53:19 <edwardk> > let card :: forall p a. (Enum a, Bounded a) => p a -> Integer; card _ = toInteger (fromEnum (maxBound :: a)) - toInteger(fromEnum (minBound :: a)) + 1 in card (undefined :: Maybe Int)
18:53:21 <lambdabot>   18446744073709551616
18:53:48 <edwardk> in the real world i'd call that with card (Proxy :: Proxy Int)
18:54:13 <edwardk> but the type of card now protects me from both classes of errors.
18:54:14 <Nereid> how come you don't just write that with p = Proxy?
18:54:49 <edwardk> Nereid; because now i can pass it other things. all i want is the last type. so if I _have_ a Maybe Int, i don't have to concoct a way to turn it into a Proxy first.
18:55:05 <Nereid> hm
18:55:06 <edwardk> and i don't have to worry about the 'oops i called asTypeOf' issue zrxy had
18:55:12 <Nereid> heh
18:55:14 <edwardk> let me give you a worked example
18:55:20 <zrxy> edwardk: It would really be nice if somehow a Proxy could be built on the fly with so-and-so classes, so that Proxy doesn't have to be Bounded and everything else. It would take on the properties of the type it wraps.
18:55:34 <edwardk> Nereid: https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
18:55:51 <edwardk> reflect :: Reifies s a => p s -> a -- fits this pattern
18:56:13 <edwardk> see how i'm able to use the values of type M a s   as the values of type 'p s' for reflect
18:56:23 <edwardk> all i want is its type argument.
18:56:42 <edwardk> the proxy absolutely shouldn't have the properties of what it wraps
18:56:48 <Nereid> neat
18:57:07 <edwardk> it is just a single constructor data type with a phantom argument, that carries with it a lot of power.
18:57:12 <edwardk> pure :: a -> Proxy a
18:57:16 <edwardk> lets you make one out of a value
18:57:31 <edwardk> you can combine them like any other applicative. fmap to change their contents, etc.
18:57:46 <edwardk> that is a lot of power and its often very very useful
18:58:55 <edwardk> zrxy: consider your original card :: forall a. (Bounded a, Enum a) => a -> Int  just rejiggered to take the p. card :: forall p a. (Bounded a, Enum a) => p a -> Int -- you can't screw up and try to 'succ' the argument now.
18:59:01 <edwardk> its not a legal candidate for use as anything
18:59:12 <akahn> Does Network.HTTP support HTTPS?
19:00:15 <edwardk> then you can card [D1]  or card (Proxy :: Proxy D) at the use site without making up undefined values, and you aren't concerned with proxy's instances at all.
19:00:57 * donri just refactored some code to use proxies as this all reminded him
19:01:00 <edwardk> most of my code that expects a Data.Proxy doesn't actually depend on the tagged package at all, just the lower case 'p' with no properties
19:01:00 <edwardk> its only when i go to return a value that is just a placeholder for a type that i give you a Proxy.
19:01:54 <donri> akahn: IIRC not, but also IIRC http-conduit does
19:02:08 <binroot> question: what's a good haskell web-framework?
19:02:11 <hpaste> applicative annotated “pure inplace qsort” with “pure inplace qsort test ” at http://hpaste.org/78197#a78199
19:02:18 <applicative> dsantiago: it seems in simple cases at least the 'unsafeRead' stuff doesn't matter ^^^
19:02:19 <zrxy> edwardk: OK, but you don't believe me that I get it?
19:02:20 <donri> @where web
19:02:20 <lambdabot> #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
19:02:24 <edwardk> binroot: i'm partial to snap. but there are also yesod and happstack
19:03:10 <akahn> thanks donri
19:03:12 <binroot> i'll take a look
19:03:16 <Nereid> I should try out snap because edwardk likes it.
19:03:16 <edwardk> snap feels the most 'haskelly' to me in the overall shape of the API. yesod has some pretty powerful templating tools, happstack lets you pretty much do anything but has a steep learning curve.
19:03:18 <shapr> binroot: scotty is also awesome
19:03:24 <shapr> edwardk: You gotta try scotty if you haven't already
19:03:26 <edwardk> you kinda have to pick your poison
19:03:37 <stepkut> edwardk: what do you think makes happstack steep?
19:03:49 <donri> Nereid: but he only likes it because he knows the author and they use some of his code for snaplets!
19:03:54 <Nereid> heh
19:03:57 <binroot> Will snap be sufficient for creating a blog? How do I interact wit ha db?
19:04:02 <dsantiago> applicative: I'm not sure what I should be seeing in this...
19:04:11 <shachaf> @where+ web #haskell-web | #happs - http://happstack.com/ | #snapframework - http://snapframework.com/ | #yesod - http://yesodweb.com/
19:04:12 <lambdabot> Okay.
19:04:19 <edwardk> stepkut: my experience with happstack was you could grab anything from anywhere. which was awesome, but thats a lot of territory to cover =)
19:04:30 <stepkut> binroot: for a blog, you might consider clckwrks, though you would want to wait a few days for the new release which is way easier to get started with
19:04:32 <zrxy> edwardk: I was just wondering if there was a way that Proxy didn't have to have so many instances. I know you can use "p" variable instead, but that doesn't address when Proxy is actually used.
19:04:39 <edwardk> stepkut: but i'm no happstack expert =P
19:04:40 <stepkut> edwardk: yeah.. that is why we created happstack-lite :)
19:04:47 <applicative> dsantiago: sorry, I wandered of, but we were wondering about all the unsafeEverything the original ST quicksort I put up was using
19:04:56 <applicative> wandered *off*
19:05:06 <edwardk> zrxy: when Proxy is actually used in non-trivial code, i want and use those instances
19:05:21 <stepkut> edwardk: what did you find more haskelly about snap that happstack? (just curious)
19:05:27 <dsantiago> applicative: Right. And you've compared the two versions using safe and unsafe version… but I'm not sure what the conclusion is here.
19:05:29 <edwardk> stepkut: did you ever get around to making a websocket api?
19:05:39 <applicative> dsantiago: in any case, the two modules differ by one using all unsafeX,  the other using the 'safe' equivs. The times are the same
19:05:56 <donri> edwardk: hm, it's a loaded topic of course but quite honestly i find happstack the most "haskelly". to and through lots of haskell idioms, where snap just interfaces with something external (xml templates, text configs, sql databases etc)
19:05:59 <stepkut> edwardk: it will be in the next release, but not yet.
19:06:03 <zrxy> edwardk: I'm not saying it's feasible, it was just a wish-list thing. Whenever you actually use Proxy, you don't want it to have the instances you don't need.
19:06:04 <dsantiago> applicative: Where are times?
19:07:16 <edwardk> hrmm, the main thing i liked about snap that i could use it for my stated purpose, because i needed websockets. =P … actually thats somewhat tongue in cheek. the other parts were that it was already using lenses to manage its state, that i could grab things like the postgresql snaplet and plug it in, etc. the state felt pretty good to work with with the lensed monad. it felt coherently thought out in that regard.
19:07:26 <shachaf> applicative: What's pure about that function?
19:07:31 <donri> edwardk: happstack is certainly much more type safe than a typical snap app, anyway
19:07:34 <edwardk> now ill be honest. i don't really like heist, etc.
19:07:35 <applicative> dsantiago: i didn't bother putting them up, it was sorting a 39K file, it took . 0.24 real secs
19:07:43 <edwardk> so its a mixed bag for me
19:07:43 <donri> edwardk: without all the TH/QQ of yesod
19:07:46 <dsantiago> applicative: In any case, my issue wasn't with the runtimes, it was with the original version taking your "immutable array", modifying it in place, and then telling you it was a pure function by its type signature…
19:07:50 <applicative> shachaf: the type signature of course
19:07:56 <applicative> dsantiago: I know
19:07:58 <stepkut> edwardk: neat, thanks!
19:08:11 <edwardk> but the avoidance of all the crazy yesod TH, etc. is why i like it. which is more of a factor against 'the other guys' than you. =)
19:08:22 <stepkut> edwardk: do you find that things like the postgresql snaplet actually save you much code?
19:08:23 <shachaf> applicative: OK, sounds like it's not worth arguing about, then. :-)
19:08:24 <applicative> dsantiago: it was just that made a distracting use of the 'unsafe' operations.
19:08:32 <edwardk> my experience working with yesod was waiting 10 minutes to compile anything
19:08:39 <stepkut> edwardk:  :)
19:08:59 <edwardk> stepkut: not sure. in my case the snaplet abstraction perfectly fit what i was writing
19:09:07 <stepkut> edwardk: cool
19:09:16 <edwardk> for other people? the case could be made for a more happstacky approach
19:09:24 <applicative> dsantiago: so I rewrote it to avoid them. The only reason to use them was speed, but in this case it didn't matter.
19:09:49 <edwardk> but what i was working on was more of a framework for building up servers of a particular type, than an actual server.
19:09:50 <applicative> dsantiago: the inline pragma on the other hand made for a 10x speedup
19:09:51 <dsantiago> applicative: I was just wondering if there was a way to write the function so it could do in-place modification, but the caller of the function could make use  of it whether they wanted a given array they had to mutate or not, and change what they pass in.
19:09:54 <dsantiago> Is taht possible?
19:10:15 <edwardk> had you had websocket support, i could have considered happstack more deeply but i got cut off by that =P
19:10:16 <dsantiago> I mean, the caller can choose to send a copy in for mutation, or the original.
19:10:28 <stepkut> edwardk: I'm working a plugin architecture for at the moment, so it's useful to hear what people like and don't like about the other solutions
19:10:31 <shachaf> dsantiago: Just write an ST in-place function.
19:10:38 <zrxy> The impression I get is that Yesod is filled with little DSLs, while the happstack is more Haskell-like but more boilerplate. True/False/Maybe?
19:10:54 <aristid> @pl \x -> fmap p (f x)
19:10:54 <lambdabot> fmap p . f
19:10:55 <edwardk> find me a way to get the resource safety of yesod without the build time =P
19:10:57 * lispy tries to read article about arrows, gets annoyed at conveyor belt metaphor
19:11:06 <stepkut> edwardk: right. Been waiting for pipes to mature to decide if we want to go the pipes route, or stick with something like the streams IO in the upcoming snap
19:11:08 <donri> zrxy: not as much boilerplate as you might think, but probably still more than yesod for simple things.
19:11:18 <shachaf> dsantiago: Then you can either use it directly from ST, or use thaw + runST to copy.
19:11:45 <edwardk> *nods* i need to give my machines api some love in the haskell space. its been getting all of its use in scala
19:11:54 <zrxy> Is there some general consensus about "default Haskell user" should use yesod or happstack or something else?
19:11:56 <donri> zrxy: actually there are cases where yesod has more boilerplate, e.g. web-routes-th or the builtin generics
19:11:56 <stepkut> zrxy: yesod is filled with QQ based syntaxs, whereas happstack tends to use normal haskell combinators to creates DSLs
19:11:57 <dsantiago> shachaf: OK, that's what I thought. I only just learned about ST a few hours ago, so when I saw the code, it made me wonder if that was possible, or if it was only really useful in a "lying" type signature.
19:12:05 <aristid> ah, the dilemma: use Maybe, or a more meaningful type but lose all the Maybe helper functions (or direct access to them)
19:12:08 <shachaf> dsantiago: If what was possible?
19:12:33 <shachaf> dsantiago: A signature like ImmutableArray -> ImmutableArray isn't going to let you do in-place mutation honestly.
19:12:49 <shachaf> aristid: Use lenses!
19:12:53 <edwardk> zrxy: yesod feels like home if you come from ruby. this may or may not be something you consider a good thing if your goal is to learn haskell and not a pile of EDSLs for site generation.
19:12:58 <aristid> stepkut: i think michael has a fairly convincing argument that for some thing, his QQ syntax provides more type safety than a non-QQ/TH DSL can _possibly_ provide
19:13:02 <shachaf> Then you can use an isomorphism to Maybe for all your code.
19:13:03 <stepkut> edwardk: what resource safety do you think yesod has that happstack doesn't?
19:13:16 <aristid> shachaf: you mean i might actually have a use for lens?!
19:13:20 <dsantiago> shachaf: Write a function that uses mutation through ST, but can work by modifying an array it is given in place, or making a safe copy, depending on how the caller calls it.
19:13:21 <aristid> shachaf: glorious days!
19:13:31 <stepkut> aristid: which thing would that be?
19:13:36 <dsantiago> (In other words, let the caller do the lying)
19:13:38 <aristid> stepkut: routing, mostly
19:13:44 <shachaf> dsantiago: There's no lying involved here.
19:13:45 <stepkut> aristid: what specifically?
19:13:48 <shachaf> Just functions over mutable arrays.
19:13:55 <edwardk> stepkut: does snap have the static file TH craziness that yesod does?
19:14:01 <shachaf> If you want to copy it, just copy it first.
19:14:09 <aristid> stepkut: well, type-safe URLs and verifying that there are no broken links
19:14:15 <stepkut> aristid: in many ways, it provides less safety, because if you want to go beyond the basics of what the routing QQ does, you have to write class instances by hand with very little assistance
19:14:23 <dsantiago> shachaf: I thought the safety of the ST thing was that the type system guaranteed you had a unique pointer to what you are modifying…
19:14:31 <edwardk> stepkut: that was actually rather nice when working with ghclive
19:14:45 <shachaf> dsantiago: Sort of.
19:14:52 <stepkut> aristid: in what way is the yesod routing more type-safe than web-routes?
19:15:03 <stepkut> (which existed before yesod, btw)
19:15:05 <applicative> shachaf: the 'safe' version of the ST quicksort does copy the immutable vector
19:15:40 <shachaf> I never said otherwise.
19:15:55 <stepkut> edwardk: static file TH craziness?
19:16:08 <akahn> is there a way to require packages on the command line with ghci?
19:16:08 <donri> edwardk: are you talking about file-embed or... what?
19:16:21 * applicative was thinking of the impression he might make
19:16:22 <edwardk> stepkut: let me go look. its been a couple months.
19:16:27 <aristid> stepkut: in yesod, it's impossible to create links that are not routed anywhere as long as you use the algebraic datatypes it creates for you
19:16:32 <donri> akahn: ghci -package foo
19:16:38 <aristid> stepkut: does web-routes support that?
19:16:44 <shachaf> dsantiago: ST is like a localized IO with restricted operations. You can create one "ST universe" in which you can allocate new arrays, mutate them, whatever.
19:17:03 <shachaf> dsantiago: But none of those arrays can be used in any other "ST universe", without using unsafe functions.
19:17:23 <donri> aristid: web-routes invented that
19:17:30 <stepkut> aristid: yes.
19:17:32 <aristid> donri: without TH?
19:17:36 <donri> aristid: yep
19:17:44 <akahn> donri: I get "<command line>: cannot satisfy -package Network.HTTP.Conduit"
19:17:55 <donri> akahn: the package is http-conduit
19:17:56 <dsantiago> shachaf: Right. I understood that you create one of those "universes," and send data in, and then you can pipeline those universes together to do a series of mutations on the same data, and then get a result out at the end via copying. With optionally, "unsafe" versions giving you the mutated value.
19:18:02 <stepkut> aristid: provided you don't ignore the 'unmatched patterns' compile warnings
19:18:04 <akahn> ah, right. thanks donri
19:18:07 <aristid> donri, stepkut: i believe i may not be expressing correctly what i mean. but let me read up on web-routes.
19:18:08 <carmin> can i put an if inside a where?
19:18:19 <shachaf> dsantiago: It's not really "pipelining universes together".
19:18:19 <edwardk> Data.FileEmbed and the Yesod staticFiles TH splice
19:18:29 <applicative> carmin on the right hand side
19:18:37 <aristid> stepkut: the discussion which i read was between snoyberg and kamatsu
19:18:43 <dsantiago> shachaf: Well, I meant the functions.
19:18:47 <applicative> carmin: where a = if even  x then ...
19:18:50 <aristid> stepkut: if you want i could try to dig it up from the google plusses
19:18:53 <dsantiago> Surely you can do some sort of composition within ST.
19:18:54 <shachaf> It's more like composing universe-polymorphic functions. :-)
19:19:00 <edwardk> where you can embed the file directly in the executable and you can also create haskell identifiers for all the files in a static file directory so you can't screw up references to them
19:19:13 <shachaf> But it's much less complicated than this is making it sound.
19:19:18 <stepkut> aristid: michael is often suprised by what is possible with happstack+web-routes+hsp
19:19:43 <edwardk> stepkut: ^-
19:19:44 <dsantiago> shachaf: Yeah, for someone as new as me, everything sounds pretty complicated though.
19:19:55 <donri> edwardk: you can use file-embed with happstack though, since yesod made that a decoupled package... but it's not as automatic as in yesod currently
19:20:16 <aristid> stepkut: well kamatsu didn't find a pure-haskell solution, but nobody was aware of web-routes i think. but again i need to check up on web-routes, as i am not currently knowing what it can and cannot do
19:20:17 <edwardk> donri: its the 'staticFiles' combinator that i was thinking of mostly
19:20:52 <edwardk> donri: for making safe references to all the files in your static file dir, so your code can't mis-link to a non-existent jquery plugin version or something
19:21:05 <donri> yea, that does sound neat. and probably requires TH
19:21:13 <stepkut> a pure haskell solution for what?
19:21:24 <edwardk> i had a bit of a love-hate relationship to it. and yes, its a TH splice, so its dog slow, but the safety of it was very nice
19:21:29 <aristid> stepkut: the web-routes documentation is not extremely friendly to people who are not at all familiar with it.
19:21:47 <zrxy> what are the usage stats like for snap / happstack / yesod ?
19:21:52 <edwardk> anyways the lack of something like that was a net negative for me on the snap side
19:22:00 <stepkut> aristid: which documentation are you basing that on? What is is the crash course? or what is in the haddocks?
19:22:07 <aristid> stepkut: haddocks.
19:22:16 <aristid> stepkut: what is not linked from hackage i will not find.
19:22:26 <stepkut> aristid: i will add a link
19:22:31 <aristid> stepkut: but i think i get the gist now
19:22:38 <stepkut> http://www.happstack.com/docs/crashcourse/WebRoutes.html#web-routes
19:22:48 <aristid> stepkut: so in web-routes you create an ADT, and it automatically generates routes from that using Generic?
19:23:15 <stepkut> you create an ADT, and then use whatever method you prefer to create the mapping from the type to the url strings
19:23:46 <stepkut> that can be done automatically by template haskell or generics, or 'manually' using boomerang
19:23:59 <donri> edwardk: i only meant it's a good example of a use case where TH really is necessary
19:24:15 <edwardk> donri: yeah
19:24:30 <stepkut> with boomerang, you only have to specific the mapping once using combinators that simultaneously define the printer and parser, ensuring that they are always consistent with each other
19:25:06 <stepkut> at the lowest level, web-routes requires a pair of functions, a parser and a printer for the type. How you create the functions is up to you..
19:25:16 <stepkut> but we provide a several solutions
19:25:37 <stepkut> the yesod -quasi method used to be supported but is somewhat bitrotted at the moment
19:25:59 <aristid> stepkut: nice
19:26:33 <stepkut> I will probably revive quasi at some point in time because it will make yesod users feel more at home ;)
19:26:46 <stepkut> but, compared to boomerang, it is far less expressive
19:28:07 <aristid> stepkut: can you also generate safe links?
19:28:57 <stepkut> aristid: what do you mean by generate safe links?
19:29:29 <aristid> stepkut: say i have an element of Sitemap and i want to create a link so i can put it in <a href="http://bla">
19:29:49 <stepkut> aristid: like this,? <p>Click <a href=(Monkeys (succ n))>here</a> for more.</p>
19:30:07 <aristid> stepkut: yes
19:30:18 <stepkut> aristid: then yes.. that comes from an example in the docs
19:30:42 <aristid> stepkut: sorry, did not notice the text continues :D
19:30:51 <lispy> Is (->) the only standard instance for Arrow?
19:30:55 <lispy> ?instances Arrow
19:30:57 <lambdabot> (->), Kleisli m
19:31:14 * lispy isn't familiar with Kleisli m
19:31:30 <sclv> that's the kleisli category for a monad
19:31:38 <sclv> so any monad lowers into an arrow via that
19:32:00 <stepkut> aristid: :D
19:33:59 <aristid> stepkut: the fact that if you want to _precisely_ lay out the way the routes look, you'll have to first define the ADT and then write the boomerang code is probably not a real problem. avoiding TH seems worth this price, and you _do_ gain flexibility
19:34:14 <applicative> lispy: its  a newtype for a -> m b
19:34:26 <akahn> how can I use OverloadedStrings in ghci?
19:34:37 <aristid> akahn: :set -XOverloadedString
19:34:42 <applicative> :set -X
19:34:48 <applicative> like aristid said
19:34:57 <lispy> So, the standard arrows are just (->), Kleisli m
19:34:58 <aristid> but add the s at the end that i forgot
19:34:58 <lispy> ?
19:35:13 <sclv> standard as in in "base", yes
19:35:14 <stepkut> aristid: indeed!
19:35:22 <lispy> eg., if I understand both of those I'll at least understand the standard arrow instances?
19:35:40 <sclv> i don't know what you mean by "standard"
19:35:58 <sclv> if you want to understand yampa arrows, you should look at the arrows yampa uses, etc.
19:36:20 <stepkut> aristid: and if you aren't that picky, you can just do derivePathInfo, and get automatically derived routes. Since the ADT isn't used for anything aside from routing, you can usually structure your types to be 'good enough' for whatever you want your urls to look like
19:36:28 <sclv> the function arrow is boring and kleisli is sort of uninteresting in that anything you really want to be an arrow is *not* a monad
19:36:39 <sclv> patterson has the arrows library on hackage
19:36:39 <aristid> stepkut: well there's the rule that urls should not change
19:36:51 <lispy> sclv: thanks
19:37:03 <aristid> stepkut: so a layer of separation may help keep urls constant while allowing change of the type
19:37:03 <sclv> which has stream and automata arrows
19:37:20 <applicative> ?instances Category
19:37:21 <lambdabot> Couldn't find class `Category'. Try @instances-importing
19:37:27 <aristid> ok, urls can change but not too often and if they do make sure to 301 the old one
19:37:28 <sclv> i tend to think of stream and automata arrows as more cannonically "why you want arrows"
19:37:39 <stepkut> aristid: right.. by keeping the type separate from the mapping function, you can more easily setup redirects when you do need to change a url
19:37:44 <sclv> and closer to how they're used in yampa, parsers, etc.
19:38:35 <donri> aristid: still nice for development, before settling on a url scheme. also you can do the same with generics and no th.
19:38:49 <applicative> lispy: Isn't it like Control.Category; the only instance it exports is (->) but they're all over
19:38:51 <donri> with ghc 7.2+ anyway
19:39:03 <stepkut> aristid: alas, i gotta clean house now.
19:39:09 <aristid> stepkut: so i'm not snoyberg's lawyer, i was just referring to what i remembered from the discussion between snoyberg and kamatsu (or in real names: Michael Snoyman and Liam O'Connor)
19:39:17 <stepkut> aristid: :)
19:39:48 <stepkut> aristid: if I had to spend all day correcting wrong people, I would never have time to write new code :)
19:40:25 <aristid> stepkut: well kamatsu did try to find a solution to snoyberg's challenges, unsuccessfully. that did leave an impression on me because kamatsu is smart:)
19:41:23 <aristid> stepkut: but i should not prevent you from doing what you need to do :P
19:41:34 <stepkut> :)
19:41:37 <pharaun> what was the discussion?
19:42:39 <stepkut> aristid: if you have specific examples, I can provide answers
19:42:46 <Cale> Personally, I find the use of quasiquoters unsettling
19:43:09 <stepkut> Cale: me too. using qq for javascript makes sense.. but  for routing.. not so much
19:43:32 <stepkut> of course, in happstack we use a javascript quasiquator that actually does javascript syntax validation
19:43:36 <pharaun> isn't the whole point of th/qq to try to provide type safe url/etc
19:44:07 <aristid> this is the discussion i was referring to: https://plus.google.com/110988559818762092753/posts/V9EuZGkGbqh
19:45:39 <stepkut> aristid: i responded to that thread already :P
19:46:06 <Cale> I would honestly forego some amount of type safety if it meant I didn't have to deal with understanding some quasiquoter hackery. But I don't see any good reason why it should be that you'd lose safety from using some properly embedded DSL instead.
19:46:37 <aristid> stepkut: yes, but the last time i read the thread your comment was not yet there, and reading it now, it's a little bit cryptic
19:48:18 <stepkut> the primary example that michael offers there is, that, /foo/#Text/bar BazR GET, is shorter than any alternative. Which is true. That is what the DSL does. The problem is what happens when you want to use a type like, /foo/$SomeUserSuppliedADT/bar. Suddenly yesod falls short.
19:48:50 <stepkut> aristid: which part do you find cryptic?
19:49:27 <stepkut> I wrote that pretty quick.. probably not my best writing :)
19:49:41 <aristid> stepkut: well i understand that you say you use TH/QQ in a limited way... but not much more
19:50:00 <pharaun> stepkut: oh really, i thought the qq/yesod was able to handle the user supplied ADT :(
19:50:29 <stepkut> pharaun: I think it can, but only if you create a instance of some type class by hand, and yesod does not provide any good tools for elegantly doing that
19:50:49 <stepkut> pharaun: compared to something like boomarang, where everything can be expressed using composable and extensible combinators
19:52:02 <stepkut> pharaun: that is the problem with the yesod QQ stuff.. it is great right up until you need to do something it can't.. and then you are in an unfun spot
19:52:28 <pharaun> ahh i see
19:53:01 <pharaun> stepkut: thanks :) i just haven't reached that point yet, and i'm still wanting to play with the other stuff to find one that works for me the best
19:53:20 <stepkut> since the support for built-in patterns in the yesod route qq is pretty limited, and adding new stuff is a pain, people generally just keep their routes simple enough to fit into the defaults
19:53:39 <stepkut> for example, instead of creating a type for something, they might just make the variable part of the url a #Text field
19:53:48 <stepkut> resulting in less type safety
19:53:57 <Cale> I also kind of disagree that it's great even as far as that, because there's no real way to properly understand the quasiquoters by looking at their types, like it would be possible to do by looking at the combinators in a proper Haskell library.
19:53:58 <pharaun> i can see how that would happen
19:54:09 <stepkut> Cale: indeed
19:54:17 <pharaun> yeah when i was playing with yesod, i liked some aspects of it
19:54:24 <pharaun> but i had a hell of a time trying to figure out some of the types
19:54:43 <stepkut> Cale: i think if you are coming from RoR then yesod is a step up.. but if you are coming from a Haskell background.. there is a lot of non-haskell feel to it
19:55:01 <stepkut> Cale: also.. it uses type classes in ways that make me frown
19:55:25 <pharaun> stepkut: what about someone who never used RoR :) and is still newish with haskell
19:55:27 <Cale> The other thing which I dislike about the QQs in Yesod is that they seem to define things which are not syntactically mentioned anywhere in the enclosed code.
19:55:33 <stepkut> Cale: for example, yesod seems to use type classes as an odd way of creating global constants
19:55:48 <Cale> Which is just a horrible horrible policy for any language.
19:56:04 <stepkut> pharaun: happstack-lite is very small and easy to get started with, http://www.happstack.com/c/view-page-slug/9/happstack-lite
19:56:39 <stepkut> pharaun: and you can gracefully slide from happstack-lite to the full happstack by simply importing the rest of happstack, which is documented here: http://www.happstack.com/docs/crashcourse/index.html
19:57:40 <rcl> Is it possible to evaluate fibs (within a limited range of course) as an expression, i.e. on tryhaskell.org?
19:57:45 <stepkut> the crash course is around ~200 pages if you formatted it for printing =O. But the happstack-lite docs are under 2000 words and provide everything required to write a web application
19:58:08 <pharaun> stepkut: sweet :)
19:58:15 <lispy> rcl: try something like: take 10 fibs
19:58:36 <rcl> lispy: not in scope fibs
19:58:43 <stepkut> pharaun: if you don't like the blaze-html syntax, you can use HSP instead, which provides html syntax in your haskell files. Some people love, other people quiver in fear
19:58:51 <lispy> rcl: I assumed you had a fibs definition
19:59:12 <rcl> Is it possible to define fibs as a function on tryhaskell.org (as an expression)?
19:59:16 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- rcl you could use this
19:59:18 <lambdabot>   [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1...
19:59:30 <lispy> rcl: and if you don't have fix, then use let
19:59:37 * stepkut really must clean
19:59:42 <aristid> stepkut: i'm still a bit bitter that blaze-html defines a Monad for html (and throws an error if you actually use the value from >>=)
19:59:46 <lispy> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in take 10 fibs
19:59:48 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
20:00:18 <Cale> aristid: agreed, that is dumb
20:00:20 <rcl> hm that's failing
20:00:41 <pharaun> stepkut: what about um hamlet? i thought it was alright in yesod or is hamlet like too tied to yesod, i'll admit i haven't tried to pull hamlet out
20:00:49 <Nereid> what's failing?
20:01:06 <lispy> rcl: works for me:
20:01:07 <lispy> > take 10 $ fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
20:01:07 <lispy> => [1,1,2,3,5,8,13,21,34,55]
20:01:08 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
20:01:11 <stepkut> pharaun: you can use hamlet with happstack. It's even documented in the crash course. I like HSP better though.
20:01:16 <rcl> nevermind it works haha
20:01:21 <Cale> I also dislike HSP
20:01:30 <pharaun> stepkut: heh i'll peek at HSP
20:01:33 <stepkut> Cale: for what reasons? (there are plenty to choose from)
20:01:41 <rcl> Thanks a lot folks
20:01:52 <Cale> Mostly the same reasons I dislike quasiquoter languages
20:01:53 <lispy> rcl: np, we encourage questions :)
20:01:58 <stepkut> Cale: my primary complaint about HSP is that is results in unfortunate type errors
20:02:40 <lispy> > map text $ take 10 $ fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
20:02:42 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
20:02:42 <lambdabot>    arising from the literal `...
20:02:43 <Cale> I'd rather just have plain well-designed combinators which exactly fit the nature of the structures that I'm building. (none of this "let's wedge something which isn't a monad into being a monad" business)
20:03:04 <lispy> > map text . take 10 . fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
20:03:05 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
20:03:06 <lambdabot>    arising from the literal `...
20:03:09 <lispy> hmm
20:03:14 <lispy> oh, I need a show
20:03:21 <lispy> > map (text.show) . take 10 . fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
20:03:23 <lambdabot>   [1,1,2,3,5,8,13,21,34,55]
20:04:02 <stepkut> Cale: trying to wedge HTML into Haskell in any form is a bad match I think.. but a neccessary evil.
20:04:27 <stepkut> Cale: but, I would welcome a better alternative to blaze-html any day
20:05:25 <carmin> sorry to bother u again applicative but how can i write a function that returns me a random int between a range? i know randomR, randomRIO, but they dont seem to work when called from inside another function
20:05:28 <stepkut> Cale: hsp is actually two separate pieces. The syntax transformer that transforms <a href="foo">bar</a> into, genElement [asAttr "href" "foo"] [asChild "bar"], and the library that provides the genElement, asAttr, asChild functions
20:05:48 <Cale> stepkut: Yeah, I'd probably just use the latter.
20:05:51 <stepkut> Cale: you could actually use plain haskell combinators with HSP and not use the syntax transformation at all
20:06:14 <stepkut> Cale: however, I have yet to see a plain haskell HTML syntax that is less horrible than HTML :-(
20:06:32 <Cale> HTML syntax is ugly-as-sin to begin with, so it's hard to do worse.
20:06:53 <Crockeo> Cale: HTML isn't ugly, it's just that when you mix it with other modern technologies it gets messy.
20:07:00 <stepkut> Cale: in someways, that actually helps -- it is so obviously not haskell code that it is clear to see what is just HTML fragments and where the interesting haskell parts of the template are :)
20:07:06 <Cale> Crockeo: yes it is. End tags are ridiculous.
20:07:41 <Crockeo> I quite like the explicitness of {}'s in C++
20:08:03 <Crockeo> but that sort of thing doesn't really fit into Haskell.
20:08:03 <Crockeo> It /does/ fit into HTML, though.
20:08:08 <Nereid> Cale: good thing you don't have to type them with hamlet!
20:08:16 <Crockeo> Anyways, point is-
20:08:19 <Crockeo> Ohey Nereid!
20:08:21 <Nereid> hi
20:08:30 <Cale> Crockeo: Yeah, but you don't write  strong { ... }, you write  <strong> ... </strong>
20:08:50 <zxq9> Crockeo: explicit for you or the compliler? There's a big difference, which is why we indent...
20:08:54 <Cale> Crockeo: I would be 10x happier with an HTML which looked like a semicolon/brace language
20:08:54 <Nereid> Cale: how about TeX?
20:08:59 <Crockeo> Anyways, is it preferable to define a toString sort of function or to create an instance Show <datatype> sort of thing?
20:09:07 <zxq9> Crockeo: And if we indent then why write out { }?
20:09:12 <darkf> When should you use ST or IORef instead of State?
20:09:20 <shachaf> <strong><lax><monoidal><functor>F</functor></monoidal></lax></strong>
20:09:32 <rcl> What kind of webservice would make good use of Haskell? It seems like most webservices are just routing data around and using specific 3rd party utils that seem like they wouldn't be available in haskell (or at least not as maintained)? What's the use case
20:09:40 <Nereid> Crockeo: show is supposed to output something that resembles a haskell expression for the value
20:09:41 <Cale> darkf: You use IORef when you're in IO already
20:10:02 <darkf> Cale: Wouldn't that tempt me to try to be in IO often? :p
20:10:24 <Cale> darkf: For example, communicating stuff between threads (in a freewheeling sort of way)
20:10:28 <Crockeo> Nereid: So show is supposed to be similar to how you define the datatype, but you can make a toString function to make it go to anything?
20:10:50 <Nereid> Crockeo: you are free to define your own pretty printing function.
20:10:51 <Cale> darkf: ST gives an otherwise pure computation access to an unbounded amount of local state -- you can create and manipulate mutable arrays and such
20:11:04 <Crockeo> Nereid: Good to know! : D
20:11:06 <Nereid> Show does get abused sometimes, but that's the idea behind it.
20:11:42 <darkf> Cale: So if I'm writing, say, a video game, which needs to carry on state about the game, which would I want to use?
20:11:43 <Cale> rcl: We're redoing our web application backend in Haskell at skedge.me
20:11:47 <Crockeo> Well, thank you.
20:11:49 <Eduard_Munteanu> You may also convert ST actions to IO actions.
20:11:54 <Crockeo> Also, time to follow LYAH and make a reverse polish notation calculator
20:12:00 <Nereid> :)
20:12:22 <rcl> Interesting
20:12:23 <Cale> rcl: There's really not a lot to it, but it's amazing how hairy stupidly simple things can get in some languages :P
20:12:37 <zxq9> Is anyone familiar with gui widget bindings? I'm looking for a recommendation. I'm coming from C/Gtk+, C++/Qt and PyQt.
20:12:59 <Nereid> zxq9: there's gtk2hs for gtk+
20:13:06 <Crockeo> Well
20:13:09 <Eduard_Munteanu> zxq9: I've found gtk2hs to be a reasonable choice.
20:13:19 <Crockeo> gtk2hs, as I've been pointed to before.
20:13:22 <Cale> rcl: The most algorithmically complicated thing we're doing is determining when it's possible to schedule various services that people define (when the required people and resources are available), in the presence of recurring events of various sorts.
20:13:24 <Crockeo> Though to be fair, I've never used it.
20:13:34 <Nereid> I think there are some qt bindings but I don't know how pleasant those are to use.
20:13:45 <zxq9> Reasonable choice across Linux, Mac, Windows?
20:13:56 <Nereid> there's also wxhaskell
20:14:14 <zxq9> Nereid: The Qt stuff looks pretty old -- alteast release was 2010, so I'm a little concerned that I'd be inhereting a binding project.
20:14:24 <Nereid> heh
20:14:25 <Eduard_Munteanu> GTK should work on all those platforms, though looks might be better or worse.
20:14:41 <geekosaur> the actively supported stuff is wxhaskell and gtk2hs
20:14:50 <darkf> Alrigh then: If I'm writing a game, and I want to pass the game state around, what should I use? State, ST, IORef, or something else?
20:14:57 <Nereid> well gtk2hs would give you the same visual results as using gtk+ from C
20:15:11 <zxq9> Its a constellation of business applications we're moving from web to for-real GUI apps, so looks aren't nearly as important as X-platform availability.
20:15:15 <rcl> Cale: thanks for sharing, I hope it goes well, brave souls
20:15:18 <Cale> rcl: Despite this, there are a lot of various sorts of safety and sanity issues which need to be tended to, and they're just the sort of thing which Haskell is good at keeping track of through the use of types and computational contexts of various sorts.
20:15:39 <Nereid> zxq9: I believe gtk2hs and wxhaskell work on all of those platforms
20:15:42 <zxq9> It'd be a special bonus if there were some potential to be able to port the stuff to Android or iOS also.
20:15:59 <Nereid> that's harder :p
20:16:09 <Eduard_Munteanu> IIRC, Haskell on Android is being worked on, but it's not quite ready.
20:16:15 <rcl> I keep finding that I want to learn more about haskell but the only application I find in my life is that it helps make me be smarter
20:16:24 <zxq9> But mobile would be a bonus, not a necessity -- if the client really needs tablets we'll just put our own distro on them if need be.
20:16:32 <rcl> Not that knowing haskell seems to have any practical application for me :)
20:17:22 <zxq9> Eduard_Munteanu: Any idea what the hold up on Android is?
20:17:30 <Cale> rcl: There's no shortage of possible practical applications of any general purpose language with the level of library support that Haskell's acheived.
20:17:46 <Eduard_Munteanu> darkf: generally, I'd say State, but it depends on what state you're talking about.
20:17:58 <zxq9> rcl: Consider that my (tiny) company is looking at it for native business app development.
20:18:02 <Eduard_Munteanu> zxq9: not sure
20:18:15 <Cale> rcl: But it does require a reasonable amount of effort to learn in the first place (though likely not much more than one's first programming language)
20:18:34 <zxq9> Eduard_Munteanu: Hrm. I'll play around. I appreciate the input guys.
20:18:41 <Eduard_Munteanu> darkf: ST is useful if you're doing stuff like mutable arrays, where mutation is a requirement perfomance-wise or such.
20:18:46 <darkf> Eduard_Munteanu: The entire world state -- let's say a list of players, their positions (x/y), a list of entities and their attributes (position, sprite, etc) and probably something like elapsed time.
20:19:06 <Cale> rcl: I've been programming in Haskell for 11 years or so now though, so for me, it's significantly more comfortable than using anything else.
20:19:41 <stepkut> aristid: the example SM gives in that post reminds me arguing that perl is better than Haskell because you can perl golf some code to be shorter... yesod is perhaps optimal for some set of parameters, but the argument is about whether or not those are the right parameters
20:19:42 <Eduard_Munteanu> darkf: then State, perhaps Reader for things that don't change midway through.
20:20:20 <Eduard_Munteanu> Time is going to be an IO thingy though.
20:21:07 <darkf> Well I don't suppose this is Haskell's strong point either :)
20:21:55 <Eduard_Munteanu> Actually I found myself wishing for stuff like Reader or State in other languages.
20:22:32 <zxq9> Ohhh.. one other question. Is there any binding support for Postgres calls from Haskell? Something analogous to psycopg2+Python.
20:22:36 <darkf> Eduard_Munteanu: It does make it a lot more cumbersome to write things like games though, or maybe I'm just dumb.
20:22:56 <rcl> Cale: 11 years that's pretty awesome
20:22:57 <Cale> rcl: Programming in imperative languages is so much more mentally taxing -- I have to keep track of way too many things in my head, and I'm constantly forced to worry about many interactions which I can't really control (even if nothing unintended is going to happen for any given one-line change, I might have to dig through an unbounded amount of code to know that). As a consequence, either I write lots of bugs and spe
20:22:57 <Cale> nd lots of time in a debugger wading around trying to find where everything has gone wrong, or I just program *very slowly*.
20:23:48 <Eduard_Munteanu> darkf: you could stick everything into IO, but it's not a good idea. Once you get used to these things you'll notice it simplifies your code, e.g. you don't have to worry about passing the state around anymore.
20:24:24 <lispy> Is it just me or is there a pretty natural usage of arrows that comes from zippers?
20:24:27 <darkf> Eduard_Munteanu: because I get to use IORef? :)
20:24:42 <Nereid> also, lens is great for working with State :p
20:25:08 <Eduard_Munteanu> darkf: because it's not really idiomatic Haskell
20:25:09 <aristid> i feel like lens is overkill for my simple isomorphism, but LENS ALL THE THINGS
20:25:16 <edwardk> aristid: =)
20:25:40 <lispy> We're surrounded by lens zombies! ;)
20:25:50 <aristid> edwardk: it seems like the TH code seems to silently fail for invalid types btw
20:25:53 <lispy> fuuunnccttooorrrss......
20:25:56 <edwardk> lispy: leeeeeens, leeeeeeeens
20:26:04 <Nereid> > execState (_2 += 1) (3,4)
20:26:06 <lambdabot>   (3,5)
20:26:18 <nexx> moooonaaad
20:26:23 <Cale> and in this backend code that we're replacing, basically the debugger is the only reasonable thing to use to find and understand bugs. Reading the code is futile -- in a large part because the guys who originally wrote it (and were subsequently laid off) didn't really know what they were doing -- but also because the language allowed them to get away with many atrocities.
20:26:26 <edwardk> aristid: using makeLenses or something?
20:27:02 <edwardk> aristid: hop on #haskell-lens
20:29:22 <lispy> LYAH defines flip ($) and calls it (-:)
20:29:39 <lispy> > let x -: f = f x in 1 -: (+1)
20:29:41 <lambdabot>   2
20:30:00 <lispy> just, you know, adding an option to the bikeshed
20:31:52 <Nereid> > do { x <- use _1; _2 += x } `execState` (3,4)
20:31:55 <lambdabot>   (3,7)
20:34:03 <lispy> :t _2
20:34:05 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
20:34:49 <lispy> I wish the prelude had those _1, _2, ... for the standard tuples that it defines
20:35:07 <lispy> instead of just fst, snd for (a,b)
20:35:52 * geekosaur smells lensyprelude coming up...
20:36:07 <edwardk> geekosaur: i categorically refuse =P
20:36:31 <geekosaur> I didn't say you were the one who would write it!
20:36:32 <edwardk> lispy: yeah but its a two character option, so i reject your option =P
20:36:56 <geekosaur> but it seems like alternative preludes are the new monad tutorials :p
20:39:09 <lispy> Revising the prelude always sounds cool, but actually having that discussion would be painful (and bikeshed-full) and dealing with the new prelude would be overwhelming (I think ghc changes between releases are bad enough)
20:41:01 * hackagebot network-enumerator 0.1.5 - Enumerators for network sockets  http://hackage.haskell.org/package/network-enumerator-0.1.5 (JohnMillikin)
20:43:22 <hpaste> Crockeo pasted “More Efficient Way?” at http://hpaste.org/78202
20:43:48 <Crockeo> I implemented a function to remove whitespace, but I feel like there may be a non-recursive way to implement it, in turn making it more efficient
20:44:32 <geekosaur> hlint already gave you some ideas.  but I would add that, if ' ' is the only space you care about, there's already a function in Data.List you can use
20:44:55 <shachaf> Crockeo: Good rule of thumb: Never use head and tail.
20:45:12 <geekosaur> as for recursion, it's a natural idiom in haskell
20:45:16 <Crockeo> removeWhiteSpace' string = [x | x <- string, x /= ' ']
20:45:18 <shachaf> Anyway, this function runs over the whole string, right? There's going to be *some* form of recursion there, whether explicit or implicit.
20:45:19 <geekosaur> that also.
20:45:35 <shachaf> removeWhiteSpace = filter (/= ' ')
20:45:50 <geekosaur> ^^ is what I was trying to point you at
20:46:07 <Crockeo> Maaaaaaan, I completely forgot about filter
20:46:07 <Crockeo> thank you.
20:46:52 <geekosaur> alternately:  removeWhiteSpace "" = ""; removeWhiteSpace (' ':xs) = removeWhiteSpace xs; removeWhiteSpace (x:xs) = x:removeWhiteSpace xs
20:48:23 <Eduard_Munteanu> Hm, do you want to completely remove whitespace, or just trim it?
20:48:46 <geekosaur> that alsois a question but I went with what was presented
20:49:14 <geekosaur> Crockeo:  note that my final one is easy to adapt to do trimming leading whitespace too
20:49:47 <Crockeo> Eduard_Munteanu: All whitespace, but other peoples' suggestions already have me covered.
21:10:02 <lispy> edwardk: do lens have a notion of cursor like zippers do?
21:10:11 <lispy> s/cursor/focus
21:10:17 <shachaf> lispy: Control.Lens.Zipper does. :-)
21:11:11 <shachaf> lispy: A lens itself is a "cursor" on some particular part of a structure.
21:11:12 <lispy> heh, I guess I should have looked before asking
21:11:20 <edwardk> > rezip $ zipper ("hello","world") & down _1 & focus .~ "hahahhah"
21:11:22 <lambdabot>   ("hahahhah","world")
21:11:49 <edwardk> > rezip $ zipper ("hello","world") & down _1 & focus .~ "hahahhah" & focus.traverse.iwhere even %~ toUpper
21:11:51 <lispy> It's hard to not read "&" as "and"
21:11:51 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
21:11:51 <lambdabot>              with actual type...
21:12:06 <johnw> edwardk: we should make an example of a 3x3 matrix and using lens zippers to draw a shape in it or something
21:12:17 <edwardk> > rezip $ zipper ("hello","world") & down _1 & focus .~ "hahahhah" & focus.iwhere even %~ toUpper
21:12:19 <lambdabot>   ("HaHaHhAh","world")
21:12:24 <lispy> edwardk: can I read email with lens yet?
21:12:31 <edwardk> lispy: read it outloud as 'and' as in 'and then'
21:12:41 <edwardk> lispy: yes, email lenses are going in in 3.7
21:12:47 <lispy> :)
21:12:53 <johnw> edwardk: did you mean to mix & and %~?
21:13:05 <edwardk> johnw: you can do that with linear.   m^._x._y
21:13:26 <edwardk> johnw: yes. like i mentioned on the mailing list. i didn't rename %~, etc. just &
21:13:39 <johnw> there should also be &~ and <&~
21:13:54 <lispy> so many operators
21:13:56 <shachaf> I'm fine with it the way it is.
21:14:03 <edwardk> i deliberately renamed &~ to .&.~ to closer match the underlying operators
21:14:11 <edwardk> but i'm pretty happy with it as %~
21:14:48 <edwardk> lispy: %~ is 'mod-equals' in read as 'modify'
21:15:28 <edwardk> its, partially, a pun, and motivated the original choice of (%) as the operator that (%~) was applying to the target of the lens.
21:15:45 <edwardk> > (2,3) & _2 +~ 12
21:15:46 <lambdabot>   (2,15)
21:15:56 <edwardk> > (2,3) & _2 %~ (+ 12)
21:15:58 <lambdabot>   (2,15)
21:16:00 <johnw> so, it's & and &~?  I preferred % and %~
21:16:01 <edwardk> > (2,3) & _2 %~ succ
21:16:03 <lambdabot>   (2,4)
21:16:06 <johnw> or at least, something consistent
21:16:14 <johnw> no, I mean, it's & and %~?
21:16:22 <edwardk> johnw: its & and %~
21:16:30 <shachaf> I'm fine with it that way.
21:16:34 <johnw> i'm calling ugly on that one, edwardk
21:16:36 <edwardk> consistency is okay, but i really don't like the way &~ reads
21:16:38 <shachaf> I don't think of (&) and (%~) as related.
21:17:15 <edwardk> shachaf: me neither. their relatedness was posthoc. it was nice while it lasted but i think its actually a lot easier to visually read chains of %~ 's with them as different operators
21:17:18 * lispy wonders if he should be reading some paper about lenes for general background into the theory
21:17:25 <johnw> shachaf: i guess i shouldn't either then
21:17:35 <johnw> lispy: i recommend it
21:17:39 <edwardk> lispy: https://github.com/ekmett/lens/wiki/Derivation is the theory
21:17:43 <johnw> the lens theory is rather elegant
21:18:03 <lispy> edwardk: thanks
21:18:06 <shachaf> lispy: I can talk about my intuition for it at some point if you like.
21:18:16 <lispy> johnw: do you have a paper in mind other than the link edwardk just gave me?
21:18:23 <johnw> i find edwardk's exposition a bit too dense, but if you google for "lens costate comonad", and also read van laarhoven's paper, it should become clearer
21:18:35 <lispy> thanks
21:18:44 <johnw> and *then* go to edwardk
21:18:58 <johnw> edwardk's answers work best when I've done 99% of the work already :)
21:19:15 <edwardk> lispy: i'll be giving a talk in 2 weeks that should be recorded as well, but don't wait 2 weeks to learn lenses ;)
21:19:39 <shachaf> I found all of these resources confusing.
21:20:02 <shachaf> But who knows. Clearly different people think about the same thing differently. :-)
21:20:56 <geekosaur> cabal install SourceGraph wants to reinstall network.  without warning about the one already installed.  wtf?
21:21:35 <johnw> i liked the progression: lens = getter (a -> b) + setter (a -> b -> a); better lens = fusion of getter/estter (a -> (b, a)); fusion looks a lot like costate; lenses act like a comonad; aha, the costate comonad!  And in fact, the coalgebra for that comonad naturally leads to the lens laws...
21:22:22 <edwardk> my current exposition tries to just derive the lens laws from the functor/traversable laws and the fact that you have a function.
21:22:23 <lispy> but this raises the question, what is a colens?
21:22:24 <shachaf> I think the comonad/etc. thing doesn't help you understand it at all, especially if you don't already have an intuition for what that means.
21:22:39 <edwardk> lispy: rwbarton derived one using costrength, its somewhat interesting but weak
21:23:07 <geekosaur> yep, incoming network 2.4.0.1 on top of the existing network.  no warning, no 'reinstalls dangerous', just destroy my package db.  I thought newer cabal was supposed to be better abotu this
21:23:12 <rwbarton> i've decided that naive colenses are the good thing and the van laarhoven things seems like a wrong idea for colenses
21:23:26 <johnw> shachaf: when you had me implementing Context, you were taking me the Comonad route
21:23:39 <johnw> which did help, btw
21:23:49 <edwardk> rwbarton: fair enough
21:24:22 <edwardk> johnw: its kinda like monad tutorials, the third one you read is the one you remember and becomes your one true learning methodology everyone should folllow for life ;)
21:24:30 <lispy> van laarhoven's contribution was to return a functor in the getter/setter?
21:24:37 <johnw> edwardk: yeah, that's a good point
21:24:53 <shachaf> The advantage of the twanvl style is that it extends to Traversal/etc. naturally
21:25:05 <johnw> edwardk: but i guess we've got to start explaining things somewhere, since we can start at the purely abstract, so we each pick the path that led to greatest clarity for us individually
21:25:38 <edwardk> lispy: yeah
21:26:38 <edwardk> lispy: if you take the 'experiment' combinator in Control.Comonad.Store, it fully characterizes the store comonad.
21:27:01 <edwardk> lispy: so if you take a function to that, and flip it you get the van laarhoven lens exactly
21:27:12 <shachaf> experiment ~ "bazaar" for Context?
21:27:31 <edwardk> shachaf: runBazaar
21:27:34 <edwardk> :t runBazaar
21:27:36 <lambdabot> Not in scope: `runBazaar'
21:27:45 <edwardk> :t Control.Lens.Internal.runBazaar
21:27:47 <lambdabot> Applicative f => Control.Lens.Internal.Bazaar a b t -> (a -> f b) -> f t
21:27:48 <shachaf> (Functor f, ComonadStore s w) => (s -> f s) -> w a -> f a
21:28:38 <edwardk> so if you say w a = forall f. (s -> f s) -> f a    -- then experiment f w = w f
21:29:04 <edwardk> defining w in such a way that experiment is trivial to write and everything else gets defined in terms of it
21:29:33 <johnw> my lens fusion type above was wrong; it should be (a -> (b, b -> a))
21:29:35 <edwardk> its kind of like saying newtype Mu f = Mu { runMu :: forall a. (f a -> a) -> a }
21:29:58 <shachaf> I have no idea what goes through edwardk's head when he's thinking about these things, but it's clearly very different from what's going on in mine.
21:30:06 <shachaf> Somehow we end up at roughly the same conclusions, though.
21:30:23 <johnw> shachaf ≅ edwardk up to lenses
21:30:38 <edwardk> hahaha
21:32:48 <lispy> edwardk: there is this example where they do two polymorphic field updates in a single lens and say that naive composition of van laarhoven lenses won't support that.
21:33:03 <lispy> edwardk: But, I bet you figured out a way to make your lenses support that?
21:33:14 <shachaf> lispy: Which example?
21:33:17 <edwardk> lispy: nope
21:33:22 <edwardk> lispy: well. yes and nope
21:33:29 <lispy> shachaf: complexExample http://www.r6.ca/blog/20120623T104901Z.html
21:33:37 <edwardk> lispy: you can use the lenq stuff that isn't in mainline yet to support it
21:33:49 <inquirious> heya!
21:33:56 <edwardk> $(lense [e| \(x,y,z) -> (x,y) |])
21:33:58 <shachaf> lispy: Oh, nope, that's not really possible.
21:34:04 <edwardk> that will make a lens that can update the first two fields
21:34:08 <shachaf> lispy: The individual lenses can't be polymorphic enough to change the type.
21:34:25 <shachaf> So you can't do anything with the combined lens.
21:34:52 <edwardk> lispy: in practice its not really that bad of a problem. you'll eventually have the lens dsl to do those complex updates in the few places you actually need them
21:34:58 <lispy> edwardk: any luck with the IORef generalization we discussed the other day?
21:35:03 <edwardk> and most of the time you'd want a traversal anyways
21:35:14 <edwardk> lispy: sadly no. they are pretty much dead in the water
21:35:31 <edwardk> they were the original motivation for 'Action', which is still there, but it gets little use
21:35:32 <lispy> edwardk: remind me, what's different/hard about them?
21:36:27 <dsantiago> Is it still the case that ghc can't cross-compile? So I have to build a linux binary on a linux box, for example?
21:36:30 <edwardk> basically if you implement them under the current scheme, you'd always have to read from them, and always write back every time you just wanted to peek at it, etc.
21:36:34 <inquirious> So. I've been kinda trying to lern programming for a little while and I have started some tutorials on a lot of programs, haskell, Ocaml, ada, C++, python, java... But this is now the time where I am to really get into it. I dont have a lot of time spare, and I am not to become a full time programmer and I do know already what language I'll be using the most in a few years, that is Ada. But I wonder if it might be just a better idea
21:36:43 <edwardk> you waste a LOT of effort and the laws become quite questionable
21:36:44 <inquirious> g like Haskell before
21:36:46 <shachaf> lispy: By the way, there's nothing magical about twanvl lenses that allows polymorphism. You can extend pretty much any lens formulation to do it.
21:37:13 <lispy> dsantiago: still the case, but people are working on it
21:37:42 <Nereid> if a lens is a store comonad coalgebra in Hask,
21:38:03 <Nereid> then a lens family is a store comonad coalgebra in Hask^I for some index category I
21:38:06 <dsantiago> lispy: Darn. Thanks.
21:38:47 <edwardk> Nereid: there is a way to make the indexing more rigorous. i alluded to it in the mirrored lenses blog post, about how the indices get structured
21:39:05 <Nereid> the outer and inner stuff? yes
21:39:05 <lispy> edwardk: So, on the surface, I would expect the lens to need to reread the IORef anyway.
21:39:11 <edwardk> the indexed construction you just described is a bit different though i think
21:39:11 <lispy> edwardk: but maybe I'm missing something?
21:39:22 <edwardk> lispy: even to read from it it writes back
21:39:28 <edwardk> lispy: its pretty f'd up
21:39:41 <lispy> edwardk: that's no good for read-only things :)
21:39:51 <edwardk> correct ;)
21:40:01 <shachaf> djahandarie: Happy djahandarie++ !
21:45:19 <lispy> This is news to me:
21:45:21 <lispy> "Template Haskell is poorly thought out in my opinion, but there are some ideas to replace it with a much more powerful template system that can be statically checked. That makes a very interesting topic in its own right, which I'll visit in a later post."
21:45:46 <lispy> I don't think Template Haskell is poorly thought out, but I would say it's minimal.
21:46:06 <lispy> And what about TH can't be statically checked?
21:46:23 <lispy> I thought TH was staged in such a way that it gets checked at compile time
21:47:49 <mgsloan> The problem is that splices have types like "Exp".  While quotes are typechecked, there is no way for the compiletime code to have any assurance of generating expressions that have the appropriate type
21:48:03 <mgsloan> I agree with you, that this is not a crucial problem
21:48:56 <mgsloan> because it's all compile time anyway.  Having to justify the types in the code for generating ASTs would probably make such code ridiculously more complicated
21:49:12 <lispy> hmm
21:49:15 <mgsloan> but yeah, I think they are strongly considering adding a type parameter to "Exp" for this purpose
21:50:50 <mgsloan> main thing I'd like to see with TH is more surfacing of GHC functionality in terms of TH ASTs.  While it's fun to roll your own external analysis, it's very brittle and never going to work with all the extensions etc (this is even if you could detect while running TH what extensions are enabled)
21:51:08 <mgsloan> I've got a lot of love and a lot of hate for TH :)
21:51:23 * shachaf has got one of those...
21:51:32 <lispy> mgsloan: lack of GHC smarts for ASTs is why I think TH is minimal
21:52:21 <mgsloan> lispy: I suppose - lacking those smarts could certainly discourage compile time code that did anything /too/ complicated
21:52:49 <mgsloan> but all the cool stuff is /too/ complicated :D
21:53:29 <mgsloan> lispy: what's the quote from?
21:54:19 <lispy> mgsloan: http://www.haskellforall.com/2012/01/haskell-for-mainstream-programmers_28.html
21:54:48 <newsham> TH is standardized, no?  so its not really GHC ASTs
21:55:07 <newsham> TH's not terribly hard to get into.. just takes a little time and effort
21:55:27 <inquirious> Do you guys think Haskell is a good "learn to program" language? or maybe start on something else, maybe some imperative?
21:56:51 <shachaf> The language doesn't matter that much.
21:57:33 <lispy> edwardk: and your lens is based on ismorphisms right? http://twanvl.nl/blog/haskell/isomorphism-lenses
21:57:55 <shachaf> No, lens uses the Functor f => (a -> f b) -> s -> f t style.
21:58:25 <lispy> for some reason I thought they used both functors and isomorphisms
21:58:33 <newsham> inqui: it can be..  but most of the books on haskell arent geared towards that
21:58:34 * lispy must have halucinated that
21:58:34 <Nereid> it's based on http://twanvl.nl/blog/haskell/cps-functional-references
21:58:40 <newsham> except maybe "two dozen short lessons"
21:59:16 <lispy> inquirious: If you have a strong math background Haskell is probably a good first language. Otherwise something more mainstream like python might be better?
21:59:21 <inquirious> ehh.... it does for a beginner
21:59:48 <inquirious> uhm, ok
21:59:59 * lispy isn't sure learning python is a good idea, but eh some smart people like it
22:00:05 <inquirious> lispy: that actually helps a lot
22:00:19 <Nereid> lispy: the cool thing about this representation is that it generalizes to traversals and other things
22:00:21 <shachaf> Languages matter a lot less than people seem to think.
22:22:21 --- mode: asimov.freenode.net set +o Igloo
22:22:21 --- mode: asimov.freenode.net set +o quicksilver
22:22:21 --- mode: asimov.freenode.net set +o ChanServ
22:42:29 <Crockeo> Anyone heard of the Haskell IDE Leksah?
22:42:29 <Crockeo> I just realized something about its name
22:42:29 <Crockeo> > tail $ reverse "haskell"
22:42:31 <lambdabot>   "leksah"
22:43:01 <shapr> Cute, I hadn't noticed that!
22:44:07 <Crockeo> I didn't either when I was told about it
22:44:23 <Crockeo> then my post-12 mind had one of its rare realizations.
22:45:29 <shachaf> @quote leksah
22:45:29 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
22:45:34 <shachaf> @quote leksah
22:45:35 <lambdabot> geheimdienst says: ah, yes. now we have to make a lambdacat captioned "kittehs no bery gud at speling. we says leksah fur lexer and monad fur moniod in catagory of ennobunktors"
22:45:44 <shachaf> Eh.
22:52:43 <oajsdoas> ...
22:52:50 <oajsdoas> hi
23:01:03 <lispy> Once I noticed that about the name of Leksah, I wanted it to be spelled Lleksah
23:01:25 <lispy> But, I supposed dropping an L makes a certain amount of sense
23:02:02 <Crockeo> lispy: It makes it look better, but I still would've preferred it being Lleksah.
23:03:42 <lispy> another good IDE name might be cohaskell
23:05:10 <lispy> (because the IDE would be dual to Haskell, not that I think people need IDEs)
23:07:21 <Crockeo> 'One day I tried to learn Haskell and failed. Now I just fumble around until something works hoping that one day I wake up knowing how to use Haskell."
23:07:35 <shapr> What? http://arstechnica.com/information-technology/2012/11/how-is-lazy-evaluation-in-haskell-useful/
23:07:37 <Crockeo> That's not a direct quote (meant to do another ' at the end) but I feel like that properly illustrates my experience with Haskell so far.
23:08:19 <mm_freak_> Crockeo: write an actual application in haskell
23:08:27 <mm_freak_> something useful
23:08:49 <Crockeo> mm_freak_: I'm thinking about writing a simple game, but I've no ideas :P
23:08:52 <mm_freak_> doesn't have to be big, just useful
23:09:06 <mm_freak_> no, don't start with a game…  start with a command line utility
23:09:16 <Crockeo> Well, I already did cat :P
23:09:38 <Crockeo> Maybe now I can try my hand at a version of wget.
23:10:25 <Crockeo> I've been wanting a windows implementation of wget for a little while now, so I may as well make one. (Instead of searching on Google and finding one after 5 minutes.)
23:10:26 <mm_freak_> yes, a very simple wget could be fun =)
23:11:24 <Crockeo> mm_freak_: Well then, off I go!
23:11:25 <mm_freak_> Crockeo: you might also write a program to find duplicate files or for doing something remote
23:11:41 <djahandarie> shachaf, if that was a "happy birthday", thanks :p
23:12:09 <Crockeo> mm_freak_: Maybe a sort of AI that evaluates a given photo and attempts to give it an accurate label... in maybe 5 years.
23:12:21 <mm_freak_> Crockeo: the point is:  you don't learn haskell through little experiments and project euler problems, only through actaul application development
23:12:33 <lispy> shapr: usually I like ars technica, but that article seemed to do a poor job of just linking to the real material
23:12:49 <Crockeo> Then I ought to start doing more actual application development-
23:12:50 <Crockeo> oh
23:13:06 <Crockeo> that reminds me, I made a little program to do a Caesar shift on a string.
23:13:31 * lispy read the type safe observable sharing paper and now realizes that would be a nice rewrite for the aterm package
23:19:36 <Crockeo> Wow. I wanted to buy a paperback copy of LYAH, but turns out they're ~$50
23:19:56 <Crockeo> I mean, if it were like $15, sure, but /$50/?
23:20:37 * shapr shrugs
23:20:46 <shapr> Paper doesn't grow on trees!
23:20:58 <shapr> Ok, actually it does.
23:21:42 <Ghoul_> Can someone explain to me the definition of mkDList at http://www.haskell.org/haskellwiki/Tying_the_Knot
23:21:52 <Ghoul_> I don't understand what's going on..
23:24:33 <Ghoul_> please and thankyou :)
23:25:49 <shapr> Ghoul_: What parts of tying the knot do you understand?
23:27:01 <Sonarpulse> does anybody know how to use the CmdLib package?
23:27:19 <Sonarpulse> (System.Console.CmdLib)
23:28:20 <Ghoul_> shapr: just the definition of mkDList
23:28:38 <Ghoul_> mkDList xs = let (first,last) = go last xs firs in  first
23:29:03 <shachaf> djahandarie: Yep!
23:39:40 <shapr> Ghoul_: mkDList is setting final values that have not yet been calculated, and lazy evaluation means that works.
23:40:10 <Ghoul_> shapr: hmm, thanks.
23:40:43 <Crockeo> Is there a way to easily return a modified list? Like, not appending, but returning a list with a changed element at a given index.
23:41:56 <Crockeo> Not even wanting to apply a function to an element, just sort of getting a changed element.
23:42:08 <shapr> Crockeo: foo (x:xs) = 1:xs
23:42:37 <Crockeo> Is there a way to do that at any given index, or do I just have to parse through the list?
23:42:55 <Ralith_> you could use lenses
23:42:55 <shapr> :t (!)
23:42:57 <lambdabot> Ix i => Array i e -> i -> e
23:43:04 <shapr> :t (!!)
23:43:06 <lambdabot> [a] -> Int -> a
23:43:22 <shapr> Crockeo: try building it manually at first
23:43:35 <Crockeo> shapr: Alright, off I go!
23:43:37 <Ralith_> hey shachaf how do you do that with lenses
23:43:39 <edwardk> > [1,2,3,4,5] & element 3 .~ 12
23:43:42 <lambdabot>   [1,2,3,12,5]
23:43:46 <Ralith_> oh right I already pinged edwardk
23:43:47 <Ralith_> :D
23:43:52 <edwardk> =P
23:43:56 <shapr> Hm, maybe I should learn them lens things.
23:44:06 <shapr> Mebbe over winter break when I have enough time to sleep.
23:44:21 <shachaf> Ralith_: Or you can use upon!
23:44:25 <shachaf> (Don't use upon.)
23:44:28 <shachaf> (But you could!)
23:44:34 <Ralith_> @_@
23:44:49 <mgsloan> use uponTheDeep!
23:45:05 <shachaf> Don't use uponTheDeep!
23:45:10 <mgsloan> > [1,2,3,4,5] & uponTheDeep (!!3) .~ 12
23:45:12 <lambdabot>   Not in scope: `uponTheDeep'
23:45:18 <mgsloan> sooon :)
23:47:14 <edwardk> that works fine with upon
