00:00:26 <Saizan> e.g. managing import lists can be a chore
00:00:37 <Superbest> lolcathost, well that's encouraging, but I also find it helpful when my IDE has a concept of a "project", a debugger, a unit testing interface, code completion, build profiles and similar things
00:00:50 <Superbest> I dunno if any of these are irrelevant for haskell though
00:06:37 <lpvb> Superbest: haskell has hoogle, hayoo, cabal build files (which are simple), ghci interpreter with debugger and autocompletion, testing tools (quickcheck), vim and emacs have autocompletion via plugins like haskell-mode, and there is eclipsefp if you're ardent about IDEs
00:08:39 <lpvb> there is a haskell IDE made in haskell called leksah, but I've never gotten it to build, and a new IDE in the works by the yesod team: www.yesodweb.com/blog/2012/09/building-haskell-ide
00:09:05 <pyykkis> Superbest: I'd start with your favorite text editor (mine is Sublime Text 2) and see later if I need something like IDE
00:11:04 <startling> is there a standard way to declare a set of tests for quickcheck et al?
00:12:12 <pyykkis> Superbest: there's a learning curve in the language itself. For me, it's easier to grasp things one at a time.
00:12:30 <Saizan> startling: test-framework on hackage should be relevant
00:12:31 <Superbest> I see
00:13:33 <Superbest> Well from what I can tell the visual haskell was the most promising concept, but hasn't been updated in a year and half, so I guess I'll end up using the eclipse one after I'm done torturing myself with a text editor
00:13:55 <Superbest> Also yes I know, some people manage without ides but I'm very lazy
00:14:32 * hackagebot wizards 1.0.1 - High level, generic library for interrogative user interfaces  http://hackage.haskell.org/package/wizards-1.0.1 (LiamOConnorDavis)
00:15:37 <efie> why is it recommended to use STVector rather than IOVector in most cases?
00:15:47 <neworder> let f x = (let g y = x + y in g) in (f 3) 5
00:15:52 <neworder> In this function
00:16:04 <efie> from Data.Vector.Unboxed.Mutable
00:16:10 <neworder> f takes an argument 3 first
00:16:54 <neworder> so it becomes f 3 = (let g y = 3 + y in g)
00:17:00 <startling> efie, presumably because you can call into it from non-IO code
00:17:15 <neworder> after that, how come the 5 gets passed to y
00:17:25 <neworder> I mean binded to y
00:18:02 <Cale> neworder: because f 3 is the function g, which is defined by g y = 3 + y
00:18:16 <Cale> and we're applying this function f 3 to the value 5
00:18:42 <Cale> So we get g 5
00:18:45 <neworder> Ah I see
00:18:50 <efie> startling: is there also a difference in speed?
00:19:40 <startling> efie, dunno, I'd say they'd be pretty similar
00:20:31 <efie> startling: thanks
00:21:33 <startling> I imagine most of ST is type shenanigans
00:21:59 <shachaf> St. Type Shenanigans
00:22:13 <shachaf> Oleg, patron saint of type shenanigans?
00:22:56 <c_wraith> ST is limited-functionality IO with type shenanigans
00:25:22 <efie> what are type shenanigans?
00:25:31 <c_wraith> :t runST
00:25:33 <lambdabot> forall a. (forall s. ST s a) -> a
00:26:00 <Cale> Basically, there's some type-level stuff which ensures that the effects are limited in scope to the inside of the single call to runST
00:26:30 <efie> ah ok
00:27:08 <Cale> and that the result is really a value that doesn't contain any of the mutable cells you're allowed to create in ST
00:28:29 <Cale> Basically, that says you have to pass runST a computation which is polymorphic in this s type parameter, and that the type a is chosen without knowledge of this s, so can't involve it in any way. That s type parameter also gets attached to all the STRefs and STArrays and so on
00:29:32 <Cale> You can think of it as the user of runST gets to pick the type a, but runST gets to pick the type s
00:29:40 <Saizan> (tbf that type a could be an existential over the s, letting you take STRef's and whatnot outside, but they'd be mostly useless)
00:30:00 <Cale> yes, if you smuggle them out, you still can't use them
00:30:16 <Cale> because you won't be able to prove from another call to runST that the s types match
00:30:43 <c_wraith> I'm interested in FFI uses of ST.  There are some native libs that would fit perfectly into the ST pattern.
00:30:54 <c_wraith> And I know the tooling exists to make it work.
00:31:12 <c_wraith> But I always forget to try
00:31:35 <Jafet> Just unsafe ccall everything and wrap it into ST
00:31:53 <c_wraith> unsafe/safe is irrelevant
00:32:11 <c_wraith> (and you should really only use unsafe if you know exactly what it means)
00:32:36 <Cale> ST is one of those things that gave me a lot of comfort knowing that it existed when I was just starting to learn Haskell, but I've never actually really needed it for much of anything.
00:33:27 <c_wraith> I've used it for optimizing code with a pure interface.  Managed to get RC4 code to stop allocating, significantly speeding it up.
00:35:21 <Jafet> Unfortunately, unsafePerformIO isn't unsafe often enough for me to want to use ST more.
00:38:50 <c_wraith> time for everyone to start putting weird effects in their IO actions to make Jafet feel more uncomfortable!
00:40:15 <Jafet> Yeah, try accessing more global state or using STM or something, that'll teach me
00:41:14 <Jafet> Are you suggesting to add the option to import with ST types?
00:43:59 <c_wraith> nah, imports with IO types.  But have the module export an ST interface created with calls to unsafeIOToST
00:44:38 <c_wraith> and have whatever intermediate types exist have an extra type variable so they are kept from escaping by the standard mechanism
00:45:12 <c_wraith> it would work for things like digest algorithms particularly well
00:45:52 <c_wraith> Or any other code that allocates an intermediate mutable structure that you make multiple calls with
00:46:50 <Jafet> Is there any wrapper using this approach?
00:49:02 <c_wraith> you might argue that Vector itself is sort of one.  But I can't think of anything else.
00:51:51 <Jafet> I didn't know vector used the ffi.
00:52:03 <c_wraith> it uses primops instead
00:52:16 <c_wraith> but really, that's not all that different :)
00:54:06 <osa1> I'm trying to understand how does `instance Monad t => Applicative t where ...` actually mean "every applicative is a monad", can anyone explain my how does instance declarations work ?
00:54:27 <Jafet> It defines an instance of Applicative for every instance of Monad.
00:54:33 <c_wraith> actually, that's declaring that every type is an instance of Applicative
00:54:52 <Jafet> Given any Monad t, that instance tells you how to make an Applicative t.
00:55:03 <c_wraith> And then adding an extra constraint afterwards that if you use it as an Applicative, it needs to also be a Monad
00:55:33 <Jafet> That's an instance c_wraith, not a class
00:55:52 <osa1> I'm confused ..
00:55:56 <c_wraith> Jafet: yes.  and the isntance head is forall t :: * -> *
00:55:59 <c_wraith> *instance
00:56:21 <c_wraith> Jafet: that declares that every type with the correct kind is an instance of Applicative.
00:56:29 <c_wraith> Jafet: the constraint doesn't limit that.
00:57:02 <osa1> so what would be a correct solution ? `instance Applicative (Monad t) where ...` ?
00:57:07 <Jafet> Okay, I don't like that way of explaining it
00:57:17 <c_wraith> That's the way GHC actually works, though
00:57:25 <Jafet> You are right
00:57:35 <c_wraith> If you don't think of it that way, you'll be very confused by the error messages you will inevitably get
00:58:14 <Jafet> Heh, I usually ignore everything past the line number.
00:58:28 <c_wraith> osa1: what I think you're trying to say doesn't have a clean expression in haskell, because of issues with overlapping instances
00:58:30 <osa1> so what does constraint part do if it doesn't actually constrain instances ?
00:58:42 <shachaf> Well, knowing that unification happens before instance resolution can help you get better line numbers.
00:58:44 <c_wraith> osa1: it adds that constraint to any place that uses the instance
00:58:47 <shachaf> Like lens does. :-)
00:59:06 <edwardk> =)
00:59:42 <Jafet> Wait, you didn't say "ed" shachaf
00:59:43 <osa1> c_wraith: hmm. so if I want that code to work, every type have to be an instance of Monad, is it correct ?
00:59:51 <Jafet> I don't get it
01:00:01 <c_wraith> Jafet: edwardk has a trigger on "lens", too
01:00:02 <shachaf> ed
01:00:51 <c_wraith> osa1: Not every type - just every type that you use the Applicative instance for.
01:01:03 <c_wraith> osa1: it doesn't bother searching for instances that aren't used
01:01:35 <osa1> hmm I think I finally get it. thanks.
01:02:18 <sp3ctum> i'm trying to learn xml parsing with HXT, and find it curious that by default the xml trees are wrapped in IO. is it a good practice to keep handlers of this tree in IO as well, or should I extract the contents and process them with something pure?
01:02:21 <c_wraith> osa1: the major problem with doing something like that is if you ever want a custom instance for a type, you end up with overlapping instances.  And that's one of the more dangerous extensions in common use
01:02:27 <Jafet> @type return ?f <*> return ?x
01:02:29 <lambdabot> forall (f :: * -> *) a b. (?f::a -> b, ?x::a, Monad f, Applicative f) => f b
01:02:51 <ivanm> sp3ctum: I'm guessing (having never used HXT) that it's for laziness, so you can avoid having the entire XML tree in memory at once
01:06:43 <edwardk> =P
01:07:26 <edwardk> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
01:07:28 <lambdabot>   ("Jelly","world")
01:07:36 <edwardk> lambdabot zippers make me happy
01:07:42 <edwardk> @botsnack
01:07:42 <lambdabot> :)
01:08:35 <edwardk> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % up % focus %~ reverse % rezip
01:08:36 <lambdabot>   ("olleJ","world")
01:10:05 <edwardk> > zipper ("hello","world") % down _1 % focus.mapped %~ toUpper % rezip
01:10:07 <lambdabot>   ("HELLO","world")
01:10:35 <edwardk> :t uniplate
01:10:36 <lambdabot> on the commandline:
01:10:37 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:10:49 <edwardk> hrmm
01:10:54 <edwardk> :t biplate
01:10:56 <lambdabot> on the commandline:
01:10:56 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:11:15 <edwardk> @tell cale :t uniplate complains that  Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:11:15 <Jafet> > uniplate
01:11:16 <lambdabot> Consider it noted.
01:11:17 <lambdabot>   Ambiguous type variable `a0' in the constraint:
01:11:17 <lambdabot>    (Data.Data.Data a0) aris...
01:11:22 <shachaf> edwardk: We know.
01:11:24 <shachaf> @ty fmap
01:11:26 <lambdabot> on the commandline:
01:11:26 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:11:29 <shachaf> @ty (.)
01:11:30 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
01:11:31 <shachaf> It's very weird.
01:11:34 <shachaf> I can't figure it out.
01:11:39 <shachaf> @let blahblah = fmap
01:11:41 <lambdabot>  Defined.
01:11:41 <shachaf> @ty blahblah
01:11:43 <lambdabot> on the commandline:
01:11:43 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:11:47 <shachaf> @let (@#$%) = fmap
01:11:48 <lambdabot>  <local>:5:1:
01:11:48 <lambdabot>      Multiple declarations of `@#$%'
01:11:48 <lambdabot>      Declared at: <local>:...
01:11:57 <shachaf> Oh, it's left over.
01:11:59 <shachaf> @ty (@#$%)
01:12:01 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
01:12:11 <edwardk> > over biplate (reverse :: String -> String) ("hello","world",(),["nifty", "eh?"], 32 :: Int)
01:12:13 <lambdabot>   ("olleh","dlrow",(),["ytfin","?he"],32)
01:12:14 <shachaf> Somehow @ty for fmap only works for an infix symbol.
01:13:53 <edwardk> > ("hello","world",(),["nifty", "eh?"], 32 :: Int)^..biplate :: [String]
01:13:55 <lambdabot>   ["hello","world","nifty","eh?"]
01:14:35 * hackagebot snaplet-riak 0.2.0.0 - A Snaplet for the Riak database  http://hackage.haskell.org/package/snaplet-riak-0.2.0.0 (PaulWilson)
01:15:59 <Cale> edwardk: I haven't quite figured out what's causing that weirdness
01:16:00 <lambdabot> Cale: You have 1 new message. '/msg lambdabot @messages' to read it.
01:16:10 <edwardk> Cale: fair nuff
01:16:26 <Cale> watch:
01:16:28 <Cale> :t fmap
01:16:30 <lambdabot> on the commandline:
01:16:30 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:16:37 <Cale> @let foo = fmap
01:16:39 <lambdabot>  Defined.
01:16:40 <Cale> :t foo
01:16:41 <lambdabot> on the commandline:
01:16:42 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
01:16:46 <Cale> @let (!!!!!) = fmap
01:16:47 <lambdabot>  <local>:6:1:
01:16:47 <lambdabot>      Multiple declarations of `!!!!!'
01:16:47 <lambdabot>      Declared at: <local>...
01:16:51 <Cale> oh, der
01:16:53 <Cale> @undefine
01:16:55 <Cale> @let (!!!!!) = fmap
01:16:57 <lambdabot>  Defined.
01:17:01 <Cale> :t (!!!!!)
01:17:02 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
01:17:07 <edwardk> magic
01:17:07 <Cale> ^^ somehow, this is okay :P
01:17:40 <Jafet> Perhaps it should not use -fglasgow-exts.
01:18:57 <osa1> in this instance declaration: `class Add a b c | a b -> c where add :: a -> b -> c; instance Add a b c => Add (Succ a) b (Succ c)` c isn't matched against (Succ c), right ? because it is in right part of -> in functional dependency
01:20:09 <edwardk> osa1: there its the shapes of 'a and 'b' that matter for matching purposes, yes.
01:21:05 <edwardk> osa1: doing something like https://github.com/ekmett/type-int/blob/master/Data/Type/Binary/Internals.hs#L274 ?
01:23:03 <osa1> edwardk: I don't understand how does that work: `instance (TAddC' a b F d, TNF d d') => TAdd' a b d'` variable d doesn't mentioned in "instance head" (I think that's what it's called, I mean right part of => )
01:24:16 <edwardk> a b F determine d, using the fundep from TAddC,   a b  are in the instance head, so d is determined
01:24:32 <edwardk> that means d' is determined since class TNF x y | x -> y
01:24:56 <edwardk> so TAdd' a b d'   meets the requirement that d' is determined by a and b
01:25:14 <hpaste> “efie ” pasted “why slows my use of mutable vectors this program down?” at http://hpaste.org/77189
01:25:56 <edwardk> the variables don't have to appear directly in the instance head, just in a fundep or type family of things determined by the instance head
01:28:37 <osa1> hmm, that explains. so determined variables do not have to be in instance head. still d' is in instance head and it's strange to me because it's also determined from d.
01:29:07 <edwardk>  d' is on the right side of a fundep in the head
01:29:14 <edwardk> its an obligation
01:30:06 <osa1> aha
01:31:11 <edwardk> you can get pretty tricky with these
01:31:15 <edwardk> class TAdd a b c | a b -> c, a c -> b, b c -> a; instance (TAdd' a b c, TNeg b b', TAdd' c b' a, TNeg a a', TAdd' c a' b) => TAdd a b c
01:31:37 <edwardk> there i have 3 fundeps, so i need to make sure everything is mutually decidable
01:31:47 <edwardk> given any 2 i should be able to calculate the remaining one
01:33:35 <osa1> edwardk: wow, thanks. maybe I should study this module.
01:33:49 <Jafet> modify v i p = do v' <- GV.unsafeThaw v; MV.write v' i p; GV.unsafeFreeze v' :: IO (V.Vector Float)
01:34:00 <Jafet> efie: just what do you think you are doing dave?
01:34:18 <edwardk> TAdd'  provides the a b -> c   fundep, but to work from a c -> b we need to negate a and add it to c, or work from b c -> a we need to negate b to get b' , and then add that to c. if you have any one of those fundeps you'll have all 3 a b c values, so you can satisfy those remaining 3-4 constraints once you can flow information from any one of them
01:34:50 <edwardk> osa1: keep in mind this code is ancient. it still compiles, but i'd probably use a lot of type families, etc. in there now. they just didn't exist when i wrote that
01:35:19 <edwardk> also if you are working with natural numbers rather than 2s complement integers like i have there then some of the directions won't work.
01:35:20 <osa1> edwardk: I think it's even better to me because I have no idea about type families, I just started learning type-level stuff ..
01:35:59 <efie> Jafet: umm I have to turn the vector into a mutable vector, modify it, and then turn it back, don't I?
01:36:33 <Jafet> I'm surprised your program doesn't dump core.
01:36:36 <edwardk> i do like that TAdd in that is able to flow in all 3 directions. that made me happy
01:36:45 <edwardk> that is one thing the type family version can't do
01:37:24 <Jafet> Why are you trying to modify an immutable vector?
01:39:15 <efie> Jafet: I thought this how using mutable vectors work... taking "pure" vectors, modifying them, and making them pure again :/
01:39:45 <edwardk> efie: you can 'thaw' just don't 'unsafeThaw'
01:40:17 <shachaf> Did you know C vectors are pure too, between lines of code?
01:40:37 <efie> edwark: ok, but this will make it even slower
01:40:39 <edwardk> efie: unsafeThaw really is. if there are _any_ references to the original frozen vector, they are now given pretty much undefined behavior
01:40:44 <edwardk> efie: well, yes
01:41:08 <Jafet> C has vectors?
01:41:08 <edwardk> but in general if you don't know why you can safely unsafeThaw in a given situation, you probably can't
01:41:50 <edwardk> what code is expecting immutable vectors?
01:43:18 <edwardk> if you want speed and are working with mutable vectors, stay in mutable vectors. pass it to a function that expects a mutable vector and which pays the syntactic overhead for accessing it through IO, etc.
01:43:42 <edwardk> its ugly, its painful, it sucks, its also the way to ensure its correct
01:44:04 <Jafet> You can unsafeFreeze a mutable vector
01:44:13 <Jafet> and continue modifying it later
01:44:19 <Jafet> I think
01:45:08 <edwardk> Jafet: if you unsafeFreeze it and modify it later, then your previously unsafelyFrozen vector now has undefined contents. it may see your original contents, or your new ones
01:45:19 <edwardk> it is only safe to unsafeFreeze when you won't change it any more after
01:45:26 <Jafet> Yes, the frozen version goes stale
01:46:11 <edwardk> the main issue is its very hard in practice to rule out that something got captured in a thunk anywhere
01:46:36 <efie> edwardk: ok, so I best
01:46:38 <efie> ups
01:46:41 <Jafet> efie: since your code currently does something which isn't just unsafe but probably totally meaningless as far as vector is concerned and it is allowed to do anything including call threadDelay at random
01:46:45 <edwardk> if something is just a smidge lazier than you think its easy to fool yourself into thinking your code is correct
01:46:57 <Jafet> it's probably not a good idea to talk about its performance onw
01:48:00 <Palmik> Hmm, is type family instance defined or declared?
01:48:01 <efie> so I should drop Data.Vector.Unboxed and only use Data.Vector.Unboxed.Mutable if I want mutable vectors?
01:48:12 <edwardk> efie: probably
01:48:28 <edwardk> efie: this is why vector-algorithms mostly works with mutable vectors even for its immutable algorithms
01:49:05 <Palmik> And is type family defined or declared.
01:49:45 <Jafet> What is the difference between those two words, Palmik?
01:50:33 <Palmik> Jafet, well, I'm sure myself -- but I believe thay are not always interchangable.
01:50:56 <efie> edwardk: Jafet: thanks
01:51:32 <Jafet> Also, if you want to ask again, you should post complete programs.
01:52:10 <Palmik> That is: is "type family F x"/"data family F x" declaraion of definition? And is "type instance F Int = Int"/"data instance F Int = Foo Int" definition or declaration?
01:52:44 <shachaf> Why does it matter?
01:52:54 <Jafet> Palmik: some languages have a formal distinction between those words. Haskell doesn't
01:53:01 <Palmik> Well, I would like to use correct terminology.
01:53:08 <Palmik> Jafet, OK, thanks.
01:55:45 <Cale> Palmik: Yeah, there's no formal distinction between "declaration" and "definition". I think I would use the word "declaration" a bit more often if I was referring to the actual piece of syntax, and "definition" if I wanted to emphasise the construction of the actual thing being defined.
01:57:22 <edwardk> my understanding mirrors cale's. if i'm being pedantic i might try to distinguish between declaration for syntax and definition for semantics, but i rarely am that pedantic
01:58:28 <arbn> edwardk: You mean if you *were* being pedantic. :P
01:58:46 <edwardk> =P
02:01:08 <Palmik> Thank you guys. :)
02:01:25 <arbn> I find it interesting that, instead of trying to bring HOC back from the dead, every few months, someone makes a blog post about a new Haskell-ObjC interface they're writing, which they work on for exactly one week, and then abandon.
02:01:48 <edwardk> arbn: i did the same thing, sans the blog post ;)
02:02:08 <edwardk> arbn: there is little about HOC's design that inspires love
02:02:51 <edwardk> there is the #haskell-objc channel which is mostly empty these days
02:03:12 <edwardk> mokus has been working on hoc again (or at least was for a while)
02:03:19 <arbn> edwardk: Hmm. You think starting from scratch would be the right way to go? I'm kind of itching to work on a Haskell-ObjC interop project, or at least move in that direction.
02:03:49 <edwardk> in the meantime i went off and did some greenfield work on my own but i wound up avoiding the need for it in the end so i dropped it
02:04:20 <Jafet> Why Objective-C?
02:04:36 <edwardk> https://github.com/ekmett/objective-c and https://github.com/ekmett/foreign are my little aborted self-started projects.
02:05:21 <Palmik> Jafet, iPhone/iPad frontend development would be my guess.
02:05:23 <edwardk> Jafet: i'm on a mac, and i'd like to have an app can provide a nice opengl interface, but still offers the bells and whistles of a native interface. you know the menu acts like a real mac menu, etc.
02:05:53 <arbn> Jafet: Cocoa. It's the right choice for many applications, but Objective-C is... the anti-Haskell. Absurdly unsafe and mutability everywhere, so it'd be great to have Cocoa available through layers of Haskell.
02:06:19 <Jafet> Okay.
02:06:36 <Jafet> How is the mythical haskell phone game development, going, anyway
02:06:41 <edwardk> basically i spent all my effort learning my way around the interop needs for objective-c and then got bored with it when i started working through the issues with how to talk to it from 64 bit haskell. (there are some issues with haskell ffi and serializing structs that fit into a 64 bit int)
02:07:15 <edwardk> Jafet: well, ipwn seems to have quietly shutdown shop, while everyone took paying gigs elsewhere, so its not moving along very fast ;)
02:07:23 <Cale> Jafet: That's on hold now, though we have a fair amount of the game done, so it's a little bit sad not to have something to sell.
02:09:37 <ManateeLazyCat> Cale: hey, how are you?
02:11:21 <Cale> hello
02:11:30 <Cale> I'm reasonably well :)
02:13:54 <arcatan> i'm http://www.shastaconservationfund.org/wishing_well2.jpg
02:14:08 <ManateeLazyCat> Cale: I haven't login here long time.
02:14:17 <ManateeLazyCat> Cale: Missing haskell time. :P
02:15:12 <Cale> ManateeLazyCat: Been busy with other stuff?
02:15:39 <ManateeLazyCat> Cale: Yep, i'm busy on linuxdeepin.com,
02:16:11 <ManateeLazyCat> Cale: this project eat much time. :)
02:16:47 <arbn> ManateeLazyCat: Oh, hey. You must be the developer of manatee. :)
02:17:05 <ManateeLazyCat> arbn: Yep.
02:19:27 <pommes_> After creating a new yesod project I changed to the project directory and wanted to install the dependencieswith "cabal install, but I got the following error: http://hpaste.org/77177   It looks like a version mismatch. How do I fix that? At the moment base-4.6.0.0 is installed
02:20:37 <arbn> pommes_: I'd really, really, REALLY suggest you use cabal-dev for Yesod projects.
02:20:38 <ivanm> pommes_: yeah, shephard seems out of date
02:21:52 <neutrino_> hi
02:21:56 <arbn> pommes_: Just use cabal-dev to install yesod-platform inside the project-specific package dir, and then you're good to go.
02:22:21 <neutrino_> i am trying to run Elm. i have created the "main = lift asText Mouse.position" demo and can run the server, but when i click on main.elm i get a blank page which does nothing.
02:22:27 <neutrino_> i get no errors in the console.
02:24:03 <Cale> pommes_: ghc-pkg list directory -- which version do you have?
02:24:06 <arbn> ManateeLazyCat: So, what happened to manatee? Are you still interested in it, someday?
02:24:33 <Cale> pommes_: You won't want to reinstall that package, most likely, but adapt whatever code you're trying to build to whatever version you have
02:24:48 <pommes_> /usr/lib/ghc-7.6.1/package.conf.d
02:24:48 <pommes_>    directory-1.2.0.0
02:24:48 <pommes_> /home/rails/.ghc/x86_64-linux-7.6.1/package.conf.d
02:25:25 <Cale> pommes_: right, so it's this constraint directory>=1.1 && <1.2
02:25:43 <Cale> pommes_: maybe open up your .cabal file and just relax the upper version constraint?
02:26:28 <Cale> (Was it auto-generated somehow by yesod?)
02:26:32 * neutrino_ . . o O (Haskell On Rails)
02:28:11 <gienah> arbn: ManateeLazyCat there were incompatible API changes to dbus-core dbus-client , then these pkgs were massively changed again and renamed to dbus, and now dbus is changed again so *maybe* it might now be possible to port manatee to the latest dbus API
02:28:15 <pommes_> yes, it was all done from yesod
02:28:18 <Cale> Is Yesod updated for GHC 7.6 yet?
02:28:57 <pommes_> it should be as I installed it with cabal
02:29:27 <Cale> pommes_: Well, maybe it builds but some of the tools aren't quite right for 7.6 yet
02:29:36 <Cale> I dunno
02:29:49 <Cale> (I haven't actually used yesod myself)
02:29:51 <neutrino_> i have tried installing elm with "cabal install elm --constrain="containers==0.4.1.0" --reinstall"; however, it says "zip-archive-0.1.1.8 failed during the building phase. The exception was: ExitFailure 1". But if I install zip-archive-0.1.1.8 on its own it completes. what can i do about this?
02:30:12 <Cale> neutrino_: weird
02:30:23 <Cale> neutrino_: and it dies like that consistently?
02:30:27 <neutrino_> yes
02:30:33 <pommes_> ok, thx, I am at the moment trying to get it working by relaxing the version constriant
02:31:08 <ivanm> neutrino_: my guess is there's some weird combination of deps/flags that comes into play
02:31:12 <ivanm> try with --verbose=3 ?
02:31:16 <neutrino_> ok let me try
02:39:24 <hpaste> neutrino pasted “installing elm fails” at http://hpaste.org/77190
02:39:53 <neutrino_> ivanm, Cale ^
02:42:07 <ivanm> possibly some FFI problem?
02:42:40 <neutrino_> i don't know :(
02:42:58 <ivanm> neutrino_: it's a containers issue
02:43:06 <ivanm> you seem to have somehow installed a newer version of containers
02:43:10 <neutrino_> i have
02:43:12 <ivanm> which is highly recommended against
02:43:15 <neutrino_> should i uninstall it?
02:43:20 <ivanm> yes
02:43:29 <neutrino_> i thought different versions of the same package could coexist
02:43:32 <neutrino_> was i mistaken?
02:43:44 <ivanm> don't install newer versions of boot packages
02:43:52 <neutrino_> what's a boot package?
02:43:53 <ivanm> if it comes with GHC and isn't called "Cabal", don't upgrade it
02:44:23 <Cale> neutrino_: They can coexist, but you'll start ending up with packages which are built against two different versions of some base package and then those can't be used together
02:44:30 <neutrino_> i didn't realize it came with ghc
02:44:31 <Cale> neutrino_: and all sorts of weird things happen
02:44:54 <neutrino_> i just did "cabal install elm" and that apparently pulled in a newer "containers"
02:45:18 <Palmik> Could someone look at this short (part of) a brief introduction to type families (indended audience knows vanilla haskell): http://codepad.org/Qjt9qALY -- if you spot any technical errors or stylistic ones, let me know, please. (I for example am not really happy with "multiple instances can map two sets of distinct type arguments to the same type" and the fact that the last sentence is so long). Bear in mind that this is a just a part of the
02:45:20 <Palmik> introduction -- in its completeness it will be acompanied with examples.
02:45:35 <neutrino_> how do i uninstall a package? cabal --help doesn't seem to mention that. do i use ghc-pkg unregister?
02:45:47 <ivanm> yes
02:46:35 <Cale> Palmik: I'm not sure I'd say it's ad-hoc polymorphism on the type level. After all, the analogue to that would be letting you define a type multiple times at different kinds, and selecting between them based on how it was used.
02:47:11 <Cale> (like, defining a bunch of types with the same name and a different number of type parameters)
02:47:31 <neutrino_> so if i have ghc 7.4.1, then containers 0.4.2.1 is "newer"?
02:48:59 <neutrino_> i am guessing the version that comes with ghc 7.4.1 is 0.4.1.0 ? (i also have 0.4.1.0 installed)
02:49:09 <ivanm> probably
02:49:16 <ivanm> 0.4.2.1 comes with 7.4.2
02:49:20 <neutrino_> hmm how can i check this?
02:49:41 * hackagebot websockets 0.7.0.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.7.0.1 (JasperVanDerJeugt)
02:49:50 <ivanm> look up release notes for GHC 7.4.1?
02:51:01 <neutrino_> oh, ok. i tried searching in haskell-platform but i guess containers comes with ghc itself, not platform
02:52:14 <ivanm> yeah
02:52:23 <neutrino_> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/release-7-4-1.html
02:52:32 <neutrino_> this says 7.4.1 comes with 0.4.2.1
02:52:48 <neutrino_> however, elm is said not to work with anything newer than 0.4.1.0
02:53:21 <gienah> neutrino_: ghc-pkg list containers # says which version(s) you have
02:54:04 <ivanm> gienah: yeah, but doesn't say which version came with GHC
02:54:04 <gienah> neutrino_: yeah but a lot of the time upper bounds are just guesses that were made before the deps were bumped
02:54:13 <ivanm> neutrino_: ugh, so it tried to downgrade? :s
02:54:18 <gienah> ivanm: true
02:54:18 <Palmik> Cale, hmm, I guess you are right that it does not fit the definition of ad-hoc polymorphism if you lift it entirely (values -> types, types -> kinds). I guess I could leave this sentence out entirely.
02:54:24 <Palmik> that sentence
02:55:03 <Cale> Palmik: It *is* an analogue to open function definitions, though we don't exactly have those at the value level in Haskell.
02:55:45 <ivanm> neutrino_: which elm package are you trying to install? Elm or elm-server?
02:55:52 <Palmik> Cale, well -- type classes are as close as it gets in Haskell. But what are you getting at?
02:56:00 <ivanm> Elm says it just wants containers >= 0.3
02:56:01 <beaky> hello
02:56:04 <ivanm> unless it's some dep...
02:56:07 <ivanm> hi beaky
02:56:24 <neutrino_> ivanm: i am trying to install elm.
02:56:31 <neutrino_> ivanm: it installs fine without the added constraint.
02:56:43 <ivanm> neutrino_: there doesn't seem to be a package on hackage called "elm", just "Elm" :/
02:56:50 <ivanm> oh, so why did you add that constraint then?
02:56:50 <gienah> ivanm: maybe: ghc-pkg list --global containers # if its global then it came with ghc unless the user installed another containers globally
02:56:55 <neutrino_> the manual says "Elm does not appear to work with the latest versions of containers (i.e. 0.4.2.*). I know it works with earlier versions of containers, so to avoid this problem, you can try: cabal install elm --constrain="containers==0.4.1.0" --force-reinstall"
02:57:02 <osa1> can anyone recommend me a library to implement a prettyprinter ? I have a parser for a language and now I want to implement a prettyprinter too. how does Text.PrettyPrint do ?
02:57:05 <ivanm> OK, that's just stupid
02:57:14 <beaky> what is a prettyprinter
02:57:15 <neutrino_> well
02:57:23 <ivanm> osa1: there's Text.PrettyPrint, but it's a bit fugly
02:57:25 <neutrino_> the issue is, i installed elm and elm-server and they didn't work
02:57:37 <neutrino_> even though they installed without errors
02:57:40 <osa1> ivanm: any better alternatives ?
02:57:42 <ivanm> osa1: if you're using Text, there's wl-pprint-text (which I wrote)
02:58:17 <neutrino_> i would get a server screen showing the different .elm files, but when i clicked on one of them it gave me a blank screen.
02:58:19 <ivanm> wl-pprint uses Strings, but it doesn't deal all that well with indentation stuff (that I fixed in -text)
02:58:21 <Palmik> Cale, even "Type Checking with Open Type Functions" draws the parallel between type families and type classes (although I directly do not in that part of the introduction)
02:58:47 <ivanm> neutrino_: huh; you'd think they'd fix that at some point; the project can't be dead if they keep putting blog posts on reddit about it! :p
02:58:54 <neutrino_> ivanm, search for "Mouse.position" here, this code is what i executed: https://github.com/evancz/Elm/blob/master/README.md#elm
02:58:58 <neutrino_> bash snippet
03:00:07 <neutrino_> see if it works for you?
03:00:13 <ivanm> @slap github
03:00:13 * lambdabot would never hurt github!
03:00:17 <ivanm> grrrrr
03:00:37 <ivanm> I accidentally left focus on there instead of in IRC and started typing... and it thought I wanted to edit something so it forked the repo :@
03:00:38 <neutrino_> i know, but i'm trying to get this thing running :)
03:00:51 <neutrino_> oh crap
03:00:53 <neutrino_> haha
03:01:02 <ivanm> neutrino_: that to mea reads like they have nfi what they're talking about
03:01:04 <neutrino_> well, i think i might be able to use elm in my work
03:01:13 <ivanm> forcing usage of an older containers is ridiculous
03:01:15 <neutrino_> that's why i want to check it out
03:01:19 <neutrino_> mhm
03:01:32 <ivanm> neutrino_: "These problems all appeared before Elm version 0.1.1.4"
03:01:38 <ivanm> so... use a newer version! ;-)
03:01:48 <neutrino_> maybe it worked for one or two people though and that's why they put it in
03:02:02 <neutrino_> ivanm: i read it as "exist since Elm version 0.1.1.4"
03:02:14 <neutrino_> i am using the newest elm
03:02:22 <ivanm> oh? I read it as "this is no longer an issue"
03:02:24 <ivanm> *shrug*
03:03:11 <neutrino_> yeah, weird
03:03:23 <neutrino_> could you check if that demo works for you?
03:04:31 <ivanm> yeah, ummmm.... I'd prefer to pass thanks :)
03:09:36 <neutrino_> ok
03:09:40 <neutrino_> thanks anyways
03:12:12 <pommes_1> Cale: relaxing the constraints of directory and reinstalling the dependencies worked. Thx again for your help
03:19:43 * hackagebot linux-perf 0.3 - Read files generated by perf on Linux  http://hackage.haskell.org/package/linux-perf-0.3 (MikolajKonarski)
03:40:50 <LambdaDusk> "mid a b c = max a $ min b c" I am sure something is wrong there
03:42:10 <Jafet> This function is normally called clamp.
03:42:27 <LambdaDusk> jafet: it is? is it correct?
03:42:59 <Jafet> I don't know. What is correct?
03:43:02 <otterdam> A is the smallest permitted value, b is the largest permitted value, c is the input
03:43:09 <otterdam> If it were clamp
03:43:36 <Tinctorius> Can anyone help me finding kind (or sort) BOX? I'm trying to work with PolyKinds, but I have no idea where to import BOX from...
03:44:30 <Jafet> I've never heard of BOX, what is it?
03:45:16 <espringe> > print "hi\nthere"
03:45:17 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
03:45:17 <lambdabot>    arising from a use of ...
03:45:34 <espringe> What's the escape sequence for a newline? (if I don't want to escape the end-of-line itself
03:45:38 <espringe> \n doesn't seem to work
03:45:40 <Tinctorius> Jafet: it's the type of kinds; so it's the (only) sort in haskell
03:46:00 <beaky> > "hi\nthere"
03:46:02 <lambdabot>   "hi\nthere"
03:46:11 <Jafet> I believe the sort is **...
03:46:13 <LambdaDusk> otterdam: So the function is incorrect when I put the value as "b"?
03:46:20 <espringe> > length "\n"
03:46:22 <lambdabot>   1
03:46:51 <Tinctorius> Jafet: as I understand it, you have (* :: BOX) and ((->) :: BOX -> BOX -> BOX) on the kind level.
03:47:55 <merijn> espringe: Why wouldn't "\n" work?
03:48:08 <Tinctorius> Jafet: if you also enable DataKinds, you can lift Haskell98 datatypes to kinds, and their constructor are suddenly phantom types of that kind.
03:48:10 <merijn> espringe: Oh, wait. You're using print?
03:48:18 <merijn> espringe: *buzzer sound*
03:48:25 <merijn> espringe: What's the type of print? :)
03:48:31 <espringe> merijn: Yeah, it had me confused
03:48:49 <merijn> > show "\n"
03:48:50 <lambdabot>   "\"\\n\""
03:48:55 <espringe> I thought print would actually print the new-line itself
03:48:57 <espringe> but its escaping it
03:49:06 <merijn> espringe: print == "putStrLn . show"
03:49:11 <otterdam> LambdaDusk: It is correct both ways in fact
03:49:17 <Jafet> Tinctorius: but where are you seeing the name BOX?
03:49:25 <espringe> But using the 'length' function has convinced me that \n is actually working, so all is good in the world :D
03:49:48 <Jafet> Sort signatures are only being proposed: http://hackage.haskell.org/trac/ghc/wiki/KindSystem
03:49:48 <merijn> espringe: show convert data into a String (which can be read back) and thus escapes all special characters in the string
03:50:07 <Tinctorius> Jafet: it's part of PolyKinds. Whenever you use a kind variable, e.g. in a type constructor, PolyKinds sneaks in a kind argument of sort BOX
03:50:09 <espringe> Makes sense, just had me confused
03:50:13 <merijn> espringe: If you want to write a string to a file/stdout you want to use putStrLn/hPutStrLn
03:50:18 <shachaf> Jafet: http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/kind-polymorphism-and-promotion.html
03:50:18 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
03:51:01 <Tinctorius> Jafet: for some reason, I have problems with this implicit addition of kind variables, so I have to add them explicitly, and to do so, I need box
03:51:06 <merijn> espringe: print just exists because things like "putStrLn (show 1)" is common enough to get it's own function :)
03:51:09 <Tinctorius> Jafet: see http://www.reddit.com/r/haskell/comments/12k5xi/dealing_with_implicit_kind_variables_in_polykinds/
03:51:10 <Jafet> Ok, I've never used kind variables
03:54:37 <Jafet> BOX is probably an internal detail, because I don't think ghc lets you write sort signatures yet.
03:54:43 <Jafet> But you can ask #ghc
03:56:54 <Tinctorius> Thanks for the hint, Jafet :)
04:09:51 <nand`> Philippa: re. higher order vs first class; -XLiberalTypeSynonyms in GHC is a great example - it allows higher order type synonyms, without making them first class types
04:13:53 <efie> could someone tell me what is wrong with this? http://hpaste.org/77193
04:14:18 <espringe> Jesus Christ. Wtf. Someone needs to nerf haskell. I just finished porting my scala parser to haskell, reasonable 1:1 translation (instead of scala's builtin parser, i'm using parsec though). This is the result:
04:14:18 <espringe> http://hpaste.org/77192
04:14:18 <espringe> It's taking 0.002s real time, to parse the same thing that's taking scala ~0.5 seconds (of which 0.3 are startup time)
04:14:42 <shachaf> Are you sure it's actually parsing?
04:14:46 <espringe> Yup
04:14:49 <espringe> I outputted the AST
04:15:50 <nand`> efie: that's do { ... return (f,s') : toIO r}, not do { ... } : toIO r
04:16:02 <nand`> I'm guessing your internet was to produce a list of IO actions?
04:16:04 <nand`> intent*
04:16:45 <Jafet> I hope that was uninternetional
04:17:30 <nand`> surely that can be factored out to ‘map’ and the function changed to (a, IO [b]) -> IO (a, [b]); and note that [b] being in a list is never used, so that can again be generalized to (a, IO b) -> IO (a, b); which also makes me suspect a possible generalization as (Monad m, Monad n) => m (n a) -> n (m a) since you're merely flipping the order of (,) a and IO
04:17:30 <Jafet> efie: you mean like, it doesn't use map?
04:17:34 <nand`> there's probably a function like that
04:17:38 <nand`> @hoogle m (n a) -> n (m a)
04:17:39 <lambdabot> Data.Traversable sequenceA :: (Traversable t, Applicative f) => t (f a) -> f (t a)
04:17:39 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
04:17:39 <lambdabot> Test.QuickCheck.Gen promote :: Monad m => m (Gen a) -> Gen (m a)
04:17:58 <nand`> great luck, (,) a should be traversable; and IO is definitely applicative
04:18:27 <nand`> :t map Data.Traversable.equence
04:18:29 <lambdabot>     Not in scope: `Data.Traversable.equence'
04:18:29 <lambdabot>     Perhaps you meant one of these:
04:18:29 <lambdabot>       `Data.Traversable.sequence' (imported from Data.Traversable),
04:18:29 <nand`> :t map Data.Traversable.sequence
04:18:31 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Monad m, Traversable t) => [t (m a)] -> [m (t a)]
04:18:45 <nand`> :t map Data.Traversable.sequence :: [(a, IO [b])] -> [IO (a, [b])]
04:18:46 <Jafet> @quote premature.generalisation
04:18:46 <lambdabot>     No instance for (Traversable ((,) a1))
04:18:46 <lambdabot>       arising from a use of `Data.Traversable.sequence'
04:18:46 <lambdabot>     Possible fix:
04:18:47 <lambdabot> ksf says: ...premature generalisation is the root of all procrastination.
04:19:01 <nand`> ugh, no instance for that? It should be somewhere
04:19:59 <Jafet> espringe: sometimes I feel that way when rewriting haskell code in C++.
04:20:57 <efie> nand: thanks
04:21:57 <espringe> I was expecting a ~10x improvement, not a ~100x  [And then haskell has virtually zero startup time, compared to the .3 seconds I'm seeing in scala]
04:22:02 <espringe> I'm a happy chappy
04:23:58 <Jafet> There used to be a strength combinator, but I can't find it any more.
04:24:03 <Jafet> :t strength
04:24:05 <lambdabot> Not in scope: `strength'
04:25:52 <nand`> http://hackage.haskell.org/packages/archive/unbound/latest/doc/html/Unbound-LocallyNameless-Ops.html#v:strength
04:25:54 <nand`> this one?
04:26:27 <Jafet> Yes, that's the one.
04:26:30 <nand`> there's a similar one in http://hackage.haskell.org/packages/archive/pointless-haskell/latest/doc/html/Generics-Pointless-MonadCombinators.html too
04:27:46 <nand`> @let strength (a, b) = fmap ((,) a) b
04:27:48 <lambdabot>  Defined.
04:28:01 <nand`> :t map strength :: [(a, IO [b])] -> [IO (a, [b])]
04:28:02 <lambdabot> forall a b. [(a, IO [b])] -> [IO (a, [b])]
04:28:07 <nand`> efie ^
04:37:59 <neutrino_> hi again
04:38:29 <neutrino_> ivanm, Cale: i have installed elm and elm-server in a fresh linux user, and it works there. how can i check what the difference is that breaks this?
04:39:03 <ivanm> check versions of every package it deps on?
04:39:05 <ivanm> *shrug*
04:40:54 <neutrino_> actually i'm doing exactly that, comparing ls -1A .cabal/lib for each
04:41:44 <neutrino_> this is weird, it's using an older version of Elm?
04:42:31 <Tinctorius> Jafet: It seems I misunderstood the cause of the problem. I was partially applying a type synonym, and LiberalTypeSynonyms saved my day.
04:42:47 <Tinctorius> but thanks for helping ^_^
04:43:25 <efie> nand: thanks again
04:43:30 <Jafet> Hm, so BOX is valid?
04:43:37 <Jafet> Or did you not need sort signatures.
04:43:39 <neutrino_> i may have forgotten to do "cabal update"
04:43:53 <neutrino_> or is it "may have forgot to"
04:46:01 <neutrino_> update and reinstalling elm and elm-server helped
04:46:02 <neutrino_> thanks a lot guys
04:46:03 <neutrino_> :))
04:46:07 <neutrino_> for rubber-ducking
04:46:22 <efie> I have a vector of type IOVector Float. What is the best way to sum all entries? Do I have to freeze it first, before I can sum?
04:48:48 <Jafet> Try, er, reading each entry and adding it to the sum.
04:49:37 <Jafet> Or, er, using sum from the vector library.
04:50:19 <efie> there is a sum for mutable vectors?
04:51:01 <shachaf> Jafet clearly doesn't like a challenge.
04:52:53 <Jafet> @hackage vector-algorithms
04:52:54 <lambdabot> http://hackage.haskell.org/package/vector-algorithms
04:53:09 <Jafet> shachaf: is that a challenge?
04:54:49 <fliip> Hello. In lambda calculus does (\xy.xy)(\y.yy) become \y.(\y.yy)y or \p.(\y.yy)p   ??
04:57:23 <Jafet> It is not \y.(\y.yy)y.
04:57:57 <Jafet> ...even though my interpreter thinks it is
04:58:02 <fliip> So you alpha convert y to \p.(\y.yy)p?
04:58:27 <fmap> aren't both terms the same?
04:58:38 <Jafet> Hmm
04:58:40 <fliip> I thought y was bound.
04:58:53 <fliip> and since the second y is in a different scope...
04:58:53 <Jafet> In this case they are
04:59:05 <fliip> They are?
04:59:20 <fliip> Are you sure?
04:59:38 <neutrino_> elm is really cool
04:59:57 <shachaf> They're both equivalent to \x.xx
05:00:02 <Jafet> @let eval=let e s@(_:'\\':v:'.':l)=let(x,')':t)=e$d l in(take 4 s++x++")",t);e('(':s)=let(x,t)=e s;(y,')':u)=e$d t in(a x y,u);e s=splitAt 1$d s;d=snd.span(==' ');a(_:'\\':v:_:l)s=let f x|x==v=s|1>0=[x]in fst.e$init l>>=f;a f x='(':f++" "++x++")" in e
05:00:04 <lambdabot>  Defined.
05:00:45 <Jafet> > eval "((\\y. ((\\y. (yy)) y) x)"
05:00:47 <lambdabot>   ("*Exception: <local>:3:34-48: Irrefutable pattern failed for pattern (x, '...
05:00:56 <Jafet> Oops
05:01:09 <shachaf> fliip: You should get an example where they're not the same. :-)
05:01:34 <fliip> How would I do that?
05:01:45 <shachaf> I don't know. What are you trying to do?
05:01:47 <Jafet> > eval "((\\y. ((\\y. (y y)) y)) x)"
05:01:49 <lambdabot>   ("(x x)","")
05:01:52 <Jafet> > eval "((\\p. ((\\y. (y y)) p)) x)"
05:01:54 <lambdabot>   ("(x x)","")
05:02:25 <fliip> Ok, but in general, you should alpha convert if the variables in the scope are already bound right?
05:02:33 <fliip> just to be safe?
05:02:54 <ClaudiusMaximus> what about writing it using de Bruijn (?) indices, something like (\\10)(\00) -> \(\00)0 -> \00
05:03:02 <shachaf> In general you should figure out why and when alpha conversion is necessary. :-)
05:03:20 <shachaf> If you always alpha-convert when reducing, you should be safe, of course.
05:03:30 <fliip> Ok thanks! =)
05:03:34 <shachaf> You can also avoid the need for alpha-conversion entirely, as ClaudiusMaximus suggests.
05:04:16 <fliip> Im a novice. Give me a chance to learn the basics =P
05:06:20 <dmwit> Are there any c2hs experts here? I can use {#type Foo#} to generate something like FunPtr (Ptr () -> IO CInt); is there a directive that would generate the type (Ptr () -> IO CInt) instead?
05:07:49 <ClaudiusMaximus> type *Foo ?
05:07:59 <ClaudiusMaximus> just a guess
05:09:01 <dmwit> That makes c2hs give me a syntax error (doesn't even make it to ghc).
05:09:12 <ClaudiusMaximus> sorry..
05:09:14 <dmwit> I'm pretty sure type expects a C identifier and nothing more complicated than that.
05:15:04 <dmwit> Oh, sigh. It's not really c2hs' fault; C just doesn't have a concept of a function type that's not also a pointer.
05:21:28 <zebr> hey all. this might be a weird question, but is there a standard syntax for 'maps', as in associative lists, in maths notation?
05:21:38 <dmwit> Type families to the rescue. They're supported since GHC 6.10, so they ought to be usable in libraries now, right?
05:22:01 <dmwit> zebr: I think x |-> y is pretty standard for "x maps to y".
05:22:36 <rui_> hello
05:22:38 <dmwit> Oh, that symbol is even called \mapsto in TeX. =)
05:22:46 <rui_> i need help
05:22:52 <dmwit> Hiya, rui_.
05:23:08 <rui_> im portuguese
05:24:42 <rui_> hey
05:25:56 <zebr> hmm. i could do, say, $\{k \mapsto v, k' \mapsto v'\}$? but then what about lookups (Just x or Nothing) or removals or... >.> sometimes my unfamiliarity with maths is a nuisance.
05:27:38 <dmwit> rui_: There's #haskell-br, or you can just ask your question here (in English).
05:28:48 <dmwit> zebr: Often, maps in math are just partial functions.
05:29:32 <dmwit> So you use partial function notation for lookups, e.g. f=\{k \mapsto v, k'\mapsto v'\}, and then f(k)=v and f(l)\downarrow
05:29:44 <beaky> x := 0;
05:30:09 <dmwit> Removal is f\setminus(k,v), etc.
05:30:26 <dmwit> Probably wouldn't hurt you to have a paragraph (or table) describing whatever notation you do choose, though.
05:30:48 <raek> zebr: check out appendix A of this book: http://www.daimi.au.dk/~bra8130/Wiley_book/wiley.html
05:37:51 <raek> they model maps using functions, and f[k |-> v] means "a map like f, but which maps k to v instead"
05:38:10 <raek> lookup is function application: v = f k
05:39:25 <raek> if the functions are total, you can model "missing values" by adding an element to the domain: f :: K -> Maybe V
05:39:40 <raek> removal is then f[k |-> Nothing]
05:40:08 <zebr> ahh, that f[k |-> v] notation looks nice.
05:40:13 <zebr> cool, thanks dmwit, raek :)
05:49:43 <raek> zebr: (also, on page 12 (Semantic Functions) some other approaches are also briefly mentioned)
05:53:53 <Peaker> TypeCompose is completely broken by the new TypeOperator syntax in GHC 7.6. Is there some explicit way to allow type operators to be type-variables?
05:54:52 <byorgey> no =(
05:56:03 <rui_> hello
05:56:22 <rui_> ..
05:59:57 * hackagebot rdf4h 1.1.0 - A library for RDF processing in Haskell  http://hackage.haskell.org/package/rdf4h-1.1.0 (RobStewart)
06:00:44 <byorgey> hu rui_
06:03:18 <efie> could you tell me what is wrong with this? http://hpaste.org/77194
06:03:44 <jmcarthur> shachaf: "Do You Think In Closures? jmcarthur Does Too!"   wat
06:04:58 * hackagebot keyvaluehash 0.3.0.2 - Pure Haskell key/value store implementation  http://hackage.haskell.org/package/keyvaluehash-0.3.0.2 (EyalLotem)
06:14:35 <dmwit> efie: error seems to explain itself, no?
06:14:54 <dmwit> efie: Perhaps you should add MV.Unbox a to the context of createInitVektor's type.
06:18:00 <Peaker> Given hackage does not support https, but only http, do I need to worry that my password is passed plaintext to hackage?
06:18:19 <hpc> yes, but not particularly much
06:18:19 <byorgey> yes
06:18:30 <byorgey> but who cares, anyone can upload any package anyway =P
06:18:31 <hpc> unless you stupidly reused that password
06:19:12 <Peaker> Would cabal welcome a patch to fix warnings/hlint warnings?
06:19:24 <hpc> probably
06:21:25 <Peaker> my IRC client was write only (had to look at responses in the web logs..) trying the web client instead
06:21:36 <Peaker> I think my ISP is doing IRC jamming :(
06:22:01 <hpc> that would be an entirely useless thing for an ISP to do
06:22:58 <dmwit> Is "IRC jamming" a thing? That seems fantastically unlikely.
06:23:04 <Peaker> well, internet generally works perfectly, but IRC seems to be write-only
06:23:33 <Peaker> now the web chat works ok
06:24:21 <Jafet> An interim measure until they find someone who can speak leet.
06:24:22 <Peaker> anyway, do people generally not care that hackage doesn't respect their password's privacy?
06:24:56 <dmwit> I use a separate password for Hackage.
06:24:59 <PocketsizeIslam> @src putStrLn
06:25:00 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
06:25:04 <beaky> hello
06:25:36 <dmwit> I do hope that Hackage 2 supports https, but as I'm not willing to put up the code to fix it I don't complain about the current situation.
06:26:12 <Peaker> I've got a bunch of darcs patches for cabal from the time it was still not git. Any idea how to apply those on the new git repo?
06:26:28 <PocketsizeIslam> If lambdabot can't find a source it means it's a primtiive?
06:26:33 <PocketsizeIslam> in this case hPutStr
06:26:36 <Peaker> a "bundle" file
06:26:48 <dmwit> Well, there's a darcs to git bridge; perhaps use that and git pull from the result?
06:27:20 <dmwit> PocketsizeIslam: No, it just means lambadbot's limited database doesn't have the source for that.
06:27:39 <PocketsizeIslam> Doesn't it go through the ghc libs for that or something?
06:27:42 <dmwit> PocketsizeIslam: Use hoogle.
06:27:59 <dmwit> PocketsizeIslam: No, it has a (small) database, as I implied.
06:28:03 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#putStr
06:28:03 <PocketsizeIslam> Well, I know how to implemnet it, I was just wondering if GHC did that primitively or in terms of putStr
06:28:46 <PocketsizeIslam> Does look there like hPutStr is primitive
06:29:14 <dmwit> Why do you say that?
06:29:24 <dmwit> Again: use Hoogle.
06:29:29 <dmwit> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-IO-Handle-Text.html#hPutStr
06:29:37 <dmwit> You have to go quite deep to reach a primitive, I think.
06:29:55 <beaky> how do I do parallel programming in haskell
06:30:11 <dmwit> beaky: Step 1: learn the difference between parallel and concurrent.
06:30:23 <beaky> what is the difference between parallel and concurrent?
06:30:26 <dmwit> In case you have already learned the difference: use `par` and `pseq`, or try IVars.
06:31:50 <Peaker> beaky: Concurrent programming is when you want the semantics of things happening at the same time (e.g: explicit IO threads).  Parallel programming is when you want your algorithm to execute on multiple computing resources (e.g: multiple cpu cores) regardless of semantics.  Concurrent programming often facilitates parallelism, but you can get parallelism without concurrent semantics
06:31:54 <dmwit> parallel: the output is still determined by the input, but the implementation strategy may use multiple processors; concurrent: more than one point of control which are chosen nondeterministically
06:32:21 <beaky> so parallel programs are like a battery of guns
06:32:29 <beaky> or is that concurrent programs?
06:32:54 <dmwit> beaky: You might like Lectures 1-7 on Simon Marlow's home page:
06:32:58 <dmwit> http://research.microsoft.com/en-us/people/simonmar/
06:32:59 <beaky> ah
06:33:13 <dmwit> The summer school "Functional Programming for Parallel and Concurrent Applications" lecture course.
06:33:15 <hpc> beaky: in some sense, concurrency is a semantic detail and parallelism is an implementation detail
06:33:34 <jmcarthur> beaky: typically parallelism is for performance and concurrency is for design
06:34:16 * jmcarthur just realized how fuzzy "design" usually is
06:35:23 <beaky> so parallelism is like firing all the guns in a battleship
06:35:26 <Jafet> @wn concurrent
06:35:27 <lambdabot> *** "concurrent" wn "WordNet (r) 3.0 (2006)"
06:35:27 <lambdabot> concurrent
06:35:27 <lambdabot>     adj 1: occurring or operating at the same time; "a series of
06:35:27 <lambdabot>            coincident events" [syn: {coincident}, {coincidental},
06:35:27 <lambdabot>            {coinciding}, {concurrent}, {co-occurrent},
06:35:29 <lambdabot>            {cooccurring}, {simultaneous}]
06:35:42 <hpc> beaky: and concurrency is aiming at multiple targets :P
06:35:44 <beaky> @wn parallelism
06:35:45 <lambdabot> *** "parallelism" wn "WordNet (r) 3.0 (2006)"
06:35:45 <lambdabot> parallelism
06:35:45 <lambdabot>     n 1: similarity by virtue of corresponding [syn: {parallelism},
06:35:45 <lambdabot>          {correspondence}]
06:35:49 <beaky> :(
06:35:57 <Jafet> @wn parallel
06:35:58 <lambdabot> *** "parallel" wn "WordNet (r) 3.0 (2006)"
06:35:58 <lambdabot> parallel
06:35:58 <lambdabot>     adj 1: being everywhere equidistant and not intersecting;
06:35:58 <lambdabot>            "parallel lines never converge"; "concentric circles are
06:35:58 <lambdabot>            parallel"; "dancers in two parallel rows" [ant:
06:36:00 <lambdabot> [15 @more lines]
06:36:14 <Jafet> Heh, not intersecting.
06:36:20 <beaky> cuncurrency is like running the GUI and the Logic in separate threads?
06:38:00 <Peaker> beaky: depends, are the threads visible to the code or are they a hidden detail in the background speeding things up?
06:38:41 <beaky> background I guess :D
06:40:10 <scp> beaky: concurrency is used when having a seperate control flow is useful to the task at hand (i.e. have another thread block for I/O, have one thread per user, etc..)
06:40:38 <Peaker> beaky: if the parallel execution is an implementation detail not visible to the code itself (not in the semantics), it is parallelism
06:40:40 <scp> beaky: parallelism is generally a performance concern. Concurrency isn't necessarily parallel =]
06:40:51 <beaky> ah
06:41:12 <beaky> so concurrency can also mean a single cpu using two pretend threads?
06:41:22 <scp> yes
06:41:36 <Peaker> beaky: if it is part of the model/semantics you're programming and you have to think about things happenings at the same time (especially about the non-deterministic nature of such) then it is "concurrency", which is sometimes used as a way to get parallelism
06:41:53 <jmcarthur> beaky: concurrency can even mean cooperative threads and such
06:41:59 <Peaker> (and sometimes you just want the semantics of things happening at same time)
06:44:05 <dmwit> urgh
06:44:24 <beaky> but something like map is paralell rather than concurrent?
06:44:28 <beaky> parllel*
06:45:37 <dmwit> If you're running a GUI in one thread and the logic in another, this is almost certainly a concurrent design. I very much doubt that you can come up with a design that fits that description that is, in fact, parallel.
06:46:10 <sp3ctum> what should i use for storing dates (year, month, day) as a data type? is there a basic library for this?
06:46:11 <jmcarthur> beaky: map could have a parallel implementation, but Data.List.map does not
06:46:14 <scp> beaky: you could have a parallel implementation of map which runs all all of the computations in parallel while hiding that detail from the reader
06:46:20 <hpc> @hoogle parMap
06:46:20 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:46:24 <scp> haha
06:46:34 <fryguybob> dmwit: coerce the user into giving deterministic input?
06:46:36 <scp> s/reader/programmer
06:46:45 <dmwit> sp3ctum: Yes, the "time" library is for this.
06:46:50 <hpc> (Strategy b) roughly means "how parallel do we want to be computing a 'b')
06:47:13 <hpc> (ha, mismatched parens and quotes!"
06:47:20 <dmwit> So, GHC-7.0 doesn't allow type families in FFI declarations.
06:47:23 <dmwit> That sucks.
06:47:44 <jmcarthur> sp3ctum: http://hackage.haskell.org/package/time-1.4.0.1
06:47:55 <dmwit> you're late =)
06:48:03 <sp3ctum> thanks!
06:48:32 <dmwit> I guess it doesn't really fit the description of "basic library", but I think that's for the better where dates and times are concerned.
06:48:37 <beaky> @src parMap
06:48:37 <lambdabot> Source not found. I feel much better now.
06:48:40 <beaky> :(
06:48:41 <jmcarthur> dmwit: it's hard to find :(
06:48:53 <jmcarthur> at least by in-page search on hackage
06:48:56 <dmwit> ?hackage time <- was that so hard?
06:48:56 <lambdabot> http://hackage.haskell.org/package/time <- was that so hard?
06:49:05 <dmwit> ;-)
06:49:40 <dmwit> You should have such a shortcut in your browser if you do a lot of Haskell development -- if for nothing else than looking up documentation.
06:49:52 <watwat> hi, guys! Has anybody used HSpec?
06:50:02 <dmwit> Yes. Next question!
06:50:05 <beaky> @hoogle parMap
06:50:06 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
06:50:28 <hpc> in firefox, bookmark http://www.haskell.org/hoogle/?hoogle=%s and give it a keyword like "hoogle"
06:50:39 <hpc> then "hoogle foo" in the address bar brings up http://www.haskell.org/hoogle/?hoogle=foo
06:50:51 <dmwit> (All major browsers have something similar.)
06:52:52 <watwat> so, my specs fail at this function here
06:52:55 <watwat> https://gist.github.com/d279ab50df89bb1402a2
06:54:21 <watwat> Initially, I had eval :: IntExp -> Env -> Integer  and the Specs expected Integer's and that was fine
07:06:07 <dmwit> watwat: Looks like you just need to derive Eq for IntExp's?
07:06:25 <dmwit> Just looking at the type of shouldBe here, but don't have hspec installed so can't test that.
07:07:52 <Peaker> Peaker_ used an IRC client, Peaker uses web client. Definitely some filtering going on.
07:09:00 <watwat> dmwit: ah, right, d'oh! that works!
07:09:31 <watwat> I think I won't need it to return IntExp after all, but thanks a lot!
07:09:33 <dmwit> watwat: (I would expect the error message to more or less say exactly that, by the way.)
07:10:00 <otters> I have a HashMap of ThreadId -> some object
07:10:12 <otters> and I need to do lookups based on user input
07:10:21 <otters> and obviously there's no Read instance for ThreadId
07:11:06 <watwat> dmwit: it does indeed, but I didn't really know what to make of it ^_^   so, thanks for that!
07:12:43 <dmwit> otters: Could make a map from String to ThreadId using the Show instance, I suppose.
07:12:53 <otters> Yeah, I suppose
07:15:54 <scp> Can anyone point me to a good tutorial/explanation of Parsec?
07:16:16 <scp> rwh doesn't do a very good job of explaining the case where my input isn't [Char] and I have a syntax tree to update
07:16:42 <scp> but the type signatures in hackage seem to suggest that's a reasonable thing to want to do
07:20:36 <palango> hey, I'm wondering on how to install haskell on mac os x. should I use the installer on the website or is homebrew the better way to go?
07:25:03 * hackagebot flaccuraterip 0.1 - Verify FLAC files ripped form CD using AccurateRip"  http://hackage.haskell.org/package/flaccuraterip-0.1 (NicolaSquartini)
07:25:27 <Jafet> @arr
07:25:27 <lambdabot> I'll keel haul ya fer that!
07:25:39 <sp3ctum> @arr
07:25:39 <lambdabot> Aye
07:27:57 <srhb> sequence isn't strict, is it?
07:28:01 <srhb> @src sequence
07:28:01 <lambdabot> sequence []     = return []
07:28:01 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
07:28:01 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
07:28:08 <srhb> Hm.
07:29:28 <Jafet> It runs the list in a sequence.
07:31:13 <srhb> I'm going around this all wrong. Suppose I have an IO Something and I want to produce an infinite list [IO Something] where each depends on the previous... Should I not be able to do something like iterate (makeOneSomething =<<) (return seed) -- without accidental strictness?
07:31:43 <srhb> "accidental strictness" is a bad term <_<
07:31:52 <ClaudiusMaximus> [IO Something] or IO [Something]
07:32:05 <srhb> Well.. Hm. :P
07:32:12 <srhb> IO [Something] I suppose
07:32:35 <ClaudiusMaximus> there's unsafeInterleaveIO if you really want lazy IO, with all the problems that entails
07:32:54 <srhb> Eck, no.
07:33:46 <srhb> Is there no getting around unsafe functions for this scenario?
07:35:40 <ClaudiusMaximus> srhb: i tend to use something like  newtype Go = MkGo{ runGo :: IO (Something, Go) }
07:37:22 <ClaudiusMaximus> srhb: but there's probably a better abstraction (coroutines?)
07:37:53 <osa1> I want to generate some static html files with haskell, texts are markdown formatted so I also need to render markdown as html, what tools should I use ?
07:38:08 <Botje> can youbrecyc
07:38:23 <Botje> recycle something from pandoc?
07:38:24 <srhb> And here I thought I could just foo n = do item <- bar n; next <- foo bar; return $ bar : next
07:42:06 <Sonderblade> is there any way to pretty-print data in ghci?
07:42:49 <byorgey> osa1: you can use pandoc directly to convert markdown -> html.  You can even write a little program to easily insert some custom processing.
07:42:50 <Jafet> laziness = unsafePerformIO; foo n = do item <- bar n; return $ bar : laziness (foo $ next n)
07:43:10 <byorgey> osa1: if you have something more complex you can use hakyll (which is for creating whole static websites, and uses pandoc under the hood)
07:43:20 <byorgey> @package groom
07:43:20 <lambdabot> http://hackage.haskell.org/package/groom
07:43:25 <byorgey> Sonderblade: ^^^ try that?
07:43:48 <srhb> Jafet: Butbut, unsafe... >_<
07:43:56 <srhb> I don't think I understand the consequences of that yet.
07:44:08 <osa1> byorgey: I also need a syntax highlighter, does hakyll do that ?
07:44:15 <byorgey> osa1: yes
07:44:37 <byorgey> I mean, pandoc does, hence so does hakyll
07:45:04 * hackagebot non-empty 0.0 - List-like structures with static checks on the number of elements  http://hackage.haskell.org/package/non-empty-0.0 (HenningThielemann)
07:45:04 <Jafet> Actually it should be: foo n = laziness $ do item <- bar n; return $ item : foo (next n)
07:45:40 <Jafet> It just means that, when some pure function uses the result, some IO happens.
07:45:51 <osa1> byorgey: great, I'll try pandoc for markdown->html. any tools for generating other parts of html ? (page layout etc.)
07:46:24 <srhb> Jafet: I don't understand completely. Are you saying there's no way around unsafePerformIO when building infinite IO lists?
07:47:29 <Jafet> do list <- foo n; evaluate (f list);
07:47:45 <Jafet> Either foo uses strict IO to do infinite IO, in which case it never comes back.
07:48:05 <srhb> Hm..
07:48:09 <Jafet> Or it uses lazy IO and comes back, in which case the remaining IO has to happen when evaluating the pure function f, some way or other.
07:49:04 <byorgey> osa1: hakyll uses a simple templating system.  If you want more programmatic generation of HTML, try blaze-html
07:49:39 <Sonderblade> byorgey: but how do i use it in ghci?
07:50:39 <byorgey> Sonderblade:  :m +Text.Groom,   then    groom foo
07:52:56 <Jafet> Do I understand correctly, that groom just reformats arbitrary haskell expressions?
07:53:10 <Jafet> groomString s = case parseExp s of ParseOk x -> prettyPrint x; ParseFailed{} -> s
07:53:16 <Jafet> I understood correctly
07:54:07 <Sonderblade> byorgey: nice, can you have groom replace the default printing in ghci so that you dont have to load the groom library all the time?
07:59:22 <Jafet> I believe print is hardcoded into ghci
08:03:03 <donri> Sonderblade: not to my knowledge, but you can import it in your ~/.ghci
08:04:11 <donri> i also like to add let pp = putStrLn . groom
08:05:00 <bxx> is there a function that given a predicate returns a predicate with inverted logic?   (invpred isAlpha) => (\c -> not $ isAlpha c)
08:05:13 <dmwit> :t (not .)
08:05:14 <lambdabot> forall (f :: * -> *). Functor f => f Bool -> f Bool
08:05:20 <dmwit> ...
08:05:24 <dmwit> :t (not P..)
08:05:26 <lambdabot> Couldn't find qualified module.
08:05:29 <Peaker> Caleskell :(
08:05:31 * dmwit sighs gently
08:05:36 <dmwit> :t (not Prelude..)
08:05:37 <donri> not . isAlpha
08:05:37 <lambdabot> forall a. (a -> Bool) -> a -> Bool
08:06:00 <Peaker> :t (\f x -> not (f x))
08:06:02 <lambdabot> forall t. (t -> Bool) -> t -> Bool
08:06:11 <bxx> :) I forgot about partial application
08:06:19 <donri> @pl (\f x -> not (f x))
08:06:20 <lambdabot> (not .)
08:07:24 <scp> @let foo = takeWhile . flip (<)
08:07:25 <lambdabot>  Defined.
08:07:27 <masta_> Hello. Are haskell Qt bindings usable?
08:07:30 <scp> foo 5 [1, 2, 3, 4, 5]
08:07:36 <scp> > foo 5 [1, 2, 3, 4, 5]
08:07:38 <lambdabot>   [1,2,3,4]
08:07:47 <scp> >_<
08:07:59 <dmwit> >_< ?
08:08:12 <scp> if I do that in ghc, I get No instance for (Num ()) arising from the literal `5'
08:08:13 <jmcarthur> (.) is the biggest Caleskell disaster
08:08:22 <masta_> Everyone seems to be using gtk, but I am far more familiar with Qt library
08:08:30 <scp> jmcarthur, what do you mean?
08:08:35 <jmcarthur> heh, interesting, () would make a perfectly fine Num instance
08:08:37 <dmwit> scp: welcome to defaulting
08:08:39 <jmcarthur> :P
08:08:45 <dmwit> scp: :set -XNoMonomorphismRestriction
08:08:52 <jmcarthur> scp: observe:
08:08:55 <jmcarthur> :t (.)
08:08:56 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
08:09:02 <jmcarthur> :t (Prelude..)
08:09:04 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
08:09:37 <scp> dmwit: Can you explain that craziness?
08:09:44 <scp> jmcarthur, you too =[
08:09:45 <donri> . = fmap
08:09:45 <dmwit> masta_: I think the advice has always been "use the bindings for the GUI library you already know".
08:09:55 <jmcarthur> scp: the monomorphism restriction is an unfortunate bit of history with good intentions
08:10:21 <scp> jmcarthur: My main concern is... how do I know my code will compile x_X
08:10:42 <jmcarthur> scp: the craziness i demonstrated is only in lambdabot. it turns out that lambdabot's (.) is a generalization of Prelude's (.), but it makes it more difficult to teach with here in #haskell
08:11:02 <jmcarthur> (i also think it's the wrong generalization, but that's another matter)
08:11:04 <masta_> dmwit: I have heard that haskell qt bindings arent that usable or maintained though.
08:11:14 <scp> ah, I see
08:11:41 <dmwit> scp: The monomorphism restriction, see
08:11:45 <dmwit> ?wiki monomorphism restriction
08:11:45 <lambdabot> http://www.haskell.org/haskellwiki/monomorphism_restriction
08:12:03 <dmwit> scp: Extended defaulting is ghci's extra rules for dealing with the monomorphism restriction.
08:12:46 <monochrom> @type (.)
08:12:48 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
08:12:49 <dmwit> scp: You can turn either of them off as you prefer; the former with -XNoMonomorphismRestriction, the latter with -fno-extended-default-rules
08:12:55 * monochrom shakes head
08:13:04 <jmcarthur> scp: the monomorphism restriction was intended to make code easier to reason about by ensuring that by default top level constants are not polymorphic, which would mean that if you instantiate it at different types then you get different values in memory. many of us believe that to be a mistake.
08:13:58 <jmcarthur> scp: for example, if i say at the top level  x = 5  , without the monomorphism restriction x can take on many different types, so there must be one version of x for each type i use
08:14:45 <dmwit> scp: Oh, apparently also -XNoExtendedDefaultRules should work. See http://www.haskell.org/ghc/docs/latest/html/users_guide/interactive-evaluation.html#extended-default-rules for the details of that one.
08:14:58 <jmcarthur> scp: it could be especially confusing for, say, memoization or something, since if i accidentally use it with a different type then i will be using a different memo table
08:15:03 <scp> jmcarthur: What I'm getting from the wiki is that, if I use explicit type declarations, this won't be an issue?
08:15:16 <jmcarthur> scp: on the other hand, defaulting is annoying, which is the main beef with the monomorphism restriction
08:15:19 <scp> scp, I see, so your memoized computations might need to be recomputed
08:15:28 <jmcarthur> scp: yeah, explicit type signatures largely avoids it
08:15:28 <scp> heh, I tagged myself =P
08:16:11 <Sonderblade> donri: how do you define "pp" in .ghci?
08:16:35 <jmcarthur> i find that i mostly bump into problems with the MR in ghci, so i put :set -XNoMonomorphismRestriction into my .ghci
08:16:53 <jmcarthur> or :iset or whatever the interactive-only version of :set is
08:17:13 <Jafet> Interactive-only version of :set?
08:17:27 <jmcarthur> yeah, so it doesn't affect the interpretation of files you load
08:17:38 <jmcarthur> only things you type in directly
08:17:50 <jmcarthur> it's :seti
08:19:28 <bxx> is there a function that strips both prefix and suffix elements?  strip "-_" "---foo__"  =>  "foo"
08:19:46 <dmwit> I thought :set already only affected the interactive session.
08:20:02 <hpc> bxx: a combination of takeWhile and dropWile will do it
08:20:04 <dmwit> bxx: strip . reverse . strip . reverse
08:20:06 * hackagebot suspend 0.1.0.2 - Simple package that allows for long thread suspensions.  http://hackage.haskell.org/package/suspend-0.1.0.2 (PetrPilar)
08:20:13 <jmcarthur> time to try an experiment with ghci i guess
08:20:34 <fliip> In lambda calculus do combinators have a normal form? So for say Yi, is i(Yi) its normal form?
08:20:50 <hpc> @let strip cs s = takeWhile (not . (`elem` cs)) (dropWhile (not . (`elem` cs)) s)
08:20:51 <lambdabot>  Defined.
08:21:08 <hpc> > strip "_-" "the_quick-brownfox -- comment"
08:21:10 <lambdabot>   ""
08:21:10 <jmcarthur> dmwit: confirmed. :set affects files you load (after setting it), too
08:21:22 <hpc> hmm
08:21:25 <jmcarthur> i doubt it would retroactively reinterpret it though
08:21:34 <Jafet> takeWhile f . dropWhile f = const []
08:21:38 <dmwit> fliip: There are many kinds of normal forms, and there are definitely terms that never reach any of the most common normal forms.
08:21:49 <hpc> oh right
08:21:52 <hpc> @undefine
08:22:05 <hpc> @let strip cs s = takeWhile (not . (`elem` cs)) (dropWhile (`elem` cs) s)
08:22:06 <fliip> So does Yi have a normal form? Im a bit confused.
08:22:07 <lambdabot>  Defined.
08:22:18 <dmwit> fliip: Define Y. Define i.
08:22:23 <hpc> > strip "-_" "hyphenated-text_blub"
08:22:24 <lambdabot>   "hyphenated"
08:22:44 * hpc shouldn't be thinking right now anyway :P
08:23:16 <fliip> Y is the combinator \f.(\x.f(xx))(\x.f(xx)) and i = \x.x
08:23:35 <dmwit> ?let stripFront cs = dropWhile (`elem` cs); stripBoth cs = stripFront cs . reverse . stripFront cs . reverse
08:23:36 <lambdabot>  Defined.
08:23:39 <jmcarthur> > fix id
08:23:40 <bxx> I did it like this
08:23:43 <lambdabot>   mueval-core: Time limit exceeded
08:23:50 <dmwit> > stripBoth "-_" "hyphenated-text_blub"
08:23:52 <lambdabot>   "hyphenated-text_blub"
08:23:52 <bxx> strip xs ys = takeWhile (isWantedChar) $ dropWhile (not . isWantedChar) ys where isWantedChar c = not $ elem c xs
08:23:58 <bxx> let strip xs ys = takeWhile (isWantedChar) $ dropWhile (not . isWantedChar) ys where isWantedChar c = not $ elem c xs
08:23:59 <dmwit> > stripBoth "-_" "---hyphenated-text_blub___"
08:24:01 <lambdabot>   "hyphenated-text_blub"
08:24:09 <bxx> strip "_-" "__foo--"
08:24:35 <dmwit> bxx: As hpc observed above, that is not correct, because it will do the wrong thing to "__foo-bar--"
08:24:51 <bxx> ah
08:25:08 * hackagebot timers 0.2.0.1 - Simple package that implements timers.  http://hackage.haskell.org/package/timers-0.2.0.1 (PetrPilar)
08:25:15 <dmwit> fliip: No, that never reaches a normal form.
08:25:28 <_alex86_> hello guys, i m doing my language interpreter. In a evaluate Statement function I am trying to evaluate "while" loop line 57. But I have an error "Couldn't match expected type `Env' with actual type `IO Env'". have a look, here is code: http://pastebin.com/2TSSaFFY
08:25:31 <hpc> fliip: manually expand it yourself
08:25:44 <fliip> It becomes i(Yi)
08:25:50 <hpc> Yi = (\x.xx)(\x.xx)
08:25:58 <fliip> But then I guess you could then repeat the process...
08:25:59 <dmwit> It doesn't become i(Yi).
08:26:03 <hpc> and if you β-reduce that, you get...
08:26:04 <hpc> Yi = (\x.xx)(\x.xx)
08:26:18 <Jafet> > eval "((\\f. ((\\x. (f (x x))) (\\x. (f (x x))))) (\\x. x))"
08:26:22 <lambdabot>   mueval-core: Time limit exceeded
08:26:38 <fliip> Any Yx = x(Yx)
08:26:44 <fliip> That's what a combinator does.
08:26:58 <fliip> It creates a fixed point for x
08:27:27 <fliip> Or rather Yx is a fixed point of x
08:28:06 <dmwit> Depends what "=" means (or what "become" means), I guess. =)
08:28:41 <dmwit> Yi never reduces to something that is syntactically equal to i(Yi); however, both Yi and i(Yi) reduce to something syntactically equal.
08:28:46 <Peaker> which "base" version was the last published 3 years ago? I want to fix "cabal" but need to keep support for old ghc's
08:29:01 <monochrom> _alex86_: your're doing "evalStmt (While boolExp stmt1 :: Stmt) (evalStmt stmt1 env :: IO Env)". clearly the 2nd argument is a type error
08:29:03 <dmwit> or rather, there is something which both Yi and i(Yi) reduce to
08:29:06 <fliip> So you would say Ti has no normal form?
08:29:14 <fliip> Or has no Beta normal form?
08:29:16 <dmwit> Define T.
08:29:22 <fliip> Sorry, Yi*
08:29:42 <dmwit> That sounds accurate to me, yes.
08:29:47 <nicoo> fliip: Not all combinators are fixed-point ones ;)
08:29:49 <monochrom> I also don't understand why evalStmt has to involve IO
08:29:53 <fliip> Y is though.
08:30:09 <dmwit> Peaker: Hackage has release dates on the version-specific package pages...
08:30:46 <dmwit> Palmik: (By the way, have you seen the unbounded-delays package?)
08:31:07 <_alex86_> monochrom: yeah, how can i correct this. I could just make my evalStmt type Env, but how i am going to evaluate statements like "Write i" or "Read i" ? for this reason I m using IO Env
08:31:25 <_alex86_> monochrom: thnx for look at the code btw
08:31:53 <monochrom> well then, you're doing IO, I'm pretty sure you know either do-notation or >>=
08:32:51 <Peaker> apparently "intercalate" is more than 3 years old in ghc releases.. removing it's incessant re-implementation from cabal..
08:33:22 <Palmik> dmwit, yes, that's basically what suspend is -- but it does not use interger but "just" Int64.
08:34:09 <Palmik> dmwit, plus of course suspend has some convenience functions.
08:35:38 * dmwit nods
08:35:46 <dmwit> (Is Int64 better than Integer?)
08:35:52 <Peaker> import Prelude hiding (catch) -- apparently in new GHC no longer exports catch. This causes a warning. How do you get rid of the warning without losing compatibility with older GHC?
08:35:58 <hpc> dmwit: in what sense?
08:36:02 <hpc> @src Integer
08:36:02 <lambdabot> data Integer = S# Int#
08:36:02 <lambdabot>              | J# Int# ByteArray#
08:36:04 <_alex86_> monochrom: have done smth like this, but gives me an error again. http://pastebin.com/4SiBRRTk
08:36:05 <Peaker> I can think of just using it qualified. not sure if the cabal folks will like that
08:36:22 <mauke> The paste 4SiBRRTk has been copied to http://hpaste.org/77200
08:36:49 <dmwit> hpc: I am essentially asking Palmik to justify his library's existence. =)
08:36:59 <dmwit> The convenience functions are nice.
08:37:22 <monochrom> env1 <- evalStmt stmt1 env
08:37:29 <hpc> dmwit: oh, thought you asked "bigger"
08:37:33 <monochrom> evalStmt (While boolExp stmt1) env1
08:37:48 <Palmik> dmwit, well, Integer seems like an overkill to me.
08:47:39 <_alex86_> monochrom: ok, it turns out i had my tabs wrong.thnx
08:47:46 <_alex86_> it works now
08:47:54 <donri> Sonderblade: let pp = ...
08:50:31 <prezjordan> learning haskell - writing a binary search tree module for fun. anyone mind helping me wrap my head around `Maybe` ?
08:50:47 <srhb> prezjordan: What part of Maybe? Have you read the definition of it?
08:50:55 <prezjordan> more specifically: incorporating `Maybe` into my code instead of using `undefined`. https://gist.github.com/4007698
08:51:23 <srhb> prezjordan: Maybe a is a type that has possible values Just a or Nothing
08:52:01 <srhb> prezjordan: The easy explanation is: If you find something, return Just that, otherwise you return Nothing.
08:52:21 <prezjordan> srhb: so would I need `(Maybe a)` in all of my type declarations (sorry if that's not the correct term)?
08:52:43 <srhb> prezjordan: That's right. Maybe a for whatever a is the actual type you'll be returning
08:53:22 <prezjordan> srnhb: so it is common to see `(Maybe a)` all over the place? I'm wondering what convention is. I tried incorporating it into some functions but found I really needed it *everywhere*
08:53:48 <srhb> prezjordan: Consider this: mySqrt x | x < 0 = Nothing; | otherwise = Just (sqrt x)
08:53:55 <Iceland_jack> prezjordan: Can you give an example of functions where you felt it was needed?
08:53:56 <prezjordan> srhb: in order for them to work together :)
08:54:19 <srhb> prezjordan: It might be slightly infectious yes, but it gives you more safety. :)
08:54:38 <prezjordan> Iceland_jack: all of them. I wanted it for `findMax` but found that other functions like `removeMax` called `findMax`, so they also needed `Maybe`
08:54:43 <srhb> prezjordan: That's actually part of its strength, it forces you to consider "what will my code do in case I get a Nothing here..."
08:55:05 <prezjordan> srhb: I can appreciate that :) I was just getting concerned that it was *everywhere*!
08:55:16 <Iceland_jack> prezjordan: so findMax is something like: (Ord a) => [a] -> Maybe a?
08:55:27 <srhb> prezjordan: Find one example where it is unnecesary in a function that depends on a function that MUST be able to return a Nothing something
08:55:42 <prezjordan> srhb: when you put it that way...
08:55:46 <srhb> prezjordan: I think you will find that only the functions that explicitly need to handle the Nothing case actually needs to use Maybes. ;)
08:56:35 <donri> prezjordan: depends what you're doing. there's sometimes other ways to achieve totality (e.g. a list type that knows its size statically or can't be empty, avoids common list errors), or ways to hide the error handling (e.g. Monoid/Alternative/MonadPlus. common in parsing)
08:56:36 <prezjordan> srhb: so now (sorry for getting specific) `removeMax` will call `findMax` which CAN return `Nothing`, but it will not return `Nothing` if it is called by `removeMax`, given the cases of my code
08:57:09 <prezjordan> srhb: yet I still need to include `Maybe` to make them play nicely with each other?
08:57:20 <clahey_> prezjordan, What are findMax and removeMax?  Functions you wrote?
08:57:29 <prezjordan> clahey_: yes
08:57:38 <srhb> clahey_: Paste is a bit up
08:57:47 <prezjordan> https://gist.github.com/4007698 (repeated)
08:57:53 <donri> prezjordan: there's also a bunch of instances for Maybe that can make dealing with it easier, e.g. its Monad instance
08:57:55 <clahey_> prezjordan, You don't necessarily need Maybe in both.  There are functions of type Maybe a -> a
08:58:24 <prezjordan> clahey_: findMax could return Nothing if you give it an empty tree. however `removeMax` will never reach that case when calling `findMax`
08:58:36 <srhb> prezjordan: It also doesn't affect the signature of removeMax if removeMax uses findMax internally
08:58:42 <srhb> prezjordan: (not necessarily, at least)
08:58:43 <prezjordan> (such a mouthful)
08:59:04 <prezjordan> okay, I think I'm going to take a stab at it, given the help you've all given me thus far :) thank you!
08:59:14 <clahey_> prezjordan, Check out fromJust
08:59:18 <clahey_> :t fromJust
08:59:20 <lambdabot> forall a. Maybe a -> a
08:59:24 <donri> fromJust is evil
08:59:31 <srhb> In this case, not so much
08:59:45 <donri> it's better to pattern match on Just if you really need it, that way you get better errors if they do happen
09:00:01 <prezjordan> I guess one last concern… let's see if I can communicate this correctly
09:00:03 <donri> > let Just x = Nothing in x
09:00:05 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
09:00:09 <donri> > fromJust Nothing
09:00:10 <lambdabot>   *Exception: Maybe.fromJust: Nothing
09:00:17 <donri> one error is more helpful than the other
09:00:23 <srhb> True enough.
09:01:12 <prezjordan> I have a method `arrayToBST` which takes in an array and produces a Tree. however, if I want to call things like `findMax` on it, I would need a Tree (Maybe a). So does `arrayToBST` need to return a Tree full of Maybe's?
09:01:32 <srhb> prezjordan: No, you wouldn't
09:01:54 <monochrom> findMax should not involve Tree (Maybe a)
09:01:55 <clahey_> You still have a Tree a.  You just have a function of type  Tree a -> Maybe a
09:01:57 <srhb> prezjordan: Your trees contain a's. Your non-total functions produce Maybe a's
09:02:10 <dmwit> prezjordan: Just joined; forgive me if I've missed some context. Why would `findMax` need to be applied to a Tree (Maybe a)?
09:02:11 <srhb> "otherwise non-total_ I mean
09:02:26 <Hnoob> I did goo diligence, but could not find this. Haskell for iPad?
09:02:28 <prezjordan> hi dmwit :) : https://gist.github.com/4007698 is my paste if you haven't seen it yet
09:02:47 <srhb> prezjordan: You're already encompassing the "no value in this branch" with EmptyTree, no need to duplicate that
09:03:16 <dmwit> prezjordan: Now I have seen it, but my question is the same.
09:03:28 <prezjordan> srhb: so `findMax` would certainly need to return `Nothing` given an EmptyTree, correct?
09:03:33 <srhb> prezjordan: Correct.
09:03:50 <srhb> prezjordan: But that doesn't affect the type of the tree.
09:04:19 <monochrom> analogy: findMax on array would not force Array (Maybe a) either
09:04:21 <srhb> prezjordan: valueAtRoot EmptyTree = Nothing; valueAtRoot (Node x _ _) = Just x
09:04:52 <clahey_> dmwit, prezjordan is trying to figure out how to integrate Maybe into his findMax function and was postulating that since his old function was Tree a -> a, if he wanted to return a Maybe a, his new function would have to be Tree (Maybe a) -> Maybe a.  It's not true though.
09:04:55 <srhb> prezjordan: The "Maybe functions" deal with the wrapping into the correct constructors (Nothing or Just a)
09:05:04 <clahey_> :t Just
09:05:05 <lambdabot> forall a. a -> Maybe a
09:05:18 <monochrom> strange inference
09:05:28 <prezjordan> clahey_ nailed it :)
09:05:56 <prezjordan> let me try writing actual code, rather than pestering you all with my confusion. thank you for your help - much appreciated
09:05:58 <srhb> prezjordan: Look at valueAtRoot. Notice how it does NOT change the type of Tree a to Tree (Maybe a)
09:06:17 <srhb> prezjordan: I suspect that once you've actually tried that function you go "aaaaah!" ;)
09:06:23 <monochrom> yeah, and use type inference to see the type
09:06:26 <clahey_> prezjordan, Re post when you've got a new version.
09:06:34 <prezjordan> shrb clahey_ will do!
09:06:53 <prezjordan> srhb* I apologize for butchering your name :) but yes I am hoping for an "ahhhhhh" moment
09:07:40 <srhb> prezjordan: The function I gave is entirely compatible with your current code, give it a spin.
09:10:17 <prezjordan> srhb: 1st "aha" moment. My mind refused to accept the fact that I could do BinaryTree a -> Maybe a. For some reason I assumed I would need BinaryTree (Maybe a)
09:10:53 <srhb> prezjordan: Right. ;)
09:11:50 <srhb> prezjordan: The general idea to grasp here is that a function may return another type than it is given as its argument.. Trivially, mkJust x = Just x.
09:12:04 <srhb> (Otherwise Haskell woudln't be very useful at all :P)
09:16:11 <hpaste> srhb pasted “neverEndingReddit” at http://hpaste.org/77201
09:16:26 <srhb> If anyone's feeling bored, I would love a little criticism on the above paste.
09:16:39 <prezjordan> srhb: my current issue is that (line 55) creates a new BinaryTree Node using `(findMax left)` which returns a `Maybe a`, but I need a my Binary tree to have type `a` inside
09:16:43 <prezjordan> https://gist.github.com/4007788
09:17:01 <prezjordan> second "aha!" incoming… ;)
09:17:22 <Philonous> Why is "void (foo >> bar) " better than "(foo >> bar >> return ())"? (hlint says so)
09:18:15 <srhb> prezjordan: You'll probably need to case match on findMax left and decide what to do in either case
09:18:25 <sizz_> When I try to use Data.Heap by saying `import qualified Data.Heap as H`, running my program yields "Could not find module `Data.Heap.Internal`. It is a hidden module in the package `heap-1.0.0`". What am I doing wrong?
09:19:09 <srhb> Philonous: I don't agree with hlint on that.
09:20:28 <nand`> I think return () is ugly
09:20:34 <srhb> prezjordan: Are you sure your removeMax originally did what you meant it to do?
09:20:38 <nand`> especially if next to closing bracket like that
09:20:41 <nand`> parentheses hurt my eyes
09:20:57 <srhb> Oh, right, it does.. I think
09:21:36 <sizz_> So, no word on the hidden module issue?
09:22:34 <prezjordan> srhb: would I need a separate function to handle the return value of `(findMax left)` (you mentioned case matching - which I'm not sure how to do "inline")
09:23:06 <srhb> prezjordan: There's no magic, you can just do it inline, and it may span multiple lines even in the function definition
09:23:50 <srhb> case findMax left of; Nothing -> do something; Just val -> do something -- replace the ; with newlines and proper indentation
09:26:25 <nand`> I wonder if foldr could be generalized such that each application of the combinator produces not only a value but also the next combinator
09:26:29 <nand`> then you could do stuff like stateful folds
09:26:44 <srhb> That's... Possible with a small rewrite, isn't it
09:26:59 <srhb> Isn't that what happens in the "foldr with early termination"
09:28:39 <efie> can unboxed vectors be nested: a vector, and each enty of it is another vector?
09:29:19 <sclv> not automatically, no
09:29:57 <sclv> you can build a structure on top of a vector if you want
09:30:01 <c_wraith> elements of unboxed vectors msut be fixed-size.
09:30:13 <c_wraith> vectors are not fixed-size
09:30:47 <sclv> right. you can build a fixed-sized tuple that is unboxed though, and make a vector out of that if i recall
09:34:56 <bitonic> sclv: yeah but if you're storing big tuples it might be a problem
09:35:10 <bitonic> I wouldn't want to define the instance for the 100-ary tuple :P
09:36:01 <sclv> th to the rescue
09:36:05 <prezjordan> revised, thanks to everyone :) https://gist.github.com/4007698
09:37:24 <bitonic> sclv: still, pretty ugly
09:44:22 <dmwit> clahey__: I'm aware of that. It was a Socratic-style question, not a real question. =)
09:45:47 <dmwit> I stopped asking such questions because it seemed there were already enough Socrateses.
09:48:10 <clahey__> dmwit, Duh.  I'm an idiot.  :)
10:04:47 <jfischoff> has anyone messed around with the regions package: http://hackage.haskell.org/package/regions-0.11
10:05:19 <jfischoff> on thing I find odd is that the Finalizer is of type IO (). I would prefer m () where i could specify the monad
10:05:57 <jfischoff> I'm wondering if that is problematic, or regions can be generalized
10:08:23 <hiptobecubic> how did ocaml end up with such ugly syntax? Is it inherited?
10:09:21 <hpc> it's to do with how it's impure
10:10:22 <hpc> constructs like let-rec aren't necessary in haskell
10:12:09 <clahey__> jfischoff, I think that since the whole point is to control open file handles, there's no need for it to be general.
10:12:23 <clahey__> jfischoff, What do you want to do in some other monad?
10:12:52 <clahey__> jfischoff, Oh, unless you want it to be some other IOMonad because of monad tranformers.
10:13:22 <clahey__> Sorry MonadIO.
10:13:34 <jfischoff> clahey:I want to use regions with OpenGL resources, and for testing purposes (and purposes),  I want to the base monad to be pure
10:14:26 <sclv> the regions trick is the same as the st trick if i recall, so don't know why it would be bound to IO.
10:14:38 <hpc> it is the ST trick
10:15:06 * jfischoff nods
10:15:10 <hpc> you can combine the ST trick with some sort of (WriterT FinalizeAction m)
10:15:14 <hpc> and get your own solution
10:15:29 <jfischoff> yeah
10:15:41 <hpc> it's really just pretending to be a tower of withFoo constructs :P
10:15:53 <jfischoff> to coffee shop, but I think I will roll my own
10:30:10 <FireFly> Is there any formal term for `Either` similar to how tuples are product datatypes?  The best I can find is "sum datatype" or "tagged union", but this is far more encompassing than being limited to just Either, so I'm looking for a more specialized term (if there is one)
10:30:59 <rwbarton> binary sum?
10:31:07 <rwbarton> sounds a little awkward
10:31:31 <hpc> FireFly: "the sum type"
10:32:12 <hpc> the way i have seen the terms used, "sum types"/"product types" refers to n-ary, but "the $foo" refers to (,)/Either
10:32:34 <hpc> someone will probably yell at me though ;)
10:34:41 <FireFly> Hm, okay
10:37:54 <jmcarthur> what hpc said matches my understanding as well
10:40:29 <hpaste> ps pasted “resampling” at http://hpaste.org/77203
10:40:51 <ParahSailin> might someone look at this for me? http://hpaste.org/77203
10:42:17 <ParahSailin> i think the performance is decent, but i have to run it with +RTS -Kbignumber
10:42:29 <beaky> hello
10:42:38 <beaky> is doing the K&R exercises using Haskell a good way to learn Haskell?
10:42:56 <beaky> i.e. reimplement UNIX
10:43:11 <monochrom> perhaps
10:43:52 <beaky> how do I open a file in Haskell
10:44:06 <danharaj> Can someone explain to me the difference between the shift and withSubCont operators defined in the paper "A monadic framework for delimited continuations"?
10:44:07 <ParahSailin> @ty readFile
10:44:08 <lambdabot> FilePath -> IO String
10:44:29 <ParahSailin> @ty Data.ByteString.readFile
10:44:31 <lambdabot> FilePath -> IO BSC.ByteString
10:44:36 <danharaj> I understand shift/reset from Oleg's papers and I'm not sure why they are implemented in terms of pushPrompt/withSubCont the way they are.
10:44:47 <beaky> I think I'll use bytestring
10:44:58 <beaky> I heard String is quite funny
10:46:20 <rwbarton> reimplementing unix is probably a good way to learn conduits/pipes/flavor of the month
10:46:58 <jmcarthur> :D
10:47:00 <beaky> @hoogle ByteString -> FilePath
10:47:01 <lambdabot> Data.ByteString.Char8 unpack :: ByteString -> [Char]
10:47:01 <lambdabot> Data.ByteString.Lazy.Char8 unpack :: ByteString -> [Char]
10:47:01 <lambdabot> Data.ByteString.Char8 head :: ByteString -> Char
10:47:08 <beaky> what is a filepath
10:47:26 <danharaj> type FilePath = String
10:47:29 <beaky> ah
10:48:00 <ParahSailin> @ty fmap
10:48:01 <lambdabot> on the commandline:
10:48:01 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
10:48:13 <Sonderblade> how do you define a type that is either a 2-tuple or nothing?
10:48:23 <ParahSailin> @ty Prelude.fmap
10:48:25 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
10:48:25 <jmcarthur> you could use Maybe
10:48:30 <jmcarthur> Sonderblade: ^^
10:48:47 <Sonderblade> yes, but how?
10:48:58 <jmcarthur> Maybe (a, b)
10:49:36 <ParahSailin> @ty mapM
10:49:37 <jmcarthur> :t Just ("foo", False)
10:49:37 <lambdabot> on the commandline:
10:49:37 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
10:49:38 <lambdabot> Maybe ([Char], Bool)
10:49:44 <jmcarthur> :t mapM
10:49:45 <lambdabot> on the commandline:
10:49:45 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
10:49:47 <jmcarthur> :(
10:49:49 <ParahSailin> @ty Control.Monad.mapM
10:49:51 <lambdabot> forall (m :: * -> *) a b. Monad m => (a -> m b) -> [a] -> m [b]
10:50:28 <fryguybob> Sonderblade: Are you confused on how to make values of that type?
10:50:30 <ParahSailin> @ty (>>=)
10:50:31 <lambdabot> forall (m :: * -> *) a b. Monad m => m a -> (a -> m b) -> m b
10:50:39 <Sonderblade> jmcarthur: it gives me Couldn't match expected type `Maybe (Int, Int)' with actual type `(t0, t1)' In the third argument of `Game', namely `(3, 3)'
10:50:48 <hpc> -foleg-exts
10:50:50 <fryguybob> Sonderblade: Just (3,3)
10:51:11 <jmcarthur> Sonderblade: sounds like you need to use concete types, not just a and b
10:51:28 <jmcarthur> Sonderblade: it suggests Maybe (Int, Int), so perhaps that's what you want
10:52:07 <jmcarthur> oh i see
10:52:13 <jmcarthur> what fryguybob said is what you want to do
10:52:20 <jmcarthur> don't just use a tuple, use Just that tuple
10:52:38 <fryguybob> > let f (Just (a,b)) = a+b; f Nothing = 0 in f (1,2)
10:52:39 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe (a0, a0)'
10:52:40 <lambdabot>              with ...
10:52:48 <fryguybob> > let f (Just (a,b)) = a+b; f Nothing = 0 in f (Just (1,2))
10:52:50 <lambdabot>   3
10:55:15 <ParahSailin> @ty Control.Monad.liftM
10:55:16 <lambdabot> forall (m :: * -> *) a1 r. Monad m => (a1 -> r) -> m a1 -> m r
10:55:40 <beaky> what functions can work in a IO [a]?
10:56:00 <beaky> @hoogle (a => m b) -> m [a] -> m ()
10:56:00 <lambdabot> Parse error:
10:56:00 <lambdabot>   (a => m b) -> m [a] -> m ()
10:56:01 <lambdabot>      ^
10:56:06 <beaky> @hoogle (a -> m b) -> m [a] -> m ()
10:56:07 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
10:56:07 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
10:56:07 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
11:37:51 --- topic: '["GHC 7.6.1 http://v.gd/CEBRVo ","Haskell Platform 2012.2: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]'
11:37:51 --- topic: set by monochrom on [Fri Sep 14 12:57:21 2012]
11:37:51 --- names: list (clog Vert mizu_no_oto tech2 takuan nomeata warp edwardk ivanm mcstar BlankVerse jrslepak bps Shou linduxed donri ChristianS lambdanaut RenJuan ceii saiko-chriskun mysticc jfischoff lpsmith SLi loserone bananagram deleuz bxx Razz_ mertsas_ sbahra Eliel_ liyang_ baguasquirrel Boney zaiste_ jlewis_ kloeri dilinger_ rtharper Fuuzetsu_ FUZxxl_ jackhill_ dino-_ average_1rifter kobsu_ GHAI_ akamaus realityg1ill prophile_ amiri michaf2 CindyLin1 florent__ aliak_)
11:37:51 --- names: list (ousado knz_ mlinksva_ Natch [1]root_byte newsham sepp2k1 schovi xinming_ pramatias_ tenmilestereo mitchell strg_ mceier beaky danharaj tiripamwe peterhil gabor leoncame` Maarten_ flux fayden lolcathost yitz copumpkin Corey Tukeke davean mjo_ milessabin_ stat_vi jrajav inaimathi kadoban Sorella_ td123 hamishmack cmccann bytbox niloc132 jssanders rafter amathew Box_ daniel_karlsson efie joeytwiddle u_ jamii owst thetallguy josephle F1skr mauke tcsavage jpeeters)
11:37:51 --- names: list (fliip _alex86_ julmae- ceii_ jonkri perspectival estebistec hiptobecubic TEttinger carlocci tomboy64 sajith wtetzner moment geisthaus moobull569 sclv heruur Jesin doomlord_ cognominal blbrown_win3_ Expez kuribas ninzine julmuri watwat bbee tuxit latro`a sarfraz hallski PhilRod hughfdjackson threedaymonk tensorpudding robstewartuk whaletechho staafl morazow bitonic Icewing Earnestly niklasb MayDaniel emmanuelux [[zz]] ksf isomorphic whiteline arneis iago yanne)
11:37:51 --- names: list (hc Reite mschneider aa47f8 srhb chr1s weie zhulikas araujo einsof alanz master_of_master SoupEvil Kuraitou DexterLB birkenfeld edon Vorpal Alice3 danvet Paprikachu path[l] albel727 neutrino_ GnomeStoleMyBike agumonkey irclog0 Darkflux io2 pcapriotti hrehf phyrex1an jewel Palmik kennyd Estrellas janbanan ctype_real cdidd Raynes hiroaki MnO2 Guest___ Psamathos nus c_wraith ofan siracusa tongmomorel gentleben stephenjudkins nexx shergill augur otto_s LAMMJohnson)
11:37:51 --- names: list (Cale dmarker stupidman monochrom Hasselsaurus XWNH k00mi ku sipa lightquake Gracenotes schroedinbug1 _jwest ulfdoz et09 pxdr fgomez Nisstyre ISF JaffaCake1 favonia Swizec merijn tahu Philonous ParahSail1n bapa Sonderblade stepcut totte Nimatek Rotaerk otters dreixel electrogeek gbarboza blackrain jrockway_ pqmodn_ aszlig Gothmog_ Polarina PocketsizeIslam perlite Philippa SyntaxNinja Ralith mrlemao` ether0 demolith1 pikhq filkr ClaudiusMaximus cl_away elixey)
11:37:51 --- names: list (sclv_ ortmage ozgura matthiasgorgens1 sykora realnot mateu stevej miasma ricky munro zyg nsxt bscarlet joehillen rfw fuho vortexion alek_b canta bentham timemage barrucadu tgeeky MrFahrenheit adimit AntiSpamMeta fcr Nanar Adeon\SIGSEGV kevinqcs Mortchek knyppeldynan wto anders^^ ilias tavelram A1kmm jamy23 Jetbeard ido Starfire bduc mornfall Tehnix zoktar \rs Jonno_FTW wtw dalaing FireFly levi` BMeph dolio gwern lispy Stone_ parcs` niteria milli gienah)
11:37:51 --- names: list (aleator sohum hamilyon Khisanth noam_ tempire caleb_9_ jmcarthur crdueck Excureo spacepluk colock gbeshers tsou stelleg alaski verrens xplat DustyDingo neptunepink lambdabot brisbin sonOfRa junsuijin Jafet machisuji reacocard faybot _flow_ arlinius dabradley lomeo dumbhat jonke andrewffff heathjs gfredericks phirox othiym23 dada-cetacean CoverSlide guymann netj covi [mth] simpson frontendloader appamatto quicksilver maloi0 bcoppens tamiko kkris simon s4msung_)
11:37:51 --- names: list (hyko Belgarion0 kakos ajcave_ Nafai wjlroe Will| pettter _janne kc8qvp_ con JamesJRH_ Spockz solarus warpy VZakharov waterlaz Rogach notdan andkal isaacmk Tesseraction imphasing bd_ em fotc akosch Elemir wchun deggis estulticia kini antistrom KitB Enigmagic Plex- aniero fergusnoble nand` qwandor Valodim bookerz Minos strager Eridius djahandarie Excedrin mullein frio rhodesd harrison ahkurtz Jaxan mrpantoufle sjl wormphlegm statusfailed spacekitteh tew88)
11:37:51 --- names: list (Nemykal_ jweijers mapreduce tmiw yiannis_t pr lil`nbv4 tessier ivan\ minsa plat0 \stro capisce hvr noplamodo_ bgamari mlh Mon_Ouie tomaw ilya_ wagle_ yeltzooo smerz hive-mind `bps gtmanfred s_quark mgq Soft whoops nonymousa KBme acfoltzer jtannenbaum Internet13 maurer nominolo ParahSailin etrepum Nshag shepheb alech Bwild ben franny solirc eskimod_ MK_FG Paks Adios_ dogmaT jrib snorble_ ivan mortberg_ MetaCosm sully EvanR2 fengshaun_ lrvick torkjak yan_ DT__)
11:37:51 --- names: list (sm dfletcher__ dimka ethercrow Kuba_ reinoud mjo hpc thetallguy1 rahul TML dmwit Taggnostr2 freels purefn myme nimred mndrix Megant vmeson sp3ctum comak arnihr f4m8 lnostdal alang__ Twey osfameron __name__ hundskatt Erstarrung cods petekaz troydm Nik_89 OnionKnight twice11 fmap c9s hayashi puzza007 felipe_ xvilka aforemny jrk_ mefisto shachaf hanDerPeder qtplatypus mcsmash willb Dtgr drdo cYmen Ulrar NullSoldier Ghoul xaimus tswett chirpsalot brandonw1 ptek_)
11:37:51 --- names: list (bogner drek Daroth gereedy Nereid BlastHardcheese sunnavy elgot bartavelle SimonRC taruti thomas mvj4 arkx tazjin mroman Y0Gi zygoloid saurik Iceland_jack cynick opqdonut thoughtpolice fxrh tsuraan mm_freak Boreeas js947 Varakh ion freiksenet gdsx shutdown_-h_now iulian wumpus tdammers cjay smarter ghorn yader schlumpi gseitz mikeplus64 Arnar Igloo jaj KitB_ mzarella scgilardi Dybber majoh idnar boyscared CosmicRay Ptival geekosaur alpounet fall_ yam Ke kaol)
11:37:51 --- names: list (bezik fryguybob brainproxy ReinH deavid mux cow-orker confound Sagi monique_ ocharles ahf nlogax tobiassjosten pyrtsa larsrh wires koninkje_away dom96 jlouis rwbarton koala_man Saizan agundry kanzure ivan` edenc sixohsix jrslepak_neu mjhan Ferdirand identity petanqk a11235 `0660 Gilly absence f8 sunhay lulf danr canvon tvaalen_ fabjan Deewiant phrst malorie Athas drmegahertz arcatan XMunkki jliikka mjr84 froztbyte Guest18570 peltchu And[y] Phlogistique ccxCZ)
11:37:51 --- names: list (qasi alexanderte zomg joachifm_ suiside_ simply-c1ris Fluky jml certainty shajen ft tkataja gdeest integral Counter-Strike ByronJohnson MasseR tridactyla dixie_ shrimpx kleini\ dqd robbert zebr gds ethereal sunfun simon__ zeiris edwtjo noj chee1 aar tg Jello_Raptor asjo qwr Dodek mmaruseacph2 xymox ibid lokydor_ fireglow _1amzave Maxdamantus Jonte mahogny uogl jerojasro zenzike dottedmag ski matzo_ mietek pnielsen thirsteh decltype nicoo ZsoL anonus bylzz)
11:37:51 --- names: list (pyykkis ique elliottcable kalven MrMeh enkomax icambridge thorkilnaur_ eyck xnyhps DrSyzygy wereHamster ziman ehamberg k0ral ray Innominate pckt byorgey tomprince Derander plhk SHODAN Clint bens kosmikus dkasak mike2 Entroacceptor pharaun jix luite Cerise mixi profmakx __class__ SegFaultAX tlockney mimi_vx ptrf Laney ahihi2 marienz dcoutts sagelywizard faen appelton Cryovat davorak sordina Hugglesworth descender Baughn ps-auxw nu11ptr Botje jyyou alcz nwf)
11:37:51 --- names: list (rofer Draconx caligula__ flori tumdum fionnan joeyh klugez limetree JoshuaA_ kranius Liskni_si rcj_ zakwilson Amadiro callen mjrosenb Bigcheese saiam Gurragchaa nkpart Raynos dwierenga tomku ggreg geoffh slowpoke Vq earthy hiredman McManiaC blackmirroxx sysop_fb lpvb Martty vobi LeNsTR inr magicman jrm2k6 theorbtwo Silox| Nickeeh anachron mkaito voyd jabirali djanatyn tromp__ shoerain LeninParty EvanR wilfredh Xorlev mimico kallisti andrewsw pdxleif Viesti)
11:37:51 --- names: list (__main__ Dashkal tomh Draggor drewr tafryn KaneTW otterdam aninhumer nathanel_ cebewee popx fxkr zorzar drbean Eiam norm2782 joni6128 @ChanServ mantovani jaspervdj Ornedan hpd _br_ idoru amiller lazard Obfuscate Jaak rking lopex Lemmih int-e AtnNn upgrayeddd colah beekor dibblego The_third_man ccasin dropdrive davorb aristid-ic_ seats fds si14 SeanTAllen kopi brett raek KaiSforza mokus companion_cube mendez chra jgr quaestor mechairoi frigga1 kniu hackagebot)
11:37:51 --- names: list (BrianHV mrdomino lewurm codertux emias def-lkb adnauseam Tene peddie gemelen robinbb copton jayne brixen hpaste mrd bxc finnrobi PHO_ mrshoe ciaranm guerrilla)
11:37:55 <ClaudiusMaximus> hpc: my current code just picks an arbitrary number of points and approximates with line segments, which leads to points near the curve incorrectly labeled as outside
11:37:55 <threedaymonk> (correction: Parser String, not Parsec String)
11:40:19 <ClaudiusMaximus> hpc: so i mean to do something like "find the curve segments that intersect with a line segment from a 'known inside' point, subdivide those curve segments and repeat until the intersecting curve segment is small compared to its distance from the point to be labeled"
11:41:26 <hpc> ClaudiusMaximus: any chance you could change your representation of the curve?
11:41:27 <ClaudiusMaximus> the convexity means that if a point is determined to be inside at one level of subdivision, it'll also be inside all subsequent subdivisions
11:41:33 <ClaudiusMaximus> hpc: no
11:42:11 <hpc> hmm
11:42:17 <rwbarton> i wonder whether the path integration approach would actually be feasible
11:42:24 <hpc> you can't even guarantee that f is continuous, with that definition
11:42:42 <ClaudiusMaximus> hpc: well, the f isn't arbitrary
11:42:59 <hpc> but yeah, if you can get it into any other form than (R -> Point), there's loads of good math you can do
11:43:23 <ClaudiusMaximus> hpc: it's the boundary of a component of the mandelbrot set, which i can compute for a particular t using newton's method..
11:43:37 <rwbarton> i guess this ignores the "one function, many points" aspect of the problem
11:43:47 <hpc> ah, that makes more sense now
11:44:41 <crdueck> I need something similar to msum that looks into a data structure like Foo a b = Foo (Maybe a, b) and does what msum would do based on the first part of the tuple in Foo. Is it possible to make Foo a MonadPlus instance or should I just write a helper function?
11:45:45 <hpaste> ClaudiusMaximus pasted “curve subdivision artifacts” at http://hpaste.org/77206
11:46:08 <ClaudiusMaximus> the '?' on the right should ideally be fewer
11:47:16 <Ralith> threedaymonk: what Haskell book are you reading?
11:47:34 <hpc> oh, if you are separating points into (inside / outside / near), there's a method that can turn your function into a bezier, given that the details don't vary too wildly
11:48:07 <hpc> give it enough points that you can control the error between the spline and the real function, then approximate with an easier method of finding distance from the curve
11:48:57 <threedaymonk> Ralith: none as such. I'm trying to work things out from the documentation.
11:49:06 <Ralith> @where lyah
11:49:06 <lambdabot> http://www.learnyouahaskell.com/
11:49:11 <Ralith> threedaymonk: ^
11:49:23 <Sonderblade> fryguybob: how should you use JsonPair?
11:49:50 <threedaymonk> Ralith: though I have read both that and RWH in the past.
11:50:46 <Ralith> threedaymonk: are you sure? the problem you're having indicates that you're missing knowledge they cover carefully.
11:50:55 <ClaudiusMaximus> hpc: makes sense i guess - got any libraries to recommend for this?
11:52:21 <efie> writing and accessing mutable IOVector happens in constant time, doesn't it? I'm wondering because there are no O(x) annotations  at http://hackage.haskell.org/packages/archive/vector/0.10.0.1/doc/html/Data-Vector-Unboxed-Mutable.html
11:52:42 <hpc> ClaudiusMaximus: sadly, i barely even remember the math :P
11:52:49 <hpc> i would have to re-derive it on a less sleepy day
11:53:19 <bxx> i am struggling to implement scanr. anyone has an example?
11:53:28 <threedaymonk> Ralith: well, it was a few years ago. I'm trying to actually use Haskell by implementing a real problem I have, which is the only way I'm ever going to learn it.
11:53:50 <ClaudiusMaximus> hpc: heh, ok - i guess i'll try to implement the line segment tree thing first
11:53:53 <Ralith> threedaymonk: in any case, I recommend reviewing the chapter(s) on monads.
11:57:31 <fryguybob> Sonderblade: encode (JustP 1 2) ==> "[1,2]"
11:58:36 <fryguybob> Sonderblade: If you want you can make a mapping back and forth from Maybe (a,b) with:  f Nothing = NullP; f (Just (a,b)) = JustP a b
11:59:06 <jmcarthur> efie: yeah, it should be constant time to access and modify elements in a mutable vector
11:59:45 <efie> jmcarthur: ok, thanks for clarifying
12:02:22 <Sonderblade> fryguybob: i meant how to construct the type
12:03:35 <fryguybob> Sonderblade: Both the examples I gave construct values of type JustPair.
12:04:51 <threedaymonk> Ralith: turns out I knew what I was doing after all. I'd just typed the wrong thing :-)
12:05:28 <Ralith> hah
12:05:29 <threedaymonk> I had "a <- foo" then "return $ MyConstructor foo" which is obviously daft!
12:05:30 <Ralith> nice
12:05:32 <Sonderblade> fryguybob: i know but im trying to include a pair in a record type too
12:06:01 <Ralith> threedaymonk: I'd just use liftM or fmap here, though.
12:06:48 <threedaymonk> It's a sequence in Parsec so I think I have to use a do (unless you know better!)
12:06:57 <fryguybob> Sonderblade: Where you would want to write ":: (a, b)" write ":: JsonPair a b"
12:08:15 <hpaste> threedaymonk pasted “parsec custom data type” at http://hpaste.org/77207
12:08:42 <Sonderblade> fryguybob: yeah that's what im trying: No instance for (Data (JSONPair Int Int)) arising from the 'deriving' clause of a data type declaration
12:08:44 <threedaymonk> Ralith: open to improvements re the above paste
12:09:06 <Ralith> threedaymonk: you never "have to use a do"
12:09:17 <Ralith> threedaymonk: do is syntatic sugar for >> and >>=
12:09:51 <threedaymonk> Ralith: right, but I mean, would those be an improvement?
12:10:03 <Ralith> no, it has no bearing on my suggestion :P
12:10:35 <Ralith> in that case it looks like the explicit approach is more practical, anyway
12:10:57 <threedaymonk> I do tend to prefer code I can read :-)
12:12:06 <fryguybob> Sonderblade: You probably need {-# LANGUAGE DeriveDataTypeable #-} and add Typeable to the deriving list for JsonPair.
12:14:54 <Sonderblade> fryguybob: i got that, still no dice
12:17:48 <fryguybob> Sonderblade: You'll have to paste (to hpaste.org) more information like the error message and the code it refers to.
12:21:20 <mrlemao`> pheew: "ghc: panic! (the 'impossible' happened)"
12:24:06 <rui> hi
12:24:24 <rui> ??
12:24:26 <rui> »»
12:24:33 <simpson> rui: Yes hello.
12:24:49 <rui> im portuguese
12:24:56 <rui> and i need help
12:25:08 <rui> i dont understand nothing of haskell
12:25:33 <rui> please
12:25:46 <ion> @where lyah -- rui
12:25:46 <lambdabot> http://www.learnyouahaskell.com/
12:25:46 <rui> tutorials in haskell
12:25:51 <rui> where i find
12:26:02 <mrlemao`> How can I automatically derive Binary for a data family instance?
12:26:41 <rui> lambdabot i have this
12:26:59 <rui> but is in inglish and i am bad
12:27:08 <hpaste> mrlemao pasted “Data.DeriveTH on data families?” at http://hpaste.org/77210
12:27:11 <rui> very bad in inglish
12:27:14 <rui> :9
12:27:58 <dmwit> rui: You might ask in #haskell-br instead.
12:28:03 <dmwit> (As I think I suggested before.)
12:28:31 <hpaste> sonderblade pasted “JSONPair” at http://hpaste.org/77212
12:28:33 <dmwit> mrlemao`: If you get a panic, you should report it, especially if it's reproducible on the newest GHC.
12:28:35 <rui> yes
12:28:42 <Sonderblade> fryguybob: see paste
12:28:48 <rui> i have in portuguese
12:28:56 <rui> but i need exercices
12:28:58 <dmwit> mrlemao`: I don't know whether you can derive Binary in general, but if you can, then you might like to try StandaloneDeriving.
12:29:13 <sclv> this uses ndm's derive packge
12:29:20 <sclv> which uses template haskell
12:29:28 <sclv> and which i'm betting just can't handle data families
12:29:48 <dmwit> That wouldn't surprise me at all, either, if it's not something built in to GHC.
12:29:58 <dmwit> In fact, it wouldn't even surprise me if standalone deriving couldn't handle data families.
12:30:16 <fryguybob> Sonderblade: line 20 should be JustP 3 3
12:30:17 <sclv> sadly you'll have to write a binary instance by hand
12:30:39 <mrlemao`> dmwit: it works for regular data types
12:31:20 <sclv> mrlemao`:  yes it does. but data families are relatively new and as i recall not fully supported by th until recently if at all
12:31:32 <sclv> i really wouldn't expect the derive package to work with them
12:31:39 <hpaste> mrlemao pasted “data family Binary derive compile error” at http://hpaste.org/77214
12:31:41 <Sonderblade> fryguybob: score = GameScore (JustP 3 3)?
12:32:25 <dmwit> Oh, this doesn't even have anything to do with data families.
12:32:44 <dmwit> You just can't use '' to turn a whole type-level expression into a name because... well, because an expression is more complicated than a name.
12:33:10 <hpaste> mrlemao pasted “data family Binary derive compile error2” at http://hpaste.org/77215
12:33:13 <fryguybob> Sonderblade: Yes
12:33:39 <dmwit> You wouldn't be able to derive makeBinary (''Cat ()) either, if Cat were a parameterized type.
12:33:41 <mrlemao`> dmwit: whatis the solution?
12:33:56 <mrlemao`> type CatCmd = Command Cat?
12:34:09 <dmwit> Hack derive yourself to take something more than just a name, or write the instance by hand.
12:34:54 <mrlemao`> dmwit: the above alias gives :   ghc: panic! (the 'impossible' happened)
12:35:20 <mrlemao`> dmwit: ok, I will look into those options. Thanks
12:35:35 <dmwit> You should *also* minimize the panic'ing example as much as you can, and report it to GHC Trac.
12:36:11 <dmwit> ("panicking"? just looks wrong...)
12:36:23 <hpaste> gertc pasted “What am I doing wrong?” at http://hpaste.org/77216
12:37:25 <Sonderblade> fryguybob: that works, but the data encodes to {"ft":{"JustP":[3,3]}} and {"ft":"NullP"} instead of {"ft":[3,3]} and {"ft":null}
12:37:43 <dmwit> gertc: strange
12:37:50 <dmwit> Do you have a .ghci that's doing weird things?
12:38:22 <gertc> only that it does not find some modules
12:38:36 <dmwit> no, no
12:38:41 <dmwit> Do you have a file named .ghci?
12:38:41 <fryguybob> Sonderblade: Well I think if you uses generics to encode you are not going to get your hand written JSON instance.
12:38:46 <gertc> :browse Data.Maybe works
12:39:22 <gertc> ghc-pkg list notting red facebook listed
12:40:03 <dmwit> Is this a literal transcript, or are you cheating us at all?
12:40:06 <beaky> wwhat is the etymoogy of monad
12:40:12 <beaky> etymology*
12:40:31 <hpaste> gertc annotated “What am I doing wrong?” with “What am I doing wrong? (annotation)” at http://hpaste.org/77216#a77217
12:41:09 <dmwit> gertc: That output looks fine.
12:42:11 <dmwit> You might try "ghc-pkg check". Also, do tell us if you have a .ghci file.
12:42:13 <Sonderblade> fryguybob: i found another json parser aeson which seem to do what i want out of the box
12:42:53 <gertc> ghc-pkg check only gives haddock warnings
12:43:12 <gertc> no .ghci
12:44:47 <hpaste> gertc annotated “What am I doing wrong?” with “What am I doing wrong? (annotation) (annotation)” at http://hpaste.org/77216#a77218
12:45:24 <mrlemao`> dmwit: just reported the GHC issue. Thanks
12:45:42 <dmwit> gertc: yeesh
12:45:45 <dmwit> Anyway, very strange.
12:46:07 <sp3ctum> is it possible to configure GHCi not to display all imported module names before the command line?
12:46:36 <dmwit> sp3ctum: :set prompt "> "
12:47:58 <gertc> if you cabal install facebook can you browse Facebook using ghci 7.6.1?
12:48:11 <sp3ctum> thankyou dmwit
12:48:26 <gertc> sorry i ment cabal install fb
12:51:28 <dmwit> Hot damn there's a lot of dependencies for that package.
12:51:47 <gertc> sorry :)
12:53:16 <byorgey> gertc: the fb package is a bit more low-level than that.  It lets you interact with (some parts of) the Facebook API
12:53:30 <byorgey> but the Facebook API is considerably more low-level than "browse Facebook"
12:53:39 <dmwit> byorgey: He means :browse Facebook
12:53:45 <dmwit> as in his hpaste
12:53:52 <byorgey> ohhh hahaha
12:54:11 <byorgey> should have read further back =)
12:54:39 <dmwit> It's a very puzzling hpaste. It's essentially "cabal install fb; ghci; :browse Facebook" and ghci says "no" even though "cabal install" said "yes".
12:54:55 <dmwit> (and the fb package does indeed expose a Facebook module, according to Hackage)
12:55:39 <gertc> and ghc-pkg list said yes also :)
12:55:46 <dmwit> right
12:56:32 <dmwit> Thank $DEITY for cabal-install; I can't imagine how quickly I would have gotten frustrated tracking down dependencies for this. I kicked it off ten minutes ago and it's still going strong!
12:57:16 <dmwit> gertc: Yes, I can :browse Facebook.
12:57:37 <gertc> doh :/
12:58:26 <gertc> i also tried ghc-pkg recache --user
13:00:45 <hpaste> gertc annotated “What am I doing wrong?” with “What am I doing wrong? (annotation)” at http://hpaste.org/77216#a77219
13:01:05 <dmwit> gertc: You could try something like ghc -v3 -e 'import Facebook; main = return ()' maybe.
13:01:14 <dmwit> I don't hold a lot of hope that will tell anything useful, though.
13:01:42 <dmwit> Oh, I see that was your next idea, too. =)
13:01:58 <monochrom> OK, you have too many packages, not too few, that's the problem
13:02:32 <monochrom> for example "package template-haskell-2.8.0.0-081a3c421c0e633e9f90f3703d633ddb is shadowed by package template-haskell-2.8.0.0-95daa33759140e02b4660d35e61d8fe3" is the problem
13:03:17 <dmwit> Why did ghc-pkg check not print these problems?
13:03:17 <monochrom> unless you are a cabal expert, never permit duplication of libs that already come with GHC, such as template-haskell
13:03:53 <monochrom> because ghc-pkg check is incomplete. this is why I don't even try. I go straight to "ghc -v", nails the problem
13:04:20 <gertc> what is teh best way to remove every packge and start over?
13:04:27 <monochrom> http://www.vex.net/~trebla/haskell/sicp.xhtml for more recipes for similar problems
13:04:53 <byorgey> gertc: rm -rf ~/.ghc
13:05:13 <gertc> i installed my ghci in there too :)
13:05:25 <byorgey> what?
13:05:34 <monochrom> you can select something inside .ghc to erase
13:05:42 <byorgey> what do you mean by "installed your ghci in there"?
13:05:49 <gertc> ./configure --prefix /home/gert/.ghc :)
13:05:57 <byorgey> oh. that's a bad idea.
13:06:16 <byorgey> .ghc is just supposed to be for your local package databases
13:06:42 <byorgey> but in any case, yeah, you can rm -rf  ~/.ghc/<arch>-<version>
13:06:47 <kinslayer> Hi I am very new to haskell, but I really like the language a lot, although I am constantly getting reminded that I do not know very much about it, I do for instance have a problem with something I am playing with right now
13:06:58 <byorgey> e.g.  rm -rf ~/.ghc/x86_64-linux-7.6.1
13:07:30 <kinslayer> that is when I say import System the compiler complains that it is a hidden member of haskell98-2.0.0.1
13:07:38 <gertc> do i need to remove somthing in the .cabal directorie too? or is that just archive?
13:07:58 <byorgey> kinslayer: 'System' is an outdated name.  Instead you should use  System.Environment or System.IO or something
13:08:05 <byorgey> kinslayer: it depends what you are trying to import
13:08:12 <byorgey> gertc: no
13:08:18 <gertc> ok thx
13:08:36 <kinslayer> byorgey I try to import getArgs
13:08:40 <byorgey> gertc: ~/.cabal is mostly just a cache of downloaded packages,
13:08:53 <dmwit> I wonder how GHC HQ would feel about a ticket complaining that ghc-pkg check is incomplete. =)
13:08:53 <byorgey> @hoogle getArgs
13:08:53 <lambdabot> System.Environment getArgs :: IO [String]
13:08:54 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
13:09:04 <byorgey> kinslayer: ^^^ you want  System.Environment
13:09:09 <jfischoff> is there a way to cast a data kinded type to * ?
13:09:35 <kinslayer> byorgey: Thanks :D
13:09:47 <dmwit> jfischoff: simple, just lift unsafeCoerce...
13:10:01 <dmwit> jfischoff: The usual trick is to use data Proxy a = Proxy, along with PolyKinds.
13:10:27 <jfischoff> how does that work?
13:10:28 <byorgey> jfischoff: not as such, but as dmwit suggests there are usually ways to accomplish whatever you are trying to accomplish
13:10:29 <dmwit> Then Proxy :: k -> *
13:10:45 <dmwit> which looks like a cast. =)
13:11:15 <dmwit> I think Proxy may even be a blessed part of the libraries that ship with GHC by now...?
13:13:21 <jfischoff> huh it think that worked, but I'm not really sure I get it ;)
13:13:28 <bxx> chr $ ord char + number  <- is there a shoter built in way of doing this?
13:13:52 <dmwit> bxx: Possibly, depending on the number.
13:14:07 <dmwit> It's sort of a questionable operation to do, though, really.
13:14:23 <bxx> it is a small Int, I am writing rot13 converter
13:14:44 <dmwit> ?where rot13
13:14:44 <lambdabot> (let e[a,b,c]=zip[a..c]$[b..c]++[a..]in map$fromMaybe<*>(`lookup`(e"anz"++e"ANZ")))
13:15:17 <bxx> yikes
13:15:29 <hpaste> rpglover64 pasted “Common.hs” at http://hpaste.org/77220
13:17:21 <hpaste> rpglover64 pasted “MapCountSpec.hs” at http://hpaste.org/77221
13:17:46 <hpaste> rpglover64 pasted “MapCountGen.hs” at http://hpaste.org/77222
13:19:26 <rpglover64> I'm having an issue where the typeclassed version of a function is causing a stack overflow (on a large enough input) but the manually inlined version isn't.
13:20:19 <ClaudiusMaximus> hpc: got the tree thing working http://mathr.co.uk/mandelbrot/2012-11-03_boundary_subdivision.svg
13:21:15 <kinslayer> That with the commandline arguments is another point at proving to myself that I really don't know very much haskell
13:21:56 <kinslayer> As my program works fine when I run it without trying to get the commandline args and compile, but when I try to get the commandline args it doesn't compile
13:22:49 <ClaudiusMaximus> @hoogle getArgs
13:22:50 <lambdabot> System.Environment getArgs :: IO [String]
13:22:50 <lambdabot> Graphics.UI.GLUT.Initialization getArgsAndInitialize :: IO (String, [String])
13:22:54 <bxx> here's how I did it. anything questionable besides being pretty inefficient?  http://hpaste.org/77224
13:24:39 <napping> well, toUpper and toLower are maybe a bit too fancy
13:25:30 <napping> *Main> map rot13 "Γ"
13:25:31 <napping> "*** Exception: Maybe.fromJust: Nothing
13:26:25 <bxx> | isLower c = rot13 $ toUpper c would have been nicer. how would you write it napping?
13:26:50 <kinslayer> Right so there probably two seperate problems I got, the most urgent is probably the one which is that my function takes an argument of type string, but getArgs  returns a [string].
13:26:54 <napping> well, I'm just saying that isUpper and isLower pass unicode characters of the appropriate case, which you don't have in your map
13:27:12 <bxx> ah
13:28:19 <gertc> works again :) after rm <arch>-<version> and cabal install fb
13:28:37 <napping> maybe something like rot13Table = zip ['A'..'Z'] alphaBetInRot13, and rot13 c = fromMaybe c (lookup c rot13Table)
13:29:09 <beaky> why does Data.ByteString.UTF8 not have the same methods as Char8
13:30:06 <monochrom> which method do you want?
13:30:29 <bxx> napping what about handling lower case characters? check for isAscii first?
13:30:42 <twmb> is there a way to do "x is NOT an element of ..." in a list comprehension?
13:30:44 <beaky> putStr, interact, etc
13:30:49 <beaky> readFile too
13:30:54 <napping> you could include them in the table, or just do arithmetic on ord
13:31:11 <simpson> twmb: Well, you use elem for that, right? So you could use "not . elem" instead.
13:31:30 <monochrom> you don't need UTF8 or Char8 for those
13:32:00 <beaky> I used to use plain [Char], but switching to Char8 speed things up by a factor of 50
13:32:04 <typoclass> > [x | x <- [1..10], (not $ elem x [3..6]) -- twmb
13:32:05 <lambdabot>   <hint>:1:49: parse error (possibly incorrect indentation)
13:32:29 <typoclass> > [x | x <- [1..10], (not $ elem x [3..6])] -- sorry, forgot a bracket
13:32:30 <lambdabot>   [1,2,7,8,9,10]
13:32:36 <rwbarton> @hoogle notElem
13:32:36 <lambdabot> Prelude notElem :: Eq a => a -> [a] -> Bool
13:32:36 <lambdabot> Data.List notElem :: Eq a => a -> [a] -> Bool
13:32:36 <lambdabot> Data.Foldable notElem :: (Foldable t, Eq a) => a -> t a -> Bool
13:32:51 <rwbarton> useful for infix
13:32:53 <typoclass> rwbarton: right, good point
13:33:27 <notdan> @src notElem
13:33:27 <lambdabot> notElem x =  all (/= x)
13:33:28 <twmb> typoclass: I haven't gotten to $ in list comprehension yet in LYAH -- what does it do?
13:33:33 <notdan> @hoogle all
13:33:34 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
13:33:34 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
13:33:34 <lambdabot> Data.Monoid All :: Bool -> All
13:33:49 <typoclass> twmb: oh, $ is just like parens :-) let me rewrite it
13:34:00 <byorgey> $ is NOT like parens
13:34:02 <notdan> Is there a reason why notElem is defined in terms of 'all'?
13:34:05 <byorgey> $ is function application.
13:34:12 <monochrom> I am saying you can just use putStr, interact, readFile from ByteString. I am not saying go back to [Char]
13:34:13 <typoclass> > [x | x <- [1..10], not (elem x [3..6])] -- equivalent
13:34:14 <lambdabot>   [1,2,7,8,9,10]
13:34:18 <byorgey> twmb: f $ x = f x, but $ has precedence level 0
13:35:19 <monochrom> s/ByteString/Data.ByteString/
13:35:34 <simpson> notdan: Probably for efficiency.
13:35:48 <simpson> That lets it short-circuit just like elem.
13:35:51 <simpson> @src elem
13:35:51 <rwbarton> beaky: are you still writing cat, or something else now
13:35:51 <lambdabot> elem x    =  any (== x)
13:36:37 <twmb> byorgey: so basically, evaluate the right side of $ before you treat them as arguments for the left side?
13:36:42 <beaky> still writing cat
13:36:47 <monochrom> "$ is like parens" is true when "parens means function application, think C"
13:36:49 <twmb> (I haven't reached precedence levels either, yet )
13:36:59 <typoclass> byorgey: i disagree a little, if you have "abc def ghi", it usually groups as "(abc def) ghi". if you want to group the other way, you either insert $ to get "abc $ def ghi" or you insert () as in "abc (def ghi)". in my view, yes, $ is function application, but that's really more of an implementation detail
13:37:11 <rwbarton> cat does not care about encoding
13:37:20 <beaky> ah
13:37:49 <rwbarton> so why not just use Data.ByteString.Lazy only
13:37:52 <byorgey> typoclass: my point is just that it is not that helpful to tell people that "$ is like parens" (which is vague and easily misinterpreted) when it is not much harder to tell them the actual definition instead.
13:38:37 <byorgey> typoclass: there are many other uses of $.  It is not just for grouping.  The fact that it is function application is not an "implementation detail", that's just what it is defined as.
13:38:40 <typoclass> byorgey: that's true, i was pretty sloppy
13:38:43 <byorgey> and it so happens it is useful for grouping.
13:39:14 <byorgey> twmb: precedence levels explains how expressions are parsed
13:39:35 <byorgey> twmb: for example, everyone knows that  4 + 3 * 5  means   4 + (3 * 5)  and not  (4 + 3) * 5, right?
13:39:42 <twmb> right
13:39:46 <monochrom> @quote monochrom lazy
13:39:47 <lambdabot> monochrom says: some kind of lazy evaluation is already known to highschool kids. teachers tell you that in a*(b+c), "evaluate b+c first", right? well, I challenge you to take 0*(389238493+97283748)
13:39:47 <lambdabot> and find one single student who faithfully evaluate 389238493+97283748 first.
13:39:49 <byorgey> twmb: in Haskell that's because * has a higher precedence level than +
13:40:04 <typoclass> byorgey: still, that definition "f $ x = f x" doesn't mean very much without saying that it's ultra-low precedence
13:40:11 <monochrom> actually I said something wrong in that quote
13:40:11 <byorgey> twmb: in particular * is level 7 and  + is level 6
13:40:27 <bxx> a nice example from LYAH how else $ can be used:  map ($2) [(+1),(^4),(*10)]   =>  [3,16,20]
13:40:31 <byorgey> typoclass: agreed.  and I did in fact say that.
13:40:49 <byorgey> twmb: well, $ is level 0
13:41:07 <twmb> bxx: what seccion?
13:41:09 <twmb> section*
13:41:11 <byorgey> twmb: which means, for example, that if you write   f $ 4 + 3 * 5   it means  f $ (4 + (3 * 5))
13:41:36 <bxx> twmb I don't know off hand
13:41:39 <byorgey> and since f $ x = f x, that is equal to  f (4 + (3 * 5))
13:41:57 <twmb> byorgey: as opposed to, say f is level 4, (f 4) + (3*5)?
13:42:03 <twmb> without the $?
13:42:11 <monochrom> f doesn't have a level
13:42:16 <byorgey> twmb: function application always has the highest precedence
13:42:17 <twmb> err
13:42:28 <twmb> (0?)
13:42:28 <byorgey> twmb: yeah, only infix binary operators have a precedence
13:42:40 <byorgey> 0 is lowest
13:42:43 <monochrom> you could say that " " has a level
13:43:02 <byorgey> twmb: so without the $  if you wrote  f 4 + 3 * 5  it means   (f 4) + (3 * 5), yes
13:43:14 <mrlemao`> is there a common pattern for callbacks in haskell? I need to split a piece of code in 2 and was the base part to call back to the custom part. All type safe, of course.
13:43:42 <lispy> let's see this lens action
13:43:47 <lispy> :t %!
13:43:48 <lambdabot> parse error on input `%!'
13:43:54 <lispy> :t (%~)
13:43:55 <lambdabot> forall s t a b. Setting s t a b -> (a -> b) -> s -> t
13:44:02 <monochrom> http://bm380.user.srcf.net/prettyparsetree.cgi shows you complete parenthesizing
13:44:05 <edwardk> :t (^.)
13:44:06 <lambdabot> forall s a t b. s -> Getting a s t a b -> a
13:44:11 <simpson> mrlemao`: As a great hacker once said, "If you have a function f, and some data x, and you need to pass that data into that function, perhaps the right thing to do is f(x)."
13:44:35 <byorgey> mrlemao`: use a higher-order function?
13:44:42 <byorgey> mrlemao`: i.e. a function which takes another function as an argument
13:44:54 <mrlemao`> simpson: :-) yes, that would be the solution if the contract btw the base and custom parts was a single function
13:44:54 <beaky> should I use ByteString.Lazy or plain ByteString
13:45:02 <edwardk> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
13:45:04 <lambdabot>   ("Jelly","world")
13:45:06 <byorgey> that's basically what a callback is, but without a fancy name because it's not fancy in Haskell =)
13:45:09 <lispy> beaky: it depends
13:45:22 <simpson> edwardk: Bless you!
13:45:33 <mrlemao`> The specific scenario here is Erlang's gen_server
13:45:49 <notdan> mrlemao`: try continuation passing style?
13:45:55 <lispy> beaky: lazy bytestrings are for when you need to stream the bytestring
13:45:56 <edwardk> > zipper ("hello","world") % fromWithin (both.traverse) % focus .~ 'J' % rightmost % focus %~ toUpper % rezip
13:45:58 <lambdabot>   ("Jello","worlD")
13:46:11 <notdan> Don't know how idiomatic that is tho
13:46:49 <lispy> edwardk: neat
13:46:55 <beaky> http://ideone.com/RU9eVo
13:47:00 <beaky> I think Lazy ones work
13:47:03 <mrlemao`> byorgey, simpson, notdan: in Erlang, you create a module with a few functions and some data types, you call back into a few generic server functions and the generic part calls the custom module back
13:47:17 <typoclass> mrlemao`: your function could take another function, e.g. "foo f = print (f 42)". if you really want, you could call "f" a callback in this case, but it's nothing special in haskell
13:47:18 <beaky> why should i use a Char8 bytestring rather than a Unicode one or a plain one though?
13:47:35 <lispy> beaky: oh, I think you want Text here
13:47:40 <rwbarton> they are all the same
13:47:45 <rwbarton> he is writing cat btw
13:47:49 <edwardk> :t  zipper ("hello","world") % down _1 % fromWithin traverse
13:47:51 <lambdabot> ((Top :> ([Char], [Char])) :> [Char]) :> Char
13:48:05 <edwardk> wish i could make :t not put in the annoying prophylactic parens
13:48:07 <monochrom> Text would be wrong for cat
13:48:07 <rwbarton> though i'm confused what is going on because that was the state a few hours ago and it seems nothing has changed at all
13:48:11 <lispy> rwbarton: yeah...I guess being able to cat a binary file is a good thing
13:48:14 <copumpkin> meow
13:48:16 <beaky> lol
13:49:00 <lispy> :t _1
13:49:00 <lambdabot> forall s t a b (f :: * -> *). (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
13:49:06 <rwbarton> Data.ByteString.Lazy.Char8 is just a different interface to the same lazy ByteString type
13:49:07 <lispy> :t _5
13:49:08 <lambdabot> forall s t a b (f :: * -> *). (Functor f, Field5 s t a b) => (a -> f b) -> s -> f t
13:49:12 <copumpkin> lispy: isn't it obvious?
13:49:16 <copumpkin> ;)
13:49:17 <edwardk> > ("hello","world","!!!")^._3
13:49:19 <lambdabot>   "!!!"
13:49:19 <lispy> > _5 (a,b)
13:49:20 <lambdabot>   Couldn't match expected type `a0 -> f0 b0'
13:49:20 <lambdabot>              with actual type `(...
13:49:23 <edwardk> > ("hello","world","!!!")^._2
13:49:25 <lambdabot>   "world"
13:49:27 <copumpkin> lispy: it isn't a function
13:49:29 <edwardk> > ("hello","world")^._1
13:49:31 <lambdabot>   "hello"
13:49:31 <copumpkin> at least not of that sort
13:49:35 <lispy> > (a,b)^._5
13:49:36 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field5
13:49:36 <lambdabot>                      (Debug.Sim...
13:49:44 <lispy> oh, cool so that's a type error
13:49:50 <edwardk> yep
13:49:56 <notdan> So those are the Lenses everyone been talking about..
13:50:00 <edwardk> there are instances for everything up to 9-tuples
13:50:01 <copumpkin> just athe answer is obviously just to write an instance of Field5 for (,)
13:50:10 <edwardk> notdan: yes
13:50:29 <lispy> copumpkin: right, and then take field 5 `mod` 2
13:50:35 <lispy> (zero indexed)
13:50:36 <notdan> I should read a tutorial on them sometime, looks quite funky
13:50:48 <copumpkin> notdan: if you aren't dan, who are you?
13:51:06 <monochrom> a function that maps dan to false
13:51:17 <lispy> We only allow dan and notnotdan (unless you can provide a specific witness of notdat)
13:51:20 <lispy> notdan*
13:51:37 <edwardk> you _can_ use the lens directly as a function, just pretend it was a funny form of 'traverse'
13:51:39 <edwardk> @type _2 putStrLn ("hello","world")
13:51:40 <lambdabot> IO ([Char], ())
13:52:02 <edwardk> @type traverse_ _2 putStrLn ("hello","world")
13:52:03 <lambdabot>     Not in scope: `traverse_'
13:52:04 <lambdabot>     Perhaps you meant one of these:
13:52:04 <lambdabot>       `Data.Foldable.traverse_' (imported from Data.Foldable),
13:52:05 <rpglover64> edwardk: Could using Data.Proxy cause a space leak?
13:52:06 <edwardk> @type traverseOf_ _2 putStrLn ("hello","world")
13:52:08 <lambdabot> IO ()
13:52:14 <dimka> Why all lens words are so short and only TRAVERSE is so TRAVERSE
13:52:14 <dimka> ?
13:52:28 <rwbarton> you have to traverse the whole word
13:52:31 <codan> lispy: so you have a witness of dan?
13:52:49 <edwardk> dimka: traverse is grandfathered in. otherwise it'd be 3-4 letters like all my others ;)
13:52:56 <edwardk> 'walk' or something =)
13:52:57 <lispy> edwardk: do you have a document somewhere explaining your heurstic for combinator naming? I thought I heard someone say that "~" always means the same thing in your lens library
13:53:00 <dimka> Could it be τ
13:53:00 <dimka> ?
13:53:01 <dimka> Please
13:53:12 <lispy> codan: good point. No, I don't.
13:53:35 <edwardk> lispy: operator~ and operator= are used consistently as the application of the lens to the target. the former is a function, the latter works as a state action
13:54:02 <edwardk> > _2 %~ length $ ("hello","world")
13:54:03 <lambdabot>   ("hello",5)
13:54:18 <byorgey> dimka: nothing's stopping you from defining τ = traverse and then using that
13:54:25 <lispy> oh, so that is set field 2 to be its length?
13:54:33 <edwardk> > _1 .~ "goodbye" $ ("hello","world")
13:54:35 <lambdabot>   ("goodbye","world")
13:54:35 <dimka> byorgey: only fact that this is redundant :[
13:54:38 <edwardk> yeah
13:54:48 <rwbarton> :t along
13:54:49 <lambdabot> Not in scope: `along'
13:54:51 <byorgey> dimka: also, traverse is not actually defined in the lens package, but in Data.Traversable
13:55:15 <lispy> edwardk: I should use your lens library to refactor my 6502 emulator. I use a lot of records in that.
13:55:29 <edwardk> .~ is 'set'   %~ is 'modify'   .= does so to a target in the current state, %= modifies part of the state,  +~ -~ *~, etc. all act like you expect. as do += *=, etc.
13:55:32 <lispy> hopefully by the time I did that I'd grok them a bit
13:55:42 <edwardk> :t (%)
13:55:43 <lambdabot> forall a b. a -> (a -> b) -> b
13:56:03 <edwardk> %~ is the use of that operator on the target of a lens
13:56:08 <edwardk> ::t (+~)
13:56:16 <edwardk> :t (+=)
13:56:18 <beaky> http://ideone.com/1oiZWV any ideas on making this as fast as the C version?
13:56:18 <lambdabot> forall s (m :: * -> *) a. (Num a, MonadState s m) => SimpleSetting s a -> a -> m ()
13:56:42 <edwardk> if you want the result as well, for say chaining assignment, you can use <operator~  or <operator=
13:56:43 <lispy> beaky: have you learned to use the profiler yet?
13:56:48 <rwbarton> what C version
13:56:48 <lispy> beaky: it's pretty amazing
13:56:51 <edwardk> :t let fresh = id <+= 1 in fresh
13:56:53 <lambdabot> forall s (m :: * -> *). (Num s, MonadState s m) => m s
13:57:07 <lispy> beaky: Please read this: http://book.realworldhaskell.org/read/profiling-and-optimization.html
13:57:17 <lispy> beaky: I think you'll like it
13:57:25 <Ralith> beaky: you need to use streaming I/O if you want to maximize performance
13:57:27 <beaky> right
13:57:33 <beaky> what's streaming IO
13:57:40 <lispy> have you folks started using ezyang's heap profiling website?
13:57:44 <Ralith> an involved subject
13:57:49 <rwbarton> you are using streaming IO already
13:58:01 <lispy> rwbarton: lazy IO, more like
13:58:04 <beaky> ah
13:58:12 <rwbarton> i assumed that was what Ralith meant, but maybe not?
13:58:16 <beaky> I just want to be as fast as C :(
13:58:21 <Ralith> rwbarton: they are different things.
13:58:21 <edwardk> ("hello",["world","!!!"],(), 32 :: Double)^..biplate :: [String]
13:58:24 <edwardk> > ("hello",["world","!!!"],(), 32 :: Double)^..biplate :: [String]
13:58:24 <lispy> lazy IO can be unsafe. Whereas, I think of streaming IO as approaches like iteratees
13:58:26 <lambdabot>   ["hello","world","!!!"]
13:58:32 <twmb> why can I not do "(take 1 [1..5]) : [2..20]"
13:58:34 <Sonderblade> with hxt, how do you remove prefix and suffix whitespace within tag values?
13:58:57 <notjoe> twmb: types don't really match up
13:59:00 <rwbarton> :t (^..)
13:59:02 <notjoe> take 1 [1..5] returns [1]
13:59:02 <lambdabot> forall s a t b. s -> Getting [a] s t a b -> [a]
13:59:06 <edwardk> twmb: because the result is a list with a single element, not the element. you can use ++ rather than : though
13:59:10 <rwbarton> :t biplate
13:59:11 <lambdabot> on the commandline:
13:59:11 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
13:59:12 <notjoe> [1] : [2..20] isn't obviously well typed
13:59:18 <notjoe> there's a way it can be, but you don't want that
13:59:21 <lispy> Sonderblade: I don't know. I prefer the 'xml' library on hackage. Then again, I don't know how to do what you want with it either.
13:59:23 <twmb> hmm
13:59:51 <edwardk> biplate :: (Data a, Typeable b) => Simple Traversal a b
13:59:52 <twmb> ah cool
14:00:12 <rwbarton> crazy
14:00:14 <twmb> I meant to be using !! but immediately forgot about me checking the types and continued on take 1...
14:00:15 <beaky> turns out the haskell version is faster than my naive C version
14:00:15 <twmb> thanks
14:00:18 <beaky> so I'm satisfied :D
14:00:35 <edwardk> its a generic programming tool to go find all the contents that have a given type. it works intelligently by building a 'hit map' of what types can't contain the target type and avoids traversing them
14:00:49 <edwardk> its based on the biplate combinator in neil mitchell's uniplate library, just faster
14:00:52 <lispy> beaky: there is a problem with your Haskell version.
14:00:52 <edwardk> and more flexible
14:01:02 <beaky> lispy: there is? how do I fix it
14:01:16 <lispy> beaky: Hmm...how to start explaining.
14:01:26 <edwardk> there is also uniplate :: Data a => Simple Traversal a a
14:01:37 <edwardk> which finds all the self-similar immediate descendants
14:01:48 <edwardk> so if you give me say, an expression it'll find all the immediate sub-expressions
14:01:50 <lispy> beaky: It starts to read immediately, but until it can finish passing all the input to the output it will keep the file handle open.
14:01:53 <edwardk> useful for generic traversals
14:01:58 <edwardk> :t rewriteOf
14:01:59 <lispy> beaky: It's not a big problem in this small example
14:02:00 <lambdabot> on the commandline:
14:02:00 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
14:02:04 <beaky> lispy: right
14:02:05 <edwardk> :t rewriteOf uniplate
14:02:05 <rwbarton> what else would it do
14:02:07 <lambdabot> forall a. Data.Data.Data a => (a -> Maybe a) -> a -> a
14:02:12 <lispy> beaky: But, if you extend your program much it could become a problem
14:02:24 <rwbarton> it will close the input file as soon as it reaches the end of the input file
14:02:30 <lispy> beaky: also, some people might expect your cat program to read the whole file so that you can write back to that file.
14:02:35 <beaky> right
14:02:46 <edwardk> that will let you apply a rewrite rule over and over recursively from the bottom of  a syntax tree up, until it no longer applies.
14:02:53 <edwardk> all you need to do is derive Data
14:02:54 <beaky> I need to refactor my silly cat program :D
14:03:01 <rwbarton> what is with these -fglasgow-exts errors
14:03:24 <edwardk> rwbarton: recent consequence of the upgrade to 7.4 and recompiling lambdabot or something
14:03:26 <twmb> so in LYAH it says that ++ isn't that great for concatenating long lists because it has to walk through every one
14:03:33 <rwbarton> is it just random?
14:03:34 <lispy> beaky: This article does a better job of explaining that I can do: http://www.haskell.org/haskellwiki/Iteratee_I/O
14:03:35 <edwardk> @let (&&&&) = uniplate
14:03:36 <twmb> is there any better way to concat a long list?
14:03:37 <lambdabot>  Defined.
14:03:39 <edwardk> :t (&&&&)
14:03:41 <lambdabot> forall a (f :: * -> *). (Data.Data.Data a, Applicative f) => (a -> f a) -> a -> f a
14:03:46 <rwbarton> :t rewriteOf
14:03:48 <lambdabot> on the commandline:
14:03:48 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
14:03:57 <startling> that's really odd.
14:03:59 <edwardk> it works only if you use an infix type right now
14:04:07 <edwardk> :t mapMOf
14:04:08 <codan> twmb: well, you can cons one element on the other list
14:04:08 <lambdabot> on the commandline:
14:04:09 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
14:04:11 <startling> :t (***)
14:04:12 <lambdabot> forall (a :: * -> * -> *) b c b' c'. Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
14:04:13 <rwbarton> it seems not to be random
14:04:15 <startling> huh.
14:04:17 <edwardk> :t (^?)
14:04:19 <lambdabot> forall s a t b. s -> Getting (First a) s t a b -> Maybe a
14:04:23 <rwbarton> :t div
14:04:25 <lambdabot> forall a. Integral a => a -> a -> a
14:04:32 <twmb> codan: I'm going to be concat'ing long lists
14:04:32 <edwardk> some built in stuff still works
14:04:35 <startling> :t `div`
14:04:35 <rwbarton> :t zip3
14:04:36 <lambdabot> parse error on input ``'
14:04:37 <lambdabot> forall a b c. [a] -> [b] -> [c] -> [(a, b, c)]
14:04:38 <codan> > cons (head [1..5]) [2..10]
14:04:40 <lambdabot>   Not in scope: `cons'
14:04:40 <lambdabot>  Perhaps you meant one of these:
14:04:40 <lambdabot>    `BS.cons' (importe...
14:04:42 <rwbarton> :t id
14:04:43 <lambdabot> forall a. a -> a
14:04:54 <codan> twmb: than you don't have much choice
14:05:00 <twmb> mmm
14:05:10 <twmb> shaznut
14:05:25 <edwardk> but it breaks randomly
14:05:25 <edwardk> :t Map.fromList [(1,2),(3,4)]
14:05:27 <lambdabot> Couldn't find qualified module.
14:05:31 <edwardk> :t Data.Map.fromList [(1,2),(3,4)]
14:05:33 <lambdabot> forall k a. (Num a, Num k, Ord k) => M.Map k a
14:05:36 <edwardk> > Data.Map.fromList [(1,2),(3,4)]
14:05:38 <lambdabot>   Not in scope: `Data.Map.fromList'
14:05:42 <edwardk> > Map.fromList [(1,2),(3,4)]
14:05:44 <lambdabot>   Not in scope: `Map.fromList'
14:05:44 <lambdabot>  Perhaps you meant one of these:
14:05:44 <lambdabot>    `M.fromLis...
14:05:47 <edwardk> > M.fromList [(1,2),(3,4)]
14:05:48 <lambdabot>   fromList [(1,2),(3,4)]
14:05:51 <lispy> beaky: another problem with lazy io: http://www.mail-archive.com/haskell@haskell.org/msg21782.html
14:05:55 <edwardk> > M.fromList [(1,2),(3,4)] ^.at 3
14:05:58 <lambdabot>   Just 4
14:06:14 <edwardk> > at 5 .~ 6 $ M.fromList [(1,2),(3,4)]
14:06:16 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe v0))
14:06:16 <lambdabot>    arising from a use o...
14:06:17 <edwardk> > at 5 .~ Just 6 $ M.fromList [(1,2),(3,4)]
14:06:18 <beaky> :(
14:06:19 <lambdabot>   fromList [(1,2),(3,4),(5,6)]
14:06:26 <edwardk> > at 5 ?~ 6 $ M.fromList [(1,2),(3,4)]
14:06:28 <lambdabot>   fromList [(1,2),(3,4),(5,6)]
14:06:39 <rwbarton> in this case none of these lazy IO boogie monsters are actual issues
14:06:47 <bxx> twmb what would be more efficient is constructing the end list element by element with (:). when you already have two lists it can't be done more efficiently though
14:06:54 <edwardk> sorry for the spam, wasn't sure how to access Data.Map
14:06:56 <typoclass> twmb: it's true that ++ will be slow for extremely long lists, but i'd recommend that you go ahead and use it. if you have profiled your program, and the measurements show that ++ is a bottleneck, you can still optimize it. (hint: i bet it won't be, i bet the bottleneck will be some other thing.)
14:07:34 <edwardk> :t setOf
14:07:35 <lambdabot> Not in scope: `setOf'
14:07:45 <edwardk> oh well, thats buried in a side module
14:07:45 <kennyd> typoclass is right, just use it it won't be the bottle neck vast majority of the time
14:07:56 <bxx> twmb here is a chapter talking about $ by the way: http://learnyouahaskell.com/higher-order-functions
14:08:04 <bxx> the
14:08:24 <twmb> ah thanks
14:08:27 <twmb> i'll get there today
14:08:46 <monochrom> "I'm concating long lists" is too little information to determine how to do it fast or even why you do it
14:09:29 <typoclass> monochrom: my lists are longer than your lists
14:09:44 <edwardk> > [1..]
14:09:46 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
14:10:02 <monochrom> "concat lists, then find its head" and "concat lists, then do FFT" have completely opposite solutions
14:11:20 <typoclass> monochrom: yup, therefore "do the simplest thing that could possibly work(TM)", then profile and speedificate
14:13:57 <bxx> here's my changed rot13. anything else that is questionable (besides it not being too efficiency). http://hpaste.org/77225
14:14:00 <lispy> typoclass: I'm doing that on some friends code now
14:14:12 <lispy> he wrote a physics sim using tuples
14:14:25 <twmb> I've been trying a lot of variations for the last 10 minutes
14:14:27 <lispy> I converted his lazy data structures to strict ones and asked the compiler to unbox them
14:14:36 <lispy> Just that much was about an order magnitude speed up
14:14:37 <twmb> how do you define a type as (Num, [Num]) -> Num
14:14:45 <lispy> Now I'm going to run the profiling to find out where it's slow
14:14:54 <edwardk> type Twmb = (Num, [Num]) -> Num
14:15:18 <Saizan> Num is not a type though
14:15:26 <edwardk> there is that. =)
14:15:31 <typoclass> lispy: nice! any chance of that story making it into a blog post? :-)
14:15:31 <edwardk> i just pasted his type =)
14:15:40 <byorgey> Num a => (a, [a]) -> a
14:15:54 <lispy> typoclass: perhaps. He shared it with me as a private repo so I don't know if I should share his code
14:16:02 <twmb> ahh thank you
14:16:07 <lispy> typoclass: But, the basic trick is one that I thought was well known (maybe not)
14:16:08 <typoclass> twmb: Num is a typeclass, not a type :-) you're probably looking for what byorgey said
14:16:23 <edwardk> newtype Twmb a = Twmb { runTwmb :: (a, [a]) -> a }    then later on work with values of type Twmb a   with a like constraint Num a => …. Twmb a …
14:16:29 <ChristianS> is the enumerator package a good alternative to lazy IO? or are there other solutions that are preferable/more popular?
14:16:44 <byorgey> twmb: do you really need a type that works with *any* numeric type?
14:16:53 <lispy> ChristianS: it's fine. There is the newer conduits. Never tried it.
14:16:54 <byorgey> or would some specific numeric type (like Integer or Double) work?
14:17:00 <twmb> byorgey: Integers
14:17:12 <byorgey> ok, so  type Twmb = (Integer, [Integer]) -> Integer  ?
14:17:25 <twmb> right ,
14:17:26 <startling> write it for Integer and then let the type-checker generalize the signature if it can.
14:17:26 <edwardk> and even that is probably better off curried
14:17:31 <edwardk> Integer -> [Integer] -> Integer
14:17:35 <byorgey> edwardk: g:t let fresh = id <+= 1 in fresh
14:17:35 <byorgey> (16:56) < lambdabot> forall s (m :: * -> *). (Num s, MonadState s m) => m s
14:17:35 <byorgey> (16:56) <     lispy> beaky: Please read this: http://book.realworldhaskell.org/read/profiling-and-optimization.html
14:17:52 <byorgey> whoops, that was my kid hitting buttons =P
14:17:56 <edwardk> hah
14:18:00 <nicoo> Hi; is there a lib around for generating a DFA from a context-free grammar, then minimizing it ?
14:18:06 <startling> byorgey, haskell prodigy?
14:18:17 * nicoo tried to diligently hoogle, without much results
14:18:23 <typoclass> byorgey: amazing spelling
14:18:24 <lispy> nicoo: maybe? There is a regex-dfa package on hackage
14:18:24 <ChristianS> lispy: thanks, i'll look at both
14:18:25 <edwardk> he's got the shape of the language down at least. good to see his first haskell code was written with lens
14:18:26 <byorgey> startling: of course
14:18:35 <startling> byorgey, he figured out the type of that expression in next to no time!
14:18:45 <byorgey> amazing, isn't he?
14:19:03 <twmb> I read the types and typeclasses about a month ago
14:19:05 <twmb> but I forgot it
14:19:14 <twmb> and had a busy month
14:19:24 <startling> twmb, typeclasses are constraints that many types can fit
14:19:27 <twmb> but now that I'm clear again, I wanted to try something before I re-read the types and typeclasses section
14:20:34 <shachaf> twmb: You should probably just forget about type classes and stick to concrete types, then.
14:20:49 <nicoo> lispy: Thanks for the pointer, but it doesn't look like it does what I need
14:21:33 <lispy> nicoo: happy might have an algorithm for it internally? Maybe you should write such a library and post it on hackage :)
14:22:23 <nicoo> Perhaps :)
14:22:56 <monochrom> if you are logical, you don't need a lot of help with types, they are logical
14:23:48 <nicoo> monochrom: Their logic is far beyound intuition(istic logic)
14:23:49 <broombs> Can anyone explain why a module that imports Control.Monad.Trans.Either doesn't get access to the MonadTrans instance defined therein?
14:24:22 <monochrom> sure, but you have the "logic maturity" to due with a formal system
14:24:28 <monochrom> s/due/deal/
14:24:44 * nicoo headdesks
14:24:48 <startling> broombs, it should. what symptom are you seeing?
14:24:51 <nicoo> monochrom: It was just a pun ;)
14:25:00 <broombs> startling: 'lift' is not in scope
14:25:01 <monochrom> "f :: Int -> Bool, x :: Int, therefore f x :: Bool" is straight from most logics
14:25:07 <monochrom> OK haha!
14:25:10 <shachaf> broombs: "lift" is not an instance.
14:25:14 <shachaf> It's a function.
14:25:25 <broombs> startling: or, rather, the MonadTrans instance is not recognized
14:25:33 <shachaf> This has nothing to do with the instance.
14:25:39 <startling> broombs, lift isn't defined in C.M.T.Either
14:25:46 <broombs> startling: I believe it is.
14:25:49 <shachaf> If you want access to the function "lift", you have to import a module that exports it.
14:25:58 <monochrom> "id :: a->[a], y :: Maybe Int, therefore id y :: [Maybe Int]" is just unification
14:26:19 <broombs> If you guys mean Control.Monad.Trans, please know that I've imported that too.
14:26:26 <shachaf> monochrom: Whereas the sort of thing Oleg does is unjust unification, right?
14:26:38 <broombs> But it still doesn't work.
14:26:43 <monochrom> of course, "just unification" is an understatement. unification is just exponential time
14:26:48 <startling> broombs, what's the error you're seeing?
14:26:51 <typoclass> broombs: please put the problematic code on hpaste, along with the error message
14:26:53 <typoclass> @where hpaste
14:26:53 <lambdabot> http://hpaste.org/
14:26:58 <shachaf> broombs: Works for me.
14:27:16 <broombs> typoclass, startling, shachaf: I'm seeing "No instance for (MonadTrans (EitherT <myLeftType>))"
14:27:46 <shachaf> That's yet another different thing from "'lift' is not in scope".
14:27:57 <shachaf> What package is this instance coming from?
14:28:03 <edwardk> broombs: is this in ghci?
14:28:05 <broombs> shachaf: C.M.T.Either.
14:28:08 <monochrom> oleg can use iteratees to do unification in one kick
14:28:09 <broombs> edwardk: yes.
14:28:16 <shachaf> That's a module. Do you know the package name?
14:28:19 <edwardk> broombs: i'm guessing you have 'either' installed referencing one version of transformers, but ghci loaded a different one
14:28:26 <broombs> I should note that the error goes away if I copy the 'lift' definition in C.M.T.Either and paste it into the module.
14:28:37 <edwardk> if you run ghc-pkg list | grep transformers   and ghc-pkg list | grep mtl    what shows up?
14:28:40 <startling> broombs, well, that's not the right thing to do
14:28:49 <startling> broombs, have you pasted your code + error?
14:28:56 <broombs> startling: yes, that's why I'm posing my question here :-)
14:30:10 <danharaj> edwardk: are you familiar with the CC-delcont library?
14:30:15 <broombs> edwardk: transformers is 0.3.0.0, then 0.2.2.0, then (BASE) 0.4.1
14:30:24 <broombs> edwardk: mtl is 2.1.1
14:30:27 <broombs> then 2.0.1.0
14:30:49 <edwardk> what version of transformers is shown under 'depends' when you use ghc-pkg describe either
14:31:05 * lispy gets annoyed with win32 version of GLUT
14:31:24 <broombs> edwardk: hmm, 'ghc-pkg describe' can't find either (!)
14:31:37 <edwardk> which package did you get EitherT from?
14:31:43 <edwardk> EitherT or either?
14:32:17 <broombs> edwardk: not sure; I don't remember exactly what I typed when (or if) I cabal-installed.
14:32:29 <shachaf> ghc-pkg list | grep ither
14:32:48 <startling> heh
14:32:59 <broombs> Too late; I'm now in the process of 'cabal install either'
14:33:18 <edwardk> cabal install either; -- and then i think the command you want is 'ghc-pkg hide EitherT'
14:33:28 <edwardk> i don't hide things often though so i could be wrong
14:33:38 <shachaf> The issue here is that you have too *many* packages installed and they're conflicting with each other. Installing more packages that do the same thing might not be the best approach. :-)
14:33:48 <edwardk> that should get you either using whatever your most recent dependencies are
14:33:55 <broombs> edwardk: didn't work.
14:34:08 <edwardk> but it now means that you'll have both either and EitherT trying to provide the same module, so you need to hide one of them
14:34:09 <broombs> Why are there multiple packages for EitherT?
14:34:29 <broombs> edwardk: which is the better one?
14:34:36 <edwardk> broombs: either
14:34:38 <shachaf> GHC printed "didn't work"? Man, they really ought to do something about their error messages.
14:34:47 <shachaf> edwardk: ...Not helpful. :-)
14:34:53 <edwardk> shachaf: hahahahaha
14:34:55 <donri> xD
14:35:04 <edwardk> the 'either' package is the better source of EitherT ;)
14:35:06 <shachaf> @remember edwardk <broombs> Why are there multiple packages for EitherT? <broombs> edwardk: which is the better one? <edwardk> broombs: either
14:35:06 <lambdabot> Done.
14:35:35 <startling> :P
14:35:36 <broombs> haha
14:36:02 <edwardk> ok, now when you ghc-pkg describe either   what version of transformers does it show?
14:36:06 <edwardk> under depends
14:36:17 <typoclass> @remember edwardk <broombs> edwardk: which is the better package, EitherT or either? <edwardk> broombs: either <shachaf> edwardk: ...Not helpful.
14:36:17 <lambdabot> I will remember.
14:36:30 <typoclass> shachaf: can i unremember your quote?
14:37:01 <broombs> edwardk: now the txfmrs version is 0.3.0.0.
14:37:03 <shachaf> Your quote is inaccurate!
14:37:22 <typoclass> shachaf: it's called editing for brevity :-)
14:37:42 <shachaf> <typoclass> it's called being a bad person
14:37:48 <mrlemao`> me again... I am in 'main' so IO monad. If I have a doSomething :: StateT s IO monad function, how can I call it from main?
14:38:06 <danharaj> :t runStateT
14:38:07 <mrlemao`> i.e. I need to change the context to the StateT monad wrapping the IO
14:38:07 <lambdabot> on the commandline:
14:38:07 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
14:38:38 <edwardk> broombs: ghc-pkg hide transformers; ghc-pkg expose transformers-0.3.0.0; then run the repl and see what it says
14:39:09 <edwardk> shachaf: maybe it was unintentional. i mean he has typo in his name
14:39:20 <startling> :t let (&^&) = runStateT in (&^&)
14:39:22 <lambdabot> forall s (m :: * -> *) a. StateT s m a -> s -> m (a, s)
14:39:35 <typoclass> shachaf: they put some surreal into your tea again. i don't know what to do with your comments
14:39:40 <broombs> edwardk: the hide worked, but the expose denied me permission.  Should I sudo?
14:39:54 <startling> mrlemao`, ^ that turns a StateT s IO into a s -> IO (a, s)
14:40:14 <broombs> edwardk: openBinaryTempFile is what balked.
14:40:25 <edwardk> broombs: neat. i've never seen that =P
14:40:31 <broombs> Great.
14:40:54 <broombs> So, at the risk of sounding critical, why are there multiple packages for so many modules?
14:41:00 <mrlemao`> so a runStateT doSomething initialState, called within main will do?
14:41:07 <broombs> (And should I repeat with sudo?)
14:41:11 <edwardk> what kind of haskell stuff do you have installed? e.g. did you just start installing packages or did you install yesod or something in particular?
14:41:18 <edwardk> don't sudo
14:41:31 <broombs> edwardk: I just did a cabal install.
14:41:34 <edwardk> i'm trying to back into what you did to your package list =)
14:41:36 <broombs> Nothing in particular.
14:42:02 <edwardk> what did you cabal install earlier. somewhere along the way something updated your transformers, etc.
14:42:10 <edwardk> so i'm trying to back into how you got into this situation
14:42:14 <broombs> No idea.
14:42:23 <typoclass> broombs: i think it can be healthy to have 2-3 competing implementations, particularly when someone came up with a new idea and it's just isn't clear yet how best to approach things
14:42:23 <broombs> I may have cabal installed snap.
14:42:30 <shachaf> Don't sudo, broombs.
14:42:34 <edwardk> aha
14:42:43 <typoclass> broombs: but you're right that maybe people should standardize a little more :-)
14:42:43 <edwardk> ok, that was the big install i was looking for =)
14:43:12 <broombs> edwardk: I'm beginning to feel dread coming on.
14:43:31 <edwardk> broombs: hahaha. well, there is some. i'm trying to come up with the cleanest way to get you what you want
14:44:11 <broombs> edwardk: I wonder if I should sandbox with cabal-dev?
14:44:16 <edwardk> honestly cabal works really well 99% of the time. its just wen you go and install something huge like snap or yesod, and then start playing around in ghci with packages that you get into trouble
14:44:44 <edwardk> this leads to bad experiences for a number of folks from outside of the community because usually the first thing they do is install one of those two things =P
14:44:47 <typoclass> edwardk: one or two folks told me that it's now way better with the 1.16 version
14:45:04 <broombs> typoclass: the 1.16 version of what?
14:45:18 <typoclass> broombs: the cabal command line tool
14:45:21 <edwardk> broombs: do you want the minimal fix for just this problem?
14:45:44 <edwardk> rm your ~/.ghc directory. cabal install either; try again ;)
14:45:58 <broombs> edwardk: actually no, I prefer a deep fix.  Is there a way to rip out snap?
14:46:11 <edwardk> well this will basically do that
14:46:15 <broombs> Ah, yes.
14:46:18 <broombs> OK, now trying...
14:48:31 <broombs> edwardk: I'm afraid it didn't work; I get the same "no instance" error.  On the bright side, ghc-pkg list shows only one transformers version (0.3.0.0).
14:48:34 <jfischoff> has anyone created a type level set and map, hopefully using the singletons library?
14:48:35 <edwardk> broombs: there is a good reason _not_ to use sudo when you install packages with cabal. because then you can scrub everything the easy way
14:49:05 <edwardk> let me check to make sure i have an instance for MonadTrans in either ;)
14:49:34 <edwardk> instance MonadTrans (EitherT e) where  lift = EitherT . liftM Right -- is there all right
14:49:45 <edwardk> can you hpaste the code in question?
14:49:47 <broombs> Yes, I see it too.
14:50:49 <edwardk> if you ghc-pkg list | grep ither     does EitherT show up or just the one version of either?
14:50:56 <broombs> edwardk: I'm actually not comfortable hpasting this, but I can tell you that I just literally typed in the MonadTrans line you entered, and the error went away.
14:51:18 <edwardk> (my worry is you might have sudo'd something in an earlier install)
14:51:26 <broombs> edwardk: the ghc-pkg grep shows either-3.0.2
14:51:30 <broombs> and nothing else
14:51:42 <edwardk> and you are just loading up from ghci ?
14:51:47 <broombs> yes
14:52:01 <broombs> (ctrl-C ctrl-L in Emacs Haskell mode)
14:52:31 <edwardk> i don't use haskell emacs mode so i don't know how to send ghci command line arguments there
14:52:52 <edwardk> can you load it with 'ghci -package transformers-0.3.0.0' ?
14:52:53 <broombs> That control sequence just loads the current buffer into ghci.
14:53:24 <broombs> edwardk: that just worked.
14:53:27 <broombs> In fact...
14:53:38 <broombs> it now says that the import of C.M.T.Either is redundant.
14:53:58 <edwardk> that was what i was trying to do with the hide and expose earlier
14:55:17 <edwardk> whatever concoction of stuff you have there was trying to load a different version of transformers from the repl than was used by the library, when that happens you won't see any instances, because the instances are for a different library version, etc.
14:55:25 <lispy> anyone have experience profiling gloss apps?
14:55:43 <lispy> I keep getting an empty .prof file and I'm wondering if it has to do with the way the program exits
14:55:54 <edwardk> lispy: never tried
14:56:04 * lispy is using gloss for the first time and this is someone else's code
14:56:21 <edwardk> broombs: in theory if you hide the old transformers then you can get the same resut
14:56:24 <edwardk> er result
14:56:33 <broombs> edwardk: silly me, all I had to do after the recent cabal install was kill the old shell and restart.  Things now appea fine.
14:56:51 <broombs> So thank you!
14:57:01 <edwardk> doh
14:57:02 <edwardk> np
14:57:23 <broombs> I'll try to avoid snap, yesod, etc.
14:57:31 <edwardk> they aren't that bad
14:57:33 <edwardk> really
14:57:46 * lispy whispers 'cabal-dev'
14:57:47 <broombs> btw, do you prefer one of those over the other?
14:57:54 <edwardk> i tend to prefer snap over yesod
14:57:58 <broombs> (thank you, lispy)
14:58:04 <edwardk> but thats mostly a mindset/culture thing
14:58:09 <typoclass> broombs: just have a #haskell chat window open when you install one of those :-)
14:58:28 <broombs> ha, ok, thanks guys.
14:59:34 <edwardk> the yesod guys have some pretty impressive tools for building static resources that can be served up and strongly typed -- its like a rails that doesn't suck -- and they have better templating. snap feels more 'haskelly' to me though, but thats a harder thing to quantify.
15:00:26 <startling> snaplets are pretty weird, I never quite wrapped my head around those.
15:00:41 <edwardk> startling: well, i got them to make them comonads recently. ;)
15:00:50 <cmccann> "like a rails that doesn't suck" was pretty much my impression of yesod as well
15:00:50 <edwardk> that should help… er.. maybe not
15:01:41 <startling> edwardk: I may or may not understand comonads!
15:01:57 <edwardk> cmccann: yesod makes perfect sense if you come from ruby and want to overload everything to do anything. it does feel a bit strange and ad hoc to someone without that background. ;)
15:02:51 <edwardk> it does bring a lot of fresh blood into the haskell community though, and they are very active
15:03:07 <sclv> i'll rep for happstack btw
15:03:22 <sclv> i think it is even more haskelly in certain ways
15:03:26 <cmccann> I never actually used ruby or rails that much, certainly not recently
15:03:28 <edwardk> and then there is happstack, which is basically grab anything you want, and smash it together ;)
15:03:31 <typoclass> how does snap do newlines? i'm trying to quantify out how haskelly it is
15:03:34 <sclv> basically more flexible and more compositional
15:03:43 <cmccann> but all the TH magic in yesod feels like the sort of thing that rails wishes it could do
15:03:43 <sclv> newlines!?
15:03:54 <edwardk> cmccann: yeah
15:03:54 <typoclass> sclv: http://memearchive.net/memerial.net/3231/a-newline-in-haskell.jpg
15:04:12 <edwardk> the big split between snap and yesod is over whether or not to use quasiquotation all over the place
15:05:22 <cmccann> personally I like the TH and QQ stuff to make all the various bits of a web app more statically checked
15:05:58 <edwardk> the main reason i stick to snap is honestly because i don't like compiling my web app to take 10 minutes while it works through quasiquotes ;)
15:06:01 <sclv> i always preferred to generate navigation directly from descriptions of the structure of a site
15:06:15 <sclv> a which point you don't need qq to do it
15:06:31 <cmccann> after doing a lot of web development, the compile-time disconnect between the twenty different kinds of code needed is my biggest annoyance I think
15:06:38 * lispy keeps forgetting to use the new parallel build feature of cabal
15:06:47 <lispy> Maybe i need to turn it on in my config
15:06:53 <typoclass> lispy: -j?
15:06:59 <lispy> typoclass: yeah
15:07:10 <sclv> i have my own approaches, but i don't know anything vis a vis the big three where they handle ajaxy stuff well at all
15:07:15 <sclv> although i know yesod had some experiments
15:08:11 <lispy> hmm...is there a way to turn it on in my cabal config?
15:10:26 <lispy> maybe jobs is the name of the option?
15:10:46 <tromp__> what is the accuracy of 0.012 ? is it 2, 3 or 4 digits?
15:12:04 <danharaj> tromp__: 2
15:12:22 <mapreduce> :t 0.012
15:12:24 <lambdabot> forall a. Fractional a => a
15:13:06 <tromp__> thx:)
15:13:14 <simpson> > 0 == (0.012 * 1000 - 12)
15:13:16 <lambdabot>   True
15:13:45 <danharaj> wait, you were asking about sig figs right?
15:14:06 <tromp__> it didn't say that
15:14:12 <simpson> tromp__: Homework?
15:14:14 <tromp__> it said: Please give your answer as a decimal number with an accuracy of 13 digits.
15:14:21 <tromp__> no, IBM's ponder this
15:14:28 <lispy> <sigh>
15:14:34 <lispy> accuracy != precision
15:14:40 <lispy> I think their question is broken
15:14:44 <tromp__> i already sent in a solution
15:15:06 <danharaj> I didn't even notice the question was about accuracy ._.
15:15:07 <tromp__> it looks like they wanted 9 significant digits
15:15:11 <tromp__> that gives the cutest answer
15:15:12 <rwbarton> accuracy of 0.012 depends on what the true value is :)
15:15:26 <tromp__> i made up the 0.012. that's not the asnwer:)
15:16:49 <typoclass> tromp__: you mean, the "accuracy of 13 digits" would be 4 digits before the decimal point and 9 after?
15:17:36 <tromp__> no, it would be 0.000 plus 9 significant digits
15:18:11 <tromp__> but to be safe i submitted 13 significant digits
15:18:24 <mrlemao`> me again: type Server id s = (EntityId id) => StateT s Process, is this the right way to declare thta id has to be an instance of EntityId in a type alias?
15:20:44 <parcs`> what's an integer lattice point
15:21:20 <monochrom> integer lattice point just means a tuple of integers
15:21:48 <edwardk> parcs`: (Integer,Integer), think complex numbers with integers instead of reals
15:22:10 <monochrom> "lattice" is just because Z^n looks like a crystal lattice
15:22:40 <edwardk> @google gaussian integer
15:22:42 <lambdabot> http://en.wikipedia.org/wiki/Gaussian_integer
15:22:42 <lambdabot> Title: Gaussian integer - Wikipedia, the free encyclopedia
15:23:25 <ocharles> edwardk: does Magnify really need the MonadReader constraints?
15:23:37 <lispy> hmm...I'm not sure that cabal-dev is working correctly with the new cabal parallel builds feature
15:23:40 <ocharles> I wanted to magnify an applicative functor built with Data.Functor.Compose, so I don't have a Monad instance
15:24:01 <ocharles> I think this functor composition is in fact a monad, so in this case it's not the end of the world, but still...
15:24:03 <edwardk> magnify is designed to work with a monad transformer stack. as is zoom
15:24:23 <edwardk> i cannot provide you with any canonical instances for monads in terms of compose
15:24:38 <edwardk> there are multiple constructions that arise.
15:24:46 <typoclass> mrlemao`: i think that won't do anything, "type" is not that powerful. as far as i recall, you'd have to repeat the "(...) =>" in every function signature, so it's kinda pointless to have it in the "type"
15:24:50 <ocharles> right, but i can't write my own due to the constraints on the class
15:24:53 <edwardk> based on which distributive law you use, or if the two functors form an adjunction, etc.
15:25:04 <edwardk> well, just don't use magnify, make another combinator ;)
15:25:08 <ocharles> i have :)
15:25:12 <ocharles> i wanted to delete my own code :p
15:25:47 <monochrom> lens, magnify, zoom... are we going to get prism, optic fibre, and CCD too? :)
15:25:52 <edwardk> magnify is literally for a more powerful 'local' that can change the type of the target
15:25:55 <ocharles> https://gist.github.com/704e8bda49f0da98e1e5 -- mergedVia has the same sig as magnify
15:26:31 <shachaf> monochrom: You forgot "iwhere".
15:26:55 <dimka> There was a throwDyn function in Control.OldException package. What is it's analog in Control.Exception from base?
15:27:00 <ocharles> but if i can't make this an instance of magnify, i'll stop bike shedding :)
15:27:17 <edwardk> it really should be something else.
15:27:22 <ocharles> ok
15:27:23 <shachaf> dimka: Probably throw
15:28:09 <edwardk> magnify would ideally be more powerful than it is. and it is probably one of the shakier parts of the api design. i _want_ a magnify that can work with deeper transformer stacks, but that works against its ability to work with folds as well as getters
15:28:53 <edwardk> its better than the older 'focus' i used to have that required a particular statet or readert to be on the outside of the transformer stack, but its not as good as i'd like
15:29:06 <edwardk> the issue is when you feed it a fold it should run your action multiple times
15:29:12 <shachaf> Hmm, instance Zoom ContT is still TODO.
15:29:29 <edwardk> shachaf: knock yourself out ;)
15:29:48 <Silox|> What does readFile do with newlines? Does it convert them to \n or to \r\n?
15:30:41 <shachaf> Try it out!
15:30:51 <monochrom> \n
15:30:52 <typoclass> Silox|: i think it doesn't do anything :-) it reads them as they are in the file
15:31:27 <monochrom> on windows, it converts \r\n to \n. this is required by the haskell report
15:31:31 <Silox|> I see, thanks!
15:31:43 <lispy> @where report
15:31:43 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
15:32:35 <typoclass> monochrom: right, thanks. i got it mixed up with something else
15:52:22 <ezyang> Does anyone know if 'plugins' has been made to work with Safe Haskell?
15:54:07 <lispy> ezyang: AFAICT, work on plugins stopped when dons left unsw
15:54:12 <donri> stepcut: ^
15:54:12 <ezyang> blah
15:54:25 <ivanm> there's someone updating it to at least work with new GHC's though
15:54:27 <ivanm> and a fork or two I think
15:54:34 <lispy> ah, cool
15:54:41 <stepcut> ezyang: it has not, but I would accept patches
15:55:25 <stepcut> ezyang: I am the current maintainer of plugins, btw. I have not done much work on it yet aside from keeping it building. However, I do have a strong interest in keeping it alive.
15:55:51 <lispy> stepcut: cool. I will do my best to remember that it has a maintainer
15:56:40 <stepcut> lispy: yup. I'm even listed as the maintainer on hackage, http://hackage.haskell.org/package/plugins-1.5.3.0
15:56:44 <ezyang> OK. I have a project which would strongly benefit from Safe Haskell support for plugins.
15:56:48 <ezyang> So I'll poke at it.
15:57:08 <stepcut> ezyang: great!
15:57:34 <lispy> ezyang: don's thesis would be relevant here. IIRC, he makes statements about the safety
15:57:55 <lispy> ezyang: perhaps those can be translated into 'proof obligations' to the module
15:58:11 <gwern> @quote obligations
15:58:11 <lambdabot> drull95 says: with great power comes a lot of proof obligations
15:58:23 <lispy> ohai gwern
15:58:44 <shachaf> @quote norway
15:58:44 <lambdabot> No quotes match. Are you on drugs?
15:58:47 <shachaf> @quote panacea
15:58:47 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
15:58:51 <shachaf> @quote triple
15:58:51 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
15:58:52 <lispy> randomRIO is slow...
15:58:54 <shachaf> Sigh...
15:59:20 <lispy> which is faster, mwc-random or mersenn random?
15:59:25 <lispy> mersenne*
15:59:52 <lispy> oh, well there you go: Compared to the mersenne-random package, this package has a more convenient API, is faster, and supports more statistical distributions.
16:00:05 * lispy plugs in mwc-random
16:03:36 <ezyang> stepcut: Is this the accurate repo http://hub.darcs.net/stepcut/plugins ?
16:03:42 <stepcut> ezyang: yes
16:03:55 <stepcut> ezyang: let me make sure I pushed everything
16:05:01 <stepcut> ezyang: yes that is the correct location, and I have no unpushed changes
16:05:11 <ezyang> Great
16:05:33 * hackagebot vty-ui 1.6 - An interactive terminal user interface library for Vty  http://hackage.haskell.org/package/vty-ui-1.6 (JonathanDaugherty)
16:10:22 <ezyang> stepcut: Oh, good, adding Safe Haskell support will be pretty easy
16:10:27 <Cale> okay, time to try to figure out what this -fglasgow-exts nonsense is about
16:11:32 <Cale> does someone have a list handy of all the extensions which are implied by -fglasgow-exts?
16:11:58 <shachaf> Hmm, why is that relevant?
16:12:13 <simpson> I think he's going to stop passing -fglasgow-exts or something.
16:12:16 <geekosaur> isn't it essentially all of them'
16:12:18 <geekosaur> ?
16:12:24 <Cale> Because once I track down all the uses of -fglasgow-exts, I'm going to need to replace them
16:12:33 <stepcut> ezyang: awesome!
16:12:37 <rwbarton> won't they track themselves down?
16:12:45 <rwbarton> i guess i don't understand what is going on at all
16:12:55 <ezyang> In fact, it seems no changes to plugins will be necessary
16:12:56 <edwardk> i think you can get the list by looking at the hint source code. they had a list
16:12:56 <shachaf> Cale: ForeignFunctionInterface UnliftedFFITypes ImplicitParams ScopedTypeVariables UnboxedTuples TypeSynonymInstances StandaloneDeriving DeriveDataTypeable DeriveFunctor DeriveFoldable DeriveTraversable DeriveGeneric FlexibleContexts FlexibleInstances ConstrainedClassMethods MultiParamTypeClasses FunctionalDependencies MagicHash ExistentialQuantification UnicodeSyntax PostfixOperators PatternGuards LiberalTypeSynonyms RankNTypes TypeOperators ...
16:13:02 <shachaf> ... ExplicitNamespaces RecursiveDo ParallelListComp EmptyDataDecls KindSignatures GeneralizedNewtypeDeriving
16:13:07 <stepcut> Cale: can't you just remove -fglasgow-exts and then see what the compiler tells you to reenable?
16:13:31 <geekosaur> http://www.haskell.org/ghc/docs/latest/html/users_guide/ghc-language-features.html#options-language
16:13:39 <shachaf> Cale: Oh, you should enable some more extensions!
16:13:42 <shachaf> Like TupleSections
16:13:48 <edwardk> there was an enableGlasgowExtensions or some such that turned them all on individually. it is deprecated, but its in there
16:13:49 <shachaf> Everyone loves TupleSections.
16:13:51 <gienah> stepcut: not always as sometimes then the code does not compile leaving be baffled as to which extension made it compile
16:14:06 <shachaf> edwardk: That's where I got my list just above. :-)
16:14:26 <edwardk> shachaf: =)
16:14:36 <shachaf> Oh, hint?
16:14:39 <shachaf> I looked at the GHC code.
16:14:48 <Cale> stepcut: Well, it's which extensions we want in lambdabot
16:14:51 <dimka> Cale: are yu gonna move lambdabot from Control.OldException to Control.Exception?
16:14:52 <geekosaur> the entire list is at the URL I pasted above
16:15:11 <Cale> dimka: I am going to do as little as possible to lambdabot's code as I can manage
16:15:13 <stepcut> Cale: ah.. for the eval plugin?
16:15:22 <shachaf> Man, -fglasgow-exts enables GeneralizedNewtypeDeriving?
16:15:28 <Cale> stepcut: well, more important for :t
16:15:30 <shachaf> I bet you don't want GeneralizedNewtypeDeriving.
16:15:31 <Cale> :t fmap
16:15:33 <lambdabot> on the commandline:
16:15:33 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
16:15:39 <Cale> ^^ this junk
16:15:57 <Cale> shachaf: It doesn't really matter
16:15:58 <danharaj> it looks like lambdabot is outputting the wrong line :3
16:16:07 <lispy> Productivity  17.9% of total user, 16.4% of total elapsed
16:16:12 <shachaf> Cale: True. But if we ever get the ability to define type, it would!
16:16:21 * lispy tries to decide if that's a reasonable amount of GC time
16:24:44 <jmcarthur> lispy: that seems very unreasonable
16:25:25 <shachaf> jmcarthur: I keep seeing those ads from Jane St.
16:25:35 <jmcarthur> shachaf: which ones :)
16:25:47 <lispy> jmcarthur: what would you expect, 9%?
16:25:50 <shachaf> "Do you think in closures? We do too!"
16:26:18 <jmcarthur> lispy: just to make sure i understood, those percentages were productivity? not gc?
16:26:37 <lispy> jmcarthur: oh right. I read that as GC time.
16:26:44 <lispy> So my program is very UNproductive
16:26:51 <jmcarthur> lispy: that is a very low productivity, yes
16:27:26 <lispy> that would explain the bad performance :)
16:27:28 <jmcarthur> i expect gc to be in the range of 1%-15%, depending on the nature of the program
16:27:45 <typoclass> so it's 80-85% for him
16:28:00 <lispy> I wonder if I should abandon this transformation to Data.Vector and focus on heap profiling
16:29:40 <jmcarthur> lispy: with that much gc it seems that would be the top priority to increase performance for now
16:30:13 <jmcarthur> shachaf: i get it now
16:30:35 <lispy> jmcarthur: right. Thanks for pointing out that I misread it.
16:32:21 <lispy> jmcarthur: I was considering the switch to Data.Vector because I think the most garbage will be lists, but having an actual heap profile will set me straight
16:40:22 <hpaste> mrlemao pasted “How to call action on a wrapped monad?” at http://hpaste.org/77227
16:41:06 <hpaste> “ ” pasted “ ” at http://hpaste.org/77228
16:41:16 <efie> ups
16:41:21 <efie> could you help me with this?
16:41:23 <mrlemao`> server is in a Server monad, which wraps Process. I need to call 'expect' from the Process monad but I get the compilation error at the bottom
16:41:59 <shachaf> roconnor: Did the patch to lens fix your holesOf bug?
16:44:30 <typoclass> mrlemao`: i think it has to do with 'expect' being of type 'Process a', while in line 19, you're doing "case expect of (..., ...)", which means 'expect' would have to be a 2-tuple
16:47:18 <mrlemao`> typoclass: but if I call the same expect within a Process monad it works
16:47:59 <mrlemao`> typoclass: do you mean that I should pattern match on Process (True, cmd) instead to extract the value?
16:50:16 <typoclass> mrlemao`: i don't really know what you're doing there, and what Process and Server are, but you might want "do", then "e <- expect", then "case e of ..."
16:52:07 <mrlemao`> typoclass: Process is the monad provided by CloudHaskell, I am wrapping it with Server so I can associate my own state with it
16:52:51 <typoclass> mrlemao`: i see
16:52:56 <mrlemao`> typoclass: humm, maybe I should perform the loop + expect in the caller which is in the Process monad?
16:53:20 <mrlemao`> typoclass: and then runStateT into the Server monad to process?
16:53:56 <typoclass> mrlemao`: i don't know about that
16:54:32 <mrlemao`> typoclass: I am basically in the Server monad, but need to perform a Process monad function/patter matching but I am not sure how
16:54:57 <mrlemao`> typoclass: and in this case, Server wraps Process
16:55:14 <ij> How do I convert an int to float inline
16:56:38 <Mossmoth> ij : you can use the fromIntegral :: Num a => Integer -> Num a
16:57:06 <efie> I have the expression "f x = g x >>= return . h" - can I avoid displaying the variable x here?
16:57:07 <typoclass> mrlemao`: i would check the paper on cloudhaskell and any documentation they have. see if you can find out how their Process monad should be used, and if/how you can run it
16:58:19 <Mortchek> @pl \x -> g x >>= return . h
16:58:20 <lambdabot> (h `fmap`) . g
16:58:20 <mrlemao`> typoclass: done that. I am writing a layer on top of CloudHaskell adding functionality that wasnt part of their scope
16:58:42 <mrlemao`> typoclass: I am stumbling on my own ignorance of Haskell + monads, but learning as I go
16:58:53 <typoclass> mrlemao`: so, have you come across any code where they used that Process monad?
16:59:18 <mrlemao`> typoclass: oh, yes, but no with another monad wrapping it
16:59:41 <mrlemao`> typoclass: this is more of a pure haskell + monad question than CloudHaskell
17:00:33 <mrlemao`> typoclass: I have a simple server build on top of CloudHaskell using the approach in the papers. But now I am abstracting some stuff away into a generic layer and a custom layer
17:00:52 <typoclass> mrlemao`: right. well there is no general way of running a monad or extracting things from it (there can't be). several monads have a "run" function like "runStateT"
17:01:57 <mrlemao`> typoclass: the server :: Server () function is already executing in a runProcess, but maybe I should execute runProcess again within the server function?
17:02:16 <mrlemao`> typoclass: seems a bit messy
17:02:32 <efie> Mortchek: thanks
17:02:38 <efie> what does pl stand for?
17:04:09 <typoclass> mrlemao`: sorry, i can't give you much advice how to structure that, because two important functions are not implemented yet :-/ in general, if you call a function only once, you could just as well take the function's code and put it in the place of the call
17:04:11 <Mortchek> efie, pointless
17:04:43 <Mortchek> efie, http://www.haskell.org/haskellwiki/Pointfree
17:05:15 <typoclass> mrlemao`: (this of course has its limits, because you don't want to end up with a single 3000-line function. or you have some code that you really want to name, so a function name is useful there)
17:06:13 <mrlemao`> typoclass: ok, thanks for your help. I will try to restructure this a bit (btw, the code in hpaste is a simplification of the original server code).
17:06:22 <efie> ah, I see .)
17:06:44 <typoclass> mrlemao`: another general thing -- i'd only start with newfangle advanced stuff like cloud haskell if you have already some understanding of basic haskell. i think you'll frustrate yourself otherwise. have you worked through lyah, for example?
17:06:46 <typoclass> @where lyah
17:06:47 <lambdabot> http://www.learnyouahaskell.com/
17:07:30 <typoclass> (or at least some sizeable part of lyah :-)  )
17:13:29 <koda> #ghc
17:13:46 * koda throws in a /join
17:14:18 <koda> ah #haskell was ok
17:14:41 <koda> so i wanted to ask, can you save getCurrentDirectory somewhere, eg in a String?
17:15:26 <Nereid> what does "save" mean?
17:15:34 <typoclass> koda: hello, not sure what you mean by 'save', but in the simplest case you can just use a variable. "d <- getCurrentDirectory" inside your "main" should work
17:15:40 <Nereid> you can certainly bind it to a name like ^
17:15:43 <Nereid> and then use it again elsewhere
17:17:22 <koda> thanks typoclass and Nereid
17:17:59 <koda> however i (think i) need to have it as a string
17:18:14 <byorgey> what typoclass wrote does give you a String
17:18:19 <hpaste> applicative annotated “How to call action on a wrapped monad?” with “How to call action on a wrapped monad? (annotation)” at http://hpaste.org/77227#a77229
17:18:23 <mrlemao`> typoclass: yes, I have been through it though not thoroughly. However, I find that trying to build something you want/need is a greater motivation!'
17:18:23 <Nereid> FilePath = String
17:18:59 <coldpizza72i> So i pretty much finished my parser but I'm having trouble extending the language to allow comments…Im trying to start of by just allowing comments for Assignments as shown on line 175 but at the bottom of the program i commented out a test case that is failing to parse http://ideone.com/2eDiSr Im not quite sure why this is failing
17:19:21 <typoclass> byorgey: but it gives a String ONLY if you run the program at some point!!1! ;-) otherwise it'll just be an unexecuted IO String action lying around disappointedly on your hard drive
17:19:46 <byorgey> well, getCurrentDirectory will be
17:19:47 <mrlemao`> typoclass: I am not frustrated at all, but learning as I go. I know what I need to build (done that in Java), just finding my way around haskell and reusing as much as possible of CloudHaskell
17:20:06 <byorgey> d will just be a variable name bound to the future result of an unexecuted IO String action =)
17:20:35 <koda> ah, i thought of doing     let outputPath =  getCurrentDirectory
17:21:03 <Philonous> koda:  That binds the _action_ that returns the string to the name outputPath, rather than the result of running it
17:21:23 <typoclass> koda: yup, you can do that, but it won't give you a String. i bet it won't be useful to you
17:22:08 <Nereid> "let x = m" just makes x another name for the action m
17:22:17 <typoclass> byorgey: no worries, i was just kidding about that popular advice that it's like "getting the file list out of /bin/ls" ... never mind
17:22:21 <Nereid> "x <- m" represents "running" m, and putting the result into x
17:22:24 <byorgey> typoclass: hehe
17:22:26 <koda> ah i get it
17:23:11 <danharaj> x <- m is m >>= (\x -> ...
17:23:16 <danharaj> I don't see why we have to lie about it.
17:24:38 <typoclass> danharaj: yeah, but i don't think Nereid lied. he said "represents 'running' and putting the result into x", which is a good description for "m >>= (\x ->", isn't it
17:24:45 <danharaj> no
17:24:48 <Cale> Don't say "putting the result into x", say "naming the result x"
17:24:54 <Cale> there is a subtle distinction
17:25:06 <Cale> x is not a name for a "place where we can put stuff"
17:25:15 <Cale> it's a name for the result of the action m
17:25:26 <danharaj> yes that is sensible
17:26:18 <koda>     outputPath <- getCurrentDirectory
17:26:18 <koda>     show outputPath
17:26:19 <koda> ghc won't compile that :\
17:26:27 <Cale> koda: use print
17:26:31 <Cale> instead of show
17:26:36 <Cale> print = putStrLn . show
17:26:46 <koda> show wants a String
17:26:51 <rwbarton> show converts to String
17:27:03 <danharaj> :t show
17:27:07 <lambdabot> forall a. Show a => a -> String
17:27:07 <Cale> koda: The problem is that every line in the do-block needs to be an IO action (since getCurrentDirectory is an IO action)
17:27:10 * lispy may have found one of those cases where data.vector is worse than list, even though the number of list elements is fixed per iteration
17:27:17 <Cale> koda: while show outputPath will just be a String
17:27:21 <lispy> I think lists are getting better fusion
17:27:38 <danharaj> lispy: that sounds pathological if the number of elements is fixed.
17:27:47 <Cale> koda: So you need to say what you'd like to do with that String, in this case, write it to the terminal using putStrLn
17:27:51 <danharaj> i.e. it should be fixed
17:27:52 <koda> Cale: that's ok, i just want to save in which directory we are now and then change it with setCurrentDirectory
17:28:44 <danharaj> koda: if you want to name pure expressions inside a do block then say "let foo = bar"
17:28:52 <typoclass> Cale: i dunno what you mean. i don't see how "putting the result into x" conflicts with "naming the result x". you put something in there, which you can do only once in haskell (hence it's not similar to variables from other programming languages). *shrug*
17:28:57 <Nereid> oh geez Cale. I was just trying to get the idea across.
17:29:19 <EvanR7> im looking at vps, and i see some dirt cheap for like 1 dollar a month with 128M ram, is that enough to run ghc?
17:29:29 <Cale> typoclass: Okay, for concreteness...
17:29:36 <Cale> Suppose we write  x <- getLine
17:29:39 <danharaj> typoclass: variables are names they are not places where you put things. Saying you can only put things in a variable once is misleading because nothing ever gets 'put' anywhere.
17:29:42 <Cale> x :: String
17:29:46 <Nereid> EvanR2: 128 sounds pretty tight for doing anything
17:29:53 <Cale> So x *is* the result of getLine
17:30:01 <Cale> it's not a place where we put the result of getLine
17:30:02 <koda> so i cannot convert IO to String, can you do the opposite?
17:30:08 <EvanR7> Nereid: was ok for playing warcraft2 :(
17:30:24 <koda> String to IO
17:30:28 <Cale> koda: sure, in many ways
17:30:52 <danharaj> koda: if s is a String, then `return s` is an IO String
17:30:54 <Cale> One is that you can convert a String to an IO action which does nothing except results in that String when executed
17:30:54 <EvanR7> you can convert String to IO String
17:31:01 <Cale> which is what return does
17:31:02 <geekosaur> you can always lift something into IO
17:31:16 <geekosaur> the trick is to use that to work with stuff in IO
17:31:21 <Cale> You can also turn a String into an IO action for printing that String on the screen
17:31:25 <Sonarpulse> In http://hackage.haskell.org/packages/archive/binary/0.3/doc/html/Data-Binary.html the documentaition for data.binary mentions a using a script to derive binary.get and binary.put instances for a given data definition
17:31:25 <lispy> danharaj: yeah, it's making my head hurt :)
17:31:26 <Cale> which is what putStrLn does
17:31:30 <geekosaur> rather than trying to get something out of IO, lift what you need into IO
17:32:12 <Sonarpulse> I am having trouble figuring out how to use the script: I just get errors saying something itsn't defined when AFIAK the whole point is to generate a definition
17:33:03 <bxx> kode string <- getLine gets you the strong. of course you can't do this in a function, since functions don't have side effects
17:33:20 <bxx> koda*
17:33:25 <danharaj> what does that even mean
17:33:32 * monochrom is tempted to add to the problem of too many chefs
17:33:50 <Nereid> how about we all just point him to something like
17:33:51 <Nereid> @where IO
17:33:51 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
17:33:58 <Cale> yes :)
17:34:05 <monochrom> well, I guess if I am not part of the solution anyway, I may as well be part of the problem
17:34:11 <koda> that might also be useful, thanks :p
17:34:12 <EvanR7> haha
17:34:25 <danharaj> heh
17:34:30 <danharaj> "- CaleGibbard"
17:34:33 <Nereid> haha
17:34:37 <danharaj> Did we really send them anywhere ;)
17:34:39 <monochrom> "getLine >>= callback" calls the callback with the string as parameter
17:34:46 <Cale> YOU CAN'T LEAVE
17:35:20 <EvanR7> uhg the callback thing reminds me of nodejs, a train wreck
17:35:27 <monochrom> there is no container, no box, nowhere to store things. just passing parameters to callback
17:36:06 <danharaj> I do like thinking of monads as continuation passing style.
17:36:14 <danharaj> That, or expression tree subsitution.
17:36:24 <danharaj> (I guess those are the same thing???)
17:36:31 <Nereid> everything is the same thing
17:36:39 <EvanR7> well the expression thing is different for IO
17:37:06 <EvanR7> it 'does' the lhs of >>= first
17:37:12 <EvanR7> normally it 'does' >>= first
17:37:26 <starx> How do i return from main function
17:37:33 <danharaj> call-by-value continuations
17:37:39 <danharaj> starx: what do you mean
17:37:46 <danharaj> post code.
17:37:47 <mauke> starx: what's a main function?
17:37:58 <Nereid> starx: reach the end
17:38:10 <typoclass> starx: you probably want exitSuccess ...
17:38:14 <typoclass> @hoogle exitSuccess
17:38:15 <lambdabot> System.Exit ExitSuccess :: ExitCode
17:38:15 <lambdabot> System.Exit exitSuccess :: IO a
17:38:16 * monochrom adds to the problem again!
17:38:20 <Nereid> :V
17:38:28 <monochrom> by proving termination of the main function :)
17:38:34 <EvanR7> lol
17:38:45 <starx> thanks. Yes I wanted to terminate main function
17:38:52 <EvanR7> :t exit
17:38:53 <Nereid> <_<
17:38:56 <lambdabot> Not in scope: `exit'
17:39:08 <EvanR7> :t exitSuccess
17:39:09 <lambdabot> Not in scope: `exitSuccess'
17:39:18 <EvanR7> IO a
17:39:31 <monochrom> I want to see why your current main function doesn't terminate
17:39:44 <Nereid> starx: normally you let the control flow reach the end, but you can also exit at any time with exitSuccess or one of its friends
17:39:59 <Sonarpulse> anybody see my question?
17:40:12 <Nereid> I saw it but couldn't give an answer.
17:40:15 <Nereid> fwiw.
17:40:40 <danharaj> does anyone want to help me grok the 4 control operators in cc-delcont?
17:40:42 <coldpizza72i> Cale: you there?
17:41:12 <Cale> coldpizza72i: yeah, I'm around
17:41:16 <Sonarpulse> I guess I could just make the monad instances by hand
17:41:19 <starx> This is a bit odd
17:41:22 <Sonarpulse> but I am not so sure how to do tha
17:41:50 <Sonarpulse> and using such a "macro-script" sounds quiet nice
17:42:43 <coldpizza72i> Cale: do you think you might be able to take a look at a problem I'm having trying to extend my language to accept comments. Im trying to start of by just allowing comments for Assignments as shown on line 175 but at the bottom of the paste i commented out a test case that is failing to parse http://ideone.com/2eDiSr Im not quite sure why this is failing
17:43:32 <Cale> coldpizza72i: I would recommend removing the comments in a completely separate pass
17:46:12 <starx> Does ghc produce completely stand alone executable on all platforms?
17:46:38 <lispy> starx: nope
17:46:47 <lispy> starx: if you have a linux machine run ldd on the executable
17:46:53 <simpson> starx: It doesn't even produce standalone executables, unless it has a static linker I'm not aware of.
17:47:00 <lispy> starx: you will see that it needs gmp
17:47:11 <starx> I see.
17:47:19 <danharaj> I wish they would remove the gmp dependency already.
17:47:34 <hpc> gmp is gpl, is it not?
17:47:36 <danharaj> If I ever felt like releasing my stuff to the public I wouldn't want to be tied to the gpl :\
17:47:54 <lispy> starx: glibc is a big run-time BTW and pretty much anything that uses c will link to it dynamically
17:48:06 <lispy> I thought gmp was lgpl
17:48:10 <Cale> hpc: lgpl
17:48:16 <lispy> and required dynamic linking
17:48:19 <starx> Well libc is part of OS
17:48:42 <simpson> Nah.
17:48:51 <hpc> i would be interested in a "GHCVM" kind of thing
17:49:01 <hpc> that just takes ghci bytecode and dumps it to a file
17:49:18 <danharaj> it doesn't require dynamic linking
17:49:39 <danharaj> but if you statically link, you are caught by LGPL
17:49:41 <geekosaur> hpc:  I think that requires a fair amount of work, plus the bytecode backend reportedly does no optimization at all
17:49:50 <hpc> ah :(
17:50:02 <hpc> it'd certainly be interesting
17:50:03 <lispy> hpc: that would work until you need something that needs a C lib
17:50:16 <lispy> hpc: then you have to arrange for the VM to go load that C lib for you
17:50:26 <lispy> not impossible, but you have to design for it
17:50:31 <starx> Perhaps I shouldnt have taked about it being completely stand alone. How about this, can executable from haskell run without haskell installed on all 3 major desktop platforms
17:50:49 <coldpizza72i> Cale: thats a good idea but I'm not sure exactly how to do that
17:50:56 <hpc> starx: you wouldn't install "haskell", but yes
17:51:08 <hpc> ghc-compiled programs do not depend on ghc to run
17:51:25 <danharaj> unless you dynamically link to the GHC RTS
17:51:26 <hpc> even the ones that use ghc-as-a-library have the whole compiler static-linked in
17:51:29 <hpc> yes, that
17:51:39 <Cale> coldpizza72i: Write a second parser which only separates comments from non-comments, and produces a String result that doesn't include the comments.
17:51:42 <ion> hpc: I think you accidentally a word.
17:51:43 <lispy> starx: the Haskell run-time gets linked into the program, so you don't have to ship the compiler. Just the libraries that the specific executable needs. On linux you can discover those with ldd. OSX has a different tool. On windows? No idea
17:51:54 <raek> danharaj: really? I thought LGPL didn't impose the license on the stuff it was linked with (static or dynamic)
17:52:00 <danharaj> lispy: candles and a ouija board on win32
17:52:15 <sclv> lgpl is sort of… complicated
17:52:27 <amalloy> so i was thinking about the simple treeSeq function at https://gist.github.com/4009630, which is supposed to give you all the nodes in anything tree-ish, given a way to find children. is it possible to use something like this to get a recursive directory listing, or is it impossible because the type of getDirectoryContents is IO [a] rather than just [a]?
17:52:35 <lispy> Having a nice BSD implementation of gmp would be great
17:53:02 <sclv> we do have a bsd drop-in replacement for gmp in ghc
17:53:03 <danharaj> amalloy: fmap
17:53:05 <sclv> it is just sloooow
17:53:07 <sclv> relatively
17:53:12 <shachaf> lispy: I'm glad you're volunteering!
17:53:16 <sclv> but don't use Integer and you won't noice
17:53:18 <sclv> notice even
17:53:19 <lispy> sclv: yeah, hence my 'nice' :)
17:53:37 <shachaf> sclv: It's also a pure Haskell implementation of Integer in particular. It does much less than GMP.
17:53:41 <danharaj> lispy: did pastorn ever come back from his abrupt absence way back when?
17:53:44 <sclv> true that
17:54:04 <lispy> danharaj: was that my gsoc student that stopped talking to me?
17:54:13 * lispy struggles with names
17:54:14 <danharaj> yes, and I suppose I can infer the answer.
17:54:35 <lispy> I think he's alive, I saw him create a G+ page, but I decided not to stalk him
17:54:42 <danharaj> ah well.
17:54:46 <lispy> For a while there I assumed he was ill
17:54:57 <danharaj> I assume he saw the state of the opengl spec and went insane.
17:55:05 <lispy> could be
17:55:15 <Sonderblade> why does this line: doc <- readDocument [] "data.xml" throw: Couldn't match expected type `IOSLA (XIOState s0) b1 b0' with actual type `IO ()'?
17:55:27 <danharaj> I tried parsing their stuff last week and quit when I found a nonsensical line that I could not find any information on how to interpret.
17:55:39 <Peaker> cabal seems to have some hacks for ghc 6.4 compatibility but the HACKING file says the policy is to support 3-year old GHC releases (6.12.1)
17:55:40 <lispy> I feel bad that the whole thing went south. I keep feeling like I should have done more, but the people I explained things to felt like he wanted to fail and I did plenty. <shrug>
17:55:52 <lispy> danharaj: OpenGLRawgen on hackage.
17:55:57 <ion> amalloy: Data.Tree.unfoldTreeM_BF
17:56:01 <lispy> danharaj: sorry, not hackage, github
17:56:02 <Peaker> I wonder if it's ok to get rid of ghc 6.4 compatibility
17:56:06 <danharaj> What amuses me most is that their registry at the bottom says "Yes we should publish this as xml, be patient ;)" and that was added several years ago.
17:56:33 <lispy> danharaj: they sell the cleaned up xml version
17:56:40 <danharaj> really? wow.
17:56:43 <lispy> danharaj: so they have little motivation to clean up the free version
17:56:57 <lispy> danharaj: I'm not 100% certain, but I recall inferring that from their website at one point
17:57:00 <danharaj> I don't blame anyone for just throwing their hands up in the air and giving up. I do that all the time! I just make sure no one is relying on me first ;)
17:58:49 <lispy> Peaker: I wouldn't support anything older than ghc 7, unless I had to. GHC just changes too much.
17:59:21 <danharaj> I hope ghc 8 is more stable.
17:59:31 <danharaj> Having major libraries have major features break on me is harrowing.
17:59:38 <typoclass> Sonderblade: hello, do you have a little more context to that question? could you paste the problematic code on hpaste, along with the complete error message? which package are you using for xml processing?
17:59:40 <Peaker> lispy, the cabal policy is to support 3 year old GHC's though
17:59:42 <typoclass> @where hpaste
17:59:42 <lambdabot> http://hpaste.org/
17:59:54 <Peaker> danharaj, especially annoying since Monad still doesn't subclass Applicative!
18:00:03 <danharaj> heh
18:00:22 <Sonderblade> typoclass: Handsomesoup
18:01:20 <lispy> danharaj: I don't think you should assume it will change anytime soon
18:01:26 <lispy> danharaj: ghc has always moved fast
18:01:46 <hpaste> sonderblade pasted “doesnt work” at http://hpaste.org/77230
18:02:21 <typoclass> Sonderblade: i see. on this page http://egonschiele.github.com/HandsomeSoup/ , he's using "readFile [...]" followed by parseHtml, where you used readDocument ...
18:03:43 <danharaj> lispy: Still, having ffi changes that break some packages is jolting.
18:03:46 <Sonderblade> typoclass: doc <- parseHtml (readFile "data.xml") produces an identical error
18:04:57 <danharaj> lispy: hey, random question. I'm shopping around for a library to structure GUI's since I want to write my own on top of opengl. Any recommendations? I am not sold on FRP's practicality.
18:05:30 <lispy> danharaj: what do you mean by structuring GUIs?
18:05:34 <typoclass> Sonderblade: you'd have to write that as «doc <- parseHtml =<< readFile "..."», or use the code as given on the web page
18:05:55 <lispy> danharaj: you want to make a crossplatform GUI (like widgets and stuff) that works when you're in an OpenGL context?
18:06:27 <Sonderblade> typoclass: that too gives the same error
18:06:31 <danharaj> lispy: yeah. handle device input, manage input focus and whatnot, and interdependencies between widgets.
18:06:48 <Peaker> danharaj, bottle has its own OpenGL widget thing. We're not quite satisfied with it but it already has nice stuff
18:06:58 <lispy> danharaj: having FFI stuff break sucks, but at least now the GHC FFI implementation is closer to matching the actual written report (it's not much to hold on to, but at least we can say it's true now)
18:07:11 <danharaj> oh ghc broke the report? I'm not sad then.
18:07:17 <danharaj> I am sad that old GHC was wrong :)
18:07:54 <danharaj> Peaker: cool I'll take a look right now.
18:08:24 <lispy> danharaj: vty-ui is a wrapper over vty that allows you to specify your gui in a more declarative way and then it manages the state of vty for you.
18:08:34 <lispy> danharaj: You might look at vty-ui to get ideas about how to do your library
18:08:45 <danharaj> I have a toy case I like to test to see how easy it is to express: A widget that displays the value of a counter, a button to increment it, and a button that is either greyed out if the counter is equal to 0 and does not respond to input, or a button that resets the counter.
18:08:54 <lispy> danharaj: vty is a ncurses replacement, so it's all terminal, but it's terminal guis
18:09:49 <typoclass> Sonderblade: you seem to be importing Text.XML.HXT.Core, which i think you got from the hxt package http://hackage.haskell.org/package/hxt the above page refers to this package http://hackage.haskell.org/package/HandsomeSoup
18:10:07 <coldpizza72i> Cale: so i wrote just a normal function to remove comments and my parse is still failing… when i use the function…. I tested it independently and it does strip the comments correctly http://ideone.com/rN2kaK
18:11:38 <danharaj> for example, I'm not sure how to get that to work in reactive-banana because it seems like it would require MonadFix to resolve the circular dependency between behaviors and event.
18:11:44 <lispy> danharaj: reactive-banana seems to be the most sane FRP impl I've seen, FWIW
18:11:59 <danharaj> And frp looks really cumbersome for dispatching events on your own instead of having another layer handle it.
18:12:11 <lispy> danharaj: post an SO question and tag it with reactive-banana. The author should be able to give you example code.
18:12:20 <danharaj> lispy: that is a good suggestion
18:12:38 <lispy> THen code it up in a few other systems and compare them
18:14:03 <Peaker> danharaj, in our widget framework, you'd have something like:  State -> Widget (Writer (Last State))   or if you just want to go all the way imperative:   IO (Widget IO)  (with an IORef State hanging around)
18:15:40 <Peaker> danharaj, a Widget is parameterized on the type constructor that wraps the widget results in the widget's event handlers. The event handlers can be in your specified functor/applicative/monad, but must give as output some stuff the Widget expects, which is why it is "Widget f" and not "Widget a"
18:17:35 <coldpizza72i> Could someone help me with my parser…When i have comments its failing to parse even though i wrote a stripComment function http://ideone.com/rN2kaK
18:18:40 <Cale> coldpizza72i: well, what's left of the program after stripping comments?
18:19:01 <Cale> Maybe look at the program carefully and parse the text by hand to find out where it's failing
18:19:13 <Cale> Or: break it down into smaller parts and check that the individual parsers work
18:19:23 <neutrino> @type maybe
18:19:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
18:19:45 <Cale> (I'm not sure whether you got my messages from before I was disconnected)
18:19:52 <neutrino> what is the first parameter?
18:19:56 <starx> Is it often that you avoid using Strings because they are lists?
18:20:01 <neutrino> oh
18:20:05 <Cale> neutrino: substitute for Nothing
18:20:05 <coldpizza72i> Cale: http://ideone.com/7SPHeH
18:20:14 <neutrino> yeah just dawned on me thanks Cale
18:20:15 <starx> For performance reasons
18:20:28 <coldpizza72i> Cale: whats left there parses on its on when i test it
18:20:37 <Cale> coldpizza72i: Okay, so there's some whitespace at the beginning
18:20:46 <Cale> coldpizza72i: Does your parser deal with that correctly
18:20:47 <Cale> ?
18:21:33 <coldpizza72i> Cale: yes
18:21:51 <lispy> classic error when writing a parser: can't handle files that start with spaces and/or comments
18:22:01 <lispy> I've seen that so many times it hurts :)
18:22:18 <coldpizza72i> i created a file that starts with whitespace and has no comments and it parses fine
18:22:53 <lispy> coldpizza72i: so if you run your stripComments function over that input, does it do its job correctly?
18:23:19 <coldpizza72i> lispy: yes as shown here http://ideone.com/7SPHeH
18:23:24 * lispy resorts to deepseq
18:23:40 <starx> I know its a vague question, but how often are [Char] the bottle neck and you have to use bytestring or whatever (and with that rewrite entire code I guess)
18:24:36 <Ralith> starx: in the general case? almost never.
18:24:56 <starx> Ok good
18:25:11 <Cale> The interfaces to Text/ByteString are very similar to the stuff you have on lists
18:25:23 <Cale> So the refactoring tends not to be hard at all
18:25:28 <Cale> also, the typechecker will help you
18:25:48 <danharaj> Peaker: Ok I see. Widgets always expect EventResult so you want something decorated on top of that.
18:26:21 <Peaker> danharaj, yeah though I believe it might have been a mistake (better to have hard-coded the EventResult requirement to specific combinators)
18:26:36 <Cale> starx: When programs are slow and they're using [Char] for strings of any appreciable length, that's a really good bet as to why they're slow.
18:26:49 <coldpizza72i> Cale: any idea whats going on?
18:27:02 <Ralith> fortunately, we have profilers, so we don't need to guess
18:27:03 <danharaj> Peaker: Well you could always use an f that takes a phantom type parameter :p
18:27:25 <Cale> coldpizza72i: Have you tried taking the program you got after removing comments, and putting it or parts of it into the smaller parsers?
18:27:29 <Peaker> danharaj, all the more reason not to have done it this way
18:27:49 <lispy> starx: it helps to understand when [a] is appropriate and when it is not appropriate.
18:28:06 <lispy> starx: for small lengths just use lists because it won't matter
18:28:14 <coldpizza72i> Cale: I'm not sure i understand what you mean… The program I'm testing is simply a single assignment
18:28:30 <lispy> starx: for long lists, you have to decide whether you're using a stream or an array. Lists are very good streams and very bad arrays.
18:28:43 <coldpizza72i> with comments it breaks but without them its fine even with whitespace at begining
18:28:49 <Cale> coldpizza72i: Right, so in ghci, runParser stmtAssignment " sum := 0  "
18:29:32 <coldpizza72i> Cale: that also works
18:29:38 <Cale> what do you get?
18:29:48 <coldpizza72i> [(Assignment (Var "sum") (Literal 0),"")]
18:29:53 <lispy> danharaj: before when I said vector was bad and list was good in my program I figured out what was wrong.
18:29:53 <danharaj> peaker: And I see you compose widgets using Widget.Box.
18:30:05 <danharaj> lispy: the alignment of the stars?
18:30:07 <Cale> and if it's prog1 instead?
18:30:35 <coldpizza72i> Cale: [(Seq (Assignment (Var "sum") (Literal 0)) Empty,"")]
18:30:38 <lispy> danharaj: It turns out that my update function (in this simulation) was not strict enough. I started printing the result each iteration and suddenly memory didn't ballon. I'm now trying to use deepseq and see that fixes my problem.
18:31:05 <Cale> coldpizza72i: and when you apply helper to that?
18:31:12 <Cale> (should work...)
18:31:59 <danharaj> lispy: How does one balance the needs of fusion and strictness? ... or does GHC ignore strictness when it does fusion transformations?
18:32:03 <lispy> deepseq is a horrible hammer that I would hate to use in production, but it's great for debugging performance
18:32:05 <danharaj> Sounds perilous either way.
18:32:25 <coldpizza72i> Cale: yes helper works for both
18:32:33 <Peaker> danharaj, yeah and other ways too
18:32:38 <lispy> I'm not sure how to balance those. Ask me agin in a few years :)
18:32:46 <Cale> coldpizza72i: okay, so are you sure that you're running the same code as you intend to be running?
18:33:02 <Peaker> danharaj, FocusDelegator is especially bad now (we changed the Widget model and FD remains with a mixture of old model and new model)
18:33:18 <Cale> coldpizza72i: Are you compiling your program? Did you forget to recompile? Is your editor saving to a different place?
18:33:40 <lispy> Check all the assumptions!
18:33:44 <Cale> coldpizza72i: If you can apply the same functions to the same data in GHCi and get a different result, something is wrong.
18:34:41 <Cale> :t fmap
18:34:53 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:34:57 <coldpizza72i> Cale: huh its working now
18:35:05 <coldpizza72i> i defenetly compiled it before
18:35:11 <lispy> this reminds me that I want a feature for GHC where you type something like -frts-chaos and you get random exceptions at random times. Why? So you can see just how robust (or not) your code is.
18:35:30 <Cale> lispy: lol
18:35:43 <Cale> Like out of memory and such?
18:36:00 <lispy> sure. Any exception haskell or C side
18:36:12 <Peaker> danharaj, you can of course see how the widget set looks like by running bottle :)
18:36:12 <lispy> Being able to tweak the generation of them is key
18:36:28 <Peaker> danharaj, which makes defining factorial take 22 keystrokes rather than 39 in a text editor :)
18:36:36 <Peaker> (for the same syntax, at least)
18:36:43 <lispy> Cale: This way, if you want to deploy and be robust to random segfaults or services going down you can actually build it into your test bed :)
18:36:54 <Cale> makes sense
18:37:37 * EvanR7 sends lispy a random exception
18:37:51 <lispy> ***Exception: Random Exception
18:39:24 <Ralith> lispy: easy enough to emulate with kill
18:39:34 <Ralith> in some aspects, anyway
18:39:40 <lispy> yeah, for signals
18:40:00 <koda> sorry for another IO question, but why won't this work?
18:40:01 <koda>         f <- liftIO (readFile (inputPath ++ fn) `catch` (readFile (alternateInputPath ++ fn) `catch` error ("File not found: " ++ fn)))
18:40:24 <Peaker> koda, what's the type of catch's second argument?
18:40:32 <lispy> :t catch
18:40:34 <lambdabot> IO a -> (IOError -> IO a) -> IO a
18:40:45 <bxx> what data type should I look for fast element look up?
18:40:54 <EvanR7> Vector ;)
18:41:03 <lispy> bxx: Data.Map?
18:41:08 <koda> ah i get it, can't have an ioerror/io a in the same return value
18:41:27 <EvanR7> theres also IntMap
18:41:31 <EvanR7> and others
18:41:40 <koda> is there any clean way of doing 'readfile, catch if not found, read from another location'?
18:41:46 <Peaker> koda, the thing on right side of `catch` is supposed to be a function... readFile (...) is not a function
18:41:49 <lispy> koda: you might want to look at onException
18:42:00 <lispy> :t onException
18:42:01 <lambdabot> Not in scope: `onException'
18:42:12 <lispy> :t Control.Exception.onException
18:42:13 <lambdabot> IO a -> IO b -> IO a
18:42:16 <bxx> thanks
18:42:30 <Peaker> koda, you could use:  action `catch` (\exc -> anotherAction)   but that's what onException basically does for you
18:42:37 <Ralith> lispy: signals like SIGSEGV, for example.
18:43:04 <Cale> :t runST
18:43:05 <lambdabot> (forall s. ST s a) -> a
18:43:08 <Cale> hmm
18:43:13 <bxx> I will use characters as a key. I guess CharMap would be prefered over Data.Map?
18:43:21 <lispy> Ralith: yes. Generating random exceptions within in the language would also be a neat feature.
18:43:23 <Cale> Well, it's no longer explicitly quantifying things
18:43:33 <Cale> I don't know whether to consider that good or bad
18:43:45 <Ralith> lispy: indeed! but you can get most of the benefit of process-level fault tolerance without it.
18:43:47 <shachaf> @ty fmap
18:43:48 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:43:50 <shachaf> Hooray, Cale++
18:43:54 <lispy> Ralith: true
18:44:07 <lispy> :t (.)
18:44:08 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:44:45 <koda> Peaker: that's perfect, thank you
18:45:11 <mikeplus64> what's the default fixity for operators?
18:45:40 <sclv> er, four?
18:45:42 <sclv> i think
18:46:26 <danharaj> Still looking for someone to explain a few details about CC-delcont et al. by the way :P
18:46:41 <sclv> danharaj: have you looked at ccshan and oleg's paper?
18:46:45 <danharaj> yes
18:46:49 <sclv> drat
18:47:06 <sclv> from shift to control -- that one?
18:47:07 <danharaj> I am not sure about the way shift is defined in terms of withSubCont
18:47:27 <danharaj> no the other one about dynamically scoped variables, and I read the paper by spj and others.
18:47:45 <lispy> danharaj: IIRC, you want dolion
18:47:48 <lispy> dolio*
18:48:01 <dolio> Eh?
18:48:07 <sclv> danharaj: shift to control is the paper you want
18:48:22 <lispy> dolio: you're the CC-delcont guru, right?
18:48:28 <dolio> Something like that.
18:48:42 <lispy> dolio: danharaj could use some help
18:48:43 <danharaj> sclv: I just need to figure out a tiny few details. :)
18:49:27 <dolio> If you want a paper on it, it's A Monadic Framework for Delimited Continuations by 4 or so people.
18:49:29 <danharaj> dolio: Could you explain to me what is meant when it is said that (\p -> withSubCont p (\k -> e)) doesn't delimit control in k or e while (\p -> shift p (\k -> e)) delimits control in both k and e?
18:50:04 <danharaj> wait
18:50:06 <dolio> Okay.
18:50:10 <danharaj> I think I just got it by asking the question >_<
18:50:16 <dolio> :)
18:50:28 <dolio> Basically it's about where control effects can escape from.
18:51:02 <danharaj> dolio: when I call k inside e, are the control effects in e masked up to the original delimiter?
18:51:12 <dolio> In shift/reset, when you do 'reset e' it's impossible for any effects to escape the reset.
18:51:14 <coldpizza72i> Whats the easiest way to add support of negative numbers to this parser http://ideone.com/rN2kaK
18:51:34 <dolio> However, with 'withSubCont' that's not true.
18:51:38 <danharaj> coldpizza72i: define a function `sub`
18:53:15 <dolio> So if you did something like 'reset p (reset p (withSubCont p (\_ -> withSubCont p (\_ -> e)) >> e'))' you'd end up skipping the e'.
18:53:44 <dolio> Because the first withSubCont gets rid of the inner reset, and the second captures up e' and throws it away.
18:53:53 <danharaj> dolio: because each withSubCont 'eats' the reset it bubbles to
18:53:57 <dolio> Yes.
18:54:39 <dolio> The other angle is that if e' contains its own withSubCont, and it gets used in a first withSubCont, the reset will also be eaten, so it will capture up to an outer one.
18:54:39 <danharaj> the definition of shift is not obvious to me: shift p f = withSubCont p $ \sk -> pushPrompt p $ f (\a -> pushPrompt p $ pushSubCont sk a)
18:54:59 <danharaj> I understand the first pushPrompt: it restores the prompt eaten by the withSubCont.
18:55:07 <danharaj> But the inner one is a bit confusing.
18:55:22 <dolio> That takes care of the situation I just mentioned.
18:55:46 <coldpizza72i> danharaj: do you know if prettyPrinting of source is a complicated thing to do
18:56:05 <lispy> coldpizza72i: it's not so bad if you use a pretty printer combinator
18:56:18 <danharaj> coldpizza72i: it is difficulty enough to be interesting to some very capable people
18:56:28 <coldpizza72i> lispy: where can i get one of those
18:57:10 <dolio> danharaj: In 'shift (\k -> ...)' k can't have any control effects. But the thing that withSubCont gives you might.
18:57:17 <dolio> Any escaping control effects.
18:57:18 <lispy> coldpizza72i: http://research.microsoft.com/en-us/um/people/simonpj/downloads/pretty-printer/pretty.html
18:57:43 <dolio> danharaj: Basically in 'shift (\k -> ...)' k is a pure function. You can write it that way with Cont.
18:58:03 <dolio> But the thing that withSubCont gives you is not a pure function.
18:58:04 <lispy> coldpizza72i: that has links to the papers that describe the library. Get the implementation from hackage
18:58:17 <danharaj> dolio: what if I have multiple nested withSubConts in k?
18:58:40 <dolio> So if we want to mimic shift, we have to delimit calls to k to make sure things don't escape.
18:59:06 <dolio> danharaj: Then you're not programming with the shift/reset abstraction, and it will escape.
18:59:17 <danharaj> oh ok I see now
18:59:19 <dolio> If you restrict yourself to shift/reset, the one delimiter works.
18:59:28 <dolio> Because all shifts in k will also delimit.
19:00:10 <dolio> Shifts to other prompts will also escape, of course.
19:00:17 <lispy> coldpizza72i: this seems nice too: http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf
19:00:27 <danharaj> dolio: but it seems like I am creating 2 delimiters for every 1 I eat.
19:00:45 <danharaj> supposing I have nested shifts, that is.
19:01:59 <dolio> danharaj: I think it's instructive to look at Cont.
19:02:18 <dolio> There, you can write: shift :: ((a -> r) -> r) -> Cont a r
19:02:27 <dolio> And reset :: Cont r r -> r
19:02:35 <dolio> With the obvious implementations.
19:02:48 <dolio> The types there ensure that no control effects escape.
19:03:16 <dolio> But, CC-delcont has a type like ((a -> CC r) -> CC r) -> CC a.
19:03:23 <dolio> Oops, that should be Cont r a earlier.
19:03:46 <danharaj> don't worry
19:03:57 <dgpratt> so installing cabal-dev will install a newer version of the network package; am I justified in being nervous about that?
19:04:08 <dolio> So, one of the prompt pushes is for ((a -> r) -> CC r) -> CC a, and the other is for ((a -> CC r) -> r) -> CC a instead of the CC type.
19:05:02 <danharaj> hm
19:05:24 <danharaj> I think I will also look at what happens with the other control operators with less protection.
19:05:27 <dolio> Two different leaks are being plugged.
19:05:47 <danharaj> (I am not sure I would like to program with anything leakier than shift/reset!)
19:05:47 <dolio> And yeah, that's the difference between all the different control operators.
19:05:56 <dolio> There's two choices and two dimensions to move through.
19:06:10 <lispy> dgpratt: yes. I would use cabal-dev
19:06:42 <danharaj> There is an example that has what I am sure is a typo in the hackage docs.
19:07:07 <danharaj> reset (\p -> shift p (\f -> (1:) `liftM` f (return [])) >= \y -> shift p (\_ -> return y))
19:07:11 <dgpratt> lispy: um....
19:07:58 <lispy> dgpratt: cabal-dev does per project sandboxes. So that way, if something wants to use a newer version of network you don't have to reinstall network in your global or per-user package db.
19:08:13 <mauke> lispy: wat
19:08:14 <rwbarton> i don't think you read the beginning of dgpratt's message
19:08:24 <lispy> Sorry
19:08:38 <dgpratt> lol
19:08:47 <rwbarton> doesn't cabal tell you what would break these days?
19:08:49 <danharaj> rwbarton: the greedy algorithm for irc advice sometimes fails.
19:08:53 <dolio> danharaj: Oh, I see. I forgot to put a > at the beginning of that line, so the first > in >>= is turning it into monospace.
19:09:54 <starx> Style question, do you prefer (Eq a) => [a] -> a  or  Eq => [a] -> a
19:10:03 <mauke> the former
19:10:08 <mauke> because it's not a kind error
19:10:31 <starx> Typo, question was about parenthesis
19:10:53 <lispy> starx: I used to always prefer the former, but then I realized it's not a big deal
19:10:53 <mauke> still the former :-)
19:11:08 <mauke> might change with constraint kinds; we'll see
19:11:15 <amalloy> thanks ion, danharaj. i eventually wrote https://www.refheap.com/paste/6392, which looks pretty rubbish but is a proof of concept that my treeSeq can be made general enough to work with any monad
19:12:47 <dgpratt> rwbarton: fwiw, cabal issued no warnings when I tried to install cabal-dev the first time (it failed on the network package due to requiring Cygwin or MSYS)
19:13:26 <rwbarton> network is not a package that comes with ghc
19:13:37 <rwbarton> so that probably means everything is all right
19:13:43 <danharaj> dolio: I figured. Is this a correct interpretation of the evaluation with s/shift/control?: the first `control p ..` is called preserving the delimiter, and then inside that expression, the delcont is called, but now in here we enter another control p which now doesn't know we went inside the first one, it only sees the outermost delimiter.
19:15:46 <dgpratt> rwbarton: ok, thanks
19:15:50 <lispy> dgpratt: do you know what things it needs? If you just need gcc, you can get that from your ghc install. Just find it and add it to your path.
19:16:15 <lispy> dgpratt: same with make, I think
19:16:32 <danharaj> with shift we always have to retrace our steps, with control we always go back straight to where we started.
19:16:35 <danharaj> (roughly speaking)
19:16:40 <dolio> danharaj: I always have to look up which is which.
19:16:44 <danharaj> haha
19:16:58 <danharaj> control delimits e in (\k -> e), but not k.
19:17:10 <dgpratt> lispy: not sure, actually, just mentions a 'configure' script
19:17:18 <dolio> danharaj: Okay, so control is the '((a -> Cont r r) -> r) -> Cont r a' version.
19:18:07 <dolio> So, in 'control p (\k -> ...)' when you call k, it can have control effects, but they can't escape the body of control.
19:18:58 <dolio> Or, further in 'control p (\k -> k e >> ...)' the 'k e' may have a control effect that captures the '...'.
19:20:49 <danharaj> ah hm
19:20:51 <lispy> dgpratt: oh, for that I think you will need a proper install of mingw
19:21:04 <dolio> With 'shift p (\k -> k e >> ...)' the 'k e' has no escaping control effects.
19:21:33 <danharaj> dolio: so control effects in 'k e' can only capture up to 'k e'
19:21:46 <dolio> Yes.
19:21:48 <danharaj> aha
19:21:55 <dolio> With shift0, that is also true.
19:21:56 <danharaj> that is one dimension down.
19:22:13 <dgpratt> trying to follow this process: http://neilmitchell.blogspot.com/2010/12/installing-haskell-network-library-on.html
19:22:24 <danharaj> dolio: is shift0 that I can capture up to some delimiter outside where I started
19:22:26 <dolio> But 'shift0 p (\k -> ...)' can have effects in the '...' that escape outside the call to shift0.
19:22:27 <dgpratt> but path spaces are vexing me presently
19:22:37 <starx> What is the proper terminology for IO functions?
19:22:46 <EvanR7> not functions
19:22:56 <dolio> And control0 has the same behavior as withSubCont. Completely unrestricted.
19:22:58 <EvanR7> i hear 'IO action' a lot
19:23:18 <danharaj> dolio: for some reason it was easy for me to understand shift/reset, control0/reset, but not the intermediates. :)
19:23:19 <lispy> something of type 'a -> IO b' would be an IO function, IMO
19:23:20 <starx> So it is main IO action, not main function
19:23:21 <rwbarton> we should maybe start with "what do you mean by 'IO function'"
19:23:36 <EvanR7> main is an IO action
19:23:40 <EvanR7> :t main
19:23:41 <lambdabot>     Not in scope: `main'
19:23:41 <lambdabot>     Perhaps you meant `min' (imported from Data.Ord)
19:23:42 <starx> rwbarton: something like main
19:23:49 <lispy> main is the interpreter that runs your IO commads!
19:23:53 <rwbarton> right, IO action then
19:23:57 <starx> Is it wrong to call main a function?
19:24:01 <dolio> danharaj: I don't know if anyone uses anything besides shift/reset really.
19:24:14 <mauke> starx: IMHO yes
19:24:15 <EvanR7> all functions in haskell take one argument
19:24:41 <dolio> Although there's a cute oleg example (I think) where shift vs. control gives you different tree traversal orders.
19:24:59 <danharaj> dolio: have you considered adding the yield combinator from the Yield: Mainstream delimited continuations paper?
19:25:06 <hasshelp> "Could not find module Data.Heap.Internal. It is a hidden module in the package `heap-1.0.0`". This comes up when trying: import Data.Heap. What should I do to be able to use Data.Heap?
19:25:08 <danharaj> (Your iterator example essentially uses it)
19:25:43 <EvanR7> main = do {print "Hello World"; main} -- ;)
19:26:05 <dolio> I haven't worked on the package in a while.
19:26:28 <danharaj> I see.
19:26:46 <dolio> And I forget what yield from that paper is, exactly.
19:27:07 <starx> evan do {} have a meaning there or are they optional
19:27:34 <EvanR7> { ; } is alternative syntax to indentation and newlines
19:27:36 <dolio> Actually, how is it not covered by the iterator/cursor stuff?
19:27:48 <geekosaur> hasshelp, normally a module is hidden because you neglected to declare a dependency on it in a cabal file.  if you're not using cabal, modules should in general not be hidden
19:27:53 <danharaj> dolio: it totally is, the name is just useful to have.
19:27:57 <starx> Oh i see
19:27:59 <dolio> Oh.
19:28:33 <rwbarton> hasshelp: this is a dumb question but that sounds like exactly the error you would get by doing "import Data.Heap.Internal"... are you 100% sure you're not doing that
19:28:46 <danharaj> it's a bit more suggestive to write 'yield x' than` shift p $ \k -> return $ I x (k $ return ())`
19:29:07 <hasshelp> geekosaur: I said `cabal install heap-1.0.0`. After that, I can run `import qualified Data.Heap as H` and `H.fromList [1 .. 5] :: MinHeap Int` just fine.
19:29:11 <hasshelp> rwbarton: I did check for that. Not doing it.
19:29:17 <danharaj> dolio: one last issue before I am 101% satisfied: what is the deal with the ~5 or so other CC-delcont packages published by Oleg?
19:29:19 <hasshelp> rwbarton: I only import Data.Heap.
19:29:26 <rwbarton> wait, so what is the problem?
19:30:12 <hasshelp> rwbarton: I should have specified. I can only run that in GHCI directly. When I try loading my program from a text file, I get the error.
19:30:41 <dolio> danharaj: I don't know if you read the paper I mentioned earlier, but it has like 3 different implementations. Oleg played with them all at some point, and benchmarked them, when he was working on his delimited continuation based filesystem thing.
19:30:45 <rwbarton> how are you "loading your program from a text file"?
19:30:59 <dolio> The one in CC-delcont is the one that benchmarked the fastest, I think.
19:31:04 <mauke> inb4 wrong file
19:31:22 <hasshelp> rwbarton: By using `:l`.
19:31:22 <dolio> And it's based on an updated version of the paper from when oleg played around with them.
19:31:35 <dolio> And I think I picked better combinator names than oleg typically does. :)
19:31:47 <rwbarton> does this happen even if you start a new ghci?
19:31:59 <rwbarton> i.e. are you using a ghci you started before doing the cabal install
19:32:00 <mauke> hasshelp: what's the exact command you're using?
19:32:14 <dolio> I don't think oleg publishes on Hackage, though. That was someone else putting his stuff up there.
19:32:30 <davesque> is there a way two apply a function between all possible combinations of values in two lists?
19:32:37 <danharaj> dolio:  There are a bunch of papers so I get them mixed up. Thanks a lot for your time. I feel like I have a shiny new hammer and I need a nail to destroy now.
19:33:12 <mauke> davesque: "apply between"?
19:33:44 <EvanR7> davesque: list comprehension
19:33:48 <lispy> mauke: kind of like zipWith ($), but with more combinations
19:34:00 <lispy> that one only does pairwise
19:34:02 <EvanR7> or [] monad instance
19:34:07 <davesque> right, so given [1,3,5] and [2,4,6] and f = (+), how do i get [1+2, 1+4, 1+6, 3+2, 3+4, 3+6] etc.
19:34:25 <davesque> ahh, right
19:34:29 <lispy> davesque: sounds like list comprehension time
19:34:34 <dolio> danharaj: No problem.
19:34:38 <davesque> forgot about those things :)
19:34:42 <hasshelp> mauke: :l test.hs
19:34:44 <mauke> > map (uncurry (+)) (liftM2 (,) [1,3,5] [2,4,6])
19:34:45 <lambdabot>   [3,5,7,5,7,9,7,9,11]
19:34:57 <hasshelp> rwbarton: I am not. I did open many new ghci sessions.
19:35:03 <davesque> cool
19:35:15 <lispy> > map (uncurry (+)) (liftA2 (,) [a,b,c] [e,f,g])
19:35:16 <lambdabot>   [a + e,a + f,a + g,b + e,b + f,b + g,c + e,c + f,c + g]
19:35:18 <gwern> lambdabot: @join #lesswrong
19:35:19 <rwbarton> are you in a directory with a Data/Hash.hs file?
19:35:28 <mauke> > liftM2 (+) [1,3,5] [2,4,6]
19:35:30 <lambdabot>   [3,5,7,5,7,9,7,9,11]
19:35:31 <rwbarton> uh, Heap.hs that is
19:35:37 <hasshelp> rwbarton: No.
19:36:05 <mrlemao`> typoclass: 'lift' is what I was looking for! within the Server monad I can lift the computation into the Process monad, which is the one StateT is wrapping
19:36:20 <lightquake> is there a type-level $
19:36:21 <lightquake> ?
19:36:43 <hasshelp> rwbarton: Correction -- yes I was.
19:36:50 <byorgey> lightquake: no, but you could make one
19:37:01 <rwbarton> that will tend to confuse ghci
19:37:15 <hasshelp> rwbarton: Makes sense. Thanks for the help.
19:37:47 <lightquake> byorgey: is there a generally-agreed-on symbol for it?
19:38:20 <byorgey> lightquake: no, but something like :$: seems reasonable
19:38:23 <lightquake> i guess :$ would work
19:38:23 <lightquake> yeah
19:38:36 <lightquake> in 7.6 I think even $ is legal
19:38:42 <byorgey> true
19:39:13 <lispy> and LANGUAGE TypeOperators or whatever it's called might help syntatically
19:39:21 <lispy> But, how do you define it?
19:39:28 <lispy> data a :$ b = ??
19:39:33 <typoclass> mrlemao`: well done :-)
19:39:34 <lightquake> > type a ::: b = a b
19:39:35 <lambdabot>   <hint>:1:1: parse error on input `type'
19:39:41 <lightquake> oh right
19:39:42 <lispy> I keep wanting to say, type a :$ b = a b
19:39:51 <lightquake> i mean that works for me
19:40:15 <lightquake> Prelude> type x :$: y = x y
19:40:15 <lightquake> Prelude> [2] :: [] :$: Int
19:40:15 <lightquake> [2]
19:40:38 <lispy> okay, that's fun. I didn't realize that would work
19:43:40 <Nereid> Id would work.
19:43:54 <Nereid> type Id a = a
19:43:59 <Nereid> maybe you'd want PolyKinds
19:44:09 <Nereid> to get Id :: k -> k
19:44:24 <mrlemao`> typoclass: it must look like a nothing accomplishment from above :-)
19:46:19 <typoclass> mrlemao`: no, everyone was a haskell newbie at some point :-) even the guys who understand haskell the best, or have the most code on hackage
19:46:28 <danharaj> uh
19:46:39 <lightquake> i'm pretty sure oleg was born knowing haskell
19:47:07 <danharaj> There's also the ones who were in the committee that designed the language ;)
19:47:16 <typoclass> lightquake: i'm pretty sure oleg wasn't born, technically
19:47:41 <danharaj> although I don't think many people were experts at lazy semantics from the start.
19:47:42 <mauke> oleg is an anagram of lego. co-incidence?
19:47:43 <lightquake> danharaj: well there was still a point where they didn't know anything about haskell! :D
19:47:59 <danharaj> lightquake: considering how similar Haskell is to Miranda, you'd be surprised :P
19:48:14 <lightquake> well, they had to learn miranda
19:48:31 <danharaj> well you certainly can't be a newbie at something that hadn't yet existed
19:48:49 <lightquake> true
19:49:05 <mauke> oh yeah?
19:49:35 <lightquake> mauke: yes, because being a newbie to X implies you've just started learning X
19:49:39 <lightquake> and you can't learn a nonexistent thing
19:49:44 <mauke> challenge accepted
19:51:35 <ParahSailin> @hoogle bracket
19:51:36 <lambdabot> Control.Exception.Base bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:51:36 <lambdabot> Control.Exception bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:51:36 <lambdabot> Control.OldException bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
19:52:02 <typoclass> lightquake: i think you can have a will to learn about gwimbledoddle, and know nothing about gwimbledoddle, and design and explore it over the next few months. i don't see why that shouldn't count as being a newbie
19:53:10 <lightquake> imo that's only true if gwimbledoddle actually existed beforehand. like we can learn about the geography of alpha centauri's planets, because that exists whether we know about it or not
19:53:44 <mauke> I can learn about the geography of middle earth
19:55:43 <lightquake> well yes, but that's because tolkien already made it up
19:55:55 <EvanR7> alpha centauri has no known planets
19:56:12 <lightquake> http://www.nasa.gov/home/hqnews/2012/oct/HQ_12-366_NASA_Statement_Alpha_Centauri.html
19:56:17 <EvanR7> wut
19:56:56 <EvanR7> holy shite
19:59:52 <EvanR7> i cant wait to see mind worms in the zoo
20:00:05 <EvanR7> joke probably made a million times by now
20:03:33 <gwern> @quote mind.*worm
20:03:34 <lambdabot> No quotes match. Wrong!  You cheating scum!
20:03:40 <gwern> EvanR7: apparently not
20:04:35 <mauke> the last metroid is in captivity. the galaxy is at peace.
20:04:47 <EvanR7> haha
20:05:00 <parcs`> @quote worm
20:05:00 <lambdabot> Cale says: I plan on forming a symbiotic relationship with sandtrout, which, as they merge with my body, will sustain me as I slowly turn into a sandworm, and make use of my billions of other
20:05:00 <lambdabot> memories and prescience to rule over everyone and everything for millenia.
20:05:28 <EvanR7> o_O
20:05:32 <mauke> well then
20:05:56 <mauke> dune dune DUN!
20:08:16 * geekosaur has been occasionally noodling an alternate world whose magic is based on category theory...
20:09:56 <mauke> cowizards of the ast
20:10:54 <EvanR7> lol
20:20:42 <koda> is there a way to get the separate values from this datatype? data Flag = Name String | Input String | Output String | Alternate String
20:20:42 <koda> t
20:22:47 <ion> λ> data Flag a = Name a | Input a | Output a | Alternate a deriving Data.Foldable.Foldable
20:22:49 <ion> λ> Data.Foldable.toList (Output "foo")
20:22:51 <ion> ["foo"]
20:23:18 <ion> foo (Name a) = a; foo (Input a) = a; foo (Output a) = a; foo (Alternate a) = a
20:23:22 <Polarina> Is there a shorter way do to this code?
20:23:24 <Polarina> > zip (concat $ repeat [1..5]) (concatMap (replicate 5) [1..3])
20:23:25 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(1,2),(2,2),(3,2),(4,2),(5,2),(1,3),(2,3),(3...
20:23:51 <ion> > liftA2 (,) [1..5] [1..3]
20:23:52 <lambdabot>   [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(5...
20:24:18 <Polarina> ion, thanks. :D
20:24:27 <ion> > liftA2 (flip (,)) [1..3] [1..5]
20:24:28 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(1,2),(2,2),(3,2),(4,2),(5,2),(1,3),(2,3),(3...
20:25:26 <typoclass> Polarina: also, concat $ repeat is the same as cycle
20:25:30 <u_> when does CSE result in worse performance?
20:25:55 <shachaf> For example, when it stops something from being GCed for a while.
20:26:17 <ion> > [ (b,a) | a <- [1..3], b <- [1..5] ]
20:26:18 <lambdabot>   [(1,1),(2,1),(3,1),(4,1),(5,1),(1,2),(2,2),(3,2),(4,2),(5,2),(1,3),(2,3),(3...
20:26:24 <shachaf> ([1..] !! 1000000, [1..] !! 2000000)
20:27:58 <EvanR7> i am so frustrated with mainstream support for html 'templating', the static pages of a site are such a good place for a declarative language with functions
20:28:06 <EvanR7> php failed miserably at that
20:28:17 <EvanR7> ssi has fallen way out of favor
20:28:18 <koda> ion: i get     Ambiguous occurrence `concat'
20:28:22 <EvanR7> and isnt functional
20:28:49 <EvanR7> erb syntax for using a template is painful
20:28:59 <shachaf> koda: I bet your occurrence of `concat' is ambiguous.
20:29:03 <EvanR7> none of the whizbang hipster markup languages support functions
20:29:16 <ion> koda: Ignore the Foldable example, it was a bit tongue-in-cheek. See “foo” after that.
20:29:45 <koda> foo (Name a) = a; foo (Input a) = a; foo (Output a) = a; foo (Alternate a) = a ?
20:29:57 <ion> yes
20:30:04 <koda> sorry, what's foo?
20:30:15 <ion> A function. Feel free to name it something else.
20:30:45 <shachaf> ion: Could I name it bar?
20:30:57 <ion> shachaf: No, that’s the only name that’s disallowed.
20:33:30 <koda> umh No in scope type variable 'a'
20:33:34 <koda> Not*
20:33:45 <typoclass> EvanR7: i think it's weird that they keep making these little languages with variables, then add if-then-else, then add for loops. i feel at that point you might as well admit that now it's time for a full programming language
20:34:07 <koda> basically i'm trying to parse the command line parameters and i have them stored in flags
20:34:07 <typoclass> i dunno, i don't really understand it
20:34:19 <koda> i now need to use their value inside my function
20:34:45 <EvanR7> typoclass: css preprocessors, variables, but no functions
20:34:50 <EvanR7> i really dont understand
20:35:00 <EvanR7> and when i complain, people are like wtf would you use functions for
20:35:51 <EvanR7> it doesnt need to be a full programming language
20:36:11 <typoclass> koda: there's some libraries for parsing command-line options :-) although of course you're free to write one for yourself as an exercise
20:36:38 <koda> typoclass: well i followed one tutorial and got the basics
20:36:59 <koda> but i can't get out of 'ok i parsed the args, now what?' phase
20:37:42 <EvanR7> full programming languages crash or go into infinite loops, so just add support for something less powerful, but they add the wrong stuff
20:37:49 <EvanR7> in particular fing for loops
20:37:51 <EvanR7> >_<
20:38:32 <typoclass> koda: no, i meant, if you decide to parse the command-line arguments yourself in order to just write some haskell code, that's fine. i just wanted to make sure that in 3 days you don't say "oh god i could have saved so much work if i had known"
20:39:00 <monochrom> I think you misunderstand. the point is not "will it crash or infinite loop". the point is "I don't understand functions"
20:39:55 * EvanR7 thinks
20:40:36 <EvanR7> shell script files have a good setup, each file takes arguments $1 $2 etc, and can be easily used in other files
20:40:48 <EvanR7> and a comment at the top can document whats expected
20:40:58 <EvanR7> now to target html files
20:41:43 <EvanR7> it cant compute crosstabs but thats usually all you care about when making a website is substituting other html
20:42:03 <EvanR7> and no, not freakin include header, blah blah, include footer, who the hell came up with that
20:44:58 <koda> umh, would it be bad if i showed some code?
20:45:15 <typoclass> koda: not at all :-) we have hpaste for that
20:45:17 <lispy> koda: no, just use something like hpaste
20:45:18 <typoclass> @where hpaste
20:45:18 <lambdabot> http://hpaste.org/
20:45:33 <lispy> @quote stereo
20:45:33 <lambdabot> LoganCapaldo says: * LoganCapaldo must resist urge to mention stereo
20:45:37 <lispy> @quote stereo
20:45:37 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
20:46:11 <EvanR7> welcome to #haskell, where your questions are answered in hi-fi
20:46:46 <ion> Welcome to #haskell, where your questions are answered in Ambisonics.
20:47:16 <koda> http://hpaste.org/77233
20:47:41 <koda> i got two problems i can't get past, first is the one i mentioned, about using the parsed command lines
20:47:54 <koda> and the second is that this check fails if you don't pass any arg at all
20:48:42 <koda> (this is the tutorial i followed http://leiffrenzel.de/papers/commandline-options-in-haskell.html)
20:50:49 * hackagebot network-bitcoin 1.0.0 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.0.0 (ClarkGaebel)
20:50:51 * hackagebot network-bitcoin 1.0.1 - An interface to bitcoind.  http://hackage.haskell.org/package/network-bitcoin-1.0.1 (ClarkGaebel)
21:08:56 <pordan30> suppose i have a partial functions like pop :: stack a -> (a, stack a), lookup :: k -> heap k a ->  a, etc., that i wish to parameterize over an arbitrary error type, so that pop :: error m => stack a -> m (a, stack a), lookup :: error m => k -> heap k a -> m a. however, i want different functionality for different m and a monadic interface to for monadic m. is there an existing library for this? this looks like a job for error or
21:08:56 <pordan30>  errot, but i'm not sure how to capture this correctly.
21:10:04 <edwardk> pordan30: look up MonadError in the mtl
21:10:39 <edwardk> alternately you could just work with Alternative or MonadPlus
21:12:11 <pordan30> edwardk: thanks: monaderror looks like a good solution
21:13:03 <lispy> pro tip: If your library has an internal module, go ahead and export it. Eventually one of your users will need to dig deep into your library.
21:13:34 <lispy> If you're worried they'll use it incorrectly, just put Internal in the name somewhere
21:15:06 <shachaf> What if you don't want people to depend on implementation details?
21:15:22 <lispy> That's their problem not yours.
21:15:49 <shachaf> Except for the part where it turns into your problem.
21:15:53 <lispy> I'm running into this with gloss
21:16:07 <lispy> I have to locally fork gloss just to benchmark it
21:20:06 <flonum> Is there a sensible way to attach a WARNING pragma to an internal module to warn people?
21:20:37 <flonum> yesterday there was a guy on SO who let GHC infer an internal type for some Happstack monad
21:20:46 <flonum> not cool
21:23:29 <koda> umh any help for my command line parser? http://hpaste.org/77233
21:27:14 <latro`a> I don't see where you have a problem
21:31:07 <koda> latro`a: flags should contain my parsed arguments, but i can't access it
21:31:20 <latro`a> why can't you access it?
21:32:06 <koda> latro`a: i need to pass it a function that takes 4 Strings
21:32:23 <koda> so i thought of doing something like foo flags !! 0 flags !! 1
21:32:24 <koda> etc
21:32:26 <latro`a> pass what, flags?
21:32:32 <latro`a> what type is flags
21:32:49 <monochrom> you need more parens. foo (flags !! 0) (...) (...)
21:34:09 <lispy> parens are small, take lots!
21:34:12 <koda> and the other problem is that i can pass 0 arguments and the program would not stop the user
21:34:30 <latro`a> that one can be corrected by matching getArgs differently
21:35:08 <latro`a> or in various other ways (though with getArgs in particular, you can't really loop)
21:35:36 <koda> maybe with _ -> ?
21:35:38 <latro`a> (I have a function I've used in a toy program that does some IO, checks whether it got the desired sort of input, then takes it or scolds the user and tries again)
21:35:52 <latro`a> but if you just want pattern match failure on zero arguments
21:35:54 <monochrom> yes, _ -> code
21:35:59 <latro`a> (x:_) <- getArgs
21:36:01 <monochrom> err, no, not _ -> code
21:36:01 <latro`a> does that
21:36:34 <latro`a> it'll crash the whole program if it fails, of course
21:36:37 <Jafet> > let f x(:){} = x in f []
21:36:39 <lambdabot>   *Exception: show: No overloading for function
21:36:47 <Jafet> > let f x@(:){} = x in f []
21:36:48 <lambdabot>   *Exception: <interactive>:3:5-17: Non-exhaustive patterns in function f
21:37:07 <Ralith> what're the {} doing there
21:37:28 <Jafet> > let f x@(:) = x in f []
21:37:30 <lambdabot>   Constructor `:' should have 2 arguments, but has been given none
21:37:51 <lispy> Ralith: because of record syntax you can use {} in a pattern to ignore the arguments to the data constructor
21:37:59 <Ralith> ah.
21:38:08 <latro`a> that's cute
21:38:08 <lispy> > Just {} <- return (Just 1)
21:38:09 <lambdabot>   not an expression: `Just {} <- return (Just 1)'
21:38:18 <lispy> that's not an expression, but you get the idea :)
21:38:25 <Ralith> ^^
21:38:50 <monochrom> > case Just 1 of Just{} -> "success"
21:38:53 <lambdabot>   "success"
21:39:10 <parcs`> > Just{}
21:39:11 <lambdabot>   Just *Exception: <interactive>:3:1-6: Missing field in record construction
21:39:18 <parcs`> > Just{}{}
21:39:19 <lambdabot>   <hint>:1:7: Empty record update of: Just {}
21:39:28 <lispy> it's nice for isFoo functions
21:39:32 <Jafet> > (+)
21:39:34 <lambdabot>   *Exception: show: No overloading for function
21:39:51 <lispy> isFoo (Foo {}) = True; now you never need to update this if someone adds or removes the Foo constructor
21:40:07 <lispy> adds to or removes from the Foo constructor*
21:40:08 <koda> umh i get something new
21:40:09 <koda> Warning: Pattern match(es) are overlapped
21:40:09 <koda>              In a case alternative: _ -> ...
21:40:39 <monochrom> then yes your patterns are overlapped
21:40:57 <Ralith> I don't often have both record syntax and multiple constructors in the same adt
21:41:27 <lispy> Ralith: Yeah, that would be bad. The key here is that you don't have to be using a records iny our adt definition
21:42:02 <koda> hm, i'm tempted to do if length args = 0...
21:42:03 <lispy> > let { myIsJust (Just {}) = True; myIsJust _ = False } in myIsJust Nothing
21:42:04 <lambdabot>   False
21:42:15 <Ralith> ah, right
21:42:32 <Jafet> @quote isJust
21:42:33 <lambdabot> ddarius says: isJust :: Maybe a -> Bool; isJust = unsafeCoerce
21:42:33 <monochrom> "[] -> code here" supersedes "if length args = 0"
21:43:18 <latro`a> I still can't believe that actually works
21:43:22 <latro`a> even though I understand that it does
21:43:29 <lispy> how does that work?
21:43:32 <latro`a> and why it does
21:43:35 <latro`a> the unsafeCoerce one?
21:43:39 <lispy> yeah
21:43:42 <latro`a> it's dependent on the internal representations of the constructors
21:43:45 <Jafet> data Bool = False | True
21:43:50 <Jafet> data Maybe a = Nothing | Just a
21:43:55 <latro`a> and in particular the order in which they are declared
21:43:58 <lispy> ah
21:44:09 <lispy> that is all kinds of evil
21:44:11 <latro`a> the initial bits of the two constructors line up because they are in the same place in their respective constructor sequences
21:44:20 <latro`a> so unsafeCoerce noms them up and it works
21:44:36 <monochrom> heh
21:44:57 <monochrom> it's evil. we won't use it. don't worry about it
21:45:37 <koda> is it possible to have an explicit return value? like something header = "Usage: " ++ getProgName ++ " pas2c [OPTIONS...]"
21:46:01 <lispy> explicit return value?
21:46:12 <shachaf> getProgName isn't a string, by the way.
21:46:17 <shachaf> Other than that I don't know what you mean.
21:46:17 <koda> :o
21:46:36 <koda> i thought it was and so concatenable
21:46:48 <lispy> @hoogle getProgName
21:46:48 <lambdabot> System.Environment getProgName :: IO String
21:46:58 <lispy> IO String != String
21:47:27 <Ralith> compare: Maybe String != String
21:48:06 <shachaf> @quote /bin/ls
21:48:06 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
21:48:17 <copumpkin> quoting yourself
21:48:18 <lispy> nice
21:48:20 * copumpkin shakes his head
21:48:30 <monochrom> I quote myself all the time, too
21:48:35 <latro`a> technically /bin/ls contains a list of strings
21:48:36 * lispy too
21:48:36 <monochrom> @quote monochrom faster
21:48:36 <lambdabot> monochrom says: einstein's theory implies that haskell cannot be faster than c
21:48:37 <latro`a> ;p
21:48:54 <lispy> monochrom: oooh
21:49:01 <shachaf> copumpkin: The thought process was "what was that brilliant thing that someone (I can't recall who) once said in #haskell?".
21:49:17 <Jafet> @quote IO.String
21:49:18 <lambdabot> kmc says: it is not hard to troll #haskell for real; you just have to get confused and confrontational about how to convert IO String to String
21:49:27 <monochrom> @quote monochrom String
21:49:28 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
21:49:28 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:49:28 <copumpkin> I like monochrom's question
21:49:32 <copumpkin> not that one
21:49:34 <sclv> wow, ocaml's hackage is looking pretty neat: http://opam.ocamlpro.com/
21:49:42 <copumpkin> @quote monochrom IO
21:49:43 <lambdabot> monochrom says: in Soviet Russia, current continuation calls procedure (CCCP)
21:49:45 <copumpkin> @quote monochrom IO
21:49:46 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice. Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.  Licence
21:49:46 <lambdabot> to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
21:49:47 <monochrom> @quote monochrom IO.String
21:49:48 <lambdabot> monochrom says: How do I extract the IO out of IO String?
21:49:49 <Maxdamantus> Are there any occurances of free type variables (relative to whole type expressions) other than in class definitions?
21:49:51 <copumpkin> there we go
21:50:18 <Maxdamantus> and .. instance definitions, presumably.
21:50:22 * lispy checks
21:50:29 <Maxdamantus> Yeah, those too.
21:50:32 <copumpkin> sclv: it looks prettier! we clearly need to bootstrap our hackage
21:50:54 * hackagebot GLFW 0.5.1.0 - A Haskell binding for GLFW  http://hackage.haskell.org/package/GLFW-0.5.1.0 (PaulLiu)
21:51:26 <lispy> sclv: hey maybe they'll finally upgrade to 32/64 bit ints
21:51:41 <monochrom> Maxdamantus: perhaps "data X a = C a a" counts?
21:52:07 <Maxdamantus> Yeah, I guess so.
21:52:17 <lispy> copumpkin: yeah, it is a bit prettier.
21:53:40 <monochrom> cabal install opam
21:53:55 <latro`a> ....
21:53:55 <latro`a> wow
21:53:58 <latro`a> that CCCP joke
21:53:58 <lispy> Not sure I like their packaging syntax: http://opam.ocamlpro.com/doc/Packaging.html
21:54:00 <latro`a> that's ridiculous
21:54:03 <monochrom> haha
21:55:33 * Maxdamantus wonders if there's a funny extension that lets you bind type variables over any expressions.
21:55:38 <rwbarton> just be glad it has no ;;
21:55:52 <monochrom> haha
21:57:08 <lispy> Maxdamantus: there is a LexicallyScopedTypeVariables extension
21:57:37 <Maxdamantus> That sounds like it.
21:58:02 <jfischoff> Is it possible to write higher order type functions, like map, with type families?
21:58:34 <lispy> jfischoff: I can't decide how to evaluate that.
21:59:31 <jfischoff> which part?
21:59:49 <lispy> jfischoff: sorry, joke about type level functions are not always funny, even here.
22:00:03 <jfischoff> ;)
22:01:30 <sclv> omg that syntax is awful
22:01:38 <copumpkin> jfischoff: sure
22:01:40 <sclv> its like they took makefiles and stuck some braces on
22:02:03 <lispy> sclv: yeah, but they do allow git to host the package. I quite like that feature.
22:02:14 <jfischoff> copumpkin: do you have to anything special?
22:02:18 <copumpkin> jfischoff: nope
22:02:24 <copumpkin> I can throw together a quick example if you want
22:02:33 <jfischoff> let try real quick
22:02:59 * lispy benchmarks the bits out of this code
22:04:18 <sclv> also submitting a package apparently involves a pull request on github....
22:04:28 <sclv> this infrastructure feels more minimal than i realized
22:05:34 <lispy> ah, I Couldn't find that because the section where that is explained is confusingly title, "Including packages to the official OPAM repository"
22:05:39 <lispy> including to?
22:08:05 <sclv> cabal is really a pretty amazing system when you think about it
22:08:10 <sclv> for all our complaints
22:08:13 <copumpkin> yeah
22:08:46 <sclv> dynamic languages where you can just throw all the code together and maybe it breaks but you don't notice till runtime are one extreme
22:08:59 <sclv> and vm languages where you just distribute bytecode are the other
22:09:27 <sclv> meanwhile given our constraints we have good centralized discovery + dependency info
22:09:40 <sclv> and a "just works" install system outside of dep hell
22:09:54 <sclv> which makes it crazy easy to create a package as well as to install it
22:10:07 <danharaj> cabal was not designed to build frameworks with tight constraints into a general package database.
22:10:20 <danharaj> Things like that ought to be put in sandboxes, which will happen next release.
22:10:53 <copumpkin> I'd also contribute to a kickstarter if dcoutts wanted to start one
22:10:56 <copumpkin> *nudge* *nudge*
22:11:01 <kallisti> how would you write the forgetful functor from monads to their underlying endofunctor in Haskell?
22:11:13 <shachaf> dcoutts: You're planning to start one?
22:11:32 <sclv> as i said, i'd like the haskell.org committee to help manage money so we could get the nonprofit thing going
22:12:07 <rwbarton> kallisti: you can't really because there is no way to talk about "the category of monads and monad homomorphisms"
22:12:10 <sclv> if that's feasible
22:12:23 <latro`a> anything categorical in haskell is pretty much on Hask
22:12:37 <latro`a> (I exaggerate somewhat, but yeah)
22:13:02 <Cale> kallisti: I guess if you really wanted to name it, you could write newtype Forget f a = F (f a), and then write an instance (Functor f) => Functor (Forget f)
22:13:05 <hpaste> “Jonathan Fischoff” pasted “Type level Map” at http://hpaste.org/77234
22:13:21 <Cale> kallisti: But yeah, that's not really the right thing.
22:13:29 <latro`a> nothing prevents a Monad instance there ofc
22:13:30 <jfischoff> copumkin: what am I doing wrong here http://hpaste.org/77234
22:13:43 <lispy> sclv: h.o committee joined SPI so that SPI can manage that stuff
22:14:08 <rwbarton> you can't pass around a type family like that
22:14:10 <lispy> sclv: So, while we haven't been taking donations we could be really.
22:14:16 <jfischoff> copumkin: I'm getting Type synonym `ToInt' should have 1 argument, but has been given none ...
22:14:38 <rwbarton> you can try LiberalTypeSynonyms but I expect it won't help
22:14:43 <lispy> sclv: We really need more a charter type document to help guide/govern what the committee does with donations
22:14:44 <rwbarton> what ghc version btw?
22:14:54 <shachaf> jfischoff: ToInt isn't a thing of kind * -> *
22:15:05 <shachaf> It behaves like a type synonym, i.e. something that needs to be fully applied.
22:15:10 <jfischoff> is it a Constraint
22:15:18 <shachaf> No.
22:15:20 <lispy> sclv: does any of that make sense?
22:15:30 <shachaf> It's like "type Foo x = Blah"
22:15:43 <jfischoff> shachaf: what should I use instead?
22:15:43 <shachaf> Foo on its own doesn't mean anything.
22:16:02 <rwbarton> an actual type constructor
22:16:08 <rwbarton> data family would work i suppose
22:16:46 * lispy also notes that the haskell.org committee has a slot open right now for people who want to help
22:16:54 <lispy> go nominate yourself!
22:16:55 <shachaf> Well, that wouldn't really achieve jfischoff's goals here, I assume.
22:17:01 <shachaf> lispy: Can I nominate rwbarton?
22:17:15 <lispy> shachaf: as long as rwbarton agrees :)
22:17:17 <sclv> lispy i agree except for the charter
22:17:18 <sclv> i
22:17:18 <shachaf> I already nominated him to the Lambdabot Committee.
22:17:28 <shachaf> lispy: Aw.
22:17:34 <sclv>  just think the committee should have funds where it can route earmarked donations
22:17:43 <sclv> and then just start freaking soliciting
22:18:16 <lispy> sclv: We need a "donate to haskell.org" button, I suppose?
22:18:28 <shachaf> GHC Premium Edition
22:18:34 <sclv> forget buttons.
22:18:38 <osa1> how can I do that "As an exercise, implement an instance for Char that maps back to the Int instance using the conversion functions Char.ord and Char.chr." in http://www.haskell.org/haskellwiki/GHC/Type_families ?
22:18:44 <sclv> we want donations in the hundereds and thousands
22:18:49 <sclv> not like a freaking flattr
22:18:56 <jfischoff> a simple constructor is not what I want…I wouldn't know about data family though
22:19:00 <sclv> i mean i guess butons would be nice and taking cards
22:19:05 <copumpkin> jfischoff: you need to wrap it in a newtype
22:19:16 <copumpkin> you can't partially apply type synonyms or families
22:19:22 <sclv> if ppl wan to give 100 + tho and want a receipt for tax purposes they're going to be willing to write a check
22:19:45 <EvanR7> cough bitcoins
22:19:48 <EvanR7> ;)
22:20:20 <jfischoff> copumkin: what would the newtype be for this example?
22:23:51 <jfischoff> oh wait
22:24:00 <jfischoff> any newtype will work?
22:24:09 <jfischoff> with the write kind?
22:24:11 <jfischoff> right
22:26:18 <rwbarton> any actual type constructor. newtype, data, data family (I think), (->) a etc. etc.
22:26:39 <copumpkin> yep
22:30:34 <jfischoff> hmm I didn't set up my test correctly
22:30:53 <jfischoff> I need this trigger a compiler error if the conversion doesn't work…one sec
22:35:17 <copumpkin> jfischoff: http://hpaste.org/77235
22:35:19 <copumpkin> doesn't have a newtype for you
22:35:55 * hackagebot netwire 4.0.2 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.2 (ErtugrulSoeylemez)
22:35:57 * hackagebot netwire 4.0.3 - Flexible wire arrows for FRP  http://hackage.haskell.org/package/netwire-4.0.3 (ErtugrulSoeylemez)
22:38:47 <jfischoff> mapping a heterogeneous collection of values is very cool
22:39:45 <copumpkin> yeah, unfortunately my mapH requires you to be parametric
22:39:55 <copumpkin> which makes it harder for something like a type family to work
22:41:32 <jfischoff> right
22:41:53 <jfischoff> I'm not seeing a good way to get what I want yet
22:42:22 <jfischoff> but this is the test function I wanted test :: (((Map ToInt [Float, Double]) :==: xs) ~ 'True)  => HList xs -> Char
22:42:51 <mm_freak> i think the only type of heterogenous collection in haskell is a constructor with multiple fields of different types
22:44:14 <lispy> if you {-# INLINE #-} a slow function and that makes it disappear in the .prof, then you've removed the slowdown, right? ;)
22:44:17 <elliott> jfischoff: you may be interested in: http://hpaste.org/76553
22:44:23 <copumpkin> lispy: sounds legit
22:44:38 * lispy totally gets the benchmark game
22:45:06 <lispy> Actually I have a quadtree that is creating way too many allocations
22:45:10 <lispy> Not really sure how to improve it
22:45:38 <otters> @pl \x -> if x == 1 then "" else "s"
22:45:38 <lambdabot> flip (flip if' [] . (1 ==)) "s"
22:45:45 <danharaj> when is it making the allocations?
22:46:07 <lispy> danharaj: this algorithm rebuilds the quadtree whenever the particles move
22:46:18 <jfischoff> elliot: looks promising
22:46:38 <lispy> danharaj: so, I guess I would say it does the allocations all the time
22:47:14 <elliott> jfischoff: it is sort of a mess in practice
22:47:18 <danharaj> lispy: Can you tweak the bucket size at the leaves?
22:47:29 <elliott> jfischoff: though i think All is definitely nicer as a constraint, not a data type
22:47:48 <elliott> the whole using a type family to pass around an unapplied type function thing is gross though
22:48:12 <lispy> danharaj: it uses regions
22:48:49 <jfischoff> elliot: well writing map special for a specified type of type level list is annoying
22:49:08 <elliott> jfischoff: my Map is polymorphic
22:49:10 <elliott> type family Map (f :: a -> b) (xs :: [a]) :: [b]
22:49:41 <elliott> the MapR stuff is fussier but i think it could be relaxed
22:49:44 <danharaj> lispy: so each leaf is a particle?
22:50:11 <danharaj> (or empty)
22:50:12 <jfischoff> sure but how do I write pass in something that can take Float -> Int?
22:50:44 <elliott> jfischoff: i don't understand... there's no such thing as a type-level Float
22:51:31 <jfischoff> elliot: HList [Float, Float] -> HList [Int, Int]
22:51:39 <lispy> danharaj: to be honest, I'm not sure (I didn't write this code)
22:51:51 <danharaj> ahh are you using Gloss's quadtrees? :)
22:52:01 <lispy> danharaj: it may also reduce to a minimum area?
22:52:03 <lispy> danharaj: no
22:52:08 <lispy> danharaj: it has quad trees?
22:52:24 <elliott> jfischoff: right, you can do that with mapElimH' pretty easily... or build it on top of mapH'' (it is bascially a specialisation)
22:52:26 <lispy> danharaj: I'm trying to make a friend's code go faster
22:52:33 <elliott> indeed mapElimH' is pretty easy to define in terms of mapH''
22:53:02 <jfischoff> let me see if I can figure that out
22:53:26 <lispy> danharaj: I've optimized all the stuff that was obvious to me. Including his quadtree
22:54:18 <lispy> danharaj: but I've found that when I crank up the number of particles into the 100000 range that it starts to spend 50+ % of the time doing GC and most of that is due to building quadtrees
22:54:45 <danharaj> lispy: I'm trying to think of what the cost of a particle crossing a quadrant boundary would be
22:54:51 <danharaj> on average that is.
22:56:36 <danharaj> I think that would be the costliest update that could be done and if you move each particle one by one, you'd do a lot of allocation as you move particles between the coarsest divisions.
22:57:22 <danharaj> then again maybe laziness makes that fine
22:58:42 <lispy> the updates happen by taking all the forces, then applying them (using zipWith) to each body
22:58:58 <lispy> so it's like you say in terms of moving each particel one by one
23:00:15 <danharaj> lisp: are the particles on a discrete coordinate system or floating?
23:00:27 <danharaj> sorry I can't be very useful. kind of shooting in the dark without code :P
23:01:29 <osa1> edwardk: what does `data I` and `data O` represent in this code: https://github.com/ekmett/type-int/blob/master/Data/Type/Binary/Internals.hs#L274
23:01:32 <lispy> danharaj: the coordinates are Floats
23:01:38 <lispy> danharaj: is that what you mean by floating?
23:02:12 <danharaj> lispy: yeah. my other guess was that nasty things occur in densely packed areas. I was going to suggest the leaves be arrays and doing the update there in the ST monad.
23:02:18 <edwardk> osa1: 0's and 1s. T and F represent an infinite tail of 1 or 0 most significant bits
23:03:02 <edwardk> I F   -- would be …0000000000001
23:03:24 <osa1> aha, thanks
23:03:48 <uniquenick> are there any special issues I need to keep in mind when trying to compile c/hsc libraries on windows?
23:04:06 <edwardk> in the hex version of the code they are something like D0 - D9, DA, DB, DC, DD, DE, DF
23:04:15 <lispy> danharaj: ah, interesting
23:04:28 <lispy> uniquenick: yes
23:04:42 <lispy> uniquenick: win32 has stdcall and ccall, win64 has only ccall
23:04:49 <uniquenick> the one I am trying to use appears to compile ok, but the resulting .o has a bunch of unresolved symbols
23:05:01 <danharaj> lispy: Those are the two obvious issues I see coming up as you scale the simulation. Crossing a coarse quadrant boundary is rather exceptional but will happen often with enough particles. Dense areas with region based quadtrees will have exceptionally deep leaves that create the same sort of problem.
23:05:06 <edwardk> TNF ensures that you don't have O F's or I T's  (since they are redundant) normalizing them away
23:05:15 <shachaf> uniquenick: Well, presumably the symbols are unresolved because you need to link it to a library?
23:05:31 <danharaj> lispy: my suggestion is to put buckets at the end and limit the resolution of leaves.
23:06:05 <osa1> edwardk: as an example, can you exmplain me what does that mean: instance TAddC' F F T (I F) ?
23:06:09 <uniquenick> isn't that what cabal build is supposed to do?
23:06:11 <osa1> explain*
23:06:36 <uniquenick> this is the module in question: https://github.com/bluepeppers/haskell-libtcod
23:07:12 <danharaj> uniquenick: isn't libtcod dynamically linked?
23:07:24 <danharaj> this will create issues with symbols.
23:07:30 <edwardk> Sure, TAddC' represents an adder with a carry bit. so the sum of two 'F's "….00000000" and "….00000000" with a carry set to true would be "…000000000001"
23:08:05 <edwardk> TAddC' a b c d, a is the first number, b is the second number, c is the carry bit, and d is the result
23:08:11 <osa1> edwardk: but isn't carry set to true mean a carry like "..11111111" ? or is carry always one bit ?
23:08:37 <uniquenick> yes, it is dynamically linked.  all I appeared to need to do was use cabal install --extra-include-dirs=path/to/libtcod --extra-lib-dirs=path/to/libtcod
23:08:44 <edwardk> carry is always just one bit. its a classic full adder, extended to an infinite number of bits
23:09:01 <edwardk> the T for the carry bit is being used just as a boolean
23:09:04 <uniquenick> cabal seemed happy with the dll and says it builds, registers and installs it
23:09:35 <shachaf> http://media.web.britannica.com/eb-media/21/94821-004-629D4B1A.jpg
23:09:57 <osa1> edwardk: great. thanks.
23:10:00 <lispy> danharaj: that's a good idea. I'll talk to my friend about that change. He didn't want me to make his code too ugly :)
23:10:10 <edwardk> i reporposed T and F to pun it for the infinite tail of 0's and 1's, but it the same T and F i use in the type level booleans. (which is pretty cheesy i admit)
23:10:18 <danharaj> uniquenick: so your problem is that programs you try to compile don't link against the library correctly?
23:10:20 <osa1> :)
23:10:22 <lispy> danharaj: so I've mostly been focused on ways to make his code faster without changing it too much structurally
23:10:26 <edwardk> er repurposed
23:10:32 <danharaj> lispy: there is an antagonism between spatial query and efficient update :P
23:10:50 <edwardk> i don't have much use for reporpoising
23:10:55 <uniquenick> yeah, I am just using runhaskell on the example program, and I get "cabal\libtcod-1.5.1\ghc-7.4.1\HSlibtcod-1.5.1.o: unknown symbol `__imp__TCOD_color_RGB'"
23:11:47 <lispy> danharaj: bah! ;)
23:12:13 <danharaj> uniquenick: have you tried running ghc (I am assuming you are using ghc) directly?
23:12:16 <edwardk> lispy: using a bunch of particles and doing a gravity sim?
23:12:23 <danharaj> I am not sure how runghc interacts with dynamic libraries.
23:12:54 <danharaj> lispy: incidentally spj and others did a thing about nested parallelism and n-body cluster simulations somewhere if your friend wants inspiration. :P
23:13:11 <edwardk> lispy: and if so, does it have to look good, be accurate or is there are trade-off?
23:13:18 <danharaj> I always feel bad that I don't remember papers by the important authors, just the famous ones. :[
23:13:19 <edwardk> er a trade-off
23:14:00 <uniquenick> oh, I guess that is all it is.  runhaskell and ghci get mad, but ghc --make can generate a working .exe
23:14:08 <edwardk> i've probably still got a little galaxy simulator lying around somewhere. its a fun visualization
23:14:11 <danharaj> uniquenick: make sure it runs!
23:14:52 <danharaj> edwardk: do you know of any work done on multi-hole zippers beyond the lone Oleg email from 2011?
23:14:54 <ion> edwardk: Does your simulated galaxy have intelligent life?
23:15:28 <edwardk> ion: none that i've detected so far. ;)
23:15:41 <edwardk> danharaj: you mean the zipperos stuff?
23:16:07 <lispy> edwardk: hey, reading scroll back
23:16:11 <danharaj> edwardk: I have not heard of zippero until now.
23:16:14 <edwardk> danharaj: you can make an 'ordered' 2 hole zipper just by taking a zipper of a zipper
23:16:49 <edwardk> danharaj: http://okmij.org/ftp/papers/zfs-talk.pdf
23:16:56 <danharaj> oh zipperOS
23:16:58 <danharaj> totally different!
23:17:01 <lispy> edwardk: ah, so my friend was implementing barnes-hut (a gravity sim for particles) to refresh his mind. He happened to use gloss so he could visually check the results. Physical accuracy and speed are more important than looking good.
23:18:07 <danharaj> lispy: this paper is totes relevant to them: http://research.microsoft.com/en-us/um/people/simonpj/papers/ndp/fsttcs2008.pdf
23:18:16 <edwardk> fair nuff, and yes, barnes-hut was going to be my first recommendation =)
23:19:08 <edwardk> danharaj: that should be a slightly more productive vein than one oleg email. you can find the zipperos stuff on oleg's website
23:19:10 <lispy> my friend likes haskell, but he keeps saying its too slow for numerical/physics calculations
23:19:16 <lispy> I'm trying to help him write faster code
23:19:29 <lispy> danharaj: thanks for the link
23:19:41 <edwardk> just write haskell dsl's that you can compile to llvm/cuda/opencl. done.
23:20:21 <danharaj> edwardk: thanks. I am investigating a line of thought on handling device input for a gui by expressing callbacks as zippers on the data structure defining the gui that call other zippers with all changes propagating properly.
23:20:56 <danharaj> (also I am looking for an excuse to play with delimited continuations)
23:21:05 <edwardk> fyi- all of this stuff will work with lens-style zippers
23:21:07 * ion remembers the old galaxy xscreensaver thing. Does it use Barnes-Hut?
23:21:12 <edwardk> you don't need delimited continuations
23:22:16 <danharaj> edwardk: I am at a loss on how to get lens-style zippers to propagate changes. It seems like they all have their own copy of the data.
23:22:33 <lispy> ion: I don't know, but we joked about that. It very well may
23:22:48 <edwardk> danharaj: the zipperos stuff is all about saving your location and moving back there to merge/commit transactions
23:23:15 <edwardk> thats the notion of a path i expose as the index for the 'focus' indexed lens
23:23:33 <lispy> danharaj: okay, they use "rosetrees" and the quadtree I have is quite different. The leaves have regions.
23:23:47 <danharaj> edwardk: ah, the idea I was investigating was outlined in this email: http://okmij.org/ftp/Haskell/Zipper2.lhs
23:23:56 <edwardk> save/restore can be used to build the replay stuff
23:24:26 <danharaj> I am interested in the so-called dirty read mode where a zipper propagates its changes immediately to other zippers.
23:24:36 <edwardk> danharaj: this is the zipperos stuff
23:25:14 <edwardk> note the dirty read stuff in oleg's code was quite expensive iirc
23:25:25 <danharaj> mm
23:25:32 <jfischoff> copumpkin, elliot, rwbarton: thanks for the help guys. Its looks like for my issue data families plus type families for the higher stuff is going to working out.
23:26:14 * jfischoff feels like he is starting to get the hang of type level programming
23:26:17 <danharaj> edwardk: well let me ask you. how would you go about architecting a gui library that handles device input and display directly? :P
23:27:52 <edwardk> well, you are talking to a guy who last time he went to write a game engine embedded an entire web server so he wouldn't have to deal with gui elements at all and could just serve up a web page for things like resolution settings, etc.
23:27:53 <edwardk> =P
23:27:54 <ion> Err… Either i’m reading this code incorrectly, or galaxy.c spins each galaxy’s stars about its center and only gravitates each star toward the centers of other galaxies.
23:28:01 <edwardk> so i rather deliberately dodge this issue
23:28:27 <danharaj> edwardk: it seems everyone does! even the frp people who for some reason are obsessed with fruits.
23:28:29 <edwardk> we do have an API for doing gui work here, but it works very differently
23:28:41 <shachaf> edwardk: Oh, is that what you're dealing with Snap for?
23:29:11 <edwardk> shachaf: thats why i started fiddling with it. i still toss code their way from time to time because i like the people there though
23:29:29 * shachaf hasn't looked at any of the Haskell web frameworks very seriously.
23:29:39 <shachaf> Last time I looked I didn't much like any of them.
23:29:44 <shachaf> Maybe the situation has improved.
23:29:48 * ion hasn’t looked at shachaf very seriously.
23:29:59 <shachaf> ion: I recommend not doing so.
23:30:01 <danharaj> edwardk: how does your api work?
23:30:05 <shachaf> You won't like what you'll find.
23:30:53 <edwardk> danharaj: we're able to be entirely declarative since we're mostly setting up gui's for reports, which are basically stateless. you can navigate through options, pull down selectors, click checkboxes, etc. but those select different data, charts, etc. to view
23:31:20 <danharaj> ah hm. and you don't even handle the device input and display for your widgets.
23:31:30 <danharaj> I am trying to build something right on top of opengl.
23:32:10 <danharaj> I suppose I should acquiesce and have an imperative layer to handle that stuff and then try to do something nicer on top.
23:32:11 <edwardk> so the api is specified in such a way that you declare buttons, dropdowns, etc. bind them to the data sources, in that dsl, and then a backend implementation for that dsl is provided for the different backends, pdf, excel, java swing, html, etc.
23:34:09 <danharaj> edwardk: sounds pretty nice
23:34:25 <edwardk> button "go" $ \b -> halign [b, atom "hello"]    -- declaring the button would make the gui element 'b' that you can place. and you can read from dropdowns, etc synchronized on an event, so you can saym, have a bunch of options that all take effect at once.
23:36:50 <ryanos> edwardk: how is that different than visual basic? :)
23:37:08 <edwardk> dropdown (description of the options for the foo dropdown) $ \foo fooData -> halign [ foo, fooData $ \d -> atom d ]
23:38:07 <ryanos> so u r gonna describe the whole gui in code? better not be very busy interface with lots of state..
23:38:10 <edwardk> ryanos: a.) you can implement completely stateless backends for it, so you arent building up massive viewstate, which means you can't build up and leak arbitrary state
23:38:37 <edwardk> ryanos: it works pretty well for our usecases
23:38:49 <ryanos> sounds good
23:38:55 <ryanos> was kind of 1/2 joking
23:38:56 <edwardk> and it can be dynamically generated. its not in haskell
23:39:28 <startling> ryanos: what else would you describe the gui in???
23:39:57 <danharaj> edwardk: when are you guys going to drop the pretense, implement the java vm as a haskell library, and go down to the level of running libHSrts on top of bare metal? ;P
23:40:19 <Nereid> are there supposed to be any laws for mplus, like (a `mplus` b) >> c = (a >> c) `mplus` (b >> c)?
23:40:22 <Nereid> for example.
23:40:23 <ryanos> startling: sometimes ppl prefer to describe the gui in some gui builder and put behind some functions to callback as required
23:40:38 <edwardk> ultimately we can define the gui entirely in code, or i can make some horrible xul/xaml/xml-like "meta" language that isn't fit for human consumption and which is more limited than the source language, in the name of phase separation and team scaling
23:40:54 <startling> edwardk, oh, right, xml guis
23:41:00 <startling> that's still code though!
23:41:25 <edwardk> ryanos: i didn't rule those tools out here. ;)
23:41:40 <ryanos> edwardk: makes sense then
23:41:48 <ryanos> xml gui - bad idea imho
23:42:01 <ryanos> cod gui - bad idea - unless the gui is simple
23:42:07 <Cale> http://www.haskell.org/haskellwiki/MonadPlus
23:42:26 <ryanos> Cale: i'm not at the monad yet :)
23:42:34 <Cale> http://www.haskell.org/haskellwiki/MonadPlus_reform_proposal
23:42:36 <Nereid> Cale: ah. it's not written out in the Control.Monad documentation
23:42:51 <edwardk> but the question that brought this topic up was that danharaj was explicitly looking for how to write a sort of declarative gui api
23:42:55 <Cale> Nereid: yeah, because there's not really any hard rule
23:42:59 <Nereid> heh.
23:43:05 <edwardk> so i don't feel guilty to pointing out a solution in code ;)
23:43:09 <edwardk> er for
23:43:10 <danharaj> :P
23:43:24 <Cale> Nereid: The main thing is that mzero/mplus should give a monoid structure on m t for each type t.
23:43:28 <Nereid> sure.
23:43:44 <ryanos> edwardk: a dsl for gui would be nice to play with
23:43:46 <Nereid> I figured it ought to be like "a monoid object in the category of monads" or something.
23:44:07 <edwardk> maybe we'll get to open source ours some dauy
23:44:17 <ryanos> at this point though not sure what gui really works for haskell
23:44:24 <Nereid> anyway, that's not what I want, then.
23:44:31 <ryanos> looked the other day and wx/etc didn't install properly
23:45:05 <edwardk> ryanos: as i was mentioning, for haskell proper my current 'gui' is embedding 'snap' and pointing a web browser at it ;)
23:45:09 <ryanos> danharaj: what would u use for gui ?
23:45:18 <danharaj> ryanos: that's the question
23:45:46 <Cale> Nereid: Hmm, I wonder what those actually are :)
23:45:48 <edwardk> it does open up some interesting opportunities, like oauth logins, etc.
23:46:09 <danharaj> browsers solve a lot of problems no one wants to deal with
23:46:22 <lispy> I think part of why we don't have a good gui offering for Haskell is that it's still too hard to make good solid platform specific API bindings.
23:46:25 <ryanos> danharaj: if is web based i'd follow edward's path and use some java script for the front end
23:46:29 <Nereid> Cale: well it should be easy to write out exactly what it means once you say what a monad morphism is.
23:46:29 <danharaj> frankly your approach sounds more sensible than doing it the other way around and embedding apps into browsers.
23:46:31 <Rogach> danharaj: And add some other problems.
23:47:23 <Nereid> and it's obvious what a monad morphism should be, too.
23:47:27 <edwardk> Rogach: its not a panacea. i admit
23:47:32 <Cale> Nereid: Yeah, just have to write out all the details and work it out
23:47:32 <edwardk> but its a good stopgap
23:47:34 <Nereid> yeah.
23:47:39 <Saizan> Nereid: what's the monoidal product though?
23:47:50 <danharaj> lispy: yeah, bindings to big libraries are hard. Isn't there a framework for generating C bindings for languages? I remember haskell not being supported.
23:47:53 <ion> I wonder if copilot is a good choice for writing a realtime-ish program intended to run on something like a Beagle Bone that reads some values from GPIO pins and an I²C bus, does some matrix and quaternion math based on the data, does some planning, writes the intended action to GPIO pins, logs all input and actions and sends them to a listener over the network? Getting Haskell to run on a platform like
23:47:55 <ion> that seems like a pain (not to mention if i want to downgrade to something like a TI Stellaris LaunchPad) and i’m not sure if GC in runtime is a good thing either for this.
23:47:57 <Nereid> Saizan: just the regluar product
23:47:59 <Nereid> regular
23:48:41 <lispy> ion: that sounds pretty similar to what copilot is for
23:49:05 <lispy> ion: You could ping lee pike with your question
23:49:23 <ion> lispy: Ok, thanks.
23:54:07 <Cale> hah, here's a cute description of monads: Take the category of Delta natural numbers under their usual ordering as a monoidal category under addition, and consider that monoidal category as a 2-category with one object. Then a monad is a functor Delta -> Cat
23:54:16 <Cale> er, edit fail
23:54:23 <Cale> the category Delta of natural numbers ...
23:55:06 <danharaj> Cale: Isn't that pretty much just monoid object in the category of endofunctors?
23:55:32 <Cale> Kinda...
23:55:52 <danharaj> the 2-category structure is a red herring ;)
23:55:56 <Cale> The image of the unique 0-cell picks out a category
23:56:18 <Cale> and then the rest of the structure specifies the entire simplicial resolution of the monad
23:58:01 <danharaj> Cale: I'm just guessing out from the fact that natural numbers objects are initial
