00:00:12 <sopvop> > _1 %~ getLast $  _1 <>~ Just "!!!"^._last $ _1 %~ Last $ (Just "hello", "world")
00:00:14 <lambdabot>   (Just "!!!","world")
00:00:33 <sopvop> Is there a more clever lensy one-liner to do that?
00:00:53 <johnw> to just exchange "hello" there for "!!!"?
00:01:06 <neutrino> can you write a brainfuck interpreter in lens
00:01:12 <sopvop> nope, to get Last of two Maybes in structure
00:01:12 <johnw> > (Just "hello", "world") ^. _1.folded
00:01:15 <lambdabot>   "hello"
00:01:43 <sopvop> Or rather, modify value in structure to contain lats of what it has, and what I give it
00:01:47 <sopvop> last
00:02:13 <johnw> not quite sure i follow
00:02:28 <johnw> you want to apply a series of setters, and only keep the last setting?
00:02:37 <pordan30> johnw, sopvop: thanks for the links; that appears to be what i'm looking for.
00:03:21 <sopvop> say in data Foo { something :: Maybe a }, and having another maybe a, I want such Foo where something = getLast $ Last old <> Last new
00:04:01 <sopvop> Lens only make the code uglier, but hell why not :)
00:04:08 <fmap> > ala _last foldMap [Just 1, Just 2]
00:04:09 <shachaf> What code?
00:04:09 <lambdabot>   Not in scope: `foldMap'
00:04:10 <lambdabot>  Perhaps you meant one of these:
00:04:10 <lambdabot>    `Data.Foldable....
00:04:27 <fmap> > ala _last Data.Foldable.foldMap [Just 1, Just 2]
00:04:29 <lambdabot>   Just 2
00:04:41 <shachaf> hlep
00:04:49 <shachaf> Oh.
00:04:55 <otters> :t _last
00:04:57 <lambdabot> (Functor f, Isomorphic k) => k (Last a -> f (Last b)) (Maybe a -> f (Maybe b))
00:05:02 <otters> ...what
00:05:14 <sopvop> otters: Lens...
00:05:22 <otters> oh
00:05:23 <otters> haha
00:05:23 <shachaf> sopvop: What are you trying to do?
00:05:28 <shachaf> I don't see two Maybes in that structure.
00:05:33 <sopvop> sopvop: say in data Foo { something :: Maybe a }, and having another maybe a, I want such Foo where something = getLast $ Last old <> Last new
00:05:36 <pordan30> so given "bifunctors are like functors, but over binary type constructors," a bimonad is "like a monad, but over a binary type constructor." so we would have two return operations of types a -> m a b and b -> m a b and bind with signature m a b -> (a -> m c d) -> (b -> m c d) -> m c d, right? with some kind of reasonable generalization of the monad laws. there appear to be papers on this, but they're over my head.
00:06:36 <sopvop> Sort of `foo { something = getLast $ Last (something foo) <> Last new }`
00:07:06 <johnw> shachaf: is there a "between" traversal?
00:07:22 <shachaf> ?
00:07:23 <johnw> something that would let me say [Just 1, Just 2] ^..between mappend?
00:07:33 <shachaf> Which would do what?
00:07:50 <johnw> apply a binary operator between items in a traversal
00:08:04 <sopvop> fold
00:08:04 <johnw> in this case, return [Just 1 <> Just 2]
00:08:06 <shachaf> foldrOf and foldlOf?
00:08:59 <shachaf> If you want it to be properly balanced like the Monoid, it's a bit trickier.
00:09:07 <shachaf> But it's a monoid so it doesn't matter. :-)
00:09:23 <shachaf> johnw: (If what you're doing is actually just mappend, you can just use (^.)/view/foldOf/...)
00:09:23 <johnw> how would I use foldrOf?  my attemtps in ghci are failing
00:09:38 <shachaf> What attempts?
00:09:42 <johnw> > [Just 1, Just 2] ^.. foldrOf mappend mempty
00:09:43 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Accessor
00:09:44 <lambdabot>               ...
00:09:59 <shachaf> You need to give it a traversal/fold.
00:10:03 <johnw> ah
00:10:06 <shachaf> > [Just 1, Just 2] ^.. foldrOf folded (+) 0
00:10:09 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a1]
00:10:09 <lambdabot>                        ...
00:10:22 <shachaf> > [Just 1, Just 2] ^.. foldrOf (folded.folded) (+) 0
00:10:25 <lambdabot>   Could not deduce (GHC.Num.Num
00:10:25 <lambdabot>                      (Control.Lens.Internal.A...
00:10:30 * shachaf sighs.
00:10:34 <sopvop> Num is not a monoid
00:10:46 <shachaf> Who said anything about monoids?
00:10:48 <johnw> > [Just 1, Just 2] ^.. foldrOf folded mappend mempty
00:10:50 <lambdabot>   Couldn't match expected type `[Data.Maybe.Maybe a1]
00:10:51 <lambdabot>                        ...
00:10:54 <shachaf> johnw: That won't work.
00:10:57 <sopvop> I misread
00:11:02 <johnw> why not?
00:11:04 <Cale> Num isn't even the right kind of thing to be a monoid
00:11:05 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:11:34 <sopvop> > [Sum 1, Sum 2] ^.. foldrOf folded mappend mempty
00:11:36 <Cale> lispy: I have no idea
00:11:36 <lambdabot>   Couldn't match expected type `[Data.Monoid.Sum a1]
00:11:37 <lambdabot>                         ...
00:11:45 <shachaf> sopvop: The whole point here was *not* to use a MOnoid instance.
00:11:52 <sopvop> oh
00:11:53 <sopvop> ok
00:11:54 <shachaf> Oh, why were we using (^.) again?
00:12:00 <johnw> i don't know
00:12:03 <shachaf> > foldrOf (folded.folded) (+) 0 [Just 1, Just 2]
00:12:06 <lambdabot>   3
00:12:16 <shachaf> @let nothin' = Nothing
00:12:19 <lambdabot>  Defined.
00:12:20 <shachaf> > foldrOf (folded.folded) (+) 0 [Just 1, Just 2, nothin']
00:12:23 <lambdabot>   3
00:12:32 <johnw> so, if I had (%)...
00:12:39 <shachaf> ?
00:12:48 <johnw> [Just 1, Just 2] % foldrOf folded mappend mempty
00:12:58 <shachaf> Why do you expect that to work?
00:13:06 <johnw> how is that different from
00:13:06 <shachaf> > mappend (Just 1) (Just 2)
00:13:08 <lambdabot>   Ambiguous type variable `a0' in the constraints:
00:13:09 <lambdabot>    (GHC.Num.Num a0)
00:13:09 <lambdabot>      a...
00:13:16 <johnw> oh, never mind
00:13:24 <shachaf> johnw: Also, you don't need to foldrOf mappend mempty
00:13:27 <shachaf> That's just a plain fold.
00:13:35 <shachaf> You can use view/(^.)/foldOf for that.
00:13:37 <johnw> i know, i'm just trying to find something that type checks
00:13:42 <johnw> then i'll move on to simpler forms
00:14:20 <shachaf> rwbarton: Hmm, can toDListOf l just be written as foldrOf l (:) ?
00:14:37 <johnw> can I do a simple <> fold using foldrOf?
00:14:45 <shachaf> Sure.
00:15:05 <shachaf> > foldrOf traverse (<>) mempty ["hello","there"]
00:15:08 <lambdabot>   "hellothere"
00:15:40 <johnw> still not working in my ghci
00:15:42 <johnw> wonder why...
00:15:52 <johnw> "No instance for (Monoid Int) arising from a use of `mappend'"
00:16:39 <shachaf> I don't see any Ints in the snippet I wrote up there.
00:16:44 <shachaf> So you must've introduced the Ints.
00:16:44 <johnw> i'm trying: [Just 1, Just 2] % foldrOf traverse mappend mempty
00:16:51 <shachaf> Why are you expecting that to work?
00:17:13 <shachaf> What are you expecting it to do?
00:17:18 <johnw> i'm expecting [ Just 1 <> Just 2 ]
00:17:30 <johnw> just like yoru hellothere example
00:17:34 <shachaf> Well, it does turn into that, without the []
00:17:38 <shachaf> And maybe with more mempty
00:17:45 <shachaf> What do you expect that to turn into?
00:17:54 <shachaf> I mean, what do you think ghci will print?
00:18:07 <johnw> oh
00:18:47 <johnw> i forget that Monoid (Maybe a) needs a to be a Monoid too
00:18:55 <johnw> so it's Just (1 <> 2), which fails
00:19:10 <shachaf> The great part is that I always ask the exact same questions. :-)
00:19:33 <johnw> well, lens is still difficult enough to figure out that sometimes i don't realize that the error has nothing to do with lens at all
00:20:08 <johnw> > [Just "hello", Just "hello"] % foldrOf traverse (<>) mempty
00:20:10 <lambdabot>   Just "hellohello"
00:20:12 <shachaf> At one point it just clicks, I suppose.
00:20:19 <johnw> i guess, still trying to get there
00:20:48 <johnw> right now I rarely know when it should be ^. or ^.., traverse or folded or folded.folded, when to use folded, etc.
00:20:55 <shachaf> lens didn't make intuitive sense to me until a couple of days after edwardk's talk, when someone asked me some questions about it and I tried to explain it to them.
00:21:10 <shachaf> And then it made sense.
00:21:15 <johnw> i still need to see his talk in Haskell
00:21:19 <johnw> the Scala talk didn't help much
00:21:27 <johnw> so, I'm looking forward to this NYC recording a _lot_
00:22:08 <shachaf> johnw: Recently I answered http://stackoverflow.com/questions/13434568/how-do-i-handle-the-maybe-result-of-at-in-control-lens-indexed-without-a-monoid/13436546#13436546
00:22:21 <shachaf> Do you have everything written in that "heuristic" clearly in your mind?
00:22:52 <shachaf> I should expand on that post sometime.
00:23:15 <johnw> ah, so *that* is the difference between folded and traverse
00:24:04 <shachaf> Yes.
00:24:10 <shachaf> A Getter is really like a function.
00:24:13 <shachaf> Getter s a ~~ s -> a
00:24:22 <johnw> i'm copying this into my lens notes
00:24:23 <shachaf> Fold s a ~~ s -> [a]
00:25:01 <shachaf> (Except slightly different because of Monoid reasons. But pretty much equivalent.)
00:25:29 <johnw> i didn't get the difference between Getter and Setter either
00:25:34 <shachaf> Lens s a ~~ s -> (a, a -> s)
00:26:03 <shachaf> Setter s a ~ s -> ((a -> a) -> s)
00:26:03 <johnw> yeah, Lens is Store, we went through that in depth
00:26:12 <shachaf> Or just Setter s a ~ (a -> a) -> s -> s
00:26:30 <shachaf> Traversal s a ~~ s -> ([a], [a] -> s)
00:26:39 * shachaf waves hands about.
00:26:47 <johnw> Setter is just function application, from that signature
00:26:58 <johnw> except the difference between s and a
00:27:07 <johnw> haha
00:27:16 <johnw> how did you get to know lens so well that you're working on it now?
00:27:36 <shachaf> Well, you might have Setter [Int] Int ~~ (Int -> Int) -> [Int] -> [Int]
00:27:42 <shachaf> I don't know it all that well.
00:27:54 <shachaf> Though going through the code and renaming every single type helped a bit. :-)
00:28:38 <randomclown> :source div
00:28:50 <randomclown> :src div
00:30:25 <randomclown> how different is div and quot?
00:31:43 <opqdonut> they differ on negative inputs IIRC
00:31:50 <johnw> it's described here: http://localhost:8687/file//usr/local/share/doc/ghc/html/libraries/base-4.6.0.0/Prelude.html#v:div
00:31:53 <johnw> oops
00:32:00 <johnw> in the docs on div and quot, I mean
00:32:14 <shachaf> johnw: That's digusting.
00:32:23 <shachaf> I just clicked on that link and I can't believe you would link to a page like that.
00:32:24 <opqdonut> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:quot
00:32:30 <opqdonut> (nicer link)
00:33:00 <johnw> NSFW!
00:34:53 <randomclown> is it possible to make a [1..n] descending?
00:35:06 <johnw> [n,n-1..1]?
00:35:07 <sopvop> http://i.qkme.me/3rv95m.jpg
00:35:16 <zomg> sopvop: lol :D
00:35:26 <randomclown> too ugly when n isnt nice
00:35:32 <mauke> let
00:37:55 <hpaste> clown pasted “christmas tree” at http://hpaste.org/77998
00:38:15 <randomclown> Is there a more elegant way to write this christmas tree (20 lines)
00:38:35 <johnw> yeah, just putStr the christmas tree :)
00:40:28 <randomclown> seems kinda inefficent concating all the text\
00:41:44 <johnw> you can do string continuations in Haskell, you know
00:41:47 <johnw> \
00:41:56 <johnw> This is a\
00:41:58 <johnw> \example\
00:41:59 <johnw> \of one
00:42:19 <randomclown> hahaha
00:53:54 <Ghoul> Does haskell have -Ofast ?
00:54:00 <Ghoul> *GHC
00:54:23 <opqdonut> well it has -O and -O2
00:54:28 <opqdonut> what's -Ofast?
00:54:44 <Ghoul> in gcc its all optimization options
00:55:01 <johnw> including lto?
00:55:06 <opqdonut> right, it enables target specific optimizations
00:55:08 <johnw> clang calls that -O4
00:55:12 <opqdonut> ( http://gcc.gnu.org/ml/gcc/2010-05/msg00099.html )
00:55:19 <opqdonut> we don't have target-specific optimizations in ghc
00:55:24 <opqdonut> so -O2 is everything
00:55:38 <johnw> ghc doesn't do stuff like SIMD on Intel?
00:55:42 <Ghoul> isnt there fast maths though?
00:55:51 <Ghoul> I saw a stack overflow thread about it
00:55:58 <sopvop> >  (Just "hello", "world") &  _1 %~ over _last (<>(Just "foo")^._last)
00:56:00 <lambdabot>   (Just "foo","world")
00:56:07 <sopvop> yay!
00:56:20 <Ghoul> what the hell
00:56:29 <sopvop> nvm
00:56:36 <Ghoul> that syntax destroys my brain
00:56:36 <opqdonut> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/flag-reference.html
00:57:01 <opqdonut> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/options-optimise.html
00:57:16 <johnw> yeah, that one is particularly awful I have to say
00:57:20 <arbn> sopvop: What library are those operators from?
00:57:23 <opqdonut> '-O2: Means: “Apply every non-dangerous optimisation, even if it means significantly longer compile times.” The avoided “dangerous” optimisations are those that can make runtime or space worse if you're unlucky. They are normally turned on or off individually.'
00:57:26 <sopvop> lens
00:57:26 <johnw> arbn: lens
00:57:30 <arbn> Ah. OK.
00:57:42 <johnw> but don't let that example turn you off
00:57:48 <sopvop> I'll repeat myself: http://i.qkme.me/3rv95m.jpg
00:57:57 <johnw> lens code like that is a lot worse than not using lens imho
00:58:07 <sopvop> johnw: Agree :)
00:58:23 <arbn> I should have guess it was lens stuff. That's quite trendy lately.
00:58:54 <Ghoul> opqdonut: I think theres more than that
00:58:57 <Ghoul> moment
00:58:59 <johnw> yeah, it lets you express some stuff really nicely that's hard to without it
01:00:01 <Ghoul> http://www.haskell.org/haskellwiki/Performance/GHC#Crank_up_the_gcc_flags
01:00:12 <Ghoul> -O2 -fexcess-precision -optc-O3 -optc-ffast-math -no-recomp ..?
01:00:23 <arbn> I'm thrilled for edwardk's talk next month. As soon as I attend that, I'll probably be as enamored of lenses as everyone else.
01:01:02 <johnw> so does that mean you can just do -optc-Ofast?
01:01:34 <Ghoul> No idea
01:01:41 <Ghoul> Not sure if -optc even uses llvm
01:01:45 <Ghoul> or w/e
01:02:05 <johnw> you need -fllvm to use LLVM
01:02:33 <johnw> also, i thought GHC didn't use gcc anymore
01:02:54 <shachaf> No, it generates native code.
01:02:58 <shachaf> Or llvm with -fllvm
01:02:58 <Ghoul> isnt llvm default
01:03:00 <shachaf> No.
01:03:05 <johnw> llvm isn't default
01:03:17 <Ghoul> Wait, so theoretically should get faster speeds them
01:03:17 <johnw> it's not better in a quite few cases still
01:03:18 <Ghoul> *then
01:03:27 <Ghoul> if we pass through llvm
01:03:28 <Ghoul> oh ok
01:03:33 <johnw> llvm doesn't understand the memory model as well as GHC itself does
01:04:32 <johnw> based on the talk I listened to, in the future LLVM would be used for target generation, like a much better assembly language, but many of the optimizations will still be done by GHC because it understands the problem domain so well
01:07:31 <arbn> johnw: By the time C-- is generated, I thought all GHC optimizations were already finished?
01:07:55 <johnw> C--?
01:08:12 <merijn> johnw: Well, a better way to put is that LLVM can only do micro level ASM optimisation whereas GHC can do macro level whole program elimination
01:08:26 <merijn> eh, s/elimination/optimisation
01:08:27 <johnw> llvm can do whole program optimization
01:08:54 <merijn> johnw: Not on the same scale, determining shared expressions is rather hard, whereas for GHC elimnating common subexpressions is much easier
01:08:58 <hpaste> sopvop pasted “can lens magically impove that monoid instance code?” at http://hpaste.org/78002
01:09:02 <dobblego> @hoogle Monad m => (a -> m b) -> m a -> m a
01:09:03 <lambdabot> Prelude (=<<) :: Monad m => (a -> m b) -> m a -> m b
01:09:04 <lambdabot> Control.Monad (=<<) :: Monad m => (a -> m b) -> m a -> m b
01:09:04 <lambdabot> Prelude (>>=) :: Monad m => m a -> (a -> m b) -> m b
01:09:27 <arbn> johnw: http://www.aosabook.org/images/ghc/hscpipe2.png <-- My understanding is that GHC works roughly like that still?
01:10:30 <johnw> that was my understanding too
01:11:10 <arbn> So, C-- is basically a portable assembly language. I can't imagine what kind of optimizations GHC could still do, after generating that.
01:13:16 <johnw> merijn: http://news.ycombinator.com/item?id=2373800
01:13:17 <arbn> I should read up on GHC, though, to find out!
01:13:24 <johnw> rather relevant in its comments about CSE
01:13:54 <johnw> as well his conclusion: "In short, the criticism isn't so much that LLVM has an impedance mismatch with dynamic languages as it is that it only handles the bottom of the optimization stack. You still need to do the high-level language-specific optimizations before handing things to LLVM."
01:14:00 <johnw> which I think applies here very much as well
01:14:56 <merijn> johnw: Isn't that exactly what I just said? That LLVM's value is for it's micro optimisations, whereas GHC is there for macro optimisation?
01:15:06 <johnw> but that said, llvm's whole program optimization (aka, lto), could achieve some inlining gains without needing to explicitly annotate in GHC
01:15:15 <johnw> merijn: yeah, i was backing you up :)
01:15:22 <merijn> It says it has "some support" for CSE, but clearly GHC will be much better at it, as LLVM's model is much less restricted
01:15:31 <johnw> certainly
01:15:59 <merijn> I think LLVM's constant folding is much more promising (optimisation wise) than CSE
01:16:01 <johnw> even in clang they do a lot of domain-specific optimizations that LLVM couldn't do by itself
01:16:24 <merijn> (for Haskell)
01:16:26 <sopvop> I know a project using LLVM, without high level optimisation the executable in 10 times bigger and 3 times slower. And it's a c-like language.
01:17:16 * hackagebot phybin 0.1.2.4 - Utility for binning phylogenetic trees in Newick format.  http://hackage.haskell.org/package/phybin-0.1.2.4 (RyanNewton)
01:52:17 * hackagebot regex-pcre-builtin 0.94.4.3.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.3.8.31 (AudreyTang)
01:52:55 <bitonic> whoa.  that's some intense version numbering
01:54:13 <luite> 8.31 is the libpcre version
01:54:47 * sopvop never uses regexps in haskell, for some reason
01:55:16 <sopvop> I guess the reason is parsec and attoparsec
01:55:39 <shachaf> Does someone have a recent HEAD to try a program in?
02:06:36 <hamid> this doesn't work as pattern matching in haskell right? => test (n+1) = n
02:06:59 <quicksilver> it did in haskell 98
02:07:15 <hamid> at least i can see ghci doesn't load it :/
02:07:16 <quicksilver> but it was widely considered to be immoral, and it was one of the very few things removed from the language after the definition.
02:07:40 <quicksilver> GHC still understands it and will support it if you turn on the language flag
02:07:44 <bitonic> quicksilver: "one of the few"?  I'd say it's the only removed thing
02:08:06 <hamid> quicksilver, thanks, got it
02:08:31 <merijn> bitonic: MonadComprehensions (although they got put back in later, I think)
02:08:36 <key> re
02:08:42 <key> greetings and salutations, fellow geniuses
02:08:47 <bitonic> merijn: that was never in Haskell
02:08:58 <key> i've made a binary-encoded network protocol. it piggy backs the standard pattern of tlv, type length value. there are several camps regarding the enumeration of type. some believe bool is the type, and true/false are its possible binary values. others like json have true and false as first class values. comments please
02:09:40 <quicksilver> bitonic: it was, just not in haskell 98.
02:09:51 <socket> Hello folks, TestOdd = {P | P is a Scheme program, and P(x) = "T" iff x is odd}; any idea if this is deciable or not? and how to prove it? im flying in the dark here...
02:09:53 <quicksilver> bitonic: it was in haskell 1x for x in 0..4 somehwere
02:10:08 <bitonic> quicksilver: oh, that's interesting.  I was just considering the two reports
02:10:09 <shachaf> 1.4 had it
02:10:20 <shachaf> Along with MonadZero and map = fmap and a bunch of other goodies
02:10:28 <merijn> socket: I don't think it is
02:10:48 <hamid> Am I right? there are 2 standard papers for haskell. 98 and 2010?
02:11:23 <bitonic> hamid: yes but there were other documents for earlier versions
02:11:33 <socket> merijn: why?
02:11:35 <merijn> socket: I guess it depends on the type of x and whether it's size is bounded?
02:11:46 <bitonic> 98 was already 8 years in the history of Haskell
02:12:06 <hamid> bitonic, is 2010 already all implemented in ghc?
02:12:06 <merijn> s/it's/its
02:12:09 <merijn> I hate English
02:12:15 <merijn> hamid: GHC does more than 2010
02:12:16 <shachaf> GHC doesn't quite implement 2010
02:12:19 <shachaf> But older versions did
02:12:29 <hamid> why not?
02:12:30 <merijn> hamid: And there are some minor differences, I think?
02:12:45 <merijn> For instance, I think GHC still doesn't directly support mutually dependent modules
02:12:55 <bitonic> merijn: it does in a restricted form
02:12:56 <socket> merijn: the size is not bounded
02:13:14 <bitonic> also GHC `base' is incompatible with haskell2010
02:13:34 <hamid> hmm what's the most compatible one(compiler)?
02:14:01 <bitonic> hamid: there is no single compiler that fully implements haskell2010, I think.
02:14:12 <merijn> socket: Then I don't think it's decidable programmatically? Imagine the program that loops infinitely for "x == 7", then what?
02:14:21 <nob> socket, doesn't it include the halting problem?
02:14:47 <merijn> hamid: GHC implements all the bits anyone cares about, I'd say
02:15:04 <merijn> hamid: Do you have any specific worries?
02:15:14 <socket> merijn: i agree
02:15:16 <bitonic> merijn: I'd like to have mutually recursive modules
02:15:25 <merijn> bitonic: Word.
02:15:29 <socket> nob: proving it using the halting problem would be great, not sure how though :)
02:15:37 <hamid> merijn, nope but it's not cool just to say i do care about this one then i implement it :P
02:15:43 <merijn> bitonic: Preferably without boot-hs files
02:16:02 <bitonic> merijn: yes, that's what I meant
02:16:23 <merijn> hamid: I've never personally encountered a part of 2010 that didn't work, but I haven't read the entire 2010 report, so
02:16:51 <hamid> while using haskell in production this acutally matter so much. and otherwise i may be wrong.
02:17:06 <hamid> s/and/or/
02:17:20 <merijn> hamid: In practice GHC is pretty much the only compiler the majority of haskellers care about, as a large amount code only works with GHC anyway (using GHC extensions, for one)
02:17:36 <bitonic> I think the biggest difference between GHC and haskell2010 is that in GHC Num a does not imply Eq a, Show a
02:18:23 <merijn> hamid: I wouldn't worry about it from a production code perspective. I think it's very unlikely to be a problem
02:18:43 <bitonic> hamid: I'd worry more about not restricting your code to GHC, last version
02:18:58 <bitonic> that is annoying, keep it compatible with the Haskell platform at least
02:19:04 <hamid> bitonic, yeah that's the point
02:19:21 <bitonic> is it?  I thought you wanted to comply to some standard
02:19:55 <hamid> bitonic, it seems for haskellers ghc is the standard!
02:20:32 <merijn> hamid: The haskell report is a report, i.e. it's more a description of "what is" than "what should be"
02:21:25 <merijn> hamid: I think you're worrying about things unnecessarily
02:21:49 <fmap> bitonic: what's so annoying about not being compatible with HP?
02:22:41 <socket> nob: can i PM you?
02:22:48 <nob> sure
02:23:58 <hamid> merijn, you are right. i'm just afraid of relying on something that may changes in close or even far future.
02:24:41 <hamid> merijn, maybe that
02:24:53 <hamid> 's just because i'm c++ programmer
02:26:40 <b__> is there an FPR package aimed at finance, or should I be looking for something more general?
02:28:13 <merijn> hamid: The bits that are not standard are really obscure cornercases (like bitonic points out, the standard says the Num typeclass should require Eq and Show, which GHC does not enforce)
02:28:55 <merijn> hamid: They shouldn't have any drastic effect on which code is correct and which isn't
02:30:15 <merijn> hamid: Changes that remove features (n+k patterns, for example) usually include a flag that reenables the behaviour
03:18:56 <earthy> having Num require Eq and Show makes it harder to do interesting things like automatic differentiation
03:19:33 <shachaf> earthy: That's why Num doesn't require Show and Eq anymore.
03:19:39 * earthy nods
03:19:49 <earthy> there's really good reasons, I was pointing out. :)
03:19:49 <shachaf> Oh, was that in response to something?
03:20:00 * shachaf 's screen was full of empty.
03:20:29 <Cale> He was replying to the previous bit of discussion, but there were lots of joins and parts in the way
03:20:43 <shachaf> Yes.
03:20:50 * shachaf is annoyed at this GHC bug.
03:20:58 <Cale> bug?
03:21:05 <shachaf> Looks like two separate GHC bugs, though maybe one of them is arguably not a bug? Well.
03:21:17 <shachaf> Cale: data List a = Nil | Cons a (List a) deriving (Functor, Foldable)
03:21:40 <shachaf> last $ Foldable.toList (replicate n ())
03:21:53 <shachaf> Takes n^2 time
03:22:03 <Cale> hmm
03:22:23 <shachaf> The derived Foldable instance looks something like this:
03:22:27 <shachaf> foldr f z (Cons x xs) = f x (foldr (\e -> f e) z xs)
03:22:29 <Cale> Deriving Foldable is interesting
03:22:36 <shachaf> Replacing it with "foldr f z (Cons x xs) = f x (foldr f z xs)" fixes it.
03:22:44 <Cale> I didn't even know that existed.
03:23:07 <shachaf> So somehow the function "foo f z Nil = z; foo f z (Cons x xs) = f x (foo (\e -> f e) z xs)" takes n^2 time too.
03:23:19 <shachaf> Is it getting eta-expanded at each iteration or something horrible like that?
03:25:02 <shachaf> Also, why does deriving Foldable use foldr rather than foldMap?
03:25:07 <shachaf> foldr loses information. :-(
03:36:14 <Saizan> i thought ghc would eta-contract something like that
03:36:24 <byorgey> shachaf: eh? aren't foldr and foldMap equivalent?
03:37:00 <shachaf> byorgey: After they're done reducing, sure, if your monoid is associative.
03:37:26 <byorgey> right.
03:37:27 <shachaf> But foldr will force your reductions to be right-biased.
03:37:42 <byorgey> good point.
03:37:54 <shachaf> If you have foldMap for a binary tree, you can find the leftmost or rightmost leaves in log(n) steps with First/Last
03:38:10 <shachaf> Whereas with foldr you have to traverse the whole thing.
03:38:13 <byorgey> ohhhh
03:38:25 <byorgey> that's an excellent point, I hadn't thought of that
03:38:44 <shachaf> If you have foldMap, you can always make foldr from it DList-style
03:38:46 <shachaf> But you can't go back.
03:38:48 <byorgey> I am also quite surprised that  deriving Foldable  uses foldr.  I would have thought deriving a foldMap implementation would be easier.
03:39:13 <shachaf> byorgey: Particularly given that the Traversal deriving code, right next to it, more or less *has* to do it foldMap-style
03:39:25 <byorgey> right
03:39:38 <donri> file a bug?
03:39:43 <shachaf> Working on it.
03:39:47 <donri> cool
03:39:49 <byorgey> "you can't go back" -- you mean you can't go back to a foldMap with the same *operational* behavior?
03:40:00 <byorgey> surely you can implement foldMap in terms of foldr, at least semantically speaking.
03:40:15 <byorgey> s/semantically/denotationally/
03:40:18 <shachaf> Sure, but I mean operationally.
03:40:21 <shachaf> Well, semi-operationally.
03:40:22 <byorgey> right.
03:40:26 <shachaf> You can observe it with an invalid Monoid instance. :-)
03:40:35 <byorgey> cheater!
03:40:43 <shachaf> foldr loses structure in the same way that Monoid loses structure.
03:40:56 <donri> are derived Foldable and Traversable always "right"? i.e. any instance that is different would break laws or something
03:40:59 <shachaf> But I'd prefer to have the parentheses evenly distributed.
03:41:07 <shachaf> donri: No, there are lots of possible instances.
03:41:14 <robbe-> Does anyone use haskell-mode with emacs with the cabal-dev configuration? I can't seem to get it working, the haskell-process-log buffer tells me that somewhere cabal-dev is unable to find ghc. I didn't encounter this problem outside of emacs btw.
03:41:15 <shachaf> n!, in fact
03:41:20 <donri> aha
03:41:28 <donri> but not for Functor though IIRC?
03:41:31 <shachaf> Right.
03:41:43 <Jafet> fmap id = id
03:42:01 <shachaf> Well, no, there are two possible instances, maybe.
03:42:06 <shachaf> fmap f x = ... and fmap !f x = ...
03:42:11 <byorgey> donri: in some sense though, there aren't any "interesting" differences among the different choices for Foldable/Traversable
03:42:23 <byorgey> donri: the only difference is ordering.
03:42:25 <Jafet> @slap shachaf's bottom
03:42:26 <lambdabot> why on earth would I slap shachaf's bottom?
03:42:50 <shachaf> byorgey: A nicer Monoid instance also lets you do other things, like parallelization.
03:42:52 <byorgey> donri: Applicative and Monad, on the other hand, can mave multiple nontrivially different instances, which is why GHC won't derive those
03:42:59 <luite> robbe-: perhaps a PATH problem, are you using some graphical emacs on OS X?
03:43:03 <donri> byorgey: obviously :)
03:44:43 <robbe-> luite: Thanks for your reply; I did check the exec-path (spelling?) and the environmental PATH (get-env "PATH"), which both include /usr/bin/, where GHC resides.
03:45:41 <robbe-> http://paste.debian.net/211214/
03:46:14 <luite> robbe-: you do need the cabal bin directory in your path as well
03:46:19 <luite> (where fake-ghc-cabal-dev is)
03:46:51 <robbe-> luite: That should also be okay, as I add that directory in my .emacs. Let me check with the code you just pasted.
03:47:34 <robbe-> haha lol - I'm too lispy thinking - that was not a function but a note
03:47:36 <luite> probably need to do setenv there,  not just exec-path
03:47:37 <robbe-> silly /me
03:48:11 <robbe-> http://paste.debian.net/211215/
03:48:29 <robbe-> Those are the lines modifying the paths to add the cabal bin directory.
03:49:13 <luite> hm yeah i have similar lines, which did the trick for me :)
03:49:39 <luite> does it expand ~/ properly?
03:50:17 <robbe-> How do I check that best? Or do I just change it to an absolute path to test.
03:51:33 <robbe-> luite: <3 I owe you a virtual beer.
03:51:47 <luite> np
03:52:13 <robbe-> You are in France, if you come to Brussels I can give you one in RL. :P
03:52:22 <robbe-> if*
03:52:38 <robbe-> (you are using a .fr based freenode server)
03:52:44 <luite> I'm in the netherlands
03:53:16 <robbe-> Then we even speak the same language. Bedankt! :-)
03:53:44 <luite> geen probleem
03:53:52 <luite> ik bedoel, graag gedaan
03:54:14 <luite> that was an anglicism :p
03:54:30 <shachaf> dolio bedoel
03:54:40 <robbe-> Hey, that's how Dutch rolls on the internet. :-)
03:55:48 <robbe-> Hm, I still would like to have the ~ expanded, it's more convenient when switching computers where I might not have the same homedir - but that's an emacs matter entirely I suppose.
04:05:35 <Saizan> robbe-: you can (getenv "HOME")
04:07:21 * hackagebot http-conduit 1.8.4.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.4.1 (MichaelSnoyman)
04:07:23 * hackagebot http-conduit-browser 1.7.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.7.1 (MikhailKuddah)
04:25:05 <yitz> if lens indeed defines 99 operators, it should get a special mention on http://www.99-bottles-of-beer.net/
04:25:54 <shachaf> http://hackage.haskell.org/trac/ghc/ticket/7436
04:36:41 <robbe-> Saizan: Thank you for the tip. Will apply it later today. :-)
04:42:23 * hackagebot http-conduit-browser 1.7.1.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.7.1.1 (MikhailKuddah)
04:43:35 <donri> only 99?
04:44:58 <hayashi> can anyone recommend me a decent framework for setting up restful http/s apis in haskell?
04:45:22 <hayashi> i assume a framework like yesod would be far too cracking-nut-with-sledgehammer
04:45:33 <sopvop> yseod, snap, happstack
04:46:06 <alpounet> hayashi, it's not that complicated really, and there are very good resources for learning about the 3 frameworks mentionned by sopvop
04:46:07 * sopvop uses snap for restful http api with json
04:47:20 <hayashi> mhm
04:48:15 <hayashi> so the general opinion here is that it wouldn't be overkill to use a haskell framework for a restful json/etc http api
04:49:15 <alpounet> hayashi, i really can speak mostly for happstack, it's the only one i've used seriously, but it's very simple and you're not forced to bring the whole framework
04:49:18 <alpounet> just the parts you need
04:49:20 <sopvop> Just don't use parts which you don't need. All of these are modular.
04:49:45 <sopvop> :)
04:50:24 <hayashi> oki
04:50:49 * sopvop would chose either snap or happstack
04:51:11 <sopvop> I mean, for new project
04:51:23 <donri> or plain warp, but i think that's underkill
05:03:51 <m_fulder> hey! If I have a list (say [13,14,15] ) how can I add 7 and mod each element by 12 ?
05:04:13 <neutrino> map foo yourlist
05:04:44 <shachaf> map (\x -> (x + 7) `mod` 12) [13,14,15]?
05:04:46 <sopvop> > map (\x -> x +7 `mod` 4) [13,14,15]
05:04:48 <lambdabot>   [16,17,18]
05:04:51 <neutrino> where foo x = mod (x + 7) 12
05:04:55 <m_fulder> aah ok!
05:04:58 <NoICE>  map (+7 `mod` 12) [1,2,3]
05:04:59 <neutrino> sopvop: yeah
05:05:02 <m_fulder> thanks! :åp
05:05:08 <neutrino> m_fulder: yw
05:05:12 <NoICE> > map (+7 `mod` 12) [13,14,15]
05:05:14 <lambdabot>   [20,21,22]
05:05:41 <NoICE> heh, my bad
05:05:52 <Botje> m_fulder: haskell has lots of these 'lifting' operators, where you take a simple function and lift it onto a given (combination of) data structure(s)
05:05:53 <neutrino> no ide?
05:05:55 <neutrino> no ice?
05:06:01 <neutrino> what will i drink my pina colada with?
05:06:01 * hayashi got map ((`mod` 12) . (+7)) [13, 14, 15]
05:06:22 <NoICE> yep?
05:06:28 <Botje> neutrino: wrong channel.
05:06:55 <neutrino> Botje: sorry i thought this was the drinks and beverages channel, i'll direct further questions there
05:07:00 <NoICE> neutrino: what you will drink your whiskey with?
05:07:00 <NoICE> no ice.
05:07:07 <Botje> neutrino: but the correct answer is "chilled soapstone".
05:07:46 <neutrino> Botje: ah, ok.
05:07:50 <neutrino> that makes sense i guess.
05:12:24 * hackagebot http-conduit-browser 1.7.1.2 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.7.1.2 (MikhailKuddah)
05:12:59 <ziarkaen> Will reverse = foldl (flip (:)) [] operate in linear time?
05:13:41 <Botje> yes
05:14:21 <ziarkaen> Botje, Good, I though so.  Thanks.
05:21:49 <madjestic> Reactive Banana, Yampa or Elerea?
05:23:09 <parcs`> yes!
05:27:25 * hackagebot test-framework-golden 1.1.1 - Golden tests support for test-framework  http://hackage.haskell.org/package/test-framework-golden-1.1.1 (RomanCheplyaka)
06:09:11 <AfC> Stupid question, not trolling: are lenses mathematically founded?
06:09:33 <AfC> [in the same way that Monads are]
06:10:25 <merijn> AfC: They don't really have an existing mathematical meaning, I think. But you can (and in fact edwardk *does*) define laws for them
06:10:31 <fmap> AfC: http://r6research.livejournal.com/23705.html http://patternsinfp.wordpress.com/2011/01/31/lenses-are-the-coalgebras-for-the-costate-comonad/
06:11:17 <fmap> (not if I understand anything from there)
06:11:40 <beaky> hello
06:12:03 <nand`> AfC: what *isn't* mathematically founded?
06:12:27 <nand`> there are numerous ways to define lenses in certain mathematical contexts; and I'm not just talking about Haskell
06:12:41 <nand`> for example, they can also be seen as natural transformations between state monads
06:13:04 <nand`> they also have certain laws, which enable you to reason about them
06:14:11 <beaky> what is a lens?
06:17:24 <Peaker> beaky, I see it as an "accessor" (allowing read/write) of something small inside something large
06:17:48 <beaky> ah
06:17:56 <beaky> so its like a getter and setter
06:17:56 <Peaker> beaky, though it can probably be more general than that (that's my use of them)
06:18:13 <beaky> i love FP
06:18:20 <merijn> A *composable* getter and setter
06:18:23 <Cale> So you can start out with a data type like:
06:18:39 <Cale> data Lens a b = L { view :: a -> b, set :: b -> a -> a }
06:18:57 <Peaker> s/a/big, s/b/small ?
06:19:10 <Cale> if you like
06:19:25 <Cale> I tend not to use type variables longer than one letter
06:19:51 <nand`> I don't think ‘big’ or ‘small’ are good names independent of the length
06:19:52 <Peaker> These kinds of lens though are problematic because they don't work well with an update that changes the type
06:20:13 <Peaker> nand`, they may not capture the full generality, but they help remember which is which
06:20:30 <nand`> that is true
06:20:32 <Cale> Yeah -- often that doesn't matter, but that was one of the motivating factors behind the generalisation of the type.
06:20:35 <nand`> ‘Lens s t a b’ :)
06:21:06 <Cale> type Lens s t a b = forall f. Functor f => (a -> f b) -> s -> f t
06:21:51 <quicksilver> data Lens painting detail
06:22:06 <typoclass> nand`: i think there's nothing wrong with having a function "findTheString small big = ..." even if sometimes the 'big' string is shorter than the other ...
06:22:42 <nand`> ‘find needle haystack’ :)
06:24:53 <Cale> With this generalised type, we have view :: Lens s t a b -> s -> a  which means we still have encoded here some way to get a value of type a out of a structure of type s, and we have  set :: Lens s t a b -> b -> s -> t, meaning that we can replace that field with a value of type b in a structure of type s, in order to get a new structure of type t
06:26:20 <Cale> beaky: The way we extract those is by choosing either the constant functor at the type a in the case of view, or the identity functor, in the case of set
06:27:34 <Cale> This representation also has the advantage that where before we would have had to do some fiddly manipulation to define composition of lenses, the composition comes for free as the composition of functions.
06:28:07 <Cale> (In addition to the ability to change the field types)
06:28:14 <beaky> so the types will come out very cleanly
06:28:26 <Cale> There's also   type Simple f s a = f s s a a
06:28:32 <Peaker> Cale, the generalized/Functor type has lots of advantages -- but to generalize the old/simple Lens, all you need to do is:
06:28:41 <Cale> So that you can use  Simple Lens Employee String for example
06:28:54 <Cale> for the name field of some Employee record
06:28:58 <Peaker> data Lens s t a b = Lens { get :: s -> a ; set :: b -> s -> t }
06:29:09 <nand`> of course, the best thing about this representation is that you can mix and match it with other lenslikes
06:31:06 <Philippa_> Is there a quick "I think I grok the basics, which packages etc should I be grabbing?" post somewhere, OOI?
06:31:18 <Philippa_> I seem to be getting too old and cranky to do my research properly
06:31:31 <Cale> Philippa: For lenses?
06:31:34 <Philippa> yeah
06:31:51 <shachaf> Philippa: The package you want is "lens"
06:31:52 <Cale> The main package you want is called 'lens'
06:31:59 <Cale> http://hackage.haskell.org/package/lens-3.3
06:32:00 <shachaf> https://github.com/ekmett/lens has some documentation
06:32:12 <Cale> and there's a wiki and such linked from the hackage page
06:32:20 <shachaf> The interesting part of the package actually isn't Lens but Traversal.
06:32:41 <Philippa> *nod*
06:34:23 <shachaf> So foldr f z (x:xs) = f x (foldr (\e -> f e) z xs) gives you n^2 behavior
06:34:29 <Philippa> y'know, I'm starting to wonder if we need a "catch-up for old farts" doc/list somewhere
06:34:33 <shachaf> "thx eta-expansion :'("
06:35:12 <NoICE> guys, pls, how can I read from socket (via Network.Socket) until certain character?
06:35:13 <Philippa> put all the stuff that's becoming de facto standard in it, so people can skim it for "has someone found an answer for $problem yet?" and the like
06:35:39 <NoICE> (like hGetLine but for different char)
06:35:55 <Cale> hGetChar will get one character at a time
06:36:01 <merijn> Cale: @check is broken :(
06:36:07 <Cale> merijn: I'm aware
06:36:09 <typoclass> Philippa: you mean "catch-up" documentation in general or for lens?
06:36:13 <merijn> Crap
06:36:14 <Philippa> in general
06:36:21 <merijn> Then I need to go install quickcheck...
06:36:35 <Philippa> lens'd be an obvious thing to put on it, but if I'm honest I only just about know where to start finding out what I'm supposed to do for IO these days
06:36:50 <shachaf> lens is only a few months old, by the way.
06:36:59 <shachaf> Philippa: No one knows about the IO thing. :-(
06:37:05 <shachaf> There's always hGetContents
06:37:08 <Philippa> *nod*. It's clearly a Right Thing though, and spreading as such
06:37:09 <Philippa> hah, yes
06:37:26 <typoclass> Philippa: very true. it'd be great to have a commented list of popular packages
06:37:29 <Philippa> but an overview of the current options is still good
06:37:35 <shachaf> People are fighting it out with iteratees/enumeratees/pipes/conduits/machines/boxes/tubes/trucks/etc.
06:37:38 <shachaf> I don't even know.
06:37:42 <Cale> Philippa: I'm still slightly opposed to all the iteratee stuff (conduits/pipes/etc.)
06:37:43 * shachaf will just lie low until it blows over.
06:37:56 <shachaf> ==Cale, more or less.
06:37:59 <atriq> I tend to use whichever I'm being forced to use
06:38:03 <atriq> At the moment, conduits
06:38:05 <Philippa> Cale: yeah, it feels subtly icky to me but in a way that makes me wonder if we're hitting a limit of Haskell?
06:38:10 <NoICE> Cale: so something like .. filter (!= '\x03') hGetChar ?
06:38:11 <Peaker> I think conduits went the furthest in terms of covering "real world functionality", and the various Tekmo pipes stuff went further with research on how to do it "properly"
06:38:18 <Philippa> (see also: Conor's presentation on Frank is good fun)
06:38:23 <shachaf> Philippa: By the way, there's an open problem in lens currently that you should solve.
06:38:32 <shachaf> The problem is to write taking.
06:38:42 <Cale> NoICE: You'll want to write an explicit recursive loop, probably.
06:38:44 <shachaf> "eternal glory"
06:38:50 <Philippa> heh
06:38:58 <typoclass> i dunno, it seems okay to have some competing implementations, "let's try a few things", and then contemplating what worked best and standardizing on it
06:38:58 <atriq>  :t taking ?
06:39:04 <Philippa> I'm aiming to get my glory via transforming the world of typechecking forever ;-)
06:39:21 <shachaf> Philippa: Currently the only complete implementation of taking uses unsafeCoerce.
06:39:24 <Philippa> typoclass: agreed
06:39:24 <NoICE> Cale: thx
06:39:53 <atriq> shachaf: unsafeCoerce lets you do some crazy stuff
06:40:04 <atriq> For instance, coercing unsafely
06:40:06 <atriq> But that's not all!
06:40:14 <shachaf> You can also coerce safely.
06:40:30 <shachaf> lens has a function called "coerce" for that, in fact.
06:40:35 <atriq> You can also use unsafeCoerce, (<*>), and pure to compute ANY COMPUTABLE THINGY
06:40:36 <nand`> > let id = unsafeCoerce :: a -> a in id 3
06:40:37 <lambdabot>   Not in scope: `unsafeCoerce'
06:40:41 <shachaf> (It's in .Internal.)
06:40:43 <nand`> :(
06:40:46 <Cale> Philippa: We are most definitely hitting the limitations of not having fancier type-level data structures in some of these libraries. (Of course, now we do have those, so maybe by using them, things might start to get better)
06:40:48 <Philippa> well, that warmed the CPU for a moment
06:41:00 <Cale> For example, look at this mess: http://hackage.haskell.org/packages/archive/pipes/2.5.0/doc/html/Control-Proxy-Class.html
06:41:10 <Philippa> Cale: yeah. Wonder how long before we start getting things like let in type annotations?
06:41:13 <Cale> (/>/) :: (Interact p, Monad m) => (a -> p x' x b' b m a') -> (b -> p x' x c' c m b') -> a -> p x' x c' c m a'
06:41:15 <shachaf> Funny how no other language considers themselves to be hitting those limitations.
06:41:21 <Cale> ^^ this is unacceptable
06:41:25 <shachaf> Ah, good old />/
06:41:31 <shachaf> p x' x c' c m a'
06:41:32 <nand`> Philippa: it'll be one step at a time until Haskell has full dependent typing
06:42:06 <Cale> After a while of staring at it, it starts to become clear what's going on, but it's a conventional nightmare.
06:42:12 <Philippa> Cale: no shit :-( It strikes me that people don't know when it's time to start using longer type variable names, but that's not the only problem
06:42:30 <shachaf> Philippa: Are you kidding? Half of those variables are *two characters*!
06:42:30 <rwbarton> then you get this http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html
06:42:31 <nand`> Monad m => p i p' e s -> a r e -> a w (e' s' o m e')
06:42:31 <Philippa> yeah. Arrows were bad enough
06:42:35 <shachaf> edwardk would never stand for it.
06:42:40 <yitz> shachaf: at least all the variables are different. in the lens types you get some of them identified with each other, seemingly at random to my eyes
06:42:43 <Peaker> Philippa, we kind of have "let":   f :: (a ~ LongTypeExpr, b ~ OtherTypeExpr) => ... use a and b ...
06:42:50 <shachaf> yitz: Example?
06:42:59 <nand`> type EdwardKPipe a b c d e f g h i j k = ...
06:43:12 <Philippa> Peaker: cute, I might even abuse that sometime
06:43:19 <b_jonas> Peaker: hehe
06:43:26 <yitz> shachaf: sorry don't know them by heart. just see edwardk emitting them all the time on this channel.
06:43:27 <pharm_> Quick Q: Is it reasonable for alex to take almost 1G of memory to generate Lexer.hs ?
06:43:31 <Philippa> (I'd like to have a nicer/more limited constraint than ~, but still)
06:43:38 <Cale> I have tried to abuse that, and gotten myself into trouble
06:43:43 <nand`> Peaker: I deliberated using that to make RGBSpace Double -> c -> (Double, Double, Double, Double) fit into 80col
06:43:45 <shachaf> yitz: One of these days I'm going to write up something explaining my intuition for "lens"
06:43:50 <Philippa> Cale: I am utterly shocked to hear that
06:43:55 <typoclass> Peaker: heh, that's a neat trick
06:43:55 <shachaf> Because no one else seems to have any. :-(
06:44:08 <nand`> Peaker: but doesn't that have the ability to generate (more) confusing type errors?
06:44:14 <atriq> shachaf: my intuition depends entirely on a Gary Larson cartoon I last saw years ago
06:44:16 <Philippa> "type level prolog" is totally what's going on
06:44:21 <atriq> I think I've mentioned this before
06:44:22 <Philippa> nand`: no shit!
06:44:32 <Philippa> that's one reason I want a proper let
06:44:34 <yitz> this is starting to sound like the Klop fixed point combinator
06:44:42 * nand` wants lazy, memoized type families
06:44:46 <Philippa> then again, I want let or an equivalent within type definitions (so the datatype's parms are in scope) too
06:44:52 <Cale> Type equality constraints are not quite the same thing as just substituting.
06:44:54 <Peaker> nand`, possibly.. I only look for key things in type errors and then stare at the line :)
06:45:01 <Philippa> yitz: um, er. I know bronies, pass the brain bleach?
06:45:06 <Peaker> nand`, if I can't figure out the problem long enough, only then do I actually carefully read the error
06:45:14 <Philippa> Cale: they sure aren't these days!
06:45:25 <yitz> klop = (L L L L L L L L L L L L L L L L L L L L L L L L L L) where L = λabcdefghijklmnopqstuvwxyzr. (r (t h i s i s a f i x e d p o i n t c o m b i n a t o r))
06:45:37 <nand`> Peaker: come to think of it, the package in questions has such immensely confusing type signatures (and errors) either way that I doubt it'd have made a difference
06:46:39 <Philippa> mmm. Errors are /the/ big problem, ultimately. If you've got enough info to do those well, you've got enough to handle the rest
06:46:49 <Peaker> shachaf, do you know if there's a ghc ticket open for a warning on incomplete instance declarations?
06:47:03 <Philippa> (which reminds me: I meant to have a poke at how badly type error slicing methods fall apart when you try them with pattern unification...)
06:47:24 <yitz> Peaker: there must be. people have been complaining about that for years.
06:47:37 <shachaf> Peaker: Nope, not that I know of.
06:47:48 <Peaker> yitz, yeah I wasted a couple of hours on that yesterday :(
06:47:50 <shachaf> Peaker: I started looking at the code to see what would be involved.
06:47:51 <int-e> > map (length . words) ["L L L L L L L L L L L L L L L L L L L L L L L L L L","t h i s i s a f i x e d p o i n t c o m b i n a t o r"]
06:47:53 <lambdabot>   [26,27]
06:47:59 <yitz> grrr
06:48:00 <shachaf> But it went like every other time that I've looked at GHC code.
06:48:03 <Cale> Philippa: And despite my picking on pipes, I think it's actually the *nicest* version of this sort of thing right now.
06:48:05 <Peaker> shachaf, and then you ended up reading the type checker? :)
06:48:19 <shachaf> Peaker: Well, it's *in* the type checker.
06:48:33 <shachaf> Lots of things are in the typechecker.
06:48:37 <Philippa> Cale: yep. Ever get the feeling we're hitting the stage where the greenspun-included version of the language is turning C++ish?
06:48:54 <Peaker> shachaf, which may explain another annoying ghc behavior of giving warnings only after it type-checks
06:49:04 <Peaker> shachaf, when a lot of the time, the warning would be much easier to figure out than the errors
06:49:10 <Peaker> (and caused by the same bug)
06:49:10 <Cale> Philippa: It certainly does remind me of the sort of hackery which I've seen people do with C++ templates
06:49:38 <Cale> Philippa: and on top of this, I consider it to be a premature optimisation in 90% of the cases where these libraries are being used
06:49:57 <Peaker> Cale, what's the alternative to the complicated conduit/iteratee/enumerator/pipes packages?
06:49:58 <shachaf> Cale: The only reason you consider it to be that is that none of the libraries are nice to use.
06:50:00 <Philippa> mmm. Mostly I just want to know things aren't going to behave pathologically
06:50:10 <Cale> Peaker: Writing straightforward strict IO
06:50:16 <Philippa> that's still a big ask though
06:50:31 <yitz> Cale, Peaker: i was going to say *lazy* io
06:50:39 <parcs`> egads!
06:50:41 <Philippa> mmm. I have to admit, I'm relieved I don't have to give a shit about big datasets myself
06:50:47 <Peaker> yitz, I think lazy IO is far worse than any of the other alternatives
06:51:09 <Philippa> I did recently have to remind someone I'm fond of that 1000 is a small number for most computers these days even if you run it through something with cubic complexity...
06:51:09 <Peaker> yitz, including just moving the program to be in IO and use strict IO
06:51:20 <yitz> Peaker: it's actually still the best in most simple cases.
06:51:31 <Cale> shachaf: yes, if they were transparent and obvious, and you never had to worry about the precise meaning of a type constructor with 6 or 7 type parameters, then there would be no problem using them from the start
06:52:04 <yitz> Peaker: where "most" is defined as much more than 50% of the programs i write in the problem spaces i tend to frequent. ymmv.
06:52:07 <Peaker> yitz, it has too many gotchas, and you have to choose between banning "hClose" and the like, and between taking the view that evaluation isn't pure anymore
06:52:53 <rwbarton> this is the problem I have with the whole pipes/etc. scene... so much FUD about the old ways to do things
06:52:54 <Philippa> yitz: yeah, I end up using it but grudgingly
06:52:58 <rwbarton> it happens a lot in this community
06:52:58 <Cale> Peaker: The thing about lazy IO is that sure it has gotchas which are unpleasant, but once you're aware of them, they almost cease to be an issue, because you know when to use strict IO instead.
06:53:09 <yitz> Peaker: it's true that even though it has the advantage of looking simple, thus being easier to read and understand, it actually isn't so simple. you need to understand when to worry about the gotchas.
06:53:16 <Philippa> rwbarton: mmm. Motivating the new library by trolling about existing circumstances
06:53:54 <Cale> and just because you want strict IO doesn't automatically make iteratees the right answer
06:54:16 <yitz> Philippa: have you noticed all the problems with lens? oops, never mind.
06:54:46 <rwbarton> Philippa: I think there is also a certain attitude of "moving past the dark days of lazy IO" which is also harmful
06:54:50 <Peaker> rwbarton, I don't think its FUD, I've always hated lazy I/O since before Oleg presented iteratees
06:54:56 <tomeo> gah, can't remember how to use let in ghci. isn't it just let num = 1 for example?
06:55:06 <Cale> tomeo: sure, that should work
06:55:06 <Peaker> I do think we need to move past the dark days of lazy I/O :)
06:55:13 <rwbarton> you're missing out, man
06:55:18 <kaifat> hello
06:55:44 <tomeo> haha Cale, I was loading a hs-file into ghci... thats why it wasnt working. didnt need the let :)
06:55:48 <tomeo> thanks btw
06:56:02 <Cale> tomeo: no problem
06:56:06 <Cale> kaifat: hello
06:56:46 <Peaker> Almost every time I used lazy I/O, I got bitten by it in an annoying way.  Handles that close, errors that pop up in random threads.  Processing time that happens in the wrong thread, and on and on
06:56:52 <shachaf> yitz: I heard there're 99 of them.
06:56:59 <atriq> shachaf: if you're not busy, can you explain how Control.Lens.Action works?
06:57:09 <Peaker> Error handling via pure exceptions is also a terrible outcome
06:57:16 <rwbarton> that mgsloan quote better make the haskell weekly news
06:57:50 <shachaf> rwbarton: Quotes get into HWN by being @remembered or twittered
06:57:51 <Cale> Peaker: So you don't use lazy IO when you expect to need to handle errors, and you don't use it when you care about closing handles.
06:58:23 <AfC> merijn, fmap: thanks for your earlier comments re Lenses
06:58:23 <rwbarton> @quote 99.operators
06:58:24 <lambdabot> No quotes match. :(
06:58:29 <Cale> There is a gigantic space of programs for which lazy IO is still very appropriate.
06:58:30 <tomeo> Is there a better way of treating a large number as a list of digits than to make it a string?
06:58:37 <Peaker> I personally use Haskell because I value correctness and safety over convenience and even over simplicity (especially superficial simplicity).  Lazy I/O sacrifices correctness and safety to get some convenience and superficial simplicity
06:58:53 <rwbarton> @remember mgsloan Lens got 99 operators, but a (|>) ain't one.
06:58:54 <lambdabot> I will never forget.
06:59:01 <Cale> tomeo: You could do something like  map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10)
06:59:02 <Peaker> Cale, and you don't use it when you have multiple threads in order to make the IO processing concurrent
06:59:09 <AfC> nand`: The question I was relaying was specifically asking if there was a mathematical foundation for lenses analogous to how category theory is a foundation for arrows thence monads.
06:59:10 <Cale> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div` 10) $ 3789105723891015789120572
06:59:13 <lambdabot>   [2,7,5,0,2,1,9,8,7,5,1,0,1,9,8,3,2,7,5,0,1,9,8,7,3]
06:59:22 <rwbarton> ugh so much "correctness" "safety" crap
06:59:25 <Cale> (note: ones digit first that way)
06:59:28 <Peaker> Cale, it's a bunch of extra things to think about when programming, when the problem being solved usually offers enough of its own challenge
06:59:47 <shachaf> atriq: I've never used it, but what's the trouble?
06:59:50 <rwbarton> wow is this about lazy IO? sounds like you're talking about pipes!
06:59:50 <Peaker> rwbarton, why is it crap?
06:59:55 <typoclass> > 123 `divMod` 10 -- tomeo: if you want to split off just one digit, you could use something like this
06:59:57 <lambdabot>   (12,3)
06:59:59 <atriq> shachaf: I have no idea what it is
07:00:14 <tomeo> thanks everyone, I'll have a go
07:00:20 <rwbarton> Peaker, the relevant notion of "observable effect" depends on the real-world problem you are trying to solve
07:00:23 <shachaf> atriq: Like Getter, except with the ability to have side effects.
07:00:39 <Cale> Peaker: For anything more serious, my first reaction would be to use strict IO and write things normally, rather than jump to using conduit/etc.
07:00:46 <rwbarton> Peaker, you can make the same arguments that are made against lazy IO against lazy evaluation too
07:00:47 <atriq> Oooh, I've just figured out what the hell "Effective m r f" is on about
07:01:05 <Peaker> Cale, that might be a good approach -- though one downside is that the stdlibs don't clearly mark functions that hide unsafe IO interleavings within them
07:01:11 <tomeo> typoclass: ah no that's not what I'm doing. I'm creating new numbers of a long one, out of consecutive digits. at least thats what Im trying to do :)
07:01:29 <yitz> i am tempted to add AfC's last statement to lambdabot's quote database.
07:01:35 <[1]tufflax> Hm, why can I type 4 :: Int but not 4 :: Integral
07:01:38 <Peaker> rwbarton, One of the arguments (processing time in wrong thread) is true for lazy evaluation too
07:01:45 <Philippa> rwbarton: lazy IO is a *much* leakier abstraction though
07:01:47 <prophile> Integral isn't a type, it's a typeclass
07:01:49 <Peaker> rwbarton, the others are only true for lazy I/O
07:01:55 <AfC> Cale: and, thanks for your later comments about lenses. Every time you describe it I feel I learn a little bit more. Cheers!
07:01:56 <rwbarton> Philippa: depends on the situation
07:01:57 <tomeo> Cale: Am I wrong or isnt rem a lot faster than mod?
07:02:00 <shachaf> @ty diff
07:02:02 <lambdabot> Num a => (forall (s :: * -> *). Numeric.AD.Types.Mode s => AD s a -> AD s a) -> a -> a
07:02:10 <rwbarton> if I am just processing some files on disk, I don't care when they are read
07:02:14 <Philippa> rwbarton: "I don't have a leak, why are you complaining?!". Fine.
07:02:16 <shachaf> > rem 5 3
07:02:17 <AfC> yitz: :)
07:02:17 <shachaf> > mod 5 3
07:02:18 <lambdabot>   2
07:02:19 <lambdabot>   2
07:02:20 <rwbarton> Philippa: come on
07:02:26 <shachaf> tomeo: Looks like both of them take "a couple of seconds" over lambdabot.
07:02:27 <rwbarton> different tools for different problems
07:02:36 <Cale> tomeo: It also has the wrong convention with respect to signs.
07:02:38 <prophile> shachaf: well, that settles that
07:02:49 <shachaf> prophile: I was making a point. :-)
07:02:51 <Philippa> rwbarton: sure. That includes in your responses. Peaker has the kinds of problems it's not appropriate for
07:02:59 <shachaf> Hmm, should I wait for SPJ to respond to my comment?
07:03:00 <rwbarton> right *but*!
07:03:00 <prophile> I appreciate the comprehensiveness of your tests
07:03:00 <Cale> tomeo: Well, "wrong" -- it's usually not the one that you want.
07:03:04 <prophile> bravo, sir, bravo
07:03:07 <prophile> :)
07:03:09 <Cale> > (-2) `mod` 5
07:03:11 <lambdabot>   3
07:03:15 <Cale> > (-2) `rem` 5
07:03:17 <lambdabot>   -2
07:03:18 <rwbarton> the tone from the pipes people is always: "don't use lazy IO *ever*! it is immoral"
07:03:23 <rwbarton> *that* is my problem
07:03:24 <tomeo> Cale: so I should just forget what I have "learned" that rem is the better choice?
07:03:25 <AfC> nand`: the person asking me was a functional programmer PhD who hadn't heard of lenses yet. I was trying to describe them. Not very well, I imagine.
07:03:26 <kaifat> somebody said in Russian?
07:03:38 <rwbarton> obviously for some problems lazy IO is inappropriate
07:03:48 <Peaker> rwbarton, I'm not a "pipes people". I like that people are trying nicer solutions to the problem. I think Cale might be right and straightforward strict IO would be better though
07:03:48 <Cale> tomeo: Well, it might be slightly faster if you don't care. But it's a whole lot easier to work with.
07:03:50 <rwbarton> that doesn't mean we have to discard a solution that works for another large class of problems
07:03:51 <Philippa> rwbarton: yeah. But honestly? Rephrase it as "only use lazy IO for quick hacks" and it's not so unreasonable
07:04:09 <Philippa> quick hacks (at least on the IO end) /are/ a large class, yes
07:04:36 <djahandarie> Philippa, rwbarton, maybe http://blog.ezyang.com/2012/11/extremist-programming/ is relevant here :)
07:04:39 <Philippa> but I really wouldn't be using it on anything I was productising, because then I have to care about the error handling. That's another large class of problem
07:04:42 <shachaf> @instances-importing Test.QuickCheck Testable
07:04:43 <lambdabot> Bool, Gen prop, Prop
07:04:46 <shachaf> That's not such a large class.
07:05:17 <yitz> Philippa: i use lazy for large problems, not just quick hacks. but not for large problems where complex combinations of io.
07:05:28 <yitz> come in to play
07:05:31 <Cale> I'm always concerned about the small scale space of programs. It annoys me to no end what has happened with importing modules since hierarchical modules were introduced and everyone decided to name all their functions the same as the ones in the Prelude so you'll be forced to write two imports unless you're happy qualifying everything.
07:05:51 <Philippa> yitz: Yeah. What kind of UI etc are you expected to provide around the IO going wrong?
07:06:08 <Cale> One liners and little programs in the 5-10 line range are important!
07:06:12 <Philippa> Cale: oh for a proper module system...
07:06:44 <yitz> Philippa: these are backend programs. they are wrapped by separate guis written in various other ways. (usually by other people in laguages other than haskell, actually.)
07:06:49 <yitz> *languages
07:07:26 <Philippa> *nod*. So I guess you've just got an outer catch/spew semi-useful error message situation
07:07:56 <yitz> Cale: true, but is it really that bad to write M.filter and whatever? actually makes code more clear sometimes.
07:08:34 <Cale> yitz: I just liked being able to import once and write filterFM rather than having dots-which-aren't-composition all over my code
07:08:59 <Cale> It would be a lot less bad if the module path separator were something other than '.'
07:09:28 <yitz> Cale: ok. the difference doesn't bother me. neither do the dots. question of taste i guess.
07:09:41 <Peaker> Cale, I agree that dots are bad syntax.. but listing all names is annoying as well (and sometimes the qualification does help readability).  And open-unqualified is a recipe for bitrot and extra unnecessary maintenance costs, and makes readers hunt painfully for where names are defined
07:09:48 <yitz> i mean it's not the purdiest in the world, but really no issue for me.
07:09:51 <Cale> It's visually distracting when you have lots of chains of compositions with qualified names in the middle of them
07:10:23 <jmcarthur> i find it distracting to see a bunch of suffixes on so many identifiers, though
07:10:26 <Peaker> I find space-dot-space to be visually distinguished from Capitalized-dot-something
07:10:29 <atriq> I do it by block of colour
07:10:39 <jmcarthur> at least with qualified imports i can use whatever prefix i want (plus the annoying dot)
07:10:41 <atriq> And in my editor, qualified names are green, I think
07:10:50 <yitz> Cale: a little. the look of qualified names in backquotes bothers me too. but these things are really not important enough to matter in my view.
07:10:58 <jmcarthur> Peaker: me too, actually
07:11:05 <rwbarton> Peaker: anyways I hope you would agree that for some problems, e.g. doing streaming data processing of a single file, "< Peaker> Cale, it's a bunch of extra things to think about when programming, when the problem being solved usually offers enough of its own challenge" is exactly a reason to use lazy IO, rather than a pipes-type library
07:11:07 <Cale> yitz: or, lol, other infix operators
07:11:15 <jmcarthur> it sometimes bites me when i use the [Foo..] syntax though
07:11:41 <yitz> Cale: oh yes, even worse, right.
07:11:46 <parcs`> are conduits etc not considered a better alternative lazy io implementation? (instead of an alternative _to_ lazy io)
07:12:18 <Philippa> Cale: yeah, I find it okay but only because I syntax highlight pretty viciously
07:12:18 <yitz> Cale: so for operators i import them separately unqualified whenever possible, which is usually. or rename them to something else.
07:12:31 <Philippa> well, that and don't use the long module names
07:12:31 <jmcarthur> i like how in ocaml i can say "open Foo.Infix" to open just the Infix module inside the Foo module, and for everything else in Foo i just qualify it
07:12:36 <Cale> parcs`: the evaluation order of the results has no bearing on how the IO is carried out in the case of iteratees
07:12:39 <Peaker> rwbarton, if you just stream a single file, you can usually just strict-read-it.. if it's very large, then maybe write a strict little chunk reader loop directly or use pipes/conduits.  If it is just a quick hack, then lazy I/O is acceptable (but I really wish the conduit-style libs matured enough and put in stdlib to cover that well enough to be as easy as the hGetContents >>= style solutions)
07:12:58 <jmcarthur> (where of course Foo.Infix contains only infix operators)
07:13:01 <dna_> jmcarthur: i asked you a question a couple of days ago about reifying an AST for an EDSL when using a list in the host language
07:13:07 <Peaker> rwbarton, but quick hacks sometimes grow into real programs
07:13:18 <jmcarthur> dna_: yes?
07:13:23 <dna_> jmcarthur: i managed to solve the problem using data-reify
07:13:27 <jmcarthur> awesome!
07:13:32 <yitz> Peaker: they will eventually
07:13:34 <jmcarthur> what'd you end up doing?
07:13:41 <yitz> Peaker: maybe you'll do it in fact
07:13:46 <dna_> jmcarthur: the trick was to add two list constructors in the type you reify to
07:13:57 <Cale> Peaker: this is Haskell, refactoring is easy
07:14:19 <kaifat> hеllo all girls
07:14:22 <dna_> and to add an instance (DeRef Expr ~ DeRef [Expr]) => MuRef Expr
07:14:26 --- mode: ChanServ set +o Cale
07:14:45 <yitz> Peaker: it feels very silly to roll my own chunk reader loop instead of just using lazy text and bytestring streams
07:14:47 <jmcarthur> dna_: (DeRef Expr ~ DeRef [Expr])   -- i find this amusing
07:14:50 <dna_> so even though the EDSL doesn't have lists, the DAG for the EDSL will contain lists, and from the DAG you can extract the list manually
07:15:09 <jmcarthur> cool
07:15:13 <Cale> Peaker: I mean, hopefully most of your real computation is separate from how the I/O is being done anyway, so you can just rewrite that bit when it comes time to really handle errors and so on.
07:15:24 <dna_> yeah, it's basically letting data-reify reify both primitive types and lists of primitive types to the same result type
07:15:29 <yitz> Peaker: i had to do it once due to a bug in attoparsec. it felt... embarrassing.
07:15:47 --- mode: Cale set +b *!*@static.134.225.9.5.clients.your-server.de
07:15:47 --- kick: goozoo was kicked by Cale (goozoo)
07:18:53 <notdan> what is the difference between Alternative and MonadPlus/Monoid?
07:18:59 <shachaf> MonadPlus ~ Alternative
07:19:02 <shachaf> Monoid is a different kind.
07:19:26 <notdan> shachaf: I've been told that Monoid is (isomorphic) to MonadPlus, what is the difference between those two then?
07:19:37 <shachaf> They have different kinds, for one.
07:19:52 <notdan> Well, besides the Monad requirement
07:20:03 <shachaf> And the kind difference?
07:20:16 <Cale> MonadPlus is for Monads which create monoids, in the sense that for each type t, you have a monoid structure on M t
07:20:57 <notdan> shachaf: hm, sorry, but  what is a kind of a typeclass?
07:21:13 <shachaf> The instances of Monoid have kind *
07:21:20 <shachaf> The instances of MonadPlus have kind * -> *
07:22:18 <yitz> notdan: usually we talk about the kind of a type, not of a typeclass.
07:22:21 <Gurragchaa> does the REPL at tryhaskell.org support the use of IO?  [i.e. using do-notation with putStrLn and such; i'm not sure if this is called "The IO Monad" or not]
07:22:21 <notdan> Hm, I see. Thanks Cale, shachaf
07:22:51 <notdan> yitz: yeah, that's why I asked the followup question
07:23:19 <djahandarie> Honestly, ConstraintKinds makes a whole lot of sense and should be used in explanations.
07:23:25 <copumpkin> :k MonadPlus
07:23:26 <lambdabot> (* -> *) -> Constraint
07:23:29 <copumpkin> :k Monoid
07:23:30 <lambdabot> * -> Constraint
07:23:35 <copumpkin> :k Alternative
07:23:36 <lambdabot> (* -> *) -> Constraint
07:23:48 <yitz> notdan: ah ok then shachaf's answer works for you. great.
07:23:57 <rwbarton> Peaker, the fact that I may have to replace my single line of IO code with some more complicated mechanism in the conjectural future is surely not enough to stop me from writing that single line of IO code
07:24:47 <shachaf> Area pragmatist advocates lazy I/O; bystanders horrified
07:25:15 <Philippa> Gurragchaa: just tried Hello World, it tried to show the raw IO action so that'd be a no
07:25:45 <rwbarton> Peaker, it sounds a lot more appealing than wedding my program inextricably to some particular pipes library
07:26:07 <rwbarton> in the future, this all may change when the library situation has improved. i'm not against progress on the pipes sides of things, quite the opposite!
07:28:47 <jmcarthur> most people also agree that MonadPlus has some laws, but they don't agree on what the laws are
07:28:59 <jmcarthur> therefore, the instances are inconsistent on this, even in base
07:29:25 <jmcarthur> *some additional laws beyond the Monoid laws
07:31:31 <rwbarton> Peaker: you managed to hit on an even bigger pet peeve of mine than lazy IO bashing though, so I think I'd better stop now :)
07:31:46 <Saizan> where is MonadPlus/Alternative used btw? parsers and LogicT?
07:31:58 <nand`> is there any haskell library for loading and working with ICC profiles? Preferably with a connection to package ‘colour’ :)
07:32:08 <shachaf> What's the bigger peeve?
07:32:31 <rwbarton> premature extensibility
07:32:35 <nand`> LittleCMS 2 bindings or something would be wonderful
07:33:51 <jmcarthur> i don't find "extensibility" appealling in most cases. i've rarely seen a case where it's not premature
07:34:07 <fmap> Saizan: routing in happstack
07:34:33 <jmcarthur> as long as it's composable, it'
07:34:35 <jmcarthur> oops
07:34:43 <jmcarthur> as long as it's composable, it's probably "extensible" enough already
07:34:51 <nand`> also, what's a good library for PNG file generation?
07:35:26 <shachaf> The PNG file generation? Is that people born in the 2000s?
07:35:48 <shachaf> 1990s is surely the GIF generation.
07:36:29 <Saizan> there are lots of gifs around now too
07:36:41 <nand`> I was born in 93 and I only remember PNG being popular; I don't think I register GIF popularity anywhere in my memory
07:37:04 <nand`> spinning APNGs
07:37:32 <shachaf> APNGs are a lie.
07:37:49 <Entroacceptor> yeah, people born in the 80s are the GIFfers
07:38:32 <Entroacceptor> I used a raytracer to animate my nickname for my geocities page!
07:38:46 <jmcarthur> indeed, i remember a time before pngs were popular (indeed, before they were even supported in browsers)
07:38:52 <Jafet> What is geocities
07:39:40 <robbe-> What is this internet thing you guys are talking about?
07:39:45 <robbe-> browsers?
07:39:50 * robbe- feels old
07:39:54 <Jafet> Something to do with pipes
07:40:15 <sipa> browsers? what's wrong with netcat?
07:40:16 * nand` is saddened by lack of color-aware haskell libraries
07:40:18 <tufflax> Why can't I do someFunction x:xs = ..., I mean I need need (x:xs)
07:40:38 <sipa> tufflax: because that meams (someFunction x):xs
07:40:41 <sipa> means
07:41:11 <tufflax> oh
07:41:18 <tufflax> ok, I see
07:41:18 <tufflax> thx
07:41:52 <Jafet> We have the net, we have the web, the next big thing will be dreads
07:41:53 <jmcarthur> sipa: what do you mean by "color-aware"?
07:42:20 <vraid> how would i best create a list that is xs with every nth element replaced by 'a'?
07:43:18 <watermind> a <$ xs
07:43:31 <watermind> ^ vraid
07:44:02 <vraid> where does n come in to it?
07:44:04 <watermind> which is equivalent to  fmap (const a) xs
07:44:14 <Entroacceptor> he misread
07:44:16 <Jafet> map (('a':).tail) . splitEvery n
07:44:16 <watermind> oh I didn't read properly
07:44:22 <watermind> I skipped the nth
07:44:47 <rwbarton> zipWith ($) (cycle (const 'a' : replicate (n-1) id))
07:44:56 <otters> :t fmap . const
07:44:58 <lambdabot> Functor f => b -> f a -> f b
07:45:03 <vraid> Jafet: will try, thanks
07:45:04 <otters> :t (<$)
07:45:06 <lambdabot> Functor f => a -> f b -> f a
07:45:08 <rwbarton> depending on where you want to start counting you can tweak it
07:45:40 <Jafet> Why so higher order
07:45:46 <rwbarton> if you don't have a splitEvery on hand
07:46:26 <vraid> hmm.. i realize now that i don't need to replace anything, it can be much simpler
07:47:29 <watermind> vraid: zipWith (\(x,i)->if n `mod` i == 0 then x else n) xs [1..]
07:49:41 <watermind> that lambda should be curried though
07:50:20 <fmap> :t \k n -> over (iwhereOf (indexed traverse) (\i -> i `mod` k == 0)) (const n)
07:50:20 <watermind> and the last n should be an a
07:50:23 <lambdabot> Traversable t => Int -> b -> t b -> t b
07:50:27 <watermind> eh
07:50:56 <vraid> i'm still struggling to properly read the syntax in haskell
07:51:49 <yitz> come on, where are all the lens advocates? there must be some clever way to solve vraid's problem using lens.
07:51:58 <edwardk> ?
07:52:04 * edwardk looks up
07:52:28 <yitz> vraid: ignore me, just trolling people who have been advocating a new fancy library here lately
07:52:52 <edwardk> :t \k n -> iwhere (\i -> i `mod` k == 0) .~ n
07:52:54 <lambdabot> (Integral a, TraversableWithIndex a t) => a -> b -> t b -> t b
07:53:07 <fmap> =(
07:53:36 <shachaf> That is remarkably clear, actually.
07:53:57 <Jafet> Horatio puts on his iwhere.
07:53:58 <watermind> vraid: let f n a xs = zipWith (\x i->if i `mod` n == 0 then a else x) xs [1..]    -- that's what I meant by the way
07:54:08 <shachaf> > iwhere (\i -> i `mod` 5 == 0) .~ 'Q' $ "just some text to try this thing out with"
07:54:10 <lambdabot>   "Qust Qome Qext Qo trQ thiQ thiQg ouQ witQ"
07:54:14 <edwardk> :t let every k = iwhere (\i -> i `mod` k == 0) in every 3 +~ 1  $ [1..20]
07:54:16 <lambdabot> (Enum a, Num a) => [a]
07:54:21 <edwardk> > let every k = iwhere (\i -> i `mod` k == 0) in every 3 +~ 1  $ [1..20]
07:54:23 <lambdabot>   [2,2,3,5,5,6,8,8,9,11,11,12,14,14,15,17,17,18,20,20]
07:54:33 <rwbarton> i sense a fizzbuzz coming
07:54:35 <otters> :t iwhere
07:54:37 <lambdabot> (Applicative f, TraversableWithIndex i t, Indexed i k) => (i -> Bool) -> k (a -> f a) (t a -> f (t a))
07:54:41 <otters> oh of course
07:55:13 <edwardk> it takes any container that is traversable with an index and a predicate on the index and gives you a traversal of the elements where that is true
07:55:14 <tufflax> Fizzbuzz inspired me to learn Haskell, or rather the use of monads in a fizzbuzz example i saw :p
07:55:19 <otters> oh, neat
07:55:31 <otters> and [a] is traversablewithindex
07:55:52 <edwardk> te type signature is a little crazy because it also generates an indexed traversal, so you can access the keys if you want to using some of the various iwhatever combinators in lens
07:55:54 <edwardk> yep
07:56:18 <edwardk> > itoListOf itraverse ["hello","world"]
07:56:20 <lambdabot>   Couldn't match expected type `Control.Lens.IndexedGetter.IndexedGetting
07:56:21 <lambdabot>    ...
07:56:25 <edwardk> > itoListOf itraversed ["hello","world"]
07:56:28 <lambdabot>   [(0,"hello"),(1,"world")]
07:56:49 <notdan> http://hpaste.org/78014 why does this parser code goes into the infinite loop?
07:57:22 <Jafet> Left recursion
07:57:49 <notdan> yeah, but isn't chainl supposed to deal with it?
07:57:50 * Jafet opens the link to make sure
07:57:57 <notdan> If no, then how can I fix it?
07:58:27 <Hermit> I've been reading wikipedia and the haskell wiki about Monoids... but I'm still wondering wtf are them
08:00:15 <otters> :t foldMap
08:00:16 <lambdabot>     Not in scope: `foldMap'
08:00:17 <lambdabot>     Perhaps you meant one of these:
08:00:17 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
08:00:22 <otters> :t Data.Foldable.foldMap
08:00:25 <lambdabot> (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
08:00:30 <Saizan> notdan: i think you're supposed to use chainl instead of recursion, not with it
08:00:31 <otters> why isn't m given a type argument there
08:00:48 <Saizan> because it's a Monoid, not a Monad
08:00:58 <otters> oh yeah that's right
08:01:03 <bitonic> Hermit: they're a type `a' with a function `f :: a -> a -> a' and an element `e' such that `f e x = e' for all xs
08:01:08 <bitonic> and f x e = e
08:01:30 <notdan> Hermit: it's a typeclass. Anything that implements mzero and mappend is a monoid. For example, numbers form a monoid with mzero = 0, mappend x y = x+y. Similar with lists
08:01:36 <ion> > let f modulo text num = text <$ guard (num `mod` modulo == 0) in map (\n -> fro
08:01:37 <notdan> Saizan: hm, right
08:01:38 <lambdabot>   <hint>:1:80: parse error (possibly incorrect indentation)
08:01:39 <bitonic> also, `f (f x y) z === f x (f x y)'
08:01:41 <notdan> Saizan: that makes sense
08:01:41 <ion> whoops
08:01:48 <donri> Hermit: what a monoid actually *does* depends completely on the particular instance of the monoid class
08:01:55 <ion> > let f modulo text num = text <$ guard (num `mod` modulo == 0) in map (\n -> fromMaybe (show n) (f 3 "fizz" n `mappend` f 5 "buzz" n)) [0..]
08:01:56 <lambdabot>   ["fizzbuzz","1","2","fizz","4","buzz","fizz","7","8","fizz","buzz","11","fi...
08:02:25 <vraid> better use [1..]
08:02:38 <Hermit> notdan: so works for lists too? mzero = []
08:02:40 <ion> 1 is the devil
08:02:56 <Jafet> @instances Monoid
08:02:56 <notdan> Hermit: yeah and mappend is list (++)
08:02:56 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
08:03:01 <donri> Hermit: well, mempty. mzero is MonadPlus
08:03:28 <Hermit> MonadPlus... Control.MonadPlus, right?
08:03:37 <donri> Control.Monad
08:03:47 <TBJoe> hey guys, i got a question ... im experimenting with trees but its very very circumstantial to go through patterns like "Node (Node (Node Empty 1 Empty) 2 Empty) 3 (Node Empty 4 (Node Empty 5 (Node Empty 6 Empty)))" over and over again to verify the result. is there an easy way to give this out in a structured way?
08:03:51 <hiptobecubic> :t show
08:03:52 <lambdabot> Show a => a -> String
08:04:08 <hiptobecubic> ion, why fromMaybe?
08:04:11 <Hermit> donri: that's a problem I've been having, how to find _where_ some typeclass or function is contained in all the libraries available
08:04:21 <vraid> hmm, new question. How do i declare an integer n = (x-1)/2  that i can use in 'replicate n a'
08:04:34 <donri> Hermit: hoogle and hayoo help with that
08:04:35 <ion> hiptobecubic: Why not?
08:04:47 <edwardk> Hermit: fortunately there are relatively few that you need to use every day, so you'll quickly learn where to reach for them
08:04:48 <Hermit> donri: doesn't ghc have something like that hidden somewhere?
08:04:53 <rwbarton> > 0 :: Maybe Int
08:04:54 <hiptobecubic> ion, i mean where is maybe being introduced? the guard?
08:04:55 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe GHC.Types.Int))
08:04:56 <lambdabot>    arising f...
08:05:04 <Entroacceptor> TBJoe: Data.Tree has a "drawTree"
08:05:07 <rwbarton> oh i see right
08:05:31 <Saizan> vraid: use `div`, (/) is for fractional types
08:05:35 <Entroacceptor> (which is quite simple to just copy)
08:05:39 <ion> @type let f modulo text num = text <$ guard (num `mod` modulo == 0) in f  -- hiptobecubic
08:05:41 <lambdabot> (Integral a1, Functor f, MonadPlus f) => a1 -> a -> a1 -> f a
08:05:41 <edwardk> :t div
08:05:43 <lambdabot> Integral a => a -> a -> a
08:05:45 <TBJoe> @Entroacceptor okay thanks i will try to get that work :)
08:05:45 <lambdabot> Unknown command, try @list
08:05:47 <ion> hiptobecubic: MonadPlus f ~ Maybe
08:05:49 <donri> Hermit: have you seen this? http://hackage.haskell.org/package/base
08:06:01 <ion> hiptobecubic: Err… I mean, f ~ Maybe
08:06:02 <vraid> Saizan: the thing is, x will always be odd, so n will always be an integer
08:06:10 <Hermit> so MonadPlus is like Monoid for Monads
08:06:14 <vraid> ah, nvm, got it
08:06:20 <hiptobecubic> :t guard
08:06:22 <lambdabot> MonadPlus m => Bool -> m ()
08:06:47 <ion> hermit: MonadPlus and Alternative instances are monoids, yes.
08:07:09 <hiptobecubic> :t (<$)
08:07:11 <lambdabot> Functor f => a -> f b -> f a
08:08:02 <hiptobecubic> > "Foo" <$ guard False
08:08:04 <lambdabot>   No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
08:08:04 <lambdabot>    arising from a use...
08:08:08 <hiptobecubic> ah
08:08:33 <hiptobecubic> > "Foo" <$ guard False :: Maybe String
08:08:35 <lambdabot>   Nothing
08:08:40 <hiptobecubic> > "Foo" <$ guard True :: Maybe String
08:08:42 <lambdabot>   Just "Foo"
08:08:51 <hiptobecubic> :t fromMaybe
08:08:53 <lambdabot> a -> Maybe a -> a
08:08:59 <Hermit> ion: Alternative is another typeclass, but never heard of it before. Google says it's used in parser combinators but... uhh...
08:09:25 <hiptobecubic> ok i get it finally :)
08:10:37 <ion> @src Alternative
08:10:37 <lambdabot> class Applicative f => Alternative f where
08:10:38 <lambdabot>     empty :: f a
08:10:38 <lambdabot>     (<|>) :: f a -> f a -> f a
08:10:40 <Hermit> haskell is starting to feel like I'm solving multi-dimensional type tetris most of the time instead of actually programming. Is all this complexity really worth it? (does it get better later?)
08:10:57 <Iceland_jack> Hermit: (it depends)
08:11:15 <ion> hermit: After using it for a while the experience won’t be like that at all.
08:11:22 <Jafet> @quote dimensional
08:11:22 <lambdabot> ray says: three dimensional zippers make my scalp hurt when i get my hair caught in them
08:11:23 <bitonic> Hermit: it's just novelty
08:11:42 <tomeo> Im trying to understand this statement properly; map (`mod` 10) . takeWhile (/= 0) . iterate (`div`10) $ 922511. It will produce the list [1,1,5,2,2,9]. Why use `mod` 10 when effectively does nothing to a base 10 number?
08:11:44 <Hermit> Iceland_jack: on what
08:11:54 <bitonic> it's much simpler than other mainstream languages type systems (if you stick to std Haskell)
08:12:01 <Iceland_jack> Hermit: Some of the things in Haskell are not going to be very useful: you can get by without knowing about Product or Monoids
08:12:10 <bitonic> or less astonishing anyway
08:12:15 <Hermit> bitonic: you mean haskell is just novelty or you mean I feel like this because I'm new to it?
08:12:16 <parcs`> tomeo: what do you mean it does nothing? it gives you the least significant digit of a base 10 number
08:12:17 <rwbarton> tomeo: you can take off the "map (`mod` 10) . " part to understand what it is for
08:12:28 <bitonic> Hermit: you feel like that because you're new to it
08:12:42 <geekosaur> "does nothing" isn't quite correct
08:12:54 <tomeo> rwbarton: ah, its so that I go through all elements using takeWhile(/=0) ?
08:13:04 <rwbarton> no?
08:13:09 <tomeo> oh :(
08:13:10 <dna42> Hermit: one of the strengths of haskell, but also what makes it harder for beginners is that it is so easy to define abstractions
08:13:16 <vraid> tomeo: `div` 10 will strip the last digit, while `mod` 10 strips all but the last
08:13:21 <tomeo> I was thinking as numbers 0-9 will never be 0 mod 10
08:13:33 <parcs`> tomeo: the numbers aren't 0-9 yet
08:13:35 <dna42> this is really useful, but can be quite overwhelming at first... try to take one abstraction at a time
08:13:39 <tomeo> ah okay
08:13:46 <rwbarton> tomeo: just try out the steps
08:13:50 <rwbarton> > iterate (`div`10) $ 922511
08:13:53 <lambdabot>   [922511,92251,9225,922,92,9,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
08:13:54 <parcs`> tomeo: they're 'abcde', 'abcd', 'abc', 'ab', and 'a'
08:13:58 <rwbarton> > takeWhile (/= 0) . iterate (`div`10) $ 922511
08:14:00 <lambdabot>   [922511,92251,9225,922,92,9]
08:14:04 <rwbarton> > map (`mod` 10) . takeWhile (/= 0) . iterate (`div`10) $ 922511
08:14:04 <notdan> Hm, apparently I need to buildExpressionParser. Does anybody know any good documents on Parsec3? RWH's chapter is kinda limited and the documentation on the official site is very old
08:14:06 <lambdabot>   [1,1,5,2,2,9]
08:14:14 <rwbarton> tomeo: do you see how each step is computed from the previous step?
08:14:29 <tomeo> rwbarton: yes I'm starting to get it now :) thanks
08:14:32 <Saizan> notdan: there's some in the haddocks
08:14:47 <Hermit> well, I don't like to ask most of the time so I try to figure things on my own but I've reached the point where I'm cursing like crazy trying to do "simple" stuff. For example, I've yet to find a way to get a list of bare types from a list of existentials
08:15:45 <Hermit> guess I'll paste the code
08:15:58 <geekosaur> Hermit, there's a reason for that
08:16:02 <dna42> Hermit: I don't know if existensials qualify as simple stuff though
08:16:44 <ion> > reverse . unfoldr (\n -> swap (n `quotRem` 5) <$ guard (n /= 0)) $ 922511
08:16:45 <notdan> Hm, so should I use Text.ParserCombinators.Parsec or Text.Parsec?
08:16:45 <lambdabot>  Terminated
08:16:49 <ion> > reverse . unfoldr (\n -> swap (n `quotRem` 5) <$ guard (n /= 0)) $ 922511
08:16:51 <lambdabot>   [2,1,4,0,1,0,0,2,1]
08:17:00 <ion> > reverse . unfoldr (\n -> swap (n `quotRem` 10) <$ guard (n /= 0)) $ 922511
08:17:02 <lambdabot>   [9,2,2,5,1,1]
08:17:11 <Hermit> geekosaur: well, my point is that when filtering a list of existentials there's no real reason why I couldn't get an empty list of some of the boxed types in the worst case
08:17:17 <fmap> notdan: the latter
08:17:22 <geekosaur> existential types do not give you perl-like types
08:17:31 <geekosaur> (or lack of types, really)
08:17:37 <Saizan> notdan: i think the former is a backwards compatibility re-export of the latter
08:17:41 <geekosaur> they *erase* types
08:17:42 <shachaf> @let every k = iwhere (\i -> i `mod` k == 0)
08:17:45 <lambdabot>  Defined.
08:17:51 <Jafet> > read.pure <$> show 922511 :: [Integer]
08:17:53 <lambdabot>   [9,2,2,5,1,1]
08:18:45 <geekosaur> you literally do not know anything about what;s in the box.  you didn;t cloak the stuff yoy wanted to slip past that evil type system; you removed it irrecoverably
08:19:04 <notdan> fmap, Saizan: thanks!
08:19:26 <shachaf> exists a. Typeable a *> a
08:19:34 <shachaf> "what now :'("
08:19:43 <Jafet> Sounds legit
08:19:46 <Hermit> geekosaur: oh, I see
08:20:16 <Hermit> geekosaur: I thought the existential was a way of boxing
08:20:29 <Hermit> damnit, that explains it
08:20:31 * hayashi has persistent explode in his face whilst trying to build yesod, the error message has now conveniently scrolled off the terminal and therefore i cant ask for help with it~!
08:20:37 <geekosaur> I'm not entirely certain what you're trying todo but it sounds like the usual "I want to pretend this is Perl and use any type anywhere"
08:20:50 <hayashi> something like (Int, Int) not matching (#t0, t1#) somewhere in the TH code
08:20:54 <Jafet> @instances Dynamic
08:20:55 <lambdabot> Couldn't find class `Dynamic'. Try @instances-importing
08:21:03 <Jafet> @instances-importing Data.Dynamic Dynamic
08:21:04 <lambdabot> Couldn't find class `Dynamic'. Try @instances-importing
08:21:09 <geekosaur> which treats types as a terrible thing to be worked around at every opportunity because they;re just there to make life difficult
08:21:26 <Hermit> geekosaur: not really, I was just experimenting. Learning topics in isolated environments so I get the hang of it
08:21:31 <geekosaur> if this is how you appropach haskell, it will indeed be very hard to work with.
08:21:35 <ion> (forall a. Typeable a *> a) ~ TypeRep
08:21:37 <ion> err
08:21:39 <ion> exists
08:22:04 <Hermit> geekosaur: what do you suggest then?
08:22:26 <geekosaur> have you worked your way through LYAH yet?
08:22:34 <Hermit> doesn't ring a bell
08:22:40 <geekosaur> @where lyah
08:22:41 <lambdabot> http://www.learnyouahaskell.com/
08:22:45 <shachaf> ion: Hmm?
08:22:49 <shachaf> ion: What about cast?
08:23:20 <Saizan> ion: Dynamic, you mean?
08:23:23 <Hermit> oh, that.. well, I've been reading realworld haskell and couldn't wait to get cracking, so I kind of stashed the book for a while and got my hands dirty
08:23:31 <hayashi> i get the feeling i should just remove the ghc library directory and start all over again with cabal, everything is pleasantly broken
08:23:46 <geekosaur> but the real conceptual shift is when you realize that types are where you model the problem you're trying to solve; large parts of your program will then "write themselves" insofar as there's only one (and often simple) bit of code with the type you need
08:23:47 <Hermit> I've come across lyah recently
08:24:06 <Hermit> and thought "I'm gonna read this one too...", but that's it
08:24:12 <NoICE> I had one situation like this just yesterday - I parsed some stream data from network and wanted to convert them to record type, based on whats inside the stream... but I also needed separate record types and constructs for those.. so I have data Type1 = Type1 ... Type2 = Type2 .. and then all those are Operation instances)
08:24:14 <shachaf> geekosaur: And sometimes you don't know what the type you want is at all.
08:24:16 <dna42> Hermit: it's a good book
08:24:23 <shachaf> And you know how to write the program but only with unsafeCoerce
08:24:29 <NoICE> so when I want to return this type based on the stream I don't know WHAT I will need to return
08:24:36 <shachaf> And it works great with unsafeCoerce but what about without it. :-(
08:24:38 <tomeo> Is there a function, kind of like permutations from Data.List, that will take a list of digits like [1,2,3,4] and create a new list [[1,2,3],[2,3,4]], in other words takes a specified number of consecutive elements in one list and puts them in a another list?
08:24:39 <NoICE> so I solved it by using wrapper type with forall
08:24:46 <ion> shachaf, saizan: class Typeable a where { typeOf :: a -> TypeRep } http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-Typeable.html#t:Typeable
08:25:10 <bartavelle> shachaf, I have a solution to this problem : I don't know what unsafeCoerce does, so I have to think harder ;)
08:25:11 <shachaf> ion: cast :: (Typeable a, Typeable b) => a -> Maybe b
08:25:13 <Saizan> ion: right, but you also have an 'a' in there
08:25:20 <ion> shachaf: Implemented in terms of typeOf
08:25:22 <NoICE> data Dataable = forall a. (Data a) => MkData a
08:25:22 <NoICE> data Message = Message Header Dataable deriving Show
08:25:24 <NoICE> using existential quantification:
08:25:40 <NoICE> and so I can use type definitions: f x -> Dataable
08:25:43 <shachaf> ion: typeOf and unsafeCoerce
08:25:47 <ion> yes
08:26:00 <Jafet> > fst.break (null.drop 3) . map (take 3) . tails $ [1,2,3,4]
08:26:02 <lambdabot>   []
08:26:20 <Saizan> exists a. Typeable a *> () ~ TypeRep, but if s/()/a/ you get Dynamic
08:26:37 <Jafet> > map (take 3) . fst.break (null.drop 3) . tails $ [1,2,3,4]
08:26:39 <lambdabot>   [[1,2,3]]
08:27:10 * hayashi bins his ~/.ghc and starts again from scratch
08:27:21 <neutrino> :t break
08:27:22 <lambdabot> (a -> Bool) -> [a] -> ([a], [a])
08:27:28 <ion> shachaf, saizan: Hmm, now that i think of it, i get what you mean.
08:27:31 <neutrino> interesting
08:27:53 <neutrino> > break (== 2) [0..4]
08:27:55 <lambdabot>   ([0,1],[2,3,4])
08:28:01 <hayashi> god damnit
08:28:11 <neutrino> @ty null
08:28:13 <hayashi> even global is nastily broken too
08:28:13 <lambdabot> [a] -> Bool
08:28:58 <statusfailed> is there a better way to write this? bind2 f m1 m2 = do { x <- m1; y <- m2; f x y }
08:28:58 <neutrino> .
08:29:10 <statusfailed> or does it exist in standard library already
08:29:11 <neutrino> @undo bind2 f m1 m2 = do { x <- m1; y <- m2; f x y }
08:29:12 <lambdabot> bind2 f m1 m2 = m1 >>= \ x -> m2 >>= \ y -> f x y
08:29:18 <Saizan> statusfailed: liftM2
08:29:22 <Jafet> @@ @pl @undo bind2 f m1 m2 = do { x <- m1; y <- m2; f x y }
08:29:22 <lambdabot>  bind2 = flip ((.) . (>>=)) . flip ((.) . (>>=))
08:29:24 <statusfailed> Saizan: not quite
08:29:39 <Saizan> ah
08:29:51 <shachaf> join (liftM2 f x y?
08:29:51 <Saizan> join $ liftM2 f m1 m2 :)
08:29:52 <shachaf> )
08:29:53 <ion> statusfailed: Dunno about better, but another: bind2 f a b = join (liftM2 f a b)
08:29:55 <statusfailed> oh, liftM2 . join
08:30:00 <ion> Not .
08:30:01 <neutrino> @@ @unpl @pl bind2 f m1 m2 = m1 >>= \ x -> m2 >>= \ y -> f x y
08:30:02 <lambdabot>  bind2 o c f = c >>= \ l -> f >>= (o l)
08:30:05 <statusfailed> oops backwards
08:30:06 <shachaf> And not in that order.
08:30:07 <statusfailed> haha
08:30:44 <statusfailed> that's what i'm looking for
08:30:44 <neutrino> here you go
08:30:46 <statusfailed> cheeeeeeers
08:36:12 <vraid> what's the syntax to do e.g. "where x = 2*y, y = a"
08:36:26 <shapr> vraid: does that not work?
08:36:40 <shachaf> No. You need semicolons.
08:36:46 <shachaf> (Or newlines.)
08:36:51 <byorgey> or newlines and indentation.
08:37:02 <vraid> okay, i was just unsure
08:37:54 <shachaf> byorgey: Update: DeriveFunctor is broken too.
08:38:14 <booski> Is there any module with defined permutation data structure from a group theory? With all stuff like cycles, inverse, etc
08:40:49 <johnw> shachaf: did you get to the bottom of your deriving wierdness?
08:42:04 <booski> Looks like smth what I'am looking for http://www.polyomino.f2s.com/david/haskell/permgrp.html
08:44:14 <Cale> http://hackage.haskell.org/packages/archive/HaskellForMaths/0.4.5/doc/html/Math-Algebra-Group-PermutationGroup.html
08:44:15 <Cale> yeah
08:44:21 <Cale> same thing
08:46:06 <tomeo> thanks Jafet
08:46:44 <byorgey> shachaf: really? broken how?
08:49:16 <dsirenko_> Hello, I am trying to install `reactive`
08:49:54 <dsirenko_> The initial problem was
08:49:58 <dsirenko_> Could not find module `Control.Comonad'
08:50:00 <dsirenko_>     It is a member of the hidden package `comonad-1.1.1.6'.
08:50:17 <dsirenko_> then I edited reactive.cabal and rerun cabal install
08:50:19 <edwardk> you probably need a more modern version of comonad
08:50:35 <dsirenko_> That's what cabal provides, unfortunately
08:50:55 <edwardk> oh wow. reactive still uses category-extras
08:51:07 <booski> Cale: is it ok, that there is no any function to check permutation is it odd or even?
08:51:11 <dsirenko_> it uses a lot of exotic stuff, yes
08:51:14 <edwardk> i'll have to send a patch. (i thought i already did a year or so back)
08:51:30 <edwardk> i think conal has moved on to other things
08:51:39 <tufflax> Can I define several "names" in a where, on the same line? like "where m = n, k = s" or must I use newlines?
08:51:54 <geekosaur> tufflax, not with that syntax
08:52:03 <tufflax> ok, what is the syntax?
08:52:11 <geekosaur> if you really feel you must do that, you can use braces and semicolons.
08:52:25 <tufflax> example please
08:52:27 <elliott> dsirenko_: exotic here meaning out of date? :P
08:52:29 <edwardk> i'd offer to step up and maintain it, but its gpl
08:52:38 <geekosaur> but it's regarded as very ugly; must you really do it?
08:52:47 <tufflax> no, i'm just curious
08:52:50 <edwardk> otoh, i recall he wasn't too keen on the gpl
08:52:56 <geekosaur> but, since you like ugly code:  where { m = n; k = s }
08:53:10 <dsirenko_> Then it was necessary to add -XStandaloneDeriving and -XDeriveDataTypeable to the cabal file
08:53:15 <tufflax> geekosaur, thanks
08:53:24 <tufflax> where did i say i like ugly code? :p
08:53:42 <elliott> using {;} is usually ugly
08:53:44 <dsirenko_> but now it fails in the code
08:54:14 <edwardk> dsirenko_: anyways reactive doesn't stand a chance in hell of building as it urrently exists
08:54:17 <johnw> you don't always need the {}
08:54:22 <byorgey> yeah, I don't think reactive is really maintained right now
08:54:40 <geekosaur> (this is a general rule, layout translates to this according to well defined rules; see http://www.haskell.org/onlinereport/haskell2010/haskellch2.html#dx7-21001 for details
08:54:41 <johnw> i use "case x of foo -> bar; _ -> x" in several places; with newlines that would be ungainly
08:54:49 <edwardk> reactive-banana is the new hotness or somethig
08:55:07 <byorgey> yep, that and netwire
08:55:19 <byorgey> but apparently people still use yampa too.
08:55:39 <edwardk>  johnw : its looking better for & thee days. counting up actual up and down votes, & is at 10.2 and (|>) is at 2.1
08:55:44 <byorgey> lens : lenses :: ? : FRP
08:55:55 <johnw> edwardk: yes, I noticed the tone is trending very positively today
08:56:20 <elliott> edwardk: counting up and down votes where?
08:56:32 <edwardk> on the libraries list. yitz proposed adding & to Data.Function
08:56:38 <elliott> ah
08:56:38 <johnw> hmm.. netwire is based heavily on Arrows;  I wonder if that's a good choice
08:56:46 <sclv__> get nate silver on the case
08:57:15 <elliott> (|>) is an ugly operator
08:57:31 <fancyrat> its pretty like an airport
08:57:32 <elliott> I would sort of prefer (&) to be flip (.) though, then I might actually use it
08:57:54 <elliott> (&) isn't very compelling when you use ($) at most once per expression
08:58:04 <sclv__> I want a smooth operator ...
08:58:07 <johnw> elliott: it gets more compelling with lens :)
08:58:27 <edwardk> elliott: with lens you tend to use a lot of them
08:58:37 <elliott> yeah
08:58:51 <elliott> putting a very appealing symbol in Data.Function that is only useful for lens is a bit bleh though :P
08:58:52 <edwardk> . has very much the wrong fixity for long chains of lens mutations
08:59:01 <dsirenko_> It fails in FRP/Reactive/Internal/Serial.hs at line 31, saying that it expected: MVar () -> Serial Serial, found: MVar () -> IO a0 -> IO a0 though Serial is defined a few lines above
08:59:02 <edwardk> elliott: well, its useful for other dsls too
08:59:03 <sclv__> the coolest FRP implementations now are in ocaml and agda :-(
08:59:03 <elliott> i mean it is better than the status quo of course
08:59:17 <edwardk> and diagrams also uses something similar, etc.
08:59:20 <elliott> edwardk: well, flip (.) with ($) fixity would be reasonable
08:59:27 <edwardk> so it'd be nice to unify our vocabulary
08:59:53 <sclv__> i'm gradually going over to the idea that graphical FRP should have step semantics, either ultrametric style or temporal logic style
09:00:00 <edwardk> elliott: it still doesn't work to provide the nice chains though
09:00:14 <elliott> mm
09:00:16 <sclv__> and continuous FRP is really something else entirely, that we shouldn't think of as FRP at all
09:00:33 <edwardk> :t (>>>)
09:00:35 <lambdabot> Control.Category.Category cat => cat a b -> cat b c -> cat a c
09:00:37 <byorgey> I don't think diagrams would be able to use (&) as proposed, because of the precedence
09:00:39 <edwardk> that already exists
09:00:41 <byorgey> but I'm still generally in favor
09:00:44 <byorgey> at least, I'm not opposed
09:00:45 <elliott> sclv__: surely it'd be better to call discrete FRP something else instead, since continuous FRP is the "original"
09:00:50 <sclv__> the parametricity paper for frp is very cool, but i wish it was in agda
09:01:10 <edwardk> byorgey: i do need to figure out why your fixity needs are so different at some point
09:01:18 <sclv__> elliott: not so much... the "original" was applicative style with lists, which was naturally discrete
09:01:34 <sclv__> continuous time semantics were sort of shoved on top of it and never worked quite right
09:01:35 <byorgey> edwardk: it's because you want to be able to write things like    square 1 # fc red ||| circle 3 # lw 0.5
09:01:37 <edwardk> i need it to be lower than 4 otherwise i can't chain assignments
09:01:46 <byorgey> edwardk: usually # is used to apply small local modifications to things
09:02:02 <sclv__> i'm fine with "evented FRP" -- but we should recognize that that's the version that's had success in e.g. the .NET world and elsewhere
09:02:05 <elliott> sclv__: well, fair enough -- as "original" as a distinction between the two as been recognised, at least
09:02:15 <edwardk> byorgey: in lens i use ^& as a high fixity version of &
09:02:24 <sclv__> and the only version we can actually reason about uniformly and well
09:02:32 <edwardk> infixl 8 i think
09:02:41 <byorgey> edwardk: yes, infixl 8 is what (#) is
09:02:53 <dsirenko_> How can I install `reactive`?
09:03:07 <edwardk> dsirenko_: you frankly can't without more or less rewriting it to use modern haskel
09:03:10 <elliott> step 1. install an old compiler
09:03:24 <sclv__> at this point "reactive" is for thinking about, not using :-(
09:03:34 * shapr bops cheerfully
09:03:42 <byorgey> dsirenko_: why do you want to install it?
09:03:47 <byorgey> hi shapr!
09:03:50 <dsirenko_> so, is reactive-glut also for thinking? :)
09:04:01 <dsirenko_> is it useful nowaways?
09:04:03 <rwbarton> reactive-banana is nice
09:04:07 <dsirenko_> *nowadays
09:04:16 <Peaker> dsirenko_, I suggest avoiding "glut", "glfw-b" is much better
09:04:22 <edwardk> reactive-banana is a newer frp library that is actually maintained
09:04:25 <johnw> it always makes me think of a banana in a high-oxygen atmosphere though
09:04:29 <sclv__> I propose we just create a function named "appliedFrom"
09:04:40 <edwardk> sclv__: =P
09:04:41 <sclv__> and then say a `appliedFrom` b instead of a & b
09:04:49 * shapr hugs byorgey
09:05:03 <rwbarton> edwardk: btw your revisions or whatever it's called seems like a natural fit for FRP in some way
09:05:08 <rwbarton> have you considered this angle at all?
09:05:09 <sclv__> a `asAnArgumentTo` b, perhaps
09:05:13 <shapr> byorgey: Howdy! How's code? I'm enjoying those of your blog posts I have time to decipher :-)
09:05:22 <sclv__> with line breaks, it would be very readable!
09:05:23 <elliott> it's more a different concurrency approach to FRP isn't it
09:05:48 <edwardk> my current take on FRP is that the causaity is the problem. i've been spending a lot of time working on something that the hydra guys call 'functional hybrid modeling' rather than FRP lately
09:05:51 <rwbarton> maybe it just "is" FRP already, I dunno
09:05:57 <byorgey> shapr: excellent!  code is good, though there's never enough time to write all the code I want to write!
09:06:14 <edwardk> and the revisions stuff looks like a good way to recycle equation setup work across events
09:06:44 <sonOfRa> Is there a way to do something like optional parameters in functions? We are code for an assignment, and we want to find either ALL transactions, or transactions starting at a certain Date
09:06:51 <sclv__> all the continuous time FRP guys really only do actual recursive equations with e.g. euler integration or something.
09:07:00 <sonOfRa> Should we do this with two funtions, or is there a way to do one function with an optional parameter?
09:07:17 <sclv__> so yeah, i agree, we need a way to treat signals at a more mathy level to really utilize that style
09:07:22 <geekosaur> there is no optional parameter in the sense that some other languages have, where you omit it entirely
09:07:28 <edwardk> sonOfRa: make a data FooOptions = FooOptions { blah :: Int, bar :: Double } -- and then pass in a FooOptions as your options
09:07:39 <rwbarton> use a Maybe Date, perhaps
09:07:41 <geekosaur> there is a thing you can wrap a type in to indicate that it may or may not have a valye.
09:07:45 <edwardk> you can use Data.Default to make 'def' give you the options. and then you can do things like
09:07:49 <johnw> sonOfRa: there are "implicit parameters"
09:07:55 <rwbarton> egads
09:07:55 <sclv__> or if it is just this OR that, then
09:07:56 <edwardk> foo def { blah = 12 }
09:07:59 <geekosaur> ...since they said assignemnt I was trying to avoid naming Maybe out loud)
09:08:12 <rwbarton> yeah, fair enough
09:08:31 <edwardk> with lens you could make that foo . def $ blah ?~ 12  -- if blah was Maybe valued
09:08:39 <sonOfRa> Maybe types is probably what we could do, good idea, thanks
09:08:46 <edwardk> er foo $ def & blah ?~ 12 =)
09:08:56 <rwbarton> though unclear whether it is specifically a Haskell assignment, or perhaps an assignment in a databases (or whatever) class where sonOfRa chose to use Haskell
09:08:59 <shapr> How do I submit quotes to the HWN again?
09:09:15 <edwardk> shapr: there is a twitter account you can tweet to
09:09:18 <elliott> shapr: @remember
09:09:26 <shapr> I want to submit tibbe's quote from his G+ post: "I'm asking people to read the criticism, sit down and contemplate what can be improved, and then do something productive."
09:12:32 * hackagebot BiobaseXNA 0.6.3.0 - Efficient RNA/DNA representations  http://hackage.haskell.org/package/BiobaseXNA-0.6.3.0 (ChristianHoener)
09:15:11 <Attic> Is there a way to specify your .ghc directory location? Looks to me like it's hard coded to $HOME/.ghc in the ghc repo
09:15:51 <c_wraith> I think you're right, that it is hardcoded.
09:16:02 <rwbarton> you can specify where to look for package databases though
09:16:24 <c_wraith> Yeah, you can even specify multiple package databases
09:16:36 <rwbarton> http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/packages.html#ghc-package-path
09:16:38 <Attic> How do I go on doing that?
09:17:05 <Attic> Ahh thank you very much, exactly what I was looking for :)
09:17:32 * hackagebot BiobaseInfernal 0.7.0.0 - Infernal data structures and tools  http://hackage.haskell.org/package/BiobaseInfernal-0.7.0.0 (ChristianHoener)
09:20:46 <shapr> Are there any #haskell community plans for #hackfriday?
09:22:33 * hackagebot CMCompare 0.0.1.4 - Infernal covariance model comparison  http://hackage.haskell.org/package/CMCompare-0.0.1.4 (ChristianHoener)
09:23:11 <TBJoe> a question: if i remove something from a binary tree, i have to rebuild the tree completely ... isnt that terribly inefficient thus making haskell bad language for things like this? or are there some tricks to make this more efficient?
09:23:35 <shapr> TBJoe: You don't change the original tree, or modify the nodes, you only create a new tree that points to those nodes.
09:23:38 <rwbarton> you don't have to rebuild the tree completely
09:23:55 <rwbarton> you can reuse any subtree that doesn't contain the element you removed
09:24:04 <shapr> TBJoe: A list is actually a bunch of pointers to items, same for a binary tree.
09:24:09 <TBJoe> hm how do i reuse it then?
09:24:16 <drewr> b
09:24:19 <byorgey> nice, I hadn't heard about #hackfriday
09:24:21 <shapr> drewr: c ?
09:24:40 <drewr> sry, finger slip :-)
09:24:52 <rwbarton> TBJoe: if you've written code to remove an element from a binary tree then chances are you are already reusing those subtrees
09:25:08 <TBJoe> i have not done this yet :)
09:25:11 <TBJoe> was just wondering
09:25:20 <shapr> TBJoe: You can check to be certain by saving garbage collection stats and looking at the resulting graph.
09:25:32 <byorgey> TBJoe: the point is you don't have to do anything special.  Parts that aren't changed will get reused automatically.
09:25:41 <rwbarton> well, it's a bit tricky to answer "how" in this case because it is more effort not to do it
09:25:43 <TBJoe> is there a tutorial how to deal with the garbage collection?
09:26:07 <parcs`> what does that even mean
09:26:10 <TBJoe> id really like to see what some of my existings algorithms do :)
09:26:13 <Y_Less> "deal with" in what way?  Its automatic
09:26:19 <TBJoe> i mean how to look at it
09:26:25 <shapr> TBJoe: Mostly it just works, but if you want to see explicit gc usage...
09:26:28 * shapr digs around for the tools
09:26:51 <shapr> What was that recent reddit post where someone was showing gc usage in a tight fib loop?
09:27:13 <rwbarton> was that the threadscope example thing?
09:27:24 <shapr> Yah it was, but I thought it showed GC as well?
09:27:55 <shapr> Anyway, here's the post: http://www.reddit.com/tb/13cpm3
09:28:26 <shapr> TBJoe: I haven't used threadscope and tools like that, so other people might be able to suggest better tools, but I saw that yesterday and it looks like the same sort of thing.
09:28:28 <TBJoe> ok thx ill see what i can do with it :p probably nothing tho
09:28:41 <shapr> TBJoe: Well, ask more questions if you want to do more stuff :-)
09:28:53 <TBJoe> i will ;)
09:30:12 <rwbarton> there's that heap visualization stuff too
09:30:20 <shapr> oh that's a good idea..
09:30:21 <rwbarton> I hear it is fancier than the last time I looked at it years ago
09:30:41 <shapr> IS that system.vacuum.cairo?
09:30:55 <rwbarton> that's the version I remember
09:31:04 <rwbarton> that will show you a static snapshot
09:31:33 <rwbarton> it could work well here, showing the reuse between an old tree and a new tree with an insertion/deletion
09:31:38 <shapr> TBJoe: Right, check this out: http://hackage.haskell.org/package/vacuum-cairo
09:32:01 <shapr> Here's an explicit visualization of the string "hello" http://code.haskell.org/~dons/images/vacuum/hello.png
09:32:46 <sipa> ^ how about sharing the 'l's? :)
09:33:08 <shapr> TBJoe: So the easiest thing for you might be to put a tree and its modification in the same data structure, and then looking at any resulting sharing
09:33:59 <TBJoe> ok thx :)
09:34:09 <quicksilver> > let l = 'l' in 'h':'e':l:l:"o"
09:34:11 <lambdabot>   "hello"
09:34:30 <quicksilver> sipa: if you look carefully you can tell they're shared because they're exactly the same colour
09:34:47 <Iceland_jack> so that's what they mean by “structural sharing”
09:36:38 <sipa> quicksilver: oh, of course!
09:40:22 <byorgey> shapr, TBJoe: I recommend using ghc-vis instead of vacuum-cairo, it has a much slicker interactive interface
09:41:39 <TBJoe> ok i have never done something with any of these things yet so im a bit confused anyway :p started learning haskell (my first functional programming language) 3 days ago
09:45:57 <ag90> \part
09:54:04 <dmwit> ?src foldr
09:54:04 <lambdabot> foldr f z []     = z
09:54:05 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
10:03:35 <hayashi> argh, persistent is still failing to build
10:03:50 <hayashi> couldn't match expected type `(Int, Int)' with actual type `(# t0, t1 #)'
10:07:13 <hayashi> god damnit cabal =(
10:11:24 <vraid> hmm, what's the syntax to map with x = 2y + 1
10:11:48 <hayashi> gah
10:12:16 <hayashi> i have absolutely no idea how to progress here, since there is nothing on google for this issue i get the feeling it must be broken dependencies or soemthing
10:12:19 <hayashi> something
10:12:47 <dmwit> > map (\y -> 2 * y + 1) [1..5] -- vraid ?
10:12:49 <lambdabot>   [3,5,7,9,11]
10:12:56 <vraid> ah, i got it
10:13:10 <vraid> > map (+ (* 2) 1) [1..5]
10:13:13 <lambdabot>   [3,4,5,6,7]
10:13:17 <dmwit> hayashi: Open up the file and take a look at that line, maybe?
10:13:37 <Iceland_jack> > [ 2 * y + 1 | y <- [1..5] ]       -- this may be clearer?
10:13:38 <lambdabot>   [3,5,7,9,11]
10:13:47 <yitz> > map ((+ 1) . (* 2)) [1..5]
10:13:49 <vraid> > map (* (+ 1) 2) [1..5]
10:13:50 <lambdabot>   [3,5,7,9,11]
10:13:51 <lambdabot>   [3,6,9,12,15]
10:13:54 <mcstar> @hoogle liftIO
10:13:54 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
10:13:55 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
10:13:55 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
10:14:11 <dmwit> > map ((+1) . (*2)) [1..5] -- vraid, the pointfree version
10:14:13 <lambdabot>   [3,5,7,9,11]
10:14:14 <vraid> Iceland_jack: ah yes, i had forgotten about the | <- notation
10:14:21 <mcstar> did liftIO change it's residence?
10:14:27 <mcstar> its
10:14:29 <yitz> > [2 * y + 1 | y <- [1..5]]
10:14:31 <lambdabot>   [3,5,7,9,11]
10:14:40 <geekosaur> @index liftIO
10:14:41 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
10:14:54 <geekosaur> hm
10:14:57 <yitz> ah ok Iceland_jack :)
10:15:02 <mcstar> ah, ok, so i want control.monad.trans then
10:15:06 <mcstar> thank
10:15:08 <mcstar> s
10:16:08 <yitz> dmwit: Iceland_jack beat me on the comprehension, but i got you on the combinator
10:16:34 <hayashi> bluh, i don't even know what the problem is exactly due to having not got to unboxed tuples yet (i assume (# Foo, Bar #) is an unboxed tuple)
10:16:39 <vraid> i love that people are racing to answer questions in here
10:17:13 <yitz> vraid: this is a fun channel :)
10:17:13 <startling> vraid: heh
10:17:14 <vraid> so many other channels are like "uh.. rtfm?"
10:17:25 <mcstar> vraid: rtfm
10:17:25 <hayashi> i guess what i probably need to do is nuke the system packages and re-cabal everything to eliminate cabal mess as the problem
10:17:29 <startling> vraid, haskell is an oral culture
10:17:31 <hayashi> also best excuse to install ghc7.6
10:17:35 <startling> we don't have manuals.
10:18:38 <shergill> we have type signatures
10:18:39 <mcstar> yesod examples need more type annotations :(
10:19:42 <mcstar> what i dont like, is that when i make a mistake, ghci will remove my previously loaded imports
10:19:57 <mcstar> a bit annoying, that i cant do :t on things, until i import them
10:20:11 <startling> mcstar: that annoys me too
10:20:38 <startling> it'd be cool if it remember the last version that typechecked
10:20:54 <mcstar> yeah, but is that possible?
10:21:05 <startling> shouldn't it be?
10:21:16 <mcstar> i mean, would it be a hack, or some major addition
10:21:16 <elliott> you can just use the delay type errors thing right
10:21:26 <elliott> so modules still load in ghci even if they don't typecheck
10:21:36 <mcstar> oh, whats that?
10:21:51 <startling> mcstar, I imagine you'd just keep a reference to the previous environment before typechecking, and restore it if it failed'
10:22:05 <startling> but that's making some assumptions about ghci's structure
10:22:18 <rwbarton> elliott, that wouldn't help on parse failures or "not in scope" errors though
10:22:23 <elliott> mcstar: -fdefer-type-errors
10:22:25 <elliott> rwbarton: right
10:22:30 <elliott> rwbarton: -fdefer-syntax-errors
10:22:31 <lispy> Cale: I think it's a hint bug as some lambdabot commands work just fine with unicode
10:22:32 <rwbarton> though you can imagine -fdefer-not-in-scope-errors
10:22:36 <rwbarton> but not that one, heh
10:22:49 <lispy> Cale: Someone might be trying to utf8 things before/after ghc does it?
10:22:50 <rwbarton> -fmethod-missing
10:24:04 <hiptobecubic> Strong typing was awkward for me at first, but now I find that it's so hard to be safe in python. I miss them :(
10:24:25 <johnw> hiptobecubic: I call that mental progress
10:24:54 <johnw> hating on static typing is similar to me to people who think "real programmers don't use asserts"
10:25:16 <hiptobecubic> I feel like this program is just a bunch of glue and duct tape holding a bottle of nitroglycerine off of the ground.
10:25:20 <johnw> in my CL code I used so many dynamic type declarations that I might as well have been using static typing
10:25:28 <johnw> haha
10:25:58 <mcstar> idk, it is easier to fix type errors then logic errors
10:26:08 <mcstar> i understand some ppl dont prefer static typing
10:26:09 <johnw> dynamic typing is just one gigantic ADT anyway
10:26:14 <byorgey> @remember hiptobecubic I feel like this program is just a bunch of glue and duct tape holding a bottle of nitroglycerine off of the ground.
10:26:14 <lambdabot> Okay.
10:26:17 <sacundim> that's exactly my experience with kawa scheme in the JVM, johnw
10:26:18 <mcstar> than*
10:26:28 <sacundim> i put type declarations all over the place
10:26:33 <hiptobecubic> byorgey, oooo my first quote :)
10:26:58 <byorgey> =)
10:27:04 <johnw> sacundim: I know, right?  I mean, why *not* have the computer verify our faulty assumptions?  I don't get the benefit in side-stepping that
10:27:19 <johnw> for me, static typing was a relief, not a constraint
10:27:20 <mcstar> you can get money for that, thats why
10:27:23 <johnw> now I don't have to write as many asserts
10:27:29 <sacundim> then there's the fact that a ton of lisp programmer write code that implicitly uses types that are *crazy*
10:27:32 <johnw> of course, now I want dependent typing, but that's another story
10:27:44 <johnw> because I still have to assert boundary conditions :(
10:27:48 <sacundim> like "return the value that is mapped to the key, or an empty list"
10:28:12 <johnw> although, Haskell is starting to make me use Either and Maybe to create total functions instead
10:28:20 <hiptobecubic> johnw, that's actual what i'm doing now. although i mean boundary conditions in both the PDE sense and algorithmic sense.
10:28:30 <hiptobecubic> actually*
10:28:33 <sacundim> "this function returns the sum of the two numbers if you pass it two numbers, or otherwise it returns guy steele's secondborn"
10:28:39 <hiptobecubic> :D
10:28:49 <mcstar> elliott: thanks, it seems to work
10:28:49 <johnw> rather than asserting that X should never happen, I change the function so that "X happening" is an aspect of the return type
10:28:53 <startling> sacundim: heh
10:29:11 <companion_cube> johnw: that's called exceptions ;)
10:29:14 <johnw> ShitHappens a => a -> a
10:29:35 <johnw> companion_cube: yeah, I'm still feel unsure about exceptions in Haskell
10:29:36 <sacundim> then there's the crazy syntactic things, like (cond (test => proc))
10:29:43 <johnw> i think i'm gravitating towards them now
10:30:02 <vraid> feel free to tell me how horrible my code is http://ideone.com/mDBuQn
10:30:04 <johnw> they just add a level of indeterminacy that I was hoping to expel from my pure code
10:30:22 <johnw> vraid: my eyes were just burnt from my sockets
10:30:24 <arcatan> class ShitHappens a where fuuuuuu :: IO a -> a
10:30:50 <vraid> johnw: achievement unlocked.
10:31:20 <c_wraith> instance ShitHappens (IO a) where fuuuuuu = join
10:31:23 <johnw> vraid: how long does it take to generate 1,000,000 primes?
10:31:34 <vraid> johnw: too long for me to try in the interpreter
10:31:53 <simpson> vraid: Your code's not that bad.
10:32:00 <hpaste> johnw pasted “myprimes.hs” at http://hpaste.org/78017
10:32:06 <johnw> if you want to compare, that's my version
10:32:26 <c_wraith> arcatan: don't you hate it when there are inhabitants of your class that don't break the rules?
10:33:02 <vraid> johnw: they do different things though, mine creates a sieve to use
10:33:08 <johnw> i'm not using the sieve in order to generate an infinite list of primes
10:33:31 <hiptobecubic> :t join
10:33:33 <lambdabot> Monad m => m (m a) -> m a
10:33:36 <hiptobecubic> ah right
10:33:41 <arcatan> c_wraith: that hurts my anarchistic soul
10:33:56 <hayashi> ah, after 10,000 years i finally have yesod-platform installed
10:33:57 <hpaste> johnw pasted “sieve code” at http://hpaste.org/78018
10:34:01 <johnw> that's my sieve code
10:34:04 <vraid> i still generate an infinite list, but the divisible function starts out by checking the sieve
10:34:08 <johnw> using Data.Vector.Unboxed
10:34:29 <johnw> hiptobecubic: a common idiom is: join f x = f x x
10:34:43 <rwbarton> shachaf: what's the story with taking again?
10:34:45 <vraid> right, i don't understand that hah
10:35:18 <johnw> vraid: are you doing euler #3?
10:35:26 <hiptobecubic> :t ap
10:35:28 <lambdabot> Monad m => m (a -> b) -> m a -> m b
10:35:29 <vraid> no, not euler
10:35:42 <johnw> there are a few efficient primes libraries on hackage
10:35:50 <johnw> just fyi
10:36:04 <vraid> johnw: i made a C++ sieve programs a couple of nights ago, it checks 5 million numbers in one second
10:36:37 <dmwit> Igloo: ping
10:36:44 <johnw> i haven't really made much effort to optimize that code, since it provides the answer I was looking for in minimal time
10:36:49 <vraid> thought i'd try to remake it in haskell, since that's about the level of knowledge i'm at
10:37:11 <johnw> vraid: nice; porting working code to Haskell is a good way to learn
10:37:23 <johnw> that way you aren't both trying to learn Haskell, and trying to solve the problem anew
10:37:40 <johnw> then once you know Haskell, try to solve it again in a more Haskell-friendly way
10:37:53 <c_wraith> vraid: http://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf is an interesting and readable paper on implementing the sieve of erastosthenes in haskell
10:38:07 <c_wraith> *Eratosthenes
10:38:53 <mcstar> O'Neill, with two ls
10:39:15 <vraid> johnw: how does your sieve code work, exactly?
10:39:46 <johnw> i create a vector large enough to hold the sieve, then I repeatedly pass over it, setting to False the indices that can't be prime
10:39:53 <c_wraith> @hackage primes  is a convenient pre-packaging of her implementation idea
10:39:54 <lambdabot> http://hackage.haskell.org/package/primes  is a convenient pre-packaging of her implementation idea
10:40:13 <vraid> ah, ok
10:40:32 <c_wraith> the simple-but-not-space-efficient version. :)
10:40:34 <tufflax> what does the $ operator do? :p I've seen it a couple of times now but the book I'm reading has not gotten that far
10:40:39 <c_wraith> @src ($)
10:40:40 <lambdabot> f $ x = f x
10:40:46 <c_wraith> tufflax: it's really pretty boring
10:40:46 <startling> tufflax, nothing, but it changes precedence
10:40:50 <mcstar> ive got yesod working with authentication, and htmlizing a postgresql database, im so proud
10:40:51 <vraid> i only used the functional features
10:40:53 <startling> tufflax: a $ b c is a (b c)
10:41:00 <johnw> tufflax: it makes your code look expensive
10:41:06 <Iceland_jack> johnw: ca*ching*
10:41:12 <johnw> mcstar: congrats!
10:41:16 <mcstar> ty
10:41:27 <tufflax> ah, ok, thanks
10:41:58 <ion> The structure of a $ b c is more difficult to see at a glance than that of a (b c) IMO.
10:42:25 <johnw> ion: at least, until you are used to it
10:42:36 * hackagebot polimorf 0.5.0 - Working with the PoliMorf dictionary  http://hackage.haskell.org/package/polimorf-0.5.0 (JakubWaszczuk)
10:42:42 <ion> I’m used to it.
10:42:43 <startling> ion: I diasgree
10:42:43 <tufflax> and without it that would be the same as (a b) c?
10:42:46 <johnw> whenever I see $, I automatically start reading right-to-left
10:43:02 <startling> especially with deeply nested things
10:43:02 <solrize> tufflax, yeah, $ has very low precedence
10:43:05 <sacundim> as a long time lisp programmer, i have to agree with ion
10:43:10 <startling> tufflax: right, a b c is (a b) c
10:43:14 <solrize> it's useful when you want to compose several functions
10:43:28 <sacundim> MOAR PARENS
10:43:31 <solrize> f $ g $ h x y
10:43:35 <solrize> gets rid of soem parens
10:43:44 <ion> startling: I was only talking about a $ b c.
10:43:51 <johnw> also, f $ g $ h $ i $ j == f . g . h . i $ j
10:43:53 <sacundim> solrize, ic an'
10:43:56 <johnw> I find the latter easier to read
10:44:00 <sacundim> solrize, i can't read that
10:44:02 <solrize> yeah that too
10:44:10 <lispy> When I started Haksell a $ b c really bothered me. These days I don't even flinch or grimace.
10:44:11 <ion> The latter is also better for refactoring.
10:44:19 <lispy> I feel like if I can get used to it, anyone can
10:44:24 <DrChaos_> How  do you use the Win32 API bindings to create a GUI for Windows using its native API in Haskell?
10:44:27 * Iceland_jack tries to avoid ($) when possible..
10:44:28 <startling> ion: ah, alright
10:44:41 <lispy> DrChaos_: I'm not sure if it's complete enough for that.
10:44:42 <johnw> i like to use $ most of all when a multi-line lambda is the last argument to a function
10:44:48 <sacundim> johnw: complicatedthing j where complicatedthing = f . g . h . i
10:44:52 <startling> johnw: me too
10:45:00 <elliott> the only use for ($) is because (f . g . h) x is ugly imo
10:45:00 <lispy> DrChaos_: I would start with a "Hello, World" Win32 program in something like C and then translate that to Haskell.
10:45:01 <DrChaos_> I tried to do this a long time ago, but I never understood quite how to create a window and add a button
10:45:10 <solrize> yeah, like forM_ xs $ do { .... }
10:45:11 <DrChaos_> lispy, ok
10:45:11 <elliott> and separating every (f . g . h) out into its own definition is impractical
10:45:12 <johnw> or when I'm passing a monadic value, so my functino call is "when x $ do \n ..."
10:45:13 <ion> I don’t find (f . g . h) x ugly at all.
10:45:17 <elliott> oh, and monadic control structures too
10:45:23 <startling> johnw: sometimes flip fmap is really useful for this
10:45:37 <ion> I still want “foo \x → …” and “foo do …”
10:45:39 <lispy> DrChaos_: Sadly, almost no one has ever done this with haskell so you won't find tutorials or docs :(
10:45:40 <elliott> ion: even if x is itself a long expression?
10:46:21 <ion> elliott: That may be different, sure. Again, i was only talking about the specific example.
10:46:26 <lispy> DrChaos_: Moreover, you probably want something like the API used by .NET, but getting reliable access to all that COM stuff is a road to madness (I know from experience).
10:46:29 <c_wraith> ion: (f . g . h) x bugs me because it's usually long after I've written f . g . h that I want to apply it to something.  And at that point, moving the cursor back to add an open paren is really annoying
10:46:44 <rwbarton> yep
10:46:46 <elliott> admittedly, if x has function applications then you can put them into (f . g . h)
10:46:55 <elliott> c_wraith++
10:46:59 <rwbarton> same can happen even with f $ ..., then the ... is "g $ x"
10:47:15 <elliott> clearly "x & f . g . h"
10:47:18 <rwbarton> particularly if f and g do not combine to form a unit that makes sense
10:47:22 <DrChaos_> lispy, why is getting access to all that COM stuff madness?
10:47:22 <ion> c_wraith: Moving the cursor back and adding a ( is usually something like 0f=WA( <esc>
10:47:32 <DrChaos_> is it hard to request a handle?
10:47:39 <c_wraith> ion: that's a lot more keys than $
10:48:20 <ion> Whoops, s/A/i/
10:48:47 <johnw> i was starting to feel like we hadn't had the $ in too long a time; now all is right with the world again
10:48:54 <johnw> s/$/$ debate
10:48:55 <lispy> DrChaos_: I don't know if it's still maintained, but there is a Haskell library for doing COM. I never could tell if it was buggy or if my code was buggy. There is a lot of low level fetching of handles, querying handles, and then downcasting. The .NET toolchain nows how to automate all this so .NET programmers are not aware of it.
10:49:14 <lispy> DrChaos_: I think the library was called hdirect
10:49:33 <lispy> DrChaos_: I found it via the Haskell plugin for Visual Studio.
10:49:39 <b__> can one pattern match on a Map to bind the elms?
10:49:44 <b__> elems*
10:49:55 <lispy> b__: the constructor is not exported
10:50:03 <lispy> b__: there is an elems function
10:50:12 <b__> yeah =]
10:50:26 <johnw> @remember xplat Some software is worth trying; most is just plain trying.
10:50:27 <lambdabot> I will never forget.
10:50:57 <FireFly> ion: T=a(<Esc>
10:51:52 <ion> firefly: Depends on how many =s there are on the line. :-) But sure, that, if there’s just one in the hypothetical example of going to the “foo = ” in the beginning of a line.
10:52:00 <FireFly> Oh, true
10:52:31 <alex-shpilkin> b__: if you need this badly, {-# LANGUAGE ViewPatterns #-} may be for you. (although that is still just sugar for the deconstruction function.)
10:52:35 <lispy> DrChaos_: What most Haskellers do when they want to build a gui is they reach for the wxHaskell or GTK bindings.
10:53:13 <b__> alex-shpilkin, thank you. I don't need it badly but I will look it up anyway =]
10:54:35 <elliott> is there a shortening of ((== 0) . (`mod` n)) anywhere?
10:54:42 <DrChaos_> lispy, wxWidgets has a binding for native Win32 GUI APIs?
10:54:45 <elliott> e.g. divides n = (== 0) . (`mod` n)
10:54:59 <ion> elliott: I don’t remember seeing one.
10:55:20 <lispy> DrChaos_: That's the way wx works. They layer their API on top of the native stuff on each platform.
10:55:44 <Nisstyre> elliott: well, if you can find some way to check if there's no remainder using fewer characters...
10:56:02 <elliott> ion: me too :P
10:56:04 <elliott> Nisstyre: hm?
10:56:04 <johnw> elliott: if you install the "predicates" libraries, you can say: (`mod` n) `is` (== 0) :)
10:56:19 <ion> johnw: How useful.
10:56:24 <Nisstyre> elliott: I can't think of a shorter way of doing it
10:56:32 <johnw> well, it looks better when you say length `is` (>3) and such
10:56:46 <johnw> and it comes with `isn't` too
10:56:56 <Guest9903> awesome...
10:56:58 <johnw> oh, and `equals`
10:57:02 <Nisstyre> johnw: I think he wants an even shorter version than the one he posted
10:57:02 <johnw> (`mod` n) `equals` 0
10:57:06 <Nisstyre> which I think is impossible
10:57:11 <elliott> Nisstyre: well I don't need a shorter way of doing it... just wondering if that operation or a similar one is defined anywhere semi-standard
10:57:22 <Nisstyre> elliott: oh, not that I know of
10:57:38 <elliott> I can think of a shorter version though
10:57:39 <Nisstyre> elliott: maybe someone should write a discrete math library
10:57:45 <elliott> (==0).(`mod`n)
11:01:25 <TBJoe> how can i add an integer to a string?
11:01:42 <TBJoe> like "something" ++ 5
11:01:46 <ion> ++ show 5
11:01:54 <TBJoe> ah right that makes sense thx :D
11:02:05 <ion> show :: Integer -> String
11:02:07 <ion> @type show
11:02:08 <lambdabot> Show a => a -> String
11:02:56 <Gurragchaa> how would I @src the implementation of fmap used in Lists or other specific Functors?
11:03:13 <ion> @src Functor []
11:03:14 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
11:03:16 <ion> hmm
11:03:39 <ion> @src [] fmap
11:03:40 <lambdabot> fmap = map
11:04:01 <Gurragchaa> thank you
11:05:04 <Guest9903> How do I get the list of available functions in my haskell toplevel?
11:05:14 <lispy> Guest9903: :browse ?
11:05:37 <Guest9903> Hm, thanks
11:05:46 <Gurragchaa> in the line ` fmap f (Just a)      = Just (f a) `, does that mean that it's taking the function f evaluated with the argument a and "wrapping" that in a Just?
11:06:14 <lispy> Gurragchaa: yeah
11:06:23 <lispy> Gurragchaa: it's moving the 'f' inside the Maybe
11:06:28 <lispy> Gurragchaa: sometimes we call this 'lifting'
11:06:36 <Gurragchaa> oh!
11:06:41 <Gurragchaa> that's what happens in map too!
11:06:54 <lispy> :)
11:08:55 <vraid> c_wraith: i looked at the paper, my algorithm should be similar, although i'm not the best at telling what's efficient haskell at this point
11:10:13 <lispy> vraid: it's all about profiling: http://book.realworldhaskell.org/read/profiling-and-optimization.html
11:10:26 <lispy> vraid: figure out the hot spots in your code and then ask here :)
11:11:05 <vraid> i guess hotspots can differ between compiled and interpreted code?
11:11:39 <lispy> ghci typically doesn't do optimizations but I think compiling defaults to -O1
11:11:49 <lispy> So yes, that can make a difference in hot spots
11:12:46 <vraid> got to install ghc then
11:13:04 <neutrino> you have ghci without ghc?
11:13:10 <neutrino> how did you manage that
11:13:48 <vraid> oh, i don't know, maybe i have ghc
11:14:06 <lispy> vraid: did you install the haskell platform?
11:14:22 <monochrom> w00t, gtk2hs 0.12.4
11:14:41 <vraid> well what do you know, there it is
11:15:35 <monochrom> people know 100% what's on the web outside, and 0% what's on their own disks inside
11:15:36 <vraid> now, which one of these do i run on windows?
11:15:40 <parcs`> :t on flip
11:15:42 <lambdabot>     Occurs check: cannot construct the infinite type:
11:15:42 <lambdabot>       b0 = a0 -> b0 -> c0
11:15:42 <lambdabot>     Expected type: (a0 -> b0 -> c0) -> (a0 -> b0 -> c0) -> a0 -> c0
11:15:56 <monochrom> I guess that defines "extrovert"
11:17:47 <monochrom> interesting. "Automatic memory management (unlike some other C/C++ GUI libraries, Gtk+ provides proper support for garbage-collected languages)"  Next time someone asks "why gtk+ instead of wx", perhaps that could be part of the answer?
11:17:50 <lispy> vraid: Are you using as shell on windows (cmd.exe, mingw shell, or perhaps git bash shell?)
11:18:23 <vraid> hmm, i should have the mingw shell
11:18:31 <monochrom> however, I don't see what needs to be done specially for a C lib to support garbage-collected languages
11:18:38 <lispy> vraid: then use ghcii.sh to run ghci and invoke ghc with "ghc"
11:19:04 <lispy> vraid: As in, it should all just work but you have to use a special wrapper for ghci because of the way Ctrl+c works on windows
11:19:20 <dmwit> monochrom: I believe gtk has its own reference counting, and supports calling a user-supplied function when the reference count drops to zero.
11:19:44 <TBJoe> hm i got the problem that i cant print out my binary tree data type in a neat way and the Data.Tree.drawTree doesn't help me because 1. i want to keep my tree Datatype and 2. i am too unexperienced to make changes so it works with my datatype ... could someone help me out? how can i easily visualize this data type? data Tree a =  Empty | Node (Tree a) a (Tree a)
11:19:48 <monochrom> oh! I see. no wonder! neat.
11:20:10 <lispy> I don't find gtk interesting, honestly. It's a huge pain to install and then it doesn't look native on windows (despite the claims of a theme) and on OSX it requires X11 unless you really work hard.
11:20:23 <hiptobecubic> TBJoe, get some paper
11:20:30 <hiptobecubic> (really)
11:20:49 <TBJoe> yeah that always works but its the thing i want to avoid :p
11:21:02 <hiptobecubic> imagine some paper?
11:21:07 <dmwit> drawTree . toStandardLibraryTree
11:21:17 * Eduard_Munteanu wants a gtk3hs
11:22:12 <DrChaos_> Eduard_Munteanu, one of the users of the gtk2-hs mailing list is working on a patch
11:22:12 <TBJoe> dmwit what do you mean?
11:22:29 <monochrom> when on Windows, I already use iTunes... I have long ignored native look, does not exist.
11:22:29 <DrChaos_> there will be a gtk3hs soon enough
11:22:31 <TBJoe> maybe ill just try to break up the (Node (Node (Node (Node ...)))) structure in another programming language that i can handle better
11:22:34 <dmwit> TBJoe: Write a function that converts your trees into Data.Tree.Tree's.
11:22:39 <Eduard_Munteanu> Hm, nice.
11:22:41 <dmwit> It's easy to write, and then you can use drawTree.
11:23:00 <TBJoe> hmm sounds like a good idea if i can handle it
11:23:33 <dmwit> It'll probably have to go to a Forest instead, but... meh. You'll work it out, I'm sure. =)
11:23:48 <monochrom> and when on Ubuntu and gnome, I also use some Qt and wx programs. here again, native look no longer exists.
11:23:53 <lispy> TBJoe: generating graphviz files is remarkably easy
11:23:59 <lispy> TBJoe: that's what I would recommend
11:24:10 <romildo> @pl \x y -> Dec (SeqDec x y)
11:24:11 <lambdabot> (Dec .) . SeqDec
11:24:14 <TBJoe> @lispy: and how does that work?
11:24:15 <lambdabot> Unknown command, try @list
11:24:40 <lispy> TBJoe: https://en.wikipedia.org/wiki/DOT_language
11:24:50 <TBJoe> @dmwit: could you give me an example of a standard-library tree? im dont understand how i have to build it after reading the definition
11:24:51 <lambdabot> Unknown command, try @list
11:24:56 <dmwit> ?hackage graphviz
11:24:56 <lambdabot> http://hackage.haskell.org/package/graphviz
11:25:04 <dmwit> TBJoe: Oh, sure!
11:25:13 <mornfall> TBJoe: Please drop those @, it's not twitter here and lambdabot is kinda sick... :-P
11:25:16 <dmwit> > Node 3 [Node 4 [], Node 5 []]
11:25:18 <lambdabot>   Node {rootLabel = 3, subForest = [Node {rootLabel = 4, subForest = []},Node...
11:25:22 <monochrom> I have long stopped caring about "look". hairsplitting bikeshed colour. just give me tidyness, I don't care whether corners are pointy or round
11:25:25 <lispy> TBJoe: I did this recently for some graphs at work, but I can't share the code right now because it was for work
11:25:32 <TBJoe> @mornfall ok sry this is my last one :D
11:25:33 <lambdabot> Unknown command, try @list
11:26:27 <lispy> I don't know if I would bother with the graphviz package
11:26:33 <TBJoe> thx dmwit ill try what i can do with this :) but ill definitely give this dot language thing a look too but id rather not learn a completely new thing now
11:26:40 <lispy> I just wrote a string to stdout
11:27:39 <TBJoe> hmm my data type's name is "Tree" so is the one in the standard library :(
11:28:01 <dmwit> import qualified Data.Tree as T
11:28:12 <TBJoe> thx :)
11:29:09 <johnw> the graphviz library wants to reinstall almost every package I have installed
11:29:16 <johnw> (beacuse it wants to downgrade bytestring)
11:29:40 <TBJoe> hm but the standard tree type also uses "Node"
11:29:51 <monochrom> perhaps manually change its depends: bounds
11:30:05 <johnw> yeah
11:30:33 <monochrom> eh? doesn't downgrade bytestring on ghc 7.4.2
11:30:42 <johnw> i'm using 7.6
11:30:51 <dmwit> TBJoe: ...that's why you import qualified as T, no?
11:30:55 <johnw> 7.4 is so right now
11:31:23 <TBJoe> ah ok i have to write T.Node then?
11:31:25 <monochrom> aside: this is also why the Haskell Platform people decided to stay with 7.4
11:31:32 * dmwit nods at TBJoe
11:31:38 <TBJoe> never used import before
11:31:38 <johnw> yep
11:31:44 <TBJoe> ok thx now i should be able to do this :)
11:31:54 <johnw> being on 7.6 is just a box o' fun
11:31:59 <monochrom> in fact, they say, not until April 2013 will they adopt 7.6
11:32:20 <johnw> monochrom: I'd call that reasonable bordering on wise
11:32:27 <monochrom> heh
11:33:21 <romildo> @pl \x y -> f (g x y)
11:33:21 <lambdabot> (f .) . g
11:33:21 <monochrom> but yeah, rushing to 7.6 will confuse a lot of people who don't want to investigate cabal problems
11:35:02 <johnw> ypeah, just fixing the boundary condition cleared it all up
11:35:12 <johnw> i'll submit a patch
11:35:23 <johnw> (this is really why I'm on 7.6 anyway)
11:37:19 <vraid> lispy: i keep getting "not in scope: `ghc`"
11:37:52 <sw17ch> @hackage cmdargs
11:37:53 <lambdabot> http://hackage.haskell.org/package/cmdargs
11:38:00 <sw17ch> ^^ that package is so awesome
11:38:15 <bgamari> @hackage optparse-applicative
11:38:16 <lambdabot> http://hackage.haskell.org/package/optparse-applicative
11:38:28 <bgamari> ^^ that package is awesome-r (IMHO)
11:38:56 <Nisstyre> @pl \f -> \x y -> f y x
11:38:57 <lambdabot> flip
11:39:09 <startling> hehe
11:39:32 <Nisstyre> @pl \f -> \(x,y) -> f x y
11:39:32 <lambdabot> (`ap` snd) . (. fst)
11:39:36 <sw17ch> I was just happy to find out that the state of option parsing has come a LONG way since I last attempted it in Haskell.
11:39:45 <vraid> lispy: okay, i'm getting somewhere, i need to make a main function now
11:39:56 <startling> yeah, that optparse-applicative looks really nice.
11:40:26 * fmap waits for optparse-lens
11:40:34 <johnw> bgamari: nice, thanks for the link
11:40:36 <TBJoe> hmm and how das Tree.drawTree work? if i do "T.drawTree (T.Node 3 [T.Node 4 [], T.Node 5 []])" it doesnt work even though the argument is a valid tree
11:40:44 <bgamari> johnw, no worries.
11:41:14 <rwbarton> "doesn't work?"
11:41:16 <bgamari> I was always far less than satisfied with cmdargs. Using Applicative for option parsing just feels very natural
11:41:38 <ion> nisstyre: uncurry
11:42:15 <startling> :t (`ap` snd) . (. fst)
11:42:17 <lambdabot> (a1 -> a -> b) -> (a1, a) -> b
11:42:35 <johnw> bgamari: I agree; cmdargs "data driven" approach feels constrictive at times, and definitely "unpluggable"
11:42:46 <johnw> with applicatives, I can always insert my own stuff
11:43:14 <johnw> i like that you can specify arg intrepretation with a type, like Parser Text
11:43:15 * elliott wishes there was applicative record notation
11:43:19 <hpaste> TBJoe pasted “drawTree error” at http://hpaste.org/78019
11:43:24 <elliott> would be especially nice for something like Applicative option parsing
11:43:27 <johnw> i never could get cmdargs to properly handle Filesystem.Path.FilePath arguments
11:43:40 <johnw> elliott: isn't that lens? :)
11:44:13 <elliott> well, no... you can't safely "initialise" a record with lens
11:44:40 <elliott> you can set fields of Rec{}, but there's no warning if you miss some
11:44:47 <johnw> ah
11:44:50 <elliott> in fact you'll just get a warning that they're all uninitialised
11:45:05 <rwbarton> TBJoe: apparently drawTree is for trees of Strings
11:45:11 <startling> elliott: can't you just write a default?
11:45:29 <elliott> startling: what about when there isn't a default? non-optional arguments etc.
11:45:40 <elliott> and you can set a default but then fail to override it with the option later in error
11:45:44 <startling> ellio, Maybe ?
11:45:50 <TBJoe> rwbarton: so i have to write "show" before every int i write in the tree?
11:46:00 <elliott> then you have to handle Nothing... the whole point is that there is no sensible default here
11:46:01 <rwbarton> you could use "fmap show" on the tree
11:46:02 <elliott> what you actually want is:
11:46:13 <elliott> (\a b c -> Record {myField=a,myField2=b,myField3=c}) <$> foo <*> bar <*> baz
11:46:28 <elliott> and you can imagine the syntax Record { myField <- foo, myField2 <- bar, myField3 <- baz } for this
11:48:20 <TBJoe> rwbarton: i can use "fmap show [1, 2]" but i cant use "fmap show <someTreeHere>"
11:48:36 <johnw> TBJoe: you need to write a Functor instance for your tree?
11:48:44 <ion> or derive one
11:49:10 <TBJoe> and how can i do that?
11:49:28 <johnw> {-# LANGUAGE DeriveFunctor #-}
11:49:30 <rwbarton> surely Data.Tree.Tree is an instance of Functor?
11:49:31 <ion> {-# LANGUAGE DeriveFunctor #-} data MyTree a = … deriving (…, Functor)
11:49:31 <johnw> then, "deriving Functor"
11:50:17 <startling> noooo, quadratic time
11:50:24 <TBJoe> mh well ive never heard of these things why does it have to be that complicated to draw a tree? :D
11:50:42 <johnw> is it that much simpler in other languages?
11:51:12 <rwbarton> > Node 1 []
11:51:13 <startling> :t traverse undefined (undefined :: Data.Tree.Tree)
11:51:13 <ion> Define draw a tree. You can just print/show the value.
11:51:14 <lambdabot>   Node {rootLabel = 1, subForest = []}
11:51:15 <lambdabot>     Expecting one more argument to `Tree'
11:51:15 <lambdabot>     In an expression type signature: Tree
11:51:15 <lambdabot>     In the second argument of `traverse', namely `(undefined :: Tree)'
11:51:15 <TBJoe> dont think so but here i even have a predefined drawTree function but i cant use it :p
11:51:18 <rwbarton> > fmap show (Node 1 [])
11:51:21 <lambdabot>   Node {rootLabel = "1", subForest = []}
11:51:26 <rwbarton> TBJoe: works for me
11:51:29 <startling> :t traverse undefined (undefined :: Data.Tree.Tree a)
11:51:31 <lambdabot> Applicative f => f (Tree b)
11:51:43 <startling> you can do it trivially with a traversal. 8)
11:52:35 <rwbarton> > drawTree $ fmap show (Node 1 [])
11:52:37 <lambdabot>   "1\n"
11:52:42 <TBJoe> oh i guess i had a typing error or something
11:52:47 <rwbarton> > drawTree $ fmap show (Node 1 [Node 2 [], Node 3 []])
11:52:49 <lambdabot>   "1\n|\n+- 2\n|\n`- 3\n"
11:52:56 <rwbarton> > text . drawTree $ fmap show (Node 1 [Node 2 [], Node 3 []])
11:52:59 <lambdabot>   1
11:52:59 <lambdabot>  |
11:52:59 <lambdabot>  +- 2
11:52:59 <lambdabot>  |
11:52:59 <lambdabot>  `- 3
11:53:10 <Electro_Statik> hello
11:53:43 <startling> :t \fn -> itraverse fn (undefined :: Data.Tree.Tree a)
11:53:45 <lambdabot> (Applicative f, TraversableWithIndex i Tree) => (i -> a -> f b) -> f (Tree b)
11:58:57 <mapf> @src text
11:58:58 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
11:59:04 <mapf> :t text
11:59:06 <lambdabot> String -> Doc
12:06:43 <TBJoe> okay guys thank you i can convert my trees and draw them now :)
12:11:57 <crdueck> why does the Functor instance of (,) only apply the function to the second part of the tuple?
12:12:03 <crdueck> > fmap (+1) (1,1)
12:12:05 <lambdabot>   (1,2)
12:12:23 <atriq> > fmap (+ 1) ("hello", 3)
12:12:25 <lambdabot>   ("hello",4)
12:12:31 <atriq> How would it do both for that?
12:12:36 <felix2> because it's not an instance of (,)
12:12:44 <felix2> it's an instance for (,) e
12:13:03 <felix2> which is different because it means that the type of the first part is fixed
12:13:37 <bos> does anyone know how to debug code using GHC.Generics?
12:14:12 <crdueck> felix2: right, (,) has kind * -> * -> *
12:18:32 <deus_rex> if I use deriving to make a class instance, can I still override certain things (like, showList for Show)
12:19:33 <elliott> deus_rex: no
12:19:46 <elliott> deus_rex: you shouldn't really override showList though
12:20:15 <elliott> at least not usually
12:20:45 <deus_rex> hm
12:21:34 <donri> crdueck: data Pair a = Pair a a deriving Functor -- ;)
12:21:49 <deus_rex> well, I have a data Base = Adenine | Guanine | Thymine | Cytosine | Uracil
12:22:21 <deus_rex> it'd be nice for [Base] to look like "GATTACA" instead of [Guanine, Adenine, Thymine ...]
12:22:40 <johnw> > over both (+1) (1,1)
12:22:42 <lambdabot>   (2,2)
12:23:23 <donri> deus_rex: you could use generics for "show" and custom implementation for showList, maybe
12:23:27 <Iceland_jack> deus_rex: you could wrap [Base] with a type constructor
12:23:49 <johnw> crdueck: ^^
12:24:04 <donri> > (1,1) % both ~+ 1
12:24:06 <lambdabot>   Not in scope: `~+'
12:24:06 <lambdabot>  Perhaps you meant one of these:
12:24:06 <lambdabot>    `++' (line 118), `P....
12:24:09 <capisce> map works with functions taking one parameter, zipWith with functions taking two parameters, is there any for functions taking three parameters ?
12:24:13 <donri> > (1,1) % both +~ 1
12:24:15 <lambdabot>   (2,2)
12:24:22 <hpaste> bos pasted “Unhappy generics” at http://hpaste.org/78020
12:24:28 <crdueck> johnw: ahh, i was trying to find something like that in Control.Lens but i'm not too familiar with the library yet
12:24:40 <donri> :t both
12:24:42 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
12:25:11 <deus_rex> capisce: zipWith3
12:25:27 <mpiechotka> @pl \n -> 0:1:zipWith (+) n (tail n)
12:25:27 <lambdabot> (0 :) . (1 :) . ap (zipWith (+)) tail
12:25:47 <capisce> deus_rex: ah, ok
12:26:04 <deus_rex> or you can use the ZipList applicative ;)
12:26:04 <mpiechotka> @hoogle ap
12:26:05 <lambdabot> Prelude appendFile :: FilePath -> String -> IO ()
12:26:05 <lambdabot> System.IO appendFile :: FilePath -> String -> IO ()
12:26:05 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:26:39 <donri> bos: why unhappy? not sure that's the most efficient implementation though, e.g. cereal does some trickery to make :+: efficient
12:26:40 <deus_rex> @let multThree a b c = a * b * c
12:26:42 <lambdabot>  Defined.
12:26:45 <Ferdirand> @type \f g x y z -> zipWith f x (zipWith g y z)
12:26:46 <lambdabot> (a -> b -> c) -> (a1 -> b1 -> b) -> [a] -> [a1] -> [b1] -> [c]
12:26:55 <edwardk> bos: unhappy with the amount of code?
12:27:03 <Ferdirand> ugly but works
12:27:05 <deus_rex> > getZipList $ multTree <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9]
12:27:07 <lambdabot>   Not in scope: `multTree'
12:27:07 <lambdabot>  Perhaps you meant `multThree' (line 1)
12:27:11 <deus_rex> > getZipList $ multThree <$> ZipList [1,2,3] <*> ZipList [4,5,6] <*> ZipList [7,8,9]
12:27:13 <lambdabot>   [28,80,162]
12:27:13 <capisce> Ferdirand: right
12:27:36 <donri> bos: https://github.com/GaloisInc/cereal/blob/master/src/Data/Serialize.hs#L468
12:27:49 <capisce> I see that with template haskell you can make a generalized zipWith that takes as parameter the number of arguments/lists it should accept
12:28:10 <capisce> http://www.haskell.org/haskellwiki/Template_Haskell#zipWithN
12:28:34 <bos> donri: dcoutts just pointed me at this in #ghc, thanks :-)
12:30:44 <capisce> how common is it to use template haskell in practice?
12:31:26 <deus_rex> I don't know anything about template haskell, but the ZipList applicative seems pretty elegant to me
12:32:34 <startling> capisce, it's not uncommon, especially for deriveX functions.
12:34:13 <donri> generics is arguably nicer for instance derivation
12:38:09 <ziarkaen> I am asked in a homework question to define a function analogous to "fold", but on the Maybe datatype, rather than List.  Does anyone have an idea what is meant by this?  I don't see how fold can be extended to a datatype holding only 0 or 1 separate elements...
12:38:41 <elliott> ziarkaen: well, foldr works on lists of zero and one elements, right?
12:39:29 <elliott> you can think of the trick foldr uses -- where it replaces the constructors ((:) and []) with the arguments it gets
12:39:35 <ziarkaen> elliott, True.
12:42:10 <deus_rex> (:) is the happiest operator
12:42:17 <ion> ):(
12:42:38 <alex-shpilkin> properly for Haskell, the saddest operator yields a compile error =)
12:42:50 <ion> (foo):(bar)
12:43:09 <alex-shpilkin> now it’s redundant
12:43:24 <ion> No wonder it’s sad./
12:52:05 <efie> I tried to install SourceGraph, but I get "cabal install SourceGraph Resolving dependencies... cabal: cannot configure Cabal-1.14.0. It requires containers >=0.1 && <0.5". However, .cabal/lib/ contains containers-0.4.2.1 as well as containers-0.5.1.0. what do I have to do?
12:53:30 <dcoutts> efie: .cabal/lib/ contains stuff for all versions of ghc you have
12:53:50 <dcoutts> efie: use ghc-pkg list, you probably only have containers-0.5.1.0 registered for the version of ghc you're currently using
12:54:35 <plhk> can someone point me to code example using persistent? yesod site looks dated
12:54:49 <dcoutts> efie: looks like SourceGraph needs an old Cabal, and that older Cabal only builds with older ghc, but you might be able to get the dependencies to install with your newer ghc.
13:00:51 <dinox>  /w 6
13:02:55 <mpiechotka> @pl \x -> (x, x)
13:02:56 <lambdabot> join (,)
13:03:09 <efie> dcoutts: it says "cabal: cannot configure Cabal-1.14.0", but cabal install Cabal-1.14.0 gives that no packages need to be installed
13:03:41 <rwbarton> dcoutts: If I specify e.g. "ghc-options: -Wall" in my .cabal file, does that mean it will build with -Wall -O by default?
13:04:32 <DrChaos|> hello
13:05:02 <atriq> Hello, DrChaos_
13:05:10 <atriq> Or DrChaos|, rather
13:05:21 <atriq> We appear to have two chaotic doctors
13:05:27 <DrChaos|> how do you do hello world in wxwidgets for haskell?
13:06:47 <DrChaos|> no, DrChaos_ is my home connection. This one is from my mom's bb
13:07:31 <tomeo> if I import Data.Numbers.Primes, I should be able to do :t primes and not get "not in scope" right?
13:08:03 <startling> :t Data.Numbers.Primes.primes
13:08:04 <lambdabot> Couldn't find qualified module.
13:08:13 <startling> tomeo, how did you import it?
13:08:20 <k00mi> works for me tomeo
13:08:29 <tomeo> startling: I tried import Data.Numbers.Primes in ghci which didn't complain
13:08:47 <startling> tomeo: weird. maybe you have an outdated version?
13:08:57 <tomeo> startling: 7.4.1
13:09:11 <startling> tomeo, of Data.Numbers.Primes I mean
13:09:31 <tomeo> startling: any quick way to check?
13:09:46 <startling> tomeo, ghc-pkg list | grep primes
13:10:38 <tomeo> startling: found nothing
13:10:49 <startling> tomeo, do you have it installed?
13:10:51 <NoICE> hi guys again :)
13:11:18 <tomeo> startling: oh! I haven't explicitly installed it. just downloaded osx package of haskell
13:11:35 <tomeo> thought it was part of haskell
13:11:47 <startling> tomeo: I bet this is snow leopard and you installed the 64-bit version
13:11:56 <atriq> tomeo, "cabal install primes"
13:12:05 <tomeo> startling: nah, it said to use the 32bit so I did and Im on mountain lion
13:12:12 <atriq> Or probably "cabal install primes --enable-documentation"
13:12:22 <startling> tomeo: huh. import Data.Numbers.Primes should have failed right away
13:12:30 <rwbarton> yeah... slow down here :)
13:12:36 <rwbarton> can you hpaste your whole ghci session
13:13:12 <rwbarton> and the output of "ghc-pkg find-module Data.Numbers.Primes"
13:13:23 <tomeo> startling: thanks, it works now. atriq thanks for the cabal :)
13:13:47 <rwbarton> grr
13:13:54 <atriq> tomeo, no problem!
13:13:57 <tomeo> sorry rwbarton, but I was already installing when you wrote
13:14:00 <elliott> tomeo: your GHC could still be broken...
13:14:14 <rwbarton> it'll be okay
13:14:19 <tomeo> any way to check now that I already have it installed?
13:14:19 <rwbarton> i'll just pretend i never heard anything about this
13:14:20 <elliott> does "import Asdf" complain?
13:14:36 <tomeo> elliott: nope
13:14:38 <rwbarton> probably just random typos throughout, i will tell myself
13:14:50 <elliott> tomeo: you should hpaste your whole ghci session for rwbarton, then!
13:15:03 <rwbarton> maybe he really typed "import Control.Monad.State" by accident
13:15:08 <NoICE> I have question which I can't find answer for: I use ExistentialQuantification and I can't get pattern matching on inner values to work, any workaround so I don't have to put the function isAcknowledge into class? https://gist.github.com/4127766
13:15:19 <startling> rwbarton, probably
13:15:26 <elliott> rwbarton: no escape
13:15:38 <hpaste> tomeo pasted “Broken GHCI” at http://hpaste.org/78022
13:15:58 <startling> that looks broken.
13:15:58 <rwbarton> is this an old session?
13:16:10 <elliott> tomeo: okay well i actually meant the session wherein you did import Asdf
13:16:12 <elliott> and it didn't complain
13:16:16 <tomeo> rwbarton: its from before I installed Data.Numbers.Primes via cabal yes
13:16:21 <tomeo> oh
13:16:22 <tomeo> okay
13:16:27 <NoICE> (resaved to incude Builder.hs - instance for Data Acknowledge) https://gist.github.com/4127766
13:16:27 <elliott> but it will probably look identical I guess
13:16:30 <rwbarton> oh it's a 7.4.1 bug
13:16:33 <rwbarton> http://www.haskell.org/pipermail/glasgow-haskell-users/2012-February/021806.html
13:16:37 <rwbarton> all is well
13:17:18 <tomeo> well not really :D this does explain a lot of strange things though :)
13:17:49 <startling> it seems like it's os x specific, and when I had it, installed the 32-bit version fixed it.
13:18:02 <startling> oh, no, weird.
13:18:11 <startling> probably a different bug, then
13:18:32 <tomeo> I'm pretty sure I installed the 32bit, thats the one that's recommended isn't it?
13:18:37 <startling> yeah
13:18:50 <startling> well, maybe not. idk
13:19:46 <tomeo> ah, there are specific instructions for 10.6 and 10.7, but I'm on 10.8
13:21:09 <NoICE> tomeo: startling: I have os x 10.8 with x64 version of ghci 7.4.1 and import Whatever does not output anything too.. but :m + Whatever raises proper exception
13:21:15 <tomeo> if I actually succeed at importing, this is what my prompt should look like right (kind of, depending on import)? Prelude Data.Numbers.Primes>
13:21:29 <NoICE> yep
13:21:33 <tomeo> NoICE: are those interchangeable?
13:21:45 <tomeo> import and :m +
13:22:04 <NoICE> tomeo: :m + does not support hiding, qualified, etc. (at least it looks like that)
13:22:06 <atriq> Not quite
13:22:12 <atriq> What NoICE said
13:22:16 <rwbarton> also as you can see, 'import' is buggier
13:22:28 <tomeo> :D
13:22:32 <tomeo> thanks NoICE
13:22:34 <NoICE> and import x wasn't supported until recent releases of ghci
13:22:35 <rwbarton> ':m' has decades of development experience
13:23:16 <NoICE> can you guys please help me with this? :( https://gist.github.com/4127766
13:23:25 <NoICE> (see result.txt)
13:24:40 <NoICE> tomeo: btw don't know if 32bit version of ghc for os x have this bug or not, but you should stay on x64 because of library dependencies (many libs on os x are x64, like libmysqlclient, libpq etc.)
13:24:44 <startling> rwbarton: :m + is enterprise-ready
13:25:16 <NoICE> (tried to get libmysqlclient multiarch (32bit + x64bit at once) working, but that failed miserably)
13:25:25 <tomeo> thanks NoICE
13:26:30 <NoICE> np
13:27:35 <johnw> can I vertically compose lens traversals?
13:27:50 <edwardk> like zipping them or something?
13:28:00 <edwardk> or you mean do one then the next
13:28:02 <johnw> i.e., something along the lines of: over (_1 <|> _2) == over both
13:28:25 <edwardk> oh, that doesn't work, if you think about it from a 'legal' perspective because they might overlap
13:28:44 <edwardk> i might be talked into adding a combinator with lots of caveats on its use
13:28:58 <johnw> well, i'm reworking my intro on lens wrt traversals
13:29:22 <johnw> and I realized that once you have "both", you want to say things like: how do I change the 1st, 3rd and 5th members of a 5-tuple at the same time, the way I can with both?
13:29:26 <edwardk> i've become more permissive of combinators that have conditions on their use ;)
13:29:49 <johnw> yeah, don't stop me from shooting myself in the foot
13:29:57 <edwardk> well, with lenq you could use $(lense [e| \(a,b,c,d,e) -> (a,c,e) |])
13:30:01 <johnw> the overlap should mean double-application, or double-results
13:30:10 <edwardk> well, overlap means you just get an illegal lens
13:30:11 * elliott wishes lens was a little less permissive about broken combinators :(
13:30:12 <edwardk> er traversal
13:30:27 <johnw> edwardk: err, i wanted something simpler than TH :)
13:30:29 <edwardk> elliott: fair nuff
13:30:41 <edwardk> johnw: that isn't yet in mainline anyways =)
13:31:02 * NoICE pleases :( https://gist.github.com/4127766
13:31:08 <edwardk> elliott: which ones in particular make you sad?
13:31:24 <mauke> here's a golf problem: http://golf.shinh.org/p.rb?two+kinds+of+digit
13:31:33 <elliott> that filtering one that doesn't respect the over laws (I forget its exact name)
13:31:34 <edwardk> filtered is probably the most dangerous one i've added from a law perspective
13:31:34 <johnw> so yeah, one traversal combinator operator, please
13:31:35 <mauke> I can't figure out how the other haskell people are doing it
13:31:38 <elliott> not too sure about this new non one either :p
13:31:40 <startling> :t _135 fn (a, b, c, d, e) = (,,,,) <$> fn a <*> pure b <*> fn c <*> pure d <*> fn e
13:31:41 <lambdabot> parse error on input `='
13:31:59 <elliott> I think there are also a few partial functions I wasn't too happy about when I saw them, but those are harder to argue against from a practical perspective
13:32:00 <startling> :t \fn (a, b, c, d, e) = (,,,,) <$> fn a <*> pure b <*> fn c <*> pure d <*> fn e
13:32:00 <edwardk> but its intended to work with folds, it just has a type signature that doesn't prevent you from doing more with it
13:32:01 <lambdabot> parse error on input `='
13:32:18 <startling> man. I'm so bad at lambdabot.
13:32:22 <elliott> yeah, but type signatures are meant to prevent erroneous uses :P
13:32:27 <edwardk> elliott: ah the _head, etc. lenses that are buried in Data.List.Lens
13:32:36 <elliott> yeah I don't like those
13:32:51 <elliott> or fromWithin, but it'd probably be a real pain to use the zipper stuff without that
13:33:01 <edwardk> yeah fromWithin is a pragmatic call too
13:33:02 <tomeo> omg! Data.Numbers.Primes was warpspeed compared to my prime solution :D
13:33:12 <edwardk> you have a way of highlighting all my sins ;)
13:33:26 <edwardk> tomeo: hah
13:34:16 <elliott> edwardk: well what you have to do is port lens to Agda
13:34:23 <edwardk> =)
13:34:31 <edwardk> i think copumpkin will beat me to it
13:34:34 <elliott> fromWithin will just require you pass a non-empty traversal :)
13:34:35 <edwardk> he wants dependent lenses
13:34:43 <elliott> hah
13:34:47 <elliott> because the signatures weren't complicated enough
13:35:08 <edwardk> i have Traversable1 in semigroupoids, i've been thinking about adding it as a safer fromWithin alternative
13:35:29 <edwardk> :t within
13:35:31 <lambdabot> SimpleLensLike (Control.Lens.Internal.Bazaar c c) b c -> (a :> b) -> Maybe ((a :> b) :> c)
13:35:36 <edwardk> that is the principled one ;)
13:36:32 <elliott> Traversable1 sounds more reasonable than fromWithin, yeah
13:36:44 <edwardk> sure, but i still like fromWithin pragmatically ;)
13:36:47 <johnw> edwardk: can I use <*> somehow to avoid repeating the (+1) in my example?
13:36:53 <johnw> (%~ (+1)) <$> _1 <*> _3 <*> _5 $ (1,1) or something...
13:37:00 <elliott> is it going to get rolled into lens rather than adding another dependency? :P
13:37:01 <johnw> err, (1,1,1,1,1)
13:37:17 <edwardk> :t (%~ (+1)) <$> _1 <*> _3 <*> _5 $ (1,1)
13:37:19 <lambdabot>     Couldn't match expected type `a1 -> a0 -> b0'
13:37:20 <lambdabot>                 with actual type `(t0, t1)'
13:37:20 <lambdabot>     In the second argument of `($)', namely `(1, 1)'
13:37:22 <edwardk> :t (%~ (+1)) <$> _1 <*> _3 <*> _5 $ (1,1,1,1,1)
13:37:24 <lambdabot>     Couldn't match expected type `a1 -> a0 -> b0'
13:37:25 <lambdabot>                 with actual type `(t0, t1, t2, t3, t4)'
13:37:25 <lambdabot>     In the second argument of `($)', namely `(1, 1, 1, 1, 1)'
13:37:25 <dino-> Is the map impl in Data.List tail recursive?
13:37:41 * hackagebot SHA 1.6.1 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.1 (AdamWick)
13:37:45 <elliott> dino-: no, and it would be worse if it was
13:37:52 <johnw> no, it doesn't type checke at all
13:37:56 <elliott> tail recursion isn't nearly as relevant a concept when you have lazy data
13:37:56 <Rc43> Hi, guys.
13:37:59 <johnw> i'm stabbing in the dark
13:38:06 <edwardk> good. i was wondering how that would work ;)
13:38:24 <johnw> i want to apply lenses in series
13:38:25 <edwardk> hrmm, i wonder.
13:38:32 <edwardk> let me chew for a minute
13:38:44 <Rc43> http://lambda-the-ultimate.org/node/1924
13:39:06 <Rc43> How can I access Djinn from first reply' functionality now?
13:39:11 <johnw> here's the ugly expanded version: _3 %~ (+1) $_2 %~ (+1) $ _1 %~ (+1) $ (1,1,1)
13:39:27 <johnw> my gut tells me that can be refactored down
13:39:34 <elliott> edwardk: wouldn't making _head/_tail/_last/_init the traversal versions work just fine if you added a single naughty traversal-get operator?
13:40:08 <elliott> oh, fold-get rather I guess
13:40:25 <edwardk> clearly it should be ^interrobang
13:40:49 <elliott> :t (^!)
13:40:51 <lambdabot> Monad m => s -> Acting m a s t a b -> m a
13:40:57 <elliott> :t (^?)
13:40:59 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
13:41:00 <edwardk> yeah already has another connotation
13:41:02 <elliott> (^?!) sounds sort of good to me :p
13:41:16 <elliott> or ^:( so you feel bad
13:41:26 <Rc43> Or is djinn called hoogle now?
13:41:26 <edwardk> put in an issue. i'll definitely consider doing so
13:41:29 <johnw> :^( is a sad type
13:41:33 <johnw> edwardk: are you saying that to me?
13:41:34 <NoICE> guys, nevermind, I got around https://gist.github.com/4127766 by putting "isAcknowledge" into instance (which is BAD solution imho, but I can't think about any other way :( )
13:41:35 <edwardk> ^?! makes you feel bad
13:41:45 <edwardk> johnw: nah, to elliot. chewing on your problem still
13:42:18 <edwardk> :t ?v <$> _1 <*> _2 <*> _3
13:42:20 <lambdabot> (?v::(s -> f t) -> (s1 -> f t1) -> (s2 -> f t2) -> b, Functor f, Field3 s2 t2 a b1, Field2 s1 t1 a b1, Field1 s t a b1) => (a -> f b1) -> b
13:42:38 <edwardk> the trick is fusing those.
13:42:52 <johnw> this gets really close: ((_3 %~) .) . ((_2 %~) .) . ((_1 %~) .) .  (+1) $ (1,1,1)
13:43:04 <johnw> i just have to uncurry it for the three arguments
13:43:37 <elliott> ok, I will make an issue in some minutes
13:44:07 <edwardk> :t (.) <$> _1 <*> _2
13:44:09 <lambdabot> (Functor f, Field2 s t1 a b, Field1 (f t1) t a b) => (a -> f b) -> s -> f t
13:44:31 <edwardk> > ((.) <$> _1 <*> _2) +~ 1 $ (1,2,3)
13:44:34 <lambdabot>   No instance for (Control.Lens.Tuple.Field1
13:44:34 <lambdabot>                     (Control.Len...
13:44:53 <edwardk> oh its not (.) i want to fmap in there somehow
13:45:17 <nand`> edwardk: what was that funky lens again that automatigically traverse all the holes with the right type within nested structures?
13:45:28 <edwardk> biplate
13:45:32 <edwardk> Data.Data.Lens.biplate
13:46:10 <edwardk> :t beside
13:46:11 <lambdabot> Applicative f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (s, s') (t, t') a b
13:46:30 <hpaste> kini pasted “extra line "[(),(),()]" with runhaskell or ghci” at http://hpaste.org/78026
13:46:39 <kini> what's up with this? ↑
13:47:13 <edwardk> kini: mapM generates a list of the results. the result of putStrLn each time is a (). mapM_ discards the result list
13:47:16 <mauke> kini: that's the result of running main
13:47:22 <edwardk> use mapM_ putStrLn words
13:47:48 <kini> edwardk: I see
13:47:56 <kini> but why does the behavior differ between ghc and runhaskell ?
13:47:57 <edwardk> that returns an IO () rather than an IO [()] -- and ghci suppresses the printing of units
13:48:03 <jrk_> hello
13:48:29 <edwardk> because you often look at values in ghci. so if you type 1 + 2. it takes that and shows you the answer rather than silently adding it up and throwing away the answer ;)
13:48:47 <edwardk> here you ran an action, that _happened_ to print, but if it didn't you'd probably be interested in the resulting list ;)
13:48:57 <jrk_> i'm trying to write ffi bindings (specifically a Storable instance) for a C struct which carries a pointer (+length info) to another struct
13:49:12 <kini> interesting...
13:49:21 <edwardk> ghc doesn't print anything you don't tell it to. it expects a whole program, not a series of interactions with the user
13:49:21 <jrk_> e.g. struct foo { bar_t * bar; int barlen; };
13:49:32 <edwardk> > 1 + 2
13:49:35 <lambdabot>   3
13:49:49 <kini> I can see why that makes sense with ghci, but shouldn't runhaskell suppress that behavior?
13:49:50 <jrk_> now the problem is, that if i allocate memory in poke i can't free it later
13:49:54 <jrk_> and have a memory leak
13:50:00 <kini> it seems weird that "the haskell interpreter" and "the haskell compiler" should produce different results
13:50:25 <edwardk> i don't use runhaskell so you'll need to talk to someone else about how that thing works
13:50:27 <jrk_> if i use ForeignPtr with a finalizer, the finalizer runs too early and makes my memory reference invalid
13:50:32 <elliott> well ghci and runhaskell accept different types of data
13:50:35 <jrk_> any ideas/suggestions/hints?
13:50:46 <elliott> ghci accepts a stream of interactive expressions (and some statements/special commands)
13:50:53 <elliott> runhaskell accepts a haskell module
13:51:06 <kini> elliott: right, so shouldn't runhaskell behave more like ghc than like ghci?
13:51:30 <elliott> oh hm
13:51:40 <elliott> that is weird behaviour yes
13:51:43 <elliott> and possibly unintentional
13:51:58 <elliott> I suspect runhaskell might be doing the equivalent of "GHCi> main"
13:52:08 <elliott> which will print main's result if it isn't IO () I think
13:52:21 <elliott> anyway specifying main :: IO () like you always should will fix that :p but maybe it is undesirable behaviour
13:53:11 <kini> oh, the type generated is IO [()]... right, I missed that
13:53:23 <kini> I guess that's the (a?) difference between mapM and mapM_
13:53:48 <kini> if this is undesirable behavior, should I report it to someone?
13:54:11 <elliott> I guess you could report it as a GHC "bug"
13:54:27 <elliott> arguably the behaviour is sometimes desirable I guess... I wish main was just forced to be IO ()
13:57:09 <merijn> jrk_: Are you using the pointer in the C side of things?
13:58:17 <jrk_> merijn: it's a foreign library so i can't be sure about that
13:58:31 <Jeanne-Kamikaze> how can the finalizer "run too early" ?
13:58:58 <merijn> jrk_: The runtime doesn't know about other uses of the pointer it will happily run the finalizer when the last ForeignPtr gets GCed
13:58:59 <jrk_> merijn: (in that case, however, i read the src and wouldn't necessarily need it, but i can't know where else it's needed)
13:59:13 <merijn> jrk_: If someone else is using the pointer associated with the ForeignPtr you're SOL
14:00:02 <merijn> jrk_: The runtime only tracks ForeignPtr's, if you pass them to code you better be sure the code doesn't use the pointer if you remove all of the ForeignPtr's on the haskell side
14:01:47 <jrk_> what i tried to test this instance is quite simple: poke ptr data; data2 <- peek ptr
14:03:28 <merijn> jrk_: "allocate memory in poke" what do you mean? You mean you allocate a pointer and poke it into the outer struct?
14:03:44 <jrk_> merijn: i don't quite get this, let's say i have allocated memory, run poke (which allocates finalized memory) and then call my c function on that
14:04:09 <jrk_> merijn: ah, ok, it's a Storable instance for which i've implemented poke
14:04:18 <merijn> poke doesn't allocate memory at all...
14:04:37 <merijn> poke requires a valid pointer to start with
14:04:41 <jrk_> merijn: within poke (think of do block) i call mallocForeignPtr
14:05:25 <merijn> jrk_: That's wrong, because once the ForeignPtr gets GCed the pointer is freed so the pointer in your struct is invalid
14:05:32 <jrk_> merijn: yes, the function wrapping the c call allocates memory and calls poke with that
14:05:37 <merijn> The solution is: don't use ForeignPtr and GC manually
14:06:22 <merijn> jrk_: Take a look at newHandle/destroyHandle: https://github.com/merijn/SNet2.0/blob/master/SNet/Interfaces/C.hs
14:06:40 <merijn> (Man, uploading to code has so far saved me a ton of writing out explanations :p)
14:06:57 <kini> lol, there's a "_|_" milestone on ghc trac
14:08:59 <Rc43> I have found this: http://hackage.haskell.org/package/djinn
14:09:02 <Rc43> Anybody used it?
14:09:09 <Rc43> How can I import modules?
14:09:21 <Rc43> I want use at least lists in it.
14:09:32 <simpson> @djinn a -> [a] -- Rc43
14:09:33 <lambdabot> Cannot parse command
14:09:35 <merijn> @djinn a -> b -> (a, b)
14:09:36 <lambdabot> f a b = (a, b)
14:09:36 <elliott> it isn't so good at recursive definitions
14:09:52 <elliott> and it definitely isn't good enough at haskell code to import modules
14:10:37 <jrk_> merijn: thanks :)
14:10:50 <ebpanic> I'm coming from a Ruby and JavaScript background, using MVC to organize code. Previously I've placed as much code inside the models to help with unit testing… Is there something analogous in Functional Programming to keep test coverage high? I'm working on using JavaScript in a functional way and wondering if there are Haskell MVC frameworks that do extensive unit testing that I can model my practices after, when using JavaScript
14:10:50 <ebpanic>  in a Functional way?
14:11:06 <Rc43> djinn: Recursive types are not allowed.
14:11:29 <merijn> ebpanic: Are you familiar with QuickCheck?
14:12:04 <startling> ebpanic, does your nick have anything to do with greek gods?
14:12:18 <ebpanic> no, but I've heard of it. Is it the xUnit testing framework for Haskell?
14:12:34 <startling> ebpanic, quickcheck is weird.
14:12:35 <Rc43> @djinn (a -> b) -> (a,a,a,a) -> (b,b,b,b)
14:12:35 <lambdabot> f a (b, _, _, _) = (a b, a b, a b, a b)
14:12:44 <ebpanic> startling, hahaha no… "everybody panic!"
14:12:58 <merijn> ebpanic: I have no clue what xunit is, so maybe? It's a testing framework that simplifies testing by automatic generation of test data
14:13:31 <merijn> @check \xs -> (xs :: [Int]) == reverse (reverse xs)
14:13:31 <startling> ebpanic: in quickcheck, you write a way to generate some arbitrary x and then write some properties any x should have.
14:13:32 <lambdabot>   Not in scope: `myquickcheck'
14:13:37 <merijn> Oh damn
14:13:38 <simpson> ebpanic: There *is* an xunit-style tester, but it's not used very often.
14:13:42 <merijn> I forgot @check is broken
14:14:14 * merijn is sad
14:14:50 <ebpanic> merijin, I guess my question is, I'm coming from an OO background and I'm used to just testing public methods, I'm looking for an analogous way to test in a functional paradigm
14:15:24 <merijn> Only check exported functions? I guess?
14:15:46 <simpson> ebpanic: You can do the same sort of testing, if you like.
14:16:12 <edwardk> its interesting that the law-breaking thing for making a traversal out of separate lenses is very hard to write with lens.  =)
14:17:30 <dino-> Another strategy is to put test functions in the same module with the non-exported functions to be tested
14:17:55 <Rc43> Is it possible to get map's implementation in djinn?
14:17:57 <dino-> But, you know, has disadvantages too
14:18:18 <ebpanic> simpson, is there an example of an Haskell MVC framework that makes extensive use of unit testing?
14:18:48 <ebpanic> So, I can model my JavaScript Functional MVC after that?
14:18:52 <dibblego> ebpanic: we don't do that kind of thing 'round ;ere
14:19:02 <Jafet> map _ _ = []
14:19:37 <simpson> ebpanic: Unlearn JS and learn Haskell.
14:20:06 <tufflax> Is (a ++ b) in O(|a|) always?
14:20:41 <merijn> tufflax: It depends, if many cases it can be fused with surrounding loops so the ++ is free
14:20:43 <sacundim> if you force the first |a| elements of the result, sure
14:21:08 <sacundim> fusion just means you get linear time with a multiplier of zero :-P
14:21:29 <tufflax> hm
14:21:45 <tufflax> I'm not sure I understand what fusion is :p
14:21:59 <ebpanic> simpson, I write mobile apps using Appccelerator's Titanium framework (uses javascript to build native mobile apps)… so I'm kind of locked in. But I can write in a functional paradigm, since JavaScript supports that. I'm just trying to figure out how best to unit test...
14:22:13 <johnw> tufflax: one example of fusion: map f . map g = map (f . g)
14:22:19 <ebpanic> simpson, can you use Haskell for mobile applications?
14:22:25 <johnw> you are using this isomorphism to reduce two traversals down to one
14:22:37 <tufflax> Ok
14:22:42 <monochrom> presumably, testing a function is just like testing a "method"
14:22:44 <simpson> ebpanic: By "native mobile applications," do you mean emitting Java for Android and Obj-C for iOS?
14:22:46 <tufflax> well i did this reverse' (x:xs) = reverse' xs ++ [x]  and it was way slow
14:23:08 <johnw> tufflax: that's because using ++ in recursion is slow
14:23:10 <simpson> ebpanic: Haskell is not either of those languages.
14:23:18 <merijn> tufflax: Ah, yes, that's not going to be fast, no :)
14:23:19 <johnw> you are making a new list each time
14:23:22 <tufflax> then i saw the quicksort example smaller ++ [x] ++ larger and thought "isnt that slow?"
14:23:38 <simpson> ebpanic: But, regardless, I would encourage you to learn Haskell *before* you try to directly apply it.
14:23:51 <dibblego> ebpanic: don't mean to rock the boat, but javascript definitely does not support functional programming in any way whatsoever
14:23:52 <merijn> tufflax: Word of caution, while pretty that 3 line quicksort is not actually quicksort
14:23:59 <johnw> tufflax: foldl (\acc x -> x : acc) [] [1,2,3]
14:24:06 <johnw> that version of reverse does not use ++
14:24:28 <johnw> aka, reverse = foldl (flip (:)) []
14:24:35 <ebpanic> dibblego, It seems to… we're using compose, map, reduce, filter, etc...
14:24:47 <ebpanic> dibblego, why do you think it doesn't?
14:24:48 <dibblego> ebpanic: with huge penalty
14:25:07 <dibblego> ebpanic: because I work in an office of haskell guys who tried to make javascript attempt it in every possible contortion
14:25:13 <typoclass> dibblego: it has closures, so it's e.g. better than c or java ...
14:25:27 <tufflax> johnw I dont really get that code, I'm on my first day of Haskell still
14:25:35 <sacundim> i'd take java any day over javascript
14:25:35 <tufflax> the foldl thing
14:25:35 <ebpanic> dibblego, we're using o'steele's library, with flapjax, for FRP… we've been seeing a huge benefit.
14:25:49 <merijn> tufflax: Don't worry, you can ignore that if you don't follow it :)
14:26:08 <sacundim> ebpanic: are you familiar with any kind of "fold" or "reduce" list functions?
14:26:24 <ebpanic> sacundim, yes..
14:26:38 <sacundim> basically, foldl is the left-to-right fold/reduce of a list
14:26:47 <merijn> tufflax: An alternative efficient reverse is here: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-List.html#reverse
14:26:48 <ebpanic> sacundim, I use it frequently..
14:26:52 <sacundim> lists in haskell are single-linked lists constructed with the ":" operator
14:26:55 <merijn> tufflax: (The second non-fold definition)
14:26:58 <tufflax> yes but what is that \acc and x -> x etc
14:27:04 <sacundim> so you can reverse a list with that
14:27:17 <merijn> tufflax: It's a lambda (i.e. anonymous function)
14:27:21 <tufflax> oh
14:27:25 <tufflax> i see
14:27:29 <sacundim> what other language do you know?  in scheme that is (fold-left cons '() xs)
14:27:38 <tufflax> I know clojure
14:27:47 <tufflax> (the new lisp)
14:27:47 <merijn> tufflax: "\x y -> bar" would be identical to "foo x y = bar"
14:27:48 * hackagebot enummapmap 0.4.0 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.4.0 (MatthewWest)
14:28:06 <sacundim> i don't know how fold works in clojure
14:28:14 <tufflax> it's called reduce
14:28:17 <tufflax> :p
14:28:20 <sacundim> but \x y -> body ==> (lambda (x y) body)
14:28:27 <sacundim> (in scheme)
14:28:46 <tufflax> ok, (fn [x y] body) in clojure :P
14:29:26 <sacundim> what does (fn [list] (reduce cons '() list)) or the equivalent do in clojure?
14:29:34 <sacundim> plz fix my non-clojure
14:29:53 <sacundim> if i guessed right how to write it, that either (a) copies the list, or (b) reverses it
14:30:37 <tufflax> reverse
14:30:50 <sacundim> so clojure reduce == haskell foldl
14:30:58 <tufflax> yeah
14:30:58 <ebpanic> dibblego, have your colleagues looked at http://osteele.com/sources/javascript/functional/
14:31:06 <jesyspa> Er, foldr, I think.
14:31:19 <ebpanic> dibblego, or http://www.flapjax-lang.org/
14:31:24 <tufflax> or
14:31:28 <dibblego> ebpanic: yes
14:31:33 <jesyspa> foldl would involve (cons '() list[0])
14:31:39 <rwbarton> shouldn't it be "flip cons"
14:31:39 <jesyspa> (or however you get the first element)
14:31:42 <tufflax> actually, you would not do it that way
14:31:49 <ebpanic> dibblego, and they haven't found those to be useful?
14:32:05 <dibblego> reverse = foldl (flip (:)) []
14:32:22 <dibblego> ebpanic: no more than any other effort for javascript
14:32:24 <jubos> hi, if you have a .cabal file with a bunch of build-depends is there an easy cabal command that installs just those dependencies so cabal build in that directory will work?
14:32:37 <tufflax> anyway, reduce in clojure goes left-to-right
14:32:42 <monochrom> yes, let me find it
14:33:07 <monochrom> "cabal install --only-dependencies"
14:33:16 <monochrom> how do I know: "cabal install --help"
14:33:19 <johnw> come on, come all: http://newartisans.com/2012/11/getting-started-with-lenses/
14:33:24 <johnw> one*
14:33:33 <johnw> the tradition of lens tutorials begins!
14:33:39 <edwardk> =)
14:33:48 <johnw> lenses as convex burritoes is next
14:33:49 <edwardk> twan started that craze in 2006 ;)
14:33:50 <jubos> monochrom: so i tried that, but it just says that they are already installed
14:33:58 <johnw> edwardk: haha
14:34:06 <johnw> this is for kmett lenses
14:34:07 <edwardk> its just been at a slow burn all along
14:34:12 <johnw> a whole different breed
14:34:18 <johnw> a kmens
14:34:25 <monochrom> in which directory?
14:34:28 <tufflax> sacundim, but you would have to do (reduce (fn [result e] (cons e result)) '() lst) :p
14:34:48 <edwardk> yeah. totally different. my version of van laarhoven lenses are radically different than er.. wait, van laarhoven lenses. guess not ;)
14:35:08 <jubos> monochrom: i used cabal init and it derived some dependencies from a .hs file I have
14:35:16 <johnw> i know, just being facetious
14:35:25 <edwardk> likewise =)
14:35:35 <johnw> van laarhoven pioneered the Store connection, didn't he?
14:35:48 <edwardk> the store connection was really roconnor
14:35:54 <johnw> really?
14:36:11 <edwardk> he spotted that they were store comonad coalgebras
14:36:24 <edwardk> and then we bounced around names for a long time before settling on store
14:36:34 <johnw> i've seen many papers on that connection
14:36:36 <johnw> his was the first?
14:36:40 <tufflax> merijn actually I did reverse just like that when i compared with the slow version :D
14:36:42 <edwardk> twanvl_: was it you or roconnor who first spotted the store comonad connection for lenses?
14:36:45 <jubos> monochrom: ah i think the cabal init function missed a few of the dependencies.  manually adding and then will try the command you suggested again
14:36:57 <edwardk> johnw: afaik
14:37:24 <johnw> i still have the original papers on my reading list
14:38:44 <twanvl_> edwardk: that was roconnor
14:39:02 <edwardk> twanvl_: thought so. thanks =)
14:39:05 <edwardk> johnw: see?
14:39:17 <johnw> wow, gj guys :)
14:40:15 <monochrom> lens is like foie gras
14:40:44 <Clint> delicious when prepared properly but terrible otherwise?
14:40:55 <monochrom> I don't know
14:40:57 <johnw> and incredibly harmful to animals
14:41:03 <edwardk> roconnor first came up with the 'cartesian store' comonad, but that turned out to be related to the funlists that twan had previously blogged about, and which, in its indexed form as bazaar, powers a lot of the more complicated traversal combinators i wrote in lens
14:41:40 <monochrom> traverse is like celery
14:41:49 <elliott> edwardk: I just realised that _head should actually be forall f. (Pointed f) => (a -> f a) -> [a] -> f [a]
14:41:50 * elliott ducks
14:42:17 <edwardk> elliott: i seriously considered using Pointed and Apply to make 0 or 1, and 1 or more target traversals
14:42:29 <edwardk> but the problem is the dependency hell
14:42:49 <elliott> isn't the problem Pointed :P
14:42:51 <edwardk> if they were in the hierarchy it would come for free
14:43:00 <edwardk> pointed is a problem, but here its actually exactly the right thing
14:43:13 <elliott> yeah... it's correct there
14:43:19 <elliott> but introduce it and people will use it for other things :P
14:43:24 <monochrom> oh, I know!
14:43:25 <edwardk> in lens i've adopted the convention of using ^? to access any traversal that is really a partial lens
14:43:35 <monochrom> lens is like ray, a drop of golden sun
14:43:49 <monochrom> traverse is like far, a long long way to run
14:43:49 <edwardk> and that lets you read its target, and you can update it with .~, etc.
14:43:55 <elliott> (Traversable f) => (a -> f b) -> s -> f t is a thing, right?
14:43:57 <edwardk> monochrom: hahahahaha
14:43:58 <elliott> or was it Foldable
14:44:22 <johnw> if i look into any lens deeply enough, then aim it at the sun, I feel like I'm trying to learn agda
14:45:15 <johnw> somebody said on twitter that python shops are starting to advertise interest in Haskell to weed out candidates; so he suggested his Haskell shop do the same using Agda
14:45:35 <edwardk> Control.Lens is my secret ploy to get everyone to give up on Haskell and just move on to Agda as they find the Haskell types too complicated by comparison.
14:46:10 <johnw> lol
14:46:23 <elliott> @remember edwardk Control.Lens is my secret ploy to get everyone to give up on Haskell and just move on to Agda as they find the Haskell types too complicated by comparison.
14:46:23 <lambdabot> I will remember.
14:46:42 <kmels_> hi, I am using the `hedis` package to communicate with a redis database. I'm transversing and indexing a list of file paths and I get an error "getProtocolByName: does not exist (no such protocol name: tcp)" at some point. The error occurs at *different* file paths. What could cause that?
14:46:49 <edwardk> i somehow knew that would get @remembered, so i took a moment to check my capitalization and punctuate ;)
14:47:07 <johnw> and Agda has a sufficiently large alphabet to keep up your single-letter variable naming habit, edwardk
14:47:12 <edwardk> oooh
14:47:13 <typoclass> @remember edwardk i somehow knew that would get @remembered, so i took a moment to check my capitalization and punctuate
14:47:13 <lambdabot> Done.
14:47:24 <johnw> hahahah
14:47:26 <elliott> edwardk: it was obvious @remember bait
14:47:28 <hiptobecubic> :D
14:47:29 <elliott> i just added it so you wouldn't feel bad!
14:47:36 <ion> :-D
14:48:07 <johnw> how gauche is using Unicode operators in Haskell right now?
14:48:15 <edwardk> pretty gauche
14:48:25 <johnw> i feel like I'm just setting myself up for loathing
14:48:34 <hiptobecubic> I still think unicode is for jerks
14:48:37 <johnw> makes for pretty blog posts though
14:48:53 <ion> I wouldn’t mind seeing it more, but i don’t feel like writing code that totally stands out from the norm.
14:49:10 <elliott> every time I see a library with unicode in the type signatures I shake my fist at the bourgeoisie
14:49:26 <startling> All the code I've ever written uses unicode!
14:49:38 <startling> a subset of unicode, at least.
14:49:39 <johnw> i'm thinking of using α, β and γ for type variables, freeing up a, b and c as less confusing local variables
14:49:58 <ion> a, ß and y
14:50:33 <johnw> however, it would look weird coming up in Hoogle queries
14:50:44 <ion> I would actually be funny to use a, ß, y.
14:50:48 <johnw> i'm trapped in a 7-bit world
14:51:00 <tufflax> Yay, I'm at chapter 6 in Learn You A Haskell, after this I'm hoping to be able to read some monad tutorials (that's what got me learning Haskell)
14:51:22 <johnw> i should put just "128" on my tombstone, and see if anyone gets it
14:51:24 <ion> Most Monad tutorials are horrible.
14:51:26 <monochrom> I may use non-ascii operators. but staying with ascii for types
14:51:40 <typoclass> johnw: i think cosmetically renaming established operators like ++ or >>= is a bit silly. but if you made a new operator, and it demonstrably is better readable with some unicode symbol, it's worth thinking about
14:51:41 <monochrom> wait, 128 takes 8 bits
14:51:43 <tufflax> ion do you know of a good one then?
14:52:05 <elliott> wanting to learn haskell so you can read monad tutorials is like...
14:52:09 <elliott> I can't even think of a good analogy
14:52:13 <johnw> typoclass: my compromise right now is that Emacs _shows_ me => as ⇒, so I get all the prettiness, but none of the annoyance inflicted on others
14:52:28 <johnw> that works pretty well, actually
14:52:37 <tufflax> elliott, what's wrong with that? I love clojure but most stuff about monads is using haskell
14:52:38 <monochrom> is like wanting to install windows so you can get malware
14:52:53 <edwardk> my main issue with unicode operators is they make me stop and think of what digraph to type to use them
14:52:55 <elliott> tufflax: well monad tutorials are awful
14:53:00 <merijn> tufflax: Bah, skip the monad tutorials. Focus o understanding the types
14:53:02 <simpson> Do you actually love Clojure, or do you just think that it's pretty?
14:53:06 <elliott> and basically entirely unhelpful
14:53:08 <ion> tufflax: http://www.haskell.org/haskellwiki/Typeclassopedia http://www.haskell.org/haskellwiki/Monads_as_computation http://www.haskell.org/haskellwiki/Monads_as_containers
14:53:13 <startling> tufflax, monad tutorials are very bad
14:53:19 <elliott> tufflax: if you want to understand monads probably you should read http://www.haskell.org/haskellwiki/Typeclassopedia
14:53:21 <startling> most of them, anyway
14:53:22 <merijn> tufflax: If you grok types and type classes monads are trivial. And monad tutorials are rather terrible usually
14:53:26 <elliott> which isn't a monad tutorial
14:53:28 <edwardk> the agda guys i know have it down to muscle memory, they can bang through them pretty fast, but i don't want to stop to think about syntax as i code
14:53:33 <typoclass> johnw: ... and you can type the regular => instead of whatever weird thing you need for ⇒. that's definitely a good solution
14:53:33 <elliott> but if you read it with enough knowledge and dedication it will hel pyou understand lots of things
14:53:35 <elliott> including monads
14:53:43 <tufflax> simpson, I don't know if i actually love it, but it's my favourite language
14:53:51 <johnw> and have `elem` display as ∈ and forall as ∀ really does help readability fro me
14:53:53 <startling> let's just write all our haskell source code in TeX.
14:54:06 <johnw> typoclass: well, i type \=> to get ⇒, so it's not that weird
14:54:13 <johnw> but => is indeed faster
14:54:17 <ion> Let’s just write all our Haskell source code in Microsoft™ Word™.
14:54:34 <koala_man> it makes syntax highlighting more flexible
14:54:39 <ion> Haskell comes from Microsoft™ anyway.
14:54:44 <startling> fmap :: Functor \alpha \Rightarrow ..
14:54:51 <monochrom> just install a USB 3.0 port in your head
14:54:54 <typoclass> johnw: right, elem is a good thing to replace. it's almost always used infix anyway
14:55:19 <johnw> it's just better. ∎
14:56:04 <elliott> Microsoft™ Research™
14:56:33 <tufflax> I got this recommended to me http://www.haskell.org/haskellwiki/All_About_Monads It seems like of long and got some sections on classes, but yeah, typeclasses seem interesting. Clojure's got something that is related (I think) called protocols
14:56:45 <johnw> cool, I can type dot-below letters, like Maḥmúd
14:56:46 <tufflax> kind of long*
14:56:56 <johnw> didn't know agda-input could do that
14:57:13 <johnw> ☹
14:57:26 <johnw> thats \Frowny, shachaf must be told
14:57:37 <ion> tufflax: “All About Monads” and it gets around to talking about functors in section 21.3? Horrible. :-P
14:57:39 <gwern> @quote shacaf
14:57:40 <lambdabot> No quotes match. :(
14:57:45 <johnw> ℤ⁺
14:57:47 <gwern> @quote shachaf
14:57:48 <lambdabot> shachaf says: Type classes are a scary story that you tell new Haskellers so they can go to sleep at night.
14:57:50 <tufflax> ion ;(
14:58:22 <elliott> I remember not liking All About Monads, but I forget why
14:58:31 <johnw> maybe because it wasn't about anything else?
14:58:36 <elliott> hard to beat Typeclassopedia though
14:58:45 <johnw> go byorgey
14:58:51 <tufflax> Typeclassopedia it is
14:59:03 <johnw> just a tad dense for the beginner, though
14:59:05 <elliott> tufflax: -- and Typeclassopedia isn't really about typeclasses
14:59:12 <elliott> just about a certain few abstractions which Haskell represents as the
14:59:12 <elliott> m
14:59:17 <ion> Every Monad is an Applicative functor and every Applicative is a Functor. Not mentioning Applicative at all and mentioning Functor in a passing remark in section 21.3 is bad.
14:59:26 <gwern> gentlemen, you can't fight here, this is the War Room!
14:59:54 <lispy> gwern: shouldn't you be blogging about statistical inference?
15:00:08 <lispy> er, I mean, ohai!
15:00:09 <copumpkin> there is no sex in the war room
15:00:23 <gwern> lispy: yes, but my survey hasn't finished so I lack grist for my mill
15:00:33 <FireFly> tufflax: for me LYAH's explanation of monads worked pretty well
15:00:39 <gwern> lispy: also why do I feel like you meant that as some sort of criticism
15:01:03 <lispy> gwern: Not criticism per se, just a snarky brand of friendliness
15:01:11 <deus_rex> tufflax: learn you a haskell's monad explanation was great. the key is having a good understanding of Functors and Applicatives first
15:01:19 <lispy> gwern: it's actually nice to see you
15:01:21 <deus_rex> and maybe Monoids
15:01:26 <gwern> I don't understand why anyone would snark about statistics :(
15:01:34 <tufflax> FireFly, deus_rex ok I'll keep that in mind
15:01:57 <monochrom> I don't snark about statistic
15:02:18 <monochrom> there are truths, damn truths, and kripke structures
15:02:49 * gwern observes that monochrom is a non-black non-raven, but are all ravens black?
15:02:56 <lispy> gwern: I think your posts are doing the world a service, but that doesn't stop my inherint snarkiness
15:03:14 <gwern> I see
15:03:31 <gwern> (or I don't, either way my sweet potatoe should be finished cooking)
15:04:39 <shachaf> byorgey: Broken as in data List a Nil | Cons a (List a); fmap f list will do a quadratic amount of work if you look at all the elements.
15:04:40 <johnw> ion: I don't understand anymore why people make Applicative seem special.  They really have nothing at all to do with Monads.  Every functor is an applicative functor, and every monad is a functor; that's why every monad is an applicative functor -- not because of some special relationship between Monad and Applicative
15:05:03 <monochrom> wait, every functor is an applicative functor?
15:05:06 <rwbarton> no
15:05:10 <cmccann> johnw, I think you have one of those backwards...
15:05:12 <johnw> note my lack of capitalization
15:05:16 <rwbarton> still no
15:05:21 <johnw> sorry, every applicative functor is just a functor
15:05:25 <rwbarton> yes
15:05:36 <rwbarton> but then the conclusion suffers
15:06:21 <ion> johnw: liftM2, ap, return et al. are redundant, none of them needs the power Monad adds over Applicactive.
15:06:25 <elliott> I don't understand what "making Applicative seem special" is
15:06:48 <elliott> Applicative and Monad have a very important, meaningful distinction, and the former is an important abstraction in its own right
15:06:58 <ocharles> applicative isn't 'special', it's just a fantasticly useful tool
15:07:24 <monochrom> perhaps you see me using *> all the time, and you say I make Applicative so special
15:07:43 <ion> perhaps you see me rolling, perhaps you hating.
15:07:46 <shachaf> rwbarton: Did you ask about "taking"?
15:07:47 <monochrom> but then you also see me using lambda all the time, and you should say I make lambda so special, too
15:07:51 <rwbarton> yeah
15:07:56 <rwbarton> what is the status of that?
15:08:08 <shachaf> elementOf and taking had the same issue.
15:08:18 <elliott> edwardk: is there an equivalent of Traversal but with s/Applicative/Monad/? sounds weird
15:08:18 <monochrom> you also see me using ascii all the time, I must be making ascii so special, too
15:08:20 <cmccann> lambda, the ultimate special thing
15:08:24 <shachaf> elementOf is fixed now. taking still isn't but it might be possible to use the sam approach.
15:08:30 <shachaf> Hey, it's cmccann.
15:08:31 <elliott> edwardk: I guess it'd be something which extracts "structure" somehow
15:08:42 <johnw> so, with a endofunctor you map objects from C back to C.  Because in Haskell arrows are both objects and morphisms, F(f) can mean both F(a -> b) and F(a) -> F(b) [forgive the notation, I don't have a good way to distinguish "function mapped as morphism" and "function mapped as object"].  Applicative is just a way to "back up", and take a function that was mapped as an object and remap it as a morphism
15:08:50 <cmccann> shachaf, 'sup
15:08:58 <edwardk> elliott: not currently. is there a weaker form of Traversable that only offers mapM and not traverse?
15:09:00 <ocharles> elliott: you can make any monad an applicative with WrappedMonad
15:09:05 <ocharles> elliott: not sure if that helps
15:09:08 <elliott> edwardk: good question
15:09:19 <johnw> Monads never entry that picture
15:09:22 <johnw> enter*
15:09:26 <edwardk> elliott: but you can use mapMOf, etc. with traversals to use monads with the existing ones
15:10:01 <elliott> yeah
15:10:18 * cmccann notes that any apparent relationship between Applicative and Monad is to some extent a feature of only considering certain kinds of functors
15:10:33 * shachaf disregards the unfun ctors.
15:10:36 <elliott> I guess you don't really gain any power by going to Monad
15:10:36 <johnw> cmccann: thank you
15:10:41 <elliott> because it's always universally quantified
15:10:55 <elliott> so you can't really "join" on anything of interest
15:10:57 <cmccann> there's a reason why there's no obvious counterpart such that Applicative : Monad :: ?? : Comonad
15:11:03 <elliott> well unless you write out the type signature by hand inside the forall m.
15:11:04 <johnw> Applicative is almost like the "refunctor" of the Haskell toolbox
15:11:06 <elliott> rather than using a wrapper like Lens does
15:11:51 <johnw> i would say Applicative is simply orthogonal to Monad
15:12:04 <shachaf> That would seem like an odd thing to say.
15:12:16 <johnw> the task of Applicative concerns Functors, not Monads
15:12:23 <elliott> "the task of Applicative"?
15:12:24 <cmccann> I'm not sure return and pure ought to be considered orthogonal
15:12:25 <monochrom> would you also say Monad is orthogonal to Applicative?
15:12:27 <johnw> what <*> does
15:12:31 <johnw> the reason why Applicative exists
15:12:33 <cmccann> but (<*>) and join kinda are
15:12:34 <shachaf> "the taks of Monad concerns Applicative"
15:12:37 <elliott> I don't understand
15:12:47 <elliott> you learn something important about a type by adding join to Applicative
15:13:04 <elliott> namely, you get the power for your mappings to change the structure
15:13:10 <cmccann> note that pure, fmap, and join gives you a monad
15:13:16 <cmccann> so (<*>) is completely superfluous in that case
15:13:33 <elliott> cmccann: right.
15:13:37 <cmccann> likewise, (>>=) is a goofy non-orthogonal thing that happens to be more useful for programming than join is
15:14:08 <johnw> pure is really an aspect of Functor, in the CT sense
15:14:24 <elliott> huh?
15:14:36 <monochrom> let's change subject :)
15:14:41 <johnw> what I'm trying to get at is there's a reason I never run across "Applicatives" in any of the CT literature
15:14:41 <Saizan> if you think of the Moggi/EDSL approach to this, Applicative corresponds to first-order languages while Monad to higher-order ones
15:15:02 <edwardk> the main thing you could get out of the monad is the ability to support multiple 'passes' over the structure that depend on the previous pass
15:15:04 <elliott> well, that's because Applicative isn't very interesting from a CT point of view
15:15:08 * cmccann thinks f () and (f a, f b) -> f (a, b) make it more obvious what Applicative is doing, anyway
15:15:19 <johnw> Applicatives are just a way of undoing the inequality of fmap f and "[f"], for example
15:15:20 <elliott> also strong lax monoidal functor doesn't have a good ring to it
15:15:27 <Saizan> johnw: you don't get (F a, F b) -> F (a,b) for any functor F
15:16:02 <tomeo> Is there a function like functionname 2 [1,2,3,4,5,6] that would return [[1,2],[3,4],[5,6]]?
15:16:04 <edwardk> cmccann: while i prefer not paying for structure i don't use ;)
15:16:21 <shachaf> liftA2 would still be nicer than <*> in Applicative
15:16:23 <simpson> tomeo: Probably somewhere in Data.List.
15:16:29 <johnw> Saizan: are you saying that what Haskell calls Applicative is really the monoidal functor?  Ok, that makes sense
15:16:35 <elliott> shachaf: seriously?
15:16:38 <elliott> I don't like liftA2 much
15:16:52 <shachaf> elliott: It's better than something that uses f (a -> b)!
15:16:55 <cmccann> edwardk, yeah I don't think I'd actually want to use those definitions... they just make the structure more obvious :P
15:17:05 <tomeo> simpson: yes, I could only find splitAt, but I'd have to run it a few times :)
15:17:05 <johnw> i should have known that; alright, I'll retract some of what I said.  I don't come across "Applicative" because it has a different name
15:17:11 <ion> "[f"] looks like how punctuation is illogically moved inside quotations in English, just in reverse.
15:17:14 <edwardk> the main issue with the f (), (f a, f b) -> f (a,b) approach is you still have to define the fmap separately. its like making a monad with return and bind vs return, join and fmap.
15:17:39 <Saizan> johnw: the Idioms paper (defining what got renamed as Applicatives) says "lax monoidal functor"
15:17:54 <Jafet> @hackage split
15:17:54 <lambdabot> http://hackage.haskell.org/package/split
15:17:56 <elliott> edwardk: how many people use the default fmap for applicatives, though?
15:18:06 <elliott> I find I always write fmap first, and explicitly, because it's easy and helpful
15:18:12 <cmccann> edwardk, you just don't like that definition because it'd probably get called fzip and you hate that :P
15:18:15 <edwardk> elliott: i rarely do i admit.
15:18:49 <edwardk> i'm okay with fzip's that don't explode the number of values, etc. ;)
15:18:49 <johnw> Saizan: but am I right in saying that the Monad concept is orthogonal to the lax monoidal functor?  or is there a deeper relationship that I'm missing?
15:19:08 <elliott> is there some story to this fzip thing :P
15:19:19 <shachaf> Most people just DeriveFunctor because they like quadratic runtime.
15:19:29 <johnw> shachaf: did you find out why GHC was being starnge?
15:19:33 <edwardk> elliott: just that ap is not zip. consider ap for [] and zip for []
15:19:39 <shachaf> GHC is starnge?
15:19:41 <cmccann> elliott, edwardk doesn't like calling "liftA2 (,)" fzip because of what it does on lists by default
15:20:03 <ion> shachaf: Huh. What kind of code does DeriveFunctor generate to have a quadratic runtime?
15:20:18 <edwardk> ion: it eta expands the function in the nested calls
15:20:25 <shachaf> ion: fmap f Nil = Nil; fmap f (Cons x xs) = Cons (f x) (fmap (\e -> f e) xs)
15:20:27 <edwardk> this leads to O(n) eta wrappers you have to walk through
15:20:38 <elliott> cmccann: I wish the list Applicative instance was the zippy one
15:20:38 <ion> huh
15:20:42 <cmccann> (I'd argue that the zippy applicative makes sense as the default for [], but losing []'s monad would suck and having the two instances disagree would be far worse)
15:20:53 <ion> Wouldn’t that be simple to fix?
15:20:56 <shachaf> Sure.
15:20:59 <edwardk> we've become exceptionally well tuned to unnecessary eta expansion in lens
15:21:08 <elliott> []'s monad is kind of inefficient anyway :p
15:21:11 <shachaf> ion: Derive{Foldable,Traversable} is even worse.
15:21:36 <typoclass> ion: i hear it's truly bizarre
15:21:40 <shachaf> edwardk: Well, the way I found out about this was measuring how long something took to run first and looking for lambdas later.
15:21:42 <Saizan> johnw: as i said above there's a nice relationship coming from the CS side of things, it's probably not so apparent from the CT side or we would have had Applicatives sooner? i'm speculating here
15:21:48 <edwardk> ghc likes to eta-expand function calls like that, because it sometimes gives them better inlining behavior. they can't inline unless the function is fully applied
15:22:14 <shachaf> I was trying to figure out whether foldrOf (:) [] made sense, and somehow the code was terrible slow no matter what shape tree I gave it.
15:22:28 <rwbarton> I think "applicative" as in lax monoidal functor is about as old as monad
15:22:31 <Jafet> Linear, quadratic, what's the difference
15:22:39 <rwbarton> probably older
15:23:15 <elliott> rwbarton: strong too, no?
15:23:17 <elliott> pile on the adjectives
15:23:33 <tomeo> thanks Jafet
15:23:33 <Saizan> rwbarton: yeah, but does the developement and/or presentation of monad highlight the connection?
15:23:35 <rwbarton> "strong" may be more recent
15:23:38 <Jafet> @quote monoidal.endo
15:23:38 <lambdabot> geheimdienst says: haskell makes hard things easy and easy things a strong lax monoidal endofunctor ...
15:23:52 <monochrom> really awesome cool functor
15:23:59 <rwbarton> it is not like a haskell functor can fail to be strong so I don't know why people always mention that
15:24:00 <johnw> Saizan: well, I suppose the argument could be made that applicatives are implied by >>=, since f <*> x = f >>=\g -> fmap g x
15:24:17 <edwardk> exactly. every functor in haskell is strong. done.
15:24:28 <johnw> shows proves that every monad is an applicative; ok, maybe then I'll retract my strong objection to conflating the ideas
15:24:41 <rwbarton> every objection is strong
15:24:43 <edwardk> rwbarton: i think its just that folks find 'strong lax …' funny sounding
15:24:48 <rwbarton> probably :)
15:24:53 <rwbarton> it confused me for a long time
15:24:54 * Canar overrules rwbarton
15:24:58 <Saizan> johnw: yeah, but they also make up a nice hierarchy of expressiveness
15:25:10 <rwbarton> because people also say "strong monoidal" as the opposite of "lax monoidal"
15:25:23 <rwbarton> so I saw "strong lax monoidal" and thought "?????"
15:25:31 <elliott> rwbarton: well someone who says "strong lax monoidal functor" probably isn't trying to make a statement about Haskell
15:25:36 <elliott> or at least
15:25:41 <rwbarton> not an unironic one
15:25:44 <Saizan> lax in lax monoidal means you only got natural transformations rather than isomorphisms?
15:25:46 <elliott> yeah
15:25:50 <rwbarton> Saizan, yes
15:25:55 <rwbarton> in a particular direction too
15:26:06 <Saizan> ah, right, oplax the other
15:26:09 <rwbarton> the terminology for that is pretty much a mess
15:26:53 <shachaf> 11.10.13:20:47:49 <ddarius> "The object Ω above is sometimes called the strong-subobject classifier, since it classifies strong subobjects, but also sometimes called a weak subobject classifier, since it satisfies a weaker property than an ordinary subobject classifier."
15:27:23 <monochrom> hahaha
15:27:28 <typoclass> shachaf: november 10th one year from now?
15:27:29 <rwbarton> oh yeah and strong monoidal functors are also called weak monoidal functors :)
15:27:38 <rwbarton> "In contrast to this, a strong monoidal functor may also be called a weak monoidal functor"
15:28:04 <shachaf> typoclass: That's ddarius for you.
15:28:43 <rwbarton> strong: you get an isomorphism, not just a natural transformation in one direction
15:28:50 <rwbarton> weak: you only get an isomorphism, not an equality
15:29:27 <elliott> "of average strength"
15:29:38 * cmccann is immune to that sort of thing after the "open" and "closed" sets thing
15:29:43 <monochrom> God, we're screwed
15:29:54 <cmccann> it's terminology, it can sound silly and you just gotta deal with it
15:30:02 <johnw> a weak, lazy functor sounds pathetic, but is probably pretty useful
15:30:38 <monochrom> strong weak lazy strict functor
15:30:52 <typoclass> cmccann: i was just digging out the video! :-)
15:31:09 <typoclass> http://www.youtube.com/watch?v=SyD4p8_y8Kw <- here you go everyone. hitler is unhappy with the terminology too
15:31:17 <monochrom> heh
15:31:19 <johnw> we need charmed functors next
15:32:50 * hackagebot usb 1.1.0.4 - Communicate with USB devices  http://hackage.haskell.org/package/usb-1.1.0.4 (BasVanDijk)
15:35:34 <johnw> typoclass: that's just awesome
15:36:49 <merijn> Is it possible to have a category with 0 objects?
15:37:02 <johnw> that's not the category 0?
15:37:15 <typoclass> johnw: yeah :-) just rewatched it, it's definitely one of the better hitler-flipping-out videos
15:37:26 <rwbarton> merijn, yes
15:37:34 <rwbarton> there is just one
15:37:44 <rwbarton> since there is nowhere to put edges, either
15:37:54 <merijn> It has no morphisms, I guess?
15:38:07 <rwbarton> right, i meant morphisms
15:38:19 * merijn starting to get things
15:38:50 <ocharles> merijn: you know of www.dcs.ed.ac.uk/home/dt/CT/categories.pdf ?
15:39:17 <ocharles> that mentions category 0 in the first few pages
15:39:25 <merijn> Ah, no
15:39:30 <merijn> I was reading some other ones
15:39:46 <merijn> I think I might have actually read about category 0, but then forgot it :p
15:39:57 <ocharles> :)
15:40:06 <merijn> anyhoo, bed time
15:40:07 <johnw> maybe that's because it's both an open and a closed category?
15:40:48 <tufflax> Guys, take a look at this page: http://clojuredocs.org/quickref/varsonly/Clojure%20Core Is there anything similar for Haskell -- somewhere where you can get a nice overview of all the functions with links to details
15:41:17 <ocharles> that's nice
15:41:17 <johnw> no, but i'd really like to invite you to make one!
15:41:22 <ocharles> there's the 'index'
15:41:26 <tufflax> :P
15:41:43 <ocharles> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/doc-index-All.html
15:41:46 <ocharles> not exactly pretty
15:41:54 <johnw> that's some very pretty docs clojure has
15:42:22 <rwbarton> "Log in to add / edit an example" -> we need this kind of thing
15:42:34 <tufflax> johnw they are not official, some new stuff is missing, bu yeah, i like that site :)
15:42:45 <johnw> see also, the namespace browser, and the comments section, would be great too
15:42:55 <johnw> and the link to source!
15:42:58 <johnw> this is worthy of emulation
15:43:05 <startling> I'm not sure comments are a good idea.
15:43:10 <tufflax> Keep in mind clojure is like 4 years old, you are behind guys! :)
15:43:15 <dibblego> http://pastebin.com/s8rhRhYi is there a Data.Map function that can improve this?
15:43:19 <mauke> The paste s8rhRhYi has been copied to http://hpaste.org/78031
15:43:21 <ocharles> php.net has comments and i don't think that works so well
15:43:38 <johnw> having some like thing even just for "base" would be quite valuable
15:43:42 <typoclass> tufflax: try this http://www.cs.mu.oz.au/172/Haskell/tourofprelude.html it covers the prelude, so only the most basic functions, but it's better than nothing
15:43:50 <rwbarton> it would probably work a lot better for haskell than for PHP
15:43:51 <startling> mauke, are you a bot?
15:43:55 <mauke> yes
15:44:00 <rwbarton> @botsnack
15:44:00 <lambdabot> :)
15:44:05 <ocharles> i really need to contribute some of my skill/time to hackage 2...
15:44:08 <ocharles> "skill"
15:44:11 <popl> mauke doesn't like sweets.
15:44:16 <startling> :t M.alter
15:44:17 <lambdabot> Ord k => (Maybe a -> Maybe a) -> k -> M.Map k a -> M.Map k a
15:44:19 <tufflax> I think that site is open source, if someone is interested in doing that for Haskell
15:44:25 <tufflax> :P
15:44:29 <startling> dibblego: ^^ might be useful
15:44:53 <dibblego> startling: cannot get the value
15:45:02 <startling> dibblego, huh?
15:45:14 <dibblego> startling: it will not achieve the goAL
15:45:24 <rwbarton> :t M.insertLookupWithKey
15:45:26 <lambdabot> Ord k => (k -> a -> a -> a) -> k -> a -> M.Map k a -> (Maybe a, M.Map k a)
15:45:37 <dibblego> yes I did it with that
15:45:37 <rwbarton> it returns the old value though
15:45:38 <startling> dibblego, you'll need to be more specific.
15:45:50 <dibblego> oh right it does
15:45:53 <rwbarton> oh that is what you do
15:45:57 <sonOfRa> I have a question regarding filter, I don't quite understand how to use it:
15:45:59 <hpaste> sonOfRa pasted “Filter” at http://hpaste.org/78032
15:46:01 <dibblego> startling: goal, not achieved
15:46:12 <startling> dibblego, are you a bot?
15:46:15 <johnw> typoclass: I have a had time finding that site useful
15:46:17 <dibblego> yes
15:46:19 <johnw> it's just a deluge of information
15:46:32 <tufflax> typoclass that's pretty nice thanks
15:46:44 <monochrom> I am a bot too
15:46:46 <startling> sonOfRa, try "filter (== customerNumber) (getAccountsFrom bank)
15:47:00 <sonOfRa> but then I would try Account == CustomerNumber
15:47:21 <niteria> :t (.)
15:47:22 <lambdabot> Functor f => (a -> b) -> f a -> f b
15:47:30 <sonOfRa> Account contains a customerNumber, and I want to have all Accounts with that exact customerNumber
15:47:42 <johnw> niteria: that's the lambdabot definition, where fmap = (.)
15:48:00 <monochrom> please show us your declaration of Account
15:48:19 <cmccann> :t (Prelude..)
15:48:21 <lambdabot> (b -> c) -> (a -> b) -> a -> c
15:48:31 <typoclass> johnw: i feel it does a good job of introducing the prelude functions (better than the haddock obviously). but the formatting could be better
15:48:33 <hpaste> sonOfRa pasted “Account” at http://hpaste.org/78033
15:48:38 <niteria> I wonder if there are plans to make (.) come from category by default
15:48:54 <sonOfRa> Would I have to create a function like : hasAccountSameCustomerNumber
15:48:55 <johnw> typoclass: the categorial grouping in that clojure site is quite pleaseant
15:49:01 <sonOfRa> and use that instead?
15:49:39 <monochrom> filter (\(Account _ c _ _) -> c == customerNumber) (getAccountsFromBank bank)
15:49:55 <typoclass> johnw: yes, absolutely
15:50:12 <monochrom> except now I don't know whether "customerNumber" is defined or not
15:50:15 <sonOfRa> monochrom, that would be a lambda expressing the function I described above?
15:50:24 <monochrom> perhaps
15:50:29 <niteria> :t (Control.Category..)
15:50:31 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
15:51:05 <cmccann> :t (<<<)
15:51:06 <lambdabot> Control.Category.Category cat => cat b c -> cat a b -> cat a c
15:52:03 <sonOfRa> customerNumber is defined, yes
15:52:13 <monochrom> that's good
15:52:21 <niteria> > (+2) <<< (*2) $ 10
15:52:23 <lambdabot>   22
15:52:25 <niteria> nice
15:52:40 <niteria> > (+2) >>> (*2) $ 10
15:52:41 <lambdabot>   24
15:53:41 <cmccann> :t (>>>) <<< (>>>) <<< (>>>)
15:53:42 <lambdabot> Control.Category.Category cat => cat a b -> ((cat b c2 -> c1) -> c) -> (cat a c2 -> c1) -> c
15:53:46 <ocharles> edwardk: 'because due to temporary insanity Functor is not a superclass of Monad' heh, temporary? you're optimistic :)
15:53:51 * ocharles catches up lens changelog
15:54:00 <edwardk> =)
15:54:16 <elliott> perhaps one day people will stop worrying about the backwards compatibility that's already been broken (see: Num) and fix the superclasses
15:54:43 <edwardk> there is this magic thinking that somehow a superclass default solution will reduce the pain later.
15:55:14 <monochrom> I do not mind breaking compatibility. but then this is just because I hold no stake
15:55:18 <shachaf> It would break a lot of things to just change the hierarchy.
15:55:25 <elliott> lots of things break things
15:55:31 <shachaf> The annoying thing is that e.g. GHC 7.6 broke a lot of things anyway.
15:55:39 <elliott> Applicative instances are common, let's just get on with it and do the right thing
15:55:43 <shachaf> Even H98-compliant code.
15:55:46 <elliott> yes
15:55:53 <elliott> so the damage is already done, let's take advantage
15:55:56 <cmccann> solution: just break all the things
15:56:06 <cmccann> why stop halfway?
15:56:09 <monochrom> Oh, I just found that some of my published code is broken because of the Num, Eq, Show change, too, but it's easy to fix :)
15:56:34 <elliott> cmccann: change = to :=
15:56:40 <cmccann> besides, if you want painful breakage
15:56:44 <cmccann> ask Cale about type operators
15:56:57 <ocharles> "Renamed query to peruse and queries to peruses" :o \o/
15:58:13 <shachaf> edwardk: `Indexing` isn't actually gone.
15:58:27 <shachaf> `IndexingResult` is gone because I just used a tuple instead.
15:58:59 <rwbarton> > let insertWithDefault k v m = fmap getFirst $ runWriter (forMOf (at k) m (\x -> tell (First x) >> return (Just $ fromMaybe v x))) in let m = M.fromList [(2,3)] in (insertWithDefault 2 4 m, insertWithDefault 3 4 m)
15:59:01 <lambdabot>   ((fromList [(2,3)],Just 3),(fromList [(2,3),(3,4)],Nothing))
15:59:06 <edwardk> shachaf: true. i didn't edit the changelog after we resurrected it
15:59:30 <johnw> elliott: http://www.haskell.org/haskellwiki/Functor-Applicative-Monad_Proposal
15:59:31 <shachaf> Maybe after the One True Solution to taking is worked out, Indexing will be obsolete.
16:00:10 <edwardk> one can dream
16:00:20 <elliott> johnw: that doesn't seem like a particularly novel proposal :P
16:00:32 <elliott> but yes
16:00:44 <elliott> just adding the superclasses and providing default implementations of things like return is the way to go
16:00:46 <elliott> further smoothing can wait
16:01:09 <johnw> i say we do it for 8.0
16:01:10 <mpu> > M.fromList [(1, ()), (2, ())]
16:01:12 <lambdabot>   fromList [(1,()),(2,())]
16:01:23 <elliott> I say 7.8
16:01:28 <ocharles> johnw: 8 seems a nice number for it :)
16:01:45 <johnw> elliott: let's compromise and release 7.8 as 8.0 :)
16:03:32 <startling> how about 8.7?
16:05:58 <johnw> in 8.7 we'll make everything an instance of Object, to lure Java programmers
16:07:00 <monochrom> don't forget to make every typeclass a subtypeclass of Object, too, lest we run into the exact same "why is Monad not subclass of Functor AND Object" question
16:07:22 <ocharles> johnw: can we have type Object = forall a. a ?
16:07:39 <monochrom> and then some clever guy make say "I know, make Object a subclass of every class!"
16:07:47 <shachaf> rwbarton would object strongly.
16:07:51 <monochrom> haha
16:07:52 <Mandarin> Why is selective function import a part of the language and not a part of the compiler process?
16:07:56 <popl> johnw: :|
16:08:05 <elliott> edwardk: you should have the github account edwardk so I can complete lens' repo in my address bar properly
16:08:11 <elliott> Mandarin: huh?
16:08:18 <monochrom> rwbarton will object strongly and weakly, too
16:08:21 <edwardk> heh
16:08:28 <monochrom> just not laxly!
16:09:03 <johnw> debate on this issue is both open and closed
16:09:27 <elliott> edwardk: hey, doesn't traverseTail build up a bunch of thunks?
16:09:34 <elliott> (+1) . (+1) . (+1) etc.
16:09:45 <edwardk> quite probably
16:09:48 <elliott> oh
16:09:53 <elliott> it doesn't recurse
16:09:55 <elliott> duh :)
16:10:01 <edwardk> oh yeah there is that
16:10:05 <edwardk> =)
16:10:15 <elliott> and traverseLast handles it properly
16:10:41 <edwardk> i'm tempted to adopt your ^?! solution
16:10:57 <elliott> edwardk: I guess you can't quite just rename traverseFoo to _foo in Data.List.Lens and have (^?!), because traverseTail isn't quite the same as _tail
16:11:01 <elliott> yeah I was "researching" to open an issue
16:11:19 <cmccann> monochrom, no, the subclass of every class should be named Bottom, to promote confusion with _|_
16:11:20 <elliott> I guess using toListOf there would be fine... except it rebuilds/copies the list
16:11:24 <edwardk> yeah but i'm not too worried about breaking _tail
16:11:32 <elliott> wait
16:11:34 <elliott> no it doesn't :)
16:11:42 <elliott> or, hm, yes it does, because it uses itraverse, I guess
16:12:00 <elliott> edwardk: right but you want an efficient way to just take the tail as a "partial lens" without having to rebuild it
16:12:09 <elliott> so I guess you'd need to keep traverseTail separate as another name
16:12:23 <edwardk> i'm okay with figuring out what the right combinators are for Data.List.Lens and just picking those
16:12:28 <sacundim> help!  quickcheck wants me to provide a Show (t1 a) instance, where t1 is a skolem variable :-(
16:12:30 <johnw> we need a !@#$ operator, so I can pass "oh !@#$" down to my functions
16:12:53 <edwardk> fmap (oh !@#$) ...
16:13:40 <johnw> :)
16:13:59 * elliott resists the temptation to title this issue "Partial lenses suck"
16:14:06 <edwardk> feel free
16:14:18 <geekosaur> $#!+
16:14:19 <elliott> but then all the resisting would have been for naught
16:14:23 <edwardk> hah
16:14:44 <cmccann> elliott, would "partial lenses totally suck" be too terrible and/or subtle a pun?
16:15:02 <shachaf> More like "partially"
16:15:26 <rwbarton> what is (^?!)?
16:15:32 * cmccann thought the inconsistency and incongruous slang was funnier, though
16:15:37 <shachaf> @ty (^?!)
16:15:39 <lambdabot>     Not in scope: `^?!'
16:15:39 <lambdabot>     Perhaps you meant one of these:
16:15:39 <lambdabot>       `^!' (imported from Control.Lens),
16:15:41 <hpaste> Mandarin pasted “selective function import” at http://hpaste.org/78034
16:16:07 <shachaf> rwbarton: Where?
16:16:18 <edwardk> For any #haskell-ers in New York: https://twitter.com/kmett/status/271402193272311808
16:16:56 <shachaf> Mandarin: The "selective import" is for your program, not for GHC.
16:16:57 <edwardk> rwbarton: we're talking about making that the one evil 'take a traversal and extract its head, no really trust me its there' combinator. and retiring some partial lenses
16:17:13 <rwbarton> i see
16:17:15 <edwardk> :t (^?)
16:17:17 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
16:17:26 <rwbarton> interesting
16:17:29 <rwbarton> so fromJust on that
16:17:30 <edwardk> (^?!) :: s -> Getting (First a) s t a b -> a
16:17:36 <edwardk> yeah
16:17:42 <shachaf> ^‽
16:17:54 <edwardk> i originally jokingly said it should be ^interrobang ;)
16:17:59 <shachaf> Better: ‽̂
16:18:02 <shachaf> Hmm, no.
16:18:02 <rwbarton> :t (^!)
16:18:04 <lambdabot> Monad m => s -> Acting m a s t a b -> m a
16:18:05 <edwardk> shachaf: hahaha
16:18:05 <johnw> shachaf: that's a good way to reflect the evilness
16:18:16 <edwardk> sadly the ^! has a different meaning =(
16:18:20 <shachaf> ‽
16:18:30 <shachaf> The combining ^ is obscured. :-(
16:18:47 <shachaf> a ̂⸘
16:18:49 <shachaf> There we go.
16:18:50 <edwardk> not too many folks use actions though, which makes me somewhat sad
16:19:11 <shachaf> edwardk: Hmm, big crowd in NY
16:19:12 <edwardk> i wish we'd been able to derive a form for them that permitted things like strefs to be actions
16:19:14 <elliott> edwardk: issue filed
16:19:30 <elliott> https://github.com/ekmett/lens/issues/107
16:19:46 <elliott> by the way, in a few versions I will convince you to remove (^?!) as an evil partial operator :)
16:19:54 <edwardk> elliott: hahahaha
16:20:20 <elliott> also probably there is some more efficient way to write (^?!), since I see the code for (^?) has magic hashes in it
16:20:28 <edwardk> clearly it should be: ಠ_ಠ
16:20:55 <elliott> whoops, missed an opportunity for another p in that title. fixed.
16:21:02 <shachaf> elliott: help
16:21:07 <edwardk> where ಠ_ಠ takes a traversal to a lens
16:21:07 <shachaf> Make it send me another email
16:21:39 <edwardk> :t elementOf 0
16:21:41 <lambdabot> (Functor f, Num (Control.Lens.Internal.Bazaar a a t)) => Int -> LensLike f s t a a
16:21:46 <edwardk> :t flip elementOf 0
16:21:48 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> LensLike f s t a a
16:21:56 <cmccann> you should put a unicode interrobang into any partial operators, to discourage their use.
16:21:56 <elliott> edwardk: hm, making it an operator to take a traversal to a lens sounds sort of nicer
16:21:58 <edwardk> @let ಠ_ಠ = flip elementOf 0
16:21:58 <lambdabot>   Illegal character ''\3232''
16:22:00 <cmccann> that sounds like a reasonable plan.
16:22:06 <elliott> since you could just reuse ^.
16:22:20 <elliott> I guess the parens would suck though
16:22:23 <elliott> unless you could use (&) somehow
16:22:47 <shachaf> edwardk has already shown that Maybe a ~ a
16:22:54 <shachaf> So you can just turn a traversal into a Maybe lens
16:22:56 <edwardk> shachaf is really bitter about that ;)
16:23:23 <shachaf> sbahra: Are you going to edwardk's talk?
16:23:59 <edwardk>  ಠ_ರೃ would be a better lens operator.
16:24:08 <edwardk> probably something to do with loupe.
16:24:23 <shapr> haha
16:24:37 <shapr> @remember edwardk  ಠ_ರೃ would be a better lens operator.
16:24:37 <lambdabot> Okay.
16:25:09 <shachaf> @quote be.a.better
16:25:09 <lambdabot> ddarius says: Oh no! My code is more than two lines!  There must be a better way!
16:25:14 <shachaf> Oh no!
16:25:18 <shachaf> Where did ddarius go, anyway?
16:25:24 <shapr> Yah, haven't seen him lately.
16:25:27 <shachaf> "we miss u ddarius :'("
16:25:29 <edwardk> @quote lens.operator
16:25:30 <lambdabot> edwardk says:  ಠ_ರೃ would be a better lens operator.
16:25:33 <elliott> edwardk: what if you had non :: (Eq a) => a -> (forall s. (Reifies s a) => Simple Iso (Maybe a) (a `Without` s) -> r) -> r where Without has a smart constructor that reifies the s and rejects it :)
16:25:40 <shachaf> OK, so the Unicode thing isn't completely broken.
16:25:46 <edwardk> elliott: hahaha
16:25:47 <elliott> then it'd be ok!
16:26:04 <edwardk> feel free to submit that as a bug report.
16:26:16 <edwardk> i haven't marked anything 'wontfix' in quite a while ;)
16:26:23 <shapr> It's amazing how much ram I can get back by clearing the #haskell channel buffer in emacs.
16:26:37 <shachaf> It's amazing how much RAM I can get by not using Emacs.
16:27:00 <sclv>  eighty million buffers and constantly swapping
16:27:03 <shapr> shachaf: It's true. but it has so many neat features! Like haskell-stylish is built-in!
16:28:14 <edwardk> sadly the curly in ರೃ isn't in a character class that ghc will parse.
16:29:32 <rwbarton> maybe as a package name
16:32:50 <elliott> edwardk: "bug report: non exists"
16:33:07 <edwardk> elliott: =P
16:33:40 <shachaf> Sounds like a nonexistent bug to me.
16:37:08 <beaky> what is beta reduction
16:37:15 <beaky> eta reduction*
16:38:18 <mpu> eta is (\x -> f x) --> f
16:38:34 <pdxleif> http://www.haskell.org/haskellwiki/Eta_conversion
16:38:34 <Jafet> ta reduction
16:39:27 <ski> sometimes going from `foo x y z = ..x..y.. z' to `foo x y = ..x..y..' is also called "eta reduction" (though it's really extensionality)
16:39:42 <pdxleif> It's from lambda calculus.  Basically that functions that do nothing put apply another function to their argument, are equivalent to just that function.
16:39:48 <pdxleif> *but
16:39:51 <mpu> well it can be seen as a rewrite rule
16:40:07 <ski> @pl squares ns = map (\n -> n ^ 2) ns
16:40:07 <lambdabot> squares = map (^ 2)
16:40:29 <beaky> is there an alpha reduction?
16:40:33 <edwardk> (^?!) has been added
16:40:39 <ski> there's alpha-conversion
16:40:41 <beaky> oh
16:40:50 <jacobian> which basically means "up to variable renaming"
16:40:52 <beaky> why 'alpha', 'beta', and 'eta'?
16:40:54 <ski> and it means (consistently) renaming bound variables, avoiding variable capture
16:40:56 <pdxleif> Here's the three conversions: http://en.wikipedia.org/wiki/Lambda_calculus#Reduction
16:40:59 <rwbarton> alpha reduction is what happens when you let edwardk maintain your module
16:41:01 <ski> beaky : tradition
16:41:05 <beaky> oh
16:41:08 <edwardk> rwbarton: hahaha
16:41:15 <beaky> why is it even called the lambda calculus?
16:41:24 <jacobian> an accident apparently
16:41:29 <pdxleif> Mathematicians love Greek letters?
16:41:30 <monochrom> @quote rwbarton alpha reduction is what happens when you let edwardk maintain your module
16:41:30 <lambdabot> No quotes match. Sorry.
16:41:30 <edwardk> Using it in a sentence. "I alpha reduced (|>) to (&)."
16:41:33 <jacobian> It was a type setting problem
16:41:36 <monochrom> @remember rwbarton alpha reduction is what happens when you let edwardk maintain your module
16:41:37 <lambdabot> It is forever etched in my memory.
16:41:49 <jacobian> x hat, became ^x
16:41:53 <ski> beaky : sometimes in specifications of variants of the lambda calculus, you'd also have delta-rules, like e.g. : `n0 + n1 ~> n2' if `n2' is the sum of `n0' and `n1'
16:41:58 <jacobian> And then it was interpreted as \lambda x
16:42:23 <edwardk> jacobian: it was more that the typesetter thought it looked better that way. the lambda wasn't an interpretation thing so much as a preference
16:42:37 <beaky> ah
16:43:03 <pdxleif> Lambda Calculus is named so in honor of its inventor, Albert Lambda.
16:43:08 <jacobian> haha
16:43:20 <edwardk> its better than us sitting around talking about the hat calculus all day
16:43:22 <beaky> it was Alonzo Church who devised the Lambda Calculus
16:43:24 <jacobian> Church and Lambda were good friends
16:43:27 <pdxleif> Until it was superceded by Lambek Calculus
16:43:29 <beaky> oh
16:43:37 <johnny934759> is there any new haskell library for sparse vector/matrix similar to Data.Vector?
16:43:45 <pdxleif> Well, we do have Church numerals, at least.
16:43:59 <beaky> what is the difference between the Lambda Calculus and the Calculus I took in high school/undergrad uni?
16:44:04 <edwardk> johnny934759: i keep threatening to write one, but haven't actually done so
16:44:06 <elliott> it's more lambda
16:44:26 * ski wonders whether the `Zero',`Succ' thing is usually called "Peano numerals"
16:44:39 <johnny934759> edwardk: i think based off repa would be awesome
16:44:39 <startling> ski, yeah
16:44:42 <mpu> ski, it is
16:44:49 <pdxleif> Why couldn't he have called it -> calculus, instead of λ calculus?
16:44:54 <monochrom> Church wanted a long hat to indicate lexical scope, so, different hat lengths for different expressions. but the typesetter said can't do. after some exchanges, they mutually agreed a hat before the variable. then the typesetter used λ because there were more λs than hats
16:45:02 <ski> beaky : that calculus presumably was differential calculus, and integral calculus
16:45:06 <beaky> ah
16:45:15 <edwardk> johnny934759: well, sparse and repa are kind of at the opposite ends of the spectrum ;)
16:45:17 <ski> (sometimes called "infinitesimal calculus")
16:45:22 <edwardk> but api wise i can see what you mean
16:45:29 <ski> beaky : those are just some commonly known examples of calculi
16:45:34 <startling> beaky, "calculus" is a much more general word than you think
16:45:42 <beaky> what is a calculus?
16:45:44 <ski> beaky : arguably, to have a calculi, you have to have bound variables
16:45:50 <beaky> ah
16:46:01 <pdxleif> Church numerals are the ones that are functions?
16:46:06 <startling> yeah.
16:46:12 <monochrom> calculus just means mechanical rules for formula manipulation
16:46:25 <beaky> church numerals are like haskell value constructors?
16:46:34 <startling> 0 = λ f λ x x
16:46:38 <johnw> calculus also sticks to my teeth
16:46:46 <monochrom> that too!
16:46:58 <startling> beaky, not really
16:47:01 <ski> beaky : see <http://lambda-the-ultimate.org/node/533#comment-7712>
16:47:06 <monochrom> go visit your dentist to clean out calculus
16:47:29 <pdxleif> Just like they teach you "algebra", but that's just a specific instance.
16:47:38 <ski> (beaky : also see the top question there)
16:48:07 <startling> is the algebra we learn in high school given a more specific name?
16:48:30 <monochrom> my idea of algebra, generally: a special case of calculus. the rules are all equational
16:48:31 <rwbarton> high school algebra
16:48:40 <alang> ring theory?
16:48:51 <pdxleif> startling: Umm, "elementary algebra"? http://en.wikipedia.org/wiki/Algebra
16:48:57 <beaky> so Haskell is a kind of algebra?
16:48:58 <startling> pdxleif: heh
16:49:07 <startling> beaky: no, it's a calculus!
16:49:22 <beaky> haskell has algebraic data types
16:49:22 <monochrom> the algebra you learned in highschool 20 years ago is now called college algebra! XD
16:49:30 <Jafet> @google tarski high school algebra
16:49:32 <lambdabot> http://en.wikipedia.org/wiki/Tarski's_high_school_algebra_problem
16:49:39 <monochrom> soon, the college algebra you learn now will be called grad school algebra!
16:49:40 <pdxleif> I guess they changed the meaning over time. :/
16:49:49 <ski> monochrom : universal algebra ?
16:49:54 <monochrom> haha
16:50:21 <pdxleif> What they teach in high school varies wildly from country to country.
16:51:38 <ski> (monochrom : that was re "my idea of algebra, ...")
16:51:50 <monochrom> yes
16:51:59 <ski> beaky : Haskell gas bound variables
16:52:13 <ski> er, s/gas/has/
16:52:44 <Jafet> Gaskell
16:52:47 <beaky> haskell programs look like proofs
16:52:50 <elliott> edwardk: thanks, that UNSAFE is uppercase enough for me
16:52:56 <elliott> haskell programs don't look like proofs
16:52:58 <edwardk> hah =)
16:53:17 <Jafet> In ur haskell, inhabiting ur types
16:53:31 <monochrom> I think we need not argue over subjective judgements such as "look like"
16:53:49 <monochrom> but why not go meta? argue over what counts as subjective
16:54:09 <edwardk> so the question is just delete the _head, _last, etc. ones or not only kill them but mock them by renaming traverseHead etc to take their names
16:54:33 <monochrom> I suggest "perverseHead"
16:54:42 <edwardk> "evilHead"
16:54:51 <monochrom> make it long, too
16:54:56 <shachaf> elliott: Now we have a "head"-alike in lens thanks to you?
16:55:10 <shachaf> elliott, elliott, elliott. What hast thou donst.
16:55:17 <edwardk> yeah, he wanted to solve the partiality problem, but he really just made it worse
16:55:18 <edwardk> ;)
16:55:21 <Jafet> @quote unsafeHead
16:55:21 <lambdabot> Philippa says: plus who wants to get unsafeHead?
16:55:21 <monochrom> perverseInterleaveIO: http://hpaste.org/77374
16:55:49 <elliott> shachaf: I'm getting rid of the other head-alike!!
16:55:50 <elliott> or rather
16:55:54 <elliott> I told edwardk to
16:56:07 <shachaf> What, _head?
16:56:13 <startling> butt
16:56:15 <elliott> yes
16:56:18 <shachaf> But (^?!) is one that people will actually use.
16:56:25 <shachaf> Then they'll write evil code.
16:56:27 <elliott> edwardk: you can define a _tail that's more like the current _tail
16:56:29 <elliott> I think?
16:56:30 <shachaf> _head was only useful for lists.
16:56:33 <elliott> one that doesn't copy the list anyway, copying is bad
16:56:40 <elliott> it might have a weird type though
16:56:41 <shachaf> @ty dropping 1
16:56:43 <lambdabot> Applicative f => SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
16:56:52 <startling> :t let butt fn (a:b) = (a:) <$> fn b in butt
16:56:54 <lambdabot> Functor f => ([a] -> f [a]) -> [a] -> f [a]
16:56:56 <elliott> actually I can't figure out if traverseTail does copy the list
16:57:10 <ion> (^‽)
16:57:14 <rwbarton> \/|\|$/-\|-|=^.
16:57:20 <edwardk> i think i should just mark the issue resolved as it stands, and leave all the partial lenses -- as elliott breaks down into a "Noooooo!" scream like darth vader at the end of episode 3
16:57:41 <monochrom> > let x \/ y = True in 'x' \/ 'y'
16:57:42 <elliott> edwardk: i would hire shachaf to go rogue and delete everything
16:57:43 <edwardk> i think the utility of the _tail is somewhat limited though, since you can recover it from partsOf of the traversal tail that walks the elements
16:57:43 <lambdabot>   True
16:57:59 <monochrom> > let x \/|\|$/-\|-|=^. y = True in 'x' \/|\|$/-\|-|=^. 'y'
16:58:02 <lambdabot>   True
16:58:05 <edwardk> its nice that its efficient, but its existence isn't all that fundamental
16:58:06 <monochrom> onoes!
16:58:12 <elliott> right but doesn't the partsOf of traverseTail copy the list :(
16:58:14 <elliott> sharing!
16:58:22 <shachaf> traversals + sharing = hard
16:58:24 <edwardk> thank you for sharing =)
16:58:30 <monochrom> haha
16:58:37 <rwbarton> :t sharing
16:58:39 <lambdabot>     Not in scope: `sharing'
16:58:39 <lambdabot>     Perhaps you meant one of these:
16:58:39 <lambdabot>       `sparking' (imported from Control.Parallel.Strategies),
16:58:57 <edwardk> i love how everyone assumes every word stated in isolation is now a lens combinator.
16:59:08 <shachaf> @ty isolation
16:59:09 <lambdabot> Not in scope: `isolation'
16:59:15 <monochrom> zoom
16:59:39 <shachaf> elliott: Want an advanced lens exercise?
16:59:46 <shachaf> elliott: Make it so that traverseBits is useful on an Integer.
16:59:47 <monochrom> or, like they say in star trek, "computer, magnify", "computer, enhance image"
16:59:59 <elliott> shachaf: okay! no
17:00:04 <shachaf> let bz = traverseBits sell (n::Integer)
17:00:09 <shachaf> Extract n out of bz
17:00:12 <monochrom> lens is like the star trek image processor
17:00:15 <elliott> <shachaf> traversals + sharing = hard
17:00:17 <elliott> right but you could define
17:00:25 <elliott> _tail :: Simple Traversal [a] [a]
17:00:41 <rwbarton> traverseTail does not share the list according to ghc-vis
17:00:58 <shachaf> Yes, traversals don't share.
17:01:03 <edwardk> shachaf: well it at least doesn't crash now ;)
17:01:14 <elliott> shachaf: i don't think that is possible
17:01:21 <elliott> traverseBits returns something infiniteish
17:01:24 <elliott> but Integer is strict
17:01:26 <shachaf> What doesn't crash now?
17:01:37 <shachaf> elliott: Right, but what if you could tell the traversal "ok im done now thx"
17:01:40 <edwardk> shachaf: well, traverseBits when i first wrote it crashed when you used it to fold an integer
17:01:43 <shachaf> So it would "share" the infinite tail.
17:01:47 <elliott> how will you know when you're done
17:01:47 <edwardk> > 512^..traverseBits
17:01:49 <lambdabot>   [False,False,False,False,False,False,False,False,False,True,False,False,Fal...
17:02:00 <elliott> edwardk: nooo, you made (^?!) faster
17:02:01 <elliott> now people will use it
17:02:03 <elliott> I regret everything
17:04:56 <edwardk> i'm going to twist the knife for a while, leaving _head, etc. in while I go get dinner and decide how to fix up the traversal issue =P
17:04:58 <shachaf> What was the funny export list issue?
17:05:20 <edwardk> shachaf: it had the section for elementOf, double commented out, but they were in another section
17:05:33 <edwardk> er elementOf and element were
17:05:48 <edwardk> just a consequence of merging
17:05:49 <shachaf> Oh.
17:06:29 <shachaf> I'll add a test for infinite elementOf
17:06:30 <otters> :t _head
17:06:32 <lambdabot>     Not in scope: `_head'
17:06:32 <lambdabot>     Perhaps you meant one of these:
17:06:32 <lambdabot>       `head' (imported from Data.List),
17:06:45 <otters> :t (^?!)
17:06:46 <lambdabot>     Not in scope: `^?!'
17:06:47 <lambdabot>     Perhaps you meant one of these:
17:06:47 <lambdabot>       `^!' (imported from Control.Lens),
17:07:07 <elliott> otters: neither of those exist
17:07:29 <elliott> edwardk: I bet (^?!) is slow!
17:07:53 <shachaf> elliott: You should switch it out for elementOf 0
17:08:06 <beaky> @pl \x -> x >= 50000 && x <= 100000
17:08:06 <lambdabot> liftM2 (&&) (>= 50000) (<= 100000)
17:08:18 <beaky> :t liftM2
17:08:20 <lambdabot> Monad m => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
17:08:43 <beaky> @pl \x -> 50000 <= x <= 100000
17:08:44 <lambdabot> (line 1, column 21):
17:08:44 <lambdabot> unexpected "1"
17:08:44 <lambdabot> expecting space
17:08:44 <lambdabot> ambiguous use of a non associative operator
17:08:49 <beaky> oops
17:09:02 <pdxleif> startling: If you want to be a purist, I think you should call it "al-ğabr".
17:09:06 <elliott> oh right
17:09:08 <elliott> edwardk: I hate elementOf too
17:09:33 <shachaf> elliott: Do you hate it more or less now that it works for Fold?
17:09:43 <elliott> I hate everything equally
17:10:15 <elliott> anyway if you do
17:10:29 <elliott> foo = f <$> 0 <*> foo
17:10:42 <elliott> then can you write a Traversal that detects this sharing? I think no, because it'd break RT
17:10:58 <Jafet> Al-ğabraik al-Khwārizmī
17:11:01 <elliott> so the only way you can make traverseBits work properly is by making it something other than a SimpleIndexedTraversal
17:11:07 <shachaf> elliott: Yes.
17:11:10 <shachaf> "but what"
17:11:38 <elliott> class (Applicative f) => Applicative! f where lotsofzeroes :: f Bool
17:11:41 <elliott> job done
17:11:59 <elliott> you don't want to do this anyway because you'll have to write a billion instances and traverseBits won't work on an applicative out of the box
17:12:06 <cmccann> "Applicative! : the musical"
17:15:37 <startling> pdxleif, if I want to be a pursit, I'll call it diophantining. or maybe fibonaccing.
17:16:11 <startling> *purist
17:16:21 <pdxleif> touché
17:17:06 <pdxleif> Algebra started as a means of abstraction, and then they came along and abstracted algebra itself.
17:17:55 <dimituri> can someone please explain why am i not allowed to do this: https://github.com/uploadcare/uploadcare-haskell/blob/error-handling/src/Web/Uploadcare/Internal.hs#L97 ?  GHC complains that there's "No instance for (FromJSON a)"
17:17:59 <startling> pdxleif: and then we forgot to give variables letters for ~1000 years. :(
17:19:05 <dimituri> as soon as i put something concrete in place of "a" in "Either String a" everything builds a-ok
17:19:53 <startling> dimituri: weird. can you paste the whole error?
17:20:16 <dimituri> ah wait
17:20:23 <dimituri> it's actually src/Web/Uploadcare/Internal.hs:87:22
17:20:46 <dimituri> No instance for (FromJSON a) arising from a use of `parseResponse' In the expression: parseResponse res
17:21:19 <rwbarton> right, you'll need to add a (FromJSON a) constraint to the type signature of queryRequest, because parseResponse need sit
17:21:23 <startling> aha
17:21:41 <ski> dimituri : like `queryRequest :: FromJSON a => Client -> Method -> ByteString -> IO (Either String a)'
17:21:59 <dimituri> yep, got it
17:22:03 <dimituri> silly me
17:22:16 <ski> btw, your `(Done _ r)     -> ...' and `(Fail _ _ err) -> ...' could drop the brackets
17:22:20 <dimituri> builds now, thanks
17:22:58 <ski> dimituri : in `request', you can replace all but the first `let' with three spaces
17:23:36 <ski> hrm, or maybe not the last one, because of how you indented the record update
17:24:14 <dimituri> needs reindenting and simply a style check
17:24:20 <dimituri> not now though
17:30:35 <ew0> now I needed a profiler to know how much time is spent in each function
17:30:50 <SethRobertson> Stupid newbee question: how do you specify a where clause in a filter or function during a ghci interactive session?
17:31:30 <ski> SethRobertson : perhaps you want `let <decls> in <expr>' ?
17:31:41 <Jafet> Stupid answer: you cannot
17:31:54 <aavogt> > let x = 1 + y where y = 2 in x
17:31:55 <lambdabot>   3
17:33:05 <ski> `let f x = 1 + y where y = 2 * x' works fine in my GHCi
17:34:07 <SethRobertson> As it does for me.  How about this example?  let foo = head (filter p [100000,99999..] where p x = x `mod` 3829 == 0)
17:34:30 <ski> `where' attaches to definitions, not to expressions
17:34:31 <shachaf> This question has nothing to do with ghci.
17:34:38 <shachaf> It has to do with how "where" works.
17:34:54 <ski> `let foo = head (filter p [100000,99999..]) where p x = x `mod` 3829 == 0' would work
17:35:08 <SethRobertson> Thanks, that was what I was missing
17:35:12 <ski> as would `let foo = head (let p x = x `mod` 3829 == 0 in filter p [100000,99999..])'
17:36:21 <ski>   let foo = head [x | x <- [100000,99999..] , x `mod` 3829 == 0]  -- perhaps looks nicer
17:36:44 <shachaf> > [100000,99999..]^?folded.filtered (\x -> x `mod` 3829 == 0)
17:36:46 <lambdabot>   Just 99554
17:37:07 <sipa> :t (^?)
17:37:08 <lambdabot> s -> Getting (First a) s t a b -> Maybe a
17:37:52 * hackagebot idna 0.1.2 - Implements IDNA (RFC 3490).  http://hackage.haskell.org/package/idna-0.1.2 (GeorgePollard)
17:38:07 <SethRobertson> So should I ask why removing the "let foo =" doesn't let it continue to work?
17:38:30 <shachaf> SethRobertson: Because 17:34 <ski> `where' attaches to definitions, not to expressions
17:38:59 <ski> SethRobertson : `foo = ..some expression here..' is a definition, `..some expression here..' is an expression
17:39:03 <Jafet> where should be allowed to be attached to expressions
17:39:20 <SethRobertson> Thanks.  I'm just trying to wrap my head around the terminology and usage
17:39:59 <shachaf> Saying that "where" is attached to "=" or "->" is wrong, though.
17:40:06 <ski> in the elder days, lambdabot would accept `> x ^ 2 where x = 17'
17:42:53 * hackagebot email-validate 0.3.1 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-0.3.1 (GeorgePollard)
17:43:13 <pdxleif> > let 2 + 2 = 5 in 2 + 2
17:43:15 <lambdabot>   5
17:43:56 <Ralith> o.O
17:44:09 <startling> Ralith, it's defining (+)
17:44:23 <Ralith> startling: ahh.
17:44:39 <startling> for some reason that always gets people, myself included.
17:44:58 <startling> > let 2 + 2 = 5 in 0 + 0
17:44:59 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
17:45:13 <Ralith> probably because we're not used to seeing pattern that type of matching in let
17:45:17 <startling> yeah
17:45:22 <startling> @src on
17:45:22 <lambdabot> (*) `on` f = \x y -> f x * f y
17:45:38 <startling> ^ that type of thing is weird and cool, to
17:46:07 <beaky> :t (.)
17:46:09 <lambdabot> Functor f => (a -> b) -> f a -> f b
17:46:14 <beaky> :t Prelude.(.)
17:46:16 <lambdabot> Not in scope: data constructor `Prelude'
17:46:21 <beaky> :t Prelude..
17:46:23 <lambdabot> parse error on input `Prelude..'
17:46:26 <beaky> :(
17:46:26 <startling> haha
17:46:31 * ski would often call equivalence or comparator arguments `(==)' alt. `compare'
17:46:37 <ski> @type (Prelude..)
17:46:39 <lambdabot> (b -> c) -> (a -> b) -> a -> c
17:46:57 <ski> (that's how you take the section of a module-qualified operator)
17:47:08 <startling> oh, right
17:47:10 <startling> that's like
17:47:11 <startling> :t .
17:47:12 <lambdabot> parse error on input `.'
17:47:47 <ski> @type let infixr 9 .; (.) = (Prelude..) in (.) . (.)
17:47:48 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:47:53 * hackagebot email-validate 0.3.2 - Validating an email address string against RFC 5322  http://hackage.haskell.org/package/email-validate-0.3.2 (GeorgePollard)
17:48:05 <beaky> @src  (.)
17:48:05 <lambdabot> (f . g) x = f (g x)
17:48:06 <lambdabot> NB: In lambdabot,  (.) = fmap
17:49:19 <ski> Cale : `flip' apparently is reverted in lambdabot :(
17:51:10 <shachaf> ski: Yes, people complained.
17:51:14 * shachaf <-
17:52:31 * ski initially interpreted that as shachaf saying he also complained about it being reverted
17:53:46 <startling> shachaf just complains.
17:53:51 <startling> he doesn't care what you do.
17:56:22 <startling> wow, I didn't realize Church had $. he called it ., though
17:57:35 * ski . o O ( $., )
17:57:45 <startling> he also said "When, in omitting square brackets, the initial bracket is replaced by a bold dot .,it is to be understood that the scope of the omitted pair of brackets is from the dot forward the maximum distance which is consistent with the whole expression's being well-formed or interpretable as an abbreviation of a well-formed formula." which I'm sure makes the grammar a thousand times more complicated.
18:00:13 <elliott> Haskell has rules like that, too
18:00:36 <ski> startling : there's also a convention when talking about sexprs that a final `]' closes as many `)'s as are needed to get a well-formed sexpr
18:01:14 <startling> elliott: really?
18:01:46 <elliott> yeah
18:02:16 <startling> note that Church's rules about well-formedness include type correctness.
18:02:48 <startling> elliott: what rules?
18:03:52 <shachaf> startling: That's the . in ∀x. P(x), too!
18:03:58 <shachaf> "Church's dot", I've heard it called.
18:04:09 <startling> shachaf: oh huh, neat.
18:04:17 <startling> thought that was just syntax.
18:04:29 <shachaf> Maybe it is.
18:04:35 <elliott> startling: something about lambdas
18:04:38 <elliott> they extend as far as possible
18:04:41 <elliott> except I think that got changed
18:04:45 <elliott> because nobody implemented it
18:04:59 <startling> elliott, that's different from "As far as possible to get a result that typechecks" though
18:05:09 <ski> in <http://www.funmath.be/>, they use `x. E' as a lambda-expression
18:05:43 <startling> e.g. I'd be able to do \x -> 12 <$> [1, 2, 3]
18:06:56 * ski thinks `foo \x -> ..x..' should be valid syntax (and also with `foo case ...',`foo if ...',`foo let ... in ...',`foo do ...')
18:07:11 <startling> ski: me too.
18:07:37 <ski> (that'd get rid of the main uses of `$' for me)
18:08:57 <startling> sometimes I do let (<&>) = flip fmap in x <&> \a -> ...
18:09:02 <startling> just so that I don't need parens.
18:11:06 * ski has been known to call that `pamf'
18:11:12 <startling> haha
18:11:13 <ski>   x `pamf` \a -> ...
18:11:20 <edwardk> elliott: ok, back, now that i've let you squirm for a while i'll try to figure out what the heck we can do about all these partial lenses
18:11:35 <byorgey> sounds like one of those sound effects from old batman shows
18:11:37 <startling> edwardk, call them monocles
18:11:43 <byorgey> smack! biff! pamf!
18:12:01 <ski>   (`fmap` x) $ \a -> ...  -- is an alternative
18:13:01 <startling> oh, that's nice
18:13:11 <monochrom> http://a.tgcdn.net/images/products/additional/large/f020_sodium_batman.jpg
18:13:12 <startling> I wish I could just do x `flip fmap` y
18:13:28 <ski> > let pam = flip map in [0 .. 4] `pam` \x -> [0 .. 3] `pam` \y -> x ^ y
18:13:30 <lambdabot>   [[1,0,0,0],[1,1,1,1],[1,2,4,8],[1,3,9,27],[1,4,16,64]]
18:13:36 <t7> sometime fitting everything on one line is not the best idea
18:13:46 <t7> i found that when trying to read my old code
18:13:46 <hpc> monochrom: negative neutrons?
18:14:03 <startling> t7: right, so it's nice to let the lambda go to the next line without having to use parens
18:14:06 <monochrom> no, "na na na na na ... batman!" in the song
18:14:12 <t7> its 10% of lines compared to C++ but i spend much longer to read it again
18:14:29 <t7> or name the function :)
18:14:35 <t7> anyway good night
18:16:39 <hpc> monochrom: look at the atomic number and weight
18:16:48 <hpc> it's got 27 protons and -16 neutrons
18:16:49 <monochrom> hmm!
18:16:55 <Eduard_Munteanu> Yes, it also looks like Batman has multiple isotopes.
18:17:06 <hpc> er, -8
18:17:53 * hackagebot stringprep 0.1.5 - Implements the "StringPrep" algorithm  http://hackage.haskell.org/package/stringprep-0.1.5 (GeorgePollard)
18:17:55 * hackagebot edge 0.8.12 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.12 (ChristopherHoward)
18:18:55 <startling> I wonder if Church and his buddies competed to write shortest derivations of e.g. N : oα' .
18:19:06 <startling> good thing he didn't know about pointfree.
18:21:22 <shachaf> startling: in retrospect were you joking
18:21:27 <shachaf> "elliott"
18:21:41 <startling> shachaf, ?
18:22:56 <shachaf> Never mind.
18:26:26 <startling> k
18:32:46 <deus_rex> hehehe, uncurry is such a nice little thing
18:33:22 <ski> are you `zip'ping ?
18:34:25 <deus_rex> hamming xs ys = length $ filter (uncurry (/=)) $ zip xs ys
18:36:43 * ski would replace the initial `$' there with `.'
18:37:46 <johnw> me too
18:38:06 <ski>   hamming xs ys = length . filter id $ zipWith (/=) xs ys  -- not sure whether you'd prefer this version or not
18:38:57 <deus_rex> ahh, I was trying to solve it with zipWith but hadn't thought to use id with filter
18:40:03 <deus_rex> that's much cleaner :)
18:42:20 * vreg climbs into a robot dinosaur suit and sneaks up on Canar...
18:47:10 <johnw`> שחף: hi
18:49:18 <shachaf> hi Guest98424
18:49:37 <Guest98424> that was your name :)
18:49:38 <Nereid> deus_rex: ski: of course that only works if xs and ys have the same length
18:50:24 <johnw> ah, i'm back
18:50:27 <shachaf> johnw: Not much of a secret.
18:50:39 <johnw> didn't know if you read hebrew or not
18:51:34 <shachaf> Unfortunately my IRC client shows it LTR.
18:52:41 <johnw> ערב טוב שחף
18:52:51 <johnw> mine only recently gained the ability to go RTL
18:52:51 <XexonixXexillion> I'm compiling GHC 6.12.3 with GHC 6.12.3 and I keep getting cannot find -lHSrtsmain
18:53:20 <geekosaur> mine's LTRing it too :(
18:53:20 <vreg> johnw: challenge accepted
18:53:27 * vreg skewers johnw with a lightsaber.
18:53:38 <geekosaur> braindead
18:53:53 <johnw> ack, I'm in halves!
18:53:55 <XexonixXexillion> does anyone know how to fix it so it'll shut up and compile?
18:54:40 <vraid> pidgin RTLs it
18:55:30 <vraid> shame i can't read any of it
18:55:33 <XexonixXexillion> libHSrtsmain.a is in /usr/local/lib/ghc-6.12.3/ and the aforemention path is in /etc/ld.so.conf
18:57:19 <JoeyA> How does the documentation for the Win32 package get built?  Does somebody build it on Windows and upload it manually?
19:00:12 <shachaf> ski: It's probably my terminal that's to blame, not my IRC client.
19:01:23 <ski> hm, is the terminal supposed to auto-mirror sequences of glyphs from an RTL script ?
19:02:13 <ski> what should happen if you reposition the cursor and change the contents of a cell in the middle to an LTR glyph ?
19:02:52 <johnw> for me, that just splits the RTL region
19:03:24 <johnw> the meaning of the ← and → keys in reversed in such regions, as well as the direction of insertion, but that's really all that changes
19:04:39 <ski> johnw : is that also the case for programmatic change of the cell ?
19:05:58 <tejaswidp> I have a question (it might seem stupid)
19:06:04 <johnw> i haven't done much RTL programming, actually, just typing
19:10:19 <tejaswidp> Is evaluating a primitive type different from output?
19:10:31 <tejaswidp> how is it different?
19:10:42 <johnw> i don't know what you mean, tejaswidp
19:10:53 <edwardk> :t sets
19:10:53 <JoeyA> > (1,2,3)
19:10:55 <lambdabot>   (1,2,3)
19:10:55 <lambdabot> Settable f => ((a -> b) -> s -> t) -> (a -> f b) -> s -> f t
19:10:56 <edwardk> :t sets map
19:10:59 <lambdabot> Settable f => (a -> f b) -> [a] -> f [b]
19:11:06 <tejaswidp> johnw: Instead of printing out a string "hello world"
19:11:06 <JoeyA> Are you talking about what you see when you say "print (1,2,3)" ?
19:11:13 <tejaswidp> I could just evaluate it
19:11:15 <edwardk> > ("tibbe",["doesn't","like"],2 :: Int,(),IntMap.fromList [(23,"lenses")]) & biplate.sets map %~ toUpper
19:11:17 <lambdabot>   Not in scope: `IntMap.fromList'
19:11:18 <lambdabot>  Perhaps you meant `IM.fromList' (imported ...
19:11:25 <edwardk> > ("tibbe",["doesn't","like"],2 :: Int,(),M.fromList [(23,"lenses")]) & biplate.sets map %~ toUpper
19:11:27 <lambdabot>   Not in scope: `&'
19:11:33 <edwardk> > ("tibbe",["doesn't","like"],2 :: Int,(),M.fromList [(23,"lenses")]) % biplate.sets map %~ toUpper
19:11:37 <lambdabot>   ("TIBBE",["DOESN'T","LIKE"],2,(),fromList [(23,"lenses")])
19:11:49 <JoeyA> tejaswidp: GHCi uses the Show instance of the type to render its values.
19:11:53 <edwardk> heh, borked data instance for map still ;)
19:11:55 <johnw> tejaswidp: evaluating doesn't necessarily have anything to do with printing
19:12:01 <JoeyA> To make a string like that yourself, use the 'show' function.
19:12:08 <JoeyA> > show (1,2,3)
19:12:10 <lambdabot>   "(1,2,3)"
19:12:14 <JoeyA> > show "Hello"
19:12:16 <lambdabot>   "\"Hello\""
19:12:28 <JoeyA> > (show . show) "Hello"
19:12:30 <lambdabot>   "\"\\\"Hello\\\"\""
19:12:34 <Nereid> > fix show
19:12:34 <JoeyA> > fix show
19:12:36 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
19:12:36 <lambdabot>   can't find file: L.hs
19:12:41 <JoeyA> great minds think alike
19:12:43 <Nereid> :p
19:13:16 <edwardk> > ("tibbe",["doesn't","like"],2 :: Int,(),IntMap.fromList [(23,"lenses")]) % biplate  %~ toUpper
19:13:18 <lambdabot>   Not in scope: `IntMap.fromList'
19:13:18 <lambdabot>  Perhaps you meant `IM.fromList' (imported ...
19:13:24 <edwardk> > ("tibbe",["doesn't","like"],2 :: Int,(),M.fromList [(23,"lenses")]) % biplate  %~ toUpper
19:13:27 <lambdabot>   ("TIBBE",["DOESN'T","LIKE"],2,(),fromList [(23,"lenses")])
19:13:43 <tejaswidp> johnw: can you plepase tell me how it is different
19:13:52 <JoeyA> Lemme guess: lambdabot is running on Windows.
19:14:17 <JoeyA> And if two people give it commands at once, the two threads handling it access the file simultaneously.
19:14:53 <tejaswidp> (I am working with scheme here but I can't seem to wrap my head around why display is actuallly required)
19:14:55 <JoeyA> Leading to the "can't find file" error
19:15:31 <Nereid> JoeyA: I don't believe it runs on windows.
19:15:49 <JoeyA> > maxBound :: Int
19:15:50 <lambdabot>   9223372036854775807
19:15:55 <elliott> edwardk: are you saying tibbe doesn't like lenses, perhaps
19:16:06 <edwardk> elliott: fairly loudly even ;)
19:16:09 <JoeyA> Nereid: I think you're right.
19:16:16 <Nereid> lol
19:16:18 <JoeyA> lambdabot has been 64 bit for a long time.
19:16:35 <JoeyA> 64-bit support for Windows was added very recently.
19:16:41 <JoeyA> for GHC for Windows
19:16:45 <elliott> is this to do with the whole libraries list thing
19:17:11 <edwardk> it was a reddit thing, i wanted to reply to him with an example that showed them do something better ;)
19:18:56 <Nereid> :t biplate
19:18:58 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
19:19:23 <Nereid> mhm
19:19:48 <Nereid> > ("tibbe",["doesn't","like"],2 :: Int,(),M.fromList [(23,"lenses")]) ^. biplate :: String
19:19:50 <lambdabot>   "tibbedoesn'tlike"
19:19:57 <edwardk> heh
19:20:00 <Nereid> oh it can't get inside the Map
19:21:07 <elliott> edwardk: that tuple modification is an unfortunate example for a tutorial :(
19:21:13 <elliott> uncompelling and syntactically noisy
19:21:52 <Nereid> :t _2 +~ 1
19:21:54 <lambdabot> (Num a, Field2 s t a a) => s -> t
19:22:07 <statusfailed> edwardk: What exacly is "witnessed type equality"? I can't figure out what Data.Machine.Is is for :)
19:22:53 <edwardk> statusfailed: its used in machines partially applied, so  Is a b   tells you a ~ b.
19:23:00 <edwardk> look at Process
19:24:39 <edwardk> type Process a b = Machine (Is a) b
19:24:40 <statusfailed> I can't see how type Process a b = Machine a b would be different
19:24:44 <statusfailed> :\
19:24:52 <edwardk> a has the wrong kind
19:24:58 <statusfailed> oh
19:25:18 <edwardk> i need a type k such that k x    entails that x ~ a.
19:25:36 <statusfailed> ahhh right
19:25:39 <edwardk> that 'k = Is a'
19:25:46 <statusfailed> got it!
19:25:49 <edwardk> Is a x    gives you a ~ x
19:25:51 <statusfailed> that's sneaky
19:26:12 <statusfailed> Ok cool, cheers!
19:26:19 <edwardk> await uses the 'id' from the category for Is
19:26:25 <edwardk> that way it reads from its only input channel
19:26:46 <rwbarton> why can't biplate get inside the Map? lame Data instance for Map?
19:26:56 <rwbarton> I know it needs a custom one but I thought it had fakery involving to/fromList
19:27:10 <edwardk> rwbarton: the fix for Data instance for Map and IntMap was already pushed through the libraries@ mailing list
19:27:20 <rwbarton> ah ok
19:27:22 <edwardk> it only had one dir for fromList
19:27:25 <rwbarton> :t H.fromList
19:27:27 <lambdabot> Couldn't find qualified module.
19:27:30 <edwardk> it didn't have the gunfoldl part
19:27:53 <edwardk> i pushed for fake constructors that look like the functions and won, just not sure when it'll go into the platform
19:29:37 <edwardk> rwbarton: http://haskell.1045720.n5.nabble.com/Proposal-Allow-gunfold-for-Data-Map-Data-IntMap-etc-td5716865.html
19:29:49 <crdueck> is it possible to get ghc/ghci to typecheck a haskell expression from the command line? something like (this doesnt work obviously) "ghci -c :t map odd" would produce "map odd :: Num a => [a] -> [Bool]"
19:30:52 <hpc> echo ":t map odd" | ghci
19:30:53 <monochrom> ghc -e ':type id'
19:30:53 <Nereid> echo ':t map odd' | ghci
19:30:57 <hpc> heh
19:31:09 <hpc> you have to do some extra crap to make it not so noisy
19:31:12 <Nereid> monochrom: oh that works.
19:31:15 <monochrom> I guess ghc -e ':type map', too
19:31:16 <Nereid> oh.
19:31:21 <Nereid> I was trying ghci -e, no wonder it wasn't working.
19:31:31 <crdueck> monochrom: perfect, thanks
19:32:38 <Nereid> I wonder if ghci can do something better if it detects that stdin isn't a pty
19:33:32 <hpc> monochrom: argh, i can't believe that works
19:33:45 <hpc> lambdabot does it by interacting with a ghci process
19:33:49 <hpc> wtf
19:34:28 <rwbarton> and horrendous regular expressions
19:34:37 <rwbarton> :type map
19:34:45 <Nereid> @type map
19:34:47 <lambdabot> (a -> b) -> [a] -> [b]
19:34:49 <rwbarton> oh right
19:34:58 <Nereid> @t map
19:34:59 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
19:35:02 <Nereid> of course
19:35:15 <rwbarton> is there really a "thank you" command
19:35:18 <Nereid> @. djinn type map
19:35:21 <lambdabot> Error: Undefined type []
19:35:21 <hpc> @thank you
19:35:22 <lambdabot> Maybe you meant: thank you thanks
19:35:25 <elliott> @thank
19:35:26 <lambdabot> Maybe you meant: thank you thanks
19:35:26 <hpc> @thanks
19:35:27 <rwbarton> @thank_you
19:35:27 <lambdabot> you are welcome
19:35:28 <elliott> @you
19:35:28 <lambdabot> you are welcome
19:35:29 <lambdabot> Couldn't find fortune file
19:35:30 <hpc> what
19:35:33 <rwbarton> i see
19:35:37 <Jafet> gunfold sounds like a decent movie title
19:35:37 <rwbarton> elliott: :(
19:35:39 <Nereid> @. djinn type flip
19:35:41 <lambdabot> f a b c = a c b
19:35:58 <rwbarton> critical missing bits of lambdabot functionality
19:35:58 <Nereid> @. free type flip
19:36:00 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
19:36:01 <roadfish> Still new-to-Haskell and coming from Python. (33,44)[1] gives 44 in Python but Haskell-no-like. let (x,y)=(33,44) in y gives 44 ... but is there anything tighter?
19:36:06 <Nereid> oh right
19:36:14 <Nereid> @free flip -- we still have this I guess
19:36:16 <lambdabot> (forall x. h . k x = p (f x) . g) => h . flip k y = flip p (g y) . f
19:36:24 <elliott> roadfish: snd (33,44)
19:36:26 <rwbarton> interesting
19:36:31 <rwbarton> I wonder how @free gets the type?
19:36:36 <rwbarton> it can't be worse than how :t does it
19:36:42 <Nereid> > snd (33,44)
19:36:44 * Eduard_Munteanu wants a @seen command in lambdabot
19:36:44 <lambdabot>   44
19:36:46 <Nereid> > fst (33,44)
19:36:48 <lambdabot>   33
19:36:56 <Nereid> note: fst and snd only work for 2-tuples
19:37:07 <roadfish> elliott:thanks. And I see that Nereid seconds that answer.
19:37:09 <rwbarton> @ticker
19:37:11 <Nereid> @type fst
19:37:14 <hpc> you normally don't work with tuples larger than 2
19:37:15 <lambdabot> (a, b) -> a
19:37:18 <lambdabot> Empty ticker.
19:37:32 <statusfailed> edwardk: one more thing- I can't quite figure out what k is in the Machine/MachineT definitions
19:37:47 <statusfailed> (sorry to keep pestering you :D)
19:38:03 <roadfish> snd good enough for now. I was getting the results from "break".
19:38:04 <rwbarton> for the record it's "ghci -v0"
19:38:04 <edwardk> statusfailed: 'k' plays the role of the input channel type. a process is what you are used to with pipes, etc. its a machine that takes one input
19:38:16 <Nereid> roadfish: if you want something that works for larger tuples, you could write your own function.
19:38:17 <edwardk> Process a b = Machine (Is a) b
19:38:19 <edwardk> k = Is a
19:38:25 <Nereid> > let snd3 (_,a,_) = a in snd3 (12,34,56)
19:38:27 <lambdabot>   34
19:38:28 <statusfailed> oh! k is "how to get inputs"?
19:38:29 <edwardk> but there can be machines that take multiple inputs
19:38:38 <edwardk> Tee a b c = Machine (T a b) c
19:38:45 <Nereid> > (12,34,56) ^. _2   -- or you could use lens
19:38:47 <lambdabot>   34
19:38:49 <Jafet> @pl snd.break p
19:38:49 <lambdabot> snd . break p
19:38:50 <Nereid> :v
19:38:55 <Nereid> :t view _2
19:38:56 <lambdabot> Field2 s t a b => s -> a
19:39:01 <edwardk> so you can 'awaits L' or 'awaits R' when building a plan for a 'Tee'
19:39:07 <edwardk> statusfailed: yeah
19:39:30 <statusfailed> ah, and T is k for Tee
19:39:38 <Nereid> roadfish: also, welcome, and enjoy your stay ;)
19:39:42 <edwardk> 'Wye' is like 'Tee' but you can also block waiting on input for either side without caring which comes first.
19:39:54 <edwardk> it allows a bit of non-determinism in
19:40:53 <edwardk> you can 'cap' one of the inputs of a 'Tee' by tying it to a source. a source might be monadic where it has the side-effects directly. or it much just generate a fixed input stream. and there are ways to 'preload' values into a hopper more or less that will be pulled by whatever you connect it to
19:41:11 <edwardk> the machines model is similar but different to the pipes model.
19:41:27 <statusfailed> it feels more like dataflow and automata
19:41:28 <edwardk> in machines you write plans, then you build machines from the plans
19:41:33 <statusfailed> as far as I can judge anyway
19:41:56 <statusfailed> I'm trying to write a "total idiot's guide to Machines", mainly for myself :)
19:41:57 <roadfish> lambdabot Int
19:41:58 <Nereid> edwardk: I thought a bit about having a lens for IORef but I couldn't come up with anything. :(
19:42:00 <edwardk> once you have the machines you can connect them up with tees, and cap off the inputs you aren't concerned with
19:42:19 <roadfish> lambdabot:Int
19:42:21 <Nereid> :t lens readIORef writeIORef
19:42:23 <lambdabot>     Not in scope: `readIORef'
19:42:23 <lambdabot>     Perhaps you meant `readSTRef' (imported from Data.STRef)
19:42:23 <lambdabot>     Not in scope: `writeIORef'
19:42:29 <Nereid> :t lens readSTRef writeSTRef
19:42:31 <lambdabot> Functor f => (ST s b -> f b) -> STRef s b -> f (ST s ())
19:42:36 <edwardk> and when you've streamlined it down to a process you can compose it onto the output of another machine using ~> or <~
19:42:37 <Nereid> kinda useless
19:42:50 <edwardk> Nereid: not a legal lens i'm afraid
19:42:53 <roadfish> is there a ways to talk privately with lambdabot? I tried "/msg lambdabot Int" but nothing happened.
19:42:54 <Nereid> that too
19:43:03 <Nereid> roadfish: well, Int doesn't mean anything to lambdabot ;)
19:43:04 <rwbarton> roadfish: lambdabot does not care about "Int"
19:43:15 <rwbarton> try "> 2+2" or "@type map"
19:43:16 <Nereid> roadfish: you can give it the same commands as in here, just make sure they're prefixed with @
19:43:18 <edwardk> Nereid: i tried to concoct a version of 'Action' that would let me write MonadicLens, etc. but it didn't work out so well
19:43:20 <monochrom> /msg lambdabot is right, Int is a syntax error
19:43:30 <johnw> edwardk: when are you going to prove the theory of lenses in Agda?
19:43:35 <rwbarton> sometimes I yell at lambdabot in PM
19:43:41 <Nereid> rwbarton: haha
19:43:41 <edwardk> johnw: thats copumpkin's job. he wants dependent lenses
19:44:08 <rwbarton> 10:26 <rwbarton> thanks man   -- lambdabot PM
19:44:18 <rwbarton> little did I know I could use the @thx command!
19:44:25 <Nereid> @thx
19:44:25 <lambdabot> you are welcome
19:44:26 <edwardk> @thx
19:44:27 <lambdabot> you are welcome
19:44:43 <rwbarton> @thx lambdabot
19:44:44 <lambdabot> you are welcome
19:45:09 <statusfailed> @THX 1138
19:45:09 <lambdabot> Unknown command, try @list
19:45:16 <ski> edwardk : please, no <nabble.com>. <http://www.haskell.org/pipermail/libraries/2012-August/018366.html>
19:45:29 <rwbarton> there is one command that doesn't work so well in PM though: @get-shapr
19:45:36 <edwardk> ski: i just googled it, didn't even notice where it came back from ;)
19:45:41 <edwardk> @get-shapr
19:45:41 <lambdabot> shapr!!
19:45:51 <shapr> You called?
19:46:03 <rwbarton> see, when I PM'd lambdabot that nothing happened :)
19:46:05 <edwardk> still works
19:46:08 <shapr> hah
19:46:15 <johnw> edwardk: heh, just found https://groups.google.com/forum/?fromgroups=#!topic/bostonhaskell/aIhVNRdWOPk
19:46:58 <rwbarton> gentle introduction to category theory haha
19:47:28 <monochrom> it worked for me
19:47:28 <edwardk> i was particularly proud of that message
19:47:38 <edwardk> Particularly easy-to-follow theorems include the interchange law, which he was able to prove with only 9 universes: https://github.com/pumpkin/categories/blob/master/Category/NaturalTransformation.agda#L133
19:47:58 * ski . o O ( `putShapr :: Shapr -> IRC ()' )
19:47:58 <rwbarton> failing to prove associativity of horizontal composition for natural transformations was what turned me off agda
19:48:28 <rwbarton> oh maybe I mean vertical composition
19:48:30 <Nereid> that link doesn't work :(
19:48:40 <rwbarton> whichever one says the functor category is a category
19:48:52 <Nereid> that's vertical
19:48:54 <rwbarton> yeah
19:48:59 <edwardk> https://github.com/copumpkin/categories/blob/master/Categories/NaturalTransformation/Core.agda#L95 is apparently the new link
19:49:13 <rwbarton> I proved addition was commutative, and then I wanted to prove the Yoneda lemma, and failed miserably
19:50:46 <copumpkin> rwbarton: I have a proof of that!
19:50:52 <Nereid> now prove that there is a unique conic passing through 5 points in the projective plane if and only if no 3 points are collinear :(
19:51:06 <edwardk> copumpkin: did you used to pumpkin on github?
19:51:10 <rwbarton> well I was trying to do it without setoids so I'm pretty sure I was doomed from the start
19:51:14 <copumpkin> edwardk: yeah
19:51:14 <monochrom> it will only take 19 universes
19:51:15 <edwardk> er did you use to have?
19:51:27 <edwardk> ah
19:51:39 <copumpkin> I figured I'd try to homogenize across sites
19:51:43 <edwardk> ah
19:52:24 <johnw> copumpkin: watching your Agda intro presentation now
19:52:26 <johnw> good stuff
19:52:28 <copumpkin> oh shit
19:52:52 <johnw> you may Agda seem less completely foreign than what I've seen elsewhere
19:52:54 <johnw> make*
19:53:11 <Nereid> I can't focus. :(
19:53:23 <johnw> Nereid: I am a master procrastinater
19:53:32 <ski> @type focus
19:53:35 <lambdabot> (Functor f, Indexed (Tape (h :> a)) k) => k (a -> f a) ((h :> a) -> f (h :> a))
19:53:37 <johnw> in fact, I bet I could earn a PhD if assigned a sufficiently onerous task
19:53:38 <Nereid> johnw: me too
19:53:43 <Nereid> lol
19:54:17 <copumpkin> johnw: I'm glad!
19:55:12 <roadfish> copumpkin:where is the presentation?
19:55:15 <rwbarton> isn't this just the definition of horizontal composition
19:55:27 <copumpkin> somewhere on edwardk's youtube profile
19:55:29 <johnw> https://www.youtube.com/watch?v=shXKb2MTkUc&feature=relmfu
19:55:57 <rwbarton> associativity should have four categories and six functors and three natural transformations and lord knows how many universes
19:56:00 <rwbarton> twelve I guess
19:56:04 <edwardk> you probably want https://www.youtube.com/watch?v=shXKb2MTkUc&list=PLB7F836675DCE009C&feature=g-list
19:56:10 <edwardk> that gets you the entire playlist
19:56:52 <copumpkin> rwbarton: https://github.com/copumpkin/categories/blob/master/Categories/NaturalTransformation.agda
19:56:57 <copumpkin> you can find all the ugliness in there if you want :)
19:57:08 <copumpkin> the other one is just the definition of the operations
19:57:12 <copumpkin> oh wait
19:57:19 <copumpkin> edwardk already linked to it, nevermind
19:57:54 <rwbarton> well it wasn't the link I was looking at, and it was the link I was looking for, so thanks
19:58:25 <literal_username> Hi all, I'm new here. I'm trying to build xmonad-utils. When I `./Setup.lhs build`, I get this: http://sprunge.us/aDLO -- any ideas what's going on?
19:59:58 <statusfailed> is 'copointed' basically 'a structure in which there exists a unique element based on some criteria'?
20:00:19 <literal_username> In case it helps, src/Hslock.hsc is: http://sprunge.us/QZZZ?hs
20:00:43 <copumpkin> rwbarton: probably a lot uglier than it needs to be. We never got around to making a full 2-category structure for them
20:01:36 <shachaf> literal_username: Which version of GHC are you using?
20:01:53 <rwbarton> the proof itself is not really that bad. it looks about like what proofs of this sort of thing look like when you write them out equationally in math, only with a lot more subscripts on everything
20:01:55 <shachaf> It's using an old API which is gone in 7.6
20:02:11 <literal_username> schlumpi: Yep, 7.6.1
20:02:14 <rwbarton> but it would be cool if you could extract the proof term from a diagram somehow
20:02:26 <copumpkin> rwbarton: yeah. Most of the proofs in that library aren't that bad, and most of the pain is just getting enough stuff in scope to do it, and figuring out what all the subscripts should be
20:02:27 <literal_username> shachaf: Yep, 7.6.1
20:02:40 <literal_username> spelling...
20:02:42 <shachaf> literal_username: OK, then it won't work. :-)
20:02:48 <literal_username> shachaf: Thanks.
20:02:58 <shachaf> You'll need to import Control.Exception and quite possibly change some code.
20:03:02 <Nereid> statusfailed: the first interesting example of a Copointed is (,) a
20:03:15 <Nereid> statusfailed: where you have copoint = snd :: (a,b) -> b
20:03:59 <dibblego> s/Copointed/Comonad
20:04:09 <rwbarton> (why does getEnv raise an exception if the variable doesn't exist, anyways??)
20:04:09 <Nereid> yes, it's a comonad too
20:04:19 <Nereid> (every comonad is copointed, obviously.)
20:04:35 <dibblego> just trying to keep "interesting" description alive (Copointed is never interesting)
20:04:35 <rwbarton> oh there is a thread about this isn't there
20:04:43 <rwbarton> getEnv never fails on POSIX, or something?
20:05:07 <edwardk> dibblego: =)
20:05:14 <rwbarton> so confusing
20:05:52 <rwbarton> literal_username: since you are on 7.6 you can replace 'd <- catch (getEnv "DISPLAY") ( const $ return [])' by 'd <- lookupEnv "DISPLAY"'
20:05:55 <statusfailed> Nereid: I haven't actually looked into comonad
20:06:15 <literal_username> rwbarton: Thanks, trying it...
20:06:35 <rwbarton> (But why does the documentation for lookupEnv claim "For POSIX users, this is equivalent to getEnv."?)
20:07:34 <rwbarton> ((And why did anyone ever think that returning IO String rather than IO (Maybe String) was a good idea in the first place?))
20:07:48 <literal_username> rwbarton: Thanks, it works, and I'm on to my next error.
20:08:06 <geekosaur> there was a long argument on -cafe about that.  I still think it's fundamentally broken
20:08:07 <literal_username> Is there a good resource for a newbie to learn about what changed in 7.6?
20:08:08 <monochrom> because IO already has an exception mechanism
20:08:28 <geekosaur> but apparently it'sconsidered proper and correct and use the POSIX one instead if you want sane behavior, or something
20:08:34 <rwbarton> geekosaur, which is fundamentally broken, the old way?
20:08:59 <geekosaur> returning a Maybe instead of throwing an exception was adjudged to be improper behavior
20:08:59 <lispy> monochrom: but it's considered bad for to use exceptions for things that commonly fail.
20:09:09 <lispy> form*
20:09:14 <geekosaur> you can hunt down the mailing list thread if you want; I'm still too p****d about iut
20:09:54 <rwbarton> oh, I see, that POSIX one
20:10:09 <geekosaur> why do we have a Maybe type if we'er supposed to throw exceptions for not-found?
20:10:26 <Nereid> at least lookupEnv exists now
20:10:29 <geekosaur> and why are we doing Java-y APIs in core Haskell?
20:11:27 <Nereid> and I guess if you don't care about exceptions or Maybe, you could just
20:11:28 <monochrom> openFile :: FilePath -> IOMode -> IO (Maybe Handle)
20:11:31 <rwbarton> literal_username: oh wait I lied
20:11:39 <Nereid> instead of 'x <- getEnv blah', 'Just x <- lookupEnv blah'
20:11:46 <rwbarton> d <- fmap (fromMaybe "") $ lookupEnv "DISPLAY"
20:12:43 <Nereid> yes, while you're at it why not openFile :: FilePath -> IOMode -> IO (Either IOError Handle)
20:12:44 <monochrom> withFile :: FilePath -> IOMode -> (Handle -> IO (Maybe a)) -> IO (Maybe a)
20:13:33 <rwbarton> well if I open a file, chances are I planned to subsequently read or write from that file, and the file not existing may change my plans
20:13:42 <monochrom> the problem with "bad form if commonly fail" is: what is "commonly"?
20:14:04 <rwbarton> perhaps it is a limit of my imagination but I think normally if I try to read an environment variable, and it doesn't exist, I am going to use some default value and continue going about my business
20:14:10 <lispy> monochrom: For Map-like data structures, a normal lookup would be a common operation.
20:14:12 <literal_username> rwbarton: Lies require an intent to deceive. :P
20:14:25 <rwbarton> in other words almost always the getEnv will be wrapped immediately in a 'e'catch
20:14:28 <rwbarton> 'catch'
20:14:38 <lispy> monochrom: but, I take your point. In the case of openFile it's a grey area to me.
20:14:54 <sw17ch> any one have a good tutorial on Arrows?
20:15:09 <Jafet> http://ro-che.info/ccc/12.html
20:15:24 <statusfailed> edwardk: Is there a mistake in the haddocks for Plan? it says "types based on i", but there is no 'i' type variable
20:15:41 <monochrom> map is pure-functional. getEnv is as map-like as hGetLine
20:15:52 <Jafet> Exceptions and error types are mechanisms. I don't know why people think about them as policies.
20:16:11 <edwardk> statusfailed: its a reference to the way the types used to work. k used to take two parameters, so it worked with 'k i'
20:16:22 <edwardk> i should fix that
20:16:32 <edwardk> can you put in an issue in the tracker to remind me?
20:16:36 <statusfailed> sure, will do
20:17:08 <lispy> monochrom: morally the env is [(String,String)], even if you have to do IO to get at that list.
20:17:22 <rwbarton> it's not like the IO to get that list is going to fail
20:17:25 <lispy> monochrom: or maybe Data.Map String String since it doesn't allow duplicates
20:17:47 <Jafet> "Save the environment"
20:17:49 <monochrom> no, getEnv is not pure-functional. another thread can change it behind your back every time you read again. it's like hGetLine
20:19:08 <monochrom> morally the env is an ever-changing set of IORefs
20:19:15 <lispy> oh boy
20:19:25 <rwbarton> okay, it's like an IORef (Map String String)
20:19:29 <lispy> I think I'm done here
20:21:44 <monochrom> you can use getEnvironment :: IO [(String,String)] if you want
20:21:57 <Jafet> @hoogle getEnv
20:21:57 <lambdabot> System.Environment getEnv :: String -> IO String
20:21:58 <lambdabot> System.Environment getEnvironment :: IO [(String, String)]
20:21:58 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
20:22:30 <monochrom> but as far as getEnv goes, it certainly has a slightly different semantics from IO [(String,String)]
20:23:37 <Jafet> Well, this is a minor infelicity compared to what getProgName returns
20:25:08 <Nereid> :t getProgName
20:25:10 <lambdabot> Not in scope: `getProgName'
20:25:13 <Nereid> @hoogle getProgName
20:25:13 <lambdabot> System.Environment getProgName :: IO String
20:25:21 <Nereid> what's wrong with it?
20:25:42 <Jafet> It returns basename(argv[0])
20:25:51 <Nereid> oh. :(
20:35:52 <Crockeo> I don't know if anyone I was talking to last night is on but I've gotten to section 8 on L(earn)Y(ou)AH(askell) and I'm on the subject of type constructors.
20:36:03 <Crockeo> So Maybe is a type constructor (or can be implemented as one)
20:36:09 <Cale> Yes, it is
20:36:10 <Crockeo> does that mean IO is just another type constructor?
20:36:13 <Cale> yes
20:36:22 <Jafet> :k IO
20:36:23 <lambdabot> * -> *
20:36:25 <Crockeo> It all makes sense now!
20:36:31 <ski> @kind Maybe
20:36:33 <lambdabot> * -> *
20:36:38 <ski> @kind Either Int
20:36:40 <lambdabot> * -> *
20:36:45 <dmwit> Crockeo: beautiful, ain't it?
20:37:09 <Crockeo> dmwit: Though it was initially nearly impossible for me to learn, yes, yes it is.
20:37:11 <Nereid> :k Either
20:37:13 <lambdabot> * -> * -> *
20:37:17 <Crockeo> Goddamn I love this language
20:37:23 * ski grins
20:37:26 <Nereid> :>
20:37:36 <latermuse> im really liking this article about lenses: http://newartisans.com/2012/11/getting-started-with-lenses/
20:37:40 <johnw> oh, just you wait
20:37:46 <johnw> latermuse: thanks!
20:38:27 <Crockeo> Everyone always says Haskell gets better and better, I can't help but agree.
20:38:37 <latermuse> Its the perfect amount of information to get started with lenses, and not worry about the inner workings of it all.
20:38:40 <johnw> Crockeo: it most certainly does
20:38:55 <edwardk> i think it might have been more compelling to chain 'set' than to mash the symbols in the bigger example until folks get comfortable with the fixity stuff
20:39:01 <Nereid> the best part about lens is the things that aren't lenses though :)
20:39:07 <edwardk> Nereid: =)
20:39:22 <edwardk> had I it to name over i would have called the package 'traversals'
20:39:29 <johnw> edwardk: i only avoided that because in real world use, almost no one is going to chain set
20:39:40 <Jafet> @quote kesselrun
20:39:41 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
20:39:42 <shachaf> edwardk: And called every module "Foo.Bar.Travesals"?
20:39:46 <johnw> edwardk: but lenses is a much sexier name
20:39:55 <Crockeo> I just realized how stupid I was to ask if you could convert an IO String to a string; that's like trying to convert 'data Vector a = a a' to a tuple.
20:39:56 <shachaf> johnw: "lenses" is already taken.
20:39:57 <latermuse> agreed. lens is very sexy
20:40:02 <johnw> i meant, lens
20:40:09 <Nereid> Crockeo: no, it's not like that, it's much much worse
20:40:12 <shachaf> Crockeo: Converting Vector to a tuple is eas.
20:40:18 <Crockeo> Oh god
20:40:23 <Jafet> Foo.Bar.TravelingSalesman
20:40:25 <johnw> "lens" sounds like something you *have* to learn to be cool.  "traversals" just sounds like a mundane feature of the language
20:40:43 <Nereid> johnw: heh
20:41:06 <Crockeo> Nereid, shachf: I guess I'll just keep on reading and hopefully come back with another sudden realization.
20:41:16 <johnw> Crockeo: that's the whole fun of it :)
20:41:19 <shachaf> @quote /bin/ls
20:41:20 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:41:21 <shachaf> Crockeo: ☝
20:41:22 <edwardk> At least lens maintains my tradition of ending most of my packages with "-s".
20:41:42 <johnw> sadly, it's very hard to hear Conor in his Agda intro
20:41:51 <johnw> i can hear edwardk's laugh though :)
20:42:03 <edwardk> It is a library all about how to use a "len"
20:42:10 <Nereid> :v
20:42:12 <edwardk> the agda intro is dan peebles
20:42:13 <shachaf> > @let lenOf = lengthOf
20:42:15 <lambdabot>   <hint>:1:1: parse error on input `@'
20:42:17 <johnw> edwardk: next will be proving CT using lensoids
20:42:32 <johnw> I watched Dan
20:42:34 <johnw> now I'm watching Conor
20:42:37 <johnw> you are at both :)
20:42:40 <edwardk> link?
20:42:43 <johnw> https://www.youtube.com/watch?v=vQXIABaDgjo&list=PL44F162A8B8CB7C87&index=1&feature=plpp_video
20:42:49 <liyang> When do we get colensoids?
20:43:09 <rwbarton> i don't know about the "oids" but i've been thinking about colenses
20:43:09 * ski . o O ( `both .~ edwardk' )
20:43:25 <edwardk> i think that is someone else with an edwardk-like laugh in the second case.
20:43:32 <johnw> ah
20:43:44 <johnw> you feature prominently in part 5/5 of Dan's talk :)
20:43:49 <edwardk> hah
20:45:00 <edwardk> there is also alec (who only lurks here by reading the logs, hi alec) and ddarius chatting away in that section
20:45:09 <johnw> haha
20:45:11 <johnw> hi alec!
20:45:17 <startling> we're from your past!
20:45:40 <johnw> happy will have having met you!
20:46:34 <latermuse> is there a hackage page for lens yet?
20:46:43 <shachaf> @google lens hackage
20:46:46 <johnw> yes
20:46:46 <lambdabot> http://hackage.haskell.org/package/lenses-0.1.6
20:46:46 <edwardk> @hackage lens
20:46:46 <lambdabot> Title: HackageDB: lenses-0.1.6
20:46:47 <lambdabot> http://hackage.haskell.org/package/lens
20:46:49 <shachaf> Whoops.
20:46:49 <johnw> but Hoogle doesn't find it
20:46:52 <johnw> @hoogle biplate
20:46:52 <lambdabot> No results found
20:47:02 <johnw> my local Hoogle finds it just fine
20:47:26 <latermuse> can you send the link?
20:47:32 <latermuse> im not finding it
20:47:33 <edwardk> @hackage lens
20:47:33 <lambdabot> http://hackage.haskell.org/package/lens
20:47:35 <edwardk> ^--
20:47:46 <latermuse> oh sorry! haha thanks
20:48:18 <johnw> latermuse: also see the wiki at github.com/ekmett/lens
20:48:31 <johnw> it has some other examples and a good operator reference
20:49:03 <shachaf> I ought to write a proper introduction to lens so I can stop Caling it on IRC.
20:49:24 <johnw> are you calling mine improper? :)
20:49:28 <latermuse> thanks
20:49:54 <edwardk> shachaf: feed the wiki!
20:50:09 <johnw> edwardk: when my series is finished, i'll edit it into a single document and put it on the wiki
20:50:15 <edwardk> johnw: good =)
20:50:30 <shachaf> I don't like wikis. :-(
20:50:57 <roadfish> too many brutal edit-wars
20:51:10 <johnw> i want to evolve it slowly toward the full magic of biplate.  the next logical area to cover would be "extending lens", which is where I would think shachaf should come in
20:51:26 <johnw> (if I have my choice)
20:51:54 <shachaf> I agree with tibbe on "let x = 1 in _1 +~ x $ _3 +~ x $ _5 +~ x $ (1,1,1,1,1)" vs. "let (a,b,c,d,e) = (1,1,1,1,1) in (a+1, b, c+1, d, e+1)"
20:52:09 <shachaf> The latter seems much clearer to me.
20:52:18 <latermuse> yes, but the first example can work on tuples greater than 5
20:52:23 <shachaf> Also "supports any size tuple" is completely orthogonal to lens.
20:52:39 <shachaf> And I don't know when I would ever want code that's polymorphic on tuple size in practice.
20:52:45 <shachaf> Ever want to export such code, that is.
20:52:50 <johnw> a proper lens document should cover: usage, theory, implementation, related libraries.  edwardk is great at #2, shachaf at #3, and I'm trying to address #1
20:52:54 <shachaf> _1 etc. just seems like a naming convenience to me.
20:53:23 <johnw> where did tibbe make that comment?
20:53:23 <edwardk> yeah _1.._9 aren't something i even pretend are fundamental, they are just darn convenient
20:53:37 <edwardk> reddit.com/r/haskell in the thread for your post
20:53:37 <latermuse> johnw: reddit
20:53:43 <johnw> ah, i always forget to check there
20:53:56 <edwardk> http://www.reddit.com/r/haskell/comments/13l9vj/getting_started_with_lenses/
20:54:09 <edwardk> i decided to post a couple of fun examples poking fun at his grumpiness ;)
20:54:16 <johnw> thanks for the clarification edwardk
20:54:27 <johnw> but that example needs improving
20:54:31 <johnw> i don't want to counter-sell lens
20:55:20 <shachaf> I think neither johnw's nor edwardk's examples there are particularly good motivation for lenses. :-)
20:55:26 <edwardk> _1 +~ x $ _3 +~ x $ _5 +~ x $ (1,1,1,1,1)     does read better as set _1 x . set _3 x . set _5 x $ (1,1,1,1,1)    or something
20:55:30 <johnw> so, what's a better example here?
20:55:38 <edwardk> shachaf: feel free to barrage him with better ones.
20:55:48 <edwardk> i'm sure if we all shout at him louder the message will get through ;)
20:55:54 <shachaf> I try to stay off Reddit. :-)
20:55:58 <johnw> i've got the file open to rewrite now :)
20:56:06 <johnw> i agree what I have here looks garish
20:56:08 <shachaf> Also I don't know a really good compact motivation for lenses.
20:56:21 <johnw> well, "both" is a good motivation all by itself
20:56:24 <shachaf> johnw: I think nested read/write on records is the biggest thing.
20:56:26 <Crockeo> (I love that in LYAH the hello world tutorial is in the 9th chapter)
20:56:34 <johnw> shachaf: I want to get to records after the fundamental types
20:56:37 <shachaf> That's motivation for lenses, not "lens".
20:56:47 <shachaf> Eh, records are better than tuples.
20:56:54 <shachaf> Tuples are meaningless.
20:56:54 <johnw> tuples are more accessible
20:57:01 <johnw> think of the person who wants to just dip his toes into lens
20:57:08 <johnw> using them on records requires setup work
20:57:12 <sacundim> Crockeo, i saw your remark earlier.  it's not stupid to ask for an IO String -> String function; most every other language has that as a noop :-)
20:57:17 <johnw> but using "over both" is almost like a Prelude-level utility function
20:57:26 <shachaf> sacundim: Not as a noop.
20:57:35 <ski> shachaf : hawiki was nice
20:57:39 <shachaf> Usually as "foo()" or whatever you want to call it.
20:57:40 <latermuse> tuples is a good way to show how lenses work for a beginner
20:57:41 <sacundim> schachaf: bad choice of words
20:57:43 <Nereid> @type let f :: IO String -> String; f x = "HELLO" in f
20:57:45 <lambdabot> IO String -> String
20:57:48 <edwardk> the low hanging fruit for folks who want to dabble in lenses are things like tuples, maps, sets, and some basic ADTs of their own
20:58:08 <Crockeo> sacundim: Coming from an imperative language one assumes that there should be a way to do that, but I've learned that I have to throw out everything I've learned from imperative programming.
20:58:10 <sacundim> "Hello world" and getLine() are interchangeable in most languages
20:58:10 <edwardk> and some recursive examples involving lists of structures, etc.
20:58:18 <johnw> shachaf: oh, and in the next entry I want to cover the basic terminology, basically copying your "heuristic"
20:58:24 <shachaf> sacundim: Sure, but "Hello world" and getLine aren't. :-)
20:58:31 <sacundim> exactly
20:58:40 <shachaf> sacundim: In other languages, I mean.
20:58:54 <Nereid> johnw: it would have been cool if your examples for both had tuples with different elements.
20:58:56 <shachaf> Anyway, that's a pointless argument, so I'll stop.
20:59:00 <Jafet> :t both
20:59:00 <shachaf> I should also write about the other things that I keep complaining that there isn't enough about. Like quantification.
20:59:01 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
20:59:08 <johnw> Nereid: you mean, different types?
20:59:11 <Jafet> What would the one for (a, a, a) be called
20:59:11 <Nereid> no
20:59:18 <Nereid> > both +~ 1 $ (3,4)
20:59:20 <rwbarton> troth
20:59:21 <lambdabot>   (4,5)
20:59:25 <johnw> ah, ok, I'll make that change
20:59:32 <Nereid> obviously you can't use both on tuples of different types
20:59:34 <sacundim> schachaf: you mean polymorphic types or dependent types by "quantification"?
20:59:42 <Jafet> Thus quoth rwbarton
20:59:46 <latermuse> if I have (123,"meow"), how can i change the "meow" to "bark" using lenses?
20:59:55 <shachaf> Class Allof'em t a | t -> a where allof'em :: SimpleTraversal t a
20:59:56 <latermuse> using lens i mean
21:00:06 <edwardk> > (123,"meow") & _2 .~ "bark"
21:00:07 <lambdabot>   Not in scope: `&'
21:00:12 <edwardk> > (123,"meow") % _2 .~ "bark"
21:00:14 <lambdabot>   (123,"bark")
21:00:29 <Nereid> @let (&) = ($); infixl 1 &
21:00:33 <lambdabot>  Defined.
21:00:39 <latermuse> ok. im going to save that somewhere for future reference
21:00:39 <shachaf> Nereid: Not quite.
21:00:44 <Nereid> haha. oops
21:00:47 <Nereid> @undefine
21:00:50 <Nereid> @let (&) = flip ($); infixl 1 &
21:00:53 <lambdabot>  Defined.
21:01:05 <edwardk> > (123,"meow") & _2 .~ "bark"
21:01:09 <Nereid> or I could have written (%)
21:01:09 <lambdabot>   (123,"bark")
21:01:26 <Nereid> (123,"meow") & _2 .~ False
21:01:28 <Nereid> > (123,"meow") & _2 .~ False
21:01:31 <lambdabot>   (123,False)
21:02:23 <latermuse> johnw: you should put an example like this in your tutorial
21:02:36 <johnw> which?
21:02:46 <Nereid> of set _2
21:02:49 <Nereid> or so
21:02:50 <johnw> i'm going to use "set" now
21:02:51 <latermuse> the meow to bark in a tuple
21:02:53 <johnw> as edwardk suggested
21:03:02 <latermuse> set _2
21:03:33 <edwardk> > (123,"meow") & set _2 False
21:03:35 <lambdabot>   (123,False)
21:03:36 <latermuse> set _2 "bark" meow
21:03:42 <edwardk> is less scary to people getting started
21:03:49 <edwardk> only one operator to hold in your head at a time
21:03:59 <ski> latermuse : use `> '
21:04:02 <latermuse> set _2 "bark" (123,"meow")
21:04:08 <latermuse> > set _2 "bark" (123,"meow")
21:04:10 <lambdabot>   (123,"bark")
21:04:29 <edwardk> > (123,"meow") & over _2 length
21:04:31 <lambdabot>   (123,4)
21:04:35 <johnw> this is like a collaborative IRC wiki edit
21:04:53 <johnw> ok, check now guys: http://tech.wp.newartisans.com/2012/11/getting-started-with-lenses
21:04:59 <johnw> I've tried to incorporate all the feedback
21:05:04 <edwardk> > (123,"meow") & over (_2.mapped) toUpper
21:05:06 <lambdabot>   (123,"MEOW")
21:05:11 <johnw> and address tibbe's grumpiness
21:05:30 <johnw> edwardk: that kind of stuff will come a few articles from now, but that's the real motivation ;)
21:05:30 <latermuse> thats cool edward
21:05:45 <Nereid> johnw: mainly I wanted (3,4) for the .~ example
21:05:46 <Nereid> :p
21:05:59 <edwardk> notice how lenses were able to change the types involved. and how 'mapped' let it update multiple targets with a Char -> Char function.
21:06:01 <johnw> once we can get people comfortable with traversals, then the idea of mutating the traversed data set will come naturally
21:06:12 <edwardk> > (123,"meow") & over (_2.mapped) ord
21:06:15 <lambdabot>   (123,[109,101,111,119])
21:06:18 <johnw> Nereid: you mean, (3,4) -> (9,9)?
21:06:22 <Nereid> yeah
21:06:26 <johnw> ok, i'll change it for ya
21:06:33 <Nereid> I mean I'm sure it gets the idea across just fine as it is
21:06:38 <latermuse> mutating data types
21:06:38 <rwbarton> where is the "replace all values with the minimum" lens operator
21:06:39 <Nereid> :p
21:07:05 <edwardk> rwbarton: its some complicated mess using partsOf
21:07:10 <Nereid> :t minimumOf
21:07:13 <lambdabot> Getting (Control.Lens.Internal.Min a) s t a b -> s -> Maybe a
21:07:15 <Nereid> ah it exists.
21:07:17 <johnw> Nereid: done
21:07:25 <edwardk> > minimumOf both (1,2)
21:07:27 <lambdabot>   Just 1
21:07:33 <Nereid> > minimumOf traverse []
21:07:37 <lambdabot>   Nothing
21:07:53 <latermuse> i didnt realize how amazing lens is until today!
21:07:56 <latermuse> so cool!
21:08:02 <Nereid> :)
21:08:04 <johnw> every one of these one-liners edwardk posts in this channel, i copy off to a "notes.txt" file
21:08:09 <Nereid> haha
21:08:16 <johnw> and I want to find a way to work them all into this tutorial series
21:08:21 <johnw> because they all rock!
21:08:24 <Nereid> grep '<edwardk> >' irc.log
21:08:43 <johnw> a personal favorite:
21:08:44 <johnw> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate._head %~ toUpper
21:08:46 <lambdabot>   Not in scope: `_head'
21:08:47 <lambdabot>  Perhaps you meant one of these:
21:08:49 <lambdabot>    `head' (imported ...
21:08:53 <latermuse> minimumOf both (1,2) works on a 2-tuple. what if i want to do it on a n-tuple? minimumOf all (1,2,3,4,5)
21:08:57 <johnw> (("Hello","World"),"!!!",2,())
21:09:08 <edwardk> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate.traverseHead %~ toUpper
21:09:09 <rwbarton> hmm, is there a Minimum newtype of Maybe somewhere?
21:09:10 <lambdabot>   Not in scope: `traverseHead'
21:09:11 <lambdabot>  Perhaps you meant one of these:
21:09:11 <lambdabot>    `traverseM...
21:09:15 <Nereid> latermuse: there's no generalization of both to larger tuples
21:09:22 <johnw> when edwardk gets type errors using lens, I feel his is more human
21:09:22 <Jafet> @instances Monoid
21:09:23 <Nereid> well, you could write it yourself
21:09:23 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
21:09:25 <johnw> he*
21:10:01 <edwardk> @let _head :: Simple Traversal [a] a; _head = iwhere (==0)
21:10:04 <lambdabot>  Defined.
21:10:13 <edwardk> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate._ead %~ toUpper
21:10:16 <edwardk> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate._head %~ toUpper
21:10:16 <johnw> yeah, like: triad f (a,b,c) = (,,) <$> f a <*> f b <*> f c
21:10:17 <Jafet> Cute
21:10:19 <lambdabot>   Not in scope: `_ead'
21:10:19 <johnw> that's both for a 3-tuple
21:10:23 <lambdabot>  Perhaps you meant one of these:
21:10:25 <lambdabot>   mueval-core: Time limit exceeded
21:10:27 <lambdabot>    `read' (imported f...
21:10:42 <Nereid> > let all3 f (a,b,c) = (,,) <$> f a <*> f b <*> f c in (1,2,5) & all3 *~ 2
21:10:45 <johnw> edwardk: something like all3, all4, all5, would be useless but good analogues to both
21:10:45 <lambdabot>   (2,4,10)
21:10:47 <johnw> heh
21:10:58 <latermuse> johnw: so "both" needs to be rewritten for whatever size n-tuple you are using?
21:11:04 <johnw> latermuse: yes
21:11:17 <edwardk> latermuse: sadly. inference isn't good enough to figure out all the right things to do for those
21:11:19 <johnw> but a lot of Haskell is oriented toward pairs, so it's not that much a biggie
21:11:28 <Crockeo> (Does anyone have a good explanation of what the <- operator does? I know how to use it in context, but I don't know what it does.)
21:11:28 <johnw> like shachaf said, tuples are easy to demonstrate, but they aren't the selling case
21:11:38 <sacundim> crockeo, it's not really an operator
21:11:39 <Nereid> Crockeo: it's not an operator
21:11:42 <sacundim> it's syntax sugar
21:11:47 <rwbarton> it's part of the syntax of do notation (and various other things)
21:11:52 <Crockeo> Syntax sugar for /what/ then?
21:11:57 <latermuse> johnw: yeah, having all3, all4, all5 as examples in hackage might be nice to show people how they might go about writing their own allN
21:11:57 <Nereid> Crockeo: it's syntactic sugar: do { x <- m; n } = m >>= (\x -> n)
21:12:04 <johnw> do notation and pattern matching
21:12:08 <johnw> and list comprehensions
21:12:19 <Nereid> (well, ignoring issues with failed pattern matches and ...)
21:12:22 <Crockeo> Alright! Thank you!
21:12:41 <edwardk> johnw: maybe streamline the example ghci> let x = 9 in set _1 x . set _3 x $ (1,1,1,1,1)    ==>   (9,1,9,1,1)   by eliminating the let binding?
21:12:48 <Nereid> agreed
21:12:53 <latermuse> Would using lens over records be more ideal than tuples?
21:12:56 * hackagebot yesod-form 1.2.0.1 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.0.1 (MichaelSnoyman)
21:12:58 <edwardk> > set _1 9 . set _3 9 $ (1,1,1,1,1)
21:13:00 <lambdabot>   (9,1,9,1,1)
21:13:18 <edwardk> latermuse: makeLenses will automatically construct lenses for your record type for you
21:13:41 <johnw> latermuse: personally speaking, unless you deal in nested records, lens is excess baggage for records
21:13:43 <edwardk> makeClassy will do so and make a class for your type, that helps it find it, so if you have structures of structures you can use the lenses for your 'children' directly
21:13:48 <latermuse> or vectors even
21:13:51 <edwardk> let me give an example
21:14:12 <Nereid> time to go
21:14:15 <edwardk> latermuse: https://github.com/ekmett/lens/blob/master/examples/Turtle.hs
21:14:21 <edwardk> def & forward 10 & down & color .~ red % turn (pi/2) & forward 5
21:14:24 <johnw> edwardk: edit made
21:14:45 <edwardk> see https://github.com/ekmett/lens/blob/master/examples/Turtle.hs#L55 in there. heading is a field of 'Turtle' turned into a lens
21:14:54 <edwardk> as are 'x' and 'y'
21:15:09 <edwardk> which it inherited from the fact that it has a Point, and it has an instance of HasPoint
21:15:43 <edwardk> forward d t =    t & y +~ d * cos (t^.heading)        & x +~ d * sin (t^.heading)  -- is a pretty nice way to write the turtle movement function
21:17:29 <ski> > ((traverse .~) . fromJust . minimumOf traverse) `join` [4,2,8,5,7]
21:17:31 <lambdabot>   [2,2,2,2,2]
21:17:32 <edwardk> with a little work, e.g. setting up a Writer that tracked line segments you could turn that into a functioning, functional logo implementation.
21:17:52 <edwardk> > (set traverse . fromJust . minimumOf traverse) `join` [4,2,8,5,7]
21:17:55 <lambdabot>   [2,2,2,2,2]
21:18:23 <edwardk> :t \l -> set l . fromJust . minimumOf l
21:18:25 <lambdabot>     Couldn't match expected type `Accessor
21:18:26 <lambdabot>                                     (Control.Lens.Internal.Min a0) b0'
21:18:26 <lambdabot>                 with actual type `Mutator a0'
21:18:52 <edwardk> :t \l -> join (set (cloneTraversal l) . fromJust . minimumOf (cloneTraversal l))
21:18:52 <ski> presumably it's possible to both return the minimum and the updated structure in one traversal ?
21:18:54 <lambdabot> Ord b => ((b -> Control.Lens.Internal.Bazaar b b b) -> s -> Control.Lens.Internal.Bazaar b b t) -> s -> t
21:18:55 <XexonixXexillion> I was compiling GHC 6.12.3 and it had a heart attack, printed garbage and said please report this as a GHC bug. Should I do it, or just not care because it's so old?
21:18:58 <monochrom> w00t, HWN!
21:19:11 <johnw> bye Nereid
21:19:15 <johnw> thanks for your help
21:19:34 <edwardk> ski: probably with a laziness trick, like the linear time tree minimizer
21:19:52 <ski> yes, i meant by tying a knot
21:19:57 <edwardk> yep
21:19:59 <johnw> edwardk: did you fix something to make biplate descend into Map values?
21:20:07 <johnw> that didn't work for you here in channel earlier today...
21:20:12 <edwardk> johnw: you need a version of containers that has been patched
21:20:20 <johnw> ah
21:20:25 <johnw> i'll just wait for that to come down the pike
21:20:28 <edwardk> i have an open libraries request for it that passed the deadline
21:20:34 <rwbarton> > let replaceWithMax t s = let (result, Just m) = fmap (`appEndo` Nothing) $ runWriter (t (\v -> tell (Endo $ max (Just v)) >> return m) s) in result in replaceWithMax both (3,4)
21:20:36 <lambdabot>   (4,4)
21:20:39 <ski> what i wondered was whether there already was some easy way to both yield a folded result and an updated version
21:20:42 <edwardk> so it just needs tibbe/milan to put it in and both were in favor
21:20:50 <johnw> nice
21:21:04 <rwbarton> this turned out rather worse than I hoped
21:21:21 <johnw> hmm, i think I'll need to update here, to get my examples for that to work
21:21:32 <johnw> since i do this all in literate Haskell
21:21:45 <shapr> johnw: bird tracks or LaTeX?
21:21:49 <johnw> i think your example is funny in the reddit comments
21:21:51 <johnw> shapr: bird tracks
21:21:55 <johnw> + Markdown
21:21:58 <edwardk> just don't use biplate into maps until that goes into containers
21:22:01 <johnw> + MathJax
21:22:06 <johnw> edwardk: ok
21:22:15 <roadfish> how do I ask for the version of Haskell or of various libraries? Hoogle/google talks about Data.Version but that seems to require you already have the version string.
21:22:28 <johnw> shapr: also, BlogLiterately auto-verifies the ghci example outputs
21:23:19 <johnw> edwardk: is there no unfoldr' because the semantics are different enough it would just confuse people?
21:23:24 <edwardk> video of tibbe's reaction while writing that post: https://www.youtube.com/watch?feature=player_embedded&v=DhjLBmZqJKU
21:23:25 <otters> edwardk: I just saw your comment on that recent reddit post about lenses
21:23:28 <otters> yeah
21:23:32 <otters> okay you're talking about it now
21:23:34 <otters> my brain exploded
21:23:38 <johnw> lol
21:23:43 <edwardk> otters: the biplate examples?
21:23:45 <otters> yeah
21:24:04 <edwardk> it is really nice that the uniplate stuff ported so well to lens
21:24:07 <otters> where is biplate
21:24:10 <edwardk> Data.Data.Lens
21:24:17 <otters> ...
21:24:26 <shachaf> edwardk: You should stuff Data.Data.Lens into data-lens
21:24:31 <edwardk> shachaf: ahhahaha
21:24:46 <johnw> shapr: y
21:24:49 <johnw> shapr: https://github.com/jwiegley/posts/blob/master/Getting%20Started%20with%20Lenses/lens-intro.lhs
21:24:53 <johnw> that's the source file
21:25:11 <edwardk> i may eventually export biplate and uniplate from Control.Lens, since GHC.Generics.Lens doesn't currently offer optimized versions like those
21:25:12 <shachaf> johnw: What's with the Control.Category?
21:25:16 <johnw> i have no idea
21:25:19 <johnw> just noticed that too
21:25:25 <johnw> i bet I copied this file from someplace else
21:25:26 <johnw> i do that
21:25:37 <edwardk> yeah you can drop lines 7 and 8
21:25:58 <shachaf> Unless you like isomorphisms.
21:26:05 <johnw> i _love_ isomorphisms
21:26:12 <shachaf> Let's rephrase that.
21:26:14 <shachaf> Unless you like Isomorphisms.
21:26:21 <edwardk> well, unless you like using "from (some iso . some other iso)"
21:26:34 <edwardk> otherwise Category is largely irrelevant to lens ;)
21:26:48 <edwardk> you can compose isos with Prelude (.), they just dumb down to lenses in the process
21:26:54 <johnw> some part of me wants Category in every module I write
21:28:13 <otters> :t (^. biplate)
21:28:15 <lambdabot> (Data.Data.Data t, Typeable b, Monoid b) => t -> b
21:28:23 <otters> Data.Data.Data???
21:28:47 <rwbarton> fix (Data.)
21:29:23 <edwardk> otters: Data.Data defines 'Data', so its Data.Data.Data
21:29:39 <otters> edwardk: interestingly, when I run your example, example ^.. biplate gives me ["tibbe","doesn't","like"]
21:30:14 <johnw> see our containers discussion above
21:30:19 <edwardk> otters: yeah containers currently doesn't have a good Data instance for Map and IntMap. there is a libraries request to fix them. locally i'm running with a patched version
21:30:23 <otters> oh I see
21:30:34 <otters> also what is (&)
21:30:37 <edwardk> i proposed fixing them a couple months back, it should go in soon
21:30:39 <rwbarton> > "test" ^.. biplate :: [String]
21:30:41 <lambdabot>   ["test"]
21:30:42 <edwardk> (&) = (%) in the current lens version
21:30:46 <edwardk> in 3.4 its changing
21:30:55 <johnw> you're that optimistic, eh?
21:31:16 <edwardk> i'm changing it in lens regardless of what happens with base
21:31:17 <otters> what about traverseHead
21:31:24 <edwardk> Data.List.Lens
21:31:29 <johnw> fair enough
21:31:36 <edwardk> i admittedly picked types from all over ;)
21:31:40 <rwbarton> > "test" ^.. template :: [String]
21:31:41 <johnw> once it's on hackage, i'll change all my posts to it
21:31:42 <lambdabot>   ["est"]
21:31:59 <otters> yeah, this example is ridiculous
21:32:10 <otters> I don't know if there are any practical applications of it in this project
21:32:11 <otters> I wish there were
21:32:13 <shachaf> The sooner rwbarton fixes taking, the sooner it'll go on Hackage.
21:32:26 <edwardk> biplate is pretty convenient for working with the plated combinators
21:32:37 <edwardk> :t rewriteOf uniplate
21:32:39 <lambdabot> Data.Data.Data a => (a -> Maybe a) -> a -> a
21:33:02 <edwardk> that will take a rewrite rule for some expression tree, and just keep applying it recursively from the bottom up until it doesn't apply any more
21:34:27 <rwbarton> > universeOf template "test"
21:34:29 <lambdabot>   ["test","est","st","t",""]
21:34:49 <edwardk> > universe "test"
21:34:51 <lambdabot>   ["test","est","st","t",""]
21:35:01 <edwardk> that uses 'plate'
21:35:04 <rwbarton> ah
21:35:06 <edwardk> which is hand implemented for list
21:36:41 <edwardk> :t contextsOf "test"
21:36:43 <lambdabot>     Couldn't match expected type `SimpleLensLike
21:36:43 <lambdabot>                                     (Control.Lens.Internal.Bazaar a0 a0) a0 a0'
21:36:43 <lambdabot>                 with actual type `[Char]'
21:36:47 <edwardk> :t contexts "test"
21:36:48 <lambdabot> [Control.Lens.Internal.Context [Char] [Char] [Char]]
21:36:59 <edwardk> :t extract <$> contexts "test"
21:37:01 <lambdabot> Not in scope: `extract'
21:37:08 <edwardk> damn. no Control.Comonad
21:37:29 <johnw> :m +Control.Comonad
21:37:38 <johnw> i doubt that worked
21:37:42 <edwardk> sadly no
21:38:11 <edwardk> you really want that and Control.Comonad.Store.Class to work with Context anyways
21:38:23 <johnw> Caleskel is ε free
21:38:53 <edwardk> that lets you do things like work with all of the one-hole contexts that exist recursively in a structure.
21:39:08 <johnw> nice
21:40:07 <edwardk> e.g. focus on every sub-expression, and give me it, and a function from an expression to an expression such that if i feed it the one i got, i get the original tree, and otherwise i replace it in the original tree
21:40:30 <johnw> yep
21:40:34 <edwardk> here its a list of strings, and functions from string -> string
21:40:35 <johnw> that's basic "extend" behavior, right?
21:41:23 <edwardk> well, each context forms a comonad, 'extract' here takes the old value and plugs it into the function, giving you the whole.
21:41:42 <edwardk> extend takes some action from a context comonad to a value, and extends that to a new context comonad.
21:42:01 <edwardk> pos, peek, seek, etc. can be used to edit the intermediate result easily
21:42:17 <edwardk> though the names are a little funny given how they are used for contexts or holes
21:43:02 <edwardk> the nice thing is this is just a generalization of a combinator from uniplate
21:44:04 <johnw> heh, http://stackoverflow.com/questions/13503965/mapping-over-eithers-left
21:44:08 <johnw> that question is perfectly addressed by lens
21:44:28 <johnw> answering now...
21:45:16 <edwardk> notice shachaf's reply to the accepted answer
21:46:39 <johnw> ach
21:46:43 <johnw> you guys are everywhere
21:46:49 <applicative> nice primer johnw.  You could  do with an example of a user-defined record maybe.
21:46:54 <applicative> With a lens-able field?
21:47:00 <popl> johnw: Pod people.
21:47:26 <johnw> applicative: records will come around post 4 in the series
21:47:43 <johnw> i'm estimating there should be around 10-12
21:47:49 <applicative> johnw I was thinking, The Lens Army is out in force, but  I was counting you as a member
21:48:14 <johnw> I'm not?
21:48:46 * edwardk promotes johnw to lens army private first class.
21:48:47 <applicative> no, you are
21:49:20 <johnw> atten, hut!
21:49:26 <startling> popl, man, you're everywhere.
21:49:38 <johnw> where did you find popl?
21:49:39 <popl> startling: Pod people.
21:49:41 <edwardk> popl gets around. rome this year?
21:49:47 <johnw> i'm convinced edwardk and shachaf don't sleep
21:50:03 <startling> johnw, in #python and ##math
21:50:04 <edwardk> johnw: the sad thing is i get a lot more sleep that i used to
21:50:07 <edwardk> er than
21:50:08 <johnw> they spider the Internet in a spare process, attend every conference, and meanwhile generate Hackage packages as they eat and sleep
21:50:13 <popl> edwardk: Vatican City.
21:50:40 <johnw> mi piasce l'Italia molto
21:50:43 <edwardk> well, copumpkin will probably attend then ;)
21:51:07 <latermuse> yeah, how do you guys work, make packages, chat 24/7 and eat/sleep?
21:51:34 <johnw> i'm presenting avoiding work
21:51:34 <wobsite> so, question: I have an algebraic datatype for a message in a particular network protocol; there are 20 or so of them, split between client and server messages. many of the variants have constructors that need 4 or 5 parameters. I'd like to just use a record for each one, but I run into field name clashses everywhere. I'm having a hard time coming up with a non-hackish solution to this.
21:51:36 <copumpkin> popl: basically rome :P
21:51:41 <copumpkin> since nobody will actually stay in the vatican
21:51:47 <wobsite> how do people handle situations like this?
21:52:17 <edwardk> copumpkin: speak for yourself. the pope offered to let me crash on his couch.
21:52:23 <copumpkin> oh fair enough
21:52:30 <edwardk> BrianLovesJesus told me so
21:52:35 <copumpkin> aha!
21:52:57 <popl> johnw: piace?
21:53:01 <startling> latermuse, johnw: they're quantum-locked when you're looking at them
21:53:04 <startling> don't even blink
21:53:09 <johnw> Firenze
21:53:10 <popl> I'm kidding. I am not the Pope.
21:53:18 <johnw> piasce, I guess
21:53:21 <copumpkin> piace
21:53:31 <johnw> i usually say it, not spell it
21:53:43 <copumpkin> sce is pronounced like sh in english
21:53:54 <copumpkin> ce is like ch
21:54:00 <copumpkin> (in english)
21:54:03 <popl> That is probably why there is transliteration error on the web.
21:54:15 <johnw> yeah, i think it's piace then
21:54:27 <popl> edwardk: I've never been to Rome.
21:54:34 <popl> edwardk: I've never been outside of the US.
21:54:38 <popl> :P
21:55:27 <johnw> ho stato nell'Italia durante due mese nel 2003
21:55:44 <johnw> not surprisingly, my need for Italian now is restricted to ordering food :(
21:55:51 <applicative> wobsite, the clashing field names all have the same type?
21:55:57 <_cl1> what is () in writeSTRef :: STRef s a -> a -> ST s ()
21:55:57 <copumpkin> there used to be an italian haskell channel
21:56:01 <copumpkin> with about 4 people in it
21:56:17 <wobsite> applicative: yes.
21:56:21 <copumpkin> I wonder where xerox went
21:56:38 <edwardk> Welcome to issue 251 of the HWN … This issue covers the week of November 4 to 17, 2012.   -- 14 day weeks!
21:56:50 <_cl1> lol
21:56:51 <luite> _cl1: it's called unit, it's a type with a single value (both the ttype and value are called ()  )
21:57:04 <_cl1> luite: okay
21:57:07 <pdxleif> Can Agda generate readable Haskell code?
21:57:15 <johnw> heh
21:57:18 <_cl1> kind of like null
21:57:23 <luite> _cl1: it returns () because the action doesn't have anything more interesting to return
21:57:30 <wobsite> the protocol is pretty similar to 9p, for which there's a minimal haskell library. the VarMsg type in this code is essentially what I'm looking at: https://code.google.com/p/9ph/source/browse/src/Data/NineP.hs
21:57:45 <copumpkin> pdxleif: not right now
21:57:54 <wobsite> they just prefix everything with an abbreviation of the constructor. Not sure how I feel about that.
21:58:14 <pdxleif> I guess you can always call into the generated Haskell from regular Haskell?
21:59:31 <applicative> wobsite: but they are all included in some monster record ultimately?
21:59:31 <luite> _cl1: yeah not really, since null is just a value, and the types that contain null have lots of other values
21:59:56 <wobsite> applicative, yes.
22:00:06 <neutrino> luite: what types have null and other values in them?
22:00:23 <vraid> how do i write a main file to load another file, then do nothing (or something, in the main function)
22:00:43 <applicative> wobsite: oh I was thinking it was a big alternative
22:01:03 <luite> neutrino: i assume that cl1 meant languages like C or Java, where null is a value in any pointer or object type
22:01:07 <applicative> I mean after looking back
22:01:14 <wobsite> applicative: I'm not entirely sure what you mean; it's much like the data VarMsg in the code I linked.
22:01:15 <luite> since null in Haskell is just a function
22:01:27 <neutrino> :t null
22:01:29 <lambdabot> [a] -> Bool
22:01:44 <applicative> ah didnt see the code, wobsite
22:01:46 <wobsite> the solution they use works, I just don't like having to manually namespace things like that.
22:01:52 <neutrino> luite: there is no null value in C
22:02:05 <neutrino> you can speak about null pointers or null characters but not about null
22:02:28 <johnw> null is what functions returning void return!
22:02:39 <johnw> you just can't ever use that fact for anything meaningful...
22:02:48 <wobsite> neutrino: sure you can.
22:02:56 <luite> neutrino: hm right, C++ does have a real null, right?
22:03:07 <neutrino> i don't use esolangs
22:03:24 <neutrino> however, in most recently popular languages null is a singleton value
22:03:24 <vraid> luite: it's just a null pointer value
22:03:27 <applicative> wobsite: yes VarMsg is pretty alarming
22:03:45 <wobsite> yeah, but I'm having a hard time finding a better way to do it.
22:04:01 <wobsite> what makes a null "real"
22:04:06 <wobsite> ?
22:04:22 <wobsite> in C it's just a pointer with a particular numeric value.
22:04:40 <wobsite> and no, void functions do *not* return NULL. they just don't return a value.
22:04:59 <neutrino> languages have specifications. if that specification talks about a value of type null then that's a null. otherwise it's probably not.
22:05:00 <ski> cl1 : `()' in Haskell is more like `void' in e.g. C
22:05:03 <luite> hehe bah i didn't want this discussion :p
22:05:09 <neutrino> yeah me either
22:05:23 <neutrino> wobsite: relax
22:05:28 <wobsite> :P two different words for the same thing.
22:05:48 <wobsite> err, rather two different things with the same name.
22:05:52 <johnw> () is not like void at all
22:05:55 <luite> ski: yeah the problem is that () does have one value, void doesn's, haskell Void doesn't, but then that's different again
22:05:56 <johnw> Void is more like void, I'd say
22:06:13 <johnw> Void still has undefined, right?
22:06:20 <luite> yeah...
22:06:24 <wobsite> neutrino: Did I come off as otherwise? if so I apologize.
22:06:28 <ski> luite : i'm not convinced `void' doesn't have a value
22:07:07 <copumpkin> void in C is closest in meaning to haskell's (), I'd say
22:07:17 <wobsite> I would agree.
22:07:23 <shachaf> Would be nice if C++ allowed void values.
22:07:24 <copumpkin> but not perfectly so
22:07:32 <shachaf> s/nice/useful/
22:07:35 <luite> yeah i do agree it's closest :)
22:07:58 <johnw> copumpkin: but () has a legitimate value, and you can compose functions that return () with functions that take (); you can't do that in C/C++ for void returning functions
22:08:21 <copumpkin> johnw: yes, but you can't have functions returning the empty type
22:08:21 <johnw> void foo(void); void bar(void); foo(bar()); /* nope */
22:08:28 <shachaf> johnw: There's no such thing as a function that takes a void.
22:08:31 <shachaf> Or a value of type void.
22:08:42 <johnw> > id ()
22:08:43 <copumpkin> well, that's the thing
22:08:44 <lambdabot>   ()
22:08:47 <johnw> > (id . id . id) ()
22:08:49 <shachaf> Maybe void is contravariant-only, or something.
22:08:49 <ski> johnw : but you can't pass or return arrays to functions in C either -- it's just an inconsistency in the language
22:08:49 <lambdabot>   ()
22:08:50 <copumpkin> you can write void foo(void)
22:08:53 <johnw> that's what I meant
22:08:55 <copumpkin> if void were really empty
22:08:58 <copumpkin> you couldn't return it
22:09:03 <copumpkin> and you couldn't call functions that took it
22:09:14 <neutrino> wobsite: it seems like you're not very agreeable today.
22:09:16 <wobsite> johnw: you would just do bar(); foo();
22:09:28 <shachaf> copumpkin: blah foo(void) is an unrelated use of the keyword void from void foo(blah);
22:09:28 <copumpkin> so conceptually, void has a single value
22:09:34 <copumpkin> that is trivial and unnamable
22:09:36 <shachaf> If C++ allowed void values, you could do template <typename res_t>res_t foo(...) { struct { res_t res; run() { res = ...; } s; ...; return s.res; }
22:09:41 <shachaf> As it is you have to duplicate code. :-(
22:09:44 <shapr> Is void the bottom type?
22:09:44 <johnw> () allows composition of identity, void does not; that's an algebraic difference
22:09:48 <copumpkin> shachaf: conceptually it's the same kind of thing
22:09:55 <copumpkin> shachaf: I can write void foo(int);
22:09:59 <ski> copumpkin : "you couldn't call functions that took it" -- well, you could, they'd just not return :)
22:10:06 <shachaf> shapr: No, it's just ().
22:10:09 <wobsite> johnw: C is not an algebra.
22:10:14 <vraid> what's the syntax to load a file.hs from another file?
22:10:25 <shachaf> GNU C has an extension such that you can say void foo(); void bar() { ...; return foo(); }
22:10:25 <copumpkin> anyway, void is a type, and if you can return it, it isn't empty
22:10:28 <shachaf> Which is nice.
22:10:31 <ski> vraid : itym `import File'
22:10:32 <shachaf> But not in actual C
22:10:48 <copumpkin> void in C acts like a unit type with a single value that you can't name, and that gets returned automatically for oyu
22:10:57 <johnw> i love it when we argue C
22:10:58 <vraid> ski: i'm getting error on input :/
22:11:00 <copumpkin> yeah!
22:11:00 <shachaf> copumpkin: Except you can't have a value of that type.
22:11:12 <copumpkin> shachaf: sure, it's not a first-class type
22:11:17 <johnw> copumpkin: well, in that sense maybe I can buy what you're saying
22:11:18 <copumpkin> but its role is just like that of unit
22:11:25 <ski> @paste
22:11:25 <lambdabot> Haskell pastebin: http://hpaste.org/
22:11:27 <copumpkin> in a language that does have a meaningful unit
22:11:28 <copumpkin> like scala
22:11:29 <wobsite> there's no reason to have () in C, there's no information carried there, so no reason to bother passing it around. the semantics work fine without doing so due to the imperitive nature.
22:11:30 <copumpkin> and effects
22:11:33 <copumpkin> it's replaced by unit
22:11:51 <wobsite> you just have two statements.
22:11:52 <rwbarton> or ML
22:12:10 <johnw> in practical terms, I explain IO () to C people as being what they'd write when they'd otherwise reach for "void"
22:12:17 <wobsite> one can comment on the expressiveness, of course.
22:12:34 <ski> wobsite : it would be useful to distinguish in C between functions which return no interesting value, and functions which does not return
22:12:45 <copumpkin> gcc attributes ;)
22:12:52 * ski nods
22:12:54 <johnw> ski: there is __attribute__((noreturn)) in gcc
22:12:57 * hackagebot binary 0.6.3.0 - Binary serialisation for Haskell values using lazy ByteStrings  http://hackage.haskell.org/package/binary-0.6.3.0 (LennartKolmodin)
22:13:07 <wobsite> there's also some kind of thing for that in the c11 standard.
22:13:16 <wobsite> which might also work in clang eventually.
22:13:40 <shachaf> (forall a. a) exit(int x) { ... }
22:13:40 <copumpkin> forever :: m a -> m Void
22:13:41 <wobsite> though I would point out that would also be nice in haskell.
22:14:01 <vraid> ski: i have main.hs and primes.hs, but "import primes" fails even when primes.hs is empty
22:14:37 <copumpkin> someone should replicate the dumbest algorithm ever written for enumerating all primes, the one I implemented in Agda
22:14:43 <rwbarton> (a) needs to be Primes.hs, not primes.hs (b) it can't be empty, it should begin "module Primes where"
22:14:51 <ski> shachaf : hm, where's that extension documented ?
22:14:52 <copumpkin> the state of the art in dumb prime algorithms
22:14:59 <johnw> {
22:15:05 <johnw> {-# LANGUAGE GeneratingPrimes #-}
22:15:05 <ski> vraid : module names should start with upper case
22:15:48 <Nereid> copumpkin: I'm fine with forever :: m a -> m b
22:15:57 <vraid> ski: file names too?
22:16:01 <shachaf> ski: Hmm, I see a reference to it at http://gcc.gnu.org/ml/gcc/2006-10/msg00697.html
22:16:08 <Nereid> vraid: file name should match the module name
22:16:09 <cl1> i'm reading older papers about type functions, one says its experimental in GHC, is that still the case?
22:16:10 <copumpkin> Nereid: it says the same sort of thing :) it'd just force you to acknowledge the nontermination
22:16:10 <ski> vraid : for GHC, yes
22:16:19 <copumpkin> Nereid: a bit like how Maybe forces you to acknowledge that you might not get a value
22:16:38 <Nereid> copumpkin: but m b can be specialized to m Void
22:16:40 <copumpkin> what does the additional polymorphism get you? the ability to not notice that you're doing something
22:16:43 <copumpkin> sure
22:16:45 <copumpkin> but that's not the point
22:16:47 <Nereid> :p
22:17:00 <copumpkin> you're saying "but you can check for null" :P
22:17:10 <copumpkin> I'm saying "but I don't want to be responsible for remembering that"
22:17:15 <Nereid> well, what do you think when you see forall a. a?
22:17:30 <vraid> ski: thanks, got it working now
22:17:32 <shachaf> Nereid: I think copumpkin's point is that you don't see that.
22:17:36 <Nereid> :V
22:17:38 <shachaf> You just say x <- foo
22:17:47 <shachaf> And then you can use x as Int
22:17:51 <copumpkin> yeah, I could write x <- forever ...
22:17:53 <copumpkin> putStrLn x
22:18:02 <Nereid> heh
22:18:05 <shachaf> copumpkin: Int, not String!
22:18:13 <copumpkin> okay
22:18:14 <shachaf> Clearly we were thinking of completely different things here.
22:18:16 <Nereid> haha
22:18:16 <copumpkin> threadDely x
22:18:19 <copumpkin> :P
22:18:25 <Nereid> I get your point though.
22:18:27 <Nereid> and I even agree.
22:18:36 <shachaf> I disagree with copumpkin on principle.
22:18:43 <shachaf> Also because he insulted me in #-blah before.
22:18:46 <copumpkin> I don't really care about it that much, but if I coul choose, I'd prefer it
22:18:49 <copumpkin> when did I insult you?
22:18:54 <copumpkin> or how, I should ask
22:18:56 <copumpkin> "before"
22:19:07 * ski used `kill :: SystemM Void' for a kill-thread thing, introduced `Void' here to keep sanity
22:19:08 <shachaf> You called me a photographer and an optician!
22:19:17 <copumpkin> you like lenses!
22:19:23 <shachaf> I hate lenses!
22:19:25 <johnw> lol
22:19:25 <copumpkin> not my fault
22:19:25 <Nereid> but even if forever :: m a -> m Void, it doesn't stop you from writing forever ... >> ...
22:19:31 <shachaf> That's why I'm sabotaging the code with confusing types.
22:19:36 <johnw> shachaf sees the world through lens-colored lenses
22:19:48 <Nereid> why not traversal-colored lenses?
22:19:54 <ski> Nereid : `(>>) :: Monad m => m () -> m a -> m a', obviously :)
22:19:55 <copumpkin> Nereid: well, I think the type of >> should force you to acknowledge that the first return value won't get used too :P
22:20:01 <copumpkin> yeh
22:20:02 <Nereid> ski: hehe
22:20:03 <edwardk> you know, lens was unsafeCoerce-free until shachaf came along. i think there might be something to this sabotage thing
22:20:08 <Nereid> good point
22:20:13 <shachaf> Computer scientists tend to see th world through graph-colored lenses.
22:20:25 <shachaf> edwardk: Not true! Data.Data had a few.
22:20:36 <edwardk> oh yeah
22:20:36 <Nereid> and then if you *really* want to discard the result, do { _ <- ... ; ... }
22:20:40 <ski> (with explicit calls to `ignore :: Functor f => f a -> f ()' if you need it)
22:20:41 <shachaf> It only has 2000% or so more unsafeCoerce thanks to me.
22:20:42 <edwardk> but those were safe unsafeCoerces ;)
22:20:48 <copumpkin> I'd like the ignore better
22:20:53 <copumpkin> _ <- reminds me too much of scala
22:20:56 * copumpkin shudders
22:20:58 <shachaf> @let voided n = replicate n ()
22:20:59 <edwardk> you want unsafeCoerce for coerce in bazaar =P
22:21:00 <ski> Nereid : or that
22:21:01 <lambdabot>  Defined.
22:21:02 <Nereid> well ok, if you had ignore
22:21:06 <Nereid> but that's more typing
22:21:14 <shachaf> edwardk: Hey, I just mentioned that it was possible.
22:21:24 <shachaf> And you could totally make it safe if you wanted to.
22:21:43 <shachaf> edwardk: Don't you feel bad that Lens.Unsafe doesn't actually export anything unsafe?
22:21:47 <johnw> I'd like to see lens merge with FRP
22:21:48 <copumpkin> call it "eat"
22:21:50 <copumpkin> instead of ignore
22:21:54 <copumpkin> or "nom"
22:21:55 <johnw> or, a banana-lens library
22:22:00 <shachaf> @ty void
22:22:01 <copumpkin> @let nom x = x >> return ()
22:22:02 <lambdabot> Functor f => f a -> f ()
22:22:03 <lambdabot>  Defined.
22:22:08 <copumpkin> @ty nom
22:22:09 <lambdabot> Monad m => m a -> m ()
22:22:12 <johnw> lenses on values, actions and events
22:22:15 <edwardk> if you want to implement the EvilBazaar lets do that and get a solution we _could_ ship for taking, and then we can debate about ways to improve it rather than having something potentially insurmountable block 3.4
22:22:15 <shachaf> My Functor is better than your Monad.
22:22:19 <copumpkin> yeah it is
22:22:21 <johnw> and traversals over event streams
22:22:28 <ski> shachaf : yeah, it shouldn't be called `void'
22:22:33 <shachaf> edwardk: I don't want EvilBazaar. :-(
22:22:35 <Nereid> I don't ilke the name "void".
22:22:47 <copumpkin> nom is good
22:22:49 <shachaf> Is the entire release blocking on this now?
22:22:50 <edwardk> shachaf: then you shouldnt have proposed the only known workable solution =P
22:22:56 <edwardk> yes
22:22:59 <Nereid> ski: do you use `strange quotes' all the time"?
22:23:10 <copumpkin> yup
22:23:13 <edwardk> with that fixed in some fashion 3.4 can go out and we can stop fighting with % vs &, etc.
22:23:21 <copumpkin> ski: you coming to boston next year for ICFP?
22:23:23 <ski> Nereid : only when quoting formal languages in natural languages
22:23:35 <shachaf> edwardk: As opposed to exporting a nonlazy taking, like 3.3 had?
22:23:38 <edwardk> the traverseHead vs _head stuff is also nominally in 3.4 but at least (^!?) is here so that should be easy
22:23:51 <edwardk> shachaf: yeah. i want taking to work in the infinite cases
22:24:16 <edwardk> i don't like thinks that just randomly hang that the user might reasonably try
22:24:19 <edwardk> er things
22:24:48 <vraid> is there an easy way to get an int from getline?
22:24:58 <ski> @type readIO
22:25:00 <lambdabot> Read a => String -> IO a
22:25:11 <ski> @type readLn
22:25:12 <lambdabot> Read a => IO a
22:25:20 <ski> vraid : try `readLn'
22:25:28 <Nereid> @ty getLine >=> readIO
22:25:30 <lambdabot>     Couldn't match expected type `a0 -> m0 b0'
22:25:30 <lambdabot>                 with actual type `IO String'
22:25:30 <lambdabot>     In the first argument of `(>=>)', namely `getLine'
22:25:32 <luite> hm when do papers have to be in?
22:25:39 <Nereid> @ty getLine >>= readIO -- oops
22:25:41 <lambdabot> Read b => IO b
22:25:46 <luite> for ICFP
22:26:15 <shachaf> I,I newtype BlackMarket
22:26:32 <edwardk> BlackMarket works =P
22:26:52 <edwardk> put it in .Unsafe  and just export the type from .Internal?
22:27:37 <shachaf> Unsafe imports Internal
22:27:42 <shachaf> You really want me to do this? :-(
22:27:57 <edwardk> lets do it and get forgiveness later ;)
22:28:21 <Nereid> hurry up, it's been almost a week since the last release :(
22:28:24 <edwardk> maybe make a Private module or something that Internal can import the constructor from then
22:29:02 <edwardk> Nereid: why the rush. 3.4 isn't due for 4 days: https://github.com/ekmett/lens/issues/milestones
22:29:07 <edwardk> =)
22:29:33 <shachaf> Are we actually sure EvilBazaar is sound if you just export the type?
22:29:42 <Nereid> haha
22:29:57 <edwardk> write the code, we can beat on your hypothesis that its sound with code in hand
22:30:04 <shachaf> Fine, fine.
22:30:27 <edwardk> and this way i can point to your name on the commit and blame you when it goes horribly wrong ;)
22:31:08 <cl1> I thought Monad was of kind (* -> *) but ghci says its (* -> *) -> Constraint
22:31:25 <shachaf> cl1: Monad instances are of kind (* -> *)
22:31:28 <shachaf> So Maybe :: * -> *
22:31:35 <shachaf> Monad doesn't really have a kind in Haskell 98
22:31:38 <cl1> okay, so what is -> Constraint then
22:31:41 <edwardk> cl1: _a_ monad is of kind * -> *. Monad itself is the class of monads, it takes something of kind * -> * and gives you a constraint.
22:31:47 <shachaf> GHC has something called ConstraintKinds that lets it do that.
22:31:51 <edwardk> constraints are things that go on the left of => in a signature
22:31:53 <cl1> ah
22:32:02 <edwardk> Num :: * -> Constraint.   takes an arg of kind *
22:32:03 <Nereid> this Constraint business is quite new to Haskell.
22:32:04 <cl1> :k Monad Int
22:32:06 <lambdabot>     Kind mis-match
22:32:06 <lambdabot>     The first argument of `Monad' should have kind `* -> *',
22:32:06 <lambdabot>     but `Int' has kind `*'
22:32:09 <edwardk> :k Monad []
22:32:11 <lambdabot> Constraint
22:32:15 <edwardk> :k Monad Maybe
22:32:17 <lambdabot> Constraint
22:32:17 <cl1> :k Monad []
22:32:19 <lambdabot> Constraint
22:32:28 <cl1> :k []
22:32:30 <lambdabot> * -> *
22:32:33 <cl1> i see
22:32:37 <Nereid> :k Monad ZipList
22:32:39 <lambdabot> Constraint
22:33:06 <edwardk> > cls :: Ord a :- Eq a
22:33:08 <lambdabot>   Sub Dict
22:33:11 <johnw> what is a Constraint kind?
22:33:17 <johnw> it just means type classes apply?
22:33:27 <shachaf> Can you say "export everything except this one thing"?
22:33:27 <Nereid> Constraints are the things you put on the left of =>
22:33:33 <shachaf> Otherwise the .Internal export will be awkward.
22:33:39 <edwardk> 'a constraint kind' is a bit of a misnomer. there is _a_ constraint kind. there are lots of constraints.
22:33:44 <johnw> so just Constraint ⊂ *?
22:33:47 <Nereid> nope
22:33:50 <edwardk> it should really be {-# LANGUAGE ConstraintTypes #-}
22:33:50 <Nereid> it's disjoint from *
22:34:10 <shachaf> rwbarton: Do you know what edwardk is making me do right now?
22:34:18 <Nereid> for each a :: *, one has Num a :: Constraint.
22:34:23 <johnw> oh, I see
22:34:27 <Electro_Statik> hey there fellas
22:34:39 <Nereid> :k Num String
22:34:41 <johnw> Monad Maybe goes to the left of ⇒, so it's kind is Constraint; * goes to the right of ⇒
22:34:41 <lambdabot> Constraint
22:34:45 <edwardk> shachaf: put the EvilBazaar in another module other than .Internal then import just the constructor into Internal
22:34:55 <shachaf> Oh, good point.
22:35:01 <shachaf> You can import just a type.
22:35:19 <edwardk> it should be Cathedral
22:35:22 <edwardk> =)
22:35:23 <Nereid> lol
22:35:45 <edwardk> then it makes some kind of value judgment
22:36:49 <Nereid> :k (:-)
22:36:51 <lambdabot> Constraint -> Constraint -> *
22:37:11 <Nereid> :t cls
22:37:13 <lambdabot> Class b h => h :- b
22:37:23 <Nereid> :i Class
22:37:30 <shachaf> edwardk: Hey, I'm using outs instead of unsafeOuts
22:37:30 <Nereid> hmm
22:37:31 <cl1> so is the following statement in a type class definition saying that Ref m has kind * -> * or that m has kind * -> *  .. type Ref m :: * -> *
22:37:32 <shachaf> This is totally safe
22:37:46 <edwardk> hah
22:37:53 <Nereid> cl1: Ref is the class?
22:38:04 <Nereid> wait.
22:38:16 <Nereid> I think I get it.
22:38:18 <edwardk> Nereid: they come from Data.Constraint: http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/Data-Constraint.html
22:38:20 <Nereid> cl1: ah. Ref is an associated type.
22:38:27 <Nereid> edwardk: I know, I was just being lazy.
22:38:28 <shachaf> You know what, I'm just going to call this .Evil
22:38:35 <edwardk> shachaf: sure.
22:38:54 <edwardk> of course. the .Unsafe module is also Evil
22:39:00 <edwardk> maybe Unsafe should be .Evil.Lesser
22:39:14 <cl1> Nereid: yes
22:39:15 <Nereid> cl1: so given an instance m of your class, Ref m is some type constructor * -> *
22:39:19 <Nereid> Ref m has kind * -> *
22:39:32 <cl1> okay
22:39:33 <Nereid> unrelated to the kind of k
22:39:35 <Nereid> er, kind of m
22:40:00 <vraid> trying to profile, how do i link with -rtsopts? i compiled with-prof
22:40:40 <cl1> got it
22:40:53 <cl1> this is powerful stuffs
22:41:04 <johnw> edwardk: how does one use Data.Constraint?
22:41:14 <edwardk> i can rename Unsafe to something about Eta   and put some haddocks in it to describe why it exists.
22:41:17 <Nereid> someone made a blog post about it somewhere
22:41:25 <johnw> @google Data.Constraint
22:41:27 <lambdabot> http://www.businessdictionary.com/definition/data-constraint.html
22:41:27 <lambdabot> Title: What is data constraint? definition and meaning
22:41:33 <edwardk> johnw: http://comonad.com/reader/2011/what-constraints-entail-part-1/
22:41:42 <Nereid> figures it would have been that blog.
22:42:07 <edwardk> http://comonad.com/reader/2011/what-constraints-entail-part-2/
22:42:31 <edwardk> my blog is apparently now "that blog", said in a tone of terror. ;)
22:42:45 <Nereid> :P
22:43:10 <shachaf> Bah, circular modules are annoying.
22:43:40 <edwardk> what does it need that is circular?
22:43:48 <edwardk> oh the gettable
22:43:56 <edwardk> you can put the gettable instance in Internal
22:44:04 <edwardk> and just put the type name on Internal's export list
22:44:09 <edwardk> then no cycles
22:45:13 <johnw> edwardk: maybe it's me, but from your blog post I can't see what I'd actually use this for
22:45:55 <edwardk> johnw: the usecases are somewhat advanced. one example of something horrible is to fake a fix for the module hierarchy. see Data.Constraint.Unsafe
22:46:06 <johnw> does it mean that . will compose the constraints of the composed functions into the result type?
22:46:31 <johnw> doesn't that already happen?
22:46:36 <edwardk> (:-) forms a category (well, it would if Category was poly-kinded)
22:46:38 <edwardk> eg.
22:47:06 <edwardk> cls :: Ord a :- Eq a      works because of Eq a is the superclass of Ord a
22:47:09 * cl1 thinks (:-) forms a happy little ascii man
22:48:06 <edwardk> ins :: Eq a :- Eq [a] works because instance Eq a => Eq [a]
22:48:35 <johnw> huh, i'll come back to this when I've read more about the type theory aspects of GHC/haskell
22:48:51 <edwardk> so trans ins cls :: Ord a :- Eq [a]  -- says that you can get a dictionary for Eq [a] given one for Ord a
22:49:07 <johnw> i'm still not comfortable enough with GADTs yet
22:50:16 <edwardk> the key to using constraints is that you can use (\\) to apply a constraint.
22:50:23 <edwardk> :t (Data.Constraint.\\)
22:50:25 <lambdabot> (a) => ((b) => r) -> (a :- b) -> r
22:50:42 <johnw> i'll stop you here, edwardk
22:50:45 <Electro_Statik> what's the haskell package name for ghc?
22:50:48 <johnw> don't waste your time on me just yet
22:50:48 <edwardk> that says that if 'a' holds. and if given 'b' you could give me an r, and that a entails b, then you can have an r.
22:50:51 <Electro_Statik> 'ghc'?
22:51:01 <Nereid> Electro_Statik: yes, but why?
22:51:12 <edwardk> Sub Dict :: Ord a :- Ord [a]
22:51:12 <Nereid> (ghc-pkg list will tell you)
22:51:14 <edwardk> > Sub Dict :: Ord a :- Ord [a]
22:51:16 <lambdabot>   Sub Dict
22:51:19 <edwardk> > Sub Dict :: Ord a :- Ord [[a]]
22:51:20 <Electro_Statik> im installing Haskell on Ubuntu
22:51:21 <lambdabot>   Sub Dict
22:51:27 <edwardk> > Sub Dict :: Ord [a] :- Ord a
22:51:29 <lambdabot>   Could not deduce (GHC.Classes.Ord a1)
22:51:30 <lambdabot>    arising from a use of `Data.Constr...
22:51:37 <edwardk> notice i can't typecheck a relationship that doesn't work
22:51:51 <edwardk> Ord a entails Ord [a], but you can't run that relationship backwards
22:52:00 <geekosaur> Electro_Statik, if you're asking if ghc can be installed via cabal-install, the answer is no.
22:52:07 <edwardk> you can make big jumps, notice i went from Ord a :- Ord [[a]]
22:52:21 <Nereid> > Sub Dict :: Ord a :- Eq [[a]]
22:52:23 <lambdabot>   Sub Dict
22:52:24 <edwardk> > Sub Dict :: Ord a :- Eq [[[a]]]
22:52:26 <lambdabot>   Sub Dict
22:52:27 <Nereid> heh
22:52:38 <edwardk> > Sub Dict :: Ord a :- (Eq [[[a]]], Eq Int)
22:52:40 <lambdabot>   Sub Dict
22:52:47 <Electro_Statik> ill just look up the documentation
22:53:00 <Electro_Statik> lazi <<<
22:53:02 <Nereid> Electro_Statik: what are you trying to do?
22:53:06 <edwardk> Eq Int can be inferred from an empty context, since there is an instance.
22:53:11 <rwbarton> did you mean "what is the Ubuntu package name for ghc?"
22:53:28 <Nereid> oh that would make more sense.
22:53:34 <Electro_Statik> I just want to set up Haskell on my system
22:53:48 <Nereid> try the haskell platform.
22:53:49 <Electro_Statik> make sure im downloading the appropriate libraries
22:53:56 <cl1> Electro_Statik: just download it http://www.haskell.org/platform/linux.html
22:54:03 <rwbarton> apt-get install haskell-platform
22:54:09 <rwbarton> (what ubuntu version?)
22:54:11 <Electro_Statik> is that all?
22:54:33 <Nereid> haskell-platform includes ghc and a bunch of other things that you will likely want
22:54:45 <Nereid> ubuntu seems to have platform 2012.2.0.0
22:54:49 <Nereid> latest is 2012.4.0.0 though
22:54:53 <edwardk> johnw: anyways the cases it arises are mostly around things where you want a constraint that is universally quantified. e.g. you need to know that there is a forall a. Monoid (m a)   -- which you can't normally state. or where you are working with type families of constraints and sometimes the constraints come out in the wrong form
22:55:14 <johnw> edwardk: ok
22:55:20 <rwbarton> as long as you get ghc 7.4 you are pretty much in good shape
22:55:24 <Nereid> true
22:55:31 <Nereid> (which 2012.2.0.0 has)
22:55:37 <edwardk> but in general its mostly interesting because its a category for objects of kind Constraint, and it lets you write some code that you otherwise have to make a million one off codefragments for once and forall
22:56:01 <edwardk> (:-) should be read as 'entails' and maybe should look like |-   ideally
22:56:16 <Electro_Statik> I used the uname -a command and I see 3.2
22:56:19 <edwardk> after 7.6 i might make the change, probably a platform or two later
22:56:25 <rwbarton> uh
22:56:37 <vraid> how do i link with -rtsopts to enable profiling?
22:56:40 <rwbarton> well I guess that suggests you have a pretty recent ubuntu
22:57:00 <Nereid> isn't there a /etc/ubuntu-release file or something that tells you?
22:57:16 <Nereid> I know nothing about ubuntu.
22:57:29 <rwbarton> I'm running 12.04 with linux 3.0
22:57:33 <rwbarton> so I guess 3.2 must mean 12.10
22:57:36 <alang> Electro_Statik: run lsb_release -a
22:58:26 <neutrino> 12.04 comes with 3.2
22:58:35 <neutrino> you are probably running a pre-release
22:58:43 <neutrino> 12.10 is 3.5
22:59:09 <rwbarton> don't think so
22:59:40 <rwbarton> maybe just an old version
23:00:19 <neutrino> i do
23:00:20 <Electro_Statik> 12.04 codename precise
23:00:29 <neutrino> because i am running 12.04 and it has 3.2
23:00:34 <neutrino> and it doesn't have 3.0
23:00:46 <Electro_Statik> what linux distribution is ubuntu derived from?
23:00:51 <Electro_Statik> Debian?
23:01:25 <Nereid> yes
23:01:29 <hpaste> neutrino pasted “ubuntu 12.04 kernels” at http://hpaste.org/78039
23:01:31 <rwbarton> "Description:    Ubuntu 12.04.1 LTS"
23:01:33 <rwbarton> shrug
23:01:42 <Nereid> these are things you could find out on wikipedia.
23:02:11 <neutrino> rwbarton: maybe you upgraded from an older version?
23:02:18 <rwbarton> hm
23:02:21 <neutrino> rwbarton: that would explain why you have 3.0
23:02:24 <rwbarton> that's possible actually
23:02:34 <neutrino> i think 11.10 had 3.0
23:03:01 <neutrino> 12.04 has 3.5 in backports too btw
23:03:06 <neutrino> and probably going to get 3.7
23:03:47 <Nereid> rolling release is good
23:03:53 <Electro_Statik> I know this is probably reserved for Haskell blah, but has anyone studied with Simon Peyton Jones in this room?
23:04:56 <neutrino> guys i have a question, how can i memoize a function which creates a Map?
23:05:24 <johnw> so you want to memoize multiple possible map values?
23:05:38 <johnw> or the values within a map?
23:05:39 <edwardk> neutrino: memoization is more of an issue about what the inputs are than the outputs
23:05:51 <neutrino> well what i have is a function step :: a -> b -> (a, b)
23:06:10 <neutrino> or rather
23:06:10 <neutrino> sorry
23:06:19 <neutrino> step :: a -> b -> [(a, b)]
23:06:28 <edwardk> what are 'a' and 'b' ?
23:06:31 <neutrino> at every step, there's a multitude of possibilities
23:06:41 <neutrino> they're tuples and lists
23:06:45 <neutrino> of ints and chars
23:06:59 <neutrino> finite lists
23:07:27 <neutrino> what i want is to get a map with every possible reachable state
23:07:37 <neutrino> every chain of step's is going to terminate
23:07:41 <neutrino> rather quickly too
23:08:00 <neutrino> and they cross-cut, meaning that multiple choices will then converge again
23:08:44 <edwardk> the reason i ask is that memoization cares a lot about the particular argument types ;)
23:08:53 <edwardk> the easiest way would be to take some depth/breadth first search from the starting point and use that. e.g. Data.Graph or some fgl mess
23:09:35 <neutrino> getting a graph of all possible values would be even better
23:10:40 <neutrino> basically, i have a 3d map of bits (that's b) initially all 1 and a list of shapes to remove from that bitmap. you can position the shape and rotate it. you start with a finite amount of shapes you can use only once each.
23:10:53 <neutrino> so i want to see where that can lead, i.e. what bitmaps you can get.
23:11:15 <neutrino> i want to find all strands of [(shape, rotation, position)] that lead to empty bitmaps.
23:11:47 <neutrino> naturally those lists are commutative. it doesn't matter if you remove a pixel in the first or second step, only that it's removed in the end.
23:13:34 <neutrino> edwardk: how would you do that?
23:13:35 <rwbarton> I usually roll my own little bfs function (or whatever kind of search is appropriate)
23:13:45 <rwbarton> for example I recently wrote this one
23:14:06 <hpaste> rwbarton pasted “bfs” at http://hpaste.org/78040
23:14:28 <neutrino> rwbarton: well, i currently have a function which, for a given bitmap and list of shapes, finds all possible (shape, rotation, transformation) that can be removed from the bitmap.
23:14:50 <neutrino> rwbarton: i also have a function remove :: bitmap -> (shape, rotation, transformation) -> bitmap
23:14:52 <rwbarton> that's basically what you would pass as the argument to this bfs function
23:14:59 <rwbarton> a combination of those two
23:15:02 <shachaf> edwardk: Whoops.
23:15:04 <neutrino> right
23:15:14 <rwbarton> bitmap -> [(bitmap, aux_data)]
23:15:16 <shachaf> Given EvilBazaar, you can say over (taking 5 folded) succ
23:15:17 <edwardk> shachaf: ?
23:15:29 <edwardk> shachaf: heh
23:15:35 <shachaf> It's giving me an empty string.
23:15:45 <shachaf> I'm not sure where that string is coming from.
23:15:48 <neutrino> what is e here?
23:15:50 <shachaf> Is it unsafeCoercing something?
23:15:51 <edwardk> so question
23:15:54 <edwardk> if we tweak EvilBazaar
23:16:01 <rwbarton> e is the type of a "label" for an edge
23:16:07 <edwardk> EvilBazaar a b f c     being Bazaar a b c
23:16:15 <edwardk> and limit the Gettable instance to Gettable f
23:16:16 <neutrino> give me a simple example for e
23:16:24 <edwardk> then you can borrow the 'f' from the result lens
23:16:27 <edwardk> that should avoid this
23:16:29 <rwbarton> well for example
23:16:43 <Electro_Statik> documentation says: " If you have a file /usr/lib/libedit.so.2 (expected on Debian and derived distributions) then use this bindist"
23:16:52 <Electro_Statik> I have no file by that name
23:16:57 <rwbarton> adj (x,y) = [((x+1,y),'E'),((x-1,y),'W'),((x,y+1),'S'),((x,y-1),'N')]
23:17:05 <shachaf> This f being independent of the forall f. ... inside?
23:17:07 <edwardk> nsince it won't be gettable unless the output is gettable
23:17:09 <rwbarton> the labels are whatever you want. you don't have to use them if you don't like
23:17:11 <edwardk> ye
23:17:11 <neutrino> ...simple :))
23:17:12 <edwardk> er yep
23:17:17 <edwardk> this is just a phantom
23:17:26 <edwardk> this was the fix i mentioned on #haskell-lens
23:17:36 <edwardk> as a possible hack to move forward
23:17:37 <rwbarton> the output will include each reachable vertex once and one of the paths that will get there as a sequence of edges
23:17:54 <rwbarton> or more accurately the labels on the sequence of edges
23:18:23 <shachaf> edwardk: That's kind of evil, but I can't complain.
23:18:33 <neutrino> rwbarton: ok wait, let's say i have a finite list of numbers, and i want to make a bfs which takes a number off the list (any index it wants), adds it to an accumulator, and if the accumulator is > 100 it ends.
23:18:33 <rwbarton> Data.Dequeue is from the dequeue package, it was the simplest one I could find. for your problem dfs would be equally appropriate and then you could use a stack instead
23:18:34 <edwardk> =)
23:18:38 <neutrino> rwbarton: what would e be?
23:18:53 <rwbarton> well what information do you want to get out at the end
23:19:16 <neutrino> all such combinations of numbers that reach 100 exactly
23:19:25 <shachaf> What would this make taking's type?
23:19:28 <rwbarton> and I can't reuse numbers I take it?
23:19:36 <neutrino> no, you only use them once
23:19:37 <edwardk> :t taking
23:19:38 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
23:19:39 <neutrino> you need to carry the list
23:19:44 <rwbarton> then I'd make e be the number I took
23:19:45 <neutrino> edwardk: #lens
23:19:47 <neutrino> :P
23:19:51 <liyang> (Is someone eulergising?)
23:20:13 <edwardk> taking :: Applicative f => Int -> SimpleLensLike (EvilBazaar a a f) s a -> SimpleLensLike f s a
23:20:25 <rwbarton> adj (sumSoFar, available) = [ ((newSum, available'), e) | (e, available') <- selections available, let newSum = sumSoFar + e, newSum <= 100 ]
23:20:42 <shachaf> Oh, it has to return SimpleLensLike, right.
23:21:28 <shachaf> OK, that fixes it.
23:21:35 <neutrino> rwbarton: ok, so [e] in my case is the sequence of moves that has lead to me getting to e.g. an empty board?
23:21:36 <edwardk> woot!
23:21:37 <rwbarton> then your result is   [ paths | ((100, _), paths) <- bfs 0 available ]
23:21:40 <neutrino> yeah.
23:21:41 <rwbarton> yes
23:21:49 <rwbarton> it's a list of all the "e"s you used to get there
23:22:03 <neutrino> and adj is going to be the first parameter to bfs
23:22:04 <neutrino> ok
23:22:05 <rwbarton> I find it a really handy interface. compared to having to enumerate all the vertices of my graph in advance like with most graph libraries
23:22:12 <rwbarton> oh yeah I forgot that
23:22:15 <neutrino> is your bfs function memoized?
23:22:18 <rwbarton> bfs adj (0, available)
23:22:24 <rwbarton> not across several queries
23:22:39 <neutrino> but when paths cross-cut, will it be smart enough?
23:22:47 <neutrino> because otherwise this thing could explode exponentially
23:22:50 <rwbarton> within a single search it will only visit each node once, that is what the "seen" Set is for
23:22:53 <rwbarton> yes, of course
23:23:01 <neutrino> how is that done?
23:23:21 <rwbarton> see how it uses a pair of a queue and a set
23:23:46 <rwbarton> the queue contains vertices it still needs to visit, the set contains everything that has been put into the queue
23:23:49 <neutrino> yes
23:24:03 <neutrino> how does it know what vertices it needs to visit up front?
23:24:06 <neutrino> or
23:24:13 <neutrino> are those just the vertices it saw at that point?
23:24:25 <rwbarton> I don't really understand
23:24:37 <neutrino> in my case until you're at a certain vertex you don't see what other vertices are reachable from it
23:24:47 <rwbarton> well that is what adj is for
23:24:55 <neutrino> right
23:25:11 <neutrino> but then you discover the vertices iteratively, you don't need a predefined list of all possible vertices
23:25:15 <neutrino> right?
23:25:16 <rwbarton> correct
23:25:24 <rwbarton> that is what makes it so convenient for many purposes
23:25:34 <rwbarton> you don't even have to have a finite list of vertices
23:25:38 <neutrino> so the deque is going to be "vertices i saw so far but haven't visited"?
23:25:57 <rwbarton> right
23:26:02 <neutrino> ok that explains it
23:26:09 <neutrino> ok, so how is the memoization done?
23:26:14 <neutrino> we have a set and deque
23:26:36 <rwbarton> when it takes a vertex out of the queue, it checks whether it is in the set of things that have already been put in the queue, if so, it does nothing
23:26:41 <rwbarton> otherwise, it adds it to the queue and to the set
23:26:48 <rwbarton> just basic BFS algorithm
23:26:58 <rwbarton> er
23:27:11 <rwbarton> insert "for each of its neighbors, " in that first sentence
23:27:59 <neutrino> i'm not sure how i'd insert that there
23:28:09 <edwardk> shachaf: push?
23:28:10 <neutrino> ok wait
23:28:15 <rwbarton> after the first comma
23:28:32 <neutrino> when it takes a vertex out of the queue, for each of its neighbours, it checks whether it is in the set of things that have already been put in the queue, if so, it does nothing
23:28:36 <rwbarton> yes
23:28:42 <neutrino> what are neighbours?
23:29:12 <rwbarton> whatever adj returns on it...
23:30:02 <neutrino> wait
23:30:08 <neutrino> i would think it would work this way
23:30:46 <neutrino> when it takes a vertex out of the queue, it checks if it is in the set already, and if it is it does nothing. if it's not, it computes the vertex, and adds it to the set, and adds the neighbours to the queue.
23:31:01 <rwbarton> it's more efficient to just never put a vertex in the queue more than once
23:31:09 <rwbarton> well
23:31:12 <rwbarton> I imagine
23:31:14 <rwbarton> more space-efficient anyways
23:31:32 <neutrino> ah right
23:31:36 <neutrino> so let's revise that
23:31:52 <neutrino> when it takes a vertex out of the queue, it checks if it is in the set already, and if it is it does nothing. if it's not, it computes the vertex, and adds it to the set, and adds the neighbours to the queue if they're not in the set either..
23:32:01 <neutrino> is that what your bfs function does?
23:32:06 <shachaf> edwardk: Pushed.
23:32:55 <rwbarton> well no, you can still end up with the same vertex in the queue multiple times that way
23:33:02 <rwbarton> it does what I said it does :)
23:33:17 <edwardk> shachaf: hrmm. i think Control.lens.Internal's import won't work without an explicit export list.
23:33:26 <edwardk> it is in internal, but not exposed
23:33:28 <neutrino> rwbarton: i don't see how what you say it does works
23:33:54 <rwbarton> simple, the set's sole purpose is to ensure that no vertex ever enters the queue more than once
23:33:58 <shachaf> edwardk: Well, one way around it would be another module...
23:34:22 <neutrino> rwbarton: oh, so the queue is actually the list of vertices that have been computed already, but that haven't had their neighbours visited yet?
23:34:22 <edwardk> i'll just add the export list to Internal.
23:34:25 <shachaf> edwardk: Or we can just not export EvilBazaar at all.
23:34:29 <rwbarton> I don't know what "computed" means
23:34:34 <shachaf> Do we really want people writing it in their signatures?
23:34:35 <rwbarton> it's the normal bfs queue
23:34:38 <neutrino> computed = visited
23:34:40 <shachaf> This is "a temporary measure" at best.
23:34:54 <shachaf> If people want they can always write more polymorphic types.
23:34:58 <rwbarton> usually one says that one "visits" the vertex when removing it from the queue, I think
23:35:08 <rwbarton> a matter of terminology I guess
23:35:14 <shachaf> (In this case .Evil could be removed entirely.)
23:35:23 <neutrino> but when the vertex is in the queue, it's already in the set as well, right?
23:35:27 <rwbarton> yes
23:35:29 <neutrino> ok
23:35:38 <neutrino> that's the difference in semantics that was messing us up
23:35:59 <neutrino> ok, so, let's say you're visiting a vertex. you look at all of its neighbours, and one is not in the set yet.
23:36:11 <neutrino> you push that vertex to the set and to the queue
23:36:12 <neutrino> right?
23:36:15 <edwardk> it can leak to a signature the user should be able to write in a pinch
23:36:27 <rwbarton> right
23:36:37 <shachaf> Yes, but that signature'll break when this is fixed anyway...
23:36:49 <shachaf> But maybe it's useful to be able to write it.
23:36:55 <edwardk> assuming we can fix it
23:37:20 <neutrino> ok so now we have the function next.
23:37:23 <neutrino> :t unfoldr
23:37:23 <rwbarton> also, it outputs vertices when removing them from the queue. in retrospect this doesn't seem like the best way to do it
23:37:24 <vraid> i'm getting a stack overflow from (primes ps 0) !! 100000, with "primes ps n = x : primes ps x,  where x = nextPrime ps n", anything obvious i did wrong?
23:37:25 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
23:37:29 <rwbarton> yeah
23:37:50 <shachaf> vraid: Try adding a `seq` in there.
23:37:59 <vraid> at what point?
23:38:19 <neutrino> what is b in unfoldr?
23:38:22 <shachaf> If you have BangPatterns, you can use "!n" or "!x"
23:38:24 <shachaf> I think either would work.
23:38:31 <rwbarton> here b is the "state" of the queue and the set
23:38:48 <rwbarton> a is the type of thing it is outputing which it a pair (vertex, path)
23:38:51 <neutrino> so the current value of the set and queue after a single iteration
23:39:32 <neutrino> b carries the information on vertices that have been visited and that are yet to be visited, and nothing else, right?
23:39:39 <rwbarton> yes
23:39:50 <neutrino> that's very cool
23:40:04 <neutrino> the rest is just data manipulation, that seems easy enough to understand
23:40:18 <rwbarton> the only other sort of subtle thing is the way it uses difference lists for the path
23:40:31 <neutrino> can you explain?
23:40:41 <rwbarton> not tonight
23:40:44 <neutrino> ok
23:40:47 <neutrino> i have to go soon too
23:40:50 <rwbarton> ask Cale, he will be happy to explain :)
23:40:54 <neutrino> but give me some keywords?
23:40:58 <rwbarton> i already did
23:41:00 <neutrino> ok :)
23:41:01 <rwbarton> difference lists
23:41:03 <shachaf> rwbarton: toDListOf in lens isn't really necessary because you can use foldrOf l (:)
23:41:08 <neutrino> thanks rwbarton
23:41:29 <rwbarton> I should package up a better version of this code and other graph traversals
23:41:31 <neutrino> you're great help
23:41:39 <neutrino> yeah could be fun :)
23:42:08 <rwbarton> btw there is astar on hackage which is a fancier version
23:42:22 <rwbarton> but not 100% to my tastes
23:42:32 <rwbarton> only about 90%
23:42:59 * hackagebot cblrepo 0.7.1 - Tool to maintain a database of CABAL packages and their dependencies  http://hackage.haskell.org/package/cblrepo-0.7.1 (MagnusTherning)
23:43:05 <shachaf> > head $ toListOf (backwards traverse) [1..1000000]
23:43:08 <lambdabot>   *Exception: stack overflow
23:43:15 <shachaf> > head $ foldrOf (backwards traverse) (:) [] [1..1000000]
23:43:19 <lambdabot>   1000000
23:43:29 <neutrino> rwbarton: :) ok
23:43:31 <rwbarton> @type foldrOf ?l (:)
23:43:35 <lambdabot> (?l::Getting (Endo [a]) s t a b) => [a] -> s -> [a]
23:43:46 <Ralith> @hoogle Floating a => Float -> a
23:43:47 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
23:43:47 <lambdabot> Prelude acos :: Floating a => a -> a
23:43:47 <lambdabot> Prelude acosh :: Floating a => a -> a
23:43:58 <Ralith> hm.
23:44:14 <shachaf> Ralith: Isn't unsafeCoerce a great function?
23:44:19 <Ralith> :P
23:44:23 <shachaf> Ralith: I just introduced the first properly legitimate unsafeCoerce into lens.
23:44:23 <rwbarton> @type realToFrac
23:44:25 <lambdabot> (Fractional b, Real a) => a -> b
23:44:28 <Ralith> ah, thanks
23:44:39 <Ralith> shachaf: as opposed to all the illegitimate ones?
23:44:50 <shachaf> Hmm.
23:44:54 <shachaf> Properly illegitimate.
23:44:57 <rwbarton> as opposed to the boring ones, perhaps?
23:45:02 <edwardk> :t @type flip (foldrOf ?l (:)
23:45:04 <lambdabot> parse error on input `@'
23:45:07 <edwardk> @type flip (foldrOf ?l (:)
23:45:09 <lambdabot> parse error (possibly incorrect indentation)
23:45:14 <rwbarton> or improperly legitimate?
23:45:14 <edwardk> @type flip (foldrOf ?l (:))
23:45:16 <lambdabot> (?l::Getting (Endo [a]) b t a b1) => b -> [a] -> [a]
23:45:24 <shachaf> rwbarton: https://github.com/ekmett/lens/commit/7ec5e55c130093ad3f3428da12f866453d9f8412
23:45:28 <shachaf> See what you made me do!
23:46:27 <rwbarton> evilicious
23:47:19 <vraid> shachaf: could you help me understand how seq works?
23:47:31 <shachaf> @where lazy
23:47:32 <lambdabot> http://www.vex.net/~trebla/haskell/lazy.xhtml
23:47:34 <shachaf> vraid: Read that first.
23:48:59 <vraid> thanks, guess i'll be back later then
23:53:42 <booski> Is there a IntMap insert-like method for inserting a key only if it is not a member of a map?
23:54:50 <shachaf> You could use alter, presumably.
23:55:22 <rwbarton> or insertWith
23:57:27 <rwbarton> > M.fromList [(2,3)] % at 2 %~ (<|> Just 4)
23:57:29 <lambdabot>   fromList [(2,3)]
23:57:48 <copumpkin> :t IM.insertWith (const id)
23:57:49 <lambdabot> IM.Key -> a -> IM.IntMap a -> IM.IntMap a
23:57:59 <copumpkin> hmm
23:58:02 <copumpkin> or is it the other one
