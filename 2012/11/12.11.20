00:00:42 <Cale> @undefine
00:00:50 <edwardk> :t (%)
00:00:52 <lambdabot> a -> (a -> b) -> b
00:00:58 <edwardk> :t (R.%)
00:00:59 <Cale> > 47238 Data.Ratio.% 4890110
00:01:00 <lambdabot> Couldn't find qualified module.
00:01:01 <lambdabot>   23619 % 2445055
00:01:03 <edwardk> :t (Data.Ratio.%)
00:01:04 <Cale> wat
00:01:05 <lambdabot> Integral a => a -> a -> Ratio a
00:01:32 <edwardk> that works
00:01:36 <edwardk> Cale++
00:01:40 <Cale> @undefine
00:01:44 <Cale> > 47238 Data.Ratio.% 4890110
00:01:46 <lambdabot>   23619 % 2445055
00:01:48 <Cale> > 47238 R.% 4890110
00:01:50 <lambdabot>   23619 % 2445055
00:01:59 <edwardk> :t (%)
00:02:01 <lambdabot> a -> (a -> b) -> b
00:02:14 <Cale> I still think that backwards application is weird
00:02:31 <edwardk> it grows on you ;)
00:02:31 <shachaf> It would be nice if there was backwards composition.
00:02:35 <Cale> and its use should be discouraged :P
00:02:47 <shachaf> So (zipper % blah % blah % blah % rezip) would be a function.
00:03:10 <edwardk> shachaf: you can do that with (>>>) and (<<<) but the precedence is off
00:03:15 <Cale> You could just compose and write the functions in the other order
00:03:28 <shachaf> edwardk: Right.
00:03:56 <edwardk> cale: we went round on this one before. i acknowledge that you _could_. i have a terrible time believing one should =)
00:04:42 <edwardk> and composition with (.) has terrible precedence for mixing lenses with update operators
00:05:22 <Cale> I don't see the problem with writing it like that. It's just the usual order in which function compositions ordinarily are written in.
00:05:49 <Cale> What's wrong with f . g . h in a general setting?
00:05:57 <Cale> What makes lenses any different?
00:05:59 <edwardk> i don't have a problem with them in general
00:06:06 <pordan30> what is the best way to transmit composable proofs not dependent on values? for instance, suppose f1, f2 :: a -> b perform an operation f, but f1 approximates f1 and f2 is exact; and g1, g2 :: b -> c perform an operation g, and g1 can accept approximated inputs whereas g2 cannot. i see the following options: (a) enforce the relation though types, so that e.g., f1 :: a -> Tag Approx b and g2 :: Tag Either b -> c; or (b) constrain u
00:06:07 <pordan30> sing type-classes, so that e.g., f1 :: Approx b -> a -> b, g2 :: Either b => b -> c, where, say, Approx a => Either a is an instance. does one approach have an advantage?
00:06:42 <pordan30> backwards application makes modifying diagrams convenient in the diagrams package. i wasn't convinced that it was useful until seeing examples of such code without it.
00:07:04 <edwardk> the main quirky thing about lenses is it offers up a lot of ternary combinators for doing things like .~, which generate functions. but the precedence on those operators is at the level of ==, which is way lower than (.)
00:07:32 <edwardk> you could use $, but now you have something that looks imperative but reads ass backwards when using .~, and reads forward when using .=
00:08:09 <edwardk> using (%) means you don't have to flip everything around in your head and on the screen to go from functional composition style to the lens style
00:08:14 <edwardk> er to the state monadic style
00:08:37 <edwardk> t % bar .~ 12 % baz .~ 24   becomes do bar .= 12; baz .= 24
00:10:49 <edwardk> diagrams also provides a version of (%), but they called it (#). that is a bad choice for lens though, because it interacts poorly with magic hash and the penchant a lot of us have for writing a lot of lens code a little light on spaces, and that # is already in use with a different semiotic purpose in the loupe combinators.
00:11:08 <edwardk> so its not just lens that wants a name for that flipped application ;)
00:12:03 <yitz> edwardk: bite the bullet and use a two-character operator
00:12:59 <FireFly> let (£) = flip ($)
00:13:08 <yitz> haha
00:13:52 <edwardk> yitz: the problem is that the %~ and %= operators have a nice mnemonic. % is usually 'mod' to an imperative programmer, so those are 'mod-equals', this makes % the mod operator that is being applied to the target of the lens. If we switched to (|>), then |>= would fit that, but is downright hideous and then when you get down, Data.Sequence collides, and you wind up with things like (<|>=) which have nothing to do with (<|>)
00:14:07 <Jafet> > "£"
00:14:07 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
00:14:12 <shachaf> ▶ has no such issues.
00:14:24 <edwardk> %~ and %= are too common an operation to go to a 3 char identifier.
00:14:51 <shachaf> edwardk: Can you imagine using a *four*-character identifier for what (%~) does?
00:14:55 <shachaf> That would be ridiculous.
00:15:04 <edwardk> shachaf: =P
00:15:25 <latermuse> please dont use £, it isnt a key on my keyboard
00:15:36 <yitz> edwardk: use % for everything else. use something else instead of bare % as a special case. probably % with some other character, but i won't even suggest anything since i don't speak lensoperatorese.
00:15:37 <edwardk> latermuse: thats a large part of why i don't use it ;)
00:16:11 <shachaf> @let (») = (>>>)
00:16:12 <lambdabot>  <local>:1:2: lexical error at character '\187'
00:16:17 <shachaf> Bah.
00:16:35 <Jafet> ¥
00:16:42 <Ralith> wonder why it doesn't like that
00:16:52 <latermuse> edwardk: i saw your one-act play last night, and it blew my mind.
00:16:53 <shachaf> Ralith: Because it's a quote.
00:16:57 <sopvop> is @ a valid haskell identifier?
00:17:07 <shachaf> Nope.
00:17:09 <FireFly> @let (⋙) = (>>>)
00:17:10 <lambdabot>  Defined.
00:17:13 <shachaf> sopvop: Look it up on the Hoogle. :-)
00:17:18 <yitz> sopvop: no it's a pattern matching character
00:17:23 <shachaf> 22D9   VERY MUCH GREATER-THAN     [⋙]
00:17:35 <sopvop> oh yeah
00:17:42 <shachaf> Ah, right next to my favorites
00:17:44 <Ralith> haha
00:17:44 <shachaf> 22DA   LESS-THAN EQUAL TO OR GREATER-THAN     [⋚]
00:17:44 <shachaf> 22DB   GREATER-THAN EQUAL TO OR LESS-THAN     [⋛]
00:17:54 <FireFly> Yeah, those are cute :p
00:18:06 <Ralith> shachaf: what does haskell use to classify unicode?
00:18:14 <Ralith> er, ghc
00:18:16 <shachaf> Ralith: The Unicode spec.
00:18:19 <shachaf> Presumably.
00:18:21 <Ralith> it's got the full table?
00:18:22 <yitz> shachaf: 22d9 doesn't show in my irssi font. the others do though.
00:18:25 <pharaun> unicode is great till i can't type it :p
00:18:34 <shachaf> yitz: Looks like >>>
00:19:06 <yitz> shachaf: i figured. that's the one we want! too bad i can't see it.
00:19:06 <edwardk> yitz: we have gone through a lot of pain and pissed off a lot of early users constantly changing things to get to a consistent set of symbol usage. we pretty much agonized over whether we should grab (%), but consistency in this one case won out. i understand your position, it was one we weighted very strongly, it just didn't make sense in the grand scheme of things.
00:19:25 <sopvop> can `foo` ops have fixity?
00:19:43 <shachaf> Yes.
00:20:30 <yitz> edwardk: well that's fine. but the consequence of that decision should be that you'll have to paste your examples in lambdabot. % has a deeply ingrained meaning in haskell.
00:20:32 <pordan30> what's wrong with `&' for `flip ($)'? it seems rather intuitive, reading: x & f & g as: x `at' f `then' g, which translates: [do f at x, then g] i.e., g (f x) fairly well.
00:21:16 <shachaf> Ralith: A big awk script.
00:21:47 <shachaf> (Really.)
00:22:38 <yitz> Ralith: i think it just has a bunch of hard coded functions based on some earlier version of Unicode. (hope i'm wrong)
00:23:27 <Ralith> shachaf: oh dear.
00:34:53 <dreixel> how can I check if I installed the 64bit or 32bit version of GHC?...
00:35:06 <shachaf> ghc --info?
00:35:10 <shachaf> Or look at the binary.
00:35:12 <shachaf> Or who knows.
00:35:30 <dreixel> --info works, thanks
00:35:44 <dreixel> ,("target arch","ArchX86_64")
00:35:54 <dreixel> turns out with a 64bit GHC I cannot install hmatrix
00:36:04 <dreixel> maybe because the .dlls it depends on are 32bit?...
00:36:40 * hackagebot Monadius 0.98 - 2-D arcade scroller  http://hackage.haskell.org/package/Monadius-0.98 (HideyukiTanaka)
00:38:05 <fmap> > maxBound :: Int
00:38:06 <lambdabot>   9223372036854775807
00:38:56 <edwardk> pordan30: many of us just can't type the thing
00:39:12 <yitz> > length . takeWhile (> 0) . iterate (`div` 2) $ (maxBound :: Int)
00:39:14 <lambdabot>   63
00:39:24 <edwardk> pordan30: oh, just &
00:39:27 <edwardk> hrmm
00:39:41 <edwardk> i was reading that as a pound sign
00:40:15 <edwardk> :t (Data.Bits.Lens.&=)
00:40:17 <lambdabot> (MonadState s m, Bits a) => Simple Setting s a -> a -> m ()
00:40:23 <yitz> edwardk: it looks like the framers of haskell purposely tiptoed around &, using && and .&., just to leave it free for you
00:40:26 <shachaf> edwardk: To be fair, the operator's usual name is .&.
00:40:33 <fmap> (&) is used in optparse-applicative, but it's just a mappend there
00:40:51 <edwardk> shachaf: yes and to be fair everyone coming from c/c++ expects &= and |= to be bitwise =P
00:41:12 <shachaf> Sure.
00:41:36 <shachaf> edwardk: But by the logic that required you to  export (%) for (%~)/(%=), you must also export (|) for (|~) and (|=)
00:41:42 * hackagebot http-conduit-browser 1.6.6 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.6 (MikhailKuddah)
00:41:48 <edwardk> shachaf: but i can't there. ;)
00:41:54 <shachaf> Exactly.
00:42:15 <shachaf> edwardk: It's annoying that "at" for Map has to be implemented by going down the tree twice.
00:42:20 <edwardk> the fact that (%) reads as mod and (%~) and (%=) are already the operators in all the other lens libraries is what led to the export of (%)
00:43:01 <edwardk> zipper ("hello","world") & … & .. &  -- isn't that bad i admit
00:43:07 <shachaf> I guess there's nothing much to do about it.
00:43:17 <shachaf> edward: How about (%) = flip ($), (&) = flip (.)?
00:43:23 <shachaf> That way everyone's unhappy.
00:43:25 <edwardk> shachaf: =P
00:43:31 <shachaf> (But it would be sort of nice.)
00:43:56 <shachaf> Is there any reason Data.Map doesn't provide an operation like update with effects?
00:43:59 <FireFly> I like (¦) as flip (.), but that's the not-on-everyone's-keyboard issue again
00:44:19 <shachaf> k -> (Maybe v -> f (Maybe v)) -> Map k v -> f (Map k v)
00:44:32 <fmap> lens could provide XCompose tutorial..
00:44:40 <edwardk> shachaf: not really. other than the authors not really liking things that use third part monads
00:44:43 <edwardk> fmap: =)
00:46:23 <shachaf> edwardk: Why not?
00:46:31 <edwardk> yitz: i'll at least think about (&). its a pretty plausible compromise. not promising anything yet mind you. ;)
00:46:41 * hackagebot instant-generics 0.3.7 - Generic programming library with a sum of products view  http://hackage.haskell.org/package/instant-generics-0.3.7 (JosePedroMagalhaes)
00:46:48 <shachaf> Presumably it would be more efficient, and allow you to write a lot of operators that otherwise have to be provided directly.
00:46:53 <edwardk> shachaf: probably because they cant reason about the behavior
00:47:15 <edwardk> and anything that tends to hold the map open is less efficient in practice than the thing that traverses it twice in benchmarking
00:47:27 <shachaf> Really? Why?
00:47:30 <edwardk> no idea
00:47:45 <shachaf> Anyway, this would let you write something like updateLookupWithKey
00:47:52 <shachaf> That doesn't really "hold the map open"
00:47:56 <edwardk> i haven't been able to make nice zipper based apis for maps that don't suck
00:48:49 <shachaf> Map has traverseWithKey
00:49:17 <deus_rex> > (words . reverse) "foo"
00:49:19 <lambdabot>   ["oof"]
00:50:00 <shachaf> instance Ord k => TraversableWithIndex k (Map k) where itraverse f = sequenceA . Map.mapWithKey f
00:50:03 <shachaf> Any reason?
00:51:41 * hackagebot http-conduit-browser 1.7.0 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.7.0 (MikhailKuddah)
00:51:46 <shachaf> Oh, it's because it's not in containers 0.4.0.0, which lens is compatible with.
00:52:13 <edwardk> shachaf: we can add a check for a modern containers. i do it elsewhere
00:52:46 <edwardk> just make sure to include the nonsense at the top of the file like we do with the other checks to make sure it works even when that module is loaded directly in ghci
00:53:10 <mindbender1> how do I return to the top-level context in ghci
00:53:22 <Nereid> what top-level context
00:53:49 <mindbender1> after using :m to switch context
00:53:50 <shachaf> What nonsense?
00:53:55 <edwardk> yitz: i'm flipping over to (&) in the next major release. so you'll get your (%), but it'll probably take a few days
00:53:59 <shachaf> mindbender1: :m just loads and unloads modules
00:54:10 <Nereid> load with +, unload with -
00:54:31 <edwardk> there is some CPP fiddliness for making sure the macros that cabal defines are defined even when not using cabal. look for ifdefs most are like that ;)
00:54:52 <mindbender1> Prelude Data.Char>  I want to return to Prelude>
00:55:00 <Nereid> :m -Data.Char
00:55:16 <mindbender1> thanks
00:55:18 <Nereid> although why not use :set prompt
00:55:24 <Nereid> so you can load as many things as you want
00:55:25 <shachaf> Oh, like #ifndef MIN_VERSION_mtl #define MIN_VERSION_mtl(x,y,z) 1 #endif
00:55:29 <Nereid> without cluttering it up
00:55:33 <mindbender1> ok
00:55:45 <edwardk> @let (&) = (%)
00:55:46 <Nereid> example: :set prompt ">>> "
00:55:48 <lambdabot>  Defined.
00:55:48 <edwardk> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'J' & rightmost & focus .~ 'y' & rezip
00:55:51 <lambdabot>   Couldn't match expected type `((Control.Lens.Zipper.Top
00:55:51 <lambdabot>                    ...
00:55:59 <edwardk> oh it got the wrong fixity
00:56:04 <edwardk> can @let do fixity?
00:56:10 <edwardk> @undefine
00:56:34 <shachaf> @let (&) = (%); infixl 1 &
00:56:36 <lambdabot>  Defined.
00:56:43 <shachaf> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'J' & rightmost & focus .~ 'y' & rezip
00:56:45 <lambdabot>   ("Jelly","world")
00:56:45 <boegel> hi all!
00:56:58 <boegel> does someone know which bot takes care of the logging in here?
00:57:03 <shachaf> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
00:57:05 <lambdabot>   ("Jelly","world")
00:57:09 <shachaf> (%) stands out more to my eye.
00:57:24 <edwardk> yeah, but the & does read pretty well
00:57:43 <edwardk> and it'll avoid another knock-down drag out like this
00:57:45 <deus_rex> @type (&Z)
00:57:47 <lambdabot> Not in scope: data constructor `Z'
00:57:49 <deus_rex> @type (&)
00:57:50 <lambdabot> a -> (a -> b) -> b
00:58:17 * obk rises from the deep
00:58:24 <obk> What's that about replacing % with & ? :-)
00:59:05 <Nereid> boegel: it says it on the log page
00:59:13 <Nereid> "clog"
00:59:28 <shachaf> > zipper ("hello","world") & down _1 & fromWithin traverse & focus .~ 'J' & rightmost & focus .~ 'y' & rezip
00:59:30 <lambdabot>   ("Jelly","world")
00:59:43 <edwardk> obk: we lose consistency with %~ but we gain the fact that we no longer collide with Data.Ratio and have to deal with folks wanting to get off their lawn =P
00:59:47 <edwardk> er wanting us
01:00:02 <Nereid> I like % better :(
01:00:12 <edwardk> Nereid: i did too honestly
01:00:24 <pordan30> the real solution is to standardize the use of apl keyboards
01:00:35 <edwardk> one pro of this is that foo & bar %~ baz   -- no longer looks as silly as foo % bar %~ baz did ;)
01:00:38 <obk> edwardk: We knew about Data.Ratio. And there was the lens library that used # instead of %, I don't recall which one.
01:00:54 <shachaf> (#) is a bit of a problem because of MagicHash
01:00:56 <obk> Wait, you still want to keep %=?
01:00:58 <edwardk> obk: (#) is in diagrams, but its not suitable for lens for other reasons.
01:00:59 <edwardk> yes
01:01:04 <edwardk> we kept (%~) etc.
01:01:10 <edwardk> just changed (%)
01:01:17 <obk> The consistency between % and %= made sense to me...
01:01:19 <edwardk> or rather i'm currently doing so
01:01:21 <edwardk> it did to me to
01:01:32 <edwardk> too
01:01:43 <obk> I don't suppose we can convince Data.Ratio to use something else rather than % :-(
01:01:44 <edwardk> and 99% of the users didn't object
01:02:12 <obk> It isn't a show-stopper, but IMVHO this change "isn't nice"...
01:02:12 <edwardk> i've had 2-3 strong objectors
01:02:19 <edwardk> sure
01:02:34 * obk would count as a "moderate objector"
01:02:52 <boegel> Nereid: ok, now where do I get more info on clog?
01:02:56 <Nereid> I don't know :D
01:03:04 <boegel> Nereid: :)
01:03:06 <obk> How many of Data.Ratio's users would object to them changing from % ? :-)
01:03:11 <Itkovian> boegel: hackae
01:03:11 <edwardk> i'm not happy about a pretty major break in compatibility, i'm a strong-to-middling objector
01:03:20 <mgsloan> (#) for diagrams consistency!!
01:03:20 <shachaf> boegel: tunes.org?
01:03:24 <edwardk> obk: that API is close to 20 years old =P
01:03:29 <shachaf> 3.4 is shaping up to be a big release.
01:03:43 <shachaf> Especially if it gets held back until taking is worked out.
01:03:44 <obk> What about using # and #=/#~ ?
01:03:55 <obk> You said there was another reason not to do it.
01:04:36 <shachaf> GHC has some issues with (#) + MagicHash
01:04:40 <shachaf> Or maybe that's just ghci.
01:05:14 <b_jonas> obk: wouldn't that break compat with the haskell standard? not that ghc hasn't already done that in other cases, but still.
01:05:29 <shachaf> b_jonas: Well, (%) isn't in the Prelude.
01:05:35 * obk sighs. If we only had Unicode keyboards ;-)
01:05:46 <shachaf> We do!
01:05:53 <b_jonas> shachaf: not in the prelude, but in a module defined by H2010, right?
01:05:57 <shachaf> b_jonas: Yes.
01:06:02 <shachaf> Admittedly most of them are restricted to codepoints below 127.
01:06:17 <shachaf> (But not mine! «»äåéëáßðfáhú®¤ä¤€®ñµ)
01:06:49 <Nereid> how about €
01:07:06 <b_jonas> you could define a longer synonym for both (%), but keep both (%) and let people decide what to import
01:07:12 <b_jonas> what's this new % thingy by the way?
01:07:14 <yitz> shachaf: anyone using emacs can type any unicode character fairly easily
01:07:31 <edwardk> b_jonas: &
01:07:45 <edwardk> its typeable, 1 character, and not used
01:07:48 <shachaf> yitz: I don't think the all vim users are a hit that #haskell can take.
01:07:59 <shachaf> b_jonas: flip ($)
01:08:17 <shachaf> yitz: (...And, you know, every editor except emacs.)
01:08:19 <yitz> shachaf: true. i'll bet there's something you can do in vim, too, though. i'm just not as good at vim as i am at emacs.
01:08:23 <edwardk> b_jonas: and it has the benefit that it reads right for the common use
01:08:23 <b_jonas> seriously? they want an operator for that?
01:08:32 <b_jonas> just call it $~ or something
01:08:34 <edwardk> yitz: you can use digraphs in vim, nobody does
01:08:34 <obk> edwardk: Reads right?
01:08:49 <obk> record & field ~= value
01:08:55 <edwardk> obk: 'just read it as &'
01:09:01 <edwardk> er as and
01:09:02 <shachaf> I assume "do this and this and this and this"?
01:09:05 <obk> Sorry, I meant record & field %~ value
01:09:09 <edwardk> shachaf: yep
01:09:22 <edwardk> shachaf: you get a little breathless reading code that way, but it works for the most part
01:09:28 <Nereid> > (1,'a') & _2 %~ succ
01:09:31 <lambdabot>   (1,'b')
01:09:43 <obk> What I'd really love to use is the : - record : field :~ value (or, monadic, field := value).
01:09:48 <obk> That would have been awesome.
01:09:57 <shachaf> obk: Get in line.
01:09:58 <obk> But like Larry Wall said, "everybody wants the :)
01:10:01 <edwardk> obk: alas : is special =P
01:10:07 <b_jonas> no way. colon has a much more useful ues
01:10:11 <shachaf> edwardk: It works for everything except the first &, really.
01:10:12 <obk> I thought that restriction was lifted lately?
01:10:21 <shachaf> edwardk: Which suggests that (&) should be flip (.)
01:10:22 <obk> It used to be that : was only for type operators
01:10:35 <Nereid> it still is
01:10:41 <edwardk> shachaf: ahahaha
01:10:48 <Nereid> it's just that more things are type operators now
01:10:49 <obk> Ah. I must have mis-read something.
01:10:55 <edwardk> obk: not here. they changed it at the type level operators
01:10:58 <Nereid> i.e. everything
01:11:14 <obk> So if type operators can be everything, why still restrict : ?
01:11:14 <edwardk> he motivation is because then (+) can be a type family
01:11:27 <shachaf> conal is still mad at them for that.
01:11:28 <edwardk> obk: because at the value level we need to know what is a constructor and what is a function
01:11:49 <b_jonas> isn't it that operators starting with a colon are like uppercase identifiers?
01:11:55 <b_jonas> the mean constructors or type constructors
01:12:03 <shachaf> b_jonas: Yes, except that changed for types.
01:12:07 <obk> But if type operators can be "everything" (not _have_ to start with a ":"), then... how does it help to forbid it from regular operators?
01:12:12 <b_jonas> shachaf: uh, in what way?
01:12:16 <shachaf> Now you can data a + b = L a | R b
01:12:23 <edwardk> shachaf: its the right long term call though, despite the pain. a usable notion of 3 + 2 at the type level is more valuable than a bunch of local (~>) bindings that have crappy precedence and require parens anyways
01:12:34 <b_jonas> but how does that work?
01:12:39 <Saizan> obk: value operators can't be
01:12:55 <Ralith> b_jonas: type contexts in haskell are unambiguous.
01:12:57 <shachaf> b_jonas: Every operator is a constructor.
01:12:58 <Ralith> (afaik)
01:13:01 <edwardk> obk: at the type level there is no ambiguity, you just don't have type level _variable_ operators.
01:13:02 <obk> Saizan: can't be what?
01:13:10 <shachaf> "everything"
01:13:13 <mapf> there is the right way to find hash? class Hashable a where hash :: a -> Int  or something else?
01:13:14 <Saizan> obk: everything
01:13:14 <b_jonas> don't they have to be separated for syntax reasons so you can override any symbol in an inner context? or is that only on the data level?
01:13:15 <edwardk> you can't say type Foo (+) = …  any more
01:13:19 <edwardk> just type Foo k = ...
01:13:31 <b_jonas> edwardk: what? but I _can_ have type level variable operators
01:13:31 <edwardk> but those type variables are only local in scope anyways
01:13:44 <b_jonas> like, ones scoped with foreach
01:13:48 <edwardk> b_jonas: you could. 7.6.1 takes them away
01:13:54 <b_jonas> oh NO!
01:14:07 <b_jonas> so now you can use only alphabetic names for them?
01:14:09 <obk> Well, this is all getting side-tracked, anyway. So I guess changing the rules to allow for ":" and ":=", ":~" is out. Sigh :-(
01:14:12 <b_jonas> crazy
01:14:13 <edwardk> b_jonas: its painful but the payout will be worth it in the long term.
01:14:22 <Nereid> there's still that >~a~> trick
01:14:24 <Saizan> obk: more correctly, you still can't define data Foo = Bar & Baz; you have to define data Foo = Bar :& Baz
01:14:25 <edwardk> b_jonas: i posted a trick you can use to work around it on the mailing list
01:14:29 <edwardk> Nereid: yeah
01:14:42 <obk> Saizan: Ah, I see.
01:14:43 <mapf> ok Data.Hashable is exaclty that i need
01:14:44 <deus_rex> > (68 * 5) & Just
01:14:45 <Nereid> or -a> heh
01:14:47 <lambdabot>   Just 340
01:14:47 <b_jonas> does this interact with the data lifting extension?
01:14:56 <b_jonas> Nereid: heh
01:14:57 <obk> Sigh. So & is it?
01:14:59 <edwardk> you can make types -: and  :>   such that x -:c:> y    is an arrow
01:15:06 * obk foresees a long day of fixing it in all my code.
01:15:12 <shachaf> obk: You can always define (%) = (&) in your own project.
01:15:13 <edwardk> obk: alas, yes
01:15:19 <shachaf> If you really want it.
01:15:26 <obk> shachaf: I _could_...
01:15:31 <edwardk> Nereid: sadly - doesn't work as a type =(
01:15:38 <Nereid> oh?
01:15:45 <edwardk> yeah. not sure why
01:15:50 <shachaf> Alternatively, you could probably replace it with one semi-careful regexp.
01:16:03 <obk> When is the & going to be pushed to Hackage?
01:16:04 <edwardk> -a> was my preferred version but i couldn't use it ;)
01:16:09 <Nereid> heh
01:16:12 <edwardk> obk: as soon as it compiles clean ;)
01:16:13 <Nereid> --a>  ;)
01:16:16 <shachaf> obk: After "taking" gets fixed, I bet. :-)
01:16:27 <Saizan> are you really changing (%)?
01:16:29 <edwardk> Nereid: nice comment
01:16:29 <obk> Would that be a major version # change?
01:16:38 <edwardk> obk: definitely
01:16:40 <Nereid> ;)
01:16:47 <shachaf> What, lens 4.x?
01:16:52 <edwardk> there is some other stuff in flight for the next version
01:16:58 <edwardk> shachaf: nah, still on 3.x
01:17:13 * obk will put his head in the sand and ignore this for a couple of weeks...
01:17:16 <edwardk> just bumping x in 3.x.y
01:18:13 <Saizan> imo, it still stands the fact that Data.Ratio.(%) is mostly subsumed by (/)
01:18:34 <shachaf> Yes, I'm not *quite* clear on why yitz is so mad about it.
01:18:57 <Saizan> we could gather some statistics of Data.Ratio.(%) use on hackage to tell if it's so fundamental
01:19:20 <shachaf> A lot of times people use it where (/) would work too.
01:19:45 <shachaf> But if anything clearing up the idea that (/) --> Double from people's heads is a good thing. Double is evil.
01:19:55 <deus_rex> > (23 / 5) :: Ratio Integer
01:19:56 <lambdabot>   23 % 5
01:20:30 <Nereid> > 1728 / 8 :: Rational
01:20:32 <lambdabot>   216 % 1
01:20:44 <edwardk> honestly right up until the (&) suggestion was going to shrug, say sorry and carry on, but once a viable alternative was offered i couldn't just sit on my high horse =P
01:21:43 <Nereid> so
01:21:50 <Nereid> what was wrong with Ratio Int?
01:21:51 <obk> edwardk: Now you are talking. All we need is a good reason why & doesn't work, then :-)
01:22:35 * obk finds it surprising nobody used & for anything so far.
01:22:40 * Nereid too
01:22:53 <b_jonas> obk: we've been reserving it for the user's code
01:23:01 <edwardk> Nereid: fairly small Ratio Int's can wrap.
01:23:03 <obk> ?
01:23:04 <b_jonas> just like (?), only that clashes with an extension
01:23:09 <edwardk> i mean they aren't even all that exotic
01:23:12 <Nereid> which extension?
01:23:21 <shachaf> ImplicitParams
01:23:22 <edwardk> :t ?a
01:23:24 <lambdabot> (?a::t) => t
01:23:25 <Nereid> oh that
01:23:30 <b_jonas> that yes
01:23:36 <Nereid> never used it
01:24:06 <edwardk> its useful as a 'poor man's holes' until we get them ;)
01:24:26 <b_jonas> at least put a new synonym for Data.Ratio.(%) in Data.Ratio so people can start using it to ease transition later when (%) gets reused
01:24:34 <edwardk> want an error with a type report? just from ?foo x y z -- and you can see the args
01:24:42 <b_jonas> holes?
01:24:51 <shachaf> @google ghc holes
01:24:53 <lambdabot> http://hackage.haskell.org/trac/ghc/wiki/Holes
01:24:53 <lambdabot> Title: Holes – GHC
01:25:00 <b_jonas> ok
01:25:13 <merijn> Basically undefined, but cooler :p
01:25:40 <b_jonas> oh no that page starts with a crazy analogy
01:25:55 <edwardk> it lets you get the type of a place in your code and see the types of the stuff you've locally defined that can fit into that place
01:26:21 <edwardk> its really really insanely useful when writing CPSd code.
01:27:20 <edwardk> shachaf: if we could get taking fixed i'd be happy shipping with the (&)
01:27:35 <fenton> does anyone have decent instructions on how to setup a good haskell dev environment in arch (or gentoo)?
01:27:39 * obk needs to dive back into his day job
01:28:43 <Ralith> fenton: arch? if you can tolerate 7.6, just do the obvious
01:29:00 <Ralith> gentoo, you to twiddle some knobs to not get 6.something
01:29:44 <Nereid> gentoo, you use the haskell ovelray
01:29:45 <Nereid> overlay
01:29:55 <fenton> Ralith: i'm looking to either find or create some docs that can walk a newbie through it...what would you recommend start with gentoo or arch...which would be easier?
01:30:28 <Ralith> I question the implication that anyone who uses gentoo can reasonably expect to be treated like a newbie
01:30:29 <fenton> i'm guessing too much doesn't work with 7.6?
01:30:33 <Ralith> that aside, yeah.
01:30:42 <Ralith> go with the one that doesn't force the bleeding edge.
01:30:43 <Nereid> lots of things aren't yet compatible with 7.6 yeah
01:31:06 <fenton> okay, I'll continue down the gentoo route for now...
01:31:14 <Nereid> so it's still keyword-masked in the haskell overlay
01:31:25 <Nereid> but yeah, gentoo is a matter of
01:31:29 <Nereid> fiddle with keywords; emerge haskell-platform
01:32:14 <fenton> alright, i'll back my vm up and redo on gentoo...the 6.x didn't get me very far with yessod...my ultimate goal.
01:32:44 <b_jonas> shachaf: ok, but I hope that's not the only use for ImplicitParams
01:34:09 <shachaf> aristid: I bet you're in favor of (&) = (<*>)
01:34:26 <Nereid> but (<*>) is neither (.) nor ($)
01:34:38 <Nereid> (even up to a flip)
01:34:39 <Nereid> oh
01:35:34 <Nereid> I would be less hesitant to use <*> and friends if they were one character, tbh
01:35:35 <Nereid> :p
01:35:44 <Nereid> just a little.
01:35:47 <shachaf> And he also advocated (.) = (<$>)
01:35:53 <shachaf> So f . x & y & z
01:36:07 <jacobian> what is the most effective haskell tag generator?
01:36:15 <shachaf> hasktags?
01:36:17 <jacobian> I'd like M-. to work in emacs
01:36:23 <shachaf> It's the most effective for me since it's the first one I found.
01:36:31 <jacobian> ;)
01:36:42 <Nereid> I should figure out how to use tags.
01:36:54 <jacobian> Does it generally get to the correct definition?
01:37:11 <edwardk> shachaf is just shopping around for other uses to put (&) to, to keep from switching from (%) ;)
01:37:14 <shachaf> Try it out!
01:37:22 <shachaf> edwardk: I don't care much one way or the other.
01:37:41 <edwardk> shachaf: it should be on github now
01:37:43 <shachaf> Hmm, you're switching (^%) too?
01:37:56 <edwardk> ^% was & with tighter precedence is all
01:38:03 <shachaf> Hmm, you sneaked in non
01:38:09 <edwardk> no semantic tie to %~, etc.
01:38:13 <edwardk> yeah
01:38:46 <shachaf> @ty fromMaybe
01:38:47 <Nereid> I have to admit, I haven't written a whole lot of code.
01:38:48 <lambdabot> a -> Maybe a -> a
01:38:57 <Nereid> probably less than 10k lines in my life. :s
01:39:19 <shachaf> @ty \p v' -> if p v then Just v else Nothing
01:39:21 <lambdabot> (Expr -> Bool) -> t -> Maybe Expr
01:39:25 <shachaf> @ty \p v -> if p v then Just v else Nothing
01:39:26 <lambdabot> (a -> Bool) -> a -> Maybe a
01:39:28 <Nereid> not counting TeX
01:39:35 <shachaf> "toMaybe"?
01:39:44 <shachaf> Bools are somewhat ugly, though.
01:39:47 <edwardk> i thought about using that name ;)
01:41:47 <shachaf> edwardk: Are there two different definitions of non there?
01:42:21 <edwardk> non :: Eq a => a -> Simple Iso (Maybe a) a
01:42:21 <edwardk> non a = iso (fromMaybe a) go where  go b | a == b    = Nothing;       | otherwise = Just b
01:42:23 <edwardk> is all i see
01:42:46 <edwardk> i might have removed the --'d other one in a second patch
01:42:51 <shachaf> Oh, whoops.
01:42:57 <shachaf> Oh, now I see why you objected to non before.
01:43:05 <shachaf> As an isomorphism between (Maybe a) and a it's indeed fishy.
01:43:13 <Nereid> quite.
01:43:20 <edwardk> yeah, its just convenient ;)
01:43:25 <shachaf> Why an isomorphism?
01:43:37 <edwardk> because you can run it backwards
01:43:40 <shachaf> I'd understand an isomorphism between Maybe a and Maybe a
01:43:49 <shachaf> Then you can traverse with it or something.
01:44:09 <edwardk> it explicitly documents that it considers it an isomorphism from Maybe (a sans v) to a
01:44:15 <edwardk> so 'v' is not in the domain
01:44:26 <bitonic> why does something like this fail the coverage condition: `instance MonadState s m => MonadState s (InputT m) where'?
01:44:29 <shachaf> Explicit to people who read comments!
01:44:47 <edwardk> bitonic: instance MonadState s m => MonadState (Foo s) (InputT m) would pass it
01:45:13 <edwardk> you need to refine all args to a MPTC
01:45:19 <bitonic> edwardk: OK but why?  if `s' appears in `m', then it appears in `InputT m'
01:45:25 <edwardk> otherwise you get that
01:45:27 <Saizan> i think the coverage condition wants s to appear in (InputT m), actually
01:45:31 <Saizan> because of the fundep
01:45:45 <bitonic> Saizan: but it must
01:45:55 <Saizan> bitonic: syntactically
01:45:57 <edwardk> bitonic: reasoning about that requires the functional dependency
01:46:08 <Saizan> bitonic: i.e. the MonadState s m premise doesn't matter
01:46:16 <bitonic> oh, right.
01:46:34 <bitonic> I *always* forgot this.  I just can't accept it
01:47:10 <edwardk> shachaf: don't worry, nobody who doesn't read comments even knows the laws, so they can't call us on it ;)
01:47:12 <bitonic> so edwardk suggestion wouldn't work
01:47:15 <Saizan> tbf, the fact it doesn't matter for this check is not strictly related to the fact it doesn't matter for instance resolution
01:47:24 <edwardk> bitonic: possibly not. i'm thinking of another error
01:47:29 <shachaf> edwardk: That's nonsense. I learn all the laws from IRC.
01:47:47 <shachaf> Comments are for other people to read and then tell me about.
01:47:49 <edwardk> shachaf, lens lawyer
01:47:50 <bitonic> edwardk: I don't see how it helps.  anyway, thanks
01:49:11 <edwardk> bitonic: i saw an MPTC with an error, usually the error is complaining that you didn't refine all args of the MPTC, when doing so in the absence of a fundep, now state has one, but i figured you had some combination of flags complaining…. never mind
01:49:19 <shachaf> edwardk: By the way, what about the "simple = isomorphic id id" thing?
01:49:33 <edwardk> :t simple
01:49:35 <lambdabot> (Functor f, Isomorphic k) => k (a -> f b) (a -> f b)
01:49:45 <edwardk> :t isomorphic id id
01:49:47 <lambdabot> Isomorphic k => k b b
01:50:17 <shachaf> @ty Control.Category.id :: (Functor f, Isomorphic k) => k (a -> f b) (a -> f b)
01:50:17 <edwardk> :t dynamic
01:50:18 <FireFly> @src Isomorphic
01:50:19 <lambdabot> (Functor f, Isomorphic k) => k (a -> f b) (a -> f b)
01:50:19 <lambdabot> Source not found. :(
01:50:19 <lambdabot> Not in scope: `dynamic'
01:50:27 <edwardk> :t Data.Dynamic.Lens.dynamic
01:50:29 <FireFly> Poor lambdabot gets a lot of work
01:50:30 <lambdabot> (Typeable b, Typeable a, Applicative f, Projective k Dynamic b) => k (a -> f b) (Dynamic -> f Dynamic)
01:50:32 <edwardk> :t Data.Dynamic.Lens.dynamic . simple
01:50:34 <lambdabot> (Functor (k (a -> f b)), Typeable b, Typeable a, Applicative f, Isomorphic k) => k (a -> f b) (Dynamic -> f Dynamic)
01:50:47 <shachaf> That's issue 99
01:50:52 <edwardk> hrmm simple is borked it should be typing us to (a -> f a)  -> b -> f b
01:50:59 <shachaf> Hmm, up to 101
01:51:40 <exDM69> what's the idiomatic way of doing something like an assert() in IO code?
01:51:50 <exDM69> let True = my condition here
01:51:50 <exDM69> ?
01:51:55 <shachaf> exDM69: You could use assert
01:52:02 <shachaf> assert x $ return (), or something.
01:52:26 <exDM69> ok
01:52:34 <shachaf> Not sure if that's idiomatic.
01:52:43 <shachaf> assert is a magic function that gives you a line number, though.
01:52:46 <shachaf> So there's that.
01:53:16 <exDM69> a failed pattern matching gives line numbers too
01:53:24 <shachaf> True.
01:53:34 <quicksilver> but let is lazy
01:53:45 <shachaf> let !True = ...
01:53:45 <quicksilver> > let True = 1 + 1 == 3 in "hi there"
01:53:47 <lambdabot>   "hi there"
01:53:55 <shachaf> > let !True = 1 + 1 == 3 in "hi"
01:53:58 <lambdabot>   "*Exception: <interactive>:3:5-22: Non-exhaustive patterns in pattern binding
01:54:07 <typoclass> exDM69: yup, try http://www.haskell.org/ghc/docs/7.0.2/html/users_guide/assertions.html . however those asserts go away if you use -O to compile optimized
01:54:36 <typoclass> ... and to me "let !True =" looks like a clever and clear way
01:55:00 <shachaf> You could also define an ASSERT() macro C-style.
01:55:25 <shachaf> +* Made `indexed`, `taking` and `dropping` lazier, and capable of dealing with infinite lists, but at the cost that `taking` can no longer accept a `Fold`.
01:55:31 <shachaf> Don't give up!
01:56:45 <edwardk> well, i try to keeo the CHANGELOG accurate
01:56:56 <edwardk> if we change it i'll happily drop the comment ;)
01:57:31 <edwardk> https://github.com/ekmett/lens/issues/96 remains open
01:57:40 <Nereid> so any thoughts on a unary operator for from?
01:57:46 <shachaf> Do you mind if I get rid of IndexingResult and just use tuples?
01:58:02 <edwardk> shachaf: feel free
01:58:06 <shachaf> Nereid: Unary? As in (... ¯¹)?
01:58:10 <Nereid> yes
01:58:13 <edwardk> it used to be strict, which was when it mattered
01:58:24 <Nereid> well
01:58:38 <Nereid> except the -1 would be some valid operator name.
01:58:40 <typoclass> hm, how many unary operators do we have anyway? just (-)?
01:58:41 <edwardk> Nereid: sure, we'll call it % ;)
01:58:45 <Nereid> haha
01:59:12 <shachaf> @let (?) = from
01:59:14 <lambdabot>  Defined.
01:59:22 <shachaf> > view (_identity?) (Identity 5)
01:59:23 <lambdabot>   Not in scope: `_identity'
01:59:24 <lambdabot>  Perhaps you meant `identity' (imported from Cont...
01:59:27 <shachaf> > view (identity?) (Identity 5)
01:59:30 <lambdabot>   5
01:59:45 <edwardk> :t (?)
01:59:46 <shachaf> Good use because it can never come in front of something else.
01:59:47 <lambdabot> Isomorphic k => Isomorphism a b -> k b a
02:00:04 <shachaf> (So it doesn't conflict with ImplicitParams.)
02:00:06 <edwardk> :t ((?) identity)
02:00:08 <lambdabot> (Functor f, Isomorphic k) => k (a -> f b) (Identity a -> f (Identity b))
02:00:16 <Nereid> so how does this github thing work? I fork, make my changes, and make a pull request?
02:00:34 <shachaf> That's one way to do it.
02:00:37 <edwardk> maybe if (?) was from with the explicit requirement that it be used as a function
02:00:44 <Nereid> because this is a really tiny thing
02:00:46 <edwardk> foo ? bar
02:00:48 <Nereid> fixing some documentation typos
02:01:05 <edwardk> Nereid: for doc fixes you can often edit right there somehow
02:01:06 * typoclass one of these days is gonna use ´ as a unary operator for something
02:01:14 <Nereid> what do you mean?
02:01:34 <edwardk> https://github.com/ekmett/lens/blob/master/examples/Aeson.hs should have an Edit link in the upper right
02:01:35 <Nereid> I mean I fixed some docs in lens.
02:01:37 <Nereid> ah.
02:02:49 <shachaf> edwardk: We didn't want the Int to be strict, right?
02:02:58 <edwardk> correct. it caused issues when it was
02:03:00 <shachaf> Or did we ever test what happens if the Int is strict but the pattern match is lazy?
02:03:19 <edwardk> you might test, but i'd be shocked if it worked
02:03:43 * typoclass . o O ( i mean, you could have f and f' and then also f´ where (´) is some function that transforms f )
02:04:23 <edwardk> :t let (´) = diff in sin´ 0
02:04:24 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
02:04:36 <typoclass> > let ä = 4 in 2
02:04:37 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
02:04:52 <typoclass> ... lambdabot's unicode skillz are borked since the upgrade
02:05:27 <typoclass> > let x = "ä" in 3 -- i mean, even stuff that should clearly work
02:05:28 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
02:05:52 <Nereid> edwardk: ah but it creates a pull request either way
02:06:06 <edwardk> Nereid: yeah, but it avoids you having to fork
02:06:06 <FireFly> "ä" isn't a compelling argument. Take a course in rhethoric
02:06:17 <Nereid> yeah well I already did
02:06:19 <Nereid> :v
02:06:21 <edwardk> ah =)
02:06:23 <Ralith> :∧
02:06:35 <FireFly> ∧_∧
02:06:59 <edwardk> i'm pretty happy to take pull requests, they are easy to merge and get auto-tested by the bot
02:07:08 <typoclass> FireFly: the argument is, these things worked before lambdabot's upgrade, and they have always worked in ghc and ghci
02:07:27 <shachaf> Ugh, just swapped out 1GB.
02:07:30 <edwardk> this is especially good for pull requests for new unit tests
02:07:30 <shachaf> I'll take that as the test not passing.
02:07:35 <FireFly> Yes, yes, I know. It was a lame attempt at a pun on "invalid argument"
02:07:37 <FireFly> :P
02:07:40 <edwardk> shachaf: hahaha
02:07:59 <shachaf> Fortunately I caught it before it started thrashing completely.
02:08:31 <Ghoul> Was much progress ever made with that haskell JIT?
02:08:34 <shachaf> OK, so I won't feel bad about replacing IndexingResult with a tuple.
02:08:41 <shachaf> Ghoul: nominolo is actively working on it as far as I know.
02:08:43 <shachaf> @where lambdachine
02:08:43 <lambdabot> I know nothing about lambdachine.
02:08:49 <shachaf> @google lambdachine workshop
02:08:52 <lambdabot> http://www.cs.rice.edu/~dmp4866/PDF/2011.Phd-Proposal-Slides.pdf
02:08:52 <lambdabot> Title: Low-Level Haskell Code: Measurements and Optimization Techniques
02:08:55 <Ghoul> lambdabot dont know about a lambdamachine
02:08:55 <typoclass> FireFly: ooh :-) didn't catch that. at "recoverEncode" i stopped reading lambdabot's message and went "bah, that thing again"
02:08:57 * Ghoul lost
02:08:59 <shachaf> @google lambdachine implementors workshop
02:09:01 <lambdabot> http://www.cs.rice.edu/~dmp4866/PDF/2011.Phd-Proposal-Slides.pdf
02:09:02 <lambdabot> Title: Low-Level Haskell Code: Measurements and Optimization Techniques
02:09:06 <shachaf> Hmph.
02:09:08 <shachaf> @google lambdachine implementors workshop 2012
02:09:11 <lambdabot> http://tweettunnel.com/reverse2.php?textfield=johtib
02:09:11 <lambdabot> Title: Old Tweets: johtib (Johan Tibell)
02:09:13 <exDM69> does anyone understand why you can't use LLVM from GHCi. There's a runtime linking problem related to C++, do you know the details?
02:09:13 <shachaf> Well, whatever.
02:09:17 <shachaf> You can find it somewhere.
02:09:19 <Ghoul> lol, I'll just look for it on ghub
02:09:54 <Ralith> exDM69: yes, it's fairly straightforward if you think about it
02:10:23 <Ralith> exDM69: ghc links LLVM, so it has those symbols defined locally, so it can't load them from somewhere else without a conflict.
02:10:40 <edwardk> exDM69: for one, ghci doesn't do all the c++ initialization stuff, its got a pretty ad hoc linker.
02:11:00 <edwardk> oh and i guess there is that
02:11:13 <Ghoul> lowut, it isnt on github anymore or something
02:11:15 * Ralith isn't sure LLVM actually has any C++ init stuff
02:11:17 <Ralith> they're very hygenic.
02:11:23 <Ghoul> nominolo: Hey
02:12:11 <exDM69> edwardk: Ralith: yeah, I think LLVM runtime linking fails even before c++ initialization becomes a potential issue
02:12:25 <typoclass> Ralith: i bet they are. i always thought that linking to c++ is difficult or impossible if you're not hygienic
02:13:13 <Ralith> typoclass: well, one doesn't actually need to link to C++ to use LLVM, as it has C bindings
02:13:22 <Ralith> it's just that those get compiled into the same object, so you get the symbol clashes.
02:13:35 <Ralith> I suppose that must mean it doesn't do any important init stuff, though.
02:13:55 <Nereid> hmm
02:13:58 <Ralith> given that the same linker of course applies to the whole file
02:14:07 <Nereid> github is scary.
02:14:11 <Nereid> permanent things are scary.
02:14:15 <Ralith> exDM69: anyway, it's just something ghci can't do. Maybe you could build a ghc without LLVM support?
02:14:23 <Ralith> Nereid: permanent things?
02:14:34 <Ralith> exDM69: what do you want it for?
02:14:48 <Nereid> Ralith: git push and a pull request.
02:14:51 <shachaf> I'll just push the partsOf taking code anyway
02:15:10 <Ralith> Nereid: what's wrong with those being ETCHED INTO THE MEMORY OF THE INTERNET FOR ALL TIME?
02:15:26 <Nereid> that's exactly what sounds scary.
02:19:31 * shachaf considers telling Nereid about tunes.org
02:20:12 <exDM69> Ralith: I built a small compiler that emits llvm
02:20:18 <exDM69> using llvm-base
02:20:39 <exDM69> it would be real nice to be able to test parts of it from ghci
02:21:03 <Nereid> what's that?
02:21:22 <Nereid> or rather, what about it?
02:21:57 <Ralith> exDM69: the bad news is you can't.
02:22:21 <Ralith> exDM69: the good news is you can have a much easier time with that project by using llvm-base and llvm-wrapper from https://github.com/Ralith/llvm !
02:22:33 <shachaf> Nereid: See topic.
02:22:48 <Ralith> bonus points if you nag bos to review the pull request already
02:23:39 <Nereid> shachaf: I don't follow.
02:23:53 <Ralith> Nereid: why does it sound scary?
02:24:00 <Ralith> what harm do you imagine coming from it?
02:24:03 <shachaf> Nereid: The point is that everything you type in this channel is logged forever.
02:24:12 <Nereid> I know.
02:24:15 <Nereid> ah.
02:24:22 <Nereid> Ralith: yeah, well I'm irrational.
02:25:05 * typoclass tries to think of something clever to type, and fails
02:25:07 <Ralith> Nereid: in a world where everyone's teenage embarassments are recorded for posterity, a pull request is hardly going to damn you.
02:25:33 <Nereid> :p
02:25:38 <shachaf> Hmm, now I know how to merge a pull request.
02:25:52 <typoclass> Ralith: ... can bet your posterior on that
02:26:28 <merijn> Ralith: What if it's a pull request of an embarassing photo? :p
02:26:57 <Nereid> shachaf: cool =)
02:27:04 <Ralith> merijn: then everyone who sees it will appreciate your familiarity with state-of-the-art version control and collaboration techniques!
02:27:13 <Ralith> you win some, you lose some.
02:27:48 <Nereid> haha
02:28:53 <shachaf> Nereid: If you want to be helpful, you can fix taking.
02:28:58 <shachaf> @ty fix (taking 1)
02:29:00 <lambdabot>     Occurs check: cannot construct the infinite type:
02:29:00 <lambdabot>       f0 = Control.Lens.Internal.Indexing f0
02:29:00 <lambdabot>     Expected type: SimpleLensLike
02:29:11 <shachaf> I guess you can't fix taking.
02:29:13 <Nereid> haha
02:29:42 <shachaf> Nereid: The issue is that when you're using taking as a Fold, you want to stop as soon as you've seen N elements.
02:29:58 <shachaf> But when you're using it as a Traversal, you want to resume the old traversal once you've seen n elements.
02:30:01 <shachaf> I.e.
02:30:35 <shachaf> > over (taking 5 traverse) succ "hello world"
02:30:37 <lambdabot>   "ifmmp world"
02:30:48 <shachaf> > [1..] ^.. baking 3 traverse
02:30:51 <lambdabot>   [1,2,3]
02:31:02 <Nereid> baking?
02:31:06 <shachaf> baking
02:31:12 <FireFly> > baking
02:31:14 <Nereid> > [1..] ^.. taking 3 traverse
02:31:14 <lambdabot>   Ambiguous type variable `f0' in the constraint:
02:31:14 <lambdabot>    (Control.Applicative.App...
02:31:16 <lambdabot>   *Exception: stack overflow
02:31:18 <Nereid> heh
02:31:20 <shachaf> baking is a version of taking that only works for Traversals.
02:31:23 <FireFly> eek.
02:31:28 <shachaf> But it's lazy enough.
02:31:37 <shachaf> The old taking doesn't work for infinite lists.
02:31:43 * hackagebot hackage-db 1.4 - provide access to the Hackage database via Data.Map  http://hackage.haskell.org/package/hackage-db-1.4 (PeterSimons)
02:31:47 <shachaf> We want something that works for both folds and traversals.
02:31:52 <Nereid> indeed
02:33:25 <epsil> so I just finished Learn You a Haskell, and now I'm sad that there isn't more.
02:33:33 <epsil> can someone cheer me up with some reading suggestions?
02:33:43 <Nereid> epsil: looked at the typeclassopedia?
02:34:50 <epsil> Nereid: nope :)
02:34:59 <merijn> epsil: Depends, what type of reading do you want to do? Theory, practical stuff? Little of both?
02:35:07 <merijn> Haskell specific, generic :p
02:35:57 <epsil> merijn: practical stuff, mainly. I'm in the process of setting up xmonad so I'll have something to play with
02:36:06 <Nereid> :)
02:36:43 * hackagebot cabal2nix 1.41 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.41 (PeterSimons)
02:37:18 <merijn> epsil: Real World Haskell has some stuff on transformers, the FFI and profiling
02:37:29 <merijn> epsil: If you've finished LYAH just skip to the later interesting chapters
02:37:41 <squidz> can somebody tell me why ghc is complaining that it expects type ClientID but got Bytestring, when ClientID is a type synonym for ClientID? http://hpaste.org/77955
02:37:59 <shachaf> How can ClientID be a synonym for ClientID?
02:38:04 <merijn> The monad transformer and arrow papaers are also interesting
02:38:15 <squidz> shachaf: sorry i meant type synonym for bytestring of course
02:38:25 <shachaf> squidz: I don't see any error in your paste.
02:38:32 <shachaf> I don't even see code that could cause an error.
02:38:33 <squidz> ill paste my error
02:38:41 <shachaf> squidz: Paste your code too.
02:38:45 <Nereid> you want Lazy.Char8 probably
02:38:49 <Nereid> or no Lazy at all
02:38:50 <shachaf> squidz: Also you shouldn't use ByteString.Char8, it's evil and wrong.
02:38:55 <Nereid> that too
02:39:10 <merijn> epsil: For example, "Generalising Monads to Arrows" by Hughes is also interesting (it becomes a bit harder to follow by the end, but the start is very readable and useful on its own)
02:39:19 <shachaf> Ugh, Arrow talk.
02:39:26 <latermuse> :)
02:39:30 <Nereid> ugh, "ugh".
02:39:32 * merijn thwaps shachaf
02:39:52 <squidz> http://hpaste.org/77955
02:39:53 <latermuse> (id &&& show) ugh
02:39:54 <shachaf> merijn: I'm tired of the "oh, you've learned some basic Haskell and you sort of understand what Monad is? the next logical step: Arrow!"
02:40:12 <shachaf> Arrow is a pretty obscure concept whose use must be justified.
02:40:16 <Nereid> ap show ugh
02:40:23 <shachaf> (Unlike Category. Category is good.)
02:40:28 <squidz> shachaf: here is the arrow with the code http://hpaste.org/77955
02:40:46 <shachaf> squidz: Did you read what Nereid and I said above?
02:40:50 <merijn> shachaf: I actually thought the basics of Arrow were pretty easy and useful
02:41:03 <merijn> I'm not saying the next step is writing AFRP code >.>
02:41:11 <quicksilver> AFRP doesn't use arrows.
02:41:13 <latermuse> Im a new haskell user, and Ive only recently grasped arrows. They are seeing a lot of use in my code now, it is very comfortable to use them
02:41:17 <squidz> shachaf: yes, but using lazy doesnt change the error
02:41:19 <Nereid> the Arrow instance for (->) is pretty useful.
02:41:20 <shachaf> Most uses I see of Arrow are of (->)
02:41:25 <merijn> Just understanding &&&, ***, first and second is useful
02:41:38 <quicksilver> they're useful combinators but they don't justify the Arrow typeclass.
02:41:46 <shachaf> merijn: Those become significantly easier to understand when you get rid of the Arrow nonsense.
02:41:54 <merijn> quicksilver: Doesn't the A stand for Arrowized? Or is AFRP different from Arrowized FRP?
02:42:01 <latermuse> arrows are just functions
02:42:09 <merijn> latermuse: No! Bad!
02:42:19 <latermuse> >:)
02:42:22 <squidz> shachaf: any idea=
02:42:31 <shachaf> squidz: Did you read the part where you shouldn't use Char8?
02:42:37 <shachaf> Not that that's relevant.
02:42:55 <merijn> And if does stand for Arrowized, then I'm confused why AFRP wouldn't use arrows...
02:43:02 <quicksilver> merijn: it stands for it, but they fib.
02:43:03 <shachaf> squidz: But I don't believe you that you tried Lazy.
02:43:09 <shachaf> I'll believe you if you show me code. :-)
02:43:26 <Nereid> my next guess is Riak expects a strict bytestring
02:43:32 <squidz> shachaf: haha okay, how do I convert a [char] to lazy bytestring
02:43:47 <epsil> merijn, Nereid: thanks for the tips, I'll look into it :)
02:43:52 <quicksilver> merijn: or, so I believe. Maybe I'm wrong but I think most FRP-style 'Arrows' are not really Arrows, they don't implement pure.
02:44:02 <shachaf> squidz: There are lots of ways.
02:44:05 <Nereid> squidz: the issue is that Char contains a unicode character, where as a ByteString contains, well, bytes
02:44:11 <shachaf> squidz: Bytes aren't the same thing as characters, so you'll have to encode it.
02:44:22 <squidz> ah i see
02:44:43 <squidz> so i need to convert form utf8 to bytestring
02:44:51 <shachaf> No.
02:44:56 <squidz> ?
02:44:59 <shachaf> If anything, you need to convert *to* UTF-8 ByteString.
02:45:05 <shachaf> If the encoding you want is indeed UTF_8
02:45:09 <typoclass> epsil: it's just 20 lines or so, but i found them very enlightening: http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/src/Control-Monad-Instances.html
02:45:20 <shachaf> Unicode isn't the same thing as UTF-8. :-)
02:45:22 <Nereid> and for that, you'd use encodeUtf8
02:45:38 <Nereid> ah, riak uses lazy bytestrings.
02:45:59 <shachaf> Nereid: I wish there was a standard library function for encoding to UTF-8 ByteString.
02:46:05 <shachaf> encode :: String -> ByteString
02:46:11 <merijn> quicksilver: I thought that once in Netwire were, but I might be wrong...
02:46:12 <Nereid> from [Char]? yeah heh
02:46:16 <shachaf> Making you go through Text is silly.
02:46:32 <t7> how do i get seconds since epoch?
02:46:36 <Sonderblade> squidz: think of utf8 as a compression algorithm from string -> bytestring and decompressing bytestrings to strings
02:46:50 <quicksilver> shachaf: http://hackage.haskell.org/package/utf8-string-0.3.7 is the right way is it not?
02:46:52 <Nereid> t7: getCurrentTime
02:47:03 <shachaf> quicksilver: Well, it's not especially standard.
02:47:03 <Nereid> oh and then
02:47:07 <typoclass> Sonderblade: hah, not bad :-)
02:47:08 <shachaf> Not in the platform or anything.
02:47:10 <Nereid> oh epoch
02:47:13 <Nereid> sceonds
02:47:28 <quicksilver> shachaf: hmm yes I wonder if there is a good reason it isn't.
02:47:34 <shachaf> quicksilver: I feel very mildly bad telling people about how they're bad people for using ByteString.Char8 when there's no easy alternative.
02:47:42 <squidz> okay, im giving it a shot with encode
02:47:48 <typoclass> t7: try Data.Time.Clock.POSIX
02:48:00 <shachaf> squidz: The thing causing your type error was almost certain Lazy/Strict confusion.
02:48:05 <quicksilver> shachaf: I don't think installing utf8-string is a terrible terrible hardship but I do know what you mean.
02:48:07 <notdan> Ah, strings again :(
02:48:19 <twoolie> Can anyone help me with a problem? http://pastebin.com/HvaFM2R2
02:48:24 <mauke> The paste HvaFM2R2 has been copied to http://hpaste.org/77957
02:48:27 <shachaf> quicksilver: It's not terrible but it's not as convenient as saying "import this thing"
02:48:38 <Elision> jesus I was not expecting this large a channel :<
02:48:42 <shachaf> And you you have to add an extra dependency to your package, too.
02:48:50 <latermuse> elision: :D
02:49:21 <quicksilver> shachaf: it's all right! We were on the case 3.5 years ago ( http://www.haskell.org/pipermail/libraries/2009-May/011722.html ) so surely it will be solved any day now.
02:49:42 <quicksilver> shachaf: "We can't standardise utf8-string, we'll just fix the standard IO libraries, that will be much quicker"
02:50:14 <shachaf> quicksilver: The standard librares *have* UTF-8 encoding and decoding, of course.
02:50:55 <shachaf> It's just hidden away and uses some disgusting imperative API.
02:50:57 <notdan> twoolie: you can do 'data (Show a) => Array a' if you enable XDataTypeContexts
02:51:05 <shachaf> twoolie: Don't do it!
02:51:09 <shachaf> notdan: Don't give people bad advice.
02:51:11 <t7> is POSIX time from UTC will be universal right?
02:51:11 <Nereid> don't do it!
02:51:26 <quicksilver> shachaf: oh, I think you're supposed to go via Text really.
02:51:26 <shachaf> -XDataTypeContexts was deprecated for a reason.
02:51:27 <Nereid> t7: it says in the docs, a POSIXTime represents the time difference from epoch
02:51:32 <shachaf> quicksilver: :-(
02:51:39 <quicksilver> shachaf: is that so bad?
02:51:43 <squidz> trying to use fromString from http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html gave the same error
02:51:48 <notdan> shachaf: wait, it's deprecated?
02:51:53 <notdan> shachaf: sorry, I didn't know that
02:52:03 <quicksilver> notdan: yes, it's deprecated because it never worked in a useful way.
02:52:07 <shachaf> quicksilver: Well, doing UTF-16 encoding in order to do UTF-8 encoding is kind of silly.
02:52:15 <Nereid> squidz: well yeah, you need the lazy version
02:52:16 <shachaf> It might be that it'll get fused away in text, but still.
02:52:38 <squidz> Nereid: oh thats still not lazy sorry
02:52:43 <notdan> Well, I would have adviced to use GADTs, but Array a is a type without constructors :|
02:52:58 <Nereid> without constructors or with only hidden constructors?
02:53:57 <notdan> Well, I am talking about this code: http://pastebin.com/HvaFM2R2
02:53:58 <mauke> The paste HvaFM2R2 has been copied to http://hpaste.org/77957
02:54:15 <notdan> twoolie: well, you can put constraints on functions instead
02:54:19 <Nereid> twoolie: anyway, that's when you put Foreign constraints on all the functions
02:54:29 <typoclass> shachaf: when reading the code and trying to understand it, that complication will not get fused away. which really supports your earlier point
02:54:36 <shachaf> twoolie: You'll need to put a constraint on every function that uses it.
02:54:44 <Nereid> putting a constraint on the data type won't do any good since you'd have to put the constraint everywhere else anyway
02:55:09 <shachaf> typoclass: Well, sure, but you can define utf8EncodeString = B.encode . T.pack
02:55:13 <Nereid> and well it's a bad idea
02:55:19 <shachaf> But anyway there ought to be *something8
02:55:23 <quicksilver> shachaf: if you think of it that way, sure. But I don't think of Text as UTF16.
02:55:33 <quicksilver> shachaf: I think of Text as "a good way to store text"
02:55:35 <Nereid> and with OverloadedStrings, you don't even need T.pack for string literals
02:55:51 <quicksilver> shachaf: and having all the encoding functions in one place (in Data.Text.*) makes some sense.
02:56:08 <quicksilver> the implementation of Text isn't the point unless it becomes a speed bottleneck.
02:56:38 <Nereid> and Text is fast, right?
02:57:22 <c_wraith> Usually
02:57:24 <twoolie> notdan: shachaf: I ended up putting constraints on all the functions, but i'd much rather put the constraint on the type, so that the type system won't allow creating an array of anything else
02:57:34 <c_wraith> There are some corner cases where Text isn't very fast.
02:57:42 <shachaf> twoolie: Who cares?
02:57:48 <Nereid> twoolie: well, they have to go on the functions.
02:57:50 <shachaf> The constraints will come along when you try to use it for anything.
02:57:54 <squidz> okay changing the string to bytestring lazy did the trick thanks guys
02:58:11 <quicksilver> twoolie: you're free to have a custom 'smart constructor' which imposes the constraint if you want to.
02:58:44 <luite> hm, the TextEncoding in base can only be used with Handles, right?
02:59:14 <Nereid> oh my, time to go to bed.
02:59:20 <shachaf> luite: It works on Buffers.
03:02:21 <twoolie> quicksilver: "smart constructors" are a little silly imho. It's just a function, no sugar or binding to the type.
03:02:25 <t7> @hoogle [(a -> b)] -> a -> [b]
03:02:26 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
03:02:27 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
03:02:27 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:02:31 <luite> shachaf: hm, the only things that i can find that use it are hSetEncoding and hGetEncoding
03:03:21 <raymank26> :r
03:03:30 <raymank26> okey(
03:03:42 <shachaf> luite: Are you looking in GHC.IO.Encoding?
03:04:13 <shachaf> t7: sequence
03:04:17 <shachaf> @ty sequence :: [a -> b] -> a -> [b]
03:04:19 <lambdabot> [a -> b] -> a -> [b]
03:04:30 <shachaf> @ty \fs x -> map ($ x) fs
03:04:32 <lambdabot> [a -> b] -> a -> [b]
03:05:27 <t7> oh poo i have a [a -> (b + c + d)]
03:05:49 <quicksilver> twoolie: I'm not sure what your point is. Exporting functions with restricted types is a common way to implement an abstraction barrier.
03:05:54 <t7> this is turning into code golf anyway
03:05:56 <luite> shachaf: oh right i was just looking at the "public" System.IO API
03:06:00 <quicksilver> if my use of the word 'constructor' irked you, I apologise
03:06:06 <nicoo> t7: Code golf ?
03:06:10 <quicksilver> 'smart constructor' is what people often call these, abuse of notation aside.
03:06:15 <shachaf> luite: Yep, not too much in there.
03:06:23 <shachaf> luite: That's because the real API is a digusting abomination. :-)
03:06:24 <t7> nicoo: minimization for the sake of minimization
03:06:32 <nicoo> Ah, ok
03:10:02 <shachaf> luite: Well, OK, it's not that bad.
03:10:06 <shachaf> But it's kind of unfriendly.
03:12:51 <luite> shachaf: the IO lib uses an annoying amount of mutability under the hood :)
03:13:35 <luite> i spent the last two days implementing all those things for ghcjs just to get putStrLn working (so it can run the GHC testsuite)
03:14:26 <quicksilver> luite: the GHC programmers are very bad people :-(
03:14:45 <luite> yes!
03:14:47 <shachaf> You hear that, JaffaCake?!
03:14:49 <luite> well dunno
03:15:21 <quicksilver> even the "pure" bits of GHC use mutation under the hood in some phases of the compiler
03:15:42 <luite> i'm still doing something wrong in the exception handling code, so it doesn't work yet :/
03:15:54 <quicksilver> which is quite funny given the talks SPJ has given in which he uses phases of compilation as great motivating examples for using Monads to maintain purity.
03:16:10 <c_wraith> well.  Evaluation uses mutation behind the scenes - replacing pointers to expressions with pointers to values resulting from evaluating that expression.
03:16:26 <nicoo> quicksilver: Ahah. Is there a video of the talk ? (or at least slides)
03:16:26 <quicksilver> c_wraith: yes. But there is a difference, isn't there.
03:16:41 <latermuse> is there an easy way to get the modification time of a file in unix/epoch time?
03:16:51 <shachaf> latermuse: stat?
03:16:56 <quicksilver> nicoo: I wasn't thinking of one particular talk. Although 'Wearing the hair shirt' was one of them and that is certainy available online
03:16:58 <latermuse> stat?
03:17:07 <shachaf> Whatever it's called.
03:17:09 <c_wraith> Amusingly, this is part of why GC is hard for haskell code - it actually does a lot more mutation than most functional languages at the operational level.
03:17:14 <shachaf> How portable do you need it to be?
03:17:14 <shachaf> @hoogle stat
03:17:15 <lambdabot> Control.Monad.State module Control.Monad.State
03:17:15 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
03:17:16 <lambdabot> Graphics.UI.GLUT.State module Graphics.UI.GLUT.State
03:17:19 <shachaf> Not that.
03:17:35 <luite> utcTimeToPOSIXSeconds
03:17:41 <luite> Data.Time.Clock.POSIX
03:17:48 <t7> :t (++) . id
03:17:50 <lambdabot> Monoid a => a -> a -> a
03:17:53 <quicksilver> latermuse: http://www.haskell.org/ghc/docs/6.12.2/html/libraries/unix-2.4.0.1/System-Posix-Files.html#v%3AmodificationTime
03:17:57 <quicksilver> presumably
03:18:14 <luite> yeah but you don't need the unix package if you use the above function to convert
03:18:16 <t7> :t ((++) . id) "Hello " "World!"
03:18:18 <lambdabot> [Char]
03:18:21 <luite> then you just use getModificationTime
03:19:29 <luite> c_wraith: on the other hand, all thunks are updated only once, so it's relatively easy to collect the closures that may point from the old generation to the new one
03:19:40 <luite> easier than for mutable things like iorefs and mvars
03:20:02 <luite> and other closure types never point forward in time
03:20:41 <latermuse>     No instance for (Show (IO System.Time.ClockTime))
03:22:13 <nicoo> quicksilver: Ewww, Comic Sans in slides :(
03:29:58 <osfameron> SPJ?
03:30:05 <typoclass> > let iterate' f x = out : iterate' f xn where (out, xn) = f x in takeWhile (not . null) $ iterate' (splitAt 3) [1..20]
03:30:07 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20]]
03:30:33 <typoclass> can this ^^ be done in a clever short way, possibly lensily?
03:31:24 <typoclass> i imagine a function interate' like that would be useful for break, span, splitAt, possibly others
03:31:27 <quicksilver> nicoo: yeah, that always makes me laugh too :)
03:32:15 <typoclass> s/interate'/iterate'
03:32:51 <nicoo> quicksilver: I'm just grateful there wasn't 80s-styles pictures & flashy colors; Unfortunately, such eye-cancer exists in conferences :(
03:34:44 <fmap> :t \n -> map (take n) . iterate (drop n)
03:34:46 <lambdabot> Int -> [a] -> [[a]]
03:35:26 <raymank26> Could someone explain me how ListT works? How to transform list to ListT? How to make a function that choose item from list and print it to screen?
03:35:30 <zhulikas> > take 5 [1,2]
03:35:32 <lambdabot>   [1,2]
03:35:53 <zhulikas> :t iterate
03:35:55 <lambdabot> (a -> a) -> a -> [a]
03:36:20 <bishboria> typoclass: Just had a look on Hackage. Data.List.Split (splitEvery) might be what you're after
03:36:20 <cmears> typoclass: Your "iterate'" is basically Data.List.unfoldr
03:36:32 <typoclass> > iterate (*2) 7 -- zhulikas, here's what iterate does
03:36:34 <lambdabot>   [7,14,28,56,112,224,448,896,1792,3584,7168,14336,28672,57344,114688,229376,...
03:36:41 <typoclass> cmears: yup, except for the Maybe
03:36:43 <typoclass> :t unfoldr
03:36:44 * hackagebot statistics-linreg 0.2.2 - Linear regression between two samples, based on the 'statistics' package.  http://hackage.haskell.org/package/statistics-linreg-0.2.2 (AlpMestanogullari)
03:36:45 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
03:36:47 * hackagebot database-migrate 0.1.0 - Database versioning and migration (experimental)  http://hackage.haskell.org/package/database-migrate-0.1.0 (MarkHibberd)
03:37:38 <cmears> iterate' f = unfoldr (Just . f)
03:37:54 <typoclass> cmears: hmm ...
03:38:46 <cmears> iterate' = unfoldr . (Just .)    -- if you prefer pointfree
03:39:40 <typoclass> cmears: hm thanks, interesting. hadn't looked at it that way :-)
03:39:51 <cmears> you're welcome (:
03:43:47 <typoclass> bishboria: in this case yes, thanks
03:54:45 <latermuse> is it normal to be doing a bulk of your programming in the IO monad?
03:55:13 <zomg> latermuse: I would imagine that depends on the type of your application
03:55:47 <latermuse> zomg: I am enjoying the IO monad and its intricacies. but it feels like cheating
03:56:33 * shachaf wonders why people call it "the IO monad"
03:56:45 * hackagebot database-migrate 0.1.1 - Database versioning and migration (experimental)  http://hackage.haskell.org/package/database-migrate-0.1.1 (MarkHibberd)
03:56:58 <merijn> latermuse: The answer is it depends
03:57:09 <Botje> the IO warm fuzzy thing?
03:57:11 <typoclass> latermuse: the general advice is to have only a few functions "-> IO ..." and most functions not
03:57:40 <merijn> latermuse: I have some code that's almost completely in IO. Which effectively makes it imperative code written in haskell. But it works and I'm happy with it, so :p
03:58:05 <latermuse> merijn: yeah, my newest project has almost every function in IO. was just wondering if this is bad practice or not
03:58:08 <merijn> typoclass: That only really applies for programs where IO is not the bulk of the code
03:58:20 <merijn> latermuse: It really depends on the problem, some code is just very IO heavy
03:58:32 <latermuse> my project is a blog content management system
03:58:41 <latermuse> lots of reading, writing, and manipulating files
03:58:52 <merijn> If you're only stringing FFI functions and IO together then naturally you'll end up doing lots of IO
03:59:03 <Saizan> latermuse: that sounds like it could be factored better
03:59:15 <zhulikas> I don't understand such approach
03:59:21 <latermuse> saizan: how so?
03:59:27 <typoclass> latermuse: if you put it on hpaste, i bet folks can come up with suggestions how to organize it better
03:59:29 <zhulikas> I always found pure functions being much more comfortable
03:59:37 <merijn> latermuse: For those things the recommended approach is to have pure manipulation functions and only have the input/output functions as IO
03:59:45 <latermuse> I was planning to put it online in a day or two after I bang out the last few pieces of basic functionality
03:59:53 <Saizan> latermuse: the manipulating files part shouldn't need IO so much, i imagine
03:59:59 <merijn> zhulikas: Like I said, it really depends on the code
04:00:08 <Saizan> latermuse: if by that you mean manipulating their content
04:00:14 <zhulikas> merijn, give me an example where putting most of stuff in IO makes sense
04:00:20 <Saizan> right, what merijn says
04:00:50 <typoclass> latermuse: it's fine if you hpaste just a snippet, just a few functions :-)
04:00:57 <latermuse> the code is generating html pages via a mini markup language
04:01:17 <merijn> zhulikas: I have code that functions as coordination layer for existing C libraries, that means all the code does is: 1) Read in input 2) call FFI functions 3) Read/write data from/to Chan 4) write output
04:01:25 <latermuse> typoclass: i was going to put the whole project on github probably tomorrow. then you guys can poke around easily
04:01:42 <merijn> zhulikas: i.e. 75% or more is dealing with IO
04:01:45 * hackagebot dawg 0.5.0 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.5.0 (JakubWaszczuk)
04:01:47 <zhulikas> I see
04:02:09 <merijn> Then why use Haskell? Because the type system, threading, etc. are all so much nicer in Haskell, so why not?
04:02:42 <typoclass> merijn: i could be wrong, but think it's unlikely that a beginner is knee-deep in ffi stuff
04:02:54 <zhulikas> :D
04:02:57 <zhulikas> or threading!
04:03:00 <merijn> typoclass: Oh, sure. But the question was "why would you want to be mostly in IO"
04:03:11 <zhulikas> but of course, that answers my question
04:03:18 <merijn> typoclass: Not whether latermuse was right in doing that :)
04:04:20 <latermuse> do you guys know of any current blogging software written in haskell?
04:04:36 <typoclass> merijn: yeah. i still think "would you want everything in IO?" has the answer "there's a few niches, but the general rule of thumb is 'no'"
04:04:56 <shachaf> @quote Jafet research
04:04:57 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
04:04:57 <lambdabot> s, phone apps, and web services.
04:05:02 <shachaf> lambdabot: Sorry.
04:05:07 <latermuse> my program reads all the text files in a directory, and automatically formats them and puts them into a blog format with archives and nice seo-style links
04:05:11 <zhulikas> latermuse, I did a very primitive blog cms with Yesod in April!
04:05:27 <sopvop> what is seo-style links?
04:06:15 <latermuse> sopvop: instead of www.blog.com/post/123123.html, it will have something relevant for the url like: www.blog.com/post/Relevant-Url-Name.html
04:06:34 <zhulikas> and then you have collision o/
04:07:05 <latermuse> so with my blog software, you just write your posts in a text file, then run the program and it automatically rebuilds your site with your newest post
04:07:27 <latermuse> easy updating from command line, and no need to deal with a GUI or the web browser
04:07:39 <zhulikas> sounds like hakyll
04:08:57 <latermuse> (reading the hakyll page now) Yeah its like hakyll
04:09:10 <sopvop> there is also clckwrks :)
04:11:00 <latermuse> im going to be using this platform to build a VOIP thingy next
04:23:44 <killy9999> there is no haddock documentation for GHC.Base on hackage
04:23:59 <killy9999> is that on purpose, or is it an error?
04:24:08 <sopvop> http://hackage.haskell.org/package/base-4.5.0.0 this base?
04:24:33 <killy9999> yes
04:24:38 <Saizan> http://hackage.haskell.org/packages/archive/base/4.5.0.0/doc/html/GHC-Base.html <- this (missing) one
04:25:01 <killy9999> exactly
04:25:36 <killy9999> it seems that Haskell Platform does not install sources (or I can't find them on my system)
04:25:45 <killy9999> so I can't even view the source :/
04:25:48 <sopvop> http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-Base.html
04:26:09 <sopvop> {-# OPTIONS_HADDOCK hide #-} in your face! :)
04:26:55 <typoclass> killy9999: yes, hackage.haskell.org doesn't have complete documentation or source on base. however you can find it at haskell.org/ghc as sopvop showed
04:26:56 <killy9999> hm.. I wonder why they did that
04:28:57 <sopvop> because it's not intended for external use. marked as 'Stability   :  internal'
04:29:23 <neutrino_> @pl letDimensionRange x y z u v w = (x - u, y - v, z - w)
04:29:24 <lambdabot> letDimensionRange = flip flip (-) . (((.) . flip . ((flip . ((.) .)) .)) .) . (. (-)) . flip . (((.) . (,,)) .) . (-)
04:29:33 <neutrino_> the obfuscated haskell contest
04:30:04 <killy9999> sopvop: makes sense, though I see libraries using it and I want to do something similar in my code :)
04:30:10 <sopvop> eat this perl!
04:32:41 <Ralith> where can I find documentation or examples on using cabal install from/with the windows haskell platform?
04:34:11 <zhulikas> hate those flip flops! >:|
04:35:01 <alpounet> Ralith, do you have a specific question? cabal install just works the same way on windows and other OSes
04:35:34 <t7> sopvop: nope i just saw RSA in 3 lines of perl
04:35:51 <Ralith> alpounet: I've never touched the windows haskell platform and have a clueless newbie friend I am trying to get to install a package and have no idea what to tell them to do.
04:35:53 <t7> looks like cat /dev/rand
04:36:16 <t7> Ralith: they might have to add cabal to %PATH
04:36:20 <t7> %PATH%
04:36:34 <Ralith> that might be helpful if either of us knew where cabal installed to
04:36:40 <alpounet> i think the installer does it for you, doesn't it?
04:37:09 <Ralith> I certainly don't know
04:37:50 <alpounet> Ralith, well, tell him to launch cmd
04:37:56 <alpounet> and type in for example 'cabal update'
04:38:20 <alpounet> if it doesn't find cabal, yes he should add the right directory to his PATH
04:38:58 * Ralith nod
04:39:03 <Ralith> looks like it's in path and in working order, thanks
04:39:56 <iratsu> @pl \f g (a, b) (c, d) -> (f a c, g b d)
04:39:57 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
04:40:44 <iratsu> @pl \(f, g) (a, b) (c, d) -> (f a c, g b d)
04:40:46 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .
04:40:47 <lambdabot> )) .))
04:41:11 <hayashi> when building a library through cabal, is there any way of forcing it to use a specific version of one of its dependencies or at least finding out why it's selecting a specific dependency version?  attoparsec seems insistent on using containers-0.4.2.1 for no outwardly apparent reason
04:41:24 <hayashi> and i need it to be using 0.5.0.0 due to dependency hell elsewhere
04:41:46 * hackagebot database-migrate 0.1.2 - Database versioning and migration (experimental)  http://hackage.haskell.org/package/database-migrate-0.1.2 (MarkHibberd)
04:42:38 <killy9999> hayashi: I *think* it depends how attoparsec was compiled
04:42:46 <alpounet> hayashi, one of the dependencis probably has a restrictive upper bound on containers for some reason (or with no reason)
04:43:03 <killy9999> if it was compiled against containers-0.4.2.1 then it will not work with 0.5.0.0
04:44:23 <typoclass> hayashi: to find out what's going on, try "-v3". if the output isn't clear, feel free to put it on hpaste and ask in here :-)
04:44:26 <typoclass> @where hpaste
04:44:26 <lambdabot> http://hpaste.org/
04:44:59 <fmap> hayashi: yeah, --constraint='containers-0.5.0.0'
04:45:08 <hayashi> ahs
04:45:14 <AfC> hayashi: I have attoparsec-0.10.2.0 and containers-0.5.1.0 simultaneously installed here.
04:45:22 <hayashi> i just tried --upgrade-dependencies and am preparing for wonderful happy breakage of everything ever
04:45:35 <AfC> hayashi: I'm getting a little tired of this sort of thing, too
04:45:36 <killy9999> speaking of cabal
04:45:52 <killy9999> can I force it to ignore warnings?
04:46:43 <alpounet> hayashi, well, i'd suggest using cabal-dev so that at least it won't fail because of stuffs you have previously installed in your user package db
04:46:44 <AfC> hayashi: I half-way wonder what the only realistic way to upgrade is to rm -r ~/.ghc/$arch and then reinstall... everything :(
04:47:31 <killy9999> AfC: +1
04:49:01 <fmap> killy9999: what warnings?
04:49:07 <Y_Less> I have a quick question - the wiki states that to make things simpler, Cabal has different instal locations on different versions of Windows, but I'm not entirely clear on how that is meant to be simpler.  Surely it would be simpler to have just one location for every version?  Or is it simpler from a development point of view due to the constantly changing user directory layouts?
04:49:13 <AfC> killy9999: I have actually had some luck calling ghc-pkg unregister on problem packages, but I was surprised that it actually worked out in the end. I was expecting a full rebuild
04:49:36 <killy9999> fmap: that my package database is not up to date and I should run cabal update
04:49:51 <merijn> Y_Less: I think it just means that they follow the "default" location specified by Windows, which has changed over time
04:50:04 * hayashi spends most of his free hour pleading with cabal
04:50:09 <merijn> Y_Less: i.e. the default location exposed by XP is different from Windows 7
04:50:42 <alpounet> yes merijn, i think that's all there is to it
04:50:42 <iratsu> @pl \f g a -> f . g a
04:50:42 <lambdabot> (.) . (.)
04:50:48 <killy9999> fmap: but I also would like to have control over other warnings produced by cabal
04:51:01 <hayashi> mmm, triple-breasted whore combinator
04:51:04 <hayashi> my favourite.
04:51:22 <Y_Less> Ok, is there a way to change it as my GHC is on E:, my user directory is on C:, but I don't want to install packages on that disk or I would have installed the whole thing there in the first place.
04:51:25 <fmap> killy9999: ignore as in hide?
04:51:56 <fmap> surely cabal won't stop on `update me please'
04:52:04 <iratsu> > join ((.) . (.)) (uncurry (***)) ((+), (-)) (0, 0) (1, 1)
04:52:06 <lambdabot>   Occurs check: cannot construct the infinite type: b'0 = b'0 -> b'0Occurs ch...
04:53:47 <killy9999> fmap: ignore as "I know that, stop displaying this bloody message on my stdout every time I run cabal configure"
04:57:27 <iratsu> > (fmap fmap fmap) (uncurry (***)) (uncurry (***)) ((+), (-)) (0, 0) (1, 1)
04:57:29 <lambdabot>   (1,-1)
04:58:57 <zhulikas> :D
05:00:17 <Y_Less> Figured it out
05:02:21 <killy9999> does anyone know what module defines remInt# ?
05:02:30 <zhulikas> @pl (1, -1)
05:02:31 <lambdabot> (line 1, column 3):
05:02:31 <lambdabot> unexpected ","
05:02:31 <lambdabot> expecting digit, variable, "(", operator or ")"
05:02:36 <zhulikas> ok :|
05:02:58 <Botje> zhulikas: that's just a value, silly.
05:03:11 <zhulikas> just fooling around
05:03:18 <alpounet> Y_Less, it's in your ~/.cabal/config
05:03:26 <alpounet> but you seem to have figured it out
05:03:40 <Philonous> Botje:  Functions are values, too.
05:04:01 <zhulikas> I was tempted to say that too
05:04:15 <zhulikas> but it's a meaningless discussion
05:04:35 <Philonous> zhulikas:  The best kind!
05:04:40 <zhulikas> :D
05:04:55 <zhulikas> it's relatively easy to start pointless discussions here :P
05:05:16 <Philonous> zhulikas:  That's what @pl is for
05:06:47 * hackagebot process-conduit 0.5.0.4 - Conduits for processes  http://hackage.haskell.org/package/process-conduit-0.5.0.4 (HideyukiTanaka)
05:06:48 * hackagebot zlib-bindings 0.1.1.2 - Low-level bindings to the zlib package.  http://hackage.haskell.org/package/zlib-bindings-0.1.1.2 (MichaelSnoyman)
05:14:38 <TBJoe> hey guys, is there a way of running the haskell interpreter in editors like Notepad++? (i prefer an interactive one ghci or even better winghci)
05:15:01 <TBJoe> i couldnt figure it out by myself with google
05:15:05 <shachaf> That sounds like a Notepad++-question, not a Haskell question.
05:15:34 <TBJoe> well i thought you guys maybe know the arguments etc that need to be passed to the haskell interpreter when calling it
05:16:03 <mauke> what arguments?
05:16:07 <TBJoe> and Notepad++ is just an example of an editor so its definetely not a Notepad++ question
05:16:24 <shachaf> This is just a Notepad karma ring, isn't it?
05:16:34 * shachaf can see right through you.
05:16:57 <TBJoe> arguments like which file to interpret, im a dumb windows user who doesn't use console commands :(
05:17:07 * sopvop looks down on anyone who does not use emacs or vi
05:17:13 <latermuse> TBJoe: you can run ghci in vim and emacs pretty easily
05:17:13 <mauke> TBJoe: most editors don't support running commands in them
05:17:36 <shachaf> mauke: If you want to give it which file to interpret, I suggest you do just that.
05:17:41 <shachaf> s/mauke/TBJoe/
05:17:55 <shachaf> (I assume mauke could figure it out.)
05:18:05 <latermuse> I use a tiling window manager with ghci running in one, and vim running in another. its easy to jump back and forth that way
05:18:24 <killy9999> TBJoe: become a smart linux user :)
05:18:34 * killy9999 uses tmux
05:18:45 <latermuse> killy9999: *nix user you mean
05:19:03 <latermuse> unix/linux/*bsd are all good for programming on
05:19:07 <sopvop> mac is a nix too
05:19:20 <shachaf> Are you serious? Someone comes in with an (unrelated to Haskell, but anyway) editor question and you tell them to switch operating systems?
05:19:30 <shachaf> And then you get into an argument about The True Meaning of Unix?
05:19:42 <killy9999> latermuse: yes,
05:19:43 <TBJoe> why not? seems legit
05:19:45 <latermuse> shachaf: no. I recommended they use vim or emacs, which are available on windows and *nix.
05:20:11 <killy9999> shachaf: don't you know that all Windows problems are solved by reinstallation?
05:20:13 <shachaf> Are you *really* going to tell someone to use vim or emacs?
05:20:18 <shachaf> Come on.
05:20:32 <latermuse> shachaf: they asked how to run ghci in their editor. vim and emacs are the first ones to come to mind
05:20:45 <zhulikas> eclipse can run ghci too :P
05:20:48 <mauke> shachaf: definitely
05:20:54 <merijn> Telling windows users with no *nix experience to use vim and emacs is ridiculously unhelpful
05:20:54 <TBJoe> i actually used linux for a while but as a gamer its easier to stay with windows ... and i see why vim is a good editor if you really want to be productive but i also dont want to learn it as i feel like "normal" editors are powerful enough for me :)
05:21:14 <Botje> TBJoe: if i remember correctly, the haskell platform ships with winghci
05:21:21 <latermuse> merijn: we cant be sure he is a windows user. he just gave notepad++ as an editor example.
05:21:26 <zhulikas> TBJoe, did you look into EclipseFP?
05:21:27 <killy9999> TBJoe: zhulikas has a point there
05:21:27 <shachaf> mauke: To which?
05:21:33 <killy9999> you can use EclipseFP
05:21:33 <zhulikas> it has a great support for Haskell
05:21:34 <Botje> which is ghci with some windows stylings
05:21:35 <zomg> TBJoe: that's what you think until you learn vim ;)
05:21:42 <latermuse> although notepad++ is a windows program, it cant be solid evidence that he is a windows-only kind of person
05:21:55 <mauke> shachaf: either, actually
05:22:07 <shachaf> mauke: I meant to which question, but that answers it.
05:22:08 <TBJoe> @zhulikas: i dont like eclipse :)
05:22:09 <lambdabot> Unknown command, try @list
05:22:24 <merijn> latermuse: He explicitly said he was a windows user...
05:22:25 <donri> latermuse: <TBJoe> arguments like which file to interpret, im a dumb windows user who doesn't use console commands :(
05:22:40 <latermuse> merijn: Sorry, I missed that message.
05:22:56 <zhulikas> I actually wish I knew how to use vim...
05:23:14 <latermuse> zhulikas: http://robertmassaioli.wordpress.com/2010/06/16/haskellmode-guide-awesome-haskell-with-vim/
05:23:14 <zhulikas> it's so cool when everyone talks about it, yet it's mysterious and alien to me :(
05:23:35 <shachaf> This channel is terrible.
05:23:35 <sopvop> stop being silly. use ghci like : ghci -iD:\mycode\myproject\src  Main
05:23:36 <TBJoe> its easy to distract you guys from a simple question, isnt it? i mean i understand your point, its not really about haskell but i thought maybe some haskell users have already embedded the interpreter to another editor ... well but it was naiv to think i'd get an easy answer in a programming community :p
05:24:13 <mauke> TBJoe: sure they have, but how will that help you?
05:24:14 <zhulikas> :D
05:24:19 <zhulikas> hehehe
05:24:23 <latermuse> :D
05:24:35 <merijn> TBJoe: Well, it's not all that simple of a question. It really depends on Notepad++ how you can (or can't) embed interpreters in it
05:24:37 <Botje> TBJoe: you rejected eclipseFP and don't want to use emacs. then that leaves you with either yi or helium
05:24:41 <mauke> I imagine it's trivial in emacs
05:24:55 <TBJoe> mauke: thats how society works (or should). one achieves something and then is able and willing to share with others :)
05:24:56 <merijn> shachaf: Yes, let's yell at people about it :)
05:25:06 <mauke> TBJoe: are you willing to switch to emacs?
05:25:13 <zhulikas> latermuse, I will go over this tutorial in the evening and see if I can make it all work
05:25:29 <merijn> mauke: Are you sure that'll work on the windows version of emacs too?
05:25:30 <zhulikas> latermuse, if it gives me acceptible support for writing Haskell, I may slowly switch to it
05:25:32 <Botje> TBJoe: my professor *hates* commandline stuff and he gets along with emacs just fine
05:25:35 <latermuse> zhulikas: good luck! you might also want to check out a beginner vim tutorial before trying to setup haskellmode.
05:25:50 <mauke> merijn: no
05:25:52 <TBJoe> id rather not switch anything now if it works with my current preferences
05:25:56 <donri> vim's haskellmode is terrible
05:25:57 <zhulikas> I am not a beginner, I successfully completed vim-adventures! :P
05:26:07 <latermuse> zhulikas: http://vimcasts.org is a good place to start with beginner tutorials
05:26:07 * zhulikas is a pro at hjkl
05:26:07 <shachaf> TBJoe: You haven't actually asked a clear question.
05:26:18 <mauke> TBJoe: "if"
05:26:25 <shachaf> That's the main reason people are going off on tangents.
05:26:26 <donri> you want ghc-mod or hdevtools and neco-ghc
05:26:35 <sopvop> hey, I actually found how to do this in notepad++
05:26:44 <donri> emacs is much better at embedding ghci though
05:26:50 * merijn never bothered with haskellmode for vim, seemed like to much work :p
05:27:00 <zhulikas> embed a terminal or somehting and execute a command upon window show-up? )
05:27:03 <latermuse> sopvop: please go on
05:27:15 <zhulikas> plugin should be quite easy to write
05:27:49 <sopvop> install NppExec, open file and press F6, in the window write 'NPP_SAVE' and 'ghci "$(FULL_CURRENT_PATH")'
05:27:52 <donri> if you think hjkl is what makes vim effective, you've missed The Point :)
05:28:05 <zhulikas> :D
05:28:11 <donri> using hjkl in vim is almost as bad as using the arrow keys
05:28:27 <zhulikas> that was a bad joke I guess
05:28:32 <mauke> I use the arrow keys!
05:28:35 <zhulikas> but what makes vim a good editor then?
05:28:39 <latermuse> i find hjkl and the arrow keys have their uses in different scenarios
05:28:44 <TBJoe> @sopvop: ok thanks i will try that
05:28:45 <lambdabot> Unknown command, try @list
05:29:16 <nevrenato> Hi all
05:29:20 <donri> zhulikas: http://stevelosh.com/blog/2010/09/coming-home-to-vim/#vims-feeling
05:29:22 <hpaste> nevrenato pasted “How to get around this” at http://hpaste.org/77962
05:29:24 <zhulikas> I am not actually sure how great is hjkl compared to arrow keys because of the reason such as 'you don't need to move your hand around the keyboard'
05:29:39 <zhulikas> I mean... you think 95% of the time anyway
05:29:41 <latermuse> zhulikas: you can do massive sweeping changes in just a few keystrokes. you can also do accurate and pinpointed changes in just a few keystrokes
05:29:45 <zhulikas> and program only 5% remaining
05:29:57 <zhulikas> (disregard the numbers though)
05:29:59 <nevrenato> Is there a way to get around this problem pasted in http://hpaste.org/77962 ??
05:30:06 <sopvop> nevrenato: add type signature to x
05:30:09 <donri> hjkl is just the arrow keys but in your home row. effectively using vim is about understanding the motions and operators and such
05:30:42 <mauke> nevrenato: add a type annotation to C
05:30:47 <zhulikas> not sure typing and editing code faster makes one a better programmer
05:31:24 <sopvop> If you think slower than you type then no
05:31:29 <zhulikas> :D
05:31:32 <mauke> nevrenato: alternatively: data FW = FW String; x = FW (show C)
05:32:04 <zhulikas> can you think fast about non-trivial things?
05:32:11 <mauke> yes
05:32:19 <latermuse> vi/m is useful for me when using ssh to access servers across the world. because the latency can be so high, its easy to jump around and make changes without needing to wait forever
05:32:19 <donri> i don't think vim is about speed so much as comfort
05:32:20 <mauke> familiarity is all it takes
05:32:23 <sopvop> emacs is real fingerbender
05:32:40 <zhulikas> comfort
05:32:42 <zhulikas> hmmm
05:32:47 <latermuse> sopvop: I dont like emacs because it hurts my pinkies
05:32:48 <merijn> zhulikas: It's not about editing speed, it's about being able to edit on reflexes
05:33:02 <osfameron> lowering the friction required to do useful things
05:33:06 * sopvop has enough long fingers for emacs
05:33:13 <mauke> use more pedals
05:33:19 <zhulikas> :D
05:33:27 * zhulikas saw a pedal for vim too
05:33:34 <shachaf> nevrenato: Just use FOR String
05:33:37 <latermuse> pedal??
05:33:43 <jacobian> I wish emacs had a haskell mode like Slime.
05:33:45 <merijn> zhulikas: I had an (emacs using) colleague that saw me do something in vim and asked "how did you do that?" and I actually had to redo it in slo-mo to figure out what I was doing as vim commands have become so ingrained I actually think in term of editing operations, rather than keys to press
05:33:56 <latermuse> jacobian: doesnt it?
05:34:02 <zhulikas> hmmm
05:34:08 <jacobian> merijn, that's typical for me in emacs as well
05:34:10 <zhulikas> so you say vim is intuitive
05:34:19 <jacobian> I have muscle memory performing many of the commands.
05:34:21 <nevrenato> mauke, shachaf : I don't want to do that or else I will over restrict f
05:34:23 <shachaf> This editor talk is off-topic.
05:34:28 <shachaf> You should take it to #not-haskell
05:34:32 <merijn> Yeah, let's go -blah
05:34:35 <mauke> nevrenato: how so?
05:34:36 <jacobian> It's not off topic if it's about emacs haskell mode :)
05:34:40 <sopvop> average emacs user http://goo.gl/fKd2U
05:34:45 <shachaf> jacobian: Yes it is.
05:35:08 <jacobian> Where is it on-topic ?
05:35:16 <nevrenato> mauke : Because i don't know if f is a string or not, i only know that instances the Show class
05:35:18 <shachaf> #emacs
05:35:21 <shachaf> #not-haskell
05:35:25 <jacobian> Dubious
05:35:36 <shachaf> OK, if it has to do with Haskell it might be on-topic.
05:35:36 <latermuse> how about arrows? when should they be used?
05:35:58 <shachaf> Are you talking about arrow keys or Arrow?
05:36:05 <jacobian> <latermuse> jacobian: doesnt it?
05:36:07 <jacobian> Does it?
05:36:14 <mauke> nevrenato: uh. if it's an instance of Show, you can always convert it to a String beforehand
05:36:15 <jacobian> if it does, I need to start using it
05:36:38 <mauke> nevrenato: that is, just use FW (show x) everywhere
05:36:47 * hackagebot cabal2nix 1.42 - Convert Cabal files into Nix build instructions  http://hackage.haskell.org/package/cabal2nix-1.42 (PeterSimons)
05:38:54 <nevrenato> mauke : ok then, i shouldn't have used the Show Class. let's try another way
05:39:01 <hpaste> nevrenato pasted “How to get around this” at http://hpaste.org/77963
05:39:01 <Thomyho> hey@ all
05:39:08 <latermuse> shachaf: I was just trying to get the chat back on topic by talking about arrows.
05:39:19 <shachaf> nevrenato: No, you have it backwards.
05:39:35 <shachaf> nevrenato: What you want to do there depends on exactly what class X is.
05:39:47 <shachaf> If X is like Show, for example, you might as well use String.
05:39:51 <latermuse> jacobian: I am pretty sure there is a pretty good haskell mode for emacs. But I dont use it, so have no personal experience.
05:40:02 <shachaf> If X is like Read, you might as well not do anything at all, because it's useless.
05:40:22 <shachaf> If X is something else, you might do something else.
05:40:28 <shachaf> nevrenato: Did you read this article?
05:40:30 <shachaf> @where antipattern
05:40:31 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
05:40:44 <mauke> nevrenato: that question was already answered
05:41:00 <nevrenato> mauke : No, i will read it thanks :)
05:41:23 <latermuse> jacobian: http://www.haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:41:27 <mauke> ITYM shachaf:
05:41:30 <sopvop> Great article, I stopped pursuing existentials after reading it.
05:41:41 <jacobian> latermuse, thanks
05:42:38 <LAMMJohnson> Appropriate greetings for you time of day, glorious Haskellbros.
05:43:01 <LAMMJohnson> I'm stupid and can't correctly derive an instance of the Random class.
05:43:03 <sopvop> mildly sexist greeting to you too
05:43:13 <Iceland_jack> heh
05:43:20 <LAMMJohnson> http://hpaste.org/new
05:43:33 <lantti> Haskellbro sounds a bit like Hasbro
05:43:45 <merijn> sopvop: The term bro is sexist nowadays?
05:43:58 <Iceland_jack> merijn: assuming everyone on this channel is male is, yeah
05:44:00 <LAMMJohnson> My data type is basically a bool. Is there any man or woman awesome enough to help me?
05:44:08 <mauke> merijn: "nowadays"?
05:44:09 <Thomyho> hey guys, i am actually trying to write a QuickCheck function to test mei multMat function, which multiplicates two matrixes. How i can set Parameters for QuickCheck that Haskell is just using special testmatrixes
05:44:10 <LAMMJohnson> I have fixed my mild sexism appropriately.
05:44:16 <sopvop> LAMMJohson: Show us some code
05:44:18 <Iceland_jack> LAMMJohnson: ;)
05:44:19 <Thomyho> thats the function
05:44:20 <Thomyho> import Test.QuickCheck
05:44:20 <Thomyho> type Matrix a = [[a]]
05:44:20 <Thomyho> type IntMat = Matrix Integer
05:44:20 <Thomyho> transpose :: Matrix a -> Matrix a
05:44:20 <Thomyho> transpose ([]:_) = []
05:44:21 <Thomyho> transpose x = (map head x) : transpose (map tail x)
05:44:21 <Thomyho> dotp :: [ Integer ] -> [ Integer ] -> Integer
05:44:22 <Thomyho> dotp xs ys = sum $ zipWith (*) xs ys
05:44:22 <Thomyho> multMat :: IntMat -> IntMat -> IntMat
05:44:23 <Thomyho> multMat a b = [[dotp a b |b <- (transpose b)]| a <- a]
05:44:23 <Thomyho> test :: IntMat ->IntMat ->Bool
05:44:24 <Thomyho> test a b = multMat a b == multMat a b
05:44:24 --- mode: ChanServ set +o mauke
05:44:25 --- kick: Thomyho was kicked by mauke (Thomyho)
05:44:26 <sopvop> whoa
05:44:43 <LAMMJohnson> sopvop: I did an hpaste. http://hpaste.org/new
05:44:45 <LAMMJohnson> Oh
05:44:45 <merijn> Iceland_jack: Generally the people know employ bro as equal opportunity term
05:44:50 <LAMMJohnson> Excuse my silly paste.
05:45:10 <LAMMJohnson> http://hpaste.org/77964
05:45:20 <hpaste> Thomas pasted “QuickCheck Matrix” at http://hpaste.org/77965
05:45:24 <mauke> :t random
05:45:26 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
05:46:09 <mauke> random g = (if b then Alive else Dead, g') where (b, g') = random g
05:46:18 <LAMMJohnson> I just can't wrap my head around how to write what is effectively an instance of Random for Bool.
05:46:25 --- mode: mauke set -o mauke
05:47:25 <LAMMJohnson> mauke: You are truly a God amongst non-gender specific people.
05:48:12 <Thomyho> thx, worked :)
05:48:20 <sopvop> LammJohnson: As I understand, you should use 'next' from RandomGen
05:48:22 <mauke> "people" is already non-gender-specific
05:49:39 <sopvop> random g = \(i, g') -> (odd i, g') $ next g
05:49:41 <sopvop> or something
05:49:57 <mauke> :t next
05:49:58 <lambdabot> RandomGen g => g -> (Int, g)
05:50:09 <LAMMJohnson> sopvop: Thankyou. mauke already hit me up with instance goodness.
05:50:12 <Thomyho> @all ^^ does someone has a good side which explains, how i can transform a matrix
05:50:16 <lambdabot> No match for "^^".
05:50:16 <lambdabot>  
05:50:16 <lambdabot> *** "Does" gcide "The Collaborative International Dictionary of English v.0.48"
05:50:16 <lambdabot> Does \Does\ (d[u^]z).
05:50:16 <lambdabot>    The 3d pers. sing. pres. of {Do}.
05:50:17 <mauke> sopvop: why bother when you can piggyback on Bool?
05:50:18 <lambdabot> [2944 @more lines]
05:50:30 <sopvop> For general case
05:50:42 <LAMMJohnson> ghci complains to me abotu a lack of a randomR method but I laugh in the face of mere warnings
05:50:45 <LAMMJohnson> Hahahahaha
05:50:50 <mauke> :t randomR
05:50:52 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
05:51:22 <sopvop> You'll need Bounded and Enum for that :)
05:51:26 <mauke> I think you want to derive Enum and Bounded, and define from/to Bool functions
05:51:34 <sopvop> :)
05:51:50 <mauke> you don't need Bounded or Enum for that
05:52:04 <sopvop> but it will be easier that way
05:52:08 <mauke> fromBool = toEnum . fromEnum; toBool = toEnum . fromEnum
05:52:10 <LAMMJohnson> So if Enum and Bounded are a bit... superfluous what would be good practise?
05:52:13 <mauke> still no Bounded required
05:52:21 <LAMMJohnson> Derive anyway to eliminate the warning, I would guess?
05:53:11 <sopvop> Use bool again
05:53:31 <joshcheek> Hi, trying to go through Programming in Haskell, and I'm stuck on the chapter about parsers. I basically copied this code verbatim (switched return to Main.return), but it won't even compile. Also `x <- item` doesn't make sense to me, because it looks like x is expected to be a Char, but item returns `[(Char, String)]` https://gist.github.com/4118052
05:54:07 <shachaf> joshcheek: That code doesn't quite work verbatim.
05:54:19 <LAMMJohnson> sopvop: Cheers.
05:54:19 <shachaf> joshcheek: Programming in Haskell's website has adapted code that'll work.
05:54:20 <LAMMJohnson> I got it.
05:54:24 <shachaf> @google hutton haskell
05:54:26 <lambdabot> http://www.cs.nott.ac.uk/~gmh/book.html
05:54:27 <lambdabot> Title: Programming in Haskell
05:54:27 <TBJoe> so, now a real haskell related question. im new to functional programming and haskell (started 2 days ago) ... ive just written a function that can flatten a binary tree (write the nodes into a list) ... but how can i do the reverse thing? how can i build the tree recursively? i'd need something like a "addNode" function how do i get this?
05:54:33 <shachaf> joshcheek: ☝
05:54:50 <joshcheek> shachaf: Thank you :)
05:54:52 <shachaf> joshcheek: The answer to the other thing is in the definition of <- (and >>=)
05:55:12 <osfameron> TBJoe: why don't you paste the code you've got to a pastebin?
05:55:15 <shachaf> joshcheek: When you write "x <- y", and y has type Parser a, x gets the type a
05:55:19 <Botje> TBJoe: do you know how to insert into a binary tree in another language?
05:55:29 <osfameron> TBJoe: http://hpaste.org/
05:55:42 <shachaf> joshcheek: That's because it really turns into y >>= (\x -> ...)
05:55:44 <TBJoe> osfameron: cause i dont have any code yet (only the data type but its a common version of a tree in haskell)
05:56:03 <TBJoe> botje: no i have experience in other languages but not with trees
05:56:11 <osfameron> TBJoe: well paste the functionthat flattens the binary tree?
05:56:12 <sopvop> TBJoe: write a function to add node to it
05:56:24 <osfameron> so we have an idea of what data you're using in the other direction
05:56:24 <LAMMJohnson> Has anybody seen smoothlife? It's a generalisation of Conway's Game of Life for rounded surfaces and a smooth sort of pseudo-grid.
05:56:37 <LAMMJohnson> It's useless but hugely cool.
05:56:40 <TBJoe> sry missclicked
05:56:57 <LAMMJohnson> http://youtu.be/KJe9H6qS82I
05:57:24 <hpaste> TBJoe pasted “tree” at http://hpaste.org/77966
05:57:44 <Botje> TBJoe: perhaps you want to read https://en.wikipedia.org/wiki/Binary_search_tree first, then.
05:57:53 <Botje> that outlines the algorithm in pseudocode
05:58:42 <merijn> TBJoe: You want to write "insert :: a -> Tree a -> Tree a", so start with the base case, what would "insert 1 Empty" return?
05:58:47 <TBJoe> botje: well i understand what trees are the problem is that i am new to haskell. i need a point to start: how can i add something to the tree?
05:59:00 <Botje> TBJoe: you create a new tree with the new node in place :)
05:59:03 <TBJoe> maybe im stuck with imperative programming style at this point
05:59:16 <merijn> TBJoe: Since everything in haskell is immutable you just create a new tree using bits of the old one
06:01:00 <Botje> TBJoe: start with the simplest case. how do you insert something into an Empty tree?
06:01:32 <TBJoe> i create a new node (Node x Empty Empty) where x is the node i want to insert
06:01:59 <Botje> okay, that's one clause of insert.
06:02:07 <zhulikas> are old references being kept when you construct a new tree? or are the previous values being copied over?
06:02:24 <sopvop> There is a binary tree implementation with explanation http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures
06:02:40 <Botje> zhulikas: it just reuses the nodes.
06:03:02 <Botje> zhulikas: otherwise (:) would also need to copy the entire list
06:03:02 <merijn> TBJoe: Right, so now your problem becomes "given a tree, you either create a new node *or* insert in one of the two subtrees"
06:03:26 <TBJoe> @sopvop thx ill maybe read into that but i want to do most of the work by myself i just need a point to start
06:03:26 <lambdabot> Unknown command, try @list
06:03:31 <zhulikas> ok
06:03:57 <TBJoe> merijn: thats right and thats my problem :D
06:04:15 <Botje> TBJoe: okay, let's walk through the second case.
06:04:29 <Botje> what is the result of insert 5 (Node 5 whatever whatever) ?
06:04:41 <sopvop> insertTree Empty x = Node x Empty Empty -- first case
06:06:36 <TBJoe> not sure, depends what insert does :o maybe (Node 5 (Node 5 Empty Empty) whatever) if `whatever` should mean something like `Empty`
06:06:59 <Botje> TBJoe: well, assume you don't want duplicates in your tree.
06:07:29 <sopvop> TBJoe: usually values inserted to binary tree have order (thus you will get binary search tree)
06:07:42 <TBJoe> so it stays like it was before?
06:07:46 <Botje> yes.
06:07:59 <TBJoe> ok makes sense
06:08:13 <Botje> so now we come into the hard part.
06:08:19 <Botje> you need to descend either left or right.
06:08:59 <Botje> so in an imperative language you descend into the left or right subtree and do your modification there
06:09:41 <Botje> in haskell you need to change one of the two subtrees *and* keep the other subtree untouched
06:10:33 <Botje> (because in a BST, the left subtree of a node can only contain values smaller than the node's key)
06:10:57 <TBJoe> right
06:11:43 <Botje> so you need to recursively call insert on the correct subtree
06:11:54 <Botje> and then combine it with the other tree.
06:12:46 <hpaste> Thomyho pasted “what is wrong with it :??” at http://hpaste.org/77968
06:12:55 <Thomyho> can somebody help me, pls?
06:14:31 <TBJoe> @botje: actually sounds easy to walk through the tree to find the right place for the given value. but how do i change/recreate the whole tree then?
06:14:31 <lambdabot> Unknown command, try @list
06:15:19 <Botje> TBJoe: you take the return value from the recursive insert
06:15:24 <Botje> (which is a tree)
06:15:41 <Botje> and you feed it to the Node constructor with the other parameters.
06:15:54 <mauke> Thomyho: with what?
06:15:58 <Botje> so if you have Node x left right and you've determined you need to insert into the left subtree
06:16:01 <ppseafield> Thomyho: perhaps you meant -> instead of => on line 4
06:16:06 <Botje> you do Node x (insert y left) right
06:17:16 <TBJoe> well ill need to to think about that now
06:18:37 <Thomyho> @mauke still doesn't work :(
06:18:38 <lambdabot> Unknown command, try @list
06:18:41 <jacobian> I always seem to end up requiring two versions of mtl indirectly
06:18:44 <mauke> Thomyho: what?
06:18:44 <jacobian> Is that normal?
06:18:51 <jacobian> (using cabal)
06:19:16 <ppseafield> Thomyho: also, you don't need the argument (the "a" in "showMat a") since you only partially applied the map
06:20:12 <ppseafield> :t unlines . map unwords . map (map show)
06:20:13 <lambdabot> Show a => [[a]] -> String
06:21:48 * hackagebot bash 0.1.5 - Bash generation library.  http://hackage.haskell.org/package/bash-0.1.5 (JasonDusek)
06:21:54 <Thomyho> the function should give out  putStrLn $ showMat [[1 ,2 ,3] ,[4 ,50 ,57] ,[9 ,1 ,43565]]
06:21:54 <Thomyho> <Thomyho>1 2 3
06:21:54 <Thomyho> <Thomyho>4 50 57
06:21:54 <Thomyho> <Thomyho>9 1 43565
06:22:18 <mauke> you're incoherent
06:22:50 <astropirate> ( ͡° ͜ʖ ͡°)
06:23:09 <Botje> TBJoe: are you familiar with list processing in haskell?
06:23:36 <Botje> TBJoe: note how map and filter are very careful about using (:) to stitch the list back together after doing their thing.
06:24:32 <TBJoe> i am familiar with the syntax (:) and i know map and filter but not how they are programmed
06:25:41 <byorgey> TBJoe: then it sounds like it would be a good exercise for you to try implementing map and filter yourself =)
06:26:04 <TBJoe> yeah maybe :)
06:26:48 * hackagebot simple-log-syslog 0.1.1.0 - Syslog backend for simple-log  http://hackage.haskell.org/package/simple-log-syslog-0.1.1.0 (AlexandrRuchkin)
06:26:52 <hpaste> Thomyho pasted “Should give out a formated Matrix” at http://hpaste.org/77969
06:27:00 <zhulikas> > let f = Prelude.filter in f (>2) [1,2,3,4]
06:27:02 <zhulikas> like that?
06:27:03 <lambdabot>   [3,4]
06:27:18 <nand`> zhulikas: you get full points from me
06:27:31 <nand`> for re-using existing code in elegant ways to arrive at a conciser implementation ;)
06:27:43 <zhulikas> \o/
06:27:51 <TBJoe> gj
06:28:16 <rwbarton> highly optimized too
06:28:51 * nand` wonders how one would do this with lenses
06:29:09 <zhulikas> :D
06:29:16 <nand`> something like traversing into a Maybe [a]
06:29:47 <ppseafield> Thomyho: remove the `a` in `showMat a` and it works
06:31:39 <fmap> nand`: do what?
06:32:01 <nand`> if we had lawful restricted traversals it would be as simple as x^..restrict f traverse
06:32:07 <nand`> fmap: implement filter :)
06:32:18 <fmap> :t filtered
06:32:20 <lambdabot> Applicative f => (a -> Bool) -> SimpleLensLike f a a
06:32:55 <nand`> > [1,2,3,4]^..traverse.filtered (>2)
06:32:57 <lambdabot>   [3,4]
06:33:10 <nand`> \o/
06:33:27 <Thomyho> :all thx
06:33:32 <zhulikas> I can again optimize it!
06:35:00 <nand`> > [1..10] % traverse.filtered (>5) %~ negate
06:35:02 <lambdabot>   [1,2,3,4,5,-6,-7,-8,-9,-10]
06:35:17 <nand`> oh neat, I didn't know about that
06:35:24 <edwardk> nand`: note filtered can be composed folds legally, but if you compose it with traverse and use it as a traversal, you are taking the laws into your own hands =P
06:35:29 <zhulikas> huh
06:35:31 <nand`> ah
06:35:52 <nand`> edwardk: so it suffers from the same law paradox as restrict :: Applicative f => (a -> Bool) -> SimpleLensLike f s a -> SimpleLensLike f s a ?
06:35:55 <nand`> I guess it's pretty much the same thing
06:35:59 <edwardk> i gave it a very liberal type signature, which doesn't enforce the traversal laws but typechecks
06:36:14 <edwardk> yes, its just designed that you post compose with it instead of pass it the other lens
06:36:19 <edwardk> which led to a prettier api
06:36:29 <nand`> > [1..4]^..folded.filtered (>2)
06:36:31 <lambdabot>   [3,4]
06:36:34 <nand`> there we go
06:36:45 <edwardk> that is completely legal and its intended use ;)
06:37:04 <Abso> Hey I have got a problem with a custom type: http://dpaste.com/833791/
06:38:00 <rwbarton> Abso: snd is only for 2-tuples (pairs)
06:38:07 <edwardk> > ([1..10] % traverse.filtered (>5) %~ negate % traverse.filtered (>5) %~ negate,  [1..10] % traverse.filtered (>5) (negate.negate))
06:38:09 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[b0]'
06:38:23 <edwardk> > ([1..10] % traverse.filtered (>5) %~ negate % traverse.filtered (>5) %~ negate,  [1..10] % traverse.filtered (>5) %~ negate.negate)
06:38:25 <Abso> so how do I access the second argument then ?
06:38:26 <lambdabot>   ([1,2,3,4,5,-6,-7,-8,-9,-10],[1,2,3,4,5,6,7,8,9,10])
06:38:32 <rwbarton> use pattern matching
06:38:42 <edwardk> you'd want those to be equal by the first setter law
06:38:43 <zhulikas> @hoogle (a, b, c) -> c
06:38:44 <lambdabot> Data.Typeable typeOf3 :: Typeable3 t => t a b c -> TypeRep
06:38:44 <lambdabot> Data.Typeable typeOf2Default :: (Typeable3 t, Typeable a) => t a b c -> TypeRep
06:38:48 <rwbarton> daFunction (a, b, c) = b
06:38:51 <noby> snd3 (_,b,_) = b
06:38:55 <rwbarton> (feel free to pick better names)
06:39:05 <zhulikas> trd
06:39:15 <Abso> oh ok
06:39:17 <Abso> thanks
06:39:18 <nand`> > zipper [[1],[2,3,4],[6,8,9]] % fromWithin (traverse.traverse.filtered even) % rightmost % focus .~ 100 % rezip -- goodbye laws :(
06:39:21 <lambdabot>   [[1],[2,3,4],[6,100,9]]
06:39:26 <rwbarton> you also may want to consider an actual data type, possibly defined with record syntax
06:39:35 <rwbarton> but that's not strictly necessary
06:39:54 <zhulikas> or some TH magic to automatically pick Nth element from your tuple
06:40:12 <edwardk> nand`: that guy was a fine usecase for it as a traversal though. you edited something even to something even
06:40:13 <rwbarton> you don't want to consider that
06:40:16 <edwardk> the laws held for you
06:40:37 <nand`> edwardk: what do you sacrifice if you drop that setter law? just optimizations, or do some utility functions die as well?
06:40:52 <edwardk> the ability to reason about lenses like functors
06:41:01 <edwardk> i like those laws =P
06:41:26 <edwardk> one nice thing about lenses is you can fuse together edits reasonably
06:41:42 <nand`> zhulikas: view _3 ;)
06:42:06 <edwardk> > ("hello","world","!!!!")^._2
06:42:08 <lambdabot>   "world"
06:42:17 <zhulikas> heh
06:42:25 <edwardk> > ("hello","world","!!!!")^._3
06:42:28 <lambdabot>   "!!!!"
06:42:37 <zhulikas> cool
06:42:49 <zhulikas> and I like that ._3, like in Scala
06:43:03 <nand`> my dissertation will be on automatically finding elegant lens one-liners to replace common functions
06:43:12 <edwardk> yeah i admit that was where i stole the name from. i had a bit of a mutiny on my hands when i proposed it here though ;)
06:43:25 <yitz> edwardk: oh noes it's the same as scala better change it! ;)
06:43:34 <nand`> then it can be built into hoogle
06:43:43 <edwardk> > ("hello",("world","!!!!")) & _2._1 %~ length
06:43:46 <lambdabot>   ("hello",(5,"!!!!"))
06:43:53 <nand`>  @djinn-lens
06:44:00 <sopvop> :t &
06:44:02 <lambdabot> parse error on input `&'
06:44:09 <sopvop> :t (&)
06:44:09 <zhulikas> _2._1
06:44:11 <lambdabot> a -> (a -> b) -> b
06:44:11 <edwardk> (&) = (%)
06:44:12 <zhulikas> does this type-check?
06:44:16 <edwardk> we're renaming it in the next release
06:44:19 <nand`> zhulikas: yes
06:44:20 <zhulikas> against what was in tuples?
06:44:20 <edwardk> yep
06:44:22 <zhulikas> wow, cool
06:44:23 <nand`> :t _2._1
06:44:24 <lambdabot> (Functor f, Field2 s t a b, Field1 a b a1 b1) => (a1 -> f b1) -> s -> f t
06:44:25 <yitz> @let (&) = (%)
06:44:26 <lambdabot>  <local>:4:1:
06:44:27 <lambdabot>      Multiple declarations of `&'
06:44:27 <lambdabot>      Declared at: <local>:1:1...
06:44:39 <edwardk> zhulikas: and it means more or less what you as an imperative programmer would expect
06:44:48 <edwardk> > ("hello",("world","!!!!"))^._2._1
06:44:49 <sopvop> edwardk lost to Data.Ratio
06:44:50 <lambdabot>   "world"
06:44:58 <nand`> (&) == (#) == (%) ?
06:45:02 <noby> (1,2,3,4,5,6,7)^._3
06:45:09 <akamaus> hi there. I'm parsing a binary network protocol. I've implemented a couple of Binary instances for my data types and looking for a way to run 'get' on data coming from a socket. Can't find a proper way. There is a 'decode' function, but it operates on bytestrings, not handles.
06:45:11 <zhulikas> have you considered making it more-imperative may not be a good strategic goal?
06:45:27 <yitz> @type (&)
06:45:30 <lambdabot> a -> (a -> b) -> b
06:45:32 <sopvop> akamaus: read bytestrings, pass to parser
06:45:34 <zhulikas> well, look more imperative
06:45:38 <edwardk> no, but once yitz offered up an operator with equivalent properties to (%) that was only a little harder to type and which read a little better, i could live with it.
06:45:45 <nand`> zhulikas: I think there's not much of a semantic different between fst (snd x) and x^.snd.fst
06:45:47 <nand`> difference*
06:45:55 <yitz> oh ok already done.
06:45:56 <edwardk> > (1,2,3,4,5,6,7)^._3
06:45:58 <lambdabot>   3
06:45:59 <akamaus> sopvop, I don't know the length of a packet in advance
06:46:00 <nand`> it fits perfectly within the haskell spirit of abstraction, reusability and elegance for me
06:46:12 <edwardk> yitz: that is just a @let for now. we haven't released the next version quite yet
06:46:13 <yitz> edwardk: wasn't my idea but i liked it.
06:46:19 <yitz> edwardk: understood
06:46:28 * nand` has immense difficulties typing #, muscle memory always takes it to $
06:46:45 <edwardk> we have a big limitation on 'taking from an infinite fold that we'd like to resolve first.
06:47:25 <nand`> edwardk: oh no, % is changing upstream? what about the other combinators like %~?
06:47:28 <sopvop> akamaus: recv :: Socket -> Int -> IO ByteString. That Int is Maximum length, actuall length is length of bytestring
06:47:33 <akamaus> sopvop, basically, I know what N serialized objects follows. The size of each differs depending on the type of the object.
06:47:51 <edwardk> taking works like 'take' but you pass it a fold, and it'll give you a fold that only returns at most n elements. but it can also be passed a traversal and do the same, etc. but right now we can suppport _either_ taking from an infinite traversal or from folds but not yet both from the same combinator
06:48:01 <edwardk> nand`: all the other combinators stay the same
06:48:12 <edwardk> the mod-equals mnemonic is too good
06:48:14 <zhulikas> isn't it just a scan?
06:49:37 <nand`> akamaus: isn't this a use case for something like attoparsec?
06:49:37 <edwardk> nand`: it reads pretty well for the zipper examples, the new way btw. moreover you no longer have the ugly foo % bar %~ baz % quux %~ quaffle
06:50:00 <edwardk> foo & bar %~ baz & quux %~ quaffle -- breaks it up a little better
06:50:08 <zhulikas> maybe I don't understand well enough but traversable fold with taking n elements is a scan for me
06:50:11 <nand`> the ‘&’ doesn't read half-bad either
06:50:13 <mapf> where is writeArray for list? something like set :: Int -> a -> [a] -> [a]
06:50:22 <nand`> “over bar baz and over quux quaffle”
06:50:34 <edwardk> zhulikas: well its a bit trickier because of the types involved
06:50:40 <edwardk> nand`: yep
06:50:51 <akamaus> nand`, maybe :) thanks for an idea.
06:51:00 <nand`> Record{} & field1 .~ 3 & field2 .~ "foo"
06:51:22 <edwardk> i warmed to it. i don't like the lack of consistency, but if it can smooth adoption with the 2-3 people who objected to taking Data.Ratio.% over the last 3 months, so be it =P
06:51:44 <nand`> akamaus: well, it seems like “I'm reading bytestrings in chunks but I don't know in advance how much I need to consume” <- attoparsec is oriented around that sort of thing, passing it data incrementally and having it return either a request for more data or the finished object + the rest of the data
06:52:33 <sopvop> akamaus: So you need partial results.  http://hackage.haskell.org/packages/archive/binary/0.6.2.0/doc/html/Data-Binary-Get.html#t:Decoder
06:53:06 <edwardk> > set (element 3) 12 [1..20]
06:53:08 <lambdabot>   [1,2,3,12,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
06:53:19 <nand`> :t element
06:53:19 <sopvop> akamaus: Done constructor keeps unused string
06:53:21 <lambdabot> (Functor f, Traversable t) => Int -> (a -> f a) -> t a -> f (t a)
06:55:41 <mapf> @src element
06:55:41 <lambdabot> Source not found. That's something I cannot allow to happen.
06:55:51 * nand` thinks there is a lot of code that could read in very straightforward ways with (&)
06:56:08 <nand`> runGetPartial myParser & pushChunk myInput1 & pushChunk myInput2 & pushEndOfInput
06:56:42 <akamaus> nand`, yeah. Actually my use case a bit different. I send a command to remote party and wait for response to parse. Then loop continues. So I need to read no more, no less than needed. In principle, I can calculate the size of the data on other end and send it before the data, but I'd like to avoid it, if possible.
06:57:13 <sopvop> was not runGetPartial changed to runGetIncremental?
06:57:20 <nand`> it was, I copied that from the comments
06:57:22 <nand`> that should be fixed
06:58:04 <sopvop> Also, where should I vote to include (&) to Data.Function?
06:58:56 <yitz> ok sopvop i'm with you on that now ;)
06:59:26 <sopvop> you write a ticket for library/base
06:59:53 <sopvop> or open ticket
06:59:57 <sopvop> English is hard
07:01:01 <latro`a> what is &
07:01:06 <nand`> flip id
07:01:19 <latro`a> with what precedence
07:01:31 <nand`> 1
07:01:31 <yitz> edwardk: you're ok with moving & to base?
07:01:33 <nand`> by the looks of it
07:01:37 <saep> :t flip it
07:01:38 <lambdabot>     Not in scope: `it'
07:01:39 <lambdabot>     Perhaps you meant one of these:
07:01:39 <lambdabot>       `id' (imported from Data.Function),
07:01:40 <edwardk> yitz: i would be happy with it
07:01:44 <latro`a> I don't get it, isn't that only slightly difference from $ then?
07:01:47 <latro`a> *different
07:01:53 <nand`> $ is id
07:02:13 <latro`a> er...
07:02:16 <nand`> or what did you mean?
07:02:27 <latro`a> so it is
07:02:28 <latro`a> carry on
07:02:31 <edwardk> latro`a: it binds ever so slightly tighter than ($) permittined them to be intermixed meaningfully
07:02:44 <S11001001> not %?
07:02:45 <latro`a> but it's also ordered the other way
07:02:49 <sopvop> I wonder why no-one invented (&) before
07:02:51 <nand`> S11001001: edwardk lost to Ratio
07:02:52 <edwardk> S11001001: yitz shamed us into renaming it
07:03:01 <S11001001> nand`: eh, who needs those
07:03:03 <latro`a> I saw an infix postfix function application in hmatrix
07:03:05 <latro`a> as \\
07:03:06 <nand`> don't ask me
07:03:06 <edwardk> really i just got tired of arguing ;)
07:03:12 <nand`> :t 1/2 :: Rational
07:03:13 <lambdabot> Rational
07:03:14 <S11001001> (|>) for life
07:03:21 <nand`> (|>) is just disgusting :(
07:03:24 <nand`> one character to omany
07:03:25 <edwardk> S11001001: |>=    is pretty hideous
07:03:26 <nand`> too*
07:03:40 <nand`> (yet >>= isn't?)
07:04:00 <latro`a> seems like all infix stuff is ugly until you're used to it
07:04:09 <latro`a> and any haskeller is used to >>= by way of necessity
07:04:11 <edwardk> nand`: for its stated purpose it is
07:04:19 <S11001001> infixes with low precedence should look bigger
07:04:33 <XexonixXexillion> >>= has a nice form when written by hand
07:04:41 <nand`> on the other hand, I'm fine with >>
07:04:48 <S11001001> how about *> nand`?
07:04:55 <sopvop> S11001001: >>>>>>>>= for 1, and >>= for 9?
07:04:59 <nand`> *> is for Applicative :)
07:05:07 <nand`> ah, but you're right
07:05:08 <S11001001> nand`: I mean aesthetically
07:05:09 <nand`> they're the same, aren't they?
07:05:14 <edwardk> latro`a: its more a matter of consistent semiotics for the use of symbols in the lib.     in lens you can use +=, -=, *= to modify the targets of a setter in the current state.
07:05:21 <FireFly> S11001001: so we should rename ($) then?
07:05:24 <nob> :t (|>)
07:05:25 <S11001001> sopvop: that's a little extreme
07:05:27 <lambdabot>     Not in scope: `|>'
07:05:27 <lambdabot>     Perhaps you meant one of these:
07:05:27 <lambdabot>       `Seq.|>' (imported from Data.Sequence),
07:05:35 <nand`> S11001001: I accept *> because of the nice convention with respect to <*>
07:05:49 <edwardk> you can also use <operator=   to also read the answer you modified. but this means you get <|>=  if you accept that (|>) as the mod operator
07:05:51 <S11001001> FireFly: $ is weird, but consider . versus <$>
07:05:53 <nand`> but I wouldn't think of it as natural for ‘sequencing operations’, IO-y speaking
07:05:54 <sopvop> We just need editor with variable size font.
07:06:02 <S11001001> FireFly: and $ has history, & does not.
07:06:03 <FireFly> S11001001: I like the other extreme end of that though.. regular function application being a zero-width operator in a sense :P
07:06:40 <FireFly> Right, true
07:07:46 <edwardk> but now (<|>=) fits two possible denotata it coud be use he applicative (<|>) on the target of the lens in the current state, or it could be modify the target and return the new answer. this latter is a very common operation, but the pull of the other denotation is strong
07:07:56 <sopvop> Alternative
07:08:01 <edwardk> yes
07:08:39 <edwardk> @tell shachaf BazaarT seems to be working pretty well
07:08:40 <lambdabot> Consider it noted.
07:09:31 <XexonixXexillion> Are there any simpler (read: smaller) haskell RTSs than GHC's?
07:10:27 <edwardk> XexonixXexillion: there have been many over the years
07:10:31 <sopvop> @implementations
07:10:31 <lambdabot> Unknown command, try @list
07:10:40 <sopvop> fy lambdabot http://www.haskell.org/haskellwiki/Implementations
07:11:32 <sopvop> there is link to comparision at the bottom of page
07:11:56 <mauke> @where implementations
07:11:56 <lambdabot> <http://www.haskell.org/haskellwiki/Implementations>. Also see `GHC',`Hugs',`Helium',`UHC',`DDC',`LHC',`JHC',`YHC',`NHC',`HBC',`UHC',`YaleHaskell',`Brisk'
07:12:07 <nand`> @where LHC
07:12:07 <lambdabot> http://lhc.seize.it/
07:12:27 <sopvop> @where waldo
07:12:28 <lambdabot> http://planet.haskell.org
07:16:08 <nand`> how many people would still say Hugs is the best system for newcomers to learn Haskell?
07:16:31 <FireFly> What (made|makes) it good for that task?
07:17:10 <nand`> judging by http://www.haskell.org/haskellwiki/Implementations “the convenience of an interactive interpreter (within which one can move from module to module to test different portions of a program)”, and supposedly also clearer error messages
07:17:20 <XexonixXexillion> It's also painless to install
07:17:37 <nyc> AFAICT ghci has superseded it.
07:17:41 <nand`> so is the haskell platform, on platforms where installation is not painless
07:18:39 <XexonixXexillion> For those of us not running Linux, Mac or Windows, compiling GHC is *incredibly* painful
07:19:15 <mcstar> just go, and buy linux, it's worth it
07:19:22 <mcstar> wait, it is free
07:20:13 <Cale> XexonixXexillion: You're not meant to compile GHC
07:20:14 <nyc> XexonixXexillion: ISTR ghc not being difficult on Solaris.
07:20:56 <Cale> (Well, if you're on a strange platform, you might be forced to...)
07:21:21 <Cale> But hopefully people contribute their binaries back to the GHC site, so not many people have to go through that pain.
07:21:33 <Cale> Bootstrapping isn't easy
07:22:39 <elliott> edwardk: if I asked what Control.Lens.Loupe was, would the answer make any more sense than the documentation :P
07:23:01 <edwardk> elliott: a loupe is a crippled lens you can hand back in a monad or a list
07:23:34 <edwardk> m (forall f. Functor f => (a -> f b) -> s -> f t)   doesn't work without impredicative types that are currently busted. picking f to be something that fully characterizes a lens does.
07:23:37 <S11001001> edwardk: it works only during a full moon?
07:23:40 <elliott> ah
07:23:47 <elliott> so it is a dirty compiler hack :)
07:24:02 <edwardk> elliott: its a workaround for the lack of usable impredicative types
07:24:09 <elliott> yeah
07:24:35 <edwardk> you can use any lens as a loupe, and you can 'cloneLens' to promote a loupe back to a lens. the combinators in control.lens.loupe exist because cloning is a PITA
07:24:51 <elliott> so Loupe ~ Lens basically
07:24:55 <elliott> just a different representation
07:24:58 <edwardk> > ("hello","world")^#_2
07:25:01 <lambdabot>   "world"
07:25:02 <elliott> or are they not quite isomorphic
07:25:05 <XexonixXexillion> The current computer I'm on runs Gentoo. I'll admit that that was a painless install (although still compiled from source). For haiku I have a broken version of GHC that kind of works for simple things. I did get it working on dragonflyBSD, but that was time consuming
07:25:18 <edwardk> yeah, its a presentation that doesn't play as well with (.) and the other lens variants
07:25:49 <elliott> "almost a Lens" in the documentation mislead me a bit -- I thought they were slightly semantically weaker somehow
07:26:05 <edwardk> they are equivalent but encoded worse =P
07:26:13 <edwardk> they are a bit slower in practice
07:26:26 <elliott> mere operational details
07:26:55 <edwardk> i take doc patches
07:26:59 <edwardk> :)
07:27:09 <nand`> quick, get your kmett number up
07:27:14 <edwardk> heh
07:27:18 <elliott> my kmett number is already 1!
07:27:31 <mcstar> i decided to do my web stuff with yesod, after all; wish me luck
07:27:41 <Leif_Bork> Hi! I'm doing some heap profiling, and suddenly I see a giant, very steap, rise for ghc-prim:GHC.Types.:, it drains all my memory. What could this be?
07:27:49 <edwardk> we switched conventions to one more useful to me. the kmett number is now defined by the number of lines worth of patches i've accepted from someone ;)
07:28:00 <elliott> now, if I could convince edwardk to direct his talents towards performing necromancy on and then collaborating with the zombie of Erdős, that might be a good trade for future patches
07:28:22 <edwardk> i dont want a zombie erdos on my couch
07:30:19 <XexonixXexillion> Does the GHC RTS depend on posix? Also, can I somehow tell GHC to use a different RTS, or am I going to have to write my own compiler if I write my own RTS?
07:30:53 <bitonic> XexonixXexillion: nothing is stopping you from replacing the RTS with something else with the same interface
07:30:53 <booski> Could you please remind algorithm for generating list of combinations? E.g, n=4,m=3: [(1,2,3),(1,2,4),(1,3,2),(1,3,4),(1,4,2),(1,4,3),...,(4,3,2)]
07:31:20 <elliott> XexonixXexillion: ghc-compiled programs work just fine on windows
07:31:24 <bitonic> XexonixXexillion: and for what concerns POSIX it's definitely not *only* POSIX, since it works on windows too
07:31:36 <ziman> > replicateM 3 [1..4]
07:31:38 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,3,1],[1...
07:31:43 <edwardk> > replicateM 3 [1..4]
07:31:45 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,3,1],[1...
07:32:00 <bitonic> > replicateM 3 [1..4]
07:32:01 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,3,1],[1...
07:32:10 <edwardk> =P
07:32:10 <booski> > replicateM 3 [1..4]
07:32:12 <lambdabot>   [[1,1,1],[1,1,2],[1,1,3],[1,1,4],[1,2,1],[1,2,2],[1,2,3],[1,2,4],[1,3,1],[1...
07:32:19 <booski> Everybody should try !
07:32:25 <bitonic> it works every time
07:32:40 <elliott> edwardk: i like (%) more than (&) by the way :(
07:32:48 <edwardk> elliott: as did i
07:32:53 <nand`> that's not what booski asked, is it?
07:33:04 <booski> It is not
07:33:25 <elliott> compromise with (&%)
07:34:12 <nand`> > map drop $ permutations [1..4]
07:34:13 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
07:34:14 <lambdabot>              with actual type ...
07:34:15 <nand`> oops
07:34:20 <nand`> > map init $ permutations [1..4]
07:34:22 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2],[4,3,2],[3,4,2],[3,2,4],[4...
07:34:50 <nand`> but that isn't generalized
07:36:14 <XexonixXexillion> More importantly, the GHC RTS can't run without an underlying OS can it?
07:36:48 <elliott> XexonixXexillion: take a look at HaLVM
07:36:53 <merijn> XexonixXexillion: Well, there's HaLVM and House
07:36:58 <elliott> http://corp.galois.com/halvm https://github.com/GaloisInc/HaLVM
07:37:11 <merijn> XexonixXexillion: Both of which run haskell code as bare metal (house) or inside Xen (HaLVM)
07:41:11 <dmwit> Yeah, that will create duplicates if m + 1 < n.
07:41:39 <Leif_Bork> Is there somebody I can ask about memory leaks?
07:41:59 <dmwit> booski: Have you tried writing the specialized version where m=1 (and you also return the list of things you *didn't* pick)? It helps a lot. =)
07:42:08 <dmwit> Leif_Bork: Don't ask to ask, just ask.
07:42:55 <Leif_Bork> When I look at the heap profile, what is ghc-prim:GHC.Types.:?
07:43:05 <Botje> Leif_Bork: lists.
07:43:12 <Leif_Bork> Aah!
07:43:24 <Leif_Bork> Damn
07:46:46 <Cale> XexonixXexillion: with some modification, it can.
07:46:56 <robbe-> Hello :-) Can I ask about the haskell emacs mode here? I have a problem with cabal-dev not finding 'ghc'. (cabal: Cannot find the program 'ghc' at 'fake-ghc-cabal-dev' or on the path
07:48:07 <Cale> robbe-: Maybe something has messed with your path?
07:48:17 <Leif_Bork> The ghc 7.4.2 user guide names several RTS options for heap profiling, but many that I can't use, such as -hm and -hy, how can I use them, I can only use -h?
07:48:47 <robbe-> Cale: Would that be my system path, or the paths within emacs? (or both :))
07:48:49 <geekosaur> most profilin options require that you compile with profiling support?
07:49:09 <geekosaur> also the available options may be version speciifc
07:50:12 <robbe-> (getenv "PATH") -> lists ~/.cabal/bin at the end
07:50:23 <Leif_Bork> geekosaur: Yes, but I compiled using profiling support, and the ghc 7.4.2, and am trying to run with RTS options listed in the 7.4.2 guide
07:50:50 <robbe-> Cale: and the exec-path variable also has it at the end
07:50:52 <XexonixXexillion> I'll be honest, I'm just looking for inspiration here as opposed to something I can actually use. My theoretical target is an AVR, and I doubt I'm going to be able to avoid writing my own RTS.
07:51:16 <Cale> robbe-: The important thing is whether the path where your GHC is located is listed. (Presumably that's not ~/.cabal/bin)
07:51:28 <robbe-> Cale: oh, right of course :)
07:51:41 <robbe->  which ghc
07:51:41 <robbe-> /usr/bin/ghc
07:51:48 <robbe-> -> / /usr/bin/ghc
07:51:51 <Cale> hmm
07:52:02 <booski> dmwit: for m = 1 it's just id
07:52:20 <robbe-> And /usr/bin is listed again in both paths.
07:54:08 <Cale> XexonixXexillion: Honestly, when it comes to programming microcontrollers, I would think Haskell makes a better metalanguage than as a language to actually program them directly.
07:54:44 <edwardk> XexonixXexillion: you may want to look into DSLs like atom that already target that sort of environment
07:54:49 <Cale> XexonixXexillion: Have you seen things like Atom?
07:54:52 <Cale> right :)
07:58:19 <Leif_Bork> geekosaur: I had used cabal's -p option, it worked with ghc options -prof -auto-all, for some reason
07:58:34 <XexonixXexillion> Cale: yeah, I've seen Atom (I've even used it). It's not to actually be useful; it's to see if I can do it.
07:59:37 <XexonixXexillion> Also, the atmega328p has a 16mhz processor, which seems to be overkill for just about everything I do, so it doesn't matter how slow it runs
08:01:03 <Cale> XexonixXexillion: are you going to have some interface to external memory? That thing doesn't really have enough memory to hold a GHC-compiled program, by several orders of magnitude.
08:03:58 <XexonixXexillion> Cale: 32kb is plenty, if all the RTS has to do is memory map some devices, handle memory and evaluation of thunks. GHC is not sufficient, nor is NHC, but the RTS I need is far simpler than a normal Haskell RTS
08:04:39 <Cale> If you're going to write your own Haskell compiler (probably for some subset of Haskell), then fine :)
08:05:10 <typoclass> XexonixXexillion: interesting. which RTS do you mean, if it isn't a normal haskell RTS?
08:05:57 <Cale> I don't think it's so easy to separate the GHC RTS and swap it out for something else.
08:06:12 <XexonixXexillion> A normal haskell RTS has to handle interfacing with C, threading, errors and has a more complicated memory management system
08:06:33 <Cale> But maybe...
08:07:49 <Cale> XexonixXexillion: In a way, what you're asking for is not *so* different from the projects to get GHC (and other implementations) to compile to Javascript.
08:08:39 <Cale> (Many things which were IO primitives won't make sense anymore)
08:10:00 <XexonixXexillion> Javascript is a much more difficult problem IMO
08:10:14 <eamon> Hey, I'm looking at Haskell, and I think it's beautiful. What would be a good book to read to learn it?
08:10:14 <edwardk> you do realize that any haskell that can run in 32kb is going to be fairly ridiculously crippled. that is a TINY rts.
08:10:35 <ion> @where lyah
08:10:35 <lambdabot> http://www.learnyouahaskell.com/
08:10:59 <edwardk> you may want to look at the approach taken by jhc or something instead, which is better at unused code elimination by dint of being a whole program optimizing compiler
08:11:04 <typoclass> eamon: hello, welcome. try lyah ^^ it's available free of charge
08:11:28 <edwardk> i can't link hell world even sans RTS in that space =P
08:11:28 <Cale> eamon: Also, feel free to ask lots of questions here as you learn :)
08:11:56 <eamon> Thank you ion and typoclass. How long would it take me, roughly, to get to this level? http://ideone.com/oFjl2W
08:12:03 <quicksilver> I'm pretty sure whole program compilation is absolutely the right choice for a 32K target
08:12:37 <quicksilver> I think the main challenge might be deciding the best way to write your memory management/GC subsystem
08:12:51 <XexonixXexillion> edwardk: I can't do that in Ada either on x86 (the RTS is several hundred kb). I do however have an Ada RTS for AVR that's only 1k. If Ada can shrink the RTS that much; why not Haskell :p
08:13:20 <mcstar> 2 days
08:13:25 <Cale> eamon: That's a tricky question. You can learn everything that's going on in that code in under a week, for sure.
08:13:47 <elliott> eamon: you can understand that code in a week
08:13:54 <elliott> writing it like that to start with might take a bit longer
08:13:54 <edwardk> XexonixXexillion: my point is that ghc will keep whole swathes of libraries it doesn't use in the resulting executable. we suck at whole program optimization, because we want good separate compilation
08:13:56 <typoclass> eamon: depends on how much time you're going to spend. and reading is easier than coming up with something like that. but it seems fairly straightforward :-)
08:14:08 <edwardk> jhc on the other hand often produces vanishingly small executables that look like they were written in c
08:14:38 <XexonixXexillion> edwardk: which is why I'll probably just write my own compiler for it
08:14:39 <eamon> Cheers Cale elliot, and typoclass! I'm going to take the plunge!
08:15:06 <elliott> eamon: have fun :)
08:15:12 <edwardk> XexonixXexillion: sure. just hinting that if you want a good starting point, meacham's work on jhc is probably a better launching off point than ghc's internals ;)
08:15:28 <Cale> > replicate 5 '*'
08:15:30 <lambdabot>   "*****"
08:15:39 <Cale> > intersperse ' ' (replicate 5 '*')
08:15:40 <edwardk> there is also published research on the grin-style intermediate language he uses for optimization
08:15:42 <lambdabot>   "* * * * *"
08:15:44 <XexonixXexillion> edwardk: I'm looking at that too. I'm also looking at NHC, that seems to produce fairly small executables
08:16:05 <Cale> > replicate 3 (intersperse ' ' (replicate 5 '*'))
08:16:07 <lambdabot>   ["* * * * *","* * * * *","* * * * *"]
08:16:34 <Cale> > intersperse (replicate 2 ' ') (replicate 3 (intersperse ' ' (replicate 5 '*')))
08:16:35 <lambdabot>   ["* * * * *","  ","* * * * *","  ","* * * * *"]
08:16:40 <Cale> > concat (intersperse (replicate 2 ' ') (replicate 3 (intersperse ' ' (replicate 5 '*'))))
08:16:42 <lambdabot>   "* * * * *  * * * * *  * * * * *"
08:16:47 <typoclass> > let { widest = 11 } in reverse [0..widest]
08:16:49 <lambdabot>   [11,10,9,8,7,6,5,4,3,2,1,0]
08:17:05 <typoclass> > "lol" ++ "cat"
08:17:08 <lambdabot>   "lolcat"
08:17:16 <typoclass> > [1,2,3] ++ [7,8,9]
08:17:18 <lambdabot>   [1,2,3,7,8,9]
08:17:19 <ion> > intercalate (replicate 2 ' ') (replicate 3 (intersperse ' ' (replicate 5 '*')))
08:17:21 <lambdabot>   "* * * * *  * * * * *  * * * * *"
08:17:37 <mynickname> @help
08:17:37 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:17:38 <XexonixXexillion> Also 32kb is not that crippled. I wrote an entire multithreading operating system for the device in question in 8kb
08:17:46 <mynickname> @list
08:17:46 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:17:49 <edwardk> :t (interspersed, replicated)
08:17:51 <lambdabot>     Not in scope: `interspersed'
08:17:51 <lambdabot>     Perhaps you meant one of these:
08:17:51 <lambdabot>       `intersperse' (imported from Data.List),
08:17:54 <typoclass> eamon: all of this ^^ is aimed vaguely at you, by the way :-)
08:17:58 <edwardk> oh yeah i removed interspersed
08:18:14 <edwardk> typoclass: way to scare the guy =)
08:19:01 <typoclass> edwardk: i didn't once mention the m-word
08:19:07 <typoclass> get off my back
08:19:10 <typoclass> :-D
08:19:13 <XexonixXexillion> typoclass: You mean warm fuzzy things?
08:19:28 <edwardk> heh, sok, soon he'll discover the l-word. =P
08:19:41 <mcstar> whats that?
08:19:47 <eamon> Cheers guys. It's all good!
08:20:26 <mcstar> whats the l-word?
08:20:32 * edwardk fights down a bad Scott Pilgrim joke about the l word being "lesbians" to say 'lens".
08:20:38 <typoclass> XexonixXexillion: yes, warm fuzzy things from an obscure branch of mathematics that rhymes with ategory eory
08:20:45 <mcstar> ah
08:21:36 <mcstar> edwardk: i was thinking of l-azy, but didnt make much sense
08:21:43 <edwardk> mcstar: ah
08:21:51 <mcstar> im not a lens user myself, yet :)
08:22:00 <edwardk> sok, we'll convert you eventually ;)
08:22:31 <rwbarton> i'm currently overusing lenses to get an idea of what they are good/not good for
08:22:40 <rwbarton> "need a function? why not a lens instead?"
08:22:55 <mynickname> > 1+1
08:22:57 <lambdabot>   2
08:23:40 <mynickname> @pl f x y = x + y
08:23:40 <lambdabot> f = (+)
08:24:00 <elliott> I still think a language where everything was a lens-style lens-like would be interesting
08:24:21 <edwardk> we just call that haskell these days ;)
08:24:25 <elliott> haha
08:24:29 <edwardk> rwbarton: hahahaha
08:24:57 * edwardk peeks over rwbarton 's shoulder and sees to foo. to bar . to baz sprinkled all over his code.
08:25:34 <mynickname> @pl f x y z = map x $ map y z
08:25:34 <lambdabot> f = (. map) . (.) . map
08:25:43 <edwardk> rwbarton: i confess i did the same thing, before backing up a little and finding my own personal 'lens boundary'
08:26:07 <elliott> x ^. to a . to b . to c
08:26:15 <typoclass> edwardk: it's called focal point
08:26:20 <elliott> it's better because it's lens
08:26:28 <XexonixXexillion> Because you are all an unbiased bunch; Does modelling a turing tape machine in Haskell sound like a reasonable assignment for first year comp students in their 6th/7th week?
08:26:31 <edwardk> typoclass: =)
08:26:58 <PatrickRobotham> XexonixXexillion: Oh, that sounds like a fun assignment.
08:27:00 <typoclass> beyond the focal point, it all gets fuzzy and divergent and ineffective
08:27:03 <edwardk> XexonixXexillion: if the class has been teaching haskell throughout? yes. its pretty straightforward
08:27:03 <PatrickRobotham> XexonixXexillion: How long do they have to do it?
08:27:09 <rwbarton> who needs lookup k m when there's m^.traverseAt k, etc.
08:27:16 <rwbarton> or ^? rather
08:27:22 <edwardk> m^? at k
08:27:28 <edwardk> or m ^.at k
08:27:46 <edwardk> :t ?m ^.at ?k
08:27:47 <lambdabot> (?m::m v, ?k::k, At k m) => Maybe v
08:27:51 <rwbarton> hmm
08:27:51 <XexonixXexillion> PatrickRobotham: Generally two weeks
08:28:04 <rwbarton> :t ?m ^. traverseAt ?k
08:28:05 <edwardk> at was chosen because its really short and really common ;)
08:28:06 <lambdabot> (?m::m b, ?k::k, Monoid b, At k m) => b
08:28:18 <rwbarton> :t ?m ^. traverseAt ?k . traverseLeft
08:28:20 <typoclass> XexonixXexillion: what would that involve? juggling two lists, a 'data' with the possible commands in it?
08:28:20 <lambdabot> (?m::m (Either a c), ?k::k, Monoid a, At k m) => a
08:28:22 <edwardk> :t ?m ^? traverseAt ?k
08:28:24 <lambdabot> (?m::m b, ?k::k, At k m) => Maybe b
08:28:26 <rwbarton> :t ?m ^? traverseAt ?k . traverseLeft
08:28:27 <lambdabot> (?m::m (Either a c), ?k::k, At k m) => Maybe a
08:28:37 <elliott> I guess the sugar you could have for a "function" is lenslanguage would be (s -> a) --> ({s,s} -> {a,a}) -> ({s,s} ->{Gettable} {a,a}) or something
08:28:38 <rwbarton> is there a better way to write this?
08:28:49 <edwardk> yeah the main use of ^? is because you can use a lot of nested traversals and just get an answer
08:28:55 <elliott> and setter would be ({s,t} ->{Settable} {a,b}) and so on
08:28:56 <rwbarton> because this is what I am really doing, expecting to find particular json types in a json object
08:29:18 <XexonixXexillion> typoclass: The tape is just a zipper, and states are a function from symbol -> (state, direction, symbol)
08:29:20 <edwardk> rwbarton: thats pretty much the intended usage pattern
08:29:22 <rwbarton> ok cool
08:29:33 <dmwit> booski: No, not quite, if (as I said) you *also* return the elements of the list that you *didn't* use.
08:29:44 <edwardk> nested maps kinda suck to update because you have to decide what it means when you empty the inner map
08:29:52 <elliott> ({s,t} {Indexed i}->{Applicative} {a,b}) -- perfect???
08:29:57 <edwardk> do you delete the entry pointing to the empty map or not?
08:30:06 <edwardk> i guess its better with non, now. you could use non empty ;)
08:30:14 <edwardk> :t at 5 . non empty
08:30:16 <lambdabot>     Not in scope: `non'
08:30:16 <lambdabot>     Perhaps you meant one of these:
08:30:17 <lambdabot>       `not' (imported from Data.Bool),
08:31:00 <edwardk> :t at 5 . non mempty
08:31:00 <edwardk> @let non non a = iso (fromMaybe a) go where go b = b <$ guard (a/= b)
08:31:02 <lambdabot>     Not in scope: `non'
08:31:02 <lambdabot>     Perhaps you meant one of these:
08:31:02 <lambdabot>       `not' (imported from Data.Bool),
08:31:03 <lambdabot>  Defined.
08:31:07 <edwardk> @let non a = iso (fromMaybe a) go where go b = b <$ guard (a/= b)
08:31:09 <b__> does error always terminate the process, or could I catch it somehow?
08:31:09 <lambdabot>  <local>:4:1:
08:31:10 <lambdabot>      Equations for `non' have different numbers of arguments
08:31:10 <lambdabot>   ...
08:31:11 <edwardk> @undefine
08:31:13 <edwardk> @let non a = iso (fromMaybe a) go where go b = b <$ guard (a/= b)
08:31:15 <lambdabot>  Defined.
08:31:18 <edwardk> :t non
08:31:21 <lambdabot> (Eq a, Functor f, Isomorphic k) => a -> k (a -> f a) (Maybe a -> f (Maybe a))
08:31:29 <edwardk> :t at 5 . non mempty
08:31:31 <lambdabot> (Eq v, Functor f, Functor (k1 (v -> f v)), Num k, Monoid v, Isomorphic k1, At k m) => k1 (v -> f v) (m v -> f (m v))
08:31:43 <edwardk> :t at 5 . non mempty . at 4 . non mempty
08:31:45 <lambdabot> (Eq v, Eq (m1 v), Functor f, Functor (k2 (v -> f v)), Num k1, Num k, Monoid v, Monoid (m1 v), Isomorphic k2, At k1 m1, At k m) => k2 (v -> f v) (m (m1 v) -> f (m (m1 v)))
08:32:00 <elliott> nice constraint
08:32:05 <edwardk> hah
08:32:11 <edwardk> i may have missed a traverse ;)
08:32:21 <edwardk> :t at 5 . non M.empty . at 4
08:32:23 <lambdabot> (Eq a, Functor f, Functor (k2 (Maybe a -> f (Maybe a))), Num k1, Num k, Ord k1, At k m, Indexed k1 k2) => k2 (Maybe a -> f (Maybe a)) (m (M.Map k1 a) -> f (m (M.Map k1 a)))
08:32:25 <edwardk> :t at 5 . non M.empty
08:32:27 <lambdabot> (Eq k2, Eq a, Functor f, Functor (k1 (M.Map k2 a -> f (M.Map k2 a))), Num k, Isomorphic k1, At k m) => k1 (M.Map k2 a -> f (M.Map k2 a)) (m (M.Map k2 a) -> f (m (M.Map k2 a)))
08:32:55 <yitz> edwardk: in what module is % ?
08:33:09 <elliott> none now :(
08:33:14 <edwardk> yitz: Control.Lens.Getter it gets re-exported by Control.Lens
08:33:19 <yitz> thanks
08:33:33 <edwardk> in head its just (&) now
08:34:46 <edwardk> :t M.empty % at 5 . non M.empty . at "hello" . non M.empty
08:34:48 <lambdabot>     Couldn't match expected type `M.Map k0 a0'
08:34:48 <lambdabot>                 with actual type `a1 -> f0 a1'
08:34:48 <lambdabot>     Expected type: M.Map k0 a0 -> Maybe a2 -> f1 (Maybe a2)
08:35:01 <edwardk> :t M.empty % at 5 . non M.empty . at "hello"  ?~ "there"
08:35:03 <lambdabot> (Num k, Ord k) => M.Map k (M.Map [Char] [Char])
08:35:08 <donri> aww, i liked it as %
08:35:10 <edwardk> > M.empty % at 5 . non M.empty . at "hello"  ?~ "there"
08:35:13 <lambdabot>   fromList [(5,fromList [("hello","there")])]
08:35:17 <edwardk> score
08:35:24 <elliott> edwardk: I don't suppose you had any wonderful insights about how to do zipper stuff with maps nicely
08:35:24 <edwardk> non really fixes up the nested maps problem
08:35:36 <edwardk> elliott: use zipper ;)
08:36:32 <elliott> (in particular re: getting access to the key)
08:36:39 <edwardk> donri: %~. %= etc are still using % its just the % that became &
08:36:59 <donri> yea i wasn't confused
08:37:16 <donri> guess & is less taken than %
08:37:20 <edwardk> i do miss the internal consistency of the other presentation though
08:38:22 <donri> what motivated the change?
08:38:23 <rwbarton> sort of amazing how un-taken & is
08:38:59 <edwardk> donri: avoiding collision with Data.Ratio.%
08:39:11 <edwardk> donri: it was changing the meaning of some golf code here on channel, etc.
08:39:17 <donri> heh
08:39:55 <edwardk> rwbarton: i think it comes down to you tend to want to use & and | together, for and and or, but | is taken by syntax
08:40:01 <donri> CLASSY PRELUDE TO THE RESCUE ok not really
08:40:05 <rwbarton> hmm, sounds plausible
08:40:41 <donri> & is used in optparse-applicative where it used to be >>> and now is <>
08:40:54 <elliott> classyprelude, here to rescue us from meaning
08:40:56 <edwardk> i can live with that collision ;)
08:40:59 <elliott> (ok, i shouldn't engage in such flamebait)
08:41:14 <donri> yea, i don't even use lens and optparse in the same modules
08:41:31 <edwardk> donri: that and the optparse one can be just replaced with mappend or (<>)
08:41:32 <elliott> but what if you want to edit your options structure :)
08:41:38 <edwardk> so its kinda silly
08:42:10 <Cale> Apparently the main reason we have backslash is because of the ability to ascii-art /\ and \/ for 'and' and 'or'.
08:42:15 <donri> yea, but & aligns better with parenthesis than <> :)
08:42:55 <Cale> (when they were sorting out what characters should be in ascii)
08:42:59 <elliott> Cale: and haskell doesn't even take advantage of it!
08:43:37 <donri> elliott: i suppose you could have use cases for that, but the use of & in both doesn't really get in the way in that case anyway
08:43:40 <typoclass> > let (/\) = 2 in 3 -- oh wow, i didn't realize that worked
08:43:42 <lambdabot>   3
08:43:59 <donri> easy enough to use <> with optparse or just $ with lens
08:44:24 <edwardk> well $ with lens flips the reading around when you go from .~ to .= making it a big jump
08:44:31 <donri> let (---) = 2 in 3 --- oh wow
08:44:39 <donri> > let (---) = 2 in 3 --- oh wow
08:44:41 <lambdabot>   <hint>:1:30: parse error (possibly incorrect indentation)
08:44:48 <edwardk> nice comment
08:44:49 <elliott> oh wow, a parse error
08:45:58 <tac> @type oh
08:46:01 <lambdabot>     Not in scope: `oh'
08:46:01 <lambdabot>     Perhaps you meant one of these:
08:46:01 <lambdabot>       `or' (imported from Data.List),
08:46:15 <edwardk> @type 3 -- oh wow
08:46:16 <lambdabot> Num a => a
08:46:53 <donri> > let (---) = (-) in 2 --- 2
08:46:55 <lambdabot>   <hint>:1:27: parse error (possibly incorrect indentation)
08:47:22 <rwbarton> any token of two or more -s begins a comment
08:47:41 <rwbarton> > let (--+) = (-) in 2 --+ 2
08:47:41 <donri> ah yea you need another character
08:47:43 <lambdabot>   0
08:48:06 <Trudko> guys what does in exactly do here et add1 x = x + 1 in map add1 [1,5,7] ? and how can I create function add1 and use it right away?(would be easy if you use javascript as explation)
08:48:23 <donri> > let (--^) = (-) in 2 --^ not your average haddock comment
08:48:26 <lambdabot>   Not in scope: `your'Not in scope: `average'Not in scope: `haddock'Not in sc...
08:48:33 <rwbarton> at least "not" was in scope
08:48:33 <elliott> Trudko: you probably want to read a haskell tutorial like learn you a haskell to get to grips with the basics of things like functions and map
08:48:37 <donri> :)
08:49:26 <rwbarton> javascript doesn't have let ... in ... (afaik?) so the closest equivalent would be to turn it into an application of a function
08:49:41 <Trudko> elliott: I know what is map and what are functions I dont understand 1. What in is exactly doing iin aboewe example
08:49:46 <donri> Trudko: the syntax is, let [local definitions] in [expr with those definitions in scope]
08:49:56 <rwbarton> (function (add1) { return map(add1, [1,5,7]) })(function (x) { return (x+1) }) // DISCLAIMER I don't know javascript
08:50:23 <rwbarton> it's not really the same though since you can make recursive definitions
08:50:32 <nand`> does javascript not have ‘fix’?
08:50:51 <tac> nand`: fix? It's not really the Javascript way of doing things.
08:50:57 <tac> Javascript has cut & paste :P
08:51:10 <hpaste> Thomyho pasted “danke, habe showMat fertig ^^” at http://hpaste.org/77976
08:51:18 <elliott> edwardk: port lens to javascript IMO
08:51:20 <Trudko> rwbarton: so this is just recursive function ?
08:51:21 <rwbarton> well even in Haskell you can't simply rewrite let v = e1 in e2 as (\v -> e2)(e1) if v appears in e1
08:51:24 <rwbarton> it's not recursive
08:51:27 <edwardk> elliott: knock yourself out ;)
08:51:29 <donri> (function(){ var add1 = function(x){return x + 1}; return map(add1, [1,5,7]); })()
08:51:32 <yitz> edwardk: ok ticket created: http://hackage.haskell.org/trac/ghc/ticket/7434
08:51:47 <arcatan> i think JavaScript actually nowadays has let bindings, but not many implementations support them yet
08:52:03 <Trudko> donri: ok so that is eqivalent of the code
08:52:12 <donri> kinda sorta
08:52:35 <edwardk> yitz: i give that about a 30% chance of happening but it'd be nice if it does
08:52:56 <elliott> I give it 80% chance of happening within 4 years of issue comments
08:53:15 <yitz> ok those aren't bad odds actually
08:53:59 <Trudko> donri: so what  what is done is 1. I create function add1 then I return list after I apply function add on it
08:54:04 <rwbarton> the (function (add1) { return map(add1, [1,5,7]) })(function (x) { return (x+1) }) thing is sort of a javascript "idiom" for working around the lack of scoping and let bindings and so on, isn't it
08:54:29 <donri> Trudko: let doesn't create a function in haskell, but it's the only way to simulate local scope in js.
08:54:57 <Trudko> but add1 x = x + 1does right donri?
08:55:03 <donri> ah yea
08:55:08 <rwbarton> "let add1 x = x + 1 in blah" just means that within the scope of blah, add1 is another name for the function that sends x to x + 1
08:56:00 <Trudko> donri what confuse me is that you define function and use it in one line and then return soem value
08:56:02 <donri> > let var = "value" in map toUpper var
08:56:04 <lambdabot>   "VALUE"
08:56:53 <Trudko> the in confuses me why not create var on first line then just do map toUpper var?
08:56:55 <donri> Trudko: yea, in that particular case we'd probably write it differently in both haskell and js. you probably just got that as an example of syntax?
08:57:07 <donri> ah, that's because let can define multiple variables
08:57:12 <donri> just like "var" in js can
08:57:15 <Trudko> donri yes I am going through try haskell examples
08:57:25 <donri> var x = 1, y = 2;
08:57:35 <donri> let x = 1; y = 2 in ...
08:58:00 <donri> the ; can also be a newline, with the y lined up with the x
08:58:10 <Trudko> so by using in you say what is scope for variables?
08:58:23 <donri> so that's why we need the "in", to mark the end of the 'let' bindings
08:58:49 <donri> note that 'let' is an expression
08:59:06 <donri> > 1 + let x = 2 in x + 3
08:59:08 <lambdabot>   6
08:59:41 <yitz> if you want the proposal to be adopted, please subscribe to the ticket, and participate in the discussion on the libraries list. thanks.
09:00:40 <bxx> why can't I use % in here?   data List a = Empty | a % (List a)
09:00:51 <bxx> LYAH used :-:
09:00:53 <rwbarton> infix data constructors start with :
09:01:03 <donri> bxx: % is considered lowercase, and data constructors must start with a capital.
09:01:13 <donri> bxx: : is special cased to be considered a capital.
09:01:35 <donri> except in 7.6 where they broke type operators ^_^
09:02:04 <bxx> ok thanks
09:02:53 <rwbarton> hmm, & is flipped on the numrow from $ on a US keyboard
09:02:56 <donri> so % probably works with ghc 7.6
09:02:59 <rwbarton> can pretend that is the source of the name
09:03:59 <Trudko> donri:  rwbarton ok guys I think understand this
09:04:09 <Trudko> I mean yes I do so thanks :)
09:07:20 <bxx> donri how did they break type operators in 7.6 by the way?
09:07:40 <donri> i'm just being cranky. some would say they fixed them in 7.6
09:08:23 <startling> what was the change in 7.6?
09:08:25 <donri> basically they made all operators be considered upper case in types (hm so maybe % still doesn't work as a data constructor)
09:08:47 <startling> donri: oh, so you can use any operator?
09:09:27 <donri> but i think that's oddly inconsistent with the value level, and it breaks existing code that does things like, Arrow (~>) => a ~> b
09:10:10 <donri> now we have to change such code into the uglier, Arrow arr => a `arr` b, or something.
09:10:54 <startling> can you do `` on type variables? weird
09:11:07 <donri> sure, at least with -XTypeOperators
09:11:15 <bxx_> so ~= can't be used for regex either anymore?
09:11:20 <rwbarton> some of this stuff is covered by extensions, yeah
09:11:27 <donri> bxx_: no it can, that's the inconsistency
09:11:31 <rwbarton> but it is all very natural extension of value-level syntax
09:11:42 <donri> rwbarton: until 7.6 it was, yes
09:11:45 <rwbarton> right
09:12:13 <rwbarton> in haskell 98 i think maybe you can write a `f` b but not data a :% b, or something like that
09:15:01 <geekosaur> h98 doesn't specify the :-is-uppercase hack so there's no way to define an infix constructor
09:17:41 <typoclass> i don't know if that should be called a hack. i think it's halfway towards saying "it's a hack that the first letter decides if it's type or value"
09:19:28 <Cale> donri: There is that clever trick which makes them look like  (Arrow c) => a >--c--> b or similar, but it's still horrible when you have thousands of lines of Arrow code.
09:19:49 <donri> yea seen it, horrible IMO
09:19:51 <quicksilver> geekosaur: h98 does specify : for constructors.
09:20:07 <quicksilver> data Foo a b = a :+: b is valid h98
09:20:16 <bxx_> what does the arrow thing do? first time I see it
09:20:23 <quicksilver> "consym-> (: {symbol | :})"
09:20:50 <Cale> bxx_: Arrow is another abstraction like Monad or Applicative which various combinator libraries fall into.
09:20:53 <quicksilver> but there is no way to do infix types (as distinct from infix constructors)
09:22:46 <Cale> bxx_: Honestly, the Arrow which is in the libraries isn't so useful in its present state imo. But it's pretty close to something which would be very useful. At some point, the other iPwn guys and I should write a paper or something describing what we think Arrow ought to become.
09:23:19 <strebe> Cale: tell me when you've written the paper, assuming you do?
09:23:38 <edwardk> cale: more of a CCC?
09:23:43 <Cale> Basically, it should steal a lot of influence from the definition of a symmetric monoidal category.
09:23:54 <edwardk> *nods*
09:24:03 <Cale> and have explicit left and right associators, swap, etc.
09:24:44 <Cale> and that should be nicely split up into a hierarchy -- it can be useful to have arrows where you can't necessarily "forget" things.
09:25:10 <Cale> (but even if you can, it can be useful to have explicit primitives for that)
09:25:12 <donri> would this make arrow more useful than applicative for more situations than currently?
09:25:20 <Cale> yes
09:25:54 <donri> mm_freak said most of the arrow classes could/should be generalized to just Category
09:26:03 <Cale> Because you get a notation which explicitly represents all the bindings, which can then be analysed fully (or almost fully, if you allow some use of 'arr')
09:26:11 <edwardk> @hackage categories
09:26:11 <lambdabot> http://hackage.haskell.org/package/categories
09:26:42 <startling> yeah, Arrow is kind of weak.
09:27:08 <geekosaur> interesting, I thought I recalled discussion when the :infix thing was added claiming otherwise
09:27:37 <Cale> We also think that the naturality law, that (f *** g) >>> (h *** k) should be required.
09:27:41 <Cale> err, lol
09:27:53 <Cale> (f *** g) >>> (h *** k) = (f >>> h) *** (g >>> k)
09:28:10 <donri> i also heard arrow is slow because of all the tuples. would that still be the case, if it's true that it is now? :)
09:28:21 <Cale> This implies that g and h are not able to communicate with each other in either case.
09:28:38 <tromp__> > 771*36
09:28:39 <lambdabot>   27756
09:28:45 <Cale> donri: It becomes more possible to do something about that.
09:29:21 <Cale> donri: basically, because you can see all the tuple-manipulation, you can construct the code graph explicitly and reduce it in any way that you like before actually running your computations.
09:29:34 <donri> aha
09:29:55 <quicksilver> geekosaur: I think you're probably thinking about infix types, and infix type variables
09:29:59 <Cale> This was a very-involved process for us -- manipulating a typed heterogeneous graph structure is not the simplest thing in the world.
09:30:03 <Cale> But it is possible :)
09:30:10 <quicksilver> geekosaur: which are two different topics from infix constructors.
09:30:16 <quicksilver> geekosaur: it's all a bit confusing to be honest :)
09:31:06 <tibbe> hvr: was it you who suggest that I remove the Partial constructor from cassava or was it shachaf?
09:31:56 <Cale> donri: The main problem with Arrow as it stands is that the proc/do notation (and even the user to a lesser extent) is forced to stick 'arr' in between practically every pair of arrow computations, to rewire things.
09:32:22 <Cale> donri: and every occurrence of 'arr' is a black box which you can't do any meaningful analysis on at runtime
09:32:31 <donri> aha
09:32:44 <donri> and much of the point of arrow was to allow more transparency?
09:32:50 <Cale> right
09:33:16 <Cale> The idea being that since both parameters to (>>>) are of a type you have control over, there's more opportunity for analysis
09:36:14 <Cale> Our custom Arrow preprocessor limits the occurrences of 'arr' to just those cases where you either have expressions to the right of -< and patterns to the left of <- which involve something other than variables and the pair constructor.
09:37:39 <Cale> (and it relies on the law that I mentioned for some simplification of the code that it produces)
09:38:07 <Cale> Kleisli m isn't an Arrow anymore for most monads m in our scheme though.
09:38:34 <Cale> (only commutative monads, of which there are not so many)
09:45:07 <mapf> :t foldr (<|>) empty
09:45:08 <lambdabot> Alternative f => [f a] -> f a
09:45:20 <mapf> some handy combinator for this?
09:45:58 <rwbarton> @hoogle Alternative f => [f a] -> f a
09:45:59 <lambdabot> Data.Foldable asum :: (Foldable t, Alternative f) => t (f a) -> f a
09:45:59 <lambdabot> Control.Monad msum :: MonadPlus m => [m a] -> m a
09:45:59 <lambdabot> Control.Applicative (<|>) :: Alternative f => f a -> f a -> f a
09:46:12 <mightybyte_> tibbe: ping
09:46:19 <tibbe> mightybyte_: pong
09:46:31 <mightybyte_> What's the status on the new sandboxing in cabal?
09:46:37 <mightybyte_> cabal-dev is not cutting it for me
09:46:43 <tibbe> mightybyte_: we're working on it
09:46:51 <mightybyte_> Is the development version useable?
09:46:53 <dcoutts> mightybyte_: it's getting there, in the devel version
09:47:02 <tibbe> mightybyte_: This is the major reminding work item: https://github.com/haskell/cabal/pull/1118
09:47:15 <mightybyte_> I'm just about to create a totally separate user on my computer for each of my projects.
09:47:25 <tibbe> mightybyte_: otherwise there are a few minor refactorings and it should be good to go
09:47:33 <mapf> rwbarton: yep, i can use MonadPlus, thanks
09:47:36 <mightybyte_> So I figured maybe it would be worthwhile for me to be an alpha/beta user.
09:47:41 <typoclass> mightybyte_: i haven't tried them, but there's also one or two alternatives to cabal-dev. one is virthualenv (note h) and the other was called hsenv or something like that
09:47:43 <rwbarton> or asum
09:47:47 <tibbe> mightybyte_: it's dependent on mikhail's time, so send him a lot of fan mail telling him how much this means to you :)
09:48:14 <tibbe> mightybyte_: it works today but you have to use a UI won't be final e.g. cabal sandbox build instead of cabal build
09:48:26 <tibbe> mightybyte_: if you want to try HEAD
09:48:37 <tibbe> mightybyte_: otherwise there will be release candidates eventually
09:48:39 <mightybyte_> Hmmmm, I think I'll give it a shot.
09:48:58 <dcoutts> tibbe: aye, it's good that we're keeping the ui separate for the moment
09:49:24 <tibbe> mightybyte_: so basically you do: cabal sandbox init; cabal sandbox add-source <my local dependecy>; cabal sandbox configure; cabal sandbox build
09:49:33 <tibbe> dcoutts: yes
09:49:42 <tibbe> dcoutts: I'm worried that we gave Mikhail too much work
09:49:46 <tibbe> dcoutts: or unclear work
09:49:55 <dcoutts> tibbe: though on that topic, I think having cabal configure do an install plan, freeze it, and then cabal build just build & install deps into the sandbox, is the way the ui should move
09:50:25 <tibbe> dcoutts: sounds reasonable
09:50:28 <dcoutts> so configure would say: ok configured, and these are the packages that will be installed into the sandbox when you build"
09:50:47 <tibbe> dcoutts: that could be useful, we should think about the UI
09:50:52 <dcoutts> aye
09:51:08 <dcoutts> tibbe: we've got that wiki page to sketch out ideas
09:51:16 <tibbe> dcoutts: in my mind the main entry point for day-to-day development will be just "cabal build" or "cabal test" (as they imply configure). So the message should be clear from that perspective.
09:51:20 <tibbe> dcoutts: right
09:51:29 <mightybyte_> tibbe: Ok, that sounds fine for now.
09:51:34 <tibbe> dcoutts: I'm still trying to make sure this gets out before the end of the year
09:51:34 <yitz> mightybyte_: why in the world would you need to create separate users for your projects?
09:51:45 <mightybyte_> yitz: Because cabal-dev won't work for me.
09:51:56 <dcoutts> tibbe: right, and my cabal build [target] is still moving along
09:51:56 <mightybyte_> It's a poor man's sandboxing
09:52:05 <yitz> mightybyte_: i'm using cabal-dev extensively, for numerous large multi-repo projects at work.
09:52:07 <tibbe> dcoutts: sweet
09:52:10 <rwbarton> isn't there just an environment variable you can use
09:52:18 <rwbarton> monochrom keeps going on about it
09:52:23 <yitz> mightybyte_: never ran into any significant obstacles
09:52:29 <tibbe> dcoutts: I think we need to address some of the despair that has been seen on reddit re. build tools lately
09:52:34 <mightybyte_> yitz: cabal-dev builds things for me, but ghci integration is completely broken for me.
09:52:37 <dcoutts> tibbe: totally
09:52:54 <yitz> mightybyte_: strange, never happened to me.
09:53:13 <mightybyte_> yitz: It gives me "cabal-dev: user error (Warning: cannot determine version of …fake-ghc-cabal-dev ...
09:53:17 <typoclass> yitz: i think it's a ghc 7.6 issue when used with some particular cabal-dev version
09:53:22 <mightybyte_> …when I do "cabal-dev ghci"
09:53:23 <yitz> aha
09:53:41 <geekosaur> I think we determined it was fixed in their repo but not yet released?
09:53:42 <mightybyte_> It's bizarre…seems to work fine for my coworker sitting right next to me.
09:53:52 <typoclass> there's been talk about it in #haskell before. not sure if anyone has a workaround. i *think* i heard somebody has made a fix and pushed it
09:54:03 <typoclass> mightybyte_: compare the ghc versions ...?
09:54:24 <mightybyte_> yitz: I've used cabal-dev before for other large projects and it "worked", but the user experience still sucked.
09:54:45 <yitz> mightybyte_: there are certain executables cabal-dev needs to find. it needs to have a complete set from the same compiler installation.
09:54:48 <mightybyte_> I couldn't do simple things that I do all the time like "ghci src/some/specific/module.hs"
09:54:59 <neutrino_> hey guys, is there something like !! but [a] -> Int -> Maybe a?
09:55:03 <neutrino_> so that i don't get exceptions
09:55:14 <mightybyte_> So even when it was working, it was pretty much unacceptable for my workflow.
09:55:14 <startling> neutrino_: there isn't
09:55:27 <startling> neutrino_: it sucks, I know. :(
09:55:32 <neutrino_> i can write my own
09:55:46 <startling> neutrino_: yeah; lens has a thing too iirc
09:55:47 <johnw> edwardk: ping
09:55:56 <edwardk> pong
09:55:57 <rwbarton> there's a lens for that
09:56:04 <mightybyte_> yitz: THAT is why I'm creating a totally separate user.
09:56:05 <johnw> edwardk: have you seen see
09:56:07 <johnw> http://hackage.haskell.org/trac/ghc/ticket/7434
09:56:13 <johnw> discussion period just opened
09:56:17 <edwardk> johnw: yeah
09:56:19 <johnw> maybe you want to argue for (%)
09:56:22 <typoclass> mightybyte_: the virthualenv thing i mentioned before bills itself as being easier to use than cabal-dev
09:56:26 <edwardk> i have come around to (&)
09:56:33 <johnw> orly?
09:56:36 <dcoutts> mightybyte_: "ghci src/some/specific/module.hs" is more or less what I'm working on now
09:56:45 <rwbarton> edwardk: btw diagrams uses (#) though it's got a different precedence (probably you already know)
09:56:49 <tibbe> dcoutts: getting off shuttle
09:56:56 <edwardk> yeah yitz made a pretty compelling case last night and someone offered up (&) as a good alternative
09:57:06 <dcoutts> mightybyte_: initially cabal build [target], but from there cabal repl [target] is not a big step, and then combine that with the sandboxing we're adding...
09:57:12 <yitz> mightybyte_: you don't need a separate user for that. just make sure that for each sandbox you always use a path that points to the correct ghc with all of its exe's.
09:57:22 <edwardk> rwbarton: we consciously rejected (#) -- it interacts poorly with magic hash and the general lack of space folks use writing lenses
09:57:42 <neutrino_> startling: i don't need lens.
09:57:44 <rwbarton> mmm
09:57:49 <neutrino_> better keep it simple.
09:57:56 <yitz> mightybyte_: you're right that it will be great to get true native sandboxing in cabal though.
09:58:01 <rwbarton> oh right, even lens uses magic hash
09:58:15 <rwbarton> was going to say, maybe not that many people really need lens while they are MagicHashing...
09:58:15 <edwardk> rwbarton: it was necessary to fix some performance issues internally
09:58:41 <edwardk> there is a whole module full of unsafeCoerces buried in lens's guts that make a 50% speed difference on some benchmarks
09:58:43 <edwardk> =(
09:59:00 <startling> neutrino_: that's what you say. :)
09:59:25 <yitz> mightybyte_: byorgey recently suggeste on his blog using GNU stow. haven't tried it, but maybe that will help you. http://byorgey.wordpress.com/2012/11/01/using-multiple-versions-of-ghc-in-parallel-with-gnu-stow/
09:59:49 <johnw> i use stow for lots of things
09:59:49 <rwbarton> @where sicp
09:59:50 <lambdabot> http://mitpress.mit.edu/sicp/ | http://swiss.csail.mit.edu/classes/6.001/abelson-sussman-lectures/ | http://www.vex.net/~trebla/haskell/sicp.xhtml | "Storage and Identification of Cabalized Packages"
10:00:03 <startling> is stow any good? I was kind of suspicious of it
10:00:08 <johnw> yes, it's very good
10:00:14 <johnw> i've used it for maybe 13 years
10:00:17 <mightybyte_> yitz: I don't need multiple versions of ghc.
10:00:17 <ion> stow is very nice.
10:00:54 <yitz> mightybyte_: oh really? then you *certainly* don't need separate users for your cabal-dev sandboxes. just set up your path correctly.
10:00:56 <startling> cool, I'll take a look. :)
10:01:12 <neutrino_> startling: ? :)
10:01:25 <geekosaur> I haven't used stow but I know its inspiration (depot) pretty well, it's a nice package
10:01:26 <mightybyte_> yitz: Yeah, I do…because I'm working on multiple large projects and I don't want them colliding
10:01:42 <yitz> mightybyte_: that's exactly what cabal-dev does.
10:01:55 <yitz> mightybyte_: i'm in exactly that situation too.
10:01:59 <mightybyte_> Yeah, but I've experienced a lot of pain with it thus far
10:02:17 <rwbarton> mightybyte_, what about http://www.haskell.org/ghc/docs/7.4.2/html/users_guide/packages.html#ghc-package-path
10:02:19 <donri> neutrino_: there's one in the safe package i think
10:02:21 <mightybyte_> So it's pretty simple for me to just create a new user on my local system and use it for development.
10:02:22 <startling> neutrino_, lens simplifies a bunch of stuff that doesn't seem like it can simplified. I usually write things and say "yeah I won't use lens" but end up wanted Plated or Isomorphism or head_
10:02:33 <edwardk> startling: =)
10:03:02 <mightybyte_> rwbarton: Yeah, that might be roughly equivalent…but I've already got the new user set up. :)
10:03:04 <yitz> mightybyte_: i can't imagine how that can help you in any way.
10:03:07 <rwbarton> ok fair enough
10:03:18 <edwardk> the plated combinators have turned out to be a goldmine
10:03:41 <mightybyte_> yitz: It lets me use cabal straight-up instead of cabal-dev, virthualenv, or anything else.
10:03:43 <startling> edwardk: yeah, really. I didn't think I understood it, then I realized I had written them all.
10:04:02 <yitz> mightybyte_: the main thing you want to do is to start with a fresh ghc (or HP) installation, install *nothing* except cabal-dev and its dependecies, and then only use cabal-dev.
10:04:21 <johnw> edwardk: how so?
10:04:28 <atriq> edwardk, I need to learn the plated stuff
10:04:32 <yitz> mightybyte_: if you don't always do that, then perhaps one separate user for that workflow would be useful.
10:04:35 <mightybyte_> Yeah, but that means I can't use ghci the way I want to.
10:04:39 <johnw> can you show us a plated example?
10:04:39 <edwardk> :t rewrite
10:04:40 <rwbarton> yitz, do you expect any of this to help with < mightybyte_> yitz: It gives me "cabal-dev: user error (Warning: cannot determine version of …fake-ghc-cabal-dev ...
10:04:41 <lambdabot> Plated a => (a -> Maybe a) -> a -> a
10:05:18 <startling> johnw, it's really useful for tree transformations
10:05:24 <edwardk> rewrite can take a rewrite rule, that, say, matches negated literals in a syntax tree and returns the literal with the negated value, and will apply it recursively over and over from the bottom of the tree up
10:05:27 <yitz> rwbarton: that's just a question of setting up the path correctly. once and for all, if you are only using one ghc.
10:05:36 <mightybyte_> yitz: Out of curiosity, what editor do you use?
10:05:53 <yitz> mightybyte_: mostly emacs, but more and more vim lately
10:05:59 <mightybyte_> Ahh, that might be part of it.
10:06:03 <donri> isn't plated basically like traversable but for monomorphic structures? is that what you call them
10:06:09 <edwardk> rewrite (\ case Neg (Lit n) -> Just (Lit (-n)); _ -> Nothing) ....
10:06:15 <yitz> mightybyte_: why, what are you using?
10:06:20 <mightybyte_> My coworker who is successfully using cabal-dev also uses emacs.  I'm a 10-year vim user.
10:06:26 <johnw> edwardk: if a "free variable" is a variable where you get to plug in any value, then is a "free algebra" an algebra where you get to plug in any operation for the operators of the algebra?
10:06:29 <edwardk> plate provides a traversal of your self-similar children
10:06:34 <mightybyte_> And I do get the impression that Haskell support is a little better in emacs.
10:06:46 <startling> it is.
10:06:49 <johnw> (any compatible operation, that is, just as the free variable needs a compatible value)
10:07:09 <startling> I think emacs people in general like more comprehensive tools than vim people
10:07:13 <yitz> mightybyte_: i don't use the emacs ghci though - only in a regular shell. why should it make a difference? and i do use vim too quite a bit now.
10:07:15 <mightybyte_> Agreed
10:07:23 <edwardk> assume that a free algebra is the algebra you get just by putting together the operations you get and using the laws you get the quotient out what you can say are the same thing
10:07:28 <neutrino_> startling: what do you use Plated, Isomorphism and head_ for?
10:07:35 <neutrino_> donri: hmm nice
10:07:37 <edwardk> :t rewriteOf
10:07:38 <lambdabot> SimpleSetting a a -> (a -> Maybe a) -> a -> a
10:07:49 <mightybyte_> startling: I tried getting some of the vim tools working, but had trouble.
10:07:56 <simpson> edwardk: Ingenious!
10:08:01 <edwardk> you can provide any setter that knows how to find the nested children an expression type and it just works
10:08:05 <mightybyte_> Too bad yi wasn't ready for prime-time last time I tried.
10:08:42 <startling> neutrino_, I'm writing a markdown parser/renderer and a I have a tree-ish structure for Html. Plated gives me tree transforms essentially for free
10:09:09 <edwardk> donri: note, a monomorphic traversable would be different. you could change out the values.. we have a name for a monomorphic traversable.. its 'traversal' ;)
10:09:12 <yitz> startling: i'm definitely not a comprehensive-tools-everything-including-the-kitchen-sink emacs person. so i guess that explains how i can relatively easily glide over to vim.
10:09:19 <edwardk> :t Data.Text.Lens.text
10:09:21 <lambdabot> (Applicative f, Indexed Int k, Data.Text.Lens.IsText t) => k (Char -> f Char) (t -> f t)
10:09:28 <edwardk> :t Data.Text.Strict.Lens.text
10:09:30 <lambdabot> (Applicative f, Indexed Int k) => k (Char -> f Char) (Data.Text.Internal.Text -> f Data.Text.Internal.Text)
10:09:31 <startling> yitz: mhm, understood. I'm really fond of haskell-mode's ghci
10:09:52 <startling> I think most vim people keep a separate shell open while emacs people do it all in emacs, too
10:09:56 <atriq> "My son looks a bit like me, he can put away the plates after dinner now thanks to edwardk!"
10:10:08 <startling> atriq: haha
10:10:17 <yitz> startling: ok. tried it a few times, wasn't willing to put in enough effort to make it worthwhile. regular ghci just works fine for me.
10:10:34 <edwardk> > (("hello","world"),"!!!", 2 :: Int, ()) ^..biplate :: [String]
10:10:36 <lambdabot>   ["hello","world","!!!"]
10:10:43 <edwardk> > (("hello","world"),"!!!", 2 :: Int, ()) ^..biplate :: [Int]
10:10:46 <lambdabot>   [2]
10:10:48 <startling> yitz, the key is C-c C-l. :)
10:11:11 <yitz> @remember atriq My son looks a bit like me, he can put away the plates after dinner now thanks to edwardk!
10:11:12 <lambdabot> Okay.
10:11:17 <edwardk> > "hello"^..uniplate
10:11:19 <lambdabot>   ["ello"]
10:11:39 <ion> yitz: That’s cheating.
10:11:40 <edwardk> the uniplate of "hello" is "ello" because that is the only immedate descedant of String of type String.
10:11:50 <startling> edwardk: heh
10:12:10 <donri> :t (^..)
10:12:12 <lambdabot> s -> Getting [a] s t a b -> [a]
10:12:18 <edwardk> if lambdabot had more interesting recursive data types we could try more plates
10:12:31 <Canar> loooool
10:12:37 <startling> > ""^.plate
10:12:39 <lambdabot>   ""
10:12:46 <startling> > "hello"^.plate
10:12:48 <lambdabot>   "ello"
10:13:12 <edwardk> hrmm it shouldn't see itself
10:13:18 <mightybyte_> dcoutts: So "ghci src/some/specific/module.hs" doesn't work right now with sandboxing?
10:13:21 <edwardk> that looks like a bug in the Plated definition for [a]
10:13:38 <donri> > "hello"^..plate
10:13:40 <lambdabot>   ["ello"]
10:13:42 <startling> edwardk, yeah, shouldn't there be lots of them?
10:13:49 <rwbarton> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate %~ toUpper
10:13:50 <neutrino_> startling: how do you transform your tree?
10:13:51 <lambdabot>   (("HELLO","WORLD"),"!!!",2,())
10:13:51 <edwardk> startling: no, it only gives immediate children
10:13:57 <edwardk> > universe "hello"
10:13:58 <startling> edwardk: oh, right
10:13:59 <lambdabot>   ["hello","ello","llo","lo","o",""]
10:14:18 <rwbarton> edwardk: didn't it not see itself, and then mconcat together the empty list
10:14:28 <rwbarton> > ""^..plate
10:14:30 <lambdabot>   []
10:14:30 <donri> > unwords $ universe "echo"
10:14:31 <johnw> > "hello"^..plate
10:14:32 <lambdabot>   "echo cho ho o "
10:14:33 <lambdabot>   ["ello"]
10:14:35 <edwardk> rwbarton: thats what it did. i didn't see the ^.
10:14:37 <startling> neutrino_, write a Plated instance and then `transform` or `rewrite`
10:15:00 <edwardk> donri: =)
10:15:17 <rwbarton> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate._head %~ toUpper
10:15:19 <lambdabot>   Not in scope: `_head'
10:15:20 <lambdabot>  Perhaps you meant one of these:
10:15:20 <lambdabot>    `head' (imported ...
10:15:43 <startling> :t head_
10:15:44 <lambdabot>     Not in scope: `head_'
10:15:45 <lambdabot>     Perhaps you meant one of these:
10:15:45 <lambdabot>       `head' (imported from Data.List),
10:15:47 <edwardk> _head isn't in scope on lambdabot. iwhere (==0)
10:15:52 <startling> oh
10:15:55 <rwbarton> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate.iwhere (==0) %~ toUpper
10:15:57 <lambdabot>   Ambiguous type variable `i0' in the constraints:
10:15:57 <lambdabot>    (GHC.Classes.Eq i0)
10:15:57 <lambdabot>    ...
10:16:06 <rwbarton> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate.iwhere (==0::Int) %~ toUpper
10:16:08 <lambdabot>   <hint>:1:62: parse error on input `::'
10:16:13 <rwbarton> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate.iwhere (==(0::Int)) %~ toUpper
10:16:15 <lambdabot>   No instance for (Control.Lens.WithIndex.TraversableWithIndex
10:16:15 <lambdabot>               ...
10:16:24 <rwbarton> @type iwhere
10:16:25 <edwardk> it doesn't know you wanted a list
10:16:26 <lambdabot> (Applicative f, TraversableWithIndex i t, Indexed i k) => (i -> Bool) -> k (a -> f a) (t a -> f (t a))
10:16:27 <rwbarton> yeah
10:16:37 <edwardk> _head would be the better version
10:16:41 <rwbarton> well i didn't want a list!
10:16:57 <rwbarton> oh i get it
10:17:01 <rwbarton> that list
10:17:03 <edwardk> _head would be the bettyeah
10:17:25 <Trudko> guys why do I need to surround (a:_) in let (_,(a:_)) = (10,"abc") in a
10:17:40 <rwbarton> @let _head = iwhere (==0) :: Simple Traversal [a] a
10:17:43 <lambdabot>  Defined.
10:17:48 <edwardk> =)
10:17:49 <rwbarton> > (("hello","world"),"!!!", 2 :: Int, ()) % biplate._head %~ toUpper
10:17:52 <lambdabot>   (("Hello","World"),"!!!",2,())
10:17:56 <donri> so, what packages does lens cover? uniplate, zippo, newtype... i guess safe to some extent?
10:18:09 <clahey> > let (_,a:_) = (10, "abc") in a
10:18:11 <lambdabot>   'a'
10:18:15 <edwardk> uniplate, zippo, newtype, data-lens and a lot of the foo-lens packages i'd presume
10:18:25 <donri> well sure the lens packages
10:18:37 <clahey> Trudko: You don't seem to.
10:18:49 <edwardk> well i was thinking in terms of lenses for particular packages that fall under its batteries included purview
10:18:51 <Trudko> clahey: seem to what?
10:19:06 <clahey> Trudko: "guys why do I need to surround (a:_) in let (_,(a:_)) = (10,"abc") in a
10:19:11 <clahey> "
10:19:18 <rwbarton> Trudko: what do you mean "surround"
10:19:21 <clahey> Or did I misunderstand the question?
10:19:28 <Trudko> rwbarton: surround in brackets
10:19:39 <rwbarton> as clahey demonstrated, you don't
10:19:41 <Trudko> > let (_,(a:_)) = (10,"abc") in a
10:19:43 <lambdabot>   'a'
10:19:45 <typoclass> donri: it doesn't cover parts of xmonad-contrib. but other than that ... :-)
10:19:51 <donri> :D
10:20:00 <Trudko> > let (_,a:_) = (10,"abc") in a
10:20:02 <lambdabot>   'a'
10:20:34 <Trudko> so there is nodifference then is it?
10:20:43 <Trudko> i found example with brackets on try haskell
10:20:44 <donri> not in this case no
10:21:02 <donri> but you often do need parenthesis when pattern matching on ":"
10:21:20 <typoclass> Trudko: probably they wrote the parens to be absolutely clear, although you don't need them
10:21:28 <Trudko> ok
10:21:44 <donri> not sure if there's a technical reason for that, though, since as we said earlier ":" is special so you couldn't define an operator like that anyway
10:22:21 <donri> > let a:_ = "hello" in a
10:22:23 <rwbarton> you could write a pattern binding
10:22:23 <lambdabot>   'h'
10:22:24 <rwbarton> yeah
10:22:50 <rwbarton> but "let f a:b = ..." wouldn't make sense even as (:) (f a) b
10:22:56 <donri> > let f a:_ = a in f "hello"
10:22:58 <lambdabot>   <hint>:1:5: Parse error in pattern: f
10:23:26 <donri> > let f (a:_) = a in f "hello"
10:23:28 <lambdabot>   'h'
10:26:20 <dcoutts> mightybyte_: ghci on its own will not work with sandboxing, since you need to pass a whole bunch of flags to set the sandbox
10:26:25 <edwardk> (:) has no funny relationships with ()'s that i know of
10:26:32 <dcoutts> mightybyte_: that's why we're adding cabal repl
10:26:50 <dcoutts> mightybyte_: which basically runs ghci in the right environment
10:27:20 <dcoutts> mightybyte_: it might be possible as a ui for us to do that by making a .ghci file
10:28:26 <donri> cabal-dev ghci ignores $PWD/.ghci which is annoying, but considers $HOME/.ghci even though it imports things not in the sandbox, which is also annoying
10:28:34 <clahey> How is (:) special?
10:28:41 <donri> if you can make this all work magically in cabal repl, that'd be nice ;)
10:28:52 <donri> clahey: it's upper case
10:28:53 <johnw> :t (:)
10:28:55 <lambdabot> a -> [a] -> [a]
10:29:07 <dcoutts> donri: I think we'd probably want to ignore both by default.
10:29:54 <clahey> donri: Gotcha.
10:37:42 <neutrino_> kmb, huh
10:38:08 <neutrino_> looks like someone just rage joinparted
10:38:58 <monsieurlu> hey, I'm looking for great ressources about implementing data structure (linked list, tree, ...) in purly functional language, someone can help?
10:39:18 <rwbarton> @where okasaki
10:39:19 <lambdabot> http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
10:39:26 <johnw> heh
10:39:31 <johnw> i was just about to paste that :)
10:39:47 <monsieurlu> Thanks guys :)
10:41:26 <typoclass> monsieurlu: i think the clojure people have put quite some thought into their data structures as well. i bet they've written about that
10:42:19 <monsieurlu> typoclass: I'll also take a look a it then, thanks for the help
10:47:31 <dropdrive> Hi!  I have a function that takes inputs, computes from filenames, reads data from those files, processes the data, and returns a serializable value (e.g. just a Double).  I would like to modify this function such that (i) the result is cached on disk, so the computation isn't repeated, and (ii) if the files that were opened have changed (say, by comparing size and mtime), then the computation *is* repeated and the new result is cac
10:48:15 <dropdrive> This modification seems pretty generic; are there any existing libs that try to do something like this?  (Or would anyone have pointers to how this might be done?)
10:48:30 <Cale> monsieurlu: When it comes to lists and trees in the case of Haskell, support for constructing those types is built directly into the language. Recursive data declarations will define new types of trees very nicely -- but any additional conditions you want on the values in those trees, you'll need to enforce on your own.
10:48:31 <clahey> dropdrive: That's not a function, which might be an issue.
10:48:45 <dropdrive> clahey: What isn't a function?
10:48:59 <clahey> dropdrive: In haskell, functions can't read from files.
10:49:01 <bgamari> dropdrive, It requires side-effects
10:49:13 <clahey> dropdrive: So you must be creating an IO computation or something like that.
10:49:15 <djahandarie> edwardk, jeez, you just came up with lens recently and it's already swaying core library bikeshedding decisions!
10:49:51 <dropdrive> clahey: I was envisioning something like  g :: (Eq a, Serializable a, Serializable b) => (a -> IO b) -> (a -> IO b)
10:50:04 <Cale> djahandarie: edwardk just implemented lenses very nicely, I'm not sure he'd claim to have invented them...
10:50:31 <djahandarie> I meant the package, of course :)
10:50:36 <Cale> djahandarie: and lenses in one form or another have been swaying bikeshedding discussions for a long time
10:51:09 <dropdrive> clahey: Or, maybe IO is too ambitious, maybe some other thing M would work better there?  g :: (Eq a, Serializable a, Serializable b) => (a -> M b) -> (a -> IO b)
10:51:28 <Cale> dropdrive: Probably (a -> IO b) -> IO (a -> IO b)
10:51:29 <clahey> dropdrive: You definitely need the IO there.
10:51:38 <clahey> Cale: Why?
10:51:42 <Cale> (with conditions)
10:51:46 <Cale> clahey: To set up the cache
10:51:55 <clahey> Cale: That can all happen in the IO b, no?
10:52:07 <Cale> Well, you can join...
10:52:24 <Cale> but you don't want a new cache every time you run the resule
10:52:26 <Cale> result*
10:52:47 <clahey> Cale: Ah, I actually was imagining:
10:53:04 <dropdrive> Cale: Maybe (a -> IO b) -> String -> (a -> IO b) where String is the directory where the cache is?
10:53:16 <typoclass> dropdrive: here is an rwh chapter that describes working with getModificationTime and such. i hope it's not relying on outdated modules. http://book.realworldhaskell.org/read/systems-programming-in-haskell.html
10:53:21 <clahey> CacheName -> (a -> IO b) -> (a -> IO b)
10:53:23 <Cale> dropdrive: That could work.
10:53:26 <Cale> yeah
10:53:26 <edwardk> i really hope we get (&). (|>) would be pretty bad for lens
10:53:29 <clahey> Wait.
10:54:03 <clahey> Why can't it just be:
10:54:04 <dropdrive> I guess I'm just wondering if it's too ambitious to try to transform (a -> IO b) -- it doesn't capture the fact that it only performs reading IO, no writing.
10:54:07 <donri> dropdrive: for the caching part maybe look at acid-state
10:54:13 <Cale> It's not too ambitious at all
10:54:29 <clahey> CacheDirection -> (a -> IO b) -> a -> IO b.  Oh, duh.  parentheses!
10:55:27 <Cale> You may *still* want the extra IO there
10:55:31 <dropdrive> Cale: How would this hof figure out what files "f" is opening and reading?
10:55:43 <typoclass> dropdrive: well, i don't think of it as transforming, i think of it as passing in an IO action which will get run sometime. if you want you could say "callback" or something
10:55:48 <Cale> because that would give you an opportunity to load the cache if it exists, or initialise a new one when it doesn't
10:55:54 <mightybyte_> Good grief, the problems don't quit.  Anyone know why "cabal install gtk2hs-buildtools" fails with "Illegal datatype context"?
10:56:06 <Cale> and not have to do that work for each choice of 'a'
10:56:17 <clahey> Cale: You could still do the exact same thing in the final IO b, no?
10:56:23 <clahey> Hmm, perhaps.
10:56:29 <Cale> mightybyte_: Because you're using GHC 7.6.1?
10:56:34 <Cale> (shot in the dark)
10:56:36 <clahey> Oh yeah, I could see that.
10:56:42 <mightybyte_> Cale: 7.4.2
10:56:50 <Cale> mightybyte_: hmm, let me try
10:57:07 <Cale> I have 7.4.1 presently
10:57:08 <clahey> dropdrive does have an excellent point about not knowing what files "f" is opening and reading.
10:57:26 <Cale> dropdrive: It wouldn't...
10:57:32 <mightybyte_> Cale: Oh, this is a really old cabal.  That might be it.
10:57:55 <dropdrive> Cale: I'm willing to rewrite "f" but I don't know what form it should take.
10:58:00 <Cale> dropdrive: Okay, your message was cut off, so I think I didn't properly understand the second condition.
10:58:37 <rwbarton> basically the problem is like how to implement 'make'
10:58:40 <rwbarton> as i understand it
10:58:41 <Cale> dropdrive: Probably the solution then is to use a new type of computations, similar to what STM does
10:58:53 <Cale> dropdrive: So that you have a way to keep track of file operations.
10:59:18 <sclv_> don't know what peopel are talking about |>~ is a great combinator!
10:59:23 <dropdrive> Cale: Do you think STM-like is the way to go, or Reader-like (sorry, newbie here)
10:59:26 <Cale> rwbarton: Actually, that's an interesting way to look at it -- maybe shake has a ready-made answer to this?
10:59:41 <johnw> sclv_: back away, back away slowly
10:59:44 <sclv_> we can literally program with semaphores!
11:00:11 <Cale> dropdrive: Make it impossible for your users to tell whether or not you're using monad transformers.
11:00:28 <mightybyte_> Cale: That fixed it.  I had installed the latest cabal-install, but hadn't restarted my shell.
11:00:29 <Cale> dropdrive: that's the only thing I would really be concerned with :)
11:00:33 <sclv_> http://flagexpressions.files.wordpress.com/2010/03/semaphore-flag-codes3.jpg
11:00:37 <Cale> mightybyte_: ah
11:00:41 <dropdrive> Cale: I don't know what that means, unfortunately.
11:01:21 <sclv_> |>=, \^~, etc. it will be the world's first language suitable for execution via nautical signals.
11:01:25 <Cale> dropdrive: So, have some new monad -- you might use ReaderT or StateT to construct it, but you ought to wrap it in a newtype anyway.
11:01:55 <Cale> dropdrive: and then provide all the file operations, and not just arbitrary IO actions, because you want to keep track of all the stuff which is going on.
11:02:05 <clahey> And then you have functions for read and write which you implement in terms of IO and state updates.
11:02:11 <Cale> (and if you allow arbitrary IO actions, then you give up that ability)
11:02:12 <clahey> That's a neat neat idea.
11:02:26 <sclv_> bah, my ideas are too advanced for this channel :-P
11:02:35 <dropdrive> clahey: Which part?  (mostly clueless)
11:02:51 <Cale> dropdrive: How familiar with STM are you?
11:03:02 <johnw> sclv_ |> smack
11:03:09 <dropdrive> Cale: I've read the SPJ paper.
11:03:35 <clahey> Cale: So one issue is that you have to remember which files were touched and their dates when you generate the cache.
11:03:38 <dropdrive> Cale: I mean, I can't claim to be able to write STM code, but maybe I could if I had some working STM code to ape off of.
11:03:44 <Cale> dropdrive: Okay, so you know how STM transactions are kind of like IO actions, but you can only do transactional memory reads and writes?
11:03:50 <dropdrive> Cale: Yes.
11:03:59 <clahey> Actually, I suppose that's less of an issue and more of the whole point, eh?
11:04:01 <typoclass> dropdrive: another suggestion -- write a function readCache :: FilePath -> Maybe ComputationResult. then change the function that you already have so that it doesn't do readFile anymore, but readCache. when Nothing, it can compute the stuff and write a cache file. when Just, it doesn't need to do anything much anymore
11:04:37 <Cale> dropdrive: The idea here is to do something similar to that, but instead have operations which affect the filesystem (and maybe not worry about rollback or transactional semantics, but just keeping track of everything which is being touched)
11:04:41 <clahey> typoclass: You mean readCache :: FilePath -> IO Maybe ComputationResult?
11:04:51 <typoclass> erm yes, sure :-/
11:05:07 <clahey> typoclass: Except that you actually need a lot more information than just the file path.
11:05:53 <clahey> typoclass: You need to know all the files that were touched and have a name for the operation.
11:06:03 <clahey> So that you could have different operations for the same files.
11:06:46 <sclv_> more seriously, |> "reads" perfectly well as "into" -- not that I have a real side in this discussion.
11:07:05 <johnw> sclv_: if it weren't for the ?~ and ?= variants, I'd have no issues with |>
11:07:19 <johnw> but having a single character correlate to $ would be nice
11:07:21 <typoclass> clahey: i dunno if i understood the problem description correctly. i thought he had a number of files to process, and each file may have a corresponding cache file with the precomputed result ...
11:07:49 <typoclass> dropdrive: ^^
11:07:50 <sclv_> actually, my only "side" is that more operators will make haskell look even scarier to newcomers
11:08:16 <sclv_> and I've never needed a flipped ($) (and lens is the only case where I could imagine needing it)
11:08:29 <clahey> typoclass: That might be, but if you're writing a general combinator, you should support having multiple inputs to the combinator.
11:08:36 <sclv_> like generally when people define a flipped ($) I think "you're thinking about code wrong"
11:08:58 <dropdrive> Cale: That was very helpful.  So would this sound reasonable: CacheDirection -> (a -> STM' b) -> IO (a -> IO b) where (STM' b) is like (STM FilePath) minus writeTVar?
11:09:02 <edwardk> |> combines terribly with the other conventions from lens. leading to things like <|>= that has nothing at all to do with (<|>)
11:09:04 <johnw> sclv_: you don't have to use operators with lens at all, but that doesn't make it look any less scary
11:09:05 <Cale> dropdrive: So the idea is basically that you'll have this new monad, say FileIO which has operations such as  read :: FilePath -> FileIO String and  write :: FilePath -> String -> FileIO ()  and perhaps some other things, as well as something which makes an ordinary IO action from it: runFileIO :: CacheLocation -> FileIO a -> IO a
11:09:27 <johnw> edwardk: ooh, that's a good point to make on the libraries list
11:09:39 <rwbarton> dropdrive: do you write files or just return a Haskell value
11:09:54 <edwardk> feel free =P
11:10:07 <dropdrive> rwbarton: I would like the initial function to just return a value, but the "decorated" function to write to files *and* return the value.
11:10:16 <rwbarton> write to the cache you mean?
11:10:22 <sclv_> from the new haskell people i interact with, operators are more scary than normal words, no matter how confusing the words might actually be
11:10:27 <dropdrive> rwbarton: Yes, I mean write to the cache.
11:10:30 <edwardk> that and the abomination in the eyes of god and man that is |>= are a large part of why i opted against |> in lens
11:10:35 <sclv_> ditto for single letters vs. longer but no more informative names.
11:10:40 <rwbarton> so then your FileIO really needs only read
11:10:43 <pxp> i have a question about the best way to generate a unique identifier for a record if the code is pure, i realize the identifier concept seems side-effecty which makes me feel like i'm missing something important about how to do this while keeping the pure code pure if anyone has any insight i'd appreciate it
11:10:49 <dropdrive> Cale, clahey, rwbarton: BTW, thanks for all this help -- I've asked this question several times here before :)
11:10:51 <danharaj> sclv_: replace all the dummy variables with pony names
11:10:56 <edwardk> sclv_: hence taking the under utilized & which can be read as &-then or 'and' conversationally =P
11:10:56 <sclv_> i agree that > and < are arguably more overloaded in haskell than &
11:11:02 <typoclass> dropdrive: ok. is the reading of the input file being done in the decorator function or in the computing function?
11:11:24 <dropdrive> typoclass: In the computing function.
11:11:30 <sclv_> i also despise the .andThen convention in e.g. scala
11:12:12 <sclv_> haskell should be like german sentences -- the subject goes at the end.
11:12:30 <Clint> that's not how german sentences work
11:13:00 <typoclass> Clint: no it is, if yoda is talking
11:13:02 <neutrino_> hi
11:13:07 <Cale> sclv_: I don't know about German, but I agree with you about function application.
11:13:10 <Clint> deutsches yoda
11:13:16 <neutrino_> is there a set-like data structure with an Eq instance?
11:13:31 <johnw> sclv_: verb particles often go at the end, but not subjects nor simple present tense verbs
11:13:31 <Cale> neutrino_: Any such structure is going to suck
11:13:36 <johnw> s/particles/participles
11:13:46 <Cale> neutrino_: you might as well use lists
11:13:57 <danharaj> Doesn't Set have Eq a => Eq (Set a)?
11:13:57 <dropdrive> rwbarton: Yes, it seems that FileIO only needs reading.
11:14:01 <danharaj> Or am I misinterpreting the question.
11:14:03 <neutrino_> why Cale
11:14:16 <neutrino_> i need something like a list where the order doesn't matter for equality
11:14:23 <neutrino_> i think a set fits the description nicely
11:14:25 <Cale> neutrino_: I'm thinking you mean something like Set but which uses Eq rather than Ord constraints?
11:14:48 <neutrino_> i need something like a list where [1, 2] == [2, 1]
11:14:59 <neutrino_> and [2, 2] == [2]
11:15:00 <Cale> neutrino_: Because of efficiency. If all you have is an Eq instance, then you're resigned to comparing any new element you insert with every other element in the set.
11:15:42 <neutrino_> i never said i need it to only have Eq instances on the elements
11:15:51 <neutrino_> i want the set itself to have an Eq instance, that's all
11:15:53 <neutrino_> :)
11:15:57 <Cale> Oh, in that case
11:16:02 <Cale> What's wrong with Set?
11:16:14 <neutrino_> yeah i just figured it out that there's something like that :)
11:16:58 <Cale> dropdrive: you know what, you might want to have a look at shake
11:17:02 <neutrino_> i'm not sure if my elements have Ord
11:17:19 <neutrino_> > [["x"]] > [["y"]]
11:17:21 <lambdabot>   False
11:17:26 <neutrino_> i guess they do
11:17:28 <Cale> dropdrive: given that what you're describing is quite similar
11:17:35 <danharaj> [[[Char]]] is an ugly type
11:17:42 <Cale> dropdrive: http://hackage.haskell.org/packages/archive/shake/0.3.4/doc/html/Development-Shake.html
11:17:44 <neutrino_> no it's a nice type
11:17:44 <sclv_> johnw: I stand corrected on German then (but not Haskell :-P). I coulda sworn there was a language with that convention but I can't remember what it is
11:17:49 <neutrino_> i like it
11:18:10 <johnw> sclv_: Persian always puts the verb at the end
11:18:25 <johnw> but I know of no language that moves the subject of the sentence to the end
11:18:40 <dropdrive> Cale: Got it, thanks.
11:18:47 <atriq> I wonder what the next ball-game-changing library will be
11:18:54 <eacameron> What would cause GHCI to give me this? Couldn't match expected type `Data.ByteString.Internal.ByteString' with actual type `ByteString'
11:19:09 <Cale> dropdrive: It's not quite the same, but it already exists :)
11:19:18 <atriq> eacameron, possibly using Lazy rather than Strict ByteStrings?
11:19:22 <johnw> eacameron: you are probably using a lazy ByteString where a strict is needed
11:19:27 <Cale> dropdrive: So depending on what your actual problem is, maybe it can help :)
11:19:46 <dropdrive> Cale: I was hoping to get an instructive exercise out of this, but it seems quite hard and having shake will help :)
11:20:03 <eacameron> atriq: johnw: the library I'm using (Data.Redis) says it just takes ByteStrings...how do I know which version it wants?
11:20:13 <dropdrive> Cale: I feel like maybe if I had the skeleton it would be not too bad to "fill stuff in" but getting the skeleton right seems quite tricky.
11:20:26 <johnw> well, that's a good question...
11:20:31 <Cale> dropdrive: That is almost always the case :)
11:20:46 <johnw> that error does almost always mean that, though
11:20:49 <atriq> eacameron, click the link in the docs, and it should take you to Data.ByteString or Data.ByteString.Lazy
11:20:50 <typoclass> dropdrive: i think it'd clear things up mightily if you could put some code on hpaste :-) along with some comment "this code expects file1, file3, and file17 to be present"
11:21:21 <eacameron> atriq: Ahh...I thought the ByteString interface was backend agnostic...is that possible?
11:21:48 <dropdrive> typoclass: I'll give it a shot -- this was mostly imaginary for now; I have no actual code yet.
11:22:19 <atriq> eacameron, I don't think so
11:22:40 <eacameron> atriq: Thank you!
11:23:00 <atriq> No problem!
11:30:33 <danharaj> edwardk: do you have a package for something like class Foo k where foo :: k a -> Maybe a?
11:31:00 <hpaste> nand` pasted “Cairo incorrect PNG output” at http://hpaste.org/77977
11:31:19 <atriq> danharaj, that... sort of looks like Foldable
11:31:56 <danharaj> except the monoid is always Maybe.
11:32:05 <dcoutts> nand`: you've misunderstood the cairo api I think
11:32:11 <nand`> dcoutts: how so?
11:32:43 <dcoutts> nand`: paint is to fill the region enclosed by the path I think
11:32:50 <atriq> danharaj, that is pretty much just Foldable with e.g., the First monoid
11:33:01 <nand`> dcoutts: I didn't find a more appropriate way to ‘clear the entire surface’
11:33:12 <dcoutts> nand`: there's a fill or something like that I think
11:33:16 <nand`> either way, that's not the issue; at least I don't think so
11:33:37 <taesoo> @help
11:33:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:34:08 <nand`> dcoutts: according to haddock, fill ‘fills the current path according to the current fill rule’
11:34:09 <typoclass> nand`: no idea if it's relevant at all, but i noticed it's ARGB in line 3, but RGBA in line 4. i wonder if that will juggle the channels about
11:34:27 <danharaj> atriq: Foldable is too strong.
11:34:47 <nand`> typoclass: doesn't seem to be; RGBA is the format-independent API for setting colors
11:35:08 <nand`> besides, the channels work as expected
11:35:16 <typoclass> ok right
11:35:19 <lispy> hello
11:35:25 <nand`> the issue is that it outputs 128/0/0 at 50% opacity, instead of 255/0/0 at 50% opacity, when using the PNG backend
11:35:26 <atriq> danharaj, can you give me something in this class I'm tentatively calling Danharaj, but not in Foldable?
11:35:28 <nand`> it does not do this in the SVG backend
11:35:30 <johnw> hi lispy!
11:36:12 <danharaj> atriq: The type `k a -> Maybe a` does not mention a monoid at all.
11:36:20 <danharaj> monoid instance*
11:38:18 <dcoutts> nand`: take a look at the cairo demos, there's several, including ones that show png writing
11:38:33 <dcoutts> nand`: the star and ring, uses setOperator OperatorClear >> paint
11:38:58 <atriq> danharaj, so, what can be a Danharaj but not a Foldable
11:39:25 <rwbarton> nothing because there are Maybe a -> [a] and [a] -> Maybe a -- though they're only inverses of each other in one direction
11:40:02 <dcoutts> nand`: hmm, actually, your code just works for me, now that I actually try it. :-)
11:40:32 <rwbarton> i.e. if I have a Danharaj then I can make a Foldable that always outputs a list of length 0 or 1
11:40:38 <rwbarton> it just might not be the Foldable I expected
11:41:27 <danharaj> I see now.
11:42:16 <dcoutts> nand`: I checked in the gimp, it's colour ff0000 with 50% opacity.
11:42:38 <nand`> dcoutts: interesting
11:42:41 <rwbarton> so while Danharaj's natural transformation f a -> Maybe a is not the same as Foldable's natural transformation f a -> [a], in the "there can be only one" world of type class instances, it sort of is the same
11:44:16 <nand`> dcoutts: I have reason to suspect my image editor is broken
11:44:21 <nand`> http://sadpanda.us/images/1258835-UBN45FK.png <- my output, for sanity reference
11:44:26 <danharaj> Yeah, I was constraining my thought to things that had unique instances of what I wanted, and Foldables generally have many such instances.
11:44:28 <nand`> though it seems brighter in firefox than it would be at 80000/0.5
11:45:02 <rwbarton> that's because firefox displays it on a white background
11:45:05 <rwbarton> not a black background
11:45:11 <nand`> rwbarton: no, my background in firefox is black
11:45:14 <rwbarton> oh well
11:45:23 <rwbarton> "who knows? your environment is weird"
11:45:34 <dcoutts> nand`: oooh, it's just that the image viewer is using white as the background colour
11:45:59 <nand`> dcoutts: my image viewer is using black as background color; mind
11:46:14 <nand`> (but the editor I used to test it was using a checkerboard background; I tested using the eyedropper tool there)
11:46:15 <rwbarton> in eog the background is a checkerboard pattern
11:46:18 <rwbarton> makes it obvious
11:46:37 <clahey> danharaj: What is an example of something that only has one such instance?
11:46:40 <nand`> hmm, I need some sort of utility I can trust, since apparently my image editor must be broken
11:46:46 <dcoutts> nand`: try the gimp
11:46:53 <nand`> I have gimp installed but no idea how to use it
11:47:01 <johnw> you should be able to just open an image file with it
11:47:03 <johnw> using the File menu
11:47:08 <clahey> danharaj: Or one such natural instance, of course.
11:47:14 <danharaj> clahey: Maybe
11:47:36 <danharaj> Either a
11:47:50 <clahey> danharaj: Ah, so you want a generalization of Maybe like Foldable is a generalization of [].
11:47:54 <clahey> danharaj: Ah, interesting.
11:48:10 <johnw> like, Optional
11:48:21 <nand`> johnw: I passed it as a command line option; it did seem to open the file successfully. I selected the ‘eye dropper’ tool from the ‘Tools’ menu and clicked on my color and I now see ‘ff0000’ in the color dialog; but I don't see the alpha listed anywhere
11:48:31 <nand`> (though I guess that means it's at ff0000/0.5)
11:48:36 <rwbarton> I feel like removing the type class language here would be helpful
11:49:45 <edwardk> danharaj: no
11:49:52 <Saizan> here?
11:49:57 <rwbarton> relating to danharaj
11:50:35 <nand`> johnw: oh, I found a workaround; I'll use Inkscape
11:55:05 <rwbarton> has anyone used cgen? "cgen parses C++ headers and generates C wrappers and Haskell bindings to a C++ library"
11:56:26 <sclv_> how do i query preflex again
11:56:36 <johnw> rwbarton: never heard of it
11:56:37 <edwardk> given the way the (&) conversation is going on libraries@ why do i get the impression we're going to get railroaded into using (|>) =(
11:57:08 <johnw> edwardk: maybe we should all be using -: because LYAH used it ;-{
11:57:11 <danharaj> is & a new member to the lens operator soup?
11:57:33 <sclv_> i'm avoiding seriously weighing in
11:57:34 <edwardk> danharaj: we renamed (%) to avoid tromping Data.Ratio. it actually works better
11:58:02 <danharaj> That is entirely reasonable.
11:58:03 <edwardk> he funny thing is until i actually wrote a lot of lens code with it i too was in favor of (|>)
11:58:05 <sclv_> but i have no idea why tibbe is suggesting that |> is a "standard operator for function composition" and comparing it to "." when it is clearly an operator for *application*
11:58:39 <atriq> I've never seen it for application
11:58:44 <edwardk> swapping all that code to (%) made it much more pleasant in the large
11:58:48 <atriq> To me it's a snocing operator
11:59:05 <sclv_> i mean the operator that we're discussing
11:59:05 <edwardk> atriq: its application in some ml dialects like f#
11:59:19 <sclv_> be it & or |> or <#$%%%#$>>=~
11:59:27 <sclv_> the signature is application, not composition
11:59:35 <edwardk> bah <#$%%%#$>>=~ collides with lens ;)
11:59:41 <sclv_> so it has nothing to do with "."
11:59:49 <edwardk> sclv_: i agree
12:00:08 <edwardk> its analogue is $. right there 3 characters over from & ;)
12:00:17 <sclv_> and since I am opposed to application on principle (since it does not form a category) then I don't think it needs an operator at all :-P
12:00:19 <sclv_> *ahem*
12:00:24 <danharaj> Although I tend to find a use for every lens operator I look up, I still feel queasy about their proliferation :P
12:00:37 <edwardk> danharaj: i've been shrinking the set actually
12:00:42 <edwardk> 3.4 dropped about 20 of them
12:00:43 <atriq> edwardk, when I'm just messing about, I define it as (), but that alienates anyone without a UK keyboard
12:00:51 <efie> why has last :: Vector a -> a cost of O(n)? I thought if length and (!) have costs of O(1), last should have so as well
12:01:12 <edwardk> atriq: when someone wrote & on channel as a proposal the first time i just assumed they'd written £ and paid it no heed
12:01:19 <nand`> sclv_: (&) :: (() -> a) -> (a -> b) -> () -> b -- what's the problem?
12:01:27 <sclv_> I actually suggest pound sterling to paul for ermine. We currently use something insane like I think ~
12:01:37 <sclv_> as an alias for ($)
12:01:54 <sclv_> since "$ confuses people since they expect it to have to do with money"
12:02:18 <danharaj> is !> taken?
12:02:34 <sclv_> i'm all for more exclamation marks in my code!
12:02:37 <danharaj> (yes I am being silly)
12:02:44 <sclv_> but ! is overloaded to mean "set" typically
12:02:48 <johnw> :t (!)
12:02:49 <lambdabot> Ix i => Array i e -> i -> e
12:02:57 <sclv_> or index
12:03:20 <danharaj> It is clearly a dripping pipe.
12:03:26 <sclv_> indexing ! into ! nested ! arrays ! is ! exciting !
12:03:31 <edwardk> the main utility of (&) was that it was shorter than anything else equivalently unencumbered, and | is already syntax so its unpaired
12:03:54 <nand`> sclv_: complete^.ix and.ix utter.ix nonsense
12:04:26 <nand`> wasn't there some language that ends everything with ‘ix’?
12:04:39 <sclv_> greek?
12:04:59 <danr> I'm trying cabal install darcs using 7.6.1, and I get this error: http://hpaste.org/77978, any suggestions how to resolve it?
12:05:19 <k00mi> nand`: asterix and obelix ;)
12:05:24 <atriq> nand`, Asterix-gallic
12:05:24 <nand`> k00mi: exactly!
12:05:26 <neutrino_> in a listcomp i can do xs = [x | x <- ys, x == 2]. How can I do the x == 2 test in a do block?
12:05:50 <sclv_> ?ty guard
12:05:51 <lambdabot> MonadPlus m => Bool -> m ()
12:05:54 <danr> neutrino_: do { x <- ys; guard (x == 2); return x }
12:06:00 <neutrino_> thanks
12:06:12 <neutrino_> is guard applicable to every monad?
12:06:19 <danr> any MonadPlus
12:06:34 <neutrino_> oh
12:06:38 <neutrino_> why does it need Plus?
12:06:45 <neutrino_> @hoogle guard
12:06:46 <lambdabot> Control.Monad guard :: MonadPlus m => Bool -> m ()
12:06:46 <lambdabot> Language.Haskell.TH.Syntax data Guard
12:06:46 <lambdabot> Language.Haskell.TH data Guard
12:06:47 <sclv_> :i MonadPlus
12:06:48 <danr> well it is basically a Monoid interface for kinds * -> *
12:07:12 <neutrino_> no idea how to understand this.. sorry
12:07:13 <danr> it needs the mzero, which is [] for lists (and Nothing for Maybe)
12:07:32 <sclv_> you need a good notion of failure (beyond Monad's "fail" which shouldn't really be there)
12:07:42 <neutrino_> what does it need the mzero for?
12:07:51 <danharaj> for when all alternatives fail
12:07:55 <atriq> neutrino_, to cull alternative paths
12:07:56 <danr> if the guard evaluates to true, it returns () in the monad, otherwise it returns mzero ([] or Nothing for the said monads)
12:08:32 <neutrino_> what happens when () is returned?
12:08:42 <neutrino_> does the do block continue processing further lines?
12:09:44 <Grahack> hi there, can the Pole (with birds landing on it in balance) in Learn You A Haskell be seen as a State and Maybe monad ?
12:09:55 <danr> neutrino_:  if you think about lists an non-determinism, it just puts a dummy value in there so that branch can continue. remember that the do block desugars to guard (x == 2) >> return x
12:10:36 <neutrino_> how would i think about lists as non-determinism?
12:10:36 <singpolyma> I'm binding to some C++ with the FFI, but when linking with ghc I need to add -lstdc++  is that the normal way to do that, or is tehre a better one?
12:10:54 <danr> neutrino_: do you realize the difference between [] >> return 1 and [()] >> return 1
12:11:10 <neutrino_> hmm
12:11:13 <neutrino_> no, i do not
12:11:25 <neutrino_> i see they're different but i don't actually know what either of them does
12:12:09 <danr> neutrino_: well as list comprehensions, they are [ 1 | _ <- [] ] and [ 1 | _ <- [()] ], respectively
12:12:15 <mpu> neutrino_, a MonadPlus is a Monad that has the ability to fail.
12:13:31 <startling> neutrino_, a list is a computation with many answers
12:14:01 <neutrino_> danr: what does the 1 do there?
12:14:33 <startling> > [ 1 | _ <- [()] ]
12:14:35 <lambdabot>   [1]
12:14:44 <neutrino_> mpu: that's a good way to look at it, thanks for the insight.. but i still don't understand danr
12:14:47 <neutrino_> :)
12:14:49 <startling> > [ 1 | _ <- [] ]
12:14:51 <lambdabot>   []
12:15:11 <neutrino_> oh, i didn't notice the 1 in danr's previous code
12:15:31 <neutrino_> now i see that they're in the comprehensions.. hmm
12:15:41 <neutrino_> oh ok, now i see what's going on
12:16:16 <startling> read it as "1 for each element in [...]"
12:16:26 <neutrino_> yeah
12:16:30 <neutrino_> i know list comps well
12:16:38 <startling> k
12:18:09 <mpu> [ f a b c | a <- as, b <- bs, c <- cs ] is the same as do { a <- as; b <- bs; c <- cs; return f a b c }
12:18:25 <neutrino_> yeah i know that
12:18:27 <neutrino_> thanks :)
12:18:34 <mpu> (is it the same in terms of performance, though)
12:18:39 <mpu> ?
12:19:02 <neutrino_> i thought those were exactly the same after desugaring
12:19:15 <shachaf> mpu: well, no, you have to add parentheses.
12:19:23 <shachaf> Beyond that, try it out and see.
12:19:28 <shachaf> Who knows how GHC compiles things?
12:19:29 <mpu> sure
12:19:30 <chris___> hi, i'm chris
12:19:38 <atriq> Hey, chris___
12:21:00 <neutrino_> hi
12:22:20 <mpu> What happens when a pattern matching in a monad (some thing like 'Just x <- blah') fails?
12:22:30 <shachaf> It turns into fail.
12:22:32 <shachaf> See the Report.
12:22:38 <neutrino_> the same as in a non-monad
12:24:27 <neutrino_> with hunit and test-framework is there a way to run just one test case?
12:27:17 <startling> neutrino_, no, it's not the same as in a non-monad
12:27:31 <startling> > let Just x = Nothing in x
12:27:33 <lambdabot>   *Exception: <interactive>:3:5-20: Irrefutable pattern failed for pattern Da...
12:27:40 <clahey> neutrino_: In a non-monad it turns into error.
12:27:46 <clahey> No?
12:28:03 <startling> > do { x <- Nothing; return x }
12:28:05 <lambdabot>   Nothing
12:28:07 <danr> mpu: regarding performance vs list comprehensions and do notation: http://www.reddit.com/r/haskell/comments/oolyt/why_are_guards_in_the_list_comprehension_faster/
12:28:20 <mpu> danr, thanks
12:28:49 <danr> mpu: the tldr is that list comprehensions are faster because they use foldr/build fusion whereas do-notation is translated to concatMap which is slower
12:29:00 <neutrino_> startling: ohh
12:29:02 <clahey> > do { Just x <- Just Nothing; return x } :: Maybe Int
12:29:03 <lambdabot>   Nothing
12:29:23 <clahey> I think that's a more relevant statement.
12:29:27 <clahey> > do { Just x <- Just Nothing; return x }
12:29:27 <neutrino_> what about a Monad which is not monadPlus?
12:29:28 <lambdabot>   Nothing
12:29:33 <neutrino_> MonadPlus
12:29:52 <clahey> Huh, maybe I'm misunderstanding something.
12:29:55 <startling> neutrino_, it uses `fail`, which is part of Monad.
12:30:04 <clahey> > do { Just x <- Just 5; return x }
12:30:05 <lambdabot>   No instance for (GHC.Num.Num (Data.Maybe.Maybe b0))
12:30:06 <lambdabot>    arising from a use o...
12:30:06 <rwbarton> clahey: for Maybe, fail _ = Nothing
12:30:10 <clahey> > do { Just x <- Just (Just 5); return x }
12:30:12 <lambdabot>   Just 5
12:30:12 <startling> > fail :: Maybe Integer
12:30:13 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
12:30:14 <lambdabot>                             ...
12:30:38 <neutrino_> startling: sure, but what does fail do in a monad which isn't plus?
12:30:49 <geekosaur> whatever the monad defines it to do
12:31:02 <neutrino_> what's a good example of a monad without plus?
12:31:14 <danr> neutrino_: state, reader
12:31:16 <clahey> rwbarton: I thought there was something more complicated going on.  I forgot that it can tell the Monad type because of the type I was pulling from into the <-
12:31:23 <geekosaur> most define it to throw an exception because there's rarely anything else sensible to do (and htis is one of the reasons some of us dislike fail being in Monad at all)
12:31:26 <neutrino_>  aha
12:31:27 <clahey> :t do { Just x <- Just Nothing; return x }
12:31:28 <lambdabot> Maybe b
12:31:35 <startling> neutrino_: the default is error/undefined/whatever iirc
12:31:42 <neutrino_> what happens in state?
12:31:50 <clahey> fail :: Either String Int
12:31:59 <clahey> > fail :: Either String Int
12:32:01 <lambdabot>   Couldn't match expected type `Data.Either.Either
12:32:01 <lambdabot>                           ...
12:32:07 <startling> :t fail
12:32:08 <lambdabot> Monad m => String -> m a
12:32:13 <startling> oh right
12:32:14 <clahey> > fail "Hello" :: Either String Int
12:32:16 <lambdabot>   *Exception: Hello
12:32:23 <clahey> > fail "Hello" :: Maybe Int
12:32:25 <lambdabot>   Nothing
12:32:25 <neutrino_> gotcha
12:32:30 <danr> > runState (fail "boo") ()
12:32:31 <neutrino_> Either is a monad without plus too, right?
12:32:32 <lambdabot>   *Exception: boo
12:32:37 <clahey> > fail "Hello" :: IO Int
12:32:39 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Int))
12:32:39 <lambdabot>    arising fro...
12:33:27 <neutrino_> thanks for the examples
12:33:47 <clahey> Is there any way to tell lambdabot to run an IO?
12:34:18 <clahey> It makes me sad that fail :: String -> Either String Int can't be Left.
12:34:19 <ziman> hopefully not ;)
12:34:30 <clahey> ziman: Touché.
12:34:41 <clahey> Prelude> fail "Hello" :: IO Int
12:34:41 <clahey> *** Exception: user error (Hello)
12:34:54 <fmap> fail as a part of Monad makes me sad
12:35:19 <clahey> fmap: Touché.
12:35:49 <clahey> fmap: What's the generally accepted alternative?  Have do require MonadZero?
12:36:20 <johnw> rwbarton: cgen looks interesting
12:36:38 <shachaf> clahey: It should make you happier than all the alternatives.
12:37:22 <clahey> shachaf: Having do require MonadZero would probably make me least sad.
12:37:44 <rwbarton> johnw, I want to extract some enum values from C++ header files
12:37:45 <clahey> shachaf: It's too bad do can't take either a MonadFail or a MonadZero.
12:38:08 <rwbarton> I'm also considering extracting them from DWARF tags
12:38:15 <roadfish> What is the "<-" thing actually called? I want to search on it but google seems treats "<-" as an empty string.
12:38:23 <shachaf> It's just an arrow.
12:38:35 <shachaf> @hoogle <-
12:38:35 <rwbarton> try hoogling it
12:38:36 <lambdabot> keyword <-
12:38:37 <johnw> > ala Endo foldMap [(+1),(+2),(+3)] $ 3
12:38:38 <lambdabot>   Not in scope: `foldMap'
12:38:39 <lambdabot>  Perhaps you meant one of these:
12:38:39 <lambdabot>    `Data.Foldable....
12:38:42 <shachaf> roadfish: http://haskell.org/hoogle/
12:38:44 <johnw> > ala Endo Data.Foldable.foldMap [(+1),(+2),(+3)] $ 3
12:38:46 <lambdabot>   Couldn't match expected type `s0 -> f s0'
12:38:46 <lambdabot>              with actual type `Da...
12:38:51 <geekosaur> more generally http://symbolhound.com
12:39:05 <shachaf> > ala _endo Data.Foldable.foldMap [(+1),(+2),(+3)] 3
12:39:07 <lambdabot>   9
12:39:09 <geekosaur> but hoogle and hayoo for haskell specifics
12:39:10 <johnw> heh
12:39:13 <johnw> :t _endo
12:39:15 <lambdabot> (Functor f, Isomorphic k) => k (Endo a -> f (Endo b)) ((a -> a) -> f (b -> b))
12:39:23 <shachaf> Easy!
12:39:30 <johnw> :i _endo
12:39:43 <johnw> where is _endo from?
12:39:48 <shachaf> lens
12:39:57 <johnw> huh, I thought I had lens always imported into my ghci
12:40:08 <shachaf> Data.Monoid.Lens?
12:40:15 <rwbarton> > ala _sum (foldMapOf both) (1,1)
12:40:16 <shachaf> Hayoo would find it.
12:40:18 <lambdabot>   2
12:42:06 <roadfish> lambdabot lambdabot
12:42:28 <shachaf> > let endoOf l = appEndo . foldMapOf l Endo in endoOf traverse [(+1),(*2)] 5
12:42:31 <lambdabot>   11
12:42:42 <shachaf> @let endoOf l = appEndo . foldMapOf l Endo
12:42:45 <lambdabot>  Defined.
12:42:53 <neutrino_> man, contravariant coordinate systems are so annoying.
12:44:22 <uniquenick> is there a way to re-export a whole module you imported, or do you have to export all the things in it one by one?
12:45:15 <sclv_> yes -- you can just add the module itself to your export list as i recall
12:45:26 <shachaf> module Blah (module Foo, ...)
12:45:57 <edwardk> neutrino_: move to my covector monad =P
12:47:05 <neutrino_> edwardk: naw
12:47:20 <neutrino_> i'm better off not using your devilish ways
12:47:25 <edwardk> =)
12:47:39 <sclv_> :t ala
12:47:40 <lambdabot> Simple Iso s a -> ((s -> a) -> e -> a) -> e -> s
12:47:41 <neutrino_> type errors that i have to scroll through are unwelcome in this town
12:47:58 <sclv_> haha yes that ala is the lens ala, not the newtype ala, hence the confusion
12:48:33 <edwardk> :t ala _endo foldMap
12:48:35 <lambdabot>     Not in scope: `foldMap'
12:48:35 <lambdabot>     Perhaps you meant one of these:
12:48:35 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
12:48:41 <edwardk> :t ala _endo Data.Foldable.foldMap
12:48:43 <lambdabot> Data.Foldable.Foldable t => t (b -> b) -> b -> b
12:49:42 <uniquenick> so, I do an "import qualified Herp.Derp.Foo as Foo" and then put "module Foo" in my export list, but I get a warning that "export item module Foo exports nothing"
12:51:57 * hackagebot happstack-foundation 0.3.0 - Glue code for using Happstack with acid-state, web-routes, reform, and HSP  http://hackage.haskell.org/package/happstack-foundation-0.3.0 (JeremyShaw)
12:52:40 <johnw> edwardk: i'm trying to fight for (&) as best I can!
12:52:57 <edwardk> =)
12:53:10 <johnw> just posted again
12:53:24 <edwardk> we'll see. i figure the preoponderance of people who will just go with (|>) by precedent will overwhelm us people who actually use the operator =P
12:53:31 <johnw> it's starting to feel very bike-sheddy, though, and for some reason people are losing sight of &'s main consumer
12:53:39 <edwardk> er by precedent
12:53:56 * geekosaur not really fond of any of them but thinks & is the least obnoxious/most general
12:54:01 <johnw> there's no authority in these matters, right?  it's just majority rule?
12:54:10 <edwardk> pretty much
12:54:13 <geekosaur> johnw, who do you see as the main consumer?
12:54:13 <johnw> geekosaur: then come cast your verbal vote
12:54:17 <johnw> geekosaur: lens
12:54:21 <geekosaur> I already did comment on the thread
12:54:29 <johnw> we're only discussing this issue because of lens
12:54:40 <johnw> otherwise, the Haskell world has been happy to live with &/|> for like 20 yearso
12:54:41 <geekosaur> right, that was a bit of a leading question actually
12:54:50 <johnw> without*
12:54:51 <geekosaur> if all you care about is lens then why bother with a libraries proposal?
12:55:01 <johnw> because this operator has general use
12:55:10 <johnw> i just want to see its main consumer get due consideration
12:55:22 <johnw> &= is dead sexy
12:55:24 <geekosaur> but if it is general then lens is not a privileged consumer
12:55:39 <johnw> it's general, yes, but with prior art
12:55:51 <edwardk> whats worse to me is lens consciously rejected (|>) for all of the reasons i raised, so if we go to (|>) we'll have switched the operator out 3 times, just to come back to one that is longer than the ones we used and which makes user code more verbose and to my eyes, less readable
12:55:55 <geekosaur> can't have it both ways, if you want lens to be privileged then it doesn't really belong in libraries territory
12:56:05 <edwardk> johnw: i'm still sticking to %= for the mod-equals conntation
12:56:12 <johnw> geekosaur: i don't want lens priveleged, I want the discussion to not _ignore_ lens
12:56:15 <kranius> is there a "table of operators" for Haskell
12:56:33 <johnw> kranius: operators in Haskell are just functions, so that wouldn't really be of much use
12:56:43 <edwardk> geekosaur: i don't consider lens privileged in this regard, but operators get created to be used, and its the single biggest example of what it looks like when used in earnest
12:56:47 <johnw> the core operators, which are not from Prelude, are incredibly small
12:56:49 <geekosaur> (mind, I do prefer &, but there is reason behind those arguments.  if you are going with libraries then you are *giving up* lens's preferences
12:57:10 <edwardk> geekosaur: the arguments i stated in the discussion aren't lens-centric.
12:57:29 <sclv_> right. but johnw's posts are bending that way
12:57:31 <edwardk> the _insights_ from lens i think are valuable. that it has to have low fixity, etc.
12:57:33 <sclv_> which i think is not-helpfull
12:57:36 <sclv_> helpful even
12:57:36 <johnw> geekosaur: we're picking an operator.  Rather than having that choice be arbitrarily based on what people thinks looks pretty on their screen, let's consider the semantics of existing code that heavily relies on said operator
12:57:58 <johnw> sclv_: uh oh, am I hurting the case for &?
12:58:09 <edwardk> but i already had to give up consistency with %=, etc. so i figure the |>= argument has aready flown.
12:58:15 <sclv_> lens is cool and picking up momentum, but is super-new. so even if one expects it to be big, you really can't make that case on libraries
12:58:24 <johnw> edwardk: your comment about <|> and |> had merit
12:58:26 <sclv_> i don't think its hurting the case, but it is an argument that will be dismissed
12:58:39 <edwardk> sure, but its not the argument i'd use to sell it to libraries ;)
12:58:50 <johnw> sclv_: i see what you mean
12:58:54 <johnw> sclv_: i'm new to libraries
12:58:58 <sclv_> most voices with weight on libraries have never used lens
12:59:03 <geekosaur> that;s what I was trying to say
12:59:03 <sclv_> and really won't care
12:59:20 <Gurragchaa> I wish tryhaskell.org had more lesson
12:59:22 <Gurragchaa> lessons*
12:59:28 <edwardk> i'd rather focus on the real cost of a more verbose operator than on some lib that most of the folks there will never have used or seen and by its very name they'll dismiss as equivalent to something they think they already know
12:59:53 <johnw> edwardk: ok, i'll stop selling the "lens as victim of |>" argument then
13:01:04 <edwardk> yitz pushed ahead with proposing & for Data.Function. i am able to separate myself from my own lib enough to be happy if it gets in in any form, even as regrettable as (|>), but i'm also opinionated enough that i feel duty bound to fight the good fight for the better solution, in spite of the existence of the (|>) precedent in some ml dialects
13:01:24 <sclv_> My read of the list is at this point either the & crowd capitulates or nothing happens... but mainly I'd just give it a day to see what other people say
13:01:31 <sclv_> like i feel the main arguments on both sides have been made
13:01:48 <hiptobecubic> I'm late to this, but why is (&) better than (|>) ?
13:01:49 <rwbarton> if (|>) gets in would you define (&) in lens?
13:01:58 <sclv_> yep you can always do that!
13:02:05 <sclv_> & is shorter is all
13:02:06 <drchaos> How do I specify a function that takes a list of type a and an Integral of type b?
13:02:10 <sclv_> and composes better in compound operators
13:02:21 <drchaos> oh, and a result of type c
13:02:21 <sclv_> since > and < get used for lots of things with lifting already
13:02:26 <simpson> drchaos: Homework?
13:02:42 <sclv_> what is an Integral of type b?
13:02:43 <drchaos> it's not homework
13:02:53 <drchaos> sclv_: type b is a typeclass
13:03:03 <sclv_> foo :: Integral b => [a] -> b -> c
13:03:07 <rwbarton> @quote rwbarton type.class
13:03:07 <lambdabot> rwbarton says: A type class is not a type just like a dog house is not a dog.
13:03:19 <sclv_> quoting yourself :-P
13:03:19 <simpson> Well, the signature would look like Integral b => [a] -> b -> c
13:03:23 <tac-tics> Gurragchaa: we can make you a lesson if you want :P
13:03:34 <mcstar> i typed in the Blog yesod example
13:03:38 * shachaf agrees with Gábor that (&) reads better as composition.
13:04:04 <shachaf> edwardk: What would you think of (|>) for flip ($) and (&) for flip (.), actually?
13:04:12 <shachaf> foo |> zipper & ... & ... & rezip
13:04:28 <shachaf> Assuming the infixity could be made to work.
13:04:31 <johnw> but you have >>> already
13:04:40 <shachaf> That way (zipper & ... & rezip) is its own function.
13:04:44 <arbn> Hmm. There's been a lot of talk about what symbols to use for what lately. :P
13:04:46 <edwardk> johnw: >>> has the wrong fixity to work with that
13:04:51 <johnw> oh
13:04:56 <Gurragchaa> tac-tics: a lesson on Monads would be incredibly useful
13:04:58 <shachaf> Also (>>>) is too long.
13:05:13 <edwardk> shachaf: its cute, but it suffers the same problem that long chains of (.)'s have with inlining.
13:05:26 <sclv_> if i design a language it will have no user-definable operators. it will be a poorer language for it, but have a more enjoyable community.
13:05:33 <tac-tics> Gurragchaa: you know about Real World haskell, right? http://book.realworldhaskell.org/read/io.html
13:05:43 <rwbarton> sclv_: make sure it has no syntax at all; but also is not lisp
13:05:55 <sclv_> oh it will have lots of syntax!
13:06:01 <sclv_> but you won't be able to change it!
13:06:04 <edwardk> rwbarton: constraints are types now ;)
13:06:20 <rwbarton> heh
13:06:22 <sclv_> because my syntax will be perfect from the start
13:06:36 <rwbarton> I still disagree that things of kind other than * deserve to be called "types", but maybe I am on the losing side of that
13:06:57 * hackagebot hsc3-sf-hsndfile 0.12 - Haskell SuperCollider SoundFile  http://hackage.haskell.org/package/hsc3-sf-hsndfile-0.12 (RohanDrape)
13:07:09 <shachaf> tac-tics: What does I/O have to do with "Monads"?
13:07:36 <shachaf> If you think #haskell's operator arguments are bad, you should see #perl6.
13:07:36 <tac-tics> shachaf: because only a sadist would teach monads to someone before they knew how to do IO in Haskell
13:07:45 <tac-tics> :)
13:08:06 <startling> tac-tics: IO is not a very good monad
13:08:10 <tac-tics> maybe a narcolepsist, someone who enjoys putting others to sleep.
13:08:35 <arbn> rwbarton: I prefer "type constructor" for * -> * and so forth.
13:08:38 <edwardk> sclv_: i don't feel that the discussion we're having about (&) vs. (|>) is particularly unpleasant. its fairly passionate in that there are opinions on all sides, but i'm not going to go to bed to night thinking "fuck tibbe, that bastard!"
13:09:38 <mightybyte_> Any idea why something builds fine with "cabal build", but fails with a "No instance" error when I try to load the offending module in ghci?
13:09:40 <hiptobecubic> so |> is not favored because it will tend to be used around things with '<' and '>' in them? Other than that it's just a matter of wanting a one-char operator?
13:09:56 <edwardk> i'm even willing to concede i might be wrong in terms of the overall community as to what the right decision is
13:10:10 <geekosaur> I just think it's fugly
13:10:22 <geekosaur> ok, so it's common in MLoids.  it's stil fugly
13:10:25 <edwardk> hiptobecubic: in my experience, the one char operator makes a big difference in code that uses it a lot
13:10:30 <johnw> edwardk: you really have become a nice guy, huh? :)
13:10:30 <hiptobecubic> geekosaur, indeed it is. yes
13:10:32 <edwardk> geekosaur: then post =P
13:10:37 <geekosaur> and asymmetric with (.)
13:10:42 <geekosaur> or ($)
13:10:54 <edwardk> johnw: its this damn #haskell channel. its turning me into a nice person or something
13:10:55 <hiptobecubic> what is the type of this proposed thing?
13:11:04 <edwardk> i blame Cale, and shapr, and maybe something they put in the water
13:11:07 <hiptobecubic> :t (&)
13:11:09 <lambdabot> Not in scope: `&'
13:11:12 <startling> mightybyte_, importing modules from the wrong packages?
13:11:12 <shachaf> edwardk: Does (.) really cause inlining problems when you apply the function straight away?
13:11:13 <sm__> fight it edwardk ! FIIIGHT
13:11:28 <edwardk> (&) :: a -> (a -> b) -> b; infixl 1
13:11:36 <johnw> there's water?
13:11:41 <mightybyte_> startling: Pretty sure that's not it.  There's only one version of the package providing the instance installed.
13:11:51 <edwardk> shachaf: it can, depends on how much the inliner wants to try to do
13:12:05 <mightybyte_> startling: The module in question is http://hackage.haskell.org/packages/archive/Thrift/0.6.0/doc/html/Thrift-Transport-Handle.html
13:13:49 <mightybyte_> startling: When I run ghci, import Thrift.Transport.Handle, then do :i HandleSource, that tuple instance doesn't show up.
13:13:56 <hiptobecubic> So it's flipped ($)? Why is this causing a ruckus?
13:14:05 <johnw> hiptobecubic: aesthetics
13:14:11 <edwardk> hiptobecubic: because some folks want it to be the longer (|>).
13:14:19 <johnw> everyone has an opinion on matters of aesthetics
13:14:26 <startling> mightybyte_: weird
13:14:29 <edwardk> hiptobecubic: i was content to let it baste in lens for a while longer, but it got pushed out as a proposal =P
13:14:29 <shachaf> ▶ solves everyone's problems.
13:14:40 <arcatan> yes, let's have unicode syntax
13:14:43 <rwbarton> mightybyte_: "import" doesn't always get instances
13:14:46 <rwbarton> use :m +
13:14:51 <mightybyte_> Ok
13:15:09 <hiptobecubic> What about €  :)
13:15:11 <johnw> rwbarton: how is import different from :m+L?
13:15:17 <mightybyte_> rwbarton: That doesn't show it either.
13:15:29 <mightybyte_> But "ghc-pkg list" says that I have Thrift-0.6.0 installed.
13:15:42 <rwbarton> well I assume it is a bug, but in my experience "import Foo" in ghci doesn't import instances that are defined in modules that Foo imports
13:16:05 <johnw> edwardk: what do you think about ($.)?
13:16:16 <edwardk> johnw: i think its the worst of all worlds
13:16:30 <hiptobecubic> I have trouble looking at (&) and seeing it as anything but bitwise logical and
13:16:35 <johnw> it doesn't indicate the reversal of ($) at all
13:16:39 <hiptobecubic> johnw, yes. terrible.
13:16:45 <johnw> and since the dot is small, it makes you read it wrongly
13:16:58 <edwardk> it is long like (|>), but has no precedent, and it looks like someone just tapped a couple of symbols on his keyboard at random
13:17:06 <rwbarton> I didn't realize at first the . wasn't just to end the sentence
13:17:12 <edwardk> rwbarton =)
13:17:14 <edwardk> snd that
13:17:15 <hiptobecubic> heh
13:17:41 <hiptobecubic> what about `FLIPPEDDOLLARSIGN`
13:17:49 <johnw> (⨀)
13:17:49 <shachaf> x █ h █ g █ f
13:17:57 <johnw> shachaf: i couldn't see that siymbol
13:18:12 <shachaf> Get a better font.
13:18:18 <johnw> 💲
13:18:30 <johnw> or 💵
13:18:38 <shachaf> � � � �
13:18:57 <johnw> yeah, I switched to Lucida Grande
13:19:59 <deus_rex> if it's 'reverse' ($) you're looking for, why not use (₴)? ;)
13:20:12 <startling> $ should be ! and then % could be ¡
13:20:20 <deus_rex> :)
13:20:22 <S11001001> no, £, they drive on the other side of the street
13:20:30 <johnw> ∯
13:21:00 <startling> ✓
13:21:02 <deus_rex> (Ƨ|)
13:21:18 <startling> <del>S</del>
13:21:23 <deus_rex> er, (|Ƨ)
13:21:37 <arbn> Then, I can start a business selling special keyboards to Haskell programmers.
13:21:45 <johnw> just sell them Emacs
13:22:01 <startling> set-input-method yo
13:22:02 <johnw> typing special chars is quite easy since shachaf introduced me to the Agda input mode :)
13:22:30 <shachaf> johnw: If you're happy with everything being 5 keystrokes.
13:22:47 <tac> shachaf: It's no worse than writing in an asian language.
13:22:48 <johnw> actually, most of the special chars I use only need \ added at the beginning
13:22:54 <tac> 1 character, 20+ strokes
13:22:55 <johnw> → is \->, ⇒ is \=>, etc.
13:23:11 <tac> 憂鬱 <- it means depression
13:23:37 <startling> johnw: (set-input-method 'Tex) is also nice
13:23:43 <Rc43> Hi, guys.
13:23:52 <johnw> Agda inherits the TeX input method :)
13:23:58 <FireFly> I'd like to see an (xkb) input method where you can sort-of search/complete Unicode codepoint names
13:24:00 <startling> johnw: → is \rightarrow, ⇒ is ⇒
13:24:05 <startling> johnw: oh huh
13:24:16 <johnw> really, you want to type \rightarrow each time?
13:24:18 <startling> FireFly: that would be nice
13:24:26 <Rc43> Can anybody tell me, what is "variable reference" from lambda calculus? It denotes as "e = x", but I can't recall such thing.
13:24:33 <Rc43> http://en.wikipedia.org/wiki/Simply_typed_lambda_calculus
13:24:36 <clahey> So, I'm thinking of expanding a parser that I wrote.
13:24:38 <rwbarton> how about shapecatcher as an input method
13:24:58 <Rc43> (End of 'syntax' chapter.)
13:25:05 <hpc> shapecatcher is awful
13:25:20 <hpc> i never get the symbol i want
13:25:20 <tac> Rc43: it's just a place a variable gets used.
13:25:24 <clahey> But the spec I want to expand it to match has a state machine with a different set of accepted tokens in each state.
13:25:24 <rwbarton> Rc43, just a variable that is in scope
13:25:53 <tac> Rc43: So \x. x has one variable reference (x). \x. \y. y only has one (y)
13:25:54 <drchaos> elementAt [x] 1 = x
13:25:56 <drchaos> elementAt (x:xs) n = elementAt xs (n-1)
13:25:57 <rwbarton> hpc, hmm yes it is failing for me right now
13:26:07 <clahey> Is there a standard way to handle this in MonadParser or parsec or whatever?
13:26:14 <edwardk> tac: oh man, now instead of two characters it has to be two double-wide characters? brutal
13:26:28 <Rc43> rwbarton, tac, ok, but why there is equals sign?
13:26:29 <drchaos> ok, I try this: elementAt [1,2,3] 2
13:26:38 <startling> clahey, doesn't Parsec have state already?
13:26:38 <pdxleif> I've got stuff like "syntax match hsNiceOperator "->" conceal cchar=→" in my haskell.vim
13:26:48 <rwbarton> Rc43: that's part of the BNF-like syntax
13:26:50 <startling> clahey: and isn't that just >>= \x -> if x then y else z ?
13:26:54 <drchaos> I get back: *** Exception: kthelement.hs:(1,1)-(2,39): Non-exhaustive patterns in function elementAt
13:26:57 <edwardk> > [1,2,3,4] ^. element 2
13:27:00 <lambdabot>   3
13:27:00 <tac> Rc43: equal sign? (oh, rwbarton may be correct on this one)
13:27:02 <simpson> pdxleif: Okay, that's kinda cool.
13:27:10 <Rc43> rwbarton, tac, oh, really; thanks
13:27:13 <rwbarton> "e" (an expression) "=" (is) "x" (a variable reference) "|" (or) ...
13:27:15 <clahey> startling: That makes a lot of sense.
13:27:28 <shachaf> drchaos: Sounds like you have non-exhaustive patterns.
13:27:31 <clahey> startling: Well, hmm.
13:27:31 <tac> edwardk: Double wide is the best wideness. No kerning here, folks
13:27:37 <Rc43> rwbarton, tac, I could guess by myself =/
13:27:43 <clahey> startling: So the type of all my expressions is the state.
13:27:46 <rwbarton> Rc43: it's e = the-whole-right-hand-side
13:27:51 <drchaos> shachaf: yes, and I am trying to figure out what is missing
13:28:03 <clahey> startling: Or rather the state and the data associated with the thing being parsed.
13:28:05 <pdxleif> simpson: It's just this: https://github.com/Twinside/vim-haskellConceal
13:28:12 <shachaf> drchaos: Empty lists, numbers other than 1
13:28:16 <rwbarton> drchaos: compile with -Wall
13:28:19 <shachaf> Combinations thereof.
13:28:21 <rwbarton> it will tell you
13:28:21 <shachaf> Oh, rwbarton++
13:28:24 <shachaf> Much better answer..
13:28:26 <shachaf> s/.$//
13:28:26 <tac> rwbarton: (it goes to show you how crappy Wikipedia is for those kinds of things. There's no consistency or links to prerequisite topics)
13:28:49 <rwbarton> tac, I suppose, a link from "syntax" to a relevant page would help
13:29:09 <clahey> startling: It's a little weird since I will have token rules and states that they can be in.
13:29:35 <startling> clahey: weird
13:29:51 <startling> clahey: what's this for?
13:30:13 <clahey> So in state x, the next token could be a, b, or c, and the next state is specified for each of those.
13:30:21 <clahey> startling: microxml parsing with error handling.
13:31:31 <drchaos> shachaf: I add this code to the top of the file, and I get Exception: empty list , : elementAt [] n = error "Empty list"
13:32:19 <mightybyte_> Ok, here's how to get my problem:  "cabal unpack cassy; cd cassy-0.4.0.1; cabal install".  Everything builds fine.  Then do "ghci src/Database/Cassandra/Pool.hs", and I'm getting a "No instance" error.
13:32:27 <drchaos> it seems when the length of the list is 3 and I want to get the 2nd element, it errors with Empty list just like that
13:32:41 <shachaf> drchaos: I recommend evaluating it by hand one step at a time.
13:32:49 <startling> clahey: interesting
13:33:06 <arbn> drchaos: Your function is try to do something to an empty list. Make sure that you have a separate case for when the list might be empty.
13:33:10 <arbn> is trying*
13:33:26 <clahey> startling: So the spec says things like:
13:33:35 <drchaos> arbn: the thing is it should never get to an empty list unless called with an empty list
13:33:38 <clahey> DATA_CHAR - emit a DataChar token
13:33:52 <drchaos> or a negative number, for that matter
13:33:52 <clahey> START_TAG_CLOSE - emit a StartTagClose token and change to Main mode
13:33:59 <shachaf> drchaos: Reduce it by hand and see what happens.
13:34:05 <clahey> But each of the rules is only valid in certain contexts.
13:34:09 <drchaos> shachaf: ok
13:34:22 <clahey> If you're in Comment mode, the rule is DATA_CHAR - do nothing
13:34:45 <startling> clahey: sounds like vim
13:35:36 <clahey> So I guess there's a parser for the whole thing that is a parser for the first lexical token that passes the result into a state table function which returns a new parser.
13:35:48 <clahey> And then those are chained with >>=.
13:36:20 <clahey> Or maybe it returns a Maybe Parser and it chains it into that same function until it returns Nothing.
13:36:39 <clahey> Or an Either Parser Result which returns the result in some cases.
13:36:45 <mightybyte_> rwbarton: Any idea what might be causing that?  It's starting to seem like it might be a bug in ghci or something.
13:36:51 <clahey> I think I may be using monad transformers to implement this.
13:37:04 <startling> clahey, I was just thinking that
13:37:11 <clahey> WriterT output Parser
13:37:15 <clahey> WriterT output Parser result
13:37:58 <clahey> Is there a way to say, run this parser until there's no more results?
13:38:18 <johnw> if it returns a Maybe a, you could use whileJust from control-monad-loops
13:38:27 <drchaos> shachaf: it gets to elementAt [1,2] 1 and keeps on going
13:38:50 <startling> clahey, no more results meaning what?
13:38:51 <drchaos> it gets to elementAt [] -1 and stops with an exception
13:38:52 <clahey> johnw: Except then I don't get a result.
13:38:59 <startling> :t many
13:39:00 <lambdabot> Alternative f => f a -> f [a]
13:39:16 <amalloy> i'm curious about the runtime behavior of newtype. my understanding is that, say, (Product Integer) is just a compile-time construct for typeclass resolution, but at runtime it's stored the same as any other Integer. but what about (map Product xs)? does that have the same run-time behavior as (map id xs), and if so is there something one could do to stop it making a useless copy of a list?
13:39:19 <rwbarton> mightybyte_, I don't know, didn't really catch what the original scenario was, just saw you had a problem involving "import" in ghci and instances
13:39:19 <johnw> clahey: then fold over Maybe [a]
13:39:23 <clahey> startling: Except that doesn't allow one to depend on the other.
13:39:25 <johnw> or something similar
13:39:39 <startling> clahey, I'm having a hard time picturing what you mean
13:39:50 <mightybyte_> rwbarton:  "cabal unpack cassy; cd cassy-0.4.0.1; cabal install".  Everything builds fine.  Then do "ghci src/Database/Cassandra/Pool.hs", and I'm getting a "No instance" error.
13:40:11 <mightybyte_> rwbarton: Seems rather bizarre
13:40:58 <clahey> What I'm looking for is: g :: Parser a -> (a -> Either (Result b) (Parser a)) -> Result b
13:41:34 <clahey> What I'm looking for is: g :: Parser a -> (a -> Either (Result b) (Parser a)) -> Parser (Result b)
13:44:33 <johnw> clahey: unfoldr will let you accumulate results in a list until your logic detects the parsing has ended
13:44:53 <johnw> your "seed" value in that case in the input String
13:45:16 <johnw> for each stage you either return Just(val, rest of string), or Nothing at end
13:47:21 <clahey> g :: (a -> Either (Result b) (Parser a)) -> a -> Parser (Result b)     g f a = h f n where h f (Left b) = return b; h f (Right p) = p >>= g f; n = f a
13:48:13 <clahey> :t let g f a = h f n where h f (Left b) = return b; h f (Right p) = p >>= g f; n = f a in g
13:48:14 <lambdabot> Monad m => (a1 -> Either a (m a1)) -> a1 -> m a
13:49:45 <wires> i would like to write an elastic search client for haskell, ES is a search index with a json query language. I'm not so well versed in state of the art haskell libraries, what is a good project to base this code one? (either conceptually or using code)
13:50:33 <wires> If possible i'd like it to fit nicely with something like zeromq
13:50:43 <wires> any ideas?
13:52:22 <clahey> How do I turn my parser objects into MaybeT StateT WriterT Parser s?  lift?
13:52:31 <sm__> wires: I'd browse hackage for api clients, published recently, depending on strong libs like http-conduit and aeson
13:52:46 <clahey> I guess I don't want MaybeT, just include an end state.
13:52:57 <clahey> This is so fascinating.
13:52:58 <wires> sm_, thanks sounds good
13:54:00 <drchaos> shachaf: evaluating all this stuff out by hand even helped me find all the edge cases, even the one where the list index is too large
13:54:13 <wires> "couchdb-conduit library: Couch DB client library using http-conduit and aeson" <-- yup, I guess that would do. Any experience with it, by any chance?
13:54:58 <drchaos> shachaf: http://vpaste.net/idMnu
13:55:03 <Cale> I would start with a non-conduit library first.
13:55:24 <johnw> clahey: why wouldn't you just want unfoldr?
13:55:28 <wires> Cale, why?
13:56:02 <wires> easier to design that way?
13:56:43 <johnw> > unfoldr (\str -> if not (null str) then Just (take 5 str, drop 5 str) else Nothing) "Hello, world!"
13:56:45 <lambdabot>   ["Hello",", wor","ld!"]
13:56:47 <Cale> wires: I think so. All the iteratee libraries are internally pretty hairy, and are sort of a premature optimisation in a lot of cases.
13:57:00 <johnw> clahey: there's a dumb parser that consumes 5 chars until there's nothing left to consume
13:57:54 <Cale> Now, maybe you're going to be doing massive amounts of communication and you want it to perform really competitively, and conduit or one of the other iteratee libraries might be a good thing to get you there.
13:58:10 <clahey> johnw: I wan it to be in the Parser monad so I can use all the parser combinators and so forth?
13:58:17 <johnw> clahey: sure
13:58:30 <johnw> clahey: unfoldr doesn't care what your test and parse functions are
13:58:50 <johnw> and I know parsec has a parse method or something that will return the remainder of the input
13:58:54 <Cale> But if you're starting out, it's kind of pulling in a heavy piece of machinery which you may or may not actually need.
13:58:55 <johnw> when that is null, you're done
13:59:37 <clahey> johnw: I don't think that's quite going to do the right thing because of how error handling in the parser itself works.
14:00:00 <clahey> The parser has metadata about where the data came from.
14:00:04 <clahey> So you can't just return a string.
14:00:11 <clahey> And then pass the string into the next parser.
14:00:12 <Cale> wires: For example, the zeromq-haskell package: http://hackage.haskell.org/package/zeromq-haskell-0.8.4
14:00:24 <johnw> clahey: you can fmap into an Either value in your unfold
14:00:25 <clahey> I really want something that returns a m [a]
14:00:34 <johnw> so that the unfolding stops on error
14:01:23 <Cale> has almost no dependencies, and looks pretty simple -- I have no idea about its quality, I don't even really know what you'd use this thing for despite having watched a talk about it. :)
14:01:23 <clahey> johnw: I'll keep unfoldr in mind.
14:02:08 <Cale> But it's certainly not obvious to me that this kind of thing needs to be using conduits.
14:02:18 <clahey> johnw: At the very least, I've looked at unfoldr's source code and can make mine similar.
14:02:29 <merijn> edwardk: What did you start! That's the 5th digest of libraries I receive today >.>
14:03:11 <johnw> clahey: sure, we're just talking about an anamorphism here, however you want to implement it
14:04:18 <johnw> there's also the unfoldable package, which generalizes this a bit
14:04:31 <johnw> and gives you: unfold :: Unfolder f => f a -> f (t a)
14:06:13 <clahey> johnw: I don't think I quite want an anamorphism, since I want to return a generic MonadParser.
14:06:27 <clahey> johnw: But it's very close.
14:07:10 <johnw> oh, you want to return a single MonadParser value?
14:08:25 <clahey> Yes.
14:08:39 <Cale> wires: Looking at it, it kind of seems like you just need perhaps some FromJSON instances for datatypes representing the results of various requests, and perhaps some nice wrappers for making the appropriate HTTP requests. I'd just use the Network.HTTP library.
14:08:45 <johnw> what is the ultimate type signature you want to use?
14:09:22 <clahey> I want unfoldM (a -> Either b (m a)) -> a -> m b
14:09:39 <clahey> I want unfoldM :: (a -> Either b (m a)) -> a -> m b
14:09:47 <clahey> And I think I wrote it up above.
14:09:51 <johnw> ok
14:10:02 <Cale> It looks like the responses from the server are expected to be pretty simple and small, in which case I'd say screw conduits, they're not worth the trouble.
14:10:32 <clahey> johnw: Although, I kinda want a to be the state.
14:10:40 <johnw> Either b -> m b?
14:10:45 <johnw> you only want the Left value?
14:11:05 <clahey> johnw: No.
14:11:13 <clahey> johnw: You're right.
14:13:18 <clahey> Maybe unfoldM :: (a -> Maybe (WriterT b m a)) -> a -> m b
14:15:03 <clahey> Perhaps unfoldM :: (a -> MaybeT (WriterT b m) a) -> a -> m b
14:15:10 <clahey> I'll figure it out when I can actually play with code.
14:17:37 <hpaste> johnw pasted “unfoldM.hs” at http://hpaste.org/77982
14:17:41 <johnw> clahey: how about that
14:19:52 <johnw> then your m could be (Either c) and you'd get short-circuiting with return of error
14:20:47 <johnw> if the full type were Either c [a], then you'd have your list of parsed results in Right [a]
14:23:44 <johnw> of course, that's really not any different from sequence $ unfoldr
14:23:48 <clahey> johnw: Now what I'm looking for.
14:23:53 <clahey> johnw: I'll figure it out.
14:23:57 <johnw> k
14:24:41 <clahey> johnw: However...
14:26:56 <clahey> unfoldM :: MonadPlus m => (b -> Maybe (a, m b)) -> b -> m a
14:29:45 <clahey> Nope.  I'm at work right now, so I shouldn't be working on this anyway.
14:31:04 <mm_freak> Cale: the naturality law makes arrow-to-monad transformers impossible
14:31:38 <crdueck> @hoogle ([a] -> Bool) -> [a] -> [a]
14:31:39 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
14:31:39 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
14:31:49 <mm_freak> Cale: that's because you disallow a generic Kleisli
14:32:35 <crdueck> @src takeWhile
14:32:35 <lambdabot> takeWhile _ []                 =  []
14:32:35 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
14:32:35 <lambdabot>                    | otherwise =  []
14:38:46 <Josher> Hi
14:38:54 <simpson> Howdy.
14:39:35 <clahey> So, do you guys see haskell as being a practical programming language that anyone can learn and build large systems out of?
14:39:56 <clahey> I really like it, but I have a hard time explaining to people why.
14:39:58 <frio> that's a very loaded question
14:40:20 <frio> practical? maybe, anyone can learn? yes, build large systems out of? yes
14:40:23 <Josher> What are some major software written in haskell
14:40:33 <mauke> not everyone can build large systems
14:40:47 <frio> agree mauke
14:40:53 <clahey> mauke: That is true.  I thought of that too.
14:41:03 <Sculptor> i see it as a proof of concept language
14:41:12 <clahey> mauke: I guess the requirement is that everyone could be made a cog of a group creating a large system.
14:41:19 <frio> and while i say "anyone can learn", i mightn't say it's *practical* for everyone to learn it :)
14:41:23 <clahey> mauke: Much as happens in large company.
14:42:00 <crdueck> is there a better way to write this function? http://sprunge.us/KROH
14:42:32 <clahey> frio: So, the gist is that I see programming as a community effort.
14:42:41 <clahey> frio: Readability is super important to me.
14:42:53 <johnw> and he's not referring to gist.github.com or readibility.com :)
14:42:58 <frio> hah :p
14:43:01 <clahey> Readability and Editability.
14:43:23 <frio> as someone who works at a large-ish software company, yes clahey, I agree with both of those. Maintainability is super-important to everything
14:43:43 <clahey> So if I write something in haskell and it's not practical for 80% of my peers to contribute to, then I'm programming myself into a corner.
14:43:47 <clahey> frio: Where do you work?
14:43:57 <frio> Haskell lets you make guarantees about your code which I find awesome when it comes to updating elder stuff -- myFunc :: String -> String being referentially transparent/functionally pure is awesome
14:44:04 <frio> as opposed to, say, java
14:44:16 <frio> whereby I'm currently working to fix a bug
14:44:28 <clahey> frio: So, one advantage I see is testability.
14:44:30 <johnw> yes, when you come back to your functions a year later, their behavior remains the same
14:44:35 <frio> in which the method signature is public static void validateOrThrowException(Message message) throws InvalidMessageException
14:44:45 <frio> which does *nothing* except mutate all the dates in the passed in message...
14:44:54 <Polarina> frio, const is your "anti-pattern" friend. :)
14:45:16 <clahey> I'm working on a piece of code that mixes IO and computation.
14:45:17 <amalloy> i'm curious about the runtime behavior of newtype. my understanding is that, say, (Product Integer) is just a compile-time construct for typeclass resolution, but at runtime it's stored the same as any other Integer. but what about (map Product xs)? does that have the same run-time behavior as (map id xs), and if so is there something one could do to stop it making a useless copy of a list?
14:45:48 <clahey> amalloy: Who said that map id xs isn't going to make a useless copy of a list?
14:46:01 <Polarina> amalloy, map Product xs, would at runtime, be nothing more than a no-op, technically speaking.
14:46:13 <Polarina> amalloy, relatively to map id xs, of course.
14:46:19 <simpson> amalloy: I think it depends on whether or not the compiler can guarantee that Product, and not some other member of the typeclass, is going to be used.
14:46:36 <avpx> Does the compiler utilize the fact that fmap f . fmap g  = fmap f . g?
14:46:45 <clahey> simpson: At final compile time, it must know.
14:46:47 <avpx> Modulo parens that I probably forgot to put in there
14:46:53 <frio> clahey: I work for a software company in NZ. large by NZ standards (one of the largest!), small compared to the likes of Google or MS
14:46:59 <johnw> avpx: i believe there is a RULES directive to apply that fusion, yes
14:47:08 <johnw> shachaf: would know
14:47:15 <Polarina> avpx, I remember seeing a rule that lets GHC know of that.
14:47:30 <avpx> So map Product is, then, just id
14:47:32 <amalloy> clahey: i must have expressed myself poorly, because i meant that (map id xs) *does* uselessly create a list, and it would be nice to have something "like" (map Product xs) that does only a compile-time transformation
14:48:13 <sclv_> i think that newtypes go away well after ghc rewrite rules can kick in :-(
14:48:20 <avpx> Err wait
14:48:25 <avpx> Sorry, that would be a different fusion.
14:48:26 <avpx> fmap id = id
14:48:34 <sclv_> yeah you can't do that in general
14:48:39 <clahey> amalloy: I see no reason why the compiler couldn't handle that if someone coded it.
14:48:42 <sclv_> because something might break functor laws
14:48:48 <sclv_> you can do a rewrite rule for that
14:48:52 <sclv_> however
14:49:09 <clahey> sclv_: But for map, that's not true.
14:49:12 <sclv_> as i recall Sequence uses this trick
14:49:17 <simpson> clahey: I thought that, at runtime, it was still possible for a function to be polymorphic with a typeclass constraint in a given argument.
14:49:17 <sclv_> let me find the code
14:49:40 <clahey> simpson: I still don't understand existential types.
14:49:48 <sclv_> w/r/t the map example you can use an unsafeCoerce, safely
14:50:02 <clahey> simpson: And thus forgot about them.
14:50:05 <sclv_> one of edwardk's packages takes advantage of this
14:50:11 <sclv_> to very evil effect
14:50:36 <sclv_> s/one/one or more/
14:50:48 <clahey> amalloy: Actually, repa might be relevant.
14:51:06 <clahey> amalloy: Or something like it for lists.
14:52:26 <frio> on a completely different topic, im champing at the bit to try out reactive-banana
14:53:01 <amalloy> ah, unsafeCoerce is interesting. granted that it seems pretty unlikely i ever write code that needs performance that badly, it's neat to know it's there, and it seems it would address my "problem"
14:53:47 <clahey> type MyList a = Manifest (List a) | Delayed (b -> a) (List b)
14:54:28 <clahey> Then fmap f (Delayed f' l) = Delayed (f . f') l
14:54:43 <edwardk> sclv_: reflection
14:54:55 <sclv_> yep
14:55:04 <clahey> Something like that?
14:55:09 <edwardk> well, reflection does someting even more evil
14:55:19 <edwardk> but i use the map id = id Iso hack in ad a lot
14:55:27 <edwardk> it makes a pretty big performance difference embarassingly
14:55:43 <edwardk> and the performance hack in lens is somewhat similar in spirit, but only saves an eta expansion
14:56:14 <sclv_> so if you look at the applicativeTree function in Data.Sequence
14:56:15 <sclv_> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/containers-0.3.0.0/src/Data-Sequence.html#replicate
14:56:31 <sclv_> it is called from replicate with log(n) and replicate(A) with O(n)
14:56:44 <sclv_> the Id specialization automatically introduces sharing, which is sort of awesome
14:56:59 * hackagebot edge 0.8.10 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.10 (ChristopherHoward)
14:57:02 <sclv_> its not exactly what we were discussing, but its a very cool trick
14:58:13 <amalloy> huh. if i run `unsafeCoerce [1]`, without telling it what return type i want, i would expect ghci to complain about the ambiguous type variable "b". instead, it crashes and tells me to please report a ghc bug
14:58:36 <JoshuaLin>  /join #NakedCats
14:59:27 <Polarina> amalloy, better report the bug then.
14:59:30 <johnw> edwardk: wait, why is no one complaining that |> is already in Data.Sequence?
14:59:42 <Cale> amalloy: GHCi has extended defaulting rules which make it pick () when a type is otherwise unconstrained, as a last-ditch attempt to make sense of things
14:59:43 <Polarina> amalloy, if GHC tells you to report a bug, and it's not a bug, it's a bug.
14:59:46 <johnw> I'd assume someone like yitz to come along with the same objection
14:59:52 <Cale> It's not a bug
15:00:04 <rwbarton> the bug is that it said it was a bug :)
15:00:11 <rwbarton> but that bug seems hard to fix
15:00:21 <edwardk> johnw: it was raised early on. i'm actually with ibbe on the fact that that shouldn't be a consideration. libraries for the most part should stand on their own. global conflict avoidance is impossible.
15:00:29 <edwardk> er tibbe
15:00:45 <edwardk> Data.Ratio is much older than Data.Sequence
15:01:02 <johnw> oh, containers doesn't "come with" ghc?
15:01:10 <edwardk> so its a much harder sell to not only break but change semantics
15:01:22 <johnw> :t iterate
15:01:24 <lambdabot> (a -> a) -> a -> [a]
15:01:30 <johnw> edwardk: at least the recent posts are leaning toward &
15:01:47 <edwardk> containers is part of the platform, and it is even used internally by ghc now, but its still outside of base, while ratio is inside.
15:01:54 <johnw> ah
15:02:06 <johnw> huh, Sequence looks neat, i'll have to use it for some stuff
15:02:19 <johnw> it's those bat-wing trees you described, right?
15:02:25 <edwardk> i did a talk on fingertrees at one point if you want to know more about how it can work
15:02:33 <johnw> oh?  where at?
15:02:36 <edwardk> http://comonad.com/reader/2010/finger-trees/
15:02:42 <johnw> nice, thanks
15:03:54 <Cale> See also the original paper
15:03:56 <edwardk> johnw: there is one or two too many (!)'s in that when it comes to descriptions of the fingertree types, the spine down 'D' shouldn't be strict
15:03:59 <edwardk> there is that
15:04:06 <Cale> http://www.soi.city.ac.uk/~ross/papers/FingerTree.html
15:04:54 <edwardk> hinze and paterson's paper is excellent for getting your head around what you can actually do with fingertrees by choosing appropriate monoids.
15:05:16 <edwardk> trifecta is build on a fingertree of bytestrings with a nice monoidal summary of file position and some other stuff
15:05:18 <johnw> thanks, i've queued it all up
15:05:45 <edwardk> so to know file position you just have to slice open the fingertree and look at the monoidal summary of the prefix
15:05:45 <Cale> Yeah, the really important thing from the finger tree paper isn't the actual tree structure, if you ask me
15:05:52 <johnw> what isi t?
15:06:20 <edwardk> you can do most of the interesting finger tree operations on a regular 2-3 tree where you stick a monoidal annotation in the nodes summarizing what comes below them
15:06:29 <Cale> It's the idea of monoidally indexed trees, which is one of those blindingly obvious should-have-been-known-for-fifty-years sort of ideas.
15:06:36 <edwardk> the finger tree representation just turns that around so its easier to summarize prefixes/suffixes
15:06:56 <Cale> Not even just 2-3 trees, but practically any sort of tree
15:07:11 <edwardk> johnw: consider building a tree, and just tagging each binary tree node with an Int for the count of it and all of its children.
15:07:19 <edwardk> johnw: or where you store the maximum value of its children
15:07:26 <Cale> Basically all the trees we use in computer science in order to improve performance in some fashion are monoidally indexed trees of some sort.
15:07:31 <johnw> an augmented tree
15:07:35 <edwardk> johnw: yep
15:07:47 <johnw> i've written those, so go on
15:07:48 <edwardk> i use monoidally annotated structures a _lot_
15:07:57 <edwardk> @hackage lca
15:07:58 <lambdabot> http://hackage.haskell.org/package/lca
15:08:21 <edwardk> that uses monoidally annotated paths and extracts the summary of the paths to their lowest common ancestor, etc.
15:08:56 <johnw> what do you use lca for?
15:09:06 <crdueck> @hoogle (a -> Bool) -> Data.Map.Map k a -> Bool
15:09:07 <lambdabot> Parse error:
15:09:07 <lambdabot>   (a -> Bool) -> Data.Map.Map k a -> Bool
15:09:07 <lambdabot>                      ^
15:09:13 <crdueck> @hoogle (a -> Bool) -> Map k a -> Bool
15:09:13 <lambdabot> No results found
15:09:20 <edwardk> i have a monad for revision control that uses it internally.
15:09:31 <johnw> a monad for revision control?
15:09:38 <johnw> that sounds interesting
15:09:46 <crdueck> is there no version of "any" for Maps?
15:10:00 <johnw> oh, lca is what merge algorithms use
15:10:12 <Cale> crdueck: There's no better way to do it than applying elems first and using the list any
15:10:27 <crdueck> Cale: okay, thats what i was thinking of doing
15:10:40 <edwardk> basically you get the ability to create 'versioned variables', and you can fork and join. and edit variables. when you fork each fork gets its own copy of all the variables, when you join, if both branches edited it, then the merge strategy you specify when you create the variable is used to merge the two new ancestors, and is given access to their lowest common ancestor in the fork/join graph
15:11:01 <johnw> edwardk: is this on hackage?
15:11:17 <edwardk> this requires a lot of _online_ lowest common ancestor queries, and while i was solving it, i wound up improving the known asymptotic bounds in online lowest common ancestor search. ;)
15:11:33 <edwardk> its on my github under revisions, but not yet on hackage
15:11:35 <johnw> did you have a problem at work that required you to solve this?
15:11:45 <edwardk> no, this was for something else i was working on on my own
15:11:57 <edwardk> this is about 5 yaks deep ;)
15:12:07 <johnw> does your wife get to see you ever?
15:12:17 <edwardk> she's a very patient woman ;)
15:12:47 <johnw> oh, this relates to concurrency
15:13:00 <johnw> where you're merging the results of descendant computations?
15:13:08 <edwardk> the idea of the revision control monad isn't mine. it was originally done by daan leijen and some other guys at microsoft research. i just came up with a nicer encoding, and my other encoding required me to solve the LCA problem that they ignored
15:13:12 <edwardk> yep
15:13:46 <edwardk> think of each fork as a fork of the version control repository or something and then you want to merge together answers in a way that you can always roll forwar rather than roll back on conflict
15:13:51 <johnw> Rev m <|> Rev n = Rev $ \ks kf s r w d h -> m ks (\_ -> n ks kf s r w d h) s r w d h
15:13:53 <edwardk> lets take a simple versioning strategy
15:13:58 <johnw> that's, um, interesting
15:14:09 <edwardk> johnw: i was more concerned with it working and being fast than readable ;)
15:14:36 <edwardk> i drift into that mode every once in a while =P
15:14:59 <cmccann> that's perfectly readable. it says, "here is some bullshit involving continuations, don't even bother"
15:15:12 <edwardk> the simplest example of a merge strategy is the 'forked process wins' , just ignore the old value and the value in the main thread, and the one you forked and joined back in wins if both edit.
15:15:30 <edwardk> the next simplest would be to do something like add up the two new values and subtract their least common ancestor.
15:15:47 <edwardk> this gives you something like a rolling total, because you avoid double counting the ancestors
15:16:06 <edwardk> so if you fork a proces that adds 2 and you add 2, and join you get a net delta of 4
15:16:24 <edwardk> you can take this farther and find strategies for relative and absolute offset, etc.
15:16:34 <edwardk> or for doing things like unification in parallel
15:16:44 <edwardk> so far so good?
15:16:56 <wires> Cale, (re ES client) thanks that makes a lot of sense
15:16:59 * hackagebot monad-peel 0.1.1 - Lift control operations like exception catching through monad transformers  http://hackage.haskell.org/package/monad-peel-0.1.1 (AndersKaseorg)
15:17:13 <johnw> edwardk: thank goodness for type checking, eh?
15:17:18 <edwardk> just think 'allocated versioned variable with a merge strategy, edit variables, fork and join' and the model so far should be consistent
15:17:28 <johnw> otherwise swapping two of those variables would be impossible to tarck down
15:17:36 <johnw> gtg, dinner time
15:17:45 <johnw> i'll read my log when I get back
15:17:49 <edwardk> anyways the best part is when you break the version control metaphor.
15:18:08 <edwardk> you can make an operation we'll call 'record :: MonadRev m =>  m a -> m (a, m a)'
15:18:37 <edwardk> and record runs a task, which contains a bunch of forks and joins, and returns the answer, but it also returns an optimized version of that task
15:18:59 <edwardk> that can look at the edited variables since it was run the first time, and if they don't overlap with the variables needed by a branch, it can reuse the answer to that branch
15:19:15 <edwardk> that means the fork/join model becomes not inly a parallelization strategy but an incrementalization strategy.
15:19:45 <edwardk> and so you can do things like get 28x speedup on 8 cores instead of piddly little 2.5-4.5x speedups
15:21:00 <edwardk> and its particularly useful for game loop -style tasks like 'runPhysics' or whatnot where the majority of the world state isn't changing from frame to frame
15:24:38 <bgamari> edwardk, This actually sounds like precisely what I need for tracking my sampler's state
15:24:56 <edwardk> bgamari: =)
15:25:07 <Ralith> edwardk: oo, concurrent unification sounds fun
15:25:30 <edwardk> Ralith: my major usecase is somewhat more interesting -- using it for type error slicing
15:25:59 <edwardk> getting concurrency out of it is ho-hum, but getting incrementalization so i can rip one part of the syntax tree out and get a new unification problem and recycle most of the work done on the last one? priceless
15:26:07 <cmccann> oh, is this part of the "try to accidentally invent an entire language and compiler toolchain" plan?
15:26:19 <edwardk> cmccann: pretty much
15:26:19 <Ralith> thta sounds pretty neat too!
15:26:40 <edwardk> cmccann: i keep tripping over parts of this imaginary tool chain on my way to other ideas ;)
15:27:00 <Ralith> I am interested in anything that can speed up typechecking; I expect it to be a major challenge in the future of idris
15:27:42 <edwardk> with idris the main things i can recommend is hash-cons the crap out of it =P
15:28:33 <startling> Ralith, yeah, editing idris' prelude is pretty painful.
15:28:50 <Ralith> startling: lots of recompilation?
15:28:53 <Ralith> wel
15:28:55 <Ralith> retypechecking
15:29:17 <startling> Ralith, it took me like a minute to :r each time. :(
15:29:44 <Ralith> oh wow
15:29:46 <Ralith> what are you working on?
15:29:50 <Ralith> what hw, that is
15:29:58 <Ralith> edwardk: heh
15:30:23 <startling> Ralith, 2008 macbook
15:30:33 <Ralith> startling: weird, would've thought that'd've been more up to it
15:30:48 <Ralith> my 2012 thinkpad tears through a full typecheck in a few seconds, iirc
15:31:05 <startling> Ralith, maybe something weird's happening then
15:31:10 * Ralith checks
15:31:18 <edwardk> startling: thats nothing compared to copumpkin's experiences with agda, loading up projects he can't fit the entire thing into memory, waiting 15 minutes, loading module by module and doing incremental type checking for category theory =P
15:31:22 <startling> Ralith: #idris ->
15:31:45 <Ralith> edwardk: see, that scares me.
15:31:52 <edwardk> i was all gung ho about working on his categories library in agda until i saw his compile times =P
15:32:01 <Ralith> hah
15:32:47 <startling> yeah, I think memory could be an issue here
15:33:01 <startling> I've only got 1GB
15:36:43 <edwardk> whatever happened to preflex, anyways?
15:37:08 <shachaf> mauke's machine died.
15:40:22 <tufflax> Hi there, just starting out with haskell. Is there a built-in help in ghci, so that I can do something like "help +" and is shows me help about the + function
15:41:11 <rwbarton> there's :info (or :i)
15:41:13 <rwbarton> :i +
15:41:22 <rwbarton> would tell you a little bit about it
15:41:24 <fryguybob> tufflax: There is also http://www.haskell.org/hoogle/
15:41:35 <geekosaur> including http://www.haskell.org/haskellwiki/Hoogle#GHCi_Integration
15:41:46 <Nereid> :i won't show you the documentation though
15:41:48 <geekosaur> (although I don't know how recent that is; ghc evolves...)
15:42:00 * hackagebot fay 0.10.0.0 - A compiler for Fay, a Haskell subset that compiles to JavaScript.  http://hackage.haskell.org/package/fay-0.10.0.0 (ChrisDone)
15:42:03 <Nereid> geekosaur: it still works
15:42:30 <rwbarton> for (+) I hope the name and type are enough documentation :)
15:42:37 <Nereid> ahh, hoogle --info does it.
15:42:48 <tufflax> fryguybob, thanks
15:43:19 <Nereid> tufflax: so if you have a local hoogle installation, you can integrate it with ghci
15:43:25 <Nereid> and type :doc whatever to see stuff
15:44:35 <edwardk> i think we set the bar too low grabbing for (%) with lens. we should have aimed for something a little more common like (+).
15:44:51 <merijn> edwardk: :p
15:44:55 <Nereid> haha
15:45:27 <merijn> edwardk: Like I said earlier, I'm already up to 5 libraries digests for today alone thanks to you ;)
15:45:39 <edwardk> merijn: =)
15:45:55 <edwardk> merijn: i figured i'd let the current discussion cool down before proposing more combinators out of lens.
15:46:01 <edwardk> :t (<$!>)
15:46:03 <lambdabot> Monad m => (a -> b) -> m a -> m b
15:46:22 <merijn> Although I still oppose your claim to both :p
15:46:47 <edwardk> > ("oh", "well") & both .~ "shrug"
15:46:49 <lambdabot>   Not in scope: `&'
15:46:50 <shachaf> merijn: Blame yitz for that!
15:47:01 <merijn> "both = join (***)" is clearly the superior both!
15:47:02 <edwardk> @let (&) = (%); infixl 1 &
15:47:02 * hackagebot multiset 0.2.2 - The Data.MultiSet container type  http://hackage.haskell.org/package/multiset-0.2.2 (TwanVanLaarhoven)
15:47:04 <lambdabot>  Defined.
15:47:06 <edwardk> > ("oh", "well") & both .~ "shrug"
15:47:09 <lambdabot>   ("shrug","shrug")
15:47:15 <shachaf> @ty join (***)
15:47:16 <lambdabot> Arrow a => a b c -> a (b, b) (c, c)
15:47:19 <shachaf> @ty over both
15:47:21 <lambdabot> (a -> b) -> (a, a) -> (b, b)
15:47:33 <edwardk> thats 'diag' in categories somewhere
15:47:53 <rwbarton> hmm
15:47:59 <rwbarton> i keep wanting the name 'diag' for \x -> (x,x)
15:48:12 <Nereid> yes
15:48:13 <edwardk> @hackage categories
15:48:14 <lambdabot> http://hackage.haskell.org/package/categories
15:48:27 <edwardk> diag :: a `k` Product k a a
15:48:29 <Nereid> heh it's there
15:48:32 <edwardk> actually it is that one
15:48:37 <rwbarton> good!
15:48:42 <rwbarton> carry on then
15:48:54 <edwardk> so i stand corrected. i don't recognize merijn's both at all =P
15:49:12 * merijn has a sad
15:49:31 <edwardk> and it offers codiag :: CoCartesian k => Sum k a a `k` a
15:50:21 <Nereid> well, you have join bimapProduct
15:50:23 <rwbarton> often called "fold" but I guess that won't fly here
15:50:28 <Nereid> but then (***) is bimapProduct
15:50:38 <edwardk> yeah, i don't think you can win the name fold ;)
15:51:00 <edwardk> :t join Data.Bifunctor.bimap
15:51:02 <lambdabot> Data.Bifunctor.Bifunctor p => (a -> b) -> p a a -> p b b
15:51:10 <Nereid> actually
15:51:24 <Nereid> some notation I liked for describing maps from coproducts to products
15:51:29 <Nereid> you write them like a matrix
15:51:47 <Nereid> so diag is a column [id; id], and codiag is a row [id id]
15:53:00 <Nereid> I guess it's mostly useful in additive categories though
15:54:13 <Nereid> well I guess all you need is biproducts
16:17:33 <tufflax> [0.1, 0.3..1] = [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999] what? :p
16:17:57 <tufflax> I'm too curious to let that go :p
16:18:06 <simpson> > [0.1, 0.3..1] :: [Rational]
16:18:07 <lambdabot>   [1 % 10,3 % 10,1 % 2,7 % 10,9 % 10,11 % 10]
16:18:29 <simpson> > [0.1, 0.3..1] :: [Float]
16:18:31 <lambdabot>   [0.1,0.3,0.5,0.7,0.9,1.0999999]
16:18:45 <simpson> Floats have a limit to their precision.
16:19:01 <tufflax> yes i'm well aware
16:19:26 <tufflax> But isn't the 1 supposed to be an upper limit
16:19:39 <Nereid> tufflax: yes, the Enum instance for Double is uhhhhhhhhhhh
16:20:01 <simpson> tufflax: Oh. Yes, but with the comparison on the other side of the fencepost.
16:20:12 <tufflax> oh
16:20:14 <tufflax> ok, then
16:20:31 <Nereid> > filter (<= 1) [0.1,0.3..]
16:20:33 <rwbarton> protip: don't write literals like [0.1, 0.3 .. 1]
16:20:36 <lambdabot>   mueval-core: Time limit exceeded
16:20:41 <Nereid> > takeWhile (<= 1) [0.1,0.3..] -- oops
16:20:43 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999]
16:21:08 <startling> > [0.1, 0.11, 0.111, 0.1111 .. 1]
16:21:09 <Nereid> tufflax: Enum is one of those classes where uh
16:21:10 <lambdabot>   <hint>:1:27: parse error on input `..'
16:21:17 <Nereid> no one has really written down what an Enum instance should obey
16:21:18 <avpx> > takeWhile (<= 1) [0.1, 0.3..]
16:21:20 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999]
16:21:38 <rwbarton> "takeWhile (<= limit)" is dangerous when you expect limit to be in the sequence
16:21:52 <Nereid> rwbarton: for floating point numbers, sure
16:21:53 <rwbarton> which is the only time you should be writing such a literal in the first place
16:22:01 <Nereid> haha
16:22:08 <avpx> I seldom use floating point numbers anyway
16:22:21 <Nereid> > [0,0.1..]
16:22:23 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
16:22:34 <Nereid> > drop 10000 [0,0.1..]
16:22:35 <clahey> rwbarton: Why not takeWhile (<= 34) fibs
16:22:36 <lambdabot>   [1000.0000000000249,1000.1000000000249,1000.2000000000249,1000.300000000025...
16:22:48 <rwbarton> > takeWhile (<= 1) [0,0.1..]
16:22:50 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001,0.5000000000000001,0.60...
16:22:54 <Nereid> > drop 1000000 [0,0.01..]
16:22:56 <lambdabot>   [9999.999999842887,10000.009999842885,10000.019999842883,10000.029999842882...
16:22:59 <rwbarton> > takeWhile (<= 0.5) [0,0.1..] -- oops!
16:23:01 <lambdabot>   [0.0,0.1,0.2,0.30000000000000004,0.4000000000000001]
16:23:24 <Nereid> > takeWhile (<= 0.5) [0,1/10] :: [Rational]
16:23:26 <clahey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<=limit) fibs
16:23:26 <lambdabot>   [0 % 1,1 % 10]
16:23:27 <lambdabot>   Not in scope: `limit'
16:23:28 <Nereid> > takeWhile (<= 0.5) [0,1/10..] :: [Rational]
16:23:30 <lambdabot>   [0 % 1,1 % 10,1 % 5,3 % 10,2 % 5,1 % 2]
16:23:32 <clahey> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in takeWhile (<=34) fibs
16:23:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
16:23:46 <Nereid> hmm I should have written 1/2
16:23:56 <rwbarton> no need
16:24:03 <Nereid> > 0.1 :: Rational
16:24:05 <lambdabot>   1 % 10
16:24:07 <rwbarton> 0.5 means fromRational (5%10)
16:24:07 <Nereid> ah ok
16:24:27 <Nereid> > 1.0000000000000000000000000001 :: Rational
16:24:29 <lambdabot>   10000000000000000000000000001 % 10000000000000000000000000000
16:24:32 <Nereid> cool
16:24:59 <hiptobecubic> wait, are there no actual double literals?
16:25:05 <hiptobecubic> or float
16:25:19 <clahey> > .5e2 :: Rational
16:25:21 <lambdabot>   <hint>:1:1: parse error on input `.'
16:25:26 <clahey> > 0.5e2 :: Rational
16:25:28 <lambdabot>   50 % 1
16:25:34 <clahey> > 0.5e2 :: Int
16:25:36 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
16:25:36 <lambdabot>    arising from the lit...
16:25:40 <rwbarton> what would a "double literal" be
16:25:41 <tufflax> simpson, Actually, I don't really get it: [0.1, 0.3..0.95] = [0.1,0.3,0.5,0.7,0.8999999999999999]
16:26:17 <clahey> > [0.1, 0.3..0.95] :: [Rational]
16:26:19 <lambdabot>   [1 % 10,3 % 10,1 % 2,7 % 10,9 % 10]
16:26:24 <clahey> That's so awesome!
16:26:34 <rwbarton> tufflax, basically it rounds the stated endpoint to the nearest number that is actually in your sequence
16:27:15 <tufflax> ok
16:28:28 <rwbarton> that keeps it maximally robust in the face of floating-point inaccuracies
16:29:42 <clahey> > [0.1, 0.3..0.89]
16:29:44 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999]
16:29:52 <chreekat> If for some daft reason I wanted a variable with a £ in its name, could I manage it somehow? language pragma of some sort?
16:30:28 <tufflax> Another thing I'm just curious about: Are "infix functions" defined differently than other functions of 2 arguments? Or are all functions of 2 args infix? (I know one can do (+) 1 2, but, I mean without any extra syntax or whatever)
16:31:33 <mauke> tufflax: alphanumeric vs. symbols
16:32:00 <tufflax> mauke sorry, what?
16:32:38 <geekosaur> alphanumeric names are prefix, symbolic names are infix
16:32:53 <tufflax> oh
16:32:57 <Jafet1> > let (*!&^\) = (+) in 1 *!&^\ 2
16:32:58 <tufflax> ok, thanks
16:32:59 <geekosaur> wrapping () around symbols produces an infix function, wrapping `` around alphanumerics produces infix
16:32:59 <lambdabot>   3
16:33:11 <geekosaur> (they don't nest though)
16:33:25 <FireFly> wrapping () around symbols produces a prefix function*
16:33:40 <FireFly> I think?
16:34:15 <Nereid> > (+) 1 2
16:34:17 <lambdabot>   3
16:34:44 <chreekat> let add = (+) in 1 `add` 2
16:34:49 <chreekat> DD> let add = (+) in 1 `add` 2
16:34:51 <chreekat> oop
16:34:55 <chreekat> I give up :P
16:34:56 <Nereid> :P
16:35:01 <Nereid> > let add = (+) in 1 `add` 2
16:35:03 <lambdabot>   3
16:35:11 <Nereid> > let 2 + 2 = 5 in 2 + 2
16:35:13 <lambdabot>   5
16:35:18 <chreekat> kaching
16:35:53 <FireFly> > let 2 + 2 = 5 in 2 + 3
16:35:54 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
16:36:12 <FireFly> Ah, right, the numbers are just for pattern-matching
16:36:19 <startling> yeah, it's defining (+)
16:36:25 <Jafet> @let 0 = 1
16:36:27 <lambdabot>  Defined.
16:36:36 <Nereid> > 0
16:36:38 <lambdabot>  Terminated
16:36:40 <Nereid> haha
16:36:41 <FireFly> Also I just realised that wasn't a very clever test.. since 2 + 3 would end up as 5 if it'd somehow use the outer (+)
16:36:49 <Nereid> > 0
16:36:51 <lambdabot>   0
16:37:23 <Nereid> I wonder how that's legal
16:37:25 <Nereid> 0 = 1
16:37:59 <startling> FireFly: haha
16:38:04 <mauke> > let True = False in 2
16:38:04 <latro`a> > (+) 0 1
16:38:06 <lambdabot>   2
16:38:06 <lambdabot>   can't find file: L.hs
16:38:10 <latro`a> oh dear
16:38:13 <Nereid> oh I get it.
16:38:19 <mauke> > let True = () in 2
16:38:21 <lambdabot>   Couldn't match expected type `GHC.Types.Bool' with actual type `()'
16:38:28 <Nereid> > let (x:xs) = [] in 5
16:38:30 <lambdabot>   5
16:38:52 <startling> > let a : b = [a, b] in [1, 2]
16:38:54 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
16:38:59 <startling> errr
16:39:00 <Nereid> gj
16:39:22 <Nereid> > let !True = False in 2
16:39:24 <lambdabot>   *Exception: <interactive>:3:5-17: Non-exhaustive patterns in pattern binding
16:39:29 <startling> > let a : b = False in 1 : 2
16:39:31 <lambdabot>   Couldn't match expected type `[t0]'
16:39:31 <lambdabot>              with actual type `GHC.Type...
16:39:33 <Nereid> @let !0 = 1
16:39:33 <lambdabot>   BangPatterns is not enabled
16:39:36 <Nereid> aw.
16:40:01 <startling> weird, so you can redefine type constructors with "let" but only make them constructors of their own type?
16:40:06 <Nereid> you can't redefine constructors
16:40:09 <Nereid> it's pattern matching
16:40:21 <startling> > let True = False in True
16:40:23 <lambdabot>   True
16:40:27 <startling> ah
16:40:41 <Nereid> > let x@True = False in x
16:40:43 <lambdabot>   *Exception: <interactive>:3:5-18: Irrefutable pattern failed for pattern x@...
16:42:00 <Nereid> and writing "let !0 = 1" gives a non-exhaustive patterns error in ghci
16:51:24 <Peaker> does GHC 7.6 have any facilities for some info on stack overflows?
16:51:31 <Peaker> what context it overflowed in?
16:51:51 <fengshaun> hi all, any other more advanced books on haskell other than RWH and LYAH?
16:52:51 <sm__> fengshaun: I don't know if it's more advanced, but have you see Haskell School of Expression ?
16:53:03 <fengshaun> no, I'll check it out now
16:53:04 <sm__> seen. More code in it perhaps
16:53:15 <sm__> old thought
16:53:25 <sm__> though.
16:53:54 <fengshaun> sounds interesting
16:55:01 <fengshaun> thanks for the suggestion
16:55:17 <sm__> np
17:06:34 <liyang> fengshaun: at that point you can start reading some of the classic papers on Haskell…
17:06:56 <fengshaun> liyang, those are very math heavy :(
17:07:22 <fengshaun> I checked a few papers, couldn't get through much given I seriously dislike reading stuff on screen!
17:07:58 <liyang> Don't expect to be able to understand everything in them on the first read. Also, print it out (or put it on a Kindle), grab a cup of coffee, and sit back.
17:08:41 <liyang> You can always ask questions about them here.
17:14:20 <johnw> @tell clahey unfoldM = (foldr mplus mzero .) . unfoldr
17:14:20 <lambdabot> Consider it noted.
17:15:28 <Nereid> :t unfoldr
17:15:30 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
17:15:59 <Nereid> :t \f z -> foldr f z .: unfoldr
17:16:01 <lambdabot> (a -> b -> b) -> b -> (b1 -> Maybe (a, b1)) -> b1 -> b
17:19:20 <fengshaun> liyang, sounds like a good idea, thanks!
17:20:19 <fengshaun> :t (.:0
17:20:22 <lambdabot> parse error (possibly incorrect indentation)
17:20:23 <fengshaun> :t (.:)
17:20:25 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
17:20:32 <fengshaun> weird operator
17:21:04 <fengshaun> nevertheless useful
17:21:32 <liyang> :t fmap . fmap
17:21:33 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:23:38 <rwbarton> @type enum
17:23:40 <lambdabot> Not in scope: `enum'
17:25:04 <rwbarton> is there no lens iso for fromEnum/toEnum?
17:25:24 <johnw> Peaker: yes
17:25:41 <johnw> chreekat: sure you can
17:25:54 <liyang> rwbarton: file a pull request. :)
17:26:33 <shachaf> rwbarton: Not as far as I know.
17:26:39 <Nereid> fengshaun:
17:26:42 <Nereid> :t (.) . (.)
17:26:44 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
17:26:46 <Nereid> ahh crap
17:26:48 <shachaf> Enum is slightly evil, to be fair. But it's probably still reasonable.
17:26:52 <Nereid> :t (Prelude..) . (Prelude..)
17:26:53 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
17:27:03 <johnw> shachaf: i no longer object to (f .) . g
17:27:03 <Nereid> :t (Prelude..) . (Prelude..) . (Prelude..) . (Prelude..) . (Prelude..)
17:27:05 <lambdabot> (b -> c) -> (a -> a1 -> a2 -> a3 -> a4 -> b) -> a -> a1 -> a2 -> a3 -> a4 -> c
17:27:10 <johnw> it clearly means to compose f with the function returned by g
17:27:15 <Nereid> :)
17:27:23 <shachaf> johnw: Sure.
17:27:29 <Nereid> :t \f g -> (((f .) .) .) . g
17:27:31 <shachaf> johnw: I don't object to (f .) . g
17:27:31 <lambdabot> (Functor f3, Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 (f3 a))) -> f (f1 (f2 (f3 b)))
17:27:35 <johnw> oh, ok
17:27:44 <shachaf> johnw: I just object to people who write code using that idiom.
17:27:53 <startling> haha
17:28:01 <johnw> i've stopped using .:, in fact, because (f .) . g looks a bit more obvious
17:28:05 <crdueck> @src filter
17:28:05 <lambdabot> filter _ []     = []
17:28:06 <lambdabot> filter p (x:xs)
17:28:06 <lambdabot>     | p x       = x : filter p xs
17:28:06 <lambdabot>     | otherwise = filter p xs
17:28:09 <crdueck> @src takeWhile
17:28:09 <lambdabot> takeWhile _ []                 =  []
17:28:10 <lambdabot> takeWhile p (x:xs) | p x       =  x : takeWhile p xs
17:28:10 <lambdabot>                    | otherwise =  []
17:28:30 <johnw> heh, every time I see "f []; f (x:xs)" now, I see a foldr at work :)
17:28:42 <startling> johnw: I know!
17:28:54 <shachaf> @src foldl
17:28:55 <lambdabot> foldl f z []     = z
17:28:55 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
17:29:03 <johnw> yeah, there too
17:29:25 <shachaf> Turning that into a foldr isn't completely obvious.
17:29:39 <rwbarton> @src listToMaybe
17:29:40 <lambdabot> listToMaybe []        =  Nothing
17:29:40 <lambdabot> listToMaybe (a:_)     =  Just a
17:29:54 <shachaf> rwbarton: Well, that one is obviously a foldr.
17:29:57 <shachaf> @src last
17:29:58 <lambdabot> last [x]    = x
17:29:58 <lambdabot> last (_:xs) = last xs
17:29:58 <lambdabot> last []     = undefined
17:29:58 <rwbarton> wait that's not the one i wanted
17:30:03 <johnw> foldl f a bs = foldr (\b g x -> g (f x b)) id bs a
17:30:04 <rwbarton> @src tail
17:30:04 <lambdabot> tail (_:xs) = xs
17:30:04 <lambdabot> tail []     = undefined
17:30:35 <shachaf> Writing tail as a foldr is like writing pred in the usual lambda calculus encoding of Nat.
17:34:11 <startling> shachaf: how about as a traversal? ;)
17:34:32 <shachaf> startling: Ugh. Don't talk to me about traversals.
17:34:46 * shachaf wonders whether you-know-who has a hilight on "traversal".
17:34:58 * startling traverses shachaf, trapping him in the IO monad
17:35:12 <crdueck> @pl \f x -> f (x^._2) x
17:35:12 <lambdabot> (line 1, column 16):
17:35:12 <lambdabot> unexpected '_'
17:35:12 <lambdabot> expecting simple term
17:35:18 <shachaf> startling: In the IO monad you're free to use pure functions.
17:35:30 <shachaf> startling: Whereas from pure functions you can't do I/O.
17:35:35 <shachaf> "who's trapped now?!"
17:36:00 * startling sticks him in Const instead
17:36:17 <rwbarton> @@ @pl @djinn @type \f x -> f (x^._2) x
17:36:20 <lambdabot>  Error : Class not found : Field2
17:36:24 <rwbarton> oh yeah
17:36:44 <startling> shachaf: can't get out of that one, can you
17:37:00 <shachaf> @let znd f (x,y) = (,) x <$> f y
17:37:02 <lambdabot>  Defined.
17:37:04 <shachaf> @@ @pl @djinn @type \f x -> f (x^._2) x
17:37:06 <lambdabot>  Error : Class not found : Field2
17:37:10 <shachaf> @@ @pl @djinn @type \f x -> f (x^.znd) x
17:37:12 <lambdabot>  f = (`ap` snd) . (. fst) . (. (,)) . ap
17:40:49 <edwardk> rwbarton: hrmm thats a pretty good one. its a bit of a lie i suppose. in the case of Float, etc. but good nonetheless
17:40:50 <edwardk> :t char
17:40:52 <lambdabot> Char -> Doc
17:40:54 <edwardk> :t enum
17:40:56 <lambdabot> Not in scope: `enum'
17:41:21 <edwardk> :t iso toEnum fromEnum toEnum fromEnum
17:41:23 <lambdabot>     Couldn't match expected type `Int' with actual type `a0 -> Int'
17:41:24 <lambdabot>     In the fourth argument of `iso', namely `fromEnum'
17:41:24 <lambdabot>     In the expression: iso toEnum fromEnum toEnum fromEnum
17:41:27 <edwardk> :t iso toEnum fromEnum
17:41:29 <lambdabot> (Enum a, Functor f, Isomorphic k) => k (a -> f a) (Int -> f Int)
17:41:57 <shachaf> edwardk: Everything's a lie in the case of Float.
17:42:04 <edwardk> > let enum = iso toEnum fromEnum in LT^.from enum
17:42:07 <lambdabot>   0
17:42:11 <edwardk> > let enum = iso toEnum fromEnum in GT^.from enum
17:42:14 <lambdabot>   2
17:42:27 <shachaf> @let review = view.from
17:42:30 <lambdabot>  Defined.
17:42:41 <shachaf> @let enum = iso toEnum fromEnum
17:42:44 <lambdabot>  Defined.
17:42:51 <shachaf> @ty review enum
17:42:52 <lambdabot> Enum t => t -> Int
17:43:02 <edwardk> > review enum LT
17:43:05 <lambdabot>   0
17:43:07 <edwardk> > review enum 'a'
17:43:10 <lambdabot>   97
17:43:19 <lispy> I've been locked out of my gmail all day right? I finally get back in and the first thing I see is the libraries@ thread about (&). Oh man. Maybe I was better off with my gmail blocked.
17:43:26 <Nereid> :t view enum
17:43:27 <lambdabot> Enum b => Int -> b
17:43:28 <edwardk> lispy: hahaha
17:43:29 <shachaf> lispy: You were.
17:43:46 <Nereid> haha
17:45:40 <lispy> edwardk: is the TH part of lens separate from the main package?
17:45:45 <edwardk> no
17:45:55 <lispy> edwardk: any plans to separate them?
17:45:57 <edwardk> lens requires a ton of ghc specific extensions, so there is no point in hiding it
17:46:11 <edwardk> nope
17:46:29 <Nereid> part of the justification is that a library can provide lenses without even depending on the lens package
17:46:52 <lispy> Yeah, but what if you want to derive your lenes without depending on the lens library?
17:46:54 <edwardk> and as Nereid pointed out, you can make your library provide lenses without incurring a dependency on lens at all.
17:47:03 <Nereid> lispy: too bad :v
17:47:20 <edwardk> :t \ f (a,b) -> (,) a <$> f b
17:47:22 <shachaf> lispy: There was talk of having a function that printed the generated lenses so you could paste them into your file.
17:47:22 <lambdabot> Functor f => (t -> f a) -> (a1, t) -> f (a1, a)
17:47:27 <edwardk> ^-- look a wild lens appears!
17:47:41 <Nereid> shachaf: do it
17:47:43 * startling sends out his ODDISH
17:47:47 <edwardk> note that that function didn't depend on lens.
17:47:49 <lispy> It's starting to look a little bit like perl!
17:47:54 <shachaf> Nereid: NO U
17:47:57 <Nereid> :v
17:48:05 <edwardk> lispy: you can use fmap instead of <$> if you want =P
17:48:24 <startling> then you don't even need to depend on base!
17:48:26 <startling> oh wait
17:48:42 <shachaf> Hugs-compatible lenses.
17:48:47 <edwardk> anyways, i'd be happy to take a patch that generated the code from the lenses based on the Control.Lens.TH code so you could paste them into your project without incurring the TH issues
17:48:58 <shachaf> Nereid: Now's your chance!
17:49:10 <Nereid> but I have other things that need doing :(
17:49:12 <edwardk> shachaf: lens-family which is mostly lens compatible is pretty much there =P
17:49:17 <startling> it's usually trivial to write those lenses anyway
17:49:23 <edwardk> startling: there is that
17:49:35 <shachaf> startling: That's exactly why you *don't* want to do it by hand.
17:49:44 <startling> shachaf: well yes
17:49:45 <johnw> edwardk: back; i find your version control monad quite intriguing
17:50:01 <edwardk> johnw: did you get a chance to read what i had to say about 'record'?
17:50:07 <johnw> yes
17:50:14 <johnw> that sounds pretty... awesmoe
17:50:21 <shachaf> 'record'?
17:50:22 <edwardk> record is what makes it worth having. otherwise its just a pretty crappy parallelism strategy ;)
17:50:25 <johnw> do you have live, smallish examples of it at work?
17:50:45 <edwardk> johnw: not really. daan leijen has some nice benchmarks from his c# version though
17:50:46 <lispy> > let 💩 = 1 in 💩
17:50:46 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:51:01 <johnw> oh, and I ran into Codensity from a completely different direction last night
17:51:03 <edwardk> that was where the idea for record came from
17:51:18 <edwardk> shachaf: do you know 'revisions'?
17:51:20 <lispy> We should define 💩 = flip ($)
17:51:22 <johnw> it was used to define a Monad from a functor with no adjoint
17:51:29 <shachaf> Vaguely.
17:51:29 <Peaker> BAH! I just wasted a lot of time debugging a stack overflow that was due to my Ord defining (<) and not (<=)
17:51:30 <johnw> is that a pile of dung?
17:51:33 <johnw> with eyes?
17:51:34 <Peaker> man, that sucks
17:51:40 <lispy> johnw: yup
17:51:51 <copumpkin> @ let 💩 = flip ($)
17:51:59 <shachaf> Peaker: That's why I want there to be a "minimal complete definition" warning!
17:52:01 <copumpkin> @ let (💩) = flip ($)
17:52:03 <johnw> really, Unicode?  you can have a smiling pile of *dung*, but no subscript latin capital F????
17:52:04 <edwardk> basically record takes a fork/join task in it, and turns it into an incremental computation where it'll recycle answers from branches where the inputs haven't changed or break them down until it gets to where that holds
17:52:12 <copumpkin> @let (💩) = flip ($)
17:52:14 <lambdabot>  Defined.
17:52:18 <johnw> lol
17:52:25 <Peaker> shachaf, I agree! But until that's implemented, I think it would be much more sane to have only "compare" in Ord, and have the rest be functions
17:52:34 <lispy> that's my answer to the bikeshed currently on libraries@
17:52:37 <shachaf> Peaker: Well, that breaks some code, or something.
17:52:47 <edwardk> record :: MonadRev m => m a -> m (a, m a)
17:52:49 <shachaf> Peaker: Anyway, it can't be that complicated to implement.
17:52:50 <lispy> @type zipWith (💩)
17:52:51 <lambdabot> fd:9: commitBuffer: invalid argument (invalid character)
17:52:57 <lispy> hmm
17:53:05 <lispy> lambdabot: why you no 💩
17:53:06 <startling> johnw: there should really be subscript for all the unicode codepoints
17:53:19 <shachaf> Peaker: If you could just say class Blah a where {-# MINIMAL foo #-} {-# MINIMAL bar, vaz #-} ... , would that be sufficient?
17:53:25 <Peaker> shachaf, yeah, this is one of those places where the Haskell people choose convenience over safety -- and thus I Was left with a very very inconvenient debugging session that's costed me more than all the savings I ever got from being able to choose between multiple method impls
17:53:55 <Peaker> shachaf, yeah, it sounds sufficient
17:53:58 <shachaf> Peaker: Where if you had all of the methods in any of the specified sets implemented, it wouldn't warn.
17:54:16 <lispy> Peaker: yeah, debugging broken type classes is one of the biggest wastes of time I've experienced with Haskell.
17:54:28 <Peaker> it is especially painful to crash on such things though -- because Haskell is so awful at runtime debugging
17:54:44 <shachaf> Peaker: Did -xc not help here?
17:54:45 <lispy> @tell Cale any idea why lambdabot is choking on unicode characters?
17:54:45 <lambdabot> Consider it noted.
17:54:53 <lispy> @tell Cale for instance, 💩
17:54:53 <lambdabot> Consider it noted.
17:54:54 <Peaker> shachaf, what is -xc?
17:54:58 <shachaf> @where rts-xc
17:54:59 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
17:54:59 <copumpkin> > 5 💩 (+1)
17:55:00 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:55:01 <shachaf> Peaker: Stack traces.
17:55:03 <johnw> shachaf: i think the reason why tail doesn't lend itself well to foldr is that it's not a recursive function
17:55:07 <copumpkin> it's outside the BMP I think
17:55:13 <Peaker> shachaf, I looked at the stack traces ticket which seems pessimistic
17:55:17 <shachaf> johnw: OK, how about
17:55:26 <shachaf> @src init
17:55:27 <lambdabot> init [x]    = []
17:55:27 <lambdabot> init (x:xs) = x : init xs
17:55:27 <lambdabot> init []     = undefined
17:55:37 <shachaf> Hmm, maybe that one is too easy.
17:55:41 <johnw> yeah
17:55:46 <johnw> finding the base case there is trivial
17:55:48 <shachaf> Peaker: I was under the impression -xc works for things like this.
17:55:54 <Peaker> shachaf, I'll give it a shot
17:56:03 <johnw> -xc is pretty darn good in 7.6
17:56:08 <shachaf> How about reverse?
17:56:09 <johnw> not quite so much in 7.4
17:56:12 <shachaf> Hmm, reverse is kind of easy too.
17:56:22 <johnw> yeah
17:56:24 <johnw> come on man
17:56:26 <Peaker> johnw, I'm using 7.6
17:56:44 <Peaker> shachaf, I went in here and asked if there's stack traces about 1.5 hours ago when I started debugging, heh
17:56:51 <Peaker> then I googled a bit and my conclusion was "not yet"
17:57:02 * Peaker is now recompiling with profiling to have rtsopts and try -xc out
17:57:12 <johnw> Peaker: -xc is actually really godo
17:57:17 <johnw> and if it's not good enough, try Hat
17:57:20 <johnw> @hoogle hat
17:57:21 <lambdabot> package HaTeX
17:57:21 <lambdabot> package HaTeX-meta
17:57:21 <lambdabot> package hatt
17:57:22 <rwbarton> @faq can Haskell provide stack traces if I build with -auto-all -prof -rtsopts -osuf .p_o and run with +RTS -xc ?
17:57:22 <lambdabot> The answer is: Yes! Haskell can do that.
17:57:35 <latermuse> :D
17:57:38 <johnw> http://hackage.haskell.org/package/hat
17:57:42 <johnw> not only will hat produce stack traces
17:57:45 <shachaf> Hmm, -auto-all is deprecated.
17:57:53 <johnw> you can interactively unwind them after the fact :)
17:58:08 <johnw> with a colorize curses GUI and everything
17:58:08 <shachaf> @where rts-xc
17:58:09 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
17:58:13 <johnw> it's kind of awesome
17:58:21 <rwbarton> I wonder how much hackery I'd need to add to my awful exception TH hack to get that
17:58:26 <rwbarton> probably an infinite amount
17:58:37 <johnw> rwbarton: you just need template template haskell
17:58:38 <shachaf> --make is deprecated too
17:58:43 <shachaf> Well, no it's not.
17:58:46 <shachaf> But it's unneeded.
17:58:55 <rwbarton> while you're at it, add a description of what it does as a shell comment
17:58:56 <shachaf> @where+ rts-xc ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
17:58:56 <lambdabot> Okay.
17:59:05 <shachaf> rwbarton: You should add that.
17:59:10 <edwardk> rwbarton: added enum to Control.Lens.Iso with suitable caveats about the range
17:59:54 <startling> johnw, can I use agda's unicode stuff outside of agda-mode?
18:00:01 <johnw> absolutely
18:00:03 <shachaf> This is going to be a big lens release.
18:00:05 <rwbarton> @where+ rts-xc ghc -prof -fprof-auto -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc    # print stack traces on unhandled exceptions
18:00:05 <lambdabot> It is stored.
18:00:10 <johnw> C-x RET C-\ Agda RET
18:00:17 <johnw> I use it in ERC
18:00:19 <edwardk> shachaf: they usually are these days
18:00:26 <startling> oh, that's set-input-method, isn't it
18:00:27 <startling> neat
18:00:29 <johnw> yeah
18:00:37 <Peaker> shachaf, johnw GHC 7.6 -xc leads me all the way to my Map.insert that was bad -- but it doesn't show the broken Ord instance itself
18:00:40 <shachaf> edwardk: It'll be even bigger if this taking thing doesn't get worked out. :-)
18:00:50 <edwardk> if we could just get taking to work i'd be happy with shipping it
18:00:54 <johnw> Peaker: -xc is only ever going to be approximate
18:00:57 <startling> for some reason set-input-method TeX doesn't let me do x_n et al
18:01:04 <shachaf> johnw: That key combination parts the IRC channel you're in, right?
18:01:10 <johnw> Peaker: Marlow gave a presentation on how it works, if you're interested
18:01:18 <Peaker> in this case, my stack trace should have been Ord's default implementation loop
18:01:22 <johnw> shachaf: no, I parted because ERC gets really slow when the buffer gets too large
18:01:31 <Peaker> so I guess Ord's default implementations don't have these annotations?
18:01:33 <johnw> then Emacs can't keep up with my typing anymore
18:01:53 <Peaker> johnw, sure, yeah :)
18:02:02 <startling> johnw: there's a way to delete stuff. I forget it, but there's a way
18:02:12 <johnw> Peaker: http://www.youtube.com/watch?v=J0c4L-AURDQ
18:02:29 <johnw> erc-truncate-buffer?
18:02:37 <chreekat> johnw: Ah, £ is a symbol, of course. thanks
18:02:53 <shachaf> Peaker: What about -fprof-auto-calls?
18:03:05 <johnw> erc-truncate-mode; ok, I've enabled it, let's see how it does
18:04:50 <ew_> hey
18:05:05 <ew_> anyone here worked with linear programming in haskell?
18:05:53 <Peaker> shachaf, and then +RTS -xc?
18:05:58 <shachaf> Peaker: Yes.
18:06:05 <Peaker> shachaf, trying now.. each recompile takes a few minutes.. too much TH in there
18:06:12 <johnw> ew_: http://haskell.1045720.n5.nabble.com/Linear-programming-in-Haskell-td3091695.html
18:06:23 <Peaker> I need TH for my lenses and a few auto-instances.. that slows compilations down so much :(
18:06:38 <Peaker> I ought to move my records to their own tiny modules just for the TH compiles to be faster
18:06:50 <johnw> like a Types module...
18:06:59 <Peaker> yeah, I try to avoid those if I can
18:07:02 * hackagebot cabal-rpm 0.6.6 - RPM package creator for Haskell Cabal-based packages  http://hackage.haskell.org/package/cabal-rpm-0.6.6 (JensPetersen)
18:07:12 <edwardk> Peaker: i find it funny that lens doesn't use the TH code to generate any of its lenses
18:07:42 <Peaker> shachaf, seems same
18:07:50 <shachaf> Peaker: Hmm, OK.
18:08:00 <Peaker> edwardk, for records it would be a real pain, though
18:08:02 <shachaf> Maybe you'd've had to compile containers with that flag to gain anything.
18:08:22 <shachaf> Nor does lens use lens.
18:08:23 <Peaker> shachaf, my problem is loop in the Ord instance of my key type which is my own record
18:08:37 <Peaker> shachaf, (not in containers)
18:08:43 <shachaf> Peaker: Right, but it's getting attributed to Map.insert
18:08:49 <edwardk> Peaker: i'm not encouraging it as a general style, but i understand your pain =)
18:08:56 <shachaf> -fprof-auto-calls should add annotations to function calls
18:09:13 <shachaf> But the (<) call is happening in containers code.
18:09:15 <Peaker> shachaf, actually it gets attributed to my very specific code that wraps Map.insert
18:09:16 <edwardk> in general _ANYTHING_ TH tends to cause a huge drag on the build while it goes off and loads all the modules
18:10:07 <shachaf> edwardk: Build is broken, by the way.
18:10:15 <edwardk> should have just fixed it
18:10:21 <shachaf> Ah.
18:10:30 <edwardk> i added more tests for non
18:10:31 <shachaf> I guess you're getting those annoying emails.
18:10:38 <edwardk> from travis?
18:10:39 <shapr> I still think the easiest way to do runtime code reloading is to have Main.main run inside the TH compile loop where it has access to all the type tables anyway.
18:10:50 <edwardk> i think i only have it set to pop into #haskell-lens
18:11:04 <shachaf> Hmm, whenever I break of fix the build I get an email.
18:11:13 <edwardk> i have all my travis emails filtered so they only show on edge transitions i think
18:11:28 <shachaf> Right.
18:11:33 <shachaf> As far as I can tell that's the default.
18:11:39 <shachaf> Since I don't really have an account or anything. :-)
18:14:02 <shachaf> djahandarie: Did you know I was you?
18:14:11 <djahandarie> Say what?
18:14:18 <shachaf> djahandarie: 18:13 <copumpkin> I thought you were djahandarie
18:14:37 <copumpkin> shachaf, typoclass, geheimdienst, djahandarie
18:14:39 <copumpkin> what's the difference
18:15:21 <edwardk> oh, great, there is a binding to gnuplot.
18:15:35 <copumpkin> is that a new scheme distribution?
18:15:35 <edwardk> oh, wait, it was written by Henning.
18:15:36 <copumpkin> >_>
18:15:39 <copumpkin> lol
18:15:41 <djahandarie> Has anyone seen geheimdienst recently?
18:15:49 <shachaf> djahandarie: Come to #-blah
18:15:53 <copumpkin> djahandarie: did you check the mirror?
18:17:13 <startling> copumpkin: haha
18:17:32 <copumpkin> djahandarie: he's known as typoclass these days :)
18:17:49 <djahandarie> Oh, really? I never noticed that transition.
18:18:23 <djahandarie> Know thy self, know thy enemy, I know neither, apparently.
18:20:58 <zachel> Foxes ?
18:28:58 <neutrino_> hi
18:29:14 <neutrino_> is there something like Data.HashTable which does not require a hashing function?
18:29:51 <copumpkin> neutrino_: how would that work?
18:30:03 <simpson> neutrino_: You've seen Data.Map, right?
18:30:16 <mpu> neutrino_: Data.Set ?
18:31:27 <neutrino_> simpson: looking, thanks
18:31:35 <neutrino_> it hasn't occured to me to search for "map"
18:31:59 <neutrino_> mpu: looking at that again, too, thanks
18:37:10 <mpu> How come I can catch the exception thrown by head with catch (in Control.Exception)?
18:37:25 <mpu> Is this module using some kind of magic?
18:37:47 <mauke> that sounds like a bad idea
18:37:56 <mauke> er
18:38:10 <mauke> mpu: the "magic" is exception handling
18:38:29 <mauke> also, asynchronous exceptions
18:38:45 <mauke> @src error
18:38:45 <lambdabot> error s = throw (ErrorCall s)
18:38:50 <mpu> mauke is it in the Haskell standard? Haskell has monads, why providing exception handling?
18:38:52 <camio> mpu: Why do you think that is bad?
18:39:09 <mauke> I don't think it's in the report
18:39:22 <mauke> and IO is a monad
18:39:23 <mpu> camio: 'error' in my opinion should stop the program
18:39:51 <mpu> mauke, I can catch exceptions thrown in pure code (say head)
18:40:11 <mauke> yes
18:40:17 <camio> mpu: I wonder why. Does it break the semantics of IO somehow?
18:40:29 <mpu> camio, I don't know
18:40:33 <shachaf> "the semantics of IO"
18:40:39 <mauke> >implying
18:40:49 <camio> Yeah, it was a bit of a trick question.
18:40:58 <mpu> I am just surprised that this is provided by haskell when there is no 'concept' of exception explained properly anywhere.
18:41:30 <mpu> Except in monads (say MonadPlus monads) where we can simulate them.
18:42:13 <camio> mpu: I think calling this exception handling is misleading. Perhaps it would be better to call it bottom handling.
18:42:14 <mauke> http://community.haskell.org/~simonmar/papers/async.pdf
18:42:25 <mauke> no, they're exceptions
18:42:26 <mpu> camio, sounds even worse
18:42:40 <mpu> mauke, thanks
18:42:50 <luite> these are not asynchronous exceptions though
18:42:55 <luite> but regular ones
18:43:27 <mauke> looks asynchronous to me
18:44:00 <camio> Semantically, error creates _|_. We cannot detect all _|_'s, but the ones we can dedect can be handled in the IO monad. I think this is a case of "since we *can*, lets do it".
18:44:41 <mpu> ok I see
18:45:02 <mpu> sounds not very pretty though
18:45:20 <camio> mpu: I agree. I can't think of a good use case.
18:50:51 <cl1> what does => mean in a type definition? (e.g. digit :: Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m Char)
18:52:12 <camio> cl1: When I read a => b, I see assuming "a" then "b".
18:52:39 <cl1> well when I type :t digit in the interactive it spits out that
18:52:56 <cl1> where as :t putStrLn outputs String -> IO()
18:53:06 <mauke> cl1: :t show
18:53:11 * lispy is surprised to learn so many programmers actually *like* IDEs
18:53:24 <luite> hm why is that surprising?
18:53:30 <cl1> :t show
18:53:32 <lambdabot> Show a => a -> String
18:53:41 <cl1> :t digit
18:53:43 <lambdabot> Not in scope: `digit'
18:54:11 <cl1> :t Text.ParserCombinators.Parsec.digit
18:54:13 <lambdabot> Text.Parsec.Prim.Stream s m Char => Text.Parsec.Prim.ParsecT s u m Char
18:54:18 <cl1> that
18:54:22 <lispy> luite: I worked at a company for a few years where I had to use Visual Studio and I really disliked it. At other points in time I've been forced to leave emacs/vim for intellij and eclipse. It's never been a good experience and I always go back to "editors" ASAP.
18:54:46 <cl1> camio, so does that mean assuming a then b?
18:55:00 * cl1 likes his visual studio
18:55:04 <lispy> luite: So it suprises me to learn that some folks do actually like IDEs
18:55:19 <luite> hmm, i like eclipse and intellij if i have to program java
18:55:45 <luite> they know a lot more about what i'm doing than emacs with haskel-mode :)
18:56:17 <lispy> luite: have you tried ghc-mod?
18:56:44 <camio> cl1: If you expand out the foralls, you get: for all types s, u, and m, if there is a typeclass instance Stream s m Char, then digit has the type ParsecT s u m Char. Does that make sense?
18:57:44 <mpu> cl1, it is not the functional arrow (meaning, digit is not a function), what is at the left of => is a set of contraints over free type variables appearing on the right of it.
18:58:06 <luite> lispy: i tried it a while ago but it crashed emacs all the time
18:58:21 <lispy> I wonder how much of the "IDE magic" we could bundle up into "Haskell Editions" of Vim and/or emacs.
18:58:43 <mpu> I want instant typechecking!
18:58:53 <lispy> luite: Ah, bummer. Did you try eclipse with the eclipseFP plugin?
18:59:13 <luite> no not yet
18:59:19 <camio> cl1: Do you have a C++ background?
19:00:01 <luite> lispy: do you have lots of customization in your vim or emacs etup?
19:00:08 <lispy> luite: nope
19:00:25 <lispy> luite: https://github.com/dagit/dotfiles
19:00:29 <johnw> lispy: quite a bit
19:00:37 <rwbarton> can I have a single .cabal project with two executables, where one is a build-tool of the other?
19:00:37 <lispy> my vimrc is 55 lines
19:00:41 <johnw> lispy: for the Common Lisp world I created ReadyLisp, which did just that
19:00:56 <johnw> (a one-click Emacs bundle for Mac that included everything you'd want for CL development on Emacs)
19:00:57 <cl1> camio, yes it does! thanks
19:01:18 <lispy> johnw: oh interesting. I used to do a lot of common lisp, but I missed that package.
19:01:29 <johnw> http://newartisans.com/2007/11/ready-lisp-for-os-x-leopard/
19:01:36 <luite> lispy: in that case wouldn't some IDE with vim keymap customization and basic scripting work for you?
19:01:46 <johnw> dunno if it works on 10.8
19:02:18 <lispy> luite: if it supported console modes so I could run it under tmux and if I could quickly get it out of the way and reopen it
19:02:32 <luite> hm
19:02:52 <lispy> I do have an IDE, but not in the traditional sense
19:03:03 <lispy> The entire computer (mostly the commandline) is my ide
19:03:07 <cl1> lispy, visual studio does more than just help you develop code, it also has integrated source control management, and if you have permissions, it allows you to manage the source control server ...
19:03:10 <luite> you compile on a server?
19:03:22 <cl1> it also has built in features for project management as well
19:03:31 <luite> cl1: emacs also has hat of course
19:03:33 <luite> that
19:03:57 <cl1> but it comes that way, you don't have to turn any of it on or download it
19:04:09 <lispy> luite: I usually run tmux where the compiler is. Whether it's a server or not is usually not that important
19:04:16 <luite> cl1: does it support github?
19:04:26 <johnw> shachaf: does foldr do CTO?
19:04:29 <johnw> TCO
19:04:41 <shachaf> johnw: "TCO" isn't quite a concept that makes sense in GHC.
19:04:45 <mpu> lispy: why is the compiler not on your computer?
19:04:47 <johnw> no?
19:04:48 <cl1> no, it supports svn and tfs
19:04:49 <shachaf> At least, not in the same way that it does in other languages.
19:05:04 <johnw> say I make my f strict, will foldr have constant stack usage?
19:05:36 <cl1> lispy, only tfs out of the box
19:05:42 <cl1> err luite
19:05:47 <lispy> mpu: I use a different virtual machine for almost every project at work. Mostly because that's a nice way to separate them.
19:05:48 <johnw> i.e., will it internally decay to iteration, or must it always be O(n)?
19:06:16 <lispy> But, I use console based stuff when I work locally
19:06:23 <lispy> I use gvim on windows though
19:06:23 <geekosaur> how does TCO apply to graph reduction?
19:06:52 <lispy> johnw: do you know about deforestation and fusion?
19:06:53 <johnw> geekosaur: i don't know, that's why I ask
19:07:01 <mpu> lispy, That's pretty hardcore separation... I use directories for this but you probably have some good reasons :). Cool you can use Haskell in your job though.
19:07:03 <johnw> i know about fusion, I've heard of deforestation
19:07:06 <shachaf> johnw: Well, think of in terms of simple substitution.
19:07:15 <shachaf> f x = g x x
19:07:24 <shachaf> g x y = (2*x) + (3*y)
19:07:33 <geekosaur> johnw, more to the point, it is not clear that asking if functions do TCO is *meaningful* in a system that does graph reduction
19:07:40 <geekosaur> it's a procedural concept
19:07:40 <shachaf> If you evaluate (f 5), the very first thing you do is turn it into (g 5 5)
19:07:48 <johnw> geekosaur: ah, that's a good enough answer for me for now
19:07:52 <lispy> mpu: it makes a lot of sense when two projects both require the same software configured differently (for instance, apache)
19:07:59 <luite> cl1: are there plugins for git or darcs?
19:08:21 <lispy> mpu: if you build a little infrastructure around working this way it's also efficient to create new VMs
19:08:26 <geekosaur> there are equivalent things that cn happen, but they aren't qite in the same conceptual space
19:08:31 <geekosaur> see stream fusion as an example
19:08:31 <johnw> shachaf: ok
19:08:46 <QinGW`> Use newtype to define a new type, which things will be derived from source type?
19:09:36 <cl1> i lied, git works in visual studio 2012
19:09:49 <shachaf> johnw: In one sense you're always doing TCO, maybe.
19:10:09 <QinGW`> It would not be instance of typeclass of original type.
19:10:38 <lispy> mpu: re: getting to use haskell, if you want advice about how to get more haskell allowed in the work place, I have tips
19:10:59 * cl1 wants tips
19:11:08 <shachaf> johnw: You should evaluate some Haskell expressions by hand, respecting non-strict semantics, and think about how "TCO" would change what you're doing.
19:11:09 <mpu> lispy: That's fine, I'm in a research lab :), thanks though.
19:11:19 <johnw> shachaf: that's a great idea
19:11:21 <lispy> mpu: nice
19:11:22 <johnw> thanks
19:11:49 <lispy> cl1: One easy inroad is using Haskell to automate tasks and parse things.
19:11:58 <johnw> another is prototyping
19:12:01 <shachaf> johnw: This also has to do with why stack traces are hard. :-)
19:12:31 <lispy> cl1: if you have a need for some tool in your workflow, make a haskell thing to solve it. Share it with co-workers if they do similar things.
19:12:58 <lispy> johnw: right. prototyping and compiler related tasks are usually an easy win in Haskell
19:13:01 <johnw> shachaf: have you played with hat yet?
19:13:07 <shachaf> Nope.
19:13:22 <johnw> it's kind of magical
19:13:40 <lispy> cl1: as an example of automating a workflow. In grad school I made an embedded domain specific language for writing procmail rc files because I could never get the syntax right by hand.
19:15:03 <lispy> of course, these days we all use gmail so it's not all that necessary now
19:15:40 <lispy> Lately though, I've been thinking about writing an email client in Haskell
19:15:59 <shachaf> How to write an email client in Haskell:
19:16:07 <shachaf> (1) Write any program in Haskell
19:16:08 <shachaf> (2) Wait
19:16:09 <lispy> Probably something like sup, but perhaps not cli based
19:16:27 <lispy> shachaf: I don't get it?
19:16:32 <cl1> those are good tips
19:17:00 <shachaf> @google zawinski's law
19:17:02 <lambdabot> http://catb.org/jargon/html/Z/Zawinskis-Law.html
19:17:02 <lambdabot> Title: Zawinski's Law
19:17:40 <lispy> cl1: edwardk uses haskell to specify the program he wants to write and then writes backends for the languages he needs to write it in. Then he compiles the Haskell specification into those languages.
19:18:05 <lispy> shachaf: ah, clever
19:18:09 <rwbarton> lispy, just make gmail filters be a second backend for your EDSL
19:18:41 <camio> lispy: Does he derive the implementation from Haskell by hand?
19:19:16 <cl1> lispy: so he writes haskell to <language he needs> compilers?
19:19:20 <robbe-> shachaf: Well, it shouldn't be *any* program in Haskell, but a truly useful one, then - according to the explanation google found. :-)
19:19:35 <lispy> camio: Not sure if I understand you. I believe he has a eDSL in Haskell and the haskell program generates the, say, C program
19:19:58 <lispy> cl1: yeah
19:20:03 <cl1> wow
19:20:16 <camio> lispy: Ah okay. I thought he might write the program in Haskell and then write an equivelent one in a more verbose language.
19:20:29 <lispy> cl1: it's not that crazy. That's actually how my procmail recipe thing works
19:20:48 <hpaste> edwardk pasted “for shachaf” at http://hpaste.org/77989
19:21:04 <lispy> camio: I've done that at my current job. We had to deliver readable source in Java, but we did all the whiteboard sessions in Haskell
19:21:20 <mpu> With GADTs to get the typing for free?
19:21:29 <lispy> camio: 20 minutes of Haskell turns into about 2 days of Java :)
19:21:55 <sacundim> lispy, camio: i'm actually doing exactly that Haskell-to-Java thing at my job right now
19:21:58 <camio> lispy: That's what I do too. Except when I use that I prefer to use Agda as the "intellectual" language.
19:22:21 <lispy> camio: nice. Yeah, agda seems like it's good for exploring ideas
19:22:21 <camio> And then derive a usually C++ implementation from that.
19:22:43 <lispy> sacundim: would a Haskell -> JVM compiler do you any good or do you need to deliver Java?
19:22:51 <sacundim> i need to deliver java
19:22:52 <camio> lispy: Absolutely. The syntax is so much cleaner than Haskell.
19:22:58 <cl1> mine would have to derive c#
19:24:19 <camio> cl1: I don't know much about c#, but my understanding is that its templates equivelent isn't powerful enough to handle the more abstract type-level stuff. When I derive java implementations, I usually end up writing a code generator.
19:26:41 <cl1> camio, correct c# does not have higher kinded types, hence f# is kind of lame
19:26:59 <lispy> Most managers want something along the lines of good results with a low-reasonable level of effort. The less risk the result poses the better. If you can point to a lot of great Haskell stuff and make a case that it satisifies what they're looking for they'll probably get onboard.
19:27:20 <cl1> camio, i believe the limitation is due to .net in general
19:27:33 <sacundim> i'm quite more cynical than that, lispy
19:28:05 <lispy> sacundim: how about, results that make them look good with a low level of effort from the team?
19:28:13 <sacundim> i work for a company that wrote hundreds of thousands of lines of code in Kawa Scheme (JVM-based), and all the managers hate that fact
19:28:32 <lispy> do you know what they hate about it?
19:28:39 <sacundim> they conveniently ignore the fact that the application could not have been delivered in the time it was if it had been pure java
19:28:53 <sacundim> the difficulty in hiring people
19:29:06 <sacundim> the difficulty in integrating with other stuff
19:29:12 <sacundim> there's a lot of politics, too
19:29:23 <sacundim> most of the early guys who did this were pushed out of the company
19:29:25 <lispy> ah, so the first two complains sound like risks
19:29:55 <lispy> it sounds like the managers feel that having all that kawa scheme is risky because ... (the reasons you gave)
19:30:05 <cl1> that would be the same issue in my case as well
19:30:10 <monochrom> I am even more cynical. "why do they hate it, what do they hate it for" is a wrong question. as human goes, they decide to hate it first, and then they will look for reasons when asked why
19:30:37 <liyang> what monochrom said.
19:30:42 <hpaste> edwardk annotated “for shachaf” with “for shachaf (it works!)” at http://hpaste.org/77989#a77990
19:31:23 <lispy> hate first, rationalize later.
19:32:18 <camio> lispy: Why hate it in the first place?
19:32:34 <geekosaur> because it's what people do
19:32:37 <monochrom> eh? you want to ask me, because I'm the one who said it
19:32:53 <sacundim> i think one of the problems too is that the farther away you are from the nuts and bolts, the harder it is to see the productivity differences between Java and Scheme
19:33:01 <monochrom> and because we're talking about human psychology, intuition, feeling, neural networks
19:33:16 <sacundim> so the first CTO at this company wrote a big chunk of the code, and he was one of the Scheme proponents
19:33:33 <sacundim> then gradually we get a series of less technical replacements for the guy
19:33:45 <sacundim> um, a series of gradually less technical replacements
19:34:23 <monochrom> but the closest-to-reason explanation is simply "unfamiliar". people fear unfamiliar things. they just do.
19:34:28 <liyang> I'm not sure how this article directly relates to the discussion, but I have a fuzzy feeling that it does: http://michaelochurch.wordpress.com/2012/09/03/tech-companies-open-allocation-is-your-only-real-option/
19:34:44 <camio> sacundim: So the initial hate could have come from their dislike of a guy. I dislike this guy, so I must dislike the peculiar things he is interested in.
19:35:24 <sacundim> i just remembered this developer we once hired.  He came in the first week, noticed that half the codebase was in Scheme instead of Java, and he quit
19:35:33 <sacundim> like in two weeks after his start date
19:36:01 <sacundim> there's a lot more politics than just the dislike of the first guy, lispy
19:36:09 <sacundim> that's why i'm so cynical :-P
19:36:42 <sacundim> because there's also the time that the company bought a much smaller, less successful company and promoted its people above the original people
19:36:45 <lispy> sacundim: heh, yeah that is pretty bad
19:36:56 <lispy> oops
19:37:05 * hackagebot http-date 0.0.3 - HTTP Date parser/formatter  http://hackage.haskell.org/package/http-date-0.0.3 (KazuYamamoto)
19:37:08 <sacundim> i could go on and on and on
19:37:25 <sacundim> but i actually do have a haskell question
19:37:30 <johnw> ask away
19:37:34 <hpaste> sacundim pasted “SetDiff” at http://hpaste.org/77991
19:37:50 <sacundim> is that a reasonable thing, am i reinventing some wheel
19:38:08 <sacundim> this is mostly coming out of unfamiliarity with hackage
19:38:30 <copumpkin> sacundim: that may or may not be an application of the grothendieck construction!
19:38:40 <johnw> there's definitely a Group class "out there" :)
19:39:04 <copumpkin> yeah, it looks like it
19:39:21 <copumpkin> you could make a custom meaningful Eq class for it too
19:39:42 <sacundim> but, did somebody already do it for me :-P
19:40:09 * lispy hasn't seen it before in Haskell, but he also hasn't looked
19:40:09 <copumpkin> sacundim: I did, in Agda ;)
19:40:14 <copumpkin> https://gist.github.com/4010366
19:40:15 <copumpkin> there you go
19:40:20 <copumpkin> just provide your commutative Set union monoid
19:40:23 <copumpkin> and this gives you the rest!
19:40:50 <shapr> sacundim: So you're trying to move out of that company into a Haskell job, right?
19:41:13 <sacundim> not until january at least
19:41:31 <copumpkin> sacundim: but anyway, what you made is this: http://en.wikipedia.org/wiki/Grothendieck_group
19:41:41 <rwbarton> your grothendieck group construction is going to give you 0, though
19:41:42 <sacundim> copumpkin: yeah, google gave me that
19:41:56 <rwbarton> unless you allow multiple occurrences of the same element and count them
19:42:13 <sacundim> i can never remember what Hom is, though
19:42:18 <copumpkin> give you 0?
19:42:34 <rwbarton> as in the resulting group will be the trivial gorup
19:42:37 <johnw> sacundim: Hom is the category of homomorphisms
19:42:47 * sacundim thinks really, really hard
19:42:52 <copumpkin> rwbarton: hmm!
19:42:55 <johnw> Hom(a,b) in Hask is really just a -> b :)
19:42:57 <copumpkin> rwbarton: how so?
19:43:00 <liyang> Why isn't there an equivalent of IntMap.mergeWithKey for IntSet?
19:43:02 <shapr> I love the way that happens so often here. Um, the thinking really really hard bit.
19:43:02 <sacundim> so the arrows are arrows between homomorphisms...
19:43:03 <rwbarton> if inserting a and then inserting a is the same as inserting a...
19:43:16 <rwbarton> and if you can invert "inserting a", then inserting a is the same as doing nothing
19:43:38 <copumpkin> oh, fair enough. So you'd want Map[A, Nat]
19:43:41 <rwbarton> yep
19:43:43 <johnw> sacundim: if such arrows exist; the category could potentionally contain only endomorphisms
19:43:47 <lispy> shapr: heyo
19:43:57 <shapr> oh hai lispy! How's code? Long time no chat!
19:44:15 <copumpkin> so does that mean applying grothendieck group to any semilattice will produce a trivial group?
19:44:16 <lispy> shapr: pretty good. Having a lot of nerd rage lately. Need to channel it...
19:44:17 <shapr> lispy: Do you think #haskell has made you want to be a nicer person?
19:44:22 <lispy> shapr: how about you?
19:44:48 <johnw> edwardk: is Hom also a category, or is it only the class of morphisms of a given category?
19:44:52 <shapr> I'm also having lots of nerd rage, mostly because I have too much to do and too little time to do it. But so far I'm on track to graduate spring of 2014!
19:44:59 <lispy> shapr: Yeah, I suppose it has (never really thought about it)
19:45:09 <lispy> shapr: oh nice
19:45:12 <shachaf> shapr: #haskell has made me meaner.
19:45:24 <lispy> shachaf: yes, we can tell ;)
19:45:25 <shapr> shachaf: I thought that might be true.
19:45:46 <jrajav> Think you took the wrong turn for nerd rage
19:45:51 <jrajav> You want #c or ##javascript
19:46:10 <monochrom> haha
19:46:17 <johnw> sacundim: I think Hom is just the hom-set for a given catgeory
19:46:21 <alang> except a -> b is an object in Hask and Hom(a, b) is an object in Set
19:46:34 <mpu> It is a bifunctor
19:46:45 <edwardk> johnw: normally its just a set. if your category C is enriched over some other category D then your hom-set sets are actually objects of D.
19:46:48 <mpu> covariant on one side, contravariant on the other
19:47:15 <johnw> edwardk: I was wondering if "Hom" denoted that category of hom-sets
19:47:33 <copumpkin> rwbarton: why are you not in ##categorytheory btw? :P
19:47:39 <copumpkin> seems like a huge waste!
19:47:41 <johnw> yeah, seriosuly rwbarton
19:47:42 <lispy> shapr: lately, I've been wanting to spend some free-time on all of: a) making an email client I like (that's a yak I've been trying not to shave for a decade), b) making a physics library, c) writing a procedural content game, d) implementing HOL and/or a dependently typed language, e) using Agda to learn me some CT
19:47:47 <lispy> shapr: I'm sure I forgot something
19:48:17 <edwardk> johnw: the ##categorytheory folks are a lot better at this than i am ;)
19:48:23 <shapr> lispy: I'll join you for e) and possibly d)
19:48:26 <johnw> alang: isn't a -> b, as expressed in Haskell code, an element of both under two different classifications?
19:48:34 <sacundim> ok, thanks guys, i gotta go...
19:48:46 <johnw> i.e., it's both an object and a morphism
19:48:49 <shapr> lispy: though I really want to write a compiler for https://github.com/HackerFoo/peg instead of doing d)
19:49:10 <johnw> edwardk: if that's true, then I don't yet know what I don't know
19:49:11 <shapr> Does HackerFoo ever show up here on #haskell?
19:49:21 <johnw> i haven't seen a nick by that name yet
19:49:53 <shapr> Yah, probably not.
19:50:39 <lispy> shapr: I've got a pretty good start on d. I have a private github repo where I play with things. It's private simply so my github doesn't clutter up with things that I'm not ready to share
19:51:32 <lispy> shapr: I started with the paper for LambdaPi about the tutorial impl of a dependently typed lambda calculus
19:51:55 <mpu> lispy, I wrote a typechecker for the lambda Pi modulo, you can check it out at https://github.com/mpu/dedukti/ it uses a fancy compilation technique to Lua
19:51:55 <shapr> lispy: I make everything public. Thus I am most speedily notified of bad choices.
19:52:00 <copumpkin> rwbarton: hmm, I'm not sure I buy that yet
19:52:18 <lispy> shapr: it's split into a simply typed lambda calculus. I stopped there and now I'm integrating the typing haskell in haskell paper to add type schemas so I can make it a HOL light thingy
19:52:28 <shapr> lispy: That certainly does sound nifty.
19:52:43 <rwbarton> copumpkin: you can also think just in terms of definition of equality in the grothendieck construction
19:52:59 <rwbarton> if you have any two sets A and B, you can find S so that A union S = B union S
19:53:03 <rwbarton> for example, S = A union B
19:53:09 <johnw> rwbarton: ##categorytheory!
19:53:09 <rwbarton> or any bigger set
19:53:23 <copumpkin> lol
19:53:37 <johnw> anyone who uses the words "grothendieck construction" needs to be there
19:53:50 <copumpkin> there are at least two grothendieck constructions I know of
19:53:52 <copumpkin> he was such a builder
19:54:03 <lispy> mpu: so you're pretty far along?
19:54:06 <shapr> I admit, substructural type systems are totally 2009.
19:54:16 <lispy> mpu: mine doesn't do much yet :)
19:54:46 <rwbarton> yeah, isn't this one really called the grothendieck group
19:54:54 <copumpkin> yeah
19:55:37 <rwbarton> in topology we call it the group completion
19:55:39 <copumpkin> rwbarton: okay, I think I'm starting to believe this
19:56:03 <copumpkin> so that does mean any idempotent monoid (bounded semilattice) has a trivial grothendieck group
19:56:04 <copumpkin> right?
19:56:24 <mpu> lispy: oh, it was for an internship actually, I continued the work of a previous PhD student. lambda Pi modulo is funny though because it the conversion rule is very relaxed. See this too http://strictlypositive.org/Easy.pdf I am sure you wil enjoy it.
19:56:24 <rwbarton> yes
19:56:30 <copumpkin> which intuitively makes sense, since I can't "undo" max or something
19:56:39 <rwbarton> or even any monoid with an absorbing element
19:56:47 <rwbarton> (a * z = z for all a)
19:56:56 <copumpkin> that's mean
19:57:28 <copumpkin> and that explains why I can get almost the rationals by applying it to the Z-{0},* monoid
19:57:34 <copumpkin> but I gotta kill that 0
19:57:44 <mpu> lispy, please excuse typos, I suck at typing tonight.
19:58:55 <copumpkin> dammit
19:59:05 <copumpkin> now I have to prove that if you have an absorbing element, the grothendieck group is trivial
19:59:09 <copumpkin> (in Agda, of course)
19:59:19 <copumpkin> this is all your fault, rwbarton
19:59:24 <rwbarton> yep
19:59:40 <cl1> you people blow me away with your computational theory
20:00:00 <mpu> if only it was computational...
20:00:09 <augur> byorgey: is there really such a category as |B? wouldnt it just be Set restricted to identity morphisms?
20:00:12 <copumpkin> cl1: it's a bunch of fancy words for fairly unexciting stuff
20:00:17 <augur> |Set| I suppose?
20:00:20 <cl1> its like you are talking a foreign language
20:00:44 <cl1> when I program I worry about stuff like reliable messaging
20:01:08 <rwbarton> copumpkin: do you have a setoid-aware concept of group isomorphism already?
20:01:17 <copumpkin> nope
20:01:23 * cl1 doesn't think its boring. he just doesn't know sqat about it
20:01:32 <copumpkin> cl: I didn't either a couple of years ago :)
20:01:38 <copumpkin> I just got sick of not knowing and sat down and learned it
20:01:45 <rwbarton> doing math in agda always sounds appealing but the setoid stuff is such a turnoff
20:01:58 <copumpkin> yeah, I want quotients
20:02:08 <copumpkin> getting really sick of not having them
20:02:10 <augur> copumpkin: tell me about what agda + quotients would be like :o
20:02:26 <copumpkin> augur: there was an example of it for a while
20:02:31 <augur> oh?
20:02:49 <mpu> copumpkin: If you get a good notion of quotients, people from Coq will be interested
20:03:01 <rwbarton> it sounds like it should be ... well not easy, but not necessarily impossible at least
20:03:03 <copumpkin> mpu: we're all hoping the OTT guys get their act together
20:03:06 <copumpkin> or the HTT guys
20:03:09 <copumpkin> someone!
20:03:18 <crdueck> i have these two functions that are similar to takeWhile and filter: http://sprunge.us/AXdQ but these versions aren't lazy and i need them to be. for example, "filter even [1..]" starts spitting out numbers right away, but "filterAcc (any even) [1..]" halts. could someone explain to me why they arent consuming their input lists lazily?
20:03:21 <rwbarton> I should really learn more about HTT
20:03:42 <alang> what's OTT?
20:03:53 <copumpkin> http://www.cs.nott.ac.uk/~txa/AIMXV/Quotient.html/Quotient.html#330
20:03:56 <copumpkin> augur: ^
20:03:59 <Eduard_Munteanu> alang: Observational Type Theory.
20:04:04 <copumpkin> that's the interface you'd get
20:04:07 <alang> thanks
20:04:09 <copumpkin> those turned out to be broken
20:04:15 <augur> \o/
20:04:39 <Eduard_Munteanu> @google observational equality now
20:04:44 <lambdabot> http://www.cs.nott.ac.uk/~txa/publ/obseqnow.pdf
20:04:44 <lambdabot> Title: Observational Equality, Now!
20:04:59 <copumpkin> but the basic idea is that you have something that looks like a setoid, so you have a type and an equivalence on it. But you can't "look inside" unless you prove that you respect the equivalence
20:05:06 * Eduard_Munteanu should read that properly sometime.
20:05:49 <augur> copumpkin: whats this do now
20:05:57 <haskell_nuby> is a parsec parser a pure function? It should always parse input the same way.
20:06:58 <copumpkin> augur: it lets me define integers as pairs of natural and knowing for sure that nothing will ever be able to distinguish (1,5) from (0,4)
20:07:04 <copumpkin> wow, that was a terrible sentence
20:07:11 <rwbarton> higher inductive types should give you exactly quotients (and more exotic things besides)
20:07:16 <copumpkin> yup
20:07:30 <augur> copumpkin: how do you program with this?
20:07:38 <copumpkin> what do you mean?
20:08:15 <augur> copumpkin: well like, what does it look like to USE quotients
20:08:15 <copumpkin> presumably the functions that actually need to respect the equivalence form a "basis" of your API, and then you build other combinators on top of them that don't need to make all the annoying proofs
20:08:37 <copumpkin> augur: that elim function in the file I linked to is it
20:09:04 <copumpkin> if you had built-in pattern matching, you'd need some syntax to prove you're respecting the rules
20:09:16 <copumpkin> not sure what that would look like, but it's nothing too ground-breaking
20:09:57 <augur> hm
20:10:40 <copumpkin> rec is closer to the average "programmer" use of it though
20:11:04 <copumpkin> it takes a function (f : (x : Carrier) → P)
20:11:12 <copumpkin> and gives you a function (Quotient A → P)
20:11:24 <copumpkin> as long as you can prove that your f respects the quotient's equivalence
20:11:53 <shachaf> tibbe: Have there been any requests for a function like k -> (Maybe a -> f (Maybe a)) -> Map k a -> f (Map k a)?
20:12:03 <YayMe>  /join #css
20:12:05 <tibbe> shachaf: in containers?
20:12:07 <YayMe> oops
20:12:13 <shachaf> tibbe: Yes.
20:12:29 <tibbe> shachaf: is it a generic replacement function?
20:12:44 <tibbe> shachaf: it looks like an effectful adjust
20:12:49 <shachaf> tibbe: Right.
20:13:01 <shachaf> tibbe: That would let you write things like updateLookupWithKey and so on yourself.
20:13:05 <shachaf> Depending on the effects.
20:13:12 <shachaf> (And still only traverse the Map once.)
20:13:12 <tibbe> shachaf: we have yet to decide what to do in terms of applicatve/monadic functions
20:13:16 <copumpkin> damn lenses
20:13:20 <shachaf> OK, fair enough.
20:13:23 <augur> copumpkin: is it problematic if you were to use that source as is, without some underlying support?
20:13:25 <tibbe> shachaf: but you have to traverse twice
20:13:37 <tibbe> shachaf: we're a bit worried about growing the API too much
20:13:40 <shachaf> Does adjust traverse twice?
20:13:41 <copumpkin> augur: yeah, iirc it lets you violate the quotient rules
20:13:43 <tibbe> shachaf: so we're hurrying slowly
20:13:49 <augur> copumpkin: :(
20:13:50 <tibbe> shachaf: once
20:14:02 <tibbe> shachaf: but you can write adjustA by using lookup etc
20:14:07 <tibbe> shachaf: but you have to traverse twice
20:14:08 <copumpkin> augur: https://lists.chalmers.se/pipermail/agda/2012/004052.html
20:14:11 <shachaf> So why would an effectful adjust do it twice?
20:14:18 <shachaf> tibbe: Ah, with lookup, sure.
20:14:51 <edwardk> shachaf: i tried doing it in one pass, but my map-fu wasn't strong enough to make the applicative update faster than the naive two-pass one when i last tried
20:15:11 <shachaf> If anything this would let you shrink the API (sort of).
20:16:49 <augur> copumpkin: what should i watch to get a better understanding of how HTT works, especially with regard to quotients?
20:17:04 <edwardk> > M.empty & at "hello" . non 0 +~ 2
20:17:06 <lambdabot>   fromList [("hello",2)]
20:17:10 <augur> everything ive watched so far is really math-focused and not terribly programming-y
20:17:11 <copumpkin> hm, just read the HTT blog? I don't know that much about it beyond what's on there
20:18:20 <shachaf> > let (++) = (+= 1) in (`execState` M.empty) $ do { ((at "hello" . non 0) ++) }
20:18:22 <lambdabot>   fromList [("hello",1)]
20:18:26 <rwbarton> the one sentence explanation of HTT and quotients is "instead of identifying two elements of a set, you draw a path between them"
20:18:47 <edwardk> shachaf: thats awful =P
20:19:06 <rwbarton> (++)++
20:19:07 <copumpkin> augur: http://homotopytypetheory.org/2012/11/12/abstract-types-with-isomorphic-types/ and http://homotopytypetheory.org/2012/09/23/isomorphism-implies-equality/ and dolio's https://plus.google.com/u/0/103747431621921238432/posts/XiWVpZPwxSV are probably of interest to you
20:19:11 <augur> rwbarton: so ive heard! but i dont understand how it works beyond funny pictures with circles :(
20:23:31 <ion> @type non
20:23:33 <lambdabot> (Eq a, Functor f, Isomorphic k) => a -> k (a -> f a) (Maybe a -> f (Maybe a))
20:23:38 <ion> Huh, does lambdabot have a newer lens than 3.3?
20:23:49 <edwardk> non is loaded from @let
20:23:54 <ion> ah
20:24:03 <edwardk> as is the binding for (&)
20:24:16 <shachaf> lambdabot should be hooked up to HEAD
20:24:22 <shachaf> Anything older is an insult.
20:24:29 <edwardk> lambdabot gets really slow when building lens ;)
20:26:28 <shapr> edwardk: are you hosting lambdabot?
20:26:53 <edwardk> nope, its just last time cale built lens, lambdabot got really slow for a while ;)
20:26:57 <startling> shachaf, I'm waiting for my contribution to make it into lambdabot
20:27:42 <shachaf> startling: Which one?
20:27:48 <edwardk> i think lispy runs the box, or at least ran it enough to upgrade his linode to be able to support a new enough ghc that, blah blah blah lambdabot =P
20:28:39 <startling> shachaf, https://github.com/ekmett/lens/commit/ba842321d3a8bb9712a4a84b245f4f0b8e1d3eb9
20:28:56 <shachaf> startling: Good point.
20:29:02 <shachaf> We should deprecate the old version.
20:29:11 <shachaf> It might have security implications.
20:29:20 <startling> shachaf, definitely
20:29:36 <rwbarton> @@ @hoogle @type \f -> map snd . filter (f . fst)
20:29:38 <lambdabot>  Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
20:29:55 <rwbarton> @@ @hoogle @type \f -> listToMaybe . map snd . filter (f . fst)
20:29:56 <ion> I take it l . from l isn’t supposed to ≡ l?
20:29:57 <lambdabot>  Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
20:30:00 <rwbarton> stop it hoogle
20:31:04 <shachaf> rwbarton: I don't think that function is in the standard library.
20:31:28 <rwbarton> feels like it should be in the (find|lookup|...)(By)? family but I guess not
20:31:30 <shachaf> Hoogle doesn't have heuristics for Eq a => a -> ... ~ (a -> Bool) -> ..., does it?
20:32:18 <shachaf> rwbarton: For returning a list?
20:32:26 <shachaf> Oh, never mind.
20:32:42 <shachaf> No, it doesn't quite have it.
20:32:46 <shachaf> It would be called lookupBy, probably.
20:32:48 <ion> shachaf? edwardk? shadwardk?
20:33:16 * edwardk looks up
20:33:25 * shapr looks up by lambdabot
20:33:35 <rwbarton> @type lookup
20:33:37 <lambdabot> Eq a => a -> [(a, b)] -> Maybe b
20:33:38 <rwbarton> @type find
20:33:40 <lambdabot> (a -> Bool) -> [a] -> Maybe a
20:33:42 <edwardk> l . from l = id generally
20:33:44 <rwbarton> yeah
20:33:52 <ion> edwardk: But it’s okay if it isn’t?
20:33:54 <edwardk> otherwise what you have isn't an isomorphism
20:33:55 <shachaf> @ty let l = enum in l . from l
20:33:56 <lambdabot>     Ambiguous type variable `a0' in the constraint:
20:33:57 <lambdabot>       (Enum a0) arising from a use of `l'
20:33:57 <lambdabot>     Probable fix: add a type signature that fixes these type variable(s)
20:34:04 <ion> > view (at "foo" . non 0 . from (non 0)) (Map.singleton "foo" 0)
20:34:06 <lambdabot>   Not in scope: `Map.singleton'
20:34:06 <lambdabot>  Perhaps you meant one of these:
20:34:06 <lambdabot>    `M.single...
20:34:15 <ion> > view (at "foo" . non 0 . from (non 0)) (M.singleton "foo" 0)
20:34:15 <edwardk> well, the way we've been handling it in the lens docs is any violation of that assumption is documented.
20:34:17 <lambdabot>   Nothing
20:34:19 <ion> > view (at "foo") (M.singleton "foo" 0)
20:34:21 <lambdabot>   Just 0
20:34:45 <edwardk> non 0 assumes you are working with Maybe (a sans 0) and want to get an 'a' out of it
20:34:55 <edwardk> so you are explicitly outside of the stated domain of non.
20:34:55 <shachaf> startling: That extra space in the documentation was a startling discovery.
20:35:03 <ion> edwardk: alright
20:35:10 <edwardk> it is documented pretty heavily in the haddocks for it
20:35:18 <startling> shachaf: :|
20:35:28 <augur> copumpkin: essentially i guess my question is
20:35:41 * shachaf thinks a "principled" Lens (Maybe a) a lens would be nicer.
20:35:43 <augur> will proper quotients make == reasoning unnecessary?
20:35:44 <edwardk> https://github.com/ekmett/lens/blob/master/src/Control/Lens/Iso.hs#L199
20:35:53 <copumpkin> augur: nope
20:35:56 <augur> copumpkin: :(
20:36:03 <edwardk> well, that still fails the lens laws just as much as the iso does
20:36:04 <copumpkin> equational reasoning is good!
20:36:11 <ion> Holy long lines, Batman!
20:36:14 <edwardk> under exactly the same conditions
20:36:14 <shachaf> OK, a traversal?
20:36:16 <augur> copumpkin: i dont like it!
20:36:24 <copumpkin> augur: well, don't use it!
20:36:24 <copumpkin> :P
20:36:25 <edwardk> as a traversal its 'traverse' thats boring and useless for its stated purpose.
20:36:31 <copumpkin> nothing you can't do without it
20:36:41 <augur> copumpkin: but what if i want proper quotienty things! :(
20:36:43 <shachaf> edwardk: Eq a => a -> Traversal (Maybe a) a?
20:36:53 <edwardk> the nice thing about non is if you want to have a map where you know the entries are all non 0, and when you go to put a 0 back in, you want to delete it, its much less burdensomethis way
20:37:02 <copumpkin> augur: you have proper quotienty things with a TT that supports them. What's wrong with that?
20:37:02 <shachaf> What's its stated purpose?
20:37:37 <augur> copumpkin: well lemme reask my question more specifically
20:37:37 <shachaf> @let foo :: Eq a => a -> SimpleIso (Maybe a) (Maybe a); foo v = iso (\x -> case x of Nothing -> Just v; Just x | x == v -> Nothing | otherwise -> Just x) (\x -> case x of Nothing -> Just v; Just x | x == v -> Nothing | otherwise -> Just x)
20:37:39 <lambdabot>  Defined.
20:37:44 <shachaf> foo is a proper isomorphsim, right?
20:37:54 <edwardk> say you have a map of counts, where no 0 entries exist in the map.
20:37:54 <augur> copumpkin: would quotients eliminate == reasoning for =='s from the quotient definition
20:38:03 <copumpkin> eqreasoning is a fancy syntax for trans
20:38:06 <copumpkin> that's all it is
20:38:27 <edwardk> shachaf: yes, but its nearly useless for the canonical non case of dealing with nested maps
20:38:42 <copumpkin> so if you need trans in your proof
20:38:43 <augur> copumpkin: eg if you define multisets over lists via permutation equations, would i need to use == for the defining equalities?
20:38:49 <edwardk> > M.empty & at "hello" . non M.empty . at "world" ?~ "!!!"
20:38:52 <lambdabot>   fromList [("hello",fromList [("world","!!!")])]
20:38:57 <augur> or would the relevant equalities be obvious to the type checker
20:39:03 <Eduard_Munteanu> augur: eqreasoning works with any equivalence
20:39:17 <copumpkin> nothing is ever obvious to the typechecker, except additional definitional equalities
20:39:19 <edwardk> > M.fromList [("hello",M.fromList [("world","!!!")])] & at "hello" . non Map.empty . at "world" .~ Nothing
20:39:21 <lambdabot>   Not in scope: `Map.empty'
20:39:22 <lambdabot>  Perhaps you meant `M.empty' (imported from Data....
20:39:26 <edwardk> > M.fromList [("hello",M.fromList [("world","!!!")])] & at "hello" . non M.empty . at "world" .~ Nothing
20:39:29 <lambdabot>   fromList []
20:39:36 <augur> copumpkin: so then what does a true quotient type get us??
20:40:02 <copumpkin> and the new TTs don't add much in that department, beyond what we want
20:40:02 <copumpkin> a guarantee that bad things don't leak, and the ability to use propositional equality in places we couldn't use it before
20:40:14 <augur> hm
20:40:17 <edwardk> it provides a sentinel meaning for what it means when the key is not in the map, which we presume doesn't occur in the map.
20:40:33 <copumpkin> since we can subst the quotiented values, quotiented by another equivalence
20:40:35 <shachaf> > M.fromList [("hello",M.fromList [("world","!!!")])] & at "hello" . foo M.empty . traverse . at "world" .~ Nothing
20:40:38 <lambdabot>   fromList []
20:40:57 <shachaf> > M.fromList [("hello",M.fromList [("world","!!!")])] & at "hello" . foo M.empty . traverse . at "blah" ?~ "blue"
20:40:59 <lambdabot>   fromList [("hello",fromList [("blah","blue"),("world","!!!")])]
20:41:08 <edwardk>  > M.fromList [("hello",M.fromList [("world","!!!")])] ^. at "hello" . foo M.empty
20:41:28 <copumpkin> so if I have (4 / 8) and you have a proof about 1 / 2, I can use it about my value, even though they aren't actually structurally the same
20:41:33 <edwardk> > M.fromList [("hello",M.fromList [("world","!!!")])] ^. at "hello" . foo M.empty
20:41:33 <shachaf> > M.fromList [("hello",M.fromList [("world","!!!")])] ^. at "hello" . foo M.empty
20:41:36 <lambdabot>   can't find file: L.hs
20:41:37 <lambdabot>   Just (fromList [("world","!!!")])
20:41:45 <copumpkin> where / means rationals
20:41:55 <edwardk> > M.fromList [("hello",M.empty)] ^. at "hello" . foo M.empty
20:41:58 <lambdabot>   Nothing
20:42:03 <copumpkin> I can stop worrying so much about structural equalities
20:42:08 <Eduard_Munteanu> copumpkin: is that an actual TT you have in mind, or plain Agda code?
20:42:09 <copumpkin> just because Agda privileges it
20:42:21 <copumpkin> Eduard_Munteanu: is what?
20:42:29 <Eduard_Munteanu> This quotients stuff.
20:42:37 <edwardk> the swapping there preserves information, but it has a pretty strange effect
20:42:40 <copumpkin> Eduard_Munteanu: well, there's that file I linked to earlier
20:42:49 <copumpkin> which would probably give a reasonable API for them
20:42:58 <copumpkin> even though it was bad the way it was implemented
20:43:09 <shachaf> edwardk: Oh, you want Just M.empty there?
20:43:13 <Eduard_Munteanu> Yeah, I've seen it. So I guess it's not some special feature.
20:43:19 <copumpkin> well, it is
20:43:27 <augur> copumpkin: wait wait
20:43:29 <copumpkin> since I don't think we can define them in the language
20:43:40 <copumpkin> augur: what what
20:43:42 <edwardk>  > M.fromList [("hello",M.empty)] ^. at "hello" . non M.empty
20:43:43 <copumpkin> (in the ****)
20:43:50 <edwardk> > M.fromList [("hello",M.empty)] ^. at "hello" . non M.empty
20:43:52 <lambdabot>   fromList []
20:43:54 <augur> so you can use the 4/8 pair in place of 1/2 with a proof, or without?
20:43:58 <shachaf> Well, it's an isomorphism, so you can review foo
20:44:04 <neutrino_> edwardk: you should make a twitter account
20:44:12 <edwardk> neutrino_: @kmett
20:44:13 <shachaf> > M.fromList [] ^. at "hello" . non M.empty
20:44:16 <lambdabot>   fromList []
20:44:21 <shachaf> > M.fromList [] ^. at "hello" . foo M.empty
20:44:24 <lambdabot>   Just (fromList [])
20:44:28 <neutrino_> edwardk: i mean one with just lens related code snippets.
20:44:35 <shachaf> > M.fromList [("hello", M.empty)] ^. at "hello" . foo M.empty
20:44:37 <lambdabot>   Nothing
20:44:51 <shachaf> OK, those are different, but you'll never notice that if you don't have invalid lists.
20:44:51 <neutrino_> edwardk: i don't want to read about any of your flesh bag issues.
20:44:56 <shachaf> You can fromMaybe default, in fact.
20:44:58 <copumpkin> augur: if I have (4 / 8) in my rational type (defined as quotiented naturals in the usual rational sense) and you have a proof about rationals involving (1 / 2), I can use subst on the rational and squeeze mine in
20:45:01 <shachaf> And then you'll really never notice it.
20:45:02 <copumpkin> since they're equal, propositionally
20:45:15 <copumpkin> you can then continue to compute with it
20:45:19 <edwardk> the 'foo' Nothing case is noise. my goal is to have a map that doesn't have 0s, or empty nested maps or whatever in it, now i have to deal with that case all over again by traversing or what have you
20:45:40 <copumpkin> that's allowed with "real quotients" because we have a guarantee that _nothing_ can distinguish the values
20:45:41 <rwbarton> you could even error (gasp) if you see the sentinel value
20:46:06 <edwardk> rwbarton: the nice thing about the non version is that it is self-correcting, which seems to me to be more robust
20:46:08 <copumpkin> Setoids look similar, but they miss the crucial part of forcing you to respect the relation if you want to see the value
20:46:49 <augur> copumpkin: respecting which relation?
20:46:59 <copumpkin> the relation you're quotienting by
20:47:07 <rwbarton> whatever relation you wish to impose
20:47:13 <copumpkin> the agda code I linked to forced you to respect it by hiding the constructor
20:47:17 <copumpkin> so you can't get the value out
20:47:26 <copumpkin> unless you go through the safe API
20:47:27 <shachaf> There's something to your isomorphisms being actual isomorphisms
20:47:43 <shachaf> If you had a Lens (Maybe a) a, and you composed it with foo, you'd get the same behavior, right?
20:47:57 <shachaf> And it would be broken in the same way.
20:48:07 <edwardk> yes, but the stated lens isn't any more correct than the isomorphism
20:48:14 <copumpkin> augur: so the quotient is like the identity monad, plus a guardian at the exit
20:48:15 <shachaf> Of course.
20:48:22 <edwardk> the isomorphism is between Maybe (a sans 0) and a   which has the same count of elements
20:48:44 <edwardk> the lens would be the same, except you'll have wasted the knowledge that the relationship is bidirectional
20:48:57 <edwardk> and force someone to hold onto an environment needlessly somewhere
20:49:10 <Eduard_Munteanu> Or like ST's way of preventing leaks.
20:49:58 <edwardk> Now, i _am_ happy to document it more thoroughly, etc.
20:50:36 <edwardk> :t foo 0 . traverse
20:50:38 <lambdabot> (Eq a, Num a, Applicative f) => (a -> f a) -> Maybe a -> f (Maybe a)
20:50:48 <edwardk> but foo 0 . traverse   is a mere traversal
20:50:50 <copumpkin> augur: and that guardian allows you to have a more liberal propositional equality rule
20:50:53 <edwardk> :t non 0
20:50:55 <lambdabot> (Eq a, Functor f, Num a, Isomorphic k) => k (a -> f a) (Maybe a -> f (Maybe a))
20:51:10 <augur> copumpkin: hm.. so by using quotients, say you have f : A -> B, then if you know x ~A y, then you know f x ~B f y, where the ~'s are type-specific?
20:51:51 <copumpkin> it's stronger than that
20:51:57 <copumpkin> f x == f y
20:52:00 <copumpkin> using propositional equality
20:52:33 <edwardk> but the swapping in of the default element for Nothing means that assignment to Nothing takes on some pretty strange meanings, etc.
20:52:44 <augur> copumpkin: hm. thats interesting
20:52:50 <augur> i cant imagine how that works
20:52:50 <copumpkin> augur: so in a sense, it's promoting the arbitrary equivalence relation to propositional equality
20:53:42 <augur> copumpkin: hm. i suppose i'd need to see ideal use cases
20:54:03 <copumpkin> well, think of anything that's "observationally equivalent" to something else
20:54:09 <rwbarton> if I want to identify two elements x and y of a set A (quotient by the relation x ~ y) then I adjoin a "higher value" to A which "witnesses" this equality of x and y
20:54:20 <copumpkin> it gives us a way of saying "if it quacks like a duck, it is a duck" in the type theory
20:54:23 <copumpkin> which we can't do right now
20:54:23 <edwardk> > M.empty^.at 1.non 0
20:54:25 <lambdabot>   0
20:54:32 <rwbarton> as a function, f will send this "higher value" in A to a "higher value" in B which "witnesses" an equality of f(x) and f(y)
20:54:57 <edwardk> > M.empty & at 1.non 0 +~ 1 & at 1.non 0
20:54:58 <Eduard_Munteanu> AFAIU from this conversation, it's more like if x ~ y, then x == y as representatives for the purpose of proving stuff within that quotient type.
20:55:00 <lambdabot>   Couldn't match expected type `Data.Map.Map k0 a0'
20:55:00 <rwbarton> so it is impossible to ever talk about functions which don't preserve these relations
20:55:00 <lambdabot>              with actual ...
20:55:16 <copumpkin> augur: you've come across setoidfunction, right?
20:55:18 <edwardk> > M.empty & at 1 . non 0 +~ 1 & view (at 1.non 0)
20:55:22 <lambdabot>   1
20:55:23 <augur> copumpkin: i guess. i just cant see how to get obseq with distinct implementations unless you can force all use of a function to go through the definition's interfaces
20:55:24 <augur> copumpkin: no
20:55:27 <copumpkin> oh
20:55:59 <edwardk> he foo version makes you deal with a Maybe that has had its guts shuffled to read from it
20:56:12 <edwardk> > M.empty & at 1.foo 0
20:56:14 <lambdabot>   Couldn't match expected type `Data.Map.Map k0 a0'
20:56:15 <lambdabot>              with actual ...
20:56:34 <edwardk> > M.empty ^. at 1 . foo 0
20:56:36 <lambdabot>   Just 0
20:56:54 <copumpkin> augur: http://www.cse.chalmers.se/~nad/listings/lib/Function.Equality.html#500
20:56:57 <copumpkin> it's horrible
20:57:00 <edwardk> but i just want to read the target, and default it to 0 if its absent
20:57:05 <rwbarton> edwardk: I mostly write programs to run myself so my default position is to prefer a crash over doing something semantically dubious
20:57:05 <copumpkin> but that's what we get right now for a similar idea
20:57:37 <rwbarton> however I haven't thought about whether in this case it is likely semantically dubious
20:57:39 <edwardk> rwbarton: i have a lot of code where i have state and in my state i have maps of maps.
20:57:47 <rwbarton> right
20:57:47 <copumpkin> augur: have you worked with the various congs using a custom equivalence relation?
20:57:51 <edwardk> this is precisely the semantics i want for that situation.
20:57:59 <augur> copumpkin: maybe, dunno
20:58:06 <edwardk> where i want to delete the empty maps, and give default values for the missing entries
20:58:25 <copumpkin> augur: well, do you see why all the structures in the std lib (Algebra.Structures) have a cong for every operation they support?
20:58:28 <rwbarton> (Maybe a) / (Nothing ~ default)
20:58:38 <edwardk> > M.empty^.at "hello". non M.empty . at "world"
20:58:40 <lambdabot>  Terminated
20:58:43 <augur> copumpkin: cant say ive noticed this but who knows
20:58:47 <rwbarton> edwardk: just use a quotient type ;)
20:58:56 <edwardk> hah
20:59:23 <Eduard_Munteanu> Yeah. Let's just redirect #haskell to #agda and be done with it. :P
20:59:28 <copumpkin> augur: well, if you try doing anything with any of the structures in the stdlib, you'll notice that you can't prove anything interesting about an arbitrary structure without using the -cong included
20:59:31 <copumpkin> augur: http://www.cse.chalmers.se/~nad/listings/lib/Algebra.Structures.html#2117 for example
20:59:44 <copumpkin> augur: that file has 32 occurrences of the word "cong" in it
21:00:05 <edwardk> the thing i like about non is that it takes one of the situations that i've had to apologize for not being able to handle well with lenses for 3-4 months now, and makes it trivial
21:00:18 <copumpkin> augur: that is what we hate, and that is what quotients would get rid of
21:00:24 <augur> copumpkin: hm
21:00:25 <shachaf> Fair enough.
21:00:45 * edwardk will make a non-believer of you yet ;)
21:01:02 <copumpkin> augur: the point is that although you might have a custom equivalence relation, how do you know that your function respects it? If I know that (1/2) = (2/4) = (4/8) etc., how do I know that your multiplication operation doesn't treat those differently?
21:01:11 <copumpkin> augur: cong tells you that
21:01:16 <augur> right
21:01:28 <copumpkin> so it lets you actually prove things about the operations
21:01:45 <copumpkin> but the only reason we need it is because we can't promote the equivalence relation
21:01:53 <copumpkin> and force everyone to respect mah authoriteh
21:01:59 <Eduard_Munteanu> copumpkin: hmm... wouldn't it help if they defined groups etc. over setoids and used the underlying equivalence relation instead?
21:02:13 <copumpkin> Eduard_Munteanu: that's what they're doing
21:02:25 <copumpkin> they just expand the setoid into the record
21:02:32 <Eduard_Munteanu> Yeah.
21:02:41 <Eduard_Munteanu> I mean, they end up reimplementing it.
21:02:50 <copumpkin> well, it's a record with two fields
21:03:30 <copumpkin> and each structure exports an assembled setoid
21:03:35 <copumpkin> so you can use one if you want one
21:03:50 <copumpkin> it wouldn't save you from doing any of that cong shit though
21:05:44 <Eduard_Munteanu> Hm (bear with me, I'm thinking). I kinda see, but I can't help wonder if there's another way to just employ propositional equality there.
21:06:13 <copumpkin> well, if we had quotients, we could just use propositional equality everywhere, and let someone else deal with the custom equivalence
21:06:17 <johnw> are you guys talking about Haskell?
21:06:22 <copumpkin> >_>
21:06:22 <copumpkin> <_<
21:06:28 <rwbarton> "sure"
21:06:32 <copumpkin> um, yeah
21:06:34 <johnw> i keep thinking i'm in #adga
21:06:40 * copumpkin ushers people into #agda
21:07:05 <rwbarton> didn't you know the H in Haskell stands for Homotopy
21:07:13 <copumpkin> lol
21:07:24 * Eduard_Munteanu thinks johnw wants to thwart our spamming efforts by mispelling the name of #agda
21:07:40 <johnw> i'm typing with less fingers since I burned myself making popcorn
21:11:48 <copumpkin> likely excuse
21:12:03 <shachaf> edwardk is a non-believer, it turns out.
21:12:24 * Eduard_Munteanu grabs a pitchfork
21:12:37 <rwbarton> non would go great with def
21:12:49 <shachaf> def?
21:12:56 <edwardk> Data.Default def
21:12:57 <rwbarton> the class Default thing
21:12:57 <edwardk> non def
21:13:08 <edwardk> :t def
21:13:10 <lambdabot>     Not in scope: `def'
21:13:10 <lambdabot>     Perhaps you meant `dff' (imported from Data.Graph)
21:13:12 <shachaf> I didn't know abou that class.
21:13:18 <shachaf> Does it have any laws?
21:13:20 <edwardk> its kinda silly
21:13:26 <rwbarton> yeah
21:13:29 <edwardk> no laws
21:13:33 <shachaf> Hmm.
21:13:35 <shachaf> @free def :: a
21:13:35 <copumpkin> it should be called "Inhabited"
21:13:35 <lambdabot> f def = def
21:13:39 <rwbarton> the law is def is hopefully the value you expect
21:13:40 <edwardk> its occasionally useful for when you need a value for Pointed ;)
21:14:12 <copumpkin> class True a where oyeah :: a
21:14:51 <shachaf> @djinn-add class Default a where def :: a
21:15:00 <shachaf> @djinn b -> a
21:15:01 <lambdabot> -- f cannot be realized.
21:15:03 <shachaf> @djinn Default a => b -> a
21:15:04 <lambdabot> f _ = def
21:15:11 <shachaf> @djinn Default b => a -> b
21:15:12 <lambdabot> f _ = def
21:15:19 <mauke> mos def
21:15:25 <johnw> where did you learn about @djinn-add, shachaf?
21:15:36 <sclv> so so def
21:16:01 <shachaf> johnw: I'm not sure how to answer that question.
21:16:04 <copumpkin> @yhjulwwiefzojcbxybbruweejw
21:16:05 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
21:16:14 <shachaf> lambdabot: ?
21:16:15 <lambdabot> Maybe you meant: . ? @ activity activity-full admin all-dicts arr ask b52s babel bf bid botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add
21:16:15 <lambdabot> djinn-clr djinn-del djinn-env djinn-names djinn-ver do docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq farber flush foldoc forget fortune
21:16:15 <lambdabot> fptools free freshname ft gazetteer get-shapr ghc girl19 google googleit gsite gwiki hackage help hitchcock hoogle hoogle+ id ignore index instances instances-importing irc-connect jargon join karma
21:16:15 <lambdabot> karma+ karma- karma-all keal kind learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on nixon oeis offline
21:16:15 <lambdabot> oldwiki palomer part paste ping pl pl-resume pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc
21:16:16 <lambdabot> read reconnect remember repoint run shootout show slap smack source spell spell-all src tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc
21:16:19 <lambdabot> topic-tail topic-tell type undefine undo unlambda unmtl unpf unpl unpointless uptime url v vera version vote web1913 what where where+ wiki wn world02 yarr yhjulwwiefzojcbxybbruweejw yow
21:16:21 <shachaf> There, now you know.
21:16:32 <shachaf> @palomer
21:16:32 <lambdabot> I have news for you, it's pointless
21:16:38 <copumpkin> @pl (\x -> x x) (\x -> x x)
21:16:39 <sclv> def leppard
21:16:41 <shachaf> My lord, I have news to tell you.
21:16:42 <lambdabot> ap id id (ap id id)
21:16:42 <lambdabot> optimization suspended, use @pl-resume to continue.
21:16:43 <johnw> i guess I meant, how did you know how to use it
21:16:44 <rwbarton> karma-all?
21:16:46 <copumpkin> >_>
21:16:46 * rwbarton is afraid to test
21:16:52 <copumpkin> @pl-resume
21:16:58 <lambdabot> ap id id (ap id id)
21:16:59 <lambdabot> optimization suspended, use @pl-resume to continue.
21:16:59 <shachaf> @karma-all
21:17:00 <lambdabot>  "nobody"             2000
21:17:00 <lambdabot>  "c/c"                 328
21:17:00 <lambdabot>  "("                   128
21:17:00 <lambdabot>  "+"                   102
21:17:02 <lambdabot>  "g"                    98
21:17:04 <lambdabot> [1670 @more lines]
21:17:21 <copumpkin> at least we have SII(SII)
21:17:27 <shachaf> @@ @read @run reverse @show karma-all
21:17:29 <lambdabot>  lla-amrak
21:17:35 <shachaf> @@ @read @run reverse @show @karma-all
21:17:37 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
21:17:45 <shachaf> @@ @run reverse @show @karma-all
21:17:47 <lambdabot>   "\n8762-         \"sekahsklim\" \n6262-                  \"<\" \n257-      ...
21:18:03 <shachaf> Somebody doesn't like milkshakes.
21:18:08 <copumpkin> @karma milkshakes
21:18:08 <lambdabot> milkshakes has a karma of -2678
21:18:10 <copumpkin> yeah.
21:18:42 <Jafet> @@ @run reverse.lines @show @karma-all
21:18:45 <lambdabot>   ["0002             \"ydobon\" ","823                 \"c/c\" ","821        ...
21:18:59 <Jafet> @@ @run reverse$lines @show @karma-all
21:19:01 <lambdabot>   [" \"milkshakes\"         -2678"," \"<\"                  -2626"," \"-\"   ...
21:19:18 <shachaf> @@ @run unlines.reverse.lines $ @show @karma-all
21:19:18 <sclv> def rocks! http://c3.cduniverse.ws/resized/250x500/music/652/1056652.jpg
21:19:21 <lambdabot>   " \"milkshakes\"         -2678\n \"<\"                  -2626\n \"-\"      ...
21:19:25 <shachaf> @@ @run @read unlines.reverse.lines $ @show @karma-all
21:19:26 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
21:19:27 <shachaf> @@ @run @read unlines.reverse.lines $ @show @karma-all
21:19:28 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
21:19:31 <shachaf> Um.
21:19:41 <shachaf> @@ @run @read take unlines.take 20.reverse.lines $ @show @karma-all
21:19:42 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
21:19:50 <shachaf> @@ @run @read take unlines.take 1.reverse.lines $ @show @karma-all
21:19:51 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
21:19:52 <shachaf> Useless bot.
21:19:53 <sclv> well, this is exciting
21:20:07 <rwbarton> what's thre @read for
21:20:16 <shachaf> Turning it into a form that can be @mored
21:20:44 <shachaf> @@ @run text.unlines.reverse.lines $ @show @karma-all
21:20:47 <lambdabot>    "milkshakes"         -2678
21:20:47 <lambdabot>   "<"                  -2626
21:20:47 <lambdabot>   "-"             ...
21:20:48 <ion> edwardk: Btw, you can close GitHub bugs with commit messages. https://github.com/blog/831-issues-2-0-the-next-generation
21:20:51 <rwbarton> i see
21:20:53 <rwbarton> i think
21:21:16 <shachaf> ivanm pours more fuel on the fire
21:21:25 <rwbarton> you can manually @more, though, right
21:21:33 <shachaf> Sure.
21:21:34 <rwbarton> with drop 2
21:21:39 <shachaf> If you're willing change the number each time.
21:21:48 <edwardk> ion: i tried to get that to work a few times. apparently putting ()'s around the closes #89   caused me problems or something
21:22:21 <shachaf> edwardk: How does it feel conflicting with a Platform operator?
21:22:30 <edwardk> which one now?
21:22:41 <shachaf> <ivanm> fgl - which is in the Platform - uses &.
21:23:03 <Jafet> ion: "Reverting last merge -- it did not actually fix #xxx"
21:23:04 <edwardk> i find it hard to get my ability to care about that conflict up ;)
21:23:23 <shachaf> This is an excuse to go back to (%)!
21:23:50 <shachaf> ion: I demand the ability to open bugs in commit messages.
21:23:55 <edwardk> replied
21:24:30 <copumpkin> gah, fgl is in the platform?
21:24:41 <edwardk> copumpkin: apparently
21:25:43 <ion> Will lens be in the next platform?
21:26:06 <edwardk> probably not. ;) its a bit bleeding edge for the platform and i'd rather not grind lens development to a halt
21:26:35 <edwardk> it uses many ghc features that aren't used by any lib in the platform
21:27:10 <edwardk> also it depends on a lot of stuff that isn't in the platform. unordered-containers, comonads, etc.
21:27:15 <Jafet> reflection should be in the platform!
21:27:19 * sopvop found lens using void package, as usual with edwardk packages, I don't get what it is for
21:28:03 <edwardk> if you have a Functor f, then when you have f Void you know that the 'f' has no 'holes' for values in it, or something hinky is going on with undefined.
21:28:13 <edwardk> [Void]       should only be []
21:28:45 <edwardk> we get there by reasoning that given a Void you should be able to get any 'a' you want.
21:28:46 <sopvop> kind of undefined?
21:29:00 <edwardk> the idea is you shouldn't make values of type Void.
21:29:14 <edwardk> :t traverse (const Nothing)
21:29:16 <lambdabot> Traversable t => t a -> Maybe (t b)
21:29:27 <edwardk> there 'b' could be picked by the user to have type Void.
21:29:59 <edwardk> :t traverse (const Nothing) "x"
21:30:01 <lambdabot> Maybe [b]
21:30:05 <edwardk> > traverse (const Nothing) "x"
21:30:07 <lambdabot>   Nothing
21:30:09 <edwardk> > traverse (const Nothing) ""
21:30:12 <lambdabot>   Just []
21:31:47 <edwardk> consider: foo :: Either Void a -> a; foo (Right a) = a; foo (Left nonsense) = absurd nonsense;
21:32:05 <edwardk> absurd :: Void -> a
21:32:28 <edwardk> in theory a value of foo :: Either Void a should only be able to be Right, the Left case is 'absurd'
21:33:47 <sopvop> And void can't be 'created', that might be useful
21:34:47 <edwardk> yeah. () logically has one inhabitant, Void logically has none.  i say logically because _|_ kind of sneaks in and inhabits everything
21:35:16 <Jafet> data Void#
21:35:23 <edwardk> type Not a = a -> Void  -- is also quite useful
21:35:44 <edwardk> Not (Not (Not a)) -> Not a      works constructively, but Not (Not a) -> a  does not
21:35:48 <shachaf> Jafet: State# Void?
21:36:07 <sclv> !Void has none :-)
21:36:25 <shachaf> type Mot m a = a -> m Void
21:36:43 <shachaf> (forall m. Monad m => Mot m (Mot m a)) -> a
21:36:47 <sopvop> I have typeclass which describes type (in my case table columns in db). with   dbColumns :: a -> [Column], and use it like dbColumns (undefined :: Foo).
21:37:15 <sopvop> Void still can't be used though
21:37:56 <sopvop> damn, I thought that will protect me from _|_
21:38:58 <sclv> how do we write absurd w/o undefined?
21:39:06 <sclv> or absurd = absurd?
21:39:15 <sclv> not that it matters
21:39:19 <sopvop> absurd ::  Void -> a
21:39:25 <sclv> yes, that's the type
21:39:27 <copumpkin> there was a proposal to make empty patterns recently
21:39:29 <sclv> what's the body?
21:39:32 <copumpkin> not sure what happened
21:39:44 <copumpkin> it was supposedly good for the low-level compiler too
21:39:47 <copumpkin> to help it optimize or something
21:39:57 <sclv> oh, as in case x of ->
21:39:59 <sclv> cute
21:40:04 <copumpkin> something like that, yeah
21:40:19 <copumpkin> http://hackage.haskell.org/trac/ghc/ticket/2431
21:40:32 <copumpkin> there was a more recent discussion on it though
21:40:40 <shachaf> Yay!
21:40:44 <shachaf> Nullary classes, too, right?
21:40:47 <sclv> even then we don't have anything to put on the other side of the ->
21:41:03 <Jafet> > case () of {}
21:41:05 <lambdabot>   <hint>:1:13: parse error on input `}'
21:41:15 <copumpkin> yeah, in agda you just write it as f :: Void -> a; f ()
21:41:24 <Jafet> instance x where {} -- valid
21:41:46 <pordan30> given data void = void {unboid :: void}, wouldn't absurd :: void -> a; aburd = absurd . unvoid work, ala data.void?
21:42:44 <shachaf> Might as well say absurd = absurd
21:43:10 <Jafet> absurd /= absurd
21:43:16 <sclv> its slightly nicer
21:43:29 <shachaf> It's not as if you're getting something smaller by unvoiding.
21:43:50 <sclv> yeah the unvoid bit doesn't do anything
21:43:56 <shachaf> Is Void data or codata?
21:43:57 <copumpkin> aha
21:44:11 <copumpkin> http://snapplr.com/b7z4
21:51:41 <augur> shachaf: void is data!
21:51:50 <edwardk> pordan30: note that in Data.Void i use a newtype which means Void = Void Void can have no inhabitants other than _|_. but data Void = Void Void -- has lots of inhabitants, it has _|_, Void _|_, Void (Void _|_), ...
21:51:56 <augur> or maybe its codata..
21:52:24 <shachaf> copumpkin would claim that data Void = Void Void has lots no inhabitants.
21:52:29 <shachaf> Silly pumpkin.
21:52:37 <augur> hmm
21:52:42 <augur> no void is data, shachaf
21:52:45 <edwardk> the definition used in the void package is codata, it provides an infinite tower of Void's
21:52:45 <augur> silly me.
21:52:51 <edwardk> but no base case
21:53:02 <augur> but in principle it can be data!
21:53:03 <copumpkin> well
21:53:05 <augur> ignoring bottom
21:53:08 <copumpkin> that doesn't make it codata
21:53:12 <augur> mu X. 0
21:53:12 <edwardk> true
21:53:15 <copumpkin> I can define
21:53:18 <augur> its data!
21:53:24 <augur> nu X. 0
21:53:24 <augur> :(
21:53:25 <copumpkin> data Void : Set where Void : Void -> Void
21:53:29 <copumpkin> in agda
21:53:32 <copumpkin> and it's perfectly valid
21:53:36 <augur> copumpkin: can you? thats naughty
21:53:39 <copumpkin> why?
21:53:41 <copumpkin> I just can't construct it
21:53:43 <copumpkin> oh well
21:53:45 <augur> {-# OPTIONS --no-positivity-check #-}
21:53:48 <copumpkin> there's a name conflict
21:53:48 <edwardk> its both a floor wax AND a dessert topping!
21:53:50 <augur> ok say that again
21:53:51 <copumpkin> augur: it's positive
21:54:00 <augur> oh i guess it is :(
21:54:05 <copumpkin> nothing wrong with it
21:54:06 <pordan30> edwardk: thanks for clarifying the distinction between defining void using data and newtypes. i was recently (within the last minute) surprised that i could define inhabitants of void defined with a data declaration, and wondering what was wrong!
21:54:09 <copumpkin> I can also prove it's empty
21:54:20 <augur> copumpkin: quelle interesting
21:54:21 <copumpkin> try it!
21:54:27 <augur> you're right its obviously positive
21:54:30 <augur> its just Nat minus zero
21:54:31 <copumpkin> that's the thing, it's structurally decreasing
21:54:32 <augur> derp
21:54:41 <edwardk> pordan30: the void package uses newtype Void = Void Void except on some old GHCs where it can't then it uses data Void = Void !Void -- to pretend to be a newtype ;)
21:54:55 <augur> copumpkin: i guess that Void type is the non-well-founded naturals, or something like that
21:55:14 <copumpkin> so you can have infinite recursion on it :)
21:55:14 <copumpkin> so I can write absurd : {a : Set} -> Void -> a
21:55:18 <copumpkin> absurd (Void v) = absurd v
21:55:22 <copumpkin> and that's a valid definition
21:55:37 <augur> horrible
21:55:43 <copumpkin> again apart from the name overlap :)
21:55:44 <copumpkin> I like it
21:55:51 <augur> its not too bad tho i guess
21:55:54 <copumpkin> well
21:55:59 <copumpkin> think about it this way
21:56:00 <augur> cause itll always terminate when you run it
21:56:01 <augur> which is
21:56:02 <augur> never
21:56:05 <copumpkin> take the Acc type for well founded recursion
21:56:10 <copumpkin> and put in a non-wellfounded relation
21:56:14 <copumpkin> you get something like that
21:56:19 <copumpkin> and then you just prove it's empty :)
21:56:26 <copumpkin> ergo, the relation is not well founded
21:56:48 <copumpkin> I have something like that on my github I think
21:57:00 <augur> oh man i dont even grok Acc
21:57:19 <pordan30> edwardk: yes, i was working without the strict field. thank you for highlighting me aware of the (slightly subtle, but important) distinctions.
21:57:55 <pordan30> *making me aware / highlighting
21:58:20 <copumpkin> augur: https://plus.google.com/u/0/106318233255980016498/posts/ThcYYK4GUH5
21:58:53 <augur> copumpkin: oh man look at you
21:59:08 <augur> I CAN SEE YOU
21:59:11 <copumpkin> lo
21:59:11 <copumpkin> l
21:59:24 <copumpkin> someone was bugging me to put up a real pic
21:59:35 <augur> you look way more like an adult there than ive ever seen before
21:59:49 <copumpkin> must be a bad pic then
22:00:35 <sopvop> eureka! data Empty a = Empty; dbColumns :: Empty a -> [Columns]; protect your _|_!
22:01:34 <augur> copumpkin: which, the one where you look like an adult?
22:01:39 <latermuse> do you guys often practice math proofs with haskell?
22:01:40 <copumpkin> yup
22:01:43 <augur> lol
22:01:54 <johnw> latermuse: some of the people here use Agda for that
22:01:56 <Crockeo> latermuse: Sometimes, I more often just do Project Euler.
22:01:58 <copumpkin> latermuse: I did for a while, until I learned Agda
22:03:45 <Crockeo> Though this is most likely a noob question (given that I've just started a week or so ago, that's somewhat a given), is there any way to untaint something tainted by the IO monad (such as an IO String) or do I just have to use the IO version of whatever type I'm using?
22:04:13 <Jafet> @quote /bin/ls
22:04:13 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
22:04:27 <shapr> cute
22:05:28 <otters> Crockeo: you've fallen into the IO monad and you can't get up
22:05:40 <Crockeo> I should just get lifeline.
22:05:50 <otters> But to answer your question, no
22:05:55 <sopvop> IO Something >>= \untainedSomething -> return (toSomethingElse untainedSomething)
22:06:08 <copumpkin> Crockeo: you shouldn't think of the IO monad as a "taint flag"
22:06:09 <otters> IO a is an action that produces a result of type a
22:06:15 <otters> it's not actually a value
22:06:18 <otters> in the sense you're thinking
22:06:20 <copumpkin> Crockeo: that quote that Jafet pulled up is relevant
22:06:49 <otters> The most common way to operate on the result of an IO action is bind (>>=)
22:06:50 <Crockeo> It may be relevant but I haven't worked in Linux enough to understand it.
22:06:58 <copumpkin> Crockeo: and because an IO Int is not a "dirty int", I can make a big list of actions that haven't been run yet, and send them between threads, and possibly never even run them
22:06:59 <otters> Or I guess fmap
22:07:01 <shapr> Crockeo: you could substitute the dir command
22:07:13 <copumpkin> Crockeo: basically, IO a is a program that will produce an a when run
22:07:19 <copumpkin> Crockeo: it doesn't actually "contain" an a
22:07:22 <Eduard_Munteanu> Or Explorer. :)
22:07:32 <Crockeo> Ah, alright.
22:07:35 <Crockeo> Makes sense.
22:07:39 <copumpkin> Crockeo: your clock app doesn't contain the time. It computes it based on an interface with your system
22:07:57 <pordan30> Crockeo: although it extends the analogy of the IO type as a "tainted data flag," this page provides a decent explanation of why you wouldn't want such a function: <http://en.wikibooks.org/wiki/Haskell/Understanding_monads/IO>
22:08:00 <Eduard_Munteanu> Also your browser doesn't contain Internet. :)
22:08:40 <popl> My IRC client contains lots of little AIs.
22:08:44 <Crockeo> pordan30: I searched for an article on monads and ended up getting the page one up of that.
22:08:49 <Crockeo> I'll read it.
22:08:50 <pordan30> *or wouldn't want to put such a function into common use, rather than wouldn't want such a function
22:09:30 <Jafet> I think I still have some code containing the amazing line unsafePerformIO . unsafeSTToIO . unsafeFreeze
22:09:33 <Eduard_Munteanu> popl: watch it, I might become self-aware. :P
22:10:19 <pordan30> Crockeo: others might have better recommendations (because the following are slightly dated), but i'd recommend "the essence of functional programming" and "monads for functional programming," available here: <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html>
22:10:43 <Crockeo> Thank you again pordan!
22:11:04 <deus_rex> is there a compiler flag i can pass to ignore type signatures lacking bindings?
22:13:06 <Jafet> Why do you have type signatures lacking bindings
22:13:38 <sacundim> deus_rex, I just comment those out
22:13:56 <deus_rex> if i'm planning how to solve something sometimes i'll write out the type signatures for functinos i think i'll need
22:13:58 <pordan30> or create an undefined binding
22:13:59 <deus_rex> but not implement all of them
22:14:30 <Jafet> _TODO_ = undefined
22:14:36 <sacundim> or double check that the signature and the definition are both spelled correctly :-)
22:14:57 <deus_rex> Jafet: thanks!
22:19:29 <pordan30> does data.inductive.graph have a zipper with comonad instances (for doing simultaneous calculations on nodes with respect to local neighborhoods) defined anywhere in the standard libraries?
22:21:07 <Crockeo> Back again, so I made a function called stringOperation (type: String->Int) and did '(return . stringOperation) string' it works. What is that doing to the stringOperation function?
22:22:01 <Crockeo> The article referenced the function 'shout :: [Char] -> [Char]' and said doing (return . shout) sort of 'made it into' 'shout :: IO [Char] -> IO [Char]'
22:23:02 <copumpkin> not really, but liftM shout will do that
22:23:13 <pordan30> return :: Monad m => a -> m a and stringOperation :: String -> Int, so return . stringOperation :: Monad m => String -> m Int is a function that takes a string, performs a string operation, and returns the resultant integer in a monadic context
22:23:16 <Crockeo> So what /does/ return do?
22:23:47 <sopvop> depends on monad :)
22:24:10 <johnw> Crockeo: that question can be answered on a lot of different levels
22:24:15 <sopvop> Crockeo: I understood monads after implementing Maybe monad following some tutorial, can't remember which one.
22:24:20 <Crockeo> Maaaaaan switching over to functional programming is so godamn difficult.
22:24:20 <johnw> Crockeo: can you show me the context of your question?
22:24:20 <sacundim> the only brief answer to "what does return do" is "study monads"
22:24:33 <sacundim> i second the maybe monad recommendation
22:24:45 <hpaste> Crockeo pasted “Showing” at http://hpaste.org/77995
22:24:58 <Crockeo> That's for you johnw
22:25:13 <Crockeo> I'll try to implement the maybe monad.
22:25:27 <sacundim> in the case of IO, IO a is the type of an "action" that may or may not perform side effects, and produces a result of type a.
22:25:50 <sacundim> return :: a -> IO a is a dummy action that performs no side effects, and returns the value that was passed to it
22:26:16 <sacundim> haskell doesn't allow you to mix pure code and side effecting code freely
22:26:28 <johnw> Crockeo: in this case the return is just making main type-check, it's not achieving anything else there
22:26:54 <Crockeo> Alright. Thank you.
22:26:54 <johnw> implementing maybe will help you better than my trying to explain it in the context of IO examples like this
22:27:38 <sacundim> which means that (a) you can't write a function that depends on the result of a side-effecting operation, (b) if something wants a side-effecting  operation and you want to give it just a value, you need to use return
22:27:45 <sacundim> it takes quite some getting used to
22:28:42 <Crockeo> Alright. So that means I /can/ write a pure function and occasionally pass it data from a side-effecting source, along with passing it pure data at other times?
22:28:59 <sacundim> no, the other way around
22:29:05 <Crockeo> Oh, okay.
22:29:10 <hpaste> sopvop pasted “Maybe monad” at http://hpaste.org/77996
22:29:15 <sacundim> you can write a side-effecting operation that takes a side-effecting operation as an argument
22:29:25 <sacundim> and pass it a pure value in stead of the argument
22:29:31 <Crockeo> Alright.
22:29:45 <johnw> Crockeo: it gets even better
22:29:52 <Crockeo> Ohhhhhhhh god.
22:29:57 <Crockeo> I'll be back in a few years
22:30:01 <Crockeo> hopefully I've gotten it by then.
22:30:18 <sacundim> crockeo: think of C, or any other such language
22:30:36 <sacundim> you can write 5 + 5, or 5 + convertToNumber(getLine())
22:30:41 <johnw> Crockeo: if you do "foo <- readFile "foo.txt"", and then pass foo to a pure function, it will be able to see the data in the file without the pure function ever needing to know that fact!  it's kind of magical
22:30:41 <deus_rex> i found monads much easier to understand once i had a clearer picture of functors + applicatives
22:31:03 <sacundim> Haskell treats those two cases differently
22:31:38 <sopvop> I also suggest to forget about monads for now
22:31:41 <johnw> Crockeo: data reads will even happen behind the scenes while the pure function executing, to provide the contents of "foo" lazily; this all works because the data *originated* from IO, but that doesn't mean all your functions have to be in IO to use the data
22:32:17 <sopvop> just if you see IO, use do  a <- thatIO; return $ pureFunction a;
22:32:24 <johnw> they just have to be called from IO for this to work
22:32:24 <pordan30> is there a technical, or merely a cultural, reason that enforcing the distinction between pure and impure code via types hasn't caught on in mainstream imperative languages?
22:32:55 <johnw> pordan30: look at how much difficulty we've had with explaining it to people who are fascinated by our luangage
22:32:56 <sopvop> Then go for Functors, Applicatives, and Monads, when you feel comfortable with pure functions and higher order functions
22:33:11 <Crockeo> Probably because it's so impossible to learn. Though it may just be my experience /with/ imperative languages.
22:33:37 <deus_rex> Learn You a Haskell is helpful
22:34:11 <pordan30> johnw: on the other hand, it should be admitted that some of the difficulty arises from the distinction being made using a mathematical abstraction, not the concept itself.
22:34:13 <sopvop> Crockeo: Forget the monads for now, just use do notation and wrap pure functions with return. Monads will get easier once you get to know other abstactions
22:34:14 <pordan30> but point taken
22:34:36 <Crockeo> Alright, I'll just continue with learnyouahaskell
22:34:42 <Crockeo> (is that a good set of tutorials)
22:34:44 <sopvop> That is good decision
22:34:53 <pordan30> *mathematical abstraction recognized as difficult to understand by many inside and outside the community
22:35:17 <johnw> Also, in another sense, there *are no side-effects in Haskell*.  All functions are pure.  The end results of such a pure program is a IO value which, when executing by the Haskell runtime, causes side-effects to happen.  We can describe it both ways: either as an admixture of pure and impure code, or as 100% pure code that builds a description of the side-effects you want to see, and a runtime which realizes those side-effects via
22:35:17 <johnw> computation.
22:35:38 <deus_rex> Crockeo: be sure you have a really good picture comnig out of the chapter on Functors, Applicatives, and Monoids
22:36:01 <Crockeo> Will do deus_rex!
22:36:02 <johnw> pordan30: yes, that's true
22:36:07 <sopvop> Crockeo: LYAH is very good, and it introduces monads after Functor and Applicative, so by that time you will grasp it easily
22:36:16 <Crockeo> I'm flying down to Georgia for Thanksgiving tomorrow, so I'll have some time to study.
22:36:28 <johnw> pordan30: the mathematical abstraction is just so powerful, it would be a shame to focus on its use for IO and then have the beauty of the Monad get lost in the shuffle
22:37:04 <johnw> I think one of the greatest things Haskell has done is to force the Monad on unsuspecting programmers, who might not have learned otherwise that they've been reimplementing its concepts almost their entire coding lives
22:37:35 <deus_rex> LYAH's bird-balancing Maybe monad example is great :3
22:38:18 <johnw> for everyone who thinks Monads are a rough spot, just be glad Haskell doesn't express them in terms of Adjunctions :)
22:39:18 <johnw> Crockeo: I also recommend LYAH
22:39:37 <sopvop> most of my newbie problems came from type annotations
22:39:37 <johnw> and I recommend reading it twice; skim the first time, read for fuller understanding the second
22:39:49 <sopvop> I could not get why it works backwards
22:40:02 <johnw> sopvop: backwards?
22:40:15 <pordan30> johnw: re: two descriptions: the second description probably fits your resistance to specializing the importance of monads to sequencing io actions. a selling point for some appears to be the level of abstraction, and a useful way of thinking about computational contexts (esp. "combinators over arbitrary contexts," and then other abstractions such as applicatives and arrows).
22:40:16 <sopvop> yup, the 'return value' is at the end :)
22:40:23 <johnw> ohh
22:40:27 <sopvop> partial application was hard
22:40:30 <johnw> i guess you never programmed in Pascal then :)
22:40:40 <sopvop> nope
22:41:14 <sopvop> But since I new python, higher level functions were ok
22:41:23 <johnw> pordan30: yes, very much so
22:42:14 <sopvop> also I think I should restart learning English
22:42:15 <deus_rex> it was nice knowing a little bit about partial application from clojure
22:42:18 <johnw> I wouldn't call applicatives an abstraction, though
22:42:50 <johnw> they are just another functor, and a fairly specialized one at that
22:43:37 <Crockeo> Alright, well, thanks for the help tonight everyone. For the sake of me being able to get up relatively early tomorrow I'll call it a night.
22:43:50 <Crockeo> I'll make sure to read more LYAH
23:13:09 <OceanSpray> guys
23:13:15 <OceanSpray> type checkers
23:13:17 <OceanSpray> are hard to write
23:15:13 <shachaf> Depends on what kind of types you want to check.
23:17:22 <OceanSpray> polymorphic ones
23:17:31 <OceanSpray> and parametric ones
23:17:43 <OceanSpray> in fact, I still don't know how to do the latter
23:18:05 <OceanSpray> forall m a. Monad m => m a
23:18:28 <OceanSpray> the problem with the papers I've read is that every one of them uses the AST for types as:
23:19:22 <OceanSpray> Type ::= Monomorphic | Polymorphic Var Type | Constructor Var [Type]
23:19:29 <OceanSpray> or some variant thereof
23:19:47 <OceanSpray> and I'm like "but what about that 'm a' thing how is that even expressed"
23:20:40 <sopvop> Polymorphic Var (Polymorphic Var Type) ?
23:21:13 <OceanSpray> that'd be something like
23:21:18 <OceanSpray> forall a b. ...
23:21:45 <OceanSpray> whereas I'm looking for a paper that deals with the case
23:22:01 <OceanSpray> Type ::= Apply Var [Type]
23:22:10 <OceanSpray> kind of
23:22:11 <OceanSpray> I think
23:22:13 <OceanSpray> I don't know
23:23:01 <pordan30> have you looked at "typing haskell in haskell", available here: <http://web.cecs.pdx.edu/~mpj/thih/> ?
23:23:08 <OceanSpray> yes
23:23:17 <OceanSpray> it's not as helpful as people say it is
23:34:50 <pordan30> pierce has a specification of fomega in type and programming languages (chapters 29 and 30) with T := X | T -> T | ∀X :: K.T | λX :: K.T | T T with typing rules, but no type checker (i think there is no implementation of these systems in ml in the book)
23:37:38 <pordan30> oh, there is an implementation on his web page: http://www.cis.upenn.edu/~bcpierce/tapl/
23:37:56 <pordan30> anyways, that might be a good resource; last i checked, the pdf of the book was on some *.edu sites also
23:46:35 <sopvop> > from _last ^$ (Just 1)^._last <> (Just 2)^._last
23:46:37 <lambdabot>   Just 2
23:47:11 <sopvop> > (Just 1)^._last <> (Just 2)^._last^% getLast
23:47:13 <lambdabot>   Couldn't match expected type `Data.Monoid.Last a0'
23:47:13 <lambdabot>              with actual...
23:55:53 <pordan30> is there a useful characterization of structures like: class FunctorB (m :: * -> * -> *) where fmapB f g m :: (a -> c) -> (b -> d) -> (m a b -> m c d) /or/ fmapB f m :: (a -> b -> (c, d)) -> (m a b -> m c d) or class MonadB (m :: * -> * -> *) where bindM m f g :: m a b -> (a -> m c) -> (b -> m d) -> m c d /or/ bindM m f :: m a b -> (a -> b -> m (c, d)) -> m c d?
23:57:16 <sopvop> like bifunctors?
23:59:16 <pordan30> perhaps? looking at category-extras, it looks like arrows are another possible abstraction.
23:59:44 <pordan30> actually, bifunctors are apparently what i was trying to capture with the functor signature.
23:59:47 <johnw> pordan30: http://hackage.haskell.org/packages/archive/bifunctors/3.0/doc/html/Data-Bifunctor.html
23:59:48 <sopvop> http://hackage.haskell.org/package/bifunctors
23:59:56 <johnw> your fmapB is ekmett's bimap
