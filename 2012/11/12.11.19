00:00:08 <Nereid> which is easy once you use fmap fmap :: g (f b) -> f (g b) and fmap fmap :: f (g t) -> g (f t)
00:00:20 <Nereid> er
00:00:32 <Nereid> those aren't fmap fmap
00:00:48 <Nereid> you need your iso somewhere obviously.
00:01:08 <Nereid> hmm
00:02:20 <shachaf> let x ¬Ø y = from x; Íûå = () in view (identity¬ØÍûå) (Identity 5)
00:02:21 <Nereid> well it should be easy to construct the thing using isos.
00:03:19 * liyang squints ‚Ä¶ ¬¨_¬¨
00:03:28 <hpaste> CubeZero pasted ‚ÄúInplace Mergesort with 0 additional space requirements‚Äù at http://hpaste.org/77912
00:03:39 <CubeZero> shachaf: here is an example: http://hpaste.org/77912
00:04:17 <Nereid> shachaf: why not just use postfix operators and let (¬Ø) x = from x?
00:04:19 <CubeZero> there is somewhat complicated conditions which array indices i want to have selected
00:04:26 <Nereid> so view (identity¬Ø) ...
00:04:28 <shachaf> Nereid: Because that doesn't look like ¬Ø¬π
00:04:33 <Nereid> oh you want -1
00:04:40 <shachaf> Sadly I can't use ¬π
00:04:46 <shachaf> @ask edwardk Any consensus on (view . from)?
00:04:47 <lambdabot> Consider it noted.
00:05:11 <shachaf> CubeZero: Well, what people told you would work.
00:05:17 <liyang> Nereid: don't you need Traversable g and Applicative f to get g (f b) -> f (g b) ?
00:05:21 <FireFly> > let ' = 1 in '
00:05:23 <lambdabot>   <hint>:1:7: parse error on input `='
00:05:34 <Nereid> that's sufficient
00:05:46 <shachaf> > concat [[5 | True], [3 | False], [8 | True, False], [9 | True, True]]
00:05:48 <lambdabot>   [5,9]
00:05:57 <Nereid> liyang: oh yeah you have the inverse iso to
00:06:16 <Nereid> o
00:06:19 <Nereid> which you need.
00:06:24 <CubeZero> shachaf: yes and thanks again. I like haskell more and more
00:07:04 <Nereid> > generalCategory 'üí∏'
00:07:05 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
00:07:07 <Nereid> aw.
00:07:23 <Nereid> U+1F4B8 MONEY WITH WINGS
00:07:29 <typoclass> Nereid: try it in ghci, lambdabot is pickier about unicode now since the upgrade
00:07:40 <Nereid> but I wanted to do it in lambdabot.
00:08:06 <Nereid> shachaf: what about a more general symbol for dual?
00:08:30 <shachaf> Nereid: Is this really "dual"?
00:08:36 <shachaf> It's an inverse.
00:08:41 <Nereid> yes.
00:08:56 <Nereid> well.
00:09:06 <Nereid> > generalCategory 'Àá'
00:09:06 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
00:09:10 <Nereid> oh come on.
00:09:11 <Nereid> ghci time
00:09:43 <Nereid> ModifierLetter bleh
00:10:00 <Nereid> also yeah never mind about the dual.
00:15:36 <Nereid> maybe I'm not understanding what an isomorphism family is like.
00:18:08 <Nereid> how does one recover tb and bt from isos sa as tb bt?
00:18:43 <Nereid> also looks like the documentation for iso and isos have some issues
00:20:41 <Nereid> an instance of isos that should be iso, and some ' that should be gone.
00:20:46 <liyang> Nereid: maybe you can't. :-/
00:21:02 <Nereid> :/
00:21:24 <Nereid> I'm starting to believe that might be the case
00:21:37 <liyang> isos is not an isomorphism.
00:21:47 <Nereid> :V
00:22:13 <jerng> Hello. I've read some very interesting white/papers summarising certain implementations of the Erlang runtime system. Can anyone recommend some good summaries of how Haskell (GHC?) is implemented, in terms of memory management, fundamental language semantics, data types, etc.
00:22:15 <jerng> ?
00:25:16 <statusfailed> Can I annotate the type of a name on the left side of a monadic <-?
00:25:37 <statusfailed> e.g., (x :: Floating a => a) <- foo
00:26:30 <latermuse> Whats the best way to extract the name of the file from a string like this. Input:  "/home/folder/foobar.txt"  Output:  foobar
00:27:12 <latermuse> or even just foobar.txt
00:27:14 <key> how does haskell compete with flow based programming?
00:29:32 <statusfailed> latermuse: try "takeBaseName" from here: http://hackage.haskell.org/packages/archive/filepath/1.3.0.1/doc/html/System-FilePath-Posix.html
00:29:57 <bxx> @ hoogle "FilePath -> String
00:30:06 <bxx> @hoogle "FilePath -> String
00:30:07 <lambdabot> Parse error:
00:30:08 <lambdabot>   "FilePath -> String
00:30:08 <lambdabot>   ^
00:30:09 <neutrino> key: what is flow based programming?
00:30:23 <bxx> @hoogle FilePath -> String
00:30:23 <lambdabot> System.FilePath.Windows takeBaseName :: FilePath -> String
00:30:24 <lambdabot> System.FilePath.Posix takeBaseName :: FilePath -> String
00:30:24 <lambdabot> System.FilePath.Windows takeExtension :: FilePath -> String
00:30:39 <neutrino> bxx: please do this in a query with lambdabot
00:30:57 <latermuse> works great! thanks
00:31:00 <statusfailed> neutrino: I think it was for demonstration purposes
00:31:09 <neutrino> oh ok sorry
00:31:10 <bxx> yes, that was for latermuse
00:31:43 <neutrino> @faq can Haskell do flow based programming?
00:31:43 <lambdabot> The answer is: Yes! Haskell can do that.
00:31:48 <statusfailed> too late :p
00:31:59 <neutrino> i know
00:32:05 <neutrino> i just wanted to know if Haskell can do that
00:32:12 <statusfailed> hahaha
00:32:20 <neutrino> lol
00:33:11 <FireFly> @faq can Haskell solve the halting problem?
00:33:11 <lambdabot> The answer is: Yes! Haskell can do that.
00:33:21 <FireFly> Sweet
00:33:27 <sopvop> @faq can Haskell shoot me in a foot
00:33:28 <lambdabot> The answer is: Yes! Haskell can do that.
00:33:51 <zhulikas> @faq can Haskell make pancakes?
00:33:52 <lambdabot> The answer is: Yes! Haskell can do that.
00:33:54 <zhulikas> yay! \o/
00:34:00 <latermuse> <3 pancakes
00:56:07 * hackagebot plot 0.1.5 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.5 (VivianMcPhail)
01:28:35 <lambdas> #quit
01:28:40 <lambdas> Ugh.
01:31:10 * hackagebot network-fancy 0.1.5.1 - Networking support with a cleaner API  http://hackage.haskell.org/package/network-fancy-0.1.5.1 (MarkWotton)
01:32:43 <wyfrn> :i bounds
01:33:30 <mapf> :t bounds
01:33:32 <lambdabot> Ix i => Array i e -> (i, i)
01:33:47 <mapf> @src bounds
01:33:49 <lambdabot> bounds (Array l u _) = (l,u)
01:34:11 <mapf> @where bounds
01:34:12 <wyfrn> thx
01:34:12 <lambdabot> I know nothing about bounds.
01:34:45 <mapf> i dunno how to find location with lambdabot
01:34:58 <mapf> but it is in arrays
01:36:05 <wyfrn> http://www.haskell.org/hoogle/?hoogle=bounds
01:36:09 <wyfrn> hoggle ftw
01:39:14 <osa1> can anyone point me a testing module that uses quickcheck ? I'm trying to understand a few points about quickcheck
01:42:38 <yitz> @hoogle bounds
01:42:38 <lambdabot> Data.Graph type Bounds = (Vertex, Vertex)
01:42:39 <lambdabot> Data.Array.IArray bounds :: (IArray a e, Ix i) => a i e -> (i, i)
01:42:39 <lambdabot> Data.Array bounds :: Ix i => Array i e -> (i, i)
01:45:18 <yitz> osa1: Ranged-sets has a lot of simple quickcheck properties that are visible in the haddocks
01:46:02 <yitz> osa1: (because it is rather old, from before cabal allowed you to hide them and not make your package depend on quickcheck)
01:46:31 <osa1> yitz: thanks
01:47:17 <yitz> @hackage Ranged-sets
01:47:17 <lambdabot> http://hackage.haskell.org/package/Ranged-sets
01:47:51 <arbn> In HXT, how does one run an arrow with an empty root purely? I end up with an ArrowXml a => a XmlTree String, which I can run with runX, but that puts it in the IO monad. I can run it with runLA, but that doesn't supply an empty root node.
01:48:53 <latermuse> There is a bug on the haskell wiki. When I want to install the haskell platform on *nix system, it says to first get haskell 7.4.2. So I click on the link for that version of haskell, and it says that I shouldnt download it and instead should just install the haskell platform. Its an infinite loop and im not sure where to go from here.
01:49:40 <arbn> latermuse: Download the Haskell platform. That includes GHC and everything.
01:50:03 <latermuse> arbn: ok. so the haskell wiki should be changed to remove the part about downloading GHC separately?
01:50:17 <arbn> latermuse: Yeah. Where is that page?
01:50:28 <latermuse> http://www.haskell.org/platform/linux.html
01:51:01 <Cale> latermuse: That's if you want to build it from source.
01:51:11 <Pranz> just use apt-get
01:51:34 <latermuse> im installing on freebsd, should i just use the haskell platform from ports?
01:51:41 <arbn> latermuse: Yes.
01:51:51 <arbn> latermuse: Definitely.
01:51:54 <nyc> haskel-platform updates for Ubuntu 10.10 are unavailable
01:52:29 <Cale> Personally, I wouldn't bother with the Haskell platform. Just get the generic linux (or freebsd) binaries for GHC from the GHC website, then grab cabal-install from Hackage and run the bootstrap.sh script from the tarball.
01:52:40 <Cale> http://www.haskell.org/ghc/download_ghc_7_4_2
01:53:25 <Cale> http://hackage.haskell.org/packages/archive/cabal-install/0.14.0/cabal-install-0.14.0.tar.gz
01:54:04 <nyc> I might try to go with more bleeding edge ghc.
01:54:20 <Cale> (and if you're installing 7.4.2, that's the right version of cabal install)
01:55:13 <Cale> I don't know how usable 7.6.1 is yet if you're a beginner.
01:55:28 <jix> Cale: are there any problems with using a newer cabal-install? (on ghc 7.4.2) It's running fine so far for me and I really like the parallel build feature
01:55:45 <hiptobecubic> I thought a lot of packages weren't yet bumped for 7.6?
01:55:59 <shachaf> 7.6 isn't that bad these days.
01:56:05 <shachaf> I mean, compatibility-wise.
01:56:10 * hackagebot chu2 2012.11.19 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.19 (JinjingWang)
01:56:11 <Cale> jix: Oh, you got it to build? Perhaps you upgraded the Cabal library which came with your GHC?
01:56:12 * hackagebot tls 1.0.2 - TLS/SSL protocol native implementation (Server and Client)  http://hackage.haskell.org/package/tls-1.0.2 (VincentHanquez)
01:56:38 <arcatan> by the way, why is there no OS X installer for GHC 7.6?
01:56:50 <jix> Cale: I installed GHC 7.4 from my distribution's repository. Then I just downloaded the cabal-install-1.16 tar.gz and did the bootstrap
01:56:59 <jix> Cale: everything just worked so I assumed that was a supported setup
01:57:02 <arcatan> there used to be installers for the previous releases
01:58:52 <Cale> jix: ah, okay, probably it installed a newer Cabal library -- if that works then great. I usually don't like upgrading any of the packages that come with GHC ever, but probably few enough things depend directly on the Cabal library that you won't run into trouble.
02:00:11 <jix> Cale: I figured that no other library that ships with GHC should depend on the cabal lib that comes with ghc.. so when the first thing it does is updating the cabal lib I shouldn't run into problems
02:04:06 <luite> jix: the ghc package depends on Cabal
02:06:51 <jix> luite: ah, I guess I can avoid using anything that depends on that until I upgrade to 7.6
02:11:20 <leomeror> hi there
02:16:24 <dreixel> is there any package with substitution and matching utilities for Template Haskell?
02:36:31 <merijn> arcatan: There is, it's just not a graphical installer
02:36:43 <merijn> arcatan: The graphical installer is only made for Haskell Platform releases
02:37:15 <merijn> arcatan: If you grab the binary GHC release from the site and follow the instructions in the README it works fine
02:39:55 <Sonderblade> where does the lift function likely come from in this expression: lift $ putStrLn "foo!"
02:40:49 <merijn> Sonderblade: Control.Monad.Trans
02:40:59 <shachaf> @hoogle lift
02:41:00 <lambdabot> Text.ParserCombinators.ReadPrec lift :: ReadP a -> ReadPrec a
02:41:00 <lambdabot> Control.Applicative liftA :: Applicative f => (a -> b) -> f a -> f b
02:41:00 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
02:41:08 <shachaf> Well that's not too useful.
02:41:12 <merijn> Sonderblade: It lifts a monadic value into a monad transformer
02:41:33 <Sonderblade> shachaf: tried hoogle but didn't find anything good
02:41:35 <shachaf> http://haskell.org/hoogle/ still finds it.
02:41:46 <shachaf> Sonderblade: It's right on that page, if you search for "lift ::"
02:42:06 <merijn> Ah, Control.Monad.Trans.Class even (which is reexported by Control.Monad.Trans)
02:42:21 <Sonderblade> shachaf: gives me a parser error
02:42:32 <Sonderblade> shachaf: Parse error: (line 1, column 8): unexpected end of input Bad symbol
02:42:56 <merijn> Same here
02:43:03 <merijn> It's there when you search for "lift" too, though
02:43:09 <merijn> But it's a bit far down, I'll admit
02:43:22 <merijn> 13th entry
02:43:46 <shachaf> Sonderblade: No, search for "lift ::" on the page.
02:43:48 <shachaf> With ^F
02:44:27 <Sonderblade> shachaf: nope, http://www.haskell.org/hoogle/?hoogle=%22lift+%3A%3A%22
02:44:39 <shachaf> Sonderblade: What?
02:44:43 <shachaf> 02:43 <shachaf> Sonderblade: No, search for "lift ::" on the page.
02:45:35 <Sonderblade> i dont understand you
02:45:46 <arbn> Hmmm. Yeah. I'm starting to think that HXT deliberately provides no way to provide an empty root node to a pure arrow.
02:45:47 <merijn> Sonderblade: Use your browsers search option to search through the page
03:01:12 * hackagebot keter 0.3.4 - Web application deployment manager, focusing on Haskell web frameworks  http://hackage.haskell.org/package/keter-0.3.4 (MichaelSnoyman)
03:01:14 * hackagebot biopsl 0.4 - Library and executables for working with PSL files  http://hackage.haskell.org/package/biopsl-0.4 (KetilMalde)
03:11:12 * hackagebot http-conduit-browser 1.6.5 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.5 (MikhailKuddah)
03:21:18 <kknehra> hi
03:23:35 <kknehra> D:
03:23:42 <typoclass> kknehra: hello
03:25:45 <Sonderblade> why can't cabal uninstall packages?
03:29:02 <fmap> I guess main reason is nobody has written uninstall support yet
03:30:10 <neutrino> does cabal collect the information required for an uninstall, fmap?
03:30:18 <neutrino> bear in mind it might be impossibl
03:30:18 <neutrino> e
03:31:05 <Sonderblade> that's pretty primitive compared to gem, pip, npm and so on
03:31:14 <typoclass> not sure, but i thought a "cabal remove" command would largely be "ghc-pkg unregister" and then "rm ~/.ghc/thepackage". and recursively for the dependencies
03:33:13 <Sonderblade> on windows, the location must be different
03:33:38 <fmap> neutrino: why would it be impossible?
03:35:00 <hidas> What is the theoretical reason to disallow infinite function definitions? If I wanted to
03:35:23 <hidas> assume the responsibility for the computation to end.
03:36:43 <parcs`> what is the difference between an '{-# UNPACK #-} !Int' field inside a constructor and an Int# field?
03:37:00 <ChristianS> i just tried installing the pipes package via cabal (cabal install pipes) and got "Installing library in $HOME/.cabal/lib/pipes-2.0.0/ghc-7.4.1"
03:37:18 <ChristianS> however, the latest version is 2.5.0, can anyone explain why i got such an old version?
03:39:29 <fmap> ChristianS: well, one reason may be you hadn't `cabal update' since may
03:40:13 <ChristianS> fmap: ah, that's probably the problem (i prefer installing debian packages, but pipes is not available as such)
03:40:43 <hidas> oh, I got my answer "This is an explicit design decision: with infinite types, many obviously wrong expressions that we would like the compiler to reject would have to be allowed, and since many more programs would be allowed, a lot of previously unambiguously-typed programs would become ambiguously typed,1 requiring explicit type annotations. So a tradeoff is made: requiring you to be explicit about the fairly rare uses of infinite types 
03:41:49 <hidas> Which is sad.
03:42:11 <hidas> Anybody know a programming language allowing infinite types? :)
03:42:27 <hidas> *of*
03:43:25 <Saizan> ocaml with a flag
03:43:40 <ChristianS> fmap: works now, thanks!
03:44:18 <isomorphic> > runMaybeT $ lift $ print ""
03:44:20 <lambdabot>   Not in scope: `runMaybeT'
03:44:36 <parcs`> haskell with newtypes
03:45:43 <isomorphic> hrmm‚Ä¶  is the order of the IO and the Maybe defined for the statement runMaybeT $ lift $ print "" ?
03:46:13 <hidas> Saizan, thanks. Let's see...
03:46:17 <Saizan> what do you mean?
03:46:46 <Saizan> lift $ runMaybeT $ print "" wouldn't typecheck
03:46:53 <isomorphic> ie: When I put that statement into ghci - "" prints, and then Just () - can it happen in another order?
03:47:22 <Saizan> no
03:47:43 <isomorphic> What defines the order?
03:47:44 <Saizan> but the printing of Just () is something that happens only because ghci is showing the result
03:48:18 <nyc> Maybe () might as well be Bool anyway.
03:48:21 <Saizan> the fact that to get the result of something of type IO (Maybe ()) you have to execute its side-effects
03:48:23 <hidas> parcs, thank you too :)
03:48:58 <Saizan> (if by result we mean the Maybe () which will get computed)
03:49:25 <Saizan> the only exception is if you start using unsafeInterleaveIO or stuff defined with it
03:50:17 <isomorphic> That's beyond me for now ;)
03:50:58 <isomorphic> incidentally - I've asked in Yesod - but has anybody here managed to use persistent with an existing (non-persistent) database?
03:56:08 <isomorphic> How would I print the numbers 1 to 10 to stdout, with a one second delay between each number?
03:57:17 <Saizan> mapM_ (\n -> print n >> threadDelay (10^6)) [1..10]
03:57:41 <byorgey> sequence_ . intersperse (threadDelay 1000000) . map print $ [1..10]
03:58:00 <Saizan> yeah, i guess mine adds one spurious delay
03:59:39 <statusfailed> Does anyone know what the "sizes of the initial search box" argument is supposed to be here? http://hackage.haskell.org/packages/archive/hmatrix/0.14.1.0/doc/html/Numeric-GSL-Minimization.html
04:00:12 <isomorphic> the use of intersperse is interesting there
04:02:08 <isomorphic> can there be a pure implementation of threadDelay?
04:06:14 <merijn> isomorphic: No
04:06:29 <merijn> isomorphic: Well, yes. Depending on what you mean by pure
04:07:14 <isomorphic> I mean no IO in its signature.  I guess I don't know if the model of computation without IO contemplates time
04:07:23 <merijn> isomorphic: No, you cannot implement threadDelay outside of IO (at least not in standard haskell). But, on the other hand, IO is (strictly speaking) pure. (Even though people have the tendency to say "impure" code when they mean code in IO)
04:07:25 <byorgey> isomorphic: no, it doesn't
04:08:05 <isomorphic> Thanks :)
04:10:11 <Cale> *Evaluation* of IO actions is pure, sure, but execution of them is not.
04:11:04 <merijn> Cale: Of course, but execution of IO actions cannot be done in Haskell anyway :)
04:12:06 <isomorphic> Cale: have you written something distinguishing evaluation and execution?
04:12:49 <merijn> I have been thinking of writing a blog post distinguishing those for a few months now, but I can never be arsed >.>
04:14:52 <merijn> isomorphic: The basic idea is that haskell IO values are actions that can be executed, but there is no way to execute them *in haskell*. Haskell does provide combinators that combine multiple IO actions together (think of >>= and friends). So main is multiple smaller IO actions combined together into one big one, which is then executed by the runtime system when you run the program
04:15:26 <isomorphic> merijn:  I was just thinking that through.  I gather unsafePerformIO is the exception?
04:15:57 <merijn> isomorphic: Well yes, but unsafePerformIO is not part of the haskell standard and can't be written in standard haskell
04:16:17 <merijn> isomorphic: Hence, why it is unsafe. All bets are off when you use it :p
04:16:26 <merijn> @quote shachaf contains
04:16:27 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
04:17:27 <merijn> isomorphic: You can think of "getLine >>= print" as combining a program that reads a line (getLine) and a program that prints something printable and combining them into a new program that reads a line and then prints it.
04:20:20 <kosmikus> merijn: unsafePerformIO is part of the standard
04:20:54 <merijn> isomorphic: The beauty is that getLine is still pure. It always refers to the same *program* the fact that each invocation might produce a different result is only relevant when you execute the code, not when you evaluate it (evaluation is for example the expression "getLine >>= print" evaluating to the combined program). If you write the expression 10 times in your program it will still be referentially transparent (i.e. returning the sa
04:21:07 <merijn> kosmikus: I'm gonna need a link to the standard to believe that
04:21:25 <isomorphic> A minute ago byorgey and Saizan gave one liners that intersposed a bunch of IO actions to print numbers separated by one second delays in time.  I can understand those - but how does the interaction with the runtime system work if not all of the IO actions are ready to be passed back?
04:22:02 <Cale> isomorphic: Evaluation is turning expressions into values. Execution is carrying out the effects described by IO actions.
04:22:18 <merijn> isomorphic: You can evaluate IO expressions without running them
04:22:43 <Cale> But evaluating IO actions without running them is fairly pointless.
04:22:59 <merijn> isomorphic: Try taking byorgey's example and doing "drop 5" before sequencing the list
04:23:15 <Cale> (because the only way you can tell two IO actions apart ultimately is by executing them)
04:23:26 <merijn> kosmikus: I just looked it up, unsafePerformIO is part of the FFI definition, *not* of core Haskell98
04:23:27 <Cale> (two of the same type, anyway)
04:23:46 <merijn> Cale: Unless, of course, you don't know in advance which you want to run :)
04:23:46 <Cale> merijn: The FFI was merged into Haskell 2010
04:23:51 <merijn> Cale: Ah, bugger
04:24:05 <merijn> Made incorrect by the passage of time :\
04:24:42 <Cale> also, that was an official addendum to the Haskell 98 report
04:25:09 <Cale> But it doesn't matter -- the Report is just what it's called, a report on the state of Haskell.
04:25:46 <merijn> Anyway, I would still advice not considering unsafePerformIO a "true" part of Haskell. For some values of "true" and "part of"
04:26:13 <kosmikus> it's an incredibly useful function :)
04:26:13 * hackagebot tftp 0.2 - A library for building tftp servers  http://hackage.haskell.org/package/tftp-0.2 (SvenHeyll)
04:26:19 <Cale> It's not a function
04:26:21 <Cale> ;)
04:26:43 <kosmikus> it has a function type
04:26:46 <kosmikus> ;)
04:26:52 <Cale> Well, its type uses the function constructor, but that's a lie of course :)
04:27:03 <latermuse> how is that a lie? can you explain?
04:27:16 <kosmikus> agreed
04:27:25 <Cale> A function assigns to each value in its domain exactly one value in its codomain
04:27:50 <Cale> unsafePerformIO getLine  will produce a different result each time it is evaluated
04:27:57 <Cale> (depending on what the user types)
04:28:22 <Cale> So even though we're giving the same IO action, we're getting different results -> it is not a function.
04:28:50 <isomorphic> In some languages, a loop collects IO events and passes these out to functions in response to that IO.  Is there a way of achieving that sort of effect in Haskell without Control.Concurrent?
04:29:31 <Cale> isomorphic: Well, what do you mean by "collects IO events"?
04:29:34 <merijn> isomorphic: You just mean an event loop?
04:29:50 <Cale> isomorphic: If you can write the IO action which does that, then certainly
04:29:56 <isomorphic> Cale:   waits for a character on the keyboard, might be an example
04:30:22 <merijn> isomorphic: Just use something like getChar which waits for a character from the keyboard? :p
04:30:26 <Cale> But forking a few threads is the standard way to do what you'd usually do with select/epoll/etc.
04:30:50 <merijn> You can have an event loop by waiting for an event and having event handlers of type "WorldState -> IO WorldState"
04:31:02 <Cale> (and internally, the RTS implementation uses epoll/kqueue where available instead of select)
04:31:08 <merijn> Also, Control.Concurrent is freaking awesome, why avoid it? :p
04:31:36 <isomorphic> merijn:  Heheh.  I'm trying to figure out how it works ;)
04:31:36 <latermuse> ls
04:31:38 <latermuse> oops ;)
04:32:18 <merijn> isomorphic: The runtime system uses epoll/kqueue/select to wait for a file descriptor to become ready and uses this to wake up and schedule haskell forkIO threads
04:33:06 <Cale> When you use various "blocking" IO actions like getLine, they really use nonblocking IO internally
04:33:28 <CubeZero> > let xs = zip [5,1] [False, True] :: [(Int, Bool)] in minimumBy (comparing fst) xs
04:33:30 <lambdabot>   (1,True)
04:33:40 <merijn> So, for example. "hGetLine" will tell the runtime system "block me until I can read from this fd", then goes to sleep until the fd is ready and RTS wakes it to continues
04:33:51 <CubeZero> > let xs = zip [5,1] [False, True] :: [(Int, Bool)]; cmpfst = comparing fst in minimumBy cmpfst xs
04:33:53 <lambdabot>   (1,True)
04:34:19 <CubeZero> > let xs = zip [5,1] [False, True] :: [(Int, Bool)] in let cmpfst = comparing fst in minimumBy cmpfst xs
04:34:21 <lambdabot>   (1,True)
04:34:40 <merijn> CubeZero: Lambdabot also responds to privmsg if you just want to play around
04:34:46 <CubeZero> > let cmpfst = comparing fst in let xs = zip [5,1] [False, True] :: [(Int, Bool)] in minimumBy cmpfst xs
04:34:48 <lambdabot>   (1,True)
04:35:03 <CubeZero> oh sorry
04:35:16 <CubeZero> how do i send him a private message? with :lambdabot?
04:35:35 <merijn> CubeZero: In most IRC clients you can just write "/msg lambdabot text here"
04:35:55 <DMcGill> In game programming, if I have a desired fps value and let spf = 1/fps. Once there are no more events, my plan was to sleep for `spf - (time since last frame'. That way I get an average fps of my desired value unless it's taking too long to process events. Does that sound like a good way of doing it?
04:36:07 <ChristianS> CubeZero: or  /query lambdabot  for an ongoing dialogue
04:36:16 <merijn> DMcGill: That's how most C engines I've seen do it
04:36:38 <merijn> DMcGill: But why not run unlimited?
04:36:46 <CubeZero> lambdabot: @run "hi"
04:36:48 <lambdabot>   "hi"
04:37:34 <isomorphic> DMcGill:    New to me - but - how about the opposite problem where you want to cut a calculation short?  I saw this link while discussing here - http://stackoverflow.com/questions/11320180/compute-as-much-of-a-list-as-possible-in-a-fixed-time
04:37:44 <DMcGill> I was told (and it makes sense) that polling in a tight loop is bad form
04:38:12 <merijn> DMcGill: It's bad form for applications that are supposed to gracefully share the CPU
04:38:32 <merijn> DMcGill: That is mostly not true for games as they are expected to run be the only thing running
04:38:44 <merijn> Or, at least the only thing anyone cares about while running them
04:39:16 <DMcGill> I guess it's just another case of me prematurely optimising - I might as well take the easier option in development as it's pretty easy to change it
04:39:18 <merijn> They're one of the few scenarios where most users would think hogging the CPU is acceptable
04:40:14 <Saizan> tbf, getting my cpu much hotter for no reason is not so nice :P
04:40:22 <merijn> You might want to cap when the game is minimised, but that seems more of a later add on feature.
04:40:23 <JuanDaugherty> bad form, dirty, ewwww
04:40:37 <DMcGill> Heroes of Newerth uses 100% of a core all the time
04:40:50 <DMcGill> tbh it's the only game I've found that does so
04:40:56 <merijn> Saizan: Well, unless you're writing something like nethack your CPU is going to get heated anyway
04:41:14 * hackagebot language-puppet 0.3.0.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.3.0.0 (SimonMarechal)
04:41:20 <merijn> DMcGill: Galactic Civilizations is pretty good at (ab)using CPU time
04:41:27 <kranius> nethack is hot
04:41:33 <kranius> not cpu wise of course
04:41:46 <DMcGill> yes, graphics is no indication of CPU usage - see Dwarf Fortress
04:41:48 <Saizan> i don't know, silly flash games should know their place, for example :)
04:41:53 <merijn> One of the first games where I really saw my dual core CPU start to shine
04:42:05 <merijn> Saizan: That's just flash sucking, I think
04:42:21 <kranius> civilization series abuse my cpu too
04:42:53 <merijn> GalCiv used available extra cores to have the AI plan its turns while you ran your own, meaning the AI's turn would almost always be instantaneous after you finished yours. Very pleasant :)
04:43:27 <merijn> In general it had one of the more impressive AIs I've seen
04:43:42 <kranius> Neat.
04:44:58 <DMcGill> urgh, waiting for the AI in Civ games
04:45:44 <DMcGill> there was a neat mod for Civ 4 that cached a load of AI values and look advantage of how much more memory we have these days to get less CPU time
04:46:16 * hackagebot puppetresources 0.4.0 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.4.0 (SimonMarechal)
04:49:37 <CubeZero> The following ghci session lets the monomorphism restriction bite: ghci> :m +Data.Ord ; :type comparing fst ; let cmp = comparing fst ; :type cmp -- cmp and comparing fst are the same but have different types! Could someone with an account copy & paste this MR example into http://www.haskell.org/haskellwiki/Monomorphism_restriction ?
04:52:22 <YoFO> hi folks..
04:52:43 <CubeZero> Good morning :)
04:54:37 <DMcGill> not where I am!
04:56:47 <hpaste> lattenwald pasted ‚Äúcombinations‚Äù at http://hpaste.org/77918
04:58:26 <solrize> has anyone here ever used algol?  it had call-by-name parameter passing and i'm wondering if that caused the same confusion, performance bugs etc. that we associate with lazy evaluation in haskell
04:58:59 <YoFO> just done some Clojure,... looks very similar to Haskell.
04:59:17 <YoFO> Why should I learn Haskell over Clojure ?
04:59:18 <kranius> lol what
04:59:22 <shachaf> solrize: Not really the same thing.
04:59:28 <solrize> clojure similar to haskell except for having strict evaluation and no type system?
04:59:30 <latermuse> is it possible to do this: (id &&& (functionOne . functionTwo)) list   ?
04:59:40 <shachaf> solrize: For that matter, lazy evaluation isn't call-by-name.
04:59:46 <solrize> latermuse, sure
04:59:50 <Botje> YoFO: you should learn both.
04:59:56 <shachaf> latermuse: Hmm, is it?
05:00:05 <solrize> shachaf, right, call-by-name would be even worse, and in algol's case the parameters were mutable too
05:00:12 <latermuse> im getting a weird type error while trying it
05:00:57 <merijn> :t (&&&)
05:00:59 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
05:01:18 <solrize> > (id &&& (head . reverse)) [2,3,4]
05:01:29 <merijn> latermuse: That should work *if* functioIne returns a list of the same type as the input list
05:01:33 <merijn> oh, wait
05:01:35 <solrize> lambdabot ?
05:01:36 <lambdabot>   ([2,3,4],4)
05:01:37 <merijn> No, I'm claiming nonsense
05:01:45 <merijn> Ignore that :p
05:01:59 <shachaf> solrize: Presumably it just means copying pointers there?
05:02:00 <merijn> latermuse: Post the code + error?
05:02:48 <latermuse> let addHtml = (id &&& (addHtml . replaceSpaces)) names    where   replaceSpaces n = map (replace " " "-") n    addHtml n = map (++ ".html") n
05:02:53 <shachaf> Well, I don't actually know what you mean.
05:02:57 <solrize> shachaf you mean for mutation and cbn?  hmm i dunno what happens if you overwrite a thunk, i'm thinking of stuff like
05:03:12 <YoFO> Botje: why should I learn both...both functional languages. Just looking for some inspiration here...
05:03:35 <solrize> function f (x,y) { x = 3; print x, y }      # this isn't really algol syntax of course
05:03:59 <solrize> function g { a = 2; f (a, 2*a); }
05:04:07 <latermuse> YofO: *both* functional languages? You mean ocaml and lisp?
05:04:10 <solrize> then g would print 3, 6
05:04:15 <solrize> if i understand correctly
05:04:29 <DMcGill> latermuse: YofO has already said Clojure and Haskell
05:04:43 <solrize> yofo, clojure is a pretty cool lisp that is polluted by the jvm
05:04:53 <latermuse> DMcGill: Ah, ok! I didnt see that line.
05:04:54 <solrize> haskell is a typed language
05:04:55 <kranius> i'd pick scheme if you want to learn a lisp
05:04:58 <Botje> YoFO: you should learn Haskell to see what a decent type system gets you.
05:04:59 <solrize> haskell is much more interesting imho
05:05:03 <DMcGill> YofO: Pro: Clojure gets tvm Con: Clojure uses jvm
05:05:08 <Dodek> kranius: scheme is not a lisp
05:05:16 <merijn> latermuse: And what is the error
05:05:19 <merijn> Dodek: Yes it is
05:05:33 <kranius> Dodek: why not ?
05:05:38 <solrize> if you already know an untyped language like scheme/python/ruby/JS/whatever then clojure is basically more of the same
05:05:39 <latermuse> Couldn't match expected type `[[Char]] -> c'0' with actual type `([[Char]], c'0)'
05:05:46 <latermuse> Probable cause: `id &&& (addHtml . replaceSpaces)' is applied to too many arguments
05:06:06 <merijn> latermuse: Names is not the right type, then
05:06:25 <merijn> latermuse: Wait...
05:06:27 <latermuse> how did you get that information?
05:07:23 <killy9999> I just finished reading Marlow's tutorial on parallelism and concurency
05:07:33 <latermuse> this is what is in names: ["First Post","Hohoho","Just testing","The Cat is out of the bag","meow"]
05:07:34 <killy9999> and I have two short questions
05:07:47 <merijn> latermuse: Well, it's saying it was expecting a type "[[Char]] -> c'0" but you're giving it the type "([[Char]], c'0)", i.e. what you're giving it must not have the type you expect.
05:07:53 <YoFO> DBcGill:what is tvm ?
05:08:08 <killy9999> are STM transactions always rolled back when exception is thrown, or only if they are called via catchSTM ?
05:08:10 <merijn> latermuse: Alternatively, do you have any type signatures anywhere?
05:08:12 <DMcGill> oops, I meant JVM
05:08:20 <Dodek> kranius: the point of scheme is being small, dynamically typed functional language. the point of lisp is creating abstractions using syntax extensions.
05:08:27 <latermuse> no type signatures yet
05:09:04 <merijn> Dodek: Irrelevant, "a lisp" is what McCarthy defined Lisp to be in his original paper and Scheme fully meets that description, therefore Scheme is a Lisp
05:09:28 <latermuse> there was a big lisp post on reddit today
05:09:31 <Dodek> merijn: who cares what mccarthy defined, really.
05:09:32 <killy9999> AFAIR McCarthy's definition was like 9 functions or so
05:09:43 <merijn> latermuse: Try replacing parts with undefined until it works, then attempt to figure out why the part that fixed it was not the correct type
05:09:47 <merijn> killy9999: Yeah, it's very small
05:09:54 <companion_cube> Dodek: do you know scheme allows for abstractions via syntax extension?
05:10:02 <latermuse> merijn: what is undefined
05:10:07 <merijn> :t undefined
05:10:09 <lambdabot> a
05:10:14 <killy9999> Dodek: I'm affraid more people will care about McCarthy's definition of Lisp than yours. No offence
05:10:14 <latermuse> oh cool
05:10:16 <latermuse> :D
05:10:18 <merijn> latermuse: undefined is a value that has any type
05:10:21 <merijn> > undefined
05:10:22 <Dodek> companion_cube: sure i know. i didn't feel that's the point of scheme, though.
05:10:24 <lambdabot>   *Exception: Prelude.undefined
05:10:31 <merijn> > [1,2,3,undefined]
05:10:33 <lambdabot>   [1,2,3,*Exception: Prelude.undefined
05:10:37 <companion_cube> Dodek: it is, that's why scheme is so small
05:10:41 <latermuse> neat! thanks
05:10:47 <companion_cube> you can define what you need from functions, references, macros and call-cc
05:10:56 <merijn> latermuse: Very handy to get code past the typechecker if you don't know what should be there yet
05:10:58 <fryguybob> killy9999: The effects of a transaction are not seen unless it commits.
05:11:14 <solrize> > let { addHtml xs = intercalate "<p/>" xs; replaceSpaces xs = map ("space ++") xs} in (id &&& (addHtml . replaceSpaces)) ["First Post", "Hohoho","Just testing"]
05:11:16 <lambdabot>   Couldn't match expected type `a0 -> b0'
05:11:16 <lambdabot>              with actual type `[GHC...
05:11:25 * JuanDaugherty cares what McCarthy defined
05:11:29 <latermuse> thanks, that should help me figure this out
05:11:31 <YoFO> ok thanks guys. Is Haskell used in real world in real projects..if so..what are they
05:11:35 <killy9999> fryguybob: OK, so it is always rolled back in case of exception?
05:11:44 <latermuse> YoFO: xmonad
05:11:45 <merijn> YoFO: Xmonad?
05:11:47 <killy9999> Marlow writes in such a way that it seems otherwise
05:11:49 <latermuse> :D
05:11:57 <DMcGill> http://www.haskell.org/haskellwiki/Haskell_in_industry
05:12:00 <killy9999> YoFo: GHC :)
05:12:00 <merijn> The new puppet implementation is in Haskell, no?
05:12:01 <fryguybob> killy9999: Yes, if you catch inside STM, then you are still in the transaction.
05:12:02 <JuanDaugherty> YoFO, define "real world"
05:12:04 <latermuse> im making a CMS in haskell right now
05:12:16 <fryguybob> killy9999: What writing are you refering to?
05:12:31 <killy9999> Marlow's tutorial on parallelism and concurency
05:12:35 <Dodek> killy9999: original mccarthy's paper is irrelevant mainly because what he created there was not even meant to be a real programming language. what's more, if you disregard the S-expressions and focus on M-expressions, it's not any more similar to modern lisps as, say, to python.
05:12:53 <hkBst> Dodek: syntax extension research seems to happen mostly in Scheme community...
05:13:35 <solrize> yofo what languages do you use now?
05:13:55 <JuanDaugherty> real ones apparently
05:14:08 <JuanDaugherty> like php and ruby
05:14:23 <solrize> ruby = matzlisp
05:14:23 <Paprikachu> xD
05:15:03 <killy9999> do I undestand correctly that MVars are introduce mutable state into Haskell?
05:15:10 <killy9999> s/are//
05:15:13 <osfameron> ruby isn't all that lispy
05:15:25 <JuanDaugherty> you're thinking python
05:15:27 <osfameron> well, no more so than javascript or perl
05:15:31 <DMcGill> killy9999: yes, IORef and STM also do that
05:15:37 <Dodek> hkBst: is there any kind of syntax extension research happening that's not the "create hygenic macros that are not less powerful than unhygenic macros"?
05:15:48 <DMcGill> as for which one you want to use, IORef is best on one thread iirc
05:15:54 <osfameron> python is less lispy, due to having poor scoping and lambdas
05:15:57 <JuanDaugherty> killy9999, MVars are mainly for concurrency  IIU
05:16:00 <JuanDaugherty> C
05:16:02 <DMcGill> if you need good concurrency behaviour, use STM
05:16:24 <killy9999> DMcGill: thanks
05:16:34 <kranius> btw, on ruby and lisp, this article was definitly a nice read http://experthuman.com/programming-with-nothing
05:16:37 <YoFO> I'm reading Bruce Tate's 7 languages book and have done Ruby, Clojure and have done programming in Java..
05:16:42 <killy9999> I just needed to make sure that I got this concept correctly
05:16:58 <killy9999> YoFo: great book
05:17:07 <DMcGill> have you looked at how to program C in Haskell with IORef?
05:17:11 <killy9999> Thanks to it I started with FP
05:17:27 <killy9999> DMcGill: I don't think so
05:17:37 <DMcGill> x = x + 1 ==> do {x' <- readIORef x, writeIORef x (x' + 1)
05:17:45 <DMcGill> they do fibb in it on the wiki somewhere
05:18:31 <merijn> killy9999: Well, mutable state with guaranteed ordering and mutual exclusion on accesses to it, so that's much better
05:18:32 <killy9999> I've done something similar with mutable vectors in ST monad
05:18:37 <killy9999> that was an ugly piece of code
05:18:56 <YoFO> actually...i got to bout the FP ecosystem from this book,...i'm interested...but I need nurturing
05:19:12 <hkBst> Dodek: yes, hygienic macros that are more expressive than unhygienic macros ;P syntax-rules is old history
05:19:22 <solrize> 7 languages has a haskell chapter apparently
05:19:25 <DMcGill> YoFO: if you want a Haskell tutorial, look at
05:19:28 <DMcGill> @where lyah
05:19:28 <lambdabot> http://www.learnyouahaskell.com/
05:19:31 <killy9999> YoFo: I had lots of fun with Prolog
05:19:49 <killy9999> but I skipped chapter on Clojure and read The Little Schemer instead :)
05:20:05 <merijn> killy9999: Not SICP? :p
05:20:46 <killy9999> merijn: I only skimmed SICP ;)
05:21:02 <killy9999> there's just to much to read...
05:21:27 <killy9999> I have four books lying on my desk that are waiting to be read - not mrntioning the papers
05:21:43 <kranius> what books killy9999 ? :)
05:21:57 <Dodek> hkBst: hygenic macros that are more expressive than unhygenic macros? could you please explain what you are thinking of?
05:21:59 * merijn still needs to read TaPL
05:22:42 <killy9999> kranius: Purely Functional Data Structures, To Mock a Mockingbird, Introduction to Functional Programming and Pearls of Functional Programming
05:24:09 <solrize> there's a famous paper by felleisen about the expressive power of PL's.  i've looked at it several times and can't understand what it is trying to say.  does anyone have a tl;dr summary ?
05:30:19 <bxx> "However, it's a very strong convention in Haskell to never add typeclass constraints in data declarations" <- is this widely accepted? he makes a compelling argument for not including them. ie doing data Map k v = ... instead of data (Ord k) => Map k v = ...
05:31:21 <bxx> does Map in stdlib have Ord contraints?
05:31:33 <Botje> bxx: no, all the operations have this constraint instead.
05:31:38 <hkBst> Dodek: http://lists.racket-lang.org/users/archive/2009-April/032406.html
05:31:52 <Botje> bxx: because some libraries might not want to export their data constructors
05:33:32 <Saizan> bxx: constraints on data declarations got removed in the latest revisions of the language (one of 2011 or 2012)
05:34:20 <bxx> Saizan ah I see
05:35:19 <merijn> bxx: Personally I've never encountered a good reason to use constraints on data in the past
05:35:41 <merijn> Any cases I could think of would be nicer with GADTs and existentials
05:40:12 <Saizan> GADTs behave quite differently, the old constraints weren't as useful
05:41:04 <Botje> @hoogle foldr
05:41:05 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
05:41:05 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
05:41:06 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
05:41:57 <merijn> Saizan: I know, like I said. I never found the old constraints usable, and any situation where I'd want to use constraints on datatypes the GADT is much more convenient
05:45:47 <Eelis> do i understand correctly that one cannot make a  UArray Int CDouble  ?
05:46:05 <Eelis> and if so, is there a good reason for that?
05:46:29 <bxx> is the latest revision introducing any other breaking changes? and does this happen often in new revisions of the language
05:46:58 <aristid> Eelis: using UVector is not an option for you?
05:47:05 <Eelis> oh, i'll have a look :)
05:47:27 <merijn> bxx: Well, the report is more a description of "haskell as it is" then a "standard which must be adhered to", one of the reasons it was removed is that almost no one used it
05:48:00 <Eelis> aristid: looks very interesting. i'll see if i can use it, thanks!
05:48:26 <aristid> Eelis: cool. it's my understanding that vector is considered superior to Array for most use cases
05:48:33 <merijn> bxx: I think you can still enable the behaviour using an extension
05:59:23 <Eelis> aristid: no dice :(  i think it's because the "primitive" package (which vector uses) doesn't have a Prim instance for CDouble. i wonder whether one could be added
06:00:08 <rwbarton> possibly you can generalizednewtypederive one?
06:00:08 <aristid> Eelis: you have to use CDouble?
06:00:21 <Eelis> aristid: well, i use GLdouble, which is defined as CDouble :)
06:00:46 <Eelis> and i need my GLdoubles tightly packed so i can copy them over to a vertex buffer object
06:00:54 <aristid> Eelis: oh
06:01:00 <rwbarton> how about a storable array
06:01:14 <aristid> Eelis: yeah, vectors and OpenGL might be a nice thing to work with oO
06:01:24 <Eelis> rwbarton: from what package?
06:01:52 <Eelis> oh i'm using StorableArray right now, but the docs say it's slower than UArray
06:01:53 <rwbarton> array
06:02:13 <Eelis> so i tried to use UArray but it doesn't like GLdouble
06:02:19 <Eelis> and neither does vector :/
06:02:49 <rwbarton> if you want to hand your array to a C function then I think you need a storable array (or storable vector) anyways
06:03:06 <Eelis> oh
06:04:08 <Eelis> i don't get why a C compatible type would be slower
06:04:19 <Eelis> this is what the storablearray docs say: "It is similar to IOUArray but slower."
06:07:23 <Eelis> i can see why it would be slower if they have to make special accomodations for mutability, but i don't need mutability, so it stands to reason i should be able to use an array/vector type that's optimally fast and very C read-compatible
06:10:31 <bxx> why am I getting "*** Exception: Prelude.read: no parse" when I type `read "10"' in the ghci? I could swear I was getting something about unambiguous type the other day
06:11:23 <dmwit> bxx: Because it's trying to parse it at type ().
06:11:31 <dmwit> bxx: Try read "10" :: Int or similar.
06:11:37 <ketil> bxx: maybe the monomorphism restriction - uh, dmwit +1
06:12:02 <dmwit> It's a combination of the MR and defaulting, yes.
06:12:20 <bxx> ah yes I turned that one on
06:12:22 <dmwit> Possibly also ghci's extended defaulting, but I'm never too clear on when that applies and usually it doesn't matter because I just turn off the MR. =P
06:12:28 <jix> Eelis: the garbage collector is free to move around arrays and vectors whenever it wants. That would be a problem when passing a pointer to it to C as the GC can't trackt that pointer to update it. Storable arrays/vectors use memory that has a fixed address and is not moved by the GC. (AFAIK)
06:13:34 <aristid> jix: in that case, he needs a Storable thing anyways, right?
06:14:45 <yitz> you can put :set -XNoMonomorphismRestriction in your .ghci
06:14:57 <Eelis> i don't need the pointer to be valid for a long time though. at some point i call the C function and that is the only time the memory is accessed
06:14:58 <yitz> in the next version of ghc, though, that will be the default
06:15:09 <rwbarton> not relevant to read "10" though
06:15:43 <dmwit> I think it is relevant. It turns an exception into an ambiguity error.
06:15:43 <aristid> yitz: in 7.8?
06:15:45 <yitz> true that's pretty inherently ambiguous :)
06:15:57 <yitz> aristid: i think so. check the ticket.
06:16:06 <rwbarton> just a matter of defaulting
06:16:09 <aristid> yitz: cool
06:16:31 <dmwit> Oh, huh. The MR isn't involved.
06:16:46 <dmwit> It seems like the MR ought to be involved.
06:16:47 <rwbarton> well there is no definition :)
06:17:08 <rwbarton> if you wrote: let x = read "10"
06:17:15 <rwbarton> and then: x :: Int
06:17:19 <yitz> dmwit: we;; bxx complained that before the error was "ambiguous..." and now it's "no parse". so that would be MR.
06:17:23 <rwbarton> now you have MR problems
06:17:24 <aristid> Eelis: storable vectors also seem to have all the fancy vector magic, nice
06:17:28 <dmwit> yitz: try it
06:17:37 <dmwit> yitz: -XNoMR doesn't change the "no parse"
06:17:57 <rwbarton> extendeddefaultingrules would change it
06:18:02 <dmwit> So there must be something else that he also did differently.
06:18:19 <dmwit> e.g. stick it in a file vs. type it in ghci or similar
06:19:06 <yitz> ok got it
06:19:36 <jix> Eelis: I guess it's just hard to implement correctly
06:19:56 <yitz> dmwit: you know that bxx is "he"?
06:20:06 <dmwit> I don't.
06:20:10 <jix> Eelis: with non moving memory it works in either case (whether the ptr is stored or not)
06:20:15 <dmwit> However, statistically speaking, it's the safer pronoun to use.
06:20:16 <yitz> just trying my best to keep things neutral around here :)
06:20:54 <osfameron> "they" is safer
06:21:02 <yitz> right or just repeat the nick
06:21:03 <osfameron> "ey" or "ze" is likely to get you stabbed in the face with a spoon
06:21:16 * hackagebot yaml 0.8.1.1 - Support for parsing and rendering YAML documents.  http://hackage.haskell.org/package/yaml-0.8.1.1 (MichaelSnoyman)
06:21:18 * hackagebot http-conduit 1.8.4 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.4 (MichaelSnoyman)
06:21:52 <jix> Eelis: I also think that the performance warning isn't correct for newer ghc versions
06:22:39 <Dodek> hkBst: that URL you sent me explains nothing
06:22:43 <yitz> dmwit: those statistics are changing. my company is about even now.
06:22:45 <jix> Eelis: "Additional comments: GHC 6.6 made access to 'StorableArray' as fast as to any other unboxed arrays."
06:23:06 <Eelis> jix: oh, sweet! thanks!
06:23:19 <jix> Eelis: allocation might be a tiny bit slower though
06:23:24 <Eelis> that's okay
06:24:12 <hkBst> Dodek: well, AFAIUI modern hygienic macros can break hygiene and thus can do what unhygienic macros can do, but the reverse doesn't hold.
06:24:21 <dmwit> I am aware of the issue and sympathetic with the people who want more sensitivity, but still feel that all proposed solutions are bad in their own way.
06:24:40 <pharm_> Has anyone told Braden Shepherd that his blog / Facebook is posting spammy ads?
06:25:00 --- mode: ChanServ set +o edwardk
06:25:08 --- mode: edwardk set +b *!~Lajla@*
06:25:18 --- mode: edwardk set -o edwardk
06:26:01 <yitz> dmwit: avoiding a default pronoun does take more thought and sometimes results in awkwardness. on the other hand, it also helps discourage the kind of offensive comments that used to be more common here.
06:26:29 * dmwit nods appreciatively
06:27:02 <Philippa> yitz: "they" makes an awesome default pronoun, too
06:27:19 <hidas> finnish ftw
06:27:20 <yitz> Philippa: often works, yeah.
06:28:39 <yitz> hidas: yes, interesting. google translate: "he and she" => "h√§n ja h√§n"
06:29:42 <pharm_> (said ads are hitting plant.haskell.org btw)
06:29:53 <hidas> yitz, that's right
06:29:53 <pharm_> (or planet.haskell.org even)
06:31:12 <hidas> yitz, english has a bit clumsy atoms here :)
06:32:06 * Saizan must have missed the period with the offensive comments in here
06:32:18 * typoclass too
06:32:30 <yitz> hidas: actually finnish is the first language i've heard of that doesn't have that clusminess
06:33:05 <Philippa> I've had a few rounds of people not exactly taking it well when I point out that they've used the wrong pronoun for me
06:33:09 <hkBst> yitz: I hear they retrofitted he/she distinction in Chinese
06:33:38 <yitz> Saizan: you were definitely around. you are fortunate that you didn't notice those comments. ;)
06:33:42 <Philippa> I'll be distinctly happy if I never get the same shitty joke that doesn't work about thinking I'm filipino, for example
06:34:10 <Philippa> (yes, I know the -o vs -a distinction, apparently they don't)
06:34:14 <hidas> finland also was the first country in the world to grant women unrestricted rights to vote and to stand for parliament.
06:34:20 <osfameron> that's weird.  If someone told me they are a "she" and not a "he", I'd apologize, and make a note
06:34:27 <osfameron> why take that badly?
06:35:07 <Philippa> osfameron: I suspect because being reasonably direct about it makes me "uppity"
06:35:24 <Philippa> (what they think when they discover I'm an op, I have no idea...)
06:35:40 <typoclass> Philippa: so is what you're saying related to the ban a few minutes ago? or two different things? (i'm unsure what's going on)
06:35:45 <osfameron> ah, I guess a lot is in the way you say it ;-)  but still
06:36:05 <Philippa> (also loss of face, worsened by my having an obviously-in-England female first name as my nick)
06:36:18 <Philippa> osfameron: I'm not actively impolite by US or UK standards
06:36:41 <Philippa> typoclass: right now? Topic drift
06:36:43 <osfameron> ah I see
06:37:00 <Philippa> Lajla's pulled a lot of shit, though
06:37:16 <Philippa> and I've a feeling (though I've not been keeping notes) that includes gender-related trolling here
06:37:37 <Philippa> (as opposed to, say, the lovely greeting I got in -blah 20-odd minutes ago)
06:37:46 <Philippa> (that, I'm entirely certain about)
06:39:14 <yitz> hkBst: wikipedia said it was the opposite. chinese pronouns did not specify gender, and they tried to change that to imitate european languages as part of a "modernization" program in the mid 20th century. in the end only the new characters caught on but not any distinction in pronunciation.
06:39:42 <yitz> http://en.wikipedia.org/wiki/Gender-neutral_pronoun
06:40:28 <yitz> looks like actually most languages are neutral. i only happen to know languages from the minority that specify gender.
06:41:04 <Philippa> *nod*. Would've saved a friend of mine a lot of time cataloguing them for English a while back before declaring their preference to refer to themself
06:41:44 * applicative looking into hidas ' s bold claims sees Sweden/Finland and Finland proper do have awfully early forms of women's suffrage.  New Jersey had it from 1790, but gave it up for genuinely 'universal' *male* suffrage.
06:42:19 <osfameron> there were earlier forms of female suffrage I think.  Didn't the celts have it?
06:43:30 <hidas> applicative, thanks for the correction
06:44:22 <applicative> osfameron: yeah I was just looking at accounts of the modern development.
06:44:42 * applicative evidently needs some type problem to solve
06:45:36 <earthy> The high rank ascribed to abbesses within the Catholic Church permitted some women the right to sit and vote at national assemblies - as with various high ranking abbesses in Medieval Germany, who were ranked among the independent princes of the empire and could therefore sit and vote in the Diet
06:45:44 <earthy> so, yeah. very limited though.
06:49:17 <hidas> What I find interesting is that the gender inspecific pronoun "h‰n" is informal speech almost always replaced by animateness inspecific "se", which in turn is sometimes used as a definite article which Finnish doesn't have.
06:50:01 <hidas> Maybe "the" could be used as the gender inspecific pronoun.
06:50:34 <nand`> Nothing like opening #haskell and finding discussions about the church; and not the kind you usually like to hear about
06:50:44 <hidas> is in informal speech*
06:50:45 <earthy> what I find interesting is that my son of 5 has serious trouble matching up the pronoun and the gender of the person/thing refered to
06:51:19 <osfameron> my *dad* has it now, which is really odd
06:51:29 <osfameron> whereas my mum (who is finnish, and therefore could be expected to) doesn't
06:51:32 <earthy> to the point of simply picking one of the pronouns at random and seeing if he'll be corrected.
06:52:57 <earthy> and especially with possessive pronouns
06:52:59 <applicative> nand` looking for uses of the singletons library I found a truly wild employment by you on hpaste.  I should try to figure it out
06:53:06 <typoclass> earthy: genders of things? what language is it?
06:53:27 <nand`> applicative: which one was that?
06:53:31 <earthy> typoclass: dutch
06:54:08 <typoclass> earthy: oh nice :-) at the risk of being ot, how many genders does it have?
06:54:18 <earthy> (which makes matters more complicated by not designating the gender in the article
06:54:21 <earthy> )
06:54:23 <mreh> am I stuck with fixed interval sampling with elerea? or is there a way to introduce the sample time into the network?
06:54:25 <merijn> typoclass: 3, male, female, genderless/inanimate
06:54:33 <earthy> what merijn says
06:54:44 <typoclass> ah thanks, same as german then. danish has only 2
06:54:49 <earthy> 3 genders, 2 articles
06:54:56 <applicative> nand` http://hpaste.org/77421 TAssocArray. What amazed me was all the functions it was promoting or however you put it
06:55:01 <earthy> as opposed to german that does have 3 articles
06:55:03 <mreh> way off topic :)
06:55:14 <nand`> ah
06:55:21 <merijn> Where genderless and male use the same articles
06:55:25 <nand`> yeah, that's quite nice; but it does have some jarring limitations once you start actually using it
06:56:05 <nand`> applicative: you can find an up to date version of that codebase in http://hub.darcs.net/nand/units/browse/src/Units/Internal/Types.hs and http://hub.darcs.net/nand/units/browse/src/Units.hs
06:56:31 <applicative> ah I see the darcs repos
06:57:58 <mreh> and I don't like Yampa's switching combinators, they're yucky to use
06:58:41 <mreh> is there a nice alternative that works (not reactive then) that uses a function of time like semantics
06:58:57 <mreh> elerea just uses functions of natural numbers, like a sort of sample index
06:59:06 <typoclass> nand`: sorry, this might be obvious, but what's a Unit in that code? does it represent "3 m" or just "m"?
06:59:21 <mreh> hence fixed interval
06:59:33 <nand`> typoclass: just ‚Äòm‚Äô
06:59:38 <nand`> ‚Äò3‚Äô would be the value
06:59:44 <nand`> it's like 3 :: Double :@ Meter
06:59:47 <typoclass> nand`: i see, thanks :-)
06:59:52 <typoclass> ooh
07:01:02 <typoclass> nand`: you know, this tiny example that's just 20 bytes long goes a very long way explaining things :-D thanks
07:01:33 <mm_freak> when you like yampa, you should really try out netwire
07:01:38 <mm_freak> netwire is yampa on steroids
07:02:20 <mreh> well, I was reading someone's blog where they were making Javascript games with netwire
07:02:31 <nand`> typoclass: (that's not an actual usage though; that would be a type error since Meter ‚â† One :)
07:02:31 <mm_freak> yeah
07:02:39 <nand`> typoclass: the actual usage would be 3*meter :: Double :@ Meter
07:03:21 <mreh> I was hooked in by reactive's first class signals, but I could probably go back to signal functions again
07:03:22 <typoclass> hm i see. so the type annotation here is just for illustration, or do you need it?
07:03:29 <earthy> merijn: no, male and female use the same articles in dutch, male and genderless the same pronouns
07:03:42 <nand`> typoclass: it's just there for illustration; that would be inferred as Num a => a :@ Meter
07:03:47 <merijn> earthy: I always mix up my english terminology
07:03:51 <typoclass> nand`: right :-) thanks
07:03:57 <mm_freak> mreh: the difference between yampa and netwire lies precisely in events and switching‚Ä¶  netwire gets events in FRP right
07:04:37 <mm_freak> mreh: signal functions are first class, too‚Ä¶  a behavior is basically a wire that ignores its input signal‚Ä¶  you can even write "15 + 3*time" in netwire
07:05:01 <mreh> signals are a Num instance?
07:05:07 <mm_freak> yes
07:05:10 <mreh> cool
07:05:27 <mm_freak> nothing special about that except i actually wrote the Num instance in netwire =)
07:05:38 <mm_freak> yampa lacks that instance, but it could do it, too
07:06:06 <mm_freak> the coolest feature however is signal inhibition, where you can write stuff like:  "yes" . periodically 1 <|> "no"
07:06:18 <mm_freak> that wire produces "yes" once every second, and "no" otherwise
07:06:30 <ion> OverloadedStrings?
07:06:34 <mm_freak> yes =)
07:06:36 <mreh> and Categories?
07:06:37 <mreh> :)
07:07:12 <mm_freak> of course
07:07:24 <mm_freak> you get an applicative interface, but also an arrow interface
07:07:31 <mreh> looks kind of compact
07:07:41 <mm_freak> it is =)
07:08:18 <mm_freak> mreh: check out the tutorial in the Control.Wire module
07:08:25 <mreh> oh, thats nice, I didn't always like having to write  >>^ ^>> &c &c &c everywhere
07:08:44 <mm_freak> yeah, exactly
07:09:06 <mm_freak> through the Num instance you can write arithmetic quite directly anyway
07:09:11 <mreh> I'm not sure that mitigates it, but if all you need is a pure function, you can't really map it over an arrow
07:09:14 <mm_freak> (also Fractional, etc.)
07:09:46 <mreh> is it as efficient as reactive?
07:10:07 <mreh> that's debatable I suppose
07:11:17 * hackagebot dawg 0.4.0 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.4.0 (JakubWaszczuk)
07:11:24 <mreh> I just wonder if we are a point where we can practically write games with the technology
07:11:38 <mreh> I know it's possible, I've done it, but only toy games
07:13:53 <applicative> nand`:  wow, the type errors are something, as one would have expected.
07:14:28 <nand`> applicative: yeah, it gets crazy
07:14:45 <nand`> applicative: also, the latest edition is super slow because I used rational instead of integer exponents, so I could encode planck units :)
07:15:08 <nand`> and apparently GHC is fairly slow at calculating my type-level rational addition and multiplicaiton algorithms :(
07:15:17 <applicative> hah
07:15:38 <applicative> I hadn't heard people complaining about that.
07:15:47 <applicative> They just complain about addition of Naturals....
07:16:32 <aristid> nand`: how does the speed compare to agda?
07:16:48 <CodePrincess> is there a point to type-level rational addition and multiplication in practical programs?
07:16:48 <nand`> no idea, agda would probably win out by a margin when it comes to dependent types
07:16:54 <nand`> type families seem to be strict also
07:17:09 <mm_freak> mreh: netwire has basically the same features as all the other FRP frameworks, except that it predefines a lot of useful stuff for you
07:17:11 <applicative> yes it's all strict up there
07:17:12 <nand`> at least one code failed to terminate until I factored out the if/then/else to a pattern match
07:17:13 <mm_freak> like signal averaging, etc.
07:19:07 <applicative> it occurred to me once they  might have done better to permit haskell-98 type kind definitions, kind Nat = Z | S Nat ; then later we could get genuine 'demotion' into strict types
07:19:17 <applicative> or 'unlifted' types
07:21:56 * nand` still wants type synonyms to be automatically lifted to kind synonyms
07:23:26 <mm_freak> mreh: to answer your other question, yes, FRP is ready for practical game development‚Ä¶  in fact i even think it's the way to go in the future
07:24:23 <mm_freak> the categorical FRP libraries (netwire, yampa/animas) have a very low memory footprint and are almost as efficient as if you would have written the code without FRP
07:26:30 <mm_freak> the only problem i see with yampa in particular is that all your FRP code is arrowic, which costs some performance, but you don't have that problem in, say, netwire
07:29:11 <neutrino> hey guys
07:29:38 <kranius> hey neutrino
07:29:45 <neutrino> hi :)
07:30:10 <neutrino> i have a question
07:30:12 <neutrino> if you're writing a complex, self-contained part of your program, is it usual for you to start with the types of the main functions, then break them down and write types for functions those would call, etc?
07:32:46 <Botje> yup
07:32:58 <Botje> I stub things out with undefined if I just want to type check.
07:34:46 <neutrino> yeah that's what i do too
07:44:32 <DMcGill> :t empty :: IO ()
07:44:33 <lambdabot>     No instance for (Alternative IO)
07:44:34 <lambdabot>       arising from a use of `empty'
07:44:34 <lambdabot>     Possible fix: add an instance declaration for (Alternative IO)
07:44:51 <DMcGill> well, guess it's just `return ()' then
07:45:01 <DMcGill> :t mzero :: IO ()
07:45:03 <lambdabot> IO ()
07:45:21 <DMcGill> 5 characters fewer oh yeah
07:46:07 <hpaste> ew0 pasted ‚Äúweird error‚Äù at http://hpaste.org/77919
07:46:22 <ew0> weird compilation error here
07:46:46 <ew0> expected type is the same as the actual type
07:46:51 <ew0> but code won't compile
07:47:49 * applicative has seen this before, but is at a loss where
07:49:12 <geekosaur> ew0, Gr is not a type constructor, it's a data constructor
07:49:18 <geekosaur> the type constructor is M_Graph
07:49:48 <ew0> I don't understand
07:50:30 <Botje> ew0: are you sure there's not multiple Gr types floating around?
07:50:34 <ew0> M_Graph should be a type synonim to Gr [P.Instruction] Int
07:50:38 <ew0> no, I'm not
07:50:41 <ew0> let me check
07:51:02 <Botje> i've scratched my head at expected type: ByteString actual type: ByteString a few times
07:52:04 <ew0> ow thanks
07:52:06 <ew0> that was it
07:52:29 <ew0> I had Data.Graph.Inductive.PatriciaTree and Data.Graph.Inductive both imported
07:52:56 <Botje> \o/
07:54:26 <peopleHands> Has anyone had a problem with Network on Windows where it says "Saw Main, expected Network"?
07:56:04 <watermind> is there any 'tutorial' alternatives to subtyping in haskell?  I can think of a few different possibilities, but still wonder if I'm missingh something
07:56:23 <ew0> subtyping?
07:56:39 <merijn> watermind: Depends on what you want to do?
07:56:48 <dgpratt> peopleHands: you mean you are trying to cabal install network and this is the result?
07:56:59 <merijn> watermind: The usual solutions are embedding, typeclasses and existentials, depending on the problem
07:57:11 <watermind> merijn: I know, which is why I'd like to see a tutorial on the subject with different approaches for different kinds of problems:)
07:57:15 <applicative> peopleHands: What is the name of your file?
07:57:51 <watermind> merijn: well for instance now we also have kind promotion, it kind of gives subtyping if I understand correctly
07:57:57 <ew0> 97,3% chance of what you are looking for is type classes
07:57:57 <peopleHands> dgpratt: No, well, it doesn't build when I cabal install. But what normally happens if I try to load Network in any file at all it just complains
07:58:03 <merijn> watermind: No
07:58:13 <applicative> peopleHands: It sounds like it is looking for a file called Network in the directory.
07:58:15 <peopleHands> Even if it's a new file. Like "networkTest.hs", I'll get hte error
07:58:16 <peopleHands> Aaah
07:58:19 <merijn> watermind: Kind promotion is used for different things entirely
07:58:37 <merijn> watermind: You can use it to encode more information in your types
07:58:39 <watermind> merijn: I know it is, but doesn't it gives you a weak kind of subtyping
07:58:47 <applicative> peopleHands: is the network package installed? it comes with the platform
07:58:55 <merijn> watermind: Are you familiar with the term "phantom types"?
07:59:06 <watermind> merijn: in the sense that a single constructor of a sum type originates a new type?
07:59:09 <watermind> merijn: yes
07:59:13 <dgpratt> applicative: I don't think it does these days
07:59:24 <peopleHands> applicative: Yeah, even it used t happen with the old Haskell platform so I removed it and installed the newest
07:59:31 <peopleHands> Still happens
07:59:45 <beaky> hello
08:00:09 <beaky> how do I write a functin f such that (f . f) x = -x?
08:00:10 <merijn> watermind: I have some code which has a Record datatype with records being either control records or data records, which I wanted to encode in the types.
08:00:50 <merijn> watermind: With phantom types you'd usually do "data Record a = {- no mention of a here -}" and "data Control; data Data" and give "Record Data" as signature
08:01:00 <Keiro> can any one point me to an interpreter for simply typed lambda calculus implemented in Haskell?
08:01:04 <dgpratt> peopleHands: I had my own problems with the network package on Windows; I was finally able to get it working by following this approach: http://blog.johantibell.com/2011/01/setting-up-haskell-development.html
08:01:05 <merijn> The unfortunate downside is that now "Record Int" is also a valid type
08:01:21 <merijn> watermind: Because "Record :: * -> *"
08:01:53 <applicative> peopleHands:  this happens when you write 'import Network' at the top of the file?  what about e.g. Network.URI
08:02:09 <merijn> watermind: With data kinds you can do (note, this syntax is not real, but a bit less confusing) "kind RecType = Data | Control; data Record (a :: RecType) = ..."
08:02:29 <merijn> watermind: This gives "Record :: RecType -> *" which means "Record Int" is now a type error
08:03:03 <merijn> watermind: That's more the type of thing you'd use kind promotion for
08:03:15 <merijn> watermind: Which is rather unrelated to subtyping like things
08:03:44 <applicative> peopleHands: I think installing network via cabal install on windows is likely to be pretty rough.  it is very difficult on os x to get the linking right, and it's usually somewhat easier than windows
08:04:15 <applicative> peopleHands: Its just the kind of thing it makes sense to have the 'haskell platform' for
08:05:00 <peopleHands> applicative:I'm giving that blog post a shot. Haha, haskell platforms works on my other computers. Oh well
08:05:01 <watermind> merijn: I'm not clear on how you're using phantom types to simulate subtyping still....  how do you get subtyping?
08:05:35 <watermind> merijn: so you could parameterize your Record with different kinds of Data
08:06:03 <applicative> peopleHands: well he is the maintainer of network.  See also the github page https://github.com/haskell/network/issues/59
08:06:33 <bitonic`> refresh my memory: when are we going to get holes?
08:07:57 <nand`> they're in 7.7 iirc
08:08:00 <nand`> so 7.8?
08:09:15 <watermind> merijn: nevermind I think I get the idea
08:09:20 <tibbe> Are there monoids with multiple identities?
08:09:44 <S11001001> tibbe: different identities live in separate monoids
08:09:56 <tibbe> S11001001: that's what I thought
08:09:58 <S11001001> tibbe: e.g. Bool gives rise to two separate monoids
08:10:12 <merijn> watermind: My point was that they're not really used to simulate subtyping :p
08:10:16 <tibbe> S11001001: context: https://github.com/haskell/cabal/issues/1053#issuecomment-10519054
08:10:49 <watermind> merijn: right, I mean you can add the type information but it's still unsafe in the same way phantom types are unsafe for other purposes
08:11:13 <applicative> it would have to be that  o <> i = i  and o <> i = o
08:11:28 <watermind> merijn: it does make it easier to be "correct" because it restricts errors to specific parts of the code
08:11:29 <merijn> watermind: You can make it safe by using GADTs to enforce that right types for the right constructor
08:11:53 <watermind> merijn: right
08:11:55 <merijn> watermind: GADTs can force a certain constructor to always return the right phantom type
08:12:06 <watermind> merijn: yes, got it
08:12:32 <S11001001> tibbe: Ah. I don't think it's disallowed to have multiple identities aside from the canonical mempty one.  But that example violates the monoid identity laws anyway.
08:12:35 <watermind> merijn: that makes perfect sense
08:13:24 <aristid> S11001001: multiple identities... what would mempty `mappend` otherIdentity return?
08:13:36 <aristid> S11001001: and what about otherIdentity `mappend` mempty?
08:13:48 <S11001001> aristid: that's a good counterexample; I didn't think of that.
08:13:56 <aristid> :)
08:14:12 * applicative insists it was his counterexample! 
08:14:28 <S11001001> applicative: well aristid used longer identifiers :)
08:14:44 <applicative> Yeah I guess it was a little opaque
08:15:22 <aristid> applicative: i'll give you half of the prize cake
08:15:38 <applicative> aristid: you know how much this means to me.
08:16:19 * hackagebot Unixutils 1.52 - A crude interface between Haskell and Unix-like operating systems  http://hackage.haskell.org/package/Unixutils-1.52 (DavidFox)
08:16:31 <beaky> in Haskell, how do I write a function f(x) such that f(f(x)) = -x ?
08:16:46 <t7> using abs
08:17:05 <t7> > let f x = abs x * -1 in f (f 123)
08:17:07 <lambdabot>   Precedence parsing error
08:17:08 <lambdabot>      cannot mix `GHC.Num.*' [infixl 7] and prefix ...
08:17:16 <t7> > let f x = abs x * (-1) in f (f 123)
08:17:18 <lambdabot>   -123
08:17:18 <S11001001> t7: forall x
08:17:27 <t7> > let f x = abs x * (-1) in f (f (- 123))
08:17:29 <lambdabot>   -123
08:17:36 <t7> three cheers for me
08:17:41 <beaky> > let f x = abs x * (-1) in f(f (-3))
08:17:43 <lambdabot>   -3
08:17:47 <beaky> :(
08:17:47 <S11001001> t7: ...
08:17:56 <aristid> beaky: you could also use complex numbers
08:18:04 <beaky> I have done it in python and C++ without complex numbers
08:18:20 <copumpkin> ...
08:18:41 <copumpkin> then take the function you wrote in python and C++ and write it in haskell
08:18:48 <aristid> > let f x = x * (0 :+ 1) in f (f 123)
08:18:50 <lambdabot>   (-123.0) :+ 0.0
08:18:54 <aristid> \o/
08:19:18 <beaky> I used closures in those other 2 languages
08:19:28 <copumpkin> o.O
08:19:30 <bartavelle> ??
08:19:34 <copumpkin> mutable, I assume
08:19:40 <aristid> beaky: http://hpaste.org
08:19:53 <S11001001> beaky: was the function you wrote actually a function then?
08:20:11 <beaky> yes
08:20:26 <copumpkin> then ****ing show it to us :P so we can tell you how to do it in haskell
08:21:00 <copumpkin> we shouldn't have to chase you down to help you out
08:21:42 <Botje> {-# RULES "f/f" forall x. f (f x) = negate x #-}
08:21:43 <Botje> f = id
08:21:46 <Botje> :o)
08:22:09 <beaky> copumpkin: alright I will paste the C++ version
08:22:32 <beaky> there was a nice python version in a stackoverflow question but I lost it :(
08:22:34 <t7> are there many other functions where f (f x) == x ?
08:22:37 <beaky> I will see if I can write it again
08:22:51 <beaky> let f = id in f(f(3))
08:22:53 <beaky> > let f = id in f(f(3))
08:22:55 <lambdabot>   3
08:23:04 <t7> oh and f x != x
08:23:07 <beaky> http://ideone.com/u2X20z
08:23:08 <aristid> beaky: note that you don't need all that many parens
08:23:12 <beaky> right
08:23:14 <aristid> f (f 3) suffices
08:23:20 <beaky> or (f . f) 3 :D
08:23:20 <atriq> Hmm
08:23:21 <copumpkin> t7: http://en.wikipedia.org/wiki/Involution_(mathematics)
08:23:40 <beaky> @src (.)
08:23:41 <lambdabot> (f . g) x = f (g x)
08:23:41 <lambdabot> NB: In lambdabot,  (.) = fmap
08:23:47 <aristid> beaky: not even in c++ is that a function.
08:24:08 <beaky> how do I do that in haskell though?
08:24:14 <copumpkin> it's not even close to being a function, but you could probably approximate that with typeclasses in haskell
08:24:19 <copumpkin> why do you want to, though?
08:24:23 <aristid> beaky: yo could abuse typeclasses
08:24:26 <aristid> *you
08:24:27 <danr> t7: http://en.wikipedia.org/wiki/Involution_(mathematics)
08:24:42 <t7> ok ok im reading it guys
08:24:47 <beaky> ah
08:24:50 <copumpkin> t7: http://en.wikipedia.org/wiki/Involution_(mathematics)
08:24:53 <copumpkin> :P
08:24:54 <beaky> I want to impress folks with this puzzle
08:24:55 <danr> oh sorry I missed copumpkin's answer :)
08:25:03 <t7> hehe
08:25:04 <aristid> danr: no not the same thing, he wants f(f(x)) = -x
08:25:17 <copumpkin> aristid: t7 asked about the non-negated one
08:25:18 <danr> aristid: no, see backlog :p
08:25:26 <aristid> oh, sorry then
08:25:31 <atriq> I could do this as class Typeable p => Post p, data Post = {commonStuff :: blah... postTypeSpecificStuff :: Post p => p} or something
08:25:35 <atriq> But that would be nasty
08:25:52 <aristid> danr: i actually did read the backlog but i imagined t7 uses a - there, like beaky before :)
08:26:17 <aristid> atriq: yes, don't do that.
08:27:06 <aristid> danr: are there many functions (as opposed to typeclass hacks) for which f (f x) = -x? other than f x = x * i
08:27:18 <beaky> http://stackoverflow.com/questions/731832/interview-question-ffn-n found it :D
08:27:29 <jesyspa> aristid: f x = x * j, f x = x * k... :)
08:27:49 <jesyspa> (And I'm not sure if you could extend it to octonions, but there's probably some way.)
08:28:09 <aristid> jesyspa: haha
08:28:38 <beaky> :d
08:29:24 <copumpkin> beaky: what was wrong with the negated absolute value?
08:30:09 <aristid> copumpkin: it doesn't work for negative numbers
08:30:10 <bartavelle> copumpkin, it must work with signed integers
08:30:16 <copumpkin> ah okay
08:30:57 <bartavelle> beaky, you can convert the python solution directly
08:31:11 <beaky> you can?
08:31:16 <beaky> what would it look like
08:31:16 <copumpkin> :t even 2
08:31:18 <lambdabot> Bool
08:32:00 <copumpkin> beaky: almost identical, if you want it to
08:32:49 <watermind> merijn: that solution works for many things, but consider for instance a representation of first order polymorphic types (so no explicit quantifiers needed) and you want to distinguish between polymorphic and monomorphic subtypes
08:33:34 <bartavelle> beaky, exactly the same
08:33:49 <copumpkin> :t let f n = if n == 0 then 0 else if n >= 0 then if odd n then n + 1 else negate (n - 1) else if odd n then n - 1 else negate (n + 1) in f
08:33:51 <lambdabot> Integral a => a -> a
08:34:00 <copumpkin> I just read it out
08:34:11 <watermind> merijn: follwing the Phantom types/GADT approach you'd have data Mono; data Poly;  data Type a where ...
08:34:17 <bartavelle> > f (f 4)
08:34:19 <lambdabot>   Ambiguous type variable `t0' in the constraints:
08:34:20 <lambdabot>    (GHC.Show.Show t0)
08:34:20 <lambdabot>     ...
08:34:34 <bartavelle> ah
08:34:37 <copumpkin> @let beaky n = if n == 0 then 0 else if n >= 0 then if odd n then n + 1 else negate (n - 1) else if odd n then n - 1 else negate (n + 1)
08:34:39 <bartavelle> you did not define it
08:34:39 <lambdabot>  Defined.
08:34:42 <copumpkin> > beaky (beaky 5)
08:34:43 <eacameron> is there a better way of saying (f x <$>) <$> y ?
08:34:44 <lambdabot>   -5
08:34:50 <watermind> merijn: and then you'd have a constructor  Nat :: T Mono   and another    Var :: String -> T Poly
08:34:55 <copumpkin> @let beaky2 = beaky . beaky
08:34:57 <lambdabot>  Defined.
08:35:05 <copumpkin> > map beaky2 [-5..5]
08:35:08 <lambdabot>   [5,4,3,2,1,0,-1,-2,-3,-4,-5]
08:35:22 <watermind> merijn: but then don't we get stuck when trying to implement Products or Exponentials?
08:36:19 * hackagebot Extra 1.46 - A grab bag of modules.  http://hackage.haskell.org/package/Extra-1.46 (DavidFox)
08:36:27 <fmap> eacameron: I often define (.:) as `fmap fmap fmap' and use it instead
08:36:41 <copumpkin> fmap: very narcissistic of you
08:36:56 <eacameron> fmap: I was gonna say! The smiley face messed it up for me
08:36:57 <watermind> merijn: i.e.  what would be the type of  Prod :: T ? -> T ? -> T ?
08:37:21 <eacameron> fmap:   you mean   .: ??
08:37:29 <copumpkin> watermind: T a -> T b -> T (a, b)
08:37:37 <copumpkin> watermind: I don't have any context :P
08:37:44 <copumpkin> so I just threw that in cause it sounded good
08:38:08 <fmap> eacameron: yeah, that would be `f x .: y'
08:38:16 <watermind> copumpkin: :)
08:39:13 <eacameron> fmap: I thought .: was often (.) . (.) ?
08:39:20 <watermind> copumpkin: I was wondering about ways to 'simulate' subtyping in haskell, so we were talking about using phantom types and GADTs, with the phantom type being used to annotate the specific sub type used
08:39:42 <copumpkin> ah
08:39:43 <watermind> copumpkin: and GADT to make it compile-time safe
08:40:08 <uffot> hiho, where can I read the source of the implementation of (->) ? If I use :i (->) it says it is defined in GHC.Prim but I can't find the source of this package
08:40:21 <copumpkin> uffot: it's built-in
08:40:23 <fmap> eacameron: yes, and (.) = fmap :)
08:40:26 <copumpkin> uffot: it can't be defined in the language
08:40:36 <eacameron> fmap: oh yes...on functions
08:40:43 <watermind> copumpkin: so that works for simple examples, e.g. having a data Shape a = ...   and then  data Rectangle; data Triangle and what not to annotate them
08:40:54 <copumpkin> watermind: the usual way I consider making subtyping in haskell is to make a 2-param typeclass representing the subtyping relation, with a method for injecting
08:41:03 <copumpkin> then you need a bunch of instances, of course
08:41:16 <fmap> eacameron: so `fmap fmap fmap' is basically generalized `(.) . (.)'
08:41:41 <uffot> copumpkin: I don't want to define it I want to know how it is defined. :i (->) only gives me "data (->) a b "
08:41:54 <copumpkin> watermind: but then you can say area :: (Shape :> a) => a -> Double
08:41:55 <copumpkin> or something
08:42:11 <copumpkin> uffot: it's not defined anywhere
08:42:15 <copumpkin> uffot: it's lying or something
08:42:26 <watermind> copumpkin: right but using the classes approach it leads to lots of code duplication if you're using pattern matching no?
08:43:02 <geekosaur> uffot, while you can to some extent pretend it's a function with a definition, mostly it's baked in syntax.  and "GHC.Prim" is code for "baked into the compiler"
08:43:58 <uffot> geekosaur: ok, thx
08:44:03 <hpaste> not_simon pasted ‚ÄúCrappy isNegative implementation‚Äù at http://hpaste.org/77921
08:44:17 <t7> webscale
08:44:35 <watermind> copumpkin: i.e. your approach is rather general and works really well to establish a subtyping relation between types, but if you just want to differentiate between certain constructors being used in a type or not, it seems overkill
08:44:47 <copumpkin> ah, probably
08:45:35 <watermind> copumpkin: So in the shapes example the Phantom/GADT
08:45:39 <watermind>  tops
08:45:45 <watermind> ops
08:45:59 <watermind> copumpkin: So in the shapes example the Phantom type/GADT approach is enough to restrict certain functions to triangles or rectangles
08:46:53 <watermind> copumpkin: using type classes you'd need to implement different types for Rectangles, Triangles, and their Sums
08:47:02 <copumpkin> yeah
08:47:07 <watermind> copumpkin: plus rewrite functions acting on these types
08:47:23 <watermind> copumpkin: so now I was wondering if the GADT approach worked for something just slightly more complicated
08:47:38 <watermind> copumpkin: therefore the example of  representation of 1st order poly types
08:47:55 <watermind> copumpkin: where it is mono if there are no type vars, and poly if there exists at least one
08:48:21 <watermind> copumpkin: sure we can use phantom types and smart constructors, but I was wondering if we could make it type safe using GADTs
08:48:38 <watermind> copumpkin: I think the answer is no... but maybe there is some trick I don't know
08:50:12 <copumpkin> hmm, not sure :)
08:50:15 <watermind> copumpkin: so with no GADTs we have   data T a = Nat | Var String | Exp (T a) (T a)    and   data Mono   and data Poly   to annotate the type
08:51:11 <watermind> copumpkin: with GADTs  we'd get   Nat :: T Mono  ;  Var :: String -> T Poly   ;  Exp :: T ? -> T ? -> T ?    :(
08:53:25 <watermind> functions at the type level would come in handy
08:53:26 <t7> why not dependent types.jpg
08:53:48 <watermind> t7: yeah... exactly
08:54:24 <t7> im sure there is a caption photo for that
08:55:09 <copumpkin> watermind: well, what logic do you want in Exp?
08:56:48 <atriq> Okay, this solution is absolutely ridiculous, but works
08:57:24 <watermind> copumpkin: Exp :: T a -> T b -> T (f a b)      with   f Poly Mono = Poly ;  f Mono Poly = Poly ;   f Mono Mono = Mono ;    f _ _ = undefined
08:57:33 <copumpkin> watermind: then use a type family :)
08:58:16 <copumpkin> watermind: you're going to have to decide what to do with the other option though
08:58:30 <copumpkin> type family Exp x y :: *; type instance Exp Poly Mono = Poly; type instance Exp Mono Poly = Poly; type instance Exp Mono Mono = Mono
08:58:34 <copumpkin> with Poly Poly
08:58:56 <copumpkin> you could make Mono/Poly into a lifted data type
08:59:39 <hpaste> johnw annotated ‚ÄúAdjunction.hs‚Äù with ‚ÄúAdjunction.hs (annotation)‚Äù at http://hpaste.org/77843#a77922
09:01:39 <Canar> What's an ideal Haskell tutorial for a guy with a CS degree and plenty of experience with non-Haskell languages?
09:01:53 <johnw> any of them, really
09:02:14 <copumpkin> sadly, most CS education and non-haskell languages don't give you much help with getting a started with haskell
09:02:36 <copumpkin> not that it's all that hard
09:02:46 <copumpkin> it's just unlike most things that most people have experience with
09:02:48 <Canar> eh, I've got my first project running now. I want to wade in a bit deeper.
09:02:49 <Botje> Canar: I learned from the Gentle introduction to Haskell.
09:03:03 <watermind> copumpkin: hmm not sure if I follow...
09:03:17 <copumpkin> watermind: type families allow you to write your type-level function
09:03:18 <Botje> Canar: you might want to look at real world haskell or the later chapters of LYAH, then
09:03:29 <rwbarton> RWH is nice for "a bit deeper" if you browse for topics that interest you
09:03:40 <Canar> RWH it is.
09:04:29 <qwr> imho biggest problem with haskell tutorials I read was that they forget to tell "but most real code you'll write live directly or indirectly in IO"
09:04:46 <watermind> copumpkin: does it really? I mean, I get that type families let you define data dependent on the type parameters, but if I understand correctly, you can't write 'functions from types to types' with them
09:04:57 <copumpkin> watermind: that's exactly what you can do
09:05:06 <copumpkin> what I wrote above is your function
09:05:09 <watermind> copumpkin: oh really
09:05:14 <copumpkin> then you can make Exp :: T a -> T b -> T (Exp a b)
09:05:16 <copumpkin> and it'll do what you want
09:05:34 <watermind> I had no idea you could do that
09:05:36 <Canar> qwr: yeah, dealing with the IO monad was a bitch at first, but thanks to the help of certain people here, I've got it working
09:05:38 <copumpkin> but you probably want to decide what to do about Poly, Poly for a, b
09:05:51 <Canar> hence my desire for a tutorial. i want to understand the ingredients in the special sauce
09:06:51 <qwr> Canar: it's not even bitch, it's just you read the tutorial and try to write pure haskell like the one in tutorial, and it's not going to work...
09:07:31 <watermind> copumpkin: ohhh you used it with a type synonym!   I'd only seen  it with "data family ..."
09:07:37 <watermind> copumpkin: that is pretty cool
09:07:54 <copumpkin> watermind: yeah, data family will make new types, type family acts like a type synonyn on steroids
09:07:58 <Canar> qwr: well, I've got a nice "pure haskell" IO core now. it even writes to a file.
09:08:47 <qwr> Canar: until you accept, that you actually have state, and best way to deal with it isn't passing always through arguments, but using State monad or IO (and often code has most of it's logic dealing with outside world - IO, and then the attempt to avoid it is even more ridiculous...)
09:09:41 <Canar> qwr: I'm familiar with the concept of stateful vs. stateless programming. I adore Prolog, which has a bunch of semantic sugar for dealing with state transitions.
09:09:43 <watermind> copumpkin: the other cases could result in   T Undefined     for some   data Undefined :P
09:10:08 <copumpkin> watermind: what other cases? :P presumably valid values are only Poly and Mono, and you can even state that in recent GHCs
09:10:26 <watermind> copumpkin: you can? how?
09:10:40 <qwr> Canar: what the IO core does?
09:11:05 <copumpkin> DataKinds lets you automatically lift types to kinds. You define data Which = Poly | Mono, then data T :: Which -> * and go on your merry way like you did before
09:11:15 <copumpkin> but now the parameter to T must be either Poly or Mono
09:12:17 <watermind> copumpkin: right!
09:12:45 <watermind> copumpkin: do we have DataKinds on 7.4.x or only 7.6.x?
09:12:56 <copumpkin> can't remember. Try turning them on :)
09:13:07 <watermind> copumpkin: ok!
09:14:02 <watermind> copumpkin: looks like it works :) thanks!
09:14:03 <tac> all those type extensions make me dizzy (looking at johnw's code example)
09:14:16 <Philippa> qwr: it's amazing just how much you can do in pure code with a little know-how. I mean, I'm one of #haskell's more obvious advocates of controlled effectful programming? But unless you need IO-like effects, there's not a lot except the occasional temporary type system weakness to worry about
09:14:23 <Philippa> (anyone written a pure ST implementation yet?)
09:14:27 <tac> GHC isn't a real language. It's an indexed family of languages.
09:14:47 <Sonderblade> any way to make installing cabal packages containing c source less painful on windows?  like compiling with visual studio instead of trying to get mingw/cygwin to work?
09:15:28 <qwr> Philippa: yes, the ST (etc monads) are pure in reality, but they "don't look" like pure to the beginner
09:15:57 <qwr> Philippa: I had kind of mental conflict at start, where I had learnt some of that "Haskell" thing
09:15:59 <rwbarton> if I have "ghc-options: -Wall" in my .cabal file does that mean it will build with -O2 -Wall?
09:16:00 <copumpkin> Philippa: Saizan concocted an amazing ST-alike in Agda and proved that it did the right thing
09:16:04 <rwbarton> or -O -Wall I mean
09:16:17 <Philippa> copumpkin: cool. I meant in Haskell though :p
09:16:19 <qwr> Philippa: and writing everything in do-blocks didn't seem natural ;)
09:16:34 <Philippa> (but I really need to start playing with Agda sometime - I keep hitting the point of cba too soon installing it)
09:16:46 * nand` has agda installed
09:16:49 <rwbarton> alternatively is there an RTS option to find out what options an executable was built with?
09:16:50 <copumpkin> cabal install agda!
09:16:51 <copumpkin> bam!
09:16:58 <copumpkin> >_>
09:17:04 <qwr> Philippa: and attempts to write haskell-without-monads (being not to sure about monads) made a lot of unnecessary pain
09:17:12 <Philippa> qwr: Funny thing - use let instead of do and you have a highly natural, suspiciously low-level approach
09:17:15 <nand`> I just never got round to reading some sort of introduction
09:17:22 <nand`> also, the unicodesyntax is scary
09:17:40 <Philippa> we don't talk about that as much as we perhaps should, because we don't want to focus on it. But it doesn't help newbies, certainly
09:18:14 <qwr> Philippa: well, but the low-level approach isn't simpler to understand in the end
09:18:36 <Philippa> qwr: the resulting code isn't. Sure as hell gives you a better operational model though
09:18:58 <qwr> Philippa: yes, you _have to_ know what the do block does
09:19:11 <qwr> Philippa: but it's much better to write do block most of the time
09:19:36 <Philippa> y'know, again: I'm a strong advocate of controlled effectful programming? I still don't entirely agree
09:19:59 <qwr> Philippa: exactly because it hides the details not important to the problem solved by your code
09:20:05 <Philippa> thing is, when you learn how to do the low-level parts, you quickly gain more options than stuffing things in a monad
09:20:11 <nand`> hypothesis: any sufficiently complex code can be made simpler and shorter by adding lenses
09:20:24 <tromp__> :t pack
09:20:26 <lambdabot>     Not in scope: `pack'
09:20:26 <lambdabot>     Perhaps you meant one of these:
09:20:26 <lambdabot>       `BS.pack' (imported from Data.ByteString),
09:20:42 <tac> nand`: simpler metatheoretically? or simpler in practice?
09:20:50 <edwardk> the strong nand` hypothesis: any code can be made simpler and shorter by adding lenses
09:20:54 <tromp__> :t Data.Text.pack
09:20:55 <nand`> simpler to write, read and understand
09:20:56 <lambdabot> String -> Data.Text.Internal.Text
09:21:03 <qwr> Philippa: well there are often many options
09:21:07 <tac> nand`: do you have any good lens examples?
09:21:14 <tromp__> :t Data.Text.IO.puStrLn
09:21:15 <lambdabot> Not in scope: `Data.Text.IO.puStrLn'
09:21:22 <tromp__> :t Data.Text.IO.putStrLn
09:21:23 <qwr> Philippa: but when you want to get something quickly done, you need some obvious option
09:21:23 <lambdabot> Data.Text.Internal.Text -> IO ()
09:21:37 * Philippa is actually getting pretty fed up of having to accidentally the entire monad signature just to get a binding notation again
09:21:40 <nand`> most of my significantly large code that uses lenses is in the examples folder on the lenses github
09:21:48 <nand`> the rest is IRC one-liners
09:21:52 <nand`> or proofs-of-concept
09:22:59 <tac> nand`: what's the link to the github?
09:23:29 <Philippa> qwr: Being able to fall back on "I know how to write code-in-general" is a good one there, and one we really don't cover properly. It bites people with do notation as much as the Identity Monad^W^W^Wlet
09:24:07 <nand`> tac: https://github.com/ekmett/lens/tree/master/examples
09:24:11 <tac> ty nand`
09:25:44 <nand`> I think adding lenses to diagrams would actually make it /more/ complex
09:26:23 <tac> diagrams?
09:26:44 <nand`> http://projects.haskell.org/diagrams/
09:27:07 <rwbarton> adding lenses to a raytracer would make it more complex
09:27:16 <nand`> rwbarton: :(
09:27:17 <nand`> :)*
09:27:44 <Philippa> adding things-that-I-didn't-bother-making-instances-for to my constraint stuff has helped a little, FWIW
09:27:57 <Philippa> don't know if I'm hitting a point where having lib functions as well'd be useful
09:28:19 <eacameron> fmap: what's the type sig  for your generalized .: ?
09:29:55 <peopleHands> Is there any reason why I keep seeing "io = liftIO" in code?
09:30:02 <atriq> Well, this code compiles, which is a good sign
09:30:22 <aristid> peopleHands: yes, it is shorter than liftIO
09:30:43 <eacameron> > :t fmap fmap fmap
09:30:45 <lambdabot>   <hint>:1:1: parse error on input `:'
09:31:21 <peopleHands> aristid: haha, is this seriously the reason? Haskell really is lazy.
09:31:49 <atriq> :t fmap fmap fmap
09:31:51 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
09:32:04 <atriq> :t (.:)
09:32:06 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
09:32:10 <aristid> peopleHands: not everybody does it
09:32:17 <aristid> peopleHands: but some people are lazy, yes.
09:32:40 <atriq> :t let (.) = fmap; (.) :: (b -> c) -> (a -> b) -> a -> c in (.) . (.)
09:32:42 <lambdabot> (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:33:04 <watermind> copumpkin: quite neat http://hpaste.org/77924   :)
09:34:02 <eacameron> atriq: thanks
09:34:07 <tac> It would be neat if IO a's were instead all defined as MonadIO m => m a's
09:34:11 <tac> So you wouldn't have to lift
09:35:28 <nand`> but that would mean pulling the mtl into prelude
09:35:52 <johnw> tac: you can always write a set of functions for yourself just like that
09:37:27 <rwbarton> it also doesn't help once you want to use forkIO, exceptions, etc.
09:48:46 <watermind> still don't fully understand kind promotion...   so in   data T = A | B     T is promoted to a kind  T :: Box    and A and B to types   A :: T  ,  B :: T
09:49:04 <watermind> so shouldn't I be able to write a function    f :: A -> Int ; f A = 0
09:49:05 <watermind> ?
09:49:08 <nand`> watermind: correct
09:49:15 <nand`> functions aren't promoted
09:49:20 <nand`> oh
09:49:21 <mauke> that looks wrong
09:49:26 <nand`> wait
09:49:29 <nand`> I see waht you mean
09:49:32 <nand`> no, you can't
09:49:36 <watermind> :(
09:49:37 <mauke> A :: T, not :: A
09:49:40 <Polarina> tac, something that lifts for us automatically would be neat. :)
09:49:44 <edwardk> watermind: the function you wrote is working on the unlifed values.
09:49:46 <nand`> watermind: kind mismatch
09:49:49 <nand`> watermind: (->) :: * -> * -> *
09:49:50 <edwardk> er unlifted
09:49:53 <nand`> A :: T
09:49:57 <watermind> ah!
09:50:01 <nand`> so (->) A is a kind error
09:50:05 <watermind> got it thanks guys
09:50:29 <watermind> I know there's also kind polymorphism... couldn't (->) be made polymorphic?
09:51:00 <edwardk> f :: T -> Int   -- A doesn't inhabit A, it inhabits type T. as a type A is a type that  inhabits kind T. but you can't use A ->. because (->) :: * -> * -> *  and A :: T.
09:51:13 <watermind> edwardk: yes I understand now
09:51:27 <edwardk> (->) is a little polymorphic but it doesn't work for arbitrary kinds just * and #
09:51:32 <rwbarton> @type (.~?)
09:51:34 <lambdabot>     Not in scope: `.~?'
09:51:35 <lambdabot>     Perhaps you meant `.~' (imported from Control.Lens)
09:51:42 * tac is waiting for polymorphism polymorphism. The type extension that allows datatypes to be polymorphic in how polymorphic they are
09:51:47 <edwardk> @type (?~)
09:51:49 <lambdabot> Setting s t a (Maybe b) -> b -> s -> t
09:51:59 <watermind> right
09:52:02 <rwbarton> i think i want something slightly different
09:52:02 <latermuse> metapolymorphism
09:52:21 <rwbarton> Setting s s a a -> Maybe a -> s -> s
09:52:29 <watermind> is there any fundamental reason why it wouldn't work with promoted kinds such as that one?
09:52:35 <edwardk> what would that do if it set Nothing?
09:52:37 <rwbarton> trivial to write, just wondering if it exists
09:52:37 <rwbarton> id
09:52:41 <watermind> or is that uncharted territory?
09:52:54 <rwbarton> it's like "update the value with this possible piece of new information"
09:52:55 <edwardk> yeah just use %~ fromMaybe ..
09:53:04 <rwbarton> @type (%~)
09:53:06 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
09:53:09 <rwbarton> oh
09:53:49 <rwbarton> like fromMaybe id const maybeNewVal?
09:54:05 <rwbarton> hm wait
09:54:08 <edwardk> :t fromMaybe
09:54:09 <lambdabot> a -> Maybe a -> a
09:54:15 <edwardk> not maybe ;)
09:54:16 <edwardk> :t maybe
09:54:17 <lambdabot> b -> (a -> b) -> Maybe a -> b
09:54:24 <rwbarton> okay right
09:54:41 <rwbarton> :t ?l %~ fromMaybe ?v
09:54:43 <lambdabot> (?l::Setting s t (Maybe b) b, ?v::b) => s -> t
09:55:22 <rwbarton> I don't quite get it though, it's not the old value that's a Maybe, it's the new one
09:55:25 <rwbarton> am I misunderstanding something
09:55:32 <rwbarton> :t ?l %~ maybe id const ?v
09:55:33 <lambdabot> (?l::Setting s t b b, ?v::Maybe b) => s -> t
09:55:37 <rwbarton> that's the one
09:55:56 <rwbarton> :t maybe id const
09:55:58 <lambdabot> Maybe a -> a -> a
09:56:08 <rwbarton> aha
09:56:11 <rwbarton> :t ?l %~ flip fromMaybe ?v
09:56:13 <lambdabot> (?l::Setting s t b b, ?v::Maybe b) => s -> t
09:56:27 <rwbarton> > (1,2) % _2 %~ flip fromMaybe (Just 3)
09:56:30 <lambdabot>   (1,3)
09:56:33 <rwbarton> > (1,2) % _2 %~ flip fromMaybe Nothing
09:56:35 <lambdabot>   (1,2)
09:56:37 <rwbarton> perfect
09:57:15 <nand`> > over _2 (`fromMaybe` Just 3) (1,2)
09:57:17 <lambdabot>   (1,3)
09:57:54 <edwardk> > over both (`fromMaybe` Just 3) (1,2)
09:57:56 <lambdabot>   (3,3)
10:15:34 <Polarina> Is there a function like { :: a -> Bool -> Maybe a } that returns { Just a } when the Bool is True, Nothing otherwise?
10:16:21 * hackagebot pontarius-xmpp 0.1.0.1 - An incomplete implementation of RFC 6120 (XMPP: Core)  http://hackage.haskell.org/package/pontarius-xmpp-0.1.0.1 (JonKristensen)
10:16:23 * hackagebot diagrams-tikz 0.1.1.0 - TikZ backend for diagrams drawing EDSL  http://hackage.haskell.org/package/diagrams-tikz-0.1.1.0 (AriePeterson)
10:17:47 <tac> Polarina: I think you can use guard to express it pretty tersely
10:18:37 <Polarina> tac, that'll work just nicely. Thanks. :)
10:19:33 <takemitsu> Maybe this is just a matter of taste but should I rather use liftM or fmap?
10:20:38 <nand`> liftM if you're polymorphic in some Monad constraint; fmap or <$> otherwise
10:21:16 <mindbender1> YoFO: http://www.infoq.com/presentations/Simple-Made-Easy
10:22:20 <edwardk> :t ?a <$ guard ?b
10:22:21 <lambdabot> (?a::a, ?b::Bool, Functor f, MonadPlus f) => f a
10:22:52 <edwardk> takemitsu: use fmap unless you are forced to use liftM by only knowing that you have a Monad and not a Functor
10:23:13 <aristid> and <$> if you want it infix
10:23:20 <edwardk> liftM is a valid default definition for fmap, but it can be slower
10:23:56 <takemitsu> Alright, thanks.
10:36:22 * hackagebot regex-pcre-builtin 0.94.4.2.8.31 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pcre-builtin-0.94.4.2.8.31 (AudreyTang)
10:36:24 * hackagebot pontarius-xmpp 0.1.0.2 - An incomplete implementation of RFC 6120 (XMPP: Core)  http://hackage.haskell.org/package/pontarius-xmpp-0.1.0.2 (JonKristensen)
10:36:45 <latermuse> is there an easy way to fix this type error? Couldn't match expected type `(IO [Char], FilePath)' with actual type `IO ([Char], [Char])'
10:37:05 <latermuse> just getting the IO outside of the tuple to go into the tuple
10:37:29 <rwbarton> no
10:37:53 <rwbarton> that would mean getting a FilePath out of an IO action
10:38:57 <ew0> is there a less ugly way to rewrite this: f z a b = let c = mustMayInsnUpdate a b in accountFunctionCall z c
10:39:01 <latermuse> if i make the filpath into an action, would it work?
10:41:22 <latro`a> latermuse: really depends on what you're doing
10:41:30 <latro`a> but in general that's not trivial to fix
10:41:43 <latermuse> alright. thanks :)
10:44:20 <Botje> @pl f z a b = funcall z (mustupdate a b)
10:44:21 <lambdabot> f = (. mustupdate) . (.) . funcall
10:48:29 <mountained> I'm new to haskell and have this code snippet: http://nopaste.me/paste/11331271450aa7e4b88e1e . Since the code of my instances is similar i wonder if i can get rid of the duplicates, or if this is a common issue?
10:48:54 <ew0> dafux, that's even more cryptic
10:49:23 <ew0> first lesson of haskell, use hpaste
10:49:24 <ew0> xD
10:50:57 <hpaste> mountained pasted ‚ÄúInstances Problem‚Äù at http://hpaste.org/77929
10:51:04 <sm> hi all. I can't figure out the reason for this cabal failure - any insight ?  https://gist.github.com/4112812
10:51:41 <sm> yesod 1.1.3 is the one I expect to work, I've been building with it on another machine
10:51:41 <nand`> mountained: most immediate way I would see is to provide an instance for [FTupel], make the two data's newtypes instead, and use GeneralizedNewtypeDeriving
10:51:46 <nand`> (would require FlexibleInstances as well)
10:51:51 <watermind> ok so, I understand that given  T = A | B    and kind promotion, we still cannot write   f :: A -> B, because  (->) :: * -> * -> *  ,   but why can't we define    x :: A ; x = A     - the error message is "kind mis-match Expected kind `ArgKind', but `A' has kind `T"
10:52:06 <watermind> what is this ArgKind?
10:52:30 <nand`> values can only have types of kind *, mind
10:52:35 <nand`> even so, A :: T
10:52:40 <nand`> not A :: A
10:53:02 <nand`> the sooner you treat the promoted version as completely separate from the nonpromoted version, the better
10:54:10 <watermind> right... my next question was going to be how to coerce between   A :: A  and A :: T
11:00:37 <ciaranm> does anyone have a handy reference of all the usual monads defined the join way rather than the bind way?
11:01:22 <watermind> can we declare new kinds explicitely?
11:02:35 <watermind> e.g.  kind  T :: BOX
11:05:52 <atriq> watermind, that would require some sort of metakind
11:06:14 <watermind> atriq: I've seen BOX in the GHC documentation, for the meta *
11:06:37 <tac> atriq: metakinds? unthinkable :)
11:07:04 <nand`> data T -- will be promoted to kind T :: BOX
11:07:13 <nand`> but with no inhabitants
11:07:15 <nand`> not very useful
11:09:57 <lispy> Types with no inhabitants are useful (in general, I don't know what context you're working with)
11:10:36 <watermind> lispy: yes but this would be kinds with no inhabitants...
11:11:02 <nand`> kind-level metaprogramming
11:11:05 <nand`> DataSorts
11:11:06 <lispy> I see
11:11:29 <lispy> I've never really thought about kinds without inhabitants. Not sure if they have a use.
11:11:47 <watermind> me neither... was just trying to give it some thought
11:12:38 <lispy> ciaranm: I've never seen something like that, but it seems derivable
11:12:47 <johnw> what does the GHC warning "Too strict if" mean?
11:13:00 <lispy> ciaranm: what are the primitives if you do it that way? join and whatelse?
11:13:07 <ciaranm> lispy: pure, fmap and join
11:13:17 <lispy> johnw: I've never seen that one. hpaste?
11:13:26 <ciaranm> i think i saw a scanned in hand drawn picture of it somewhere
11:13:34 <johnw> the example is kind of large, and I'm not sure which part is causing the problem
11:13:40 <lispy> ciaranm: ah, so take applicative functors and add join?
11:14:00 <ciaranm> lispy: and remove <*>, although that's irrelevant in Hask
11:14:20 <lispy> :t (<*>)
11:14:22 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
11:14:45 * lispy wonders if applicative could be pure/<$> instead of pure/<*>
11:14:49 <watermind> by the way, another way to restrict type constructors would be, rather specifying a kind for its arguments, restrict the type variables to be members of a class.  It would therefore be useful to restrict people from creating instances for arbitrary types
11:14:54 <watermind> is there a way to do that?
11:14:54 <johnw> lispy: no
11:15:02 <ciaranm> lispy: it couldn't
11:15:05 <ciaranm> lispy: <$> is fmap
11:15:23 <ciaranm> lispy: pure/<$> is sometimes called "Pointed", which is weaker than Applicative
11:15:26 <watermind> i.e. specify that a class only has instances for a certain specific types and no more
11:16:23 * hackagebot libstackexchange 0.2.1.0 - StackExchange API interface  http://hackage.haskell.org/package/libstackexchange-0.2.1.0 (MatveyAksenov)
11:16:25 <watermind> or for instance, by specifying that other modules cannot define new instances
11:17:12 <S11001001> watermind: yes but it is widely discouraged in favor of putting those constraints on the operations instead
11:17:36 <watermind> S11001001: well these classes would have no operations
11:18:29 <S11001001> watermind: unfortunately when you change Map k v to Ord k => Map k v, map length becomes length :: Ord k => Map k v -> Int.
11:18:32 <watermind> S11001001: I'm thinking of classes that are just used to restrict the admissible type variables in some data declaration
11:20:25 <clahey> watermind: Why would you want that?
11:22:35 <watermind> clahey: for instance, when using phantom types it is nice to restric the type argument to the specific "tags" you want to use
11:24:29 <watermind> clahey: see this example, it uses kind promotion http://hpaste.org/77924
11:24:45 <lispy> ciaranm: given x :: m a, and f :: a -> m b, where m is a monad, then what is join (f <$> x)?
11:25:07 <watermind> clahey: the arguments of T are restricted to the (promoted) types Poly and Mono
11:25:27 <lispy> ciaranm: I think that's (>>=)
11:25:33 <lispy> ciaranm: but I'm not very confident yet
11:25:39 <ciaranm> lispy: right
11:25:55 <ciaranm> lispy: draw pictures!
11:26:06 <lispy> ciaranm: I derived it from the types :)
11:26:19 <lispy> :t join . fmap
11:26:21 <lambdabot>     Occurs check: cannot construct the infinite type: f0 = (->) (f0 a0)
11:26:21 <lambdabot>     Expected type: (a0 -> a1) -> f0 a0 -> f0 a0 -> a1
11:26:22 <lambdabot>       Actual type: (a0 -> a1) -> f0 a0 -> f0 a1
11:26:34 <johnw> lispy: particularly, what is "fmap f" doing in that definition of >>=
11:26:35 <lispy> :t \x f -> join (f <$> x)
11:26:37 <lambdabot> (Monad m, Functor m) => m a1 -> (a1 -> m a) -> m a
11:26:45 <neutrino> hey guys
11:26:48 <johnw> i.e., why is it needed.  If you answer that, you should see why join is needed
11:26:51 <neutrino> has anyone here used Strafunsky?
11:27:02 <neutrino> it's a grammar manipulation library for haskell
11:27:25 <lispy> johnw: And I suppose I used that in my derivation.
11:27:25 <johnw> it library is manipulation Haskell for a?
11:27:39 <watermind> nand`: it seems to me like everything would be much more clear if we could explicetly define new kinds and its inhabitants rather than having to rely on kind promotion
11:28:18 <hpaste> wm pasted ‚Äútypes‚Äù at http://hpaste.org/77930
11:29:22 <watermind> for instance in that example Poly and Mono are just used as types
11:29:39 <watermind> what I really want there is   kind System = Poly | Mono
11:30:34 <johnw> lispy: the essence of a Monad is two things, and you used them both in that definition (in CT, it's the pair of natural transformations I ‚Üí T and T¬≤ ‚Üí T).  You should be able to work out how those transformations are coming into play in your >>=
11:31:09 <lispy> johnw: I?
11:31:13 <watermind> the fact that it is declarated as a data declaration just seems to make everything more confusing
11:31:23 <johnw> I is the identity functor
11:31:28 <lispy> ah, okay
11:31:45 <johnw> i.e., a ‚Üí m a and m (m a) ‚Üí m a
11:32:14 * lispy has a book an category theory but has not been studious
11:32:28 <lispy> I think I made the mistake of getting a book that was too introductory
11:32:43 <johnw> which book did you get?
11:32:43 <lispy> Having several chapters of really slow moving set theory drives me nuts
11:32:52 <lispy> Conceptual Mathematics
11:32:53 <startling> lispy: hahaha
11:33:03 <startling> lispy: the plague of the first three set theory chapters
11:33:23 <johnw> you want Awodey then
11:33:31 * tac got Awodey last week
11:33:37 <tac> It's pretty readable.
11:33:51 <startling> what's this book?
11:34:04 <tac> It's just called Category Theory or some dumb thing :P
11:34:14 <tac> http://www.amazon.com/Category-Theory-Oxford-Logic-Guides/dp/0199237182
11:34:17 <tac> ^ Awodey
11:34:18 <johnw> yep
11:34:19 <startling> tac: thanks
11:34:32 <tac> I'm going through and doing all of the quesitons in the book, I've decided
11:34:42 <tac> I'm on question 6, so far :P
11:36:00 <watermind> hmm data declarations are also restricted to things with returned kind  *
11:36:22 <watermind> so we can't even make   data Extra :: SomeKind
11:37:22 <ew0> yay, I sarted ~2 months ago writing my first real project in haskell
11:37:32 <ew0> gone from 12 minuntes runtime to 2-3 secs
11:37:33 <ew0> =D
11:37:39 <watermind> ew0: real as in...?
11:37:48 <Botje> ew0: woo!
11:37:52 <ew0> as in useful for my phd
11:37:53 <ew0> xD
11:37:59 <watermind> right, cool :)
11:38:11 <ew0> xD
11:38:25 <ew0> the python version was taking 4 days
11:38:37 <ew0> rewriting everything in haskell made me find some algorithmic changes
11:39:03 <johnw> you went from 4 days to 2 seconds?
11:39:08 <ew0> yeah
11:39:11 <johnw> good job!
11:39:15 <johnw> or, bad job, depending :)
11:39:16 <ew0> not the same algorithm, though
11:39:38 <johnw> yeah, i've done that before too
11:39:42 <ew0> I went to exponential complexity to n^4
11:39:48 <johnw> sometimes I solve things using sets that can be solved really quickly using arithmetic intsead
11:40:09 <ew0> yeah
11:40:16 <johnw> i blame my set theory book for making me see the world in sets for the time being
11:40:35 <ew0> auhuhua
11:40:40 <ew0> last month I learned about monads
11:40:50 <ew0> and I wrote a monadic version of this algo, it was taking 2 mins to run
11:41:20 <ew0> now I tossed everything out and wrote it purely funcional and surprisingly the time went down
11:41:20 <burbul> Is the following true: "It is legitimate for a class declaration to have 'type' declarations within it, as well as defining functions." ?
11:41:26 <hiptobecubic> ew0, what was the algorithm doing?
11:41:41 <johnw> burbul: if you enable type families, yes
11:41:54 <atriq> burbul, "Not is Haskell 2010, but yes with a GHC extension"
11:42:01 <ew0> worst case execution time analysis of an elf
11:42:10 <burbul> Thank you.
11:42:29 <tac> johnw: sets are so loosely typed, though! :)
11:42:29 <ew0> just an upper bound estimate
11:42:36 <burbul> Actually, how 'bad' is it to use a GHC-specific extension?
11:42:58 <johnw> ew0: monads are purely functional too.  It's just that "executing" an IO action is not.
11:43:00 <nand`> depending on how portable you want it to be
11:43:01 <burbul> As in, is it considered bad practice , because it ties you to a particular compiler, or is GHC so standard that
11:43:05 <atriq> Depends on the extension
11:43:08 <nand`> most people use GHC, and most type trickery these days is done in GHC
11:43:13 <burbul> ok
11:43:14 <burbul> thanks
11:43:15 <nand`> so you wouldn't be alienating a lot of people
11:43:19 <hiptobecubic> burbul, as 'bad' as using gcc specific extensions i would think.
11:43:49 <nand`> implementations can measure themselves based on how many GHC-specific extensions to Haskell they implement :P
11:44:19 <ew0> johnw, yeah, I know, but it was my first time writing monadic code. I exagerated a bit
11:44:40 <ew0> johnw,  I was using state transformers inside state transformers
11:44:49 <johnw> heh
11:45:10 <nand`> burbul: but personally I think that if using something like associated type families would make your code simpler, more elegant or more powerful (in terms of abstraction) then I think it's worth pulling in the GHC-specific extension
11:45:37 <burbul> ok -- thanks
11:45:57 <burbul> It's a case where we want each instance of a particular class to be able to specify its own type of error messages.
11:46:24 <burbul> The alternative would involve adding more parameters to the class, and would probably be significantly nastier.
11:46:46 <Nisstyre> every time I've thought "an existentially quantified type would be useful here" I've ended up removing it and going back to the simpler way
11:47:07 <burbul> Nisstyre:  existentially quantified type  is the same as type family?
11:47:12 <Nisstyre> burbul: no
11:47:15 <Nisstyre> it's another extension
11:47:19 <burbul> ok, good!
11:47:40 <nand`> I agree, I don't think existentials are that useful
11:47:45 <nand`> at least not as useful as one would first think they are
11:48:03 <Nisstyre> nand`: yeah, that was my mistake
11:48:10 <tac> burbul: existential quantification is the dual to universal quantification. For all vs exists. For all makes functions. Exists makes pairs.
11:48:28 <nand`> I also don't like MPTCs (without FunDeps), and with FunDeps I prefer type families
11:48:32 <johnw> existentials can be nice for simple heterogenous lists
11:48:32 <shapr[> edwardk: your reddit comment about the friendliness and niceness of the #haskell channel is getting lots of attention :-)
11:48:44 <nand`> shapr[: link?
11:49:05 <shapr[> http://www.reddit.com/r/haskell/comments/13g0ul/putting_haskell_down/c73qbmu
11:49:30 <edwardk> shapr[: oh?
11:49:54 <nand`> ‚ÄúI watched Cale Gibbard and some of the other guys very patiently explain some pretty advanced concepts to a newcomer and I had no idea what he was talking about. ‚Äù <- this *is* edwardk, right? O.o
11:49:57 <shapr[> yah, its votes went from +4 to +27 in about 45 minutes, especially after hitting twitter
11:50:03 <edwardk> yep
11:50:06 <edwardk> thats me
11:50:13 <edwardk> at the time i didn't know what a monad was
11:50:16 <nand`> ah
11:50:49 <dgpratt> edwardk: if you had said 2009, I would have wondered if the newcomer might have been me :)
11:51:08 <edwardk> =)
11:51:31 <nand`> Coyoneda f?
11:52:20 <edwardk> nand`: if you look at the types in heinrich apfelmus's operational monad tutorial they are probably the closest
11:52:25 <startling> edwardk: a monad is kind of like a lens
11:52:38 <watermind> ah, we can actually extend the inhabitants of arbitrary kinds... using type families
11:53:02 <watermind> type family NewType :: ExistingKind
11:53:30 <dgpratt> actually, it's kind of depressing that edwardk got into Haskell in '06 -- my Haskell trajectory is much flatter than his :/
11:53:55 <edwardk> dgpratt: at the time i had nothing better to do than read papers 24 hours a day
11:54:21 <dgpratt> edwardk: that does make me feel better :) -- I have a job and five kids :)
11:55:47 <edwardk> i basically had 6 months where i was just doing a job i could do with both hands tied behind my back, taking classes at literally 1/10th the pace i'd been the previous semester and lecturing, so i had plenty of time to binge
11:56:20 <hpaste> johnw pasted ‚ÄúAdjunction2.hs‚Äù at http://hpaste.org/77931
11:56:43 <shapr`> I remember when edwardk came to ICFP 2006 just as I returned from Sweden
11:56:46 <nand`> edwardk: Coyoneda = Lan Identity ?
11:57:10 <watermind> shapr`: were you at Chalmers?
11:57:15 <edwardk> shapr`: =) that was pretty much the tail end of my front-loading of everything i could about haskell and substructural logic
11:57:16 <shapr`> I got asked whether edwardk was full of it, or whether he really understood the ICFP papers better than the authors.
11:57:35 <shapr`> watermind: No, I only visited for EuroHaskell 2003
11:57:57 <edwardk> he visited for eurohaskell 2003 and then never left =P
11:57:57 <sp3ctum> i'm using parsec to parse a list of comma-separated data. but then I have to parse stuff out of the parsed data chunks. would a good approach be to call e.g. parse chunkContents "streamName" foo
11:58:02 <shapr`> watermind: Which was the joke conference where we got actual paper submissions :-)
11:58:14 <edwardk> well, they eventually kicked him out of sweden unnecessarily
11:58:29 <sp3ctum> ..I'd like to keep parsing the comma-separated chunks separate from parsing their contents, if possible. seems clearer to me that way
11:58:37 <watermind> shapr`: ah didn't hear about that :P
11:58:47 <shapr`> watermind: I made it up
11:59:37 <shapr`> watermind: I was planning to attend EuroPython 2003, so I started joking here on #haskell about EuroHaskell 2003
11:59:45 <watermind> :D
12:00:01 <shapr`> I was going to go sit on Anders Carlsson's floor and drink a beer with him and talk about Haskell, that was going to be EuroHaskell 2003
12:00:24 <shapr`> and then bringert and some other chalmerites wanted to hang out and drink beer and talk about Haskell as well
12:01:01 <shapr`> and we talked about it enough on #haskell that someone found my email address and submitted a paper
12:01:07 <shapr`> so I had to find a venue!
12:02:02 <shapr`> Of course, things on #haskell have certainly gotten more awesome since edwardk showed up..
12:02:26 <ciaranm> bring back why!
12:02:39 <edwardk> yeah, but the 'be nice or else' tone that got me into it kind of suffered a blow when shapr got too busy to hang out and be the niceness enforcer ;)
12:02:58 <shapr`> edwardk: So you took over and started enforcing?
12:03:04 <johnw> i'm willing to enforce niceness too
12:03:07 <shapr`> yay!
12:03:16 <johnw> i used to #emacs, but then like shapr got too occupied for a while
12:03:28 <johnw> and then that channel got away from me; but if several of us do it here, we can keep that from happening
12:03:34 <shapr`> yah, totally!
12:03:37 <merijn> Awww....I want to drink beer and talk about haskell too...
12:03:46 <shapr`> merijn: organize a conference where you are!
12:03:49 <shapr`> It worked for me!
12:04:15 <merijn> AmsterdamHaskellConf 2013 is a go? :>
12:04:18 <johnw> anyone want to do a Chicago Haskell meetup?
12:04:19 <nand`> I think shachaf would make a good niceness enforcer
12:04:20 <shapr`> merijn: srsly, do it!
12:04:36 <shapr`> johnw: invite people!
12:04:49 <startling> amsterdamnmonomorphismrestriction
12:04:54 <johnw> when people claim laziness shouldn't be the default, it makes me wonder how much they've really thought about the problem
12:05:01 <ciaranm> hrm. if it has Conf in the name, does that mean i can claim travel expenses?
12:05:12 * nand` can't write non-lazy code anymore, it seems
12:05:13 <merijn> ciaranm: Depends on your boss, I guess? :p
12:05:17 <ciaranm> clearly laziness and on-laziness should be functorial
12:05:32 <nand`> I always start lazy, then realize the strictness is causing it to loop, and then I start refactoring in ugly ways to get the laziness out
12:05:35 <johnw> i'll pay the cost of manual strictness analysis any day over the bending-over-backward that strictness-everywhere costs me
12:05:41 <shapr`> johnw: Strict by default certainly has some good points, have you seen Robert Ennals thesis?
12:06:11 <johnw> i think 'strict by default' is another way of just deprecating laziness
12:06:41 <startling> we could compromise
12:06:43 <nand`> (Are there no Haskell meetups in Germany?)
12:06:44 <simpson> johnw: You can always create one in the other.
12:06:51 <startling> the compiler could randomly pick between "lazy" and "strict"
12:06:56 <shapr`> nand`: organize one? (I think I've heard of some already)
12:06:57 <johnw> I think lazy by default has a lower code cost with a higher development cost, while strict by default just trades it the other way
12:07:04 <merijn> nand`: You could always come to Amsterdam if your close-ish to the border :p
12:07:12 <nand`> shapr`: I don't trust my organizational skills; merijn: near the south
12:07:21 <watermind> documentation says DataTypeContexts is on by default, but I just had to add it explicitely
12:07:25 <merijn> nand`: Our group seems to have too many Germans already anyway >.>
12:07:30 <johnw> i.e., neither is easier than the other, they are just different kinds of hard
12:07:30 <watermind> does any of the other extentions turns it off?
12:07:36 <nand`> well, I do trust my organizational skills, but only when it comes to electronic mediums
12:07:36 <watermind> or is the documentation outdated?
12:07:47 <johnw> like edwardk, I am enchanted by laziness
12:07:47 <shapr`> nand`: I certainly don't have organization skills, I just ask people to show up at a nearby coffee shop at a particular time.
12:08:04 <nand`> shapr`: no program?
12:08:19 <merijn> nand`: "beer" sounds like a program to me...
12:08:21 <watermind> hmm seems outdated
12:08:24 * geekosaur thinks about some uses of 'enchanted', wonders if there needs to be a handsome prince on standby
12:08:40 <shapr`> nand`: No, I ask people to bring code they want to talk about, even better if they wrote it themselves, and I bring code I think is nifty
12:08:49 <nand`> merijn: what about the non-alcoholics? :(
12:09:25 <johnw> shapr: "Adaptive Evaluation of Non-Strict Programs"?
12:09:34 <merijn> nand`: I thought you were German? :p
12:09:49 <shapr`> johnw: that sounds like the right document
12:09:56 <johnw> ok, i'll read it
12:10:13 <saml> how can I create a haskell ide?
12:10:22 <nand`> merijn: in my defense, I only spent about half my childhood here
12:10:22 <shapr`> saml: gtk?
12:10:29 <saml> thanks
12:10:36 <shapr`> saml: Hey, didn't you hang out here about six years ago?
12:10:37 <johnw> but i have to say that laziness by default is one of my favorite features about Haskell; it was be quite saddening if it moved toward strictness
12:10:40 <saml> i was thinking server and browser
12:10:43 <beaky> hello
12:10:48 <ciaranm> goodbye
12:10:48 <clahey> saml: Another possible option might be eclipse.
12:10:52 <beaky> bye?
12:10:53 <saml> i hang out on channels with many girls
12:10:54 <shapr`> saml: oh, in that case you could start with ghcLiVE maybe?
12:11:11 <nand`> saml: s/gtk/vty/
12:11:12 <saml> shapr, thanks let me check that out
12:11:20 <nand`> shapr`: *
12:11:26 <johnw> they guy https://www.b7j0c.org/blog/putting_haskell_down.html sounds like he just needs to understand strictness analysis better, rather than change the language to dumb it down
12:11:27 <shapr`> howdy beaky
12:11:44 <beaky> Every programming language has a feature that makes it stand out from others; C has pointers, Java has classes, Lisp has macros. What does Haskell have over all those?
12:11:47 <saml> what do you need in haskell ide?  let's forget about cabal integration for now
12:11:54 <saml> unicode  characters for -> and stuff, right?
12:12:02 <johnw> beaky: maybe monads
12:12:03 <saml> and hoogle integration, code search and complete
12:12:05 <nand`> Haskell has curry
12:12:08 <startling> beaky, huh? none of those are features that make those stand out
12:12:12 <Botje> beaky: a nice type system and an even nicer community.
12:12:16 <mauke> beaky: Perl's references are similar to C's pointers. Pascal/Delphi also have pointers
12:12:17 <beaky> ah
12:12:27 <nand`> many languages have pointers, many languages have classes
12:12:30 <mauke> beaky: C++, Perl, Python, Ruby, Lisp, OCaml, ... all have classes
12:12:31 <ciaranm> beaky: still asking bad homework questions?
12:12:34 <johnw> it's not that they uniquely have them, it's more than they are kind of famous for them
12:12:35 <dcoutts> saml: I think it's hard to get away from doing the build system well, and so that pretty much means cabal/package stuff.
12:12:38 <nand`> many languages have macros, C and Haskell included
12:12:43 <mauke> beaky: Haskell has macros called Template Haskell
12:12:43 <simpson> beaky: I find that what's more important than a single feature is the kind of library that all of the language's features contribute towards.
12:12:49 <mauke> beaky: oh, Haskell also has pointers
12:12:50 <beaky> right
12:12:54 <simpson> beaky: For example, why is there no Twisted-like library for Haskell?
12:13:17 <nand`> beaky: it should be obvious: Haskell has lenses!
12:13:21 <beaky> haskell is powerful enough to not need that?
12:13:26 <beaky> what are lenses
12:13:28 <ciaranm> haskell has category theory
12:13:43 <ciaranm> beaky: lenses are just natural transformations between state monads
12:13:48 <saml> Haskell has do syntax for monads
12:13:49 * merijn just found out Amsterdam already has a functional programming group that meets
12:13:53 <beaky> haskell doesn't hase classes though :(
12:13:54 <clahey> saml: hoogle integration code search and complete.  Unicode character for ‚Üí doesn't stand out.
12:13:57 <nand`> haskell has classes
12:13:59 <mauke> Haskell has types, laziness, purity
12:14:02 <johnw> ciaranm: don't you mean between store comonads? :)
12:14:15 <ciaranm> johnw: no!
12:14:23 <geekosaur> simpson, last I checked there is nothing just like twisted because twisted thinks like python.  there are a number of such frameworks that are not like twisted because they are haskell, not python in haskell
12:14:28 <Philippa> if I had to pick a defining feature for Haskell but not relatives of similar age, it'd be type classes
12:14:32 <merijn> hah, they claim to be commercial FP users too
12:14:33 <johnw> "Lenses are the coalgebras for the costate comonad"
12:14:57 <saml> haskell has microsoft
12:14:59 <saml> funding
12:15:09 <saml> java doesn't ahve that
12:15:11 <simpson> geekosaur: Okay, so why does that pattern work well in Ruby (EventMachine), JS (Node (ugh)), and so forth? It's not a bad pattern.
12:15:17 <ciaranm> java has a marketing department
12:15:32 <beaky> arent typeclasses less powerful than Java interfaces? or so i've heard
12:15:36 <ciaranm> no
12:15:49 <simpson> geekosaur: I'd say that it's because mutability of objects is integral to the pattern.
12:15:51 <ciaranm> also that question doesn't even make sense
12:15:53 <nand`> write a java interface for monads :)
12:15:53 <mauke> did you mean: more powerful
12:15:57 <geekosaur> simpson, it;s actually a pretty lousy pattern.  it's easy to write for, which I suppose if that;s all you care about makes it "good' in the sam eway that php is the best web language
12:16:04 <saml> beaky, they are different things like black and white
12:16:07 <beaky> ah
12:16:12 <beaky> what is the difference?
12:16:21 <saml> java nad haskell are pretty different
12:16:23 <ciaranm> what's the difference between a duck and a banana?
12:16:38 <saml> they both let you write programs easily though
12:16:45 <beaky> right
12:16:55 <shapr`> ciaranm: be nice
12:16:57 <deus_rex> ciaranm: both are the product of Intelligent Design :P
12:17:00 <simpson> geekosaur: Please, enlighten me as to the correct way to write an event-driven program, because I have *not* found it in Haskell yet.
12:17:16 <Mert> Hai?
12:17:17 <Mert> xd
12:17:24 <beaky> hello
12:17:25 <shapr`> oh hai Mert, are you learning Haskell?
12:17:32 <geekosaur> simpson, FRP gets discussed around here fairly often
12:17:37 <Mert> Well, I don't know what it is.
12:17:37 <saml> is this twitter?
12:17:41 <nand`> ciaranm: the difference between polymorphism and catamorphism
12:17:56 <Mert> I've learned Java though
12:17:59 <saml> this channel updates as fast as twitter #hotkeyword
12:18:00 * ciaranm applauds nand` 
12:18:00 <Mert> So I am wondering
12:18:07 <Mert> what the difference is.
12:18:12 <beaky> so monads are just as powerful as lisp macros?
12:18:19 <simpson> geekosaur: Yeah, none of the FRP solutions are suitable for dealing with network traffic. Also nobody in the Haskell world has unified protocols over sockets, files, subprocesses, etc. yet.
12:18:22 <ciaranm> beaky: they have nothing to do with each other
12:18:24 <simpson> geekosaur: Well, conduits have.
12:18:24 <nand`> both are turing complete, I guess?
12:18:32 <simpson> geekosaur: But conduits aren't good for dealing with timed events!
12:19:00 <shapr`> simpson: make up a unified protocol?
12:19:08 <Mert> Is Haskell supported on all platforms?
12:19:19 <shapr`> Mert: It doesn't work well on the Arduino
12:19:23 <saml> Mert, give me a list of all platforms
12:19:34 <Mert> Well popular platforms like
12:19:41 <Mert> Windows, linux and mac?
12:19:42 <saml> Haskell Platform is released for windows, mac, linux
12:19:42 <shapr`> Mert: But Haskell does work on Windows, Linux and Mac OS X
12:19:46 <nand`> Mert: I don't think Haskell is supported on a non-turing complete platform
12:19:47 <simpson> shapr`: I've been tempted to go for it. It just seems like I'm not qualified to write a new networking library.
12:19:57 <saml> mert, http://www.haskell.org/platform/
12:19:59 <Mert> I see
12:20:04 <shapr`> simpson: So? At least you can find out things that will not work and help inform a better design?
12:20:10 <Mert> Thanks, you guys are so useful
12:20:10 <Mert> xd
12:20:11 <nand`> Mert: the popular implementation of Haskell is GHC, which has Windows, Linux and Mac OS X as tier 1 platforms
12:20:23 <nand`> tier 1 meaning somebody pays them to make sure every feature of GHC always works on them
12:21:03 <Mert> So, does haskell run on a client computer without installing a runtime?
12:21:05 <sp3ctum> someone pays for that?
12:21:15 <simpson> shapr`: I guess. I just don't think I've got the chops.
12:21:27 <ciaranm> Mert: you're thinking in very windowsy terms
12:21:28 <shapr`> simpson: go get the chops by designing the interface?
12:21:46 <fryguybob> Mert: Yes you can static link.
12:21:49 <simpson> shapr`: Yeah, okay. I'll start hacking on it.
12:21:52 <sp3ctum> Mert, yes, the final compiled code requires no separate runtime
12:21:52 <Mert> Oh I see
12:21:53 <nand`> Mert: binaries compiled by GHC link against libraries that every user should probably already have; except perhaps libgmp
12:22:05 <nand`> Mert: of course, this depends on the implementation, platform, and building methodology
12:22:09 <Mert> That's really interesting.
12:22:20 <b_jonas> good evening. I have a question.
12:22:23 <nand`> GHC can also write dynamically linked code that would require all of that code's dependencies as separately built and installed libraries
12:22:30 <kane77> hi, are there any image processing libraries for haskell?
12:22:31 <shapr`> simpson: rock on :-) tell me how it goes!
12:22:39 <nand`> kane77: image processing of what form?
12:23:24 <kane77> well, something like imagemagick, various effects, transformations, etc.
12:23:27 <nand`> Mert: the trade off is, of course, larger binaries if you include all of the dependencies
12:23:32 <fryguybob> b_jonas: I have an answer.
12:23:41 <b_jonas> Is it possible to segfault the haskell runtime by defining inconsistent typeclass instances in different modules? If not, is it supposed to crash the runtime by defining inconsistent instances with the overlapping instances extension switch? Suppose that multi-parameter typeclasses, fundeps, and gadts are enabled in first place.
12:24:22 <b_jonas> Eg. maybe you can do something like have the runtime derive a false witness for two types being equal, and then access one type as if it was the other.
12:24:34 <nand`> kane77: there seem to be bindings for the GraphicsMagick (is that part of imagemagick?) library, but I know there are also some other image processing libraries ranging from cairo to juicypixels to DevIL
12:24:51 <nand`> and probably a few more that I don't know of
12:25:05 <kane77> nand`, I was thinking of implementing something in pure haskell
12:25:22 <quchen> Hello everyone! I've got a small question about idiomatic Haskell. How do I create a Maybe value out of a Bool and something? I wrote "if p then Just x else Nothing" so many times in code next to fromMaybe etc. Am I overlooking something? An inverse of fromMaybe/maybe?
12:25:29 <shapr`> b_jonas: I don't know, do you have code that does cause segfaults?
12:25:42 <shapr`> b_jonas: The guys on #ghc might be able to help if you have a code sample that causes segfaults
12:25:48 <nand`> kane77: JuicyPixels seems to be pure haskell, but it doesn't have processing (upscaling, etc.); it provides, among others, a repa interface, so you could probably write a library on top of that
12:25:50 <b_jonas> shapr`: no, I don't have such code
12:26:00 <nand`> or maybe wait for somebody more knowledgable about this than me to find an existing one
12:26:03 <b_jonas> shapr`: I'm just wondering what the safety guarantees are supposed to be.
12:26:18 <S11001001> quchen: guard p >> Just x
12:26:20 <kane77> nand`, yes, that would be very useful
12:26:56 <kane77> nand`, I believe that haskell would be very good language for such thing..
12:27:10 <quchen> S11001001: Ha! Monads again. Makes sense, thanks!
12:27:18 <nand`> kane77: I agree, I know there has been interesting work in the area of image processing in pure haskell, especially with comonads
12:27:21 <S11001001> quchen: applicative functors in this case :)
12:27:42 <quchen> S11001001: Well, that would be *> then. :-)
12:27:54 <Eduard_Munteanu> :t guard
12:27:55 <lambdabot> MonadPlus m => Bool -> m ()
12:28:16 <nand`> x <$ guard p
12:28:53 <S11001001> nand`: right :]
12:29:16 <`Jake`> mert
12:29:18 <`Jake`> oops
12:29:22 <`Jake`> wanted to ctrl-f
12:30:03 <Mert> Hmm?
12:30:10 <Mert> xd
12:34:13 <clahey> Does ghc use ssl at all?
12:34:50 <nand`> clahey: I'm not sure what you mean
12:34:57 <nand`> SSL for that?
12:34:58 <nand`> what*
12:35:14 <ciaranm> for when it sends your code to the great category theory god in the sky
12:36:02 <quchen> GHC doesn't send anything. It receives.
12:36:06 <clahey> Does ghc use sse at all?
12:36:23 <nus> no! satisfied?
12:36:28 <Iceland_jack> clahey: Why would it?
12:36:35 <ciaranm> why wouldn't it?
12:37:02 <ciaranm> SSE has delicious tasty functions for counting the number of set bits in an int
12:37:51 <beaky> are there any imperative programming languages with lazy evaluation or pattern matching or other haskell niceties?
12:38:07 <beaky> python has generators
12:38:10 <simpson> beaky: Sure! Python.
12:38:29 <simpson> Although full pattern matching in Python's syntax has proved, uh, difficult.
12:38:41 <beaky> heh
12:39:00 <beaky> pattern matching in python seems either using dicts or if-else trees,
12:39:14 <beaky> or something
12:39:37 <beaky> what about deconstructing objects tho
12:39:48 <simpson> Or one could make their own language that repurposes backticks, and then...
12:39:50 <ciaranm> scala has that
12:39:56 <simpson> Actually, no, I'm getting ahead of myself.
12:40:11 <simpson> beaky: Python's types aren't algebraic; you get to define for yourself what it means to match.
12:40:17 <beaky> ah
12:40:27 <nand`> quchen: that reminds me of http://www.yesodweb.com/blog/2012/04/replacing-cabal
12:40:33 <bgamari> ciaranm, I'm not sure if GHC uses the SSE bit count instructions, but there is a bit-count primop, so in principle it could
12:40:56 <singpolyma> Is there a way to make a FunPtr with a finalizer or something, so that I don't have to explicitly call freeHaskellFunPtr freeHaskellFunPtr?
12:40:57 <nus> clahey, if you actually care, take a look at the source (it does "use a restricted set of the available SSE2 instructions for floating-point.")
12:42:08 <clahey> Well, specifically, I was thinking about repa and hoping that it would do multiple instructions at once.
12:42:08 <beaky> :t liftM
12:42:10 <lambdabot> Monad m => (a1 -> r) -> m a1 -> m r
12:45:45 <beaky> is if-then-else a function?
12:45:58 <atriq> beaky, nyish
12:46:02 <singpolyma> beaky: I wish.  You can define an if' function that is
12:46:14 <singpolyma> there's a whole wiki page about that
12:46:21 <tac> beaky: no. It's syntax. But in Haskell, you can define an if function
12:46:22 <beaky> seems to be syntactic sugar for something
12:46:27 <atriq> It works like a stupid function you can't partially apply
12:46:32 <atriq> if :: Bool -> a -> a -> a
12:46:53 <donri> it's the ifThenElse function with RebindableSyntax
12:46:54 <nand`> with OverloadedSyntax, ifThanElse becomes a user-definable function
12:46:56 <nand`> oh
12:46:59 <nand`> that was the name
12:47:03 <nand`> and Then not Than :(
12:47:07 * nand` needs to sleep
12:47:55 <singpolyma> donri: has anyone found a good reason to rebind that syntax, though?  It seems like there's only one semantics you I'd want it to have
12:48:20 <nand`> singpolyma: it's obvious; so you can redefine data Bool = True | False | FileNotFound
12:48:32 <donri> :)
12:48:43 <beaky> :t \x y z -> case x of {True -> y; False -> z};
12:48:44 <donri> you could maybe implement python-like fuzzy booleans
12:48:44 <lambdabot> parse error on input `;'
12:48:48 <beaky> :t \x y z -> case x of {True -> y; False -> z}
12:48:49 <lambdabot> Bool -> t -> t -> t
12:48:53 <nand`> (I think it's more a manner of principle; as in, the extension allows rebinding as much as possible, because why not?)
12:48:55 <singpolyma> nand`: ooh, or    type Bool = (a -> a -> a)
12:49:19 <donri> but not sure it would affect guards
12:49:34 <singpolyma> donri: no?  I thought guards desugar to if-then-else ?
12:49:41 <donri> duno
12:49:50 <donri> try :)
12:49:54 <nand`> only one way to find out :)
12:50:01 <nand`> ..two ways, with what donri suggested
12:50:29 <beaky> I thought ghc efficiently compiled guards down to jump tables or something
12:50:46 <atriq> edwardk, how weird would it be for you if I said I view you as a sort of role model?
12:50:50 <Eduard_Munteanu> More like case statements in Core.
12:51:25 * hackagebot debian 3.69 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.69 (DavidFox)
12:51:25 <edwardk> how weird for you would it be for me to admit that i've had folks ask me that before? ;)
12:51:27 <nand`> I wonder how edwardk ranks on the haskell coder efficiency index, in modules per second
12:51:58 <b_jonas> I was wondering about this because of that safe haskell thing where the ghc developers are hoping that ghc can be coerced to compile untrusted haskell code to an executable you can run safely, under many caveats.
12:52:07 <b_jonas> That's why I'm asking about the inconsistent instances.
12:52:10 <edwardk> so overall, not terribly awkward =P
12:52:17 <rwbarton> edwardk can write haskell modules faster than ghc can compile them
12:52:28 <merijn> I aspired to be like edwardk when I get to his age, and then I realised he's only like a handful of years older when I saw his linkedin >.>
12:52:36 <tac> Is there an intuitive reason why type inference is decidable up to Rank 2?
12:52:47 <edwardk> merijn: =P
12:52:54 <donri> what's *your* kmett number? ( http://en.wikipedia.org/wiki/Erd%C5%91s_number )
12:52:59 <merijn> Afterwards I just felt bad and lazy >.>
12:53:31 <b_jonas> merijn: that's better than if you found out you were a little bit older
12:53:34 <merijn> I can still aspire to be like shapr`, the age difference there gives me some time to catch up :p
12:53:52 <edwardk> merijn: hahahaha
12:53:54 <ciaranm> i've got an erdos number of 4, and an SPJ number of 3 or maybe 2...
12:54:11 <singpolyma> seems to not affect guards :P
12:54:21 <merijn> My bachelor project supervisor had an Erdos number of 3, made me sad I didn't get a paper published with him...
12:54:45 <tromp__>  i can never improve my erdos number...
12:55:13 <startling> merijn, you want to be an elite haskell master like edwardk ?
12:55:15 <arbn> tromp__: There's still hope for your SPJ number.
12:55:18 <b_jonas> tromp__: not even like http://xkcd.com/599/ ?
12:55:22 <clahey> How about if then else redefined over Either Bool Bool ?
12:55:38 <clahey> Or even more useful, if then else redefined over (Bool, Bool).
12:55:53 <clahey> if (True, False) then a else b  ===  (a, b)
12:56:06 <tromp__> b_jonas :)
12:56:10 <pqmodn> tac, i'm not sure if it's intuitive but i think this is the proof http://dcommon.bu.edu/xmlui/bitstream/handle/2144/1475/1993-017-finite-rank.pdf?sequence=1
12:56:20 <beaky> what makes haskell so pleasant to progam in? it is so different from von-neumann languages like Java
12:56:28 <b_jonas> clahey: no, we're a typed language here, we don't randomly break inferability of programs
12:56:28 <ciaranm> hrm. could get an SPJ number of 2 fairly easily.
12:56:31 <atriq> I could possibly justify having a Kmett number of 1. Hmm
12:56:34 <atriq> Wow
12:56:42 <b_jonas> clahey: if you want that, define an if' then use (fmap if')
12:56:55 <edwardk> i think the kmett number should be based on packages coauthored
12:56:55 <clahey> b_jonas: That would be completely reasonable.
12:56:59 <startling> beaky, what makes you think haskell isn't a "von-neumann" language?
12:57:05 <acowley> edwardk: your "soul" post on /r/haskell was fantastic
12:57:18 <clahey> Is (a, a) a Functor a?
12:57:18 <atriq> edwardk, I contributed a tiny bit of documentation in semigroupoids
12:57:19 <nand`> clahey: I don't think RebindableSyntax can change the type of language feature functions, can it?
12:57:25 <edwardk> acowley: thanks =)
12:57:30 <beaky> it doesnt deal with th notion of cells and assignment and imperativeness
12:57:30 <b_jonas> clahey: um... no. sorry
12:57:36 <b_jonas> clahey: dunno then
12:57:40 <cornihilio> is there something like hslint when editing projects? it only seems to work for single files
12:57:41 <nand`> > (True, False) % both %~ if' a b
12:57:43 <lambdabot>   Not in scope: if'
12:57:43 <lambdabot>  Perhaps you meant f' (imported from Debug.SimpleReflect)
12:57:44 <beaky> it is much closer to the lambda calculus
12:57:52 <edwardk> dolio argues that it should be based on the handing off of package maintainership
12:57:55 <Botje> clahey: you can make it a functor if you promise not to change the left element.
12:57:57 <nand`> @let if' b a b = if b then a else b
12:57:58 <lambdabot>  <local>:6:5:
12:57:58 <lambdabot>      Conflicting definitions for `b'
12:57:58 <lambdabot>      Bound at: <local>:6:5...
12:57:59 <donri> nand`: i don't think syntax has types
12:57:59 <nand`> > (True, False) % both %~ if' a b
12:58:01 <lambdabot>   Not in scope: if'
12:58:02 <lambdabot>  Perhaps you meant f' (imported from Debug.SimpleReflect)
12:58:02 <mauke> :t f'
12:58:03 <lambdabot> FromExpr a => a
12:58:04 <edwardk> so i have a dolio number of one as he handed me category-extras.
12:58:07 <nand`> oops
12:58:17 <nand`> @let if' b x y = if b then x else y
12:58:20 <lambdabot>  Defined.
12:58:22 <edwardk> and roconnor has an edwardk-number of 1 because i gave him data-lens
12:58:24 <Botje> woops, nevermind.
12:58:27 <nand`> > (True, False) % both %~ if' a b
12:58:29 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
12:58:30 <lambdabot>              with actual type...
12:58:30 <Botje> i think it works if you change both
12:58:34 <edwardk> but that kind of limits transmission
12:58:35 <donri> nand`: RebindableSyntax would be quite useless if you were constrained by the old type...
12:58:48 <acowley> cornihilio: ghc-mod uses hlint pretty effectively
12:59:00 <atriq> edwardk, in that case, I could maybe, by being extremely sneaky, justify an edwardk number of 2
12:59:06 <atriq> But I'm not
12:59:30 <donri> cornihilio: you can hlint directories recursively
12:59:44 <nand`> :t bool
12:59:45 <lambdabot> Not in scope: `bool'
12:59:52 <clahey> Botje: Why can't it be a functor along the lines of ZipList?
12:59:53 <pqmodn> tac, if i remember (starting to remember now), the trouble is there's no way to decide which of many possible types are most general
13:00:11 <nand`> @let bool x y b = if' b x y
13:00:13 <lambdabot>  Defined.
13:00:27 <nand`> > (True, False) % both %~ bool a b -- there we go
13:00:27 <edwardk> alternately i'd say, as i am still alive. that you should invert the convention, and just use number of lines accepted to one of my packages in a patch. so shachaf has an edwardk number of 1753 or more, while, byorgey has only 1, etc.
13:00:29 <clahey> fmap f (a, b) = (f a, f b)?
13:00:29 <lambdabot>   (a,b)
13:00:31 <b_jonas> clahey: because it's functor in a conflicting way
13:00:43 <b_jonas> clahey: you have to wrap it in a newtype if you want it to be functor in any other way
13:00:56 <ciaranm> number of lines is a bad measure!
13:00:58 <clahey> b_jonas: Ah, that makes sense.
13:01:03 <edwardk> that makes them grow the opposite direction, but has the benefit that i get more patches ;)
13:01:06 <nand`> edwardk: do wiki patches and documentation count?
13:01:07 <clahey> Number of lines is a horrible measure.
13:01:15 <edwardk> ciaranm: the difference is if they are boilerplate nonsense lines i won't take them =P
13:01:18 <ciaranm> "number of words java programmers don't understand" is a better one
13:01:48 <edwardk> ciaranm: it also has the benefit that i can easily establish a lower bound by looking at https://github.com/ekmett/lens/graphs/contributors ;)
13:01:50 <djahandarie> Any patch to one of the categories-extra subpackages would certainly ramp that number up then.
13:01:50 <nand`> haskell program size should be measured in number of applications; perhaps
13:01:51 <nand`> or number of nodes in the program expressed as a haskell-src-exts tree
13:02:11 <eikke> fwiw, my NBD library now has client support as well ^_^
13:02:14 <ciaranm> number of fmaps!
13:03:15 <b_jonas> nand`: I don't think number of applications is enough
13:03:21 <b_jonas> maybe number of tokens?
13:03:26 <merijn> edwardk: So I should just talk you into accepting a commit of me reindenting all your code? :>
13:03:54 <edwardk> merijn: well, after putting that metric in place, i suppose, yes if you could convince me that was a good patch, then it'd count ;)
13:04:04 <edwardk> mind you getting me to change conventions like that is unlikely ;)
13:04:20 <ciaranm> i think we should abandon metrics, and just define a topology
13:04:39 <donri> do deletions count in the negative, such that if you refactor some horrible code edwardk wrote you get minus point for suggesting it could be done in less lines of code?
13:04:44 <startling> merijn: just do s/(\w+)Ãá\.(\w+)/\1 . \2
13:04:49 <edwardk> yes, we have a dan isomorphism between copumpkin and dolio
13:05:15 <clahey> Any open set of contributors including edwardk and person x also include person y?
13:05:23 <edwardk> donri: i was trying toc ome up with how i could count deletions as the good thing. e.g. contributuons that net delete lines are better than ones that add.
13:05:55 <edwardk> or even deletions - additions as the number, but that penalizes more active contributors like shachaf =P
13:05:56 <merijn> My lifetime contribution to my current codebase is -7k SLOC :>
13:05:57 <startling> edwardk, my add/delete ration is 0/1, do I win?
13:06:28 <atriq> Mines's 33/32
13:06:31 <ciaranm> startling: careful, you might not like the prize
13:06:33 <edwardk> the only person who would have a positive number under deletions - additions in lens right now would be nand`, but that doesn't count the fact that i accepted his initial modules
13:06:50 <edwardk> er examples
13:06:57 <beaky> what makes the lambd calculus model better than the von-neumann model of programs?
13:07:12 <ciaranm> beaky: your questions don't make sense
13:07:14 <rwbarton> beaky ugh
13:07:16 <rwbarton> stop it
13:07:16 <startling> edwardk, oh, this is lines?
13:07:30 <ciaranm> beaky: tell your professor to set better homework
13:07:35 <beaky> sorry
13:07:41 <tac> beaky: the Lambda calculus isn't stateful by default.
13:07:56 <ciaranm> there's no such thing as state!
13:08:10 <tac> ciaranm: not for someone like you
13:08:11 <beaky> theres the united states
13:08:27 <tromp__> lambda calculus programs are more easily composed
13:08:40 <ciaranm> lambda calculus is unusable
13:08:45 <startling> beaky, what's do haskell and us have in common?
13:08:51 <startling> s/'s//
13:09:05 <ciaranm> both are ruled by an evil dictator!
13:09:10 <nand`> edwardk: oh, examples count? I was wondering where those lines were going
13:09:24 <startling> ciaranm, separation of church and state!
13:09:39 <nand`> note to self: write more examples for kmett packages
13:09:40 <ciaranm> that was terrible.
13:09:53 <johnw> note to self: read more examples for kmett packages
13:09:55 <acowley> I'm really not sure how I feel about multiway if
13:10:05 <jacobian> Is there an emacs mode which integrates with scion?
13:10:06 <johnw> acowley: there's many options to choose from, at least
13:10:09 <edwardk> meh, i'll keep it simple and just go back to the 'lines of accepted patch additions + deletions' metric. =P
13:10:11 <ciaranm> if we allow multiway if, next we'll be having sex with snakes
13:10:15 <edwardk> that gets me more patches
13:10:15 <johnw> jacobian: I couldn't find a working one; let me know if you can
13:10:16 <acowley> johnw: there are too many options
13:10:26 <acowley> johnw: and I worry about adopting it given the need for yet another pragma
13:11:11 <acowley> doing case () with guards is ugly
13:11:16 <acowley> but not that much uglier than multiway if
13:12:10 <acowley> things were so much simpler when everything was cond
13:12:39 <kini> Is there a way to write "count p xs = length $ filter p xs" in a point-free way?
13:13:02 <edwardk> count p = length . filter p   -- gets you started. then you need to kill the other parameter (if you're insane)
13:13:09 <acowley> :t (length .) . filter
13:13:10 <lambdabot> (a -> Bool) -> [a] -> Int
13:13:17 <edwardk> now, we can do this two ways. one is to use the (length .) . filter approach
13:13:21 <eikke> count = (length .) . filter
13:13:28 <edwardk> another is to realize we can replace . with fmap
13:13:33 <edwardk> count = fmap length . filter
13:13:38 <johnw> or length .: filter, if you import Data.Function.Pointless
13:13:40 <edwardk> this leads to a prettier pointfree form
13:13:54 <lispy> :t (.:)
13:13:56 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
13:14:00 <kini> seeing as how I don't know what fmap is, I imagine if I had stared at it hard enough I would only have come up with the first approach :)
13:14:04 <edwardk> :t fmap length . filter
13:14:06 <lambdabot> (a -> Bool) -> [a] -> Int
13:14:06 * kini goes to look up fmap
13:14:36 <lispy> edwardk: yeah, that's the way I spell it (I needed that recently)
13:14:43 <edwardk> in practice i wouldn't use the fmap = (.) refactoring. using pointfree style on more than one argument just makes your code more brittle
13:15:15 <lispy> Pointfree is good when you're putting something in place to try something
13:15:19 <johnw> kini: that particular use of fmap is using the ((->) e) instance of Functor, if you get to the point where that means something to you
13:15:32 <ciaranm> the copointy functor!
13:15:54 <singpolyma> acowley: http://www.haskell.org/haskellwiki/Case the `select` function is pretty nice
13:16:42 <acowley> singpolyma: Yeah, that's very condish
13:16:57 <hpaste> ben pasted ‚Äúasync exception?‚Äù at http://hpaste.org/77933
13:16:59 <lispy> Do you folks know about the next case syntax extension?
13:17:04 <lispy> lambda case I think it's called?
13:17:06 <acowley> lambda case?
13:17:22 <ben> Could you help me expand that above example to catch asynchronous exceptions, note them, and continue counting?
13:17:24 <acowley> I always use a where binding for those situations and don't see much upside in lambda case
13:17:27 <b_jonas> I realized multi-parameter type classes don't work the way I thought they do, but I'm still not sure I understand how they work. Oh well.
13:17:33 <ben> I can't figure out where to squeeze in the exception handling
13:17:49 <b_jonas> They work sort of like ordinary typeclasses, that much I know.
13:18:01 <lispy> http://hackage.haskell.org/trac/ghc/ticket/4359
13:18:09 <lispy> lambda case ^^
13:18:28 <johnw> lispy: LANGUAGE LambdaCase
13:18:58 <merijn> b_jonas: How did you think they work then?
13:19:55 <b_jonas> merijn: magic, or some actual extension to the core language
13:20:19 <merijn> b_jonas: They work pretty much exactly like normal typeclasses, except the lookup is based on multiple types, rather than only 1
13:20:24 <lispy> multiwayif seems like a really bad idea
13:20:47 <mauke> a typeclass maps a type to a set of methods
13:20:51 <singpolyma> lambda case seems reasonable.  multiwayif is crazy, and also I hear it doesn't work right with layout
13:21:39 <merijn> "class Foo a b" defines the typeclass "instance Foo Char Int" defines an dictionary of functions for that combination of types. GHC just looks up a matching instances for the relevant combination of types
13:22:11 <b_jonas> merijn: what I'm more confused about is how they work in runtime
13:22:44 <b_jonas> I know you have to imagine them as if the runtime passed proofs of each constraint in every expression constrained by a typeclass,
13:22:46 <merijn> b_jonas: Ah, but that probably also applies to single parameter classes then
13:23:08 <merijn> There was an SPJ talk where he gave a high level typeclass explanation, but I forgot the name
13:23:10 <b_jonas> and constructs such a constraint whereever you call a more general typed expression from a more specifically typed one.
13:23:13 <merijn> Maybe someone else remembers?
13:24:00 <b_jonas> But the part I'm not sure about is how these constraints work in the more general case, with all the safe language extensions (especially multi-parameter typeclasses) on.
13:24:18 <kane77> I'm kind of lost.. how can I convolve mask on matrix? (in image processing)
13:24:54 <b_jonas> because there you can have instances like instance (Foo x) => Bar (G x) (H y)
13:25:05 <b_jonas> or even more ugly ones
13:25:09 <merijn> b_jonas: The GHC implementation just treats the Eq a constraint in "Eq a => [a] -> [a]" as an extra parameter which is a dictionary of functions implementing the Eq functions
13:25:26 <johnw> merijn: link me!
13:25:33 <acowley> kane77: Are you using a particular library to represent your image?
13:25:33 <merijn> johnw: I don't remember!
13:25:38 <johnw> merijn: remember!
13:25:44 <b_jonas> kane77: are you asking about how you do it algorithmically?
13:26:18 <johnw> merijn: was it http://research.microsoft.com/en-us/um/people/simonpj/papers/haskell-retrospective/ECOOP-July09.pdf?
13:26:27 <b_jonas> because there's at least three ways, depending on the size and type of the image and the matrix
13:26:31 <kane77> b_jonas, yes, more or less.. I've done it in imperative way
13:26:51 <b_jonas> kane77: there's the ordinary way, iterating over all pairs of pixels from the mask and the image;
13:27:23 <b_jonas> the fourier transform way where you take the fast fourier transform of the image and the mask, extending the mask to the size of the image, then multiply the transforms, then do an inverse fft,
13:27:33 <merijn> johnw: It's the one where he says "Good! That means I've slipped functional programming into your mind without you realising it's something very weird!"
13:27:37 <booski> What extensions should I use for this definition be valid? `data Matrix Œ± = CDL Œ± ‚áí Matrix Bounds [Œ±]'
13:27:50 <merijn> booski: Don't do that
13:28:00 <merijn> booski: Oh actually
13:28:10 <merijn> booski: You might want to do that, ExistentialQuantification
13:28:23 <merijn> I misread it as a data type context :>
13:28:25 <b_jonas> ; and there's the third way where you compute all the partial sums of the image, the adjacent differences of the mask, and then work from there -- this is easier to imagine in one dimension but works for 2-d images too
13:28:34 <rwbarton> also UnicodeSyntax :P
13:28:40 <lispy> Wouldn't extinstential omit the a on the LHS?
13:28:50 <acowley> yes
13:28:54 <kane77> b_jonas, interesting.. I'l take look on that
13:28:57 <merijn> oh, right
13:29:09 <booski> rwbarton: that was the obvious part
13:29:10 <merijn> booski: What are you trying to do?
13:29:21 <lispy> I'm not sure what booski is getting at. The use of unicode or having the type class constraint on the RHS
13:29:41 <b_jonas> kane77: the third method is faster than the second only if the adjacent differences of the mask has lots of zeros, but that's typical for zero-one masks
13:29:46 <lispy> GADTs might help or using the unicode extension might help.
13:30:04 <rwbarton> booski, doesn't GHC tell you?
13:30:19 <booski> merijn: I'm trying to define datatype with some constrains
13:30:35 <merijn> booski: Why?
13:30:45 <kane77> b_jonas, semms I have lot to learn.. but one day I'll have haskell image processing library! :)
13:30:47 <b_jonas> kane77: oh, and you could say there's a fourth way, namely writing the mask as the convolution of multiple masks, and then convolving with each of those separately in one of the previsou ways -- that's how you convolve with a gaussian efficiently: you just convolve with [1,1] multiple times effectively convolving with a binomial, and ignore the error.
13:30:52 <merijn> That's almost always the wrong thing to do
13:31:02 <booski> rwbarton: it said `Data constructor `Matrix' has existential type variables, a context, or a specialised result type'
13:31:13 <rwbarton> and then what
13:31:22 <rwbarton> mine says:       (Use -XExistentialQuantification or -XGADTs to allow this)
13:31:49 <booski> rwbarton: oh, sorry, you're right
13:32:05 <quchen> Does anyone know the "fixity" of the -> symbol in Lambda expressions?
13:32:55 <quchen> How far does it range to the right? Sometimes I have the subjective experience that it's not "as far as it can".
13:33:18 <nand`> I just read ‚ÄòLHC‚Äô and though this was some Haskell implementation I was not aware of
13:33:25 <nand`> turns out they were talking about the large hadron collider
13:33:55 <rwbarton> well there is (was?) an LHC Haskell compiler
13:33:58 <startling> nand`, the large haskell compiler a.k.a. ghc
13:34:02 <rwbarton> heh
13:34:04 <ben> There's a lhc package on hackage that purports to be a haskell compiler
13:34:50 <geekosaur> the haskell landscape is littered with the broken remains of older compilers :p
13:35:14 <rwbarton> it's that microsoft embrace and extend
13:35:17 <kini> and interpreters
13:35:56 <atriq> I tried to write a haskell interpreter once
13:36:04 <atriq> It was called PHI
13:37:08 <johnw> and what happened?
13:37:33 <acowley> He stopped after deciding on the name
13:37:38 <rwbarton> it's a nice name
13:37:56 <startling> too bad there are no good fibonacci sequence puns.
13:37:58 <johnw> PHI PHI PHO PHUM
13:37:58 <sclv_> lhc was lemmih's
13:38:15 <geekosaur> .oO { it got hak-ed? }
13:38:19 <sclv_> it was a fork of jhc -- don't know how much further he got
13:38:27 <sclv_> it was v. experimental from the start
13:38:30 <clahey> Is there a compiler that outputs java?
13:38:34 <johnw> startling: there are exactly fsp (-2) + fsp (-1) of them
13:38:36 <atriq> The P stands for Portinatx, which was where I was on holiday at the time
13:38:47 <clahey> I've been wondering if that would be a good way to go for doing haskell on android.
13:39:31 <startling> johnw: :S
13:39:49 <startling> couldn't you just bind against the ndk?
13:40:28 <geekosaur> there was at one point a thing that translated yhc's core to java, IIRC
13:40:46 <geekosaur> but yhc died some years back
13:41:07 <johnw> is there a good embedded prolog for haskell?
13:41:23 <singpolyma> johnw: LogicT (or just list monad)
13:41:37 <simpson> singpolyma: That's really not sufficient, though.
13:42:47 <simpson> @hackage hswip -- connects to SWI Prolog.
13:42:47 <lambdabot> http://hackage.haskell.org/package/hswip -- connects to SWI Prolog.
13:43:04 <simpson> @hackage prolog -- appears to be a basic interpreter that didn't get far.
13:43:05 <lambdabot> http://hackage.haskell.org/package/prolog -- appears to be a basic interpreter that didn't get far.
13:43:06 <acowley> I'm impressed with tibbe's patience in all the cabal threads
13:48:36 <mebaran151>  /join #yesod
13:49:03 <merijn> johnw: I found a similar talk to the one I mentioned
13:49:05 <merijn> johnw: http://channel9.msdn.com/posts/MDCC-TechTalk-Classes-Jim-but-not-as-we-know-them
13:51:22 <plat0> Do lenses supercede semantic editor combinators?
13:51:29 <b_jonas> kane77: here's a simple example: http://hpaste.org/77941
13:51:29 <edwardk> yes
13:51:41 <plat0> edwardk: was that "yes" to me?
13:51:46 <edwardk> 'sets' converts a semantic editor combinator to a setter
13:51:47 <acowley> yes
13:51:47 <b_jonas> plat0: I doubt. they don't even supercede glasses.
13:51:57 <edwardk> over converts a setter to a semantic editor combinator
13:52:06 <johnw> merijn: yeah, just read the slides for that talk
13:52:16 <edwardk> lenses are semantic editor combinators that you can read from, use monadic side-effects to edit, etc.
13:52:42 <b_jonas> why does hpaste syntax highlight the word "now" as if it was a language keyword?
13:52:45 <plat0> Good to know.  I was just trying to find out what they are, but conal's blog seems to be down.
13:53:03 <b_jonas> and "const" too
13:53:05 <b_jonas> strange
13:54:31 <watermind> merijn: by the way, did you follow my conversation with copumpkin? turns out it is possible to do the Mono/Poly datatype with phantom types/GADTs
14:03:56 <tac> Is there a cleaner formulation of Applicative that doesn't require a whole 5 laws?
14:04:56 <johnw> tac: not sure this is going to help, but: http://en.wikipedia.org/wiki/Monoidal_functor
14:04:58 <nicoo> @src Applicative
14:04:59 <lambdabot> class Functor f => Applicative f where
14:04:59 <lambdabot>     pure  :: a -> f a
14:04:59 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
14:05:07 <byorgey> tac: yes, there is
14:05:21 <byorgey> ezyang had a blog post about it, let me find it...
14:05:43 <tac> johnw: monoidal functors are the same as applicative functors? Or are they just related?
14:05:51 <tac> byorgey: thanks
14:05:55 <byorgey> tac: http://blog.ezyang.com/2012/08/applicative-functors/
14:06:28 <byorgey> tac: they are basically the same
14:06:54 <byorgey> though of course the notion of monoidal functor is more general than Applicative, just as the notion of functor is more general than the Functor class
14:07:19 <johnw> (**) :: f a -> f b -> f (a,b) ==> that's the monoidal functor
14:07:34 <johnw> (from ezyang's post)
14:15:17 <mreh> can I get an identity monad without installing mtl
14:15:23 <johnw> sure
14:15:26 <mreh> screw it, i'll just copy out the code
14:15:41 <simpson> mreh: data Identity a = Identity { unIdentity :: a }
14:15:44 <johnw> writing your own identity monad is about 4 lines of code
14:15:45 <mreh> transformers has IdentityT, but i need Identity to use it :)
14:15:48 <simpson> And the instances are trivial.
14:15:51 <mauke> did you mean: newtype
14:15:52 <mreh> yeah, i know
14:15:59 <simpson> mauke: Yes I did! How did you know? :3
14:15:59 <mreh> i'll see it as an exercise
14:17:52 <tac> johnw: byorgey yeah
14:18:05 <tac> I notice right off the bad the identity laws are only true up to isomorphism.
14:18:51 <tac> Since you don't have unit ** x = x, because the LHS has type ((), X) and the right, X
14:19:06 <Eduard_Munteanu> MrZepeda: transformers has Identity
14:19:15 <Eduard_Munteanu> Erm, sorry.
14:19:19 <Eduard_Munteanu> mreh: ^^
14:19:36 <Eduard_Munteanu> http://hackage.haskell.org/packages/archive/transformers/0.3.0.0/doc/html/Data-Functor-Identity.html
14:21:49 * mreh throws the last ten minutes work in the trash
14:22:22 <mreh> rm -rf Control
14:22:57 <rwbarton> you're out of control!
14:23:02 <startling> haha
14:23:28 <rwbarton> hmm, lots of good Control puns available
14:23:32 <rwbarton> edwardk now has Lens under Control
14:23:56 <shachaf> @remember rwbarton edwardk now has Lens under Control
14:23:57 <lambdabot> Good to know.
14:24:03 <edwardk> hahaha
14:24:19 <shachaf> (Even though it's not really true. :-( )
14:24:31 <edwardk> =P
14:24:42 <mreh> i'm going to waste 10 minutes emailing the maintainer of netwire to update his documentation now
14:26:26 <shachaf> rwbarton: I bet you feel like getting taking under control.
14:26:27 * hackagebot BlogLiterately 0.5.3 - A tool for posting Haskelly articles to blogs  http://hackage.haskell.org/package/BlogLiterately-0.5.3 (BrentYorgey)
14:26:34 <johnw> make it worthwhile: waste 11
14:26:58 <clahey> So, someone pointed out that something that was just a Getter was called a function.
14:27:05 <rwbarton> maybe?
14:27:06 <clahey> Is there a way to include functions in a lens chain?
14:27:12 <rwbarton> is this another one of those laziness issues?
14:27:15 <shachaf> clahey: Yep, to (blah)
14:27:16 <clahey> Or is that a nonsense sentence?
14:27:27 <shachaf> I think someone mentioned that last time too. :-)
14:27:27 <Ralith> :t to
14:27:29 <lambdabot> Gettable f => (s -> a) -> (a -> f a) -> s -> f s
14:27:29 <edwardk> clahey: 'to'
14:27:37 <shachaf> rwbarton: Yep.
14:27:41 <edwardk> it makes a getter or fold out of a lens or traversal chain though
14:27:43 <johnw> clahey: see the "lens" combinator
14:27:44 <clahey> shachaf: I logged off before they did.
14:27:45 <shachaf> rwbarton: Well, it's either a laziness issue or a type issue.
14:28:20 <clahey> What is replicated?  That's a Getter, I think, but is it anything else?
14:28:44 <clahey> :t replicated
14:28:45 <lambdabot> (Applicative f, Gettable f) => Int -> (a -> f a) -> a -> f a
14:28:58 <shachaf> replicated is a Fold
14:30:01 <rwbarton> is there some "naive" version of a Traversal (where a "naive" version of a lens is (s -> a, s -> b -> t))
14:30:03 <shachaf> > ("hello","there")^.._1.replicated 3.traverse.to toUpper
14:30:05 <lambdabot>   "HELLOHELLOHELLO"
14:30:16 <shachaf> rwbarton: Yes, s -> Bazaar a b t
14:30:23 <rwbarton> aha
14:30:32 <shachaf> rwbarton: Where data Bazaar c d a = Buy a | Trade (Bazaar c d (d -> a)) c
14:31:00 <shachaf> Alternatively, s -> (n :: Nat, Vect n a, Vect n b -> t)
14:32:09 <rwbarton> okay, right
14:32:10 <johnw> edwardk: i wanted dependent types in Haskell yesterday
14:32:59 <tac> johnw: Doesn't it just seem like dependent types would make so many type extensions trivial?
14:32:59 <edwardk> johnw: don't worry, this will pass. ;)
14:33:03 <johnw> lol
14:33:35 <cornihilio> why does this code work: https://gist.github.com/4114511 but this one doesn't?: https://gist.github.com/4114521
14:33:52 <johnw> i have these commoditized amounts where certain math operations between mismatched commodities are simply an error, so I wanted dependent types to make them cause a failure to type-check
14:34:09 <edwardk> tac: in exchange for a ton of type signatures, yes
14:34:12 <cornihilio> it complains about the data constructor for Node not existing, but in the first example one exists for DNode, not Node and compiles fine
14:34:13 <shachaf> cornihilio: Because Node is a value in the former and not in the latter.
14:34:13 <startling> johnw: why not just use phantom types?
14:34:33 <shachaf> cornihilio: (It's also a type in both, but that doesn't matter for "let foo = Node".)
14:34:34 <tac> edwardk: Type inference is overrated.
14:34:36 <johnw> startling: can you link me to some literature on how they would apply here?  the commodities are strings
14:35:06 <startling> johnw: data Dollar; data Euro; data Amount a = Amount Integer
14:35:08 <johnw> although I could use hashing to render all commodities as integers
14:35:13 <johnw> oh
14:35:19 <johnw> well, I don't know what the set of commodities will be
14:35:28 <startling> johnw: right, makes sense
14:35:28 <edwardk> tac: o.O
14:35:34 <johnw> only that certain operations preserve the equality, and others don't
14:36:01 <johnw> so the type system should *know* that a mismatch is only possible under certain conditions, and check for those conditions
14:36:04 <Eduard_Munteanu> edwardk: a resident of #agda should know ;)
14:36:09 <cornihilio> shachaf: what I don't get is why it says a constructor exists when I defined something called 'DNode' instead of 'Node'
14:36:20 <shachaf> cornihilio: Look on the other side of the = :-)
14:36:28 <edwardk> Eduard_Munteanu: i mostly am there to keep an eye on you guys and make sure you aren't up to anything ;)
14:36:45 <tac> edwardk: The nice thing about type inference is you don't have to write down all the types. The not so nice thing is you can't read all the types that weren't written down.
14:36:45 <Eduard_Munteanu> Heh.
14:36:56 <clahey> Every Getter is a Fold, right?
14:37:00 <clahey> How is replicated not a Getter?
14:37:15 <shachaf> clahey: Not every Fold is a Getter
14:37:17 <johnw> in agda, aren't type signatures just code too?
14:37:30 <cornihilio> shachaf: I think I sort of get what you are implying... but not entirely. what should I google for more info?
14:37:32 <mauke> all that getters is fold
14:37:38 <mauke> only shooting stars break the mold
14:37:41 <johnw> so really it just come down to how much code you have to write to express an idea, not how many type signatures it does or doesn't have
14:37:44 <Eduard_Munteanu> johnw: yeah, types are terms too
14:37:48 <clahey> shachaf: I sorta understand that.  I don't understand why replicated isn't a Getter.
14:37:58 <shachaf> clahey: How would it be a Getter?
14:38:17 <clahey> Or rather replicated n isn't a Getter.
14:38:24 <shachaf> It "gets" something n times. That's called a Fold. :-)
14:38:24 <shapr`> More requires more work when your ideas change, thus Haskell enables faster improvement of ideas.
14:38:30 <shapr`> Code is inertia, and you don't want that.
14:39:02 <clahey> I thought a Fold got n things and returned them once, not got one thing n times.
14:39:15 <johnw> shapr`: careful, the dynamic type lovers could say the same thing...
14:39:23 <shachaf> clahey: A Fold gets n things.
14:39:35 <johnw> sometimes, more code is less work, and less code is more work
14:39:44 <shapr`> johnw: I tell those guys that Haskell is dynamically typed at compile time anyway, so they should be fine.
14:39:45 <johnw> if it's the right code
14:40:25 <deus_rex> oh huh phantom types are neat
14:40:35 <tac> phantom types are type trickery
14:41:01 <clahey> shachaf: Which then you can foldMap on.
14:41:10 <shachaf> clahey: If you want.
14:41:26 <startling> shapr`: haha
14:41:30 <clahey> shachaf: Isn't it also a getter in that it returns a single thing which is a list?
14:41:35 <johnw> i map edwardk to Opinion·¥º·¥æ, the category where all his opinions reverse direction
14:41:37 <startling> @info Fold
14:41:38 <lambdabot> Fold
14:41:43 <startling> ?
14:41:49 <shapr`> johnw: What does that even mean?
14:41:50 <shachaf> startling: One day people will stop doing @info
14:41:54 <shachaf> clahey: What does that mean?
14:42:05 <mauke> there has never been an @info
14:42:05 <startling> shachaf, I need the information
14:42:19 <clahey> shachaf: A Fold gets n things.  What does a Getter do?
14:42:29 <startling> what does lambdabot think I'm saying?
14:42:34 <mauke> startling: @undo
14:42:42 <shachaf> clahey: Gets one thing.
14:42:45 <johnw> shapr`: nothing :)
14:42:49 <shapr`> whew
14:42:55 <startling> mauke: heh
14:43:01 <johnw> i hardly think a normal functor will work on edwardk anyway
14:43:06 <shapr`> startling: That's the equivalent of :info Fold
14:43:10 <johnw> i probably need a 2-cell natural transformation for the likes of him
14:43:15 <shapr`> oh nm then
14:43:25 <clahey> shachaf: So replicated is fold in that it gets n things.  You can then create a list out of that, but that's not the natural thing to do.
14:43:37 <shachaf> clahey: It seems pretty natural to me.
14:43:41 <clahey> Or rather, not the automatic thing to do.
14:43:43 <startling> johnw, he *is* an elite haskell master, you know.
14:43:52 <clahey> I agree that it's a natural thing to do.
14:44:50 <clahey> You then have to decide what to do with your n things.  foldMapOf is one option.
14:45:14 <clahey> However, expanding an array is more than just getting n things.  It's getting a ton of things with a structure applied to those things.
14:45:25 <shachaf> ?
14:45:29 <shachaf> Where did arrays get into it?
14:45:47 <shapr`> clahey: I'm lost, what's going on again?
14:45:48 <clahey> shachaf: I'm trying to figure out what lenses into arrays look like.
14:45:55 <startling> is there a longer-than function for lists?
14:45:57 <clahey> In particular, repa.
14:46:05 <shachaf> clahey: There are some in Data.Array.Lens
14:46:07 <clahey> :t comparing length
14:46:09 <lambdabot> [a] -> [a] -> Ordering
14:46:09 <shachaf> And I think Data.Vector.Lens
14:46:18 <shachaf> They're "indexed lenses"
14:46:20 <shapr`> startling: yes, but I've only seen it in personal utility packages.
14:46:28 <startling> clahey: nah, that's not what I mean
14:46:38 <startling> I mean longerthan :: Int -> [a] -> Bool
14:46:42 <hpaste> autthor pasted ‚Äútitle‚Äù at http://hpaste.org/77944
14:46:54 <startling> so it's only O(n) where n is your given length
14:46:56 <clahey> flip ((>) . length)
14:47:12 <clahey> Ah, I see.
14:47:15 <startling> clahey, again, not what I mean
14:47:16 <shachaf> mauke: I didn't say there had been.
14:47:17 <startling> yeah
14:47:27 <startling> it's trivial to write, just annoying that it doesn't exist. :(
14:47:41 <clahey> You want that, except faster and true for infinite lists.
14:47:46 <startling> right
14:48:00 <shachaf> @ty let longerthan n xs = replicate n () > void xs in longerthan
14:48:02 <lambdabot> Int -> [a] -> Bool
14:48:05 <Lemmih> startling: not . null . drop n
14:48:13 <startling> Lemmih: nice
14:48:34 <clahey> shachaf: I have to go, but I will be back to understand more about lenses.
14:48:37 <shachaf> I'm always afraid of off-by-one errors when I do the null . drop n thing.
14:48:38 <startling> :t not . null .: drop
14:48:40 <lambdabot>     Couldn't match expected type `Bool' with actual type `g0 b0'
14:48:40 <lambdabot>     Expected type: f0 Bool
14:48:40 <lambdabot>       Actual type: f0 (g0 b0)
14:48:59 <startling> > not . null . drop 2 $ [1, 2, 3]
14:49:01 <lambdabot>   True
14:49:14 <clahey> > not . null . drop 2 $ [1, 2]
14:49:16 <lambdabot>   False
14:49:27 <clahey> So that's >, not >=, depending on which you want.
14:49:28 <johnw> > not . null . drop 2 $ [2]
14:49:31 <lambdabot>   False
14:49:40 <shachaf> My approach works for any operation. :-)
14:49:51 <cornihilio> shachaf: I'm sorry to keep pestering you but I still don't understand. I don't get how 'data DNode = Node' lets me do 'let a = Node'
14:49:57 <pauser> hi, i need some help to do a function because i dont know what im doing wrong . http://hpaste.org/77944 . Equations give different arities for "sum" . I know it pretty simple but i still dont get it .
14:50:07 <shachaf> cornihilio: Do you understand how data Bool = False | True lets you do let x = True?
14:50:37 <merijn> pauser: Your second pattern for sum has 4 arguments
14:50:44 <merijn> pauser: While your first pattern has only 1
14:51:07 <cornihilio> wow, I guess I've been doing that without thinking about it at all...
14:51:30 <hpaste> merijn annotated ‚Äútitle‚Äù with ‚Äútitle (annotation)‚Äù at http://hpaste.org/77944#a77945
14:51:52 <merijn> pauser: Presumably you meant to write something like that
14:52:34 <merijn> pauser: Actually, your first pattern is also incorrect. Null doesn't have any arguments, so "(Null n)" is a type error
14:52:48 <pauser> just Null ?
14:53:30 <merijn> pauser: Your data declaration defines a type Tree, which has 2 constructors (Null and Tree).
14:53:52 <johnw> startling: not . null .: drop has the advantage that it works on infinite lists too, since it really means "has more than N"
14:53:59 <merijn> pauser: The first of these (Null) takes 0 arguments. The second takes three arguments, a Label and two Trees
14:54:09 <johnw> not . null . drop 3 $ [1..]
14:54:11 <johnw> > not . null . drop 3 $ [1..]
14:54:14 <lambdabot>   True
14:54:23 <merijn> pauser: Pattern matching a constructor means you bind each argument it has, so 0 for Null and 3 for Tree
14:54:31 <cornihilio> shachaf: thank you for being patient and explaining that to me
14:54:42 <startling> johnw: right, that's why I wanted it. :)
14:54:51 <johnw> adding that to my mental toolbox... :)
14:55:05 <hpaste> autthor annotated ‚Äútitle‚Äù with ‚Äútitle (annotation) (annotation)‚Äù at http://hpaste.org/77944#a77946
14:55:10 <shachaf> > void [1..] > voided 3
14:55:12 <lambdabot>   True
14:55:22 <shachaf> > void "hello" == voided 5
14:55:25 <lambdabot>   True
14:55:26 <pauser> merijn: like this ? http://hpaste.org/77944
14:55:27 <startling> :t (not . null) .: drop
14:55:28 <lambdabot> Int -> [a] -> Bool
14:55:32 <merijn> pauser: No, you still need to write the Null constructor, but without the n behind it
14:55:33 <shachaf> > voided 14 < void [1..]
14:55:35 <lambdabot>   True
14:55:37 <startling> yeah, that's how you need to spell it.
14:55:44 <merijn> pauser: So "summe Null = 0"
14:56:05 <johnw> :t voided
14:56:07 <lambdabot> Int -> [()]
14:56:24 <startling> :t void
14:56:25 <lambdabot> Functor f => f a -> f ()
14:56:32 <startling> that's interesting
14:57:02 <johnw> shachaf: where is voided from?
14:57:09 <startling> > (compare `on` voided) [1, 2] [1, 2, 3]
14:57:09 <johnw> @hoogle voided
14:57:10 <lambdabot> No results found
14:57:10 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
14:57:11 <lambdabot>              with actual type ...
14:57:13 <shachaf> johnw: @let
14:57:19 <tac> :t void
14:57:21 <lambdabot> Functor f => f a -> f ()
14:57:24 <tac> hm
14:57:24 <johnw> @src voided
14:57:25 <lambdabot> Source not found. I am sorry.
14:57:28 <startling> :t compare `on` voided
14:57:29 <lambdabot> Int -> Int -> Ordering
14:57:37 <pauser> merijn: that works thanks a lot
14:57:52 <johnw> > voided 4
14:57:55 <lambdabot>   [(),(),(),()]
14:58:02 <startling> > (compare `on` void) [1, 2, 3] [1, 2]
14:58:04 <lambdabot>   GT
14:58:34 <johnw> what is compare doing there?
14:58:42 <johnw> :t compare `on` void
14:58:43 <shachaf> johnw: comparing
14:58:44 <lambdabot> (Functor f, Ord (f ())) => f a -> f a -> Ordering
14:58:59 <merijn> johnw: Comparing by length :p
14:59:10 <startling> johnw, [()] > []
14:59:10 <merijn> > void [1]
14:59:12 <lambdabot>   [()]
14:59:14 <merijn> > void [1,2]
14:59:16 <lambdabot>   [(),()]
14:59:27 <merijn> > compare [()] [(),()]
14:59:29 <lambdabot>   LT
14:59:34 <tac> :t compare
14:59:36 <lambdabot> Ord a => a -> a -> Ordering
14:59:36 <johnw> why bother void'ing the list then
14:59:42 <johnw> > voided 14 > [1,2,3]
14:59:44 <lambdabot>   No instance for (GHC.Num.Num ())
14:59:44 <lambdabot>    arising from the literal `1'
14:59:44 <lambdabot>  Possible ...
14:59:48 <merijn> johnw: Else it's take the elements into account
14:59:54 <johnw> ah
14:59:59 <merijn> s/'s/
15:00:01 <startling> > [2] > [1]
15:00:03 <lambdabot>   True
15:00:03 <shachaf> > unwords . sortBy ((compare `on` void) ++ compare) $ words "just a few words to compare Cale-style, but using the void trick"
15:00:06 <lambdabot>   "a to but few the just void trick using words compare Cale-style,"
15:00:31 <johnw> shachaf: does that trick fuse down to simple O(n) iteration of the list being compared against?
15:00:39 <shachaf> johnw: I'd be pretty surprised.
15:00:50 <shachaf> johnw: Well, it depends.
15:00:52 <johnw> oh, I thought you knew some deep core voodoo
15:01:00 <shachaf> It'll surely be O(n), because what else could it be?
15:01:15 <johnw> i should have added: and constant stack
15:01:21 <startling> johnw, it might be O(2n), which is just O(n)
15:01:23 <johnw> i.e., it's not going to really create a list full of ()
15:01:38 <shachaf> But it'll probably allocate the extra list and examine it and GC it.
15:01:43 <johnw> meh
15:01:48 <startling> > head $ void [1..]
15:01:50 <lambdabot>   ()
15:01:52 <shachaf> johnw: But you can create RULES for it if you want.
15:01:55 <johnw> not . null .: drop sounds preferable then
15:02:01 <shachaf> However, you shouldn't.
15:02:07 <startling> johnw, you need parens
15:02:17 <startling> (not . null) .: drop
15:03:12 <johnw> really?
15:03:18 <johnw> without parens it type-checked fine for me
15:03:25 <startling> :t not . null .: drop
15:03:27 <lambdabot>     Couldn't match expected type `Bool' with actual type `g0 b0'
15:03:27 <lambdabot>     Expected type: f0 Bool
15:03:27 <lambdabot>       Actual type: f0 (g0 b0)
15:03:41 <startling> johnw: you probably have a different fixity
15:03:43 <johnw> I got this:
15:03:44 <johnw> not . null .: drop :: Int -> [a] -> Bool
15:03:52 <johnw> ah, maybe this .: isn't from Data.Function.Pointless
15:04:18 <johnw> seems like there should be a Prelude definition for "not .null"
15:04:21 <johnw>  i use it often enough
15:04:29 <lispy> BTw, I ordered that awodey book on my lunch break today :)
15:04:49 <johnw> lispy: nice!
15:04:53 <johnw> lispy: completely worth it
15:04:54 <shachaf> Awodey wrote a book on lispy's lunch break?
15:05:20 <startling> shachaf, no, it was about lispy's lunch break
15:05:32 <shachaf> startling: Yes, that sense of "on"
15:05:48 <startling> shachaf, no, it was during lispy's lunch break
15:06:00 <shachaf> startling just wants to say "no" to me.
15:06:04 <shachaf> It doesn't matter what the topic is.
15:06:11 <tac> lispy: nice.
15:06:19 <johnw> lispy: I recommend following along with http://www.haskell.org/haskellwiki/User:Michiexile/MATH198/Lecture_1 while you read it
15:06:22 <startling> shachaf: I'm a h8r h8r
15:06:24 <tac> lispy: If I need to work through exercises with someone, I'll bug you :)
15:06:37 <lispy> cool
15:06:38 <shachaf> 12:04 <nand`> I think shachaf would make a good niceness enforcer
15:06:42 <lispy> Thanks for all the offers!
15:06:45 * shachaf has no idea what nand` meant.
15:06:48 <johnw> tac: bug me too, please
15:06:52 <shachaf> I was asleep by then.
15:07:03 <cornihilio> um... I guess I really don't understand basic haskell... but how would I go about fixing this?: https://gist.github.com/4114690
15:07:03 <tac> johnw: sure thing.
15:07:10 <johnw> shachaf: sarcasm maybe? ;)
15:07:19 <shachaf> johnw: Maybe!
15:07:25 <shachaf> But I don't know the context.
15:07:50 <tac> cornihilio: The problem is with how DNode is defined
15:07:58 <merijn> cornihilio: Node (as in the constructor for DNode) is a value
15:08:07 <johnw> cornihilio: Node is both a data constructor and a type constructor in your program
15:08:09 <cornihilio> in my mind it would be like writing a function that only works on True instead of Bool, so I can't really imagine a similar situation
15:08:12 <tac> It says, the way you have it written, that Node is a 0-argument constructor for making DNodes
15:08:13 <merijn> cornihilio: The other Node (the type) is a type constructor
15:08:34 <tac> cornihilio: you want a 1-argument constructor instead, and you want the type of the argument to be Node
15:08:38 <mauke> you have two unrelated Nodes
15:08:40 <rwbarton> maybe
15:08:42 <tac> cornihilio: try changing it to DNode = DNode Node
15:08:47 <rwbarton> even if you erase all the types from the program, it still makes no sense
15:08:47 <merijn> cornihilio: Did you maybe intend something like "data DNode = Node (Mailbox Operation)"?
15:08:50 <johnw> shachaf: we were talking about keeping the tone of #haskell friendly in the sense of what initially attracted edwardk to come hang out here
15:09:25 <cornihilio> jeez thanks for all the suggestions!
15:10:00 <johnw> shachaf: he claimed he was a big old meanie until #haskell impressed him to the point that he decided he wanted to be "friendly like Cale, et la"
15:10:30 <cornihilio> so it seems like I want to write something like "Node' :: Node" as a constructor?
15:10:39 <johnw> shachaf: and we all agreed that's a culture we want to preserve
15:11:09 <rwbarton> cornihilio, probably you would be better off without type synonyms for now
15:11:18 <cmccann> aspiring to be more like Cale is always a worthwhile goal
15:11:21 <merijn> cornihilio: As mauke pointed out you have two Node definitions in your program that are completely related, which is probably what's confusing you
15:11:24 <johnw> I wonder  if Awodey knows how many of his book sales come from this channel
15:11:42 <merijn> johnw: He should do an AMA on r/haskell ;)
15:11:50 <startling> johnw, lispy can tell him on his lunch break
15:11:59 <rwbarton> cornihilio: so the type of insert is Mailbox Operation -> Int -> IO ()
15:12:17 <rwbarton> cornihilio: so you better pass insert a Mailbox Operation, whatever that is
15:12:31 <rwbarton> and forget about all the Node/DNode stuff
15:13:02 <cornihilio> rwbarton: ah, okay. I will try to do that. thank you all!
15:16:43 <cornihilio> um... but what about the Bool/True thing? How would I handle an example where I have a Bool value in 'a' and I'm trying to use a function that only works with 'True'?
15:17:05 <rwbarton> don't
15:17:27 <cornihilio> so that's basically a problem you only have with bad code :p?
15:17:37 <rwbarton> if the only value you can pass is True then why do you need to pass a value at all...
15:18:35 <glguy> cornihilio: just ask the same question but say that you take an Int, but not negative Ints
15:19:48 <johnw> lispy: I can also recommend watching the Catsters
15:20:35 <cornihilio> so my confusion is coming from not understanding data/type constructors?
15:20:51 <johnw> cornihilio: I misspoke
15:21:01 <johnw> you have a type (not type constructor) named Node
15:21:15 <johnw> and a singleton value named Node
15:21:56 <johnw> data Foo = Foo
15:21:59 <rwbarton> in this case I cannot understand the intent of your code any better than GHC
15:22:04 <johnw> that represents the same pairing
15:23:31 <cornihilio> johnw: isn't my singleton 'data DNode = Node'?
15:23:51 <cornihilio> I tried 'data Node = Node' and it complained about multiple declarations, so that's what caused me to change it
15:25:15 <cornihilio> well to be clear about my intentions: I have this function 'insert :: Node -> Int -> IO ()' and this type 'type Node = Mailbox Operation' and I'm basically trying to create a root node and insert a sample value
15:25:58 <rwbarton> you need to know about Mailbox Operation then
15:26:00 <crdueck> @src zipM_
15:26:01 <lambdabot> Source not found. You type like i drive.
15:26:02 <crdueck> @src zipM
15:26:03 <lambdabot> Source not found. Are you on drugs?
15:26:25 <rwbarton> none of the 'type Node = Mailbox Operation', 'data DNode = Node' etc. is getting you closer to that
15:26:26 <cornihilio> rwbarton: why do you say that?
15:26:48 <rwbarton> what is Mailbox?
15:26:48 <crdueck> :t \f as bs -> sequence_ (zipWith f as bs)
15:26:50 <lambdabot> Monad m => (a1 -> b -> m a) -> [a1] -> [b] -> m ()
15:27:08 <cornihilio> I don't know... but I'm just trying to understand why you want to look there
15:27:10 <cornihilio> I'm sure you are right
15:27:16 <rwbarton> okay...
15:27:23 <rwbarton> you say you want to pass something to insert
15:27:28 <cornihilio> I just know without this channel I'd be fooling around with DNode for 8 hours
15:27:32 <rwbarton> insert's argument has type Mailbox Operation
15:27:40 <rwbarton> so, you need a value of type Mailbox Operation
15:27:51 <rwbarton> yes?
15:28:29 <cornihilio> I believe so... but from that type declaration for Node, it's not obvious how to make a data constructor for it?
15:28:46 <rwbarton> forget all the "type Node = Mailbox Operation" "data DNode = Node" stuff
15:29:10 <cornihilio> my problem is that I can't tell if I'm misunderstanding something fundamental or missing something 100 lines down
15:29:44 <cornihilio> or both
15:30:38 <rwbarton> you cannot simply conjure up a value of type Mailbox Operation from thin air
15:30:46 <rwbarton> (aside from using "undefined")
15:31:08 <rwbarton> you need to use a function provided by whatever package defines Mailbox, or use the definition of the type Mailbox...
15:33:59 <cornihilio> so this has most of the info on it https://gist.github.com/4114847
15:36:00 <cornihilio> so I guess the 'Mailbox Operation' is similar to something like 'Mailbox Bool'
15:36:14 <rwbarton> okay! so you can construct a Mailbox Operation with the 'mailbox' function
15:36:23 <rwbarton> applied to a function of type Operation -> IO ()
15:36:31 <cellc3llcell> /
15:39:41 <cornihilio> ah! okay, I think it's starting to make sense now
15:41:29 <cornihilio> but I'm a bit confused about this... if mailbox() is defined in Control.Concurrent.Actors, if I run 'import Control.Concurrent.Actors' it imports everything Actors exports, right?
15:42:15 <pqmodn> cornhilio: you can do this, import Control.Concurrent.Actors (mailbox) to import only "mailbox"
15:42:15 <Polarina> cornihilio, it would import everything in Control.Concurrent.Actors, yes.
15:42:42 <pqmodn> cornihilio: see http://www.haskell.org/haskellwiki/Import
15:42:49 <rwbarton> it looks like mailbox is not exported
15:43:07 <rwbarton> it is for internal use in Control.Concurrent.Actors only
15:43:14 <cornihilio> but it exports: > newtype Mailbox a = Mailbox { sender :: Sender a }
15:43:56 <cornihilio> so I should be able to say "Mailbox Int", right?
15:44:08 <cornihilio> err let a = Mailbox Int
15:44:11 <rwbarton> it exports the type but not the definition
15:44:12 <rwbarton> and no
15:44:33 <geekosaur> types can be exported minus constructors
15:45:21 <rwbarton> but even if the constructor was exported, you could not say that unless you happened to have a value named Int
15:45:43 <geekosaur> right
15:46:32 <rwbarton> the module documentation suggests using spawn
15:47:06 <cornihilio> oh... it turns out I'm an ever bigger idiot. There was this example was defined in Actor.lhs: https://gist.github.com/4114950
15:47:14 <cornihilio> 30 lines down...
15:48:07 <cornihilio> sorry about that everyone
15:53:32 <Taslem> With the FFI, I want to check whether a CIntPtr is null. But the "nullPtr" object is of type Ptr a. How do I do that?
15:54:03 <lispy> Taslem: castPtr is a last resort
15:54:13 <lispy> Taslem: there might be something more specific. 0?
15:54:17 <mauke> >implying
15:54:22 * lispy doesn't know what CIntPtr corresponds to
15:54:34 <rwbarton> er
15:54:50 <lispy> oh, I see the problem
15:54:56 <Taslem> Yes...
15:55:02 <rwbarton> you do?
15:55:03 <lispy> newtype CIntPtr = CIntPtr Int64
15:55:21 <rwbarton> oh
15:55:36 <mauke> it corresponds to intptr_t
15:55:37 <rwbarton> well you can just check whether it == 0
15:55:47 <Taslem> Oh, right. Will that work?
15:56:00 <lispy> It will work if it works in C
15:56:06 * lispy is still looking this up
15:56:07 <mauke> Taslem: no
15:56:17 <Taslem> It compiled. I don't know if it worked.
15:56:24 <mauke> the laws of intptr_t are:
15:56:37 <mauke> for any void *p, it is guaranteed that (void *)(intptr_t)p == p
15:56:54 <mauke> (also, intptr_t is an integer type)
15:57:35 <rwbarton> why do you have a CIntPtr anyways?
15:57:36 <mauke> I don't see any helper functions for converting between Ptr a and CIntPtr
15:57:39 <rwbarton> it sounds useless
15:58:04 <Taslem> It's a pointer to a struct, so.. it worked to shuffle it around without having to specify.
15:58:28 <mauke> it's not a pointer
15:58:29 <rwbarton> wouldn't a pointer to a struct be something like Ptr MyStruct?
15:58:35 <mauke> CIntPtr is an integer
15:58:57 <lispy> It's meant to be a signed integer large enough to store a pointer
15:59:00 <Taslem> Yes.., but the compiler doesn't particularily care, as it turns out.
15:59:01 <lispy> (that's my reading)
15:59:05 <Taslem> So... I'll change that...
15:59:06 <mauke> Taslem: yes, it does
15:59:12 <kini> whoa, what? I can't do "[0..] !! (2 :: Integer)"?
15:59:13 <rwbarton> what a terrible name
15:59:20 <mauke> kini: correct
15:59:27 <lispy> kini: you need the generic list functions
15:59:35 <kini> or I could just use Int, I suppose...
15:59:41 <rwbarton> it seems like the laws of intptr_t should be:
15:59:44 <rwbarton> don't use intptr_t
16:00:22 <Taslem> So what DO I use?
16:00:32 <lispy> Sorry, what are you doing?
16:00:38 <mauke> rwbarton: it usually is, yes
16:00:50 <mauke> Taslem: that depends on what you're trying to achieve
16:01:17 <Taslem> I'm trying to set up my own SDL wrappers.
16:01:30 <mapf> yo mam so fat that if someone trying to apply beta reduction with her then all De Bruijn indexes corresponding to the free variables of a substituted term approaches infinity
16:01:35 <Taslem> And I need to be able to pass pointers back and forth from C.
16:01:47 <mauke> ok
16:02:12 <ben> Use a 'Ptr a' type
16:02:14 <mauke> how does intptr_t enter the picture?
16:03:09 <Taslem> I needed some method of using pointers. I preferred CIntPointer because it meant I didn't have to keep specifiying (Ptr a) when 'a' was a lie anyway.
16:03:21 <Taslem> Anyway, I switched over to Ptr a.
16:03:29 <mauke> ‡≤†_‡≤†
16:03:47 <lispy> Taslem: what do you mean that the 'a' is a line?
16:03:47 <Taslem> I can see why that's bad.
16:03:49 <lispy> lie*
16:03:51 <mauke> that doesn't even make sense
16:03:58 <Taslem> You're exactly right.
16:04:00 * Ralith wonders of (Ptr Void) works
16:04:07 <mauke> Haskell offers no way to convert Ptr a to CIntPtr
16:04:18 <startling> Ralith: sure
16:04:21 <Taslem> Yeah, that's what I figured. Seems odd.
16:04:24 <Ralith> @hoogle (Ptr a) -> CIntPtr
16:04:25 <lambdabot> Foreign.Ptr castPtrToFunPtr :: Ptr a -> FunPtr b
16:04:25 <lambdabot> Foreign.Ptr castPtr :: Ptr a -> Ptr b
16:04:25 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
16:04:31 <lispy> Taslem: your FFI bindings don't get type checked like you're probably use to.
16:04:33 <Ralith> :D
16:04:54 <Taslem> lispy: Yes. That's right.
16:04:57 <lispy> Taslem: you can give types in your import that are more or less bogus (not sure on the exact rules)
16:04:59 <Ralith> Taslem: I don't believe it's uncommon for bindings to use empty types for this.
16:05:36 <Taslem> Yeah, I don't know really. It effectively doesn't matter since I don't do any operations except pass them back or compare them to null.
16:05:44 <Taslem> And that way they're pretty much the same no matter what type they are.
16:05:48 <Ralith> yes, so it's just documentation/safety
16:06:04 <lispy> Taslem: in that case, you'll want to add a layer that makes the Ptr an opaque thing to the user code
16:06:29 * hackagebot repa-examples 3.2.2.3 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.2.3 (BenLippmeier)
16:06:34 <lispy> Taslem: just so no one using your binding accidentally messes with it
16:07:04 <Taslem> lispy: I need to get it finished before I can add safety features like that. I plan on making a few versions so people can do it better if they want.
16:07:30 <lispy> Taslem: Any particular reason you are doing it from scratch?
16:07:37 <lispy> Taslem: IIRC, a binding for SDL exists
16:07:40 <Taslem> Tried.
16:07:46 <Taslem> Didn't work for me on Windows.
16:07:48 <Taslem> That's the key issue.
16:07:50 <lispy> In fact, someone I work with got SDL working on windows
16:08:01 <Taslem> There were some weird dependencies I couldn't resolve.
16:08:06 <Taslem> Can't remember right now.
16:08:06 <lispy> He doesn't use darcs so he didn't have a way to submit the patches
16:10:14 <lispy> Taslem: here is his code: https://github.com/elliottt/blank-slate/tree/master/windows
16:10:25 <lispy> Taslem: install-sdl.sh patches the SDL bindings to build on windows
16:11:15 <Nereid> I got SDL working for windows with basically no effort
16:11:19 <Taslem> Weird.
16:11:20 <Nereid> a few months ago
16:11:47 <lispy> Nereid: did you use SDL-image?
16:11:53 <Nereid> I don't remember
16:12:06 <Nereid> well I didn't use it, I don't remember if I installed it successfully
16:12:11 <lispy> Nereid: I think that might have been the tricky part
16:12:18 <Nereid> hmm
16:12:19 <lispy> the patches are pretty much trivial though
16:12:26 <Nereid> I believe it was on 7.4 too
16:16:51 <lispy> > 0.5 * 0.8
16:16:53 <lambdabot>   0.4
16:17:09 <lispy> Good to see that's still working
16:17:52 <startling> ...why wouldn't it?
16:18:49 <lispy> cosmic rays?
16:18:55 * lispy doesn't have an answer
16:19:37 <startling> I suppose lambdabot would be a good way to tell if you're dreaming.
16:20:36 <Nereid> heh
16:21:46 <DMcGill> @faq am I dreaming?
16:21:47 <lambdabot> The answer is: Yes! Haskell can do that.
16:22:20 <startling> inconclusive
16:23:32 <mauke> @nixon am I dreaming?
16:23:32 <lambdabot> The presidency has many problems, but boredom is the least of them.
16:26:52 <nicoo> @dream ing am I ?
16:26:52 <shachaf> @palomer am I dreaming?
16:26:52 <lambdabot> Plugin `dummy' failed with: Prelude.read: no parse
16:26:52 <lambdabot> Blargh!
16:27:10 <nicoo> @quote dream
16:27:10 <lambdabot> kyevan says: I had a haskell-related dream last night. Sorta. I was beaten up by some kids because I tried to go somewhere my type didn't match, apparently.
16:27:21 <nicoo> Ahah
16:27:37 <Canar> @quote sex
16:27:37 <lambdabot> davidhasselh0f says: [on SPJ's "A Taste of Haskell" tutorial]: It's better than sex.
16:41:30 * hackagebot debian 3.69.1 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.69.1 (DavidFox)
16:58:26 <signalsea> What's * mean when it appears in a type signature?
16:59:14 <startling> signalsea, it's a kind
16:59:59 <signalsea> so it means "kind type"? I'm not talking about kind signatures
17:00:27 <startling> signalsea, what does your type signature look like?
17:01:43 <signalsea> example :: Rec ((':) * ("name" ::: String) ('[] *))
17:02:24 <signalsea> (i am playing with https://github.com/jonsterling/Vinyl)
17:02:40 <startling> that's really strange.
17:03:08 <signalsea> yup the library makes heavy use of type literals and operators
17:03:42 <signalsea> but * seems to be some built-in type operator, or maybe a type itself
17:04:06 <startling> signalsea, looks like a crazy Num instance to me
17:04:24 <startling> I have no idea what (':) and (:::) do though
17:04:29 <mauke> startling: where do you see Num?
17:04:48 <signalsea> (:::) is a type operator defined in the library
17:04:59 <shachaf> ': is lifted :
17:05:04 <startling> mauke, (*) is a Num method.
17:05:16 <shachaf> startling: That's a type, not a value.
17:05:19 <mauke> startling: not in types
17:05:37 <startling> I figured this was some crazy DataKinds thing?
17:05:51 <startling> Oh well, I'll stop making guesses.
17:07:21 <signalsea> shachaf: so value operators can be lifted to type operators? are ': and '[] built-in?
17:07:54 <shachaf> Yep.
17:08:39 <shachaf> data HList :: [*] -> * where { HNil :: HList '[]; HCons :: t -> HList ts ->  HList (t ': ts) }
17:09:14 <shachaf> HCons True (HCons 'a' (HCons "hi" HNil)) :: HList '[Bool, Char, String]
17:11:13 <signalsea> was that "Yep" to both my questions or just the first?
17:11:56 <shachaf> ': and '[] are as built-in as : and []
17:13:02 <signalsea> can one make an arbitrary "Sometype *" kind, such as [*] ?
17:13:10 <shachaf> Yep.
17:13:15 <signalsea> how?
17:13:43 <signalsea> i presume it's to do with promoted types, i just wonder what the syntax would look like
17:14:07 <shachaf> data List a = Nil | Cons a (List a)
17:14:12 <shachaf> data HList :: List * -> * where { HNil :: HList Nil; HCons :: t -> HList ts -> HList (Cons t ts) }
17:14:37 <signalsea> oh it's just a listed type variable, ok
17:14:45 <signalsea> err
17:14:51 <signalsea> s/listed/lifted
17:18:55 <signalsea> can one specify which kind the type variable should become? like Constraint for example, or some other lifted Kind?
17:19:18 <shachaf> Variable?
17:20:55 <signalsea> ie could i make a "List Constraint" kind? or a "List List" from something resembling "data List a..."
17:22:31 <signalsea> or even a "List OpenKind" kind
17:24:16 <signalsea> oh nvm the ghc manual mentions restrictions
17:43:53 <souf> Haskell
17:45:02 <souf> What makes it so good?
17:45:49 <johnw> not sure how to answer that, souf
17:46:26 <MetaCosm> it is full of protien
17:46:31 <MetaCosm> that is why I like haskell.
17:46:40 <MetaCosm> If anyone tells you it isn't, they are lying.
17:46:40 <hpc> it's got the electrolytes plants crave
17:46:59 <MetaCosm> and some people here like to screw around with people and say it is about programming.
17:47:04 <MetaCosm> nothing could be further from the truth.
17:47:09 <MetaCosm> don't get suckered in.
17:47:16 <MetaCosm> darn pranksters.
17:47:21 <aristid> or do, but realize it's because of the proteins.
17:47:46 <souf> If you compare it with java, what makes Haskell simplier.
17:48:07 <mauke> ArrayStoreException
17:48:12 <spaceships> java is more pro-teen, haskell is anti-teen
17:48:33 <johnw> souf: I wouldn't compare it with java
17:48:45 <hpc> did you know "haskell" is properly spelled "HasÃúkell", and is french for "not a programming language"
17:49:00 <deus_rex> one way haskell is simpler is that its hello world is shorter :V
17:49:29 <hpc> souf: java is lower in protein and higher in caffeine
17:49:40 <MetaCosm> Haskell will teach you -- if you invest the time, to approuch problems differently that you (probably) do.
17:49:50 <MetaCosm> which makes it worthwhile if nothing other than a hobby langauge.
17:50:03 <johnw> souf: I think what we're saying is that your question lacks enough context for us to give a meaningful answer that will relate to you, so instead we're giving nonsensical answers to amuse ourselves :)
17:50:16 <hpc> yes, tha
17:50:37 <hpc> for a sales pitch, see haskell.org
17:50:43 <hpc> for a list of features, see wikipedia
17:50:44 <hpc> :P
17:50:49 <souf> I see.
17:52:18 <johnw> souf: I'm sorry if we sound snarky, it's just late in the day for some of us :)
17:53:08 <MetaCosm> and, some of us idle in lots of language channels -- and that question pops up in all of them.
17:53:29 <MetaCosm> http://bit.ly/10iBnxR
18:10:22 <startling> <|> is kind of annoying for error-handling, isn't it
18:10:59 <Ralith> how so?
18:14:00 <Dashkal> @type (<|>)
18:14:02 <lambdabot> Alternative f => f a -> f a -> f a
18:15:12 <johnw> lispy: ping
18:15:21 <shachaf> lispyng
18:15:29 <johnw> (ping)
18:15:52 <Ralith> lispNG
18:17:24 <startling> Ralith: because I want my error to gather the errors that all the subparsers made
18:18:31 <Ralith> startling: what for?
18:18:57 <startling> Ralith: so I can get a nice tree of errrors
18:19:36 <Ralith> I'm not sure what the use of that is
18:19:51 <Ralith> parsec doesn't really have tree-shaped errors
18:20:10 <Ralith> unless you want to construct a graph of all the various failed parses?
18:21:33 * hackagebot chu2 2012.11.20 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.20 (JinjingWang)
18:21:51 <startling> Ralith, yeah, that's why I'm not using parsec. :)
18:25:33 <Ralith> what are you using?
18:25:58 <Ralith> if you want good error reporting to users, edwardk's trifecta has some pretty attractive claims
18:30:35 <startling> Ralith, I'm writing a thing. :/
18:31:02 <startling> I've seen trifecta, though; it's better than parsec but I want to try some other stuff.
18:31:09 <Ralith> what a silly idea
18:31:15 <Ralith> everyone knows writing things is a waste of time!
18:33:08 <startling> Ralith: heh
18:34:50 <Ralith> seriously though, what's your design?
18:34:56 * Ralith is interested in parsers
18:35:40 <shachaf> Ralith: When are they going to make a streaming parser. :-(
18:36:16 <startling> Ralith: sec
18:37:31 <startling> Ralith: https://gist.github.com/205ed910d446e37f1814
18:37:59 <startling> Ralith, mostly I'm kind of sheepish about re-inventing the wheel.
18:38:21 <Ralith> re-inventing the wheel is one of the best ways to learn!
18:41:25 <startling> shachaf, I'm not sure streaming parsers are so useful.
18:41:44 <shachaf> startling: What if you're parsing a 1GB file?
18:43:33 <startling> shachaf, can't attoparsec do that lazily already?
18:44:09 <shachaf> Attoparsec is specialised to deal only with strict Text input. Efficiency concerns rule out both lists and lazy text. The usual use for lazy text would be to allow consumption of very large input without a large footprint. For this need, Attoparsec's incremental input provides an excellent substitute, with much more control over when input takes place. If you must use lazy text, see the Lazy module, which feeds lazy chunks to a regular parser.
18:45:53 <aristid> shachaf: so that sounds like it can stream input but not output, right?
18:45:58 <startling> shachaf, yes, doesn't that do what you want?
18:46:06 <startling> oh, you want streaming output?
18:46:53 <shachaf> Who knows what I want?
18:47:56 <startling> shachaf exists to h8
18:48:09 <shachaf> :-(
18:50:04 <Ralith> startling: I'm not sure 'streaming output' makes sense for a parser.
18:50:11 <Ralith> at least, for common usecases.
18:50:19 <Ralith> what use is an incomplete tree?
18:50:52 <Ralith> the case I more often find myself in is with a stream of discrete input blocks, each of which need to be parsed into an individual result
18:52:08 <startling> Ralith, well, you could have a list of top-level elements
18:57:06 <Ralith> startling: I was going to describe that as a case the aforementioned situation, but with things like module declarations, I can see how you'd still want a top-level parser there.
18:59:00 <shachaf> tibbe++ # cassava streaming
18:59:11 <tibbe> shachaf: :)
18:59:46 <shachaf> tibbe: So you went with a list-like thing that has extra things attached to the Nil
18:59:55 <tibbe> shachaf: yes
19:00:18 <shachaf> Is there an advantage of data Foo a = Cons a (Foo a) | Nil Blah over ([a], Blah)?
19:00:45 <shachaf> Such that you can force the Blah either when you're done going through the list or right at the beginning.
19:00:54 <shachaf> (Clearly it's not streaming if you do it at the beginning.)
19:02:13 * shachaf was just wondering a few days ago which approach was better.
19:03:25 <BrettB> heh. i figured this language was only a few years old at most since i only heard about it
19:03:34 <BrettB> didn't know it appeared in 1990
19:05:00 <shachaf> Why | Nil (Maybe String) ByteString rather than | Nil (Maybe (String,ByteString))?
19:05:13 <shachaf> Or equivalently | Success | Failure String ByteString
19:10:02 <copumpkin> True | False | FileNotFound
19:11:03 <startling> Either Bool ()
19:11:23 <shachaf> Either () ()
19:11:30 <liyang> Either (Either () ()) ()
19:12:09 <shachaf> Either () Void has the same number of inhabitants as data Foo = True | False | FileNotFound
19:12:16 <shachaf> Wait, no
19:12:20 <shachaf> I was right. Either () ()
19:12:30 <shachaf> No...
19:12:33 <shachaf> It's Either () Void
19:12:34 <startling> there's Left () and Right (), right?
19:12:43 <startling> what's Void?
19:12:43 <dibblego> Either () Void = 2
19:12:47 <dibblego> Either () () = 4
19:13:00 <liyang> No butts please.
19:13:09 <dibblego> Either () (Either () ()) = 3
19:13:13 <shachaf> ‚ä•, Left ‚ä•, Left (), Right ‚ä•
19:13:20 <shachaf> I count four.
19:13:23 <startling> shachaf: ah
19:13:36 <dibblego> I am excluding ‚ä•, sorry
19:14:43 <startling> dibblego: good for you, dude. stand up to the h8
19:14:55 <copumpkin> shachaf: are unobservable inhabitants inhabitants?
19:15:20 <otters> space aliens!
19:15:21 <shachaf> copumpkin knows when to call a spoon a spoon
19:15:29 <copumpkin> the spoon is a lie
19:15:47 <shachaf> copumpkin: Agreed.
19:15:54 <shachaf> If I'd taken spoon into account, there's be even more:
19:16:16 <shachaf> undefined, ‚ä•, Left undefined, Left ‚ä•, Left (), Right ‚ä•, Right undefined
19:19:13 <tibbe> shachaf: sorry, didn't see your message
19:19:21 <tibbe> shachaf: (Error, [a]) is really error prone
19:19:31 <tibbe> shachaf: it's easy for people to force the whole list by misstake
19:19:50 <tibbe> shachaf: Nil String ByteString because even if you hit an error you can have unconsumed input (in fact you most likely do)
19:20:20 <shachaf> tibbe: Right, but if you don't hit an error then presumably you've consumed everything?
19:20:25 <shachaf> tibbe: Hmm, I would see that as a convenience.
19:20:25 <Ralith> shachaf: and people worry about space usage in Haskell--look how many values you can cram into one place!
19:20:37 <tibbe> shachaf: yes
19:20:39 <latermuse> :D
19:20:46 <shachaf> I.e. with (Error, [a]) you can use it as streaming or as non-streaming and it works fine either way.
19:21:06 <tibbe> shachaf: there's already a non-streaming API (which returns Vector, which is much more efficient)
19:21:15 <shachaf> Good point.
19:21:30 <tibbe> shachaf: (String, [a]) needs a big documentation warning. Nil String doesn't
19:22:16 <shachaf> The list is really convenient, though. :-) Especially since you'll pretty likely be processing it as a list anyway.
19:22:21 <shachaf> But I see your point.
19:23:20 <tibbe> shachaf: use the Foldable instance
19:23:27 <tibbe> shachaf: it has a toList :)
19:23:40 <shachaf> Sure.
19:24:37 * shachaf wonders what the Foldable laws are, if any.
19:32:38 * shachaf wonders whether Foldable should export a DList-style toList
19:34:04 <shachaf> @let foo :: Fol.Foldable f => f a -> [a]; foo = ($ []) . appEndo . Fol.foldMap (\x -> Endo (x:))
19:34:05 <rwbarton> toDList?
19:34:05 <lambdabot>  <local>:12:8:
19:34:06 <lambdabot>      Not in scope: type constructor or class `Fol.Foldable'
19:34:06 <lambdabot>  
19:34:06 <lambdabot> ...
19:34:07 <rwbarton> toLists?
19:34:20 <shachaf> @let foo :: Foldable f => f a -> [a]; foo = ($ []) . appEndo . Data.Foldable.foldMap (\x -> Endo (x:))
19:34:21 <lambdabot>  <local>:12:8:
19:34:21 <lambdabot>      Not in scope: type constructor or class `Foldable'
19:34:21 <lambdabot>      P...
19:34:25 <shachaf> @let foo :: Data.Foldable.Foldable f => f a -> [a]; foo = ($ []) . appEndo . Data.Foldable.foldMap (\x -> Endo (x:))
19:34:28 <lambdabot>  Defined.
19:34:34 <shachaf> rwbarton: Well, it can just return a regular list.
19:34:46 <rwbarton> a DList result might be useful too
19:35:04 <rwbarton> I guess this is to magically make naive Foldable instances faster, though?
19:35:15 <rwbarton> at the cost of sharing, etc.
19:35:16 <shachaf> rwbarton: I wouldn't call those "na√Øve"
19:35:33 <shachaf> If you have a Foldable instance for a Tree, and you use First/Last, it'll only look at log(n) nodes.
19:35:39 <rwbarton> ah
19:35:43 <shachaf> But there's a cost when you use toList, unless you do something like this.
19:36:00 <rwbarton> well just because it is naive doesn't mean it can't also be useful :) but point taken
19:36:19 <shachaf> I think having the Foldable instance reflect the structure of the, uh, structure is generally a good idea.
19:36:41 <dibblego> Reducer praps
19:37:26 <shachaf> You can also get a reversed list just as easily as a regular list this way.
19:37:29 <shachaf> Or foldl/foldr/etc.
19:38:08 <dibblego> class Semigroup s => Reducer r s where unit :: r -> s
19:38:23 <shachaf> What's Reducer?
19:38:34 <dibblego> another of Ed's inventions
19:39:28 <shachaf> Hmm, http://hackage.haskell.org/packages/archive/monoids/0.2.0.2/doc/html/src/Data-Monoid-Reducer.html
19:39:35 <shachaf> Ralith: Is that related to what you were looking for?
19:39:47 <shachaf> Whoops, obsolete link.
19:39:50 <dibblego> Monoid constraint is wrong
19:40:00 <copumpkin> the monoids package is deprecated
19:40:15 <shachaf> Yes, http://hackage.haskell.org/packages/archive/reducers/3.0.0.1/doc/html/src/Data-Semigroup-Reducer.html
19:40:45 <lispy> johnw: pong
19:41:21 <copumpkin> lispy: pang
19:41:41 <shachaf>   snoc = flip . uncurry . IntMap.insertWith $ const id
19:41:49 <shachaf> Is it just me or is that definition a little too @pl-happy?
19:42:11 <shachaf> @unpl snoc = flip . uncurry . IntMap.insertWith $ const id
19:42:12 <lambdabot> snoc b c = uncurry (IntMap.insertWith (\ _ e -> e)) c b
19:42:55 <rwbarton> particularly as the order of the arguments of the argument to insertWith is not exactly obvious
19:43:14 <rwbarton> i like to write \new old -> ... or whichever way it goes to keep myself sane
19:43:37 <Ralith> shachaf: yes.
19:43:38 <Ralith> :D
19:44:03 <shachaf> In lens I wrote (\oldVal -> state (unconsWithDefault oldVal)) in one place.
19:44:19 <shachaf> edwardk will rue the day he gave me a commit bit.
19:44:29 <Ralith> so devious
20:26:36 * hackagebot Data-Hash-Consistent 0.1.1 - Provide a simple consistent hashing mechanism  http://hackage.haskell.org/package/Data-Hash-Consistent-0.1.1 (BradClawsie)
20:27:10 <tomberek> i've simplified the problematic program for http://hackage.haskell.org/trac/ghc/ticket/7429 and added some ddump-simpl Core outputs.  For some reason a StateT on top of ST and profiling is faster than without profiling or even ST itself !?
20:28:23 <johnw> tomberek: did you check use counts to make sure you're comparing apples with apples?
20:28:45 <tomberek> johnw: i might need some education,,, what do you mean use counts?
20:29:30 <johnw> if you have profiling enabled, running with -p -hc
20:29:39 <johnw> seeing how much memory is allocated, how much is CG'd
20:30:01 <johnw> make sure your 'faster' case is evaluating all that you need evaluated
20:30:24 <scooty-puff> is there anything significant about the fact Monoidal where (**) :: m a -> m b -> m (a, b) cannot be used to define fmap, but Applicative can do fmap f a = pure f <*> a?
20:30:32 <johnw> it's easy to write really, really fast Haskell programs; it's another thing to get them to do what you expect them to :)
20:31:01 <tomberek> johnw: ah yes, take a look at the trac,, there are GC differences, but not so much as to cause the difference.   The evaluation is the same
20:31:07 <edwardk> johnw: in my experience its easy to understand what they'll do, but not how long they'll take to run ;)
20:31:16 <johnw> scooty-puff: are you sure?  most definitions of Applicative use fmap to define <*>
20:32:04 <edwardk> scooty-puff: its just inconvenient. its like how you can use return and (>>=) to define fmap, but not return and join.
20:32:18 <edwardk> (>>=) already incorporates the 'fmap' like behavior before the join
20:32:32 <tomberek> johnw, edwardk: the confusing thing is that the profiling with the StateT on top of ST is FASTER than without profiling, and it's faster than using straight up ST with or without profiling
20:32:33 <edwardk> similarly (<*>) already incorporates some fmap like behavior
20:32:55 <edwardk> tomberek: hah
20:33:17 <tomberek> edwardk: http://hackage.haskell.org/trac/ghc/ticket/7429
20:33:36 <scooty-puff> k
20:34:40 <scooty-puff> i guess fewer methods may be nice, whatever that may be worth
20:37:00 <tomberek> johnw: i can't reinstall mtl without breaking things in my cabal hell... (i havn't grok'd cabal-dev yet)
20:37:52 <johnw> cabal-dev is just "cabal-dev install BLAH" in some empty directory
20:38:00 <johnw> there's nothing more to it than that
20:40:07 <tomberek> johnw, one sec...
20:40:09 <johnw> edwardk: I can define <*> with >>=, but not with fmap
20:40:22 <johnw> f <*> x = f >>= flip fmap x
20:40:28 <edwardk> @src ap
20:40:28 <lambdabot> ap = liftM2 id
20:40:33 <edwardk> :t liftM2 id
20:40:34 <tomberek> lol, can't install cabal-dev without breaking things!!! ouch
20:40:35 <lambdabot> Monad m => m (a2 -> r) -> m a2 -> m r
20:40:59 <johnw> that's just another verison of <*>
20:41:26 <johnw> so, how do you define THAT without >>=?
20:41:29 <edwardk> johnw: correct. just showing it to you. you can define (<*>) using >>= and return or (>>=) and fmap
20:41:37 <johnw> ah, ok
20:41:40 <johnw> just checking
20:41:58 <johnw> most implementors of <*> use pattern matching and (possibly) private data constructors
20:42:23 <johnw> there's no way to define it generically without invoking Monad
20:42:52 <johnw> or can I with the monoidal functor?
20:43:23 <sacundim> isn't <*> interdefinable with Applicative f => f a -> f b -> f (a, b)?  though yeah, interdefinable means you traded one problem for another
20:43:40 <johnw> sacundim: i think you're exactly right
20:43:58 <johnw> edwardk: what do lax, strong and strict mean, in regard to functors?
20:44:06 <lpvb> Why didn't ghc 7.6 make it into haskell platform 2012.4.0.0?
20:44:20 <johnw> lpvb: too many hackage packages still don't compile under 7.6
20:44:30 <johnw> makes for a bad initial user experience
20:44:31 <lpvb> that's what I suspected
20:44:51 <johnw> i still port packages and submit patches on a fairly regular basis
20:45:01 <lpvb> is there a group that is updating hackage to work with it?
20:45:08 <johnw> just all of us volunteers
20:45:09 <edwardk> yhttp://ncatlab.org/nlab/show/lax+functor
20:45:13 <johnw> if you see a package you want, port it, submit the patch
20:45:20 <johnw> i just fixed "hat" to work with 7.6
20:45:39 <shachaf> h√¢t
20:46:10 <shachaf> ƒ•√¢tÃÇ
20:46:14 <shachaf> "excessive?"
20:46:20 <latermuse> ha
20:46:27 <edwardk> strong functors give you strength. that is you can take something like (a, f b) -> f (a, b)  -- every functor in haskell is strong
20:47:19 <edwardk> when you have a strict functor it isn't that it maps isomorphic things to isomorphic things it maps actually equal things to actually equal things
20:47:32 <johnw> ok, thanks
20:49:03 <lispy> johnw: were you looking for me
20:49:05 <edwardk> lax replaces some isomorphisms with equivalences.
20:49:24 <johnw> lispy: do you have any interest in Coq?
20:49:29 <shachaf> strong LAX airport
20:49:37 * lispy tries to stop ranting on the Haskell IDE thread on reddit
20:49:40 <johnw> shachaf: it's at least strict thes edays
20:49:46 <tomberek> edwardk: you wrote mtl, i'm not finding the source for Strict StateT, hackage source says it's in Control.Monad.Trans.State.Strict, but i can't find that module
20:49:50 <johnw> lispy: link to rant?
20:50:00 <lispy> johnw: Are you asking if I'm a Coq lover?
20:50:03 * lispy giggles
20:50:12 <edwardk> i didn't write mtl, i just maintain it.
20:50:12 <lispy> johnw: I've looked at Coq, but never really used it
20:50:16 <jmcarthur> we've heard them all by now
20:50:21 <lispy> johnw: I'm trying to learn Agda/Idris
20:50:24 <edwardk> you want to look in the 'transformers' package for that
20:50:34 <jmcarthur> lispy: use it or lose it
20:50:35 <johnw> lispy: I found this today, thought you might be interested too: http://www.cs.berkeley.edu/~megacz/coq-categories/
20:50:41 <edwardk> Control.Monad.Trans.* is in transformers which is a package mtl depends on
20:50:48 <lispy> johnw: http://www.reddit.com/r/haskell/comments/13gn8k/designing_the_haskell_ide/c7424r2
20:51:08 <edwardk> transformers provides the data types, which can be provided in a haskell 98 fashion that mtl wraps with MTPCs, etc to make usable (which is not haskell 98)
20:51:16 <tomberek> edwardk, thanks!
20:51:17 <lispy> johnw: nice. Have you seen copumpkin's categories for agda?
20:51:25 <johnw> yes
20:51:28 <johnw> i have that downloaded too
20:51:40 <johnw> you can never have too many examples in this domain (no pun intended)
20:51:50 <lispy> johnw: the last time I spent any significant effort to learn CT or Agda I was doing it at the same time.
20:52:10 <johnw> i'm exploring CT ideas in Haskell right now, but maybe Agda would be better for that
20:52:26 <lispy> or Isabelle
20:52:30 <lispy> or epigram
20:52:34 <lispy> :)
20:52:49 <johnw> i would go for agda just because it's not *that* far away from Haskell
20:52:51 <lispy> Really, I think the important part is to pick *something* and go with it for a while
20:52:57 <johnw> it's close enough that edwardk is in that channel, which is extremely close
20:53:02 <lispy> idris is even closer to Haskell
20:53:10 <jmcarthur> the difference between agda and all those other dependently typed languages is that i've taken the time to become relatively comfortable with agda. therefore, agda is the best
20:53:15 <johnw> idris is also a bit too new
20:53:22 <jmcarthur> and agda isn't?
20:53:48 <lispy> emacs mode for proofs in Agda is pretty nice
20:54:01 <jmcarthur> yeah, the emacs mode is a huge selling point for agda
20:54:05 <johnw> yeah
20:54:06 <lispy> proof general can be nice, but it's huge and isabelle feels like it's hiding a lot
20:54:12 <johnw> i use Agda's input mode now in IRC :)
20:54:36 <lispy> johnw: does it follow that you have an emacs irc client? ERC?
20:54:45 <johnw> C·¥º·¥æ and C‚Éó are derivative categories for C :)
20:54:50 <johnw> yes, eRC
20:55:02 <edwardk> johnw: be careful, i lurk in #scala too =P
20:55:12 <johnw> jvm languages make me gag, to be honest
20:56:06 <copumpkin> johnw: gotta keep arrowing the arrow category
20:56:09 <copumpkin> until you can't stand it anymore
20:56:11 <johnw> i appreciate that they can make for impressively robust, long-running server processes
20:56:22 <jmcarthur> i'll be honest, i mostly say the jvm is awesome because that's what people tell me. i've never personally observed the awesomeness.
20:56:37 <Clint> what if we tell you that it's awful
20:56:37 <sacundim> the jvm isn't all that great
20:56:49 <johnw> but i'm not that kind of coder; I like lean executables, fast startup times, lots of parallelism
20:57:01 <jmcarthur> maybe i'm thinking of a particular implementation?
20:57:16 <sacundim> we've been fighting the Java 6 garbage collector very heavily at work for the past two months
20:57:43 <johnw> i'm on java 7 now, and i don't even know if that's a good thing
20:57:50 <sacundim> oh yes it is
20:58:00 <sacundim> i congratulate you on your great fortune
20:58:05 <jmcarthur> what, you mean you can't just use azule and solve all your problems magically?
20:58:11 <sacundim> we tried that
20:58:14 <jmcarthur> *azul?
20:58:28 <sacundim> java 7 was better enough than 6 to make azul not worth our time
20:58:33 <johnw> i only use the JRE, but i use it for a few things (CrashPlan, several user apps)
20:58:42 <sacundim> we did have azul's CTO come to our office and give us a presentation
20:58:57 <sacundim> it was a pretty awesome presentation, i must say, but java 7 is good enough, IMO
20:59:05 <sacundim> GC-wise
20:59:41 <sacundim> also, azul had this problem for a while where it required you to use a custom linux kernel, and it wouldn't fly with many IT departments
20:59:46 <sacundim> they did fix that, though
21:02:01 <lispy> johnw: I used ERC for a long time. I had to mod it heavily, but it was nice. I sometimes think about going back to it, but the reason I switched to irssi was emacs would end up using several hundred megs of ram when I'd leave it running for months at a time.
21:02:17 <lispy> johnw: I tried all the obvious stuff like log truncation, but something was still leaky
21:02:32 <johnw> ah, i reboot my main machine too often for that to be an issue
21:02:38 <johnw> and i run a second Emacs, dedicated to only eRC
21:03:28 <jmcarthur> it would never fly for me. i run a persistent irc session on my home theater system that i just ssh to occasionally
21:03:29 <lispy> I tend to have long running server side sessions in tmux
21:03:44 <jmcarthur> (yes... on my home theater system... problem?)
21:04:00 <johnw> ah
21:04:01 <lispy> lol on my home theater system, you mad?
21:04:08 <Jafet> IRC: better than the news
21:04:09 * lispy makes a troll face
21:04:30 <jmcarthur> Jafet: i don't irc on my tv!
21:04:50 <jmcarthur> but... i don't really use the tv for news either
21:04:56 <jmcarthur> mainly just for movies and games
21:05:09 <lispy> I was using a TV as my monitor for a while. On a 56" tv, minecraft blocks are bigger than your head when you're next to them :)
21:05:17 <deus_rex> why not use znc or something similar to persist your connection?
21:05:25 <lispy> znc?
21:05:35 <deus_rex> http://wiki.znc.in/ZNC
21:05:36 <jmcarthur> it's a kind of irc proxy, right?
21:05:40 <deus_rex> yes
21:05:52 <Ralith> lispy: only several hundred?
21:05:58 <jmcarthur> i've simply never tried it
21:06:06 * Ralith could lose several hundred MB in the cracks.
21:06:16 <Ralith> and this isn't even a high end system.
21:06:24 <lispy> Ralith: on a linode that has maybe 1GB of ram
21:08:01 <lispy> deus_rex: an irc proxy/bouncer thingy might be nice for some things, but a) I prefer console programs, b) wouldn't I need to install IRC clients on all the machines I use? (the machines I regularly use: work machine, personal laptop, personal desktop)
21:08:39 <lispy> Ralith: free is reporting less than 500 megs of ram right now but that can't be right
21:10:07 <Ralith> lispy: ah, cheap servers
21:10:33 <Ralith> lispy: wait, if you don't like bouncers, why were you running it on a linode?
21:11:07 <Ralith> oh, you prefer to ssh
21:11:08 <lispy> Ralith: my irc session is "in the cloud" this way. I just need an ssh client to reconnect.
21:11:13 <Ralith> right
21:12:09 <lispy> The one thing I'm missing out on with my current configuration is notifactions in the local OS
21:12:21 <jmcarthur> you can get that
21:12:27 <lispy> I know you can configure these tools to do that stuff, even over ssh, but I haven't configured it
21:13:08 <jmcarthur> i have urgency hints passing through weechat -> tmux -> ssh -> urxvt -> xmonad -> xmobar
21:13:36 <jmcarthur> it was indeed a pain to arrange
21:13:44 <jmcarthur> unicode seems to be even tougher though, actually
21:13:55 <jmcarthur> i set it up twice and it keeps disappearing
21:14:12 <tomberek> johnw: compiling with -prof -auto-all destroys the effect
21:14:28 <shachaf> jmcarthur: I bet you want to fix taking, right?
21:14:39 <spaceships> so you get xmobar notifications (on your laptop?) from your tv when someone private messages you?!?!
21:15:17 <jmcarthur> not from my tv. just an htpc
21:15:38 <jmcarthur> shachaf: i am having trouble parsing that sentence
21:15:51 <shachaf> @ty taking
21:15:53 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
21:16:07 <jmcarthur> i don't know lens enough yet
21:16:18 <jmcarthur> it's on my todo list, and that's all i've got
21:16:37 <johnw> tomberek: that might be telling you something
21:16:43 <edwardk> shachaf: wait, i outsourced it to you, now you're trying to outsource it again? =)
21:16:55 <jmcarthur> edwardk: to the wrong guy, even
21:16:57 <edwardk> at this rate it'll wind up being done by some guy on mechanical turk
21:16:58 <shachaf> edwardk: Isn't that how it works?
21:17:22 <shachaf> edwardk: If someone on mechanical turk does it correctly, I'll be delighted!
21:18:09 <tomberek> johnw: sure, that profiling is affecting the result, but the result is backwards.... profiling speeds up the computation, and it is the same computation. It's just running around a circular list of length 2. (effectively calculating odd/even)
21:18:38 <tomoj> with Reactive, how do you get (a -> Future b) -> Event a -> Event b ?
21:18:54 <johnw> tomberek: can you show me the code?
21:19:12 <lispy> tomberek: have you used something like ghc-core to look at the differences between the profiling and non-profiling builds?
21:19:19 <tomberek> http://hackage.haskell.org/trac/ghc/ticket/7429   (i just added a version that removed reliance on mtl)
21:19:21 <shachaf> jmcarthur: How about I explain lens to you and then you write taking?
21:19:27 <jmcarthur> lispy: would you expect the core to be different?
21:19:33 <edwardk> shachaf: hah
21:19:42 <jmcarthur> shachaf: i'm holding off for ed's nyc talk
21:19:58 <tomberek> lispy, Main.exe +RTS -s is SLOWER than Main.exe +RTS -s -h (no recompilaion needed).   The core is on the trac page
21:20:06 <lispy> jmcarthur: maybe not at the level of core, but I would expected one of the lower level representations to be different and ghc-core will show you core all the way down to asm
21:20:17 <shachaf> jmcarthur: Oh, right, you live in NYC.
21:20:18 <johnw> tomberek: how are you measuring speed?
21:20:36 <tomberek> +RTS -s and the timeit package
21:20:40 <edwardk> tomberek: its probably something where more aggressive inlining is happening without the profiling, and its causing a bad result for your pathological case where its cycling a list of 2 entries
21:20:45 <johnw> ah, timeit
21:20:49 <johnw> hadn't seen that one before
21:21:18 <johnw> tomberek: isn't your iterateM the same as replicateM?
21:21:31 <tomberek> edwardk: this started where it wasn't' 2 entries, but many more and not necessarily a circle
21:22:24 <tomberek> edwardk: i just simplified it for the trac
21:22:40 <johnw> :t replicateM
21:22:42 <lambdabot> Monad m => Int -> m a -> m [a]
21:22:49 <johnw> ah, not the same
21:23:21 <tomberek> johnw: close, and it seems like sequenceM and others are close, but I just want to do function (a -> m a) many times
21:24:02 <rwbarton> @type (>=>)
21:24:03 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
21:24:12 <johnw> you mean, like mconcat (replicate 5 f)
21:24:17 <johnw> :t mconcat (replicate 5 f)
21:24:19 <lambdabot> (Monoid a, FromExpr a) => a
21:24:20 <lispy> tomberek: a case where laziness is better?
21:24:40 <jmcarthur> so what is this iterateM?
21:24:51 <jmcarthur> oh nevermind, i see the link
21:24:52 <tomberek> lispy, i don't think so, but maybe
21:24:56 <lispy> tomberek: I ask because in the faster version there seems to be this: 0 -> (# w2_s1ne, (w_s1nc, w1_s1nd) #)
21:24:58 <johnw> mconcat on monadic functions uses <=<, I believe
21:25:01 <shachaf> edwardkL When's your NY talk?
21:25:10 <lispy> tomberek: in the ST case that looks: 0 -> (# w1_s1ld, w_s1lc #)
21:25:15 <tomberek> lispy, that extra w_s1nc is the Int in StateT
21:25:21 <johnw> :t mconcat (replicate 5 return)
21:25:23 <lambdabot> (Monad m, Monoid (m a)) => a -> m a
21:25:39 <lispy> tomberek: the second element of the (# #) tuple is lazy in the STO case.
21:25:40 <johnw> :t mconcat (replicate 5 (putStrLn "Hi"))
21:25:41 <lambdabot>     No instance for (Monoid (IO ()))
21:25:42 <lambdabot>       arising from a use of `mconcat'
21:25:42 <lambdabot>     Possible fix: add an instance declaration for (Monoid (IO ()))
21:25:45 <johnw> > mconcat (replicate 5 (putStrLn "Hi"))
21:25:47 <lambdabot>   No instance for (Data.Monoid.Monoid (GHC.Types.IO ()))
21:25:48 <lambdabot>    arising from a us...
21:25:51 <lispy> tomberek: I wonder if that makes any difference
21:25:57 <edwardk> shachaf: the 12th
21:26:03 <shachaf> Oh, that's a long time away.
21:26:09 <edwardk> yeah
21:26:20 <tomberek> lispy: shouldn't be an issue, because I never ask for the StateT value
21:26:23 <shachaf> I assume that means you haven't even started making the slides.
21:26:24 <shachaf> jmcarthur: Think of all the lensy goodness you'll be missing out on for almost a whole month!
21:26:41 <edwardk> they are the SF slides, alpha renamed and resized a bit to better fit the screen and target audience size
21:26:48 <jmcarthur> shachaf: i can't be too sad about not having something i know so little about
21:27:03 <tomberek> jmcarthur: that's just referring to a function I seem to keep having to write
21:27:04 <shachaf> edwardk: You should put them up!
21:27:10 <shachaf> jmcarthur: You'll be retroactively sad.
21:27:26 <edwardk> shachaf: i posted the old ones to bahaskell. i'll probably post these once i get closer to the talk or shortly thereafter
21:27:44 <shachaf> Fair enough.
21:27:51 <edwardk> i still need to go through the punchlines to these more or less by talking over the slides and they rely on me doing a bit of live demoing
21:28:22 <tomberek> johwn: what would the whole function look like with mconcat?
21:28:57 <edwardk> :t replicateM
21:28:58 <lambdabot> Monad m => Int -> m a -> m [a]
21:29:00 <tomberek> johns: nah, that won't order things
21:29:10 <edwardk> :t replicateM_
21:29:12 <lambdabot> Monad m => Int -> m a -> m ()
21:29:26 <edwardk> :t replicateM_ 5 (putStrLn "hi")
21:29:28 <lambdabot> IO ()
21:29:31 <johnw> > foldr (<=<) return (replicate 5 (\_ -> putStrLn "Hello")) $ ()
21:29:33 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
21:29:33 <lambdabot>    arising from a use of ...
21:29:38 <johnw> well, that works in my ghci
21:29:56 <edwardk> i'd recommend just using replicateM ;)
21:30:09 <johnw> yeah, but it's not the same as what he wants
21:30:13 <edwardk> :t sequence (replicate 5 (putStrLn "hi"))
21:30:15 <lambdabot> IO [()]
21:30:20 <edwardk> :t sequence_ (replicate 5 (putStrLn "hi"))
21:30:23 <lambdabot> IO ()
21:30:24 <johnw> he wants a an n-way composition of the same monadic function
21:30:31 <johnw> which will accept an argument
21:30:40 <edwardk> got it
21:30:42 <tomberek> edwardk: i just want to take a function (a -> m a) and compose it with itself n times to create a new (a -> m a) action
21:30:42 <shachaf> @ty putStrLn "hi_\nhi_\nhi_\nhi_\nhi_"
21:30:44 <lambdabot> IO ()
21:30:48 <alang> @hoogle (Integral c, Monad m) => c -> m a -> m [a]
21:30:49 <lambdabot> Control.Monad replicateM :: Monad m => Int -> m a -> m [a]
21:30:49 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
21:30:49 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
21:31:11 <jmcarthur> edwardk: what happened to your monoids package again? was it split up or simply destroyed?
21:31:24 <copumpkin> reducers ate some of it
21:31:28 <edwardk> look in reducers which basically subsumes it
21:31:30 <jmcarthur> reducers!
21:31:38 <copumpkin> the example reducers in the older versions of monoids are long-gone though
21:31:44 <copumpkin> like the compression ones and the UTF8 ones
21:31:49 <copumpkin> as far as I know
21:32:01 <edwardk> @hackage compressed
21:32:01 <lambdabot> http://hackage.haskell.org/package/compressed
21:32:07 <lispy> if foldM was a right fold you could implement it pretty easily
21:32:11 <edwardk> that has the LZ78 reducer
21:32:13 <lispy> :t fold
21:32:14 <lispy> :t foldM
21:32:14 <lambdabot>     Not in scope: `fold'
21:32:15 <lambdabot>     Perhaps you meant one of these:
21:32:15 <lambdabot>       `Data.Foldable.fold' (imported from Data.Foldable),
21:32:16 <lambdabot> Monad m => (a -> b -> m a) -> a -> [b] -> m a
21:32:22 <lispy> :t foldr
21:32:24 <lambdabot> (a -> b -> b) -> b -> [a] -> b
21:32:53 <edwardk> i don't have the parsing monads anywhere though, the UTF8 monad i never resurrected
21:33:01 <jmcarthur> i was actually just going to point to the generalized replicate function there and point out that it could be specialized for (a -> m a)
21:33:05 <edwardk> Delta wandered into trifecta
21:33:08 <tomberek> edwardk, lispy, johnw: I love the interateM sidebar (truly, I think there must be a canonical way that I missed), but the poor performance of ST and (StateT over ST without profiling) compared to (StateT over ST with profiling) is still very confusing to me.
21:33:18 <jmcarthur> reducers seems to lack it, or at least i haven't found it
21:33:40 <johnw> we grappled onto the simlper problem ):
21:33:44 <shachaf> Generalized replicate function?
21:34:02 <edwardk> jmcarthur: yeah i don't have a GEndo in there
21:34:04 <shachaf> For an arbitrary monoid using repeated squaring?
21:34:16 <shachaf> Well, that's not really replicate.
21:34:16 <lispy> tomberek: indeed. I think the point of the sidebar is to reduce this to as small and as canonical example as possible
21:34:25 <edwardk> you can of course use just normal Endo (m a -> m a) by using Endo (>>= f)
21:34:30 <edwardk> :t \f -> Endo (>>= f)
21:34:32 <lambdabot> Monad m => (a -> m a) -> Endo (m a)
21:34:33 <jmcarthur> i think i also misremember some of the functions
21:34:41 <tomberek> lispy: i'd love to, but I was stumped, so I wrote it the way you see
21:34:45 <shachaf> @ty \f -> Endo (f >=>)
21:34:47 <jmcarthur> replicate indeed seems odd
21:34:47 <lambdabot> Monad m => (b -> m b) -> Endo (b -> m c)
21:35:11 <tomberek> lispy: plus this way had better memory characteristics
21:35:13 <lispy> tomberek: I'm currently leaning towards edwardk's pet theory. Might be interesting to ask ghc which rewrite rules are firing (or inlining) and see the difference between the fast and slow versions
21:36:03 <tomberek> lispy: no no,, I compile,,, I run with +RTS -s and it takes 3 seconds...  WITHOUT recompiling i then run +RTS -s -h and it takes 2.6 seconds
21:36:11 <jmcarthur> shachaf: http://hackage.haskell.org/packages/archive/monoids/0.3.2/doc/html/Data-Monoid-Combinators.html
21:36:21 <jmcarthur> but it occurs to me that that isn't quite replicate
21:36:22 <tomberek> the rules firing etc are identical because I use the same executable
21:36:42 <lispy> tomberek: oh. I didn't realize that before.
21:36:52 <jmcarthur> to be replicate it would need to be something like...    replicate :: Monoid a => Int -> Elem a -> a
21:36:58 <shachaf> jmcarthur: OK, that's what I said, then.
21:37:00 <edwardk> :t \f -> mconcat (replicate 5 (Endo (>>= f)))
21:37:02 <lambdabot> Monad m => (a -> m a) -> Endo (m a)
21:37:11 <edwardk> :t \f -> appEndo (mconcat (replicate 5 (Endo (>>= f))))
21:37:13 <lambdabot> Monad m => (a -> m a) -> m a -> m a
21:37:22 <tomberek> lispy: no prob, but that's what boggles my mind, why would running with profiling speed up an already compiled program?
21:37:25 <edwardk> :t \f -> appEndo (mconcat (replicate 5 (Endo (>>= f)))) . return
21:37:27 <lambdabot> Monad m => (a -> m a) -> a -> m a
21:37:28 <shachaf> Hmm, can replicated in lens do this?
21:37:33 <rwbarton> shouldn't you be alaing something
21:37:41 <copumpkin> ala was stolen
21:37:41 <edwardk> shachaf: probably
21:37:52 <edwardk> :t Endo (>>= f)^.replicated 5
21:37:54 <lambdabot> (Monad m, Show a, FromExpr (m a)) => Endo (m a)
21:37:58 <shachaf> edwardk: Would that be an improvement?
21:38:00 <edwardk> :t \f -> Endo (>>= f)^..replicated 5
21:38:02 <lambdabot> Monad m => (a -> m a) -> [Endo (m a)]
21:38:10 <edwardk> :t \f -> Endo (>>= f)^.replicated 5
21:38:12 <lambdabot> Monad m => (a -> m a) -> Endo (m a)
21:38:14 <jmcarthur> :t ala
21:38:16 <lambdabot> Simple Iso s a -> ((s -> a) -> e -> a) -> e -> s
21:38:25 <lispy> tomberek: I think to understand this I would have to know more about the code paths that the RTS takes in those two modes.
21:38:35 <jmcarthur> oh hey there's a thing called ala that doesn't look at all like the ala i'm familiar with
21:38:40 <copumpkin> yeah
21:38:41 <lispy> tomberek: Perhaps there is something related to thunk evaluation that differs between them
21:38:44 <copumpkin> edwardk stole it
21:38:51 <johnw> watching edwardk evolving a lens usage is... unnerving
21:38:55 <shachaf> jmcarthur: lens obsoletes newtype
21:38:58 <shachaf> And uniplate
21:39:02 <shachaf> And zippo
21:39:08 <jmcarthur> so i've heard
21:39:13 <shachaf> And, uh, a bunch of other things?
21:39:13 <edwardk> :t \f -> Endo (>>= f)^.replicated 5.to (return . appEndo)
21:39:14 <rwbarton> it is actually sane
21:39:15 <lambdabot> (Monad m1, Monad m, Monoid (m1 (m a -> m a))) => (a -> m a) -> m1 (m a -> m a)
21:39:22 <edwardk> :t \f -> Endo (>>= f)^.replicated 5.to (appEndo)
21:39:24 <lambdabot> (Monad m, Monoid (m a)) => (a -> m a) -> m a -> m a
21:39:25 <shachaf> What else does it obsolete?
21:39:38 <johnw> edwardk: i'm going to go with suggesting the foldr approach on this one... :)
21:39:43 <edwardk> :t \f -> (Endo (>>= f)^.replicated 5.to (appEndo)) . return
21:39:45 <lambdabot> (Monad m, Monoid (m a)) => (a -> m a) -> a -> m a
21:39:50 <edwardk> :t \f -> (Endo (>>= f)^.replicated 5.to appEndo) . return
21:39:52 <lambdabot> (Monad m, Monoid (m a)) => (a -> m a) -> a -> m a
21:40:00 <edwardk> :t \f -> Endo (>>= f)^.replicated 5.to appEndo.return
21:40:02 <lambdabot>     Couldn't match expected type `Accessor a0 (m0 a1 -> m0 a1)'
21:40:03 <lambdabot>                 with actual type `a0 -> Accessor a0 b0'
21:40:03 <lambdabot>     Expected type: (a0 -> Accessor a0 b0)
21:40:05 <tomberek> lispy: perhaps, i also don't know much about RTS, but run it without RTS it's SLOWER than +RTS -s -h
21:40:08 <edwardk> :t \f -> (Endo (>>= f)^.replicated 5.to appEndo).return
21:40:10 <lambdabot> (Monad m, Monoid (m a)) => (a -> m a) -> a -> m a
21:40:11 <lispy> tomberek: how do you measure the runtime, with the time command?
21:40:16 <edwardk> now to see if we can ala our way through it ;)
21:40:18 <johnw> that's it!
21:40:39 <tomberek> lispy: i use-s and the timeIt from the timeIt package
21:40:50 <edwardk> :t \f -> appEndo (Endo (>>= f)^.replicated 5) . return
21:40:52 <lambdabot> Monad m => (a -> m a) -> a -> m a
21:40:58 <edwardk> hats the one you want
21:41:09 <edwardk> :t ala _endo
21:41:10 <shachaf> edwardk: Any reason for replicated not to do repeated squaring?
21:41:11 <lambdabot> (((b -> b) -> Endo b) -> e -> Endo b) -> e -> b -> b
21:41:11 <lispy> tomberek: humor me and use /usr/time on the two runs?
21:41:12 <tomberek> edwardk: one sec.....
21:41:21 <edwardk> :t ala _endo foldMap
21:41:22 <rwbarton> :t Endo
21:41:23 <lambdabot>     Not in scope: `foldMap'
21:41:23 <lambdabot>     Perhaps you meant one of these:
21:41:23 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
21:41:24 <lambdabot> (a -> a) -> Endo a
21:41:28 <tomberek> lispy (windows.... )
21:41:34 <shachaf> @ty ala _endo (foldMapOf folded)
21:41:36 <rwbarton> is there an Arrow-y Endo?
21:41:36 <lambdabot> Data.Foldable.Foldable f => f (b -> b) -> b -> b
21:41:44 <edwardk> rwbarton: i used to have one
21:41:45 <rwbarton> or Category-y
21:41:46 <lispy> tomberek: likewise at the moment :(
21:41:48 <rwbarton> rather
21:42:24 <jmcarthur> ... base doesn't have a newtype for this?     newtype CategoryMonoid a b = CategoryMonoid (a b b); instance Category a => Monoid (CategoryMonoid a b)
21:42:32 <tomberek> edwardk: where does appEndo come from?
21:42:39 <rwbarton> @quote appendo
21:42:40 <lambdabot> hpc says: appEndo sounds like a harry potter spell
21:42:40 <shachaf> tomberek: Same place as Endo. Data.Monoid
21:42:48 <edwardk> @src Endo
21:42:48 <lambdabot> Source not found. Sorry.
21:42:59 <shachaf> newtype Endo a = Endo { appEndo :: a -> a }
21:43:02 <edwardk> newtype Endo a = Endo { appEndo :: a -> a }
21:43:50 <shachaf> jmcarthur: Doesn't look like it.
21:43:52 <edwardk> had i been smart and just defined 'times' for monoid like i define times1p for semigroup i'd be all set =P
21:44:05 <edwardk> i had it in monoids but it got lost in reducers
21:44:16 <tomberek> @src (^.)
21:44:17 <lambdabot> Source not found. Wrong!  You cheating scum!
21:44:22 <jmcarthur> shachaf: would have been a straightforward way to define iterateM with mostly newtype boilerplate
21:44:41 <jmcarthur> via Kleisli
21:45:26 <tomberek> @src ^.
21:45:27 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
21:46:26 <edwardk> a ^. l = getConst (l Const a)
21:46:42 <edwardk> :t \a l -> getConst (l Const a)
21:46:44 <lambdabot> t -> ((a1 -> Const a1 b1) -> t -> Const a b) -> a
21:46:55 <edwardk> (its actually a bit uglier internally, but thats close enough)
21:47:10 <edwardk> > ("hello","world")^._2
21:47:12 <tomberek> edwardk, shachaf; frankly, when the spelled out version is more complex and has more dependencies than mine, i don't see the point of using the complex one
21:47:13 <lambdabot>   "world"
21:47:14 <jmcarthur> @djinn \a l -> getConst (l Const a)
21:47:14 <lambdabot> Cannot parse command
21:47:22 <jmcarthur> derp
21:47:25 <jmcarthur> @pl \a l -> getConst (l Const a)
21:47:25 <shachaf> tomberek: Spelled out version of what?
21:47:26 <lambdabot> (getConst .) . flip ($ Const)
21:47:33 <edwardk> tomberek: its mostly more interesting for us to golf. not a practical solution to your issue =P
21:47:37 <jmcarthur> that's worse than i thought it would be
21:47:57 <shachaf> @pl \l a -> getConst (l Const a)
21:47:58 <lambdabot> (getConst .) . ($ Const)
21:47:58 <edwardk> view l = getConst . l Const
21:48:03 <edwardk> is the flipped form
21:48:17 <tomberek> edwardk, shachaf; got it,, the golf is fun for an exercise, but perhaps iterateM should make it into Control.Monad ?
21:48:19 <shachaf> view is simple enough.
21:49:04 <edwardk> :t \  l f -> runIdentity . l (Identity . f)
21:49:05 <rwbarton> foldr (>=>) return . replicate n is simple enough
21:49:06 <lambdabot> (Functor f1, Functor f) => (f1 (Identity a) -> f (Identity b)) -> f1 a -> f b
21:49:22 <edwardk> :t iterate
21:49:24 <lambdabot> (a -> a) -> a -> [a]
21:49:47 <edwardk> so you want (a -> m a) -> a -> m [a] ? if not its not iterateM =P
21:49:59 <edwardk> that sounds remarkably impossible =P
21:50:23 <shachaf> What if it's (m a -> m a) -> m (a -> m [m a])?
21:50:32 <shachaf> Whoops, missed an m
21:51:05 <edwardk> (m a -> m a) -> mi a, m a -> m a, mia, let me go, beelzebub has a devil set aside for ...
21:51:22 <tomberek> hehe
21:52:42 <edwardk> anyways my point is the M suffix has a pretty strict interpretation that is documented in Control.Monad that this proposed function doesn't match
21:53:11 <edwardk> ou might petition to get something added, but thats a great way to have something you might be able to use .. in a year.
21:53:13 <tomberek> edwardk: perhaps iterateM should be (a -> m a) -> a -> [m a]     and then you can do     (iterateM f init) !! n
21:53:52 <jmcarthur> yeah i guess that actual intended type is not iterateM after all
21:54:02 <tomberek> edwardk: let me go read Control.Monad 'M' usage........
21:54:12 <edwardk> tomberek: the issue is that that isn't what it should mean. A postfix 'M' always stands for a function in the Kleisli category: The monad type constructor m is added to function results (modulo currying) and nowhere else.
21:54:14 <tomberek> jmcarthur, I'm am very open to suggestions
21:54:19 <edwardk>   filter  ::              (a ->   Bool) -> [a] ->   [a]
21:54:19 <edwardk>   filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
21:54:23 <jmcarthur> :t \f -> let g = g <=< f in g
21:54:25 <lambdabot> Monad m => (b -> m b) -> b -> m c
21:54:30 <jmcarthur> hmm
21:54:30 <tomberek> edwardk: ditto, i'm open to a different name
21:54:41 <jmcarthur> that makes sense because i don't know when to stop it otherwise anyway
21:54:58 <edwardk> that convention is adhered to in Control.Monad pretty religiously ;)
21:55:53 <jmcarthur> ah, it goes for a certain number of iterations
21:56:00 <edwardk> and i'm not sure what you'd call it. you can't prefix it with an m or end it with M, and any other name will get bikeshredded
21:56:44 <edwardk> fear the bikeshredder
21:57:07 <jmcarthur> i still think http://hackage.haskell.org/packages/archive/monoids/0.3.2/doc/html/Data-Monoid-Combinators.html#v:replicate seems the most reasonable, if only we had the appropriate newtypes
21:57:30 <tomberek> edwardk: sorry for my ignorance, but the iterateM doesn't seem too far off from filterM, or is this a case of "looks close, but not close enough"
21:57:35 <edwardk> jmcarthur: that would be 'times' under the current parlance of semigroups, etc.
21:58:10 <edwardk> tomberek: it isn't a kleisli m on the result. the docs for what is allowed to use the M suffix in Control.Monad rule that out.
21:58:26 <edwardk> its a case of looks close but not close enough
21:58:31 <rwbarton> @type iterate (>>= ?f) (return ?x) !! ?n
21:58:33 <lambdabot> (?f::a -> m a, ?x::a, ?n::Int, Monad m) => m a
21:59:05 <edwardk> rwbarton's solution is pretty good
21:59:32 <yitz> @pl \f x -> iterate (>>= f) $ return x
21:59:33 <lambdabot> (. return) . iterate . (=<<)
21:59:50 <jmcarthur> :t foldr (<=<) return $ replicate ?n f
21:59:51 <lambdabot> (?n::Int, Monad m, Show b, FromExpr (m b)) => b -> m b
22:00:04 <jmcarthur> FromExpr?
22:00:07 <jmcarthur> oh
22:00:09 <jmcarthur> :t foldr (<=<) return $ replicate ?n ?f
22:00:10 <lambdabot> (?n::Int, ?f::b -> m b, Monad m) => b -> m b
22:00:47 <stepkut> I have some Text (currently strict) and I want to apply one or more transformers of type (Text -> IO Text) to it. But I am wondering.. should I maybe be using, Text -> IO Builder?
22:00:54 <tomberek> @src iterate
22:00:55 <lambdabot> iterate f x =  x : iterate f (f x)
22:01:07 <tomberek> @type iterate
22:01:09 <lambdabot> (a -> a) -> a -> [a]
22:01:55 <jmcarthur> :t (fmap.fmap) (foldr (<=<) return) replicate
22:01:56 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
22:02:07 <tomberek> !!
22:02:23 <jmcarthur> aka:
22:02:35 <jmcarthur> :t foldr (<=<) return .: replicate
22:02:37 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
22:03:34 <shachaf> > length . show . getProduct $ Product 2 ^. replicated 1000000
22:03:37 <lambdabot>   *Exception: stack overflow
22:03:39 <shachaf> > length . show . getProduct $ Product 2 ^. replicated 100000
22:03:42 <lambdabot>   30103
22:03:47 <shachaf> > length . show $ product (replicate 100000 2)
22:03:50 <lambdabot>   30103
22:03:51 <shachaf> > length . show $ product (replicate 1000000 2)
22:03:53 <lambdabot>   *Exception: stack overflow
22:04:11 <shachaf> > length . show $ replicate 1000000 2
22:04:14 <lambdabot>   2000001
22:04:17 <shachaf> Um.
22:04:23 <shachaf> > length . show $ 2 ^ 1000000
22:04:26 <lambdabot>   301030
22:04:43 <tomberek> jmcarthur: would using that version be any better than my low-golf-score version? better optimization, fusion, rule firings?
22:05:32 <jmcarthur> tomberek: not that i'm aware of
22:05:50 <tomberek> jmcarthur: just tested it, you run out of stack space
22:05:54 <tomberek> arg!
22:05:57 <jmcarthur> amazing
22:06:05 <tomberek> mine doesn't, no matter what n is
22:06:06 <jmcarthur> that, i did not really expect
22:06:14 <jmcarthur> oh
22:06:26 <jmcarthur> i think i see why
22:06:37 <shachaf> What's being tested here?
22:06:38 * hackagebot haskelldb-connect-hdbc-catchio-tf 0.1.0.0 - Bracketed HaskellDB HDBC session using MonadCatchIO-transformers  http://hackage.haskell.org/package/haskelldb-connect-hdbc-catchio-tf-0.1.0.0 (KeiHibino)
22:06:46 <jmcarthur> my buggy version
22:06:52 <shachaf> Of what?
22:06:59 <jmcarthur> :t (fmap.fmap) (foldr (<=<) return) replicate
22:07:01 <lambdabot> Monad m => Int -> (b -> m b) -> b -> m b
22:07:05 <jmcarthur> his iterateM function
22:07:42 <jmcarthur> :t (fmap.fmap) (foldr (>=>) return) replicate
22:07:43 <lambdabot> Monad m => Int -> (c -> m c) -> c -> m c
22:07:53 <jmcarthur> tomberek: does that one stack overflow?
22:08:00 <tomberek> one sec
22:08:10 <jmcarthur> (again, i doubt you will see any performance improvements from this...)
22:08:21 <shachaf> (fmap.fmap)?
22:08:24 <tomberek> that's the one i tested, you have another?
22:08:25 <shachaf> You're basically already using lenses.
22:08:32 <jmcarthur> tomberek: my last one is different
22:08:34 <jmcarthur> shachaf: yeah yeah
22:08:45 <jmcarthur> tomberek: (>=>) instead of (<=<)
22:08:46 <edwardk> fmap.fmap is a semantic editor combinator. thats just a crappy setter :0
22:08:49 <edwardk> :t sets (fmap.fmap)
22:08:50 <lambdabot> (Functor f2, Functor f1, Settable f) => (a -> f b) -> f1 (f2 a) -> f (f1 (f2 b))
22:09:02 <shachaf> @ty sets (mapped.mapped)
22:09:03 <lambdabot> (Functor f3, Functor f1, Settable f2, Settable f) => (a -> f (f2 b)) -> f1 (f3 a) -> f (f2 (f1 (f3 b)))
22:09:06 <shachaf> Er.
22:09:14 <shachaf> @ty over (sets (fmap.fmap))
22:09:15 <edwardk> :t over (mapped.mapped)
22:09:15 <tomberek> wow,, wait, one sec
22:09:16 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:09:17 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
22:09:19 <shachaf> @ty (over.sets)
22:09:21 <lambdabot> ((a -> b) -> s -> t) -> (a -> b) -> s -> t
22:09:28 <edwardk> over.sets = id
22:09:32 <shachaf> Let's see whether GHC optimizes it to id!
22:09:33 <edwardk> :t sets.over
22:09:35 <lambdabot> Settable f => Setting s t a b -> (a -> f b) -> s -> f t
22:09:42 <edwardk> = id
22:09:49 <jmcarthur> you lens people are out of control
22:09:56 <otters> no kidding
22:09:57 <copumpkin> yeah, get a room
22:09:59 <copumpkin> wtf
22:10:15 <edwardk> jmcarthur: i'll take that as a compliment ;)
22:10:31 <edwardk> and actually, as rwbarton pointed out, lens is in Control.
22:10:38 <pqmodn> haha
22:10:41 <mgsloan> lmao
22:10:44 <tomberek> jmcarthur: edwardk:    jmcarthur's last version works perfectly, and interestingly, it destroys the "profiling-increases-performance" effect...
22:10:51 <jmcarthur> edwardk: i facepalmed so hard that i scared the crap out of my cat
22:10:58 <tomberek> jmcarthur: but it's slower, not faster
22:11:02 <shachaf> edwardk: Hey, it compiles "foo = over.sets" to "foo x y = x y"
22:11:09 * shachaf considers this a success.
22:11:12 <edwardk> shachaf: good =)
22:11:24 <mgsloan> I think that's HWN-quote worthy if anything is
22:11:31 <tomberek> the profiling (+RTS -s -h) doesn't give the same speed boost to jmcarthur's version of iterateM
22:13:33 <shachaf> over' :: Setting s t a b -> (a -> b) -> s -> t
22:13:33 <shachaf> over' = unsafeCoerce
22:14:02 <edwardk> shachaf: =P
22:14:13 <tomberek> jmcarthur, this just got more interesting,,, please check out http://hackage.haskell.org/trac/ghc/ticket/7429  your version of iterateM destroys the effect, but is only as fast as the non-profiling or just-ST version
22:14:20 <shachaf> hi mgsloan
22:14:38 <edwardk> @quote Control
22:14:39 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
22:14:44 <edwardk> @quote rwbarton
22:14:44 <lambdabot> rwbarton says: when you learn C, watch out for the keyword "return", it doesn't do what you'd expect
22:14:50 <edwardk> hrmmph
22:14:54 <edwardk> @quote rwbarton.*Control
22:14:55 <mgsloan> hey shachaf! Y'all have been busy on the lens front, good work! :D
22:14:55 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
22:14:56 <shachaf> @quote rwbarton Control
22:14:57 <lambdabot> rwbarton says: edwardk now has Lens under Control
22:15:04 <edwardk> ah there it is
22:15:19 <shachaf> mgsloan: Yall? I thought that was deprecated.
22:15:22 <jmcarthur> tomberek: i'm not too surprised that small differences in the code can make the issue disappear
22:15:42 <shachaf> mgsloan: edwardk was talking about integrating lenq the other day.
22:15:45 <mgsloan> shachaf: Not in the south
22:15:53 <jmcarthur> not here in nyc, even'
22:15:56 <jmcarthur> *even
22:16:03 <jmcarthur> i've heard it as much here as i did in alabama
22:16:06 <tomberek> jmcarthur: but makes it disappear in the wrong way, it's still slower by a significant percentage with your version
22:16:13 <edwardk> at least the lense stuff from lenq
22:16:15 <mgsloan> shachaf: oh yeah?  Cool!  I need to get back to it..  Been pretty busy lately
22:16:20 <jmcarthur> tomberek: i expected that. i doubt the list stuff is optimized away at all
22:16:22 * shachaf was talking about the lens library. :-(
22:16:33 <mgsloan> shachaf: I know :D
22:16:52 <jmcarthur> tomberek: or if it is, then the (<=<) is probably affecting things a bit
22:16:56 <jmcarthur> err... (>=>)
22:17:05 <jmcarthur> anyway, i'm off to bed
22:17:22 <mgsloan> I thought Y'all was a cool idea back when I was doing the predecessor of lenq
22:17:25 <tomberek> jmcarthur: nope, yours is exactly as fast and compiles to same as mine with ST or without profiling
22:17:39 <jmcarthur> :o
22:17:42 <tomberek> jmcarthur: thanks, good night
22:18:02 <mgsloan> edwardk: I still haven't figured out the right approach for traversals
22:18:40 <edwardk> hence why i'm tempted to just polish up lense and call it good for now
22:18:59 <edwardk> otoh, to be honest, it hasn't been that hard writing lenses the long way
22:19:23 <shachaf> edwardk: If you don't have traversals, then you don't get the advantage of setting multiple fields and changing the type, do you?
22:19:31 <mgsloan> yeah, I actually think that the full on declaration lenq is the more useful part, due to writing recursive lenses 'n such
22:19:40 <edwardk> shachaf: point
22:19:48 <mgsloan> we should make sure that the generated code for such recursive lenses is as efficient as possible, though
22:20:09 <shachaf> What's a recursive lenses?
22:20:34 <mgsloan> shachaf: for example, a lens for "last"
22:20:37 <edwardk> shachaf: well, no. you can still do \ (Foo x y z) -> (x,y)   -- and update multiple fields
22:20:58 <edwardk> they just aren't traversed
22:21:28 <shachaf> Oh, a lens onto a tuple.
22:22:14 <shachaf> I guess that's just isomorphism.
22:22:57 <mgsloan> lastLens f [x] = (:[]) <$> f x;   lastLens f (_:xs) = lastLens f xs
22:23:09 <mgsloan> I guess writing this isn't really too bad
22:23:21 <mgsloan> yeah, maybe more than lense is overkill?
22:23:27 <shachaf> mgsloan: (_:xs)?
22:23:28 <edwardk> the declaration form of the lenq dsl still makes me a little queasy
22:23:36 <edwardk> the lense stuff is easy to sell
22:23:40 <shachaf> Not (x:xs) = (x:) <$> ... or something?
22:24:10 <mgsloan> edwardk: would it make you less queasy if it didn't use type sigs for TH dispatch? :P
22:24:40 <edwardk> mgsloan: a little. i'd still be pretty queasy though =P
22:24:45 <mgsloan> thing is that I think a good deal of the benefit comes from being able to write multi-case lenses
22:25:06 <mgsloan> and having them actually be checked for lens properties (mostly TODO)
22:25:43 <mgsloan> upcoming four day weekend =D  could be a good time to make it happen
22:25:59 <shachaf> mgsloan: Oh, I bet you feel like fixing taking.
22:26:01 <shachaf> Right?
22:26:10 <shachaf> Can't have another release until taking is fixed.
22:27:25 <mgsloan> 'struth
22:28:06 <shachaf> Should cycled be INLINE?
22:28:41 <rants> does it matter?
22:29:13 <shachaf> Well, everything else in the module is.
22:30:52 <edwardk> shachaf: let me go look at it and see if i remember why i didn't
22:31:10 <edwardk> yeah it should
22:31:36 <edwardk> > [1,2,3]^..cycled
22:31:38 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Accessor
22:31:39 <lambdabot>               ...
22:31:46 <edwardk> :t cycled
22:31:48 <lambdabot> (Applicative f, Gettable f) => LensLike f s t a b -> LensLike f s t a b
22:31:58 <edwardk> :t [1,2,3]^..cycled folded
22:32:00 <lambdabot> Num t => [t]
22:32:05 <edwardk> > [1,2,3]^..cycled folded
22:32:08 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
22:32:14 <edwardk> > [1..]^..cycled (taking 2)
22:32:16 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Accessor
22:32:16 <lambdabot>               ...
22:32:21 <edwardk> > [1..]^..cycled (taking 2 folded)
22:32:24 <lambdabot>   *Exception: stack overflow
22:32:30 <shachaf> :-(
22:32:43 <edwardk> oh this is the old taking anyways
22:32:47 <shachaf> Yes.
22:32:50 <edwardk> but that doesn't help with folded
22:34:25 <shachaf> Well, I had a taking that worked with folded once, I think.
22:34:32 <shachaf> But it was broken for traversing.
22:35:00 <shachaf> review?
22:35:04 <shachaf> wfm
22:35:17 <edwardk> it sounds like view, its backwards looking is ;)
22:35:19 <edwardk> er ish
22:35:53 <shachaf> A fold is allowed to change the number of elements, right?
22:35:58 <edwardk> sure
22:36:07 <edwardk> > 5^.replicated 3
22:36:10 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:36:10 <lambdabot>    (GHC.Num.Num a0)
22:36:10 <lambdabot>      a...
22:36:11 <edwardk> > 5^..replicated 3
22:36:13 <shachaf> Can cycled etc. be written to do that?
22:36:13 <lambdabot>   [5,5,5]
22:36:23 <edwardk> it does
22:36:33 <shachaf> I mean, folded.cycled
22:36:33 <edwardk> > [1,2,3]^.cycled folded
22:36:36 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:36:36 <shachaf> Instead of cycled folded
22:36:36 <lambdabot>    (GHC.Num.Num a0)
22:36:36 <lambdabot>      a...
22:36:37 <edwardk> > [1,2,3]^..cycled folded
22:36:39 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
22:36:48 <shachaf> > "abc"^..folded.cycled
22:36:50 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Accessor
22:36:51 <lambdabot>               ...
22:37:00 <edwardk> hat doesn't work because i can't generate the answers out of order like that
22:37:05 <edwardk> they'd all have to be adjacent
22:37:18 <shachaf> > [1,2,3,4]^..folded.filtered even
22:37:21 <lambdabot>   [2,4]
22:37:29 <shachaf> Ah, because you get them in order.
22:37:40 <edwardk> yep
22:37:41 <shachaf> And you can only do simple things at any particular point.
22:37:51 <edwardk> think nested loops
22:37:51 <johnw> > [1,2,3,4]^..filtered even
22:37:53 <lambdabot>   No instance for (GHC.Real.Integral [t0])
22:37:53 <lambdabot>    arising from a use of `e_11234'...
22:38:04 <edwardk> :t filtered
22:38:06 <lambdabot> Applicative f => (a -> Bool) -> SimpleLensLike f a a
22:38:10 <edwardk> > 2^.filtered even
22:38:12 <lambdabot>   Ambiguous type variable `a0' in the constraints:
22:38:12 <lambdabot>    (GHC.Real.Integral a0)
22:38:12 <lambdabot> ...
22:38:13 <edwardk> > 2^..filtered even
22:38:14 <johnw> those types don't really help me atm
22:38:16 <lambdabot>   [2]
22:38:21 <edwardk> > 2^..filtered odd
22:38:21 <johnw> > [1,2,3,4]^.filtered even
22:38:23 <lambdabot>   No instance for (GHC.Real.Integral [t0])
22:38:23 <lambdabot>    arising from a use of `e_11234'...
22:38:24 <lambdabot>   can't find file: L.hs
22:38:31 <edwardk> filtered works on one element
22:38:39 <Nereid> > 2^?filtered odd
22:38:42 <edwardk> you compose it with traverse or filter
22:38:42 <lambdabot>   Nothing
22:38:52 <shachaf> johnw: You need to have a "cursor" on a particular element, or N elements, before you can use filtered.
22:38:55 <edwardk> > 2^> filtered even
22:38:57 <lambdabot>   Not in scope: `^>'
22:38:57 <lambdabot>  Perhaps you meant one of these:
22:38:57 <lambdabot>    `^' (imported from P...
22:39:00 <edwardk> > 2^? filtered even
22:39:02 <lambdabot>   Just 2
22:39:11 <shachaf> traverse :: SimpleTraversal [Int] Int
22:39:20 <shachaf> (traverse.traverse) :: SimpleTraversal [[Int]] Int
22:39:21 <edwardk> > [1,2,3,4]^..traverse
22:39:24 <lambdabot>   [1,2,3,4]
22:39:26 <johnw> shachaf: ah, ok
22:39:27 <edwardk> > [1,2,3,4]^..traverse.filtered even
22:39:30 <lambdabot>   [2,4]
22:39:40 <edwardk> that traverse gets you down to the individual elements
22:39:43 <shachaf> johnw: The nice thing about lens is that it lets you refer to elements directly.
22:40:01 <shachaf> So you can talk about the path in one place and what you want to do in another place.
22:40:25 <edwardk> > traverse.filtered odd *~ 2 $ [1..10]
22:40:25 <shachaf> edwardk: Should "non" from yesterday be added somewhere?
22:40:28 <lambdabot>   [2,2,6,4,10,6,14,8,18,10]
22:40:29 <edwardk> that is evil
22:40:45 <edwardk> shachaf: going to pass on it for now, because its not _that_ principled
22:41:22 <shachaf> What, because of Eq?
22:41:39 <edwardk> that and it has the funny domain that excludes one value, etc.
22:41:53 <shachaf> Excludes one value?
22:42:23 <edwardk> non 0  -- takes (Maybe a) to (a sans 0)
22:42:47 <Nereid> what is non?
22:43:01 <edwardk> Nereid: something we banged out in channel for rwbarton yesterday
22:43:11 <Nereid> what does it do
22:43:15 <edwardk> so he could work principledly with a total map
22:43:16 <shachaf> What about foo :: Eq a => SimpleIso (Maybe a) (Maybe a)?
22:43:29 <shachaf> Er, a ->
22:43:31 <edwardk> shachaf: still blech. that one is less useful than non
22:43:45 <shachaf> Fair enough.
22:43:58 <edwardk> i have to admit non was pretty concise though
22:44:04 <edwardk> at 2 <. non 0
22:44:19 <copumpkin> what we need are lenses on Containers and W types
22:44:28 <copumpkin> since you get positions by constructions
22:44:29 <copumpkin> -s
22:44:32 <edwardk> do you have the final form it took handy?
22:45:00 <shachaf> edwardk: Oh, I just noticed repeated isn't INLINE either.
22:45:14 <shachaf> Those seem to be related. Are you sure there's no reason for it?
22:46:27 <shachaf> Oh well, I'll add it.
22:46:27 <edwardk> there might actually have been now that you mention it
22:46:55 <shachaf> You can revert later if you decide there was a reason.
22:46:56 <edwardk> those are the kind of thing where sharing might be a good idea
22:46:57 <shachaf> Or even if you don't.
22:47:34 <shachaf> edwardk: But it's defined as repeated f a = as where as = f a *> as
22:47:42 <shachaf> Doesn't that give you all the sharing you need?
22:48:09 <edwardk> :t let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in non
22:48:11 <lambdabot> (Eq a, Functor f) => a -> (a -> f a) -> Maybe a -> f (Maybe a)
22:48:19 <edwardk> shachaf: in theory
22:48:32 <shachaf> @let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in non
22:48:32 <lambdabot>   Parse error: in
22:48:36 <shachaf> @let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v'
22:48:39 <lambdabot>  Defined.
22:48:49 <edwardk> :t at 2 . non 0
22:48:51 <lambdabot> (Eq v, Functor f, Num v, Num k, At k m) => (v -> f v) -> m v -> f (m v)
22:48:58 <Nereid> :t non
22:49:00 <lambdabot> (Eq a, Functor f) => a -> (a -> f a) -> Maybe a -> f (Maybe a)
22:49:05 <edwardk> :t at 2 . non 0 +~ 1
22:49:07 <lambdabot> (Eq v, Num k, Num v, At k m) => m v -> m v
22:49:23 <edwardk> :t M.fromList [(2,4)] % at 2 . non 0 +~ 1
22:49:25 <lambdabot> (Eq a, Num k, Num a, Ord k) => M.Map k a
22:49:29 <edwardk> > M.fromList [(2,4)] % at 2 . non 0 +~ 1
22:49:32 <lambdabot>   fromList [(2,5)]
22:49:35 <edwardk> > M.fromList [(2,1)] % at 2 . non 0 -~ 1
22:49:38 <lambdabot>   fromList []
22:49:50 <edwardk> basically it blows away the entry in the map when you hit the 'non' value
22:50:19 <shachaf> @let foo :: Eq a => a -> SimpleIso (Maybe a) (Maybe a); foo v = iso (\x -> case x of Nothing -> Just v; Just x | x == v -> Nothing | otherwise -> Just x) (\x -> case x of Nothing -> Just v; Just x | x == v -> Nothing | otherwise -> Just x)
22:50:21 <lambdabot>  <local>:15:1:
22:50:22 <lambdabot>      Duplicate type signature:
22:50:22 <lambdabot>        <local>:15:1-49: foo :: ...
22:50:34 <shachaf> @let blah :: Eq a => a -> SimpleIso (Maybe a) (Maybe a); blah v = iso (\x -> case x of Nothing -> Just v; Just x | x == v -> Nothing | otherwise -> Just x) (\x -> case x of Nothing -> Just v; Just x | x == v -> Nothing | otherwise -> Just x)
22:50:37 <lambdabot>  Defined.
22:50:42 <shachaf> > M.fromList [(2,4)] % at 2 . foo 0 . traverse +~ 1
22:50:44 <lambdabot>   Couldn't match expected type `a1
22:50:45 <lambdabot>                                -> Data.May...
22:50:54 <shachaf> > M.fromList [(2,4)] % at 2 . blah 0 . traverse +~ 1
22:50:57 <lambdabot>   fromList [(2,5)]
22:50:58 <shachaf> > M.fromList [(2,4)] % at 3 . blah 0 . traverse +~ 1
22:51:01 <lambdabot>   fromList [(2,4),(3,1)]
22:51:10 <shachaf> > M.fromList [(2,1)] % at 3 . blah 0 . traverse -~ 1
22:51:13 <lambdabot>   fromList [(2,1),(3,-1)]
22:51:15 <shachaf> > M.fromList [(2,1)] % at 2 . blah 0 . traverse -~ 1
22:51:18 <lambdabot>   fromList []
22:51:23 <edwardk> shachaf: you beat me to refactoring it into an Iso ;)
22:51:49 <edwardk> well, i was looking at refactoring it into an iso where it wasn't swapping to another Maybe
22:51:55 <edwardk> just pretending the target didn't have 0's
22:51:58 <edwardk> or whatever
22:52:02 <edwardk> :t non
22:52:03 <lambdabot> (Eq a, Functor f) => a -> (a -> f a) -> Maybe a -> f (Maybe a)
22:52:06 <shachaf> That's no iso!
22:52:10 <yitz> > 2 % 4
22:52:12 <lambdabot>   4
22:52:13 <shachaf> Though it might be an iso up to isomorphism.
22:52:17 <yitz> what ??
22:52:23 <edwardk> its an iso with a suitable caveat about the domain
22:52:28 <shachaf> yitz: Get with the times. (%) = flip ($)
22:52:35 <edwardk> yitz: we stole (%) for lens. use (/)
22:52:35 <yitz> no !!
22:52:40 <johnw> > 4 $ 2
22:52:41 <shachaf> edwardk: The one I gave is a real Iso (unless Eq is broken).
22:52:42 <lambdabot>   4
22:52:43 <johnw> what?
22:52:58 <edwardk> shachaf: yeah. it is. but it isn't as nice as non ;)
22:53:06 <shachaf> > ((*2) + 1) 5 -- johnw
22:53:09 <lambdabot>   11
22:53:16 <yitz> what do you mean "get with the times"? i think fraction are still quite useful, even though it's true they've been around since the time of the greeks at least
22:53:17 <edwardk> johnw: thats a caleskel thing. it lets you do things like 2 * sin
22:53:25 <shachaf> > 2 / 4 :: Rational
22:53:27 <lambdabot>   1 % 2
22:53:28 <yitz> *fractions
22:53:30 <edwardk> > 2 / 3 :: Rational
22:53:32 <lambdabot>   2 % 3
22:53:33 <johnw> ah
22:53:38 <johnw> caleskel
22:54:12 <shachaf> edwardk: Well, non doesn't make any restrictions about the domain, does it?
22:54:21 <shachaf> non x ~~ blah x . traverse
22:54:21 <edwardk> yitz: i tried really hard to avoid name conflicts with lens. (%) was one of the few casualties though.
22:54:34 <johnw> not a big Ratio user, yet?
22:54:38 <johnw> i mean, eh?
22:54:58 <edwardk> i use Ratio all the time. but (%) is kinda useless since you can basically always replace it with (/)
22:55:05 <johnw> true
22:55:14 <edwardk> (possibly with some fromIntegral noise)
22:55:15 <shachaf> Sometimes you need to fromIntegral
22:55:24 <yitz> @tell Cale lenses are ok, but please put % back to its standard meaning immediately. thanks.
22:55:25 <lambdabot> Consider it noted.
22:55:39 <shachaf> @tell Cale yitz is just a h8r
22:55:39 <lambdabot> Consider it noted.
22:55:58 <johnw> @tell Cale lenses % putback
22:55:58 <lambdabot> Consider it noted.
22:56:11 <edwardk> yitz: basically if you look at the log here on the channel. (%) in the lens sense was used easily 30 or 40 : 1 relative to the (%) from Data.Ratio meaning
22:56:23 <edwardk> yitz: that was pretty much when we got cale to relent
22:56:24 <johnw> yeah, we rarely talk about quotients here
22:57:02 <mgsloan> :t (.)
22:57:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
22:57:19 <johnw> that's (.) in this channel, msgloan
22:57:20 <mgsloan> yup, reign of the caleskell continues ;)
22:57:21 <yitz> is different than %. it's polymorphic, and that's usually not what you want when you are constructing a fraction.
22:57:28 <johnw> ah, you knew that :)
22:57:47 <johnw> > 4 / 2
22:57:48 <shachaf> mgsloan: So how's the taking thing going?
22:57:49 <lambdabot>   2.0
22:58:19 <mgsloan> shachaf: lol, I'm not sure if my lens-foo is up to the task!  I'm sure y'all will have it resolved in notime
22:58:33 <yitz> look, there are plenty of libraries that re-use Haskell 98 symbols. that's fine. just import them qualified.
22:59:11 <edwardk> the problem is there are an inordinate number of lens examples that use (%) that don't refactor cleanly and really don't work if you are using Lens.%
22:59:17 <sopvop> I love (%) so much, and think it should live in Data.Function.
22:59:17 <yitz> or even import Prelude (or Data.Ratio) hiding if you really want (personally i almost never do that). but not in lambdabot, please.
22:59:32 <yitz> sopvop: me too, fractions are extremely useful.
22:59:35 <Jafet> > let (√∑) :: Integer -> Integer -> Rational; (√∑) = (/) in 1 √∑ 2
22:59:35 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
22:59:46 <edwardk> yitz: i think he meant the lens one ;)
22:59:47 <shachaf> > M.fromList [(2,4)] Control.Lens.% at 2 . non 0 Control.Lens.%~ (+5)
22:59:50 <lambdabot>   fromList [(2,9)]
23:00:04 <edwardk> @let (√∑) :: Integer -> Integer -> Rational; (√∑) = (/) in 1 √∑ 2
23:00:04 <lambdabot>   Parse error: in
23:00:07 <sopvop> edward: I sure did
23:00:13 <edwardk> @let (√∑) :: Integer -> Integer -> Rational; (√∑) = (/)
23:00:15 <lambdabot>  <local>:16:46:
23:00:15 <lambdabot>      Couldn't match expected type `Rational' with actual type...
23:00:41 <edwardk> @let (√∑) :: Integer -> Integer -> Rational; (√∑) = (/) fromInteger fromInteger
23:00:44 <lambdabot>  Defined.
23:01:01 <shachaf> edwardk: How does it feel being evil?
23:01:01 <mauke> haha
23:01:52 * sopvop still cant forgive Control.Lens.Getter.query
23:02:03 <edwardk> sopvop: that one i'd be willing to change
23:02:25 <shachaf> request?
23:02:28 <shachaf> No one uses that name. :-)
23:02:29 <edwardk> i don't have a better name for it
23:02:53 <edwardk> put in an issue, and we can kick around names
23:03:06 <shachaf> mgsloan: I'm sure Y'all is deprecated.
23:03:20 <shachaf> mgsloan: And it doesn't even have taking. I don't know what y'all're talking about.
23:03:26 <sopvop> inquire :)
23:03:58 <shachaf> inquiring monads want to know
23:04:03 <shachaf> gwern: Isn't that so?
23:04:40 <edwardk> asking and askings would fit the '-ing' or '-ed' lens use suffix pattern
23:04:58 <shachaf> Is there an actual patterns to those?
23:05:01 <ion> ****ing
23:05:18 <shachaf> It seems kind of random what gets "ing" and "ed" and what doesn't.
23:05:19 <edwardk> its a little ad hoc in places, i admit.
23:05:19 <mgsloan> shachaf: Yes, I believe y'all have taking
23:05:29 <shachaf> mgsloan: It don't.
23:05:35 <edwardk> i had a system. i think i lapsed in places
23:05:50 <edwardk> e.g. i think cycled should be cycling
23:06:17 <edwardk> the -'ing's were originally things that took another lens/traversal/etc.
23:06:47 <edwardk> :t taking
23:06:49 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
23:06:50 <edwardk> :t dropping
23:06:52 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
23:07:21 <shachaf> That makes sense.
23:07:22 <edwardk> while the '-ed's were for lens-like analogues without parameter
23:07:36 <edwardk> er without a lens/fold/etc parameter
23:08:01 <edwardk> here, 'asking' would be the right name
23:08:06 <edwardk> but 'askings' is silly
23:08:17 <edwardk> er asked and askeds
23:08:46 <sopvop> demand? :)
23:08:50 <edwardk> hah
23:08:54 <shachaf> gimme
23:09:04 <edwardk> i've seen both demand and gimme in real code ;)
23:09:11 <ion> icanhas
23:09:16 <edwardk> ion: =)
23:09:31 <shachaf> icanha
23:09:38 <ion> hah
23:10:13 <edwardk> and it should have something to do with reading or asking
23:10:32 <edwardk> peruse, and peruses has 'use' in it
23:10:50 <Jafet> icanhaskell
23:10:50 <edwardk> and the reader connotation
23:11:41 <edwardk> you has kelled me. you bastard.
23:12:08 <sopvop> There are not enough words in english, use latin. (or greek, unicode)
23:12:54 <mgsloan> the new version of category-extras will use a lolspeak dialect, to avoid naming conflicts with lens, featuring such lovely combinators as "canHazYoneda", and will appropriately be titled "cats", adding another 4-letter library to edwardk's arsenal
23:14:09 <shachaf> "do yoneda cheezburger?"
23:14:42 <simpson> "Kan I haz a cheezburger?"
23:14:54 <edwardk> nah, the base library will be cats, and that will be haskell 98. you are thinking of what will be in the lol-cats package, which extends it and where i feel free to laugh out loud when people ask if its haskell 98.
23:15:03 <edwardk> simpson: =)
23:15:18 <sopvop> feel FreeT
23:15:19 <yitz> @type (/) fromIntegral fromIntegral
23:15:22 <lambdabot> (Fractional b, Integral a) => a -> b
23:15:34 <simpson> edwardk: :3
23:15:36 <yitz> now where did *that* breakage come from?
23:15:51 <shachaf> yitz: Cale's fault.
23:16:00 <edwardk> yitz: instance Num a => Num (e -> a)
23:16:01 <mgsloan> yitz: Num (a -> b)
23:16:05 <yitz> since when is lambdabot's evaluator not haskell anymore? isn't this #haskell?
23:16:12 <shachaf> yitz: Blame Cale!
23:16:25 <edwardk> lambdabot's evaluator on #haskell hasn't been stock haskell in 4-5 years at least
23:16:32 <mapf> @type (/) a b c d
23:16:34 <lambdabot>     Couldn't match expected type `t0 -> t1 -> t2'
23:16:34 <lambdabot>                 with actual type `Expr'
23:16:34 <lambdabot>     In the first argument of `(/)', namely `a'
23:16:34 <yitz> ah he defined an instance like that? very weird.
23:16:54 <shachaf> @type (/) f g x
23:16:55 <edwardk> yitz: um, ghc dropped the Eq and Show constraint on Num explicitly so instances like that can be defined.
23:16:55 <lambdabot> (Fractional t, FromExpr t) => t
23:16:57 <ion> It‚Äôs in NumInstances.
23:16:59 <shachaf> > (/) f g x
23:17:01 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:17:01 <lambdabot>    (GHC.Real.Fractional a0...
23:17:07 <yitz> edwardk: that's true. but somehow closer to what people actually do at least.
23:17:09 <shachaf> > (/) f g x :: Expr
23:17:11 <lambdabot>   f x * recip (g x)
23:17:14 <shachaf> Hah.
23:18:27 <mgsloan> I agree though, if I was new to a language, and came to the channel, and the language worked differently, it'd be a bit off-putting
23:18:34 <Jafet> Cale's law: if you provide an interpreter, people will attribute all of its idiosyncrasies to you.
23:18:53 <shachaf> Jafet: Well, he *did* add all those idiosyncrasies in.
23:18:53 <edwardk> sopvop: query/queries became peruse/peruses in lens HEAD
23:18:58 <Jafet> Not to be confused with Cale slaw
23:19:20 <yitz> @check const True
23:19:20 <mgsloan> I guess it depends on whether lambdabot is an educational tool or just for fun
23:19:22 <lambdabot>   Not in scope: `myquickcheck'
23:19:34 <sopvop> Now I have to look in English dictionary
23:19:59 <yitz> urg @check still broken. seems like time spent on lambdabot could be much better spent.
23:20:13 <shachaf> yitz: No time has been spent on lambdabot for several years.
23:20:14 <Jafet> @quickcheck ap (==) reverse
23:20:15 <lambdabot> Unknown command, try @list
23:20:26 <sopvop> peruse - Examine carefully or at length.  -- deepseq lens? :)
23:20:34 <yitz> shachaf: not true. % is broken and Num is broken. that's recent.
23:20:52 <edwardk> Num has been like this for years
23:21:02 <Nereid> @check ap (==) reverse
23:21:04 <mgsloan> yeah, I complained about it at least a year ago
23:21:04 <lambdabot>   Not in scope: `myquickcheck'
23:21:10 <mauke> yitz: how is Num broken?
23:21:13 <Jafet> > (+)
23:21:14 <edwardk> this was a longstanding 'caleskel' feature
23:21:16 <lambdabot>   *Exception: show: No overloading for function
23:21:26 <edwardk> (%) was a recent change though
23:21:33 <yitz> yeah
23:21:39 * hackagebot plot 0.1.5.1 - A plotting library, exportable as eps/pdf/svg/png or renderable with gtk  http://hackage.haskell.org/package/plot-0.1.5.1 (VivianMcPhail)
23:21:40 <mgsloan> I mean, I think it's cool, but Caleskel should be something other than ">" like ">>" orso
23:21:59 <mgsloan> of course I'm totally fine with lens being default :)
23:22:01 <shachaf> The centerpiece of Caleskell is (.) = fmap, though.
23:22:11 <shachaf> And that one is wrong. :-(
23:22:12 <yitz> shachaf: yes true :)
23:22:44 <yitz> shachaf: it's a very interesting observation, but doesn't belong in every day programming.
23:22:44 <ion> Has (.) = fmap ever been used for anything other than obfuscation/golfing here?
23:22:45 <mgsloan> shachaf: yeah, I'm thinking that could make lensy errors quite frightening
23:22:45 <edwardk> mgsloan: i think it comes down to him being the guy who actually puts up the bot, so he gets to trot out and enjoy his little pecadillos ;)
23:23:00 <mapf> @src (.)
23:23:00 <lambdabot> (f . g) x = f (g x)
23:23:00 <lambdabot> NB: In lambdabot,  (.) = fmap
23:23:17 <shachaf> There's such an obvious generalization of (.), though.
23:23:36 <edwardk> i'm just glad that lens is pretty robust to either generalization of (.) =P
23:23:53 <Jafet> shachaf: it'll have to wait until edwardk makes cats
23:24:07 <yitz> edwardk: hmm lens doesn't essentially depend on . being the one from categories?
23:24:10 <shachaf> edwardk: It's funny that when I experimented with some other implementations of polymorphic lenses, I was at a loss for the type of composeLens.
23:24:21 <shachaf> You need two extra variables names other than s t a b
23:24:21 <ion> yitz: The normal (.) is fine, yes.
23:24:26 <shachaf> That doesn't happen anywhere in the lens code.
23:24:34 <mgsloan> yitz: only for Iso and perhaps Projection?
23:24:36 <yitz> ion: in this case it isn't the normal one either
23:24:42 <Nereid> yitz: yes it is
23:24:46 <shachaf> Hmm, maybe it happens for Projection.
23:24:49 <edwardk> yitz: correct. lens uses functions like type Lens s t a b = forall f. Functor f => (a -> f b) -> (s -> f t)  -- so its just a function from 'objects' of the form (x -> f y)
23:24:49 <mauke> ion: consider this law: fmap f (fmap g x) == fmap (f . g) x
23:25:02 <mauke> ion: with (.): f . (g . x) == (f . g) . x
23:25:03 <mgsloan> yitz: most of lens uses normal (.)
23:25:16 <edwardk> this lets us use 'id' as the identity lens.
23:25:52 <edwardk> and by putting different constraints on 'f' we can make traversals (by using Applicative), getters, setters, folds, actions, indexed versions of the above, isomorphisms, etc.
23:26:34 <edwardk> > id +~ 1 $ 2
23:26:37 <lambdabot>   3
23:26:47 <ion> mauke: One can still bask in the glory of that without lambdabot having (.) = fmap by default. :-P
23:26:55 <edwardk> > both +~ 1 $ (2,3)
23:26:57 <lambdabot>   (3,4)
23:27:08 <edwardk> or to send yitz into conniption fits again
23:27:25 <edwardk> > (2,3) % both +~ 1 % _2 *~ 10
23:27:28 <lambdabot>   (3,40)
23:28:05 <simpson> edwardk: Geshundeit.
23:28:36 <edwardk> > zipper ("hello", "world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
23:28:39 <lambdabot>   ("Jelly","world")
23:28:46 <twoolie> hey can anyone here help me with a little fay problem i have?
23:28:55 <mauke> needs more "wello"
23:29:00 <arcatan> what kind of sorcery is this?
23:29:04 <edwardk> twoolie: sprinkle salt across the door frame or leave out milk
23:29:32 <c_wraith> edwardk: not fae.  :P
23:29:40 <sopvop> I hope to never see such code in real use
23:29:52 <mauke> edwardk: how can I replicate http://www.phpfiddle.org/lite/code/jxs-h05 with lenses?
23:29:59 <MetaCosm> I am a golden god, all the groceries in one trip from the car...
23:30:08 <MetaCosm> can barely feel my fingers.
23:30:23 <c_wraith> MetaCosm: that seems to be setting the bar low.  What level will you have to reach when you do something even more amazing?
23:30:45 <MetaCosm> c_wraith, illogical question.  Nothing is more amazing that all the groceries in one trip.
23:30:48 <shachaf> c_wraith: Are you using lens yet?
23:30:54 <edwardk> mauke: lenses kinda suck at dealing with nested maps
23:31:04 <edwardk> at least with updating them. reading them is easy
23:31:13 <c_wraith> shachaf: no, but that's because I'm not really working with much haskell code at the moment.
23:31:17 <mauke> don't worry, so does PHP
23:31:31 <shachaf> edwardk: Look at that code more closely.
23:31:42 <shachaf> Oh, that doesn't show the output.
23:32:01 <mauke> you may have to click on Run
23:32:31 <edwardk> my brain refuses to deal with php language irregularities. the language was written by a guy who admits he hates programming, and who has said he doesn't give 2 shits about language design.
23:32:35 <shachaf> mauke: I guess 'bar' gets turned into 0?
23:32:52 <edwardk> and it shows
23:33:42 <mauke> shachaf: yeah
23:34:00 <shachaf> And so it's indexing a single character.
23:34:43 <edwardk> :t zipper (M.fromList [("foo","hello")]) % fromWithin (at "foo")
23:34:45 <lambdabot>     Ambiguous occurrence `%'
23:34:45 <lambdabot>     It could refer to either `L.%', defined at <local>:1:41
23:34:45 <lambdabot>                           or `Lens.%',
23:34:58 <edwardk> ?
23:35:04 <shachaf> @undefined
23:35:08 <edwardk> :t zipper (M.fromList [("foo","hello")]) % fromWithin (at "foo")
23:35:10 <lambdabot> (Top :> M.Map [Char] [Char]) :> Maybe [Char]
23:35:19 <edwardk> :t zipper (M.fromList [("foo","hello")]) % fromWithin (at "foo" . traverse)
23:35:22 <lambdabot> (Top :> M.Map [Char] [Char]) :> [Char]
23:35:23 <shachaf> edwardk: Any reason you put zipper on the left side of the %?
23:35:45 <edwardk> :t M.fromList [("foo","hello")] % zipper % fromWithin (at "foo" . traverse)
23:35:47 <lambdabot> (Top :> M.Map [Char] [Char]) :> [Char]
23:35:58 <shachaf> > M.fromList [("hello", M.empty), ("foo", M.empty)] % at "hello" . traverse . at "world" .~ Just 5
23:36:01 <lambdabot>   fromList [("foo",fromList []),("hello",fromList [("world",5)])]
23:36:13 <shachaf> > M.fromList [("hello", M.empty), ("foo", M.empty)] % at "hello" . traverse . at "world" .~ Just 5 % at "foo" . traverse . at "bar" .~ Just 20
23:36:16 <lambdabot>   fromList [("foo",fromList [("bar",20)]),("hello",fromList [("world",5)])]
23:36:35 <edwardk> :t M.fromList [("foo","hello")] % zipper % fromWithin (traverseAt "foo" . traverse) % focus .~ 'w'
23:36:37 <lambdabot> (Top :> M.Map [Char] [Char]) :> Char
23:36:40 <edwardk> > M.fromList [("foo","hello")] % zipper % fromWithin (traverseAt "foo" . traverse) % focus .~ 'w' % rezip
23:36:43 <lambdabot>   fromList [("foo","wello")]
23:37:19 <twoolie> does anyone here use fay?
23:37:45 <edwardk> > M.fromList [("foo","hello")] % zipper % fromWithin (traverseAt "foo") % partsOf (focus.traverseHead) .~ "world" % rezip
23:37:47 <lambdabot>   Not in scope: `traverseHead'
23:37:47 <lambdabot>  Perhaps you meant one of these:
23:37:47 <lambdabot>    `traverseM...
23:38:00 <edwardk> shucks, traverseHead is in Data.List.Lens
23:38:15 <edwardk> > M.fromList [("foo","hello")] % zipper % fromWithin (traverseAt "foo") % partsOf (focus.iwhere (==0)) .~ "world" % rezip
23:38:17 <lambdabot>   fromList [("foo","wello")]
23:38:26 <edwardk> there. we too can php
23:39:00 <mauke> yay!
23:40:12 <AfC> It works!
23:40:55 <edwardk> partsOf will discard excess elements, and focus.iwhere (==0) -- only had one target
23:41:07 <sopvop> twoolie: try #fay
23:47:55 <edwardk> @src non
23:47:56 <lambdabot> Source not found. :(
23:51:02 <Cale> edwardk: I'm getting messages from people who want % to mean the usual thing again
23:51:27 <edwardk> yitz popped up on channel with it, and we armwrestled about it
23:51:32 <Cale> heh
23:51:34 <yitz> hi :)
23:51:48 <edwardk> but he also wants to revert (.) to the original meaning and for Num to stop with all this newfangled tomfoolery
23:51:53 <Cale> heh
23:52:08 <edwardk> i'm not sure i want to get off his lawn though ;)
23:52:09 <Nereid> what's the usual thing for %?
23:52:25 <edwardk> :t (Data.Ratio.%)
23:52:27 <lambdabot> Integral a => a -> a -> Ratio a
23:52:34 <yitz> other non-standard behaviors of \bot mostly preserve the basic flavor of haskell, with some extensions. % is just complete breakage.
23:52:40 <Nereid> oh that
23:52:51 <hpaste> b__ pasted ‚ÄúBetter way?‚Äù at http://hpaste.org/77953
23:53:04 <b__> simple parsing question ^^
23:53:08 <yitz> edwardk: those other things bother me less than %
23:53:36 <yitz> (.) can still be used in the usual way. usually. you just get weird error messages.
23:53:49 <edwardk> if Data.Ratio was exported by default from the Prelude and if (/) was such a better workaround i'd be much more sympathetic. but (%), but (%) is a crappy operator as it exists. it encourages accidentally making Ratio Int's which just crap out
23:54:07 <edwardk> er if (/) wasn't
23:54:09 <yitz> Numeric types can also be used in the usual way.
23:55:12 <yitz> nah Int vs. Integer is pervasive in Haskell. nothing special about % there.
23:55:29 <edwardk> you can explicitly use Data.Ratio.% still with lambdabot.
23:55:50 <edwardk> what i mean is that Ratio Int is almost always a bad idea.
23:56:02 <edwardk> and Data.Ratio isn't imported by default at ghci, its not exported by the Prelude
23:56:11 <Cale> lol Ratio Int
23:56:12 <yitz> you saw the effect of @let (%). it doesn't work.
23:56:19 <Cale> That's worse than floating point
23:56:36 <edwardk> of course it doesn't we have an explicit import to the contrary
23:56:57 <edwardk> > 4 Data.Ratio.% 3
23:56:59 <lambdabot>   Not in scope: `Data.Ratio.%'
23:57:02 <mgsloan> We'll hold (.) hostage, in exchange for amnesty for (%)
23:57:22 <edwardk> oh, its not even imported with an explicit qualified constraint.
23:57:22 <yitz> mgsloan++
23:57:43 <edwardk> mgsloan: =P
23:58:13 <edwardk> cale: could we import Data.Ratio qualified to appease yitz to some extent?
23:58:30 <shachaf> Could we fix Unicode?
23:58:39 <shachaf> Then yitz can get Ÿ™
23:58:45 <shachaf> Or Ôπ™
23:58:50 <shachaf> Or the one Jafet used!
23:58:55 <shachaf> √∑
23:58:58 <shachaf> That's the right symbol.
23:59:19 <shachaf> yitz: mgsloan is in favor of (Lens.%), by the way
23:59:22 <edwardk> i'd really not be ready to give up the ability to actually copy and paste lens examples, but, the ability to explicitly use Data.Ratio.% or R.%  or something would go a long way to mollify this
23:59:27 <Cale> Or lenses can get √∑ ;)
23:59:34 <Cale> kekeke
23:59:44 <edwardk> i would just go back to pasting my damn examples by hand if lambdabot lost (%) its in almost all of them now
23:59:49 <shachaf> @let (‚ñ∂) = (%)
23:59:51 <lambdabot>  Defined.
