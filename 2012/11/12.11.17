00:00:14 <Sonarpulse> I figured you would say that :)
00:00:14 <Canar> I tried sticking runPut in there in a few places... nothing seemed to work
00:00:46 <shachaf> Sounds like the right thing to do is to think about it a bit.
00:00:53 <shachaf> Go to ghci, instead of that program.
00:01:01 <shachaf> Start with just a single value, rather than a list of them.
00:01:06 <shachaf> Can you turn this value into a ByteString?
00:01:12 <Canar> Ugh. I just want to get that chunk of code working, then I can figure it out from there.
00:01:25 * shachaf sighs.
00:01:31 <Canar> I'm so new with Haskell, I'm trying to get a hunk of code to a point where it's somewhat useful, then I can bootstrap myself.
00:02:10 <shachaf> Did you fix the comma bug I mentioned?
00:03:01 <Canar> yep
00:03:06 <shachaf> (runPut . putFloat64le) :: Float -> ByteString
00:04:15 <shachaf> Canar: A much more valuable skill than "being able to dump numbers to stdout with Put" is "being able to figure things out on your own in little pieces [in ghci]"
00:04:26 <Canar> shachaf: I'm aware of that.
00:04:44 <shachaf> Have you gotten anything working in there?
00:04:55 <Canar> As weird as it may seem, the "being able to dump" bit is a place I'm actually quite comfortable with.
00:04:59 <Sonarpulse> yeah, the less debuging you can do without side effects the better
00:05:16 <shachaf> For example, do you see why "runPut (putFloat64le 0.5)" should work?
00:05:20 <shachaf> (I don't know if it does.)
00:05:55 <Sonarpulse> btw can gchi stay "in scope" so can test local functions as if they were global?
00:06:50 <Canar> shachaf: because types
00:06:58 <Canar> but I get not in scope problems in ghci
00:07:15 <shachaf> What do you do about not-in-scope problems outside of ghci?
00:07:18 <shachaf> Do the same thing inside ghci. :-)
00:07:24 <Canar> import
00:07:32 <Canar> but i've imported the relevant lib, or so i thought
00:09:12 <Nereid> Sonarpulse: what are "local functions"?
00:09:26 <shachaf> Canar: Did you import them in ghci?
00:09:35 <Sonarpulse> like stuff in a let or where
00:09:39 <Canar> shachaf: Yes, I think so.
00:09:42 <Sonarpulse> I guess it's more C speak
00:09:49 <Canar> import Data.Serialization.Put
00:09:54 <Sonarpulse> or lisp
00:09:59 <Canar> import Data.Serialization.IEEE754
00:10:02 <shachaf> Looks good.
00:10:07 <shachaf> And it still says it's not in scope?
00:10:19 <Canar> Yes.
00:10:39 * shachaf wonders what "it" is.
00:10:53 <Canar> runPut and putFloat64le
00:11:18 <shachaf> I suspect you're not doing what you're saying you're doing.
00:11:29 <Canar> ?
00:11:54 <Canar> Well, I have no idea how to prove to you that I'm not deliberately wasting both of our times in such a contentious manner.
00:11:57 <shachaf> Oh, what version of GHC are you using?
00:12:14 <shachaf> Canar: I didn't say anything about malice!
00:12:25 <shachaf> Try ":m +" instead of "import"
00:12:34 <Canar> 7.4.1, admittedly
00:12:38 <Canar> latest debian sid release
00:12:49 <shachaf> Should be fine.
00:13:09 <shachaf> You could hpaste.org your entire ghci transcript so that I'll believe you. :-)
00:15:58 <Canar> Bleh.
00:16:00 <Canar> Typo.
00:16:05 <Canar> Data.Serialize
00:16:45 <Canar> now runPut is giving me a ByteStream
00:16:53 <shachaf> No it's not.
00:16:54 <b__> if I have a bunch of Accounts (name :: String, and value :: EUR), to which I want to apply a bunch of transactions (whose values depend on the state of some of these Accounts), what kind of datatype would I use for this? something mutable to update inside the State monad?
00:17:19 <Canar> ByteString?
00:17:24 <shachaf> Yes. :-)
00:17:34 <b__> I read the SPJ paper on Contracts, but am not sure how to do the simulation of events
00:19:01 <b__> if I'd do it with a Map, it would get really ugly I think
00:20:11 <shachaf> I'm not sure what it is you're trying to do.
00:20:44 <Canar> hooray i'm getting bytes from a list
00:21:08 <Canar> thanks shachaf
00:21:21 <Canar> ...and i thought thinking in prolog was hard x.x
00:21:36 <b__> I have n Accounts at t1, I then apply all Transactions between t1 and tx to these accounts
00:21:58 <b__> a Transaction would consist of moving a certain amount between two Accounts
00:22:13 <shachaf> OK.
00:22:19 <shachaf> And what's the question?
00:22:21 <b__> but this amount is dependent on the current state of the Accounts
00:22:26 <shachaf> What's ugly about using Map?
00:23:51 <b__> because I would be defining Transactions using String to identify Accounts
00:24:17 <b__> instead of having combinators that I can directly apply to Accounts
00:24:32 <shachaf> ?
00:25:04 <b__> move (Ä 200) "A" "B"
00:25:23 <b__> would do a lookup in the Map to see what "A" and "B" are
00:26:21 <b__> hm I can't explain it properly so I'll come back when I have some code to show
00:26:46 <shachaf> That seems pretty reasonable to me.
00:26:50 <shachaf> How else would you want to express that?
00:27:15 <b__> yeah not sure, preferably my generating data types
00:27:27 <shachaf> ?
00:27:38 <b__> to have actual types for each Account
00:27:53 <shachaf> Types?
00:28:42 <b__> yeah, like CreditCard = CreditCard { saldo :: EUR, spendable :: EUR }
00:28:49 <b__> etc
00:29:33 <b__> but I'll go ahead and implement it with Map first
00:30:31 <b__> I'll come back when I have a real question to ask =]
00:47:11 <hpaste> Canar pasted ‚ÄúSpurious zero?‚Äù at http://hpaste.org/77845
00:47:46 <Canar> shachaf: there's some spurious value being prepended to my list here
00:48:35 <shachaf> Yes.
00:48:37 <Canar> the "correct" result is the last 8 bytes of the od output
00:48:46 <shachaf> It's putListOf
00:48:54 <hpaste> Sonarpulse pasted ‚Äúdispatching!‚Äù at http://hpaste.org/77846
00:48:54 <shachaf> What do you expect putListOf to do?
00:49:03 <Sonarpulse> ok, so this is what I have been doing
00:49:18 <Canar> to put 8 bytes per value in the list
00:49:42 <Canar> given varying lists, i always get 8n + 8 bytes for n values
00:50:00 <Sonarpulse> Canar: I haven't been following this, and only used Data.Binary
00:50:02 <shachaf> Data.Serialize is for serialization.
00:50:09 <Sonarpulse> as is Binary
00:50:15 <Sonarpulse> the overlap is huge
00:50:18 <Sonarpulse> not sure what the deal is
00:50:23 <Sonarpulse> anyways
00:50:28 <Canar> so it's prepending the number of items?
00:50:33 <Sonarpulse> I have found this it doesn't allways infer the right up
00:50:35 <shachaf> Something along those lines, yes.
00:50:40 <Sonarpulse> use "::" and specify it byhand
00:50:42 <shachaf> Otherwise how would it be able to deserialize?
00:50:55 <Sonarpulse> hmm?
00:51:03 <Canar> Good point.
00:51:13 <Sonarpulse> I mean if a :: LazyByteString
00:51:20 <shachaf> What?
00:51:28 <Sonarpulse> put a and putLazyByteString a were different
00:51:33 <Sonarpulse> I say this from experience
00:51:49 <shachaf> Maybe I should set up a bot that answers "what?" to everything Sonarpulse says. :-(
00:52:00 <shachaf> I find it very difficult to understand what you're trying to say.
00:52:22 <Sonarpulse> I saw that there was some issue with putting here?
00:52:32 <Sonarpulse> right?
00:52:36 <Canar> Not really.
00:52:41 <Sonarpulse> well my bad
00:52:43 <Canar> My own misunderstanding of Haskell serialization.
00:52:54 <Canar> Now I just need to figure out how to tell those first 8 bytes to F off.
00:53:10 <Sonarpulse> what is your problem?
00:53:31 <Sonarpulse> I think Binary.Serialize (why do people say cereal?) was made before
00:53:33 <shachaf> Canar: Just don't use putList.
00:53:45 <Sonarpulse> Data.Binary.Strict
00:53:57 <Sonarpulse> because they are almost identical
00:54:13 <Sonarpulse> was putList padding things?
00:55:05 <Canar> shachaf: I imagine that to not use putListOf, I need to write something analogous to it, but my Haskell-fu is still too weak to know what exactly I want.
00:55:08 <shachaf> Sonarpulse: I don't think "cereal" is broken enough that the only advice to give to someone using it is "use this other package instead". :-)
00:55:22 <shachaf> Canar: I recommend learning some more Haskell before trying to write this code.
00:55:26 <Canar> I think I just want to map putFloat64le across my list or something.
00:55:28 <shachaf> Seriously, it's different from other languages you're used to.
00:55:38 <shachaf> It's worth putting a bit of up-front effort in.
00:55:50 <Sonarpulse> I wasn't trying to say that
00:55:51 <shachaf> With that said, yes, you can use map.
00:56:01 <Sonarpulse> I was critizing the makers for ceral for re-inventing the wheel
00:56:21 <Sonarpulse> and I was also saying that I only know binary so I can help indirectly
00:56:35 <shachaf> I don't think you know enough about either package to do that.
00:56:37 <Sonarpulse> for all i know cereal is better than Data.Binary should be depricated
00:56:57 <Canar> shachaf: I understand that you're trying to help me to learn correctly. However, I learn best correctly from correct examples, and I'm just trying to get to the point where I have this bit of code working correctly so I can do the other stuff.
00:57:06 <shachaf> Canar: OK, so use map!
00:57:09 <shachaf> You had map earlier.
00:57:40 <shachaf> The following function may be useful:
00:57:49 <shachaf> concat :: [ByteString] -> ByteString
00:57:56 <shachaf> The following function may also be useful:
00:58:09 <shachaf> mapM_ :: (a -> IO b) -> [a] -> IO ()
00:58:15 <shachaf> The following function may also be useful
00:58:37 <shachaf> mapM_ :: (a -> Put) -> [a] -> Put
00:59:39 <shachaf> These are three different approaches for solving this problem. :-)
01:00:20 <Canar> I like the last one.
01:00:37 <Pranz> @kind Put
01:00:39 <lambdabot> Not in scope: type constructor or class `Put'
01:00:46 <shachaf> tpye Put = PutM ()
01:01:00 <Sonarpulse> Canar are you still just trying to print the list of floats?
01:01:07 <Sonarpulse> as in your first pastebin?
01:01:11 <Canar> not print, write them as binary
01:01:16 <Canar> output them as binary
01:01:22 <Sonarpulse> oh
01:01:38 <Sonarpulse> within an IO ?
01:01:47 <Canar> I think the answer is yes.
01:02:03 <Sonarpulse> do you want to write to a file or bytestring?
01:02:27 <Canar> bytestring is fine
01:02:33 <Sonarpulse> then no IO
01:02:58 <shachaf> Yes, of course there's IO involved.
01:03:00 <Sonarpulse> (shachaf, no typeclasses I promise)
01:03:01 <shachaf> Did you see what the program is doing?
01:03:17 <Sonarpulse> he just says he just wants to make a bytestring
01:03:23 <shachaf> It's taking a bunch of floats and printing them (encoded in IEEE754) to stdout.
01:03:29 <shachaf> No.
01:03:32 * shachaf sighs.
01:03:56 <Sonarpulse> i didn't see the stdout part
01:03:58 <Canar> haha
01:04:00 <shachaf> I'm getting too mean for this channel. I should leave when this happens.
01:04:00 <Canar> wow
01:04:09 <Canar> shachaf: not mean
01:04:15 <Canar> you're forcing me not to be stupid
01:04:17 <Canar> and i hate it
01:04:20 <Canar> but it's for the best
01:04:34 <Sonarpulse> well still we can do this on step at a time
01:04:41 <Canar> i figured out the mapM_ approach now
01:04:46 <Canar> and it works as expected.
01:04:47 <Sonarpulse> proper types -> bytestring
01:04:47 <Canar> woot
01:04:59 <Sonarpulse> nevermind
01:05:11 <Sonarpulse> do you have code? should be one line so just paste here
01:05:24 <Canar> main = B.putStr $ runPut $ mapM_ putFloat64le [0.0,0.5]
01:05:47 <Sonarpulse> seems legit
01:05:55 <Canar> yep, that is working fine
01:06:19 <Sonarpulse> have you done functional before btw?
01:06:23 <Canar> heh
01:06:27 <Canar> scheme, lisp
01:06:36 <Canar> prolog <3
01:06:44 <Canar> which isn't really functional, but
01:06:45 <Sonarpulse> me too for the first too
01:06:54 <Sonarpulse> certainly want to do prolog though
01:07:02 <Pranz> haha prolog
01:07:05 <Pranz> Never understood any of it
01:07:14 <Canar> i see how nice/powerful the type system in haskell is, but it's a big mindfuck
01:07:36 <Sonarpulse> do like lazy racket or something if you want to "ease in"
01:07:53 <Canar> i learn best by doing self-guided projects
01:08:02 <Sonarpulse> me too
01:08:02 <Canar> i have a software synth that i've been hacking on for a long time
01:08:09 <Canar> mostly written in ruby, because i <3 ruby
01:08:33 <Canar> ...but i keep running into these functional, typed situations, and it feels like haskell is the appropriate fit
01:08:35 <Sonarpulse> typing is nice  in the end, you really do all your "debugging" compile time
01:08:51 <Canar> i'm writing all this stupid boilerplate, even in ruby, to deal with something that boils down to raw functions
01:08:58 <Sonarpulse> yeah
01:09:14 <Sonarpulse> there is very few extraneous characters in haskell
01:09:17 <Pranz> Canar, you have any blog about programming your software synth?
01:09:20 <Pranz> I would love to see that
01:09:25 <Canar> Pranz: haha not really
01:09:26 <Sonarpulse> I was thinking of doing a synth
01:09:27 <Pranz> Also interested in sound production
01:09:42 <Pranz> Ah too bad
01:09:44 <Sonarpulse> where every generater was just a lambda that took modulus time
01:09:46 <Canar> i have some noodlings from a former incarnation on my soundcloud tho
01:10:19 <Canar> lost the source to these
01:10:25 <Sonarpulse> and it would be like samplerate independant from day one that way
01:10:27 <Canar> and they're pretty boring/primitive, but whatever
01:10:34 <Canar> http://soundcloud.com/baryon/sets/7-tone-equal-temperament/
01:10:48 <Pranz> Cool, gonna giva it a listen
01:10:58 <Canar> Sonarpulse: imo samplerate independence is not a good goal
01:11:04 <Canar> samplerate is too fundamental
01:11:59 <Sonarpulse> well, then if nobody else is doing it I am especially interested :D
01:12:07 <Sonarpulse> I tried nyquist
01:12:08 <Canar> lol
01:12:32 <Sonarpulse> but nothing was first class
01:12:40 <Sonarpulse> or so it felt
01:12:52 <Pranz> it's really cool you made that yourself
01:13:02 <Sonarpulse> i dunno, this was before I had done any lisp or anything
01:13:09 <Sonarpulse> yeah, those are really good
01:13:13 <Canar> Pranz: that was like a few hours of me being really stoned >_>
01:13:24 <Pranz> xD
01:13:36 <ion> > let a :: Integer = 42 in a  -- Huh
01:13:38 <lambdabot>   42
01:14:02 <Sonarpulse> hmm?
01:16:04 <Sonarpulse> anyways, with my earlier pastebin
01:16:05 <Sonarpulse> http://hpaste.org/77846
01:16:17 <Sonarpulse> how can i used dDecode and dEncode
01:16:23 <Sonarpulse> instead of g and h ?
01:16:43 <Sonarpulse> how do I pull the resaulting mix out of my Mix sumtype?
01:20:09 <neutrino> Canar: the type system looks like a mind fuck until you've used haskell for a couple projects and figured out the syntax, then it's easy
01:20:44 <Canar> neutrino: that's usually the case for CS stuff
01:21:17 <Canar> before you grok it, everything is arcane, and afterwards, everything is comprehensible
01:22:30 <Canar> anyways, i need sleep
01:22:34 <Canar> thank you all for contributing
01:23:03 <Sonarpulse> unless your are doing my project where as soon as learn one aspect of types you get yourselves confused by using something more advnaced
01:23:07 <Canar> this problem is one that i've been stumped on literally for years, and my inability to figure it out in the past has actually prevented me from picking haskell up in the way i wanted to
01:23:21 <Sonarpulse> types?
01:23:41 <Canar> just the general spit-out-a-binary-file-from-an-array-of-doubles thing
01:23:46 <Sonarpulse> oh, yeah
01:23:57 <Canar> a bloody one-liner
01:23:59 <Canar> oh well
01:24:04 <Canar> got 'er now
01:24:07 <Sonarpulse> yeah
01:24:31 <Sonarpulse> it's not as consise as C, but it's hard to do binary stuff in lisp without huge function names
01:24:56 <Sonarpulse> no fromInteger
01:25:52 <Sonarpulse> and i with think the binary stuff in haskell, even if again, it's not as consise as some imperative language, the high-level concept of what you are trying to do, is there
01:26:10 <Sonarpulse> lot of inperative stuff it's all just implementation
01:26:24 <Sonarpulse> nobody else can figure out the purpose
01:29:00 <Sonarpulse> cya everybody
01:30:25 <Sculptor> good morning
01:50:02 * hackagebot aivika-experiment 0.2.1 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.2.1 (DavidSorokin)
01:50:04 * hackagebot aivika-experiment-chart 0.2.1 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.2.1 (DavidSorokin)
01:56:59 * killy9999 hates having boring labs on Saturday mornings
02:01:41 <merijn> killy9999: Which lab?
02:10:04 <killy9999> merijn: software engineering classes
02:16:48 <ion> Ok, haskell-src-exts wasn‚Äôt too bad for Haskell code generation. Language.Haskell.Exts.Build is very incomplete, though.
03:11:41 <nand`> Can you run the Q monad other than splicing it into your source code?
03:12:24 <nand`> oh, you can run it in IO
03:12:27 <nand`> and I guess other Quasi monads
03:13:52 <nand`> I wonder how feasible it would be then to use template haskell for actual Haskell code generation; the advantage being able to use quotes eg. for declarations
03:14:50 <shachaf> @ty concat .: replicate
03:14:52 <lambdabot> Int -> [a] -> [a]
03:15:00 <shachaf> Hmph.
03:15:46 <gienah> nand`: there's an old project that would need tweaking, it might help: zeroth
03:16:15 <gienah> nand`: although I guess that's not quite what you asked for :-/
03:16:23 <shachaf> "someone" ought to maintain zeroth
03:16:34 <nand`> it does look similar though
03:16:46 <nand`> in that it generates actual code from the TH splices
03:16:53 <nand`> I'm sure that portion could be factored out somehow
03:17:30 <shachaf> ...The zeroth Setup.lhs uses modules from the zeroth distribution?
03:17:43 <shachaf> Are you ridiculous?
03:18:34 <ion> The GHC build uses GHC. u mad?
03:19:56 <nand`> that's indeed funny
03:20:03 <shachaf> ion: me mad
03:20:16 <nand`> compiling Setup.lhs does indeed pull in Language.Haskell.TH.ZeroTH stuff
03:20:31 <shachaf> ion: This means that I can't use cabal to autodownload the dependencies it uses.
03:20:51 <typoclass> (is Setup.hs normally run in interpreted mode ...?)
03:21:00 <nand`> typoclass: depends
03:21:01 <shachaf> typoclass: Sometimes.
03:21:14 <shachaf> I just remembered that I don't like TH.
03:21:21 <shachaf> So I won't bother looking into what's making zeroth broken.
03:21:28 <typoclass> shachaf: is it the devil? ;-)
03:21:35 <nand`> typoclass: if you're running it manually; I think the most common is `runhaskell Setup.hs`; but build systems would compile it once and re-use the binary - on the other hand, stuff like cabal-install bypasses Setup.hs where possible
03:21:37 <shachaf> typoclass: What isn't?
03:22:02 <typoclass> nand`: i see, thanks
03:25:42 <neutrino> what do you guys think: rethinkdb: new mongodb?
03:25:57 <shachaf> hiptobecubic: GADTs = existential quantification + equality constraints
03:26:53 <typoclass> in other words, "forall" and "(... ~ ...) =>", isn't it
03:27:09 <shachaf> forall is universal, not existential
03:27:17 <shachaf> But the way you use it in GADTs it can be existential
03:27:20 <nand`> "exists" :(
03:27:21 <ion> universal crisis
03:27:29 <typoclass> shachaf: right
03:27:33 <shachaf> nand`: I bet you want *>, too.
03:27:37 <typoclass> nand`: i thought that didn't exist?
03:27:44 <ion> typoclass: I see what you did there.
03:27:47 <shachaf> typoclass: It definitely exists.
03:27:50 <shachaf> That's all it does.
03:28:11 <shachaf> (Anyway, UHC implements it.)
03:28:12 <nand`> shachaf: What's *> ?
03:28:26 <shachaf> nand`: Existential variant of =>
03:28:32 <typoclass> shachaf: no, i mean there is a 'forall' keyword, but there is not 'exists' keyword
03:28:35 <shachaf> I.e. a kind of pair, instead of a kind of function.
03:28:40 <shachaf> typoclass: UHC has that keyword.
03:29:05 <typoclass> s/there is/there is in ghc/
03:29:22 <nand`> ‚ÄòNum a *> a‚Äô is the same as ‚Äòexists a. Num a => a‚Äô
03:29:23 <nand`> ?
03:29:34 <shachaf> nand`: exists a. Num a => a doesn't make much sense.
03:29:47 <shachaf> nand`: (exists a. Show a *> a) ~ String
03:30:10 * typoclass scratches his head
03:30:12 <shachaf> nand`: Think about what type classes get translated into.
03:30:13 <nand`> oh, I see
03:30:15 <nand`> yeah
03:30:29 <shachaf> You need a pair, rather than a function.
03:30:36 <shachaf> Just like exists is a pair and forall is a function. :-)
03:30:42 <nand`> I was thinking in terms of ExistentialQuantification's data N = forall a. Num a => N a
03:30:57 <shachaf> Right, but that puts both the forall and the constraint outside.
03:31:09 <shachaf> Keep in mind that The Num dictionary is stored as part of the data type.
03:31:32 <shachaf> I.e. data Foo = forall a. (Show a, Read a, Num a, ..., ...) => Foo a will be like a huge tuple.
03:32:31 <nand`> it makes a bit more sense with GADTSyntax I think
03:32:37 <nand`> data Foo where Show a => a -> Foo
03:32:42 <shachaf> Yes.
03:35:31 * nand` vaguely remembers an SO answer that made the connection between a universal quantification on the constructor and existential quantification clear by transforming them into logical statements a la curry-howard
03:36:26 <shachaf> nand`: You can do it that way.
03:36:28 <ion> Hmm. If ‚Äúf :: forall a. Foo a => a -> a‚Äù ~ ‚Äúf :: Foo a -> a -> a‚Äù, ‚Äúf :: exists a. Foo a *> a -> a‚Äù ~ what?
03:36:31 <shachaf> I find the other way more intuitive. :-)
03:36:46 <shachaf> ion: exists a. (Foo a, a -> a)
03:37:26 <ion> Ah, alright.
03:37:39 <shachaf> That's why it has to be a different syntax. :-)
03:37:54 <shachaf> (exists a. Foo a => a -> a) makes no sense, because the person who consumes it has to supply the dictionary.
03:38:23 <shachaf> nand`: Anyway, it's pretty easy to see:
03:38:39 <shachaf> (exists a. Foo a) -> Bar === forall a. Foo a -> Bar
03:38:55 <nand`> http://stackoverflow.com/questions/10753073/whats-the-theoretical-basis-for-existential-types
03:38:56 <nand`> ah, found it
03:39:08 <shachaf> @google trebla any all
03:39:10 <lambdabot> http://www.vex.net/~trebla/weblog/any-all-some.html
03:39:10 <shachaf> nand`: ‚òù
03:39:10 <lambdabot> Title: Any, For All, Exists
03:39:29 <shachaf> Not everything has to be a stackoverflow question!
03:39:49 <neutrino> when do you make use of existential quantification?
03:41:06 <shachaf> Anyway, in most cases where you can translate to logic, reason about something, and translate back, there's more direct type intuition that you can use too.
03:41:14 <nand`> exceptions use them, for example
03:41:23 <shachaf> Exceptions are slightly the devil.
03:41:44 <shachaf> Oh, that was in reply to what's-his-name.
03:43:18 <neutrino> nand`: is there any simple pragmatic thing that uses them though?
03:43:24 <neutrino> exceptions are usually hacks in every language
03:43:45 <ion> Is this true? ‚Äúforall a. Show a => a -> String‚Äù ~ ‚Äú(exists a. Show a *> a) -> String‚Äù
03:44:05 <nand`> neutrino: I can't say that I've come across a situation where I needed them
03:44:22 <shachaf> ion: Looks right.
03:44:26 <ion> Ok, thanks
03:44:40 <shachaf> ion: You can transform from the latter to the former by currying.
03:44:54 <mauke> what's the *> ?
03:45:03 <shachaf> mauke: Like => but for exists
03:45:11 <shachaf> I.e. a tuple instead of a function.
03:45:45 <mauke> why does this look wrong to me, then?
03:45:46 <nand`> I guess a lot of OOP programmers would embrace existential quantification at first, since it reminds them of interface polymorphism
03:45:58 <nand`> but many of those situations can be dealt with much more elegantly using first class functions
03:46:24 <shachaf> mauke: Quite possibly because I'm saying nonsense. :-)
03:46:26 <shachaf> How is it wrong?
03:46:46 <nand`> I think the ‚Äò>‚Äô may be a bit misleading, since it's not like an arrow (whereas => is)
03:46:55 <nand`> exists a. Num a * a -- would have been better :)
03:47:02 <shachaf> nand`: True. *> is ski's notation.
03:47:03 <mauke> now it looks right again
03:48:04 <shachaf> mauke: "(a :: *) -> Show a -> a -> String", "((a :: *), Show a, a) -> String"
03:48:17 <shachaf> Now you can move back and forth with curry3/uncurry3. :-)
03:48:43 <shachaf> ion: You can apply this transformation to any "exists a. Foo a" value, by the way.
03:49:10 <shachaf> exists a. Foo a ----> forall r. ((exists a. Foo a) -> r) -> r ----> forall r. (forall a. Foo a -> r) -> r
03:49:30 <keep_learning> Hello All
03:49:31 <shachaf> (You have to either CPS or use a data type, though.)
03:50:47 <shachaf> ion: (That lets you see why it works with the GADT syntax: "data Blah where Blah :: (exists a. Foo a) -> Blah" ---> "data Blah where Blah :: forall a. Foo a -> Blah")
03:50:49 <keep_learning> I am trying to install ghc-7.6.1 in Mountain Lion and http://www.haskell.org/ghc/download_ghc_7_6_1 says "The package requires Xcode 4.1 ". Would it work if I install Xcode 4.5 ?
03:50:55 <nand`> I wonder if this has any connection to the yoneda lemma
03:50:59 <shachaf> (This is probably not helpful at this point. :-) )
03:51:28 <shachaf> nand`: So I'm told.
03:51:55 <shachaf> By the way, note that while (exists a. Show a *> a) ~ String, (forall a. Read a => a) ~ String
03:52:24 <nand`> Maybe String, surely :)
03:52:24 <shachaf> Since Read has the opposite variance-thing.
03:52:29 <shachaf> nand`: Quiet.
03:52:34 <shachaf> You know what I mean.
03:53:12 <nand`> oh, I'm wrong either way
03:53:26 <mauke> (forall a. Read a => a) ~ (forall a. a) ?
03:54:02 <nand`> the maybe would be in front of the ‚Äòa‚Äô; forall a. Read a => Maybe a
03:54:12 <shachaf> @ty (read "5")
03:54:14 <lambdabot> Read a => a
03:54:15 <nand`> (of course, that could just as well be Nothing)
03:54:29 <nand`> :t readMaybe "5" -- do we have this, incidentally?
03:54:30 <lambdabot> Not in scope: `readMaybe'
03:54:32 <nand`> :(
03:54:34 <nand`> no GHC 7.6.1?
03:54:37 <shachaf> Nope.
03:55:17 <shachaf> mauke: In particular, newtype Foo = Foo String; instance Read Foo where read = Foo -- assuming we had "class Read a where read :: String -> a", which is a lie, of course.
03:55:23 <neutrino> nand`: why does exist remind of interface polymorphism?
03:55:36 <neutrino> nand`: i thought forall would remind of interface polymorphism
03:55:37 <shachaf> Which lets us get the String back out of the forall a. Read a => a
03:57:11 <mauke> I still don't quite get what the Read constraint is doing there
03:57:42 <nand`> neutrino: for an example in C#; interface IShow { string Show { get }}; now a value of type ‚ÄòIShow‚Äô ~ String;  similarly class Show a where show :: a -> String -- a value of type exists a. Show a *> a ~ String
03:57:42 <shachaf> mauke: read "blah" :: forall a. Read a => a
03:58:03 <ion> shachaf: Ah, the CPS example was interesting.
03:58:31 <nand`> In the C# example ‚ÄòIShow‚Äô just tells you ‚Äòthis is some ‚Äòa‚Äô which has a property of type string‚Äô; whereas the exists example tells you ‚Äòthis is some ‚Äòa‚Äô which has a way to turn that into a string‚Äô <- in the C#, the first parameter to ‚Äòshow‚Äô is sort of passed along implicitly, but it's the same situation
03:59:15 <shachaf> nand`: Can you have the equivalent of (forall a. Read a => a) in C#?
03:59:56 <nand`> shachaf: I can't think of any way off the bat
04:00:23 <mapf> IShow a; or void f(IShow a) {}
04:00:25 <mapf> why not?
04:01:20 <mauke> shachaf: struct Foo { template<typename T> operator T() const { ... } }; :-)
04:01:23 <neutrino> nand`: i am afraid i don't know what ~ means?
04:01:38 <nand`> loosely speaking, ‚Äòis equivalent to‚Äô
04:02:35 <mauke> it goes both ways!
04:03:13 <shachaf> mauke: It's more obvious if you think of things in terms of functions instead of constraints.
04:03:24 <shachaf> (Also, if you think of things in terms of functions instead of foralls!)
04:03:30 <shachaf> (Functions make everything simple.)
04:03:45 <mauke> inb4 lambda calculus
04:04:40 <shachaf> ion: Also note that it's sort of like double-negation.
04:05:01 <mauke> did you mean: "not unlike"
04:05:10 <shachaf> Yes, that.
04:05:22 <shachaf> any p x ~~ not (all (not . p) x)
04:06:02 <shachaf> (exists x. P x) ~~ Not (forall x. Not x)
04:06:19 <shachaf> Not x = x -> Void, so that's (forall x. x -> Void) -> Void
04:06:29 <shachaf> Except we use a universally-quantified r instead of Void
04:06:56 <ion> shachaf: Interesting
04:07:34 <ion> > show Void
04:07:36 <lambdabot>   Not in scope: data constructor `Void'
04:07:56 <ion> err
04:08:03 <ion> > (undefined :: Void)
04:08:04 <lambdabot>   Not in scope: type constructor or class `Void'
04:08:04 <hpaste> nand` pasted ‚Äúforall a. Read a => a‚Äù at http://hpaste.org/77847
04:08:09 <shachaf> I assume we can also do this backwards.
04:08:09 <nand`> shachaf: ^ this is the closest you can get
04:08:17 <shachaf> (forall x. P x)
04:08:19 <shachaf> forall r. (exists x. P x -> r) -> r
04:08:28 <shachaf> Of course, we still need a forall in the result to make any use of it. :-)
04:08:31 <shachaf> So it's not as nice.
04:08:39 <shachaf> If we had DNE, on the other hand...
04:09:25 <shachaf> nand`: You use (lisp \n    (style)) braces in C#?
04:09:26 <ion> DNE?
04:09:29 <shachaf> Doesn't everyone hate you for it?
04:09:33 <shachaf> ion: Double-negation elimination
04:09:50 <shachaf> (:: Void (Void a) -> a, = law of excluded middle)
04:10:07 <shachaf> nand`: I mean, not me. But C# people.
04:10:18 <nand`> shachaf: I'm just trying to make braces as invisible as possible. I refer to indentation when reading my code; and include the appropriate number of closing braces when going back an indentation level
04:10:21 <ion> Do you mean Not (Not a) -> a?
04:10:26 <nand`> and yes, they hate me for it
04:10:28 <shachaf> ion: Er, yes.
04:11:17 <shachaf> When you're used to Haskell and intuitionistic logic and such, it feels like forall and functions and things are much more natural than exists and pairs and things.
04:11:30 <shachaf> I wonder whether there's a dual sort of logic where exists is natural and forall isn't.
04:11:33 <merijn> shachaf: Pffft
04:11:43 <shachaf> Saizan?
04:12:06 * merijn likes his existential quantification even after being used to haskell and intuitionistic logic
04:12:41 <shachaf> merijn: I didn't say I don't like it! Just that it seems less natural.
04:13:32 <neutrino> nand`: i'm sort of having trouble understanding your interfaces example
04:15:00 <Saizan> shachaf: oh, btw, the "free functor functor" (or however we want to call it) is Yoneda
04:15:37 <shachaf> Saizan: And what's the generator?
04:16:03 * shachaf doesn't really know much about this.
04:16:08 <Saizan> shachaf: a non-necessarily functor of kind * -> *
04:16:22 <nand`> neutrino: perhaps this would make the connection clearer? http://www.haskell.org/haskellwiki/Existential_type#Dynamic_dispatch_mechanism_of_OOP
04:16:36 <Saizan> i mean, a type of kind * -> * with no addition
04:17:17 <nand`> what's the connection between yoneda and codensity?
04:17:24 <nand`> codensity gives you a monad from any * -> *, right?
04:17:37 <Saizan> http://hackage.haskell.org/packages/archive/kan-extensions/3.1/doc/html/Data-Functor-Yoneda.html
04:18:00 <shachaf> What about Coyoneda?
04:18:08 <shachaf> Why is Coyoneda called Yoneda these days? :-(
04:18:22 <Saizan> nand`: Yoneda f = Ran Identity f; Codensity f = Ran f f
04:18:56 <nand`> ah yes
04:19:20 <shachaf> Fork f = Ran Away Spoon
04:19:57 <mauke> is this real code or are you just messing with me now?
04:20:17 <shachaf> Who?
04:20:25 <shachaf> Everything up to what I said was real, I think.
04:20:41 <nand`> Saizan's is definitely real
04:21:43 <mauke> 'Fork f = Ran Away Spoon' might as well be dadaist poetry
04:22:23 <shachaf> Yes, that's just nonsense.
04:22:25 * nand` .oO( forall b. (a -> Away b) -> Spoon b )
04:24:43 <aristid> nand`: why are you making one type variable explicit, and not the other?
04:24:46 * Saizan wonders what's the categorical way to say "type of kind * -> *"
04:25:13 <shachaf> aristid: The other one is a parameter.
04:25:31 <nand`> (‚àÉx. F x ‚áí y) = ((‚àÄx. F x) ‚áí y) makes a surprising amount of sense once you try to think about it intuitively
04:25:38 <aristid> shachaf: what?
04:25:44 <neutrino> nand`: Shape is the existential type, yes?
04:25:51 <nand`> though the forward transformation makes a bit more sense than the reverse one
04:26:19 <nand`> aristid: well, I should have been more explicit; that's the expanded form of ‚ÄòFork f a‚Äô
04:27:07 <neutrino> nand`: they both are simple transformations.
04:27:52 <shachaf> nand`: It works in the other direction too?
04:28:09 <neutrino> left to right: all x make F x true, therefore that one x mentioned on the left makes F x true, therefore y is implied by it.
04:28:15 <nand`> in english; ‚ÄúIf we know that if every x being F implies y; then there is at least one x such that x being F implies y‚Äù
04:29:00 <aristid> shachaf: i don't think so. at least not constructively
04:29:19 <nand`> shachaf: well, I pulled that = from the bottom of http://www.vex.net/~trebla/weblog/any-all-some.html
04:30:04 <neutrino> right to left: the fact that F is being true for all inputs implies y means that there exists an input such that F x implies y.
04:30:20 <neutrino> right to left: the fact that F being true for all inputs implies y means that there exists an input such that F x implies y.
04:30:55 <shachaf> nand`: OK, but does it work constructively?
04:32:18 <neutrino> this one is proven easily ad-absurdum: suppose that all x are such that F x /=> y. Then the tautology (forall x. F x) is true, but the right hand of the implication on the right side might not be.
04:32:18 <merijn> nand`: Wait. While the second follows from the first they're not equivalent
04:32:31 <neutrino> this is not allowed therefore we have arrived at a contradiction.
04:32:48 <shachaf> merijn: Not in Haskell. :-)
04:33:03 <merijn> If y only follows from *all* F x being true, then you cannot say that there exists an F x which implies y
04:33:14 <neutrino> merijn: read what i just wrote.
04:33:37 <shachaf> merijn: It's saying that there exists an x such that F x implies y
04:34:20 <merijn> shachaf: Sure, but I don't think the forall version is equivalent
04:34:38 <nand`> shachaf: I don't know
04:34:40 <merijn> i.e. I agree the forall follows from the exists case, but not necessarily vice versa
04:34:54 <shachaf> merijn: Not even in logic?
04:34:57 <ramses_> is there a simple way to validate a bunch of arguments to a function and return all errors encountered? Like some monoid instance to mappend all the errors to
04:35:03 <merijn> shachaf: I was thinking in logic
04:35:08 <nand`> probably not
04:35:32 <neutrino> merijn: can you invalidate the proof i attempted just now?
04:35:39 <shachaf> (exists x. P(x) -> y) vs. ((forall x. P(x)) -> y)
04:36:00 <shachaf> Which direction don't you like again?
04:36:06 <merijn> neutrino: Your mistake is that the bracketting of the forall case is written "((‚àÄx. F x) ‚áí y)"
04:36:10 <shachaf> forall -> exists?
04:36:23 <merijn> neutrino: If it was written "(‚àÄx. (F x ‚áí y))" then you'd be right
04:37:07 <neutrino> merijn: bear in mind that if (forall x. F x) is not true, then we have no way to infer that y is true
04:37:47 <merijn> neutrino: Yes, but if forall x . F x *is* true then it does not necessarily follow that "(‚àÉx. F x ‚áí y)"
04:38:07 <merijn> Because the latter says "there is an x for which "F x" implies y"
04:38:13 <neutrino> merijn: yes, but we're in a construction ad-absurdum
04:38:40 <neutrino> hmm
04:38:41 <merijn> But if y is only implied by "forall x . F x" that is not necessarily true
04:39:41 <merijn> So while the forall clearly follows from the exists (i.e. if the exists statement is true then the forall is true as well), but not vice versa
04:40:16 <merijn> Because if there exists an x so that "F x implies y" then clearly "forall x . F x" must imply y
04:40:27 <neutrino> if we negate the left side we get forall x. ~ (F x => y). This means that forall x. F x & ~ y. This means that ~y.
04:40:41 <neutrino> so on the right we're left with ((forall x. F x) => False)
04:41:10 <shachaf> merijn: Why not?
04:41:14 <shachaf> Just pick any x
04:41:30 <shachaf> Er, never mind.
04:41:33 <merijn> Negating the left side must be "~ forall x. (F x => y)", no?
04:41:56 <neutrino> no, negating the left side is ~ exists x. (F x => y)
04:42:02 <shachaf> merijn: Oh, yes.
04:42:03 <merijn> oh, duh
04:42:09 <shachaf> merijn: Consider: Either y is true or it's false.
04:42:14 <shachaf> If y is true, then you can just pick any x
04:42:16 <neutrino> negating a quantifier flips it and the term it quantifies
04:42:26 <shachaf> If y is false, then you can pick some particular x which is a counterexample.
04:42:32 <shachaf> This is the same as the pub paradox. :-)
04:42:45 <neutrino> ~ (p => q) = p & ~ q
04:42:53 <nand`> (‚àÄx:‚àÖ. F x) ‚áí ‚ä§  -- is trivially true;  but ‚àÉx:‚àÖ. F x ‚áí ‚ä§ -- can't be true, can it?
04:43:05 <neutrino> I don't know
04:43:15 <merijn> nand`: Correct, afaik
04:43:28 <nand`> oh
04:43:37 <nand`> there's an extra condition
04:43:40 <shachaf> Hence "non-empty pub"
04:43:41 <maxedmelon> hello peeps, does anyone know how to show the call stack evaluation step by step in ghci?
04:43:42 <nand`> yes
04:44:12 <merijn> shachaf: I wasn't actually following the discussion, I just saw the equivalence with no conditions on it and that can't be right
04:47:56 <neutrino> merijn: see how that implication works now?
04:48:45 <shachaf> So why does the "any" not have that condition?
04:49:05 <shachaf> Or does it?
04:50:37 <shachaf> Oh, it's because you have to provide a pair rather than a function.
04:53:04 <merijn> neutrino: No, still don't see the equivalence
04:55:14 <merijn> "forall x. F x & ~ y" either there is no x and it's trivially true, or the truth value depends on all xs and the value of y. "(forall x. F x) => False" is only true if there are xs and F x is false for each
04:56:07 <neutrino> merijn: "forall x. F x & ~y" means that y, which is not dependent on x, is tautologically false for all x.
04:56:13 <merijn> A trivial case where their not identical suppose the set of x is empty, then "forall x . F x & ~y" is true and "(forall x . F x) => False" is clearly false
04:56:13 <neutrino> this means that y is tautologically false.
04:56:30 <neutrino> therefore the implication on the right, which has y on its right side, can never hold.
04:56:35 <neutrino> but it's part of our assumptions.
04:56:45 <merijn> neutrino: Which assumption?
04:56:49 <neutrino> therefore, by using ad-absurdum, we have arrived at a contradiction.
04:56:51 <neutrino> wait
04:57:14 <neutrino> we're trying to prove  (‚àÉx. F x ‚áí y) <= ((‚àÄx. F x) ‚áí y)
04:57:18 <neutrino> right-to-left
04:57:22 <neutrino> we are assuming the right side
04:57:45 <neutrino> we have assumed ad-absurdum that the left does NOT hold. from this we have arrived at y being tautologically false.
04:57:56 <neutrino> therefore the right side is whatever => False
04:57:56 <merijn> neutrino: I think nand` made a typo in the line I read
04:58:09 <merijn> neutrino: He was stating the two are equivalent
04:58:15 <neutrino> yes
04:58:22 <neutrino> we're arguing about the implication from right to left
04:58:30 <neutrino> since the implication from left to right is easy
04:58:33 <merijn> "< nand`> (‚àÉx. F x ‚áí y) = ((‚àÄx. F x) ‚áí y)"
04:58:39 <neutrino> yes
04:58:44 <merijn> I was just observing that that equality is false
04:58:48 <neutrino> logical equality is the same as two implications
04:58:55 <neutrino> we have proven the implication towards the right
04:59:06 <neutrino> i am explaining to you my idea on how to prove the implication towards the left
04:59:15 <shachaf> merijn: But it's true if F's domain is nonempty?
04:59:34 <neutrino> merijn, (x = y)  if and only if (x <= y) and (x => y)
04:59:46 <merijn> sec
04:59:52 <merijn> have to move my laptop
05:03:00 <neutrino> you done yet? :)
05:03:18 <merijn> oh, bah, I see it
05:03:26 <shachaf> ?
05:03:45 <neutrino> ok explain it to me
05:04:46 <merijn> If y is false than (forall x . F x) has to be false, which means that there is at least one x for which F x is false. Which means "exists x . F x => y" as there must be an x for which F x is not true
05:05:59 <shachaf> And if y is true?
05:06:19 <merijn> Than the left hand side of the implication is irrelevant
05:06:23 <merijn> s/than/then
05:06:34 <shachaf> Yes, but how can you say (exists x. F(x) -> y)?
05:07:11 <neutrino> merijn: that's not it
05:07:13 <neutrino> but you're close
05:07:49 <merijn> shachaf: That holds for any non-empty set in the case that y is true
05:07:56 <neutrino> if y is false then (forall x. F x) has to be false, BUT we are free in choosing any F that we want and apply it because it's a free variable.
05:08:25 <neutrino> in specific we can choose F = const True
05:08:30 <shachaf> Sure. But what if the set is empty?
05:08:36 <neutrino> which means that forall x. F x cannot be false.
05:08:37 <shachaf> That was the point, I thought.
05:08:48 <neutrino> merijn: following so far? :)
05:08:50 <merijn> shachaf: I dunno, I never saw the original question/problem
05:08:53 <shachaf> For the other direction, we don't need that condition.
05:08:57 <shachaf> Er, not other direction.
05:09:00 <shachaf> For the dual.
05:09:49 <merijn> neutrino: Wait, why would you be allowed to make up any arbitrary F? You have to work with every possible F, no?
05:10:30 <shachaf> Yes.
05:10:45 <shachaf> neutrino is, I assume, just trolling.
05:12:04 * merijn is coming back to his original assumption that the equivalence is wrong
05:12:30 <nand`> oh my, what did I start
05:13:23 <shachaf> merijn: I think it's correct if it's nonempty?
05:13:34 <merijn> shachaf: Sure, but that precondition wasn't stated
05:13:55 <merijn> (I just wrote down the proof for nonempty sets)
05:14:20 <neutrino> merijn: yes, every possible F, and in specific the arbitrary F = const True
05:14:24 <merijn> But then neutrino started saying we could chooise any F and then things quickly became nonsense and the empty set case is still not proven
05:14:28 <shachaf> merijn: Well, it *was* stated in the article nand` linked to. :-)
05:14:43 <merijn> neutrino: No, you can't do that
05:14:48 <neutrino> of course you can
05:14:53 <shachaf> I'm not concerned with what neutrino says.
05:14:58 <Saizan> you can do that if you want to disprove it.
05:15:07 <neutrino> the formula has a "forall F" prepended to it implicitly
05:15:30 <shachaf> merijn: My question is why the precondition is required for this equality but for its dual.
05:15:33 <shachaf> Or whether it is, or what.
05:15:46 <merijn> I think neutrino is just trying to argue my case by counter example... of the opposite of what I was saying
05:15:53 <neutrino> if you want to disprove forall F. Theorem(p, q, F) then you can take some F that makes Theorem untrue and you win
05:16:06 <Saizan> i.e. if you want to prove (forall F. ...) -> False, you can pick a specific F to use the premise
05:16:14 <neutrino> merijn: i'm arguing ad-absurdum and then by counter-example, yes.
05:16:26 <merijn> Saizan: Yes, but why bother? We had already arrived at the conclusion it was false for non-empty sets without neutrino's babbling about F
05:16:43 <merijn> eh
05:16:44 <neutrino> merijn: you haven't
05:16:47 <merijn> false for empty sets, that is
05:17:02 <Saizan> shachaf: which is the dual one?
05:17:13 <neutrino> merijn: you got confused along the way :)
05:17:58 <shachaf> Saizan: ((‚àÉx. P x) -> Q) ~ (‚àÄx. P x -> Q)
05:18:00 <neutrino> merijn: by the way, if you don't want any help - that's ok, but i'm here currently only to help you understand this since you seemed interested. it's not mandatory for either of us.
05:18:06 <merijn> neutrino: You claimed we were assuming "(forall x. F x) => y" to be true, which restricts your choice of F to F's for which that formula holds, obviously
05:18:33 <merijn> Because otherwise your starting premise is false to begin with
05:18:51 <neutrino> that's *exactly* the whole point of ad-absurdum proof
05:19:12 <neutrino> you start with a premise, make an assumption opposite to the one you're trying to prove, and from that arrive at the falsity of your premise
05:19:19 <neutrino> have you never used this proof method?
05:19:37 <neutrino> i can see why you'd think it was gibberish
05:19:54 <neutrino> but listening to shachaf talk shit about me won't help you become better at basic logic
05:20:10 <merijn> I have, but I just wandered into the discussion half way so I think we're not even arguing in the same discussion
05:20:40 * merijn is no longer clear what people were even trying to proof in the first place
05:20:43 <neutrino> right, well we were trying to prove the <= part of the theorem by ad-absurdum, since nand` said it's not immediately clear
05:21:09 <neutrino> we were trying to prove this: (‚àÉx. F x ‚áí y) <= ((‚àÄx. F x) ‚áí y)
05:21:19 <neutrino> which, combined with this: (‚àÉx. F x ‚áí y) => ((‚àÄx. F x) ‚áí y)
05:21:25 <neutrino> yields this: (‚àÉx. F x ‚áí y) = ((‚àÄx. F x) ‚áí y)
05:21:54 <Saizan> shachaf: i guess because it's implicit in the fact that they are giving you an x
05:22:11 <neutrino> however the right-pointing implication was simple, so we skipped it other than a simple english-language proof.
05:24:14 <shachaf> Saizan: Right.
05:24:27 <shachaf> It seems like there ought to be a more satisfying explanation for why one direction has extra preconditions.
05:24:33 <masq> reverse $ sort list  <- is there a built in way to do this without reverse?
05:24:35 <shachaf> Er, not direction.
05:24:37 <shachaf> Dualthing.
05:24:46 <shachaf> masq: sortBy (flip compare)
05:25:05 <masq> thanks
05:25:12 <shachaf> > sortBy (flip compare) "hello there"
05:25:15 <lambdabot>   "trollhheee "
05:25:51 <nand`> lol
05:25:59 <aristid> shachaf: a subtle trolling ;)
05:26:26 <nand`> that's disturbingly similar to ‚Äútroll heehee‚Äù
05:26:38 <shachaf> That was the goal.
05:34:27 <neutrino> hey, guys, does this look OK for anyone who knows linear algebra? http://hpaste.org/77848
05:35:07 * hackagebot cmdargs 0.10.1 - Command line argument processing  http://hackage.haskell.org/package/cmdargs-0.10.1 (NeilMitchell)
05:36:46 <sipa> neutrino: it's correct afaics
05:37:11 <neutrino> thank you! it's very good to get someone's eyes on this for validation
05:37:20 * neutrino buys sipa a beer.
05:45:07 * hackagebot language-haskell-extract 0.2.2 - Module to automatically extract functions from the local code.  http://hackage.haskell.org/package/language-haskell-extract-0.2.2 (OscarFinnsson)
05:50:07 * hackagebot language-haskell-extract 0.2.3 - Module to automatically extract functions from the local code.  http://hackage.haskell.org/package/language-haskell-extract-0.2.3 (OscarFinnsson)
05:51:08 <trudko> guys is there syn. sugar for writing type definition for functions I am used to write public String myF(String param1, String param2) in Java not sure whhy I have to write (or do I?)  myF :: (Int,Int)-> Int and then on next line myF(x,y) = etc
05:52:34 <shachaf> "because"
05:52:40 <aristid> trudko: you can omit the type declaration usually, although it is recommend to write it out for documentation purposes
05:52:52 <neutrino> is there a data type which is a 3d matrix which can be rotated and flipped? i'm happy with using libraries. 2d matrices are good too.
05:52:59 <neutrino> the matrix only needs to hold boolean values.
05:53:14 <Dodek> why would you want to rotate a matrix?
05:53:33 <neutrino> because it's a representation of a 2d object
05:53:41 <neutrino> in fact it's something like a bitmap
05:53:58 <Dodek> so you want to rotate bitmaps actually.
05:54:00 <shachaf> trudko: With a GHC extension you can write f ((x::Int), (y::Int)) = ...
05:54:04 <shachaf> trudko: But please don't do that.
05:54:06 <shachaf> It's terrible.
05:54:12 <neutrino> 1-bit bitmaps that are three-dimensional
05:54:25 <neutrino> do you know of a library that has something like this?
05:54:31 <trudko> shachaf:  i promisse i wont :D
05:54:35 <Dodek> sorry, i don't.
05:54:36 <trudko> yeah it looks odd
05:54:45 <neutrino> that's ok :)
05:55:07 <trudko> ok so I wil just write it on two lines
05:55:13 <trudko> not that big dill but it just seems odd
05:55:20 <trudko> deal
05:55:21 <trudko> lol
05:56:10 <shachaf> The type of the function doesn't really have anything to do with the implementation of the function
05:56:17 <shachaf> foo :: [Int] -> [Char]
05:56:18 <antonio_> .
05:56:19 <shachaf> foo = map chr
05:56:51 <rwbarton> or you might have multiple pattern matching lines
05:56:51 <trudko> I aggree shachaf
05:57:52 <shachaf> With that said, giving names to arguments for documentation's sake might be nice.
05:58:09 <shachaf> foo :: (blah :: Int) -> (blam :: Char) -> ...
05:58:14 <shachaf> In Agda you get this for free. :-)
05:58:21 <aristid> shachaf: that's pseudo-haskell, right?
05:58:49 <shachaf> aristid: Yes.
05:58:55 <shachaf> But with s/::/:/ it's real Agda!
05:59:06 <shachaf> aristid: You should implement type holes in GHC.
05:59:09 <shachaf> It would be the future.
05:59:17 <rwbarton> s/\w+ ::/{- \1 -}/
05:59:25 <aristid> shachaf: the fuuuuture
05:59:49 <neutrino> type holes sound like fun.
05:59:55 <shachaf> rwbarton: Sure.
06:00:07 * hackagebot test-framework-th 0.2.3 - Automagically generate the HUnit- and Quickcheck-bulk-code using Template Haskell.  http://hackage.haskell.org/package/test-framework-th-0.2.3 (OscarFinnsson)
06:00:42 <shachaf> rwbarton: Or, more standardfully, foo :: Int {- ^ Blah blah -} -> Char {- ^ Blam blam -} -> ...
06:00:54 <shachaf> Hmm, I don't know if Haddock documentation works with {--} comments.
06:01:09 <shachaf> rwbarton is the only person I ever see using {--} comments in this channel.
06:03:11 <mpu> When I need to compose two functions but the first one takes two arguments, is there something simpler than: f p = fromJust . M.lookup p
06:04:12 <shachaf> mpu: Don't use fromJust. :-(
06:04:24 <mpu> why that ?
06:04:29 <neutrino> mpu:
06:04:30 <shachaf> @pl \f g x y -> f (g x y)
06:04:31 <lambdabot> (.) . (.)
06:04:34 <shachaf> Hmm.
06:04:37 <shachaf> @pl \x y -> f (g x y)
06:04:38 <lambdabot> (f .) . g
06:04:46 <neutrino> @pl foo x = bar (baz x) x
06:04:46 <lambdabot> foo = bar =<< baz
06:04:48 <shachaf> Also known as f .: g, but that's not in the standard library.
06:04:54 <rwbarton> that combination exists alread anyways
06:04:56 <shachaf> I would recommend just giving the parameter a name.
06:05:00 <rwbarton> (p M.!)
06:05:05 <shachaf> Yes.
06:05:09 <rwbarton> or f = (M.!)
06:05:23 <shachaf> mpu: fromJust is an unsafe function -- it'll crash your program if it gets a Nothing, and you'll get a completely useless error message.
06:05:42 <shachaf> Well, for that matter that's true about (M.!) too. But I don't feel as bad for that one.
06:05:54 <mpu> shachaf: but it won't get a nothing
06:06:01 <shachaf> You can say let Just x = M.lookup x y in ... if you want a nice error message.
06:06:08 <mpu> shachaf: I could write a proof of it
06:06:08 <shachaf> mpu: You say that now!
06:06:14 <shachaf> Proofs are good.
06:06:22 <shachaf> Unfortunately GHC can't process them.
06:06:30 <mpu> it is an invariant of my data structure
06:06:38 <aristid> shachaf: you're just mad you can't write all your code in agda
06:07:05 <shachaf> mpu: Then maybe write a function specialized to the type of your data structure.
06:07:19 <mpu> shachaf: it is
06:07:28 <shachaf> That function can do evil fromJust nonsense -- though it would still be better if it didn't use fromJust, but did explicit pattern matching or something -- but then you only have to do it once.
06:07:35 <mpu> shachaf: though I did not include the type
06:07:40 <neutrino> aristid: i used to be mad because none of the code i wrote for work was haskell.. now i'm mad because all of it is.
06:07:50 <neutrino> it's almost exactly the same feeling.
06:08:27 <invariant> neutrino, shouldn't you be happy?
06:08:35 <mpu> neutrino: funny :), programming is a pain whatever language
06:08:45 <shachaf> If you're using fromJust so often that making it pointfree is significant savings, then you should probably adjust your code to use fromJust less.
06:08:59 <aristid> mpu: i think there was some philosopher who insisted that all life is pain
06:09:00 <shachaf> Once you're using fromJust less, you can do explicit pattern matching instead. :-)
06:10:00 <mpu> shachaf: why do you want me to remove this fromJust? In this case this is exactly what I want I know the Map must contain the value, o.w. the proper behavior is to crash badly
06:10:23 <shachaf> Crashing badly is OK, but it'll crash badly with the error
06:10:25 <shachaf> > fromJust Nothing
06:10:28 <lambdabot>   *Exception: Maybe.fromJust: Nothing
06:10:36 <shachaf> Which is a completely useless error.
06:10:43 <invariant> shachaf, it's easy to work around that.
06:10:44 <shachaf> There won't be a stack trace.
06:10:50 <shachaf> invariant: ?
06:11:01 <typoclass> mpu: with pattern matching, you'll at least see the line number and file name. fromJust doesn't do that
06:11:03 <invariant> shachaf, preprocessor macros.
06:11:32 <shachaf> invariant: #define fromJust fromMaybe (error $ __FILE__ ++ show __LINE__) ?
06:11:45 <invariant> shachaf, something like that.
06:11:49 <shachaf> That's pretty terrible.
06:11:59 <shachaf> fromJust isn't really something to be treated casually. :-)
06:12:05 <invariant> shachaf, terrible?
06:12:08 <shachaf> It's worth the extra line and slight hassle when you want to use it.
06:12:11 <invariant> shachaf, I think it's great.
06:12:21 <invariant> shachaf, there is no extra hassle.
06:12:47 <invariant> shachaf, anyway, what's your fantastic solution?
06:13:01 <shachaf> Pattern-matching on the Just.
06:13:15 <typoclass> invariant: that needs -XCPP on all your files, doesn't it?
06:13:30 <mpu> shachaf I'd rather use a function that already exists
06:13:33 <invariant> typoclass, that depends on your build system.
06:13:46 <invariant> typoclass, but most easily, yes.
06:14:01 <rwbarton> you can also get the same effect with TH
06:14:19 <mpu> and you could simply define a function
06:14:36 <shachaf> mpu: How about fromMaybe (error "mpu's invariant is broken") ?
06:14:40 <typoclass> invariant: hm ... you mean you'd run it through gcc with that flag to only expand macros and output the source code?
06:14:42 <shachaf> @ty fromMaybe (error "oh no")
06:14:44 <lambdabot> Maybe a -> a
06:14:46 <shachaf> That has the right type.
06:14:56 <neutrino> invariant: i think mpu put it the best way
06:15:25 <invariant> neutrino, his function?
06:15:32 <mpu> shachaf: whatever
06:15:34 <invariant> neutrino, it's a bad idea.
06:15:36 <neutrino> 15:07 < invariant> neutrino, shouldn't you be happy?
06:15:36 <neutrino> 15:07 < mpu> neutrino: funny :), programming is a pain whatever language
06:15:42 <invariant> neutrino, ah, ok.
06:15:45 <neutrino> :)
06:15:59 <mpu> invariant: why that?
06:16:00 <invariant> neutrino, programming is a game.
06:16:09 <neutrino> a game?
06:16:13 <neutrino> what kind of game?
06:16:13 <shachaf> mpu: Anyway, (M.!) is exactly the function you want, and it already exists.
06:16:29 <invariant> mpu, because you don't want to write similar functions over and over.
06:16:35 <invariant> neutrino, man vs machine.
06:16:44 <typoclass> mpu: the problem with defining a function yourself is that you then get filename and line number pointing only to that function, which isn't much useful either
06:16:55 <invariant> neutrino, it's like solving cross-word puzzles, except on a more advanced level.
06:17:04 <mpu> invariant: I was giving another solution for the #define
06:17:14 <neutrino> i guess that makes sense
06:17:23 <mpu> typoclass: oh, I see
06:17:32 <rwbarton> can i TH splice an infix operator?
06:17:32 <invariant> mpu, that wasn't clear, because you didn't use any macro.
06:17:32 <neutrino> but it's also a bit like hauling bricks up the stairs.
06:17:47 <invariant> neutrino, tedious?
06:17:57 <neutrino> tiring.
06:18:02 <fmap> I guess it's hard to understand why `let Just ..' is better than `fromJust' until you get something like `Prelude.head: empty list' buried in N levels of libraries.
06:18:33 <fmap> but then it's easy :]
06:19:03 <rwbarton> just use this http://hpaste.org/76740
06:19:07 <neutrino> how do you use let Just ?
06:19:12 <typoclass> realistically, the choice is between a custom error message (by using shachaf's fromMaybe (error ...)), or the default error message (by letting a pattern-match fail)
06:19:33 <byorgey> fmap: how is  let Just ... any better ?
06:19:42 <shachaf> byorgey: It gives you a line number when the match fails.
06:19:53 <byorgey> oh, hehe, I see
06:20:01 <typoclass> rwbarton: interesting, what package is that?
06:20:07 * byorgey never uses either
06:20:10 <neutrino> fmap: could you show an example of code that uses let Just ?
06:20:13 <shachaf> I don't really care which solution you use as long as it's not fromJust. :-)
06:20:26 <rwbarton> something i hacked up one day, haven't published it anywhere
06:20:38 <typoclass> shachaf: seeing how it is the devil
06:20:45 <shachaf> rwbarton: Unfortunately that doesn't work for someone else's library.
06:20:55 <rwbarton> it does
06:21:01 <rwbarton> well
06:21:10 <typoclass> rwbarton: oh nice. can it show the line number and file name?
06:21:26 <rwbarton> it works when your code calls someone else's library which fails, at least you know where in your code the call to that library was
06:21:31 <shachaf> True.
06:21:36 <fmap> neutrino: yeah, `let Just x = Nothing in x'
06:21:40 <rwbarton> typoclass: no, TH doesn't seem to have that information
06:21:42 <typoclass> > let (Just x) = Nothing in x -- neutrino
06:21:44 <lambdabot>   *Exception: <interactive>:3:5-22: Irrefutable pattern failed for pattern (D...
06:21:56 <typoclass> rwbarton: hm, interesting
06:22:11 <neutrino> fmap: so you use it to prevent functions from being able to error out?
06:23:01 <rwbarton> i guess if there is a way for TH to produce a TH splice maybe it can be done
06:24:33 <rwbarton> there doesn't seem to be one though (and it would feel a bit silly)
06:25:07 <rwbarton> run a TH splice to get new code full of smaller TH splices and then run TH again
06:28:38 <rwbarton> I considered using a haskell-src-exts-based quasiquoter but abandoned that idea for some reason I now forget
06:32:05 <bitonic> edwardk: hey, I'm still not sure what the best way to traverse nested `Scope's while keeping a context is.  The problem is that when I reach variables I won't know what type they are, so I won't be able to, say, index a list with my context in it.  is the best way just to always instantiate with the content instead of keeping a context?
06:32:33 <edwardk> bitonic: thats pretty much what i do
06:32:46 <bitonic> edwardk: you mean always instantiate?
06:32:51 <edwardk> yeah
06:33:07 <bitonic> mhm... OK.  I think I lose some clarity that way - or maybe I'm just too used to that.
06:33:11 <edwardk> i instantiate them to meta or skolem variables, go down do my unification and then abstract them back out
06:33:16 <bitonic> right
06:34:05 <edwardk> the nice thing is you never have to worry about meta variables leaking into places they can't go, because they aren't in your ast as a primitive construction, etc.
06:35:03 <bitonic> OK, I'll try that approach then.  I'll just instantiate to some synthetic name
06:37:41 <edwardk> i go through and reduce all my free variables to where they don't exist any more. then i have forall a. Exp a -- a closed term. you can use 'closed' from Bound to convert to that.
06:38:30 <edwardk> once i have a closed term i start building up from the outside in meta/skolem variables. which is just another free variable type to me. i can build them with builtin IORefs even to get unification to work in the classic imperative-but-fast sense
06:38:54 <edwardk> then i go through and abstract away to build up the bound variables again when generalizing
06:39:19 <bitonic> edwardk: I wasn't talking about type inference now, but just type checking in a dep. typed setting
06:39:37 <bitonic> but I get what you're saying
06:39:38 <edwardk> this scheme actually prevents me from screwing up inference by forgetting to abstract, etc.
06:39:49 <edwardk> ah. dolio has a pure type system hacked up with bound lying around
06:40:02 <edwardk> you might ask him for where the repo is
06:40:35 <bitonic> edwardk: I think I'll manage, thanks for telling me :)
06:43:18 <edwardk> bitonic: http://code.haskell.org/~dolio/upts/Language/UPTS/TypeCheck.hs
06:44:02 <bitonic> edwardk: cool
07:01:43 <mapf> it's possible to do something like data A :: Nat -> * -> * where ...
07:01:46 <mapf> ?
07:02:20 <mapf> i hear about some extension but forgot its name
07:02:27 <shachaf> DataKinds?
07:02:46 <mapf> shachaf: thanks
07:07:24 <mapf> DataKinds so elegant integrated, any datatype is automatically promoted to datakind
07:07:28 <mapf> aw
07:08:06 <startling> mapf, you should learn idris or agda. :)
07:09:21 <mapf> startling: nope, it's too early to me)
07:11:31 <startling> mapf: hehe
07:21:22 <mpu> As an internal model when programming in Haskell, do you think it is reasonable to think it strict?
07:22:19 <Philonous> shachaf:  You have to admit he is rather subtle.
07:22:40 <byorgey> mpu: not really.
07:22:40 <mpu> I think I do this in my subconscious and I am reminded of the laziness when I get an output I did not expected.
07:23:10 <edwardk> mpu: that should tell you that it isn't the best model then ;)
07:23:28 <hpc> mpu: eventually you get used to thinking lazily
07:23:46 <hpc> then you'll get annoyed by other languages where you can't express a problem as a fold on an infinite list
07:23:51 <hpc> or something like that
07:24:00 <byorgey> just don't worry about it until you get an answer you didn't expect.  Then learn about laziness just enough to understand what happened.
07:24:05 <rwbarton> what exactly does "an output you did not expect" mean anyways?
07:24:22 <rwbarton> if the strict version would produce output, the lazy version will produce the same output
07:24:25 <shachaf> Philonous: ?
07:24:36 <sipa> if you assume the programming language is strict, you'll still get correct answers from a lazy one, i think
07:24:47 <rwbarton> but maybe you mean a program produced an output when you expected it to run forever
07:25:05 <Philonous> shachaf:  Never mind
07:25:14 <shachaf> Philonous: You mean in #-blah?
07:25:22 <Philonous> shachaf:  Yes
07:25:28 <mpu> byorgey: That is what I do. I know lazyness quite well (finished a Master thesis in CS) but I am still surprised (quite often in a pleasant way) because my program outputs "more" than it shoud have in a strict setting :)
07:25:39 <shachaf> Philonous: Yes, well, benefit of the doubt and all.
07:26:15 <mpu> rwbarton: no
07:26:28 <Philonous> shachaf:  I think he is rather good. Getting the entire channel wound up but leaving no tangible grounds for intervention
07:26:54 <rwbarton> what is this, #haskell-blah-blah
07:27:06 <shachaf> rwbarton: Is that where we talk about lenses on lenses?
07:27:21 <Philonous> rwbarton:  Sorry about that.
07:27:57 <edwardk> shachaf: sadly without impredicative types its hard to write lens-lenses
07:28:11 <copumpkin> wrap 'em up
07:28:24 <mpu> rwbarton: The haskell program I wrote would have (in a strict setting) said nothing while it started to output stuff.
07:30:34 <wlangstroth> hi all - anyone know of a way to pass test options to cabal test by default in a user's .cabal/config file?
07:35:10 <merijn> rwbarton: Modulo out of memory exceptions? :p
07:35:31 <mpu> Can I 'deriving (Random)' on a user defined type?
07:36:05 <rwbarton> merijn: well, yes, but that can go the other way too
07:36:11 <merijn> True :)
07:39:58 <geekosaur> mpu: only if it's made out of something that already has a Random instance; it's not one of the typeclasses the language knows how to build arbitrary instances for.  (there may be a package which provides a TH-based way to do that though)
07:40:51 <mreh> I just got this message from UHC "ehc: No match in record selector forextractEnt" and I'm totally stumped
07:41:04 <mreh> seems like there is a space missing in the last word, but even then
07:41:34 <mreh> that symbol doesn't appear anywhere in my program
07:41:55 <mreh> which is about 50 lines
07:43:00 <geekosaur> forextractEnt might be something inside of ehc, and that would make this an internal error (possibly reflecting an error that is not properly being related to the original source)
07:46:05 <atriq> I'm writing a library to connect to the Tumblr API, but can't think of a name
07:46:12 <atriq> "hstumblr">
07:46:15 <atriq> *?
07:47:12 <mreh> heh
07:47:26 <mreh> geekosaur, yeah, you're probably right
07:47:45 <mreh> atriq: just call it tumblr
07:47:51 <pckt> humblr to obvious?
07:48:14 <Sculptor> humbly
07:49:25 <atriq> pckt, I'll go with that
07:49:28 <typoclass> atriq: i think "hstumblr" could be mistaken for "h-stumbler"
07:49:36 <typoclass> atriq: er, yeah :-)
07:49:51 <eikke> anyone who ever wanted to implement a block device using Haskell -> I just pushed 'nbd', a lib to write NBD servers. Documentation is WIP. Check see https://github.com/NicolasT/nbd
07:50:09 * hackagebot alpha 0.9999 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.9999 (MarcCoiffier)
07:50:22 * geekosaur trying to come up with a more punny one but something like roughs is probably not obvious enough...
07:51:00 <shachaf> 0.9999?
07:51:03 <shachaf> That's a nice scheme.
07:51:27 <ski> neutrino : were you attempting to prove `(‚àÉx. (F x ‚áí y)) ‚áê ((‚àÄx. F x) ‚áí y)', or trying to show that if `(‚àÄx. F x) ‚áí y' is provable (with `F' a predicate symbol, `y' a propositional symbol), then `‚àÉx. (F x ‚áí y)' is provable ?
07:51:46 <typoclass> eikke: oh wow interesting :-) so, it provides a thingy in /dev which is fed by a remote machine?
07:51:57 <atriq> Now to make sure I'm calling it what it is
07:52:06 <atriq> I think it's a wrapper for the Tumblr API?
07:52:23 <eikke> typoclass: NBD is a kernel module which can be used to access block devices exposed over a network, and expose it as a blockdev in /dev yes
07:52:39 * shachaf sleep
07:52:47 <eikke> typoclass: *but* it's also a neat way to implement block devices in userspace (and then run the server on localhost)
07:53:01 <otters> @pl \p -> (lim - snd (head p), lim - snd (last p))
07:53:02 <lambdabot> ap ((,) . (-) lim . snd . head) ((-) lim . snd . last)
07:53:05 <ski> (shachaf : i son't recall calling it "nonfree" specifically ..)
07:53:08 <hamid> > let (_, a:_ ) = a in (1,"hello")
07:53:10 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = (t0, [t1])
07:53:12 <shachaf> ski: NonFreeMonoid
07:53:12 <otters> :t (&&&)
07:53:14 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
07:53:20 <hamid> i don't get this :|
07:53:23 <ski> ok
07:53:25 <shachaf> I think?
07:53:31 <shachaf> I might not remember correctly.
07:53:33 <eikke> typoclass: I did a very rough benchmark of exposing a large file using my demo server in that repo, then dd the /dev device to /dev null, and do the same from the file itself (after flushing caches twice), and results were comparable
07:53:36 <ski> (i just meant that it was not the free monoid)
07:53:44 <shachaf> ski: Ah.
07:53:46 <shachaf> Sure.
07:53:52 <ski> "non-(free-monoid)"
07:53:59 <shachaf> Right. It was a bit of a pun.
07:54:09 <typoclass> eikke: interesting, i've got to read up on these things. i've on and off used the haskell fuse binding that allows you to write userspace filesystems
07:54:10 <shachaf> I was wondering to what sorts of classes that technique can work with.
07:54:32 <typoclass> eikke: thanks for the explanation :-) sounds great. looking forward to checking out your git repo
07:54:33 <shachaf> Is there a better way to apply it to Functor than what I said?
07:54:42 <ski> you need the result type to be one of the class parameters at least, i think
07:54:49 <hamid> what's this infinit type that ghci complains about :/
07:54:51 <hamid> > let (_, x:_ ) = x in (1,"hello")
07:54:53 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = (t0, [t1])
07:54:58 <shachaf> ski: Right.
07:55:06 <shachaf> So it wouldn't work with things like Eq and Show
07:55:14 <shachaf> It'd sort of work with Read, but be pretty boring.
07:55:44 <merijn> hamid: You have x in both the left and right hand side
07:55:48 <merijn> hamid: With different types
07:56:00 <hamid> aha!
07:56:04 <hamid> merijn, thanks :)
07:56:09 <eikke> typoclass: yeah, somewhat comparable to Fuse, but you don't need to bother about FS things :P only read/write blocks (and some optional stuff). API is not frozen or anything alike now, but shouldn't drift too much
07:56:11 <hamid> > let (a, x:_ ) = x in (1,"hello")
07:56:12 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = (t0, [t1])
07:56:29 <ski> shachaf : do you mean the `data Foo a = Some a | forall o. Map (o -> a) (Some o)' thing ?
07:56:44 <sipa> hamid: you still have x left and right with different type
07:57:02 <merijn> hamid: Your type is "(a, [b])" where b has to be the type "(a, [b])" infinitely recursing, since you use x as first item in the list
07:57:09 <sipa> hamid: do you mean to do this?
07:57:20 <ski> shachaf : did you intend to have one data constructor `Some' there, and one type constructor `Some' ?
07:57:26 <sipa> > let (a, x:_) = (1,"hallo") in x
07:57:28 <lambdabot>   'h'
07:57:34 <shachaf> ski: Er, that last Some was meant to be Foo
07:57:49 <ski> oh
07:57:59 <shachaf> Foo a ~ (Nat,a) in this case
07:59:22 <hamid> merijn, i kinda get it what did you mean by left and right sides! i thought you meant sides of the (:) operator :P
07:59:41 <ski> the `Some a' case doesn't correspond to a type class method -- hm, i suppose it's the injection, as with `NLeaf a' in `data Nonoid a = NLeaf a | NEmpty | NAppend (Nonoid a) (Nonoid a)'
07:59:52 <shachaf> Right.
08:00:05 <shachaf> I don't quite like that but I don't know what else to put there.
08:00:32 <shachaf> You could have Foo f a = Some (f a) | forall o. Map (o -> a) (Foo o), I guess.
08:00:38 <hamid> sipa, thanks i was following something like this tryhaskell.org : let (a:_) = a in "xyz"
08:00:40 <shachaf> Er, Foo f o
08:00:52 <hamid> > let (a:_) = a in "xyz"
08:00:54 <lambdabot>   Occurs check: cannot construct the infinite type: t0 = [t0]
08:01:29 <hamid> nope :P so it was what you mentioned
08:01:31 <ski> hm, though that's more powerful
08:01:49 <shachaf> Yes.
08:02:01 <ski> (`Foo f a' is no longer iso to `Nat * f a')
08:02:31 <shachaf> Right.
08:02:40 <shachaf> Well, unless f is a ("real") functor?
08:02:42 * ski wonders whether that is right
08:03:14 <shachaf> If f = (-> Bool) then it doesn't seem right, for instance.
08:03:19 <shachaf> Er, then it does seem right.
08:03:29 * shachaf is really rather tired.
08:04:01 <ski> if `f' is a functor, then we can map all the functions -- and we can't inspect the existentials, so that seems to really be all we can do, apart from counting them
08:04:23 <shachaf> Right.
08:04:37 <shachaf> I don't really like the existential there, it was just the obvious thing to do. :-)
08:04:50 <ski> e.g. if `f' is `Maybe', then is `t :: f o' is `Nothing', then `fmap fun t :: f a' will also be `Nothing'
08:05:05 <ski> s/then is/then if/
08:05:46 <ski> so i don't think you can observe anything more about `f o' than about `f a' (though vice versa is not true, since `a' can be known)
08:07:12 <ski> hm, if `f = (-> Bool)' ..
08:08:00 <shachaf> Then there's nothing you can do with the function, since it's contravariant.
08:09:29 <ski> yes, but `Foo f a' then seems the same as `Nat * f a', yes ?
08:09:35 <ski> hm
08:09:43 <ski> oh, right, no
08:09:55 <shachaf> Not if you have a Map
08:10:00 <ski> because you can't `fmap' from `o -> Bool' to `a -> Bool' (with `a' known)
08:10:01 <shachaf> You can't get an "o" to use the predicate with.
08:10:27 <shachaf> Or an "a", depending on your perspective. :-)
08:10:49 <ski> well, since `a' is known, you could possibly get an `a'
08:10:55 <shachaf> Well, not in general.
08:11:17 <shachaf> ...Not that you have any functor laws to worry about or anything.
08:11:21 <ski> meaning that you can do more with `Nat * f a' (for some `a's) than with `Foo f a', so they're not iso
08:11:39 <shachaf> Right.
08:12:31 <Rogach> Q: Is there a way to detect window closing event in X11 library?
08:12:39 <ozgura> you know how --make is the defualt in ghc 7? then, how can I stop ghc from linking and creating an executable?
08:12:50 <shachaf> ozgura: Don't name your module Main.
08:13:14 <atriq> Okay, hmm
08:13:15 <shachaf> Otherwise, pass it the "don't link" option.
08:13:15 <ozgura> shachaf: but I sometimes want to link and create an executabel
08:13:19 <atriq> What should I call this module
08:13:35 <shachaf> ozgura: $ man ghc | grep link # :-)
08:13:35 <atriq> Web.Tumblr?
08:13:48 <shachaf> (It's -c.)
08:14:02 <hpc> @hackage ghc-man-completion
08:14:02 <lambdabot> http://hackage.haskell.org/package/ghc-man-completion
08:14:13 <ozgura> shachaf: oh damn, I did not rtfm'ed enough again.
08:15:31 <ozgura> shachaf: thanks, that works!
08:16:43 <shachaf> dne :: forall a. (forall m. Monad m => (a -> m Void) -> m Void) -> a; dne e = case e Left of Left x -> x; Right _ -> undefined
08:16:46 <shachaf> Clever.
08:16:56 <copumpkin> undefined!
08:17:08 <shachaf> copumpkin: That's totally fine, man.
08:17:22 <shachaf> I, uh, promise it'll never be reached.
08:17:51 <copumpkin> :(
08:18:14 <shachaf> copumpkin: Can you do it better in Agda?
08:18:44 <Eduard_Munteanu> Double negation elimination? You can just postulate it. :)
08:18:59 <shachaf> Eduard_Munteanu: This isn't postulating it, man. That's an actual function!
08:19:01 <ski> shachaf : s/Right _ -> undefined/Right u -> void u/
08:19:23 <shachaf> ski: Oh, good point.
08:19:27 <copumpkin> ahhh
08:19:29 * copumpkin hugs ski
08:19:42 <shachaf> I guess Oleg wrote that in a pre-void world.
08:20:07 <shachaf> ski++
08:20:07 <copumpkin> void is the gentleman's undefined
08:20:10 <ski> with `void u = seq u (error "can't happen")' or something -- blaming the one you thought they'd sneak a bogus `Void' value in there :)
08:20:28 <ski> s/you thought/who thought/
08:20:28 <shachaf> copumpkin: void is called absurd these days, I hear.
08:20:37 <copumpkin> that's absurd!
08:20:41 <shachaf> ski: You probably want pseq. :-)
08:20:53 <ski> shachaf : hm, yeah, just realized that
08:25:18 <otters> > [a,b,c,d]
08:25:21 <lambdabot>   [a,b,c,d]
08:29:49 <shachaf> Ah, let lem1 :: (forall m. Monad m => (a -> m w)) -> (forall m. Monad m => (a -> m Void) -> m w) -> w; lem1 pos neg = case neg Left of Right y -> y; Left y -> runIdentity (pos y)
08:29:53 <shachaf> No absurd needed.
08:30:20 <shachaf> oleg++
08:30:25 <shachaf> "We show how to program with the law of excluded middle. We specifically avoid call/cc, which is overrated."
08:33:10 <Eduard_Munteanu> shachaf: where's that from
08:33:12 <Eduard_Munteanu> ?
08:33:15 <shachaf> http://okmij.org/ftp/Computation/lem.html
08:34:50 <shachaf> Really it should be obvious. You get to pick the monad, so just pick one that makes ((a -> m Void) -> m Void) ~ ((a -> a) -> a), and then pass id.
08:34:58 <Eduard_Munteanu> That's basically Agda's Dec in some way, no?
08:35:15 <shachaf> I don't know.
08:35:25 <Eduard_Munteanu> Or a classical monad.
08:35:28 <ski> `Dec' ?
08:35:49 <Eduard_Munteanu> ski: decidable propositions
08:36:07 <Eduard_Munteanu> Dec P ~= P V ~P
08:36:45 <shachaf> Can you prove that something is decidable in Agda without actually deciding it?
08:37:11 <atriq> I decided to go and get a drink
08:37:25 <atriq> Therefore the problem of whether I should get a drink or not is decidable
08:37:26 <atriq> brb
08:38:04 <mauke> yes, I need a drink, alcoholic of course
08:38:15 <ski> shachaf : i'm not sure i like that that effectively requires us to know `a -> w'
08:38:31 <shachaf> @@ @run @where pi_10
08:38:33 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
08:39:06 <shachaf> ski: ?
08:39:09 <ski> @. pl where pi_10
08:39:09 <lambdabot> take 100 [show (foldr (((20 * 100 ^ n +) .) . (*) . ap div ((1 +) . (2 *))) 0 [1..[4,8..] !! n]) !! n | n <- [0..]]
08:39:23 <ski> shachaf : `lem1'
08:39:25 <Eduard_Munteanu> shachaf: well, if you postulate or otherwise require LEM, *all* propositions are decidable.
08:40:15 <trudko> guys I am puzzled by currying please help me out multThree :: (Num a) => a -> a -> a -> a  multThree x y z = x * y * z
08:40:25 <shachaf> ski: Why?
08:40:28 <ski> shachaf : converting in the other direction, from `w' to `a' (or converting to a common target) would be nicer, imo
08:40:47 <Eduard_Munteanu> trudko: ok, what puzzles you?
08:40:51 <shachaf> ski: w *is* the common target, isn't it?
08:41:02 <trudko> so from what I red -> if I do multThree 1 2 3 . First you I take 1 and return function ?
08:41:04 <shachaf> lem1 ~ (a -> w) -> (Not a -> w) -> w
08:41:05 <ski> shachaf : because with `a -> w' essentially assumed, you can't set `w' to `Void' and get anything useful out of it
08:41:38 <ski> (note, setting `w' to `Void' would get `(a -> m Void) -> m w' into `(a -> m Void) -> m Void')
08:41:46 <mauke> http://www.cadaeic.net/naraven.htm
08:42:06 <Eduard_Munteanu> trudko: yes, you can rewrite that as multThree x = \y z -> x * y * z
08:42:41 <trudko> Eduard_Munteanu: ok so  but what happends inside of function? does it store  three then  or?
08:43:03 <shachaf> ski: I'm not sure I follow.
08:43:33 <mauke> trudko: multThree = \x -> \y -> \z -> x * y * z
08:43:41 <ski>      multiThree 1 2 3
08:43:47 <trudko> Eduard_Munteanu: or let me repharse i am reading learn you haskell  they say First, 3 is applied to multThree
08:43:50 <ski>   =  (\x -> \y -> \z -> x * y * z) 1 2 3
08:43:59 <ski>   =  (\y -> \z -> 1 * y * z) 2 3
08:44:04 <trudko> what does it mean that 3 i sapplied to multthree
08:44:06 <Sonderblade> any string replace function in haskell?
08:44:07 <ski>   =  (\z -> 1 * 2 * z) 3
08:44:14 <ski>   =  1 * 2 * 3
08:44:17 <ski>   =  2 * 3
08:44:19 <ski>   =  6
08:44:22 <shachaf> ski: Oh, now I see what you mean.
08:44:26 <mauke> trudko: no, multThree is applied to 1
08:44:29 <trudko> what do you mean by \z \y?
08:44:48 <shachaf> ski: Your (a -> m w) function doesn't get a continuation, so it has to use "return"
08:44:49 <Eduard_Munteanu> trudko: those are lambdas, or anonymous functions
08:44:53 <trudko> mauke sorry yes  so what doe sit mean that multThree is applied to one
08:44:54 <ski> trudko : `\x -> x ^ 2' is *the* function that, when given an input, call it `x', returns `x ^ 2'
08:45:06 <Eduard_Munteanu> > (\x -> x + 2) 3
08:45:08 <lambdabot>   5
08:45:22 <mauke> trudko: \x -> B is a function with a parameter x and a body B
08:45:28 <trudko> sec let me read what you wrote you are super helpful but I am getting cofused :)
08:45:44 <ski> shachaf : yes, `forall m. Monad m => (a -> m w)' hides a `a -> w' function inside, since `m' can be `Identity'
08:45:46 <trudko> btw by anychance any javascript programmer ? maybe it is possible to explain me it in JS terms
08:46:06 <mauke> trudko: function (x) { return B }
08:46:15 <shachaf> function(x) { return function(y) { return x * y; } }
08:46:18 <rwbarton> just run it through ghcjs
08:46:29 <otters> I don't even understand why this won't work
08:46:31 <otters> http://hpaste.org/77851
08:46:34 <rwbarton> (Note: don't do this.)
08:46:35 <shachaf> rwbarton: I feel like there should be some kind of unhelpfulness award for a comment like that.
08:46:43 <ski> trudko : when `multThree' is called with `1' as argument, you can think of it as returning a function that waits for the `y' and `z' arguments, and when given them, will return `1 * y * z'
08:46:58 <ski> tumdum : iow, it returns the function `\y -> \z -> 1 * y * z'
08:47:05 <ski> trudko ^
08:47:06 <bitonic> edwardk: OK, dolio's code is smarter than mine :)
08:47:18 <edwardk> bitonic: =)
08:47:26 <edwardk> dolio's a pretty smart guy
08:47:34 <shachaf> rwbarton: We need multiple levels of #haskell, such that all the jokes get filtered out for the people asking questions.
08:47:42 <rwbarton> yes
08:47:50 <shachaf> And lambdabot always provides a level-1 answer with Prelude and a level-N answer with Caleskell
08:47:54 <ski> trudko : another way of thinking about it is that when given `1', it returns `\y -> \z -> x * y * z' together with recalling that in *this* case, `x' is actually `1'
08:47:58 <bitonic> edwardk: looks like it ehe
08:48:04 <Eduard_Munteanu> I should totally play #haskell on nightmare level.
08:48:07 <trudko> shachaf: what you write is for function with 2 not 3 parameters  am I right so it should be function(x) { retunr function(y) {return function(z) { x*y*z}}}
08:48:07 <rwbarton> surely you mean lenskell
08:48:17 <mauke> trudko: var multThree = function (x) { return function (y) { return function (z) { return x * y * z; }; }; };
08:48:31 <mauke> trudko: multThree(1)(2)(3)
08:48:43 <rwbarton> otters: looks pretty ambiguous to me
08:48:50 <bartavelle> Eduard_Munteanu, having list respawning once you have consumed them quickly gets old
08:48:51 <rwbarton> i take it you have OverloadedStrings in ghci?
08:48:55 <trudko> k let me think about it
08:49:22 <Eduard_Munteanu> bartavelle: you just have to kill the thunk shaman :P
08:50:13 <bartavelle> Eduard_Munteanu, I am still playing the 1.9 version, it doesn't have all the fancy monsters
08:50:21 <shachaf> ski: His other lem is :: (forall m. Monad m => (a -> m w, (a -> m F) -> m w)) -> w
08:50:26 <otters> rwbarton: yessir
08:50:40 <typoclass> shachaf: i actually agree with that, i don't think it looks too good if some newbie asks a question and the first 4 responses are jokes and mocking and useless non-answers
08:50:42 <trudko> ski, mauke, skachaf, Eduard_Munteanu  thx javascript example helped ok  my question would be isnt that bit complicated for doing something simple?
08:50:47 <bartavelle> (that would be the thunk elemental : http://doom.wikia.com/wiki/Pain_elemental)
08:50:51 <trudko> or I just guess that I will found out later dont i ? :)
08:51:17 <mauke> trudko: it's more parts, but the parts alone are simpler
08:51:33 <Eduard_Munteanu> trudko: it actually simplifies functions a lot
08:51:44 <otters> rwbarton: the only instance for IsString that is also an instance for SourceLike is Text
08:51:44 * shachaf appreciated the ghcjs comment, mind you.
08:51:45 <mauke> e.g. Haskell doesn't need special "parameter lists"
08:52:09 <rwbarton> otters, ghc doesn't know that though
08:52:20 <mauke> every function takes exactly one argument
08:52:48 <monochrom> @quote monochrom curry
08:52:49 <lambdabot> monochrom says: I am 17-ary, going on 18-ary, I can take curry of you
08:52:51 <ski> shachaf : hm, looks like basically the same thing
08:52:56 <shachaf> ski: Yep.
08:53:18 <rwbarton> otters: it never does logic like "welp i guess there's only one instance this could be given the current instances in scope so i'll just pick that one i guess"
08:54:10 <shachaf> -XWelpInstances
08:56:17 <shachaf> ski: But of course if a ~ Void, you can just use absurd to make w
08:56:36 <ski> yes
08:56:41 <rwbarton> otters: why not just make Keypath an instance of IsString directly, and not have (&) be overloaded
08:56:44 <ski> but if `a' is `Bool' (say)
08:58:51 <latermuse> so arrows are just functions right? and all monads are arrows, but not all arrows are monads?
08:59:12 <merijn> latermuse: No, functions are just arrows
08:59:20 <atriq> latermuse, Arrows are a generalization of functions
08:59:23 <merijn> latermuse: There are things which are arrows but not functions
08:59:27 <latermuse> ah i was backwards then :)
08:59:30 <shachaf> Uh oh, "Arrow" discussion.
08:59:34 <shachaf> It's an omen.
08:59:37 * shachaf goes to sleep.
08:59:59 <merijn> latermuse: Did you read the paper introducing arrows? I can recommend it, the beginning is very readable
09:00:20 <latermuse> yes, ive read it and i know how to use most of the functions in Control.Arrow
09:00:37 <latermuse> just trying to grasp my way around the theory behind it all now
09:01:16 <merijn> latermuse: Not all monads are arrows, btw
09:01:28 <merijn> latermuse: Actually, yes they are
09:01:40 <latermuse> so functions are just arrows, and all monads are arrows
09:01:42 <merijn> latermuse: But not all arrows monads, that was the direction
09:01:51 <latermuse> but not all arrows are monads
09:01:55 <mauke> kind error
09:02:13 <nand`> not all monads are arrows, strictly speaking
09:02:14 <merijn> latermuse: The basic idea was "functions seem to have some nice general properties that apply to other things too"
09:02:27 <atriq> Functions are the simplest kind of arrow that I can think of
09:02:30 <felix2> but all monads give rise ton an arrow
09:02:53 <felix2> (I'm not sure what I said means something)
09:03:07 <latermuse> where do comonads fit into the "monad - arrow - function" trifecta?
09:03:26 <atriq> All Monads have a corresponding Kleisli arrow
09:03:27 <nand`> felix2: take IO for a counterexample
09:03:44 <atriq> newtype Kleisli m a b = Kleisli (a -> m b)
09:03:59 <atriq> Similarly, all Comonads have a corresponding Cokleisli arrow
09:04:12 <atriq> newtype Cokleisli w a b = Cokleisli (w a -> b)
09:04:18 <nand`> atriq: that makes the types line up but the laws don't necessarily have to hold
09:04:58 <atriq> nand`, do they not? I thought the monad laws were equivalent to the arrow laws for the relevant kleisli category
09:05:12 <nand`> iirc there was some law to the effect of (f *** g) >>> (h *** i) = (f >>> h) *** (g >>> i)
09:05:35 <rwbarton> that is a Cale-arrow law
09:07:29 <rwbarton> it's a good law, but not usually regarded as one of the arrow laws
09:07:35 <nand`> ah, okay
09:08:36 <latermuse> did the cale who is always in this irc write that law?
09:09:35 <rwbarton> well that is the Cale I'm talking about yes
09:09:45 <latermuse> neat :)
09:09:51 <rwbarton> anyone can write down a law
09:10:18 <rwbarton> Cale is an advocate of it being regarded as a standard Arrow law, though
09:10:32 <rwbarton> or at least, of a standard [Something]Arrow law
09:11:11 <nand`> wasn't the term for that ‚Äòpure arrow‚Äô?
09:11:25 <rwbarton> if you draw the arrows-and-boxes diagrams it is a pretty obvious law to write down
09:12:16 <nand`> I think a consequence of that law is first f >>> second g = second g >>> first f
09:12:28 <rwbarton> yep
09:12:39 <rwbarton> in fact that is equivalent
09:13:29 <rwbarton> since once you have that, then first f >>> second g = second g >>> first f = f *** g
09:13:42 <rwbarton> and then you can use that to rearrange the terms in the original law
09:13:45 <nand`> yes makes sense
09:14:12 <latermuse> interesting :)
09:14:30 <aristid> does the kleisli arrow instance satisfy that law?
09:14:42 <nand`> for certain monads
09:14:43 <nand`> but not all
09:14:50 <Saizan> only if the monad is commutative, iirc
09:15:09 <aristid> ah, so it can't be a standard arrow law :)
09:15:18 <aristid> can't lose the generic kleisli arrow!
09:20:11 * hackagebot hlint 1.8.35 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.35 (NeilMitchell)
09:22:54 <Saizan> losing it is kind of the point
09:28:34 <RickJ> Where can I find list of built-in functions in Haskell 2010?
09:29:24 <merijn> RickJ: What do you mean by built-in?
09:29:29 <merijn> The Prelude?
09:29:45 <geekosaur> buit-in is not really a concept
09:29:51 <RickJ> nope, the low-level built-in functions like +,- and ...
09:30:11 <RickJ> Prelude is written in Haskell itself
09:30:12 <c_wraith> those aren't built-in
09:30:16 <c_wraith> they're defined in libraries
09:30:17 <rwbarton> what exactly is "built-in" is up to the compiler
09:30:17 <copumpkin> nothing is built in
09:30:21 <geekosaur> http://www.haskell.org/onlinereport/haskell2010/haskellch9.html#x16-1710009 (prelude) http://www.haskell.org/onlinereport/haskell2010/haskellpa2.html#x20-192000II (standard libraries)
09:30:24 <typoclass> RickJ: most of haskell is written in haskell itself ...
09:30:34 <ziman> is there an edsl for csg-style 3D graphics, something like byorgey's 2D diagrams?
09:30:45 <RickJ> typoclass: I am searching for the part that is not written in Haskell
09:30:48 <merijn> RickJ: It depends on the compiler which low level primitives are used
09:31:06 <monochrom> clearly, Char and Int cannot be implemented in Haskell
09:31:22 <merijn> RickJ: I think that's mostly some bits of the runtime system?
09:31:32 <monochrom> anyway, + is in the Prelude
09:31:38 <merijn> RickJ: As people said, most of Haskell is written in Haskell
09:31:38 <copumpkin> @src Num
09:31:39 <lambdabot> class  (Eq a, Show a) => Num a  where
09:31:40 <lambdabot>     (+), (-), (*)           :: a -> a -> a
09:31:40 <lambdabot>     negate, abs, signum     :: a -> a
09:31:40 <lambdabot>     fromInteger             :: Integer -> a
09:31:49 <copumpkin> there are two levels of Haskell in Haskell and people are confusing them though
09:31:55 <rwbarton> http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Num.html#Num has GHC's definition of (+) for Int (scroll down a bit)
09:31:58 <rwbarton> yep
09:32:01 <nand`> the Prelude is built in; in that Haskell implementations have to offer it
09:32:08 <nand`> other than that, it's implementation specific
09:32:23 <geekosaur> RickJ, maybe you mean GHC.Prim
09:32:25 <nand`> I think ultimately the only thing that needs to really be primitive in implementations is the C FFI
09:32:32 <rwbarton> do you want to see the implementation of (+#)? clearly this is a very compiler-specific thing
09:32:32 <copumpkin> all the libraries (i.e., functions you call) are written in Haskell, possibly calling out to low-level primitives provided by GHC (which is itself written in Haskell, but that's a separate question)
09:32:34 <typoclass> RickJ: as far as i know, part of the RTS (runtime system) is written in c
09:32:54 <rwbarton> let's just pick one question at a time shall we
09:32:57 <merijn> typoclass: But even then only a fairly small part, afaik
09:33:04 * copumpkin sighs
09:33:04 <nand`> parts of GHC are written in C, and parts are in Cmm
09:33:09 <nand`> but GHC is not Haskell
09:33:16 <nand`> please do not equate the two
09:33:26 <copumpkin> that's not even what I'm talking about
09:33:45 <typoclass> RickJ: could you tell us more about what you're planning to do?
09:33:50 <byorgey> ziman: you can in theory do 3D stuff with diagrams, though no one has yet fleshed out the library you would need
09:33:50 <geekosaur> doesn't jhc do all its primops via ffi?
09:33:57 <geekosaur> maybe I'm misremembering
09:34:01 <RickJ> ok if I rephrase: where can I find list of "primitive" functions in GHC?
09:34:05 <copumpkin> GHC.Prim
09:34:08 <byorgey> ziman: though it would not currentl support CSG easily
09:34:28 <copumpkin> RickJ: none of them are visible to you as an application programmer though, unless you go out of your way to use them
09:34:37 <byorgey> but that's certainly something interesting to think about.
09:34:59 <copumpkin> RickJ: in fact, you can't even type their names without activating a language extension
09:35:49 <rwbarton> byorgey: have you thought at all about a bitmap image library
09:36:07 <copumpkin> there's that REPA bitmap image library, but I really dislike its API
09:36:13 <byorgey> rwbarton: in what sense?
09:36:14 <typoclass> RickJ: so, you are investigating some source code and can't understand its behavior ...?
09:36:19 <copumpkin> well, specifically for loading BMPs
09:36:30 <RickJ> yes, I am just interested in the internals of the language/compiler... somewhere the compiler should loosen up  and call native/primitive functions
09:36:33 <rwbarton> well, since diagrams exists... it would be nice to have something compatible/analogous for dealing with bitmap images
09:36:41 <merijn> RickJ: Why should it?
09:36:58 <rwbarton> writing a repa-based imagemagick-like library is somewhere on my todo list
09:37:06 <byorgey> rwbarton: yes, that's true.  I mean I have thought about it enough to think "that would be nice".  But I haven't thought deeply about what that would actually look like.
09:37:11 <rwbarton> okay
09:37:12 <RickJ> linking?
09:37:15 <rwbarton> yeah, that's what I was asking :)
09:37:20 <nand`> rwbarton: I'm not sure what interface you're thinking of here
09:37:36 <rwbarton> nand`, neither am i!
09:37:38 <nand`> bitmaps aren't very composable in the way diagrams are, since their pixels have to line up, no?
09:37:39 <rwbarton> but i hate imagemagick
09:37:47 <byorgey> diagrams is about vector graphics at a very fundamental level
09:37:49 <Sonderblade> @hoogle isDigit
09:37:50 <lambdabot> Data.Char isDigit :: Char -> Bool
09:37:53 <copumpkin> RickJ: many/most of the primitives in GHC.Prim expand either to calls to the (haskell) code generator in GHC that produces appropriate low-level code that gets translated to assembly, or to calls to the RTS which is written in Cmm or C
09:38:02 <typoclass> RickJ: well, there's the ffi, which allows haskell source code to call c functions, if that's what you mean. the ffi works pretty well and is easy to use in practice. however, i don't know if "the internals" of the language use it very much
09:38:05 <rwbarton> nand`, you can still put two bitmap images next to each other
09:38:34 <rwbarton> just thinking of them as 2D arrays of pixels
09:38:36 <nand`> yeah, or overlay them; but the fundamental interface would probably be very different to diagrams
09:38:44 <rwbarton> right
09:38:53 <rwbarton> well, it would have some things in common, and not other things
09:39:07 <ziman> a friend of mine asked for a recommendation what languages he could use to create 3D objects programatically so I went right to Hackage but got surprised nobody had made such a library yet
09:39:19 <ziman> while haskell would be a very fine language for that, imho
09:39:44 <copumpkin> someone make an idiomatic translation of CGAL to haskell
09:39:46 <nand`> there are a bunch of libraries for that, iirc
09:39:47 <rwbarton> ziman: I seem to recall a ... something gloss-like for 3d
09:39:50 <copumpkin> since you can't really bind to it
09:39:50 <ziman> perhaps that's an opportunity to make a contribution :)
09:39:53 <nand`> there's diagrams, for one
09:40:01 <byorgey> ziman: http://hackage.haskell.org/package/mecha ?
09:40:11 <nand`> there are a few ray tracers that concern themselves with this; there's also ImplicitCAD which manipulates 3d shapes
09:40:20 <ChristianS> ziman: there is https://github.com/colah/ImplicitCAD
09:40:45 <nand`> that being said; I've never tried out 3d diagrams
09:40:52 <byorgey> 3d diagrams doesn't really exist yet
09:40:55 <nand`> what would be the most reasonably well supported backend for that?
09:40:56 <nand`> oh
09:40:59 <rwbarton> heh, there's "not-gloss"
09:41:20 <byorgey> there is just a stub library which lets you construct spheres, and a stub pov-ray backend which outputs the spheres to a file with no light source =P
09:41:24 <rwbarton> copumpkin: I wanted some medial axis transform code a while back and came across CGAL and said "nopenopenope"
09:41:31 <byorgey> patches welcome! =)
09:42:30 <byorgey> rwbarton: why?  (I know what CGAL is but not familiar with it)
09:42:42 <copumpkin> rwbarton: :P
09:42:54 <copumpkin> it's very templatey
09:43:01 <copumpkin> and abstracts over number types and stuff, even
09:43:04 <rwbarton> as I recall it is about as C++ as you can imagine
09:43:05 <copumpkin> which in some ways is quite haskellish
09:43:10 <copumpkin> but it does it in a very C++ way
09:43:17 <rwbarton> I didn't look at it for very long!
09:43:19 <copumpkin> but yeah, you can't bind to it
09:43:20 <rwbarton> so I don't remember much
09:43:21 <copumpkin> because it's all templates
09:43:26 <rwbarton> maybe that was it
09:43:36 <rwbarton> with sufficient c++bits you could, perhaps?
09:43:36 <copumpkin> you can bind to particular instantiations of it if you want
09:43:37 <RickJ> how does GHCi execute "1+1"? what function is called underneath to do the addition?
09:43:37 <ziman> byorgey, ChristianS, that looks very like what I had in mind, thanks
09:44:05 <rwbarton> RickJ: the 'add' instruction of your cpu
09:44:05 <copumpkin> rwbarton: well, the templates are compile-time code generation, so you might pick a generic instantiation of the operations and then make that polymorphic in haskell or something
09:44:05 <ChristianS> RickJ: (+)
09:44:06 <copumpkin> but it's ugly
09:44:22 <rwbarton> that sounds sort of "cool"
09:44:54 <RickJ> it actually generates fresh assembly code to interpret?!
09:44:59 <rwbarton> oh GHCi
09:45:01 <copumpkin> RickJ: (+) is a method of the Num typeclass, so it depends on the type of 1 there. For Int, it reduces to +# in GHC.Prim
09:45:09 <byorgey> RickJ: first, since it doesn't know what type to use for 1, it defaults to Integer.  Then it looks up the Num instance for Integer, and picks the (+) method out of that instance.
09:45:28 <copumpkin> RickJ: for Integer, it will call out to GMP's C API to do the addition
09:45:38 <rwbarton> except it won't in this case because 1 is small
09:45:41 <nand`> doesn't Integer use machine ints where possible?
09:45:43 <nand`> yeah
09:45:45 <copumpkin> yeah, it does
09:45:54 <copumpkin> but that seemed like a little more detail than he cares about :P
09:46:15 <rwbarton> by default I think GHCi generates some kind of bytecode and interprets that
09:46:21 <byorgey> RickJ: no, it doesn't generate fresh assmbly code
09:46:30 <byorgey> presumably it calls some code in the Haskell runtime system
09:46:37 <copumpkin> it's bytecode for ghci
09:46:40 <nand`> How does GHCi end up executing things? Does it generate x86 on the fly or does it compile to some other low level primitive representation and interpret that directly?
09:46:41 <rwbarton> though you can tell it to (that's what ghci -fobject-code does, right)
09:46:45 <copumpkin> they both go through the GHC.Prim thing though
09:46:51 <copumpkin> nand`: no on-the-fly codegen
09:46:58 <copumpkin> it just interprets a fairly low-level bytecode
09:47:07 <rwbarton> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghci-obj.html
09:47:16 <nand`> does it actually generate some byte code or does it just use an ADT?
09:47:28 <copumpkin> what's the difference?
09:47:28 <copumpkin> https://github.com/ghc/ghc/blob/master/compiler/ghci/ByteCodeInstr.lhs
09:47:40 <rwbarton> is it a list or a tree, i guess
09:47:49 <rwbarton> (and yes i know a list is a tree :)
09:47:50 <typoclass> @where stg
09:47:51 <lambdabot> http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.53.3729
09:47:52 <RickJ> Thanks for the links!
09:48:44 <copumpkin> rwbarton: should be a list
09:48:49 <rwbarton> is there a way to get ghci to show the bytecode with that Outputable instance? just for kicks
09:49:04 <copumpkin> hmm, that'd be cool, but I don't think so
09:49:09 <merijn> One of these days I should read up on STG machines...
09:49:26 <rwbarton> yeah, it seems pretty much useless but cool
09:49:31 <typoclass> RickJ: ^^ this is another paper that describes part of haskell's runtime system (RTS). i think it's not going to do much if you want to learn haskell or get a feel for the language, but have a look at it :-)
09:49:40 <nand`> copumpkin: well, if it's already a byte code internally then you don't have to serialize/deserialize it would you want to manually store it in a file or something
09:49:55 <copumpkin> rwbarton: well, if they expanded the bytecode a bit more, provided a path from it to the native codegens, then it might be a much cooler back-end for cloud haskell
09:50:03 <copumpkin> rwbarton: where we could actually transmit code/closures/etc. over the wire
09:50:12 <nand`> I guess it only matters if you want to dig around in GHCi's modules either way
09:50:28 <rwbarton> interesting
09:50:36 <copumpkin> there are some things it doesn't do right now
09:50:44 <copumpkin> like it doesn't handle unlifted tuples and things like that
09:50:57 <copumpkin> if you turn on those extensions in GHCi it will complain at you
09:51:41 <rwbarton> indeed
09:52:07 <copumpkin> nand`: yeah, just an ADT then. It's one binary instance away from being binary though ;)
09:52:08 <rwbarton> would have to do extra work for things like CCALL's code pointer also
09:52:22 <copumpkin> yeah, you'd have to make sure you had dependencies and foreign libraries
09:52:30 <copumpkin> but it would make cloud haskell a lot more compelling to me
09:52:51 <rwbarton> how about using the llvm opcodes
09:52:57 <rwbarton> I guess those are not really intended to be portable
09:53:11 <copumpkin> that could work
09:53:19 <copumpkin> but we'll have less information at that point
09:53:23 <rwbarton> yeah,
09:53:54 <nand`> being able to seamlessly transmit all kinds of data between architectures would probably be of immense popularity for Haskell
09:54:45 <copumpkin> sending partially evaluated data would be weird but kinda cool
09:55:28 <rwbarton> i also want to be able to store partially evaluated data in my filesystem
09:55:30 <rwbarton> is that weird
09:55:46 <nand`> I imagine strictness annotations would play a key role for stuff like that; since it may take more time to send the uncomputed closure than it takes to just compute it
09:55:50 <copumpkin> rwbarton: no!
09:55:51 <typoclass> rwbarton: ... it's called an executabe ...
09:55:53 <typoclass> :-)
09:55:54 <copumpkin> nand`: and NFData
09:56:09 <rwbarton> typoclass: heh, indeed
09:56:23 <rwbarton> but why can't i have a file 'primes' that i can read from, and is computed on-demand and cached
09:56:24 <RickJ> Does Hugs too compile to a kind of bytecode first?
09:56:26 <nand`> still, it would be interesting to be able to send something like ‚Äòcycle [1..10]‚Äô over the net
09:56:39 <rwbarton> ideally with some way to "uncompute" the value as well
09:57:20 <nand`> rwbarton: shouldn't it be possible to write a filesystem like that for today's operating systems?
09:57:28 <rwbarton> or: apply some pure function to every file in a directory, but defer the actual computation of the function until the resulting files are read
09:57:34 <rwbarton> I guess, maybe?
09:57:45 <rwbarton> maybe with FUSE
09:57:49 <nand`> ‚Äòhfs‚Äô, fund it
09:57:56 <rwbarton> i think that name is taken
09:58:02 <nand`> hsfs?
09:58:13 <rwbarton> better
09:58:19 <latermuse> Will non-hand-optimizied ghc eventually pass gcc in performance?
09:58:23 <rwbarton> lambdafs
09:58:39 <nand`> the utilities are prefixed with Œª and god help you if you can't type that
09:58:45 <rwbarton> latermuse: you mean in, like, decades?
09:58:48 <typoclass> yeah you can do that stuff. much of /sys and /proc aren't "files" in the sense of bytes lying around on a disk waiting to be read. it's the output of whatever computations, querying ram, etc.
09:59:06 <nand`> latermuse: that's not something that can be generalized
09:59:14 <rwbarton> woe to whoever stat()s my "primes" file, I guess
09:59:18 <latermuse> rwbarton: i mean eventually. decades falls into that generalization
09:59:36 <rwbarton> latermuse, well I wouldn't rule out the possibility
10:00:04 <latermuse> nand': are there currently any big hurdles that are being worked on in this direction?
10:00:20 <merijn> latermuse: Mostly depends on the code you write, I think
10:00:38 <latermuse> so it comes down to individual skill in optimization?
10:01:04 <rwbarton> copumpkin: :set -ddump-bcos
10:01:06 <nand`> our processors are not quantum graph reducers. graph reducers are being worked on, I just have to find somebody that will let me pay them to make them quantum-y
10:01:09 <copumpkin> rwbarton: w00t
10:01:29 <merijn> latermuse: That's not what I meant. There is no absolute performance difference between GHC and GCC. For some kinds of code I suspect GHC is already much better than gcc
10:01:40 <latermuse> when processors are all quantum graph reducers, will ghc outperform gcc?
10:01:47 <rwbarton> also: wow there are a lot of -ddump-* options
10:01:51 <nand`> latermuse: it depends on the machine in question and the program you're compiling
10:01:57 <nand`> re: performance
10:02:06 <latermuse> merijn: ah I see. neat
10:02:20 <nand`> also, GHC is a Haskell implementation, while gcc is a C implementation - you can't directly compare the two without involving some sort of program transformation
10:02:40 <rwbarton> "let it_sux = ... in ..."
10:02:46 <nand`> so ultimately, it depends on the machine in question and *both* programs you're compiling
10:02:54 <rwbarton> my code does not suck ghci! :(
10:03:56 <rwbarton> AP = thunk for fully applied function, PAP = thunk for partially applied function?
10:04:30 <nand`> ‚ÄúMKAP, PUSH, SLIDE‚Äù <- GHCi implements a G-machine?
10:05:04 <rwbarton> i should really read that G-machine paper some day
10:05:39 <nand`> @google implementing functional languages: a tutorial
10:05:41 <lambdabot> http://research.microsoft.com/~simonpj/papers/pj-lester-book/
10:05:42 <lambdabot> Title: Simon Peyton Jones: book
10:05:50 <nand`> I found this to be quite readable
10:10:33 <sw17ch> hmm
10:10:35 <atriq> Hey, Monoid a => Maybe a is a Monoid, right?
10:10:38 <atriq> This is PERFECT
10:10:58 <nand`> yes
10:12:08 <fmap> I guess even Semigroup a => Maybe a is a Monoid
10:12:25 <nand`> yes
10:12:28 <nand`> but not in Prelude
10:12:36 <atriq> Aaargh
10:12:42 <atriq> It is less perfect than I imagined
10:12:58 <nand`> atriq: what were you imagining?
10:13:06 <atriq> Something stupid
10:13:17 <atriq> That would have made my life easier
10:13:25 <rwbarton> you might be interested in one of the newtypes of Maybe
10:13:36 <atriq> I don't think so
10:13:44 <nand`> what would make your life easier?
10:13:59 <atriq> Wait
10:14:10 <atriq> No
10:14:19 <atriq> Some sort of interspersy monoid
10:14:21 <aristid> fmap: given that the Monoid a => Monoid (Maybe a) instance doesn't use mempty, sure
10:14:45 <aristid> atriq: i think you should try to say a bit more clearly what you want
10:15:00 <atriq> Nah, it actually is stupid
10:15:05 <atriq> And I'm tired and got excited
10:15:28 <nand`> depending on the problem you were trying to solve there may be another solution
10:16:14 <atriq> I've got 2 Maybe ByteStrings, and I want to change that into a list options to send to a website which I believe is in PHP
10:16:22 <atriq> GET-wise
10:16:29 <atriq> Does it matter if it's PHP? I dunno
10:16:34 <atriq> They're GET arguments
10:16:57 <nand`> if you're sending it over HTTP, it doesn't matter what the remote end looks like
10:17:06 <nand`> just which interface it exports
10:17:28 <atriq> But yeah, it's ?limit=20&offset=0
10:17:38 <atriq> And both are optional
10:17:51 <nand`> :t catMaybes
10:17:53 <lambdabot> [Maybe a] -> [a]
10:17:59 <nand`> does this help?
10:18:04 <mapf> heh, standalone deriving works with gadts pretty cool
10:18:04 <atriq> Ooh, yes
10:18:10 <DMcGill> say I have a data X = A | B | C | D and xs :: [X]. Is there an easy way to split that into As and Bs other than a) [A | A <- xs] for each one or b) let isA A = True; isA _ = False in filter isA?
10:18:26 <atriq> Thank you, nand` and aristid and rwbarton
10:18:45 <nand`> > ('?':) . intersperse '&' . catMaybes $ [Just "limit=20", Nothing, Just "offset=0"]
10:18:47 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
10:18:47 <lambdabot>              with actual type...
10:18:53 <nand`> oh
10:19:00 <mapf> DMcGill: deriving Eq
10:19:07 <nand`> > concat . ("?":) . intersperse "&" . catMaybes $ [Just "limit=20", Nothing, Just "offset=0"]
10:19:10 <lambdabot>   "?limit=20&offset=0"
10:19:16 <aristid> atriq: maybe consider using http-types?
10:19:22 <DMcGill> some of the constructors also have arguments
10:19:29 <mapf> filter (/= A)
10:19:33 <aristid> atriq: it's got the toQuery and renderQuery functions that might help
10:19:56 <rwbarton> if only you could derive colenses for your type X!
10:20:08 <mapf> heh
10:20:20 <nand`> Control.Colens.makeColenses
10:20:32 <nand`> wait, that doesn't exist? edwardk?
10:20:32 <DMcGill> looking now
10:20:39 <DMcGill> aww, you tease :(
10:20:40 <cornihilio> hey is this the actual implementation of fmap for either?: https://gist.github.com/4098474
10:20:57 <nand`> cornihilio: yes
10:21:04 <rwbarton> I will possibly end up writing a colens library for a project
10:21:09 <nand`> @src Functor Either
10:21:09 <lambdabot> Source not found. I feel much better now.
10:21:11 <cornihilio> I thought it was just convention to treat the left value like an error or something
10:21:15 <rwbarton> hoping edwardk beats me to it though ;)
10:21:35 <nand`> @src Either fmap
10:21:35 <lambdabot> fmap _ (Left x) = Left x
10:21:36 <lambdabot> fmap f (Right y) = Right (f y)
10:21:52 <DMcGill> cornihilio: for Either, fmap :: (r -> r') -> Either l r -> Either l r'
10:22:13 <DMcGill> you couldn't possible change the type of 'l'
10:22:30 <DMcGill> as Functor only allows for one type variable
10:23:03 <atriq> aristid, wow, I'm using that anyway, it'd help if I looked, heh
10:23:08 <cornihilio> I'm sorry but I don't follow
10:23:48 <atriq> Thank you VERY much
10:24:37 <Hermit> I've just updated cabal-install to 1.16.0.2 and it seems to be ignoring conditional compilation macros completely. Statements like #if MIN_VERSION_* are ignored. I tried negating them (if !MIN_VERSION_...) but the result is the same. I had to edit 30% of the packages and comment out these checks and their code manually. Is this a known issue?
10:25:03 <DMcGill> cornihilio, look at typeclassopedia to get an understanding of why fmap can't change the Left part of Either
10:25:08 <DMcGill> @typeclassopedia
10:25:09 <lambdabot> Unknown command, try @list
10:25:15 <DMcGill> @where typeclassopedia
10:25:15 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
10:26:12 <aristid> atriq: i added toQuery fairly recently because i had pretty much a similar problem occurring in a number of places :)
10:26:14 <zhulikas> @type fmap fmap fmap
10:26:15 <lambdabot> (Functor f1, Functor f) => (a -> b) -> f (f1 a) -> f (f1 b)
10:26:16 <DMcGill> plus I'd consider it essential reading
10:26:22 <cornihilio> DMcGill: thank you
10:26:28 <nand`> there's only one correct functor instance for any possible type, right?
10:26:38 <nand`> so if it type checks and the laws hold, you know it can't be any other wy
10:26:38 <nand`> way*
10:26:43 <rwbarton> yes, at most one
10:28:06 <DMcGill> that's interesting, why is that the case?
10:28:22 <nand`> there's an SO answer on this somewhere
10:30:50 <atriq> Okay, that's annoyting
10:30:53 <atriq> *annoying
10:31:40 <atriq> The authenticate-oauth package has an outdated dependency for http-conduit
10:35:26 <atriq> And I don't want to cause a cabal hell problem
10:37:21 <rwbarton> :t Map.fromList
10:37:23 <lambdabot> Couldn't find qualified module.
10:37:29 <rwbarton> > Map.fromList [('a',1)]
10:37:30 <bitonic> edwardk: OK bound properly clicked now, I'm using it with great pleasure :)
10:37:32 <lambdabot>   Not in scope: `Map.fromList'
10:37:32 <lambdabot>  Perhaps you meant one of these:
10:37:32 <lambdabot>    `M.fromLis...
10:37:36 <rwbarton> > Just $ M.fromList [('a',1)]
10:37:37 <edwardk> =)
10:37:38 <lambdabot>   Just (fromList [('a',1)])
10:37:41 <bitonic> edwardk: I might write a tutorial on how to implement an ITT with it
10:37:45 <edwardk> great!
10:38:01 <bitonic> considering that the basic version is what, 50 lines of code
10:38:09 <rwbarton> > Just $ Data.HashMap.Strict.fromList [('a',1)]
10:38:11 <lambdabot>   Not in scope: `Data.HashMap.Strict.fromList'
10:38:22 <bitonic> I'm adding other basic types now
10:38:37 <edwardk> consider if you'd like to contribute it as an example to distribute with bound itself
10:38:43 * nand` still isn't sure what he'd want to use bound for, or when he does, how to use it
10:38:52 <edwardk> nand`: hence, tutorial ;)
10:38:58 <nand`> examples would be nice
10:39:16 <nand`> that seems to be my main problem with new libraries in general; I can't figure out a use case to try and conceptualize its workings in that context
10:39:17 <edwardk> nand`: well, there are 3 in the repo. one is just an untyped lambda calculus
10:39:20 <bitonic> edwardk: OK, I'll let you know
10:40:08 <edwardk> bound is useful when you go to define a little language, be it an EDSL or interpreter/compiler. any time you have to deal with variable names being captured and substitution
10:40:09 <atriq> Well, I am now in a cabal hell
10:40:14 <nand`> DMcGill: found it: http://thread.gmane.org/gmane.comp.lang.haskell.libraries/15382/focus=15384
10:40:20 <DMcGill> thanks
10:40:36 <atriq> authenticate-oauth depends on older versions of http-conduit and SHA
10:41:17 <nand`> @free foo :: Functor f => (a -> b) -> f a -> f b
10:41:17 <lambdabot> Extra stuff at end of line
10:41:18 <edwardk> here had been other solutions before bound, and arguably sometimes they are even a better idea, but bound has the benefit of being braindead simple while solving the problem for most usecases, and just gives you a monad transformer you can use on your expression type.
10:41:24 <nand`> what's the syntax of that?
10:41:28 <nand`> @free (a -> b) -> f a -> f b
10:41:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
10:41:46 <nand`> @free f :: (a -> b) -> f a -> f b
10:41:46 <lambdabot> Extra stuff at end of line
10:42:04 <rwbarton> @free foo :: (a -> b) -> f a -> f b
10:42:05 <lambdabot> Extra stuff at end of line
10:42:14 <atriq> Yesod seems to be awful for dependency stuff
10:42:17 <edwardk> i always struggle a half-dozen times when i go to call @free figuring out its syntax.
10:42:17 <Saizan> @free (a -> b) -> F a -> F b
10:42:17 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
10:42:23 <rwbarton> ah that's it
10:42:29 <rwbarton> @free foo :: (a -> b) -> F a -> F b
10:42:29 <lambdabot> g . h = k . f => $map_F g . foo h = foo k . $map_F f
10:42:36 <nand`> okay..
10:42:39 <edwardk> aha, there you go
10:43:03 <nand`> that thing needs better error messages at the very least
10:43:10 <nand`> ‚ÄúExtra stuff at the end of line‚Äù <- nonsense
10:43:31 <rwbarton> end of line was after the
10:43:36 <rwbarton> "-> f", can't you tell :)
10:43:58 <nand`> I semi-figured
10:44:07 <edwardk> if you have a monad, a monad is 'about substitution and renormalization'. bound is about letting your expression type itself be a monad, and providing you with a monad transformer that lets you 'bind' some variables (lambdas, foralls, etc. act as binders) so that they won't be considered for substitution.
10:45:01 <edwardk> normally you'd have to write some big substitution function as a one-off thing, and then write how to extract the free variables, etc. bound replaces these with the use of a monad and traversable/foldable.
10:45:14 <edwardk> checking for closed terms just becomes traverse (const Nothing)
10:45:41 <edwardk> and the monad transformer takes care of alpha equivalence
10:45:49 <nand`> but what I would like to see is an example of bound being used for some domain-specific language, to represent something concrete; rather than just implementing a general purpose lambda calculus or whatever
10:45:56 <mapf> data H = H (forall a. T a)   data H = forall a. H (T a)
10:46:19 <mapf> second is existensial quantification, while first is ... ?
10:46:38 <nand`> impredicative polymorphism
10:46:43 <mapf> why first requires RankNTypes?
10:46:48 <rwbarton> universal quantification
10:47:04 <tibbe> bgamari: I've released cassava 0.2. Will write a release blog post soon.
10:47:20 <rwbarton> that's what RankNTypes means, "forall a." not at the top level of a type
10:47:29 <nand`> ImpredicativeTypes actually makes it work as well
10:47:34 <edwardk> nand`: we use it here in DSLs that we use for sql queries and relation algebra operations to name temp table variables for subsequent reuse, for our 'core' language we compile down to. i have an example of a simple 'remote' AST for defining programs you want to send over the wire which is based on an indexed version of bound.
10:47:42 <mapf> rwbarton: so if i don't want dictionary i should choose first?
10:47:51 <nand`> mapf: if you look at it like this; ‚ÄòH‚Äô is just a new name for (forall a. T a)
10:47:57 <rwbarton> well they are totally different--you should choose the one you want
10:48:09 <nand`> so a function of, say, H -> X is of type (forall a. T a) -> X; which is a rank-2 type
10:48:33 <rwbarton> a value of type H is something that I can unpack to a "T a" for *any* type of my choice
10:48:38 <atriq> I may become a Cabal hell vigilante
10:48:41 <atriq> Hahaha!
10:48:44 <edwardk> for real DSL work i tend to advocate for typed DSLs, which pushes me towards an indexed form of bound (which isn't on hackage)
10:48:48 <nand`> for an example; suppose T = []; the first declaration only allows [], or perhaps [undefined], [undefined, undefined, ...]
10:48:58 <nand`> the latter allows any possible list
10:49:16 <edwardk> atriq: hpaste the complaint from cabal?
10:49:27 <ski> mapf,nand` : `data H = H (forall a. T a)' is `PolymorphicComponents'
10:49:28 <rwbarton> the second H is something I can unpack to "T a" where a is some unknown type I don't control
10:49:29 <atriq> edwardk, it got well past that
10:49:34 <atriq> I'm worried I'm gonna cause them
10:49:48 <atriq> Because I've got two versions of http-conduit
10:49:59 <atriq> And I'm sort of using both at once
10:50:05 <nand`> so there are three language extensions that make it work? What's the difference between using either of these, then?
10:50:13 * hackagebot cassava 0.2.0.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.2.0.0 (JohanTibell)
10:50:20 <mapf> i'm gonna confused...
10:50:47 <mapf> actually i'm not thinking about rank polymorphism in context of data constructors
10:50:47 <ski> nand` : "a function of, say, H -> X is of type (forall a. T a) -> X; which is a rank-2 type" would have been true if it was `type H = forall a. T a' -- but as stated, it's not the case
10:51:02 <atriq> Isn't Nat equivalent to forall a. [a]?
10:51:15 <ski> with `data H = H (forall a. T a)', `H -> X' doesn't require `Rank2Types'
10:51:28 <nand`> atriq: should be
10:51:40 <bgamari> tibbe, Awesome! I look forward to seeing it
10:51:46 <ski> atriq,nand` : no, to `exists a. [a]'
10:51:55 <nand`> oh, oops
10:52:03 <tibbe> bgamari: I have some ideas how to improve the space usage a lot, but you'll have to do with the current improvements for a little while
10:52:06 <atriq> ski, can you explain?
10:52:06 <nand`> yes that's what I was thinking of :(
10:52:16 <ski> the only fully defined value of type `forall a. [a]' is the empty list
10:52:20 <bgamari> tibbe, No worries, I think they should be enough
10:52:58 <ski> if you cheat with partial values, then you can (sometimes) extract more information out of `forall a. [a]'
10:53:14 <nand`> but Haskell has ‚ä•; so we can use replicate n undefined and length and it would still line up
10:53:32 <tibbe> bgamari: just so you're aware, the memory usage is still a bit too high due to me parsing the whole CSV file to a Vector (Vector ByteString). Both Vector and ByteString have quite high fixed overheads (e.g. 6 and 9 words respectively), so that eats a bunch of memory.
10:53:38 <nand`> I don't see how you can get any form of information out of the ‚Äòforall a. a‚Äôs inside, though
10:53:39 <ski> atriq : if you have `exists a. [a]', then since you only have a list of `a's, but nothing to do with them, you can't really look at them at all, you can just count how many there are
10:53:41 <rwbarton> I guess PolymorphicComponents means you can put (forall a. ...) in a component of a data type; RankNTypes means you can put (forall a. ...) on the left side of an ->, and it implies PolymorphicComponents because data type components are arguments to the constructor; and ImpredicativePolymorphism means you can put (forall a. ...) anywhere you damn well please
10:53:45 <mapf> ski: now i see thanks.
10:53:48 <tibbe> bgamari: but there are no leaks
10:54:07 <atriq> ski, how could you cheat with partial values?
10:54:21 <bgamari> tibbe, sure.
10:54:23 <atriq> Like, one example
10:54:26 <ski> nand` : with partial values, it depends on how `Nat' is defined
10:54:44 <ski> atriq : `replicate n undefined' as nand` said
10:54:48 <bgamari> tibbe, I think a 1.3 million record file requires 1.2GB after your changes IIRC
10:54:59 <atriq> And how does the exists one stop that?
10:54:59 <nand`> Nat = Word ?
10:54:59 <bgamari> tibbe, Pretty high, but usable
10:55:06 <ski> nand` : then no
10:55:13 <atriq> nand`, Nat = Wordeger
10:55:25 <nand`> that reminds me
10:55:29 <nand`> is Data.Word.Word unbound?
10:55:41 <rwbarton> it's Int-sized
10:55:56 <nand`> oh
10:56:00 * ski thinks there ought to be a type `Natural' corresponding to `Integer', with efficient implementation
10:56:13 * bgamari agrees
10:56:19 * nand` agrees
10:56:32 * atriq agrees
10:56:35 <ski> (iow, the only (proper) partial element of `Natural' would be `_|_' itself)
10:56:53 <ski> (as opposed to `data Nat = Zero | Succ Nat')
10:57:25 <ski> > maxBound :: Word
10:57:27 <lambdabot>   18446744073709551615
10:57:28 <ski> > maxBound :: Int
10:57:30 <lambdabot>   9223372036854775807
10:57:33 <nand`> I wonder
10:57:42 <ski> > 2 * fromIntegral (maxBound :: Int)
10:57:44 <lambdabot>   18446744073709551614
10:57:47 <nand`> data Nat = Zero | Succ !Nat -- wouldn't this essentially make the whole thing strict?
10:57:50 <rwbarton> it should be pretty easy using the same strategy as for Integer, right
10:57:56 <rwbarton> probably designing the API would be the harder part
10:57:57 <tibbe> bgamari: with the attoparsec changes?
10:58:04 <atriq> nand`, yes, but it would still take up looooaaaads of memory
10:58:09 <tibbe> bgamari: you can also try the new streaming API :)
10:58:09 <ski> nand` : yes, but then the point of `Nat' disappears
10:58:19 <rwbarton> you can just use Word then :P
10:58:22 <nand`> ski: what do you mean?
10:58:23 <edwardk> nand`: yes, but a bit inefficient ;)
10:58:26 <nand`> well, yeah
10:58:31 <rwbarton> since you wouldn't be able to fit any bigger Nats in memory anyways
10:58:36 <nand`> that is true :)
10:58:43 <nand`> well
10:58:44 <ski> nand` : i mean then you can just use `Natural' (assuming we get one such, with efficient implementation)
10:58:45 <bgamari> tibbe, I believe so (new attoparsec is installed; it's possible that cabal decided not to compile against it. I'll have to check)
10:58:46 <nand`> depends on how large your memory is
10:58:49 * nand` hides
10:58:54 <bgamari> tibbe, I was considering that; is there an example for usage?
10:58:54 <rwbarton> and your compiler, I suppose
10:59:04 <ski> nand` : the point of `data Nat = Zero | Succ Nat' is that we *can* have incremental computation
10:59:14 <rwbarton> on GHC though, Word corresponds to the size of the virtual address space
10:59:20 <nand`> ski: yes, but I meant in the absence of Natural
10:59:31 <bgamari> tibbe, Looks like the new attoparsec is being used
10:59:39 <nand`> this actually reminds me of something completely unrelated
11:00:01 <atriq> Haskellers.com seems down?
11:00:17 <nand`> would it make sense for type families to be cached by the compiler? like; say; the compiler has expanded F A B C somewhere, then future uses of the same would be looked up from some cache instead of re-expanded
11:01:06 <nand`> in particular, I'm trying to track down some sources of gross inefficiencies in my type families and I believe it may be recomputing a lot
11:01:54 <DMcGill> there's no way that Nat = Zero | Succ Nat is usable for any programs wanting to actually use arithmetic right?
11:01:58 <atriq> MY CABAL VIGILANTISM SHALL WAIT
11:02:01 <tibbe> bgamari: I forgot to put some examples in examples/ :/
11:02:06 <tibbe> bgamari: let me write one
11:02:19 <atriq> DMcGill, it's useful for comparing the length of infinite lists
11:02:37 <atriq> > length (repeat 0) > 7
11:02:43 <lambdabot>   mueval: ExitFailure 1
11:02:43 <lambdabot>  mueval: Prelude.undefined
11:02:53 <atriq> > genericLength (repeat 0) > 7 :: Nat
11:02:54 <lambdabot>   Not in scope: type constructor or class `Nat'
11:02:56 <nand`> did we have some peano nats in lambdabot anywhere?
11:03:06 <atriq> DMcGill, point is, that works with Nat
11:03:51 <DMcGill> I suppose, but some lengthGEQ :: [a] -> Int -> Bool does that just as well
11:04:42 <nand`> but that requires more typing / code redundancy
11:05:05 <nand`> hmm
11:05:08 <nand`> that actually gives me an idea
11:05:10 <edwardk> DMcGill: i use something like it in my automatic differentiation library somewhere ;)
11:05:34 <rwbarton> oh that reminds me
11:05:34 <nand`> perhaps some form of ‚Äòlazy int‚Äô ‚âà [Int]
11:05:38 <edwardk> found it https://github.com/ekmett/ad/blob/master/src/Numeric/AD.hs#L152
11:05:42 <nand`> arithmetic on that would have to be defined carefully I guess
11:05:52 <rwbarton> ski: no, I don't know where the "@where sneaky" trick comes from, I know it is not mine though
11:05:56 <rwbarton> I learned it here
11:06:05 <atriq> nand`, how would that work?
11:06:55 <nand`> atriq: the idea would be to treat the int as the sum of its components. Addition could be either concatenation or just a modified zipWith (+) (that appends any rest, instead of ignoring it); multiplication could be done with concatMap or something
11:06:56 <DMcGill> I guess you'd just have a Num and Ord instance for Nat and then would do lengthLazy xs >= 3
11:07:30 <atriq> nand`, that sounds completely ridiculous
11:07:40 <DMcGill> you'd have to be careful that people don't do something crazy like try to (+) two Nats
11:08:02 <atriq> Why not, DMcGill
11:08:07 <atriq> That works fine
11:08:23 <DMcGill> it works, but compare the speed of Int's (+) with Nat's
11:08:33 <rwbarton> -- | Is this structure larger than edwardk can count?
11:08:34 <DMcGill> especially on numbers bigger than a few hundred
11:08:45 <nand`> atriq: the most immediate problem I see is that ‚Äòlength‚Äô for this would either be [1,1,1,1,1,1,1,1..] and thus not more efficient than peano, or somehow magical
11:08:48 <startling> DMcGill, but Nat is unbounded!
11:08:54 <DMcGill> Integer then
11:08:59 <startling> hehe
11:09:20 <startling> I think most systems will be able to represent more in an Int than in a Nat, actually
11:09:21 <nand`> how high can edwardk count?
11:09:31 <DMcGill> tbh I like the idea of having a uInt or something
11:09:35 <ski> rwbarton : ok
11:09:43 <startling> UInteger
11:09:45 <nand`> DMcGill: Word
11:09:53 <nand`> but yes, unbounded Word as Natural would be great
11:09:55 <DMcGill> ah yes, my mistake
11:10:06 <rwbarton> nand`: 9 apparently
11:10:14 * hackagebot digest 0.0.1.2 - Various cryptographic hashes for bytestrings; CRC32 and Adler32 for now.  http://hackage.haskell.org/package/digest-0.0.1.2 (EugeneKirpichov)
11:10:18 <nand`> rwbarton: by what metric?
11:10:22 <nand`> _9 ?
11:10:26 <rwbarton> big (S (S (S (S (S (S (S (S (S (S _)))))))))) = True
11:10:32 <nand`> ah
11:11:12 <startling> :t _9
11:11:13 <lambdabot> (Functor f, Field9 s t a b) => (a -> f b) -> s -> f t
11:11:21 <startling> woah, wasn't expecting that to exist
11:11:46 <mpu> why \x -> (x, a) is not a monad?
11:11:49 <DMcGill> isMany (S (S (S (S _)))) = True; isMany _ = false
11:11:50 <startling> don't tuples only go up to 6 or something?
11:11:51 <tibbe> bgamari: gotta run soon, but I will have one created by tonight and put on github in the examples/ directory
11:11:52 <startling> mpu, it is
11:12:01 <startling> mpu, you need to import Control.Monad.Instances though
11:12:03 <bgamari> tibbe, Sure, no worries. Thanks!
11:12:04 <nand`> that ‚Äú))))))))))‚Äù makes me weep inside
11:12:08 <mpu> startling: Ok, thanks
11:12:16 <nand`> this blatant inefficiency needs to be optimized
11:12:28 <startling> I wish there were a type-level $
11:12:33 <nand`> startling: 60 or something in GHC, I think
11:12:42 <startling> oh, right sixty, not six
11:12:46 <DMcGill> nand`: we need some function "remainingParens"
11:12:54 <startling> knew there was a 6 involved somewhere
11:13:14 <nand`> DMcGill: big (S (S (S (S (S (S (S (S (S (S (S .. = foo
11:13:15 <DMcGill> a + (b + (c + (d remainingParens = a+b+c+d
11:13:21 <nand`> I mean, the ‚Äò=‚Äô can't be in a pattern, right?
11:13:22 <startling> DMcGill: :S
11:13:27 <nand`> or maybe even drop the ‚Äò..‚Äô
11:13:57 <startling> can you do type (:$) a b = a b ?
11:14:17 <nand`> that's on the type level
11:14:19 <nand`> not the pattern level
11:14:21 <nand`> but yes, you can
11:14:22 <startling> oh, right
11:14:44 <startling> you should be able to declare constructor synonyms. :(
11:15:00 <nand`> something something smart patterns something
11:15:35 <nand`> wasn't there a proposal or somesuch that would allow this or something like this aeons ago; as an alternative to view patterns? that would eg. allow matching on Seq directly with :< and :>
11:15:58 <DMcGill> can't you do that with GADTs? data X where {F :: a -> X, G = F}
11:16:24 <DMcGill> note: I haven't really ever used GADTs
11:16:32 <mpu> startling: hell, it is not a monad!
11:16:55 <nand`> DMcGill: nope
11:17:00 <mpu> startling: (,) a is one, what I want is (, a)
11:17:07 <nand`> DMcGill: you can only provide type signatures in GADT bodies, not definitions
11:17:14 <startling> mpu, oh, why?
11:17:17 <startling> mpu, just do
11:17:37 <startling> :t let switch (a, b) = (b, a) in switch
11:17:38 <lambdabot> (t1, t) -> (t, t1)
11:17:55 <nand`> mpu: there's no such thing as a type lambda
11:18:04 <mpu> startling: then I have to use switches everywhere...
11:18:07 <DMcGill> then make a newtype over (a,) and write your instances for that
11:18:09 <nand`> (, a) would be \x -> (x, a)
11:18:13 <startling> mpu: only in one place?
11:18:15 <mpu> nand`: I don't care, you see what I mean
11:18:16 <nand`> but yes, you can flip (,) instead
11:18:21 <DMcGill> if you write switches directly into your instances, you don't have to do it yourself
11:18:36 <nand`> Flip (,) a -- surely something like this exists; but you would need to pack/unpack everything manually
11:18:44 <nand`> so there's just as much overhead as using flip everywhere instead
11:18:48 <mpu> startling: I want to use it to play with the random functions in System.Random
11:19:18 <mpu> startling: these functions keep returning the state  of the random generator, I don't get why there is no monad for this...
11:19:36 <ClaudiusMaximus> there's MonadRandom somewhere
11:19:38 <startling> mpu, just use State for it
11:19:40 <nand`> there's a Random monad or so
11:19:47 <nand`> oh, MonadRandom
11:19:54 <nand`> yes
11:19:55 <nand`> :t getRandom
11:19:56 <rwbarton> http://hackage.haskell.org/package/MonadRandom
11:19:57 <lambdabot> Not in scope: `getRandom'
11:19:59 <nand`> :(
11:20:10 <mpu> is it in haskell plateform?
11:20:26 <rwbarton> i imagine not
11:20:30 <DMcGill> State is, I don't think MonadRandom is
11:20:37 <mpu> hell...
11:20:58 <mpu> this System.Random is a _real_ pain to use
11:21:04 <DMcGill> state :: (s -> (a,s)) -> State a
11:21:18 <mpu> :t state
11:21:19 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
11:21:23 <nand`> :t random
11:21:24 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
11:21:28 <nand`> :t state random
11:21:30 <lambdabot> (MonadState s m, RandomGen s, Random a) => m a
11:21:43 <rwbarton> :t runState (state random) ?x
11:21:44 <lambdabot> (?x::s, RandomGen s, Random a) => (a, s)
11:21:46 <mpu> DMcGill: cool thing, thanks
11:22:00 <nand`> :t evalState (state random) ?gen
11:22:02 <lambdabot> (?gen::s, RandomGen s, Random a) => a
11:22:24 <DMcGill> what does the '?' mean?
11:22:28 <rwbarton> > evalState (replicateM 10 (state random)) (mkStdGen 17) :: [Bool]
11:22:30 <nand`> implicit parameter
11:22:30 <lambdabot>   [True,False,True,False,False,True,True,False,False,True]
11:22:34 <nand`> :t ?f ?x
11:22:36 <lambdabot> (?f::t -> t1, ?x::t) => t1
11:22:41 <DMcGill> ah, like holes?
11:22:49 <nand`> not quite
11:23:01 <rwbarton> in theory one could use them for other things
11:23:11 <nand`> implicit parameters can be bound/provided
11:23:12 <nand`> they're just passed along automatically, like type class dictionaries usually are
11:23:19 <rwbarton> > let g x = x + ?n in let ?n = 5 in g 3
11:23:21 <lambdabot>   8
11:23:56 <nand`> I'm not sure how much you'd get frowned if you use them instead of a Reader or something in passing along environments to sub-functions
11:24:14 <nand`> frowned at*
11:24:31 <rwbarton> You'd probably earn a frown from shachaf.
11:24:41 <nand`> that's easy
11:25:01 <rwbarton> I hear some people do actually use them
11:25:12 <merijn> rwbarton: Well, I imagine they can be very useful
11:25:14 * hackagebot subtitleParser 0.4.1 - A parser for .srt and .sub files  http://hackage.haskell.org/package/subtitleParser-0.4.1 (RubenAstudillo)
11:25:19 <nand`> @ask shachaf how much would you frown at code that uses implicit parameters to pass along environments, instead of a Reader or something?
11:25:19 <lambdabot> Consider it noted.
11:25:24 <rwbarton> good
11:26:00 <merijn> rwbarton: I mentally filed them under "Haven't needed them yet, but this seems like something that could be really helpful in some obscure corners case I will encounter in the future" :p
11:26:19 <nand`> ‚ÄòsubtitleParser‚Äô hmm; that gets me thinking - how about an ass implementation in Haskell, maybe with diagrams or something fancy?
11:29:19 <edwardk> rwbarton: the motivation is that i could have uncountably many targets and can't know, so it has to be lazy, and most things for which you want to use reverse mode have remarkably few outputs
11:29:33 <edwardk> er countably many but infinite
11:30:09 <startling> see, he can't even count to "many"!
11:30:41 <rwbarton> uncountably as in more than 10
11:30:48 <rwbarton> :P
11:30:54 <nand`> byorgey: know what would be cool? a diagrams backend for generating OpenGL textures or something
11:31:00 <nand`> I don't know how it would work
11:31:26 <nand`> but my use case is ‚Äò1. I want to draw a diagram‚Äô and ‚Äò2. I want to have it as an OpenGL texture‚Äô
11:31:29 <nand`> of course; efficiently
11:31:57 <edwardk> :t ?field^._1
11:31:59 <lambdabot> (?field::s, Field1 s t a b) => a
11:32:07 <ClaudiusMaximus> nand`: cairo can render to in memory bitmaps, which you can then upload to a texture (i've done it, in C though)
11:32:21 <DMcGill> edwardk: not very subtle there
11:32:59 <edwardk> DMcGill: just thinking in terms of implicit configurations for a sec. thats horrible. ;)
11:33:10 <edwardk> sing HasFoo classes and lenses
11:33:12 <edwardk> er using
11:34:02 <nand`> ClaudiusMaximus: that certainly sounds like a distinct possibility; 1. do you know if that would be reasonably efficient? think for realtime subtitles; and 2. how good is diagrams' font support in general?
11:34:22 <ClaudiusMaximus> nand`: https://gitorious.org/maximus/incidents/blobs/master/code/boat.c , generates multiple mipmap levels to get a constant outline thickness
11:35:07 <edwardk> ClaudiusMaximus: excellent idea!
11:35:45 <DMcGill> hmm, does GLFW have a mainLoop like GLUT? I've set up my window and all my callbacks, now I just want to let my program run
11:36:30 <mpu> Thank you guys you saved my ass
11:37:06 <mpu> Now I can do random stuff without too much of a hastle:     round maxGen =<< sortBy cmp <$> replicateM genSize (state randomAnt)
11:39:40 <otters> @pl \s f -> onKey (fieldName s) f
11:39:40 <lambdabot> onKey . fieldName
11:40:15 <Sonderblade> any regexp replace function in haskell?
11:40:41 <linduxed> why doesn't this return numbers which have the common divisors of 1,2,3,4,5 ?
11:41:09 <linduxed> [ x | x <- [1..], n <- [1..5], x `mod` n == 0]
11:41:14 <nand`> Sonderblade: can of worms
11:41:19 <nand`> there are a few regex packages
11:42:31 <atriq> Every number is a multiple of 1
11:42:42 <atriq> So all numbers get returned at least once, linduxed
11:42:49 <nand`> linduxed: that picks out combinations
11:42:49 <neutrino> ski: what is the difference between the former and the latter?
11:43:11 <nand`> it doesn't test all the numbers [1..5]; it tests each individually and includes the number (perhaps multiple times) if it succeeds
11:43:29 <nand`> > [x | x <- [1..], all ((==0) . mod x) [1..5]]
11:43:32 <lambdabot>   [60,120,180,240,300,360,420,480,540,600,660,720,780,840,900,960,1020,1080,1...
11:43:34 <linduxed> oh, yes that makes sense
11:43:35 <startling> hmmm, is there an equivalent to the Applicative/CFG thing for Regular languages?
11:43:35 <Sonderblade> nand`: any of them good?
11:43:52 <slack1256> on the HTTP package the simpleHTTP can return a lazyBytestring. Does this produce problems as with lazyio or is different because it is a socket?
11:43:59 <linduxed> nand`: that's what i wanted, yes
11:44:03 <nand`> Sonderblade: not really, they're all fairly ugly
11:44:06 <linduxed> nand`: still learning list comprehension
11:44:32 <rwbarton> or
11:44:45 <startling> I'm surprised there's not a parsec-ish thing equivalent to regex
11:44:46 <rwbarton> > [ x | x <- [1..], and [ x `mod` n == 0 | n <- [1..5] ] ]
11:44:48 <lambdabot>   [60,120,180,240,300,360,420,480,540,600,660,720,780,840,900,960,1020,1080,1...
11:45:49 <neutrino> hey, guys. does anyone know a data structure which is like a 2d or 3d matrix of bools, and can be transposed? and so that two of them can hopefully be AND-ed or ORed together?
11:47:11 <watermind> I just upgraded to ghc 7.4.2 and now haskell mode seems to be trying to access 7.4.1 libs
11:47:14 <nand`> transpose :: [[Bool]] -> [[Bool]]
11:47:30 <watermind> e.g. on C-c C-i : Dummy:0:0:Error:/usr/lib64/ghc-7.4.1/settings: openFile: does not exist (No such file or directory)
11:47:40 <nand`> zipWith (zipWith (&&)) :: [[Bool]] -> [[Bool]] -> [[Bool]]
11:47:53 <nand`> of course, they're not necessarily very square
11:47:58 <rwbarton> or if you want a much bigger hammer, repa
11:48:15 <watermind> how do you fix this? I don't remember any such setting where you specify ghc version
11:49:02 <watermind> grepping the .el files doesn't show any 7.4.1 strings anywhere
11:49:13 <nand`> something to do with ENV maybe?
11:50:10 <linduxed> nand`: haha, for [1..5] it was an easy solution
11:50:25 <linduxed> nand`: for [1..15] it went quick too
11:50:28 <neutrino> @type transpose
11:50:30 <lambdabot> [[a]] -> [[a]]
11:50:42 <linduxed> but for [1..20] which is what i need... i'm gonna have to optimze :-P
11:51:05 <watermind> nand`: seems empty
11:51:07 <nand`> an immediate optimization is to use rem instead of mod
11:51:16 <linduxed> why is thaT?
11:51:33 <nand`> rem is more efficient and the two only differ for negative numbers
11:52:02 <rwbarton> mod's behavior on negative numbers is usually what you want but rem is the one your hardward implements
11:52:11 <linduxed> nand`: ok, but it's still too slow
11:52:16 <nand`> yes
11:52:24 <rwbarton> for projecteuler usually you will have to do math rather than "optimize"
11:52:24 <nand`> but surely there are laws governing this thing
11:52:30 <linduxed> maybe i should use [2,4..] instead
11:52:31 <nand`> like
11:52:48 <linduxed> that will be less to check
11:53:00 <Philippin>  Find a loving filipino women today at http://philippinesmatch.com Good women looking for good American men
11:53:56 <nand`> let divides n m = m `rem` n == 0 in  divides n x && divides n y == divides n (f x y) for some ‚Äòf‚Äô and some ‚Äòx‚Äô, ‚Äòy‚Äô
11:53:59 <linduxed> yeah, i could definitely start off by only checking [10,20..]
11:54:16 <neutrino> nand`: thanks for the tip, using transpose i can define other things.
11:54:33 <neutrino> however, how would i rotate a 3d matrix?
11:54:37 <linduxed> yeah, i could definitely start off by only checking [10,20..], or even [20,40..]
11:54:40 <nand`> sorry, flip my parameters on ‚Äòdivides‚Äô
11:55:15 <nand`> I know that for example in the fizzbuzz example divides 3 n && divides 5 n is the same as divides 15 n but that doesn't seem to hold in general; eg. ‚Äò6‚Äô and ‚Äò4‚Äô
11:55:31 <neutrino> in specific, i mean the rotation around the first or second axis, which means that e.g. the top layer becomes the leftmost layer
11:55:47 <nus> watermind, is haskell-program-name set in your ~/.emacs?
11:56:07 <nand`> > let divides n m = m `rem` n == 0 in (divides 6 36 && divides 4 36, divides (6*4) 36)
11:56:09 <lambdabot>   (True,False)
11:56:36 <linduxed> nand`: yeah, i just did [ x | x <- [20,40..], all ((== 0) . (rem x)) [2..20]]
11:57:02 <nand`> neutrino: some combination of ‚Äòtranspose‚Äô and ‚Äòmap transpose‚Äô, perhaps?
11:57:03 <squidz> how can i unregister all my cabal packages and remove them to start over?
11:57:24 <nand`> depends on how exactly you're representing them and what exact transformations you want
11:57:28 <neutrino> nand`: hmm. it is not immediately clear to me.
11:57:33 <startling> squidz, remove ~/.ghc and ~/.cabal, I think
11:58:01 <squidz> startling: i dont have to unregister them?
11:58:12 <startling> squidz, that's where they're all registered.
11:58:14 <squidz> i want to start completely clean
11:58:16 <squidz> okay
11:58:24 <startling> squidz, move them to a new directory to be safe
11:58:39 <startling> but I don't think anything bad will happen
11:59:16 <monochrom> ~/.ghc is where the registration happens
11:59:31 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
11:59:31 <startling> squidz, oh, that won't gt rid of stuff you may have sudo cabal install'd
11:59:53 <squidz> okay but i never sudo cabaled as far as i know
11:59:58 <monochrom> "sudo cabal install" is still "sudo cabal install --user". this means /root/.ghc
12:00:37 <squidz> ill try to move and see
12:00:53 <monochrom> in the future, always sandbox
12:01:17 <startling> monochrom, so what's ~/.cabal for?
12:01:30 <squidz> monochrom: yeah, I found that out after i starting coding
12:01:43 <monochrom> ~/.cabal has the files. ~/.ghc has the registration
12:01:48 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
12:02:01 <startling> monochrom: oh, the source files, right.
12:02:05 <rwbarton> ~/.cabal also has your cabal config and caches of the .tar.gzs from hackage
12:02:08 <monochrom> no source files
12:02:13 <ski> neutrino : in the former case, you have a fixed `F'. in the latter you assume the one thing is provable for any `F', and have to show the other thing is provable for any `F'
12:02:24 <monochrom> I guess source tarballs, but that's irrelevant actually
12:02:39 <startling> monochrom, so the object files and/or type information?
12:02:46 <monochrom> yes
12:02:54 <startling> interesting
12:03:26 <startling> I knew ~/.cabal had source tarballs because over the summer I was internetless and needed to see why some library was doing some dumb thing. :S
12:03:59 <neutrino> ski: suppose you have [["abc", "def", "ghi"], ["123", "456", "789"], ["rst", "uvw", "xyz"]]. I would like to have a function which allows me to get [["r1a", "u4d", "x7g"], ["s2b", "v5e", "y8h"], ["t3c", "w6f", "z9i"]]
12:04:01 <Hermit> monochrom: speaking of cabal, what could be the reason it's ignoring conditional compilation directives?
12:04:36 <Hermit> (including code in the if and else blocks)
12:05:06 <monochrom> because the semantics is prolog semantics, not algol semantics
12:05:50 <Hermit> monochrom: is that your answer?
12:06:38 <monochrom> that is, "if fff then {depends: base > 4} else {depends: base < 2}" means: If you have base>4, set fff to true. If you have base<2, set fff to false. If neither, abort
12:07:41 <neutrino> ski: i was trying to prove the former.
12:07:56 <neutrino> ski: did some part of my argument not hold in that case?
12:07:57 <Hermit> I guess wrong syntax is not the problem here. I'm talking about a handful of packages failing to compile due to cabal ignoring MIN_VERSION_* macros
12:08:34 <monochrom> then I haven't seen that happening
12:08:37 <ski> > (transpose . map transpose . transpose . reverse) [["abc", "def", "ghi"], ["123", "456", "789"], ["rst", "uvw", "xyz"]]
12:08:40 <lambdabot>   [["r1a","u4d","x7g"],["s2b","v5e","y8h"],["t3c","w6f","z9i"]]
12:09:06 <neutrino> oh that's nic
12:09:06 <Hermit> I've had to unpack, comment out, repack, run cabal again the whole morning
12:09:07 <neutrino> e
12:09:08 <ski> neutrino : prove what ?
12:09:15 <neutrino> how have you arrived at this?
12:09:30 <ski> oh, you mean the former of the two alternatives i contrasted
12:09:36 <neutrino> ski: yes.
12:10:21 <neutrino> > transpose . map transpose . transpose $ [["abc", "def", "ghi"], ["123", "456", "789"], ["rst", "uvw", "xyz"]]
12:10:23 <lambdabot>   [["a1r","d4u","g7x"],["b2s","e5v","h8y"],["c3t","f6w","i9z"]]
12:10:37 <ski> "how have you arrived at this?" -- i squinted a bit, and tried it step-by-step
12:11:05 <ski> > (map (map reverse) . transpose . map transpose . transpose) [["abc", "def", "ghi"], ["123", "456", "789"], ["rst", "uvw", "xyz"]]
12:11:07 <lambdabot>   [["r1a","u4d","x7g"],["s2b","v5e","y8h"],["t3c","w6f","z9i"]]
12:11:29 <mpu> Is there a function to get a 'product' of two lists (all pairs)
12:11:41 <ski> (i.e. first adding the `reverse', then the `transpose', then the `map transpose' and finally the `transpose')
12:11:59 <rwbarton> mpu: liftA2 (,)
12:11:59 <Hermit> mpu: zipWith ?
12:12:03 <ski> > liftM2 (,) "abc" "01"
12:12:04 <lambdabot>   [('a','0'),('a','1'),('b','0'),('b','1'),('c','0'),('c','1')]
12:12:18 <mpu> rwbarton: sweet, thanks.
12:12:22 <ski> > zipWith (,) "abc" "012"
12:12:23 <lambdabot>   [('a','0'),('b','1'),('c','2')]
12:12:37 <Ferdirand> > sequence ["abc","123"]
12:12:38 <mpu> rwbarton: not exactly sure to understand the inner details though ...
12:12:39 <lambdabot>   ["a1","a2","a3","b1","b2","b3","c1","c2","c3"]
12:12:44 <monochrom> hmpf! no HWN!
12:12:59 <ski> mpu : it's using the list monad
12:13:00 <Sculptor> do permutations of "abcdef"
12:13:08 <mpu> ski: I guess
12:13:33 <ski> > do x <- "abc"; y <- "01"; return (x,y)
12:13:34 <lambdabot>   [('a','0'),('a','1'),('b','0'),('b','1'),('c','0'),('c','1')]
12:13:43 <ski> > [(x,y) | x <- "abc" , y <- "01"]
12:13:45 <lambdabot>   [('a','0'),('a','1'),('b','0'),('b','1'),('c','0'),('c','1')]
12:14:11 <gbacon> > filterM (const [True,False]) [1,2,3]
12:14:13 <lambdabot>   [[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]
12:14:23 <neutrino> @do [(x,y) | x <- "abc" , y <- "01"]
12:14:24 <lambdabot> [(x, y) | x <- "abc", y <- "01"]
12:14:25 <ski> `liftM2 f ma mb' is `do a <- ma; b <- mb; return (f a b)'
12:14:27 <neutrino> hrm
12:14:34 <ski> @undo [(x,y) | x <- "abc" , y <- "01"]
12:14:34 <lambdabot> concatMap (\ x -> concatMap (\ y -> [(x, y)]) "01") "abc"
12:14:35 <neutrino> there's no tool to get form listcomp to do, is there?
12:14:52 <squidz> so i guess i did have root level packages installed. I forgot that I use XMonad as my X environment which I installed with my distros package manager. Should I install it instead with cabal install from my user? or continue using Arch Linux's pacman to install it?
12:15:22 <squidz> because trying to cabal install cabal-dev has conflicts
12:15:34 <Hermit> ski: what you just did looks like vodoo magic to me
12:15:54 <Hermit> do x <- "abc"; y <- "01"; return (x,y)   <-- specially this
12:16:02 <Hermit> how the...
12:16:02 <squidz> or not conflicts but it's asking me to force reinstall
12:16:44 <ski> Hermit : `do x <- xs; ..x..' is the same as `xs >>= \x -> ..x..' -- in the list monad, this is the same as `concatMap (\x -> ..x..) xs'
12:16:48 <gbacon> > "abc" >>= \x -> "01" >>= \y -> return (x,y)
12:16:50 <lambdabot>   [('a','0'),('a','1'),('b','0'),('b','1'),('c','0'),('c','1')]
12:16:51 <neutrino> Hermit: it uses the list monad.
12:17:00 <ski> and in the list monad, `return x' is `[x]'
12:17:05 <ski> @src [] return
12:17:05 <lambdabot> return x    = [x]
12:17:08 <ski> @src [] (>>=)
12:17:08 <lambdabot> xs >>= f     = concatMap f xs
12:17:08 <neutrino> Hermit: list comprehensions are syntactic sugar for do blocks.
12:17:11 <ski> so
12:17:14 <ski>   do x <- "abc"; y <- "01"; return (x,y)
12:17:17 <ski> is the same as
12:17:22 <neutrino> Hermit: do blocks are syntactic sugar for monad operations.
12:17:36 <Hermit> hmm
12:17:44 <Hermit> I'll read on the list monad
12:17:44 <ski>   concatMap (\x -> concatMap (\y -> [(x,y)]) "01") "abc"
12:18:01 <ski> .. which also happens to be the same as the list comprehension above
12:18:48 <neutrino> Hermit: no don't. just remember that list comprehensions are syntactic sugar for do notation.
12:19:05 <ski> neutrino : .. actually, the expansion for list comprehensions are specified separately (though you're in essence right, module guards (and parallel list comprehensions))
12:19:10 <neutrino> Hermit: do you know how to use list comprehensions? if yes, try writing several, and then translate them to do notation
12:19:19 <neutrino> ski: it's easier to explain this way
12:19:27 <nand`> are list comprehensions really syntactic sugar for monad operations? Not without -XMonadComprehensions, surely?
12:19:33 <ski> neutrino : perhaps. i'm not sure
12:19:40 <neutrino> in effect it's equivalent and all Hermit needs to know
12:20:11 * ski would rather have said that `do' in the list monad is essentially the same as a list comprehension, though
12:20:24 <neutrino> he'll have forgotten this soon enough while having learnt do notation.
12:20:26 <neutrino> :)
12:21:12 <ski> neutrino : if you were trying to show that `..F..' was valid, you could show that by assuming there's a module/structure (specifying a value for `F') where `..F..' is false, and try to derive a contradiction
12:21:27 <ski> neutrino : but i don't see where you get to pick the interpretation of `F' there
12:24:55 <neutrino> ski: i tried proving the theorem with F as a free variable by negating it ad-absurdum, choosing a specific value for the free variable F, and showing that the assumption was contradicted.
12:25:42 <neutrino> this is standard a-a proving strategy.
12:26:15 <squidz> ah i cant install cabal-dev with cabal install
12:27:10 <squidz> i installed cabal-install with my package manager and after that, try to cabal install cabal-dev, but cant
12:27:44 <startling> squidz, is this just a weird tic or what?
12:28:04 <squidz> startling: what do you mean tic?
12:28:26 <startling> squidz, why can't you install cabal-dev?
12:28:42 <neutrino> ski: here's an example of a simpler proof: 2x = x + x. Suppose 2x, and now to enter ad-absurdum mode suppose the right hand side is not equal x+x. Let's take x'=1. Then the right hand side is not 1+1, therefore it is not 2, while being equal to the left side. Therefore we have arrived at a contradiction of our assumption that the left side is equal to 2.
12:28:52 <neutrino> ski: by doing so we have proven the theorem.
12:28:56 <squidz> startling: here's my cabal error http://hpaste.org/77856
12:29:32 <rwbarton> that's not the error
12:29:47 <rwbarton> error is further up
12:29:48 <neutrino> i guess "suppose 2x" makes little literal sense, it's probably better to say "suppose 2x has a value"
12:30:09 <squidz> startling: any idea?
12:30:24 <rwbarton> try cabal install cabal-dev again and paste the whole output
12:30:38 <geekosaur> ummm
12:30:45 <geekosaur> that log shows it installing template-haskell
12:31:00 <geekosaur> that's ALWAYS an error; the only version of template-haskell that will work is the one built into the compiler
12:31:07 <ski> neutrino : i don't follow
12:31:10 <rwbarton> oh yeah that's not good is it
12:31:20 <startling> squidz: what ghc version are you using?
12:31:26 <geekosaur> (and in general I think that failure is telling you that cabal-dev from hackage doesn't yet support ghc 7.6)
12:31:40 <startling> ^ yeah, that's my guess
12:31:47 <squidz> ghc version is 7.6.1
12:32:12 <neutrino> ski: do you know ad-absurdum proofs?
12:32:12 <ski> neutrino : afaiu, using reductio ad-absurdum to prove `Phi' means to assume the negation of `Phi' and manage to derive a contradition
12:32:19 <neutrino> yes.
12:32:53 <ski> neutrino : formally, there's two cases. negation-introduction : prove `not Phi' by assuming `Phi' and deriving a contradiction
12:33:00 <squidz> rwbarton: heres the annotation
12:33:01 <copumpkin> http://math.andrej.com/2010/03/29/proof-of-negation-and-proof-by-contradiction/
12:33:03 <squidz> http://hpaste.org/77856
12:33:14 <ski> neutrino : and proof-by-contradiction : prove `Phi' by assuming `not Phi' and deriving a contradiction
12:33:24 <neutrino> in specific, ad-absurdum means to prove "a => b" can mean to assume "~ (a => b)" which is the same as "a & ~b" which is what we've done here.
12:33:36 <scooty-puff> i'm not sure if this method makes sense, but are class dictionaries strict - MonadDict m = MonadDict !(a -> m a) ... in desugared haskell?
12:33:38 <neutrino> er
12:33:41 <neutrino> that wasn't english
12:33:42 <scooty-puff> *this question
12:33:48 <rwbarton> "unix-2.6.0.0 -> 2.3.2.0" looks very fishy
12:33:55 <neutrino> in specific, ad-absurdum means to prove "a => b" one would assume "~ (a => b)" which is the same as "a & ~b" which is what we've done here.
12:34:00 <neutrino> ^better
12:34:22 <ski> neutrino : yes, but if we're proving `forall F. ..F..', then we have to assume `not (forall F. ..F..)', which is (classically) equivalent to assuming `exists F. not (..F..)'
12:34:26 <rwbarton> squidz: in fact everything about that looks brofen
12:34:42 <ski> neutrino : so, afaics, you have to assume you're given an arbitrary `F' -- you can't choose a specific value for it
12:34:52 <neutrino> ski: and by choosing a specific F in the course of my proof i have done exactly that.
12:34:54 <squidz> rwbarton: yeah, thats why i wanted to start from scratch, but removing .ghc and .cabal didnt seem to help
12:35:04 <ski> neutrino : i don't agree
12:37:07 <neutrino> interesting
12:37:29 <ski> neutrino : consider proving `forall n \in |N. even(n)' by : assume `not (forall n \in |N. even(n))', i.e. `even(n)' is false for some natural number `n'. pick `n' to be `0'. so `even(n)' is also true. contradiction
12:38:01 <ski> neutrino : i hope you'll agree this "proof" is incorrect -- but afaics, you were trying to do the same kind of thing in your proof attempt
12:38:19 <rwbarton> squidz: yeah, it looks like the conclusion is that cabal-dev just does not support ghc 7.6
12:38:25 <neutrino> i see your point
12:39:09 <squidz> hmmm, how could i get around that
12:41:04 <neutrino> maurer: ski has shown that my proof may not have been correct.
12:43:48 <shachaf> @messages
12:43:49 <lambdabot> nand` asked 1h 18m 30s ago: how much would you frown at code that uses implicit parameters to pass along environments, instead of a Reader or something?
12:44:07 <shachaf> nand`: My frowns have been going down in value due to inflation. :-(
12:44:22 <shachaf> rwbarton: ‚òù
12:44:28 <squidz> rwbarton: i can cabal install the new version of cabal-dev from source right?
12:44:37 <shachaf> A frown from me isn't worth what it used to be.
12:44:48 <nand`> withhold frowning
12:44:55 <rwbarton> squidz: how is that any different?
12:44:57 <shachaf> nand`: Eh. Do it if you like.
12:44:58 <rwbarton> i don't understand
12:45:14 <rwbarton> all cabal installs are from source
12:45:15 <shachaf> ImplicitParams are at least relatively simple and expressed in the type.
12:46:07 <newman> hello world anyone here
12:46:07 * Heffalump likes implicit parameters for environments
12:46:25 <atriq> This is one of the biggest channels on the server
12:46:26 <shachaf> newman: There is only silence and some second-hand clothes.
12:46:28 <squidz> rwbarton: i mean cabal install the latest version from git should do it, but i dont know how to cabal install from git
12:46:30 <atriq> Of COURSE there's people here
12:46:37 <rwbarton> squidz: as I see it your broad options are: (1) don't use cabal-dev (2) downgrade to ghc 7.4 (3) figure out how to get it to work with ghc 7.6
12:46:41 <rwbarton> oh i see
12:46:49 <neutrino> so in fact we're trying to prove forall F. (‚àÉx. F x ‚áí y) <= ((‚àÄx. F x) ‚áí y). Assume exists F. ((‚àÄx. F x) ‚áí y) & ~(‚àÉx. F x ‚áí y). Therefore exists F. ((‚àÄx. F x) ‚áí y) & (forall x. ~(F x ‚áí y)). Therefore exists F. ((‚àÄx. F x) ‚áí y) & (forall x. F x & ~y). Therefore an F exists where the fact that F x holds for all inputs means that y is true. However we also see that for all inputs F x holds and y is false. Therefore, for
12:46:50 <squidz> do you know how?
12:46:50 <rwbarton> git clone git://whatever && cd whatever && cabal install
12:46:59 <squidz> okay simple enough
12:47:00 <Heffalump> as I understand it the really dodgy thing with implicit params is to try to change them during a recursive call (or perhaps at all)
12:47:14 <neutrino> ski: does that look better? I think it does.
12:47:27 * nand` is in favor of (1)
12:47:42 <shachaf> whoa, dude. what if, like, everything was an implicit param?
12:47:49 <shachaf> groovy, huh?
12:48:01 <rwbarton> ...
12:48:05 <startling> shachaf, we have already!
12:48:13 <nand`> shachaf: with like, automatic alpha renaming?
12:49:14 * rwbarton can't figure out whether groovy actually has dynamic scoping
12:49:30 <shachaf> Oh, I didn't remember there was a language called that.
12:49:34 <shachaf> I hope it's lexical?
12:49:35 <squidz> rwbarton: alright the latest cabal-dev from git did the trick, thanks
12:49:40 <neutrino> rwbarton: groovy the web framework?
12:49:43 <shachaf> I thought it was very Ruby-inspired, and Ruby has lexical scoping.
12:49:45 <rwbarton> shachaf: See what I expect from you now?
12:50:09 <shachaf> rwbarton: Hey, I'm sick and had about 2 hours of sleep in the last 24.
12:50:43 <rwbarton> maybe one of these will cheer you up: poor shachaf :-(
12:50:44 <shachaf> Why don't you ejonegba us some jonegbas.
12:51:11 <shachaf> rwbarton: Hey, I'm trying to cut down! You're not helping. :-(
12:51:23 <shachaf> Once a frowner, always a frowner.
12:51:41 <ski> neutrino : cut off after "... However we also see that for all inputs F x holds and y is false. Therefore, for"
12:52:03 <mpu> How do I invert an ordering?
12:52:29 <rwbarton> I seem to recall some wild trick involving implicit params + constraint kinds
12:53:03 <shachaf> mpu: ?
12:53:19 <mpu> I want 'sort' to go in the other direction...
12:53:22 <shachaf> There are at least three answers to that question.
12:53:23 <neutrino> Therefore, for all inputs y is true and false.
12:53:27 <shachaf> Ah, sortBy (flip compare)
12:53:39 <shachaf> The other two I was thinking of were "compare EQ" and "Data.Ord.Down"
12:53:40 <mpu> flip... thanks
12:53:51 <ski> Heffalump : it's not clear (to me) how you can substitute "equals-for-equals" or "distribute" implicit-parameter-bindings safely
12:53:55 <shachaf> mpu: Well, you don't need to know about flip to write this.
12:53:59 <shachaf> sortBy (\x y -> compare y x)
12:54:32 <shachaf> rwbarton: In my defense, I can't think of any word in English that isn't the name of some programming language.
12:54:39 <mpu> shachaf, I know, I was thinking of a function mapping Le to Ge and vice versa
12:54:56 <mpu> to compose with
12:55:03 <ski> neutrino : i think it's ok now
12:55:14 <shachaf> mpu: Yes, well, I gave you one of those too. :-)
12:55:20 <shachaf> > map (compare EQ) [LT,EQ,GT]
12:55:23 <lambdabot>   [GT,EQ,LT]
12:55:24 <Heffalump> ski: what do you mean by "distribute"?
12:55:55 <mpu> wow, compare EQ... what a trick
12:56:00 <ski> neutrino : you've shown `y & (forall x. ~y)', and therefore also shown `forall x. y & ~y' -- however this isn't the same as `y & ~y' (since that would need to assume there's at least one element in the domain of `y')
12:56:44 <neutrino> ski: yes, i said i showed forall x y & ~y.
12:56:51 <neutrino> that is a contradiction in itself.
12:56:52 <ski> Heffalump : like going from `let ?x = e in e0 e1' to `(let ?x = e in e0) (let ?x = e in e1)' -- and for other expression nodes than application
12:57:01 <ski> neutrino : i don't agree
12:57:03 <rwbarton> neutrino, not if the domain of x is empty
12:57:21 <ski> neutrino : in case the domain is empty, then `forall x. y & ~y' is true
12:57:39 <neutrino> if the domain of x is empty the proof reduces. i think we can safely assume it is not in this case.
12:57:55 <neutrino> but that's a good catch.
12:57:57 <ski> (since if the domain is empty, then `forall x. ..x..' is always true, it's vacuosly true, regardless of what `..x..' is)
12:58:04 <Heffalump> ski: can you give an example of where that goes wrong?
12:58:14 <ski> neutrino : "the proof reduces" meaning ?
12:58:43 <ski> Heffalump : not off-hand, but i suspect it must go wrong in some cases
12:59:32 <ski> Heffalump : perhaps something like going from `let ?x = e in \p0 -> e1' to `\p0 -> let ?x = e in e1'
12:59:49 <neutrino> ski: it means there's a separate method of proving the theorem for when the domain of x is empty.
13:00:42 <ski> or going from `let ?x = e in Just e0' to `Just (let ?x = e in e0)', in case one can express the type `(?x :: T) => Maybe ((?x :: T) => U)' (looking like it needs `ImpredicateTypes')
13:02:36 <Heffalump> I think those two expressions have the same type
13:05:47 <ski> Heffalump : it's not clear (to me) when `(?x :: T) => ' get hoisted out and when not
13:06:20 <Heffalump> ski: why does it differ from type classes?
13:07:09 <ski> for type classes, there's at most one possible instance which can be used (and the passing of these is silent in the surface code)
13:07:19 <Heffalump> I mean, I know the meaning of implicit parameters is more subtle because you can give different instantiations. But the rules for when type class constraints are hoisted out of types are clear (I hope!), so they should also be clear for implicit parameters.
13:07:41 <ski> for implicit-parameters, you can have several different values of `?x', and you have expression nodes for manipulating this
13:07:49 <zypper> I'm trying to `read' a value from a string, with a default value if the read fails. Is there are `readMaybe' function or something similar?
13:08:25 <ski> Heffalump : so, i guess it's not clear to me what implications this have re which "movements" of `let ?x = e in' are valid
13:08:30 * zypper didn't notice there *is* a readMaybe function.
13:08:32 <ski> (semantics-preserving)
13:08:55 <rwbarton> new in 7.6
13:09:09 <heatsink> Is there a name for the operation isomorphic to fmap (const ()) that gets the "shape" of a functor while discarding its contents?
13:09:12 <ski> neutrino : in case the domain is empty, then `‚àÄx. F x' is true. so `(‚àÄx. F x) ‚áí y' is as true as `y'. however `‚àÉx. (F x ‚áí y)' is false if the domain is empty (since there's no `x'), so the implication is equivalent to `false ‚áê y', iow `¬¨ y'. so in case the domain (of `x') is empty, the whole formula `‚àÄ F. (‚àÉx. (F x ‚áí y)) ‚áê ((‚àÄx. F x) ‚áí y)' is false in case `y' is true (this is assuming there is at least one `F', yes)
13:10:26 <Heffalump> http://www.haskell.org/ghc/docs/latest/html/users_guide/other-type-extensions.html#implicit-parameters documents a difficult case (search for "polymorphic recursion") and my general takeaway from that is not to use implicit parameters recursively at all
13:12:05 <neutrino> ski: oh, indeed
13:12:37 <neutrino> ski: so i guess the implication to the left only holds for non-empty {x}?
13:12:51 <neutrino> ski: i assumed it was true for empty {x} since that's what maurer stated beforehand.
13:13:07 <ski> ok
13:14:43 <smg> hi
13:14:49 <mapf> hi
13:14:50 <ski> neutrino : the implication to the left holds in case `y' is false or the domain of `x' is non-empty
13:14:59 <ski> (either suffices)
13:15:20 <act> is djinn still on here
13:15:35 <ski> @djinn NotNot (Either a (Not a))
13:15:35 <lambdabot> f a = void (a (Right (\ b -> a (Left b))))
13:15:41 <act> o nice
13:15:55 <Ralith> NotNot?
13:15:57 <Sonderblade> which code is best: zip (map ("parent" </>) bah) bah OR [("parent" </> f, f) | f <- bah] ?
13:16:02 <neutrino> ski: mhm
13:16:04 <ski>   type NotNot a = Not (Not a)
13:16:08 <Ralith> Not?
13:16:13 <neutrino> act: what editor do you use?
13:16:15 <ski>   type Not x = x -> Void
13:16:22 <act> neutrino: geany
13:16:34 <ski>   void :: Void -> a
13:16:49 <neutrino> act: oh, ok. if you were using vim, i have just made a djinn plugin which allows you to invoke it on type signatures in your code.
13:16:56 <Ralith> that seems somewhat silly
13:17:04 <neutrino> i'm not sure if it's just as possible with geany.
13:17:32 <ski> Sonderblade : a third option is `map (\f -> ("parent" </> f, f)) bah'
13:18:41 <nand`> map ("parent" </>) &&& id
13:19:05 <startling> nand`: you beat me. :)
13:19:31 <niteria> if you had to choose between alex, happy and bnfc what would you use?
13:19:42 <smg> I want to conditionally transform a subtree of XML using HXT - I've used `when` for it so far - but what about specifying multiple conditions  ...
13:19:50 <heatsink> Alex and happy aren't mutually exclusive
13:19:53 <smg> say - subtree has to contain node with name "foo" _and_ another node with name "bar"
13:19:59 <act> neutrino: that sounds cool. Don't think it work in geany though.
13:20:07 <act> it would work*
13:20:34 <startling> act, you can't writer plugins for geany?
13:20:37 <smg> (f `when` h) `when` g  - or is there a better combinator available?
13:21:00 <startling> > foldl when f [h, g]
13:21:01 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
13:21:02 <lambdabot>              with actual type...
13:21:09 <startling> :t when
13:21:11 <lambdabot> Monad m => Bool -> m () -> m ()
13:21:12 <jfischoff> so there is Bifunctor‚Ä¶is there Biapplicative?
13:21:13 <lambdabot> jfischoff: You have 1 new message. '/msg lambdabot @messages' to read it.
13:21:18 <jfischoff> @msg
13:21:19 <lambdabot> Not enough privileges
13:21:23 <act> startling: you can but I've never written one so I dont know
13:21:27 <niteria> ok so using bnfc converter would be easiest
13:21:27 <startling> jfischoff, there's bifoldable and bitraversable
13:21:32 <jfischoff> @messages
13:21:33 <lambdabot> edwardk said 16h 54m 16s ago: http://iamlasun8.mathematik.uni-karlsruhe.de/~ae16/preprnts/slides_neher_2003_aca03.pdf is a good, practical, taylor model overview
13:21:43 <jfischoff> cool
13:21:43 <Sonderblade> nand`: &&&?
13:21:50 <Ralith> :t (&&&)
13:21:52 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
13:22:07 <edwardk> heya
13:22:25 <startling> jfischoff, how would pure work for biapplicative
13:22:26 <startling> ?
13:22:53 <startling> you'd need to encapsulate the Either- and (,)-type uses somehow
13:22:56 <Sonderblade> it's not defined anywhere
13:22:58 <niteria> is it possible to tell bnfc to save line numbers and offsets in AST?
13:23:11 <jfischoff> startling: it would return an associated type that is like pair, so I guess it would take in two args
13:23:15 <jfischoff> or
13:23:26 <jfischoff> wait bipure :: a -> Tensor a a
13:23:38 <startling> jfischoff, right, that doesn't let you have Either-type things
13:23:47 <jfischoff> yes
13:24:00 <jfischoff> I guess you are constrained to product categories
13:24:12 <startling> which is one of the coolest parts about bi{functor, foldable, traversable} imo
13:24:31 <snorble_> had a look at webkit, became depressed by C++ having a monopoly on browser engines. Sigh. If only there was somebody insane enough to do one in Haskell.
13:25:15 <startling> snorble_: ikr
13:25:23 <startling> C even
13:25:25 <jfischoff> startling: working with sum types?
13:25:32 <startling> jfischoff: yeah
13:25:40 <startling> snorble_, have you seen Rust and Servo?
13:25:41 <jfischoff> I'll have to think about that
13:25:55 <heatsink> Well, next time someone comes by saying they want to learn haskell and they're looking for a starter project...
13:25:55 <Ralith> someone did one in common lisp once
13:25:59 <Ralith> it became unmaintained
13:26:18 <startling> > bitraverse putStrLn print $ Left "hello"
13:26:19 <lambdabot>   Not in scope: `bitraverse'
13:26:20 <lambdabot>  Perhaps you meant one of these:
13:26:20 <lambdabot>    `itraverse' ...
13:26:26 <startling> aww
13:26:49 <snorble_> startling: yeah, I know of it, as far as I know they'r keeping the rendering from Gecko. But it's a start. A pity they had to invent a language to do it.
13:27:37 <startling> snorble_: yeah. Rust is pretty meh
13:27:57 <startling> but it's better than C++
13:28:54 <mapf> how to prove associativity of arrow composition in Rel?
13:29:20 <squidz> i know this doesnt really have to do with haskell, but doesn anybody know of any good books to learn ruby a functional manner?
13:29:22 <ski> Heffalump : hm, this made me think of the following definition of referential-transparency : a context `C' is ref.-trans. iff for any expression `E' and any value `v', `C[E] [x |-> v]' is equivalent to `C[E [x |-> v]] [x |-> v]'
13:30:28 <smg> startling, thanks
13:31:12 <ski> (or generalizing to any monad : (`m' a monad), an `f :: m a -> m b' is ref.-trans. iff for any `ma :: m a', `f ma' is equal to `ma >>= \a -> f (return a)' -- which is in turn equivalent to there being a `g :: a -> m b' with `f' equal to `(g =<<)')
13:32:14 <ski> Heffalump : perhaps one could try to generalize "not to use implicit parameters recursively" to, "not to use implicit parameters nestedly" (iow overriding) ..
13:33:55 <Heffalump> ski: well, if there's a case where doing that is broken, yes :-)
13:36:46 <ski> i think we need to define "broken"
13:37:07 <ski> one possible value is "code behaves differently if a type signature is added"
13:37:22 <Heffalump> your referential transparency definition above is superficially plausible, so I'll accept that for now :-)
13:37:58 <ski> another could be something like "breaks ref.-trans."
13:38:06 <Heffalump> ok, and I can sort of see how that might break with implicit params, but only sort of
13:38:35 <Heffalump> I'd definitely agree about adding a type signature
13:38:41 <ski> a third could be "breaks reasoning-laws", like perhaps the distributivities mentioned above
13:39:17 <ski> (istr seeing some other case where adding a type signature changes behaviour -- not using defaulting or implicit parameters)
13:39:55 <Heffalump> yeah, I think type generalization can confuse that in a number of ways
13:43:59 <niteria> is anyone aware of any toy / simple / small compilers written in haskell with an open source? Preferably using bnfc converter
13:47:58 <gbacon> niteria: https://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours
13:48:02 <pordan30> niteria: BNFC-meta generates an LALR parser and pretty printer from a BNF grammar; BNFC generates an Alex source and Haskell AST from a BNF grammar; they are both on Hackage.
13:48:37 <gbacon> niteria: but I don't believe it generates machine code
13:48:41 <niteria> gbacon: isn't that just an interpreter
13:48:47 <niteria> yeh
13:48:49 <niteria> yeah
13:50:16 <niteria> and it uses Parsec and to use Parsec I'd have to modify my grammar
13:50:29 <hpaste> neutrino pasted ‚ÄúThis is why I like Haskell‚Äù at http://hpaste.org/77860
13:53:04 <niteria> BNFC-meta looks nice, version number (0.4.0.1) worries me though
13:53:39 <edwardk> niteria; we don't tend to like 1.0 releases here in the haskell world ;)
14:01:17 <rwbarton> edwardk: bug in the big lens hierarchy diagram: in the "Fold s a" box the signature for view and (^$) is flipped
14:01:56 <edwardk> i blame shachaf. one sec
14:02:42 <edwardk> found it. yep
14:02:46 <copumpkin> it's always shachaf's fault
14:02:50 <copumpkin> regardless of what "it" may be
14:04:51 <edwardk> rwbarton: i can't fix it. since i upgraded my laptop flash dies a horrible death the moment i do anything, so i can't get onto creately to edit the diagram.
14:04:59 <edwardk> i'll put in a bug for shachaf ;)
14:05:09 <shachaf> edwardk: Ugh, don't make me find that link again.
14:05:17 <shachaf> Give copumpkin the link.
14:05:53 <edwardk> http://creately.com/diagram/h5nyo9ne1/QZ9UBOtw4AJWtmAKYK3wT8Mm1HM%3D
14:05:59 <neutrino> edwardk: what OS are you on?
14:06:23 <neutrino> and what browser?
14:06:43 <copumpkin> what about the diagram?
14:07:00 <edwardk> osx. i think its the fact that i'm on a retina 13" macbook pro. they had a bunch of flash issues on the 15" rMBP, which were fixed, but i still can't watch embedded youtube videos in chrome on my laptop
14:07:33 <cmccann> and nothing of value was lost
14:07:35 <gbacon> edwardk: paid Haskell work partnering with looking very likely, last Q1 next year
14:07:36 <edwardk> copumpkin: basically the signature of view and (^$) in Fold is flipped
14:07:40 <copumpkin> oh
14:07:46 <copumpkin> I thought this was about everything being shachaf's fault
14:08:03 <edwardk> gbacon: ?
14:08:28 <gbacon> oops, wrong Edward K
14:08:36 <shachaf> There's more than one?!
14:08:37 <neutrino> edwardk: ok, can't help you there.
14:09:04 <copumpkin> gbacon: edwardk is the only Edward K that matters
14:09:15 <neutrino> copumpkin: be nice
14:09:22 <neutrino> gbacon: partnering with whom?
14:09:26 <edwardk> copumpkin: i figure it happened when he alpha renamed everything in the diagram
14:09:38 <gbacon> neutrino: oops, partnering with Galois
14:09:47 <copumpkin> neutrino: I'm always nice
14:09:49 <neutrino> gbacon: fun :)
14:10:02 <neutrino> copumpkin: non e' vero.
14:10:20 <copumpkin> no u
14:10:35 <shachaf> Easy enough to find out: http://hackage.haskell.org/package/lens-3.0
14:10:50 <edwardk> nope. its my fault
14:10:54 <edwardk> shachaf is exonerated
14:10:58 * merijn always blames shachaf
14:11:05 <shachaf> copumpkin: :: really means "has a type isomorphic to"
14:11:14 * edwardk returns to goading him to fix it anyways ;)
14:11:44 <gbacon> 'k' : "mett"?
14:12:05 <copumpkin> http://en.wikipedia.org/wiki/Mett
14:13:09 <nexx> Mett \o/
14:13:11 <edwardk> thats me
14:13:22 <gbacon> ok, right Edward K then
14:13:57 <edwardk> good. was afraid i'd been cloned again.
14:15:37 <shachaf> cloneEdwardk :: LensLike (Bizarre a b) s t a b -> Traversal s t a b
14:16:04 <rwbarton> is there a SimpleTraversal s a -> SimpleTraversal (t, s) (t, a)
14:16:10 <rwbarton> er
14:16:19 <edwardk> how would it work legally?
14:16:25 <rwbarton> yeah it doesn't seem to make much sense now
14:16:37 <rwbarton> okay here is my real problem
14:16:38 <edwardk> :t beside
14:16:40 <lambdabot> Applicative f => LensLike f s t a b -> LensLike f s' t' a b -> LensLike f (s, s') (t, t') a b
14:16:48 <rwbarton> I tried beside but I think it's not what I wanted
14:17:33 <edwardk> :t alongside
14:17:35 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Context a b) s t a b -> LensLike (Control.Lens.Internal.Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
14:17:35 <rwbarton> I have a list of (key,value) pairs and I want to get all (key,value') pairs where I have a SimpleTraversal value value'
14:17:43 <mapf> hell
14:17:47 <rwbarton> that sounds more promising
14:18:06 <edwardk> lets see
14:18:31 <rwbarton> and actually this (key,value) thing is inside some other object
14:18:40 <rwbarton> I just want to extract it though
14:19:03 <edwardk> so you want to get all of the key value pairs?
14:19:10 * edwardk is a little confused
14:19:31 <rwbarton> I want to get a (key,string) pairs for all the values that are of the form String string
14:19:34 <edwardk> [(1,2),(3,4)] and you want to update the 2 and 4 with your traversal?
14:19:54 <rwbarton> sure
14:20:04 <rwbarton> or [(1,Left 2),(3,Right 4)] and I want [(3,4)]
14:20:49 <edwardk> ah, icky.
14:21:13 <edwardk> there should be a nice way to do this with the pieces we have, hrmm
14:21:30 <edwardk> so you have something like 'traverseRight'?
14:21:37 <rwbarton> yes
14:21:41 <edwardk> :t catMaybes
14:21:43 <lambdabot> [Maybe a] -> [a]
14:23:49 <edwardk> :t value
14:23:51 <lambdabot> (Applicative f, Indexed k k1) => (k -> Bool) -> k1 (v -> f v) ((k, v) -> f (k, v))
14:24:13 <mapf> it seems that any finite category is kind of partial ordering
14:24:25 <edwardk> this is one of those messy things where you want a 'filterMap' or something, which isn't given to us.
14:24:27 <mapf> is similar in some sense
14:25:11 <edwardk> mapf: the partial ordering would have only at most one arrow between any two objects. that is a 'thin' category.
14:25:40 <mapf> hm, yes
14:25:55 <rwbarton> hm
14:26:07 <rwbarton> if I have an IndexedTraversal can I get out a list of (index,value) pairs?
14:26:13 <edwardk> yeah
14:26:32 <edwardk> :t withIndicesOf
14:26:34 <lambdabot> Functor f => Overloaded (Index i) f s t a b -> LensLike f s t (i, a) (j, b)
14:26:54 <edwardk> > ["hello","world"]^..withIndicesOf itraversed
14:26:56 <lambdabot>   [(0,"hello"),(1,"world")]
14:27:25 <rwbarton> > M.fromList [(1, Left "a"), (2, Right "b")] ^.. withIndicesOf traverseRight
14:27:27 <lambdabot>   Couldn't match expected type `Control.Lens.Type.Overloaded
14:27:27 <lambdabot>                 ...
14:27:46 <rwbarton> oh
14:28:25 <edwardk> > M.fromList [(1, Left "a"), (2, Right "b")] ^.. withIndicesOf (traverse.traverseRight)
14:28:27 <lambdabot>   Couldn't match expected type `Control.Lens.Indexed.Index
14:28:27 <lambdabot>                   ...
14:28:32 <rwbarton> > M.fromList [(1, Left "a"), (2, Right "b")] ^.. withIndicesOf (traverseRight . itraversed)
14:28:34 <lambdabot>   Couldn't match expected type `Data.Map.Map
14:28:35 <lambdabot>                                 ...
14:28:39 <rwbarton> > M.fromList [(1, Left "a"), (2, Right "b")] ^.. withIndicesOf (itraversed . traverseRight)
14:28:41 <lambdabot>   Couldn't match expected type `Control.Lens.Indexed.Index
14:28:41 <lambdabot>                   ...
14:28:44 <edwardk> > M.fromList [(1, Left "a"), (2, Right "b")] ^.. withIndicesOf (itraversed <. traverseRight)
14:28:46 <lambdabot>   [(2,"b")]
14:28:52 <rwbarton> whoa
14:29:17 <edwardk> ou want the index from the traversal of the map, not the either, hence the (<.)
14:29:27 <rwbarton> I see
14:31:58 <edwardk> > M.fromList [(1, Left "a"), (2, Right "b")]^..indicesOf (itraversed <. traverseRight)
14:32:00 <lambdabot>   [2]
14:32:23 <edwardk> note that that is only a fold, not a traversal so you cant update with it, etc.
14:32:26 <rwbarton> yup
14:36:18 <shachaf> "traverse" sticks out a littl next to names like itraversed and mapped and folded.
14:36:27 <ThePawnBreak> hi guys; I'm a haskell newbie, can you tell me what's wrong with this code, please? reverse.show.foldl(*)1.map(+1)$[1..3]
14:36:44 <shachaf> ThePawnBreak: Why are you writing code like that if you're just starting out?
14:36:48 <shachaf> > reverse.show.foldl(*)1.map(+1)$[1..3]
14:36:48 <edwardk> yeah sadly i don't think i can get the name 'map' or 'fold' for my own purposes.
14:36:50 <lambdabot>   "42"
14:37:01 <ThePawnBreak> it's a puzzle I'm trying to solve
14:37:12 <edwardk> also itraversed and itraverse have tension, because only one can be the thing you use directly and the other is the one you want as an indexed traversal
14:37:31 <edwardk> i thought about adding 'traversed' as an alias, but it seemed silly.
14:37:36 <shachaf> I guess renaming traverse to traversed is -- yes.
14:37:45 <ThePawnBreak> shachaf: can you please tell me if there's a simple syntax error in my code?
14:37:50 <edwardk> or maybe making "traversed = indexed traverse"
14:37:57 <shachaf> ThePawnBreak: lambdabot just ran your code, so it looks OK to me.
14:38:05 <ThePawnBreak> can you tell me the output, please?
14:38:08 <copumpkin> "42"
14:38:11 <copumpkin> it just did
14:43:02 <edwardk> shachaf: i'm wondering if we should dust off mgsloan's lenq dsl and get it down to a simple enough form we can push it out
14:44:26 * shachaf looks
14:44:47 <shachaf> Ah, he showed this to me, I think.
14:45:16 <shachaf> Is that the thing where you write isomorphisms by using pseudo-Haskell such that all the expressions are patterns?
14:45:41 <edwardk> first2 = $(lense [e| \(x,y,z) -> (x,y) |])
14:45:42 <edwardk> yeah
14:46:01 <shachaf> Well, lenses, not just isomorphisms, I guess.
14:46:19 <edwardk> he goes farther than i'm probably willing to go in terms of willy nilly changing of semantics, but the core of it i completely buy
14:46:45 <shachaf> Farther how?
14:47:03 <edwardk> he was using 'traverse' like a keyword and applying Iso's like functions, etc.
14:47:08 <edwardk> or getting ready to
14:47:30 <shachaf> Ah.
14:47:50 <edwardk> he also had a whole system where you could make top level declarations this way
14:48:32 * shachaf wonders what use cases for this are.
14:48:34 <edwardk> i definitely want the expression dsl for lenses.
14:49:08 <edwardk> the main usecase was that you could write just the pattern match half of a lens and get the reconstruction for free
14:49:30 <edwardk> _2 f (a,b) = (,) a <$> f b   -- all you need is the (a,b) -> b  part of that
14:49:34 <edwardk> the (,) a   is inferred
14:50:00 <edwardk> and that is the ugly part of writing a lens for something with records
14:50:06 <shachaf> How many interesting lenses are there that are simple enough to be expressed in this DSL and not simple enough to be autogenerated as field accessors?
14:50:30 <edwardk> shachaf: the main usecase is when you want to do type-changing lenses for something where more than one field contains something of that type.
14:50:46 <shachaf> Ah, hmm.
14:50:56 <edwardk> data Foo a b = Foo { _x, _y :: a, _t :: b }
14:51:26 <edwardk> he lens for x or the lens for y in isolation can't change the type 'a'
14:52:24 <edwardk> but $(lense [e| \f -> (_x f, _y f) |]) can change 'a'
14:52:41 <edwardk> i do have to admit though, we've done pretty well without it
14:53:11 * shachaf wonders whether there's a reasonable way to extend this to traversals.
14:53:24 <shachaf> Well, there's the obvious partsOf way.
14:53:25 <edwardk> that was why he started going nuts with 'traverse' as a keyword and stuff =P
14:56:29 <shachaf> Hmm, the TH is pretty small.
14:59:17 <edwardk> remarkably so
15:04:29 <mSSM> About as-patterns in do-blocks: I had lambdabot desugar this the following code; why does it desugar the as-opattern into a case-expression?
15:04:31 <mSSM> @undo do Ising (rg, grid@(Grid (n,_))) <- S.get ; x <- l $ (`mod` n) <$> random rg ; up (i+1) ns
15:04:32 <lambdabot> S.get >>= \ a -> case a of { Ising (rg, grid@(Grid (n, _))) -> l $ (`mod` n) <$> random rg >>= \ x -> up (i + 1) ns; _ -> fail ""}
15:04:48 <shachaf> mSSM: Because what if it fails?
15:05:06 <mSSM> shachaf: The failing is implicitly taken care of in the do-block?
15:05:21 <shachaf> Yes.
15:05:25 <shachaf> @where report
15:05:26 <lambdabot> http://www.haskell.org/onlinereport/haskell2010/ (more: http://www.haskell.org/haskellwiki/Definition)
15:05:57 <mSSM> shachaf: what do you want me to look at there?
15:06:08 <monochrom> all patterns in do-block become case. not just @
15:06:23 <shachaf> mSSM: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-470003.14
15:07:39 * shachaf can't get th-build to build.
15:07:42 <shachaf> Is it a 7.6 thing?
15:08:51 <mSSM> monochrom: thanks, I guess that's an important thing to know :-)
15:09:24 <shachaf> mSSM: Fortunately the Report is always there to answer our questions. :-)
15:09:37 <mSSM> shachaf: I am reading it, but I am not sure how the pattern matching comes in there?
15:09:52 <shachaf> Do you see the section Translation?
15:10:21 <mSSM> shachaf: I do
15:10:40 <shachaf> Do you see which of the four cases is relevant here?
15:10:55 <mSSM> shachaf: number 3? :)
15:11:05 <shachaf> Yep.
15:11:14 <shachaf> Can you see the pattern matching happening? :-)
15:11:56 <mSSM> shachaf: so if the pattern matches, do {stmts}, otherwise throw errors?
15:12:10 <shachaf> Otherwise uses "fail", yes.
15:12:12 <shachaf> Hmm... Depending on how you read the report, can the name "ok" be shadowed?
15:12:22 <monochrom> fail does not necessarily throw errors
15:12:52 <mSSM> I didn't mean errors in the error type way
15:13:28 <monochrom> pretend "ok" is a fresh name, no clash with any other name you use. such is the convention of reading desugaring
15:13:29 <mapf> :t fail "hah!"
15:13:31 <lambdabot> Monad m => m a
15:13:46 <mSSM> shachaf: but this is cool; thank you
15:13:52 <shachaf> > do { Just x <- Just 5; ok (Just 6) }
15:13:54 <lambdabot>   Not in scope: `ok'
15:13:54 <lambdabot>  Perhaps you meant one of these:
15:13:55 <lambdabot>    `or' (imported from ...
15:13:56 <shachaf> lambdabot: Noncompliant!
15:14:55 <mapf> > (do { Just x <- Nothing; return x }) :: Either String Int
15:14:57 <lambdabot>   Couldn't match expected type `Data.Either.Either
15:14:58 <lambdabot>                           ...
15:15:42 <mapf>  > (do { Just x <- Nothing; return x }) :: Maybe Int
15:15:56 <monochrom> space before >
15:16:06 <mapf> > (do { Just x <- Nothing; return x }) :: Maybe Int
15:16:08 <lambdabot>   Nothing
15:16:31 <mapf> > (do { Just x <- return Nothing; return x }) :: IO Int
15:16:33 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO GHC.Types.Int))
15:16:34 <lambdabot>    arising fro...
15:16:58 <monochrom> yeah, it is not going to print out an IO action
15:17:31 <mapf> > unsafePerformIO ((do { Just x <- return Nothing; return x }) :: IO Int)
15:17:33 <lambdabot>   Not in scope: `unsafePerformIO'
15:18:34 <mapf> > trace "hehe!" 10
15:18:36 <lambdabot>   Not in scope: `trace'
15:19:28 <mapf> ok, only pure compurations
15:20:05 <monochrom> w00t, new Cartesian Closed Comic!
15:20:52 <monochrom> many teachers also don't know the difference between parsing and evaluation order
15:21:07 <shachaf> monochrom++
15:21:07 <neutrino> haha.
15:21:38 <monochrom> 0*(39283943+1234567)  not going to evaluate 39283943+1234567 first
15:23:37 <monochrom> the negative impact on #haskell is that newbies come here asserting that foldr "starts from the end of the list", just because x+(y+z) "starts from y+z"
15:25:14 <shachaf> monochrom: That may not be the only reason.
15:25:32 <shachaf> If you think of foldr as an imperative loop on an array with an accumulator, you might have similar intuition.
15:26:34 <dobblego> I prefer to tell newbies that there is no starting from an end of the list; rather, foldr f z replaces every (:) with f and [] with z, then give them a set of exercises where they can entertain this (e.g. write map with foldr)
15:27:08 <shachaf> Everyone prefers to tell them that; but they seem to prefer not to listen.
15:27:21 <dobblego> this is true, but I force the issue
15:27:34 <dobblego> just by repetition, until it sinks in
15:28:04 <dobblego> e.g. "I wish to append y to x, in what list do I replace which with what?"
15:28:04 <monochrom> the newbies assume a wrong evaluation order. that order would be right in SML
15:28:37 <dobblego> it is pretty obvious that to perform x ++ y, you replace (in x) every (:) with (:) and [] with y
15:28:50 <shachaf> Is there a way to use TH slices in ghci?
15:29:40 <shachaf> monochrom: I was going to say that perhaps f a (f b (f c z)) would evaluate a before ever getting to the parentheses, but then I realized that a would already be evaluated.
15:29:45 <shachaf> Haskell has corrupted my mind.
15:30:35 <monochrom> heh heh heh!
15:31:34 <shachaf> Maybe I should be envious of the strict languages and their bottomless types.
15:31:51 <monochrom> I use foldr (||) False (repeat True)
15:34:06 <monochrom> @let {0 √ó b = 0; a √ó b = a*b}
15:34:07 <lambdabot>  <local>:3:1: parse error on input `{'
15:34:13 <monochrom> @let 0 √ó b = 0; a √ó b = a*b
15:34:15 <lambdabot>  Defined.
15:34:29 <tallpeak> I wonder why Haskell Platform is almost a gig ... I don't mind particularly, but it seems like there might be some opportunities for code reuse to reduce that?
15:34:31 <monochrom> > foldr (√ó) 100000 [0 ..]
15:34:32 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
15:34:39 <monochrom> hate this
15:34:41 <shachaf> tallpeak: Yes, there was a thread lamenting that.
15:34:44 <Sonderblade> what is the type signature for a recursive list of list of strings?
15:34:47 <monochrom> @undefine
15:34:56 <shachaf> tallpeak: Lots of static linking and profiling libraries and what not.
15:35:18 <monochrom> > let {0 ## b = 0; a ## b = a*b} in foldr (##) 100000 [0 ..]
15:35:20 <shachaf> Sonderblade: [[String]], assuming "recursive list" means "list"
15:35:22 <lambdabot>   0
15:36:23 <monochrom> perhaps the future lies in ghclive
15:36:35 <monochrom> @get-shapr
15:36:36 <lambdabot> shapr!!
15:36:48 <shachaf> @hej-shapr
15:36:49 <lambdabot> shapr!!
15:36:51 <ski> @put-shapr
15:36:51 <lambdabot> shapr!!
15:36:58 <monochrom> shapr!! is there a canonical ghclive website?
15:36:59 <eikke> is there any consensus on using MonadIO m => m a instead of IO a in libraries?
15:37:14 <Cale> tallpeak: It's all the static linking, I'm pretty sure.
15:37:15 <monochrom> no
15:37:20 <shachaf> eikke: Let's don't?
15:37:21 <Sonderblade> shachaf: i meant a list nested arbitrarily deep
15:37:34 <luite> monochrom: it's not really meant to be a permanent thing, since there's no built-in security
15:37:39 <shachaf> eikke: Are you proposing using it for everything, like putStrLn?
15:37:53 <shachaf> Sonderblade: I think that's normally called a "tree"
15:37:57 <Cale> tallpeak: Everything is statically linked for a few decent reasons, but it makes the binaries a bit hefty.
15:37:59 <eikke> shachaf: yup, to be able to get rid of liftIO all around
15:38:02 <aristid> eikke: most people use IO for everything.
15:38:12 <monochrom> tallpeak, the bulk of haskell platform's 1G is GHC
15:38:45 <parcs`> tallpeak: ghc by itself is around 700M, and it comes with two copies of each library. one static copy, one copy with shared libs, and one static copy with profiling hooks
15:38:57 <eikke> aristid: yes, but that's kinda annoying when using their stuff in a monad stack
15:39:22 <atriq> Most ridiculous not-higher-order type I've written: "tumblrPosts :: (HasAPIKey k, MonadBaseControl IO m, MonadResource m, MonadReader k m) => BaseHostname -> Maybe PostType -> Maybe Int -> Maybe String -> Maybe Int -> Maybe Int -> Maybe Bool -> Maybe Bool -> Maybe PostFilter -> Manager -> m Value"
15:39:23 <shachaf> "monad stacks" are indeed "kinda annoying" :-(
15:39:44 <shachaf> atriq: That doesn't look like a happy type.
15:39:52 <atriq> shachaf, no, it isn't
15:39:57 <Jafet> atriq: you should describe how you feel in a tumblr post
15:40:12 <aristid> atriq: sounds like it wants a record!
15:40:13 <atriq> Jafet, I'm too busy reblogging pictures of cats
15:40:29 <eikke> atriq: so you're thay guy!
15:40:36 <atriq> eikke, which guy!?
15:40:40 <atriq> I'm a guy!?
15:40:48 <eikke> (sorry, I wouldnt know the latter)
15:40:56 <atriq> aristid, it doesn't, I don't think
15:41:08 <Sonderblade> shachaf: yes
15:41:08 <aristid> atriq: i think it does.
15:41:09 <shachaf> That's 1 bit down, 32 to go.
15:41:20 <shachaf> Sonderblade: If you want a tree, use a tree type. :-)
15:41:27 <shachaf> data Tree a = Tree a [Tree a] -- or something
15:41:38 <aristid> shachaf: Data.Tree has that!
15:41:42 <aristid> a rose tree
15:41:43 <atriq> (eikke, I meant that in terms of "I'm significant enough to be "that guy"!?")
15:41:53 <atriq> aristid, how so?
15:42:07 <aristid> atriq: it's got a lot of parameters
15:42:12 <shachaf> Hmm, there are more humans than there are possible values of a 32-bit integer.
15:42:27 <eikke> atriq: it was a joke => "So you're the guy reblogging pictures of cats!" (as if that makes anyone special/unique). Sarcasm, never mind.
15:42:33 <aristid> shachaf: o-m-g
15:42:42 <atriq> eikke, ah, completely missed that. Gotcha
15:42:42 <jmcarthur> > 2^32
15:42:44 <lambdabot>   4294967296
15:42:49 <aristid> shachaf: and there are no negative-indexed humans!
15:42:55 <atriq> eikke, also, I don't often reblog pictures of cats
15:42:57 <mauke> maybe some humans are identical?
15:43:00 <shachaf> aristid: Real "32-bit integers" are unsigned.
15:43:04 <eikke> atriq: I wouldnt have a clue :)
15:43:07 <aristid> shachaf: tell that to GHC
15:43:31 <ski> > minBound :: Int32
15:43:33 <lambdabot>   -2147483648
15:43:50 <mauke> > maxBound :: Word32
15:43:52 <lambdabot>   4294967295
15:44:02 <Jafet> Unsigned integers, how insecure
15:44:09 <covi> SICP mentions 'delayed evaluation'. In my understanding, it's the same as lazy evaluation. Am I right?
15:44:18 <ski> covi : it's related
15:44:36 <mauke> > complement 0
15:44:37 <lambdabot>   -1
15:44:40 <atriq> aristid, I've got a bunch of similar-typed functions, which have different numbers of parameters and sometimes more restrictive constraints
15:44:40 <mauke> gg
15:44:45 <ski> covi : are you thinking about `delay' and `force' primitives ?
15:45:01 <Jafet> The well known sign extension attack
15:45:19 * hackagebot pontarius-xmpp 0.1.0.0 - An incomplete implementation of RFC 6120 (XMPP: Core)  http://hackage.haskell.org/package/pontarius-xmpp-0.1.0.0 (JonKristensen)
15:45:21 * ski . o O ( `compliment 0' )
15:45:22 <shachaf> > compliment 0
15:45:24 <covi> ski: yes
15:45:24 <lambdabot>   you're so wonderful, 0
15:45:38 <ski> shachaf :)
15:45:38 <mauke> > compliment 2
15:45:41 <lambdabot>   you're so wonderful, 2
15:45:42 <mauke> 2's compliment
15:45:47 <monochrom> interesting!
15:45:59 <monochrom> > compliment "mauke"
15:46:02 <lambdabot>   you're so wonderful, "mauke"
15:46:19 <ski> covi : `force' takes a value of type `Promise A' and yields a value of type `A'
15:46:45 <monochrom> too bad can't have "@data X = Mauke" with lambdabot. > compliment Mauke  would be cooler
15:46:51 <ski> covi : `delay' takes an expression of type `A' and yields a value of type `Promise A'
15:47:01 <tallpeak> complement "mauke"
15:47:08 <covi> ski: yep
15:47:10 <shachaf> monochrom: Why would you capitalize mauke?
15:47:12 <shachaf> > compliment mauke
15:47:15 <lambdabot>   you're so wonderful, mauke
15:47:26 <aristid> atriq: this is how i solved a similar problem: http://hackage.haskell.org/packages/archive/aws/0.7.5/doc/html/Aws-Sqs-Commands-Message.html
15:47:33 <ski> covi : or, if you don't use a new syntactical form, then `delay' can be a function that takes a value (a function) of type `() -> A' and yields a value of type `Promise A'
15:47:41 <monochrom> hmm, how did you do that?!
15:47:41 <tallpeak> I thought it would invert the bits of the bytes in the string
15:47:47 <aristid> atriq: i have a Request and Response type for every action, and link them through a Transaction type class :)
15:47:51 <atriq> aristid, okay, I'll give that a look
15:47:58 <shachaf> tallpeak: Strings aren't made of bits.
15:48:00 <ski> covi : lazy evaluation is sortof as if every value was wrapped in a promise
15:48:02 <monochrom> > compliment thatwhichhithertotherefore
15:48:04 <lambdabot>  Terminated
15:48:05 <shachaf> Or of bytes.
15:48:12 <Jafet> > compliment doc
15:48:15 <lambdabot>   you're so wonderful, Doc
15:48:19 <shachaf> > compliment thatwhichhithertotherefore
15:48:21 <lambdabot>   Not in scope: `thatwhichhithertotherefore'
15:48:34 <aristid> :t compliment
15:48:35 <lambdabot> Show a => a -> Doc
15:48:41 <covi> ski: oh i see! very clear. thx
15:48:44 <monochrom> I guess I see now
15:48:45 <mauke> > compliment (var "monochrom")
15:48:47 <lambdabot>   you're so wonderful, monochrom
15:49:00 <ski> covi : there's also a `lazy' primitive, which given an expression of type `Promise A' gives an expression of type `Promise A', see SRFI 45 <http://srfi.schemers.org/srfi-45/srfi-45.html>
15:49:37 <shachaf> jfischoff: Hmm, I should read that paper.
15:50:03 <monochrom> Haskell makes the IO monad explicit, and the Promise monad implicit. SICP does the opposite.
15:50:14 <covi> ski: very cool
15:50:21 * hackagebot chu2 2012.11.18 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.18 (JinjingWang)
15:50:23 * hackagebot chu2 2012.11.18.1 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.18.1 (JinjingWang)
15:51:18 <Jafet> Scheme: "what is this monad thing, can I implement it with call/cc?"
15:51:34 <mauke> (spoilers: yes)
15:51:48 <ski> covi : btw, note that in SML `Promise' is called `susp' (for suspension), and in OCaml, it's `Lazy.t'
15:52:36 <mauke> (susp x) checks whether x is The Sussman
15:53:01 <shachaf> @remember Oleg We show how to program with the law of excluded middle. We specifically avoid call/cc, which is overrated.
15:53:02 <lambdabot> Nice!
15:53:07 <gbacon> !score lsu
15:53:47 <ski> covi : also see "How to add laziness to a strict language, without even being odd" by Philip Wadler,Walid Taha,David MacQueen in 1998-09 at <http://homepages.inf.ed.ac.uk/wadler/topics/language-design.html#lazyinstrict>
15:55:18 <shachaf> Hmm, you can't add laziness to a pure strict language without something like mutation, can you?
15:55:22 <covi> ski: very helpful, thank you!
15:56:07 <mauke> okasaki had something about that
15:57:27 <ski> Okasaki's notation is mentioned in that paper
15:58:35 <shachaf> notation, noproblems
15:58:41 <mauke> getting good amortized bounds in a persistent setting by clever use of laziness
15:58:59 <ski> yes
15:59:21 <zhulikas> I believe some form of tail-recursion can be used to make some laziness
15:59:34 <zhulikas> but that's just lazy stream for example
15:59:48 * zhulikas does lazy evaluation using anonymous objects in Java :(
16:00:12 * shachaf suspects that what zhulikas means by "lazy evaluation" isn't what other people here mean by it?
16:00:21 <zhulikas> oh, ok
16:00:26 * zhulikas hides in shame
16:00:40 <Sonderblade> shachaf: you can concatenate lists of lists but not trees, so they are different
16:01:10 <shachaf> Sonderblade: Hmm? Why can't you concatenate trees?
16:01:43 <shachaf> A tree is, after all, just a list of trees.
16:01:44 <zhulikas> shachaf, I believe when you pass something to a function and you don't want an immediate evaluation, at least that can be done in a way I described above. But I guess I just see it as a number of different constructs used to simulate laziness
16:02:14 <shachaf> zhulikas: In particular the discussion was (I think?) about the difference between laziness and other forms of non-strictness.
16:02:34 <zhulikas> ohhhhh
16:02:41 <mSSM> What's the right syntax to have lambdabot desugar a if then else expression in a do block?
16:02:41 <zhulikas> and I just popped in after a while :)
16:02:41 <Jafet> "You, too, could have invented Miranda(TM) in Java!"
16:02:46 <zhulikas> ok, sorry
16:03:18 <Jafet> if _ then _ else _ is not sugar
16:03:23 <byorgey> mSSM: if-then-else expressions are not sugar for anything
16:03:28 <Jafet> At least, we don't find it very sweet
16:03:52 <shachaf> byorgey: They're not?
16:04:12 <byorgey> oh, uh, of course they are
16:04:17 <Jafet> It's not syntactic sugar
16:04:22 <shachaf> Would you call "do" sugar?
16:04:25 <byorgey> they're sugar for a case
16:04:27 <Jafet> (Synthetic sugar?)
16:04:33 <mauke> semantic sugar
16:04:36 <byorgey> but I don't see what being inside a do-block has to do with anything.
16:04:36 <mSSM> I mean: I have an expression like do x <- foo ; if x <0 ; then do _stuff_ ; else do _stuff_ ; some_stuff_outside the if-then-else
16:04:52 <mauke> mSSM: no semicolons inside
16:05:01 <shachaf> Why do you want lambdabot to desugar ifs?
16:05:09 <shachaf> ¬´if e1 then e2 else e3 = case e1 of { True -> e2 ; False -> e3 }¬ª
16:05:28 <byorgey> but  if e1 ; then e2 ; else e3  is a syntax error
16:05:28 <mauke> @undo do x <- foo; if x < 0 then do _stuff_ else do _stuff_; some_stuff_outside
16:05:29 <lambdabot> foo >>= \ x -> if x < 0 then _stuff_ else _stuff_ >> some_stuff_outside
16:05:39 <mSSM> byorgey: thank you
16:05:58 <mSSM> I didn't know that you should write all the in one line
16:06:17 <atriq> aristid, I don't think that solution is the one for me
16:06:22 <byorgey> mSSM: you can write them on separate lines but the then... and else... must be indented past the 'if'
16:06:35 <byorgey> so that they still form one logical line
16:06:37 <mSSM> byorgey: absolutely; the thing is with lambdabot....
16:06:39 <aristid> atriq: what specifically makes you think that?
16:06:43 <byorgey> mSSM: ahhh
16:06:54 <byorgey> right, I get it now
16:07:06 <mSSM> byorgey: and also, what if in the `then' part the _stuff_ is more than one line?
16:07:28 <kuznero> Hi All
16:07:31 <mSSM> byorgey: I can't write if e1 then e2_a ; e2_b ; e2_c
16:07:32 <atriq> aristid, I don't really understand it, and what I have now works
16:08:10 <aristid> atriq: oh, i presume you have never used functional dependencies?
16:08:15 <monochrom> you need a "do". if e1 then do { e2_a; e2_b; e2_c }
16:08:23 <hpaste> Kuznero pasted ‚ÄúRemoving boilerplate code‚Äù at http://hpaste.org/77865
16:08:28 <atriq> aristid, no, I have
16:08:33 <mSSM> monochrom: oh, great; thank you
16:08:52 <kuznero> Hi gents, who could help me with http://hpaste.org/77865 ?
16:09:05 <atriq> aristid, I just don't see what you're trying to do with the Transaction class
16:09:11 <kuznero> looking for a way to get rid off this boilerplate code
16:09:27 <shachaf> kuznero: hpaste has several good suggestions for you.
16:09:34 <aristid> atriq: i'm just using it to link request and response type via functional dependencies, and it requires all the other type classes for doing the actual work
16:09:38 <byorgey> kuznero: you want 'guard'
16:09:43 <kuznero> shachaf: let me check :)
16:09:50 <kuznero> I tried guard already
16:09:54 <byorgey> err, sorry, I spoke too quickly
16:09:57 <byorgey> I mean 'when'
16:09:57 <kuznero> end up with mzero and IO
16:10:05 <kuznero> I see
16:10:09 <kuznero> Let me try that, thanks!
16:10:28 <hpaste> ‚Äúnot me‚Äù annotated ‚ÄúRemoving boilerplate code‚Äù with ‚ÄúRemoving boilerplate code (annotation)‚Äù at http://hpaste.org/77865#a77866
16:10:50 <shachaf> kuznero: ‚òù
16:11:02 <byorgey> you can even not indent the stuff after   when condition $ do
16:11:10 <ski> covi : if you can get access to the book "Purely Functional Data Structures" by Chris Okasaki in 1998, it explains useful ways to use laziness to get good algorithms (it also talks about non-lazy algorithms, but still using immutable data structures)
16:11:14 <shachaf> Oh, fancy.
16:11:33 <kuznero> nice
16:11:38 <kuznero> looks good, thanks!
16:11:43 <shachaf> hpaste turns all (/= "versions" tables) into ("vestions" `notElem` tables)
16:11:46 <shachaf> hlint++
16:12:22 <Jafet> @src elem
16:12:23 <ski> covi : there's also a PhD thesis "Purely Functional Data Structures" by Chris Okasaki in 1996-09 at <http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf>, but it doesn't contain as much as the book
16:12:23 <lambdabot> elem x    =  any (== x)
16:12:41 <mapf> hlint is pretty smart, ya
16:16:28 <byorgey> actually, it's ndm who's pretty smart
16:16:49 <mapf> who is it?
16:17:17 <ski> @where ndm
16:17:17 <lambdabot> http://www.cs.york.ac.uk/~ndm/
16:17:39 <shachaf> byorgey: Eh. ndm may be pretty smart, but that doesn't follow from hlint being pretty smart. :-)
16:18:22 <shachaf> We have different standards for programs like hlint. In this case a smart program is one that has a lot of good heuristics.
16:19:49 <Jafet> Like Deep Blue's
16:19:56 <covi> ski: cool!
16:20:06 <covi> ski: r u a phd student working on pl?
16:21:58 <byorgey> shachaf: true =)
16:23:16 <Herp> Hey
16:23:31 <Herp> can Haskell be used with win32 and network programmin?
16:23:54 <mapf> yes, since Haskell is turing complete
16:24:08 <YayMe> *turing awesome
16:24:09 <YayMe> ftfy
16:24:21 <aristid> mapf: as if one had anything to do with the other.
16:24:37 <Herp> but doesn't the functional bit not work with network programming?
16:24:39 <aristid> Herp: yes, but win32 programming is not its strength
16:24:41 <ski> covi : no
16:24:56 <aristid> Herp: functional programming and network programming mixes _just fine_
16:25:02 <YayMe> aristid: well if a language is turing complete... then the answer will be yes...
16:25:06 <aristid> YayMe: no
16:25:13 <ski> @wn ftfy
16:25:14 <lambdabot> No match for "ftfy".
16:25:20 <aristid> brainfuck is turing complete, yet you can't do win32 (directly) with it
16:25:20 <Herp> but that fact its not procedural...
16:25:36 <aristid> ski: "fixed that for you"
16:25:41 <YayMe> Herp: What on earth would make you think that? Have you heard of Erlang?
16:25:42 <ski> ah, ty
16:26:01 <aristid> ski: "thank you"
16:26:22 <atriq> Herp, a) Haskell can be sort of procedural at  times and b) it doesn't need to be to do network programming
16:26:29 * ski passes aristid through a type checker
16:26:38 <aristid> ski: True
16:27:05 <aristid> ski: man, booleans are just evil!
16:27:16 <mapf> heh
16:27:35 <Canar> I'm trying to do something that I think should be very straightforward but I can't seem to get the right idiom.
16:27:46 <Herp> Well I use to know C and C++ but forgot most of it as I haven't programmed in a long time
16:28:03 <YayMe> Iduno, i think George Boole was a sharp fellow
16:28:04 <Herp> I want to relearn programming but I am not sure if I want to repeat what I have already done
16:28:08 <aristid> Herp: rest assured, network programming is possible in haskell.
16:28:12 <Canar> Let's say I have a list, [1, 2, 4, 3]. I want to calculate the partial sum of every position in the list, like [1, 1+2, 1+2+4, 1+2+4+3]
16:28:22 <Canar> What would such a function look like? It's kind of stateful.
16:28:26 <mapf> Canar: scanl
16:28:28 <shachaf> > scanl (+) 1 [1,2,4,3]
16:28:28 <Herp> What about win32 callbacks?
16:28:30 <lambdabot>   [1,2,4,8,11]
16:28:34 <shachaf> Um
16:28:35 <shachaf> > scanl (+) 0 [1,2,4,3]
16:28:37 <lambdabot>   [0,1,3,7,10]
16:28:41 <aristid> Herp: possible, but probably not a lot of fun.
16:28:48 <parcs`> > scanl1 (+) [1,2,4,3]
16:28:50 <lambdabot>   [1,3,7,10]
16:28:59 <Canar> all right
16:29:06 <shachaf> Don't use scanl1 :-(
16:29:11 <mapf> heh
16:29:26 <YayMe> Herp: Being functional has no effect on whether something can be used for network programming or not, being lazy can make proper sequencing tricky but that's why Haskell has monads to make it easy even with laziness
16:29:30 <shachaf> rwbarton: Did you see my fancy metaprogramming ballot stuffing?
16:29:34 <DMcGill> well it's not like head (scanl .. is any safer
16:29:35 <shachaf> @@ @run length @show @@ (@read @run unwords . replicate 28 $ "(@vote best-spoken-language Polish)")
16:29:35 <rwbarton> no
16:29:37 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
16:29:42 <shachaf> @@ @run length @show @@ (@read @run unwords . replicate 25 $ "(@vote best-spoken-language Polish)")
16:29:44 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
16:29:48 <shachaf> Hmm.
16:29:50 <shachaf> @@ @run length @show @@ (@read @run unwords . replicate 20 $ "(@vote best-spoken-language Polish)")
16:29:53 <lambdabot> Plugin `compose' failed with: Prelude.read: no parse
16:29:56 <shachaf> It worked in /msg
16:29:59 <aristid> shachaf: is polish your native language?
16:30:06 <Herp> hmmm
16:30:18 <byorgey> shachaf: what's wrong with scanl1?
16:30:18 <rwbarton> multiple @@s scares me
16:30:20 <shachaf> Anyway, doing things like that with lambdabot reminds me of you.
16:30:20 <Herp> Python is another option but I don't know.
16:30:23 <Herp> I just don
16:30:25 <Herp> 't know.
16:30:27 <byorgey> it's total
16:30:29 <rwbarton> thanks, I think?
16:30:32 <shachaf> byorgey: Oh, wait, scanl1 isn't evil.
16:30:41 <shachaf> Canar: Disregard that frown!
16:30:44 <byorgey> nope
16:30:49 <Canar> haha
16:30:50 <byorgey> the 1 was throwing you off
16:30:58 <byorgey> usually 1 is a suffix denoting evil
16:31:03 <aristid> shachaf: do you consider foldr1 evil?
16:31:15 <byorgey> foldr1 is evil because it is not in scope
16:31:15 <shachaf> > foldr1 (+) []
16:31:17 <lambdabot>   *Exception: Prelude.foldr1: empty list
16:31:29 <byorgey> oh.  huh, I didn't realize there was a foldr1.
16:31:32 <byorgey> anyway, it's evil.
16:31:37 <aristid> byorgey: hah
16:31:52 <shachaf> byorgey: What do you think of the Control.Lens.Zipper functions?
16:32:08 <shachaf> byorgey: What about Traversable1? That's like the opposite of evil.
16:32:14 <edwardk> shachaf: re the appending of '1' for evil?
16:32:16 <aristid> what happened to new-hackage by the way? wasn't there a beta? i was unable to follow that
16:32:19 <shachaf> edwardk: Yes.
16:32:31 <shachaf> Most of them aren't ‚ä•-evil
16:32:34 <byorgey> shachaf: well, I was joking of course =)
16:32:38 <aristid> TraversableMinusOne
16:32:47 <aristid> if 1 makes evil, -1 makes good
16:32:55 <ski> aristid : i was thinking of <http://www.lisperati.com/landoflisp/panel60.html> :)
16:32:58 <ski> (if you haven't seen this before, you can start at <http://www.lisperati.com/landoflisp/panel01.html> of "Functional Programming is Beautiful" by Conrad Barski in 2008-04-01)
16:33:07 <edwardk> aristid: there is Data.Semigroup.Traversable.Traversable1    if you want to use a semigroup safely ;)
16:33:22 <edwardk> that gives you a principled foldr1
16:33:37 <byorgey> aristid: there was a beta.  Not sure of the status.
16:34:02 <dobblego> edwardk++
16:34:15 <aristid> byorgey: the beta seems to be shut down, though. (if new-hackage.haskell.org is right)
16:34:38 <shachaf> edwardk: Presumably Data.List.NonEmpty gives you that too?
16:34:49 <edwardk> that is an instance ;)
16:34:57 <shachaf> Hah, OK.
16:34:58 <lambdabot> shachaf: You have 50 new messages. '/msg lambdabot @messages' to read them.
16:35:10 <shachaf> Uh oh.
16:35:11 <lambdabot> shachaf: You have 75 new messages. '/msg lambdabot @messages' to read them.
16:35:16 <edwardk> you're getting more lens bug reports than i thought
16:35:16 <Canar> Man. I haven't felt so over my head with computer science since my undergrad.
16:35:16 <DMcGill> uh
16:35:21 <shachaf> Um.
16:35:21 <Canar> #haskell is so good for me.
16:35:24 <lambdabot> shachaf: You have 125 new messages. '/msg lambdabot @messages' to read them.
16:35:25 <covi> ski: hah, ok
16:35:25 * hackagebot reactive-thread 0.3.2.1 - Reactive programming via imperative threads  http://hackage.haskell.org/package/reactive-thread-0.3.2.1 (MattGlazar)
16:35:36 <edwardk> shachaf: who was it who was spamming you earlier?
16:35:45 <shachaf> edwardk: This time it's just ion.
16:35:50 <lambdabot> shachaf: You have 25 new messages. '/msg lambdabot @messages' to read them.
16:35:53 <edwardk> ah
16:36:03 <ion> shachaf: hi
16:36:05 <rwbarton> i hope he is using @@ ... @tell .. @run
16:36:11 <shachaf> ion: You've mentioned.
16:36:30 <shachaf> rwbarton: Rate limiting would suggest so.
16:36:38 <parcs`> i wonder why ghc chose to not implement Integers through the FFI
16:36:50 <parcs`> i guess Integers predate the FFI
16:37:09 <shachaf> parcs`: I assume the FFI has too much overhead for something that simple?
16:37:22 <ion> Foreign F******* Interface
16:38:36 <JoeyA> ion: No, it's all right.  You can say that here.
16:38:50 <JoeyA> (Futurama reference)
16:39:27 <ion> hehe
16:39:28 <mauke> Ô¨É
16:40:16 <JoeyA> @google Ô¨É
16:40:18 <lambdabot> http://en.wikipedia.org/wiki/Fatal_familial_insomnia
16:40:18 <lambdabot> Title: Fatal familial insomnia - Wikipedia, the free encyclopedia
16:41:17 <rwbarton> @pl fmap (const x)
16:41:18 <lambdabot> fmap (const x)
16:41:29 <rwbarton> @@ @hoogle @type \x -> fmap (const x)
16:41:32 <lambdabot>  Data.Functor (<$) :: Functor f => a -> f b -> f a
16:41:32 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
16:41:32 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
16:45:05 <shachaf> @@ @pl @djinn @type (,)
16:45:07 <lambdabot>  f = (,)
16:48:21 <aristid> ski: our southern wars are just!
16:48:27 <aristid> ski: this propaganda cannot be tolerated
16:48:52 <aristid> ski: (yes, took me a while to finish the comic)
16:51:55 <Ralith> shachaf: heh
16:55:29 <bxx> > (not . elem)
16:55:32 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
16:55:32 <lambdabot>              with actual type...
16:55:38 <bxx> why doesn't this work?
16:55:54 <Hermit> ski: what's the comic supposed to tell the reader? I've found opposite possible interpretations
16:55:56 <shachaf> (not . elem) === (\x -> not (elem x))
16:56:03 <shachaf> @ty elem
16:56:05 <lambdabot> Eq a => a -> [a] -> Bool
16:56:09 <shachaf> elem x :: [a] -> Bool
16:56:10 <mauke> bxx: what is 'not (elem x)' supposed to be?
16:56:52 <bxx> i figured it would return a function that accepts whatever elem accepts, and then pass the return Bool from elem to not
16:57:02 <bxx> returned
16:57:19 <mauke> no, that would be \x -> not . elem x
16:58:15 <bxx> yeah  ithink I got it now
16:58:21 <bxx> > (not . elem 'o') "foo"
16:58:23 <lambdabot>   False
16:58:37 <mauke> > notElem 'o' "foo"
16:58:39 <lambdabot>   False
16:58:44 <bxx> I know :)
16:58:54 <mauke> > ((not .) . elem) 'o' "foo"
16:58:56 <lambdabot>   False
16:59:06 <ski> aristid : it's great ! :)
16:59:30 <bxx> ok why did last one work?
16:59:31 <ski> Hermit : i don't know, perhaps the author knows ?
16:59:32 <Jafet> I don't like no double negatives.
16:59:55 <shachaf> Jafet prefers a bigger mantissa.
17:00:01 <mauke> ((not .) . elem) 'o'
17:00:08 <mauke> (not .) (elem 'o')
17:00:17 <mauke> not . (elem 'o')
17:00:19 <Jafet> Mantissa? I 'ardly know 'a!
17:00:24 <mauke> (not . (elem 'o')) "foo"
17:00:32 <mauke> not (elem 'o' "foo")
17:04:50 <shachaf> mauke: Speaking of which, what happened to mauke.hopto.org?
17:04:57 <shachaf> I wanted to link to that array article.
17:05:24 <mauke> that was just my pc (which died)
17:05:57 <shachaf> And the hard disk died, and there were no backups?
17:06:26 <mauke> it's probably bad ram
17:06:48 <shachaf> You should replace it with good RAM!
17:06:53 <mauke> I managed to copy my most important stuff off first
17:07:15 <mauke> I've got a copy of array-pointer.html right here
17:07:39 <aristid> shachaf: and the only good RAM is _lots_ of RAM!
17:11:43 <NemesisD> anyone know how to update the auth time for sudo. i'm running arch on my raspberry pi and it forces me to enter my credentials every time i use sudo
17:12:03 <Jafet> mkswap /dev/ram1
17:12:34 <geekosaur> By running sudo with the -v option, a user can update the time stamp without running a command.
17:12:44 <geekosaur> (hint:  "man sudo")
17:13:00 <geekosaur> also see "man sudoers" as it's possible to disable the timestamp thing entirely
17:13:43 <latro`a> I think you can also do that in visudo
17:13:53 <Jafet> echo sudo su >> .bash_login
17:14:51 <parcs`> NemesisD: perhaps googling "sudo tty_tickets" will be of help
17:16:05 <NemesisD> ok. ill check it out. thanks
17:36:28 <ion> http://hackage.haskell.org/package/language-python seems to have bitrotted.
17:37:20 <monochrom> NemesisD: "sudo -v" renews the time
17:38:26 <monochrom> also worth knowing: "sudo -k" and "sudo -K" expires you immediately
17:40:40 <mauke> shachaf: http://blogs.perl.org/users/mauke/2012/11/c-programming-what-is-the-difference-between-an-array-and-a-pointer.html
17:40:51 <shachaf> parcs`: ‚òù
17:41:14 <monochrom> wait, what, now we're on to random numbers at the type level?! http://thread.gmane.org/gmane.comp.lang.haskell.glasgow.user/22764
17:41:47 <mauke> @quote .rsa
17:41:47 <lambdabot> luite says: I'm really interested in both practice and theory of optics and wave mechanics, so I'll be coming over from Europe for Edward's lecture on lenses and transversals.
17:42:06 <monochrom> haha
17:42:31 <monochrom> oh, great inspiration. lenses at the type level!
17:42:47 <shachaf> Does GHC support existential kinds?
17:42:58 <monochrom> haha
17:43:04 <monochrom> (I believe not)
17:44:26 <shachaf> mauke: Do you know about void blah(int foo[static 42])?
17:44:27 <parcs`> yay
17:44:38 <mauke> yes
17:44:45 <mauke> the 4th meaning of 'static' :-)
17:44:47 <monochrom> wait, "static 42" is allowed there?
17:45:11 <monochrom> I guess C has been updated since I learned C
17:45:22 <mauke> 1. (file scope): makes symbols have internal linkage
17:45:34 <mauke> 2. (block scope): gives objects static storage
17:45:53 <mauke> 3. (C++ only): associates class members with the class itself (rather than objects of this class)
17:46:23 <mauke> 4. (C99 only): in function parameters: tells the compiler it may assume the pointer points to at least the given number of elements
17:46:34 <monochrom> nice
17:46:50 <mauke> that is, if you write void blah(int foo[42]), foo is an int * and the 42 is completely ignored
17:47:10 <mauke> if you write [static 42], foo is still an int *, but the compiler may prefetch foo[0] ... foo[41] if it wants to
17:47:15 <aristid> mauke: static has only 4 separate and unrelated meanings? didn't you miss one?
17:47:24 <mauke> inorite
17:47:35 <Sonderblade> what is a simple way to take a Data.Tree and return a new Tree String of it?
17:47:37 <mauke> I haven't checked the latest versions of C and C++
17:47:48 <mauke> this is still based on C99/C++98 :-)
17:48:09 <monochrom> I know about int foo[42] being just int *foo
17:48:23 <eikke> monochrom: 42[foo] you mean? :P
17:48:31 <mauke> eikke: syntax error
17:48:41 <aristid> no, 42[foo] is valid C
17:48:44 <monochrom> eikke, see context
17:48:46 <mauke> aristid: not in declarations
17:48:50 <eikke> monochrom: I was kidding
17:48:53 <aristid> mauke: ah, sure, not there
17:48:58 <monochrom> ok! hahaha!
17:49:15 <Sonderblade> @hoogle Tree a -> Tree String
17:49:15 <shachaf> eikke: Be at most one of [pedantic, wrong]
17:49:15 <lambdabot> Data.Tree flatten :: Tree a -> [a]
17:49:16 <lambdabot> Data.Graph.Inductive.Basic postorder :: Tree a -> [a]
17:49:16 <lambdabot> Data.Graph.Inductive.Basic preorder :: Tree a -> [a]
17:49:32 <monochrom> however, in another context, 42[foo] is perfectly fine
17:49:36 <eikke> shachaf: I'll be undefined
17:49:53 <mauke> so what you're saying is you're a bottom
17:50:14 <eikke> mauke: at this time of the night I don't really care what I am anymore
17:50:30 <monochrom> I am a computer
17:50:55 <shachaf> monochrom: You and Raymond Smullyan!
17:51:18 <aristid> monochrom: i suspected that all along
17:51:36 <mauke> http://dannybrito.tumblr.com/post/1287281108/
17:51:55 <monochrom> is dannybrito related to danny burrito?
17:52:10 <heatsink> Is someone here familiar with shake?
17:54:11 <neutrino> heatsink: no, what is it?
17:55:05 <heatsink> It's a library for dependency-based building, like the 'make' interpreter
17:55:16 <Ralith> Sonderblade: fmap show
17:55:33 <eikke> When writing Python, I tend to stop coding when it's running late since I'd introduce too many bugs when tired. Haskell ruined my sleeping time :-(
17:55:38 <mm2> hi, any hints on using virthualenv with ghc 7.6.1 getting the "GHC_PACKAGE_PATH is incompatible with Cabal. Use the flag --package-db to..."
17:55:55 <Sonderblade> Ralith: thanks
17:56:17 <geekosaur> mm2, virthualenv is out of date, the modern package is hsenv and may work better with 7.6
17:57:52 <mm2> geekosaur: woah thanks for the tip!
17:59:35 <monochrom> is hsenv on hackage? can't find it
18:00:40 <rwbarton> "*** Exception (reporting due to +RTS -xc): (THUNK_1_0), stack trace:   Main.main" does this mean anything? my program kept running...
18:00:42 <monochrom> I guess it's on someone's github
18:01:15 <geekosaur> https://github.com/Paczesiowa/hsenv looks like
18:01:27 <monochrom> yeah
18:01:35 <geekosaur> virthualenv was not being updated.  I am not sure hsenv knows 7.6 looking at the top page
18:02:49 <geekosaur> mmm, latest commit doesn't look hopeful tbh
18:08:32 <mm2> same thing i guess :/
18:09:22 <antoine__> hello
18:10:24 <antoine__> what are the main usages of Haskell ? Can it be on any help for game or web development?
18:10:48 <heatsink> @faq
18:10:48 <lambdabot> The answer is: Yes! Haskell can do that.
18:11:14 <wlangstroth> also useful for making lambdabots
18:11:18 <YayMe> haha
18:11:18 <rwbarton> "Alloc rate    18,446,744,073,497,567,167 bytes per MUT second"
18:11:28 <heatsink> Is there something you want to learn about Haskell, antoine__?
18:11:37 <rwbarton> "Productivity -33.0% of total user, -15.0% of total elapsed"
18:11:59 <YayMe> antoine__: The main use of haskell: Everything. (Actually nothing, but that's why they were allowed to create something that could do everything)
18:13:00 <antoine__> I often find that some languages are better than other for specific taks. But I guess this does not apply to Haskell
18:13:14 <antoine__> I will do my homework by reading the FAQ
18:13:44 <Jafet> @quote abstract.research
18:13:45 <lambdabot> Jafet says: Haskell is an abstract research language used only in academia, education, banking, stock trading, circuit design, embedded systems, cryptography, operating systems research, bioinformatic
18:13:45 <lambdabot> s, phone apps, and web services.
18:14:14 <Canar> haha
18:14:21 <wlangstroth> true - it's so limited that way
18:14:25 <Canar> used only in ALL THE THINGS
18:14:33 <byorgey> rwbarton: wow, that's uh... 15 exabytes per second?
18:15:35 <pranavrc> wait, so you're saying i can add two numbers in haskell?
18:15:43 <jmcarthur> pranavrc: no
18:15:50 <jmcarthur> haskell doesn't actually have numbers, see
18:15:57 <wlangstroth> :)
18:16:08 <pranavrc> ah, exposed!
18:16:27 <jmcarthur> rwbarton: quite impressive
18:16:45 <pranavrc> on another note
18:16:49 <pranavrc> i'm starting to learn it
18:16:50 <pranavrc> and
18:16:56 <pranavrc> any recommended/liked oss projects?
18:17:28 <jmcarthur> ghc, xmonad, pandoc, darcs. not recommended necessarily for awesome source code (because i haven't never really dug into them), but because they are just plain awesome projects
18:17:37 <jmcarthur> *have never
18:17:43 <wlangstroth> pranavrc: what's your background? (to help figure out what code will make the most sense)
18:17:48 <deus_rex> pandoc is written in haskell?
18:17:51 <jmcarthur> yes
18:17:56 <spaceships> let 0 = \x -> x
18:18:06 <pranavrc> jmcarthur, alright
18:18:12 <pranavrc> 'xmonad for awesome source code'
18:18:17 <pranavrc> sounds very...controversial
18:18:18 <pranavrc> :P
18:18:27 <jmcarthur> no idea
18:18:37 <Jafet> awesome for xmonad source code
18:18:51 <aristid> xmonad is the awesomest xmonad source code?
18:18:53 <byorgey> xmonad's source code is fairly nice, actually
18:19:01 <wlangstroth> true
18:19:04 <pranavrc> wlangstroth, python, javascript, c, if you're asking about languages
18:19:16 <pranavrc> domains - i dont really mind, anything that's interesting
18:19:31 <aristid> pranavrc: just build a wayland backend for xmonad ;)
18:19:43 <pranavrc> ok, i'll parse that statement and get back to you next week
18:20:08 <pranavrc> i think i'll check out xmonad
18:20:10 <pranavrc> i use it :)
18:20:14 <pranavrc> urxvt on xmonad is awesome
18:20:27 <wlangstroth> pranavrc: snap is a web framework that has good code organization - should at least look somewhat familiar
18:20:38 <antoine__> how good is http://learnyouahaskell.com/ ?
18:20:54 <Jafet> <------------->
18:20:59 <pranavrc> wlangstroth, righto, will check it out
18:21:03 <pranavrc> anything i can do for the haskell community?
18:21:11 <pranavrc> (assuming i'm an interested newb)
18:21:16 <Jafet> ("pretty good")
18:21:20 <ion> ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
18:21:54 <wlangstroth> pranavrc: have fun learning? (I can't speak for the haskell community, but that strikes me as a good goal)
18:21:56 <aristid> pranavrc: yes! you can make sure to always file bugs when you encounter them :)
18:22:31 <pranavrc> alright, that, and i'll hang around and bug you all
18:23:03 <byorgey> pranavrc: yes, there are lots of things
18:23:19 <byorgey> pranavrc: just keep poking around, find some projects you're interested in, and find ways to contribute
18:23:21 <pranavrc> wlangstroth, i think i will, just a little bit into it and I'm loving it
18:23:47 <byorgey> antoine__: LYAH is pretty good
18:24:13 <pranavrc> byorgey, righto
18:24:21 <deus_rex> antoine__: learn you a haskell is good, and very informal. i'm following it up right now with Real World Haskell and found they complement each other very nicely
18:24:50 <wlangstroth> pranavrc: byorgey's typeclassopedia was the source of most of my Haskell "aha" moments, if that helps
18:25:38 <byorgey> I dislike some of LYAH's ordering -- for example, it leaves algebraic data types and pttern matching until very late, and I personally think those ought to be one of the first things you learn
18:25:48 <byorgey> and this is backed up by experience teaching it
18:25:48 <pranavrc> http://www.haskell.org/haskellwiki/Typeclassopedia
18:25:49 <pranavrc> that one?
18:25:51 <pranavrc> sweet :O
18:26:03 <byorgey> but despite that LYAH is quite good
18:26:09 <byorgey> pranavrc: yep, that one
18:26:18 <wlangstroth> byorgey: agreed on pattern matching, for sure
18:26:19 <pranavrc> bookmarkied
18:26:39 <deus_rex> pattern matching is touched on in the first couple chapters i thought
18:27:00 <antoine__> byorgey: deus_rex : thanks
18:27:12 <Herp> I still don't know if Haskell is worth learning
18:27:25 <byorgey> @faq is Haskell worth learning?
18:27:26 <lambdabot> The answer is: Yes! Haskell can do that.
18:27:38 <byorgey> deus_rex: perhaps so, but it's not really emphasized at all
18:27:48 <wlangstroth> Herp: I still don't know if football is worth learning
18:28:00 <Herp> I don't know football
18:28:02 <parcs`> i'm not sure if i want to learn the piano
18:28:13 <byorgey> for example it introduces a whole bunch of functions on lists (including -- ugh -- head and tail!) without ever telling you about lists' inductive structure
18:28:21 <pranavrc> so
18:28:25 <pranavrc> was python inspired by haskell or something
18:28:28 <Herp> The point is I don't know if Haskell will be too restrictive or not.
18:28:30 <pranavrc> i see a lot of analogies
18:28:38 <Herp> Or if I should just relearn C or Python
18:28:39 <parcs`> list comprehensions were, at least
18:28:43 <pranavrc> except for the paradigm shift of course
18:28:48 <pranavrc> parcs`, exactly
18:28:57 <byorgey> these days it seems like python is anti-inspired by Haskell
18:29:11 <parcs`> python and haskell don't share any other similarities though
18:29:12 <pranavrc> Herp, they're different beasts, python and haskell, so learn both
18:29:13 <byorgey> judging by the antipathy to anything functional
18:29:17 <parcs`> guido is actively anti-functional
18:29:19 <wlangstroth> there's a teensy bit of hate from Guido for functional programming
18:29:29 <pranavrc> oic
18:29:42 <Herp> I will only learn 1 and it's been 2 years since I programmed last
18:29:44 <pranavrc> benevolent dictators sure like stomping something prevalent, dontthey
18:29:48 <pranavrc> linus hates c++
18:30:00 <Herp> so I am trying to decide what to do.
18:30:06 <wlangstroth> Herp: learn C - it will lead you to enlightenment
18:30:11 <wlangstroth> ‚Ä¶ eventually
18:30:14 <Herp> I use to know C and C++ but I don't know if I want to relearn it
18:30:23 <Herp> I kind of want to learn something new.
18:30:32 <Herp> But it must not be too restricted.
18:31:13 <wlangstroth> am I feeding the troll? What do you mean by "restricted", Herp?
18:32:30 <Herp> Must be able to program win32
18:33:33 <Herp> I want a language that has more or less the power and windows compatiability C++ and visual studio but is different enough so that I won't get bored and depressed from learning it.
18:33:51 <wlangstroth> uh, F#?
18:34:04 <parcs`> sounds like you want C#
18:34:33 <wlangstroth> parks`: he said *not* bored and depressed
18:34:44 <Jafet> Visual Basic.NET
18:34:52 <parcs`> pascal?
18:34:56 <wlangstroth> Jafet few again
18:34:59 <wlangstroth> *ftw
18:35:25 <Jafet> It has "dim", meaning even dim people can use it.
18:35:49 <bxx> under the hood is haskell function that takes two arguments implemented as a function that takes the first arg and returns a function that takes the second one?
18:36:09 <Ralith> bxx: that depends on the hood.
18:36:12 <byorgey> bxx: yes
18:36:23 <Jafet> Under da hood
18:36:27 <bxx> Ralith ghc
18:36:31 <aristid> bxx: not just under the hood
18:36:36 <Ralith> ghc has a lot of hoods!
18:36:44 <byorgey> bxx: really, there is no such thing as a function of two arguments in Haskell
18:36:49 <shachaf> bxx: GHC will probably implement it as something that passes the two arguments directly in registers or something like that.
18:36:55 <shachaf> Or it won't. It depends.
18:36:56 <byorgey> bxx: there are only single-argument functions which return functions.
18:37:00 <Ralith> but that probably isn't what you wanted to know
18:37:10 * shachaf suspects byorgey is working at a completely different level of abstraction.
18:37:13 <shachaf> Or bxx is.
18:37:14 <shachaf> Or I am!
18:37:33 <byorgey> yes, this question has a lot of potential answers depending on what bxx is really asking.
18:37:49 <bxx> I was curious how it's implemented. I know that conceptually all functions take one argument
18:37:59 <shachaf> bxx: Relevant paper:
18:38:03 <shachaf> @google how to make a fast curry
18:38:06 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/eval-apply/index.htm
18:38:06 <lambdabot> Title: How to make a fast curry
18:38:07 <luite> yeah if "under the hood" means how ghc does it, then it does implement it as two-argument function. if you apply it to one argument, it makes a partial application heap object that captures the first argument
18:38:36 <Jafet> Under the hood, functions are just stg_closures
18:38:56 <byorgey> ah, so shachaf was right, I was interpreting it at the wrong level
18:39:27 <xpika> is there a version of listToMaybe which doesnt take the only the first value in the list?
18:39:38 <Herp> Also I am a bit worried about using a ,NET language
18:39:44 * shachaf saw xpika as xplat for a moment, was confused.
18:39:59 <wlangstroth> Herp: ?
18:40:04 <shachaf> byorgey: Or perhaps bxx was being vague at first. :-) There's no "Haskell hood" that has multi-argument functions, but there are several "GHC hoods".
18:40:06 <luite> xpika: what should it do? Just [nonemptylist] | Maybe ?
18:40:32 <shachaf> Anyway, yes, xpika, your question doesn't seem to make sense. Provide examples.
18:40:50 <luite> oh i meant | Nothing of course
18:40:55 <xpika> sorry, maybeToList
18:40:56 <Herp> Well using an interpreted language verse machine code
18:41:05 <shachaf> xpika: Can you give an example?
18:41:05 <Herp> I shouldn't feel this way but, it feels kind of dirty.
18:41:17 <shachaf> myfunction blah = blaf; myfunction foo = bar
18:41:47 <shachaf> Herp: Are you worried about performance or what?
18:41:52 <wlangstroth> Herp: you object to bytecode?
18:42:00 <Herp> yes :s
18:42:07 <shachaf> Herp: Good news: Your intuition about performance is terribly flawed.
18:42:16 <shachaf> (Everyone's is, generally.)
18:42:16 <Herp> no I meant yes to wlangstroth
18:42:36 <Jafet> -fno-use-microcoded-instructions
18:42:48 <shachaf> Herp: Where did .NET come up, anyway?
18:42:48 <ion> @google how to make a vindaloo curry
18:42:50 <lambdabot> http://www.indianfoodforever.com/non-veg/chicken/chicken-vindaloo.html
18:42:50 <lambdabot> Title: Chicken Vindaloo Recipe - How To Make Chicken Vindaloo
18:43:11 <wlangstroth> shachaf is correct, so what other objections migth you have for bytecode?
18:43:20 <Jafet> @google how to make a fast vindaloo curry
18:43:28 <Herp> F#
18:43:36 <lambdabot> Plugin `search' failed with: thread killed
18:43:42 <shachaf> That seems kind of off-topic here.
18:43:57 <shachaf> Maybe not. I haven't seen any concrete question.
18:44:49 <wlangstroth> Herp: to answer your earlier question, and avoid further confusion, Haskell is my favourite language - your needs may vary
18:45:34 <xpika> reneg back to listToMaybe
18:45:40 <xpika> > listToMaybe [1,2,3]
18:45:42 <lambdabot>   Just 1
18:46:11 <xpika> >  something like  listToMaybe [1,2,3]  => [1,2,3] and listToMaybe [] => Nothing
18:46:13 <lambdabot>   <hint>:1:38: parse error on input `=>'
18:46:27 <shachaf> xpika: No, that doesn't make sense.
18:46:34 <shachaf> What would the type of that be?
18:46:34 <aristid> i don't like the name listToMaybe. it suggests that this is a conversion, when in fact it loses most of the list contents (if it's got more than 1 element, of course)
18:46:37 <xpika> listToMaybe [1,2,3]  => Just [1,2,3]
18:46:41 <shachaf> aristid: Yes, it's not a good name.
18:46:53 <shachaf> aristid: lens calls it headOf folded!
18:47:30 <ion> > let f xs = xs <$ guard ((not . null) xs) in [f [1,2,3], f []] :: [Maybe [Integer]]
18:47:32 <lambdabot>   [Just [1,2,3],Nothing]
18:47:32 <YayMe> Herp: .NET languages have excellent performance; JIT is a bit different than how you would think about a traditional interpretter, and the industry has proven out that .NET can perform fantastically.
18:48:18 <shachaf> This isn't a channel for .NET performance. :-)
18:48:23 <YayMe> Herp: But after saying that, why do you demand "win32" support from your language? Haskell is more than capable of doing whatever you want to do most likely
18:48:50 <deus_rex> mmm vindaloo
18:48:50 <Herp> Well I want to develop win32 apps, some with GUI
18:48:54 <YayMe> shachaf: I know, just felt inclined to correct what appeared like an incorrect assumption, but I don't know what he has against the idea of haskell
18:49:51 <YayMe> Herp: You can develop windows apps in Haskell, GUI's as well (look at leksah IDE for example, and I'm sure there are others) though in this day and age I tend to think HTML is all the gui you need, which haskell can serve up great as well.
19:12:57 <bxx> > partition odd [1..]
19:12:59 <lambdabot>   ([1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,...
19:13:30 <parcs`> > snd (partition odd [1..])
19:13:32 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
19:13:48 <parcs`> @let myquickcheck = id
19:13:51 <lambdabot>  Defined.
19:14:03 <bxx> is there an elegant way of fetching N elements in both fst and snd?
19:14:37 <parcs`> yes
19:14:43 <shachaf> > over both (take 5) $ partition odd [1..]
19:14:45 <lambdabot>   ([1,3,5,7,9],[2,4,6,8,10])
19:14:54 <bxx> nice
19:15:06 <shachaf> That requires the library Control.Lens, though.
19:16:53 <parcs`> > take 5 . concat . transpose . uncurry ((. pure) . (:)) $ partition odd [1..]
19:16:55 <lambdabot>   [1,2,3,4,5]
19:17:34 <parcs`> :t take 5 *** take 5
19:17:36 <lambdabot> ([a], [a1]) -> ([a], [a1])
19:17:54 <rwbarton> :t over
19:17:56 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
19:18:25 <dobblego> :t over both
19:18:27 <lambdabot> (a -> b) -> (a, a) -> (b, b)
19:18:41 <deus_rex> @help
19:18:42 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:19:30 <rwbarton> :t both
19:19:32 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
19:19:42 <shachaf> @ty over all
19:19:44 <lambdabot>     Couldn't match expected type `Mutator b0' with actual type `Bool'
19:19:44 <lambdabot>     Expected type: Setting s0 t0 a0 b0
19:19:44 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> Bool
19:19:45 <shachaf> :-(
19:20:00 <shachaf> The name "all" should be given to "traverse"
19:20:08 <shachaf> Who cares about boolean predicates anyway?
19:20:13 <rwbarton> :t over loaded
19:20:14 <lambdabot>     Not in scope: `loaded'
19:20:15 <lambdabot>     Perhaps you meant `folded' (imported from Control.Lens)
19:20:23 <shachaf> world.monsters.all.appendages.all.position.x += 1
19:20:56 <deus_rex> :t over it
19:20:57 <lambdabot>     Not in scope: `it'
19:20:57 <lambdabot>     Perhaps you meant one of these:
19:20:57 <lambdabot>       `id' (imported from Data.Function),
19:21:33 <Ralith> huh, Set isn't Traversable?
19:21:38 <shachaf> Ralith: Nope.
19:21:40 <shachaf> Not Functor, either.
19:21:47 <Ralith> why's that?
19:21:54 <shachaf> Try to write a Functor instance. :-)
19:22:07 <shachaf> instance Functor Set where fmap = S.map won't work
19:22:07 <aristid> shachaf: lambdabot got lens now?!
19:22:09 <dobblego> try to write: (a -> b) -> Set a -> Set b
19:22:23 <shachaf> aristid: All the cool kids got lens.
19:22:44 <aristid> shachaf: yeah i haven't really found a compelling use yet, but i might!
19:23:30 <shachaf> aristid: Traversals are pretty nifty, eh?
19:23:51 <shachaf> @ty partsOf
19:23:53 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
19:23:54 <YayMe> shachaf: I hear lens talked about every single time I'm here lately; is it going to be a really important part of haskell soon (or already is?), one of the libraries all haskellers are going to know?
19:24:00 <aristid> shachaf: to be honest, i don't really understand most of it
19:24:08 <aristid> shachaf: but i know the types are sexy
19:24:08 <shachaf> YayMe: Totally, man. It's the best.
19:24:18 <shachaf> YayMe: (I don't know. But it's pretty nifty.)
19:24:30 <shachaf> aristid: The key concept of Control.Lens is Traversal
19:24:40 <shachaf> When you figure that out most of the rest of it falls into place naturally.
19:24:50 <YayMe> Alright, I'll have to dig into it to at least know what it's used for and when to reach for it
19:24:51 <shachaf> I can explain it later if you like.
19:24:59 <dobblego> YayMe: some of us have been working with lenses for a while and Control.Lens supersedes all that work, so for some of us, we can relax now
19:25:17 <shachaf> @localtime aristid
19:25:18 <lambdabot> Local time for aristid is Sun Nov 18 04:24:59 2012
19:25:48 <YayMe> dobblego: Yeah all the talk I been hearing is mostly folks working on it, but interesting, is it going to be a part of the initial platform moving forward like the other Control libs?
19:26:57 <aristid> shachaf: yes, i'll go sleep after i'm done ranting about stupid channels in the other channel, k? ;)
19:28:55 <dobblego> YayMe: sometimes there is discussion about (some arbitrary, not necessarily haskell) language integration
19:48:39 <neutrino> hi
19:51:48 <simpson> I find myself needing to build message passing and actors. Should I just use TChans and forkIO to victory, or has somebody written something for it already?
19:55:35 <ion> @hackage distributed-process -- simpson
19:55:36 <lambdabot> http://hackage.haskell.org/package/distributed-process -- simpson
19:55:55 <ion> http://skillsmatter.com/podcast/home/cloud-haskell
19:56:51 <simpson> ion: Thanks.
19:57:11 <simpson> This is "overkill," but of course there's no such thing as overkill. :3
19:57:37 <ion> !hackage async
19:58:09 <ion> Probably not quite what you want, but it‚Äôs a lower-level concurrency-related package.
19:58:36 <simpson> Nifty.
19:58:52 <ion> @hackage async
19:58:52 <lambdabot> http://hackage.haskell.org/package/async
19:59:19 <simpson> I'm exploring options; I have decided to roll with conduits (network-conduit, cereal-conduit, etc.) and while they're reasonably nice once the types line up, network-conduit doesn't give me much control over running the conduits.
19:59:28 <simpson> It forkIOs for me and just hands me a pair of conduits.
20:00:54 <leoncamel> simpson: for message passing, did you try msgpack ?
20:01:20 <simpson> leoncamel: I'm thinking of Erlang-style message passing; I don't really care about the *format*, I care about the *semantics*.
20:01:30 <simpson> I want actors, really.
20:01:41 <ion> leoncamel: If he‚Äôs running everything under a single Haskell runtime he probably doesn‚Äôt want or need serializing.
20:01:59 <ion> distributed-process is probably as ‚ÄúErlang-style‚Äù as you can get.
20:04:36 <rwbarton> there's a simple-actors package though i only just glanced at it
20:11:11 <mm_freak> is greg weber here?
20:13:17 <ion> I wonder how and if simple-actors handles failure? I don‚Äôt see anything about linking or exceptions in the documentation.
20:14:05 <ion> That‚Äôs a rather important part of ‚ÄúErlang-style‚Äù.
20:20:30 * hackagebot chu2 2012.11.18.2 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.18.2 (JinjingWang)
20:20:32 * hackagebot DescriptiveKeys 0.0.4 - A library for specifying xmonad key bindings with functionality.  http://hackage.haskell.org/package/DescriptiveKeys-0.0.4 (TonyMorris)
20:32:51 <MichaelBurge> I can efficiently create a specific 1D Repa array. I'd like to generate a 2D array by iterating a function on the initial array. Is there a way to efficiently define an array in Repa whose elements depend on previous rows?
20:34:45 <neutrino> the semantic value of data is of no consequence to a repa array
20:34:58 <neutrino> whether the entries are related or not doesn't matter
20:35:19 <neutrino> however, to prevent duplication of data (1D array and 2D array), why not just start with a 2D array?
20:39:53 <Ralith> neutrino: did you read what he said?
20:40:25 <Ralith> he wants something like
20:40:35 <Ralith> > take 10 $ iterate (map f) [x,y,z]
20:40:37 <lambdabot>   [[x,y,z],[f x,f y,f z],[f (f x),f (f y),f (f z)],[f (f (f x)),f (f (f y)),f...
20:42:16 <clahey_> What's Repa?
20:42:33 <clahey_> There's definitely a way in haskell.
20:42:33 <copumpkin> a radish
20:42:40 <MichaelBurge> I didn't want the total number of iterations to necessarily be fixed when I start iterating, but I can always just return a new initial state and do it in chunks I suppose
20:42:52 <MichaelBurge> That might actually be better, since I could make an image for each chunk
20:45:27 <clahey_> Oh, it's a library.  Got it.
20:47:22 <mm_freak> sometimes, especially when dealing with categories/arrows it would be useful to have an infix version of (,)
20:47:28 <mm_freak> (a predefined one that is)
20:47:53 <jmcarthur> MichaelBurge: repa generally avoids things that are not easily parallelizable. what you want sounds tougher to parallelize than the typical repa operation
20:48:56 <neutrino> Ralith: no, i obviously replied without reading what he said, i just had a feeling someone might be asking about arrays
20:49:12 <Guest23262> Heya all. If I'm having trouble installing a package with cabal, is this the right place to ask?
20:49:21 <jmcarthur> mm_freak: i'm not sure i understand. you mean (,) without the requirement to have parens?
20:49:32 <mm_freak> jmcarthur: i mean this:
20:49:36 <mm_freak> > 3 `,` 4
20:49:38 <lambdabot>   <hint>:1:4: parse error on input `,'
20:49:47 <mm_freak> something infixl
20:49:51 <MichaelBurge> > let test = (,) in 5 `test` 6
20:49:53 <lambdabot>   (5,6)
20:50:05 <mm_freak> sure, but that's boilerplate you have to define yourself
20:50:15 <Ralith> neutrino: suspected as much
20:50:22 <Ralith> neutrino: I'd recommend reading the question next time.
20:50:30 <Ralith> :D
20:50:43 <jmcarthur> i just wish (,) didn't require the parens, so i could just leave them out unless necessary to disambiguate
20:50:44 <neutrino> Ralith: i'd recommend getting off that high horse once in a while
20:51:00 <jmcarthur> calm down both of you
20:51:10 <neutrino> i'm done
20:51:17 <Jafet> yaw: it isn't the wrong place to ask
20:51:23 * Ralith was joking :p
20:51:26 <neutrino> MichaelBurge: given that your data only ever references a single previous row, it doesn't make sense to make huge arrays other than memory alignment
20:51:26 * jmcarthur hugs neutrino and Ralith
20:51:30 <Ralith> hugs <3
20:51:30 <jmcarthur> now you two hug
20:51:39 * Ralith hugs neutrino!
20:51:47 <neutrino> get off me you hobo
20:51:48 <neutrino> :P
20:51:51 <jmcarthur> lol
20:51:57 <Ralith> so mean
20:52:00 <shachaf> Yay, hugging.
20:52:03 * shachaf hugs jmcarthur
20:52:05 <clahey_> mm_freak, Is (a, b) so much worse than a, b?
20:52:05 <neutrino> MichaelBurge: i suggest you do things in chunked manner and allocate new arrays as soon as you need them
20:52:22 <mm_freak> clahey_: no, but (((((a, b), c), d), e) is
20:52:22 <neutrino> MichaelBurge: you will be able to tune for chunk size if necessary
20:52:51 <neutrino> MichaelBurge: bear in mind a 1D array is just a 2D array with chunk size = 1 row.
20:52:56 <liyang> Can we have Hagda yet?
20:52:58 <clahey_> mm_freak, So you want a different character than , or you want comma to be redefined?
20:53:00 <otters> > a , b
20:53:01 <lambdabot>   <hint>:1:3: parse error on input `,'
20:53:09 <neutrino> liyang: no, but you can have Askell
20:53:41 <clahey_> mm_freak, Cause (a, b, c) would be ambiguous.
20:53:52 <mm_freak> clahey_: neither, just an infixl version of (,)‚Ä¶  might call it 'c' or 'comma'
20:54:12 <Jafet> Hagda? I ne'er even knew 'a.
20:54:13 <clahey_> mm_freak, Although I'm somewhat of the camp that (a,b,c) should be the same as ((a,b),c)
20:54:19 <MichaelBurge> neutrino: That does sound like the best way to go, especially since I could still parallelize computing the next row
20:54:19 <liyang> clahey_: in Agda, _,_ is the pair constructor. You write e.g. "(a, b), c" explicitly if you want it the other way 'round.
20:54:20 <MichaelBurge> thanks
20:54:23 <mm_freak> clahey_: ditto
20:54:34 <shachaf> liyang: No, you write (a , b) , c
20:54:34 <neutrino> MichaelBurge: yw
20:54:36 <yaw> Jafet: thanks. Basically, if I run "cabal install monad-state", even on a fresh environment, it fails with error " Could not find module `Data.Record.Label' ". Ubuntu 12.04, cabal 0.14.0
20:54:43 <shachaf> Because Agda likes its space.
20:54:46 <liyang> @slap shachaf
20:54:47 * lambdabot clobbers shachaf with an untyped language
20:54:52 <neutrino> MichaelBurge: it doesn't sound like allocation overhead will be your biggest issue.
20:54:57 <clahey_> Lamdbabot is back!
20:55:01 <yaw> Been trying for a while to find answers on Goog.
20:55:04 <clahey_> lambdabot, Welcome home!
20:55:14 <shachaf> Data.Record.Label?
20:55:25 <neutrino> MichaelBurge: later on, scanning overhead might be, but if you have to do multiple passes on the columns all at once, you might just want to copy data to a new array.
20:55:39 <Jafet> @hoogle Data.Record.Label
20:55:39 <lambdabot> package labeled-tree
20:55:40 <lambdabot> package dclabel
20:55:40 <lambdabot> package dclabel-eci11
20:56:11 <yaw> cool, should i try installing one of those manually?
20:57:02 <yaw> 2nd one fails to compile too, first one installs, but installing monad-state still complains of Data.Record.Label
20:57:15 <yaw> @hoogle Control.Monad.State
20:57:15 <lambdabot> Control.Monad.State module Control.Monad.State
20:57:16 <lambdabot> Control.Monad.Trans.State module Control.Monad.Trans.State
20:57:16 <lambdabot> Control.Monad.Trans.State.Lazy type State s = StateT s Identity
20:57:49 <p_nathan> Hi, I'm trying to understand some haskell syntax, anyone feel like taking a look (I think it'd be simple)
20:58:09 <shachaf> p_nathan: No one will look if you don't ask your question.
20:58:16 <shachaf> If you do, it's quite possible that someone will. :-)
20:58:25 <sw17ch> In cmdargs, is there a way to parse a 'list' on the command line?
20:58:27 <clahey_> p_nathan, Ask, don't ask to ask.
20:58:39 <p_nathan> Aight, then.  http://www.mew.org/~kazu/proj/red-black-tree/   in the insert function, there's a line...
20:58:53 <shachaf> You can ask, and ask to ask to ask, but not ask to ask.
20:58:55 <p_nathan>     ins x t@(Fork c l y r) = case compare x y of  --- what does the t@(...) syntax imply?
20:59:03 <shachaf> @hoogle @
20:59:04 <lambdabot> keyword
20:59:04 <lambdabot> Test.HUnit.Base (
20:59:04 <lambdabot> Test.HUnit.Base (
20:59:15 <jmcarthur> p_nathan: match that pattern and name the whole thing t
20:59:15 <Hermit> p_nathan: means the whole matched term between parens
20:59:21 <Jafet> I don't think hoogle indexes @.
20:59:24 <shachaf> It does.
20:59:30 <ski> p_nathan : the input is both named `t' and matched with `Fork c l y r'
20:59:30 <jmcarthur> p_nathan: so if you use t on the right side, it means the same as Fork c l y r
20:59:30 <shachaf> p_nathan: Type @ into http://haskell.org/hoogle/
20:59:42 <p_nathan> OK.
20:59:47 <p_nathan> Understood.
20:59:54 <jmcarthur> p_nathan: it's useful to save typing or to reduce allocations (because it wil reuse the existing value instead of reconstructing it)
21:00:30 <Jafet> yaw: you need dclabel
21:00:38 <p_nathan> thanks, all.
21:00:48 <jmcarthur> p_nathan: well, i should say for the sake of pedantry that the optimization applies to ghc but i guess doesn't necessarily apply to all haskell implementations
21:01:05 <p_nathan> the optimization doesn't matter to me, I just want to grasp the semantics
21:01:13 <Jafet> What haskell implementations
21:01:17 <yaw> Jafet: thanks. "cabal install dclabel" produces this error:
21:01:17 <yaw> Duplicate instance declarations:
21:01:17 <yaw>       instance [safe] Ord Clause -- Defined at DCLabel/Core.hs:101:17
21:01:17 <yaw>       instance [safe] Ord Clause -- Defined at DCLabel/Core.hs:103:10
21:01:42 <ski> mm_freak : .. `3 , 4' is valid OCaml
21:02:16 <yaw> The actual thing I'm trying to do is just to use the State monad
21:02:29 <mm_freak> ski: that doesn't really help me =)
21:02:37 <Hermit> yaw: let me guess... on DCLabel/Core.hs:101 there's a conditional compilation macro with some MIN_VERSION_*, right?
21:02:54 <yaw> I can import Control.Monad.State, but the data constructor doesn't seem to be in scope - and i'm assuming i need to install monad-state
21:03:04 <ski> mm_freak : yeah .. especially since `3 , 4 , 5' is distinct from both `(3 , 4) , 5' and `3 , (4 , 5)' :)
21:03:10 <Jafet> Wait, monad-state doesn't even depend on dclabel
21:03:14 <yaw> Hermit: I'm googling for the source now, but I don't know about those details (I'm new to all this)
21:03:35 <geekosaur> yaw, "state" instead of "State" these days
21:03:45 <Hermit> yaw: just unpack it from ~/.cabal/packages/hackage.haskell.org/dclabel/*/
21:04:04 <yaw> geekosaur: heh ok thanks :) all the examples on the internet have all used State! :(
21:04:05 <geekosaur> in mtl 1.x monads like State were their own things; in 2.x state is StateT Identity
21:04:12 <geekosaur> this is somewhat confusing, yes
21:04:22 <yaw> yeah, I was about to give up and just use StateT Identity as a hack
21:04:47 <Ralith> @hoogle s -> (a, s) -> State s a
21:04:48 <lambdabot> Data.Graph.Inductive.NodeMap delMapEdge :: (Ord a, DynGraph g) => NodeMap a -> (a, a) -> g a b -> g a b
21:04:48 <lambdabot> Data.Graph.Inductive.NodeMap delMapEdges :: (Ord a, DynGraph g) => NodeMap a -> [(a, a)] -> g a b -> g a b
21:04:48 <lambdabot> Data.Array.IArray listArray :: (IArray a e, Ix i) => (i, i) -> [e] -> a i e
21:04:57 <Ralith> well that didn't work
21:05:04 <ski> @hoogle (s -> (a, s)) -> State s a
21:05:04 <lambdabot> Control.Monad.Trans.State.Lazy state :: (s -> (a, s)) -> State s a
21:05:05 <lambdabot> Control.Monad.Trans.State.Strict state :: (s -> (a, s)) -> State s a
21:05:05 <lambdabot> Control.Monad.State.Lazy state :: (s -> (a, s)) -> State s a
21:05:06 <Ralith> oh, parens
21:05:09 <Ralith> right
21:05:21 <Ralith> yaw: hoogle is your friend ^^
21:05:29 <yaw> yeah i'm starting to notice that :)
21:06:18 <yaw> so I'm guessing the state monad part of the "default install" (whatever that means) since ":t state" works in ghci, but I haven't installed monad-state
21:06:23 <yaw> @hoogle monad-state
21:06:24 <lambdabot> package monad-state
21:06:31 <yaw> hmm :P
21:06:57 <Ralith> did you install the haskell platform?
21:07:01 <Ralith> because that comes with quite a few packages.
21:07:20 <yaw> apt-get install ghci (or something)
21:07:51 <yaw> maybe cabal is conflicting with some pre-installed stuff
21:08:17 <yaw> because it seems a few hackages are not installing cleanly when using "cabal install ..."
21:08:34 <geekosaur> in a standard install it should come from mtl
21:08:52 <yaw> yeah i guess i probably already have that
21:09:32 <neutrino> yaw: what OS are you on?
21:09:42 <yaw> Ubuntu 12.04
21:09:49 <neutrino> yeah you shouldn't be doing that
21:09:56 <neutrino> remove ghc and install haskell platform
21:10:15 <yaw> okay, i'll try that
21:11:20 <yaw> so it appears there's a haskell-platform debian package - is that good to use? or did you mean I should install from source?
21:12:39 <yaw> installing it anyway, see how we go
21:13:02 <yaw> random q:   why does ":k State" not work in ghci but ":k (State String)" works... shouldn't ":k State" work and produce * -> * -> *
21:13:46 <shachaf> yaw: Are you using a really old mtl or something?
21:13:54 <Ralith> if he apt-get installed ghc, probably.
21:13:58 <yaw> this was with ubuntu ghci
21:14:03 <yaw> i've uninstalled it now
21:14:12 <yaw> haskell-package is installing... (with apt-get still, though...)
21:14:26 <shachaf> "State" has been a type synonym for a while.
21:14:36 <shachaf> So :k State shouldn't work but :k State String should.
21:14:40 <shachaf> Oh, wait. That's what you said.
21:14:47 <Ralith> heh
21:14:53 <shachaf> yaw: The answer is that State is a type synonym, so it doesn't have a kind.
21:14:55 <yaw> cool, but you also answered my question, so thanks :)
21:14:57 <Ralith> yaw: you should install haskell-platform, from the website.
21:15:07 <shachaf> Ralith: The website just tells you to use apt-get
21:15:19 <Ralith> oh
21:15:20 <Ralith> >_>
21:15:21 <neutrino> yaw: get haskell-platform from its website, there is a description there
21:15:21 <Ralith> um
21:15:22 <yaw> yeah
21:15:32 <neutrino> they have a ppa
21:15:34 <Clint> what's wrong with the packaged one?
21:15:34 <neutrino> i believe
21:15:36 <Ralith> why does ubuntu have an up to date haskell-platform, but not an up to date ghc?
21:15:39 <neutrino> or a deb server or something
21:15:41 <shachaf> Huh?
21:15:51 <shachaf> I'd think Ubuntu's haskell-platform would depend on ghc.
21:16:08 <Clint> likely ghc 7.4
21:16:14 <yaw> ghc --version  ===>   The Glorious Glasgow Haskell Compilation System, version 7.4.1
21:16:16 <shachaf> That's not old.
21:16:24 <shachaf> You'll be perfectly fine with 7.4
21:17:55 <geekosaur> Ralith, ghc is not like linux.
21:18:01 <yaw> bah.  Ambiguous module name `Control.Monad.State':    it was found in multiple packages: monads-tf-0.1.0.1 mtl-2.0.1.0
21:18:07 <yaw> I'm actually getting stuff like that happen a lot
21:18:11 <shachaf> yaw: How did you get monads-tf?
21:18:15 <yaw> Is there a "best practice" for not having conflicting packages?
21:18:16 <shachaf> You're not supposed to have that.
21:18:22 <shachaf> Did you do something weird?
21:18:28 <Jafet> He thought that you needed monad-state to use Monad.State.
21:18:34 <geekosaur> you do not run the absolute latest version; the latest version is for people who like to play at the wild edges of the type system
21:18:43 <Jafet> Just ghc-pkg unregister the packages.
21:18:49 <shachaf> Yes.
21:18:51 <geekosaur> haskell-platform uses the latest version that normal people shou;d use
21:18:52 <yaw> ok, i resolved my issue. I rm -rf'd my local cabal install stuff
21:18:57 <Ralith> shachaf: if ubuntu has ghc 7.4, why are people discouraged to install it...?
21:19:05 <shachaf> Ralith: They are?
21:19:08 <geekosaur> huh?
21:19:26 <Ralith> shachaf: oh, maybe not.
21:19:29 <geekosaur> well, maybe ubuntu fell down the arch rabbit hole and expects everyone to bleed
21:19:31 <shachaf> Ralith: haskell-platform = a package that depends on ghc and also on a bunch of libraries
21:19:36 <shachaf> As far as I know
21:19:41 <Ralith> that makes sense!
21:19:49 * Ralith was confused.
21:19:53 <shachaf> I don't know why yaw uninstalled ghc to install haskell-platform
21:20:15 <Ralith> because neutrino instructed him to.
21:20:22 <soiamso> shachaf: so many lib not catch up with 7.6 at now
21:20:36 <shachaf> soiamso: Agreed, though it's getting better.
21:20:51 <neutrino> because the last time i installed ghc and then h-p on ubuntu it broke on its own.
21:21:09 <neutrino> that was on 10.04 though.
21:21:36 <Jafet> You boon too
21:21:54 <shachaf> no u
21:22:32 <yaw> for what it's worth, so far uninstalling ghc and installing haskell-platform has not made a difference to the (limited) set of things I've been trying
21:22:55 <Ralith> that is consistent with reality
21:22:57 <shachaf> yaw: Yes, that was a useless step. There's some misinformation going around here. :-)
21:23:02 <geekosaur> if it was the same ghc then any personal installs will still be valid
21:23:03 <shachaf> yaw: What is the original issue?
21:23:10 <yaw> (also, to clarify, i don't currently have any outstanding issues)
21:23:14 <geekosaur> since haskell-platform shuld just reinstall the same ghc
21:23:15 <yaw> the original issue was monad-state not installing
21:23:28 <yaw> but that's a non-issue now since i don't need to install it
21:23:28 <neutrino> try to remove .cabal from your homedir?
21:23:28 <shachaf> yaw: OK. The answer is you don't need monad-state
21:23:31 <shachaf> Yep.
21:23:33 <neutrino> no idea.
21:23:38 <neutrino> :\
21:23:41 <Ralith> I think the issue was just that you had some old no longer relevant library names
21:23:45 <Ralith> but it seems like that is resolved, so.
21:23:52 <yaw> ok
21:23:57 <soiamso> shachaf: and so many lib become uncompatible with 7.4- at near future.
21:24:02 <yaw> i've had some other cabal installs fail
21:24:14 <yaw> but i'll just assume they're for old crufty thigns that aren't supposed to work
21:24:17 <shachaf> soiamso: It's sad.
21:24:31 <yaw> since they were just me mucking around, i haven't actually had something not work that i actually need
21:25:09 <yaw> thanks for the help everyone :)
21:27:00 <Clint> the ubuntu haskell guys have gotten better as of late
21:28:28 <neutrino> yeah, 10.04 was a tragedy
21:36:46 <SrPx> How does function composition work when used in functions with >1 arity?
21:37:08 <Ralith> a -> b -> c is a -> (b -> c)
21:37:15 <Ralith> all haskell functions have "arity" of 1
21:38:27 <Ralith> :t (1*)
21:38:28 <lambdabot> Num a => a -> a
21:38:34 <Ralith> :t (+)
21:38:35 <lambdabot> Num a => a -> a -> a
21:38:41 <Ralith> :t (1*) . (+)
21:38:42 <lambdabot> Num a => a -> a -> a
21:39:27 <shachaf> > compliment (text "norway")
21:39:29 <lambdabot>   you're so wonderful, norway
21:39:42 <Ralith> I applaud whoever added that to lambdabot.
21:39:44 <otters> :t compliment
21:39:45 <lambdabot> Show a => a -> Doc
21:39:49 <otters> :t text
21:39:50 <lambdabot> String -> Doc
21:39:54 <otters> :i Doc
21:39:59 <otters> oh
21:40:45 <neutrino> SrPx: there was some version of . for two-argument functions i believe..
21:41:22 <SrPx> hmm
21:43:37 <mm_freak> SrPx: (.) :: (b -> c) -> (a -> b) -> (a -> c), now replace 'b' by a function type and see what you get
21:44:07 <mm_freak> (.) :: ((x -> y) -> c) -> (a -> x -> y) -> (a -> c)
21:44:42 <SrPx> wait.
21:44:46 <SrPx> im confused.
21:44:50 <Jafet> :t (.:)
21:44:52 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
21:50:14 <JavaSucksMan> > take 10 $ iterate (map f) [x,y,z]
21:50:16 <lambdabot>   [[x,y,z],[f x,f y,f z],[f (f x),f (f y),f (f z)],[f (f (f x)),f (f (f y)),f...
21:50:40 <JavaSucksMan> > 3 + 4
21:50:42 <lambdabot>   7
21:50:49 <JavaSucksMan> > f 7
21:50:51 <lambdabot>   Ambiguous type variable `a0' in the constraints:
21:50:52 <lambdabot>    (GHC.Show.Show a0)
21:50:52 <lambdabot>     ...
21:51:26 <JavaSucksMan> > (map f) [x,y,z]
21:51:29 <lambdabot>   Ambiguous type variable `b0' in the constraints:
21:51:29 <lambdabot>    (GHC.Show.Show b0)
21:51:29 <lambdabot>     ...
21:52:05 <JavaSucksMan> OK, I'm confused
21:52:50 <shachaf> f is magic
21:52:52 <shachaf> Ignore it
21:53:18 <yaw> i'm trying to use hoogle to find a utility function that splits a list based on a value. Searching for (Eq a) => a -> [a] -> [[a]], no results. But then I can find this with google http://hackage.haskell.org/packages/archive/split/0.2.1.1/doc/html/Data-List-Split.html
21:53:50 <yaw> but searching hoogle for "splitOn", for example, doesn't give the above package
21:54:27 <latermuse> yaw: check inside Data.List
21:55:35 <JavaSucksMan> what about x y & z
21:55:44 <yaw> Data.List doesn't seem to export functions like splitOn,
21:55:53 <yaw> only Data.List.Split has the fancier ones
21:56:07 <latermuse> splitAt 3 [1,2,3,4,5]
21:56:29 <yaw> :t splitAt
21:56:31 <lambdabot> Int -> [a] -> ([a], [a])
21:56:34 <Ralith> yaw: Data.List.Split is from a different package than Data.List, if that was unclear
21:56:39 <yaw> :t splitOn
21:56:40 <lambdabot>     Not in scope: `splitOn'
21:56:40 <lambdabot>     Perhaps you meant one of these:
21:56:40 <lambdabot>       `splitAt' (imported from Data.List),
21:56:51 <yaw> see, doesn't find it :(
21:57:03 <aupif> hello. does it makes sense that if I run a main function in ghc that it runs fine, but if I compile the program and run it I get a stack overflow?
21:57:04 <yaw> splitOn should be  (Eq a) => [a] -> [a] -> [[a]]
21:57:43 <yaw> yep, i realise Data.List.Split is a different package, I'm just curious as to why hoogle doesn't seem to index its contents
21:57:47 <latermuse> splitOn [1] [1,2,3,4,5]
21:57:52 <yaw> (and lambdabot here doesn't seem to know it either)
21:57:58 <Ralith> I don't think hoogle indexes all of hackage
21:58:03 <Ralith> lambdabot certainly doesn't have all of hackage loaded.
21:58:11 <latermuse> splitOn [3] [1,2,3,4,5] becomes [[1,2],[4,5]]
21:58:37 <Ralith> yaw: anyway, you can write this yourself trivially
21:58:48 <Ralith> not worth the effort of a dependency imo
21:59:36 <yaw> sure, i was about to, but thought it best to reuse library functions :)
21:59:51 <yaw> maybe i will anyway because the one i actually want is a -> [a] -> [[a]]
21:59:59 <yaw> (i.e. split on element, not sublist)
22:00:00 <latermuse> splitOn ['c'] ['a'..'f'] becomes ["ab","def"]
22:00:59 <Ralith> yaw: latermuse's example, as is convention, takes a list of potential split values, not a sublist.
22:02:06 <yaw> Prelude Data.List.Split> splitOn "ab" "XaYbZ"
22:02:07 <yaw> ["XaYbZ"]
22:02:11 <yaw> doesn't look like it
22:02:12 <latermuse> if you want to use a -> [a] -> [[a]], you could either write it yourself, or just wrap your a with [] then put it through splitOn
22:02:17 <yaw> looks like it's a sublist
22:02:35 <yaw> yeah all good, i'm find with how splitOn works at the moment
22:37:45 <blackdog> anyone know if there's a websocket library for haskell that lets you impersonate a client?
22:40:50 <copumpkin> I've wanted one and have been frustrated to see that all the libraries only let you be a server :P
22:41:17 <shachaf> "impersonate" a client?
22:41:17 <copumpkin> I made my own one-off implementation for my needs
22:41:22 <shachaf> As opposed to actually being one?
22:41:27 <copumpkin> for some reason everyone assumes that if you want to be a client, you're in javascript
22:41:31 <copumpkin> and there's already an implementation
22:41:46 <copumpkin> it's really annoying
22:46:17 <blackdog> shachaf: "be a client" is probably more accurate
22:46:52 <blackdog> at a hackathon, writing a bot for a multiplayer roguelike
22:47:14 <blackdog> ended up doing it in ruby because the libs were available, but it's too slow doing A* searches
22:49:22 <blackdog> copumpkin: don't suppose you've open-sourced your one-off?
22:50:33 * hackagebot vector-th-unbox 0.2 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.2 (LiyangHu)
22:52:15 <copumpkin> blackdog: I'm willing to, but I can't find it now. It was to talk to a shitty bitcoin exchange that published its data over websocket :P
22:52:21 <copumpkin> not sure where it is
22:52:54 <copumpkin> they eventually moved to socket.io, which incorporates websocket, so I wrote some code for that too (but can't find it either)
22:53:05 <copumpkin> I think I formatted my computer since then so it's probably on one of my externals
22:54:30 <blackdog> copumpkin: ah, righto. well, let me know if you happen to come across it :)
22:54:51 <copumpkin> will do
22:54:56 <copumpkin> it was really simplistic though
22:55:01 <copumpkin> since I guess the protocol isn't that bad
22:55:15 <copumpkin> the main annoyance was that it was over SSL, so I used http-enumerator (which I think is deprecated now)
22:55:33 <copumpkin> or was it the underlying TLS package
22:55:36 <copumpkin> can't even remember :P
22:57:16 <blackdog> heh, fair enough. i've got a ruby impl here, maybe i'll just brainlessly translate
23:04:15 <aupif> /nmaes
23:04:58 <shachaf> https://github.com/ghc/ghc/commit/1437590cc560f7e91e7887b4ce195226b26bb13f
23:05:06 <shachaf> Wait, those are plain old value-level holes, not type holes!
23:07:03 <leoncamel> ls
23:07:24 <leoncamel> sorry, wrong console.. :)
23:13:28 <ion> rm -fr ~
23:13:28 <cross> join #sml
23:22:45 <sw2wolf> hello
23:27:42 <startling> hi
23:27:48 <statusfailed> What's a good plotting library? I can't figure out how to get the 'plot' or 'chart' packages to work :(
23:33:50 <luite> statusfailed: trouble installing gtk2hs?
23:41:05 <statusfailed> luite: nah, trouble with the API P
23:41:07 <statusfailed> :P*
23:41:43 <statusfailed> I've got it working now. I was just wondering if there were any other options
23:53:22 <sm> can I not use @ as an operator ? http://stackoverflow.com/questions/10548170/what-characters-are-permitted-for-haskell-operators seems to think I can but ghc complains
23:53:37 <shachaf> sm: Hoogle would answer that question. :-)
23:53:57 <sm> ack
23:54:06 <sm> thanks shachaf .. a pity!
23:54:07 <shachaf> You can use it in an operator name, but not on its own, because that's syntax.
23:54:08 <c_wraith> sm: you can't use @ by itself, because that's syntax
23:54:32 <sm> @@ won't work either
23:54:32 <lambdabot>  won't work either
23:54:52 <sm> wait, maybe it will
23:55:03 <shachaf> > let (@@) = (+) in 2 @@ 3
23:55:05 <lambdabot>   5
