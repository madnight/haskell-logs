00:00:25 <statusfailed> hahaha, proof by use of puns :D
00:00:40 <Nisstyre> would Fermat's Last Theorem be "Proof by reference to inaccessible literature" ?
00:00:46 <Nisstyre> (the original proof)
00:00:52 <statusfailed> Doesn't "no cow" also have infinite legs?
00:00:53 <shachaf> monochrom: I bet you could do proof by imminent authority.
00:00:55 <statusfailed> being the empty set
00:01:06 <pordan30> unless i'm misunderstanding something, i don't think the liftAX / applicative-style notation is what I'm looking for: e.g.: liftAn :: Applicative f => (a1 -> ... -> an) -> (r -> a1) -> ... -> (r -> an) in ((->) r), no? so the second to nth arguments must have the same domain.
00:01:54 <shachaf> What is the domain of an argument?
00:02:02 <pordan30> aren't they function arguments?
00:02:23 <shachaf> Oh, the arguments to liftAn.
00:02:25 <Nisstyre> hmm, no, it would be "Proof by haste"
00:02:30 <shachaf> I have no idea what you're looking for, but yes.
00:03:37 <shachaf> liftAn will just pass your extra argument for you.
00:03:39 <pordan30> something like: comb/n :: (a1 -> ... -> an) -> (r1 -> a1) -> ... (rn - 1 -> an - 1) -> r1 -> ... -> rn -> an
00:04:03 <pordan30> (err. r(n - 1) in the last argument type)
00:04:13 <shachaf> That sounds way more abstract than what you actually want.
00:06:45 <Cale> pordan30: what code are you trying to factor?
00:07:35 <sopvop> pordan30: there is also `ap` for monads
00:07:38 <sopvop> :t ap
00:07:39 <lambdabot> forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
00:08:50 <sopvop> > return (,,) `ap` return 1 `ap` return 2 `ap` return "foo"
00:08:51 <lambdabot>   No instance for (GHC.Show.Show (m0 (a1, a0, [GHC.Types.Char])))
00:08:52 <lambdabot>    arising ...
00:09:22 <sopvop> > (return (,,) `ap` return 1 `ap` return 2 `ap` return "foo") >>= print
00:09:23 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
00:09:23 <lambdabot>    arising from a use of ...
00:09:43 <ivanm> > ((,,) <$> pred `ap` succ) 3
00:09:44 <lambdabot>   Occurs check: cannot construct the infinite type: a1 = a1 -> a0
00:09:47 <ivanm> bah
00:10:13 <ivanm> @type (,,) `ap` pred `ap` succ
00:10:14 <lambdabot> forall a. Enum a => a -> (a, a, a)
00:10:26 <ivanm> > ((,,) `ap` pred `ap` succ) 3
00:10:28 <lambdabot>   (3,2,4)
00:10:38 <pordan30> Cale: nothing in particular at the moment; it's just a common pattern i've found when trying to write pointfree code that causes blowup of the factorization. it seems useful enough to deserve a name
00:10:39 <ivanm> @type ap
00:10:40 <lambdabot> forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
00:10:42 <ivanm> @type (<*>)
00:10:43 <lambdabot> forall (f :: * -> *) a b. Applicative f => f (a -> b) -> f a -> f b
00:11:02 <ivanm> pordan30: excessive pointfree usage often leads to being less readable
00:12:26 <o-_-o> ychat crashed.
00:14:34 <pordan30> sure, but using monad / functor / applicative combinators with ((->) r) is pretty useful, and i see it done often - it seems like a natural generalization of the use of liftM with ((->) r) to factor code. that said: point taken.
00:15:24 <shachaf> What's the pattern you're trying to capture again?
00:16:37 <pordan30> this one: \f g1 ... gn x1 ... xn = f (g1 x1) ... (gn xn)
00:17:10 <shachaf> @pl \g1 g2 g3 x1 x2 x3 -> f (g1 x1) (g2 x2) (g3 x3)
00:17:10 <lambdabot> ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . f) .)
00:17:15 <shachaf> There you go. I don't see the problem.
00:18:19 <pordan30> yup. well, it sounds like there isn't a useful way to capture the pattern :/
00:19:21 <shachaf> I bet you could use two HLists for it!
01:08:21 <shachaf> Is edwardk gone for the night?
01:08:21 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
01:08:41 <frontendloader> @pl (\x -> sortBy x cmp)
01:08:42 <lambdabot> flip sortBy cmp
01:08:56 <mrpantoufle> @help
01:08:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:08:59 <mrpantoufle> @help pl
01:08:59 <lambdabot> pointless <expr>. Play with pointfree code.
01:09:13 <mrpantoufle> @pl fmap fmap fmap
01:09:14 <lambdabot> fmap fmap fmap
01:09:18 <mrpantoufle> −_−
01:09:19 <mrpantoufle> silly me
01:09:43 <mrpantoufle> @pl \f g x y -> f (g x y)
01:09:44 <lambdabot> (.) . (.)
01:09:59 <shachaf> Or roconnor?
01:10:09 <shachaf> Why is everyone gone?!
01:12:06 <sopvop> Maybe it's sleeping time in their time-zone?
01:12:19 <shachaf> It's sleeping time in my time zone too.
01:12:22 <shachaf> Doesn't stop me!
01:14:05 <sopvop> be careful, you may end like this guy http://images3.wikia.nocookie.net/__cb20101223143649/southpark/images/e/eb/Tweek_Tweak.png
01:16:56 <Sonarpulse> A simple question: data structs do no force evaluation right?
01:17:12 <Sonarpulse> and how is a data structure different from a tuple?
01:18:14 * hackagebot vty 4.7.0.20 - A simple terminal UI library  http://hackage.haskell.org/package/vty-4.7.0.20 (CoreyOConnor)
01:18:20 <s2r2> Dear #haskell.  Are there any Pandoc/citeproc-hs users around that (try to) generate non-english documents?
01:19:13 <s2r2> I'm wondering, it seems like citeproc-hs was able to use locales (after all, it installs locale-xx_XX.xml files); but I'm unsure if, when used with pandoc, it does try to (and how I could get it to try)
01:21:55 <Jafet> Sonarpulse: some don't and some do.
01:22:35 <Sonarpulse> is there any generalazing?
01:23:02 <Jafet> If the type appears like: forall a. T a, then T is usually non-strict in a.
01:23:21 <Sonarpulse> oh, I was thinking even more basic like:
01:23:23 <Jafet> If it appears like: T Int or (Unbox a) => T a, then it is usually strict in a.
01:23:52 <Sonarpulse> data foo = foo {num1 :: integer, num2 :: integer }
01:24:33 <Jafet> data types are lazy by default
01:24:59 <Sonarpulse> and hopefully GHC can "inline" them out if they are only used once?
01:25:15 <startling> Sonarpulse, that's not what "inline" means
01:25:17 <shachaf> If your data type declaration has syntax errors, your values will never be evaluated.
01:25:35 <Jafet> Sometimes, but it is difficult to do that correctly.
01:26:05 <Jafet> -defer-syntax-errors
01:26:57 <Sonarpulse> well I think i will just go with it for now, seems cleaner though more rigid
01:27:21 <Sonarpulse> what about accessors for those types of data?
01:27:31 <startling> Sonarpulse, -O2 will strictify some things
01:27:54 <Sonarpulse> thanks
01:28:57 <startling> Sonarpulse: what do you mean by "accessors"?
01:29:13 <Sonarpulse> are they made automatically like the data constructors?
01:29:39 <Sonarpulse> I mean the function to pull values from something made with data a = a {...}
01:29:51 <Jafet> They are made when you write them in the datatype definition.
01:30:28 <Sonarpulse> oh ok, just got the syntax right
01:30:29 <startling> Sonarpulse: data X = X { x :: Integer } defines x :: X -> Integer
01:31:11 <Jafet> startling: I don't think he's referring to lenses, no
01:31:28 <Sonarpulse> i think that is what I want
01:31:32 <Sonarpulse> actually
01:32:01 <startling> Jafet: neither do I?
01:32:11 <statusfailed> How can I view the modules in a package I have installed?
01:32:28 <statusfailed> is there some way to do it with ghc-pkg?
01:32:31 <startling> Jafet, the other thing he could have meant was java-style getters/setters
01:32:34 <Jafet> View the modules?
01:32:56 <statusfailed> Jafet: see what modules are in the packeage
01:32:58 <Sonarpulse> I don't know java: staying as far away from that as I can
01:33:13 <Jafet> You can view the haddock index for the modules, but modules themselves aren't very showy
01:33:23 <Sonarpulse> "data X = X { x :: Integer } defines x :: X -> Integer"
01:33:26 <Sonarpulse> is what i wanted
01:33:39 <Sonarpulse> what do you all call those generated functions
01:33:41 <startling> Sonarpulse: cool, that's why I asked. :)
01:33:42 <statusfailed> i'm not generating a haddock for the package yet
01:33:48 <startling> Sonarpulse, record fields
01:33:53 <Jafet> cabal unpack foo; ls -R foo/
01:33:58 <statusfailed> Jafet: can I just unpack it somehow?
01:34:04 <statusfailed> toolsow :D
01:34:10 <statusfailed> thanks*
01:34:30 <Sonarpulse> record field is the field itself, or the function that get it?
01:34:32 <Jafet> > "toolsow" \\ "thanks"
01:34:33 <lambdabot>   "oolow"
01:34:57 <startling> Sonarpulse: both, I guess.
01:35:06 <Sonarpulse> interesting
01:35:11 <statusfailed> er, where do packages go on cabal install?
01:35:12 <Sonarpulse> well thanks so much everbody
01:35:17 <Jafet> Sonarpulse: the name of the field can be used both as a function and a name.
01:35:25 <Sonarpulse> that's true
01:35:39 <Sonarpulse> i guess that's kind of  why "record fields" can work for both too
01:35:48 <startling> Sonarpulse: another things is "lenses", which are a little bit nicer in some respects, but they're fairly cutting-edge
01:36:14 <Sonarpulse> hmm?
01:36:25 <Sonarpulse> what makes them speciel?
01:36:26 <startling> Sonarpulse: another things is "lenses", which are a little bit nicer in some respects, but they're fairly cutting-edge
01:36:40 <Jafet> statusfield: your use of prepositions for ethereal entities is a bit confusing
01:36:51 <statusfailed> haha
01:36:59 <fmap> statusfailed: ghc-pkg field $package exposed-modules
01:37:09 <statusfailed> Where are the binary files for a particular package copied to when I run "cabal install"
01:37:15 <startling> Sonarpulse, you can do things like view (_1._1) (('a', 'b'), 'c') == 'a'
01:37:21 <statusfailed> fmap: nice! thanks
01:37:41 <Sonarpulse> well i don't know all that syntax yet
01:37:47 <Sonarpulse> anyways I do have to go
01:37:56 <Sonarpulse> thank again
01:38:03 <Jafet> They get installed to whichever world is appropriate, such as ~/.cabal/
01:38:11 <startling> Sonarpulse: it's not much syntax, . is (.), _1 is a lens, (('a', 'b'), 'c') is a tuple
01:38:19 <startling> Sonarpulse: but sure, seeya later
01:38:32 <statusfailed> Turns out you need exposed-modules in your cabal file!
01:38:41 <Sonarpulse> ok.. that helps
01:38:46 <Sonarpulse> i guess i can look them up more too
01:38:49 <Sonarpulse> bye
01:48:16 * hackagebot Semantique 0.3.0 - Command-line tool for maintaining the Semantique database.  http://hackage.haskell.org/package/Semantique-0.3.0 (DavidHimmelstrup)
02:13:26 <thirsteh> is there anything like an efficient Data.List.popFirstBy :: (a -> Bool) -> [(a, b)] -> (Maybe b, [(a, b)])? Should I just use Data.Sequence.Seq (a, b)?
02:13:42 <thirsteh> I assume that lists are not doubly-linked lists?
02:14:05 <gal_bolle> no, they aren't
02:14:21 <thirsteh> alright, I'll just use sequence, thanks
02:16:55 <frontendloader> compiler errors are starting to make more and more sense
02:17:05 <frontendloader> to me, personally
02:24:11 <thirsteh> it feels like there should be an efficient way to pop a value from a list and return the list with it omitted, if lists are single-linked. Essentially what I want is Data.List.deleteFirstBy, but including the thing that was matched
02:24:20 <thirsteh> I can't wrap my head around how to do it recursively though
02:26:13 <thirsteh> hmm, I guess that would need to be mutating to be efficient
02:26:37 <ClaudiusMaximus> > break isUpper "hello, World"
02:26:38 <lambdabot>   ("hello, ","World")
02:27:36 <thirsteh> I could do something like break, take the head, and concatenate the lists, but I was thinking that was inefficient
02:28:22 <thirsteh> I was thinking of something like traversing the linked list, keeping track of the last node, and changing the last node to point to the next one when I found something, but I realize that's not possible, or wanted, here
02:29:31 <ClaudiusMaximus> i think O(length(unmatchedprefix)) about as good as you can get - even with mutation you'd need to traverse that many elements to find where to delete
02:29:33 * thirsteh mutters something about HTTP headers having to retain their ordering
02:30:19 <thirsteh> yeah
02:30:38 <frontendloader> popping implies mutation does it not too
02:31:11 <thirsteh> not necessarily, but generating the popped list will be inefficient otherwise
02:31:20 <shachaf> Not really.
02:31:22 <thirsteh> at least I assume it will
02:31:35 <ClaudiusMaximus> the tail can be shared
02:31:37 <Iceland_jack> Normally “peek” refers to a non-mutative operation
02:31:51 <thirsteh> that's true
02:31:52 <shachaf> thirsteh: "pop" usually refers to taking the front element off.
02:32:15 <thirsteh> shachaf: popBy then
02:32:19 <shachaf> Huh?
02:32:31 <thirsteh> popFirstBy :: (a -> Bool) -> [(a, b)] -> (Maybe b, [(a, b)])
02:32:45 <frontendloader> this is more like
02:32:49 <frontendloader> omitFirstBy ::
02:32:53 <shachaf> Just don't use the word "pop". This isn't popping. :-)
02:33:03 <thirsteh> frontendloader: I want the thing that I've omitted
02:33:07 <thirsteh> otherwise it'd just be deleteFirstBy
02:33:14 <shachaf> Also, why not (a -> Bool) -> [a] -> Maybe (a, [a])?
02:33:38 <thirsteh> shachaf: yeah, I happen to be doing it on an AL, but that's not important
02:33:58 <thirsteh> shachaf: how would you suggest doing this?
02:33:59 <shachaf> If you're using a list as a key-value map, you might consider using a Map instead.
02:34:04 <thirsteh> I can't
02:34:21 <Ralith> why not?
02:34:33 <thirsteh> it's HTTP headers--they have to retain their ordering, at least if I want to follow the RFC
02:34:44 <paolino> :src deleteBy
02:34:46 <thirsteh> some headers can span multiple lines
02:34:54 <Ralith> thirsteh: that doesn't mean you can't use a Map.
02:35:00 <Ralith> it just means you have to retain the ordering.
02:35:43 <shachaf> Well, there are all sorts of things you can do.
02:35:52 <thirsteh> I suppose I could add that information to the map's values
02:36:08 <thirsteh> the problem is you can have duplicate keys, and they have to retain their ordering
02:36:39 <shachaf> If you're sure that you want to deal with a list of key-value pair, the operation (a -> Bool) -> [a] -> Maybe (a, [a]) will have to make N new (:)s, where N is the number of items before the first one that matches.
02:37:15 <thirsteh> I'm fine with that
02:37:17 <shachaf> I'm not quite sure what you're doing here, though. There are a lot of potential solutions.
02:39:23 <paolino> @src partition
02:39:23 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
02:39:23 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
02:39:23 <lambdabot>                               | otherwise = (ts, x:fs)
02:40:54 <espringe> I'm trying to port some code from C++ and Scala -- and running into what seems like a big problem. It's heavily based around persistent hashmaps, and there's hundreds of thousands of "copies" made, as well as merges of these copies together. In Scala/C++ I can easily do a "reference equality" when doing the merge, so that I only have to merge parts of the tree structure that aren't the same -- but I can't see if you can do the s
02:41:20 <espringe> My merges are going to be proportional to the size of the trees, instead of proportional to the changes made
02:41:56 <Ralith> espringe: you can reimplement an operation isomorphic to referential equality tests for your purposes.
02:41:59 <Ralith> probably.
02:42:36 <espringe> I can implement something that is logically the same (a comparison), that's no problem and needs to be done anyway
02:42:49 <espringe> But the whole idea of persistent datastructures, is they share a lot of the data
02:43:01 <espringe> so when comparing two of them, i really need to see that it's shared
02:43:24 <shachaf> I think Ralith means something like tagging each object with an ID so you can compare IDs.
02:43:35 <espringe> hm
02:43:55 <Ralith> yep.
02:43:56 <espringe> I'll need to give that some thought, how to do that
02:44:20 <Ralith> a simple state monad is an easy approach
02:44:38 <Ralith> but there are a million ways to generate names
02:45:23 <espringe> I guess I could have a global counter, that i use as an node-id for each new node
02:45:29 <espringe> but seems like a really really hacky approach
02:46:05 <shachaf> Well, it doesn't have to be global, just unique. :-)
02:46:17 <Ralith> 'counter' is a tricky term, also.
02:46:40 <ion> counter strike
02:46:47 <espringe> How do people do stuff like fast string / collection comparisons? There's no way to quickly check that the two values aren't the same physical value before committign to a deep comparison?
02:46:49 <shachaf> Counter? I just met 'er!
02:47:24 <shachaf> espringe: Sometimes people do evil observable sharing or other evil things.
02:47:35 <sipa> espringe: you could keep a hash of the data + subnodes in every node
02:47:36 <espringe> I guess that would be problematic, as sometimes you'd have two infinite lists that could like return they're the same -- and then other times it just not terminate
02:48:31 <espringe> Hm, a hash of the children could work nicely actually. In the rare case of hash-collisions, i just do the deep check
02:48:46 <espringe> I like that approach a lot actually
02:48:51 <espringe> oh shit
02:48:53 <sipa> yes, if the hashes do not match, you are certain they are different
02:48:54 <espringe> never mind, i'm retarded
02:49:08 <espringe> I want to optimize the case they *are* the same
02:49:24 <espringe> If they're different, i got to go in and do the merge
02:49:29 <fmap> super quick check (also unreliable) is reallyUnsafePtrEquality#. I guess?
02:49:29 <espringe> so knowing they're different, doesn't really help me
02:49:41 <sipa> make the hash function SHA3 or something, and they won't collide before the universe dies
02:50:10 <ion> Make the hash function SHACHAF.
02:50:11 <espringe> Well if they're both hashing the node with the value "1" -- they will :P
02:50:35 <sipa> that's not a collision
02:50:54 <espringe> true
02:53:50 <espringe> I don't understand the signature  "reallyUnsafePtrEquality# ::  a -> a -> Int#"
02:53:55 <espringe> Why is it returning an Int# ?
02:54:57 <Jafet> What should it return?
02:55:05 <espringe> A boolean?
02:55:33 <Jafet> Booleans might not exist yet.
02:55:51 <donri> i bet it's c-style 0, 1 or error code
02:56:13 <ion> FileNotFound
02:56:42 <shachaf> espringe: The reason you don't understand it is that you're not supposed to use it.
02:57:22 <ion> shachaf: I thought you’re only supposed to avoid the reallyReallyUnsafe…# functions.
03:17:17 <gal_bolle> morning owst
03:34:57 <wereHamster> god, what magic do I have to apply so I can use Data.Map.insertWith inside an STM monad?
03:35:13 <shachaf> The same as anywhere else?
03:35:33 <wereHamster> lemme paste some code.
03:40:06 <hpaste> wereHamster pasted “insertWith inside STM?” at http://hpaste.org/77145
03:41:53 <cmears> "map" is perhaps not the best name (:
03:42:23 <wereHamster> I have not named it map in my actual code.. this is just for illustration
03:43:04 <donri> wereHamster: someTVar <- newTVar (Some int); atomically $ ...
03:43:56 <fmap> :t Control.Concurrent.STM.TVar.newTVar
03:43:57 <lambdabot> Couldn't find qualified module.
03:44:54 <donri> @hoogle newTVar
03:44:54 <lambdabot> GHC.Conc.Sync newTVar :: a -> STM (TVar a)
03:44:54 <lambdabot> GHC.Conc newTVar :: a -> STM (TVar a)
03:44:54 <lambdabot> Control.Concurrent.STM.TVar newTVar :: a -> STM (TVar a)
03:44:58 <fmap> donri: you probably meant newTVarIO?
03:45:02 <wereHamster> newTVar returns STM (..), right? So you can only use it inside the STM monad, which means inside the atomically $ do ... block
03:45:15 <donri> oh yea
03:45:27 <shachaf> wereHamster: Yes, but the point stands.
03:45:39 <donri> just do the newTVar like you're doing the state readTVar
03:45:42 <shachaf> You're trying to put an IO action that contains a TVar into your map.
03:45:46 <demo> who can help me?
03:45:49 <shachaf> Er, STM action.
03:45:49 <demo> in the irc
03:45:53 <demo> the irc server?
03:45:57 <shachaf> demo: No one, if you don't ask your question.
03:46:04 <wereHamster> shachaf: where am I trying to insert that IO action?
03:46:18 <shachaf> There's no IO action. It's an STm action.
03:46:29 <shachaf> (newTVar (Some int)) :: STM (TVar blah)
03:46:59 <hpaste> donri annotated “insertWith inside STM?” with “something like this” at http://hpaste.org/77145#a77146
03:47:17 <ion> (newTVar (Some (int))) :: ((STM) (TVar (blah)))
03:48:01 <shachaf> You forgot a few, ion.
03:48:06 <ion> sorry :-(
03:48:17 <demo> what?
03:48:31 <demo> the haskell is language?
03:48:31 <wereHamster> so, still doens't work. In the merge function, I either need to update the TVar or create a new one. But merge is a pure function, it doesn't run in any monad. what do I do?
03:48:51 <ion> Yes, like English
03:49:05 <fmap> better
03:49:34 <nand`> it's somewhat less complicated than english
03:49:49 <ion> For instance, there are no monads in English.
03:49:53 <yiannis_t> <troll-mode>
03:50:04 <demo> thanks
03:50:07 <demo> i will study
03:50:12 <demo> is't sound good
03:52:01 <paolino> wereHamster, insertWith is not monadic
03:52:05 * nand` wonders why it's Map String (TVar Some) rather than Map String Some
03:52:42 <wereHamster> Because Some's are independent. Updating the whole shared state each time I access the Somes would quickly lead to contention
03:52:43 <nand`> (isn't technically every haskell function monadic?)
03:53:01 <nand`> wereHamster: but that's what you're doing, isn't it?
03:53:20 <wereHamster> here, yes. But there's ton of other code which only requires the Somes
03:53:39 <nand`> it just seem to me that if you wanted to update only the leafs without writing to the map you'd only have the ‘writeTVar’ there in the base case in which no leaf exists already
03:53:43 <nand`> but I don't know the semantics of your code
03:54:12 <wereHamster> nand`: here I want to insert or update a Some. So I need to access the global shared state.
03:57:27 <wereHamster> hm, what I could do is merge _ old = old, and after the insert: lookup the tvar and modify.
03:57:54 <hpaste> mrlemao pasted “void? What is it doing here?” at http://hpaste.org/77147
03:58:54 <Lemmih> mrlemao`: It ignores the result of 'forkProcess'.
04:02:14 <paolino> wereHamster, you have to handle the insert and adjust cases separately with a lookup
04:02:49 <paolino> well, there is no adjust
04:02:51 <mrlemao`> Lemmih: ok, prob not what I am looking for
04:03:31 <Maxdamantus> @hoogle IO a -> IO ()
04:03:31 <lambdabot> Foreign.Marshal.Error void :: IO a -> IO ()
04:03:31 <lambdabot> Control.Exception.Base block :: IO a -> IO a
04:03:31 <lambdabot> Control.Exception block :: IO a -> IO a
04:03:42 <mrlemao`> Lemmih: from main (IO () do block) I am trying to call a function that returns a different monad
04:03:51 <fmap> mrlemao`: `void' is useful when you feel like enabling `fwarn-unused-do-bind' annoyance
04:04:14 <wereHamster> paolino: I was hoping that I could do it in one step, somehow inside the merge function. Surely I'm not the only one who wants to run a monadic action inside the insertWith merge function.
04:04:48 <Lemmih> mrlemao`: There's no general way of interleaving monadic actions. Show us some code and we can help.
04:04:54 <Ralith> fmap: it's also useful for things like 'when'
04:05:13 <hpaste> mrlemao pasted “How to interleave?” at http://hpaste.org/77148
04:05:24 <paolino> wereHamster, anyway it makes half sense to create and access a TVar , if it already exists.
04:05:26 <mrlemao`> Lemmih: see line 26
04:06:04 <paolino> @hoogle insertWithM
04:06:05 <lambdabot> No results found
04:07:43 <wereHamster> I already tried that :)
04:08:17 <wereHamster> Another option is to do it all manually, with case M.lookup ... of Nothing -> ... Just x -> ...
04:08:30 <paolino> the only option
04:08:34 <wereHamster> that way I'll stay in the SDM monad all the time.
04:08:48 <fmap> Ralith: yeah, but that's because `when' is unreasonably monomorphic :[
04:08:56 <wereHamster> hm, maybe I could wrap that in a custom insertWithM function :)
04:09:14 <nand`> fmap: even if it weren't, it'd be useful in the definition of ‘when’
04:09:31 <nand`> when True = void; when False = const (return ())
04:10:13 <Lemmih> mrlemao`: Look the documentation for distributed-process.
04:10:37 <Lemmih> mrlemao`: You most likely want to use the SimpleLocalnet backend.
04:10:43 <shachaf> when True = fmap (return ()); when False = return (return ())
04:11:05 <nand`> fmap (const ())
04:11:12 <nand`> oh
04:11:17 <nand`> tricky
04:12:16 <shachaf> @ty let when b = (if b then fmap else return) (return ()) in when
04:12:17 <lambdabot> forall a. Bool -> (a -> a) -> a -> ()
04:12:18 <nand`> fmap (return ()) = (() <$) but that's not much prettier
04:12:28 <shachaf> Silly monomorphism thing!
04:12:54 <fenton> SimonRC:
04:13:16 <mrlemao`> Lemmih: true, but I am stuck even before that. how do I call startKitty from main?
04:16:54 <Lemmih> mrlemao`: You don't.
04:17:18 <Lemmih> mrlemao`: You use SimpleLocalnet which will call it for you.
04:18:25 * hackagebot snaplet-riak 0.1.0.0 - A Snaplet for the Riak database  http://hackage.haskell.org/package/snaplet-riak-0.1.0.0 (PaulWilson)
04:20:44 <osa1> I'm trying to understand type-level programming , do type-level functions and extensions allowing more complex typeclasses/instances (like FlexibleInstance, FlexibleContexts, FunctionalDependencies, MultiParamTypeClasses etc.) cause any extra run-time operations ?
04:24:33 <merijn> osa1: Some of them (for example typeclasses may result in more indirect dictionary lookups), others don't
04:24:45 <demo> what?
04:24:49 <demo> what?
04:26:01 <merijn> osa1: But in general that overhead is fairly small and is not so much overhead as it is not being able to inline some typeclass lookups
04:27:30 <nicoo> :t `==<`
04:27:31 <lambdabot> parse error on input ``'
04:27:34 <Jafet> Most of those extensions merely lift arbitrary restrictions on the type system.
04:27:36 <nicoo> :t `==<'
04:27:37 <lambdabot> parse error on input ``'
04:27:38 <osa1> merijn: thanks. I'm reading "strongly typed heterogeneous collections" paper but I'm having trouble understanding typeclass and instance definitions, do you know a better paper to get me started with type-level programming ?
04:28:35 <osa1> ie. code in that paper uses 5 GHC extensions without describing any of them
04:29:15 <Jafet> @google "strongly typed heterogeneous collections" filetype:pdf
04:29:18 <lambdabot> http://homepages.cwi.nl/~ralf/HList/paper.pdf
04:29:18 <lambdabot> Title: Strongly Typed Heterogeneous Collections
04:29:19 <merijn> osa1: Which ones? The ones you just listed?
04:29:32 <osa1> merijn: yes
04:29:45 <Jafet> @hackage HList
04:29:46 <lambdabot> http://hackage.haskell.org/package/HList
04:30:36 <merijn> osa1: FlexibleInstances and FlexibleContexts are rather simple in that they simply accept more Contexts (typeclass constraints) or Instances that Haskell98 doesn't allow
04:31:39 <merijn> osa1: For example (ignore that this already exists), Haskell doesn't allow defining "instance Eq (Maybe Int) where", because it demands that there is only one non-variable in the type you're using and that one must be the first entry.
04:31:53 <merijn> i.e. it only allows "instance Eq (Maybe a) where"
04:32:29 <merijn> FlexibleInstances just tells GHC to be more flexible and accept anything that has a single valid interpretation
04:32:40 <merijn> Contexts is similar, but for the typeclass contraints
04:33:16 <merijn> osa1: MultiParamTypeClasses is also very simple, Haskell98 only allows typeclasses with one argument, MultiParamTypeClasses lets you define ones with more than one
04:33:18 <osa1> merijn: as far as I understand, with FlexibleInstances instance definitons can use values instead of types, is it correct ?
04:33:35 <merijn> osa1: No, they can use "types" instead of "type variables"
04:33:43 <osa1> hmm
04:34:07 <merijn> osa1: If it allowed values you could write something like "instance Eq 'a'" or "instance Eq 1"
04:34:45 <merijn> osa1: MultiParamTypeClasses lets you define classes like "class Convert a b where convert :: a -> b" which is illegal in haskell98 since you have two parameters
04:35:22 <osa1> merijn: is that how dependent types work ? using values in place of types in typeclasses or instances ?
04:36:03 <merijn> osa1: Kinda-ish, if you don't particularly care about being technically correct in your statements :)
04:36:22 <merijn> osa1: FunctionalDependencies is a bit trickier to explain, but there are some fairly readable papers about it
04:36:40 <Jafet> @quote kmc synonymous
04:36:40 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
04:36:46 <osa1> merijn: I should move to another room, coming in 5 minutes ..
04:37:33 <merijn> Jafet: Right ;)
04:41:29 <shachaf> Is there a sort of dual to Monoid that lets you take values apart rather than putting them together?
04:42:13 <osa1> merijn: I'm back, have you written something for me ?
04:42:23 <Jafet> mappend is not injective, which complicates things a bit
04:42:36 <osa1> merijn: can you recommend me some of the "readable" papers about FunctionalDependencies
04:42:40 <merijn> osa1: Well, I was just gonna add you might want to look at the "Fun With Functional Dependencies" paper
04:42:44 <Jafet> Is there a dual to groups?
04:42:55 <osa1> merijn: thanks
04:42:57 <merijn> osa1: The GHC manual also has reasonably understandable example of when to use them
04:43:24 <nand`> msplit :: a -> (a, a); with the semantics of msplit a = (a, mempty); msplit a = (mempty, a);  msplit *** id . msplit ≅ id *** msplit . msplit --? :P
04:43:54 <Jafet> Perfect, thank you
04:44:10 <shachaf> Thanks, just what I needed.
04:44:17 <osa1> merijn: I've never written a line of code in a dependently typed language but I've heard that some type system extensions of GHC make haskell more dependently-like, what are those extensions ?
04:44:27 <osa1> s/dependently-like/dependently-typed-like
04:44:28 <shachaf> I suspect I'm asking the wrong question.
04:44:46 <nand`> probably, I don't know what a useful ‘dual to monoid’ would look like
04:45:26 <shachaf> No one said anything about useful!
04:45:49 <nand`> or interesting
04:45:56 <merijn> osa1: Things like TypeFamilies and DataKinds
04:46:22 <shachaf> At least I found the bug in holesOf in lens.
04:46:39 <Twey> osa1: FSVO ‘dependent-like’, GADTs & TypeFamilies maybe
04:46:49 <nand`> what bug is that?
04:47:13 <shachaf> #79
04:47:42 <merijn> I take this conversation as a sign I really should write that "guided tour of GHC extensions" some time...
04:48:07 <byorgey> osa1: and especially DataKinds
04:48:24 <byorgey> especially when used in conjunction with the ones Twey mentioned
04:48:24 <shachaf> merijn: Can you write a guided tour of lens instead?
04:48:31 <osa1> Twey: FSVO ?
04:48:38 <shachaf> @google fsvo
04:48:39 <lambdabot> http://www.urbandictionary.com/define.php?term=FSVO
04:48:39 <lambdabot> Title: Urban Dictionary: FSVO
04:50:19 <osa1> merijn: what is your blog address ?
04:51:12 <mrlemao`> quit
04:52:21 <merijn> osa1: I don't have one :p
04:53:39 <osa1> merijn: then where will you publish "guided tour of GHC extensions" post ? :)
04:53:54 <shachaf> Uh-oh, merijn. osa1 got you good.
04:54:09 <merijn> osa1: Well, making one is somewhere on my list of priorities, right after writing stuff for it :p
04:54:11 <shachaf> If you don't have a blog address, you're a practical non-entity on the Internet.
04:54:28 <shachaf> Let me see your IRC license.
04:54:34 <osa1> hahah
04:55:09 <janbanan> I have defined the binary numbers as a list of Bit and now I try to define the successor function but I can't figure out how it should work, any ideas?
04:55:47 * earthy remembers the internet before blogs
04:56:01 * earthy notices there now is an internet 'after' blogs
04:56:14 <earthy> e.g.: you could replace blog with twitter feed or facebook timeline
04:56:35 * Ferdirand remembers these being called "weblogs"
04:57:09 <merijn> shachaf: Right, so where's your blog? :p
04:58:59 <shachaf> merijn: I don't got one!
04:59:02 <shachaf> You've found me out.
04:59:12 <byorgey> janbanan: maybe you already knew this, but it will work best if your list of bits *starts* with the *least significant* bit (so the list is "backwards")
04:59:21 <byorgey> janbanan: i.e. use  [0,0,1]  to represent 4.
04:59:33 <shachaf> byorgey: More like "forwards".
04:59:49 <shachaf> It's the sensible representation!
04:59:56 <byorgey> shachaf: good point!
05:00:07 <byorgey> we did get our numbers from a language that writes right-left, after all.
05:00:51 <byorgey> janbanan: then pattern-match and decide what to do.  successor [] = ?   successor (0:bs) = ?   successor (1:bs) = ?
05:01:03 <byorgey> though actually you will also need to change that to keep track of a carry bit.
05:01:19 <shachaf> data Bit = O | I
05:02:56 <nand`> there's an implementation of Nats as lazy bit lists somewhere, mind
05:03:03 <nand`> (and ints)
05:26:56 <nand`> “fresh = id <+= 1”; yuck, should be “fresh = id <%= succ”
05:27:16 <shachaf> Hardly.
05:27:20 <shachaf> succ is yuck
05:27:27 <byorgey> succ is yucc
05:27:37 <shachaf> yuckety succ
05:27:43 <nand`> but it's generalized to any enumerable identifier
05:27:54 <shachaf> Yes, but Enum is an abomination.
05:28:01 <nand`> fair point
05:45:28 <t7> if ghc could link 2 versions of a module to a single exe could we get rid of the cabal errors?
05:46:31 <donri> not necessarily... depends on how "private" the dependencies are
05:46:49 <donri> there's been talk of allowing a distinction between private and public dependencies
05:59:53 <bartavelle> my executable is throwing a Prelude.undefined, but there is none in my code, I suppose it comes from a module I call
06:00:03 <bartavelle> how can I know where that comes from ?
06:00:38 <t7> what packages are you using?
06:00:47 <bartavelle> base ==4.5.*, containers, parsec, random, mtl, pqueue, unordered-containers, grid, astar
06:03:59 <bartavelle> it seems I can't break on the "undefined" function using ghci
06:04:05 <bartavelle> I didn't figure out how
06:04:16 <t7> isnt it a constant?
06:04:29 <bartavelle> cannot set breakpoint on undefined: module GHC.Err is not interpreted
06:07:07 <mm_freak> i really think that unamb isn't appreciated enough for parallel programming
06:07:17 <mm_freak> for some algorithms it's really convenient
06:08:41 <t7> a language based on systemf with no type inference would pretty much be esoteric
06:11:23 <t7> i feel like   Maybe a -> Maybe a -> Maybe a   would be more useful
06:12:08 <Jafet> t7 has solved the halting problem already, you see.
06:12:21 <t7> oh i didnt read :)
06:12:46 <t7> i only work with total functions
06:14:04 <t7> oo there is parrelel or & and in that package
07:03:36 * hackagebot sequor 0.3.0 - A sequence labeler based on Collins's sequence perceptron.  http://hackage.haskell.org/package/sequor-0.3.0 (GrzegorzChrupala)
07:03:38 * hackagebot hashable-generics 1.1.6 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.6 (ClarkGaebel)
07:11:06 <Jafet> > do ()
07:11:08 <lambdabot>   ()
07:11:10 <Jafet> Wat
07:12:18 <dmwit> Jafet: desugar it manually according to the Report and you will understand
07:12:41 <paolino> @hoogle unamb
07:12:41 <lambdabot> package unamb
07:12:41 <lambdabot> package unamb-custom
07:13:10 <dmwit> Any Monad constraints that arise on do-blocks are due merely to type inference and the appearance of (>>=) in the desugaring.
07:13:28 <Eduard_Munteanu> > do 1 + 1
07:13:29 <lambdabot>   2
07:13:44 <typoclass> > do Nothing
07:13:45 <lambdabot>   Nothing
07:13:50 <maurer> Eduard_Munteanu: Does lambdabot implicitly lift things into the Identity monad, or....
07:14:07 <maurer> I am confused as to why just listing a pure value after do is working.
07:14:11 <dmwit> maurer: Nope. See my comments above.
07:14:12 <Eduard_Munteanu> No Identity monad involved.
07:14:36 <dmwit> maurer: Desugar it yourself by hand, following the rules in the Report, and see what you get out. =)
07:14:36 <typoclass> > do 4 ; 7 -- this won't work
07:14:37 <lambdabot>   Could not deduce (GHC.Num.Num (m a0))
07:14:37 <lambdabot>    arising from the ambiguity check f...
07:14:49 <ion> > (do 4 ; 7) 42
07:14:50 <lambdabot>   7
07:14:54 <Jafet> @undo do x
07:14:54 <lambdabot> x
07:15:08 <typoclass> ion: yeah but that selects the (->) instance, doesn't it
07:15:10 <maurer> dmwit: Yeah, trying to find the relevant report rules
07:16:46 <maurer> Oh, huh, the bind never gets produced
07:16:52 <maurer> So it doesn't care
07:16:58 <dmwit> right =)
07:17:00 <maurer> Still feels a bit weird, vov
07:17:43 <dmwit> definitely
07:17:45 <Jafet> Presumably this opens a new avenue of expression: do this, or do that, or please (do not)
07:18:01 <Eduard_Munteanu> INTERHASK
07:18:02 <dmwit> ?hackage acme-don't
07:18:02 <lambdabot> http://hackage.haskell.org/package/acme-don't
07:18:15 <Jafet> @hackage acme-dont
07:18:15 <lambdabot> http://hackage.haskell.org/package/acme-dont
07:19:28 <ion> There’s also an acme don't in CPAN. :-)
07:20:15 <typoclass> > do not want
07:20:17 <lambdabot>   True
07:21:31 <dmwit> ion: That was the inspiration for the one on Hackage, I'm pretty sure.
07:24:48 <Chaze> @pl (\f g input -> g (f input) input)
07:24:49 <lambdabot> flip flip id . (ap .) . flip (.)
07:25:17 <typoclass> Chaze: you may be interested in <*>
07:25:20 <Chaze> @pl (\g f input -> g (f input) input)
07:25:20 <lambdabot> flip flip id . liftM2
07:25:25 <typoclass> > ((==) <*> reverse) "radar"
07:25:26 <lambdabot>   True
07:25:36 <dmwit> ?pl \input g f -> g (f input) input
07:25:36 <lambdabot> flip =<< (flip .) . flip (.) . flip id
07:25:41 <dmwit> oh, right
07:25:48 <dmwit> ?pl \input g f -> g input (f input)
07:25:48 <lambdabot> ap (flip . ((.) .) . flip id) (flip id)
07:25:52 <typoclass> > ((==) <*> reverse) "lolcats"
07:25:53 <lambdabot>   False
07:25:59 <dmwit> hm
07:26:08 <Chaze> :t (<*>)
07:26:10 <lambdabot> forall (f :: * -> *) a b. Applicative f => f (a -> b) -> f a -> f b
07:26:44 <typoclass> Chaze: if that helps, in this case <*> is the same as ap (i'm pretty sure)
07:28:00 <dmwit> Chaze: I feel like the first one you gave should just be (>>=).
07:28:02 <dmwit> Was that your intent?
07:28:08 <typoclass> Chaze: see http://hackage.haskell.org/packages/archive/base/4.1.0.0/doc/html/src/Control-Applicative.html for the instance being selected ... (<*>) f g x = f x (g x)
07:28:16 <dmwit> :t [(>>=), \f g input -> g (f input) input]
07:28:17 <lambdabot> forall t a b. [(t -> a) -> (a -> t -> b) -> t -> b]
07:28:19 <dmwit> yeah
07:28:45 <Chaze> oh, i wasn't aware that it was bind
07:28:55 <Chaze> i just observed that control flow and felt like it was something
07:29:04 * typoclass scratches his head ... is >>= really the same as <*> with just some arguments flipped ...
07:29:09 <dmwit> It is something. I'm actually a bit surprised that ?pl didn't notice it.
07:29:24 <dmwit> typoclass: Specifically for the Reader monad/applicative...
07:29:29 <ion> @type (=<<) `asAppliedTo` (undefined :: a -> b -> c)
07:29:30 <lambdabot> forall a b b1. (a -> b1 -> b) -> (b1 -> a) -> b1 -> b
07:29:32 <ion> @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
07:29:33 <lambdabot> forall a b a1. (a1 -> a -> b) -> (a1 -> a) -> a1 -> b
07:29:53 <ion> @@ @djinn @type (=<<) `asAppliedTo` (undefined :: a -> b -> c)
07:29:55 <lambdabot>  f a b c = a (b c) c
07:29:58 <ion> @@ @djinn @type (<*>) `asAppliedTo` (undefined :: a -> b -> c)
07:29:59 <lambdabot>  f a b c = a c (b c)
07:30:44 <typoclass> dmwit: by Reader you mean ((->) a)?
07:30:51 <dmwit> I do.
07:31:30 <dmwit> typoclass: For Reader, there's a nice conversion between m (a -> b) and a -> m b, which is why (>>=) and (<*>) are so similar.
07:31:39 <parcs`> :t let f 5_6 = () in f
07:31:40 <lambdabot> forall t a. (Eq a, Num a) => a -> t -> ()
07:31:41 <typoclass> interesting!
07:31:50 <typoclass> thanks dmwit
07:32:23 <Chaze> what module is <*> in?
07:32:32 <Chaze> (i keep forgetting how to look that up with lambdabot)
07:32:33 <dmwit> parcs`: funny
07:32:43 <dmwit> _6 is one big identifier =)
07:32:46 <typoclass> Chaze: Control.Applicative (see link above) :-)
07:32:46 <bxc> control.applicative
07:32:59 <dmwit> Chaze: Here are two ways to look it up:
07:33:03 <dmwit> ?index (<*>)
07:33:03 <lambdabot> bzzt
07:33:06 <dmwit> ?hoogle (<*>)
07:33:06 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
07:33:13 <bxc> dmwit: but only one way works?
07:33:17 * bxc coughs
07:33:25 <dmwit> Sometimes one way works, sometimes the other. =)
07:33:36 <paolino> unamb
07:33:44 <dmwit> (Actually, Hoogle's database probably subsume's index's these days.)
07:35:55 <Jafet> So
07:36:11 <Jafet> > let (!)=flip const;(...)=flip const;be=id;doo=id;wah=id;woo=text"" in do be (do be) doo... do wah! do be doo! do wah! (woo)
07:36:13 <lambdabot>  Terminated
07:36:46 * sopvop hates cabal. Because 5 posts on reddit in 3 days about cabal is way too much.
07:36:55 <dcoutts> hah
07:38:51 <bxc> there seems to be a lot of cabal bashing going on at the moment
07:39:07 <bxc> people should be sent to 1990 to learn what they have.
07:39:14 <dcoutts> :-)
07:39:22 <dcoutts> but also some useful reflection I think
07:39:46 <nand`> “You shouldn't criticize this system! It could be so much worse”
07:39:49 <nand`> sure, but it could be so much better
07:39:59 <bxc> heh
07:40:01 <bxc> yeah
07:40:30 <typoclass> are they bashing 1.16 or older versions?
07:40:41 <bxc> i think in general (not haskell related) theres a mindset that packaging is easy ... it "just" needs to do this simple stuff ... which leads people to criticise. and also write their own package systems, but just do it right
07:40:55 <bxc> there's a programmer antipattern that is "I'm going to do X, but this time i'm going to do it right"
07:41:00 <bxc> that packaging systems seem to get.
07:41:07 <bxc> monitoring systems too.
07:41:31 <nand`> lots of people insist on creating their own package management systems for some reason
07:41:41 <nand`> these days all of the cool programming languages come with their own package managers
07:41:46 <bxc> nand`: because they have made the key realisation that they need to do it right.
07:41:49 <mapreduce> so does java
07:41:55 <bxc> nand`: if only everyone else had realised that when they wrote theirs.
07:42:07 <nand`> personally, I ignore all of those and do everything via my system's package manager. it works well
07:42:17 <parcs`> at one point i've had 310 packages installed via cabal with absolutely no breakage. what am i doing wrong?
07:42:21 <typoclass> bxc: i think it really applies to all kinds of software
07:42:30 <bxc> parcs`: i've only occasionally seen breakage
07:42:33 <nand`> parcs`: not updating enough? I guess
07:42:41 <bxc> parcs`: so I think you aren't alone
07:42:50 <typoclass> there's a bias towards trying some completely new shiny thing, instead of patiently improving with the existing thing
07:43:09 <nand`> if the existing approaches are dead on arrival that may be entirely justified
07:43:15 <bxc> one project i worked on, we built a new package manager basically because RPM didn't compile on cray.
07:43:23 <bxc> thats gotta be the worst reason ever.
07:43:24 <tac> parcs`: RE: What are you doing wrong. You're reading Reddit.
07:43:36 <nand`> like why spend money constantly maintaing some twice-ported visual basic abomination when you could rewrite it in Haskell
07:44:07 <typoclass> nand`: sure, it can be healthy, but i do feel it's often overdone (leading to waste)
07:44:23 <nand`> I think that's a consequence of differing opinions
07:44:27 <nand`> everybody has a different philosophy
07:44:34 <nand`> so to them, everything else looks wrong
07:46:05 <typoclass> nand`: yes that. plus too little ability to reach compromise or see someone else's point of view
07:47:05 <scp> Can I force GHCI to optimize code it is evaluating?
07:47:15 <scp> so I can interactively test -O2 speeds
07:47:46 <Jafet> You want highly optimized bytecode?
07:47:56 <Eduard_Munteanu> scp: ghci interprets so even with -O2 a comparison might not be fair
07:48:25 <Eduard_Munteanu> Also, some optimizations are turned off anyway.
07:48:30 <scp> ok, thanks
07:49:00 <parcs`> scp: you can compile a module with -O2 and then load it via ghci
07:49:46 <scp> parcs`, will just :l do that?
07:49:55 <scp> I mean, after Ive compiled it to .o form
07:50:04 <parcs`> yep
07:50:15 <parcs`> :l Foo, not :l Foo.hs
07:50:33 <scp> ok, thanks
07:50:48 <fmap> parcs`: probably you a) use latest cabal-install b) don't install packages one by one c) even read error messages and don't --force-reinstall blindly
07:53:05 <parcs`> fmap: guilty :(
07:53:17 <tac> hm
07:53:59 <thoughtpolice> copumpkin: hey! don't be endorsing my skills on the internets, don't you have a hurricane you're dealing with? all you guys ok?
07:54:05 <copumpkin> lol
07:54:11 <copumpkin> I'm the evil endorser
07:54:22 <copumpkin> nah, good weather here, and I don't think boston was hit that hard. I was in FL at the time, though
07:55:16 <rwbarton> it was more like "storm of the year" here, not "storm of the century"
07:55:19 <thirsteh> Is there a library for parsing HTTP time? (primarily RFC1123) to Data.Time.Clock.UTCTime? I found http://hackage.haskell.org/packages/archive/time-http/0.5/doc/html/Data-Time-Format-HTTP.html, but I have no clue how to use it, and ascii is deprecated
07:55:46 <thoughtpolice> copumpkin: ah, our offices in boston just said screw it and declared that they were closed for a few days, so we weren't sure how bad it was there
07:56:05 <thoughtpolice> just making sure your priorities weren't whack :P why were you in FL?
07:56:12 <JordiGH> Are Haskell function types not usually curried? I mean, when I see "Int -> Int -> Int -> Int", I have to mentally curry it myself?
07:56:30 <JordiGH> And think "(Int, Int, Int) -> Int"?
07:56:31 <thoughtpolice> oh, dear, and i didn't realize i was not in -blah
07:57:51 <fmap> JordiGH: that would be "mentally uncurry"
07:58:07 <copumpkin> JordiGH: why would you want to do that
07:58:09 <JordiGH> And I know that () shouldn't be there and that's a different type than the one with three arrows. I just wonder how you guys think about it.
07:58:10 <merijn> JordiGH: No, you should think of it as "Int -> (Int -> Int -> Int)"
07:58:12 <pnielsen> JordiGH: (Int -> (Int -> (Int -> Int)))
07:58:33 <merijn> JordiGH: As in, function that takes one Int and returns a function that...etc.
07:58:38 <JordiGH> copumpkin: Because I like to think of functions as taking in a number of input arguments and outputting something.
07:58:40 <parcs`> JordiGH: Haskell function types aren't usually curried because currying is more natural and probably more efficient
07:58:45 <copumpkin> JordiGH: then stop liking that :P
07:58:53 <nicoo> JordiGH: As a curryied functoin
07:59:13 <JordiGH> copumpkin: sorry, this is how I usually write functions in mathematics. I thought this language was supposed to appeal to me?
07:59:18 <merijn> JordiGH: For example, suppose I write just "map f", how would you think of that in your terms?
07:59:18 <nicoo> Number =1; output = potentially a function
07:59:20 <nicoo> Easy
07:59:36 <JordiGH> merijn: Is "map" a keyword? I'm barely starting to learn here.
07:59:37 <jmcarthur> JordiGH: the language is supposed to encourage a principled way of thinking about your code
07:59:48 <merijn> JordiGH: ah, no. Map is a function on lists
07:59:50 <merijn> :t map
07:59:52 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:59:57 <merijn> > map (+1) [1..10]
07:59:58 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:00:04 <copumpkin> JordiGH: the currying notion is trivial, and depending on your branch of math, you can deal with functions that return functions :)
08:00:08 <KBme> hi
08:00:09 <merijn> But I could just easily write:
08:00:10 <bxc> well how about (+) 1   as a different example
08:00:14 <JordiGH> copumpkin: Number theory?
08:00:14 <merijn> :t map (+1)
08:00:15 <jmcarthur> JordiGH: curried functions are no less mathematical than uncurried ones
08:00:15 <lambdabot> forall b. Num b => [b] -> [b]
08:00:16 <copumpkin> JordiGH: just replace f(x, y, z) with f x y z
08:00:17 <bxc> that doesn't involve knowing what is map...
08:00:30 <copumpkin> JordiGH: then nope, but isn't the goal to learn, too?
08:00:30 <JordiGH> jmcarthur: You don't usually worry about currying in most of mathematics.
08:00:33 <rwbarton> maybe 75% of the time you do want to think of Int -> Int -> Int -> Int as a function taking three Int arguments
08:00:44 <rwbarton> people here will valiantly claim otherwise
08:00:46 <jmcarthur> JordiGH: you don't have to *worry* about it in haskell either if you just learn to use it
08:00:56 <KBme> how would one do an algebraic datatype with a few string possible, like data Foo = "A" |  "B" | "C"?
08:01:00 <jmcarthur> JordiGH: it's much more convenient to use curried functions
08:01:21 <JordiGH> jmcarthur: Of course I have to worry it. I have to understand why it deduces the type as "int -> int -> int -> int" instead of "int, int, int -> int" or whatever.
08:01:52 <merijn> KBme: Either give one constructor per string i.e. "data Foo = A | B |C" or define "newtype Foo = Foo String" and then provide a safe constructor "foo :: String -> Maybe Foo"
08:01:58 <jmcarthur> JordiGH: code how you want. i've given my advice. it's your decision whether to ignore it.
08:02:05 <JordiGH> At any rate, fine, I'll get used to these wondrous strange new ideas, but I'll have to stop believing the propaganda that just because I like number theory or functional analysis I would also like Haskell.
08:02:12 <merijn> JordiGH: It deduces that, because that is the type
08:02:18 <KBme> ah, so I would then have data A = "A" ?
08:02:21 <KBme> hmmm, weird
08:02:26 <merijn> JordiGH: Are you familiar with lambda calculus?
08:02:30 <rwbarton> KBme: no
08:02:35 <rwbarton> Strings are Strings
08:02:40 <rwbarton> they cannot also be values of your type Foo
08:02:45 <copumpkin> JordiGH: just look a little past the syntax and it's almost identical, except more convenient
08:02:52 <copumpkin> I hope syntax isn't enough to make you not like it as a mathematician
08:02:59 <JordiGH> merijn: Yeah. I get it from that point of view. But I think the propaganda should be that Haskell appeals to people who like lambda calculus, not mathematics in general.
08:03:07 <KBme> hmmm
08:03:12 <copumpkin> there isn't propaganda
08:03:14 <copumpkin> we just like it
08:03:18 <merijn> JordiGH: There is not propaganda that haskell appeals to mathematics people
08:03:21 <copumpkin> loaded words are loaded
08:03:31 <merijn> JordiGH: Anyone who claims there is is misguided or trolling
08:03:32 <JordiGH> copumpkin: You might not be a propagandist, but there certainly is a lot of such advertising elsewhere on the web.
08:03:58 <Jafet> Now this is a line of trolling I haven't seen before
08:04:00 <KBme> so the haskell community is responsible for what a random person says on the internet
08:04:00 <copumpkin> JordiGH: it does appeal to many different kinds of mathematicians. Just because we write our functions a little differently isn't enough to put most of them off
08:04:05 <merijn> JordiGH: Most of the web is written by incompentent idiots, unfortunately. I wouldn't put so much stock in their correctness
08:04:08 <strg> the web can be wrong
08:04:15 <KBme> NOOO
08:04:16 <rwbarton> I don't like lambda calculus
08:04:24 <bxc> rwbarton: but its turing complete!
08:04:32 <copumpkin> bxc: not a lot of them
08:04:39 <JordiGH> Eh, guys, settle down, Haskell is great, sorry.
08:04:48 <strg> yay :)
08:04:54 <KBme> \☺/
08:04:54 * copumpkin hugs JordiGH 
08:05:02 <jmcarthur> JordiGH: you don't have to say haskell is great to appease us either
08:05:04 * nicoo hugs copumpkin and JordiGH 
08:05:15 <copumpkin> JordiGH: just give it a chance :)
08:05:19 * KBme hugs everyone
08:05:23 <nicoo> \o/
08:05:30 <hpaste> C pasted “type errors” at http://hpaste.org/77159
08:05:42 <jmcarthur> JordiGH: the upset is just the feeling of putting words in our mouths based on a few silly vocal people
08:05:45 <copumpkin> most of us have several complaints about it, but it's still enjoyable to use
08:05:47 <Chaze> can someone help me with those type issues? http://hpaste.org/77159
08:06:21 <rwbarton> KBme: "data Foo = A | B | C" means that the possible values of type Foo are A, B, and C
08:06:25 <johnw> Chaze: when faced with type errors, the first step toward sanity is to add type signatures for your functions
08:06:26 <rwbarton> that sounds like about what you want
08:06:43 <KBme> right, but the you have to define A no?
08:06:47 <KBme> hmmm
08:06:57 <merijn> Chaze: What's the type of trig and indexed?
08:06:57 <rwbarton> that is the definition of A
08:07:00 <Chaze> johnw: I've tried that already.
08:07:04 <merijn> Chaze: Or of anything in your code?
08:07:15 <rwbarton> it simultaneously defines the type Foo and the values (data constructors) A, B, and C
08:07:21 <Chaze> trig is a Floating a => a -> a
08:07:25 <Chaze> :t sin
08:07:26 <lambdabot> forall a. Floating a => a -> a
08:07:27 <KBme> rwbarton, so for my example…?
08:07:33 <merijn> Chaze: Adding signatures is not about fixing your problem, it's about us here knowing what the hell your code is doing
08:07:35 <rwbarton> what about it?
08:07:44 <KBme> data Foo = A | B | C
08:07:49 <KBme> data A = "A"
08:07:51 <rwbarton> no
08:07:52 <KBme> …
08:08:00 <Eduard_Munteanu> A is A.
08:08:02 <rwbarton> you are done after that first line
08:08:04 <typoclass> jmcarthur: it's not like what the channel said to him was level-headed or calm ("so we're responsible for all the web?", "they're all incompetent idiots")
08:08:05 <KBme> man, why am i not understanding this
08:08:09 <Chaze> alright, i will add signatures. the weird thing though is, that the code works in the REPL mode of ghci
08:08:14 <rwbarton> probably because it is different from C or whatever
08:08:51 <Jafet> typoclass: successful troll was successful
08:08:52 <merijn> Chaze: Did you accidentally import a Num instance for (a, a) in ghci, maybe?
08:09:21 <merijn> typoclass: Me calling the web incompetent idiots is about as levelheaded as I can be :>
08:09:23 <jmcarthur> typoclass: that's true
08:09:24 <merijn> SOP
08:09:25 <rwbarton> this issue also looks potentially MR-related though I didn't attempt to actually try to work out the types of anything
08:09:50 <Chaze> merijn: no, i keep restarting ghci
08:09:52 <KBme> MR-related?
08:09:56 <rwbarton> not yours
08:10:03 <KBme> rwbarton, was that adressed to me?
08:10:03 <rwbarton> Chaze's
08:10:06 <KBme> ah ok
08:10:07 <merijn> KBme: MonomorphismRestriction
08:10:13 <KBme> yeah, all right
08:10:29 <rwbarton> KBme: your issue is just "data Foo = A | B | C"-related. no more to say :P
08:10:47 <KBme> yeah, i was starting to worry ;)
08:10:49 <merijn> Chaze: You might also want to move the lambda you're mapping in sum_term to a helper function to clear up things
08:11:09 <Eduard_Munteanu> Yeah, I'd be worried too if my problem was <big words>-related. :P
08:11:10 <KBme> rwbarton, but then I have to instantiate Foo with A="A" … is that it?
08:11:10 <merijn> rwbarton: Well, that or a newtype if the number of constructors is to cumbersome to type out, but easy to check programmatically
08:11:28 <KBme> Eduard_Munteanu, heheheh
08:11:48 <rwbarton> KBme: nooooooooooooo
08:11:54 <KBme> gosh
08:11:59 <Eduard_Munteanu> KBme: when you define a datatype, you also define constructors. There's no more to it, you don't define a representation of those constructors.
08:12:12 <rwbarton> compare
08:12:13 <typoclass> Jafet: i think he was frustrated because he had picked up strange expectations. i don't think he came in here with malicious intent, or wanting to disrupt discussion. i don't think the term troll is justified
08:12:18 <rwbarton> @src Maybe
08:12:18 <lambdabot> data Maybe a = Nothing | Just a
08:12:22 <paolino> Jafet, he didn't come here for trolling
08:12:35 <Jafet> Well, he was trolling the last time he came here
08:12:36 <merijn> Chaze: oh duh
08:12:37 <Jafet> and in other channels
08:12:38 <KBme> but then how does this help me in creating a datatype that has a few possible strings as values?
08:12:41 <merijn> Chaze: Found your issue
08:12:43 <Jafet> and this time too
08:12:46 <rwbarton> that is the definition of Maybe and Nothing and Just. there is no other definition of what Nothing "is"
08:12:56 <Chaze> merijn: its something stupid, is it?
08:12:58 <rwbarton> KBme: you can't do that, as mentioned previously
08:13:02 <merijn> Chaze: "No instance for (Num ((a, a) -> a))"
08:13:11 <KBme> rwbarton, OH! i didn't catch that. ok.
08:13:11 <merijn> Chaze: What does sum_term return according to you?
08:13:12 <paolino> Jafet, ok
08:13:12 <Eduard_Munteanu> KBme: data Foo = A String | B Int; foo1 = A "Hello"; foo2 = B 5
08:13:26 <Chaze> merijn: complicated: sum_term :: (Double -> Double) -> [(Double, Double)] -> (Double, Double) -> Double
08:13:26 <rwbarton> < rwbarton> Strings are Strings
08:13:26 <rwbarton> < rwbarton> they cannot also be values of your type Foo
08:13:31 <bxc> KBme: you can make data Foo = A | B | C derving Show, Read; and then you can use 'show' and 'read' to convert to/from strings if you want
08:13:45 <bxc> KBme: but they won't be Strings themselves
08:13:53 <merijn> Chaze: Now look at this: "complexTerm = negate . (sum_term sin)"
08:14:03 <bxc> KBme: you'll be able to print them out and stuff like that though
08:14:09 <merijn> Chaze: Which we can rewrite as "complexTerm foo = negate (sum_term sin foo)"
08:14:22 <merijn> Chaze: "sum_term sin foo" has type...
08:14:24 <KBme> all right then. sorry for the misunderstanding, I was trying to understand something where there was nothing to understand
08:14:39 <typoclass> Jafet: before making those accusations, you could offer some evidence
08:15:16 <merijn> Chaze: Specifically, compare the types of negate and "sum_term sin foo" :)
08:15:24 <Chaze> merijn: yeah, i see my thinking error
08:15:34 <Chaze> i'm trying to negate at the wrong point in the computation
08:15:42 <Jafet> I liked his technique
08:15:48 <Jafet> It's not an accusation
08:16:24 <merijn> Chaze: Relatedly: since function application always beats operators you can drop the parenthesis around "sum_term sin" in the composition
08:26:09 <JordiGH> Classes are like proper classes in Von Neumann-Bernays-Gödel set theory, right?
08:27:06 * JordiGH keeps reading.
08:27:43 <merijn> I have no clue what those are, but I'm gonna say the almost is certainly "no"
08:27:57 <merijn> s/the almost/the answer almost
08:28:21 <JordiGH> Proper classes, i.e. not sets.
08:28:26 <lolcathost> IIRC, proper classes in set theory are "too big to be sets".
08:28:42 <lolcathost> And type classes have absolutely nothing to do with this.
08:28:56 <rwbarton> a type class could have no instances for example
08:29:12 <merijn> lolcathost: Props for the name :>
08:29:22 <JordiGH> They sound like they're defined by some sort of formula, which is analogous to VNBG classes.
08:29:59 <JordiGH> rwbarton: Right, the intensionality and extensionality of two classes need not coincide.
08:30:07 <merijn> ok, I'm to tired to be trolled like this, but A for effort. Time for beer...
08:30:45 <lolcathost> JordiGH: A type class is simply an assertion that there exist types which expose a certain interface (defined by the types of the exposed values/functions). A type class instance is a proof of this assertion.
08:31:07 <JordiGH> But it's just called "class" for fun, not because a mathematician came up with the word?
08:32:22 <typoclass> JordiGH: i don't know if they had any particular math concept in mind when they designed typeclasses
08:32:30 <mcstar> typecollection is longer
08:32:32 <nand`> edwardk: how efficient is a Top :> [a] :> a  zipper compared to something like ListZipper a?
08:32:40 <merijn> lolcathost, typoclass: I suspect you're wasting your time :)
08:32:41 <nand`> uh, Zipper a, from package ListZipper*
08:32:47 <JordiGH> Since this is sort of like generics in other programming languages, I would expect it to be something like the rejected "concepts" extension in C++11. Any generic type can go in here as long as it satisfies certain requirements. You're not actually using a logical formula to determine what those requirements are, right? A class in Haskell is just a set, explicitly enumerated?
08:32:50 <lolcathost> merijn: Yeah.
08:32:51 <edwardk> nand`: its basically the same thing
08:33:15 <lolcathost> Anyway, today I woke up in a good mood. I do not want to ruin it.
08:33:55 <rwbarton> JordiGH: yes to last two questions
08:34:00 <typoclass> JordiGH: typeclasses are similar to c++ concepts, from what little i know about concepts
08:34:02 <rwbarton> FSVO "set"
08:34:13 <JordiGH> rwbarton: "set" has no value, it's an undefined concept.
08:34:33 <rwbarton> set theory is not intended to be a model of Haskell
08:34:50 <rwbarton> so your question is ill-posed
08:35:11 <mcstar> rwbarton: i coined the acronym FSDO recently
08:35:15 <JordiGH> Yeah, just that 'FSVO "set"' sounds weird. Unless Haskell defines "set", unlike mathematics.
08:35:24 <nand`> edwardk: also, would it be reasonable to add versions of left/right that ‘wrap around’? basically; fromMaybe (leftmost z) (right z)
08:35:33 <typoclass> JordiGH: i think there's several possible definitions for 'set', but that doesn't mean the term is undefined or has no value
08:35:42 <edwardk> nand`: sure. bang one out
08:35:52 <JordiGH> typoclass: It's not defined in mathematics ZFC, but I suppose you can come up with another system in which set is defined.
08:35:55 <rwbarton> you are the one who used the term "set"
08:35:59 <edwardk> not sure what the best name would be though
08:36:07 <rwbarton> anyways, I just make this hedge because you can have instances parameterized by type variables
08:36:14 <nand`> ‘rightw’, ‘leftw’ are the most immediate I can think of, but ugly
08:36:16 <edwardk> wrapRight wrapLeft?
08:36:20 <JordiGH> rwbarton: Yeah, I wasn't expecting you to think it had some precise definition or value.
08:36:30 <edwardk> i don't use any one character manglings in lens. i'd like to keep it that way ;)
08:36:38 <edwardk> other than _ of course ;)
08:36:40 <rwbarton> rightwr
08:36:46 <edwardk> rwbarton: =P
08:36:49 <nand`> rightLoop; leftLoop?
08:37:13 <nand`> operator form: →∞
08:37:51 <nand`> cycleRight, cycleLeft?
08:38:38 <paolino> fixl
08:38:47 <edwardk> the assembly geek in me wants to use 'rol' and 'ror' but thats bad ;)
08:38:54 <nand`> @pl \z -> f (l z) (r z)
08:38:54 <lambdabot> liftM2 f l r
08:38:57 <nand`> ah
08:39:47 <edwardk> wrapRight and wrapLeft seem to suck the least
08:41:33 <uniquenick> is there not a reversed >> like there is with >>=?
08:41:51 <typoclass> uniquenick: how about << ?
08:41:53 <typoclass> :t (<<)
08:41:54 <lambdabot>     Not in scope: `<<'
08:41:54 <lambdabot>     Perhaps you meant one of these:
08:41:55 <lambdabot>       `=<<' (imported from Control.Monad), `<' (imported from Data.Ord),
08:42:05 <typoclass> oh great ...
08:42:08 <typoclass> @hoogle <<
08:42:08 <lambdabot> Control.Category (<<<) :: Category cat => cat b c -> cat a b -> cat a c
08:42:08 <lambdabot> Control.Arrow (<<<) :: Category cat => cat b c -> cat a b -> cat a c
08:42:08 <lambdabot> Control.Arrow (<<^) :: Arrow a => a c d -> (b -> c) -> a b d
08:42:09 <edwardk> <*
08:42:25 <typoclass> why doesn't it find it ...
08:42:26 <rwbarton> that's not exactly flip (>>) though
08:42:32 <uniquenick> yeah I guess << but didn't find one
08:42:36 <uniquenick> guessed*
08:43:01 <fmap> I would expect (<<) be infixr, but (<*) is infixl
08:43:13 <edwardk> true its not quite. (<<) was just running the effects right to left. but its seems to be gone these days
08:43:22 <edwardk> i don't miss it
08:43:35 <rwbarton> did it ever really exist?
08:43:40 <typoclass> it's gone? how weird
08:43:43 * hackagebot ghc-datasize 0.1 - Determine the size of data structures in GHC's memory  http://hackage.haskell.org/package/ghc-datasize-0.1 (DennisFelsing)
08:43:47 <rwbarton> maybe it was all a dream
08:43:54 <edwardk> not sure. could be imagining it ;)
08:44:28 <typoclass> rwbarton: i could have sworn i used it, but now you're making me doubt ...
08:54:24 <jmcarthur> i don't remember there ever being a (<<), just (<*)
08:55:47 <geekosaur> (<<) is something I expected to be there but wasn't
08:57:07 <mcstar> great, this welcomes me in my gmail account: "I'm trying out KDE after a long absense."
08:57:15 <mcstar> by Linus T.
09:00:13 <nand`> hmm
09:00:50 <nand`> I'm trying to think about how to best implement this: long story short I need to send data into the future and into the past simultaneously; while matching brackets
09:01:02 <nand`> if I find a ( I'll need data that I only know at the site of the closing )
09:01:09 <nand`> and if I find a ) I'll need data that I only know at the site of the opening (
09:01:23 <nand`> in short, each matching parenthesis ‘knows’ data from the other
09:01:44 <atriq> TardisT?
09:01:51 <nand`> yeah I thought about that
09:02:08 <nand`> just trying to figure out how I would implement the nesting and stuff correctly
09:02:10 <atriq> I'd love to see someone manage to actually use that for something useful
09:02:48 <bscarlet> nand`: I've done something similar w/ simultaneous use of StateT & RStateT
09:03:18 <typoclass> nand`: not sure what you're doing, but could the function when it sees "(" simply call itself recursively with some extra parameter, and return when it sees ")"?
09:03:28 <nand`> I'm parsing left to right; so doing it forwards should be no problem: just a usual stack inside a state, then pop from that on each closing
09:04:46 <nand`> typoclass: that may actually be possible
09:05:19 <typoclass> nand`: i just went for the simplest thing. sorry that it doesn't involve complicated monads ;-)
09:05:33 <nand`> I really, really wanted to find a use case for TardisT though :(
09:08:33 <bscarlet> nand`: sorry - just coming up to speed. I hadn't seen TardisT before. I rolled my own, but it worked just fine. My use case was computing about closed paths in graphics stuff. Each path was described by a sequence of points, and I needed the time travel to share information about the edge connecting the end to the beginning.
09:08:44 * hackagebot uuagc 0.9.42.0 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.42.0 (JeroenBransen)
09:10:50 <Philippa> bscarlet: yeah, it strikes me as a better way of talking about time travel than leaving it totally implicit
09:12:16 <bscarlet> Philippa: Sorry, I can't resolve the targets of your pronouns. What strikes you as better than leaving what implicit?
09:23:00 <nand`> nice
09:23:02 <nand`> typoclass: it works :)
09:24:01 <typoclass> nand`: oh cool. sometimes the simplest stuff is the best ... *if* it works for the problem
09:24:29 <nand`> not convinced it's as simple as it could be
09:24:32 <nand`> but it works
09:25:16 <hpaste> nand` pasted “Brainfuck parser, compiler and interpreter” at http://hpaste.org/77162
09:25:36 <nand`> have a look at my first iteration; I'm thinking about how to prettify it at this point
09:25:42 <nand`> I don't like the code bloat in the interpret function
09:25:46 <nand`> run*
09:27:37 <nand`> also not entirely sure it's correct
09:27:41 <nand`> haven't tested extensively
09:28:32 <beaky> hello
09:28:54 <beaky> > foldr (+) 0 [a,b,c,d,e]
09:28:55 <lambdabot>   a + (b + (c + (d + (e + 0))))
09:29:12 <beaky> > foldl (+) 0 [a,b,c,d,e]
09:29:13 <lambdabot>   0 + a + b + c + d + e
09:29:21 <beaky> > foldl' (+) 0 [a,b,c,d,e]
09:29:23 <lambdabot>   0 + a + b + c + d + e
09:30:53 <nand`> edwardk: it's also an example of both lenses and zippers :P
09:31:12 <typoclass> nand`: hey that looks nice
09:34:19 <mutjida> What do people mean when they claim attoparsec can't interleave parsing with effects?
09:34:22 <rwbarton> nand`: this is on a circular tape?
09:34:41 <nand`> rwbarton: yes, see wrapRight/wrapLeft
09:34:47 <nand`> circular zipper. Not very efficient. Probably
09:35:07 <rwbarton> not if you hit the leftmost/rightmost case often, yeah
09:35:14 <nand`> oh, I screwed up alignment on lines 74/75
09:35:27 <rwbarton> can you make it a finite but extensible tape?
09:35:49 <nand`> how about an infinite tape in both directions
09:36:03 <nand`> I'd be interested in how traversals handle those
09:36:08 <nand`> traversal-based zippers*
09:36:17 <rwbarton> i would assume that is easy but perhaps not as easy as i think
09:37:56 <nand`> ah, shame
09:38:00 <nand`> doesn't work out of the box
09:38:11 <nand`> zipper [0..] % fromWithin traverse % rights1 5 % focus .~ 10 % rezip -- ⊥
09:38:14 <typoclass> mutjida: i'm not familiar with attoparsec, but maybe it doesn't offer a monad transformer? then you couldn't stack it on top of IO. i think other libraries of the parsec family allow that
09:38:43 <beaky> is the haskell 'where' clause inspired by the SQL where clause?
09:39:02 <nand`> probably the miranda ‘where’ clause
09:39:14 <beaky> ah
09:39:35 <beaky> wouldn't it be cool if Haskell can embed SQL statements into things like listcomps
09:39:42 <beaky> and then send it to SQL
09:39:43 <nand`> it can, sort of
09:39:55 <beaky> sort of a language-integrated query
09:40:20 <scp> greetings haskellians
09:40:22 <nand`> there's a language extension that generalizes the actual list comprehension syntax (and adds a few more SQL-y forms to it like groupBy and whatnot)
09:40:25 <beaky> hello
09:40:37 <nand`> but apart from that, there's nothing stopping you from adding your own DSL for representing SQL expressions
09:40:49 <nand`> the syntax just won't be the same as in actual SQL
09:41:03 <nand`> but the queries will look pretty close
09:41:28 <scp> So, I've got a pretty good grasp of the basics of haskell at this point (i.e. I can write programs that work but I'm sure they could be written much better). I've read okasaki's "purely functional data structures" and "Learn you a haskell" cover to cover. Any pointers to more reading?
09:41:37 <typoclass> nand`: http://hpaste.org/diff/77162/77163 <- random untested ideas, not sure if it'll help :-) just for inspiration
09:41:38 <scp> specifically, I'm interested in program design in haskell
09:42:05 <scp> as opposed to, say, slightly  more theoretical aspects of language design etc..
09:43:08 <mutjida> typoclass: it doesn't offer a monad transformer, so there are some things you can't do, but you can lift it into a state transformer to get stateful parsing. you can also have it produce a monadic computation to get effects during parsing; however, using this approach, you can't use the result of a monadic action to influence the structure of the parser.
09:43:10 <typoclass> beaky: i thought 'where' was just mimicking english sentences or math speak. "blah blah x blah, where x means ..."
09:43:35 <typoclass> scp: you know about rwh?
09:43:38 <typoclass> @where rwh
09:43:38 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:43:46 * hackagebot ghc-heap-view 0.3.0.4 - Extract the heap representation of Haskell values and thunks  http://hackage.haskell.org/package/ghc-heap-view-0.3.0.4 (JoachimBreitner)
09:44:01 <typoclass> it's pretty practical. not sure if that is the sort of language design book you're looking for
09:44:11 <typoclass> mutjida: hmm right
09:44:56 <rwbarton> there was this blog post about esqueleto a while back
09:45:19 <rwbarton> "select $ from $ \b -> do { where_ (b ^. BlogPostAuthorId ==. val johnId) ; return b }"
09:45:25 <typoclass> nand`: just noticed, the diff view doesn't make it very clear, perhaps it's better to read http://hpaste.org/77162#a77163
09:45:37 <nand`> yeah
09:45:45 <nand`> I was confused by that
09:45:51 <c_wraith> Huh.  ghc-heap-view looks interesting.  But it needs a utility to output in graphviz format. I guess I have a project idea!
09:45:58 <mutjida> typoclass: perhaps it is specifically that last limitation that is meant by interleaving effects?
09:46:06 <nand`> here's my current version, I think I like that a bit more for clarity
09:46:25 <typoclass> mutjida: sounds plausible! but as i mentioned, i'm not really familiar with attoparsec :-)
09:46:44 <hpaste> nand` annotated “Brainfuck parser, compiler and interpreter” with “Brainfuck parser, compiler and interpreter” at http://hpaste.org/77162#a77164
09:47:57 <typoclass> nand`: right. i think the Skip case and the Loop case could be pulled out into a function, since they only differ in "p n" vs. "n p". i tried to do that
09:48:30 <typoclass> nand`: the other thing i tried to do is pull out ">> run n", since that seems common to all remaining cases except Read
09:48:48 <nand`> well, I think I'm satisfied with my current version
09:53:34 <nand`> hmm, here's an idea for an improvement: move from Stream Cell to [Cell] for input; and follow the semantics of EOF=0
09:54:06 <danharaj> does anyone know of declarative ways of defining GUI's that isn't FRP?
09:55:41 <nand`> I think there's an attempt at mixing diagrams with gtk
09:55:51 <nand`> but I could be hallucinating
09:56:16 <nand`> but that just covers GUI layout either way; I'd guess
09:57:37 <danharaj> getting logical dependencies between components to work out nicely seems hella painful.
09:57:58 <rwbarton> you are asking about specifying functionality, right. not just layout
09:58:05 <danharaj> right.
09:58:19 <danharaj> ideally layout could be built by traversing the graph that defines the functionality or something?
09:58:58 <danharaj> my current test case is: A display for an Int counter, a button that increments the counter, and a button that is disabled when the counter is 0, and otherwise resets the counter to 0.
10:00:41 <danharaj> unless I am really bad at frp (very plausible), that dependency between the event creator and the behavior that it affects is hairy to do and seems unscalable.
10:01:09 <nand`> all attempts at FRP I have seen have given me the impressions of “much more complicated than it ideally ought to be”
10:01:14 <nand`> for even simple demos
10:01:26 <aninhumer> Is there anything like the Bits class, but which only includes finitely representable types?
10:01:56 <nand`> I'd give it a shot with netwire just to see if I can learn netwire, but I don't know how to plug it into any GUI frameworks; I'm not sure I even have any functioning GUI frameworks
10:02:02 <nand`> I could give it a try with console input though
10:02:15 <nand`> but that wouldn't quite be the same thing as receiving button events, unless I fake i t
10:02:35 <callen> nand`: that's my impression as well @ FRP. I don't think it's worth it if your goal is to just "make a thing"
10:02:46 <aninhumer> I guess Bounded + Enum kind of allows what I want, but it's a bit awkward
10:02:50 <nand`> my goal is always to “make a thing”
10:02:53 <rwbarton> aninhumer: there was a discussion on libraries@ (I think) about this recently. so I think the answer is "not yet, but maybe in the future" if you are asking about in standard libraries
10:03:11 <rwbarton> http://www.haskell.org/pipermail/cvs-libraries/2012-September/016005.html
10:03:14 <nand`> everything else is in the domain of enterprise programming, where you spend less time on making things and more time on looking stylish
10:03:17 <callen> nand`: some people are tinkerers. *shrugs*
10:03:23 <danharaj> I am trying to write a gui on top of opengl, I find that all the examples of FRP rely on an outside library to handle all the event handling and display, and that's kind of the hard part.
10:03:32 <callen> nand`: enterprise software is anything but stylish.
10:03:46 * hackagebot couchdb-conduit 0.10.6 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.10.6 (AlexanderDorofeev)
10:04:00 <nand`> I didn't mean the software is stylish; I mean the programmers attempt to look stylish to their bosses while they produce said software; throwing around as many buzz words as they can
10:04:17 <aninhumer> rwbarton: Well, standard is nice, but I don't mind using a library
10:04:37 <rwbarton> in that case i don't know
10:04:47 <nand`> finitely representable?
10:05:15 <rwbarton> I assume aninhumer means fixed size
10:05:42 <nand`> I'm thinking something like ‘Storable’ (but maybe not as heavy) would be similar; since that's for “fixed size finitely storable” stuff
10:06:03 <nand`> + some fluff for pointers
10:06:23 <aninhumer> Yeah, I saw Storable, but it is a bit overkill for what I need
10:07:23 <aninhumer> I think I'll probably just go with Bits for now, it does at least declare bitSize
10:07:28 <aninhumer> Even if Integer doesn't define it
10:08:03 <callen> FRP seems like a nice alternative to callbacks sometimes, but I'm not convinced it's sufficient to make making a game not-painful. I'm actually kind of curious as to why making games in Haskell seems so roundabout.
10:08:09 <callen> because that uh...concerns me.
10:08:51 <nand`> I would mainly attribute it to a lack of libraries / work in that field
10:09:06 <nand`> speaking of which, how is haskell-arcade coming along?
10:10:18 <nand`> callen: imo the easiest way to ‘make a 2d game’ right now is via gloss
10:10:43 <nand`> haskll-arcade: no commits since 3 months ago :(
10:15:56 <jmcarthur> 3 months isn't that long
10:16:30 <DanielDiaz> that depends on what are you waiting for
10:17:31 <Sculptor> jmcarthur, how long did the jury deliberate
10:17:49 <kirindave> Ugh
10:17:52 <jmcarthur> DanielDiaz: <nand`> haskll-arcade: no commits since 3 months ago :(
10:18:11 <Sculptor> ah
10:18:39 <DanielDiaz> isn't that long then, right
10:20:32 <kirindave> Could someone help me figure out what I did wrong in defining StatementM?
10:20:33 <kirindave> https://gist.github.com/be2d9906798642db15a7
10:20:51 <kirindave> It's obvious that I did something wrong with my type synonym declaration
10:20:59 <kirindave> Maybe I'm missing an extension i should know?
10:21:13 <rwbarton> in this case you can just delete ' a' from both sides of line 6
10:21:40 <rwbarton> it's upset because you tried to pass a partially-applied type synonym to a type constructor
10:21:47 <kirindave> Hum
10:21:51 <kirindave> Isn't there an extension to allow that?
10:21:55 <kirindave> Not that I necessarily need tgo.
10:21:56 <geekosaur> nope
10:22:14 <geekosaur> ghc never allows partially applied type synonyms, as I understand it
10:22:20 <rwbarton> there is an extension that might sometimes let you pass a partially-applied type synonym to another type synonym, if the expansion of the latter would cause the former to become fully applied
10:22:53 <kirindave> Good to know. Thanks.
10:23:48 * hackagebot hat 2.7.0.3 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.3 (OlafChitil)
10:25:33 <beaky> how does haskel lcompare to prolog?
10:25:44 <nand`> (I haven't looked at your code) there's an extension LiberalTypeSynonyms which allows higher order type signatures
10:25:44 <nand`> but they're still not first class types
10:27:23 <kirindave> LiberalTypeSynonyms, that was it.
10:27:33 <kirindave> Doesn't matter, I was doing it wrong.
10:29:11 <nand`> haskell only runs in one direction
10:29:45 <bxc> i thought there was a future monad to allow things to run backwards?
10:29:59 <rwbarton> they have almost nothing in common
10:30:01 <rwbarton> only the letter 'l'
10:30:31 <geekosaur> prolog is a logic language; there are some conceptual similarities, but not a lot.  the closest thing to prolog in haskell is functional dependencies, I think
10:30:43 <yawning> do the haskell web frameworks automatically treat all io asynchronously?
10:30:59 <beaky> prolog and haskell pattern matching similarly
10:31:22 <Philippa> not really: prolog doesn't pattern match, it unifies
10:31:23 <beaky> O.o prolog and haskell seem to have similar pattern-matching mechanisms*
10:31:34 <beaky> ah unification
10:31:36 <Philippa> much more powerful mechanism, that
10:32:02 <beaky> wouldn't it be cool if Haskell had that?
10:32:05 <Philippa> Haskell just asks "are these things equal?" and then binds, Prolog treats it as an equation that has to hold instead
10:32:14 <Philippa> it's not hard to write unification for a single type
10:32:16 <otters> @pl \_ o -> f o
10:32:17 <lambdabot> const f
10:32:45 <nand`> goes both ways
10:32:49 <nand`> haskell only goes in one way :(
10:32:49 <nand`> beaky: you can implement unification in haskell
10:32:49 <nand`> so I don't see much of a drawback from either system
10:32:55 <beaky> ah
10:33:14 <callen> nand`: interesting @ gloss. I have to wonder why there aren't nice high-level game programming libraries like this for C++.
10:33:28 <callen> nand`: being able to write a game like this at a high-level in C++, where you could drop down to a lower-level at will, would be amazing.
10:33:29 <Philippa> nand`: well, there're some neat things we'd get if our variables were logic variables at least, but it's definitely a different kind of system
10:33:30 <beaky> http://en.wikipedia.org/wiki/Unification_%28computer_science%29#Type_inference it says Haskell also uses unification
10:33:58 <Philippa> beaky: strictly speaking, unification is /one way to implement/ that part of the type system
10:34:07 <Philippa> (but historically at least, it's what GHC does)
10:34:20 <Ralith> what other ways are there?
10:35:23 <beaky> giant switch statements
10:35:28 <nand`> brute force
10:36:32 <Philippa> decomposing constraints that resolve themselves
10:36:43 <Philippa> (yes, that's in some sense equivalent, but that's also what you asked for)
10:37:12 <Philippa> FWIW: it's well worth reading a bit about logic programming in languages other than Prolog - Oz and Mercury are worth knowing a bit about
10:37:39 <nand`> callen: you can drop down to a lower level with gloss, it has an IO-y version
10:37:47 <filkr> Question: I have a data constructor that needs about 30 fields. Let's say it's called Foo. If I make a function of type Foo -> Int, is there any way to extract part of Foo without pattern matching on every single field (i.e. Foo _ _ _ .... x ...  _ _ _ = 9)
10:37:52 <beaky> is logic programming even more mindblowing than functional programming?
10:37:59 <rwbarton> how about you try it and find out
10:37:59 <Ralith> not really
10:38:05 <Ralith> but listen to rwbarton
10:38:17 <beaky> right
10:38:29 <Ralith> such qualification is subjective, after all
10:38:30 <rwbarton> filkr: record syntax
10:38:49 <filkr> rwbarton: thanks, I'll look that up
10:38:50 <mcstar> also, i dont think it works for 30 fields
10:38:50 <rwbarton> i.e. declare Foo with record syntax
10:39:01 <mcstar> for 29 and 31 i know it does, but for 30, who knows
10:39:57 <filkr> Whaaa
10:40:31 <Philippa> I find logic programming interesting and useful but less mindblowing as such - if you squint slightly it's a form of metaprogramming around FP
10:42:26 <Philippa> logic programming leads to constraint programming which is well worth understanding
10:43:13 <Philippa> I suspect at the moment my ideal 'base language' would be something akin to Haskell-with-logic-variables, which I guess leads to one of my interests in Contextual Modal Type Theory
10:43:21 <Philippa> anyone suffering from info overload yet? :-)
10:44:17 <djahandarie> I've looked into constraint programming, but I wasn't particularly impressed for some reason. Is there a nice theory which wraps it up nicely with functional programming? I've seen it used in conjunction with imperative programming only.
10:44:58 <Philippa> djahandarie: ah, ouch. You can view constraint functional programming as a subset of constraint logic programming, if that helps?
10:45:15 <Philippa> something like Oz's approach is at least not utterly incompatible with FP
10:45:46 <djahandarie> I'll take a look at Oz.
10:45:50 <Philippa> (I end up building monads and applicatives that build constraint sets, and whether solving happens as constraints are added or later is an 'it depends')
10:46:03 <Philippa> CTM's chapter on it's probably worth a read if you can get your hands on a copy
10:46:09 <osa1> in "fun with functional dependencies" paper, in "functions" part (3.2.3), do I have to use "UndecidableInstances" or am I doing something wrong ?
10:46:20 <osa1> because code in that part doesn't work for me with just FunctionalDependencies
10:47:08 <Saizan> Contextual Modal Type Theory sounds like something i should've read about before implementing pattern unification
10:48:10 <Philippa> heh. Yeah, guess which paper I found the reference to it in? :-)
10:48:37 <Saizan> hah, Abel's ? :)
10:49:10 <Philippa> agundry's, but hey
10:49:11 <beaky> is foo >> bar equivalent to foo >>= \_ -> bar ?
10:49:19 <Philippa> beaky: yep
10:49:24 <beaky> :t (>>)
10:49:26 <lambdabot> forall (m :: * -> *) a b. Monad m => m a -> m b -> m b
10:49:28 <atriq> beaky, unless someone's defining evil Monad instances
10:49:29 <Philippa> or at least, any time it isn't the Monad instance is broken
10:49:39 <c_wraith> osa1: yeah, that will require undecidable instances
10:49:53 <beaky> evil Monads are monads that don't satisfy the monad laws?
10:49:58 <osa1> c_wraith: strange, it isn't mentioned in the paper
10:50:00 <atriq> Yes
10:50:17 <c_wraith> osa1: the paper was written for people who understand that extension already. :)
10:52:19 <osa1> c_wraith: so where can I learn what causes the need for UndecidableInstances for that code ?
10:53:08 <osa1> c_wraith: if I delete "| n -> b" part it works without UndecidableInstances, I have no idea ..
10:54:34 <c_wraith> osa1: UndecidableInstances is for when the compiler can't tell that instance searches will terminate. That usually means that there's an instance declaration with a fully polymorphic element in the head.
10:55:09 <osa1> c_wraith: hmm, in that case that polymorphic variable in the head is "b", is it correct ?
10:55:16 <c_wraith> osa1: yes
10:55:28 <osa1> c_wraith: but why does it work if I delete "| a->b" part ?
10:55:39 <c_wraith> osa1: I'm not sure about that part. :)
10:55:52 <osa1> ;-(
10:58:21 <lispy> edwardk: sorry it took me so long to follow up with SPI
10:58:33 <hpaste> osa1 pasted “UndecidableInstances question” at http://hpaste.org/77166
10:58:56 <osa1> ok so I pasted my question: http://hpaste.org/77166 can anyone help ?
11:04:44 <startling> I've got a tree. I want to perform some monadic operation on each leaf and some monadic operation on each branch. What kind of traversal would capture this operation?
11:05:00 <startling> by "tree" I mean "possibly-nested map"
11:05:21 <fmap> osa1: are you sure? pasted code works for me without -XUndecidableInstances
11:06:18 <osa1> fmap: yes, the code below doesn't work without UndecidableInstances
11:07:45 <Philippa> startling: sounds like a monadic fold to me, though I haven't poked around Hackage recently looking for good libs for such things
11:08:12 <startling> Philippa: hmm, yeah, it does
11:08:14 <fmap> oh, I see, ghci problems
11:08:45 <jmcarthur> startling: make it an instance of Foldable/Traversable?
11:09:05 <rwbarton> i think basically the answer is that the termination checker is not very smart about functional dependencies
11:09:11 <osa1> fmap: ghci problems ? I haven't tried it with ghc. does their type checker work different ?
11:09:22 <jmcarthur> startling: it depends on if you actually want access to those constructors or just to some elements you are storing there
11:09:35 <startling> jmcarthur: I've already got those, but traverse doesn't touch the branches, only the leaves
11:09:46 <jmcarthur> startling: ah, so you only have "elements" at the leaves
11:09:48 <startling> I can try to hack around it, but then I don't get anything done for empty branches.
11:09:57 <startling> jmcarthur: yeah, should have clarified
11:10:21 <S11001001> startling: if you need branches as well as their leaves you need monad
11:10:23 <jmcarthur> yeah i think you basically just want a monadic fold then
11:10:25 <startling> It's newtype Tree a b = Map a (Either b (Tree a b))
11:10:41 <startling> S11001001: a monad instance for the tree?
11:10:57 <jmcarthur> i don't think startling is after that
11:11:21 <startling> I don't think there's a valid monad instance for my type.
11:11:35 <jmcarthur> if you were using a total map it would be a valid monad
11:11:55 <rwbarton> or if you switch the order of Either and Map
11:12:06 <jmcarthur> ah, indeed
11:12:44 <startling> yeah, but then most of my operations would be partial and I couldn't have a Monoid instance. :/
11:13:04 <jmcarthur> you can lift Monoid via Applicative
11:13:30 <Cale> startling: what's the type of the *result* of your operation? That would tell you something important.
11:13:57 <startling> Cale, m () I guess
11:14:08 <Cale> startling: If it's a monadic computation with an arbitrary result, then you can factor your operation through one of the operations like mapM which works on lists.
11:14:50 <Cale> (Just write a traversal which flattens the thing into a list of appropriate data to be iterating over)
11:15:30 <fmap> osa1: nope, my ghci has undecidable instances enabled by default and I forgot about it
11:16:01 <fmap> osa1: actually, ghc says why does it need -XUndecidableInstances, the problem is Coverage Condition
11:16:22 <fmap> osa1: this question http://stackoverflow.com/questions/11959764/what-is-the-coverage-condition might be interesting
11:16:27 <osa1> fmap: thanks
11:16:43 <startling> Cale, that might work, thanks
11:16:54 <startling> I'm not sure how I would preserve empty branches in a list version, though
11:17:20 <Cale> Well, it depends on exactly what you flatten it into
11:17:39 <Cale> If you go all the way to [a], then maybe that's too far
11:17:45 <parcs`> > sqrt ((3 + sqrt 5) / 2)
11:17:46 <lambdabot>   1.618033988749895
11:17:47 <startling> yeah. I guess (path, Maybe element) could work.
11:17:51 <Cale> right
11:17:55 <parcs`> > (1 + sqrt 5) / 2
11:17:57 <lambdabot>   1.618033988749895
11:18:00 <fmap> osa1: basically, every instance in form `Odd X b' should have `b' in `X'
11:18:11 <fmap> (to be decidable)
11:18:14 <startling> but I'm still not sure how I would reach the branches with a traversal at all.
11:18:27 <fmap> (same for Even)
11:18:27 <parcs`> > 1 + sqrt ((1 + sqrt 5) / 2)
11:18:28 <lambdabot>   2.272019649514069
11:19:20 <Cale> startling: well, first of all, you can apply Map.toList
11:19:40 <startling> Cale, oh, I could do that repeatedly.
11:19:46 <Cale> startling: right
11:19:53 <startling> interesting.
11:19:58 <kwilcox> Hey there, I have a question about the difference between GHC and GHCi / runhaskell. I have a problem that's running an astar search, and I'm seeing the following inexplicable behavior: if I compile my code and pass it an equation to solve, it fails for a large number of starting equations. However, if I run the code in ghci or run the Main.hs file using runhaskell, it works just fine.
11:20:11 <kwilcox> s/problem/program
11:20:17 <startling> It might be worth writing a) traverse all the leaves at this level and b) traverse all the branches at this level functions
11:20:27 <Cale> kwilcox: odd...
11:20:38 <osa1> fmap: but only if I have "| n -> b" in my class, is it correct ?
11:20:39 <kwilcox> Yeah, that's what i thought
11:20:43 <Cale> kwilcox: One difference is that GHCi has been compiled with the threaded runtime
11:20:57 <Cale> kwilcox: But I'm not sure what difference that makes to your situation.
11:21:04 <kwilcox> I'm compiling with the -threaded runtime as well
11:21:07 <Cale> hmm
11:21:17 <kwilcox> this is in my cabal file:
11:21:18 <kwilcox> if impl(ghc >= 6.12.0)
11:21:19 <kwilcox>       ghc-options: -threaded -Wall -fwarn-tabs -funbox-strict-fields -O0
11:21:20 <kwilcox>                    -fno-warn-orphans -fno-warn-unused-do-bind
11:21:21 <beaky> what should I do if readLn fails to parse input from stdin?
11:21:24 <kwilcox> and I'm using ghc 7.4.1
11:21:32 <kwilcox> (or rather, the latest haskell platform release)
11:22:11 <fmap> osa1: yep, it's defined only for fundeps
11:22:12 <rwbarton> "-funbox-strict-fields -O0" is an interesting choice
11:22:18 <Cale> beaky: You can catch the exception, or you might prefer to use reads instead, to get a list of the parses, and handle the empty case (or the case where there was extra input left over)
11:22:18 <kwilcox> hehe
11:22:19 <kwilcox> my bad
11:22:23 <kwilcox> I was at O2
11:22:34 <beaky> Cale: the reads one seems more elegant
11:22:35 <kwilcox> was experimenting to see if messing with the compilation optimization settings would fix it
11:22:51 <rwbarton> i see
11:22:55 <rwbarton> makes senes
11:22:58 <rwbarton> sense, even
11:23:46 <rwbarton> does your program actually use threads?
11:24:01 <kwilcox> So, it does, but even removing the threaded usage doesn't seem to change the behavior
11:24:06 <kwilcox> I'm using timeout
11:24:18 <kwilcox> to ensure that if it searches for more than 3 seconds, I return Nothing
11:24:27 <kwilcox> I've tried cranking it to 60 though
11:24:29 <kwilcox> and it doesn't change anything
11:24:29 <rwbarton> is that the sense in which it fails?
11:24:36 <kwilcox> well, sorry, fails to find an answer
11:24:46 <kwilcox> (it's an equation solver)
11:24:55 <rwbarton> "it fails for a large number of starting equations" meaning you hit this timeout?
11:25:03 <rwbarton> or something else
11:25:06 <kwilcox> yes
11:25:07 <kwilcox> that
11:25:14 <kwilcox> But raising the timeout seems to have no effect
11:25:24 <kwilcox> I.e. - knocking it to 60s doesn't make any difference
11:25:43 <kwilcox> Same with removing the timeout entirely - just having it execute the search is also failing to complete when it's compiled
11:25:47 <kwilcox> but succeeding for ghci or runhaskell
11:26:19 <atriq> ghc -threaded?
11:26:27 <kwilcox> yup
11:26:44 <atriq> How is it outputting?
11:26:53 <kwilcox> I'm using an implementation of AStar based roughly on the one on hackage
11:27:07 <kwilcox> sorry, atria, you mean how does it output the final result?
11:27:10 <rwbarton> is it using 100% cpu?
11:27:16 <atriq> Yes
11:27:22 <S11001001> startling: I mean that your traversal must operate in some monad, not an applicative, so traverse won't do
11:27:24 <atriq> Yes, that is what I meant
11:27:32 <kwilcox> right now, the base case I had was outputting via print
11:27:36 <kwilcox> But
11:27:53 <kwilcox> it usually is running behind a json endpoint using snap
11:28:00 <atriq> Hmm
11:28:06 <atriq> Not a silly buffering problem
11:28:06 <kwilcox> I thought it was Snap at first that was causing the issue, but I managed to knock that out, and still it fails
11:28:09 <kwilcox> yeah
11:28:18 <kwilcox> let me check about the cpu pegging now
11:28:39 <kwilcox> no
11:28:41 <kwilcox> cpu isn't pegged at all
11:28:48 <startling> S11001001: ah, makes sense
11:28:50 <kwilcox> well wait
11:28:55 <kwilcox> no, that's not true. it's pegging one cpu
11:28:58 <Philippa> kwilcox: that's a baaad mental image there
11:29:11 <beaky> why does 'getLine >>= reads' not work?
11:29:19 <kwilcox> Phillipa: <laughs>
11:29:29 <kwilcox> with 3 threads
11:29:33 <roadfish> Just starting Haskell today. Is it true that you can't define functions at the interactive prompt? That you _must_ do a :l filename to load in functions?
11:29:53 <beaky> you can define functions using 'let'
11:29:56 <Philippa> :t reads
11:29:57 <lambdabot> forall a. Read a => ReadS a
11:29:58 <rwbarton> kwilcox: I suppose you could try building with profiling and run with time profiling or heap profiling
11:30:08 <beaky> > let f x = x * x -- defines a function f
11:30:10 <lambdabot>   not an expression: `let f x = x * x -- defines a function f'
11:30:11 <Philippa> did you want read?
11:30:13 <beaky> :(
11:30:14 <roadfish> beaky:thanks
11:30:15 <S11001001> startling: and your f looks like a -> m b and Tree b -> m (Tree b) (for post order) instead of a -> m b
11:30:15 <rwbarton> then ctrl-c the program after running for a while and see if you can notice anything odd in the profiling output
11:30:21 <typoclass> roadfish: hello, you can use "let f x = x*2" for example. it's really only useful for one-liners, however
11:30:27 <Philippa> beaky: that only works inside a do statement
11:30:31 <beaky> ah
11:30:35 <Philippa> otherwise you need the 'in' part and a body for it
11:30:46 <beaky> > let f x = x * x in f 3
11:30:47 <lambdabot>   9
11:30:50 <kwilcox> rwbarton: Actually, i've been having some real issues with that, might you be able to help me set it up?
11:30:55 <rwbarton> ok
11:30:57 <beaky> in ghci, everything is in a do
11:31:05 <kwilcox> so, in my ghc options in the cabal file
11:31:09 <typoclass> Philippa: i tried it the other day in ghci, it works nowadays (one line "let", another line with the call)
11:31:09 <srhb> beaky: Sort of.
11:31:15 <kwilcox> I've added -prof and -auto-all
11:31:30 <Philippa> typoclass: right, ghci is in a do statement effectively (but fair enough, I should've mentioned that explicitly)
11:31:32 <rwbarton> add -rtsopts too
11:31:33 <kwilcox> Anything else i should add to the cabal file before building?
11:31:37 <kwilcox> -s?
11:31:57 <rwbarton> hmm?
11:32:21 <rwbarton> build with -prof -auto-all -rtsopts and then run with +RTS -p or +RTS -xc or other options
11:32:45 <kwilcox> ahhh - i get it. thought you had to pass options to -rtsopts, didn't realize it just turned them on...
11:33:02 <rwbarton> there is also -with-rtsopts for that
11:33:06 <clahey> beaky: Even if you wanted read, it's still the wrong signature.
11:33:07 <clahey> :t read
11:33:08 <lambdabot> forall a. Read a => String -> a
11:33:16 <clahey> :t read <$> getLine
11:33:17 <lambdabot> forall b. Read b => IO b
11:33:22 <kwilcox> getting the following compilation error:
11:33:24 <kwilcox> Perhaps you haven't installed the profiling libraries for package `aeson-0.6.0.2'?
11:33:28 <rwbarton> oh
11:33:35 <kwilcox> i have my global cabal config
11:33:37 <beaky> getLine >>= readIO
11:33:42 <kwilcox> set to Profile: False i think
11:33:43 <beaky> :t getLine >>= readIO
11:33:44 <Philippa> clahey: point, shows how awake I'm not
11:33:44 <lambdabot> forall b. Read b => IO b
11:33:49 <clahey> :t readIO
11:33:50 <lambdabot> forall a. Read a => String -> IO a
11:33:54 <rwbarton> library-profiling:
11:34:29 <kwilcox> -- library-profiling: True
11:34:31 <beaky> should I use read <$> getLine or getLine >>= readIO ?
11:34:31 <clahey> @src IO fail
11:34:32 <lambdabot> fail s  = failIO s
11:34:33 <kwilcox> is commented out right now
11:34:37 <clahey> @src failIO
11:34:37 <lambdabot> failIO s = ioError (userError s)
11:34:37 <kwilcox> uncomment it?
11:34:42 <kwilcox> (and do i need to reinstall anything?)
11:34:54 <ion> beaky: readLn
11:34:55 <clahey> beaky: It depends on how you want it to handle parse errors.
11:34:58 <rwbarton> yeah unfortunately that means you need to reinstall what i assume is a bunch of packages
11:35:07 <kwilcox> hehe. no problem. i've already blown it away 3 times this morning
11:35:09 <rwbarton> oh ok
11:35:16 <kwilcox> so i'm used to it ;0
11:35:30 <kwilcox> do i uncomment that in config, or config.platform, or both?
11:35:32 <rwbarton> "cabal install world --reinstall" might do the trick for you, if not, you can blow away again :)
11:35:38 <clahey> beaky: But as ion said:
11:35:41 <clahey> @src readLn
11:35:42 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
11:35:48 <kwilcox> :)
11:35:53 <rwbarton> i don't know what config.platform is
11:36:02 <kwilcox> hehe. I assume it's something to do with haskell-platform
11:36:02 <clahey> readLn = getLine >>= readIO
11:36:07 <kwilcox> I'll set it to true on both
11:36:07 <aninhumer> Hmm, why is there no instance Bits Bool?
11:36:18 <clahey> Does anyone know why readLn is written in do notation?
11:36:25 <beaky> do notation ftw
11:36:33 <rwbarton> hopefully your haskell platform includes profiling libraries
11:36:54 <ion> aninhumer: The same reason there’s no instance Num Bool.
11:37:03 <beaky> :t reads
11:37:04 <lambdabot> forall a. Read a => ReadS a
11:37:54 <Eduard_Munteanu> clahey: not sure what you mean, they could've used that, or >>= I guess.
11:37:55 <rwbarton> looks like Bits lots its Num superclass in 7.6 though
11:38:33 <ion> I’m not talking about a dependency, i’m talking about whether it makes sense for Bool to be either Num or Bits.
11:38:34 <rwbarton> wow, the actual readLn source uses layout! amazing
11:38:47 <clahey> Eduard_Munteanu: When I did @src readLn, it came back in do notation.  That's all.
11:39:00 <rwbarton> surely it does make sense for Bool to be Bits
11:39:21 <clahey> Eduard_Munteanu: I don't really care, I was just curious if there was some important reason.
11:39:28 <Philonous> Is it possible to have patterns that spawn multiple lines? Like case foo of [ abc, \n def] -> ... ?
11:39:38 <clahey> rwbarton: The reason it needed Num that I saw was so that it could get a 0.
11:39:49 <kwilcox> k, reinstalling from scratch, rwbarton
11:39:55 <aninhumer> I guess technically for my purposes at the moment, all I really need is a function a -> BitVector
11:39:56 <kwilcox> I'll let you know when it's finished
11:40:12 <rwbarton> with "cabal install world --reinstall"?
11:40:13 <lispy> edwardk: ping
11:40:21 <rwbarton> or actually from scrath
11:40:24 <clahey> ion: Why wouldn't it make sense for Bool to be a Bits?
11:40:26 <sclv_> Philonous: pretty sure you can as long as you respect layout
11:41:10 <aninhumer> But yeah, I don't really see why Bool can't be Bits, it makes far more sense than Integer tbh
11:41:26 <beaky> http://ideone.com/gRt9Pw is there a clean way for me to handle getLine receiving EOF
11:41:28 <ion> How are shift, rotate, testBit et al. meaningful functions of a truth value?
11:42:05 <aninhumer> ion: shift and rotate aren't, testBit is useful for generalising
11:42:22 <ion> And if you say it’s also an integer in a mod-2 algebra, then it also makes sense for it to be Num.
11:42:24 <rwbarton> honestly i don't see much point in drawing a distinction between "truth value" and "sequence of truth values of length 1" so those all seem fine to me
11:42:30 <rwbarton> i wouldn't say that
11:43:08 <aninhumer> An integer in mod2 is clearly different from a Boolean, if isomorphic
11:43:32 <aninhumer> Whereas Bits is more of a representation thing
11:43:44 <Philonous> sclv_:  Ah, thanks, works with enough indentation(TM)
11:43:47 <clahey> Yeah, a Bits is an array of bits.
11:43:48 <aninhumer> And clearly, Bool has a representation as Bits
11:44:01 <clahey> A Bool is a array of 1 bit.
11:44:31 <kwilcox> from scratch. was getting dependency issues trying to reinstall world
11:44:37 <rwbarton> ah :(
11:44:41 <rwbarton> well, useful data point for me, thanks
11:45:41 <beaky> how do I do logical negation in Haskell?
11:45:46 <beaky> > not True
11:45:48 <lambdabot>   False
11:45:53 <copumpkin> @djinn a -> Not (Not a)
11:45:54 <lambdabot> f a b = b a
11:45:57 <beaky> > ! True
11:45:59 <lambdabot>   <hint>:1:7: parse error (possibly incorrect indentation)
11:46:02 <beaky> :(
11:46:26 <parcs`> > let (!) = not in (! True)
11:46:27 <lambdabot>   The operator `(!)' takes two arguments,
11:46:27 <lambdabot>  but its type `GHC.Types.Bool -> GH...
11:46:27 <ion> > let (!) = not in (True !)
11:46:28 <lambdabot>   False
11:46:34 <S11001001> beaky: what's wrong with not
11:46:58 <typoclass> ion: that needs that one postifx extension to be on, doesn't it
11:47:21 <ion> yes
11:48:32 <Philonous> typoclass:  Wait, that's actually supposed to work? Does the parsing depend on the type, then?
11:49:11 <startling> woah what?
11:49:19 <S11001001> typoclass: pointless desugaring?
11:49:32 <startling> you mean my css thing could have 12% rather than percent 12 ???
11:49:45 <rwbarton> if you put it in parens
11:49:51 <rwbarton> has to be (12%)
11:50:02 <startling> still not bad. neat.
11:50:11 <Philonous> Horrible
11:50:18 <Philippa> beaky: surely bang would be a synonym for launchMissiles?
11:50:21 <typoclass> Philonous: no, it's nothing complicated, ghc just allows an operator with one argument, as in "(True !)" or "(True +++)" or whatever
11:50:22 <rwbarton> {-# LANGUAGE PostfixOperators #-} (%) = percent
11:50:53 <rwbarton> the idea is (x &) normally means \y -> x & y or \y -> (&) x y
11:50:57 <Philippa> so like a section where it doesn't bother checking it's a >=2 parm function?
11:50:59 <rwbarton> but this can be eta-reduced, to (&) x
11:51:15 <startling> Philonous, parsing already depends on infix declarations
11:51:18 <rwbarton> that generalizes the type which is why it is controlled by an extension
11:51:38 <typoclass> eta-shmeta, it just means (True !) is the same as ((!) True)   ;-)
11:51:44 <plotr> anyone seen (an interface has a type 113 different from the type of the first interface) while working with Network.Pcap?
11:51:50 <rwbarton> well that is the end result yes
11:51:56 <Philonous> typoclass:  Ah, of course. Somehow I was thinking that it would have to flip the operator, but since it's postfix it's already in the right oder
11:52:05 <Philonous> order*
11:52:35 <typoclass> http://www.haskell.org/ghc/docs/6.8.1/html/users_guide/syntax-extns.html#postfix-operators <- here's the documentation by the way. it's short and simple
11:53:11 <rwbarton> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/syntax-extns.html#postfix-operators if you want a version from this decade
11:53:15 <Philonous> typoclass:  Didn't it even use to work due to a bug in ghc?
11:53:28 <typoclass> Philonous: no idea :)
11:53:45 <rwbarton> the 6.8 version looks like basically a "documented bug"
11:54:11 <typoclass> rwbarton: yeah sorry, i only noticed after i posted. my kingdom for someone who makes google ignore all the old haddocks and user guides
11:54:19 <rwbarton> yeah...
11:54:45 <typoclass> ('my kingdom' in the sense of a moist handshake and possibly a beer)
11:55:01 <beaky> http://ideone.com/W1a9SN anyone want to criticize my code? :D
11:55:25 <filkr> Question: I'm using both lists and vectors in my code (Prelude && Data.Vector). Do I really have to now prefix every function call with P or V? (i.e. P.length vs V.length)
11:56:19 <typoclass> filkr: no, you don't have to. you can prefix the vector functions with V and just keep Prelude as normal (no prefix), or vice versa
11:56:39 <filkr> typoclass: I tried to do that, but it tells me constantly that it has ambiguous naming
11:56:45 <filkr> typoclass: I did import Data.Vector as V
11:57:32 <rwbarton> import qualified Data.Vector as V
11:57:33 <typoclass> filkr: try "import qualified Data.Vector as V". your import line means "names from Data.Vector will be available as 'V.something' and also as 'something'"
11:57:51 <filkr> Okay, so the "qualified" makes it only work under V, got it
11:58:08 <typoclass> filkr: yup, exactly :)
11:58:18 <Philonous> beaky:  I'd say "prompt" needs some newlines. Either go for hanging lambdas (foo >>= \n \x -> ...) or do notation
11:58:35 <filkr> typoclass, rwbarton: Thank you
11:58:42 <beaky> right
11:58:54 <Philonous> beaky:  Err, sorry, I meant "foo >>= \x -> \n ..."
11:59:03 <plotr> Network.Pcap anyone?
11:59:05 <beaky> why does reads return a singleton list instead of just a tupl
11:59:29 <rwbarton> well sometimes it returns an empty list!
11:59:43 <typoclass> filkr: if i'm confident i won't get confused, i also sometimes do "import Data.Map hiding (length)", "import qualified Data.Map as M". that means Data.Map's stuff is imported without prefix, except for the ambiguous function 'length'. i can access length only by saying M.length
12:00:22 <filkr> typoclass: I think I'll avoid that rabbit hole for now, but thanks for the advice. I'm new enough that it's probably best to prefix everything or nothing
12:00:54 <typoclass> filkr: sure :-) i really only use that for Map and one or two other modules that i know well enough
12:01:43 <Philonous> beaky:  Also, it looks like lines 34 and 25 should be indented more (why does that even compile? )
12:01:49 <Philonous> 24 and 25*
12:02:13 <typoclass> beaky: in lines 18-20, you could move most of those strings into 'prompt', so that 18-20 only look like "a <- prompt 'a'"
12:02:29 <rwbarton> Philonous: looks like line 23 is an empty do block, haha
12:02:36 <beaky> lol
12:02:39 <rwbarton> which is fine because line 22 doesn't fall through
12:02:53 <jedai> beaky: theoretically it could also return a list of several tuples (though I'm unaware of any Show instance where this is the case though...)
12:03:01 <Philonous> rwbarton:  I didn't even know you could do that.
12:03:04 <parcs`> beaky: reads returns a list in the case of ambiguous parses
12:03:08 <Philonous> @type do {}
12:03:09 <lambdabot> Empty 'do' block
12:03:12 <rwbarton> hm
12:03:16 <rwbarton> oh
12:03:16 <bxx> how can i combine two predicates?  for example (comb even (>5)) would return True for all even numbers greater than 5
12:03:22 <rwbarton> i guess you can't
12:03:26 <typoclass> beaky: yeah, folks are right, you should replace that if-then-else with an 'unless'
12:03:29 <rwbarton> (makes sense, what would it mean)
12:03:42 <typoclass> :t (do)
12:03:44 <Philonous> rwbarton:  return ()
12:03:44 <lambdabot> Empty 'do' block
12:03:44 <rwbarton> okay then i agree, i don't know why this code compiles
12:03:48 <typoclass> :t (do ())
12:03:49 <jedai> parcs`: Could you give an example ? Without cobbling together your own Show instance I mean
12:03:49 <lambdabot> ()
12:03:51 <ion> @type liftA2 (&&)
12:03:52 <lambdabot> forall (f :: * -> *). Applicative f => f Bool -> f Bool -> f Bool
12:04:00 <beaky> haskell has an 'unless'?
12:04:06 <jedai> beaky: Yes
12:04:11 <beaky> :t unless
12:04:12 <jedai> @type unless
12:04:12 <lambdabot> forall (m :: * -> *). Monad m => Bool -> m () -> m ()
12:04:13 <lambdabot> forall (m :: * -> *). Monad m => Bool -> m () -> m ()
12:04:20 <typoclass> beaky: yep, it's in Control.Monad. it also has 'when' in the same place
12:04:21 <beaky> it's in Control.Monad iirc
12:04:24 <beaky> ah
12:04:50 <beaky> @src unless
12:04:50 <lambdabot> unless p s = if p then return () else s
12:04:52 <Philonous> unless == when . not
12:04:58 <ion> > map (liftA2 (&&) even (>5)) [0..]
12:04:59 <lambdabot>   [False,False,False,False,False,False,True,False,True,False,True,False,True,...
12:06:43 <rwbarton> it compiles with NoDoAndIfThenElse too so it's not that
12:07:31 <beaky> http://ideone.com/MXHppL strange it doesn't compile on ideone, but compiles on my machine ^^
12:07:31 <typoclass> so the theory is that haskell treats 24-25 as the do block's body? even though the indentation is off the wall
12:07:41 <rwbarton> i guess so
12:07:47 <rwbarton> i don't have a better one :P
12:08:13 <rwbarton> beaky: that one is the DoAndIfThenElse thing
12:08:21 <Cale> beaky: your layout of if-then-else is sort of wrong, and hits an edge case which has been relaxed recently
12:08:26 <typoclass> beaky: dude, really, you need to fix that if-then-else, it's confusing us :-)
12:08:36 <beaky> lol
12:08:37 <Cale> The normal way to lay out if-then-else is like:
12:08:39 <Cale> if foo
12:08:42 <Cale>   then bar
12:08:44 <Cale>   else quux
12:08:49 <beaky> ah
12:08:49 <rwbarton> Cale, did you see http://ideone.com/W1a9SN, a nice "why does this compile" layout puzzle
12:09:28 <typoclass> beaky: yes, and "do" by itself is not something that you can put in place of "bar" or "quux". if you want "nothing" to happen, use "return ()" or similar
12:09:40 <Philonous> use "case foo of True -> bla; False -> blub", problem solved :>
12:09:50 <beaky> right
12:10:17 <typoclass> beaky: although in this case you can just use 'when' or even 'unless' :-) as said before
12:10:23 <Cale> rwbarton: Ah, the 'else do'
12:12:00 <hpaste> rwbarton pasted “minimal weird layout example” at http://hpaste.org/77168
12:12:18 <typoclass> (i think i actually saw something similar once ... it may have been "main = do" followed by unindented lines, which worked but only as long as you didn't try to append a where ...)
12:12:29 <rwbarton> that does sound similar yeah
12:12:58 <Cale> It's actually kind of surprising how weak the layout rules are.
12:13:31 <rwbarton> "Note 1.
12:13:33 <rwbarton> A nested context must be further indented than the enclosing context (n>m). If not, L fails, and the compiler should indicate a layout error."
12:13:49 <rwbarton> I don't understand how this is satisfied
12:13:54 <Cale> It's not.
12:13:57 <Cale> lol
12:14:04 <rwbarton> well, fair enough :)
12:14:16 <typoclass> what is an enclosing context?
12:14:20 <rwbarton> Anyone have hugs?
12:14:39 <rwbarton> some website does, right?
12:14:50 <Cale> rwbarton: also, is that from Haskell 98 or 2010?
12:15:00 <rwbarton> 98
12:15:03 <rwbarton> let me check 2010
12:15:32 <rwbarton> same wording
12:15:33 <Cale> still there
12:15:35 <Cale> yeah
12:16:23 <beaky> http://ideone.com/zJFRwt
12:16:31 <rwbarton> typoclass, I assumed it referred to the nested {}s in main = do { do { return () } }
12:16:36 <rwbarton> roughly speaking
12:17:12 <parcs`> jedai: i don't know of any Read instances that return multiple results
12:17:20 <rwbarton> statements in each {} block are delimited by lines beginning in the starting column of that block... or so I thought
12:17:23 <bxx> is there no syntax for combining predicates?  filter (even _something_ (>5)) [1..10]
12:17:38 <simpson> Hm.
12:17:52 <simpson> @hoogle (a -> Bool) -> (a -> Bool) -> a -> Bool
12:17:52 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
12:17:52 <lambdabot> Prelude (.) :: (b -> c) -> (a -> b) -> a -> c
12:17:52 <lambdabot> Data.Function (.) :: (b -> c) -> (a -> b) -> a -> c
12:17:56 <Cale> bxx: you could use liftM2 (&&) or liftM2 (||), but it might be best just to use a lambda
12:18:04 <bxx> Cale ok thanks
12:18:10 <jedai> parcs`: Yes, that was my experience too :) Which suggest that at least readMaybe would be the most useful function
12:18:21 <hpaste> rwbarton annotated “minimal weird layout example” with “minimal weird layout example (annotation)” at http://hpaste.org/77168#a77169
12:18:23 <Philippa> you could have fun folding over a list of predicates, too
12:18:26 <rwbarton> amazingly this also compiles
12:18:32 <typoclass> rwbarton: hm interesting ... then it might even be an off-by-one problem. the spec says "n>m" as you quoted, but what ghc implements is "n>=m", meaning it's fine with his "let" and "putStrLn" being on the same level as his "a <-" and "if"
12:18:40 <Philippa> (write "anyOf", "allOf")
12:18:40 <typoclass> (does that even make sense ...)
12:18:43 <rwbarton> I guess that is because of automatic } insertion
12:18:48 <Cale> rwbarton: Well, that's not as confusing
12:18:54 <parcs`> jedai: yeah, but that has been just recently added (ghc 7.6 i think) so it's not as portable
12:19:07 <Cale> rwbarton: That's a let statement with an empty set of declarations
12:19:11 <Philippa> or all $ map ($ value) [predicates]...
12:19:23 <rwbarton> right, but if the first one is main = do { do { return () } } then why is the second one not main = do { let { return () } }
12:19:55 <jedai> parcs`: I know, just arguing in the abstract here, that reads is underused and readMaybe (or rather its semantic) is by far more useful
12:20:00 <Cale> backtracking in the parser?
12:20:04 <rwbarton> hmm, what is this RelaxedLayout
12:20:15 <rwbarton> Cale: yes, i think basically, that is part of the layout rules
12:20:26 <rwbarton> if the next token would be a syntax error, try inserting }
12:20:31 <beaky> http://ideone.com/0XF67T why does my program still throw the domainError? :(
12:20:38 <rwbarton> (under certain conditions etc.)
12:20:57 <rwbarton> oh NondecreasingIndentation
12:21:10 <kwilcox> rwbarton: Almost finished reinstalling the world. Ran into a few hiccups. The last one is this, relating to installing with prof:
12:21:11 <bxx> Philippa yeah I'll do fold for practice
12:21:12 <kwilcox> Dynamic linking required, but this is a non-standard build (eg. prof).
12:21:12 <rwbarton> success! doesn't compile with {-# LANGUAGE NoNondecreasingIndentation #-}
12:21:13 <kwilcox>     You need to build the program twice: once the normal way, and then
12:21:13 <kwilcox>     in the desired way using -osuf to set the object file suffix.
12:21:17 <Cale> beaky: -1?
12:21:47 <rwbarton> "It is now on by default, and (incorrectly, but for backwards compatibility) on in Haskell98" hahaha :(
12:22:08 * typoclass scratches his head about the Nondecreasing thingamajig
12:22:23 <Cale> beaky: In order to satisfy validDimensions a b c, it is required that a + b >= c, but in this case a = -1 and b = 1, while c = 2, so a + b = 0 which is less than 2.
12:22:26 <parcs`> jedai: oh, right. agreed
12:22:27 <Cale> oh
12:22:34 <rwbarton> typoclass, I assume it refers to exactly the change "n>m" -> "n>=m" you suggested
12:22:39 <Cale> you mean why isn't it caught earlier
12:22:40 <Cale> hmm
12:22:47 <rwbarton> kwilcox, hmm
12:22:59 <rwbarton> when building what exactly?
12:23:06 <typoclass> rwbarton: interesting!
12:23:21 <kwilcox> at this point, i believe my project:
12:23:24 <typoclass> rwbarton: anyway, good sleuthing :-)
12:23:29 <kwilcox> that's coming from: src/LearnMath.hs:1:1:
12:23:32 <kwilcox> which is one of my files
12:24:15 <rwbarton> can you try building with ghc manually?
12:24:19 <rwbarton> or is that a pain
12:24:26 <rwbarton> i've never tried to build a cabal project with profiling
12:24:46 <kwilcox> it would be a pretty major pain (lots of files) but it looks like i figured it out. There was some template haskell in there - removing it caused it to compile
12:24:51 <rwbarton> this error message is vaguely familiar
12:24:51 <rwbarton> oh
12:25:17 <aninhumer> Hmm, cabal reports base-4.6, but the info says it is base3-compat, and it doesn't seem to match hackage's haddock?
12:25:19 <kwilcox> Which +RTS options should i use again?
12:25:28 <scp> why would my data structures be taking up way more memory than they shoul dbe?
12:25:40 <aninhumer> On Linux Mint (/Ubuntu)
12:25:51 <Cale> beaky: oh, weird
12:25:54 <beaky> right
12:25:57 <parcs`> scp: how do you mean
12:26:08 <scp> I am implementing okasaki's Random Access lists based on skew binary numbers, and a list w/ 100M elements takes up like 10GB
12:26:09 <typoclass> beaky: looks great to me! the only remaining thing i'd change is combining lines 9 + 12 by just saying "| not (valid...) = error ..."
12:26:12 <rwbarton> kwilcox: you can try a few things, e.g. +RTS -p
12:26:38 <Cale> beaky: oh, right
12:26:39 <Cale> beaky: lol
12:26:52 <beaky> why is it like that
12:26:56 <Cale> beaky: you continue with main in the case of an error, but eventually that returns
12:26:58 <scp> 100M integer elements that is. So we're talking like 92 bytes overhead per integer. Does that make any sense?
12:27:01 <beaky> oh
12:27:05 <Cale> beaky: and then the rest of the code runs, of course
12:27:14 <parcs`> scp: integer as in Integer or Int
12:27:21 <rwbarton> scp: it's not out of the realm of possibility
12:27:33 <Cale> beaky: so you really want an if-then-else with both branches
12:27:47 <rwbarton> keep in mind each word is 8 bytes (i assume you are on 64-bit) and every constructor and field in a data type costs one word
12:27:48 <scp> Int
12:28:37 <rwbarton> so even if you have a simple binary tree of Ints, you are talking 2 words per Int + 3 words per node = 40 bytes per Int
12:28:58 <scp> why 2 per int?
12:29:10 <scp> oh, is that the fabled "boxing"
12:29:15 <rwbarton> yes
12:29:21 <rwbarton> you can think of it like this
12:29:23 <rwbarton> @src Int
12:29:23 <lambdabot> data Int = I# Int#
12:29:31 <rwbarton> 1 for I# and 1 for the Int# itself
12:29:36 <parcs`> @src []
12:29:36 <lambdabot> data [] a = [] | a : [a]
12:29:36 <beaky> http://ideone.com/cmBr0x it works fine now :D
12:30:05 <scp> ok... that's kind of disappointing
12:30:11 <aninhumer> Oh nevermind, old terminal environment launched old ghci (and old base)
12:30:26 <Philippa> anyone know how ghci performs on ARM at the moment? Preferably on a Cortex A15? :-)
12:30:32 <scp> effectively, that reduces the size of the datasets I can work on by a factor of .. a lot
12:31:10 <rwbarton> you can unbox the Ints into your data structure perhaps and save 8 bytes per Int
12:31:11 <luite> scp: you can make specialized datatypes that store unboxed ints directly if you really need to optimize
12:31:12 <beaky> if then else makes way too much indentation :(
12:31:25 <rwbarton> but that gives up laziness (which probably you didn't want anyways in this case) and polymorphism
12:31:26 <luite> 16 bytes
12:31:29 <rwbarton> sorry, yes
12:31:39 <startling> scp, are you using -O2?
12:31:40 <mrlemao`> Any one know what feature Cloud Haskell is referring to? "static values can be serialized simply by transmitting a code
12:31:47 <mrlemao`> -- pointer to the value. This however requires special compiler support"
12:31:47 <scp> startling: yes
12:31:57 <scp> rwbarton: how am I saccrificing polymorphism?
12:32:00 <clahey> rwbarton: What is the I#?
12:32:04 <scp> s/saccrificing/sacrificing
12:32:12 <luite> scp: polymorphic values must always be boxed
12:32:37 <beaky> is there any way to embed line numbers and filenames in haskell code?
12:32:38 <scp> so, I couldn't call a function (a -> a) on an Int#?
12:32:44 <beaky> like the __LINE__ and __FILE__ macros in C?
12:32:47 <luite> you can specialize your tree to Int#, but a in a 'Tree a' cannot be Int#
12:33:13 <scp> gross =]
12:33:15 <startling> beaky: {-# Language CPP #-} ?
12:33:16 <parcs`> > id 3# -- scp
12:33:17 <lambdabot>   Couldn't match kind `*' against `#'
12:33:18 <rwbarton> or another way to say it is you can replace all your "a"s in "Tree a" by "{-# UNPACK #-} !Int"
12:33:21 <Philippa> luite: now there's a thing that makes typeclasses useful :-)
12:33:28 <startling> beaky, or maybe template haskell has a thing
12:33:33 <luite> right, they have a special kind
12:33:55 * hackagebot uuagc 0.9.42.1 - Attribute Grammar System of Universiteit Utrecht  http://hackage.haskell.org/package/uuagc-0.9.42.1 (JeroenBransen)
12:34:02 <scp> ok, well for now I only need to work on 10M or so elements, so I can probably survive
12:35:09 <clahey> @src #I
12:35:09 <lambdabot> Source not found. Are you on drugs?
12:35:14 <clahey> @src I#
12:35:14 <lambdabot> Source not found. Sorry.
12:35:22 <rwbarton> it's a data constructor
12:35:42 <c_wraith> It's kind of like looking for the source for Just
12:35:51 <rwbarton> however if you ask too many more questions you will start to get into compiler internals
12:35:57 <typoclass> clahey: some internal unboxed thing. it's in GHC.Somewhere afaik
12:36:09 <startling> @info #I
12:36:09 <lambdabot> (# I)
12:36:12 <startling> oh.
12:36:30 <luite> GHC.Exts
12:37:32 <bxx> just learned how important it is to manually write function declarations.  I did a small error in here (wrong argument order in lambda passed to foldr) and haskell silently compiled it. elem' x xs = foldr (\acc y-> if x == y then True else acc) False xs
12:37:34 <scp> Anyone know of a good, small, well written haskell program? Basically, I wanna see how someone else develops an end-to-end program in haskell
12:37:40 <beaky> @pl \a b c -> a + b >= c && a + c >= b && b + c >= a
12:37:41 <lambdabot> ap (ap . ((ap . ((&&) .) . (>=)) .) . (+)) (ap (ap . (liftM2 (&&) .) . flip . ((>=) .) . (+)) (flip (flip . ((>=) .) . (+))))
12:37:45 <beaky> :t ap
12:37:47 <lambdabot> forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
12:38:01 <typoclass> bxx: you mean, how important it is to write type signatures?
12:38:04 <beaky> ap (+1) [1..10]
12:38:06 <beaky> > ap (+1) [1..10]
12:38:08 <lambdabot>   Couldn't match expected type `(->) (a0 -> b0)'
12:38:08 <lambdabot>              with actual typ...
12:38:09 <bxx> typoclass yes
12:38:11 <startling> beaky, it's <*> for Monad.
12:38:16 <beaky> ah
12:38:27 <beaky> > ap [(+1)] [1..10]
12:38:29 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
12:39:03 <beaky> the pointfree version of that lambda looks obfuscatish :(
12:39:07 <bxx> haskell did what it should have and made elem' Bool -> [Bool] -> Bool
12:39:08 <typoclass> bxx: right :-) they are great for double-checking. the compiler will yell at you if you claimed it will be one thing, but actually made it another
12:39:37 <Cale> bxx: by the way, if p then True else q is the same thing as p || q
12:39:58 <typoclass> bxx: it's great for ensuring you did what you meant to do :)
12:40:30 <nicoo> beaky: Why don't you want map ?
12:41:21 <Saizan> scp: xmonad, maybe?
12:41:38 <beaky> > [1..10] >>= \x -> return x + 1
12:41:40 <lambdabot>   No instance for (GHC.Num.Num [b0])
12:41:40 <lambdabot>    arising from a use of `e_11101'
12:41:40 <lambdabot>  Poss...
12:41:43 <beaky> :(
12:42:41 <rwbarton> moar parens
12:43:00 <beaky> > [1..10] >>= \x -> return $ x + 1
12:43:02 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
12:43:02 <Cale> bxx: So, after correcting the parameter order, you can simplify to  elem' x xs = foldr (\y acc -> x == y || acc) False xs
12:43:05 <sipa> needs moar lisp
12:43:28 <nicoo> @pf ([1..10] >>= \x -> return $ x + 1)
12:43:28 <lambdabot> Maybe you meant: bf pl
12:43:32 <typoclass> sipa: yeah, well, lisp needs moar types ;-)
12:43:49 <beaky> @pl ([1..10] >>- \x -> return $ x + 1)
12:43:49 <lambdabot> [1..10] >>- (return . (1 +))
12:43:55 <beaky> :t (>>-)
12:43:57 <lambdabot> forall (m :: * -> *) a b. MonadLogic m => m a -> (a -> m b) -> m b
12:44:01 <Cale> bxx: But then, this is the same thing (by foldr unfusion) as  foldr (\y acc -> y || acc) False (map (x ==) xs)
12:44:03 <bxx> Cale yes thanks. I am following tutorial and they introduced fold for the first time,m so they made it more explicit than they should have
12:44:23 <bxx> for clarity
12:44:27 <Cale> and then this foldr has a name in the libraries, it's called or
12:44:44 <Cale> So that reduces to  or (map (x ==) xs)
12:44:59 <Cale> and then or (map p xs) has a name too, it's  any p xs
12:45:13 <Cale> So we get  elem' x xs = any (x ==) xs
12:45:44 <bxx> cool, did not know about any
12:46:16 <bxx> is there some function too?
12:46:19 <typoclass> > let f = any . (==) in f 42 [1..50] -- bxx, let me just confuse you further ;-)
12:46:21 <lambdabot>   True
12:46:24 <bxx> it's not there by the name of some
12:46:33 <Cale> all?
12:46:37 <rwbarton> what would be the difference between any and some
12:46:44 <bxx> nevermind, any is some. :]. yes all would be the other one
12:46:59 <nand`> I think some would imply not all?
12:47:04 <nand`> but not sure
12:47:14 <bxx> yes
12:47:51 <typoclass> nand`: you mean, at least one must be False and at least one True? when are you gonna need that, realistically ...
12:49:07 <masta_> Are Qt bindings usable?
12:49:27 <Philippa> nand`: so that's not how it's been used in Control.Applicative?
12:49:49 <Cale> nand`: nah, 'some' means the same as 'exists' :)
12:49:55 <Philippa> also, is this a bad time to mention the optimisation on (any && not all)?
12:50:24 <beaky> > :t any
12:50:26 <lambdabot>   <hint>:1:1: parse error on input `:'
12:50:31 <typoclass> we could rename Just to Some ... Nothing | Some a
12:50:59 <aninhumer> Hmm, I note that there is no way to ask for an empty Bits instance in the current definition
12:50:59 <nand`> oh, ‘some’ is an actual function
12:51:01 <nand`> I didn't realize
12:51:14 <sipa> :t some
12:51:15 <lambdabot> forall (f :: * -> *) a. Alternative f => f a -> f [a]
12:51:36 <aninhumer> Which might be because 0 used to suffice when it was Num
12:51:41 <c_wraith> some is not well-founded for many Alternative types
12:52:08 <c_wraith> > some (Nothing :: Maybe Int)
12:52:10 <lambdabot>   Nothing
12:52:16 <c_wraith> > some (Just 5 :: Maybe Int)
12:52:20 <lambdabot>   mueval-core: Time limit exceeded
12:52:33 <rwbarton> @src some
12:52:34 <lambdabot> some v = some_v
12:52:34 <lambdabot>   where many_v = some_v <|> pure []
12:52:34 <lambdabot>         some_v = (:) <$> v <*> many_v
12:52:53 <Cale> aninhumer: hah, yeah, that's definitely an issue
12:55:08 <rwbarton> clearBit (bit 0) 0
12:55:10 <Cale> Though I guess if you have at least one value, you could xor it with itself
12:55:12 <rwbarton> (ugh)
12:55:15 <rwbarton> or yeah
12:55:21 <Cale> ah, right, bit
12:55:47 <scp> is there a common function "fn_or f g x = f x || g x"?
12:56:29 <sipa> :t liftA2 (||)
12:56:31 <lambdabot> forall (f :: * -> *). Applicative f => f Bool -> f Bool -> f Bool
12:56:46 <Cale> Yeah, you can use liftM2 or liftA2 with the instance for functions
12:56:56 <koala_man> oh, that wonderful feeling when you've drudged through all the low level parsec functions and can suddenly implement large language constructs in a few lines
12:59:58 <clahey> rwbarton: I'm fine with getting into compiler implementation.  :)
13:00:01 <clahey> But I'm about to leave.
13:00:23 <rwbarton> worse, you may get into questions I cannot answer off the top of my head
13:01:14 <masta_> What is the name of the function that returns position of an element in a list?
13:01:39 <rwbarton> hoogle time!
13:01:50 <rwbarton> @hoogle [a] -> a -> Maybe Int
13:01:50 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
13:01:50 <lambdabot> Data.ByteString findSubstring :: ByteString -> ByteString -> Maybe Int
13:01:50 <lambdabot> Data.ByteString.Char8 findSubstring :: ByteString -> ByteString -> Maybe Int
13:03:13 <masta_> Thanks
13:03:17 <scp> ?src liftM2
13:03:18 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:03:38 <scp> functions are monads?
13:04:20 <lolcathost> @hoogle ReaderT
13:04:21 <lambdabot> Control.Monad.Reader ReaderT :: (r -> m a) -> ReaderT r a
13:04:21 <lambdabot> Control.Monad.Trans.Reader ReaderT :: (r -> m a) -> ReaderT r m a
13:04:21 <lambdabot> Control.Monad.Trans.Reader newtype ReaderT r m a
13:04:53 <Cale> scp: The type constructor for functions from a specific type is a monad
13:05:16 <Cale> scp: That is, the partially-applied function type constructor (->) e is a monad for each e
13:05:48 <scp> :k (->)
13:05:49 <lambdabot> * -> * -> *
13:06:10 <scp> :k Maybe
13:06:12 <lambdabot> * -> *
13:06:22 <scp> ok..., I think I see
13:06:57 <Cale> First of all, it's a functor, with fmap :: (a -> b) -> (f a -> f b) specialising to something of type (a -> b) -> (e -> a) -> (e -> b)
13:07:04 <Cale> and what could that be?
13:07:10 <dgpratt> I am reminded of when I asked about a 'pairwise' function, the response was "ap zip tail"; I stared at that for a long time
13:07:22 <Cale> There's only one reasonable thing, right? It has to be composition :)
13:07:38 <Cale> and then there's  return :: a -> (e -> a)
13:07:39 <beaky> What is the difference between functions in a functional programming language and a function in a von-neumann language like C?
13:07:44 <Cale> that's got to be const
13:07:53 <srhb> beaky: One is a function, the other is not.
13:08:01 <Cale> and join :: (e -> e -> a) -> (e -> a)
13:08:06 <dgpratt> beaky: the latter is not a function, at least in a mathematical sense
13:08:07 <Cale> which is  join f x = f x x
13:08:33 <beaky> aren't things like `int square(int n) { return n * n }` functions?
13:08:37 <scp> beaky: The C thing is better described as a subroutine or procedure
13:08:37 <Philippa> dgpratt: at least, not by the time the von-neumann device does IO too
13:08:41 <beaky> ah
13:08:48 <Cale> beaky: well, *that* is :)
13:08:56 <Philippa> scp: yeah. One that happens to be parameterised
13:09:08 <Philippa> (usually - see also: Haskell does /not/ have 0-ary functions)
13:09:23 <Cale> beaky: but there are a lot of "functions" in C which are not properly modelled by functions in any reasonable way, except perhaps as functions of the entire state of the universe.
13:09:33 <Eduard_Munteanu> As a side note, gcc has that __attribute__((pure)) thing, but it doesn't actually check it. It just lets the compiler optimize better if it can.
13:09:37 <srhb> beaky: Perhaps it would be better to say that one is guaranteed to be a function.
13:09:40 <beaky> ah
13:09:43 <tac> Is there any introduction to using haskell plugins?
13:10:03 <Philippa> Cale: yep. The world passing model is great fun for mental imagery that explains concerns with eg unsafePerformIO, too bad it's lousy for anything else
13:10:11 <Cale> tac: If by plugins you mean the 'plugins' library, I would recommend using something like 'hint' instead
13:10:20 <tac> Cale: oh yeah?
13:10:40 <Cale> tac: I don't think 'plugins' is being maintained, and you may have trouble getting it to work with new GHCs.
13:10:48 <tac> kk
13:10:52 <tac> thank you
13:10:56 <scp> :k (->) Int
13:10:57 <lambdabot> * -> *
13:11:04 <scp> when I type that into ghci
13:11:05 <Cale> http://hackage.haskell.org/package/hint
13:11:12 <scp> I get (->) Int :: ? -> *
13:11:15 <scp> what does that mean?
13:11:18 <kwilcox> Parsec Question: Is there any way to force parsec to fail if it doesn't consume the entire input?
13:11:24 <Eduard_Munteanu> :k (->)
13:11:25 <lambdabot> * -> * -> *
13:11:27 <Eduard_Munteanu> Grr.
13:11:30 <Philippa> kwilcox: eof
13:11:31 <Cale> scp: yeah, the funny ?? and ? kinds have to do with unboxed types
13:11:37 <Eduard_Munteanu> (->) :: ?? -> ? -> *
13:11:47 <Philippa> (which is something like notFollowBy anyChar :p)
13:11:57 <Philippa> (er, notFollowedBy anyChar, even)
13:12:06 <kwilcox> ahh. ok. so I put that at the end of the parser?
13:12:09 <scp> Cale: does that translate to "don't worry about it, it's an implementation detail"?
13:12:11 <Philippa> yeah
13:12:14 <typoclass> scp: aiui, the question marks are not very different from *
13:12:22 <Cale> scp: pretty much
13:12:26 <scp> ok
13:12:30 <kwilcox> thanks :)
13:12:41 <Cale> scp: and newer GHCs hide that detail from you now
13:13:04 <scp> Cale: I'm running 7.0.4, is that particularly old?
13:13:13 <Cale> That's fairly old
13:13:28 <kwilcox> Philippa: Is there anything special I need to do when using the buildExpressionParser function?
13:13:32 <Cale> (It's from March 2011)
13:13:34 <kwilcox> i.e. : exprparserTex = buildExpressionParser exprTableTex termRecognizerTex <?> "TexExpression"
13:13:39 <scp> I read a while ago that they were looking into some sort of "supercompiler" implementation, did that come to fruition?
13:13:44 <Philippa> kwilcox: no idea I'm afraid, I don't use it
13:13:49 <Cale> oh, no sorry, June
13:13:53 <Philippa> I mean, it's not magic...
13:14:07 <Philippa> also: you're trying to parse TeX? :-)
13:14:09 <kwilcox> <grins> Fair. I can probably just wrap it in a do block
13:14:25 <kwilcox> <laughs> Yeah, a bit ;)
13:14:28 <Cale> scp: there was 7.2.x and 7.4.x and now 7.6.x which come after it :)
13:14:33 <kwilcox> I'm doing some fun work with handwritten equation recognition
13:14:39 <kwilcox> Where the equation recognizer is outputting latex
13:14:48 <kwilcox> so I'm parsing it to generate data structures to represent expressions and equations
13:14:50 <scp> meaning everyone has it but me? =P
13:14:55 <kwilcox> and then generating step-by-step solutions from those ;)
13:14:56 <hpaste> mrlemao pasted “What's wrong with this?” at http://hpaste.org/77170
13:15:15 <Philippa> kwilcox: ah. I still want expression-sized detexify as an android app, come to think of it
13:15:46 <Cale> scp: 7.6.1 is still bleeding edge and there'll be lots of brokenness with respect to getting things to work, but 7.4.2 is pretty stable now, and would be the version I'd recommend.
13:15:48 <kwilcox> (www.checkmyanswers.com)
13:15:57 <scp> Cale: thanks
13:15:57 <kwilcox> What do you want to detoxify it to? :)
13:16:03 <kwilcox> err, detexify. stupid auto-correct
13:16:13 <plotr> is Bryan O'Sullivan somewhere around?
13:16:32 <kwilcox> An image? some human-ish friendly text?
13:16:43 <Cale> plotr: he comes here as 'bos'
13:16:52 <Cale> Doesn't appear to be here at the moment
13:16:54 <Philippa> LaTeX is fine
13:17:04 <Cale> Where is preflex?
13:17:22 <plotr> Cale thanks
13:17:31 <Philippa> I already have some tedious LaTeX -> blog-friendly .png code I'm making semi-regular use of
13:17:54 <kwilcox> Philippa: The handwriting recognition i'm using is available as a web api.
13:17:56 <Cale> plotr: I'd ask a bot when he was last online, but it's gone missing too :)
13:18:11 <plotr> doh :)
13:18:24 <beaky> is there a version of reads that returns a Maybe a instead of an [(a, String)]?
13:18:34 <plotr> I've just hit a bug in one of his packages :(
13:18:35 <Philippa> kwilcox: *nod*. I'd prefer on-device, I do too much work on trains, but yeah
13:19:10 <kwilcox> Philippa: If you're interested, we can probably get the online-version working for you
13:19:26 <beaky> :t readMaybe
13:19:27 <lambdabot> Not in scope: `readMaybe'
13:19:29 <kwilcox> Phillipa: Sadly, the handwriting recognition has a minimum expense of 10k euros to use directly from the company we're using.
13:19:36 <kwilcox> But we've already paid their fee for the online version
13:19:54 <kwilcox> (They have an iOS and android sdk as well, but a bit too rich for our blood right now)
13:20:08 <kwilcox> So if you were interested in being able to navigate to a website and get raw latex you could copy and paste
13:20:12 <kwilcox> I can probably arrange that for you
13:20:13 <kwilcox> :)
13:20:33 <beaky> let readMaybe s = case reads s of {[(a, _)] -> Just a ; _ -> Nothing } in readMaybe "12 a" :: Maybe Int
13:20:34 <Philippa> thanks. Mostly I just use detexify for symbols and put up with it :-)
13:20:37 <beaky> > let readMaybe s = case reads s of {[(a, _)] -> Just a ; _ -> Nothing } in readMaybe "12 a" :: Maybe Int
13:20:39 <lambdabot>   Just 12
13:20:47 <beaky> is that alright?
13:20:59 <kwilcox> hehe. I can do you one better then :)
13:21:03 <mrlemao`> anyone that knows Cloud haskell over here? I am pulling my hair trying to get minimum dependencies I need
13:22:52 <beaky> > let readMaybe s = case reads s of {[(a, _)] -> Just a ; _ -> Nothing } in putStrLn (readMaybe "12 a")
13:22:54 <lambdabot>   Couldn't match expected type `GHC.Base.String'
13:22:54 <lambdabot>              with actual typ...
13:24:36 <jeff_s1> I'm wondering if anyone knows some "magic" RTS flags that could help a warp web server respond faster to connection requests... currently some are timing out after 1 second. I'm using +RTS -N32 -K1G on a 32 core machine.
13:25:11 <Cale> mrlemao`: I can't say that I really know it, but I've seen some things describing its structure in a fair amount of detail, so maybe I can provide some help?
13:25:43 <hpaste> scp pasted “Why won't this compile?” at http://hpaste.org/77171
13:26:29 <scp> tells me "No instance for (Monad ((->) a))"
13:26:40 <Cale> scp: import Control.Monad.Instances
13:26:45 <scp> merci
13:26:58 <aninhumer> Hmm, is it possible to define an infinite Vector.Unboxed? I'm guessing no...
13:27:19 <ion> Depends on how much memory you have.
13:27:24 <sclv_> a lazy one?
13:27:30 <sclv_> we still have lazy vectors, yeh?
13:27:48 <shachaf> Not unboxed ones, presumably.
13:27:54 <shachaf> Isn't that just value-laziness, not spine-laziness?
13:27:55 <beaky> what is the difference between the Data.Array and the Data.Vector?
13:27:55 <mrlemao`> Cale: there are some interesting tutorials, blog posts, presentations, but they all fail to provide the simplest path with minimum dependencies
13:27:58 <aninhumer> sclv_: Well, more specifically, I'm trying to define bit for BitVectors, which are unboxed
13:28:11 <aninhumer> And I don't think it can be done in a useful way
13:28:12 <sclv_> you can have an unboxed lazy vector
13:28:17 <sclv_> like a lazy bytestring
13:28:24 <aninhumer> Ah hmm
13:28:25 <sclv_> chunkwise unboxed
13:28:42 <mrlemao`> Cale: See this : http://hpaste.org/77170
13:29:14 <Cale> mrlemao`: ghc-pkg list network-transport
13:29:23 <Cale> mrlemao`: and hpaste the result
13:29:36 <ncs> how can i make an instance of Read for the Zipper datatype:  data Zipper a = Zip ![a] ![a]   ??
13:29:38 <jeff_s1> Wow, I have a 77 second maximum pause for gen 1 garbage collection. That seems really bad.
13:29:43 <aninhumer> Actually, it might make more sense to change the implementation of some other functions
13:29:45 <spaceships> what is the best book to learn compilers from (and hopefully implement in haskell)?
13:29:53 <shachaf> ncs: You could just derive it...
13:30:23 <ncs> but i import the module where Zipper is defined.. i don't define it in my module
13:30:34 <hpaste> mrlemao pasted “result for ghc-pkg list network-transport ” at http://hpaste.org/77172
13:30:34 <sclv_> i coulda sworn there was a lazy bitvector on hackage somewhere already
13:30:37 <sclv_> wren wrote one i think
13:30:53 <shachaf> Well, an orphan Read instance is kind of an evil thing to do.
13:30:53 <sclv_> i have a scheme for a very fast one but never fully implemented it
13:30:58 <Cale> mrlemao`: Right, so you somehow ended up with two versions of network-transport installed
13:31:14 <sclv_> oprhan <strike>Read</strike> instance is kind of an evil thing
13:31:20 <shachaf> You can use StandaloneDeriving to derive it, though.
13:31:23 <Cale> mrlemao`: and then some of the other stuff got compiled against one version and some got compiled against the other
13:31:27 <shachaf> sclv_: Yes, but some instances are justified more than others.
13:31:36 <Cale> mrlemao`: and so the errors you're seeing are because of that
13:31:49 <mrlemao`> Cale: what can I do to rectify this?
13:32:25 <scp> ?src liftM2
13:32:25 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
13:32:52 <mrlemao`> Cale: thanks. that is already a big help!
13:33:05 <Cale> mrlemao`: you might want to ghc-pkg remove one of them
13:33:27 <aninhumer> sclv_: I don't particularly need a lazy bit-vector, I'm just trying to define Bits.bit on BitVector (Vector.Unboxed Bool) and not really succeeding
13:33:36 <Cale> mrlemao`: but when you do that, some packages will become broken, so you'll want to cabal install --reinstall distributed-process-simplelocalnet
13:33:58 <ncs> shachaf: how could i do that?
13:33:59 <Cale> mrlemao`: and actually probably the safest way to do it is to specify some of the dependencies at the same time
13:34:07 <scp> where can I find the source for "instance Monad ((->) a) where ..."
13:34:08 <Cale> (so it compiles them all together)
13:34:19 <ion> scp: Control.Monad.Instances
13:34:20 <shachaf> ncs: Look up StandaloneDeriving. :-)
13:34:40 <Cale> Let me try installing this...
13:34:41 <shachaf> sclv_: In the module ion mentioned, but keep in mind that writing this code is a good exercise!
13:34:50 <shachaf> Er, s/lv_/p/
13:35:01 <mrlemao`> Cale: is there a way to see a tree of dependencies for a given package?
13:35:09 <Cale> http://hackage.haskell.org/package/distributed-process-simplelocalnet
13:35:22 <Cale> You can see the direct dependencies there
13:35:40 <Cale> the ones you care about really are the ones which are obviously cloud-haskell related things
13:35:41 <mrlemao`> k
13:36:12 <ncs> ok, thanks! L(
13:36:13 <ncs> :)
13:36:18 <Cale> if you were just to unregister all the cloud-haskell related packages and install distributed-process-simplelocalnet, probably it would find a consistent solution
13:36:31 <scp> ion I tried that on hackage, there is no source link. Where could I locate the source for that package?
13:36:50 <scp> ion: nevermind, I'm silly
13:39:13 <mrlemao`> Cale: found this ghc-pkg dot | tred | dot -Tpdf >pkgs.pdf but it renders the whole list which is not that useful
13:39:39 <mrlemao`> Cale: thanks. Let me work on this.
13:42:02 <Cale> mrlemao`: I just did  cabal install distributed-process-simplelocalnet  and then loaded your program successfully (modulo not having a definition for initCat)
13:42:39 <Cale> mrlemao`: you might also just try  cabal install --reinstall distributed-process-simplelocalnet  and see what happens
13:43:15 <Cale> (but yeah, unregistering old versions of some of these packages will likely help)
13:43:22 <Cale> (or just hiding them)
13:43:23 <Makkron> hi
13:43:27 <Cale> hello
13:43:49 <Makkron> I have a small question about lambdabot
13:44:02 <Makkron> How can i connect to a password protected server?
13:44:30 <Makkron> I tried to look for the passwd.rc but i wasn't able to find it
13:44:58 <shachaf> Makkron: passwd.rc is separate because it contains an actual password in it. :-)
13:45:19 <shachaf> Makkron: But I suspect it contains something of the form msg nickserv identify ...
13:45:35 <Cale> Makkron: the idea is that you'd create it yourself with something like   msg freenode:nickserv identify 0penS3s4m3
13:45:49 <shachaf> That won't help with an actual password-protected server, of course.
13:45:53 <Cale> rigth
13:46:00 <shachaf> lambdabot is a hack anyway.
13:46:08 <shachaf> Moreover, lambdabot doesn't even support lens!
13:46:22 <Cale> I don't know where you'd put an actual server password
13:46:43 <shachaf> rwbarton was going to implement the code for that.
13:46:47 <Makkron> Ok thanks
13:46:59 <Cale> presumably the irc-connect command would need to take that as a parameter, but I don't know if it supports that
13:47:15 <shachaf> @help irc-connect
13:47:16 <lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
13:47:34 <Makkron> So maybe the question is stupid, but if it doesn't work with a password protect server, what is the point of a passwd.rc file?
13:47:51 <Cale> Makkron: identifying the bot with nickserv
13:48:12 <geekosaur> because it's used on open servers with nickserv, not with password protected servers.  different usage model, different conventions, different commands needed, etc.
13:48:27 <rwbarton> is there code to implement besides "import Control.Lens"
13:48:32 <Cale> Makkron: also, you don't need to put that in a separate file, you can just put the msg command right in your online.rc
13:48:37 <Cale> rwbarton: no
13:48:39 <ion> 0penS3s4m3 looks like a good password, i will use it from now on.
13:48:44 <startling> is there a "lefts" traversal for [Either a b] in lens? can I make it somehow?
13:48:50 <Makkron> irc-connect doesn't support password unfortunately :(
13:48:56 <rwbarton> shachaf: consider it implemented
13:49:05 <Makkron> ok thanks for the info
13:49:13 <shachaf> rwbarton: Great, thanks!
13:49:31 <Cale> ion: "correct horse battery staple" is even better!
13:49:40 <shachaf> rwbarton: Wait, are we talking about passworded IRC login or adding lenses?
13:49:47 <ion> shachaf: yes
13:49:56 <shachaf> Passworded IRC login was your job. Adding lenses was Cale's job.
13:49:57 <Cale> better than Tr0ub4dor&3 anyway
13:50:00 <rwbarton> i assumed lenses
13:50:02 <rwbarton> oh
13:50:06 <Cale> ;)
13:50:20 * shachaf needs to get better at this delegation thing.
13:50:39 <typoclass> shachaf: i want a job as well! https://i.chzbgr.com/completestore/12/10/31/fekqLCW1i0SFzH_Tr0zO0Q2.jpg
13:51:03 <rwbarton> the problem is that I have slightly surreal conversations with shachaf on a regular enough basis anyways
13:52:36 <startling> is there a way to traverse the Left of an either in general?
13:53:01 <Cale> @undefine
13:53:06 <Cale> :t lens
13:53:07 <rwbarton> there's a lens-y way
13:53:08 <lambdabot> Not in scope: `lens'
13:53:10 <Cale> hmm
13:53:11 <parcs`> @quickcheck True
13:53:11 <lambdabot> Unknown command, try @list
13:53:16 <parcs`> @check True
13:53:18 <lambdabot>   Could not find module `Data.Lens'
13:53:18 <lambdabot>  Use -v to see a list of the files search...
13:53:21 <Cale> oh
13:53:24 <srhb> Haskell 2012 edition: Also known as Lenseskell.
13:53:25 <rwbarton> traverseLeft
13:53:33 <startling> rwbarton: oh neat, thanks
13:53:47 <shachaf> @ty both
13:53:48 <lambdabot> Not in scope: `both'
13:53:56 <Cale> @undefine
13:54:01 <Cale> :t both
13:54:02 <lambdabot> Not in scope: `both'
13:54:19 <scp> so, if I do "liftM2 (||)"
13:54:35 <ion> do liftA2
13:54:35 <Cale> :t chosen
13:54:36 <lambdabot> Not in scope: `chosen'
13:54:38 <Cale> hmm
13:54:41 <nicoo> :t liftM2 (||)
13:54:42 <lambdabot> forall (m :: * -> *). Monad m => m Bool -> m Bool -> m Bool
13:54:44 <scp> how does haskell know that the type is "(a -> Bool) -> (a -> Bool) -> a ->Bool"
13:54:50 <Cale> oh, it installed 2.4.0.2
13:54:51 <Cale> lol
13:55:02 <shachaf> scp: Because m = (a ->)
13:55:08 <ion> scp: The same way type inference works everywhere.
13:55:22 <nicoo> scp: It matches the type of || against the first type variable, basically
13:55:23 <scp> ion: I figured as much =P, I just am not seeing it. not being a compiler myself
13:55:35 <scp> oh ok, wait, I see from shachaf's comment.
13:55:40 <typoclass> scp: it's what nicoo showed + what shachaf said :)
13:55:40 <ion> @type liftA2 (||) `asAppliedTo` even
13:55:42 <lambdabot> Not in scope: `asAppliedTo'
13:56:00 <ion> @type liftA2 (||) `asTypeIn` ($ even)
13:56:01 <lambdabot>     Not in scope: `asTypeIn'
13:56:01 <lambdabot>     Perhaps you meant `asTypeOf' (imported from Prelude)
13:56:04 <Cale> hang on
13:56:04 <ion> I want my money back.
13:56:08 <scp> I was forgetting that ((->) Int) and ((->) Float) aren't the same monad
13:56:10 <typoclass> ... she's not really been herself these past few days
13:56:18 <Cale> shachaf is making me install lens
13:56:23 <Cale> so it's broken for a sec
13:56:29 <shachaf> lens 3.1!
13:56:45 <shachaf> lens 3.1.1 (for workgroups) will be out soon, actually.
13:56:46 <ion> Lens 3.11 for Workgroups
13:56:53 <Cale> lol
13:57:55 <Cale> lens 95
13:58:02 <Cale> @undefine
13:58:05 <sipa> lens longhorn
13:58:08 <shachaf> @ty both
13:58:10 <lambdabot> forall a b (f :: * -> *). Applicative f => (a -> f b) -> (a, a) -> f (b, b)
13:58:25 <Cale> :t asTypeIn
13:58:27 <lambdabot> forall a b. a -> (a -> b) -> a
13:58:29 <shachaf> Hmph. It doesn't preserve type synonyms.
13:58:33 <Cale> :t asAppliedTo
13:58:33 <ion> Lens 95 will have an RPC service listening on all network interfaces and running as root.
13:58:34 <lambdabot> forall b t. (t -> b) -> t -> t -> b
13:59:02 * hackagebot threadscope 0.2.2 - A graphical tool for profiling parallel Haskell programs.  http://hackage.haskell.org/package/threadscope-0.2.2 (MikolajKonarski)
13:59:03 <ion> @type liftA2 (||) `asAppliedTo` even
13:59:05 <lambdabot> forall a. Integral a => (a -> Bool) -> (a -> Bool) -> a -> Bool
13:59:22 <Cale> :t lens
13:59:23 <lambdabot> forall s a b t (f :: * -> *). Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
13:59:32 <Cale> hooray, no type synonyms!
13:59:32 <scp> ion: why would I use liftA2 as opposed to liftM2?
13:59:48 <Cale> :t alongside
13:59:49 <lambdabot> forall a b s t a' b' s' t' (f :: * -> *). Functor f => LensLike (Control.Lens.Internal.Context a b) s t a b -> LensLike (Control.Lens.Internal.Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) ->
13:59:50 <lambdabot> (s, s') -> f (t, t')
13:59:50 <rwbarton> it's trendier
13:59:53 <Philippa> scp: the weaker type signature
14:00:07 <edwardk> :t (^.)
14:00:08 <lambdabot> forall s a t b. s -> Getting a s t a b -> a
14:00:10 <edwardk> yay!
14:00:13 * edwardk hugs Cale.
14:00:13 <ion> scp: liftM2 shouldn’t exist in the first place, it’s only there for hysterical raisins.
14:00:14 <edwardk> Cale++
14:00:30 <S11001001> this is freaky edwardk
14:00:36 <Philippa> "Getting a s t a b" is a worrying type, no?
14:00:37 <Cale> ion: disagree
14:00:39 <edwardk> ?
14:01:00 <scp> ?src lifta2
14:01:01 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:01:02 <scp> ?src liftA2
14:01:02 <startling> can I use Simple with IndexedTraversal
14:01:03 <lambdabot> liftA2 f a b = f <$> a <*> b
14:01:06 <startling> somehow?
14:01:07 <Philippa> I mean, the compiler's not supposed to have a knife handy in the first place
14:01:11 <startling> Philippa: ;)
14:01:17 <shachaf> startling: If you apply the index first.
14:01:24 <Cale> ion: You'd still want things like ap and liftM2 and so on, even if Monad had an Applicative superclass constraint
14:01:36 <edwardk> startling: 'traverse.traverseLeft'
14:01:43 <Cale> ion: because when you're writing instances, you'll still want things like that
14:01:44 <mrlemao`> Cale: this worked: many thanks!
14:01:45 <scp> ion: Not sure I understand, the definition of liftM2 looks elegant and logical to me
14:01:48 <edwardk> startling: its not quite lefts, but it trraverses the left hand _values_
14:01:52 <edwardk> lefts isn't quite a traversal
14:01:56 <startling> edwardk: yeah, I figured that out. :)
14:02:02 <Philippa> scp: the "problem" is that liftM2 is now a duplicate of liftA2
14:02:02 <monochrom> wait, what? lambdabot now knows lenses?!
14:02:18 <startling> finally starting to grok this traversal stuff.
14:02:23 <Philippa> scp: assuming none of the instance laws're broken, they're the same function except liftA2 has a more general type
14:02:25 <ion> cale: Granted. But there isn’t much use for liftM2 outside defining Applicative methods based on Monad ones, is there?
14:02:28 <Cale> ion: For example, you still might want to write the instance of Monad first (as I often do), and then fill in the Functor and Applicative instances by writing fmap = liftM, pure = return, and (<*>) = ap
14:02:40 <scp> Philippa: ok, so it's mostly for consistency of source code, not actually anything wrong semantically
14:02:41 <Cale> ion: well, yeah
14:02:55 <hpaste> mrlemao pasted “Cale: Steps to remove and reinstall Cloud Haskell” at http://hpaste.org/77173
14:03:49 <Cale> mrlemao`: looks good :)
14:04:22 <startling> can I write "(Ord a, Applicative f) => (k -> v -> f v) -> Tree k v -> f (Tree k v)" with the Traversal-type things? I guess that's not really a traversal, since v is constant.
14:04:43 <startling> er, s/Ord a/Ord k
14:04:56 <ion> scp: It’s typically a good idea to have e.g. “add :: Num a => a -> a -> a” instead of the less generic “add :: Integer -> Integer -> Integer”. Similarly, Applicative is more generic than Monad. Every monad is an applicative functor, but every applicative functor is not a monad.
14:04:58 <edwardk> :t traverse.traverseLeft
14:04:59 <lambdabot> forall (t :: * -> *) (f :: * -> *) a c b. (Applicative f, Traversable t) => (a -> f b) -> t (Either a c) -> f (t (Either b c))
14:05:08 <edwardk> wow, this will definitely help with the lens tutorials on channel.
14:05:15 <startling> edwardk: haha
14:05:20 <scp> ion: ok, I see
14:05:23 <kirindave> edwardk: Btw
14:05:46 <shachaf> edwardk: Help? Now I won't be able to @let half of "lens" while explaining things!
14:05:49 <shachaf> This is a traversty!
14:05:50 <edwardk> > traverse.both +~ 1 $ [(1,2),(2,3)]
14:05:53 <lambdabot>   [(2,3),(3,4)]
14:05:56 <kirindave> edwardk: I have been using over someLens $ (field1 .~ x) >>> (field2 .~ y)
14:06:00 <startling> :t \fn -> itraverse (traverseLeft . fn)
14:06:01 <lambdabot> forall i (t :: * -> *) (f :: * -> *) a c b. (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t (Either a c) -> f (t (Either b c))
14:06:05 <kirindave> edwardk: Is this a reasonable plan?
14:06:15 <rwbarton> "traversty" intentional?
14:06:17 <startling> :t itraverse . traverseLeft
14:06:18 <lambdabot> forall (t :: * -> *) a b a1 b1. TraversableWithIndex (Either a1 b) t => (a1 -> a -> b1) -> t a -> Either b1 (t b)
14:06:18 <edwardk> kirindave: i absolutely hate that syntax =P
14:06:23 <shachaf> rwbarton: echo shachaf | rot13
14:06:28 <kirindave> edwardk: Please tell me how to make better.
14:06:38 <edwardk> kirindave: foo % field1 .~ x % field2 .~ y
14:06:49 <ion> shachaf: Mind blown.
14:06:54 <kirindave> :t (%)
14:06:55 <lambdabot>     Ambiguous occurrence `%'
14:06:55 <lambdabot>     It could refer to either `Data.Ratio.%',
14:06:56 <lambdabot>                              imported from `Data.Ratio' (and originally defined in `GHC.Real')
14:07:00 <kirindave> Lol
14:07:21 <edwardk> ack, cale, can we hide Data.Ratio.(%) in lambdabot?
14:07:31 <monochrom> hahaha, no!
14:07:39 <rwbarton> while we're fixing things can we get rid of one of the Show instances for functions
14:07:39 <Cale> uhhh
14:07:47 <Cale> > id
14:07:48 <lambdabot>   *Exception: show: No overloading for function
14:07:49 <rwbarton> i guess that might not be easy
14:07:51 <rwbarton> oh
14:07:55 <rwbarton> what?
14:07:56 * monochrom appoints himself to be Defender of Data.Ratio.%
14:08:04 <Cale> errr
14:08:15 <edwardk> monochrom: practically every use of % can be replaced safely with /
14:08:22 <kirindave> edwardk: Can I do the % stuff for chained setters in isolation to the initial value?
14:08:24 <shachaf> Cale: lens's (%) is flip ($). Just sayin'.
14:08:39 <Cale> ugh, flip ($)
14:08:47 <kirindave> edwardk: The only reason over came up was because I was raising some mutators from depth 1 to depth N.
14:08:53 <Cale> who would be crazy enough to write their code backwards? :)
14:09:13 <monochrom> I recommend € for flip ($)
14:09:20 <startling> heh
14:09:22 <edwardk> kirindave: sadly i don't have a low enough precedence version of . to let that work without annoying parens
14:09:30 <kirindave> edwardk: 's fine.
14:09:39 <edwardk> > zipper ("hello","world") % down _1 % focus %~ reverse % rezip
14:09:41 <lambdabot>   Ambiguous occurrence `%'
14:09:41 <lambdabot>  It could refer to either `GHC.Real.%',
14:09:41 <lambdabot>           ...
14:09:46 <Cale> @undefine
14:09:49 <kirindave> edwardk: The nice part of "over" is that I can basically bring the depth 1 setters into whatever context I want relatively cleanly.
14:09:50 <edwardk> works a lot better than using the $'s and reading it backwards
14:09:51 <shachaf> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
14:09:52 <lambdabot>   parse error on input `%'
14:09:57 <shachaf> Uh oh.
14:10:01 <kirindave> edwardk: These are small problems tho.
14:10:02 <fmap> > left
14:10:02 <shachaf> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
14:10:02 <lambdabot>   parse error on input `%'
14:10:03 <lambdabot>   parse error on input `%'
14:10:10 <shachaf> I bet Cale forgot the () around hiding (%)
14:10:15 <Cale> yes
14:10:17 <Cale> @undefine
14:10:22 <shachaf> > zipper ("hello","world") % down _1 % fromWithin traverse % focus .~ 'J' % rightmost % focus .~ 'y' % rezip
14:10:24 <lambdabot>   Couldn't match expected type `Control.Lens.Setter.Setting
14:10:24 <lambdabot>                  ...
14:10:32 <startling> how do I compose a lens with (itraverse fn) ?
14:10:34 <kirindave>  indeed.
14:10:41 <kirindave> Poor edwardk
14:10:44 <kirindave> victim of his own success.
14:10:46 <edwardk> startling: use <. .> or <.>
14:10:55 <startling> :t (<.>)
14:10:56 <lambdabot>     Ambiguous occurrence `<.>'
14:10:56 <lambdabot>     It could refer to either `Data.VectorSpace.<.>',
14:10:56 <lambdabot>                              imported from `Data.VectorSpace'
14:10:59 <startling> >:(
14:11:02 <kirindave> edwardk: Is it difficult being famous?
14:11:41 <edwardk> kirindave: it has its moments
14:11:41 <edwardk> hrmm what broke in that zipper?
14:11:41 <edwardk> :t (%)
14:11:43 <lambdabot> forall a. Integral a => a -> a -> Ratio a
14:11:46 <kirindave> Also 3 weeks ago: did not even know what lens meant, let alone Free monad.
14:12:00 <kirindave> Here I am writing a simulator using lenses, free monads, codensity.
14:12:01 <startling> :t (<.)
14:12:02 <lambdabot> forall i (k :: * -> * -> *) b c a. Indexed i k => Index i b c -> (a -> b) -> k a c
14:12:04 <shachaf> I think Cale hid the wrong %
14:12:07 <kirindave> I feel pretty effing smart today. Just so you all know.
14:12:17 <edwardk> shachaf: ah
14:12:17 <edwardk> =(
14:12:26 <startling> edwardk, I'm not seeing it.
14:12:26 <kirindave> Mostly because of leaning on everything Edwardk wrote, but I find that acceptable.
14:12:54 <startling> 9000 people feel the same way.
14:12:54 <jeff_s1> So if I start a program with +RTS -N4, and then I use Data.Binary.decodeFile, why does it use all 4 cores?
14:13:01 <jeff_s1> That seems very strange.
14:13:04 <edwardk> (%) is a pretty integral part of the lens api
14:13:13 <shachaf> @let infixl 1 ▶; x ▶ f = f x
14:13:15 <kirindave> startling: 9000? or Over 9000? </shades>
14:13:15 <lambdabot>  Defined.
14:13:21 <edwardk> shachaf: =P
14:13:43 <Cale> why not just use function composition?
14:13:46 <shachaf> zipper ("hello","world") ▶ down _1 ▶ fromWithin traverse ▶ focus .~ 'J' ▶ rightmost ▶ focus .~ 'y' ▶ rezip
14:13:54 <shachaf> > zipper ("hello","world") ▶ down _1 ▶ fromWithin traverse ▶ focus .~ 'J' ▶ rightmost ▶ focus .~ 'y' ▶ rezip
14:13:55 <lambdabot>   mueval-core: Enum.toEnum{Word8}: tag (56546) is outside of bounds (0,255)
14:14:01 <shachaf> Useless bot.
14:14:04 <edwardk> hah
14:14:10 <thoughtpolice> what
14:14:11 <shachaf> @let infixl 1 |>; x |> f = f x
14:14:13 <lambdabot>  Defined.
14:14:28 <shachaf> > zipper ("hello","world") |> down _1 |> fromWithin traverse |> focus .~ 'J' |> rightmost |> focus .~ 'y' |> rezip
14:14:30 <lambdabot>   ("Jelly","world")
14:14:38 <edwardk> cale: because the foo % field .~ bar   is a vastly more palatable replacement to foo { field = bar } than the alternative
14:14:39 <shachaf> @yarr!
14:14:39 <lambdabot> This is the END for you, you gutter-crawling cur!
14:14:39 <startling> hehe
14:14:53 <Cale> > rezip . (focus .~ 'y') . rightmost . (focus .~ 'J') . fromWithin traverse . down _1 $ zipper ("hello","world")
14:14:55 <lambdabot>   ("Jelly","world")
14:15:10 <shachaf> Cale: Are you actually reading that code?
14:15:11 <edwardk> and i use %~ for mod-equals. so % becomes the natural operator to be applying to the target
14:15:23 <Cale> shachaf: yes, it makes perfect sense
14:15:26 <beaky> > print "Hello, World!"
14:15:28 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
14:15:28 <lambdabot>    arising from a use of ...
14:15:33 <edwardk> the % avoids spurious parens around every assignment
14:15:43 <kirindave> shachaf: Are you getting over your initial typeshock?
14:15:48 <ion> > down _1 >>> fromWithin traverse >>> (focus .~ 'J') >>> rightmost >>> (focus .~ 'y') >>> rezip $ zipper ("hello","world")
14:15:50 <lambdabot>   ("Jelly","world")
14:15:56 <shachaf> kirindave: I fixed a bug involving Bazaar yesterday!
14:15:58 <shachaf> I mean today.
14:16:10 <kirindave> shachaf: Bazaar?
14:16:22 <kirindave> The SCM?
14:16:30 <shachaf> newtype Bazaar a b t = Bazaar { _runBazaar :: forall f. Applicative f => (a -> f b) -> f t }
14:16:44 <Cale> edwardk: I don't understand what's wrong with (field .~ bar) foo
14:17:11 <edwardk> the . version makes sense but is noisy because it has the wrong fixity for almost everything
14:17:11 <edwardk> hence the new operator
14:17:11 <edwardk> i used to call it |> in lens, but calling it % made the code considerably shorter, and more consistent
14:17:11 <edwardk> and the problem with |> is that |>= leads to <|>= not meaning what you might expect if you didn't know about |>=
14:17:44 <kirindave> :t (|>=)
14:17:45 <lambdabot>     Not in scope: `|>='
14:17:45 <lambdabot>     Perhaps you meant one of these:
14:17:45 <lambdabot>       `>=' (imported from Data.Ord), `>>=' (imported from Control.Monad),
14:17:57 <kirindave> I didn't.
14:18:08 <shachaf> ▶ is the future!
14:18:10 <Cale> I guess I mostly prefer to use the non-infix versions of everything in lens.
14:18:12 <rwbarton> i wonder how long that error message is in full
14:18:19 <edwardk> cale: i use very very few ()'s in actual lens code in practice. field .~ bar $ foo  is okay, but you have to read it right to left.
14:18:42 <edwardk> cale: so do i. but i have to admit for large parts of the api the % version is much more readable to me
14:18:43 <jmcarthur> edwardk: i often use <<< instead of (.) for its fixity. would that not be sufficient?
14:18:45 <kirindave> I can see why that's a problem.
14:18:51 <Cale> I mean, we can also do away with the .~'s
14:18:53 <kirindave> Because the lenses compose left-to-right.
14:18:54 <edwardk> jmcarthur: not good enough
14:18:57 <fmap> :t left
14:18:58 <lambdabot>     Ambiguous occurrence `left'
14:18:58 <lambdabot>     It could refer to either `Control.Arrow.left',
14:18:59 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
14:19:12 <Cale> > rezip . set focus 'y' . rightmost . set focus 'J' . fromWithin traverse . down _1 $ zipper ("hello","world")
14:19:13 <lambdabot>   ("Jelly","world")
14:19:22 <edwardk> its got the wrong associativity
14:19:37 <edwardk> cale: thats not so great when you go to use any operator other than set or over
14:19:38 <kirindave> edwardk: Did I miss a monoid appender lens in your lib, or did me adding one for myself break another law I should be but am not aware of?
14:19:48 <edwardk> kirindave: its in Data.Monoid.Lens
14:19:51 <kirindave> Ah
14:20:00 <kirindave> I just missed it.
14:20:18 <Cale> edwardk: What else do you mean?
14:20:18 <hpaste> roconnor pasted “defining duplicate on a kleene store with copatterns” at http://hpaste.org/77174
14:20:31 <edwardk> cale: +~, etc.
14:20:37 <jmcarthur> > rezip <<< focus .~ 'y' <<< rightmost <<< focus .~ 'J' <<< fromWithin traverse <<< down _1 $ zipper ("hello","world")
14:20:38 <lambdabot>   ("Jelly","world")
14:20:51 <rwbarton> jmcarthur: HI I'M COMPOSING A LOT OF FUNCTIONS
14:20:59 <ion> The alot of functions.
14:21:07 <Cale> but +~ is just over
14:21:14 <rwbarton> er, that is, <<< seems a bit "loud" to me
14:21:24 <jmcarthur> i do agree that it's an unnecessarily loud operator
14:21:28 <edwardk> over … (+1)  which is noisier and much longer
14:21:28 <edwardk> i think you mean %~
14:21:35 <shachaf> @let (<<<<<<<<<) = (<<<) <<< (<<<)
14:21:36 <nand`> Cale: good luck finding an infix version of <<>~
14:21:37 <lambdabot>  Defined.
14:21:38 <nand`> jmcarthur: lens in my lambdabot? that's super cool
14:21:40 <nand`> I uh
14:21:42 <nand`> really prefer the left-to-right version with %
14:21:49 <jmcarthur> nand`: that is the topic
14:21:52 <mrpantoufle> :t (<<<<<<<<<)
14:21:53 <lambdabot> forall a (cat :: * -> * -> *) b c a1. Control.Category.Category cat => cat b c -> (a -> cat a1 b) -> a -> cat a1 c
14:22:06 <kirindave> Clippy for lenses. "I see you typed <+===, did you mean to drown your audience is noisy metalanguage?"
14:22:26 <edwardk> :t let fresh = id <+= 1 in fresh
14:22:27 <ion> @@ @djinn @type (<<<<<<<<<) `asAppliedTo` (undefined :: a -> b)
14:22:27 <lambdabot> forall s (m :: * -> *). (Num s, MonadState s m) => m s
14:22:29 <lambdabot>  f a b c d = a (b c d)
14:23:01 <Cale> > over _1 (+5) $ (3,5)
14:23:03 <lambdabot>   (8,5)
14:23:17 <edwardk> > _1 +~ 4 $ (3,5)
14:23:19 <lambdabot>   (7,5)
14:23:35 <jmcarthur> for some reason i haven't had much opportunity to use lenses
14:23:36 <shachaf> overunder score1
14:23:40 <Cale> basically the same, except you don't have to keep track of 80-kajillion infix operators
14:24:31 <Cale> I dunno, maybe I'm weird :)
14:25:03 <startling> is there a traverseEither that takes traversals for Left and Right and applies them to the same Either?
14:25:04 <edwardk> fresh = id <+= 1;       vs. fresh = do x <- get; modify (over id (+1)); return x
14:25:10 <Cale> I don't really see the point of combining all these arithmetical things with the higher order functions
14:25:13 <edwardk> the operators exist for a reason ;)
14:25:17 <Cale> at least, a-priori
14:25:36 <edwardk> and they are a relatively small portion of the api
14:26:31 <edwardk> they all fit a relatively mundane pattern of operator~ or operator=    optionally prefixed by <
14:27:11 <edwardk> cale: i don't expect every user to embrace or use every portion of the api
14:27:35 <edwardk> i don't use the ^$ operator at all, other people would kill me if i removed it
14:28:18 <ion> That looks like a regexp.
14:28:19 <edwardk> but my goal was to establish a relatively large vocabulary of lenses/traversals, etc. and a relatively large vocabulary of combinators that you can use with them
14:28:33 <Cale> right
14:28:48 <Cale> I just think the general ones ought to be basically sufficient :)
14:29:09 <Cale> In that practically anything is reasonably constructed from them without much effort
14:29:14 <edwardk> its like getting used to using a lot of compound words, and being told you must speak in basic english for the rest of your life ;)
14:29:48 <Cale> Well, I think of it like Data.List -- there are a lot of idiomatic combinations of things in there which we don't make definitions for
14:30:05 <simpson> edwardk: I have to be honest, I see (over id (+1)) and I feel like I'm in Factor.
14:30:06 <edwardk> honestly my biggest problem with missing (%) is that i can't paste examples from the haddocks ;)
14:30:10 <Cale> because the compositions are short enough
14:30:55 <edwardk> there are ~800 operators, combinators and types in lens. maybe 40 of them are the ones you don't like ;)
14:30:59 <hpaste> tac-tics pasted “Cabal installing wxc, unknown error” at http://hpaste.org/77175
14:31:08 <johnw> only 800?
14:31:12 <startling> is there a "both" for Either?
14:31:16 <tac-tics> ^ anyone wanna help with a cabal install failure?
14:31:16 <edwardk> johnw: it was 795 at last check
14:31:20 <Cale> edwardk: It's just a fragment of the infix ones that I don't care for
14:31:45 <edwardk> cale: fair nuff. i'm not planning on removing them though. they are damn convenient when writing state code
14:31:51 <Cale> edwardk: sure :)
14:32:21 <johnw> edwardk: one of the cool things Emacs did for me today: integration with sage: http://ftp.newartisans.com/pub/emacs.png
14:32:27 <edwardk> :t chosen
14:32:29 <lambdabot> forall a b (f :: * -> *). Functor f => (a -> f b) -> Either a a -> f (Either b b)
14:32:49 <Cale> edwardk: actually, does <%= have a prefix name? Perhaps it ought to
14:33:00 <edwardk> startling: chosen =)
14:33:02 <edwardk> cale: nope. none of the < versions have prefix names
14:33:16 <startling> edwardk: ah
14:33:34 <startling> oh, I asked for the wrong thing. :(
14:33:46 <efie> is STVector s faster than IOVector, or why should STVector be preferred over IOVector?
14:33:55 <edwardk> startling: ?
14:33:57 <startling> I want something like (a -> f b) -> (c -> f d) -> Either a c -> f (Either b d)
14:34:04 * hackagebot weather-api 0.3.0 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.3.0 (PeterGoncharov)
14:34:24 <edwardk> startling: ah that violates the pattern of lenses. it would be a 'multiplate'-like construction, which falls out of the scope of the library
14:35:12 <startling> edwardk: ah, alright. I'll just write it myself, then
14:35:49 <edwardk> i've been toying with how to implement them nicely with combinators, but they aren't yet packaged anywhere
14:35:49 <edwardk> he problem with them is while they compose for construction they don't offer a nice way to apply them like i can with lenses
14:35:49 <edwardk> the closest i've gotten is you can use arrow sugar (backwards) while constructing them to plumb the lenses to the right place, etc.
14:35:49 <edwardk> :t choosing
14:35:50 <lambdabot> forall (f :: * -> *) s t a s' t'. Functor f => LensLike f s t a a -> LensLike f s' t' a a -> LensLike f (Either s s') (Either t t') a a
14:35:55 <edwardk> is about as close as i get
14:36:09 <startling> meh, it's just \a b = either (fmap Left . a) (fmap Right . b) anyway
14:36:09 <edwardk> but those are pretty esoteric ;)
14:36:11 <Cale> edwardk: for some reason I still prefer  fresh = id <%= (+1)  over the version which uses <+=
14:36:37 <Cale> I'm not sure I can explain why
14:36:46 <edwardk> ballSpeed.both *= multiplier
14:36:49 <edwardk> =)
14:36:58 <johnw> += is pretty handy
14:37:05 <Cale> ballSpeed.both %= (* multiplier)
14:37:18 <edwardk> i prefer the less noisy version. maybe its my c++ heritage
14:37:31 <tac-tics> Anyone on my cabal issue? “Cabal installing wxc, unknown error” at http://hpaste.org/77175
14:37:43 <jfischoff> I'm getting "haddock: internal error: renameType" with my datakind and type family heavy code. Any ideas?
14:37:47 <tac-tics> (if not, the naysayers on Reddit were right :P)
14:37:59 <edwardk> i am parenthesophobic
14:38:01 <Cale> also, that should probably not use both, but should be Vector-valued anyway :P
14:38:06 <Cale> (and use scalar multiplication)
14:38:27 <edwardk> well, i'd in practice use 'linear' which uses _x and _y was accessors for it ;)
14:38:27 <Cale> ballVelocity %= (multiplier *^)
14:38:41 <edwardk> er as
14:38:49 <Cale> see, now you'd need =*^ or some funny thing
14:39:04 <edwardk> i freely admit the convention is limited
14:40:28 <startling> @pl (\p -> e (a p) (b p))
14:40:28 <lambdabot> liftM2 e a b
14:40:32 <startling> huh.
14:41:11 <edwardk> :t (%)
14:41:13 <lambdabot> forall a. Integral a => a -> a -> Ratio a
14:41:20 * edwardk frowns.
14:42:13 <Cale> but rational numbers!
14:42:24 <edwardk> > 1 / 2 :: Rational
14:42:26 <lambdabot>   1 % 2
14:42:29 <edwardk> > 1 % 2 :: Rational
14:42:30 <lambdabot>   1 % 2
14:42:46 <edwardk> waste of a perfectly good operator =P
14:43:47 <edwardk> i'll bet if you grep the logs for the last 2 months in here, and check which % folks were referencing it'd be 5:1 lens over Data.Ratio =P
14:44:02 <Cale> fiiine
14:44:08 <edwardk> =)
14:44:23 * edwardk appreciates cale taking one for the team.
14:44:27 <Cale> @undefine
14:44:32 <edwardk> :t (%)
14:44:33 <lambdabot>     Ambiguous occurrence `%'
14:44:33 <lambdabot>     It could refer to either `Lens.%',
14:44:33 <lambdabot>                              imported from `Control.Lens' at State/L.hs:83:1-19
14:44:38 <Cale> oh, lol
14:45:42 <Cale> Now we get to play which of these 80 other modules is reexporting Data.Ratio's (%)
14:45:59 <edwardk> probably some vector space crap =p
14:46:15 <Cale> oh, wait, what?
14:46:19 <Cale> > 5 % 4
14:46:20 <lambdabot>   4
14:46:27 <Cale> It's just a problem with :t
14:46:33 <edwardk> :t (%)
14:46:34 <lambdabot>     Ambiguous occurrence `%'
14:46:34 <lambdabot>     It could refer to either `Lens.%',
14:46:34 <lambdabot>                              imported from `Control.Lens' at State/L.hs:83:1-19
14:47:01 <Cale> oh, imports.h?
14:47:02 <edwardk> does :t get a different import list?
14:47:38 <startling> traverseEither a b = either (fmap Left . a) (fmap Right . b) is correct, right? there's no law I'm breaking?
14:47:39 <Cale> :t (%)
14:47:40 <lambdabot> forall a b. a -> (a -> b) -> b
14:47:46 <Cale> lol
14:47:47 <Cale> okay
14:47:49 <edwardk> :t traverseEither
14:47:50 <lambdabot>     Not in scope: `traverseEither'
14:47:50 <lambdabot>     Perhaps you meant `traverseRight' (imported from Control.Lens)
14:47:58 <edwardk> startling: i have no laws for those things
14:48:10 <edwardk> startling: and thats the definition i use in my little 'multilens' toy
14:48:14 <beaky> @pl \xs -> foldl (++) [] xs
14:48:14 <lambdabot> foldl (++) []
14:48:19 <startling> edwardk: good to know, thanks
14:48:26 * edwardk hugs cale
14:48:36 <Cale> beaky: btw, foldr is *much* more efficient there
14:48:40 <beaky> > foldr (++) [] [[1,3],[5]]
14:48:42 <lambdabot>   [1,3,5]
14:48:47 <beaky> why is foldr more efficient?
14:48:59 <Cale> beaky: because xs ++ ys costs O(length xs) steps to compute
14:49:02 <edwardk> > foldrOf (traverse.both) (+) z [(a,b),(c,d)]
14:49:03 <lambdabot>   a + (b + (c + (d + z)))
14:49:24 <edwardk> > foldlOf (traverse.both) (+) z [(a,b),(c,d)]
14:49:25 <Cale> beaky: with the right associated fold, all the left lists are short
14:49:25 <lambdabot>   z + a + b + c + d
14:49:38 <Cale> beaky: with the left-associated fold, the left lists grow
14:49:48 <beaky> even with foldl'?
14:49:50 <Cale> and you get quadratically many steps
14:49:57 <beaky> ah
14:50:03 <Cale> foldl' is even worse, because you force some of the evaluation earlier than you need it
14:50:24 <edwardk> cale: can you also expose Data.Data.Lens ?
14:50:35 <ion> Data.Data.Data.Lens
14:50:44 <edwardk> that just gets you uniplate, biplate, and template
14:50:54 <Cale> beaky: also see:
14:50:58 <edwardk> which are really convenient for showing off with lenses
14:51:10 <Cale> > foldr (++) [] [[k,10*k] | k <- [1..]]
14:51:12 <lambdabot>   [1,10,2,20,3,30,4,40,5,50,6,60,7,70,8,80,9,90,10,100,11,110,12,120,13,130,1...
14:51:15 <Cale> > foldl (++) [] [[k,10*k] | k <- [1..]]
14:51:19 <lambdabot>   mueval-core: Time limit exceeded
14:51:21 <Cale> ^^ this will never work
14:51:33 <Cale> the foldr works in the infinite case
14:51:40 <beaky> I don't get why foldr works in that case O.o
14:51:47 <Cale> @src foldr
14:51:48 <lambdabot> foldr f z []     = z
14:51:48 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
14:51:54 <Cale> edwardk: will do
14:52:01 <beaky> ah
14:52:03 <edwardk> much obliged
14:52:08 <Cale> beaky: foldr in the case of a nonempty list immediately passes control to f
14:52:23 <Cale> (as you can see there, f is the first thing on the right of the = sign)
14:52:48 <Cale> So (++) gets to produce its result almost immediately
14:52:51 <beaky> @src foldl
14:52:52 <lambdabot> foldl f z []     = z
14:52:52 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
14:52:57 <edwardk> cale: Data.Monoid.Lens and Data.Bits.Lens are similarly innocuous
14:53:08 <Cale> foldl does nothing but greedily apply itself until it finds the end of the list
14:53:17 <Cale> and never gives f a chance
14:53:26 <shachaf> Poor f
14:53:27 <Cale> So it'll never work on an infinite list
14:53:59 <beaky> in what cases does foldr become worse than foldl and foldl'
14:54:20 <beaky> foldr (+) [a..z]
14:54:31 <beaky> > foldr (+) 0 [a..z]
14:54:34 <lambdabot>   *Exception: not a number
14:54:34 <ion> When the HOF is strict in its second argument.
14:54:48 <beaky> > foldr (+) 0 ['a'..'z']
14:54:48 <johnw> > foldr (+) A [a..z]
14:54:49 <lambdabot>   Not in scope: data constructor `A'
14:54:50 <lambdabot>   can't find file: L.hs
14:54:53 <edwardk> beaky: foldr (+) may be more expensive than foldl' (+) when… what ion said holds.
14:54:53 <Cale> Well, when the function parameter* is strict in its second argument
14:54:56 <johnw> > foldr (+) z [a..y]
14:54:57 <lambdabot>   *Exception: not a number
14:55:00 <johnw> huh
14:55:10 <johnw> i'd think simple-reflect would handle that
14:55:19 <ion> Yeah, what Cale said.
14:55:26 <Cale> johnw: [a..y]?
14:55:30 <Cale> > [a..y]
14:55:32 <lambdabot>   *Exception: not a number
14:55:32 <johnw> no good reason
14:55:41 <Cale> > foldr (+) z [a,b,c]
14:55:42 <lambdabot>   a + (b + (c + z))
14:55:42 <beaky> @src product
14:55:43 <lambdabot> product = foldl (*) 1
14:55:47 <Cale> > foldl (+) z [a,b,c]
14:55:48 <lambdabot>   z + a + b + c
14:55:58 <johnw> > [LT..GT]
14:56:00 <lambdabot>   A section must be enclosed in parentheses thus: (LT.. GT)Not in scope: `LT....
14:56:03 <edwardk> > succ a
14:56:05 <lambdabot>   succ a
14:56:12 <edwardk> > enumFromTo a b
14:56:13 <lambdabot>   *Exception: not a number
14:56:17 <Cale> beaky: Let's look at what happens when we use foldr and foldl and foldl with (+)
14:56:22 <Cale> foldr (+) 0 [1,2,3]
14:56:26 <edwardk> just not a supported operation in the Enum instance for it
14:56:29 <Cale> -> 1 + foldr (+) 0 [1,2,3]
14:56:32 <Cale> er
14:56:34 <Cale> -> 1 + foldr (+) 0 [2,3]
14:56:38 <Cale> rather
14:56:57 <Cale> but now (+) can't do anything until it knows what its second parameter is
14:57:10 <Cale> so it looks at its second parameter, and foldr continues...
14:57:20 <Cale> -> 1 + (2 + foldr (+) 0 [3])
14:57:47 <Cale> and then the second (+) also needs to know its second parameter, and pattern matches it
14:57:59 <Cale> -> 1 + (2 + (3 + foldr (+) 0 []))
14:58:01 <Cale> and again
14:58:06 <Cale> -> 1 + (2 + (3 + 0))
14:58:17 <Cale> and then finally, we start to collapse this stuff
14:58:21 <Cale> -> 1 + (2 + 3)
14:58:26 <startling> "Mnemonically, a Bazaar holds many stores and you can easily add more.", heh
14:58:27 <Cale> -> 1 + 5
14:58:29 <Cale> -> 6
14:59:07 <edwardk> startling: =)
14:59:09 <Cale> beaky: So we can see that we used O(n) space, and also because the pattern matches inside (+) were waiting for their scrutinee to evaluate, O(n) stack
14:59:11 <hpc> startling: a bizzare bazaar it would be when you could add stores no more
14:59:15 <hpc> (say that 5 times fast)
14:59:25 <Cale> oh, beaky was lost
14:59:50 <startling> hpc, indeed.
15:02:07 <Cale> Anyone with wallops on know what's happening?
15:03:47 <geekosaur> haven't seen anything mentioned
15:04:21 <hpc> verne died maybe?
15:08:57 <edwardk> > (["hello","world"],"!!!") % Data.Data.Lens.biplate %~ (reverse :: String -> String)
15:08:58 <lambdabot>   Not in scope: `Data.Data.Lens.biplate'
15:09:40 <edwardk> guess it makes sense that qualified imports don't work =)
15:11:05 <startling> is there a typeclass for creating structures from monadic actions like how traverse is for creating monadic actions from structures?
15:11:17 <startling> well, applicative actions
15:13:15 <startling> @pl \fn p l = fn (p : l)
15:13:15 <lambdabot> (line 1, column 9):
15:13:15 <lambdabot> unexpected "="
15:13:15 <lambdabot> expecting pattern or "->"
15:13:27 <startling> @pl \fn p l -> fn (p : l)
15:13:27 <lambdabot> (. (:)) . (.)
15:13:51 <edwardk> @hoogle distributive
15:13:52 <lambdabot> package distributive
15:13:56 <edwardk> @hackage distributive
15:13:56 <lambdabot> http://hackage.haskell.org/package/distributive
15:14:05 <startling> :t let (.:) = (.).(.) in (.: (:))
15:14:06 <lambdabot> forall b a. ([a] -> b) -> a -> [a] -> b
15:14:09 <edwardk> startling: ^- is about as close as you get, but its not quite what you asked for
15:14:36 <jfischoff> I'm curious as to what people think of my first attempt at adding compile time checks for OpenGL GLSL programming. https://github.com/jfischoff/oxymoron
15:14:39 <startling> edwardk: interesting, thanks
15:15:57 <scp> > let square = product . take 2 . repeat
15:15:59 <lambdabot>   not an expression: `let square = product . take 2 . repeat'
15:15:59 <jfischoff> if anyone knows how I get kind of the kind annotation for data-kinded type level lists that would be great
15:16:05 <scp> =[
15:16:11 <edwardk> cale: thanks again for adding lens to lambdabot. you've made my life a heck of a lot easier
15:16:15 <sipa1024> scp: use @let
15:16:16 <jfischoff> err get rid of
15:16:30 <scp> @let square = product . take 2 . repeat
15:16:32 <lambdabot>  Defined.
15:16:35 <scp> > square 2
15:16:37 <lambdabot>   4
15:16:40 <scp> neat =]
15:16:46 <edwardk> jfischoff: did you already turn on PolyKinds?
15:17:07 <jfischoff> I think so. I think it is a requirement of the singleton library
15:17:10 <startling> what's Unfoldable for?
15:17:21 <edwardk> startling: in recursion-schemes?
15:17:22 <startling> yeah, lensabot is nice to have.
15:17:25 <jfischoff> you don't need them of [*] lists
15:17:50 <jfischoff> yeah polykinds is on
15:18:03 <edwardk> startling: the recursion schemes Unfoldable and Foldable are so i don't have to roll everything around the base-functor and explicit Mu pattern
15:18:18 <startling> edwardk: I'm looking in collections-api, but that's just the first Unfoldable in google
15:18:41 <edwardk> oh, then i have no idea
15:18:43 <edwardk> happy hunting ;)
15:18:54 <startling> It's just something I'd heard of before, wondering whether it might be relevant to what I'm looking for. thanks!
15:19:03 <edwardk> gotta run
15:20:10 <jfischoff> well it still works just would look better if I could write [a, b] instead of (a ': b ': ('[] :: Blah))
15:20:40 * jfischoff wonders if you could use a type quasiquoter as a workaround
15:20:43 <ramses_> :t =<<
15:20:44 <lambdabot> parse error on input `=<<'
15:20:52 <ramses_> :t (=<<)
15:20:53 <lambdabot> forall (m :: * -> *) a b. Monad m => (a -> m b) -> m a -> m b
15:21:05 <ramses_> :t (>>=)
15:21:06 <lambdabot> forall (m :: * -> *) a b. Monad m => m a -> (a -> m b) -> m b
15:24:06 * hackagebot weather-api 0.4.0 - Weather api implemented in haskell  http://hackage.haskell.org/package/weather-api-0.4.0 (PeterGoncharov)
15:26:05 <startling> (.: (:)) is really useful. I'm surprised I haven't come up with it before.
15:26:49 <sipa1024> :t (.: (:))
15:26:50 <lambdabot> forall b a. ([a] -> b) -> a -> [a] -> b
15:27:06 <mauke> @unpl (.: (:))
15:27:06 <lambdabot> (\ a -> a .: ((:)))
15:27:39 <startling> (tail .: (:)) '?' "Hello"
15:27:42 <sipa1024> :t (.:)
15:27:43 <lambdabot> forall (f :: * -> *) (g :: * -> *) a b. (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
15:27:49 <startling> > (tail .: (:)) '?' "Hello
15:27:50 <lambdabot>   <hint>:1:25:
15:27:50 <lambdabot>      lexical error in string/character literal at end of input
15:28:01 <startling> bah
15:28:13 <scp> does anyone have a cool fancy way to do "foo f g x y = f (g x y)"
15:28:30 <startling> scp, f . g x
15:28:37 <startling> > (tail .: (:)) '?' "Hello"
15:28:39 <lambdabot>   "Hello"
15:28:59 <startling> ^ it prepends a thing to a list argument to a function
15:29:05 <scp> startling: I don't yet have x
15:29:06 <Cale> @pl \f g x y -> f (g x y)
15:29:06 <lambdabot> (.) . (.)
15:29:14 <Cale> @pl \x y -> f (g x y)
15:29:14 <lambdabot> (f .) . g
15:29:17 <startling> scp, (.:)
15:29:24 <startling> scp, which is (.) . (.)
15:29:27 <scp> oh, I see
15:29:37 <scp> that makes sense =]
15:29:38 <Cale> (which generalises to fmap . fmap)
15:30:39 <scp> startling: what do I need to import
15:30:55 <nand`> there's one in Data.Function.Pointless
15:31:04 <scp> hehe, nice name
15:31:11 <startling> scp, usually I just do where (.:) = (.).(.)
15:31:16 <startling> I don't need it often
15:31:31 <startling> and it's easy to remember.
15:32:14 <scp> I'm trying to do all the project euler problems point-free
15:32:35 <startling> ouch.
15:32:51 <shachaf> That's a waste of time.
15:33:01 <scp> shachaf: that is the idea, I'm bored =]
15:33:01 <shachaf> A double waste of time: Project Euler *and* point-free.
15:33:09 <shachaf> If you're bored, don't waste time.
15:33:12 <mauke> lambda elimination is mechanical and boring
15:33:22 <mauke> write a program to do it for you!
15:33:38 <shachaf> Writing programs is mechanical and boring.
15:33:44 <shachaf> Write a program to do it for you!
15:33:51 <qasi> So, I'm sure this is a FAQ, but: yesterday, I suddenly had an exception again, where *something* was using negative integers with showIntAtBase (which is explicitly forbidden).
15:34:06 * hackagebot http-conduit-browser 1.6.3.1 - Browser interface to the http-conduit package  http://hackage.haskell.org/package/http-conduit-browser-1.6.3.1 (MikhailKuddah)
15:34:17 <qasi> Luckily, I could somehow guess from the number (that was written out as part of the exception) where the problem somehooow was
15:34:39 <qasi> Because it was not in my code (didn't use showIntAtBase), but "somewhere in one of the libraries" 8)
15:34:58 <baguasquirrel> quick question...
15:35:03 <qasi> And I still don't know where it really is...
15:35:08 <qasi> So how do you debug stuff like that?
15:36:01 <shachaf> qasi: GHC has some sort of stack traces with profiling, which might help.
15:36:04 <shachaf> @where rts-xc
15:36:04 <lambdabot> ghc --make -prof -auto-all -rtsopts -osuf .p_o foo.hs && ./foo +RTS -xc
15:36:04 <Cale> qasi: it can be tricky. There are a bunch of things you can do to help though, like building with profiling turned on and then running the program with +RTS -xc
15:36:06 <baguasquirrel> if I have a type class, "class VectorCl pointType accumType", and it has a member "unit :: accumType", is it possible to create a value of "unit"
15:36:33 <qasi> I read a paper from SPJ once, where GHC was modified to include implicit backtrace-parameters in a certain debugging mode... Don't know if it ever made it into it officially, though
15:36:35 <Cale> which will give a sort of "cost centre trace" of where the error occurred, and maybe give some hints about the way the code got there
15:36:35 <shachaf> Other than that -- well, a good approach might be to avoid evil functions that crash. :-)
15:37:06 <Cale> baguasquirrel: I believe you will want a functional dependency
15:37:08 <qasi> Cale, okay, I will try that, thanks.
15:37:17 <baguasquirrel> @Cale thanks!
15:37:18 <lambdabot> Unknown command, try @list
15:37:26 <Cale> class VectorCl pointType accumType | accumType -> pointType where ...
15:37:38 <qasi> Why did the implicit backtrace parameters for debugging not make it, though? They seemed like a good idea
15:38:19 <Cale> qasi: That's basically the same thing as what I'm talking about
15:38:30 <Cale> qasi: You wouldn't want them compiled in all the time
15:39:13 <qasi> Cale, no, the approach was to have them twice. Once with the implicit debug-Parameters (if desired), once twice.
15:39:41 <baguasquirrel> Cale: apparently, it only works if it's accumType -> pointType, and not the other way around. should've figured that… :)
15:39:57 <Cale> baguasquirrel: right
15:39:59 <qasi> Cale, similarly to profiled versions of libraries. Then again, I really don't know much about profiling (other than how to use it and what to do with it), so maybe it is really much closer to it than I'm thinking
15:40:15 <qasi> I mean, yeah, profiling does something similar.
15:40:19 <Cale> baguasquirrel: because you're going to demand something of type accumType, and it'll have to work out which instance to use
15:40:38 <Cale> baguasquirrel: So there had better be at most one pointType
15:41:21 <Cale> qasi: Well, I don't know exactly which thing you're talking about, there have been a lot of approaches to try to deal with things like this
15:41:37 <Cale> qasi: It's tricky when there's no such thing as a call stack ;)
15:41:40 <qasi> Cale, I'm trying to find the paper...
15:42:06 <shachaf> rwbarton has a dirty trick for this.
15:42:16 <qasi> <Main.rewriteTar,Main.main,Main.CAF><Main.rewriteTar,Main.main,Main.CAF><Main.rewriteTar,Main.main,Main.CAF>FixTar: Numeric.showIntAtBase: applied to negative number -86400
15:42:37 <qasi> Hmm. I've got to say, that's entirely useless. I probably don't have the profiling version of the library that is involved installed, though...
15:44:24 <Cale> ah, recompile with -caf-all?
15:44:35 <lispy> hello
15:44:46 <lispy> how's code?
15:45:08 <Cale> Normally CAFs (constant applicative forms) are collected together into one cost-centre because they're computed at most once, and so while profiling, you usually don't worry about them separately so much.
15:45:13 <qasi> Cale, still no change :( I also reinstalled the library with -p
15:45:17 <Cale> hmm
15:45:30 <ParahSail1n> Vector.fromList seems to be very slow
15:46:30 <Cale> ParahSail1n: hmm
15:46:41 <Cale> ParahSail1n: What list are you applying it to?
15:47:40 <ParahSail1n> one being generated from reading in a large file as lazy bytestring
15:47:58 <qasi> Found the paper! http://research.microsoft.com/en-us/um/people/simonpj/papers/stack-trace/DebugTraces.pdf
15:48:14 <ParahSail1n> specifically, readCollapsed f = ((map (either error id) . unfoldr parse) . BL.lines) `fmap` BL.readFile f
15:48:21 <qasi> Oh, May 2009? Thought it was much older. Must have read it when it was published?
15:49:07 * hackagebot hashable-generics 1.1.7 - Automatically generates Hashable instances with GHC.Generics.  http://hackage.haskell.org/package/hashable-generics-1.1.7 (ClarkGaebel)
15:49:07 <ParahSail1n> and parse :: [BL.ByteString] -> Maybe (Either String (Int, B.ByteString), [BL.ByteString])
15:55:51 <qasi> And sorry, it's by Allwood, SPJ and Eisenbach
15:57:58 <qasi> Hmm. I looked at some of the few works that reference this paper, and so far only one is doing more than just mentioning it in passing. But nothing is going into any problems with the approach.
15:58:38 <qasi> Yeah, it kind of simulates a strict stack, but often that's exactly what one needs (or rather, often that's enough).
15:58:56 <qasi> Like in my case: all I want to know is where (approximately!) the problem is, and then I could investigate further.
15:59:23 <qasi> As it is, I know *absolutely nothing*, it could be any of the used libraries, and the only way I was able to fix/workaround it is by coincidence>
15:59:27 <qasi> <Main.rewriteTar,Main.main,Main.CAF:main><Main.rewriteTar,Main.main,Main.CAF:main><Main.rewriteTar,Main.main,Main.CAF:main>FixTar: Numeric.showIntAtBase: applied to negative number -86400
16:01:00 <qasi> 86400 is the amount of seconds in a day (I think every developer has seen that number pretty often), so I suspected that it must have something to do with the timestamps I'm passing to a library.
16:01:05 <startling> @pl \f v -> writeFile (p </> f) v
16:01:05 <lambdabot> writeFile . (p </>)
16:01:23 <qasi> I still don't know where exactly the problem is, but I was able to restrict all timestamps to be after epoch and that fixed it...
16:04:19 <n1tn4tsn0k> How to translate from (Num a) => a to Int?
16:05:14 <n1tn4tsn0k> average :: (Num a) => [a] -> a
16:05:14 <n1tn4tsn0k> average a = (sum a)/(length a)
16:05:14 <startling> :t fromIntegral
16:05:15 <lambdabot> forall a b. (Integral a, Num b) => a -> b
16:05:25 <n1tn4tsn0k> Shows an error.
16:05:33 <startling> :t (/)
16:05:34 <lambdabot> forall a. Fractional a => a -> a -> a
16:05:45 <coldpizza72i> Cale you there?
16:05:48 <startling> n1tn4tsn0k: ^ (/) isn't defined for all Num.
16:05:54 <startling> n1tn4tsn0k: you may want
16:05:55 <startling> :t div
16:05:57 <lambdabot> forall a. Integral a => a -> a -> a
16:05:57 <n1tn4tsn0k> Oh.
16:05:58 <n1tn4tsn0k> Ok.
16:06:02 <n1tn4tsn0k> To fractional?
16:06:04 <startling> but it still needs to be an Integral
16:06:20 <geekosaur> I think that can't be done as specified
16:06:35 <startling> n1tn4tsn0k, you wouldn't convert things, you'd add different constraints to your type signature
16:07:51 <n1tn4tsn0k> average a = (sum a)/(fromIntegral $ length a)
16:07:54 <n1tn4tsn0k> It works.
16:07:58 <startling> @hoogle Monad m => (a -> m ()) -> a -> m a
16:07:59 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
16:07:59 <lambdabot> Control.Monad (<=<) :: Monad m => (b -> m c) -> (a -> m b) -> (a -> m c)
16:07:59 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
16:08:09 <startling> n1tn4tsn0k: that doesn't mean you should do it.
16:08:25 <n1tn4tsn0k> What should I do then?
16:08:48 <startling> :t \a -> sum a `div` length a
16:08:49 <lambdabot> [Int] -> Int
16:09:06 <startling> oh, you do need a fromIntegral in ther for `length'
16:09:22 <startling> :t \a -> sum a `div` length (fromIntegral a)
16:09:23 <n1tn4tsn0k> startling: then I'll get integral number.
16:09:23 <lambdabot>     No instances for (Integral [Int], Num [a0])
16:09:23 <lambdabot>       arising from a use of `fromIntegral'
16:09:24 <lambdabot>     Possible fix:
16:09:33 <startling> n1tn4tsn0k, what's wrong with that?
16:09:54 <startling> :t \a -> sum a `div` fromIntegral (length a)
16:09:55 <lambdabot> forall a. Integral a => [a] -> a
16:09:58 <n1tn4tsn0k> startling: I do it for laboratory work in physics.
16:10:10 <startling> ah, okay. so yeah, use (/)
16:10:11 <n1tn4tsn0k> I need accuracy.
16:13:41 <beaky> hello
16:14:47 <n1tn4tsn0k> Does Num include Fractional?
16:15:13 <startling> @info Fractional
16:15:13 <lambdabot> Fractional
16:15:35 <startling> n1tn4tsn0k: all Fractionals must also be Nums.
16:16:11 <beaky> I love lists
16:16:29 <n1tn4tsn0k> So, why does it works with average :: (Fractional n) => [n] -> n but doesn't with average :: (Num n) => [n] -> n ?
16:16:29 <beaky> how do haskell lists compare to LISP lists?
16:16:48 <startling> n1tn4tsn0k, because Nums might not be Fractionals
16:17:07 <startling> Num is a superset of Fractional.
16:17:31 <n1tn4tsn0k> Hm.. Ok.
16:17:46 <startling> beaky: they're basically the same. how do you mean?
16:18:50 <beaky> I heard lisp was a language for processing lists
16:19:02 <lispy> beaky: lisp's lists are more like nested tuples
16:19:15 <johnw> they both use cons cells to structure the lists
16:19:19 <beaky> ah
16:19:25 <startling> in lisps, though, you can cons anything
16:19:25 <lispy> beaky: Haskell's lists are more like streams
16:19:33 <startling> and get "improper lists"
16:19:39 <johnw> plus in Lisp you can put atom in the cdr
16:20:04 <startling> that'd be like 1 : 2 in haskell
16:20:20 <johnw> yes, you're right!
16:20:25 <johnw> hadn't even thought to do that
16:20:27 <lispy> beaky: (a, (b, (c, nil))) <-- lisp list. This is why you can do things like hetrogenousness and it's not the same as (a, (b, c))
16:20:54 <johnw> lispy: are there library functions to get the length/etc of a nested tuple construction in Haskell?
16:21:05 <lispy> johnw: there is HList
16:21:07 <nand`> HLi--
16:21:16 <nand`> so
16:21:20 <nand`> now that we have GHC 7.6
16:21:25 <startling> johnw: that could be interesting.
16:21:25 <beaky> ah
16:21:25 <cmccann> all the HList-style fancy heterogeneous list stuff is built from nested tuples, yeah
16:21:25 <nand`> can't we have proper heterogenous lists
16:21:25 <lispy> johnw: but, I've never really seen anyone work with nested tuples in Haskell
16:21:46 <cmccann> and in pleasant symmetry, the type of an HList value is a type-level list of the type of each element
16:22:02 <cmccann> p.s. "pleasant" was a bit sarcastic there
16:22:12 <beaky> :t ("foo", (1, ('b', "ar")))
16:22:13 <lambdabot> forall t. Num t => ([Char], (t, (Char, [Char])))
16:22:26 <beaky> can I implement such lists in haskell?
16:22:47 <parcs`> you just did
16:22:48 <johnw> HList looks a little, um, hairy
16:22:54 <johnw> > ("foo", (1, ('b', "ar")))
16:22:56 <lambdabot>   ("foo",(1,('b',"ar")))
16:22:57 <cmccann> actually doing anything with right-nested tuples in a generic way is very difficult
16:23:06 <cmccann> also ignore HList, it's an antique
16:23:22 <johnw> cmccann: was it supplanted by anything?
16:23:24 <beaky> right
16:23:26 <cmccann> it predates all kinds of new GHC stuff that obsoletes most of oleg's crazy type hacks
16:24:05 <startling> you could probably do it really nicely with DataKinds
16:24:19 <cmccann> johnw, HList uses the old "coercive unification" hack which I think oleg called TypeCast or something bizarre like that
16:24:31 <cmccann> it's equivalent to ~ in GHC
16:24:32 <Philippa> cmccann: is there a modern replacement?
16:24:49 <Philippa> because at least HList is a known quantity
16:25:10 <cmccann> I suspect that about the only thing in HList that you can't replace with newer shiny stuff is TypeEq
16:25:24 <cmccann> because that's a fundamentally horrible hack, not an incidentally horrible one
16:25:25 <beaky> maybe I can uncurry (:)
16:25:30 <beaky> then implement those lisp lists
16:25:35 <Philippa> yeah, I mean: stuff available in HackageDB?
16:25:45 <cmccann> Philippa, not that I know of
16:25:52 <cmccann> people who like this stuff tend to roll their own
16:26:07 <cmccann> people who can't roll their own tend to be scared away by the complexity
16:26:18 <Philippa> yeah. That suggests we could use such a replacement
16:26:20 <startling> haha
16:26:35 <cmccann> I wouldn't really classify HList as something people should simply use as a library
16:27:00 <jmcarthur> HList is more of an experiment that has been taken too seriously
16:27:04 <cmccann> honestly I would discourage anyone who doesn't understand it well enough to implement it themselves from trying to use it at all
16:27:19 <startling> traversals are the coolest. they made my writeTree literally three lines.
16:27:22 <beaky> is a hylomorphism something like sum . (map (-1) [1..10]) ?
16:27:44 <cmccann> jmcarthur, no, it was a work of horror that motivated the GHC folks to add shiny new features just so that nobody would ever, ever want to use HList
16:27:59 <startling> writeTree p t = createDirectoryIfMissing False p >> kids_ (writeFile . (p </>)) ((.:) writeTree (</>) p) t where (.:) = (.).(.)
16:28:04 <jmcarthur> beaky: that could be written as a hylomorphism
16:28:52 <beaky> where can I learn about all teh morphisms?
16:29:22 <parcs`> > map (-1) [1..10]
16:29:23 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
16:29:25 <jmcarthur> beaky: sum could be written as a fold, and map could be written as an unfold. i don't think it's a great example of a hylomorphism, though, since sum is most naturally written as a left fold, and map can be written as either a fold or an unfold
16:29:52 <jmcarthur> parcs`: lol, i didn't think about that at all
16:29:52 <hpc> map would be a paramorphism anyway, iirc
16:30:10 <jmcarthur> finally, sufficient proof for me to believe that NumInstances can be unintuitive
16:30:19 <jmcarthur> (given our choices for syntax sugar)
16:30:42 <hpc> jmcarthur: oh that's always been known ;)
16:30:55 <jmcarthur> hpc: but nobody had convinced me until now
16:31:00 <beaky> will learing about the morphisms make me a better functional programmer?
16:31:14 <johnw> yes, I think so
16:31:31 <jmcarthur> beaky: i think it's an interesting exercise and gives you some good first steps toward a useful way of thinking
16:31:40 <Iceland_jack> I wouldn't really say so, pretty much what jmcarthur said
16:31:45 <jmcarthur> beaky: not necessarily a tool you can practically use directly
16:31:55 <beaky> would be cool if I could create my own data structures, then define what a catamorphism, anamorphism, hylomorphism, paramorphism, isomorphism etc. would be on that structure
16:31:57 <hpc> i would say, learning the morphisms will build you up to things that make you a better programmer
16:31:59 <bxx> parcs how did that work?
16:32:01 <shachaf> morphisms morproblems
16:32:52 <bxx> is there a flag that makes (-1) a function rather than -1
16:33:16 <shachaf> (subtract 1)
16:33:42 <bxx> i know about subtract, just puzzled how this worked. <parcs`> > map (-1) [1..10]
16:33:48 <startling> I sort of wish they just did (- 1) vs (-1)
16:34:09 <startling> bxx, instance Num n => Num (a -> n) where
16:34:23 <beaky> @src subtract
16:34:23 <lambdabot> subtract x y = y - x
16:34:51 <bxx> > map (-1) [1..10]
16:34:53 <lambdabot>   [-1,-1,-1,-1,-1,-1,-1,-1,-1,-1]
16:35:04 <Cale> bxx: There's a Num instance for functions
16:35:24 <Cale> bxx: Which makes fromInteger n be the constant function (\x -> n)
16:35:26 <mauke> > (-1) 1
16:35:27 <lambdabot>   -1
16:35:28 <mauke> > (-1) 2
16:35:30 <lambdabot>   -1
16:35:30 <bxx> I see
16:35:35 <mauke> > pi "hello"
16:35:36 <lambdabot>   3.141592653589793
16:36:01 <shachaf> Someone likes to be unhelpful to people who are learning, so they added weird instances to lambdabot to confuse you. :-(
16:36:07 <beaky> is fromInteger a homomorphism?
16:36:09 <shachaf> Or maybe there's another reason.
16:36:21 <startling> mauke, it also probably encodes "hello" somewhere in pi
16:36:29 <tsou> > 0 undefined
16:36:30 <lambdabot>   0
16:36:42 <nicoo> startling: It should be a CReal then
16:36:49 <nicoo> > pi :: CReal
16:36:50 <lambdabot>   3.1415926535897932384626433832795028841972
16:37:00 <tsou> Cale: when you say "there is ...", you mean where exactly?
16:37:02 <nicoo> > show (pi :: CReal)
16:37:03 <lambdabot>   "3.1415926535897932384626433832795028841972"
16:37:22 <startling> tsou: in lambdabot
16:37:45 <mauke> @hackage NumInstances
16:37:45 <lambdabot> http://hackage.haskell.org/package/NumInstances
16:37:48 <tsou> ah; only, right?
16:38:24 <nicoo> > show 50 (pi :: CReal)
16:38:25 <lambdabot>   The function `GHC.Show.show' is applied to two arguments,
16:38:25 <lambdabot>  but its type `a0...
16:38:34 <startling> tsou: well, you could write it yourself if you like
16:38:37 <startling> and use it elsewhere
16:38:41 <startling> the neat thing is
16:38:44 * nicoo doesn't remeber the proper syntax :°(
16:38:47 <tsou> indeed, I'm wondering why it's useful :P
16:38:52 * nicoo blames beer
16:38:53 <startling> > ((+ 1) * (* 10)) 3
16:38:55 <lambdabot>   120
16:39:20 <startling> i.e. it does * on the output of the functions
16:39:36 <startling> > ((+ 1) * 12) 3
16:39:37 <lambdabot>   48
16:40:36 <tsou> i see, thanks
16:41:06 <startling> it's weird but useful maybe sometimes
16:41:22 <tsou> i mean, i see what you mean here, still can't see where one could put this to use..
16:41:25 <Cale> > sum (map (\c x -> if x == c then 1 else 0) "hello there") 'e'
16:41:26 <lambdabot>   3
16:41:40 <Cale> (not very efficient, mind you)
16:42:38 <beaky> is negate an automorphism?
16:42:45 <beaky> as well as an isomorphism?
16:43:11 <Cale> beaky: not a ring homomorphism, because negate x * negate y is not the same thing as negate (x * y)
16:43:18 <shachaf> > minBound :: Int
16:43:19 <lambdabot>   -9223372036854775808
16:43:20 <shachaf> > negate minBound :: Int
16:43:21 <lambdabot>   -9223372036854775808
16:43:23 <beaky> ah
16:43:34 <startling> @hoogle (a -> b) -> a -> (a, b)
16:43:34 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:43:35 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:43:35 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
16:44:34 <nicoo> @src CReal
16:44:34 <lambdabot> Source not found. Do you think like you type?
16:44:53 <beaky> @src negate
16:44:53 <lambdabot> negate x = 0 - x
16:45:05 <beaky> why 0 in there
16:45:10 <Cale> http://hackage.haskell.org/packages/archive/numbers/3000.1.0.1/doc/html/src/Data-Number-CReal.html
16:45:15 <startling> what does doesFileExist say about special files?
16:45:22 <startling> beaky, because that's what it does
16:45:35 <startling> @desugar -12
16:45:35 <lambdabot> Unknown command, try @list
16:45:37 <Cale> beaky: that's the default implementation when you provide (-) and fromInteger, but not negate
16:45:40 <startling> bah
16:47:29 <shachaf> So how 'bout that extension to specify a minimal complete definition of a type class?
16:49:41 <coldpizza72i> Cale: I made much more progress with my parser but I'm not quite sure how to do the main function http://ideone.com/qk1ARt … do you think you could help me?
16:54:14 <startling> coldpizza72i, your main would just call runParser (do you have that?) and see what happens
16:55:41 <nicoo> > showCReal 50 pi
16:55:41 <shachaf> cmccann: Wait, you're in here too!
16:55:42 <lambdabot>   "3.14159265358979323846264338327950288419716939937511"
16:55:46 <nicoo> > showCReal 150 pi
16:55:47 <lambdabot>   "3.141592653589793238462643383279502884197169399375105820974944592307816406...
16:55:52 <nicoo> :(
16:56:04 <shachaf> @where pi
16:56:05 <lambdabot> I know nothing about pi.
16:56:07 <shachaf> @where pi_10
16:56:07 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
16:56:13 <shachaf> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
16:56:15 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
16:56:49 <edwardk> now, how to make that shorter with lens ;)
16:57:08 <bgamari> Cale and whoever else was worried about Idris's strictness-by-default, I think codata in the new release might be of interest to you
16:57:15 <copumpkin> > (!!2)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
16:57:17 <lambdabot>   "30315926535897932384626433832795028841971693993751058209749445923078164062...
16:57:22 <copumpkin> damn
16:57:30 <copumpkin> > (!!4)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
16:57:34 <edwardk> copumpkin: heh, i recognize that screw up. i made it before =)
16:57:34 <lambdabot>   mueval-core: Time limit exceeded
16:57:37 <copumpkin> lol
16:58:04 <beaky> what are combinators
16:58:50 <coldpizza72i> startling: what does it take as the parameters?
16:59:08 <edwardk> copumpkin: https://raw.github.com/gist/4005130/fadf77d23916d6d2fd845bd81b7222a6594a7c70/Golf.hs
16:59:19 <cmccann> shachaf, your powers of observation are remarkable, I see
16:59:36 <shachaf> cmccann: As remarkable as always.
16:59:39 <copumpkin> edwardk: wow
16:59:47 <edwardk> copumpkin: that shows the evolution of it over time
16:59:56 <edwardk> for both e and pi
17:00:16 <startling> coldpizza72i, it's a Parser -> String -> [(a,String)] . look familiar?
17:00:16 <copumpkin> > (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
17:00:18 <lambdabot>   "27182818284590452353602874713526624977572470936999595749669676277240766303...
17:00:21 <copumpkin> that's pretty good
17:00:33 <coldpizza72i> startling: yea
17:00:34 <edwardk> @src e_10
17:00:34 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:00:34 <copumpkin> is it actually correct? :P
17:00:39 <edwardk> @where e_10
17:00:40 <lambdabot> (!!2)<$>transpose[show$sum$scanl div(10^2^n)[1..2^n]|n<-[0..]]
17:00:45 <copumpkin> > showCReal 100 (exp 1)
17:00:46 <lambdabot>   "2.718281828459045235360287471352662497757247093699959574966967627724076630...
17:00:52 <copumpkin> I guess it's good enough
17:00:55 <edwardk> CReal is considered out of bounds ;)
17:00:58 <copumpkin> I'll prove it in Agda later
17:01:21 <shachaf> What's pi_9?
17:01:30 <shachaf> Is that "using unfair lambdabot extensions"?
17:01:32 <edwardk> @where pi_10
17:01:33 <lambdabot> (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
17:01:36 <edwardk> @where pi_9
17:01:36 <lambdabot> I know nothing about pi_9.
17:01:39 <beaky> @hoogle fix
17:01:39 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
17:01:39 <lambdabot> Data.Fixed module Data.Fixed
17:01:39 <lambdabot> Data.Function fix :: (a -> a) -> a
17:01:50 <shachaf> At the bottom of your file.
17:02:03 <edwardk> oh, no. it just lies. it gets the right result visually, but is only good to a given number of decimal places
17:02:26 <shachaf> Oh.
17:02:30 <edwardk> pi_11 was 'turning it up to 11', making it shorter at the expensive of too long runtime.
17:02:38 <shachaf> > (!!3)<$>transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
17:02:40 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
17:02:41 <shachaf> > (!!3).transpose[show$foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..2^n]|n<-[0..]]
17:02:43 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
17:02:51 <edwardk> pi_9 was named because it was just accesing the 9th element of the list or something originally
17:02:54 <coldpizza72i> startling: does this look right? main = do str <- getLine; runParser (returnP str) str
17:03:06 <edwardk> exactly
17:03:22 <edwardk>  [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])|n<-[0..]]!!9
17:03:22 <edwardk> >  [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])|n<-[0..]]!!9
17:03:24 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
17:03:33 <shachaf> Oh, I remember the trick for pi_9 now.
17:03:39 <edwardk> =)
17:03:40 <shachaf> It wasn't even infinite.
17:03:44 <edwardk> yep
17:03:49 <shachaf> > let pi_9 = [show(foldr(\k a->2*10^2^n+a*k`div`(2*k+1))0[1..4*2^n])|n<-[0..]]!!9 in length pi_9
17:03:51 <lambdabot>   513
17:03:51 <edwardk> just long enough to print the right thing
17:03:52 <mauke> not even infinite!
17:03:53 <mauke> preposterous
17:04:14 <beaky> > let y f = f (y f) in (y (\f x -> if f == 0 then 1 else f * x(f - 1))) 6
17:04:15 <lambdabot>   Occurs check: cannot construct the infinite type:
17:04:15 <lambdabot>    a1 = (a1 -> a0) -> a0O...
17:04:17 <shachaf> edwardk: I'm glad you're keeping track here.
17:04:51 <edwardk> i'm waiting for the next major breakthrough
17:05:02 <shachaf> Maybe this is it.
17:05:12 <beaky> > fix (\n f -> if n == 0 then 1 else n * f(n - 1))
17:05:13 <lambdabot>   Occurs check: cannot construct the infinite type:
17:05:13 <lambdabot>    a1 = (a1 -> a0) -> a0O...
17:05:18 <beaky> infinite type?
17:05:42 <hpc> beaky: like, suppose you wanted to make a list that contained itself three times
17:05:46 <shachaf> We've found the Kolmogorov complexity of pi_10! Must be.
17:05:53 <hpc> the type would be [[[[[[[[[[[[[[[[[[[[[[[[[[
17:05:58 <hpc> etc
17:06:10 <mauke> a@[a]
17:06:25 <hpc> as GHC would say, you are trying to solve the equation a = [a]
17:06:53 <shachaf> Well, actually, pi_10's restriction of "being computable in a reasonable time on lambdabot" makes Kolomogorov complexity perfectly computable.
17:06:57 <nicoo> hpc: Is the type error so explicit ?
17:06:58 <hpc> in your case, you applied something to too many arguments
17:07:05 <nicoo> > \a -> a@[a]
17:07:06 <lambdabot>   Pattern syntax in expression context: a@[a]
17:07:16 <edwardk> the problem with such types is that once you let them into the type system lots of other extensions to the type system become hard or impossible to typecheck and worse, almost everything typechecks
17:07:20 <hpc> and did it just right that ghc hit that error
17:07:48 <shachaf> hpc: Well, beaky just flipped the arguments.
17:07:52 <shachaf> Should be f n
17:08:03 <hpc> edwardk: when you allow infinite types, you are in a sense allowing terms with no defined type
17:13:39 <mikeplus64> @pl foo x >>= \y -> return ((), y)
17:13:39 <lambdabot> (,) () `fmap` foo x
17:14:33 <startling> do getDirectoryContents et al follow symlinks correctly?
17:15:43 <geekosaur> getDirectoryContents does, yes
17:15:56 <startling> what about the readFile s ?
17:16:45 <geekosaur> I think the only thing that doesn't follow symlinks is getSymbolicLinkStatus (and the readlink() api whose name I forget)
17:17:10 <startling> thanks, good to know.
17:20:59 <coldpizza72i> startling: does main = do str <- getLine; runParser (returnP str) str look right?
17:21:55 <Nereid> coldpizza72i: how does that typecheck?
17:22:27 <coldpizza72i> Nereid: Couldn't match expected type `IO b0'           with actual type `[(a0, String)]'
17:22:37 <Nereid> indeed
17:22:45 <Nereid> runParser doesn't return an IO action
17:23:40 <coldpizza72i> Nereid: so how do i fix it?
17:23:58 <startling> coldpizza72i, how do you turn some value into a monadic action for some monad?
17:24:11 <Nereid> coldpizza72i: what do you want to do with the value?
17:25:02 <startling> is there a typeclass for a monad with throw/catch somewhere?
17:25:03 <Nereid> although if returnP is return for the parser monad then that won't actually parse anything
17:27:08 <startling> oh, yeah, that's a weird thing to do
17:27:38 <sclv> startling: there are like three. monadcatchIO is the classic of the bunch
17:27:54 <coldpizza72i> startling: im not sure
17:28:01 <sclv> that's for throw/catch lifted thru a monadIO stack
17:28:22 <sclv> errors that aren't exceptions you can do with MonadError
17:28:49 <startling> yeah, these aren't IO exceptions. I'll look at MonadError, thanks
17:29:32 <Nereid> there's a MonadError instance for IO exceptions though
17:32:50 <mrlemao`> CloudHaskell question: are newLocalNode
17:33:10 <mrlemao`> supposed to be called once per executable?
17:33:35 <sclv> you can call it as many times as you want
17:33:50 <sclv> i still don't understand why one would want multiple local nodes though...
17:34:00 <sclv> maybe for two unrelated uses of cloud haskell by different subsystems
17:34:32 <mrlemao`> the reason I ask is that I am seeing pattern where the send/expect between 2 Process'es just stop
17:35:02 <sclv> hmm
17:35:04 <mrlemao`> client sends to the server, which replies. Client picks up reply and sends another req
17:35:23 <mrlemao`> this one never reaches the server (2 Processes, 1 LocalNode, single executable)
17:35:48 <mrlemao`> I am not sure what is going on nor how to debug it
17:36:06 <sclv> are you sure it doesn't reach the server?
17:36:09 <rwbarton> is the server exiting?
17:36:15 <mrlemao`> well, it's all in the same os process
17:36:22 <rwbarton> is this just a little test program?
17:36:32 <mrlemao`> yes
17:36:36 <sclv> if it is tiny you can hpaste it and i will happily look at it
17:36:41 <mrlemao`> yes
17:37:05 <mrlemao`> 2 files, I will paste Main.hs first.
17:38:37 <hpaste> mrlemao pasted “CloudHaskell: Main.hs” at http://hpaste.org/77179
17:39:15 <hpaste> mrlemao pasted “CloudHaskell: Kitty.hs” at http://hpaste.org/77180
17:40:26 <hpaste> mrlemao pasted “CouldHaskell: output” at http://hpaste.org/77181
17:41:13 <mrlemao`> At first, I forgot to compile with -threaded, but that didnt fix it and I do see the # of htreads increasing when increasing -N
17:41:50 <mrlemao`> It's pretty much the same 'orderCat' that worked the first time, but the second time it just hangs
17:42:45 <sclv> ok, looking at it now
17:44:48 <sclv> oh, i got it!
17:44:52 <sclv> there's only one cat, right?
17:45:02 <sclv> mrlemao`: one cat?
17:45:34 * beaky purrs
17:45:44 <sclv> so look at loopCat
17:45:51 <sclv> it expects a list with at least one element
17:45:52 <mrlemao`> (wasn't my idea :-) )
17:45:58 <sclv> so when it loops there's a pattern match failure and it falls through
17:46:01 <sclv> and then terminates
17:46:09 <sclv> but there's nothing to catch and print the exception
17:46:24 <sclv> so your client thread just dies
17:46:47 <sclv> if you make it a habit to compile with -Wall the incomplete pattern match would have jumped out at you
17:46:54 <sclv> total programming ftw
17:46:57 <mrlemao`> humm, the server yo mean
17:47:15 <sclv> whichever thread you think of as the loopCat one
17:47:27 <sclv> handle the empty case and you're golden
17:49:08 <sclv> this indicates to me that there should be an abstraction on top of spawnLocal that wraps the thread in an error handler
17:49:09 <rwbarton> i guess for extra points you could link your processes
17:49:27 <rwbarton> i think there is
17:49:29 <sclv> yep, linking and monitoring would be the more solid ways to do it
17:49:41 <sclv> you can spawn with monitoring and stuff
17:49:50 <rwbarton> however, it would be nice if doing this simple thing didn't just drop errors on the floor
17:50:07 <sclv> actually the spawnLocal family is relatively impoverished compared to the normal remote spawn
17:50:17 <sclv> lots of compositions of functions not implemented
17:50:30 <rwbarton> maybe your process is getting messages about the failing initCat process and it's just ignoring them, but still
17:50:32 <sclv> yep, its a classic problem in normal multithreaded haskell oo
17:50:33 <mrlemao`> great! I am not sure how I missed that (actually it happens all the time)
17:51:03 <rwbarton> but usually the exceptions make it to the screen, right?
17:51:03 <mrlemao`> do you know how I could catch the exception?
17:51:08 <sclv> rwbarton: yeah I just mean there should be a simple default that logs a message at least
17:51:11 <mrlemao`> no
17:51:12 <rwbarton> right.
17:51:31 <rwbarton> sorry, that was to sclv regarding "a classic problem in normal multithreaded haskell"
17:52:20 <sclv> rwbarton: actually i don't think they do? or they didn't used to -- maybe they changed the runtime behavior a bit since i last worried about this
17:54:13 <sclv> mrlemao`: Control.Distributed.Process includes catch, bracket, etc. lifted to the Process monad
17:55:03 <mrlemao`> So I should take a look at spawnLink and catch/bracket etc
17:55:21 <mrlemao`> let me fix Kitty.hs and see what happens
17:55:55 <beaky> how do I define the Y combinator in Haskell
17:56:30 <sclv> ?go "y combinator" haskell
17:56:30 <lambdabot> Maybe you meant: google googleit do
17:56:41 <sclv> ?google "y combinator" haskell
17:56:43 <lambdabot> http://stackoverflow.com/questions/4273413/y-combinator-in-haskell
17:56:43 <lambdabot> Title: Y Combinator in Haskell - Stack Overflow
17:56:52 <sclv> ^ that's how
17:57:17 <Cale> Y = λf.(λx.f (x x)) (λx.f (x x)) -- in untyped lambda calculus
17:57:33 <Cale> In order to represent this, we can define the newtype:
17:58:23 <Cale> newtype Rec a = InR {outR :: Rec a -> a}
17:58:39 <beaky> maybe we can use unsafeCoerce
17:58:48 <monochrom> I would just write an interpreter for untyped lambda calculus
17:58:49 <Cale> see, what happens when you write:
17:59:03 <monochrom> in fact, I already did
17:59:12 <Cale> :t let y = \f -> (\x -> f (x x)) (\x -> f (x x)) in y
17:59:13 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
17:59:13 <lambdabot>     In the first argument of `x', namely `x'
17:59:13 <lambdabot>     In the first argument of `f', namely `(x x)'
17:59:30 <mauke> :t InR
17:59:31 <Cale> We seem to need a type t1 where t1 is equal to t1 -> t0
17:59:32 <lambdabot> forall a. (Rec a -> a) -> Rec a
18:00:01 <mauke> Rec a = Rec a -> a
18:00:01 <Cale> So, instead of having an *equal* type, it's perhaps good enough just to have an isomorphism between our type t1 and t1 -> t0
18:00:02 <sclv> monochrom: i wrote one in scheme.
18:00:13 <Cale> So, that's what this Rec type is
18:00:17 <Cale> We have a function:
18:00:19 <sclv> it was the shortest program ever
18:00:19 <Cale> :t InR
18:00:20 <lambdabot> forall a. (Rec a -> a) -> Rec a
18:00:23 <sclv> :-P
18:00:25 <beaky> ah
18:00:26 <Cale> and in the other direction
18:00:28 <Cale> :t outR
18:00:29 <lambdabot> forall a. Rec a -> Rec a -> a
18:00:37 <monochrom> hahaha you win!
18:00:38 <Cale> and so:
18:00:59 <monochrom> I implemented SECD in haskell
18:01:05 <Cale> :t let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y
18:01:07 <lambdabot> forall a. (a -> a) -> a
18:01:16 <Cale> and there's your fixed point combinator :)
18:01:20 <mrlemao`> sclv, rwbarton: thanks for your help! I think I may bug you again ...
18:01:22 <Nereid> @let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
18:01:31 <Cale> :t let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
18:01:38 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
18:01:40 <Nereid> wuh
18:01:46 <Cale> heh, wat
18:01:48 <lambdabot>  thread killed
18:01:50 <lambdabot> thread killed
18:01:55 <Cale> lol
18:01:56 <Nereid> @let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
18:01:56 <lambdabot>   mueval: ExitFailure 1
18:01:56 <lambdabot>  mueval: Prelude.undefined
18:02:06 <Cale> let me see what's going on
18:02:09 <Nereid> :P
18:02:10 <monochrom> the two of you are breaking it
18:02:11 <Cale> ssh is being slow
18:02:11 <lambdabot>  thread killed
18:02:19 <Nereid> it's the Y combinator's fault.
18:02:21 <mauke> Nereid: stop trying to break lambdabot
18:02:30 <mauke> I'm just going to @undefine it anyway
18:02:35 <Cale> @undefine
18:02:38 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
18:02:42 <startling> > (\x -> x x) (\x -> xx)
18:02:42 <lambdabot>   mueval-core: Time limit exceeded
18:02:43 <lambdabot>   Not in scope: `xx'
18:02:43 <lambdabot>  Perhaps you meant one of these:
18:02:43 <lambdabot>    `x' (line 1), `x' (i...
18:02:51 <Cale> weird
18:02:56 <Cale> This used to work :)
18:02:58 <Nereid> lambdabutt
18:02:58 <startling> > (\x -> x x) (\x -> x x)
18:02:59 <lambdabot>   Occurs check: cannot construct the infinite type: t1 = t1 -> t0
18:03:03 <startling> >:(
18:03:14 <mauke> > ()
18:03:16 <lambdabot>   ()
18:03:17 <copumpkin> I think Cale should give us that negatively recursive type
18:03:21 <monochrom> (\x -> x x) has the same type problem as Y
18:03:22 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
18:03:24 <copumpkin> so we can write omega and so on
18:03:24 <lambdabot>   3628800
18:03:27 <copumpkin> oh wait!
18:03:30 <Cale> yeah, I don't know what the heck
18:03:31 <copumpkin> he did!
18:03:35 <beaky> :D
18:03:36 <copumpkin> :t InR
18:03:37 <lambdabot> forall a. (Rec a -> a) -> Rec a
18:03:40 <copumpkin> sweet
18:03:42 <copumpkin> thank you Cale
18:03:44 <mauke> :t def
18:03:45 <lambdabot>     Not in scope: `def'
18:03:45 <lambdabot>     Perhaps you meant one of these:
18:03:45 <lambdabot>       `dff' (imported from Data.Graph),
18:03:47 <mauke> aww
18:03:49 <Cale> That's been there for ages
18:03:57 <copumpkin> well
18:04:00 <copumpkin> thank you Cale, ages ago
18:04:05 <Nereid> @let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
18:04:11 <Nereid> ...
18:04:15 <rwbarton> instance Default [Integer] where def = 0 : 1 : zipWith (+) def (tail def)
18:04:20 <monochrom>  @let does not have output
18:04:26 <Nereid> no, it says Defined.
18:04:27 <lambdabot>  thread killed
18:04:32 <monochrom> I see
18:04:34 <Nereid> @let y = 5
18:04:36 <Cale> oh, maybe it's the inliner
18:04:40 <Nereid> haha
18:04:42 <lambdabot>  Defined.
18:04:45 <mauke> @undefine
18:05:38 <Nereid> it's @undefine that doesn't have output.
18:06:02 <Nereid> @let b = b
18:06:04 <lambdabot>  <local>:1:5:
18:06:04 <lambdabot>      Ambiguous occurrence `b'
18:06:05 <lambdabot>      It could refer to either `L....
18:06:05 <mauke> @undefine
18:06:09 <Nereid> eh
18:06:13 <Nereid> @let blah = blah
18:06:14 <lambdabot>  Defined.
18:06:17 <Nereid> hmm.
18:06:24 <monochrom> b is in Expr
18:06:27 <Nereid> right.
18:06:39 <Nereid> @let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) -- :))))
18:06:57 <Nereid> yeah so that breaks it.
18:07:01 <lambdabot>  thread killed
18:07:19 <Nereid> :t y
18:07:22 <lambdabot> Expr
18:07:23 <rwbarton> @let x = x x
18:07:24 <lambdabot>  <local>:2:5:
18:07:24 <lambdabot>      Ambiguous occurrence `x'
18:07:24 <lambdabot>      It could refer to either `L....
18:07:25 <mauke> @undefine
18:07:29 <rwbarton> @let xx = xx xx
18:07:30 <lambdabot>  <local>:1:6:
18:07:30 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t0 ...
18:07:41 <rwbarton> does it do inlining before type checking?
18:07:56 <rwbarton> or is there just no way to do type checking without also doing inlining
18:08:26 <Nereid> @let y = \f -> (\x -> f (x x)) (\x -> f (x x)) -- nope
18:08:26 <crdueck> how do i pattern match on an empty vector from Data.Vector like I would with an empty list?
18:08:27 <lambdabot>  <local>:1:39:
18:08:27 <lambdabot>      Occurs check: cannot construct the infinite type: t1 = t1...
18:09:02 <monochrom> don't pattern-match. do a test on length or something
18:09:05 <Nereid> crdueck: you can't, since you don't have access to the constructors
18:09:35 <rwbarton> you can use view patterns to get a "self-contained" syntax
18:09:46 <rwbarton> f (V.null -> True) = [] etc.
18:10:06 <monochrom> yeah, there is null too
18:10:47 <Nereid> f v | V.null v = [] etc.
18:10:53 <Nereid> a bit shorter
18:11:11 <monochrom> also, do you need the distinction between empty and non-empty? most algorithms work fine with both, same code.
18:11:23 <Nereid> head doesn't
18:11:54 <monochrom> sure, but we seldom ask for "head of a vector"
18:12:20 <kirindave> You know what would save me a lot of keystrokes? Applicative f => f (a -> b) -> a -> f b
18:12:28 <kirindave> Hoogle doesn't seem to find one for me.
18:13:17 <Cale> kirindave: That's  foo x v = fmap ($ v) x
18:13:27 <Cale> no need for Applicative?
18:13:28 <Nereid> and Functor suffices.
18:13:29 <kirindave> Cale Yea it's trivial.
18:13:58 <mauke> :t flip
18:13:59 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
18:14:03 <rwbarton> foiled :P
18:14:10 <Cale> heh, the moment that I put it back!
18:14:22 <mauke> :t fflip
18:14:23 <lambdabot>     Not in scope: `fflip'
18:14:24 <lambdabot>     Perhaps you meant `flip' (imported from Prelude)
18:14:29 <rwbarton> Cale.flip
18:14:36 <Nereid> lol
18:14:55 <shachaf> @yarr
18:14:55 <lambdabot> Smartly me lass
18:14:59 * shachaf wins again!
18:15:03 <Nereid> module Caleskell ((.), flip, ...) where ...
18:15:07 <Nereid> do it
18:15:13 <rwbarton> import Calelude
18:15:26 <Nereid> :t (.)
18:15:27 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
18:15:32 <Nereid> that's still there :v
18:17:14 <kirindave> Missed opportunity to call it quelude.
18:17:43 <kirindave> Cale: Or f a b = f a <*> pure b
18:17:55 <kirindave> Err, f a b = a <*> pure b, sorry
18:18:29 <kirindave> I just often use the pattern of or $ [pred1, pred2] <*> pure thingToTest
18:21:26 <kirindave> Would you guys say that GHC's priority as an implementation is research?
18:21:38 <kirindave> And if so, what kind?
18:21:40 <Nereid> what does that mean?
18:22:09 <kirindave> Nereid: Well soemone is selling me that, "Haskell is great for research, but Clojure is where pragmatic FP is at."
18:22:22 <kirindave> Nereid: And when questioned, "Every language has its priorities."
18:22:31 <Nereid> haskell is great for pragmatic FP
18:22:36 <shachaf> Research is a priority of GHC's.
18:22:38 <shachaf> But not the only one.
18:22:49 <typoclass> kirindave: ghc is likely to have some grad student design a new extension and put it in. unlike, say, gcc
18:23:16 <hpaste> gertc pasted “glib” at http://hpaste.org/77182
18:23:19 <kirindave> typoclass: Yes, but the extension mechanism exists to float trials of stuff.
18:23:37 <kirindave> typoclass: And lord knows there are lots of gcc forks that can't be integrated mainline. Haskell just does that better.
18:23:54 <Nereid> gertc: yes, the gtk2hs from hackage won't build on 7.6
18:23:56 <typoclass> kirindave: yeah, so? floating trials of stuff is research isn't it :-)
18:24:00 <Nereid> http://patch-tag.com/r/hamish/gtk2hs
18:24:10 <gertc> ok thx
18:24:48 <kirindave> typoclass: I take your point. It still feels difficult to put haskell in the same category as, say, Agda?
18:25:39 <typoclass> kirindave: oh that's true, i see what you mean. i don't feel haskell is an academic toy language (apologies to the agda people, i mean in the sense of 'writing and running programs' as opposed to proving things)
18:25:42 <shachaf> kirindave: See http://www.aosabook.org/en/ghc.html
18:25:59 <shachaf> "While the ultimate goal for us, the main developers of GHC, is to produce research rather than code, we consider developing GHC to be an essential prerequisite: the artifacts of research are fed back into GHC, so that GHC can then be used as the basis for further research that builds on these previous ideas. Moreover, it is important that GHC is an industrial-strength product, since this gives greater credence to research results produced ...
18:26:06 <shachaf> ... with it. So while GHC is stuffed full of cutting-edge research ideas, a great deal of effort is put into ensuring that it can be relied on for production use."
18:26:19 <kirindave> shachaf: Beautiful.
18:27:33 <kirindave> shachaf: The conversational equivalent of a suplex.
18:28:13 <kirindave> Cale: It does make me worried. Am I insane for saying or $ [pred1, pred2, pred3] <*> pure thingToTest
18:28:42 <rwbarton> any ($ thingToTest) [pred1, pred2, pred3]
18:28:50 <rwbarton> is that too backwards?
18:28:58 <kirindave> Or is mine? :)
18:29:01 <kirindave> I dunno. Yours is shorter.
18:29:10 <rwbarton> i can see why you might want to have the functions on the left
18:29:20 <typoclass> kirindave: what you quoted, "clojure is for pragmatic fp", is an overly broad statement; i think it means little more than "clojure is currently en vogue among a certain crowd, and they feel they can do great things with it". which of course isn't a bad thing
18:29:42 <simpson> It's like Lisp for hipsters.
18:29:53 <kirindave> typoclass: I agree. And of all the alt.jvm languages Clojure is least likely to inundate you with nonsense.
18:30:32 <kirindave> typoclass: e.g., Scala and it's atrocious build system and schism'd library world and it's god-awful love of combinator libraries by people with no taste in combinator naming.
18:30:44 <kirindave> I feel sad for Scala. :(
18:31:32 <beaky> does haskell support continuations?
18:31:42 <typoclass> kirindave: i agree, from what little i know about clojure, it's not some half-baked thing anchored on buzzwords. rich hickey has experience and is a smart guy. he's done a lot of valuable work on immutable data structures, for instance
18:31:53 <kirindave> Yeah
18:31:55 <Nereid> sup
18:32:01 <mauke> beaky: only in userspace
18:32:06 <kirindave> And his STM stuff is very close to what haskell does for STM. And I think that cell-oriented STM has legs.
18:32:18 <et09> anyone having problems with GLURaw?
18:34:54 <shachaf> @ty or .: sequence
18:34:55 <lambdabot> forall (g :: * -> *). (Monad g, Functor g) => [g Bool] -> g Bool
18:53:42 <mikeplus64> @pl \x -> f (g x >> h x)
18:53:42 <lambdabot> f . liftM2 (>>) g h
19:15:24 <mrlemao`> do any of you know how expensive Channels are in Cloud haskell?
19:16:22 <mrlemao`> is that even a concern for at most 1000's or channels?
19:17:28 <typoclass> mrlemao`: i'm not familiar with cloud haskell, but try it :-) i bet it won't be a concern
19:19:31 <sclv> mrlemao`: my sense of the model is that channels themselves aren't expensive at all, it's just operations on them that are expensive
19:19:42 <sclv> as in things are tagged and multiplexed or whatever
19:19:59 <sclv> so i suspect that if you're only using one channel, then its no mater if you have no other inactive ones, or ten thousand
19:20:09 <sclv> but that's just an intuition based on my understanding of the code
19:30:19 <coldpizza72i> I have got a bit further now but main isn't working properly. Could someone help me out http://ideone.com/ZunyaX
19:32:53 <mrlemao`> sclv: ok. the little Kitty is working great now.
19:33:04 <sclv> cool
19:34:10 <Nereid> coldpizza72i: well duh
19:34:16 <Nereid> coldpizza72i: you know what the "returnP str" parser does, right?
19:36:28 <coldpizza72i> Nereid: not exactly actually
19:36:42 <Nereid> coldpizza72i: it consumes nothing and always returns the result str
19:40:10 <Jafet> Oh, I found a way to get around the (!!)
19:40:16 <Jafet> > [show(foldr(\k a->20*10^(2*n)+a*k`div`(2*k+1))0[1..[4,9..]!!n])!!n|n<-[0..]]
19:40:20 <lambdabot>   mueval-core: Time limit exceeded
19:40:22 <Nereid> coldpizza72i: you went through all that effort to write a parser for a program and then you're not using it.
19:40:39 <coldpizza72i> Nereid: I don't know how to use it
19:40:59 <Jafet> Pft
19:41:17 <Nereid> coldpizza72i: you runParser it
19:41:28 <coldpizza72i> but what do i pass into runParser
19:41:32 <Nereid> your parser
19:43:06 <Jafet> > [show(foldr(\k a->20*10^(2*n)+a*k`div`(2*k+1))0[1..[4,9..]!!n])!!n|n<-[0..]]
19:43:10 <lambdabot>   mueval-core: Time limit exceeded
19:43:23 <Nereid> what is that mess supposed to do
19:43:24 <Jafet> > take 100 $ [show(foldr(\k a->20*10^(2*n)+a*k`div`(2*k+1))0[1..[4,9..]!!n])!!n|n<-[0..]]
19:43:26 <lambdabot>   "31415926535897932384626433832795028841971693993751058209749445923078164062...
19:43:30 <Nereid> oh
19:43:42 <Nereid> lol
19:43:58 <Jafet> Nereid: it should be obvious from the types man
19:44:03 <Nereid> haha
19:46:50 <coldpizza72i> Nereid: so it should be putStrLn (show (runParser proSeq str))  ?
19:46:58 <Nereid> try it!
19:47:10 <coldpizza72i> it compiles but yields []
19:47:27 <Nereid> that means your parser failed
19:50:08 <nand`> what's the easiest way to implement Test.QuickCheck.Arbitrary for a simple, small, bounded, enumerable type like data Foo = Bar | Bat | Baz
19:50:51 <nand`> ah, ‘elements [minBound .. maxBound]’ should do the trick
19:52:09 <Nereid> nand`: or write a Random instance for it first
19:52:26 <Nereid> and use choose or something
19:52:48 <Nereid> actually
19:52:57 <Nereid> just use arbitraryBoundedEnum
19:53:02 <meck> dear lord!
19:53:22 <meck> I couldn't imagine too much people here.
19:53:35 <sclv> only 913.
19:53:37 <sclv> slow night
19:53:58 <sclv> haha i guess we scared him off
19:54:23 <Nereid> lol
19:54:39 <Nereid> nand`: arbitraryBoundedEnum
19:56:06 <nand`> oh, that's what I was looking for :)
19:56:21 * nand` .oO( deriving (Bounded, Enum, Arbitrary) )
19:56:54 <Nereid> :)
20:00:20 <ivanm> oh, is that in QC now?
20:00:26 <ivanm> I tend to define that myself
20:00:40 <Nereid> it's there yeah
20:00:41 <ivanm> @hoogle arbitraryBoundedEnum
20:00:42 <lambdabot> No results found
20:00:52 <Nereid> http://hackage.haskell.org/packages/archive/QuickCheck/latest/doc/html/Test-QuickCheck-Arbitrary.html
20:01:17 <Nereid> since 2.5
20:02:00 <ivanm> hmmm, that looks more efficient than my implementation
20:02:45 <ivanm> that uses [minBound..maxBound] and picks an element from that
20:03:09 <Nereid> that's what nand` would have used earlier
20:03:31 <Mike> hi
20:03:34 <ivanm> ahhh, yeah, he said that
20:03:42 * ivanm waves idly in Mike's general direction
20:03:43 <Mike> how to write a simple program in haskell
20:04:00 <Guest39652> how to write a simple program in haskell
20:04:16 <startling> Guest39652, usually you type it.
20:04:19 <Guest39652> to compare two list
20:04:28 <ivanm> define "compare"
20:04:30 <Jafet> http://memearchive.net/memerial.net/3231/a-newline-in-haskell.jpg
20:04:33 <Nereid> @type compare
20:04:34 <lambdabot> forall a. Ord a => a -> a -> Ordering
20:04:42 <ivanm> are you actually wanting a stand-alone program?
20:04:48 <ivanm> are the lists hard-coded or inputs?
20:05:10 <Guest39652> inputs
20:05:21 <ivanm> what format?
20:05:34 <ivanm> command-line args or an interactive program?
20:06:03 <Guest39652> like list1[1,2,3,] list2[1,2,3,4,5] then its should return a boolen type true
20:06:08 <Guest39652> command line
20:06:12 <mauke> why true?
20:06:16 <mauke> the lists aren't equal
20:06:20 * ivanm heads off to go watch Dredd
20:06:31 <simpson> Guest39652: Why do you want this?
20:06:33 <ivanm> Jafet: oh, by grinning and crossing our arms? :p
20:07:02 <Jafet> Yep, we don't have to print newlines
20:07:08 <Jafet> @hoogle putStrLn
20:07:08 <lambdabot> Prelude putStrLn :: String -> IO ()
20:07:08 <lambdabot> System.IO putStrLn :: String -> IO ()
20:07:09 <lambdabot> Data.ByteString putStrLn :: ByteString -> IO ()
20:07:19 <Guest39652> I was using the logic of comparsion for find the prefix is true for the list1 and lis2
20:07:50 <Guest39652> prefix :: Eq a => [x] -> [x] -> Bool
20:09:43 <typoclass> Guest39652: so, you have this function "prefix" and want to use it, or you want to write it?
20:10:17 <Guest39652> want to write the function
20:11:27 <Guest39652> i have written some basic type like int to compare with the list but i want to compare two lists to check the prefix of one list should match with another one
20:12:52 <Guest39652> member member 1 [2,1,3] = True member 1 [2,3] = False
20:13:26 <Guest39652> member a [] = False member a (b:xs) | a = = b = True | otherwise = member a xs
20:13:52 <simpson> :t elem
20:13:54 <lambdabot> forall a. Eq a => a -> [a] -> Bool
20:14:05 <simpson> Guest39652: So, uh, what are you building? Why do you want this?
20:15:31 <Guest39652> I am just in learning phase
20:15:39 <Guest39652> want to learn haskell
20:19:20 * hackagebot stable-memo 0.2.1 - Memoization based on argument identity  http://hackage.haskell.org/package/stable-memo-0.2.1 (JakeMcArthur)
20:19:54 <shachaf> mauke: How's preflex?
20:22:17 <typoclass> Guest39652: ok very good :-) so, do you know about pattern matching? it splits a list into the first element, and the rest of the elements. an example is "f (x:xs) = ..."
20:22:37 <Nereid> @src elem
20:22:37 <lambdabot> elem x    =  any (== x)
20:22:41 <Nereid> er
20:22:42 <Nereid> @src any
20:22:43 <lambdabot> any p =  or . map p
20:22:46 <Nereid> oh great.
20:22:53 <Jafet> Abstraction, man
20:23:15 <jmcarthur> @src or
20:23:15 <lambdabot> or    =  foldr (||) False
20:23:18 <Nereid> :p
20:23:18 <jmcarthur> @src foldr
20:23:19 <lambdabot> foldr f z []     = z
20:23:19 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
20:23:21 <Nereid> @src map
20:23:22 <lambdabot> map _ []     = []
20:23:22 <lambdabot> map f (x:xs) = f x : map f xs
20:23:23 <Nereid> aww.
20:23:27 <jmcarthur> done!
20:23:38 <Nereid> I was secretly hoping map was defined in terms of foldr.
20:23:50 <shachaf> I imagine that it secretly is.
20:24:04 <Nereid> @type \f -> foldr ((:) . f) []
20:24:06 <lambdabot> forall a a1. (a -> a1) -> [a] -> [a1]
20:24:18 * startling was hoping it was secretly defined in terms of traverse.
20:24:26 <jmcarthur> Nereid: check out the rewrite rules: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.6.0.0/src/GHC-Base.html#map
20:24:35 <Nereid> startling: no, it would be foldr that's defined in terms of that.
20:24:38 <evincar> startling: Use ClassyPrelude.
20:24:40 <startling> @info Identity
20:24:41 <lambdabot> Identity
20:24:44 <jmcarthur> "map"       [~1] forall f xs.   map f xs                = build (\c n -> foldr (mapFB c f) n xs)
20:24:49 <startling> @src Identity
20:24:49 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
20:25:04 <Nereid> jmcarthur: oh man.
20:25:05 <shachaf> > over mapped (+1) [1,2,3]
20:25:07 <lambdabot>   [2,3,4]
20:25:13 <shachaf> There we go!
20:25:25 <jmcarthur> @src over
20:25:25 <lambdabot> Source not found. Wrong!  You cheating scum!
20:25:31 <jmcarthur> :t over
20:25:32 <Nereid> lambdabot has lens now?
20:25:32 <lambdabot> forall s t a b. Setting s t a b -> (a -> b) -> s -> t
20:25:36 <jmcarthur> :t mapped
20:25:37 <lambdabot> on the commandline:
20:25:38 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:25:41 <shachaf> over l f = runIdentity . l (Identity . f)
20:25:42 <jmcarthur> ah lens stuff
20:25:42 <Nereid> haha
20:25:50 <jmcarthur> no wonder i'm not familiar with it
20:25:57 <shachaf> jmcarthur: You should become familiar with lens!
20:25:57 <startling> :t \fn -> runIdentity . traverse (Identity . fn)
20:25:58 <lambdabot> forall (t :: * -> *) a b. Traversable t => (a -> b) -> t a -> t b
20:26:11 <jmcarthur> shachaf: i have not yet come across a situation where i want it
20:26:27 <shachaf> jmcarthur: Maybe you just don't recognize the situations, because you're not familiar with it!
20:26:31 <startling> jmcarthur, you just don't know it yet!
20:26:33 <startling> oh.
20:26:58 <jmcarthur> that is a possibility, although i do feel like i would recognize the situation
20:27:05 <Nereid> when did lambdabot get lens?
20:27:10 <shachaf> Todayish.
20:27:10 <copumpkin> today
20:27:13 <simpson> I get the feeling that, given adequate time and practice, I could just use lens combinators exclusively and stop using the prelude entirely.
20:27:13 <Nereid> cool
20:27:20 <jmcarthur> i rarely reach into something and modify it along some path. usually the most i do is read it
20:27:25 <shachaf> jmcarthur: Well, "lens" provides more than lenses!
20:27:42 <shachaf> It provides traversals and folds.
20:27:47 <jmcarthur> and even when i'm doing modifications, usually the old-school SECs are enough for me
20:27:57 <jmcarthur> traversals and folds sounds nice
20:28:01 <shachaf> Also isomorphisms and zippers and uniplate/etc. and other things.
20:28:15 <jmcarthur> huh, that's a lot more than i thought
20:28:19 <shachaf> jmcarthur: A traversal is just a slight extension of SEC to support Applicative effects.
20:28:26 <jmcarthur> right
20:28:28 <shachaf> type SEC s t a b = (a -> b) -> s -> t
20:28:32 <startling> jmcarthur, traversals are super useful
20:28:40 <shachaf> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
20:29:20 <shachaf> If you pick Identity, you get a plain old SEC.
20:29:24 <shachaf> (Which is what over does.)
20:30:01 <Nereid> :t mapped
20:30:02 <lambdabot> on the commandline:
20:30:02 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:30:04 <Nereid> agh
20:30:16 <shachaf> Cale: ☝
20:30:34 <Cale> wat
20:30:36 <startling> shachaf: did you just get a new keyboard or something?
20:30:38 <shachaf> :t mapped
20:30:39 <lambdabot> on the commandline:
20:30:39 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:30:43 <shachaf> startling: Nope.
20:30:49 <shachaf> Should I have?
20:30:50 <Cale> How did we suddenly start getting that?
20:30:54 <Cale> > 1
20:30:56 <lambdabot>   1
20:30:58 <Cale> :t map
20:30:58 <shachaf> :t map
20:30:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:30:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:31:06 <Cale> w. t. f.
20:31:15 <shachaf> @ty over
20:31:16 <lambdabot> forall s t a b. Setting s t a b -> (a -> b) -> s -> t
20:31:20 <shachaf> @ty folded
20:31:21 <lambdabot> on the commandline:
20:31:21 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:31:25 <Cale> I have no idea
20:31:31 <typoclass> looks like the first line of the message is cut off, and the rest ends up here for some weird reason?
20:31:33 <shachaf> Maybe it's only relevant when you actually use the extension.
20:31:40 <startling> shachaf, you seem more unicodey than usual
20:32:32 <Nereid> mapped has a rank-2 type?
20:32:47 <shachaf> @ty runST
20:32:48 <lambdabot> forall a. (forall s. ST s a) -> a
20:32:51 <Nereid> hmm.
20:33:01 <shachaf> mapped is rank-1, anywya.
20:33:05 <Nereid> hmm.
20:33:09 <shachaf> Cale: Is there a -fglasgow-exts anywhere?
20:33:09 <Nereid> so it is.
20:33:42 <Cale> shachaf: probably
20:33:56 <Cale> But I don't know where it is, or why it's only showing up for some requests
20:33:57 <shachaf> Then get rid of it. :-)
20:34:00 <Cale> :t sduisafhui
20:34:01 <lambdabot> Not in scope: `sduisafhui'
20:34:01 <shachaf> Ah.
20:34:03 <Cale> hmm
20:34:10 <shachaf> @let blah = mapped
20:34:12 <lambdabot>  Defined.
20:34:13 <shachaf> @ty blah
20:34:15 <lambdabot> on the commandline:
20:34:15 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:34:27 <typoclass> shachaf: do you happen know where folded or mapped are defined?
20:34:31 <typoclass> to*
20:34:40 <shachaf> Control.Lens.{Fold,Setter}, I assume.
20:34:48 <typoclass> thanks
20:36:07 <shachaf> @let blam :: Functor f => (a -> Identity b) -> f a -> Identity (f b); blam f = Identity . fmap (runIdentity . f)
20:36:09 <lambdabot>  Defined.
20:36:10 <shachaf> @ty blam
20:36:12 <lambdabot> on the commandline:
20:36:12 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:36:37 <Nereid> heh
20:36:46 <shachaf> @ty fmap
20:36:47 <lambdabot> on the commandline:
20:36:47 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:36:50 <shachaf> Oh.
20:37:00 <shachaf> @ty (>>=)
20:37:01 <lambdabot> forall (m :: * -> *) a b. Monad m => m a -> (a -> m b) -> m b
20:37:02 <Nereid> _heh_
20:37:05 <shachaf> @ty liftM
20:37:07 <lambdabot> on the commandline:
20:37:07 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:37:07 <Nereid> @ty (.)
20:37:09 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
20:37:14 <Nereid> ...
20:37:24 <Nereid> caaaaaaaaaaaaale!
20:37:25 <shachaf> @ty fmap
20:37:26 <lambdabot> on the commandline:
20:37:26 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:37:48 <Cale> @undefine
20:37:55 <Cale> @ty fmap
20:37:56 <Nereid> @ty fmap
20:37:57 <lambdabot> on the commandline:
20:37:57 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:37:58 <lambdabot> on the commandline:
20:37:58 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:37:59 <Nereid> welp
20:38:12 <shachaf> @let (...) = fmap
20:38:14 <lambdabot>  Defined.
20:38:14 <shachaf> @ty (...)
20:38:15 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
20:38:17 <Nereid> haha
20:38:25 <shachaf> @undefine
20:38:29 <Nereid> @ty fmap :: Functor f => (a -> b) -> (f a -> f b)
20:38:30 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
20:38:30 <Cale> @let quux = mapped
20:38:31 <typoclass> lambdabot definitely is entertaining today :-)
20:38:31 <lambdabot>  Defined.
20:38:34 <Cale> :t quux
20:38:36 <lambdabot> on the commandline:
20:38:36 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:38:39 <Nereid> hahaha
20:38:39 <shachaf> @let (@#$%) = fmap
20:38:41 <lambdabot>  Defined.
20:38:43 <shachaf> @ty (@#$%)
20:38:45 <lambdabot> forall (f :: * -> *) a b. Functor f => (a -> b) -> f a -> f b
20:38:53 <Cale> @let (!!!!!) = mapped
20:38:55 <lambdabot>  Defined.
20:38:59 <Cale> :t (!!!!!)
20:39:00 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
20:39:05 <Nereid> what is going on
20:39:07 <shachaf> Fun.
20:39:41 <Nereid> hmm
20:39:54 <Nereid> is there some Functor f, Settable g => f (g a) -> g (f a)
20:40:14 <shachaf> Well, you can write it...
20:40:19 <Nereid> sure.
20:40:36 <Nereid> and then mapped could be defined in terms of it and fmap.
20:41:06 <shachaf> Right now mapped = sets fmap
20:41:07 <shachaf> @ty sets
20:41:12 <lambdabot> on the commandline:
20:41:12 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
20:41:15 <Nereid> oh, silly Settable
20:41:20 <Nereid> there ought to be something more general?
20:41:29 <shachaf> Settable = Identity
20:41:38 <Nereid> yeah
20:42:13 <Nereid> bleh
20:42:16 <Nereid> never mind
20:42:45 <Nereid> :t sequenceA
20:42:47 <lambdabot>     Not in scope: `sequenceA'
20:42:47 <lambdabot>     Perhaps you meant one of these:
20:42:47 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
20:42:56 <Nereid> :t Data.Traversable.sequenceA
20:42:57 <lambdabot> forall (t :: * -> *) (f :: * -> *) a. (Applicative f, Traversable t) => t (f a) -> f (t a)
20:43:06 <Nereid> oh that goes the wrong way.
20:43:10 <Nereid> never mind.
20:43:12 <Nereid> bye
20:46:01 <stupidman> hi...
20:46:26 <stupidman> class Tofu t where tofu :: j a -> t a j
20:47:25 <stupidman> i want to know the kind of tofu in ghci (but  i know it's kind is * -> (* -> *) -> *)
20:48:24 <stupidman> in ghci, :k tofu print error. :i tofu do not show the kind.
20:48:26 <shachaf> Tofu doesn't have a kind.
20:48:37 <shachaf> Well, first, are you talking about tofu or Tofu?
20:48:44 <stupidman> tofu
20:48:52 <shachaf> That's a function. functions have types, not kinds.
20:48:57 <mm_freak> @tell jonkri i received your messages…  just waiting for a time when we're both online =)
20:48:57 <lambdabot> Consider it noted.
20:49:05 <shachaf> hi mm_freak
20:49:15 <shachaf> Any lenses lately?
20:53:52 <stupidman> shachaf, you right. i want to know what kind of "a" and "j" (but i know kind of "a" and "j") using  ghci  like ":k" command
20:54:18 <shachaf> I'm not sure ghci has an option to tell you that.
20:54:25 <shachaf> But you can work it out yourself pretty easily. :-)
20:54:49 <mm_freak> hi there shachaf, no lenses
20:54:52 <stupidman> shachaf. thank a lot :-).
20:55:14 <mm_freak> i can't seem to find a DPH package on hackage that exports the Data.Array.Parallel module
20:56:21 <mm_freak> ah, got it
20:58:19 <Nereid> stupidman: :k Tofu
20:58:48 <Nereid> Tofu :: (* -> (* -> *) -> *) -> Constraint
20:59:46 <Nereid> which means whenever you write Tofu t, t has kind * -> (* -> *) -> *
21:00:47 <Nereid> (or, with PolyKinds: k -> (k -> *) -> *
21:00:49 <stupidman> Nereid , it do not works.
21:00:58 <Nereid> stupidman: works for me in both 7.4.1 and 7.6.1
21:01:06 <stupidman> *Main> :k Tofu  <interactive>:1:1:     Class `Tofu' used as a type     In the type `Tofu'
21:01:23 <shachaf> You probably need to enable ConstraintKinds.
21:01:26 <shachaf> But that's beside the point.
21:01:33 <shachaf> Haskell 2010 classes don't have kinds.
21:01:35 <Nereid> I didn't have to enable anything.
21:01:40 <Nereid> in ghci 7.4.1
21:03:02 <Nereid> stupidman: what version of ghc?
21:03:03 <stupidman> hmm..
21:03:09 <Nereid> anything older than 7.4 won't work
21:03:10 <stupidman> i have 7.0.4 version.
21:03:12 <Nereid> yep
21:03:33 <Nereid> time to ~upgrade~
21:03:37 <bxx> why can't I use | as a function name?
21:03:38 <stupidman> Nereid, thanks a lot. you  helped me. :-)
21:03:46 <shachaf> Nereid: A ConstraintKind still won't really help stupidman.
21:03:54 <Nereid> bxc: because it's used for guards
21:04:07 <bxx> Nereid ah right
21:04:19 <Nereid> shachaf: but he can use :kind to look at the kinds of typeclass arguments
21:04:24 <Nereid> which was the whole point
21:04:55 <stupidman> yes. it's right.
21:05:27 <shachaf> Nereid: That requires figuring out a lot of nonsense about constraints and what not.
21:05:32 <shachaf> And also it only accidentally works.
21:05:39 <Nereid> what's accidental about it?
21:05:47 <shachaf> I.e. if "a" wasn't given as an argument to "t", you wouldn't be able to tell the kind from it.
21:06:19 <Nereid> so it defaults to the simplest kind that works.
21:06:23 <Nereid> unless you have PolyKinds.
21:06:25 <espringe> I've got a [(T, V)] and need to map over it with a function. Would the more idiomatic haskell solution make the function have a signature of  (T,V) -> Result    and use it directly. Or make the function a T -> V -> Result and use uncurry ?
21:07:00 <Nereid> espringe: I'd probably go for the latter, personally.
21:07:00 <typoclass> espringe: i'd say either way is fine
21:07:05 <shachaf> espringe: Depends on what your function happens to be.
21:07:52 <espringe> The function is just a convenience thing, to separate out some of the logic
21:08:03 <espringe> it's not designed to be particularly reusable
21:08:13 <typoclass> > map (\(k,v) -> 42) [(1,"x"), (7, "y")] -- it's the most straightforward thing, it works, *shrug*
21:08:14 <lambdabot>   [42,42]
21:08:16 <typoclass> :-)
21:08:32 <shachaf> @ty fmap
21:08:33 <lambdabot> on the commandline:
21:08:33 <lambdabot>     Warning: -fglasgow-exts is deprecated: Use individual extensions instead
21:08:34 <shachaf> :-(
21:08:42 <mm_freak> espringe: if your function is locally defined and only used once, you could just as well write an uncurried version
21:08:50 <Nereid> true.
21:08:51 <mm_freak> if your function is at the top level, definitely write a curried version
21:09:03 <espringe> Yeah, it's local. Ok, i'll use the tuple version
21:09:04 <espringe> thanks
21:09:16 <Nereid> I'd never write
21:09:22 <Nereid> uncurry (\a b -> ...)
21:09:25 <Nereid> that's just silly. :p
21:09:56 <mm_freak> Nereid: that's too simple a view…  consider:  uncurry . fix
21:10:32 <mm_freak> but mostly it's just useless additional line noise, that's right
21:10:42 <Nereid> huh?
21:10:53 <Nereid> who said anything about fix?
21:11:06 <mm_freak> nobody, but you don't know espringe's function =)
21:11:26 <espringe> Well, this is my function:
21:11:27 <espringe> escape_pair (s, c) = c <$ (try $ string s)
21:11:48 <espringe> Seemed a bit noisey to do inline, so that's why I wanted to pull it out as a function. Then wasn't sure to write it curried or not
21:11:48 <Nereid> do whatever you feel like doing. :p
21:11:56 <startling> :t uncurry . fix
21:11:57 <lambdabot> forall a b c. ((a -> b -> c) -> a -> b -> c) -> (a, b) -> c
21:11:57 <Nereid> neither is bad.
21:13:21 <mm_freak> espringe: just a style note, this is easier to read:  escapePair (s, c) = c <$ try (string s)
21:14:03 <mm_freak> (i think the ($) operator comes from hell)
21:14:08 <Nereid> haha
21:14:30 <Nereid> no, it comes from me. give me all your money.
21:14:56 <mm_freak> it has to…  it's addictive and causes severe health problems later (when reading your $-flattened code)
21:16:14 <espringe> mm_freak: Thanks, that is better indeed
21:16:22 <Nereid> I should charge a dollar every time someone uses $.
21:16:40 <espringe> I got a feeling I'm doing something wrong then :P I'm using it everywhere
21:17:01 <startling> Nereid: do we get one every time we use flip ($)?
21:17:02 <mm_freak> espringe: background: ($) makes your code flat, and flat code is harder to read
21:17:15 <Nereid> startling: use flip id instead :p
21:17:16 <shachaf> mm_freak: Go back to #lisp
21:17:16 <startling> Nereid, or maybe we should get a dividend for every (%)
21:17:36 <mm_freak> i don't like lisp, sorry =)
21:17:47 <espringe> I'm using it a lot like this:
21:17:47 <espringe> return $
21:17:47 <espringe>      if ... then ... else ..
21:17:48 <espringe> for instance
21:17:56 <mm_freak> that's fine
21:17:58 <espringe> And stuff like that
21:18:13 <startling> I do that too.
21:18:28 <Nereid> or blah $ some huge do block
21:18:29 <startling> I did (,) path $ if x then y else z
21:19:55 <espringe> What about code like this:
21:19:56 <espringe>       builtin_pairs l = choice $ uncurry builtin_pair <$> l
21:19:59 <espringe> is that an abuse of $ ?
21:20:22 <Nereid> I'd be fine with that.
21:20:51 <Nereid> but (try $ string s) doesn't even save any parentheses over try (string s)
21:20:51 <Nereid> and it's longer
21:21:30 <Nereid> I guess, generally I'd use it if it saves me from having some large thing inside parentheses.
21:21:47 <Nereid> it's too bad $ is infixr though
21:22:30 <Nereid> because you can always write a $ b $ c as a . b $ c
21:23:03 <Nereid> but there's no $-ified way to write a b c = (a $ b) $ c
21:23:09 <Nereid> without so many parentheses
21:23:48 <mm_freak> espringe: ultimately it's your choice, but often using ($) is just a reflex, when a parenthesized expression would be easier to read
21:24:09 <mm_freak> for example i see no problem with: choice (uncurry builtin_pair <$> l)
21:24:17 <mm_freak> i find that one easier to read
21:24:21 <Nereid> I generally find parentheses easier to read, yeah.
21:24:45 <Nereid> it's just when you have many nested parentheses, or you have some that are split across multiple lines...
21:25:01 <espringe> return $ WDict $ DM.fromList kvs
21:25:01 <espringe> But
21:25:02 <espringe> return (WDict (DM.fromList kvs))   looks really ugly imo
21:25:05 <espringe> I hate matching parens
21:25:12 <espringe> having to match parens, I mean
21:25:12 <mm_freak> i think the former is much more reasonable than the latter
21:25:27 <mm_freak> espringe: don't write for writing, but for reading
21:25:31 <Nereid> return $ WDict (DM.fromList kvs)
21:25:45 <Nereid> I'd probably write this.
21:26:19 <mm_freak> knowing myself i might have written (return . WDict . DM.fromList) kvs
21:26:21 <fruitFly> opinions on text editors? sublime text 2? vim? emacs?
21:26:32 <shachaf> fruitFly: It doesn't matter at all.
21:26:45 <shachaf> Please don't start an editor war.
21:26:49 <mm_freak> fruitFly: you may want to ask in #flamewars or something
21:26:54 <Nereid> a very dangerous question, yes. :p
21:27:01 <rwbarton> that would be a good place for this . vs $ vs () discussion too
21:27:04 <Nereid> fruitFly: I personally use vim, but just pick something you like and stick with it.
21:27:12 <shachaf> ==rwbarton
21:27:21 <shachaf> But at least one of them is vaguely on-topic.
21:27:34 <fruitFly> I suspect vim in the LONG run is the most efficient
21:27:52 <startling> haskell-mode for emacs is very nice, too
21:28:04 <Nereid> but it's ... emacs...
21:28:07 <mm_freak> fruitFly: i second shachaf's opinion…  please don't start an editorwar
21:28:11 <Nereid> ;)
21:28:30 <fruitFly> I feel like I'm with Nereid
21:28:30 <mm_freak> Nereid: don't feed the…  well…  i don't yet know what he is =)
21:28:39 <fruitFly> lol
21:28:50 <shachaf> Are you starting an editor war, fruitFly?
21:28:55 <fruitFly> Vim people seem like elitists.. an I'm an elitist
21:28:58 <Nereid> haha
21:29:02 <shachaf> I specifically asked you not to!
21:29:14 <fruitFly> I'm not shachaf
21:29:14 <mm_freak> ok, troll
21:29:36 <espringe> speaking of editors, I probably should learn how to use one. Manually changing the identation with gedit is starting to kill my soul :D
21:29:56 <fruitFly> let's learn vim espringe:
21:30:03 <fruitFly> lol... don't slay me guys
21:30:06 <mm_freak> espringe: there are some nice editors written in haskell, like leksah =)
21:30:34 <shachaf> @quote gwern
21:30:34 <lambdabot> gwern says:  the laws of thermodynamics protects wallets from being bruteforced
21:30:35 <Nereid> does anyone use yi?
21:30:45 <neworder> Hi guys
21:30:50 <mm_freak> doubt it
21:30:53 <mm_freak> hi there neworder
21:30:56 <espringe> Yeah, I was going to try it and yi -- but installing either would break my existing installed packages in cabal
21:30:59 <espringe> so i haven't bothered :D
21:31:03 <neworder> Is there function closure in Haskell
21:31:08 <mm_freak> espringe: see cabal-dev
21:31:12 <Nereid> neworder: what does that mean?
21:31:34 <espringe> (\ x -> x + someOtherCapturedThing)
21:31:35 <espringe> ?
21:31:45 <Nereid> Haskell has closures. but closures are essential in any functional language.
21:31:56 <mm_freak> neworder: free variables are allowed in lambdas, if that's what you're asking
21:32:04 <mm_freak> and yes, lambdas are first class functions
21:32:15 <neworder> Hmm, I'm trying to understand closures
21:32:24 <neworder> Any places you can refer me to
21:32:34 <mm_freak> neworder: a function together with variables in scope makes up a closure
21:32:36 <neworder> I can't find it in the Haskell book
21:32:44 <neworder> Hmm
21:32:50 <mm_freak> let x = 3 in (\y -> x + y)
21:32:59 <mm_freak> that's a closure, because it carries the value of 'x'
21:33:02 <tricorder42> neworder: how much do you know about scoping?
21:33:10 <espringe> Just think of it as a normal function really, you'll have no problems using them without understanding the definition of a closure
21:33:16 <neworder> not much actually
21:33:18 <neworder> haha
21:33:22 <Nereid> closures are so fundamental in haskell that I'm not surprised they don't explicitly get mentioned.
21:33:27 <mm_freak> neworder: btw, closures are an implementation detail
21:33:31 <neworder> Ah I see
21:33:36 <mm_freak> neworder: think in bound and free variables
21:33:43 <startling> neworder, do you know what "lexical scoping" means?
21:33:43 <mm_freak> in the lambda above 'y' is bound and 'x' is free
21:33:45 <neworder> hmm
21:34:07 <neworder> why mm_freak
21:34:27 <neworder> nope, don't know what is lexical scoping startling
21:34:32 <mm_freak> neworder: intuitively because 'y' is introduced by the lambda itself, while 'x' is from outside
21:34:55 <neworder> Ah I see
21:35:07 <mm_freak> in other words the value of 'y' depends on the function application, the value of 'x' doesn't
21:35:34 <startling> neworder: closures are a way to implement lexical scoping.
21:35:36 <neworder> I see!
21:35:54 <espringe> I think if you introduce the idea of an "inline function" to someone, and you *don't* support capturing the lexical scope -- people are like "wtf? why don't I have access to ... ".
21:36:21 <shachaf> I think "capturing the lexical scope" is the natural concept.
21:36:29 <shachaf> The only reason it might seem unnatural is that your brain has been corrupted.
21:36:29 <mm_freak> neworder: a closure is a technical term for a particular way to implement functions with free variables…  i'm not even sure GHC uses this implementation
21:36:35 <shachaf> Sorry about your brain. :-(
21:36:51 <typoclass> i agree, it's all obvious and intuitive. i wonder why people make such a big deal out of the term closure ...
21:36:53 <Nereid> mm_freak: if I understood what I read of the STG paper correctly, it does
21:36:57 <neworder> Lol, Yeah, My brain is sure corrupted
21:37:02 <Nereid> well, STG does
21:37:15 <neworder> Don't know why I take longer to understand concepts in computer science
21:37:17 <mm_freak> Nereid: not sure if that paper really applies to GHC
21:37:17 <neworder> haha
21:37:20 <Nereid> heh
21:37:27 <espringe> typoclass: probably because the mainstream languages (C++ in C++11 and the new Java) are just getting onto implementing them
21:37:36 <espringe> so now the masses are hearing about it
21:37:52 <mm_freak> neworder: just don't think in closures…  simply think in variable scope
21:38:17 <neworder> hmm, in terms of local and global scopes right
21:38:20 <shachaf> Do You Think In Closures? jmcarthur Does Too!
21:38:22 <typoclass> espringe: hm yeah ... still, it might just as well be called anonymous function
21:38:34 <Nereid> but closures aren't new even among popular languages
21:38:35 <Nereid> python has them
21:38:36 <mm_freak> neworder: there isn't really a global scope in haskell
21:38:41 <Nereid> lua has them
21:38:58 <startling> Nereid, python and lua are pretty lispy
21:39:06 <neworder> I see
21:39:10 <espringe> Well in C++11 at least, it's pretty fair a closure -- as you explicitly say how you want to close over particular variables (reference, value, const etc. )
21:39:12 <neworder> oh yah
21:39:15 <neworder> right
21:39:37 <typoclass> neworder: really, don't worry about it :-) 99% of the time, "closure" means the same as "lambda" or "anonymous function". it's something of the form "\... -> ..."
21:39:39 <mm_freak> neworder: scopes are defined by expressions and their corresponding 'let' and 'where' bindings…  that includes your whole module, since you write "module Main where …"
21:40:05 <Nereid> > let f x = (let g y = x + y in g) in (f 3) 5
21:40:06 <lambdabot>   8
21:40:28 <mm_freak> > let 2 + 2 = 5 in 2 + 2
21:40:29 <lambdabot>   5
21:40:33 <Nereid> :))))
21:40:47 <otters> what seriously
21:40:48 <quest> hi, i have a question.....stuck on homework..i was given a algebraic data type data Expr = Num Float | Id String | App String [ Expr ] , where  the strings are '+' '-' sin cos x / .....so from what i understand in class is, this will expand into a tree of a+b+c+d+e if it is a "+". then, now the question ask us to use lookup a list to change the data in the tree,
21:41:16 <otters> Oh, it just redefines (+)
21:41:17 <otters> of course
21:41:19 <Nereid> yep
21:41:33 <Nereid> > let 2 + 2 = 5 in 2 + 3
21:41:34 <lambdabot>   *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
21:41:37 <mm_freak> quest: i think your message got truncated
21:41:38 <typoclass> mm_freak: sure, that makes it clear ... *sigh*
21:41:38 <quest> im stuck at how to write the pattern matching on the left side of the "="
21:42:20 <quest> umm.....
21:42:22 <espringe> quest: http://en.wikibooks.org/wiki/Haskell/Control_structures#case_expressions
21:42:30 <neworder> Yup, I get it, thanks
21:42:38 <espringe> Scroll down to the where they define "Colour" and match on it
21:42:40 <mm_freak> typoclass: apparently it did ;)
21:43:27 <Nereid> I accidentally screwed up writing a guard in ghci once and redefined "otherwise". :(
21:43:33 <quest> it was truncated at which word
21:43:40 <Nereid> "to change the data in the tree,"
21:43:41 <mm_freak> don't underestimate people's ability to comprehend, just because they are new to haskell =)
21:44:07 <quest> espringe: i didnt get to fully explain my problem
21:44:57 <mm_freak> quest: you may want to write your problem on hpaste.org and just share the link
21:45:13 <mm_freak> if it's really long, consider posting to the haskell-beginners mailing list
21:46:53 <Nereid> or stackoverflow?
21:53:23 <hpaste> quest pasted “algebraic data type” at http://hpaste.org/77185
21:53:34 <quest> just posted
21:54:24 * hackagebot fix-imports 1.0.2 - Program to manage the imports of a haskell module  http://hackage.haskell.org/package/fix-imports-1.0.2 (EvanLaforge)
21:58:31 <quest> http://hpaste.org/77185
22:03:12 <applicative> quest why don't you begin with Exprs of the forms Num x and Id str ?
22:03:49 <applicative> what is eval (Num x) = ?
22:04:02 <applicative> what is eval (Num x) env = ?      rather
22:04:18 <quest> applicative means eval (Num x) as base case
22:04:59 <quest> ?
22:05:21 <quest> then recurse the bigger f?
22:07:15 <applicative> just go through the cases.  Where you need to 'recurse' will become obvious.  The cases are: eval (Num x) = ...; eval (Id str) env = ... ; eval (App str exprs) env = ...
22:07:46 <applicative> you may need to develop env making subcases and so on
22:16:34 <quest> applicative i got a type error when typing this may :: Maybe a -> a may (Just a) = a  eval :: Expr -> Environment -> Float eval (Num x) env         = may (lookup x env)
22:17:02 <quest> im sorry if you cant read that, i will type in hpaste again
22:17:45 <rwbarton> The type errors contain information. Did you read it?
22:17:46 <hpaste> quest pasted “type error” at http://hpaste.org/77186
22:18:06 <quest> in the second argument of lookup
22:18:22 <quest> env is [(string,float)]
22:34:05 <fengshaun_> lyah says all Monads are also Applicative functors.  If I'm making a monad, should I also make it an applicative?
22:34:26 <fengshaun_> or is it enough to just follow the monad laws and forget about applicatives
22:34:41 <shachaf> fengshaun_: You should also make it Applicative.
22:34:52 <fengshaun_> shachaf, thanks
22:35:11 <shachaf> You can make a trivial Applicative instance, though:
22:35:17 <startling> fengshaun_, if you're lazy, instance Applicative MyThing where pure = return; (<*>) = ap
22:35:20 <shachaf> instance Applicative m where pure = return; (<*>) = ap
22:35:28 <fengshaun_> and can I assume a monad is also an applicative all the time?
22:35:43 <shachaf> Unfortunately you can't *assume* it, because the hierarchy is broken. :-(
22:35:48 <shachaf> But in theory yes.
22:36:13 <fengshaun_> so, I have to see it in the docs to be able to assume stuff then!
22:36:45 <fengshaun_> and what is 'ap' in the instance dec?
22:36:57 <shachaf> Look it up in the Monad documentation.
22:37:03 <fengshaun_> shachaf, thanks
22:37:05 <shachaf> @src ap
22:37:05 <lambdabot> ap = liftM2 id
22:37:06 <fengshaun_> startling, thanks
22:37:28 <fengshaun_> shachaf, would ap work in all cases?
22:37:40 <shachaf> ap works for any Monad.
22:37:45 <fengshaun_> great, thanks
22:37:54 <startling> :t ap
22:37:55 <lambdabot> forall (m :: * -> *) a b. Monad m => m (a -> b) -> m a -> m b
22:38:11 <fengshaun_> awesome!
22:38:19 <startling> "for all monads m, there exists a function m (a -> b) -> m a -> m b"
22:51:47 <applicative> quest in the case of eval (Num x) env you dont need the env to find a Float do you?
22:52:47 <quest> applicative yeah! i figured that part out! i did num and id base case already, now doing app str esprs part
22:53:17 <applicative> quest yes good
22:58:22 <hpaste> quest pasted “stucked #2” at http://hpaste.org/77187
22:58:35 <quest> applicative i just posted something
22:58:49 <quest> applicative http://hpaste.org/77187 can you help me check?
23:02:46 <applicative> chg "+" = `sum` should be chg "+" = sum
23:03:37 <Nereid> or maybe it should be chg "+" = (+)
23:03:54 <Nereid> in any case the type signature doesn't work
23:04:21 <applicative> Neried, yeah, but he needs it to operate on a list of floats. The signature has to go indeed.
23:04:44 <Nereid> list?
23:06:09 <applicative> yes, the type is here, http://hpaste.org/77185 Note that it's homework
23:06:45 <stupidman> hmm...
23:06:46 <stupidman> NamedFieldPuns
23:06:51 <stupidman> mistake..
23:06:54 <Nereid> representing operations by strings, gross
23:07:20 <applicative> quest: this chg function is the hardest part of the problem.  Supposing you have it defined, the case of App str exprs is easier than you think
23:08:29 <stupidman> data Person = Person { name :: String , age :: Int } deriving Show
23:08:30 <stupidman> data Pet    = Pet    { name :: String , age :: Int } deriving Show
23:08:42 <stupidman> in mydata.hs
23:08:51 <quest> applicative so i have to define a new function for it, that converts string....am thinking of chg :: String -> [Float] -> Float but then I have like 8 "strings"
23:09:10 <applicative> exactly  the type you want, yes
23:10:11 <stupidman> in the one haskell file, there is no way that record field name have same name like "name" ?
23:10:19 <Nereid> correct
23:10:59 <stupidman> why? i think it is not good way.
23:11:26 <Nereid> well, the short answer is that record fields define functions of the same name
23:11:38 <stupidman> i know that.
23:11:47 <applicative> quest: yes you just have to go through the cases; it will be hard to figure out what to do with / and - it seems a bit indeterminate
23:11:56 <Nereid> but lots of us know that it's kind of an issue
23:12:32 <Nereid> http://hackage.haskell.org/trac/ghc/wiki/Records
23:12:55 <stupidman> i think , it could be..Person.name or..PersonName..automatically generated.
23:13:13 <stupidman> Neried : thanks .
23:13:19 <Nereid> you could name your fields something like personName, but
23:13:22 <Nereid> yeah.
23:18:03 <Nereid> and then you could write a class HasName a where name :: a -> String, and write HasName instances for Person and so on, but that quickly gets annoying too
23:23:25 <stupidman> hmm.. thanks for a good information, but as you say , i think it's painful defing typeclass for it.
23:24:00 <loserone> what information?
23:24:20 <stupidman> <Nereid> and then you could write a class HasName a where name :: a -> String, and write HasName instances for Person and so on, but that quickly gets annoying too
23:24:22 <loserone> sadly i was disconect
23:25:42 <stupidman> loserone : we are talking about <Nereid>  namespacing for record field names  , http://hackage.haskell.org/trac/ghc/wiki/Records
23:29:03 <quest> OMG applicative i did it!!! cant believe it :O
23:30:38 <hpaste> quest pasted “done” at http://hpaste.org/77188
23:31:00 <quest> applicative thank you :))))
23:55:58 <Superbest> Hi
23:56:40 <Superbest> So I decided to learn Haskell, but is there a good IDE with syntax highlighting, code folding, and useful refactoring features for Haskell like, say, VS2010/2012?
23:57:06 <shachaf> There are some IDEs but most people don't use them.
23:58:29 <Superbest> so which ones are more feature-complete?
23:58:46 <startling> emacs is certainly not lacking for features
23:58:59 <lolcathost> Superbest: IDEs mainly help you deal with boilerplate and refactoring. Haskell programmers seldom need help with those, because the language is succinct and its type system is the best refactoring tool ever.
23:59:11 <dimka> Superbest: http://www.haskell.org/haskellwiki/IDEs
23:59:31 * hackagebot Elm 0.5.0.2 - The Elm language module.  http://hackage.haskell.org/package/Elm-0.5.0.2 (EvanCzaplicki)
23:59:43 <Saizan> lolcathost: we could do with some automatization though
