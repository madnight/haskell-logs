00:01:35 <hpaste> killy9999 pasted “Problems with Eval monad” at http://hpaste.org/77599
00:02:00 <killy9999> I'm learning how to work woth parallelism in Haskell
00:02:21 <killy9999> and it seems that I don't understand something fundamental about Eval monad and rpar
00:02:41 <killy9999> can anyone give me a hint what am I doing wrong?
00:02:51 <johnw> try $! instead of $ on line 31
00:03:06 <killy9999> ok
00:03:09 <johnw> wait, no, that's not enough
00:03:19 <johnw> use $!!
00:03:44 <shachaf> Did someone just say DeepSeq? :-(
00:03:50 <johnw> he already imported it
00:03:56 <johnw> so i felt justified :)
00:04:11 <killy9999> nope
00:04:17 <johnw> and $!! with (x,y) isn't too bad
00:04:17 <killy9999> still no sparks :/
00:04:32 <killy9999> SPARKS: 0 (0 converted, 0 overflowed, 0 dud, 0 GC'd, 0 fizzled)
00:05:02 <johnw> does it return the correct result?
00:05:26 <killy9999> yes
00:06:07 <killy9999> just realized that liftM force is unnecessary in inParallel
00:06:07 <johnw> i'm not familiar with the Eval Monad
00:06:26 <killy9999> and I also think that liftM force should do the same as $!!
00:06:58 <johnw> ah, http://ghcmutterings.wordpress.com/2010/08/20/parallel-programming-in-haskell-with-explicit-futures/ is a good intro to them
00:07:14 <killy9999> I'll take a look
00:07:22 <killy9999> I'm learning from Marlow's tutorial
00:07:51 <johnw> i didn't realize rpar was a function from the Eval monad
00:08:01 <killy9999> oh, this post is also by Marlow :)
00:08:40 <johnw> killy9999: ah, force and $!! are exactly equivalent in this context
00:08:51 <killy9999> yes
00:09:12 <johnw> f $!! x = x `deepseq` f x; force x = x `deepseq` x
00:09:22 <killy9999> so it seems that the expression is evaluated
00:09:23 <johnw> so, maybe not exactly equivalent
00:09:26 <shachaf> johnw: You're a deepseq expert, right?
00:09:37 <johnw> force forces the return value from f, $!! forces the arguments to f
00:09:41 <shachaf> How do I force evaluation of my input data in Criterion before starting?
00:09:42 <killy9999> and rpar is a strategy for paralle evaluation
00:09:43 <johnw> shachaf: hardly!
00:09:56 <killy9999> shachaf: you don't have to
00:09:56 <shachaf> Does Criterion have a function for it?
00:10:03 <johnw> shachaf: show me your bench call?
00:10:10 <killy9999> it does that automagically
00:10:14 <shachaf> bench "blah" $ nf (...) xs
00:10:23 <johnw> that should do it
00:10:24 <killy9999> as far as I was able to verify
00:10:29 <johnw> that's what the whole separation of (...) and xs is about
00:10:34 <shachaf> Ah, makes sense.
00:10:50 <johnw> wow, the day you ask me a Haskell question marks a watershed moment in my learning process
00:11:01 <shachaf> I've never really used Criterion before!
00:11:06 <johnw> the pupil has become the master
00:11:14 <johnw> MUHAHAHAHAHAHAHA
00:11:37 <johnw> i only learned Criterion like last Monday
00:11:43 <shachaf> johnw: My secret is that I'm much better at frowning than I am at Haskell.
00:11:48 <johnw> lol
00:11:53 <johnw> but you frown at exactly the right times
00:12:00 * hackagebot data-dword 0.2.1 - Stick two binary words together to get a bigger one  http://hackage.haskell.org/package/data-dword-0.2.1 (MikhailVorozhtsov)
00:12:04 <shachaf> That reminds me of a joke.
00:19:55 <shachaf> Hmm, these look exactly the same to me.
00:19:55 <shachaf> grrr = \ (xs_a1RV :: [()]) -> map @ () @ () lvl_r3xY xs_a1RV
00:19:55 <shachaf> gmmm = \ (xs_a1RW :: [()]) -> map @ () @ () lvl_r3xY xs_a1RW
00:27:29 <shachaf> I like how this answer on stackoverflow.com links to the GHC 2.10 manual.
00:28:03 <mjrosenb> shachaf: link?
00:28:04 <johnw> upvote it!
00:28:28 <shachaf> mjrosenb: http://stackoverflow.com/questions/13339813/haskell-libraries
00:28:39 <shachaf> I assume it was just the first result on Google. I've run into that before.
00:29:16 <startling> "or for a more updated explanation:" ...
00:29:32 <startling> in case you're not using a version likely older than you
00:31:00 <shachaf> «Without `-O' it puts in just the minimum; with `-O' it lobs in a whole pile of stuff.»
00:31:06 <shachaf> They don't write GHC manuals like this anymore.
00:32:34 <startling> they should write it in the style of http://xkcd.com/1133/
00:33:42 <johnw> is that comic making fun of something I missed (don't watch TV)?
00:38:27 <startling> johnw: no, it's just using the 1000 most common words
00:38:44 <johnw> I love the title, "The Up Goer Five" :)
00:39:17 <johnw> reminds me of that study they did measuring language complexity in the various US State of the Union addresses
00:39:26 <startling> haskell might be better off if we only used the 1,000 most common words, actually.
00:40:37 <fenton> anyone use xmonad and gentoo?
00:40:41 <johnw> http://blog.lib.umn.edu/cspg/smartpolitics/2010/01/professor_obama_presidents_sta.php
00:40:56 <johnw> startling: actually, with C
00:41:07 <johnw> T we could probably get away with 100, and then just compose them
00:41:51 <startling> johnw: what are 'C' and 'T' in those messages?
00:42:00 <johnw> CT, sorry
00:42:02 <johnw> Category Theory
00:42:15 <johnw> sometimes my finger hits the return key before I'm ready
00:42:34 <fenton> trying to setup a decent haskell development platform...on a unix...is gentoo the best platform for it...arch wasn't much good for me.  just trying to sense what other people use, so i can follow the common road.
00:42:46 <shachaf> Gentoo and Arch should both be fine.
00:42:59 <startling> johnw: oh heh
00:43:09 <shachaf> So should Debian and Ubuntu and most other things.
00:43:10 <fenton> didn't like arch, cause darcs wouldn't compile...
00:43:31 <johnw> i keep waiting for darcs to die
00:43:58 <startling> johnw: don't you mean "merge"?
00:44:10 <johnw> if I wanted to keep any of it, sure
00:44:14 <fenton> johnw: lol...well projects i'd like to help on are using darcs...
00:44:15 <johnw> git merge --ours darcs :)
00:44:25 <johnw> fenton: yeah, that's why I have it installed too
00:44:36 <startling> johnw, no, no, you're waiting for your merge to finish
00:44:42 <Cale> darcs' commandline user interface is so much better than git's though
00:44:42 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
00:44:55 <johnw> Cale: only if you know darcs
00:45:00 <johnw> i quite like git's command-line interface
00:45:33 <Ghoul> I think git's matching system sucks
00:45:33 <johnw> my real problem with the <10 repositories on my machine that use darcs, hg and bzr is that I just never remember how to do anything in them
00:45:40 <johnw> matching system?
00:46:03 <Ghoul> /s/matching/patching recognition, whatecer
00:46:06 <Ghoul> *whatever.
00:46:12 <johnw> you mean, the merge algorithms?
00:46:17 <Ghoul> It splices entire lines.
00:46:21 <Ghoul> In an add/remove fashion
00:46:33 <johnw> what does darcs do?  word-wise?
00:46:50 <Cale> I'm pretty sure darcs is similar in that regard
00:46:57 <Ghoul> No idea.
00:47:01 * hackagebot aws-sdk 0.6.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.6.0.0 (YusukeNomura)
00:47:02 <johnw> lol
00:47:05 <Ghoul> Only used svn and git.
00:47:05 <johnw> ok then ;)
00:47:09 <Cale> But darcs does a better job of keeping track of how changes developed over time
00:47:11 <Cale> when merging
00:47:28 <johnw> yeah, maybe
00:47:28 <Cale> it considers the entire history, not just the common ancestor and the endpoints of the two branches
00:47:34 <fenton> i'm definitely intreagued by it's tracking mechanism...seems quite novel
00:47:50 <johnw> Cale: Git tracks the sub-histories of all branches that were ever merged in too
00:47:53 <fenton> no chronology...bit harder to conceptualize
00:48:07 <Cale> johnw: I mean, when computing the merge
00:48:21 <johnw> Cale: have you tried "merge -s recurse -X patience"?
00:48:46 <johnw> "With this option, merge-recursive spends a little extra time to avoid mismerges that sometimes occur due to unimportant matching lines (e.g., braces from distinct functions). Use this when the branches to be merged have diverged wildly."
00:49:13 <johnw> but if darcs considers the entire history, that's pretty cool
00:49:44 <johnw> i'd like an option to git merge that made it take way more time, but produce better results
00:49:56 <johnw> i've dealt with merges before that resulted in hundreds of conflicts I had to vet by hand
00:50:54 <startling> ouch
00:51:11 <startling> johnw: this was C++, wasn't it?
00:51:15 <johnw> yeah, the company had been maintaining a compiler fork for 10 years without merging from upstream
00:51:18 <johnw> yeah
00:51:38 <startling> hehe
00:51:44 <johnw> at least it was a paying contract, but I wouldn't call it a fun one
00:52:19 <johnw> they finally merged that work into their mainline like 3 weeks ago, after more than 2 years of work (not man years, calendar years)
00:53:24 <johnw> and they still use CVS!
00:53:42 <johnw> so task one was to convert everything to Git, do the merging there, and then export it back :)
00:54:00 <johnw> at least you never see RCS anymore
01:07:01 * hackagebot leveldb-haskell 0.2.0 - Haskell bindings to LevelDB  http://hackage.haskell.org/package/leveldb-haskell-0.2.0 (KimAltintop)
01:12:30 <hpaste> Adrian pasted “Certificate Verification” at http://hpaste.org/77600
01:13:02 <adek05> I wonder what is wrong with this parsing of certificate, I get:  StreamConstructionWrongSize
01:33:04 <neworder> For this expression, let x = 1:x in x
01:33:19 <neworder> Is it computed from left to right or from right to left?
01:33:44 <neworder> I expanded it, and got this
01:33:45 <neworder> 1:(1:(1:(1:(1:x))))
01:34:00 <t7> right to left lol
01:34:24 <t7> neworder: look up the fixity of (:)
01:34:30 <t7> its left to right
01:35:21 <neworder> hmm ok
01:38:09 <Ralith> t7: fixity and evaluation order are different things.
01:38:37 <t7> i thought that would be the case
01:38:47 <t7> its too early for me to think about it
01:38:59 <Ralith> then perhaps it is too early to advise people on it :P
01:39:11 <t7> i want to be part of the group
01:40:28 <kranius> you mean, category
01:40:59 <mauke> how does fixity even matter here; there's only one (:)
01:41:57 <t7> i got mixed up with a variant of haskell that has a determined, strict evaluation order
01:46:38 <neworder> I don't really get why fix (const "hello") returns "hello"
01:47:00 <t7> lazyness
01:47:44 <hpaste> kosta pasted “warp” at http://hpaste.org/77601
01:48:26 <Kosta1> Hi! I'm fooling around with the warp web server. The pasted code prints "Listening on port 3000", but now "Sending response"
01:49:09 <Kosta1> application has type Control.Monad.Trans.Resource.ResourceT IO Response, that's why I'm doing return $ putStrLn "Sending response"
01:49:16 <Kosta1> any idea what I'm doing wrong?
01:49:47 <neworder> hmm
01:50:10 <ClaudiusMaximus> that won't do what you want, you need to liftIO or something similar
01:50:40 <neworder> fix (const "hello")=(const "hello") fix (const "hello")
01:50:43 <neworder> eh
01:50:50 <neworder> How is it evaluated? =)
01:51:04 <Kosta1> neworder: what do you exactly?
01:51:49 <donri> isn't there some way to detect haddock via CPP?
01:51:50 <neworder> Kostal, you mean how I evaluate it
01:53:45 <Kosta1> neworder: sorry, I though you were talking about my paste, but I think you're not :)
01:54:03 <neworder> Haha
01:54:05 <neworder> yeah
01:54:11 <neworder> Not talking about your paste
01:54:28 <neworder> > fix (const "hello")
01:54:29 <lambdabot>   "hello"
01:54:37 <neworder> I wonder why
01:58:04 <Kosta1> ClaudiusMaximus: Yes, using liftIO it works
01:59:32 <fmap> > fix f :: Expr
01:59:34 <lambdabot>   f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (f (...
01:59:46 <fmap> > const "hello" undefined
01:59:48 <lambdabot>   "hello"
01:59:49 <Kosta1> However, I don't really understand why... but well, maybe I'm smarter after reading the corresponding "real world haskell" chapter
02:03:54 <Ralith> @src const
02:03:54 <lambdabot> const x _ = x
02:03:58 <Ralith> neworder: ^
02:05:30 <neworder> Be right back
02:12:03 * hackagebot hat 2.7.0.10 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.10 (OlafChitil)
02:12:48 <rpert> can someone translate that? why is fix useful? -> "fix f is the least fixed point of the function f, i.e. the least defined x such that f x = x."
02:13:28 <merijn> rpert: fix can be useful for function that immediately return a partial result due to laziness
02:14:42 <merijn> To give an example, the function (:) returns a list element (well, list element thunk) and tail thunk. The element thunk can be used immediately, even if the tail part never finishes
02:14:47 <merijn> > fix (1:)
02:14:49 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:14:57 <merijn> > take 5 $ fix (1:)
02:14:59 <lambdabot>   [1,1,1,1,1]
02:15:08 <Iceland_jack> The dayly `fix' example ;)
02:15:19 <Iceland_jack> *daily even!
02:15:28 <rpert> i am not sure what is going on there
02:15:31 <shachaf> There are no "thunks" involved in fix (1:), really.
02:15:57 <merijn> shachaf: Sure there are, if there were no thunks it'd be strict and would never return
02:16:03 <merijn> rpert: Let's look at the type
02:16:05 <merijn> :t fix
02:16:07 <lambdabot> (a -> a) -> a
02:16:25 <quicksilver> merijn: that's not true.
02:16:30 <merijn> rpert: So, given a function "a -> a" fix claims to construct an "a"
02:16:33 <shachaf> merijn: I can certainly imagine a strict language where let x = 1 : x in x returns.
02:16:35 <merijn> quicksilver: It's not? Why not?
02:16:42 <rpert> merijn: yes
02:16:47 <quicksilver> shachaf: is right, there are no thunks in fix (1:) once you've evaluated the 1 and the :
02:16:59 <quicksilver> it's just a heap object which points to itself
02:17:04 <quicksilver> everything is fully evaluated.
02:17:20 <merijn> rpert: Which is clearly a lie, because nowhere do you give it an initial "a"
02:17:25 <shachaf> quicksilver: Well, it depends on which definition of fix you're using. :-)
02:18:07 <merijn> rpert: The only way it can work is if the "a -> a" is can return a result before it actually inspect it's first argument
02:18:37 <rpert> I see
02:18:54 <merijn> rpert: Examples would be "("test":)" which can immedaitely return the "test" string before it has to evaluate its argument, of (1:) which can do the same
02:19:08 <merijn> eh,, I wanted to write "("test"++)" as first example >.>
02:20:17 <quicksilver> fix ("test"++) doesn't actually return the string "test", immediately or otherwise
02:20:54 <quicksilver> maybe I'm being too pedantic this morning
02:21:05 <merijn> quicksilver: You are!
02:21:48 <merijn> If you're gonna be pedantic, at least offer a "more correct" explanation >.>
02:23:04 <quicksilver> OK, then, the function ("test"++) when applied to an argument does some level of work before actually inspecting that argument
02:23:12 <quicksilver> it constructs a new list and returns the pointer to it
02:23:19 <quicksilver> and if you examine that list char by char
02:23:47 <quicksilver> you will be able to examine the chars 't','e','s','t' - in the process, you are "gradually" evaluating that function
02:24:09 <quicksilver> it's only when you try to evaluate the fifth character that the function tries to inspect its argument
02:24:09 <fmap> rpert: fix is useful when you don't have recursion in language; or don't want to give a name to recursive function in a middle of something
02:24:13 <quicksilver> merijn: better?
02:24:33 <rpert> fmap i see
02:25:22 <rpert> a recursion you cant stop? it seems
02:26:14 <quicksilver> you can. The recursion stops if the function never examines its argument again
02:26:25 <shachaf> This is just like regular recursion.
02:26:42 <quicksilver> in a "normal" recursive function there is probably an if statement or case statement and one of the branches doesn't recurse
02:27:31 <rpert> yes
02:29:52 <rpert> I am struggling to see where else it could be useful besides being a replacement for repeat function
02:30:23 <neworder> Haha
02:30:27 <neworder> Me too
02:31:18 <fmap> > fix (\f n -> if n == 0 then 1 else n * f (n - 1)) 5
02:31:19 <lambdabot>   120
02:31:30 <fmap> you can write any recursive function with fix
02:31:36 <shachaf> You can't do anything with fix that you can't do with normal recursion.
02:32:12 <rpert> ok thats interesting
02:32:45 <neworder> http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion
02:32:49 <rpert> still wrapping my head around it
02:32:51 <quicksilver> it is precisely equivalent to recursion.
02:33:01 <quicksilver> if you had a language without recursion, then you could use fix instead
02:33:08 <quicksilver> conversely if you *have* recursion, fix is trivial to write
02:33:24 <merijn> Although, if your language doesn't have recursion it probably doesn't have fix either :p
02:33:33 <parcs`> using fix may be more efficient than using normal recursion, depending on how you write the latter
02:33:40 <shachaf> merijn: The untyped lambda calculus doesn't have recursion!
02:35:41 <Cale> shachaf: ?
02:36:02 <shachaf> Cale: 02:33 <merijn> Although, if your language doesn't have recursion it probably doesn't have fix either :p
02:36:28 <Cale> One might say that the untyped lambda calculus has fix and recursion as a consequence of it
02:36:45 <shachaf> OK, but that makes merijn's statement a boring tautology.
02:37:22 * shachaf is a fan of the interesting tautologies.
02:37:56 <merijn> A counter example doesn't invalidate my claim that languages without recursion *probably* don't have fix
02:38:03 <merijn> See, for example, ASM
02:38:23 <merijn> Granted, it doesn't really have function either, depending on the ASM
02:38:34 <merijn> And you can approximate recursions if you want
02:38:43 <merijn> Thus mostly rendering my claim pointless
02:38:45 <merijn> But still!
02:49:25 <rpert> I am a bit puzzled how we provided both the function and an argument in the fact fix example, but only a function when doing ("test" ++)
02:50:11 <shachaf> It's always a function
02:50:30 <shachaf> fix :: (a -> a) -> a
02:50:45 <shachaf> Figure out what the type of a is in the factorial example.
02:50:47 <rpert> fix's type is (a -> a) -> a. how could we pass both function and 5 when it accepts just one argument
02:51:09 <shachaf> > id id 5
02:51:11 <lambdabot>   5
02:51:14 <shachaf> Do you know how that works?
02:51:17 <aninhumer> Oh wow, I just realised what an awful pun (%=) in Data.Lens is...
02:51:31 <shachaf> aninhumer: You should use Control.Lens, not Data.Lens!
02:51:55 <rpert> id takes x and returns x right
02:51:59 <shachaf> Yep.
02:52:12 <Adeon> I choose my lens package according to its pun level
02:52:37 <shachaf> Control.Lens has (%=) and many other puns.
02:52:46 <rpert> so i dont know how it works. as I understand space has the argument separator function, so we should be sending teo arguments to id
02:52:58 <rpert> two arguments
02:53:03 <fmap> rpert: what if `a' is `(b -> c)'?
02:53:07 <shachaf> rpert: Hint: (id id) 5
02:53:10 <shachaf> What's (id id)?
02:53:14 <rpert> ah
02:53:17 <rpert> id
02:53:24 <rpert> ok got it now
02:53:55 <shachaf> OK.
02:54:00 <rpert> ill try to apply that in the fix example
02:56:02 <neworder> Anyone knows of any other references for Haskell fixed point function? (fix f=f (fix f) )
02:56:16 <shachaf> @google the little schemer
02:56:18 <lambdabot> http://www.amazon.com/Little-Schemer-Daniel-P-Friedman/dp/0262560992
02:56:25 <shachaf> Hmm
02:56:29 <shachaf> @google the little schemer sample chapter
02:56:31 <lambdabot> http://www.ccs.neu.edu/home/matthias/BTLS/
02:56:32 <lambdabot> Title: The Little Schemer
02:56:40 <shachaf> The sample chapter there is about a particular version of fix
02:57:05 <rpert> i understand the effect. fix creates a recursive function and we pass 5 to it
02:57:30 <neworder> Hmm ok thanks
02:59:02 <rpert> but i cant quite figure out how it does that reading its source.
03:01:44 <Cale> fix (\fac n -> if n == 0 then 1 else n * fac (n-1))
03:02:08 <Cale> --> let x = (\fac n -> if n == 0 then 1 else n * fac (n-1)) x in x
03:02:28 <Cale> --> let x = \n -> if n == 0 then 1 else n * x (n-1) in x
03:02:42 <Cale> rpert: ^^ perhaps that helps?
03:03:40 <Cale> (I'm using the definition: fix f = let x = f x in x)
03:04:07 <shachaf> Man, we should write a program that's like Cale except automatic.
03:05:39 <donri> but would it be web-cale?
03:06:10 <Cale> What, I'm not automatic enough?
03:06:32 <shachaf> Cale: I mean, like, a program that could, like, reduce lambda expressions, man.
03:06:35 <shachaf> How crazy would that be?
03:06:57 <Cale> What a far-fetched idea.
03:08:59 <Cale> A lambda term which could reduce itself...
03:09:08 <rpert> cale yes that helped thanks. so did fix f = f (fix f). Easier to understand than the let version for me
03:11:14 <scriptus> Hello haskell people :)
03:27:05 * hackagebot classy-prelude 0.4.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.4.1 (MichaelSnoyman)
03:27:07 * hackagebot classy-prelude-conduit 0.4.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.4.1 (MichaelSnoyman)
03:33:33 <killy9999> is there a built in implementation of difference lists in Haskell?
03:35:46 <parcs`> @hackage dlist
03:35:46 <lambdabot> http://hackage.haskell.org/package/dlist
03:36:20 <killy9999> thanks
03:37:22 <bitonic> killy9999: `[a] -> [a]' :)
03:37:58 <bitonic> that's pretty built in
04:05:03 <saparvia> @pl \x->(foo x) <= bar
04:05:03 <lambdabot> (<= bar) . foo
04:05:13 <co-dan> @help pl
04:05:14 <lambdabot> pointless <expr>. Play with pointfree code.
04:05:22 <co-dan> Oh, cool.
04:05:41 <co-dan> By the way, why does this coding style is called `pointfree'?
04:06:19 <saparvia> co-dan: http://www.haskell.org/haskellwiki/Pointfree#But_pointfree_has_more_points.21
04:06:31 <FireFly> Each "point" is a name, afaik
04:06:42 <mapf> because it's pointless
04:06:42 <co-dan> Ha
04:06:45 <co-dan> thanks saparvia
04:07:11 <FireFly> Also what mapf said :p
04:07:32 <mapf> @pl \k f -> k . flip f
04:07:32 <lambdabot> (. flip) . (.)
04:08:25 <mapf>  @pl \k f -> (k :: (a -> r) -> r) . flip f
04:08:38 <mapf> hell
04:19:56 <mapf> suppose we have a cabal package. i want to inject some code in source(from comments) by preprocessing and then get fully qualified names in that injected code. I guess it's possible to do with template haskell, but how to handle dependencies properly then...
04:24:53 <djcoin> I have a question regarding, I guess, point-free style, does the ($ a) or (b $) comes handy in some specific situation ? I seldom use it
04:25:55 <nand`> > fmap ($ 3) [sqrt, succ, exp, log]
04:25:57 <lambdabot>   [1.7320508075688772,4.0,20.085536923187668,1.0986122886681098]
04:26:01 <mapf> ($ a) creates a continuation...
04:26:07 <nand`> (b $) is the same as b
04:26:11 <nand`> so I don't see that coming in handy
04:28:26 <djcoin> Thanks
04:32:00 <ion> > sequence [sqrt, succ, exp, log] 3
04:32:02 <lambdabot>   [1.7320508075688772,4.0,20.085536923187668,1.0986122886681098]
04:32:06 <ion> > [sqrt, succ, exp, log] <*> pure 3
04:32:08 <lambdabot>   [1.7320508075688772,4.0,20.085536923187668,1.0986122886681098]
04:34:17 <fmap> mapf: TH cannot into comments
05:02:07 * hackagebot language-puppet 0.2.2.0 - Tools to parse and evaluate the Puppet DSL.  http://hackage.haskell.org/package/language-puppet-0.2.2.0 (SimonMarechal)
05:11:45 <saparvia> @pl \x-> (foo x (bar (baz c x)))
05:11:46 <lambdabot> ap foo (bar . baz c)
05:12:07 * hackagebot puppetresources 0.3.6 - A program that displays the puppet resources associated to a node given .pp files.  http://hackage.haskell.org/package/puppetresources-0.3.6 (SimonMarechal)
05:14:48 <saparvia> Hmm... which ap would that be?
05:16:13 <Botje> the one for functions, i'd wager
05:16:16 <byorgey> the one for the  ((->) e)  instance of Monad
05:16:31 <Botje> ap f g = \x -> f x (g x)
05:16:38 <byorgey> ap f g = \x -> f x (g x)
05:16:45 <byorgey> ah, Botje beat me =)
05:16:54 <saparvia> What do I need to import?
05:17:12 <byorgey> Control.Monad.Instances
05:19:47 <saparvia> Control.Monad.Instances doesn't export it, and the one from Control.Monad gives "No instance for (Monad ((->) Double))"
05:20:18 <nand`> I thought C.M.I was deprecated in newer GHC versions either way
05:20:54 <nand`> instance Monad ((->) r) -- Defined in `GHC.Base'
05:22:59 <byorgey> what?
05:23:38 <byorgey> saparvia: you need to import both Control.Monad (to bring 'ap' into scope) and Control.Monad.Instances (to bring the instance for  ((->) e) into scope)
05:23:57 <shachaf> nand`: Huh, strange.
05:24:06 <byorgey> nand`: I hadn't heard that it was deprecated, do you have a link?
05:24:37 <nand`> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Control-Monad-Instances.html
05:24:41 <nand`> This module is DEPRECATED and will be removed in the future!
05:24:50 <byorgey> huh, you're right
05:25:00 <saparvia> byorgey: Thanks, that worked. I'm only on 6.12 so I guess that's not counted as "new"
05:25:12 <nand`> yes I think that's since 7.x
05:25:23 <byorgey> oh, I see, Prelude now exports that instance
05:25:25 <byorgey> cool =)
05:25:26 <nand`> (is the ins-- yeah)
05:25:29 <nand`> it's in prelude now
05:25:49 <byorgey> saparvia: yeah, 6.12 is pretty old =)
05:26:03 <byorgey> looks like it's only since 7.6, actually
05:26:24 <byorgey> when I try in 7.4 I get a "no instance" error
05:26:27 <nand`> ah
05:26:28 <christiaanb> hi, has anybody successfully build shared libraries on OS X? I'm having problems where either Cabal can't seem to find installed dyn_hi files
05:26:37 <nand`> Does Control.Monad export it in 7.4?
05:26:42 <byorgey> nand`: no
05:26:52 <byorgey> I mean, I had to import Control.Monad to get 'ap'
05:27:15 <byorgey> but it doesn't export that instance
05:27:19 <scp> Sorry if I'm asking a common question, but is there a pronounceable name for ">>=" and/or ">>"
05:27:24 <nand`> bind
05:27:27 <nand`> for the former
05:27:39 <scp> ok, I guess that makes sense
05:27:48 <byorgey> >>= is "bind".  There's not as much of a standard for >>, but you could pronounce it "and then"
05:27:57 <scp> > :t (>>)
05:27:58 <lambdabot>   <hint>:1:1: parse error on input `:'
05:28:02 <scp> :t (>>)
05:28:04 <lambdabot> Monad m => m a -> m b -> m b
05:28:35 <scp> It's annoying that it resembles C++ iostreams =P
05:28:50 <nand`> lots of things resemble lots of other things
05:28:53 <nand`> ‘return’ for one
05:29:27 <scp> ya, I guess it's arbitrary
05:29:41 <shachaf> ins++
05:30:57 <Prezioso> if I run cabal install language-javascript it fails doing configuration step  and the exeption is ExitFailure 1. how do I solved this?
05:31:20 <hpc> it should give a more useful error if you scroll up in the output
05:31:25 <nand`> try posting the build log
05:32:10 <Prezioso> this one: cabal: The program happy version >=1.18.5 is required but it could not be
05:32:14 <Prezioso> found?
05:32:37 <nand`> do you have happy >= 1.18.5 installed?
05:32:50 <Prezioso> Doh, no. Im caballing now
05:32:51 <hpc> (you can check with ghc-pkg list | grep happy)
05:33:15 <nand`> (I thought cabal-install auto-resolves dependencies?)
05:33:59 <hpc> could be it's trying a newer version somehow, and you need to cabal update
05:33:59 <Prezioso> Any idea on how I ln s yesod to /usr/bin ? it says to many levels of symlinks (archlinux)
05:34:29 <hpc> ln -s /path/to/your/yesod /usr/bin/yesod
05:34:39 <hpc> you should just copy it as root though, imo
05:34:50 <nand`> I wouldn't put the symlink in /usr/bin either
05:35:08 <sipa> @pl \(x,xs) -> (x:xs)
05:35:09 <lambdabot> uncurry (:)
05:35:11 <saparvia> I use up a lot of memory when using iterate with the function "step (State t x v a) = State (t+dt) (x+dx) (v+dv) (total_force x)". How do I avoid this?
05:35:39 <saparvia> iterate step initial_state
05:35:40 <hpc> saparvia: hard to know without profiling
05:35:43 <Prezioso> hpc $ nand okay
05:35:49 <Prezioso> hmm still the same javascript error :S
05:36:09 <saparvia> hpc: Well, I'm only increasing some values, right?
05:36:20 <saparvia> So it really shouldn't eat up that much memory
05:36:29 <hpc> the trick is lazy evaluation
05:36:41 <saparvia> hpc: Yeah, that's what I suspect too.
05:36:43 <scp> ya, try generous application of seq
05:36:44 <nand`> try making the function script
05:36:46 <nand`> like
05:36:47 <hpc> if you add (+ 1) repeatedly, you aren't getting 100
05:36:49 <nand`> step (State !t !x !v !a)
05:36:56 <hpc> you are getting (1 + (1 + (1 + ...
05:36:57 <nand`> s/script/strict/
05:37:13 <hpc> yeah, strictness should help
05:37:33 <scp> saparvia: are you compiling w/ optimizations turned on? Often it will get rid of stupid laziness (in my experience at least)
05:37:52 <hpc> also, rename total_force to totalForce
05:38:05 <beaky> hello
05:38:07 <beaky> hello
05:38:12 <scp> greetings
05:38:22 <beaky> is iterate an anamorphism?
05:38:29 <saparvia> scp: Yes, -O3
05:38:39 <nand`> beaky: yes
05:38:43 <nand`> saparvia: there's no -O3
05:38:59 <hpc> -O2 is the highest optimization pass
05:39:01 <saparvia> I assume that -O3 just mean -O2 then
05:39:09 <nand`> yes
05:39:14 <hpc> even on something like gcc that has -O3, that denotes minimizing binary size
05:39:20 <hpc> rather than making it run quickly
05:39:26 <nand`> no
05:39:28 <nand`> that's -Os
05:39:37 <nand`> -O3 in gcc has larger binary sizes and less correct semantics
05:39:40 <scp> hpc: O3 performs unsafe optimizations on gcc
05:39:46 <hpc> oh yes, my mistake :P
05:39:53 <hpc> you can see how often i use C
05:39:59 <beaky> :D
05:40:00 <scp> we can C o_O
05:40:04 <nand`> I don't use C either, I just compile it :P
05:40:06 <beaky> i love C
05:40:12 <beaky> it's like the language for von-neumann computers
05:40:20 <FireFly> I love C:ing
05:40:48 <saparvia> I on the other hand do lots of Fortran where -O3 is certainly often needed
05:42:08 <merijn> There's a different "optimise for space" flag in gcc, which incidentally often increases performance more than the performance optimisations :)
05:42:45 <nand`> yeah
05:43:33 <nand`> -Os is almost unconditionally faster than -O2 from what I've seen; occasionally -O3 beats it, especially if you have large caches, but -O3 also sometimes breaks programs
05:44:38 <Philonous> nand`:  That's bizarre
05:44:47 <saparvia> nand`: Thanks, the bangs did the trick
05:45:00 <merijn> Philonous: Not really, makes sense
05:45:25 <merijn> Philonous: Space optimisation improves cache/memory behaviour, which is more often the bottle neck than computation is
05:45:33 <Philonous> merijn:  Why would even have the speed optimizations that do universally worse both in speed and size?
05:45:34 <saparvia> Memory is slow
05:46:04 <merijn> Philonous: Because speed optimisations do actually optimise speed. It's just that speed is almost never the bottle neck.
05:46:14 <mm_freak> you can feel the effect of -Os especially on magnetic devices
05:46:30 <merijn> If you have pure numeric code with very little memory accesses O3 will of course beat Os no problem
05:46:33 <mm_freak> faster boots, faster loads, etc.
05:46:36 <nand`> Philonous: because it's conditional
05:47:17 <Sonderblade> then you should all use compressed executables for even smaller sizes
05:47:56 <saparvia> But compressed executables are uncompressed when run, right?
05:48:04 <saparvia> The code size is not actually smaller
05:48:15 <merijn> saparvia: Correct
05:48:39 <saparvia> It's not loading the code from the hard drive that is slow
05:48:45 <saparvia> Or well, it is
05:48:52 <saparvia> But it's just done at startup
05:48:57 <merijn> Similar fun fact: On ZFS (but presumably also other filesystems) compressed volumes are faster, rather than slower than uncompressed volumes
05:49:00 <scp> saparvia: compressed executeables will not have better cache locality =P. Unless there is some kind of decompressing instruction fetch unit that I don't know about
05:49:02 <saparvia> It's the move the data from main memory to cache which is the problem
05:49:26 <merijn> This because the overhead of uncompressing on the fly is negligible compared to the speed gain of having to read less disk blocks
05:49:40 <scp> merijn: On spinning disks anyway =P. Doesn't work out on SSDs (iirc)
05:49:47 <Sonderblade> but one could imagine an exe format which keeps the blocks compressed until actually executed
05:49:57 <merijn> scp: Might still work on SSD too
05:50:15 <hpc> i doubt the gain would be as amazing
05:50:20 <merijn> scp: SSD's have constant access speed, but that doesn't give them negligible latency
05:50:21 <saparvia> Sonderblade: It would have to be the CPU that decompresses on the fly
05:50:29 <hpc> at the very least, an SSD would be swapping bottlenecks
05:50:33 <scp> ya, you're capitalizing on the CPU outperforming the disk
05:50:42 <merijn> As long as the latency is long enough uncompressing could still be faster by reducing the number of loads
05:50:59 <saparvia> You would anyway need a big cache to do the decompression of the program data directly in the CPU cache
05:51:14 <scp> hmm, that's an interesting idea though.
05:51:20 <scp> It would require very cache-aware code
05:51:21 <saparvia> You're probably better off investing in a bigger cache
05:51:49 <scp> interestingly, you would gain from having a size-optimized decompression routine there
05:52:46 <scp> also, can you get good compression ratios on intel instructions? Since its a prefix-free encoding, I'd expect it to have higher entropy than regular text
05:53:01 <hpc> i would put decompression directly in the drive firmware
05:53:13 <Prezioso> .cabal/bin/.copyFile25388.tmp: inappropriate type (Now language-javascript is installed) but why this error? im trying to cabal install my yesod project
05:53:37 <hpc> scp: there's still patterns, but different ones
05:53:40 <hpc> like stack frames
05:53:59 <hpc> scp1: there's still patterns, but different ones, like stack frames
05:54:05 <hpc> (dunno if you got that)
05:54:16 <scp> scpl != scp =P
05:54:22 <scp> err, scp1
05:54:31 <hpc> oh
05:54:40 <scp> either that or I just logged on on another machine and don't know it
05:54:48 <Sonderblade> scp: back in the day, you used to be able to. people did amazing things that fit in a 4kb self-decompressable executable
05:54:53 <scp1> don't tell scp
05:55:14 <WarDaft> So, I'm trying to install a new package, but cabal says that doing so will break about half a dozen installed packages, one of which sounds fairly important. This is the only library that does what I need, and building my own solution is utterly out of my depth. Is there anything I can do other than make a backup and just hope everything works?
05:55:46 <saparvia> SSD:s have nothing to do with the issue. The cost of loading the program into RAM from drive is negligable to the total runtime of the program. Compressing it on the disk helps nothing to speed things up.
05:55:57 <scp> hmm, now that I think about it, I wrote a self decompressing bootloader once
05:56:04 <merijn> saparvia: We weren't talking about program performance anymore
05:56:16 <dcoutts_> WarDaft: you can ask cabal to try to install both things at once, ie the thing you want, and the thing that would be otherwise broken. Use --dry-run to start with.
05:56:47 <dcoutts_> Prezioso: how do you get that error? is it reproducible?
05:57:06 <flux> saparvia, SSDs can speed starting up programs, given the pages you need to read in are scattered all over the medium. of course, it doesn't matter in the great scheme of things if you run the program for a long time, very it's very perceptible :).
05:57:18 <dcoutts_> Prezioso: what has it got to do with language-javascript?
05:58:25 <beaky> javascript is a prototype-based OOP language
05:58:34 <Prezioso> dcoutts_: Just because I was asking about that before and cabal wouldnt let me install it, but pacman would. Which wont let me install yesod, but cabal would.
05:59:00 <Prezioso> So maybe I just messed up big time with installing with both pacman and cabal
05:59:01 <beaky> prototypes are a generalization of classes and metaclasses
05:59:14 <beaky> and objects :D
06:01:25 <WarDaft> Cabal doesn't seem to like having --force-reinstalls and --dry-run at the same time.
06:04:35 <beaky> how are variadic functions in haskel?
06:05:10 <beaky> are there* variadic functions in haskell?
06:05:21 <WarDaft> beaky: Not really
06:05:47 <beaky> ho is it done in the lambda calculus?
06:06:17 <nand`> you can implement them
06:06:24 <beaky> ah ccool
06:08:11 <nand`> it's easy in the lambda calculus
06:08:11 <nand`> the function just takes as many parameters as it needs
06:09:23 <nand`> > printf "foo %s bar %s" "bat" "baz" :: String
06:09:23 <WarDaft> It's types that make it non-trivial in Haskell. You need to wrap things up in data structures.
06:09:25 <lambdabot>   "foo bat bar baz"
06:09:43 <nand`> not necessarily
06:09:51 <nand`> printf uses a class-based approach
06:09:51 <Prezioso> user error (Cannot find the program 'ghc' at 'yesod-ghc-wrapper' or on the path - should I just add .cabal/bin to $PATH or?
06:09:57 <nand`> instead of doing stuff like [String]
06:10:10 <FireFly> @type printf
06:10:12 <lambdabot> PrintfType r => String -> r
06:11:03 <FireFly> @type printf "hello %s" "world"
06:11:05 <lambdabot> PrintfType t => t
06:11:36 <nand`> basically, PrintfType can either be the result (IO () or String), or it can be (PrintfArg a, PrintfType r) => a -> r
06:11:45 <nand`> so you can instantiate it to as many parameters as you want
06:11:56 <nand`> @type printf "hello %s" "world" :: String -> String
06:11:58 <lambdabot> String -> String
06:13:59 <jacobian> Cabal-1.14.0-d9285d24da91e18b76cec71052b2d268 is shadowed by package Cabal-1.14.0-0338b6f52e6e6a56054371a110e1d79e
06:14:04 <jacobian> ^ Any thoughts on this one?
06:18:25 <FireFly> nand`: heh, interesting approach
06:19:32 <fmap> jacobian: yeah, you've reinstalled core package Cabal, don't do that
06:19:57 <jacobian> any way out?
06:22:04 <fmap> jacobian: rm -rf ~/.cabal ~/.ghc would work, but you can probably just ghc-pkg unregister offending package
06:23:06 <jacobian> ugh
06:23:48 <fmap> jacobian: basically, you shouldn't reinstall anything from here: http://www.haskell.org/ghc/docs/7.6.1/html/libraries/index.html
06:23:55 <fmap> (adjust for you ghc version)
06:24:00 <shachaf> printf isn't type-safe, as a result.
06:24:01 <fmap> s/you/your
06:26:05 <linduxed> does haskell also have that 80 char rule going for it?
06:26:18 <linduxed> or have you guys dropped that
06:27:13 <jacobian> fmap, thanks
06:27:59 <dmwit> linduxed: "rule"?
06:28:09 <Sonderblade> linduxed: haskell is so terse, you almost never need any long lines
06:28:19 <dmwit> jacobian, fmap: I've installed newer versions of Cabal on older versions of GHC before without problems.
06:28:36 <dmwit> (Though the advice not to reinstall core packages in general is pretty sound.)
06:28:47 <dmwit> Sonderblade: haha!
06:29:15 <fmap> Sonderblade: until you discover lens
06:30:11 <fmap> dmwit: yeah, but his problem is more like "I've reinstalled the same version of Cabal"
06:30:23 <fmap> oh maybe just "installed"
06:30:52 <Sonderblade> fmap: lenses isn't that bad, the weird Arrow thingies are worse :p
06:30:57 <dmwit> linduxed: Anyway, I find the question quite suspect. You can put that rule into practice in any language, and asking whether an entire language has it is a bit... odd? I don't think any language has that as a rule of its syntax, and I'd be very suspicious if any language added it.
06:31:19 <edwardk> Sonderblade: yes, the difference is, i still have uses for lenses. ;)
06:32:24 <rwbarton> dmwit: old-school fortran :)
06:32:52 <rwbarton> "Columns 7 to 72 served as the statement field. Columns 73 to 80 were ignored, so they could be used for identification information."
06:33:03 <shachaf> Do tabs take up 8 holes on the punch card?
06:33:16 <shachaf> (OK, that doesn't make sense. But you know what I mean.)
06:33:19 <edwardk> linduxed: yes, never had it, it is a long dead concept in basically every language since fortran 77 ;)
06:33:24 <edwardk> shachaf: =)
06:33:25 <dmwit> rwbarton: I'm very suspicious of Fortran. (Happy now? =)
06:33:51 <shachaf> Igloo might beg to differ.
06:34:36 <shachaf> I'm going to post a question about type-safe difference lists to StackOverflow unless someone in here stops me.
06:34:49 <Igloo> What am I differing about?
06:35:02 <shachaf> 80-column lines?
06:35:06 <shachaf> I think that was you.
06:35:41 <edwardk> shachaf: knock yourself out. i'd be shocked if you got a usable answer
06:35:54 <dmwit> What a threat. "If you don't answer me, I'll... go ask somebody else!"
06:36:07 <dmwit> Except in this case it's more like "If you don't answer me over the phone, I'll ask you over email!".
06:36:08 <Marenz> Noooooooooooo
06:36:09 <shachaf> It's not a threat!
06:36:29 <shachaf> dmwit: It's like email, except email where you get magic Internet points for answering.
06:36:41 <shachaf> So I probably shouldn't have mentioned that, come to think of it.
06:36:44 <linduxed> edwardk: except pretty much all of C
06:36:53 <shachaf> edwardk: Yes, I'd be pretty surprised too.
06:36:56 <edwardk> linduxed: there it is a guideline, not a rule per se
06:36:57 <shachaf> But I'd like to get one!
06:37:01 <linduxed> Sonderblade: i have a tendency to write long function names :-)
06:37:03 <shachaf> Maybe some crazy Agda people can do it.
06:37:20 <linduxed> dmwit: well i mean like python has PEP8
06:37:30 <edwardk> linduxed: a lot of folks still abide by it personally. i tend to aim for something closer to 132 columns as a cap myself, but i'm not religious about it.
06:37:50 <dmwit> > 132 * 8
06:37:52 <lambdabot>   1056
06:37:52 <linduxed> edwardk: i haven't seen C code with more than 80 in a long time
06:37:56 <shachaf> http://javadoc.bugaco.com/com/sun/java/swing/plaf/nimbus/InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter.html -- let's see you do 80 columns with that.
06:38:07 <edwardk> shachaf: =)
06:38:30 <dmwit> > length "InternalFrameInternalFrameTitlePaneInternalFrameTitlePanMaximizeButtonPainter"
06:38:32 <lambdabot>   77
06:38:32 <edwardk> > length "InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter"
06:38:34 <lambdabot>   78
06:38:50 <dmwit> I typo'd the second Pane.
06:39:11 <dmwit> Just enough space left over for a space and a {...
06:39:14 <shachaf> You typed that?
06:39:21 <edwardk> i pasted
06:39:30 <dmwit> Just to see what typing it would be like.
06:39:46 <shachaf> I assume a Java programmer would use some sort of completion.
06:39:47 <dmwit> Just the name, just for a second, just to see what it would be like.
06:40:03 <shachaf> I hear Java IDEs are pretty great at that sort of thing.
06:40:34 <shachaf> (vim would probably be pretty good at it too.)
06:41:17 <edwardk> > length "VirtualMachineDeviceRuntimeInfoVirtualEthernetCardRuntimeStateVmDirectPathGen2InactiveReasonOther"
06:41:19 <lambdabot>   97
06:41:59 <edwardk> or as we like to call it here in haskell "Foo"
06:42:21 <shachaf> I prefer a descriptive name like "x"
06:42:29 <strg> wtf
06:42:39 <strg> are those real java classnames?
06:42:46 <edwardk> yes
06:43:16 <strg> scary
06:43:23 <beaky> what makes haskell a non-von-neumann language?
06:44:02 <shachaf> realJava: Interactive 3D edition
06:45:03 <dmwit> von-Neumann-ness seems like a property of the implementation, not the language.
06:45:07 <beaky> ah
06:45:48 <gds> Could it also be seen as a property of the model you have in your head when programming in a language?
06:45:56 <mizu_no_oto> dmwit: true, but different languages have easier or harder implementations on different architectures
06:46:00 <gds> (a much fluffier concept, to be sure)
06:46:12 * dmwit nods agreeably towards mizu_no_oto
06:47:00 <byorgey> though some languages have more of the von-Neumann nature than others.
06:47:43 <beaky> haskell doesn't seem von neumann since there's no notion of assignment
06:47:52 <scp> Can you think of an architecture more suited to a haskell implementation? To me it just seems like haskell has you deal less w/ machine details, so you don't encounter the architecture
06:48:58 <shachaf> A graph reduction machine seems pretty well-suited to implementing Haskell on. :-)
06:49:08 <flux> scp, well, how about Symbolics? what if there was hw-accelerated pattern matching?
06:51:27 <byorgey> beaky: you might be interested in reading Backus's famous 1977 Turing Award lecture, if you haven't already
06:51:32 <beaky> ah
06:51:51 <beaky> yeah he said that we need to free ourselves from the von-neumann model
06:51:55 <byorgey> right
06:52:01 <beaky> and languages like haskell are our savior
06:52:12 <shachaf> I don't believe he said quite that. :-)
06:52:13 <mami> i dont really understand that type declaration
06:52:14 <mami> applyTwice :: (a -> a) -> a -> a
06:52:15 <mami> applyTwice f x = f (f x)
06:52:23 <byorgey> hehe, that's basically what he said, but the details are interesting =)
06:52:47 <shachaf> mami: applyTwice takes a function of type (a -> a) and returns a function of type (a -> a)
06:53:01 <mami> ah
06:53:03 <beaky> we need to stop thinking in `for (i = 0; i < n; ++i) { a[i] = f(a[i]); } and start thinking in `map f xs`
06:53:04 <mami> so i could also say
06:53:08 <byorgey> mami: is there something in particular about it which is confusing you?
06:53:19 <mami> (a -> a) -> (a -> a)
06:53:20 <mami> ?
06:53:40 <byorgey> mami: yes, -> associates to the right
06:53:57 <mami> byorgey: ah okay
06:53:57 <byorgey> so  a -> b -> c  is just an abbreviation for  a -> (b -> c)
06:54:11 <mami> ah good
06:54:28 <byorgey> though it is a *suggestive* abbreviation.  a -> b -> c  looks like a two-argument function;  a -> (b -> c) is a function which returns a function
06:54:35 <byorgey> because of currying, they are the same thing.
06:55:03 <mami> i was thinking how can (((a -> a) -> a) -> a )
06:55:06 <mami> more or less
06:55:10 <byorgey> right, that is different
06:55:27 <byorgey> that's a function which takes a single argument of type  ((a -> a) -> a)
06:55:39 <mami> its a little crude notation, but i think it clarifies how i mixed up associativity
06:55:47 <mami> yeah
06:55:56 <mami> but i see, thanks
06:55:58 <byorgey> @type foo f = f id
06:56:00 <lambdabot> parse error on input `='
06:56:05 <byorgey> @type let foo f = f id in foo
06:56:06 <lambdabot> ((a -> a) -> t) -> t
06:56:27 * typoclass . o O ( what does von neumann mean in this last discussion? )
06:56:48 <dmwit> typoclass: I think this: http://en.wikipedia.org/wiki/Von_neumann_architecture
06:56:52 <beaky> the von neumann programming model, where everything is a cell that you assign to and processing happens sequentially
06:57:23 <scp> flux: that's a very cool idea
06:58:08 <mami> but (a -> a) -> (a -> a) makes it very clear, thx shachaf
06:59:02 <byorgey> the von neumann model is really more about having separate units for processing, control, and memory connected by a bus
06:59:05 <dmwit> scp: You might be interested in reading the Reduceron papers.
06:59:45 <byorgey> but implicit in that is the idea that memory is addressed and you can retrieve or store things in memory by referring to them by their address
07:00:28 <nand`> scp: haskell runs best on graph reducers
07:00:33 <nand`> the reduceron, as the name implies, is one
07:00:38 <flux> nand`, well, only if they are fast :)
07:00:41 <nand`> but there have been other machines aimed at doing the same
07:00:42 <scp> neato, googling =]
07:00:59 <flux> or whatever 'running best' means
07:01:04 <quicksilver> is it actually true that GHC would run better on a graph reducer?
07:01:05 <typoclass> i was taught that the defining feature of von neumann is that programs and data are stored in the same memory, as opposed to harvard where there's an instruction memory and another memory for data ... seems at variance with that wikipedia article. but whatever.
07:01:27 <nand`> quicksilver: probably not GHC, at least not with its current backends
07:01:35 <quicksilver> I mean, it represents quite a few man-years work in designing ways to cope with current architectures
07:01:37 <nand`> it's very aimed at generating code for architectures like x86 or ARM
07:02:15 <nand`> the reduceron papers/talks address this btw, their real world reduceron running on a reconfigurable FPGA is at about .. I think 30-50% the performance of a modern x86 CPU + GHC I think; but that's
07:02:28 <nand`> but that's probably not what you'd get from a dedicated/optimized chip*
07:03:18 <scp> typoclass: that is what distinguishes it from a harvard architecture. But I think what we're talking about here is more of a "turing machine style" computation, of which von neumann and harvard are both variations
07:03:57 <flux> nand`, 30-50% sounds pretty good for me
07:03:58 <nand`> as far as I understood it, that's the ‘von neumann model’; but the ‘von neumann cycle’ is more general; and consists of ‘fetch, decode, execute’
07:04:17 <flux> nand`, but 100% or 200% would sound even better :)
07:04:19 <nand`> flux: oh, obviously; the reduceron is running at like less than a tenth the clock r ate
07:04:19 <typoclass> scp: ok, so turing machine style in the sense of 'sequential execution' then
07:04:22 <typoclass> scp: thanks
07:04:30 <jamil> hi all
07:04:47 <typoclass> jamil: hello
07:07:10 * hackagebot git-annex 3.20121112 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121112 (JoeyHess)
07:09:54 <jamil> is it correct to relate constraint programming and type systems ?
07:10:39 <ski> especially type systems with e.g. type class constraints
07:12:10 * hackagebot aivika 0.5 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.5 (DavidSorokin)
07:13:10 <jamil> is there any literature comparing two ?
07:32:51 <Palmik> Hi guys, I would like to benchmark operations over a data structure that has 3 fields: 1st is Int, 2nd is IntMap, 3rd is Map of IntSets. Would applying whnf to each of these three fields be enough? And what if the fields are strict, would then applying whnf to the value of that data type be enough?
07:33:51 <atriq> > execState (_2 <<%= tail >>= (=: _1) . head) ("hello", "world")
07:33:53 <lambdabot>   Not in scope: `=:'
07:33:53 <lambdabot>  Perhaps you meant one of these:
07:33:54 <lambdabot>    `==' (imported from ...
07:34:06 <Cale> Palmik: depends on what you're measuring.
07:35:09 <Palmik> Cale: I'm not what answer you are looking for, but I'm for example inserting into this data structure (this entails increasing the int and inserting into the maps/sets) and looking up and deleting.
07:35:47 <alpounet> @type (<<%=)
07:35:48 <lambdabot> MonadState s m => LensLike ((,) a) s s a b -> (a -> b) -> m a
07:35:55 <alpounet> we have lenses in \bot now uh
07:36:07 <edwardk> yep
07:36:35 <rwbarton> Palmik: it's not enough to fully evaluate the data structure unless you can guarantee that every value inserted into the IntMap or the Map of IntSets is already fully evaluated
07:37:04 <edwardk> > ("lenses",("are","fun", 2 :: Int))^..biplate :: [String]
07:37:06 <lambdabot>   ["lenses","are","fun"]
07:37:38 <edwardk> atriq: Data.List.Lens isn't in scope in lambdabot
07:37:46 <Cale> Palmik: Strictifying the 3 fields should be enough to ensure that all the work which goes into inserting elements into the IntMap/Map gets done, but it doesn't ensure that the IntMaps which are elements of the outer Map are evaluated.
07:37:55 <atriq> edwardk, is it imported qualified?
07:37:59 <alpounet> alright, beginners are going to curse the haskell experts even more now
07:38:01 <atriq> > execState (_2 <<%= tail >>= (Data.List.=: _1) . head) ("hello", "world")
07:38:02 <lambdabot>   Not in scope: `Data.List.=:'
07:38:03 <lambdabot>  Perhaps you meant one of these:
07:38:03 <lambdabot>    `Data.List...
07:38:05 <edwardk> not at all at last check
07:38:10 <atriq> > execState (_2 <<%= tail >>= (Data.List.Lens.=: _1) . head) ("hello", "world")
07:38:11 <lambdabot>   Not in scope: `Data.List.Lens.=:'
07:38:11 <lambdabot>  Perhaps you meant one of these:
07:38:11 <lambdabot>    `Data...
07:38:14 <atriq> :(
07:38:29 <edwardk> you can use %= (foo:)
07:38:30 <atriq> Anyway, that gives ("whello", "orld")
07:38:43 <atriq> It's useful for list zippers
07:38:51 <atriq> It may be possible to use Zipper, of course
07:38:57 <Palmik> Cale, rwbarton, thank you guys. :)
07:39:00 <atriq> But I haven't figured that out yet :
07:39:01 <atriq> (
07:39:05 <rwbarton> @type biplate
07:39:07 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f) => (a -> f a) -> s -> f s
07:39:45 <edwardk> hrmm. ("hello","world")^.both.traverse gets you the elements we can use partsOf to get a list and then rotate it
07:39:54 <edwardk> :t partsOf (both.traverse)
07:39:55 <lambdabot> (Functor f, Traversable t) => ([a] -> f [a]) -> (t a, t a) -> f (t a, t a)
07:40:41 <rwbarton> > mapOf biplate (toUpper :: Char -> Char) ("lenses",("are","fun", 2 :: Int))
07:40:43 <lambdabot>   ("LENSES",("ARE","FUN",2))
07:40:46 <edwardk> :t let rotate xs = last xs ++ [init xs] in rotate
07:40:47 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [[a0]]
07:40:48 <lambdabot>     Expected type: [a0]
07:40:48 <lambdabot>       Actual type: [[[a0]]]
07:41:10 <rwbarton> ... I don't know why I felt the need for that type signature
07:41:13 <edwardk> :t let rotate xs = last xs : init xs in rotate
07:41:15 <lambdabot> [a] -> [a]
07:41:16 <edwardk> heh
07:41:27 <rwbarton> to ward off the Data.Data.Data demons I guess
07:41:41 <edwardk> > let rotate xs = last xs ++ [init xs] in partsOf (both.traverse) %~ rotate $ ("hello","world")
07:41:42 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = [[a0]]
07:42:10 * hackagebot hat 2.7.0.11 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.11 (OlafChitil)
07:42:27 <edwardk> > let rotate xs = last xs : init xs in partsOf (both.traverse) %~ rotate $ ("hello","world")
07:42:29 <lambdabot>   ("dhell","oworl")
07:43:04 <edwardk> > let rotate xs = tail xs ++ [head xs] in partsOf (both.traverse) %~ rotate $ ("hello","world")
07:43:06 <lambdabot>   ("ellow","orldh")
07:45:54 <nand`> :t partsOf
07:45:56 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
07:46:10 <copumpkin> damn! the infamous bazaar is leaking
07:52:55 <Cale> copumpkin: I really wish that type synonyms were more meaningful with respect to module boundaries.
07:53:46 <Cale> (i.e. It would be nice to be able to export a type synonym without exporting the type equality constraint that it represents)
07:54:08 <atriq> :t let traverseTape a2fb (ls, rs) = sequenceAOf both (for ls a2fb, for rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in traverseTape
07:54:10 <lambdabot>     Not in scope: `for'
07:54:10 <lambdabot>     Perhaps you meant one of these:
07:54:10 <lambdabot>       `Data.Traversable.for' (imported from Data.Traversable),
07:54:22 <atriq> :t let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in traverseTape
07:54:24 <lambdabot> Applicative f => (a -> f b) -> ([a], [a]) -> f ([b], [b])
07:55:16 <copumpkin> Cale: yeah
07:55:46 <copumpkin> didn't hugs have an extension along those lines for even more local type synonyms?
07:56:36 <Cale> oh, it did!
07:56:37 <atriq> > let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in fromWithin traverseTape (zipper ("hello" "world")) ^. focus
07:56:38 <lambdabot>   The function `"hello"' is applied to one argument,
07:56:39 <lambdabot>  but its type `[GHC.Type...
07:56:44 <atriq> > let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in fromWithin traverseTape (zipper ("hello", "world")) ^. focus
07:56:46 <lambdabot>   'h'
07:56:48 <Cale> Type synonyms in export and import lists
07:56:48 <Cale> Hugs allows the T(..) syntax for type synonyms in export and import lists. It also allows the form T() for type synonyms in import lists.
07:57:01 <atriq> > let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in right (fromWithin traverseTape (zipper ("hello", "world"))) ^. focus
07:57:02 <lambdabot>   Ambiguous occurrence `right'
07:57:03 <lambdabot>  It could refer to either `Control.Arrow.right...
07:57:06 <Cale> well, the documentation doesn't say what that means
07:57:12 <atriq> > let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in Control.Lens.right (fromWithin traverseTape (zipper ("hello", "world"))) ^. focus
07:57:14 <lambdabot>   Couldn't match expected type `Data.Maybe.Maybe
07:57:14 <lambdabot>                             ...
07:57:20 <atriq> > let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in Control.Lens.right1 (fromWithin traverseTape (zipper ("hello", "world"))) ^. focus
07:57:22 <lambdabot>   'e'
07:57:40 <atriq> > let traverseTape a2fb (ls, rs) = sequenceAOf both (forOf traverse ls a2fb, forOf traverse rs a2fb); traverseTape :: Traversal ([a], [a]) ([b], [b]) a b in Control.Lens.right1 (fromWithin traverseTape (zipper (repeat 0, repeat 0))) ^. focus
07:57:41 <lambdabot>   0
07:57:43 <copumpkin> Cale: I mean "restricted type synonyms"
07:58:17 <copumpkin> http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5
07:59:08 <copumpkin> it seems kinda cute
07:59:43 <Cale> yeah, that is cute
08:02:55 <johnw> what is cute?
08:03:33 <rwbarton> I wanted this feature recently
08:03:38 <quicksilver> johnw: http://cvs.haskell.org/Hugs/pages/hugsman/exts.html#sect7.3.5
08:03:41 <rwbarton> though it's not clear to me that it really interacts with type classes sensibly
08:03:53 <rwbarton> but perhaps that is the point
08:04:14 <Cale> johnw: Hugs' feature which lets you specify the exact list of definitions in which a type synonym applies, making the type abstract outside of those
08:04:58 <johnw> so it's like "where" in functions, but for types?
08:05:33 <johnw> is this different from what finely-granular modules can achieve?
08:05:38 <Cale> Well, you can still use that type in the external interface.
08:05:43 <rwbarton> it is more like a newtype which is automatically (un)wrapped in a certain region
08:05:49 <johnw> ah, ok
08:12:35 <john__> in ghci can I load a file and run a command in a one liner?   IE   :l test.hs ; mytest
08:12:58 <kranius> have you tried ?
08:13:05 <john__> yep
08:14:13 <GHAI> aye
08:14:31 <GHAI> i just tried if i could get the stuff from http://www.haskell.org/haskellwiki/Debugging to work
08:15:09 <GHAI> anyhow, if i try any of the things listed there in winghci or ghci i get "not found" responses
08:15:19 <rodlogic> what kind of performance penalty do I pay by using monads or monad transformers?
08:15:30 <GHAI> although i did cabal install the requested things
08:15:44 <atriq> rodlogic, roughly nil
08:16:06 <monochrom> you need "import Debug.Trace" and/or ":m + Debug.Trace"
08:16:06 <rwbarton> somewhere between none and a few orders of magnitude
08:16:13 <ski> restricted type synonyms are quite similar to exporting a type synonym abstractly in the MLs
08:17:23 <GHAI> monochrom :m did not yield errors
08:17:52 * ski notices Cale more or less said this already
08:18:22 <GHAI> hm, now import Debug.Trace does not either
08:18:31 <GHAI> maybe i needed to install a few more modules
08:18:33 <monochrom> do you want errors?
08:18:51 <monochrom> Debug.Trace comes with GHC
08:18:57 <GHAI> no, actually i want something along those lines
08:18:57 <GHAI> http://hackage.haskell.org/packages/archive/htrace/0.1/doc/html/Debug-HTrace.html
08:19:12 <Cale> rodlogic: The monad transformers in the MTL can be quite expensive compared to using hand-written monad instances unfortunately.
08:19:32 <GHAI> and i wondered what $ would be good for (did not read that far in lyah although encountered it a few times
08:19:33 <monochrom> I hate moving targets.
08:19:55 <GHAI> you need to fire patterns at them with high cadence and explosive rounds ;)
08:20:03 <ParahSail1n> cale, how expensive?
08:20:17 <rodlogic> Cale, atriq: the specific case I am considering is a StateT monad wrapping another Monad that already wraps IO
08:20:31 <monochrom> you are the moving target. do you want me to fire explosive stuff at you?
08:20:59 <GHAI> hrhr. that neccessary
08:21:05 <monochrom> get Debug.Trace to work first, ok? it comes with GHC, keep it simple and stupid
08:21:07 <Cale> ParahSail1n: I don't have specific measurements, but there have been at least one or two cases I've run into where it was a performance bottleneck.
08:21:18 <GHAI> actually the link was more for explanative reasons of what would ultimativly be nice
08:21:28 <GHAI> ok, lets have debug.trace
08:21:45 <Cale> rodlogic: But using Monad in general is fine. It costs exactly as much as an additional function parameter (the cost of using a type class)
08:21:59 <Owner1> is there an automated way to derive Typeable1 for something with kind    (* -> *) -> * -> * ? I can write the instance manually where I call    typeOf1 for the parameter with kind (* -> *) after applying it to ()
08:22:12 <rwbarton> :k Typeable1
08:22:14 <lambdabot> (* -> *) -> Constraint
08:22:23 <Cale> rodlogic: In any case, don't worry too much about it unless you're already having performance issues.
08:22:56 <rodlogic> Cale: ok
08:23:03 <rwbarton> Owner1: do you mean "instance Typeable1 f => Typeable1 (MyThing f)"?
08:23:13 <Cale> rodlogic: If you wrap up your uses of monad transformers using a newtype (so nobody outside your library can tell that you're using StateT, etc. then you can always replace the implementation with something better if it turns out to be slow.
08:23:14 <Owner1> rwbarton: exactly
08:23:26 <Cale> I meant to have ) after etc. there :)
08:23:28 <Owner1> ghc doesn't want to write that instance for me. I also tried derive
08:23:35 <rwbarton> if it doesn't work with DeriveTypeable and "... deriving (Typeable1)" try standalone deriving?
08:23:46 <rwbarton> sometimes that can be smarter
08:23:47 <Owner1> tried that too
08:23:49 <rwbarton> hm
08:23:56 <rwbarton> like "deriving instance Typeable1 f => Typeable1 (MyThing f)"?
08:24:28 * Owner1 thinks it has to do with the deriving mechanism not knowing that it can call    typeOf1 (undefined :: f ())
08:25:29 <rwbarton> I see
08:26:49 <GHAI> well, back to Debug.Trace. It seems to me that appending the trace line a bit customized to my functions yields their intermediate steps
08:27:15 <monochrom> then problem solved, no "not found" error.
08:27:36 <GHAI> well, the "not found" error actually was there
08:28:27 <GHAI> anyhow it is not anymore. now lets see if i get to some point where this actually enhances my understanding of a few list comprehension and recursive functions
08:28:52 <Owner1> rwbarton: do you think this problem would exist if Typeable was written with -XPolyKinds?
08:29:54 <rwbarton> I think in fact a future GHC will include a polykinded Typeable
08:30:04 <GHAI> as far as it seems to me the | trace ... is something that does io. although the signature says it does not
08:30:20 <monochrom> yes, it does backdoor I/O
08:30:35 <geekosaur> this means you need to be a bit careful with it
08:30:54 <monochrom> that's what "debugger" is all about. backdoors.
08:30:58 <geekosaur> and you may get surprises since GHC won't know to avoid e.g. evaluating it multiple times
08:31:35 <rwbarton> Owner1: in fact it's even the example of PolyKinds in the 7.4.1 release notes
08:31:44 <GHAI> "backdoor i/o" so its like unpure code that is marked pure to be able to use it in clean environments?
08:31:55 <monochrom> yes
08:31:58 <GHAI> where unpure is tainted with io
08:32:15 <GHAI> i assume there dragons where that comes from?
08:32:18 <GHAI> is
08:32:24 <monochrom> yes
08:32:40 <monochrom> that's what "debugger" is all about. backdoors and dragons.
08:32:45 <GHAI> :D
08:32:46 <GHAI> hahaha
08:32:54 <GHAI> somewhat correct
08:32:57 <monochrom> and it is not just haskell. it is all languages
08:33:28 <monochrom> every programming language's semantics says that some implementations are not supposed to be observable.
08:33:33 <monochrom> err
08:33:36 <GHAI> nice
08:33:39 <monochrom> every programming language's semantics says that some implementation details are not supposed to be observable.
08:33:52 <GHAI> the first use of trace yielded nice results
08:33:57 <rwbarton> like perl 6! zing
08:33:59 <monochrom> and the very thesis of "debugger" is to exactly observe those forbidden implementation details
08:34:56 <mm_freak> interesting notion
08:35:06 <mm_freak> monochrom++
08:35:27 <GHAI> :D
08:35:43 <dr_balor> Will ghc compile against newlib, or does it need a "full" GNU/BSD libc?
08:35:53 <monochrom> eh? GHC has this option -fpedantic-bottoms?!
08:36:42 <mapf> someone did use the haddock package? i want to get parsed markup but i can't see how to do it
08:38:01 <GHAI> hm. when i have the trace stanza in one of my helper functions (a merger) it breaks the main inifinite list that uses it
08:38:04 <GHAI> meh
08:39:21 <monochrom> printing out the whole infinite list is clearly an infinite loop
08:40:34 <rwbarton> seq on functions feels morally a bit dubious in the first place
08:40:40 <tac> an infinite loop? Or a productive loop?
08:42:33 <mapf> one nice execise with infinity data structures is to prune infinity forest to (obviously finite) graph
08:42:42 <GHAI> monochrom surely that is, although i use it with take 20 infinitelist
08:42:47 <monochrom> this one is not considered productive because the intention is to print a debugging message and move on with the computation, not print a debugging message forever and starve the computation
08:43:20 <GHAI> which actually yields the disired result, mostly due to lazy evaluation, and the call to the parameterless inifite liste actually yields the inifinte list
08:44:12 <nejucomo> How can I specify "do not match X" in parsec?
08:44:30 <atriq> noneOf "X"?
08:44:40 <nejucomo> I want to parse any characters up to two possible terminator strings.
08:44:57 <nejucomo> I need: [String] -> Parser ()
08:45:15 <mapf> noneOf "X" >> return ()
08:45:29 <nejucomo> :t noneOf
08:45:31 <lambdabot> Not in scope: `noneOf'
08:45:46 <ski> perhaps `manyTill'
08:45:46 <nejucomo> :t Text.Parsec.Char.noneOf
08:45:48 <lambdabot> Text.Parsec.Prim.Stream s m Char => [Char] -> Text.Parsec.Prim.ParsecT s u m Char
08:45:55 <nejucomo> sky: Thanks.  I think that's it.
08:46:14 <ski> @type Text.Parsec.Combinator.manyTill
08:46:16 <lambdabot> Text.Parsec.Prim.Stream s m t => Text.Parsec.Prim.ParsecT s u m a -> Text.Parsec.Prim.ParsecT s u m end -> Text.Parsec.Prim.ParsecT s u m [a]
08:46:37 * ski replaces the sky
08:46:53 <mapf> ha
08:46:58 <GHAI> the "did you mean" functions in ghci is nice
08:52:12 * hackagebot pwstore-cli 0.4 - Command line interface for the pwstore library  http://hackage.haskell.org/package/pwstore-cli-0.4 (RobertHelgesson)
08:54:57 <nejucomo> Hrm.  manyTill consumes the end marker, but I need to know which one it was...
08:55:15 <nejucomo> Gotta run.
09:01:36 <cornihilio> are there any popular haskell libraries under the gpl/agpl?
09:01:47 <copumpkin> I think hmatrix might be
09:02:01 <copumpkin> but BSD tends to be more popular in this community
09:02:19 <cornihilio> why is that?
09:02:42 <copumpkin> fewer restrictions on code use
09:02:46 <copumpkin> I assume
09:05:19 <mapf> cornihilio: gitit
09:07:21 <beaky> I love pattern matching
09:07:24 <beaky> how do you live without pattern matching?
09:07:33 <monochrom> by being a lisp fan
09:07:41 <beaky> ah i've never used Lisp much
09:07:56 <Jafet> monochrom: by doing exception-passing style?
09:07:59 <nand`> by living in the untyped lambda calculus
09:08:01 <beaky> how do they get around not having patterns? big cond blocks?
09:08:01 <monochrom> hahaha
09:08:14 <nand`> that reminds me
09:08:14 <johnw> and Python doesn't even have those
09:08:15 <beaky> exception passing style? :D what is that
09:08:17 <johnw> big if-else chains
09:08:19 <nand`> pattern matching via exception passing
09:08:22 <Guest16170> lol
09:08:34 <monochrom> exception-passing style: http://www.vex.net/~trebla/humour/Nightmare.java
09:08:40 <nand`> yes that
09:08:56 <beaky> lol
09:09:03 <tac> beaky: You ever notice how you can't really use (full) pattern matching with numeric types in Haskell? I hate that >_<
09:09:17 <beaky> what are numeric types
09:09:32 <monochrom> what does "full" pattern matching mean?
09:09:35 <beaky> do the logic programming languages have superior pattern matching to haskell?
09:09:40 <nand`> you can pattern match numeric types in haskell
09:09:44 <nand`> well
09:09:48 <tac> monochrom: it means you can't match n :: Nat with (succ n')
09:09:52 <nand`> by numeric types I mean the built-in Int, Integer, Float
09:10:00 <nand`> actually; I don't think you can pattern match on float that well
09:10:09 <nand`> since you can't match for eg. NaN, can you?
09:10:10 <tac> well, there's no Nat in Haskell
09:10:17 <tac> so.... that's part of the problem -.-
09:10:19 <mapf> tac: n + k patterns?
09:10:31 <monochrom> you're saying "f (x * (sin (y+1))^2) = ..."
09:10:52 <tac> mapf: Those are a hack to make your code look like a pattern match. But yeah, more or less.
09:11:08 <mapf> monochrom: we can define HOAS
09:11:11 <mapf> haha
09:11:19 <nand`> Int is like an enumeration type with 2^..whatever constructors; and you can ‘match’ on each constructor; f 1 = ...; f 2 = ...
09:11:26 <nand`> so I don't see what the difference is
09:11:33 <nand`> Int doesn't behave like peano Nat or whatever
09:12:18 <monochrom> if you want "s n" to be a pattern, first you must teach the compiler how to invert s
09:12:49 <monochrom> whether s turns out to be succ or sin
09:12:55 <GHAI> the ghci integrated debugger almost looks like real debugger
09:13:06 <GHAI> as in "non-printf-debugging"
09:13:33 <monochrom> here we're running into the phenomenon that the "meaning" of succ and sin are "obvious" to you but completely meaningless to the computer
09:14:02 <tac> I should start refering to Peano nats as "succ'y numbers"
09:14:09 <monochrom> and therefore "f (sin x) = ..." is "obviously" "doable" "I don't see why not" to you. but not to the computer
09:14:09 <GHAI> xD
09:15:08 <Cale> hmm...
09:15:42 <atriq> f (sin x) = ... isn't doable, though
09:15:54 <atriq> There's the big question over which range you take asin for
09:16:01 * Cale .oO(Dependent typeclass of invertible functions specifying their inverses?)
09:16:16 <Jafet> x :: TypeWhoseSineIsInvertable
09:16:22 <mapf> wat
09:16:23 <Jafet> a => a
09:17:20 <romildo> Is the function (\action x -> action >> return x) already available in some library (maybe as an operator)?
09:17:35 <Cale> Almost wrong to call it a type class at that point -- I'm thinking of a class-like thing but indexed by values.
09:17:47 <atriq> romildo, flip (<$)?
09:17:50 <rwbarton> value class
09:17:55 <Cale> yeah
09:17:57 <rwbarton> @hoogle m a -> b -> m b
09:17:57 <lambdabot> Data.Functor (<$) :: Functor f => a -> f b -> f a
09:17:58 <lambdabot> Control.Applicative (<$) :: Functor f => a -> f b -> f a
09:17:58 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
09:18:12 <atriq> > flip (<$) [1,2,3] 8
09:18:14 <lambdabot>   [8,8,8]
09:18:32 <Cale> Of course, it's a bit nonsense, because without a comparison on those values, it's pretty hopeless.
09:18:58 <Cale> How do you tell that the function you have is really sin, for instance.
09:19:51 <Cale> (it's uncomputable in general, and in this case, prohibitively expensive to check that an arbitrary function is equal to sin :: Double -> Double, say
09:19:54 <Cale> )
09:19:59 <monochrom> no. f (sin x) = ...x... is sugar for f y | y is in range = ... asin y ...
09:20:23 <djahandarie> Sins are just sugar?
09:20:47 <nart> hi
09:20:56 <Jafet> They cause cancer in the monads.
09:21:24 <monochrom> f (g x) = ...x... is sugar for f y | y is in range of g = ... g^-1 y ...
09:21:25 <Cale> monochrom: Yeah, I was thinking about a mechanism which would generalise such sugar, but it doesn't really work out for this because of the fact that we're talking about functions.
09:22:00 <monochrom> someone has to teach the computer how to invert g and how to test the range part. then it's just desugaring
09:22:10 <Cale> The problem is that even if you have a mechanism for recording what g^-1 is for various g, you still have the problem of comparing other functions which might occur in patterns with the set of g's that you know about.
09:22:38 <ski> beaky : matching is bidirectional in logic programming
09:22:45 <Cale> Unless you sell out and just base it on the name of g, rather than on the value of g
09:23:01 <monochrom> you're saying, f (sin x) = True, f (cos x) = False, what is f 0.5
09:23:11 <monochrom> I'm saying, f 0.5 = True
09:23:20 <Cale> No, that's not what I'm saying
09:23:46 <ski> Cale : you can do this (to some extent) in Mercury, with the mode system
09:24:26 <johnw> yay, Hat now works with GHC 7.6!  (using a patch I just submitted)
09:24:45 <Cale> monochrom: I'm saying that the mechanism for matching sin and giving asin as its inverse to use in the desugaring either has to do something very expensive to test that the function is equal to sin, or it has to compare based on the name of the function rather than which actual function it is.
09:24:59 <ski> because `:- mode append(in,out) = in is semidet.', you can say `f(append([0,1,2],Xs)) = ..Xs..'
09:25:21 <Jafet> Cale: just make the language require every function to be given with its inverse
09:25:34 <mapf> how to import specific package in ghci? i have installed two versions of Cabal and there are mismatch
09:25:53 <monochrom> by extensionality, you can just do syntactic lookup
09:26:36 <mapf> so i want import Cabal-1.16.*:Distribution.Verbosity but import Distribution.Verbosity imports Cabal-1.14.*
09:27:24 <rwbarton> you really want to import Cabal modules in ghci?
09:27:27 <Jafet> Come to think about it, if you used a language like cat it would be easy, you just reverse the program.
09:27:57 <ski> (Jafet : Mercury keeps track of which functions you have specified to be invertible (which is checked, of course))
09:28:03 <mapf> rwbarton: hm, yes
09:28:06 <monochrom> Suppose g and sin are extensionally equal. then g^-1 and sin^-1 are extensionally equal. the tests (is in range of g?) and (is in range of sin?) are extensionally equal. therefore, to compile "f (sin x) = ...", you may use either sin or g, does not matter, so use sin because of the name match, it's simpler and wlog
09:29:02 * ski thinks `sin' here is not a good example
09:30:04 <Jafet> It was a random example, as von Neumann would have put it
09:32:13 * hackagebot chuchu 0.3 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.3 (FelipeLessa)
09:33:08 <monochrom> use sqrt for a better example
09:33:56 <mapf> wtf is cucumber?
09:34:14 <bitonic> @google cucumber behavior driven
09:34:16 <lambdabot> http://cukes.info/
09:34:16 <lambdabot> Title: Cucumber - Making BDD fun
09:34:21 <bitonic> it's the magic of google
09:34:23 <rwbarton> here I have Cabal-1.14.0 and Cabal-1.16.0.1 and "import Distribution.License" gives me the 1.16.0.1 version as I would expect
09:34:33 <monochrom> I am not re-inventing Mathematica here. this is just number crunching, none of those symbolic algebra shit
09:35:51 <rwbarton> unless I use "ghci -package Cabal-1.14.0", then I get the 1.14.0 version
09:35:56 <mapf> rwbarton: oh, yes. but i need 1.14.0
09:36:00 <johnw> byorgey: you around?
09:36:03 <rwbarton> what
09:36:17 <mapf> i see)
09:36:19 <mami> how can i use modulo and an equality check with "filter"? "filter ((`mod` 3) == 0) [1..100]" and similar do not work
09:36:21 <rwbarton> very confused
09:36:27 <rwbarton> < mapf> so i want import Cabal-1.16.*:Distribution.Verbosity but import Distribution.Verbosity imports Cabal-1.14.*
09:36:31 <rwbarton> < mapf> rwbarton: oh, yes. but i need 1.14.0
09:37:30 <ski> > filter ((0 ==) . (`mod` 3)) [0 .. 99]
09:37:32 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
09:37:59 <rwbarton> or you can write it straightforwardly
09:38:08 <ski> > filter (\n -> n `mod` 3 == 0) [0 .. 99]
09:38:10 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
09:38:24 <johnw> @pl \n -> n `mod` 3 == 0
09:38:25 <lambdabot> (0 ==) . (`mod` 3)
09:38:29 <monochrom> mapf: firstly, I recommend not having different versions, unless you are a pro in cabal business. secondly, if you insist, some options are: what rwbarton says about -package; use myproject.cabal to specify versions, which is a wrapper over -package; GHC extension "PackageImports" (7.3.19)
09:38:38 <nand`> > [0,3..100]
09:38:39 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
09:38:42 <ski> > let divisiblyByThree n = n `mod` 3 == 0 in filter divisiblyByThree [0 .. 99]
09:38:43 <beaky> what is life like without recursion, higher-order functions, and lambdas?
09:38:43 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
09:38:51 <rwbarton> mapf: you could also hide one version globally
09:38:59 <johnw> i like nand`'s version ;)
09:39:04 <johnw> [0,3..]
09:39:24 <beaky> takeWhile (<100) [0. 3..]
09:39:29 <beaky> > takeWhile (<100) [0, 3..]
09:39:31 <lambdabot>   [0,3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,...
09:39:54 <ski> mami : .. any of those good enough ?
09:40:04 <monochrom> life without recursion, hof, and lambdas goes back to the BASIC :)
09:40:40 <beaky> ah the BASIC age
09:40:56 * ski . o O ( `POKE 53280,0' )
09:41:35 <beaky> LET X := 0
09:42:48 <johnw> beaky: why use takeWhile?  [0,3..99]
09:42:55 <beaky> right
09:43:02 <ski>   poke (nullPtr `plusPtr` 53280) 0  -- present-day version
09:43:08 <beaky> :t poke
09:43:10 <lambdabot> Not in scope: `poke'
09:43:24 <ski> @type Foreign.Storable.poke
09:43:26 <lambdabot> Foreign.Storable.Storable a => GHC.Ptr.Ptr a -> a -> IO ()
09:47:20 <mami> ski yeah thanks
09:47:35 <mami> what does the (\n -> n `mod` 3 == 0) notation mean?
09:47:47 <johnw> it's a lambda function
09:48:01 <johnw> it's the same as defining anon n = n `mod` 3 == 0
09:48:06 <johnw> and then use anon in place of the lambda
09:48:11 <mami> hmm have to look that up
09:48:18 <johnw> yes indeed, they are super common
09:48:20 <beaky> why use mod over rem?
09:48:29 <mami> and the (0 ==) . (`mod` 3)?
09:48:42 <johnw> i'd ignore that for now, if you aren't familiar with lambdas yet
09:48:44 <mami> beaky: just started to learn haskell
09:48:47 <beaky> ah
09:49:01 <mami> a week ago someone pointed me to learnyouahaskell
09:49:02 <ski> mami : `\n -> ..n..' means : the function that given an input, call it `n', returns `..n..'
09:49:16 <mami> and the list comprehensions alone left a deep impression
09:49:27 <ski> > map (\n -> n^2 + 1) [0 .. 9]
09:49:29 <lambdabot>   [1,2,5,10,17,26,37,50,65,82]
09:49:31 <ski> > map (\n -> n^2 + 1) [0 .. 9] :: [Expr]
09:49:32 <lambdabot>   [0 * 0 + 1,1 * 1 + 1,2 * 2 + 1,3 * 3 + 1,4 * 4 + 1,5 * 5 + 1,6 * 6 + 1,7 * ...
09:49:38 <mami> ah good
09:49:58 <ski> mami : sometimes you don't care to give a function a name, you just want to use it once
09:50:17 <mcstar> or many time ^^
09:50:18 <beaky> if (0 ==) was f, and (`mod` 3) was g, then ((0 ==) . (`mod` 3)) x is equal to f (g x)
09:50:20 <mcstar> s
09:50:35 <ski> > [n^2 + 1 | n <- [0 .. 9]]
09:50:35 <mami> makes sense
09:50:36 <lambdabot>   [1,2,5,10,17,26,37,50,65,82]
09:50:45 <Abso> how can I pass the "<=" function to another function ?
09:50:47 <ski> @src .
09:50:48 <lambdabot> (f . g) x = f (g x)
09:50:48 <lambdabot> NB: In lambdabot,  (.) = fmap
09:50:52 <ski> Abso : `(<=)'
09:51:03 <Abso> oh ok
09:51:10 <ski> > sortBy (<=) [4,2,8,5,7,1]
09:51:11 <lambdabot>   Couldn't match expected type `GHC.Types.Ordering'
09:51:12 <lambdabot>              with actual ...
09:51:17 <kennyd> > map (^2) [1..5]
09:51:17 <ski> oh, right
09:51:19 <lambdabot>   [1,4,9,16,25]
09:51:39 <kennyd> map ((^2) . (+1)) [1..5]
09:51:40 <mami> > [1..3]
09:51:42 <lambdabot>   [1,2,3]
09:51:49 <ski> > let ns = [4,2,8,5,7,1] in zipWith (<=) ns (tail ns)
09:51:51 <lambdabot>   [False,True,False,True,False]
09:51:53 <kennyd> > map ((^2) . (+1)) [1..5]
09:51:55 <lambdabot>   [4,9,16,25,36]
09:52:03 <nyc> :t comparing
09:52:04 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:52:37 <nyc> > sortBy (comparing (<=)) [4,2,8,5,7,1]
09:52:39 <lambdabot>   *Exception: (==): No overloading for function
09:53:56 <atriq> :t comparing
09:53:57 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
09:55:57 <johnw> oh, very cool, I didn't know about comparing
09:56:23 <mcstar> :t compare `on`
09:56:24 <lambdabot> parse error (possibly incorrect indentation)
09:56:27 <Abso> oh my god, my function is so awesome now
09:56:35 <mcstar> :t on compare
09:56:37 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
09:56:38 <johnw> yeah, i'd been using compare `on`
09:56:43 <ski> > sortBy (comparing length `mappend` compare) (words "The quick brown fox jumps over the lazy dog")
09:56:44 <mcstar> so, its the same
09:56:45 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
09:57:23 <johnw> ski: i will have to make a note of that trick!
09:58:15 <mcstar> sort the equal length words alphabetically?
09:58:40 <johnw> sort alphabetically, then by length
09:58:52 <johnw> so, sort and sub-sort
09:59:11 <mcstar> no, sort by lenght, and then alphabetically
09:59:33 <johnw> well, not quite
09:59:38 <johnw> if I sort by length, I get small to large
09:59:53 <johnw> if I *then* sort alphabetically, I undo that sort
10:00:06 <mcstar> "sort the equal length words alphabetically?"
10:00:09 <johnw> so, I have to sort alpha first, then by length, to get the output he showed
10:00:16 <mcstar> thats what i said, yes, you sort by length first
10:00:19 <johnw> mcstar: that doesn't say that the list is sorted by length too
10:00:27 <johnw> you sort by alpha first
10:00:29 <mcstar> because it was trivial
10:00:47 <johnw> sortBy (comparing length) $ sort ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:00:53 <johnw> > sortBy (comparing length) $ sort ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:00:55 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:01:04 <johnw> > sort $ sortBy (comparing length) ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:01:06 <lambdabot>   ["The","brown","dog","fox","jumps","lazy","over","quick","the"]
10:01:15 <johnw> that's what happens if you do length first then alpha
10:01:56 <monochrom> the haskell fox leaps lazily over the ocaml dog :)
10:02:02 <parcs`> :t (<>)
10:02:04 <lambdabot>     Ambiguous occurrence `<>'
10:02:04 <lambdabot>     It could refer to either `Data.Monoid.<>',
10:02:04 <lambdabot>                              imported from `Data.Monoid' at State/L.hs:35:1-18
10:02:30 <gertc> is it difficult to create a equal instance on a sink, so i can do sink1 == sink2? http://hackage.haskell.org/packages/archive/websockets/0.7.0.0/doc/html/src/Network-WebSockets-Monad.html#Sink
10:02:47 <Cale> > sortBy (comparing length `mappend` compare) (words "The dog fox the lazy over brown jumps quick")
10:02:49 <lambdabot>   ["The","dog","fox","the","lazy","over","brown","jumps","quick"]
10:03:03 <Cale> oh, right, that's already been mentioned
10:03:05 <Abso> ((<=).not) 1 2 , why is this not working ?
10:03:19 <johnw> Abso: rewrite that as a lambda
10:03:42 <johnw> @unpl ((<=).not)
10:03:42 <lambdabot> (\ c -> (<=) (not c))
10:03:46 <Cale> Abso: ((<=) . not) 1 2 = (<=) (not 1) 2 = (not 1) <= 2
10:03:48 <ski> johnw : "Monoids? In my programming language?", comment by Cale at <http://www.reddit.com/r/programming/comments/7cf4r/monoids_in_my_programming_language/c06adnx>
10:03:53 <Cale> Abso: But 1 isn't a truth value
10:04:15 <felix2_> hi
10:04:15 <Abso> Ah
10:04:19 <Abso> makes sense ^^
10:04:44 <geekosaur> Abso, I think you have your functions swapped.  (not . (<=)), maybe
10:05:18 <mcstar> johnw: you are missing my point
10:05:24 <Cale> (not . (<=)) 1 2 = not ((<=) 1) 2, but ((<=) 1) isn't a Bool either
10:05:36 <mcstar> what i said was, sort the list by length, and sort the equal length words alphabetically
10:05:55 <mcstar> thats one way to imagine what happens
10:06:01 <Cale> You could write ((not .) . (<=))
10:06:10 <Cale> > ((not .) . (<=)) 1 2
10:06:12 <lambdabot>   False
10:06:24 <Cale> But this is a bit funny
10:06:35 <Cale> Better just to use a lambda here
10:06:35 <mcstar> if the sort is not a stable sort, your double sort doesnt work
10:06:41 <Abso> how does that work ?
10:07:13 <nand`> :t concat . map sort . groupBy ((==) `on` length) . sortBy (comparing length)
10:07:13 <nand`> ^ the uglier way to do it
10:07:14 <johnw> mcstar: ah, your wording didn't mention sub-sorting (as in, mapping a sort over a partitioned list)
10:07:14 * hackagebot crypto-pubkey-types 0.2.0 - Generic cryptography Public keys algorithm types  http://hackage.haskell.org/package/crypto-pubkey-types-0.2.0 (VincentHanquez)
10:07:15 <lambdabot> Ord a => [[a]] -> [[a]]
10:07:34 <carasufo> [1..x]
10:07:40 <carasufo> [1..]
10:07:43 <Cale> ((not .) . (<=)) 1 2 = (not .) ((<=) 1) 2 = (not . (<=) 1) 2 = not ((<=) 1 2) = not True
10:07:52 <nand`> surely not .: (<=)  =  (>)
10:07:53 <carasufo> take 5 [1..]
10:08:25 <Cale> Or more generally,
10:08:39 <ski> > (map (sortBy compare) . groupBy (equating length) . sortBy (comparing length)) (words "The quick brown fox jumps over the lazy dog")
10:08:41 <lambdabot>   [["The","dog","fox","the"],["lazy","over"],["brown","jumps","quick"]]
10:08:55 <Cale> ((f .) . g) x y = (f .) (g x) y = (f . g x) y = f (g x y)
10:08:59 <ski> > (groupBy (equating length) . sortBy (comparing length)) (words "The quick brown fox jumps over the lazy dog")
10:09:01 <lambdabot>   [["The","fox","the","dog"],["over","lazy"],["quick","brown","jumps"]]
10:09:01 <byorgey> carasufo: if you want lambdabot to evaluate your expressions you need to put  >  in front of them
10:09:06 <byorgey> > take 5 [1..]
10:09:07 <lambdabot>   [1,2,3,4,5]
10:10:03 <johnw> ski: thanks
10:10:21 <ski> johnw : what nand` said is basically the same thing
10:10:31 <signalsea> is there a way i can define fmap for Set without it conflicting with functor's fmap? would i need to put the class declaration in a seperate module?
10:10:38 <johnw> nand`: thanks
10:10:43 <Abso> ah yeah that makes sense, thanks
10:10:53 <johnw> signalsea: um, create a differently named function?
10:11:15 <johnw> signalsea: most of the container-specific mapping functions are called "map" generally
10:11:27 <johnw> makes importing extra fun
10:11:27 <nand`> Cale's version is still best
10:11:32 <nand`> or uh I guess ski mentioned that one initially
10:11:44 <johnw> :t (f .) . g
10:11:45 <lambdabot> (Functor f1, Functor f, Show a, FromExpr (f (f1 a)), FromExpr b) => f (f1 b)
10:11:47 <johnw> :t (.:)
10:11:49 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
10:12:05 <johnw> > f .: g $ x y
10:12:07 <lambdabot>   The function `Debug.SimpleReflect.Vars.x'
10:12:07 <lambdabot>  is applied to one argument,
10:12:07 <lambdabot>  but...
10:12:13 <parcs`> @check (<= True)
10:12:14 <lambdabot>   Not in scope: `myquickcheck'
10:12:18 <byorgey> signalsea: Set is not an instance of Functor anyway.
10:12:19 <nand`> hmm
10:12:20 <nand`> :t (<>)
10:12:22 <lambdabot>     Ambiguous occurrence `<>'
10:12:22 <lambdabot>     It could refer to either `Data.Monoid.<>',
10:12:22 <lambdabot>                              imported from `Data.Monoid' at State/L.hs:35:1-18
10:12:23 <manju> bos, Hello ?
10:12:24 <johnw> byorgey!
10:12:26 <Cale> sortBy (comparing length) kind of sucks though
10:12:37 <byorgey> oh, but perhaps you mean you want to use the *name* fmap.
10:12:39 <Cale> because it recomputes lengths repeatedly
10:12:47 <byorgey> that's probably not a good idea anyway.
10:12:48 <signalsea> I know, but it is a functor if restricted to instances of Ord
10:12:51 <byorgey> johnw!
10:12:51 <signalsea> isn't it?
10:12:53 <geekosaur> byorgey, I suspect that's what they're trying to "fix"
10:12:58 <nand`> :t (++)
10:12:59 <johnw> byorgey: can you give me a hint of where to start making the mathjax change to BlogLiterately?  I cannot see the connection between Pandoc's API, how it handles math rendering, and what BlogLiterately is doing...
10:12:59 <lambdabot> Monoid m => m -> m -> m
10:13:27 <Cale> So if you want to be efficient about this, it would be better to do something like:
10:13:34 <byorgey> signalsea: mathematically, yes, but the naive implementation only works for order-preserving maps
10:14:03 <bos> manju: yes?
10:14:04 <lambdabot> bos: You have 4 new messages. '/msg lambdabot @messages' to read them.
10:14:14 <byorgey> johnw: sure, just a minute
10:14:20 <Cale> > map snd . sort . map (length &&& id) $ words "the quick brown fox jumps over the lazy dog"
10:14:22 <lambdabot>   ["dog","fox","the","the","lazy","over","brown","jumps","quick"]
10:14:24 <manju> bos, Did you write criterion ?
10:14:29 <ski> > ((f :: Expr -> Expr) .: g) x y
10:14:31 <lambdabot>   f (g x y)
10:14:35 <bos> yes
10:14:47 <byorgey> johnw: first of all, I did send you a link to http://hub.darcs.net/byorgey/BlogLiterately/issue/2 , right?
10:15:16 <johnw> yes, let me read it again
10:15:23 <johnw> ok, I did read that
10:15:27 <byorgey> ok, it might not be that helpful, just making sure
10:15:29 <johnw> and I've looked at your source and the Pandoc source
10:15:31 <bos> manju: yes
10:15:42 <johnw> but you aren't using the data type for HTMLMathRendering anywhere in your code
10:16:05 <manju> bos, ok, one moment. I have some code that I am trying to benchmark and it doesn't get run by Criterion. I think it is a bug.
10:16:19 <bos> manju: very likely to be a bug in your code
10:16:23 <signalsea> byorgey: how do you mean, only works for order preserving maps? Doesn't Set take care of that automatically?
10:16:27 <manju> bos, ok
10:16:38 <byorgey> johnw: pandoc gets invoked right here: http://hub.darcs.net/byorgey/BlogLiterately/browse/src/Text/BlogLiterately/Transform.hs#159
10:17:03 <byorgey> johnw: so you'd have to set the HTML math rendering mode in the writeOpts
10:17:14 * hackagebot cryptocipher 0.3.6 - Symmetrical Block, Stream and PubKey Ciphers  http://hackage.haskell.org/package/cryptocipher-0.3.6 (VincentHanquez)
10:17:17 <johnw> byorgey: btw, I have a GHC 7.6 patch for you too
10:17:27 <byorgey> johnw: oh, great
10:17:35 <byorgey> xformDoc gets a BlogLiterately argument, which is a record of command-line options
10:17:47 <johnw> pull request sent
10:17:59 <byorgey> so it should just be adding a command-line argument (as described in that ticket) and then using that to set the writeOpts
10:18:34 <byorgey> though it's possible there's something more complicated going on that I don't understand
10:19:22 <byorgey> johnw: hmm, this is a pull request for BlogLiterately?
10:19:41 <byorgey> maybe I don't know where to find the pull requests in the hub.darcs.net interface
10:19:48 <johnw> ahh, writerHTMLMathMethod
10:19:59 <johnw> byorgey: oh, whoops
10:20:05 <johnw> i sent myself a pull request on github apparently :)
10:20:07 <johnw> https://github.com/jwiegley/BlogLiterately/pull/1/files
10:20:08 <johnw> that's the patch
10:20:10 <byorgey> hahaha
10:20:29 <johnw> ~> is no longer available in 7.6
10:20:43 <byorgey> ah, right
10:21:19 * ski . o O ( `data MappedSet b = forall a. Ord a => MapIncl (a -> b) (Set a); instance Functor MappedSet where {fmap f (MapIncl g s) = MapIncl (f . g) s}; fromMappedSet :: Ord a => MappedSet a -> Set a; fromMappedSet (MapIncl f s) = Data.Set.map f s' )
10:21:22 <byorgey> cool, didn't know about bool-extras
10:22:02 <johnw> neither did I, but Hoogle did :)
10:22:13 <byorgey> signalsea: it depends how you implement it.  if you implement mapping over a set by re-inserting every mapped element into a new set, it takes care of it automatically
10:22:26 <byorgey> signalsea: but if you just map over the underlying tree structure...
10:22:53 <geekosaur> signalsea, the problem with fmap over a Set (or anything else with a constraint) is that the constraint *cannot* be maintained across the map.  ^^  this is why types with constraints aren't Functors
10:23:07 <ski> signalsea : .. would something like that work ?
10:24:01 <johnw> geekosaur: excellent point
10:24:24 <johnw> the homomorphism restriction
10:26:53 <pls> Hi, I would like to know a simple information (I think, I'm a newbie :))... I have a file .hs and I would like to create its executable version from HUGS. Is it possible? thanks
10:26:57 <pordan30> are there recommended graph visualization libraries for haskell, preferably not the graphviz bindings from the trees library? the intended application would be visualizing state transitions in abstract machines implementing lazily evaluated functional languages, e.g., as in jones and lester's "implementing functional languages: a tutorial."
10:27:11 <signalsea> maybe I'll try it ski. thanks.
10:27:50 <byorgey> pls: no, hugs is only an interpreter.
10:28:15 <signalsea> geekosaur: doesn't Set.map do that?
10:28:24 <byorgey> pls: hugs is very old (it has not been updated since 2006).  You should install the Haskell Platform (which comes with GHC) instead.
10:28:48 <byorgey> pls: or if this is on a computer you do not have control over, you should ask your system administrator to install the haskell platform.
10:29:21 <tomboy64> hello.
10:29:37 <johnw> pordan30: there's the diagrams packag
10:29:41 <tomboy64> might i request the inclusion of attobencode into the tree?
10:29:58 <johnw> http://projects.haskell.org/diagrams/tutorial/DiagramsTutorial.html
10:30:03 <byorgey> diagrams doesn't have any graph visualization built in
10:30:19 <byorgey> but you could easily implement your own
10:30:44 <byorgey> tomboy64: hmm? what tree?
10:31:04 <pordan30> johnw: thanks, i will take a look at that
10:31:40 <johnw> pordan30: byorgey knows a /ton/ more about diagrams than I do
10:33:18 <hpaste> gertc pasted “?” at http://hpaste.org/77613
10:33:53 <geekosaur> signalsea, Set.map constructs a new Set, it doesn't replace nodes in the existing Set which is what an fmap would do.  See what byorgey said
10:34:40 <byorgey> I mean, fmap *could* be implemented like Set.map, if it weren't for the fact that it only works for Ord types which doesn't fit into the current Functor class
10:34:49 <pls> thanks, byorgey....I tried with the haskell platform (ghc) but, unhapilly, I didn't manage to create the final .exe file (the ghc --make myfile.hs) generated several .o and .hi files, but not the .exe)
10:35:17 <pls> However, I managed to do this with a simple helloworld example :(
10:35:18 <byorgey> pls: oh, that's probably because it expects a module called Main to create an .exe from
10:35:24 <johnw> byorgey: that would be an fmap for Hask/Ord, right, rather than Hask?
10:35:27 <pls> hum....
10:35:39 <pls> maybe....i will try now
10:35:40 <byorgey> pls: if the module you have which contains your 'main' function is not called 'Main' you can pass the  -main-is Foo  option to GHC
10:35:48 <byorgey> if the module is named Foo
10:36:21 <mcstar> maybe you are on linux, and there is no .exe extension
10:36:22 <bos> manju: did you figure out your problem?
10:36:31 <signalsea> but if fmap :: (a -> b) -> f a -> f b    and (f = Set) and it's parameter must be an Ord, then won't the typechecker make sure b is also Ord?
10:36:41 <byorgey> johnw: yes, though if we are talking about the Hask/Ord category, I would expect arrows in that category to be *only* order-preserving functions
10:36:43 <manju> bos: I am trying to make a short reproducable version of the program.
10:36:57 <byorgey> signalsea: no
10:37:02 <geekosaur> signalsea, no.  fmap *cannot* pass on any constraint, including Ord
10:37:08 <signalsea> hmm
10:37:08 <signalsea> ok
10:37:15 <byorgey> why would it?  the type of fmap says it can return *any* type the caller wants.
10:37:28 <byorgey> so I should be able to use fmap to change a set of Ints into a set of functions.
10:37:46 <pordan30> you can implemented fmap for set in terms of restricted functors, if i recall correctly. otherwise, you can implemented constrained versions of common typeclasses using associated types or multiparameter type classes.
10:38:02 <byorgey> that's right.
10:38:25 <signalsea> that is what i was thinking of doing
10:38:43 <ski> pls : does GHCi work ?
10:39:20 <signalsea> byorgey: doesn't the result type have to be in the same functor as the paramater type?
10:39:37 <Cale> heh, what a coauthor list: https://cdsweb.cern.ch/record/1493302/files/PAPER-2012-043.pdf
10:39:46 <ski> signalsea : my `MappedSet' secretly passes an `Ord' constraint inside
10:40:09 <ski> (but `union' will probably not work)
10:41:07 <byorgey> signalsea: I don't understand your question.
10:41:07 <ski> signalsea : `Set (IO Bool)' is a valid type
10:41:26 <jfischoff> does anyone know the best way to get cairo working on mac?
10:41:27 <lambdabot> jfischoff: You have 2 new messages. '/msg lambdabot @messages' to read them.
10:41:32 <jfischoff> @messages
10:41:32 <lambdabot> nand` said 1d 8h 10m 32s ago: If you're interested, I scrapped :==: and implemented a sorting algorithm instead, so that insertions are always sorted afterwards. Then you can drop the annoying (a :==
10:41:33 <lambdabot> : b) ~ True constraint and just re-use the same variable
10:41:33 <lambdabot> nand` said 1d 8h 9m 25s ago: Of course, the Right Thing would be to implement a search tree or something, but I don't know how to make sure they're always normalize into the same representation
10:41:33 <lambdabot> regardless of what order you construct it in
10:41:36 <byorgey> jfischoff: yes, carter does
10:42:07 <jfischoff> carter: ping
10:42:11 <carter> jfischoff byorgey , yeup, i've beenn known to figure out how to get it all working :)
10:42:26 <byorgey> jfischoff: there are some instructions on http://www.haskell.org/haskellwiki/Diagrams/Install
10:42:28 <carter> jfischoff: doyou have mac brew installed?
10:42:35 <jfischoff> yeah
10:42:55 <carter> have you tried those directions?
10:43:10 <carter> (they're a cleaned up version of the original ones i've derived)
10:43:15 <jfischoff> the ones byorgey linked to?
10:43:19 <carter> yes
10:43:39 <jfischoff> cool I'll give it a shot
10:43:47 <mcstar> Cale: heh, not going to fit the 4 pages requirement of PRL
10:43:51 <carter> used to be even more  complicated because mac brew would use a partially installed version of a certain C-lib that woulc cause no end to pain
10:44:01 <signalsea> byorgey: something like... class Ord a =>RFunctor f where  fmap :: (a -> b) -> f a -> f b    would imply both a and b are Ord, wouldn't it?
10:44:19 <ski> no
10:44:21 <byorgey> signalsea: no
10:44:31 <carter> to get the original directions, had to try builing the gtk-cairo stuff under a whole bunch of different pieces of including / withholding static / dylib bits
10:44:43 <carter> jfischoff those directions *should* work
10:44:44 <signalsea> err
10:44:51 <carter> though you'll have to wait ~ 20 min
10:44:54 <jfischoff> carter: I got Unsatisfied dependency: XQuartz is that expected?
10:44:55 <carter> after everything builds :)
10:44:58 <carter> YES
10:45:04 <carter> go install that
10:45:05 <signalsea> didn't quite write that correctly.
10:45:10 <carter> thats X windows
10:45:14 <jfischoff> aye
10:45:19 <signalsea> anyways i think i might just go play around and see what dumb things happen for myself
10:45:41 <carter> hrm.... byorgey : we should add ""make sure you have Xquartz / aka X windows installed"
10:45:49 <byorgey> carter: it's a wiki =)
10:45:52 <carter> true
10:46:16 <signalsea> ... with ski  and pordan30s suggestions
10:47:02 <carter> byorgey jfischoff done
10:47:11 <byorgey> carter: thanks!
10:47:20 <jfischoff> ah I was trying to login :(
10:47:21 <nand`> class RFunctor f where type Ctx f :: * -> Constraint; fmap :: (Ctx a, Ctx b) => (a -> b) -> f a -> f b
10:48:16 <signalsea> thank you nand, I was about to go learn how to write that
10:48:22 <carter> np
10:49:35 <gertc> do not understand when to use deriving instance? example deriving instance Eq Bool http://www.haskell.org/ghc/docs/7.6.1/html/libraries/ghc-prim-0.3.0.0/src/GHC-Classes.html
10:49:37 <nand`> I'm not sure if that's what byorgey or anybody else were discussing; just thought it seemed like a possibility
10:50:13 <scp> @pl f g a b = f (g a) b
10:50:13 <lambdabot> f = fix (.)
10:50:14 <manju> bos, http://hpaste.org/77614
10:50:23 <manju> I don't think that is working.
10:50:28 <manju> Can you take a look ?
10:53:12 <pordan30> since every functor is a restricted functor, is there a reason beyond backwards compatibility that restricted functors haven't become the de facto standard? recent material on haskell doesn't seem to endorse or mention their use.
10:53:39 <atriq> What's the difference between the two?
10:53:40 <linduxed> hey guys i've got this code, and i'm constantly messing up the foldl part https://gist.github.com/4061143
10:54:09 <linduxed> currently i'm getting MolSeq.hs|18 col 37 error| Couldn't match type `Char' with `Molecule'
10:55:00 <Jeanne-Kamikaze> switch the order linduxed
10:55:10 <Jeanne-Kamikaze> accumulator -> element -> accumulator
10:55:28 <Botje> linduxed: seqType should take two arguments
10:55:33 <Botje> oh bleh
10:55:39 <linduxed> Jeanne-Kamikaze: for what?
10:55:44 <linduxed> Jeanne-Kamikaze: i'm confused
10:55:45 <pordan30> :t fldl
10:55:45 <Jeanne-Kamikaze> for seqType
10:55:46 <pordan30> :t foldl
10:55:46 <lambdabot>     Not in scope: `fldl'
10:55:47 <lambdabot>     Perhaps you meant one of these:
10:55:47 <lambdabot>       `foldl' (imported from Data.List),
10:55:48 <lambdabot> (a -> b -> a) -> a -> [b] -> a
10:56:02 <Jeanne-Kamikaze> exactly
10:56:10 <Jeanne-Kamikaze> a = Molecule
10:56:11 <Botje> linduxed: I don't think you want a foldl there.
10:56:13 <Jeanne-Kamikaze> b = Char
10:57:00 <Jeanne-Kamikaze> actually, what Botje said
10:57:05 <linduxed> Botje: well the idea is that it gets a string and checks against nucleotides and aminoacids if the characters are there
10:57:27 <scp> @pl f g h a b = g (h a) b
10:57:27 <lambdabot> f = (.)
10:57:30 <Botje> linduxed: I think you want to check something like all (`elem` nucleotides) inSequence = DNA
10:57:36 <linduxed> i've read that if you "go through a list and use a function on each element, then you can use fold"
10:57:42 <pordan30> the errors indicates that seqType :: Char -> Molecule, but foldl expects a function f :: Molecule -> Char -> Molecule. you need to provide a molecule argument to seqType, and do something sensible with it
10:57:47 <linduxed> Botje: oh yeah, that's an idea
10:58:11 <Botje> linduxed: fold is when you want to reduce a list down to one element according to some operator.
10:58:32 <linduxed> Botje: isn't that what i was trying to do?
10:58:53 <pls> byorgey: thanks!!! I got your hints and I managed (:)) now, i must to solve some incompatiblities (e.g. getChar does not work as I expected into the .exe file genereted by the ghc compile)... anyway, thank you more once
10:59:01 <Botje> linduxed: it would be awkward at best with foldl.
10:59:41 <ski> pls : perhaps `hSetBuffering stdin NoBuffering' ?
10:59:50 <byorgey> pls: oh, you may have to turn off buffering, like what ski suggested
10:59:58 <byorgey> but buffering is broken on windows I think
11:00:24 <monochrom> don't use getChar
11:01:18 <jfischoff> carter: I got (gtk-demo:46854): Gtk-WARNING **: cannot open display: when I tried to run the demo
11:01:24 <jfischoff> any ideas?
11:01:33 <carter> jfischoff di dyou install xquartz yet?
11:01:43 <jfischoff> yeah
11:01:49 <jfischoff> maybe it is not on my path?
11:01:51 <johnw> byorgey: $$ isn't rendering right for me at all
11:02:13 <carter> hrm.....
11:02:22 <carter> open a new terminal tab?
11:02:24 <carter> :)
11:02:29 <byorgey> johnw: what do you mean?
11:02:37 <carter> your paths might not have updated in taht console?
11:02:55 <johnw> byorgey: this is what I have, and what I get on the other end: https://gist.github.com/4061186
11:03:01 <jfischoff> one sec
11:03:09 <johnw> for now I hard-coded writerHTMLMathMethod = MathJax "http://cdn.mathjax.org/mathjax/latest/MathJax.js"
11:04:22 <carter> jfischoff: cmd+t for new terminal tab
11:04:23 <carter> and try again
11:04:47 <byorgey> johnw: and why is that wrong?
11:05:02 <byorgey> that's what I would expect for MathJax
11:05:06 <jfischoff> carter: I did that no dice. Trying some stuff of stackoverflow
11:05:21 <carter> did you brew install all the things?
11:05:27 <carter> or were some already partially installed ?
11:05:31 <byorgey> you have to include that on a page which has the proper <script> tags to invoke MathJax
11:05:35 <johnw> "<p><br /><span class="math">$" should be "\[", based on examples on the MathJax website
11:05:44 <byorgey> ohh, hmm, maybe you're right
11:06:02 <carter> jfischoff brew's big weakness is that its bad at ensuring everything is at a consistent version
11:06:03 <johnw> see the source for the page http://www.mathjax.org/demos/tex-samples/
11:06:18 <jfischoff> right
11:06:23 <carter> so for complicated things like gtk & cairo, you want to trash the full installed and install from the ground up
11:06:42 <carter> hence the "delete all the packages gtk depends on recursively"
11:06:44 <carter> step
11:06:46 <carter> did you do that?
11:07:10 <jfischoff> not really, but this machine is almost brand new. What is the list?
11:07:13 <byorgey> johnw: and it definitely doesn't work?
11:07:16 * hackagebot formal 0.1.0 - A statically typed, functional programming language  http://hackage.haskell.org/package/formal-0.1.0 (AndrewStein)
11:07:20 <byorgey> johnw: maybe it's a bug in pandoc
11:07:22 <johnw> heh, not at all
11:07:32 <johnw> let me try this with raw pandoc
11:07:54 <carter> jfischofff : did you have anything installed via brew already?
11:08:19 <carter> and whats your current PATH defn?>
11:08:25 <jfischoff> maybe one thing
11:08:56 <johnw> byorgey: pandoc --mathjax does it correctly
11:09:00 <jfischoff> carter: I'm pm-ing you
11:09:08 <carter> jfischoffI know :)
11:09:10 <byorgey> oh, hmm, strange
11:09:16 <johnw> so I need to teach BlogLiterately how to transform the HTML if MathJax is being used
11:09:38 <byorgey> johnw: maybe try source-diving in the pandoc executable to see what happens when you pass --mathjax
11:11:13 <byorgey> johnw: when you say pandoc --mathjax works correctly, you mean it outputs \[ etc.?
11:11:18 <johnw> yes
11:11:23 <johnw> <p>\[, to be precise
11:11:35 <johnw> as the substitution for $$
11:11:41 <manju> bos : ?
11:12:03 <johnw> the only thing that --mathjax does is to set writerHTMLMathMethod to MathJax URL
11:12:26 <bos> manju: i am earning my dayjob pay right now, will look later if time permits
11:12:27 <byorgey> I know, I was just looking
11:12:36 <linduxed> Botje: Jeanne-Kamikaze i did it this way instead https://gist.github.com/4061246
11:12:37 <manju> bos: haha ok
11:12:39 <byorgey> but clearly it's doing *something* different!
11:12:41 <felix2_> I think I had problems too when I tried to use MathJax with Pandoc
11:12:45 <johnw> so who changes $$ to <span class="math">?
11:12:56 <linduxed> Botje: Jeanne-Kamikaze is there a prettier or more concise way to do it?
11:13:11 <felix2_> I wasn't able to write block math, iirc
11:13:27 <aninhumer> Heh, reading this lens documentation, I feel like I'm being subliminally coerced into violence...
11:13:30 <aninhumer> s t a b
11:13:33 <aninhumer> s t a b
11:14:28 <monochrom> yes, that's the intention. we had a long discussion resulting in that
11:14:55 <byorgey> johnw: the other thing to keep in mind is that the version of pandoc on github (if that's what you're looking at) has diverged considerably from the latest released version
11:15:02 <byorgey> johnw: since he's working towards a 1.10 release
11:15:11 <johnw> oh
11:15:18 <byorgey> so we might not be looking at the right source code
11:15:23 <johnw> yeah, i'm using BlogLiterately with hackage pandoc
11:15:38 <johnw> but my test uses the same version
11:15:53 <byorgey> right, but which code are you reading?
11:16:54 <johnw> github ;(
11:16:55 <byorgey> never mind, I looked at the 1.9 source and it looks the same re: math writing
11:17:05 <byorgey> you can switch to the 1.9.x branch on github
11:18:21 <johnw> in pandoc, HTML.hs:658 seems to be creating the span
11:18:27 <johnw> but why does it not create it in my test output?
11:20:01 <johnw> that must be a new change
11:21:01 <johnw> wait, that doesn't make sense
11:21:23 <johnw> i do see it when using pandoc via BlogLiterately, but I don't see it when using pandoc directly, for the same version of pandoc
11:21:27 <Botje> linduxed: yep, looks nice that way
11:21:39 <hpaste> Rob pasted “first class record fields” at http://hpaste.org/77616
11:22:19 <robstewartuk> Whilst I can understand why this complains, I'd like to know if lenses will help me in http://hpaste.org/77616
11:22:37 <robstewartuk> It should be clear what I am trying to achieve.
11:23:43 <nand`> lenses will help with that
11:23:55 <byorgey> johnw: yes, that's what I don't understand.  I can't figure out what the difference is.
11:24:03 <nand`> :t \rec fieldName val -> rec # fieldName .~ val
11:24:04 <lambdabot> Not in scope: `#'
11:24:07 <nand`> uh
11:24:09 <nand`> :t \rec fieldName val -> rec % fieldName .~ val
11:24:11 <lambdabot> a -> Setting a b a1 b1 -> b1 -> b
11:24:19 <johnw> byorgey: i'm still looking too
11:24:37 <robstewartuk> cool. Any clues how exactly, w.r.t. my hpaste ?
11:24:58 <nand`> with lenses? change ‘foo’, ‘bar’ to _foo and _bar and add makeLenses ''Rec
11:25:14 <nand`> of course you could do what lenses are doing under the hood manually and just pass along a setter
11:25:16 <nand`> like
11:25:27 <nand`> updateRecord :: Rec -> (a -> Rec) -> a -> Rec
11:25:40 <nand`> rather
11:25:42 * robstewartuk tries
11:25:45 <nand`> (Rec -> a -> Rec) for the second argument
11:26:05 <nand`> of course that function begins to get a bit superfluous in the case, and using it is going to be uglier than using the record syntax directly
11:26:25 <robstewartuk> I'm trying the former suggestion...
11:29:12 <clahey> edwardk: I'm sorry I missed the Boston Haskell meetup.
11:29:19 <clahey> edwardk: Are you planning another any time soon?
11:31:58 <linduxed> so i've got a line saying "data Molecule = DNA | Protein deciving (Show)". is there some binary operator that checks that both arguments are of the same type (like DNA === DNA)?
11:32:17 <johnw> deriving (Show, Eq)?
11:32:28 <linduxed> johnw: aaah yes
11:33:41 <ski> > onLetters reverse "Eva, can i stab bats in a cave?"
11:33:43 <lambdabot>   "Eva, can i stab bats in a cave?"
11:34:02 <atriq> edwardk, I'd like to complain about the conflict of (:>) between Control.Lens.Zipper and Data.Stream.Infinite
11:34:23 <Pantoufle> :t onLetters
11:34:25 <lambdabot> ([Char] -> [Char]) -> String -> String
11:34:35 <Pantoufle> Oh nice
11:34:49 <nicoo> Isn't String already [Char] ?
11:34:54 <nicoo> @src String
11:34:54 <lambdabot> type String = [Char]
11:34:55 <ski> yes
11:34:58 <neutrino> yes
11:35:00 <nicoo> ><'
11:35:12 <ski> > onLetters reverse "Isn't String already [Char] ?"
11:35:14 <lambdabot>   "Rah'c Ydaerl agnirts [Tnsi] ?"
11:35:51 <neutrino> ski, it kind of feels like this doesn't work
11:35:58 <ski> ?
11:35:58 <neutrino> :)
11:36:00 <nicoo> Aaaaah
11:36:05 <bxxx> it uses both [Char] and String to keep you on your toes?
11:36:07 <jacobian> Wow, that looks like Cthulu translation
11:36:08 <atriq> edwardk, I kind of want to use both at once
11:36:23 <neutrino> why would reverse do something like this?
11:36:28 <nicoo> jacobian: So true; it should be « romanisation » though
11:36:38 <johnw> :t onLetters
11:36:40 <lambdabot> ([Char] -> [Char]) -> String -> String
11:36:45 <johnw> :i onLetters
11:37:05 <mentus> hello everybody
11:37:27 <mentus> how do i change on StateT to another StateT
11:38:00 <ski> @let onWords :: ([String] -> [String]) -> (String -> String); onWords f = unwords . f . words; perWord :: (String -> String) -> (String -> String); perWord f = onWords (map f)  -- per conal
11:38:02 <lambdabot>  Defined.
11:38:04 <mentus> e.g. StateT [String] IO Bool to StateT [String] Identity Bool
11:38:08 <mentus> and vice versa ?
11:38:11 <ski> > perWord (onLetters reverse) "Isn't String already [Char] ?"
11:38:13 <lambdabot>   "Tns'i Gnirts ydaerla [Rahc] ?"
11:38:43 <johnw> where are onWords and onLetter from?
11:38:47 <atriq> mentus, it can't be done!
11:38:55 <neutrino> ohh
11:38:55 <ski> `onWords', see above
11:38:59 <neutrino> now i see what's going on
11:39:08 <mentus> i was afraid of this answer :-)
11:39:19 <mentus> ok, so what's the haskell way to do it ?
11:39:30 <neutrino> i thought onLetters reverse was doing something like rot13
11:39:41 <seliopou> mentus: you should try to use the StateT monad without calling lift or similar functions
11:39:56 <neutrino> but it makes much more sense now that i see what it really did
11:39:57 <seliopou> that way your code will be agnostic to the underlying monad
11:40:02 <seliopou> and then you can set it to whatever you like
11:40:12 <seliopou> but you can't change one from the other in all cases
11:40:20 <seliopou> and even when you can, it's a bit of a manual process
11:40:25 <fmap> :t mapStateT
11:40:27 <lambdabot> (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
11:40:28 <ski> johnw : see <http://www.haskell.org/haskellwiki/TV#IO> by Conal Elliott(sp)
11:40:56 <seliopou> well, mapStateT makes it a little easier
11:40:57 <ski> johnw : .. for `onLetter', i just invented it
11:41:05 <seliopou> :i mapStateT
11:41:06 <johnw> cool!
11:41:12 <ski> @index mapStateT
11:41:13 <lambdabot> Control.Monad.State, Control.Monad.RWS
11:41:15 <seliopou> Boom
11:41:18 <neutrino> speaking of, conal hasn't been here in a while has he?
11:41:27 <ski> preflex: xseen conal
11:42:23 <seliopou> it'd be great if @index listed the package as well as the module
11:42:24 <ski> Last seen  : Nov 05 15:28:45 2012 (1 week, 0 days, 04:11:03 ago)
11:42:28 <neutrino> by the way.. in the 90s, what conal calls tangible values now, was called "naked values"
11:42:29 <mentus> mapStateT seems promising
11:42:32 <neutrino> :^)
11:42:42 <mentus> at least what's its signature says
11:42:42 <neutrino> not only naked but now tangible..
11:42:59 <ski> mentus : `StateT [String] IO Bool' to `StateT [String] Identity Bool' seems not possible
11:43:23 <seliopou> seems unsafe
11:43:25 <fmap> mentus: except you can't have meaningful `IO (a, s) -> Identity (b, s)'
11:43:25 <pordan30> i'm having trouble installing gtk2hs-buildtools via cabal on mint/debian, which exits with the error: "unacceptable result type in foreign declaration: cint." google reveals this problem occurs with gtk2hs and leksah on arch, but i'm having trouble finding good solutions.
11:43:29 <neutrino> are conal's TVs bound by an FRP framework?
11:43:37 <ski> dunno
11:43:44 <seliopou> fmap: it can be meaningful, you just have to be careful about it
11:44:23 <nand`> last time I use TV there wasn't any of the usual FRP libraries involved; though it could be that TV itself implements a form of FRP - I still have no idea what FRP is or how to recognize it, and likely never will
11:44:52 <neutrino> ok well did it have a simple facility where you could say "this slider is always 2x that slider"?
11:45:08 <neutrino> in declarative form
11:45:16 <neutrino> rather than having to do polling or callbacks
11:48:16 <Philippa> so I just ran apt-cache search haskell on the raspi someone lent me
11:48:29 <Philippa> somehow, I don't think I want to bother with agda-bin. Not in 256MB of RAM.
11:49:00 <Philippa> neutrino: who called them naked values, and were they exactly the same thing?
11:49:35 <Philippa> (often the differences between things that are almost-similar are worth understanding, if only to confirm it's entirely incidental complexity - sometimes it's not)
11:49:37 <nand`> edwardk: I'm not sure I understand Projection; what's the canonical example?
11:49:56 <neutrino> "values which had a direct gui representation"
11:50:11 <neutrino> i think it was some java mvc gui thing for a while
11:50:30 <nand`> “A Traversal that can be turned around to get a Getter” <- like say you had a traversal [a] a in the form of traverse; but also a getter a [a] in the form of pure?
11:50:59 <neutrino> where you'd have computed values which had a gui control that ran some function which then set the new value in some oblique way, or you had naked values which were just a widget that set the value directly
11:51:23 <DanBurton> hey guys, I'm trying to install BlogLiterately on a Windows Vista machine, but having trouble with pcre
11:52:33 <DanBurton> it's telling me that the pcre library is missing, even though I downloaded it and am telling Cabal exactly where it is with --extra-lib-dirs
11:53:17 <johnw> byorgey: so, when I use BlogLiterately, it's actually trying to render the math in regular HTML
11:53:54 <neutrino> "BlogLiterately" sounds like something I'd want to check out
11:54:08 <johnw> MathJax rendering should use \(\pi = \tau/2\), but BlogLiterately is using <span class="math"><em>π</em> = <em>τ</em> / 2</span>
11:54:13 <johnw> neutrino: it's quite nice
11:54:21 <Philippa> neutrino: ah. That's a very different concept in an OO environment
11:54:23 <johnw> i write all my blog posts in literate Haskell now
11:55:06 <Philippa> johnw: heh, I'm making do with markdown with lots of embedded haskell and LaTeX myself
11:55:21 <johnw> Philippa: with BlogLiterately?
11:55:28 <DanBurton> neutrino: it is. It's great. I keep the .lhs sources for my blog on github, and then just use BlogLiterately to throw a pretty version on wordpress.com
11:55:31 <neutrino> i think the general idea is the same though
11:55:32 <johnw> because i'm using markdown+haskell+ghci sessions+LaTeX too
11:56:22 <neutrino> DanBurton: here's an idea: make a build script which pushes to another github repo, and then you can use github as the hoster.
11:57:02 <johnw> byorgey: maybe it's the call to renderHtml isn't being setup properly?
11:57:10 <DanBurton> probably a good idea; I'm too lazy to figure out the details of it though :P plus BlogLiterately was sort of written with wordpress in mind
11:57:34 <johnw> yeah, I use it with WordPress
11:57:48 <Athas> What library would you recommend for parsing HTML?
11:57:57 <johnw> tagsoup on HXT
11:58:00 <johnw> s/on/or
11:59:41 <DanBurton> for those interested, you just have to constrain the pcre library to a version prior to 0.94.4.1. Ugh, I better email the maintainer about this.
11:59:54 <johnw> byorgey: ahh, I'm not getting the option passed down; it's using the default PlainMath
11:59:59 <johnw> "The default is to render TeX math as far as possible using unicode characters..."
12:00:23 <johnw> DanBurton: or use git://github.com/bgamari/regex-pcre-builtin.git
12:00:27 <johnw> that's what I'm doing, via cabal-meta
12:01:08 <DanBurton> johnw: why that one?
12:01:16 <DanBurton> aside from it being not broken
12:01:47 <Philonous> Is there a flag for ghci to make it load modules from hidden packages?
12:02:13 <rpert> what about a web browser library? with support for cookies, entering data in forms, etc
12:02:26 <Eduard_Munteanu> Philonous: perhaps you have to use -package to "unhide" the modules
12:03:13 <Philonous> Eduard_Munteanu:  Well, :set -package works of course, but it's tedious. Is there a way to automate this?
12:03:24 <johnw> DanBurton: just because it worked
12:04:54 <Eduard_Munteanu> Philonous: you can supply it on the cmdline
12:06:24 <linduxed> so i've got two strings that i need take head of on both, check if they're the same, if they are increment a number by one, and then do the same for the next two, and so on
12:06:36 <Philonous> Eduard_Munteanu:  It's a long-running ghci session so, that doesn't help
12:06:48 <linduxed> i know how to do this with explicit recursion, but i was wondering if this sounds like something an existing function does
12:06:53 <linduxed> it reminds me of zip
12:06:59 <linduxed> but i don't know how i'd do that
12:07:10 <Philonous> linduxed:  check out zipWith
12:07:16 <Philonous> @type zipWith
12:07:17 * hackagebot FixedPoint-simple 0.4.2 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.4.2 (ThomasDuBuisson)
12:07:17 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
12:09:36 <Philippa> johnw: not seen BlogLiterately, I hacked something up out of pandoc
12:10:01 <linduxed> Philonous: so i could use zipWith to generate a list with 1's and 0's and then add it all together?
12:10:02 <Philonous> linduxed:  Also, "incrementing a number by one" is an inherently imperative concept. Try to reformulate your problem so that you say what you want rather than how to get it.
12:10:14 <linduxed> ok
12:10:14 <johnw> Philippa: heh, that describes BlogLiterately :)
12:10:25 <Philonous> linduxed:  That's one way to do it
12:10:27 <johnw> http://byorgey.wordpress.com/blogliterately/
12:10:37 <linduxed> basically, i've got two strings and i need to calculate the percentual difference in characters
12:11:05 <linduxed> so it needs to step through each pair of characters and see if they're the same
12:11:45 <linduxed> by the end it will divide the amount of different characters with the length of one of the strings (they need to be the same length)
12:11:49 <linduxed> (that's checked before)
12:12:07 <mcstar> > length $ takeWhile (uncurry (==)) (zip "abcdef" "abchjg")
12:12:09 <lambdabot>   3
12:12:19 * hackagebot yesod 1.1.3.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.3.1 (MichaelSnoyman)
12:12:56 <pordan30> if you actuall want a stateful operation, you can use zipWithM / zipWithM_ or a variant that throws an exception on lists of unequal length
12:13:04 <Philonous> mcstar:  That's will only find the longest matching prefix, not the number of identical characters
12:13:17 <linduxed> mcstar: that's good, but doesn't takeWhile stop at the first occurrence of it not working?
12:13:26 <Philonous> linduxed:  Yes it does
12:13:34 <mcstar> i see, didnt catch that
12:13:39 <linduxed> hmmm
12:13:45 <linduxed> but it's a very good start
12:14:02 <linduxed> filter?
12:14:07 <Philonous> linduxed:  You cuould do it with zipWith, filter and length
12:14:09 <linduxed> yes! filter might do it
12:14:22 <mcstar> ok, so you need only cound the number of positions when the letters are equal?
12:14:24 <nand`> > length . filter id $ zipWith (==) "abcdef" "abchjf"
12:14:25 <mcstar> count*
12:14:26 <lambdabot>   4
12:14:29 <johnw> > commonPrefixes (pack "abcdef") (pack "abchjf")
12:14:31 <lambdabot>   Not in scope: `commonPrefixes'
12:14:32 <lambdabot>  Perhaps you meant `commonPrefix' (line 6)No...
12:14:34 <nand`> confound my 24 second latency
12:14:41 <johnw> :t commonPrefix
12:14:43 <lambdabot> Eq a => [a] -> [a] -> [a]
12:14:47 <simpson> :t stripPrefix
12:14:49 <lambdabot> Eq a => [a] -> [a] -> Maybe [a]
12:14:52 <johnw> > commonPrefix "abcdef" "abchjf"
12:14:55 <lambdabot>   "abc"
12:14:59 <simpson> ^^ from Data.List. Might be what you want.
12:15:08 <simpson> > stripPrefix "abc" "abcdef"
12:15:10 <lambdabot>   Just "def"
12:15:15 <simpson> > stripPrefix "abc" "defabc"
12:15:17 <lambdabot>   Nothing
12:15:42 <linduxed> yes, i'll probably use something like nand`s solution
12:15:49 <linduxed> thank you guys
12:15:50 <mcstar> > length $ filter (uncurry (==)) (zip "abcdef" "abchjg")
12:15:52 <lambdabot>   3
12:15:58 <mcstar> linduxed: do you want this?
12:16:07 <mcstar> > length $ filter (uncurry (==)) (zip "abcdef" "abchef")
12:16:08 <lambdabot>   5
12:16:35 <linduxed> mcstar: yes, that's it
12:16:45 <johnw> linduxed: your input lists are already in correct order?
12:17:24 <linduxed> johnw: they're protein/DNA sequences, which will be of the same length and largely identical
12:17:38 <pordan30> > let tick = get >>= put . (+ 1) in runState (zipWithM_ (\a b -> if a == b then tick else return ()) [1,2,3,4] [1,3,2,4])
12:17:40 <lambdabot>   *Exception: show: No overloading for function
12:17:51 <pordan30> > let tick = get >>= put . (+ 1) in runState (zipWithM_ (\a b -> if a == b then tick else return ()) [1,2,3,4] [1,3,2,4]) 0
12:17:52 <nand`> > (zipWith subtract `on` map fromEnum) "abcdef" "abchjf"
12:17:53 <lambdabot>   ((),2)
12:17:54 <lambdabot>   [0,0,0,4,5,0]
12:18:03 <johnw> so do you just want a "diff"?  you're looking for a percentile position-wise equality?
12:18:30 <mcstar> 'count the number of concidences' thats what he wants
12:18:33 <Blkt> good evening everyone
12:18:37 <mcstar> coincidences
12:18:39 <johnw> ah
12:18:40 <mcstar> if theres such a word
12:18:45 <mcstar> im not sure :)
12:18:46 <johnw> yes
12:19:20 <johnw> byorgey: so, apparently pandoc is not seeing my writerHTMLMathMethod, so something is not happening as I'd expect
12:19:26 <mcstar> i like when i see Blkt's welcome messages everywhere at the same time
12:19:50 <mcstar> (no, i dont like it, why automate a welcome message??)
12:20:49 <johnw> so really it's his computer greeting you, not him
12:21:12 <mcstar> heh
12:21:24 <nand`> I don't see much of a difference
12:21:39 <johnw> if you don't, we have other problems
12:21:49 <linduxed> if i do the same thing on both arguments, like "zip (molseq a) (molseq b)" is there some prettier way to apply that molseq function on a and b?
12:21:59 <nand`> his IRC client is medium used to transfer the intent of the message, not unlike when I type out a message on my keyboard
12:22:15 <nand`> except he did a little bit less typing
12:22:37 <nand`> linduxed: on
12:22:38 <nand`> zip `on` molseq
12:22:44 <linduxed> aaah yes
12:22:47 <linduxed> forgot about it
12:22:49 <linduxed> thx
12:23:38 <mcstar> Data.Function, if you are wondering :)
12:23:45 <linduxed> oh yes i know
12:23:49 <linduxed> just a lapse there
12:24:46 <neutrino> is there a way to define implicit functions in haskell?
12:25:23 <ski> define "implicit functions" ?
12:25:24 <rwbarton> what do you mean by "implicit function"?
12:25:29 <nand`> what's an implicit function?
12:25:39 <johnw> apparently you need to first define them on #haskell
12:25:40 <otters> it should be obvious
12:26:03 <neutrino> in mathematics, an implicit function is defined by taking a functional equation, finding its free variables, and making that a function
12:26:18 <neutrino> for example, let's say F(x, y) = x^2 + y
12:26:20 <ski> do not want
12:26:33 <Heffalump> so to execute it you actually need to solve the equation?
12:26:40 <neutrino> now you define f: F(x, y) == 0
12:26:48 <sipa> haskell is not an equation solver
12:26:48 <neutrino> yes
12:27:07 <mcstar> they are not free variables, they are bound, arent they?
12:27:18 <mcstar> f(x,y)=x+y+z, z is free
12:27:22 <mcstar> x,y is bound
12:27:23 <pordan30> > foldr (\a r (x : xs) -> if a == x then rec xs + 1 else rec xs) (const 0) [1,2,3,4] [1,3,2,4]
12:27:24 <lambdabot>   <hint>:1:40: parse error on input `rec'
12:27:34 <nand`> (+) is free too :P
12:27:37 <pordan30> > foldr (\a rec (x : xs) -> if a == x then rec xs + 1 else rec xs) (const 0) [1,2,3,4] [1,3,2,4]
12:27:38 <lambdabot>   <hint>:1:11: parse error on input `rec'
12:27:41 <mcstar> ah yeah nand`
12:27:51 <pdxleif> @pl \x y -> x^2 + y
12:27:51 <lambdabot> (+) . (^ 2)
12:27:53 <neutrino> anyways, continuing
12:28:14 <mcstar> neutrino: that is an implicit equation for either x or y
12:28:15 <neutrino> if F(x, y) == 0 then x^2 + y == 0, therefore y = -x^2
12:28:17 <lolcathost> neutrino: I guess the closest you could get would be implementing a higher-order function that takes F, x, and returns some approximate value for y obtained using a numerical method (perhaps some generalization of Newton's method?).
12:28:20 <nand`> :t (^2) >>= (+)
12:28:21 <neutrino> that is f(x)
12:28:22 <lambdabot> Num b => b -> b
12:28:35 <pordan30> weird: that evaluates in my prompt, but not via lambdabot :/
12:28:35 <geekosaur> pordan30, rec is a keyword these days, I think.  (do rec ...)
12:28:41 <pordan30> ohh
12:28:51 <geekosaur> LB has the extension enabled, your ghci does not
12:28:51 <neutrino> lolcathost: hmm.
12:29:13 <mcstar> point is, in haskell, functions need not be numeric
12:29:14 <nand`> pordan30: LANGUAGE RecursiveDo
12:29:17 <neutrino> but can't you perform the steps required for the implicit function theorem in lambda calculus?
12:29:17 <lolcathost> neutrino: But "what value of y makes 'F x y == 0' true?" is not answerable in the general case.
12:29:31 <pordan30> the eta expanding foldr trick is cool; anyways, that's another extraneous way to write the function being discussed above
12:29:39 <Eduard_Munteanu> Sounds like logic programing.
12:29:42 <lolcathost> neutrino: The implicit function theorem is a result from analysis.
12:30:08 <neutrino> i'm not sure that's important
12:30:25 <pdxleif> Curry is a superset-ish of Haskell, and does logic programming.
12:30:53 <sipa> as far as i know the implicit function theorem does not provide you with a way to evaluate said implkcitly defined function?
12:31:07 <lolcathost> neutrino: IIRC, the implicit function theorem relies on F being differentiable, and dF/dy not being 0. (Actually, I mean the weird d that denotes a partial derivative.)
12:31:19 <sipa> it just proves that the result is something that mathematically satisfies the requirements for a function
12:31:56 <Eduard_Munteanu> ∂
12:32:09 <lolcathost> Eduard_Munteanu: That.
12:32:17 <lolcathost> Unfortunately, I cannot easily type that using my keyboard.
12:32:20 <pordan30> the implicit function theorem has a constructive proof, so it should provide a way to evalute the function
12:32:25 <neutrino> sipa: that's incorrect, the proof for the IFT is constructive
12:32:30 <neutrino> right
12:32:31 * Eduard_Munteanu types \partial
12:32:32 <pordan30> i mean, a function that can be evaluated
12:32:40 <lolcathost> Eduard_Munteanu: Are you using ERC?
12:32:59 <Eduard_Munteanu> lolcathost: no, irssi, but I'm using SCIM with the Latex table to type symbols.
12:33:06 <rwbarton> for the implicit function theorem you need a starting point also
12:33:25 <lolcathost> rwbarton: Actually, an interval in which [#haskell] rwbarton: Actually, an interval in which
12:33:26 <neutrino> rwbarton: why do you?
12:33:28 <niteria> IIRC you just need to solve a system of linear equations to get a value of implicit function at a given point
12:33:28 <lolcathost> dang
12:33:29 <Asim> haskell ? i joined just now
12:33:35 <mcstar> i still dont see what relevance does this have to haskell's notion of functions
12:33:39 <lolcathost> rwbarton: ∂F/∂y != 0
12:34:12 <neutrino> rwbarton: i don't remember that
12:34:19 <Eduard_Munteanu> (SCIM should work with any X app)
12:34:31 <bgamari> tibbe, Have you thought at all about what will happen to the Control.Concurrent.QSem usage in cabal-install?
12:35:06 <rwbarton> the implicit function theorem says if you have one solution then you can construct a function of nearby solutions under the conditions lolcathost mentioned
12:35:31 <neutrino> right, by following the jacobian around
12:35:33 <rwbarton> in general there might be several solutions or no solutions, so you need to start with a solution to construct nearby ones
12:35:38 <neutrino> but that's not exactly what it says
12:35:45 <rwbarton> anyways this has nothing really to do with Haskell functions in general
12:35:50 <neutrino> in general you don't really need a starting point
12:36:01 <rwbarton> it might make sense to implement something like this in CReal
12:36:02 <linduxed> why does my linter say that "differentLetters = length $ filter (uncurry (==)) $ zip `on` molSequence a b" has Precedence parsing error on "length"?
12:36:04 <mcstar> is the IFT, that you can construct a function implicitely, i.e. define it as the level set equation of a more general function?
12:36:08 <mcstar> isnt
12:36:18 <linduxed> or well, it places the warning/error at the start of length at least
12:37:35 <niteria> IFT sort of reminds me of Tylor expansion at a given point
12:39:10 <linduxed> aaah, "cannot mix `$' [infixr 0] and `on' [infixl 0] in the same infix expression"
12:39:44 <neutrino> anyways, my question comes from the fact that you could possibly do this with a lot of functions in programming languages
12:40:10 <neutrino> s/fact/hypothesis
12:41:54 <neutrino> the general idea is that you have a boolean function of two inputs, and you end up expressing one input in terms of another for where the function is True
12:42:19 <niteria> isn't that logic programming?
12:42:21 <mcstar> you maybe want a constraint solver
12:42:30 <neutrino> i don't know?
12:42:44 <covi> What does 'Nat' mean?
12:42:49 <sipa> that's CSP really
12:42:49 <mcstar> but that has nothing to do with IFT
12:42:59 <ski> logic programming is nice for "reversing" some operations
12:43:27 <ski> covi : perhaps `data Nat = Zero | Succ Nat' ?
12:43:45 <neutrino> for example, let's say we take elem. then let's define f: elem x list == True. This way we have just defined "lookup".
12:44:20 <niteria> is there some kind of clojure's core.logic / kanren's port to Haskell?
12:44:27 <pordan30> usually the logic programming languages define a notion of success and failure, however, and at most expose the former to the user; not really a transformation from a boolean valued binary function.
12:44:32 <ski> neutrino : like `lookup(Key,Val,AssocList) :- member((Key,Val),AssocList).' ?
12:44:49 <pordan30> neutrino: that's basically valid curry
12:44:52 <simpson> covi: "Nat" is usually the name of the type of natural numbers defined recursively as zero and an infinity of successors to zero.
12:45:04 <neutrino> ski: i'm not sure how to read that
12:45:04 <mcstar> i think he wants to define a function from the properties you'd write for quickcheck
12:45:10 <ski> neutrino : it's Prolog
12:45:16 <neutrino> pordan30: that's interesting
12:45:21 <ski> `:-' means "if"
12:45:31 <neutrino> ski: ok, i've been interested in prolog for some time now
12:45:38 <neutrino> hmm
12:45:49 <neutrino> yes, like that ski
12:45:54 <covi> ski: i see
12:45:56 <covi> simpson: thx
12:46:00 <pordan30> elem a (xs ++ b ++ ys) | a == b = success or something, is how you might write it; it's been a while, so correct me if I'm wrong
12:46:39 <ski> neutrino : you could use that definition to solve the query `lookup(2,Val,[(0,2),(1,3),(2,5),(3,7)])' and get `Val = 5' as solution
12:47:18 * hackagebot dawg 0.1.0 - DAWG  http://hackage.haskell.org/package/dawg-0.1.0 (JakubWaszczuk)
12:47:25 <atriq> Yo, dawg
12:47:36 <wmoss> bos: I've got a question about pool-conduit, do you have a second?
12:47:56 <bos> wmoss: not right now, sorry
12:48:33 <ski> (`member' is the name of the corresponding operation in Prolog to `elem'. it is defined as `member(A,[A|_]).  member(A,[_|As]) :- member(A,As).')
12:48:41 <wmoss> bos: would you prefer email?
12:48:59 <bos> wmoss: please
12:49:13 <wmoss> bos: will do, thanks!
12:50:27 <pordan30> for simple operations like that, the list monad or a backtracking monad with logic variables would do a pretty good job
12:51:30 * ski nods
12:53:08 <neutrino> ski: i understand prolog does this by searching the space in discrete manner, right?
12:53:37 <simpson> neutrino: Not exactly.
12:53:51 <neutrino> what does it do then? hi simpson
12:53:54 * ski would have answered "yes"
12:54:14 <simpson> neutrino: Prolog goes top-to-bottom, left-to-right, and tries each clause to see if it matches.
12:54:35 <simpson> neutrino: It might help to think of [A|As] as sugar for cons(A, As).
12:55:39 <neutrino> that is what i meant by "discrete manner"
12:55:45 <neutrino> :)
12:56:23 <pordan30> in order to get it to /really/ search the problem space, you spend all your time translating your programs in to breadth-first searches; or maybe i'm doing it wrong
12:56:27 <simpson> Sure. I was thinking of "the space" and what that means.
12:56:29 <neutrino> it would be fun to see a language that can solve implicitly defined functions of this kind in a smart way
12:57:10 <ski> aye
12:57:22 <simpson> neutrino: Hm. Well, Prolog *is* Turing-complete, so it's neither stronger nor wimpier than anything else.
12:57:43 <neutrino> you mad?
12:57:45 <neutrino> :)
12:58:38 <tibbe> bgamari: not yet, I don't even know why it was deprecated
12:58:49 <simpson> Well, yes, I *am* MAD.
12:58:55 <simpson> But I go by this nick nowadays.
12:59:02 <neutrino> oh ok
12:59:22 * ski . o O ( "What, me worry?" )
12:59:24 <bgamari> tibbe, Apparently it wasn't exception safe
12:59:32 <tibbe> bgamari: bummer
12:59:33 <bgamari> tibbe, I couldn't tell you exactly how though
12:59:34 <mcstar> (defparameter *am* nil)
12:59:37 <tibbe> bgamari: and it couldn't be fixed?
12:59:48 <tibbe> bgamari: I guess we'll have to look into it for ghc 7.8.1
13:00:34 <bgamari> tibbe, http://haskell.1045720.n5.nabble.com/Proposal-Remove-Control-Concurrent-QSem-QSemN-SampleVar-mergeIO-nmergeIO-from-base-td5711428.html
13:01:31 <Cale> It kind of bothers me that the proposal is to remove them rather than replace them with the repaired versions.
13:01:48 <bgamari> tibbe, I'm not sure the reason for that
13:02:13 <ski> (yuck, <nabble.com>)
13:02:37 <bgamari> Cale rather
13:02:57 <neutrino> ski: agreed
13:03:28 <bgamari> ski, Google chose it, not me
13:04:18 <bgamari> tibbe, Is a dependency on SafeSemaphore acceptable?
13:04:29 <neutrino> man this implicit function thing is really stuck in my head now
13:04:31 <pordan30> if i have transformers 0.3.0.0 installed, but a package depends on e.g., transformers < 0.3.0.0, is there a way to keep the current installation of transformers and run the package using an older version?
13:04:47 <tibbe> bgamari: no
13:05:52 <byorgey> pordan30: there's no problem in principle with having multiple versions of a package installed at the same time
13:06:02 <bgamari> tibbe, I guess an MVar and atomicIORefModify could work?
13:06:27 <byorgey> it's just that in practice you have to be careful because this can lead to trying to use packages together which were compiled with different versions of a third package which doesn't work.
13:07:00 <ski> bgamari : "Proposal: Remove Control.Concurrent{QSem,QSemN,,SampleVar,mergeIO,nmergeIO} from base" by Ian Lynagh in 2012-06-07 at <http://www.haskell.org/pipermail/libraries/2012-June/017881.html>
13:07:04 <ski> there you go
13:07:08 <linduxed> could someone tell me why i get "MolSeq.hs|30 col 51 error| Couldn't match expected type `Float'" on this code?  https://gist.github.com/4061892
13:07:12 <bgamari> ski, Thanks
13:07:43 <bgamari> which is atomicModifyIORef up to permutation
13:08:27 <pordan30> byorgey: okay, so if i installed e.g., diagrams, using an older version of transformers, would that interfere with import declarations when compiling haskell code? assuming that i'm not using transformers generally in my other code
13:08:36 <linduxed> ghci says "Couldn't match expected type `Float' with actual type `a0 -> a0 -> c0'"
13:09:01 <byorgey> pordan30: no
13:09:23 <byorgey> pordan30: (was that just an example or are you really trying to install diagrams?)
13:09:52 <pordan30> ghc is telling you that it has inferred a type different than the type of some value
13:10:33 <pordan30> byorgey: yes, i am trying to install diagrams. it relies on transformers 0.2.2, while i apparently am using 0.3.
13:10:38 <bgamari> tibbe, stm is also out, I take it?
13:11:42 <byorgey> pordan30: wait, really?  can you paste the output of cabal install diagrams (or whatever command you are using) with the -v3 option?
13:11:56 <byorgey> pordan30: as far as I know diagrams ought to work fine with transformers 0.3
13:12:39 <ski>   difference       = ((/) `on` fromIntegral) differentLetters sequenceLength  -- linduxed
13:13:13 <Asim> can we build web app using haskell ?
13:13:40 <byorgey> linduxed: you need parentheses around  ((/) `on` fromIntegral)
13:13:47 <byorgey> oh, ski beat me to it
13:13:58 <linduxed> byorgey: oooh, so that's why
13:14:18 <linduxed> byorgey: because when i tried to just dump the infixing and write "on (/) fromIntegral" then it worked
13:14:37 <byorgey> linduxed: yes, that's because function application always has higher precedence than infix operators
13:15:08 <byorgey> so  on (/) fromIntegral  parses the way you want, but the other parses as   (/) `on` (fromIntegral ... )
13:15:16 <pordan30> byorgey: here is an hpaste of the output (i assume you meant -v, since -v3 is a parse error) <http://hpaste.org/77619> it looks like i was reading the error wrong; transformers failed to install, but the error is that `catch' isn't in scope.
13:15:38 <ski> linduxed : is there a reason you use `String' for `molSequence', instead of using different types for DNA vs. protein ?
13:15:40 <byorgey> pordan30: uh, -v# is a parse error =)
13:15:59 <pordan30> oh, wow, not i feel like an idiot
13:16:02 <hpaste> hi pasted “mr” at http://hpaste.org/77620
13:16:09 <byorgey> pordan30: oh, you are using GHC 7.6
13:16:31 <byorgey> pordan30: the version of diagrams on hackage does not work with 7.6
13:16:45 <byorgey> pordan30: the version in github does, except that gtk2hs still does not
13:16:50 <hpaste> hi annotated “mr” with “mr (annotation)” at http://hpaste.org/77620#a77621
13:20:00 <pordan30> byorgey: thanks. the introduction to diagrams demanded i install gtk2hs-buildtools, which wasn't a problem. i'll try the version on github, and see if that works better. if not, i suppose the other option is to run diagrams using ghc < 7.6.
13:20:03 <luite>   there was a new gtk2hs release yesterday
13:20:09 <luite> doesn't that work with 7.6?
13:20:14 <byorgey> ah, so there was
13:20:17 <byorgey> I didn't realize
13:20:59 <byorgey> pordan30: I am still not sure why it is trying to install transformers-0.2
13:21:07 <byorgey> pordan30: can you actually paste the output with -v3?
13:22:08 <byorgey> oh, wait, never mind
13:22:59 <FireFly> ski: that's how it's specified in the exercise that the code is for. As to why the exercise does it like that, I don't know
13:23:18 <pordan30> byorget: nevermind? for posterity, then, this is the output: <http://hpaste.org/77622>
13:23:45 <byorgey> pordan30: notice it is trying to install diagrams-0.2.2.3, which is *super* old!
13:23:47 <tibbe> bgamari: I don't think STM is called for here
13:24:08 <byorgey> it's because the latest version of diagrams says it only works with base-4.5 or lower
13:24:20 <byorgey> so cabal goes back in time to try to find a version of diagrams which works with base-4.6
13:24:41 <byorgey> and diagrams-0.2.2.3 happens to be the last time I didn't specify an upper bound on the base package =(
13:24:57 <byorgey> the moral of the story is, either *always* specify upper bounds, or *never* do
13:25:01 <byorgey> but don't mix and match!
13:25:04 <byorgey> but it's too late
13:26:42 <Clint> gtk2hs-buildtools 0.12.4 does build with ghc 7.6
13:26:51 <byorgey> I guess now that a new gtk2hs is out I should try making a new minor point release in the 0.5 series which works with 7.6
13:27:06 <byorgey> well, gtk2hs-buildtools wasn't the problem, it's gtk2hs itself
13:27:16 <Clint> ah
13:27:19 <byorgey> which is pulled in as a dependency of diagrams-cairo
13:28:19 <johnw> byorgey: so, it seems like Pandoc is just ignoring my option setting
13:28:26 <pordan30> byorgey: thanks. if i understand you correctly, that only applies to the lastest cabal release, no? the cabal file on the github repo depends on base < 4.7. so that should be fine, right?
13:29:11 <byorgey> pordan30: correct.
13:30:13 <byorgey> if you want to use diagrams with GHC 7.6, you can build it from github: you'll have to get the diagrams-core, diagrams-lib, and diagrams-cairo repositories
13:30:26 <byorgey> assuming the new gtk2hs release works with 7.6
13:30:38 <byorgey> if it doesn't, you can try diagrams-svg in place of diagrams-cairo
13:30:50 <byorgey> which certainly works
13:33:17 <johnw> byorgey: trying to confirm that the setting gets set now
13:34:05 <pordan30> byorgey: thanks for your help. the diagrams package looks very interesting, so i'm hoping i can get it working :)
13:34:33 <byorgey> pordan30: cool, thanks, me too =)  and feel free to join #diagrams
13:34:46 <byorgey> johnw: oh, what was the problem?
13:35:48 <johnw> still haven't identified it yet
13:36:11 <johnw> but my setting of writerHTMLMathMethod is having no effect; Pandoc is still rendering with PlainMath
13:36:58 <byorgey> oh, that's strange
13:37:33 <johnw> once I can get past this, though, the change is going to be trivial; I'll e-mail you a patch once I've debugged this
13:39:07 <bgamari> tibbe, I suppose that's true
13:39:35 <byorgey> johnw: maybe this has something to do with it:
13:39:38 <byorgey> https://github.com/jgm/pandoc/blob/1.9.4.x/src/Text/Pandoc/Writers/HTML.hs#L107 ?
13:40:01 <johnw> yeah, I was reading that code earlier
13:40:05 <byorgey> ok
13:40:11 <johnw> got to go now, but i'll look for you here later if I find out something more
13:40:18 <byorgey> ok
13:40:41 <arbn> If I'm using Haskell Platform libraries, is there a single copyright notice, I can include? Or do I need to find the notices for all the libraries linked by my binary distribution, that are in the platform?
13:42:05 <simpson> How would one put a forkIO'd thread to sleep?
13:42:25 <simpson> I was thinking of having timers in an application by forkIO'ing and then sleeping for a given period of time.
13:42:58 <Abso> is there a quick way to take integers from a list while they are bigger than the previous one? ex: [1,2,3,4,1,2] = [1,2,3,4] ?
13:43:25 <arbn> simpson: threadDelay? Isn't that what that does?
13:43:33 <simpson> arbn: Maybe? Lemme check.
13:43:37 <identity> arbn: threadDelay is for the local thread it seems
13:43:42 <simpson> Abso: I bet takeWhile could help you out.
13:43:56 <arbn> identity: Oh. Right. Hm.
13:43:57 <simpson> Or... hm.
13:44:01 <rwbarton> zip + takeWhile + map fst
13:44:01 <Abso> yeah, but whats the condition?
13:44:14 <rwbarton> or so
13:44:19 <spherox> @pl f g g' a b = g (g' a) (g' b)
13:44:20 <lambdabot> f = join . ((flip . ((.) .)) .) . (.)
13:44:27 <rwbarton> might need slight adjustment at the edges
13:44:50 <spherox> =[ Anyone see a less stupid way to point-free that?
13:45:08 <identity> Abso: something with zip, tail, takeWhile I guess
13:45:25 <byorgey> spherox: g `on` g'
13:45:26 <rwbarton> isn't that "on"
13:45:33 <spherox> cool beans
13:45:35 <ion> > ((zipWith (\a b -> (a < b, b)) <*> tail)) [1,2,3,4,1,2,3,4]
13:45:35 <byorgey> yes, f = on
13:45:36 <lambdabot>   [(True,2),(True,3),(True,4),(False,1),(True,2),(True,3),(True,4)]
13:45:38 <rwbarton> @@ @hoogle @type f g g' a b -> g (g' a) (g' b)
13:45:40 <lambdabot>  Parse error:
13:45:40 <lambdabot>   parse error on input `->'
13:45:40 <lambdabot>  
13:45:45 <rwbarton> @@ @hoogle @type \f g g' a b -> g (g' a) (g' b)
13:45:46 <lambdabot>  No results found
13:45:50 <simpson> :t on
13:45:51 <rwbarton> @@ @hoogle @type \g g' a b -> g (g' a) (g' b)
13:45:52 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
13:45:53 <lambdabot>  Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
13:45:53 <lambdabot> Data.Data gmapQr :: Data a => (r' -> r -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:45:53 <lambdabot> Data.Data gmapQl :: Data a => (r -> r' -> r) -> r -> (forall d. Data d => d -> r') -> a -> r
13:45:54 <arbn> simpson: Isn't the point of Concurrent Haskell to avoid outside side-effects like that? You should use a communication abstract to tell threads when to threadDelay. MVars or something.
13:45:55 <ion> > ((zipWith (\a b -> (a < b, a)) <*> tail)) [1,2,3,4,1,2,3,4]
13:45:56 <lambdabot>   [(True,1),(True,2),(True,3),(False,4),(True,1),(True,2),(True,3)]
13:46:00 <ion> hmm
13:46:06 <arbn> communication abstraction*
13:46:06 <mzero> arbn: there isn't a single copyright notice, alas - but we should fix that
13:46:48 <arbn> mzero: OK. Yeah. It would be a convenience.
13:46:49 <simpson> arbn: I have an imperative, procedural event loop. It has two primitives: Wait for a timeout, then do something; or, read from a non-blocking source, then do something.
13:47:11 <simpson> arbn: I'm trying to figure out how to model lots and lots of pre-existing computations in my event loop in Haskell.
13:47:18 <simpson> I'm porting stuff.
13:47:19 * hackagebot MC-Fold-DP 0.1.1.0 - Folding algorithm based on nucleotide cyclic motifs.  http://hackage.haskell.org/package/MC-Fold-DP-0.1.1.0 (ChristianHoener)
13:47:28 <identity> simpson: can't you just use threadDelay inside the thread, then?
13:47:35 <identity> instead of delaying a remote thread
13:47:36 <identity> that is.
13:48:14 <spherox> @hoogle [(a, b)] -> a -> b
13:48:15 <lambdabot> Prelude lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:48:15 <lambdabot> Data.List lookup :: Eq a => a -> [(a, b)] -> Maybe b
13:48:16 <lambdabot> Language.Haskell.TH.Syntax RecConE :: Name -> [FieldExp] -> Exp
13:48:20 <simpson> identity: If threadDelay will delay IO'd threads, then certainly.
13:48:26 <identity> simpson: aye, it does
13:48:30 <identity> :t threadDelay
13:48:32 <lambdabot> Not in scope: `threadDelay'
13:48:36 <identity> @hoogle threadDelay
13:48:37 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
13:48:37 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
13:48:37 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
13:48:53 <niteria> > let a = [1,2,3,4,1,2] in map snd $ takeWhile (uncurry (<=)) $ zip ((head a):a) a
13:48:55 <lambdabot>   [1,2,3,4]
13:49:11 <niteria> but this is uglish
13:49:44 <nicoo> o_O
13:50:01 <nicoo> @pf \a map snd $ takeWhile (uncurry (<=)) $ zip ((head a):a) a
13:50:01 <lambdabot> Maybe you meant: bf pl
13:50:02 <Abso> :D
13:50:06 <nicoo> @pl \a map snd $ takeWhile (uncurry (<=)) $ zip ((head a):a) a
13:50:06 <lambdabot> (line 1, column 12):
13:50:06 <lambdabot> unexpected "$"
13:50:06 <lambdabot> expecting pattern or "->"
13:50:16 <nicoo> @pl \a -> map snd $ takeWhile (uncurry (<=)) $ zip ((head a):a) a
13:50:16 <lambdabot> map snd . takeWhile (uncurry (<=)) . (zip =<< (:) =<< head)
13:50:24 <nicoo> Not much better
13:50:43 <niteria> ugly part is prepending head
13:51:01 <niteria> not not-pointless style
13:51:03 <ion> > ((zipWith (\a b -> (a < b, b) =<< (Nothing:)) . map Just) [1,2,3,4,1,2,3,4]
13:51:04 <lambdabot>   <hint>:1:76: parse error (possibly incorrect indentation)
13:51:14 <nicoo> niteria: I know ;)
13:51:24 <ion> > ((zipWith (\a b -> (a < b, b)) =<< (Nothing:)) . map Just) [1,2,3,4,1,2,3,4]
13:51:26 <lambdabot>   [(True,Just 1),(True,Just 2),(True,Just 3),(True,Just 4),(False,Just 1),(Tr...
13:51:43 <ion> > (catMaybes . map snd . (zipWith (\a b -> (a < b, b)) =<< (Nothing:)) . map Just) [1,2,3,4,1,2,3,4]
13:51:45 <lambdabot>   [1,2,3,4,1,2,3,4]
13:51:56 <ion> > (catMaybes . map snd . takeWhile fst . (zipWith (\a b -> (a < b, b)) =<< (Nothing:)) . map Just) [1,2,3,4,1,2,3,4]
13:51:58 <lambdabot>   [1,2,3,4]
13:52:00 <quest> when I'm in a driving test, what is the best way to know acharacter's ASCII?
13:52:43 <ion> quest: Memorize the entire ASCII table.
13:52:45 <osfameron> you have some weird driving tests
13:52:47 <quest> no access to internet,  I guess theres a command in terminal that shows
13:52:50 <niteria> man ascii?
13:53:09 <niteria> quest: ^
13:53:09 <quest> ord a?
13:54:00 <identity> quest: you can remember the values for a and A and just add (num letter of alphabet) to that value
13:54:26 <osfameron> what is the actual use-case?
13:55:24 <osfameron> you could also hover over the character in vim and type ga
13:56:08 <pordan30> > ((,) <*> ord) <$> ['a'..'j']
13:56:10 <lambdabot>   [('a',97),('b',98),('c',99),('d',100),('e',101),('f',102),('g',103),('h',10...
13:56:14 <quest> what is the 'alt tab' equivalent of Linux?
13:56:20 <osfameron> quest: alt-tab
13:56:21 <pordan30> alt tab?
13:56:26 <ion> guest: alt-sysrq-b
13:56:36 <rwbarton> depends on window manager but normally something-tab yeah
13:56:53 <quest> it switches between text editir and terminal in windows
13:56:55 <ski> > (ord `graph`) `map` ['a' ..]
13:56:57 <lambdabot>   [('a',97),('b',98),('c',99),('d',100),('e',101),('f',102),('g',103),('h',10...
13:56:58 <identity> Welcome to #haskell QUIZ TIME! Todays topics: ASCII, Basic Linux and more!
13:57:05 <osfameron> if someone asks about "Linux" then they probably haven't got a weird window manager ;-)
13:57:18 <rwbarton> fair enough
13:57:22 <osfameron> what's sysrq?
13:57:28 <pordan30> :t graph
13:57:29 <lambdabot> Arrow ar => ar a b -> ar a (a, b)
13:57:31 <osfameron> ion--
13:57:35 <osfameron> if that's a reboot command
13:57:53 <nicoo> osfameron: Like in REISUB ?
13:58:09 <osfameron> nicoo: wuh?
13:58:12 <nicoo> It's the special key to give the kernel commands through the keyboard driver
13:58:28 <osfameron> oh yes, I do have it
13:58:37 <nicoo> osfameron: unRaw, tErm, kIll, Sync, Unmount, reBoot
13:58:38 <ski> <http://en.wikipedia.org/wiki/SysReq>,<http://en.wikipedia.org/wiki/Magic_SysRq_key#Commands>
13:58:38 <osfameron> fn-PrtSc on my thinkpad keyboard
13:58:47 <quest> pordan can you explain how your code to show ord pair work?  I don't understand
13:59:21 <quest> what the dollar and star does?
14:00:46 <pordan30> <*> = \f g x -> f x (g x), <$> = map, so ((,) <*> ord) = \x -> (,) x (ord x) and ((,) <*> ord) <*> xs = map (\a -> (a, ord a)) xs
14:01:28 <pordan30> err, <$> instead of <*> in the last occurrence
14:01:35 <Sonderblade> is there a haskell way to create a generator?
14:01:40 <ion> osfameron: He seems to be trolling, i don’t think my answer was worth --. :-P
14:01:46 <ski> quest : if you're using GNU Screen, an equivalent is `^AA' ..
14:02:22 <edwardk> Sonderblade: easy enough, just make a list and read it. ;)
14:02:56 <edwardk> Sonderblade: remember we're lazy, so forM [1..100000] $ \i -> do …  isn't going to take up huge swathes of memory or precalculate it
14:03:09 <osfameron> ion: he was off topic certainly.  I don't like people giving potentially dangerous commands to people on forums, it's mean
14:03:31 <otters> @pl ap
14:03:32 <lambdabot> ap
14:03:33 <otters> wait
14:03:37 <otters> @src ap
14:03:37 <lambdabot> ap = liftM2 id
14:03:48 <Raynes> Where is the ghc package database stored on OS X? I'm trying to do a complete reinstall of ghc and the haskell platform, but whenever I reinstall ghc, ghc-pkg reports the same package database with all sorts of broken packages.
14:03:49 <Sonderblade> edwardk: the list is coming from an io monad: IO [String] so it is fully evaluated when it comes back
14:04:31 <edwardk> Sonderblade: then what you probably want is something more like "ListT-done-right" or LogicT, etc.
14:04:36 <otters> Raynes: doesn't ghc-pkg list show you?
14:04:46 <edwardk> so you can generate it as you go with smaller actions for instance
14:05:17 <nicoo> @type ap
14:05:19 <lambdabot> Monad m => m (a -> b) -> m a -> m b
14:05:34 <Sonderblade> edwardk: i've no idea what that is :)
14:05:44 <edwardk> Raynos: you might want to remove your local ~/.ghc directory
14:05:57 <quest> zipWith (+) [1,2] [3,4]
14:06:00 <edwardk> Raynos: as long as you weren't silly and didnt start sudo installing packages that should work well enough
14:06:22 <Raynes> edwardk: I don't have a ~/.ghc
14:06:39 <quest> gets [4,6] ?
14:06:41 <edwardk> Raynes: what platform are you on?
14:06:41 <Raynes> All the paths from ghc-pkg that I can see (it's a zillion lines) are ~/.cabal paths, but that directory has been deleted.
14:06:55 <luite> Raynes: oh platform might have a different config, search ~/Library for a folder named package.conf.d
14:06:59 <Raynes> I was on 2012.4.0.0, but the platform is uninstalled at the moment.
14:07:15 <edwardk> i meant windows, mac, vs linux
14:07:21 <Raynes> Oh, mac.
14:08:29 <edwardk> on my mac it always makes a .ghc folder when i install locally and puts the contents in there. the usual rule of thumb is you delete that rather than .cabal. not sure why yours doesnt exist
14:08:56 <Raynes> Ugh, it doesn't exist because I wasn't in my ~.
14:08:56 <monochrom> deleting .cabal is not enough
14:09:04 <Raynes> It's there. Sorry. :<
14:09:17 <luite> :)
14:09:21 <monochrom> as long as "ghc-pkg list" still lists things, they still "exist"
14:09:43 <edwardk> Raynes: blow that away and try again
14:09:47 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml
14:09:55 <Raynes> edwardk: That did the trick.
14:10:00 <Raynes> Thanks a lot. :)
14:10:07 <edwardk> in the future you shouldn't have to touch ~/.cabal. just nuke ~/.ghc
14:10:11 <Raynes> I'll try to not explode my packages this time.
14:10:23 <edwardk> that way you keep the cache of the downloaded files, etc.
14:10:46 <Raynes> I don't know how I managed to break everything just by trying to parse JSON, but I certainly did.
14:10:47 <monochrom> be very conservative with what you install and/or "upgrade"
14:11:16 <Raynes> aeson required older versions of bytestring, text, etc, so I seem to recall hiding a few packages and reinstalling one or two.
14:12:01 <monochrom> that is not reproduced here
14:12:26 <monochrom> "cabal install --dry-run aeson" does not say that it will bring in an old version of bytestring
14:12:49 <Raynes> It was giving me errors like "Could not match expected type "text-someoldversion:Text" with type "Text"
14:12:59 <monochrom> but of course I have a pretty clean system
14:13:00 <Raynes> It actually installed fine, just didn't work.
14:13:15 <Raynes> I suppose I might have broken the packages somehow before that though.
14:13:32 <monochrom> in general, the more packages and versions you add, the more cabal-install needs to bring in even more
14:13:46 <Raynes> If it happens again, I think I'll ask around here instead of, you know, sending a bob-omb into my package database.
14:14:03 <rwbarton> it did work, but you were trying to use different packages with incompatible dependencies on text at the same time
14:14:05 <monochrom> in the limit, it wants to reinstall things that can't be reinstalled because they are base and ghc
14:14:45 <rwbarton> in general when you install a package successfully that does not mean you can necessarily use it simultaneously with any other package
14:14:55 <rwbarton> if you want to be able to use both X and Y simultaneously, do "cabal install X Y"
14:15:02 <typoclass> Raynes: yup, folks in here can usually fix cabal issues pretty quickly. be sure to run it verbosely with -v3 and put cabal's output on hpaste
14:15:52 <tac_> Is there a name for Monads which act like state or ST, where the computation is always linear (no backtracking or saving continuations)?
14:16:23 <monochrom> ST does not backtrack
14:16:24 <johnny934759> i can't seem to compile any code with -prof option
14:16:53 <johnny934759> i changed prof option to true in ~/.cabal/config then reinstall... no change
14:17:21 <tac_> monochrom: I know it doesn't backtrack.
14:17:35 <monochrom> you have to rebuild a lot of things. but not those that come with GHC. never rebuild them
14:17:40 <pordan30> are you looking for the monadstate class?
14:17:53 <nwf> Is there a way to factor out common dependencies between a Library and an Executable (or several Executable) stanzas in a .cabal file?
14:18:09 <monochrom> I see, you're looking for terminology. I know none.
14:18:11 <tac_> pordan30: I don't think that's quite it. Something like Maybe would also be "linear" in this sense
14:18:14 <tac_> yeah
14:18:49 <Raynes> typoclass: Duly noted.
14:19:51 * ski . o O ( `State :: !_+ * -o * -o *; Maybe :: !_0 * -o *' )
14:22:28 <typoclass> ski: your cat walked over the keyboard. just wanted to let you know
14:22:38 <monochrom> linearly, too
14:23:31 <eric_niebler> hi all. looking for a function that takes a tuple of functions, a tuple of arguments and produces a tuple of results. is there a name for such a beastie. Hoogle comes up empty for: ((a->b),(c->d))->(a,c)->(b,d)
14:24:06 <mauke> :t uncurry (***)
14:24:07 <lambdabot> Arrow a => (a b c, a b' c') -> a (b, b') (c, c')
14:24:24 <typoclass> > (pred &&& succ) (42,37) -- eric_niebler: this maybe?
14:24:26 <lambdabot>   No instance for (GHC.Enum.Enum (t0, t1))
14:24:26 <lambdabot>    arising from a use of `e_14237'...
14:24:39 <typoclass> gah
14:24:41 <byorgey> ***, not &&&
14:25:03 <byorgey> mauke already said the function eric_niebler wants
14:25:03 <typoclass> > (pred *** succ) (42,37)
14:25:05 <eric_niebler> ok, don't know arrows. how would one pronounce *** ?
14:25:06 <lambdabot>   (41,38)
14:25:15 <mauke> @quote monochrom modem
14:25:15 <lambdabot> No quotes match. I am sorry.
14:25:15 <otters> star star star
14:25:26 <byorgey> eric_niebler: perhaps "times".
14:25:26 <eric_niebler> otters: heh, thanks.
14:25:33 <typoclass> > (pred &&& succ) 42 -- another Arrow function that's sometimes useful
14:25:35 <lambdabot>   (41,43)
14:25:38 <otters> eric_niebler: no problem
14:25:42 <byorgey> it's multiplication, for a suitably generalized notion of multiplication.
14:26:01 <atriq> Perhaps "merge"?
14:26:02 <eric_niebler> off to read about Arrows. thanks all.
14:26:12 <typoclass> eric_niebler: you won't find *** or &&& easily with hoogle because their type is slightly funky (as mauke showed)
14:26:22 <atriq> For the pronunciation of (***)
14:26:23 <byorgey> eric_niebler: you don't particularly need to read about arrows.
14:26:35 <atriq> And fan out for (&&&)
14:26:39 <mauke> I don't anything about arrows other than (->)
14:26:46 <byorgey> just replace a with (->) in the above type signature
14:27:09 <atriq> mauke, Comonad w => w a -> b and Monad m => a -> m b are BOTH arrows.
14:27:14 <mauke> instance Arrow (=>)
14:27:17 <atriq> The Cokleisli and Kleisli arrows
14:27:44 <ski> `f &&& g' could be pronounced as "`f' tupled with `g'"
14:28:14 <monochrom> you are not a modem. you don't need to convert symbols into voice commands
14:28:34 <atriq> monochrom, that's a dangerous assumption to make
14:28:39 <atriq> I am, in fact, a modem
14:28:44 <atriq> beep da-boop
14:28:54 <monochrom> +++ATH0
14:28:55 <mauke> that's right, we're going to cloud city
14:29:39 <atriq> I'm a hungry modem, though
14:29:49 <mauke> 0xF00D
14:31:55 <byorgey> @quote pronounced
14:31:56 <lambdabot> uncyclopedia says: Calculations which are undefined are denoted by the _|_ symbol, pronounced Bottom, which the documentation explains as the compiler giving you the finger.
14:32:12 <byorgey> @quote Jacquelin
14:32:12 <lambdabot> monochrom says: <$> is pronounced Jacquelin von Brionée
14:33:15 <eric_niebler> monochrom: i'm importing these ideas into another programming language which doesn't allow new operators. so yeah, i wanted to know if there was a pronounceable name for this operation.
14:35:58 <ski> eric_niebler : i've seen `(***)' called `cross' ..
14:37:52 <monochrom> take comfort in the convention that, in those languages, long names are the norm
14:38:09 <spherox> eric_niebler, what language?
14:38:24 <eric_niebler> monochrom: thx. :-P
14:38:38 <mauke> strpbrk
14:41:15 <eric_niebler> spherox: c++. doing metaprogramming. pure function logic is best reasoned about in haskell, so i want to borrow as many ideas and terminology as makes sense.
14:42:41 <typoclass> eric_niebler: good luck :-/ sounds daunting
14:46:30 <eric_niebler> typoclass: i'll make some s*** up. i'm good at that. (see what i did there?)
14:46:54 <mauke> just overload operator*
14:47:29 <eric_niebler> mauke: C++ metaprogramming == compile time. operator* == runtime.
14:47:49 <mauke> hmm, you can't overload types, right?
14:47:49 <eric_niebler> sorry, way off-topic now. thanks all.
14:52:25 <Raynos> edwardk: His name is Raynes.
14:52:31 <Raynos> Raynes: get a less similar name >_>
14:52:48 <atriq> Wow, someone's actually came up for a use for TardisT!?
14:52:55 <Raynes> I will be Raynes until the day I die.
14:53:02 * mauke is now known as Raynis
14:53:06 <arbn> atriq: What has it been used for?
14:53:08 <ogsus> argghhh and you are both the same color
14:53:16 <atriq> Scoring bowling
14:53:27 <Raynus> actually that sounds disturbing
14:53:34 <Raynes> Raynes: On the other hand, that wouldn't have happened had he set his IRC client to prefer the most recently active user for tab completion.
14:53:35 <Raynes> :(
14:53:37 <atriq> http://unknownparallel.wordpress.com/2012/11/05/bowling-on-a-tardis/
14:53:51 <edwardk> Raynes: no such option in textual i think
14:54:13 <Raynes> edwardk: Ugh, really?
14:54:15 * Raynes checks
14:55:04 <Raynes> Darn.
14:55:36 <atriq> edwardk, Data.Stream.Infinite and Control.Lens.Zipper have an annoying conflict
14:55:45 <edwardk> the (:>) ?
14:55:51 <atriq> Yeah
14:56:34 * nicoo is too used to have :> as subtyping anyways.
14:56:41 <edwardk> :t (:>)
14:56:42 <lambdabot>     Not in scope: data constructor `:>'
14:56:43 <lambdabot>     Perhaps you meant one of these:
14:56:43 <lambdabot>       `Seq.:>' (imported from Data.Sequence),
14:56:49 <edwardk> i don't have a data constructor in zipper
14:56:53 <edwardk> i have a type constructor
14:56:58 <atriq> Oh, that IS handy
14:57:00 <edwardk> i have a data constructor in Data.Stream.Infinite
14:57:09 <edwardk> they shouldn't collide
14:57:22 <atriq> Heh, I saw them and panicked
14:57:25 <atriq> That's a relief
14:57:25 <edwardk> =)
14:57:28 <atriq> =) indeed
15:04:06 <ion> What was module other than Debug.SimpleReflect that let you write symbolic expressions that are a Num instance? It let you display the data sharing.
15:04:12 <atriq> edwardk, for what it's worth, Control.Lens.Zipper also conflicts with Control.Arrow
15:04:24 <edwardk> there i care a lot less ;)
15:04:35 <ion> I tried hoogling with “var” but didn’t get good results.
15:04:51 <atriq> :t left
15:04:53 <lambdabot>     Ambiguous occurrence `left'
15:04:53 <lambdabot>     It could refer to either `Control.Arrow.left',
15:04:53 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
15:05:29 <edwardk> i can't in good conscience rename those standard zipper operations to make use for an abuse of what should just be standard bifunctor maps, anyways =P
15:05:35 <ski> > var "a" + x
15:05:38 <lambdabot>   Couldn't match expected type `Data.Number.Symbolic.Sym a0'
15:05:38 <lambdabot>              wit...
15:05:47 <ski>               with actual type `Debug.SimpleReflect.Expr.Expr'
15:05:51 <edwardk> er make way for ;)
15:06:12 <edwardk> i was somewhat sad when they conflicted though
15:06:42 <atriq> I am quite possibly the only person who thinks Data.Monoid.Endo should by newtype Endo c a = Endo {appEndo :: c a a}; instance Category c => Monoid (Endo c a) where...
15:06:50 <edwardk> If left, right, and (%) are the 3 greatest conflicts i get out of lens i'm pretty happy
15:07:03 <hpc> atriq: not the only one
15:07:20 <hpc> but i think it would belong in a categorical module
15:07:25 <edwardk> atriq: i had a GEndo lying around in a package somewhere, but i've forgotten it
15:08:07 <acowley> So I'm sitting here writing some multi dimensional indexing code, and I can't help but suspect that this exists somewhere.
15:08:28 <acowley> Anyone have any recommendations for particularly flexible loop indexers?
15:08:47 <hpc> what kind of indexing?
15:08:49 <edwardk> acowley: how so?
15:09:29 <acowley> For example, suppose I have a 3D discretization packed into a flat array, and I want to walk down the second dimension
15:10:12 <edwardk> acowley: so basically you want something like the blas vector indexing?
15:10:24 <acowley> it seems worryingly ad hoc, so there may not be any really elegant way to do it. My current setup involves a zipper over the dimensions.
15:10:28 <acowley> edwardk: yeah
15:10:59 <edwardk> you can always pack it flat, and use a start index, delta and end point ;)
15:11:23 <acowley> The delta isn't constant
15:12:01 <edwardk> well, then you are probably hosed =)
15:12:23 <acowley> What I have so far is pretty neat, but now I need composable folds to stuff into the mix
15:12:37 <acowley> and as I start wheezing from all the yak hair, I thought I'd come up for air
15:12:46 <edwardk> :t Data.Vector.backpermute
15:12:48 <lambdabot> Couldn't find qualified module.
15:12:53 <edwardk> bah
15:13:04 <acowley> That's not enough for me
15:13:23 <acowley> If I come up with something that works I'll run it by #haskell to see if it seems useful to anyone else
15:13:35 <edwardk> kk
15:14:44 <schattenwesen> hi, what is an actual working Gui-Toolkit fr Haskell that can be used for win32? It is really burning, to use ghci and then plot and play, but how to get this (fast)? Most bibs are old and ...hm bitrotting?
15:16:31 <Raynes> https://www.refheap.com/paste/6598 What monstrously incorrect horrid thing am I doing here? (This is an aeson example)
15:16:37 <ion> Ah, found it. http://hackage.haskell.org/package/traced
15:17:26 <Raynes> Oh, I guess I should have included output.
15:17:30 <Raynes> It's Nothing.
15:17:34 <Raynes> Just Nothing.
15:17:46 <Raynes> Hahaha, Just Nothing. It just occurred to me that that has meaning in Haskell.
15:18:02 <Raynes> The result is 'Nothing'.
15:18:05 <nicoo> Raynes: Classic
15:18:11 <dibblego> I have a colleague whose surname is Just
15:18:24 <ski> > Just Nothing == Nothing
15:18:26 <lambdabot>   False
15:18:26 <Eduard_Munteanu> schattenwesen: gtk2hs should work fine
15:18:29 <dibblego> and I always try to tell him that he is a forall a. a -> Maybe a
15:18:31 <Tehnix> is there a simple way to md5 hash a string?
15:18:39 <startling> Just Nothing (the haskell value) is super useful.
15:18:49 <hpc> > join (Just Nothing)
15:18:51 <lambdabot>   Nothing
15:19:52 <acowley> Tehnix: Check hackage
15:20:05 <acowley> Tehnix: http://hackage.haskell.org/package/pureMD5 for example
15:20:16 <startling> wow, Bitraversable is super useful.
15:20:41 <startling> edwardk: remember when I was asking for a way to traverse both sides of an Either? Bitraversable does it.
15:20:54 <Tehnix> acowley: yeah, but I ran in to the issue of bytestrings then :/
15:20:57 <edwardk> yes. i just don't have it bundled in lens =)
15:21:04 <acowley> Tehnix: what issue?
15:21:13 <Tehnix> as in, how to convert from string to bytestring
15:21:32 <edwardk> i can concoct many of those 'multilenses', but i haven't come up with a nice way to build combinators for using them
15:21:48 <startling> edwardk: yeah, interesting.
15:21:58 <startling> edwardk: could (.:) do it?
15:22:09 <acowley> Tehnix: are you dealing with ASCII text?
15:22:10 <Tehnix> I tried something like, md5 $ fromString "bla"
15:22:12 <edwardk> you can even compose them with arrow sugar, like normal lenses.
15:22:21 <edwardk> if you uncurry bitraverse that is
15:22:23 <startling> edwardk: oh neat
15:22:33 <edwardk> note the arrow sugar composes backwards
15:22:39 <Tehnix> acowley: I'd probably need to manipulate UTF-8
15:23:41 <sam0> hi
15:23:43 <acowley> Well I think md5 just works on bytes, so I'm afraid you'll need to upgrade "probably" to "certainly", the get a ByteString of your encoded characters
15:24:01 <Raynes> Oh, the problem was that my json string value was single quoted. I suck.
15:24:30 <acowley> Tehnix: e.g. http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-UTF8.html
15:25:15 <Tehnix> md5 $ toChunks $ fromString "bla"
15:25:35 <Tehnix> yeilds that it's getting Data.ByteString.UTF8.ByteString and wants Data.ByteString.Lazy.ByteString
15:27:22 <acowley> If you have a strict ByteString, x, then you want Data.ByteString.Lazy.fromChunks [x]
15:28:04 <acowley> Tehnix: I would have expected http://hackage.haskell.org/packages/archive/utf8-string/0.3.7/doc/html/Data-ByteString-Lazy-UTF8.html to do what you want directly
15:28:50 <acowley> It re-exports Data.ByteString.Lazy.ByteString
15:29:08 <Nereid> hooray, I used ViewPatterns for something practical for the first time.
15:29:39 <Tehnix> acowley: yeah :) that did the trick, thanks :)
15:30:01 <acowley> Tehnix: excellent!
15:30:09 <Tehnix> thanks for the help :)
15:32:15 <sam0> I am new to monads and I am having some trouble hpaste.org/77624
15:33:25 <sam0> I'm not sure if I am importing a wrong module
15:33:27 <hpc> sam0: afaict, that definition is correct, up to the fact that State is defined in terms of StateT
15:33:33 <hpc> you want
15:33:48 <hpc> StateT $ \(x:xs) -> return (x, xs)
15:33:54 <hpc> (probably)
15:34:23 <Nereid> and an Identity there too
15:34:23 <acowley> State is defined in mtl
15:34:41 <hpc> Nereid: return = Identity
15:34:44 <Nereid> oh fine
15:34:49 <hpc> i made it polymorphic for all StateT
15:34:51 <sam0> Hm... it seems to compile as you said
15:34:57 <acowley> sam0: What version of mtl do you have?
15:35:23 <sam0> I am not sure
15:35:27 <acowley> Oh, nm, I misunderstood your error
15:35:28 <Nereid> sam0: probably >= 2
15:35:32 <Nereid> acowley:
15:35:32 <Nereid> ^
15:35:43 <acowley> Everything's fine, nothing to see here, listen to hpc
15:35:47 <Nereid> sam0: mtl 2 changed the definition of State
15:35:54 <Nereid> so that code would have worked with old mtl
15:36:19 <sam0> Oh I see, I was working with a book and some example codes are not compiling so I was a little confused
15:36:26 <Nereid> sam0: instead of State, use state
15:36:37 <Nereid> state $ \(x:xs) -> (x,xs)
15:36:55 <Nereid> either that or use hpc's thing that works for StateT over any m
15:37:21 * hackagebot alpha 0.99 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.99 (MarcCoiffier)
15:37:32 <sam0> Thanks for the help
15:37:36 <sam0> I have a lot more learning to do haha
15:38:01 <Nereid> it's a good exercise to implement State yourself :p
15:39:05 <arbn> If I have an IO computation, and I need to export it via a foreign export ccall, how do I perform the IO computation at the top-level? Is it OK to unsafePerformIO here?
15:39:31 <startling> arbn, course not.
15:39:34 <hpc> whut
15:39:41 <startling> arbn, just export the IO Whatever
15:39:49 <arbn> The output would be IO CInt. Is that OK?
15:39:56 <Nereid> yes
15:40:00 <arbn> Oh. OK.
15:40:04 <arbn> Thanks.
15:49:11 <acowley> Well, I'm happy. I now have a function whose documentation concludes with, "The idea is to let the caller do whatever the heck they want in that traversal."
15:49:48 <acowley> The core of the indexer is zipFoldM :: Monad m => Zipper Int -> (a -> Int -> m a) -> a -> [Int] -> m ()
15:50:04 <acowley> Though I will probably have to change all my names
15:51:33 <Nereid> @hoogle (Integral n, Monoid m) => m -> n -> m
15:51:33 <lambdabot> Prelude (^) :: (Num a, Integral b) => a -> b -> a
15:51:33 <lambdabot> Prelude (^^) :: (Fractional a, Integral b) => a -> b -> a
15:51:33 <lambdabot> Prelude const :: a -> b -> a
15:51:47 <Nereid> Data.Monoid should have a n'th power function.
15:53:16 <Nereid> analogous to times1p for Semigroups
15:58:01 <archmonk> js
16:00:08 <ozgura> I have a cabal project. If I compile a single module with "ghc -odir dist/build -hidir dist/build filename.hs" it places the *.hi and *.o files in the correct places
16:00:30 <ozgura> but when I run "cabal install" in the project dir later on, those modules are recompiled
16:00:45 <ozgura> can I convince cabal to use the files I just generated instead
16:01:34 <ozgura> (I am asking this, because I am trying to setup a bg process to build files as they get modified, and want this script to play well with "cabal install")
16:02:46 <gertc> is there a build option do to allow acces to a hidden model? in my case Network.WebSockets.Monad
16:02:55 <startling> hidden model?
16:03:03 <startling> oh, you probably mean module.
16:03:19 <gertc> yes sorry :)
16:03:21 <startling> is it in your own package? if not, I don't think there's such an option.
16:03:26 <gertc> nope
16:04:09 <startling> you might want to bug the maintainers, then, if you want to do something reasonable.
16:04:58 <gertc> deriving instance Eq (WS.Sink WS.Hybi10)
16:05:25 <gertc> or instance Eq (WS.Sink WS.Hybi10) where WS.Sink a == WS.Sink b = a == b
16:06:29 <gertc> trying this http://stackoverflow.com/questions/13350569/deriving-instance-eq-sink-p
16:15:53 <rwbarton> possibly for your purposes you can make a pair of the Sink returned from getSink and a comparable "identity" obtained from some other source (e.g. newIORef)? if you only ever call getSink once per websocket connection
16:16:10 <rwbarton> then write an Eq instance for that that only compares the added identity
16:16:53 <gertc> yes i do i like this now (gert,mysink)
16:17:24 <gertc> and look up gert to sent gert a message
16:18:04 <gertc> but online i can open a new window and then there are 2 gert's :)
16:18:23 <gertc> so the best way is to just compare sockets
16:18:40 <rwbarton> right, so where you call getSink, also do a newIORef or something and compare on the result of that
16:18:49 <rwbarton> or any way to generate a unique identifier for each connection
16:20:17 <gertc> that would probably work but i am kind of interested why there is now Eq instance in the first place? if it would be as trivale as just one line of code? i am trying to figure out what i am missing here
16:20:41 <rwbarton> I think that's right
16:21:17 <rwbarton> after all Handle is also an instance of Eq, and Sink is a similar sort of thing
16:22:42 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/Main.hs
16:23:01 <gertc> removeClient c = filter ((/= fst c) . fst)
16:23:25 <gertc> type Client = (FB.User, WS.Sink WS.Hybi10)
16:24:25 <gertc> is there was a eq instance then i would not need to do the (x,sink) at all right?
16:25:06 <gertc> i just compaire the disconected socket to the list of all sockets no mather wich person is loged in
16:26:28 <gertc> now i have to code this uid crap to be bale to log in under the same name
16:28:41 <gertc> one thing that i did not think of is that the eq instance of sink compairs just the Mvar container
16:29:42 <gertc> not the actually socket? so does this make life complicated or is it just as trival to eq that as wel ?
16:31:01 <gertc> http://hackage.haskell.org/packages/archive/websockets/0.7.0.0/doc/html/src/Network-WebSockets-Monad.html#Sink
16:31:27 <rwbarton> there should be one MVar allocated per connection as I understand it
16:31:37 <rwbarton> so that is the thing you want to compare to identify a connection
16:32:13 <gertc> ok so that one line adding to the websocket code would do it?
16:33:28 <gertc> deriving instance Eq (Sink p)
16:33:29 <rwbarton> "deriving (Eq)" should do it
16:33:55 <gertc> aha just adding that to my code
16:38:24 <gertc> no, is still have to add it to his code, ok let see if i can build this websocket stuff from github
16:51:41 <spherox> @pl f g h a b = g (h a) b
16:51:41 <lambdabot> f = (.)
16:51:44 <spherox> doh
16:52:02 <spherox> this is what I get for thinking too much
16:52:04 <hpc> heh
16:52:26 <acowley> Does anybody have a need for an n-dimensional distance transform?
17:02:23 * hackagebot ListLike 3.1.7 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.1.7 (JohnLato)
17:07:12 <shachaf> Is ListLike really a type class with *73* methods?
17:07:31 <copumpkin> yes
17:07:57 <EvanR7> lists can do a lot of shit
17:07:59 <monochrom> that is very extreme!
17:08:01 <hpc> http://24.media.tumblr.com/tumblr_m68mg2HrKR1qfxowao1_400.jpg
17:08:21 <startling> shachaf, it's almost like someone wrote it to annoy you
17:08:43 <monochrom> only HXT has similarly fat type classes :)
17:09:02 <startling> it's nice that you only have to define head, tail, null, and singleton though
17:11:00 * ski . o O ( "won't anyone think of list-*unlike* structures !?" )
17:11:17 <startling> I feel like it'd be nicer if it was, uncons (listlike a -> Maybe (a, listlike a)), and empty, though.
17:11:57 <hpc> startling: that smells a lot like a lens
17:12:02 <monochrom> list-unlike type class has 37283 methods
17:12:24 <hpc> monochrom: and a good third of them are just the tuple operations
17:12:32 <hpc> (,), (,,), (,,,), ...
17:13:39 <startling> hpc, huh.
17:16:34 <hpaste> “Ben Gamari” pasted “Leaky Aeson” at http://hpaste.org/77625
17:17:07 <bgamari> bos, Can you see why the above would leak space?
17:17:23 * hackagebot listlike-instances 0.2.3 - Extra instances of the ListLike class  http://hackage.haskell.org/package/listlike-instances-0.2.3 (JohnLato)
17:20:50 <bos> bgamari: leaking space? how are you measuring it as leaking?
17:21:03 <bgamari> bos, working set usage
17:21:12 <mm_freak> donri: (regarding ApplicativeLoop) what would the type of – let's call it – afix be?
17:21:22 <bgamari> bos, The heap usage of bytestrings monotonically increases
17:21:32 <donri> mm_freak: no clue
17:21:48 <hpc> :t mfix
17:21:50 <lambdabot> MonadFix m => (a -> m a) -> m a
17:21:51 <bgamari> bos, I would have thought that the bytestring could be thrown away after the record has been parsed
17:21:54 <mm_freak> you could generalize mfix to afix, but i find that quite pointless
17:22:07 <mm_freak> mfix isn't really useful without (>>=) or (>=>)
17:22:18 <mm_freak> and with one of the two you have either Monad or Category
17:22:24 * hackagebot sphinx 0.6.0 - Haskell bindings to the Sphinx full-text searching daemon.  http://hackage.haskell.org/package/sphinx-0.6.0 (GregWeber)
17:22:25 <bgamari> bos, The memory usage seems to be in parseRecord, but not in framePt
17:22:26 * hackagebot edge 0.8.8 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8.8 (ChristopherHoward)
17:22:31 <mm_freak> i'd just generalize ArrowLoop to CategoryLoop and be done with it
17:22:39 <bos> bgamari: aeson doesn't parse lazily, you need to do that by hand
17:22:59 <bos> bgamari: it's going to hold onto the entire bytestring until it succeeds or fails
17:23:04 <mm_freak> in fact i'd generalize most Arrow* classes to Category* classes
17:23:20 <mm_freak> if not all
17:23:20 <donri> they don't need arrow?
17:23:26 <mm_freak> not really
17:23:29 <bgamari> bos, alright, I guess that would explain it
17:23:50 <mm_freak> the Arrow constraint is arbitrary, about the same as the Monad constraint for MonadFix
17:26:49 <bgamari> bos, Oh dear, sorry, s/aeson/cassava/
17:26:57 <bgamari> and perhaps s/bos/tibbe/
17:27:10 <bgamari> mixing up parsing libraries
17:27:32 <tibbe> bgamari: what did I do now?
17:27:35 <bgamari> although perhaps the response still applies
17:27:53 <bgamari> tibbe, did you see the QSem patch?
17:27:54 <tibbe> bgamari: cassava's API is lazy in converting fields IIRC
17:28:05 <tibbe> bgamari: I did, thanks. I'll have Mikhail review it as it's his code.
17:28:16 <bgamari> tibbe, then yes, that's what you did ;) damn laziness
17:28:29 <tibbe> bgamari: aeson lets you convert either strictly or lazily, I have plans to support both
17:28:35 <bgamari> tibbe, that's probably what's going on here then, tibbe, http://hpaste.org/77625
17:28:36 <tibbe> bgamari: but have been too lazy to do so yet
17:28:51 <tibbe> bgamari: please file a bug to motivate me to fix it by the next release :)
17:28:58 <bgamari> tibbe, sure
17:29:02 <bgamari> tibbe, thanks
17:29:44 <tibbe> bgamari: include the sample program and preferrably a heap profile
17:29:50 <tibbe> bgamari: I think I know what's going on
17:30:13 <tibbe> bgamari: but I need to find some time to sit down and fix it
17:30:22 <bgamari> tibbe, alright
17:30:41 <bgamari> tibbe, The heap profile isn't very helpful in this case
17:30:50 <tibbe> bgamari: at least describe the symptoms
17:30:57 <tibbe> bgamari: what kind of object is leaked, etc
17:31:21 <bgamari> all of the allocation is in parseFrame, as expected
17:31:28 <tibbe> bgamari: a bit of sample data (at least one record that I can duplicate to create a big file) would help
17:31:38 <bgamari> sure, it's coming
17:32:13 <tibbe> bgamari: you're framePt function doesn't actually do anything, given that the constructor is already strict
17:32:55 <bgamari> tibbe, Yes, I suppose the bang patterns are redundant but I didn't know how to write it point-free
17:33:16 <bgamari> It only exists to pack x and y into a P
17:33:17 <tibbe> bgamari: ah, I see
17:33:26 <tibbe> makes sense
17:33:46 <hpaste> “Ben Gamari” pasted “Heap Profile” at http://hpaste.org/77626
17:34:43 <tibbe> bgamari: I was thinking of the graphic heap profile that shows which constructors are in the heap as a function of time, -hy IIRC
17:35:05 <bgamari> ahh, yes
17:35:45 <tibbe> bgamari: you want to compile this code with -funbox-strict-fields or add UNPACK pragmas to all those scalar fields.
17:36:02 <tibbe> bgamari: to all fields of FramePt actually
17:36:28 <tibbe> getting off the shuttle soon
17:37:33 <bgamari> tibbe, Alright, trying this
17:37:40 <tibbe> bgamari: great
17:38:51 <tibbe> bgamari: if you want, you can also replace .! with parseField (V.unsafeIndex v index)
17:39:00 <tibbe> bgamari: since you're checking the length already
17:39:08 <tibbe> bgamari: (I include the safer option in the docs)
17:39:14 <bgamari> tibbe, http://goldnerlab.physics.umass.edu/~bgamari/legos.ps
17:39:20 <bgamari> there is a profile
17:39:25 <tibbe> thanks
17:40:00 <tibbe> bgamari: finally, is the input data available? or a sample of it?
17:40:06 <tibbe> getting off in a sec
17:40:06 <bgamari> yep
17:40:09 <tibbe> back in a while
17:40:15 <tibbe> please attach at least links to the bug
17:40:47 <tibbe> bgamari: try the heap profile that includes the constructors instead of the types
17:40:53 <tibbe> it's more useful
17:40:57 <bgamari> Sure
17:50:27 <Raynes> How do you make ghci use a language pragma?
17:50:37 <bgamari> Does anyone know what the OTHER closure description represents on a heap profile?
17:50:48 <bgamari> Raynes, :set -X...
17:50:57 <Raynes> Cool, thanks!
17:51:29 <bgamari> Raynes, no worries
17:52:21 <malik> to intersect several sets should I just call intersection multiple times?
17:53:10 <bgamari> malik, foldl1 S.intersection ?
17:53:57 <malik> I wanted to do something similar. was wondering if there's something more efficient?
17:54:21 <malik> something that doesn't create all the intermediate sets
17:54:25 <shachaf> Probably foldl1'
17:54:49 <Blkt> good night everyone
17:55:13 <bgamari> shachaf, I suppose so
17:55:28 <shachaf> No identity to use for foldl. :-(
17:59:08 <startling> shachaf: Set.fromList [minBound..maxBound], duh
17:59:25 <shachaf> [minBound..maxBound] /= universe
17:59:46 <gertc> omg the deriving (Eq) stuff just work :)
18:00:17 <startling> fine, Set.fromList Data.Enumerable.enumerate
18:00:55 <shachaf> I've never heard of that module.
18:01:13 <shachaf> Oh, copumpkin.
18:01:15 <shachaf> I should've known.
18:01:26 <copumpkin> ?
18:01:46 <shachaf> Data.Enumerable
18:01:53 <copumpkin> ah
18:02:06 <mauke> Data.LtCmdr
18:02:15 <startling> shachaf: hehe
18:02:42 <startling> two bad there's no nice way to have infinite sets
18:02:47 <shachaf> data Cardinal = Finite Integer | Aleph Integer -- I can dream
18:02:52 <mauke> *their's
18:03:18 <startling> mauke: hm?
18:03:34 * ski . o O ( <http://math.andrej.com/2008/11/21/a-haskell-monad-for-infinite-search-in-finite-time/> )
18:03:35 <mauke> "two bad"
18:04:44 <shachaf> one bad two bad my bad your bad
18:05:27 <pordan30> is it possible to have a representation of infinite sets that doesn't sacrifice the complexity of the set operations? if i recall, that's essentially the reason that people don't construct balanced tree representations of infinite sets.
18:06:14 <startling> pordan30, I don't think so, but I'd love to be proved wrong.
18:06:26 <shachaf> What would a balanced tree representation of an infinite set look like?
18:07:03 <copumpkin> a trie
18:07:05 <c_wraith> if it's countably infinite, you can do it.
18:07:08 <malik> how is this done in less than a second? is haskell optimizing calculation away?  let lists = [[0,2,10000000],[1,0,-10000000]] in foldr1 intersect lists   let lists = [[0,2,10000000],[1,0,-10000000]] in foldr1 intersect lists
18:07:21 <copumpkin> shachaf: have you seen luke palmer's infinite trie?
18:07:21 <malik> sorry for pasting the code twice
18:07:36 <malik> > let lists = [[0,2,10000000],[1,0,-10000000]] in foldr1 intersect lists
18:07:38 <lambdabot>   [0]
18:07:40 <c_wraith> malik: those are 3-element lists
18:07:45 <copumpkin> http://hackage.haskell.org/package/data-inttrie-0.0.8
18:07:48 <malik> oh lol
18:07:55 * malik smacks himself
18:08:29 <shachaf> copumpkin: Yes.
18:09:38 <pordan30> according to the header, the interface for int-trie is incomplete, and implies (conversationally) that delete can't be implemented without sacrificing laziness (i assume laziness is essential to their representation)
18:12:39 <startling> Huh, I need to read up on that, then
18:14:15 <copumpkin> pordan30: that's what it exists for, so yeah
18:14:23 <malik> foldl1 S.intersection sets  takes longer than I expected. I have two sets with 1 million elements, and it takes over 2 seconds
18:14:25 <copumpkin> it's for memoizing functions from integers
18:14:42 <startling> malik, update your expectations, then
18:14:58 <copumpkin> :t foldl1'
18:15:00 <lambdabot> (a -> a -> a) -> [a] -> a
18:15:02 <copumpkin> try that
18:15:08 <copumpkin> well
18:15:13 <copumpkin> if it's two sets, you'll want to make a strict pair
18:15:15 <copumpkin> or be more careful
18:15:24 <malik> one set goes from 0 to 1 million, other from 0 to - 1 million. since sets are sorted this should be done in a nanosecond
18:16:04 <malik> or am I missing something?
18:16:14 <copumpkin> hard to say
18:16:47 <startling> :t S.intersection
18:16:49 <lambdabot> Ord a => S.Set a -> S.Set a -> S.Set a
18:17:26 <startling> > S.intersection (S.fromList [0..1000000]) (S.fromList [0..(-1000000)])
18:17:30 <lambdabot>   fromList []
18:17:36 <shachaf> So the foldr/build transformation gives better performance than the DList transformation, but doing both of them gives even better performance?
18:17:46 <startling> malik, that was pretty quick
18:17:59 <copumpkin> startling: the latter one is empty
18:18:00 <malik> your second list contains just 0
18:18:06 <malik> or yes empty
18:18:09 <startling> copumpkin: oh heh
18:18:28 <startling>  > S.intersection (S.fromList [0..1000000]) (S.fromList [(-1000000)..0])
18:18:45 <startling> [...]
18:19:07 <EvanR7> > [0..(-1),(-10000)]
18:19:09 <lambdabot>   <hint>:1:9: parse error on input `,'
18:19:09 * startling waits patiently.
18:19:14 <EvanR7> > [0...(-1),(-10000)]
18:19:15 <lambdabot>   Not in scope: `...'
18:19:16 <lambdabot>  Perhaps you meant one of these:
18:19:16 <lambdabot>    `.&.' (imported fro...
18:19:30 <malik> > S.intersection (S.fromList [0..1000000])
18:19:32 <lambdabot>   *Exception: show: No overloading for function
18:19:33 <startling> > S.intersection (S.fromList [0..1000000]) (S.fromList [(-1000000)..0])
18:19:38 <lambdabot>   mueval-core: Time limit exceeded
18:19:38 <EvanR7> > [1,3..10]
18:19:40 <startling> ah.
18:19:41 <lambdabot>   [1,3,5,7,9]
18:19:58 <EvanR7> > [0,(-1)..(-10000)]
18:20:00 <lambdabot>   [0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,-...
18:21:06 <malik> so why is it so slow? sets are sorted, it should do nothing but iterate the second list until it goes to last element, 0, which is the only element in the intersection
18:21:11 <EvanR7> 1000000 is believed to be the biggest number, but some scientists believe there may be a bigger one. 1000001?
18:21:31 <byorgey> malik: note that in order to figure out the upper and lower bounds of each set, it has to traverse both lists entirely
18:21:46 <byorgey> it has no way to know that the lists are sorted
18:21:47 <pordan30> "it's a pretty big number, but most are bigger"
18:22:03 <EvanR7> if it knew one was sorted ascending, the other descending it wouldnt have to check the whole list
18:22:05 <malik> byorgey I meant a set not a list.
18:22:09 <malik> Set is sorted
18:22:28 <malik> Set is sorted by definition. it's a binary tree
18:22:30 <byorgey> malik: I know that.  my point is that a lot of work might have to be done to construct the set in the first place.
18:22:37 <startling> that's true.
18:22:40 <byorgey> and the work might be delayed until you actually call intersect.
18:22:43 <Raynes> aeson has a type synonym, Object, that was working fine until I tried only importing some specific things. Now my code wont compile, saying "Not in scope: data constructor `Object'". I tried adding Object to the import, but that doesn't seem to have an effect.
18:22:48 <malik> byorgey that is possible
18:22:51 <startling> @let !first = S.fromList [0.1000000]
18:22:52 <lambdabot>   BangPatterns is not enabled
18:22:56 <startling> :(
18:23:46 <OceanSpray> @hoogle (a -> b) -> a -> Identity b
18:23:47 <lambdabot> Prelude ($) :: (a -> b) -> a -> b
18:23:47 <lambdabot> Data.Function ($) :: (a -> b) -> a -> b
18:23:47 <lambdabot> Prelude ($!) :: (a -> b) -> a -> b
18:23:53 <byorgey> Raynes: are you sure Object is a type synonym?
18:24:02 <Raynes> http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson.html#t:Object
18:24:14 <byorgey> ok.
18:24:23 <byorgey> Raynes: can you paste the code which is causing the error?
18:24:26 <mauke> Raynes: but that's not what you're using
18:24:32 <mauke> the error message is about a data constructor
18:24:38 <byorgey> apparently Object is getting used in a way that makes the compiler think it's a data constructor
18:24:53 <pordan30> if you force evaluation of the arguments, then evaluate intersection, it's not noticeably slow (it outputs to my console in the same amount of time that most things do)
18:25:10 <mauke> http://hackage.haskell.org/packages/archive/aeson/0.6.0.2/doc/html/Data-Aeson.html#v:Object
18:25:27 <byorgey> aHA
18:25:34 <Raynes> Bluh
18:25:37 <mauke> 😼
18:25:37 <byorgey> mauke wins
18:25:46 <Raynes> Indeed.
18:25:48 <Raynes> Thanks. <3
18:33:23 <malik> compiled with -O2, constructed the sets beforehand, and intersection of two 1 million element sets still takes several seconds despite the fact that there is only 1 element in set B that could possibly be in intersection (since all other are smaller than set A's first element)
18:34:05 <EvanR7> yeah well you need a 'sorted intersection' algorithm
18:34:22 <malik> EvanR7 isn't Data.Set.intersection supposed to be it? Sets are sorted
18:34:33 <Lemon> @pl (\f x -> Identity (f x))
18:34:33 <lambdabot> (Identity .)
18:34:40 <Lemon> @pl (\f x y -> Identity (f x y))
18:34:41 <lambdabot> ((Identity .) .)
18:34:47 <EvanR7> sorted one way
18:35:13 <dgpratt> trying to install cabal-dev: the saga continues
18:35:16 <malik> both sets are sorted the same way
18:35:29 <EvanR7> yeah so how are you going to optimize that
18:35:52 <malik> iterate set B until an element is equal to or greater than first element in set A
18:36:24 <dgpratt> so at least one problem I am having with getting cabal-dev involves a file named Paths_cabal_dev.hs
18:36:25 <EvanR7> worst case youd still check n x m things
18:36:45 <rwbarton> EvanR7: no
18:36:53 <rwbarton> malik: still requires traversing all of one of the sets
18:36:56 <dgpratt> that file gets automatically generated during the build step, but it appears that (at least on my system) it gets generated wrong
18:36:57 <malik> you don't need to check anything until element in one list is equal to or greater than first element in other set
18:36:57 <cmears> malik: are you sure you constructed the sets before properly (taking care of laziness)?
18:37:15 <malik> rwbarton yeah but that shouldn't take several seconds I think?
18:37:28 <rwbarton> well compare to some other thing that traverses the whole set
18:37:33 <dgpratt> the thing is, I cannot, for the life of me, figure out how that file is getting generated
18:38:04 <malik> cmears this is how I constructed the sets. lists = [[0,1..1000000],[1,0..(-1000000)]]; sets = map S.fromList lists
18:38:29 <dgpratt> can someone who is more familiar with the typical Haskell build process tell me how that file gets created?
18:38:30 <rwbarton> paste your actual code
18:38:32 <rwbarton> @where hpaste
18:38:32 <lambdabot> http://hpaste.org/
18:38:47 <hpaste> cmears pasted “set intersection” at http://hpaste.org/77627
18:38:50 <cmears> try that code
18:38:59 <cmears> (maybe reducing the sizes by an order of magnitude)
18:39:11 <cmears> For me that takes ages to make the sets, but intersection is fast
18:39:35 <cmears> I print the sizes to force construction of the sets
18:40:24 <pordan30> malik: how fast does this run: let !m = fromList [a million things]; let !n = fromList [another million things]; intersection m n. for me the intersection is fast, and i have an old computer.
18:40:34 <malik> here is the code. I tested it the lame way, since I just started learning haskell and I Have no idea how to profile code.  http://hpaste.org/77628
18:41:09 <malik> sorry didn't paste the whole code. check annotation
18:41:33 <rwbarton> yes, you are timing the construction of the sets also
18:41:36 <cmears> malik: the sets aren't built until after the getLine
18:41:36 <rwbarton> due to laziness
18:41:44 <malik> oh?
18:41:48 <cmears> malik: try the code I posted above
18:42:01 <malik> crazy. I forgot about laziness
18:43:34 <cmears> One must not forget laziness in haskell (:
18:43:39 <malik> getting runtime errors now.  test: getMBlocks: VirtualAlloc MEM_COMMIT failed
18:43:56 <shachaf> Grr, benchmarking.
18:44:00 <shachaf> GHC is too smart for me.
18:44:38 <cmears> malik: maybe it's really running out of memory?
18:44:40 <malik> if I make it N million elements each Set it's done instantly, which is good
18:47:17 <malik> yeah it was. firefox was leaking. :). works instantly now, even with billion elements. perfect
18:47:32 <cmears> great (:
18:47:54 <rwbarton> billion?
18:48:37 <malik> or rather 10 million
18:48:41 <rwbarton> oh okay
18:48:44 <rwbarton> that sounds more plausible
18:48:45 <malik> :)
18:49:08 <malik> so sets are created only when we call print (S.size s1), interesting
18:49:10 <shachaf> The little-known "really short scale"
18:49:50 <cmears> malik: that's just one way to force their construction
18:50:47 <CB_> hi can anyone explain what is meant by persistance in haskell?
18:51:17 <strebe> What library do you recommend for arbitrary precision arithmetic? There are quite a few for haskell. (My use case is multiplying a ~9000 digit number by a couple of numbers around 1e-276)
18:52:01 <luite> strebe: is Rational too slow?
18:52:07 <mauke> CB_: that data structures aren't modified
18:52:23 <mauke> CB_: e.g. adding an element to a set gives you a new set. the old set is still there, unchanged
18:52:55 <hpaste> uniquenick pasted “ugly code” at http://hpaste.org/77630
18:53:33 <uniquenick> how can I make that ^ less ugly?  specifically the nested cases
18:53:45 <CB_> @mauke oh ok, so a persistent data structure leaves the old one behind?
18:53:45 <lambdabot> Unknown command, try @list
18:53:47 <strebe> luite: haven't tried it; I will in a bit (I've found a workaround for the second and have a deadline, but I will check today)
18:54:56 <mauke> CB_: http://en.wikipedia.org/wiki/Persistent_data_structure
18:54:57 <CB_> mauke: oh ok, so a persistent data structure leaves the old one behind?
18:55:09 <CB_> mauke: ah thanks1
18:57:07 <shachaf> A persistent data structure, like plastic, stays around forever. Once you construct it you can't get rid of it.
18:59:17 <hpaste> “Brent Yorgey” annotated “ugly code” with “less ugly” at http://hpaste.org/77630#a77631
18:59:38 <byorgey> oh wait, that's not quite right
19:00:20 <byorgey> instead of  fmap gameLoop  it should be   fromMaybe (return ()) gameLoop
19:00:38 <byorgey> anyway, I don't know if that's really better
19:01:05 <ivanm> where does newstate come from?
19:01:12 <ivanm> is it a constant?
19:01:20 <shachaf> It's defined right there.
19:01:26 <Mortchek> I've run into the same problem and tried maybe as well, but it's still unsatisfying
19:01:31 <ivanm> duh, missed that
19:01:34 <Mortchek> +ly ugly
19:01:38 <ivanm> I'm used to when being un-indented
19:01:44 <ivanm> s/when/where/
19:02:59 <shachaf> @ty Data.Foldable.sequence_ :: Monad m => Maybe (m a) -> m ()
19:03:00 <lambdabot> Monad m => Maybe (m a) -> m ()
19:03:16 <shachaf> @ty fromMaybe (return ())
19:03:18 <lambdabot> Monad m => Maybe (m ()) -> m ()
19:04:28 <shachaf> maybe (gameLoop state) (sequence_ . inputHandler state) key
19:05:39 <ivanm> shachaf: do you want an fmap in there?
19:05:43 <ivanm> to put gameLoop in
19:06:14 <shachaf> I don't know, I was going by what byorgey said.
19:06:35 <byorgey> oh, fromMaybe was wrong too
19:06:45 <byorgey> this is what happens when you don't have a type checker
19:07:01 <ivanm> maybe (return ()) gameLoop . inputHandler state
19:07:17 <byorgey> yes, that looks better.
19:07:21 <byorgey> @type  maybe (return ())
19:07:23 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
19:07:44 <byorgey> @type Data.Foldable.mapM_
19:07:45 <lambdabot> (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
19:07:54 <ivanm> oooohhhh
19:08:00 <shachaf> @ty Data.Foldable.mapM_ :: Monad m => (a -> m ()) -> Maybe a -> m ()
19:08:02 <lambdabot> Monad m => (a -> m ()) -> Maybe a -> m ()
19:08:07 <byorgey> if the goal is to make it unreadable.
19:08:22 <shachaf> @ty mapMOf_ folded
19:08:24 <lambdabot> (Monad m, Data.Foldable.Foldable f) => (b -> m r) -> f b -> m ()
19:08:32 <ivanm> byorgey: how is that making it unreadable?
19:08:44 <ivanm> @type mapMOf_
19:08:46 <lambdabot> Monad m => Getting (Control.Lens.Internal.Sequenced m) s t a b -> (a -> m r) -> s -> m ()
19:08:55 <ivanm> oh, edwardkaleskell...
19:08:56 <ivanm> ;-)
19:09:31 <edwardk> =P
19:09:54 <shachaf> I wonder whether a specialization of traverse for Maybe would help with readbility.
19:09:55 <ski> oh, that's where "s t a b" came from, earlier
19:10:16 <edwardk> @type (^.)
19:10:17 <lambdabot> s -> Getting a s t a b -> a
19:10:23 <edwardk> there are a lot of s t a b's in lens
19:10:24 <byorgey> so violent
19:10:40 <byorgey> I would not like to be getting a stab, thank you
19:10:48 <ivanm> heh
19:11:44 <ivanm> @remember byorgey <edwardk> @type (^.) <lambdabot> s -> Getting a s t a b -> a <byorgey> I would not like to be getting a stab, thank you
19:11:44 <lambdabot> Okay.
19:11:59 <shachaf> byorgey: Would you prefer to be Getting c a b c d?
19:12:36 <uniquenick> I like the nested maybes better than nested cases anyhow, but I got lost at the mapM_ business.  should I ignore that?
19:12:39 <byorgey> cab drivers often listen to interesting music, so sure
19:13:13 <byorgey> uniquenick: yes =)
19:13:23 <ivanm> byorgey: *groan*
19:15:32 <shachaf> I bet byorgey isn't using enough lenses yet.
19:15:40 <shachaf> You learn to appreciate getting a stab, eventually.
19:16:00 <byorgey> hehehe
19:16:11 <byorgey> I am not using any lenses yet, actually
19:16:16 <byorgey> but plan to
19:16:37 <kfish> what's the mnemonic for s t a b? (what are s and t?)
19:16:46 <ivanm> are digits allowed in module names?
19:16:53 <shachaf> kfish: s could stand for "structure" or "state"
19:16:53 <ivanm> kfish: state and traversed ?
19:16:53 <ski> presumably "source" and "target" ?
19:16:55 <byorgey> ivanm: yes
19:17:00 <shachaf> Or it could be "source" and "target"
19:17:15 <ivanm> byorgey: excellent; 3ConCubic is more to the point than ThreeConCubic :p
19:17:15 <shachaf> ivanm: "traversed" doesn't make much sense -- if anything, it's s that you traverse. :-)
19:17:24 <rwbarton> probably can't start with one though
19:17:25 <byorgey> ivanm: uhhhh
19:17:26 <shachaf> ivanm: I don't think a module name can *start* with a digit.
19:17:27 <ivanm> shachaf: *shrug*
19:17:31 <ivanm> damn :(
19:17:40 <shachaf> Well, hmm, maybe it can.
19:17:46 <byorgey> ivanm: module names follow the same rules as any haskell identifier.
19:17:47 <shachaf> If it's preceded by a dot.
19:17:58 <byorgey> I don't think so.
19:18:05 <ivanm> shachaf: module names can start with a . ? or do you mean hierarchical?
19:18:12 <shachaf> Hmm, no, you're right.
19:18:17 <byorgey> to the report!
19:18:19 <shachaf> ivanm: I meant hierarchical; but it doesn't work.
19:18:24 <ivanm> byorgey: heh
19:18:28 * ski reports byorgey
19:18:34 <ivanm> *sigh* guess I"m using the boring full name then
19:19:02 <byorgey> ivanm: I've run into this too, I have Diagrams.TwoD
19:19:03 <ivanm> should possibly make it ThreeConnectedCubic rather than shortening Connected
19:19:09 <ivanm> byorgey: ahhh, yes
19:19:24 <rwbarton> I'm mildly annoyed I can't start a module name with a single quote for my 'JSON' parser
19:19:41 <ivanm> rwbarton: because you're parsing 'JSON' as opposed to JSON?
19:19:46 <byorgey> hehe, scare quotes?
19:19:49 <rwbarton> yep
19:20:11 <shachaf> What's 'JSON'?
19:20:23 <byorgey> it's like JSON
19:20:23 <ivanm> scary JSON!
19:20:25 <byorgey> but fake
19:20:25 * ski . o O ( `JSON.Ersatz' )
19:20:31 <cmears> he was on the ship called the rgo
19:20:48 <rwbarton> whatever eval('(' + str + ')') accepts
19:20:50 <ivanm> cmears: *groan*
19:21:04 <startling> rwbarton: oh man
19:21:14 <shachaf> rwbarton: You're writing a JavaScript interpreter?
19:21:30 <rwbarton> for a very small subset of javascript
19:21:39 <ivanm> bos: how do you get the bar charts in your more recent blog posts, now that criterion doesn't create images?
19:21:48 <ivanm> dammit, he quit just as I asked him...
19:21:59 <startling> rwbarton: I bet this has a fun story behind it.
19:22:56 <shachaf> So I'm trying to figure which representation of DList and foldr ends up being more efficient.
19:23:03 <luite> criterion should generate fully interactive web charts with ghcjs!
19:23:28 <shachaf> In some benchmarks, it turns out that using both transformations makes it fastest!
19:23:33 <shachaf> But I think these benchmarks are flawed.
19:24:27 <ivanm> luite: it creates interactive html pages, but it's a bit difficult to embed them into a paper...
19:24:38 <luite> ivanm: clearly you need interactive paper
19:25:25 <bgamari> tibbe, You have profiles
19:25:29 <ivanm> luite: heh
19:25:35 <tibbe> bgamari: thanks, I'm looking at it now
19:25:42 <tibbe> bgamari: your deps are really tight :)
19:25:53 <tibbe> bgamari: does the code really depend on the latest bytestring?
19:26:01 <bgamari> tibbe, nope
19:26:06 <tibbe> ok
19:26:08 <tibbe> fixing
19:27:26 <bgamari> I really don't know what the OTHER closure description is
19:29:48 <tibbe> bgamari: got it compiling
19:29:57 <bgamari> tibbe, brilliant
19:30:49 <bgamari> tibbe, cabal-install's sandbox work is still hidden as the user-facing interface has yet to be finalized?
19:31:28 <tibbe> bgamari: yes, there are secret cabal sandbox-configure cabal sandbox-build commands
19:31:31 <ivanm> tibbe: do I understand that the intention is to have sandboxing enabled by default?
19:31:44 <tibbe> ivanm: it's still up for discussiong
19:31:45 <bgamari> tibbe, I see that
19:31:55 <ivanm> tibbe: if it will be the default, will that be configurable via ~/.cabal/config ?
19:31:56 <tibbe> ivanm: otherwise you'll have to do cabal sandbox init once for each working dir
19:32:01 <ivanm> *nod*
19:32:17 <tibbe> ivanm: not decided yet, I started a discussion on cabal-devel@haskell.org
19:32:20 <ivanm> OK
19:32:40 <ivanm> atm, sandboxing would be a PITA for me since I work on a few libs that are used in various other projects I work on at the same time
19:33:01 <tibbe> ivanm: you can link the projects together with cabal sandbox add-source <dir>
19:33:09 <tibbe> ivanm: that way they will all get recompiled as needed
19:33:15 <monochrom> you need hierarchical sandboxing!
19:33:32 <tibbe> monochrom: we're looking into it, add-source gets you most of the way there though
19:33:41 * tibbe goes back to hacking.
19:33:44 <ivanm> tibbe: so if I have Bar and Baz depending on Foo, would I still need to build Foo twice?
19:33:47 <monochrom> but ghc already supports that. GHC_PACKAGE_PATH can contain many paths, not just one
19:34:08 <tibbe> ivanm: yes, if Bar and Baz have separate sandboxes
19:34:16 <tibbe> ivanm: I need to hack for a bit now
19:34:19 <ivanm> OK
19:34:23 <tibbe> monochrom: that's what we use
19:34:26 * ivanm should get back to hacking as well
19:35:11 <monochrom> GHC_PACKAGE_PATH=/for_projects_X_Y_Z:/for_projects_X_Z:/for_project_X:
19:35:32 <monochrom> and when you switch to project Z instead:
19:35:37 <monochrom> GHC_PACKAGE_PATH=/for_projects_X_Y_Z:/for_projects_X_Z:/for_project_Z:
19:35:43 <bgamari> tibbe, Thanks for having a look
19:35:54 <tibbe> bgamari: np, it's something I knew I'd have to fix anyway
19:36:01 <monochrom> some day I have to write about that in my sicp.xhtml
19:41:47 <fengshaun> ahh, just ordered RWH, should be fun!
19:42:29 <tgeeky> is there a new version of it?
19:42:44 <Nereid> last time I checked, the online version was more up-to-date
19:42:49 <Nereid> (not that it's really all that up-to-date)
19:42:53 <uniquenick> is there a standard function that does: [(x, y) | x <- [0..39], y <- [0..39]]
19:43:06 <Nereid> > liftA2 (,) [0..3] [0..3]
19:43:07 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(1,0),(1,1),(1,2),(1,3),(2,0),(2,1),(2,2),(2,3),(3...
19:43:09 <tgeeky> Nereid: it still tastes like Haskell to me (the online version, that is)
19:43:25 <tgeeky> fengshaun: but I'm sure he thanks you for your patronage!
19:44:26 <Nereid> uniquenick: ^
19:44:58 <Nereid> > liftA2 (+) [1,2,3] [10,20,30]
19:45:00 <lambdabot>   [11,21,31,12,22,32,13,23,33]
19:48:40 <rogerthealien> i get  --- gtk-0.12.4 depends on cairo-0.12.4 which failed to install --- when trying to cabal install gtk, anyone had this problem before?
19:49:07 <monochrom> need more error message
19:49:15 <rwbarton> @where hpaste
19:49:15 <lambdabot> http://hpaste.org/
19:50:24 <rogerthealien> http://hpaste.org/77632
19:50:46 <fengshaun> Nereid, oh man!  is the print version that much older?
19:50:57 <Nereid> I don't konw.
19:51:34 <Nereid> I just know that the online version has had updates since the print version was published.
19:51:36 <ivanm> I thought the RWH website was actually a bit out of date compared to the book
19:51:50 <ivanm> as they couldn't backport changes made by the publisher
19:51:51 <Nereid> I don't know what the extent of those updates are, though.
19:51:55 <tgeeky> evidence!
19:52:17 <fengshaun> well, I just didn't want to read on the computer!
19:52:20 <rogerthealien> any insight on http://hpaste.org/77632
19:52:23 <tgeeky> either way: 1) you can settle these questions if you read it twice; and 2) you are still supporting him monetarialy, in principle
19:52:25 <ivanm> is there any way of using Traversable or Foldable with Data.Tree.Tree so that each Node in the tree has a list of the labels in the path from the root?
19:52:39 <Nereid> I'm not saying you shouldn't buy it!
19:52:48 <Nereid> I love reading dead tree books.
19:52:50 <ivanm> rogerthealien: do you have the gtk2hs-buildtools package installed?
19:52:58 <rogerthealien> yes
19:53:12 <ivanm> so gtk2hsC2hs is in your PATH for example?
19:53:17 <ivanm> and we'd really need more error messages
19:53:17 <rogerthealien> yup
19:53:22 <monochrom> I'm afraid you should paste more completely
19:53:25 <ivanm> i.e. _why_ did cairo fail in the configure step?
19:53:55 <monochrom> at this stage, logically, you should not judge what's irrelevant
19:54:41 <rogerthealien> monochrom, ivanm: http://hpaste.org/77633
19:55:01 <ivanm> rogerthealien: which version of GHC are you using?
19:55:09 <rogerthealien> 7.4.1
19:55:14 <monochrom> setup: The pkg-config package cairo-pdf is required but it could not be found.
19:55:17 <ivanm> rogerthealien: read line 9
19:55:48 <ivanm> you need the cairo-pdf C library headers installed
19:56:04 <rogerthealien> ow, missed that, it's 4 a.m. here
19:57:52 <rogerthealien> monochrom, ivanm: thanks
19:57:54 <monochrom> on my ubuntu, libgtk2.0-dev libglade2-dev bring in everything
19:59:43 <mark9>  trying to understand fix. it just creates a recursive function that has itself as the first argument, correct?
20:01:12 <monochrom> see my http://www.vex.net/~trebla/haskell/fix.xhtml
20:01:29 <monochrom> your description looks off
20:02:28 <Nolatar> bota?
20:02:38 <Nereid> mark9: it takes a function and computes a fixed point of that function
20:03:04 <ski> > fix (\_ -> ())
20:03:06 <lambdabot>   ()
20:03:08 <Nereid> (specifically, the least-defined fixed point of that function)
20:03:17 <ski> (note that `()' is not a function)
20:03:26 <Nereid> but \_ -> () is
20:03:27 <mark9> monochrom:  well that's what it looks like when I write say last with it. fix (\f (x:xs) -> if null xs then x else f xs) "foobar
20:04:06 <ski> mark9 : how about writing `cycle' or `repeat' with it ?
20:04:26 <Nereid> "fix (\f (x:xs) -> if null xs then x else f xs)" computes a solution to f = \(x:xs) -> if null xs then x else f xs)
20:05:03 <Nereid> in fact, it is by definition: let f = \(x:xs) -> if null xs then x else f xs in f
20:05:44 <Nereid> @src fix
20:05:44 <lambdabot> fix f = let x = f x in x
20:05:47 <monochrom> "a recursive function that takes itself as an argument" is a type error in Haskell
20:07:34 <shachaf> fix (\x -> 1 : x) === let x = 1 : x in x
20:07:55 <ski> funnily enough, it can be done in OCaml, though
20:08:17 <shachaf> fix (\fac -> \x -> if x == 0 then 1 else x * fac (x - 1)) === let fac = \x -> if x == 0 then 1 else x * fac (x - 1) in fac
20:08:18 <ivanm> oh? why can OCaml do it?
20:08:30 <shachaf> It's easy to see when you inline it.
20:08:51 <ski> ivanm : because it supports cyclic types (it's needed for cyclic object types)
20:09:06 <ivanm> what are cyclic object types?
20:09:20 <ski> however, normally cycles have to go through at least one object type. to allow it generally, you need to say `ocaml -rectypes'
20:10:50 <ski> ivanm : something like `self where self = { someMethod :: Blah , binaryMethod :: self -> Bleh , cloningMethod :: self }' e.g.
20:11:13 <ski> (not actual OCaml syntax. i forget the exact syntax for object types)
20:11:14 <shachaf> OCaml supports equirecursive types?
20:11:20 <ski> yes
20:11:20 <ivanm> hmmmm....
20:11:43 <ski> but it's disabled by default, except for when the cycles go through at least one object type
20:12:23 <monochrom> if you say, in "fix (\f -> ...)", we pass the created function into the \f, then that's right, but that is not "the created function takes itself". that is "the created function is given to (\f -> ...)". and since (\f -> ...) is the parameter given to fix, you're looking at "the created function is given to the parameter given to fix"
20:12:40 <monochrom> that is, as opposed to "the created function takes whatever"
20:12:53 <uniquenick> can anyone explain how the type signature of (***) lets me use it instead of "(x + fst pos, y + snd pos)"?
20:12:54 <fengshaun> Nereid, dead tree books are the best!
20:12:59 <fengshaun> I feel like i'm a bit late
20:13:27 <ski> `fix' is a factory function that given a function factory makes a function !
20:13:32 <Nereid> uniquenick: ((+ fst pos) *** (+ snd pos)) (x,y)
20:13:33 <ski> quick, someone Javaify that !
20:13:34 <Nereid> like that?
20:13:38 <Nereid> or wait.
20:13:39 <Nereid> I'm dumb.
20:13:43 <monochrom> and if you say, the correct natural language description is unreadable, that's exactly right, the point is screw natural language
20:13:46 <Nereid> ((x+) *** (y+)) pos
20:13:47 <Nereid> like that
20:14:23 <Nereid> > ((x+) *** (y+)) (a,b)
20:14:24 <lambdabot>   (x + a,y + b)
20:14:28 <monochrom> and the incorrect natural language description is readable but incorrect and unreliable. it's most suitable for lying.
20:14:54 <uniquenick> how do I get to that from the type signature "a b c -> a b' c' -> a (b, b') (c, c')" though?  all the Control.Arrow functions have type signatures that confuse me
20:15:28 <rwbarton> a = (->)
20:16:07 <gertc> do i want conduit sourceHandle or sourceIOHandle for websockets and why?
20:17:15 <manju> How to pack [Char] to ByteString ?
20:17:25 <manju> B.pack "1024 1024"
20:18:00 <manju> doesn't work, it says it expects type [GHC.Word.Word8] not [Char], how to fix it ?
20:18:09 <parcs`> import Data.ByteString.Char8
20:18:18 <parcs`> instead of Data.ByteString
20:18:58 <monochrom> if the [Char] is "λα", what do you want that "pack" as?
20:19:21 <manju> parcs`, ah...thanks
20:19:32 <monochrom> oh well
20:19:32 <Nereid> why "Char8" anyway?
20:19:49 <monochrom> because Char8 is anti-internationalization
20:19:55 <Nereid> oh I see.
20:19:59 <Nereid> it still holds strings of Word8s.
20:20:00 <manju> monochrom, A function of mine accepts ByteString, it works when I read from file. But not while testing with ghci.
20:20:29 <Nereid> "All Chars will be truncated to 8 bits." make sure you are really okay with this.
20:20:48 <shachaf> manju: Listen to these people carefully.
20:20:57 <monochrom> sorry, I don't understand your answer
20:21:14 <manju> shachaf, ok
20:21:20 <luite> hm what's a good alternative? i usually encode stuff with the text package (or set decoding when reading a file), but that would require an unnecessary conversion here
20:21:42 <manju> No, my file currently consists of only alpha numeric characters.
20:22:01 <Nereid> if everything is ASCII then it's fine.
20:22:02 <monochrom> I ask, if the [Char] is "λα", what do you want that "pack" as? A logical answer, would be either "don't worry about λα" or "I want that to become ...". I am not seeing a logical answer.
20:22:16 <shachaf> Nereid: But not everything is ASCII.
20:22:25 <Nereid> you know what I mean.
20:22:31 <tibbe> I need a strict fmap!
20:22:37 <shachaf> For example, "λα" isn't ASCII.
20:22:42 <shachaf> tibbe: For what?
20:22:49 <shachaf> Strict in what?
20:22:51 <Nereid> what the heck would it do?
20:23:08 <tibbe> shachaf: well, I guess I need a strict map for Vector
20:23:13 <tibbe> shachaf: I have thunks everywhere
20:23:15 <manju> monochrom, Are you asking me ?
20:23:18 <Nereid> that's a better question.
20:23:39 <manju> monochrom, Because I don't understand the question.
20:23:40 <shachaf> OK, so strict in the result of the function.
20:23:58 * shachaf needed a strict-in-the-function fmap recently, but that's a pretty unusual case. :-)
20:24:27 <manju> How to convert something which is [a,b] to (a,b) ?
20:24:36 <donri> my god, it's full of thunks
20:24:38 <shachaf> edwardk: Does lens have something for strict traversals?
20:24:40 <Nereid> manju: do you care what happens to lists of other lengths?
20:24:45 <edwardk> no
20:24:49 <ski> > (\[a,b] -> (a,b)) "cd"
20:24:50 <lambdabot>   ('c','d')
20:24:59 <manju> Nereid, No, in this case I get only 2 element list.
20:25:31 <shachaf> Hmm, you could probably strictify a traversal, though.
20:25:32 <Nereid> one hopes that you could structure your code better such that you don't have to do this.
20:25:35 <manju> I am reading a file format, I can guarantee that the line contains something which is only a list which is 2 things.
20:25:52 <Nereid> ok, so read 2 things, rather than reading a list.
20:26:06 <donri> > (,) <$> (!!0) <*> (!!1) $ "cd"
20:26:09 <lambdabot>   ('c','d')
20:26:32 <donri> oh god what have i done
20:26:36 <Nereid> disgusting
20:26:37 <manju> Nereid, ok
20:27:06 <manju> donri, I am not using that, cause I'll figure out, what I wrote later. :-)
20:27:12 <manju> I'll try something like
20:27:20 <Nereid> am I the only one who would rather write "liftA2 f x y" than "f <$> x <*> y"?
20:27:43 <Nereid> > liftA2 (,) (!!0) (!!1) "cd"
20:27:44 <lambdabot>   ('c','d')
20:27:51 <ski> Nereid : i do too
20:28:10 <donri> nah, that's almost readable
20:28:16 <Nereid> damn
20:28:22 * ski also prefers writing `ap' to `(<*>)'
20:28:31 <edwardk> shachaf: i was trying to find a nice "Strict" Applicative that did the right thing, so you can make a lens transformer that strictifies that way
20:28:37 <Nereid> ski: infix or prefix?
20:28:42 <ski> both
20:28:46 <Nereid> although ap only works for Monads
20:29:06 <ski> and `(<*>)' only works for instances of `Applicative'
20:29:16 <edwardk> there are a few ways that it can be done, by e.g. leaning on Bazaar exposing the individual values, etc.
20:29:16 <Nereid> but every instance of Monad should also be an instance of Applicative
20:29:17 <donri> > (return (,) `ap` (!!0) `ap` (!!1)) "cd"
20:29:19 <lambdabot>   ('c','d')
20:29:52 <ski> imho, `<*>' isn't a good name for it
20:30:04 <shachaf> By the way, should ins/outs be exported (from .Internal or something)?
20:30:21 <shachaf> Well, ins is just toListOf bazaar.
20:30:22 <edwardk> shachaf: another model might be to add something like 'before' to https://github.com/ekmett/lens/blob/master/src/Control/Parallel/Strategies/Lens.hs
20:30:52 <edwardk> i was trying to avoid the export of ins/outs, and encourage the use of partsOf and unsafePartsOf if you need access to those bits
20:31:13 <edwardk> that is a much more palatable end-user-visible combinator
20:31:16 <shachaf> Fair enough.
20:31:42 <donri> @pl (\[a,b] -> (a,b))
20:31:43 <lambdabot> (line 1, column 3):
20:31:43 <lambdabot> unexpected "["
20:31:43 <lambdabot> expecting pattern
20:31:51 <donri> @pl \[a,b] -> (a,b)
20:31:51 <lambdabot> (line 1, column 2):
20:31:52 <lambdabot> unexpected "["
20:31:52 <lambdabot> expecting pattern
20:31:54 <donri> :(
20:32:12 <edwardk> donri: @pl doesn't pattern match
20:32:30 <shachaf> > unsafePartsOf both .~ "ab" $ (2,3)
20:32:32 <edwardk> @pl \xs -> (head xs, head (head xs))
20:32:32 <lambdabot>   ('a','b')
20:32:33 <lambdabot> liftM2 (,) head (head . head)
20:32:41 <shachaf> > unsafePartsOf both .~ "a" $ (2,3)
20:32:43 <lambdabot>   ('a',*Exception: src/Control/Lens/Plated.hs:843:1-29: Irrefutable pattern f...
20:32:55 <shachaf> That error used to be nicer.
20:33:05 <edwardk> feel free to swap in a nicer error message
20:33:11 <shachaf> Yep.
20:33:16 <Nereid> > (!!0) &&& (!!1) $ "cd"
20:33:18 <lambdabot>   ('c','d')
20:33:24 <shachaf> Was there a reason for the irrefutable pattern match in unsafeCons?
20:33:25 <ski> @type head &&& head . tail
20:33:26 <lambdabot> [c'] -> (c', c')
20:34:00 <edwardk> @pl \xs -> (head xs, head (tail xs))
20:34:01 <lambdabot> liftM2 (,) head (head . tail)
20:34:13 <edwardk> but yeah head &&& head . tail is much nicer
20:34:21 <donri> guys these are way too readable
20:34:25 <Nereid> lol
20:34:30 <donri> requesting insane lens version plz
20:34:36 <shachaf> (\[x,y] -> (x,y)) . take 2
20:34:50 <shachaf> (\(x:y:_) -> (x,y)), for that matter
20:34:58 <shachaf> Oh, hmm, that's where we started.
20:35:00 <edwardk> > [1,2]^.to (head &&& head . tail)
20:35:02 <lambdabot>   (1,2)
20:35:04 <edwardk> =)
20:35:07 <donri> cheating ;)
20:35:58 <shachaf> @ty flip (set (unsafePartsOf both)) ((),()
20:35:59 <lambdabot> parse error (possibly incorrect indentation)
20:36:09 <shachaf> > flip (set (unsafePartsOf both)) ((),()) "ab"
20:36:10 <lambdabot>   ('a','b')
20:36:15 <shachaf> There you go. Lensy enough?
20:36:23 <donri> awesome!
20:36:35 <donri> even got "unsafe" in it. perfection.
20:36:46 <edwardk> unsafePartsOf both .~ "ab" $ ((),())
20:36:46 <monochrom> haha
20:36:48 <edwardk> > unsafePartsOf both .~ "ab" $ ((),())
20:36:50 <lambdabot>   ('a','b')
20:36:51 <shachaf> If you want the safe version, you have to give it defaults for when the list isn't long enough.
20:37:07 <edwardk> > partsOf both .~ "ab" $ "cd"
20:37:07 <shachaf> > partsOf both .~ "a" $ ('x','y')
20:37:09 <lambdabot>   can't find file: L.hs
20:37:09 <lambdabot>   Couldn't match expected type `(GHC.Types.Char, GHC.Types.Char)'
20:37:09 <lambdabot>            ...
20:37:13 <edwardk> > partsOf both .~ "ab" $ ('c','d')
20:37:16 <lambdabot>   ('a','b')
20:37:21 <donri> :t def
20:37:23 <lambdabot>     Not in scope: `def'
20:37:23 <lambdabot>     Perhaps you meant one of these:
20:37:23 <lambdabot>       `dff' (imported from Data.Graph),
20:37:30 <donri> :t Data.Default.def
20:37:33 <lambdabot> Couldn't find qualified module.
20:38:01 <shachaf> > partsOf both .~ "a" $ ('x','y') -- will fill in as much of the structure as it can
20:38:02 <lambdabot>   ('a','y')
20:38:31 * shachaf wonders what partsOf is doing in .Plated
20:38:44 <shachaf> And elementOf, for that matter. I guess it's just a matter of avoiding cross-module recursion?
20:38:46 <donri> > ((),())%partsOf both.
20:38:48 <lambdabot>   <hint>:1:22: parse error (possibly incorrect indentation)
20:38:52 <donri> > ((),())%partsOf both.~"cd"
20:38:54 <edwardk> shachaf: partsOf fits the way the old uniplate combinator worked
20:38:54 <rwbarton> :t replicateOf
20:38:55 <lambdabot>   Couldn't match expected type `()' with actual type `GHC.Types.Char'
20:38:56 <lambdabot>     Not in scope: `replicateOf'
20:38:56 <lambdabot>     Perhaps you meant one of these:
20:38:56 <lambdabot>       `replicate' (imported from Data.List),
20:39:05 <copumpkin> > partsOf both .~ "ab" $ ('x','y')
20:39:07 <lambdabot>   ('a','b')
20:39:09 <copumpkin> wtf :P
20:39:12 <copumpkin> > partsOf both .~ "abc" $ ('x','y')
20:39:15 <lambdabot>   ('a','b')
20:39:19 <donri> > (undefined,undefined)%partsOf both.~"cd"
20:39:22 <lambdabot>   ('c','d')
20:39:37 <edwardk> partsOf takes a traversal and gives you a lens that views the list of its targets, and expects back a list of the same length
20:39:56 <edwardk> if you give it too many entries or not enough it violates the lens but doesn't crash
20:40:06 <shachaf> > partsOf (both.traverse) .~ "norway" $ ("hello","lenses!")
20:40:08 <lambdabot>   ("norwa","yenses!")
20:40:09 <edwardk> unsafeParts of requires exactly as many elements, but can do type changing assignment
20:40:28 <shachaf> Well, it just requires at least as many elements. :-)
20:40:37 <edwardk> sure
20:41:36 <shachaf> reallyUnsafePartsOf should unsafeCoerce
20:41:42 <edwardk> heh
20:42:08 <mark9> .
20:44:03 <shachaf> Unfortunately you can't use unsafePartsOf to build up a tuple without having a boilerplate tuple like ((),())
20:44:26 <mark9> where is my error in expanding fix? http://hpaste.org/77634
20:44:30 <shachaf> edwardk: Can anything interesting be done with traversals like both where you statically know the number of elements?
20:45:18 <shachaf> > let mark9 = (\f (x:xs) -> if null xs then x else f xs) in fix mark9 "abc"
20:45:20 <lambdabot>   'c'
20:45:36 <shachaf> > let mark9 = (\f (x:xs) -> if null xs then x else f xs) in mark9 (mark9 (mark9 (mark9 undefined))) "abc"
20:45:37 <lambdabot>   'c'
20:45:51 <shachaf> mark9: The expansion of "fix f" is "f (f (f (f (f (f ..."
20:45:53 <edwardk> shachaf: in theory if you know its >=1 element .e.g. like a "Traversable1" to use the term from semigroupoids, then you can reduce it with a semigroup, Apply or Bind instance
20:46:25 <shachaf> edwardk: Right, but I mean one where you statically know exactly how many elements there are, so you can use "outs" without having an initial structure.
20:46:29 <edwardk> containers that have exactly n elements are often representable.
20:46:56 <shachaf> Is there a type class like Applicative that has only <*>, no pure?
20:47:12 <shachaf> Maybe that should be part of the One True Hierarchy.
20:47:14 <edwardk> Data.Functor.Apply.Apply
20:47:22 <edwardk> its in semigroupoids
20:47:29 <pordan30> a computation in a (deterministic) state transition system can be modeled by a list of states. embedded in a zipper, the focused element would be the current state and the traversals would be transitions between states. this gives a convenient way to traverse a computation stepwise. if the states have a monadic context, then the zipper must focus on the value in that context, so that traversing the zipper entails executing monadic
20:47:29 <pordan30>  actions. this implies (to me) that a monadic interface to the zipper would be useful, something like a "zipper transformer." am i off base, or has anything like this been implemented?
20:47:31 <shachaf> Ah.
20:48:43 <pordan30> mark9: you can think of fix like: fix f = f (fix f). if you substitute (fix f) for the outer lambda, then you'll substitute in the function body, and subsequently the remaining arguments.
20:49:16 <shachaf> So if we had Semigroup => Monoid and Functor => Apply => Applicative then we could talk about nonempty traversals.
20:51:44 <edwardk> yep
20:51:44 <edwardk> but as it stands non-empty traversals would have to have a cast involved or i'd have uglier constraints
20:52:04 <Nereid> I don't like non-unital semigroups/rings. :(
20:52:13 <edwardk> with Pointed you could have 'partial' lenses in a more principled fashion where you can only have 0 or 1.
20:52:36 * copumpkin hands Nereid max/min
20:52:43 <edwardk> in practice this isn't such a big deal, since you can always use Last or First, which is what ^? does
20:52:45 * Nereid hands copumpkin infinity/-infinity
20:52:58 * copumpkin hands Nereid types that don't have such a thing
20:53:05 * Nereid adjoins them
20:53:09 * edwardk hands Nereid "Integer"
20:53:12 * copumpkin detaches them
20:54:27 <Nereid> you look at Hungerford's graduate algebra text (he deals with non-unital rings) and see all these awkward conditions on all the theorems like RR = R and crap.
20:54:27 <mark9> i think i got it finally
20:54:50 <mark9> > (\f (x:xs) -> if null xs then x else f xs) ((\f (x:xs) -> if null xs then x else f xs) undefined) "ab"
20:54:52 <lambdabot>   'b'
20:55:12 <edwardk> Nereid: on the other hand you wind up with awkward conditions for how to handle all these attached elements that aren't logically part of the type
20:55:31 <edwardk> i have lots of things that give me a semigroupoid where i _can't_ attach a unit.
20:55:42 <Nereid> I'm not being totally serious.
20:55:46 <edwardk> many ComonadApply instances can't be made Applicative
20:56:01 <edwardk> so the applicative-like structure for them is only associative, it has no unit
20:56:21 <mark9> thanks all
20:57:05 <shachaf> What's a good name for unconsWithDefault :: a -> [a] -> (a,[a])?
20:57:18 <ski> > foldr (const (\f (x:xs) -> if null xs then x else f xs)) undefined `join` "ab"
20:57:19 <lambdabot>   'b'
20:57:25 <edwardk> fromMaybe x . uncons xs =)
20:57:42 <edwardk> or i guess thats uglier
20:57:48 <edwardk> fromMaybe (x,[]) . uncons xs
20:58:18 <crdueck> :t uncons
20:58:20 <lambdabot>     Not in scope: `uncons'
20:58:20 <lambdabot>     Perhaps you meant one of these:
20:58:20 <lambdabot>       `BS.uncons' (imported from Data.ByteString),
20:59:52 <shachaf> outs = evalState . bazaar (state . unconsWithDefault)
20:59:56 <shachaf> unsafeOuts = evalState . bazaar (\_ -> state (unconsWithDefault (error "unsafePartsOf: not enough elements were supplied")))
21:00:01 <shachaf> Something like that, anyway.
21:00:35 <mm_freak> btw, what's the difference between bazaars and nested stores?
21:00:47 <shachaf> Nested stores?
21:01:12 <lucca> decons
21:02:11 <mm_freak> shachaf: StoreT i (Store j)
21:02:18 <shachaf> I think this unsafeOuts is slightly lazier than the other one but not in a way that matters.
21:02:54 <shachaf> mm_freak: I'm not sure what StoreT is, but it sounds like that still only refers to one or two values or something along those lines.
21:03:15 <shachaf> What's the definition of Store? data Store a t = Store a (a -> t)?
21:03:42 <mm_freak> shachaf: according to edwardk a bazaar can be thought of as a store of stores, which to me sounds like StoreT nesting
21:03:48 <mm_freak> yeah, that's store
21:04:14 <edwardk> well, its more like a store with a bunch of states.
21:04:23 <shachaf> mm_freak: Where Store has exactly one value :: a + a function :: a -> t, a Bazaar has N values :: a + a function :: Vect N a _> t
21:04:41 <shachaf> That was a confusing phrasing.
21:05:16 <shachaf> mm_freak: Bazaarish a t = Bazaarish [a] ([a] -> t), where the two lists must have the same length.
21:05:33 <shachaf> (I.e. it gives you N values, you give it N values.)
21:05:41 <mm_freak> data Bazaar s a = forall n. Bazaar (Vec n s) (Vec n s -> a)
21:05:44 <mm_freak> something like that?
21:05:49 <shachaf> Yep.
21:05:52 <edwardk> mm_freak: yep
21:06:02 <edwardk> you can encode it several ways
21:06:05 <mm_freak> i see
21:06:33 <edwardk> newtype Bazaar c d b = Bazaar { runBazaar :: forall f. Applicative f => (c -> f d) -> f b }  -- is one way
21:06:38 <mm_freak> then i wonder, now is a bazaar more general than a store?
21:06:47 <mm_freak> s/now/how/
21:06:47 <shachaf> http://hackage.haskell.org/packages/archive/lens/3.2/doc/html/Control-Lens-Internal.html#t:Bazaar also has a bit of documentation. :-)
21:06:54 <edwardk> data Bazaar c d b = Buy b | Trade (Bazaar c d (d -> b)) c
21:07:17 <edwardk> well, lets look at it this way. see that newtype version?
21:07:27 <mm_freak> yeah
21:07:38 <edwardk> newtype Store c d b = Store { runStore :: forall f. Functor f => (c -> f d) -> f b }
21:07:55 <mm_freak> i don't get it (which my be related to the fact that i don't really know how those new lenses work)
21:07:56 <edwardk> its the same comonad as store, just with Applicative instead of Functor
21:08:39 <edwardk> then you can derive the new lenses by translating from the definition of Store used in data-lens to the definition of Store I just gave
21:09:10 <mm_freak> could you give me a real usage example in words?
21:09:24 <mm_freak> just a small summary, something that is nicer to implement using a bazaar than a store
21:09:41 <shachaf> A usage example of Bazaar? It's only used internally in lens.
21:09:59 <edwardk> its used all over internally in lens in places where i can't use anything else
21:10:20 <mm_freak> will i benefit from Bazaar as a non-lens-implementor? =)
21:10:33 <shachaf> Probably not, but you'll definitely benefit from Traversal.
21:10:34 <edwardk> cloneLens uses Store. cloneTraversal uses Bazaar
21:10:41 <shachaf> Traversal : Lens = Bazaar : Store
21:10:56 <mm_freak> ok, that starts to make sense
21:11:15 <mm_freak> so a bazaar is really about traversals rather than individual values
21:11:29 <mm_freak> and that's why you need Applicative
21:11:36 <shachaf> Well, a "traversal" is just a lens that refers to N values.
21:11:49 <mm_freak> yeah
21:11:52 <edwardk> yes
21:12:08 <mm_freak> so bazaar : store = fold : index
21:12:24 <copumpkin> it sometimes plays to fool around with the bazaar type
21:12:29 <edwardk> i don't quite grok the fold : index analogy
21:12:30 <copumpkin> *pays
21:12:33 <shachaf> What are Fold and Index?
21:12:46 <copumpkin> it makes the type even more inflexible if you make the inner type existential
21:13:02 <copumpkin> it's less interesting, but it forces you to see what you can do with it
21:13:09 <mm_freak> a bazaar relates to a store as a (bird) fold relates to indexing an element
21:13:15 <shachaf> copumpkin: The inner type?
21:13:27 <shachaf> As in (exists a. Bazaar a a t)?
21:13:37 <copumpkin> nah, the domain of the nested function
21:13:52 <copumpkin> it's a lot less interesting as far as types go
21:13:58 <copumpkin> but it might help inform the shape of the final thing
21:14:08 <shachaf> Wait, what does that look like?
21:14:51 <copumpkin> data Moo a = Done a | forall b. Moar b (Moo (b -> a))
21:15:15 <shachaf> Oh, I see, so it varies at each cons.
21:15:16 <edwardk> that existential is key to keep you from shuffling the elements, etc.
21:15:20 <copumpkin> yeah
21:15:23 <shachaf> That *really* doesn't let you do anything with it.
21:15:26 <copumpkin> yeah
21:15:37 <copumpkin> it's equivalent to a and a natural, if you disallow infinite things
21:15:59 <shachaf> Yep.
21:16:15 <copumpkin> my point is that it just forces you to see how the values you're carrying pair up with the function's domain
21:16:24 <edwardk> and its effectively a fancy version of a partiality monad if you do allow for infinite things
21:16:36 <copumpkin> yup
21:17:53 <tac> existentials are aweeeesome
21:18:00 <tac> (even though Haskell has meh support for them)
21:18:20 <shachaf> Haskell has no support for them.
21:18:22 <shachaf> UHC has first-class existentials, though!
21:18:29 <mm_freak> back to the real world:  is there a (really) fast create-once Set/Map on hackage?
21:18:40 <tac> shachaf: oh yeah? link to explanation of how it works in UHC?
21:19:19 <shachaf> It's (exists a. ...), just like it should be.
21:19:31 <shachaf> Doesn't support classes, though.
21:19:34 <copumpkin> mm_freak: http://hackage.haskell.org/package/PerfectHash maybe?
21:19:41 <tac> shachaf: noooooooooo
21:20:00 <tac> Is class support planned?
21:20:13 <shachaf> I don't know.
21:20:18 <shachaf> Type classes are overrated anyway.
21:20:21 <tac> they have so much synergy with existentials...
21:20:40 <tac> I don't think they're overrated. But abused? Definitely.
21:20:42 <shachaf> Most uses of existentials with type classes are an abuse of type classes.
21:20:46 <mm_freak> copumpkin: the conversions between Int/Integer and ByteString will kill my performance…  i guess i'll have to implement that myself
21:20:51 <mm_freak> but thanks
21:22:25 <Jafet> Just create all your integers from storable
21:22:28 * hackagebot ListLike 3.1.7.1 - Generic support for list-like structures  http://hackage.haskell.org/package/ListLike-3.1.7.1 (JohnLato)
21:22:30 * hackagebot listlike-instances 0.2.3.1 - Extra instances of the ListLike class  http://hackage.haskell.org/package/listlike-instances-0.2.3.1 (JohnLato)
21:22:48 <mm_freak> Jafet: and do arithmetic how?
21:23:48 <Jafet> Using arithmetic operators
21:24:52 <mm_freak> Jafet: the keys come from arithmetic
21:24:59 <mm_freak> ah, i get what you mean
21:25:32 <mm_freak> still going through C is probably a bad idea
21:26:05 <shachaf> Oops, I used the wrong tense for committing.
21:26:07 <shachaf> Ah well.
21:26:36 <mm_freak> commit message:  "I will fix bug #1234."
21:27:26 <shachaf> Hah, I wonder whether GitHub's auto-bug-closing heuristic would detect that.
21:27:42 <mm_freak> hehe
21:27:50 <shachaf> "The situation is even worse now. I hope someone closes #1234." --> closes #1234
21:28:55 <mm_freak> like every day?  like a smoker who stops smoking
21:30:13 <shachaf> @ty \re un f s -> re s <$> f (un s)
21:30:15 <lambdabot> Functor f => (t1 -> a -> b) -> (t1 -> t) -> (t -> f a) -> t1 -> f b
21:30:21 <shachaf> Oh, that's just lens, isn't it.
21:30:22 <shachaf> @ty lens
21:30:25 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
21:30:33 <edwardk> =)
21:33:55 <edwardk> shachaf: looks good
21:35:50 <Jafet> @src lens
21:35:50 <lambdabot> Source not found. You untyped fool!
21:37:40 <shachaf> @ty set (partsOf id) . maybeToList
21:37:42 <lambdabot> Maybe t -> t -> t
21:37:46 <shachaf> Exciting.
21:38:13 <gertc> Why does he somtimes put Protocol p => and somtime he does not? https://github.com/jaspervdj/websockets/blob/master/src/Network/WebSockets/Monad.hs
21:38:18 <edwardk> cute
21:38:44 <Nereid> @ty partsOf
21:38:45 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
21:38:49 <edwardk> gertc: if the combinator doesn't need the constraint, why put it on?
21:38:58 <gertc> example send and sendSink
21:39:11 <edwardk> ("hello","world")^.partsOf both
21:39:15 <edwardk> > ("hello","world")^.partsOf both
21:39:17 <lambdabot>   ["hello","world"]
21:39:22 <gertc> ok but we are talking about the same p right?
21:39:25 <edwardk> > ("hello","world")^.both
21:39:27 <lambdabot>   "helloworld"
21:39:40 <shachaf> > ("hello","world")^..both
21:39:42 <lambdabot>   ["hello","world"]
21:39:51 <shachaf> The read part of partsOf is just toListOf
21:39:56 <simpson> gertc: I don't understand why any of that, really.
21:39:58 <edwardk> yes.
21:40:02 <Nereid> hmm
21:40:05 <simpson> But then again I don't understand why people WebSockets.
21:40:14 <gertc> it is not like the one p is a protocol and the other p a patato?
21:40:28 <shachaf> gertc: Presumably it's the same p, yes.
21:40:29 <ski> @hoogle (s -> (a,b -> t)) -> (a -> f b) -> (s -> f t)
21:40:29 <Nereid> @ty toListOf
21:40:29 <lambdabot> No results found
21:40:31 <simpson> gertc: He probably didn't actually need the constraint there.
21:40:31 <lambdabot> Getting [a] s t a b -> s -> [a]
21:40:36 <simpson> gertc: And so he omitted it.
21:40:49 <Nereid> @ty set . partsOf
21:40:50 <lambdabot> LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> [a] -> s -> t
21:40:55 <Nereid> hmm ok
21:40:57 <gertc> ok thx
21:41:07 <edwardk> gertc: whenever you put Foo a => … you are making the program do work to pass a dictionary in. if you don't use that dictionary you are constraining yourself to run slower than you other wise could, and some combinators may work without that constraint, so you are constraining yourself not to have your code work in more general situations.
21:41:16 <shachaf> (LensLike (Control.Lens.Internal.Bazaar a a) s t a a) is ugly. :-(
21:41:22 <edwardk> shachaf: i admit
21:41:33 <Nereid> > "abcdef" % partsOf traverse .~ "xyz"
21:41:35 <lambdabot>   "xyzdef"
21:41:41 <Nereid> I think I get it.
21:42:02 <edwardk> partsOf expects you to replace the targets with a list, ideally of the same length, but it degrades gracefully
21:42:03 <gertc> ok
21:42:08 <simpson> Some days I think, "Y'know, maybe there are too many lens combinators." But then I think, "Nah, if given the choice between this and ($$.^.^~~$$) from conduits, I'd totally choose lens."
21:42:13 <shachaf> > ("abcdef","ghijkl") % partsOf (both.traverse) .~ "hi there"
21:42:16 <lambdabot>   ("hi the","reijkl")
21:42:18 <edwardk> simpson: =)
21:42:29 <Nereid> shachaf: that is so cute.
21:43:08 <shachaf> > ("abcdef","ghijkl") % partsOf (backwards (both.traverse)) .~ "hi there"
21:43:10 <lambdabot>   ("abcder","eht ih")
21:43:11 <edwardk> > ("hello","world") % partsOf (both.traverse) %~ reverse
21:43:13 <lambdabot>   ("dlrow","olleh")
21:43:29 <Nereid> > ("hi","world") % partsOf (both.traverse) %~ reverse
21:43:31 <lambdabot>   ("dl","rowih")
21:43:32 <Nereid> :V
21:43:59 <Nereid> ["a","bc","def"] % partsOf (traverse.traverse) %~ reverse
21:44:01 <Nereid> > ["a","bc","def"] % partsOf (traverse.traverse) %~ reverse
21:44:03 <lambdabot>   ["f","ed","cba"]
21:44:06 <edwardk> > ("hello","world") % partsOf (both.traverse) %~ sort
21:44:08 <lambdabot>   ("dehll","loorw")
21:44:09 <simpson> edwardk: Seriously, how do people memorize ($$), ($$=), (=$$), ($=$), ($==$$), etc.?
21:44:26 <edwardk> simpson: i have no idea. i tried to go with fewer crazy operators in machines ;)
21:44:50 <shachaf> Note how edwardk was careful not to say "less crazy operators".
21:44:55 <simpson> edwardk: I haven't read through machines yet. I wonder if it'll be useful.
21:45:02 <ski> now do `onLetters' by lenses
21:45:07 <simpson> Er, useful to what I have in mind. I'm sure it's useful for you.
21:45:14 <edwardk> ski: onLetters?
21:45:16 <ski> > onLetters reverse "Eva, can i stab bats in a cave?"
21:45:18 <lambdabot>   "Eva, can i stab bats in a cave?"
21:45:29 <shachaf> @ty onLetters
21:45:31 <lambdabot> ([Char] -> [Char]) -> String -> String
21:45:35 <edwardk> ski: ah. gets a little tricky. because thats not a legal traversal
21:45:42 <Nereid> > onLetters reverse "Abcde"
21:45:44 <lambdabot>   "Edcba"
21:45:53 <ski> > onLetters reverse "ah. gets a little tricky. because thats not a legal traversal"
21:45:55 <lambdabot>   "la. srev a rtlage latons. tahtesu aceby kci r teltt ilastegha"
21:46:15 <Nereid> where's onLetters from?
21:46:22 <shachaf> From @let, I assume.
21:46:26 <ski> i defined it yesterday
21:46:31 * ski nods
21:46:48 <shachaf> It's a legal traversal if your target list has the right number of letters, right?
21:46:49 <edwardk> @type Control.Lens.indices
21:46:51 <lambdabot> (Applicative f1, FoldableWithIndex i f, Gettable f1) => (i -> f1 i) -> f a -> f1 (f a)
21:46:57 <Ghoul> edwardk: Hey
21:47:06 <Ghoul> What's the name of that paper on spineless optimisation somethingrather
21:47:07 <Ghoul> <_<
21:47:17 <johnw> edwardk: can lens traversals use filtering predicates?
21:47:37 <edwardk> johnw: not legally, no. you can filter on position, or meta-data, but not content
21:47:47 <edwardk> otherwise if you replace it with something that fails your filter you violate the law
21:47:53 <johnw> can i do it illegally?
21:47:56 <edwardk> :t filtered
21:47:57 <lambdabot> Applicative f => (a -> Bool) -> SimpleLensLike f a a
21:48:17 <shachaf> > over (traverse.filtered even) (+1) [1,2,3,4,5,6]
21:48:18 <edwardk> filtered will 'kinda' work like a traversal when you use it in that position, but its illegal and intended for use with folds
21:48:19 <lambdabot>   [1,3,3,5,5,7]
21:48:40 <johnw> "Hello, World" ^. traverse . filtered isAlpha is not a Monoid
21:48:57 <johnw> i'm missing something to get back a list...
21:49:03 <edwardk> > partsOf (traverse.filtered isAlpha) %~ reverse $ "how am I doing"
21:49:05 <lambdabot>   "gni od I mawoh"
21:49:07 <pordan30> how to make a fast curry?
21:49:10 <johnw> ah, partsOf
21:49:21 <edwardk> thats a pretty evil abuse ;)
21:49:30 <otters> :t partsOf
21:49:32 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
21:49:38 <johnw> > "Hello, World" % partsOf (traverse . filtered isAlpha) .~ "Hey"
21:49:41 <lambdabot>   "Heylo, World"
21:49:45 <johnw> that's really cool though!
21:49:54 <otters> That's like totally efficient right
21:49:58 <ski> edwardk : only casing missing now :)
21:49:59 <Nereid> how about one that preserves case?
21:50:01 <Nereid> :p
21:50:07 <edwardk> ski: heh
21:50:18 <shachaf> That sounds evil.
21:50:21 <Nereid> @ty foldMap
21:50:23 <lambdabot>     Not in scope: `foldMap'
21:50:23 <lambdabot>     Perhaps you meant one of these:
21:50:23 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
21:50:27 <edwardk> with the casing that is probably too ugly to use =)
21:50:32 <Nereid> @ty Data.Foldable.foldMap
21:50:33 <lambdabot> (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
21:50:45 <johnw> lens is turning into its own DSL
21:50:53 <edwardk> johnw: it was designed as such
21:51:00 <Nereid> lens doesn't sound like an appropriate name for lens anymore.
21:51:04 <shachaf> Sadly, lens is a DSL for talking about lenses.
21:51:06 <edwardk> i wanted a language for composing the things you already know how to use
21:51:10 <johnw> it's somewhat unfortunate that in the simple cases it diverges so much from regular Haskell
21:51:32 <edwardk> Nereid: if i had it to do over i'd call it traversals or something
21:51:40 <Nereid> yeah
21:51:49 <edwardk> but i'm pretty happy with it
21:51:51 <shachaf> Yep, traversals are the really nifty bit.
21:51:54 <Nereid> yeah
21:52:06 <shachaf> On the other hand when someone asks "which lens library should I use?", you have an easy answer.
21:52:11 <edwardk> yep
21:52:14 <Nereid> hehe
21:52:30 <edwardk> it just takes a while to explain that the cool part about lens is all the non-lens stuff =)
21:52:37 <shachaf> Yes.
21:52:41 <Nereid> @hackage lens
21:52:42 <lambdabot> http://hackage.haskell.org/package/lens
21:53:04 <shachaf> I still haven't figured out the best way to explain lens to someone.
21:53:09 <otters> @hackage is just ("http://hackage.haskell.org/package/" ++)
21:53:09 <lambdabot> http://hackage.haskell.org/package/is just ("http://hackage.haskell.org/package/" ++)
21:53:14 <otters> ...
21:53:16 <Nereid> haha
21:53:17 <shachaf> I think the SEC + effects approach might be nicest.
21:53:19 <startling> shachaf, I thought you decided it was "get startling to do it"
21:53:43 <edwardk> shachaf: yeah that was why i went with that approach for the talk in SF. i'd tried other variants before
21:54:08 <edwardk> it also helped that folks have some intuition for SECs
21:54:28 <shachaf> And that conal was attending?
21:54:31 <edwardk> yep
21:54:51 <edwardk> but the source code to fmapDefault and foldMapDefault are really how i steer folks to the types for lens
21:54:55 <johnw> you guys have convinced me to scrap my tutorial on using the "lens" part of lens, and to rewrite it from the point of view of traversals first; but now I need to really understand the traversals part :)
21:55:39 <startling> johnw: haha
21:55:45 <shachaf> johnw: Did you figure out Bazaar yet?
21:55:59 <johnw> no, i'd forgotten about that
21:56:07 <johnw> it's our Context class based on Applicative, yeah?
21:56:09 <otters> edwardk: you might know something about lens, since it's yours
21:56:11 <shachaf> Yep.
21:56:22 <edwardk> so i've been told
21:56:22 <otters> is there an equivalent of (.=) but for getting?
21:56:25 <otters> wait, so
21:56:27 <otters> wait no
21:56:27 <edwardk> ^.
21:56:34 <shachaf> What would that do?
21:56:35 <otters> that's the totally wrong thing to ask
21:56:38 <shachaf> Maybe you want "use"?
21:56:39 <edwardk> > ("hello","world")^._2
21:56:40 <shachaf> @ty use
21:56:41 <lambdabot>   "world"
21:56:41 <lambdabot> MonadState s m => Getting a s t a b -> m a
21:56:44 <edwardk> :t use
21:56:46 <lambdabot> MonadState s m => Getting a s t a b -> m a
21:56:46 <otters> yeah I want to map over the result of use
21:56:52 <otters> and I thought there might be a handy combinator for it
21:56:53 <edwardk> :t uses
21:56:55 <lambdabot> MonadState s m => Getting r s t a b -> (a -> r) -> m r
21:57:00 <johnw> will working that out make me a better *user* of traversals?  Right now I feel like I need to see examples of all the various combinators in action
21:57:10 <edwardk> use : uses = get : gets
21:57:14 <johnw> i think I know maybe 5% of them
21:58:04 <shachaf> johnw: I think a good intuition for how lenses work helps with using them.
21:58:15 <johnw> ok
21:58:18 <johnw> let me add it to my list
21:58:23 <shachaf> But I might be biased. :-)
21:58:31 <edwardk> basically the combinators for working with traversals are just the ones for working with Traversable with an Of bolted on the end
21:58:40 <johnw> "You Could Have Invented Lenses"
21:58:45 <ski> edwardk : one-based indexing :(
21:58:50 <shachaf> You don't really need to understand Bazaar. But once you understand it you'll see that really it's completely trivial.
21:59:01 <johnw> edwardk: and Foldable?
21:59:02 <shachaf> ski: "fst" ~ "one"
21:59:02 <Nereid> just like a lot of other things :V
21:59:14 <ski> shachaf : ditto for that, yes
21:59:15 <johnw> shachaf: that's reason enough for me!
21:59:16 <edwardk> > mapMOf both (\x -> [x, x * 10]) (1,2)
21:59:18 <lambdabot>   [(1,2),(1,20),(10,2),(10,20)]
21:59:27 <edwardk> > forMOf both (1,2) $ \x -> [x, x * 10])
21:59:29 <lambdabot>   <hint>:1:38: parse error on input `)'
21:59:33 <edwardk> > forMOf both (1,2) $ \x -> [x, x * 10]
21:59:35 <lambdabot>   [(1,2),(1,20),(10,2),(10,20)]
22:00:17 <edwardk> Bazaar existing is a natural consequence of flipping the signature for Traversal
22:00:24 <ski> (though i've pondered using something like "first","oneth","twoth","third",&c.)
22:00:40 <edwardk> type Traversal s t a b = forall f. Applicative f => (a -> f b) -> s -> f t
22:00:46 <otters> I don't really get how to create a lens manually
22:00:47 <gertc> i have a feeling this is going to mess with my head data Pipe l i o u m r
22:00:58 <edwardk> flipped thats type Traversal' s t a b = s -> (forall f. Applicative f => (a -> f b) -> f t)
22:01:03 <johnw> otters: I think it starts with grinding glass
22:01:09 <otters> I don't get what the Settable bit is for
22:01:16 <edwardk> if you ball that up in a newtype you get type Traversal' s t a b = s -> Bazaar a b t
22:01:18 <shachaf> otters: You don't need to worry about the Settable bit.
22:01:20 <cornihilio> dcoutts_: if these are the only default packageDBs https://gist.github.com/4064228 then am I supposed to create a SpecificPackageDB for each package in the users .cabal that's installed?
22:01:29 <otters> but I do want to create a custom lens D:
22:01:35 <shachaf> No you don't.
22:01:40 <otters> Yeah I guess not.
22:01:46 <shachaf> otters: _1 f (x,y) = (,y) <$> f x
22:01:50 <edwardk> otters f (x,y,z) = (,,) x y <$> f z
22:02:31 <shachaf> Your lens takes a function and a structure. It takes apart that structure and applies the function to it, and then fmaps a "reconstructing" function to what it returns.
22:02:35 <edwardk> pattern match on something, peel out its parts, call the supplied function on one part. fmap over that a function that puts all the other parts back where you got them
22:02:36 <otters> use case: I have a bot with settings stored in YAML format and I have a handy setting update/retrieval DSL
22:02:36 <shachaf> ...OK, that was more confusing than helpful.
22:02:41 <otters> I see
22:02:57 <otters> shachaf: that's straightforward
22:03:06 <edwardk> make sure you only use everything once
22:03:10 <otters> right
22:03:19 <edwardk> and that you use everything exactly once
22:03:22 <edwardk> and you have a lens =P
22:03:40 <shachaf> You can also build it with "lens"
22:03:41 <otters> okay so for something like data Foo = Foo { _bar :: Int }; makeLenses ''Foo; what does the source of "bar" look like?
22:03:47 <otters> oh yeah lens
22:03:57 <Nereid> @ty lens
22:03:58 <lambdabot> Functor f => (s -> a) -> (s -> b -> t) -> (a -> f b) -> s -> f t
22:03:58 <edwardk> i really don't recommend using the 'lens' combinator, its almost never shorter
22:04:01 <shachaf> bar f (Foo x) = Foo <$> f x
22:04:02 <edwardk> and its often slower
22:04:18 <otters> oh
22:04:45 <shachaf> Well, more generally, if you have data Foo = Foo { _bar :: Int, ... }, it'll be
22:04:47 <edwardk> if you use makeClassy you get a slightly spiffier lens
22:05:05 <shachaf> bar f (Foo { _bar = x }) = (\x' -> Foo { _bar = x' }) <$> f x
22:05:16 <otters> I see
22:05:30 <shachaf> That fmapped function is clearly just a setter.
22:06:14 * yitz hasn't had time yet to really jump into lenses
22:06:15 <ski> @type let foo :: Functor f => (s -> (a,b -> t)) -> (a -> f b) -> (s -> f t); foo l f s = fmap wrap (f a) where (a,wrap) = l s in foo
22:06:16 <lambdabot> Functor f => (s -> (a, b -> t)) -> (a -> f b) -> s -> f t
22:06:25 <yitz> so, lenses do version control too now?
22:06:26 <otters> Right
22:06:56 <edwardk> with makeClassy, it updates to building class HasFoo t where foo :: Simple Lens t Foo;      and then bar = foo . go where go f Foo { _bar = x } = … is the lens you get from makeLenses
22:07:15 <edwardk> yitz: version control how?
22:07:22 <yitz> Bazaar?
22:07:40 <shachaf> ski: Data.Lens has (^%%=) :: Functor f => Lens a b -> (b -> f b) -> a -> f a
22:07:43 <edwardk> yitz: ah, no, Bazaar is a pun. its a bunch of stores that you can easily traverse
22:08:01 <simpson> Haha.
22:08:06 <shachaf> You should totally alpha-rename data-lens to match now!
22:08:42 <edwardk> shachaf: roconnor is a much more responsible maintainer than i am and would probably never countenance such a disruption to his users ;)
22:09:04 <yitz> edwardk: ok. ;) sounds more useful actually
22:09:09 <shachaf> roconnor is maintaining data-lens now?
22:09:20 <edwardk> shachaf: yeah i handed it over to him probably 8 months ago
22:09:21 <shachaf> Or was he always maintaining it?
22:09:24 <shachaf> Ah.
22:10:01 <edwardk> at the time i'd kind of decided i'd said all there was to say about lenses ;)
22:10:16 <edwardk> silly me
22:10:40 <startling> heh
22:11:03 <otters> what's the difference between use and query?
22:11:20 <shachaf> otters: The monad.
22:11:22 <shachaf> @ty use
22:11:22 <edwardk> query works on a MonadReader environment, use works on a MonadState
22:11:24 <lambdabot> MonadState s m => Getting a s t a b -> m a
22:11:32 <otters> oh monadreader
22:11:34 <otters> lol
22:11:50 <edwardk> zoom focuses in on part of the state, while you use magnify to read.
22:11:55 <edwardk> @ty zoom
22:11:57 <lambdabot> Zoom m n k s t => SimpleLensLike (k c) t s -> m c -> n c
22:12:06 <edwardk> avert your eyes from the horror that is the Zoom class
22:12:12 <startling> what's that one html templating thing built around "splice"s?
22:12:41 <ski> `Zoom' looks fun
22:12:47 <startling> ah, heist.
22:13:04 <shachaf> ski: Does it look fun enough to write a ContT instance for?
22:13:29 <johnw> some way we should work ContT into lens
22:13:30 <edwardk> shachaf: the problem is i know how to write the ContT version for an actual lens. but zoom can work with traversals too
22:13:49 <edwardk> shachaf: that winds up with all sorts of MonadCatchIO-like issues
22:14:06 <startling> yeah, I can't do what I want with heist. ah well.
22:14:06 * shachaf hates MonadCatchIO-like issues.
22:14:08 <johnw> can you show an example of using zoom?
22:15:04 <edwardk> johnw: you write a program foo :: State Int a    and you want to embed it in a larger program with type State (Int,Double) a  -- you can zoom _1 foo
22:15:05 <shachaf> > (`runState` (3,4)) $ zoom both (modify (+1))
22:15:07 <lambdabot>   ((),(4,5))
22:15:23 <johnw> ah
22:15:26 <shachaf> OK, that's not a very interesting example.
22:15:40 <otters> I can verify that
22:15:41 <johnw> it's like += 1, but on both parts of the state?
22:15:41 <edwardk> :t let fresh = id <+= 1 in zoom _1 fresh
22:15:43 <lambdabot> (Functor (k c), Num c, Zoom m n k c t, Field1 t t c c) => n c
22:15:53 <edwardk> :t let fresh = id <+= 1 in zoom both fresh
22:15:55 <lambdabot> (Num c, Applicative (k c), Zoom m n k c (c, c)) => n c
22:16:10 <shachaf> johnw: Well, you can already do += 1
22:16:15 <shachaf> @ty both += 1
22:16:17 <lambdabot> (Num a, MonadState (a, a) m) => m ()
22:16:31 <johnw> so why zoom then?
22:16:32 <edwardk> its basically prepending the use of the lens onto everything you are doing in the current state.
22:16:33 <shachaf> The point of zoom is that it lifts an existing state operation
22:16:36 <Nereid> @ty (+= 1)
22:16:38 <lambdabot> (Num a, MonadState s m) => SimpleSetting s a -> m ()
22:16:43 <startling> :t zoom
22:16:44 <lambdabot> Zoom m n k s t => SimpleLensLike (k c) t s -> m c -> n c
22:16:48 <Nereid> @ty (id += 1)
22:16:50 <lambdabot> (Num s, MonadState s m) => m ()
22:17:03 <shachaf> @ty (id %=)
22:17:05 <lambdabot> MonadState s m => (s -> s) -> m ()
22:17:08 <edwardk> say you have written a function that expects a really simple state. say it should take your localization settings, or your error configuration, or something
22:17:17 <edwardk> and you want to use it in a larger program where you have more complex state
22:17:24 <startling> > (`runState` 1) . zoom $ id += 1
22:17:25 <edwardk> you can zoom down to the part of the state that that function expects
22:17:26 <lambdabot>   Couldn't match expected type `Control.Monad.Trans.State.Lazy.State
22:17:26 <lambdabot>         ...
22:17:45 <johnw> ohh
22:17:46 <johnw> i get it
22:17:47 <startling> oh, so it's a lens pun.
22:17:48 <Nereid> :t zoom id
22:17:48 <otters> the thing that really worries me about all this lens crap
22:17:49 <lambdabot> Zoom m n k t t => m c -> n c
22:17:50 <johnw> that's why you did zoom (modify (+1)
22:17:58 <johnw> modify is seeing a subset of the state
22:18:01 <otters> is that I could probably use it to simplify my codebase
22:18:02 <startling> oh I see
22:18:03 <haskeller> hi guys
22:18:06 <johnw> ah, then the name makes perfect sense
22:18:06 <otters> but I don't understand any of it
22:18:08 <otters> so
22:18:09 <Nereid> haha
22:18:19 <Nereid> so, time to get learning
22:18:20 <shachaf>  > (`runState` 1) . zoom id $ id += 1
22:18:25 <edwardk> johnw: basically you use a lens from Foo to Bar to run a state action with state Bar in a larger state Foo
22:18:30 <startling>  otters, do you get traversals? traversals as is simplify a lot of code
22:18:46 <johnw> edwardk: got it; that's cool!
22:18:47 <otters> no I do not
22:19:01 <startling> otters: want the two-minute version?
22:19:03 <edwardk> johnw: and since its in lens, it also does the right thing when you hand me a traversal. it'll run the action for _all_ of the targets in the current state, and then monoidally summarize the result of each action it performed
22:19:04 <otters> sure
22:19:18 <edwardk> :t zoom both putStrLn
22:19:20 <lambdabot> (Applicative (k (IO ())), Zoom ((->) String) n k s (s, s)) => n (IO ())
22:19:22 <johnw> yeah, lens may not always improve upon standard Haskell code -- even in the record update case -- but traversals can often do so
22:19:28 <startling> otters: traversals are generalizations of mapM for any applicative on some structure.
22:19:32 * sopvop simplified his codebase with lens, without understanding
22:19:37 <otters> oh cool
22:19:55 <johnw> > (`runState` (3,4)) $ zoom both putStrLn
22:19:57 <lambdabot>   Couldn't match type `Data.Functor.Identity.Identity'
22:19:58 <lambdabot>                 with `...
22:19:58 <startling> otters: they're stronger than Functor because they let you run monadic functions on each element and then they sequence those actions
22:20:09 <johnw> > (`runState` (3,4)) $ zoom both (get >>= putStrLn)
22:20:11 <lambdabot>   Couldn't match type `Control.Monad.Trans.State.Lazy.StateT
22:20:11 <lambdabot>                 ...
22:20:16 <edwardk> sopvop: that is actually my goal. if you can use lens without understanding it the overall API design has been a success.
22:20:25 <edwardk> if it then guides you toward fuller understanding later, even better
22:20:31 <otters> I see
22:21:10 <startling> otters: the neat thing is that you can use them to set fields by narrowing them down to fmap
22:21:42 <startling> otters, the other neat thing is that if you can write it using Functor instead of Applicative, you guarantee that there's one and exactly one field that gets traversed over
22:21:43 <sopvop> edwardk: great success!
22:21:50 <otters> I see
22:21:51 <cornihilio> uh... can someone suggest an easy cabal issue for me to fix? apparently I can't even tell the difference between easy/difficult ones
22:21:57 <otters> so what would you use traversals for
22:21:59 <otters> in general
22:22:05 <otters> I guess the point of them is "anything"?
22:22:07 <shachaf> Traversin'
22:22:16 <Nereid> anything you'd use traverse for, except more
22:22:29 <otters> I don't use traverse because I don't know anything about it
22:22:35 <startling> otters: so if you have one of these functor-traversals, you can read that one field -- this is how Getters work in lens.
22:22:43 * otters is a n00b that just recently starting using Monoid generally
22:22:44 <edwardk> @type flip evalStateT ("hello","world") $ zoom both $ do x <- get; lift $ putStrLn x
22:22:46 <lambdabot> IO ()
22:22:53 <otters> I see
22:23:05 <malik> is curry function improperly named?  as far as I know this is currying (+ 1)
22:23:17 <otters> that's partial application
22:23:19 <zachk> that is partial
22:23:22 <zachk> yea
22:23:22 <shachaf> malik: No, that's application.
22:23:25 <Ghoul> malik: All functions in haskell are curried.
22:23:28 <shachaf> Nothing partial about it, really.
22:23:41 <startling> otter: it's more complicated than that, but you get the idea
22:23:53 <shachaf> Ghoul: Like id?
22:23:58 <malik> Ghoul so why is curry function called curry then?
22:24:01 <zachk> currying would be ((a,b) -> c) -> (a -> b -> c)
22:24:04 <edwardk> malik: currying a function takes a function that takes a tuple and gives you a function that expects one argument and then gives you a function for the remaining arguments. you can then partially apply that function to one argument, which is what you did there
22:24:05 <startling> otters: one thing I used Traversals for was pretty-printing trees
22:24:09 <Nereid> malik: curry takes an uncurried function and makes it curried.
22:24:22 <Nereid> @ty curry
22:24:23 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:24:29 <Ghoul> shachaf: I have no idea what you're asking
22:24:32 <shachaf> edwardk: Well, (+1) has the additional complication that it flips.
22:24:37 <Ghoul> I honestly dont know much about haskell at all.
22:24:38 <edwardk> shachaf: yes
22:24:47 <ski> Ghoul : `not' is not curried
22:24:59 <malik> what confuses me is that in other languages curry function does what partial application does in haskell
22:24:59 <startling> any unary function is arguable not curried.
22:25:10 <shachaf> malik: That's because other language have misnamed it. :-)
22:25:16 <Nereid> malik: in haskell, multi-argument functions are already curried.
22:25:21 <edwardk> malik: in other languages you call functions with something like foo(bar,baz)   in haskell you can do that too, but its just making a tuple out of bar and baz, and passing them to 'foo' as a single argument.
22:25:40 <shachaf> It ought to be called Schönfinkeling, anyway.
22:25:44 <edwardk> malik: this isn't a common convention here. we prefer to write functions that take one argument and return a _function_ of the rest of the arguments
22:25:48 <Nereid> when you write "f x y" in haskell, it's like writing "f(x)(y)" in some other language.
22:25:51 <edwardk> foo a b = a + b  -- foo is curried
22:25:57 <edwardk> bar (a,b) = a + b -- bar is not
22:26:02 <startling> shachaf, what, you don't like indian food?
22:26:08 <edwardk> uncurry bar gives you something like foo
22:26:25 <sopvop> just found (%) in Control.Lens, want this one in base
22:26:28 <Nereid> curried functions are the norm in haskell, so usually there's no need to use "curry".
22:26:36 <Jafet> Food is curried at the curry bar.
22:26:52 <startling> Jafet: you can get some drinks there, too.
22:26:54 <edwardk> curry takes a function in the 'both args at the same time style and converts it to the function that returns a function style.
22:27:02 <Nereid> @ty curry id
22:27:03 <edwardk> (a, b) -> c      vs.          a -> (b -> c)
22:27:04 <lambdabot> a -> b -> (a, b)
22:27:07 <zachk> @type curry
22:27:08 <Ghoul>  Curry is great.
22:27:09 <lambdabot> ((a, b) -> c) -> a -> b -> c
22:27:11 <Jafet> Let's not get curried away now
22:27:17 <Ghoul> haha
22:27:23 <Nereid> you guys remind me that I have some leftover curry.
22:27:26 <Nereid> and I'm hungry.
22:27:33 <zachk> are you sure you want to curry on with this conversation?
22:27:40 <shachaf> I, too, am hungry. But I lack leftover curry.
22:27:45 <sopvop> more readable  curry :: ((a, b) -> c) -> (a -> b -> c)
22:27:48 <Nereid> shachaf: what a shame.
22:27:52 <shachaf> Nereid would seem to have won this time around.
22:27:53 <mm_freak> so far i think that currying is best explained in terms of two small equations
22:28:02 <mm_freak> 1. a -> (b -> c) = a -> b -> c
22:28:10 <mm_freak> 2. (f x) y = f x y
22:28:25 <Nereid> I'd flip those equations around but yes.
22:28:27 <shachaf> Neither of those has anything to do with currying *as such*. :-)
22:28:40 <johnw> yeah, where is (,)?
22:28:45 <ski> @type curry (snd &&& fst) 'a'
22:28:46 <lambdabot> c -> (c, Char)
22:29:03 <startling> oh that's neat
22:29:31 <Nereid> (,) = curry id
22:29:42 <pordan30> > uncurry id (succ, 1)
22:29:43 <lambdabot>   2
22:29:54 <Nereid> @ty uncurry id
22:29:56 <lambdabot> (b -> c, b) -> c
22:29:56 <mm_freak> shachaf: currying is two concepts: turning a function of tuples into a curried function, and a language where functions are curried by default…  for the latter i don't think you need currying as a transformation to explain
22:29:58 <edwardk> anyways, if you read -> as the logical 'implies' operator, then you can work out the truth table that to see that (a and b) implies c    and a implies that b implies c are equivalent. this is one way to view the equivalence between the uncurried and curried form of a function
22:30:19 <shachaf> mm_freak: The latter isn't really currying.
22:30:38 <mm_freak> what would you call it?
22:30:41 <shachaf> mm_freak: Anyway, the original question was "why is curry :: ((a,b) -> c) -> a -> b -> c?"
22:30:49 <ski> mm_freak : "curried" is not "currying"
22:30:53 <shachaf> I wouldn't really call it anything.
22:30:58 <mm_freak> ah
22:31:03 <Nereid> "hom-tensor adjunction".
22:31:13 <Nereid> :(
22:31:22 <copumpkin> :)
22:31:41 <mm_freak> anyway, add too much curry and it gets spicy
22:31:53 <sopvop> curring should be properly named as Schönfinkelization
22:32:16 <mm_freak> i totally think of haskell as a "curried language"
22:32:39 <Ghoul> o-o "Schönfinkelization"
22:33:04 <sopvop> wikipedia:  It was originated by Moses Schönfinkel[1] and later re-discovered by Haskell Curry.
22:33:18 <startling> mosesing
22:33:21 <Ghoul> wot
22:33:24 <Nereid> haskelling
22:33:24 <Ghoul> Haskell Curry
22:33:30 <Ghoul> Is that seriously the guys name?
22:33:30 <mm_freak> latering
22:33:32 <yitz> > runIdentity (flip evalStateT ("hello","world") $ zoom both get) -- ok then, where does the concatenation come from here?
22:33:34 <lambdabot>   "helloworld"
22:33:34 <otters> yeah
22:33:35 <startling> Ghoul: yes
22:33:39 <Ghoul> NO WAI
22:33:46 <Ghoul> You lie to me
22:33:50 <Ghoul> lalalalaa not listening.
22:33:55 <startling> Ghoul, there's a language named after him.
22:34:02 <startling> Ghoul: you may have heard of it.
22:34:04 <johnw> Haskell was originally going to be named Curry
22:34:06 <startling> Ghoul: two, actually.
22:34:09 <Ghoul> startling: I got that part/
22:34:11 <ski> malik : perhaps you're confused by that if `f :: (A,B) -> C' and `a :: A', then `curry f a :: B -> C' is partial application of `f' on the first part of the pair input -- this is because the `curry' function in Haskell is itself curried ! :)
22:34:13 <johnw> but then they thought about all the unfortunate puns
22:34:13 <otters> Haskell and Curry
22:34:22 <mm_freak> Ghoul: in fact there is also a language called curry =)
22:34:26 <Nereid> Curry is less likely to be confused with Pascal in speech though :(
22:34:30 <johnw> > (snd &&& fst) ('a', 'b')
22:34:32 <lambdabot>   ('b','a')
22:34:35 <johnw> edwardk: what's the lens form of doing that?
22:34:54 <yitz> Ghoul wants to know whether there is a language named Schönfinkel
22:35:01 <johnw> there should be a Prelude or Data.Tuple function called "swap" to do that
22:35:02 <startling> we should call it mosing.
22:35:04 <edwardk> > partsOf both %~ reverse $ ('a','b')
22:35:06 <lambdabot>   ('b','a')
22:35:10 <Ghoul> curried functions could really be expressed as codecaves by llvm and then simplified down to uncurried functions :O
22:35:20 <pordan30> > uncurry (flip $ curry uncurry id) (1, succ)
22:35:23 <lambdabot>   Couldn't match expected type `(a1, a0)'
22:35:23 <lambdabot>              with actual type `a2 -...
22:35:29 <mm_freak> it's almost weird that there is no language called turing and no cryptosystem called shannon
22:35:30 <pordan30> > uncurry (flip $ curry $ uncurry id) (1, succ)
22:35:32 <lambdabot>   2
22:35:34 <otters> :t curry uncurry
22:35:36 <lambdabot>     Couldn't match expected type `(a0, b0)'
22:35:36 <lambdabot>                 with actual type `a1 -> b1 -> c0'
22:35:36 <lambdabot>     Expected type: (a0, b0) -> c1
22:35:39 <shachaf> edwardk: Next step: Prettify the Core for partsOf both %~ reverse
22:35:42 <ski> malik : hm, i suppose i should really say that `curry' can be considered a curried form of an "partial-application" function
22:35:43 <mm_freak> :t uncurry curry
22:35:44 <lambdabot> ((b, b1) -> c, b) -> b1 -> c
22:35:48 <pordan30> uncurry (flip $ curry id) (1,2)
22:35:48 <edwardk> of course thats a hack because i relied on them having the same types
22:35:51 <pordan30> > uncurry (flip $ curry id) (1,2)
22:35:52 <lambdabot>   (2,1)
22:35:57 <johnw> edwardk: that's my main difficulty with lens at this stage: I knew lens could do it, and I got really close to what you had, but I failed to stumble upon the right combination of terms
22:36:00 <ski> malik : i.e. we can use `curry :: ((a,b) -> c) -> (a -> (b -> c))' instead of `partialApply :: ((a,b) -> c,a) -> (b -> c)'
22:36:02 <Nereid> partsOf both %~ reverse has the type (a,a) -> (a,a) though
22:36:06 <Nereid> too restrictive
22:36:10 <shachaf> I don't think lens is the right answer for writing "swap"
22:36:17 <shachaf> Not everything needs to be a lens.
22:36:19 <Nereid> snd &&& fst seems to be the way to go.
22:36:20 <startling> swap (a, b) = (b, a)
22:36:22 <edwardk> :t let swap = iso (uncurry (flip (,))) (uncurry (flip (,))) in swap
22:36:24 <lambdabot> (Functor f, Isomorphic k) => k ((b, a) -> f (b, a)) ((a, b) -> f (a, b))
22:36:39 <edwardk> > let swap = iso (uncurry (flip (,))) (uncurry (flip (,))) in (2,"hello")^.swap
22:36:39 <Nereid> lol
22:36:42 <lambdabot>   ("hello",2)
22:36:48 <ski> johnw : yes. sometimes i define `swap :: Arrow ar => ar (a,b) (b,a); swap = arr snd &&& arr fst'
22:36:53 <liyang> johnw: if you want to combine two Setters (or Traversals), maybe this is related: https://github.com/ekmett/lens/pull/84
22:37:12 <Nereid> ski: why not arr (snd &&& fst)?
22:37:12 <mm_freak> Nereid: i'd define swap as: swap (a, b) = (b, a)
22:37:16 <johnw> hi liyang!  ltns
22:37:27 <startling> :t let swap = iso (via swap) $ uncurry (flip (,)) in swap
22:37:29 <lambdabot>     Couldn't match expected type `(b0, a0)'
22:37:29 <lambdabot>                 with actual type `(a0, b0) -> f0 (a0, b0)'
22:37:29 <lambdabot>     Expected type: Isomorphism (b0, a0) (a0, b0)
22:37:31 <ski> Nereid : i would rather not use `arr' at all
22:37:31 <edwardk> mm_freak: as would i, possibly after debating about a lazy pattern
22:37:32 <startling> er
22:37:35 <Nereid> sure
22:37:40 <Nereid> @arr
22:37:40 <lambdabot> Ahoy mateys
22:37:41 <shachaf> The Core for partsOf both %~ reverse is a bit scary.
22:37:41 <yitz> edwardk: isn't there some way to make the types more understandable and intuitive, with aliases or newtypes or something?
22:37:52 <startling> :t let swap = iso (from swap) $ uncurry (flip (,)) in swap
22:37:52 <ski> in the absense of that, i prefer to push the `arr's inward
22:37:53 <lambdabot>     Couldn't match expected type `(a0, b0)'
22:37:53 <lambdabot>                 with actual type `(a0, b0) -> f0 (a0, b0)'
22:37:53 <lambdabot>     Expected type: Isomorphism (a0, b0) (b0, a0)
22:37:56 <startling> bah
22:37:58 <Nereid> yitz: there are plenty of aliases
22:38:03 <johnw> liyang: example of use for ~*~?
22:38:06 <edwardk> yitz: they are type aliased. ghc doesn't maintain them when showing them with :t
22:38:08 <Nereid> I think the types are pretty intuitive when tought of as souped up SECs
22:38:09 <startling> there's some way to do it by only defining it once, I forget.
22:38:12 <johnw> Lens type signature are still opaque to me just yet
22:38:17 <yitz> edwardk: or at least documentation for each type that tells you which type parameters are important and what they mean?
22:38:22 <Nereid> thought*
22:38:23 <startling> johnw: they're just traversals
22:38:25 <mm_freak> :t liftA2 (,) (arr snd) (arr fst)
22:38:26 <lambdabot> (Applicative (a1 (b, a)), Arrow a1) => a1 (b, a) (a, b)
22:38:31 <edwardk> yitz: that is how i do document them =)
22:38:35 <yitz> edwardk: oh. :(
22:39:07 <yitz> edwardk: so now we need to write lenses again in ghci script?
22:39:26 * ski wonders whether malik was scared away ..
22:39:27 <Nereid> that's how I think of the types anyway.
22:39:29 <Nereid> as souped up SECs.
22:39:34 <shachaf> yitz: Maybe sometime I'll get around to writing a nice high-level explanation of lens, and thhen it'll all make sense.
22:39:34 <johnw> lol
22:39:46 <johnw> shachaf: just don't mention Bazaar when you do it
22:40:26 <shachaf> johnw: But understanding Bazaar makes understanding Traversal trivial!
22:40:31 <Nereid> haha
22:40:33 <edwardk> yitz: take a look at the haddocks on http://hackage.haskell.org/packages/archive/lens/3.2/doc/html/Control-Lens-Getter.html#v:view for an example of how they are documented
22:40:35 <Nereid> (and vice versa)
22:40:46 <Nereid> I'm going to look at data-lens now. just for fun.
22:40:54 <sopvop> Say I have a lens pointing to Functor, is there an operator to use instead of mylens %~ fmap foo? like <%~>
22:41:02 <yitz> edwardk: ok great thanks!
22:41:07 <shachaf> sopvop: mylens.mapped %~ foo
22:41:17 <sopvop> sweeet
22:41:23 <Nereid> :t mapped
22:41:24 <edwardk> i try to provide working examples you can use to get your head around them as doctests that get verified at build time, and i put several 'fake' signatures on there to show you what the signature means when you apply it to a lens, traversal, fold, etc.
22:41:25 <lambdabot> (Functor f, Settable f1) => (a -> f1 b) -> f a -> f1 (f b)
22:41:27 <sopvop> lens is like totaly new language
22:41:35 <johnw> sopvop: yeah, I said that before too
22:41:47 <ski> @type \mylens foo -> mylens.mappend %~ foo
22:41:48 <lambdabot> Monoid (Mutator b) => (((a -> Mutator b) -> a -> Mutator b) -> s -> Mutator t) -> (a -> b) -> s -> t
22:41:53 <startling> > mapped %~ id $ [1, 2]
22:41:54 <shachaf> yitz: When you see something like SimpleLens s a, it's a lens from some structure s to some internal value a.
22:41:55 <lambdabot>   [1,2]
22:42:00 <johnw> sopvop: the only real difficulty with that is that people won't realize that they're looking at something they already understand, it's just in different syntactic form now
22:42:13 <edwardk> @type \mylens foo -> mylens.mapped %~ foo
22:42:13 <shachaf> yitz: But you want lenses to be polymorphic, so you add two extra types: Lens s t a b
22:42:15 <lambdabot> Functor f => ((f a -> Mutator (f b)) -> s -> Mutator t) -> (a -> b) -> s -> t
22:42:19 <edwardk> rather than mappend =)
22:42:21 <shachaf> That way you can set something to a different value from what it started with.
22:42:26 * startling stabs shachaf with a lens.
22:42:39 <sopvop> If many programmers were scared befor by haskells liberal use of operators, code with lens will left them terrified
22:42:39 <ski> edwardk : i know, just curious :)
22:43:03 <startling> sopvop, don't worry, they'll think they understand a.b.c.d
22:43:13 <Nereid> :)))
22:43:14 <startling> sopvop: so it evens out
22:43:15 <edwardk> startling: =)
22:43:32 <startling> += etc as well
22:43:34 <johnw> startling: yeah, but that's not really the compelling argument for using lens!
22:43:36 <yitz> shachaf: somehow that leads to other constructors with at least six or seven type parameters, that often criss-cross each other. whew!
22:43:51 <shachaf> yitz: It's actually not that complicated at all.
22:43:51 <johnw> the a.b.c stuff looks "cute", but I don't actually run into it in practice
22:43:54 <edwardk> the principal conceit of lens is to pun (.) for both function application and member access
22:44:10 <Nereid> composition*
22:44:16 <edwardk> er yes, composition
22:44:25 <shachaf> The reason (.) works like is the same reason you can mapM (mapM (mapM f)) == (mapM.mapM.mapM) f
22:44:26 <johnw> edwardk: the fact that your "." is in reverse too is a bit odd; I mean, I understand why it's odd, but it further proves the point that lens is its own DSL
22:44:38 <zachk> hmmm
22:45:06 <shachaf> [x] ++ [y] doesn't get optimized in Core. :-(
22:45:25 <shachaf> Nor does reverse of it.
22:45:25 <johnw> shachaf: how were you expecting it to be optimized?
22:45:29 <liyang> johnw: id ~*~ _2 :: Simple Setter (String, (Int, String)) String
22:45:35 <shachaf> johnw: [x,y] would be nice.
22:45:40 <proteros> [42, 13, 22]
22:45:43 <yitz> oh my, a haddock comment containing a UML diagram? what is this world coming to?
22:46:15 <edwardk> liyang: i have yet to hear back from russell disproving the usability of ~*~.
22:46:18 <sopvop> It just looks like uml
22:46:25 <edwardk> yitz: hahahaha
22:46:34 <shachaf> sopvop: It is UML.
22:46:55 <sopvop> We are doomed! DO-O-OMED!
22:46:57 <liyang> johnw: we're not 100% sure if it's a valid Traversal.
22:47:00 <edwardk> yitz: its very 'yo dawg'. I mean we're so oop even our member accessors have diagrams explaining their member accessors.
22:47:06 <johnw> liyang: id ~*~ _2 .~ ("Hello", "World") => ?
22:47:33 <shachaf> @remember edwardk I mean we're so oop even our member accessors have diagrams explaining their member accessors.
22:47:33 <lambdabot> It is stored.
22:47:41 <johnw> we just need lens at the type level
22:47:47 <johnw> it'll make my types look bigger
22:47:53 <Nereid> lol
22:48:16 <johnw> codependent types
22:48:57 <liyang> johnw: set (id ~*~ _2) "world" ("hello", (42, "there")) ↦ ("world", (42, "world))
22:49:43 <Nereid> what is ~*~ ?
22:49:51 <shachaf> liyang's operator
22:49:53 <edwardk> Nereid: its a combinator liyang wants me to add
22:49:53 <liyang> Nereid: https://github.com/ekmett/lens/pull/84
22:49:58 <johnw> as opposed to just ("hello", (42, "there")) .~ _2._2 $ "world"?
22:50:06 <sopvop> looks like clown mustache
22:50:20 <Nereid> ah
22:50:27 <liyang> johnw: I end up with two "world"s.
22:50:38 <edwardk> johnw: it wound up traversing all the targets of both traversals
22:50:48 <johnw> then what's the _2 mean?
22:51:02 <ski> > run (dup . mult . swap_ . dup . mult . add . sqrt_) 3 4
22:51:04 <lambdabot>  Terminated
22:51:12 <liyang> johnw: the second component of (42, "there")
22:51:12 <ski> > run (dup . mult . swap_ . dup . mult . add . sqrt_) 3 4
22:51:14 <lambdabot>   5.0
22:51:24 <edwardk> he wanted to traverse the top level of the left of the outer pair, and the second element of the second element of his pair.
22:51:43 <edwardk> ("hello",(42,"there"))  -- he wants to walk both "hello" and "there"
22:51:44 <ski> (that's another use of `.' which appears backwards)
22:51:57 <johnw> i get that, but i'm not seeing how id ~*~ _2 expresses that
22:52:02 <johnw> oh
22:52:07 <shachaf> ski: I can make any use of (.) be backwards if you let me CPS the function!
22:52:11 <johnw> id traverses the pair, and _2 traverses the second pair
22:52:14 <edwardk> its like alongside
22:52:16 <edwardk> :t alongside
22:52:18 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Context a b) s t a b -> LensLike (Control.Lens.Internal.Context a' b') s' t' a' b' -> ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
22:52:21 <Nereid> _2 ~*~ _1 %~ id
22:52:25 <Nereid> :))
22:52:25 <edwardk> but not restricted to actual lenses
22:52:29 <johnw> ok, edwardk, that type signature does NOT help
22:52:31 <Nereid> wait
22:52:33 <Nereid> nope
22:52:50 <edwardk> and where it doesn't get a tuple out
22:52:55 <edwardk> so i guess its not like alongside ;)
22:53:10 <Nereid> alongside : *** :: ~*~ : &&&
22:53:10 <shachaf> edwardk: It's an annoying property of rank-2 types that making something more polymorphic involves giving it a longer type.
22:53:12 <johnw> can you show me an example of alongside?
22:53:26 <ski> edwardk : is that a product map ?
22:53:26 * alpounet fears the day there'll be lenses everywhere in haskell code
22:53:27 <johnw> i'm keeping a special file now of just lens usage examples one after the other
22:53:29 <shachaf> (Because you demand less polymorphism.)
22:53:34 <edwardk> :t alongside _2 _1
22:53:36 <lambdabot> (Functor f, Field2 s t a b, Field1 s' t' a' b') => ((a, a') -> f (b, b')) -> (s, s') -> f (t, t')
22:53:57 <johnw> edwardk: sigh
22:54:15 <edwardk> :t alongside _2 _1 %~ \(x,y) -> (y *10, x * 10) $ ((1,2),(3,4))
22:54:17 <lambdabot>     The first argument of ($) takes one argument,
22:54:18 <lambdabot>     but its type `(t0, t1)' has none
22:54:18 <lambdabot>     In the expression: (y * 10, x * 10) $ ((1, 2), (3, 4))
22:54:26 <edwardk> > alongside _2 _1 %~ (\(x,y) -> (y *10, x * 10)) $ ((1,2),(3,4))
22:54:28 <lambdabot>   ((1,30),(20,4))
22:55:21 <liyang> :t alongside _2 _1 :: Simple Lens ((String, Int), (Int, String)) (Int, Int)
22:55:22 <edwardk> alongside takes two lenses, and applies them independently to each argument of a pair, getting out their target, lets you change it, and can then take the two new answers, and put them back in
22:55:23 <lambdabot> Functor f => ((Int, Int) -> f (Int, Int)) -> ((String, Int), (Int, String)) -> f ((String, Int), (Int, String))
22:55:35 <johnw> so, alongside takes two lenses, and turns the values referenced into a tuple?
22:55:43 <edwardk> yep
22:56:00 <edwardk> but i can't let you index into the same object for those parts, because your lenses might overlap
22:56:03 <johnw> ('a', 'b') ^. alongside _2 _1
22:56:09 <johnw> > ('a', 'b') ^. alongside _2 _1
22:56:11 <lambdabot>   Could not deduce (Control.Lens.Tuple.Field2 GHC.Types.Char t0 a b0)
22:56:11 <lambdabot>    aris...
22:56:11 <edwardk> no
22:56:23 <edwardk> that lens could be illegal
22:56:30 <johnw> > ((1,2), (3,4)) ^. alongside _2 _1
22:56:32 <lambdabot>   (2,3)
22:56:32 <edwardk> what happens when you update johnwside _1 _1
22:56:41 <edwardk> =)
22:56:47 <johnw> there's a johnwside combinator too??
22:56:54 <johnw> ;)
22:57:04 <edwardk> i was using it to refer to the way you were thinking alongside worked
22:57:31 <sopvop> lens now has 108 operators, 60 of them start with '<'
22:57:35 <startling> who's alan g?
22:57:47 <johnw> the johnw combinator always yields a type error
22:57:57 <liyang> startling: there's an A Lang.
22:58:35 <mgsloan> alpounet: I look forward to the day that there's tons of lensy haskell, but at once, yeah, I feel for any new Haskeller reading lensy code
22:58:38 <startling> liyang: oh yeah, the fermat guy? what's he got to do with lens?
22:59:00 <edwardk> mgsloan: well, it seemed to help draw johnw into the language at least ;)
22:59:09 <startling> oh wait, misremembering.
22:59:09 <liyang> startling: where did you see alang in the context of lenses?
22:59:25 <Nereid> alangside
22:59:29 <ion> Which JSON generators support prettyprinting data structures with indentation and outputting maps sorted by the key? Aeson doesn’t seem to support the latter, it seems to convert maps to hash maps.
22:59:33 <startling> ^^
22:59:39 <shachaf> > (["hi","there"],["new","haskellers"]) % partsOf (both.traverse.traverse) %~ reverse
22:59:41 <lambdabot>   (["sr","ellek"],["sah","wenerehtih"])
23:00:02 <startling> shachaf: woah
23:00:04 <mgsloan> edwardk: cool! Then maybe lens is Haskell's killer app ;)
23:00:22 <typoclass> shachaf: thanks for making that clear ...
23:00:23 <alpounet> mgsloan, i loved the usage of lenses if edward's physics code, but i'm really affraid they're going to be overused and overall decrease readability
23:00:36 <alpounet> s/if/in/
23:00:46 <edwardk> > (["hi","there"],["new","haskellers"]) % partsOf biplate %~ (reverse :: String -> String)
23:00:48 <lambdabot>   (["sr","ellek"],["sah","wenerehtih"])
23:00:54 <startling> :t partsOf
23:00:55 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> ([a] -> f [a]) -> s -> f t
23:00:59 <Nereid> > ("ab","cde") % over (both.traverse) %~ ord
23:01:01 <edwardk> > (["hi","there"],2 :: Int, "new","haskellers", ()) % partsOf biplate %~ (reverse :: String -> String)
23:01:01 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator b0'
23:01:01 <lambdabot>            ...
23:01:03 <lambdabot>   (["sr","ellek"],2,"sah","wenerehtih",())
23:01:03 <Nereid> eh
23:01:16 <startling> > view partsOf [[1], [2], [3]]
23:01:17 <Nereid> whoa.
23:01:17 <yitz> edwardk: ok nice work. hope i have more time to read through it all more carefully soon
23:01:17 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Accessor
23:01:18 <lambdabot>               ...
23:01:40 <edwardk> > (["hi","there"], 2 :: Int, "new","haskellers", ()) % partsOf biplate %~ toUpper
23:01:40 <Nereid> ok, gotta see what this *plate business is about.
23:01:42 <lambdabot>   Couldn't match expected type `[a0]'
23:01:42 <lambdabot>              with actual type `GHC.Type...
23:01:54 <yitz> edwardk: did you really invent some type classes for the sole purpose of convincing ghc to produce neater error messages?
23:01:55 <edwardk> > (["hi","there"], 2 :: Int, "new","haskellers", ()) % partsOf biplate %~ (reverse :: String -> String)
23:01:57 <lambdabot>   (["sr","ellek"],2,"sah","wenerehtih",())
23:02:06 <shachaf> > (["hi","there"], 2 :: Int, "new","haskellers", ()) % biplate %~ toUpper
23:02:08 <lambdabot>   (["HI","THERE"],2,"NEW","HASKELLERS",())
23:02:09 <edwardk> yitz: yes
23:02:28 <mgsloan> alpounet: Yeah, I think Control.Lens actually makes a very good testcase for tools to aid comprehension of Haskell code.  (especially w.r.t types)
23:02:34 <yitz> edwardk: if so, that seems to indicate that there should be some better way of passing that kind of information to ghc. some pragmas or something.
23:02:50 <edwardk> yitz: they also helped in other more subtle ways i didn't expect until after i had them. for instance, it means that 'backwards' works on folds as well as traversals now
23:02:55 <edwardk> :t backwards
23:02:57 <lambdabot> LensLike (Control.Applicative.Backwards.Backwards f) s t a b -> LensLike f s t a b
23:03:01 <sopvop> edwardk: newtype Neither a b = Neither { _nor :: Either a b } this one is great :)
23:03:07 <shachaf> > (["hi","there"],["new","haskellers"]) % partsOf (both.traverse.traverse) .~ "GREETINGS"
23:03:09 <lambdabot>   (["GR","EETIN"],["GSw","haskellers"])
23:03:25 <edwardk> > ("hello","world")^.._2.backwards traverse
23:03:26 <shachaf> > (["hi","there"],["new","haskellers"]) % (partsOf.backwards) (both.traverse.traverse) .~ "GREETINGS"
23:03:28 <lambdabot>   can't find file: L.hs
23:03:28 <lambdabot>   "dlrow"
23:03:34 <shachaf> > (["hi","there"],["new","haskellers"]) % (partsOf.backwards) (both.traverse.traverse) .~ "GREETINGS"
23:03:36 <lambdabot>   (["hi","there"],["new","hSGNITEERG"])
23:03:43 <cornihilio> is there somewhere I can read about the subset of haskell that I'm limited to if I'm working on cabal?
23:03:50 <yitz> edwardk: aha. if the original motivation was just that, but it led to deeper insight, then that's a different story.
23:04:19 <cornihilio> hello?
23:04:19 <edwardk> yitz: anyways the main issue was that if i let them _unify_ and got an error you got a screen full of terrible noise and it looked like it was my fault.
23:04:42 <cornihilio> dcoutts_: if these are the only default packageDBs https://gist.github.com/4064228 then am I supposed to create a SpecificPackageDB for each package in the users .cabal that's installed?
23:04:43 <yitz> edwardk: but often introducing type classes can lead to some very nasty side effect you don't want. so you wouldn't want to have to do that just to get better error messages.
23:04:44 <edwardk> yitz: if i wound up with a type class error it says 'no instance of Settable Accessor' or 'no instance of Gettable Mutator' and you quickly realize its your fault ;)
23:05:02 <johnw> edwardk: would you mind if I add doctests for all the lens combinator, so that simple examples of usage would show up in the Haddock docs for each operator?
23:05:12 <edwardk> johnw: feel free to add more doctests
23:05:18 <johnw> cool
23:05:19 <shachaf> johnw: edwardk hates getting patches with examples and documentation.
23:05:25 <edwardk> shachaf: =)
23:05:29 <shachaf> That's his favorite part. He always wants to keep it to himself.
23:05:39 <sopvop> cornihilio: you may try #ghc channel, most cabal devs talk there I think
23:05:51 <edwardk> yeah. i live for 1000s of ("hello","world") examples =)
23:05:58 <johnw> lol
23:06:22 <johnw> we could switch to Guten Tag Erde
23:06:36 <yitz> > replicate 1000 ("hello","world")
23:06:38 <edwardk> keep in mind there are several hundred combinators, probably 3/4ths of which lack examples
23:06:38 <lambdabot>   [("hello","world"),("hello","world"),("hello","world"),("hello","world"),("...
23:07:03 <johnw> i'll keep snapshotting examples from our iRC chats, and turn some of those into doctests too
23:07:11 <shachaf> > genericReplicate (1000 * s) ("hello","world")
23:07:12 <edwardk> sure
23:07:13 <lambdabot>   [("hello","world"),("hello","world"),("hello","world"),("hello","world"),("...
23:07:13 <johnw> a lot of these tonight were extremely valuable
23:07:15 <shachaf> I bet that's infinite.
23:07:20 <shachaf> > genericReplicate x 1
23:07:22 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
23:07:27 <cornihilio> sopvop: thanks for the suggestion!
23:07:40 <yitz> 100's of combinators? do i really want this in my code?
23:07:58 <johnw> yitz: you want thousands, you just don't know it yet
23:08:07 <edwardk> yitz: i deliberately chose names for the most part that fall into portions of the namespace that folks don't use
23:08:37 <johnw> except for code that uses Data.Ratio...
23:08:39 <edwardk> yitz: i actually did a combinator frequency search on hackage to start this to make sure i was avoiding common names. i broke that rule for a handful where i felt it was worth it
23:08:46 <yitz> well ok but how will anyone ever be able to read my code without having spent weeks learning these combinators?
23:08:51 <shachaf> johnw: Hey, the namespace isn't the same as the symbolspace!
23:09:05 <shachaf> yitz: Most of the combinators follow simple patterns.
23:09:12 <shachaf> It's a bit of a combinatorial thing.
23:09:15 <johnw> simple if you know them, that is
23:09:16 <edwardk> yitz: lets take a look at about 120 of them, real quick
23:09:35 <sopvop> Thanks god edwardk didn't use x,y,z, i, j, k.
23:09:35 * typoclass lols
23:09:38 <johnw> edwardk has a pretty good table of them on his Wiki now
23:09:39 <yitz> so then there should be a few simple combinators that generate all those combinators
23:09:39 <edwardk> yitz: operator~ applies the operator to the target of a lens.     operator= applies the operator to the target of a lens in the current state.
23:09:50 <edwardk> yitz: prepend < to also get the answer back.
23:09:57 <edwardk> so fresh = id <+= 1
23:10:21 <edwardk> that is a fairly combinatorially explosive scheme, but its also dense and _consistent_
23:10:31 <johnw> true
23:10:34 <edwardk> yitz: there are. you can use those too
23:10:43 <johnw> i think you've done a great job with that philosophy, edwardk
23:10:46 <edwardk> over id (+1)  would be perfectly accceptable
23:10:54 <johnw> the lens operators could easily have become a nightmare
23:11:15 <shachaf> yitz: There's "+= 1", which is the same as "%= (+ 1)"
23:11:17 <edwardk> johnw: i learned from data-lens, where i just shoe-horned anything in that i needed without thought to consistency
23:11:19 <shachaf> It's just a shorthand.
23:11:35 <johnw> how does ~*~ fit the pattern?  "~" feels like a modifier, not a traversal
23:11:44 <edwardk> %=   looks arbitrary, but I have (%) :: a -> (a -> b) -> b   which is flip ($)
23:11:44 <liyang> Oh, I don't know.
23:11:49 <shachaf> ~*~ isn't even in lens
23:11:50 <typoclass> johnw: explosion at sea
23:11:57 <edwardk> johnw: it doesn't. liyang named it. i'd probably rename it to suit
23:12:42 <liyang> johnw: I wanted something reminiscent of *** or &&& but ~~~ seemed too special to use up so I mashed the keyboard.
23:12:43 <edwardk> so %= is the application of the (%) combinator to the target(s) of a lens, setter or traversal into the current state.
23:13:00 <edwardk> so learning the general rule guides you to the name of other operators
23:13:19 <edwardk> liyang: honestly it'll probably wind up non-infix
23:13:35 <yitz> edwardk: are these naming meta-rules documented somewhere too?
23:13:40 <liyang> edwardk: I think that's a better idea.
23:13:47 <simpson> :t (<+=)
23:13:48 <lambdabot> (Num a, MonadState s m) => SimpleLensLike ((,) a) s a -> a -> m a
23:14:02 <edwardk> yitz: i have a big chart of them. i could probably stand to write a paragraph on the operators page of the wiki through
23:14:21 <shachaf> You can pick up the pattern from https://github.com/ekmett/lens/wiki/Operators , at least.
23:14:22 <liyang> Do we really need a "+= n" shorthand for "%= (n +)" ?
23:14:29 <edwardk> https://github.com/ekmett/lens/wiki/Operators shows them so you can visually deduce the overall pattern
23:14:34 <edwardk> liyang: yes
23:14:45 <simpson> liyang: Yes.
23:14:51 <simpson> Well, we don't *neeeeeed* any of this.
23:14:55 <simpson> But it's sure nice.
23:15:02 <yitz> edwardk: that would be very good. then if i want to use them in a project, i could link to that, so that some qa engineer or whatever would have a fighting chance of figuring out what's going on
23:15:10 <edwardk> ballSpeed.both *= speedUp is much more readable
23:15:44 <edwardk> yitz: well, the nice thing is i keep most of these supplemental bits of information in a wiki, so folks can contribute that verbage if i don't get around to it
23:15:56 <yitz> yes
23:15:56 <edwardk> a lot of the documentation for lens is user contributed these days
23:16:21 <yitz> yes i see that there is lot of momentum now. that's very good.
23:16:25 * liyang isn't so fond of the OO-like usage, like omitting spaces around (.)…
23:16:37 <simpson> Then put spaces around it.
23:16:48 <edwardk> liyang: you and cale and a few others are definitely peas in a pod on that issue ;)
23:16:54 <simpson> I don't like it either. Not because I don't like OO, but because I expect spaces around my operators.
23:17:03 <shachaf> edwardk is a saboteur from C++land.
23:17:10 <edwardk> liyang: i use the spaceless version because it lets my brain 'chunk' the use of lenses better.
23:17:21 <edwardk> i don't require that of end users though ;)
23:17:46 <yitz> also there has been talk in ghc hq for quite a while about adding new syntax that would make those break without spaces around the .
23:17:52 <edwardk> it also encourages you to see them as tightly bound, which makes folks less surprised at the general lack of parens around concatenated lenses
23:18:30 <edwardk> well, we'll see. i haven't seen any progress on the record front, and i'm not expecting it any time soon. there are too many big issues in the way
23:18:34 <liyang> but function composition is tightly bound!
23:18:40 <liyang> Anyway…
23:19:07 <edwardk> one of the reasons i pushed forward on lens was that i wanted something i could seriously propose as a usable candidate to use as part of the accessors in a real record proposal
23:19:20 <Nereid> edwardk: how much of Control.Lens.Tuple did you write by hand? ;)
23:19:43 <edwardk> i don't care about SORF vs DORF or whatever, those are where the real issues lie, but i'm much happier with lenses compared to ad hoc messiness
23:19:58 <edwardk> Nereid: i'm embarassed to say, all of it. i macro'd my way through a lot of it
23:20:05 <Nereid> haha
23:20:07 <edwardk> but it was just macros in vim, not a script
23:20:19 <Nereid> yeah
23:20:26 <edwardk> whats worse is i wrote it 3 times
23:20:29 <Nereid> lol
23:20:35 <edwardk> because i was experimenting with different api designs
23:20:39 <edwardk> and that was the cleanest
23:20:48 <edwardk> earlier versions used type families rather than fundeps, etc.
23:20:55 <edwardk> but that turned out to lead to much much messier code
23:21:01 <edwardk> :t _1
23:21:03 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
23:21:16 <edwardk> now the arguments to Field1 are the same order as the arguments to 'Lens'
23:21:26 <Nereid> I see
23:21:29 <edwardk> _1 :: Field1 s t a b => Lens s t a b
23:22:31 * hackagebot http-conduit 1.8.3 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.3 (MichaelSnoyman)
23:23:08 <yitz> edwardk: you should tell spj about this fd vs. type families exercise. that is an important open question, and this is the first real empirical evidence i have ever heard of.
23:23:28 <edwardk> liyang: anyways, i knew that some things (the operators, the use of names like _2, the lack of spaces in lens concatenation i use in practice, etc) wouldn't sit well with a lot of folks. I can't say i'd do them differently though.
23:23:55 <edwardk> yitz: there is plenty of empirical evidence on both sides. if you took _either_ of them away from me at this point i'd be very mad
23:24:23 <edwardk> the mtl is plenty of empirical evidence
23:24:43 <edwardk> signatures in the mtl get much larger if you use type families. monads-tf signatures are about 10 characters longer on average
23:25:20 <edwardk> the few things that can be shorter aren't functions anyone writes ;)
23:25:21 <yitz> really? mtl works either way, not much difference. and if you try to use either approach extensively in practice - in my opinion they both collapse equally quickly.
23:26:01 <shachaf> @ty state
23:26:03 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
23:26:16 <shachaf> Compare to MonadState m => (StateType m -> (a, StateType m)) -> m a
23:26:35 <edwardk> get :: MonadState m => m (StateType m)    is longer than get :: MonadState s m => m s
23:26:46 <edwardk> _and_ you consume precious namespace in types for each one
23:26:59 <edwardk> i am not against type families. they are awesome and let you do lots of neat stuff
23:27:13 <edwardk> but i'm also not prone to want to get rid of fundeps.
23:27:27 <edwardk> class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s where
23:27:36 <edwardk> would be a pain in the ass without them
23:28:17 <Saizan> will we ever get to the point fundeps mean something wrt ~, though?
23:28:21 <edwardk> class (Functor f, Functor g) => Adjunction f g | f -> g, g -> f
23:28:21 <yitz> edwardk: it doesn't matter much if signatures are a little longer or a few more names are used. what matters is the big-O complexity of that.
23:29:19 <edwardk> yitz: yes, and here, the big-o complexity is terrible. because i wind up having to write a combinatorial explosion of different type equalities between all the different type family members to express that correctly.
23:29:46 <edwardk> Saizan: they basically do now, no?
23:29:57 <yitz> edwardk: so that's why i think that this is very important empirical evidence.
23:29:58 <edwardk> it all turns into TFs under the hood
23:30:00 <Nereid> > ("hello","world") ^. both
23:30:02 <lambdabot>   "helloworld"
23:30:04 <Nereid> fantastic
23:30:35 <edwardk> (^.) will use a monoid to stitch together multiple answers when applied to a Fold or Traversal
23:30:41 <Nereid> yep
23:31:34 <Nereid> :t view traverse
23:31:35 <lambdabot> (Traversable t, Monoid a) => t a -> a
23:31:39 <Nereid> yeah.
23:31:47 <Saizan> edwardk: you couldn't get ghc to typecheck something like foo :: (MonadState s m, MonadState s1 m) => TEq s s1; foo = Refl, haven't tested on 7.6.1 though
23:31:52 <yitz> > runIdentity (flip evalStateT ("hello","world") $ zoom both get) -- edwardk, where does the mappend come from here?
23:31:54 <lambdabot>   "helloworld"
23:32:35 <simpson> :t both
23:32:36 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
23:32:54 <Nereid> :t get
23:32:55 <lambdabot> MonadState s m => m s
23:33:16 <edwardk> :t Saizan: there appears to be an issue there, yeah
23:33:18 <Nereid> :t zoom both
23:33:18 <lambdabot> parse error on input `,'
23:33:19 <lambdabot> (Applicative (k c), Zoom m n k s (s, s)) => m c -> n c
23:33:44 <Nereid> it's hiding in that Applicative there.
23:33:51 <edwardk> but i think thats it just missing a few rules
23:34:17 <luite> lensify this: mconcat (map (\(_,_,_,y) -> f y) xs)
23:34:35 <yitz> are we running something in the list monad maybe, sequenced over the two tuple elements?
23:35:05 <edwardk> views (folded._4) f xs
23:35:09 <Saizan> edwardk: iirc ghc would have to be less liberal with Overlapping and/or Undecidable instances for the extra rules to be sound
23:35:30 <edwardk> xs^.folded._4.to f
23:35:42 <johnw> > views (folded._4) f xs $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
23:35:43 <lambdabot>   Not in scope: `xs'
23:35:44 <lambdabot>  Perhaps you meant one of these:
23:35:44 <lambdabot>    `x' (imported from D...
23:35:49 <johnw> > views (folded._4) f $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
23:35:51 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:35:51 <lambdabot>    (GHC.Show.Show a0)
23:35:51 <lambdabot>     ...
23:35:59 <edwardk> 'f'
23:36:02 <johnw> > views (folded._4) id $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
23:36:04 <lambdabot>   Ambiguous type variable `a0' in the constraints:
23:36:04 <lambdabot>    (GHC.Num.Num a0)
23:36:04 <lambdabot>      a...
23:36:18 <edwardk> > views (folded._4) Sum $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
23:36:21 <lambdabot>   Sum {getSum = 24}
23:36:25 <johnw> ah
23:36:27 <edwardk> you need a monoid
23:36:39 <Nereid> > views (folded._4) (:[]) $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]
23:36:40 <johnw> [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.folded._4.to Sum
23:36:41 <lambdabot>   [4,8,12]
23:36:42 <johnw> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.folded._4.to Sum
23:36:45 <lambdabot>   Sum {getSum = 24}
23:36:48 <edwardk> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.folded._4.to Sum
23:36:51 <lambdabot>   Sum {getSum = 24}
23:36:58 <luite> :)
23:37:09 <johnw> at least we agree :)
23:37:59 <edwardk> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.traverse._4.to Sum
23:38:01 <johnw> :[
23:38:02 <lambdabot>   Sum {getSum = 24}
23:38:06 <johnw> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.folded._4.to Identity
23:38:09 <lambdabot>   No instance for (GHC.Show.Show (Data.Functor.Identity.Identity t0))
23:38:09 <lambdabot>    aris...
23:38:17 <edwardk> Identity doesn't form a monoid
23:38:19 <johnw> i'd think Identity could easily be a monoid
23:38:20 <Nereid> Identity isn't a yeah
23:38:24 <edwardk> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^..traverse._4
23:38:27 <lambdabot>   [4,8,12]
23:38:31 <johnw> well, a semigroup
23:38:35 <simpson> Isn't Const a monoid?
23:38:44 <johnw> wait, i guess it can be that even
23:38:45 <simpson> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.traverse._4.to Const
23:38:45 <Nereid> Const a b is a monoid when a is a monoid
23:38:47 <lambdabot>   No instance for (GHC.Show.Show (Control.Applicative.Const t0 b0))
23:38:47 <lambdabot>    arisin...
23:38:48 <edwardk> simpson: iirc, its not actually implemented as such
23:38:57 <Nereid> or do you mean
23:39:02 <simpson> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.traverse._4.to (Const 42)
23:39:04 <lambdabot>   Couldn't match expected type `b1 -> b0'
23:39:04 <lambdabot>              with actual type `Cont...
23:39:09 <edwardk> > getConst $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^..traverse._2.to Const
23:39:10 <simpson> Bleh.
23:39:11 <lambdabot>   Couldn't match expected type `Control.Applicative.Const a0 b0'
23:39:12 <lambdabot>             ...
23:39:21 <edwardk> > getConst $ [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^.traverse._2.to Const
23:39:23 <lambdabot>   Could not deduce (Data.Monoid.Monoid
23:39:24 <lambdabot>                      (Control.Applicat...
23:39:29 <edwardk> yeah its not one
23:39:35 <edwardk> its Applicative if the arg is a Monoid
23:39:54 <edwardk> > [(1,2,3,4),(5,6,7,8),(9,10,11,12)]^..traverse._4
23:39:56 <lambdabot>   [4,8,12]
23:42:59 <Nereid> well for any Applicative f, f a is a monoid under *>
23:43:01 <johnw> is ^.. equiv. to partsOf?
23:44:06 <Nereid> > [1..4]^..traverse
23:44:08 <lambdabot>   [1,2,3,4]
23:44:11 <Nereid> > [1..4]^..partsOf.traverse
23:44:13 <lambdabot>   Couldn't match expected type `[t0]'
23:44:13 <lambdabot>              with actual type `[a0] -> ...
23:44:14 <Nereid> er
23:44:34 <johnw> > [1..4]^.partsOf.traverse
23:44:36 <lambdabot>   Couldn't match expected type `[t0]'
23:44:36 <lambdabot>              with actual type `[a0] -> ...
23:44:42 <johnw> > [1..4]^.partsOf traverse
23:44:44 <lambdabot>   [1,2,3,4]
23:44:47 <johnw> ok
23:46:14 <edwardk> ^.. foo and ^.partsOf foo    will do the same thing. the latter may take more time
23:46:23 <johnw> oh?  how are they different?
23:46:35 <edwardk> :t (^.partsOf traverse)
23:46:36 <lambdabot> Traversable t => t a -> [a]
23:46:39 <edwardk> :t (^..traverse)
23:46:40 <lambdabot> Traversable t => t a -> [a]
23:46:47 <edwardk> er
23:47:00 <edwardk> :t (\l -> ^..l)
23:47:02 <lambdabot> parse error on input `^..'
23:47:05 <edwardk> :t (\l -> ^.partsOf l)
23:47:07 <lambdabot> parse error on input `^.'
23:47:16 <edwardk> :t (\l -> (^.partsOf l))
23:47:18 <lambdabot> LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> s -> [a]
23:47:22 <edwardk> that goes through Bazaar.
23:47:30 <edwardk> :t (^.)
23:47:32 <lambdabot> s -> Getting a s t a b -> a
23:47:40 <edwardk> that uses 'Accessor' which might as well be Const
23:47:54 <ivanm> edwardk: I thought you were using git, not bzr... :p
23:48:25 <edwardk> =)
23:48:56 <edwardk> i mostly wanted a name that i could come up with a common intuition for, that was a little tongue in cheek and better than KleeneStore or CartesianStore =P
23:49:09 <edwardk> and it was unserious enough to get roconnor's goat ;)
23:49:25 <simpson> Getting goats is like 98% of what Haskell does. :3
23:49:41 <johnw> #haskell ^. goats
23:49:47 <simpson> The other 2% is mutating goats, but that's in the platform-dependent System.Unsafe.Goats, of course
23:50:09 <johnw> unsafeGoatse
23:50:36 <edwardk> plus, most usecases have the two indices the same, so you get 'a a r' type parameters for it sometimes
23:50:52 <edwardk> that was what steered me to the name originally
23:51:13 <edwardk> I had 'Baz a a r' in a sig before i had a good name
23:51:48 <nicoo> edwardk: KleeneXStore ?
23:51:59 <edwardk> nicoo: =)
23:52:13 <edwardk> i think the kleene store is where you go to buy your kleene stars.
23:52:52 <johnw> i think it's time for a new lens release
23:52:59 <johnw> i haven't gotten to say "cabal install lens" yet this week
23:53:00 <edwardk> the changelog size get to you?
23:53:03 <edwardk> hahah
23:53:14 <edwardk> i want to get better vector support into 3.3 first
23:53:22 <johnw> ooh, vector support!
23:53:27 <johnw> Data.Vector?  Data.Array?
23:53:31 <edwardk> Data.Vector
23:53:34 <edwardk> we already have Data.Array.Lens
23:53:40 <edwardk> vector is now in the platform
23:53:46 <edwardk> so it falls into scope
23:54:05 <johnw> how about conduit/pipes support?
23:54:25 <edwardk> currently we have Data.Vector.Generic.Lens,   and there will probably be various Data.Vector.Foo.Lens modules for technical reasons
23:54:28 <johnw> i could see having a getter for sources and a setter for sinks, and a lens for proxies
23:54:31 <edwardk> they are free to add lenses to either
23:54:46 <edwardk> the rule of thumb is if its just a 'getter' i don't package it
23:54:53 <johnw> ah
23:55:08 <edwardk> and lens itself limits its scope to the platform + things i needed to build lens itself
23:55:22 <edwardk> hence the separate aeson-lens package tanakh has, etc.
23:55:27 <johnw> true
23:56:12 <edwardk> still, alex keeps pushing other packages that technically fall in the platform on me. hence vector, and possibly 'split' support
23:56:26 <edwardk> mostly lenses for editing the splitter itself, etc.
23:56:38 <johnw> splitsOf :)
23:56:47 <edwardk> hah
23:58:46 <Nereid> when would one want to use folded instead of traverse?
23:58:58 <edwardk> Set is foldable but not traversanle
23:59:01 <edwardk> er traversable
23:59:11 <Nereid> I thought
23:59:13 <Nereid> @src Traversable
23:59:14 <lambdabot> class (Functor t, Foldable t) => Traversable t where
23:59:14 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
23:59:14 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
23:59:14 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
23:59:14 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
23:59:25 <Nereid> every Traversable was Foldable.
23:59:37 <edwardk> every traversable is foldable. set is also foldable
23:59:37 <Nereid> oops.
23:59:39 <Nereid> I'm silly.
23:59:42 <edwardk> these aren't contradictory =)
23:59:53 <simpson> Hm. Do Sets get sorted when folded?
