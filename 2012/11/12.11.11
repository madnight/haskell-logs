00:01:30 * hackagebot ghc-core 0.5.6 - Display GHC's core and assembly output in a pager  http://hackage.haskell.org/package/ghc-core-0.5.6 (ShachafBenKiki)
00:10:20 <Inst> why is haskell better than lisp?
00:11:05 <jfischoff> why not
00:11:05 <Eduard_Munteanu> @@ @google @protontorpedo
00:11:08 <lambdabot>  http://ircarchive.info/haskell/2007/4/17/63.html
00:11:08 <lambdabot>  Title: haskell and _ is not very HaskellIsh hasBar it is then :) I like has_bar, but ha ...
00:11:27 <Inst> haskell programmers are paid more than lisp programmers
00:11:30 <typoclass> Inst: haskell has a powerful type system :-)
00:11:30 * hackagebot resourcet 0.4.3 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.3 (MichaelSnoyman)
00:11:55 <Inst> lisp has more fanatic adherents than haskell, though
00:12:13 <Inst> you're supposed to be less blubby than lisp, which is a bit unbelieveble
00:12:43 <notdan> What should I use for graphics (mostly simple drawing) for Mac OS X? Gtk2hs or GLFW?
00:13:06 <typoclass> Inst: how do you mean, you consider lisp people to be not "blubby" at all?
00:13:25 <Eduard_Munteanu> @wn blubby
00:13:25 <lambdabot> No match for "blubby".
00:13:58 <Inst> http://www.paulgraham.com/avg.html
00:14:17 <typoclass> Eduard_Munteanu: i think he means "john is blubby" = "john can't imagine any language is better than his favorite language"
00:14:48 <Inst> well original meaning of blub is that it's a weaker programming language whose users can't imagine a more powerful programming language because they're locked into the programming paradigm
00:14:57 <shachaf> Haskell isn't better than lisp, Inst.
00:15:14 <shachaf> A discussion of "which programming language is better, A or B" is a waste of everyone's time.
00:15:15 <Inst> so if haskell is less blubby than lisp, that means that haskell's paradigm encompasses lisp's paradigm
00:16:08 <typoclass> notdan: not sure. folks seem to be quite fond of byorgey's diagrams library ...
00:16:25 <Cale> Inst: This kind of statement is pretty meaningless
00:16:25 <shachaf> The article that introduced the word "blub" jumped straight to a lattice (well, a semilattice), without considering partial orderings.
00:16:29 <Eduard_Munteanu> It's only a waste of time because it's been discussed before over and over.
00:16:34 <shachaf> But anyway that's a pointless discussion.
00:17:44 <Eduard_Munteanu> @protontorpedo -- let's move on
00:17:44 <lambdabot> windows is validating itelf a lot during ownloads altely
00:17:52 <Cale> Inst: "Better" and "worse" suggest that there's some objective way of comparing languages.
00:18:08 <Inst> Oh dear, sorry, I'm not trying to troll for responses
00:18:30 <Cale> Inst: If you'd like to hear why we prefer Haskell, that's a lot easier :)
00:18:53 <Inst> what happened to me is this; I wanted to learn Lisp and C/C++ at the onset because some Lispers were claiming it's an awesome programming language and your go-to for most needs; you spend less time and have less difficulty coding in lisp than in other languages
00:19:14 <Inst> I did a little bit more research and there's a significant performance disadvantage in some fields, however, and apparently it's not commonly used and has other drawbacks
00:19:24 <Inst> if i'm looking for easy coding, Python might be better
00:19:33 <typoclass> i think the only sensible way is doing some work in haskell, doing some work in a lisp (clojure seems popular these days ...), then making up your mind and saying "i like haskell better because it gets me correct results quicker" or whatever it may be
00:19:35 <dolio> Lattices aren't total orders, so what's the problem?
00:19:42 <Inst> I'm looking at Haskell because I found a bunch of posts about how CLispers were migrating to Haskell
00:19:46 <Eduard_Munteanu> If by easy you mean approachable, then Haskell doesn't excel at that.
00:19:48 <Cale> Python has probably worse performance issues than compiled lisp implementations do.
00:20:03 <Inst> and I saw on a salary search website that haskell is paid significantly better than Lisp
00:20:07 <Cale> (But that's a quagmire to evaluate in and of itself)
00:20:41 <otters> fortunately we won't have to until Inst forces the thunk
00:20:44 <typoclass> Inst: i'd argue that python is easier until you get to the stage of debugging, at which point it becomes time-consuming and painful
00:20:57 <Eduard_Munteanu> Inst: it's mostly useful as a side skill you can sell to your employer, rather than an actual language people use at their workplaces (unless you're lucky).
00:21:18 <dolio> Or, aren't necessarily total orders.
00:21:29 <Cale> Inst: That *might* have something to do with the fact that some of the few users of Haskell in industry are investment banks.
00:21:30 * hackagebot yesod-core 1.1.4.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.4.1 (MichaelSnoyman)
00:21:32 * hackagebot yesod-routes 1.1.1.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.1.1.1 (MichaelSnoyman)
00:21:33 <notdan> typoclass: well, I thought that diagrams is a library for generating static images?
00:21:34 * hackagebot yesod-static 1.1.1.1 - Static file serving subsite for Yesod Web Framework.  http://hackage.haskell.org/package/yesod-static-1.1.1.1 (MichaelSnoyman)
00:21:44 <typoclass> Inst: however, i feel on the question of documentation, python is doing a better job than haskell. that factors into the 'easy' thing as well
00:21:56 <Inst> no no no, python is supposed to be fast to code
00:22:00 <dolio> Yes, I think the Haskell salary stuff is kind of an accident. Although I don't know what Lisp people get paid for.
00:22:05 <Inst> there's some kind of paradigm based on programmer productivity versus machine efficiency
00:22:12 <Cale> Inst: My recommendation would just be to learn all the languages you can.
00:22:13 <Inst> lisp et al and python for that matter is fast and easy to code
00:22:19 <Inst> cale: time is not an unlimited resource
00:22:19 <Inst> :(
00:22:23 <typoclass> Inst: yes, fast to code, but _then_ you have to debug it :-/
00:22:29 <Cale> Okay, then learn Haskell :)
00:22:31 <Cale> heh
00:22:57 <Inst> typoclass: do you have lisp experience?
00:23:03 <Eduard_Munteanu> I disagree with Cale there a bit, learn as many *different* things as possible.
00:23:09 <Cale> Yeah, that's true
00:23:15 <typoclass> Inst: a little bit of clojure
00:23:16 <Eduard_Munteanu> And Haskell surely is different.
00:23:38 <Cale> If you don't have all the time in the world, you want to pick languages such that the convex hull of the languages you picked has as much volume as possible :)
00:23:48 <Eduard_Munteanu> Heh.
00:24:20 <typoclass> Inst: i feel that in haskell, it's hard to get things to compile, but once they do, they rarely have many bugs in them anymore
00:25:15 <Inst> how are the compilers, by the way?
00:25:25 <otters> GHC is the best compiler in the world
00:25:41 <Eduard_Munteanu> There's just one worth using for production code, GHC.
00:25:42 <Inst> compiled GHC score scores lower than gcc/g++
00:25:46 <mroman> It's not hard to compile stuff.
00:25:50 <Cale> Inst: In what?
00:25:53 <Inst> I mean on benchmarks
00:25:56 <mroman> It's only hard if you don't know wath you are doing ;)
00:25:58 <Inst> programming language shoot-out
00:26:01 <mroman> *wath
00:26:22 <Inst> you're faster than C# on mono
00:26:28 <Eduard_Munteanu> You said wath wath.
00:26:37 <mroman> ah
00:26:37 <Inst> or approximately as fast, but since you're functional you're easier to code for than C#
00:26:38 <mroman> damn :(
00:26:40 <mroman> *wath
00:26:43 <mroman> *what
00:26:47 <pharaun> Inst: probably faster than python
00:26:47 <typoclass> Inst: i think you'd be hard pressed to find anything that scores higher than gcc. *and* i'd argue that runtime speed isn't everything. for instance, programmer time is also an issue
00:26:54 <Inst> yeah
00:27:18 <Inst> you're faster than clisp in this regard, though
00:27:21 <mroman> Fortran scores the hell out of everything.
00:27:29 <pharaun> if something approaches gcc then its probably fast enough for most purposes, beside if it *really* matters, there's always the haskell->c bindings and asm
00:27:46 <Inst> what is the haskell-> c bindings / asm?
00:27:48 <Cale> Inst: Of course, what the programming language shootout really measures is how much time people are willing to spend crafting programming language shootout entries.
00:28:21 <typoclass> (if speed is as important as people claim, we should probably abandon all software and only do everything in hardware ...)
00:28:36 <Eduard_Munteanu> Inst: Haskell code can call C code.
00:28:36 <Inst> well, that's an absolutist statement
00:28:40 <mroman> Cale: That's one of the thing it measures.
00:28:44 <mroman> *things
00:28:57 <Inst> for a given project the language selected is in part a function of both coding difficulty and efficiency
00:29:03 <mroman> but you can probably spend infnite time on a python entry and you will still not be able to beat fortran.
00:29:07 <Inst> DSPs are often coded in assembly, whereas there's a large python ecosystem
00:29:26 <shachaf> Is there a nice way of represent a set of flags in Haskell?
00:29:37 <Eduard_Munteanu> shachaf: what sort of flags?
00:29:47 <pharaun> mroman: not if you could abuse the underlaying c stuff in python for ex
00:29:57 <mroman> pharaun: True.
00:30:08 <Eduard_Munteanu> @shachaftorpedo? :P
00:30:08 <lambdabot> Unknown command, try @list
00:30:15 <arbn> Why does almost everyone confuse languages with their implementations?
00:30:29 <pharaun> but for *most* parts you probably won't be able to approach fortran but for some operations there's *lots* being done in the C part of the language (re python)
00:30:35 <otters> because people use the implementation
00:30:36 <Inst> Eduard: thanks re bindings / asm
00:30:48 <mroman> arbn: Because that's what people assume.
00:30:50 <Cale> mroman: In Haskell's case, I suspect the entries can be made almost arbitrarily good if people are willing to spend enough time on them, because of all the low-level things you can do without too much trouble. You do end up with fairly contrived programs after a while though. I seem to recall many of them are already looking pretty worked over.
00:31:02 <Inst> Cale: curious, why did the financial industry pick up on haskell?
00:31:08 <mroman> When you say "that python script is slow" then you are usually referring to the script running under the most common interpreter.
00:31:18 <pharaun> same thing with ruby
00:31:27 <shachaf> Eduard_Munteanu: You know, a bunch of options to a program.
00:31:32 <pharaun> you have mrv/yarv/jruby/etc, and yeah
00:31:43 <pharaun> *mri ? i forgot what they called the 1.8 series
00:31:46 <arbn> Inst: They got tired of OCaml. :P
00:31:52 <shachaf> Eduard_Munteanu: The sort of thing you would use an integer and | and & to manipulate in C.
00:31:56 <mroman> Cale: Yes. Most of them already don't look like neat haskell code anymore :)
00:32:05 <Eduard_Munteanu> Hm.
00:32:18 <mroman> shachaf: Data.Bits and WordN?
00:32:29 <pharaun> then again *most* things probably does not look like neat <x> language code anymore after you've gone at them with a hatchet
00:32:36 <Eduard_Munteanu> Nah, that's a bit gross in Haskell.
00:32:48 <Nereid> write a nice interface to it?
00:32:50 <typoclass> shachaf: if you mean command line options, there's at least 3 or 4 approaches these days ... lemme think
00:32:50 <Eduard_Munteanu> Maybe a Set of flags?
00:33:04 <Cale> Inst: I don't know the real answer, but in general, Haskell is good for things you want a fairly high level of assurance will do the right thing, and it's also is rather good for domain specific languages.
00:33:08 <Nereid> Bool-valued functions?
00:33:11 <Eduard_Munteanu> (where the flags are just a datatype)
00:33:26 <pharaun> Inst: its also highly enjoyable (imho) :)
00:33:40 <mroman> Yeah. datatype + Data.Set should be totally fine then?
00:33:40 <pharaun> i program in python for my day job, and i really enjoy lots of the stuff that haskell offers up
00:34:02 <Cale> Inst: The fact that you can reason about the behaviour of Haskell functions in an equational way is probably convenient. In the financial guys' case, it would be natural to think of Haskell as a super-powered spreadsheet as well. :)
00:34:30 <Eduard_Munteanu> Or you could argue for a Set-variant that was implemented as a bitset behind the scenes.
00:34:32 <Cale> (The evaluation order is demand-driven and there are no side-effects.)
00:34:41 <Eduard_Munteanu> Requiring just an Enum instance, or something like that.
00:34:49 <shachaf> typoclass: I mean flags in general.
00:34:58 <Nereid> Eduard_Munteanu: that's what I was thinking.
00:36:34 <Nereid> Eduard_Munteanu: and Boudned
00:36:37 <typoclass> shachaf: i think i'd just use data ... = Flag1 | Flag2, and then lists of those, and "F1 `elem` flags"
00:36:55 <Nereid> sounds slow
00:37:01 <Eduard_Munteanu> Nereid: hrm, so you could check if they fit in a given WordN?
00:37:04 <Nereid> it's what SDL does, though
00:37:09 <Nereid> Eduard_Munteanu: and so you can tell where the first one is
00:37:35 <Eduard_Munteanu> Ah, I was expecting the user to just derive Enum.
00:38:00 <Nereid> oh, I guess yeah, it would be mostly about the size
00:38:01 <typoclass> > "⚐" -- Cale: i was wondering why this is ok in ghci, but not in lambdabot. any ideas?
00:38:01 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
00:38:04 <Eduard_Munteanu> But yeah, you probably want to force certain invariants.
00:38:08 <Nereid> > fromEnum (maxBound :: Ordering)
00:38:09 <lambdabot>   2
00:38:17 <typoclass> (not that it's really important, just wondering)
00:38:37 <shachaf> typoclass: Yes, but I'm hoping for something nice.
00:38:44 <shachaf> What sort of answer would conal give me?
00:38:49 <Cale> typoclass: meh, some weird encoding issue. Lambdabot is probably using ByteString.Char8 somewhere that it shouldn't be.
00:39:02 <typoclass> Cale: i see, thanks
00:39:04 <shachaf> lambdabot is a hack.
00:39:40 <typoclass> shachaf: so you mean 'nice' in the sense of more type-safe?
00:39:50 <Nereid> what's not type-safe about lists?
00:40:08 <typoclass> Nereid: ... exactly, that's what i'm wondering :)
00:40:14 <shachaf> typoclass: For example.
00:40:19 <shachaf> Well, [Flag] is too big.
00:40:22 <Nereid> fwiw, SDL uses lists for flags
00:40:32 <shachaf> (Flag -> Bool) is the right size but kind of not nice.
00:40:56 <Nereid> I still think you could get something nice out of a bit string wrapped in a nice interface.
00:41:12 <typoclass> shachaf: you mean, you have tons and tons of flags and are worried about memory consumption?
00:41:26 * typoclass is still not clear on what the problem is, sorry
00:41:28 <shachaf> No, I mean there are more values of type [Flag] than there are possible sets of flags.
00:41:35 <typoclass> ooh
00:41:41 <shachaf> For example, [A,A] ~ [A]
00:41:50 <typoclass> yep, sure, that's true
00:42:22 <Eduard_Munteanu> Lists aren't really appropriate here, they're just cheap (not in the right sense) sets.
00:43:03 <typoclass> right. cheap in the sense of it's so damn easy to do `elem`
00:43:57 <shachaf> More like cheap in the sense of it's really syntactically cheap to type [A,B,C]
00:44:35 <Nereid> how often are the flags going to be accessed?
00:45:40 <typoclass> if it's only 3 or so flags, you could plausibly use a (Bool, Bool, Bool). it'd let you do stuff like "foo (_, False, _) = ...", which would probably look nice
00:45:47 <Nereid> that looks gross
00:46:31 * hackagebot attoparsec-conduit 0.5.0.3 - Consume attoparsec parsers via conduit.  http://hackage.haskell.org/package/attoparsec-conduit-0.5.0.3 (MichaelSnoyman)
00:46:33 * hackagebot blaze-builder-conduit 0.5.0.2 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.5.0.2 (MichaelSnoyman)
00:47:19 <Eduard_Munteanu> You could fromList them, possibly using a shorter convenient name for that.
00:49:53 <typoclass> Eduard_Munteanu: you mean Data.Set.fromList ... yeah that's a nice way
00:50:11 <Eduard_Munteanu> Yes.
00:51:35 * hackagebot conduit 0.5.4.1 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.4.1 (MichaelSnoyman)
00:51:37 * hackagebot filesystem-conduit 0.5.0.2 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.5.0.2 (MichaelSnoyman)
00:51:39 * hackagebot imagesize-conduit 0.5.0.2 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-0.5.0.2 (MichaelSnoyman)
00:51:41 * hackagebot zlib-conduit 0.5.0.2 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.5.0.2 (MichaelSnoyman)
00:51:43 * hackagebot html-conduit 0.1.0.4 - Parse HTML documents using xml-conduit datatypes.  http://hackage.haskell.org/package/html-conduit-0.1.0.4 (MichaelSnoyman)
00:56:45 * hackagebot wai-app-static 1.3.0.4 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.3.0.4 (MichaelSnoyman)
00:56:47 * hackagebot xml-conduit 1.0.3.3 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-1.0.3.3 (MichaelSnoyman)
00:56:49 * hackagebot classy-prelude 0.4.0.1 - A typeclass-based Prelude.  http://hackage.haskell.org/package/classy-prelude-0.4.0.1 (MichaelSnoyman)
00:56:51 * hackagebot wai-extra 1.3.0.4 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.3.0.4 (MichaelSnoyman)
00:56:53 * hackagebot xml-hamlet 0.4.0.3 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.4.0.3 (MichaelSnoyman)
01:01:55 * hackagebot classy-prelude-conduit 0.4.0.1 - conduit instances for classy-prelude  http://hackage.haskell.org/package/classy-prelude-conduit-0.4.0.1 (MichaelSnoyman)
01:01:57 * hackagebot warp 1.3.4.3 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.4.3 (MichaelSnoyman)
01:05:52 <charliesome> this panics ghc: https://gist.github.com/f4a6635c2f8138e24a6a
01:05:53 <charliesome> what should i do
01:06:53 <shachaf> charliesome: GHC doesn't support nullary classes.
01:06:58 <shachaf> Which version are you using?
01:07:07 <shachaf> Wait, is M meant to be nullary?
01:07:10 <charliesome> 7.4.2
01:07:18 <charliesome> what's nullary?
01:07:33 <shachaf> No parameters.
01:07:37 <shachaf> "class M where ..."
01:07:40 <charliesome> ah
01:07:55 <charliesome> it had one but i removed it when i was trying to boil it down to a minimal breaking case
01:08:38 <shachaf> Oh, what do you know, the whole file at once crashes 7.4.
01:08:52 <shachaf> 7.6 just gives an error
01:08:55 <shachaf> instance M a => M b => M (a -> b) where
01:09:09 <charliesome> so i should probably update my ghc?
01:09:11 <shachaf> Do you mean (M a, M b) => ?
01:09:17 <shachaf> You could update your GHC.
01:09:30 <charliesome> is (M a, M b) => how i do multiple type parameters?
01:09:39 <shachaf> You could also not write malformed code, if you want a quick workaround. :-)
01:09:40 <shachaf> Yep.
01:10:06 <shachaf> The foo => bar => thing isn't Haskell 2010.
01:10:22 <charliesome> hehe, well it would've been nice if ghc told me the code was malformed before it panicked
01:12:07 <typoclass> charliesome: sure. it is a compiler bug, i don't think the compiler should ever crash
01:12:25 <charliesome> tried to register on trac, but the captcha's broken
01:12:33 <shachaf> charliesome: Agreed.
01:12:42 <shachaf> Fortunately it's fixed in 7.6.
01:12:49 <charliesome> ah cool
01:13:19 <typoclass> charliesome: i think the ghc trac has a guest account, you don't need to register
01:13:34 <charliesome> typoclass: if it's been fixed in a later ghc i won't bother reporting it
01:14:55 <mikeplus64> > fix (\loop x y -> if x + y == 5 then (x,y) else loop (y+2) (x-1)) 1 0
01:14:57 <lambdabot>   (3,2)
01:17:20 <mikeplus64> @src fix
01:17:20 <lambdabot> fix f = let x = f x in x
01:41:32 * hackagebot warp 1.3.4.4 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.3.4.4 (MichaelSnoyman)
01:41:34 * hackagebot hamlet 1.1.1.1 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.1.1.1 (MichaelSnoyman)
01:46:28 * Nastya http://vk.com/id189043294 - it's me join me)
01:55:53 <notdan> Hi guys. I was wondering if I can get some advice on my program. I am working on a simple EDSL for Turtle graphics, so for my interface looks like this: http://hpaste.org/77564  I do, however, want to easily compose my programs (such as forward, left, right, etc), so I thought that the monad class would be a right choice. But my Program type is very simple and of kind * instead of * -> *
01:56:11 <notdan> Frankly, I don't know what to do. Use a phantom type argument : newtype Program a = ... ?
01:56:44 <shachaf> You can make a free monad of it.
01:57:32 <shachaf> It wouldn't be a phantom type -- you'd actually have an "a" in there somewhere (sometimes).
01:57:55 <notdan> Hm, can you please elaboraete?
01:58:00 <shachaf> Anyway, maybe Monad is too much for what you have. Can output from one command become input to another?
01:58:11 <shachaf> If not, there it might just be a monoid or something.
01:58:35 <shachaf> It would be nice if you could get the IO business out of it completely.
01:58:43 <shachaf> Do you have a complete list of operations you want to support?
01:58:59 <notdan> It does. For example, if we have a program: right 10; forward 10. The input turtle of `forward' is the output turtle of `right'
01:59:03 <bitonic> shachaf: yay for ghc-core!
01:59:21 <shachaf> bitonic: Yay!
01:59:25 <shachaf> I already took out a couple of features.
01:59:27 <notdan> shachaf: I don't have a complete list, but I want to implement most of the functionality
01:59:28 * shachaf = evil dictator
01:59:30 <bitonic> :(
01:59:36 <shachaf> bitonic: They were buggy, though.
01:59:51 <bitonic> well for example I never looked at the assembly, so if it's related to that I don't care.
01:59:55 <shachaf> I might rewrite them properly later.
02:00:00 <shachaf> It's related to that. :-)
02:00:15 <shachaf> notdan: Of the functionality of what?
02:00:28 <notdan> shachaf: of the LOGO language
02:00:31 <shachaf> You should at least come up with an idea of what sorts of programs you have.
02:01:03 <notdan> The usual programs one might write in LOGO/Turtle Graphics
02:01:15 <notdan> I am doing this lab assignment: http://www.cse.chalmers.se/edu/course/afp/lab1.html
02:01:17 <shachaf> data Program = Forward Distance | Right Angle -- maybe this is all you need. :-)
02:01:21 * typoclass could have sworn there already was a hackage package that offered some logoish language ...
02:01:29 <notdan> (I am not a student btw, just stumbled upon that page on the internet)
02:01:35 <shachaf> Then you can write runProgram :: Program -> IO ()
02:01:54 <notdan> shachaf: Well, I thought about that, but I want to have a shallow embedding
02:01:58 <shachaf> Of course, you want more than Fwd and Rt. But you should figure out what.
02:01:59 <bitonic> shachaf: I think you need `-fno-warn-unused-do-bind' :P
02:02:03 <shachaf> ?
02:02:06 <shachaf> bitonic: ?
02:02:13 <shachaf> I thought I got rid of all of those.
02:02:16 <shachaf> Which version are you installing?
02:02:21 <bitonic> oh, sorry, my bad.
02:02:31 * bitonic hides
02:03:20 <shachaf> notdan: That first "?" was to you. I'm not sure what you mean.
02:04:37 <notdan> shachaf: Well I want to have a shallow embedding http://www.cse.chalmers.se/edu/course/afp/lab1.html and write most of the stuff in Haskell, instead of the implemented pseudo-languaged
02:05:06 <bitonic> `cabal update' is soooo slow
02:05:11 <shachaf> You can use both Haskell and the pseudo-language!
02:07:08 <notdan> I wholly understand the possibility of your approach, it's just that I've used deep embedding before, so now I want to try making eDSL using shallow embedding
02:07:30 <shachaf> I'm not talking about expressing your logic in the pseudo-language.
02:07:34 <shachaf> Just your operations.
02:07:38 <bitonic> what was the difference between "embedded" and simple DSL?
02:08:41 <Sonderblade> say you have a pure function for visiting a tree structure, can you create that function so that it can take a callback function in the IO monad?
02:09:19 <shachaf> What?
02:09:58 <Sonderblade> for example, if the tree contains a bunch of urls and the callback function fetches an url
02:10:15 <bitonic> Sonderblade: you probably want Traversable
02:10:18 <Eduard_Munteanu> :t mapM
02:10:20 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
02:10:36 <bitonic> @info Traversable
02:10:36 <lambdabot> Traversable
02:10:36 <shachaf> You probably want to know what it is you want to do. :-(
02:10:45 <bitonic> @src Traversable
02:10:45 <lambdabot> class (Functor t, Foldable t) => Traversable t where
02:10:46 <lambdabot>     traverse    :: Applicative f => (a -> f b) -> t a -> f (t b)
02:10:46 <lambdabot>     sequenceA   :: Applicative f => t (f a) -> f (t a)
02:10:46 <lambdabot>     mapM        :: Monad m => (a -> m b) -> t a -> m (t b)
02:10:46 <lambdabot>     sequence    :: Monad m => t (m a) -> m (t a)
02:10:59 <notdan> shachaf: well you are advising me to basically create an AST of my language using Haskell's datatypes and write an intepreter function. I just want to do it the other way around, I don't know which way is better but for the sake of education I want to try it the way I haven't done anything similarly
02:11:06 <Eduard_Munteanu> I think bitonic guessed it right.
02:11:17 <shachaf> I think guessing is bad.
02:11:30 <shachaf> We should discourage people from asking the sorts of questions that require mind-reading to answer.
02:11:38 <shachaf> (By encouraging them to ask better questions.)
02:11:41 <Eduard_Munteanu> I guess it is bad after all. :P
02:11:53 <Eduard_Munteanu> Yeah.
02:12:06 <bitonic> Sonderblade: better your question
02:12:07 <Sonderblade> bitonic: yeah that looks right
02:12:09 <PatrickRobotham> shachaf: Parapsychology is a much more useful skill than programming or mathematics :P
02:12:43 <shachaf> PatrickRobotham: What about the expected value of studying one or the other?
02:13:45 <notdan> Here's a good example of deep vs shallow embedding: http://www.cse.chalmers.se/edu/course/afp/lectures/lecture3/Program/Deep1.hs.html http://www.cse.chalmers.se/edu/course/afp/lectures/lecture3/Program/Shallow.hs.html
02:14:22 <shachaf> All I'm saying is to get IO out of your program type.
02:14:45 <shachaf> I don't care how you do it.
02:15:00 <pdxleif> @type id
02:15:02 <lambdabot> a -> a
02:15:12 <typoclass> Sonderblade: i don't know about your tree case, but it might come out similar to doing 'map' on a list, resulting in a list of IO actions. that's all pure so far. you can then do 'sequence' (or similar) on the result list, and this is the impure part
02:15:35 <bitonic> notdan: get it, thanks.  deep embedding seems to be what you usually see.
02:15:36 <pdxleif> Didn't lambdabot used to give forAlls?
02:15:47 <bitonic> lambdabot has changed.
02:15:52 <shachaf> pdxleif: Yep.
02:16:03 <bitonic> lambdabot: you're not the lambdabot we used to know
02:16:12 <bitonic> used to know?  mhm
02:16:19 <notdan> bitonic: percisely, that's why I want to try an other one
02:16:49 <notdan> shachaf: well, I know that my types are quite bad right now, that's why I came to ask the question
02:17:03 <shachaf> OK, so first figure out what sorts of things you want to express.
02:17:19 <bitonic> notdan: it depends what you need to do.  "shallow" embeddings are basically ordinary Haskell programs...
02:17:41 <bitonic> well not that deep one aren't.  but there is less of a new language
02:18:06 <bitonic> for the LOGO thing, I think you want a deep one.
02:18:06 <notdan> shachaf: I did figure that out. The LOGO language, with most of its' constructs
02:18:37 <shachaf> You haven't said, for example, whether one program can depend on the "output" of another.
02:19:30 <notdan> I did say that. The program takes a turtle as input and outputs another turtle (by moving it around). You can compose programs in obvious way
02:20:03 <shachaf> So the answer is no.
02:20:16 <shachaf> Well then, I don't know why you want a monad.
02:20:23 <bitonic> me neither
02:21:15 <bitonic> just start with the obvious way, what shachaf said (`data LOGO = Forward | Right | Whatever'), and then you can have a `draw :: [LOGO] -> IO ()'
02:21:36 <shachaf> @google byorgey functional pearl monoid
02:21:39 <lambdabot> http://www.cis.upenn.edu/~byorgey/pub/monoid-pearl.pdf
02:21:40 <lambdabot> Title: ≡ ] , , [
02:21:45 <bitonic> nice title
02:22:08 <notdan> Ok shachaf, I guess you are right, I'll look into monoids
02:22:19 <notdan> bitonic: but that's exactly what I do not want to do
02:22:26 <bitonic> notdan: I don't see why you have to start from the abstraction
02:22:36 <bitonic> the abstraction should just surface at some point
02:22:58 <bitonic> since you don't really know what you want, I suggest some exploratory work :P
02:27:58 <pauser> hello, what is the difference between .hs and .lhs (literate Script). is that just the name ?
02:28:38 <lolcathost> pauser: http://www.haskell.org/haskellwiki/Literate_programming
02:29:43 <pauser> thanks :D
02:42:37 <Vyn> Hi, byorgey. You there? I finished writing that function for Fike's order permutation
02:43:37 <shachaf> @localtime bylzz
02:43:38 <lambdabot> Local time for bylzz is Sun Nov 11 11:43:18 2012
02:43:42 <shachaf> Er.
02:43:44 <shachaf> @localtime byorgey
02:43:45 <lambdabot> Local time for byorgey is Sun Nov 11 05:43:26 2012
02:44:50 <cornihilio> dcoutts_: hey, I think I'm sort of the on the way to getting the --user flag working, but I think I'm creating the user package db incorrectly. https://gist.github.com/4054497
02:45:36 <cornihilio> dcoutts_: does SpecificDB expect to be pointed at an individual package? I was looking at the source and I'm hoping/believe that I can just point it at the dir
02:45:47 <nand`> What kind of work has been done on getting weak typing into Haskell, or rather some subset of Haskell? I have a series of types that are isomorphic; and I want to be able to automatically coerce these as needed. I can't just use the same type for everything because the user should be free to choose which representation makes it easiest to express his value
02:45:47 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
02:47:01 <b52> hey
02:47:07 <nand`> preferably this should be on an entirely automatic basis, with the user needing no extra annotations
02:47:19 <nand`> otherwise I can probably live with ‘convert’ and a MPTC or something
02:48:26 <b52> is there a datatype to represent real numbers without loss of precision ?
02:48:43 <shachaf> There's CReal
02:49:06 <shachaf> Of course real (computable) real numbers are pretty annoying to work with. :-)
02:49:14 <shachaf> For example you can't check that two are equal.
02:50:18 <nand`> (there's also Sym, which has something to do with symbolic representations of numbers, but I haven't quite figured out what exactly it does and doesn't)
02:50:18 <b52> but i can assume they are in a certain span
02:50:36 <adek05> Can I install cabal without intstalling haskell-platform? I am using AWS and compiling haskell platform fails because I run out of memory when linking cabal...
02:51:19 <b52> shachaf: the same should be the case for any real number type
02:51:52 <shachaf> b52: Right.
02:53:49 <ivanm> adek05: yes, as long as you have GHC
02:53:59 <ivanm> there's a bootstrap.sh script in the cabal-install tarball
02:54:14 <ivanm> but, if you're running out of memory then, I doubt it's a platform issue
02:54:26 <ivanm> alternatively, just copy a pre-built cabal-install binary from somewhere else?
02:54:57 <adek05> ivanm: I think that when I am building haskell platform LD keeps cache somewhere in memory and that is the issue it is killed with 9 by OS
02:56:49 <Sonderblade> @hoogle Database
02:56:50 <lambdabot> package database-study
02:56:50 <lambdabot> package usb-id-database
02:58:38 <adek05> ivanm: and i think that OpenGL compilation prior cabal makes memory shrink
02:58:49 <ivanm> hmmm
02:59:49 <pauser> is it possible to save a thing temporary , i dont want to do this here http://paste.ubuntu.com/1350259/
03:01:39 <byorgey> pauser: let xs = blah in ... xs ... xs ...
03:02:02 <byorgey> pauser: or depending on the context you could do  .... xs ... where xs = blah
03:02:34 <ivanm> where clauses don't play well with explicit SCC pragmas :(
03:02:42 <byorgey> e.g.  let xs = [ x | x < t, ... ] in if null xs then "0" else xs
03:02:48 <ivanm> (I think it's how the desugaring works
03:02:54 <ivanm> s/$/)/
03:03:18 <nand`> huh
03:03:22 <nand`> “Not in scope: type constructor or class `Constraint'” <- ConstraintKinds is enabled
03:03:22 <nand`> do I have to import something to get the kind?
03:03:38 <byorgey> pauser: also, btw, using 'null' is slightly nicer than checking for equality with the empty list
03:03:57 <ivanm> byorgey: s/slightly// ;-)
03:03:59 <nand`> the example in http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/constraint-kind.html fails to compile for me, even with -XConstraintKinds -XTypeFamilies
03:06:06 <byorgey> nand`: which example?
03:06:56 <nand`> the one that starts with ‘type family Typ a b :: Constraint’
03:07:37 <byorgey> hmm, you're right, I get that too
03:08:25 <nand`> ah
03:08:27 <nand`> it's in GHC.Prim or GHC.Exts
03:08:27 <nand`> this should really be mentioned in the documentation for that flag
03:09:02 <byorgey> http://stackoverflow.com/questions/9450558/whats-the-constraint-kinds-syntax-for-ghc-7-4-1
03:09:05 <byorgey> yeah
03:09:46 <pauser> let xs = .. works fine thanks, btw it made a caffe for me thats why im writing 8 min later :D
03:10:17 <Marenz> greetings
03:13:49 <byorgey> hi Marenz
03:17:56 <shachaf> I wonder whether there should be a special alias of "traverse" just for Maybe.
03:18:10 <shachaf> It would be silly, of course. But seeing "traverse" is confusing.
03:18:40 <Eduard_Munteanu> How so?
03:18:49 <Eduard_Munteanu> :t traverse
03:18:50 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
03:19:03 <nand`> I don't see why; you're traversing a single value that may or may not be there
03:24:22 <Marenz> Hmm I am a bit surprised that that cabal-dev is not in my distributions repository (arch linux)
03:24:39 <jing> hey all
03:25:15 * ivanm waves idly in jing's general direction
03:26:27 <pordan30> searching hackage, i can't find a library containing the generalized functor, applicative, and monad typeclasses (either using multiparameter type classes or associated types). has anyone created such a package, or is suck a package in general use?
03:27:18 <shachaf> Which generalization are you talking about here? :-)
03:29:15 <pordan30> the one permitting class constraints, not gfunctor from the generics library; those are the only two i'm aware of
03:30:13 <pordan30> nevermind, i believe they are called restricted functor / monads in the standard library. i suppose i was searching for the wrong thing.
03:31:21 <Sonderblade> @hoogle hdbcConnect
03:31:21 <lambdabot> No results found
03:31:29 <Marenz> the archlinux link at haskell platform is a 404
03:32:52 <Marenz> what exactly is cabal-dev?
03:33:03 <neutrino> have you ever used python?
03:33:09 <neutrino> it's like python's virtualenv without the suck.
03:33:10 <Marenz> reluctantly
03:33:12 <ivanm> Marenz: an implementation of sandboxing when developing haskell packages
03:33:20 <Marenz> Ah, I see
03:33:23 <ivanm> neutrino: but with it's own suck in return? ;-)
03:33:26 <neutrino> ivanm: isn't it also useful for production?
03:33:31 <Marenz> having trouble installing it
03:33:42 <neutrino> don't bother for now
03:33:53 <neutrino> just install everything as regular user and if anything goes wrong nuke your .cabal
03:34:06 <Marenz> I need it for an application that I want to compile & modify eventually
03:34:17 <Marenz> it uses it in the makefile
03:34:26 <ivanm> neutrino: well, developing/building-and-releasing maybe
03:34:43 <ivanm> my "production" is "cabal sdist && cabal upload dist/foo-version.tar.gz" :p
03:34:53 <neutrino> right
03:35:03 <ivanm> the next release of cabal-install is meant to have native sandboxing support
03:35:15 <Marenz> well, I guess it could be modified to work without cabal-dev.. I just have no idea yet... https://github.com/jgm/gitit2/blob/master/Makefile
03:36:08 <neutrino> yeah just replace cabal-dev with cabal.
03:36:34 <Marenz> that easy?
03:36:42 <neutrino> i believe so. try and see.
03:37:29 <Marenz> cabal: unrecognized option `--cabal-install-arg=-fblaze_html_0_5'
03:37:49 <ivanm> Marenz: any particular reason for wanting to use the pre-release of pandoc?
03:38:32 <Marenz> ivanm, I am not the author of that. my first step is, getting this application to compile. Then I start hacking it :)
03:39:47 <neutrino> Marenz: try installing without that switch.
03:41:26 <Marenz> seems to work.. getting some package list fisrt
03:41:46 <neutrino> right, it's compiling the deps
03:43:11 <Marenz> hmm it just says the deps are missing. doh.
03:43:13 <cornihilio> does anyone know how traceEvent/traceEventIO output can be viewed with threadscope?
03:43:37 <Marenz> anyway to get it to install those automatically?
03:44:27 <Marenz> ah..  cabal install seems to do it
03:44:35 <Marenz> but fails with conflict
03:44:36 <Marenz> darn
03:44:47 <neutrino> can you post the error message on hpaste?
03:45:41 <ivanm> Marenz: I know you're not the author of pandoc
03:45:47 <hpaste> Marenz pasted “Cabal install error” at http://hpaste.org/77567
03:45:51 <ivanm> but I take it you want to help out with development?
03:46:16 <Matthias|PC> I wrote this function to reverse a list (I can't use the built in reverse, homework):
03:46:17 <Matthias|PC> http://pastebin.com/ukQSGGLZ
03:46:17 <Marenz> ivanm, yea. I want to use it as basis for some ideas
03:46:22 <mauke> The paste ukQSGGLZ has been copied to http://hpaste.org/77568
03:46:25 <Matthias|PC> it works, but I'd also need it to reverse strings
03:46:32 <Matthias|PC> right now reversing "bla" will give me 3 2 1 or so
03:46:38 <neutrino> Marenz: if you just want to test some ideas then i suggest you use the release version
03:46:51 <neutrino> Marenz: merging in changes based on that should be easy enough
03:46:54 <Marenz> of gitit you mean?
03:46:58 <ivanm> Matthias|PC: ... and?
03:47:08 <neutrino> of whatever software you're working on
03:47:11 <ivanm> here's a hint; that's a really awful definition of reverse :p
03:47:28 <Matthias|PC> ivanm: no idea how to do it otherwise :p
03:47:42 <nicoo> :t reverse
03:47:44 <lambdabot> [a] -> [a]
03:47:56 <nicoo> @src String
03:47:56 <lambdabot> type String = [Char]
03:47:59 <ivanm> Matthias|PC: a slightly less horrendous version would be to do a manual recursion and append the value onto the end each type
03:47:59 <neutrino> can you somehow express reverse with fix?
03:48:00 <nicoo> :)
03:48:00 <notdan> shachaf: I would like to thank you again for the assistance. I don't know why I wanted to use a monad there, clearly the monoid is sufficient for my needs
03:48:26 <Matthias|PC> hmm
03:48:39 <Marenz> neutrino, it isn't exctly that easy. this repo is the result of a rewrite of the gitit main project and that rewrite contains changes crucial to my ideas ;)
03:49:00 <neutrino> oh, and that hasn't been released once yet?
03:49:01 <neutrino> ok.
03:49:20 <Marenz> not that I know of, no
03:50:07 <merijn> Matthias|PC: I second the suggestion of trying to rewrite it using manual recursion. This list comprehension approach is likely to give your TA/whatever eye cancer :)
03:51:00 <byorgey> neutrino: you can express any recursion using fix.
03:51:24 <ivanm> Marenz: anyway, with your error, it seems there might be a problem with using the blaze_html_0_5 flag
03:51:33 <mikeplus64>  
03:51:39 <ivanm> you sure you passed it right?
03:51:51 <ivanm> byorgey: btw, Eelis is passing on the maintainership of boxes on to me
03:52:04 <ivanm> just because I bugged him to release a new version with updated split dependencies :p
03:52:08 <merijn> Matthias|PC: And since the person probably won't really care about the complexity (efficiency) of your implementation the manual recursion should be a lot easier fot figure out anyway
03:52:13 <byorgey> ivanm: ah, cool, good to know
03:52:50 <Marenz> ivanm, I removed that switch, following neutrinos suggestion. the problem seems that the dependencies are simply missing. I guess I can install them oneby one, but I was hoping there is an automated way to do that
03:53:11 <ivanm> *shrug* I thought cabal-dev did that for you
03:53:16 <ivanm> or else the makefile was meant to do that
03:53:24 <Marenz> I was unable to install cabal-dev
03:53:37 <Marenz> so I changed the calls to cabal (also following neutrinos suggestion)
03:53:39 <ivanm> ahhhhh, that's right
03:53:48 <byorgey> yes, cabal does that for you
03:53:54 <ivanm> Marenz: cabal install --only-dependencies ?
03:53:55 <byorgey> cabal-dev is just a thin wrapper around cabal
03:54:09 <ivanm> byorgey: IIRC, "cabal install" inside a project won't always get deps for you
03:54:17 <byorgey> yes it will.
03:54:28 <ivanm> oh? admittedly it's been a while since I needed it to do that
03:54:33 <ivanm> OK, scratch that idea then :)
03:54:35 <byorgey> it's 'cabal build' that doesn't get deps for you.
03:54:41 <Marenz> ivanm,  I tired that, but it gives exactly the same error as in the paste before
03:54:43 <byorgey> though that may change.
03:55:01 <byorgey> Marenz: I missed the link to your paste, can you post it again?
03:55:02 <ivanm> Marenz: where are you doing the "cabal install" in?
03:55:06 <ivanm> byorgey: http://hpaste.org/77567
03:55:09 <byorgey> thanks
03:55:12 <Marenz> http://hpaste.org/77567
03:55:35 <Marenz> ivanm, inside the cloned project (there resides also a .cabal file)
03:55:37 <neutrino> byorgey: i didn't know. how can you go from any recursion to fix?
03:55:54 <byorgey> Marenz: can you run 'cabal install -v3' and paste the output of that?
03:56:00 <ivanm> this is the pandoc project?
03:56:23 <ivanm> maybe the solution is simpler: cabal-install is complaining that building this version of pandoc - and its deps - with the per-user DB will break existing pandoc and gitit
03:56:28 <byorgey> neutrino: you replace   f x y z = ... f ...   by   f' g x y z = ... g ... ,  and then  f = fix g
03:56:29 <ivanm> which is why cabal-dev is recommended
03:56:48 <ivanm> maybe try virthualenv (or whatever it's called) or some other sandboxing solution?
03:56:55 <Marenz> ivanm,  no, this is gitit2: https://github.com/jgm/gitit2
03:56:56 <byorgey> it doesn't look to me like it's complaining about breaking existing packages.
03:56:56 <hpaste> Marenz pasted “Cabal install error” at http://hpaste.org/77569
03:57:04 <byorgey> the error for that looks different.
03:57:09 <Marenz> -v2 output ^
03:57:18 <Marenz> *3
03:57:48 <Marenz> it seems to try to install gitit2, even though it should only get the deps for it?
03:57:55 <byorgey> oh, gitit2 requires an outdated version of bytestring, that's one big problem
03:58:13 <byorgey> why should it only get the deps?
03:58:27 <Marenz> Well, I try to build gitit2..
03:58:38 <Marenz> sorry if taht didn't became clear in my descriptions
03:58:58 <Marenz> *become
03:59:01 <byorgey> it seems that the bytestring issue is probably the root cause here (or one of them at least)
03:59:17 <neutrino> byorgey: i'm having a hard time visualizing this. can we look at some simple examples please?
03:59:22 <byorgey> you should change the upper bound on bytestring in gitit2.cabal so that it allows 0.10
03:59:30 <byorgey> neutrino: sure.
03:59:49 <neutrino> ok let's try making map with fix?
03:59:53 <aninhumer> Is there any neater way to get values corresponding to types than: toValue (undefined::type) ?
03:59:58 <byorgey> neutrino: ok
04:00:07 <neutrino> map f x:xs = (f x):(map f xs)
04:00:12 <neutrino> let's start with this definition
04:00:24 <shachaf> You should start with a definition which syntax-checks. :-)
04:00:27 <byorgey> neutrino: right, though note you're missing parens around (x:xs)
04:00:36 <shachaf> Good habit and all.
04:00:37 <neutrino> oh of course
04:00:38 <neutrino> thank you
04:00:47 <shachaf> (Also, that doesn't crash on every input.)
04:00:51 <byorgey> neutrino: now we make a helper function  map', which takes an extra function argument
04:00:55 * shachaf should start by going to sleep.
04:00:55 <neutrino> i still make syntax errors every now and then
04:00:59 <neutrino> ok go on
04:01:12 <byorgey> neutrino: instead of calling itself recursively, it calls that function argument
04:01:28 <byorgey> map' m f (x:xs) = (f x) : (m f xs)
04:01:30 <Marenz> I guess I try to learn more basic things first before getting my hands on this again
04:01:49 <byorgey> so notice that map' is not recursive
04:02:02 <byorgey> in some sense it does "one step" of map, and then calls some other function to do "the rest"
04:02:39 <neutrino> right
04:02:46 <neutrino> let's call that equation (1)
04:02:53 <byorgey> ok
04:03:04 <neutrino> is (1) seen by haskell as an equation on m?
04:03:13 <neutrino> defining m implicitly?
04:03:16 <byorgey> no
04:03:18 <neutrino> ok.
04:03:22 <byorgey> m is just an argument of map'
04:03:31 <byorgey> (1) is a definition of map', that's all
04:03:34 <neutrino> ok.
04:03:41 <neutrino> what's the next step?
04:03:57 <byorgey> neutrino: now, if we could pass map' as an argument to itself, we would get the original map
04:04:09 <byorgey> err, sorry, scratch that
04:05:05 <neutrino> scratching!
04:05:11 <byorgey> neutrino: now,  fix f = f (fix f),  right?
04:05:19 <byorgey> I mean I know that's not how it's actually defined
04:05:22 <neutrino> umm
04:05:23 <neutrino> right ok
04:05:24 <byorgey> but that's equivalent
04:05:39 <byorgey> so consider  fix map'
04:05:52 <byorgey> fix map' = map' (fix map')
04:05:56 <neutrino> right
04:06:28 <byorgey> so   fix map' f (x:xs) = map' (fix map') f (x:xs) = (f x) : (fix map' f xs)
04:06:29 <neutrino> so (fix map') f (x:xs) = (f x) : ((fix map') f xs)
04:06:39 <byorgey> right! =)
04:06:44 <neutrino> right
04:06:53 <byorgey> therefore  fix map' = map
04:06:59 <neutrino> why?
04:07:10 <byorgey> because fix map' satisfies the same equation as map =)
04:07:14 <neutrino> i can see the type will be equivalent
04:07:19 <neutrino> wait
04:07:20 <neutrino> oh right
04:07:24 <neutrino> i see that now
04:07:27 <neutrino> that's great :)
04:07:53 <neutrino> btw, not all functions have a fixed point, right?
04:08:03 <sipa> (+1) does not
04:08:07 <byorgey> no, all functions have a least fixed point
04:08:10 <Sonderblade> if you have a haskell module name e.g. Database.Persist.TH, what's the simplest way to figure out what cabal package provides it?
04:08:17 <byorgey> it's just that some of them have _|_ as a least fixed point
04:08:23 <byorgey> like (+1)
04:08:26 <sipa> right
04:08:28 <ivanm> Sonderblade: hayoo
04:08:55 <sipa> @hayoo Database.Persist.TH
04:08:55 <lambdabot> Unknown command, try @list
04:09:00 <sipa> bad lambdabot
04:09:08 <ivanm> @where hayoo
04:09:08 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
04:09:16 <neutrino> can you say that fix is analogous to lim, and _|_ being the lfp is analogous to a sequence having no limit?
04:09:17 <Sonderblade> thanks
04:09:59 <neutrino> Sonderblade: i google for "hackage Module.Name", click first link, look in top left corner.
04:10:29 <byorgey> neutrino: fix is strongly analogous to lim (in fact it *is* a limit, for a suitably generalized notion of limit)
04:10:41 <neutrino> right, i understand it is *a* limit
04:10:50 <adimit> question: I might have missed it in my perusal of the documentation, but how do I interact with a (SQL) database from within a Conduit? I couldn't find anything about that on the web.
04:11:01 <byorgey> neutrino: however, _|_ being the lfp is not analogous to a sequence having no limit
04:11:13 <neutrino> what is it analogous to then?
04:11:14 <byorgey> neutrino: in this setting *every* monotonic sequence has a limit
04:11:21 <adimit> (I mean, I could do it, I guess, by just running runResourceIO or somesuch, but that feels like cheating.)
04:11:37 <byorgey> neutrino: which of course does not hold for, say, the real numbers
04:11:43 <sipa> it's more similar to just considering all functions that map 0 to 0, and asking which of them have a fixed point beyond 0
04:11:43 <neutrino> sure, it just means that we get stronger properties than the cauchy criterion
04:11:51 <neutrino> that's fine though
04:12:02 <neutrino> i wasn't talking about the cauchy criterion though
04:12:27 <neutrino> or said otherwise: would you agree that a sequence which bottoms out would have no limit?
04:12:50 <byorgey> what do you mean by "a sequence which bottoms out"?
04:13:05 <neutrino> well, function that has a bottom lfp
04:13:09 <byorgey> ah
04:13:13 <byorgey> no, I would not agree
04:13:22 <byorgey> the limit is _|_ .
04:13:25 <shachaf> ⊥ presumably *is* the limit.
04:13:32 <neutrino> that's not exactly what i mean
04:13:35 <byorgey> and that's not analogous to saying it has no limit.
04:14:12 <neworder> Hi guys
04:14:19 <neutrino> if we look at a specific equivalence between fix on functions and lim on sequences, then would a function f where fix f = _|_ map to a sequence with no limit?
04:14:26 <neworder> I came across a video saying that Haskell is useless
04:14:36 <neworder> Am I wrongly informed?
04:14:39 <neworder> haha
04:14:44 <neutrino> @where ops
04:14:44 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:14:48 <byorgey> neutrino: oh, so you're specifically restricting to, say, functions of type  Integer -> Integer?
04:15:03 <sipa> of course haskell is useful, it's the best language to write for example haskell compilers in
04:15:19 <byorgey> neworder: yes, you are.  Now, are you just trolling or would you like to actually have a conversation about Haskell?
04:15:39 <neutrino> byorgey: no. i'm restrcting to equivalences (let's call such an equivalence E), where some useful properties of fix map to useful properties of lim.
04:16:02 <neutrino> whether you have functions Int -> Int or not doesn't matter
04:16:11 <trolling> no, I'm trolling
04:16:11 <byorgey> neutrino: that's really vague, I'm not sure what you mean.
04:16:12 <neworder> No not trolling
04:16:14 <neworder> haha
04:16:21 <trolling> there's a lot of people stealing my identity on this channel today
04:16:28 <neworder> Explain to me briefly pls
04:16:30 <neworder> Thanks
04:16:33 <sipa> neworder:
04:16:36 <mauke> neworder: explain what?
04:16:38 <sipa> @where lyah
04:16:38 <lambdabot> http://www.learnyouahaskell.com/
04:16:44 <neutrino> byorgey: well, let's try to come up with *some* equivalences between (fix, Functions) and (lim, Sequences)
04:16:49 <sipa> if you read that, and still have questions, come back
04:17:00 <byorgey> neutrino: ok
04:17:02 <Saizan> neworder: are you referring to the graph about the usefulness vs. safety spectrum?
04:17:02 <neworder> Hmm ok
04:17:09 <neworder> Nope
04:17:14 <neworder> The one by Simon
04:17:26 <neworder> http://youtu.be/iSmkqocn0oQ
04:17:31 <Saizan> yeah, that's what he's referring to
04:17:34 <neworder> Simon Peyton Jones
04:17:37 <neworder> Ohh
04:17:40 <neworder> hmm
04:17:42 <byorgey> neutrino: can you give an example of the kind of thing you have in mind?
04:17:47 <neworder> Think I took it out of context
04:17:52 <neutrino> byorgey: does fix have any properties similar to basic properties of lim? for example lim (f+g), lim (f*g), lim(f.g)?
04:18:04 <neworder> I'm learning it by the way sipa
04:18:20 <neworder> I see its uses too
04:18:21 <neutrino> byorgey: actually, let's use s t u for sequences and f g h for functions
04:18:27 <byorgey> ok
04:18:31 <neworder> The main one being able to take in functions
04:18:54 <Saizan> neworder: he's saying haskell started out as a very safe but impratical language, and while it's been moving into more practical (but also safer) territory other languages are trying to get safer too
04:19:12 <neutrino> byorgey: iirc, fix fix f == fix f, right?
04:19:21 <neutrino> sorry fix $ fix f
04:19:29 <neworder> Hmm Ic
04:19:34 <byorgey> neutrino: no, but  fix (f . f) == fix f
04:19:41 <neutrino> oh, that's interesting.
04:20:05 <neutrino> what about fix (f . g) ?
04:20:35 <mauke> :t fix (?f . ?g)
04:20:37 <byorgey> neutrino: I don't think there's anything you can say in general about  fix (f . g)
04:20:37 <lambdabot> (?f::a1 -> a, ?g::a -> a1) => a
04:20:53 <notdan> I don't think we can say anything about it neutrino. fix f and fix g can diverge, for example
04:20:56 <byorgey> well, I guess you can say  fix (f . g) = f . fix (g . f)
04:20:59 <notdan> while fix (f .g ) converges
04:21:48 <neutrino> looking at this, it's more similar to differentiation on some crazy domain than limiting
04:21:58 <shachaf> fix is the limit of a sequence
04:22:20 <Eduard_Munteanu> fix as the least fixed point is sorta limitish.
04:22:24 <shachaf> fix f is the limit of the sequence ⊥, f ⊥, f (f ⊥), ...
04:22:29 <sipa> byorgey: what if f = (+1) and g = (subtract 1) ?
04:22:45 <shachaf> sipa: What of it?
04:22:47 <sipa> fix (f . g) = id then, but f . fix (f . g) is not
04:22:57 <byorgey> sipa: no, fix (f . g) is still _|_
04:23:14 <neutrino> why is it _|_?
04:23:17 <notdan> :t fix
04:23:18 <lambdabot> (a -> a) -> a
04:23:27 <Eduard_Munteanu> Because fix id = _|_
04:23:34 <byorgey> because it sits there adding and subtracting 1 forever
04:23:34 <neutrino> oh.
04:23:56 <sipa> byorgey: right, i was thinking about the mathematical functions, not the haskell one
04:24:11 <byorgey> right, that's easy to do =)
04:24:21 <neutrino> byorgey: anyways, my questions about equivalence of fix and lim come from a more basic question: can you implement limiting of number sequences with fix?
04:24:35 <byorgey> neutrino: right, you can't
04:24:47 <neutrino> have you tried?
04:24:49 <shachaf> fix isn't any more magic than recursion.
04:25:06 <byorgey> neutrino: well, unless perhaps you want to talk about number sequences consisting of lazy peano natural numbers
04:25:17 <Eduard_Munteanu> Sure you can...
04:25:17 <byorgey> neutrino: the problem is that the orders are quite different.
04:25:18 <Eduard_Munteanu> ^^
04:25:33 <neutrino> can you explain what you mean by orders?
04:25:34 <byorgey> the limit of number sequences is with respect to the usual ordering on numbers
04:25:41 <byorgey> 4 < 5 < 5.6   etc.
04:25:45 <neutrino> ok go on
04:25:49 <Eduard_Munteanu> You'd be calling a function with fix succ as a parameter.
04:25:57 <byorgey> the "limit" corresponding to fix is with respect to informating ordering
04:26:06 <neutrino> what is informating ordering?
04:26:11 <byorgey> _|_ < Just _|_ < Just 3
04:26:24 <neutrino> how does that work?
04:26:31 <byorgey> let me find you a link
04:26:39 <shachaf> @google ezyang monotonic
04:26:39 <byorgey> ezyang had some nice blog posts explaining it
04:26:40 <lambdabot> http://blog.ezyang.com/2010/12/gin-and-monotonic/
04:26:41 <lambdabot> Title: Gin and monotonic : Inside 206-105
04:26:52 <neutrino> can you walk me through a simple sequence and how to find its limit by hand?
04:26:53 <byorgey> thanks shachaf =)
04:26:55 <shachaf> Not that one.
04:26:57 <shachaf> @google ezyang hasse
04:26:59 <byorgey> oh.
04:26:59 <lambdabot> http://blog.ezyang.com/2010/12/hussling-haskell-types-into-hasse-diagrams/
04:26:59 <lambdabot> Title: Hussling Haskell types into Hasse diagrams : Inside 206-105
04:28:27 <byorgey> neutrino: _|_ is <= everything; and  for any constructor Foo we have   Foo x <= Foo y   iff  x <= y
04:29:15 <byorgey> neutrino: the intuition is that  x <= y  means that y is either equal to x  or "more defined" than x
04:29:27 <neutrino> right
04:29:37 <neutrino> is this order linear?
04:29:40 <byorgey> no
04:29:43 <byorgey> not in general
04:29:52 <neutrino> can you give me an example?
04:30:59 <byorgey> you should look at ezyang's blog post that shachaf linked
04:31:08 <neutrino> thank, i will
04:31:08 <byorgey> it has examples with pictures =)
04:31:17 <neutrino> in fact i think i have saved it on disk some time ago..
04:31:30 <shachaf> But why look at a web page that explains it all when you can ask people in IRC to type it in? :-)
04:32:02 <byorgey> hehe =)
04:32:21 <neutrino> because conversations with humans are worth 100000x more
04:32:47 <byorgey> that is true
04:32:58 <neutrino> and i bet no amount of books will give anyone the kind of experience to be gained by learning from someone like byorgey directly
04:33:05 <shachaf> They are when they're personalized, sure.
04:33:21 <byorgey> heh, thanks =)
04:33:34 <Sonderblade> is there any way when using persistent and mkPersist that the name of the table should be different from the name of the generated type?
04:33:39 <neutrino> just saying how it is byorgey :)
04:33:56 <neutrino> Sonderblade: considered using an alias?
04:34:40 <Sonderblade> neutrino: a type alias?
04:34:46 <neutrino> yes
04:34:48 <byorgey> neutrino: anyway, feel free to ask more questions later, at the moment I have to go take care of my son
04:34:59 <neutrino> i have to go too :)
04:35:04 <neutrino> have fun with your family, and thanks
04:35:52 <shachaf> neutrino: Oh, you're cheater.
04:35:57 <shachaf> That explains it.
04:36:59 <shachaf> (Or am I wrong?)
04:37:16 <Sonderblade> neutrino: maybe that would work.. but i also wants the fields to be converted from haskell's camelCase to underscore_case
04:55:30 <mentus> hi everybody
04:55:43 <mentus> i have a question regarding lifting and state monads
04:55:55 <mentus> anyone there to help me ?
04:56:03 <atriq> Let's see the question
04:56:07 <mentus> ok
04:56:20 <Marenz> mentus, the usual way to ask qusetions in irc is to ask the question, not ot ask whetre you can ask a question
04:56:43 <mentus> Marenz: cool, good to know
04:56:48 <Cale> There are 971 people here, probably someone can help ;)
04:56:51 <mentus> will always do that right from now
04:56:56 <mentus> :-)
04:57:20 <Marenz> usually, noone will feel responsible if you state it like that, but if you ask the question right away, someone might now the answer already or feels more included to take the matter :)
04:57:30 <Marenz> *inclined
04:58:05 <mentus> ok so i have a function applyOpS :: Op -> State ProgState Bool
04:59:27 <mentus> and i want to do something like: all applyOpS ops, where ops :: [Op]
04:59:51 <mentus> which should give me a Bool within the State monad
05:00:20 <atriq> :t akk
05:00:23 <atriq> :t all
05:00:23 <lambdabot>     Not in scope: `akk'
05:00:23 <lambdabot>     Perhaps you meant `ask' (imported from Control.Monad.Reader)
05:00:25 <lambdabot> (a -> Bool) -> [a] -> Bool
05:00:47 <atriq> :t mapM
05:00:49 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
05:01:09 <atriq> No, not quite
05:01:46 <mauke> :t liftM all . mapM ?applyOps
05:01:47 <lambdabot>     Couldn't match expected type `a0 -> Bool' with actual type `[b0]'
05:01:48 <lambdabot>     Expected type: [a1] -> m0 (a0 -> Bool)
05:01:48 <lambdabot>       Actual type: [a1] -> m0 [b0]
05:02:15 <atriq> :t liftM all . fmap ?applyOps
05:02:17 <lambdabot> (?applyOps::a1 -> a -> Bool, Monad m, Functor m) => m a1 -> m ([a] -> Bool)
05:02:40 <shachaf> :t liftM and . fmap ?applyOps
05:02:42 <lambdabot> (?applyOps::a -> [Bool], Monad m, Functor m) => m a -> m Bool
05:02:52 <shachaf> Well, no.
05:02:53 <atriq> :t liftM and . sequence . map ?applyOps
05:02:55 <lambdabot> (?applyOps::a -> m Bool, Monad m) => [a] -> m Bool
05:03:04 <mauke> :t liftM and . mapM ?applyOpS
05:03:06 <lambdabot> (?applyOpS::a -> m Bool, Monad m) => [a] -> m Bool
05:03:26 <atriq> That last one is the best,, mentus
05:03:28 <shachaf> Sigh, why did I write fmap?
05:03:32 <atriq> What mauke said
05:05:16 <mentus> what's the difference between sequence . map and mapM ?
05:06:20 <merijn> mentus: Eh, nothing :)
05:06:25 <merijn> @src mapM
05:06:25 <lambdabot> mapM f as = sequence (map f as)
05:07:41 <merijn> mentus: mapM just reads nicer/more intuitive
05:09:26 <mentus> so, liftM and (mapM applyOpS ops) ?
05:09:43 <shachaf> and <$> mapM applyOpS ops
05:13:40 <cornihilio> dcoutts_: you there?
05:16:18 <ivanm> mentus: that's almost prose! "liftM and mapM applyOpS ops" :p
05:21:03 <mentus> :t liftM and $ mapM achieveS ["test1", "test2"]
05:21:05 <lambdabot> Not in scope: `achieveS'
05:21:22 <mentus> StateT ProgState Identity Bool
05:21:41 <mentus> sorry achieveS has the same signature as applyOpS
05:21:50 <mentus> it seems to be what i am looking for
05:22:32 <PatrickRobotham> Hi, I'm having trouble with the cabal package elm. I've installed it but I can't get it to run
05:23:00 <PatrickRobotham> Oh, sorry, gotta update my path
05:26:14 <mentus> so i will try to make it work in the context of my program now
05:26:23 <mentus> thanks and have a nice rest of the day
05:28:18 <Tehnix> Hi, running into a bit of a dependency problem with yesod and cabal :/ If anyone has any idea how to sort this mess out, it would be greatly appreciated :) you can see the specific problem in this gist (what exactly is wrong) https://gist.github.com/4054871
05:40:02 <benmachine> hey guys, can anyone recommend me any (preferably light!) reading on the Curry-Howard correspondence?
05:40:35 <benmachine> I want to do a talk introducing the idea to some of my fellow undergrad mathematicians in half an hour
05:40:43 <benmachine> so I may need also to explain to them what types are
05:41:06 <benmachine> I have a bunch of quasiknowledge on the subject but it's not really authoritative
05:41:19 <apfm> Is there some source code of these slides http://bos.github.com/reaktor-dev-day-2012/reaktor-talk-slides.html#(30) ?
05:41:47 <benmachine> oh, by "in half an hour" I mean "that lasts half an hour"
05:41:51 <benmachine> not "this afternoon"
05:41:54 <apfm> An could someone please explain the tools they made with?
05:43:00 <Philippa> benmachine: the way I introduced it to my gf was to start with a contextless presentation of minimal logic first so there's less syntax clutter (she'd learned SML aaaages back but wasn't familiar with lambda calculi)
05:43:17 <Philippa> don't have any reading recs for you myself though, 'mafraid
05:43:52 <benmachine> Philippa: I don't know how many of the terms you just used are to be interpreted literally or technically :P
05:44:18 <benmachine> (like is "minimal logic" a concept in itself or just a minimal amount of logic)
05:47:42 <Peaker> getProgName appears to give only the base name -- any idea how to figure out which directory the executable runs in?
05:47:59 <Peaker> argv[0] is not really "prog name" except by a (relatively strong) convention.. I wish getArgs just exposed argv as it was
05:49:09 <benmachine> Peaker: there have been discussions about this sort of thing... I believe Windows may be part of the problem
05:49:35 <fryguybob> Peaker: That would break more windows things.
05:49:38 <benmachine> (but I also have a faint recollection that there may have been a resolution to the problem recently... /me searches for some things)
05:49:51 <Peaker> benmachine, ah, I see the system-argv0 package
05:50:03 <benmachine> the latest base has getExecutablePath
05:50:36 <benmachine> in System.Environment
05:51:03 <mauke> fryguybob: why would it break windows?
05:51:04 <benmachine> looks like it's new in base 4.6
05:51:21 <fryguybob> mauke: The assumed convention does not hold.
05:51:32 <mauke> what assumed convention?
05:52:36 <Philippa> benmachine: minimal logic is a specific logic - the only connective is implication
05:52:51 <Philippa> (also known as the simply-typed lambda calculus :p)
05:52:59 <benmachine> Philippa: ah, okay
05:53:43 <benmachine> my audience will have already done a course on logic that involved a system in which ¬A was defined as A => false
05:54:21 <benmachine> and... A v B = ¬A => B or something similar
05:54:33 <fryguybob> mauke: That argv[0] has anything to do with how the currenly executing process was started.
05:56:17 <mauke> fryguybob: huh?
06:05:29 <Peaker> doh, system-argv0 returns the path wrapped in system-filepath which doesn't seem to have a way out!
06:06:28 <benmachine> Peaker: it does
06:06:38 <benmachine> http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/Filesystem-Path-Rules.html#t:Rules toText
06:06:38 <Peaker> how do you get a String from a FilePath?
06:07:08 <Peaker> that's really weird/cumbersome.. an exposed newtype for safety I can understand, but why so much fuss around conversions?
06:07:43 <benmachine> Peaker: aiui because Windows filepaths are notionally text (sequences of characters) whereas Linux filepaths are notionally bytestrings
06:09:07 <merijn> benmachine: Windows filepaths are UTF-16, to be precise
06:09:18 <benmachine> merijn: right
06:09:43 <merijn> Whereas Linux (and really all traditional unix filesystems) are "plain" bytes (with the exception of NUL and / which are not allowed in names
06:10:08 <merijn> Interpretation of the bytes is undefined
06:10:43 <merijn> You can only use some heuristic approaches to figure out what it most likely is
06:11:06 <Peaker> what a mess :(
06:11:40 <merijn> The most sane approach would be to assume UTF-8 and screw anyone with a different terminal encoding
06:12:27 <fryguybob> Peaker: What would you hope to do with the directory on windows?
06:14:26 <carli2> hi. are all haskell data (even unexecuted function calls) representable as expressions? (for serialization/persistence purposes)
06:16:43 <merijn> carli2: No, you can't, for example, serialise closures if that's what you're asking
06:17:18 <carli2> merijn: closures are exact my point because I may have monads which are partially executed over days and months
06:18:12 <carli2> is there a haskell engine with a persistent data model? (for instance a nosql database that allows haskell scripting)
06:19:15 <merijn> carli2: Maybe you want acid-state?
06:19:28 <Jeanne-Kamikaze> are you aware of cloud haskell ?
06:19:30 <Peaker> fryguybob, probably do a utf16->utf8 encoding and pretend it's linux
06:19:35 <arbn> carli2: You can't serialize arbitrary higher-order functions. You could do something like what is done with Cloud Haskell, but then your free variables basically need to be a bytestring.
06:19:35 <merijn> carli2: That allows persisting data structures to disk with acid guarantees
06:19:45 <Jeanne-Kamikaze> because it can serialise closures iirc, assuming both ends are running the same binaries
06:20:02 <merijn> arbn: Wut. Sure you can serialise arbitrary higher-order functions, just not in haskell :)
06:20:17 <fryguybob> Peaker: I mean even if you could get the directory of the process what are you going to do with it?  Just show it to the user?
06:20:34 <Peaker> fryguybob, look for data files that accompany it in the same dir
06:20:39 <Peaker> fryguybob, it's for scripting purposes
06:20:54 <arbn> merijn: Is there a language that lets you serialize a function with arbitrary free variables? That could be very unpredictable.
06:20:54 <Peaker> and executing other executables relative to its own path
06:21:02 <merijn> arbn: Erlang, I think?
06:21:09 <mauke> read /proc/self/exe
06:22:15 <fryguybob> Peaker: That will almost certainly have unexpected results on Windows.
06:22:26 <arbn> merijn: If true, that's interesting. Maybe I should look at Erlang, or Akka, or whatever else the kids are smoking these days.
06:22:49 <Peaker> mauke, thanks, I think I'll use that
06:23:04 <Peaker> fryguybob, Don't need Windows compatibility, so I'll go with mauke's suggestion
06:23:15 <fryguybob> Peaker: That sounds like an excellent route to take.
06:24:16 <arbn> I think the suggestion of acid-state is good, though. Transactional, and has a very functional approach to persistence.
06:25:16 <Peaker> mauke, oh, that's no good :) I am running it with runhaskell so getting ghc's path
06:25:55 <mauke> haha
06:26:14 <mauke> so ... stop running it with runhaskell?
06:26:38 * hackagebot hspec-experimental 0.1.0 - An experimental DSL for testing on top of Hspec  http://hackage.haskell.org/package/hspec-experimental-0.1.0 (SimonHengel)
06:26:59 <fryguybob> Peaker: Template haskell and bake the current directory in :P
06:27:35 <Peaker> doh, even system-argv0 is returning the wrong thing..
06:27:48 <mauke> your choices are to go up or down
06:27:57 <mauke> down: compile executable
06:27:59 <mauke> up: wrapper script
06:28:26 <Peaker> I'll just run it from the right cwd at all times :(
06:28:47 <mauke> that can be automated with a wrapper script :-)
06:54:38 <killy9999> is it possible to do such comparison in Haskell: x =/ _|_  ?
06:55:09 <killy9999> I meant /= not =/
06:55:17 <Iceland_jack> Are you familiar with the halting problem?
06:55:27 <killy9999> yes
06:55:35 <killy9999> and that is why I'm asking
06:55:57 <killy9999> I'm reading Wadler
06:56:04 <sipa> ok, what would the answer be for (1 /= (fix (+1))) ?
06:56:07 <killy9999> "Comrehending Monads" that is
06:56:25 <Iceland_jack> http://stackoverflow.com/questions/9392129/detect-bottom-value-in-haskell look at this
06:56:37 <cornihilio> if I wanted to generate a SpecificPackageDB for each of the packages installed for the user, where would I be pointing it at?
06:56:47 <killy9999> and he gives a function: strict f x = if x /= _|_ then f x else _|_
06:56:52 <cornihilio> this is within cabal/cabal-install
06:56:53 <killy9999> Iceland_Jack: thanks
06:59:01 <killy9999> sipa: I see that this does not terminate but honestly I have a problem understanding how fix works
06:59:37 <killy9999> Iceland_Jack: according to SO it would therefore be impossible to implement Wadler's strict function?
07:00:08 <mauke> killy9999: in haskell, yes
07:00:15 <Iceland_jack> Well what happens if x is bottom?
07:00:23 <killy9999> the bottom is returned
07:00:46 <killy9999> mauke: so Wadler's strictness monad is only a theoretical concept?
07:00:49 <Iceland_jack> Bottom is not a return value
07:00:59 <Iceland_jack> Then the comparison x /= ⊥ never finishes
07:01:16 <killy9999> yes, so the function ends up as bottom
07:01:22 <mauke> killy9999: I don't know wadler's strictness monad
07:01:27 <killy9999> which is basically what the conditional instruction says
07:01:29 <mauke> but 'strict' is called $! in haskell
07:01:33 <Iceland_jack> So strict begins by evaluating x and then running f x
07:02:03 <mauke> > const 2 $! undefined
07:02:04 <killy9999> mauke: it's the same as identity monad, except that it uses strict function given above as map
07:02:05 <lambdabot>   *Exception: Prelude.undefined
07:02:46 <killy9999> Iceland_jack: I understand that, though it took me about 20 minutes to figure out that it works that way
07:03:06 <killy9999> the question is how to write such function in Haskell so that it actually works
07:03:28 <mauke> see above
07:03:41 <Iceland_jack> I think the point of it is that comparing x to bottom requires that you evaluate x, right?
07:04:02 <killy9999> mauke: ok, I'm looking at the source
07:04:12 <killy9999> Iceland_jack: yes
07:04:23 <killy9999> but I see that in the end it comes down to seq
07:05:22 <Iceland_jack>     f $! x  = let !vx = x in f vx
07:05:41 <Iceland_jack> This definition is pretty much the same, forcing evaluation of `x' before invoking f x
07:06:15 <mauke> > let !vx = undefined in 2
07:06:17 <lambdabot>   *Exception: Prelude.undefined
07:06:44 <killy9999> OK, I see
07:16:21 <zmoazeni> Hi folks, I'm writing my first cabal package, and I'm wanting to stick to convention as much as possible. I'm trying to find some information behind the reasoning behind choices in top level modules (e.g. Data, Text) as well as Hackage categories. Is there anything someone can point me to?
07:17:58 <killy9999> zmoazeni: I had the same problem a couple of weeks ago
07:18:16 <killy9999> it seems that ypu just have to use your common sense
07:18:48 <zmoazeni> killy9999: Right on. Thanks.
07:19:59 <toki78> Hi folks !
07:21:46 <killy9999> Hi
07:22:18 <toki78> I'm bored, any ideas for what to program ?
07:22:30 <m0g> an activity suggestor
07:22:45 <toki78> good idea :)
07:23:26 <m0g> you give wieghts to activities such as cinema, reading, listening radio, music etc and depending on whether you did that recently it's more or less proposed
07:23:28 <m0g> :)
07:23:32 <m0g> weights*
07:24:13 <arbn> killy9999: Hello.
07:51:37 <toki78> are the latest OpenGL extensions available in hugs ?
07:52:10 <mauke> haha
07:54:48 <toki78> so I guess not
07:55:53 <geekosaur> hugs hasn't really been maintained since 2006 or thenabouts
07:56:03 <geekosaur> it doesn't have the latest anything
07:56:08 <arkantos> I'm a complete Haskell noob as far as I know: hugs == obsolete
07:56:29 <toki78> and ghc ?
07:57:57 <geekosaur> ghc's currently the flagship for haskell development
07:57:58 <bitonic> OpenGL *is* available for hugs, iirc
07:58:03 <bitonic> I'm not sure about "latest
07:58:03 <bitonic> "
07:58:11 <geekosaur> opengl is, the latest version isn't so much.
07:58:19 * geekosaur would love to see more jhc activity...
08:01:11 <mm_freak> how good is GHC at micro-optimization nowadays?  for example does it optimize 2*x to a bitshift and such?
08:01:40 * hackagebot hatt 1.5.0.0 - A truth table generator for classical propositional logic.  http://hackage.haskell.org/package/hatt-1.5.0.0 (BenedictEastaugh)
08:03:44 <mm_freak> btw, why do people still install hugs today?
08:05:01 <pordan30> it remains recommended in the current versions of several popular haskell introductions, for example: thompson's "the craft of functional programming."
08:05:24 <mm_freak> i see
08:06:25 <ivasilov_> anyone knows a faster way xor a list than "zipWith (xor) x y"
08:06:26 <ivasilov_> ?
08:06:50 <mauke> mm_freak: academic inertia
08:07:03 <Iceland_jack> ivasilov_: What do you mean ‘faster’?
08:07:23 <applicative> ivasilov_: are these lists of booleans?
08:07:38 <pordan30> what's wrong with zipWith xor to combine the lists pointwise using xor?
08:07:50 <Iceland_jack> . o O ( You can drop the parentheses: zipWith xor x y )
08:08:20 <quest>     The type signature for `nodes' lacks an accompanying binding Failed, modules loaded: none.
08:08:28 <applicative> pordan30: nothing,  I'd think, if lists were the right choice to  begin with
08:08:38 <ivasilov_> applicative: no, Ints
08:09:10 <quest> wat does the error mean?
08:09:24 <hilhi> There ought to be a promotion function of type
08:09:26 <hilhi> (x -> m y) -> (Maybe x -> m (Maybe y))
08:09:36 <mauke> quest: it means 'nodes' isn't defined anywhere
08:09:41 <hilhi> Does it have a nice name, or do I need to write it from scratch?
08:09:45 <applicative> ivasilov_:  is  it xor that you think is slow, or the list manipulation
08:11:21 <pordan30> :t \(f :: a -> Maybe b) -> fmap f
08:11:23 <lambdabot> Functor f => (a -> Maybe b) -> f a -> f (Maybe b)
08:11:39 <pordan30> oh, i see, nevermind
08:14:55 <ivasilov_> applicative: the xor is probably using the assembly instruction, so I'm guessing the list manipulation
08:16:26 <applicative> ivasilov_:  where are you getting the lists of ints? It might be easy to use some more closely packed representation like Data.Vector.Unboxed
08:16:43 <applicative> ivasilov_:  since Int is an unboxed type
08:17:29 <applicative> or one of the other arrayish types; Data.Vector.Unboxed is my favorite since it's so straightforward
08:18:17 <applicative> you might still use V.zipWith xor vec1 vec2
08:19:06 <mm_freak> zipWith xor is the best method for stream-like data
08:19:35 <mm_freak> vectors/arrays will help, if you actually need all the data in memory
08:21:23 <ivasilov_> applicative: mm_freak: Thanks for the info
08:21:51 <merijn> quicksilver: You write a type signature "nodes :: Foo" somewhere but never wrote a definition "nodes = ..." for it
08:22:02 <merijn> quicksilver: May bad, wrong autocomplete :p
08:40:47 <quest> wat is the prelude function to take away maybe
08:40:57 <pordan30> :t maybe
08:40:59 <lambdabot> b -> (a -> b) -> Maybe a -> b
08:41:27 <quest> so if i maybe (x) where x is maybe 13, then it will return 13?
08:42:30 <quest> also, what is the code that we type in the terminal if we want to summon out the list of prelude functions?
08:42:34 <geekosaur> quest, no, because you haven't specified what to do if it's Nothing instead of Just 13
08:42:43 <geekosaur> (not "maybe 13" or "Maybe 13")
08:43:01 <pordan30> you are looking for fromJust, but you should use it
08:43:05 <geekosaur> if you;re in ghci, try :browse Prelude
08:43:12 <geekosaur> shouldn;t use it
08:43:17 <pordan30> maybe "Nothing" (("Just" ++) . show) (Just 1)
08:43:26 <MrFenix> hi.. how do I auto insert the standard header of haskell files in emacs? is there anything ready to use?
08:43:29 <pordan30> > maybe "Nothing" (("Just" ++) . show) (Just 1)
08:43:32 <lambdabot>   "Just1"
08:43:39 <geekosaur> fromJust is bad because your program crashes if your assumption thta it's always Just is wrong
08:43:40 <mauke> MrFenix: what standard header?
08:44:06 <quest> owh i understand now
08:44:08 <pordan30> oh, geekosaur is right, i mean't shouldn't
08:44:13 <quest> why dun recommend to use
08:44:16 <MrFenix> mauke: http://www.haskell.org/haskellwiki/Programming_guidelines#File_Format
08:44:24 <geekosaur> sincee the whole point of Maybe is avoiding crashes due to missing data, you shouldn't drag those crashes back in with fromJust
08:44:53 <quest> i tried :browse prelude
08:44:54 <quest> not working
08:45:04 <mauke> MrFenix: oh, I don't do that
08:45:15 <quest> im using ghci
08:45:16 <mauke> quest: spelling matters
08:46:05 <geekosaur> case matters too
08:46:06 <MrFenix> mauke: I usually don't do that, too.. but I'd like to start it and I wondered if there is anything ready to use
08:46:12 <geekosaur> the module is Prelude, not prelude
08:46:22 <quest> owh
08:46:34 <quest> great! it worked now
08:49:33 <brideshead> This is probably a perennial question, but is there no function of type (a,b,c) -> a  ?
08:49:48 <brideshead> (Hoogle evidently thinks not.)
08:51:06 <ChristianS> brideshead: i remember having seen a package that extends the fst/snd concept to triples, but i don't remember the name
08:53:16 <jmcarthur> brideshead: http://hackage.haskell.org/packages/archive/utility-ht/0.0.8/doc/html/Data-Tuple-HT.html http://hackage.haskell.org/packages/archive/MissingH/1.2.0.0/doc/html/Data-Tuple-Utils.html
08:53:53 <jmcarthur> brideshead: http://hackage.haskell.org/packages/archive/lens/3.2/doc/html/Control-Lens-Tuple.html
08:54:27 <jmcarthur> > (a,b,c)^._1
08:54:29 <lambdabot>   a
08:54:32 <jmcarthur> > (a,b,c)^._2
08:54:34 <lambdabot>   b
08:54:35 <jmcarthur> > (a,b,c)^._3
08:54:36 <lambdabot>   c
08:56:41 <MrFenix> haskell's strange handling of tuples of size > 2 still escapes me
08:56:47 <jmcarthur> strange?
08:57:10 <jmcarthur> you mean that they are just different constructors?
08:57:15 <jmcarthur> with different types?
08:57:44 <monochrom> what is strange about it?
08:57:53 <int-e> @type _1
08:57:55 <lambdabot> (Functor f, Field1 s t a b) => (a -> f b) -> s -> f t
08:58:10 <MrFenix> yes.. it causes quite a lot of fuss in classes like Typeable
08:58:38 <jmcarthur> i wouldn't say it's strange. a little boilerplatey, maybe
08:59:11 <monochrom> every type causes a lot of fuss in Typeable. this is not specific to tuples. maybe you should say another example
08:59:36 <MrFenix> arrows
08:59:56 <jmcarthur> arrows only deal with 2-tuples, don't they?
09:00:16 <jmcarthur> at least the standard interface
09:00:42 <MrFenix> y.. if you want to use triples and so forth you have to translate them to (a, (b, c)) or ((a, b), c) ...
09:00:55 <MrFenix> which is pure boilerplate again
09:01:06 <jmcarthur> it should mostly be handled by the desugaring for you
09:01:29 <monochrom> wrote in the proc-do notation. then no tuple in sight, any size
09:01:34 <int-e> strictly speaking, nobody is forcing you to use the tuple constructors of higher arity
09:01:37 <monochrom> s/wrote/write/
09:01:39 <jmcarthur> what would the alternative be, anyway
09:01:40 <jmcarthur> ?
09:02:30 <brideshead> ChristianS, jmcarther: thank you.
09:02:47 <MrFenix> I don't like the concept of supporting higher arities then 2 at all
09:03:04 <MrFenix> *a
09:03:12 <int-e> hah. go back to lisp? (scnr)
09:03:13 <jmcarthur> MrFenix: that seems to be in support of the arrow interface you just criticized
09:04:18 <jmcarthur> (to be fair, i too like to stick with lower arity tuples)
09:04:21 <int-e> MrFenix: we have record types, which are very useful for staying sane. which means we have constructors of arity larger than 2 anyway. why would we not use this feature for proper n-tuples?
09:06:40 <MrFenix> the arrow interface is fine and using records for arity > 2 (and even below..) is good practice, in that we agree; I just don't like the fact that if you want to write reusable code you have to take care of higher arities which other people might use
09:15:24 <MrFenix> but I guess finding a good solution is hard; it is in some sense related to the uncurring of kind genericity
09:18:01 <quest> hi, i want [0,1,2,3,4,5] become [(0,1),(0,2),(0,3),(0,4),(0,5)] how do i do it? i dont know how long is my list, so i cant use zip
09:18:35 <quest> i tried map (uncurry 0) to it but didnt work out as well, i think its not how it meant to be
09:18:39 <int-e> > zip (repeat 0) [0..5]
09:18:41 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5)]
09:18:51 <int-e> > map ((,) 0) [0..5]
09:18:53 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5)]
09:19:15 <quest> list comprehension [ (0,x)| x <-a] works?
09:19:28 <int-e> quest: sure, that works too
09:19:45 <portnov> > map (uncurry $ const 0) [0..5[
09:19:46 <int-e> quest: but note that you *can* use zip - just use an infinite list
09:19:47 <lambdabot>   <hint>:1:31: parse error (possibly incorrect indentation)
09:19:54 <portnov> > map (uncurry $ const 0) [0..5]
09:19:56 <lambdabot>   No instance for (GHC.Enum.Enum (a0, b0))
09:19:56 <lambdabot>    arising from the arithmetic seq...
09:20:10 <quest> so what is the cost efficient way to write?
09:20:12 <portnov> > map (curry $ const 0) [0..5]
09:20:14 <lambdabot>   *Exception: showList: No overloading for function
09:20:14 <quest> or simple/elegant
09:20:20 <portnov> eh.
09:20:27 <int-e> > map (curry id 0) [0..5]
09:20:29 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5)]
09:20:36 <MrFenix> map ((,) head xs) (tail xs) $ [0..5]
09:20:51 <int-e> MrFenix: huh?
09:20:54 <yitz> quest: just a matter of taste. personally, i would use zip (repeat 0)
09:21:05 <portnov> quite perl-ish :)
09:21:09 <yitz> in this case
09:21:24 <quest> i dont understand why curry id 0 works
09:21:39 <quest> owh curry needs a function? so id dont do anything, just return 0 and the pair?
09:21:40 <yitz> @type curry id
09:21:42 <lambdabot> a -> b -> (a, b)
09:21:48 <yitz> @type curry
09:21:49 <lambdabot> ((a, b) -> c) -> a -> b -> c
09:21:59 <int-e> curry id  is a round-about way of writing  (,). (note that id may have type (a,b) -> (a,b))
09:22:25 <portnov> @type flip id
09:22:26 <lambdabot> b -> (b -> c) -> c
09:22:48 <MrFenix> (\ xs -> map ((,) $ head xs) (tail xs)) $ [0..5]
09:23:12 <int-e> curry id = \a b -> id (a,b) = \a b -> (a,b) = (,)
09:23:51 <portnov> btw
09:23:56 <portnov> is haskellers.com up ?
09:25:00 <int-e> > (map <$> ((,) . head) <*> tail) [0..5]
09:25:03 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5)]
09:25:39 <portnov> int-e: perl-golf is now obsolete game ;) ?
09:26:05 <int-e> portnov: on #haskell we play the pointless^H^H^H^Hfree game.
09:26:09 <pordan30> > [1..5] >>= return . (0, )
09:26:11 <lambdabot>   Illegal tuple section: use -XTupleSections
09:26:25 <yitz> int-e: also golf sometimes
09:26:32 <pordan30> > [1..5] >>= return . (,) 0
09:26:34 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5)]
09:26:42 * hackagebot debian 3.66 - Modules for working with the Debian package system  http://hackage.haskell.org/package/debian-3.66 (DavidFox)
09:26:45 <kliko> Hi, I am having troubles deriving the show instances for my fixed type, what is the most common way to derive them?
09:27:09 <kliko> (i.e. Fix f = In {out :: f (Fix f)})
09:27:11 <int-e> portnov: because we recognize expert functional programmers by their avoidance of lambdas or variables ;-)
09:27:14 <int-e> yitz: true
09:28:30 <int-e> (I have not seen  http://www.willamette.edu/~fruehr/haskell/evolution.html  in a while)
09:29:51 * geekosaur wonders how one would expect to get a Show instance for such a type
09:31:17 <copumpkin> deriving instance (Show (f (Fix f)) => Show Fix f
09:31:40 <copumpkin> with appropriately balanced parentheses, ideally
09:31:53 <copumpkin> I failed pretty miserably there :P
09:32:06 <int-e> right... deriving instance Show (f (Fix f) => Show (Fix f)  :-)
09:32:11 <int-e> uhm
09:32:15 <int-e> I also fail
09:32:15 <copumpkin> :P
09:32:17 <kliko> oh icic, I will try
09:32:22 <copumpkin> this is a hard problem!
09:32:29 <int-e> deriving instance Show (f (Fix f)) => Show (Fix f)
09:32:34 * copumpkin applauds
09:34:03 <int-e> also needs  {-# LANGUAGE StandaloneDeriving, FlexibleContexts, UndecidableInstances #-}  but then  In (Just (In Nothing)) will be shown as In {out = Just (In {out = Nothing})} :-)
09:37:13 <kliko> Thanks guys I figured it out ^^
09:37:16 <kliko> it works perfectly
09:37:38 <kliko> (PS: I figured I need all those settings as I kept getting the errors ;) :P
09:38:21 <int-e> yes, fortunately ghc is very good at suggesting required extensions :)
09:40:08 <hpaste> “Ertugrul Söylemez” pasted “Efficient parallel safe prime search (again)” at http://hpaste.org/77575
09:42:10 <mm_freak> i love when it works out of the box…  four cores, 390% CPU utilization =)
09:42:25 <copumpkin> mm_freak: my stream of primes is better
09:42:35 <mm_freak> copumpkin: ?
09:42:38 <copumpkin> https://gist.github.com/3889687
09:42:47 <copumpkin> it's so inefficient, nobody even knows what the time complexity is for it
09:43:01 <mm_freak> hehe
09:43:09 <mm_freak> also it gives different answers than mine ;)
09:43:09 <copumpkin> all I know is that the Agda evaluator only lets me ask for the first 3 primes
09:43:21 <copumpkin> mm_freak: how so?
09:43:32 <mm_freak> mine specifically looks for safe primes…  openssl takes forever to do it even for 1024 bits
09:43:34 <srhb> copumpkin: Agda _evaluator_? What is this sorcery.
09:43:36 <mm_freak> mine takes 8 seconds =)
09:43:37 <copumpkin> oh
09:43:52 <copumpkin> srhb: Agda needs a partial evluator built into the type checker
09:43:57 <copumpkin> so I use that instead of compiling
09:44:07 <copumpkin> compilation would probably let me get the first several primes in a reasonable amount of time
09:44:15 <copumpkin> but the typechecker one is slow/inefficient as hell
09:44:46 <thoughtpolice> do you just OOM if you ask for the fourth prime?
09:45:06 <copumpkin> it takes so long and so much memory that I just interrupt it
09:45:34 <mm_freak> copumpkin: i think agda could very well spit out a few primes quickly, if you would use an efficient nat type
09:46:03 <copumpkin> sure, it'd be better, but it's computing fairly complex proofs and my approach to both the proofs and the prime search is inefficient as hell
09:46:12 <yitz> > let uncons (x:xs) = Just (x,xs); uncons _ = Nothing in unfoldr (fmap (first ((,) 0)) . uncons) [1..5]
09:46:14 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5)]
09:46:42 * hackagebot bzlib-conduit 0.2.1.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/bzlib-conduit-0.2.1.0 (HideyukiTanaka)
09:46:53 <mm_freak> > zip (repeat 0) [1..5]
09:46:54 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5)]
09:47:15 <mm_freak> > map ((,) 0) [1..5]
09:47:17 <lambdabot>   [(0,1),(0,2),(0,3),(0,4),(0,5)]
09:47:32 <copumpkin> . map(0,)[1..5]
09:47:34 <yitz> copumpkin: did you design a prime factorization algorithm based on the principle of bogosort?
09:47:39 <copumpkin> > map(0,)[1..5]
09:47:41 <lambdabot>   Illegal tuple section: use -XTupleSections
09:47:54 <copumpkin> yitz: no real factorization really yet :)
09:48:04 <copumpkin> yitz: I have a prime decision procedure
09:48:28 <copumpkin> where prime P is defined as "if a number divides P, it's either P or 1"
09:48:37 <copumpkin> and composite is defined as "there exists a smaller prime that divides it"
09:48:37 <beaky> hello
09:48:51 <mm_freak> hi there beaky
09:48:55 <copumpkin> the tricky thing was getting all the primes
09:49:02 <beaky> how do I make my own data structures instances of Functor?
09:49:06 <copumpkin> I had some earlier work that made an infinite stream of primes, but it didn't have all of them
09:49:24 <copumpkin> termination/productvity is really annoying :)
09:49:33 <mm_freak> beaky: write a Functor instance for them
09:49:53 <mm_freak> instance Functor Maybe where fmap f = maybe Nothing (Just . f)
09:49:54 <pordan30> if m :: * -> *, define an instance for functor m
09:50:13 <beaky> ah
09:50:19 <solarus> > map (join (-) &&& id) [0..5]
09:50:21 <lambdabot>   [(0,0),(0,1),(0,2),(0,3),(0,4),(0,5)]
09:50:27 <yitz> copumpkin: no problem. for each integer n, pick integers smaller than n at random and use your decision procedure to decide if any of them is a factor. if no factor turns up after a long enough time, n is probably a prime.
09:50:47 <copumpkin> yitz: random? probably? what do those mean in formal math? :P
09:51:02 <yitz> copumpkin: that's how bogosort works, except for sorting.
09:51:05 <mm_freak> copumpkin: see "strong pseudoprime" ;)
09:51:05 <copumpkin> I need to be deterministic and prove that I'm terminating
09:51:18 <copumpkin> mm_freak: good luck formalizing that to the point that Agda could deal with it
09:51:53 <mm_freak> copumpkin: i don't see a problem there
09:51:54 <copumpkin> remember, we don't even have natural numbers built in
09:51:58 <copumpkin> okay, how? :)
09:51:58 <beaky> also, how does one fold a binary tree?
09:52:22 <mm_freak> myFunc : (n : Nat) -> PseudoPrime n -> WhateverYouWantToCompute
09:52:30 <copumpkin> mm_freak: how do you define PseudoPrime n?
09:52:31 <portnov> copumpkin: is Agda calculating all primes while compiling that code?
09:52:38 <copumpkin> nope
09:53:13 <portnov> then compilation should take finite time :)
09:53:25 <copumpkin> it typechecks in very little time
09:53:37 <copumpkin> just good luck "forcing" prefixed of that stream of primes
09:53:37 <mm_freak> copumpkin: i'd have to try that out, but i won't, because agda doesn't compile on GHC 7.6 =)
09:53:45 <copumpkin> mm_freak: you can still think about it ;)
09:54:03 <copumpkin> my point is that I don't know of anyone dealing even remotely with "probabilistic" proofs in any formal proof system
09:54:10 <copumpkin> and I don't know how to do it
09:54:15 <copumpkin> and I don't know of anyone else who does, either
09:54:35 <copumpkin> I'd love to, though!
09:54:58 <srhb> beaky: One way might be to fold together the values at each side of a branch, perhaps using identity where the branch is one-sided.
09:55:14 <yitz> copumpkin: actually as usually i rashly jumped into the middle and didn't even know you were talking about agda. but actually yes it sounds fun to think about.
09:55:15 <mm_freak> copumpkin: well, an easy way is to cheat:  PseudoPrime is opaque and has only one constructor…  you can collect such a value only through a specific p[4~rimality test
09:55:25 <mm_freak> that's what i often do in haskell, but yeah, it's cheating
09:55:30 <copumpkin> mm_freak: how does that primality test work though?
09:55:47 <mm_freak> copumpkin: depends on how strong you want "strong" to be
09:56:02 <srhb> beaky: Or you could flatten your tree and then fold it. It really depends what you want to do with your fold. Different traversals are also possible.
09:56:06 <copumpkin> would I construct a monadic value of a decision on some opaque proof type?
09:56:16 <copumpkin> that really doesn't address the problem, unfortunately
09:56:21 <beaky> right
09:56:39 <copumpkin> prime? : (n : Nat) -> Random (Dec (ProbablyPrime n))
09:56:45 <yitz> copumpkin: maybe there's some way to define a "random" stream as one that satisfies some egodicity test
09:57:03 <mm_freak> copumpkin: it's practical, but yeah, you lose type system support, if you mess up
09:57:16 <yitz> *ergodicity
09:57:19 <copumpkin> yeah, it doesn't add anything over Haskell there
09:57:26 <copumpkin> the point is to write real proofs that are verified
09:58:18 <mm_freak> anyway, i don't do formal proofs…  i do static correctness, which is much easier and very practical =)
09:58:44 <copumpkin> but then you need to trust those meaty brains that came up with your probably prime algorithm!
09:58:52 <copumpkin> meaty brains suck :P
09:59:17 <mm_freak> copumpkin: no trust, just you have to know that those numbers are /probably/ prime
09:59:47 <copumpkin> mm_freak: you think those numbers are probably prime because someone designed the algorithm and proved it according to his definitions of probable primality
09:59:58 <copumpkin> I'm saying that person might have been wrong!
10:00:24 <copumpkin> we need to reduce the algorithm down to first principles :)
10:00:36 <copumpkin> (and thus get nothing interesting done at all)
10:00:51 <copumpkin> but there's always trust
10:01:15 <copumpkin> I trust Agda's logic, you trust the guy who designed your algorithm (or if you hand-checked all his logic and proofs, then you trust your own ability to do that)
10:01:25 <mm_freak> i understand what you're saying…  but you can also prove numbers prime much more efficiently
10:01:34 <mm_freak> for example there is the EC primality proof
10:01:46 <copumpkin> sure, but there's a lot of math going into that
10:01:49 <pauser> i have to add two binary (String) number, does haskell have any function for that or i do have to write a function for that
10:01:57 <mm_freak> yeah, so it's probably impractical to encode this in agda =)
10:02:38 <mm_freak> pauser: you have "101" and "10" and want "111"?
10:02:54 <pauser> hmm yes
10:03:05 <copumpkin> bitwise or is good enough for everyone
10:03:09 <mm_freak> pauser: first step:  write a function that turns a binary number string into an actual Integer
10:03:12 <sipa> Haskell has a function for that, but it does not have name yet :p
10:03:39 <mm_freak> pauser: hint:  the type of that function is:  fromBinary :: String -> Maybe Integer
10:03:56 <pauser> mm_freak: but integer does not help i think
10:04:00 <srhb> mm_freak: Why the Maybe?
10:04:04 <srhb> Oh
10:04:08 * srhb facepalms
10:04:08 <mm_freak> srhb: fromBinary "abc"
10:04:08 <copumpkin> then you add the integers, and convert back to binary strings
10:04:18 <pordan30> is there a way to write \mb m1 m2 -> mb >>= \b -> if b then m1 else m2 without the conditional?
10:04:26 <mm_freak> pauser: your second step is to write the inverse:  toBinary :: Integer -> String
10:04:59 <mm_freak> pordan30: yes, write a combinator for it =)
10:05:32 <mm_freak> ifM cp ct cf = cp >>= \b -> if b then ct else cf
10:05:34 <copumpkin> \mb m1 m2 -> mb >>= ([m1, m2] !!) . toEnum
10:05:38 <copumpkin> >_>
10:05:41 <mm_freak> lol
10:05:42 <copumpkin> I mean fromEnum
10:05:58 <srhb> Yikes :P
10:06:01 <jrajav> You could probably do this without converting to Integer
10:06:05 <copumpkin> @pl \mb m1 m2 -> mb >>= ([m1, m2] !!) . fromEnum
10:06:05 <lambdabot> (. flip (flip . (((.) . (!!)) .) . (. return) . (:)) fromEnum) . (.) . (>>=)
10:06:07 <copumpkin> there
10:06:13 * copumpkin 's work is done
10:06:49 <mm_freak> jrajav: not for the usual MSB-encoded binary number
10:07:15 <pordan30> haha, well...the choices make this one hard :)
10:07:20 <beaky> qui
10:07:21 <mm_freak> otherwise yeah, you can implement add-with-carry as a list operation
10:07:29 <srhb> It would actually be pretty enough using a real ifelse function
10:07:56 <srhb> Especially with the conditional at the end.
10:08:03 <srhb> Don't we have that?
10:08:14 <srhb> In the Platform, I mean.
10:08:25 <jrajav> Really? You couldn't write a big-endian binary adder?
10:08:30 <copumpkin> sure you could
10:08:34 <copumpkin> it'd just be ugly
10:08:45 <copumpkin> also, this isn't endianness, really
10:08:48 <copumpkin> it's bit ordering
10:08:49 <mm_freak> jrajav: you would basically go through Integer anyway =)
10:08:53 <jrajav> Meh :P
10:10:10 <jrajav> Am I missing something that keeps you from simply reversing the list and doing the simpler LE adder?
10:10:11 <mm_freak> > foldl' (\x y -> 2*x + y) 0 . map digitToInt $ "1110"
10:10:12 <lambdabot>   can't find file: L.hs
10:10:19 <mm_freak> huh?
10:10:21 <mm_freak> > foldl' (\x y -> 2*x + y) 0 . map digitToInt $ "1110"
10:10:24 <lambdabot>   14
10:10:47 <mm_freak> jrajav: simple, going through Integer is actually much faster ;)
10:10:57 <jrajav> Well duh :P
10:11:08 <copumpkin> well, I think his goal is to implement bitwise math directly, without appealing to any native adders?
10:11:13 <copumpkin> so no foldl' either
10:11:19 <copumpkin> of addition and multiplication
10:11:24 <jrajav> Yeah, I thought that was the exercise
10:11:30 <mm_freak> ah, i see
10:11:39 <copumpkin> jrajav: first reverse both strings
10:11:43 * hackagebot aeson-lens 0.4.0.0 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.4.0.0 (HideyukiTanaka)
10:11:43 <copumpkin> it'll make things a lot easier
10:11:46 <mm_freak> in that case i definitely order from least significant up
10:11:57 <jrajav> It's pretty clear that using anything that results in eventually doing a CPU add would be much faster than high-level bitwise
10:12:26 <copumpkin> if you reverse, then zip, then mapAccum
10:12:33 <copumpkin> I think that'll cover everything you need fairly elegantly
10:12:37 <copumpkin> then you might want to reverse again
10:12:39 <yitz> > let fromBinary = fst . head . readInt 2 (\b -> b=='0' || b=='1') digitToInt in fromBinary "101010"
10:12:41 <lambdabot>   42
10:12:45 <yitz> > let toBinary = flip (showIntAtBase 2 intToDigit) "" in toBinary 42
10:12:47 <lambdabot>   "101010"
10:13:08 <copumpkin> @hoogle mapAccum
10:13:09 <lambdabot> Data.List mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:13:09 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
10:13:09 <lambdabot> Data.List mapAccumR :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
10:13:17 <adek05> Is it possible to use external machine to compile Haskell files? I have very efficient machine with lots of RAM and I would like to use it to compile stuff and then run on deploy machine with different characteristic
10:13:48 <srhb> adek05: Deponds on the "different characteristics"
10:14:20 <yitz> adek05: often a VM is a good idea for that. ghc's cross-compilation is very limited.
10:14:48 <Palmik> Hmm, what is 'entailment' in the context of type theory? (Used in e.g. in 'entailment checking' in the context type functions)
10:14:49 <lambdabot> Palmik: You have 1 new message. '/msg lambdabot @messages' to read it.
10:14:54 <adek05> yitz: Am, could elaborate? Where should I have VM
10:16:49 <yitz> adek05: you can use virtualbox, for example. fire up a VM with the characterstics you need, but with a lot more memory and disk space. compile your program in that VM, and copy the result to the real target machine.
10:17:16 <mm_freak> > let binAdd xs ys = binAdd' 0 (xs ++ repeat 0) (ys ++ repeat 0); binAdd' c (x:xs) (y:ys) = let (q, r) = divMod (x + y + c) 2 in r : binAdd' q xs ys in binAdd [0, 1, 1] [1, 0, 1]
10:17:18 <lambdabot>   [1,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:17:27 <adek05> yitz: Okay. Both of the machines are running 64bit linux distributions, one is Redhat second is PLD
10:17:41 <adek05> Are they 'compatible'?
10:17:43 <pordan30> Palmik: look at "Type Checking With Open Type Functions," section 3.1
10:18:17 <yitz> adek05: i don't know. the biggest issue is probably whether they are using the same version of libc.
10:18:35 <byorgey> Palmik: it's just a fancy word for "implication"
10:18:39 <adek05> yitz: I see... I think I cannot guarantee it...
10:18:46 <mm_freak> @let binAdd xs ys = binAdd' 0 (xs ++ repeat 0) (ys ++ repeat 0); binAdd' c (x:xs) (y:ys) = let (q, r) = divMod (x + y + c) 2 in r : binAdd' q xs ys
10:18:48 <lambdabot>  Defined.
10:18:59 <adek05> The huge problem is that ghc with ld consumes lots of memory...
10:19:03 <mm_freak> > binAdd [1] (repeat 1)
10:19:04 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:19:26 <mm_freak> 2-adic numbers ahoi
10:19:44 <yitz> adek05: yes, that is a common problem. so if you create a VM with everyting exactly right except a lot more memory, it solves that problem.
10:19:50 <sm> morning all
10:20:18 <pordan30> entailment is different than implication, though, at least in the contexts i'm familiar with. but i suppose they're usually synonymous in english.
10:20:39 <yitz> mm_freak: well yes but there is a much more concise way of writing the 2-adic number you get when you add 1 to [1]. It's called "0".
10:20:59 <adek05> yitz: Btw, do you know how helpful could be increasing /swap partition size?
10:21:01 <mm_freak> yitz: it is 0
10:21:01 <sm> I want optional debug logging throughout my program, in pure and monadic code, using some kind of immutable global flag rather than passing opts into everything. What's a good way to do this ? I think there's a lib on hackage
10:21:23 <srhb> adek05: How much memory does your small machine have anyway?
10:21:33 <adek05> 600MB
10:21:37 <srhb> Ouch, okay.
10:22:02 <srhb> adek05: Swap will help.
10:22:56 <adek05> srhb: Thanks!
10:31:31 <Guest25558> hey, anyone know how to download Haskell for Ubuntu?
10:31:39 <yitz> and now that plenty of time has passed, the classic solution:
10:31:44 <yitz> > let fromRadix b = foldr (\x y -> x + y * b) 0 in fromRadix 2 [0,1,0,1,0,1]
10:31:46 <lambdabot>   42
10:31:49 <pordan30> yum install ghc, or whatever, right?
10:31:51 <yitz> > let toRadix b = map (`mod` b) . takeWhile (> 0) . iterate (`div` b) in toRadix 2 42
10:31:53 <lambdabot>   [0,1,0,1,0,1]
10:32:18 <yitz> of course you could put in some reverses, but that would mess up mm_freak's 2-adics.
10:32:28 <Peaker> Guest16170, sudo apt-get install haskell-platform
10:33:35 <yitz> Peaker: wrong guest. the other one already left.
10:34:44 <pordan30> haskell platform ships ghc 7.4.2, however, so you might want to download and install ghc from source
10:35:24 <yitz> pordan30: for most people, you don't even need to build from source. you can just download a ghc binary tarball.
10:35:27 <Peaker> oops
10:36:14 <pordan30> yitz: good idea
10:36:27 <yitz> pordan30: however, if you use a different version of ghc than the official one for that platform version, you begin to lose some of the stability guarantees
10:40:44 <bxx> it is pretty cool that $ and . are just functions.
10:41:06 <bxx> is there any other function that looks like a built in syntax at first glance?
10:49:06 <byorgey> bxx: && and || , perhaps?
10:49:21 <byorgey> in some languages they have to be built in to give them short-circuiting behavior
10:49:29 <byorgey> in Haskell that just comes for free from laziness
10:51:24 <pordan30> demonstrating the operation of >>= to people who don't know haskell, some swear it must be hard-coded
10:52:24 <johnw> heh
10:52:31 <johnw> it can appear quite magical indeed
10:55:42 <parcs`> for most people you can't use the ghc binary tarball because it uses links against an old version of ghc
10:55:51 <parcs`> er, gmp
10:58:19 <nand`> bxx: (+), (*), etc.
10:58:26 <FireFly> bxx: maybe the (:) list constructor
10:59:58 <pordan30> is there a technical reason that a transformer for maybe isn't part of the mtl, or has it merely not been implemented yet?
11:01:20 <jeff__> I'm wondering if anyone can help, I'm having trouble install ghc on Xubuntu
11:02:00 <parcs`> apt-get install ghc
11:02:12 <johnw> pordan30: hoogle is telling me that it is
11:02:18 <johnw> Control.Monad.Trans.Maybe
11:03:01 <srhb> johnw: That's not in mtl.
11:03:16 <jeff__> where would I find haskell though after running that?
11:03:47 <johnw> ah, somehow I got confused and thought he was talking about "transformers", but obviously not
11:03:54 <jeff__> nevermind I have it running now, thanks!
11:03:59 <pordan30> you should have ghc in your path, and you can run ghc using ghc or ghci at the prompt
11:04:59 <srhb> pordan30: I think it's just that ErrorT covers more ground.
11:05:21 <srhb> But yeah, I don't see why it's not there anyway.
11:08:23 <pordan30> according to hackage, control.monad.trans.class defines MaybeT with the appropriate instances (appearing in the archives for mtl), but these seem not to exist in the package obtained through cabal. i.e., control.monad.trans.class appears not to import them
11:08:58 <doomlord> http://www.youtube.com/watch?v=1-0vnRmej0Q
11:09:37 <pordan30> srhb: true, but many functions return in maybe; interestingly, there is no error instance for maybe, although the standard seems to be a definition of MonadError () Maybe for that type. hmm
11:09:47 <lispy> pordan30: is there a reason to use mtl over transformers?
11:10:42 <pordan30> lispy: if arguments from authority work, my argument is that people smarter than myself recommended it on #haskell :)
11:11:44 <jmcarthur> mtl is just transformers with the type classes
11:12:13 <byorgey> pordan30: there is no Control.Monad.Trans.Class module in the mtl package.
11:12:18 <byorgey> mtl has never had MaybeT.
11:12:24 <byorgey> However, MaybeT is in the transformers package.
11:13:29 <byorgey> the general advice is to use transformers unless you specifically want the type class stuff (e.g. MonadState, etc.) in mtl
11:14:12 <pordan30> byorget: i see that you're right. <http://hackage.haskell.org/package/mtl-2.1.2> links to control.monad.trans.class, which links to transformers, which defines maybet
11:15:17 <byorgey> it's confusing because in addition to defining some extra type classes on top of transformers, mtl also re-exports a lot of stuff from transformers because it's supposed to be a mostly-backwards-compatible replacement for the old mtl package
11:15:26 <joeyh> if I have data MyKey = FooA | FooB, and I want to make a lookup :: MyKey -> MyMap a -> a, what's a good way to do that? I'm currently using a Map which is constructed containing all possible keys.. but this is not a type checked invariant.
11:15:28 <byorgey> but it *doesn't* re-export MaybeT
11:16:46 <byorgey> joeyh: will this map change a lot? or is it constructed once and then used just for static lookups?
11:16:51 <joeyh> it's entirely static
11:16:51 <merijn> joeyh: You mean a total map? (i.e. one that enforces that every key has a value)
11:16:56 <joeyh> yes, total
11:17:05 <byorgey> joeyh: in that case, why not just use  type MyMap a = MyKey -> a
11:17:12 <joeyh> values are, say, TMVar
11:17:26 <byorgey> then lookup is just function application
11:17:39 <joeyh> well, how does the function get the TMVars though?
11:17:49 <joeyh> obviously that works for pure values of a
11:18:09 <byorgey> joeyh: what do you mean, how does it "get" them?  you just make a function that returns the right things.
11:18:16 <byorgey> if you can make a Map then you can make a function.
11:18:29 <byorgey> also I have no idea what you mean by "pure values"
11:18:47 <joeyh> well, I'd like it to return the same TMVar every time for a given key.
11:18:59 <byorgey> joeyh: of course.
11:18:59 <joeyh> not construct a new one
11:19:13 <byorgey> why would it construct a new one?
11:19:31 <joeyh> lookup FooA = ???
11:19:46 <byorgey> joeyh: well, you don't write lookup like that
11:20:49 <typoclass> joeyh: i think you'd do "tv <- newTMVar" or whatever the exact syntax is, then put tv into your Map, and after you looked it up you can do readTMVar with it. if you do that often you can of course make a function that does the lookup and read
11:21:15 <byorgey> if you really only have two keys you can do   lookup' a b FooA = a; lookup' a b FooB = b
11:21:17 <joeyh> typoclass: sure, that's what I'm doing now, but as I said, there's no guarantee the map is total
11:21:28 <byorgey> and then create your lookup function by passing lookup' the two TMVars you want to use
11:21:35 <joeyh> ah, I see
11:21:44 * hackagebot perm 0.4.0.0 - permutation Applicative and Monad with many mtl instances  http://hackage.haskell.org/package/perm-0.4.0.0 (AndySonnenburg)
11:21:57 <joeyh> ok, that'll certianly work. I guess I'd need to pass the constructor map for anything more complex
11:26:56 <ivasilov_> quick question: how can I generate only one half (I could get the other half by map $ reverse the first one if I need it) of the permutations?
11:28:38 <johnw> take (equation to get half the number of permutations) (permutations xs)
11:29:22 <johnw> ah, but that won't necessarily be the inverse of the other half
11:29:43 <johnw> huh, interesting question
11:33:47 <ivasilov_> johnw: and that's also kind of brute forcing (generate all, then delete half)
11:35:17 <typoclass> ivasilov_: haskell uses lazy evaluation. in john's example, the elements in the list of permutations are only computed when you access them
11:35:35 <johnw> yeah, but you have to generate them all to find the unique half
11:35:39 <johnw> > permutations [1,2,3]
11:35:40 <lambdabot>   [[1,2,3],[2,1,3],[3,2,1],[2,3,1],[3,1,2],[1,3,2]]
11:35:44 <johnw> the set he wants is 0, 1, 3
11:36:19 <sipa> what makes 0,1,3 different from any other subset?
11:36:22 <johnw> > nubBy (\x y -> x == reverse y) (permutations [1,2,3])
11:36:24 <lambdabot>   [[1,2,3],[2,1,3],[2,3,1]]
11:36:36 <sipa> ah, inverses
11:36:38 <sipa> never mind
11:37:43 <johnw> it makes sense that there should be an algorithm to determine that half without computing the inverse half
11:41:14 <typoclass> ivasilov_: have you looked at the implementation at http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html#line-794 ?
11:49:10 <ivasilov_> typoclass: yes, I've looked into it. I'm looking now into other algorithms to see if I can find some with a predictable generation
11:55:52 <johnw> Data.List's permutations is predictable
11:56:22 <johnw> for [x,y,z], it partitions on z, then on y, then on x; it's the order that's a bit wonky
11:56:33 <johnw> for a 4-element list, the order is 4, 1, 3, 2
11:56:53 <johnw> 5-element is 5,1,4,2,3
11:58:20 <mm_freak> permutations is designed to be as lazy as possible
11:58:29 <Jeanne-Kamikaze> course lab mentions the algorithm can be implemented in any language of choice -> interest in course increases by 100
11:58:38 <mm_freak> > map (take 5) (permutations [1..])
11:58:40 <lambdabot>   [[1,2,3,4,5],[2,1,3,4,5],[3,2,1,4,5],[2,3,1,4,5],[3,1,2,4,5],[1,3,2,4,5],[4...
11:58:47 <hpc> Jeanne-Kamikaze: php!
11:58:49 * hpc ducks
11:59:11 <johnw> this sounds like a good interview question ;)
11:59:56 <merijn> hpc: Piet :)
12:02:33 <hpc> merijn: http://www.imagemagick.org/Usage/convolve/#life
12:03:24 <hpc> life is turing-complete, too
12:04:13 <erasmas> is there a haskell equivalent to python's hexencodedstring.decode('hex') ? I've tried different approaches with Data.Text and ByteString.Char8 but I don't get the same results
12:04:30 <hpc> > read "0xdeadbeef" :: Int
12:04:32 <lambdabot>   3735928559
12:05:14 <sipa> #haskell: faster than your shadow
12:05:41 <hpc> heh
12:05:44 <monochrom> sometimes
12:06:28 <sipa> (assuming a lazy shadow)
12:06:47 <johnw> shachaf: ping
12:06:51 --- mode: ChanServ set +o monochrom
12:07:01 --- mode: monochrom set -b *!*@gateway/web/freenode/ip.66.71.87.158
12:07:38 --- mode: monochrom set -b *!*@ool-182e02bb.dyn.optonline.net
12:07:43 --- mode: monochrom set -o monochrom
12:07:59 <erasmas> hpc: dumb question, but I'm missing something basic. if someone encodes "hello" as hex it produces "68656c6c6f", and I don't know how to get "68656c6c6f" back to hello in haskell
12:08:50 <RichyB> There's actually a text codec in python which is called "hex".
12:09:25 <monochrom> 68656c6c6f is not internationalized, i.e., why assume 2 digits
12:10:04 <RichyB> Works just fine if you expect a byte-string as output and not text.
12:10:50 <johnw> is there a function for chunking any list?  i.e., chunksOf 2 [1,2,3,4] -> [[1,2],[3,4]]?
12:10:59 <byorgey> @package split
12:10:59 <lambdabot> http://hackage.haskell.org/package/split
12:11:08 <sipa> :t splitAt
12:11:10 <lambdabot> Int -> [a] -> ([a], [a])
12:11:13 <johnw> ah, thanks brent
12:11:17 <byorgey> johnw: chunksOf is defined in there
12:11:24 <johnw> sipa: I don't want a single split
12:11:24 <monochrom> split is now in Haskell Platform!
12:11:30 <byorgey> \o/
12:12:24 <johnw> byorgey: are you by any chance working on the Breeze language?
12:12:32 <erasmas> RichyB: ok, I'll look into the how and why of python's approach (I'm stuck decoding some strings encoded with it)
12:13:16 <hpc> erasmas: ah
12:16:17 <byorgey> johnw: no, I'm not
12:16:44 <johnw> i love BlogLiterately, btw, many thanks for that
12:16:51 <byorgey> ah, you're welcome =)
12:17:45 <johnw> today i'm going to figure out how to get the math generation working with my private WordPress; I'd like to use MathJax somehow
12:18:34 <hpc> write a tiny bit of php to shell out to pandoc
12:18:41 <johnw> lol
12:19:08 <byorgey> johnw: yeah, it turns out that pandoc can output math in a number of formats, including mathjax and other things
12:19:09 <johnw> i don't think i'd respect myself in the morning
12:19:17 <johnw> oh, great
12:19:20 <byorgey> I just have to extend BlogLiterately so you can tell pandoc to do that
12:19:39 <johnw> well, i may have a patch for you then :)
12:19:44 <byorgey> though of course I welcome contributions
12:19:46 <byorgey> great =)
12:19:47 <arbn> johnw: If I recall, there are MathJax plugins for wordpress. I know I had it working somehow.
12:19:54 <johnw> yeah, I have one installed now
12:20:02 <byorgey> johnw: see http://hub.darcs.net/byorgey/BlogLiterately/issue/2
12:20:12 <johnw> i just haven't used it yet, since I use BlogLiterately exclusively for writing articles now, and I want it to work through there
12:20:42 <arbn> johnw: Now I'm using Hakyll, though, because it's cool to make things as difficult as possible.
12:21:11 <johnw> yeah
12:21:14 <johnw> i'm lazy, hence wordpress
12:21:26 <byorgey> hehehe
12:21:37 <johnw> looks like hakyll should be using shake
12:21:55 <byorgey> to be fair, hakyll has been around a lot longer than shake =)
12:22:00 <johnw> yeah, true
12:23:12 <arbn> Between tinkering with XMonad and Hakyll, there's not time for anything else! :P
12:24:50 <johnw> yeah, that's the problem with more manual system
12:25:06 <johnw> cool, yes, time sucking, unfortunately
12:26:34 <bxx> thanks, good examples
12:30:15 <RichyB> era
12:30:26 <RichyB> Er, wrong button.
12:31:43 <spaceships> can monads be nested arbitrarily with transformers?
12:32:21 <bxx> some Sources links on hackage are dead
12:32:47 <bxx> for example source of ||.  http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:-124--124-
12:37:37 <byorgey> spaceships: monad transformers can be nested arbitrarily.  Not every monad gives rise to a corresponding monad transformer.
12:43:26 <nand`> I asked earlier but I'll try again in a different timezone: has any work been done in getting weak typing into (some subset of) Haskell? I have a number of isomorphic types that I want to convert as automagically as possible on an ad-hoc, as-needed basis
12:44:04 <johnw> nand`: I assume Data.Dynamic is too weak?
12:44:36 <nand`> yeah; this should be limited to types that are actually known to be compatible
12:44:43 <johnw> also, since I have no background with your problem, how is that different from using type classes to encode the isomoprhism?
12:45:03 <nand`> probably not very; I'm just thinking of a way to get it done with as little overhead as possible
12:45:11 <nand`> user overhead that is
12:45:19 <johnw> perhaps type classes plus existential quantification?
12:45:23 <nand`> in the worst case I'll settle for some magic function ‘convert’
12:46:23 <johnw> oh, you want a morphism (Iso t, Iso t) => t a -> t b?
12:46:29 <johnw> err, just Iso t
12:46:54 <johnw> or maybe I've inverted that
12:47:30 <johnw> (forall t. Iso t a, Iso t b) => a -> b
12:47:52 <johnw> so that a and b are known to be isomorphic in t
12:48:31 <johnw> bah, i think i'm just making a hash of your question
12:48:35 <nand`> I'm not sure how to make sense of that; Iso t a contains t -> a and a -> t ?
12:48:39 * arbn wishes that something using pwadler's blame calculus had already emerged in Haskell-land.
12:48:55 <johnw> well, you have to have another type that represents the isomorphism of a and b, right?
12:49:07 <johnw> or maybe you don't at all
12:49:08 <nand`> no, not really
12:49:09 <hpc> arbn: the blame calculus is quite simple
12:49:23 <hpc> CEO blames underling, underling blames under-underling, ...
12:49:28 <hpc> when the blame stops, that person gets fired
12:49:42 <johnw> nand`: you know, maybe what you want is a (non-Endo)Functor!
12:50:22 <johnw> are you mapping between two concrete types, or two ADTs?
12:50:47 <arbn> Dynamic typing is just unityping, after all. Using a single type, with operators defined to match each case (constructor), would be ugly but sufficient. Or, yeah, you could use convert functions to cast back and forth between your cased type and a stronger one.
12:50:49 <nand`> concrete types
12:51:44 <nand`> like think I have some type Foo and some type Bar; which are isomorphic. I have some function Foo -> X and some function Bar -> Y; the intent is to be able to use either function with a value of either type Foo or Bar
12:52:02 <johnw> this sounds like a functor
12:52:27 <johnw> for each Foo(X) is there a Bar(Foo(X))?
12:52:56 <nand`> what do you mean, for each Foo(X)?
12:53:10 <johnw> for each value that can inhabit Foo
12:53:41 <nand`> like x :: Foo?
12:53:53 <johnw> wait, I may be confusing objects and categories again
12:54:09 <johnw> i hate that I'm used to thinking of "objects" as value, but in Hask they are types
12:54:30 <johnw> so, it's easy enough to convert :: Foo -> Bar
12:54:41 <nand`> yes
12:54:56 <johnw> but you're saying you have a category of types C and another category of types D, where Foo is an object of C, and Bar is an object of D, right?
12:55:01 <nand`> functions Foo -> Bar and Bar -> Foo are assumed to exist; but I'm trying to avoid the user having to call them manually
12:55:03 <johnw> and you want a generalized mapping from C to D?
12:56:13 <nand`> more like I have some category of types C which contains ‘Foo’ and ‘Bar’ and I want to generalize mappings from any object to any object
12:56:32 <johnw> is "Foo" an object in that sentence?
12:56:50 <nand`> in the Haskell type sense, sure
12:57:12 <johnw> ok, so within this category, any object is mappable to any other object?
12:57:20 <nand`> yes. All objects in this category are isomorphic
12:57:22 <johnw> (I think there's a name for this condition...)
12:57:27 <johnw> ok!
12:57:41 <uniquenick> if I want a grid I can access elements of in constant time, is vector the current "approved" package?
12:58:22 <applicative> is a grid something with two dimensions?
12:58:46 <uniquenick> yeah, an array of arrays of ints for example
13:01:12 <nand`> I think I'll realize this by picking out a distinguished ‘intermediate’ object for each category and then encoding the isomorphism to/from this via type classes or something, and when I need to convert to an arbitrary unit I'll go to/from this intermediate one
13:01:16 <applicative> vector is all 1 d , so to say; repa uses it for n dimensions.  Maybe you want some kind of uarray
13:01:42 <ivasilov_> uniquenick: I'm guessing Maps of Maps is better for constant time access
13:02:24 <hpaste> johnw pasted “iso.h” at http://hpaste.org/77579
13:02:39 <johnw> ^^ nand`, let's start here and see if we can't get to what you want
13:03:00 <arbn> nand`: Is there a reason that plain old ADTs would be too unwieldy?
13:03:14 <johnw> so, Iso  lets us make any two types convertible from one to the other and back
13:04:57 <johnw> nand`: see also http://hackage.haskell.org/packages/archive/every-bit-counts/0.1/doc/html/src/Iso.html
13:05:08 <applicative> uniquenick: I would have thought Data.Array.Unboxed, but repa is more sexy
13:05:18 <johnw> he does it without a type class by creating a value type that embodies the isomorphism
13:07:30 <hpaste> nand` annotated “iso.h” with “iso.h (annotation)” at http://hpaste.org/77579#a77580
13:07:37 <nand`> johnw: here's what I was thinking
13:07:50 <nand`> this way, for n types, I need n instances
13:07:51 <nand`> instead of n²
13:07:58 -ChanServ(ChanServ@services.)- shapr set flags +ARfiorstv on johnw.
13:08:05 <nand`> in particular, they don't need to know eachother
13:08:08 <shapr> johnw: done
13:08:19 <nand`> I just need to pick out some canonical representation, in this case ‘Foo’
13:08:21 <nand`> but that's doable
13:10:19 <johnw> shapr: thanks!
13:10:51 <johnw> nand`: probably TH can help undo some of that boilerplate
13:11:04 <johnw> I like the names into and from
13:11:08 <johnw> and the use of type families :)
13:11:52 <johnw> but what about a new type Baz that is isomorphic to both Foo and Bar?
13:11:59 <johnw> that gets combinatorial
13:12:42 <johnw> but I guess you have to state the relatioship between any two types
13:13:38 <nand`> johnw: easy; instance Iso Baz where type Base Baz = Foo; ...
13:13:47 <nand`> convert :: Baz a -> Bar a -- works
13:15:40 <johnw> nice
13:15:48 <johnw> does this solve your problem then?
13:16:02 <nand`> more or less
13:16:30 <nand`> I can just make every function polymorphic with that constraint and slap a ‘convert’ in front of it
13:17:13 <nand`> then the user of the function doesn't need any overhead
13:24:38 <Saizan> i suspect ambiguous type variables everywhere
13:25:16 <hpc> Saizan: oh that's easy to fix
13:25:27 <hpc> they just put a higher-ranked type signature on every composition!
13:25:35 <hpc> :P
13:26:39 <nand`> Saizan: values are still monomorphic at every application
13:26:46 <nand`> and the return type would be monomorphic
13:26:47 * hackagebot data-binary-ieee754 0.4.3 - Parser/Serialiser for IEEE-754 floating-point values  http://hackage.haskell.org/package/data-binary-ieee754-0.4.3 (JohnMillikin)
13:26:56 <gertc> @pl broadcast t = liftIO .: perform $ traverse._2.act (`WS.sendSink` WS.textData t)
13:26:57 <lambdabot> (line 1, column 14):
13:26:57 <lambdabot> unexpected " "
13:26:57 <lambdabot> expecting operator
13:27:09 <hpaste> nand` annotated “iso.h” with “iso.h (annotation) (annotation)” at http://hpaste.org/77579#a77581
13:27:11 <nand`> here's what I'm looking at right now
13:27:15 <nand`> I wonder if there's a way to cut down on the overhead
13:28:14 <mpiechotka> If I have data Nat = Z | S Nat lifted to type in say data Test (n :: Nat) where ... is there a quick way of creating function getN :: Test n -> Nat (I'm using ghc 7.4)?
13:29:19 <johnw> nand`: TH?
13:29:29 <mpiechotka> (I would like the function to be non-strict)
13:29:45 <nand`> johnw: perhaps
13:30:07 <johnw> mkIsomorphic ''Foo ''Bar
13:30:23 <Saizan> mpiechotka: a typeclass constraint like Natural n => ... would work
13:37:24 <applicative> mpiechotka left.  I think an existential wrapper would be likely to work if I follow him.
13:49:53 <gertc> what are the letters from eta stand for?
13:50:14 <hpc> the greek letter eta
13:50:29 <Ralith> η
13:50:49 <zomg> gertc: eta? like "eta 5 min"?
13:51:17 <geekosaur> zomg:  I imagine eta expansion, and it's the Greek letter
13:51:45 <monochrom> eta in #haskell is most likely η
13:51:52 <gertc> that would explain the google eta haskell results
13:53:05 <geekosaur> there's also beta reduction and alpha conversion
13:53:24 <gertc> and what do greeks have to do with compiler omtimisation?
13:53:27 <geekosaur> these are concepts from lambda calculus
13:53:44 <joeyh> so, a cabal question.. network 2.4.0.1 has a minor API change. My code can be compiled using the new API, or the old, by setting a CPP flag. How do I make the cabal file set that flag when cabal uses the new version of network?
13:53:49 <geekosaur> you'll have to ask a mathematician why they like Greek so much :p
13:54:09 <gertc> ok :)
13:54:49 <dcoutts> joeyh: cabal defines macros for each of your dependencies, MIN_VERSION_network(2,4,0)
13:55:27 <joeyh> wow, how did I never see that?
13:55:50 <joeyh> hmm, that's a CPP macro?
13:56:37 <monochrom> yes
13:57:28 <monochrom> http://www.haskell.org/cabal/users-guide/developing-packages.html#conditional-compilation
13:58:43 <nand`> hmm
13:58:57 <nand`> isn't there a constructor for the (~) type in TemplateHaskell?
13:58:59 <nand`> or do I use '(~)
13:59:03 <nand`> '' even
13:59:46 <mgsloan> EqualP :: Type -> Type -> Pred
14:01:07 <monochrom> yeah, type Cxt = [Pred], data Pred = ClassP ... | EqualP Type Type
14:05:27 <nand`> but how do I get that as a Type?
14:06:54 <shachaf> nand`: Why would it be a Type?
14:07:07 <nand`> so I can use it on the right hand side of a TySynD
14:07:32 <nand`> say I want to generate this using TH:  type Foo a = (Num a, Show a)
14:08:31 <mgsloan> ahh, yeah, Constraint Kinds are unfortunately not yet supported :/
14:08:36 <nand`> oh
14:08:38 <nand`> so I'm wasting my time?
14:09:45 <hpc> you can still generate class (Num a, Show a) => Foo a where; instance (Num a, Show a) => Foo a where;
14:09:59 <nand`> oh
14:10:02 <nand`> I can do this
14:10:13 <shachaf> Don't be disgusting, hpc.
14:10:15 <nand`> type Helper f g a = (f a, g a) :: Constraint
14:10:24 <nand`> then generate AppT (ConT ''Helper) ...
14:10:58 <gertc> haskell-beginners is really not a great name for your mailing list http://www.haskell.org/pipermail/beginners/2012-June/010145.html
14:10:58 <mgsloan> maybe for now!  I don't remember what it was, but I feel like some constraint kinds worked with TH somewhat accidentally
14:12:06 <mgsloan> nand`: Hmm, I wonder if that trick could allow usage of ~
14:12:39 <nand`> if I'm generating an associated type definition in a type class instance, would that be a TySynD or a TySynInstD?
14:12:55 <shachaf> gertc: The goal is for beginners to be able to ask questions, not necessarily for beginners to be able to answer them.
14:12:56 <nand`> the actual syntax is that of the former, but the semantics is that of the latter, no?
14:13:00 <shachaf> What's wrong with that question?
14:13:09 <hpc> what cabal-dev should i use with 7.6.1?
14:13:37 <nand`> mgsloan: I have here a type Helper a = (a ~ b, Foo a) -- which works with TH
14:13:58 <mgsloan> cool!!
14:14:25 <gertc> shachaf, problem is that haskell beginners using google get a hart atack
14:15:40 <pdxleif> You notice the monomorphism restriction pretty early on.
14:15:58 <pdxleif> And eta reduction is just (\x->f x) == x
14:16:04 <pdxleif> I mean f
14:16:16 <pdxleif> \x->f x == f
14:17:19 <gertc> i undertsand the concept but it get complicated really fast
14:18:11 <gertc> like i was thinking of getting rit of t :) broadcast t = liftIO .: perform $ traverse._2.act (`WS.sendSink` WS.textData t)
14:19:40 <shachaf> Words you don't know /= complicated
14:19:59 <gertc> true
14:20:44 <mauke> Zerlegungsgleichheit
14:21:10 <gertc> == complicated :)
14:22:19 <Polarina> If you think about it, everything can be phrased in a way that makes in complicated.
14:22:41 <gertc> true
14:23:47 <nand`> hmm
14:23:48 <mauke> after considerable consideration I'm afraid I'm forced to provide your statement with my full approval
14:24:01 <nand`> “Illegal type synonym family application in instance”
14:24:24 <trevize> hello. I'm still fairly new to Haskell. Is there a trick I can use to safely escape the monad call chain? I want to have a function that generates a UUID but I don't really care for it happen at some specific sequence.
14:24:35 <nand`> can this be bypassed?
14:25:30 <Kosta> Hi! What do I need to import in order for ":t Num" to work?
14:25:47 <Kosta> ghci complains: Not in scope: data constructor `Num'
14:25:49 <mauke> Kosta: a module that defines a data constructor called Num, I guess
14:26:12 <raek> Kosta: Num is a type constructor, not a data constructor
14:26:31 <mauke> >implying Num is a type constructor
14:27:02 <Kosta> Well, according to http://www.haskell.org/ghc/docs/7.4-latest/html/libraries/base-4.5.1.0/Prelude.html: The Prelude: a standard module imported by default into all Haskell modules
14:27:04 <raek> or maybe even it doesn't count as a type constructor since it is a type class
14:27:16 <mauke> Kosta: yes, but it doesn't define a data constructor called Num
14:27:22 <Kosta> and I can find Num there, so why does ghci complain?
14:27:27 <nand`> depends on how you define ‘type constructor’
14:27:27 <sipa> types and classes are indepedent
14:27:33 <mcstar> now why would be Num a type constructor? (the usual Num, the typeclass)
14:27:40 <monochrom> Prelude's Num is a type class, not a type
14:27:48 <trevize> Kosta: data can be associated with the Num type class, but Num will not have a type on it's own
14:27:49 <sipa> indepeNdent
14:27:50 <nand`> surely Num is a type, of kind :: * -> Constraint
14:27:55 <monochrom> also, underappreciated fact: type class is not type
14:27:59 <Kosta> ok I wanted to find out about the typeclass, do I not do this using ":t" ?
14:28:00 <sipa> oh, constraint kinds
14:28:13 <nand`> Kosta: :i works best
14:28:16 <monochrom> no, :type does not do type class
14:28:18 <mcstar> nand`: i saw that, but since when? is it a new addition? also, what good is it?
14:28:19 <nand`> as does :k
14:28:37 <nand`> Kosta: :t is only for values
14:28:59 <nand`> mcstar: it's been around for a while now
14:29:28 <Kosta> yes, :i is what I was looking for
14:29:34 <Kosta> thanks a loy, nand`
14:29:53 <Kosta> s/loy/lot/
14:30:35 <mcstar> s/thanks/thank you/
14:31:12 <monochrom> s/ you/s/
14:32:02 <mcstar> i was just kidding :(
14:32:18 <monochrom> then, haha
14:32:36 <monochrom> s|s/ you/s/|haha|
14:33:25 <threedaymonk> I'm writing tests that are parsing Japanese text. It would be really nice to see the actual text instead of "\39135\12358" when something fails. Is there a straightforward way to achieve this?
14:34:06 <mcstar> 食う
14:34:09 <mcstar> thats what i see
14:34:09 <hpc> threedaymonk: putStrLn the actual string
14:34:13 <mauke> fails how?
14:34:24 <hpc> instead of doing print string
14:34:28 <mcstar> little house, and a water tap
14:34:37 <monochrom> putStrLn works
14:34:38 <threedaymonk> hpc: it's the output of HUnit
14:34:39 <hpc> can't show directly in lambdabot, but here's an analogous example:
14:34:44 <hpc> oh, hmm
14:34:57 <mauke> > "é"
14:34:58 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:35:01 <monochrom> then HUnit is over-using print or show
14:35:25 <mauke> threedaymonk: if all else fails, write a script to postprocess the output
14:35:27 <hpaste> nand pasted “illegal type family instance” at http://hpaste.org/77582
14:35:29 <threedaymonk> I think it's probably right to be using show (Just [["\38563","\12398", )
14:35:31 <nand`> why can't this work?
14:35:40 <threedaymonk> mauke: yeah, that might be easiest
14:35:43 <monochrom> anyway, show/print for String is expected to put in quotes and use escapes etc
14:35:47 <nand`> surely the compiler can expand that to ‘instance Bar Char’?
14:36:02 <threedaymonk> monochrom: I know it's meant to. I'd just like it not to. If possible.
14:36:07 <threedaymonk> I don't live in 1993 :-)
14:36:21 <monochrom> the issue is not about 1993
14:36:50 <monochrom> the issue is that Show is meant for "how would you type this as source code"
14:37:00 <threedaymonk> I would type it in UTF-8.
14:37:17 <mauke> perl -pe 's{("(?:[^\\.]|\\.)*")}{ $1 =~ s/\\(\d+)/chr $1/egr }eg'
14:37:43 <mauke> may need PERL_UNICODE=S depending on how your stuff is set up
14:38:11 <merijn> nand`: What's the full error?
14:38:21 <threedaymonk> thanks mauke!
14:38:28 <nand`>     Illegal type synonym family application in instance: Foo Int
14:38:30 <nand`>     In the instance declaration for `Bar (Foo Int)'
14:38:53 <merijn> nand`: Oh! Don't you need {-# LANGUAGE TypeSynonymInstances #-}?
14:38:58 <mauke> oh, and it's completely untested
14:39:00 <nand`> doesn't change
14:39:17 <nand`> merijn: doesn't affect type synonym families, apparently
14:39:35 <merijn> nand`: Ah, bummer
14:39:38 <threedaymonk> I don't have a problem with the default being ASCII-safe, but pretending that UTF-8 is some esoteric magic is absurd in this century
14:39:53 <threedaymonk> well, this decade
14:40:16 <merijn> nand`: What if you define the type family associated with the Bar class?
14:40:22 * threedaymonk still remembers when Mac IE supported UTF-8 but not in drop-downs
14:40:28 <nand`> merijn: non-solution
14:40:35 <merijn> nand`: Oh, wait..that probably doesn't solve your problem at all >.>
14:41:10 <mauke> threedaymonk: haha
14:41:21 <monochrom> UTF-8 is not the only possibility. there is also UTF-16
14:41:30 <merijn> monochrom: Liar!
14:41:34 <mauke> we don't speak about UTF-8
14:41:35 <mauke> er, 16
14:41:40 <mauke> see? I can't even type it
14:42:07 <gertc> ghc -v5 bad idea
14:42:09 <monochrom> in a parallel universe, someone like you is saying "but pretending that UTF-16 is some esoteric magic is absurd in this century"
14:42:16 <threedaymonk> UTF-16 isn't ASCII-compatible. Your argument is invalid :-)
14:42:28 <mauke> and UTF-16 actually is some esoteric magic
14:42:40 <mauke> who even cares about the difference between codepoints and scalar values?
14:42:59 <gertc> where does ghc-mod check get its warning stuf from, i know its not hlint?
14:43:09 <monochrom> I don't actually see why you need ASCII-compatible
14:43:16 <threedaymonk> Then, of course, there's JavaScript-ish UTF-8 ...
14:43:26 <mauke> javascript has utf-8?
14:43:31 <sipa> and who thought it was a good idea to have features at the codepoint level to make a partial encoding viable...
14:43:32 <merijn> gertc: I think it just uses GHC libraries?
14:43:37 <mauke> I thought it was all UCS-2
14:43:53 <sipa> s/partial/particular/
14:44:14 <sipa> the keys are like right next to eachother
14:44:15 <gertc> merijn: yes but i expected that ghc Main.hs would return the same warnings but it does not
14:44:18 <bxx> how do you call undefined? a function? a global variable?
14:44:28 <threedaymonk> JavaScript can use a defective UTF-8, but IIRC astral plane uses surrogates. If at all
14:44:29 <merijn> gertc: Did you run using -Wall?
14:44:36 <gertc> no
14:44:54 <merijn> gertc: Try if that produces the same warnings? :)
14:44:57 <mauke> bxx: I call it ⊥
14:45:03 <sipa> a name
14:45:24 <gertc> merijn: it does :)
14:45:26 <threedaymonk> monochrom: well, no, ASCII-compatible doesn't matter if your system is all UTF-16 or -32, but if that's the case then escaping non-ASCII is moot
14:45:31 <monochrom> undefined is a value and/or variable, depending on what you mean
14:46:06 <sipa> it's also a function if you want it to
14:46:14 <gertc> can you Wall when you ./Setup build ?
14:46:16 <sipa> (it has/can have a function type)
14:46:20 <bxx> function with zero arguments is what it looks like to me
14:46:29 <monochrom> yes, fortunately "value" subsumes "function"
14:46:39 <mauke> bxx: all functions take 1 argument
14:46:42 <sipa> :t (undefined :: Int -> Int)
14:46:43 <lambdabot> Int -> Int
14:47:06 <monochrom> "rectangle or square" is just "rectangle"
14:47:11 <bxx> mauke so undefined is not a function? it's a variable, that throws? odd
14:47:41 <sipa> bxx: it doesn't throw; trying to evaluate it does cause an exception, yes
14:47:41 <mauke> bxx: what
14:47:53 <mauke> bxx: "variable" isn't even in the same category
14:48:04 <sipa> but you can use it like any other variable, as long as you don't look what is "inside"
14:48:06 <mauke> the name 'undefined' is a name
14:48:15 <mauke> the value it's bound to is a value
14:48:16 <monochrom> for the purpose of Haskell, "function" is value whose type contains "->". True is not a function, True :: Bool, does not mention ->
14:48:32 <monochrom> outside Haskell, you are free to talk about 0-arity functions, I don't care
14:48:46 <mauke> s/ contains/'s outermost constructor is/
14:48:58 <bxx> mauka what is it's value?
14:49:03 <sipa> bxx: undefined
14:49:07 <mauke> bxx: bottom
14:49:13 <monochrom> undefined :: a, you may instantiate a to Bool or Bool->Bool or whatever
14:49:23 <gertc> aha cabal ghc-options:-Wall
14:49:23 <mcstar> a dead, rotting cat
14:49:27 <bxx> it has no value. it throws error when trying to fetch it's value
14:49:28 <mauke> well, 'undefined = undefined' would be a valid definition
14:49:33 <sipa> bxx: undefined is of any type you want it to be
14:49:34 <mauke> bxx: yeah, pretty much
14:49:41 <mauke> bottom is the un-value
14:49:54 <sipa> bxx: the reason is that haskell allows you to work with values without evaluating them
14:49:58 <mauke> it's the value of infinite loops, neverending recursion, and runtime errors
14:50:09 <sipa> and the reason that undefined can have any type you like, is because evaluating it is an error
14:50:13 <companion_cube> :t sequence  -- for Hermit
14:50:15 <lambdabot> Monad m => [m a] -> m [a]
14:50:20 <companion_cube> oops
14:51:05 <sipa> bxx: it's called a value in Haskell's semantics, but if you don't like that definition... well yes, there is no real value to speak of associated with it
14:51:32 <mm_freak> bxx: undefined is the value that is never completely calculated…  there are a number of ways to manifest this idea:  exceptions, infinite loops, etc.
14:51:49 <mm_freak> you can define your own "undefined" like this:  myUndef = myUndef
14:51:50 <mauke> infinite exception loops ...
14:51:56 <mauke> (fix error)
14:52:15 <mm_freak> when evaluating myUndef, what's myUndef?  well, it's myUndef…  and what's myUndef?  it's myUndef…
14:52:18 <mm_freak> that's an infinite loop
14:52:42 <Iceland_jack> > fix error -- did someone say...?
14:52:44 <lambdabot>   "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *E...
14:53:03 <mcstar> there is a clear distinction between undefined and an undefined value
14:53:41 <mcstar> can you reproduce 'undefined's behavior, when it is being evaluated, wihtout using undefined?
14:54:01 <gertc> A do-notation statement discarded a result of type GHC.Conc.Sync.ThreadId. Suppress this warning by saying "_ <- ($) It want me to do what?
14:54:25 <mauke> gertc: it wants you to use "_ <-"
14:54:41 <mm_freak> bxx: when you say that "myUndef = myUndef", then the type of myUndef is the type of myUndef (because of the equation)…  type equality is reflexive, so myUndef can take any type…  in other words, the type is fully polymorphic
14:54:43 <gertc> at the end of my do?
14:55:00 <mauke> wat
14:55:09 <mauke> gertc: what's the complete error message?
14:55:17 <geekosaur> gertc, at the beginning of the line that's triggering the warning
14:55:20 <mm_freak> the only constraint is that the type of myUndef is the same as the type of myUndef, and because of the reflexivity every type is valid here
14:55:47 <hpaste> gertc pasted “_ <- ($)” at http://hpaste.org/77583
14:55:54 <geekosaur> gertc, the point is that something is being returned and you should do *something* with it, even if it's jusrt discarding it
14:56:28 <mcstar> so, nobody agrees with me?
14:56:44 <geekosaur> that's mildly weird.  $ is being used prefix?
14:56:47 <mcstar> or can you say, that you can replicate 'undefined' exactly?
14:57:11 <mauke> gertc: in line 148, column 5
14:57:13 <hpc> geekosaur: it's just ask
14:57:14 <hpc> :t ask
14:57:16 <lambdabot> MonadReader r m => m r
14:57:16 <hpaste> gertc annotated “_ <- ($)” with “_ <- ($)” at http://hpaste.org/77583#a77584
14:57:33 <kennyd> undefined' = error "value not defined"
14:58:09 <mm_freak> mcstar: at some point you will be on the 'throw' level, and 'throw' is magic
14:58:31 <mcstar> ok, thats why i think your recursive example is different from undefined
14:58:40 <mm_freak> mcstar: the point is that both throwing an exception and going into an infinite loop is semantically the same value
14:58:51 <mm_freak> it's semantically equivalent
14:59:00 <hpc> they're semantically equivalent until you enter IO
14:59:03 <geekosaur> gertc, so you just want to put "_ <- " at the start of that line (line 6 in the paste)
14:59:04 <mcstar> yeah, but the former terminates, and thats good
14:59:11 <hpc> and then yuck happens
14:59:19 <hpc> but categorically both are bottom
14:59:19 <mm_freak> mcstar: the latter likely terminates as well, when compiled
14:59:20 <geekosaur> "yes, I know it returns a value, and I don't want the value"
14:59:34 <mcstar> mm_freak: <<loop>> ? :)
14:59:39 <mm_freak> yeah ;)
14:59:41 <hpc> mm_freak: the loopy undefined only terminates in the unthreaded runtime
14:59:53 <mm_freak> hpc: can't confirm that
15:00:07 <hpc> ghc can assume that re-entering a thunk indicates non-termination
15:00:24 <mm_freak> % ./primes
15:00:24 <mm_freak> primes: <<loop>>
15:00:26 <hpc> (re-entering in the same stack frame)
15:00:28 <mm_freak> threaded runtime
15:00:31 <mm_freak> main = main
15:00:41 <gertc> ps what happens if you put  _ <- in every do line that does not have a <- ?
15:00:51 <mm_freak> gertc: nothing
15:00:53 <hpc> in the threaded runtime another thread might start evaluating the same thunk as another, and that trick can't apply
15:01:04 <mm_freak> gertc: except perhaps it may mess up your indentation and looks really ugly
15:01:15 * hpc finds docs
15:01:27 <mm_freak> hpc: % ./primes +RTS -N
15:01:27 <mm_freak> primes: <<loop>>
15:02:17 <mm_freak> hpc: again <<loop>> with:  main = let x = x in x `par` x `pseq` return ()
15:02:25 <mm_freak> so i really can't confirm what you're saying
15:03:07 <hpc> mm_freak: compiling with -threaded?
15:03:12 <mm_freak> yes
15:03:15 <hpc> huh
15:03:31 <mm_freak> The Glorious Glasgow Haskell Compilation System, version 7.6.1
15:03:40 <mm_freak> ghc -O2 -threaded -rtsopts --make -o primes primes.hs
15:04:05 <mm_freak> (disregard the name, i just used an existing program)
15:04:14 <hpc> mm_freak: i think the term i am looking for is blackholing
15:05:18 <hpaste> gertc annotated “_ <- ($)” with “this looks awome :)” at http://hpaste.org/77583#a77585
15:05:30 <hpc> and yeah, im probably wrong :P
15:05:53 <hpc> maybe it was true in the past or something
15:05:58 <mm_freak> hpc: at least by my observation
15:06:03 <hpc> otherwise i have no idea where i got it from
15:06:12 <mm_freak> it isn't true at least since GHC 7.0
15:06:18 <Sonderblade> what's the best way to pick the first element of each item in a list of n-tuples?
15:06:45 <hpc> gertc: oh god the security implications
15:06:49 <mm_freak> > let fst' (x, _, _) = x in map fst' (zip3 [1..] [3..] [5..])
15:06:50 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
15:07:00 <gertc> kind of higlight my do stuff _ <- , i like that :)
15:07:19 <gertc> hpc: security?
15:08:06 <hpc> unless there's something i am missing
15:08:27 <hpc> it looks like you are letting arbitrary users post and serve files
15:09:37 <gertc> nope webserver only does static files
15:10:13 <gertc> i wonder if there is no simpler one then happstack i just need static fiels tahts it
15:10:34 <hpc> @google tux webserver
15:10:36 <lambdabot> http://en.wikipedia.org/wiki/TUX_web_server
15:10:36 <lambdabot> Title: TUX web server - Wikipedia, the free encyclopedia
15:10:53 <hpc> it's a frelling kernel module!
15:11:56 <gertc> nice :)
15:12:21 <gertc> but is there something made in haskell?
15:13:29 <mm_freak> gertc: what?  static file serving?
15:14:39 <gertc> yep i use happstack but its a swiss army nife and i only need the knife
15:15:07 <gertc> hapsatck kills my cabal dependecies
15:15:11 <mm_freak> all three major web frameworks support static file serving, and i really suggest you use them
15:15:39 <gertc> but can they not strip it in smaler packges :)
15:15:46 <mm_freak> for snap there is a snaplet and for yesod there is a subsite…  happstack likely has something similar, but i don't know
15:16:06 <mm_freak> snap should be pretty lightweight
15:16:16 <mm_freak> there is also happstack-lite
15:16:49 * hackagebot ot 0.1.1.1 - Real-time collaborative editing with Operational Transformation  http://hackage.haskell.org/package/ot-0.1.1.1 (TimBaumann)
15:17:18 <gertc> yes tried that but i uses teh same dependecies i think
15:18:24 <Sonderblade> i have a function: insert :: (PersistStore backend m, PersistEntity val) => val -> backend m (Key backend val), to insert entities, i can write: do ... insert $ MyEntity 1 2 3, but what map or mapM variant should i use to insert a [MyEntity] list?
15:18:33 <Sonderblade> i cant figure it out because it is inside some weird monad :)
15:18:39 <mm_freak> gertc: if you install the whole framework, it's understandable =)
15:18:47 <mm_freak> at least snap and happstack can be installed componentwise
15:19:15 <mm_freak> Sonderblade: mapM_ insert?
15:19:28 <gertc> ok so what should i cabal install to have minimal dependecies?
15:19:42 <mm_freak> gertc: i don't know happstack too well, sorry
15:19:50 <mm_freak> you'll need at least happstack-server
15:19:50 <gertc> or snap
15:20:01 <mm_freak> for snap i'd really just install snap
15:20:21 <gertc> ok i will look it up
15:23:26 <Sonderblade> mm_freak: that was simple
15:31:13 <m3ga> anyone know of http-conduit works on windows?
15:31:14 <lambdabot> m3ga: You have 1 new message. '/msg lambdabot @messages' to read it.
15:31:49 * hackagebot gtk2hs-buildtools 0.12.4 - Tools to build the Gtk2Hs suite of User Interface libraries.  http://hackage.haskell.org/package/gtk2hs-buildtools-0.12.4 (DanielWagner)
15:31:51 * hackagebot glib 0.12.4 - Binding to the GLIB library for Gtk2Hs.  http://hackage.haskell.org/package/glib-0.12.4 (DanielWagner)
15:31:53 * hackagebot gio 0.12.4 - Binding to the GIO.  http://hackage.haskell.org/package/gio-0.12.4 (DanielWagner)
15:32:08 <Sonderblade> @hoogle Int -> UTCTime
15:32:08 <lambdabot> Prelude (!!) :: [a] -> Int -> a
15:32:09 <lambdabot> Data.List (!!) :: [a] -> Int -> a
15:32:09 <lambdabot> Data.Sequence index :: Seq a -> Int -> a
15:33:23 <mm_freak> m3ga: i don't see why not
15:34:36 <m3ga> mm_freak: well it is windows :-) i know http-conduit is pure haskell, but it has a huge bunch of dependencies.
15:36:55 * hackagebot cairo 0.12.4 - Binding to the Cairo library.  http://hackage.haskell.org/package/cairo-0.12.4 (DanielWagner)
15:36:57 * hackagebot pango 0.12.4 - Binding to the Pango text rendering engine.  http://hackage.haskell.org/package/pango-0.12.4 (DanielWagner)
15:36:59 * hackagebot gtk 0.12.4 - Binding to the Gtk+ graphical user interface library.  http://hackage.haskell.org/package/gtk-0.12.4 (DanielWagner)
15:37:01 * hackagebot gconf 0.12.1.1 - Binding to the GNOME configuration database system.  http://hackage.haskell.org/package/gconf-0.12.1.1 (DanielWagner)
15:37:03 * hackagebot gstreamer 0.12.1.2 - Binding to the GStreamer open source multimedia framework.  http://hackage.haskell.org/package/gstreamer-0.12.1.2 (DanielWagner)
15:37:20 <monochrom> oh, gtk2hs update
15:37:31 <dmwit> GHC 7.6 compabitibility
15:37:37 <fryguybob> dmwit++
15:37:37 <dmwit> nothing much else exciting
15:38:10 <monochrom> compatibility is the most exciting part for most users!
15:38:45 <gertc> finaly
15:39:04 <dmwit> Yeah, it's a bit late. Sorry about that.
15:39:37 <monochrom> hehe
15:39:56 <gertc> al does broken leksah apps, all over the world :)
15:40:01 <mm_freak> m3ga: i'd say just try it out
15:40:28 <m3ga> i actually don't have a windows system to try it on which is why i was asking.
15:40:41 <mm_freak> me neither, sorry
15:41:04 <spherox> hmm, are most people here running linux?
15:41:13 <m3ga> linux or mac
15:41:21 <startling> yeah, os x is common here too.
15:41:31 <dcoutts> dmwit: great
15:41:41 <spherox> interesting
15:41:50 <gertc> so when wil gtk3hs be out :)
15:42:08 <monochrom> gtk2.71828hs first
15:42:09 <m3ga> spherox: interesting how?
15:42:09 <gertc> or does the 2 not refer to gtk
15:42:12 <dmwit> As soon as I get my act together.
15:42:21 <monochrom> and then gtk3.14159hs
15:42:31 <dmwit> which will certainly not be this week =)
15:42:36 <spherox> m3ga, I don't know many programmers who use OS X
15:42:48 <dmwit> (and yes, the 2 refers to gtk)
15:43:14 <m3ga> spherox: really common in the webdev world, especially for ruby on rails.
15:43:55 <spherox> m3ga, hmm, I guess that make sense. Also, now that I think about it, "app" developers are also abundant
15:44:27 <m3ga> spherox: yeah, i'd even forgotten about all the iOS and android devs
15:45:17 <kfish> dmwit: anything we can do to help with the gtk2hs release? testing?
15:45:43 <dmwit> Yes please! Check that it compiles.
15:46:05 <dmwit> I got some very mysterious warnings during cabal sdist, so if it compiles on somebody else's machine that's already a big step forward. =P
15:46:22 <kfish> ok!
15:46:47 <monochrom> you need some sandboxing ninja techniques to test on your own computers :)
15:47:01 <gertc> try to install leksah also :) it mest up my .ghc :)
15:47:23 <hpc> monochrom: also known as cabal-dev
15:47:29 <monochrom> all of you need some sandboxing skills
15:48:40 <monochrom> but yes, it could be as simple as cabal-dev or virthualenv etc
15:52:00 <spherox> So let's say I have a truck that can hold a fixed weight
15:52:15 <dmwit> I like where this question is going.
15:52:22 <spherox> and I'm driving around a bunch of cities (weighted graph)
15:52:42 <spherox> in each of these cities, various items are for sale at varying prices
15:53:11 <spherox> my goal is to pick up items where they are cheap and sell them where they are valuable (maybe think space trader in EV Nova)
15:53:41 <spherox> Do any of you know the NP Hard problem that I'm describing?
15:54:14 <spherox> oh, I forgot the last sentence. So I'm optimizing for the best path through the cities, and maximum profit while constrained by my truck's capacity
15:54:58 <spherox> It is like a knapsack-problem/travelling salesman medley
15:55:36 <spherox> hmm, maybe I should ask this in #algorithms
15:55:37 <sipa> let's call it the travelling knapsack problem!
15:55:55 <mauke> http://javadoc.bugaco.com/com/sun/java/swing/plaf/nimbus/InternalFrameInternalFrameTitlePaneInternalFrameTitlePaneMaximizeButtonPainter.html
16:00:26 <byorgey> mauke: wat
16:03:24 <gertc> wich webserver can integrate runWebSockets? haskell.org/packages/archive/websockets/0.7.1.0/doc/html/Network-WebSockets.html
16:06:31 <ion> Yay, i have GHC running on the Beagle Bone (ARMv7), thanks to Debian’s porting efforts.
16:07:55 <Cale> gertc: I'm thinking that'd be easiest to integrate with Snap probably?
16:08:06 <Cale> gertc: Really, any of them should do.
16:08:57 <Cale> (but there might be some fiddling around with iteratees that you have to do)
16:09:47 <gertc> sound like suicide :)
16:10:22 <luite> it's also pretty simple with yesod/warp (use settingsIntercept in the warp Settings)
16:10:39 <edwardk> straw poll: Who is in favor of (or against) adding Data.Vector.Lens to lens?
16:10:46 <edwardk> pros: vector lenses. cons: another dependency, and i probably have to ship 40 packages to clear the need for vector-instances from all my other packages to make it fully kosher
16:11:01 <Ralith> it seems like you could ask the same question for any lib; shouldn't it be the responsibility of the lib to depend on lens and provide those features itself instead?
16:11:02 <edwardk> on the other hand, vector isn't as bad as it used to be about providing instances.
16:11:18 <edwardk> so the original argument that forced me to make vector-instances in the first place is now invalid
16:11:37 <edwardk> and it is now in the platform so it falls under the purview of what i said lens considers 'in scope'
16:11:56 <m3ga> gertc: Wai (used by Yesod and possibly others) can use web sockets : https://github.com/yesodweb/wai/tree/master/wai-websockets
16:12:06 <Ralith> that would suggest you not really consider it another dependency, then
16:12:17 <edwardk> Ralith: thats kind of where i'm going
16:12:48 * Ralith doesn't have a stake in this one way or the other, but thinks consistency is generally a good idea, and being expected to provide lenses for everything in the world is not
16:12:53 <edwardk> my main headache is killing the vector-instances package and shipping dozens of packages
16:13:19 <Peaker> edwardk, lens-vector, lens-foo, lens-bar for minimum deps sounds nicest to me
16:13:22 <Ralith> that doesn't make this course of action any more or less meritous except insofar as :effort:
16:13:27 <edwardk> like i said, i've limited my scope to packages that are in the platform or that i need to implement the implementation of lens itself
16:13:55 <Ralith> are you happy with providing implementations for everything in platform (and thereby requiring that everything that depends on lens, depend on the platform)?
16:14:08 <edwardk> Peaker: i've already rejected that design. it is a pain in the ass for users in general. orphan instances are by far the worse evil
16:14:22 <edwardk> Ralith: it already effectively does
16:14:41 <Peaker> edwardk, I never understood why "official orphans" by the same author cause any pain at all
16:14:51 <ion> edwardk: Well, i for one wouldn’t mind the dependency on vector.
16:15:15 <Peaker> edwardk, depending on lens-vector if I want to use lens with vector doesn't sound like a pita?
16:15:25 <edwardk> Peaker: because you still have to know they are there, they clutter up your cabal file, become another import. if you forget to import the _module_ your code stops working, etc.
16:15:49 <Ralith> then it sounds like there shouldn't even be any question; implement it!
16:15:56 <edwardk> the problem is that there are many combinators that come from classes in lens. for things like TraversableWithIndex, etc.
16:15:59 <Ralith> to do otherwise would be overt inconsistency.
16:16:02 <Peaker> edwardk, are all the vector related lens things just instances?
16:16:34 <edwardk> the issue is the 3 instances. there are a bunch of actual lenses that would go in Data.Vector.Lens for "backpermuted", etc.
16:16:50 <edwardk> if it wasn't for those instances, i'd leave them exile to vector-instances
16:16:56 <edwardk> er leave them exiled
16:17:29 <edwardk> e.g. https://github.com/pthariensflame/lens/commit/62274ebfc45d6a0dee0d27389b3127975f40298b
16:18:07 <edwardk> er i mean if it wasn't for those lenses.
16:18:43 <edwardk> Ralith: i have to admit i agree =)
16:18:53 <edwardk> i just wanted to sound myself out on the topic =)
16:19:01 * Ralith quacks ^^
16:19:21 <Peaker> edwardk, I guess it's a choice between dependency higyne pita and orphan instances pita.. I personally prefer the latter because imports are the least important part of my code to make nice
16:19:52 <edwardk> Peaker: yeah, we've gone round on this one before, so i guess we'll just have to agree to disagree. ;)
16:20:00 <Peaker> ok :)
16:20:26 <edwardk> i just hate fielding questions from users who forgot to import the moral equivalent of Control.Monad.Instances
16:20:51 <edwardk> it is the sort of question that leads to the user abandoning the library/language, because its needless pain
16:21:28 * Ralith suspects that a user who abandons lens/haskell because an import was less than obvious was not going to be around for long anyway
16:21:34 <edwardk> Ralith: =P
16:21:45 <edwardk> the C.M.I thing was a source of more than one rant in here ;)
16:22:15 <ion> Orphan ALL the instances!
16:22:37 <edwardk> ugh. this gets ugly because it means i'd have to push semigroup down into semigroups
16:22:56 <edwardk> otherwise its perfectly palatable
16:23:11 <edwardk> meh, in for a penny...
16:23:22 <nicoo> ion: All your instances are belong to us.
16:23:37 <edwardk> oh i can't do that actually
16:23:45 * lispy waves
16:23:46 <edwardk> because semigroups supports hugs still
16:24:12 <lispy> Just talking to a friend about vcs issues in the community. I wish the darcs-git bridge was usable.
16:24:52 <lispy> It's fine if people want to use darcs, but by not at least *offering* git support (github specifically) they are seriously throttling contributions.
16:24:52 <mcstar> nicoo: singular, not plural
16:25:05 <ion> nicoo: “All your instance are belong to us”
16:25:17 <nicoo> Sorry
16:25:21 <mcstar> XD
16:25:30 <edwardk> i suppose this argues for the continue existence of vector-instances for the other stuff, and just sucking back in the instances for lens stuff
16:25:36 <edwardk> which makes this easy
16:26:36 <pdxleif> lispy: What darcs-git bridge are you speaking of?
16:26:39 <lispy> edwardk: did you see that bikker finished his phd?
16:26:47 <edwardk> yeah
16:27:03 <lispy> pdxleif: Hmm...I think this one: http://darcs.net/DarcsBridgeUsage
16:27:04 <edwardk> i had honestly thought he'd done it years ago
16:27:05 <edwardk> =)
16:27:11 <lispy> pdxleif: it was GSoC project
16:27:13 <edwardk> he's been teaching there forever
16:27:48 <lispy> the darcs wiki style sheet is pretty nice these days
16:27:56 <lispy> glad to see darcsit working out so well for them
16:28:05 <pdxleif> I import darcs repos to GitHub all the time, but I'm unsure of how to submit pull requests back to the original project. :/ https://github.com/leifw
16:31:34 <lispy> pdxleif: cool. BTW, your personal website (the one mentioned on github) seems to be down.
16:32:09 * lispy really needs to redo the style sheet on his blog and switch to a different way of doing math
16:32:38 <hpc> pandoc!
16:32:50 <lispy> hpc: maybe? mathblog (you can find it on hackage) seems nice
16:33:14 <lispy> hpc: I use blogspot at the moment because I don't really want to worry about server maintenance
16:33:37 <lispy> I tweaked one of their css templates, but I'm really not pleased with the font I'm using.
16:34:11 <hpc> lispy: heh, maintaining a server isn't that hard imo
16:34:54 <hpc> (but i would have this box up 24/7 anyway, so ymmv)
16:36:12 <lispy> hpc: I did it for a few years, but I never backed up the machine and one year it started to become unreliable. blogspot keeps applying security patches and all that for free.
16:36:14 <gertc> anything deprecated in this setup or i should know abaout?  websokects -> wai-websocket -> wai -> warp
16:36:52 <hpc> lispy: ouch
16:37:01 <m3ga> gertc: wai and warp are definitely ok. haven't used the other two.
16:37:04 <lispy> hpc: I didn't lose any content, luckily.
16:37:34 <hpc> i don't back my box up, but i have it set up in such a way that "any linux install is disposable"
16:37:39 <gertc> m3ga: can the warp thing serve just static files
16:37:42 <hpc> er, don't back my whole box up
16:37:44 <edwardk> @tell roconnor https://github.com/ekmett/lens/pull/84 do these pass the traversal laws?
16:37:45 <lambdabot> Consider it noted.
16:38:02 <hpc> stuff is on github and in dropbox, and i have a cron that archives things so they are replicated on multiple machines and a NAS
16:38:10 <lispy> hpc: If I went back to self-hosting I would actually make my blog a git repo and host it from github. I've seen that work quite well.
16:38:21 <hpc> heh
16:39:01 <m3ga> gertc: (from memory) warp is a library for writing web servers. for serving static stuff you probably want yesod-static.
16:39:22 <pdxleif> lispy: thanks for the heads-up.  Maybe I had forgotten to have that server run at boot. :<
16:40:08 <lispy> pdxleif: np. As a fellow portlander I was interested in what you had on your site :)
16:41:08 <pdxleif> Nothing much, just links to my other accounts, some RDFa markup, a public key... I should do a blog someday.
16:41:51 * hackagebot cr 1.1 - Code review tool  http://hackage.haskell.org/package/cr-1.1 (AlexandruScvortov)
16:42:06 <lispy> hmm.../me checks out cr
16:43:25 <pdxleif> Coming to PDXFunc tomorrow?  There will be Bart Massey talking about bidirectional superfolds, and cake.
16:43:32 <lispy> hmm..so I guess it turns git log entries into something kind of like a mailbox?
16:43:51 <lispy> I have an appointment elsewhere at that same time
16:43:53 <Taslem> I'm looking for a library like curses which doesn't have hundreds of dependencies and works on Windows.
16:44:14 <lispy> Taslem: does vty satisfy those constraints?
16:44:27 <Taslem> I'll look into that.
16:44:32 <lispy> Taslem: vty has the added benefit of vty-ui that makes it easier to build guis with
16:44:37 <lispy> or should I say, tuis
16:45:06 <Taslem> I only need simple text, really. Roguelike is what I plan to make. I just need to avoid refresh issues.
16:45:10 <neworder> Hi guys
16:45:13 <neworder> I was reading this
16:45:14 <neworder> http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion#Introducing_fix
16:45:34 <lispy> > fix show
16:45:34 <neworder>  let fact n = if n == 0 then 1 else n * fact (n-1) in fact 5
16:45:35 <lambdabot>   "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\...
16:45:46 <Nereid> lispy: haha.
16:45:52 <neworder> It says there, Here we have used fix to "encode" the factorial function
16:46:14 <neworder> I don't really get this part, our second definition of fact doesn't involve recursion at all.
16:46:17 <lispy> > fix (\rec n -> if n == 0 then 1 else n * rec (n-1)) 5
16:46:19 <lambdabot>   <hint>:1:7: parse error on input `rec'
16:46:31 <EvanR7> Taslem: ncurses
16:46:31 <Nereid> rec is a keyword
16:46:36 <hpc> neworder: it's a mechanical transformation, but the wikibook doesn't make that part obvious
16:46:47 <hpc> let fact n = if n == 0 then 1 else n * fact (n-1) in fact 5
16:46:50 <hpc> let's rename fact
16:46:56 <neworder> ok
16:47:01 <hpc> let rec n = if n == 0 then 1 else n * rec (n-1) in rec 5
16:47:12 <hpc> now let's do something really weird
16:47:19 * EvanR7 does a double take at 'let rec'
16:47:20 <hpc> let f rec n = if n == 0 then 1 else n * rec (n-1) in rec 5
16:47:22 <hpc> -- OR
16:47:31 <hpc> let f = \rec n -> if n == 0 then 1 else n * rec (n-1) in rec 5
16:47:40 <Taslem> Okay, so: cabal: The package has a './configure' script. This requires a Unix  compatibility toolchain such as MinGW+MSYS or Cygwin.
16:47:46 <hpc> neworder: still following?
16:47:46 <neworder> ok
16:47:48 <neworder> then
16:47:49 <neworder> Yup
16:47:50 <Taslem> But I do have MinGW+MSYS installed.
16:47:51 <mauke> hpc: error: 'rec' not in scope
16:47:59 <Taslem> Any idea how to let cabal know where they are?
16:48:13 <hpc> neworder: now (fix f) = fact
16:48:17 <Nereid> Taslem: put the mingw binaries in your PATH
16:48:28 <hpc> for reasons i think are covered in the wikibook if you re-read
16:48:38 <neworder> hmm
16:48:39 <m3ga> Taslem: what are you trying to install?
16:48:52 <hpc> the wikibook then inlines f, and you get the final result of
16:49:01 <hpc> fix (\rec n -> if n == 0 then 1 else n * rec (n-1) in rec 5)
16:49:02 <Taslem> m3ga: A few things lately. ncurses at the moment.
16:49:08 <Nereid> neworder: let me try putting it a different way
16:49:14 <Nereid> neworder: let me write fact as
16:49:14 <neworder> sure
16:49:24 <Nereid> fact = \n -> if n == 0 then 1 else n * fact (n-1)
16:50:05 <Nereid> so fact is a "solution" to the equation f = \n -> if n == 0 then 1 else n * f (n-1)
16:50:21 <Nereid> this is exactly to say it is a fixed point of the function \f -> (\n -> if n == 0 then 1 else n * f (n-1))
16:50:36 <Nereid> I don't know why I put quotes around "solution", because it literally is a solution.
16:50:52 <Nereid> now
16:50:56 <neworder> hmm
16:50:58 <neworder> ok
16:50:58 <Nereid> fix takes any function and gives you a fixed point of that function
16:51:08 <Nereid> so in particular, fix (\f -> (\n -> if n == 0 then 1 else n * f (n-1))) is fact
16:51:13 <Taslem> Nereid: They are, I just checked.
16:52:02 <Nereid> Taslem: oh, here's what I did
16:52:09 <Nereid> run cabal from within a mingw shell
16:52:25 <Taslem> I'm not all that familiar with mingw. How exactly do I do that?
16:52:38 <Nereid> open mingw shell
16:52:44 <Nereid> and type cabal install whatever
16:52:51 <hpc> neworder: to be a bit more technical, it gives the least fixed point; that's not important for this explanation :P
16:53:02 <Taslem> Oh, that's all. Okay.
16:53:13 <neworder> hmm yup, get the least fixed point part
16:54:13 <Nereid> anyway, this is entirely mechanical
16:54:31 <Nereid> whenever you have a recursive definition f = <something involving f>
16:54:35 <Nereid> you can change that to
16:54:40 <Nereid> fix (\f -> <something involving f>)
16:54:57 <Nereid> f doesn't even have to be a function, I guess.
16:55:02 <neworder> hmm ok
16:55:11 <hpc> hopefully that helps you see how fix "encodes" recursion
16:55:15 <neworder> I just don't see clearly how the recursion can be encoded
16:55:23 <neworder> Haha
16:55:30 <Nereid> I don't know what "encoded" means.
16:55:33 <Nereid> but the point is that
16:55:38 <neworder> My mind is corrupted
16:55:42 <neworder> haha
16:55:43 <EvanR7> reformat
16:55:45 <neworder> Oh
16:55:45 <Nereid> after this translation, all of the recursion is being done by fix
16:56:02 <neworder> Finding a way to reformat!
16:56:08 <neworder> hmm
16:56:09 <Nereid> so in some sense, fix is the universal recursive function.
16:56:21 <neworder> The word encoded is in the book
16:56:24 <Nereid> because any other recursive function can be written in terms of fix and a non-recursive function.
16:56:27 <neworder> I mean in the link
16:56:38 <EvanR7> funny that the emphasis here is on recursion, when fix doesnt have to be defined recursively ;)
16:56:42 <EvanR7> (it does in haskell through)
16:56:50 <EvanR7> though
16:57:07 <shachaf> fix is recursion, whether it's defined recursively or not. :-)
16:57:13 <Taslem> Okay, so... I'm back to where I was before.
16:57:17 <EvanR7> shachaf: heh
16:57:25 <EvanR7> dogma!
16:57:29 <Taslem> I'm looking for a curses like library that works on windows without hundreds of dependancies.
16:57:46 <Nereid> EvanR7: no, you can write the y combinator directly in haskell, with some newtype trickery.
16:57:47 <hpc> Taslem: that works in cmd.exe?
16:57:55 <EvanR7> Nereid: yes but that doesnt count
16:57:56 <shachaf> Nereid: Yes, which uses recursion.
16:57:57 <hpc> i don't know of anything like that
16:58:05 <Taslem> hpc: I'm not that picky.
16:58:05 <Nereid> shachaf: haha.
16:58:22 <hpc> Taslem: the silly answer would be curses in cygwin
16:58:45 <EvanR7> throw out ncurses and use graphics which draw glyph tiles
16:58:59 <hpc> heh
16:59:12 <fryguybob> Taslem: ansi-terminal?
16:59:14 <Nereid> apparently there's something called pdcurses, which works on win32
16:59:15 <hpc> and just for fun, shell out to `clear` for each page refresh
16:59:16 <parcs`> @where y
16:59:16 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
16:59:38 <Taslem> fryguybob: I can't use that to refresh instantly, so you get visible artifacts when changing lots of the terminal.
16:59:59 <lispy> Taslem: WHat package gave that msys error? I'm on windows. I could try it too.
17:00:10 <EvanR7> someone is making a rogue like which works on a 'real' terminal in 2012
17:00:11 <Taslem> lispy: ncurses errored
17:00:24 <lispy> Taslem: ah. Any luck with vty?
17:00:27 <Taslem> lispy: Though that's cause I'm missing dependencies
17:00:32 <Taslem> lispy: Different issue with vty.
17:00:56 <lispy> Taslem: Is windows a hard requirement for you?
17:01:03 <EvanR7> let the past be consigned to history
17:01:07 <Taslem> lispy: It was installing and then for whatever reason a package called "unix-2.6.0.0" is a requirement
17:01:15 <Taslem> lispy: yes, pretty much.
17:01:19 <lispy> Taslem: many haskell things simply work better in linux/osx. So if you have the option, I recommend learning haskell there.
17:01:37 <Taslem> I'll consider it. Gotta go.
17:01:44 <lispy> Taslem: I'm trying vty now and getting the curses errors too
17:01:52 <slack1256> to learn about syb I kept getting recommended that 2003 paper about it
17:02:01 <slack1256> is still relevant for the current implementation?
17:03:16 <plhk> hey, is this true in some approximation . == <>; id == mempty or am i totally confused?
17:03:38 <EvanR7> looks right
17:03:47 <shachaf> plhk: For Endo, yes.
17:03:54 <EvanR7> for functions on the same type
17:03:57 <shachaf> @src Endo
17:03:57 <lambdabot> Source not found. You type like i drive.
17:04:13 * lispy doesn't trust lambdabot to drive
17:04:25 <shachaf> newtype Endo a = Endo { appEndo :: a -> a }; instance Monoid Endo where mempty = Endo id; Endo a <> Endo b = Endo (a . b)
17:04:48 <Nereid> more generally, for any Category c, c a a forms a monoid.
17:04:51 <startling> plhk: yep, look at Category. "A class for categories. id and (.) must form a monoid."
17:05:20 <shachaf> You can also take any monoid and convert its values to functions by using (v ++) instead of (v), and id instead of mempty
17:05:27 <lispy> :t (<>)
17:05:27 <Nereid> newtype Endo c a = Endo { appEndo :: c a a }; instance Monoid (Endo c) where (exact same thing)
17:05:28 <lambdabot>     Ambiguous occurrence `<>'
17:05:28 <lambdabot>     It could refer to either `Data.Monoid.<>',
17:05:29 <shachaf> Then you apply the whole thing to mempty when you're done.
17:05:29 <lambdabot>                              imported from `Data.Monoid' at State/L.hs:35:1-18
17:05:38 <lispy> :t (Data.Monoid.<>)
17:05:39 <Nereid> shachaf: you mean (v <>)
17:05:39 <lambdabot> Monoid m => m -> m -> m
17:05:40 <shachaf> Difference lists are an example.
17:05:52 <startling> shachaf: are you sure you mean (v ++)?
17:05:55 <shachaf> I mean mappend by whatever name.
17:05:58 <startling> oh right
17:05:59 <lispy> ?quickcheck mappend == (Data.Monoid.<>)
17:05:59 <lambdabot> Unknown command, try @list
17:05:59 <shachaf> @ty (++) -- ∎
17:06:01 <lambdabot> Monoid m => m -> m -> m
17:06:07 <lispy> ?check mappend == (Data.Monoid.<>)
17:06:09 <lambdabot>   Not in scope: `myquickcheck'
17:06:24 <EvanR7> lambdabot has <> now
17:06:27 <shachaf> That @check won't give you anything interesting because it's a type-level question. :-)
17:06:36 <Nereid> Cayley made that observation forever ago.
17:06:37 <shachaf> Cale: @check is broken.
17:06:44 <shachaf> @tell Cale @check is broken.
17:06:44 <lambdabot> Consider it noted.
17:07:01 <lispy> @scheck 1 == 1
17:07:03 <lambdabot>   Not in scope: `myquickcheck'
17:07:10 <mauke> > "ä"
17:07:11 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:07:17 * lispy doesn't even know if scheck still mean smallcheck
17:07:24 <shachaf> > let á = 5 in á
17:07:24 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
17:07:26 <uniquenick> I can create a multidimensional boxed immutable array using "array ((0,0),(256,256))".  how can I make a multidimensional unboxed mutable array?
17:07:30 <shachaf> Hmm, that used to work.
17:08:01 <startling> :t array
17:08:03 <lambdabot> Ix i => (i, i) -> [(i, e)] -> Array i e
17:08:03 <lispy> uniquenick: MUArray?
17:08:31 <Nereid> IOUArray and STUArray are mutable unboxed arrays
17:08:44 <Nereid> which you can make with newArray
17:09:06 <EvanR7> :t newArray
17:09:08 <lambdabot> Not in scope: `newArray'
17:09:28 <Nereid> :t Data.Array.MArray.newArray
17:09:29 <lambdabot> (Ix i, Data.Array.Base.MArray a e m) => (i, i) -> e -> m (a i e)
17:09:37 <lispy> ah, STUArray is what I was thinking of
17:10:24 <deech> Hi all, are null values in sets analogous to bottom in types?
17:11:07 <Nereid> I don't understand the question.
17:11:15 <Nereid> what is a null value?
17:11:26 <EvanR7> :t Nothing
17:11:28 <lambdabot> Maybe a
17:11:59 <Nereid> there is no analogy for the bottom value of a type to sets.
17:12:13 <Nereid> however, there is to pointed sets: the distinguished point corresopnds to bottom.
17:12:23 <lispy> what is a pointed set?
17:12:24 <Nereid> (note that the category of pointed sets is equivalent to the category of sets with partial functions)
17:12:31 <Nereid> lispy: a set with a distinguished element.
17:12:36 <deech> Nereid: I mean that all sets in math have a null, right? Since all types also have a bottom I figured they might have something in common.
17:12:39 <uniquenick> Nereid, how do I make it multi-dimensional though?  I don't see any equivilent functionality to "array" letting me give upper/lower bounds in tuples
17:12:41 <Nereid> deech: what?
17:12:45 <lispy> Nereid: What is a distinguished element?
17:12:48 <Nereid> uniquenick: the same way
17:13:01 <Nereid> lispy: a pointed set is a pair (X,x), where X is a set and x is an element of X.
17:13:10 <Nereid> a morphism (X,x) -> (Y,y) is a function f: X -> Y such that f(x) = y
17:13:10 <EvanR7> deech: you sound like youre talking about SQL haha
17:13:38 <lispy> deech: what is the null element of the natural numbers?
17:13:53 <Nereid> what is the null element of the empty set?
17:13:53 <EvanR7> NULL
17:14:05 <lispy> Nereid: I think I understand now (re: distinguished elements)
17:14:25 <Nereid> lispy: the Pointed class is the analogous thing internal to haskell.
17:14:45 <lispy> ?hoogle Pointed
17:14:45 <lambdabot> package pointed
17:14:46 <lambdabot> package pointedlist
17:14:54 <deech> lispy: http://www.phy.duke.edu/~rgb/Philosophy/axioms/axioms/node18.html "The null set is a member of all sets".
17:14:56 <Nereid> class Pointed a where point :: a
17:15:02 <Nereid> deech: that's wrong
17:15:06 <EvanR7> the empty set is a subset of every set
17:15:10 <Nereid> ^
17:15:14 <Nereid> but not member
17:15:20 <EvanR7> the empty set is also a value of type Set a for all a
17:15:38 <Nereid> EvanR7: what is Set a, and what does it have to do with anything?
17:15:49 <EvanR7> Data.Set
17:16:06 <Nereid> deech: don't learn mathematics from a philosopher
17:16:08 <deech> Nereid: Yes, sorry I mixed up the the two. I'm not a mathematician. Is the empty set then something like bottom?
17:16:21 <Nereid> no
17:16:25 <Nereid> the empty set is a *set*
17:16:27 <Nereid> bottom is a *value*
17:16:43 <FireFly> Also note the distinction between subset-of and element-of
17:16:48 <deech> Nereid: Oh, ok.
17:16:53 <EvanR7> the empty set is also a value in haskell
17:17:00 <Nereid> EvanR7: no, there are no sets in haskell
17:17:11 <Nereid> stop being confusing
17:17:13 <EvanR7> >_>
17:17:26 <EvanR7> Data.Set is an implementation of a set
17:17:34 <mauke> EvanR7: no, it's not
17:17:36 <Nereid> not really
17:17:48 <startling> EvanR7: even if it were, does it matter?
17:18:02 <startling> EvanR7: clearly they're talking about sets as types
17:18:03 <dibblego> @check let extend = init . tails in quickCheck $ \x -> all (not . null) (extend x)
17:18:05 <lambdabot>   Not in scope: `myquickcheck'Not in scope: `quickCheck'
17:18:22 <dibblego> @check \x -> let extend = init . tails in all (not . null) (extend x)
17:18:22 <Nereid> caaaaaaaaale!
17:18:24 <lambdabot>   Not in scope: `myquickcheck'
17:18:28 <dibblego> boo
17:18:40 <deech> Given my limited understand of bottom the properties of empty sets http://en.wikipedia.org/wiki/Empty_set#Properties look a lot like bottom.
17:18:53 <Nereid> deech: no
17:19:01 <EvanR7> i figured deech is talking about haskell since hes talking about bottom
17:19:02 <Nereid> they are completely different kinds of things
17:19:15 <deech> EvanR7: Yes.
17:19:16 <EvanR7> but more people in here seem to be ignoring that so, theyre right
17:19:19 <Nereid> deech: between set theory and haskell, we have the analogues:
17:19:21 <Nereid> sets <-> types
17:19:26 <Nereid> elements of sets <-> values
17:19:30 <startling> deech, the empty set is not *in* every set
17:19:42 <startling> deech: the empty set is a *subset* of every set
17:19:48 <lispy> Well hang on. What if we have a type for Sets
17:19:50 <Nereid> deech: the empty set and bottom are at different levels in this hierarchy. it makes no sense to compare them.
17:19:55 <Nereid> lispy: let's not
17:19:58 <startling> lispy: shhh
17:20:03 <lispy> Now, the null set is a value in that type
17:20:09 <Nereid> no shut up
17:20:13 <EvanR7> ...
17:20:13 <Nereid> stop confusing him.
17:20:24 <EvanR7> thats what i was saying lispy
17:20:31 <startling> lispy: they type-level null set is not, though
17:20:37 <deech> startling: Oh, I don't think I understood the distinction between *in* and *subset*.
17:20:52 <Nereid> deech: X is a subset of Y if the *members* of X are members of Y.
17:20:58 <astertronistic> 4 is in {1, 2, 3, 4}
17:21:02 <Nereid> X is in Y (is a member of Y) if, well, it's a member of Y.
17:21:07 <astertronistic> {3, 4} is a subset of {1, 2, 3, 4}
17:21:07 <startling> deech: {1, 2, 3} <- 1 is *in* this set, {1} is a subset of this set
17:21:14 <uniquenick> is "IO (IOUArray (Int, Int) Int)" a reasonable/sane type signature for a matrix of ints?
17:21:15 <charliesome> hi all, is it possible to have ghc compile and run a haskell program without forking?
17:21:17 <Nereid> {1} is not a member of {1,2,3}
17:21:20 <startling> lispy: not in haskell, anyway
17:21:45 <Nereid> charliesome: "without forking"?
17:21:48 <deech> Nereid: Oh, so that's like saying the list [1] is not in the list [1,2,3]
17:21:51 <Nereid> yes
17:21:53 <startling> deech: exactly
17:22:05 <deech> Gottit!
17:22:06 <lispy> startling: type systems specifically try to avoid a set of all sets. So, yeah what you say makes sense for Haskell.
17:22:24 <charliesome> Nereid: it should do it all in the same process
17:22:27 <Nereid> uniquenick: get rid of the IO on the outside
17:22:36 <Nereid> charliesome: is "runghc" not sufficient for you?
17:22:43 <charliesome> Nereid: runghc is a bash script and forks
17:22:55 <deech> Nereid, startling, lispy: Thanks!
17:22:59 <lispy> startling: do you know russell's paradox or girard's version? (the latter being easier to encode in type theory)
17:23:19 <startling> lispy: yeah. my point is that the empty type is not the empty set in haskell
17:23:36 <Nereid> charliesome: runghc is definitely a binary here
17:23:39 <startling> *empty set value
17:23:56 <Nereid> deech: if anything, the empty set corresponds to the Void type in haskell.
17:24:08 <startling> it's "data Void"
17:24:09 <Nereid> (they are both initial objects in the corresponding categories)
17:24:18 <charliesome> Nereid: it's a bash script on 7.4.2 - are you on a later version?
17:25:14 <Nereid> charliesome: ok, what I have is a bash script that does nothing but sets some environment variables and execs a binary
17:25:19 <Nereid> charliesome: 7.6.1
17:25:35 <deech> Nereid, startling : Awesome. Things are a little clearer. Clearly I need to read up on types more.
17:25:43 <Nereid> charliesome: oh and on windows, there is no notion of bash scripts, and runghc is a binary by itself.
17:26:03 <startling> runghc is a shell script here
17:26:09 <Nereid> startling: what's in it?
17:26:36 <Nereid> in any case, exec is not fork
17:26:52 * hackagebot Agda 2.3.2 - A dependently typed functional programming language and proof assistant  http://hackage.haskell.org/package/Agda-2.3.2 (AndreasAbel)
17:26:57 <startling> Nereid: https://gist.github.com/f562979664976ed079d6
17:27:06 <Nereid> yes, same thing here.
17:27:28 <startling> yeah.
17:27:55 <Nereid> it does nothing more than execs whatever binary it refers to.
17:28:40 <Nereid> and /usr/lib64/ghc-7.6.1/runghc is some ELF binary.
17:28:48 <Nereid> which does some thing.
17:28:59 <charliesome> ah so it looks like running the shell script under my sandbox doesn't work, but running runghc from the lib dir does work
17:29:39 <Nereid> and it does fork.
17:30:21 <Nereid> so next time, just say directly what you're trying to do :v
17:30:33 <charliesome> if it forks, it must fork before it opens the source file
17:31:00 <charliesome> basically i have this sandbox that waits for the program to open the source file and then locks down
17:31:49 <Nereid> well maybe with the shell script, you accidentally had it only wait for it to open the runghc binary
17:32:03 <Nereid> I dunno.
17:48:27 <startling> say I have a Reader that gets a list of lazy bytestrings. By the end of the execution of the monad, I'll be using a lot of memory, right?
17:48:48 <startling> er, *end of the exection of the Reader
17:49:21 <monochrom> depends
17:49:45 <startling> on how much of the list is forced by the individual actions?
18:00:07 <Drakeson> Is there an easy way in GHCi to find a common typeclass of two objects (or all of such)?
18:03:11 <dibblego> :info
18:03:31 <bxx> how can I create a list where every other int is doubled?  [1,2,4,8,16 ...]
18:04:04 <mauke> > iterate (* 2) 1
18:04:06 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:04:06 <Nereid> > iterate (2*) 1
18:04:08 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
18:04:17 <Nereid> I'm too slow.
18:04:20 <bxx> thanks
18:04:42 <bxx> nice function
18:05:16 <mauke> :t scanl
18:05:18 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
18:06:36 <edwardk> :t iwhere
18:06:38 <lambdabot> (Applicative f, TraversableWithIndex i t, Indexed i k) => (i -> Bool) -> k (a -> f a) (t a -> f (t a))
18:06:55 <edwardk> > iwhere even *~ 2 $ [1,2,3,4]
18:06:57 <lambdabot>   [2,2,6,4]
18:07:01 <edwardk> =)
18:07:24 <edwardk> oh thats literally what he asked for, but not the example he gave
18:09:08 <applicative> iwhere even  acts on the even indices
18:09:09 <applicative> ?
18:09:23 * applicative looks it up
18:11:02 <applicative> > over (iwhere (>0)) Prelude.reverse $ ["He","was","stressed","o_O"]
18:11:04 <lambdabot>   ["He","saw","desserts","O_o"]
18:13:32 <nand`> > words "He was stressed o_O" % iwhere (>0) %~ reverse
18:13:33 <lambdabot>   ["He","saw","desserts","O_o"]
18:16:13 <applicative> >  words "He was stressed o_O" % (iwhere (>0) %~ reverse)  %  unwords
18:16:15 <lambdabot>   "He saw desserts O_o"
18:16:53 * hackagebot buildbox 2.1.2.3 - Rehackable components for writing buildbots and test harnesses.  http://hackage.haskell.org/package/buildbox-2.1.2.3 (BenLippmeier)
18:16:54 <applicative> >  words "He was stressed o_O" % iwhere (>0) %~ reverse  %  unwords
18:16:55 <nand`> aren't those parens unnecessary
18:16:55 <lambdabot>   "He saw desserts O_o"
18:16:59 <applicative> yeah
18:17:08 <Hermit> :t (%~)
18:17:10 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
18:17:17 <nand`> :t byWords
18:17:18 <lambdabot> Not in scope: `byWords'
18:17:22 <nand`> aw, we don't have it yet
18:17:37 <Hermit> :t (iwhere)
18:17:38 <lambdabot> (Applicative f, TraversableWithIndex i t, Indexed i k) => (i -> Bool) -> k (a -> f a) (t a -> f (t a))
18:17:46 <Hermit> ...
18:19:32 <applicative> the signature's is a little alarming of course
18:26:30 <nejucomo> What utility does Text provide which String does not?  (-and why doesn't the top-level Data.Text library documentation explain this?)
18:26:53 * hackagebot gloss-raster 1.7.7.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.7.1 (BenLippmeier)
18:27:21 <nejucomo> Is it only a performance/internal-representation difference, or do the types represent different semantic values?
18:29:16 <monochrom> I think it's just efficiency
18:31:53 * hackagebot gloss-examples 1.7.7.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.7.1 (BenLippmeier)
18:34:22 <nejucomo> monochrom: Ok, thanks.
18:36:59 <donri> nejucomo: text is usually faster and more memory efficient and is a distinct type (String is really a list, so sometimes requires hacks to write some instances like Show)
18:38:35 <applicative> nejucomo:  as far as the 'api' of Data.Text  goes, I  suppose it's trying as much as possible to make Text look like String
18:39:19 <applicative> but with the inevitable differences, like Text.map :: (Char -> Char) -> Text -> Text
18:40:16 <donri> on the other hand string is often easier to work with since it's just a list, and text internally uses a lot of unsafe stuff (but probably, hopefully used safely)
18:41:04 <donri> IIUC text is also easier to interface with FFI
18:41:38 <gertc> \
18:42:08 <donri> /
18:45:51 <hpaste> gertc pasted “Network.Wai.Application.Static” at http://hpaste.org/77590
18:46:26 <gertc> what did i do wrong again?
18:51:52 <gertc> o fuck no dont tell me i had the wrong version of documentation
19:01:32 <spherox> Can two records not have the same field name in haskell?
19:02:22 <nejucomo> spherox: The field names live in (aka pollute) the namespace the record type lives in.  You must prevent collisions with module namespace management.
19:02:46 <spherox> that's ugly x_X
19:03:19 <nejucomo> In one sense it's simple because there's already a way to manage module namespaces.
19:03:42 <spherox> ya, but if I want to have a getName "selector" on two types in the same module
19:03:46 <nejucomo> There's been plenty of contention around the issue and countless proposals to change this, and maybe libraries that help.
19:04:10 <frio> you could generify the getName into a class
19:04:11 <spherox> ya, I'll just design things differently I guess.
19:04:15 <startling> spherox, what kind of thing?
19:04:21 <nejucomo> import qualified Foo ; import qualified Bar; Foo.getField x ; Bar.getField y
19:04:23 <frio> and then make your two things instances of that class
19:04:38 <frio> typeclass, i should say
19:04:55 <shachaf> You can do what frio said.
19:04:57 <spherox> startling, what do you mean?
19:04:58 <shachaf> But you probably shouldn't.
19:05:14 <shachaf> Except in specific cases.
19:05:56 <startling> spherox, what do you want your record name to get out of your data structure?
19:06:06 <spherox> ya, I am not going to do that, the name collision is because it's a common name, not because they share behaviour
19:06:16 <frio> fair enough
19:06:26 <spherox> startling, I want to be able to access the name of the object without manual unpacking
19:07:20 <startling> spherox, hmm
19:07:24 <spherox> name being an attribute of the real-world object I'm modelling in haskell
19:07:51 <startling> yeah. maybe you could do data Named a = Named { name :: String, unName :: a } ?
19:08:37 <spherox> I was thinking, if I had a person and a car class, both with names
19:08:53 <shachaf> class /= typ
19:08:54 <shachaf> e
19:09:01 <spherox> I could do data Person = Person {personName :: String}, data Car = Car {carName :: String}
19:09:08 <hpaste> jojooo pasted “First fib attempt” at http://hpaste.org/77591
19:09:09 <spherox> doh, that's the OOP talking. I meant type
19:09:40 <shachaf> It might be that the answer to your question is "structure your code differently".
19:10:08 <geekosaur> there is http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#disambiguate-fields
19:10:40 <Ghoul> Do you think there will be a time in the future where GHC will be able to compile code which is on-par or faster than gcc in most scenerios
19:10:47 <geekosaur> note that fields need to have the same type regardless of this (a field selector is a function; this is where mosrt of the ambiguity comes from)
19:10:54 <startling> Ghoul: sure
19:11:07 <Ghoul> startling: How long, you reckon?
19:11:12 <Ghoul> 2020? Further?
19:11:21 <startling> well, do you mean now-gcc or then-gcc
19:11:30 <Ghoul> gcc won't move far.
19:11:37 <Ghoul> It's hit the limits of imperitive-ism.
19:11:40 <startling> it might.
19:12:05 <startling> anyway, I think probably ten years-ish, assuming people are still interested in and work on ghc
19:12:36 <geekosaur> gcc's hit some limits u the limit of imperativism isn't one of them.  as C compilers go it's one of the more crap ones
19:13:49 <spherox> geekosaur, what C compiler do you think is better?
19:13:52 <shachaf> They're going to be directly competing less and less.
19:14:32 <geekosaur> spherox, icc is one example.  there are still commercial compilers out there and they generally d a lot better optimization.  but gcc is "good enough" and free
19:14:57 <bxx> is there a way to access unexported functions in some module?
19:14:59 <spherox> geekosaur, well, ICC is also made by the chip mfg =P, they get a bit of an edge
19:15:23 <shachaf> bxx: No.
19:15:58 <geekosaur> unexported means unexported.  This isn't perl.
19:16:21 * applicative hadn't  known perl was so advanced
19:16:29 <geekosaur> (and heck, even perl can my() stuff to keep it from being inaccesible)
19:17:22 <geekosaur> (even if you have to localize subs with my $sub = sub { ... };)
19:17:32 <geekosaur> (this is not so much "advanced" as...)
19:17:56 <applicative> bxx, you can write to the library writer if its unreasonable, or just make your equivalent, of course.  Often the hiding has a structural purpose, e.g. to protect 'invariants'
19:18:00 <shachaf> But if you're evil and/or rwbarton, you can define an equivalent data type and unsafeCoerce it back and forth.
19:18:08 <shachaf> (But don't do that.)
19:18:21 <applicative> do it, bxx
19:18:45 <applicative> and take full advantage of GeneralizedNewtypeDeriving
19:20:18 * applicative supposes there must be some devil horned emoticon he could be  typing
19:20:19 <startling> bxx, you can copy-paste the source
19:20:37 <bxx> geekosaur I understand hiding internals makes sense. but I am not convinced making things completely inaccessible by the user is prefered. I'd be happy with additional syntax to access unexported stuff
19:21:03 <startling> bxx: that's tricky. does it affect all the things that import it, too?
19:21:07 <shachaf> bxx: Some packages do that, some don't.
19:21:19 <startling> that would make ghc need to go back and re-load all those with the new definitions
19:21:28 <shachaf> Haskell already has a mechanism for that -- just put the internal bits in a module called .Internal.
19:21:30 <shapr> Just got asked why this doesn't work: fib x = fib(x – 1) + fib(x - 2) Took me a bit to spot the Unicode Character 'EN DASH' (U+2013)
19:21:58 <startling> haha
19:22:01 <shachaf> Get a better font!
19:22:22 <shachaf> Anyway, yes, Haskell catches punctuation mistakes like that. It should be EM DASH (U+2014)
19:22:23 <geekosaur> ^
19:23:23 <monochrom> hehe
19:27:44 <arkantos> Hi guys, I'm doing some exercises to continue learning haskell,  I've tried the following expession on GHCi:  [if x `mod` 2 == 0 then x else 0 | x <- take 400 getShow] and its working perfectly but when I try to compile it from a .hs file the compiler throws this error: No instance for (Integral String)
19:27:44 <arkantos>       arising from a use of `mod'
19:27:44 <arkantos>     Possible fix: add an instance declaration for (Integral String), any suggestions would be greatly appreciated.
19:28:12 <shachaf> arkantos: You're probably not running the exact same code.
19:28:34 <monochrom> show actual file
19:28:34 <shachaf> I recommend figuring out the type of every subexpression there.
19:28:47 <arkantos> yes its the same since I've just copy-pasted from my console
19:28:50 <arkantos> ok
19:29:49 <startling> :t mod
19:29:51 <lambdabot> Integral a => a -> a -> a
19:29:54 <startling> what's the type of getShow?
19:30:09 <shachaf> I recommend following monochrom's advice.
19:30:13 <startling> that too
19:30:20 <arkantos> an integer list
19:30:49 <shachaf> I think that's not right. But I'll just wait for monochrom's advice to be followed.
19:30:51 <bxx> shachaf consider a situation where some useful function should be exported but it wasn't. as it stands, user of the library can't use that function without copy/pasting it
19:30:53 <hpaste> Arkantos pasted “Euler exc 2” at http://hpaste.org/77593
19:31:05 <shachaf> bxx: Well, it should've exported that function, shouldn't it?
19:31:21 <donri> edwardk: where did the type operator for simple lens go?
19:31:36 <geekosaur> that looks buggy
19:31:38 <monochrom> putStrLn (evens) ?!
19:32:04 <shachaf> Advice #1: Write a type signature for every top-level binding.
19:32:13 <arkantos> I barely know the language xD
19:32:29 <monochrom> find an IDE that tells you that putStrLn doesn't want a number parameter
19:32:29 <arkantos> shachaf, taking note...
19:32:35 <geekosaur> that's *why* you shuld write the type signatures
19:32:37 <bxx> shachaf yes. but knowing that the library writer made a mistake not exporting it doesn't help the user of the library much.
19:32:56 <startling> bxx, fork that library, pull request
19:32:59 <shachaf> Also, your code is full of other bugs.
19:33:07 <shachaf> "fork" :-(
19:33:07 <geekosaur> bxx, this does not mean the language should let you go behind the library writer's back arbitrarily
19:33:30 <shachaf> bxx: The interface that a library exports is stable.
19:33:44 <shachaf> The implementation details of the library -- such as what useful functions it defines -- are not.
19:33:45 <bxx> geekosaur an additional syntax (that warns you and the people reading your code that you may be doing something sketchy) that lets you go behind the library's writer's back would be useful
19:34:02 <monochrom> use a disassembler
19:34:15 <geekosaur> bxx, again I say this is not Perl.  Perl is all about that kind of thing
19:34:21 <arkantos> shachaf, thanks for your advices, I appreciate it, thank you all guys, you rock
19:42:42 <edwardk> donri: Control.Lens.Simple -- it was causing too many conflicts
19:42:50 <donri> aha thanks
19:42:52 <edwardk> donri: so its off to the side there, not exported by default
19:43:13 <edwardk> i kept it mostly because i didn't want to hear mgsloan complain ;)
19:59:27 <shachaf> Is there an evil Monoid instance on Hackage that gives you the actual structure that things got mappended in?
19:59:30 <shachaf> I.e. breaks all the monoid laws on purpose, gives you a binary tree.
20:06:36 <parcs`> what would mconcat do
20:06:51 <shachaf> Either the default definition or an N-ary node.
20:06:57 <shachaf> Depending on how honest you wanted to be.
20:09:34 <nejucomo> I wonder if I can have a context like: Testable (Foo, t) => t -> Test
20:09:42 * nejucomo tries.
20:39:24 <donri> edwardk: for some reason the overview image of lens never seem to cache properly so it always reloads, and slowly at that, causing the module list to jump out of sight just as you try to click some module. would be real nice if the image could be browser cache so as to instantly load on reload, or perhaps remove the image entirely from the cabal description (only keep it on wiki and in Control.Lens)
20:39:57 <donri> (i have this issue basically every time i view the lens hackage page, since the image was added.)
20:39:59 <shachaf> donri: On Hackage or on GitHub?
20:40:00 <edwardk> i'd rather not remove it from the cabal description. let me see how i linked it
20:40:42 <edwardk> i understand your issue, but the utility of that diagram i think is a big deal
20:40:58 <edwardk> i'm open to making it load faster though ;)
20:40:58 <donri> oh sure, it's a nice image
20:41:07 <shachaf> GitHub sends pictures from the wiki with cache-control: no-cache.
20:41:13 <donri> although it might be sufficient to keep it in Control.Lens IMHO
20:41:26 <shachaf> So either find another place to host it or fix GitHub.
20:41:33 <donri> shachaf: ah. i'm having this on hackage, but the image is loaded from github wiki so yea.
20:41:55 <edwardk> i wonder if its in the main github repo if it gets cache-control: no-cached
20:42:09 <shachaf> donri: No, the image on github.com/ekmett/lens links to a diagram hosted off-github.
20:42:20 <donri> aha
20:42:54 <edwardk> the one in the hackage page gets linked to a specific version image in the wiki that way if i update the creately doc it doesn't change all past versions to start lying ;)
20:44:01 <shachaf> edwardk: Does this four-parameter "more than a category" thing come up anywhere other than lens?
20:44:23 <edwardk> well the four parameter version is just a 2 parameter version with a product kind
20:44:36 <edwardk> there are plenty of those in other places
20:44:49 <edwardk> but product kinds in ghc are pretty borked right now until we get rid of Any
20:45:08 <gertc> aleloia i got the Network.Wai working
20:45:14 <edwardk> because right now (*,*) is inhabited by '(Type,Type)     AND Any
20:45:24 <edwardk> so its x*x+1, not x*x
20:45:51 <edwardk> it wouldnt be so bad if Any wasn't distinguishable, making any eta-expansion unsound
20:46:02 <typoclass> edwardk: stuff from imgur.com seems to allow caching for 30 years or so, and you don't need an account to upload
20:46:32 <edwardk> if shachaf wants to upload it to imgur and toss a patch up. i won't stop him ;)
20:46:40 <edwardk> i worry about them lowering resolution
20:46:54 <Ralith> they tend to recompress overlarge images as low quality jpeg
20:47:02 <edwardk> yeah that would kinda suck for this
20:47:06 <typoclass> edwardk: hm yeah, not sure about it
20:47:32 <edwardk> i can upload it to comonad.com, or add it to gh-pages for the main repo, etc. there are plenty of options
20:47:52 <edwardk> the main thing i liked about the current arrangement was other people could do it
20:48:28 <shachaf> The clock is ticking on edwardk getting bored with lenses.
20:48:56 <edwardk> ?
20:48:57 <typoclass> http://i.imgur.com/keOs9.png <- doesn't seem to recompress as jpeg
20:49:18 <donri> yea a diagram like that should compress well with png anyway
20:49:25 <edwardk> fair nuff
20:49:38 <edwardk> i'm okay with relinking the main doc links to that for now
20:49:45 <donri> great!
20:50:02 <shachaf> You could host it on comonad.com
20:50:09 <typoclass> donri: "Expires: Thu, 31 Dec 2037" enough caching? :-)
20:50:16 <edwardk> i could but thats harder for you to update
20:50:20 <donri> :)
20:50:22 <edwardk> and i like outsourcing ;)
20:51:26 <hpaste> someone pasted “composing "old" lenses with (.)” at http://hpaste.org/77594
20:52:14 <edwardk> =P
20:52:29 <edwardk> the problem with the difference lenses is they are too big i think
20:52:47 <shachaf> The type is too big?
20:52:51 <edwardk> like with difference lists
20:52:54 <edwardk> they are bigger than lists
20:52:55 <shachaf> Same as difference lists, yes.
20:53:02 <edwardk> but only by convention are the same size
20:53:03 <shachaf> (And Codensity, I think.)
20:53:14 <edwardk> yes, codensity is also bigger, typically
20:53:32 <edwardk> this was the topic dolio blogged about on comonad recently
20:53:35 <shachaf> Is there a nice way to enforce difference lists in the type system?
20:53:50 <donri> makeIso with a newtype: makeLensesWith: A single-constructor single-argument data type is required
20:54:00 <edwardk> donri: yeah i'm not sure what started that
20:54:12 <donri> am i meant to use something other than makeIso for newtypes?
20:54:15 <edwardk> i'll add an issue and remember to fix it
20:54:21 <edwardk> no, it should be makeIso
20:54:23 <edwardk> something borked it
20:55:01 <edwardk> https://github.com/ekmett/lens/issues/89
20:55:22 <edwardk> i'll post to that when i get a chance to look, unless shachaf wants to bite it off
20:55:27 <donri> it works with singletonRequired False
20:55:34 <edwardk> donri: interesting
20:55:46 <donri> although not sure if that breaks it for data-types
20:57:19 <edwardk> the code in makeLensesWith looks right. not sure what broke
20:57:20 <donri> uh by works i meant compiled. doesn't seem to have generated anything.
20:57:38 <donri> oh because i have a module exports list of course
20:57:42 <donri> ignore me :D
20:57:51 <edwardk> hah
20:58:13 <edwardk> with singletonRequired .~ False thats going to fall back on a normal set of field lenses
20:59:16 <edwardk> donri: can you try it with handleSingletons .~ True ?
20:59:23 <edwardk> i think its just missing from the makeIso rules
20:59:53 <donri> same error
21:00:17 <donri> and yea singletonRequired False did stop it from generating the iso, wasn't just my exports
21:01:15 <edwardk> did you use makeLensesWith $ isoRules % handleSingletons .~ True  ?
21:01:20 <edwardk> or did you use lensRules?
21:01:26 <donri> isoRules
21:01:29 <shachaf> Seems to work fine with handleSingletons .~ True
21:01:37 <edwardk> yeah i just patched it locally and it worked here
21:01:39 <edwardk> going to push
21:01:40 <shachaf> newtype Foo = Foo { _foo :: Int }; makeLensesWith (isoRules % handleSingletons .~ True) ''Foo -- looks like it works.
21:02:16 <donri> oh wait i set it to False
21:02:18 <donri> stupid
21:02:31 <edwardk> its in HEAD
21:02:48 <edwardk> that means i'll need to push 3.3 soon.
21:03:00 <donri> cool
21:03:01 <edwardk> since thats an actual bug not an enhancement
21:03:16 <donri> i'm already using makeLensesWith so setting it myself isn't harder
21:05:15 <donri> new problem! duno if bug:  Ambiguous type variable `k0' in the constraint: ...
21:05:19 <donri> using generateSignatures False
21:05:28 <donri> and then using the type op for Simple Lens
21:05:31 <donri> uh Simple Iso
21:06:24 <edwardk> what is the type you gave?
21:06:57 <donri> with generated signatures: affix :: Iso Text Text Affix Affix
21:07:05 <donri> my signature: affix :: Text :<-> Affix
21:07:20 <Ghoul> How's GHC's branch prediction respect?
21:07:23 <edwardk> the code doesn't look at that signature. so i would hazard you have an ambiguous type variable some how =)
21:07:41 <edwardk> Ghoul: you mean in the resulting code?
21:07:45 <Ghoul> Does it take processor-level branch prediction into consideration?
21:07:50 <Ghoul> edwardk: ie: http://privatepaste.com/92bdf0133e
21:08:05 <donri> i don't follow. the type error happens if i disable generateSignatures. aren't those two signatures identical?
21:08:08 <edwardk> Ghoul: ghc is pretty crapy at branch prediction because o the spineless tagless g-machine jumping indirectly all over
21:08:26 <Ghoul> hmm
21:08:30 <shachaf> privatepaste.com should redirect you to publicpaste.com when more than a few IP addresses have accessed the same URL.
21:08:57 <Ghoul> lol
21:08:59 <edwardk> they should be. maybe the phase separation causes something weird down in the bowels of ghc.
21:09:42 <donri> edwardk: also the error is in the generated code, not anything i wrote (you can tell from the TH generated variable names)
21:10:03 <edwardk> donri: can you paste the list of edits you made to the rules?
21:10:12 <minsa> vlc is tied to libfglrx ?
21:10:42 <edwardk> i worry that the rule set you built is trying to generate something with a prepended lens like makeClassy or some such
21:10:55 <edwardk> but that doesn't make sense with makeIso
21:11:02 <edwardk> hrmm
21:11:16 <edwardk> not sure if makeIso properly respects generateSignatures. i don't remember testing it ;)
21:11:21 <edwardk> checking
21:11:23 <hpaste> donri pasted “makeIso” at http://hpaste.org/77595
21:11:56 <edwardk> it looks like it should, hrmm
21:13:18 <edwardk> donri: interesting. there shouldn't be any type variables in that code
21:14:00 <donri> alright it compiles fine if I write the same signature as the generated one
21:14:09 <edwardk> interesting
21:14:10 <applicative> I think asStream :: Vector v a => Simple Iso (v a) (Stream a) and the like are going to break with the next `vector`
21:14:11 <donri> so would seem generateSignatures is fine
21:14:12 <minsa> all the videos are tied to libfglrx.
21:14:21 <edwardk> applicative:
21:14:29 <edwardk> ?
21:14:48 <applicative> he has some new concept
21:14:49 <edwardk> donri: odd that :<-> is borked.
21:14:53 <edwardk> ah
21:14:58 <edwardk> when it ships we break ;)
21:15:03 <donri> edwardk: don't you need to forall k f. in the type op
21:15:23 <edwardk> type s :<-> a = Iso s s a a
21:15:35 <edwardk> is what i have now
21:15:37 <edwardk> no forall.
21:15:44 <edwardk> the Iso expands to that
21:15:46 <donri> yea, but: type :-> s a = forall f. Functor f => (a -> f a) -> s -> f s
21:15:59 <donri> why isn't that one just = SimpleLens s a
21:16:00 <edwardk> tats because i didn't import Control.Lens.Type then
21:16:31 <edwardk> as a rule if the expansion of something is short i tend to inline it. it makes someone spend less time diving through modules looking for other made up one-off abstractions
21:16:57 <minsa> sorry.. wrong channel.
21:17:11 <shachaf> Did you just post your "wrong channel" message to the wrong channel?
21:17:27 <shachaf> (Ah, no, there was something above.)
21:17:51 <applicative> edwardk:   yes, it wont  be much, but the  new equivalent of Stream you are using is called Bundle
21:18:18 <edwardk> donri: feel free to make an issue on there with a minimalish example and i'll be happy to take a longer look
21:18:30 <edwardk> applicative: fair nuff, any eta on release?
21:18:51 <applicative> no, I don't know.
21:19:14 <shachaf> edwardk: The thing about release etas is that they tend to be expanded.
21:19:16 <edwardk> if he starts randomly alpha renaming crap like that i'll probably have to drop the associated functionality. i try to ensure i support the last 2 platforms, that would break my api across that boundary
21:19:52 <edwardk> shachaf: -fno-eta-expand-releases
21:20:38 <edwardk> donri: but i agree what you wrote _should_ work
21:20:41 <carter> Ghoul's remark does raise an interesting question: if GHC hypothetically was better about hinting branch prediction, what perf difference would realistically be seen?
21:20:54 <carter> afaik, the order of the cases of a data type help with that sort of
21:21:00 <shachaf> carter: Did you see edwardk's JIT thing?
21:21:09 <carter> what jit thing?
21:21:10 <edwardk> carter: it makes a pretty big difference in my tests
21:21:18 <edwardk> github.com/ekmett/jitplusplus
21:21:47 <shachaf> Well, nominolo is working on a Haskell-specific tracing JIT these days, too.
21:21:54 <carter> what just jitplusplus do?
21:22:01 <carter> (hows it relate)
21:22:03 <edwardk> and i was working on one when matt morrow left the haskell community
21:22:19 <edwardk> when my oracle for ghc internals retired i lost interest
21:22:20 <carter> are there links to the nominolo work?
21:22:34 <shachaf> The idea is that you can figure out a lot more about which branches will be taken at runtime than at compiletime, so you can rewrite the code to be more predictable.
21:22:40 <carter> k
21:22:42 <shachaf> Hmm, there were some slides somewhere.
21:22:54 <carter> implementor workhsop slides?
21:23:00 <carter> edwardk: what sort of perf difference?
21:23:07 <shachaf> carter: http://www.haskell.org/haskellwiki/HaskellImplementorsWorkshop/2012
21:23:09 <shachaf> Yes, that.
21:23:10 <luite> he's the one compiling to luajit bytecode, right?
21:23:15 <edwardk> the jit++ stuff lets me turn indirect jumps into direct jumps in general, this happens to also cover the resulting ghc-style jumps from the spineless tagless g-machine, but you can do so of course more directly with a MUCH simpler jit
21:23:55 <donri> and of course i can't reproduce it in a small example
21:24:01 <carter> ok
21:24:02 <edwardk> well, the difference is very program specific, but its the kind of difference you get out of tracemonkey compared to raw spidermonkey
21:24:20 <carter> refresh my memory on what the difference can be
21:24:45 <luite> of course tracemonkey has now been replaced by a more traditional method jit :p
21:25:03 <edwardk> see 'assorted benchmarks' http://brendaneich.com/tag/tracemonkey/
21:25:08 <shachaf> edwardk: The kind of difference where it's theoretically better, but in practice it's too hard to get right so you abandon it? :-)
21:25:23 <edwardk> shachaf: yep
21:25:30 <Ghoul> Hmm, anyone know if ghc takes it into consideration?
21:25:35 <Ghoul> Woops, meant gcc. :)
21:25:47 <shachaf> Did jit++ cover things other than indirect jumps?
21:25:51 <edwardk> Ghoul: gcc has all sorts of stuff for branch prediction support
21:25:59 <Ghoul> i have no idea of the internals of ghc, so I dont actually know if ghc uses gcc or whatever order it all might fall.
21:26:19 <edwardk> shachaf: runtime constant folding, vtable dereferencing, lots of flag optimization, etc.
21:26:20 <carter> Ghoul: GHC uses LLVM as its main backend now
21:26:32 <edwardk> moving more code off the mainline into side-branches
21:26:54 <carter> edwardk: also seeming a jit model lets you have more dynamical metaprogramming being allowed, right?
21:27:39 <carter> hrm, so basically for bit twiddlery, the difference is EPIC, for numericalish code its still pretty snazzy at ~ 3x
21:28:05 <carter> and for fancy stuff with less locality, more like ~ 2x at best
21:28:16 <edwardk> carter: well, with the jitpp model i was able to do things like take code that called out into third party libraries like glibc to something like printf with a known pattern string, figure out the arguments that were going out and how they were decoded, and turn it into a routine that grabbed the spinlock on the file handle, shoved the data in decoded, without ever looking at the format string, and spun the lock back up
21:28:17 <carter> ok cool
21:28:45 <edwardk> so it basically let it optimize through third party libraries pretty well
21:28:46 <edwardk> =)
21:28:51 <carter> WAT
21:28:51 <carter> ok
21:28:53 <carter> thats snazzy
21:29:11 <carter> insanely hard to do correctly too i imagine
21:29:30 <edwardk> yeah that and the general lack of time to work on it are why it has languished for 4 years
21:29:49 <carter> so you were able to specialize constant format string / associated code path?
21:29:57 <edwardk> there were also issues with how to deal gracefully with multithreaded trace access and update when you can't afford to even rendezvous on trace entry/exit
21:30:01 <carter> what spinlock on a file?
21:30:14 <carter> eh?
21:30:15 <edwardk> way down in glibc there is a spinlock on stdout ;)
21:30:29 <carter> eeesh
21:30:39 <carter> to ensure not TOOO much interleaving
21:30:40 <carter> ?
21:30:43 <edwardk> that lock, the one you don't even know is there =)
21:30:55 <carter> https://github.com/nominolo/lambdachine being the jit in question?
21:31:05 <edwardk> thats probably his
21:31:15 <carter> cool
21:31:36 <carter> so basically the jitpp had some problems when it wasn't running singlethreaded code?
21:31:43 <carter> let alone multicore?
21:32:13 <edwardk> well, yes and no. i already worked out how to fix it with the help of some gcc guys, but it was scary =)
21:32:26 <johnw> edwardk: when you defined natural transformations as: type Nat f g = forall x. f x -> g x, why would you need "forall x" there?
21:32:37 <edwardk> basically i came up with the scariest 'eventually correct' trace collection scheme ever
21:32:39 <shachaf> johnw: Where else would the x come from? :-)
21:32:53 <johnw> *face palm*
21:33:03 <edwardk> johnw: because it needs to be something like [a] -> Maybe a   to work for any choice of a.
21:33:23 <edwardk> so the forall gives you a place to say that the caller gets to choose what 'a' (or 'x') they use
21:33:43 <edwardk> Nat [] Maybe = forall x. [x] -> Maybe x
21:33:44 <carter> scary in terms of ...... many many many low level deets intersecting?
21:33:47 <johnw> if [] is a functor a -> [a], does Haskell allow me to write a functor [a] -> a?  that would need type-level pattern matching, yes?
21:34:09 <shachaf> johnw: [] is a functor : * -> *
21:34:16 <edwardk> scary in that i never pay for a memory barrier but wait for the natural thread quantum to elapse twice and the fact that there is a memory fence down in the bowels of the thread scheduling code in the OS
21:34:29 <edwardk> and have very slow communication paths that rendezvous over that
21:34:41 <johnw> shachaf: but [] only maps types to list types
21:35:14 <copumpkin> I don't think you could write the reverse functor, even if we could write funky type fucntions
21:35:16 <edwardk> [] :: * -> *         Maybe :: * -> *          Either :: * -> * -> *      Either Int :: * -> *
21:35:26 <shachaf> johnw: Right, but the domain and codomain of [] are both *
21:35:35 <copumpkin> johnw: think of what the fmap of that functor would be
21:35:49 <carter> edwardk: that sounds like a chthulian chant in that sentence
21:35:49 <shachaf> It happens to be injective, but that doesn't change anything. :-)
21:36:18 <shachaf> (It's not surjective, which is why the thing copumpkin said works. Unless I'm mixing my terms up.)
21:36:18 <carter> so there were invariants needed that you couldn't force to be so, so you'd have to do very exotic timing?
21:36:34 <johnw> shachaf: oh, right, it's fmap that deals in terms like "a", not the type constructor
21:36:46 <shachaf> Yep.
21:37:22 <edwardk> johnw: Functors in haskell are a very limited class of endofunctors on the category of haskell types. in particular they are required to all be marked by a newtype or data type in the target, so they all map to a proper subcategory of Hask.
21:38:33 <edwardk> but the fact that they map all of hask to that requires you to take (a -> b) -> …    the fact that they all inject is a consequence of how we do the typeclass machinery, yielding you the f a -> f b shape that the image of the functor has to have
21:38:48 <copumpkin> you'd need your "fmap" to be ([a] -> [b]) -> (a -> b)
21:38:56 <copumpkin> which isn't possible to write soundly
21:39:26 <copumpkin> even ignoring the inadequacy of the haskell type system to write that instance
21:40:49 <donri> this is reaaaally odd and headache-inducing. it consistently fails to build in my cabal project, but i can't reproduce it with ghc and a simple test file.
21:41:25 <hpaste> johnw pasted “HeadOf.hs” at http://hpaste.org/77596
21:41:33 <johnw> copumpkin: that's how I would write it
21:41:48 <typoclass> donri: what switches does cabal pass to ghc in your case?
21:41:49 <copumpkin> sure, but head is a lie
21:42:08 <shachaf> Even if you had nonempty lists it would probably wind up being a lie.
21:42:10 <copumpkin> head can't be written in a total language
21:42:21 <shachaf> You can do (Writer w a -> Writer w b) -> a -> b, though!
21:42:34 <edwardk> well the problem with fmap :: ([a] -> [b]) -> … is it isn't a functor from all of Hask
21:42:49 <johnw> I would imagine HeadOf would be possible when the List type can be a Comonad
21:42:59 <johnw> edwardk: ahh
21:43:04 <johnw> edwardk: that's a very good point
21:43:22 * shachaf doesn't know what is being discussed in the first place.
21:43:24 <johnw> it's a functor from Hask/[], right?
21:43:39 <donri> edwardk: ok so it fails with SimpleIso as well!
21:44:05 <shachaf> johnw: If it's a functor at all. :-)
21:44:09 <johnw> shachaf: i want to find a case in Hask where [] was a left adjoint
21:44:12 <edwardk> not really. its still busted. because what happens when i take the [a] feed it to your function and you give me [] back? how do i get my b?
21:44:18 <johnw> (or prove that it's not possible)
21:44:43 <johnw> edwardk: how can I turn [a] into []?  that wouldn't be homomorphic
21:44:50 * shachaf should probably find out what adjunctions are.
21:44:59 <copumpkin> stupid syntax means that [a] and [] are ambiguous
21:45:08 <copumpkin> let's say List a is the type
21:45:12 <edwardk> johnw ::  ([a] -> [b]) -> a -> b ; johnw f a = head $ f [a]
21:45:13 <copumpkin> [a] and [] are values
21:45:22 <edwardk> that head is partial
21:45:38 <johnw> oh, I see now
21:45:45 <johnw> well, from my example, the fmap is:
21:45:55 <johnw> (NonEmpty a -> NonEmpty b) -> a -> b
21:45:58 <johnw> not [a] -> [b]
21:46:29 <johnw> i realize how futile this is for []
21:46:58 <edwardk> anyways that may well be a functor from Hask/NonEmpty to Hask., but thats not a 'Functor' with a capital f. ;)
21:47:28 <edwardk> in practice you'd be better off building Nat NonEmpty Identity or something which took the head
21:47:47 <shachaf> It doesn't pass the Functor tests, so it's more of a Flunctor.
21:47:56 <edwardk> or Nat [] Maybe which safely took the head or returned Nothing
21:47:57 <edwardk> hah
21:47:59 <johnw> shachaf: when for any two functors F : C <- D and G : C -> D there exists a natural isomorphism such that GF = 1_C and FG = 1_D
21:49:17 <johnw> ok, but it IS a valid functor from Hask/NonEmpty; is it then right adjoint to NonEmpty in Hask?
21:49:34 <copumpkin> shachaf: "mappy" adjunctions often end up giving you a "canonicalize" operation
21:49:35 <johnw> i'm not sure if the naturality condition holds
21:50:27 <edwardk> johnw: no idea. work through it ;)
21:50:28 <johnw> ack, GF = 1_D and FG = !_C
21:50:38 <johnw> edwardk: good answer :)
21:51:04 <copumpkin> naturality should always hold in haskell unless you do weird stuf
21:51:56 <donri> edwardk: ok i found the problem. i was calling makeIso, then makeLenses, then the type signatures. you have to give the Iso signature right after makeIso.
21:51:56 <edwardk> as long as the naturality you want is the one implied by parametricity
21:52:19 <edwardk> donri: ah, messy
21:52:27 <donri> so confusing :)
21:52:52 <edwardk> i'd expect the signature would have to come _before_ the call to makeIso
21:53:00 <edwardk> er have expected
21:54:19 <donri> yea, me too. used to think you couldn't give signatures at all for TH generated code
21:55:48 <johnw> edwardk: have you read this: http://www.andres-loeh.de/LambdaPi/LambdaPi.pdf
21:55:58 <edwardk> yes
21:56:18 <johnw> it made wonder again why we aren't heading toward fully dependent types in Haskell; you gave me a good one-liner for it in Boston...
21:56:47 <edwardk> i choose not to give up great inference for types that are 10x larger ;)
21:57:33 <johnw> would it have to be everywhere, making all existing libraries incompitable?
21:58:11 <edwardk> well, we're slowly picking up new features inspired by the dependent typed stuff, but a whole-hog adoption of their ideas is probably not a good idea.
21:59:08 <edwardk> haskell sits at a very sweet spot in terms of the cost/benefit ratio of its strong types. We slowly find ways to expand the benefits for little cost or in ways where you only pay the extra costs when you use the new features.
22:00:07 <edwardk> You can't just bolt on agda as one of those extensions, though. adam chlipala had a type system for a while that almost met that goal, in Ur, but he later ripped all the dependent types out.
22:01:03 <edwardk> the goal he had was that users would write libraries with dependent types, that could do things like give strong types to sql, xml bindings, etc.    and then the users would write little web pages with inference that used those libraries
22:01:21 <edwardk> he ultimately went with a different design though, where the front end and library languages are now the same
22:08:42 <johnw> interesting
22:09:01 <shachaf> Why is hscolour GPL?
22:09:03 <johnw> yes, bifurcated languages (like in C++) end up being complex for a few reasons
22:10:11 <startling> bifurcated?
22:10:18 <johnw> "forked into two"
22:10:36 <startling> yeah, but how do you mean?
22:10:37 <johnw> in C++, between the "regular" language and the template metaprogramming language
22:10:43 <startling> oh, I see.
22:11:00 <johnw> often only libraries developers know anything about the latter, and only they can read it, debug it, or understand its error messages
22:11:33 <johnw> as well as I know C++, there is code in Boost that just boggles my mind -- and I've heard the same said by other Boost library authors!
22:12:14 <johnw> what I like about Haskell is that when it boggles my mind, it's because I don't understand the abstraction; not because the syntax makes the abstraction impossible to follow
22:12:37 <startling> johnw, I saw a CPP foldr in Boost once.
22:13:07 <startling> I think that's when I decided I didn't like C or C+=
22:13:11 <startling> s/=/+
22:14:16 <aleator> Anyone want to criticise my pre-version of half baked teaching materials? http://functional-programming.it.jyu.fi/static/Chapters/01810_The_Free_Monad.html
22:15:10 <Heffalump> edwardk: so Ur isn't dependently typed any more?
22:15:34 <edwardk> afaik. it just has a really nice kind system, etc.
22:16:03 <startling> is Ur any good?
22:16:55 <copumpkin> I should email adam to tell him it's spelled "your"
22:16:59 <edwardk> it is pretty interesting
22:17:04 <edwardk> copumpkin: =)
22:17:12 <edwardk> tell him next time he shows up to boston haskell
22:17:18 <edwardk> oh wait. you can't.
22:17:25 <edwardk> you'll be in CT =P
22:17:32 * copumpkin looks glum
22:17:37 <shachaf> :-(
22:17:41 <edwardk> down in blandville
22:17:44 <copumpkin> lol
22:17:47 <copumpkin> it's a cute town actually
22:17:50 <shachaf> copumpkin: Are you going to slowly disappear, like dons did when he went to SCB?
22:18:01 <edwardk> of course you'd say that now. you have to convince yourself
22:18:05 <copumpkin> lol
22:18:08 <copumpkin> shachaf: yep
22:18:13 <Ghoul> "startling> I think that's when I decided I didn't like C or C+="
22:18:17 <Ghoul> This one belongs in lambdabot
22:18:39 <edwardk> when copumpkin starts sending out tweets wistfully showing what is going on outside of his window, that is our sign to go in for the jailbreak.
22:18:42 <copumpkin> shachaf: oh wait, I'm supposed to deny it
22:18:50 <edwardk> erm, and not his usual kind of jailbreak either.
22:18:54 <copumpkin> :P
22:18:56 <Ghoul> It implies that C == C++, kind of. And hence, any movement forwards is actually moving nowhere
22:19:14 <edwardk> c does = c++
22:19:30 <copumpkin> the view out my window probably won't be worth posting compared to the dons ones
22:19:40 <shachaf> C is totally a superset of a subset of C++
22:19:41 <edwardk> it takes a whlle for that postincrement operator to go through ;)
22:20:04 <startling> Ghoul, I was hoping for a decent preprocessor
22:20:09 <shachaf> Is "c = c++" undefined behavior?
22:20:21 <Bigcheese> shachaf: yes!
22:20:23 <edwardk> shachaf: yes
22:20:27 <edwardk> ask johnw
22:20:28 <edwardk> =)
22:20:45 <shachaf> edwardk: I meant undefined behavior in C, not in C++. :-)
22:21:18 <shachaf> C++ has a much more complicated system than C for that sort of thing, if I remember correctly.
22:21:19 <edwardk> well c == c++ should be undefined, c = c++ might be okay from the happens before semantics on the right hand side vs the left
22:21:26 <johnw> shachaf: looking
22:21:40 <startling> why should c == c++ be undefined?
22:21:59 <Eduard_Munteanu> c == c++ actually seems reasonable
22:22:16 <startling> I'd assume c = c++ would be a no-op, but I could see how it could be tricky
22:22:19 <Ghoul> c == c++ would work
22:22:24 <Ghoul> c increases by 1
22:22:26 <edwardk> startling: c++ post increments. so if c = 3, it becomes equal to 4 afterwards, but the value that expression retuens is 3. now, if the 'c' was dereferenced first, that is also 3, so 3 == 3, passes
22:22:33 <Ghoul> but the carry flag would be zero
22:22:35 <Ghoul> wait,
22:22:36 <Ghoul> no
22:22:37 <Ghoul> HAHAHA
22:22:39 <edwardk> but if the 'c' is dereferenced after then its 4 == 3 which is false
22:22:50 <Ghoul> if (c == c++) passes true doesn't it?
22:23:02 <Ghoul> the one that would pass for 4==3 would be (c == ++c)
22:23:09 <startling> edwardk: oh, I see.
22:23:11 <shachaf> startling: c = c++, not c == c++
22:23:16 <edwardk> Ghoul: that is implementation specific. c doesn't specify that these evaluate from left to right or right to left
22:23:28 <startling> shachaf: I figured.
22:23:33 <startling> edwardk: yeah, that makes sense.
22:23:33 <Ghoul> Anyhow, it would probably look like if (c == c) c += 1;
22:24:06 <edwardk> Ghoul: that would be entirely implementation specific and could well vary under different optimization flags, etc.
22:24:26 <bxx> according to C faq c == c++ is undefined.  http://c-faq.com/expr/seqpoints.html
22:24:39 <Ghoul> aww
22:24:46 <donri> foss-world problems: to keep my unNewType functions or use (^.from newType) isos everywhere
22:25:08 <edwardk> they also ruled out c = c++, so the right hand side apparently doesn't happen before
22:25:18 <edwardk> i guess that makes sense actually because you can chain the result of =
22:26:09 <Ghoul> edwardk: I thought the behaviour for these operations were that
22:26:11 <johnw> shachaf: in C++, it undefined due to 5.4: "Except where noted, the order of evaluation of operands of individual operators and subexpressions of individual expressions, and the order in which side effects take place, is unspecified."
22:26:19 <Ghoul> --c = 2 means, subtract from c then compare
22:26:22 <johnw> still looking for the C rule, since I don't know that standard as well
22:26:27 <Ghoul> c-- = 2 means compare then subtract from c
22:26:37 <Ghoul> woops
22:26:42 <Ghoul> /s/=/==
22:27:01 <Ghoul> Hence, magic happens when you use a single equals
22:27:06 <Ghoul> c = 5;
22:27:11 <edwardk> Ghoul: yes, but here, the problem is you also have 'c' on the other side o the (==) and the relative order in which those two attempts to reference 'c' happens is undefined
22:27:13 <Ghoul> --c = 2; equals 2
22:27:21 <Ghoul> c-- = 2; equals 3
22:27:21 <Eduard_Munteanu> c-- can't be an lvalue
22:28:10 <donri> and bam ghc panic
22:28:14 <Eduard_Munteanu> Or can it? :/
22:28:26 <Nereid> nope
22:28:27 <sopvop> donri: I stick to direct newtype wrappers/unwrapper. Fear what maybe ghc might do less optimizations
22:28:29 <edwardk> johnw: http://c-faq.com/expr/seqpoints.html talks about the relevant line of the c standard and gives this exact example (with an i)
22:28:38 <Ghoul> Eduard_Munteanu: I dont think it matters
22:28:59 <Ghoul> as long as it isnt a pointer
22:29:00 <Nereid> if you're writing c == c++, then you need to be slapped in the face
22:29:00 <johnw> shachaf: In C it is undefined according to 6.5.16p4: "The order of evaluation of the operands [of the assignment operators] is unspecified."
22:29:03 <Ghoul> in which case it would still work
22:29:09 <Ghoul> but not as expected
22:29:09 <Nereid> who cares whether it means something or some other thing
22:29:43 <johnw> fyi, the phrase to search for questions like this is "sequence point"
22:29:52 <edwardk> Ghoul: we all understand that it works when the thing on the other side doesn't involve 'c' itself. =P
22:30:04 <Ghoul> :C
22:30:16 <donri> sopvop: there's a thought. someone should investigate core i guess?
22:30:17 <edwardk> i think ghoul just showed his fangs
22:30:29 <shachaf> c-- = 2; looks like an error to me.
22:30:35 <sopvop> donri: I fear the core even more :)
22:30:41 <donri> ^_^
22:30:53 <johnw> shachaf: it is; the result of c-- is not an lvalue
22:30:56 <shachaf> What's the question here?
22:30:59 <shachaf> johnw: Right.
22:31:26 <shachaf> I hear C++ has xvalues and lrvalues and all sorts of crazy values these days.
22:31:37 <johnw> heh, there are 5 kinds now, yes
22:31:38 <shachaf> Still doesn't have traversals, though!
22:31:44 <Ghoul> I read lrvalues as konami code.
22:31:50 <Ghoul> left right...
22:31:51 <donri> edwardk: d'ya know if newtype isos have more overhead than the newtype [de]constructors?
22:32:00 <shachaf> donri: Look at the Core!
22:32:16 <edwardk> shachaf would know ;)
22:32:22 <copumpkin> donri: shachaf has a package to sell you
22:32:29 <donri> ^_^
22:32:35 <shachaf> They're not supposed to, at least. Some of the crazy patches to lens recently have been to improve this sort of thing.
22:32:38 * copumpkin steals shachaf's agenda
22:32:47 <shachaf> copumpkin: Wait, which package am I selling?
22:32:52 <shachaf> Oh, right.
22:33:02 * shachaf forgot about that.
22:33:04 <copumpkin> http://hackage.haskell.org/package/ghc-core
22:33:07 * shachaf not good maintainer.
22:33:10 <edwardk> =)
22:33:12 <edwardk> wait
22:33:13 <donri> looks like i'm causing a ghc panic trying to do away with my record syntax anyway
22:33:18 <copumpkin> shachaf: I am disappoint
22:33:30 * Ghoul is wondering why -O3 styled asm-level optimisation is so hard
22:33:37 <donri> compiler/rename/RnPat.lhs:535:39-79: Irrefutable pattern failed for pattern gres@(gre : _)
22:33:43 <johnw> shachaf: rvalues, lvalues, xvalues, glvalues, and prvalues
22:33:51 <donri> i get that if I change the export WordData(..) to WordData(WordData)
22:33:59 <johnw> http://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues
22:34:07 <shachaf> @arr values
22:34:07 <lambdabot> Swab the deck!
22:34:20 <startling> haha
22:34:32 <johnw> shachaf: oh, and to put you to sleep at night: http://blog.regehr.org/archives/213
22:34:44 <shachaf> donri: What are you trying to find out, exactly?
22:35:23 <edwardk> you aren't? crap. i added the wrong person to the lens repo then ;)
22:35:23 * sopvop would never again touch c++, will stick to haskell and c.
22:35:38 * startling formats root partition, chomp chomp
22:36:58 * hackagebot yesod-fay 0.1.0.1 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.0.1 (MichaelSnoyman)
22:37:39 <Ghoul> om nom nom nom zfs
22:38:23 <startling> wow, unmatched " are undefined? silly C.
22:38:43 * sopvop is intimidated by 61 package in yesod category on hackage.
22:39:03 <shachaf> edwardk: Don't worry, I'll just add someone else to it when I'm tired of it.
22:39:08 <shachaf> Hmm, I can't do that.
22:39:19 <startling> shachaf: ;)
22:40:03 <shachaf> startling volunteered to benchmark lens, didn't you, startling?
22:40:18 <edwardk> hahaha
22:40:46 <startling> I volunteered when shachaf told me how much fun benchmarking haskell was.
22:41:09 <shachaf> donri: What are you wondering about with newtype isos specifically?
22:41:58 <donri> nothing, really. it was sopvop who wondered about overhead.
22:42:18 <shachaf> sopvop: ?
22:43:32 <sopvop> yup, I use Wrap/unWrap directly, not through fancy lens ^. operators, because I can't read core and think it might interfere with wrapping optimizations.
22:44:32 <johnw> I think I would summary lens as "expressive traversals"
22:45:26 <johnw> it's strange to me that "ghc-pkg check" is happy, but "cabal install world" gives me a ton of conflicts
22:46:03 <shachaf> sopvop: It should work out to the same thing.
22:46:11 <shachaf> sopvop: Do you have a specific example you're wondering about?
22:47:47 <edwardk> sopvop: it evaluates to id in core
22:47:56 <edwardk> then it vanishes when applied
22:48:02 <edwardk> sopvop: i just looked
22:48:53 <startling> wow, cool.
22:49:11 <shachaf> sopvop: Core isn't that hard to read.
22:49:12 <edwardk> both foo and from foo do
22:49:23 <shachaf> Like most generated code, it's overwhelming at first because there's so much of it.
22:50:11 <shachaf> If you suppress the casts and put {-# NOINLINE blah #-} next to your functions and other tricks like that, it becomes pretty simple.
22:50:51 <shachaf> The first step to reading generated code like Core or assembly is knowing what to ignore. :-)
22:51:05 <shachaf> (Almost everything, usually.)
22:51:59 * hackagebot aivika-experiment 0.1.2 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.1.2 (DavidSorokin)
22:56:59 * hackagebot aivika-experiment-chart 0.1.2 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.1.2 (DavidSorokin)
22:58:18 <johnw> byorgey: ping
22:58:48 <Ghoul> pong
22:58:52 <Ghoul> 700ms
22:58:59 <sopvop> shachaf: Thanks for checking, I fear lens less now
22:59:04 <johnw> man in the middle attack!
22:59:16 <Ghoul> haha
22:59:19 <shachaf> Ghoul: You don't give someone the latency in your pong...
22:59:33 <Ghoul> shachaf: sharing is caring
23:01:57 <shachaf> startling: So are you going to write those benchmarks?
23:02:07 * shachaf can't even think of how to benchmark the mapped thing in a meaningful way.
23:02:23 <edwardk> shachaf: delegating already i see. i'm proud
23:02:26 <johnw> shachaf: can I help you with the lens benchmarking?
23:02:27 <startling> shachaf, yes, but I'll need a little hand holding. I'll probably start tomorrow
23:02:45 <johnw> or help startling?
23:03:03 <shachaf> johnw: Why don't you help startling help me help edwardk write a package that helps you write fast code?
23:03:10 <johnw> done!
23:03:26 <johnw> with criterion, all evaluable things are possible
23:03:27 <startling> recursive dependency!
23:03:27 * edwardk gets the impression this is going to turn into an epic game of telephone ;)
23:03:41 <johnw> or chinese whispers
23:03:41 <startling> edwardk, so you want to benchmark against xmonad, right
23:03:46 <johnw> lol
23:04:06 <edwardk> yes, please rewrite xmonad to use lens and benchmark
23:04:18 <donri> lens *all* the things
23:04:33 <startling> edwardk: k. and what was the thing you wanted me to do with yesod?
23:04:54 <shachaf> edwardk: So .Zipper doesn't let you have a "zipper" on lists that are infinite in both directions, does it?
23:05:02 <edwardk> it may have involved killing something with fire ;)
23:05:08 <edwardk> shachaf: nope
23:05:30 <startling> edwardk: darn, I was hoping i could piggyback on your zipper code.
23:05:36 <edwardk> shachaf: it is for real zippers into real structures. that isn't a realizable derivative. you can't zip it back up
23:05:50 <edwardk> its infinitely far to the right.
23:05:50 <shachaf> Fair enough.
23:06:33 <donri> far out.
23:07:24 <Ghoul> So how's GHC and register intersparsing :)
23:07:50 <sopvop> with data Stored a = Stored { fromStored :: a }, iso Stored fromStored :: Simple Iso what here? Or it is not Simple Iso?
23:08:29 <Ghoul> Read-write grouping
23:09:24 <sopvop> oh, got it. reversed order of params
23:09:45 <Nereid> between a and Stored a, clearly.
23:10:12 <edwardk> shachaf: i think i should delegate the oren's parameterized makeclassy bug to you. that'll make for fun family conversations.
23:16:40 <sopvop> do Lens have strict versions of set, view, over?
23:17:21 <edwardk> set foo $! 1 + 2    =)
23:17:53 <edwardk> the very nature of 'view' is to give a single result back, no point in strictness there, it comes from the demand
23:18:29 <sopvop> but the Data.Lens had them... :)
23:18:36 <edwardk> yes, because i was an idiot
23:20:25 * sopvop still is
23:20:55 <covi> Arrows are hard to understand. Should I learn some category theory first?
23:20:55 <edwardk> now, im not saying that some of those combinators couldn't admit strict variants
23:21:19 <edwardk> covi: no, you should learn applicatives and monads really well, and shrug when someone asks if they should learn arrow
23:21:50 <sopvop> covi: Arrows are almost like monads, it's just that (***) and friends are funny.
23:21:50 <shachaf> edwardk: Hmm, it looks like it makes an actual benchmarkable difference. :-(
23:21:53 <johnw> covi: http://newartisans.com/2012/10/arrows-are-simpler-than-they-appear/
23:21:56 <johnw> :)
23:22:04 <edwardk> shachaf: how much?
23:22:13 <shachaf> Let me run a proper benchmark.
23:22:17 <edwardk> kk
23:22:18 <shachaf> Well, not proper, but slightly more proper.
23:22:38 <startling> covi: arrows are not very useful at all
23:22:43 <covi> edwardk: are you saying that arrows are more than enough in terms of being productive in Haskell?
23:23:09 <johnw> startling: I would hardly say that
23:23:14 <edwardk> covi: i'm saying that almost every usecase for arrows is better served with an applicative or monad, and they are vastly easier to learn and understand
23:23:29 <startling> johnw, compared to Monad and Applicative?
23:23:34 <sopvop> Some argue what arrows give cleaner 'pipeline syntax'.
23:23:36 <covi> edwardk: i see
23:23:46 <johnw> startling: if you ever need to "hook into composition", they are the only sane option I know of
23:23:48 <edwardk> the major motivating example for arrows back in the day was the swierstra and duponcheel parser, but that works better applicatively.
23:23:49 <shachaf> Wait, my benchmark was completely improper.
23:23:55 <shachaf> I was still seeing some difference, though.
23:24:01 <donri> i kinda thought arrow was easier than applicative, but alright
23:25:26 <edwardk> sopvop: that is pretty much the sole reason why i used the weasel word 'almost' ;)
23:25:54 <edwardk> johnw: Control.Category is a superclass of arrow and gives you the composition part
23:26:09 <solirc> If I have `newtype Value = Value (Ptr ())` and never use the constructor, then GHC warns.  I wonder if it would be desirable to teach GHC to never warn on unused newtype constructors?
23:26:14 <johnw> edwardk: yeah, very good point
23:26:23 <johnw> arrows give you the data flow stuff
23:26:42 * solirc wonders if there are possibly situations where this warning could be useful?
23:26:44 <johnw> which you need if you want to deal with intermediate values in composition chains
23:26:45 <edwardk> johnw: the problem with arrows is they are so damn restrictive, the 'arr' mapping from Hask is too much.
23:27:06 <johnw> yeah, I'm not saying use them if you can, just use them if you must ;)
23:27:09 <edwardk> usually you'd be happier with just a cartesian closed category
23:27:18 <johnw> HXT makes pretty good use of them, I thought
23:27:46 <edwardk> hxt uses them. i'll say that. not sure i'd call what results good =)
23:27:54 * sopvop reads cartesian closed category on wikipedia
23:28:04 <c_wraith> I'm really not sure what HXT does with them that wouldn't be just as clean with applicatives
23:28:15 <edwardk> c_wraith: exactly
23:28:42 <sopvop> I failed to understand how to use HXT at all.
23:29:16 <johnw> HXT uses Arrows to abstract IO, similar to what my blog post describes
23:29:27 <edwardk> the hint that hxt chose the wrong abstraction (admittedly i don't think applicative existed back then) is that almost every arrow in hxt is oblivious to its context.
23:29:28 <edwardk> xmlChar                 :: XParser s Unicode
23:29:29 <johnw> if that can be done with applicative and category, I'd love to know how
23:29:35 <edwardk> look at that s wallowing there.
23:29:55 <edwardk> dtdDeclTokenizer :: XParser s XmlTree
23:30:00 <edwardk> oops. still useless
23:30:41 <edwardk> its bad enough they bother to just define type SimpleXParser a = XParser () a
23:31:54 <shachaf> That's silly. SimpleXParser a b = XParser a a b b
23:32:04 <edwardk> shachaf: hahahaha
23:32:51 <sopvop> Data.Xml.Lens?
23:33:03 <sopvop> Or rather Text.Xml
23:33:07 <edwardk> the other thing is every arrow they define as an ArrowXml or ArrowDTD is a monad.
23:33:22 <edwardk> so the utility of arrow is already lost
23:34:04 <johnw> how do you abstract IO from composition without Arrow?  with Category?
23:34:32 <edwardk> i compose with (>=>) or (>>=)
23:34:51 <edwardk> especially when my arrows are all ArrowApply instances anywyas
23:35:09 <johnw> ah, well, then sur
23:35:34 <johnw> would like to hear your comment on my blog post if you ever feel inclined
23:36:06 <johnw> i thought it was an argument for Arrow, but maybe I'm just special casing and ordinary composition with Category is better
23:36:32 <johnw> yeah, looks like it
23:36:36 <johnw> huh
23:36:45 <johnw> so how come everyone got so excited about Arrows?
23:36:51 <johnw> because Applicative hadn't come along?
23:39:50 <Ralith> they're quite a bit different
23:40:31 <edwardk> yes, because applicative wasn't here yet
23:40:49 <johnw> that explains why I've yet to find a need for Arrows
23:41:15 <edwardk> this is why i occasionally do my 'arrows are not the abstraction you are looking for' rant ;)
23:41:21 <edwardk> otherwise people buy the hype =)
23:41:29 <johnw> ok, you've convinced for me for now :)
23:41:37 * Ralith wonders how else you would implement FRP
23:41:48 <johnw> ugh, I just wrote some C++ and my fingers are screeching in pain
23:42:05 <donri> most FRP uses applicative. netwire uses both.
23:42:18 <edwardk> donri beat me to it
23:42:22 <sopvop> edwardk: you should write an arrow-bashing blogpost and start a flamewar on reddit.
23:42:41 <Ghoul> Wow, I'm quite impressed by the level of optimisation that can be applied to hand written assembler
23:42:46 <Ghoul> That compilers tend to ignore
23:42:55 <edwardk> nah, i tend to reserve my more id-like persona for #haskell ;)
23:43:57 <donri> i've heard arrow being described as "still useful due to ArrowLoop"
23:44:09 <donri> IIRC
23:44:19 <Ghoul> A system would have to be written that decides on register dependancies and does some kind of instruction shuffle
23:44:33 <Ghoul> And then I'm sure after the shuffle you could run the optimiser again and refold :O
23:44:39 <Ghoul> and reshuffle :O
23:45:02 <edwardk> arrowloop is pretty useful
23:45:28 <edwardk> and anyways, i did throw the appropriate weasel words out there. there are some usecases for arrow.
23:45:39 <donri> is ApplicativeLoop possible?
23:45:45 <edwardk> its just reached for far too often
23:45:55 <donri> oh? I thought it was hardly used :)
23:46:21 <johnw> let's rewrite lambdabot using all arrows, and then it will auto-kick edwardk from the channel
23:47:16 <sopvop> all power to the arrows!
23:47:32 <donri> i'd like to see a hxt-style xml library using applicative/category instead of arrow
23:48:09 <c_wraith> all glory to the hypnotoad!  (I mean, what?)
