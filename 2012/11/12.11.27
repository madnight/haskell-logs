00:00:42 <gatlin> i have a regular grammar and there are purportedly tools for dealing with it. seems reasonable.
00:00:59 <Sonarpulse> well in my defence there are some other "optomizations" there
00:01:03 <Sonarpulse> that work both ways
00:01:09 <Sonarpulse> but yes, do notation to the rescue
00:06:03 <Sonarpulse> is there an fzipWith btw?
00:06:42 <shachaf> ?
00:06:54 <Sonarpulse> an analogue to fmap
00:07:21 <shachaf> You should err on the side of being more detailed with your questions.
00:07:54 <Sonarpulse> yeah that was especially bad cause f<name> isn't much a convention
00:07:56 <Nereid> what would it do? what would its type be?
00:08:31 <mauke> :t liftA2
00:08:32 <lambdabot> Applicative f => (a -> b -> c) -> f a -> f b -> f c
00:08:35 <Sonarpulse> Functor f => (a -> b -> c) -> f a -> f b -> f c
00:08:54 <shachaf> No, it's impossible to write a function of that type. But see what mauke said.
00:08:58 <mauke> :t ZipList
00:08:59 <lambdabot> [a] -> ZipList a
00:09:03 <Nereid> :t zipWith . liftA2
00:09:04 <lambdabot> Applicative f => (a -> b -> c) -> [f a] -> [f b] -> [f c]
00:09:26 <shachaf> But there's also a distinctions between zipping and lifting. But that's not really relevant here.
00:09:37 <Sonarpulse> ok
00:09:39 <shachaf> Anyway you already know about liftM2
00:09:41 <Sonarpulse> yeah
00:09:44 <shachaf> Are you dealing with something that isn't a monad?
00:09:53 <Sonarpulse> no, but Nereid used fmap
00:09:59 <Nereid> fmap = liftM
00:10:03 <Sonarpulse> and I hadn't released that
00:10:08 <Sonarpulse> which got me thinking
00:10:34 <Nereid> liftA is also liftM, which generalizes to liftA2 = liftM2, ...
00:10:51 <Nereid> but there's no point in writing liftA ever because every lawful Applicative is also a Functor where fmap = liftA
00:11:10 <Sonarpulse> ok
00:11:13 <Sonarpulse> good to know
00:11:14 <Nereid> (every Monad should be a Functor too, but that isn't expressed in the types)
00:11:17 <shachaf> Functor gives you lift1 :: (a -> b) -> f a -> f b
00:11:30 <Nereid> also liftA0 is called pure
00:11:34 <shachaf> Applicative adds onto that lift0 :: a -> f a and lift2 :: (a -> b -> c) -> f a -> f b -> f c
00:11:39 <Nereid> yeah
00:11:50 <shachaf> That lets you write any lifting function.
00:12:13 <Nereid> in fact, you don't need liftA2 in general; it suffices to have
00:12:14 <Nereid> :t liftA2 (,)
00:12:15 <lambdabot> Applicative f => f a -> f b -> f (a, b)
00:12:26 <shachaf> It suffices to have a lot of things.
00:12:27 <Nereid> but no one really does it that way
00:12:34 <shachaf> Why specialize of (,) if we don't need to?
00:12:40 <Nereid> more suggestive:
00:12:45 <Nereid> :t uncurry $ liftA2 (,)
00:12:47 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
00:12:59 <Nereid> I know.
00:13:07 <Nereid> but it makes the "monoidal functor" part more apparent.
00:13:20 <Nereid> oh yeah,
00:13:31 <Nereid> in place of pure it also suffices to have
00:13:33 <Nereid> pure ()
00:13:41 <Nereid> because you can always fmap that to whatever else
00:13:46 <shachaf> Yes.
00:14:04 <shachaf> But that seems silly to me.
00:14:12 <Nereid> not to a mathematician :(
00:14:13 <shachaf> Why give tuples special rights?
00:14:25 <Sonarpulse> well, i just pushed
00:14:31 <Nereid> because monoidal product
00:14:37 <edwardk> unsafeCoerce count: 92
00:14:52 <Sonarpulse> there was one thing i forgot which makes combining the inner IFs unpracticle
00:15:00 <Sonarpulse> :(
00:15:09 <Sonarpulse> this is still the native style
00:15:18 <Sonarpulse> now i will unstash and finish do-ing it
00:15:28 <edwardk> i'm tempted to graph lens's unsafeCoerce count by version number for the talk ;)
00:15:35 <Nereid> lol
00:20:48 <liyang> Is there anything of type (Functor f) => SimpleLens s a -> SimpleLens (f s) (f a) ?
00:21:00 <edwardk> :t mapping
00:21:01 <lambdabot> (Functor f1, Functor f, Isomorphic k) => SimpleIso s a -> k (f a -> f1 (f a)) (f s -> f1 (f s))
00:21:48 <liyang> mapping requires a SimpleIso… (I suggested it. ;p)
00:21:56 <edwardk> i know =)
00:29:31 <liyang> I think I need Applicative. :-/
00:31:44 <neutrino> in a do block in the IO monad, if there's a function func of type Foo -> IO (), I can just go "func myfoo", right?
00:31:52 <neutrino> i don't need to do <- or anything?
00:33:20 <beaky> hell
00:33:25 <beaky> hello
00:33:43 <hpaste> liyang pasted “Is mopping more useful than mapping?” at http://hpaste.org/78346
00:34:06 <beaky> are integers monoids?
00:34:28 <bitonic> beaky: yes, in at least two way
00:34:30 <neutrino> yes
00:34:32 <liyang> Integers and what operation?
00:34:34 <bitonic> *ways
00:34:35 <neutrino> in many, many ways
00:34:44 <neutrino> bitonic: what do you know about monoids?
00:34:53 <beaky> what are monoids?
00:35:05 <liyang> In Haskell, Integer is not an instance of Monoid.
00:35:10 <neutrino> er, that was for beaky
00:35:24 <neutrino> beaky: do you know the monoid laws?
00:35:27 <beaky> yes
00:35:33 <beaky> monoid id = 0
00:35:38 <beaky> mappend = (+)
00:35:51 * hackagebot conduit 0.5.4.2 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.4.2 (MichaelSnoyman)
00:35:55 <neutrino> those are not the laws
00:35:59 <beaky> ah :(
00:36:01 <neutrino> they're just instances of special elements
00:36:33 <beaky> what are the monoid laws
00:36:45 <liyang> (Integer, 0, +) is a monoid… and so is (Integer, 1, *).
00:36:50 <neutrino> you have two special elements in a monoid structure on a set: one is a binary operator on that set (for example, (+)), another is an element of the set (for example, 0)
00:37:11 <neutrino> those need to meet the following laws:
00:37:18 <liyang> edwardk: Did you see http://hpaste.org/78346
00:37:25 <neutrino> 1. the binary operator is associative
00:37:38 <neutrino> 2. the special element is an identity of the binary operator
00:37:57 <neutrino> so for example, * is associative
00:38:02 <neutrino> and 1 is its identity
00:38:27 <beaky> ah
00:39:05 <beaky> are there bonoids?
00:39:08 <beaky> binoids*
00:39:19 <neutrino> er, not really
00:39:29 <neutrino> "monoid" just refers to the fact that you have one operation.
00:39:46 <beaky> oh
00:39:53 <beaky> so monoids are rings
00:40:10 <beaky> or am i mistaken?
00:40:29 <neutrino> if you want two operations you can take a ring, or an algebra
00:40:33 <neutrino> no, they're not rings
00:40:43 <beaky> oh'
00:40:51 <beaky> so monoids are degenerate rings
00:40:54 <edwardk> liyang: does it pass laws?
00:40:56 <neutrino> a ring requires two operations to be defined
00:41:32 <beaky> so if i defined both * and + for my Integer monoid, it becomes a ring?
00:41:34 <edwardk> i think not ;)
00:41:34 <edwardk> liyang: fclabels had some abomination like that too
00:41:46 <liyang> Oh. D:
00:42:21 <Pantoufle> A ring must have invertible elements, doesn't it?
00:42:30 <Pantoufle> *must it not
00:42:30 <neutrino> beaky: if you can prove that they meet the assumptions, yes
00:42:33 <neutrino> (you can't)
00:42:40 <bitonic> neutrino: what many monoids did you have in minds with Z?
00:42:40 <neutrino> look here: http://mathworld.wolfram.com/Ring.html
00:42:52 <beaky> aww :(
00:43:09 <neutrino> bitonic: there are theoretically infinitely many binary operations that make Z into a monoid.
00:43:11 <beaky> but I can prove that Rationals are rings?
00:43:45 <neutrino> give it a try :)
00:44:17 <neutrino> look at the 6 conditions on the page i linked to and see if they fit for rationals
00:44:32 <beaky> right
00:44:36 <Pantoufle> neutrino: how do you call the extension of a field with fractions?
00:44:54 <bitonic> neutrino: well it’s very easy to generate monoids with subsets of Z but I can’t picture many monoids on Z itself...
00:45:59 <beaky> are monnoids categories too?
00:46:07 <bitonic> neutrino: do you have a relevant link?
00:46:07 <neutrino> Pantoufle: i think you mean the extension of an integral domain with fractions to form a field.
00:46:12 <neutrino> bitonic: no.
00:46:37 <Pantoufle> neutrino: yes, but I mean in the general case (with reals, polynomials…)
00:46:45 <neutrino> Pantoufle: a field already has fractions.
00:46:59 <bitonic> neutrino: so OK, what’s an example of a monoid on Z apart from + and *?
00:47:21 <neutrino> or do you mean the structure you get when you define classes of fractions by what they reduce to?
00:47:44 <neutrino> bitonic: no idea :)
00:47:58 <neutrino> it's just something i remember .. it might actually be wrong now that i think about it
00:47:59 <beaky> what is so great about monoids?
00:48:07 <neutrino> what is so great about bricks?
00:48:16 <Pantoufle> No, I mean this: you take R[X], polynomials on R. You can define R(X), which are all the fractions P/Q where P and Q are in R[X]
00:48:23 <neutrino> people build houses with them all the time, they gotta be great, right?
00:48:28 <beaky> right
00:48:45 <beaky> so they are elementary building blocks
00:48:49 <beaky> monods are *
00:48:52 <beaky> monoids*
00:48:56 <neutrino> Pantoufle: R[X] is not a field
00:49:02 <Pantoufle> Ow
00:49:04 <beaky> but what do monoids build/?
00:49:24 <neutrino> under R[X] i understand it will only have positive powers of X
00:49:30 <bitonic> neutrino: I mean you can generate infinitely many groups by taking all the multiples of a number, or the Z modulo something, but I can’t see how you can generate infinitely many groups on Z itself.  you may very well be right I know almost nothing about this
00:49:38 <Pantoufle> neutrino: yes
00:49:39 <bitonic> *many monoids
00:49:53 <neutrino> Pantoufle: what is the inverse of f(x) = x?
00:50:17 <beaky> neutrino: x?
00:50:19 <Pantoufle> f
00:50:19 <neutrino> bitonic: oh, yeah, but that's not what i was thinking of.
00:50:29 <beaky> oh
00:50:30 <neutrino> Pantoufle: very funny
00:50:36 <Pantoufle> Ahah
00:50:40 <beaky> lol
00:50:43 <neutrino> beaky: you need a number a such that a*x = x*a = 1
00:50:52 * hackagebot doctest 0.9.3 - Test interactive Haskell examples  http://hackage.haskell.org/package/doctest-0.9.3 (SimonHengel)
00:50:58 <beaky> ah
00:51:03 <beaky> then it's 1/x
00:51:16 <beaky> thougght you meant function inverse
00:51:19 <neutrino> but 1/x = x^(-1), a negative power of x, which is not contained in R[X]
00:51:25 <beaky> ah right
00:51:27 <Pantoufle> I thought it was under the composition law ^^
00:51:31 <Pantoufle> Ok
00:52:32 <beaky> higher order functions ftw
00:55:45 <beaky> i love monoids
00:55:48 <beaky> they are so easy
00:58:13 <bitonic> neutrino: well, wolfram says that “the integers under the operation max(x+y,n) also forms a commutative monoid.” but I think they mean for the integers >= n, otherwise I don’t see you can have the identity element
00:58:59 <ramses_> for a fixed n then?
00:59:50 <bitonic> well yes the `n' is part of the operation
01:02:40 <Ferdirand> what about min(x+y,n) ?
01:03:22 <bitonic> well what’s the identity for that?
01:03:48 <bitonic> again it works if you pick integers <
01:03:49 <Ferdirand> 0 ?
01:03:49 <bitonic> n
01:04:26 <bitonic> min(3 + 0, 5) gives 5.
01:04:31 <bitonic> which is not 3
01:04:33 <Ferdirand> no, it gives 3
01:04:49 <bitonic> sorry, `min(7 + 0, 5) gives 5' :P
01:04:56 <bitonic> I was still thinking about `max'
01:05:14 <Ferdirand> right, so it only works for <= n
01:05:24 <Ferdirand> but at least it has an identity ?
01:05:36 <bitonic> yes but it’s not on Z then...
01:07:02 <beaky> what is so special about monoids in the category of endofunctors?
01:07:10 <beaky> if monoids are basically just adding?
01:08:00 <johnw> there's actually nothing special
01:08:11 <johnw> and they are not sufficient to _define_ a monad
01:08:14 <beaky> oh
01:08:29 <beaky> so that's where the endofunctor part comes in?
01:08:35 <johnw> let me show you
01:08:55 <johnw> head over here: https://github.com/jwiegley/posts/blob/master/Adjunctions%20in%20Haskell/Adjunction.hs#L134
01:09:32 <johnw> in the first instance of Monoid there, we see that functions form a Monoid over composition
01:09:43 <johnw> well, monads do to, within the Kleisli categeory
01:09:46 <johnw> and that's it
01:09:51 <johnw> nothing special at all
01:10:14 <johnw> err, *endomorphisms* form a Monoid over composition
01:10:16 <johnw> not all functinos
01:10:37 <johnw> and probably I should be saying under, not over
01:11:26 <beaky> are functions themselves monoids?
01:11:41 <beaky> where mempty is (id) and mappend is (.) ?
01:11:43 <johnw> so, composing endofunctors in a Kleisli category is just like composing endomorphisms in the category of Sets
01:11:53 <johnw> endomorphisms form a monoid
01:11:58 <johnw> functions with the same domain and codomain
01:12:24 <beaky> oh
01:12:42 <beaky> so something like id is an endofunctor
01:12:48 <donri> a -> a is a monoid (under the Endo newtype in haskell) but a -> b is not
01:12:56 <johnw> something like "return" is an endofunctor
01:13:02 <beaky> ah
01:13:06 <beaky> :t return
01:13:07 <lambdabot> Monad m => a -> m a
01:13:12 <shachaf> How is that an endofunctor?
01:13:44 <johnw> isn't an endofunctor a -> f a
01:13:58 <shachaf> What?
01:14:05 <shachaf> What are a and f?
01:14:23 <johnw> where a is a type and f is a functor
01:14:44 <Saizan> an endofunctor is just a functor whose source and target category are the same one
01:14:48 <shachaf> Are you talking about Haskell?
01:15:05 <shachaf> I think f would be the only endofunctor involved here.
01:15:06 <johnw> shachaf: i'm using Haskell syntax, but not specifically talking about HAskell
01:15:17 <Saizan> it doesn't require the presence of a nat trans. Id -> F
01:15:21 <johnw> shachaf: yes, you are right
01:15:22 <donri> i've hard both endofunctor and endofunction, are those different
01:15:34 <johnw> i'm confusing the object-mapping part of the functor pair with the functor itself
01:15:52 <johnw> donri: i've never heard of endofunction
01:16:00 <shachaf> donri: "endo" means "from something to itself"
01:16:15 <beaky> wow
01:16:22 <donri> looks like endofunction is the Endo newtype
01:16:27 <beaky> it all makes sense now :D
01:16:30 <shachaf> So an endofunctor is a functor from a category to itself; an endofunction would be a function from a type to itself.
01:16:34 <johnw> beaky: sorry beaky
01:16:43 <beaky> huh?
01:16:53 <johnw> beaky: i thought you were being facetious
01:17:55 <beaky> http://en.wikipedia.org/wiki/Endomorphism
01:18:05 <johnw> whenever my use of math terminology doesn't get questioned for several minutes, I'm about 10% sure I got it right, and 90% sure everyone was just sleeping :)
01:18:25 <johnw> but shachaf keeps me honest, every time
01:18:34 <beaky> ah
01:18:38 <shachaf> Hardly.
01:21:00 <johnw> beaky: in that code I showed you, idT is just another name for "return"
01:21:12 <beaky> oh
01:21:18 <johnw> i was striving to match CT terminology, not Haskell terminology
01:21:21 <beaky> so idT is the Functor id
01:21:23 <beaky> what is CT?
01:21:45 <johnw> CT = category theory
01:21:52 <beaky> ah
01:22:03 <johnw> idT is the identity functor for a monad T
01:22:06 <beaky> I keep hearing a lot about category theory when I do haskell
01:22:13 <johnw> that's a good thing
01:22:18 <shachaf> It isn't.
01:22:25 <johnw> it really is
01:22:43 <johnw> category theory is the language of many of the abstractions underlying Haskell
01:23:05 <dmwit> eh
01:23:11 <beaky> category theory is like the god of all theory?
01:23:13 <dmwit> CT is the language the designers of Haskell think in.
01:23:24 <dmwit> It isn't necessarily the best language for understanding Haskell, though.
01:23:24 <beaky> all type theory*
01:23:45 <johnw> it has a strong connection to type theory
01:24:02 <shachaf> dmwit: Which designers of Haskell?
01:24:30 <beaky> now that I got monoids and endomorphisms, I think I get monads :D
01:24:40 <beaky> a monad is like an endomorphic monoid
01:24:50 <johnw> no, i'm sorry to say
01:24:58 <dmwit> shachaf: Wadler, I guess
01:24:59 <beaky> :(
01:25:07 <johnw> it's not a monoid of endomorphisms, but a monoid in the category of endofunctors
01:25:22 <johnw> also, that's not sufficient to define what a monad is
01:25:26 <shachaf> @quote spj category.theory
01:25:26 <lambdabot> spj says: "You do the category theory, and you talk to Gordon. And he talks to Phil. And Phil talks to me."
01:25:42 <johnw> it's just one of the other ways you can characterize a monad
01:25:44 <edwardk> haha
01:26:16 <beaky> ah
01:26:40 <johnw> beaky: i wouldn't worry much about the CT definition of monad at this stage
01:26:59 <dmwit> Hinze and Hudak, probably.
01:27:08 <johnw> beaky: if you want to get into CT, really groove on functors first
01:27:10 <dmwit> Not sure about the rest of the names on the Report. =)
01:27:22 <beaky> right
01:27:26 <beaky> so what are functors?
01:27:37 <johnw> they are mappings between categories
01:27:47 <edwardk> beaky; in proper CT or Haskell?
01:27:55 <beaky> in CT
01:27:58 <edwardk> beaky: e.g. functor or Functor?
01:28:11 <edwardk> Do you know what a category is?
01:28:16 <beaky> not really
01:28:20 <Jaxan> ha
01:28:27 <johnw> beaky: do you know about sets?
01:28:28 * dmwit summons Cale
01:28:35 <beaky> yes
01:28:40 <dmwit> If you say his name three times...
01:28:42 <beaky> sets are like bags of stuff
01:29:05 <johnw> do you know about set theory?
01:29:12 <liyang> Sets are definitely not like bags!
01:29:17 <edwardk> A category is a bunch of arrows and objects, where the arrows connect objects, and where you can compose the arrows and every object has an identity arrow. e.g. there is a category of sets, where each set is an object, and the arrows are mappings between them
01:29:46 <johnw> beaky: i think you would like http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_1?ie=UTF8&qid=1354008561&sr=8-1&keywords=category+theory+lawvere
01:29:55 <beaky> so in the caterogy of sets, an arrow would be like set union?
01:29:57 <dmwit> "functions" is probably a more familiar term than "mappings", FWIW
01:29:59 <beaky> or carterian product
01:30:10 <dmwit> In SET, the arrows are functions.
01:30:18 <beaky> ah
01:30:24 <dmwit> (There are other categories with sets as objects whose arrows are other things.)
01:30:27 <euskarate> I've got some object I want to feed into some single-threaded function... fully evaluating the object in parallel and then feeding it into the function works fine, but consumes a lot of memory... do I have a viable alternative?
01:30:32 <edwardk> A functor is a mapping from one category to another category that preserves the structure of the original category. e.f. you map objects that connect to arrows to objects that connect to arrows in the new category, so that when you lift up the spider web of arrows you put it down somewhat mashed and mangled but not torn.
01:30:48 <euskarate> I'd like in some sense for the object to be evaluated in parallel "as needed", which I know doesn't completely make sense, but I don't know how to go about formulating what I really want
01:30:48 <beaky> so inside sets, the arrows are functions, but outside them arrows are something different?
01:31:09 <dmwit> Where did this talk of "inside" and "outside" come from?
01:31:18 <dmwit> oh
01:31:22 <edwardk> beaky: different categories use different notions of arrow
01:31:24 <dmwit> SET is the name of a particular category.
01:31:29 <beaky> ah
01:32:00 <edwardk> beaky: you might have a category for the partial ordering of the numbers 1, 2, and 3.   where the arrows are the relationship <= .   1 <= 2       , 2 <= 3    the composition of those arrows gives you 1 <= 3.
01:32:05 <dmwit> There's also categories like REL (where objects are sets and arrows are relations) and MON (where objects are monoids and arrows are monoid homomorphisms), etc.
01:32:09 <euskarate> a category just formalises the idea of having objects with arrows between them that you can compose
01:32:15 <edwardk> the fact that every object has an identity arrow gives you 1 <= 1, 2 <= 2, and 3 <= 3.
01:32:23 <beaky> oh
01:32:26 <euskarate> and an example of a category is the category of sets where the objects are sets and the arrows are functions
01:32:53 <beaky> functions like addition?
01:32:55 <edwardk> beaky: you can also have categories of 1-to-1 functions, onto functions, bijections, etc.
01:33:19 <dmwit> Yes, the addition function is an arrow between two particular sets.
01:33:20 <Jetbeard> Is this the right place to ask about Cabal dependency hell?
01:33:30 <dmwit> Jetbeard: yes
01:33:35 <johnw> Jetbeard: this channel is the 8th circle of cabal hell
01:33:47 * dmwit <3 cabal
01:35:21 <hpaste> Jetbeard pasted “'url' package claims to be missing” at http://hpaste.org/78348
01:36:05 <dmwit> runhaskell Setup.hs configure --user
01:36:08 <dmwit> or --local
01:36:12 <dmwit> I can never remember which.
01:36:33 <dcoutts_> Jetbeard: or install using cabal
01:36:39 <dcoutts_> rather than runghc Setup
01:37:04 <johnw> beaky: you may want to google around for introductions to CT
01:37:10 <dmwit> Yep, just "cabal install" is my preferred way.
01:37:14 <beaky> right
01:37:21 <beaky> maybe if I learn CT I will be a better programmer
01:37:28 <bitonic> beaky: maybe not.
01:37:32 <bitonic> maybe it doesn’t matter
01:37:33 <johnw> all the stuff this channel just told you I'm betting meant almost nothing to you at this poitn
01:37:55 <bshields> Can anyone tell my why this works as expected: class Test a b c | ab -> c; instance Test x y y; instance Test x x x;
01:38:16 <johnw> beaky: I think CT is very valuable, and it has helped me to see a lot of things more clearly in the domain of functional programming
01:38:20 <bshields> But this fails with Functional dependency conflict:
01:38:40 <bshields> class Test a b c | ab -> c; instance Test x y (x,y); instance Test x x x;
01:39:17 <dmwit> bshields: Because there is no longer a function which takes in the "a" and "b" arguments and produces "c".
01:39:42 <bshields> so (a,b) is not a valid c?
01:39:48 <dmwit> The first instance says the function should take "x" and "x" and produce "(x, x)", but the second instance says the function should take "x" and "x" and produce "x".
01:39:52 <MrWoohoo> I know ghci doesn't allow it, but does ":t do" have a generic type/
01:39:57 <MrWoohoo> ?
01:40:09 <dmwit> No, do is not a term, it's syntax.
01:40:27 <dcoutts_> Jetbeard: for reference: http://www.haskell.org/cabal/FAQ.html#runghc-setup-complains-of-missing-packages
01:40:52 <MrWoohoo> right, but whatever it expands into, does it have a type like m a -> m b?
01:40:52 <dcoutts_> Jetbeard: so thankfully this isn't an instance of "cabal dependency hell"
01:41:08 <bitonic> dmwit: to be honest, GHC conditions are stricter than necessary, but in this case your analogy works
01:41:39 <Jetbeard> excellent, thanks dcoutts_ :) i thought it was going to be hell but it was more like accidentally burning my finger very slightly
01:41:43 <dmwit> MrWoohoo: Not always, no.
01:41:48 <bitonic> it doesn’t try to derive any function it’s just syntactical rules
01:42:02 <dmwit> MrWoohoo: (In fact, quite rarely does it expand into a functional type.)
01:42:09 <kosmikus> MrWoohoo: "do" alone doesn't expand to anything; it depends on what comes after the "do"
01:42:34 <dmwit> bitonic: It doesn't try to derive a function, but it does check that you *could* derive a function.
01:42:59 <bitonic> dmwit: yes but there are cases in which a function exists but GHC will still reject your instance
01:43:36 <bitonic> just wanted to make that clear
01:43:46 <dmwit> huh
01:43:48 <dmwit> Like what?
01:44:38 <sopvop> which package people use now instead of MonadCatchIO? monad-control?
01:45:01 <bitonic> dmwit: if a function could be formed by using other functional dependencies, for example... there was a “won’t fix” bug regarding this
01:45:08 <bitonic> but I’m pretty sure there are other ways
01:45:31 <bitonic> bshields: it might be useful to understand how GHC actually checks for fundeps instances: <http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html#flexible-instance-head>
01:46:06 <bshields> bitonic: thanks for that link
01:47:48 <bitonic> actually the bug I remembered is related but not fully relevant here: <http://hackage.haskell.org/trac/ghc/ticket/7100>.  still, I’m pretty sure you can construct something which doesn’t pass for which a function exists given the rules, exploiting the same kind of thing (there are functional dependencies on the type variables, but GHC won’t use them)
01:49:20 <bitonic> e.g. this fails the coverage condition:
01:49:21 <bitonic> class Foo a b | a -> b
01:49:21 <bitonic> class Bar a b | a -> b
01:49:21 <bitonic> instance Foo a b => Bar a (b, b)
01:49:51 <dmwit> Nice example, thanks.
01:49:56 <bshields> bitonic:  I have UndecidableInstances though, doesn't that mean it doesn't care about the coverage condition?
01:50:20 <bitonic> bshields: it does, yes, I didn’t look at your example
01:50:53 * hackagebot shake 0.3.5 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.5 (NeilMitchell)
01:51:17 <bitonic> bshields: your case is different: the two instances work alone but not together
01:51:50 <dmwit> bshields: bitonic is giving an example showing that GHC is too conservative, but even if GHC were perfect it would still have to reject your instance.
01:52:14 <dmwit> The condition should never be relaxed so far that a claimed functional dependency is violated, and your two instances do that.
01:52:22 <bshields> bitonic: I still don't understand how Test x x x and Text x y (x,y) conflict
01:52:49 <dmwit> bshields: No function can take "x" and "x" and produce as output both "x" and "(x, x)", as those two instances would demand.
01:53:03 <bitonic> bshields: you have two universally quantified things (`x' on one side and `x' and `y' on the other) that produce different things
01:53:08 <dmwit> Functions only have one output.
01:53:26 <bitonic> yeah, that’s not good :)
01:53:44 <bshields> ok but Test x x x and Test x y y is ok because?
01:53:56 <bitonic> because they are the same thing
01:53:56 <bshields> oh i see
01:54:04 <bshields> if x ~ y they resolve to the same
01:54:05 <bitonic> well not really the same thing, but the result is the same
01:54:32 <dmwit> Because the function which takes "x" and "y" and outputs "y" also happens to take "x" and "x" and output "x". =)
01:54:56 <bitonic> bshields: functional dependencies are an hack anyway.  use type/data families
01:55:11 <bitonic> the only advantage is that they’re less verbose
01:55:31 <bshields> bitonic:  I've been doing that and only started looking at fundeps because I ran into a whall with type/data families
01:55:43 <bitonic> bshields: you’ll run into the same walls with fundeps
01:55:45 <bshields> sounds like you're saying that type / data families are strictly more powerfoll though?
01:55:48 <dmwit> bitonic: So, I'd point out that it isn't the functional dependencies extension that's rejecting your proposed "GHC is too conservative" example.
01:56:31 <bitonic> dmwit: here it says that the coverage condition fails.
01:56:34 <bitonic> (for my example)
01:56:48 <bitonic> which shows my point
01:57:08 <superkaas> can I ask a basic question on function type declaration?
01:57:09 <dmwit> bshields: Actually, as currently implemented, functional dependencies can do a few things type families can't (but not vice versa). There's nothing fundamental about that, though: it seems likely that it's possible to give type families the same powers functional dependencies have regarding guiding type resolution.
01:57:23 <dmwit> bitonic: The coverage condition isn't part of FunDeps, though, it's part of MPTCs.
01:57:26 <tdammers> superkaas: sure, why not?
01:57:48 <bshields> That's what I was hoping because it seems that I have more power for handling overlapping instances using classes / fundeps than with type / data families
01:57:48 <bitonic> dmwit: ah, OK.  still, my point stands
01:57:54 <dmwit> bitonic: No, it doesn't.
01:57:57 <bitonic> dmwit: why?
01:58:26 <bitonic> there clearly is a function between `a' and `(b, b)' there, in your terms
01:58:37 <dmwit> bitonic: Your point was that GHC sometimes rejects instances that are functions. That's not yet shown to be true (with appropriate extensions), though it may reject things which are infinite functions (again without appropriate extensions).
01:59:24 <bitonic> dmwit: 1) what do you mean by “infinite function” and 2) is my example an “infinite function”?
01:59:42 <dmwit> Yes, that was imprecise. Let me rephrase.
02:00:09 <dmwit> It may reject functions whose computational component isn't obviously terminating (without appropriate extensions).
02:00:34 <dmwit> Termination analysis is Hard with a capital Halting Problem.
02:01:34 <superkaas> I'm fairly new to the language, but I have a reasonable mathematical background, and I'm trying to get the concepts of type declaration clear to me... as an exercise for myself, I'm trying to construct a function that will give me a list of the prime divisors of a number. In order to do this, I first create a list of 'candidates', which contains all integers smaller than the square root of n. In order to do this, I have to compute
02:01:52 <superkaas> integer n. However, I can't figure out the correct way to declare the type of this function
02:02:07 <dmwit> ?hpaste the code you tried
02:02:07 <lambdabot> Haskell pastebin: http://hpaste.org/
02:02:14 <bitonic> dmwit: so you’re saying that under the open world assumption that function of mine might not terminate, so it is consistent behaviour for GHC to require UndecidableInstances for it?
02:02:21 <superkaas> so: rsq n = round (sqrt n)
02:02:41 <beaky> what is the difference between then haskell Functor and the CT functor?
02:02:43 <dmwit> Oh, no. It may be possible to show that it always terminates; I haven't thought hard about that.
02:03:05 <bitonic> dmwit: actually I don’t see why that is the case - I am using a specific type class - `Foo'.  I don’t see what the problem is
02:03:06 <tdammers> superkaas: and what exactly is wrong with that function?
02:03:06 <dmwit> However, it's not *obvious* that it terminates, where I hereby define "obvious" to mean "passes GHC's simple termination checker". ;-)
02:03:25 <bitonic> I think you’re revising the notion of “function” heavily now
02:03:30 <dmwit> Am I?
02:03:38 <superkaas> the function is perfectly fine, but to make everything rigorous for myself and make sure I understand the type system, I wanted to explicitly write down the type declaration for this function
02:03:42 <bitonic> the point i wanted to make to bshields is that it’s not as obvious as you made it look
02:03:49 <edwardk> beaky; haskell functors are limited to being functors from the category of haskell types to the category of haskell types. the arrows in that category are functions. it takes any function in haskell to a function in haskell
02:03:55 <bitonic> and in my case, everything is in scope and obviously terminating
02:03:58 <tdammers> superkaas: ghci can do that for you, you know
02:03:59 <edwardk> :t fmap
02:04:00 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:04:12 <edwardk> you can view that as taking a function (a -> b)   to a function (f a -> f b)
02:04:14 <tdammers> :t \n -> round (sqrt n)
02:04:15 <lambdabot> (Floating a, Integral b, RealFrac a) => a -> b
02:04:19 <dmwit> bitonic: I really don't think it is obviously terminating. The coverage condition is there for a reason.
02:04:44 <beaky> ah
02:04:48 <merijn> tdammers: If he wants to understand he might not want to have ghci tell him the answer, though
02:04:48 <edwardk> beaky: there are other functors out in CT that don't fit this mold, but its a pretty good subset of the ones we care about in haskell ;)
02:05:03 <dmwit> bitonic: Well, we could argue all day about whether it's obviously terminating or not, I guess.
02:05:04 <tdammers> merijn: point taken
02:05:10 <merijn> superkaas: Did you paste the code + your current attempt at a type somewhere? (hpaste.org for example)
02:05:10 <superkaas> yeah that's why, actually
02:05:11 <beaky> right, since Haskell is a purely functional programming language where everything is a function
02:05:11 <bitonic> dmwit: the coverage condition is there becase it is a very simple syntactic rule that guarantees you that there is a function between the two sides of the fundeps
02:05:25 <merijn> superkaas: plus any relevant errors, of course
02:05:28 <bitonic> dmwit: but I think it’s hardly the most general condition
02:05:34 <merijn> beaky: heh, not everything is a function
02:05:36 <bitonic> (I’m not saying that’s a bad thing)
02:05:45 <merijn> beaky: Hell, there's tons of things that aren't functions in haskell...
02:06:03 <edwardk> beaky: to be a valid Functor, you must satisfy two laws you can derive from the CT definition which is 'fmap id = id' and 'fmap f . fmap g = fmap (f . g)'    -- the second actually follows from the first in haskell, and 'fmap id = id' says that your fmap shouldn't do anything hinky to the structure while remapping the elements.
02:06:27 <edwardk> beaky: the latter, which is a consequence of the first and something called a free theorem tells you that you can 'fuse together passes' over the structure.
02:06:29 <dmwit> bitonic: Anyway, my point is that the "functional"-ness analysis of GHC is correct; it's the "terminating"-ness check of GHC that's incomplete. I claim that if there's really a functional dependency, you can get GHC to accept the instances that define that function. This claim might not be true, but your example isn't a counterexample.
02:06:39 <beaky> ah
02:06:48 <superkaas> the way I saw it from a mathematical standpoint, was that it should be a function that maps an integer to an integer, since I'm only interested in those. As such, rsq :: (Integral a) => a -> a
02:07:00 <superkaas> or should I hpaste these?
02:07:12 <bitonic> dmwit: but there is a functional dependency in my example!  you have `a -> b', you can definitely get `a -> (b,b)'
02:07:18 <merijn> superkaas: hpasting the entire code + type + error is easiest, yeah
02:07:19 <edwardk> this is a pretty powerful reasoning tool, because you can shuffle around your code, and if you ever wind up with map foo (map bar x)   you can turn it into map (foo . bar) x
02:07:31 <tdammers> ah, but you can't take the sqrt of an Integral value directly
02:07:50 <dmwit> bitonic: Right, and GHC accepts it once you ask for it to stop doing its termination analysis!
02:07:56 <edwardk> this means you may construct fewer temporary structures, and life generally gets better and faster ;)
02:08:04 <tdammers> that's why ghc says that the input parameter has to satisfy Floating and RealFrac
02:08:07 <bitonic> dmwit: but you don’t need any termination analysis here
02:08:18 <dmwit> You always need termination analysis. =)
02:08:33 <dmwit> Or rather, you always *get* termination analysis, unless you explicitly ask not to.
02:08:41 <bitonic> sorry, I meant that that is clearly terminating
02:08:48 <dmwit> GHC doesn't agree.
02:09:01 <dmwit> (Its definition of "clearly terminating" is stricter than yours.)
02:09:14 <bitonic> no, GHC says that the coverage condition fails, which is a different thing
02:09:22 <bitonic> it subsumes termination
02:09:24 <hpaste> superkaas pasted “type declaration error” at http://hpaste.org/78349
02:09:25 <bitonic> but it’s much stronger
02:09:51 <dmwit> Yes. All sound, terminating termination analyses are stronger than termination.
02:09:52 <merijn> superkaas: Ah, yeah. tdammers is right
02:09:56 <merijn> :t sqrt
02:09:58 <lambdabot> Floating a => a -> a
02:10:05 <tdammers> :t round
02:10:06 <lambdabot> (Integral b, RealFrac a) => a -> b
02:10:07 <dmwit> That is the halting problem summed up.
02:10:09 <bitonic> dmwit: well, my original point is that you can have a looser condition
02:10:11 <superkaas> I know I'm probably not grasping the lines of haskell thinking yet, but that's what I'm trying to accomplish ;-)
02:10:15 <merijn> superkaas: sqrt expects a float, you probably want fromIntegral
02:10:27 <merijn> @quote fromIntegral
02:10:27 <lambdabot> lilac says: <drdozer> gha! I'm drowning in the haskell number hierarchy again <lilac> drdozer: magic 8-ball says 'add calls to fromIntegral'
02:10:31 <dmwit> bitonic: You can have a looser termination condition, yes. But GHC's functional-ness condition is already loose enough.
02:10:33 <merijn> ah, bah
02:10:35 <merijn> Wrong quote
02:10:37 <merijn> Anyhoo
02:11:03 <merijn> @quote who.do.you.call
02:11:03 <lambdabot> monochrom says: You've got an Int / But you want Double / Who do you call? / "fromIntegral!"
02:11:17 <tdammers> :D
02:11:19 <bitonic> dmwit: OK so the disagreement here is that I consider coverage condition part of the “functional-ness”, you don’t.
02:11:23 <cmears> @type round . sqrt . fromIntegral
02:11:24 <lambdabot> (Integral a, Integral b) => a -> b
02:11:35 <bitonic> dmwit: “The Coverage Condition. For each functional dependency, tvsleft -> tvsright, of the class, every type variable in S(tvsright) must appear in S(tvsleft), where S is the substitution mapping each type variable in the class declaration to the corresponding type in the instance declaration.”.  to me that’s very relevant to the “functional-ness” :P
02:12:05 <superkaas> wow, it actually worked
02:12:18 <dmwit> When you turn off the coverage condition, you're still banned from writing things that aren't functions.
02:12:26 <dmwit> So how is it part of the function-ness check?
02:12:32 <merijn> superkaas: Anyhoo, you're not missing any crucial Haskell insight, it's just that for practical reasons some operations like sqrt are "stricter" on their input type than people expect (i.e. they only accept the same input as their output, which restricts them to Floating)
02:13:09 <superkaas> and if I don't use type declaration, it automatically works, so that means that haskell works it out on its own?
02:13:21 <bitonic> dmwit: you mean if you do what bshields did?
02:13:35 <cmears> superkaas: it would have computed a different type (one that depends on RealFrac)
02:13:40 <dmwit> bitonic: Hell, the very next sentence in the manual is, "These restrictions ensure that context reduction terminates.".
02:13:43 <merijn> superkaas: Well, without the type signature GHC infers the type "rsq :: (Floating a) => a -> a"
02:13:47 <tdammers> if you don't use type declaration, you get the widest possible set of constraints on your type variables
02:13:48 <cmears> @type round . sqrt
02:13:50 <lambdabot> (Floating a, Integral b, RealFrac a) => a -> b
02:13:58 <merijn> Actually, no. Not even that
02:14:06 <dmwit> bitonic: Yes, bshields' code is still rejected even without the coverage condition.
02:14:20 <bitonic> dmwit: well, the coverage condition is *part* of checking functional-ness, but not all there is to it
02:14:29 <tdammers> but as long as you feed it types that match those, nothing bad happens
02:14:42 <dmwit> bitonic: No, that's not accurate.
02:14:43 <dmwit> Really.
02:14:56 <merijn> superkaas: Your code has a completely valid interpretation as something taking a Floating and returning an Integral. That would mean it doesn't accept Integral as input (which you intended), though
02:14:58 <superkaas> so for clarity, the fact that 'a' appears twice, once as Floating and once as RealFrac, does that mean that it can take both as input?;
02:15:03 <dmwit> The coverage condition is about something completely different than whether the instances define a function or not.
02:15:15 <merijn> superkaas: No, it means that a has to be *both* Floating and RealFrac
02:15:23 <superkaas> right
02:15:43 <merijn> superkaas: Do you know what unification is?
02:16:33 <bitonic> dmwit: whatever - my original goal was simply to make bshields aware of those subtleties.  the coverage/paterson are the source of quirks in fundeps and I wanted to point that out.  whether they define or not the “function-ness” is mostly a terminology argument, for what concerns me.
02:16:39 <merijn> (If no, ignore I said anything)
02:17:05 <bitonic> I think that rejecting `a -> (b,b)' given `a -> b' shapes what a function is in that context
02:17:30 <superkaas> no, but I can look it up ;)
02:17:39 <dmwit> GHC can be made not to reject that. GHC cannot be made not to reject bshields' code.
02:17:47 <dmwit> That's a very fundamental difference.
02:18:37 <merijn> superkaas: Basically GHC just tries to find values for a and b such that all the constraints on the left of => are met, if it doesn't succeed it will complain
02:18:41 <bitonic> dmwit: I don’t see how that proves anything.  GHC could be made to accept what bshields wrote
02:18:53 <dmwit> eh? how?
02:19:18 <bitonic> I don’t know, just pick one of the two or whatever.
02:19:29 <merijn> superkaas: If you don't explicitly provide a type and GHC manages to construct a valid type (that is perhaps more restrictive than you intended) it will succeed but confuse you later when you try to apply the function and the inferred type/constraints turn out to be different from what you thought.
02:19:30 <dmwit> Perhaps "made" was the wrong verb. I'm not talking about hacking GHC to change it's behavior.
02:19:42 <superkaas> right
02:19:50 <dmwit> I'm talking about right now, today, with GHC 7.6 as released, I can write the instances you asked for and have GHC compile them.
02:20:52 <bitonic> dmwit: still, I don’t see how it proves anything about the nature of functions in that context.  your explanation was misleading because you presented those functions informally, and most people would think that my definition would conform to your informal description
02:21:50 <dmwit> Right, the difference between functions and computable functions is definitely subtle. And the fact that you have to prod GHC a bit more than usual to get it to accept functions that aren't computable (and even some that are computable but for subtle reasons) is a fine point.
02:23:25 <bitonic> anyway, gotta study :P
02:23:32 <bitonic> better turn off IRC
02:23:41 <dmwit> see ya
02:23:44 <bitonic> bye
02:28:02 <superkaas> awesome, I'm starting to grasp it :-) thanks!
02:54:54 <mm_freak> i need floating point numbers where i can choose the precision…  is there something like that?
02:55:15 <mm_freak> Double is not precise enough
02:57:39 <mm_freak> ok, i solved it differently using logarithm representation
02:57:42 <mm_freak> nevermind
02:58:08 <atriq> How do I get Cabal to hscolour things so I get the link on the haddock page and stuff?
02:58:09 <xunatai> you could use Rational
02:58:35 <xunatai> uses two Integers, and since Integer is arbitrary precision, then Rational is arbitrary precision as well
02:58:49 <mm_freak> xunatai: i need Floating
02:59:06 <xunatai> why exactly
02:59:20 <mm_freak> because i need logarithms
02:59:41 <ocharles> jaspervdj: ping
02:59:43 <mm_freak> the range of Rational is either exceeded quickly or takes a lot of memory
02:59:52 <ocharles> jaspervdj: actually, pong me in #snapframework :)
03:00:30 <mm_freak> xunatai: in other words Rational doesn't work well for everything =)
03:08:16 <[mth]> Is there a work around available for compiling packages on 7.6.1 that fail with Paths_*: Not in scope: `catch'?
03:08:44 <[mth]> Of for that matter should these be failing to compile, HTTP-4000.2.6 is an example.
03:09:32 <typoclass> [mth]: i bet that's related to Control.OldException being removed. i think you usually only need to change some imports
03:10:05 <typoclass> [mth]: oh, Paths_* is stuff generated by cabal isn't it? are you sure you have a current cabal version?
03:10:31 <[mth]> typoclass: Yes it looks like that is the change that breaks it. I am actually trying to `cabal install cabal-install`
03:10:49 <[mth]> Will try download a binary of latest cabal install to see if that helps.
03:16:55 <[mth]> typoclass: Thanks. got it. Switch back to 7.4, `cabal install cabal-install`, then switch to 7.6 and everything is good.
03:18:51 <typoclass> [mth]: oh, that seems like a lot of trouble for something that you'd hope was straightforward
03:19:05 <typoclass> [mth]: but anyway, as long as you got it to work eventually :-)
03:19:10 <beaky> :D
03:20:34 <[mth]> Partially my fault. I was 2 versions of cabal install behind. Looks like it should of worked if I was up to date before hand. But yeh.
03:22:57 <killy9999> is there a cumulative sum function in Prelude?
03:23:16 <mauke> did you mean: scanl
03:23:33 <killy9999> mauke: I think yes
03:23:56 <Ferdirand> @type scanl
03:23:57 <lambdabot> (a -> b -> a) -> a -> [b] -> [a]
03:24:10 <Ferdirand> what's the origin of the name "scanl" ?
03:25:23 <atriq> It scans the list leftwards, I think
03:25:40 <killy9999> not the list
03:25:46 <killy9999> fold accumulator
03:25:53 <Ferdirand> well for some definition of scan
03:30:55 * hackagebot dawg 0.8 - Directed acyclic word graphs  http://hackage.haskell.org/package/dawg-0.8 (JakubWaszczuk)
03:44:19 <atriq> Cabal isn't using HsColour, how can I fix this?
03:44:47 <donri> "using"?
03:45:19 <donri> are you looking for --haddock-hyperlink-source?
03:45:29 <atriq> Possibly
03:46:54 <atriq> I want there to be a "Source" link in the haddock docs
03:48:52 <donri> then yes
03:49:04 <atriq> So, what do I do?
03:53:17 <cmears> atriq: I think add --haddock-hyperlink-source to "cabal install"
03:54:21 <atriq> Can I make it automatic?
03:55:07 <atriq> (that works :) )
03:55:44 <johnw> atriq: see http://hackage.haskell.org/trac/hackage/ticket/941
03:55:47 <johnw> answer: not yet
03:55:55 * hackagebot hlint 1.8.36 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.36 (NeilMitchell)
03:55:59 <atriq> :(
03:56:13 <atriq> Thanks donri, cmears, and johnw
03:57:35 <atriq> Now to reinstall everything
03:58:02 <johnw> such is the way of things
04:00:04 <johnw> atriq: i'm doing the same now too :)
04:00:22 <atriq> :)
04:01:26 <cmears> Could you do: alias cabal="cabal --haddock-hyperlink-source" ?
04:01:46 <johnw> i have a "cabal" wrapper script
04:01:48 <johnw> it adds -j too
04:01:56 <johnw> (and only for the "install" subcommand)
04:05:01 <atriq> You use JHC?
04:11:49 <johnw> no, -j to cabal
04:11:55 <johnw> cabal install -j --haddock-hyperlink-source ...
04:13:06 <atriq> I assumed that would work like -g. What does it do?
04:17:12 <johnw> -j = parallel dependency builds
04:17:17 <johnw> in the newer cabal-install (1.16)
04:26:47 <johnw> yay, source links everywhere
04:26:51 <johnw> thanks for pointing that out
04:30:45 <atriq> edwardk, crazy and not very important idea
04:31:31 <atriq> That ultimately is pointless because Haddock doesn't allow arbitray html
04:32:41 <atriq> ...I'll shut up
04:40:56 * hackagebot uhc-util 0.1.0.0 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.0.0 (AtzeDijkstra)
05:09:44 <Philonous> I wonder what the point of a strong monad is. Doesn't (\x m -> m >>= \y -> (x, y) ) implement the appropriate natural transformation for _any_ monad?
05:11:08 <Philonous> Is there a good book on counterexamples in category theory?
05:14:11 <`nand`> (Haskell monads are all strong, no?)
05:14:52 <`nand`> all Haskell Functors are strong functors as well iirc
05:16:24 <Philonous> `nand`:  Ah, well, that would explain it.
05:16:27 <hpc> :t (\x m -> m >>= \y -> (x, y) )
05:16:28 <lambdabot> Monad ((,) t) => t -> (t, b) -> (t, b)
05:17:01 <Philonous> :t liftM . (,)
05:17:02 <lambdabot> Monad m => a -> m a1 -> m (a, a1)
05:17:35 <Philonous> hpc:  I forgot the return before the pair
05:17:36 <`nand`> :t uncurry (fmap . (,))
05:17:38 <lambdabot> Functor f => (a, f a1) -> f (a, a1)
05:18:20 <Eduard_Munteanu> I think they're not strong with respect to arbitrary tensor products though.
05:18:25 <mauke> @djinn (Functor f) => (a, f a1) -> f (a, a1)
05:18:25 <lambdabot> Error: Class not found: Functor
05:18:29 <Eduard_Munteanu> (which is why you have Traversable)
05:18:30 <mauke> oic
05:21:23 <Eduard_Munteanu> :t Data.Traversable.sequence
05:21:24 <lambdabot> (Monad m, Traversable t) => t (m a) -> m (t a)
05:21:34 <`nand`> :t Data.Traversable.sequenceA
05:21:35 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
05:25:58 * hackagebot unix-time 0.1.3 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.3 (KazuYamamoto)
05:33:16 <`nand`> what would be the simplest way to define some peekChar :: IO (Maybe Char) that returns a character if available or Nothing otherwise?
05:34:21 <shachaf> Why do you want such a thing?
05:34:25 <shachaf> What does "available" mean?
05:35:04 <mauke> what's a character?
05:35:10 <mm_freak> `nand`: peekChar exists, but the type is very different from what you would expect
05:35:14 <`nand`> “define ‘define’”
05:35:41 <mm_freak> most notably it's not in IO, but rather in one of Parser, Pipe, Iteratee or something similar
05:35:44 <mauke> `nand`: "explain what the fuck you're talking about"
05:37:56 <Eduard_Munteanu> `nand`: if you're reading from e.g. stdin, the input should contain proper message boundaries. Generally you can't really decide if there's more data or not.
05:39:17 <parcs`> would hGetBufNonBlocking work? or timeout/getChar?
05:39:36 <Eduard_Munteanu> Uh, don't do that.
05:39:41 <mm_freak> parcs`: yes, but no
05:39:53 <`nand`> ah, what's wrong with hGetBufNonBlocking? That's what I was about to use
05:39:54 <parcs`> or hWaitForInput
05:40:16 <mauke> <shachaf> Why do you want such a thing?
05:40:22 <mm_freak> `nand`: you're bastardizing IO for stream processing…  use a proper stream processing abstraction
05:40:30 <Eduard_Munteanu> `nand`: it's timing and buffering-sensitive, just don't do it.
05:40:32 <mm_freak> IO can't process streams…  don't force it to
05:40:37 <parcs`> i don't see how stream processing would help
05:41:05 <typoclass> `nand`: not sure what you're trying, but i think the more haskellish way might be to fork a thread that just blocks infinitely, and do whatever other things on the first thread
05:41:10 <Eduard_Munteanu> Generally, expect it to work like TCP.
05:41:13 <parcs`> in the end something will need to call hGetBufNonBlocking or whatever
05:41:45 <mm_freak> parcs`: "don't use a fork to eat soup, use a spoon, because it's soup" — "i don't see how soup would help"
05:43:04 <parcs`> i still don't understand
05:43:08 <mm_freak> a stream processing abstraction basically does what typoclass suggests, but with coroutines instead of threads, and with a sane underlying model
05:43:42 <mm_freak> if you want to decide how to proceed depending on what the next character is, you're doing not only stream processing, but actually parsing
05:44:14 <mm_freak> in other words: if you read a character, you never need to put it back
05:45:55 <randomclown> I just finished a group theory couse. Anything else I need to tackle categories?
05:47:29 <johnw> just start the reading, man!
05:48:01 <`nand`> so would forking off a thread that blocks on getChar forever and snocs it to an MVar (Seq Char) or something be a better solution?
05:48:14 <`nand`> (then defining the IO (Maybe Char) in terms of that)
05:48:17 <shachaf> That depends on the problem.
05:48:49 <mauke> <mauke> <shachaf> Why do you want such a thing?
05:50:41 <`nand`> let me demonstrate a simple use case: I have a terminal application that prints "Hello, world!" to STDOUT every 100ms. This process should be pausable and resumable by pressing any key - the idea would be to use IO (Maybe Char) to determine if a key was pressed since the last invocation; without blocking
05:51:32 <typoclass> `nand`: i'd still recomment a thread that prints things every 100 ms, and another that blocks for keypresses, communicating via an mvar
05:51:34 <mm_freak> `nand`: not snocing to MVar (Seq Char), but simply putting to an MVar Char
05:52:09 <parcs`> `nand`: ncurses can help you with that, but it's probably overkill
05:52:40 <mm_freak> `nand`: but your problem doesn't even sound like you want any of that
05:52:43 <`nand`> mm_freak: what if I change the requirements to only pause/unpause if the key ‘p’ was pressed? All other keys are ignored; so pressing ‘xpy’ between an interval would still toggle it
05:52:45 <mm_freak> it sounds like you want FRP
05:52:58 <`nand`> mm_freak: FRP is what I want, yes
05:53:13 <`nand`> mm_freak: I was thinking of defining a Wire that either inhibits or produces a Char in terms of peekChar :: IO (Maybe Char)
05:54:08 <mm_freak> `nand`: i see…  this should probably be controlled outside of the application wire
05:54:19 <mm_freak> type MyWire = WireP
05:54:23 <mm_freak> uhm, no
05:54:33 <mm_freak> type MyWire = WireM ((->) Event)
05:55:05 <mm_freak> your Event type could look like this:  data Event = KeyEvent Char | TimerEvent
05:55:07 <`nand`> and then feed Events using some external ‘driver’ for the wire?
05:55:32 <mm_freak> have two secondary threads, one for the timer, one for the key presses (or use vty!)
05:55:57 <mm_freak> the main thread uses STM to read from them…  whatever is reported next is put into an Event and the wire is stepped
05:56:40 <mm_freak> by the way i have a netwire-vty project going on, but it's early alpha
05:56:48 <`nand`> that sounds interesting
05:56:48 <mSSM> How do you suggest should I use cabal-dev to install packages like xmonad and pandoc? Should I for example create a directory .cabal-dev/, build those packages there, and make a symlink in $HOME/.bin to the binaries?
05:57:30 <mm_freak> mSSM: if possible, use your distribution…  otherwise personally i install stuff like that through regular cabal
05:57:32 <`nand`> I should perhaps note that I'm not actually thinking of any concrete use case here; ie. I'm not trying to solve some inherent problem, just thinking about how I would solve it if I did need something like that
05:58:00 <mSSM> mm_freak: I don't want to use my distribution to manage that.
05:58:19 <mm_freak> `nand`: you run into this problem when you use vty like i do…  there is no peekEvent in vty (like in SDL), only a blocking event getter
05:58:26 <mSSM> mm_freak: And I want to use cabal-dev because there seem to be a lot of dependencies which clash. Therefore, cabal-dev.
05:58:38 <mm_freak> `nand`: the only solution there is to use concurrency…  STM makes this fairly easy
05:59:31 <mm_freak> mSSM: for a long time i have pandoc and xmonad and a lot of other packages installed through cabal at the same time…  haven't run into problems there, but if you want to use cabal-dev symlinking is probably your best bet
06:00:06 <`nand`> (wait a minute, how would you even define a timer using STM?)
06:00:10 <parcs`> mSSM: pandoc is a stand alone application and you should install it through your distribution
06:00:21 <mm_freak> `nand`: registerDelay is an example
06:00:29 <ocharles> ivan: are you Ivan Miljenovic?
06:00:54 <`nand`> mm_freak: oh, so the thread lives in IO, but writes to a TVar with atomically; that makes sense
06:00:58 * hackagebot conduit 0.5.5 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.5.5 (MichaelSnoyman)
06:01:03 <parcs`> mSSM: xmonad is special because it depends on haskell libraries so that it could recompile itself on the fly. i would locally install xmonad in ~/.cabal because it doesn't have too many dependencies to require sandboxing
06:01:55 <mm_freak> `nand`: it /has to/ live in IO
06:02:08 <mm_freak> otherwise no timer event would ever be fired =)
06:04:26 <mSSM> parcs`: well, even installing cabal-dev through cabal install gives me issues: template-haskell-2.8.0.0 (reinstall) changes: containers-0.5.0.0 -> 0.4.2.1
06:04:46 <mSSM> parcs`: and this on a fresh .cabal/ folder
06:05:26 <geekosaur> cabal is being dumb.  (it should never, ever even consider reinstalling template-haskell; it's wired into the compiler, reinstall = break completely)
06:05:56 <mSSM> geekosaur: so what am I supposed to do?
06:08:26 <geekosaur> you can try installing cabal-dev from its giyt repo (this is necessay if you're using ghc 7.6; there is no released version of cabal-dev compatible with it).  apparently you can otherwise get cabal-install to be less stupid by listing the installed versions of libraries as explicit constraints
06:08:43 <mSSM> geekosaur: I do indeed use ghc 7.6
06:20:13 <mm_freak> inferior-haskell doesn't seem to work well with cabalized packages
06:21:00 <mm_freak> (in fact it doesn't seem to use the cabal file at all)
06:23:12 <hpaste> nand` pasted “STM-based events” at http://hpaste.org/78353
06:23:19 <`nand`> this seems to work nicely
06:24:53 <mm_freak> `nand`: i'd recommend TMVar over TQueue
06:25:17 <mm_freak> unless you expect event congestion to be non-exceptional
06:25:24 <`nand`> oh
06:25:27 <`nand`> good point, yes
06:26:09 <mm_freak> also don't forget to compile your program with -threaded, even if you don't intend to use multiple OS threads
06:26:45 <mm_freak> without -threaded you will encounter some weird lockups and other artefacts when using FFI or some RTS features like threadDelay (and registerDelay)
06:27:26 <hpaste> “`nand`” annotated “STM-based events” with “STM-based events (annotation)” at http://hpaste.org/78353#a78354
06:27:46 <statusfailed> When using Control.Lens.Zoom.zoom, do m and n have to both be in the monad stack? (I hope this question makes sense...)
06:27:54 <mSSM> Different question: do you recommend using ghc 7.6 at all, or should I stick to 7.4 for now?
06:28:05 <mm_freak> `nand`: that looks close to how i would do it =)
06:28:10 <`nand`> some libraries are still incompatible with GHC 7.6
06:28:16 <`nand`> on the other hand, some require it
06:28:29 <`nand`> in general, if you want to do advanced type trickery (type families, data kinds, etc.) it's recommended
06:29:03 <mm_freak> mSSM: in my experience GHC 7.6 is fine except for agda, gloss, gtk and snaplet-postgresql-simple
06:29:09 <`nand`> lambdabot
06:29:17 <mm_freak> other packages may file, but those are the ones i was using
06:29:41 <mm_freak> file → fail
06:30:01 <mm_freak> not having gloss proved to be annoying sometimes
06:31:23 <`nand`> gloss works for me, actually
06:31:29 <`nand`> you just need the latest version
06:31:47 <hpaste> “Ertugrul Söylemez” pasted “World file that works with GHC 7.6” at http://hpaste.org/78355
06:32:03 <mm_freak> that's my world file (yes, i'm not using cabal-dev)
06:32:19 <fmap> gtk should work with 7.6 too
06:32:20 <mm_freak> `nand`: oh thanks, time for an upgrade
06:37:10 <Philonous> Did they fix the bytestring bug in 7.6.1?
06:38:07 <hpaste> neutrino pasted “how can i besser do this?” at http://hpaste.org/78356
06:38:22 <neutrino_> any tips on doing this better?
06:38:34 <neutrino_> and wow, german is really getting to me isn't it
06:38:40 <neutrino_> i need to move out of here haha
06:39:36 <statusfailed> @pl Kleisli $ \_ -> modify (+1)
06:39:37 <lambdabot> Kleisli (const (modify (1 +)))
06:39:48 <Alex_M_I> Hello, everyone! Can I ask a noob question about using Haskell and oAuth?
06:39:51 <statusfailed> woops
06:40:01 <mm_freak> neutrino_: maybe (return []) (\p1 -> maybe (return [p1]) (\p2 -> …))
06:40:16 <mm_freak> spread over a few lines that looks quite nice
06:40:48 <neutrino_> mm_freak: i don't see a difference from what i posted
06:40:53 <mm_freak> neutrino_: another way is:  liftA2 (++) codeForP1 codeForP2
06:40:58 <Philonous> neutrino_:  Does that even compile? I mean with the commas in line 5
06:41:09 <mm_freak> neutrino_: ah no, that's different, forget it
06:41:23 <neutrino_> Philonous: no, it doesn't compile yet
06:41:53 <neutrino_> i keep putting commas everywhere, i'm translating this python program to haskell, it's a mindfuck
06:41:58 <mm_freak> neutrino_: you could use a proper ListT, but honestly it would be overkill
06:42:25 <mm_freak> anyway, using 'maybe' is always a good idea
06:42:58 <Alex_M_I> I plan to develop a client to Google webservices, which require oAuth 2.0, First google result is hoauth library, but it implements only oAuth 1.0 (or so the package description says) another library is yesod-oauth, but there's even fewer info. Did anybody here use any of them?
06:43:45 <neutrino_> mm_freak: i still don't see how your "maybe" works different than my case
06:44:04 <mm_freak> neutrino_: you don't want it to work differently
06:44:13 <neutrino_> then how is it an improvement?
06:44:24 <neutrino_> the idea was to do it better, not the same just in lisp :)
06:44:25 <mm_freak> neutrino_: it uses a Maybe fold instead of pattern matching
06:44:33 <mm_freak> folding is always better than matching
06:44:43 <neutrino_> huh?
06:44:45 <neutrino_> why?
06:45:09 <mm_freak> neutrino_: it would bark at you if you missed something =)
06:45:22 <neutrino_> that's the whole point of static typing isn't it
06:45:23 <mm_freak> you haven't, so it doesn't bark and makes the impression to be the same thing
06:45:43 <pgiarrusso> mm_freak: is there no exhaustivity checking?
06:46:25 <mm_freak> you can turn on a compiler warning
06:46:32 <mm_freak> and another flag that turns warnings into errors
06:46:42 <mm_freak> -W turns it on
06:47:37 <pgiarrusso> OK, that's more reasonable
06:47:51 <mm_freak> of course exhaustivity checking is not sufficient for totality
06:48:20 <pgiarrusso> but then neither fold guarantees totality, does it?
06:48:26 <mm_freak> for Maybe the situation isn't that bad, but for [] you really should use foldr instead of matching/recursing
06:48:29 <pgiarrusso> it guarantees compositionality though
06:48:51 <mm_freak> foldr guarantees productive recursion, which is total, if you allow codata
06:49:15 <mm_freak> assuming that the implementation of foldr has no bugs
06:49:21 <pgiarrusso> we can assume that
06:49:33 <pgiarrusso> I was thinking of having nontermination in the data
06:49:48 <pgiarrusso> instead of foldr (+) 0 list
06:49:59 <pgiarrusso> you could have foldr undefined 0 list
06:50:11 <mm_freak> haskell cannot prevent that
06:50:34 <mm_freak> a language with termination checking would not allow 'undefined' in the first place
06:51:00 <pgiarrusso> I'm learning Agda, so I know what you mean :-)
06:51:19 <pgiarrusso> Anyway, that's why I said that fold can't guarantee totality
06:52:02 <mm_freak> if the arguments are fully defined (up to codata), then foldr is guaranteed to be productive
06:52:33 <pgiarrusso> can you distinguish codata and undefined? Of course you can (stupid question)
06:52:43 <pgiarrusso> and by "fully defined" you mean "no undefined in there"
06:52:59 <pgiarrusso> BTW, how's "productive" defined?
06:53:01 <mm_freak> well, actually i wonder if an infinite list is actually fully defined
06:53:15 <mm_freak> i think it is
06:53:24 <pgiarrusso> I'm thinking of "Total Functional Programming"
06:53:39 <pgiarrusso> there you have termination checking, codata and no undefined
06:54:04 <mm_freak> pgiarrusso: productivity is defined by the recursion scheme…  if your recursion is wrapped by a nonstrict constructor, then your recursion is productive (aka well-defined)
06:54:21 <mm_freak> that guarantees that pattern matching on the outermost constructor will always terminate
06:55:35 <mm_freak> foldr f z (x:xs) = f x (foldr f z xs)
06:56:13 <pgiarrusso> that satisfies the criterion if f is productive
06:56:17 <pgiarrusso> nice
06:56:51 <mm_freak> if f is nonstrict in its second argument
06:57:03 <pgiarrusso> indeed, sorry
06:57:10 <pgiarrusso> I was still thinking in terms of constructors
06:57:14 <mm_freak> of course it requires that either all list members are fully defined or that f is nonstrict in its first argument, too
06:57:18 <rwbarton> neutrino_: fwiw i don't see any reason to rewrite that code. it seems maximally clear as-is
06:58:04 <rwbarton> although i'm not sure it does what you meant, particularly as it obviously doesn't compile
06:58:19 <rwbarton> is all this supposed to be in the [] monad?
06:59:49 <ClaudiusMaximus> edwardk, copumpkin: is 'rounded' supposed to work?  i get bizarro nonsensical results in ghci with the 'ekmett/master' branch from github (after fixing the Setup.hs to mangle ...-0.1.a instead of ...-0.0.1.a)
07:00:05 <copumpkin> no
07:00:17 <pgiarrusso> rwbarton: apart from the commas,
07:00:22 <copumpkin> well, we'd love it if it did work
07:00:23 <ClaudiusMaximus> copumpkin: easily fixable?
07:00:26 <copumpkin> no
07:00:30 <copumpkin> it is fixable
07:00:30 <ClaudiusMaximus> aww, crap
07:00:36 <copumpkin> but it's a really obscure bug right now
07:00:37 <nathanel1> is there a way to query the current memory usage within my program (using GHC)?
07:00:47 <copumpkin> and we haven't figured out what's wrong yet
07:00:59 <pgiarrusso> :t projParts
07:00:59 <pgiarrusso> projParts :: Maybe (t1, Maybe t) -> [[t1]]
07:00:59 * hackagebot monad-logger 0.2.2 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.2.2 (MichaelSnoyman)
07:01:00 <lambdabot> Not in scope: `projParts'
07:01:02 <ClaudiusMaximus> it does seem obscure
07:01:18 <pgiarrusso> let projParts projAndRev = case projAndRev of {Nothing -> [];Just (proj, Nothing) -> return [proj]}
07:01:27 <ClaudiusMaximus> copumpkin: show on 4, 5, 6, 7 all return the same string here
07:01:44 <pgiarrusso> rwbarton: looks like that's the list monad, yes
07:02:02 <rwbarton> right, the question is: is it supposed to be :)
07:02:03 <neutrino_> rwbarton: my issue was with a smidge of code duplication between the case Just (p, Nothing) and Just (p, Just r)
07:02:34 <neutrino_> rwbarton: i'm keeping it as is, but i wanted to check if there's a better idea
07:02:49 <neutrino_> often there is
07:02:52 <neutrino_> :)
07:04:00 <pgiarrusso> you could separate the pattern match on the second part, couldn't you?
07:04:23 <pgiarrusso> Just (proj, rest) -> return [proj] ++ case rest of ...
07:05:14 <pgiarrusso> In fact, you're also repeating the fact that Nothing should not be dealt with
07:05:27 <beaky> hello
07:05:52 <neutrino_> what's a good analogue of python's subprocess.check_output?
07:06:50 <neutrino_> i.e. "get stdout of system command if it returned normally, raise exception if it returned non-zero"
07:06:51 <pgiarrusso> neutrino_: for your previous question, I'd consider something like fmap $ id (***) fmap (getFullRevid user proj)
07:07:01 <pgiarrusso> for this question I can't answer
07:07:10 <neutrino_> pgiarrusso: hmm, weird, i've never seen ***
07:07:16 <neutrino_> :t (***)
07:07:17 <lambdabot> Arrow a => a b c -> a b' c' -> a (b, b') (c, c')
07:07:29 <pgiarrusso> In this case, specialize the "a" to (->)
07:07:41 <neutrino_> yeah
07:07:45 <pgiarrusso> to get (b -> c) -> (b' -> c') -> (b, b') -> (c, c')
07:07:51 <mm_freak> do mp1 <- getProject; mp2 <- maybe (return Nothing) getRev mp1; return (catMaybes [p1, p2])
07:08:01 <neutrino_> so it takes a couple functions and makes a function from a couple to a couple
07:08:06 <pgiarrusso> yep
07:08:31 <pgiarrusso> What I wrote won't do the same as your function, because it returns Nothing instead of []
07:08:31 <mm_freak> s/p1, p2/mp1, mp2/
07:08:43 <mm_freak> that's a nice flat solution
07:08:56 <pgiarrusso> (Just proj, Nothing) instead of return [proj]
07:09:02 <neutrino_> mm_freak: there's no getProject though
07:09:20 <mm_freak> neutrino_: yes, in your case it starts at "mp2 <-"
07:09:25 <mm_freak> since mp1 is already given
07:09:35 <neutrino_> mm_freak: no idea what you mean
07:09:55 <neutrino_> i'm having a hard time following sorry :)
07:09:56 <beaky> in what cases are higher-order functions a necessity/
07:10:05 <neutrino_> in most cases
07:10:10 <pgiarrusso> mp1 is similar to projAndRev
07:10:15 <beaky> I wanna convince my m8s that functional programming is superior to OOP in certain cases
07:10:17 <neutrino_> in what cases are hands a necessity? you can do everything with feet
07:10:28 <Chousuke> wouldn't that depend on the definition of necessity?
07:10:28 <neutrino_> it's not
07:10:29 <neutrino_> get over it
07:10:35 <neutrino_> OOP is closer to the metal
07:10:42 <edwardk> ClaudiusMaximus: we used to have it working except for ghci now its pretty borked for both ghc and ghci
07:10:45 <neutrino_> </trollface>
07:10:50 <mm_freak> do mRev <- maybe (return Nothing) getRev mProj; return (catMaybes [mProj, mRev])
07:11:14 <ClaudiusMaximus> edwardk: aww :(
07:11:15 <pgiarrusso> beaky: you know the Strategy and the Template method pattern? Those are fancy ways of using higher-order functions
07:11:37 <mm_freak> beaky: functional vs. OOP is a red herring…  it's pure composition vs. encapsulated state
07:11:54 <Chousuke> how about visitors?
07:11:59 <beaky> ah
07:12:30 <pgiarrusso> beaky: I can elaborate if desired
07:12:36 <neutrino_> mm_freak: i don't think that code would compile
07:12:38 <edwardk> ClaudiusMaximus: well, the current approach will get us to better support for both in the long term
07:12:43 <mm_freak> beaky: there are a lot of merits to identifying things as monoids/categories and then using composition…  for example it allows you to focus and understand code without understanding the whole project first
07:12:46 <beaky> my mates don't know the strategy pattern though
07:12:58 <mm_freak> neutrino_: why not?
07:13:12 <ClaudiusMaximus> edwardk: i hope so!  i'm thinking of crazy things at the moment like compiling numerical algorithms to C and getting a separate process to dlopen them...
07:13:17 <neutrino_> mm_freak: look at it :)
07:13:30 <pgiarrusso> beaky: hmm… do they know the concept of abstraction?
07:13:38 <neutrino_> beaky: why not just show them all the cool stuff you can do with haskell and can't do with most other languages?
07:13:53 <Chousuke> beaky: try to keep it simple, though. If you go off about monads and such chances are they will just see apparent complexity for little benefit.
07:13:54 <neutrino_> such as parsers, strong type inference, etc
07:14:24 <pgiarrusso> You might want to have them write some instantiations of map and then look at map itself
07:14:24 <rwbarton> I am becoming increasingly convinced of my suggestion not to rewrite the original code
07:14:28 <pgiarrusso> or things like that
07:14:33 <edwardk> ClaudiusMaximus: keep in mind that, yeah, you have to do it in another process
07:14:42 <mm_freak> beaky: functional programming is all about localization and isolation…  it's about the ability to focus on the task, not on the surroundings
07:14:44 <beaky> neutrino_: that's what I did and they said "wow that language looks like Java"
07:15:16 <neutrino_> they probably saw the type operator (::) and thought it's a class function call
07:15:21 <beaky> right
07:15:25 <neutrino_> or something stupid like that
07:15:25 <pgiarrusso> neutrino_: that's not in Java
07:15:31 <neutrino_> oh that's php isn't it
07:15:34 <beaky> they looked at putStrLn and thought "System.out.println"
07:15:46 <pgiarrusso> I know that in C++, I don't know where else
07:15:46 <neutrino_> i wonder if you could implement php in haskell type specs
07:15:57 <pgiarrusso> you showed them Haskell and they thought it's like Java?
07:15:57 <neutrino_> you can do that in php pgiarrusso
07:16:13 <pgiarrusso> I must have forgot too much PHP then
07:16:13 <neutrino_> pgiarrusso: well, it uses camel case for a lot of names too
07:16:16 <beaky> right
07:16:21 <neutrino_> :)
07:16:22 <pgiarrusso> might be a good thing though :-)
07:16:42 <pgiarrusso> sorry to ask beaky, but can your mates program? No offense intended
07:16:44 <mm_freak> beaky: this video is an (IMO slightly unfortunate) explanation of what i mean:  http://channel9.msdn.com/Shows/Going+Deep/Brian-Beckman-Dont-fear-the-Monads
07:17:04 <Chousuke> beaky: immutable data is one of the things I like most about functional programming. it's easier to convince yourself that your program works as a whole when you can guarantee that each part works on its own.
07:17:05 <beaky> pgiarrusso: they are just freshmen like me :D
07:17:26 <beaky> their only programming experience is rudimentary C++ and Java
07:17:36 <Chousuke> beaky: ... and that there will be no surprising interactions between the parts
07:18:02 <mm_freak> Chousuke made another summary about what i mean, except that immutable data is only one part of the equation =)
07:18:10 <beaky> immutability ftw
07:18:16 <beaky> it's like minimizing moving parts
07:18:17 <pgiarrusso> Well, then I fear they won't be able to understand for real what we're saying
07:19:00 <pgiarrusso> But if they miss function pointers from C++ in Java, you might maybe show them that.
07:19:14 <mm_freak> functional programming reasoning in a nutshell:  w1 is a proper web application, w2 is a proper web application, proper web applications form a monoid under (+), so w1 + w2 is by definition a proper web application
07:19:37 <mm_freak> isolation of information, localization of errors
07:19:39 <beaky> they don't know what function pointers are :( wasn't touched in the classes we've taken :D
07:19:56 <Chousuke> mm_freak: haskell provides really neat tools for isolating unrelated things, and then composing them safely, but I think immutable data is probably the easiest to understand.
07:20:41 <hpaste> 7 pasted “0” at http://hpaste.org/78357
07:20:57 <mm_freak> Chousuke: it's really about what things become when composed in a formal manner…  if s1 is a safe ST action and s2 is a safe ST action, then s1 >> s2 is also a safe ST action
07:21:13 <mm_freak> notice that ST actions can use mutable data without problems
07:21:24 <notdan> Are there any success-stories about proving the properties of some Haskell programs using denotational semantics?
07:21:50 <mm_freak> notdan: i don't think anyone really does that…  we use group/category theory
07:22:55 <sclv> is it legit to refer to a purely evented reactive system as "evented FRP"?
07:23:01 <sclv> I tend to think so, but I worry about muddying terms
07:23:06 <notdan> mm_freak: hm, do you mean that people prove that some datatype is in fact a group and therefore operations on it adhere to certain properties?
07:23:06 <mm_freak> beaky: about the use of function pointers, i have written a blog post about that which you might find interesting:  http://ertes.de/techblog/2009-02-19-1-continuations-for-secure-code.html
07:23:12 <beaky> ah
07:23:18 <mm_freak> notdan: all the time
07:23:21 <sclv> since classical FRP always has some notion of streams in time
07:23:26 <beaky> I used function pointers in C to implement Strategy
07:23:31 <mm_freak> sclv: without events it's hardly FRP
07:23:42 <neutrino_> ohhh here's one:
07:23:49 <sclv> well some systems do events as streams
07:23:52 <neutrino_> is there an idiom for removing space off the end of a string?
07:23:55 <sclv> i.e. only have signals
07:23:58 <neutrino_> whitespace that is
07:24:00 <notdan> mm_freak: ok, well, what if I want to prove that my function X does infact do what I want it to do? and it might be not a simple algebraic property
07:24:10 <sclv> but in my case the signals are just sampleable
07:24:13 <mm_freak> sclv: most of them do that…  in fact netwire is the only counterexample i know
07:24:16 <pgiarrusso> notdan: they also like to use more universal algebra-kind of things
07:24:21 <sclv> so the only notion of "time" is at events
07:24:30 <pgiarrusso> notdan: the main tool is equational reasoning
07:24:39 <sclv> so you have entirely distinct events and signals, that aren't unifiable at all
07:24:59 <mm_freak> notdan: then you come up with a simple algebraic formalization of what you want (or you do it in agda/coq)
07:25:07 <beaky> algebra ftw
07:25:21 <sclv> and the structure of output is a single self-adjusting display
07:25:28 <sclv> as opposed to a signal itself
07:25:39 <sclv> (and you have "sinks" for whiteholes)
07:25:45 <mm_freak> sclv: are you referring to anything specific?
07:25:59 <notdan> mm_freak: well, to be concrete, i want to prove that my function does correspond to some logical formula. in coq i would probably have to make uses of embeddings, i am not sure how would i do this in haskell
07:26:01 <sclv> yeah, something I wrote :-)
07:26:05 <sclv> I'm close to announcing
07:26:11 <sclv> but I can't decided how to describe it
07:26:34 <sclv> it feels very frp-like to me, but it doesn't match the literature
07:26:44 <sclv> and it might be closer to e.g. .NET reactive extensions
07:26:47 <sclv> and RxJs and the like
07:26:49 <mm_freak> sclv: mind pasting the main underlying type?
07:26:51 <sclv> which I think are all purely evented
07:27:08 <mm_freak> because i'm not sure i understand your question =)
07:27:17 <sclv> but I don't know if its legit to call them FRP.
07:27:41 <mm_freak> anything that deals with time-varying values in the presence of events can be called FRP
07:28:40 <sclv> that's sort of how i feel about it, but i don't want to step on the toes of anyone with a more rigorous definition
07:29:21 <sclv> I also don't want to be the guy with a lame thing that's not really FRP but claims it is :-)
07:29:49 <sclv> but I don't want to end up spending half a year writing out a type theory for it with soundness proofs either.
07:30:24 <mm_freak> sclv: well, it's too much too-application-specific code for me to comprehend now, but you can identify FRP:  1. does it have time-varying values? 2. does it allow them to react to events?
07:30:30 <mm_freak> i think those two are sufficient
07:30:30 <notdan> That HALO paper uses denotational semantics, but it seems to me it would be hard to prove monadic code in that way
07:30:49 <sclv> mm_freak: ok, thanks, then sure :-)
07:31:12 <sclv> notdan: do you mean all monadic code, or just IO code?
07:31:16 <Sculptor> hi
07:31:30 <mm_freak> sclv: well, event handling is not FRP =)
07:31:38 <mm_freak> your onEvent makes me unsure
07:31:43 <notdan> sclv: well State monad code
07:31:49 <notdan> and IO code too I guess
07:32:03 <sclv> state monad code desugars into very nice functional code tho
07:32:11 <copumpkin> sclv: I have not forsaken thee! Making my changes now, will send soon :)
07:32:50 <notdan> sclv: well, yeah, but you'd have to use some automatic tools for that, I suppose, can't just do a quick pen&paper rewrite
07:33:03 <sclv> mm_freak: yeah, there's a listening on events sort of thing going on. i guess i should review the MSR stuff on duals of observables
07:33:23 <sclv> onEvent is just the notion of time
07:33:31 <mm_freak> sclv: in FRP you never listen…  you don't "do" anything
07:33:37 <mm_freak> FRP is supposed to be declarative
07:34:04 <sclv> right. but you need some notion of how time advances
07:34:10 <sclv> and you can be continuous, i.e. always advancing
07:34:17 <sclv> or discrete, i.e. advancing in steps
07:34:26 <sclv> or evented, i.e. advancing when an event fires
07:34:29 <mm_freak> sclv: imagine two input boxes b1 and b2 and a label l1…  the label should display the sum of whatever you put into b1 and b2 and "error" if there is no sum…  if the corresponding code looks something like this, it's FRP:  l1 = b1 + b2 <|> "error"
07:34:43 <mm_freak> incidentally that's what netwire code looks like =)
07:34:59 <mm_freak> if you want FRP, consider integrating netwire =)
07:35:06 <rwbarton> is there a nice formula for forall r. (s -> r) -> t r when t is *not* a functor?
07:35:19 <sclv> right -- that's what we have here, except you can't update whenever the boxes change, only when an event fires
07:35:36 <sclv> so you can recover those semantics by firing events for everything else everytime something changes
07:35:40 <rwbarton> s and t are fixed
07:36:18 <elliott> rwbarton: wait, what kind of formula?
07:36:29 <rwbarton> well if t was a functor, it would be isomorphic to t s
07:36:35 <The_third_man> .
07:36:38 <elliott> right
07:37:22 <rwbarton> but that's not always true, consider t r = r -> r, then forall r. (s -> r) -> (r -> r) =~ ()
07:37:22 <shachaf> If t is contravariant then presumably that function doesn't do you much good.
07:37:27 <sclv> mm_freak: but i guess with pervasive sinks it maybe mutates into something else, or starts to feel different
07:37:34 <sclv> i like it, but i'm not sure what to call it
07:37:45 <rwbarton> shachaf: well, t can involve s
07:37:52 <shachaf> Oh, t and s are both fixed.
07:37:55 <rwbarton> since they are just both fixed things
07:37:58 <sclv> maybe just an evented reactive framework, and leave out the 'f' since there's an imperative character :-)
07:38:23 <rwbarton> but maybe that's consistent with what you said
07:40:21 <sclv> rwbarton: isn't it basically a constructive proof of a "functor" from (s->) to t ?
07:40:31 <sclv> i.e. not a haskell functor per se
07:40:51 <beaky> how does Haskell's stdlib compare to C++'s stdlib?
07:40:54 <mm_freak> sclv: let me state it this way:  if it's imperative, it's not FRP…  doing things on events is imperative
07:41:19 <sclv> I think that's sort of extreme
07:41:20 <elliott> beaky: It doesn't.
07:41:25 <mm_freak> events doing things is not necessarily imperative…  events can cause switches
07:41:28 <sclv> like an frp framework can pop up a window, for example
07:41:30 <rwbarton> the kind of formula I have in mind would go along the lines of "split the positive and negative occurrences of r so you have t(r',r) : Hask^op x Hask -> Hask, then apply [some standard category theory construction]"
07:42:19 <rwbarton> ultimately I want to apply this formula to some particular, mildly complicated t
07:42:24 <beaky> I found the C++ stdlib (<algorithm>, <iterator>, and all the generic containers, i.e. the STL) to be very elegant
07:42:37 <beaky> oh and <functional>
07:42:50 <shachaf> What's the t?
07:43:08 <Saizan> rwbarton: i've wanted that too
07:43:12 <rwbarton> t r = Either (s -> r) (a -> r, (a -> r) -> (s -> r))
07:43:29 <mm_freak> sclv: that's what switching in FRP is about…  in FRP you shouldn't say /what/ happens, just /when/ it happens and what the new thing looks like, not what it does
07:43:37 <rwbarton> (a is some other fixed thing)
07:43:57 <mm_freak> it sounds extreme, but really isn't…  it's what FRP is about, and popping up windows does not break it =)
07:43:59 <sclv> mm_freak: if you ignore the sinks
07:44:07 <mm_freak> sclv: i don't know what a sink is
07:44:08 <sclv> then i think this provides that?
07:44:10 <sclv> a whitehole
07:44:17 <sclv> so the example below is more frp like
07:44:28 <mm_freak> could you elaborate?
07:45:08 <sclv> none of the code says "do this" -- it all is declarative. the things that "happen" on events are just portions of a structure transforming
07:45:22 <sclv> the event just define when it happens -- i.e. not continuously
07:45:28 <mm_freak> is a sink comparable to an MVar?
07:45:31 <sclv> so we can view them as boolean streams
07:45:33 <sclv> sinks are more general
07:45:41 <sclv> they're just things that can take a value
07:45:42 <Saizan> in my case t has been the type of an higher order representation of terms with r the type of variable names(aka typing context), so i see forall r. (s -> r) -> t r as the subset of terms which we know how to weaken
07:45:48 <sclv> so you can build mvars with them
07:45:53 <sclv> they're "whiteholes"
07:45:57 <mm_freak> sclv: i think you have a concept similar to elerea
07:46:19 <mm_freak> but FRP is about as well-defined as FP, so don't feel bad about calling it FRP =)
07:46:24 * shachaf wonders where rwbarton's type came from.
07:47:00 <sclv> heh. sounds good. lots of what i have is driven by the fact that it is client-server based
07:47:19 <mm_freak> sclv: i have a categorical view of FRP
07:47:30 <mm_freak> elerea is about as far away from that as you can get
07:47:38 <sclv> categorical here meaning?
07:47:46 <mm_freak> in the sense of category theory
07:48:23 <sclv> i don't see what that means in this context.
07:48:42 <sclv> i can give a categorical account of any semantics :-P
07:48:52 <sclv> for a sufficiently smart "i"
07:49:02 <mm_freak> sclv: it means that for me FRP manifests in a type and that type forms a category
07:49:49 <mm_freak> yampa has started it and netwire continues it
07:49:54 <scooty-puff> completely unrelated to haskell, but on the chance anyone knows: how is the monotonicity of an indexical containing nonlinear terms computed?
07:50:37 <rwbarton> here is another question
07:50:45 <rwbarton> if I have forall r. (s -> r) -> Either (t1 r) (t2 r)
07:51:17 <sclv> mm_freak: btw I meant not whiteholes, but wormholes: http://haskell.cs.yale.edu/?post_type=publication&p=802
07:51:28 <rwbarton> seems like any value of that type is either always Left or always Right, right, so it should be the same as Either (forall r. (s -> r) -> t1 r) (forall r. (s -> r) -> t2 r) ?
07:51:29 <sclv> eek, describing and announcing this thing is harder than writing it
07:51:39 <andsens> hey guys, I am looking for advice on how to best solve the following problem: I want to parse a tree which holds variables on some nodes and leaves. The values of these variables may change the structure of the tree, so I want to arrive at equations that analyze a tree and return the variable values. Which pattern should I use to traverse that tree? Zippers? Keep in mind that standing in one branch I might want to know about the contents about t
07:51:40 <andsens> other branch.
07:52:02 <mm_freak> sclv: i got that…  but wormholes alone only give you concurrency
07:52:37 <sclv> rwbarton: "of that type" meaning what type?
07:52:39 <sclv> the whole thing
07:52:44 <Saizan> rwbarton: i think by parametricity that should follow
07:52:44 <rwbarton> the type in the previous line
07:52:46 <sclv> or the "s"?
07:52:52 <dropdrive> rwbarton: Aren't you saying that a^(b+c) == a^b + a^c there?
07:53:01 <mm_freak> sclv: what you're having may in fact be a concurrency abstraction
07:53:24 <rwbarton> dropdrive: (b+c)^a = b^a + c^a. but the "forall r." is key
07:53:55 <sclv> yeah the weird thing about the way i do events is two panels can have two distinct "worlds" since updates don't happen globally
07:54:02 <sclv> i think lexical scoping keeps it sound
07:54:06 <rwbarton> hmm what I wrote about forall r. (s -> r) -> (r -> r) was totally wrong
07:54:14 <sclv> so you have multiple forking worlds
07:54:23 <rwbarton> that is the same as Maybe s
07:54:39 <dropdrive> rwbarton: ha, yes.  How does the "forall r." make a difference?
07:54:48 <sclv> and sinks let them communicate
07:55:07 <rwbarton> it means I can't really do anything with the value of type r besides pass it to another function I've got that takes a value of type r
07:55:55 <sclv> rwbarton: yeah, i think you're right on the either thing
07:56:01 <sclv> took me a second to see where you were going
07:57:09 <dropdrive> rwbarton: "pass it to another function I've got" -- which functions specifically?  The ones in Left and Right?
07:57:35 <rwbarton> well, just in general
07:57:53 <dropdrive> but what can you do with a value besides pass it into a function?
07:58:10 <rwbarton> well if it is of a known type, I can do whatever I want with it
07:58:11 <sclv> cook it with some fava beans
07:58:33 <sclv> and roast garlic. values go great with roasted garlic.
07:58:35 <rwbarton> in general the correspondence with "high school algebra" breaks down once you introduce forall
07:58:43 <shachaf> dropdrive: If I give you x :: Int, you can lots of things with it. Like add 1 to it. Or add 2 to it. Or even 3.
07:58:59 <shachaf> But if I give you x :: r, and you don't know what r is, you can't do anything with it (other than force it with seq).
07:59:23 <monochrom> note that "add 1 to it" is just a special case of "pass it to a function"
07:59:23 <dropdrive> But then what's the point of saying forall r. -- it's already "r" -- not Int or something.
07:59:38 <shachaf> monochrom: Sure. But it's a function you had in your pocket before we even started.
07:59:42 <rwbarton> for example forall r. (a -> r) -> (b -> r) is the same as b -> a. that doesn't mean (r^b)^(r^a) = a^b or anything
08:00:08 <dropdrive> rwbarton: what is the correspondence with "grown up algebra"?
08:00:14 <rwbarton> long story :)
08:00:28 <dropdrive> any link?
08:00:38 <rwbarton> well
08:00:39 <elliott> because the quantifier is at a different level
08:00:46 <rwbarton> I could just link you to a book on category theory
08:00:48 <elliott> like rwbarton's statement works for any concrete "s"
08:00:55 <elliott> but it's still concrete within the type
08:01:00 * hackagebot monad-logger 0.2.3 - A class of monads which can log messages.  http://hackage.haskell.org/package/monad-logger-0.2.3 (MichaelSnoyman)
08:01:01 <elliott> (assuming rwbarton were to make a true statement about that type)
08:01:09 <rwbarton> but I can also give you this, one sec.
08:01:33 <rwbarton> http://math.ucr.edu/home/baez/week240.html
08:02:50 <rwbarton> (skip through the first page or two)
08:03:24 <mSSM> I have found `forkIO . forever $ waitEvent >>= \e -> when (e == Quit) quit' in a few codes online, usually in relation to SDL drawing; what I don't understand is - what is the IO computation, e.g. in this code: https://github.com/willdonnelly/brians-brain/blob/master/BriansBrain.hs (line 38)?
08:03:40 <dropdrive> "forall r. (a -> r) -> (b -> r)" is the same as "b -> a" -- what is the category-theoretic statement of this?  Does it involve the phrase "universal property" (in which case I suppose I might understand)?
08:03:58 <rwbarton> it's (one version of) the yoneda lemma
08:04:48 <dropdrive> okay, that makes sense then I think.
08:04:48 <rwbarton> "forall r. (r -> a) -> (r -> b) =~ a -> b" is closer to the traditional yoneda lemma
08:05:21 <elliott> mSSM: "quit" is from SDL, if that's what you mean.
08:05:28 <elliott> quit :: IO () or such.
08:05:44 <elliott> It should be SDL.quit there but they imported the module wrong and it pulled all the names into their namespace.
08:05:59 <dropdrive> rwbarton: Do you have an example of using the former where the latter won't do?
08:06:00 <mSSM> elliott: yes, but what exactly is being forked there?
08:06:20 <Botje> forever (waitEvent >>= ...)
08:06:24 <rwbarton> shachaf: colenses!
08:06:44 <elliott> mSSM: That's the same as:
08:06:58 <elliott> mSSM: forkIO (forever (waitEvent >>= (\e -> when (e == Quit) quit)))
08:07:14 <elliott> Because (f . g $ x) == ((f . g) x) = (f (g x)).
08:07:56 <rwbarton> dropdrive: well, on the face of it, they are different statements, so any time you need the first equation, rather than the second equation? :)
08:08:00 <rwbarton> I don't really understand
08:08:34 <mSSM> elliott: ok, so waitevent >>= ... is the IO computation; and where does the need of using forkIO come from?
08:08:38 <rwbarton> but, [a suitably-phrased version of] this statement is true for any category, and these are the formulations in Hask^op and Hask, respectively
08:08:43 <elliott> mSSM: Well, do you know what forever does?
08:08:54 <elliott> Without forkIO, it'd just loop forever waiting on events and never get to the rest of the program.
08:09:13 <elliott> The IO computation being forked is not (waitEvent >>= ...), it is (forever (waitEvent >>= ...)).
08:10:31 <mSSM> elliott: ok, cool; thank you. Yes, the IO computation is of course (forever (... )), that was careless of me.
08:14:43 <rwbarton> dropdrive: sometimes when you want to compute the type of a free wibble on a blarx, you plug in all the definitions, and you get out something like "forall r. (a -> r) -> (b -> r)", then it's nice to simplify to "b -> a", and maybe you then learn something about wibbles and blarxes
08:14:55 <rwbarton> that is the kind of application I have in mind
08:15:49 <dmwit> rwbarton: very down-to-earth
08:15:56 <dropdrive> rwbarton: That is completely beyond me, but "free" in what sense?
08:16:04 <dmwit> Nothing like a solid example to really clarify an abstract concept.
08:16:10 <elliott> free as in beer
08:16:41 <dropdrive> rwbarton: Are you saying that ghc/lambdabot "knows" that "forall r. ..." simplifies to "b -> a"?
08:16:48 <rwbarton> ghc doesn't know
08:17:01 <dmwit> dropdrive: "free" in the sense of being initial in the category of wibbles and wibble homomorphisms.
08:17:19 <rwbarton> wibbles equipped with a map from a blarx :)
08:17:25 <dmwit> err, yes
08:17:45 <dmwit> What is the plural of blarx? "blarxes"?
08:17:55 <byorgey> blarxen
08:18:00 <dmwit> ...or do plurals toggle? "blark"
08:18:07 <atriq> blarces?
08:19:00 <dropdrive> cool, thanks all.
08:19:30 <ClaudiusMaximus> woohoo, benchmark of New Algorithm completes in 15s compared to 1m30s for Old Algorithm - now I just need to check that the results are sane, heh
08:19:51 <rwbarton> dropdrive, basically it is just another formula that comes in handy for the same kinds of reasons as "(a, Either b c) =~ Either (a, b) (a, c)" comes in handy
08:20:18 <dropdrive> handy for whom?  the optimizer, for the coder, or...?
08:20:29 <rwbarton> me
08:20:33 <rwbarton> the coder
08:20:38 <dropdrive> but you know it's true :)
08:20:40 <rwbarton> or even the person who is planning to write code
08:22:00 <elliott> it's helpful because you know it's true...
08:23:58 <ion> PLOT TWIST: it is revealed that you are in an alternative universe where it is not true.
08:25:11 <rwbarton> it's helpful because when I program with types I like to know what the possible values of those types are :)
08:25:27 <dropdrive> Next question: in Section 2.1 of http://projects.haskell.org/operational/Documentation.html , where "StackProgram a" is a program that pushes/pops/returns values of type "a", why isn't the type of "interpret" StackProgram a -> Stack a -> a ?
08:26:01 * hackagebot language-java 0.2.0 - Manipulating Java source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/language-java-0.2.0 (VincentHanquez)
08:26:35 <elliott> dropdrive: Because a program that processes a stack of Ints and returns an a needs a stack of Ints as input.
08:26:45 <elliott> (You need to read the tutorial it links to understand that example.)
08:27:23 <Saizan> dropdrive: it's the same except for the stack containing Int's presumely because the stack operations only deal with Ints
08:27:35 <dropdrive> Wait, so what is "a" then?  Doesn't it have to be Int as well (otherwise how would you can't push it onto the stack)?
08:28:14 <Saizan> the 'a' is the final result, but it's not forced to be on the stack
08:28:15 <ion> I haven’t studied the example, but perhaps it’s akin to “State Int a”.
08:31:57 <dropdrive> (Maybe it's okay then to replace "Stack Int" with "Stack b".)
08:32:26 <elliott> it's not okay AFAIK
08:32:32 <elliott> because StackProgram has operations based on Ints
08:33:23 <rwbarton> here is really a better version of my question: is there a general algorithm (or is it even possible at all) to replace "forall r. t r" with an isomorphic type involving no quantifiers
08:33:46 <elliott> rwbarton: What if t = Identity?
08:33:54 <elliott> oh, then that's just ()
08:33:58 <shachaf> Void?
08:34:02 <rwbarton> Void I think
08:34:04 <elliott> er, right
08:34:07 <rwbarton> if t is a functor then you get t Void
08:34:16 <elliott> I mixed up forall and exists
08:34:27 <elliott> rwbarton: I think it might well be possible for Haskell types t
08:34:27 <rwbarton> I guess this is pretty related to djinn
08:34:58 <rwbarton> this is also sort of what that link I posted addresses
08:35:29 * elliott should probably stop trying to think of counterexamples.
08:38:28 <danharaj> I think you have (forall r. t r) is isomorphic to (t (forall r. r)) and if t is a functor then you can fmap to obtain (t Void)
08:39:06 <danharaj> I don't see how you would do it without fmap :[
08:39:39 <elliott> danharaj: That's not true.
08:39:45 <elliott> Take t r = (r -> a) for some a.
08:40:02 <elliott> (forall r. t r) = (forall r. r -> a) =/= ((forall r. r) -> a)
08:40:24 <Saizan> forall r. t r is not in general isomorphic to t (forall r. r)
08:40:24 <byorgey> it's not even true for things that are functors.
08:40:32 <danharaj> boo
08:41:03 <elliott> it is true for functors, isn't it?
08:41:12 <elliott> At least I can't think of a counterexample off the top of my head.
08:41:14 <byorgey> no, it isn't
08:41:21 <elliott> hmm
08:41:40 <byorgey> forall r. [r] is a list, whose elements can have any type you like (but they must all be the same)
08:42:00 <byorgey> [forall r. r] is a list, each of whose elements can have any type
08:42:14 <shachaf> Both of them have only one inhabitant. :-)
08:42:21 <elliott> (forall r. [r]) is isomorphic to [Void].
08:42:22 <byorgey> oh, but I guess those are isomorphic, right
08:42:26 <elliott> So is [forall r. r].
08:42:33 <andsens> I have somevariables in a do block I would like to use in a nested do block. How can I pass those variables on?
08:42:44 <elliott> I'm pretty sure (forall r. f r) = f Void = f (forall r. r) for all functors f
08:43:20 <elliott> rwbarton: hmm, is there some general analoguous rewriting of (forall r. t r) just for contravariant functors t?
08:43:25 <byorgey> ok, yes, I think I agree now
08:43:28 <danharaj> elliott: your example is also isomorphic
08:43:31 <byorgey> andsens: just use them
08:43:45 <elliott> danharaj: hm?
08:43:51 <byorgey> andsens: you don't need to do anything special.  they will be in scope in the nested do block as well.
08:43:57 <elliott> danharaj: (forall r. r -> a) is not (Void -> a).
08:44:00 <elliott> it's (() -> a) ~ a
08:44:09 <andsens> Not in scope: `attrs'
08:44:14 <elliott> It's the difference between a and not a :P
08:44:14 <danharaj> yes I guess so
08:44:26 <andsens> Oh wait, this might be because my indentation is wrong
08:44:30 <elliott> er
08:44:33 <elliott> it's the difference between a and () rather
08:44:41 <andsens> It's actually two do blocks with a choice operator in between
08:44:47 <n-dolio> IORef (forall a. a) ~ forall a. IORef a
08:44:48 <n-dolio> Oh wait.
08:44:57 <andsens> So somehow the second block doesn't see the vars
08:45:14 <elliott> instance Functor IORef
08:45:23 <elliott> instance Monad IORef???
08:45:50 <byorgey> andsens: two do-blocks with a choice operator in between is definitely not the same thing as nesting one do-block within the other.
08:46:06 <andsens> byorgey, no it is not. hehe
08:46:15 <shachaf> byorgey: Well, (>>) *is* quite a choice operator.
08:46:45 <byorgey> heh, I suppose.
08:46:53 <yaparq> is there some way I can ensure that evaluation of one expression in a list sparks the evaluation of some specified number of following elements in that list?
08:46:59 <hpaste> andsens pasted “vars in do blocks” at http://hpaste.org/78358
08:47:07 <andsens> I figured it out, but it's kinda ugly.
08:47:12 <andsens> Any suggestions
08:47:56 <elliott> that looks like a good candidate for applicative notation
08:47:57 <rwbarton> elliott: for contravariant t it should be t () I think
08:48:13 <elliott> and a shorter indentation width
08:48:33 <rwbarton> xml is the "killer app" for short indentation width yes
08:48:45 <elliott> heh
08:48:52 <byorgey> elliott: I don't think applicative notation would actually work very well
08:49:15 <elliott> I guess there's the problem of the alternation being below some of the parses
08:49:30 <byorgey> andsens: line up the 'do's, and don't indent x_reservedOp etc.  so much
08:50:04 <byorgey> andsens: also, don't use tabs
08:50:16 <ClaudiusMaximus> yaparq: hm, there's parBuffer which does something like that assuming the list is consumed from the head, but for random access i'm not sure there'll be something for lists...
08:50:45 <andsens> byorgey: I kind of have to have some indentation for the block to work
08:51:14 <andsens> otherwise the <|> wil be inside the do block
08:51:18 <neutrino_> @pl foo x y = bar x y Nothing
08:51:18 <lambdabot> foo = flip flip Nothing . bar
08:51:30 <elliott> andsens: You should probably use a "where" clause to separate out the two halve of the (<|>)
08:51:32 <elliott> *halves
08:51:34 <yaparq> ClaudiusMaximus: thanks, I'll see if I can implement something along those lines
08:51:36 <elliott> so you can just say foo <|> bar in the do block
08:51:46 <hpaste> byorgey annotated “vars in do blocks” with “vars in do blocks (annotation)” at http://hpaste.org/78358#a78359
08:51:46 <beaky> how do you define purely-functional data structures?
08:51:53 <byorgey> andsens: ^^^ something like that
08:51:54 <andsens> eliott, great idea :-)
08:52:24 <andsens> byorgey: I will never ever use spaces for indentation, I get it when I am using hpaste, the tab width there is insane.
08:52:32 <andsens> My own tab-width is 2
08:52:45 <elliott> andsens: that is not really a viable policy for Haskell with most formatting styles
08:52:54 <elliott> because GHC treats tabs as 8 spaces always and alignment (not just indentation) matters in Haskell
08:53:00 <byorgey> andsens: it's not because of the width.  using tabs with Haskell is a bad idea.
08:53:07 <byorgey> because of what elliott said.
08:53:23 <andsens> Well I don't use tabs for alignment
08:53:28 <andsens> That would be stupid
08:53:28 <elliott> you can write Haskell in a way such that you never rely on alignment, but it is a very unconventional (and pretty ugly) style
08:53:30 <elliott> and it is easy to mess it up
08:53:46 <elliott> well Haskell does not really distinguish indentation and alignmetn
08:53:47 <shachaf> Uh oh.
08:54:54 <beaky> alignment tyle ftw
08:55:05 <beaky> curly braces and semicolons are nasty
08:55:09 <andsens> you got some link so I can read more about this?
08:55:26 <elliott> the Haskell Report :P
08:55:35 <elliott> haskell alignment rules are a bit arcane
08:56:15 <beaky> just write pretty code and a sufficiently smart cmpiler will align it right
08:56:27 <beaky> rules are for machines
08:56:32 <monochrom> not arcane to me. I correctly guessed 99% of it without even reading
08:56:57 <elliott> monochrom: that might mean you are arcane :)
08:56:59 <shachaf> @arr cane
08:56:59 <lambdabot> Aye Aye Cap'n
08:57:09 <beaky> @arr ays
08:57:09 <lambdabot> Aye Aye Cap'n
08:58:09 <andsens> Can't find it, only stuff about Layout in 2.7
08:58:26 <elliott> layout is what's relevant here, yes
08:58:39 <rwbarton> the full treatment of layout is somewhere in the back
08:58:51 <monochrom> you can use tab, but haskell defines tab to mean "go to the next 8n column", which is usually not how you set up your editor
08:58:57 <elliott> I think it might be in http://www.haskell.org/onlinereport/haskell2010/haskellch10.html#x17-17500010
08:59:05 <elliott> yeah, it is
08:59:21 <monochrom> fortunately, hpaste shows you what your tabs really mean
08:59:26 <andsens> oh wait, but then tehre should be no problem
08:59:36 <andsens> As long as I don't confuse spaces with tabs
08:59:59 <rwbarton> you must also never put a token on the same line as "of" "do" etc.
09:00:14 <rwbarton> i.e. follow all "of" "do" "let" "where" by newline
09:00:21 <andsens> So yes, if I indent a single line in a do block with spaces instead of tabs there is a problem
09:00:35 <elliott> thinking that you can use non-8-wide tabs problem-free in Haskell is a good indication you don't understand the layout algorithm fully :P
09:00:42 <elliott> or else use a _very_ weird formatting style such that it works
09:00:43 <rwbarton> there is a problem if you write "f = do x\n\ty"
09:00:59 <andsens> rwbarton, I think "follow" is the right word here, I only precede a do with something
09:01:47 <monochrom> I don't understand. the layout rules certain allow and deal with "do/let/where" followed by tokens
09:01:57 <rwbarton> as long as you understand the problem I just mentioned and understand how to avoid it you are okay
09:02:02 <Eelis> i wish the haskell layout rules didn't penalize variable-width fonts
09:02:05 <rwbarton> monochrom, in conjunction with tabs I mean
09:02:35 <hpaste> andsens pasted “same block with spaces” at http://hpaste.org/78360
09:03:01 <andsens> That's what stuff looks like in my editor
09:03:35 <monochrom> "ff = do x\n\ty" will work. tab brings you to the next 8n column, right under x
09:04:16 <shachaf> Some GHC code indents with spaces-then-tabs-then-spaces.
09:04:20 <monochrom> you have to be very careful with what the layout rules say vs what you recommend for sanity
09:04:23 <shachaf> But then again they don't use layout.
09:05:20 <andsens> by the way. Does anybody use SublimeText. If so, what cool linting plugins are out there?
09:05:57 <andsens> for haskell that is
09:09:35 <troydm> what's apr?
09:09:44 <troydm> ups sorry wrong channel
09:10:50 <shachaf> .win 28
09:10:52 <shachaf> Ahem.
09:16:03 <killy9999> I have Yet Another Haskell Problemy only this time I don't even know how to describe it in a sensible way
09:16:20 <johnw> @faq Can Haskell solve undescribable problems?
09:16:20 <lambdabot> The answer is: Yes! Haskell can do that.
09:16:34 <killy9999> OK, that's good to know
09:16:56 <johnw> indescribable, silly me
09:17:36 <killy9999> so I'll give it a try - please bare with my explanation :)
09:17:53 <vraid> @faq Can haskell find constant time solutions to NP-hard problems?
09:17:53 <lambdabot> The answer is: Yes! Haskell can do that.
09:17:53 <killy9999> I have a function passed around in a tuple
09:18:07 <killy9999> that function has a type constraint
09:18:21 <johnw> @faq Can Haskell define the set that contains all sets?
09:18:21 <lambdabot> The answer is: Yes! Haskell can do that.
09:18:37 <tac> Of course haskell can do that....
09:18:40 <tac> @type fix id
09:18:41 <lambdabot> a
09:18:47 <killy9999> the point of using a constraint is that I can apply that function to different types
09:19:16 <killy9999> only at some point that constraint gets unifed with some particular type
09:19:29 <johnw> killy9999: show us what Haskell isn't letting you do
09:19:43 <killy9999> which basically prevents it from unifiying with diferent types
09:19:54 <killy9999> johnw: I can show you the error message
09:20:02 <elliott> showing code would be good too
09:20:03 <johnw> sure!  and the code, on hpaste.org, bitte
09:20:05 <killy9999> but I can't give any reasobaly-sized code
09:20:20 <elliott> well if you don't show some code it's going to be very hard to help
09:20:32 <hpaste> killy9999 pasted “error” at http://hpaste.org/78361
09:20:42 <killy9999> elliott: I know
09:20:50 <killy9999> but the code is spread over many files
09:20:52 <johnw> yeah, undeduced types
09:20:59 <johnw> i ran into this in all kinds of situations
09:21:28 <johnw> you have a type variable, r presumably, but your usage doesn't pin it down to a type in the context where you are wanting to evaluate the expression
09:21:51 <rwbarton> sounds like you want higher-rank polymorphism
09:22:02 <killy9999> rwbarton: that was my first thought
09:22:04 <johnw> yeah, try LANGUAGE RankNTypes
09:22:07 <killy9999> and in fact I even tried
09:22:10 <killy9999> but failed :/
09:22:32 <rwbarton> perhaps: benchLattice :: (forall r. Array r DIM1 Double -> Array U DIM1 Double, (Double, Double), Array U DIM1 Double) -> Array U DIM1 Double
09:22:38 <killy9999> ok, I'll try to paste some type signatures. Gimme a sec
09:22:47 <johnw> rwbarton: is that existential quantification?
09:22:50 <rwbarton> no
09:22:56 <killy9999> rwbarton: that's what I tried and still got an error (although different one)
09:23:24 <rwbarton> I don't know exactly what GHC calls this but basically it is just higher-rank polymorphism
09:23:46 <rwbarton> if you rewrite it to (forall r. Array r DIM1 Double -> Array U DIM1 Double) -> (Double, Double) -> Array U DIM1 Double -> Array U DIM1 Double (is there a reason the function is uncurried?)
09:24:08 <rwbarton> as-is it might need PolymorphicComponents or ImpredicativeTypes
09:24:34 <hpaste> killy9999 annotated “error” with “error (annotation)” at http://hpaste.org/78361#a78363
09:25:14 <killy9999> rwbarton: you got lost in the parentheses I think - this is all in a tuple :)
09:25:25 <rwbarton> I didn't get lost, I just didn't understand why the tuple.
09:25:31 <rwbarton> I detupled it intentionally
09:25:38 <rwbarton> But now I think I see why
09:25:51 <killy9999> rwbarton: I see - it is intended to be a tuple since this is basically data the gets passed around
09:25:56 <rwbarton> sure
09:26:20 * killy9999 tries using RankNTypes & ImpredictiveTypes
09:26:26 <rwbarton> why are there two "benchLattice"s?
09:26:39 <killy9999> because they are in different files
09:27:04 <killy9999> they are used with qualifed imports in the main benchmark file
09:27:05 <rwbarton> well okay but the latter looks like a generalization of the first
09:27:11 <rwbarton> in type at least
09:27:27 <killy9999> hm... gimme a sec
09:27:30 <rwbarton> oh, you might want to pass the result of dataLatticeP to one or the other
09:27:33 <rwbarton> is that it?
09:28:26 <killy9999> rwbarton: yes
09:28:55 <killy9999> results of dataLatticeP are passed to both of these functions
09:30:02 <rwbarton> this is tricky without knowing exactly what you want to do. there are a lot of variations
09:30:20 <killy9999> rwbarton: well, I think you're right
09:30:41 <killy9999> but I don't expect anyone to actually read through tens of lines of my code...
09:30:53 <tromp> > 16384+625
09:30:54 <lambdabot>   17009
09:30:59 <killy9999> anyway, I'm trying to narrow down the problem
09:31:11 <killy9999> the problem is not with RankNTypes
09:31:33 <NoICE> hi guys, is there any library that can convert haskells string (utf8) to ucs2?
09:31:48 <NoICE> (i found hxt-unicode, which can do only ucs2->utf8, at least it looks like that)
09:32:00 <shachaf> NoICE; UCS-2 isn't a thing you should use.
09:32:08 <shachaf> It can't encode all of Unicode.
09:32:34 <shachaf> What do you want to do with a codepoint like U+1F314?
09:32:38 <NoICE> shachaf:  I know, but UCP/EMI protocol specification needs that (I'm connecting directly to SMSC via EMI protocol)
09:32:47 <rwbarton> is ucs-2 the same as utf-16 except it fails if it gets a non-BMP character?
09:32:55 <shachaf> Yep.
09:33:23 <shachaf> Once you figure out what you want to do with non-BMP characters, just do that and then encode it as UTF-16
09:33:38 <NoICE> I can safely strip them off
09:33:48 <NoICE> most mobiles won't show them anyway
09:34:07 <NoICE> so I can just use UTF16 and pretend it's ucs2? :)
09:34:18 <NoICE> (I don't know all the differences between those two)
09:34:22 <shachaf> Yes.
09:34:30 <NoICE> thanks!
09:34:37 <shachaf> But you should probably find out the differences, just so you know. :-)
09:35:02 <shachaf> UTF-16 is such a mess.
09:35:06 <NoICE> good to know :) btw maybe I will release this library after it's finished (but hey, EMI is complex protocol and I don't handle all the cases, like flashing sim cards :D )
09:35:41 <Jambato> ls
09:35:49 <Jambato> arf
09:35:51 <Jambato> nvm
09:39:04 <mSSM> In ghci, if I want to bind `g <- U.new 64' (with import Data.Vector.Unboxed.Mutable as U), what is the correct type I am supposed to give it?
09:39:20 <mSSM> I thought :: IO Int would work, but it doesn't
09:39:32 <elliott> :t Data.Vector.Unboxed.Mutable.new
09:39:33 <lambdabot> (Control.Monad.Primitive.PrimMonad m, Data.Vector.Unboxed.Base.Unbox a) => Int -> m (Data.Vector.Unboxed.Base.MVector (Control.Monad.Primitive.PrimState m) a)
09:39:54 <rwbarton> IO (U.Vector Int), should be
09:40:01 <rwbarton> or maybe U.MVector or whatever
09:40:09 <rwbarton> I think there is an alias for MVector IO though
09:40:10 <mSSM> ah
09:40:12 <mSSM> that makes sense
09:40:35 <mSSM> IO (IOVector Int)
09:40:38 <mSSM> rwbarton: thanks
09:40:38 <rwbarton> that's it
09:41:02 * hackagebot ls-usb 0.1.1 - List USB devices  http://hackage.haskell.org/package/ls-usb-0.1.1 (RoelVanDijk)
09:41:13 <NoICE> shachaf: looks like I can use Data.Text.pack for converting to utf16? is that right?
09:41:36 <elliott> NoICE: You should use http://hackage.haskell.org/packages/archive/text/0.11.2.3/doc/html/Data-Text-Encoding.html
09:42:08 <NoICE> thanks )
09:42:09 <NoICE> :)
09:43:39 <shachaf> NoICE: Data.Text uses UTF-16 internally, but it doesn't really expose that.
09:43:42 <shachaf> Do what elliott said.
09:46:14 <killy9999> rwbarton: I did it, or rather I should say Haskell's type inferencer did it
09:46:33 <killy9999> I commented out the type signatures and copied the inferenced types :)
09:46:38 <rwbarton> huh
09:46:39 <ocharles> damnit, I don't know my hackage password :'(
09:46:47 * killy9999 wonders why didn't he do that earlier
09:47:22 <killy9999> now I have to see why did I come up with wrong type signatures (this means that I misunderstood sth)
10:02:10 <mSSM> If I have `x <- lift m a', have I effectively bound `m a' to x ?
10:03:01 <c_wraith> that...  doesn't quite pass my mental typechecker.
10:03:04 <c_wraith> :t lift
10:03:05 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
10:03:12 <c_wraith> lift only takes one argument
10:03:35 <mSSM> c_wraith: well, it was pseudocode.... I meant lift (m a)
10:03:39 <c_wraith> (unless of course t m a is a function - possible, but very unlikely)
10:04:58 <mSSM> what I mean is: x <- lift y, where the type of y is m a
10:05:10 <mSSM> what type is x, then?
10:05:17 <c_wraith> t m a
10:05:25 <c_wraith> just like the type signature above says
10:05:43 <c_wraith> Oh, no
10:05:44 <c_wraith> sorry
10:05:47 <c_wraith> The type of x is a
10:06:04 <mSSM> c_wraith: So what's the point of having lift there?
10:06:25 <mSSM> what's the difference between x <- y and x <- lift y ?
10:06:28 <mSSM> if y :: m a
10:06:33 <c_wraith> one will typecheck, one won't
10:06:56 <c_wraith> it depends on the type of the do block the binding is in
10:07:15 <hpaste> killy9999 pasted “error once again” at http://hpaste.org/78366
10:07:28 <killy9999> turns out that I did not solve my error
10:07:46 <killy9999> and it also turns out that I'll be needing higher order types
10:07:51 <mSSM> c_wraith: Can you give me an example?
10:10:01 <c_wraith> @ty do { x <- lift readLn ; put x }
10:10:02 <lambdabot> (Read s, MonadTrans t, MonadState s (t IO)) => t IO ()
10:10:09 <c_wraith> @ty do { x <- readLn ; put x }
10:10:10 <lambdabot>     No instance for (MonadState s0 IO)
10:10:11 <lambdabot>       arising from a use of `put'
10:10:11 <lambdabot>     Possible fix: add an instance declaration for (MonadState s0 IO)
10:10:18 <hpaste> killy9999 annotated “error once again” with “error once again (annotation)” at http://hpaste.org/78366#a78367
10:10:55 <killy9999> rwbarton: I've followed GHC's suggestions to use ImpredicativeTypes, but this only leads to an error I'm unable to resolve
10:12:15 <monochrom> GHC ImpredicativeTypes is not fully implemented. the suggestion is a mistake
10:13:43 <killy9999> monochrom: thanks.
10:14:02 <killy9999> Without this extension I get this error: Illegal polymorphic or qualified type forall r. Array r DIM1 Double -> Array U DIM1 Double
10:18:54 <rwbarton> you will have to actually understand what it is you want to do and what the types mean
10:20:02 <killy9999> rwbarton: *I think* I finally got to a point where I understand what I want to do :)
10:20:05 <Cale> You rarely actually want ImpredicativeTypes
10:20:24 <killy9999> and I think I know what is the problem
10:20:46 <rwbarton> you can always wrap up the universal in a newtype
10:20:48 <killy9999> variable in a type class constraint gets unified with type D and cannot be latter unified with L
10:21:28 <Susanne> hi :)
10:21:33 <killy9999> I think this should be solved with RankNTypes (or Rank2Types)
10:21:48 <killy9999> but I don't know how to do that :/
10:22:00 <Susanne> Can Anybody help me write this for <n> elements ?
10:22:01 <Susanne> http://hpaste.org/78368
10:22:01 <fryguybob> killy9999: Why do the two r's need to be the same?
10:22:46 <killy9999> fryguybob: not sure if I understand what you're asking
10:22:56 <killy9999> r's in fact need to be different
10:23:08 <fryguybob> killy9999: Hence my quesiton.
10:23:08 <killy9999> in one function this needs to be D, in another L
10:23:29 <killy9999> after r gets unified with D it is impossible to unify it with L
10:23:52 <Susanne> nobody :(
10:25:30 <atriq> edwardk, you still need to update the Readme after the Great Monoid Lens Diaspora,
10:25:37 <atriq> I only touched the wiki
10:25:43 <parcs`> Susanne: nobody is going to decipher that code. tell us what it does
10:26:05 <killy9999> parcs` run it in GHCi and it becomes pretty obvious what ot does :)
10:26:15 <parcs`> why would i do that
10:26:21 <killy9999> for fun
10:26:31 <killy9999> for a list [1..10] it produced [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
10:26:38 <killy9999> but I agree that code is obfusctaed
10:26:40 <edwardk> atriq: send a patch. =)
10:26:44 <elliott> well the idea is that the person asking the question should do the work
10:26:46 <parcs`> oh, ok
10:26:50 <elliott> not the person being asked to help
10:27:05 <glguy> > map (take 3) (tails [1..])
10:27:06 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10],[9,10,11]...
10:27:11 <elliott> this scales far better in a channel where lots of people ask lots of questions
10:28:19 <Susanne> ok i want to build a list of list with always the next k elements of an element in it , so for example [1,2,3,4,5,6] -> [[1,2,3][2,3,4][3,4,5][4,5,6]] for k = 3. the last 2 elements do not have 3 next elements, so i ignore them
10:29:25 <killy9999> Susanne: se glguy's solution above
10:29:29 <killy9999> s/se/see/
10:30:53 <Susanne> what does the tails function?
10:31:09 <parcs`> > let f n xs = zipWith const (map (take n) (tails xs)) [1..n+1] in f 3 [1..6]
10:31:11 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6]]
10:31:13 <niteria> > [take 3 s | s <- tails [1..10], length s > 3]
10:31:15 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9]]
10:31:47 <niteria> > [take 3 s | s <- tails [1..10], length s >= 3]
10:31:48 <lambdabot>   [[1,2,3],[2,3,4],[3,4,5],[4,5,6],[5,6,7],[6,7,8],[7,8,9],[8,9,10]]
10:32:12 <Susanne> do i need an import for tails?
10:32:17 <niteria> Data.List
10:32:44 <kylcarte1> Susanne: http://www.haskell.org/hoogle/
10:33:05 <glguy> ?index tails
10:33:05 <lambdabot> Data.List
10:33:53 <Susanne> i like the lambdabot
10:33:53 <niteria> would anyone share their .ghci with me? I'd like to have some common things always imported
10:33:59 <Susanne> who made it?
10:34:25 <elliott> lots of people
10:35:30 <Susanne> its connected with ghci?
10:35:47 <c_wraith> not really
10:36:21 <c_wraith> both ghci and lambdabot use the ghc api to interpret code - but they have a lot different structures
10:36:50 <elliott> c_wraith: well, lambdabot actually uses ghci directly for :t :)
10:36:59 <c_wraith> lambdabot uses some wrappers that are designed to greatly increase safety of executing code
10:37:05 <killy9999> Susanne: you can install lambdabot locally on your machine
10:37:16 <elliott> c_wraith: (directly, afaik)
10:38:41 <Susanne> how can i do it?
10:40:44 <killy9999> Susanne: cabal install lambdabot
10:41:42 <Susanne> http://www.haskell.org/cabal/download.html ?
10:44:44 <neutrino_> Susanne: aptitude install cabal-install
10:45:59 <Susanne> what is aptitude?
10:46:12 <asti> It's a package manage on Linux
10:46:39 <Susanne> ok, i use apt-get normally
10:46:47 <killy9999> apt-get is also fine
10:46:54 <killy9999> wait
10:47:00 <Susanne> whats the difference?
10:47:01 <killy9999> Susanne, do you have Haskell Platform?
10:47:14 <Susanne> i have ghci
10:47:18 <killy9999> apt-get uses command line interface
10:47:40 <asti> Well, APT is the actual implementation
10:47:43 <killy9999> aptitude uses text-mode interface similar to mc
10:47:52 <asti> Both are different front-ends to APT
10:47:57 <asti> and work slightly differently
10:48:09 <killy9999> anyway
10:48:14 <asti> But for most purposes, they should work the same
10:48:19 <killy9999> if you have ghci this means you already have haskell
10:48:24 <killy9999> so you should have cabal also
10:49:09 <Susanne> oh :D, so i also have lambdabot?
10:49:30 <asti> You don't really need lambdabot if you have GHCi
10:49:53 <asti> ...which you already have
10:50:14 <asti> On a related note, how safe is lambdabot?
10:50:52 <asti> > [1 ..10]
10:50:54 <lambdabot>   [1,2,3,4,5,6,7,8,9,10]
10:51:01 <asti> > [s - s | s <- [1..]]
10:51:02 <killy9999> Susanne: no
10:51:02 <lambdabot>   [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,...
10:51:04 * hackagebot shake 0.3.6 - Build system library, like Make, but more accurate dependencies.  http://hackage.haskell.org/package/shake-0.3.6 (NeilMitchell)
10:51:06 * hackagebot progression 0.5.0.1 - Automates the recording and graphing of criterion benchmarks  http://hackage.haskell.org/package/progression-0.5.0.1 (KidoTakahiro)
10:51:14 <killy9999> if you have cabal it means you can install lambdabot
10:51:18 <Susanne> [1..]
10:51:28 <Susanne> > [1..]
10:51:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
10:51:35 <Susanne> :D
10:52:41 <nicoo> asti: It is supposed to be quite safe
10:53:02 <Susanne> whats the difference between lamdabot and ghci?
10:53:10 <nicoo> You cannot run stuff in IO inside (or use type-unsafe stuff like unsafePerformIO)
10:53:19 <nicoo> Susanne: GHCi is run locally, in your shell
10:53:41 <asti> It simply looks like BASH
10:53:44 <nicoo> lambdabot is an IRC bot; moreover, it comes preloaded with stuff that isn't in GHCi's prelude
10:53:46 <asti> You type in code
10:53:52 <asti> and it interprets it,
10:53:56 <asti> and gives you the output
10:54:50 <Susanne> oh ok
10:54:58 <Susanne> so its useless for me :D
10:55:01 <typoclass> Susanne: not very big really. lambdabot is sort of a ghci that has been put into this chat room. it has a few extras compared to ghci
10:55:18 <typoclass> Susanne: you can talk to lambdabot in private chat, if you want
10:56:06 <asti> Welp, I just tried explaining what Monads are to a friend who knows only Ruby.
10:56:08 * hackagebot functor-combo 0.3 - Functor combinators with tries & zippers  http://hackage.haskell.org/package/functor-combo-0.3 (ConalElliott)
10:56:26 <Susanne> ah nice to know
10:56:28 <typoclass> asti: to scare him? :-)
10:56:44 <nicoo> typoclass: Monads aren't scary
10:56:44 <asti> He found it way too abstract, so he asked me for an example.
10:56:52 <asti> I gave him the simplest one: Maybe.
10:57:11 <asti> I said it's just a structure which has one of two values: Just or Nothing.
10:57:31 <elliott> that's not true :P
10:57:49 <elliott> that's Bool
10:58:00 <killy9999> I think that monads are actually quite easy
10:58:07 <glguy> no way, bool has three
10:58:12 <killy9999> which in turn makes me think that I misunderstood something...
10:58:12 <Chousuke> monads are extremely simple
10:58:14 <asti> Anyway,
10:58:18 <Chousuke> it just takes a while to see why
10:58:23 <asti> he looks at this and goes...
10:58:36 <typoclass> nicoo: yes and no ... i think it's not a big deal in terms of using them, but otoh, people make a huge fuss about them, with dozens of tutorials and talk of obscure math subfields
10:58:39 <asti> huh, I see... all monads are basically useless then.
10:58:48 <asti> > mfw
10:58:50 <lambdabot>   Not in scope: `mfw'
10:58:55 <asti> lol'd
10:59:10 <elliott> well Bool is not a very compelling example of a Monad
10:59:21 <Chousuke> the way I would describe Maybe is that it takes your bunch of types and transforms it into another bunch of types + Nothing
10:59:22 <asti> Basically, to summarise the discussion,
10:59:26 <asti> it went something like https://dl.dropbox.com/u/1928972/rf/aaaaa/AaaaahAaaaah.gif
10:59:46 <Chousuke> which means you get a nullable type
10:59:48 <Philippa> asti: List/non-determinism is a better sell for folks like that, yeah
11:00:24 <Philippa> killy9999: there're several angles from which monads-in-haskell are easy, yeah
11:00:28 <Chousuke> hm, actually that's probably a bit imprecise.
11:00:28 <asti> Apparently Ruby can sort of simulate the List monad with it's magical yeild rewriting
11:00:36 <asti> *yield
11:01:09 <asti> So that was more of a case of "it's done this way in Ruby - why do you have to make it so hard"
11:01:09 <Philippa> mmm. Obviously the turing tarpit is all we need
11:01:20 <Philippa> "it's done this way in Haskell, why do you have to make it so hard?"
11:01:29 <asti> Have you guys seen what Procs do in Ruby?
11:01:30 <killy9999> Well, monads can be a bit tricky when it comes to details but generaly I think the idea is simple (or, as I said, I misunderstand that idea and think that it's simple)
11:01:39 <asti> I just read up on it,
11:01:44 <elliott> you mean functions
11:01:55 <asti> and jesus, you guys would have a heart-attack to know what it can do
11:02:15 <c_wraith> most languages can simulate any specific monad pretty easily. The important part languages like haskell give is the ability to abstract over them.
11:02:29 <asti> That's the important bit.
11:02:40 <asti> Otherwise working with monads becomes tedious.
11:03:01 <typoclass> "it's done this way in combobuloid generalized dihylocatabstractate theory, who do all the other guys make it so hard"
11:03:04 <typoclass> s/hard/easy
11:03:13 <Chousuke> :P
11:03:52 <asti> ( ¬‿¬
11:03:56 <Chousuke> I don't claim to understand what monads are exactly from a category theory point of view but in context of programming I just see them as a generalisation of function composition
11:04:20 <asti> That's pretty much it.
11:04:36 <asti> In fact, if you replace all the data structures with functions,
11:04:44 <asti> you'll see that it's only function composition
11:04:44 <copumpkin> ( ͡° ͜ʖ ͡°)﻿
11:04:57 <asti> _███_
11:04:57 <asti> ( ͡° ͜ʖ ͡°)
11:05:03 <Chousuke> comonads, however, I don't quite get.
11:05:37 <c_wraith> They're kind of simpler, actually
11:05:47 <copumpkin> asti: not sure I'd say that
11:05:47 <nyc> Weird, I've been seeing that face smiley elsewhere, too.
11:05:49 <c_wraith> What's less obvious is when the abstraction is useful
11:05:56 <copumpkin> nyc: it's pretty good, innit
11:06:06 <monochrom> impressive!
11:06:41 * copumpkin stole it from dolio
11:06:43 <copumpkin> not sure where dolio stole it
11:07:04 <asti> It's apparently called le lenny face
11:07:18 <copumpkin> it's gotta be "le"?
11:07:30 <Chousuke> c_wraith: there was some blog post I tried to read that used zippers and comonads in some web-programming context but I completely failed to understand it
11:07:41 <asti> Otherwise it wouldn't be ironic
11:07:55 <copumpkin> oh okay
11:08:08 <Chousuke> asti: maybe whoever came up with that name had a stutter
11:08:20 <copumpkin> Chousuke: comonads sort of give you a notion of context, conceptually
11:08:37 <copumpkin> Chousuke: as do zippers, incidentally
11:09:03 <Chousuke> in a zipper the context would be your location in the structure?
11:09:21 <copumpkin> yeah
11:09:54 <elliott> zippers are comonads I think?
11:11:50 <killy9999> is there any good resource (book perhaps?) on type systems?
11:11:58 <killy9999> I mean Haskell's type system in particular
11:12:51 <Philippa> killy9999: Pierce's two Types and Programming Languages cover a lot of material related to Haskell's system
11:12:53 <Chousuke> so if you have a comonad w a, the w is the context, and with extract you take "a" from the context? and extend seems to be that given a function  w a -> b, you get a function w a -> w b that in essence returns b to the context? hm
11:13:00 <Philippa> (er, +books in there somewhere)
11:13:08 <killy9999> I'd like to understand the basics and theoretical background for some of Haskell's type extensions
11:13:16 <killy9999> Philippa: thanks, I'll take a look
11:14:13 <killy9999> Oh, I probably should not admit that, but I have that book on my disk...
11:14:32 <asti> Aren't comonads essentially monads which compose in the other direction?
11:15:29 <Chousuke> asti: it might be something like that, but the question is, what exactly does that mean?
11:16:12 <asti> Well, in text form, bind takes in an amplified value,,
11:16:18 <asti> unwraps it,
11:16:32 <elliott> that's not quite accurate
11:16:34 <Chousuke> I tried watching some category theory videos on youtube and while some of it makes sense, a lot of it just doesn't connect to anything :P
11:16:39 <asti> applies a function on the value, and rewraps it
11:16:43 <elliott> since a lot of the time you can have multiple or even 0 "values" of type a inside m a
11:16:46 <elliott> which is half the point of monads
11:17:44 <asti> elliott, you're applying a technicality to an over simplified explanation
11:18:02 <asti> The fact you just said is in the implementation of bind
11:18:10 <eacameron> I'm a noob, so take this with salt, but it seems that the type class hierarchy in haskell is quite convoluted. I'm specifically thinking of the Arrow/Monad distinction, the fmap/map distinction, etc. It's not surprising since, as people discover more abstractions, the hierarchy get's patched again and again. Is there any plan to just organize the whole thing sensibly and then release a (probably non-backwards-compatable) version 
11:18:30 <elliott> asti: it's not a technicality, it's a very important detail that misleads people a lot when they're learning about monads
11:18:44 <elliott> (hence why the simple form of the container analogy doesn't really help people understand, e.g. the [] monad, or State)
11:18:57 <Chousuke> eacameron: the problem with doing something like that is compatibility. Haskell has a standard.
11:18:59 <elliott> State is another good example -- there isn't an "a" in State s a, there's as many "a"s as there are "s"s
11:19:01 <glguy> eacameron: Arrows are mostly a novelty and having a separate name for map and fmap is definitely a good thing
11:19:22 <asti> The monad isn't a container for the value - it's a container for the computation it represents
11:19:23 <eacameron> glguy: unless fmap was renamed to map
11:19:50 <asti> Functors may entirely replace monads one day, who knows.
11:19:57 <elliott> huh??
11:20:05 <elliott> every Monad is a Functor, but the former is strictly more powerful...
11:20:09 <eacameron> Chousuke: I realize that...but why do we live with an outdated standard for so long when we already know a better way of doing it? does the standard buy us anything besides backwards compatability?
11:20:32 <Chousuke> eacameron: backwards compatibility is huge
11:20:32 <elliott> if IO was just a Functor, you wouldn't even be able to write a program that read some text and printed it back out again
11:20:40 <glguy> eacameron: The type class hierarchy gets changed over time, see the Num class, Bits
11:20:46 <Chousuke> eacameron: you don't want to randomly break existing code
11:21:12 <glguy> eacameron: it's good that there is a separate map and fmap, so switching their names would just confuse things and break everything
11:21:12 <ion> Char may entirely replace String one day, who knows.
11:21:14 <typoclass> eacameron: yes and no :-) sure, haskell is decades old, things were discovered, circumstances changed, and so on. the rationale about "fmap vs. map" is that beginners see map very early, and you'd rather have an error message about lists than about "no instance for Functor Something". about Arrow and Monad, i don't know, but i've sometimes heard people say they're not convinced Arrow is the right way to go
11:21:15 <eacameron> Chousuke: of course, but you could keep releasing new versions of the standard, then old code wouldn't break
11:21:30 <ion> By which i mean, of course:
11:21:32 <ion> C
11:21:55 <Chousuke> eacameron: but then you'd need to maintain compilers and standard libraries for all the old standards.
11:22:14 <Chousuke> eacameron: and new libraries wouldn't be compatible with old code, and vice versa.
11:22:22 <Chousuke> lots of problems.
11:22:27 <edwardk> i used to be in favor of map being separate from fmap, but i've pretty much given in and want everything as general as humanly possible now ;)
11:22:44 <edwardk> at least as general as i can reason about without case-specific reasoning
11:22:48 <Chousuke> is there any benefit to having map be separate from fmap?
11:22:59 <edwardk> which cuts off somewhere below Pointed and the classy-prelude
11:23:12 <elliott> classy-lens
11:23:15 * Philippa reckons the teaching solution is mapList and map
11:23:53 <edwardk> Philippa: that would make it clear that map is an example of a larger pattern rather than fmap being an exotic extension to 'such a simple concept'
11:24:02 <edwardk> Philippa: alas the ship has sailed =/
11:24:23 <Philippa> mmm. It also sets you up wonderfully if you have a language where explicit type applications can happen, but meh
11:24:26 <asti> [sarcasm] perhaps I should wrap things in  [/sarcasm]
11:24:32 <Philippa> "mapList is map[List]" etc
11:24:35 <elliott> can we put edwardk in charge of Prelude :)
11:24:39 <eacameron> The way I see it (as a noob, mind you): Haskell is already rediculously hard to get used to (mostly because of all the crazy generalizations). So why don't we just do what haskell is good at and generalize to kingdom come and then teach the noobs how it works. As of now, I have to learn the generalizations AND all the weird oddities how things don't work with this or that or this is a version of that, etc.
11:25:00 <ion> Has anyone asked SPJ what he thinks about whether the type class dependencies will be fixed ever? The more we (FSVO “we”) wait the more painful the change will be.
11:25:01 <parcs`> what weird oddities are you talking about?
11:25:19 <Philippa> ion: I suspect SPJ's response would be a bemused "why are you asking me?"
11:25:31 <ion> s/class dependencies/classes/ that is
11:25:39 <Chousuke> one thing that always gets me is all the liftFoo operators. is there no way to generalise those?
11:25:50 <ion> philippa: He doesn’t have a say in the matter?
11:25:51 <elliott> ion: the standard line seems to be that we should fix all the typeclass stuff after we get a default superclass instance thing
11:25:53 <eacameron> parcs`: like why somethings can be overloaded as strings, others can't. why fmap and map aren't the same, why foldl exists and you should never use it, etc.
11:25:56 <elliott> not convinced of this personally
11:26:04 <Philippa> eacameron: yeah. There're some cases that ought to be a slam-dunk like Applicative => Monad, but...
11:26:35 <typoclass> eacameron: interesting idea. however, it's not always clear in which direction to generalize. and only time and practice can tell which generalizations are useful at all. Functor and Applicative turned out to be useful. people these days seem to be convinced that Pointed isn't useful (which lies in between Functor and Applicative)
11:26:50 <Philippa> ion: sure he does. But really if you want to make it happen or find out if he's going to, there're more appropriate channels nowadays
11:27:19 <Philippa> typoclass: hah! I have a class that generalises Pointed slightly...
11:27:19 <eacameron> typoclass: that makes sense.
11:27:34 <parcs`> eacameron: you shouldn't never use foldl
11:27:38 <eacameron> I'm just frustrated that the slam-dunks aren't dunked yet
11:27:40 <eacameron> that's all!
11:27:40 <elliott> Philippa: class (Category c, Functor f) => Pointy c f where pointed :: c a (f a)?
11:27:41 <eacameron> ;)
11:27:52 <Blkt> good evening everyone
11:28:08 <Philippa> elliott: nah. It's an evil piece of PolyKindery designed to work with 2-level types
11:28:15 <arcatan> typoclass: hmm, is Pointed a Functor?
11:28:17 <rwbarton> maybe I only want a semigroupoid though
11:28:22 <elliott> Philippa: aww
11:28:23 <typoclass> Philippa: ah. so is it halfway between Pointed and Functor, or halfway between Pointed and something else?
11:28:36 <rwbarton> class (IsCategoryish cat, cat c, Functor f) => Pointy cat c f where ...
11:28:37 <parcs`> too much polymorphism is bad
11:28:51 <Philippa> typoclass: it's not the pointing that's generalised, it's the functoriality
11:29:04 <Chousuke> parcs`: only if it affects performance. :)
11:29:11 <parcs`> the more (ad hoc) polymorphism in your code, the easier it is to make unintentional errors. thus, more and more generalization is not a universally good thing
11:29:19 <eacameron> class (IsGeneralizable g) => *
11:29:20 <typoclass> eacameron: right :-) i guess we all have our frustrations. but progress does happen. e.g., this year Num's constraint on Eq and Show was removed (which had been bugging people)
11:29:22 <elliott> class (Category j, Category k, Category l) => Augh j k l f where 'fmap' :: j (k a b) (l (f a) (f b))
11:29:39 <Philippa> parcs`: Argument doesn't follow. Ad hoc polymorphism is not generalisation
11:29:40 <elliott> :t let 'fmap' = undefined in 'fmap'
11:29:41 <lambdabot> Parse error in pattern: 'fmap'
11:29:42 <rwbarton> sadly that name is not valid
11:29:44 <elliott> aw
11:29:55 <rwbarton> good naming scheme though
11:30:04 <typoclass> arcatan: not sure, i may well be misremembering stuff :-/
11:30:08 <elliott> rwbarton: does .'Foo' work or did you have a prefix
11:30:14 <rwbarton> there was a prefix
11:30:28 <rwbarton> :t let _'fmap' = undefined in _'fmap'
11:30:30 <lambdabot> a
11:30:35 <elliott> edwardk: category-extras had that Augh didn't it
11:30:44 <HaskNoob> I am going through YAHT and in section 3.2.2. there is an example - map Char.toUpper "Hello World". I get a "Failed to load interface for `Char'" error. This is both on Linux ghci and in the latest Haskell platform on Windows 7 (winHGCi and hgci). What do I need to do to sort this out?
11:30:47 <eacameron> parcs`: I'm using hyperbole ;)
11:30:59 <Philippa> FWIW, if anybody wants to know WTF my generalisation's actually doing I'll probably have a release of the lib within the next few months or year at the outermost and people /should/ prod me to find out WTF's going on with it!
11:31:03 <sclv> HaskNoob: use Data.Char
11:31:13 <sclv> we got rid of the top level packages a little while ago
11:31:22 <elliott> HaskNoob: YAHT is a bit out of date, you might want to consider reading another tutorial like LYAH or RWH
11:31:31 <sclv> YAHT is a fine tutorial
11:31:50 <Saizan> Philippa: you could put it up on github or similar in the meantime?
11:32:00 <typoclass> HaskNoob: hello, welcome. i second the recommendation of lyah
11:32:03 <typoclass> @where lyah
11:32:03 <lambdabot> http://www.learnyouahaskell.com/
11:32:04 <edwardk> elliott: Augh? i don't remember adding that type
11:32:15 <Philippa> Saizan: I'm kinda allergic to doing that while I /know/ the current state is utter shite, but hey
11:32:18 <elliott> edwardk: well I assume it had another name :)
11:32:22 <elliott> class (Category j, Category k, Category l) => Augh j k l f where 'fmap' :: j (k a b) (l (f a) (f b))
11:32:39 <Philippa> you miiiight get a 0.01 out of me in another 20-30 well-placed LoC and some subsequent examples, though
11:32:43 <typoclass> HaskNoob: other than that, if you run into these things, you can easily ask in here :-) it's usually just that a name or two have changed
11:32:45 <edwardk> elliott: yes, Control.Categorical.Functor or some such
11:32:46 <Philippa> (and I need it for my blog post series, of course)
11:32:48 <edwardk> CFunctor
11:32:49 <sclv> cfunctor ?
11:32:52 <edwardk> no outer 'j'
11:32:54 <Saizan> Philippa: we'd have something to prod you about :)
11:32:58 <sclv> haha i just read the ref to that in tillman's paper
11:33:02 <HaskNoob> I will take a look at RWH, but having gone through LYAH, it is not suitable for non CS learners like myself.
11:33:08 <elliott> edwardk: no outer j??? useless!
11:33:10 <sclv> i forgot it got a citation
11:33:15 <Philippa> Saizan: true, it's a little evil when mostly it's you and edwardk who know WTF I'm doing
11:33:17 <elliott> what if I want j to be Kleisli IO :P
11:33:22 <edwardk> the outer j is about the definition
11:33:31 <edwardk> so its a 'meta-language' arrow
11:33:37 <elliott> yeah, I know :)
11:33:38 <Chousuke> this makes me think
11:33:46 <rwbarton> could be an enriched functor!
11:33:47 <elliott> also kind of hard to get laws with a generalised j there!
11:33:51 <Chousuke> what is the most general generalisation you can express in haskell? :/
11:33:55 <monochrom> I can't rationalize your frustration of Haskell not being exactly right ("right" according to you anyway). Given that Haskell is designed and evolved by so many other people who are not like me, I rationally expect it to be far from my idea of "right", and I am surprised that it is not too far.
11:34:14 <elliott> Chousuke: class Q a where q :: a
11:34:16 <HaskNoob> sclv - thanks :)
11:34:17 <Philippa> Chousuke: that assumes a single direction of generalisation...
11:34:24 <elliott> (FSVO generalisation, most)
11:34:55 <sclv> the most general generalisation: ($)
11:35:01 <Philippa> not \?
11:35:07 <ion> unsafeCoerce
11:35:15 <Philippa> (this is the moment I talk about PTSes again, isn't it?)
11:35:19 <sclv> nope, you're write, \ is it.
11:35:25 * ion is read
11:35:26 <eacameron> monochrom: you're right: hence the noob disclaimer
11:35:26 <sclv> you don't get more abstract than abstraction!
11:35:34 <sclv> right even
11:35:51 <HaskNoob> typoclass - thanks, that's probably what I will do.
11:36:19 <monochrom> well, to be blunt, that is noob not just to haskell, not just to programming, but noob to cooperating with other people in general
11:36:38 <Saizan> you gotta be able to apply those lambdas though :)
11:37:09 <elliott> Lambda the Ultimate Abstraction
11:37:20 <kranius_> not really
11:37:37 <typoclass> monochrom: how do you mean? he asked pretty specific questions, Arrow vs. Monad and fmap vs. map
11:37:59 <elliott> eacameron: (by the way, the solution to all confusion or problems related to Arrow is to ignore that it exists)
11:38:25 <Saizan> monochrom: what's a bit surprising is that what's perceived as the community consensus is so hard to realize
11:38:25 <eacameron> elliott: thank you, I'll remember (forget?) that
11:38:27 <monochrom> Arrow is seldom used. that takes care one part.
11:38:36 <KBme> hi
11:38:50 <KBme> is it possible to make a statemonad also a readermonad?
11:39:08 <monochrom> having both fmap and map is precisely an instance of some other people seeing "right" differently
11:39:10 <eacameron> monochrom: what do you mean by "hard to realize". hard to perceive? or hard to make it a reality in code?
11:39:22 <ramses_> KBme: kinda, using monad transformers
11:39:26 <monochrom> I did not say those phrases
11:39:34 <Saizan> though i've seen objections to e.g. Applicative => Monad by quite prominent figures
11:39:41 <eacameron> monochrom: haha oops
11:39:45 <Saizan> eacameron: you meant to address that to me i guess
11:39:54 <eacameron> Saizan: yes, thank you
11:39:58 <deech> Hi all, Are there any Hackage examples of Haskell bindings to C++ libraries via C? I've tried looking at wxhaskell but it's too big and complicated.
11:40:07 <Saizan> eacameron: and i meant hard to make it a reality in code
11:40:31 <tromp> @hoogle Reader
11:40:31 <lambdabot> Control.Monad.Reader module Control.Monad.Reader
11:40:31 <lambdabot> Control.Monad.Trans.Reader module Control.Monad.Trans.Reader
11:40:31 <lambdabot> Data.Text.Lazy.Read type Reader a = Text -> Either String (a, Text)
11:40:51 <KBme> ramses_, really? I would've thought it to be easy since ask is just get and local is something that can be done with put …
11:40:51 <eacameron> Saizan: yes, that is true. So many libraries would have to implement the new big abstraction out there: it wouldn't happen very fast
11:41:06 <KBme> ramses_, but yeah, it's a stateT and i want a readerT
11:41:06 <eacameron> Saizan: I guess I didn't realize how "new" Applicative and Functor were
11:41:11 <glguy> deech: first you'll want to find examples of C bindings to C++ libraries and then Haskell bindings to C libraries. You can't do it in one jump
11:41:38 <deech> glguy: Any examples of the C bindings to C++?
11:41:42 <monochrom> perceived consensus is perceived. I am serious. it's perceived only. for example, "we want better records" is a perceived consensus. not a consensus. as long as we do not have "we want exactly the following record system", there is no consensus.
11:41:48 <Saizan> eacameron: oh, i just meant actually getting the patches accepted for the standard libraries
11:42:10 <eacameron> Saizan: oh...gotcha
11:42:31 <Saizan> eacameron: which involves actually going through a discussion on the libraries mailing list and reach a consensus there
11:42:47 <eacameron> Saizan: yeah, that would be tough
11:43:11 <eacameron> monochrom: where is that better records implementation anyway? ;)
11:43:15 <niteria> can I hide / qualify LT?
11:44:58 <monochrom> in practice it seems that all changes are made by narrowing down to a very small group of people before hoping for a consensus. removing Eq and Show from Num was done this way. done on the libraries mailing list only. then it came out, and a lot of people are surprised
11:45:14 <glguy> niteria: import Prelude hiding (Ordering)
11:45:41 <monochrom> an easy corollary is that some of the changes made this way are bound to surprise you
11:47:12 <eacameron> thanks all, this has been enlightening. I must say, despite the few oddities we've mentioned, I still think haskell is most promising language I've ever tried to learn. And still try to learn I will. ;)
11:47:37 <sclv> libraries is where the action is
11:47:49 * eacameron assumes yoda posture
11:50:03 <monochrom> another surprise to many people: new GHC versions forbid some uses of CInt unless you import "CInt(..)" i.e., you also need the data constructor name in scope, not just the type name
11:50:26 <Saizan> oh, for what?
11:50:46 <monochrom> the surprised people do not know that 2 years ago, in Haskell 2010, this rule has already been written
11:51:04 <monochrom> and clearly, Haskell 2010 is consensus of a pretty small group of people
11:51:05 <niteria> glguy: this doesnt seem to work
11:51:32 <paolino> hiding (Ordering (LT)) ?
11:52:05 <niteria> paolino: this works, thanks
11:52:19 <monochrom> for use in "foreign types", i.e., type sigs you use in foreign import/export
11:53:00 <paolino> niteria, LT is a constructor of datatype Ordering
11:53:39 <monochrom> the requirement of "need data constructor name in scope" is new in Haskell 2010. was not required in Haskell 98
11:54:09 <bgamari> Has anyone used repa with boxed Vectors?
11:54:21 <bgamari> I'm a bit suspicious that deepSeqArray might be incorrect
11:54:33 <bgamari> it doesn't seem to be fully forcing the array
11:55:35 <monochrom> and I noticed it, only because I have not found an FFI tutorial I like, so every time I play with FFI, I read again Haskell 2010 or Haskell 98's FFI addendum
11:56:13 <monochrom> naturally, I do not expect most FFI users to do this
12:02:48 <Peaker> import Foo (SomeClass, someMethod)  ,  you don't get a warning about SomeClass not being used, if someMethod is used and is within that class
12:03:09 <Peaker> though if you import SomeClass in a separate import statement from someMethod, then you do get it. Worth a bug report?
12:05:57 <Philippa> Peaker: looks buggy to me
12:06:46 <lispy> has anyone here used Shelly?
12:06:58 <lispy> I'd like to convert their special FilePath type to a String or Text
12:07:10 <lispy> AFAICT that's not supported
12:07:20 <lispy> Which is really obnoxious
12:08:11 <lispy> oh, toTextIgnore
12:08:13 <lispy> of course...
12:08:17 <elliott> isn't it just http://hackage.haskell.org/package/system-filepath
12:08:27 <lispy> elliott: nope, they use a special type
12:08:59 <elliott> lispy: looking at the source code, they don't
12:09:14 <elliott> you can just use http://hackage.haskell.org/packages/archive/system-filepath/0.4.7/doc/html/Filesystem-Path-CurrentOS.html
12:09:28 <lispy> http://hackage.haskell.org/packages/archive/shelly/0.14.3/doc/html/Shelly.html#t:FilePath
12:09:35 <lispy> The haddocks link to the Shelly module
12:09:45 <elliott> right
12:09:47 <elliott> because they re-export it
12:09:59 <elliott> if you look at the module source code, they import Filesystem.Path and use FilePath from there
12:10:55 <lispy> okay, I guess you're right. Haddock can be really misleading sometimes :(
12:11:03 <ParahSail1n> @hoogle FilePath -> String
12:11:03 <lambdabot> System.FilePath.Windows takeBaseName :: FilePath -> String
12:11:04 <lambdabot> System.FilePath.Posix takeBaseName :: FilePath -> String
12:11:04 <lambdabot> System.FilePath.Windows takeExtension :: FilePath -> String
12:11:58 <lispy> ParahSail1n: those are a different FilePath
12:15:18 <ParahSail1n> fromText = FP.fromText . LT.toStrict
12:16:04 <MrWoohoo> how do I find all the types inside Data on http://hackage.haskell.org? It just wants to show me individual type pages
12:19:09 <Heffalump> MrWoohoo: you can't easily; the same namespace might be used across every package
12:19:23 <Heffalump> hoogle can sort of do it but not very accurately: http://www.haskell.org/hoogle/?hoogle=Data
12:20:32 <MrWoohoo> found it… http://hackage.haskell.org/packages/archive/base/latest/doc/html/ but Data.Set isn't mentioned there? *scratches head*
12:20:58 <Igloo> Data.Set isn't in base
12:21:04 <Igloo> it's in containers
12:26:14 <c_wraith> MrWoohoo: the module namespace isn't sealed in any way in haskell. Any package can add a new module that's a child of any existing module.
12:26:52 <MrWoohoo> ah, so I must look in non-base packages as well..
12:27:32 <niteria> @pl \x y -> snd x == snd y
12:27:32 <lambdabot> (. snd) . (==) . snd
12:31:45 <niteria> @pl \x y -> (snd x) `compare` (snd y)
12:31:45 <lambdabot> (. snd) . compare . snd
12:31:54 <niteria> :t on
12:31:55 <lambdabot> (b -> b -> c) -> (a -> b) -> a -> a -> c
12:32:37 <Clint> what is "Dynamic linking required, but this is a non-standard build (eg. prof)." trying to tell me?
12:33:43 <c_wraith> Clint: that you're asking ghc to link the binary dynamically, which it can't do when making a profiling build.
12:34:33 <Clint> c_wraith: but i'm not?
12:34:44 <c_wraith> well, something is
12:35:41 <Clint> i'm just doing ghc -prof -fprof-auto -rtsopts -Wall
12:40:19 <hpaste> jhickner pasted “polymorphic callback” at http://hpaste.org/78373
12:41:04 <jhickner> Hello, is it possible to make a list of callbacks like I'm attempting in this paste?
12:41:20 <jhickner> I just want to constrain them to return a value that can be converted to JSON, that's all
12:42:43 <Cale> jhickner: If the only thing you know about something is that it can be converted to JSON, why not just convert it to JSON to begin with?
12:43:24 <Cale> jhickner: You could make an existential type:
12:43:35 <jhickner> that would work well in this case, but I keep running into this and I want to know if it's possible
12:43:55 <Cale> data JSONable where J :: (ToJSON a) => a -> JSONable
12:44:12 <Cale> and then write your list with J applied to callback1 and callback2
12:44:36 <Cale> But then when you pattern match the J and get the elements out, the only thing you will know is that they are instances of ToJSON
12:44:41 <rwbarton> in this case you gain nothing because applying J is as much work as applying toJSON
12:44:49 <Cale> and so the only thing you can do with the elements is then to apply toJSON to them
12:44:52 <elliott> jhickner: it's generally not something you want to do
12:45:00 <Cale> So you might as well have done this in the first place
12:45:13 <elliott> http://www.haskell.org/haskellwiki/FAQ#How_do_I_make_a_list_with_elements_of_different_types.3F (and the next question)
12:45:15 <Cale> (and laziness means that you don't have to worry about paying the cost of this up front)
12:45:25 <elliott> plus http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/ is semi-related
12:45:48 <Cale> There *are* good use-cases for existential types, but something like this is not one of them :)
12:46:00 <jhickner> ok, that makes sense
12:46:11 <jhickner> thanks guys. and I'll check out those links
12:46:52 <monochrom> your current example needs only M.HashMap String Value
12:47:36 <monochrom> [("foo", toJSON 1), ("bar", toJSON "a string")]
12:48:49 <monochrom> you may have an interesting case for existential types if you need M.HashMap String (something -> something). that is, when it is worthwhile to say "callback"
12:49:04 <jhickner> right, my example is pretty contrived
12:49:13 <Cale> jhickner: This sort of situation is a kind of case where it can be good to take an "object oriented" approach to the situation, and ask yourself: "What operations do I need on these values in my list?" -- If you can decide which "methods" the objects have, or which "messages" they respond to, then you can make a record of how each of them would respond in each case -- and this will suffice for the remainder of your pro
12:49:13 <Cale> gram as an abstraction of the various original types.
12:49:14 <jhickner> the actual callbacks are more complex
12:50:36 <monochrom> but then, with "something -> something", I can see how to avoid existential types too
12:51:51 <Cale> jhickner: In doing this, it's very convenient that functions are first class values (so your "messages" can have parameters too)
12:51:57 <monochrom> instead of M.HashMap String (exists a. ToJSON a => something -> a), I'm seeing M.HashMap String (something -> Value)
12:52:45 <Cale> jhickner: Does that make some amount of sense?
12:53:09 <monochrom> and at the value level, instead of ("foo", (callback :: something -> Int)), I'm seeing ("foo", toJSON . (callback :: something -> Int))
12:53:32 <jhickner> @Cale yeah that does make sense. I was hoping there was a less verbose way to go about it but I think I'm getting why it's necessary
12:53:32 <lambdabot> Unknown command, try @list
12:55:30 <Cale> jhickner: So, for example, let's say you need both a way to convert the things to JSON, and I dunno, a way to step them forward in time by some Double value :)
12:55:35 <jhickner> ahh interesting storing a lambda that calls toJSON in the hashmap is cool
12:56:02 <Cale> data Object = O { json :: JSON, step :: Double -> Object }
12:56:31 <Cale> You can now make a function like:
12:57:30 <neutrino_> hi
12:57:42 <neutrino_> i've seen someone do something like Just{}. what does this notation do?
12:58:08 <tac> @type Just{}
12:58:09 <lambdabot> Maybe a
12:58:14 <c_wraith> as a pattern match, it matches on the constructor, without caring about the value
12:58:17 <Cale> neutrino_: matches like  Just _
12:58:26 <c_wraith> as a value, it's similar to Just undefined
12:58:32 <c_wraith> > Just{}
12:58:33 <neutrino_> right, but that's not the same, right?
12:58:34 <lambdabot>   Just *Exception: <interactive>:3:1-6: Missing field in record construction
12:58:37 <neutrino_> how does this notation work?
12:58:42 <c_wraith> it's record notation
12:58:44 <neutrino_> ok, "record construction"
12:58:47 <neutrino_> right
12:58:54 <neutrino_> this way you can use every constructor, right?
12:59:07 <neutrino_> instead of specifying fields one by one just use an empty record?
12:59:17 <basdirks_> have lenses for Map been removed lately?
12:59:43 <Cale> jhickner: rocket pos vel accel = O { json = toJSON (M.fromList [("position", toJSON pos), ("velocity", toJSON vel)]), step = \dt -> rocket ... }
12:59:46 <neutrino_> @type Maybe{}
12:59:47 <elliott> basdirks_: no, you can use _at and stuff
12:59:47 <lambdabot> Not in scope: data constructor `Maybe'
12:59:49 <neutrino_> er
12:59:58 <neutrino_> @type Left{}
12:59:59 <lambdabot> Either a b
13:00:02 <basdirks_> elliott, ok, thanks
13:00:06 <neutrino_> @type (,){}
13:00:07 <lambdabot> (a, b)
13:00:14 <neutrino_> nice
13:00:23 <neutrino_> @type (->){}
13:00:24 <lambdabot> parse error on input `->'
13:00:31 <neutrino_> oh, you can't do that, i guess
13:00:46 <Cale> jhickner: Where the idea is that the arguments to the recursive call to rocket will have the appropriately updated position and velocity.
13:01:00 <Cale> (I could write out the math there, but it would just be distracting)
13:01:03 <chersanya> hi! How to do such things in one comprehension? I guess it's related to monad transformers...     fnames' <- liftIO $ getDirectoryContents "..."     let fnames = [fname | fname <- fnames', <conditions>]
13:01:35 <Cale> chersanya: What?
13:01:38 <neutrino_> chersanya: why do you want to do this?
13:01:46 <Cale> chersanya: I don't understand what you're asking for.
13:01:50 <neutrino_> Cale: he wants to put fnames' <- ... in the comprehension.
13:02:02 <Cale> chersanya: you can't getDirectoryContents from inside a list comprehension.
13:02:15 <tac> > Just {}
13:02:16 <monochrom> eh? you have the [] Monad, the IO Monad, and one other unnamed Monad, no?  one comprehension cannot cross 3 different Monads. not even 2.
13:02:17 <lambdabot>   Just *Exception: <interactive>:3:1-7: Missing field in record construction
13:02:30 <tac> > let x = Just {} in "Hello"
13:02:32 <chersanya> I want to filter output of getDirectoryContents (or other IO [a] functions) in a list comprehension
13:02:32 <lambdabot>   "Hello"
13:02:47 <neutrino_> Cale: that's surprising, wouldn't liftIO let you do gDC?
13:03:11 <ion> (\xs -> [ x | x <- xs ]) <$> getDirectoryContents …
13:03:36 <chersanya> (liftIO is there because the whole thing is happening in a happstack server monad)
13:03:58 <chersanya> ion: nice idea))
13:04:01 <Cale> neutrino_: The list monad is not a transformed IO monad.
13:04:06 <Cale> neutrino_: so no
13:04:36 <Cale> liftIO takes an IO action and turns it into an action in some other monad which is constructed in some way in terms of IO.
13:04:37 <neutrino_> Cale: ok
13:04:49 <neutrino_> Cale: there's ListT, isn't there?
13:05:05 <atriq> Isn't ListT the evil one?
13:05:06 <Cale> i.e. it elaborates it with whatever other structure is required to make it an action in the new monad
13:05:15 <Cale> There is ListT, except ListT IO isn't a proper monad.
13:05:18 <neutrino_> atriq: is it? why?
13:05:36 <atriq> It requires the inner monad to be commutative or something
13:05:37 <Cale> ListT m requires m to be a commutative monad in order to be a monad.
13:05:40 <Cale> yeah
13:05:51 <Cale> There's also LogicT, and LogicT IO will be a proper monad.
13:05:54 <neutrino_> does it?
13:05:56 <neutrino_> hmm
13:05:57 <neutrino_> ok
13:05:57 <atriq> I think that means that (a >=> b) = (b >=> a)
13:05:58 <Cale> But I don't think that's relevant at all.
13:06:06 <Cale> atriq: yes
13:06:10 <Cale> uhh
13:06:18 <neutrino_> what's LogicT?
13:06:22 <copumpkin> wait waht
13:06:24 <Cale> actually, let's just say
13:06:25 <atriq> Liquid awesome
13:06:32 <neutrino_> ?
13:06:36 <Cale> it means do u <- x; v <- y; f u v
13:06:38 <Cale> is the same as
13:06:38 <chersanya> and why is such an intuitive thing impossible?
13:06:42 <scooty-puff> neutrino_: check hackage for logict
13:06:44 <Cale> do v <- y; u <- x; f u v
13:06:46 <copumpkin> yeah
13:06:48 <copumpkin> that
13:06:50 <copumpkin> :P
13:07:19 <Cale> I don't know if that actually implies that the fish commutes whenever it makes sense to commute it -- possibly not.
13:17:06 * osfameron reads "the fish commutes", decides the channel is full of crazy people, and backs out slowly
13:17:22 <xunatai> the fish operator
13:17:30 <xunatai> >=>
13:18:27 <citizen93> Hey, I have a small question. Can someone give me a hint how I can make a chain of functions like: start f1 f2 f3 f4 ... fn stop. That can be executed without function composition or any other things except the function application?
13:18:43 <citizen93> I can use Monads though
13:18:43 <Ferdirand> is that homework ?
13:18:54 <citizen93> yes
13:18:59 <citizen93> I would like a hint only please
13:20:26 <citizen93> because I keep getting errors about that start is applied to too many arguments and maybe I thought I could use a lift function, however lift functions are only applied to a limited amount of args.
13:23:33 <Cale> citizen93: I could give you the types of start and stop, perhaps :)
13:24:29 <Cale> make: start :: (() -> t) -> t
13:24:31 <citizen93> that would be good, but not more please =)
13:24:41 <Cale> and stop :: (t, s) -> t
13:25:20 <niteria> is defer typechecks to runtime available in ghci?
13:25:40 <sclv> should be, if you have a recent enough version
13:25:51 <rwbarton> (7.6)
13:25:52 <Cale> Well, I'm not really sure what the meaning of the program you wrote was supposed to be, but there is a way to embed a forth-like language in Haskell using this start and stop
13:25:57 <geekosaur> ghci kinda *is* runtime, though, so not clear how that would work
13:26:13 <sclv> it doesn't defer to runtime, it defers till you hit them
13:26:21 <citizen93> oh you can see it as ASM
13:26:24 <citizen93> assembly
13:26:25 <niteria> I want :r to just do what it can do
13:26:37 <sclv> so if you throw away ("hi" + 1) before you try to reduce it
13:26:41 <niteria> and not fail if I have type error
13:26:43 <sclv> then you don't get an error
13:26:47 <citizen93> but I figured that the f1 f2 f3 ... fn functions do not really matter
13:27:02 <citizen93> as I have no problems implementing those
13:27:48 <Chousuke> is that "start f g h stop" literally what should work? do you control the types of the fs?
13:28:13 <citizen93> yes
13:28:21 <citizen93> start f g h stop should literally work
13:28:32 <citizen93> I define the types of f g and h
13:28:56 <citizen93> you can see it as a stack based language
13:29:02 <citizen93> that can for example put someting on a stack
13:29:19 <citizen93> like start put 'A' stop
13:29:20 <citizen93> should work
13:29:27 <citizen93> however
13:29:33 <citizen93> I get the problem
13:29:42 <citizen93> that start is applied to too many arguments
13:29:53 <niteria> damn, newest haskell-platform on ubuntu is 7.4.1
13:30:10 <citizen93> ofcourse you can say that I can put parentheses and use (.) etc., but it should work without these...
13:30:26 <Philippa_> niteria: That's the current Platform's version of GHC, yes
13:30:50 <niteria> so, no defer for me
13:31:21 <Chousuke> citizen93: are you not allowed to use eg. parentheses? :/
13:31:38 <citizen93> start f g h stop <-- should work without parentheses
13:32:46 <citizen93> I figured maybe I should be doing something like the do statement, however I'm not very sure... and I figured maybe you guys had a suggestion or a hint
13:33:15 <tdammers> the -> functor maybe?
13:33:30 <zypper> Is there a way to make a tuple an instance of a typeclass? `instance Foo (Int,Int) where ...' doesn't seem to work.
13:33:50 <Ferdirand> mhh
13:33:58 <sipa> zypper: that should work, i think
13:34:02 <Ferdirand> i think i just reached enligthenment about this Mu business
13:34:07 <sipa> zypper: which typeclass?
13:34:36 <zypper> sipa: Not in ghci and ghc 7.4.2, unless I'm doing something wrong. >_>
13:34:53 <rwbarton> did it give an error telling you to turn on a particular language extension?
13:35:34 <zypper> sipa: A user-defined typeclass I declared just for testing a very simple case.
13:36:26 <zypper> rwbarton: I'll paste a log from ghci. >_>
13:36:36 <sipa> zypper: turn on FlexibleInstances
13:37:03 <Cale> citizen93: This is something which I think is really hard to get right if you haven't seen it done before
13:37:28 <Cale> citizen93: I'll give the types of push and pop as well
13:37:45 <Cale> push :: a -> b -> ((a, b) -> t) -> t
13:37:56 <Cale> pop :: (a, b) -> (b -> t) -> t
13:38:35 <Cale> add :: Num a => (a, (a, b)) -> ((a, b) -> t) -> t
13:39:06 <zypper> sipa: Thanks, that works. :D
13:39:16 <Cale> citizen93: From these type signatures, you should be able to write the definitions and see how it works :)
13:39:27 <citizen93> yes, your types differ a bit from mine
13:39:30 <citizen93> thank you for the tip
13:40:20 <citizen93> cause my function do work, however not without additional parentheses and function compositions :(
13:40:25 <Cale> citizen93: the key is that the last parameter to any of the operations is a function which takes the result of the operation as its parameter
13:40:39 <citizen93> OH!
13:40:52 <citizen93> I think I get it!
13:40:53 <Cale> i.e. you'll always have something like  ... -> (r -> t) -> t
13:41:00 <Cale> where r is the result type of the operation
13:41:10 <citizen93> yes indeed!
13:41:12 <Cale> and t is completely polymorphic
13:41:40 <citizen93> I think everything falls right on its place
13:42:01 <citizen93> thank you for the amazing hint Cale
13:42:06 <Cale> no problem :)
13:42:24 <citizen93> the one sentence is the only thing I needed "the key ... parameter"
13:43:17 <Cale> Yeah. This sort of thing is more generally known as continuation passing style
13:48:51 <citizen93> Thanks again Cale for the background information and the hints! Have a nice day!
13:50:07 <niteria> is there a nice tree-ish varsion of Show?
13:50:49 <rwbarton> feel like i am mind-reading here but have you tried groom?
13:54:24 <niteria> rwbarton: awesome, your mind-reading skill have just leveled up
13:54:33 <dropdrive> I'd like to make definitions like "a = b+c; b = c*d+f(x)" and then be able to inspect the dependencies, e.g. "might a depend on x?"  Is there a "native" way to do this or do I have do build up datastructures like "a = Add b c" etc.?
13:57:24 <ClaudiusMaximus> dropdrive: if you rephrase it as "is a strict in x" you might get away with something like http://hackage.haskell.org/package/ChasingBottoms
13:58:14 <ClaudiusMaximus> at least, that's if my naive lack of understanding is ok..
14:00:55 <cmears> maybe you could do something like that with the vacuum package
14:01:08 * hackagebot git-annex 3.20121127 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121127 (JoeyHess)
14:05:22 <victorm> hi!
14:05:33 <victorm> how can i know the source line of an error in haskell?
14:06:06 <Clint> put it into the error message?
14:06:57 <ocharles> victorm: hi, you have a few options
14:07:09 <ocharles> the 'easiest' is producing the error in ghci and using the debug tools
14:07:46 <victorm> ocharles: like: error "undefined procedure" ?
14:08:14 <ocharles> i haven't seen that error before, but I guess so
14:08:22 <victorm> I'm just starting in Haskell, so I don't know which tools should I use :)
14:08:29 <ocharles> http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/ghci-debugger.html see 2.5.6
14:09:00 <ocharles> i believe on new GHCs you can also do +RTS -xc: http://www.haskell.org/ghc/docs/7.0.1/html/users_guide/prof-time-options.html
14:09:13 <ocharles> (that is, run your program as ./program +RTS -xc)
14:09:30 <`nand`> GHC errors start with file:line:column
14:09:47 <`nand`> oh
14:09:51 <`nand`> you mean a runtime error
14:10:14 <ocharles> i think that's what victorm means
14:10:18 <victorm> yep
14:15:42 <victorm> ok, dum question now...
14:16:12 <victorm> how I can feed some data to the main function though stdin inside the ghci interpreter?
14:16:38 <Botje> run main and type stuff.
14:16:53 <monochrom> this assumes main is written to read stdin to begin with
14:18:48 <victorm> the problem is that I've been using getArgs
14:19:24 <rwbarton> well yes that is different then. :set args
14:19:33 <victorm> yes, sorry :)
14:21:31 <monochrom>  :main hello
14:22:27 <monochrom> then again, :set args hello is more permanent if you are testing the same argument all the time
14:26:07 <ocharles> another option is writing mainArgs :: [String] -> IO (), and then having main = getArgs >>= mainArgs
14:26:35 <elliott> :t withArgs
14:26:36 <lambdabot> Not in scope: `withArgs'
14:26:38 <elliott> hm
14:27:03 <elliott> right
14:27:05 <elliott> withArgs :: [String] -> IO a -> IO a
14:27:08 <elliott> so you don't need mainArgs
14:27:14 <elliott> or rather you can define mainArgs as mainArgs args = withArgs args mani
14:27:16 <elliott> *main
14:28:24 <victorm> :)
14:28:45 <victorm> ok, I made it work with :set args and used :back to trace the problem
14:28:50 <victorm> =D
14:29:14 <ocharles> elliott: ah, thanks :)
14:29:37 <ocharles> :t System.Environment.withArgs
14:29:38 <lambdabot> [String] -> IO a -> IO a
14:29:43 <ocharles> there we go
14:29:52 <pdxleif> How do I turn an IO into a ResourceT IO?
14:29:59 <pdxleif> I'm in a WAI response handler.
14:30:07 <pdxleif> I just wanna call "print".
14:30:27 <hpc> :t lift -- pdxleif
14:30:28 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
14:30:38 <pdxleif> Thanks!
14:30:42 <hpc> should work if ResourceT is sanely written
14:30:49 <pdxleif> I was trying liftM for some reason... knew it was long those lines.
14:30:56 <ocharles> more generally you may want to learn about liftIO
14:30:57 <ocharles> :t liftIO
14:30:59 <lambdabot> MonadIO m => IO a -> m a
14:31:07 <geekosaur> you might want liftIO if it's a MonadIO, yeh
14:31:38 <hpc> ResourceT is properly kinded for plain old lift
14:32:33 <ocharles> sure, i'm just providing more resources for similar problems
14:33:04 <pdxleif> :i liftIO
14:33:14 <pdxleif> @info liftIO
14:33:14 <lambdabot> liftIO
14:33:19 <geekosaur> :i doesn't work with lambdabot
14:33:26 <geekosaur> and @info isnt what you hope
14:33:51 <geekosaur> (I think it edit-distances to @undo)
14:34:01 <`nand`> yes
14:34:06 <`nand`> @info do { a <- b; c a }
14:34:07 <lambdabot> b >>= \ a -> c a
14:37:21 <pdxleif> The liftIO from Control.Monad.IO.Class, I guess?
14:38:32 <pdxleif> Yay, I can IO
14:40:05 <ocharles> that's the one
14:40:56 <ocharles> edwardk: is it right to say 'a projection is like an isomorphism, but partial in one direction?'
14:41:12 <ocharles> i have some free time so i figured I'd provide that doc patch at last
14:41:32 <hpc> ocharles: i think so, yes
14:41:32 <edwardk> ocharles: yes
14:41:43 <hpc> in particular, a projection is partial in the "reverse" directon
14:42:14 * ocharles nods
14:42:58 <hpc> in (A projected onto B), all of A casts a shadow, but not all of B is dark
14:42:58 <edwardk> ocharles: a projection is a traversal, which also contains an 'injection' or embedding in the opposite direction.
14:42:59 <edwardk> consider _head. that is a traversal of the head of a list. you can use it to modify the head.
14:42:59 <edwardk> you can also   5^.remit _head  to get a list such that 5 is the head and nothing else holds.
14:42:59 <edwardk> [5]
14:43:10 <ocharles> oh I get how it all works
14:43:10 <MrWoohoo> Hmmm, Data.Set doesn't support duplicates in the set. What alternative type should I look at?
14:43:11 <edwardk> likewise 5^.remit last
14:43:14 <ocharles> i just wanted to document it correctly
14:43:29 <ocharles> make sure my terms are all correct, etc
14:43:52 <ocharles> oh, it's no longer 'by'?
14:44:18 <edwardk> ocharles: yeah MonadComprehensions takes 'by' as a keyword for some reason (it should just be TransformListComp)
14:44:36 <edwardk> so i felt the need to get out of the way ;)
14:45:10 <ocharles> ah
14:45:10 <edwardk> review/reviews were strengthened so they can work with any projection not just iso, so remit fit the use of the re- prefix from those, and reuse, reuses
14:45:43 <elliott> you need to define a less general mit :)
14:47:12 <`nand`> MrWoohoo: MultiSet
14:47:39 <MrWoohoo> thanks. which package is that in?
14:47:46 <`nand`> multiset
14:47:53 <MrWoohoo> makes sense LOL
14:59:48 <monochrom> I like the name "bag" better than the name "multiset". shorter name, also Dijkstra's favourite name :) (not sure who coined it)
15:01:55 <scooty-puff> maybe a silly question, but if Integer's are being used to tag things for to emulate identity comparison, would it make sense to have the first tag start at fromIntegerl (minBound :: Int)?
15:02:15 <scooty-puff> (assuming each tag is computed from the previous via (+ 1))
15:03:18 <geekosaur> not a whole lot with the usual Integer implementation
15:03:20 <Susanne> i want to make a list with only the fst of the tupel from the list : cBit list1 list2 = foldl (\ac a -> ac ++ [fst a])  [] (zip list1p list2p)
15:03:52 <ocharles> lens question! let maybeInt = (projecting Just $ \f m -> case m of { Just i -> Just <$> f i ; Nothing -> pure Nothing }) :: SimpleProjection (Maybe Int) Int -- gives me 'No instance for (Projective k0)'
15:03:56 <ocharles> How should I type annotate this?
15:04:14 <ocharles> Using the instance Projective (->) would seem to be fine
15:04:26 <Susanne> why is my result list 2 x the length of my touple list
15:04:28 <Susanne> ?
15:04:28 <elliott> if you use that instance then it won't be a Projection :)
15:05:02 <monochrom> but Int is not Integer. so I think minBound is a good starting point
15:05:35 <ocharles> elliott: hmm, then which instance is Control.Lens.Exception.Lens.exception using?
15:05:35 <monochrom> oh wait, fromIntegral (minBound :: Int). nevermind, that doesn't add any advantage
15:06:00 <parcs`> Susanne: what's list1p and list2p
15:06:16 <Susanne> *Main> cBit [I,I,I,I,I,I] [O,I,O,I] [I,I,I,O,I,O,I,O,I,O,O,O]
15:06:16 <elliott> ocharles: you'll have to ask edwardk about Projective I'm afraid, I have no idea beyond that
15:06:44 <Susanne> normally my result list must have length 6
15:06:52 <Susanne> not 12 :(
15:06:58 <edwardk> whats the question?
15:07:04 <Susanne> there are only 6 fst of the touples
15:07:05 <ocharles> edwardk: see my let binding above
15:07:17 <edwardk> ocharles: is this in head or 3.6?
15:07:20 <ocharles> head
15:07:35 <edwardk> if you turn on NoMonomorphismRestriction?
15:07:39 <ocharles> i'm figured a projection between Maybe Int and Int would make a trivial example
15:07:49 <ocharles> aha
15:07:54 <ocharles> bloody monomorphism restriction
15:07:58 <monochrom> Susanne: you should answer parcs`'s question
15:08:38 <ocharles> thanks edwardk!
15:11:03 <edwardk> Having -finline-all-the-things would make writing lens a lot easier.
15:11:31 <elliott> -finline-functions
15:11:41 <elliott> but does it inline 0-argument functions??
15:11:59 <sipa> what is a 0-argument function?
15:12:22 <edwardk> it is a function that brooks no arguments.
15:12:23 <monochrom> a value whose type is not X->Y
15:12:45 <elliott> sipa: it isn't
15:12:47 <monochrom> getLine and True are 0-argument functions
15:12:49 <ion> elliott: How about IO functions??
15:13:00 <elliott> monochrom: and depth-0 lists
15:16:46 <madjestic> victorm: does not it show it in sdtout?
15:17:47 <victorm> madjestic: nope, it just gives the error message
15:17:51 <victorm> not the line number
15:19:09 <lpsmith> ok,  when compiling the Haskell Platform from source,  is there a handy way to build the haddocks as well?
15:20:38 <ion> The Haddocks? Would documentation: True in ~/.cabal/config work?
15:21:39 <Susanne> < foldl (\acc a ->acc++ fst s) [] [(1,2),(2,3)(4,5)]
15:21:43 <elliott> > not <
15:21:45 <lambdabot>   <hint>:1:6: parse error (possibly incorrect indentation)
15:21:47 <Susanne> > foldl (\acc a ->acc++ fst s) [] [(1,2),(2,3)(4,5)]
15:21:49 <lambdabot>   Couldn't match expected type `(a0, b0)'
15:21:49 <lambdabot>              with actual type `Debu...
15:22:13 <Susanne> > foldl (\acc a ->acc++ fst a) [] [(1,2),(2,3)(4,5)]
15:22:14 <lambdabot>   The function `(2, 3)' is applied to one argument,
15:22:14 <lambdabot>  but its type `(t0, t1)' ...
15:22:39 <Susanne> > foldl (\acc a ->acc++ fst a) [] [(1,2),(2,3),(4,5)]
15:22:41 <lambdabot>   No instance for (GHC.Num.Num [a0])
15:22:41 <lambdabot>    arising from a use of `e_1122345'
15:22:41 <lambdabot>  Po...
15:22:49 <Susanne> wtf
15:23:06 <Stacky> Maybe try acc ++ [fst a]?
15:23:19 <lpsmith> ion:  well but if you compile the haskell platform from source,  it has it's own makefile
15:23:56 <ion> lpsmith: Ah, ok.
15:24:26 <lpsmith> Susanne:
15:24:35 <lpsmith> oh, you caught it
15:24:42 <lpsmith> err
15:24:53 <Susanne> > foldl (\acc a ->acc++ [fst a]) [] [(1,2),(2,3),(4,5)]
15:24:55 <lambdabot>   [1,2,4]
15:25:09 <pizzaplane> Does anyone know if you can get GHCi to show you the expansion of a type synonym?
15:25:31 <lpsmith> pizzaplane, try :info
15:25:58 <lispy> Is there a 'putTextLn' function?
15:26:03 <lispy> ?hoogle Text -> IO ()
15:26:03 <lambdabot> Data.Text.IO putStr :: Text -> IO ()
15:26:03 <lambdabot> Data.Text.Lazy.IO putStr :: Text -> IO ()
15:26:03 <lambdabot> Data.Text.IO putStrLn :: Text -> IO ()
15:26:17 <lispy> ah, I see, still called putStrLn
15:26:47 <axkrts> hello
15:26:51 <axkrts> another newbie question
15:27:00 <Susanne> < foldl (\acc a ->acc++ fst s) [] (zip [1,2,3,4,5,6,7,8] [1,2,3,4,5,6,7,8])
15:27:16 <axkrts> I am looking for this function: Monad m => m a -> a
15:27:38 <lpsmith> axkrts:  there is no such function in general
15:27:40 <Stacky> axkrts, depending on what monad it is, that might not exist
15:27:55 <lpsmith> axkrts, many monads have such a function, but not all
15:28:14 <axkrts> basically, I want to get "the thing" out of the monad
15:28:20 <Susanne> < foldl (\acc a ->acc++ [fst s]) [] [(1,2),(2,3)(4,5)]
15:28:30 <lpsmith> axkrts, you probably don't need to
15:28:53 <lpsmith> you probably want to take whatever operations you want to do on that value and lift them into the monad
15:28:56 <ion> axkrts: What you really want is either “Monad m => (a -> m b) -> m a -> m b” or “Monad m => (a -> b) -> m a -> m b”. Whatever you want to do with the “a” can be done by the function you pass as the first parameter to one of them.
15:29:17 <pizzaplane> I guess what I really want to do is evaluate type expressions containing synonyms
15:29:22 <ion> axkrts: The first one is known as (=<<) (or with parameters flipped, (>>=)). The second one is known as (<$>) and fmap.
15:30:05 <lpsmith> pizzaplane, I'm not aware of any such functionality,  but maybe somebody else has an idea
15:30:15 <nkpart> Does anyone know how hoogle (cmd-line) figures out its data directory?
15:30:24 <pizzaplane> like if I have: type Foo a = [[a]], I'll be able to show ghci "Foo (Foo a))" and get  "[[[[a]]]]"
15:30:31 <axkrts> hmmm... this is tricky
15:30:47 <Stacky> what monad are you using, maybe we can help :)
15:30:58 <axkrts> Get from Data.Binary
15:31:17 <Clint> runGet "gets it out"
15:31:42 <niteria> is there a function that would pretty print an expression with as few parentesis as possible?
15:31:53 <ion> axkrts: Data.Binary is a bit evil, Data.Serialize from cereal is better. It will let you handle parse errors gracefully.
15:32:16 <pizzaplane> lpsmith, thanks for responding anyway
15:32:58 <lpsmith> pizzaplane, lambdabot has some stuff like that though
15:33:10 <niteria> I actually don't mean pretty print, just print with parentesis
15:33:18 <lpsmith> @unmtl  ReaderT Cont Int a
15:33:18 <lambdabot> Plugin `unmtl' failed with: `Cont' is not applied to enough arguments, giving `/\A B. (B -> A) -> A'
15:33:24 <pizzaplane> ok I'll check that out
15:33:33 <lpsmith> @unmtl  ReaderT (Cont b) Int a
15:33:34 <lambdabot> Plugin `unmtl' failed with: `Cont b' is not applied to enough arguments, giving `/\A. (A -> b) -> b'
15:33:49 <axkrts> ion: because it uses Maybe and Either ?
15:35:16 <ion> axkrts: Yeah. Data.Binary.decode :: … => ByteString -> a (will throw exceptions), Data.Serialize.decode :: … => ByteString -> Either String a
15:35:58 <axkrts> ion: oh hey, and strict bytestrings... nice
15:36:13 <axkrts> i don't particularly need lazy here
15:38:14 <monochrom> niteria: that depends on what is "expression". either it is your own data type and so you have to write it yourself, or it is from an existing library and you use that library
15:42:03 <axkrts> Clint: how can I use runGet within the get method of an instance of Binary?
15:45:05 <niteria> monochrom: it's my own type, I'm just thinking one could define some typeclasses that would allow to do this for any type
15:46:05 <niteria> typeclass for precedence, typeclass for associativity
15:46:44 <Clint> axkrts: well, this is for cereal, but  do thingy <- getThingy; case (runGet (getOtherthingy) thingy) of Left e -> fail somethingorother; Right other -> return other
15:47:07 <niteria> but if there was an existing library that worked on its own type that would help me too
15:47:53 <niteria> I'm having a hard time trying to come up with rules that make number of parenthesis minimal
15:49:16 <niteria> what I have sort of works, but doesn't consider associativity
15:54:13 <Ralith> a cabal package is giving me the error:
15:54:13 <Ralith> <command line>: cannot satisfy -package Cabal-1.14.0
15:54:19 <Ralith> when I try to configure it
15:54:22 <Ralith> anyone know what might be wrong?
15:55:04 <dcoutts_> Ralith: you've likely got two instances of that version of the Cabal lib
15:55:15 <Ralith> "that version?"
15:55:27 <dcoutts_> Ralith: see ghc-pkg list Cabal
15:55:39 <Ralith>    Cabal-1.16.0
15:55:41 <Ralith> is the only result
15:56:02 <dcoutts_> hmm
15:56:35 <Ralith> verbose tells me that this is when it fails:
15:56:35 <Ralith> creating dist/setup
15:56:35 <Ralith> /usr/bin/ghc --make ./Setup.hs -o ./dist/setup/setup -odir ./dist/setup -hidir ./dist/setup -i -i. -package Cabal-1.14.0
15:56:54 <Ralith> I'm confused as to why cabal 1.16 seems to be trying to use cabal 1.14
15:57:05 <Ralith> if that's actually what's happening
15:57:11 <dcoutts_> it must think it's installed, it does look
15:57:47 <Ralith> I certainly have no idea how to fix it.
15:58:09 <dcoutts_> Ralith: you've just got the one ghc and ghc-pkg installed right?
15:58:17 <Ralith> afaik.
15:58:22 <ocharles> edwardk: thanks for elaborating, this documentation is fantastic!
15:58:30 <dcoutts_> there's no chance it's looking at a ghc-pkg that doesn't correspond to your ghc
15:58:33 <dcoutts_> ?
15:58:54 <edwardk> ocharles: if you find something missing from the docs, please feel free to take a rough stab at it ;)
15:58:55 * Ralith executes find / -name ghc-pkg
15:58:58 * Ralith only finds one.
15:59:26 <edwardk> https://github.com/ekmett/lens/issues/131 it was an open issue to fix docs, in particular that one =)
15:59:28 <Ralith> dcoutts_: so, no chance.
16:00:00 <ocharles> in fact, that both example is very cool
16:00:55 <ocharles> edwardk: i'll see what i can do!
16:01:20 <edwardk> it even worked first try ;)
16:01:30 <dcoutts_> Ralith: try a cabal clean
16:01:40 <Ralith> dcoutts_: same error.
16:01:50 <Ralith> this time from /usr/bin/ghc --make ./Setup.hs -o ./dist/setup/setup -odir ./dist/setup -hidir ./dist/setup -i -i. -package Cabal-1.14.0
16:02:13 * dcoutts_ is just looking at the code in cabal for picking the version
16:03:48 <dcoutts_> Ralith: the odd thing is that it's checking the ghc-pkg database and then picking the latest
16:04:13 <dcoutts_> Ralith: if you use -v3 we should get some more hints
16:04:23 <dcoutts_> Ralith: clean then configure with -v3
16:05:29 <Okasu> http://dfns.dyalog.com/max_examp.htm is haskell a standalone max version?
16:06:28 <Ralith> dcoutts_: in both cases, "Using Cabal library version 1.14.0
16:06:31 <Ralith> " appears.
16:06:35 <hpc> Okasu: that's scary
16:06:37 <Ralith> do you want the full paste?
16:06:42 <hpc> it's almost exactly haskell
16:06:45 <dcoutts_> Ralith: hpaste.org perhaps
16:06:50 * Ralith nod
16:06:53 <dcoutts_> ta
16:07:10 <Okasu> hpc: yeah, it was very suprising when i found it
16:07:47 <hpaste> Ralith pasted “Cabal version issues” at http://hpaste.org/78382
16:07:56 <Ralith> dcoutts_: ^
16:09:06 <Okasu> http://dfns.dyalog.com/max_scode.htm
16:10:12 <dcoutts_> Ralith: can you also paste the output of ghc-pkg list
16:10:50 <niteria> hmm, is it true that + is left and right associative?
16:10:57 <bitonic> Okasu: whoa those parsers in APL are intense.
16:10:58 <Ralith> dcoutts_: the full thing, not just filtered for Cabal?
16:11:12 <dcoutts_> Ralith: yes
16:11:50 <hpaste> Ralith annotated “Cabal version issues” with “Cabal version issues (annotation)” at http://hpaste.org/78382#a78383
16:14:46 <Okasu> too bad i can't find any date when it was written...
16:15:05 <Okasu> but it still impressive: haskell in <1000loc of APL
16:15:20 <dcoutts_> Ralith: oh, cabal clean isn't working, rm -r dist/ and try it
16:16:24 <asdf__> hello
16:16:31 <asdf__> i hate functional programming
16:16:42 <johnw> so go over to #java and be happy
16:17:05 <typoclass> asdf__: please keep it on topic. do you have any specific questions or criticisms of haskell?
16:17:18 <asdf__> not haskell, stratego xt :(
16:17:44 <asdf__> i have to do some homework for compiler construction
16:17:53 <Ralith> dcoutts_: that did it; looks like dist/ was stale and not getting automatically scrubbed
16:18:00 <elliott> feel free to complain about other languages in channels actually about those channels (though they probably won't appreciate it either)
16:18:36 <dcoutts_> Ralith: yes, so the problem was this: the dist/setup-config has various cached info, including what version of the Cabal lib we used to compile the Setup.hs
16:19:18 <dcoutts_> Ralith: it found that, decided that version was within the bounds of acceptability and went for it, though it did notice that the setup binary needed to be recompiled
16:20:02 <dcoutts_> Ralith: and clean didn't help because cabal clean for a "build-type: Custom" has to call the setup binary and ask it to clean, which meant it had to compile the setup binary...
16:20:24 <dcoutts_> Ralith: I've added a FIXME to the code to check that the cached version is still actually valid.
16:20:26 <popl> Okasu: That's scary.
16:20:30 <Ralith> awesome, thanks!
16:22:35 <asdf__> anyone experienced in stratego/xt?
16:24:53 <asdf__> i need to check for cyclic inheritance in java classes
16:25:10 <asdf__> too specific i guess
16:25:41 <elliott> asdf__: this has nothing to do with haskell.
16:26:06 <asdf__> ye i know, but i figured there must be a bunch of computer scientists here
16:26:13 <typoclass> asdf__: nope, sorry, we're all haskellers here. i think you're unlikely to find someone knowledgeable in stratego xt, whatever that is :-/
16:26:33 <popl> Isn't Stratego the name of a board game?
16:26:43 <asdf__> that's correct
16:26:45 <Peaker> yay, implicit type variables work in lamdu :)
16:28:02 <nicoo> asdf__: I heard about Stratego/XT, but never found it interesting enough to bother with, sorry.
16:28:53 <asdf__> it's not very widespread, but the university course forces it to use it.
16:29:00 <asdf__> us*
16:30:19 <johnw> asdf__: did you even check the channel list?  There's a #stratego channel
16:30:25 <niteria> huh, my parser generated by parsec's buildExpressionParser, handles "-1 * -1", but fails with "-1*-1"
16:30:46 <asdf__> yes i did, it's the board game ;p
16:31:06 <niteria> is it fixable?
16:31:07 <johnw> the description I'm looking at shows "strategoxt.org' in their topic
16:31:38 <elliott> asdf__: whether the university uses it or not, we can't help you with it, and it's off-topic here.
16:31:42 <asdf__> oh that's right, i was distracted by the childish names in the channel
16:31:47 <asdf__> alright.
16:33:20 <niteria> same with "a||!a"
16:33:50 * elliott wonders what "childish names" even means.
16:36:54 <johnw> maybe there's a guy with the nick "childish"?
16:38:20 <parcs`> niteria: perhaps it's treating ||! as an operator. how are you parsing the operators?
16:39:07 <hpaste> niteria pasted “parser” at http://hpaste.org/78386
16:40:00 <niteria> sorry it's 160 lines long
16:41:23 <niteria> it won't handle "-1*/**/1", too, where /**/ is a comment
16:42:35 <niteria> looks like it considers anything an operatior as long as it's composed of operator characters
16:43:42 <lispy> I keep wishing there was a standard foldM that take the argument in this order: foldM :: a -> [b] -> (a -> b -> m a) -> m a, it's much more suitable to foldM a bs $ \a b -> do ...
16:45:23 <johnw> why does it need to be standard?  just define it in your own projects
16:46:31 <lispy> johnw: I do (of course), but it's like having forM and mapM
16:46:40 <niteria> hm, maybe opLetter should be empty
16:51:05 <niteria> http://hackage.haskell.org/packages/archive/parsec/latest/doc/html/Text-Parsec-Token.html#v:opLetter but this says it shouldn't
17:06:13 * hackagebot happstack-server 7.1.1 - Web related tools and services.  http://hackage.haskell.org/package/happstack-server-7.1.1 (JeremyShaw)
17:06:38 <niteria> ok, when opLetter is empty it fails to parse operators that are suffixes of other operators
17:08:25 <johnw> in GHC 7.6, what's the equivalent of throwDynTo that used to be in Control.OldException?
17:10:04 <c_wraith> what did it do differently from throwTo in Control.Exception?
17:26:23 <johnw> Cale: ping
17:27:30 <Cale> pong
17:27:41 <johnw> you interested in some changes toward compiling lambdabot with GHC 7.6?
17:28:01 <johnw> i've gotten pretty far, but i'm at the point where I don't understand the way it handles signals well enough to know what the right changes should be
17:28:46 <m3ga> i'm looking at the HUnit docs. anyone know if HUnit outputs xUnit style ML test log files?
17:28:56 <Cale> hmm, well, so long as it's working on 7.4 right now, I'm not super-excited about the prospect of updating it for 7.6. If you do manage to get it working though, let me know.
17:30:11 <johnw> for example, there's data IRCError = IRCRaised Exception | SignalCaught Signal in Lambdabot.hs, but Exception wants a type parameter now
17:30:18 <johnw> should it be SomeException?
17:30:19 <Cale> The fact that there are serious bugs in the 7.x typechecker does not make me happy at all, and somehow it's currently sidestepping those problems, I'm not exactly sure how it's sidestepping those problems, but I'd be fairly worried about that aspect of the upgrade too.
17:30:32 <johnw> hmm
17:30:43 <c_wraith> johnw: you need to just convert to using Control.Exception
17:30:56 <c_wraith> johnw: it's not actually very tough to do
17:31:00 <johnw> c_wraith: yeah, that's what caused the above issue
17:31:07 <Cale> Is everyone aware that in GHC 7.x you can write unsafeCoerce?
17:31:28 <johnw> Cale: edwardk actually tweeted that today
17:31:29 <c_wraith> without unsafePerformIO?  No, I think most people aren't
17:31:34 <sipa> how?
17:31:38 <Cale> let unsafeCoerce v = z where z :: v; z = v where aux = const v
17:31:38 <sipa> (answer: no)
17:31:42 <Cale> (do this in ghci)
17:32:19 <elliott> doesn't work in lambdabot happily
17:32:45 <Cale> yeah, I think part of lambdabot is still typechecking L.hs with 6.12.3's typechecker
17:32:54 <Cale> or the stuff which is about to be added to L.hs
17:33:03 <elliott> haha
17:33:06 <elliott> nice security
17:33:12 <Cale> I'm not 100% sure that's the case, but when I tried this, I got messages about rigid types
17:33:21 <Cale> which seems to indicate that it's using the old typechecker
17:33:22 <johnw> Cale: are there bugs open on these type checking issues?
17:33:32 <Cale> I haven't looked
17:33:40 <elliott> yes
17:33:42 <elliott> there's a bug
17:33:43 <johnw> does it have to do with the work they did to allow deferring type errors?
17:33:49 <edwardk> Cale: that seems to be saving your bacon =)
17:33:49 <Cale> There are more bugs too, like that ridiculous thing the other day with pairs
17:33:57 <elliott> it's fixed in HEAD already in fact
17:34:03 <elliott> Cale: hm, what ridiculous thing?
17:34:37 <Cale> let foo :: (a,a); foo = undefined; bar = let (x,y) = foo in x:y in bar
17:34:58 <Cale> this typechecks if you turn on NoMR, but not TypeFamilies
17:35:17 <Cale> Turning off NoMR or turning on TypeFamilies will make it correctly fail to typecheck
17:35:33 <Cale> :t let foo :: (a,a); foo = undefined; bar = let (x,y) = foo in x:y in bar
17:35:34 <lambdabot> [a]
17:35:48 <Cale> ^^ lol
17:35:49 <c_wraith> that's a truly bizarre expression
17:35:57 <elliott> ~(x,y) typechecks either way, right?
17:36:00 <c_wraith> the unsafeCoerce, that is
17:36:08 <Cale> It ought not to
17:36:19 <Cale> This ought to be an occurs check failure any way
17:36:37 <c_wraith> yes, it should
17:36:41 <c_wraith> a = [a]
17:36:50 <Cale> But it treats let (x,y) = foo as if it's let (x,_) = foo; (_,y) = foo
17:37:10 <Cale> i.e. it generalises each variable individually
17:37:37 <Cale> Which produces some really derpy results
17:37:52 <c_wraith> unsafeCoerce definitely should complain about a rigid type variable
17:37:53 <copumpkin> I like the unsafePerformIO in there
17:37:57 <parcs`> > let unsafeCoerce v = z where z :: v; z = v where aux = const v in unsafeCoerce True :: () -- ?
17:37:58 <lambdabot>   Couldn't match type `t' with `v1'
17:37:58 <lambdabot>    `t' is a rigid type variable bound by
17:37:58 <lambdabot> ...
17:38:02 <Cale> We actually noticed this when a beginner's program using System.Random was failing with ambiguous type errors
17:40:00 <c_wraith> I really don't understand the unsafeCoerce thing. I mean, I see what's going on, but I don't know why all those parts are necessary
17:40:44 <copumpkin> c_wraith: because bug
17:41:03 <c_wraith> I'm poking the bug..
17:41:29 <c_wraith> That is strange.
17:42:24 <elliott> http://hackage.haskell.org/trac/ghc/ticket/7453
17:43:19 <c_wraith> interesting. If I replace const with (\r _ -> r), it correctly errors out
17:43:36 <elliott> I think you can just use Identity instead of const too, etc.
17:43:37 <c_wraith> That's really a bizarre set of circumstances that triggers the bug
17:44:04 <c_wraith> yes, you can use id in place of const
17:44:18 <Cale> *Main> cast (Just True) :: String
17:44:18 <Cale> "\-1152921504589708267Segmentation fault: 11
17:44:27 <Cale> nice string
17:44:36 <c_wraith> and replacing id with an equivalent lambda also errors
17:44:45 <geekosaur> cute
17:44:48 <copumpkin> @yhjulwwiefzojcbxybbruweejw
17:44:48 <lambdabot> Exception: <<loop>>
17:44:49 <c_wraith> I've been casting [] to ()
17:45:01 <c_wraith> it doesn't crash ghci :)
17:47:14 <Cale> c_wraith: right, you can actually make things work out if you understand the representation
17:47:23 <Cale> () and [] would both have the same constructor tag
17:47:26 <c_wraith> yeah
17:47:37 <c_wraith> I do know how to unsafeCoerce without crashing, in GHC.
17:49:05 <latro`a> still love fromJust = unsafeCoerce
17:49:09 <latro`a> :)
17:49:18 <latro`a> erm
17:49:19 <latro`a> isJust
17:49:23 <latro`a> .u'u
17:49:28 <latro`a> ...
17:49:29 <elliott> @quote isTrue
17:49:29 <lambdabot> monochrom says: isTrue = (unsafeCoerce :: Either a b -> Bool) . (unsafeCoerce :: Maybe c -> Either a b) . (unsafeCoerce :: Bool -> Maybe c)
17:49:39 <latro`a> s/.u'u/sorry
17:49:47 <latro`a> spent too much time in a certain other channel lately -_-
17:49:50 <c_wraith> listToMaybe
17:50:08 <hpc> listToMaybe = unsafeCoerce -- :D
17:52:01 <latro`a> <Cale> :t let foo :: (a,a); foo = undefined; bar = let (x,y) = foo in x:y in bar
17:52:01 <latro`a> <lambdabot> [a]
17:52:02 <latro`a> wat
17:52:20 <Cale> The typechecker sucks :(
17:52:21 <latro`a> what exactly is it printing?
17:54:17 <parcs`> how does unsafeCoerce work with the GC?
17:56:09 <hpc> parcs`: quite easily
17:56:35 <hpc> it unifies with any application of (->)
17:56:44 <hpc> (modulo higher ranked types etc)
18:00:08 <parcs`> hmm i guess the GC doesn't care about the type of a value. all it sees is pointers and primitive values
18:01:08 <hpc> oh, the GC, /me grossly misread
18:03:28 <harovali> hi! is there a reporitory of cool things that people have dona using Parsec?
18:05:00 <hpc> harovali: if hackage does reverse dependencies, look that up on parsec
18:05:08 <hpc> then search for the neat packages
18:05:32 <hpc> a very simple example might be
18:05:37 <hpc> @hackage ghc-man-completion
18:05:38 <lambdabot> http://hackage.haskell.org/package/ghc-man-completion
18:08:00 <applicative> http://packdeps.haskellers.com/reverse/parsec
18:08:33 <Nereid> oh, apparently zsh can now use bash completion files, cool
18:10:09 <glguy> Cale: http://hackage.haskell.org/trac/ghc/ticket/2357#comment:11 regarding that funny foo/bar example
18:13:03 <applicative> harovali:  have you studied parsec already, or wondering whether it is worth it, or ...
18:13:50 <typoclass> harovali: rwh has a chapter on parsec which is quite nice
18:13:54 <typoclass> @where rwh
18:13:54 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
18:22:02 <fengshaun> hi all, how can I import an infix operator from a module?
18:22:20 <mauke> import Prelude ((+))
18:22:25 <fengshaun> thanks
18:22:46 <fengshaun> what if I have import qualified Data.Map as M, how would I use the operator?
18:22:49 <fengshaun> M.(!) ?
18:22:57 <mauke> > M.empty M.! "hi"
18:22:58 <lambdabot>   <local>:1:38:
18:22:58 <lambdabot>      Couldn't match type `t' with `v1'
18:22:58 <lambdabot>        `t' is a rigid ...
18:23:12 <mauke> :t (M.!)
18:23:13 <lambdabot> Ord k => M.Map k a -> k -> a
18:23:16 <fengshaun> thanks!
18:23:36 <mauke> :t M.empty
18:23:37 <lambdabot> M.Map k a
18:23:44 <mauke> > M.empty M.! "hi" :: ()
18:23:45 <lambdabot>   <local>:1:38:
18:23:45 <lambdabot>      Couldn't match type `t' with `v1'
18:23:45 <lambdabot>        `t' is a rigid ...
18:23:51 <mauke> I don't get it
18:25:31 <liyang> fengshaun: you can import Data.Map twice. Once to get the operator unqualified, and another time qualified for everything else.
18:25:51 <applicative> fengshaun: you can also write two import lines if you aren't getting ! from somewhere else, import qualified Data.Map as M; import Data.Map (Map,(!))
18:25:52 <applicative> ha
18:25:53 <liyang> (I'd import the "Map" type unqualified too.)
18:26:26 <mauke> I'm too lazy for two import lines
18:26:30 <mauke> I just write M. everywhere
18:26:42 <applicative> M.! is too horrible!
18:26:43 <liyang> I'm too lazy to write M. everywhere.
18:27:00 <mauke> applicative: it's also unsafe
18:27:33 <applicative> because ambiguous?
18:27:41 <liyang> Explicate thyself.
18:27:50 <mauke> can't, getting type errors
18:28:44 <shachaf> @undefine
18:28:51 <shachaf> mauke: It was something in L.hs
18:29:23 <mauke> o_O
18:29:37 <mauke> > M.empty M.! "hi"
18:29:38 <lambdabot>   *Exception: Map.find: element not in the map
18:31:39 <fengshaun> thanks mauke applicative liyang
18:34:49 <Cale> glguy: aha: http://hackage.haskell.org/trac/haskell-prime/wiki/SpecifyPatternBindingSemantics
18:35:18 <Cale> This is a pretty derpy translation if the type of the freshly introduced z is allowed to be generalised
18:36:11 <Cale> You might want polymorphic pattern bindings, but whatever type is selected should be consistent between the variables which are bound
18:42:05 <Nereid> Cale: heh,
18:42:06 <Nereid> .
18:51:15 * hackagebot repa 3.2.2.201204.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.2.201204.1 (BenLippmeier)
18:51:17 * hackagebot repa-algorithms 3.2.2.201204.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.2.201204.1 (BenLippmeier)
18:56:19 * hackagebot repa-io 3.2.2.201204.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.2.201204.1 (BenLippmeier)
18:56:21 * hackagebot repa-examples 3.2.2.201204.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.2.201204.1 (BenLippmeier)
19:11:15 * hackagebot aws-sdk 0.7.0.0 - AWS SDK for Haskell  http://hackage.haskell.org/package/aws-sdk-0.7.0.0 (YusukeNomura)
19:13:36 <friendly-mango> Hello
19:13:46 * copumpkin eats the friendly-mango 
19:14:00 <friendly-mango> Was wondering if there is a package which allows one to quickly cabalise a project?
19:14:13 <friendly-mango> something like: cabalise .
19:14:20 <Nereid> cabal init does a decent job
19:14:28 <friendly-mango> awesome
19:14:52 <friendly-mango> just what I was looking for!
19:14:55 <friendly-mango> many thanks!
19:16:15 * hackagebot git-annex 3.20121127.1 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20121127.1 (JoeyHess)
19:18:47 <Nereid> hmm
19:18:50 <Nereid> git-annex sounds like a thing
19:20:29 <ion> Oh, huh. I have encountered it before but never realized it’s written in Haskell.
19:31:16 * hackagebot unix-time 0.1.4 - Unix time parser/formatter and utilities  http://hackage.haskell.org/package/unix-time-0.1.4 (KazuYamamoto)
19:38:35 <llano> Anyone up for helping me figure out how to do a list comprehension with a custom data type?
19:40:21 <shachaf> Probably not unless you ask your question. :-)
19:40:46 <pdxleif> How do you have a Maybe fallback in IO?
19:40:59 <pdxleif> e.g. IO (Maybe a) -> IO a -> IO a, or something?
19:41:18 <shachaf> pdxleif: Both arguments are IO?
19:41:28 <shachaf> What's an expression where you'd use that?
19:41:37 <pdxleif> lookupEnv "TARGET" orElse getDataDir
19:42:03 <pdxleif> basically, if that env var's not set, fall back to the cabal-provided dir.
19:42:18 <parcs`> :t liftM2 fromMaybe
19:42:19 <lambdabot> Monad m => m r -> m (Maybe r) -> m r
19:42:22 <shachaf> @ty \x y -> x >>= maybe y return
19:42:24 <lambdabot> Monad m => m (Maybe b) -> m b -> m b
19:42:45 <geekosaur> @pl \x y -> x >>= maybe y return
19:42:46 <lambdabot> (. flip maybe return) . (>>=)
19:42:49 <geekosaur> eeew
19:42:49 <parcs`> actually liftM2 fromMaybe is a bad idea
19:43:03 <shachaf> liftM2 fromMaybe will run both actions.
19:43:06 <shachaf> Presumably you don't want that.
19:43:12 <pdxleif> Some MonadPlus or Applicative Alternative thing?
19:43:22 <shachaf> I doubt it.
19:43:37 <pdxleif> It wouldn't hurt to run both.
19:43:41 <shachaf> the MonadPlus instance for IO isn't very nice, and you care about values here.
19:43:51 <pdxleif> I have to run the first, and running getDataDir won't harm anything.
19:44:16 <shachaf> In that case it would be nicer to take a non-IO argument for the default.
19:44:43 <shachaf> @ty fmap (fromMaybe ?dflt)
19:44:45 <lambdabot> (?dflt::b, Functor f) => f (Maybe b) -> f b
19:44:56 <llano> Hopefully a simple list comprehension question: looking to do
19:44:58 <llano> errorTypeCheck trees@(LogMessage mt ts str) = [tree | tree <- trees, isErrorType mt]
19:45:30 <llano> where mt is a data type for MessageType
19:45:48 <shachaf> That'll either give you all trees or an empty list.
19:46:00 <shachaf> Since isErrorType mt doesn't depend on tree.
19:46:47 <llano> is there a way to call out one of the portions of the LogMessage data type as part of the filter?
19:47:00 <Nereid> :t flip maybe return
19:47:01 <lambdabot> Monad m => m a -> Maybe a -> m a
19:47:06 <Nereid> hm
19:47:15 <applicative> is trees a list of these LogMessages?
19:47:22 <llano> yes
19:47:44 <shachaf> What's the type involved here?
19:47:44 <llano> bad name I realized now that I put it in here
19:47:46 <applicative> [mt | LogMessage mt ts str <- trees, isErrorType mt]
19:47:49 <shachaf> Does the thing you said type-check?
19:48:01 <applicative> llano, something like that ^^ ?
19:48:20 <llano> Except I want the whole LogMessage data type returned
19:48:23 <ion> lookupEnv "TARGET" >>= maybe getDataDir return
19:48:37 <applicative> ok
19:48:41 <shachaf> [m | m@(LogMessage mt ts str) <- trees, isErrorType mt] ?
19:48:49 <llano> Just only where the one piece of the LogMessage is a certain type
19:48:52 <applicative> [message | message@LogMessage mt ts str <- trees, isErrorType mt]
19:49:01 <applicative> maybe some parenses in there
19:49:04 <shachaf> Or better yet, filter (\(LogMessage mt ts str) -> isErrorType mt)
19:49:31 <applicative> the question was about comprehensions
19:49:34 <Nereid> :t \x y -> x >>= maybe y return
19:49:35 <lambdabot> Monad m => m (Maybe b) -> m b -> m b
19:49:43 <llano> Well, any implementation will work
19:49:45 <Nereid> pdxleif: ^
19:49:49 <shachaf> The question was about how to do something. :-)
19:49:50 <llano> My first thought was a list comprehensino
19:50:03 <llano> I'll go play and report back
19:50:09 <applicative> ok, filter is probably clearer.  \
19:50:11 <ion> applicative: XY problem
19:50:12 <llano> And thank you in advance :)
19:50:18 <ParahSailin> @pl \x y -> x >>= maybe y return
19:50:18 <shachaf> 19:42 <shachaf> @ty \x y -> x >>= maybe y return
19:50:18 <lambdabot> (. flip maybe return) . (>>=)
19:50:52 <applicative> 19:42 <member:shachaf> @ty \x y -> x >>= maybe y return
19:50:54 <Nereid> oh I missed that
19:51:09 <pdxleif> I could pattern match on the thing: Just s -> return s; Nothing -> getDataDir ?
19:51:24 <shachaf> pdxleif: That's the same as maybe getDataDit return
19:51:37 <shachaf> "maybe" is exactly pattern-matching on a Maybe. :-)
19:51:56 <Nereid> everything you can do with a Maybe, you can do with maybe.
19:52:18 <Nereid> :t maybe Nothing Just
19:52:20 <lambdabot> Maybe a -> Maybe a
19:52:38 <Nereid> :t maybe ?z ?f
19:52:39 <lambdabot> (?z::b, ?f::a -> b) => Maybe a -> b
19:54:05 <Nereid> :t \?x -> ?x
19:54:06 <lambdabot> parse error on input `\?'
19:54:09 <Nereid> yeah heh
19:54:39 <shachaf> You know how foldr's type should be (Maybe (a,b) -> b) -> [a] -> b?
19:54:51 <shachaf> By this logic maybe's type ought to be (Maybe a -> b) -> Maybe a -> b
19:54:58 <rwbarton> Impeccable.
19:55:27 <rwbarton> Don't forget the unfold for Maybe, too
19:55:37 <ion> shachaf: Makes sense.
19:55:54 <ion> id :: Maybe a -> a
19:56:22 <rwbarton> @type unfoldr
19:56:23 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:56:28 <shachaf> rwbarton: That was the motivation for this line of thought.
19:56:52 <shachaf> It's annoying how unfoldr's type has to be awkward.
19:57:11 <Mortchek> shachaf, I think I understand that connection as a joke, but can you explain the foldr thing? :P
19:57:23 <shachaf> @ty foldr
19:57:24 <lambdabot> (a -> b -> b) -> b -> [a] -> b
19:57:39 <shachaf> otherFoldr :: (Maybe (a,b) -> b)) -> [a] -> b
19:57:48 <shachaf> s/\)\)/)/
19:57:48 <statusfailed> Does anybody know why this prints "[]"?
19:57:52 <statusfailed> runT $ supply [1..10] (repeatedly $ await >>= liftIO . print)
19:58:01 <statusfailed> (using Data.Machine)
19:58:04 <pdxleif> Sweet, "d <- maybe getDataDir return target" works, thanks!
19:58:04 <statusfailed> (again)
19:58:05 <shachaf> Mortchek: If you look at it you can figure out that it's the same thing.
19:58:22 <Mortchek> shachaf, aha, I see it now.
19:58:25 <cmears> shachaf: the default "b" just becomes "f Nothing" ?
19:58:31 <shachaf> cmeears: Yep.
19:58:45 <shachaf> The nice thing about that type is that it's exactly unfoldr's type flipped.
19:58:47 <shachaf> @ty unfoldr
19:58:48 <lambdabot> (b -> Maybe (a, b)) -> b -> [a]
19:59:55 <rwbarton> (forall r. r -> (a -> b -> r) -> b -> r) -> b -> [a]
20:00:09 <shachaf> rwbarton: Yep.
20:00:14 <shachaf> Like I said.
20:00:41 <Mortchek> Reminds me of an unfoldTree I wrote for a binary tree: unfoldTree :: (a -> (Maybe a, Maybe a)) -> a -> Tree a
20:00:47 <shachaf> It's annoying how currying only works one way.
20:00:56 <rwbarton> tell me about it!
20:01:00 <shachaf> What's the solution?
20:01:01 <pdxleif> The parsing of that confused me a lil, though, until I realized the "return" was the (a->b) part in that.
20:01:08 <shachaf> Maybe concatenative languages are the solution.
20:01:09 <rwbarton> call/cc??
20:01:16 * hackagebot repa 3.2.3.1 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.2.3.1 (BenLippmeier)
20:01:18 * hackagebot repa-io 3.2.3.1 - Read and write Repa arrays in various formats.  http://hackage.haskell.org/package/repa-io-3.2.3.1 (BenLippmeier)
20:01:20 * hackagebot repa-algorithms 3.2.3.1 - Algorithms using the Repa array library.  http://hackage.haskell.org/package/repa-algorithms-3.2.3.1 (BenLippmeier)
20:01:22 * hackagebot repa-examples 3.2.3.1 - Examples using the Repa array library.  http://hackage.haskell.org/package/repa-examples-3.2.3.1 (BenLippmeier)
20:01:31 <pdxleif> "Maybe execute getDataDir, apply return to the Maybe String".
20:03:04 <Mortchek> shachaf, so are you proposing functions whose values can act as multiple arguments?
20:03:40 <rwbarton> classically P => A \/ Q  =  not (A \/ Q) => not P  =  not A /\ not Q => not P  =  not Q => (not A => not P)  =  not (not A => not P) => Q  =  not (P => A) => Q
20:04:05 <applicative> statusfailed: it doesn't print "[]
20:04:13 <applicative> statusfailed: it returns []
20:04:28 <yepyep> Greetings, I'm trying to construct a stack using newtype with an underlying list.  I'd like to do multiple push operators with a foldl, but I get the following error:
20:04:48 <statusfailed> applicative: doh!
20:04:53 <statusfailed> applicative: runT_ :D
20:04:57 <statusfailed> Thanks!
20:05:06 <yepyep> "Cannot construct the infinite type"
20:05:10 <rwbarton> so you can "cocurry"(?) p -> Either a q into ??? p a -> q
20:05:42 <yepyep> I'm curious why a foldr works fine, but a foldl causes a runtime error.  I also had this problem with another abstract data type i defined for a binary tree
20:06:25 <applicative> foldl requires the operation to be flipped
20:06:29 <applicative> :t foldl
20:06:31 <lambdabot> (a -> b -> a) -> a -> [b] -> a
20:06:32 <applicative> :t foldr
20:06:33 <lambdabot> (a -> b -> b) -> b -> [a] -> b
20:06:49 <shachaf> applicative: That doesn't sound like it would cause a runtime error. :-)
20:07:10 <applicative> "Cannot construct the infinite type" doesn't sound like a runtime error
20:07:18 <rwbarton> shachaf: I thought about this in the context of colenses, but I didn't figure out how to relate it to, well, reality
20:07:23 <shachaf> rwbarton: Oh, "cocurrying" would be on functions that return sums, rather than return products?
20:07:26 <statusfailed> yepyep: do you mean an error in ghci?
20:07:26 <shachaf> That makes sense.
20:07:36 <shachaf> I guess unfoldr is an example.
20:07:36 <statusfailed> or are you talking about two different errors?
20:07:46 <yepyep> Yes, it is a ghci error
20:07:58 <applicative> yepyep: it's a type error
20:08:10 <shachaf> Oh.
20:08:28 <yepyep> ah yes. I see.  I'll give that a shot then.
20:08:31 <llano> @shachaf, your implementation of the list comprehension worked perfect
20:08:31 <lambdabot> Unknown command, try @list
20:08:45 <shachaf> llano: What implementation?
20:08:47 <llano> this one: [m | m@(LogMessage mt ts str) <- trees, isErrorType mt]
20:08:49 <shachaf> I recommended using filter. :-)
20:08:59 <llano> couldn't get it with filter
20:09:06 <statusfailed> yepyep: If you could paste some code on hpaste.org that would help us have a look
20:09:07 <shachaf> filter (\(LogMessage mt ts str) -> isErrorType mt) trees
20:10:14 <yepyep> let me try this fixing this first.  I'll post it in a bit if I'm still having trouble.  I think I simply tried the same arguments for foldl as foldr and that is probably where my error is
20:10:28 <rwbarton> shachaf: I thought that was what you were going for. with functions that return products you can already replace a -> (b, c) with (a -> b, a -> c) (well, maybe not in practie)
20:10:55 <llano> shachaf: aye, I just type poorly
20:11:02 <llano> both filter and the list comprehension work
20:11:13 <applicative> yepyep: the operation must be flipped if it's to work, if it isn't something like + or * or || or whatever
20:11:19 <llano> thanks
20:11:29 <applicative> :t foldr (:)
20:11:30 <lambdabot> [a] -> [a] -> [a]
20:11:38 <applicative> :t foldl (:)
20:11:40 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = [a0]
20:11:40 <lambdabot>     Expected type: a0 -> [a0] -> a0
20:11:40 <lambdabot>       Actual type: a0 -> [a0] -> [a0]
20:11:49 <applicative> ^^^ yepyep
20:11:59 <shachaf> rwbarton: You're right, it makes more sense.
20:12:00 <Mortchek> :t foldl (flip (:))
20:12:01 <lambdabot> [b] -> [b] -> [b]
20:12:41 <applicative> yepyep: by the way, foldl is usually a bad idea.  for suitable operations, foldl' is advisable.
20:12:45 <Mortchek> Hmm, is this why some people argue that foldr is the more natural of the two?
20:12:50 <rwbarton> but yeah, the downside of currying everything in sight is when you want to return multiple things and pass all of them to another function
20:13:28 <shachaf> That's the context that I thought of concatenative languages in.
20:13:29 <applicative> Mortchek: I think foldr is 'more natural' because it corresponds with a general conception of a fold
20:13:34 <yepyep> My understanding is that foldl/foldr are lazier and have more potential of causing a stack overflow?
20:13:35 <shachaf> But it doesn't really help for unfoldr.
20:13:40 <rwbarton> right
20:14:01 <Mortchek> applicative, in what way?
20:14:22 <Mortchek> i.e., how does foldr do so that foldl doesn't?
20:14:47 <shachaf> Mortchek: foldr directly corresponds to the structure of the list.
20:14:48 <statusfailed> applicative: wait, why's foldl a badidea?
20:15:03 <shachaf> foldr f z [a,b,c,d] = a `f` b `f` c `f` d `f` z
20:15:10 <Mortchek> shachaf, that is what I was referring to originally. Sorry for being vague.
20:15:15 <shachaf> > foldr f z [a,b,c,d]
20:15:17 <lambdabot>   f a (f b (f c (f d z)))
20:15:17 <applicative> statusfailed: It's conventional wisdom.  foldl' is good for very strict operations
20:15:34 <applicative> statusfailed: I'm not sure where the best account is
20:15:42 <shachaf> Mortchek: foldr f z just replaces every (:) in the list with f, and the [] with z
20:15:50 <Mortchek> Yeah.
20:15:54 <shachaf> foldl does something weird.
20:16:01 <Mortchek> I guess we are talking about the same thing then.
20:17:00 <shachaf> There's almost never a reason to use foldl instead of foldl'
20:17:22 <applicative> statusfailed: http://www.slideshare.net/tibbe/highperformance-haskell slides 9 - 30 are pretty good on the point
20:17:36 <Mortchek> When might foldl be preferred to foldr?
20:17:56 <johnw> shachaf: can you think of *any* reason to use foldl?
20:18:00 <Mortchek> Or foldl', I suppose.
20:18:05 <shachaf> johnw: Occasionally.
20:18:15 <johnw> example?
20:18:30 <copumpkin> Mortchek: foldr is nice when you're producing lazyish things
20:18:34 <copumpkin> foldl is rarely used, and foldl' is a form of tail recursion
20:18:51 <copumpkin> johnw: I've given examples before :P
20:18:51 <copumpkin> johnw: there aren't many
20:19:02 <shachaf> > foldl1 (\x y -> y) [1,2,undefined,3,4]
20:19:03 <lambdabot>   4
20:19:05 <shachaf> > foldl1' (\x y -> y) [1,2,undefined,3,4]
20:19:07 <lambdabot>   *Exception: Prelude.undefined
20:19:17 <johnw> shachaf: wow, that's useful
20:19:18 <applicative> excellent, just the fold I've been looking for
20:19:33 <shachaf> ?
20:19:54 <copumpkin> > foldl (\x y -> y && x) True [undefined, False]
20:19:55 <lambdabot>   False
20:20:00 <copumpkin> > foldl' (\x y -> y && x) True [undefined, False]
20:20:02 <lambdabot>   *Exception: Prelude.undefined
20:20:16 <johnw> copumpkin: a non-strict "any", that makes sense
20:20:33 <Mortchek> Why isn't that first one an error?
20:20:44 <copumpkin> well
20:20:44 <shachaf> I think you might as well reverse and all, though.
20:20:48 <johnw> Mortchek: once it sees the first True, it doesn't need to go any further
20:20:48 <shachaf> and
20:20:51 <statusfailed> applicative: oh thanks
20:20:55 <Mortchek> Ah, right.
20:21:11 <copumpkin> johnw: no
20:21:22 <johnw> oh, sorry, I was thinking of ||
20:21:24 <copumpkin> once it sees the False, it doesn't look
20:21:30 <johnw> ah
20:21:37 <copumpkin> it's not really all that useful
20:21:46 <copumpkin> but perhaps a little less trivial than const id :)
20:22:00 <applicative> statusfailed: note that tibbe also rightly develops the matter of foldr/foldl/foldl' in close connection with the corresponding forms of manual recursion.  You can be choosing one without noticing it...
20:27:00 <yepyep> Got it.  I just had to use flip on my push operation before passing it off to foldl/foldl'
20:27:18 <yepyep> Thanks for the help.
20:32:25 <Mortchek> > foldl f d [a, b, c]
20:32:27 <lambdabot>   f (f (f d a) b) c
20:32:34 <applicative> the other reason for preferring foldr as a default is that the compiler is a master at getting rid of it, of course.
20:33:23 <Mortchek> > foldl (flip (:)) [] [a, b, c]
20:33:24 <lambdabot>   [c,b,a]
20:33:35 <xenocons> heh
20:34:35 <yepyep> does lamdbabot accept PMs?
20:34:45 <Mortchek> yepyep, yepyep.
20:34:47 <AfC> I have a new version of GHC, and so need to reinstall all my packages. Is there a cabal command that automates this, reading from the ~/.cabal/world file somehow?
20:35:09 <johnw> cabal install --reinstall world
20:35:19 <AfC> ah "world" is magic, like in Gentoo.
20:35:22 <AfC> johnw: thanks
20:35:28 <yepyep> \msg lambdabot ...    seems not to reply    s/\\/\/
20:35:47 <Nereid> yepyep: you need @ for any commands you send it
20:36:01 <johnw> AfC: if you're using the latest cabal-install, add -j too
20:36:01 <applicative> my world file only says 'vector -any'
20:36:04 <johnw> it'll go much faster
20:36:04 <Nereid> (exception: you can use > )
20:36:20 <AfC> johnw: er, sorry? cabal-install?
20:36:28 <johnw> cabal install --reinstall -j world
20:36:28 <yepyep> Nereid: Thank you
20:36:33 <johnw> just try it, if it doesn't work, drop the -j
20:36:52 <applicative> johnw: what is this -j ?
20:36:57 <Nereid> I have the latest cabal-install from hackage and it doesn't like -j :(
20:36:59 <johnw> build dependencies in parallel
20:37:09 <applicative> ah indeed
20:37:10 <johnw> it requires cabal-install 1.16.0.2
20:37:14 <Nereid> I have that.
20:37:23 <johnw> well, that's odd
20:37:27 <johnw> i use it exclusively these days
20:37:36 <AfC> um, sorry is "cabal-install" == "cabal install" ?
20:37:47 <johnw> cabal-install is the package that installs the "cabal" binary
20:37:49 <Nereid> cabal-install is the package that provides the "cabal" binary
20:37:50 <Nereid> heh
20:37:51 <johnw> not to be confused with the Cabal library
20:38:02 <johnw> Nereid: wow, that was eerie
20:38:08 <Nereid> meanwhile my old copy of 1.6.0 built on 7.4.2 accepts -j
20:38:17 <applicative> AfC johnw is enforcing the binary / library distinction
20:38:30 <Nereid> so I wonder what's up with that
20:38:43 <Nereid> is it because I'm on 7.6.1 now?
20:39:00 <AfC> applicative: ah, gotcha
20:39:45 <johnw> Nereid: I'm using it with 7.6.1
20:40:17 <Nereid> weird
20:41:08 <Nereid> cabal: Command.optionToFieldDescr: feature not implemented
20:41:09 <Nereid> I get that.
20:41:27 <johnw> do you have "jobs: " set in your ~/.cabal/config?
20:41:36 <johnw> if so, comment that out
20:41:41 <Nereid> I do.
20:42:11 <Nereid> so I can't have it on by default? :(
20:42:26 <johnw> well, i can now
20:42:29 <johnw> it got fixed recently
20:42:38 <johnw> but back when 1.16 first came out, I had that exact same problem
20:42:47 <Nereid> yes I'm using 1.16.0.2
20:42:57 <johnw> and Cabal 1.16.0.3?
20:43:03 <Nereid> uh
20:43:11 <johnw> (the library)
20:43:11 <Nereid> no, 1.16.0 there
20:43:15 <johnw> ok, fix that
20:43:17 <Nereid> ok
20:45:52 <Nereid> and rebuild cabal-install obviously.
20:46:26 <Nereid> yeah it works now, thanks
20:46:29 <johnw> :)
20:47:02 <johnw> in case you're interested, I use this wrapper script: https://gist.github.com/4159065
20:47:10 <Nereid> also Crypto doesn't build on 7.6.1 because they Num is no longer a superclass of Bits :(
20:47:10 <johnw> rather than settings 'jobs' in ~/.cabal/config
20:47:21 <johnw> there are times when I don't want -j, because it shortens the error messages down to 10 lines
20:47:30 <johnw> hey, I've run into the Crypto issue too
20:47:31 <Nereid> sure, so you can give it -j1
20:47:44 <johnw> yeah, that's a good point, hadn't tried that ye
20:47:48 <johnw> but I also want the hyperlinking
20:47:53 <johnw> and there's no config option for that
20:47:59 <Nereid> yeah, I have a shell alias for that heh
20:48:09 <drewr> johnw: https://raw.github.com/gist/4159065/cabal.sh is not terribly interesting :-)
20:48:14 <johnw> how do you differentiate subcommands?
20:48:25 <Nereid> I don't
20:48:27 <Nereid> well
20:48:32 <Nereid> I only have one for cabal install
20:48:55 <Nereid> also that doesn't look like a wrapper script
20:49:11 <monochrom> I only see one line and it is just "--haddock-"
20:49:15 <Nereid> :p
20:49:29 <johnw> maybe it's in the whitespace language
20:49:54 <monochrom> yikes, you use the whitespace language for your shell scripts?!
20:49:56 <Nereid> no it's 10 bytes :p
20:50:37 <Nereid> no whitespace, not even a newline at the end
20:50:43 <Nereid> :(
20:51:08 <monochrom> perhaps it is compressed
20:54:06 <applicative> here's the improved version of cabal.sh http://sprunge.us/jIUh
20:54:22 <johnw> lol
20:55:01 <monochrom> tl;dr (hehe!)
20:55:26 <Nereid> :(
20:57:31 <Nereid> oops suddenly my laptop battery is at 3%, bye :P
20:57:57 <AfC> johnw: Hey nice, -j4 wow!
20:59:12 <johnw> nice, isn't it
20:59:42 <johnw> i do some pretty common sandbox builds that bring in like 60 deps, so having -j8 is life-saver
21:03:24 <monochrom> sudden battery level drop is common for batteries near their end of lives
21:05:18 <monochrom> the laptop is a particularly hostile environment for its batteries. the long term warmth shortens service life
21:09:12 <latermuse> warmth shortens service life a lot?
21:09:21 <latermuse> how about cold? I live in siberia and its f'in cold here
21:10:18 <johnw> cold is good for lithium
21:10:23 <monochrom> I don't know too much about cold. but fridge-cold seems ok actually, people say "keep it in the fridge if you won't use it for several months"
21:10:24 <johnw> it's one of the few battery types which is not affected by it
21:11:20 <latermuse> monochrom: fridge-cold is warm here. our fridges use a heater to keep meats at a decent temperature (joke)
21:11:22 <pdxleif> It looks like most all of my haskell-built executables have executable stack: http://www.gentoo.org/proj/en/hardened/gnu-stack.xml?style=printable :/
21:11:34 <johnw> latermuse: are you really in Siberia?
21:11:45 <latermuse> johnw: yeah. its -20 degrees celcius right now
21:12:07 <johnw> are you near Omyakon?
21:12:15 <pdxleif> Maybe the stuff about "trampolines for nested functions" is the cause of that...
21:12:32 <johnw> Оймяко́н
21:12:33 <monochrom> warmth shortens life. staying near 100% shortens life. staying near 0% shortens life. those are what I read. the recommendation I read is: most of the time, keep it at 40%-60%, and away from the laptop
21:12:35 <latermuse> Im on the chinese side. So while not technically named "siberia", its the same region.
21:12:44 <latermuse> 会汉语吗？
21:13:05 <johnw> i don't know the name in chinese
21:13:07 <luite> yeah, store laptop in the fridge (don't freeze it)
21:13:29 <johnw> monochrom: yeah, i've read that 40% and cool has the longest life
21:13:31 <latro`a> any more elegant way to do this:
21:13:32 <latermuse> johwn: thats why I say its siberia, not many people know the chinese name. But its the same region, as they border each other
21:13:33 <hpaste> latro`a pasted “case?” at http://hpaste.org/78392
21:13:52 <johnw> =
21:14:12 <latro`a> (indentation is less weird in the original file)
21:14:16 <luite> johnw: yeah, recharge it once in a while though, charge level drops slowly through self-discharge
21:14:22 <johnw> latro`a: why not use the Sum monoid?
21:14:41 <johnw> > foldMap (\x -> Sum 10) [1,2,3,4]
21:14:43 <lambdabot>   Sum {getSum = 40}
21:15:22 <johnw> oh, I see, your list is only two elements long
21:15:28 <latro`a> that's part of it, yeah
21:15:37 <latro`a> though it could straightforwardly be generalized, that's the use case
21:15:49 <latro`a> (I could easily do the lookups in a map)
21:16:15 <johnw> sum . map (fromMaybe 0) $ [lookup (c:cs) freqs,lookup cs freqs]
21:16:25 <latro`a> there we are, thanks
21:17:25 <johnw> luite: i'd rather just use it to death than try to keep it alive for that long ;)
21:17:29 <monochrom> the recommendation works for me. my follow it for my current laptop batteries, almost 4 years old now and lost less than 20% of its capacity, maybe less than 10%
21:17:31 <latro`a> doing the lookups in a map is even better
21:17:34 <latro`a> lets you merge the maps
21:17:35 <latro`a> :)
21:17:36 <johnw> by the time 4 years is up, compile times get painful
21:21:48 <latro`a> oh
21:21:53 <latro`a> johnw, this has slightly wrong semantics :/
21:22:01 <latro`a> if both lookups fail I want to get Nothing
21:22:07 <johnw> ah
21:22:59 <latro`a> oh, I know a better way to do what I was doing before anyways
21:24:04 <monochrom> latermuse: are you in a northeastern province of China?
21:24:38 <yaw> any advice on a good pseudo random generator for haskell?
21:24:54 <johnw> yaw: i never know which one to pick ;)
21:24:59 <yaw> System.Random seems to be not-very-random for a fairly simple case that just bit me
21:25:05 <latro`a> > sum []
21:25:05 <yaw> e.g. let alwaysZero seed = (`mod` 3) . fst . R.next $ R.mkStdGen seed
21:25:06 <lambdabot>   0
21:25:14 <latro`a> hm
21:25:29 <yaw> i.e. the 2nd value you get from the pseudo random generator is always zero!
21:25:33 <yaw> (mod 3, sorry)_
21:26:55 <shachaf> yaw: That's an issue with mkStdGen.
21:27:19 <shachaf> Any particular stream of random numbers will seem pretty random.
21:27:36 <yaw> sorry, yeah not System.Random, the standard generator provided rather
21:28:18 <yaw> maybe pseudo random generators in general are less random than i thought,
21:28:30 <yaw> but being always zero (mod 3) for the second value, no matter what seed, seems pretty bad
21:29:03 <cmears> maybe the Mersenne Twister-based libraries will do better
21:31:30 <Guest78990> I have a program that is overflowing stack
21:31:44 <yaw> hmmm, the mersenne twister one seems to be in the IO monad, damn
21:31:45 <Guest78990> In order to fix it, I'd like to know where the overflow is occuring
21:32:03 <Guest78990> What tools can I use to find out where that stack overflow is occuring
21:33:37 <yaw> nvm, google (and guest78990) just pointed me to a solution. heh.
21:33:45 <chris___> hello
21:34:36 <latermuse> Guest78990: Its probably a problem between strict/lazy evaluation
21:35:09 <applicative> Guest66352: If it's not too immense or top secret, you can paste it
21:35:34 <Nereid> monochrom: no, I mean it was down to 3% charge
21:35:42 <Guest78990> latermuse: yes, that's my understanding
21:35:48 <Nereid> it's still a pretty new battery so its capacity is fine
21:35:59 <Guest78990> But I'm trying to find out more information about which part(s) of my code are cuasing the problem
21:36:18 * hackagebot pushme 1.0.1 - Script I use for synchronizing my data among machines  http://hackage.haskell.org/package/pushme-1.0.1 (JohnWiegley)
21:42:37 <yaw> Guest78990: are you able to link to some of the code in question?
21:42:54 <yaw> by the way, Mersenne.Pure64 works great. much better than StdGen.
21:43:10 <Guest78990> yaw: no
21:44:01 <yaw> i'm not very familiar with the tools, so i probably can't help you much, but i know haskell does have a few heap profilers etc. that you can try...
21:44:21 <yaw> try changing some of your code to use strict evaluation (sorry if i'm stating the obvious... not much help i know)
21:44:45 <statusfailed> applicative: Thanks for that link, it's really great
21:46:39 <Hafydd> If I pronounce monad with the first syllable rhyming with "gone", am I likely to be ostracised from gatherings of functional programmers, despite this being consistent with "monoid", etc?
21:46:55 <monochrom> Guest78990: you could try reading my http://www.vex.net/~trebla/haskell/lazy.xhtml and figure something out
21:50:08 <Guest78990> monochrom: I think I understand the basics of the stack overflowing story in the abstract
21:50:32 <Guest78990> monochrom: what I'm looking for now is a tool to help me pin down my stack overflow in the concrete
21:51:51 <statusfailed> monochrom: I just read your page, we should play AoE2 some time :p
21:53:41 <Guest78990> yaw: Also, I'm not sure the heap profilers are going to help me with my stack problem
21:54:27 <yaw> maybe not. sometimes though you get a stack overflow when trying to evaluate a mass of thunks, which would show up on the heap before that happens
21:55:08 <Guest78990> yaw: Good tip: thanks!
21:58:53 <Nereid> Hafydd: mathematicians too
21:59:23 <yaw> sorry i can't be more helpful :(
21:59:27 <applicative> statusfailed: oh yes, the tibbe slides are great
22:01:26 <Hafydd> :(
22:02:06 <johnw> Hafydd: http://www.haskell.org/pipermail/haskell-cafe/2007-May/025338.html
22:02:37 <Hafydd> I was just reading that, johnw, but it didn't seem to come to a consensus.
22:02:56 <johnw> pronunciation is really just about who you ask, and how many people
22:03:00 <Nereid> I have never heard it the other way.
22:03:07 <Hafydd> In particular, that post seems to disagree with what Nereid said.
22:03:20 <johnw> Hafydd: which kind of just proves the point :)
22:03:34 <johnw> when in doubt, let the other guy say it first ;)
22:03:39 <Hafydd> Heh.
22:03:55 <Hafydd> Then the game of trying to not say it starts.
22:04:23 <johnw> "Hey, what do you call that thing that's like a burrito?"
22:04:28 <Hafydd> Hahah.
22:04:41 <Nereid> fwiw in spanish it's mónada, with stress on the first syllable.
22:04:49 <johnw> or just pronounce it "Monoid in the category of endofunctors"
22:05:03 <Nereid> while monoide does not
22:05:19 <shachaf> Look, man, I like monads and I like burritos. Do you really have to ruin both for me by mentioning one whenever the other comes up?
22:06:17 <luite> does anyone how to fix this (when running cabal-dev buildopts): cabal: ghcInvocation: the programVersion must not be Nothing
22:07:17 <mgsloan> shachaf: Yo dawg, I heard you like burritos, so I put a burrito in your burrito, so you can join while you join
22:07:25 <Nereid> lol
22:07:50 <shachaf> I prefer to join while I fmap join.
22:07:52 <johnw> well, now you all know where the word "burrito joint" came from.  They guy really said "burrito joined"
22:09:16 <shachaf> http://slbkbs.org/lens.txt -- lens varieties
22:09:31 <johnw> oh, nice!
22:09:43 <edwardk> thats a start ;)
22:09:47 <statusfailed> Does anybody know why haskellmode-vim gives me "foo type not known" when I do _t on 'foo'?
22:09:52 <edwardk> now add the ones i haven't put in yet ;)
22:10:13 <edwardk> Traversal is also n:Conat. to be pedantic
22:10:24 <shachaf> thedwardk
22:11:08 <shachaf> The problem is that no one knows what Conat is.
22:11:25 <mgsloan> When are we gonna get "i m s t a b" - indexed violent actions?
22:11:26 <shachaf> Maybe I should be subtle about it and write s -> exists n. (a^n, b^n -> t)
22:11:26 <edwardk> :onepointcompatificationofthenaturalnumbers
22:11:45 <shachaf> Let people infer their own type for n.
22:11:48 <edwardk> =)
22:12:03 <johnw> what does ^ mean in a type signature?
22:12:04 <shachaf> We'll see what Conat Ellioll thinks about it.
22:12:14 <mgsloan> johnw: yeah, these'll be good didactic tools for lens!  Looking forward to more posts
22:12:14 <edwardk> johnw: he's just generally indicating there are n such entries
22:12:15 <shachaf> johnw: a^n means a list of n as.
22:12:27 <shachaf> a^2 = (a,a) etc.
22:12:43 <johnw> mgsloan: the next post starts talking about "terminology", so the timing on this is perfect; it clarifies another thing shachaf posted elsewhere
22:12:46 <shachaf> a^∞ = Stream a
22:12:46 <edwardk> johnw: use the relationship that (,) = (*)   and Either = (+) and calculate it ;)
22:12:54 <johnw> shachaf: ah, thanks
22:13:03 <edwardk> a^2 = a*a
22:13:04 <johnw> he's wanting dependent typing already
22:13:08 <Guest78990> yaw: Thanks for your help. I think the problem was a bunch of unevaluated Data.Map.inserts. I added some seqs and no longer seem to be having the problem
22:13:36 <yaw> cool, glad you solved it :)
22:15:12 <mgsloan> johnw: cool!  Good thing you're doing that now that things are getting a bit more settled convention-wise.
22:15:31 <Ralith> johnw: aren't we all?
22:18:10 <Nereid> but why mention conat at all if nat (without infinity) doesn't really exist in haskell?
22:19:53 <edwardk> Nereid: data Nat = S !Nat | Z
22:20:04 <Nereid> I don't like !
22:20:11 <Nereid> therefore it doesn't exist
22:20:15 <edwardk> =)
22:20:43 <edwardk> so i see you are strictly against strictness. i'm to lazy to be.
22:20:59 <Nereid> :(
22:21:23 <monochrom> hahaha
22:24:08 <Nereid> ok then, why is the name "conat" justified?
22:24:41 <Nereid> the naturals are the initial F-algebra where F(X) = 1 + X
22:24:48 <Nereid> conat is the universal ... ?
22:24:59 <copumpkin> conat is the terminal coalgebra
22:25:05 <Nereid> disagree
22:25:11 <johnw> ooh, fight!
22:25:44 <copumpkin> Nereid: why?
22:25:53 <Nereid> because I probably messed up, that's why
22:26:07 <copumpkin> they're just the greatest fixed point of that same functor
22:26:36 <copumpkin> the unique terminal morphism you get there is just the unfold
22:26:43 <zachk> F-algebra?
22:27:03 <copumpkin> zachk: for some functor F, the f-algebra is just F a -> a
22:27:06 <Nereid> object X together with morphism F(X) -> X
22:27:07 <copumpkin> or an F-algebra
22:28:26 <zachk> is that a comonad "action" ?
22:29:03 <applicative> inside haskell, they are the naturals as much as the conaturals
22:29:09 <Nereid> e.g. any Monoid is a []-algebra under mconcat
22:29:22 <copumpkin> zachk: it's not really anything but what Nereid said :) it's one of the most boring "structures" ever
22:29:26 <copumpkin> it doesn't even need to satisfy any properties
22:29:39 <Nereid> indeed
22:29:42 <copumpkin> but we make categories of F-algebras and then they get a bit more interesting
22:29:52 <Nereid> or you put more structure on F (e.g. a monoid) and it becomes more interesitng
22:29:58 <Nereid> (because you get extra laws)
22:30:07 <Nereid> er I meant monad there, not monoid
22:30:10 <shachaf> edwardk: Your Nat isn't even the naturals.
22:30:20 <Nereid> yes
22:32:39 <applicative> the only reason for thinking that big = S big is a genuine haskell value distinct from big = big is that you also think there is some expression S ( S ( ... it evaluates to, given the character of the type
22:33:27 <yaw> this talk of heap profilers has got me interested
22:33:41 <applicative> if you think there is no such expression there is no reason to call data N = Z | S N 'conaturals'
22:33:48 <yaw> is there any (simple?) way to visualise unevaluated thunks of an expression?
22:34:08 <yaw> like... if i go
22:34:14 <applicative> i visualize big = big very readily
22:34:15 <yaw> x = (some big expression)
22:34:41 <yaw> y = get-some-part-of-x
22:34:54 <yaw> then, show me what's left of the thunks in x
22:35:01 <yaw> applicative: what do you mean?
22:36:17 <applicative> in that case, I was thinking I didn't have anything else to think of or look at but the definition
22:36:46 <yaw> e.g. let x = map (+1) $ take 10 [1..]
22:36:59 <yaw> then call, length x
22:37:21 <yaw> it should reify the list cells, but their values should still be thunks. any way to visualise this?
22:38:02 <Nereid> copumpkin: ok I see how to construct the morphism now.
22:38:09 <copumpkin> yay
22:38:24 <copumpkin> MOARPHISMS
22:38:24 <copumpkin> ceiling category approovz
22:38:31 <Nereid> but still, in Haskell, nat = conat and the nat-without-infinity isn't a thing at all.
22:39:17 <copumpkin> Nereid: well, you might argue that Nat doesn't exist, or that it would be the strict version of Nat, or that Haskell is CPO\bot and thus least and greatest fixed points coincide
22:39:26 <copumpkin> I don't particularly care which :)
22:40:55 <johnw> CPO⊥?
22:41:49 <copumpkin> http://www.cs.gunma-u.ac.jp/~hamana/Papers/cpo.pdf
22:42:26 <johnw> nice, thank you
22:42:48 <johnw> my reading list just broke 630 unread :)
22:43:00 <copumpkin> that one's nice because it's fairly informative slides
22:43:03 <copumpkin> not long prose
22:43:10 <copumpkin> so you can skim it and get good info without wasting much time :)
22:47:14 <scp> @hoogle [(a, b)] -> ([a], [b])
22:47:14 <lambdabot> Prelude unzip :: [(a, b)] -> ([a], [b])
22:47:14 <lambdabot> Data.List unzip :: [(a, b)] -> ([a], [b])
22:49:48 <Nereid> :t map fst &&& map snd
22:49:49 <lambdabot> [(b, b1)] -> ([b], [b1])
22:49:54 <Nereid> :t fmap fst &&& fmap snd
22:49:55 <lambdabot> Functor f => f (b, b1) -> (f b, f b1)
22:50:07 <Nereid> :t uncurry (liftA2 (,))
22:50:08 <lambdabot> Applicative f => (f a, f b) -> f (a, b)
22:50:20 <johnw> :t fmap (fst &&& snd)
22:50:22 <lambdabot> Functor f => f (c, c') -> f (c, c')
22:50:26 <Nereid> nice try
23:00:06 <scp> @hoogle (a -> b -> c -> d) -> (c -> a -> b -> d)
23:00:06 <lambdabot> Data.Sequence zipWith3 :: (a -> b -> c -> d) -> Seq a -> Seq b -> Seq c -> Seq d
23:00:06 <lambdabot> Prelude zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
23:00:06 <lambdabot> Data.List zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
23:00:52 <copumpkin> @@ @pl @djinn (a -> b -> c -> d) -> (c -> a -> b -> d)
23:00:52 <lambdabot>  f = flip . (flip .)
23:01:04 <scp> thanks
23:01:12 <copumpkin> please don't actually use that :)
23:01:15 <shachaf> @@ @pl @djinn @type flip . (flip .)
23:01:16 <lambdabot>  f = flip . (flip .)
23:01:19 <shachaf> Success!
23:01:49 <copumpkin> shachaf: adjunction!
23:12:12 <Nereid> ok, I wrote cata and ana for Mu f, given a Functor f
23:12:20 <Nereid> :s
23:12:30 <shachaf> Which Mu?
23:12:37 <Nereid> data Mu f = Mu (f (Mu f))
23:12:46 <Nereid> is there another?
23:13:03 <shachaf> Mu f = Mu (forall a. (f a -> a) -> a)
23:13:19 <shachaf> Also Nu f = forall a. Nu a (a -> f a), or something.
23:13:32 <Nereid> oh geez
23:13:49 <Nereid> ok
23:13:59 <Nereid> exercise: show they're all isomorphic, right.
23:14:26 <shachaf> Right.
23:14:39 <Nereid> at least if f is a Functor.
23:16:38 <Nereid> oh I've basically already written those isomorphisms.
23:16:41 <Nereid> just need to write their inverses.
23:17:02 <shachaf> Did you know Int ~ ()?
23:17:09 <shachaf> I've already written the isomorphism. I just need to do the inverse now.
23:17:09 <Nereid> haha, how?
23:17:15 <Nereid> oh.
23:17:16 <Nereid> well.
23:17:35 <Nereid> I know what you mean.
23:18:06 <Nereid> I don't care enough to *prove* that my things are inverses.
23:18:10 <Nereid> not right now anyway
23:18:11 <Nereid> :s
23:26:05 <Nereid> I like this forall a. (f a -> a) -> a
23:28:52 <Nereid> no need for a new data type.
