00:45:36 * hackagebot haskelldb-connect-hdbc 0.1.0.0 - Bracketed HDBC session for HaskellDB  http://hackage.haskell.org/package/haskelldb-connect-hdbc-0.1.0.0 (KeiHibino)
00:45:38 * hackagebot haskelldb-connect-hdbc-lifted 0.1.0.0 - Bracketed HaskellDB HDBC session using lifted-base  http://hackage.haskell.org/package/haskelldb-connect-hdbc-lifted-0.1.0.0 (KeiHibino)
00:47:25 <mikeplus64> are there any mirrors for the windows HP?
00:50:36 * hackagebot haskelldb-connect-hdbc-catchio-mtl 0.1.0.0 - Bracketed HaskellDB HDBC session using MonadCatchIO-mtl  http://hackage.haskell.org/package/haskelldb-connect-hdbc-catchio-mtl-0.1.0.0 (KeiHibino)
00:50:38 * hackagebot haskelldb-connect-hdbc-catchio-transformers 0.1.0.0 - Bracketed HaskellDB HDBC session using MonadCatchIO-transformers  http://hackage.haskell.org/package/haskelldb-connect-hdbc-catchio-transformers-0.1.0.0 (KeiHibino)
01:41:15 <neutrino_> is there a monad in which >>= is $ ?
01:49:32 <bgamari> statusfailed, I personally use Chart
01:50:08 <bgamari> statusfailed, Although frankly I don't find it as easy to use as Python's matplotlib and therefore still find myself falling back to Python from time to time
01:51:10 <neutrino_> matplotlib is pretty damn good
01:51:16 <neutrino_> however it doesn't do web
01:51:37 <neutrino_> i'm hoping for something in Haskell that compiles down to a windowing system or Fay depending on what you want
01:51:58 <neutrino_> or maybe even latex
02:12:32 <nand`> neutrino_: there's a monad in which (>>=) is effectively flip ($)
02:12:43 <nand`> modulo some newtypes
02:13:04 <neutrino_> what monad is that?
02:13:08 <nand`> Identity
02:13:19 <neutrino_> that is very interesting
02:13:24 <nand`> Identity a -> (a -> Identity b) -> Identity b ≅ a -> (a -> b) -> b
02:16:03 <neutrino_> how would i rewrite this in that monad? foo x = do { let y = (bar . baz) x; let z = (quux . gnarf) y; return z }
02:16:17 <neutrino_> no actually
02:16:41 <neutrino_> foo x = let y = (bar.baz) x, z = (quux . gnarf) y in z
02:16:45 <nand`> let y = (bar . baz) x in let z = (quux . gnarf) y in z
02:16:53 <neutrino_> right
02:16:59 <neutrino_> but how would i rewrite it using >>= ?
02:17:09 <nand`> there's no >>= in that example
02:17:46 <neutrino_> but it's the same as foo = (quux.gnarf) . (bar.baz)
02:17:53 <nand`> I mean, you could so something silly like let Identity y = (bar <=< baz) =<< Identity x
02:18:23 <neutrino_> i think the 2nd dot can be rewritten in terms of monadic operators
02:18:43 <nand`> <=< is the monadic version of (.)
02:18:55 <nand`> other than that I'm not sure what you're trying to accomplish
02:19:02 <luite> neutrino_: that (compiling to js or native windowing) is actually one of hamishmack's goals with ghcjs
02:19:05 <nand`> what's wrong with  quux . gnarf . bar . baz ?
02:19:24 <neutrino_> is <=< the monadic version of (.) for every monad or just this monad?
02:19:33 <nand`> :t (<=<)
02:19:35 <lambdabot> Monad m => (b -> m c) -> (a -> m b) -> a -> m c
02:19:36 <neutrino_> nand`: it's just a thought exercise. i'm learning about monads and stuff.
02:19:43 <neutrino_> right
02:19:51 <neutrino_> :t (flip ($))
02:19:53 <lambdabot> b -> (b -> c) -> c
02:19:56 <neutrino_> :t (.)
02:19:58 <lambdabot> Functor f => (a -> b) -> f a -> f b
02:20:18 <nand`> :t (Prelude..)
02:20:20 <lambdabot> (b -> c) -> (a -> b) -> a -> c
02:20:28 <neutrino_> yeah i was just going to copypaste from ghci
02:20:54 <shachaf> @let cps f g = \x -> g (f x)
02:20:56 <lambdabot>  Defined.
02:21:08 <nand`> :t cps
02:21:09 <lambdabot> (t2 -> t1) -> (t1 -> t) -> t2 -> t
02:21:24 <neutrino_> ok so.. i could rewrite my equation as foo x = (quux.gnarf) $ (bar.baz) x
02:21:41 <nand`> yes
02:21:53 <neutrino_> which would be foo x = (quux.gnarf) =<< (bar.baz) x
02:22:10 <nand`> modulo newtypes
02:22:13 <neutrino_> this would then mean foo = (quux.gnarf) =<< (bar.baz) =<< return?
02:22:19 <neutrino_> right?
02:22:20 <shachaf> ?
02:22:35 <shachaf> nand`: Oh, I missed half of the convesation.
02:22:37 <shachaf> Never mind.
02:22:49 <neutrino_> 10-103m on that one
02:23:31 <nand`> neutrino_: that would be a type error, I think; at any rate, it would not be the Identity monad
02:23:33 <nand`> :t (=<<)
02:23:34 <lambdabot> Monad m => (a -> m b) -> m a -> m b
02:23:39 <nand`> :t return
02:23:41 <lambdabot> Monad m => a -> m a
02:23:52 <nand`> return does not have type Identity a
02:23:55 <neutrino_> well you say >>= is flip $
02:24:00 <neutrino_> so i flipped it again to get $
02:24:10 <neutrino_> =<< is flip >>=
02:24:28 <nand`> yes; =<< in identity is analogous to $
02:24:47 <neutrino_> why "analogous" and not "the same"?
02:24:56 <nand`> but (quux.gnarf) . (bar.baz) . return -- makes no sense
02:25:05 <nand`> err
02:25:08 <nand`> but (quux.gnarf) $ (bar.baz) $ return -- makes no sense
02:25:37 <nand`> neutrino_: because ‘Identity a’ and ‘a’ are not the same thing
02:25:39 <nand`> they're just isomorphic
02:26:00 <neutrino_> mhm
02:26:01 <nand`> so when you go to actually work with the Identity monad, you have to keep that in mind; and unwrap/wrap the Identity as needed
02:26:24 <neutrino_> but return gives me a monadic value, and that's what =<< expects on its right side
02:26:39 <nand`> but you didn't apply it to anything
02:26:44 <nand`> ‘return x’ would be fine, type-wise
02:26:50 <neutrino_> because the function is curried
02:26:59 <neutrino_> i did foo =, not foo x =
02:27:28 <nand`> you can't eta-reduce that, it's nested somewhere inside the tree
02:27:40 <nand`> look at it this way
02:27:44 <neutrino_> i don't know what eta reduction is
02:27:50 <nand`> foo x = f =<< g =<< return x
02:27:54 <nand`> so that's the same as
02:28:03 <nand`> foo x = (=<<) f ((=<<) g (return x))
02:28:27 <nand`> the eta reduction rule is: f x = g x is the same as f = g
02:28:49 <neutrino_> right, i was just going to ask about that. is foo x = f =<< g =<< return x going to be the same as foo x = f $ g $ x?
02:29:09 <nand`> yes
02:29:21 <neutrino_> that eases up a lot of the condition
02:29:23 <neutrino_> er
02:29:35 <neutrino_> i have no idea what i just said, i meant: that eases up the situation
02:29:55 <nand`> if you want to eliminate the ‘x’; it would look like this
02:30:04 <neutrino_> go on
02:30:17 <nand`> foo = ((f =<< g) =<<) . return
02:30:42 <neutrino_> however! can't we rewrite that in terms of flip $ again?
02:31:07 <nand`> (.) in Identity is (<=<)
02:31:09 <nand`> so you can write that as
02:31:09 <nand`> foo = ((f <<= g) <<=) <=< return
02:31:23 <nand`> but that brings me to the point; return x >>= f is the same as ‘f x’; or in other terms, return >=> f is f
02:31:25 <nand`> so that's the same as
02:32:06 <nand`> foo = ((f <=< g)
02:32:15 <nand`> unless I got my terms screwed up somewhere
02:32:20 <nand`> which, of course, translates back to foo = f . g
02:32:41 <neutrino_> is (.) (<=<) in other monads?
02:33:05 <nand`> none that I can think of
02:33:08 <neutrino_> ok
02:33:29 <neutrino_> >=> = flip <=<, right?
02:33:40 <nand`> yes
02:33:53 <nand`> flip (<=<)
02:34:15 <neutrino_> sure
02:34:32 <neutrino_> that's all fairly cool
02:34:42 <neutrino_> how do you express >=> in terms of >>=?
02:34:52 <nand`> @src (>=>)
02:34:52 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:35:02 <Cale> (f >=> g) x = f x >>= g
02:35:07 <nand`> yeah, that
02:35:23 <Cale> (f <=< g) x = f =<< g x
02:35:31 <neutrino_> so in fact, foo would be (return >=> f >=> g), no?
02:35:42 <nand`> yes
02:35:47 <Cale> return >=> f = f
02:35:51 <nand`> which is (f >=> g) as described above
02:35:53 <neutrino_> oh
02:36:04 <neutrino_> that's pretty cool
02:37:09 <neutrino_> thanks guys
02:37:10 <nand`> Identity is a bit useless on its own
02:37:23 <neutrino_> what do you use it with?
02:37:32 <nand`> usually, monad transformers
02:37:43 <nand`> (lens also uses it in interesting ways)
02:38:10 <nand`> neutrino_: for example, given StateT :: * -> (* -> *) -> * -> *
02:38:22 <nand`> State s = StateT s Identity
02:39:28 <nand`> runState x = runIdentity . runStateT x
02:39:43 <neutrino_> i've used neither State nor StateT
02:39:58 <latermuse> if I have a list of text files ["1.txt","2.txt"] and I want to get their contents, while keeping the filename, how can I do that with arrows? I want the output to look like: [("1.txt","contents of file 1"),("2.txt","contents of file 2")]? I tried "(id &&& readFile) fileList", but it wont work
02:40:21 <latermuse> ive managed to do it with monads, but it seems more elegant to do it with arrows
02:40:26 <Ralith> :t (id &&& readFile)
02:40:28 <lambdabot> FilePath -> (FilePath, IO String)
02:40:47 <nand`> :t (return &&& readFile)
02:40:49 <lambdabot> Monad m => FilePath -> (m FilePath, IO String)
02:41:00 <nand`> @hoogle (m a, m b) -> m (a, b)
02:41:01 <lambdabot> No results found
02:41:05 <nand`> this was called ‘strength’, no?
02:41:11 <nand`> :t strength
02:41:13 <lambdabot> Not in scope: `strength'
02:41:22 <nand`> @let strength (a, b) = liftA2 (,) a b
02:41:24 <lambdabot>  Defined.
02:41:32 <nand`> :t mapM (strength . (return &&& readFile))
02:41:33 <lambdabot> [FilePath] -> IO [(FilePath, String)]
02:41:40 <nand`> latermuse: &
02:41:42 <nand`> ^*
02:41:46 <neutrino_> nand`: that's fairly cool. i guess the Identity monad is useful for composing with a lot of monads?
02:42:02 <latermuse> that works? damn :) ill have to try that
02:42:10 <nand`> neutrino_: yeah; if you don't want a stack of monads, you can terminate it with Identity
02:42:46 <nand`> :t \x -> zipM (return x) (mapM readFile x)
02:42:48 <lambdabot>     Not in scope: `zipM'
02:42:48 <lambdabot>     Perhaps you meant one of these:
02:42:48 <lambdabot>       `zip3' (imported from Data.List),
02:42:54 <Ralith> nand`: why's that called 'strength'?
02:43:06 <nand`> Ralith: no clue whatsoever
02:43:08 <nand`> but it is
02:43:11 <Ralith> huh.
02:43:17 * nand` looks it up
02:43:24 <latermuse> works wonderfully, by the way!
02:43:37 <neutrino_> nand`: what does it mean to terminate a stack of monads?
02:43:58 <nand`> @unmtl ReaderT r (StateT s (WriterT w Identity))
02:43:59 <lambdabot> Plugin `unmtl' failed with: `ReaderT r (StateT s (WriterT w Identity))' is not applied to enough arguments, giving `/\A. r -> s -> (A, s, w)'
02:44:03 <nand`> oh
02:44:05 <nand`> @unmtl ReaderT r (StateT s (WriterT w Identity)) a
02:44:05 <lambdabot> r -> s -> (a, s, w)
02:44:12 <nand`> @unmtl ReaderT r (StateT s Identity)
02:44:12 <lambdabot> Plugin `unmtl' failed with: `ReaderT r (StateT s Identity)' is not applied to enough arguments, giving `/\A. r -> s -> (A, s)'
02:44:15 <nand`> @unmtl ReaderT r (StateT s Identity) a
02:44:15 <lambdabot> r -> s -> (a, s)
02:44:42 <neutrino_> what practical outcome does it have?
02:44:50 <neutrino_> i don't know about monad stacks
02:44:51 <nand`> each transformer takes as parameter the next monad in the stack; so until you reach Identity or IO or some other non-transformer monad, you'd have to keep recursing
02:45:12 <nand`> well, if you're interested, the typeclassopedia is a good place to start
02:45:14 <nand`> @where typeclassopedia
02:45:14 <lambdabot> http://www.haskell.org/haskellwiki/Typeclassopedia
02:45:21 <neutrino_> i know @unmtl because i just added a command for it to vim :) but i don't know what it does other than "operate on monad stacks"
02:45:48 <neutrino_> mhm
02:45:52 <neutrino_> ok i get it now
02:46:13 <neutrino_> so basically Identity is kind of like the "return" of stackable monads?
02:46:43 <nand`> Identity is like the identity of stackable monads
02:47:09 <neutrino_> i'm not sure what "identity" is
02:47:13 <neutrino_> in that context
02:47:52 <exDM69> woohoo, emitting llvm bitcode from my programming language compiler project works!
02:48:01 <nand`> something is called an ‘identity’ of some operation if  ‘e * x = x = x * e’ where e is the identity and (*) is the operation
02:48:05 <exDM69> I can now successfully compile the following expressions: 1 and x
02:48:10 <nand`> for an example, 0 is the identity of (+); since 0 + x = x
02:48:21 <nand`> 1 is the identity of (*); since 1 * x = x
02:48:29 <nand`> haskell's ‘id’ is the identity of (.); since id . f = f
02:48:52 <neutrino_> right, why is Identity the identity of stackable monads?
02:49:43 <nand`> well, because it doesn't add any extra semantics; StateT s Identity = State s; and (if we had it) IdentityT (State s) = State s
02:50:06 <nand`> in each case, you're only getting the ‘effects’ of State
02:51:13 <neutrino_> but isn't that more like lifting in a commutative graph
02:51:31 <nand`> sorry, I don't know what you mean by that
02:52:18 <neutrino_> before i explain, some semantics. the right way to call WhateverT is that it's a "monad transformer", right?
02:52:28 <nand`> yes
02:52:40 <nand`> a “monad transformer” is an instance of class MonadTrans
02:52:51 <neutrino_> ok. so imagine a graph which is horizontal and the arrows pointing left are monad transformers.
02:52:56 <nand`> (in mtl terminology)
02:53:10 <nand`> okay
02:53:47 <ion> shachaf: I wonder if there’s any way to make a type with which e.g. show ((,) <$> shown "foo" <*> shown "bar") == "(_ :: String -> String -> (String,String)) <$> shown \"foo\" <*> shown \"bar\""? That would be convenient for, say, a Show instance for Bazaar. I can’t think of a way to do that without being able to add constraints like fmap :: (Show a, Show b, Typeable a, Typeable b) => (a -> b) -> Shown a
02:53:48 <ion> -> Shown b.
02:53:54 <neutrino_> now if you want to go from a chain of monad transformers to a chain of monads you'd have an up-arrow pointing towards the rightmost point in the original graph, and a down-arrow pointing from the leftmost point
02:54:24 <neutrino_> i am guessing that such a graph is commutative
02:54:49 <neutrino_> i believe that Identity is the arrow pointing up
02:55:14 <neutrino_> and IdentityT the arrow pointing down
02:55:29 <nand`> I'm not sure what a ‘chain of monads’ would be in this context, nor what an ‘arrow’ is
02:56:02 <neutrino_> an arrow is a graphic that looks like this: <------
02:56:32 <nand`> I mean its meaning in this context
02:57:28 <neutrino_> let's say you have a monad stack that's just WriterT. that's one point. from that an arrow points left that says "StateT". the point to the left of it is the monad stack StateT .. WriterT ..
02:58:20 <neutrino_> that's just an idea, nothing specific
02:58:22 <nand`> right; so arrows are just ‘functions’ between monads?
02:58:29 <neutrino_> yes
02:59:05 <neutrino_> i'm not sure if that works, but i wanted to describe it to you to see what you think
02:59:15 <shachaf> ion: I'm not sure I understand.
02:59:20 <nand`> then I'm not sure how you want to bring a ‘chain of monads’ into this context at all
03:00:32 <neutrino_> well, if you look at the points (WriterT ...) and (StateT .. WriterT ..) then they're not really monads
03:00:43 <neutrino_> they're monad transformers, because they're missing the termination you speak of
03:01:05 <nand`> right
03:01:12 <neutrino_> so to change that to a monad you need to terminate it
03:01:53 <neutrino_> by having an arrow that points towards the point (Writer T ...) that is called "Identity"
03:01:59 <nand`> by ‘monad stack’ do you mean (StateT s (WriterT w Identity)), for example?
03:02:01 <shachaf> ion: Oh, maybe I do understand?
03:02:06 <shachaf> Why do you need a separate type?
03:02:10 <neutrino_> yes nand`
03:02:33 <nand`> oh, yes, that makes more sense; I was thinking you were trying to represent State s (Writer w x) or something
03:03:00 <shachaf> I mean, if you want a Show instance for Bazaar, why can't you just write something like showBazaar :: (Typeable a, Show a, Show t) => Bazaar a a t -> String?
03:03:02 <neutrino_> right, so Identity is kind of like a lift
03:03:16 <shachaf> But I'm probably missing something about your question. :-)
03:03:21 <neutrino_> that's why i thought Identity is the return of this world
03:03:29 <neutrino_> do you see that as well?
03:03:52 <nand`> neutrino_: assuming, for a moment, we had type functions; and our monad stacks were (WriterT w . StateT s)
03:04:01 <nand`> then the ‘lifting’ would be ($ Identity)
03:04:22 <neutrino_> wait. is (WriterT w . StateT s) terminated or not?
03:04:25 <nand`> (it's not unlike continuations in that context)
03:04:38 <nand`> it wouldn't be
03:04:39 <shachaf> Seems like this is a topic for #haskell-overflow
03:04:43 <neutrino_> ok
03:04:47 <nand`> probably
03:05:01 <shachaf> What with it having been in the channel for the past hour. :-)
03:05:35 <nand`> not a lot of other discussion going on until shachaf/ion's, for that matter
03:06:06 <neutrino_> shachaf's just unhappy because he doesn't like me
03:06:11 <neutrino_> anyways.
03:06:14 <shachaf> Yes, but this is fruitless discussion.
03:06:24 <neutrino_> nand`: i look at "return" as "plugging a hole in a chain of monadic values linked by bind". In the same way Identity plugs a hole in an unterminated monad transformer chain.
03:06:25 <nand`> I don't think shachaf likes anybody
03:06:32 <nand`> nonetheless, I agree
03:06:41 <neutrino_> do you see this semantic similarity?
03:06:55 <nand`> this is rapidly diverging from ‘useful in a Haskell context’ and ‘unnecessary ways to bring it into a graph’
03:07:00 <nand`> s/and/to/
03:07:25 <neutrino_> well, i'm sort of trying to understand why you said Identity is the identity of monad transformers, rather than saying that IdentityT is the identity of monad transformers
03:07:30 <neutrino_> which felt more natural
03:08:42 <neutrino_> i mean if we apply IdentityT to either side of an unterminated monad stack, then we get that same monad stack, right?
03:08:56 <nand`> I did say ‘kind of like’, and not ‘is’; but any way, it may have just been a word used incorrectly; it's not worth deliberating over semantics like this
03:09:06 <neutrino_> hmm ok i think you're right
03:09:47 <nand`> and yeah; IdentityT would be the proper identity of monad stacks under “composition”
03:09:56 <neutrino_> mhm
03:10:05 <nand`> and ‘Identity’ is kind of like IdentityT; so there you have it :P
03:10:25 <neutrino_> i still think "Identity" is the return of monad stacks :)
03:10:26 <nand`> (that's not at all what I meant earlier, but a good excuse :))
03:10:31 <neutrino_> :)
03:10:47 <neutrino_> by the way, i wanted to ask some other thing as well
03:11:13 <neutrino_> is there a function which takes two data structures and swaps them? for example, (a, [b]) -> [(a, b)]
03:11:47 <neutrino_> so (1, [1, 2, 3, 4]) -> [(1, 1), (1, 2), (1, 3), (1, 4)]
03:13:05 <neutrino_> i tried searching on hoogle but i'm not really sure what to search for. i've found no meaningful results.
03:13:24 <nand`> neutrino_: looks like you're thinking of Traversable
03:13:30 <nand`> :t sequenceA
03:13:31 <lambdabot>     Not in scope: `sequenceA'
03:13:32 <lambdabot>     Perhaps you meant one of these:
03:13:32 <lambdabot>       `Data.Traversable.sequenceA' (imported from Data.Traversable),
03:13:35 <nand`> :t Data.Traversable.sequenceA
03:13:37 <lambdabot> (Applicative f, Traversable t) => t (f a) -> f (t a)
03:13:53 <nand`> in particular, (,) a is Traversable; and [] is applicative
03:13:55 <neutrino_> i've already written a function which specifically takes the case (a, [b]) -> [(a, b)] but it would be nice to have something like f a (g b) -> g (f a b)
03:13:58 <nand`> so in your example, that would do the right thing
03:14:03 <neutrino_> mhm
03:14:34 <neutrino_> i knew something like this existed!
03:14:45 <neutrino_> thanks nand`, you know so much about haskell libs
03:15:11 <neutrino_> luite: let me check out hamishmack
03:15:59 <nand`> most of it comes from code golfing in #haskell, where ‘obscure functions to do some particular thing very concisely’ comes in handy
03:16:10 <neutrino_> ah
03:16:12 <neutrino_> heheh
03:16:41 <luite> neutrino_: he's a leksah dev
03:16:41 <neutrino_> i'm doing a bit of code golfing myself. it's fun. but when it's more difficult then it's mostly me coming here with a problem and someone else solving it for me :))
03:17:03 <neutrino_> luite: is leksah this project that can compile down to ghcjs or windowing?
03:17:24 <neutrino_> luite: i think this kind of approach could or could not be useful for your workbook project..
03:17:30 <nand`> neutrino_: oh yeah; (a, [b]) -> [(a, b)] is also ‘strength’
03:17:49 <neutrino_> nand`: why is it "strength"?
03:18:05 <nand`> I'm still trying to find that out for Ralith
03:18:12 <luite> neutrino_: a local installation would launch a webkit window and run a local server
03:18:14 <neutrino_> :))
03:18:25 <neutrino_> nand`: now it's time to apply your skills as a historian..
03:18:26 <luite> neutrino_: currently i'm aiming for just web, not cross platform
03:18:34 * Ralith appreciates the persistence!
03:18:34 <nand`> @ask edwardk Why is it called ‘strength’?
03:18:34 <neutrino_> luite: i know, that's kind of too bad
03:18:35 <lambdabot> Consider it noted.
03:18:48 <Ralith> even when it takes the form of delegation >_>
03:18:49 <neutrino_> luite: i kinda hate web apps :)
03:18:57 <luite> neutrino_: but if hamishmack can get the cross platform stuff in, it would run with the local webkit api
03:19:01 <nand`> Ralith: not at all, I just forgot about it until neutrino_ reminded me
03:19:01 <neutrino_> buuuut i can see the value of this approach
03:19:01 <luite> or even gtk
03:19:07 <neutrino_> hmm right
03:19:15 <shachaf> nand`: http://en.wikipedia.org/wiki/Strong_monad
03:19:19 <luite> at least the code would run native then, not js
03:19:20 <neutrino_> interesting
03:19:27 <luite> js is still at least 10x slower than native here
03:19:44 <Ralith> shachaf: ah.
03:20:19 <shachaf> http://comonad.com/reader/2008/deriving-strength-from-laziness/
03:20:23 <nand`> (on that matter, why is it called ‘Density’?)
03:20:30 <neutrino_> http://ncatlab.org/nlab/show/tensorial+strength
03:20:35 <latermuse> shachaf: thats the densest wikipedia page ive ever seen
03:20:35 <neutrino_> look at the second equation here
03:20:47 <nand`> shachaf: that, surprisingly, makes sense
03:20:50 <neutrino_> i think that looks exactly like the type for strength
03:21:12 <nand`> latermuse: wikipedia has a few arcane pages on cat theory concepts
03:21:27 <nand`> I think there's one for the Grothendieck construction or something
03:21:33 <neutrino_> oh yeah, wikipedia on cat theory has some weird things in it
03:21:47 <neutrino_> similarly algebra
03:22:31 <FireFly> Are there other (better?) resources if you want to mess about and try to understand category theory stuff?
03:22:38 <FireFly> I mean, so far I've mostly relied on wikipedia
03:22:41 <neutrino_> books
03:22:45 <FireFly> (although so far it's mostly basics)
03:22:47 <FireFly> Ah
03:23:52 <shachaf> FireFly:         23:36 <ddarius> shachaf: Awodey's book and/or Barr and Wells' ESSLLI lecture notes to start.
03:24:03 <shachaf> The latter is free online.
03:24:09 * nand` started with Pierce's ‘Category Theory for Computing Science’
03:24:16 <nand`> but I'm not the best person to ask for this
03:25:43 <FireFly> shachaf: thanks
03:28:46 <latermuse> can arrows work on any non 2-tuples?
03:29:08 <shachaf> latermuse: You can make bigger tuples out of smaller tuples.
03:29:28 <latermuse> oh yeah, i forgot. thanks!
03:29:31 <nand`> don't forget you can always compose with arr (\(a,b,c) -> (a,(b,c)) as well
03:29:33 <latermuse> (a,(b,c))
03:29:38 <nand`> so you can write your own (&&&&) or whatnot
03:30:01 <startling> why don't the arrow functions go up to 60 too? :(
03:30:12 <shachaf> Don't be gross, startling.
03:30:35 * startling places his elbows on the table and burps loudly.
03:32:05 <neutrino_> nand`: by the way this doesn't seem to work
03:32:08 <neutrino_> > Data.Traversable.sequenceA (1, [2, 3])
03:32:10 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t0))
03:32:10 <lambdabot>    arising from a u...
03:32:23 <neutrino_> @more
03:32:33 <neutrino_> hmm how did you do that again
03:32:50 <nand`> I've always been wondering where that instance went
03:33:00 <nand`> (it should be legal, no?)
03:34:05 <startling> > traverse (:[]) (1, 2)
03:34:06 <lambdabot>   No instance for (Data.Traversable.Traversable ((,) t0))
03:34:07 <lambdabot>    arising from a u...
03:35:13 <startling> > Data.Foldable.foldr (+) 0 (1, 2)
03:35:15 <lambdabot>   No instance for (Data.Foldable.Foldable ((,) t0))
03:35:15 <lambdabot>    arising from a use of ...
03:35:18 <startling> silly.
03:35:33 <Ralith> > toListOf both (1, 2)
03:35:35 <lambdabot>   [1,2]
03:36:22 <Ralith> @src toListof
03:36:22 <lambdabot> Source not found. I am sorry.
03:37:48 <nand`> > sequenceOf both
03:37:50 <lambdabot>   Ambiguous type variable `m0' in the constraint:
03:37:50 <lambdabot>    (GHC.Base.Monad m0) aris...
03:38:15 <startling> :t toListOf
03:38:16 <lambdabot> Getting [a] s t a b -> s -> [a]
03:38:47 <startling> > toListOf traverse Nothing
03:38:49 <lambdabot>   []
03:39:19 <bxx> > sortBy (compare `on` length) $ words "aaa a aa aaa"
03:39:21 <lambdabot>   ["a","aa","aaa","aaa"]
03:39:24 <bxx> sortBy (comparing length) $ words "aaa a aa aaa"
03:39:28 <bxx> which one do you prefer?
03:40:06 <Ralith> comparing isn't in my ghci's scope
03:40:09 <Ralith> so the other one
03:40:35 <Ralith> (plus, composition is fun)
03:40:43 <startling> @hoogle comparing
03:40:44 <lambdabot> Data.Ord comparing :: Ord a => (b -> a) -> b -> b -> Ordering
03:40:55 <startling> either way you need an import.
03:41:09 <nand`> > sequenceOf _2 ("foo", [1..5])
03:41:11 <lambdabot>   [("foo",1),("foo",2),("foo",3),("foo",4),("foo",5)]
03:41:19 <bxx> comparing is using composition too no?
03:41:55 <nand`> > sequenceOf both (Just 3, Just 4)
03:41:57 <lambdabot>   Just (3,4)
03:42:01 <bxx> is there something like comparing for equality
03:42:34 <bxx> > groupBy ((==) `on` (> 0)) [-5..5]
03:42:36 <lambdabot>   [[-5,-4,-3,-2,-1,0],[1,2,3,4,5]]
03:42:49 <bxx> is there a comparing equivalent for this in standard lib?
03:43:51 <startling> @hoogle Eq b => (a -> b) -> a -> a -> Bool
03:43:52 <lambdabot> Data.Function on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
03:43:52 <lambdabot> Prelude maybe :: b -> (a -> b) -> Maybe a -> b
03:43:52 <lambdabot> Data.Maybe maybe :: b -> (a -> b) -> Maybe a -> b
03:44:01 <nand`> :t equating
03:44:03 <lambdabot> Not in scope: `equating'
03:44:12 <nand`> oh, so that was in @let
03:51:37 <Jeanne-Kamikaze> anyone here using mageia by any chance ? they've got ghc but no cabal-install in their repos :/
03:52:35 <neutrino_> and no haskell-platform?
03:53:05 <Jeanne-Kamikaze> nope
03:53:08 <Jeanne-Kamikaze> no haskell anything
03:55:18 <profmakx> Jeanne-Kamikaze, just chase down the dependencies of cabal install and install manually. it's a bit of a pain but usually works
03:56:31 <Jeanne-Kamikaze> guess that's the only option
03:57:16 <profmakx> better yet: make the platform available on that distribution :P
03:57:20 <profmakx> while you're at it
03:59:19 <shachaf> Hmm, is bazaar a valid Traversal family thing?
03:59:30 <shachaf> bazaar :: Traversal (Bazaar a b t) t a b
03:59:42 <startling> :t bazaar
03:59:44 <lambdabot> Not in scope: `bazaar'
04:00:19 <shachaf> If Traversal ought to be (o a) (o b) (i a) (i b), what are o and i for bazaar?
04:15:49 <neutrino_> wow i've actually found a function that survives @pl and then @unpl
04:15:54 <neutrino_> @@ @unpl @pl findCoords pred layer = strength (zip [0..] (map (findIndices pred) layer) )
04:15:54 <lambdabot>  findCoords d m = strength (zip [0 ..] (map (findIndices d) m))
04:16:00 <neutrino_> that's a first for me :))
04:17:39 <neutrino_> hmm even though the source is incorrect...
04:21:10 <bitonic> I remember some library to write REPLs, did I imagine it?
04:21:34 <bitonic> haskeline is probably enough
04:21:51 <shachaf> forever (read >>= eval >>= print)?
04:21:54 <bitonic> but I was wondering if there was something with the concept of an environment
04:22:28 <bitonic> shachaf: yeah I might just do that :)
04:24:58 <bitonic> actually haskeline is fine.
04:31:19 <startling> bitonic: just do read' >>= eval >>= print', where they're all StateT Environment IO x
04:31:49 <bitonic> startling: yeah but I had seen something more structured - that something is haskeline
04:31:54 <bitonic> I want history, completions, etc.
04:38:29 <neutrino_> bitonic: rlwrap your-app
04:38:41 <bitonic> neutrino_: that doesn't work for the completion part
04:38:49 <neutrino_> oh, right, sorry
04:38:53 <neutrino_> yeah, hmm
04:39:09 <neutrino_> well, you can define completions in readline.. but i don't think it's worth it.
04:39:29 <bitonic> neutrino_: well since my software is in Haskell is much nicer to do the completions in haskell :)
04:39:39 <neutrino_> yes.
04:39:43 <neutrino_> :)
04:41:24 <latermuse> which libraries are websites using for in-site haskell syntax highlighting?
04:42:39 <bitonic> latermuse: kate-highlight
04:42:49 <bitonic> and that indirectly through pandoc
04:43:31 <neutrino_> pandoc++
04:43:38 <latermuse> thanks
04:43:45 <bitonic> pandoc is absolutely great
04:47:30 <neutrino_> @hoogle (a, (a, a)) -> (a, a, a)
04:47:31 <lambdabot> No results found
04:48:41 <neutrino_> @type uncurry $ uncurry (,,)
04:48:43 <lambdabot> ((a, b1), b) -> (a, b1, b)
04:49:35 <neutrino_> @type uncurry $ flip $ uncurry (,,)
04:49:37 <lambdabot> (a, (a1, b)) -> (a1, b, a)
04:50:04 <mapf> aw, pointfreezation
04:50:16 <neutrino_> > (uncurry $ flip $ uncurry (,,)) (1, (2, 3))
04:50:18 <lambdabot>   (2,3,1)
04:50:24 <neutrino_> kind of fukt
04:50:38 <neutrino_> :)
04:51:18 <neutrino_> @djinn (a, (b, c)) -> (a, b, c)
04:51:19 <lambdabot> f (a, (b, c)) = (a, b, c)
04:51:22 <neutrino_> yep that worked well
04:51:50 * neutrino_ is happy he put a command for that in vim
04:54:16 <nand`> does kate-highlight handle all of the corner cases correctly? like ' in front of names with DataKinds, I've seen a few scripts break on that
05:00:43 <neutrino_> hmm strength doesn't seem to be performing
05:00:49 <neutrino_> > strength (1, [2, 3])
05:00:51 <lambdabot>   No instance for (GHC.Num.Num [a0])
05:00:51 <lambdabot>    arising from a use of `e_1123'
05:00:52 <lambdabot>  Possi...
05:00:57 <neutrino_> i'm not sure what i'm doing wrong here
05:01:42 <nand`> oh, I think I named that incorrectly
05:01:54 <neutrino_> oh?
05:02:00 <nand`> what I defined wasn't actually strength, it was sequenceOf both
05:02:02 <nand`> @undefine
05:02:05 <mapf> :t strength
05:02:07 <lambdabot> Not in scope: `strength'
05:02:18 <nand`> @let strength = sequenceOf _2
05:02:20 <lambdabot>  Defined.
05:02:25 <nand`> > strength (1, [2,3])
05:02:28 <lambdabot>   [(1,2),(1,3)]
05:02:39 <nand`> that type may be a bit too generous though
05:02:41 <mapf> :t sequenceOf
05:02:43 <nand`> > strength (1, [2,3], 3)
05:02:43 <lambdabot> LensLike (WrappedMonad m) s t (m b) b -> s -> m t
05:02:45 <lambdabot>   [(1,2,3),(1,3,3)]
05:02:50 <neutrino_> _2 is from lens, right?
05:02:54 <startling> yes.
05:02:54 <neutrino_> ya
05:02:57 <nand`> yes
05:03:02 <mapf> :t _2
05:03:04 <lambdabot> (Functor f, Field2 s t a b) => (a -> f b) -> s -> f t
05:03:07 <neutrino_> meh, i'll just use a listcomp
05:03:13 <mapf> hell
05:03:16 <startling> > (1, 2)^._2
05:03:18 <lambdabot>   2
05:03:25 <neutrino_> yeah startling
05:03:32 <deu5> I am searching web framework with . It must be  secure ,fast with a good support for postgres. I know that Haskell have 3 major web frameworks. Witch of them is the most documented with a biggest community ?
05:03:44 <mapf> > (1, 2, 3)^._2
05:03:47 <lambdabot>   2
05:03:53 <mapf> :t (^.)
05:03:55 <lambdabot> s -> Getting a s t a b -> a
05:04:13 <nand`> Getting s t a b b e d
05:04:18 <mapf> heh
05:22:06 <aristid> conjecture: with every year passing, the average number of type parameters on a haskell type rises by 0.25
05:22:57 <atriq> aristid, what would you say it is at now?
05:23:41 <aristid> 5.
05:23:51 <atriq> 0.8 ^ 10 * 5
05:24:03 <atriq> > 0.8 ^ 10 * 5
05:24:05 <lambdabot>   0.5368709120000006
05:24:07 <srhb> How could I make a noneOf equivalent that deals with lines in Parsec? Ie. noneOf ["aLine", "anotherLine"]
05:24:11 <startling> aristid, that sounds wrong
05:24:16 <atriq> That would have been 2002
05:24:23 <aristid> atriq: what?
05:24:34 <aristid> startling: why?
05:24:52 <atriq> Extrapolating, inverse (1.25) = 0.8
05:25:05 <atriq> So, 10 years ago would have been now * 0.8^10
05:25:09 <startling> aristid, average number of type parameters is 5? Usually it's one or two or three, isn't it?
05:25:17 <atriq> =0.537
05:25:20 <aristid> atriq: absolute increase, not percentage increase.
05:25:26 <atriq> Aaah
05:25:50 <aristid> startling: perhaps for the hoi polloi, but the elite libraries push up that average
05:26:12 <startling> aristid, make sure your jokes are statistically sound before bringing them to #haskell!
05:26:31 <aristid> startling: but they are!
05:26:46 <startling> aristid: burden of proof yo
05:26:47 <aristid> startling: the types in the lens library alone are so many they cannot help but push up the average
05:27:08 <atriq> :k Overloaded
05:27:10 <lambdabot> Top level:
05:27:10 <lambdabot>     Type synonym `Overloaded' should have 6 arguments, but has been given none
05:27:10 <lambdabot>     In a type in a GHCi command: Overloaded
05:27:18 <atriq> Case in point
05:27:22 <startling> haha
05:27:27 <startling> :t itraverse
05:27:28 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
05:27:35 <startling> 4
05:27:36 <aristid> startling: and Tekmo (pipes library) has now increased the number of type parameters on his I/O pipe/proxy type from 5 to 6
05:27:45 <startling> aristid: heh
05:28:02 <aristid> and this is just the beginning!
05:28:15 <aristid> soon people will demand type records to manage their type parameters
05:28:23 <startling> heh
05:28:44 <startling> can't you already do that?
05:29:14 <aristid> startling: with DataKinds? not sure, i think they are somewhat limited but i'm not sure what exactly can be done
05:29:32 <startling> aristid: that's what I was thinking, but I'm not sure either.
05:29:51 <aristid> http://hackage.haskell.org/packages/archive/pipes/2.5.0/doc/html/Control-Proxy-Core.html
05:29:59 <aristid> behold the glory
05:30:42 <typoclass> srhb: ohai! :-) this doesn't use parse, but have you tried «map f $ lines input where f "aLine" = ... ; f "anotherLine" = ..."»
05:31:33 <startling> So i think I'm getting better at writing short functions with huge inferred types.
05:32:16 <typoclass> srhb: (works for me to use the regular functions like lines, words, and so on. i have some sort of rare parsec dyslexia. whenever i try to do something with parsec, it ends up being a complete mess and i rewrite it with regular functions anyway)
05:33:03 <aristid> typoclass: i hope you can recover from this grave disease.
05:33:15 <startling> I always end up trying to write a parsing library, because I'm foolishly convinced that I can write a thing with better error-handling.
05:34:23 <typoclass> aristid: i dunno ... i feel that i must be doing it wrong, but at the same time, i can't tell where i'm deviating from rwh's parsec chapter
05:34:49 <aristid> typoclass: maybe rwh's chapter is a bit outdated?
05:35:15 <typoclass> aristid: no idea? is there any other introduction?
05:35:30 <startling> typoclass: there's the parsec page but it's pretty mediocre
05:35:36 <startling> usually I just stare at the haddocks
05:37:25 <atriq> Is it possible to make an isolated install of GHC + libraries for testing stuff?
05:37:25 <aristid> typoclass: yeah, there's a paper, which is outdated too, and the only up-to-date docs are the haddocks
05:38:09 <aristid> atriq: yes
05:38:11 <typoclass> in the simplest case, i do char '\n'. then in another place you need noneOf "\n". already i'm not too thrilled about the duplication. later i go 'well why not support \r\n line endings', so the first becomes «string "\n" <|> string "\r\n"» and the second becomes god knows what :-)
05:38:25 <aristid> atriq: for the isolated libraries, one popular option is apparently cabal-dev
05:38:40 <typoclass> i dunno, i always end up with tons of duplication and stuff that feels weird and unstraightforward
05:38:47 <atriq> MIght it be simpler to make another user on this computer and test there?
05:38:57 <typoclass> then i decide it's way easier to just do "lines" and "words" and stuff :-/
05:39:08 <aristid> typoclass: well, parsec is a bit unautomatic in some ways, i guess
05:39:27 <aristid> typoclass: you need to factor your grammar in a specific way for it to like ti
05:39:31 <startling> typoclass: if you know of a specific example, we might be able to help
05:39:42 <startling> parsing is weird and unituitive
05:39:46 <typoclass> startling: right, i should hpaste it next time :-)
05:40:22 <typoclass> aristid: yeah, that's probably it. you need to factor it in a very specific way, otherwise you end up with tons of "try" everywhere, and that doesn't look right
05:41:37 <Pranz> > filter (0 == % 2) [1..10]
05:41:38 <lambdabot>   <hint>:1:14: parse error on input `%'
05:41:58 <Pranz> > filter (0 == div 2) [1..10]
05:41:59 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
05:42:00 <lambdabot>              with actua...
05:42:05 <Pranz> > filter (0 == mod 2) [1..10]
05:42:06 <lambdabot>   Couldn't match expected type `a0 -> GHC.Types.Bool'
05:42:07 <lambdabot>              with actua...
05:42:20 <startling> Pranz, you need a function, not a Bool
05:42:22 <aristid> typoclass: i'm not sure if the fancier parsing libraries like trifecta and uu-parsinglib are better in that regard
05:42:27 <typoclass> > filter (\x -> 0 == x `mod` 2) [1..10] -- pranz, try this :-)
05:42:29 <lambdabot>   [2,4,6,8,10]
05:42:32 <startling> Pranz: (0 == mod 2) is trying to be a Bool
05:42:42 <Pranz> Ah
05:42:51 <Pranz> Yeah i was just wondering if there was possible without lambda there
05:43:01 <Pranz> but thanks
05:43:04 <startling> > filter ((==) 0 . mod 2) [1..10]
05:43:06 <lambdabot>   [1,2]
05:43:14 <startling> uh
05:43:22 <Pranz> Ah lol
05:43:26 <Pranz> It checks in reverse then
05:43:27 <typoclass> Pranz: yeah it is, but i'm not sure if it'll be more readable :-/
05:43:30 <startling> > filter ((==) 0 . flip mod 2) [1..10]
05:43:32 <lambdabot>   [2,4,6,8,10]
05:43:41 <typoclass> > filter ((0 ==) . (`mod` 2)) [1..10]
05:43:43 <Pranz> typoclass, haha yeah no
05:43:43 <lambdabot>   [2,4,6,8,10]
05:43:45 <startling> but yeah, lambda is nicer
05:43:50 <Pranz> that is definetily not more readable
05:43:53 <rwbarton> @pl (\x -> 0 == x `mod` 2)
05:43:54 <lambdabot> (0 ==) . (`mod` 2)
05:43:55 <Pranz> :)
05:43:58 <startling> typoclass' isn't bad.
05:44:43 <Pranz> Oh yeah that was kind of a nice expression
05:45:03 <typoclass> Pranz: i'd probably use the "\x -> ..." version. it took me quite a while to get used to the unclear ( ) . ( ) stuff
05:48:17 <atriq> aristid, going back to what you were saying last night, how does that fundeppy way work?
05:48:40 <Philonous> > filter even [1..10]
05:48:42 <lambdabot>   [2,4,6,8,10]
05:48:54 <Pranz> haha
05:48:56 <startling> Philonous: heh
05:49:14 <Pranz> Btw is there any good module for sound generation in haskell?
05:49:25 <startling> it's too bad == can't work on Eq b => a -> b like the Num functions can
05:51:12 <aristid> atriq: basically just class (MakeHTTPQuery request, ParseHTTPResponse response) => Transaction request response | request -> response
05:51:41 <aristid> atriq: and then when you have a specific request type, you can always find the matching response type with that class by just adding the Transaction constraint
05:54:17 <typoclass> startling: i dunno, if the types don't match, it can't be equal, can it? the first part of the equality can be decided at compile time already, hence the (==) :: a -> a
05:54:22 <atriq> aristid, okay, I'm pretty sure that isn't what I want
05:54:35 <atriq> Because all my functions end up with a JSON Value in some monad
05:54:41 <startling> typoclass: right, it's too bad the universe works like that. :(
05:55:00 <atriq> And it won't help neaten the piles of parameters
05:55:03 <aristid> atriq: just returning unparsed JSON values is _lame_ :P
05:55:09 <atriq> True, true
05:55:14 <atriq> Early days yet
05:55:50 <deu5> Does any of you use haskell for build web app ?
05:56:03 <atriq> brb
05:56:14 <nand`> deu5: lots of people do. I don't, personally
05:57:25 <deu5> nand I am just wondering witch framework choose.
06:05:15 <parcs`> deu5: what's your experience with haskell
06:07:40 <typoclass> deu5: i think the most popular ones are yesod, happstack, and snap
06:10:21 <deu5> parcs little. More with erlang ...
06:12:36 <deu5> typoclass i need something with high secure
06:17:32 <neutrino_> deu5: check out snap
06:17:37 <neutrino_> deu5: it's pretty good
06:18:46 <neutrino_> deu5: they have #snapframework here
06:18:51 <neutrino_> there's also #yesod i believe
06:19:10 <neutrino_> happstack doesn't seem to be doing a lot recently
06:19:38 <startling> hmmm, can I give an (Monad m => m a -> m b) to an (a -> m b) ?
06:19:51 <startling> err
06:20:06 <startling> ((a -> m b) -> c -> m d) actually
06:21:01 <neutrino_> yes, you pass it a value of type a -> m b and then you have c -> m d
06:21:08 <neutrino_> which is isomorphic with a -> m b
06:22:09 <startling> neutrino_, huh?
06:22:25 <startling> I have an m a -> m a function that I want to traverse with.
06:24:37 <neutrino_> oh, i misunderstood you then
06:24:49 <rwbarton> if you have m a -> m a you can get a -> m a by precomposing with return...
06:25:09 <rwbarton> however that might not correspond to what you want to do
06:25:26 <rwbarton> what is your other input?
06:25:37 <rwbarton> besides the m a -> m a function
06:33:13 <startling> I'm trying to traverse with an (m a -> m b)
06:33:28 <sarfraz> hi, can someone help with:http://stackoverflow.com/questions/13430780/gmail-tls-hanshake-failure-in-haskell
06:33:37 <rwbarton> okay right
06:33:43 <rwbarton> but... traverse over what
06:34:38 <rwbarton> what's the type of the data structure you are traversing over
06:37:39 <startling> rwbarton, I wrote both the traversal and the datatype. The traversal's type is Monad m => (Tag (Either t (Node t)) -> m (Tag (Either t (Node t)))) -> Node t -> m (Node t)
06:38:50 <startling> specifically I want to hook it up to a State (m (Tag a)) using execstate, which gets me an m (Tag a) -> m (Tag b)
06:40:49 <rwbarton> State (m (Tag a)) looks quite unlikely
06:41:03 <rwbarton> are you sure you don't mean StateT m (Tag a)
06:41:54 <Philonous> rwbarton:  That's a kind error, isn't it?
06:42:00 <startling> I mean State (m (Tag a)); I want a nice way to dispatch to different traversals depending on its attributes.
06:42:16 <rwbarton> oh
06:42:21 <rwbarton> StateT (Tag a) m ()
06:42:36 <startling> no.
06:42:47 <rwbarton> State (m (Tag a)) is useless if you know nothing about m
06:43:11 <navaati> hi
06:43:12 <lambdabot> navaati: You have 1 new message. '/msg lambdabot @messages' to read it.
06:43:50 <hiptobecubic> Why doesn't lambdabot /query those?
06:43:51 <startling> rwbarton: no it isn't. I have on t = if kind t == s then fn t else return t
06:44:19 <startling> rwbarton: so I can "modify (on "someKind" x)"
06:44:25 <navaati> hi
06:44:41 <startling> er, "modify (>>= on "someKind" x)
06:45:32 <startling> oops, that definition of "on" should have one more parameter, "fn"
06:46:34 <navaati> i've got problems understanding parsec doc : it says, about optionMaybe, that "optionMaybe p tries to apply parser p. If p fails without consuming input, it return Nothing, otherwise it returns Just the value returned by p."
06:47:03 <navaati> But this doesn't cover the case where p fails but have consumed input
06:47:09 <navaati> what happens then ?
06:47:18 <startling> navaati: it just fails, I assume.
06:48:07 <navaati> it means that if i want p to match against more than one letter, i must use try ?
06:48:53 <startling> navaati: that sounds right
06:49:48 <navaati> *nod*, thanks
06:52:24 <mapf> for a given category if opposite exist then it's unique? or not?
06:52:46 <mSSM> list comprehensions are sugar for concatMap ?
06:52:56 <rwbarton> mapf: what is "opposite"
06:52:57 <mapf> and filter
06:53:08 <mapf> rwbarton: opposite category
06:53:13 <rwbarton> there's no condition
06:53:23 <rwbarton> there is always an opposite category
06:53:35 <rwbarton> and yes it is unique but that is because it is just defined by a formula
06:53:42 <startling> mSSM: yeah, kinda
06:54:05 <rwbarton> it has the same objects and morphisms from a to b are morphisms in the original category from b to a
06:54:40 <startling> mSSM: They're more like sugar for >>= (which is concatMap, unless you have MonadComprehensions (?) on) iirc
06:54:53 <mSSM> startling: I just popped an expression into lambabot's @undo and it gave me that ... so I investigated it and it gave me that for e.g. [ x | x <- [0..] ]
06:55:02 <mapf> rwbarton: thanks
06:55:17 <rwbarton> mSSM: http://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-420003.11 see "Translation"
06:55:29 <startling> @undo [x | x <- [0..]]
06:55:29 <lambdabot> concatMap (\ x -> [x]) [0 ..]
06:55:36 <startling> mSSM: ah, fair enough
06:56:05 <mapf> for me it's not clear why opposite category is unique though...
06:56:45 <rwbarton> it's like asking "why is the square of a number unique"
06:56:50 <rwbarton> there is nothing to be clear or not clear
06:57:14 <rwbarton> no way it could ever not be unique
06:57:28 <rwbarton> that's why i wondered what you meant by opposite
06:57:36 <neutrino_> what about modulo n
06:57:48 <startling> rwbarton, the square of a number is not unique
06:57:53 <rwbarton> oh god
06:58:07 <startling> haha
06:58:08 <neutrino_> i thought you were talking about naturals
06:58:09 <rwbarton> people here...
06:58:24 <neutrino_> rwbarton: now you have to show a proof that x^3 is unique over the reals
06:58:28 <startling> rwbarton, (-2)^2 == 2^2
06:58:35 <rwbarton> wut
06:58:50 <rwbarton> for any number n, there is a unique number m for which m is the square of n
06:58:55 <rwbarton> thus, the square of a number is unique
06:59:15 <byorgey> startling: you have showed that the square root is not unique
06:59:18 <mapf> but squaring isn't bijective
06:59:20 <rwbarton> I didn't say square roots weren't unique
06:59:24 <rwbarton> nor did I say that, right
06:59:27 <rwbarton> er
06:59:28 <startling> byorgey: ah
06:59:29 <rwbarton> *were
06:59:43 <startling> never mind!
06:59:50 <neutrino_> i think you wanted to say "single-valued", rwbarton
07:00:06 <startling> anyway, I doubt mapf is using a rigorous definition of "unique".
07:01:20 <rwbarton> startling: actually you illustrated my point nicely :)
07:01:40 <rwbarton> the fact that squares are unique is so obvious that you thought that could not be what I meant to say
07:01:53 <startling> yep!
07:02:08 <rwbarton> same deal with opposite category, I am wondering if mapf if thinking of some other concept
07:03:17 <rwbarton> questions of existence/uniqueness arise when we define something new (y) in terms of something old (x) by a relation R(x,y)
07:03:36 <rwbarton> but here opposite category (or square) is defined by a formula y = f(x)
07:04:26 <startling> how do I run some Monad m => a -> m a on a StateT a m, then?
07:05:47 <byorgey> startling: foo >>= (lift . blah)
07:05:53 <byorgey> ?
07:06:02 <squidz> -If I want to run common tasks like 'migrate db' what would be best in haskell (something like rake/make or maven)
07:06:41 <byorgey> @package shake
07:06:41 <lambdabot> http://hackage.haskell.org/package/shake
07:07:05 <byorgey> squidz: ^^^ try that?
07:07:16 <rwbarton> startling, I was just catching up with what you wrote about modify/on
07:07:39 <startling> rwbarton, i realized a StateT might be a better idea.
07:07:43 <squidz> thanks, ill look into it
07:09:34 <startling> get >>= lift . myFn >>= put does it. I guess I was expecting a combinator
07:10:49 <rwbarton> hm
07:10:56 <rwbarton> @type get >>= lift . ?myFn >>= put
07:10:58 <lambdabot>     Ambiguous occurrence `lift'
07:10:58 <lambdabot>     It could refer to either `Control.Monad.Writer.lift',
07:10:58 <lambdabot>                              imported from `Control.Monad.Writer' at State/L.hs:17:1-27
07:11:07 <rwbarton> liftM?
07:11:10 <rwbarton> or
07:11:13 <startling> no, lift
07:11:15 <rwbarton> okay
07:11:19 <rwbarton> why is lambdabot sad
07:11:40 <startling> :t \f -> get >>= Control.Monad.Trans.lift . f >>= put
07:11:42 <lambdabot> (Monad m, MonadTrans t, MonadState a (t m)) => (a -> m a) -> t m ()
07:11:44 <rwbarton> @@ @run drop 4 . lines $ @show (@type get >>= lift . ?myFn >>= put)
07:11:45 <lambdabot> Plugin `compose' failed with: Unknown command: "myFn"
07:11:50 <rwbarton> argh
07:12:02 <smg> hi
07:12:21 <startling> rwbarton: I guess this combinator is in lens
07:12:55 <rwbarton> @@ @run drop 4 . lines $ @show (@type get >>= lift . id >>= put)
07:12:59 <lambdabot>   []
07:13:06 <rwbarton> @@ @run drop 3 . lines $ @show (@type get >>= lift . id >>= put)
07:13:09 <lambdabot>   []
07:13:12 <rwbarton> sigh
07:13:16 <startling> :t (%=)
07:13:17 <lambdabot> MonadState s m => Setting s s a b -> (a -> b) -> m ()
07:13:23 <startling> oh, that's not right.
07:13:32 <rwbarton> @type get >>= Control.Monad.Writer.lift . ?myFn >>= put
07:13:34 <lambdabot> (?myFn::a -> m a, Monad m, MonadTrans t, MonadState a (t m)) => t m ()
07:14:19 <rwbarton> i see, so basically a modify that can have an effect in the base monad
07:14:34 <byorgey> hi smg
07:14:47 <startling> rwbarton: yeah
07:14:57 <smg> again, I am playing around with HXT ... - I am using processTopDown like this: processTopDown ( choiceA [ condForSubtree a :-> transformA, condForSubtree b :-> transformB, ..., (neg (hasName "OTHERWISE")) :-> this ])  -- where OTHERWISE is guaranteed not to be included in the input ...
07:15:41 <smg> thus my question: with HXT and arrows is there a 'natural' otherwise combinator?
07:16:24 <startling> why isn't there a "state" lens for StateT?
07:16:41 <startling> Oh, i guess that wouldn't work in general.
07:16:52 <rwbarton> :t state
07:16:54 <lambdabot> MonadState s m => (s -> (a, s)) -> m a
07:17:01 <rwbarton> oh right
07:17:03 <rwbarton> :t stateT
07:17:05 <lambdabot>     Not in scope: `stateT'
07:17:05 <rwbarton> :t StateT
07:17:05 <lambdabot>     Perhaps you meant `state' (imported from Control.Monad.State)
07:17:07 <lambdabot> (s -> m (a, s)) -> StateT s m a
07:17:59 <startling> yeah, it'd only work if your monad was the same as the StateT's argument. It's not really a useful lens, just a useful traversal
07:18:30 <startling> :t let stateT fn = get >>= Control.Monad.Trans.lift . fn >>= set
07:18:32 <lambdabot> <no location info>:
07:18:32 <lambdabot>     not an expression: `let stateT fn = get >>= Control.Monad.Trans.lift . fn >>= set'
07:18:44 <startling> :t let stateT fn = get >>= Control.Monad.Trans.lift . fn >>= set in stateT
07:18:46 <lambdabot>     Couldn't match kind `* -> *' against `*'
07:18:46 <lambdabot>     Kind incompatibility when matching types:
07:18:46 <lambdabot>       t0 :: (* -> *) -> * -> *
07:19:01 <startling> you get the idea!
07:20:09 <startling> edwardk, hi, do you know of a traversal over a StateT's state into the StateT's argument monad?
07:20:10 <byorgey> smg: the documentation for choiceA actually tells you what it is
07:20:26 <edwardk> :t zoom
07:20:27 <lambdabot> edwardk: You have 3 new messages. '/msg lambdabot @messages' to read them.
07:20:29 <lambdabot> Zoom m n k s t => SimpleLensLike (k c) t s -> m c -> n c
07:20:30 <smg> byorgey, ok ...
07:20:31 <edwardk> like that?
07:20:37 <byorgey> smg: the example uses 'this', which is actually just an alias for 'returnA', the identity arrow
07:20:39 <startling> edwardk: I dunno, maybe.
07:20:52 <byorgey> smg: http://hackage.haskell.org/packages/archive/hxt/latest/doc/html/Control-Arrow-ArrowIf.html#v:choiceA
07:21:05 <smg> byorgey, thanks, I surely overread this part ...
07:21:16 <byorgey> since the identity arrow is always guaranteed to succeed
07:21:16 <edwardk> zoom :: Monoid m => Simple Traversal s a -> State a m -> State s m
07:21:56 <byorgey> zoom!
07:22:11 <edwardk> you can use it on a lens without the monoid
07:22:45 <startling> edwardk: nah, doesn't appear to be what I'm looking for
07:23:01 <edwardk> then i'm not parsing you correctly =)
07:23:42 <startling> :t (\fn -> get >>= Control.Monad.Trans.lift . fn >>= set) :: Monad m => (a -> m a) -> StateT a m ()
07:23:44 <navaati> is there a version of Map with an insert that triggers an error (preferably a pure error, like returning a (Maybe (Map k a)) ) when inserting an already existing key ?
07:23:44 <lambdabot>     Couldn't match expected type `StateT a m ()'
07:23:44 <lambdabot>                 with actual type `b0 -> s0 -> t0'
07:23:44 <lambdabot>     Expected type: a -> StateT a m ()
07:24:14 <rwbarton> @type lift
07:24:16 <lambdabot>     Ambiguous occurrence `lift'
07:24:17 <lambdabot>     It could refer to either `Control.Monad.Writer.lift',
07:24:17 <lambdabot>                              imported from `Control.Monad.Writer' at State/L.hs:17:1-27
07:24:22 <rwbarton> @@ @show (@type lift)
07:24:24 <lambdabot>  "    Ambiguous occurrence `lift'\n    It could refer to either `Control.Monad.Writer.lift',\n                             imported from `Control.Monad.Writer' at State/L.hs:17:1-27\n"
07:24:29 <rwbarton> oh
07:24:44 <rwbarton> I thought there was some clever workaround for this
07:24:54 <startling> navaati, you can write it trivially
07:25:03 <navaati> startling, uh ?
07:25:18 <byorgey> navaati: you can use insertLookupWithKey
07:26:10 <navaati> byorgey, ah, right :)
07:26:16 <rwbarton> @run lift
07:26:18 <lambdabot>   Ambiguous occurrence `lift'
07:26:18 <lambdabot>  It could refer to either `Control.Monad.Trans....
07:26:25 <rwbarton> @show (@run lift)
07:26:26 <lambdabot> "(@run lift)"
07:26:29 <rwbarton> @@ @show (@run lift)
07:26:31 <lambdabot>  "  Ambiguous occurrence `lift'\n It could refer to either `Control.Monad.Trans...."
07:28:03 <rwbarton> edwardk: aha this is your fault!
07:28:06 <rwbarton> "or `Numeric.AD.Internal.Classes.lift', imported from `Numeric.AD.Types' at L.hs:69:1-23 (and originally defined in `ad-3.1.4:Numeric.AD.Internal.Classes')"
07:28:16 <edwardk> ack
07:28:30 <edwardk> I should rename that ;)
07:28:51 <mSSM> I am desugaring some do code for myself, but my version using binds doesn't work - can somebody check if I did something wrong? http://sprunge.us/AgOa
07:28:52 <startling> oh, I know what I did wrong
07:29:12 <startling> :t (\fn -> get >>= Control.Monad.Trans.lift . fn >>= put) :: Monad m => (a -> m a) -> StateT a m ()
07:29:14 <lambdabot> Monad m => (a -> m a) -> StateT a m ()
07:29:24 <startling> edwardk: ^ is what I'm talking about
07:29:35 <startling> just wondering if it's defined somewhere
07:29:47 <edwardk> oh, you want to update the state with a monadic side effect
07:29:51 <startling> yeah.
07:30:11 <parcs`> mSSM: replace forkIO . forever $ .... with (forkIO . forever $ ...)
07:30:14 <edwardk> i don't have that in there.
07:30:21 <edwardk> the closest i get is (%%=)
07:30:24 <edwardk> :t (%%=)
07:30:26 <lambdabot> MonadState s m => LensLike ((,) r) s s a b -> (a -> (r, b)) -> m r
07:30:33 <navaati> mSSM, try adding parens
07:30:37 <edwardk> but thats not 'm'
07:30:47 <edwardk> :t (%%~)
07:30:48 <mSSM> parcs`: alright; in that case it seems lambdabot lied to me?
07:30:49 <lambdabot> LensLike f s t a b -> (a -> f b) -> s -> f t
07:31:14 <mSSM> parcs`: I dumped that line into @undo as well, and it didn't give me parens
07:31:30 <edwardk> partially because it is very state specific. i can't do that when the state is buried down in the monad, and you give up your access to the state or the result, so its mostly so much shuffling for a limited case
07:31:45 <mapf> balancing of red-black trees is one order of magnitude simpler to understand and write with pattern matching rather than witout it
07:31:47 <startling> edwardk: yeah, makes sense. thanks anyway!
07:31:54 <parcs`> @undo do { forkIO . forever $ waitEvent >>= \e -> when (e == Quit) quit; sdlUpIsing isys 3 0 screen }
07:31:55 <lambdabot> forkIO . forever $ waitEvent >>= \ e -> when (e == Quit) quit >> sdlUpIsing isys 3 0 screen
07:32:01 <startling> I think I'm using a lot of the lenses as traversals, which isn't exactly the idea.
07:32:07 <parcs`> mSSM: yes
07:32:16 <edwardk> well, the traversal combinators are all intended to work on lenses
07:32:27 <Dodek> 15:58 < implr> a o
07:32:27 <Dodek> 15:58 < implr> a o
07:32:32 <edwardk> so if you find the combinator in traversal that isn't a clue you shouldn't use it or anything ;)
07:32:32 <parcs`> mSSM: lambdabot lied to you. good catch
07:32:38 <edwardk> it just means you can do more with it if you need to
07:32:56 <startling> edwardk: right, but you're not designing the library for me to _2 print
07:33:11 <mSSM> parcs`: now somebody needs to fix it, and it better be not me, coz I have no idea what I am doing.
07:33:14 <mSSM> :D
07:33:35 <startling> parcs`: haha
07:33:40 <edwardk> startling: actually i'm rather fond of that usecase ;)
07:34:00 <startling> edwardk: haha
07:34:01 <edwardk> :t mapMOf_ _2 print
07:34:03 <lambdabot> (Show a, Field2 s t a b) => s -> IO ()
07:34:13 <edwardk> tat'll keep you from building the new tuple though
07:34:24 <startling> sure
07:34:25 <edwardk> :t mapMOf_ _2 print ("hello","world")
07:34:27 <lambdabot> IO ()
07:34:32 <mSSM> parcs`: can you maybe tell me what haskell was thinking what was going on without the parens?
07:34:33 <edwardk> :t _2 print ("hello","world")
07:34:35 <lambdabot> IO ([Char], ())
07:34:43 <rwbarton> lovely
07:34:53 <navaati> @hoogle (a -> b) -> (a, b) -> b
07:34:53 <lambdabot> Data.Graph.Inductive.Query.Monad orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
07:35:06 <navaati> meh
07:35:08 <startling> Data.Graph.Inductive.Query.Monad is in like every obscure hoogle
07:36:01 <edwardk> ok, i need a new name for 'lift' in the Lifted class for Numeric.AD ;)
07:36:10 <navaati> is there a way to tell hoogle that 'a' means 'forall a' and not 'there exists a' ?
07:36:11 <parcs`> mSSM: the $ has higher precedence than >> so it's equivalent to 'forkIO . forever $ (waitEvent >>= \ e -> when (e == Quit) quit >> sdlUpIsing isys 3 0 screen)'
07:36:14 <edwardk> i've been able to live with it this long but i think it is a pain point to have in lambdabot
07:36:32 <fryguybob> edwardk: stab
07:36:37 <edwardk> fryguybob: =)
07:36:43 <startling> navaati, it's just finding the best match. it'll prefer forall if there's results for it
07:36:58 <startling> fryguybob, that's already in lens
07:37:10 <edwardk> its used to embed a simple numeric type into an AD type
07:37:19 <edwardk> so lift :: Double -> AD s Double
07:37:23 <edwardk> 'embed' could work
07:37:25 <edwardk> :t embed
07:37:27 <lambdabot> Not in scope: `embed'
07:37:32 <edwardk> doesn't collide with anything
07:37:35 <mSSM> parcs`: and how come this is not an issue for a do block? because of the new line?
07:37:49 <navaati> mSSM, yeah
07:38:04 <parcs`> mSSM: because the ; delimits the statement
07:38:22 <rwbarton> pureAD
07:38:27 <rwbarton> (yuck)
07:38:36 <edwardk> rwbarton: i thought about just using 'ad'
07:38:49 <edwardk> or auto
07:38:52 <mSSM> parcs`: but there is no ; in the do block. :/
07:39:00 <edwardk> ad, auto, embed
07:39:04 <mSSM> Or is it invisible? o.O
07:39:07 <rwbarton> what if i want to automatically differentiate my adjoint representation
07:39:14 <startling> mSSM: newlines desugar to {
07:39:16 <startling> }
07:39:43 <edwardk> you can use composite modesl to do forward-on-reverse
07:39:48 <edwardk> :t jacobian
07:39:50 <lambdabot> (Functor g, Num a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> g (AD s a)) -> f a -> g (f a)
07:39:59 <rwbarton> ... I was just referring to the name 'ad'
07:40:06 <edwardk> rwbarton: =P
07:40:29 <parcs`> mSSM: oh, yeah, a ; gets implicitly inserted between every statement that starts at the same indentation level as the first statement
07:40:29 <edwardk> i guess auto is probably the least offensive so far
07:40:42 <rwbarton> can ad deal with piecewise-defined functions at all?
07:40:45 * hackagebot alpha 0.99999 - A compiler for the Alpha language  http://hackage.haskell.org/package/alpha-0.99999 (MarcCoiffier)
07:41:05 <Roshan> hello would anyone happy to help me about Yampa?
07:41:19 <edwardk> sure. it gives derivatives based only on the current point though, if you are at the edge of one of those piecewise intervals it'll just give you the answer based on the code path you took
07:41:22 <rwbarton> maybe by approximating with some kind of bump function
07:41:26 <edwardk> > diff abs 0.5
07:41:27 <rwbarton> i see
07:41:29 <lambdabot>   1.0
07:41:30 <edwardk> > diff abs 0
07:41:33 <lambdabot>   0
07:41:38 <edwardk> it'd be free to give you pretty much any answer at 0 though
07:41:41 <rwbarton> yes
07:41:57 <Roshan> what is rec in Yampa??
07:42:43 <Roshan> anyone knows FRP?
07:42:55 <rwbarton> rec is part of arrow syntax I think
07:44:03 <Roshan> i see
07:44:06 <rwbarton> @type gradientDescent
07:44:08 <lambdabot> Not in scope: `gradientDescent'
07:44:12 <parcs`> mSSM: so in this case the first statement in the do block is 'SDL.init [InitEverything]' and it's indented 5 spaces. if on the next line a statement is also indented 5 spaces then it's considered to be a separate statement. if the next line is not indented by 5 spaces it's considered to be a continuation of the previous statement
07:45:46 <Roshan> As i want to help my friend in her Yampa problem
07:46:20 <Roshan> i hv input signal having spaceship state
07:47:05 <DMcGill> Roshan: http://www.soi.city.ac.uk/~ross/papers/notation.pdf
07:47:08 <DMcGill> part 5.3
07:47:33 <DMcGill> also, have you seen this yampa tutorial? http://haskell.cs.yale.edu/wp-content/uploads/2011/01/yampa-arcade.pdf
07:50:49 <Roshan> DMcGill: thanks a lot ..
07:51:12 <Roshan> i hv read Yampa arcade ..
07:51:37 <DMcGill> well it extensively uses rec notation
07:52:25 <Roshan> but i am stuck with one place .. in my problem the spaceship emitted the ball continuosly .. i want it to emit at time interval.. tried using repeately , after
07:53:57 <mSSM> parcs`: what if the indentation of the next line was 4 or 6? is it a continuation inboth cases?
07:55:45 * hackagebot shelly 0.14.3 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.14.3 (GregWeber)
07:56:01 <geekosaur> 4 would be a continuation, but of the immediately outer scope.  unless it happened to have indentation 4
07:56:16 <geekosaur> in which case it;s the next expression in that scope
07:56:52 <DMcGill> Roshan: what's that got to do with rec? Also repeatedly makes an event happen every time interval, what's your problem with it?
08:00:15 <nand`> I have some foreign array, allocated with Foreign.Marshal.Array.mallocArray; how would I go about saving this to a file, as raw bytes?
08:00:39 <nand`> I mean, I could peekArray it, conver those [CUByte] to [Word8] and pack that using bytestring
08:00:46 <nand`> but I'm wondering if there's a more direct way
08:02:38 <burbul> :t show
08:02:38 <luite> nand`: yeah ByteString
08:02:39 <lambdabot> Show a => a -> String
08:02:50 <navaati> :t Foreign.Marshal.Array.mallocArray
08:02:51 <lambdabot> Foreign.Storable.Storable a => Int -> IO (GHC.Ptr.Ptr a)
08:03:12 <navaati> i think there is a "write" function in some posix package
08:03:17 <nand`> s/CUByte/CUChar/
08:03:24 <burbul> Is there a named function that is a (one-sided) inverse to show :: String -> String?
08:03:24 <navaati> that may take a pointer (direct wrapper to the syscall)
08:03:49 <nand`> burbul: read :: String -> String, maybe? :)
08:03:55 <parcs`> mSSM: yes
08:04:26 <burbul> nand` : I thought of that, but I couldn't find a instance in http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#t:Read
08:04:50 <burbul> Read Char exists, as does
08:04:51 <nand`> burbul: instance Read Char
08:04:51 <DMcGill> :t read "\"string\"" :: String
08:04:53 <rwbarton> > read "\"hi\"" :: String
08:04:53 <lambdabot> String
08:04:55 <lambdabot>   "hi"
08:04:56 <burbul> Read a => Read [a]
08:05:23 <arcatan> meh, i should just start all new modules with import Control.Applicative as I will do it anyway at some point
08:05:39 <burbul> ah, I think I see what I was confused about. Thank you.
08:05:43 <nand`> arcatan: I know that
08:07:03 <Roshan> DMcGill: i want the spaceship emitting the ball at time interval.. i messed up the code :(
08:07:30 <Roshan> My code shows it emitting balls continously ..
08:08:42 <navaati> nand`, fdReadBuf
08:08:48 <Roshan> DMcGill: may be i hv to be patient .. read the whole thoroughout
08:08:50 <navaati> :t fdReadBuf
08:08:51 <lambdabot> Not in scope: `fdReadBuf'
08:09:10 <navaati> :t System.Posix.IO.fdReadBuf
08:09:12 <lambdabot> System.Posix.Types.Fd -> GHC.Ptr.Ptr Word8 -> System.Posix.Types.ByteCount -> IO System.Posix.Types.ByteCount
08:09:21 <navaati> does this suits you ?
08:09:34 <atriq> Is there a type lurking about anywhere that's "seconds since the epoch"?
08:10:10 <nand`> navaati: looks relevant (fdWriteBuf at any rate)
08:10:14 <Roshan> DMcGill: I just start learning haskell since july this year ..and i love the concept of purecode and sideeffect ..also i love the arrow concept, Yampa
08:10:28 <parcs`> atriq: POSIXTime
08:10:29 <nand`> navaati: I just need to figure out how to construct a ‘Fd’
08:10:40 <nand`> oh, I could use stdout
08:10:46 <navaati> nand`, something like "open" in the same package
08:11:03 <navaati> openFd*
08:11:03 <Roshan> ia it possible that the unread messages from irc sent to gmail??
08:11:19 <atriq> parcs`, thank you
08:12:56 <navaati> of course this is not portable to Windows…
08:24:32 <nand`> navaati: screw windows
08:25:00 <navaati> :]
08:32:17 <trudko> Guys i am not sure about this fun. definition tail (_ : xs ) = xs    . I understand  that _ is wild card , : is for  adding  new element to list, not sure what it all means together
08:33:14 <startling> trudko, think of it as destructuring assignment
08:33:24 <navaati> (:) is a constructor, so you can patter-match against it
08:33:50 <startling> trudko, it matches any list of the form (a : b) and saves the second part as "xs"
08:34:11 <monochrom> if your list looks like (a:(b:(c:[])), then xs refers to (b:(c:[]))
08:34:46 <mm_freak> trudko: compare "data [a] = [] | (a:[a])" with "head (x : _) = x" to "data Maybe a = Nothing | Just a" with "fromJust (Just x) = x"
08:34:55 <bitonic> ghc-mod breaks if I install more than two packages of the same version
08:35:01 <bitonic> sorry, two packages
08:35:14 <bitonic> the same package twice, with different versions :P
08:35:30 <bitonic> specifically, I get errors like these:
08:36:05 <hpaste> bitonic pasted “ghc-mod error” at http://hpaste.org/77880
08:36:09 <bitonic> ^^^
08:40:46 * hackagebot ad 3.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.2 (EdwardKmett)
08:41:00 <startling> heh
08:41:58 <rwbarton> is there something like gradientDescent, but ... better?
08:42:14 <edwardk> :t Numeric.AD.Newton.conjugateGradientDescent
08:42:17 <lambdabot> (Fractional a, Ord a, Traversable f) => (forall (s :: * -> *). Numeric.AD.Types.Mode s => f (AD s a) -> AD s a) -> f a -> [f a]
08:42:17 <cornihilio> how do I do something like this?: data A = A { foo :: foo }; data foo = bar | foobar; data bar = bar { ... }; data foobar = foobar { ... }
08:42:19 <rwbarton> the convergence seems pretty slow on my x^4 function
08:42:32 <edwardk> :t Numeric.AD.Halley.gradientDescent
08:42:34 <lambdabot>     Not in scope: `Numeric.AD.Halley.gradientDescent'
08:42:49 <ion> cornihilio: data Foo = Bar Bar | Foobar Foobar
08:42:56 <edwardk> oh i guess i don't have a halley version
08:43:32 <edwardk> i'd welcome patches for brent's method or BFGS, etc.
08:44:00 <edwardk> i had a mathematician contact me about collaborating to add them, but i haven't heard from him lately
08:44:05 <edwardk> so i presume they are stalled
08:44:40 <cornihilio> ion: what is that called if I wanted to look it up in real world haskell?
08:44:46 <rwbarton> conjugateGradientDescent is too good
08:44:54 <cornihilio> I was looking under adts and I don't remember seeing it...
08:45:00 <rwbarton> [[0.0,0.0,0.0],[3.50000080422687,1.2000002757349268,-0.38400008823517673],[NaN,NaN,NaN]]
08:45:18 <rwbarton> (my test function is let f [x,y,z] = (x-3.5)^2 + (y-1.2)^2 + (z+0.4)^4)
08:45:36 <rwbarton> i don't have any real use for this, just messing around
08:45:44 <rwbarton> to see what it can do
08:45:50 <merijn> cornihilio: What ion wrote is just a normal ADT
08:46:08 <merijn> cornihilio: The first Bar is a constructor, the second a type. Which is legal (albeit a bit confusing)
08:46:23 <edwardk> yeah for some reason the conjugateGradient code seems pretty NaN happy. =(
08:47:02 <rwbarton> ok
08:47:08 <trudko> navaati: what does it mean to pattern match againts constructor? In other words what are you matching againts? matching againts Boolean value is simple but I adont understand how can you pattern match againts constructor
08:47:15 <edwardk> it should stop before the nans ;)
08:47:21 <rwbarton> yeah that would be ideal
08:47:34 <rwbarton> I assume it is dividing by df/dx somewhere
08:47:57 <rwbarton> but it would be good if I could extract the -0.4
08:48:20 <geekosaur> trudko, matching against a Boolean *is* matching against a constructor
08:48:30 <geekosaur> the data constructors for Bool are False and True
08:49:58 <trudko> still not sure maybe I will understand it better tomorrow still thanks for your time
08:50:09 <edwardk> :t takeWhile (Data.Foldable.all (not . isNaN))
08:50:11 <lambdabot> (RealFloat a, Data.Foldable.Foldable t) => [t a] -> [t a]
08:50:22 <merijn> trudko: Do you know any existing other languages?
08:50:29 <cornihilio> ion, merijn: I am having trouble understanding that example... could you point me to a more full fledged one? right now I am getting "multiple declarations" from this: https://gist.github.com/4106190
08:50:35 <trudko> merijn java/javascript
08:50:45 <merijn> I guess existing is a bit redundant there :p
08:51:48 <rwbarton> cornihilio: you tried to use EntityBody both as a data constructor for EntityBody and as a data constructor for EntityData
08:51:53 <edwardk> >>> takeWhile (all (not . isNaN)) $ conjugateGradientDescent (\[x,y,z] -> (x-3.5)^2 + (y-1.2)^2 + (z+0.4)^4) [0,0,0]
08:51:53 <edwardk> [[0.0,0.0,0.0],[3.50000080422687,1.2000002757349268,-0.38400008823517673]]
08:52:20 <rwbarton> edwardk: yeah
08:52:26 <merijn> trudko: Imagine defining a class with 3 mutual exclusive attributes (i.e. if one of them has a value, the other do not). You could have an extra field that indicates which of the three attributes is set (which is a bit forced as a Java analogy, but it's common in with structs and unions)
08:52:31 <rwbarton> but I can't continue to get a more accurate value for z
08:52:54 <merijn> trudko: Pattern matching is the equivalent of checking the indicator field and returning the set attribute based on that.
08:53:06 <jmcarthur> trudko: do you know C, bychance?
08:53:16 <trudko> jmcarthur not really
08:53:31 <jmcarthur> trudko: are you familiar with what C's union keyword means?
08:53:39 <trudko> no
08:53:43 <jmcarthur> ah, nevermind then
08:53:51 <rwbarton> cornihilio: so you just have to change one of those two names (the ones after the two =s)
08:53:55 <edwardk> i wonder if i could just use the self-equality test to check for NaN and avoid the RealFloat restriction.
08:54:01 <trudko> just a sec jmcarthur i am going through merijn example
08:54:05 <ion> I wonder if i should release https://github.com/ion1/beagle_bone_pins/blob/master/Generate/NumCompare.hs separately?
08:54:14 <merijn> trudko: In the case of the datatype "Maybe a = Just a | Nothing" the function "foo (Just x) = ..." foo checks whether the Just field is set or the Nothing field. If the Just field is set it the value inside to the name x
08:54:30 <jmcarthur> trudko: i was just going to offer a slightly more accurate refinement of his, but his example is fine
08:54:56 <cornihilio> rwbarton: what do you mean?
08:55:25 <rwbarton> hmm?
08:55:29 <rwbarton> what exactly is unclear
08:55:37 <cornihilio> which name do I have to change?
08:55:41 <rwbarton> one of them
08:55:47 <rwbarton> you can't have two data constructors with the same name
08:56:00 <merijn> trudko: If you have multiple or more complex fields you could nest these lookups. If we go to your list example then we have "tail (_:xs) = xs" the "list class" would have two options (two indicator values) the empty list or the non-empty list. The empty list has no value, so that's easy.
08:56:14 <rwbarton> you can change either of them to anything whatsoever that isn't already used as a data constructor
08:56:30 <merijn> trudko: The non-empty list basically consists of one element and a reference to another list
08:56:57 <rwbarton> (then you will have to use that name in the code that constructs or pattern matches on these types, but you didn't show any of that)
08:57:18 <edwardk> rwbarton: pushed 3.2.1 where conjugateGradientDescent starts checking its elements for self-equality, avoiding NaN's
08:57:24 <rwbarton> oh nice
08:57:31 <rwbarton> to github?
08:57:40 <edwardk> it just hit hackage
08:57:43 <rwbarton> oh there it is
08:57:43 <merijn> trudko: So pattern matching "tail (_:xs) = xs" is similar to first inspecting "is this the empty list or non-empty list?" then, if it's the non-empty list assigning the element to _ (which effectively doesn't name it at all) and assigns the tail part (the list reference) to xs.
08:58:17 <edwardk> the conjugate method is much more aggressive, so it winds up dividing 0 by 0 pretty fast ;)
08:58:18 <merijn> trudko: Of course, since we haskellers are freaking lazy the compiler does most of the tedious work in that example
08:58:18 <cornihilio> rwbarton: ah thank you! now it makes sense
08:58:43 <merijn> trudko: Does that make some sort of sense?
08:58:52 <edwardk> it is a hell of a lot faster than gradientDescent though ;)
09:00:47 * hackagebot ad 3.2.1 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.2.1 (EdwardKmett)
09:02:48 <trudko> merijn let me go through that
09:04:47 <cornihilio> so why does this work?: data EntityData = EntityBody' EntityBody | WorldState' WorldState
09:05:01 <cornihilio> if EntityBody' and WorldState' are undefined, it seems meaningless
09:05:03 <cornihilio> but it compiles
09:05:20 <atriq> What's everyone's favourite URL type?
09:05:24 <latro`a> you mean if EntityBody and WorldState are undefined?
09:05:35 <byorgey> cornihilio: EntityBody' and WorldState' are defined by that very code
09:05:37 <latro`a> because that thing defines EntityBody' and WorldState' provided EntityBody and WorldState exist
09:05:52 <byorgey> cornihilio: it defines EntityBody' and WorldState' to be the constructors of the EntityData type
09:05:54 <latro`a> EntityBody' :: EntityBody -> EntityData
09:05:58 <edwardk> atriq: about:
09:06:03 <navaati> atriq, ipot:// ?
09:06:04 <latro`a> WorldState' :: WorldState -> EntityData
09:06:10 <cornihilio> ah, I see now
09:06:15 <atriq> edwardk, navaati, :P
09:06:15 <rwbarton> IO Html
09:06:18 <cornihilio> thank you for that explanation!
09:06:29 <ion> Html IO
09:06:33 <latro`a> oh dear
09:07:08 <atriq> rwbarton, ion, :P, also it's a URL to an image, not a HTML page
09:07:31 <rwbarton> HasMimeType a => IO a
09:07:49 <rwbarton> anyways I think there is one in the HTTP package?
09:08:53 <atriq> Preferably one that plays nice with Aeson
09:09:18 <rwbarton> with Aeson, huh, well I guess you want a parser for it then
09:09:27 <rwbarton> since "url" is not a json type
09:09:54 <rwbarton> :t URI
09:09:56 <lambdabot> Not in scope: data constructor `URI'
09:10:03 <atriq> I could just use Bytestring or Text, but that seems to be bad
09:10:17 <rwbarton> there's URI in Network.URI from network
09:10:23 <rwbarton> @hoogle URI
09:10:24 <lambdabot> Network.URI module Network.URI
09:10:24 <lambdabot> Network.URI URI :: String -> Maybe URIAuth -> String -> String -> String -> URI
09:10:25 <lambdabot> Network.URI data URI
09:10:30 <rwbarton> @hoogle parseURI
09:10:31 <lambdabot> Network.URI parseURI :: String -> Maybe URI
09:10:31 <lambdabot> Network.HTTP.Base parseURIAuthority :: String -> Maybe URIAuthority
09:10:31 <lambdabot> Network.URI parseURIReference :: String -> Maybe URI
09:10:36 <rwbarton> that seems pretty standard
09:10:38 <atriq> I'm already using http-conduit, which uses two ByteStrings?
09:10:47 * hackagebot ad 3.2.2 - Automatic Differentiation  http://hackage.haskell.org/package/ad-3.2.2 (EdwardKmett)
09:11:28 <edwardk> wound up needing 'ad' in my current pet project so expect a lot of improvements =P
09:14:26 <hiptobecubic> :)
09:15:27 <trudko> merijn: ok I did not really understood your explanation.  I kind of get pattern matching what I dont understand is how you match againts (_:xs) , which in other context means add something to list named XS
09:16:10 <byorgey> trudko: (:) is used both to construct lists (when used as an expression) and to take them apart again (when used as a pattern)
09:16:43 <merijn> trudko: In expressions "(_:xs)" puts things together, in patterns (function definitions, lambda's and case-of, am I forgetting any) they do the reverse, pulling things apart
09:17:17 <jmcarthur> trudko: all pattern matching does is check to see if the constructors match and then bind some variables
09:17:29 <jmcarthur> trudko: so here, (:) is the constructor
09:17:31 <trudko> I see so that make sens now
09:17:35 <trudko> sese
09:17:59 <trudko> startling said that but I did not understood him at first
09:18:30 <trudko> ok so in pattern matching (and some other cases)  x:xs means take x from xs
09:18:54 <trudko> so could I somewhere write something like 5:[1,2,3,4,5] and I would get [1,2,3,4] ?
09:18:59 <merijn> trudko: No, it means "if I give you some list, assign the first part to the name x and the second part to the name xs"
09:19:41 <merijn> "5:[1,2,3,4,5]" is the same as "[5,1,2,3,4,5]"
09:19:51 <rwbarton> if you match  [1,2,3,4,5]  to the pattern  x:xs  then  x = 1  and  xs = [2,3,4,5]
09:20:23 <FireFly> trudko: the colon is just a name of a constructor. If it was called Cons you'd write "Cons x xs" instead for the pattern
09:20:26 <merijn> Pattern matching "(x:xs)" with [5,1,2,3,4,5] means "let x = 5; xs = [1,2,3,4,5] in ..."
09:22:38 <trudko> ok I think I got it thanks guys
09:27:47 <cornihilio> how would I find example code for using a specific library (for me it's simple-actors)?
09:28:43 <merijn> cornihilio: I usually look at the hackage documentation and or google the library
09:42:15 <ew0> hello
09:42:21 <ew0> hey, I'm using fgl
09:42:27 <ew0> and I want to do a fold in a graph
09:42:32 <ew0> im topological order
09:42:34 <ew0> any ideas?
09:53:32 <hpaste> nand` pasted “[diagrams-cairo] Render to memory” at http://hpaste.org/77884
09:58:21 <rwbarton> this is sort of neat: http://monkey.org/~marius/talks/twittersystems/#59
09:58:43 <rwbarton> profiling call graph rendered as an actual graph
09:59:12 <rwbarton> is there a tool to do that with the ghc profiler?
10:01:03 <cornihilio> is there an easy way to find libraries that use a specific library?
10:03:25 <rwbarton> @google hackage reverse dependencies
10:03:27 <lambdabot> http://packdeps.haskellers.com/
10:03:28 <lambdabot> Title: Hackage dependency monitor
10:04:08 <jmcarthur> that doesn't seem to do what i would expect
10:04:10 <rwbarton> it is not the form on that page, but one you can reach from a link from there
10:04:21 <jmcarthur> ah, there's the revdep list
10:04:42 <byorgey> @where revdeps
10:04:42 <lambdabot> "Show reverse dependencies" at <http://hackage.haskell.org/trac/hackage/ticket/576>,"Hackage with Reverse Dependencies" by Roel van Dijk at <http://bifunctor.homelinux.net/~roel/hackage/packages/
10:04:43 <lambdabot> hackage.html>,"Reverse Dependencies" at <http://bifunctor.homelinux.net/~roel/hackage/packages/archive/revdeps-list.html>,<http://packdeps.haskellers.com/reverse> -- `bifunctor.homelinux.net' is
10:04:43 <lambdabot> broken, use `81.26.216.99' instead
10:05:01 <byorgey> whoah
10:05:29 <rwbarton> slightly annoying since i have never heard anyone ask "is there an easy way to find all the dependencies of a given library"
10:05:40 <cornihilio> rwbarton: thank you again!
10:05:48 <byorgey> @where+ revdeps http://packdeps.haskellers.com/reverse
10:05:48 <lambdabot> It is stored.
10:05:59 <rwbarton> perfect
10:06:02 <rwbarton> @where hdiff
10:06:03 <lambdabot> I know nothing about hdiff.
10:06:05 <rwbarton> !
10:06:19 <rwbarton> @where+ hdiff http://hdiff.luite.com/
10:06:20 <lambdabot> I will remember.
10:06:53 <cornihilio> if I wanted to look at the source code for a package, where is it stored in the .cabal? I can only find the tgz...
10:07:06 <rwbarton> in the .tar.gz
10:07:17 <rwbarton> .cabal is just the "control file"
10:07:26 <byorgey> cornihilio: just type  'cabal unpack packagename'
10:07:38 <byorgey> and then you will get a directory packagename/  with the source for  packagename
10:07:49 <cornihilio> byorgey: in my current dir?
10:08:28 <byorgey> yes
10:10:22 <bgamari> colah, ping
10:11:04 <cornihilio> thanks!
10:17:56 <osa1> how does deriving Read work ? can I assume that it always reads the same string it puts with auto-derived `show` ?
10:18:45 <parcs`> yep
10:18:57 <neutrino_> i have a difficult to create recursive data structure which is a directed acyclic graph. you start with the initial value and have multiple options to progress. at every point there are several options how to go on, but eventually the possibilities run out. a single state can be reached through multiple paths. how can i ensure that values get shared?
10:19:19 <parcs`> and the derived Show instance outputs a string that is valid haskell syntax for constructing the value that's being shown
10:20:01 <oscarvarto> Hi!. I'm new to Haskell and would like to check the source code of the Prelude library. Where can I find it?
10:20:02 <jmcarthur> neutrino_: are you trying to introduce sharing at construction or to preserve sharing during some sort of recursive operation on it?
10:20:11 <byorgey> neutrino_: you just have to make sure that you create each value only once and thread it to all the right places when constructing the structure.
10:20:30 <neutrino_> at construction.
10:20:42 <neutrino_> byorgey: how do i do that?
10:20:44 <jmcarthur> neutrino_: just make sure you don't construct the same thing multiple times. use let, etc.
10:20:57 <neutrino_> byorgey: if i memoize the constructor of the values will that be good enough?
10:20:57 <byorgey> oscarvarto: all the libraries in the 'base' package are here: http://hackage.haskell.org/package/base-4.6.0.0
10:21:08 <byorgey> neutrino_: yes, it should be
10:21:08 <jmcarthur> neutrino_: if you bind a variable and use it in multiple places, it will be shared in all those places
10:21:19 <byorgey> oscarvarto: just click on the module you want to see and then click 'Source'
10:21:25 <jmcarthur> yeah, if you don't know what to share up front, memoization is good
10:21:43 <byorgey> oscarvarto: note that the Prelude module just re-exports stuff from many other modules, so if you want to see the source code you'll have to look at those other modules
10:21:50 <byorgey> oscarvarto: e.g. Data.List
10:22:27 <neutrino_> jmcarthur: i don't know the shape of the graph before it's created
10:22:50 <neutrino_> that is, i don't know if two paths i'll take will eventually lead to among others one value shared among those two paths
10:22:56 <byorgey> oscarvarto: oh, never mind, it's actually easier than that: just go here  http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Prelude.html   and click on 'Source' next to whatever functions you want to see
10:23:01 <byorgey> it will take you to the right module
10:23:18 <oscarvarto> byorgey: I'm on Mac OS X. I Installed the Haskell Platform and when I start ghci I see I have have ghci version 7.4.2. What does the number 4.6.0.0 mean?
10:23:33 <jmcarthur> neutrino_: memoization is almost certainly the best option from what you've said, yes
10:23:42 <byorgey> oscarvarto: oh, that is the version of the 'base' package
10:23:44 <osa1> thanks, another question: does instance declarations cause any runtime load ? I'll need some instance declarations but only for using in testing, I was thinking using `StandaloneDeriving` to declare that instances in testing module. testing module won't be installed if it's not specified as a cabal parameter
10:23:57 <byorgey> oscarvarto: if you have ghc 7.4.2 then I guess you probably have base-4.5.0.0
10:24:08 <byorgey> oscarvarto: you can find out by typing 'ghc-pkg list base' at the prompt
10:24:20 <parcs`> neutrino_: what does your data structure look like
10:24:37 <oscarvarto> well, just the version of the "base" package...
10:24:39 <byorgey> oscarvarto: so if you want you can change 4.6 to 4.5 in the URL I gave you, though base-4.5 and 4.6 are not all that different
10:27:12 <neutrino_> well, each value contains a "playing board" (imagine a 3d bit field), a list of "remaining moves" (taking each move takes away a specific shape of bits and removes it from the list), and a list of (move taken, new value). the new value is the recursive value.
10:29:39 <oscarvarto> byorgey: I understand that foldl1 takes a binary function and a list. However I don't understand how something like foldl1 (+) [1] works (It takes 1 as the "accumulator" but there is nothing else to take as a second argument of the binary function +
10:29:56 <oscarvarto> The function returns a number 1
10:30:26 <oscarvarto> that's why I was trying to read the source code
10:30:31 <oscarvarto> for the implementation of fold
10:30:35 <FireFly> oscarvarto: the operation (in this case (+)) is applied zero times in that case, I think
10:30:40 <oscarvarto> foldl1
10:31:02 <FireFly> foldl1 just passes the first value of the list as the initial value to foldl
10:31:46 <byorgey> @src foldl1
10:31:47 <lambdabot> foldl1 f (x:xs) = foldl f x xs
10:31:47 <lambdabot> foldl1 _ []     = undefined
10:31:55 <neutrino_> parcs`: at some point the list is empty
10:32:06 <neutrino_> parcs`: because there are no new moves that are legal or you ran out of moves
10:32:11 <byorgey> oscarvarto: so you can see from the above that  foldl1 (+) [1] = foldl (+) 1 []
10:32:15 <byorgey> because [1] = (1:[])
10:32:19 <byorgey> @src foldl
10:32:19 <lambdabot> foldl f z []     = z
10:32:20 <lambdabot> foldl f z (x:xs) = foldl f (f z x) xs
10:32:31 <byorgey> and   foldl (+) 1 [] = 1
10:32:36 <byorgey> so (+) never gets called at all
10:33:01 <byorgey> which you can ascertain by doing this:
10:33:10 <byorgey> > foldl1 undefined [1]
10:33:11 <lambdabot>   1
10:33:23 <FireFly> > foldl1 undefined [1,2]
10:33:25 <lambdabot>   *Exception: Prelude.undefined
10:33:53 <FireFly> `undefined` blows up as soon as it tries to evaluate it?
10:35:18 <oscarvarto> Now I understand.
10:35:38 <oscarvarto> Thanks for the links to the source code.
10:36:08 <FireFly> If you check out foldl1 and foldl on hoogle, there's also a link to the source from there
10:39:30 <startling> > foldl (+) a [b, c, d, e]
10:39:32 <lambdabot>   a + b + c + d + e
10:39:35 <mapf> >foldl1 undefined []
10:39:43 <startling> > foldr (+) a [b, c, d, e]
10:39:44 <lambdabot>   b + (c + (d + (e + a)))
10:40:14 <mapf> :t a
10:40:16 <lambdabot> Expr
10:40:20 <mapf> wat
10:40:32 <mapf> :t (a, b, c, d, e)
10:40:34 <lambdabot> (Expr, Expr, Expr, Expr, Expr)
10:42:07 <byorgey> FireFly: right, undefined blows up when evaluated
10:42:39 <byorgey> > scanl (+) 0 [1,2,3,4,undefined]
10:42:41 <lambdabot>   [0,1,3,6,10,*Exception: Prelude.undefined
10:42:55 <navaati> are these a, b, c, d, e available in a package ?
10:43:04 <navaati> or are they lambdabot specific ?
10:43:06 <byorgey> @where Expr
10:43:06 <lambdabot> http://twan.home.fmf.nl/blog/haskell/simple-reflection-of-expressions.details
10:43:24 <byorgey> @package simple-reflect
10:43:25 <lambdabot> http://hackage.haskell.org/package/simple-reflect
10:43:27 <byorgey> navaati:  ^^^
10:44:33 <navaati> great, thanks :)
10:49:19 <bgamari> colah, I just submitted a few bug fixes for ImplicitCAD
10:49:36 <bgamari> colah, The new website looks quite nice
10:54:01 <bgamari> colah, Have you ever considered dropping your vector space and arithmetic primitives and in favor of vector-space or linear?
10:54:41 <bgamari> colah, I think it might be a nice improvement over the current situation which has a few sharp edges
10:56:30 <rwbarton> @where revdeps
10:56:31 <lambdabot> http://packdeps.haskellers.com/reverse
11:05:07 <osa1> is there an easy way to implement Arbitrary instances for large data types ?
11:05:41 <shapr> I have seen some helper packages on hackage.
11:05:55 <shapr> I forget exactly what parts they automate, but they make Arbitrary instance creation much simpler.
11:06:50 <shapr> osa1: perhaps http://hackage.haskell.org/package/Agata ?
11:06:57 <startling> shapr, you can do it pretty easily with Applicative style
11:07:06 <shapr> startling: Got an example handy?
11:07:12 <startling> data A b c d = A b c d
11:07:55 <startling> instance (Arbitrary a, ...) => Arbitrary (A b c d) where arbitrary = A <$> arbitrary <*> arbitrary <*> arbitrary
11:08:21 <cfwb> Sorry for the noob question here.  Can anyone explain how I can get pure Integer and String values out of these functions?
11:08:24 <cfwb> http://pastebin.com/irEUXTyW
11:08:34 <cfwb> At the moment they return IO actions
11:09:16 <shapr> osa1: Do you have a large data type example you can show us?
11:09:19 <startling> cfwb, you can't.
11:09:39 <startling> shapr: oh, oops, meant to direct that to osa1
11:09:46 <osa1> shapr: https://github.com/osa1/language-lua/blob/master/src/Language/Lua/Types.hs
11:09:50 <startling> cfwb, but you can do stuff with those IO actions
11:10:17 <monochrom> "pure Integer" would mean the same number every time. clearly, if you're reading from a file, it's a different number every time
11:10:28 <cfwb> startling, I'm calling them from a mapM over a list of filenames
11:10:53 <startling> cfwb: okay.
11:10:55 <cfwb> within main.  So I suppose I have to "run" the IO actions within main somehow?
11:11:01 <startling> cfwb, what do you want to do with the results?
11:11:48 <cfwb> startling: they will go into a list, that will be zip3'd with the list of filenames.  That list of tuples will then be sorted on the second field and then printed
11:12:19 <cfwb> startling: sorry, two lists that will be zipped I should say
11:12:28 <startling> cfwb: okay. so list <- mapM readWhatever filenames
11:12:39 <startling> let zipped = zip filenames list
11:12:48 <osa1> shapr: I also need to find a way to generate instance (Arbitrary a) => Arbitrary [a] 's easily, do you know a way to do that ?
11:13:00 <cfwb> startling: yep.   problem I have is that I don't understand how to print IO Strings (or sort them either)
11:13:03 <shapr> osa1: That instance is built-in last I checked.
11:13:18 <shapr> Though I haven't checked in the past few years, I should probably check again.
11:13:25 <startling> cfwb, when you do list <- whatever, list is just a list, not an IO list
11:13:53 <startling> cfwb: but let's take it back a step
11:14:12 <startling> cfwb, so say we want to get a line of user input and write it back
11:14:48 <startling> cfwb, getLine :: IO String and putStringLn :: String -> IO ()
11:14:50 <osa1> shapr: yeah it is, thanks.
11:15:05 <startling> cfwb: we can't just do putStrLn getLine, that's a type error
11:15:13 <startling> cfwb: do you know what we could do in this case?
11:15:49 <cfwb> startling: I would do temp <- getLine then putStrLn temp
11:16:11 <osa1> applicative style helps, but there will be still lots of boilerplate
11:16:14 <shapr> osa1: Does Agata look like it will work for what you need?
11:16:24 <startling> cfwb: sure. there's another way you could do it, though
11:16:29 <startling> cfwb: have you seen >>=
11:16:29 <osa1> shapr: oh I didn't see it yet
11:16:29 <startling> ?
11:17:00 <shapr> osa1: http://hackage.haskell.org/package/Agata
11:17:21 <cfwb> startling: Yes..  I know its implied between statements in main, but I can't use it myself
11:17:26 <osa1> shapr: never used template hakell, do you have any examples to see Agata's usage
11:17:42 <startling> cfwb: right. do you see how you could use it in this case?
11:18:13 <cfwb> startling: Roughly yes although I couldn't quote the type signature :)
11:18:42 <startling> cfwb, it's just getLine >>= putStrLn
11:19:17 <cfwb> startling: Yes, just tested it in ghci
11:19:18 <shapr> osa1: http://patch-tag.com/r/jonas_duregard/Agata/snapshot/current/content/pretty/Example.hs
11:19:55 <startling> cfwb: cool. so, do you see how this applies to your question? the trick isn't to try and get the values out of IO, it's to use >>= (or do notation) to work with the values as they're in IO
11:20:20 <monochrom> "getLine >>= \x -> putStrLn x" may show you what else you can do
11:20:41 <lispy> :t getLine >=> putStrLn
11:20:43 <lambdabot>     Couldn't match expected type `a0 -> m0 b0'
11:20:43 <lambdabot>                 with actual type `IO String'
11:20:43 <lambdabot>     In the first argument of `(>=>)', namely `getLine'
11:20:50 * hackagebot zmidi-core 0.5.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.5.0 (StephenTetley)
11:20:52 <cfwb> startling: Fair enough.  I'll think more about what in main.  Thanks
11:21:09 <cfwb> startling: *Fair enough.  I'll think more about what I'm doing in main.  Thanks
11:21:27 <startling> cfwb: if you want to do things fairly mechanically, you can use lot of let bindings
11:21:47 <osa1> shapr: hmm, seems like it can help. though I don't understand what it does and how it does (never used template haskell)
11:22:03 <startling> cfwb: like list <- readThings; let zipped = ...; let sorted = ...; print sorted;
11:23:04 <shapr> osa1: TH is much like macros in lisp, it lets you operate on the source code as a value to be manipulated.
11:23:15 <shapr> That still doesn't say what Agata does exactly, I don't know :-)
11:23:42 <osa1> shapr: :) haha thanks still
11:23:52 <osa1> shapr: I think I'll just start using it and defer learning
11:24:01 <shapr> osa1: Feel free to ask more questions!
11:25:15 <cfwb> startling: Oh far out.  I just got this bit to work.  Now onto sorting with sortBy etc.  cheers
11:25:57 <startling> cfwb: just know that this desugars to a bunch of >>= and lambdas, and that it might be easier to write it that way
11:29:28 <lispy> We say, "desugars to" but would we ever describe core as sour, tart, or bitter?
11:30:24 <startling> lispy: yes
11:34:18 <hpc> lispy: syntax-teriyaki?
11:37:09 <FireFly> Sounds tasty
11:43:46 <atriq> I'm trying to encode a structure into Haskell
11:44:01 <atriq> The structure has a field that determines the existence of a bunch of other fields
11:45:02 <atriq> Is the best way to do this making two types?
11:45:16 <atriq> And putting the extra fields into the the first field?
11:46:16 <startling> data Foo = A  | B { first :: a, second :: b, third :: c } ?
11:52:03 <atriq> You can do that?
11:52:18 <hpc> for extra fun
11:52:32 <hpc> data Foo = A {first :: a} | B {first :: a, second :: b}
11:52:41 <hpc> desugars to data Foo = A a | B a b
11:52:46 <hpc> first (A a) = a
11:52:49 <atriq> hpc, that is roughly what I need
11:52:50 <hpc> first (B a b) = a
11:52:54 <hpc> etc for second
11:53:25 <hpc> you likely just want data Foo = A {first :: a, second :: Maybe b}
11:53:45 <hpc> seeing as how you initially described the problem as one field determining the presence of others
11:53:52 <hpc> rather than one field containing others or whatnot
11:54:29 <atriq> Problem is, it's a huge record so there's 16 fields like first and up to 10 like the second
11:55:55 <atriq> There are 8 ways it can be
11:56:02 <atriq> With 16 common fields
11:56:16 <atriq> And 2 - 10 individual fields
11:57:01 <atriq> So I'd rather not do the Maybe way
11:58:34 <startling> atriq, you could also separate it into two records
12:00:19 <startling> e.g. data A = A { first :: a, second :: Maybe B } where data B = { third :: ...}
12:00:54 <atriq> Problem is, it's not Maybe B, it's OneOfEight B C D E F G H I
12:00:54 <uffot> hi, could someone help me understand the implementation of <*> in instance Applicative ((->) t) where  f <*> g = \t -> f t (g t). What I don't understand is the f t(g t) part
12:01:23 <mm_freak> uffot: in that monad (<*>) is the S combinator and pure is the K combinator
12:01:31 <mm_freak> pure x y = x
12:01:32 <mauke> uffot: what's unclear?
12:01:36 <atriq> uffot, f <*> g makes a function that applies its argument to f, then to g, then applies the result of the g one to the f one
12:02:38 <startling> > ((+) <$> (+ 1)) 0
12:02:39 <lambdabot>   *Exception: show: No overloading for function
12:02:41 <startling> er
12:02:49 <startling> > ((+) <*> (+ 1)) 0
12:02:50 <mm_freak> uffot: anyway, f <*> x in that monad applies the result of f to the result of x…  now f's result is a function, so it takes a value and produces a function…  x's result is a value, so it takes a value and produces a value…  f <*> x combines that result by applying the function result to the value result
12:02:51 <lambdabot>   1
12:02:53 <startling> too much idris. :)
12:03:18 <mm_freak> uffot: it may be easier to understand by realizing that '(->) e' and 'Reader e' are in fact the same thing
12:04:14 <uffot> for example if I use (+3) <*> (*10) 5 it results in  (+3) 5 ((*10) 5) but how can it be if (+3) takes only one parameter
12:05:03 <mauke> > (+ (3 :: Expr)) <*> (*10) 5
12:05:05 <lambdabot>   Couldn't match expected type `a0 -> b0'
12:05:05 <lambdabot>              with actual type `Debu...
12:05:13 <mauke> it's a type error
12:05:45 <zypper> Is there a built-function like (!!) that returns a `Maybe a' in case the index is out of bounds for a list?
12:06:06 <ion> zypper: You probably don’t want to use a list in the first place.
12:06:08 <mauke> @hoogle [a] -> Int -> Maybe a
12:06:08 <lambdabot> Prelude (!!) :: [a] -> Int -> a
12:06:08 <lambdabot> Data.List (!!) :: [a] -> Int -> a
12:06:09 <lambdabot> Data.List genericIndex :: Integral a => [b] -> a -> b
12:06:18 <mauke> @more
12:06:55 <mauke> :t list2maybe .: drop
12:06:57 <lambdabot>     Not in scope: `list2maybe'
12:06:57 <lambdabot>     Perhaps you meant `listToMaybe' (imported from Data.Maybe)
12:07:05 <mauke> :t listToMaybe .: drop
12:07:06 <lambdabot> Int -> [a] -> Maybe a
12:07:50 <zypper> listToMaybe . drop
12:07:54 <zypper> Thanks a lot, mauke :D
12:07:58 <mauke> no
12:08:07 <zypper> No? D:
12:08:09 <`Jake`> :t listToMaybe . drop
12:08:11 <lambdabot>     Couldn't match expected type `[a0]' with actual type `[a1] -> [a1]'
12:08:11 <lambdabot>     Expected type: Int -> [a0]
12:08:11 <lambdabot>       Actual type: Int -> [a1] -> [a1]
12:08:15 <mauke> .:, not .
12:08:33 <`Jake`> what is that?
12:08:37 <zypper> o.O
12:09:20 <zypper> Mind explaining what .: is? It doesn't seem to show up on Hoogle. D:
12:10:06 <startling> zypper, (.:) = (.) . (.)
12:10:11 <Saizan> f .: g = \x y -> f (g x y)
12:10:47 <mauke> (.:) = (.) (.) (.)
12:10:47 <startling> > ((+ 1) .: (+)) a b
12:10:47 <jmcarthur> it's a less useful and less clear version of (fmap.fmap)
12:10:48 <`Jake`> @type (.:)
12:10:49 <lambdabot>   a + b + 1
12:10:50 <lambdabot> (Functor g, Functor f) => (a -> b) -> f (g a) -> f (g b)
12:11:04 <jmcarthur> well, it's as useful in lambdabot, at least
12:11:10 <`Jake`> @info (.:)
12:11:11 <lambdabot> (.:)
12:11:20 <mauke> there never has been an @info
12:11:41 <`Jake`> Apparently, there is now, though it isn't what I wanted it to be
12:11:57 <`Jake`> @info "Hello, World"
12:11:57 <lambdabot> "Hello, World"
12:12:01 <mauke> no, it autocorrects to @undo
12:12:06 <`Jake`> Oh
12:12:10 <cornihilio> I've been trying to figure out this code in simple-actors and it's driving me crazy: https://gist.github.com/4107177
12:12:14 <cornihilio> where is val coming from?
12:12:20 <jmcarthur> @info do { a <- x; return x }
12:12:20 <lambdabot> x >>= \ a -> return x
12:12:44 <mauke> cornihilio: show the whole code
12:13:06 <`Jake`> where is (.:) defined?
12:13:07 <startling> @info [x | x <- [1..10]]
12:13:07 <lambdabot> concatMap (\ x -> [x]) [1 .. 10]
12:13:13 <startling> `Jake`: in lambdabot
12:13:23 <`Jake`> startling: Oh, ok. Thanks
12:13:29 <cornihilio> https://gist.github.com/4107183
12:13:35 <cornihilio> the top example
12:13:39 <startling> `Jake`, it's sometimes useful to use `where` for it
12:13:49 <`Jake`> @where (.:)
12:13:50 <lambdabot> I know nothing about (.:).
12:14:14 <`Jake`> That's a lie.
12:14:14 <startling> heh, I mean x = f .: g where (.:) = fmap . fmap
12:14:23 <`Jake`> Oh
12:14:29 <jmcarthur> i prefer just  (fmap.fmap) f g
12:14:51 <`Jake`> So what is @where then?
12:15:00 <jmcarthur> @where lyah
12:15:01 <lambdabot> http://www.learnyouahaskell.com/
12:15:06 <jmcarthur> it's just a little key value store
12:15:07 <`Jake`> Oh, I remember
12:15:30 <ion> > headOf (dropping 5 traverse) ['a'..]
12:15:33 <lambdabot>   *Exception: stack overflow
12:15:36 <ion> k
12:15:57 <jmcarthur> :t traverse
12:15:59 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
12:16:00 <startling> @where key
12:16:01 <jmcarthur> :t dropping
12:16:01 <lambdabot> I know nothing about key.
12:16:02 <lambdabot> Applicative f => Int -> SimpleLensLike (Control.Lens.Internal.Indexing f) s a -> SimpleLensLike f s a
12:16:02 <jmcarthur> :t headOf
12:16:04 <lambdabot> Getting (First a) s t a b -> s -> Maybe a
12:16:28 <jmcarthur> :t dropping 5 traverse
12:16:29 <lambdabot> (Applicative f, Traversable t) => SimpleLensLike f (t a) a
12:17:03 <edwardk> > ['a'..]^? iwhere (==5)
12:17:05 <mauke> cornihilio: could be pseudocode
12:17:06 <lambdabot>   *Exception: stack overflow
12:17:14 <edwardk> interesting
12:17:20 <mauke> cornihilio: oh wait, it's defined down there
12:17:23 <edwardk> oh, it can't know there is only one target =(
12:17:25 * jmcarthur eagerly awaits edwardk coming to give that talk in lenses in nyc
12:17:35 <edwardk> maybe i should work on ^? to make it lazier
12:17:54 <startling> edwardk, do you have slides or video from talks somewhere?
12:18:06 <cornihilio> mauke: down where? what line?
12:18:07 <startling> I'm curious how you explain lenses.
12:18:16 <mauke> cornihilio: have you tried ctrl-f?
12:18:17 <edwardk> i have slides from the talk in san francisco but they don't work very well without me talking over them =P
12:18:45 <mauke> I can't give you a line number because the numbers don't line up with the lines
12:19:02 <mauke> it's between 35 and 36
12:19:06 <cornihilio> yup
12:20:10 <edwardk> startling: https://groups.google.com/d/msg/bahaskell/YifnIpEu2OY/kddoyuvdCOMJ
12:20:12 <cornihilio> EQ -> case m of -- signal Int present in tree:?
12:20:43 <edwardk> i recommend not judging the library too harshly based on the slides, though. ;) as most of the punchlines and motivation were done by demo and by me talking over the slides
12:21:19 <startling> edwardk, sure, I just want to get an idea of how you're teaching them to people
12:21:27 <cornihilio> mauke: what line number in the gist I posted
12:21:44 <startling> edwardk, I've been not-very-good at explaining them, as shachaf could tell you. :/
12:21:46 <edwardk> basically i sold lenses by starting with how semantic editor combinators work. the notion of fmap.fmap.fmap    that folks already know, then looking at the definition of fmapDefault and foldMapDefault, and going from there.
12:22:05 <edwardk> :t fmap.fmap.fmap
12:22:07 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
12:22:12 <edwardk> :t traverse.traverse.traverse
12:22:14 <lambdabot> (Applicative f, Traversable t2, Traversable t1, Traversable t) => (a -> f b) -> t (t1 (t2 a)) -> f (t (t1 (t2 b)))
12:22:27 <edwardk> :t foldMap.foldMap.foldMap
12:22:29 <lambdabot>     Not in scope: `foldMap'
12:22:29 <lambdabot>     Perhaps you meant one of these:
12:22:29 <lambdabot>       `Data.Foldable.foldMap' (imported from Data.Foldable),
12:22:31 <mauke> cornihilio: DID YOU READ WHAT I WROTE
12:22:32 <edwardk> bah
12:23:00 <startling> edwardk: yeah, interesting
12:23:27 <cornihilio> mauke: I'm just trying to get some clarification... ctrl-f doesn't lead me to a definition, and between 35 and 36 there is nothing mentioning 'val'
12:23:53 <mauke> cornihilio: so how will repeating your question help?
12:24:11 <mauke> was there something unclear about my anwer?
12:24:34 <edwardk> tomorrow i get to attend a talk on lenses, but they are going to be scala lenses. for once i don't have to give the talk ;)
12:24:46 <osa1> @hoogle (Monad m1, Monad m) => (a1 -> r) -> m (m1 a1) -> m (m1 r)
12:24:48 <lambdabot> Control.Monad liftM :: Monad m => (a1 -> r) -> m a1 -> m r
12:24:48 <lambdabot> Control.Monad ap :: Monad m => m (a -> b) -> m a -> m b
12:24:48 <lambdabot> Prelude fmap :: Functor f => (a -> b) -> f a -> f b
12:24:59 <cornihilio> I just don't get what val means and I don't see a definition of it anywhere
12:25:49 <cornihilio> do you mean this?: >     >         case compare (val m) v of
12:25:55 <mauke> no
12:26:09 <mauke> and I'm getting the feeling you're not reading/understanding what I'm saying
12:26:15 <cornihilio> yes
12:26:17 <mauke> this is frustrating
12:26:34 <cornihilio> just point me to a line where there is a val = or let val = or something like that
12:26:44 <cornihilio> or heck val <-
12:27:28 <jmcarthur> cornihilio: in https://gist.github.com/4107183 it's on lines 43-44
12:27:35 <jmcarthur> cornihilio: it's a record field
12:27:53 <edwardk> cornihilio: >     > data Operation = Insert { val :: Int }  | Query { val :: Int , sigVar :: Mailbox Bool } -- see those two uses of val? those are where it is defined
12:28:14 <edwardk> data Foo = Foo { bar :: Baz } - defines bar :: Foo -> Baz
12:28:25 <jmcarthur> cornihilio: it means    val :: Operation -> Int
12:28:36 <cornihilio> oh... okay. Sorry about that, I guess it was right there.
12:30:18 <mauke> cornihilio: http://i.imgur.com/g6xeP.png
12:30:51 * hackagebot happstack-authenticate 0.9.7 - Happstack Authentication Library  http://hackage.haskell.org/package/happstack-authenticate-0.9.7 (JeremyShaw)
12:32:36 <cornihilio> mauke: thank you
12:33:08 <colah> bgamari: pong
12:33:10 <mauke> blame for the 35/36 thing goes to github
12:33:26 <hpaste> nand` pasted “Puzzling code” at http://hpaste.org/77889
12:33:39 <nand`> ^- Can anybody help me figure out why this is the case? (see comment)
12:34:37 <mauke> unitCircle is not in scope
12:35:06 <nand`> my initial suspicion was that ‘free b’ is freeing the buffer before ‘peekArray’ finished reading it (laziness?) - and indeed, removing the ‘free b’ makes both versions work; but then 1. why does the above version work? and 2. peekArray should be strict, no? I don't see unsafeInterleaveIO or anything in its source
12:35:21 <nand`> oh, I forgot the imports, didn't I
12:35:47 <nand`> you'd need Diagrams.Backend.Cairo.Ptr either way which isn't currently released
12:37:05 <startling> :t peekArray
12:37:06 <lambdabot> Not in scope: `peekArray'
12:38:03 <nand`> hmm, no, adding deepseq l before free b still causes corruption
12:38:07 <nand`> I am positively clueless then
12:38:54 <nand`> startling: Foreign.Marshal.Array
12:39:20 <startling> nand`: yeah, I found it. does renderPtr wreck things?
12:39:22 <mauke> nand`: anything obvious if running with MALLOC_CHECK_=2 or valgrind?
12:39:28 <startling> nand`: when you do it twice, I mean
12:39:42 <mauke> nand`: any difference if you swap the writeFiles or the renders?
12:40:09 <startling> nand`, what does renderPtr do anyway?
12:40:36 <nand`> swapping writeFiles: foo2 still corrupted, foo1 still fine
12:41:05 <nand`> ah; this might be a clue; swapping the renders makes foo1 corrupted
12:41:09 <nand`> seems like the second render is corrupted.
12:41:11 <nand`> now to figure out why
12:41:32 <nand`> mauke: no output with MALLOC_CHECK_=2
12:41:55 <nand`> but wait
12:42:00 <nand`> running with MALLOC_CHECK_=2 makes both work fine
12:42:20 <nand`> I just sanity checked; without MALLOC_CHECK_=2, foo1 corrupts (I haven't swapped them back), with MALLOC_CHECK_=2 both work
12:42:36 <startling> nand`: "swapping the renders makes foo1 corrupted" <- which function do you mean
12:42:49 <Palypso> hi
12:42:54 <nand`> startling: I pulled line 11 in my paste and inserted it between lines 5 and 7
12:43:09 <nand`> startling: let me paste renderPtr
12:43:24 <startling> nand`: ah. yeah I'd bet renderPtr is doing something naughty
12:43:34 <hpaste> nand` annotated “Puzzling code” with “Puzzling code (annotation)” at http://hpaste.org/77889#a77890
12:44:45 <nand`> It calls ‘mallocArray’ to allocate the arrays; then ‘withImageSurfaceForData’ <- which creates a surface, renders with it, then frees the surface right after
12:44:52 <nand`> the ‘castPtr’ in line 15 casts from Ptr CUChar to Ptr Word8
12:44:59 <`Jake`> can someone explain this to me? <`Jake`> > singleton 1 <lambdabot> mueval-core: Time limit exceeded
12:45:01 <nand`> (maybe that's wrong?)
12:45:08 <`Jake`> If i try it again, lambdabot can't find it
12:45:12 <mauke> I'd definitely check the value of 'size' there
12:45:18 <nand`> no, CUChar is a newtype for Word8
12:45:19 <`Jake`> > singleton 1
12:45:21 <lambdabot>   Not in scope: `singleton'
12:45:21 <lambdabot>  Perhaps you meant one of these:
12:45:22 <lambdabot>    `BS.singleton...
12:45:31 <startling> nand`, yeah I dunno
12:46:40 <nand`> mauke: ‘formatStrideForWidth FormatARGB32 1000’ => 4000; so size = 4000 * 1000; consistent with the (1000*1000*4) in the code above
12:48:00 <hpaste> navaati pasted “parsec, possible to do better ?” at http://hpaste.org/77891
12:48:20 <nand`> the two odd things here are still 1. why does it work if I omit ‘free b’? Maybe because the first buffer is being freed, the second one re-allocates in the same spot, and some leftover cairo code is ruining that or something?
12:48:35 <navaati> does anyone think it's possible to express this ^^^ in a more elegant way ?
12:48:38 <nand`> and 2. what's the effect of MALLOC_CHECK_=2 and why does it work if that's set?
12:49:34 <mauke> nand`: MALLOC_CHECK_=2 enables additional checks that call abort() if anything looks wrong
12:49:56 <navaati> ahah, nand`, doing memory leaks in haskell :D ?
12:50:01 <mauke> apparently something's gone very wrong so that the presence of those checks actually hides the bug
12:50:06 <flonum> Is there anything like Data.Map.insertWith but that takes a more general combining function of type (b -> a -> a) instead of (a -> a -> a)?  (For instance, if I have a map whose values are lists/sets which I want to insert into instead of overwriting, I have to first wrap the value I'm inserting in a singleton, which does unnecessary allocation if I'm building a big map.)
12:50:35 <nand`> mauke: despite this, enabling that flag makes the program produce two correct outputs. I sanity checked by deleting them beforehand
12:50:50 <flonum> I tried updateWith, alter, but these don't seem to allow combining with the old value.
12:51:00 <mauke> nand`: and valgrind?
12:53:09 * jmcarthur has discovered the joy of typelits
12:53:25 <nand`> typelits are great until you realize you can't do anything with them
12:53:40 <jmcarthur> i can do enough for what i need right now, i think
12:54:55 <nand`> mauke: just installed valgrind; how do I use it? Just valgrind ./TestProgram ?
12:55:18 <mauke> yes
12:55:33 <nand`> hmm, missing glibc debug info
12:55:57 <nand`> I suppose that would be USE="debug" in sys-libs/glibc
12:57:12 * nand` doesn't feel like rebuilding glibc today, maybe tomorrow
12:59:47 <nand`> yuck; it's more complicated than that: http://ck.kennt-wayne.de/2012/jan/valgrind-again%3A-strlen-redirection
13:06:06 <nand`> mauke: no output with MALLOC_CHECK_=1; which is supposed to print diagonistics to STDERR in the case of detection
13:06:26 <mauke> nand`: of course, you already said it worked with 2
13:08:31 <nand`> hmm; here's something curious: the documentation mentions “protection against double calls of free” <- I changed ‘free b’ to ‘free b; free b’ and I get the exact same corruption that I got before; but this time even with the MALLOC_CHECK_=1; and I still get nothing on stderr
13:08:41 <nand`> maybe some code, somewhere is freeing ‘b’ for some reason
13:10:07 <nand`> actually, that may be a distinct possibility - withImageSurfaceForData could be freeing the buffer immediately afterwards
13:12:03 <stroka007> hi
13:12:19 <stroka007> Any body to assist to me ?
13:12:48 <simpson> stroka007: What do you need help with?
13:13:10 <shapr> osa1: I want to see what you come up with!
13:13:54 <stroka007> thankx simpson i am now learning Haskell but i wanted to know whether its a bit equal to python ?
13:14:03 <startling> stroka007: not really
13:14:19 <startling> stroka007: it's statically typed, not object-oriented, and pure.
13:14:47 <simpson> stroka007: As somebody who does both, they are different languages that taste similar but for very different reasons.
13:15:21 <jmcarthur> i don't even see how they taste similar
13:16:21 <osa1> shapr: I didn't use that package because of some specific requirements. see first 3 functions and where I used them: https://github.com/osa1/language-lua/blob/printer/src/Language/Lua/Test.hs
13:17:07 <osa1> shapr: I'm not saying what I can't do what I want to do with that package, but I don't know template haskell, and that package doesn't have enough documentation for me
13:19:34 <nand`> mauke: hrm, I think I know what's causing the corruption
13:20:11 <nand`> from cairo's cairo_image_surface_create_for_data “The initial contents of data will be used as the initial image contents; you must explicitly clear the buffer”
13:20:25 <nand`> whelp, how do I write 1000*1000*4 zero bytes to a Ptr Word8?
13:20:30 <nand`> I can't seem to figure it out
13:23:06 <bgamari> Nanar, Why don't use just do a Cairo fill?
13:23:06 <startling> nand`: as an array? do you know that the pointer has enough space?
13:23:21 <bgamari> nand`, rather
13:23:33 <mauke> nand`: pokeArray p (replicate n 0)
13:23:34 <nand`> I guess I could use ‘mapM_ pokeByteOff b [0..1000*1000*4-1]’
13:23:39 <mauke> or foreign import memset
13:23:53 <nand`> bgamari: I could use a cairo fill, yeah
13:24:51 <hpaste> ew0 pasted “weird error” at http://hpaste.org/77892
13:24:58 <ew0> yo
13:25:05 <ew0> can someone help me understand this compiler error?
13:25:49 <Cale> ew0: you didn't paste the error...
13:25:51 <mauke> ew0: that's not an error
13:25:52 * hackagebot Boolean 0.1.1 - Generalized booleans  http://hackage.haskell.org/package/Boolean-0.1.1 (ConalElliott)
13:25:55 <hpaste> ew0 pasted “weird error (compilation)” at http://hpaste.org/77893
13:25:57 <mauke> that looks like Haskell code
13:26:02 <ew0> yes
13:26:04 <Cale> okay
13:26:08 <ew0> error here in the second part xD
13:26:20 <ew0> when you compile that code with ghc -c
13:26:26 <Cale> So, it says that c in the type signature you gave is polymorphic
13:26:31 <mauke> you could have just annotated the first paste
13:26:45 <Cale> but, your implementation requires c to be Map Int a1
13:27:25 <nand`> (still corruption after adding a cairo fill before the render)
13:28:09 <Cale> "rigid type variable" means a type variable which appears as such in an explicit type signature, and so can't be replaced with some more specific type
13:28:10 <nand`> actually, I have no idea if I'm doing the cairo fill correctly; I don't know cairo
13:28:30 <Cale> So let's look more closely at what's going on
13:28:49 <Cale> It says that this is happening in the second argument of foldl, which is M.empty
13:28:54 <ew0> uhm
13:29:03 <nand`> seems I didn't; works with pokeArray, thanks mauke
13:29:08 <Cale> The result of the foldl will be the result of this whole function
13:29:31 <Cale> and its type will be the same as the type of M.empty
13:30:00 <Cale> because foldl always produces a result with the same type as its second parameter
13:30:10 <centrinia_> :t foldl
13:30:11 <lambdabot> (a -> b -> a) -> a -> [b] -> a
13:31:35 <Cale> ew0: Try deleting (or commenting out) the explicit type signature for fgmap and see what the inferred type is
13:31:48 <ew0> ok
13:32:07 <Cale> (or perhaps you'll get a new type error, which would also be interesting)
13:32:56 <latro`a> gah, why is there a where inside a let
13:33:11 <Cale> latro`a: That where is part of the declaration of uwp
13:33:21 <latro`a> I see that, but why is it there
13:33:25 <latro`a> why not just have it in the let
13:33:30 <latro`a> they're corecursive
13:33:43 <Cale> because the things defined in it depend on the parameters to uwp
13:33:52 <latro`a> oh I see
13:34:09 <hpaste> ew0 pasted “error (w/o inference)” at http://hpaste.org/77894
13:34:23 <latro`a> given that this is fairly small I think that could be lambda lifted
13:34:28 <latro`a> and be somewhat less confusing
13:34:31 <latro`a> but that's my taste
13:34:51 <Cale> ew0: get rid of the type signature for uwp as well
13:35:19 <Cale> ew0: basically, these things don't have the types that you're saying they do :)
13:37:10 <ew0> ok, now it compiles
13:37:12 <ew0> meh
13:38:42 <Cale> ew0: If you ask for the type of fgmap in GHCi, you'll see that it's:
13:38:47 <Cale> fgmap
13:38:47 <Cale>   :: (Ord b1, Graph gr, Data.Hashable.Hashable b1) =>
13:38:47 <Cale>      (a -> (t, b1, t1, [(a1, b1)]) -> a)
13:38:47 <Cale>      -> (a -> a -> a) -> a -> gr (t, b1, t1, [(a1, b1)]) b -> M.Map b1 a
13:38:58 <ew0> ok
13:39:13 <ew0> I think I understad what went wrong now =D
13:39:19 <ew0> let me see...
13:47:53 <zamwich> Hi, I'm trying to run <map Char.toUpper "Hello World"> in ghci, but I keep getting the error <Failed to load interface for `Char'>. Any ideas?
13:48:18 <ew0> my topsort wasn't getting the contexts
13:48:37 <atriq> zamwich, "import Data.Char"
13:48:50 <Philonous> zamwich:  I think that means that Char is not imported. Try import Data.Char as Char
13:48:57 <ew0> I changed "ts = topsort g" to "ts = map (context g) (topsort g)" and it worked fine
13:49:04 <ew0> Cale, thanks!
13:49:06 <Maarten> Hi, i'm new to haskell. Currently following this tutorial about fastcgi with haskell: http://www.0x80.net/blog/article/web-development-in-haskell-part2.html   . When compiling the first example i get: "Not in scope: `text'".. Any ideas?
13:49:26 <Cale> ew0: no problem!
13:49:40 <zamwich> import Data.Char as Char did it, thanks
13:50:23 <atriq> zamwich, also, you don't need to say "Char."
13:50:32 <atriq> map toUpper "Hello World" works
13:50:39 <atriq> > map toUpper "Hello World"
13:50:40 <lambdabot>   "HELLO WORLD"
13:50:45 <nand`> (why would you want to use FastCGI instead of actually implementing the web server in Haskell?)
13:54:10 <Maarten> nand`: i can't even compile an example yet, so that's why :D
13:54:35 <osfameron> er, nothing wrong with using an existing fastCGI server
13:54:38 <zamwich> So, why does import Char not give me an error? what is that importing?
13:54:43 <osfameron> you could use an existing on in haskell I suppose
13:55:08 <nand`> I thought ‘Char’ didn't even exist anymore
13:55:39 <geekosaur> it exists but only in the haskell98 package, which has to be used with the Haskell98 language declaration
13:56:30 <geekosaur> zamwich, modern Haskell uses a more flexible module namespace.  It's Data.Char these days
13:56:35 <Maarten> any ideas about this "Not in scope: `text'" ? Is it a mistake in the tutorials example? Or is something wrong with my install of haskell..
13:57:01 <geekosaur> for a long time you could mix Haskell98 and modern modules, but eventually the incompatibilities between them became too large
13:58:10 <zamwich> as is the way of things
13:58:24 <zamwich> thanks guys!
14:00:32 <nand`> Maarten: try: import Text.Blaze.Internal (text)
14:01:05 <nand`> maybe that isn't being re-exported properly
14:02:11 <nand`> that's odd
14:02:26 <nand`> Text.Blaze.Html5 re-exports Text.Blaze.Html which re-exports Text.Blaze, which doesn't exist
14:02:40 <nand`> (of course, none of those re-export text)
14:02:51 <nand`> I can't find a way to import ‘text’ other than importing .Internal
14:03:32 <geekosaur> looks extant to me, just a different package?
14:03:33 <Maarten> nand`: thanks! now it compiled
14:04:13 <nand`> oh, blaze-markup; yeah
14:04:37 <nand`> but Text.Blaze doesn't export ‘text’ either
14:04:51 <nand`> (not that it could, seeing as that's in blaze-html)
14:05:38 <bytbox>  
14:05:43 <bytbox> godammit
14:05:44 <bytbox> ignore that
14:06:19 <nand`> oh, it isn't in blaze-html
14:07:43 * nand` can't see any way to get it into scope other than Text.Blaze.Internal; so there you have it
14:10:38 <Maarten> it works for me :)
14:13:47 <Maarten> third example cant be compiled either.. "Ambiguous occurrence `output'". are these kind of problems common? i see the blog post's http header says it's a 2 year-old article..
14:14:34 <mapf> > (foldr (.) id $ replicate 10000 id) 0
14:14:38 <lambdabot>   0
14:14:47 <Maarten> i mean: is it common that 2 year old examples are broken, etc
14:14:57 <mapf> > (foldr (.) id $ replicate 1000000 id) 0
14:14:59 <lambdabot>   0
14:15:04 <geekosaur> it can be, eys
14:15:12 <geekosaur> some parts of the haskell ecosystem evolve rapidly
14:16:26 <cornihilio> what does <|> mean? the rwh book is pointing at p 388 and it's definition doesn't make much sense to me
14:16:49 <mapf> :t (<|>)
14:16:51 <lambdabot> Alternative f => f a -> f a -> f a
14:17:00 <mapf> @src Alternative
14:17:01 <lambdabot> class Applicative f => Alternative f where
14:17:01 <lambdabot>     empty :: f a
14:17:01 <lambdabot>     (<|>) :: f a -> f a -> f a
14:17:08 <Maarten> thanks for the help guys
14:17:17 <cornihilio> mapf: thank you
14:17:36 <cornihilio> I kept trying :t <|>...
14:19:18 <mapf> cornihilio: if you read about parsers then in this context (<|>) just trying to apply left parser, and if it fails it's just behave as right parser
14:19:29 <jmcarthur> cornihilio: it would have to be   :t (<|>)
14:20:04 <jmcarthur> ah that's exactly what mapf did for you. nevermind my redundancy
14:20:50 <mapf> or it combine parsers if you have data Parser a r = Parser { runParser :: a -> [(r, String)] }
14:20:54 <mapf> something like this
14:21:29 <mapf> :t noneOf
14:21:31 <lambdabot> Not in scope: `noneOf'
14:33:15 <deus_rex> is any function whose name is just a MathSymbol automatically made infix?
14:33:45 <nand`> yes
14:33:48 <nand`> it's an operator
14:36:24 <`Jake`> deus_rex: Any function whose name is made only out of special characters is automatically made infix
14:36:24 <startling> > let a # b = a + b in 1 # 2
14:36:26 <lambdabot>   3
14:36:38 <startling> sort of bugs me that we can't do
14:36:49 <startling> > let a <a> b = a + b in 1 <a> 2
14:36:51 <lambdabot>   <hint>:1:5: Parse error in pattern: a < a
14:37:26 <`Jake`> but it makessense
14:37:57 <Jafet> > let a = (); x < () = x; x > y = x + y in 1 <a> 2
14:37:59 <lambdabot>   3
14:38:47 <nand`> now try sectioning it :P
14:39:10 <Jafet> Sections are broken anyway
14:39:18 <Jafet> > (1 + 2 +)3
14:39:20 <lambdabot>   6
14:39:25 <`Jake`> And it doesn't work if you don't want to redefine '>' and '<', and you can't use a as a variable
14:39:28 <Jafet> Or not
14:39:35 <`Jake`> What did you expect?
14:39:42 <Jafet> > (1 : 2 : )[]
14:39:44 <lambdabot>   The operator `:' [infixr 5] of a section
14:39:44 <lambdabot>      must have lower precedence th...
14:39:55 <Jafet> > 1(+2 + 3)
14:39:57 <lambdabot>   The operator `GHC.Num.+' [infixl 6] of a section
14:39:58 <lambdabot>      must have lower prece...
14:40:12 <nand`> there we go
14:40:36 <startling> you shouldn't be able to leave out the spaces with operators; then everything would work fine.
14:41:02 <Jafet> {-# LANGUAGE Agda #-}
14:41:25 <`Jake`> startling: That would be confusing for many people, I think.
14:41:44 <nand`> that would make some lens users very unhappy, not to mention breaking half the world :)
14:41:53 <startling> Jafet: does that include the emacs mode?
14:41:58 <deus_rex> > let (☃) = (+); 5 ☃ 10
14:41:58 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:42:01 <startling> nand`: those lens people are silly anyway
14:42:03 <edwardk> navaati: ?
14:42:09 <edwardk> er nand: ?
14:42:19 <nand`> edwardk: forcing spaces around operators
14:42:23 <argiopeweb> Anyone know why a rewrite rule would fire with explicit ">>" but not via "do" notation? Rewrite rule is "my/double-truncate" forall m. m >> truncateFile = truncateFile. Don't want to spend too much time on this one, but if there's a quick fix it'd me nice.
14:42:36 <hiptobecubic> i like leaving out space with (:)
14:42:41 <startling> I'm not saying we should change haskell, just that we should go back in time.
14:42:58 <edwardk> ah. (1+2)   -- nope. not just nope but hell nope
14:43:13 <startling> edwardk: haha
14:43:29 <startling> edwardk: you can already do that though!
14:43:39 <Jafet> startling: http://comonad.com/haskell/remorse-1.0/remorse.hs
14:43:42 <startling> > id (1+2) 0
14:43:43 <lambdabot>   3
14:44:05 <shachaf> > let x <| f = f x; f |> x = f x in 5 <| (+) |> 3
14:44:08 <lambdabot>   8
14:44:19 <Pantoufle> :t (<|)
14:44:21 <lambdabot>     Not in scope: `<|'
14:44:21 <lambdabot>     Perhaps you meant one of these:
14:44:21 <lambdabot>       `Seq.<|' (imported from Data.Sequence),
14:44:22 <deus_rex> Jafet: lol
14:44:27 <Pantoufle> :t Seq.(<|)
14:44:28 <lambdabot> Not in scope: data constructor `Seq'
14:44:29 <lambdabot>     Not in scope: `<|'
14:44:29 <lambdabot>     Perhaps you meant one of these:
14:44:32 <`Jake`> > let (+☃) = (+); 5 +☃ 10
14:44:32 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:44:35 <Pantoufle> :t Seq.<|
14:44:36 <lambdabot> parse error on input `Seq.<|'
14:44:38 <Jafet> The enterprise (+)
14:44:41 <Pantoufle> :t (Seq.<|)
14:44:43 <lambdabot> a -> Seq.Seq a -> Seq.Seq a
14:45:54 <startling> `Jake`: non-ascii identifiers are invalid by default iirc
14:46:29 <`Jake`> > let a☃b = Just
14:46:29 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
14:46:35 <`Jake`> I think it works in ghci
14:46:58 <`Jake`> kind of, at least
14:47:14 <`Jake`> I can define the function, but I can't use it
14:47:30 <deus_rex> `Jake`: http://cl.ly/image/1g333J1m332c
14:47:38 <nand`> works fine for me
14:47:55 <startling> oh. maybe lambdabot doesn't do utf-8 then?
14:48:14 <startling> deus_rex, is that emacs or what?
14:48:19 <deus_rex> ghci in tmux
14:48:24 <`Jake`> deus_rex: Is that the character you pasted here a while ago?
14:48:29 <startling> ah, tmux
14:48:30 <deus_rex> `Jake`: no, I pasted unicode snowman
14:48:39 <deus_rex> that character is unicode 'pile of poop'
14:48:49 <`Jake`> deus_rex: can you paste it?
14:48:55 <deus_rex> The technique used by 'remorse' to obfuscate programs is to rename
14:48:57 <deus_rex> er
14:49:07 <deus_rex> 💩
14:49:22 <`Jake`> Well, doesn't display correctly, I'll try to find it
14:51:06 <aristid> the Enum typeclass is evil. (because of toEnum)
14:51:12 <`Jake`> I guess it doesn't work all that well if your font doesn't support it.
14:52:03 <startling> Jafet: I give up, what does it do?
14:52:14 <edwardk> startling: remorse?
14:52:17 <startling> yeah
14:52:29 <edwardk> startling: it converts your program into one where identifiers are in morse code
14:52:31 <edwardk> and back
14:52:50 <startling> edwardk, is that output or is that the program itself?
14:53:04 <edwardk> (..|---|…) would be sos
14:53:07 <startling> or both, I guess
14:53:12 <edwardk> both
14:53:15 <FireFly> deus_rex: OSX Terminal.app renders certain unicode dingbats as coloured images?
14:53:25 <edwardk> er (…|---|…)
14:53:47 <edwardk> remorse was run on the remorse source code before submitting it to the contest =P
14:54:03 <startling> edwardk: right, makes sense.
14:54:23 <mapf> > let 1 = 2 in 1
14:54:25 <lambdabot>   1
14:54:45 <mapf> stupid lambdabot
14:55:02 <edwardk> mapf: that let binding can't fail. its not lambdabot's fault
14:55:18 <mapf> edwardk: i'm just joking a bit
14:55:31 <`Jake`> let 1 = 2
14:55:34 <`Jake`> > let 1 = 2
14:55:36 <lambdabot>   not an expression: `let 1 = 2'
14:55:50 <mapf> `Jake`: lack of in
14:56:01 <startling> mapf: not technically wrong no matter how you spin it!
14:56:13 <`Jake`> mapf: Thought lambdabot would accept something like that for temporary use... oh well
14:56:32 <startling> `Jake`: @let
14:56:32 <`Jake`> > f = 1
14:56:33 <mapf> @let a = 1
14:56:34 <lambdabot>   <hint>:1:3: parse error on input `='
14:56:35 <lambdabot>  Defined.
14:56:37 <`Jake`> ah, thanks
14:56:37 <mauke> @undefine
14:56:58 <mapf> @undefine undefined
14:57:13 <`Jake`> > undefined
14:57:15 <lambdabot>   *Exception: Prelude.undefined
14:57:16 <mapf> @make impossible possible
14:57:17 <lambdabot> Maybe you meant: map more
14:58:11 <`Jake`> @let undefined = 1
14:58:12 <lambdabot>  Defined.
14:58:15 <`Jake`> undefined
14:58:17 <`Jake`> > undefined
14:58:19 <lambdabot>   Ambiguous occurrence `undefined'
14:58:19 <lambdabot>  It could refer to either `L.undefined', d...
14:58:27 <`Jake`> @undefine undefined
14:59:02 <aristid> `Jake`, mapf: you can talk to lambdabot in a query if you want to make a lot of experiments
14:59:12 <`Jake`> aristid: All right
15:00:06 <jmcarthur> the only weird thing about lambdabot in a query is that it won't handle :t. you have to use one of the longer versions like @type
15:02:12 <electrostatik> hello
15:02:14 <`Jake`> hi
15:02:17 <mapf> hi
15:02:26 <deus_rex> FireFly: iOS and os x since 10.7 has rendered the unicode emoji characters graphically, yeah
15:02:28 <nand`> ?t id
15:02:29 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:02:31 <nand`> ah
15:02:34 <nand`> so that's too short
15:02:40 <FireFly> deus_rex: heh, cute :-)
15:03:35 <startling> FireFly: pretty sure you can do it in whatever you want if you've got the right font
15:03:36 <mapf> lambdabot is getting mad?
15:03:46 <mapf> what does ?t mean?
15:04:21 <startling> ?t t
15:04:21 <lambdabot> Maybe you meant: tell thank you thanks thx ticker time todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ? @ ft v
15:06:57 <mapf> :t thank
15:06:59 <lambdabot> Not in scope: `thank'
15:07:28 <startling> @thank mapf
15:07:28 <lambdabot> Maybe you meant: thank you thanks
15:07:34 <startling> @thanks mapf
15:07:34 <lambdabot> you are welcome
15:07:42 <startling> @thanks
15:07:42 <lambdabot> you are welcome
15:07:46 <startling> haha
15:08:14 <mapf> @thanks
15:08:15 <lambdabot> you are welcome
15:09:06 <deus_rex> @thank you
15:09:06 <lambdabot> Maybe you meant: thank you thanks
15:09:21 <mapf> @time
15:09:29 <lambdabot> Local time for mapf is Mon Nov 19 03:09:10 2012
15:10:16 <tomberek> what are some reasons that a profiled program would be faster than an un-profiled one?  ie, +RTS -s is consistently 35% slower than +RTS -s -h
15:11:04 <tomberek> i notice a difference in GC, but nothing significant enough to cause the 35% difference
15:12:24 <mapf> @todo
15:12:25 <lambdabot> 0. SamB: A way to get multiple results from a google search
15:12:25 <lambdabot> 1. dons: improve formatting of @dict
15:12:25 <lambdabot> 2. dons: write Haskell Manifesto
15:12:25 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
15:12:25 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
15:12:27 <lambdabot> [36 @more lines]
15:12:55 <hiptobecubic> @more
15:12:55 <lambdabot> 5. TheHunter: @type 1 :: Int
15:12:56 <lambdabot> 6. lispy: haddock gives a link from a type signature to the types.  It would be nice if it also let you find functions in the given module that use a type.
15:12:56 <lambdabot> 7. dons: Implement @whatis
15:12:56 <lambdabot> 8. dcoutts: implement @cool list, as a clone of the @todo(-add) commands
15:12:56 <lambdabot> 9. dons: there's some bug in the 'when i left' code of @seen
15:12:58 <lambdabot> [31 @more lines]
15:13:11 <hiptobecubic> @type 1 :: Int
15:13:12 <lambdabot> Int
15:13:27 <mapf> @more
15:13:37 <hiptobecubic> I ruined it :(
15:13:48 <shachaf> /msg lambdabot @todo
15:14:12 <mapf> @todo-add getting sleep
15:14:13 <lambdabot> Entry added to the todo list
15:14:14 <Nereid> hmm, lens 3.3
15:14:20 <mapf> @todo
15:14:21 <lambdabot> 0. SamB: A way to get multiple results from a google search
15:14:21 <lambdabot> 1. dons: improve formatting of @dict
15:14:21 <lambdabot> 2. dons: write Haskell Manifesto
15:14:21 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
15:14:21 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
15:14:23 <lambdabot> [37 @more lines]
15:14:23 <startling> shachaf, you miskeyed
15:15:10 <shachaf> Nereid: I bet 3.4 will be out within the next few days.
15:15:16 <shachaf> startling: ?
15:15:19 <Nereid> I wouldn't be surprised.
15:15:25 <startling> shachaf: <shachaf> /msg lambdabot @todo
15:15:35 <shachaf> startling: What about it?
15:15:36 <joeyh> is Data.ByteString.Builder still in common use? I was wondering because it seems not to ship with ghc's version of ByteString
15:16:11 <startling> shachaf: haha nvm
15:16:22 <Jafet> /lambdabot @todo
15:18:41 <mapf> @arr
15:18:42 <lambdabot> Aye
15:18:46 <mapf> @arr
15:18:47 <lambdabot> Yeh scurvy dog...
15:18:51 <mapf> @arr
15:18:52 <lambdabot> Swab the deck!
15:18:55 <mapf> heh
15:19:16 <crdueck> I need a data structure to represent an infinite grid where its possible to move up/down/left/right with a focus at the current position. It seems like an infinite tree and zipper would be exactly what I want, but I can't figure out how to represent the 4 different choices that can be made at any given position.
15:20:47 <mapf> data Grid a = Grid { left :: [a], right :: [a], hole :: a, up :: [a], down :: [a] }
15:20:54 <mapf> nope?
15:20:59 <Nereid> nope
15:20:59 <copumpkin> nope
15:21:02 <tomberek> crdueck: data Zipper4 a = Zipper4 [a] [a] [a] [a] a doesn't work?  left :: Zipper4 -> Ziper4     left (Zipper4 (a:as) bs ............ yeah, what mapf said
15:21:18 <copumpkin> that represents a cross
15:21:18 <Nereid> nope
15:21:19 <Nereid> :v
15:21:21 <Jafet> @wn grid
15:21:23 <lambdabot> *** "grid" wn "WordNet (r) 3.0 (2006)"
15:21:23 <lambdabot> grid
15:21:23 <lambdabot>     n 1: a pattern of regularly spaced horizontal and vertical lines
15:21:23 <lambdabot>     2: a system of high tension cables by which electrical power is
15:21:23 <lambdabot>        distributed throughout a region [syn: {power system}, {power
15:21:25 <lambdabot> [9 @more lines]
15:22:24 <`Jake`> @list
15:22:24 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:22:26 <Jafet> I don't recall anyone ever making an efficient grid zipper
15:22:44 <startling> crdueck, data Zipper a = [a] a [a]; newtype Grid a = Grid (Zipper (Zipper a))
15:22:49 <nand`> data Zipper2D a = Zipper2D { left :: [a], hole :: a, right :: [a], above :: Zipper2D a, below :: Zipper2D a }
15:22:56 <tomberek> what are some reasons that a profiled program would be faster than an un-profiled one?  ie, +RTS -s is consistently 35% slower than +RTS -s -h
15:22:57 <nand`> or what startling said
15:23:12 <Nereid> that's problematic though
15:23:22 <shachaf> That's not really what you want.
15:23:22 <startling> it's a little clumsy, yeah
15:23:28 <Nereid> how do you deal with the horizontal position when moving up or down?
15:23:38 <startling> Nereid, lenses
15:23:41 <Nereid> haha
15:23:47 <startling> that's what I did
15:23:54 <startling> made things so much easier
15:24:10 <startling> all my projects start out as "this is just going to be ~100 loc, I don't need lens"
15:24:33 <nand`> toRight Zipper2D{..} = Zipper2D (hole:left) (head right) (tail right) (toRight above) (toRight below) -- ?
15:24:41 <nand`> but that's probably not ideal
15:25:08 <edwardk> startling: =)
15:25:11 <Nereid> sounds expensive
15:25:37 <Jafet> Grid a = Grid (Int, Int) (Map (Int, Int) a)
15:25:58 <startling> Jafet: they said infinite
15:26:01 <crdueck> Jafet: I need it to be infinite
15:26:07 <startling> oh, I see
15:26:09 <startling> heh, clever
15:26:10 <Nereid> also sounds like moving right by n and up by n would be O(n^2)
15:26:10 <Jafet> s/Int/Integer
15:26:20 <Jafet> > maxBound :: Int
15:26:21 <nand`> startling: with lenses it would be ~10
15:26:22 <lambdabot>   9223372036854775807
15:26:23 <edwardk> Store (Int,Int) a -- is a pretty decent zipper =P
15:26:34 <startling> nand`: exactly
15:26:36 <edwardk> Store (Integer, Integer) a -- is even infinite
15:26:41 <Nereid> edwardk to the rescue
15:26:47 <Jafet> @src Store
15:26:48 <lambdabot> Source not found. Maybe if you used more than just two fingers...
15:27:07 <edwardk> newtype Store s a = Store (s -> a) s
15:27:11 <edwardk> er data Store
15:27:40 <crdueck> edwardk: how do you use that as a zipper?
15:27:40 <edwardk> extract (Store f s) = f s; duplicate (Store f s) = Store (Store f) s
15:28:01 <edwardk> crdueck: if you want to move up, down, left, right, you modify 's' appropriately
15:28:08 <Jafet> Okay, so you don't actually store stuff into it
15:28:16 <startling> so is there anything *other* than parsec that I could try? I want more cohesive error-handling.
15:28:24 <startling> trifecta is p. much parsec
15:28:42 <edwardk> up :: Store (Int,Int) a -> a; up (Store f (x,y)) = f (x,y+1)
15:28:58 <Jafet> crdueck: why do you want a zipper
15:29:02 <Jafet> Winter heating?
15:30:16 <Nereid> hm, would there even be any point to a lensy interface for STRef and similar guys?
15:30:37 <edwardk> Nereid: i wanted it actually. its just awkward to fit into the framework with the laws =(
15:30:54 <Nereid> hmm
15:31:00 <edwardk> that was part of the original motivation for actions
15:31:43 <edwardk> > (10,20)^!both.act (\x -> [x, x + 1])
15:31:45 <lambdabot>   Ambiguous type variable `b0' in the constraints:
15:31:45 <lambdabot>    (GHC.Num.Num b0)
15:31:45 <lambdabot>      a...
15:31:49 <edwardk> bah
15:31:59 <edwardk> :t (10,20)^!both.act (\x -> [x, x + 1])
15:32:01 <lambdabot> (Num b, Monoid b) => [b]
15:32:25 <edwardk> i'll get that down idiomatically eventually
15:32:46 <shachaf> edwardk: Pushed.
15:32:52 <edwardk> woot
15:33:32 <edwardk> Plated looks much more manageable between both our patches =)
15:34:47 <shachaf> Whoops, wrong channel.
15:34:56 <shachaf> Well, whatever. Lenses are on-topic everywhere.
15:35:16 <edwardk> =)
15:35:41 <tomberek> I updated http://hackage.haskell.org/trac/ghc/ticket/5505 with an instance of GHC 7.6.1 running faster with profiling (-h) than without.
15:38:48 <edwardk> ok, i've fixed 'taking' to handle infinite lists better, next up, dropping.
15:40:28 <navaati> @hoogle Either l r -> Bool
15:40:28 <lambdabot> Data.Graph.Inductive.Basic hasLoop :: Graph gr => gr a b -> Bool
15:40:29 <lambdabot> Data.Graph.Inductive.Query.DFS isConnected :: Graph gr => gr a b -> Bool
15:40:29 <lambdabot> Data.Graph.Inductive.Graph isEmpty :: Graph gr => gr a b -> Bool
15:41:37 <shachaf> edwardk: For dropping I guess you want to keep the old part of the list around and prefix it to the newly-traversed list?
15:41:48 <shachaf> It seems like there ought to be a better way of doing this than partsOf.
15:42:28 <edwardk> yeah dropping and taking are remarkably symmetrical this way
15:42:40 <edwardk> there should be, yes
15:43:35 <edwardk> > "hello"^? dropping 2 traverse
15:43:37 <lambdabot>   Just 'l'
15:43:42 <edwardk> > "hello"^? dropping 1 traverse
15:43:44 <lambdabot>   Just 'e'
15:44:20 <Nereid> > (1,2) ^? dropping 1 both
15:44:22 <lambdabot>   Just 2
15:44:36 <Nereid> pointless, heh
15:44:48 <edwardk> > ("hello","world") ^. elementOf 1 both
15:44:50 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
15:44:50 <lambdabot>              with actual type ...
15:44:54 <edwardk> > ("hello","world") ^. elementOf both 1
15:44:57 <lambdabot>   "world"
15:44:58 <edwardk> > ("hello","world") ^. elementOf both 0
15:45:00 <lambdabot>   "hello"
15:46:53 <lolcathost> :t both
15:46:55 <lambdabot> Applicative f => (a -> f b) -> (a, a) -> f (b, b)
15:46:55 <edwardk> ugh. i think we have a problem.
15:47:28 <edwardk> > [1,2,3,4]^.. taking 2 traverse
15:47:31 <lambdabot>   [1,2]
15:47:34 <edwardk> > [1,2,3,4]^.. taking 2 folded
15:47:37 <lambdabot>   [1,2]
15:47:50 <edwardk> that worked before but ceases to work with the new taking and dropping
15:47:59 <edwardk> so we need to figure out a better way
15:48:24 <edwardk> same with indexed. =(
15:48:55 <Nereid> what's the new taking and dropping?
15:49:06 <edwardk> taking n l f s = case splitAt n $ view (unsafePartsOf l) s of  (as,xs) -> (\bs -> set (unsafePartsOf l) (bs ++ xs) s) <$> traverse f as
15:49:23 <edwardk> before it used a type named 'Indexing' that didn't deal well with infinite structures =(
15:49:51 <Nereid> hmm
15:50:21 <Nereid> hey I understand that code.
15:50:22 <Nereid> :s
15:50:45 <shachaf> Oh, yes, taking needs to work with both Fold and Traversal.
15:51:37 <shachaf> > "abcdef" ^. elementOf folded 3
15:51:40 <lambdabot>   No instance for (Control.Lens.Internal.Gettable
15:51:41 <shachaf> That should work too.
15:51:42 <lambdabot>                     (Contro...
15:51:47 <edwardk> yep
15:52:55 <shachaf> So much for the easy way out.
15:54:17 <edwardk> indexed, dropping and taking used to work, elementOf never did though, so i don't feel too guilty about that ;)
15:54:30 <shachaf> Oh, it didn't?
15:54:36 <edwardk> not with folded
15:54:46 <shachaf> Ah, because it returns a lens.
15:54:49 <edwardk> yep
15:55:14 <edwardk> in theory it could be careful and preserve the Gettable'ness of the 'f' that it uses to drive itself, and give you a getter when fed a Fold.
15:55:34 <shachaf> Ideally holesOf would magically downgrade to toListOf, too.
15:55:37 <edwardk> but that would probably drop out obviously as part of whatever fix makes the other combinators work
15:55:58 <edwardk> we can probably sprinkle a few RULES pragmas in there for stuff like that
15:56:39 <edwardk> oh i misparsed
15:56:39 <shachaf> I mean in terms of types.
15:56:40 <edwardk> yeah
15:56:50 <shachaf> But since it returns a list of contexts it might be tricky.
15:57:09 <edwardk> i don't see holesOf successfully downgrading itself
15:57:22 <Nereid> meanwhile, if you can let those guys take both folds and traversals, you could also do the same for takingWhile/droppingWhile?
15:57:42 <edwardk> takingWhile cannot legally support a traversal
15:57:47 <Nereid> neither can filtered
15:57:58 <edwardk> consider what happens when you change one of the targets to violate the predicate.
15:58:08 <edwardk> filtered doesn't claim to support a traversal, it just happens to kinda work ;)
15:58:15 <Nereid> heh
16:11:40 <mm_freak> @remember eboy You has kelled me (##crypto)
16:11:40 <lambdabot> It is stored.
16:16:15 <Jafet> has.kell.me/harder
16:19:09 <parcs`> > recip (0.731 / 10^7)
16:19:11 <lambdabot>   1.3679890560875513e7
16:21:52 <simpson> Hey, what's the difference between binary and cereal? Is there a preference?
16:23:41 <startling> simpson: cereal is newer and has an Alternative instance
16:23:49 <startling> so you can do a <|> b <|> c
16:23:51 <startling> which is nice.
16:24:27 <simpson> startling: Aha.
16:24:45 <simpson> But some things, like Cloud Haskell, demand Binary instances. Guess I'll just go with it?
16:24:46 <rwbarton> one of them uses lazy bytestrings while the other uses strict bytestrings
16:24:53 <rwbarton> but i forget which is which
16:24:56 <startling> oh, that too ^
16:25:14 <simpson> Binary's lazy, cereal's strict?
16:25:18 <rwbarton> and it matters less than you might expect because the parsing is still effectively strict either way due to the possibility of failure
16:25:21 <simpson> Or something something.
16:25:36 <simpson> Yeah, I do *not* really want on-the-wire stuff to be that lazy.
16:29:22 <shachaf> rwbarton: For some reason people don't like making streaming parsers in Haskell.
16:29:54 <simpson> Streaming parsers are haaaaaard. :c
16:30:05 <rwbarton> I had the idea (which I assume is standard) of tracking whether a parser can fail in the type
16:31:39 <copumpkin> shachaf: how do you incorporate failure!
16:31:47 <copumpkin> I can think of one way, but it's kind of ugly
16:32:08 <rwbarton> in the result?
16:32:10 <shachaf> copumpkin: By having a failure token?
16:32:13 <simpson> Huh. Control.Distributed.Process has the Process monad, which is its general workhorse. Process is a MTL stack on IO, and has a MonadIO instance. However, it doesn't have a runner. Am I just supposed to call unProcess on it directly?
16:32:32 <shachaf> parse :: String -> [Either Failure Token]
16:32:38 <shachaf> OK, you can make that type a bit smaller.
16:32:54 <simpson> -- | Deconstructor for 'Process' (not exported to the public API)
16:32:56 <shachaf> You want a list of tokens which is terminated by either Success or (Failure Details)
16:33:08 <copumpkin> shachaf: but why a list?
16:33:10 <rwbarton> sometimes you can resume from a failure
16:33:21 <shachaf> ~ parse :: String -> (ParseResult,[Token])
16:33:28 <simpson> Right, if the failure was due to insufficient data.
16:33:34 <sipa> hehe
16:33:48 <copumpkin> the nice thing about our parsers is that we can produce arbitrary types right now
16:33:55 <shachaf> (Where ParseResult = Failure Details | Success
16:33:55 <rwbarton> well I meant if you have a line-based format for example
16:34:00 <shachaf> copumpkin: Well, OK, I have a few specific example in this case.
16:34:03 <copumpkin> it'd be nice to maintain that kind of behavior, without sacrificing laziness
16:34:20 <rwbarton> i think my strategy for failure was to let the user deal with it
16:34:25 <shachaf> The last two examples of this that someone has talked to me about have been a streaming YAML parser and a streaming CSV parser.
16:34:36 <startling> o.o
16:34:40 <shachaf> Given a list of tokens you can always construct an AST out of them pretty easily.
16:34:53 <copumpkin> sure
16:35:05 <shachaf> But given an AST parser you can't get a token parser. :-)
16:35:23 <copumpkin> my idea was to factor out the recursion in your produced type
16:35:27 <startling> what would you use a streaming yaml parser for?
16:35:29 <copumpkin> and sandwich a failure type in
16:35:32 <startling> really long configurations?
16:35:42 <rwbarton> copumpkin: yeah
16:35:56 <copumpkin> which is ugly
16:36:00 <rwbarton> you can make this an "add-on" to a non-failing parser though
16:36:05 <rwbarton> a separate concern
16:36:08 <copumpkin> yeah
16:36:14 <copumpkin> but you do need to factor out the recursion, I think
16:36:23 <rwbarton> in some cases
16:36:39 <rwbarton> i think it is problem-dependent in an essential way
16:36:49 <simpson> Aha, got it! The runners are in another module. Derp.
16:38:24 <Ralith> Can anyone recommend an easy-to-use 2D drawing library that I can get a PNG out of?
16:38:36 <startling> Ralith, people like JuicyPixels
16:39:36 <Ralith> startling: I'm looking for geometry-oriented drawing library, rather than just something to push pixels to.
16:39:47 <startling> ah
16:39:51 <shachaf> copumpkin: The annoying part is that almost none of the parsing libraries have any option for this.
16:39:54 <startling> Ralith: there's a blaze-svg
16:40:36 <Ralith> startling: looks nice, albeit a bit low-level
16:41:16 <fryguybob> Ralith: What are you wanting to draw?
16:41:17 <sclv> Ralith: have you seen Diagrams?
16:41:23 <sclv> it is very powerful
16:41:30 <rwbarton> oh apparently diagrams can output png
16:41:37 <Ralith> fryguybob: some simple annotated arcs and lines
16:41:50 <sclv> diagrams is perfect for you if you can get it running
16:41:58 <Ralith> is that hard?
16:42:35 <sclv> depends -- it has a bunch of backends
16:42:41 <sclv> the cairo backend is as hard as cairo is
16:42:46 <sclv> the others are a breeze as i recall
16:43:05 <Ralith> hm
16:43:16 <Ralith> cabal seems to be trying to install a non-7.6 compatible version of transformers
16:43:32 <rwbarton> on 7.6 everything is hard
16:43:33 <fryguybob> If you are on 7.6 you will need to get the sources from github.
16:43:40 <fryguybob> (for diagrams)
16:43:46 <sclv> yeah i stay off the bleeding edge these days
16:44:12 <fryguybob> https://github.com/diagrams
16:44:22 * Ralith is on arch, and wanted to update other things >_>
16:44:25 <rwbarton> i happened across this today http://hackage.haskell.org/package/craftwerk -- like diagrams with a tikz backend
16:44:40 <rwbarton> o
16:44:48 <rwbarton> does diagrams have a tikz backend?
16:45:07 <fryguybob> rwbarton: There was one that at one point, but I don't think it is up to date.
16:45:14 <rwbarton> home page for craftwerk says "no longer developed, use diagrams", so never mind
16:45:34 <Ralith> fryguybob: ugh, do I have to clone every single one of those by hand? :/
16:47:41 <fryguybob> Ralith: Not all of them...
16:47:50 <Ralith> many?
16:48:06 <arbn> Ralith: Arch moving to 7.6 was a horrible idea. :/
16:48:13 <Ralith> arbn: tell me about it
16:48:36 <arbn> Ralith: Why not downgrade and ignore that package? Then just use cabal-install?
16:49:16 <Ralith> arbn: do what now?
16:49:17 <fryguybob> active, dual-tree, monoid-extras, diagrams-core, diagrams-lib, and diagrams-cairo
16:49:33 <edwardk> arch jumped to 7.6 in advance of the platform?
16:49:45 <Ralith> much to everyone's annoyance
16:49:51 <arbn> edwardk: Yep. Arch follows stable upstream releases.
16:50:02 <arbn> edwardk: They don't package the platform anymore.
16:50:26 <simpson> Well, presumably all Arch users have already learned that Arch's maintainers are insane.
16:50:36 <edwardk> =)
16:50:47 <fryguybob> Ralith: I think monoid-extras is on hackage, so you wouldn't need that one.
16:51:07 <jrajav> A year back I made the move to the only linux distro better than Arch
16:51:09 <jrajav> OS X
16:51:13 <Ralith> fryguybob: the first two seem to be as well
16:51:24 <jrajav> Haven't looked back
16:51:37 <startling> jrajav: hahaha
16:51:44 * Ralith found it awfully awkward to get i3 running on OSX.
16:52:08 <arbn> There's an experimental project to port XMonad to OS X, at least.
16:52:10 <fryguybob> Ralith: Yes, so just the diagrams-core, -lib, and -cairo
16:52:20 <Ralith> kk
16:52:22 <Ralith> that is tractible!
16:52:28 <sclv> the platform *is* the stable upstream release of the haskell language
16:52:28 <sclv> so
16:52:28 * Ralith tries the svg backend also because hey
16:52:30 <jrajav> arbn: How is that going to work? Just another keyboard-shortcuts-for-window-moving thingy?
16:52:36 <jrajav> Because AFAIK it's impossible to get a real WM on osx
16:52:37 <sclv> somebody really needs to make that case
16:52:42 <sclv> somebody who uses arch and cares, that is :-)
16:52:43 <fryguybob> Ralith: The text on SVG isn't quite right yet.
16:52:55 <sclv> i got an old xmonad running on os x with no work
16:52:57 <Ralith> fryguybob: how not-quite-right?
16:53:05 <jrajav> sclv: In quartz?
16:53:07 <sclv> but of course it just managed my X windows, which was basically useless :-P
16:53:08 <jrajav> sclv: Or X11?
16:53:11 <jrajav> Yeah lol
16:53:20 <fryguybob> http://projects.haskell.org/diagrams/backend-tests/all-index.html
16:53:45 <jrajav> It can't even manage X windows unless you use X for the root, can it?
16:53:55 <Ralith> nice
16:54:51 <Ralith> so, mostly doesn't appear at all o.O
16:55:04 <arbn> Yeah. It's an X-only thing. So, kind of useless. :P
16:55:26 <jrajav> If you want xmonad on OSX, Slate comes pretty close
16:56:29 <fryguybob> Ralith: It is closer then it looks in that test as one issue is some quirks with default background colors and text with SVG.
16:56:49 <shachaf> Someone actually started/made some progress in porting xmonad to OS X.
16:57:05 <Nereid> fryguybob: speaking of diagrams, I made this picture with it. https://dl.dropbox.com/u/33903796/pictures/2adic.png
16:57:07 <Ralith> fryguybob: 'kay; cairo installed fine too, so whev
16:57:14 <Nereid> c:
16:58:03 <arbn> shachaf: But, as we said, XMonad only works with X. If it's managing native windows it would be some other kind of monad. :P
16:58:04 <Ralith> neat!
16:58:40 <spaceships> iMonad
16:58:44 <spaceships> ;\
16:58:48 <fryguybob> Nereid: Nice!
16:59:30 <Nereid> (you can replace the 2 in the URL with 3, 4, or 5 as well)
16:59:39 <shachaf> arbn: Yes, it's a port to Quartz.
16:59:46 <Nereid> well the idea came from this picture but yeah. http://en.wikipedia.org/w/index.php?title=File:2-adic_integers_with_dual_colorings.svg&page=1
16:59:48 <shachaf> arbn: Fortunately "X" is a very generic letter.
17:00:59 <jrajav> Quartx?
17:02:27 <sclv> QMonad
17:02:32 <Nereid> xMonad, where x is arbitrary
17:02:47 <sclv> [
17:02:47 <sclv> x
17:02:50 <sclv> [X]Monad
17:03:04 <startling> ∃x. xmonad
17:07:19 <sclv> hey man, i got a monad that rearranges windows… in your mind
17:24:12 <drchaos> can somebody suggest some exercises for learning computer programming using haskell?
17:24:34 <drchaos> I'm new to computer programming and I want to get better at it
17:24:50 <liyang> drchaos: http://projecteuler.net/ ?
17:25:22 <ski> Nereid : hm, reminds me of <http://mathlesstraveled.com/2012/10/05/factorization-diagrams/>
17:25:57 <Nereid> heh.
17:26:20 <Nereid> I guess you'd be looking at a "factorization diagram" of p^infinity then.
17:26:35 <startling> drchaos, http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
17:31:32 <Ralith> does emacs' haskell-mode have trouble with modified GHCI prompts?
17:31:37 <startling> yes
17:31:50 <startling> you need to customize the regex if you want a modified prompt
17:31:53 <rwbarton> it broke for me when I loaded a module with single quotes in the name
17:32:08 <startling> haha
17:34:56 <Ralith> what's the Right Way to customize that regex?
17:49:13 <fliip> Can anyone tell me why this doesnt work please?
17:49:14 <fliip> cp xs = foldr (\xss yss -> [[x,y] | x <- xss, y <- yss]) [] xs
17:49:46 <mauke> "doesn't work" is meaningless
17:50:08 <simpson> :t foldr (\xss yss -> [[x,y] | x <- xss, y <- yss]) []
17:50:10 <lambdabot>     Occurs check: cannot construct the infinite type: t0 = [t0]
17:50:10 <lambdabot>     In the expression: y
17:50:10 <lambdabot>     In the expression: [x, y]
17:50:39 <fliip> What does that mean?
17:50:51 <mauke> you're trying to create a list that contains itself
17:51:02 <jmcarthur> err, not quite that
17:51:03 <crdueck> how can i create a Data.Array.Repa of user defined data types that dont have unboxed instances? I see that Repa.Array takes a parameter U, B, D, V... what one should be used here?
17:51:14 <mauke> that is, something of the type [t0] where t0 is that same tye
17:51:22 <simpson> :t \xss yss -> [[x,y] | x <- xss, y <- yss]
17:51:23 <lambdabot> [t] -> [t] -> [[t]]
17:51:24 <jmcarthur> you're trying to create a type that contains itself
17:51:39 <simpson> That's what you were passing to foldr.
17:51:51 <fliip> Oh.
17:51:52 <jmcarthur> crdueck: probably V
17:52:14 <jmcarthur> crdueck: D will also work. i forget what B is.
17:52:23 <jmcarthur> crdueck: you should try to understand what they all mean
17:52:23 <simpson> :t foldr -- but this is foldr's type!
17:52:25 <lambdabot> (a -> b -> b) -> b -> [a] -> b
17:52:42 <fliip> Hmm. Ok thanks.
17:52:46 <crdueck> jmcarthur: i'm reading the haddock. It looks like V is probably correct
17:52:49 <simpson> fliip: What did you want this to do?
17:52:56 <fliip> The cartesian product of a list of lists.
17:53:09 <magicman> [t] -> [t] -> [[t]] is not a -> b -> b.
17:53:27 <jmcarthur> > sequence [[a,b,c],[d,e,f],[g,h,i]]
17:53:28 <lambdabot>   [[a,d,g],[a,d,h],[a,d,i],[a,e,g],[a,e,h],[a,e,i],[a,f,g],[a,f,h],[a,f,i],[b...
17:53:36 <fliip> Its for an assignment...
17:53:42 <simpson> Ah, of course.
17:53:42 <jmcarthur> ah
18:00:20 <ski> (.. s/is not/is not an instance of/)
18:05:58 * hackagebot snaplet-redis 0.1.0.2 - Redis support for Snap Framework  http://hackage.haskell.org/package/snaplet-redis-0.1.0.2 (DmitryDzhus)
18:15:59 * hackagebot zoom-cache 1.2.1.5 - A streamable, seekable, zoomable cache file format  http://hackage.haskell.org/package/zoom-cache-1.2.1.5 (ConradParker)
18:21:01 * hackagebot zoom-cache-pcm 0.3.0.1 - Library for zoom-cache PCM audio codecs  http://hackage.haskell.org/package/zoom-cache-pcm-0.3.0.1 (ConradParker)
18:21:03 * hackagebot zoom-cache-sndfile 1.1.0.1 - Tools for generating zoom-cache-pcm files  http://hackage.haskell.org/package/zoom-cache-sndfile-1.1.0.1 (ConradParker)
18:21:05 * hackagebot scope 0.8.0.1 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-0.8.0.1 (ConradParker)
18:21:07 * hackagebot scope-cairo 0.8.0.1 - An interactive renderer for plotting time-series data  http://hackage.haskell.org/package/scope-cairo-0.8.0.1 (ConradParker)
18:27:54 <crdueck> i have "import Data.Array.Repa (Z, (:.))" but I still cant write (Z :. foo :. bar), i need to do a qualified import and write (R.Z R.:. foo R.:. bar). what am i doing wrong here?
18:28:13 <mauke> define "cant"
18:29:29 <crdueck> mauke: "not in scope: data constructor 'Z'" etc.
18:31:16 <Jafet> You imported the type Z, but not its data constructor Z.
18:31:24 <mauke> import ... (Z(..)
18:32:17 <crdueck> Jafet, mauke: ah, thats it. I havent specifically imported data constructors like that before. thanks
18:36:07 <drchaos> ok, would somebody please tell me why this won't work?: myButLast (x:y:[])
18:36:48 <drchaos> don't tell me what will work
18:37:04 <mauke> "doesn't work" ist still meaningless
18:37:10 <mauke> s/ist/is/
18:37:32 <drchaos> lastElement.hs:6:32:
18:37:33 <drchaos>     Occurs check: cannot construct the infinite type: t0 = [t0]
18:37:34 <fliip> Finally figured it out! =)
18:37:35 <drchaos>     In the second argument of `(:)', namely `y'
18:38:22 <mauke> drchaos: because it's a type error
18:40:30 <sw2wolf> Why is GHC so slow to link an applcation ?  And when linking, my freebsd almost doesnot respond ...
18:40:52 <luite> huge number of object files
18:40:57 <mauke> is ghc doing the linking itself?
18:41:00 <luite> no
18:41:11 <mauke> well then
18:41:33 <drchaos> mauke: I want a solution that doesn't use any functions out of Prelude
18:41:36 <drchaos> that's my goal
18:42:11 <sw2wolf> it takes so long to `cabal install xxx` and it seems linking is a problem
18:42:34 <mauke> drchaos: a solution to what?
18:42:52 <sclv> ghc doesn't link. it uses the system linker.
18:42:57 <drchaos> The problem: Find the last but one element of a list
18:43:02 <bxx> drchaos what's the type of x and y?
18:43:08 <sclv> there are lots of symbols to link in generated files however
18:43:16 <sclv> and the system linker has a hard time of it.
18:43:26 <drchaos> bxx: x and y's type could be different, it's a list
18:43:31 <mauke> drchaos: ok, go ahead
18:43:38 <mauke> you have my permission
18:44:04 <geekosaur> what?
18:44:44 <sw2wolf> <sclv> I know it uses "ld", but why is C app using "ld"  so fast ?
18:45:12 <sclv> lots fewer symbols, if i recall.
18:45:15 <geekosaur> C apps are usually a lot simplet
18:45:26 <geekosaur> try C++ apps that use lots of templates sometime; same issues
18:45:40 <sclv> yep -- ld is just sort of terrible for complex tasks.
18:45:44 <sclv> gold is reputedly much better.
18:45:55 <sclv> but still a bit too experimental to trust for general use.
18:46:19 <sw2wolf> Can i use gold instead of ld in freebsd ?
18:46:36 <simpson> Nope.
18:46:42 <simpson> It's a GNU thing.
18:47:07 <shachaf> G-nope.
18:47:08 <geekosaur> ummm
18:47:10 <sw2wolf> i see now
18:47:17 <geekosaur> so is binutils
18:47:52 <simpson> geekosaur: BSD has their own entire toolchain, including their own ld.
18:48:07 <geekosaur> simpson, I used to run freebsd
18:48:17 <geekosaur> they do not do their own binutils, or their own bsd-licensed gcc
18:48:21 <geekosaur> (oxymoron)
18:48:31 <simpson> geekosaur: Okay, okay, you *can* use GNU stuff on BSD. But I don't know many BSDers that do.
18:48:41 <shachaf> http://wiki.freebsd.org/BuildingFreeBSDWithClang indicates that gold is usable.
18:48:52 <shachaf> simpson: What C compiler do they use?
18:48:52 <rwbarton> is there a slick lens-y way to emulate a Map with a default value? so that I can try to update a field of a record stored in a Map and if it didn't exist it gets populated with a default first
18:48:57 <geekosaur> there's some complex licensing issues involved, I grant, but a flat "it's gnu it's verboten" does not fly
18:49:04 <shachaf> Other than clang as of recently.
18:49:11 <simpson> shachaf: Out of the people that I know, they're all fans of clang.
18:49:16 <geekosaur> clang is still highly experimental
18:49:31 <geekosaur> and last I checked, largeish parts of base still didn't work if built with it
18:49:49 <sw2wolf> clang can build kernel but some ports not work
18:49:52 <edwardk> not really. you can probably play a game with (<|>) in an update
18:50:05 <rwbarton> interesting
18:50:55 <edwardk> if you think about it, i can't make something like that a legal lens in its own right, so its limited to being a combinator you could apply
18:51:00 <rwbarton> yeah
18:51:35 <edwardk> the lens laws are pretty handy for helping figure out which should be which, if nothing else ;)
18:51:37 <rwbarton> hm
18:52:36 <rwbarton> can I cheat maybe with an iso between Maybe X and X which sends Nothing to the default value
18:53:06 <edwardk> you could cheat. i'd probably frown at you, but i can't stop you ;)
18:55:21 <drchaos> mauke: can this myButLast function be implemented entirely using pattern matching?
18:55:24 <edwardk> it may be a little more principled if you mapped the value back to Nothing if it matched.
18:55:34 <drchaos> It solves this problem: Find the last but one element of a list
18:55:39 <mauke> drchaos: well, not entirely
18:55:47 <shachaf> Whatever the right solution to taking will be, it'll probably solve dropping too.
18:55:51 <mauke> drchaos: you'll also need function calls and recursion
18:56:06 <shachaf> But I'll put the code back for now.
18:56:44 <shachaf> Your "Foo" type is a bit like splittingAt
18:57:17 <edwardk> yeah
18:58:03 <drchaos> mauke: my problem is I have overlapped pattern matches
18:58:26 <mauke> drchaos: remove them
18:59:44 <simpson> drchaos: Remember that Haskell attempts pattern matches in the order that you define them.
18:59:55 <Jafet> :t head.head.snd.break(null.drop 2).tails
18:59:56 <lambdabot> [a] -> a
19:00:37 <mauke> needs more zip`ap`tail
19:00:49 <drchaos> *Main> myButLast [1,2]
19:00:51 <drchaos> 2
19:01:04 <shachaf> @ty last.last.init.inits
19:01:06 <lambdabot> [b] -> b
19:01:29 <simpson> drchaos: hpaste.org your code?
19:01:33 <mauke> :t fst.last.(zip`ap`tail)
19:01:34 <lambdabot> [b] -> b
19:02:06 <mauke> :t zipWith const <*> tail
19:02:08 <lambdabot> [b] -> [b]
19:03:35 <hpaste> drchaos pasted “pattern matching fail” at http://hpaste.org/77900
19:03:43 <Jafet> :t (fst.last).:ap zip.drop
19:03:44 <lambdabot> Int -> [b] -> b
19:04:18 <mauke> line 6 is an infinite loop
19:04:24 <mauke> x = x
19:04:25 <shachaf> I bet rwbarton would like to solve the taking problem.
19:04:36 <mauke> line 7 looks plain wrong
19:04:45 <rwbarton> i have my own lens problems!
19:04:49 <edwardk> ?
19:04:54 <rwbarton> (the one above)
19:05:01 <rwbarton> (got distracted for a bit)
19:05:01 <edwardk> ah =)
19:05:19 <shachaf> rwbarton: Don't mind edwardk, he just has a hilight on lens.
19:05:26 <shachaf> He pops in whenever someone mentions it.
19:05:29 <edwardk> hah
19:05:58 <rwbarton> edwardk: that sounds more principled but also more likely to be wrong :)
19:06:33 <edwardk> well, you need to decide what you want to do when the values match. do you suppress the entry and go back to the 'background' value?
19:06:37 <drchaos> mauke: I can see why line 6 is an infinite loop; to fix it, just change "= myButLast (x:xs)" to "myButLast xs" on that line
19:06:43 <edwardk> if so, then the principled version is the right one ;)
19:06:52 <rwbarton> i don't want to delete the value from the map!
19:06:57 <rwbarton> just leave it as-is
19:07:02 <mauke> drchaos: do you see why line 7 is wrong?
19:07:05 <shachaf> rwbarton: Is it a Map with a default value in general? Or just for this one operation?
19:07:15 <rwbarton> it pretty much is in general, I guess
19:07:17 <edwardk> then in that case you're stuck with your funny fromMaybe iso =P
19:07:29 <drchaos> mauke: no
19:07:30 <rwbarton> let me think a bit
19:07:48 <drchaos> I would hope that one with more experience would enlighten me
19:07:54 <shachaf> In that case there shouldn't be any harm in deleting a value that matches it, should there?
19:08:17 <mauke> drchaos: (x:y:[]) is equivalent to [x,y]
19:08:31 <drchaos> OH
19:08:36 <shachaf> I think TotalMap has an explicit operation to do that.
19:09:42 <toddaaro> anyone around know how to install hsc2hs? I can't get it to work. I instead get an error about ../../includes/ghcconfig.h not being found: http://hpaste.org/77901
19:09:46 <hpaste> drchaos annotated “pattern matching fail” with “pattern matching fail (annotation)” at http://hpaste.org/77900#a77902
19:10:05 <drchaos> mauke: the fix is there
19:10:18 <drchaos> try it on lists of lengths 1, 2, 3, and 4
19:10:38 <drchaos> the function returns the second to last element every time
19:11:49 <rwbarton> "a lens into a TotalMap" is at least approximately what I want
19:12:00 <mauke> drchaos: no, it doesn't
19:12:10 <mauke> myButLast [1] returns 1
19:12:13 <geekosaur> toddaaro, you shouldn't be trying to install it by itself; it only buuilds properly as part of a ghc source tree.  (I am not fond of the idea of having parts of ghc in hackage as separate packages, it causes lots of weird problems when people try to install e.gtemplate haskell)
19:12:29 <shachaf> drchaos: Try myButLast [1,2]
19:13:00 <drchaos> mauke: should it return [] in that case? I think not.
19:13:19 <geekosaur> if your ghc came from a vendor package, install the vendor hsc2hs package.  If it came from a haskell.org binary distribution, something is wrong with it; reinstall
19:13:56 <mauke> drchaos: it can't return [], that would be a type error
19:14:24 <shachaf> mauke: No it wouldn't, since there's no type annotation.
19:15:08 <mauke> heh
19:15:22 <mauke> shachaf: how would that make myButLast [1] work?
19:15:26 <toddaaro> geekosaur: ok thanks, that makes sense. I must have a path problem then
19:15:39 <Jafet> You just need the appropriate instance
19:15:39 <toddaaro> geekosaur: (trying to get 12 versions of ghc at the same time for a Jenkins server)
19:15:53 <shachaf> mauke: What Jafet said.
19:17:19 <edwardk> rwbarton: the problem i see is that its not really a lens if it can't get you back to the state you started in.
19:17:25 <mauke> "just" :-)
19:17:40 <shachaf> instance Num [a] where fromInteger n = genericReplicate n undefined
19:17:41 <rwbarton> right
19:17:49 <rwbarton> I would settle for some combinator on a Setter
19:18:03 <rwbarton> which is what I am attempting to write right now
19:19:28 <mauke> shachaf: that doesn't look like the Applicative instance
19:19:44 <rwbarton> @djinn-add type Setter s t a b = (a -> b) -> (s -> t)
19:19:48 <rwbarton> will this work
19:19:50 <shachaf> Applicative instance?
19:20:16 <rwbarton> @djinn a -> Setter (Maybe a) (Maybe b) a b
19:20:17 <lambdabot> f a b c =
19:20:17 <lambdabot>     case c of
19:20:17 <lambdabot>     Nothing -> Nothing
19:20:17 <lambdabot>     Just _ -> Just (b a)
19:20:25 <rwbarton> hehe
19:20:52 <shachaf> @ty mapped :: Setter (Maybe a) (Maybe b) a b
19:20:54 <lambdabot> Settable f => (a -> f b) -> Maybe a -> f (Maybe b)
19:21:11 <rwbarton> it wasn't the one i wanted sadly
19:21:15 <mauke> shachaf: instance (Num a, Applicative f) => Num (f a) where fromInteger = pure . fromInteger
19:21:17 <rwbarton> and not very surprisingly
19:21:27 <shachaf> rwbarton: There's only one valid Setter of that type, isn't there?
19:21:39 <shachaf> mauke: I guess that works.
19:21:57 <shachaf> I was thinking of the "lazy nats" instance for [()]
19:22:32 <mauke> (+) = liftA2 (+), etc
19:22:53 <shachaf> (+) = (++)
19:24:12 <shapr> mars-92: oh hai!
19:24:37 <rwbarton> shachaf: how do you feel about this one: defaulted :: a -> Setter (Maybe a) (Maybe b) a b; defaulted def = sets $ \f -> fmap f . (<|> Just def)
19:24:59 <Jafet> instance Num [a] where {}
19:25:00 <TadekMocarzzzz> i hate php co,mpany niggers, why they made something that shi,tty like Bi,tch PHP nig,ger
19:25:01 <TadekMocarzzzz> why php company cant be holocausted just like the jews?
19:25:04 <TadekMocarzzzz> that would be great for world, just like holocaust of jews was
19:25:08 <TadekMocarzzzz> am i right?
19:25:28 --- mode: ChanServ set +o shapr
19:25:34 <TadekMocarzzzz> banhammer
19:25:34 --- kick: TadekMocarzzzz was kicked by shapr (Kicked by shapr)
19:25:42 <shachaf> rwbarton: Well, it breaks the laws.
19:26:27 --- mode: ChanServ set +o mauke
19:26:27 --- mode: mauke set +b $a:JohnBlack
19:26:28 <rwbarton> I'm confused by the discussion of laws on Control.Lens.Setter
19:26:42 <shapr> mauke: thanks
19:26:49 <shachaf> rwbarton: Should be the same as the Functor laws?
19:27:27 <edwardk> rwbarton: over l f . over l g = over l (f . g); over l id = id
19:27:37 <edwardk> they are just the functor laws
19:27:40 <rwbarton> I guess I stopped reading after the sentence that began "The only"
19:28:27 --- mode: mauke set -o mauke
19:28:29 <edwardk> defaulted fails the latter definitely
19:29:17 <shachaf> I think it'd be OK with edwardk's suggestion of mapping back to Nothing, though.
19:29:30 <shachaf> Since then it's just an isomorphism that swaps two elements.
19:30:03 <rwbarton> but i can't imagine that ever being too useful
19:30:09 <shachaf> Why not?
19:30:18 <shachaf> If your Map has a global default value, you shouldn't care about deleting elements.
19:30:34 <shachaf> Because you know that when you view it you'll get the original value again.
19:31:10 <rwbarton> i'm very confused
19:31:55 <shachaf> Let's say you have a map of counters like {"foo": 5, "bar": 3}
19:32:08 <shachaf> Your default value is 0, so you can always just increment.
19:32:17 <shachaf> If you decrement a counter to 0, then you might as well delete it from the map entirely.
19:32:59 * shachaf might be talking about a completely different thing from what rwbarton is talking about.
19:33:10 <rwbarton> i'm sure it's not *completely* different :P
19:33:37 <shachaf> Maybe I should ask what you're trying to do instead of guessing!
19:33:52 <shachaf> At least what I described ought to give you a valid lens, I think.
19:34:38 <rwbarton> so basically you're saying that I pretend a missing element in the map means 0, and if I have an actual 0 in the map, then that means the element "doesn't exist" somehow, and I presumably want to arrange that that never happens
19:34:57 <rwbarton> I guess maybe this will work as long as I always access the map with this funny lens
19:35:14 <shachaf> Well, that's what it would mean for the default value to be "global" to the map.
19:35:28 <rwbarton> yeah, because then M.empty is the "all-0 map"
19:35:32 <shachaf> Right.
19:36:21 <rwbarton> okay
19:36:36 <rwbarton> I think before, I was confused because I didn't consider that the value I write back to the map will go through the inverse iso
19:36:42 <rwbarton> or something like that
19:36:44 <copumpkin> I'm not a fan of TMaps
19:36:46 <liyang> Maybe you might be interested in http://hackage.haskell.org/package/total-map or http://hackage.haskell.org/package/enumfun
19:37:05 <edwardk> that is basicaly what i was offfering above with the isomorphism between Maybe (a sans 0) and a    -- or some other element than 0
19:37:07 <rwbarton> I just looked at the former, but it doesn't expose very much stuff
19:37:17 <rwbarton> edwardk: yeah, I realize that now :)
19:37:31 <shachaf> rwbarton: One of the things you lose when you do this "properly" is the ability to iterate the keys.
19:37:32 <rwbarton> for example I would like to be able to enumerate all the non-default entries in the map
19:37:32 <edwardk> then at k <. non 0    -- gives you the map you want
19:37:39 <shachaf> Because every key has a value.
19:37:51 <edwardk> all the non-default entries becomes easy. just traverse
19:37:52 <rwbarton> well I can do it manually
19:37:58 <rwbarton> or yeah ,isn't that it
19:37:58 <shachaf> Right.
19:37:58 <edwardk> =)
19:38:00 <liyang> You can pretend Maybe k is the key.
19:39:32 <liyang> as the 'val' SimpleIndexedLens does in enumfun HEAD: https://github.com/liyang/enumfun/blob/master/include/enumfun.inc
19:39:41 <rwbarton> funny, so does that mean a traversal cannot change whether a key is non-default
19:39:54 <edwardk> :t guard
19:39:56 <lambdabot> MonadPlus m => Bool -> m ()
19:39:57 <rwbarton> or is this me getting confused again
19:40:05 <shachaf> liyang: Ah, delicious CPP.
19:40:48 <edwardk> non v f = go <$> f (fromMaybe v) where go v' | v' == v = Nothing; | otherwise = Just v'
19:41:09 <edwardk> :t let non v f = go <$> f (fromMaybe v) where go v' = if v' == v then Nothing else Just v' in non
19:41:11 <lambdabot> (Eq a, Functor f) => a -> ((Maybe a -> a) -> f a) -> f (Maybe a)
19:41:17 <edwardk> erm
19:41:32 <edwardk> :t let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in non
19:41:34 <lambdabot> (Eq a, Functor f) => a -> (a -> f a) -> Maybe a -> f (Maybe a)
19:41:38 <edwardk> better
19:42:01 <edwardk> :t let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in \k -> at k <. non 0
19:42:03 <lambdabot> (Eq v, Functor f, Num v, At k1 m, Indexed k1 k) => k1 -> k (v -> f v) (m v -> f (m v))
19:42:20 <shachaf> edwardk: Pushed.
19:42:58 <edwardk> :t let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in M.fromList [(1,2)]^.at 1.non 0
19:43:00 <lambdabot> (Eq a, Num a) => a
19:43:05 <edwardk> > let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in M.fromList [(1,2)]^.at 1.non 0
19:43:08 <lambdabot>   2
19:43:11 <edwardk> > let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in M.fromList [(1,2)]^.at 2.non 0
19:43:13 <lambdabot>   0
19:43:27 <edwardk> > let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in at 2.non 0 .~ 2 $ M.fromList [(1,2)]
19:43:30 <lambdabot>   fromList [(1,2),(2,2)]
19:43:34 <edwardk> > let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in at 2.non 0 .~ 0 $ M.fromList [(1,2)]
19:43:36 <lambdabot>   fromList [(1,2)]
19:43:40 <edwardk> > let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in at 1.non 0 .~ 0 $ M.fromList [(1,2)]
19:43:43 <lambdabot>   fromList []
19:43:45 <edwardk> here
19:43:45 <rwbarton> > let non v f s = go <$> f (fromMaybe v s) where go v' = if v' == v then Nothing else Just v' in M.fromList [(1,0)]^.at 2.non 0
19:43:48 <lambdabot>   0
19:44:17 <edwardk> you should avoid making maps that contain the sentinel value. because it'll delete the key from it
19:44:20 * copumpkin coughs
19:44:46 <edwardk> copumpkin: i'm not either
19:45:31 <edwardk> rwbarton: this basically gives you a way to take a map where the values are all non-zero, and access elements in such a way that preserves that invariant. treating missing keys as 0s
19:46:19 <edwardk> shachaf: thanks =)
19:46:42 <rwbarton> but non v is not really a lens, right
19:47:17 <edwardk> "non v" it is a lens as long as you consider its domain to be restricted to Maybe (values sans v)
19:47:17 <rwbarton> how would the SimpleIso (Maybe a) (Maybe a) work
19:47:23 <rwbarton> okay right
19:47:47 <rwbarton> I guess that is better than what I had been doing
19:48:04 <shachaf> It'd just be the isomorphism [Just a, Just b, Just z, Nothing] <-> [Just a, Just b, Nothing, Just z], or something like that, wouldn't it?
19:48:10 <rwbarton> right
19:48:17 <shachaf> Er, never mind.
19:48:31 <shachaf> Well, double never mind.
19:49:01 <edwardk> the benefit of the non version is you can just update and read with ^. and .~ without fiddling with Just
19:49:06 <rwbarton> yeah
19:49:12 <edwardk> and you can walk the non-default keys using traverse or itraversed, etc.
19:49:32 <shachaf> copumpkin: Why don't you like tmaps?
19:49:55 <copumpkin> feel kind of inelegant, despite being more elegant in some ways than maps
19:54:21 <rwbarton> holy crap makeLenses loads a lot of packages at compile time
19:54:37 <edwardk> you get every dependency of your current package
19:54:39 <rwbarton> hmm, it loaded everything my program uses apparently
19:54:39 <rwbarton> yeah
19:54:45 <edwardk> i can't trim that list sadly
19:55:19 <shachaf> edwardk gotta have his semigroupoids
19:55:23 <edwardk> i'm thinking about making a printLenses command you can use from ghci or something to get code you can paste in case you want to avoid it
19:55:39 <edwardk> semigroupoids is used by comonad, and we have Context and Bazaar
19:56:07 <shachaf> Are the comonad instances for those ever actually used?
19:56:17 <edwardk> actually just semigroups is used by comonad, but we have the comonad-transformers versions
19:56:26 <yaw> @djinn a -> a
19:56:26 <lambdabot> f a = a
19:56:30 <edwardk> we give back Context comonads to the user in Plated
19:56:35 <shachaf> True.
19:56:37 <copumpkin> shachaf: TMaps feel like adding Maybe to a type to make it a Monoid
19:56:52 <copumpkin> make Map an Applicative in the same way :P
19:56:56 <edwardk> i preferred to give back an actual comonadic value than the crappy (b, b -> a)
19:56:56 <shachaf> copumpkin: Right.
19:57:29 <rwbarton> it's sort of like subtracting Maybe from a type
19:57:32 <shachaf> copumpkin: On the other hand, Map is like adding mempty = undefined to a type to make it a monoid.
19:57:52 <copumpkin> shachaf: why not just a -> Maybe b?
19:57:52 <dmwit> Map's Monoid instance is so bad =(
19:57:56 <copumpkin> dmwit: yeah it is
19:58:04 <copumpkin> it's frustrating because it doesn't have to be
19:58:11 * dmwit nods sadly
19:58:28 <copumpkin> also frustrating because it's really hard to determine how much of hackage depends on it
19:58:31 <shachaf> copumpkin: Well, OK.
19:58:34 <copumpkin> because instances are so invisible
19:58:42 <shachaf> What's Map's Monoid instance?
19:58:47 <dibblego> union innit?
19:58:57 <rwbarton> just build everything on hackage, then delete the instance and build everything again
19:59:02 <copumpkin> rwbarton: :P
19:59:15 <rwbarton> in theory this is easy
19:59:16 <rwbarton> right??
19:59:19 <copumpkin> yeah
19:59:21 <copumpkin> just a pain
19:59:25 <rwbarton> you can set up your own hackage server
19:59:27 <copumpkin> it'd be nice to just grep
19:59:28 <edwardk> i use the union monoid for map fairly often
19:59:32 <dmwit> Easy but time-consuming.
19:59:34 * copumpkin slaps edwardk 
19:59:45 <dmwit> edwardk: You use it in a way incompatible with unionWith mappend?
19:59:52 <copumpkin> he'd have to map First over it
19:59:53 <copumpkin> or something
20:00:00 <edwardk> sadly, yes
20:00:05 <dmwit> ick
20:01:22 <shachaf> copumpkin: Clearly the solution is to make a TMap inspired by base's Monoid (Maybe a) instance.
20:01:28 <copumpkin> edwardk is why we can't have nice things
20:01:48 <dmwit> unionWith whateverTheSemigroupOperationIsCalled, I guess
20:01:53 <edwardk> mind you i could just replace the few places with `union` ;)
20:02:04 <edwardk> dmwit: unionWith (<>)
20:02:11 <shachaf> @ty (<>)
20:02:13 <lambdabot> Monoid m => m -> m -> m
20:02:17 <shachaf> :-(
20:02:26 <dmwit> close enough, ship it
20:02:30 <edwardk> f you import Data.Semigroup (<>) :: Semigroup m => m -> m -> m  -- and all the other stuff from Monoid comes into scope
20:02:37 <edwardk> just import that rather than Data.Monoid
20:02:52 <crdueck> is there a Data.Array.Repa function that returns the shape of a Repa array?
20:03:09 <dmwit> Isn't the shape tracked in the type?
20:03:27 <rwbarton> the dimensions are not
20:03:46 <rwbarton> extent
20:04:04 <shachaf> shapr: You're tracked in the type system? Have you been spending too much time with Oleg?
20:04:05 <crdueck> yes the shape is, but i need the dimensions. I found listOfShape which takes a shape and gives the dimensions
20:04:29 <rwbarton> crdueck, it's called extent
20:04:38 <rwbarton> unless i misunderstood what you are looking for
20:04:44 <crdueck> rwbarton: that's it, thanks
20:12:06 <rwbarton> is there a class any where for "functor that is a module over another (applicative) functor"
20:12:17 <rwbarton> f (a -> b) -> g a -> g b
20:21:18 <aa_> hi everyone, for a simple linux only gui app: gtk or write a web app
20:21:19 <aa_> ?
20:22:15 <clahey_> Are there repa lenses?
20:22:27 <edwardk> not by me.
20:24:50 <shachaf> So writing a version of taking that works with Fold doesn't seem that tricky, and there's already one that sort of works with Traversal.
20:24:55 <shachaf> But doing both is annoying. :-(
20:24:55 <clahey_> edwardk, Would they be acceptable for the lens package?
20:25:26 <edwardk> lens limits its scope to the platform and the packages it needs internally, but a repa-lens package would be fine
20:25:43 <applicative> aa_:  often people say 'write a web app' but they are precisely not thinking 'simple linux only'
20:26:00 <edwardk> there is already an aeson-lens package for instance
20:26:18 <clahey_> edwardk, I think there could be some cool slice lenses.
20:26:21 <clahey_> Maybe replicate.
20:26:32 <edwardk> :t replicated
20:26:34 <lambdabot> (Applicative f, Gettable f) => Int -> (a -> f a) -> a -> f a
20:26:49 <edwardk> 'h'^.replicated 4
20:26:53 <edwardk> > 'h'^.replicated 4
20:26:55 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
20:26:56 <lambdabot>    arising from a use o...
20:26:59 <edwardk> > 'h'^..replicated 4
20:27:02 <lambdabot>   "hhhh"
20:28:11 <arbn> Is there a way to check record construction at compile-time?
20:28:25 <clahey_> Well, that wouldn't work for repa's replicate function.
20:28:33 <arbn> The "Missing field in record construction" error is annoying to get so late.
20:28:51 <edwardk> sure
20:29:16 <edwardk> i meant sure to clahey_  not to arbn, sorry ;)
20:29:55 <clahey_> Oh, the function is extend.
20:30:11 <aa_> applicative: thanks, I guess it could even be curses
20:30:37 <aa_> just wondering if web frameworks have come on so far these days that a web app would just be easier, despite all the pain
20:30:46 <copumpkin> arbn: does -Wall help?
20:30:53 <copumpkin> arbn: I seem to remember there being something
20:31:23 <copumpkin> -fwarn-incomplete-record-updates
20:31:38 <shachaf> copumpkin: Incomplete *updates*?
20:31:43 <copumpkin> beats me
20:31:45 <clahey_> Okay.  So figuring out the type for extended is going to be a test of my master of lenses.
20:31:50 <shachaf> Oh, when it could fail.
20:31:55 <shachaf> As in sum types.
20:32:08 <clahey_> mastery*
20:32:24 <copumpkin> lol, -fwarn-dodgy-foreign-imports
20:32:27 <copumpkin> nice warning names
20:32:28 <clahey_> It's probably a Getter, but not a Setter.
20:32:51 <copumpkin> aha, -fwarn-missing-fields
20:32:52 <copumpkin> arbn: !
20:32:57 <shachaf> clahey_: The usual name for things that are only Getters is "function", isn't it? :-)
20:33:26 <clahey_> shachaf, Yeah, true.
20:33:41 <arbn> copumpkin: Thanks!
20:33:52 <clahey_> I'm not sure how to use a function in a lens chain.
20:33:58 <clahey_> But it's time for me to go to bed.  Have a good night all.
20:34:12 <edwardk> :t to
20:34:13 <lambdabot> Gettable f => (s -> a) -> (a -> f a) -> s -> f s
20:34:47 <shachaf> > (1,2)^._1.to (+1)
20:34:50 <lambdabot>   2
20:46:54 <applicative> aa_: not sure why I thought of it, but here is a fairly complicated terminal app using ansi-terminal https://bitbucket.org/paradoxiology/hreddit/  He was just learning haskell, so I helped him a little.  I thought it was fairly pleasant, despite it's obnoxious purpose.
20:47:14 <applicative> its obnoxious purpose
20:51:02 * hackagebot Extra 1.45 - A grab bag of modules.  http://hackage.haskell.org/package/Extra-1.45 (DavidFox)
20:52:43 <sw17ch> .
20:53:27 <shachaf> edwardk: Someone has outdone you!
20:53:30 <shachaf> everything-extras
20:53:44 <edwardk> hahahaha
20:54:14 <shachaf> This looks like a pretty odd assortment.
20:54:30 <shachaf> Even category-extras didn't have an SSH module.
20:54:38 <copumpkin> lol
20:54:46 <edwardk> yeah. much to my chagrin. i had so much to say about the category of TLS handshakes
20:55:34 <shachaf> "Category: Unclassified"
20:55:59 <shachaf> I guess the real cryptography modules are all in Category: Classified
20:55:59 <rwbarton> the Classified packages are much more interesting
20:56:06 <geekosaur> "yes"
20:56:15 <edwardk> shachaf: =)
20:58:37 * applicative prepares his package MissingExtras
20:59:22 <aa_> applicative: thanks
20:59:30 <applicative> System.Debian.ControlParser together with Data.Either.Utils in missingh wasn't enough
21:01:09 <shachaf> edwardk: The issue is that we want to stop early in the Fold case, but not in the Traversal case.
21:01:40 <edwardk> sounds about right. we either want to stop or just switch modes irreversibly
21:02:03 <shachaf> Right.
21:02:11 <edwardk> which means doing some kind of match that is just enough to determine if we've switched modes
21:02:21 <shachaf> I don't think that's a problem that any lens code has encountered before.
21:02:44 <shachaf> The laziness thing was good enough for holesOf because it wants to keep going no matter what.
21:02:58 <edwardk> you're right. we keep solving a bunch of odd problems though, so this one should eventually fall ;)
21:03:17 <shachaf> Yep.
21:03:27 <edwardk> eventually i want to make it so we can use taking and dropping, etc. on indexed traversals as well
21:03:59 <edwardk> which may mean adding something else to the Indexed class, etc.
21:05:14 <monodromy> I'm trying to simplify one small thing I'm doing to avoid having to write out like 16 separate cases; it's to do with existential quantification
21:05:22 <monodromy> I put up a paste at http://hpaste.org/77905 that shows the idea
21:05:39 <shachaf> monodromy: The answer might be "don't use existential quantification"
21:05:50 <monodromy> I know it's not turning out to be very nice but after struggling for ages this is the only way I've seen to make my whole program work
21:06:02 <shachaf> @where antipattern
21:06:03 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
21:06:10 <shachaf> Did you see that article?
21:06:16 <shachaf> There's also a discussion in the FAQ that links to it
21:06:18 <shachaf> @where faq
21:06:18 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
21:06:47 <shachaf> monodromy: In the end, you're going to have to map the string «"a"» to the value «A» *somehow*.
21:07:13 <shachaf> But depending on whatever it is you're actually doing, there might be a nice way to express it.
21:07:41 <monodromy> Yeah I realise that snippet isn't actually very helpful in saying what I actually want to do, I'll give it another go
21:07:46 <monodromy> sorry
21:07:56 <shachaf> monodromy: You should still read the article. :-)
21:08:16 <monodromy> yeah I will
21:08:22 <monodromy> but I've been struggling with this thing I've been writing for so long
21:08:37 <shachaf> The question is whether a type class is really the thing you want in the first place.
21:08:47 <monodromy> I actually just jumped up and down in joy when I finally got it working after struggling for hours and hours
21:09:06 <shachaf> Type classes are nice sometimes but they put you in the position of having to make new types for things.
21:09:07 <monodromy> :P
21:12:15 <isomorphic> Should I be able to use a variable bound by a "<-" in a where statement?
21:12:31 <shachaf> "what's a where statement?"
21:12:39 <shachaf> isomorphic: "where" is associated with an "=" or "->"
21:14:24 <isomorphic> Hrmm.. So, I have a do-block -  it has a line that says  a <-  someFunction
21:14:52 <isomorphic> can I use the 'a' in a subsequent where clause - eg: where x = a  ?
21:15:03 <monodromy> ok here's the more informative version of what my problem is: http://hpaste.org/77906
21:15:20 <monodromy> here I'd like a way to not have to write all 3*2 cases, just say 3+2 or something
21:15:47 <shachaf> monodromy: OK, I think everything I said still holds.
21:21:11 <monodromy> I'm not sure though
21:21:32 <shachaf> I still don't know what you're actually trying to do. :-)
21:21:38 <monodromy> yeah sorry
21:22:05 <monodromy> but in any case I'm going to need some sort of function like this that takes in various inputs and makes up some type
21:22:15 <monodromy> I think; existential quantification or not
21:22:23 <shachaf> I don't know if that's true.
21:23:50 <monodromy> I think it is; I want to parse some type in some type class (e.g. let's say Num), e.g. "int" gives me Int, "double" gives me Double etc
21:24:01 <monodromy> and then I want to do that again with another type class etc etc
21:24:15 <shachaf> That sounds universal, not existential.
21:24:20 <shachaf> Are your types actually Int and Double?
21:24:27 <monodromy> and I want to avoid writing out every case, hopefully like in my hpaste example
21:24:28 <shachaf> Where does AnyFoo come into it?
21:25:09 <monodromy> e.g. if I say "x" goes to X, "y" goes to "Y", "a goes to A" etc I can just write down a small function that makes it so that ("a", "x") goes to A X and ("b","y") goes to B Y
21:25:11 <Ralith> anyone here familiar with diagrams?
21:25:26 <Ralith> nvm
21:25:28 <monodromy> well I have many types involved shachaf in my program
21:25:33 <shachaf> Ralith: As in byorgey's thing?
21:25:38 <shachaf> Ralith: I bet the people in #diagrams are. :-)
21:26:00 <monodromy> but uhh yeah in one intsance I do want to parse some element of some type in Num, but changing the type depending on the result of the parse
21:26:01 <Ralith> a whole channel, eh?
21:26:02 <shachaf> many types involved shachaf, certainly.
21:26:29 <shachaf> monodromy: There are a bunch of questions but I've asked some of them and linked you to articles that ask others.
21:26:37 <shachaf> 21:24 <shachaf> Where does AnyFoo come into it?
21:26:42 <shachaf> What is AnyFoo, really?
21:26:45 <shachaf> I mean, what does it let you do?
21:27:07 <monodromy> I'm just using AnyFoo to actually be able to write down the type of my helper function
21:27:35 <shachaf> I'm not encouraging you to mess with your types just for the sake of making them fit into Haskell.
21:27:46 <shachaf> I'm encouraging you to think about what your program really is.
21:28:35 <monodromy> well ultimately given that for instance I'll only ever write finitely many cases for that thing with parsing something with type in Num, I could write some huge disjoint union type instead
21:28:42 <monodromy> but then that seems even more clunky and more annoying to extend
21:29:34 <shachaf> "the expression problem" may be another relevant term
21:29:38 <monodromy> it does seem to me I want something that parses something of a different type depending on various information in the parse, and the only thing I know at the end is that it's turned something in some type class
21:29:44 <shachaf> Did you read that article I linked to?
21:29:50 <monodromy> so that seemed to me to be exactly the type I want at the end
21:30:08 <monodromy> I did read it, I'm not sure I can claim to have fully understood the point it was making
21:30:20 <shachaf> OK, let's start with a simpler example.
21:30:32 <shachaf> "data Foo = forall a. Show a => Foo a" is another existential type.
21:30:39 <shachaf> It's pointless.
21:30:55 <monodromy> sure
21:31:19 <shachaf> OK.
21:31:38 <shachaf> Now, since you agree that some existential types are pointless and others aren't, please tell me why yours isn't. :-)
21:31:47 <shachaf> (This will involve revealing some information about your specific type class.)
21:32:40 <monodromy> well
21:32:48 <monodromy> is
21:33:12 <monodromy> "data Bar = forall a. Num a => Bar a" useless?
21:33:29 <Nereid> yes
21:34:04 <monodromy> why?
21:34:16 <shachaf> Here, let me give you a Bar
21:34:17 <shachaf> x :: Bar
21:34:21 <shachaf> What can you do with x?
21:34:38 <copumpkin> show it, up until recently!
21:35:00 <shachaf> No longer, copumpkin. The good times are over.
21:35:08 <monodromy> I can add any integer to it?
21:35:22 <Nereid> and then what?
21:35:26 <monodromy> not a lot for sure
21:35:37 <copumpkin> monodromy: you can multiply it by itself, and test it equal to itself
21:35:39 <Nereid> you can't do anything with the result
21:35:42 <copumpkin> and add it to itself!
21:35:46 <Nereid> copumpkin: you can't test it equal anymore!
21:35:56 <copumpkin> well yeah :P
21:36:09 <Nereid> monochrom: the Num typeclass has no methods for taking a Num value and giving you some value of a concrete type
21:36:21 <copumpkin> monochrom probably knows that
21:36:26 <Nereid> monochrom: so there is literally nothing you can do with exists a. Num a other than make more of them
21:37:11 <shachaf> copumpkin: Eh. What does monochrom know?
21:37:22 <Nereid> meanwhile
21:37:22 <shachaf> He hasn't even spoken up in this conversation.
21:37:45 <Nereid> exists a. Show a is also pretty useless
21:38:18 <copumpkin> well, it's a tad more useful
21:38:22 <Nereid> since all you can do is show it, so you may as well just have a string
21:38:26 <Nereid> (well, except that showsPrec exists and ...)
21:38:29 <copumpkin> before, when Num implied Eq
21:38:35 <copumpkin> you could actually do something with an existential Num
21:38:40 <Nereid> you can't compare two of them
21:38:42 <copumpkin> which is, inject Integers in and compare them equal
21:38:44 <copumpkin> :P
21:38:45 <Nereid> because you don't know they came from the same type
21:38:49 <copumpkin> is it equal to 5?
21:38:51 <copumpkin> how about to 6?
21:38:53 <copumpkin> what about 7?
21:38:55 <copumpkin> :P
21:38:56 <Nereid> oh you can do that.
21:38:57 <Nereid> yeah.
21:39:04 <copumpkin> really useful
21:39:20 <monodromy> I guess ultimately the reasons I am using somewhat similarly silly types
21:39:21 <Nereid> how's it more useful than a concrete Integer?
21:39:47 <copumpkin> who knows!
21:39:49 <monodromy> is e.g. that I want to attempt to read something alternatively as an Int or a Double or something, and then run through the computation using that specific type throughout
21:39:51 <shachaf> Nereid: Maybe it has a very efficient implementation of multiplication.
21:39:59 <Nereid> lol
21:40:50 <monodromy> but that all I need to know to run through the computation is that I'm given something of type in the class Num
21:41:23 <Nereid> sure.
21:41:37 <Nereid> and how would existential types help with that
21:41:45 <monodromy> and yeah naturally if I'm separating the parsing from the rest of the program
21:42:25 <monodromy> it seems to me the only sensible resulting type I can give the parsing is such an existential type, or a silly disjoint union type corresponding to the actual image in the type class
21:43:00 <Nereid> or why not just make your read function polymorphic in the result type?
21:43:24 <Nereid> if by "Int or Double or something" you mean "any Num type", at least
21:43:41 <monodromy> the functions I use afterwards are definitely polymorphic
21:43:49 <monodromy> but what type can I give to the actual parser?
21:43:57 <Nereid> you make it polymorphic too
21:44:25 <monodromy> no but I only know it returns a Num type really
21:44:40 <Nereid> parse :: Num a => (parser input) -> a
21:45:01 <monodromy> no
21:45:18 <Nereid> might be helpful if you were a bit more specific about your problem.
21:45:18 <monodromy> because I might not be able to e.g. take a ~ Int
21:45:30 <monodromy> sorry
21:45:39 <monodromy> well I could have some parsing
21:45:43 <Nereid> why not? how would you determine when you could?
21:45:44 <monodromy> and the parsing itself decides the resulting type
21:46:01 <Nereid> ok, that's what sum types are for
21:46:02 <monodromy> only ensuring the resulting type is in the class Num
21:46:16 <monodromy> yeah sure as I said I could use a huge disjoint union type
21:46:29 <monodromy> that still gives me the equivalent problem as I have before and comes out looking much clunkier
21:46:29 <Nereid> sounds like you'd have a correspondingly huge parser then
21:47:17 <Nereid> or perhaps, parse :: Num a => (...) -> Maybe a
21:47:31 <Nereid> return Nothing if a ~ Int doesn't make sense for the input
21:47:48 <Nereid> except that won't work.
21:47:59 <Nereid> so never mind.
21:48:35 <Nereid> unless you had some way of inspecting what type a was in the parser.
21:49:10 <Nereid> which maybe you could do with some finite enumeration and another typeclass
21:52:30 <CubeZero> lamdabot
21:52:38 <CubeZero> Good morning
21:52:51 <CubeZero> how can i use the lambdabot?
21:53:03 <shachaf> /msg lambdabot help
21:53:33 <CubeZero> does not work :/
21:53:36 <CubeZero> anyway
21:53:49 <CubeZero> which version will it use?
21:54:04 <CubeZero> can you please give me an example with the lamdbabot?
21:54:05 <Nereid> /msg lambdabot @help
21:54:13 <shachaf> Whoops.
21:54:15 <shachaf> What Nereid said.
21:54:18 <CubeZero> ?
21:54:30 <Nereid> @help me lambdabot
21:54:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
21:54:43 <Nereid> (prefix all commands with @)
21:54:50 <CubeZero> @print "hi"
21:54:51 <lambdabot> Not enough privileges
21:55:02 <CubeZero> @ main = print "hi"
21:55:03 <Nereid> @run "hello " ++ "world"
21:55:06 <lambdabot>   "hello world"
21:55:13 <CubeZero> @run print "hi"
21:55:15 <lambdabot>   No instance for (GHC.Show.Show (GHC.Types.IO ()))
21:55:15 <lambdabot>    arising from a use of ...
21:55:17 <Nereid> > "hello " ++ "world" -- or, more briefly, this
21:55:19 <lambdabot>   "hello world"
21:55:33 <Nereid> lambdabot will not perform IO actions
21:55:41 <Nereid> it would be stupid if it did
21:55:53 <Nereid> @ty print "hi"
21:55:54 <lambdabot> IO ()
21:56:05 <CubeZero> is the Data.Ord module loaded?
21:56:11 <Nereid> why don't you find out?
21:56:13 <CubeZero> :t comparing fst
21:56:15 <lambdabot> Ord a => (a, b) -> (a, b) -> Ordering
21:56:29 <CubeZero> my ghci 7.0.4 inferred the same
21:56:38 <CubeZero> with let cmp = comparing fst
21:56:44 <CubeZero> it inserted a UNIT () type
21:56:49 <shachaf> @where dmr
21:56:50 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
21:57:06 <CubeZero> oh not that again xD
21:57:06 <Nereid> yes, that's because of the monomorphism restriction
21:57:08 <Nereid> :v
21:57:12 <simpson> DMR? Is that the Damned Monomorphism Restriction? :3
21:57:13 <CubeZero> hahahaha
21:57:27 <CubeZero> Thank you very much
21:57:33 <Nereid> I should turn that off in my ghci.conf
21:57:50 <CubeZero> You rescued my day :)
21:57:52 <shachaf> Dreaded
21:57:57 <ski> simpson : "D" traditionally stands for "Dreaded", i think
21:58:05 <simpson> ski: Aha.
21:58:10 <Nereid> only when you're too nice to say "damn"
21:58:11 <Nereid> :v
21:58:36 * ski has never heard the "Damn" expansion before
21:58:36 <Nereid> that mfmr.
22:00:52 <CubeZero> @run let fibs = 0:1: zipWith (+) fibs (tail fibs) in take 5 fibs
22:00:54 <lambdabot>   [0,1,1,2,3]
22:01:14 <Nereid> everyone uses > instead of @run, btw
22:01:28 <Nereid> > let fibs = 0:1:zipWith (+) fibs (tail fibs)
22:01:30 <lambdabot>   not an expression: `let fibs = 0:1:zipWith (+) fibs (tail fibs)'
22:01:30 <ski> CubeZero doesn't
22:01:31 <Nereid> > let fibs = 0:1:zipWith (+) fibs (tail fibs) in fibs
22:01:33 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
22:01:41 <CubeZero> > "now i will"
22:01:43 <lambdabot>   "now i will"
22:01:49 <CubeZero> > ":)"
22:01:52 <lambdabot>   ":)"
22:02:18 <rwbarton> @botsnack
22:02:19 <lambdabot> :)
22:02:23 <ski> @botsnark
22:02:24 <lambdabot> :)
22:02:34 <Nereid> @humans
22:02:34 <lambdabot> Unknown command, try @list
22:02:38 <shachaf> rwbarton: So your own issue is resolved?
22:02:45 <ski> @palomer
22:02:45 <lambdabot> Pfft, my type inference algorithm takes hours on a 2 line program
22:03:10 <shachaf> rwbarton: I bet you want to fix taking now.
22:03:54 <Nereid> I don't really understand the motivation for the MR. even after reading the report.
22:04:26 <shachaf> > let x = sum [1..100000] in (x, x + 1)
22:04:27 <Nereid> especially since any ambiguities can be resolved by writing a type signature.
22:04:28 <lambdabot>   (5000050000,5000050001)
22:04:42 <shachaf> Nereid: Without that MR, that computes x twice.
22:04:47 <Nereid> hmm.
22:04:51 <ski> it was thought to be less confusing to newbies that `x = ...' would be cached in caching implementations
22:05:23 <Nereid> totally less confusing.
22:05:35 <Nereid> > let x = sum [1..100000] :: [Int] in (x, x + 1)
22:05:37 <lambdabot>   No instance for (GHC.Enum.Enum [GHC.Types.Int])
22:05:37 <lambdabot>    arising from the arithme...
22:05:41 <Nereid> oops
22:05:44 <Nereid> > let x = sum [1..100000] :: Int in (x, x + 1)
22:05:46 <lambdabot>   (5000050000,5000050001)
22:06:25 <Nereid> time for some highly unscientific benchmarks.
22:06:44 <shachaf> rwbarton: The advanced version is to make over traverseBits id (5::Integer) ==> 5
22:07:10 <shachaf> Nereid: Who needs benchmarks when you have Debug.Trace?
22:07:17 <Nereid> point.
22:07:31 <shachaf> (Who needs Debug.Trace when you have Core?)
22:07:45 <Nereid> more point.
22:07:53 <Nereid> although I'm not comfotrable with core.
22:07:55 <Nereid> and ghci is easier
22:09:09 <Nereid> interesting, x isn't shared in let x = ... in (x,x) :: (Int,Int)
22:09:31 <shachaf> Hmm, which way does that type annotation apply?
22:09:41 <shachaf> let x = (y :: T) or (let x = y) :: T?
22:10:33 <CubeZero> how do you find out, that its not shared? using   let x = trace "evaluate" (sum [1..100000] :: Int) in (x, x+1) ?
22:10:41 <Nereid> shachaf: you mean after the in?
22:10:50 <Nereid> CubeZero: I was just observing how long it took to evaluate.
22:11:06 <CubeZero> :)
22:11:09 <shachaf> trace works too.
22:11:09 <Nereid> or noting that ghci does incremental output
22:11:12 <Nereid> but yes
22:11:54 <Nereid> let x = ... in (\x -> (x,x)) x
22:11:57 <Ralith> okay, text in diagrams is officially terrible
22:12:12 <Nereid> Ralith: which backend?
22:12:19 <Ralith> cairo
22:12:27 <Nereid> hm
22:12:32 <Nereid> I never tried text.
22:12:40 * Ralith wants labels on his diagram
22:13:12 <Nereid> shachaf: in any case, it doesn't seem like the MR does anything we can't do with explicit type annotations.
22:13:32 <shachaf> Nereid: Correct.
22:13:37 <shachaf> It's entirely about the inferred type.
22:13:51 <CubeZero> shachaf: how would i do it with trace? would i not trace the evaluation of the sum ? let x = trace "Evaluating..." (sum [1..1000] :: Int) in ...
22:13:55 <Ralith> it seems next to impossible to get text sized sanely :/
22:13:55 <shachaf> I,I it doesn't seem like type inference does anything we can't do with explicit type annotations
22:13:56 <Nereid> and now I see that "let p = x in y" is not equivalent to "(\p -> y) x"
22:14:05 <Nereid> shachaf: haha.
22:14:21 <shachaf> Nereid: Yes, but that's more than just inference.
22:14:24 <shachaf> (At least in Haskell 98.)
22:14:35 <CubeZero> are you lazy enough to not write type annotations?
22:14:39 <shachaf> (Maybe with RankNTypes it becomes as good as let?)
22:14:45 <Nereid> CubeZero: for non-top-level declarations? sure
22:15:15 <Nereid> and sometimes you simply cant, unless you turn on say ScopedTypeVariables
22:17:34 <bxx> I crashed GHC
22:17:47 <bxx> accidentally typed show instead of Show.  data Point = Point Float Float deriving (show)
22:18:02 <shachaf> bxx: Yes.
22:18:38 <shachaf> I bet if you look the error up on Google you'll find the original bug report, which should tell you when it was fixed. :-)
22:21:48 <Nereid> that's an interesting bug
22:21:53 <Nereid> http://hackage.haskell.org/trac/ghc/ticket/5961
22:35:47 <sw2wolf> Does split-obj speed up cabal ?
23:16:05 * hackagebot FixedPoint-simple 0.5 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.5 (ThomasDuBuisson)
23:18:33 <CubeZero> is there a way to write this shorter: i have a some int indices i, j, k, l, m and would like to have a list of some of these
23:19:43 <CubeZero> with some conditions: [i, when (j < k) j, when (k < m) k]
23:19:51 <CubeZero> just the when will not work
23:19:59 <CubeZero> is there a way around catMaybes
23:20:00 <CubeZero> ?
23:20:20 <shachaf> You should give some examples of what you mean.
23:20:52 <CubeZero> something like this: [i, when (j < k) j, when (k < m) k]
23:21:00 <CubeZero> i,j, k are ints
23:21:18 <CubeZero> i would like to have the list [i, j, k] if (j < k) and (k < m)
23:22:53 <CubeZero> > catMaybes [Just 1, if (2 < 3) then Just 2 else Nothing, if (5 < 3) then Just 5 else Nothing]
23:22:55 <lambdabot>   [1,2]
23:22:57 <typoclass> CubeZero: normally, you need 'if then else' to have always a 'then' value and an 'else' value (both of the same type). 'when' is a shortcut thingy that basically does 'else return ()'. return of course only works within monads
23:23:13 <shachaf> > let foo [] = []; foo (x:xs) = takeWhile (uncurry (<)) $ zipWith xs (tail xs) in foo [1,3,5,8,4]
23:23:16 <lambdabot>   Couldn't match expected type `[(b0, b0)]'
23:23:16 <lambdabot>              with actual type `[b...
23:23:34 <shachaf> Um.
23:24:18 <CubeZero> i will go with the Maybe a type :)
23:24:27 <CubeZero> > :t uncurry
23:24:29 <lambdabot>   <hint>:1:1: parse error on input `:'
23:24:37 <CubeZero> @type uncurry
23:24:39 <lambdabot> (a -> b -> c) -> (a, b) -> c
23:24:45 <shachaf> > let foo [] = []; foo (x:xs) = x : (map snd . takeWhile (uncurry (<)) $ zip xs (tail xs)) in foo [1,3,5,8,4]
23:24:48 <lambdabot>   [1,5,8]
23:24:49 <typoclass> CubeZero: not exactly sure what you're going for, but have you thought about using 'filter'? as in, filter out all the k's that are less than m
23:25:07 <shachaf> OK, never mind. I can't even write code now.
23:25:11 <shachaf> You didn't specify your problem fully, on the other hand.
23:25:21 <CubeZero> there is several different conditions
23:25:24 <shachaf> More examples would be good.
23:25:25 <CubeZero> but Maybe is fine :)
23:25:33 <shachaf> Like [1, 3, 5, 8, 4, 9] --> ?
23:27:17 <typoclass> CubeZero: you could just make a helper function f so that you can write [Just 3, f (4 < 7) 4, ...]
23:27:46 <shachaf> ?
23:28:21 <CubeZero> @type and
23:28:23 <typoclass> shachaf: i mean, "f b x = if b then Just x else Nothing"
23:28:23 <lambdabot> [Bool] -> Bool
23:28:26 <CubeZero> > and []
23:28:28 <lambdabot>   True
23:28:53 <shachaf> > let foo [] = []; foo [x] = [x]; foo (x:y:xs) | x <= y = x : foo (y:xs) | otherwise = [x] in foo [1, 3, 5, 8, 4]
23:28:55 <lambdabot>   [1,3,5,8]
23:29:02 <shachaf> typoclass: Yes, but that doesn't solve CubeZero's problem a tall.
23:29:02 <typoclass> ... but yes, i guess it's in the standard lib as 'guard' or whatever :-)
23:29:03 <shachaf> I assume.
23:29:22 <shachaf> Well, actually, I don't blame you for being confused, because CubeZero never stated their problem clearly.
23:29:44 <shachaf> CubeZero: What do you want? A function that does something? If so, what's its type?
23:29:45 <typoclass> shachaf: i meant that as an addition to the code that he gave, catMaybe [...]
23:29:48 <CubeZero> >filter (and . snd) [(1, []), (2, [1 < 2, 5 < 2]), (5, [2 < 3, 5 < 6])]
23:29:51 * shachaf is confused too.
23:29:59 <CubeZero> > filter (and . snd) [(1, []), (2, [1 < 2, 5 < 2]), (5, [2 < 3, 5 < 6])]
23:30:02 <lambdabot>   [(1,[]),(5,[True,True])]
23:30:11 <CubeZero> > map snd .  filter (and . snd) [(1, []), (2, [1 < 2, 5 < 2]), (5, [2 < 3, 5 < 6])]
23:30:13 <lambdabot>   Couldn't match expected type `[(a0, b0)]'
23:30:13 <lambdabot>              with actual type `(a...
23:30:16 <shachaf> I have no idea where that 3 came from.
23:30:20 <CubeZero> > map snd $  filter (and . snd) [(1, []), (2, [1 < 2, 5 < 2]), (5, [2 < 3, 5 < 6])]
23:30:23 <lambdabot>   [[],[True,True]]
23:30:26 <shachaf> What's going on? Help!
23:30:28 <CubeZero> > map fst $  filter (and . snd) [(1, []), (2, [1 < 2, 5 < 2]), (5, [2 < 3, 5 < 6])]
23:30:31 <lambdabot>   [1,5]
23:30:37 <CubeZero> ah thats what i want :)
23:31:04 <typoclass> shachaf: i could 'help' you by sending some lambdacats, but i think that's not what you're looking for
23:31:08 <shachaf> You have a list of the type [(a, [Bool])]?
23:31:08 <CubeZero> i have a value and a list of bools; my conditions are [3 < 5, 2 < 3 etc...]
23:31:14 <CubeZero> now i do :)
23:31:24 <CubeZero> thats perfect thank you :)
23:31:28 <shachaf> That would be helpful to state.
23:31:41 * shachaf wonders how one ends up starting with with a list of Bools.
23:32:13 <CubeZero> the alternative is to write 20 if conditions
23:32:40 <shachaf> OK, I give up. I still have no idea what you're actually doing.
23:32:40 <CubeZero> with if then else it doubles my troubles xD
23:32:46 <shachaf> typoclass can help.
23:33:55 <typoclass> > [x | x <- [1..10], x `mod` 3 == 0] -- CubeZero, you know how you can put a comma and a condition (Bool) into a list comprehension?
23:33:57 <lambdabot>   [3,6,9]
23:34:12 <typoclass> > [x | x <- [1..10], x `mod` 3 == 0, x `mod` 2 == 0]
23:34:14 <lambdabot>   [6]
23:34:14 <shachaf> OK, maybe not.
23:34:35 <CubeZero> sure i was looking for something similar
23:36:50 <Nereid> > [5 | False]
23:36:53 <lambdabot>   []
23:36:54 <Nereid> > [5 | True]
23:36:56 <lambdabot>   [5]
23:37:15 <shachaf> With MonadComprehensions, that'll even give you a Maybe.
23:37:21 <Nereid> yeah heh
23:37:31 <Nereid> > guard False >> return 5
23:37:33 <lambdabot>   No instance for (GHC.Show.Show (m0 b0))
23:37:34 <lambdabot>    arising from a use of `M91213983...
23:37:36 <Nereid> aw.
23:37:57 <Nereid> > let x = guard False >> return 5 in (x,x) :: Maybe Int, [Int]
23:37:59 <lambdabot>   <hint>:1:54: parse error on input `,'
23:38:11 <Nereid> oh, haha
23:38:12 <Nereid> > let x = guard False >> return 5 in (x,x) :: (Maybe Int, [Int])
23:38:13 <lambdabot>   (Nothing,[])
23:38:14 <Nereid> > let x = guard True >> return 5 in (x,x) :: (Maybe Int, [Int])
23:38:16 <lambdabot>   (Just 5,[5])
23:38:35 <Nereid> :t guard
23:38:37 <lambdabot> MonadPlus m => Bool -> m ()
23:39:12 <Nereid> hmmm
23:39:32 <Nereid> so if MonadPlus is supposed to be a monoid object in the category of monads
23:39:38 <Nereid> and monads are monoids in the category of endofunctors,
23:39:49 <Nereid> and a monoid in the category of monoids is a commutative monoid, then...
23:39:57 <Nereid> MonadPlus = commutative monads?
23:40:25 <shachaf> No?
23:40:28 <Nereid> :V
23:40:29 <shachaf> @instances MonadPlus
23:40:31 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
23:40:41 <Nereid> yeah I know it's obviously false, just some silly thoughts.
23:41:42 <Nereid> ah, that's where the reasoning fails.
23:42:36 <Nereid> MonadPlus is a monoid object in the monoidal category of monads with monoidal product = product
23:42:46 <Nereid> which does not coincide with the monoidal product in the category of endofunctors
23:43:04 <hpaste> liyang pasted “lens — Generalise Simple Iso s a -> Simple Iso (Maybe s) (Maybe a) ?” at http://hpaste.org/77910
23:43:31 <Nereid> hpaste: clearly the same definition works for any Functor
23:43:44 <Nereid> er liyang
23:44:31 <liyang> You mean, Functor f => SimpleLensLike f … ?
23:44:43 <Nereid> no I mean instead of Maybe.
23:44:47 <shachaf> liyang: Simple Iso (f a) (f b)
23:44:54 <liyang> oh yeah.
23:45:06 <shachaf> liyang: Do you think there should be a name for view (from x)?
23:45:27 <liyang> Yes, weiv.
23:45:39 <Nereid> lol
23:48:03 <hpaste> liyang annotated “lens — Generalise Simple Iso s a -> Simple Iso (Maybe s) (Maybe a) ?” with “lens — Generalise Simple Iso s a -> Simple Iso (Maybe s) (Maybe a) ? (annotation)” at http://hpaste.org/77910#a77911
23:49:52 <Nereid> heh
23:50:41 <Nereid> like what?
23:51:04 <liyang> I dunno, something less Simple? But I'm struggling to write it.
23:51:16 <Nereid> oh
23:51:56 <shachaf> Grr.
23:52:07 <shachaf> (foo¯¹) is *almost* valid.
23:52:19 <shachaf> But ¹ is OtherNumber
23:52:29 <Nereid> what
23:53:06 <liyang> I guess ₁ is OtherNumber too?
23:53:09 <Nereid> liyang: what goes wrong if you just replace the Simple Isos with the obvious non-Simple versions?
23:53:20 <Nereid> Iso s t a b
23:54:00 <Nereid> well you can't use iso now, I guess
23:54:06 <shachaf> @ty isos
23:54:08 <lambdabot> (Functor f, Isomorphic k) => (s -> a) -> (a -> s) -> (t -> b) -> (b -> t) -> k (a -> f b) (s -> f t)
23:54:13 <typoclass> shachaf: i once tried to have a variable name "x with an arrow above", using a normal x and a combining unicode character. din't werk :-(
23:54:16 <Nereid> but isos exists yeah
23:54:43 <Nereid> typoclass: clearly haskell isn't unicode-compliant enough!
23:54:44 <Nereid> or something
23:55:01 <Nereid> I like having identifiers I can type.
23:55:05 <shachaf> Is there a character that looks like ¹?
23:55:13 <liyang> Nereid: I can't see how to make the other two arguments for isos.
23:55:23 <Nereid> liyang: you repeat the first two.
23:55:37 <Nereid> recall, iso sa as = isos sa as sa as
23:55:42 <Nereid> except
23:55:43 <Nereid> hmm
23:55:49 <Nereid> wait.
23:55:54 <Nereid> I dunno.
23:58:29 <typoclass> Nereid: hm yeah, "haskell needs moar unicode" :-)
23:59:00 <Nereid> well, given Functor f => (a -> g b) -> (s -> g t)
23:59:05 <Nereid> er, Functor g =>
23:59:12 <typoclass> ghc says ":2:4: lexical error at character '\8407'" when you give it the input "abc = 123" where after the c there's a funky combining arrow above
23:59:18 <Nereid> you need (f a -> g (f b)) -> (f s -> g (f t))
