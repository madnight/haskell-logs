00:04:54 <Lee_> why is case .. of .. 'char' -> <asking for Bool>, i can't even print a string
00:05:25 <sw2wolf> Can the compiled xmonad run on another machine without GHC ?
00:06:31 <shapr> sw2wolf: yes
00:06:41 <sw2wolf> thx
00:07:37 <latermuse> how can i install Data.List.Split with cabal? its not showing up when i search for it
00:07:51 <johnw> sw2wolf: unlike languages like Java, Ruby, Python, etc., GHC makes standalone executables which don't require installing any "environment" to run them on the target machine
00:07:59 <johnw> latermuse: cabal install split
00:08:17 <sw2wolf> johnw: thanks
00:08:18 <latermuse> ah! thanks
00:14:14 <donri> johnw: unless you use certain packages ...
00:14:29 <johnw> which one?
00:14:39 <shapr> template haskell?
00:14:46 <sopvop> I though ghc can dynamic link to runtime now
00:14:59 <johnw> no template Haskell is only used to compile time
00:15:01 <donri> johnw: dyre for one
00:15:22 <donri> duno if plugins requires a ghc install or if it links it only
00:15:59 <donri> sw2wolf: i think you need ghc for configuring xmonad though
00:16:29 <sw2wolf> donri: i configure it on another machine
00:16:33 <donri> sure
00:25:34 <bartavelle> anyone knows of a printable version of http://www.cis.upenn.edu/~bcpierce/sf/ ?
00:27:39 <edwardk> Soliciting additions to https://github.com/ekmett/lens/wiki/FAQ
00:37:06 <djcoin> edwardk: maybe the philosophy or some relevant papers about lenses ? (i'm a beginner in haskell so my point may not be relevant :>)
00:37:23 <edwardk> djcoin: good point
00:37:34 <edwardk> i'll add some links to videos/papers
00:40:11 <djcoin> Or maybe a webpage link to an existing more in depth explanation of lenses. Don't knooow, glad you find my point useful :)
00:40:43 <edwardk> djcoin: yeah there is a tutorial, etc. off the main page, but i can definitely add links
00:40:44 <djcoin> I really need to finish the paper about banana, lenses and barbed wires
00:41:07 <edwardk> djcoin: thats another question i need for the faq. what connection is there to that paper? the answer is there is no relation
00:41:19 <edwardk> its a common mistake, so i should definitely add it
00:42:24 <djcoin> Oh really ? There is no relation ?
00:48:40 <donri> edwardk: you do know hashable and unordered-containers aren't in platform *yet* right?
00:48:59 <donri> maybe rephrase faq to cover "planned for platform"
00:49:07 <shachaf> Those are used internally in lens.
00:49:08 <edwardk> yes. i said in there stuff that is in the platform _or_ which are needed for internal purposes
00:49:14 <edwardk> i need hashable for plated
00:49:35 <donri> oh
00:49:35 <edwardk> at last check tibbe seemed to be in no hurry to standardize unordered-containers
00:52:09 <lpsmith> is there a handy way to build the docs if you are compiling the haskell platform from source?   'cause if I just make and make install,  I get no docs and then later installs have missing links
00:53:28 <donri> edwardk: hm i think the plan is to platform hashable and move unordered to containers?
00:54:01 <edwardk> donri: might be, last i heard was a long time ago and tibbe was very negative about the prospect of standardizing it back then
00:54:13 <edwardk> the platform typically comes with a lot of costs to a package maintainer and few benefits
00:54:56 <Lee_> I am trying to do this -> map (\x -> get index of x) List, is it possible ?
00:55:00 <donri> edwardk: so... lens in platform, what, 2018? :)
00:55:34 <edwardk> heh, well, IIRC there isn't anything in the platform that needs type families right now so the hill is steep
00:55:57 <edwardk> also i think we're up to 92 unsafeCoerce's in the codebase. i'm sure that will go over well
00:56:13 <donri> \o/
00:56:57 <edwardk> Lee_: you want the current position in the list in addition to x? or are you looking it up in something else
00:59:16 <Lee_> edwardk: x is an element in List right? I want to get the index of x in List
00:59:36 <edwardk> x is just a variable name it can mean anything you want
00:59:54 <Lee_> edwardk: ??
01:00:14 <edwardk> the short answer is 'no you can't do that'. you can however, zip with a list of indices
01:00:49 <edwardk> > zipWith (\i x -> (i, x)) [1..] ["hello","this","is","my","list"]
01:00:50 <lambdabot>   [(1,"hello"),(2,"this"),(3,"is"),(4,"my"),(5,"list")]
01:01:12 <Lee_> edwardk: what i want to do is actually modify an element in a int List
01:01:14 <edwardk> you can use i to refer to the position in the list, and x as name for the element of the ["hello",..] list
01:03:00 <Lee_> edwardk: oh ok thanks
01:04:42 <Nereid> > elemIndex 'o' "hello world"
01:04:44 <lambdabot>   Just 4
01:05:06 <Nereid> well, it really depends on what you want to do.
01:05:27 <Nereid> always worth having a peek at what's in Data.List too
01:06:54 <hkBst> so in RWH they mention partiality of head and other prelude functions and that they can throw exceptions. Why don't these functions just return a Maybe?
01:07:11 <Nereid> because they are old
01:07:13 <Lee_> Nereid: ya i looked at elemIndex
01:07:14 <simpson> hkBst: Tradition!
01:07:24 <hkBst> and more generally, is there any facility for checking pattern completeness?
01:07:25 <simpson> hkBst: Many of them have total variants.
01:08:03 <Nereid> compiling with -Wall will warn you if you define a function with non-exhaustive patterns
01:08:08 <Nereid> but that won't stop you from using head
01:10:34 <Nereid> :t foldr ((<|>) . Just) Nothing
01:10:36 <lambdabot> [a] -> Maybe a
01:10:48 <Nereid> (safe head)
01:11:03 <hkBst> hmm, it is kind of disappointing that the potential safety offered by the strong type system is so easily subverted
01:11:20 <c_wraith> it's the downside of allowing general recursion
01:11:24 <Nereid> well, just make it a policy to not use head and similar functions in your code :p
01:11:25 <simpson> ^^
01:12:01 <c_wraith> Once you allow non-termination, other bottoms really aren't as big of a deal
01:12:02 <hkBst> c_wraith: you're saying checking pattern exhaustiveness is undecidable?
01:12:39 <Nereid> :t foldr (mplus . return) mzero
01:12:41 <lambdabot> MonadPlus m => [a] -> m a
01:12:57 <Nereid> hkBst: checking for bottom is undecidable
01:13:22 <c_wraith> well, in the presence of general recursion, or other turing-complete structures.
01:13:32 <hkBst> Nereid: still programmers seem to be able to do it ;P
01:13:38 <c_wraith> do they?
01:13:42 <c_wraith> you'd be surprised how bad they are
01:13:50 <Nereid> @let f = foldr (mplus . return) mzero
01:13:52 <lambdabot>  Defined.
01:13:54 <c_wraith> anyone can write an algorithm that's wrong sometimes.
01:14:05 <Nereid> > f [1,2,3] :: Maybe Int
01:14:07 <lambdabot>   Ambiguous occurrence `f'
01:14:07 <lambdabot>  It could refer to either `L.f', defined at <local...
01:14:10 <Nereid> oh great.
01:14:12 <Nereid> @undefine
01:14:16 <Nereid> @let fff = foldr (mplus . return) mzero
01:14:18 <lambdabot>  Defined.
01:14:21 <Nereid> > fff [1,2] :: Maybe Int
01:14:23 <lambdabot>   Just 1
01:14:23 <Nereid> > fff [] :: Maybe Int
01:14:25 <lambdabot>   Nothing
01:14:29 <Nereid> > fff [1,2] :: [Int]
01:14:31 <lambdabot>   [1,2]
01:14:36 <Nereid> hooray.,
01:15:18 <simpson> :t fff'
01:15:20 <simpson> :t fff
01:15:21 <lambdabot>     Not in scope: fff'
01:15:21 <lambdabot>     Perhaps you meant `fff' (line 1)
01:15:23 <lambdabot> MonadPlus m => [a] -> m a
01:15:49 <c_wraith> Now, if you're willing to take the leap to full dependent types, you can do clever things like encoding non-termination with production co-recursion, and limit your language to only things it can prove terminate.
01:15:56 <c_wraith> *productive
01:16:06 <c_wraith> and still get full turing completeness
01:16:44 <simpson> c_wraith: You still have to write the proofs, though, don't you?
01:16:54 <c_wraith> yes
01:17:06 <c_wraith> that's why "willing to take the leap" is such a big problem
01:17:48 <c_wraith> also, you end up with with meta-non-termination. You can prove each co-recursive step does work, but not that the work done will ever finish.
01:18:27 <c_wraith> It just forces you to think about it a bit more.
01:18:28 <Nereid> :t msum . map return
01:18:29 <lambdabot> MonadPlus m => [a] -> m a
01:18:32 <Nereid> heh
01:19:17 <Nereid> I think
01:19:22 <Nereid> :t void
01:19:23 <lambdabot> Functor f => f a -> f ()
01:19:25 <Nereid> we should have called this id_
01:19:32 <Nereid> :p
01:19:44 <m3ga> i have an Int64 containing the seconds since the Unix epoch, how can i convert that to UTCTime?
01:20:21 <m3ga> without going through parseTime . show
01:20:31 <c_wraith> is it really since the unix epoch?  Or is it POSIX time?
01:20:34 <c_wraith> (those are not the same)
01:20:41 <Nereid> go through secondsToDiffTime and addUTCTime
01:21:08 <m3ga> Nerid thanks. its a bit non-obvious
01:21:10 <Nereid> and uh
01:21:12 <Nereid> well maybe.
01:21:21 <Nereid> oh wait
01:21:22 <Nereid> posixSecondsToUTCTime
01:21:23 <Nereid> that exists.
01:21:32 <Nereid> no need to add.
01:21:47 <m3ga> posixSecondsToUTCTime takes a POSIXTime
01:21:48 <Nereid> c_wraith: what's the difference?
01:22:02 <Nereid> m3ga: and PosixTime = NominalDiffTime
01:22:28 <c_wraith> Nereid: leap seconds. POSIX time ignores them. It pretends days are all a fixed number of seconds, and actually calculates days * # of seconds per day
01:22:34 <m3ga> i really hate the standard time package :-)
01:22:50 <Nereid> c_wraith: ah
01:23:14 <c_wraith> this means multiple different real-world seconds can map to the same POSIX time.
01:23:36 <c_wraith> note: don't assume POSIX time increases monotonically
01:23:53 <Nereid> how sad.
01:24:30 <c_wraith> mistakes like that are why the leap second this summer broke a bunch of programs
01:24:52 <Nereid> like what?
01:25:13 <pharaun_> java iirc
01:25:33 <c_wraith> yeah, the jvm had issues
01:25:39 <c_wraith> so did some versions of the linux kernel
01:25:51 <c_wraith> (Sun's JVM, that is)
01:25:52 <hkBst> :info foldl
01:26:40 <Nereid> @info foldl
01:26:40 <lambdabot> foldl
01:26:45 <Nereid> @info not very useful.
01:26:45 <lambdabot> (not very useful .)
01:26:50 <Nereid> what.
01:26:57 <Nereid> what is it actually doing?
01:27:03 <fmap> undo
01:27:07 <Nereid> oh great.
01:27:24 <basdirks_> like half the links on eDSL-related HaskellWiki pages don't work, can I go clean it? And what should I do if I can't find replacement links for the 404'ing papers?
01:32:20 <latermuse> is there a way to set permissions for a file using haskell?
01:32:30 <yitz> m3ga: (sorry just joined in) you mean in C?
01:34:01 <snoyberg> latermuse: you can use the unix-compat package (http://hackage.haskell.org/packages/archive/unix-compat/0.4.0.0/doc/html/System-PosixCompat-Files.html)
01:34:11 <snoyberg> latermuse: if you just need posix support, you could use unix instead
01:34:14 <latermuse> snoyberg: thank you
01:34:41 <snoyberg> latermuse: np
01:34:56 <yitz> c_wraith: UTC POXIX time is certainly not strictly monotonic. it would only not be monotonic in the unlikely instance of a negative leap second, which has never happened so far.
01:35:23 <yitz> hey snoyberg!
01:35:27 <m3ga> yitz: i have an Int64 which I read from 'git log --format=raw' output
01:35:58 <yitz> snoyberg: happened to see the "sayeret-lambda" post about your upcoming talk
01:36:19 <yitz> snoyberg: (came up in some google search. i'm not subscribed.)
01:36:31 <c_wraith> yitz: you're allowed to have 2 leap seconds at once, though that's never happened
01:36:34 <snoyberg> yitz: yeah, i'm finally get out of the north ;)
01:37:16 <snoyberg> yitz: you ever been to a sayeret lambda meeting?
01:37:18 <yitz> c_wraith: at once? are you sure? i thought it's at most +1 june and +1 dec.
01:37:32 <yitz> snoyberg: no.
01:38:10 <snoyberg> yitz: neither have i, i'm still trying to figure out if they tend to speak english or hebrew
01:38:38 <yitz> c_wraith: there would have to be an as yet unseen giant wobble in the earth's rotation for more than that to be needed
01:39:02 <yitz> snoyberg: looks like israelis to me, but i'm sure it's fine if you speak in english
01:39:39 <snoyberg> yitz: i did the podcast in english, i haven't the faintest clue how to say half of the stuff i need to in hebrew... then again, i doubt *anyone* translates "monad" into hebrew
01:39:51 <yitz> snoyberg: i've seen shlomie fish's posts around for some years. he's always seemed to be negative about haskell.
01:40:03 <m3ga> @hoogle Num a => a -> UTCTime
01:40:03 <lambdabot> Prelude abs :: Num a => a -> a
01:40:03 <lambdabot> Prelude negate :: Num a => a -> a
01:40:03 <lambdabot> Prelude signum :: Num a => a -> a
01:40:10 <yitz> snoyberg: i think you just translated it
01:40:42 <c_wraith> yitz: yeah, it's one of those terribly unlikely things that (iirc) is allowed just in case
01:41:55 <yitz> snoyberg: when in hebrew, academic talks tend to use translations rather than borrowings only when there is an obvious translation, or when the term is so common that someone was able to think up something clever that caught on.
01:42:17 <yitz> snoyberg: this isn't exactly an academic forum, but i think it should work pretty much the same way
01:43:02 <edwardk> djcoin: i've added links for where to find resources
01:43:39 <yitz> c_wraith: they are not trying to track the rotation accurately, it's just approximate cumulative. so to fall so far behind that they would need a +2 seems pretty extreme.
01:43:52 <djcoin> edwardk: great ! many links I need to check I guess :) thanks
01:44:13 <yitz> c_wraith: they didn't do that even when they were already about half a minute behind in the 1970's when they first started this.
01:45:06 <yitz> c_wraith: maybe it's in case of a giant asteroid impact or something
01:45:28 <yitz> c_wraith: but in that case i'm not sure how relevant leap seconds would be anymore anyway
02:13:32 <edwardk> @tell glguy https://github.com/ekmett/lens/wiki/FAQ#wiki-lens-core
02:13:33 <lambdabot> Consider it noted.
02:54:31 <basdirks_> like half the links on eDSL-related HaskellWiki pages don't work, can I go clean it? And what should I do if I can't find replacement links for the 404'ing papers?
02:56:36 <lee_> how do i call 2 independent functions like functionA = executeFunctionB then executeFunctionC
02:57:44 <Nereid> what do you mean?
03:15:27 <quchen> lee_: You mean executing A and afterwards B?
03:26:34 <mSSM> When using record syntax: data Foo = Foo { bar :: Int ; baz :: Int}, can I still call the constructor with `Foo firstInt secondInt' ?
03:26:51 <mSSM> Or do I now _need) to use Foo { bar = firstInt, baz = secondInt} ?
03:27:01 <sipa> mSSM: you can
03:27:28 <mSSM> sipa: i.e., the fields are then assigned in the order they are placed in the record?
03:27:31 <sipa> yes
03:27:33 <mSSM> cool
03:27:41 * shachaf doesn't know what it means to execute a function.
03:28:03 <shachaf> (Well, I can think of one meaning -- run a (r ->) action -- but it's probably not what you meant.)
03:28:16 <PatrickRobotham> shachaf: What do you do with misbehaving functions? Imprison them?
03:28:58 <sopvop> execute misbehaving function, as a warning to a hundred
03:29:07 <sipa> you just unsafeCoerce them into submission
03:31:24 <Peaker> I'm having a problem composing Lens.Traversal's "horizontally." Composing them with (.) is fine, but how about having a compose that means "both these traversals happen on the same input"?
03:31:37 <Peaker> It seems like I need a Monad instance for this instead of an Applicative one
03:33:52 <shachaf> Peaker: https://github.com/ekmett/lens/issues/109
03:44:30 <mSSM> I am trying to understand how I can create a Generator from withSystemRandom using mwc-random here http://hackage.haskell.org/packages/archive/mwc-random/0.12.0.1/doc/html/System-Random-MWC.html#v:withSystemRandom
03:44:37 <mSSM> Can somebody help me?
03:45:16 <mSSM> The description says: "You should use the Gen it creates to generate many random numbers. " but it does not create a Gen, it
03:45:20 <mSSM> creates a IO a
03:46:03 <sopvop> it takes function as first argument :: Gen (PrimState m) -> m a
03:47:11 <sopvop> thare is an example below that function, in Type helpers
03:47:16 <mSSM> sopvop: so for example uniform fits that
03:48:28 <sopvop> do v <- withSystemRandom uniform :: IO Int
03:48:40 <sopvop> v will be random int
03:49:10 <mSSM> but how can I reuse the generator now?
03:49:18 <mSSM> v holds a value, not a generator, right?
03:49:22 <sopvop> Right
03:49:45 <mSSM> I would just like to create a generator with a random seed, and then reuse the generator over and over
03:49:58 <sopvop> I guess systemRandom does not do that
03:50:16 <sopvop> Oh
03:50:47 <mSSM> This is silly... it can create a non-random seed
03:50:56 <mSSM> with the create function
03:51:36 <sopvop> gen <- initialize (singleton 42)
03:51:36 <sopvop> v <- uniform gen :: IO Int
03:52:04 * sopvop sees this module second time, so maybe wrong
03:52:28 <mSSM> sopvop: indeed, but that seed is not really random
03:54:05 <sopvop> thats why it is seed then
03:55:20 <sopvop> rnd <- withSytemRandom uniform :: IO Word32
03:55:20 <sopvop> gen <- initialize (singleton rnd)
03:55:20 <sopvop> v <- uniform gen :: IO Int
03:55:53 <kliko> dear all, I have implemented a small stack based programming language, which runs programs like this runMe (push 5 (push 5 (add stop))), which ofcourse results in 10
03:56:01 <sopvop> Note what I know nothing about RNG
03:56:09 <kliko> now I'm wondering whether I can write it like runMe push 5 push 5 add stop?
03:56:26 <mSSM> sopvop: oh, that makes sense
03:56:30 <mSSM> mSSM: wow, obviously, thank you!
03:56:35 <kliko> the type of runMe is defined as State [Int] Int
03:56:42 <kliko> -> Int
03:56:46 <mSSM> sopvop: that withSystemRandom spits out a random number, and then I use that as a seed
03:56:55 <mSSM> sopvop: You, sir, are clearly smarter than me! :D
03:57:34 <kliko> is there a way to write it without parentheses?
03:57:43 <kliko> and I do not want any dollar signs there either
03:57:46 <sopvop> shucks
03:57:48 <mSSM> kliko: runMe $ push 5 $ push 5 $ add stop
03:57:58 <mSSM> :D
03:58:05 <kliko> :P, kinda trivial
03:58:17 <kliko> but I want runMe push 5 push 5 add stop
03:58:25 <kliko> and then just return 10
03:59:30 <sopvop> kliko: If your commands are always 2 tokens then sure. otherwise - maybe.
04:00:31 <kliko> well I only have the commands push, add, mul, pop and stop and runMe
04:00:59 <int-e> kliko: why don't you use the state monad as a monad?  runMe $ do push 5; push 5; add; stop?
04:01:06 <kliko> I am using a monad
04:01:12 <sopvop> kliko: Oh, it is haskell?
04:01:15 <kliko> yes
04:01:32 <int-e> kliko: I know. But you're not using it as such.
04:01:33 <sopvop> no way then
04:01:50 <sopvop> just use do
04:02:00 <sopvop> int-e: is right here
04:02:08 <kliko> let me try
04:03:11 <kliko> well uhm int-e would you like to look at my code?
04:03:23 <kliko> cause I'm not sure what I'm doing wrong.
04:03:39 <int-e> http://hpaste.org/ is the usualy way to let people look at code here :)
04:04:02 <kliko> Please note this is a homework assignment, but the teacher said this: "start push 5 push 6 add stop" should work
04:04:05 <kliko> "out of the box"
04:04:26 <kliko> but I an only produce start (push 5 (push 6 (add stop)))
04:04:34 <int-e> kliko: are you sure that this was meant to be haskell code?
04:04:38 <kliko> yes
04:04:42 <kliko> 100% sure
04:05:01 <sopvop> maybe there were dots, or newlines?
04:05:10 <kliko> no, no newlines, no dots
04:05:16 <int-e> it's not that it can't be done - I'm fairly sure modelling this after Text.Printf will work -- but it seems highly unadvisable.
04:05:29 <kliko> I can give you the exercise if you want
04:06:06 <kliko> http://www.cs.uu.nl/wiki/bin/viewfile/Afp/Assignments?rev=5;filename=Assign2.pdf
04:06:22 <kliko> read p1 p2 p3
04:06:28 <kliko> those are programs without parentheses
04:06:58 <Peaker> shachaf: thanks!
04:07:01 <kliko> I've actually succeeded in producing the desired results, however I just can't remove those parentheses without failing :(
04:07:08 <Peaker> shachaf: So I haven't been beating my head about it for nothing -- and my conclusion is similar
04:07:45 <kliko> oh well, maybe I just should ask him during the lecture
04:08:24 <int-e> kliko: ok, there's a bit of a hint, so it seems less wild now. (actually the claim that this works without type classes makes it interesting)
04:09:01 <kliko> I know, you are talking about continuations right?
04:09:32 <sopvop> There assignments look harsh
04:09:36 <sopvop> These
04:09:46 <t7> > (0b11110000, 0b00001111)
04:09:48 <lambdabot>   Not in scope: `b11110000'Not in scope: `b00001111'
04:09:55 <int-e> AFP is "advanced functional programming"?
04:09:59 <kliko> yes
04:10:05 <hpaste> Lee pasted “How can I execute 2 functions parse and show here ?” at http://hpaste.org/78466
04:10:25 <t7> > (16 + 32 + 64 + 128, 1 + 2 + 4 + 8)
04:10:27 <lambdabot>   (240,15)
04:10:43 <kliko> I thought maybe someone can give me one hint
04:11:21 <kliko> but I think I've implemented the continuations correctly as I can do start (store 3 (store 4 stop))
04:11:31 <kliko> because every command actually takes a function
04:11:34 <t7> @check 0xf0 == 240
04:11:34 <kliko> except the stop
04:11:35 <lambdabot>   Not in scope: `myquickcheck'
04:12:03 <kliko> and then binds it using >>= and >> respectively
04:12:29 <kliko> I
04:12:45 <kliko> I've thought about this problem for several days, but I can't seem to fix it :(
04:14:25 <sopvop> I think pdf is broken
04:14:30 <kliko> how come?
04:15:39 <sopvop> I don't know, but there should be either . or ()
04:16:02 <kliko> . doesn't work for monads I think
04:16:33 <nerko> @hoogle map
04:16:34 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
04:16:34 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
04:16:34 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
04:16:36 <sopvop> You don't need monads, you can just use functions :: state -> (a, state)
04:17:13 <t7> how do i shift 4 bits right in C ?
04:17:20 <luite> kliko: it's easy to do it without parentheses actually
04:17:25 <kliko> :|
04:17:31 <sopvop> x >> 4?
04:17:36 <nikita-0> t7: x <<= 4
04:17:48 <nikita-0> Err… that's left. :-)
04:18:08 <kliko> luite: can you give me a hint or something?
04:18:13 <luite> kliko: what's the type of your start function?
04:18:28 <kliko> State [Int] Int -> Int
04:18:41 <kliko> Int -> State [Int] Int -> State [Int] Int
04:18:43 <kliko> for store
04:18:47 <kliko> and the first one for start
04:19:03 <luite> kliko: try   start :: ([Int] -> a) -> a
04:19:39 <kliko> are you saying that I should try and build a function that does start :: ([Int] -> a) -> a?
04:19:44 <kliko> in what context should a be in?
04:19:49 <kliko> it should be Int right?
04:19:59 <kliko> so ([Int] -> Int) -> Int?
04:20:28 <luite> kliko: yeah you can specialize it, but if you do it with my suggested type, it's even more clear what you ahve to do :)
04:20:41 <kliko> but according to my knowledge, State s a is defined as s -> (a,s)
04:20:59 <kliko> so that means my start function is (s -> (a, s)) -> a
04:21:10 <sopvop> forget state, do by hand
04:21:25 <kliko> alright.
04:21:42 <sopvop> report results here, I'm interested :)
04:21:49 <luite> kliko: do it by hand first, then remember that start supplies the initial state, and your state is an [Int]
04:22:10 <luite> i didn't use State or your s -> (a,s) thing anywhere
04:22:54 <kliko> are you taking the same course?
04:23:03 <luite> no i graduated from uu last year :p
04:23:23 <kliko> lol... but I thought the exercise was to be familiar with Monads!
04:23:28 <luite> (but have never taken this course)
04:24:18 <kliko> which track did you do?
04:25:53 <luite> uh computing science, algorithm design and complexity
04:26:41 <kliko> luite: are you by the way suggesting that I should have the function type for store :: a -> [Int] -> ([Int] -> a) -> a?
04:27:08 <luite> kliko: no
04:27:17 <kliko> and then chain them together using continuations?
04:27:22 <kliko> oh... then I misunderstood
04:27:24 <luite> but you're close
04:27:26 <sopvop>  start push 5 push 5 add id -> [5,5], whoa It works. cps is weird
04:27:37 <luite> you're right about the continuations
04:29:03 <luite> kliko: stop shoud be easy now
04:29:18 <kliko> yes, I used cps in another program
04:29:24 <kliko> Assignment 1
04:29:38 <kliko> but I wonder why can't I do this with monads?!
04:33:13 <kliko> My store type is btw this: a -> [a] -> ([a] -> t) -> t
04:33:19 <kliko> is this correct?
04:33:50 <luite> kliko: swap the first two
04:33:56 <kliko> even though I've used CPS once, it's kind of a hard concept to grasp :(
04:34:13 <sopvop> push :: [a] -> a -> ([a] -> t) -> t -- here is mine
04:34:21 <luite> see :p
04:35:03 <mm_freak> kliko: ContT is mind-bending, but the CPS concept is actually fairly straightforward
04:35:33 <mm_freak> in fact, implementing ContT helped me both to get a better understanding of CPS and what you can do with it
04:36:03 <sopvop> cps is harder than lens :(
04:36:41 <mm_freak> i find van laarhoven (did i spell that right?) lenses much harder to understand than the basic concept of CPS
04:37:07 <Timmi_> @pl (\x -> even x)
04:37:07 <lambdabot> even
04:37:07 <kliko> omg
04:37:09 <kliko> it works
04:37:11 <kliko> omfg
04:37:15 <kliko> =.="
04:37:18 <kliko> ARE YOU SERIOUS?
04:37:19 <sopvop> basic concept is one thing, usage is other :)
04:37:26 <mm_freak> and if MonadFix wouldn't be so utterly incompatible with CPS i'd probably use it a lot more
04:37:26 <kliko> =.="
04:37:32 <kliko> I feel really stupid
04:37:36 <kliko> and I feel really dumb
04:37:49 <kliko> I still do not understand why it doesn't work with monads
04:37:56 * sopvop also feels stupid
04:38:13 <sopvop> lets thank luite for making us feel stupid
04:38:26 <kliko> \me asking sopvop why are you feeling stupid even though you implemented it faster than me?
04:38:42 <sopvop> because I thought it can't be implemented
04:38:45 <kliko> lol
04:39:10 <kliko> this is sad...
04:39:25 <kliko> XD
04:40:01 <kliko> im now going to try implementing it the program type check thing
04:40:06 <kliko> were it prevents it from failing
04:40:14 <mm_freak> given a CPS-style function of type (a -> r) -> r, what confused me most in the beginning is the final "-> r"
04:40:41 <mm_freak> but that makes sense when you understand that continuations in haskell are always delimited
04:41:26 <vraid> what does the final r mean?
04:42:07 <mm_freak> vraid: it's a function that doesn't return a result, but instead passes it to a continuation, which (and that's the important part) returns the final result
04:42:35 <mm_freak> 'r' is the type of the final result…  if you pass 'id' as continuation, then 'r' gets unified with 'a'
04:42:58 <mm_freak> > (\x k -> k (2*x)) 5 id
04:42:59 <lambdabot>   10
04:43:05 <mm_freak> :t \x k -> k (2*x)
04:43:07 <lambdabot> Num a => a -> (a -> t) -> t
04:43:20 <vraid> what are continuations in this context?
04:43:32 <mm_freak> continuations in the sense of CPS
04:43:58 <shachaf> mm_freak: What's complicated about twanvl lenses?
04:44:10 <rk_> hi
04:44:12 <shachaf> mm_freak: If you understand mapM and you understand Applicative, you understand twanvl-style lenses.
04:44:17 <shachaf> hi Argue
04:44:29 <Argue> hi shachaf
04:44:36 <rk_> hi there
04:44:42 <mm_freak> shachaf: i didn't say they are complicated, just that i find CPS easier to understand than them =)
04:44:54 <shachaf> True enough!
04:44:56 <Argue> i didn't realize you were from the _other_ irc channel
04:45:02 <shachaf> I'm not sure why you'd compare the two.
04:45:03 <shachaf> Argue: I'm not.
04:45:11 <shachaf> Argue: I'm more of an intruder.
04:45:13 <mm_freak> shachaf is everywhere
04:45:21 <mm_freak> i think he's spying on me
04:45:25 <Argue> D:
04:45:50 <rk_> just new to hackell; where exactly we use this stuff.
04:46:13 <rk_> anybody home ?
04:46:22 <shachaf> rk_: See the FAQ.
04:46:23 <shachaf> @where faq
04:46:23 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
04:46:24 <vraid> mm_freak: cheers, the CPS wikipedia article explains it well
04:46:34 <shachaf> mm_freak: Anyway, CPS can get pretty tricky sometimes.
04:46:38 <shachaf> At least, tricky to work with.
04:46:44 <shachaf> That's why we have compilers to do it for us. :-)
04:47:01 <shachaf> Unless we're using Haskell, that is.
04:47:22 <mm_freak> delimited continuations can get complicated
04:47:26 <t7> > 512 / 8
04:47:27 <rk_> mm_freak : whats that CPS
04:47:28 <lambdabot>   64.0
04:47:30 <Argue> I finsihed the coursera scala class recently; i don't think i'll ever be using scala again but i think it helped me figure out how to code better in haskell
04:47:39 <mm_freak> rk_: continuation passing style
04:48:05 <shachaf> Argue: Something specific to Scala, or just general learnin'?
04:48:07 <mm_freak> Argue: honestly i don't think that scala helps a lot with haskell
04:48:11 <Argue> just general
04:48:25 <shachaf> mm_freak: But general learnin' surely help with Haskell.
04:48:25 <sopvop> I find scala syntax disturbing
04:48:32 <Argue> i'm relatively new too; i went through bonus' book but not much else
04:48:34 <mm_freak> true
04:48:42 <shachaf> Argue: Are you using lenses yet? I heard lenses are "the cool thing to use".
04:48:46 <mm_freak> i find scala disturbing across the board
04:48:55 <Argue> if it's not in lyah i don't know what it is
04:48:56 <Argue> hahah
04:48:58 <sopvop> I have not looked deeper
04:49:37 <mm_freak> it's poor man's limited-to-imperative (because functional syntax makes you go mad) IO-based haskell
04:49:39 <shachaf> Argue: Should I pay my $10 like that one person keeps telling me to?
04:49:42 <sopvop> lenses are new monads, monads failed to scare of people. now haskell switched to lens as main weapon of intimidation
04:49:52 <shachaf> Lenses are simple.
04:49:58 <shachaf> "lens", on the other hand...
04:50:01 <Argue> wait how did you even find the channel if you didn't
04:50:29 <shachaf> I don't find channels. They find me.
04:51:16 <mm_freak> shachaf doesn't get wet; the water gets shachaf
04:51:36 <Argue> depends on how often you go on internet forums; i like it because it's meme-free and even the stupid people (of which there are many) have a minimum level of literacy
04:51:47 <sopvop> Yoda style
04:52:10 <sopvop> Argue: Thank you for kind words
04:52:14 <latermuse> sopvop: Halt. This is a meme-free zone.
04:52:27 <Argue> sopvop, wat
04:52:30 <sopvop> trespassers will be shot
04:53:01 <sopvop> Argue: you meant #haskell right?
04:53:06 <kliko> can I determine whether a list is empty in the type?
04:53:24 <Argue> sopvop, nope, but you guys are cool too :P
04:53:38 <mauke> #haskell is full of memes
04:53:39 <sopvop> Kliko: you can make data NotEmpty = NotEmpty a [a]
04:53:45 <shachaf> #haskell is pretty awful.
04:53:52 <kliko> yes I was wondering
04:53:53 <kliko> whether
04:53:56 <kliko> I had to make
04:53:56 <Argue> okay, so lenses are a pattern and not some new syntax then
04:53:56 <sopvop> and shachaf is grumpy
04:53:59 <kliko> a new datatype
04:54:04 <shachaf> sopvop: Yep.
04:54:32 <kliko> cause in Haskell, I always have the feeling it can be simpler and shorter and I shouldn't doing things unneccessary
04:55:25 <sopvop> http://goo.gl/TAOnQ <- shachaf
04:55:39 <shachaf> kliko: There's no NonEmpty in the standard library, but some packages on Hackage provide one.
04:55:42 <shachaf> E.g. semigroups.
04:55:45 <shachaf> Also, you don't have to press the enter key after every three words. :-)
04:56:17 <ion> Press it every one word
04:56:35 <shachaf> ion: Why wait for the end of the word?
04:56:37 <sopvop> and never release shitf
04:56:54 <sopvop> shitf - is like printf
04:57:29 <shachaf> Hilarious.
04:57:54 <ion> I.e. not type-safe?
04:58:01 <ion> That’s appropriate given the name.
04:59:05 <sopvop> not safe for work.
05:00:19 <ion> not type-safe for work
05:01:15 <vraid> shachaf: i believe frequent use of the enter key is based on the motto "commit early, commit often"
05:01:57 <sopvop> then get no fast-forward for you!
05:21:34 <mSSM> From what module does that `singleton' function in http://hackage.haskell.org/packages/archive/mwc-random/0.12.0.1/doc/html/System-Random-MWC.html come from?
05:21:46 <mSSM> (in the description of initialize)
05:26:17 <sopvop> mSSM Data.Vector
05:26:26 <sopvop> @hoogle singleton
05:26:27 <lambdabot> Data.Text.Lazy.Builder singleton :: Char -> Builder
05:26:27 <lambdabot> Data.ByteString.Char8 singleton :: Char -> ByteString
05:26:27 <lambdabot> Data.ByteString.Lazy.Char8 singleton :: Char -> ByteString
05:28:27 <mSSM> sopvop: well, none of those is Data.Vector :)
05:29:26 <sopvop> why @hoogle does not know vector?
05:29:33 <int-e> kliko: ok, finally have a solution (including part 2, the builtin type checking). I had to stop thinking about types and rely on my untyped lambda calculus experience.
05:31:55 <ramses_> can a function defined in a where clause or let binding be defined with multiple patterns?
05:32:02 <shachaf> Yes.
05:32:24 <mauke> spoilers: your whole file is a where clause
05:39:06 <sonOfRa> I'm currently trying to implement a function mapT for a Tree datastructure which looks like this: http://hpaste.org/78468
05:39:39 <sonOfRa> Something I am not sure about, is how I would do so, concerning the Signature of the function(s) passed to mapT
05:40:39 <merijn> sonOfRa: Why do nodes and leaves have different types? Is that important?
05:40:51 <sonOfRa> It is a task, and the Datatype was predefined
05:41:25 <merijn> Then it depends on how the task is described...
05:41:34 <sonOfRa> What I was considering is, should mapT be able to check the structure of the Tree, so I pass a function like (Tree a b -> Tree c d), or rather I can only change the objects itself, (a -> b)
05:41:47 <sonOfRa> it isn't described at all, it just says create a mapT function similar to map
05:42:29 <fmap> I'd ask TA about type signature of mapT
05:43:26 <sopvop> mapT :: ( a -> c) -> (b -> c) -> Tree a b -> [c]?
05:43:43 <sonOfRa> mapT :: ( a -> c) -> (b -> c) -> Tree a b -> Tree b c
05:43:44 <sopvop> Oh, map
05:44:01 <sopvop> more like a -> b  c-> d maybe
05:44:06 <sonOfRa> I guess that would be the most sensible declaration
05:44:14 <sonOfRa> yeah
05:45:46 <kliko> I've defined a new datatype that prevents me from popping an empty stack. My store function is now like this
05:45:47 <kliko> store :: Num a => List' [a] b -> a -> (List' [a] c -> a) -> a
05:46:02 <kliko> However as I indicated that b and c don't need to be the same type
05:46:16 <kliko> but somehow I still get a type error
05:46:38 <fmap> sonOfRa: okay, so given (a -> b) you can map leaves, and given (c -> d) you can map nodes
05:46:52 <sonOfRa> yep, that's what I think I need to do.
05:47:36 <sonOfRa> I was just wondering, if I should give mapT :: ((Tree a b) -> (Tree c d)) -> Tree a b -> Tree c d
05:47:38 <fmap> I'd start with writing simpler functions `(a -> b) -> Tree a c -> Tree b c' and `(a -> b) -> Tree c a -> Tree c b'
05:48:01 <sonOfRa> so I can access attributes like the height of the tree inside of the function that manipulates the eleents
05:48:23 <kliko> nvm I see my mistake
05:48:26 <sonOfRa> So I could say something like "If that subtree has a height of at least 5, replace it with something else"
05:48:27 <kliko> thanks for everything guys!
05:50:13 <ocharles> is there anyway to get cabal install --only-dependencies install new versions of dependencies? I had a dependency on lens >= 3.0.6, but now that's lens >= 3.4 and my continuous integration server has blown up
05:52:09 <ocharles> cabal-install 1.14
05:52:45 <sopvop> --upgrade-dependencies
05:52:52 <ocharles> still no good
05:52:52 <sopvop> or something similar
05:53:04 <ocharles> https://gist.github.com/bc5374f7d4acdaa068cf
05:53:15 <ocharles> oh
05:53:17 <ocharles> i guess i need to cabal update
05:53:28 <sopvop> Warning: The package list for 'hackage.haskell.org' is 26 days old.
05:53:29 <sopvop> :)
05:53:34 <ocharles> yea, and 3.4 isn't in the list of options :)
05:53:48 <fmap> sonOfRa: `mapT :: ((Tree a b) -> (Tree c d)) -> Tree a b -> Tree c d' doesn't look "similar to map" for me
05:53:51 <sopvop> edwardk releases fast, often, and major versions
05:53:53 <ocharles> cabal install then works properly
05:53:54 <ocharles> ye
05:53:55 <ocharles> a
05:54:57 <sonOfRa> fmap, that's what we thought to. But we thought in map it might be convenient to access something like a subtree and depending on that subtree, do something. However map can't do that on lists either, can't access the list's length it is applied on, or can it?
05:55:48 <latermuse> why doesnt the function "setFileMode" from System.FilePath.Posix work correctly? I am using "setFileMode writeDirectory 755" and it isnt chmodding the directory to 755
05:56:30 <bartavelle> octal ?
05:56:35 <typoclass> latermuse: those numbers like "755" are meant to be octal (not decimal). chmod and tools like that interpret them as octal
05:56:47 <`nand`> > 0o755
05:56:51 <typoclass> latermuse: try 0o755 in your haskell program (755 is always a decimal number)
05:56:54 <`nand`> lambdabot?
05:57:15 <typoclass> `nand`: she's gone to the pub
05:57:16 <latermuse> its meant to be octal
05:57:20 <latermuse> had no clue
05:57:25 <fmap> sonOfRa: If it could then its type would be `([a] -> [b]) -> [a] -> [b]' ;)
05:57:39 <latermuse> its not very obvious in the hackage documentation that it should be octal.
05:57:56 <typoclass> latermuse: i bet "setFileMode ... 755" did set some mode, but a weird one ...
05:58:06 <latermuse> yeah, some reall strange mode
05:58:55 <sopvop> 755 == 0o1363
05:59:11 <latermuse> -wxrw--wt
05:59:18 <latermuse> hah
05:59:21 <sopvop> what is t?
05:59:25 <typoclass> latermuse: yes, documentation is often something that could be improved in haskell. but most maintainers happily accept patches
05:59:39 <typoclass> sopvop: "sticky bit". it's like on /tmp
05:59:47 <latermuse> typoclass: is it intuitive to send a patch? I would like to patch a whole bunch of stuff.
05:59:51 <`nand`> over plate :: Plated t => (t -> t) -> t -> t
05:59:55 <`nand`> if it's done with darcs, yes :)
06:00:01 <`nand`> git? probably not ;)
06:01:11 <typoclass> latermuse: i think you could do "cabal unpack base", edit the things, then do something like "diff -R . > documentation-updates.patch". i'm not sure about the exact diff switches but people can help you with that
06:01:38 <latermuse> then email it to someone?
06:02:08 <typoclass> latermuse: yup :-) it's listed in the base.cabal file (must be ghc-libraries@ or something)
06:02:20 <`nand`> the darcs workflow would be: 1. darcs get http://link.to/repository 2. darcs record (to create the patch) 3. darcs send (to send it to the maintainer as an e-mail)
06:04:16 <latermuse> thanks
06:06:10 <mSSM> Is there a smarter way to write the `totalEnergy' function? http://hpaste.org/78469 The list comprehension looks ugly
06:07:55 <typoclass> latermuse: anyway, huge kudos if you do send a patch :-) the insufficient haddocks everywhere are bugging me as well
06:08:34 <latermuse> I am going to figure out how to send patches after I finish getting this chmod to work correctly
06:35:47 <latermuse> why is there no mod_haskell for apache?
06:36:04 <neutrino_> hi
06:37:00 <byorgey> latermuse: just a wild guess -- because no one has written one.
06:37:11 <neutrino_> i have a question about concurrent programming
06:37:54 <BrianHV> I also think the trend these days is away from language-specific apache modules and towards things along the lines of fastcgi (but not that... there's something newer out there whose name eludes me right now)
06:38:00 <sopvop> latermuse: Apache can work as a proxy afaik
06:38:52 * sopvop starts his snap app at port 9000 and points nginx to it
06:39:02 <byorgey> neutrino_: no one can answer your question unless you ask it.
06:39:46 <neutrino_> i'm typing :))
06:40:13 <byorgey> ok =)
06:40:40 <neutrino_> i want to be able to launch a process (make) with the stdout and stderr being processed
06:40:48 <byorgey> mSSM: any particular reason you're using a list instead of an immutable array?
06:41:13 <neutrino_> i understand i need to 1) fork to a thread and 2) exec in the child thread
06:41:21 <neutrino_> however, how can i send stdout/err to the parent thread?
06:42:21 <aaronj1335> i've got a data type "Constraint" that's an instance of Eq but not Ord. i'd like to make a set of Constraint's, but Data.Set requires an instance of Ord. is there an un-ordered set?
06:42:36 <typoclass> neutrino_: i'd use System.Process or some such
06:43:14 <rwbarton> neutrino_: you don't need to do any of that (manually)
06:43:18 <rwbarton> @hoogle runInteractive
06:43:26 <rwbarton> oh
06:43:27 <neutrino_> in the parent thread, i want to do the following things: 1. write stdout to the file make.stdout immediately as it comes in 2. write the stderr to make.stderr 3. write both stdout and stderr to make.both, but each line should be prepended with either "stdout> " or "stderr> " 4. every time stdout or stderr happens, if it happened more than a second ago, i would like to update a timestamp in an sqlite db
06:44:20 <byorgey> aaronj1335: no, just use a list
06:44:29 <byorgey> aaronj1335: Data.Set uses Ord for efficiency
06:45:01 <rwbarton> neutrino_: start with runInteractiveCommand or runInteractiveProcess and then spawn off threads to handle each of stdout/stderr
06:45:08 <neutrino_> oh, and it would be nice to be able to 5. collect the whole output in a single variable
06:45:20 <neutrino_> rwbarton: interesting
06:45:23 <typoclass> (hm ... if i mention the module and rwbarton mentions the function from that module, does it still count as magnificent stereo?) :-)
06:45:44 <byorgey> aaronj1335: Data.List does actually have some "set-like" operations; see http://hackage.haskell.org/packages/archive/base/latest/doc/html/Data-List.html#g:20
06:45:52 <donri> latermuse: one reason might be that the haskell rts is really good for embedding servers with your app. that's not usually true for mod_foo languages
06:46:00 <neutrino_> rwbarton: however: if i runinteractive without forking off, then the exec'd process will have the pid of my parent thread, right?
06:46:01 <donri> well, ghc rts
06:46:05 <rwbarton> you might even want a third thread to write to make.both
06:46:20 <rwbarton> no
06:46:20 <byorgey> aaronj1335: however, I should also ask, is there some fundamental reason that Constraint can't have an Ord instance?  Or is it just that you don't want to think of them as ordered?
06:46:28 <latermuse> donro: rts being the type system?
06:46:30 <rwbarton> you cannot fork() or exec() directly in haskell
06:46:40 <neutrino_> rwbarton: i thought you could exec in haskell
06:46:46 <rwbarton> all the System.Process stuff takes care of both the fork and the exec for you
06:46:47 <byorgey> aaronj1335: if the latter, you can just give them any old Ord instance and it will work with Set; you don't have to use it for anything else
06:46:57 <neutrino_> there definitely was an exec of some sort
06:47:00 <donri> aaronj1335: is the problem that Constraint isn't your type? you could use StandaloneDeriving to derive Ord
06:47:04 <rwbarton> well, maybe but you don't want to
06:47:08 <rwbarton> you really can't fork() safely
06:47:20 <neutrino_> oh, one more thing i need is to be able to get make's pid
06:47:26 <donri> it's gonna be an orphan though :(
06:47:50 <byorgey> everyone is always so uptight about orphan instances.  I don't see what the big deal is.
06:48:05 <neutrino_> just give them some matches to sell
06:48:20 <byorgey> yep, or teach them to pickpocket
06:48:26 <donri> byorgey: the deal is you can't control their import/export
06:48:42 <byorgey> that is a deal but it isn't a BIG deal.
06:48:52 <donri> shrug :) i do use orphans
06:49:03 <rwbarton> it's particularly not a big deal in an application
06:49:08 <rwbarton> as opposed to a library
06:49:12 <byorgey> right
06:49:23 <donri> good point
06:49:55 <donri> latermuse: rts being the runtime system
06:50:36 <rwbarton> neutrino_: hmm you can get a ProcessHandle that will allow you to kill or wait on the process
06:50:45 <rwbarton> I'm not sure how you can get a PID out of that
06:51:34 <rwbarton> presumably that requires some more posix-y stuff
06:53:08 <donri> latermuse: point is that i can embed a scalable webserver in my app executable and if need be reverse proxy that with nginx or apache ... in many other languages it's not that easy, and you need multiple "worker processes" and special servers that don't embed with your app directly
06:53:22 <aaronj1335> byorgey: i guess i didn't want to derive Ord on Constraint just b/c my constraints are un-ordered
06:53:32 <donri> latermuse: ... so having mod_language can be beneficial for those languages because it lets apache deal with the workers and such
06:53:57 <aaronj1335> byorgey: i'l try that tho, b/c i don't have an opposition to Ord, just didn't know what to do w/ it
06:54:09 <donri> latermuse: but anyway if you really want to i think you can run wai with fastcgi, which is kinda like mod_haskell
06:54:26 <aaronj1335> donri: Constraint is my type, so if it's as easy as adding deriving(Ord), then i'm ok
06:54:33 <merijn> rwbarton: Wait, why can't I fork safely in haskell?
06:54:52 <neutrino_> rwbarton: yeah i think i've had this conversation here like 2 months ago and the idea was to fork and exec :)
06:55:03 <donri> aaronj1335: yea that should be all you ned
06:55:06 <donri> need
06:55:26 <neutrino_> rwbarton: check this out: http://haskell.1045720.n5.nabble.com/Can-t-establish-subprocess-communication-td4988219.html
06:55:47 <basdirks_> I'm sure this has been discussed before and decided upon, but why hasn't hackage been tweaked to show up only (or primarily) latest versions of packages?
06:56:03 <basdirks_> *in google ..
06:56:03 <uniquenick> how can I tell "cabal install" to generate a statically linked executable?
06:56:29 <typoclass> neutrino_: please refer to http://hackage.haskell.org/packages/archive/process/latest/doc/html/System-Process.html , it really answers most of your questions
06:56:42 <typoclass> merijn: *shrug* i think System.Process is perfectly alright
06:56:54 <donri> basdirks_: not sure it would be that easy to do with robots.txt and the current url scheme on hackage ...
06:57:03 <rwbarton> neutrino_, well that suggestion is crazy :P
06:57:09 <quchen> uniquenick: I think it's cabal install [package] --enable-shared
06:57:27 <basdirks_> donri, it should be possible
06:57:44 <rwbarton> the ghc RTS really does not expect to be forked
06:57:52 <dcoutts> uniquenick: I presume you mean statically linked against C libs, it defaults to static linking against Haskell libs
06:57:59 <typoclass> basdirks_: i agree, man. it's bugged me a thousand times
06:57:59 <neutrino_> rwbarton: huh?
06:58:05 <neutrino_> rwbarton: what is forkProcess then?
06:58:13 <aaronj1335> donri: sorry, n00b question, but i added "data Constraint = … deriving (Show, Eq, Ord)" and got the error "No instance for (Ord Type)", do i need to import something else?
06:58:30 <uniquenick> statically linked against everything, so I can copy it to a bunch of machines and not have to install anything else on them
06:58:35 <neutrino_> http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-Process.html#v:forkProcess
06:58:40 <typoclass> dcoutts: ohai, do you have control over hackage.haskell.org? we were just wondering if we could change robots.txt there
06:58:45 <donri> basdirks_: well how do you distinguish between a version-specific page and another package sharing a prefix name? with just wildcards
06:59:12 <neutrino_> rwbarton: did you mean that the ghc RTS does not expect forkProcess? i'm not sure
06:59:18 <neutrino_> i've never done any concurrent programming in haskell
06:59:22 <basdirks_> well /latest seems like something that you can filter on
06:59:32 <dcoutts> typoclass: I don't have write access to the robots.txt file, ask Igloo
06:59:35 <basdirks_> robots.txt isn't the only thing in existence to influence things with
06:59:54 <typoclass> dcoutts: alright, thanks
07:00:21 <donri> basdirks_: ah yea i haven't looked too closely at those sitemap things and whatnot
07:00:26 <basdirks_> yeah
07:00:48 <rwbarton> neutrino_: did you see the huge warning on forkProcess?
07:00:49 <donri> basdirks_: anyway i don't think anyone is working on hackage1 but maybe you could file a feature request for hackage2
07:01:02 <rwbarton> you don't use forkProcess to do concurrent programming in Haskell
07:01:15 <donri> basdirks_: the bug tracker is https://github.com/haskell/cabal/issues
07:01:20 <basdirks_> donri okay, I do "SEO" as part of day job, and would like to help
07:01:44 <donri> basdirks_: it's a good idea, i've been annoyed by this myself
07:02:41 <typoclass> basdirks_: i think everyone will thank you if you manage to solve that issue
07:02:43 <basdirks_> If I make a proposal, will it be considered?
07:03:16 <merijn> basdirks_: Sure, I think if you go to -cafe or something with a reasonable proposal you could probably get together with the right people to fix things
07:03:42 <rwbarton> same problem for the ghc user guide on www.haskell.org, too
07:03:53 <merijn> I think things are mostly run on a "someone was annoyed enough to volunteer to fix it" as most open source projects are :p
07:04:06 <basdirks_> yeah but this isn't rocket science
07:04:32 <basdirks_> as opposed to the usual topics discussed in this channel
07:04:49 <basdirks_> which is why I find it strange that it hasn't been taken care of before
07:04:50 <aaronj1335> donri: scratch that, Constraint composed another one of my types, Type, which also needed to be deriving Ord. i added that and it's cool, thanks for your help!
07:07:58 <rwbarton> people are eager to fix the things that require rocket science :)
07:08:15 <typoclass> basdirks_: could be any number of reasons ... don't worry about that :-) if you could make a proposal, that would be awesome. if there's any disagreement on the bug tracker, i bet #haskell will provide plenty of arguments in favor of your proposal
07:08:37 <kalli> Hi, question:
07:09:06 <kalli> thanks to lazyness I can do "head [1,2,undefined]" and get 1
07:09:22 <basdirks_> the url scheme seems pretty reasonable too actually
07:09:28 <kalli> but "head [1,2,[3,4]]" is an error
07:09:30 <kalli> why?
07:09:31 <basdirks_> for the indexing we want
07:09:41 <shachaf> kalli: Because [1,2,[3,4]] is an error.
07:09:46 <shachaf> What would be its type?
07:09:58 <kalli> what is the type of [1,2,undefined] ?
07:10:03 <shachaf> Haskell may be lazy, but type checking is strict. :-)
07:10:05 <sopvop> kalli: [1 :: Int, 2 :: Int, undefined :: Int, [3,4] ::[Int]]
07:10:08 <shachaf> kalli: undefined :: Int
07:10:16 <DrSyzygy> Graargh.
07:10:27 <sopvop> :t undefined
07:10:33 <DrSyzygy> I need to be able to interface with both Database.Redis and Network.AMQP in the same application.
07:10:49 <kalli> oh, so because I included undefined in a list of Ints, haskell assumes it is an Int too?
07:10:52 <DrSyzygy> One talks only in Data.ByteString.Lazy.ByteString.Char8, the other one only in strict ByteStrings.
07:11:01 <DrSyzygy> Is there any reasonable way to go back and forth?!
07:11:26 <Saizan> there's a way
07:11:29 <sopvop> kalli: undefined :: a, it can be anything.
07:11:45 <eikke> DrSyzygy: LBS.fromStrict/toStrict ?
07:12:06 <DrSyzygy> eikke: Ooooh. I'll give those a try
07:12:06 <kalli> thanks alot
07:12:16 <kalli> understand now I think
07:14:16 <typoclass> "Haskell may be lazy, but type checking is strict." <- heh, i guess those "dynamic" languages have lazy type checking more or less
07:17:28 <DrSyzygy> yeah, updating to a less ancient bytestring now. *chugchugchug*
07:17:43 <DrSyzygy> also probably should update my base package. Annoying to not be able to strictly modify an IORef
07:18:15 <eikke> DrSyzygy: should be trivial to write a strict version yourself ;)
07:18:48 <eikke> DrSyzygy: and about the BS version, indeed, it's rather recent AFAIK (>= 0.10 IIRC)
07:19:08 <arcatan> DrSyzygy: remember that to upgrade base is to upgrade GHC
07:19:12 <DrSyzygy> eikke: The strict one exists! just in base 4.6.0 not earlier
07:19:26 <DrSyzygy> ... and I just now moved up to the latest stable haskell platform, so a bit surprised that doesn't work for me...
07:19:38 <DrSyzygy> hmmm
07:19:50 <DrSyzygy> or maybe I did the upgrade after failing with modifyIORef'
07:20:17 <DrSyzygy> errr
07:20:28 <DrSyzygy> if everything else was built against a different bytestring, how do I upgrade them with cabal?
07:20:41 <rwbarton> not worth it
07:20:41 <sopvop> upgrade everything
07:20:53 <sopvop> hope you have a sandbox
07:20:57 <dcoutts> DrSyzygy: cabal install {the things you want} --constraint='bytestring == x.y.z'
07:21:08 <dcoutts> oh and --dry-run
07:21:34 <eikke> does the latest HP contain GHC 7.6?
07:21:41 <rwbarton> no
07:22:02 <eikke> hmh, I thought base 4.6.0 comes with 7.6
07:22:04 <eikke> my bad :)
07:22:16 <mSSM> byorgey: no particular reason; but I thought it's easier to work with a list.
07:22:42 <DrSyzygy> ... and doing that will break haskell-platform
07:22:43 <mSSM> byorgey: and then after it's running, change the thing to use an array
07:23:01 <DrSyzygy> wtf
07:23:04 <fmap> eikke: it does
07:23:26 <rwbarton> upgrading packages like bytestring that come with ghc is the kind of thing that can work in theory but is rarely worthwhile in practice
07:23:27 <fmap> (base 4.6.0.0 is from ghc 7.6)
07:23:28 <mSSM> byorgey: but now I realize that I have to slize my list, change one element, and put the list back together; is that easier with an array?
07:23:40 <rwbarton> particularly if you have a gazillion packages already built against the old version
07:24:15 <eikke> DrSyzygy: OTOH modifyIORef' r f = readIORef r >>= \v -> let v' = f v in v' `seq` writeIORef r v'
07:24:17 <DrSyzygy> rwbarton: I'm happy not upgrading too; only I need to be able to move between lazy and strict bytestrings.
07:24:26 <DrSyzygy> because one package I'm using uses the one, another package uses the other
07:24:37 <rwbarton> amazingly other people have needed to do this before 0.10, too :)
07:24:47 <rwbarton> S.concat . L.toChunks
07:24:55 <rwbarton> L.fromChunks . (:[])
07:24:56 <eikke> DrSyzygy: for bytestring conversion, you could also use toChunks and concat
07:25:10 <DrSyzygy> rwbarton: Oooooooh! Thanks! That other one I hadn't seen
07:25:10 <eikke> doh
07:29:18 <neutrino_> is there something like $ but for types?
07:29:26 <DrSyzygy> AWESOME!
07:29:29 <DrSyzygy> Thank you rwbarton!
07:29:42 <DrSyzygy> rwbarton: You'd be surprised at how hard that second line is to piece together from googling. :-/
07:31:17 <eikke> DrSyzygy: looking for "strict" in the LBS api page could have helped a lot ;)
07:31:19 <rwbarton> funny, google does seem much more interested in answering the reverse question
07:31:40 <eikke> DrSyzygy: only 8 occurrences in 0.9.2.1, of which 5 in actual function docs
07:33:08 <DrSyzygy> eikke: Next you'll expect me to read the docs of the version I'm actually using!
07:33:42 <eikke> hmh, that might be a good idea actually. thanks!
07:37:36 <latermuse> hey guys, can you help me figure out why this cgi script wont work correctly? I keep getting some strange strange type errors that I cant understand. (uploading to hpaste now)
07:37:45 <hpaste> latermuse pasted “cgi woes” at http://hpaste.org/78471
07:38:45 <borkdude> I have a little question about a function from RWH: https://www.refheap.com/paste/7137
07:39:00 <borkdude> what does dollars refer to?
07:39:10 <borkdude> chapter 8
07:39:26 <borkdude> I adapted it to work with String instead of lazy bytestring
07:39:26 <rwbarton> latermuse: getArgs is an IO action, and CGI is (presumably) not the same as IO
07:39:34 <int-e> latermuse: getArgs is in IO not CGI. You can use  liftIO getArgs  instead
07:40:42 <latermuse> Oh neat. Thanks for the help!
07:40:45 <quchen> borkdude: dollars is not in scope there.
07:40:53 <quchen> (i.e. compile error)
07:41:02 <typoclass> borkdude: could you link to the rwh chapter where that function came from?
07:41:17 <borkdude> http://book.realworldhaskell.org/read/efficient-file-processing-regular-expressions-and-file-name-matching.html
07:41:31 <rwbarton> borkdude: oh, lines 7-8 need to be more indented
07:41:32 <latermuse> like this? arguments <- liftIO getArgs;
07:41:45 <int-e> latermuse: yes
07:42:09 <latermuse> doing that gives me this error: '
07:42:17 <latermuse> Couldn't match expected type `CGIT IO a0' with actual type `IO ()'
07:42:18 <letsstartwedding> hello
07:42:28 <int-e> latermuse: check the line number
07:42:55 <latermuse> Update.hs:12:5:
07:43:44 <quchen> borkdude: https://www.refheap.com/paste/7138
07:44:09 <latermuse> do I need to run liftIO on "make arguments" also?
07:44:19 <rwbarton> is it an IO action? then yes
07:44:44 <latermuse> wonderful. it compiled after I did that :D
07:45:04 <latermuse> is a cgi script going to be able to accept arguments passed to it via the web browser?
07:45:52 <rwbarton> I should hope so
07:45:58 <latermuse> :D
07:46:02 <typoclass> borkdude: yes, indentation is significant in haskell. check the original function and the one that quchen pasted. the structure is: "case {stuff} of ... -> {some case} ... -> {some other case}", and then inside of one of the cases, you have another "case"
07:46:04 <latermuse> wonderful. thanks for the help!
07:46:05 <rwbarton> I forget how CGI works exactly, do you really want getArgs?
07:46:20 <rwbarton> probably there are some CGI actions in Network.CGI that give access to the parameters
07:46:24 <latermuse> rwbarton: im not sure, but im going to be using getArgs until I figure out a better way
07:46:24 <int-e> probably not. getInputs  looks better
07:47:29 <latermuse> int-e: that does look better
07:47:45 <letsstartwedding> can someone help me with forum posting?
07:48:57 <quchen> borkdude: As a remark, as indentation is relevant, you may want to consider indenting a little bit more. I suggest at least 4 spaces, I use 6, many even 8.
07:50:06 <quchen> Benefits include that you hit the right margin earlier, forcing you to break your functions apart in smaller chunks, and it makes it very hard to mess up the alignment of blocks. The difference between 6 and 8 spaces indentation is much less obvious than between 18 and 24.
07:53:00 <borkdude> quchen I'm trying out this function isolated from bytestreams, what function can I use to read from a String to a Maybe Int?
07:53:18 <borkdude> quchen tnx for the advice
07:53:33 <quchen> You want to parse a string to an Int, that is?
07:53:49 <borkdude> quchen yes, but I need a function of type String -> Maybe Int
07:54:16 <borkdude> quchen sorry, I'm a complete Haskell noob
07:54:45 <Mortchek> :t readMaybe
07:55:16 <Mortchek> Oh, it's maybeRead
07:55:25 <quchen> borkdude: a) That's nothing to apologize for b) that's what this channel is for c) so am I
07:55:30 <statusfailed> Is there an iterative algorithm for calculating the n-th moments of some data?
07:55:40 <letsstartwedding> no one can help :(
07:55:45 <statusfailed> I know there's Welford's algorithm for variance, but I was wondering if it generalised
07:56:10 <borkdude> Mortchek from which package?
07:56:56 <quchen> borkdude: Text-Read.html (If Hoogle doesn't work, try Hayoo!)
07:57:17 <quchen> Woops, paste error. Text.Read is the module.
07:57:37 <quchen> http://hackage.haskell.org/packages/archive/base/latest/doc/html/Text-Read.html#v:readMaybe
07:58:05 <rwbarton> that's from the future though
07:58:09 <quchen> (I wonder why Hoogle doesn't show this one. It's in Base, after all.)
07:58:10 <rwbarton> unless you are using ghc 7.6 already
07:58:24 <typoclass> borkdude: try the function 'reads' directly, or wrapped as described in http://www.haskell.org/haskellwiki/FAQ#How_do_I_catch_the_error_thrown_by_read_on_a_parse_failure.3F
07:59:11 <quchen> typoclass' idea might be better for compatibility
08:00:29 <quchen> (It's actually kind of similar to the way readMaybe is implemented)
08:00:38 <merijn> typoclass, borkdude: The standard library now already includes a readMaybe :: Read a => String -> Maybe a
08:00:42 <merijn> Forgot where, though
08:01:15 <merijn> :t Text.Read.readMaybe
08:01:26 <merijn> oh, no lambdabot, sad :(
08:01:27 <neutrino_> merijn: lambdabot is gone :~(
08:01:27 <typoclass> ... uh, that Text.Read thingy isn't about Text, it's about Strings ...?
08:01:48 <merijn> typoclass: haddock says: readMaybe :: Read a => String -> Maybe a
08:02:05 <neutrino_> Text is Read a.
08:02:07 <typoclass> merijn: yes i saw it, i'm just surprised
08:02:10 <borkdude> merijn I tried import Text.Read(readMaybe) but it said: module doesn't export it
08:02:31 <rwbarton> you are not living in the future, then
08:02:33 <merijn> borkdude: Ah, which GHC version?
08:02:42 <typoclass> borkdude: have you seen the faq link? unless you have a very new compiler, you won't have that module
08:02:50 <merijn> It's reasonably new
08:03:01 <borkdude> ok
08:03:07 <quchen> borkdude: Are you using GHC?
08:03:35 <quchen> (I'm asking because the export of readMaybe is in an #ifdef __GLASGOW_HASKELL__)
08:04:01 <Mathnerd314> what's the best way to read GHC code? hscolour seems to barf on the literate haskell files: http://www.haskell.org/ghc/docs/latest/html/libraries/ghc-7.6.1/src/TcPat.html#addInlinePrags
08:05:48 <quchen> Mathnerd314: Solarized! http://ethanschoonover.com/solarized
08:06:44 <statusfailed> quchen: +1
08:06:56 <statusfailed> but: light or dark? :P
08:07:23 <Pantoufle> Does anybody know why we are still using fixed font?
08:07:32 <Mathnerd314> Pantoufle: indentation
08:07:32 <quchen> statusfailed: Light as I don't enjoy blinding myself every time I leave the editor
08:07:54 <Pantoufle> Mathnerd314: it can be done with tabulations easily
08:08:26 <Mathnerd314> tabs are generally forbidden in code
08:08:28 <borkdude> can I see the version from ghci?
08:08:35 <statusfailed> quchen: I have the same problem ... switching to browser is so painful after dark
08:08:50 <mSSM> Mixing Monadic/non-Monadic computation: http://hpaste.org/78474 the code in stepIsing isn't not correct, I know that, but: how do I properly mix monadic and non-monadic computations? On line 15 and 16, I need to do a monadic computation due to the random generator (`uniform'), but the remaining steps are not really monadic...  but I do need to present `isys'' in a monad again, right?
08:09:11 <Mathnerd314> quchen: that looks cool, howeever my problem was more about reading the Notes in a nice manner
08:09:30 <Mathnerd314> *however (I have an new keyboard; it's taking some getting used to)
08:09:46 <quchen> statusfailed: After battling the child in me that wants to have a super hacky Linux plus editor for years, I decided to switch all my editors to reasonable colors, and also my terminal.
08:09:50 <merijn> mSSM: This type can't be right "stepIsing :: GenIO -> Ising -> Double -> Ising"
08:10:10 <borkdude> ah, version 7.4.2
08:10:17 <quchen> Mathnerd314: Reading those specific notes? Oh well, the colors are hard-coded in HTML there.
08:10:19 <typoclass> quchen: 'super hacky' as in black background?
08:10:23 <merijn> mSSM: You are using IO values inside and have a return at the end, so there should be an IO in your result somewhere
08:10:25 <mSSM> merijn: yes, it would be IO ISing
08:10:45 <mSSM> merijn: sorry, I have not yet compiled the thing, so there are wrong statements
08:10:47 <hiptobecubic> I missed the beginning, but why would you do that
08:10:57 <quchen> typoclass: Yes, kind of.
08:11:00 <statusfailed> quchen: I was sad the day I finally stopped setting fractal wallpapers and using transparent aterms, but it's for the best :P
08:11:03 <hiptobecubic> Get the random part first and then make the value a parameter to the function?
08:11:25 <mSSM> hiptobecubic: sorry, are you referring to me?
08:11:26 <quchen> statusfailed: Fractal wallpapers? Let me guess, you also enjoy juggling chainsaws :-P
08:12:00 <statusfailed> hahah
08:18:59 <mSSM> Actually, I am getting a "parse error on input `else' on line 15 : what's wrong here? http://hpaste.org/78475
08:19:16 <Botje> you forgot a do
08:19:36 <mSSM> then do?
08:19:38 <mSSM> else do?
08:19:45 <Botje> both.
08:19:50 <Botje> and let doesn't work that way.
08:19:55 <Cale> mSSM: 'let' is not allowed to occur without 'in' unless as a statement of a do-block
08:20:14 <typoclass> Cale: ohai, we can haz lambdabot?
08:20:15 <typoclass> ;-)
08:20:17 <Botje> let isys' = if ... then update ... else do ...
08:20:33 <rwbarton> except there is an IO action in there also
08:20:43 <Cale> else p <- uniform gen :: IO Double
08:20:47 <Cale> yeah, that won't work
08:20:55 <rwbarton> doFlip <- if ... then return True else do { p <- ...; return (p < ...) };
08:21:04 <neutrino_> Cale: where's lambdabot :'(
08:21:09 <rwbarton> let isys' | doFlip = updateIsing ... | otherwise = isys
08:21:24 <rwbarton> (or use 'if' if you prefer)
08:21:47 <Cale> neutrino_: Still running, it's just really bad at deciding that it's disconnected.
08:21:54 <neutrino_> haha
08:21:56 <neutrino_> silly robots.
08:22:12 <neutrino_> at this rate we'll never see a cybernetic apocalypse.
08:22:21 <typoclass> Cale: thanks a lot
08:22:52 <akahn> what one or two or three options parsing libraries should I look into using?
08:23:44 <quchen> Parsec is a good start if you ask me.
08:24:01 <quchen> Bonus points because there's a chapter on it in Real World Haskell
08:24:02 <typoclass> akahn: i think people are quite fond of optparse-applicative or whatever the name is :-) i've only skimmed the github readme page, but it looks quite nice
08:24:22 <Cale> I have never heard of optparse-applicative
08:24:36 <typoclass> Cale: i thought it was fairly new
08:24:53 <hpaste> hamid pasted “What's wrong with my type signatures?” at http://hpaste.org/78476
08:24:57 <typoclass> https://github.com/pcapriotti/optparse-applicative <- nice documentation too
08:25:23 <akahn> thanks typoclass
08:25:39 <hamid> I can load them into ghci without their type signatures but they don't work :/
08:25:39 <akahn> quchen: I'm talking about command line options, not parsing text/data
08:26:17 <rwbarton> hamid: how are you loading them into ghci
08:26:20 <Cale> hamid: fib' n-1 means (fib' n) - 1
08:26:28 <rwbarton> oh
08:26:29 <neutrino_> hamid: put parens around n-1.
08:26:31 <hamid> Cale, ow!
08:26:38 <hamid> thank you :)
08:26:42 <neutrino_> - is a value, like anything else.
08:26:48 <hamid> rwbarton, :load file.hs :P
08:26:54 <Cale> also, you should configure your text editor to convert tabs to spaces
08:27:02 <rwbarton> i thought you meant it worked without the type signatures
08:27:10 <neutrino_> functions are values and values are functions
08:27:10 <rwbarton> i guess maybe it would, huh
08:27:12 <Cale> because while I don't think it has bitten you here, that will eventually get you :)
08:27:15 <neutrino_> hamid: yes, you should
08:27:21 <mSSM> rwbarton: thank you, I like that style of writing a lot. It's a lot cleaner.
08:27:34 <hamid> neutrino_, now I get it :) thanks
08:27:43 <donri> they should make -fwarn-tabs the default and an error
08:27:44 <neutrino_> hamid: and consider using variable names that are not one- or two-letter
08:27:59 <neutrino_> i wouldn't do it for n but i would do it for p and pp
08:28:29 <hamid> neutrino_, sure. just were writing a test case :)
08:28:40 <Cale> neutrino_: disagree here, except possibly to replace pp by q or something :)
08:29:01 <Cale> When a variable's scope is 2 lines being one letter doesn't matter.
08:29:04 <hamid> that is called curry ?
08:29:08 <neutrino_> hamid: ahh, cool
08:29:15 <rwbarton> well the formula is actually wrong here :P
08:29:27 <neutrino_> Cale: but it gives meaning.
08:29:27 <rwbarton> not sure whether using longer variable names makes that easier or harder to see though
08:29:56 <neutrino_> hey, guys
08:30:02 <neutrino_> i have a function foo which calls a function bar
08:30:10 <neutrino_> is there a way to run foo, but have it run baz instead of bar?
08:30:15 <neutrino_> without parametrizing foo over bar
08:30:44 <Cale> neutrino_: You have to parametrise foo over something
08:31:00 <rwbarton> sed s/bar/baz/
08:31:00 <Cale> neutrino_: When is it supposed to use baz?
08:31:08 <neutrino_> when i'm testing.
08:31:30 <Cale> CPP?
08:31:37 <neutrino_> cpp?
08:31:45 <hiptobecubic> C preprocessor
08:31:46 <Botje> or dynamically scoped bindings.
08:32:01 <neutrino_> what are dynamically scoped bindings?
08:32:44 <Cale> Maybe Botje means implicit parameters?
08:32:55 <Botje> uh, those, yes :/
08:33:06 <Cale> But they're not really dynamically scoped
08:33:19 <neutrino_> what are implicit parameters? :o
08:34:42 <neutrino_> :)
08:35:28 <developernotes> I am trying to run cabal configure on xmonad on OSX (https://bitbucket.org/puffnfresh/osxmonad), I've installed XQuartz already but I get an error saying the X11 dependency is missing >= 1.5 && <= 1.7.  Any suggestions for installing this?
08:36:30 <neutrino_> do you have X11?
08:36:40 <hiptobecubic> :D
08:37:35 <rwbarton> developernotes, first 'cabal install --dependencies-only'
08:38:03 <developernotes> neutrino_: I have XQuartz, which allows X11 to run on OSX.
08:38:11 <developernotes> rwbarton: ok, I will try that.
08:38:24 <rwbarton> it's referring to the haskell library 'X11'
08:38:30 <rwbarton> package, I should say
08:38:37 <developernotes> gotcha
08:38:45 <sm> morning all
08:39:18 <typoclass> developernotes: in general, it may help to do "-v3" on cabal. it will tell you in full detail why it decided to exclude this or that package, or why it decided to install them
08:39:35 <typoclass> (if you can't figure out the output, put it on hpaste. folks in here usually can)
08:39:41 <developernotes> rwbarton: I get "cabal: unrecognized option `--dependencies-only'"
08:39:58 <rwbarton> maybe i forgot the name
08:40:11 <rwbarton> oops, --only-dependencies :)
08:41:14 <developernotes> rwbarton: great - it's downloading the X11 library - thanks so much!
08:42:14 * hackagebot fb 0.13.4 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.13.4 (FelipeLessa)
08:42:24 <hamid> I have this "fib :: Num a => a -> a" what if I want my type _a_ to be derived from Eq and Ord two?
08:42:31 <hiptobecubic> ugh, FB bindings. I bet that's fun to maintain
08:43:10 <hamid> :t Int
08:43:11 <lambdabot>     Not in scope: data constructor `Int'
08:43:11 <lambdabot>     Perhaps you meant one of these: `In' (line 131), `InR' (line 138)
08:43:27 <rwbarton> fib :: (Num a, Ord a) => a -> a
08:43:34 <rwbarton> (Ord implies Eq)
08:43:43 <hamid> rwbarton, got it. thanks :)
08:44:00 <xos> how do I use the bot to turn ssq x y = x*x + y*y into combinator form
08:44:04 <elliott> you kids and your no superclasses of Num
08:44:09 <elliott> @pl \x y -> x*x + y*y
08:44:10 <lambdabot> (. join (*)) . (+) . join (*)
08:45:42 <otters> let ssq = (. join (*)) . (+) . join (*)
08:45:44 <otters> easy
08:46:10 <c_wraith> > ((+) `on` (join (*))) 3 4
08:46:10 <elliott> don't use that version though :p
08:46:12 <lambdabot>   25
08:46:16 <elliott> yeah c_wraith's is nice
08:46:24 <elliott> but probably just writing out the equation is best
08:46:34 <c_wraith> yeah, that's not nice
08:46:41 <c_wraith> it's just better than what @pl spits out
08:46:42 <c_wraith> :)
08:47:09 <neutrino_> @unpl  (. join (*)) . (+) . join (*)
08:47:09 <lambdabot> (\ d n -> (((*) >>= \ j -> j) d) + (((*) >>= \ e -> e) n))
08:47:15 <neutrino_> use that.
08:47:17 <elliott> c_wraith: I actually like that form :)
08:47:30 <elliott> but I am probably one of few who do
08:48:05 <t7> > 1 + 2 + 4 + 8 + 16 + 32
08:48:06 <rwbarton> @type uncurry (:+)
08:48:06 <lambdabot>   63
08:48:07 <lambdabot> (b, b) -> Complex b
08:48:21 <rwbarton> @type curry $ (^2) . magnitude . uncurry (:+)
08:48:22 <lambdabot>     Ambiguous occurrence `magnitude'
08:48:23 <lambdabot>     It could refer to either `Data.Complex.magnitude',
08:48:23 <lambdabot>                              imported from `Data.Complex' at State/L.hs:24:1-19
08:48:29 <rwbarton> @type curry $ (^2) . Data.Complex.magnitude . uncurry (:+)
08:48:31 <lambdabot> RealFloat c => c -> c -> c
08:48:35 <rwbarton> perfect
08:48:57 <elliott> rwbarton: could use some lenses there!!
08:49:02 <rwbarton> oh good call
08:49:06 <rwbarton> is there a "curry" lens??
08:49:09 <elliott> :t _magnitude
08:49:11 <lambdabot>     Not in scope: `_magnitude'
08:49:11 <lambdabot>     Perhaps you meant one of these:
08:49:11 <lambdabot>       `magnitude' (imported from Data.Complex),
08:49:17 <elliott> is that too new
08:49:22 <edwardk> rwbarton: should be.
08:49:36 <edwardk> rwbarton: i didn't write it yet but iso curry uncurry would work
08:49:43 <edwardk> :t iso curry uncurry
08:49:44 <lambdabot> (Functor f, Isomorphic k) => k ((a -> b -> c) -> f (a -> b -> c)) (((a, b) -> c) -> f ((a, b) -> c))
08:49:53 <rwbarton> delicious
08:49:56 <elliott> rwbarton: this is what happens when you make jokes about lens
08:49:59 <elliott> they come true
08:50:01 <edwardk> @let curried = isos curry uncurry curry uncurry
08:50:03 <lambdabot>  Defined.
08:50:15 <edwardk> i'll add that one =)
08:50:46 <xos> (. join (*)) . (+) . join (*)
08:50:52 <edwardk> :t curried
08:50:54 <lambdabot> (Functor f, Isomorphic k) => k ((a -> b -> c) -> f (a1 -> b1 -> c1)) (((a, b) -> c) -> f ((a1, b1) -> c1))
08:51:38 <roadfish> what is non-associative fixity? and what is it use for? in the case of "a?b?c", then is it "(a?b)?c" or "a?(b?c)" ... one or the other has to be chosen.
08:51:46 <elliott> roadfish: it's neither
08:51:48 <elliott> it spits out a compiler error
08:51:56 <elliott> (intentionally)
08:52:04 <elliott> you use it for operators with no meaningful associativity
08:52:14 * hackagebot uhc-util 0.1.0.2 - UHC utilities  http://hackage.haskell.org/package/uhc-util-0.1.0.2 (AtzeDijkstra)
08:52:47 <rwbarton> for example, <
08:53:01 <rwbarton> you don't want a < b < c to be (a < b) < c or a < (b < c) (and you can't get (a < b) && (b < c))
08:53:19 <Cale> i.e. infix functions which aren't operators in the mathematical sense
08:53:20 <robertoyzf> ?list
08:53:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
08:53:27 <robertoyzf> !list
08:53:27 <monochrom> robertoyzf: http://hpaste.org
08:53:31 <Cale> (usually)
08:54:10 <roadfish> ok, you can create and define non-associative infix operators but you may not apply explicit bracketing.
08:54:51 <roadfish> plus, you better be happy with what ever evaluation order is done. essentially, it is "undefined" and could even change between runs.
08:54:58 <rwbarton> what
08:55:04 <roadfish> ^^^ this is my interpretation ^^^
08:55:06 <elliott> roadfish: ???
08:55:08 <rwbarton> quite the opposite
08:55:17 <rwbarton> "a < b < c" is a compile error
08:55:18 <elliott> haskell functions are pure
08:55:23 <elliott> your result is not going to change over runs
08:55:35 <elliott> also what do you mean by "may not apply explicit bracketing"?
08:55:38 <rwbarton> you can write (a < b) < c if you want, as long as it type checks
08:56:06 <roadfish> ok, then I flipped the meaning of what you said. coming from Python, "a<b<c" makes perfect sense.
08:56:08 <hpaste> hamid pasted “Which style of coding do you prefer?” at http://hpaste.org/78477
08:56:19 <elliott> a non-associative operator simply means: (a OP b OP c) doesn't associate any way; it is just a syntax error.
08:56:24 <hamid> coding style* :P
08:56:25 <elliott> ((a OP b) OP c) is just fine assuming it typechecks, etc.
08:56:33 <rwbarton> python has weird special rules about <
08:57:02 <rwbarton> maybe it wasn't the best choice of example
08:57:23 <aaronj1335> is there a way to test that a function raises an exception via "error" call? i.e. assert that function f executes `error "my error message"`? i found this:  http://stackoverflow.com/a/6147930/5377, but that requires that the exception is an instance of Eq, so i don't think ErrorCall works here
08:57:58 <roadfish> ok, first question. Can you have two-or-more non-associative infix operators together? Yes/No ... and if Yes then is bracketing mandatory?
08:58:02 <tac> < in Python is syntax, so you have the option of interpreting it as an (n+1)-ary function, rather than a binary function
08:58:02 <edwardk> rwbarton: for you https://github.com/ekmett/lens/blob/8abeb7a98e1fea3b053ab77029bf39e9997d7e5e/src/Control/Lens/Iso.hs#L220
08:58:11 <elliott> rwbarton: (technically you can have a < b < c as a < b && b < c if you do some hideous hacking...)
08:58:37 <Cale> roadfish: if they are at different fixities then yes
08:58:42 <Cale> roadfish: otherwise no
08:59:01 <Cale> If you're bracketing things then the fixity doesn't matter
08:59:05 <rwbarton> :)
09:00:14 <Cale> (and you can always write an expression, so long as it typechecks, which is explicitly parenthesised)
09:00:42 <roadfish> ok, trying in ghci now ... so 2 < 3 < 4 is "precedence parsing error" and (2 < 3) < 4 is True < 4 ... or type-error
09:01:31 <roadfish> but if I define my own ? then I still can't do 2?3?4 but I could do (2?3)?4 if I (2?3) returns an acceptable type.
09:02:07 <elliott> yes
09:02:10 <rwbarton> you can declare whether 2?3?4 should be (2?3)?4 or 2?(3?4) or neither
09:02:18 <roadfish> so, really, non-associative is a way to impose a kind of sanity rule.
09:02:44 <rwbarton> right
09:02:44 <roadfish> ... but if I do pick neither (ie non-associative) then I can never actually use 2?3?4 without bracketing.
09:02:54 <rwbarton> right
09:02:56 <Cale> right, or to not impose a rule for how to treat otherwise ambiguous expressions
09:03:06 <Cale> (to look at it another way)
09:04:14 <Cale> When you declare that an operator ? is right associative, you're saying that if you write the otherwise-ambiguous 2 ? 3 ? 4 it means 2 ? (3 ? 4) instead of the other possibility.
09:04:21 <roadfish> parsing your "not impose a rule", then doing non-associative fixity _is_ applying a rule ... if I'm following things correctly.
09:04:22 <xos> is thunk the s-combinator in racket?
09:05:10 <neutrino_> lambdabot: hi!
09:05:36 <roadfish> wow, "thunk the s-combinator in racket" ... you don't get questions like that anywhere else. or maybe at a D&D convention.
09:05:39 <rwbarton> you can say "the rule is a?b?c -> fail", or "there is no rule for how to interpret a?b?c, therefore, fail"
09:06:21 <Cale> roadfish: You can't even really expect to get questions like that here, since it's a question about racket rather than Haskell :)
09:06:35 <neutrino_> is there a function which splits a string on another string, and gives me a list?
09:07:07 <Cale> neutrino_: http://hackage.haskell.org/package/split-0.2.1.1
09:07:12 <neutrino_> "bar" -> "foo bar baz bar quux" -> ["foo ", " baz ", " quux"]
09:07:29 <neutrino_> oh Cale great link thanks
09:07:30 <neutrino_> :)
09:07:30 <rwbarton> :t splitOn
09:07:31 <lambdabot>     Not in scope: `splitOn'
09:07:32 <lambdabot>     Perhaps you meant one of these:
09:07:32 <lambdabot>       `splitAt' (imported from Data.List),
09:07:44 <roadfish> and now a neutrino wants to know about splitting
09:07:52 <Cale> > splitOn "bar" . words $ "foo bar baz bar quux"
09:07:54 <lambdabot>   Not in scope: `splitOn'
09:07:54 <lambdabot>  Perhaps you meant one of these:
09:07:54 <lambdabot>    `splitAt' (impo...
09:07:57 <rwbarton> the only way it could be better is if it were imported in lambdabot
09:08:01 <Cale> ah, no split package in lambdabot :)
09:08:05 <Cale> maybe I should add that
09:08:13 <neutrino_> cale: well, spaces were only for demo, i'm not gonna have any
09:10:39 <Cale> @undefine
09:11:04 <Cale> > splitOn "x" "axbxc"
09:11:04 <djahandarie> Look what you did Cale!
09:11:10 <lambdabot>   mueval-core: Time limit exceeded
09:11:25 <Cale> > splitOn "bar" . words $ "foo bar baz bar quux"
09:11:29 <lambdabot>   mueval-core: Time limit exceeded
09:11:31 <Cale> lol
09:11:35 <fmap> > 1
09:11:38 <rwbarton> doesn't even need words, I think
09:11:38 <lambdabot>   1
09:11:42 <tomeo> Im having trouble using where in a do-block. Cant I just put it after the do-block with more indentation than the rest of the do-block?
09:11:47 <latermuse> can readFile work on text files over the net? for instance: "readFile www.example.com/textfile.txt"
09:12:09 <Cale> Oh, maybe it'll need to be splitOn ["bar"]
09:12:17 <Cale> > splitOn ["bar"] . words $ "foo bar baz bar quux"
09:12:21 <lambdabot>   mueval-core: Time limit exceeded
09:12:25 <Cale> > splitOn ["bar"] . words $ "foo bar baz bar quux"
09:12:27 <lambdabot>   [["foo"],["baz"],["quux"]]
09:12:28 <rwbarton> > splitOn "bar" "foo bar baz bar quux"
09:12:30 <lambdabot>   ["foo "," baz "," quux"]
09:12:36 <Cale> there we go, back to sanity
09:12:43 <Cale> more or less
09:12:57 <Cale> > splitOn "x" "axbxc"
09:12:59 <lambdabot>   ["a","b","c"]
09:13:14 <Cale> > splitWhen (<0) [1,3,-4,5,7,-9,0,2]
09:13:16 <lambdabot>   [[1,3],[5,7],[0,2]]
09:13:19 <elliott> latermuse: no
09:13:36 <rwbarton> tomeo: "where" attaches to pattern matches
09:13:43 <djahandarie> > splitOn "xx" "axxxbxxxc"
09:13:45 <lambdabot>   ["a","xb","xc"]
09:13:55 <rwbarton> tomeo: you can put it after the do block as long as it doesn't use any variables defined in the do block
09:14:06 <rwbarton> tomeo: otherwise, you can use do's "let" syntax
09:14:31 <djahandarie> > splitOn "x" =<< splitOn "xx" $ "axxxbxxxc"
09:14:32 <lambdabot>   Couldn't match expected type `[[GHC.Types.Char]]'
09:14:33 <lambdabot>              with actual ...
09:14:57 <tomeo> thanks rwbarton!
09:15:13 <neutrino_> > splitOn "bar" "foo bar baz quux"
09:15:15 <lambdabot>   ["foo "," baz quux"]
09:15:21 <neutrino_> > splitOn "bar" "foo bar baz bar quux"
09:15:23 <lambdabot>   ["foo "," baz "," quux"]
09:15:30 <neutrino_> ^ there yo ugo cale :)
09:15:47 <Cale> neutrino_: That doesn't deal with the spaces as nicely :)
09:15:51 <neutrino_> tomeo: show us your code
09:15:58 <neutrino_> Cale: that's exactly what i wanted though
09:16:01 <Cale> okay
09:16:01 <tomeo> neutrino_: why? I solved it
09:16:06 <neutrino_> tomeo: oh ok.
09:16:11 <tomeo> well, barton did at least :)
09:16:13 <neutrino_> nm then :)
09:16:18 <neutrino_> oh, sorry
09:16:18 <tomeo> thanks anyway neutrino_
09:16:45 <neutrino_> yw
09:21:41 <ocharles> I have an executable in my .cabal file -- can I use that as build-depends in my Test-Suite?
09:22:30 <dcoutts> ocharles: no, but you can list it as a build-tool, though I suspect that's not accurate in your use case
09:22:44 <dcoutts> because it's not used at build time I'm guessing
09:22:44 <neutrino_> interesting, how does your test suite use the executable? i'm guessing you call it as a subprocess?
09:22:52 <neutrino_> you might need to split your test to a separate package
09:22:56 <ocharles> no, I need to actually reference stuff inside it (it's a snap server, but I want to use Snap.Test)
09:23:13 <dcoutts> ocharles: ohh, then that's no problem, just list the module, it'll import them directly
09:23:21 <neutrino_> reference stuff inside a binary?
09:23:23 <ocharles> oh, with multiple hs-sources-dirs?
09:23:25 <neutrino_> how do you mean?
09:23:30 <ocharles> i have src/ and test/suite/
09:23:38 <neutrino_> ocharles: no, just a separate package altogether
09:23:56 <dcoutts> ocharles: yes, you will need to list all the src dirs so it can find the modules
09:24:01 <neutrino_> have one package install the binary under test, and the new package require it as a dependency and execute the test
09:24:09 <dcoutts> ocharles: it's perfectly ok to do that, and no need to have a separate package
09:24:15 <ocharles> dcoutts: awesome
09:24:16 <neutrino_> oh yeah
09:24:17 <ocharles> this seems to be working ok
09:24:22 <neutrino_> if you want a module from that, then yes
09:24:33 <ocharles> time to figure out Snap.Test!
09:24:46 <ocharles> thanks
09:25:29 <rwbarton> on a semi-related note: my project is an executable that requires (or will require, rather) another custom executable as a build-tool
09:25:45 <rwbarton> will it work well to just stuff both executable sections in the same .cabal file?
09:25:52 <tomeo> Is there a function in prelude that works kind of like map, that is takes a function and runs it on each element, but then prints the results to screen?
09:26:08 <elliott> you can build that with mapM
09:26:09 <elliott> :t mapM
09:26:11 <dcoutts> rwbarton: that's where you need the build-tool thing
09:26:12 <lambdabot> Monad m => (a -> m b) -> [a] -> m [b]
09:26:15 <tomeo> thanks elliott
09:26:22 <mSSM> Compared to a List xs :: [Int]  in which I randomly flip a value at some random index to create a new xs' :: [Int], is there a faster/better structure?
09:26:29 <dcoutts> rwbarton: and yes it'll work using cabal-1.14 and later I think
09:26:35 <rwbarton> ah, ok
09:26:44 <rwbarton> thanks
09:31:13 <kalli> mSSM: really interested in an answer to this too. Some kind of tree maybe?
09:31:54 <tomeo> Is there any way to make, mapM (\(x,y) -> do { putStrLn (show x); putStrLn ((show y) ++ "\n") } ) opt, not print [(),(),()] at the end?
09:32:05 <mSSM> tomeo: mapM_
09:32:14 <mSSM> tomeo: discards result
09:32:15 * hackagebot MemoTrie 0.6.1 - Trie-based memo functions  http://hackage.haskell.org/package/MemoTrie-0.6.1 (ConalElliott)
09:32:27 <tomeo> thanks a bunch mSSM!
09:32:29 * mSSM has no idea about haskell, but knows random stuff.
09:32:53 <tomeo> :)
09:33:05 <rwbarton> mSSM: a mutable array :P or a Map/Seq
09:33:14 <rwbarton> or IntMap etc
09:33:44 <mSSM> rwbarton: I started off with a mutable Vector (some code I found online), but people here suggested to implement that using "standard" haskell
09:33:54 <mSSM> rwbarton: coz mutable = ugly
09:33:59 <rwbarton> mutable arrays are standard (no quotes)
09:34:14 <rwbarton> they're also the most efficient for certain problems like this one
09:34:28 <kalli> I think one of the standard data structures in clojure does this well in an immutable way
09:34:56 <mSSM> rwbarton: Well, it was really hard for me to adapt that code, becaue it uses stateful computations, and I am not really that deep into that stuff.
09:35:42 <rwbarton> use a Map/etc./etc./etc. then
09:36:10 <mSSM> rwbarton: So now I am using immutable lists, but stuff like `let (x,_:xs) = splitAt n mylist' and then recombining it with `x ++ foo : xs' is expensive, no?
09:36:17 <qwr> hm. what's the problem with doing it in the ST monad for example?
09:36:36 <rwbarton> mSSM, indeed
09:37:19 * mSSM has no idea what ST Monads are.
09:37:57 <rwbarton> mSSM, well it depends on how big n is really. but n won't have to be very large before a list is not the best option
09:39:12 <mSSM> n can be anything in [0, 2^k], where k at the moment is 6,7,8,....
09:39:36 <mSSM> rwbarton: I wouldn't mind k being 20 either :
09:39:38 <mSSM> :)
09:39:49 <rwbarton> Map is a more convenient interface for single updates, anyways
09:40:31 <rwbarton> I suggest you start with Map and read http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Map.html until you get bored
09:40:46 <mSSM> I.e., I have a quadratic lattice with sides of length 2^m
09:41:00 <mSSM> And I map it into a 1D structure (my list)
09:41:06 <quchen> mSSM: The ST monad is a sibling of IO: it chains effectful computations together. However, you *can* escape the ST monad, giving you a pure function. Inside ST you can have non-pure stuff, but once you call runST you'll get a pure value.
09:41:25 <basdirks_> if I define fixity for an operator, load it into ghci, remove the fixity declaration, :r in ghci, the fixity is still set in ghci for this operator, even though the source file does not contain the fixity declaration any more. Why is this?
09:42:32 <mSSM> Is there a "cheap" data structure with which I can simulate a 2D lattice in a simpler way, and which also gives me cheap read/write access?
09:43:02 <hpaste> quchen pasted “test” at http://hpaste.org/78478
09:43:05 <mSSM> rwbarton: Data.Map sounds good actually; is reading it cheap?
09:43:18 <rwbarton> it is a tree
09:43:22 <rwbarton> read the docs :)
09:43:33 <mSSM> quchen: I am going to have a look at it; little over my head right there.
09:43:49 <rwbarton> so it is pretty cheap but obviously not as cheap as an array
09:43:52 <basdirks_> nvm, I didn't anticipate the proper default fixity for my self-defined operators
09:44:28 <mSSM> rwbarton: and what is the down side to using an array compared to a map?
09:44:30 <mSSM> Map*
09:44:51 <rwbarton> well immutable arrays are not mutable and mutable arrays are mutable
09:44:54 <rwbarton> that is the downside :P
09:45:16 <rwbarton> or another way to say it is that writing to an immutable array is expensive because you have to copy the whole array
09:45:35 <edwardk> while writing to a map you can do a logarithmic amount of work for each update
09:45:38 <c_wraith> on the plus side, reading from it is pure!
09:45:41 <mSSM> rwbarton: and how is that different from creating a new map or list from an old list?
09:45:57 <rwbarton> because a map is a tree, again, all your questions are answered in the docs
09:46:01 <mSSM> I guess edwardk answered.
09:46:08 <mSSM> rwbarton: ok, I will read on.
09:46:10 <edwardk> mSSM: if i have an array with a million entries i need to make a new array with a million entries to update 1 entry
09:46:21 <rwbarton> for a list, it's not that different because you have to copy everything before the element you updated
09:46:41 <edwardk> mSSM: if i have a Data.Map with a million entries they share almost the entire structure except for about ln(1 million) ~20 nodes on the path to the root
09:46:50 <edwardk> 20 << 1 million ;)
09:46:53 <kalli> With Data.Map, an operation like described is O(log n), while with a mutable array it's O(1). Am I right?
09:47:13 <typoclass> > 20 << 1
09:47:15 <lambdabot>   Not in scope: `<<'
09:47:15 <lambdabot>  Perhaps you meant one of these:
09:47:15 <lambdabot>    `=<<' (imported from...
09:47:18 <mSSM> edwardk: Sounds good :)
09:47:32 <edwardk> kalli: the price is that accessing a particular element is also about 20 steps there, vs. 1, yes.
09:47:43 <ciaranm> is there something better than Data.Complex?
09:48:03 <edwardk> ciaranm: for what purpose?
09:48:25 <ParahSail1n> isn't DataMap log_32?
09:48:30 <ciaranm> edwardk: simple trig stuff on complex numbers
09:48:53 <kalli> And a normal list would be something like O(n), so that's not really practical, but the map works fine
09:49:12 <edwardk> ParahSail1n; you're probably thinking HashMap which is a HAMT, with 32-way fanout
09:51:16 <ick> I want to take input from a file, but I want to output what is wrong with the file if the data in it is in the wrong format. Is the best way to write a bunch of tests for the file and then start from the beginning if all the tests pass? It seems to get messy quickly if I start adding error handling to every function
09:51:16 <ParahSail1n> edwardk: ah oh
09:52:15 * hackagebot shuffle 0.1.0.1 - Shuffle tool for UHC  http://hackage.haskell.org/package/shuffle-0.1.0.1 (JeroenBransen)
09:59:17 <tibbe> edwardk: (I actually ended up using a 16-way fanout in the end, as it gave a better trade-off between insert and lookup performance.)
10:01:45 <edwardk> fair nuff =)
10:02:01 <edwardk> i still need to push up my 64-way HAMT for charsets somewhere
10:02:09 <edwardk> (that gives optimal UTF-8 decoding lookup)
10:02:29 <edwardk> one utf-8 byte per layer, fixed structure, etc.
10:03:12 <edwardk> it also has the nice benefit that the complement of a charset is the exact same storage size as the original
10:04:19 <radox> Hi I am trying to work with exception handling in Haskell
10:05:10 <radox> I have been successful in using Control.Exception.catch but this seems best suited for small catch blocks
10:05:35 <radox> I am wanting to catch a division by zero and only do multiple things if there is no divison by zero
10:06:01 <radox> I think for this Ineed to use try
10:06:07 <radox> and then check if it is right or left
10:06:36 <radox> however, it is always matching right even when a divison by zero has occured
10:06:50 <Saizan> you have to be stricter within try
10:07:13 <Saizan> so that the exception is raised there rather than hidden in a yet unevaluated expression
10:07:48 <dmwit> :t evaluate
10:07:49 <lambdabot>     Not in scope: `evaluate'
10:07:49 <lambdabot>     Perhaps you meant `evalState' (imported from Control.Monad.State)
10:07:51 <radox> How can I force this strict behaviour?
10:07:56 <dmwit> ?hoogle evaluate
10:07:57 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
10:07:57 <lambdabot> Control.Exception evaluate :: a -> IO a
10:07:57 <lambdabot> Control.OldException evaluate :: a -> IO a
10:09:19 <donri> edwardk: hey would it be completely nuts to add an RFunctor to lens just so you could do functory stuff to sets and whatnot?
10:10:27 <radox> I have just tried using evaluation but I am still getting some issues
10:10:33 <ocharles> edwardk: interested in a isomorphism between strict and lazy bytestrings for lens?
10:10:34 <Saizan> traversals kind of side-step that issue already, i.e. you can write a traversal for Set without any need to introduce new classes
10:10:37 <ocharles> (toStrict/fromStrict)
10:10:42 <radox> Would anyone care to take a quick look at the code?
10:10:53 <Saizan> radox: yeah, that's the best route
10:11:10 <Saizan> radox: put it on hpaste.org or anywhere convenient for you
10:13:18 <hpaste> radox pasted “exception problem” at http://hpaste.org/78479
10:14:50 <akahn> applyBasicAuth takes bytestring parameters. does it make more sense to make my functions that use this function all take/use bytestrings or should I convert String to ByteString at the last moment before calling applyBasicAuth? http://hackage.haskell.org/packages/archive/http-conduit/1.8.3/doc/html/Network-HTTP-Conduit.html#v:applyBasicAuth
10:15:09 <akahn> the source of the auth information is (going to be) a command line arguhment
10:15:22 <edwardk> ocharles: bytes.from bytes ?
10:15:33 <radox> Sizan: let me know if you have any questions
10:15:42 <ocharles> edwardk: well I guess, but .from lazy reads very nicely :)
10:16:04 <ocharles> but i am in favour of keeping the api as lean as possible
10:16:07 <edwardk> i could see adding that.
10:16:14 <Saizan> radox: how is Number defined?
10:16:16 <edwardk> but there is that component
10:16:40 <ocharles> edwardk: the to/from strict makes me wonder if that's a family of isomorphisms
10:16:51 <ocharles> because more than just bytestrings do that
10:17:20 <edwardk> class Lazy s t a b where lazy :: ?
10:17:23 <ocharles> yea
10:17:25 <hpaste> radox annotated “exception problem” with “exception problem (annotation)” at http://hpaste.org/78479#a78483
10:17:25 <edwardk> with appropriate fundeps
10:17:55 <ocharles> well I guess I was just thinking class Lazy strict lazy where lazy :: Simple Iso lazy strict
10:18:24 <edwardk> one concern is that combinator should live in Control.Lens.Iso but Data.ByteString.Lens uses that.
10:18:29 <edwardk> let me chew for a sec
10:18:32 <ocharles> sure, no rush
10:18:49 <Peaker> edwardk: Hey, I encountered the need for a Monad constraint when vertically composing Traversals. Does lens support that use pattern? Or do you consider the Monad constraint a bug (given that you can manually write it using Applicative)?
10:18:53 <ParahSail1n> hamt is pretty cool structure, thanks for mentioning it here
10:18:55 <bgamari> byorgey, Is there are a reason diagrams' R3 and R2 aren't unpacked?
10:19:00 <edwardk> it should be the 4 arg version like 'Wrapped' otherwise it won't handle things that have changable contents
10:19:16 <Peaker> Also, if I want to avoid Rank2 and want to use type synonyms, is it idiomatic to use: Functor f => ... -> SimpleLensLike f a b ?
10:19:29 <radox> Saizan : Just added code related to Number
10:19:39 <hpaste> Saizan annotated “exception problem” with “exception problem (annotation) (annotation)” at http://hpaste.org/78479#a78484
10:19:47 <edwardk> Peaker: nope. https://github.com/ekmett/lens/issues/109
10:20:06 <Saizan> radox: see my annotation http://hpaste.org/78484
10:20:07 <edwardk> Peaker: re the SimpleLensLike thing yeah thats a viable option.
10:20:39 <Saizan> radox: evaluate is only strict in the outermost constructor, if you want deeper strictness you've to do something like force there
10:20:40 <edwardk> Peaker: basically vertical composition fundamentally requires the use of a monad.
10:20:52 <edwardk> and the monad constraint breaks almost everything else we do
10:21:46 <radox> Wow ok
10:21:49 <radox> That works!
10:22:29 <radox> Would there be any other ways to do the same thing?
10:22:40 <radox> Maybe ways which are considered better practice?
10:23:35 <Saizan> radox: there's the NFData class which is about deep evaluation, and there are TH macros to derive it
10:24:29 <Saizan> radox: which would amount to doing the same thing in a more standard way
10:24:30 <radox> Great. I will have a look into those. Thanks very much for your help.
10:24:45 <Saizan> np
10:26:48 <radox> Saizan: One more question. Why is evaluate still needed? I know it bring it into the IO monad but why could return not be used instead?
10:27:34 <edwardk> ocharles: for you https://github.com/ekmett/lens/commit/724db984fb6ee507676ef79851f7ae526293c49c
10:28:14 <ocharles> yay, undecidable instances
10:28:26 <Saizan> radox: you still need a source of strictness, which is then propagated by force
10:28:27 <ocharles> thanks, looks good!
10:29:16 <radox> Ah ok. Makes sense!
10:29:20 <radox> Thanks again :)
10:29:29 <Saizan> :)
10:36:54 <juan_> hello there
10:37:09 <juan_> i'am trying it online
10:37:20 <hiptobecubic> What's going on here "class Lazy s t a b | s -> a, t -> b, s b -> t, t a -> s where..."
10:37:27 <hiptobecubic> Which black voodoo extension is doing that?
10:38:06 <juan_> what can i do do with Haskell?
10:38:23 <juan_> i'am a newbie in Haskell
10:38:32 <josephle> hiptobecubic: "s t a b"... burn it with fire!
10:39:08 <juan_> for example can i make MDI software?
10:39:19 <juan_> or something similar?
10:39:51 <hiptobecubic> juan_, it's a general programming language. You can do the things that you would normally do.
10:40:02 <hiptobecubic> Some people can do things that you would never do.
10:40:03 <ParahSail1n> @faq can haskell make MDI software
10:40:03 <lambdabot> The answer is: Yes! Haskell can do that.
10:40:16 <hiptobecubic> The usual
10:41:04 <juan_> excellent
10:41:16 <juan_> thanks
10:41:34 <hiptobecubic> github has really developed into a nice tracker i think
10:43:54 <romildo> Is there a function in some library to download a web page, giving a String that respects any charset encoding specified in the page?
10:46:11 <jaap-> @pl MkGen $ \g n -> runSplitReader (runReaderT monad n) g
10:46:11 <lambdabot> MkGen (flip (runSplitReader . runReaderT monad))
10:46:55 <roadfish> @faq can haskell make MIDI software
10:46:55 <lambdabot> The answer is: Yes! Haskell can do that.
10:47:12 <roadfish> @faq can haskell make zoolology software
10:47:12 <lambdabot> The answer is: Yes! Haskell can do that.
10:47:45 <roadfish> very good ... and I even misspelt zoology
10:48:10 <josephle> @faq can haskell make xyz
10:48:10 <lambdabot> The answer is: Yes! Haskell can do that.
10:48:17 <roadfish> the power of positive thinking
10:48:30 <josephle> it seems to be future proof
10:48:38 <roadfish> Haskell is Turing complete ... therefore it can do anything
10:48:55 <elliott> not everything
10:48:56 <josephle> @faq can haskell make quantum turing machines?
10:48:56 <lambdabot> The answer is: Yes! Haskell can do that.
10:49:01 <josephle> >_>
10:49:06 <josephle> when was haskell quantum turing complete?
10:49:54 <elliott> josephle: you can simulate quantum computers with classical computers
10:49:54 <roadfish> that's what the Terminators run on ... Haskell for quantum computers
10:50:01 <elliott> (it's just exponentially slower)
10:50:24 <rwbarton> too bad you cannot use X][ trick to keep eustachio from healing
10:50:29 <rwbarton> oh wrong window
10:50:29 <josephle> ah yes, that's true
10:50:35 <josephle> well, one more test
10:50:37 <josephle> just to be sure
10:50:52 <josephle> @faq can haskell make a halting oracle
10:50:52 <lambdabot> The answer is: Yes! Haskell can do that.
10:50:56 <josephle> oh dear
10:50:57 <DT`> @faq can haskell solve NP problems in polytime?
10:50:58 <lambdabot> The answer is: Yes! Haskell can do that.
10:51:09 <DT`> wait.
10:51:14 <DT`> @faq can haskell solve NP-complete problems in polytime?
10:51:14 <lambdabot> The answer is: Yes! Haskell can do that.
10:51:25 <roadfish> @faq can haskell STFU?
10:51:25 <lambdabot> The answer is: Yes! Haskell can do that.
10:51:25 <DT`> let's collect the million, guys.
10:51:46 * tac bops DT` 
10:51:48 <josephle> @faq can haskell solve P-Space complete problems in polytime?
10:51:48 <lambdabot> The answer is: Yes! Haskell can do that.
10:51:49 <jaap-> if you want to I guess haskell won't stop you
10:51:59 <jaap-> so it can do that in that sense
10:52:01 <tac> DT`: Spamming Lambdabot is what #haskell-blah is for
10:52:07 <josephle> I'm not stopping until I figure out where the split is!
10:52:19 <DT`> tac, gah, didn't know it existed.
10:52:20 <DT`> sorry.
10:52:28 <tac> it's all right :)
10:57:37 <typoclass> tac: uh, i'm not sure that's what -blah is for ... :-)
10:58:14 <roadfish> but given the blah in the name, lambdabot abuse is overlooked
10:58:48 <tac> Haskell-Blah is for talking about liberal politics, how someone in #haskell pissed you off earlier, or about how stupid people on r/haskell are.
10:58:53 <tac> :)
10:59:07 <roadfish> r/haskell?
10:59:14 <monochrom> spamming lambdabot is what "hi, could you command lambdabot to join ##mychannel?" for :)
10:59:19 <glguy> but #haskell isn't for talking about #haskell-blah :-p
10:59:19 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
10:59:26 <tac> roadfish: http://reddit.com/r/haskell
10:59:59 <roadfish> :-( ... no #raskell
11:12:17 * hackagebot gtk-jsinput 0.0.0 - A simple custom form widget for gtk which allows inputing of JSON values  http://hackage.haskell.org/package/gtk-jsinput-0.0.0 (TimothyHobbs)
11:17:18 * hackagebot gtk-simple-list-view 0.0.0 - A simple custom form widget for gtk which allows single LOC creation/updating of list views.  http://hackage.haskell.org/package/gtk-simple-list-view-0.0.0 (TimothyHobbs)
11:17:36 <jojo_> Is it wrong to say that control structures in Haskell are expressions?
11:17:56 <monochrom> eh? I didn't know 0.0.0 is accepted :)
11:18:06 <Clint> why wouldn't it be?
11:19:19 <monochrom> paranoia from an old time when people used a natural number type as though it's "Maybe PositiveInt"
11:20:00 <byorgey> bgamari: no particular reason
11:20:34 <bgamari> byorgey, alright, just checking
11:20:50 <bgamari> byorgey, I'm trying to follow diagrams' model in http://www.implicitcad.org/
11:21:08 <bgamari> currently I'm using type R2 = (Double,Double)
11:21:59 <bgamari> and was wondering whether an unboxed datatype might give a worthwhile performance boost
11:22:18 * hackagebot gtk-toggle-button-list 0.0.0 - A simple custom form widget for gtk which allows single LOC creation/updating of toggle button lists.  http://hackage.haskell.org/package/gtk-toggle-button-list-0.0.0 (TimothyHobbs)
11:22:49 <bgamari> sadly wrapping points in the Point newtype has degraded performance a bit it seems
11:23:05 <bgamari> so I've been looking for ways to win that back
11:23:17 <sonOfRa> I'm using HUnit for testing some of my excercises. The following doesn't work, and I do not understand why: http://hpaste.org/78487 The GHCi says something about Ambiguous type variables, I do not understand what that means. It only does that for testing with an empty list though.
11:24:01 <bgamari> sonOfRa, Because it can't tell what type of value is in the list
11:24:26 <bgamari> sonOfRa, give it an explicit type annotation
11:24:36 <sonOfRa> Hm, is there a way to cast it, like in other programming languages? I want to explicitly test it with an empty list
11:24:53 <bgamari> e.g. [] :: [Int]
11:25:57 <sonOfRa> Then I can technically only test for that one type? Or is there a way to infer a generic type?
11:26:11 <Digihash> Hello everybody
11:27:05 <rwbarton> in principle the outcome of the test might depend on the type you choose
11:27:42 <bgamari> sonOfRa, Not really
11:28:04 <bgamari> sonOfRa, You could make it polymorphic and evaluate it with lists of different types
11:28:19 <sonOfRa> the function itself is polymorphic
11:28:20 <rwbarton> assertEqual "..." True (null (flattenPair []))
11:28:29 <bgamari> but this isn't truly generic
11:28:47 <sonOfRa> rwbarton, flattenPair [] should return an empty list, not null
11:28:58 <rwbarton> null means "is this list empty?"
11:29:03 <sonOfRa> oooh
11:29:48 <bgamari> sonOfRa, just for the record, there is no "null" value in Haskell
11:29:52 <sonOfRa> yeah
11:29:58 <rwbarton> @type null
11:29:59 <sonOfRa> I wondered what that was supposed to be
11:29:59 <lambdabot> [a] -> Bool
11:30:00 <bgamari> sonOfRa, The closest you can come is _|_
11:30:12 <hpaste> tsuraan pasted “I don't understand existential types” at http://hpaste.org/78489
11:30:13 <monochrom> it sufficies to test for [Int], or [Char], or [Whatever].
11:30:51 <sonOfRa> rwbarton, that solution worked, without having to test for a certain type, thanks
11:31:04 <tsuraan> could somebody have a look at the hpaste I just made and see what I'm doing wrong?  I want something like a curried bracket to be passed in to a function (within a data), but I can't get it to stay polymorphic
11:31:24 <tsuraan> it seems that haskell "locks" the type of my polymorphic function to a single type
11:31:32 <tsuraan> or maybe I just have no idea what's going on
11:31:40 <kartlos> hey ppl, I'm getting a segmentation fault on OS X 10.6 when I run GHCi, GHC seems to work perfectly. Does anyone know what the cause is? I pasted the output at: http://pastebin.com/QFLqCsyS
11:31:43 <mauke> The paste QFLqCsyS has been copied to http://hpaste.org/78490
11:31:46 <monochrom> this is similar to: if I give you blackbox::a->a, you need only test it with e.g. blackbox (), that will completely tell you what my blackbox does. this comes from Free Theorems
11:32:23 <rwbarton> tsuraan: you're not trying to use existentials there
11:32:36 <rwbarton> data Foo = Foo Int (forall a. (Int -> IO a) -> IO a)
11:32:39 <tsuraan> isn't the "data Foo = forall a. FOo ..." existential?
11:32:47 <tsuraan> hm
11:32:48 <dmwit> tsuraan: As currently defined, your Foo contains a *monomorphic* higher-order function, and from the outside world we're not allowed to observe which instantiation of 'a' it happens to be storing.
11:32:48 <rwbarton> yes but then the entire rest of your program is wrong :P
11:33:00 <tsuraan> hehe
11:33:04 <tsuraan> not surprised
11:33:32 <rwbarton> clearly you intended for Foo to contain a universally quantified component
11:33:37 <rwbarton> not an existentially quantified one
11:33:39 <dmwit> (This is essentially the meaning of an existential: it's storing a value of some particular type, but nobody knows which.)
11:33:48 <dmwit> Right, I agree with rwbarton.
11:34:14 <tsuraan> ok, I don't understand what those words mean, but universal sounds like what I want :)
11:34:28 <tsuraan> ghc says I want RankNTypes.  Is that sane?
11:34:41 <dmwit> define "sane"
11:34:51 <tsuraan> heh.  correct?  the same as universal?
11:35:05 <tsuraan> well, it liked Rank2Types
11:35:11 <tsuraan> at least it compiles.
11:35:17 <tsuraan> and runs!  neat
11:35:26 <tsuraan> now if only I knew why...
11:35:30 <dmwit> The rank of a type is the maximum number of arrows you can go to the left of and still find a universal quantification.
11:36:07 <dmwit> forall a. (a -> a) is rank 1. (forall a. a) -> (forall a. a) is rank 2. So is (forall a. a) -> Int.
11:36:10 <dmwit> etc.
11:36:14 <tsuraan> ah
11:36:33 <tsuraan> so the requirement for the rank2 type is actually my function, and not the data that I'm storing it in?
11:36:57 <dmwit> The type of your Foo constructor has rank two.
11:37:04 <dmwit> (Try :t Foo in ghci.)
11:37:13 <monochrom> sonOfRa: investigations show that the compiler picks one single type for you, and it is GHC.Prim.Any
11:37:49 <monochrom> how to find out: ghc -ddump-simpl, i.e., read GHC's core code
11:38:19 <dmwit> I guess Int -> Int would be rank zero? never really thought about it, though
11:38:19 <monochrom> but what you really need to know: it suffices to test for one single type
11:38:41 <sonOfRa> alright, I guess I can do that too then
11:38:42 <sonOfRa> thanks!
11:38:46 <dmwit> {-# LANGUAGE Rank0TypesAKASimplyTypedLambdaCalculus #-}
11:39:24 <tsuraan> Ok, so my Foo is "Int -> (forall a. ...) -> Foo", so it's rank 2.  makes sense
11:40:14 <c_wraith> wouldn't PolymorphicComponents suffice for that use case?
11:42:16 <tsuraan> c_wraith: using PolymorphicComponents does work instead of Rank2Types
11:42:25 <tsuraan> is one considered less bad than the other?
11:42:38 <tsuraan> Polymorphic components seems like it would just be a sane thing to allow
11:43:03 <c_wraith> Neither of them is considered bad, at all
11:43:15 <tsuraan> oh, I thought rank n was considered scary or something
11:43:19 <c_wraith> nah.
11:43:25 <c_wraith> It's totally fine.
11:43:52 <c_wraith> The worst thing enabling it does is require you to provide the occasional type annotation that would have been inferred otherwise.  But even that is rare.
11:44:09 <tsuraan> cool.  I think I understand what polymorphic components means, so I'll stick with that extension.  thanks!
11:44:21 <c_wraith> PolymorphicComponents just makes it clearer to someone looking at your language pragmas what they're there for.
11:44:34 <josephle> rank-n is just System F, right?
11:44:39 <tsuraan> that sounds reasonable
11:47:50 <Digihash> I'm a bit stuck with an exercise I got. I have to make an custom instance of the Show class. If I enter show (Puzzel (Size 2 3) [Link (1 :: Int) (Pos 1 1) (Pos 1 3), Link 2 (Pos 2 1) (Pos 2 3)]). I should get this output as return: "1 1\n2 2".
11:48:53 <Digihash> I also have a function showPuzzel that gives me this output: [[Just 1,Nothing,Just 1],[Just 2,Nothing,Just 2]]
11:49:50 <Digihash> I think I should loop through the output of showPuzzel, but there is my problem. How do I do that in a custom instance of Show?
11:50:23 <rwbarton> don't think about instances and Show
11:50:38 <rwbarton> just think about: how can I write a function to convert [[Just 1,Nothing,Just 1],[Just 2,Nothing,Just 2]] to "1 1\n2 2"
11:53:01 <Digihash> Hmm, So loop through the list from the output and concatenate everything?
11:53:07 <Digihash> I'l try
11:55:46 <S11001001> Digihash: you can do the same with your original structure, if that's easier.
11:56:57 <parcs`> is every Just value separated by a space or is Nothing a space?
11:57:24 <bgamari> parcs`, eh?
11:57:31 <dropdrive> Maybe something like -- intersperse '\n' $ map $ intersperse ' ' $ catMaybes ?
11:57:42 <bgamari> ahh
11:57:46 <rwbarton> I assume a Nothing is a space is an empty square on the grid
11:57:48 * bgamari looks above
11:57:58 <rwbarton> also, " I'm a bit stuck with an exercise I got"
11:59:02 <glguy> maybe no everyone appreciate the value of a good homework assignment
12:01:31 <Digihash> Yes, it is like that. So the Just 1 is entered like a 1 and nothing becomes a space. But I think I can have an instance of Show Puzzel, which calls another function. And this function should call the custom show of ShowPuzzel. This is my main idea. I'm just thinking about how to implement this
12:01:53 <Digihash> Is this a good way of thinking?
12:02:11 <bgamari> Digihash, Don't worry about Show for now
12:02:40 <bgamari> Digihash, you just need a function Puzzle -> String
12:02:40 <Digihash> Hmm
12:03:08 <bgamari> assuming I understand the problem correctly
12:03:16 <rwbarton> or [[Maybe Int]] -> String, since you already seem to have Puzzle -> [[Maybe Int]]
12:03:24 <rwbarton> which does most of the work, really
12:03:47 * bgamari was under the impression that type Puzzle = [[Maybe Int]]
12:03:47 <bgamari> oops
12:04:00 <bgamari> ahh, I see
12:04:22 <bgamari> Digihash, first figure out how to render a row
12:04:24 <glguy> Digihash: Where'd you get the exercise?
12:04:49 <mSSM> So I wrote my first kinda-sorta Haskell code, and I was wondering if somebody could have a look over it and suggest what I could change in terms of coding style? http://sprunge.us/WWYM It is not very efficient: for one, I will change from using Lists to Data.Map .
12:04:54 <bgamari> Digihash, after that you are done (hint: Prelude.unlines will help you here)
12:05:19 <Digihash> It's an exercise I have from my class.
12:06:07 * bgamari notes the use of (|>)
12:06:18 <Digihash> I'll look at prelude.unlines
12:06:21 <Digihash> thank you
12:06:41 <parcs`> Digihash: usually how it's done is to first implement showPuzzle :: Puzzle -> String, and then write 'instance Show Puzzle where show = showPuzzle'
12:07:13 <ParahSail1n> mSSM: whats create?
12:07:18 * hackagebot ohloh-hs 0.0.2 - Interface to the Ohloh API  http://hackage.haskell.org/package/ohloh-hs-0.0.2 (FrankThomas)
12:07:18 <Digihash> Ah, ok I get it I think
12:07:42 <bgamari> ParahSail1n, It's from random-mwc
12:07:44 <Digihash> I'll first try to create the function showPuzzel. Thank you for your help
12:07:50 <bgamari> ParahSail1n, It creates an RNG
12:08:53 <bgamari> mSSM, Just a pointer: the random-fu and rvar libraries are wonderful IMHO
12:11:36 <mSSM> bgamari: I had a look at random-fu, but it seemed it didn't help me much.
12:11:58 <bgamari> mSSM, For one, it allows you to use a more limited monad than IO
12:12:05 <bgamari> but fair neough
12:13:44 <mSSM> Oh well, the random generator stuff is not that much of a deal for my code right now. The other stuff that's happening in my code I find more dubious...
12:14:01 <mSSM> bgamari: I feel like I am doing very redundant stuff.
12:14:17 <mSSM> Like passing foo bar baz to a function, which then takes it and passes foo bar to another function.
12:14:21 <mSSM> And that happens quite a lot.
12:15:05 <theezakje> Any quick headsup how I can conert a Type a to string?
12:15:18 <archwes> I've got a function: shift3R func a b c = func c a b
12:15:31 <theezakje> patternmatch ... = "" ++ a ++ ""
12:15:34 <theezakje> isnt working :p
12:15:35 <archwes> but I can't understand why its type is:   3 shift3R :: (a -> b -> c -> d) -> b -> c -> a -> d
12:16:22 <rwbarton> theezakje, depends on the type and how you want to "convert" it of course
12:16:30 <rwbarton> but for many cases, there is 'show'
12:16:57 <theezakje> it should work for ints and chars
12:17:07 <bgamari> mSSM, use a State monad?
12:17:12 <theezakje> i suppose i dont have to write a "converter" for that myself and I can use show
12:17:47 <josephle> archwes: that's because the type signature is defined by func
12:17:51 <rwbarton> already for Char there are several sensible ways to "convert"
12:18:19 <Cale> theezakje: "" is an empty string
12:18:32 <mSSM> bgamari: Sorry, can you be more specific?
12:18:35 <Cale> theezakje: in order for "" ++ a to make sense, a must be a string as well.
12:18:48 <theezakje> yes I found out that was pretty dumb of me
12:18:48 <theezakje> sry
12:18:50 <theezakje> :m
12:19:01 <Cale> theezakje: It's okay
12:19:06 <rwbarton> it would work in Certain Other Languages
12:19:31 <archwes> josephle: why is the left side of the definition "c a b" while the returned function is "b -> c -> a"
12:20:10 <archwes> josephle: i meant right side
12:20:15 <watermind> just read about Simon going to Facebook
12:20:18 <josephle> archwes: func is of type (a -> b -> c -> d)
12:20:24 <rwbarton> archwes: 'func' is a function of three things so let's say it has type (a -> b -> c -> d)
12:20:41 <rwbarton> 'c' is the first parameter to 'func' so 'c' must have type 'a' (confusing, yes!)
12:20:44 <rwbarton> etc.
12:20:46 <Cale> archwes: Because the function's author has decided to confusingly name the variables
12:21:24 <Cale> shift3R f b c a = f a b c
12:21:36 <Cale> is equivalent, but will mean that a :: a, and so on
12:21:37 <archwes> Cale: haha my bad, made the letters the same temporarily so i could figure out this issue
12:22:25 <Cale> Let's not be punny though
12:22:31 <Cale> Suppose we start with
12:23:16 <Cale> shift3R f y z x = f x y z
12:23:49 <Cale> Since f is being applied to three parameters, its type had better look like (a -> b -> c -> d) for some types a, b, c, and d
12:24:04 <archwes> Cale: I'm folowing you so far
12:24:07 <c_wraith> and important thing to note is that d could have more arrows in it.
12:24:09 <c_wraith> *an
12:24:11 <bgamari> mSSM, If you find yourself passing around state which is mutated, you may want to use a State monad
12:24:12 <Cale> Moreover, we get that x :: a, y :: b, z :: c, and the result has type d
12:24:29 <bgamari> mSSM, Namely http://hackage.haskell.org/packages/archive/mtl/latest/doc/html/Control-Monad-State-Lazy.html
12:24:42 <archwes> c_wraith: but those "arrows" are contained with in the type d, right?
12:24:47 <Cale> That is not an important thing to note here, d can be any type at all, it may or may not be a function type, but we don't care.
12:25:03 <bgamari> mSSM, in your case, many of your functions could be of type State Ising _
12:25:11 <Cale> (at least, I don't think it's important)
12:25:21 <Cale> Nothing about this function will tell us anything more about the type d
12:25:48 <c_wraith> archwes: indeed. It just means you could apply shift3R to a function that takes 17 arguments..  The rest of them are just part of the type d
12:25:58 <archwes> c_wraith: ah
12:26:10 <Cale> So, shift3R will take 4 parameters, f of type (a -> b -> c -> d), and then y of type b, and then z of type c, and finally x of type a
12:26:15 <Cale> and it produces a result of type d
12:26:20 <bgamari> mSSM, It looks like you import Control.Monad.State even
12:26:29 <Cale> So  shift3R :: (a -> b -> c -> d) -> b -> c -> a -> d
12:27:01 <Cale> It suffices not to think about what sort of type d is
12:27:14 <archwes> Cale: It just clicked! I was thinking about it backwards!
12:28:23 <archwes> Cale: i was thinking that the parameter definition had to match the func type, which is just the opposite of the truth
12:28:48 <Cale> right, those are the parameters to shift3R, not f
12:30:14 <archwes> Cale: thank you! "shift3R func c a b = func a b c" has the type that i expected
12:32:01 <theezakje> question, which pattern match am I overlooking? (getting non-exhaustive pattern error)
12:32:02 <theezakje> http://hpaste.org/78491
12:32:38 <theezakje> thanks for your help btw Cale :p
12:33:08 <elliott> @hoogle Identity
12:33:09 <lambdabot> Control.Monad.Identity module Control.Monad.Identity
12:33:09 <lambdabot> Control.Monad.Trans.Identity module Control.Monad.Trans.Identity
12:33:09 <lambdabot> Data.Functor.Identity module Data.Functor.Identity
12:33:15 <josephle> theezakje: convertPuzzel doesn't have a [] case
12:33:30 <theezakje> thanks josephle will trie
12:33:58 <archwes> c_wraith: so the fact that d can be a function mean that I can apply flip to a function that takes 3+ parameters!
12:34:00 <theezakje> lol that was it
12:34:05 <theezakje> thanks josephle
12:34:21 <c_wraith> archwes: that's also true
12:34:36 <mSSM> bgamari: Ok, I will have a look into how I can apply that there...
12:34:42 <mSSM> bgamari: that state monad gives me headaches :)
12:34:43 <archwes> it all makes so much sense :D
12:34:46 <c_wraith> > flip foldl 0 (+) [1..10]
12:34:47 <lambdabot>   55
12:35:38 <archwes> thanks for the help everyone!
12:35:57 <radox> Hi could anyone tell me what event gets trigged when a RadioMenuItem is selected?
12:36:28 <radox> I'm using onActivateLeaf but it gets called twice
12:36:54 <radox> onToggled never gets called
12:40:09 <josephle> category theory homework is ruining my coding habits...I just used a kleisli arrow when a bind would've sufficed -_-
12:44:54 <xenocons> i want to use haskell for my next project, but i keep reaching for my comfort language :(
12:45:02 <neutrino_> hey guys
12:45:23 <neutrino_> what's a good, simple to use package which allows me to match a single string against a single regex?
12:46:00 <neutrino_> hopefully well written in that it doesn't leak or whatever, but it doesn't need any special features at all, i'm happy with just .* and stuff.
12:46:39 <josephle> I wonder if the Real World Haskell chapter on regexes is up-to-date
12:46:52 <josephle> that might work
12:47:14 <theezakje> anyway to change the output from a char like 'c' to c
12:47:25 <theezakje> to unquote it sort of speak
12:47:39 <theezakje> I'm making a string of characters like this:
12:47:46 <theezakje> "       'c'    'a'  'b'"
12:47:55 <theezakje> instead I want "        c      a  b"
12:48:17 <theezakje> atm I'm just doing show on the character
12:48:29 <monochrom> > "    " ++ ['c'] + "   " + ['a']
12:48:30 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:48:31 <lambdabot>    arising from a use of `GH...
12:48:37 <monochrom> > "    " ++ ['c'] + "   " ++ ['a']
12:48:39 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
12:48:39 <lambdabot>    arising from a use of `GH...
12:48:43 <monochrom> yikes
12:48:46 <monochrom> > "    " ++ ['c'] ++ "   " ++ ['a']
12:48:49 <lambdabot>   "    c   a"
12:48:53 <monochrom> screw show
12:49:03 <theezakje> mmm
12:49:36 <rwbarton> this is why you should not say "convert"
12:49:58 <monochrom> yes, this probably completely destroys your fundamental assumptions about always using show
12:50:20 <theezakje> "always" :p started with haskell 2 weeks ago
12:50:30 <schellsan> hi all
12:50:31 <xenocons> split at "'" then concantenate the result back to string is my niave approach to it, probably a much better haskell way though
12:50:39 <theezakje> pretty obvious though
12:51:08 <xenocons> according to Data.String.Utils there is a replace function
12:51:28 <josephle> xenocons: but then that's like (filter (!= '\''))
12:51:46 <schellsan> has anyone written (or found) a nice intro to FRP, possibly using OpenGL?
12:51:55 <xenocons> hm, yeah, i guess its inefficient
12:52:02 <josephle> which might overzealously kill all the "'"
12:52:09 <xenocons> oh right
12:52:19 <rwbarton> this was not the original question at all :P
12:52:47 <xenocons> im bad at following questions :<
12:52:51 <josephle> heh
12:53:29 <josephle> monochrom has the best answer already
12:53:32 <neutrino_> is using regex-tdfa a good idea?
12:54:39 <monochrom> "generate wrong data, then add one more stage to look for and fix errors" is more inefficient than "generate correct data"
12:55:10 <ziarkaen> I want a way to generate a list [x, f x, f (f x), ... , f ( ... <n times> ... (f x) ...)] such that the end element is equal to 1, with n minimal.  Wat's the most elegant way to achieve this?
12:55:13 <monochrom> inefficient in both computer time and human time
12:56:00 <monochrom> but usually rationalizable by NIV
12:56:06 <monochrom> err, NIH
12:56:44 <neutrino_> ziarkaen: simple recursion.
12:57:28 <sipa> :t until
12:57:29 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
12:57:39 <ziarkaen> sipa, Thanks
12:57:54 <monochrom> do you still want the whole list?
12:57:54 <elliott> > until (== 1) (subtract 1) 10
12:57:56 <lambdabot>   1
12:58:02 <elliott> doesn't quite do what you want
12:58:03 <elliott> however:
12:58:12 <elliott> > takeWhile (/= 1) $ iterate subtract 10
12:58:14 <lambdabot>   Occurs check: cannot construct the infinite type: a0 = a0 -> a0
12:58:21 <elliott> > takeWhile (/= 1) $ iterate (subtract 1) 10
12:58:23 <lambdabot>   [10,9,8,7,6,5,4,3,2]
12:58:25 <xenocons> monochrom: i agree, and if you have the ability to control the expression (data) then making the correct data initially is really nice, this is often impossible though
12:58:25 <elliott> almost does
12:58:42 <sipa> just prefix 1 to it
12:58:48 <elliott> yeah
12:59:04 <invariant> That's not equivalent.
12:59:48 <elliott> (well, suffix 1)
13:01:30 <xenocons> does platform 2012.4 contain ghc 7.6.1 or 7.4.1
13:01:33 <monochrom> there is no absolute "cannot control the data". sometimes, it seems you "cannot" gain control. but it only means, you have to play some politics to gain control
13:01:45 <neutrino_> > let start = 10 in until ((== 20).head.reverse) (\x -> start:(map (+1) x)) [start]
13:01:47 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20]
13:02:11 <xenocons> monochrom: the typical example being someone elses protocol that you are reading off the wire
13:02:28 <neutrino_> but i'd just do a simple recursion.
13:02:32 <glguy> xenocons: nope :)
13:02:49 <elliott> neutrino_: that doesn't produce results incrementally
13:03:04 <glguy> xenocons: http://www.haskell.org/platform/changelog.html 7.4.2
13:03:08 <monochrom> play politics to change the protocol. or walk away from the project altogether, let the blind lead the blind
13:03:08 <elliott> (and reverses the list each step, which will be really slow if your f takes ages to get to 1)
13:03:11 <neutrino_> 21:54 < ziarkaen> I want a way to generate a list [x, f x, f (f x), ... , f ( ... <n times> ... (f x) ...)] such that the end element is equal to 1, with n minimal.  Wat's the most elegant way to achieve this?
13:03:19 <xenocons> oops, heh, i did mean 7.4.2 =p
13:03:20 <neutrino_> 20 6
13:03:36 <neutrino_> 20 = (+1) $ (+1) $ ... $ 10
13:03:42 <glguy> takeWhile (/= 1) (iterate f x) ++ [1]
13:03:53 <neutrino_> it does seem incremental to me
13:04:07 <xenocons> monochrom: well, i dont know, that sounds a bit militant =p
13:04:09 <monochrom> if the protocol is a widespread public one, write very loud blogs to condemn the protocol
13:04:29 <elliott> I guess it is incremental
13:04:36 <elliott> but it goes over all its previous results before producing the next
13:04:44 <elliott> so each result gets slower and slower to produce
13:05:07 <neutrino_> that's why i'd do it recursively
13:05:23 <neutrino_> i was just using sipa's suggestion of the until function
13:05:53 <glguy> ziarkaen: my last message was for you
13:06:00 <sipa> s
13:07:08 <ziarkaen> glguy, Thanks
13:07:50 <quchen> :t until
13:07:52 <lambdabot> (a -> Bool) -> (a -> a) -> a -> a
13:07:56 <theezakje> any heads up on this error: http://hpaste.org/78492 ?
13:08:05 <quchen> Ah, that's the while loop
13:08:39 <neutrino_> > let start = 10 in reverse $ until ((==20).head) (\x -> [(head x) + 1] ++ x) [start]
13:08:41 <lambdabot>   [10,11,12,13,14,15,16,17,18,19,20]
13:08:49 <Cale> theezakje: toChar is supposed to produce a Char, but showPuzzel produces a String
13:09:01 <neutrino_> this avoids repeating work
13:09:07 <Cale> theezakje: String = [Char]
13:09:47 <theezakje> I did this Cale and now it compiles: [toChar a]
13:09:53 <Cale> yeah :)
13:10:10 <theezakje> thanks, AGAIN :)
13:12:21 <theezakje> What do you guys use to edit .hs files in a Windows environment? Since most of the editors I tried fuck up the indentation with tabs and so... Atm using notepad...
13:12:37 <simpson> theezakje: Notepad++ is reliable, although I don't do Haskell on Windows.
13:13:24 <ion> I’d use GVim on Windows™. If i was an Emacs user (i should get around to learning it), i’d also see if there was a nice port of that.
13:13:30 <S11001001> ion: there is.
13:13:39 <S11001001> ion: provided officially, no less
13:15:47 <quchen> There's Sublime for Windows. It's non-free though, but if the "hey this isn't free" message box once per session doesn't annoy you ...
13:16:12 <Cale> theezakje: I've heard of people who liked Notepad++
13:16:22 <Cale> (but I'm not a windows user, so I don't know)
13:16:47 <neutrino_> i dread at doing any work on windows
13:17:22 <Cale> So long as there's an option to convert tabs to spaces automatically, you ought to be okay with indentation issues.
13:17:35 <neutrino_> you can always run virtualbox
13:17:59 <glguy> What are you programming on your gaming rig? :-p
13:18:08 <theezakje> For me Notepad++ is generating way to much tabs
13:18:17 <theezakje> and thus getting indentation errors
13:18:29 <ion> It can’t be configured?
13:18:33 <Cale> I'm sure there's a way to have it convert tabs to spaces
13:19:23 <Cale> http://stackoverflow.com/questions/455037/notepad-tabs-to-spaces
13:19:24 <theezakje> ow yes I notice theres a checkbox "convert tabs to spaces"
13:19:25 <theezakje> :p
13:19:49 <theezakje> ah sweet now
13:20:09 <theezakje> ty
13:27:43 <hpaste> HaxtonFale pasted “Attempt at using random number generation” at http://hpaste.org/78493
13:27:58 <HaxtonFale> Hello!
13:28:07 <HaxtonFale> I'm in dire need of assistance.
13:28:27 <geekosaur> mkStdGen requires that you be in IO
13:28:48 <HaxtonFale> Hm?
13:29:02 <geekosaur> is my guess at least, the standard generator lives in IO because it stores state
13:29:03 <HaxtonFale> It worked fine when typed in GHCi
13:29:16 <geekosaur> GHCI's top level is implicitly in IO
13:29:23 <HaxtonFale> Ah.
13:29:35 <rwbarton> your alignment is wrong
13:29:40 <HaxtonFale> http://hackage.haskell.org/packages/archive/random/1.0.0.2/doc/html/System-Random.html doesn't say anything about that
13:29:41 <rwbarton> because you're using tabs
13:29:58 <HaxtonFale> Tabs worked perfectly fine so far.
13:30:05 <rwbarton> well, this is why they don't :P
13:30:12 <geekosaur> hm, wait, ok, I'm slightly confuised.  so you're using a constant seed at all times?
13:30:16 <HaxtonFale> I'm getting an unidentified '=' character around character 23 in line 3
13:30:27 <HaxtonFale> geekosaur, I'm using a given seed
13:30:33 <HaxtonFale> Or at least trying to
13:30:33 <geekosaur> I was thinking of getStdRandom
13:30:37 <quchen> HaxtonFale: That's the indentation. Your first let line is to spaces lefter than the rest.
13:30:59 <bishboria> Trying to install cabal-dev after installing the latest haskell platform on OS X. cabal-dev warns that it'll break a few packages due to reinstalls… Any advice?
13:31:04 <bgamari> HaxtonFale, I generally stay away from tabs in Haskell
13:31:17 <bgamari> they just make life harder
13:31:20 <HaxtonFale> Thanks for reminding me why I still hate using Haskell.
13:31:35 <parcs`> > (1440*900 / 13.3 / sqrt 2, 1366*768 / 11.6 / sqrt2)
13:31:36 <elliott> it's not GHC's fault it has no way to parse your program
13:31:37 <lambdabot>   Not in scope: `sqrt2'
13:31:37 <lambdabot>  Perhaps you meant `sqrt' (imported from Prelude)
13:31:40 <geekosaur> if you look at how your code pasted into hpaste, yu're seeing how the compiler sees your code.  the bindings on lines 4-6 are indented.. which makes them continuation lines, not new bindings
13:31:43 <elliott> (because you are lying to it)
13:31:47 <Dashkal> If tabs vs spaces is a primary concern for language evaluation, you have missed the point.
13:31:51 <geekosaur> so the = is illegal
13:32:20 * hackagebot directory-layout 0.1.0.0 - Declare, construct and verify directory layout  http://hackage.haskell.org/package/directory-layout-0.1.0.0 (MatveyAksenov)
13:32:36 <hpaste> ch0kee pasted “uff” at http://hpaste.org/78494
13:32:40 <quchen> Dashkal: I think if that's the issue Haskell is in a pretty good standing.
13:32:55 <HaxtonFale> Okay, so now the non-existant '=' is gone, and parse error moved to sizeY
13:33:10 <HaxtonFale> Which means I might have screwed up miltiline let
13:33:16 <HaxtonFale> Or I still don't know how to indent
13:33:22 <quchen> That's the IO hitting you there, not the indentation.
13:33:31 <quchen> mkStdGen has type
13:33:35 <quchen> :t mkStdGen
13:33:37 <lambdabot> Int -> StdGen
13:33:40 <HaxtonFale> So do I add ::Int after that?
13:33:44 <quchen> Oh, nevermind ;-)
13:34:11 <HaxtonFale> BTW, haskellbot?
13:34:58 <HaxtonFale> Anyway, how should I "read" the output then?
13:35:20 <quchen> What's the error message you're getting?
13:35:28 <HaxtonFale> Parse error at sizeY
13:35:40 <quchen> And the next line?
13:35:57 <HaxtonFale> Hm?
13:36:07 <rwbarton> did you paste the new code?
13:36:09 <quchen> What's the line after the "Parse error" error?
13:36:09 <HaxtonFale> Main.lhs:248:17: parse error on input `sizeY'
13:36:15 <HaxtonFale> That's it.
13:36:15 <quchen> Nothing else? Hm
13:36:43 <rwbarton> presumably the indentation is now wrong in some other way
13:37:10 <quchen> I get an ifwalls type error.
13:37:24 <quchen> In any case: you shouldn't create a new RNG for every random number.
13:37:27 <glguy> HaxtonFale: did someone tell you you shouldn't be using fst to throw away the outgoing generator when making randoms?
13:37:27 <HaxtonFale> Oh, a separate function
13:37:31 <rwbarton> yes, that is also true
13:37:43 <HaxtonFale> glguy, no
13:37:46 <neutrino_> this is really cool http://hackage.haskell.org/package/regexdot-0.11.0.1
13:37:54 <quchen> To get multiple numbers, use randomRs
13:37:58 <quchen> :t randomRs
13:38:00 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> [a]
13:38:08 <glguy> HaxtonFale: Instead of making a new Gen over and over, use the result of the previous random number function
13:38:09 <rwbarton> the way it is now, I can exactly guess sizeY given sizeX
13:38:15 <quchen> Takes a generator and boundaries, and returns an infinite list of random numbers.
13:38:18 <glguy> :t randomR
13:38:20 <lambdabot> (RandomGen g, Random a) => (a, a) -> g -> (a, g)
13:39:26 <HaxtonFale> Hm. I only need two random numbers, and pulling the second one seems like a pain...
13:39:32 <HaxtonFale> head of tail and stuff
13:39:43 <elliott> you shouldn't (and don't need to) use either head or tail
13:40:17 <HaxtonFale> ...
13:40:29 <HaxtonFale> How else should I pull from a list?
13:40:30 <chomp> just roll two dice and write down the results
13:40:36 <HaxtonFale> Indexes?
13:40:43 <elliott> pattern matching
13:40:53 <hpaste> quchen pasted “foobar” at http://hpaste.org/78495
13:41:31 <quchen> That's a version that takes a generator as parameter, splits it and uses up one of the splits for the stream of randoms, and returns something along with the new generator.
13:41:48 <quchen> (A State version might be more beautiful though.)
13:42:18 <quchen> Oh, wait, the pattern matching is wrong
13:42:18 <hpaste> glguy annotated “Attempt at using random number generation” with “Random maze changes” at http://hpaste.org/78493#a78496
13:42:20 * hackagebot elerea-sdl 0.1 - Elerea FRP wrapper for SDL  http://hackage.haskell.org/package/elerea-sdl-0.1 (StephenWeber)
13:42:35 <quchen> That's better: (sizeX:sizeY:_) = randomRs (1, 25) g
13:42:58 <glguy> HaxtonFale: I didn't try loading that with GHC first, but it's closer to the right shape
13:43:22 <HaxtonFale> I need something that doesn't need a generator supplied, only seed
13:43:41 <glguy> then make one generator from that seed
13:43:51 <quchen> You should separate those two steps.
13:44:15 <quchen> Call the function with something that makes the generator if you need to have a new one.
13:44:41 <hpaste> glguy annotated “Attempt at using random number generation” with “takes a seed” at http://hpaste.org/78493#a78497
13:46:21 <hpaste> quchen annotated “Attempt at using random number generation” with “Attempt at using random number generation (annotation)” at http://hpaste.org/78493#a78498
13:49:35 <hpaste> HaxtonFale annotated “Attempt at using random number generation” with “Current solution” at http://hpaste.org/78493#a78499
13:49:44 <HaxtonFale> This one loads correctly.
13:49:55 <glguy> HaxtonFale: you don't need the "take"
13:50:09 <glguy> zip stops zipping when one of the two lists runs out
13:50:43 <HaxtonFale> Right.
13:51:10 <HaxtonFale> Okay, seems to be working fine.
13:51:13 <HaxtonFale> Thank you.
13:51:31 <glguy> HaxtonFale: Do you understand why it works now?
13:51:51 <HaxtonFale> Not quite, to be honest.
13:51:59 <HaxtonFale> Because I'm still not sure what was wrong before.
13:52:17 <HaxtonFale> Because that was one of the things I had to look up on my own.
13:52:34 <glguy> Your original paste was wrong because it used tabs incorrectly
13:52:44 <ciaranm> gah. my monad-fu has failed me. turning [[1, 2], [3, 4], [5, 6]] into [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]. discuss!
13:52:57 <glguy> and because it misused outputs for creating new random generators
13:53:11 <c_wraith> isn't that sequence?
13:53:15 <glguy> > sequence [[1, 2], [3, 4], [5, 6]]
13:53:17 <lambdabot>   [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
13:53:23 <ciaranm> oh, so it is :(
13:53:41 <ciaranm> cheers
13:53:42 <HaxtonFale> glguy, I see.
13:53:59 <HaxtonFale> I've only known Haskell for about eight weeks now.
13:54:16 <HaxtonFale> And despite being at Oxford, no one ever bothered to explain the rules for indentation.
13:54:29 <HaxtonFale> Or how to use let/while, for that matter.
13:54:37 <ciaranm> explaining syntax rules is a waste of time when teaching
13:54:55 <ciaranm> you really don't want to sit through three lectures on how to type in a floating point number and exactly what you can and can't use for scientific notation
13:55:08 <rwbarton> indentation rules are basically "make it look nice, so the indentation reflects the structure of the code, and don't use tabs"
13:55:14 <HaxtonFale> I just want to know that Haskell really cares for indentation
13:55:32 <elliott> it actually cares about alignment
13:55:33 <elliott> which is why tabs are bad
13:55:43 <elliott> because you will treat them as something other than 8-wide
13:55:47 <elliott> and that will make your alignment look wrong to GHC
13:56:02 <quchen> Not really. It requires a certain coding style though.
13:56:04 <HaxtonFale> If this is a functional programming class and they especially care about teaching us Haskell specifically, I believe they should at least say "don't indent with tabs"
13:56:07 <elliott> (you can avoid all cases that require "alignment" per se entirely and just use indentation but it looks ugly and is very easy to mess up)
13:56:15 <HaxtonFale> Or whatever
13:56:37 <glguy> HaxtonFale: Tabs are fine, you just have to configured your editor. People tend to not like tabs for programming in general
13:56:46 <HaxtonFale> Heh.
13:57:22 <HaxtonFale> My forte is not in FP, but in procedural, so I'm kind of reliant on tabs for making it look clear
13:57:34 <elliott> ?
13:57:35 <glguy> even in C spaces are fine for indentation
13:57:38 <elliott> you can just use a bunch of spaces rather than tabs
13:57:39 <Dashkal> Spaces.  Always spaces.  Every language, every case.  Spaces.
13:57:41 <elliott> it will look just the same
13:57:41 <HaxtonFale> Especially C#, where Visual Studio tends to format using tabs.
13:57:45 <HaxtonFale> Automatically.
13:57:47 <hpaste> quchen annotated “Attempt at using random number generation” with “Long comments on the random parts” at http://hpaste.org/78493#a78500
13:57:53 <elliott> I'm sure VS has a setting to indent with spaces, not tabs
13:58:06 <elliott> practically all editors do
13:58:08 <hpc> Dashkal: see also cpan's Acme::Bleach
13:58:26 <Dashkal> I'm thinking that I should write a push hook that rejects anything with tabs in it.
13:59:00 <quchen> Dashkal: And too frequent use of verbs in comments too maybe. Wrong capitalisation? Rejected!
13:59:00 <HaxtonFale> To each their own.
13:59:16 <Dashkal> hah, just tabs, and for the reason mentioned.  It messes up indentation levels.
13:59:39 <quchen> No it doesn't. If you misuse it it does.
14:00:01 <quchen> You need a newline after every where/let/..., and that's it.
14:00:14 <monochrom> you can use tabs, but know what tabs really mean
14:00:20 <rwbarton> yes, there are several policies that will lead to success
14:00:27 <rwbarton> "don't use tabs" is just the simplest of them
14:00:32 <hpc> if you feel like being mean, use /usr/dict to change every identifier to the nearest word
14:00:43 <hpc> (levenshtein distance)
14:00:53 <monochrom> hahaha
14:01:10 <Dashkal> quchen: The very fact that changing tab size is commonplace makes using tabs dangerous.  There's no easy way to tell what indentation level that last developer used short of trial and error.  Hence my rejection of that as a legal character in any source file I control.
14:01:22 <hpc> most of Prelude should remain intact
14:01:39 <glguy> Dashkal: At least in Haskell you know that the last developer used 8 or that it doesn't matter :)
14:01:44 <quchen> Dashkal: When using tabs correctly, your code is independent of how large one tab is in spaces.
14:01:58 <HaxtonFale> ^
14:02:02 <quchen> That's kind of the point of tabs: custom indentation width.
14:02:14 <Dashkal> "When using tabs correctly" <-- My position is that that statement is nonsence.  There is no correct use.
14:02:21 <Dashkal> This is non-negotiable for me
14:02:25 <Cale> Dashkal: agreed
14:02:28 <rwbarton> the idea that an editor might show tabs as other than "to next multiple of 8" is foreign to me
14:02:38 <Cale> Tabs are pure evil, and should never appear in source code.
14:02:45 <gnuvince> How does one typically sort a list in Haskell by multiple parameters?  I have a [[Int]] and I'd like to have it sorted first by the length of the lists, and for lists of equal length, have them sorted on their elements (the elements are all equal, e.g. [[3,3], [2], [1,1]] -> [[2], [1,1], [3,3]]
14:02:46 <elliott> can we not have a tabs<->spaces flamewar
14:02:58 <elliott> there's a difference between pointing out why tabs are specifically problematic in Haskell and that
14:03:06 <glguy> gnuvince: The Monoid instance for Ordering is handy for this
14:03:11 <hpc> let's have a LF/CRLF flamewr!
14:03:19 <glguy> hpc: windows is for gaming
14:03:34 <Cale> elliott: It's not really a flamewar, it's a circlejerk, since everyone is in complete agreement on this.
14:03:34 <quchen> hpc: windows is for
14:03:37 <monochrom> "ff = do x\t\ny" is dependent on what \t means. note that I carefully align it for haskell, not for your customized tab "size"
14:03:38 <quchen> (statement ends there)
14:03:38 <Cale> EVERYONE
14:03:45 <Dashkal> Hah!
14:03:59 <elliott> Cale: does it help if I'm not?
14:04:08 <Cale> elliott: YOU AGREE
14:04:09 * elliott doesn't actually use tabs though.
14:04:38 <quchen> monochrom: Trim your trailing spaces. Tab's gone, problem's gone.
14:04:47 <glguy> gnuvince: sortBy (\a b -> compare (length a) (length b) <> compare a b)
14:04:51 <monochrom> oh, sorry
14:04:58 <monochrom> ff = do x\n\ty
14:05:53 <quchen> I'm using spaces myself, but usually the arguments brought up against tabs are based on wrong examples.
14:06:22 <ciaranm> i use vertical tabs
14:06:32 <monochrom> sure, I won't support wrong examples
14:06:34 <quchen> In the last case, you can't write code like that. It's bad indentation, should be avoided, and you have to write do\n every time. That's the price you have to pay for tabs in Haskell.
14:07:07 <gnuvince> glguy: what's <>?
14:07:08 <elliott> there's nothing wrong with always following do with a newline...
14:07:14 <glguy> :t (<>)
14:07:15 <lambdabot> Monoid m => m -> m -> m
14:07:18 <watermind> glguy: compare `on` length <> ...
14:07:18 <elliott> the most common codified haskell coding style I know of does that
14:07:29 <watermind> glguy:  on is pretty handy too
14:07:30 <glguy> watermind: yeah, that's another neat Monoid instance
14:07:34 <gnuvince> glguy: alias for mappend?
14:07:38 <glguy> gnuvince: yes
14:07:44 <gnuvince> thanks
14:07:44 <ciaranm> people still use 'do'? i thought that was considered deprecated
14:07:55 <quchen> elliott: Well, with tabs you *have* to have the NL there, with spaces you don't. Tabs make the code look a little torn apart if you ask me. That was kind of the only reason I switched to SP.
14:07:56 <glguy> f <> g    is    \x -> f x <> g x
14:07:59 <HaxtonFale> Okay, thank you for your help again.
14:08:00 <HaxtonFale> o/
14:08:16 <glguy> gnuvince: so watermind's suggesting can make things even shorter
14:08:45 <monochrom> my example is not "do\n". but you can always say all my examples are bad indentation
14:08:53 <ciaranm> on a non-flamewar note, i need a symbol i can stick in front of a whole load of other operators that no-one is using yet... is (.<.) (.+.) taken?
14:09:10 <watermind> glguy: I think "on" is on Data.Function
14:09:19 <glguy> That's right
14:09:21 <glguy> ?index on
14:09:21 <lambdabot> bzzt
14:09:25 <glguy> well, it is :)
14:09:27 <quchen> You're saying "if you write wrong code it won't compile". That's not an argument against tabs, that's an argument against wrong code.
14:09:29 <watermind> :)
14:09:34 <acowley> How do people feel about Bool arguments to a function vs. an isomorphic type?
14:09:43 <watermind> ciaranm: I usually use |+| and |*|
14:09:58 <monochrom> my example is right code
14:10:11 <elliott> ciaranm: (.&.) and (.|.) are taken
14:10:11 <quchen> Nevermind. You're right, sir
14:10:16 <monochrom> also, you will notice that I am not against tabs
14:10:17 <elliott> acowley: I dislike Bool arguments
14:10:36 <ciaranm> hrm. i'd need .&&. and .||. at some point.
14:10:38 <koala_man> True | False | FileNotFound
14:11:07 * ciaranm idly considers using the snowman
14:11:25 <watermind> acowley: isomorphic to?
14:11:34 <monochrom> the snowman is cool. only problem is that lambdabot is inconsistent with utf-8
14:12:16 <gabor> > @ty traverse
14:12:18 <lambdabot>   <hint>:1:1: parse error on input `@'
14:12:26 <gabor> @ty traverse
14:12:28 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
14:12:58 <monochrom> I am only against "tab means whatever you want". no, not you. the language.
14:13:26 <koala_man> acowley: depends how isomorphic it is. if it's something you'd want to invert or 'and' together, I think I would prefer a Bool.
14:13:32 <glguy> watermind: True|False    vs      Forward|Backward     or     Run|Walk
14:13:52 <glguy> (is how I interpreted that)
14:13:54 <byorgey> bgamari: cool, I hadn't heard of implicitcad before
14:14:01 <josephle> acowley: when I write proofs in agda, isomorphic types
14:14:16 <watermind> glguy: right, wasn't sure if it was that or  Bool->A>T  vs  Either A A -> T
14:14:45 <acowley> josephle: I suppose my question is whether the self-documenting aspects of distinct data constructors is worth any potential cognitive overhead from introducing a new type.
14:15:22 <acowley> I mean, there is a benefit to a common type: lots of functions return Bool!
14:15:41 <watermind> acowley: I think there is a cognitive overhead in interpreting the context dependent meaning of a Bool
14:15:42 <acowley> But when explicitly writing a value, a fresh type is much more descriptive
14:15:44 <koala_man> I don't think the cognitive overhead is higher with Run|Walk than True/False. It's rather the opposite
14:15:45 <monochrom> newtype Mine = Mine Bool
14:16:16 <acowley> To play devil's advocate
14:16:27 <atriq> newtype Craft = Craft (Craft -> Mine)
14:16:30 <acowley> if you encounter the expression "f True", you know the only possible other parameter is False
14:16:40 <Nisstyre> acowley: it only matters if you want it to be able to unify with functions that also use Bool, e.g. filter
14:16:41 <acowley> if you encouter "f Run", you don't know what options there might be
14:16:59 <Nisstyre> acowley: otherwise go with the most descriptive version
14:17:13 <Nisstyre> (which could be Bool anyway)
14:17:21 * hackagebot hakyll 3.5.2.0 - A static website compiler library  http://hackage.haskell.org/package/hakyll-3.5.2.0 (JasperVanDerJeugt)
14:17:28 <elliott> has anyone mentioned boolean blindness yet
14:17:49 <monochrom> is that like innumeracy?
14:17:59 <acowley> Nisstyre: Thats rather tricky to determine though! We encounter many problems due to library authors not imagining certain valid use cases of their code. Then we have unexported constructors, etc.
14:18:18 <acowley> elliott: I assumed the reference was implicit in this crowd :)
14:18:23 <Nisstyre> acowley: so write a wrapper function or use a lambda
14:18:30 <Philippa> acowley: otherwise where the author imagined certain valid uses of the library-as-it-is-now that might affect directions they want to go in, of course
14:18:40 <Nisstyre> acowley: most libraries have the constructors for their types exportec
14:18:43 <Nisstyre> *exported
14:18:47 * elliott would be interested in a Haskell where Bool doesn't exist by default
14:18:57 <rwbarton> sounds bad
14:18:58 <elliott> though you can't really eliminate boolean blindness fully in a language with no dependent types :(
14:19:04 <acowley> poor filter
14:19:06 <rwbarton> boolean blindness is way overrated
14:19:08 <elliott> and numerics would get a bit painful
14:19:12 <josephle> so now everyone just has Either () ()?
14:19:20 <acowley> Yes, that's much simpler
14:19:24 <atriq> (a -> a -> a)
14:19:28 <monochrom> if you have "x>0" you need Bool
14:19:31 <acowley> 1 == 2, true or false? Left.
14:19:38 <rwbarton> another example of "not the best for certain problems" /= "not the best for any problem"
14:20:12 <bgamari> byorgey, it's a fairly new project, things are still very much in a state of flux
14:20:27 <monochrom> but perhaps you can use continuations. x>0 :: a -> a -> a
14:20:32 <acowley> Philippa: Yes, not exposing internals is totally valid in many cases, and of real value to the library's users.
14:20:43 <byorgey> bgamari: wait, is it your project?  Or you're just playing with it?
14:20:58 <elliott> rwbarton: well, in a dependently-typed language you can make much much more things return proof evidence of propositions that would otherwise be booleans
14:21:12 <rwbarton> but who cares
14:21:12 <bgamari> byorgey, colah wrote it, I'm now contributing
14:21:13 <elliott> so Bool is much less useful if you expand your language
14:21:15 <rwbarton> most of the time, you don't
14:21:17 <byorgey> bgamari: cool
14:21:25 <rwbarton> I have seen the arguments, and I just don't buy it
14:21:26 <Nisstyre> elliott: which would you recommend for a dependently typed virgin, Epigram, CoQ, or Agda?
14:21:34 <Nisstyre> or something else?
14:21:41 <watermind> acowley: that reminds me, is there a way to 'close a class', i.e. disallow further instances?
14:21:42 <bgamari> byorgey, diagrams has no CSG operations, correct?
14:21:48 <Ralith> don't forget idris
14:21:49 <byorgey> bgamari: ooh, it has a Haskell API
14:21:52 <elliott> Nisstyre: I'm more competent in Coq than the others, but Agda might be a bit more conventional
14:21:55 <ciaranm> Nisstyre: i recommend a good hard CoQing
14:21:58 <byorgey> bgamari: correct, not yet at least
14:22:01 <watermind> acowley: or to close a kind, i.e. disallow further types of that kind to be declared via type families?
14:22:02 <elliott> Epigram 1 is dead and Epigram 2 is taking a good forever to start existing
14:22:02 <Nisstyre> elliott: yeah I've heard a lot about Agda
14:22:27 <acowley> watermind: Not entirely, but if you restrict the Kind of a type class argument you've done something to limit non-overlapping instances.
14:22:27 <bgamari> byorgey, I really like ImplicitCAD's representational approach
14:22:32 <byorgey> bgamari: though adding CSG objects as a new primitive would be very easy as long as there's a backend that can render them
14:22:51 <acowley> watermind: No, type families are open. The best you can do to close things is use GADTs
14:22:54 <bgamari> byorgey, It makes these operations very easy to implement
14:23:12 <bgamari> byorgey, Implicit's codebase isn't terribly idiomatic at the moment
14:23:23 <bgamari> but I am chipping away at this
14:24:04 <josephle> Nisstyre: Agda is pretty sane, especially if you're coming from haskell. Coq starts out fine, but then tactics and oh-god-why-don't-my-types-beta-reduce makes for fun times.
14:24:20 <elliott> assuming you buy a new keyboard first
14:24:32 <watermind> acowley: hmm how do GADTs help close things? One example I was thinking of was precisely unsing GADT's, and a phantom type as a label. We can make that phantom type to be of some new kind, but we can always extend the kind...
14:24:48 <gdeest> doing Coq right now I can confirm what josephle's saying ;)
14:25:03 <gdeest> (Coq's type errors are frightful)
14:25:09 <acowley> watermind: You can't add data constructors, so the GADT itself is closed.
14:25:24 <byorgey> bgamari: ah, it represents things with implicit functions, nice
14:25:32 <watermind> acowley: yes right that is true
14:25:55 <acowley> watermind: The upshot being that you can write a total function that takes the GADT as a parameter
14:25:59 <bgamari> byorgey, yep
14:27:12 <watermind> acowley: right...
14:27:21 * hackagebot fixed-vector 0.1.1 - Generic vectors with fixed length  http://hackage.haskell.org/package/fixed-vector-0.1.1 (AlexeyKhudyakov)
14:27:29 <watermind> acowley: I still find GADT's alone somewhat limited for some use cases though...
14:27:56 <acowley> watermind: Sure, I think it's interesting that we don't see them used more pervasively.
14:28:20 <watermind> acowley: indeed
14:28:38 <bgamari> colah, On that note, any news about merging pull request 75?
14:29:43 <bgamari> colah, I'm still trying to get to the bottom of the performance regression due to Point, but I imagine it will be fixed eventually
14:29:56 <Taslem> Num instances let you use integer literals to refer to other data types, right? ie: 5 :: MyType. Is there an equivalent for floating-point values, 5.6 :: MyType?
14:31:10 <fmap> > 1.5 :: Int
14:31:12 <lambdabot>   No instance for (GHC.Real.Fractional GHC.Types.Int)
14:31:12 <lambdabot>    arising from the lit...
14:31:31 <xnyhps> Fractional
14:32:55 <parcs`> :t 5.6
14:32:57 <lambdabot> Fractional a => a
14:33:12 <Taslem> Okay, thanks.
14:33:22 <Taslem> I didn't think to check that...
14:33:58 <hayashi> woo, cabal hell strikes again!
14:34:36 <ciaranm> i'd like to allow expressions like "v1 .<=. v4 .-. 1". i have it working, except 1 has to be replaced by (1 :: Int). the type of (.-.) is (Expr a, Expr b) => a -> b -> CompoundExpr, and i've made Int an instance of Expr. i can't easily make arbitrary Num an instance of Expr though. is there a nice way around this?
14:34:39 <hmax> i thought cabal-dev is the answer now
14:35:51 <bzm3r> I have trouble going through Learn You A Haskell For Greater Good because I am just getting...bored...going through all the syntactical stuff. Is this just me being a poor student (glue your ass to your seat, and chug through it), or are there other options that present the information in a more condensed fashion minus all the "let's hold hands and go on a walk" stuff
14:36:08 <bzm3r> I guess I am being impatient, and trying to jump too far, too fast.
14:36:44 <c_wraith> How are you getting bored? It's like a couple hours, and it crams in a whole lot of important non-syntactic stuff, too
14:37:23 <parcs`> solution: skim through the boring parts
14:37:28 <acowley> bzm3r: Try coding up something that holds your interest. When you hit rough waters, you'll be motivated to work through at least part of LYAH.
14:37:40 <bzm3r> c_wraith: Hmm, I guess I was going through it with a magnifying glass, carefully taking notes
14:37:57 <c_wraith> oh, yeah.  It's not dense enough for that to pay off.
14:37:58 <ski> > let f@g = \x -> x^2 in map ($ 3) [f,g]
14:38:00 <lambdabot>   [9,9]
14:38:20 <bzm3r> parcs`, acowley I'll try that out
14:38:22 <ski> > let (f@g) x = x^2 in map ($ 3) [f,g]
14:38:24 <lambdabot>   <hint>:1:5: Parse error in pattern: (f@g)
14:38:44 <bzm3r> wow, is there a built in interpreter int his channel?
14:38:47 <bzm3r> 5 + 6
14:38:57 <bzm3r> Not quite.
14:39:03 <josephle> > 5 + 6
14:39:04 <lambdabot>   11
14:39:12 <josephle> you forgot the '>'
14:39:16 <bzm3r> ahhh
14:39:21 <bzm3r> Amazing!
14:39:22 <ciaranm> > take 100 (cycle "monkey":)
14:39:23 <tac> > sort [5..1]
14:39:25 <lambdabot>   []
14:39:25 <lambdabot>   can't find file: L.hs
14:39:28 <tac> doh
14:39:44 <bzm3r> > :t 5
14:39:46 <lambdabot>   <hint>:1:1: parse error on input `:'
14:40:28 <sonOfRa> type 5
14:40:32 <sonOfRa> i think
14:40:33 <sonOfRa> or not
14:41:21 <parcs`> @type 5
14:41:23 <lambdabot> Num a => a
14:44:52 <Taslem> @type 5 --comments?
14:44:53 <lambdabot> Num a => a
14:46:03 <c_wraith> numeric constants are polymorphic in haskell!
14:47:01 <Nisstyre> @type 5.0
14:47:03 <lambdabot> Fractional a => a
14:48:16 <pmade> I'm trying to use Parsec to extract URLs from a file where I skip everything that isn't a URL, but I can't figure out how to do the skipping.  Is Parsec the wrong tool for this?
14:48:43 <victorm> hi!
14:48:52 <c_wraith> it's not wrong, though it might not be the best.
14:48:59 <Heffalump> pmade: regexps are probably simpler for that job
14:49:16 <victorm> how can I print some information in parsec during the parsing stage (for debugging purposes) ?
14:50:20 <Ralith> there's Debug.Trace, but a better idea might be to factor your parser well and test small components directly
14:50:46 <pmade> I like that Parsec reads better than regular expressions, but I'm throwing away a lot of content so that's probably what I should do (use an re that is)
14:52:09 <glguy> Parsec provides a monad transformer you could wrap around IO
14:52:15 <victorm> Ralith: that's what I've been trying:
14:52:21 <acowley> What's wrong with using parsec for this?
14:52:32 <victorm> insertReg r t = do updateState (ST.insert reg (ST.SDRegister reg t))                    trace ("insertReg: " ++ show r ++ show t)                    return reg   where reg = ST.toKey r
14:52:42 <victorm> :(
14:52:48 <Ralith> :t Debug.Trace.trace
14:52:50 <lambdabot> String -> a -> a
14:53:02 <Ralith> trace takes two arguments
14:53:05 <Ralith> you've only given it one
14:53:09 <Ralith> ghc probably told you this already
14:53:27 <quchen> Does anyone know the status of making BangPatterns standard?
14:54:01 <victorm> Ralith: oh, that's try
14:54:01 <victorm> true*
14:54:15 <victorm> I though I was doing something stupid with monads, thanks
14:54:47 <arpunk> Ralith: im sorry, are you the same Ralith from #netsukuku years ago?
14:54:50 <Ralith> you probably want (return ()) as the second argument
14:54:55 <Ralith> arpunk: most likely.
14:54:58 <Ralith> why?
14:55:18 <arpunk> Ralith: had to ask, I remember we once tried to collaborate on that project
14:55:37 <Ralith> yes, shame its maintainers moved on
14:55:52 <Ralith> arpunk: you might be interested in http://cjdns.info/
14:55:58 <arpunk> Ralith: sort of, there is a "new" implementation, in Vala :(
14:56:17 <Ralith> it's substantially more active than ntk ever was
14:56:39 <Ralith> not as much of a theoretical grounding, unfortunately.
14:57:04 <Ralith> arpunk: where is news posted these days?
14:58:16 <colah> bgamari: I'm happy to merge it once it acheives parity with present performance, but I don't really want to do so before hand. Performance is very important for ImplicitCAD.
14:58:21 <acowley> Kind of wish we could use ∀ with ScopedTypeVariables.
15:01:07 <bgamari> colah, fair enough
15:01:15 <bgamari> colah, We should build up a larger set of benchmarks in that case
15:01:33 <colah> bgamari: This would be a very good idea.
15:01:40 <bgamari> colah, currently I'm just using two relatively simple models which I'm not at all convinced are representative
15:02:15 <colah> bgamari: There are a few ImplicitCAD based projects in the wild. We could grab them and use them as benchmarks? :)
15:02:34 <bgamari> colah, definitely
15:03:46 <colah> bgamari: I really should have set up benchmarks a long time ago, but my only computer is really slow and it takes a long time to just recompile... I'm getting a replacement in a few weeks, which is very exciting!
15:04:06 <startling> I want to search a file of binary junk for a specific pattern of bytes. Once I find the pattern, I know I'd just use cereal or data-binary, but I'm not sure of the best way to find the pattern in the first place
15:04:26 <Saizan> acowley: with UnicodeSyntax you can, i think
15:05:27 <colah> bgamari: I've just been testing performance using `time` and a few examples.
15:05:40 <bgamari> colah, As have I
15:05:49 <johnw> Criterion is quite friendly to use
15:05:58 <bgamari> colah, I can break out my criterion benchmark into a separate pull request
15:06:48 <Ralith> startling: it seems like a simple enough operation to just implement directly
15:06:56 <Ralith> assuming you mean literal pattern
15:07:03 <Ralith> and not something more complex
15:07:47 <bgamari> colah, done: https://github.com/colah/ImplicitCAD/pull/77
15:07:56 <startling> Ralith, with a fold or something? yeah, fair enough
15:08:40 <Ralith> sometimes you just don't need a combinator library ^^
15:08:47 <startling> heh.
15:09:03 <gabor> edwardk: is this type defined somewhere?      data OnPath p = forall a . a `PrefixOf` b => (a, a -> b)
15:09:24 <gabor> kind of subdivison of a path
15:10:10 <colah> bgamari: "import Data.AffineSpace.Point" ?
15:10:14 * elliott wonders what PrefixOf is
15:10:19 <elliott> to make that not isomorphic to b
15:10:25 <elliott> er, wait
15:10:29 <arpunk> Ralith: gotta run, tty tomorrow, new repo is here: https://savannah.nongnu.org/projects/netsukuku/
15:10:30 <elliott> b is out of scope there
15:10:31 <bgamari> colah, Damn, my bad
15:10:42 <gabor> elliott:   A -> B -> C  has a prefix A -> B
15:10:50 <colah> bgamari: np, fix that and I'll merge it.
15:10:53 <elliott> where is the b quantified there?
15:11:09 <Ralith> arpunk: \o
15:11:23 <gabor> grrr.
15:11:32 <bgamari> colah, Perhaps we could just merge the vector-space branch while I sort out the affine-space branch?
15:11:39 <bgamari> colah, One is based on the other
15:11:53 <gabor> elliott: OnPath p = forall a . a `PrefixOf` p => (a, a -> p)
15:12:02 <bgamari> colah, vector-space doesn't appear to have any detrimental effect on performance
15:12:15 <bgamari> colah, Since it's mostly just changing operators
15:12:22 * hackagebot xournal-types 0.5 - Data types for programs for xournal file format  http://hackage.haskell.org/package/xournal-types-0.5 (IanWooKim)
15:12:25 * hackagebot xournal-parser 0.5 - Xournal file parser  http://hackage.haskell.org/package/xournal-parser-0.5 (IanWooKim)
15:12:26 * hackagebot hoodle-types 0.1 - Data types for programs for hoodle file format  http://hackage.haskell.org/package/hoodle-types-0.1 (IanWooKim)
15:12:28 * hackagebot hoodle-builder 0.1 - text builder for hoodle file format  http://hackage.haskell.org/package/hoodle-builder-0.1 (IanWooKim)
15:12:30 * hackagebot hoodle-parser 0.1 - Hoodle file parser  http://hackage.haskell.org/package/hoodle-parser-0.1 (IanWooKim)
15:12:41 <bgamari> colah, AffineSpace is problematic since the newtype apparently kills some deforestation
15:12:47 <elliott> gabor: right. what is the actual class definition of PrefixOf?
15:15:56 <beaky> hello
15:16:14 <startling> so I've got a 20-bit unsigned integer I have to deal with. Any suggestions?
15:16:15 <Eduard_Munteanu> Hi.
15:16:27 <johnw> hello Eduard_Munteanu!
15:16:30 <startling> Should I just stick it in an Int32 asap?
15:16:41 <johnw> startling: stat!
15:16:48 <startling> haha
15:16:53 <mm_freak> startling: newtype Int20 = Int20 Int32
15:17:07 <johnw> newtype Int20 = I# Int# :)
15:17:25 <johnw> why not just make it a raw integer
15:17:29 <mm_freak> or if you're brave:  newtype IntB bits = IntB Integer
15:17:32 * hackagebot hoodle-render 0.1 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.1 (IanWooKim)
15:17:34 <gabor> elliott: it is tricky, you need a type-level 'inits' that is generalized over an arbitrary binary type constructor, then identify 'a' as one of the prefixes with type equality :-)
15:17:34 * hackagebot hoodle-core 0.7 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.7 (IanWooKim)
15:17:36 <mm_freak> if you want this, check out the 'reflection' package
15:17:36 * hackagebot hoodle 0.1 - Executable for hoodle  http://hackage.haskell.org/package/hoodle-0.1 (IanWooKim)
15:17:42 <startling> and then define a Num instance or something?
15:17:46 <mm_freak> yes
15:17:54 <startling> that's doable. thanks!
15:17:55 <elliott> gabor: nice
15:18:06 <beaky> how do I
15:18:09 <johnw> err, s/newtype/type
15:18:18 <Eidel> How do i downgrade a package with cabal?
15:18:23 <elliott> mm_freak++ # paycheck for promoting reflection
15:18:24 <johnw> Eidel: install that specific version
15:18:33 <johnw> Eidel: cabal install foo-1.0.0
15:18:50 <johnw> then unregister the later version, if you really despise it
15:19:16 <Eidel> johnw: it complains about ambiguous module
15:19:24 <johnw> show me?
15:19:58 <hpaste> Eidel pasted “Ambiguous” at http://hpaste.org/78505
15:20:47 <johnw> i have no idea at this point
15:20:52 <Eidel> Ok
15:20:57 <johnw> wipe ~/.ghc and ~/.cabal/lib/*, start again
15:21:28 <Eidel> I saw that alex is installed as an ubuntu-package when i install haskell-platform with apt-get
15:25:04 <Eidel> I downloaded an older version from launchpad (ubuntu repositories) and it automagically downgraded when i installed it. It works now :)
15:29:31 <axkrts> hello
15:29:53 <axkrts> I have been playing with Data.Serialize and would like some advice on how to simplify this code
15:29:57 <axkrts> http://hpaste.org/78506
15:30:31 <axkrts> I used getMsg and putMsg because I am not sure how to make Msg an instance of Serialize
15:30:44 <axkrts> since the type of Msg is encoded in Header
15:32:23 * hackagebot hoodle-core 0.7.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.7.0 (IanWooKim)
15:32:25 * hackagebot lio 0.9.2.0 - Labeled IO Information Flow Control Library  http://hackage.haskell.org/package/lio-0.9.2.0 (DeianStefan)
15:33:13 <glguy> axkrts: It often isn't a good idea to make new Serialize instances. Most of the time you end up just making new functions using the existing Serialize instances
15:33:16 <edwardk> gabor: not in my code
15:34:04 <glguy> axkrts: Especially in cases like this when you need more arguments like from the header
15:34:08 <axkrts> glguy: can you elaborate?
15:34:28 <glguy> axkrts: just make a function: getMsg which has the header as a parameter
15:34:34 <glguy> you don't need to wedge it into the Serialize class
15:34:50 <aaronj1335> so in ghci, this works: `let f a = if a then Right [1,2] else Left "problem"`, but if i add the type declaration on the end, it fails: `<same> :: Num t => Bool -> Either [Char] [t]`. why is that?
15:34:58 <nerko> @hoogle+ map
15:34:58 <lambdabot> Data.Functor.Identity Identity :: a -> Identity a
15:34:58 <lambdabot> Data.Functor.Identity newtype Identity a
15:34:59 <lambdabot> Control.Monad.Trans.Identity IdentityT :: m a -> IdentityT m a
15:37:39 <hpaste> “Ertugrul Söylemez” pasted “Ints with a certain bit size” at http://hpaste.org/78507
15:37:48 <mm_freak> startling: see the paste
15:38:07 <mm_freak> you can then use 'reify' with a certain bitmask
15:38:43 <arthurdent> Why doesn't this work?: data Ops = :+: | :-: | :*: | :/:
15:38:48 <startling> mm_freak: wow, cool.
15:39:07 <startling> arthurdent: you have to give them types
15:39:08 <Peaker> arthurdent, These are infix names, so syntactically they must appear in infix context
15:39:21 <Peaker> arthurdent, something like:  data Ops = Int :+: Int | ...
15:39:24 <nerko> hello, what does the command @hoogle+ ?
15:39:30 <arthurdent> Peaker: oh! thanks
15:39:33 <rwbarton> I wonder whether "data Ops = (:+:) | ..." works
15:39:39 <mm_freak> arthurdent: data Ops = (:+:) | (:-:) | (:*:) | (:/:)
15:39:40 <Eduard_Munteanu> nerko: show more @hoogle results
15:39:44 <Peaker> rwbarton, if it did, it'd still be quite useless?
15:39:48 <Eduard_Munteanu> @hoogle sequence
15:39:49 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
15:39:49 <lambdabot> Control.Monad sequence :: Monad m => [m a] -> m [a]
15:39:49 <lambdabot> Prelude sequence_ :: Monad m => [m a] -> m ()
15:39:49 <mm_freak> arthurdent: but that's very likely not what you want
15:39:50 <rwbarton> sort of misleading though since you could never use it yeah
15:39:50 <startling> data Ops a = a :+: a | a :-: a | a :*: a | a :/: a
15:39:53 <Eduard_Munteanu> @hoogle+
15:39:53 <lambdabot> Control.Monad sequence_ :: Monad m => [m a] -> m ()
15:39:53 <lambdabot> Data.Traversable sequence :: (Traversable t, Monad m) => t (m a) -> m (t a)
15:39:53 <lambdabot> Data.Foldable sequence_ :: (Foldable t, Monad m) => t (m a) -> m ()
15:39:59 <nerko> show more @hoogle results
15:40:06 <rwbarton> never use it as infix
15:40:08 <nerko> @hoogle results
15:40:09 <lambdabot> Test.QuickCheck.Property protectResults :: Rose Result -> Rose Result
15:42:51 <beaky> how do I put my own modules in namespaces?
15:43:00 <beaky> like how all the standard stuff is organized in namespaces?
15:43:09 <beaky> i.e. Data.List, Data.Map are all under Data
15:43:16 <rwbarton> mkdir Data
15:43:20 <beaky> oh
15:43:21 <borkdude> I installed the Haskell platform on OSX - is documentation locally installed with it and how can I see it?
15:43:37 <rwbarton> then mv List.hs Data/ and "module Data.List where"
15:46:10 <shanse> borkdude: try file:///Library/Haskell/doc/start.html
15:46:29 <borkdude> shanse tnx!
15:46:56 <borkdude> shanse I remember seeing this when I installed it, but forgot where it went
15:47:56 <merijn> borkdude: And also /Users/youraccount/Library/Haskell/doc for documentation of packages installed under your user only
15:48:48 <beaky> is there a way to get ghc to clean up after itself?
15:49:17 <borkdude> merijn tnx
15:50:05 <hpaste> “Ertugrul Söylemez” annotated “Ints with a certain bit size” with “Bug fixed, withMask added” at http://hpaste.org/78507#a78509
15:50:21 <mm_freak> startling: sorry, i had a bug there (with negative numbers)…  use the new version
15:50:31 <mm_freak> it now handles negative numbers properly
15:50:49 <startling> mm_freak: k, thanks
15:50:52 <mm_freak> with one exception:  i didn't bother to implement abs and signum with full semantics
15:51:22 <mm_freak> abs (-5) = -5
15:51:27 <quchen> beaky: You mean something like a --clean instead of --make? Not that I know of.
15:51:32 <beaky> ah :(
15:51:53 <beaky> maybe if I made my projects build with cabal
15:52:18 <quchen> You can use > find -name "*.o" -delete -o -name "*.hi" -delete
16:02:14 <niteria> why does Error need strMsg?
16:02:51 <niteria> I guess what I'm asking is at which point it needs to consturct my error type from str?
16:03:54 <elliott> niteria: for fail
16:03:55 <elliott> :t fail
16:03:56 <lambdabot> Monad m => String -> m a
16:03:57 <elliott> (this sucks)
16:04:43 <niteria> suppose, my error type is (SourcePos, String) and SourcePos is opaque
16:04:56 <niteria> how am I supposed to deal with this?
16:05:15 <c_wraith> have a second constructor that just takes a string
16:05:23 <niteria> strMsg a = (undefined, a) :D
16:05:24 <c_wraith> it will only ever be called if fail is used
16:05:37 <c_wraith> and if you never use fail, it will never apply
16:06:02 <elliott> niteria: you could not use Error
16:06:54 <c_wraith> That's a better solution
16:08:18 <niteria> I want to have some kind of ErrorMonad
16:08:47 <elliott> Either
16:08:56 <elliott> there's a decent EitherT somewhere. i think in an edwardk package :)
16:09:05 <edwardk> @hackage either
16:09:06 <lambdabot> http://hackage.haskell.org/package/either
16:11:33 <niteria> how do I catch Left and modify it?
16:11:38 <Peaker> I wish I could add a "hiding" for my "EitherT"
16:12:10 <niteria> pattern match?
16:12:49 <Eduard_Munteanu> niteria: that, or using 'either'
16:12:49 <Peaker> niteria, do you want to apply a function to a Left value?
16:12:52 <Eduard_Munteanu> :t either
16:12:54 <lambdabot> (a -> c) -> (b -> c) -> Either a b -> c
16:13:03 <Peaker> or a left lens, but if you don't know about lens yet it might be "overkill"
16:13:03 <axkrts> Can someone help me reason about this type error? http://hpaste.org/78510
16:13:26 <niteria> yes, map over left
16:13:37 <axkrts> I don't think I am getting the bytestring correctly
16:14:31 <Peaker> > map   ((*2) `either` id) $ [Left 5, Right 'h']
16:14:32 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
16:14:33 <lambdabot>    arising from a use of `GHC....
16:14:47 <Peaker> > map   (Left . (*2) `either` Right) $ [Left 5, Right 'h']
16:14:49 <lambdabot>   Precedence parsing error
16:14:49 <lambdabot>      cannot mix `L..' [infixr 9] and `Data.Either....
16:14:55 <Peaker> > map   ((Left . (*2)) `either` Right) $ [Left 5, Right 'h']
16:14:57 <johnw`> axkrts: which line in that pastie is the error for?
16:14:57 <lambdabot>   [Left 10,Right 'h']
16:15:08 <axkrts> line 14
16:15:15 <Peaker> @let onLeft f = either (Left . f) Right
16:15:17 <lambdabot>  Defined.
16:15:21 <axkrts> johnw`: the do-block on line 14
16:15:23 <niteria> hyh, either is -> c
16:15:25 <Peaker> > onLeft (*3) $ Left 5
16:15:27 <lambdabot>   Left 15
16:15:29 <Peaker> niteria, ^^
16:15:38 <Peaker> axkrts, you need to add the type of getByteString
16:15:45 <shachaf> > over _left (*3) $ Left 5
16:15:46 <lambdabot>   Left 15
16:16:17 <niteria> does anyone have a decent size example with good error handling?
16:16:18 <johnw`> you need return ArgError
16:16:18 <Peaker> shachaf, is the leading underscore a common convention? I know it is for _1, _2, etc. but what else besides _left/_right?
16:16:27 <johnw`> not just ArgError by itself
16:16:27 <axkrts> Peaker: what do you mean? I just want to read a bytestring and convert it to String
16:16:46 <Peaker> axkrts, read lines 22-24
16:16:50 <johnw`> the result type of each branch in the case must match
16:17:00 <johnw`> axkrts: change ArgError on line 17 to "return ArgError"
16:17:06 <axkrts> johnw`: yeah I suspect that is the problem, but I don't know how to read the bytestring and then return a PermError
16:17:24 * hackagebot hoodle-render 0.1.0 - Hoodle file renderer  http://hackage.haskell.org/package/hoodle-render-0.1.0 (IanWooKim)
16:17:26 * hackagebot hoodle-core 0.7.0.0 - Core library for hoodle  http://hackage.haskell.org/package/hoodle-core-0.7.0.0 (IanWooKim)
16:17:31 <johnw`> axkrts: or, return $ ArgError, actually
16:17:34 <niteria> looks like lens are a solution for everything
16:17:40 <Peaker> johnw`, that's not the problem mentioned by ghc, however?
16:17:49 <johnw`> Peaker: the type error in this case is misleading
16:17:51 <Peaker> axkrts, where is getByteString from?
16:18:04 <johnw`> the problem is that the type inference has gotten things wrong, because it sees mismatched types because returned from the case
16:18:06 <axkrts> johnw`: return $ ArgError doesn't do it
16:18:20 <johnw`> axkrts: does the error change?
16:18:21 <Peaker> johnw`, it's explicitly saying "Actual type: m0 t0 -> (t0 -> m0 b0) -> m0 b0" for "getByteString len"
16:18:35 <edwardk> Peaker: you want to hide the EitherT package? message Ross Paterson. He can do it
16:18:37 <Eduard_Munteanu> return $ MsgError $ case errTy of [...] return [...]
16:18:40 <axkrts> johnw`: no, it is the same error
16:18:44 <Peaker> and I doubt he meant to use the (m0 t0 -> (t0 -> m0 b0) -> m0 b0) monad
16:18:44 <johnw`> oh
16:18:48 <johnw`> let bs = getByteString len
16:18:53 <Eduard_Munteanu> Are you sure you want the nested returns?
16:19:02 <johnw`> *and* he has a problem with return $ ArgError :)
16:19:10 <Peaker> axkrts, to me it seems you're not applying getByteString to enough args?
16:19:16 <Peaker> edwardk, Seems a bit kludgy to do so by email :)
16:19:22 <johnw`> in fact, you don't need to be using do-notation there at all axkrts
16:19:46 <johnw`> just: 0 -> PermError (toEnum code :: PermErrorCode) (C.unpack (getByteString len)); 1 -> ArgError (toEnum code :: ArgErrorCode)
16:19:51 * edwardk starts singing "I get bytes with a little help from my lens."
16:20:47 <johnw`> @remember edwardk edwardk starts singing "I get bytes with a little help from my lens."
16:20:47 <lambdabot> Done.
16:21:13 <axkrts> johnw`: I tried that before, but the error is now "Couldn't match expected type 'C.ByteString' with actual type 'Get C.ByteString'
16:21:27 <johnw`> what is Get?
16:21:50 <axkrts> johnw`: so maybe there is a way to do "m a -> a"
16:21:57 <johnw> axkrts: no
16:22:13 <johnw> what is Get?
16:22:21 <axkrts> johnw: http://hackage.haskell.org/packages/archive/cereal/0.3.0.0/doc/html/Data-Serialize-Get.html
16:22:29 <edwardk> @wordnet get
16:22:29 <lambdabot> Unknown command, try @list
16:22:32 <johnw> ahh
16:22:32 <edwardk> @wn get
16:22:34 <lambdabot> *** "get" wn "WordNet (r) 3.0 (2006)"
16:22:34 <lambdabot> get
16:22:34 <lambdabot>     n 1: a return on a shot that seemed impossible to reach and
16:22:34 <lambdabot>          would normally have resulted in a point for the opponent
16:22:34 <lambdabot>     v 1: come into the possession of something concrete or abstract;
16:22:35 <lambdabot> [123 @more lines]
16:22:52 <johnw> i didn't realize that getByteString was a function in a monad
16:23:01 <johnw> edwardk: cute
16:23:04 <Peaker> The error axkrts is getting is weird. it's claiming "Data.Binary.Get.getByteString len" has a very very weird "Actual type"
16:23:19 <Eduard_Munteanu> Peaker: because of the outer return
16:23:27 <Peaker> Eduard_Munteanu, line 16?
16:23:40 <Eduard_Munteanu> Peaker: there's one on line 13
16:23:51 <johnw> axkrts: can you pastie me what it showed when you had only changed ArgError to "return $ ArgError"?
16:24:03 <axkrts> johnw: the error didn't change
16:24:04 <Peaker> Eduard_Munteanu, but ghc is specifically mentioning that statement in the "do" (line 24 in paste)
16:24:18 <Peaker> Eduard_Munteanu, this seems to me like a GHC bug
16:24:24 <Peaker> (bad error message)
16:24:28 <johnw> Peaker: the error means that an Error is being returned in a context where a monadic value must be returned
16:24:39 <johnw> hence, Error != m0 b0
16:24:50 <johnw> and I'm guessing the m0 here is "Get"
16:24:51 <Peaker> johnw, I understand, but lines 23-24 taken together make no sense at all
16:25:07 <johnw> Peaker: don't always trust those lines
16:25:16 <Peaker> evidently :)
16:25:26 <Peaker> it's a bug, though, not just an unfortunate case of accuracy being misleading
16:25:39 <Eduard_Munteanu> I guess it complains about the desugaring of do-notation to >>= ?
16:25:41 <johnw> the point when a type inference errors is detected is often not where the real error happened
16:26:04 <Peaker> johnw, that's fine too -- but the error says some line has some type, where it doesn't have anything remotely similar to that type
16:26:05 <Eduard_Munteanu> That line is merely   getByteString len >>= ...
16:26:09 <johnw> oh
16:26:12 <johnw> duh
16:26:15 <johnw> i'm being stupid
16:26:22 <johnw> you can't use that case as an argument to MsgError!
16:26:27 <johnw> MsgError wants an error
16:26:35 <johnw> not an error in a Get
16:26:54 <johnw> axkrts: try changing "return $ MsgError $" to "MsgError <$>"
16:26:55 <Eduard_Munteanu> I guess we can agree the error isn't quite helpful, at least.
16:27:17 <Peaker> Eduard_Munteanu, We can all agree on that but I think it's important to also make sure errors don't spout false information :)
16:27:25 <johnw> *and* change "ArgError" to "return $ ArgError"
16:27:29 <Peaker> Eduard_Munteanu, that error made me believe "getByteString" must have a very funny type
16:27:38 <johnw> Peaker: the error is entirely accurate
16:27:50 <axkrts> what package is <$> in?
16:27:55 <c_wraith> base
16:28:04 <johnw> it's saying that the call to getByteString has forced it to infer that the type of the case is m0 b0, but the case is being used in a context which requires an Error
16:28:10 <johnw> axkrts: Control.Applicative
16:28:13 <Peaker> johnw, It claims the type of "getByteString len" has *Actual* type: "m0 t0 -> (t0 -> m0 b0) -> m0 b0"
16:28:24 <johnw> Peaker: and it does
16:28:33 <Eduard_Munteanu> Not really... In a stmt of a 'do' block: bs <- getByteString len
16:28:35 <Peaker> johnw, "Actual Type" means inside-outwards
16:28:48 <Peaker> johnw, the "Expected Type" may be that, not the Actual type
16:28:50 <yitz> axkrts: Data.Functor, re-exported also in Control.Applicative
16:29:03 <yitz> (the module, not the package)
16:29:07 <Eduard_Munteanu> It claims that about the whole statement, I'd say.
16:29:09 <Peaker> johnw, getByteString len   has *actual* type   Get ByteString,  or if you're early in the inference:  m0 a0
16:29:29 <johnw> Peaker: it's not complaining about just the getByteString
16:29:31 <yitz> @hoogle <$>
16:29:32 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
16:29:32 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
16:29:38 <Eduard_Munteanu> Which kinda makes sense...
16:29:41 <Eduard_Munteanu> :t (>>=)
16:29:41 <Peaker> Eduard_Munteanu, what's the "whole statement"? It's either just the "getByteString len" or it's the whole do block
16:29:43 <lambdabot> Monad m => m a -> (a -> m b) -> m b
16:29:52 <johnw> but the desugared getByteString len >>= \bs ->
16:30:06 <johnw> which, early in the inference, has the type stated
16:30:11 <Eduard_Munteanu> What johnw says, that's my guess too.
16:30:17 <kristof> May I ask what book you all used first?
16:30:19 <Eduard_Munteanu> It complains about the type of (>>=) there.
16:30:23 <kristof> Was it Learn You a Haskell, or Real World Haskell?
16:30:26 <Peaker> johnw, it desugars to:     getByteString len >>= (return $ ...)   -- what subexpression of this is it complaining about?
16:30:40 <johnw> kristof: LYAH
16:30:41 <Eduard_Munteanu> Peaker: ^
16:30:55 <Peaker> Eduard_Munteanu, well, complaining about the (>>=) and saying it is about a *statement* is as bad as a bug, imo
16:30:57 <axkrts> johnw: I don't think I want to use applicative and keep the thing in the Get monad... the function is suppose to return a MsgError not Get MsgError
16:31:03 <Peaker> Eduard_Munteanu, (>>=) isn't the statement
16:31:12 <johnw> axkrts: <$> isn't in the Appliciave type class
16:31:19 <johnw> axkrts: it's just a shorthand for fmap, which only requires Functor
16:31:32 <Peaker> Haskell's Prelude needs some modernization...
16:31:33 <johnw> axkrts: and you can bet that Get is a Functor :)
16:31:38 <Eduard_Munteanu> Peaker: the error occurs somewhere in the statement, it doesn't give you anything more specific, I think
16:31:45 <axkrts> johnw: adding <$> helps, but then I run into the type error of "can't match expected type 'Msg' with actual type 'Get Msg' ... but I need that function to return a 'Msg'
16:31:56 <johnw> axkrts: show me the new code please?
16:31:56 <Peaker> Eduard_Munteanu, I wouldn't even say that the (>>=) that connects that statement to the next statements is part of that statement
16:32:26 <Peaker> axkrts, what GHC version are you running?
16:32:26 <bzm3r> You know how LYAHFGG has pictures of an interpreter with syntax colouring? How can I set up my interpreter to be the same way?
16:32:37 <Peaker> axkrts, can you paste the whole thing? I want to try it on a newer GHC and see if they improved the error message
16:32:48 <Eduard_Munteanu> kristof: LYAH is usually recommended. Though in my case I can't say I've used any single book in particular, I googled stuff, read some parts of RWH, haskellwiki articles etc.
16:33:22 <johnw> bzm3r: that's a great question
16:33:23 <kristof> Eduard_Munteanu: Do you think you learned well that way? I like structured learning, and I very much enjoy books.
16:33:25 <Peaker> @quote gentle
16:33:25 <lambdabot> PenguinOfDoom says: Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
16:33:26 <axkrts> Peaker: 7.4.1
16:33:30 <axkrts> http://hpaste.org/78511
16:33:43 <Eduard_Munteanu> @quote gentle.intro
16:33:44 <lambdabot> Brend says: Whoever chose the title "A Gentle Introduction to Haskell" is obviously accustomed to wrestling bears in piranha pits or something.
16:33:49 <johnw> axkrts: drop the "return $"
16:33:54 <Eduard_Munteanu> I used Gentle too.
16:33:54 <johnw> on line 17
16:34:03 <shachaf> I move to @forget PenguinOfDoom's quote.
16:34:14 <Eduard_Munteanu> Which is great as a quick summary of Haskell's stuff.
16:34:39 <johnw> wouldn't a bear in a piranha pit just be a bear skeleton?
16:34:39 <Eduard_Munteanu> shachaf: why?
16:34:46 <kristof> Eduard_Munteanu: Hrmmm. I'm learning quite a bit from LYAH, and it's actually coming along quite well. Perhaps it's the fact that I'm very proficient at higher level math already.
16:34:48 <axkrts> johnw: oh duh, that lifts it into the get monad right?
16:35:00 <johnw> axkrts: yep
16:35:04 <johnw> but it's already in that monad
16:35:20 <shachaf> Eduard_Munteanu: It's not particularly good and it's sexist.
16:35:23 <bzm3r> johnw: great question :p, so what's the answer then?
16:35:37 <johnw> bzm3r: i don't have one!  if you find out, let me know, mmk?
16:35:42 <Eduard_Munteanu> kristof: maybe, customers like also bought: category theory, ##categorytheory   :D
16:35:43 <Peaker> GHC 7.6.1 still errorizes about (>>=) when it says "statement", bah
16:35:48 <Eduard_Munteanu> *like you
16:35:51 <bzm3r> johnw: hahaha, alright, sure will
16:35:51 * Peaker opens a bug report
16:35:56 <axkrts> johnw: that works!
16:35:59 <johnw> axkrts: :{
16:36:00 <bzm3r> doesn't BONUS hang out here?
16:36:03 <johnw> axkrts: :)
16:36:09 <c_wraith> been a while since BONUS has been here.
16:36:14 <c_wraith> preflex: seen BONUS
16:36:16 <axkrts> johnw: so why is it correct to use <$> fmap here?
16:36:17 <Eduard_Munteanu> bzm3r: used to, haven't seen him in a while.
16:36:18 <johnw> axkrts: now, do you understand why it works, and why it didn't before?
16:36:24 <Eduard_Munteanu> Like, over a year last time I queried preflex.
16:36:24 <c_wraith> is preflex dead now too?
16:36:27 <bzm3r> ahh
16:36:42 <Eduard_Munteanu> At least mauke is back and no longer a maukd.
16:36:54 <elliott> maukd forked and spawned a mauke worker
16:36:58 <johnw> axkrts: because you have a Get (Error), and you want it to become a Get (Msg Error), so MsgError <$> applies the value constructor MsgError to the Error value "inside" the Get
16:37:02 <johnw> that's just what fmap does
16:37:04 <Eduard_Munteanu> (a *d*epressed mauke?)
16:37:10 <axkrts> johnw: I understand that I needed to return a Error, and it was still stuck in Get monad
16:37:42 <johnw> axkrts: however, if I describe that as being "contained" in the monad, shachaf is likely to kickban me
16:37:48 <xenocons> does the haskell code highlighting on this wiki look a bit strange? http://en.wikipedia.org/wiki/Monad_(functional_programming)
16:38:03 <johnw> yes
16:38:07 <xenocons> looks like its being over zealous withthinking "'" is a string
16:38:11 <johnw> the strings have a solid green background
16:38:27 <johnw> that highlighter is against constants
16:38:41 <xenocons> and non strings like \x' -> y >>+ (\y' ..
16:38:46 <dinox> Hmm, does this function exist in any common package?
16:38:48 <xenocons> >>= sorry
16:38:54 <dinox> zipTuple (a,b) = zip a b
16:39:11 <johnw> dinox: zipWith (,)
16:39:14 <Eduard_Munteanu> shachaf: uh, dunno, that sort of antisexism is too dogmatic. I should be labeled as antidogmatic, I guess.
16:39:18 <johnw> is that what you mean?
16:39:36 <johnw> oh, i see
16:39:41 <johnw> uncurry zip
16:40:17 <johnw> zipTuple = uncurry zip
16:40:34 <xenocons> perhaps a better question: why is ' a string constant in the wiki's haskell syntax
16:40:41 <dinox> aah, there we have it!
16:40:53 <dinox> thanks johnw
16:41:22 <elliott> @forget PenguinOfDoom Being enlightened gentlemen, we split all programming languages into two groups, sucks and doesn't-suck and put all of them into the first group.
16:41:23 <lambdabot> Done.
16:42:14 <xenocons> whats the next book after learn you a haskell?
16:42:20 <Eduard_Munteanu> It probably made it into a HWN edition anyway, I guess. :)
16:42:25 <johnw> xenocons: real world haskell
16:42:35 <xenocons> johnw: im on that page right now
16:42:48 <xenocons> looks good
16:42:50 <Eduard_Munteanu> xenocons: and googling various topics of interest, I'd say
16:43:00 <johnw> then comes ideal world haskell, unreal world haskell, and then all worlds haskell
16:43:14 <sipa> surreal world haskell maybe?
16:43:21 <xenocons> im still trying to work out where to put haskell
16:43:21 <Eduard_Munteanu> Now make sure you write those. :P
16:43:22 <johnw> ah, that's what my brain wanted, thanks sipa
16:43:26 <Canar> fifth-world haskell
16:43:34 <Canar> sounds like a good idea for a new subreddit
16:43:35 <johnw> xenocons: put haskell on the shelf, next to the peanut butter
16:43:54 <xenocons> are you implying haskell belongs in the set of carcenogens?
16:43:56 <johnw> 1st world haskell, where we complain about not having fully dependent types
16:44:06 <xenocons> carcinogens apparently
16:44:06 <Eduard_Munteanu> @protontorpedo
16:44:07 <lambdabot> so haskells better than smalltalk and clsip?
16:44:29 <sipa> clsip... that's a command-line SIP implementation?
16:44:36 <johnw> apparently so
16:44:38 <axkrts> johnw: fmap is (a -> b) -> f a -> f b ... so why do you need to fmap a constructor over what is returned in the case-expression?  Why can't it be written as (MsgError case ... of ...) ?
16:44:57 <Eduard_Munteanu> sipa: probably a common pronounciation of CLISP for people afflicted by lithps. :P
16:44:59 <johnw> written by Bruno Hailbe, and licensed under the GLP
16:45:26 <johnw> axkrts: because MsgError doesn't take a Get Error, it takes an Err
16:45:34 <johnw> you need to "get inside" that Get
16:45:40 <johnw> and fmap is the go-to get insider
16:46:10 <FireFly|> fmap: how you do inside jobs in Haskell?
16:46:19 <johnw> by masquerading as a C# guy
16:46:32 <johnw> poor mgsloan!
16:46:33 <Eduard_Munteanu> > fmap Just (Right 5)
16:46:34 <lambdabot>   Right (Just 5)
16:46:58 <axkrts> ohhh.. i think i see
16:47:14 <axkrts> but what about liftM ?
16:47:19 <Peaker> how do you format code in a trac ticket text?
16:47:23 <johnw> axkrts: liftM = fmap, for Monads
16:47:24 <Eduard_Munteanu> > liftM Just (Right 5)
16:47:26 <lambdabot>   Right (Just 5)
16:47:54 <johnw> i happen to like fmap, since I believe it should be a superclass of Monad, and this is how I vent
16:48:10 <johnw> well, Applicative should be, really
16:48:11 <Eduard_Munteanu> > Just <$> Right 5
16:48:13 <lambdabot>   Right (Just 5)
16:48:18 <xenocons> hrm, realworld haskell is quite eloquently written
16:48:45 <xenocons> mistook it for a wall of text initially
16:48:46 <bzm3r> really? I gave up on it because of how wishy washy it was with definitions
16:49:10 <xenocons> i dont mind wishy washy aslong as it is interesting
16:49:19 <xenocons> (im only a few paragraphs in and feel the need to comment ;p)
16:49:27 <c_wraith> the thing about real world haskell is that it assumes you know the basics of he language, really
16:49:39 <Peaker> johnw, Eduard_Munteanu : http://hackage.haskell.org/trac/ghc/ticket/7461
16:49:56 <xenocons> i think i understand some of the fundamental concepts of ML languages, so i should be OK
16:50:14 <bzm3r> xenocons: A side effect introduces a dependency between the global state of the system and the behaviour of a function. For example, let's step away from Haskell for a moment and think about an imperative programming language. Consider a function that reads and returns the value of a global variable. If some other code can modify that global variable, then the result of a particular application of our function depends on the current 
16:50:17 <xenocons> at least, a superficial understanding hehe
16:50:26 <bzm3r> eh, it didn't paste the whole thing out
16:50:39 <bzm3r> but yeah, the whole side-effect, pure, vs. impure, etc. discussion is where I quit reading it
16:50:47 <xenocons> i dont know how much need there is to explain side effects
16:50:48 * Peaker opens lots of GHC bug reports lately
16:50:49 <bzm3r> it just was skipping over too many details for me, a total newbie
16:50:49 <Eduard_Munteanu> Peaker: yeah, I agree that needed reporting. Maybe "false" is a bit too strong though.
16:50:58 <xenocons> i mean, most people know what side effects are
16:51:09 <xenocons> (especially imperative programmers)
16:51:16 <xenocons> i dont really know what im arguing here
16:51:32 <Peaker> Eduard_Munteanu, well, it is literally saying "getLine", and there's no "x <-" thing in there to justify various hand-waving :)
16:51:33 <Eduard_Munteanu> Heh, I sometimes go on bug-reporting fits wrt Agda too. :D
16:51:43 <Eduard_Munteanu> Oh, hm.
16:52:23 <Peaker> when I read:  Actual Type: <foo>            in:  <subexpr>         I think it is trying to say:  <subexpr> has-type <foo>
16:53:09 <Eduard_Munteanu> I'm not sure if they actually intended it though, someone could argue they chose not to desugar 'do notation' and instead point out the "statement" rather than an "expression".
16:53:42 <Eduard_Munteanu> But yeah, I suppose that needs to be clarified.
16:55:10 <xenocons> whats haskells socket support like?
16:55:19 <Peaker> I think they're making an effort to avoid desugaring in the error but then they do something even worse than errorizing about desugared: They give an error about the (>>=) without mentioning it
16:55:31 <Peaker> Eduard_Munteanu, at least after all of this, I'll be able to read errors about do stmts in the future :)
16:55:38 <Eduard_Munteanu> Peaker: actually it looks like (>>) rather than (>>=) there
16:55:39 <Peaker> (it's the first time I recognize this is what these errors mean)
16:55:41 <xenocons> well, stupid question, what is the extent of the expressiveness and power of packages that deal with networking
16:55:51 <Peaker> Eduard_Munteanu, yeah
16:56:44 <Peaker> xenocons, I found the lower-level socket API to be a PITA when I tried using it. But maybe the high-level one is nice
16:57:05 <acowley> xenocons: That's fairly hard to answer. You can use sockets, and you have Haskell. It's as wonderful as you want it to be.
16:57:13 <Peaker> I like Python's socket API.. nice to have defaults:   s = socket.socket() ; c = s.connect(("google.com", 80)   <-- done
16:57:17 <xenocons> hmm
16:57:36 <xenocons> i find the interface between network and code to be one of the most painful abstractions
16:57:38 <acowley> python doesn't even require balanced parentheses
16:57:39 <xenocons> in any language
16:57:42 <Peaker> s = socket.socket() ; s.bind(("", 8080)) ; s.listen(5) ; addr, client = s.accept()
16:57:45 <Peaker> acowley, heh
16:58:01 <acowley> <python> It's cool, bro, I know what you meant....
16:58:23 <xenocons> IO constantly causes ugly code for me, and it seems my code uses a lot of IO
16:58:34 <xenocons> i end up writing my own abstractions
16:58:48 <xenocons> stack overflow points to http://hackage.haskell.org/package/network
16:58:56 <Peaker> xenocons, http://hackage.haskell.org/packages/archive/network/2.4.0.1/doc/html/Network.html <-- this API looks nice
16:59:01 <Eduard_Munteanu> Peaker: I think it should at least mention two statements to make things a bit clearer
16:59:23 * xenocons looks
16:59:41 <xenocons> okay neat, hmmm
16:59:56 <xenocons> only thing is recvFrom seems to return a string?
17:00:07 <Peaker> listener <- listenOn 1234 ; (client, addr, port) <- accept listener
17:00:29 <Peaker> http://hackage.haskell.org/packages/archive/network/2.4.0.1/doc/html/Network-Socket-ByteString.html
17:01:01 <xenocons> yes this looks better
17:01:02 <axkrts> okay, this one is a bit more difficult to reason about.... http://hpaste.org/78514
17:01:03 <Peaker> xenocons, you can use the high-level API to make connected sockets painlessly
17:01:11 <Peaker> xenocons, then use the lower-level bytestring API to send/recv on them
17:01:23 <xenocons> Peaker: right, hmm
17:01:30 <johnw> Peaker: I agree with you that reporting errors relating to implicit sugar constructs can be confusing, and perhaps is a bug
17:01:37 <Peaker> Eduard_Munteanu, SPJ said something like "We understand errors are difficult to read. We're not sure how to improve them". I think this is an easy case
17:02:00 <johnw> i'm just not sure how you improve the error in this case
17:02:07 <johnw> show the desugared code?  that would not be good
17:02:12 <xenocons> wow ok i see that example at the bottom, that is very succinct
17:02:13 <Eduard_Munteanu> I guess so.
17:02:27 <Peaker> johnw, The error is explicitly mentioning the sugar here -- so it's sane to expect it to be "above" the sugar, rather than "below". Also, even "below" the sugar, it is silly to name the stmt but actually talk about the (>>=)/(>>)
17:02:51 <Peaker> johnw, I don't think the sugar is the problem here since it is explicitly handled by the error - the problem is simply that the handling is wrong
17:03:15 <johnw> Peaker: ok, i see what you mean
17:03:22 <johnw> you want the error to be sugary too :)
17:03:33 <johnw> sweet sweet errors!
17:03:37 <Eduard_Munteanu> On a related note, I sometimes wish GHC didn't expand type synonyms in errors.
17:03:46 <xenocons> now, i believe simon marlow was working on 'visual haskell' heh, wonder if it exists now
17:04:09 <geekosaur> IIRC it proved impossible to keep it working with newer VS versions?
17:04:27 <geekosaur> (or at least Too Much Work)
17:04:28 <xenocons> ah :(
17:04:29 <johnw> Eduard_Munteanu: agreed
17:04:44 <johnw> Eduard_Munteanu: although sometimes, the type synonym might hide the cause of the error
17:04:56 <xenocons> so what do people use for a lightweight IDE on windows (preferably with intellisense or something)
17:04:57 <johnw> Eduard_Munteanu: there should be an annotation that says "don't expand", like for String
17:05:12 <Eduard_Munteanu> I'm not sure how easy it is to accomplish though. I can see it becoming really difficult in something like Agda, but not sure about Haskell.
17:05:15 <johnw> xenocons: what, for Haskell?
17:05:26 <Peaker> xenocons, there's also this: http://hackage.haskell.org/packages/archive/network-conduit/0.6.1.1/doc/html/Data-Conduit-Network.html
17:05:57 <Eduard_Munteanu> (since the typechecker would essentially have to fold things back after normalizing types)
17:06:23 <Peaker> Eduard_Munteanu, it could be nice to show each type twice, with alignments -- all synonyms collapsed/expanded
17:06:55 <Peaker> Eduard_Munteanu, Ideally errors would not be restricted to being rendered in text form so we could just interactively toy around with that :)
17:07:03 <xenocons> johnw: yeh
17:07:09 <xenocons> Peaker: ive bookmarked both
17:07:10 <johnw> have you seen Eclipse FP?
17:07:21 <Eduard_Munteanu> Peaker: yes, but only if you can decide e.g. [Char] actually comes from a use of String, otherwise it'd clutter things a lot.
17:07:44 <xenocons> ah, you are going to hate on me here, im sure, i refuse to install java
17:07:51 <xenocons> so i think eclipse will be no-go
17:08:01 <johnw> you didn't mention restriction ;)
17:08:10 <Eduard_Munteanu> Also, you could have multiple equivalent type synonyms.
17:08:11 <xenocons> I can probably get away with notepad++ or something though
17:08:28 <xenocons> johnw: my bad
17:08:36 <johnw> use Emacs
17:08:37 <Eduard_Munteanu> xenocons: also vim, emacs etc.
17:08:55 * xenocons i think i have an idea for my first project, translating some old code
17:09:11 <xenocons> Eduard_Munteanu: vim and emacs are pretty bad on windows from my experience :<
17:09:49 <Eduard_Munteanu> xenocons: if you want an actual IDE, try Leksah
17:09:55 <Peaker> Eduard_Munteanu, equivalent synonyms are OK since you don't compact them, only expand them
17:09:56 <Eduard_Munteanu> @hackage leksah
17:09:57 <lambdabot> http://hackage.haskell.org/package/leksah
17:10:01 <xenocons> leksah eh
17:10:24 <xenocons> hmm
17:10:26 <xenocons> http://www.leksah.org/
17:10:32 <xenocons> there icon is lambda with an erection
17:10:42 <xenocons> looks promising
17:11:34 <Eduard_Munteanu> Peaker: assuming you can avoid compacting, I'm not really sure. (the typechecker needs to unfold definitions to check types, so you probably need to track things and make good guesses / make sure you don't compact coincidences)
17:11:48 <Eduard_Munteanu>  Hah.
17:12:15 <Eduard_Munteanu> Looks more like χ though.
17:12:40 <xenocons> that unicode doesn't come through on my irssi
17:13:26 <Eduard_Munteanu> xenocons: the Greek lowercase letter 'chi'
17:13:38 <xenocons> ah right
17:13:51 <xenocons>  \chi according to detexify
17:13:59 <xenocons> there is also a \textcrlambda
17:14:16 <Eduard_Munteanu> Yeah, I use \chi in SCIM to type it.
17:14:31 <Eduard_Munteanu> Also, you could enable utf8 in irssi, assuming you have reasonable fonts.
17:14:50 <xenocons> (i ssh into an irssi box using putty)
17:14:55 <xenocons> haven't tried to enable utf8 before
17:15:23 <Eduard_Munteanu> /set term_charset utf-8
17:15:40 <xenocons> done
17:15:45 <xenocons> try again!
17:15:56 <Eduard_Munteanu> χ ?
17:16:00 <xenocons> :(
17:16:03 <xenocons> no-go
17:16:05 <lpvb> looks like JHC stalled since 2010?
17:16:21 <Eduard_Munteanu> xenocons: does it look like a box?
17:16:34 <xenocons> it looks like an I with a moustache at the top
17:16:54 <Eduard_Munteanu> Then I guess it's your terminal.
17:17:05 <xenocons> quite possibly
17:18:22 <Eduard_Munteanu> @google putty unicode
17:18:24 <lambdabot> http://anti.teamidiot.de/nei/2007/02/irssi_putty_screen_unicode_utf/
17:18:24 <lambdabot> Title: Irssi, PuTTY, Screen & Unicode UTF-8 (anti)
17:19:04 <xenocons> well that was easy to do
17:19:06 <xenocons> try again good sir
17:20:42 <Eduard_Munteanu> xenocons: χ again?
17:20:58 <Eduard_Munteanu> α β γ
17:20:59 <xenocons> works now
17:21:05 <Eduard_Munteanu> Neat.
17:21:08 <xenocons> ooh ty
17:21:13 <xenocons> alpha beta delta?
17:21:19 <Eduard_Munteanu> s/delta/gamma/
17:21:23 <xenocons> ahhh
17:21:31 <xenocons> untyped lambda calc i guess?
17:21:46 <Eduard_Munteanu> Nah, random Greek stuff that came to mind. :)
17:21:50 <xenocons> ah heh
17:22:05 <Eduard_Munteanu> Perhaps more like nuclear physics. :P
17:22:38 <xenocons> sounds fancy
17:23:09 <lpvb> anyone using archlinux with haskell?
17:24:08 <sw2wolf> It is not special to run haskell on ArchLinx
17:24:54 <mapreduce> :t show . read :: String -> String
17:24:55 <sw2wolf> Haskell can run on WIndows, BSD*, linux* ...
17:24:55 <lambdabot> String -> String
17:25:09 <mapreduce> > show . read $ "foo"
17:25:10 <lambdabot>   "*Exception: Prelude.read: no parse
17:25:22 <kristof> lpvb: What's your question?
17:25:52 <lpvb> kristof: I wanted to know how I could downgrade to 7.4.2 and use the standard haskell platform
17:26:00 <lpvb> instead of the repo's 7.6.1
17:26:35 <kristof> lpvb: Meet me in #archlinux
17:26:58 <lpvb> kristof: I'm already there
17:30:48 <mapreduce> > ((show . (read :: String -> Float)) :: String -> String) "3"
17:30:50 <lambdabot>   "3.0"
17:31:30 <mapreduce> Why does this work when my previous one didn't, show . read $ "foo" ?
17:31:52 <Eduard_Munteanu> > show . read $ "\"foo\""
17:31:54 <lambdabot>   "*Exception: Prelude.read: no parse
17:32:07 <Eduard_Munteanu> :t show . read
17:32:09 <lambdabot> String -> String
17:32:13 <Eduard_Munteanu> Grr.
17:32:34 <Eduard_Munteanu> mapreduce: it defaults to weird types, also "foo" obviously doesn't parse to anything sensible
17:32:53 <siracusa> > show . read $ "()"
17:32:55 <lambdabot>   "()"
17:33:18 <node> i get error 'do' block is empty :| here is the code http://hpaste.org/78517
17:33:55 <Eduard_Munteanu> > show . (read :: String -> String) $ "\"foo\""
17:33:57 <lambdabot>   "\"foo\""
17:34:02 <Eduard_Munteanu> > show . (read :: String -> String) $ "foo"
17:34:04 <lambdabot>   "\"*Exception: Prelude.read: no parse
17:34:42 <mapreduce> So what type does read default to in there?
17:34:43 <Eduard_Munteanu> In vanilla Haskell (show . read) shouldn't work.
17:34:56 <mapreduce> shouldn't compile?
17:34:58 <Eduard_Munteanu> mapreduce: read :: String -> ()
17:35:10 <Eduard_Munteanu> mapreduce: yes, it should complain about ambiguous types.
17:35:21 <Eduard_Munteanu> lambdabot uses extended defaulting rules
17:35:59 <Mortchek> That's odd, my GHC does (show . read) "()" fine
17:37:10 <ag90> Random question: what exactly is the "C a" part in "foo :: C a => ..." called?
17:37:19 <ski> ag90 : "context"
17:37:24 <mapreduce> Eduard_Munteanu: How does it get String -> (), is there such thing as a default instance?
17:37:31 <ag90> ski: Thanks
17:37:35 <ski> ag90 : sometimes "constraints"
17:38:01 <ag90> Ah great. That was exactly what I needed.
17:38:05 <Eduard_Munteanu> Mortchek: ghc or ghci
17:38:06 <Eduard_Munteanu> ?
17:38:10 <ski> often "class context/constraints", in cases (like above) in which the thing to the left of `=>' consists of classes applied to types
17:38:29 <Eduard_Munteanu> mapreduce: no, it defaults ambiguous types to ()
17:38:36 <Mortchek> Eduard_Munteanu, ah, I was unaware there were differences. I am indeed trying it in ghci.
17:38:40 <ski> (there are also other kind of constraints, like equality constraints `t ~ u' and implicit parameter constraints `?x :: t')
17:39:21 <lpvb> What OS do you guys use for haskell?
17:39:23 <Eduard_Munteanu> I get     Ambiguous type variable `b0' in the constraints:
17:39:23 <Eduard_Munteanu>       (Read b0) arising from a use of `read' at def.hs:3:15-18
17:39:24 <Eduard_Munteanu>       (Show b0) arising from a use of `show' at def.hs:3:8-11
17:39:27 <ag90> lpvb: Any
17:39:27 <axkrts> hpaste suggests code improvements, is that available as a cmdline tool?
17:39:36 <ag90> Though a *NIX OS is preferred by most
17:39:47 <ag90> [citation needed]
17:39:54 <Eduard_Munteanu> lpvb: Gentoo Linux here, Arch on my lappy (though haven't been using it lately)
17:39:56 <ag90> axkrts: hlint
17:40:02 <ag90> http://hackage.haskell.org/package/hlint
17:40:12 <axkrts> ag90: thanks
17:40:23 <johnw> axkrts: in my Emacs window, lines with hints are blue :)
17:40:39 <johnw> i've actually learned quite a few little tricks from hlint
17:41:01 <mapreduce> Eduard_Munteanu: I see, thank you.
17:41:06 <axkrts> johnw: I use emacs... is there a hlint hook for haskell-mode?
17:41:26 <johnw> axkrts: use ghc-mod in addition to haskell-mode
17:41:32 <johnw> then you'll get really good flymake behavior
17:41:42 <Eduard_Munteanu> > minBound
17:41:44 <lambdabot>   ()
17:43:23 <Eduard_Munteanu> Though Gentoo still has GHC 6.12.3 as the latest stable ebuild. :/
17:43:52 <Eduard_Munteanu> Otherwise, Haskell support seems rather ok.
17:44:20 <Eduard_Munteanu> (I unmasked 7.4.2)
17:47:07 <ag90> I have a design question. Suppose I have class MonadFoo m where foo :: Bar () -> m a. And suppose I want
17:47:11 <ag90> Oh crap.
17:47:15 <ag90> Pressed enter too eraly
17:47:16 <ag90> *early
17:48:23 <Mathnerd314> what IDE's do people use to develop GHC? or it an emacs/vim/notepad kind of project?
17:49:43 <Eduard_Munteanu> Mathnerd314: my guess is the latter, normally open projects don't impose any IDE on you.
17:50:09 <Mathnerd314> Eduard_Munteanu: well, I'm wondering what e.g. SPJ uses
17:50:23 <Eduard_Munteanu> Ah, not sure about that.
17:51:05 <Igloo> I think SPJ uses emacs
17:51:06 <mapreduce> interpretive dance
17:51:15 <startling> oil paint
17:51:32 <koala_man> oil paint dancing
17:51:42 <axkrts> is there any good example code for how to handle different versions of network protocols?
17:52:04 <johnw> axkrts: you mean TCP and UDP?
17:52:15 <johnw> or HTTP/1.0 and HTTP/1.1?
17:52:26 * hackagebot coroutine-object 0.1 - Object-oriented programming realization using coroutine  http://hackage.haskell.org/package/coroutine-object-0.1 (IanWooKim)
17:52:44 <axkrts> e.g. if implementing a protocol over TCP and 2 versions where the spec has changed added/removed messages from version to version... some common between the two...
17:52:52 <axkrts> but how to implement that elegantly..?
17:54:30 <axkrts> 3 files: common, vers1, vers2... but then name things the same in vers1 and vers2 so you can keep code simple?
17:55:07 <startling> axkrts, sometimes people use typeclasses
17:56:34 <axkrts> startling: polymorphism?
17:56:39 <startling> sure
17:57:12 <node> is there a way to add varaible to the end of the list ?
17:57:21 <node> *varaiable
17:57:26 <node> *variable
17:57:36 <startling> node, you don't add variables to anything
17:58:19 <node> startling: this is that i meant [1,2] ++ [3]
17:58:22 <node> *what
17:58:32 <Ralith> then it looks like you've answered your question
17:58:40 <startling> node: think of them as values, not variables.
17:58:41 <node> aye
17:59:02 <Mortchek> > let a = [3] in [1, 2] ++ a
17:59:04 <lambdabot>   [1,2,3]
17:59:30 <hpaste> ag90 pasted “Design Question” at http://hpaste.org/78520
17:59:45 <gertc> foldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m I thought monoids need concrete types so why is it not `m a` instead of m ?
18:00:01 <shachaf> gertc: instance Monoid [a]
18:00:06 <shachaf> Not instance Monoid []
18:01:02 <ag90> So, I have a class that depends on another monad. I want to create a wrapper that modifies the calls to functions in that class under its context. One way would be to use a new Monad. But that breaks any other classes that the wrapped monad uses. So, the transformers may have to be rewrapped.
18:01:21 <ag90> Clarification of what I mean: http://hpaste.org/78520
18:01:22 <gertc> yes so it needs to be foldMap :: (Monoid m, Foldable t) => (a -> m a) -> t a -> m a right?
18:01:48 <gertc> http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids at the bottom
18:02:15 <ag90> My question is, is this a pattern that occurs often? And if so, is there a way around it?
18:04:46 <bbloom> If I'm reading a pdf of a paper, what's the best way to look up the meaning of a symbol?
18:21:49 <MrWoohoo> anyone know know any good examples of writing monadic code that doesn't know what monad it's running in? i.e. how running the same code in different monads produces different effects
18:22:06 <shachaf> Everything in Control.Monad
18:22:08 <shachaf> @ty sequence
18:22:10 <lambdabot> Monad m => [m a] -> m [a]
18:22:34 <shachaf> > sequence [Just 1, Just 3]
18:22:35 <lambdabot>   Just [1,3]
18:22:47 <shachaf> > sequence [Just 1, Nothing, Just 4]
18:22:48 <lambdabot>   Nothing
18:22:53 <shachaf> > sequence ["hello","there"]
18:22:54 <lambdabot>   ["ht","hh","he","hr","he","et","eh","ee","er","ee","lt","lh","le","lr","le"...
18:23:25 <kenchow> bonus在不？
18:23:55 <kenchow> hello
18:24:26 <MrWoohoo> thanks. great examples. the beginnings of enlightenment
18:26:12 <rwbarton> kenchow, bonus the author of Learn You A Haskell?
18:26:27 <rwbarton> He hasn't been here for a long time
18:27:00 <kenchow> 不是，我就问问看，我没有发现这个 用户
18:27:13 <kenchow> 哦
18:27:15 <kenchow> 谢谢
18:27:26 * hackagebot hails 0.9.2.0 - Multi-app web platform framework  http://hackage.haskell.org/package/hails-0.9.2.0 (DeianStefan)
18:27:31 <shachaf> I agree.
18:27:32 <kenchow> 我看到他的页面上说，这里可以找到他。
18:28:06 <gertc> am i the only one seeing squares?
18:28:28 <startling> gertc: yes
18:28:30 <aristid> gertc: probably not the only one, but you probably miss fonts
18:28:40 <pikhq_> 僕、理解が無い。
18:29:04 <aristid> gertc: or some other reason prevents you from seeing those... chinese and in pikhq_'s case i believe japanese characters
18:29:17 <pikhq_> Yup, Japanese from me.
18:29:31 <pikhq_> Intentionally written in a way that a Chinese speaker has half a hope of getting it, but still.
18:29:38 <aristid> pikhq_: hah
18:29:41 <startling> hahah
18:29:41 <aristid> pikhq_: what did you say?
18:29:47 <pikhq_> "I don't understand."
18:29:52 <rwbarton> how useful :P
18:29:54 <aristid> pikhq_: very true.
18:32:48 <bgamari> colah,
18:34:07 <kenchow> sorry, i am not good at english.
18:34:59 <pikhq_> kenchow: 大丈夫。我之中国語が悪い。;)
18:36:38 <gertc> how many people now haskell over there?
18:39:42 <gertc> i was always a believer if you want to know what is best thing to learn you ask a Japanese or Chinese person would not be surprised they teach haskell in kinder garden
18:39:43 <tac> It seems like every month at some point, this channel devolves into oriental language discussion hour
18:40:13 <pikhq_> tac: It's a common hobby I guess.
18:40:15 <lispy> Is there a #haskell-jp?
18:40:20 <tac> lispy: there should be
18:40:43 <lpvb> I doubt they teach haskell in kindergarten
18:41:00 <pikhq_> Nah, kindergarten is SICP.
18:41:57 <gertc> ask any kid to caculate something over there :)
18:42:00 <pikhq_> Well, with an introductory lesson with 漫画で分かるLisp (Manga de Wakaru Lisp; "Understanding Lisp with Manga")
18:42:43 <guidj0s> SICP is hardly a book on Lisp.
18:43:32 <lpvb> pikhq_: wow, thats cool
18:43:35 <gertc> Is Lisp number 1 in Japan?
18:43:45 <lpvb> why don't we have childrens' books on lisp?
18:43:53 <pikhq_> lpvb: It's not a children's book.
18:43:59 <pikhq_> I was being a smart-ass. :)
18:44:09 <pikhq_> Though 漫画で分かるLisp is a real thing.
18:44:33 <lpvb> pikhq_: hard to tell the audience of manga
18:44:55 <pikhq_> ... Not really?
18:46:07 <gertc> Is it true there are far more haskell Jobs over there then anywhere els?
18:47:32 <xenocons> pretty hard to find any haskell jobs in AU
18:47:57 <xenocons> so a place with 1 haskell job is more than AU haha
18:48:10 <gertc> or EU or US :)
18:49:58 <gertc> its just a matter of time this channel will be invaded by the square language :)
18:50:33 <pikhq_> rômaji motto ii kai?
19:01:42 <slack1256> is somebody here from chile? (es alguien de chile aqui?)
19:02:54 <slack1256> I want to know from some meeting on latin-america (a la haskell-munich)
19:04:23 <gertc> if the Japanese invented haskell would we know about it? I know they are far more advanced in math so why not program languages?
19:05:17 <sw2wolf> Japan has Ruby
19:05:19 <guidj0s> Troll hour?
19:05:59 <slack1256> gertc: Japan isn't more advanced in math, humanity is more advanced in math as general :-)
19:06:52 <gertc> guidj0s, Troll asked a haskell question 30 minutes ago :P
19:07:02 <sw2wolf> Ruby is wonderful and easy to use, which causes Rails so popular ...
19:07:51 <sw2wolf> Matz is a VERY clever guy in Japan
19:08:10 <slack1256> The whole theme of japan (and asia for that matter) is documented in various blog post and has a lot to do with ASCII and different character set before Unicode
19:09:27 <SLi> So Unicode is an evil plan to destroy Japanese supremacy?
19:10:35 <gertc> Unicode is to make our language backward compatible with there's :)
19:11:37 <slack1256> No :-) Unicode is the realization that different languages have different simbols.
19:12:04 <elliott> does this have anything to do with haskell?
19:12:07 <sw2wolf> I feel building a haskell project is a miserable thing as it is too slow
19:12:25 <johnw> sw2wolf: slow to write it?
19:12:26 <slack1256> elliott: you are right. we should go to #haskell-blah
19:12:59 <sw2wolf> `cabal install ***` makes me wait for a long time
19:13:15 <slack1256> sw2wolf: it doesn't matter if it is slow, it just have to be fast enough ;-)
19:13:19 <johnw> sw2wolf: every time?  how big is this project?
19:13:52 <sw2wolf> such as xmonad, etc.
19:14:03 <johnw> ah
19:14:10 <johnw> well, sometimes the compiler takes a lot of time so that the application won't
19:14:31 <slack1256> maybe you changed some parameter of configuration?
19:14:41 <slack1256> maybe you set split-obj etc
19:14:44 <sw2wolf> Especially linking almost freezes my box ...
19:15:18 <sw2wolf> I even canot move mouse when linking ...
19:15:42 <slack1256> too much swapping ...
19:15:45 <johnw> sounds like your machine probably only has 1G RAM
19:15:56 <sw2wolf> yes
19:16:07 <johnw> that's how much RAM my phone has
19:16:08 <sw2wolf> A old freebsd box
19:17:15 <sw2wolf> i want to add more RAM but it is DRAM-2 which is hard to find
19:17:25 <sw2wolf> DDR-2
19:17:30 <augustss> SSD disks work magic for linking
19:17:30 <johnw> did you look an eBay?
19:18:02 <sw2wolf> maybe future
19:18:27 <sw2wolf> i plan to buy a new machine
19:19:15 <gertc> cant you run it on a online host and download it ?
19:19:36 <johnw> i do wish ghc supported something like distcc
19:19:49 <sw2wolf> slack1256: how to use split-obj using cabal ?
19:20:28 <gertc> i think vpn's have more and better ram these day's maybe you can use your box just as a terminal?
19:20:45 <dcoutts_> sw2wolf: there/s
19:20:48 <dcoutts_> oops
19:20:54 <dcoutts_> sw2wolf: there's a flag for it
19:20:56 <sw2wolf> gertc: VPN need money :)
19:21:11 <gertc> a new computer also
19:21:19 <sw2wolf> dcoutts_: in ~/./cabal/config
19:21:52 <sw2wolf> yes, but it is my computer can be used for many years
19:22:12 <dcoutts_> sw2wolf: right, and there too
19:22:30 <sw2wolf> ok, i will test it
19:22:31 <gertc> i dont know lets caculate how much a vpn cost
19:25:24 <dcoutts_> augustss: incidentally, have you noticed if dynamic linking is easier on the disks?
19:25:41 <augustss> can't say i've tested that
19:26:06 <shachaf> Doesn't linking happen on things in /tmp anyway?
19:29:13 <hpaste> edwardk pasted “for shachaf to break” at http://hpaste.org/78521
19:30:49 <johnw> heh, you're pretty much just side-stepping the type checker, eh? :)
19:33:06 <edwardk> johnw: well right now the typechecker has snuck in an unsafeCoerce on me, so my last attempt to side-step wound up with me taking a hook to the jaw
19:35:00 <slack1256> sw2wolf: usually you want to avoid split-obj for the memory overhead.
19:46:21 <johnw> split-objs makes you pay at compile/link time in exchange for smaller executables; but since disk is rather cheap, i don't see much of a point
19:46:54 <johnw> if i had hundreds of haskell utilities on my machine, i'd be a lot more excited about dynamic linking and/or split objs
19:47:10 <aristid> what's the dual of Writer?
19:47:29 <johnw> dual in what sense?
19:47:34 <aristid> categorical dual
19:47:59 <johnw> so, the monad of the flipped adjunction?
19:48:05 <aristid> i guess
19:48:14 <aristid> i don't actually know any ct :P
19:48:25 <johnw> http://cstheory.stackexchange.com/questions/2101/reader-writer-monads
19:48:30 <johnw> i think that ansewrsy our question
19:48:37 <johnw> according to that, it sounds like it would be Coreader
19:48:51 <johnw> err, no
19:49:07 <johnw> writer IS coreader, it says; so then cowriter is reader?
19:49:15 * johnw stops guessing
19:50:05 <aristid> johnw: i wonder if i should actually spend some time to learn a bit of CT
19:50:47 <johnw> i heartily recommend it
19:51:03 <johnw> besides being instructive, it's quite interesting
19:55:46 <xenocons> i understannd encapsulating an expression in the maybe\option type, what is the name of the monad to apply a function on the expression inside of the maybe\option ?
19:56:09 <aristid> johnw: what would you recommend reading so that a mere mortal may have a chance of understanding? i'm not a mathematician.
19:56:37 <aristid> xenocons: fmap
19:56:47 <johnw> aristid: http://www.amazon.com/Conceptual-Mathematics-First-Introduction-Categories/dp/052171916X/ref=sr_1_sc_2?ie=UTF8&qid=1354247783&sr=8-2-spell&keywords=category+theory
19:56:50 <aristid> xenocons: it's not a monad though, just a function
19:57:21 <johnw> that book isn't math heavy, and has lots of pretty pictures (err, diagrams, graphs)
19:57:39 <johnw> after that, some day you should get Awodey
19:57:54 <xenocons> aristid: ahh okay, umm, the correspondance of fmap means it returns the maybe type? or does it return the expression as the result
19:57:59 <xenocons> bear with me
19:58:15 <aristid> > fmap (\x -> x + 1) (Just 4)
19:58:17 <lambdabot>   Just 5
19:58:23 <xenocons> hmm ok
19:58:34 <johnw> xenocons: Maybe doesn't hold an expression; it holds a value
19:58:47 <johnw> and fmap is the answer to your question
19:58:48 <shachaf> ?
19:58:50 <shachaf> Just holds a value
19:58:54 <shachaf> Maybe "holds" a type
19:59:06 <johnw> shachaf is right
19:59:11 <xenocons> alright
19:59:13 <shachaf> A value of type Maybe a may or may not "hold a value" of type a
19:59:20 <johnw> you've gotten me twice on the same thing today, shachaf, i'm being slow
19:59:21 <xenocons> thats how its equal i guess
19:59:33 <aristid> johnw: y u so stoopid?
19:59:43 <johnw> yeah, srsly
20:00:43 <aristid> xenocons: equal?
20:00:50 <johnw> first I confuse a type constructor with a type and now I've confused a type with a value.  i'm not meta enough
20:01:18 <aristid> xenocons: by the way, Maybe itself forms a monad. but if you just need fmap, you need not concern yourself with that for now.
20:01:42 <johnw> i make this same mistake in category theory too; i confuse objects with elements, and functors with morphisms; it's like i'm just one level under where I need to be thinking...
20:01:49 <xenocons> well, the return type is the same as the input type, so fmap doesnt change the type (which is important i think)
20:02:02 <aristid> xenocons: but fmap can change the type!
20:02:04 <aristid> :t fmap
20:02:06 <lambdabot> Functor f => (a -> b) -> f a -> f b
20:02:15 <xenocons> hm
20:02:22 <aristid> > fmap (\x -> Left (x-100)) (Just 3)
20:02:24 <lambdabot>   Just (Left (-97))
20:02:48 <xenocons> isnt it just encapsulating in another type
20:02:54 <xenocons> the initial type will remain?
20:03:01 <johnw> xenocons: i'm not sure I follow you
20:03:07 <aristid> xenocons: specialized to Maybe, the type of fmap is: (a -> b) -> (Maybe a -> Maybe b)
20:03:35 <aristid> xenocons: so the type parameter of Maybe can change, but both input and output are wrapped in Maybe.
20:03:46 <xenocons> right, hm i think i get that
20:04:26 <xenocons> going to re-read the fmap part on learnyouahaskell
20:04:54 <xenocons> was only looking at the haskell maybe type as a result of messing with option.bind in F#
20:05:00 <aristid> johnw: i don't like stealing books, so i guess your book recommendation might make me 40 euros poorer :D
20:05:40 <johnw> aristid: can you buy it used at least?
20:05:52 <johnw> also, there are free articles on the web that aren't bad
20:06:17 <johnw> you may want to get Awodey and then supplement the reading with the Web
20:06:24 <johnw> that way, your money is well spent
20:06:39 <johnw> Lawvere is something you will "leave behind" once you get further in, I think
20:06:50 <johnw> also, check your public library
20:07:15 <aristid> johnw: if i'd try to read the awodey now i'd have pretty much no chance to actually understand it, right?
20:07:21 <johnw> that's not true
20:07:30 <johnw> i'm not a mathematician _at all_, and I like Awodey
20:07:32 <johnw> it's just... dense
20:07:35 <johnw> you have to supplement it
20:07:58 <johnw> but it's not like reading a book on quantum electrodynamics where I'm not even sure if it's English or not
20:08:17 <aristid> hah
20:09:09 <johnw> aristid: for example, check these out: http://www.haskell.org/haskellwiki/User:Michiexile/MATH198
20:09:33 <xenocons> oh i think i get it now
20:09:50 <johnw> these notes are just a little denser than Awodey, even, but since they summarize the same material, they go hand in hand
20:10:09 <aristid> johnw: they are _denser_ :D
20:10:10 <aristid> ?
20:10:21 <johnw> yeah, they don't explain too much
20:10:58 <aristid> johnw: assuming the money was irrelevant, the lawvere would still be your starting point though?
20:11:02 <johnw> there's also http://www.cs.man.ac.uk/~hsimmons/zCATS.pdf
20:11:22 <johnw> aristid: yes, I liked Lawvere
20:11:36 <johnw> do you know anything about set theory or abstract algebra?
20:12:00 <johnw> if money is no object, read at least the first half of http://www.amazon.com/Naive-Theory-Undergraduate-Texts-Mathematics/dp/0387900926/ref=sr_1_1?ie=UTF8&qid=1354248685&sr=8-1&keywords=naive+set+theory
20:12:19 <johnw> that helped me a LOT, since nearly every category theory text is heavy on using Sets as categeorical examples
20:12:25 <shachaf> 23:36 <ddarius> shachaf: Awodey's book and/or Barr and Wells' ESSLLI lecture notes to start.
20:12:25 <johnw> also, we should move this conversation to ##categorytheory
20:12:32 <xenocons> :t maybe
20:12:32 <aristid> johnw: i know a little little bit about set theory and basically nothing about abstract algebra.
20:12:33 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:12:36 <shachaf> The Barr & Wells notes are free online
20:13:01 <johnw> shachaf: thanks, I just downloaded those the other night
20:13:46 <shachaf> Anyway, ##categorytheory isn't for category theory discussions, it's for questions like "how do you guys pronounce monad?". :-)
20:13:47 <xenocons> :t Just
20:13:48 <lambdabot> a -> Maybe a
20:14:06 <xenocons> as expected, the same as 'a -> 'a option
20:14:08 <xenocons> hmm
20:14:19 <johnw> that's the problem with shachaf being in nearly every IRC group that I'm in
20:14:37 <johnw> damn you, even #coq?
20:26:28 <xenocons> ok cool
20:26:37 <xenocons> let f x g = g (fromJust x)
20:26:46 <xenocons> f (Just 5) (+ 5) behaves as i expect it to
20:27:39 <xenocons> takes a maybe 'a and returns a function that is applied to the 'a
20:27:47 <shachaf> xenocons: Please don't use fromJust :-(
20:27:52 <xenocons> is it bad?
20:27:55 <shachaf> f (Just x) g = g x
20:27:58 <shachaf> f Nothing g = ???
20:28:07 <Mortchek> :t maybe
20:28:09 <lambdabot> b -> (a -> b) -> Maybe a -> b
20:28:15 <shachaf> fromJust should pretty much never be used.
20:28:23 <xenocons> so f (Just x) is pattern matching?
20:28:27 <shachaf> Yep.
20:28:35 <shachaf> @src fromJust
20:28:36 <xenocons> (using pattern matching to decompose the type) that is the correct way yes
20:28:36 <lambdabot> fromJust Nothing  = undefined
20:28:36 <lambdabot> fromJust (Just x) = x
20:28:36 <xenocons> heh
20:28:50 <xenocons> un...defined??
20:28:57 <shachaf> Ignore that.
20:29:01 <shachaf> Just never use fromJust.
20:29:05 <xenocons> okay
20:29:25 <elliott> or head
20:29:36 <rwbarton> or div, amirite??
20:29:47 <xenocons> i just wrote my first haskell function, and it was bad! :)
20:30:00 <xenocons> TIL you use 'let' to bind functions inside ghci
20:30:09 <xenocons> very familiar
20:30:28 <xenocons> i feel that ghci is somewhat awkward for scratchpadding though
20:30:33 <xenocons> maybe its just something you get used to
20:30:37 <elliott> rwbarton: i will make a concession for div because haskell lacks the necessary tools to do it right and because it is easy to use safely in a way that would be much harder/uglier if done "correctly"
20:31:04 <Mortchek> What is wrong with div?
20:31:08 <elliott> (but really even fromMaybe (error "something went horribly wrong") . listToMaybe beats head)
20:31:38 <rwbarton> Mortchek, exactly the same as is wrong with head
20:32:04 <Mortchek> It's not defined for some value in its domain?
20:32:42 <shachaf> rwbarton: But there's no good alternative to div, and there are lots of good alternatives to fromJust.
20:32:49 <Mortchek> So then is the possibility of dividing by 0 the thing that is an issue?
20:32:51 <xenocons> head as in, Data.List ?
20:33:01 <xenocons> > head [1,2,3]
20:33:03 <lambdabot>   1
20:33:24 <xenocons> wow i really regret not using ghci\ghc when i went over learnyouahaskell last time
20:33:31 <xenocons> no idea why i furiously translated it into SML
20:34:15 <elliott> you tried to learn haskell by translating the examples to SML?
20:34:35 <Mortchek> If div is bad, is mod also bad?
20:34:43 <xenocons> well, i dont remember what my intention of reading it was, i think it was more for reading something and coding, not so much learning haskell
20:34:59 <xenocons> but now having a 2 month holiday, interest is renewed
20:35:00 <rwbarton> > 1 `mod` 0
20:35:02 <lambdabot>   *Exception: divide by zero
20:35:29 <Mortchek> I understand that it does that - I am just trying to clarify if that is the issue, and if so, why it's an issue.
20:35:34 <xenocons> think i got upset at ghci last time too
20:35:50 <elliott> I suspect rwbarton thinks it is not an issue at all in fact :P
20:36:24 <xenocons> think i got up to recursions last time
20:36:56 <xenocons> or maybe chapter 6..
20:37:30 <xenocons> so whats wrong with head?
20:37:40 <Mortchek> xenocons, it fails on the empty list.
20:37:51 <Mortchek> > head []
20:37:53 <lambdabot>   *Exception: Prelude.head: empty list
20:37:58 <Mortchek> In a way that's not recoverable.
20:38:03 <xenocons> hmm
20:38:17 <Mortchek> Pattern matching is preferable.
20:38:42 <Mortchek> > let f [] = 0; f (x:xs) = 1 + f xs in (f [1, 2, 3], f [])
20:38:44 <lambdabot>   (3,0)
20:39:33 <xenocons> i suppose its neater that way, i normally check the length :(
20:39:44 <Mortchek> That's the function I just wrote.
20:39:55 <Mortchek> You usually don't need to write it since it already exists. :)
20:40:06 <xenocons> ah
20:40:14 <elliott> checking the length and then using head is really bad for a whole host of reasons
20:40:16 <centrinia> > let f = sum . map (const 1) in (f [1,2,3], f[])
20:40:20 <lambdabot>   (3,0)
20:40:28 <elliott> (it's mess up, ugly, long *and* unsafe :P)
20:40:30 <elliott> er
20:40:31 <elliott> easy to mess up
20:40:38 <elliott> I guess the first and last points are the same there
20:40:45 <Mortchek> Oh, I misunderstood what xenocons was responding to, I think.
20:41:52 <Mortchek> Not to mention that checking the length to determine if something is the empty list is n-1 more steps than you need to take.
20:42:09 <Mortchek> I guess "long" covers that, though you could have also been referring to code.
20:42:24 <xenocons> you can gaurentee the list has at least one element in it though
20:42:39 <Mortchek> :t null
20:42:41 <lambdabot> [a] -> Bool
20:42:49 <Mortchek> > (null [], null [1])
20:42:51 <lambdabot>   (True,False)
20:43:17 <elliott> oh right I meant to include lsow
20:43:21 <elliott> null fixes that but not any of the others :P
20:43:28 <elliott> *slow
20:43:47 <xenocons> how does a list become empty though?
20:44:10 <xenocons> i mean, everytime ive used head i know whats in the list, i dont think ive *ever* had an exception
20:44:13 <Mortchek> I've yet to find a case for using null over pattern matching though. (But then I am relatively new.)
20:44:23 <xenocons> null is evil heh
20:44:25 <Mortchek> [] is a useful base case for recursion.
20:45:03 <monochrom> a list is empty or non-empty by construction. conscious, deliberate construction
20:45:16 <xenocons> let rec blah n L = if length L = n then L else blah (n::L)
20:45:17 <monochrom> don't tell me you don't understand your own program!
20:45:36 <xenocons> i think thats how i normally do it, i understand that checking length incurrs an extra cost
20:45:43 <hpaste> “Jonathan Fischoff” pasted “Help with Polynomials” at http://hpaste.org/78523
20:45:51 <elliott> xenocons: :(
20:45:57 <elliott> you'll write better haskell code if you don't do that :P
20:46:06 <ski> xenocons : why use an accumulator ?
20:46:15 <xenocons> heh, probably, im looking forward to trying to learn better :)
20:46:21 <joeyh> :t listToMaybe
20:46:22 <lambdabot> [a] -> Maybe a
20:46:40 <joeyh> I alias that to headMaybe, which I think better describes it
20:46:47 <xenocons> ski: well, in that function above it is just an example
20:47:15 <xenocons> but i definetly do have instances similar to that in some code
20:47:19 <Rotaerk> joeyh, that sounds like something you'd ask a girl
20:47:38 <ski> xenocons : if you really wanted to do more or less that, it would be better to separately keep track of the length in another accumulator, instead of calling `length' all the time
20:47:49 <xenocons> ski: oh right
20:47:53 <xenocons> good point
20:48:06 <xenocons> i think i need to go and change something.. heh
20:48:24 <Mortchek> length, as I alluded to earlier, needs to iterate over the entire list
20:48:44 <xenocons> probably implementation dependant
20:48:50 <edwardk> johnw: yes, that is strange.
20:48:54 <hpaste> “Jonathan Fischoff” annotated “Help with Polynomials” with “Help with Polynomials (annotation)” at http://hpaste.org/78523#a78524
20:48:55 <monochrom> "let rec blah n L = if length L = n then L else blah (n::L)" is a type error in various MLs or haskell (after changing syntax)
20:50:13 <xenocons> let rec blah n L = if L |> List.length = n then L else blah (n+1) (n::L);;
20:50:48 <monochrom> why are you doing n::L ?
20:50:53 <xenocons> (yes i realise it isnt useful) heh
20:51:42 <monochrom> it looks like trying very hard to get an infinite loop for nothing
20:52:03 <xenocons> i think it does yeh
20:52:19 <xenocons> im struggling to find a function where i check the list length before doing anything :(
20:52:36 <Mortchek> What do you need the length for?
20:52:37 <monochrom> it also looks like forcing L :: [Int] for no benefit
20:53:07 <xenocons> alert: this isnt code i use
20:53:26 <xenocons> i was trying to adhoc think of a place where i use List.length before doing something (like List.head)
20:53:29 <xenocons> heh
20:53:44 <xenocons> turns out, after a quick findstr, i might not ever have used it
20:53:52 <Mortchek> If you're going to use head, I'd at least use null instead of length
20:53:58 <Mortchek> That gives you all the information you need in a single step
20:53:59 <monochrom> ok sure. f xs = if length xs == 0 then Nothing else Just (head xs)
20:54:54 <xenocons> ah, like let blah = function | [] -> None | ...
20:55:16 <xenocons> im positive i used .head with .length somewhere, after what ski said i need to go back and check
20:55:58 <Mortchek> Also, length diverges on infinite lists, whereas null does not
20:56:31 <xenocons> when you say null, is that just an empty list?
20:56:36 <Mortchek> null is a function
20:56:37 <Mortchek> :t null
20:56:39 <lambdabot> [a] -> Bool
20:56:43 <Mortchek> It tests whether its argument is the empty list.
20:56:56 <xenocons> right, true if empty?
20:56:59 <Mortchek> Yes.
20:57:20 <xenocons> equivilant to null = function | [] -> true | _ -> false i guess
20:57:47 <xenocons> nothing puts the fear into me more than the word 'null' though
20:57:49 <Mortchek> > let null [] = True; null _ = False in (null [], null [1])
20:57:51 <lambdabot>   (True,False)
20:58:22 <xenocons> ok i get that now, i didn't read it properly when you posted before
20:58:52 <xenocons> is there any advantage using null over just == [] ?
20:59:11 <xenocons> (less things to type i guess)
20:59:43 <Mortchek> == additionally requires Eq for the thing in the list
21:00:02 <Mortchek> Whereas null works regardless of whether you can test the list members for equality
21:00:12 <xenocons> ah
21:00:17 <xenocons> :t (==)
21:00:18 <lambdabot> Eq a => a -> a -> Bool
21:00:24 <xenocons> ok
21:01:04 <Mortchek> s/members/elements/
21:01:44 <xenocons> okay, i just grepped my code, the only place im using head is after checking length heh
21:01:55 <xenocons> and its simple argv stuff
21:03:12 <xenocons> i never actually thought about the problem of head []
21:03:29 <xenocons> for some reason i had thought that head [] returns []
21:04:06 <xenocons> which it doesnt, but its a lot easier to check in haskell heh
21:04:22 <Mortchek> Well you can think of a list node as a thing with two properties - the value it contains, and another list node.
21:04:40 <Mortchek> Well, that's what you get with the cons (:) constructor
21:04:53 <Mortchek> But then there is [], which has neither of those things
21:05:14 <Mortchek> So it doesn't make sense to ask for its head or tail - it has none
21:05:40 <xenocons> hmm yeh
21:06:07 <xenocons> and im guessing if there is a function maybeHead it is equally as evil =p
21:06:34 <Mortchek> Less evil - at least you could get Nothing if you gave it []
21:06:42 <xenocons> right
21:06:50 <Mortchek> But surely not as easy as pattern matching it
21:06:57 <xenocons> so you could define maybeHead in terms of checking using null
21:06:58 <xenocons> yeah
21:06:58 <xenocons> heh
21:07:48 <conal> are type-level naturals in ghc 7.6.1, including arithmetic constraint solving?
21:07:49 <xenocons> its funny that haskell calls the option type Maybe
21:08:07 <lispy> conal: I don't think so but not really sure
21:08:26 <conal> lispy: thx. too bad.
21:08:43 <lispy> conal: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/promotion.html#promoted-literals
21:08:46 <lispy> conal: they are in!
21:09:15 <lispy> conal: Iavor put some examples on the ghc trac of how to write code that is polymorphic in the nat type
21:09:18 <conal> lispy: i see the literals and Nat but not a mention of constraint-solving.
21:09:31 <Mortchek> Sleepytime for me - good night~
21:09:38 <conal> lispy: http://hackage.haskell.org/trac/ghc/wiki/TypeNats/MatchingOnNats ?
21:09:50 <lispy> conal: http://hackage.haskell.org/trac/ghc/wiki/TypeNats
21:10:05 <conal> lispy: thx
21:10:26 <lispy> conal: that looks like the article I remembered
21:11:01 <lispy> conal: as far as the constraint solver is concerned, I don't have any info
21:11:16 <conal> hm. http://hackage.haskell.org/trac/ghc/ticket/4385 gives  7.6.2 as milestone
21:13:12 <conal> the most recent comments on that trac ticket suggest that the constraint solver is in 7.6.2 but not 7.6.1
21:17:15 <MrWoohoo> are there any restrictions on where clauses with do blocks?
21:17:57 <johnw> like what?
21:18:38 <rwbarton> they are unrelated
21:41:36 <pdxleif> Is there a way to get ghci to show you the "foralls" when you type say :t?
21:41:54 <shachaf> :set -fprint-explicit-foralls
21:42:01 <pdxleif> e.g. id : forall a: a->a or whatever, instead of a->a
21:42:08 <johnw> what exactly is the value in that?
21:42:19 <pdxleif> Cool, thanks!
21:42:48 <pdxleif> I guess I get used to those things in dependently typed langs and scala and stuff.
21:42:48 <shachaf> Consistency is all I ask!
21:43:22 <shachaf> explcit-foralls will also tell you kinds.
21:44:16 <pdxleif> @type fmap
21:44:18 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:45:31 <pdxleif> Dependently typed langs spend more time telling me about the type of types in those sigs.
21:45:38 <ski> @type runST
21:45:39 <lambdabot> (forall s. ST s a) -> a
21:46:02 <pdxleif> Where's runST from?
21:46:07 <ski> @index runST
21:46:08 <lambdabot> Control.Monad.ST.Lazy, Control.Monad.ST, Control.Monad.ST.Strict
21:46:08 <shachaf> Control.Monad.ST?
22:00:09 <Crockeo> Though this is definitely a longshot, and completely unrelated to Haskell, is anyone here in the Dublin Airport?
22:01:05 <Crockeo> 4-hour layovers are no fun when there's no one to talk to. Though I guess I could just talk to people in IRCs.
22:03:24 <johnw> hi Crockeo
22:03:27 <johnw> been there, done that
22:03:40 <Crockeo> johnw: :(
22:04:06 <Crockeo> johnw: So I'm reading a stackoverflow post on why lazy evaluation is useful
22:04:07 <Crockeo> I gotta say
22:05:34 <johnw> what do you have to say?
22:06:23 <sw2wolf> i always feel lay makes programmer lose controlling
22:06:28 <sw2wolf> lazy
22:07:06 <johnw> it increases control, in some ways
22:07:23 <sw2wolf> oh,why ?
22:07:51 <johnw> for example, some of the differences between defun and defmacro in Common Lisp (i.e., selective evaluation) is unnecessary when it's a core aspect of the language
22:07:57 <sw2wolf> At least programmer donot know when the code will be executed ...
22:08:18 <johnw> further, the *caller* gets to decide the bounds of an algorithm, it isn't something the callee has to concern himself with
22:08:52 <johnw> and it can make naive algorithms still well-performing, since the minimum work is being done
22:09:14 <johnw> in strict programs, you often have to take in additional arguments to set bounds on the calculation
22:09:23 <mapreduce> Some of the tradeoffs remind me of the tradeoffs between explicit memory management and garbage collection.
22:09:43 <johnw> that's a pretty good analogy, I"d say
22:10:40 <sw2wolf> For pure function lazy maybe ok but others not ?
22:10:54 <johnw> you mean, a lazy imperative program?
22:10:56 <johnw> egads
22:11:00 <startling> haha
22:11:13 <ski> (every function in Haskell is pure)
22:12:02 <sw2wolf> In fact it is impossible to build a completely pure software
22:12:16 <johnw> i can build one very easily
22:12:19 <johnw> it just won't do anything
22:12:28 <Nereid> haskell is all pure
22:12:31 * hackagebot cassava 0.2.1.0 - A CSV parsing and encoding library  http://hackage.haskell.org/package/cassava-0.2.1.0 (JohanTibell)
22:12:31 <sw2wolf> :)
22:12:38 <Nereid> even IO
22:12:50 <johnw> here's my pure program: at your shell, don't type anything.  and don't blink.
22:12:50 <ski> (yes, `putStrLn :: String -> IO ()' is a pure function)
22:13:39 <startling> sw2wolf: it's not impossible, it just won't do anything
22:13:43 <startling> oh, johnw beat me.
22:13:58 <sw2wolf> why do you called it pure? maybe it returns different result upon each call
22:14:09 <mauke> it doesn't
22:14:15 <Nereid> it returns the same IO action every time
22:14:18 <startling> sw2wolf, putStrLn always gives you the same IO action.
22:14:25 <ski> `putStrLn' always returns the same `IO'-action when called with the same string
22:14:41 <johnw> wow
22:14:44 <johnw> all at once now!
22:14:56 <ski> @quote fugue
22:14:57 <lambdabot> monochrom says: Welcome to #haskell, where your questions are answered in contrapuntal fugues.
22:15:06 <startling> haha
22:15:25 <sw2wolf> how about random number ?
22:15:32 <ski> pure
22:15:36 <johnw> 9 9 9 9 9
22:16:16 <mauke> :t random
22:16:18 <lambdabot> (RandomGen g, Random a) => g -> (a, g)
22:16:32 <ski> > map (fst . randomR (0,9)) (replicate 5 (mkStdGen 1234))
22:16:34 <lambdabot>   [9,9,9,9,9]
22:16:51 <startling> can I tell ghc/cabal to link with some object (.o) file that's sitting on my filesystem?
22:16:58 <ski> > unfoldr (Just . randomR (0,9)) (mkStdGen 1234)
22:17:00 <lambdabot>   [9,7,3,8,3,4,3,1,3,7,4,2,5,2,8,7,3,3,4,2,2,3,0,6,4,1,9,7,0,2,5,4,2,1,0,9,1,...
22:17:46 <sw2wolf> Do you think it is pure
22:17:48 <Nereid> sw2wolf: you could think of haskell code as producing a description of a big IO action (main) in a pure way, and that when you "run" your program, the run-time system is interpreting that description and uh
22:17:52 <Nereid> stuff
22:17:52 <ski> sw2wolf : yes
22:18:04 <Nereid> > unfoldr (Just . randomR (0,9)) (mkStdGen 1234)
22:18:07 <lambdabot>   [9,7,3,8,3,4,3,1,3,7,4,2,5,2,8,7,3,3,4,2,2,3,0,6,4,1,9,7,0,2,5,4,2,1,0,9,1,...
22:18:09 <Nereid> look, same thing!
22:18:20 <startling> heh
22:18:27 <sw2wolf> maybe the thunk is pure :)
22:18:35 <Nereid> it has nothing to do with thunks
22:18:52 <ski> (typically you'd use `newStdGen' instead of `mkStdGen' to obtain a `StdGen' which depends on the system state in some way, for unpredicatability. but lambdabot won't do I/O)
22:19:01 <Nereid> strict pure functional languages are just as pure
22:19:04 <johnw> sw2wolf: you can understand pure IO in Haskell quite simply
22:19:26 <johnw> the bytes that make up "/bin/ls" don't change every time you run it, but that doesn't mean its answers don't
22:20:05 <johnw> so to, the same IO action can yield different results depending on the context in which it is evaluated; that doesn't mean the IO action is mutating
22:20:25 <Nereid> executed, not evaluated
22:20:28 <sw2wolf> If  /bin/ls is regarded as a function, it is not pure ?
22:20:30 <mauke> johnw: ಠ_ಠ
22:20:45 <Nereid> there's a difference between execution and evaluation !
22:20:54 <sw2wolf> maybe pure as you said
22:20:58 <johnw> yeah, I meant execution up there
22:21:02 <johnw> sorry
22:21:04 <Nereid> :P
22:21:14 <johnw> /bin/ls doesn't mutate, but its results do
22:21:23 <johnw> it's a static description of an operation with dynamic results
22:21:31 <sw2wolf> yes
22:21:42 <johnw> so, a pure program is static in that way, even if its results are dynamic
22:21:57 <sw2wolf> maybe right
22:22:02 <johnw> and they are dynamic because of the way IO actions are executed
22:22:09 <johnw> not because of Haskell itself
22:22:33 <johnw> the result of "main" in a Haskell program (the IO action) will always be the same IO action until you change some part of the program
22:22:39 <johnw> but it's results when executed may vary continuously
22:22:40 <sw2wolf> In the past i thing "same input gets same output" is pure
22:22:45 <Nereid> IO in haskell is the same. you have a box full of basic IO actions (like putStrLn and whatever), and a bunch of combinators for putting them together
22:22:51 <startling> sw2wolf: yes
22:22:51 <johnw> sw2wolf: yes, but there are two outputs here
22:23:03 <Nereid> so your code will always get you the same IO action in the end
22:23:03 <johnw> sw2wolf: one output is the program, the other output is the results of executing that program
22:23:22 <sw2wolf> yes
22:25:59 <sw2wolf> sometimes we still need `seq` to force eval the outputted program ?
22:26:30 <sw2wolf> right ?
22:26:32 <johnw> I think /bin/ls is pure in a similar sense, because the same inputs will always yield the same *behavior* (with varying results).  But that doesn't mean the *functions* inside /bin/ls are pure.  They may be producing different results each time they are evaluated because they mutate global variables or some such.  In Haskell, every function is pure, which makes the behavior of the program as a whole easier to reason about
22:26:33 <Nereid> no
22:27:11 <sw2wolf> that when does haskell need `seq` ?
22:27:15 <johnw> seq is needed for efficiency only; it does not change behavior
22:27:27 <Nereid> johnw: it does change behaviour
22:27:30 <johnw> it does?
22:27:36 <Nereid> > undefined `seq` 5
22:27:39 <lambdabot>   *Exception: Prelude.undefined
22:27:40 <johnw> oh, because it could force evaluation of ⊥
22:27:41 <johnw> yeah
22:27:41 <sw2wolf> at lease evaluation order
22:27:52 <Nereid> seq adds strictness.
22:27:55 <johnw> thanks for that clarification
22:28:07 <pikhq_> Strictness does *in fact* change behavior. Subtly.
22:28:10 <johnw> seq can make processing infinite lists impossible too
22:28:22 <Nereid> but you never process the whole infinite list
22:28:43 <johnw> no, but if I recursively seq on it, it changes behavior
22:28:44 <startling> Nereid, that's only because I C-c first
22:29:36 <Nereid> johnw: well yes, that's why foldl' exists
22:29:36 <startling> has anyone written a thing that parses and loads an ELF in haskell?
22:29:48 <Nereid> @hackage elf
22:29:48 <johnw> ye-
22:29:48 <lambdabot> http://hackage.haskell.org/package/elf
22:29:49 <johnw> yes
22:30:05 <johnw> elf, pe/coff even
22:30:15 <startling> Nereid, johnw: that's half of it. :)
22:30:24 <Nereid> what do you mean by "loads" then?
22:30:38 <johnw> do you want a Haskell implementation of the system loader?
22:30:44 <startling> I want to stick the code in memory and run it.
22:31:05 <startling> johnw, part of the issue is that I'm on OS X and dealing with ELFs.
22:31:11 <johnw> oh, like dlopen?
22:31:15 <startling> yeah.
22:31:20 <johnw> then use dlopen :)
22:31:31 <ski> johnw : being pure (or not) is a property of the source program. it doesn't apply to the compiled program
22:32:02 <startling> johnw, I'm on OS X.
22:32:16 <johnw> ski: ok, that's good to know.  my CS foo is weak
22:32:17 <Nereid> I don't know that even makes sense to say whether an entire program is pure or not.
22:32:19 <johnw> fu
22:32:28 <Nereid> that it even
22:33:00 <johnw> startling: use the Haskell FFI to interface to the dlopen analogue on oS X
22:33:13 * ski didn't say "entire"
22:33:36 <startling> johnw, these object files are ELF, pretty sure dlopen on os x only deals with mach-o
22:33:55 <johnw> ahhh
22:33:58 <johnw> i see what you are sayig
22:34:05 <johnw> you need to use binutils I think
22:34:19 <johnw> good luck with that, it's knows to be broken in some ways on 10.7 and 10.8
22:34:31 <startling> darn.
22:34:46 <johnw> it's why I can use GDB 7 :(
22:34:50 <johnw> s/can't
22:36:01 <startling> I guess I can just recompile my things as mach-o. that's going to be pretty annoying though
22:36:12 <johnw> pick your poison
22:36:12 <startling> but dlopen is a good idea, hadn't thought of that.
22:37:07 <startling> has anyone used these dlopen bindings? http://hackage.haskell.org/packages/archive/unix/2.4.0.2/doc/html/System-Posix-DynamicLinker.html
22:37:23 <johnw> no, but it's a promising lead
22:38:28 <startling> well, I'm not sure how I get from a DL to a function pointer I can call.
22:38:42 <startling> oh, dlsym, didn't see that.
22:38:47 <johnw> :)
22:40:02 <startling> meh, maybe I should just write all this junk in C.
22:40:21 <startling> (I want a test framework for the very low-level code I'm writing)
22:40:40 <johnw> if anyone here likes chocolate covered coffee beans I know some phenomenally good ones
22:41:09 <johnw> where would be the fun in that?
22:41:49 <neutrino_> hi
22:42:04 <johnw> hi
22:42:11 <neutrino_> :)
22:42:40 <neutrino_> can someone recommend a good regex module? i don't need any advanced features, it has to be easy to use, it would be nice if it were fast, and had no bugs.
22:42:54 <johnw> System.Posix.Regex is easy
22:43:10 <johnw> regex-posix          >= 0.95
22:43:25 <startling> "I don't need any advanced features, it just needs to be flawless." :D
22:43:27 <johnw> if "str" =~ "pat" then ...
22:43:45 <shachaf> System.Posix.Regex is the devil.
22:43:52 <neutrino_> aha johnw
22:43:53 <johnw> i was counting the seconds, shachaf
22:44:01 <johnw> like, actually :)
22:44:03 <mauke> I think all Haskell regex modules I've seen had bugs
22:44:12 <mauke> because they FFI out to C
22:44:13 <johnw> you came faster than edwardk does to a "lens" summons
22:44:21 <edwardk> =P
22:44:21 <neutrino_> i have considered this one johnw
22:44:26 <neutrino_> but there were many others too
22:44:26 <elliott> lens
22:44:33 <johnw> there's text-icu
22:44:40 <johnw> but that was more work than it was worth
22:44:42 * edwardk looks askance at elliot.
22:49:20 <johnw> ... template haskell ...
22:49:25 * johnw ducks
22:49:41 <pharaun_> why the "dislike" of regex?
22:49:45 <pharaun_> they are nice for some tasks
22:49:51 <pharaun> damnit freenode >:(
22:50:00 <sopvop> because parsers are easy
22:50:17 <johnw> but they aren't easiER
22:50:23 <pharaun> well yeah, i've implemented a complete network protocol in parsec and it was not too bad
22:50:26 <startling> ...and mentally parsing regex is not. :D
22:50:30 <pharaun> i enjoyed it lots more :)
22:50:51 <pharaun> but like if it comes to say user inputtable regex, etc there are still places for it i guess
22:51:18 <johnw> regexs are a nicely compact DSL, and the simpler ones are perfectly easy to read
22:52:41 <pharaun> johnw: simpler ones like the email address regex perhaps?
22:52:49 <johnw> any language can be abused
22:53:02 <pharaun> oh i know, i just can't believe that someone went through the effort for that one
22:53:20 <mauke> pharaun: it was no effort
22:53:39 <johnw> well, when people emulate nintendo's in Minecraft, I wonder at the use of their time too
22:53:50 <mauke> pharaun: http://paste.scsys.co.uk/215984
22:54:03 <sw2wolf> i feel ruby style regexp is easy to use ?
22:54:28 <sw2wolf> =~ /.../
22:54:36 <mauke> did you mean: perl style
22:54:41 <johnw> sw2wolf: they ARE easy to use
22:54:45 <SHODAN> perl6 style regexps are good
22:54:51 <pharaun> mauke: hah that's way way more readable/reasonable than the giant regex blob
22:55:08 <mauke> pharaun: that's the code that generates the blob
22:55:24 <sw2wolf> johnw: yes
22:55:41 <pharaun> mauke: hehe nice :p well that explains :)
22:55:43 <hpaste> neutrino pasted “regex-posix-unittest” at http://hpaste.org/78527
22:55:43 <mauke> http://paste.scsys.co.uk/215985 - here's a more modern one for rfc 2822 (the other one is rfc 822)
23:00:57 <neutrino_> those unit tests fail
23:01:00 <neutrino_> :'(
23:03:10 <sopvop> email regerx = splitOn '@'
23:03:23 <neutrino_> regderpx
23:15:35 <clahey> edwardk, Around?
23:15:48 <edwardk> yes
23:16:21 <clahey> edwardk, So, I want to implement a parser spec that includes a state machine.
23:16:48 <clahey> In each state, a different set of parsers is available and which one matches determines the next state.
23:16:53 <neutrino_> this looks fun but it doesn't build: http://hackage.haskell.org/package/weighted-regexp
23:17:12 <neutrino_> . o O ( lens-regex )
23:17:54 <edwardk> is this for any particular class of languages? e.g. are there a fixed number of potential parsers, etc?
23:18:20 <neutrino_> clahey
23:18:24 <clahey> edwardk, It's xml related.  the potential parsers are pre set.
23:18:40 <neutrino_> this sounds like an idea i had thought of for some time
23:19:28 <edwardk> k
23:19:38 <clahey> edwardk, It's not so much that it's parsing multiple languages as it is that it's parsing a single language, but only certain possibilities are available next.
23:19:56 <neutrino_> a language where you can state new syntax definitions and have them trigger through keywords, and once a keyword is found, what follows (either indent block, or rest of line) is in that new syntax. new syntax can choose to import keywords defined in parent syntax, but doesn't have to.
23:20:03 <edwardk> sure. is this a thing where you are parsing in parallel or just sequentially?
23:20:18 <clahey> One thing that might be interesting to note is that all strings are valid members of the final parser.
23:20:32 <clahey> I.e., no string should give a parse error.
23:20:52 <clahey> edwardk, To match the spec in my implementation it's going to have to be sequential.
23:21:24 <clahey> edwardk, It may be that the spec is identical to one which doesn't have to be sequential, but to include the state machine means to make it sequential.
23:22:06 <clahey> I'm thinking of building some sort of unfoldM :: (State -> Parser (State, Output)) -> State -> Parser [output]
23:22:38 <clahey> Parser could be Monad m there.
23:22:56 <clahey> Oh, it should be Parser (Maybe (State, Output))
23:23:21 <clahey> Or possibly Parser (Maybe (State, [Output]))
23:23:37 <clahey> Or have the output be a monoid.
23:25:59 <clahey> edwardk, But first I wanted to ask you if there was something like this out there I should use or if I should make something new.
23:26:09 <clahey> edwardk, And I know you've done parsing stuff before.
23:26:37 <hpaste> neutrino pasted “regex-tdfa-unittest passes all at&t tests” at http://hpaste.org/78529
23:26:43 <edwardk> your phrasing of parts of it are funny enough that its hard for me to tell quite what you need. so you have a bunch of open parsers and are running them all forward one step? or will only one accept?
23:26:53 <neutrino_> mauke: ^
23:26:58 <edwardk> if they are all being run on the input its a 'list of successes' parser you've described
23:27:08 <clahey> Only one will accept.
23:27:14 <donri> edwardk: hey now that lens is somewhat stable, you gonna add it to https://github.com/fpco/stackage ? less of a commitment than platform IIUC
23:27:31 <clahey> Then the system will be in a new state which a different subset of rules can match against.
23:27:34 <mauke> neutrino_: ?
23:27:40 <edwardk> donri: johnw had asked earlier. i'm happy to do so
23:27:49 <edwardk> donri: i'd rather wait until 3.7 comes out though
23:27:54 <donri> aye
23:29:07 <edwardk> the current plan is to hold off for another week or so. we don't have many users pushing the projection plumbing too hard right now, so they can wait for the improvements there and we break a lot of stuff in 3.7.
23:29:19 <clahey> edwardk, Does that make sense?
23:29:28 <edwardk> all in the name of long term stability
23:29:35 <startling> is there a library somewhere for dealing with ext2 etc?
23:29:39 <neutrino_> mauke: you said no regex modules are bugless, this seems to pass the tests though
23:30:10 <startling> I want to create a fs image without going through the kernel for mounting.
23:30:12 <shachaf> I'd rather wait a little while *after* 3.7 comes out. :-)
23:30:21 <shachaf> Remember how 3.6 was going to be the stable release?
23:30:25 <edwardk> clahey: so you can always resolve strictly based on the classic "FIRST" set of each rule or something? e.g. each rule is one symbol?
23:30:30 <edwardk> shachaf: =) hah
23:30:45 <mauke> neutrino_: what do you mean by "the tests"?
23:30:48 <edwardk> fair enough lets push it off to whatever we're doing at the end of december
23:30:48 <elliott> lens will be stable when it catches up with GHC's versioning
23:31:06 <edwardk> lens will be stable when i get bored and stop frantically pushing features at it ;)
23:31:16 <neutrino_> mauke: at&t has a list of tests that can certify a regex engine.
23:31:45 <elliott> edwardk: only a matter of time before the Pointed lenses get in :P
23:31:51 <neutrino_> mauke: http://www2.research.att.com/~gsf/testregex/testregex.html
23:32:00 <edwardk> elliott: those have been officialy ruled out of scope =P
23:32:42 <mauke> neutrino_: that means nothing
23:32:46 <neutrino_> mauke: regex-tdfa-unittest implements those and passes, but it is not full featured: for example there is no character equivalence where ä == a
23:32:54 <neutrino_> why does it mean nothing, mauke?
23:33:19 <mauke> neutrino_: you might as well say "look, this regex engine has no bugs: 'a' matches 'a'!"
23:33:24 <mauke> that's also a test
23:33:37 <mauke> tests can't prove the absence of bugs
23:34:00 <shachaf> It's the absence of presence, nothing more.
23:34:25 <neutrino_> the at&t regression tests are made to check for important uses, i don't know if they're conclusive as to whether a regex implementation is correct
23:34:33 <mauke> they're not
23:34:35 <neutrino_> but this one looks better than most others
23:34:40 <mauke> plus, they're only for POSIX regexes
23:35:06 <donri> edwardk: haha i thought 3.6 was meant to be more stable :D i don't mind though
23:35:21 <neutrino_> i don't think your negative reception is well-founded, mauke
23:35:25 <edwardk> it was, but the projection plumbing in 3.6 turned out to be less useful than we wanted
23:35:50 <edwardk> 3.7 fixes that and solves the longstanding problem that you couldn't use an Iso as a projection.
23:36:07 <mauke> neutrino_: two tests of my own: "a\0b" =~ "a[\0]b", "å" !~ "[ä]"
23:36:25 <shachaf> As well as the longstanding problem where you can't get a segfault by combining lens operators.
23:36:28 <neutrino_> and, do they work in regex-tdfa?
23:36:42 <donri> i think stability comes naturally when you're out of obvious things to change
23:36:48 <edwardk> shachaf that was introduced and resolved between releases ;)
23:37:03 <edwardk> donri: https://github.com/ekmett/lens/blob/master/CHANGELOG.markdown gives a snapshot of changes in 3.7 relative to 3.6
23:37:19 <shachaf> edwardk: OK, ~3 days.
23:37:21 <mauke> neutrino_: oh, and "a" !~ "š"
23:37:24 <donri> yea i love that you have a changelog :)
23:37:24 <shachaf> That's longstanding in lens terms.
23:37:25 <sopvop> what are pointed lenses?
23:37:34 <mauke> neutrino_: no idea, I don't have that module
23:37:52 <elliott> sopvop: lenslikes with Pointed as the Functor
23:38:12 <elliott> well, as the typeclass
23:38:15 <edwardk> no the couldn't use an Iso as a projection was a much longer term issue. Projection was added in 2.9, 3 months ago and I've hated it ever since.
23:38:19 <elliott> basically, partial lenses (traversals already fill this role but a pointed lens is guaranteed to have 0-or-1 values)
23:38:23 <elliott> (a traversal can have any number)
23:38:38 <edwardk> er the fact that we couldn't
23:38:40 <clahey> edwardk, I'm not looking at the spec right now, but I believe that given a state and a series of characters, you always consume some deterministic list of characters, generate a deterministic list of output, and end in a deterministic state.
23:38:49 <donri> lens taught me the word 'peruse'. the next day i noticed it in a tv show.
23:39:03 <sopvop> pointed is sort of "pure" part of applicative?
23:39:19 <shachaf> donri: That's been taken out since.
23:39:21 <edwardk> donri: heh. one of the generalizations in 3.7 is that peruse is no longer needed. you can just use 'view' directly
23:39:22 <elliott> Pointed = Functor + pure, yes.
23:39:25 <clahey> edwardk, And it's listed as bnf, next state.
23:39:28 <elliott> (it's kind of awful usually)
23:39:31 <donri> aha :D
23:39:48 <clahey> edwardk, Rather, given a state, a bunch of bnf rules each with a next state.
23:39:49 <donri> as long as it's not "query" i'm good (query is used by acid-state and i use lenses with acid-state)
23:39:54 <edwardk> view is now generalized to work in any MonadReader as the access to the environment. which gives you the old view meaning when the Reader is (->) e
23:40:00 <neutrino_> i'm not sure how to use this module
23:40:05 <neutrino_> i've never used regex in haskell
23:40:24 <donri> neat trick :)
23:40:33 <sopvop> everyone hated query
23:40:33 <edwardk> donri: so there isn't a need for a separate 'query' combinator, the prefix form of (^.) is good enough
23:40:51 <neutrino_> do i need to run some monad or something? i get this error: http://hpaste.org/78530
23:41:17 <donri> edwardk: well query/peruse/view look better in a monad reader and do notation
23:41:29 <edwardk> yeah
23:41:33 <sopvop> neutrino_: regexps are so clever, they don't work without type annotations
23:41:44 <neutrino_> uuhhhhh
23:41:44 <donri> i used to just do, asks (^.lens)
23:41:47 * neutrino_ thinks
23:42:10 <sopvop> neutrino_: I think ("a"::String) should do it
23:42:11 <neutrino_> gotcha sopvop
23:42:12 <neutrino_> yeah
23:42:20 <clahey> edwardk, So I figured a map from state to Parser (State, output) would be good.
23:42:21 <neutrino_> i did "a" =~ "a" :: Bool
23:42:23 <edwardk> clahey: then it sounds like you still have a list of open rules being run forward in parallel
23:42:33 <clahey> edwardk, How so?
23:42:52 <lpvb> why do GHC updates always have to break everything?
23:42:56 <edwardk> since i might have multiple productions that want to advance on = from the current parse location unless the grammar was factored to be LL(1)
23:43:31 <edwardk> or unless you already pre-rolled an LALR-style state set
23:43:44 <clahey> I was going to factor it to be LL(1) so I can use trifecta.
23:44:03 <startling> me begins to write e2fsprogs bindings.
23:44:03 * startling begins to write e2fsprogs bindings, too.
23:44:21 <edwardk> if its already LL(1) then trifecta should do fine, and you could just directly transcode the grammar.
23:44:43 <hpaste> neutrino pasted “mauke tests” at http://hpaste.org/78531
23:45:02 <neutrino_> mauke: here you go
23:45:25 <neutrino_> mauke: passes the tests you mentioned
23:45:44 <mauke> ah, because it's pure Haskell
23:49:37 <donri> edwardk: hm but ^. ≠ view now
23:49:51 <edwardk> donri: view was flipped (^.) already
23:50:09 <edwardk> its just gained the overloading for monad reader
23:50:10 <donri> edwardk: http://ekmett.github.com/lens/Control-Lens-Getter.html#g:3
23:50:43 <clahey> edwardk, What do you mean by transcode the grammar?
23:50:46 <edwardk> fair enough. i can phrase it as specialized to (->), etc.
23:51:00 <donri> i thought you meant that i could do bla <- (^.lens)
23:51:07 <donri> not that i feel the need to
23:51:07 <edwardk> i mean that if the grammar is LL(1) i'm not seeing what all the crazy plumbing you want is for
23:51:24 <edwardk> donri: ah no. i meant do x <- view _2
23:51:31 <edwardk> like you use 'use' today
23:51:36 <shachaf> query
23:51:41 <donri> peruse
23:51:44 <donri> ;)
23:51:44 <shachaf> That one.
23:52:02 <edwardk> well, use for state, view for environment =P
23:52:19 <neutrino_> mauke: yes
23:52:22 <edwardk> i was just meaning that syntactically it goes in the same kind of place 'use' does
23:52:25 <donri> <edwardk> donri: so there isn't a need for a separate 'query' combinator, the prefix form of (^.) is good enough -- ah, i missed the "prefix form" bit
23:52:27 <neutrino_> mauke: and it's pretty fast too apparently
23:52:57 <shachaf> > (^.) (1,2) _1 -- prefix form!
23:52:59 <lambdabot>   1
23:53:20 <edwardk> @slap shachaf
23:53:20 * lambdabot smacks shachaf about with a large trout
23:54:52 <clahey> edwardk, It was more that the parser for each of the states was LL(1)
23:55:15 <edwardk> clahey: this is a pretty sideways way to use these tools i admit
23:55:30 <edwardk> you are trying to match some reference grammar?
23:55:38 <edwardk> is that grammar already LALR or something?
23:56:09 <clahey> I'm trying to match a reference grammar.
23:56:21 <clahey> I don't think it's lalr, though I could be wrong.
23:56:50 <donri> oh cool, "Wrapped". thought that was a neat trick in 'newtype'
23:56:51 <clahey> Though I just realized how to make it such.
23:56:59 <edwardk> my recommendation in your situation would be to use some other tool other than trifecta or parsec. just grab happy. feed it your grammar and tell it to run in GLR mode
23:57:22 <edwardk> donri: it greatly reduces the namespace clutter we put out
23:57:29 <donri> yea
23:59:03 <donri> Wrapped (r -> s -> m (a, s, w)) (r' -> s' -> m' (a', s', w')) (RWST r w s m a) (RWST r' w' s' m' a')  -- yea... :D
23:59:36 <edwardk> 'foo^.unwrapping ReaderT' becomes runReaderT foo
