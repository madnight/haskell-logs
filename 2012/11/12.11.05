00:00:09 <elliott> lightquake: right, then you want Getter Entity Integer
00:00:11 <elliott> shachaf: (oops)
00:00:22 <shachaf> to :: (s -> a) -> Getter s a
00:00:29 <elliott> yes
00:00:34 <elliott> but i mean you want a Getter Entity Integer at some point
00:00:40 <lightquake> right
00:00:44 <elliott> whether by applying "to" to a function or defining it that way in the first place
00:00:55 <lightquake> so now i have my threatLens :: Getter Entity Integer
00:00:58 <shachaf> "perhaps i can be of assistance" -- to
00:01:04 <shachaf> threatGetter
00:01:09 <elliott> it's not a lens :P
00:01:11 <lightquake> right, that's what i meant
00:01:12 <elliott> just call it "to threat"
00:01:18 <lightquake> so now i have to threat
00:02:05 <elliott> and what kind of map are you getting your entities from?
00:02:16 <lightquake> a Data.Map map
00:03:00 <elliott> hm, I wonder why lens doesn't come with built-in combinators for Data.Map, that's kind of awkward
00:03:02 <elliott> shachaf: do you know?
00:03:11 <shachaf> elliott: Because at
00:03:23 <elliott> shachaf: i mean a traversal (with keys)
00:03:27 <lightquake> so there's IndexedTraversal
00:03:36 <elliott> oh right At
00:04:05 <elliott> i forgot that existed entirely
00:04:08 <elliott> go me
00:04:19 <shachaf> > (at "a" .~ Just 5) $ M.fromList [("a",1),("b",2)]
00:04:21 <lambdabot>   fromList [("a",5),("b",2)]
00:04:41 <shachaf> > (itraverse .~ Just 5) $ M.fromList [("a",1),("b",2)]
00:04:42 <lambdabot>   Couldn't match expected type `Control.Lens.Internal.Mutator b0'
00:04:42 <lambdabot>            ...
00:04:43 <elliott> lightquake: anyway you probably want to use itraverseOf or iforOf here
00:04:47 <lightquake> yeah
00:04:51 <shachaf> Er.
00:04:54 <shachaf> Well, you know what I meant.
00:04:57 <elliott> er, without the Of probably
00:05:23 <lightquake> oh right there's a monad, so threat :: Entity -> m String
00:05:27 <elliott> :t itraverse
00:05:29 <lambdabot> (Applicative f, TraversableWithIndex i t) => (i -> a -> f b) -> t a -> f (t b)
00:05:50 <elliott> lightquake: that makes things fussier
00:05:56 <elliott> I think you can still do it but I don't know how :p
00:06:14 <lightquake> haha
00:06:35 <shachaf> Man, your getters have side effects?
00:06:44 <shachaf> You have terrible lenses, Veinor.
00:06:59 <lightquake> shachaf: it's Rand StdGen
00:08:28 <elliott> lightquake: -- | An 'Action' is a 'Getter' enriched with access to a 'Monad' for side-effects.
00:08:31 <elliott> i think you want that then
00:08:38 <lightquake> oh, neat
00:08:51 <elliott> Action (Rand StdGen) Entity String
00:09:16 <elliott> strangely there doesn't seem to be (Monad m) => (s -> m a) -> Action m s a
00:09:24 <lightquake> act
00:09:32 <elliott> oh, heh
00:09:44 <Nereid> I should take some time to understand lens at some point.
00:10:08 <elliott> so i guess you could write your entire program in lens if you wanted to
00:10:13 <elliott> it can loop through data structures and perform side effects
00:10:14 <shachaf> Functions are passé.
00:10:38 <elliott> it would be kind of interesting to have a language where the function arrow was actually Getter
00:10:39 <Jafet> The lens calculus
00:10:54 <Jafet> You should find unused greek letters now
00:11:00 <elliott> and you could extend it with the constraints on f that the more powerful types add
00:11:06 <Nereid> Jafet: or use a different alphabet
00:11:07 <shachaf> Jafet: No such thing.
00:11:33 <lightquake> we could use Linear B!
00:11:38 <Jafet> Maybe the other capital sigma that nobody uses.
00:11:47 <yitz> it would be kind of interesting to have a language where functions actually can have side effects. oh, wait...
00:12:19 <elliott> yitz: well, unaccountable effects -- those you don't describe in the type -- are one thing
00:12:19 <shachaf> 03F9   GREEK OTHER CAPITAL SIGMA SYMBOL THAT NOBODY USES     [Ϲ]
00:12:43 <elliott> i would call (a -> IO b) a function with a side-effect anyway, it acts as one in practice, even if you need some plumbing to use the kleisli category
00:12:53 <startling> is duplicate = extend id valid for a comonad?
00:13:08 <shachaf> startling: Just like join = (>>= id)
00:13:15 <elliott> shachaf: what was that definition you were complaining about in lens with Bazaar? holesOf?
00:13:20 <startling> shachaf: neat.
00:13:27 <shachaf> elliott: I fixed holesOf.
00:13:32 <elliott> oh
00:13:34 <elliott> but i was going to fix it
00:13:34 <shachaf> elliott: https://github.com/ekmett/lens/issues/80
00:13:41 <shachaf> Nereid: ☝
00:13:41 <elliott> what am i going to do with my time now
00:13:47 <shachaf> elliott: Fix elementOf!
00:13:51 <shachaf> By making it use holesOf
00:13:52 <shachaf> Which I fixed
00:13:56 <elliott> shachaf: wait, that's not the kind of fix o mean
00:13:57 <elliott> *i
00:14:05 <elliott> by complaining i meant you said it was ugly because it relied on two lists having the same length
00:14:11 <shachaf> Oh.
00:14:11 <elliott> not that it had any semantic error
00:14:15 <shachaf> Feel free to fix that.
00:14:25 <shachaf> But keep in mind that people apparently want unsafePartsOf.
00:14:38 <shachaf> unsafePartsOf :: LensLike (Bazaar a b) s t a b -> Lens s t [a] [b]
00:14:50 <elliott> lens has a bunch of awful unsafe functions already
00:14:52 <elliott> does it need more
00:15:01 <shachaf> This is one of the ones it has already.
00:15:08 <elliott> does it need more in the past?
00:15:12 <shachaf> No.
00:15:23 <elliott> in a few years everyone will be telling newbies not to use unsafePartsOf like they tell them not to use head now
00:15:29 <startling> \i f -> i f . f
00:15:30 <elliott> but it can't be removed because it's just so convenient!
00:15:32 <startling> er
00:15:38 <startling> @pl \i f -> i f . f
00:15:39 <lambdabot> ((.) =<<)
00:15:42 <startling> hmmm
00:17:30 <elliott>   f (x:xs) g = Context (g . (:xs)) x : f xs (g . (x:))
00:17:39 * hackagebot distributed-process-p2p 0.1.0.1 - Peer-to-peer node discovery for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-p2p-0.1.0.1 (AlexanderBondarenko)
00:17:48 <elliott> shachaf: is there a simpler way to write holesOf (or some combinator that expresses the problem of zipping ins and outs like that) without this complexity of the composition
00:17:57 <shachaf> elliott: maybe
00:18:18 <shachaf> Probably?
00:18:40 <elliott> well i don't feel like mangling that line into something in some unholy fused functor so i will give up until you figure that out :p
00:19:00 <elliott> oh hmm
00:19:04 <shachaf> elliott: That was the whole point.
00:19:29 <elliott> well i don't know
00:19:36 <elliott> it looks harder than i remember so i'm going to give up
00:20:08 <shachaf> elliott: Fix #80 then?
00:20:42 <elliott> that one looks boring though :(
00:20:59 <shachaf> elliott: You get to delete some code!
00:21:02 <shachaf> Deleting code is fun.
00:21:26 <gvangelista> unless it was important
00:21:28 <gvangelista> :p
00:21:54 <shachaf> *Especially* if it was important!
00:24:15 <elliott> I wonder what
00:24:16 <elliott> :t zoom
00:24:18 <elliott> actually does.
00:24:18 <lambdabot> Zoom m n k s t => SimpleLensLike (k c) t s -> m c -> n c
00:24:23 <elliott> oh, it does that
00:55:09 <lightquake> @pl \a b -> return (a, b)
00:55:09 <lambdabot> (return .) . (,)
00:57:42 * hackagebot uuagc-cabal 1.0.3.0 - Cabal plugin for the Universiteit Utrecht Attribute Grammar System  http://hackage.haskell.org/package/uuagc-cabal-1.0.3.0 (JeroenBransen)
01:18:23 <o-_-o> rollDice :: IO Int
01:18:24 <o-_-o>   rollDice = getStdRandom (randomR (1,6))
01:18:32 <o-_-o> So this is in the std lib doc
01:18:46 <o-_-o> now I want a list of 256 random numbers
01:19:01 <o-_-o> take 256 . map (\x -> rollDice) . [0..]
01:19:05 <o-_-o> why does this work ?
01:19:17 <Nereid> it doesn't
01:19:24 <Nereid> that gives you a list of 256 IO actions
01:19:30 <o-_-o> Yeah.
01:19:31 <Nereid> although you can use sequence
01:19:54 <o-_-o> take 256 . map (\x -> do a <- rollDice; a ) . [0..]
01:20:00 <o-_-o> doesn't work too ?
01:20:12 <Nereid> that's a type error
01:20:22 <Nereid> modulo braces
01:20:34 <o-_-o> take 256 . map (\x -> do { a <- rollDice; a }) . [0..]
01:20:36 <o-_-o> ?
01:20:38 <o-_-o> Sorry
01:20:39 <startling> :t replicateM
01:20:39 <Ralith> @where lyah
01:20:40 <lambdabot> http://www.learnyouahaskell.com/
01:20:41 <lambdabot> Monad m => Int -> m a -> m [a]
01:20:42 <Nereid> better to use replicateM though
01:20:52 <Ralith> better to learn how to use monads, rather than guessing.
01:20:55 <Nereid> that too
01:20:59 <shachaf> take 256 . randomRs (1,6) <$> getStdGen
01:21:08 <Nereid> that's better still
01:21:11 <Ralith> better not to put RNG use in IO in the first place
01:21:19 <Ralith> as shachaf demonstrates
01:21:33 <Ralith> (loosely)
01:21:43 <Nereid> well, the point is not to make 256 different random number generators
01:21:57 * shachaf holds up FREE THE MONADS sign.
01:22:01 <o-_-o> ah
01:22:26 <Ralith> still best not to involve IO where it's not needed
01:22:57 <o-_-o> Everytime I think I understand monads and try to use them.
01:23:05 <o-_-o> I find I am wrong in some other way.
01:23:10 <o-_-o> It is frustrating.
01:23:10 <shachaf> You just need to understand IO.
01:23:19 <shachaf> "monads" can come later.
01:23:19 <Nereid> well, do { a <- action; a } never works out
01:23:33 <Nereid> unless you really know what you're doing, at least
01:23:39 <o-_-o> Nereid, because you can't get out of IO monad ?
01:23:58 <nicoo> o-_-o: Not without evil stuff
01:24:04 <nicoo> :t unsafePerfomIO
01:24:05 <lambdabot> Not in scope: `unsafePerfomIO'
01:24:07 <Nereid> and because the types don't work
01:24:14 <o-_-o> nicoo, yeah.
01:24:16 <Nereid> because it's the same as action >>= id
01:24:25 <o-_-o> Nereid, yeah...
01:24:41 <Nereid> @src join
01:24:41 <lambdabot> join x =  x >>= id
01:25:29 <Ralith> is there a monad tutorial that takes the 'learn by implementing it yourself' approach
01:25:30 <shachaf> nicoo: Now was that really necessary?
01:25:38 <Nereid> Ralith: there are probably a bunch
01:25:40 <bartavelle> I have a (long) design question. This is mostly prose so is better viewed on pastebin http://pastebin.com/8J05tV93
01:26:13 <Nereid> the only good monad tutorial is lots of monad tutorials.
01:26:13 <bartavelle> I hope it premptively answers most of the questions about my question, which is, "isn't there a better way to do this?"
01:26:15 <Nereid> and practice.
01:26:16 <Ralith> Nereid: but you don't know of any? :P
01:26:19 <nicoo> shachaf: What ? Troubling him with unsafePerformIO ? I prefer to tell him it exists but is very very evil, rather than him discovery it on his own
01:26:36 <Nereid> Ralith: I've seen some but I can't be bothered to go back and find them.
01:26:52 * nicoo could also say one may write a function magic :: a -> b with unsafePerformIO
01:27:25 <Nereid> conversely, one can write unsafePerformIO with unsafeCoerce :: a -> b
01:28:03 <nicoo> Nereid: Yes, but unsafeCoerce => unsafeIO is more intuitive than the converse
01:28:32 <Nereid> I don't know if what you wrote is what you meant to write but whatever. both are evil
01:29:08 <nicoo> Nereid: I think it is what I meant; but yes, unsafe* is so evil it kills kittens.
01:30:11 <shachaf> unsafePerformIO is part of Haskell.
01:30:14 <shachaf> unsafeCoerce is not.
01:30:36 <startling> Ralith: "the trivial monad" is one
01:30:50 <startling> http://blog.sigfpe.com/2007/04/trivial-monad.html
01:30:55 <nicoo> shachaf: Yes, but the evilness of unsafeCoerce is easier to explain than unsafePerformIO's
01:31:32 <startling> > (unsafeCoerce unsafeCoerce) :: Int
01:31:33 <lambdabot>   Not in scope: `unsafeCoerce'Not in scope: `unsafeCoerce'
01:31:38 <startling> aww
01:32:07 <nicoo> startling: You shouldn't be able to ref unsafePerformIO from lambdabot
01:32:26 <startling> nicoo: that makes sense
01:32:46 <Nereid> > unsafePerformIO launchMissiles
01:32:47 <lambdabot>   Not in scope: `unsafePerformIO'Not in scope: `launchMissiles'
01:32:56 <Nereid> these messages have been weird lately
01:33:00 <Nereid> :p
01:33:02 <Ralith> startling: seems to lack any practical examples to ground the whole thing :/
01:34:10 <o-_-o> One thing I do know is to stay away from unsafe*
01:34:36 <Nereid> stay away unless you're damn sure you know what you're doing.
01:34:43 <shachaf> Sadly, not all unsafe functions are labelled.
01:34:53 <shachaf> On the other hand, there are functions like reallyUnsafePtrEquality#
01:34:58 <shachaf> Which is really unsafe.
01:34:59 <startling> Ralith, yeah.  I read that and immediately proceeded to Maybe, which in retrospect was good thinking.
01:35:07 <nicoo> o-_-o: This is the sanest thing to do, yes :)
01:35:25 <Jafet> @quote unsafe
01:35:26 <lambdabot> Binkley says: in response to [Philippa] plus who wants to get unsafeHead? [Binkley] Philippa: not if you're doing it in literate Haskell. because, you know, the LaTeX makes it safe
01:36:21 <startling> :S
01:36:35 <nicoo> Jafet: Ahah
01:36:46 <shachaf> @quote unsafe
01:36:46 <lambdabot> c_wraith says: oh.  well, then.  some actually *do* simply unsafePerformIO into Mordor.
01:37:06 <Nereid> @quote unsafe
01:37:06 <lambdabot> roconnor says: or maybe unsafeHead is even more unsafe than head.
01:38:06 <nicoo> @quote safe
01:38:07 <lambdabot> Pseudonym says: Or did you put in a call to unsafePierceEyeball?
01:39:04 <Jafet> @quote head.[
01:39:05 <lambdabot> Plugin `quote' failed with: regex failed: (ReturnCode 2,"Invalid regular expression")
01:39:08 <Jafet> @quote head.\[
01:39:08 <lambdabot> <kmc> says: head [] = peek . intPtrToPtr . fromIntegral . unsafePerformIO . randomRIO $ (0, 2^32)
01:39:25 <Nereid> lol
01:41:25 <Ralith> man, what terrible code
01:41:32 <Ralith> no 64 bit support at all
01:41:53 <Jafet> You mean apart from it not compiling
01:43:03 <Ralith> it doesn't? aw
01:44:12 <randomclown> Would that always return the same value?
01:44:18 <Nereid> ah yeah, you'd need another unsafePerformIO there.
01:44:33 <Nereid> or move the current one over.
01:47:22 <Jafet> randomclown: Try It and See
01:48:16 <Nereid> haha
01:48:59 <Nereid> well it crashed my ghci. as expected.
02:07:46 * hackagebot stylish-haskell 0.5.4.0 - Haskell code prettifier  http://hackage.haskell.org/package/stylish-haskell-0.5.4.0 (JasperVanDerJeugt)
02:24:48 <atriq> :t \s f -> IntSet.foldr (\i -> i `IntMap.insert` f i) IntMap.empty s
02:24:49 <lambdabot> Couldn't find qualified module.
02:25:01 <atriq> :t \s f -> Data.IntSet.foldr (\i -> i `Data.IntMap.insert` f i) Data.IntMap.empty s
02:25:02 <lambdabot> IS.IntSet -> (Int -> a) -> IM.IntMap a
02:25:52 <atriq> :t \s f -> S.foldr (\i -> i `M.insert` f i) M.empty s
02:25:53 <lambdabot> Ord k => S.Set k -> (k -> a) -> M.Map k a
02:26:38 <atriq> :t \f -> S.foldr (\i -> i `M.insert` f i) M.empty
02:26:39 <lambdabot> Ord k => (k -> a) -> S.Set k -> M.Map k a
02:30:40 <Jafet> :t (. S.toList) . (M.fromList .) . map . (id &&&)
02:30:42 <lambdabot> Ord k => (k -> a) -> S.Set k -> M.Map k a
02:30:55 <atriq> My god
02:31:57 <atriq> Mine doesn't go through [], I don't think, though?
02:32:19 <atriq> :t \f -> S.foldr (M.insert <*> f) M.empty
02:32:21 <lambdabot> Ord a => (a -> a1) -> S.Set a -> M.Map a a1
02:32:38 <ivanm> atriq: no
02:33:14 <ivanm> well, it might under the hood, but I doubt it
02:33:33 <atriq> Would that affect the efficiency at all, though?
02:34:26 <Jafet> > M.empty == mempty
02:34:27 <lambdabot>   True
02:34:45 <Jafet> I feel like I should feel enlightened
02:34:56 <atriq> > M.empty == mzero
02:34:57 <lambdabot>   No instance for (Control.Monad.MonadPlus (Data.Map.Map k0))
02:34:57 <lambdabot>    arising from...
02:35:00 <atriq> :O
02:35:03 <ivanm> I doubt it
02:35:05 <atriq> > M.empty == empty
02:35:06 <lambdabot>   No instance for (Control.Applicative.Alternative (Data.Map.Map k0))
02:35:06 <lambdabot>    aris...
02:35:10 <atriq> :(
02:35:14 <ivanm> atriq: (Map k) isn't a monad
02:35:21 <atriq> Oh yes
02:35:24 <atriq> Of course it isn't
02:36:39 <atriq> Would Set be a Monad if it weren't for the Ord-iness?
02:37:47 <ivanm> yes
02:37:52 <ivanm> hence the instance in rmonad
02:38:03 <neutrino_> what is rmonad?
02:38:12 <ivanm> @hackage rmonad
02:38:13 <lambdabot> http://hackage.haskell.org/package/rmonad
02:38:16 <ivanm> neutrino_: ^^ that is!
02:38:55 <neutrino_> cool
02:38:56 <neutrino_> thanks
02:39:36 <aleator> Why is the depth of an empty binary tree -1?
02:39:53 <atriq> Because the singleton tree has depth 0?
02:40:10 <ivanm> is it? I would have thought a singleton tree was depth 1
02:40:13 <ivanm> aleator: where is that?
02:40:14 <aleator> Yeah, but why doesn't singleton tree have depth of 1?
02:40:25 <aleator> ivanm: wikipedia, for example
02:40:42 <ivanm> so that could just be the result of the last person that bothered to edit the page and _their_ preference
02:41:13 <Jafet> > 2^0
02:41:15 <lambdabot>   1
02:41:39 <Jafet> > 2^(fix $ subtract 1)
02:41:41 <ivanm> oh, that makes sense...
02:41:43 <lambdabot>   mueval-core: Time limit exceeded
02:41:45 <aleator> ivanm: I guess my question was, why would someone have that preference..
02:41:50 <Jafet> > 2**(-1 / 0)
02:41:52 <lambdabot>   0.0
02:41:53 <ivanm> aleator: from what Jafet just did
02:42:04 <neutrino_> i am in the io monad. i want to ensure a list has only one element (i cannot make it a different type, it's from a lib), and if it has more than one then set an error. what's the best way to do that?
02:42:05 <Jafet> Clearly it should have depth -\infty
02:42:06 <aleator> Ah.
02:42:08 <ivanm> maximum number of nodes in a tree of that depth
02:42:18 <Jafet> Fix wikipedia to reflect that man
02:42:23 <aleator> Still a silly way to do it :)
02:42:46 <ivanm> neutrino_: either use a Maybe/Either String result, or throw an exception
02:43:13 <neutrino_> ok
02:43:20 <ivanm> singleton [_] = True; singleton _ = False
02:43:39 <ivanm> when (not . singleton $ xs) $ <throw exception/error>
02:43:47 <ivanm> @src when
02:43:47 <lambdabot> when p s = if p then s else return ()
02:43:58 <ivanm> @type throw
02:43:59 <lambdabot> Not in scope: `throw'
02:44:03 <ivanm> @hoogle throw
02:44:03 <lambdabot> Control.Exception.Base throw :: Exception e => e -> a
02:44:03 <lambdabot> Control.Exception throw :: Exception e => e -> a
02:44:04 <lambdabot> Control.OldException throw :: Exception e => e -> a
02:44:35 <ivanm> or if it's meant to be unrecoverable, use error rather than throw
02:45:04 <Jafet> error is just a convenient version of throw
02:46:21 <ivanm> Jafet: I thought the intention of error was that you use it when you're not meant to be able to recover from it
02:46:26 <ivanm> (though in practice you can)
02:47:32 <Jafet> Gee, that means I've been committing thoughtcrime all this time
02:47:47 <ivanm> heh
02:47:51 <ivanm> I could very well be wrong
02:47:57 <quicksilver> no, you're right
02:48:02 <quicksilver> and Jafet is thoughtcriminal.
02:48:08 <quicksilver> error is not for catching.
02:52:54 * hackagebot console-program 0.3.0.1 - Interpret the command line and contents of a config file as commands and options  http://hackage.haskell.org/package/console-program-0.3.0.1 (AriePeterson)
02:53:36 <shachaf> thoughtpolice: ☝
02:59:15 <Cale> http://ro-che.info/ccc/17.html -- haha
03:00:32 <atriq> Cale, how do you decide what to put into Lambdabot?
03:00:39 <atriq> Is it you who decides what to put into Lambdabot?
03:01:00 <Cale> Well, the running instance of lambdabot anyway
03:01:10 <Cale> I don't maintain the code of lambdabot itself
03:01:20 <atriq> I mean, like imported modules
03:01:27 <Cale> Yeah, I have control over that
03:01:51 <atriq> How do you decide what goes in?
03:02:04 <Cale> Arbitrarily
03:02:07 <Sonderblade> how do you check if a string represents a number or not?
03:02:27 <Cale> atriq: Usually people ask me to put stuff in
03:02:47 <atriq> :t all isDigit
03:02:48 <Cale> If the module list gets too long, performance can suffer though, and we end up with conflicting instances sometimes.
03:02:48 <lambdabot> [Char] -> Bool
03:02:56 <atriq> Sonderblade, that
03:03:02 <atriq> :t empty
03:03:03 <lambdabot> Alternative f => f a
03:03:04 <Cale> Sonderblade: you could use reads and see whether you get an empty list of parses
03:03:44 <shachaf> GHC 7.6 has Text.Read.readMaybe
03:03:51 <Cale> > (reads :: ReadS Double) "473.5748"
03:03:52 <lambdabot>   [(473.5748,"")]
03:03:58 <Cale> > (reads :: ReadS Double) "473.5748hhhhh"
03:03:59 <lambdabot>   [(473.5748,"hhhhh")]
03:04:05 <Cale> > (reads :: ReadS Double) "apple473.5748"
03:04:06 <lambdabot>   []
03:05:20 <t7> why is it a list rather than (Maybe a, Str)  ?
03:05:32 <Sonderblade> i want to classifly a list of strings as either numbers or not numbers
03:05:43 <Cale> because it can be useful to support (at least temporary) ambiguity while parsing
03:05:59 <Cale> None of the Prelude instances will produce a list longer than one element
03:06:00 <t7> aah i see
03:06:08 <Sonderblade> atriq: doesnt work for empty strings -> all isDigit ""
03:06:57 <atriq> "all isDigit <*> not . null"?
03:07:05 <atriq> But I would use the ReadS way
03:07:12 <Cale> Sonderblade: do you want to include fractional numbers?
03:07:19 <Cale> Or just integers?
03:07:23 <Cale> Can they be signed?
03:07:39 <Sonderblade> ints
03:08:31 <atriq> My way only really works in very specific circumstances
03:10:23 <Cale> Sonderblade: okay, so,   isNumber xs = case (reads :: ReadS Integer) of [(v,[])] -> True; _ -> False
03:10:36 <Cale> Or perhaps ReadS Int
03:10:45 <Cale> oops
03:10:50 <Sonderblade> that works, thanks
03:10:51 <Cale> isNumber xs = case (reads :: ReadS Integer) xs of [(v,[])] -> True; _ -> False
03:10:58 <Cale> yeah, I missed the xs argument
03:30:47 <neutrino_> hey guys, anyone here work on haskellers.org? I've found an error..
03:31:05 <neutrino_> sorry haskellers.com
03:55:26 <neutrino_> is there a type synonym for a -> IO a?
03:55:46 <neutrino_> so that i could for example do Whatever Foo which would then be a synonym for Foo -> IO Foo
03:56:22 <mikeplus64> neutrino_: type Whatever a = a -> IO a, why not just use that?
03:57:24 <neutrino_> oh right
03:57:28 <Jafet> > ((,) `on` length) "a -> IO a" "Whatever a"
03:57:30 <lambdabot>   (9,10)
03:57:57 <neutrino_> yeah but you have to press shift two more times for the left one
03:58:15 <neutrino_> well one to two
03:58:23 <neutrino_> so it's at least just as bad!!
03:59:06 <Jafet> > (x + length " -> IO " + x, length "Whatever " + x)
03:59:08 <lambdabot>   Couldn't match expected type `Debug.SimpleReflect.Expr.Expr'
03:59:08 <lambdabot>              w...
03:59:37 <Jafet> > (x + genericLength " -> IO " + x, genericLength "Whatever " + x)
03:59:39 <lambdabot>   (x + (1 + (1 + (1 + (1 + (1 + (1 + (1 + 0))))))) + x,1 + (1 + (1 + (1 + (1 ...
03:59:52 <Jafet> Ok, that doesn't help
04:03:18 <neutrino_> mikeplus64: but i'd have thought there would be something like that already, right?
04:04:25 <Jafet> It's a fairly useless type synonym
04:05:52 <neutrino_> ok
04:06:09 <neutrino_> btw, a -> (b -> c) is exactly the same as a -> b -> c, right?
04:06:14 <atriq> Yes
04:06:17 <neutrino_> i do believe it is
04:06:21 <neutrino_> thanks atriq
04:07:12 <quicksilver> a -> b -> c is defined to mean a -> (b -> c), yes.
04:25:42 <neutrino_> hey guys, why do i get type errors sometimes when i try to do typeOf on a specific value?
04:26:02 <ivanm> neutrino_: because the types are wrong?
04:26:04 <neutrino_> it's not because of the place i use typeOf being incorrect
04:26:07 <byorgey> pics or it didn't happen
04:26:09 <atriq> No typeable instance?
04:26:27 <neutrino_> well it says "ambiguous type variable"
04:26:40 <atriq> Aaah
04:26:49 <atriq> Add a type signature to the argument
04:26:55 <atriq> Like typeOf (3 :: Integer)
04:26:55 <byorgey> neutrino_: that's why then.  Because the value is polymorphic and GHC does not know what type to pick.
04:27:11 <neutrino_> errr
04:27:20 <donri> to tell the type of a value, first give it a type
04:27:20 <lambdabot> donri: You have 1 new message. '/msg lambdabot @messages' to read it.
04:27:21 <neutrino_> atriq: i'm using typeOf to find out the type signature.
04:27:26 <neutrino_>     Ambiguous type variable `a0' in the constraint:
04:27:27 <neutrino_>       (Data.Typeable.Internal.Typeable a0) arising from a use of `typeOf'
04:27:29 <donri> @messages
04:27:29 <lambdabot> mm_freak said 11h 16m 45s ago: it was rather for Num literals, but i might add string literals as well =)
04:27:30 <neutrino_> this is the error
04:27:31 <atriq> Ooh
04:27:35 <atriq> Why
04:27:43 <atriq> What are you trying to achieve with this?
04:28:55 <byorgey> neutrino_: instead of using typeOf, I suggest just trying to give it some concrete type, like Integer, and see what error message you get
04:29:10 <byorgey> neutrino_: wait, why can't you just use  :type  in ghci?
04:29:23 <donri> needs moar type holes
04:29:27 <neutrino_> i'm not in ghci
04:29:56 <donri> > (undefined :: ()) + 3
04:29:57 <lambdabot>   No instance for (GHC.Num.Num ())
04:29:58 <lambdabot>    arising from a use of `GHC.Num.+'
04:29:58 <lambdabot>  Poss...
04:30:10 <atriq> Why do you need the type, neutrino_?
04:30:37 <donri> ^ you can use that trick to get the type inferred in a context
04:30:40 <neutrino_> well, it doesn't fit and i'm not sure why.
04:30:47 <neutrino_> donri: hmm ok
04:31:10 <donri> undefined with a known-wrong type signature, throws a type error with the expected type
04:31:42 <donri> > length (undefined::())
04:31:43 <lambdabot>   Couldn't match expected type `[a0]' with actual type `()'
04:39:24 <neutrino_> thanks guys those are very good tips
04:41:05 <merijn> Of course this entire problem will disappear when GHC finally has holes \o/
04:41:25 <randomclown> > flip (:) <$> return "sdf" <$> return 'a'
04:41:27 <lambdabot>   No instance for (GHC.Show.Show
04:41:27 <lambdabot>                     (f0 (GHC.Types.Char -> [...
04:41:34 <randomclown> > flip (:) <$> return "sdf" <$> 'a'
04:41:36 <lambdabot>   Couldn't match expected type `f0 a0'
04:41:36 <lambdabot>              with actual type `GHC.Typ...
04:41:44 <randomclown> why doesn't this work>
04:42:00 <merijn> randomclown: Well, I have no clue what that's even supposed to do, so...
04:42:01 <randomclown> wait, fmap on wrong thing
04:42:11 <merijn> You're going to have to be more specific
04:42:52 <randomclown> concatinate a "unwrapped" 'a' onto a wrapped "sdf"
04:43:00 * hackagebot labeled-graph 1.0.0.0 - Labeled graph structure  http://hackage.haskell.org/package/labeled-graph-1.0.0.0 (JeanPhilippeBernardy)
04:43:02 <randomclown> I meant prepend*
04:43:28 <Jafet> > return (flip (:)) <$> return "sdf" <*> return 'a'
04:43:30 <lambdabot>   Couldn't match expected type `[a0]'
04:43:30 <lambdabot>              with actual type `GHC.Type...
04:43:59 <randomclown> Jafet: is there a way I can avoid writing the return in front of the 'a'?
04:44:23 <randomclown> > flip (:) <$> return "sdf" <*> return 'a'
04:44:25 <lambdabot>   No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
04:44:25 <lambdabot>    arising from a use...
04:44:33 <merijn> > flip (:) <$> return "sdf" <*> return 'a'
04:44:33 <Jafet> What are you even trying to do
04:44:34 <lambdabot>   No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
04:44:35 <lambdabot>    arising from a use...
04:44:46 <merijn> > flip (:) <$> return "sdf" <*> return 'a' :: Maybe String
04:44:47 <lambdabot>   Just "asdf"
04:47:43 <randomclown> Was going for something like
04:47:50 <randomclown> > (\f -> f 'a') <$> flip (:) <$> return "sdf"
04:47:51 <lambdabot>   No instance for (GHC.Show.Show (f0 [GHC.Types.Char]))
04:47:51 <lambdabot>    arising from a use...
04:48:10 <randomclown> > (\f -> f 'a') <$> flip (:) <$> return "sdf" :: Maybe String
04:48:11 <lambdabot>   Just "asdf"
04:48:33 <randomclown> @pl \f -> f 'a'
04:48:33 <lambdabot> ($ 'a')
05:01:12 <sanjoyd> Is hackage working?
05:01:38 <pckt> For me yes
05:03:01 * hackagebot hat 2.7.0.4 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.4 (OlafChitil)
05:08:20 <ivanm> sanjoyd: if you're having trouble with hackage for cabal-install, you can try this:
05:08:24 <ivanm> @where hackage-mirror
05:08:25 <lambdabot> remote-repo: hdiff.luite.com:http://hdiff.luite.com/packages/archive/
05:08:37 <sanjoyd> ivanm: thanks!  But it works now for some reason. :)
05:08:49 <ivanm> heh
05:31:49 <sanjoyd> Any hints on how I can implement totalArea: http://hpaste.org/77275
05:31:55 <Philippa> wow, it's possible to find 15 minutes of quiet in EU daytime?...
05:31:56 <Philippa> heh
05:32:14 <mauke> OPTIONS_GHC -X better written as LANGUAGE
05:32:24 <Philippa> assuming you're not worried about intersections, try a fold
05:33:04 <sanjoyd> Philippa: I've tried variations of foldl; but I can't seem to type it.
05:33:21 <sanjoyd> mauke: thanks! :)
05:33:25 <neutrino_> hey guys, is there a function like dropWhile which doesn't stop on the first false?
05:33:36 <mauke> neutrino_: filter?
05:33:42 <neutrino_> oh
05:33:43 <neutrino_> yeah
05:33:45 <edwardk> > filter even [1,2,3,4,5]
05:33:46 <lambdabot>   [2,4]
05:33:46 <lambdabot> edwardk: You have 2 new messages. '/msg lambdabot @messages' to read them.
05:33:47 <sanjoyd> [shape0 b0] and [forall (s :: * -> *). Shape s => s t0] seem the same to me.
05:33:51 <edwardk> @messages
05:33:52 <lambdabot> lispy said 18h 13m 15s ago: New OpenGL/OpenGLRaw with type aliases is uploaded
05:33:52 <lambdabot> shachaf said 1h 40m 10s ago: http://hackage.haskell.org/trac/ghc/ticket/7364
05:33:56 <sanjoyd> But GHC differs. :(
05:34:05 <merijn> sanjoyd: I'm not sure this example wants impredicative types...
05:34:41 <sanjoyd> merijn: basically, I want to have a list of Shapes.  How do I go about it?
05:35:09 <edwardk> @tell shachaf does that mean that  -fpedantic-bottoms will fix your issue?
05:35:09 <lambdabot> Consider it noted.
05:35:24 <merijn> sanjoyd: And the shapes should be potentially different types, I guess?
05:35:25 <quicksilver> sanjoyd: you need a "wrapping" newtype for 'any shape'
05:35:29 <sanjoyd> merijn: yeah.
05:35:45 <sanjoyd> quicksilver: but then I won't be able to add new shapes w/o changing that data decl. :(
05:35:51 <merijn> sanjoyd: You probably want ExistentialQuantification (or use GADTs to do the existential quantification)
05:35:59 <sanjoyd> Okay, this sounds like the expression problem.
05:36:01 <quicksilver> data AnyShape = forall s . Shape s => MkAnyShape s
05:36:20 <sanjoyd> quicksilver: okay, I'll try that; thanks!
05:36:24 <quicksilver> sanjoyd: ^^. No need to change the data decl if you add new shapes.
05:36:34 <merijn> This'd also work: "data Shape where Shape :: Shape s => s -> Shape"
05:36:51 <quicksilver> this is called ExistentialQuantification whichever way you do it.
05:37:06 <merijn> quicksilver: I know, I just think the GADT approach looks much cleaner :p
05:37:06 <osa1> is there a way to write this program with FunctionalDependencies instead of TypeFamilies ? http://hpaste.org/77276 can anyone show my how ?
05:37:08 <sanjoyd> Okay, I'll check out ExistentialQuantification too.
05:37:28 <merijn> sanjoyd: quicksilver's example requires ExistentialQuantification to compile
05:37:38 <quicksilver> merijn: your example doesn't compile at all.
05:37:45 <quicksilver> you can't have a class and a type with the same name.
05:37:51 <merijn> quicksilver: Oh, duh
05:38:00 <merijn> quicksilver: I was just reusing his class name without thinking, my bad
05:38:40 <merijn> "data AnyShape where AnyShape :: Shape s => s -> AnyShape", then
05:39:23 <quicksilver> I agree that GADT syntax is much clearer
05:39:28 <sanjoyd> And when I pattern match w/ AnyShape all I'll know is that s is an instance of Shape?
05:39:34 <quicksilver> sanjoyd: right.
05:39:35 <merijn> sanjoyd: Correct
05:39:35 <sanjoyd> That's nice.
05:39:42 <sanjoyd> Will try and see how it works.
05:39:50 <quicksilver> merijn: on the other hand, if you're not already using GADTs it's one more thing to grok.
05:40:05 <quicksilver> if you are, you might as well use GADT syntax for all non-trivial types, it's a much more natural syntax.
05:40:20 <merijn> quicksilver: True, but I would highly recommend learning GADTs anyway. They're like my most favourite Haskell extension :>
05:42:07 <flux> merijn, so how useful have they been for you?
05:43:15 <Philippa> quicksilver: I find it much more natural for anything that isn't strictly an ADT, but less clearly so otherwise and GADT-syntax-with-ADT-symbols would occasionally make sense/feel more natural to me? Most of my datatypes are explicitly syntactic classes from some language though
05:43:21 <merijn> flux: They're very nice when combined with DataKinds and phantom types to encode invariants in your types
05:43:23 <osa1> um, can anyone help me ? I'm trying to write this program using FunctionalDependencies instead of TypeFamilies: http://hpaste.org/77276
05:43:34 <mauke> osa1: looking
05:43:54 <merijn> flux: And as we just discussed they make ExistentialQuantification look much nicer
05:44:30 <osa1> mauke: I'm doing that as a learning exercise and I'm not even know if this is possible
05:45:01 <osa1> but I remember reading somewhere that FunDeps and TypeFamilies have same expressive power
05:48:35 <ique> hey guys, i'm doing (have done) my masters thesis project in Haskell, now I'm trying to write a short intro to haskell for unfamiliar readers, I don't want to spend much more than 3-4 pages on this as it's not super-relevant to the topic of the thesis.. what is a "Must-Have" in a short Haskell intro?
05:48:58 <companion_cube> an hyperref to LYAH :p
05:48:59 <merijn> ique: Depends on the assumed level of the reader?
05:49:15 <merijn> ique: Are they familiar with functional languages? Type theory? Nothing at all?
05:49:18 <ique> merijn: mathematicians with a basic introduction to object oriented programming using Java
05:49:23 <mauke> osa1: I got it to compile at least
05:49:24 <Jafet> Most writers don't really bother.
05:49:59 <osa1> mauke: FunDeps version or the one I posted ?
05:50:05 <mauke> FunDeps
05:50:27 <osa1> mauke: great, will you paste :)
05:50:41 <ique> I've tried giving a few examples of the type system and pattern matching.. but I'm not feeling that it gives a terribly good view of what really makes haskell haskell.. but then again, that might not be possible in a 4 page into :/
05:50:48 <beaky> hello
05:51:06 <beaky> how do you define the following without using unsafeCoerce? f = f f
05:51:16 <mauke> beaky: no
05:51:22 <beaky> mu?
05:51:45 <mauke> osa1: http://hpaste.org/raw/77276
05:51:55 <beaky> > let y f = f (y f) in y (cos 3)
05:51:57 <lambdabot>   -0.9899924966004454
05:52:03 <nand`> ique: purity, laziness, the type system, the healthy community and relative wealth of libraries
05:52:17 <osa1> mauke: um, this is the code I posted :)
05:53:02 <beaky> why is unsafeCoerce sometimes necessary?
05:53:09 <mauke> yes, mispaste
05:53:16 <atriq> beaky, weakness in type system
05:53:16 <mauke> osa1: change the last 6 to 7
05:53:28 <osa1> thanks
05:54:02 <beaky> ah maybe someday we can define the y combinator or the apply-to-self thing
05:54:16 <atriq> No
05:54:23 <atriq> It's a type theory thing
05:54:27 <atriq> Not a haskell thing
05:54:37 <beaky> so it's like the halting problem?
05:54:40 <Philippa> yeah. Fixpoint combinators have a type that says "circular arguments are a-okay!"
05:54:51 <Philippa> and self-application gives you fixpoints real fast
05:55:07 <Philippa> (rewrite Y in pointless style in terms of S, you'll see what I mean)
05:55:17 <Cale> beaky: We can already define the y combinator though
05:55:23 <Cale> beaky: using a newtype
05:55:23 <beaky> you can?
05:55:25 <beaky> ah
05:55:26 <Cale> yes
05:55:36 <beaky> I always used unsafeCoerce :(
05:56:08 <atriq> beaky, unsafeCoerce is nasty and should only be used for this if you're being evil
05:56:08 <beaky> > let f g x = if x == g x then x else f g (g x) in f cos 30
05:56:09 <lambdabot>   0.7390851332151607
05:56:10 <atriq> Like I have been
05:56:11 <beaky> ah
05:56:18 <Cale> > let y = \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x))) in y (\fac n -> if n == 0 then 1 else n * fac (n-1)) 10
05:56:20 <lambdabot>   3628800
05:56:29 <beaky> ah
05:56:31 <Cale> lol, I can't believe I recalled that from memory
05:56:41 <atriq> If you're okay with being evil, though, unsafeCoerce <*> unsafeCoerce is great
05:56:47 <beaky> lol
05:57:00 <Cale> I haven't slept, it's almost 9am here
05:57:12 <Cale> and I got 6 hours of sleep the previous night
05:57:23 <Cale> anyway
05:57:33 <Cale> If you try to define y
05:57:53 <Cale> :t let y = \f -> (\x -> f (x x)) (\x -> f (x x)) in y
05:57:54 <lambdabot>     Occurs check: cannot construct the infinite type: t1 = t1 -> t0
05:57:55 <lambdabot>     In the first argument of `x', namely `x'
05:57:55 <lambdabot>     In the first argument of `f', namely `(x x)'
05:58:08 <Cale> It says you need a type t1 which is equal to t1 -> t0
05:58:20 <Cale> Or a type r which is equal to r -> a, let's say
05:58:37 <Cale> Well, we maybe can't do equal to, but we can do isomorphic to through a newtype
05:58:53 <beaky> ah
05:58:55 <Cale> newtype Rec a = InR { outR :: Rec a -> a }
05:59:10 <Cale> then we get:
05:59:15 <Cale> :t InR
05:59:16 <lambdabot> (Rec a -> a) -> Rec a
05:59:19 <Cale> :t outR
05:59:21 <lambdabot> Rec a -> Rec a -> a
05:59:34 <Cale> and by applying those at the right points, we can typecheck the Y combinator
06:03:10 <mauke> typecheck yourself before you typewreck yourself
06:03:15 <beaky> right
06:04:12 <sanjoyd> Hence you're not allowed to do those in Agda. :)
06:07:33 <Cale> mauke: That would make a great t-shirt
06:08:30 <tricorder42> i just joined, what would be a t-shirt?
06:08:47 <atriq> "Typecheck yourself before you typewreck yourself"
06:09:25 <EvanR7> lol
06:09:32 <EvanR7> tweeted
06:14:03 <neutrino_> hey guys, is michael snoyman on irc?
06:14:40 <neutrino_> i'm trying to contact him because haskellers.com is broken
06:17:01 <mauke> EvanR7: tweeted here as well
06:17:17 <EvanR7> tweeter bros
06:19:17 <mauke> I need more followers
06:19:19 <mauke> and more tweets
06:20:11 <EvanR7> i had that problem for a long time, it seemed the only people on twitter were megacorps pushing their wares
06:20:23 <EvanR7> and the search is abysmal
06:28:00 * hiptobecubic coughs
06:29:20 <atriq> I wonder if I started naming internal functions and stuff in released packages after Homestuck characters how long it would take for people to notice
06:32:21 <donri> mm_freak: my point was it says "If you have enabled the OverloadedStrings extension you can also write string literals: " and then after the colon is an example without string literals... a bit confusing is all!
06:34:33 <scp> Sweet, I just made my first erlang mistake that involved assuming laziness =P. Haskell is finally getting ot me
06:34:36 <scp> s/ot/to
06:34:47 <hpaste> efie pasted “how to parse a large file with a lot of Doubles?” at http://hpaste.org/77279
06:34:50 <neutrino_> i keep doing that in all languages ;\
06:34:59 <atriq> I avoid that by only using Haskell
06:35:09 <neutrino_> smart
06:35:12 <neutrino_> i should do that
06:35:24 <dmwit> donri: That is weird, yeah.
06:37:06 <dmwit> efie: You can do better if you know something about the format of your Double.
06:37:28 <atriq> edwardk, can you send me a doodly image thing of what you intended the haddock of Data.Functor.Extend to look like?
06:37:31 <atriq> Layout wise, I mean
06:37:36 <dmwit> That's the approach I took in yeganesh.
06:38:00 <edwardk> take a look at the docs from Control.Comonad
06:38:15 <edwardk> i think i bothered to fix those. not sure
06:38:19 <efie> dmwit: what do you mean by format?
06:39:10 <dmwit> efie: Like, if you know there's going to be an optional sign, then a number, then a '.', then more numbers and that's it, you can save a lot of time by writing a parser that only succeeds on such a string.
06:39:27 <dmwit> efie: As opposed to also accepting exponential notation and other stuff.
06:39:32 <tricorder42> dmwit: regex?
06:39:39 <dmwit> tricorder42: ew, no
06:39:53 <dmwit> regex don't convert to a Double anyway.
06:40:16 <t7> has anyone else implemented the calculus as described in Wadler's 'Making ad-hoc polymorphism less ad-hoc'?
06:40:19 <tdammers> regex is a useful optimization for pre-processing stuff when your host language is too slow to churn through individual characters itself
06:40:43 <tdammers> but with Haskell, there is absolutely no gain in using them for most parsers
06:41:08 <tricorder42> tdammers: makes sense, i don't like regex as much anyways.
06:41:25 <mm_freak> donri: yeah, i understand that
06:41:32 <mm_freak> that's why i'm going to add it
06:41:42 <efie> dmwit: hm no, the format varies unfortunately
06:41:58 <dmwit> too bad
06:42:08 <tricorder42> efie: example of format?
06:42:13 <dmwit> tricorder42: ...is in the paste
06:42:15 <donri> mm_freak: netwire 4 looks real good btw. not that i know much about frp. i take it you're planning a more detailed blog post?
06:42:22 * tricorder42 facepalm
06:42:33 <donri> mm_freak: i'd love to see some practical example that netwire/frp solves elegantly
06:43:07 * hackagebot azure-service-api 0.1.0.0 - Haskell bindings for the Microsoft Azure Service Management API  http://hackage.haskell.org/package/azure-service-api-0.1.0.0 (EdskoDeVries)
06:44:00 <donri> mm_freak: and more detailed explanation for the Time thing, why it's needed, what it's used for and why it's not thread-unsafe or pron to race conditions as it sounds like in the abstract :)
06:44:04 <efie> well, 1.0, 0.16019902533825847, 5.1571940190904684e-9, something like this is possible
06:46:03 <donri> mm_freak: should these really say *Monad* constraint? http://hackage.haskell.org/packages/archive/netwire/4.0.5/doc/html/Control-Wire-Wire.html#g:3
06:46:32 <efie> or would it make more sense to try something like http://www.haskell.org/haskellwiki/DealingWithBinaryData#Binary_parsing ? is it easy for the data I have? ( [["0.0003","1.454e-9"]] )
06:46:40 <dmwit> efie: I wonder how it behaves if you use something like parseFloat = {- ask me about this part -} <$> many (noneOf '\"')
06:48:07 * hackagebot distributed-process-azure 0.1.0 - Microsoft Azure backend for Cloud Haskell  http://hackage.haskell.org/package/distributed-process-azure-0.1.0 (EdskoDeVries)
06:48:44 <dmwit> As in, I wonder whether the parser that the token definition makes is doing too much backtracking and causing you to hold on to things you shouldn't hold on to.
06:48:51 <mm_freak> donri: thanks…  a more detailed blog/ML post is planned, but don't wait for it…  i'll write more libraries first
06:49:05 <mm_freak> donri: Time is simply time, in fact just Double
06:49:15 <donri> yea that much i know :)
06:49:48 <cgaebel> erv identify nottelling
06:50:11 <dmwit> cgaebel: might want to change that password
06:50:52 <efie> dmwit: yes, I also thought that it is not good to make and use myEmptyDef only for parsing Floats ... ?
06:51:20 <dmwit> dunno, that seems like it's probably a one-time cost and certainly doesn't take 6 seconds =)
06:53:57 <cgaebel> dmwit: Thanks. Noted. Is there a better irc client for linux than xchat? It's kind of annoying me.
06:54:12 <tricorder42> cgaebel: i use chatzilla in firefox
06:54:15 <tdammers> cgaebel: have you tried irssi?
06:54:25 <mm_freak> cgaebel: if you like terminals, try irssi and weechat
06:54:30 <dmwit> I like irssi for no other reason than I was peer-pressured into it as my first client and it hasn't sucked.
06:54:44 <cgaebel> I'm on chrome, so chatzilla won't work for me.
06:54:52 <mm_freak> i use irssi, but people seem to be moving towards weechat
06:54:53 <cgaebel> I'll try out irssi. thanks!
06:55:02 <cgaebel> (and possibly weechat)
06:55:28 <ChristianS> cgaebel: xchat is fine if you prefer graphical
06:55:40 <tricorder42> cgaebel: there's probably some chrome extention too
06:55:47 <ChristianS> but apparently you don't like it?
06:55:52 <cgaebel> I couldn't find a decent chrome extension. They all looked half-assed.
06:56:01 <cgaebel> xchat won't save my password, and keeps crashing on the latest ubuntu
06:56:03 <atriq> edwardk, I've fixed the docs for Data.Functor.Extend
06:56:19 <edwardk> atriq: can you send me a pull request?
06:56:20 <hiptobecubic> weechat is great
06:56:26 <cgaebel> okay. installing weechat.
06:56:27 <ChristianS> cgaebel: strange, never had such problems (but i'm on debian)
06:56:29 <neutrino_> cgaebel: i suggest irssi
06:56:32 <mauke> weechat is shit
06:56:34 <djcoin> Is there a simple way to "decompose" (like I would unroll a loop) for a function call ? Eg: i would like to see a each step of a `foldr' call
06:56:41 <cgaebel> oh god please no IRC client flame wars.
06:56:54 <neutrino_> i'm ok
06:57:02 <hpaste> efie annotated “how to parse a large file with a lot of Doubles?” with “modified parseFloat” at http://hpaste.org/77279#a77280
06:57:10 <merijn> > foldr f z [a,b,c,d,e,f]
06:57:12 <lambdabot>   f a (f b (f c (f d (f e (f f z)))))
06:57:23 <cgaebel> map (+2) [1..5]
06:57:31 <mauke>  void weechat_string_tolower (const char *string);
06:57:33 <cgaebel> oh. I get it.
06:57:39 <cgaebel> > map (+1) [1..5]
06:57:40 <cgaebel> neat.
06:57:40 <atriq> edwardk, sent
06:57:41 <lambdabot>   [2,3,4,5,6]
06:57:42 <dmwit> efie: That's great!
06:57:43 <efie> dmwit: thanks, it helped a bit, but it's still too slow and takes too much space. ..
06:57:44 <merijn> djcoin: You can do that in ghci too, but it requires some import I forgot
06:57:49 <dmwit> efie: Especially because read is known to be ass-slow.
06:58:01 <dmwit> efie: So if switching to it helped that much, you can get much, much faster by using something better than read.
06:58:12 <edwardk> atriq: thx
06:58:13 <rwbarton> try: return $! (read s :: Double)
06:58:18 <rwbarton> for a start
06:58:21 <merijn> Where was Expr defined again?
06:58:24 <djcoin> merijn: yeah I saw the bot can do this, I was indeed wondering how I could debug locally. Thanks
06:58:28 <atriq> (I'm "Taneb", btw)
06:58:30 <rwbarton> otherwise you are retaining a gazillion strings
06:58:40 <merijn> djcoin: You want SimpleReflect.Expr
06:58:42 <efie> dmwit good news :)
06:59:04 <dmwit> efie: Experience report: switching from read to using the underlying ReadP parser straight from GHC sped up yeganesh initialization by about a factor of 10 -- meaning the parsing was probably a factor of about 20 faster with the readp thing than with read.
06:59:19 <dmwit> efie: You can snag the code from Lex.hs at
06:59:22 <dmwit> ?hackage yeganesh
06:59:22 <lambdabot> http://hackage.haskell.org/package/yeganesh
06:59:27 <atriq> edwardk, I didn't change any files other than Data/Functor/extend.hs, so the Cabal'll need to be changed
06:59:34 <merijn> djcoin: http://hackage.haskell.org/package/show-0.4.1.2
06:59:52 <dmwit> efie: Specifically, use lexDecNumber from there -- it cuts out the stuff for reading parentheses, spaces, and a bunch of other crap that read does.
07:00:02 <edwardk> atriq: np. there was a slight issue with the spacing, but otherwise looks good
07:00:08 <atriq> Okay
07:00:10 <edwardk> --> doesn't parse as a comment ;)
07:00:24 <djcoin> merijn: thanks a lot
07:00:32 <ocharles> if I want to run a monadic action for every element of a set, should I 'foldl/r (foo) (return ()) (>>)' or just forM (Set.toList blah) ?
07:00:42 <ocharles> (I'm only running for side effects)
07:00:52 <ocharles> this is Data.Set, fwiw
07:00:54 <merijn> ocharles: Import Data.Traversable and use mapM from there
07:00:58 <atriq> edwardk, ack
07:01:04 <ocharles> you can't traverse a set, merijn, it's not Traverable
07:01:04 <rwbarton> or Data.Foldable even (mapM_)
07:01:06 <ocharles> can you?
07:01:10 * ocharles looks
07:01:14 <merijn> ocharles: I don't see why not?
07:01:25 <dmwit> http://dmwit.com/yeganesh/Lex.hs
07:01:27 <rwbarton> traversable no
07:01:28 <ocharles> because it could change the contents of the set and introduce duplicates
07:01:39 <merijn> oh, only foldable
07:01:42 <ocharles> right
07:01:44 <merijn> But that's good enough for you
07:01:46 <ocharles> I haven't used Data.Foldable before :)
07:01:48 <merijn> mapM_ is Data.Foldable
07:01:51 <ocharles> but i'm aware of it
07:01:51 <ocharles> sweet
07:01:55 <rwbarton> Foldable is just toList in another guise but maybe forM_ has been fused somewhat for you
07:02:16 <ocharles> data.set doesn't seem to be foldable
07:02:24 <ocharles> urgh
07:02:29 <edwardk> atriq: pushed, uploaded to hackage as 3.0.0.1
07:02:34 <ocharles> excuse me, it's a monday :( Now I see it is indeed there
07:02:35 <atriq> :)
07:02:39 * ocharles gets to work
07:02:42 <merijn> pfft
07:02:42 <ocharles> thanks rwbarton, merijn
07:02:55 <merijn> oh, I thought I was going insane for a second there
07:03:11 <clark> exit
07:03:34 <efie> rwbarton: return $! (read s :: Double) gives 72 MB vs 625 MB total in use but slowed it down: 26 vs 3 seconds
07:03:46 <dmwit> oh ho ho
07:03:48 <rwbarton> probably because you never parsed the Doubles at all before
07:03:53 <dmwit> yeah
07:03:56 <dmwit> This is sad news.
07:04:40 <efie> sorry, what do you mean?
07:05:06 <dmwit> He means you just had a list of lists of thunks, no actual Doubles. =)
07:05:17 <ocharles> you didn't actually use the contents of the list, and thus never did that work
07:05:20 <ocharles> (is the guess)
07:05:32 <dmwit> You should probably change main to print the sum of all the elements or something to make sure everything's actually being executed in both benchmarks.
07:05:57 <dmwit> You'll want to redo the 6.02-second benchmark you started from, to, just in case.
07:06:01 <rwbarton> yeah by "parse" i meant converting String to actual Double, not at the parsec layer
07:06:25 <efie> ah ok :)
07:06:42 <cgaebel> well that's nice. seems someone changed my password.
07:06:43 <cgaebel> wonderful.
07:06:55 <cgaebel> ah well. I deserved it. :)
07:08:08 * hackagebot semigroupoids 3.0.0.1 - Haskell 98 semigroupoids: Category sans id  http://hackage.haskell.org/package/semigroupoids-3.0.0.1 (EdwardKmett)
07:08:41 <clarkg> /solved.
07:09:17 <dmwit> clarkg: You could consider contacting a freenode admin.
07:10:14 <ocharles> if I have a heteregeneous list built up with existential types (forall a. Elem a), is it possible to filter that into a homogeneous list of a specific type later? so, if I have as = [Elem $ A], I can write something that is :: [Elem] -> [A] ?
07:10:30 <ocharles> i'm wondering if modelling this existentially is not the right solution...
07:10:40 <merijn> ocharles: No
07:10:55 <Philippa> ocharles: not unless the existential tells you enough to have something to filter on
07:10:56 <rwbarton> if you include Typeable in your existential
07:11:01 <dmwit> If the constructor is really forall a. Elem a, you are truly out of luck.
07:11:01 <rwbarton> for instance
07:11:05 <merijn> ocharles: Existential quantification loses the information of which type it intially was (unless you encoded it in there somewhere)
07:11:07 <dmwit> You can't do anything with those.
07:11:13 <Philippa> if all you know is that the values exist, all you can do with them is pass them to id
07:11:23 <ocharles> well, it's forall a. RelationshipTarget a =>, but that class is nothing but a constraint
07:11:28 <ocharles> yea, I figured I was out of luck
07:11:36 <clarkg> dmwit: I'll try.
07:11:48 <merijn> ocharles: That only means you can call functions that use the RelationshipTarget typeclass on them
07:11:51 <ocharles> right
07:12:24 <merijn> ocharles: Whenever you pack up the a, GHC also adds the relevant RelationshipTarget dictionary, so that when you pattern match you can use that dictionary to do stuff
07:12:36 <merijn> But the actual type information is lost, unless encoded separately
07:12:52 <ocharles> I'm trying to model the ability to store arbitrary links between entities in this project. An artist can reference an artist, a label, a recording, etc... all of which are different types. So I think I'll just have to write: data EndPoint = ArtistEndPoint Artist | LabelEndPoint Label | etc
07:13:11 <ocharles> i don't think the existential does at all what I want
07:13:26 <merijn> ocharles: I don't know about the exact use case, but maybe you can get close to what you want using GADTs and phantom types?
07:13:56 <ocharles> perhaps, I never got enough intuition with GADTs to make use of them myself
07:14:01 <ocharles> i only "get" them in the simplest sense of the word
07:14:25 <ocharles> but i'm not so sure, with a phantom type I'd think I'd end up restricting myself to a homogeneous list
07:14:29 <merijn> ocharles: Actually, I'm not sure they'd help here now that I look at what you're doing
07:14:48 <merijn> ocharles: Implement a heterogeneous list to encode the variations? :p
07:15:09 <hpaste> efie annotated “how to parse a large file with a lot of Doubles?” with “modified parseFloat (annotation)” at http://hpaste.org/77279#a77281
07:15:11 <ocharles> I think I'll just enumerate the cases in a sum type
07:15:34 <ocharles> if commonality/inspiration emerges, then I can always refactor
07:15:35 <merijn> ocharles: I actually wrote code for that, work relatively well and probably wouldn't be to hard
07:15:39 <bxc> ocharles: maybe you can do something with Typeable instead?
07:15:43 <efie> I guess even a better read function can't make the 2 attempts faster than parseFloat = float $ makeTokenParser myEmptyDef?
07:15:52 <ocharles> bxc: i have an irrational phobia of typeable :)
07:16:12 <bxc> but doesn't it almost do exactly what you want?
07:16:18 <bxc> and if that feels bad, maybe you're being bad...
07:16:22 <merijn> ocharles: I have patterns (i.e. lists) that combine three different types of pattern objects together, so I wrote a heterogenous list that uses them
07:16:54 <ocharles> bxc: the irrationality stems from me not knowing much about it
07:17:06 <ocharles> merijn: got any code?
07:17:16 <merijn> ocharles: Actually, not sure whether the filter would work then without doing the sumtype, so it might still be useless >.>
07:17:43 <merijn> ocharles: I'd say just use the sumtype...
07:18:03 <ocharles> I think it's the safest option for now
07:18:24 <ocharles> the fact that I don't quite know what I plan to even do with this data yet is indicative of me trying to invent too much at once
07:18:51 <rwbarton> efie: btw "total alloc" is better thought of as a measurement of a certain kind of time usage
07:19:18 <rwbarton> for what's normally considered space usage you want the one that says maximum heap usage or something
07:19:35 <efie> ok
07:20:30 <efie> do you know why parseFloat takes up so much space?
07:20:58 <rwbarton> you mean allocates so much?
07:21:02 <efie> yes
07:21:36 <rwbarton> you said a 10 MB input file?
07:22:10 <rwbarton> i mean the answer is that basically the only thing that your program does is parse flotas
07:22:11 * bxc interfacing haskell into drupal to write drupal plugin modules in haskell. /me wonders how sick he is.
07:22:13 <rwbarton> floats
07:22:15 <efie> rwbarton: yes, 10 MB
07:22:33 <rwbarton> profiling is pretty useless here
07:23:19 <S11001001> bxc: depends on whether you reduce total php writing by at least one line
07:23:27 <bxc> heh
07:23:29 <bxc> by quite a lot.
07:23:38 <S11001001> then perfectly sane
07:23:39 <cgaebel> HA. Password reset is useful.
07:24:14 <efie> rwbarton: In the end I want to parse a 150 MB file of floats, do you know what else I could try to reduce amount of allocation and time usage? (besides Parsec?)
07:24:18 <tdammers> bxc: writing a compiler in haskell that outputs PHP... talk about sick...
07:24:27 <atriq> Welp, I'm installing GHC again
07:24:31 <bxc> tdammers: heh no, not that
07:24:33 <atriq> (I REALLY want lambdacase :( )
07:24:46 <bxc> tdammers: mostly wiring php->CGI-like JSON interface->haskell
07:24:57 <rwbarton> not something that will take less than 15 * 6 seconds to implement
07:25:10 <bxc> tdammers: drupal has a reasonable model of callbacks which I can hook into fairly easily
07:25:43 <rwbarton> but if you want to write ugly code for speed you can do it with http://hackage.haskell.org/packages/archive/bytestring-lexing/0.4.0/doc/html/Data-ByteString-Lex-Double.html
07:25:44 <bxc> tdammers: and putting stuff into json lets me generate most of the data structures on the haskell side
07:25:47 <qwr> efie: first thing - make sure you're _not_ storing the data somewhere as [Char]
07:26:32 * qwr thinks attoparsec was able to work on bytestring
07:26:59 <rwbarton> here you effectively are using String because parsec is handing you every unparsed double as a String
07:27:06 <qwr> efie: second, make the parsed floats _strict_
07:27:11 <rwbarton> and those doubles comprise most of your input file
07:28:03 <rwbarton> the strictness should help your memory usage, which you aren't looking at (or haven't shown us)
07:28:26 <beaky> hello
07:30:07 <Philonous> efie:  When you define a custom data structure to hold the floats, make the fields strict and unboxed, like so: data Foo = Foo {unFoo :: {-# UNPACK #-} !Float } }
07:30:09 <efie> eqr, wbarton: but ain't the parsec parser strict? I mean I used Data.ByteString and Text.Parsec.ByteString
07:30:28 <tdammers> bxc: yeah, I understand what you're saying
07:30:35 <rwbarton> there is more than "strict" and "lazy"
07:30:51 <tdammers> bxc: in my case, running haskell code on the server is not an option
07:31:06 <efie> Philonous: thanks, but I just use a list
07:31:06 <bxc> i can run whatever i want on the server
07:31:21 <bxc> (now you can puzzle over why I choose drupal...)
07:31:41 <tdammers> bxc: but since PHP sucks at parsing, and I want a real template language, I wrote a compiler that reads a sane kind of template language and outputs fairly performant PHP
07:31:53 <tdammers> bxc: indeed
07:33:09 * hackagebot Checked 0.0.0.2 - Inbuilt checking for ultra reliable computing  http://hackage.haskell.org/package/Checked-0.0.0.2 (RobertOnslow)
07:35:06 <atriq> GHC's configure script won't run?
07:35:13 <efie> rwbarton: sorry again :) what do mean by there is more than strict and lazy?
07:36:34 <atriq> "configure: error: cannot determine current directory"
07:40:27 <notdan> What graph library can you guys recommend?
07:40:42 <adu> graphviz
07:40:48 <atriq> What are you using the graph for?
07:40:52 <notdan> No, I mean for representing graphs
07:40:59 <cgaebel> how big?
07:41:01 <notdan> I'll be doing the usual things: finding cycles, tagging nodes
07:41:28 <notdan> cgaebel: might get rather big
07:41:38 <notdan> I'll use it for model checker
07:41:40 <cgaebel> megs, gigs, or terabytes, or petabytes?
07:42:00 <cgaebel> the answer's different for each of those
07:42:30 * Adie pokes cgaebel :/
07:42:55 <cgaebel> I've had good luck with http://hackage.haskell.org/package/fgl, but it tends to die when graphs get into the gigabytes.
07:43:00 <notdan> Well I can't really give you the number cgaebel, but not bigger than hundreds of mgs
07:43:06 <notdan> I hope
07:43:34 <cgaebel> Try out fgl. Use it till it dies. It has a really nice graph representation.
07:43:41 <cgaebel> it's great for reasoning, but not so good for performance.
07:43:54 <neutrino_> hey, guys
07:44:08 <neutrino_> is anyone here into analog computers and the like?
07:44:24 <notdan> Ok, I'll check it out cgaebel, thanks!
07:44:33 <cgaebel> no problem.
07:44:35 <neutrino_> oh, might be wrong channel
07:44:58 <osa1> I'm trying to understand first-order vs. higher-order distinction, for instance, how does first-order unification and higher-order unification differ, first-order logics and higher-order logics etc. can anyone give me some pointers ?
07:45:29 <companion_cube> first order unification is easy, higher order unification is undecidable, to start with :)
07:46:13 <osa1> companion_cube: yeah I know that much :)
07:46:16 <companion_cube> the difference between those logics is in the syntax but also in the semantics
07:46:44 <companion_cube> because in extensional HO logics, formulae represent sets, so if two formulae represent the same set they are equal
07:47:21 <notdan> cgaebel: what's your opinion on the containers package?
07:47:37 <cgaebel> containers is for when your graph gets bigger.
07:47:41 <cgaebel> the representation isn't as nice though
07:47:42 <bartavelle> does wrapping a stateT into another stateT into an errorT have a noticeable performance impact compared to running everything in a single stateT ?
07:47:58 <bartavelle> i benched between Pure and State, and it is about 1000x for a very simple program
07:48:17 <bartavelle> it is probably not that bad with real programs
07:48:24 <rwbarton> efie, just that there are many sources of laziness and just because a piece of code is strict in one regard does not mean it is strict in every possible regard or the relevant regard
07:48:54 <osa1> companion_cube: can you point me some resources for detailed info ?
07:49:27 <companion_cube> osa1: hmm, mostly books, but I don't really know good references (learnt this in school)
07:49:39 <companion_cube> try some classic books about logics, I suppose
07:49:50 <osa1> companion_cube: what classic books about logics :)
07:50:06 <companion_cube> heh :/
07:50:51 <Philippa> bartavelle: are you compiling with optimisation on when you bench, OOI?
07:50:56 <bartavelle> yes
07:51:08 <bartavelle> i made the output dependant of readContents
07:51:12 <bartavelle> getcontents
07:52:03 <bartavelle> http://hpaste.org/77282
07:52:16 <bartavelle> i randomly sprinkled the code with ! too
07:53:50 <cgaebel> bartavelle: your 'when' clauses in 'calcStuff1' have the strictness in the wrong place
07:53:58 <ClaudiusMaximus> bartavelle: State.Strict is strict in the actions not the state, so you might need modify' instead of modify, perhaps
07:54:11 <cgaebel> bartavelle: yeah, use modify'
07:54:46 <bartavelle> ok
07:54:48 <bartavelle> lemme check
07:55:09 <ClaudiusMaximus> @hoogle modify'
07:55:10 <lambdabot> No results found
07:55:27 <bartavelle> where does modify' come from ?
07:55:37 <ClaudiusMaximus> modify' f = get >>= \x -> put $! f x
07:55:45 <bartavelle> oh
07:55:46 <ClaudiusMaximus> or something like that
07:56:08 <cgaebel> @hoogle modify
07:56:08 <lambdabot> System.IO.Error modifyIOError :: (IOError -> IOError) -> IO a -> IO a
07:56:08 <lambdabot> Data.IORef modifyIORef :: IORef a -> (a -> a) -> IO ()
07:56:09 <lambdabot> Control.Concurrent.MVar modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
07:56:18 <atriq> @hackage unification-fd
07:56:19 <lambdabot> http://hackage.haskell.org/package/unification-fd
07:56:19 <cgaebel> where's this 'modify' that you're using?
07:56:23 <atriq> It's in there
07:56:26 <cgaebel> ah, I see.
07:56:41 <atriq> Just quickly hayoo'd it
07:56:51 <cgaebel> yeah, that has modify'
07:56:53 <bartavelle> ok, now the pure version takes 5.9us and the state version 1.28ms
07:56:55 <cgaebel> http://hackage.haskell.org/packages/archive/unification-fd/0.8.0/doc/html/Control-Monad-State-UnificationExtras.html
07:57:43 <cgaebel> yeah stateful code tends to be slower than pure code. I blame the optimizer.
07:58:10 * hackagebot process-iterio 0.0.0 - IterIO Process Library  http://hackage.haskell.org/package/process-iterio-0.0.0 (GregFitzgerald)
07:58:11 <bartavelle> this is not a theoritical concern, I am trying to write a non interactive game, and most of the logic is in a RWS that is in a stateT that is in an ErrorT
07:58:31 <bartavelle> I guess this will quickly turn ... slow
07:58:35 <atriq> Why the two states?
07:58:44 <cgaebel> yeah. monad transformers aren't free.
07:59:21 <bartavelle> atriq: I wrote a long question on pastebin but I suppose it is TL;DR
07:59:25 <bartavelle> lemme find it
07:59:33 <atriq> It's didn't see the link; dr
07:59:40 <bartavelle> yeah it was in the morning
08:00:33 <bartavelle> it is here http://pastebin.com/8J05tV93
08:00:36 <mauke> The paste 8J05tV93 has been copied to http://hpaste.org/77283
08:00:43 <osa1> so can anyone recommend me some logic texts that introduce higher-order vs. first-order distinction and topics related with type systems and type theory etc.
08:00:46 <bartavelle> (and easier to read on pastebin)
08:01:15 <Philippa> bartavelle: you might find it helps to abstract over how the monad is actually implemented? Then the worst case is a few tens of lines of new code anyway
08:01:29 <atriq> bartavelle, I would merge the two states
08:01:48 <Philippa> osa1: I can't, but Pierce's Types and Programming Languages is good and covers some of the things you're asking about
08:01:53 <atriq> Or get rid of the outer one
08:02:02 <bartavelle> I can merge the two states, even if it isn't very logical, but I can't see how to get aaway woth the errorT that is foldM'ed one block at a  time
08:02:03 <osa1> Philippa: I'm about to finish that one
08:02:19 <osa1> Philippa: but it doesn't answer questions about logics I have in mind
08:02:19 <bartavelle> Philippa, I do not understand your suggestion.
08:02:59 <Philippa> bartavelle: write wrapper functions that provide your error and state operations, work in terms of those wrapper functions only and newtype the transformer stack. Later on, you can change what's under the newtype freely
08:02:59 <t7> i should try to read TAPL again now i know more math
08:03:41 <bartavelle> Philippa, yes I more or less did this (contrary to what the snipper might show, I wrote a wrapper for CME.throwError NextListener)
08:04:02 <bartavelle> but my question goes deeper, I am not sure I am actually modelizing it the way it should be
08:04:07 <bartavelle> not even sure this is a monad
08:04:10 <bartavelle> well
08:04:13 <bartavelle> this should be a monad
08:04:22 <bartavelle> but I don't know anything else
08:04:24 <Philippa> it sounds like one?
08:04:37 <bartavelle> the part where I fold it block by block doesn't
08:04:50 <bartavelle> (the runListener snippet)
08:04:55 <atriq> I'm having trouble installing GHC 7.6.1, but it's with the configure script
08:05:59 <jaket> @pl flip (flip (boxPackStart vbox) PackGrow) 2 txtx
08:06:00 <lambdabot> boxPackStart vbox txtx PackGrow 2
08:06:07 <Philippa> bartavelle: so that's a little more 'operational' than many monad implementations? But there's nothing wrong with that
08:06:53 <jaket> @pl \txty -> boxPackStart vbox txty PackGrow 2
08:06:53 <lambdabot> flip (flip (boxPackStart vbox) PackGrow) 2
08:07:12 <bartavelle> well, let's roll with it then, thanks for the feedback
08:07:34 <bartavelle> I wondered if arrows were somehow superior for this task, as they seem to always be associated with event based processing (which I am doing)
08:07:44 <bartavelle> but I do not know much about them
08:08:23 <Philippa> I wouldn't worry about arrows specifically. It might be worth looking at comonads sometime? But that's a substantial change of style
08:09:05 <bartavelle> then I will just write code and try to achieve something instead of getting quagmired with such considerations ;)
08:10:56 <cgaebel> bartavelle: What I find works best for me is writing everything in IO, then abstracting things out as they come up.
08:11:31 <cgaebel> bartavelle: it lets you get feedback quickly, and refactoring with haskell's type system is pure joy compared to other languages.
08:12:23 <bartavelle> my thing should be entirely pure, so I went with a pure RWS
08:13:33 <ocharles> boo, standalone deriving has blown up with my GADT :( https://gist.github.com/1b9b0eed958a9cd4fcea -- any ideas what I'm doing wrong from this brief paste?
08:13:46 <ocharles> -ddump-deriv is a massive amount of data
08:14:26 <ocharles> I originally had Ref as a data family, but I don't think I need that so I was collapsing it into a single GADT
08:16:45 <ocharles> for some reason only Ord breaks it - it's quite happy to derive Eq and Show
08:23:30 <rwbarton> ocharles, looks like it is just not clever enough to write a correct derived Ord instance
08:24:40 <rwbarton> it ought to drop all the impossible cases where it is comparing two constructors with incompatible return types
08:25:07 <ocharles> like compare (Ref Country) (Ref Artist) ?
08:25:24 <rwbarton> more like compare (CountryRef _) (ArtistRef _)
08:25:29 <ocharles> right
08:26:00 <ocharles> would this be something I should report as GHC bug?
08:26:23 <ocharles> or maybe I should bring it up on the cafe first
08:27:00 <rwbarton> definitely seems like at least a wishlist item
08:28:42 <ocharles> ghc still complains about various missing patterns if I write ord myself too
08:28:56 <ocharles> such as '(ArtistCreditRef _) (ArtistRef _)'
08:29:12 <rwbarton> yes it can be a bit dense
08:29:24 <ocharles> so should I just plug that leak with a horrible 'error "Impossible!"'
08:29:28 <rwbarton> sure
08:29:43 <rwbarton> i thought it wasn't supposed to do that though
08:29:49 <rwbarton> that one seems like more of a bug
08:29:56 <rwbarton> this is what the ghc manual has to say about StandaloneDeriving
08:30:02 <rwbarton> Unlike a deriving declaration attached to a data declaration, GHC does not restrict the form of the data type. Instead, GHC simply generates the appropriate boilerplate code for the specified class, and typechecks it. If there is a type error, it is your problem. (GHC will show you the offending code if it has a type error.)
08:32:42 <ocharles> ok, I'll try and write something more minimal and report it
08:34:25 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/3927 for your second issue
08:34:55 <ocharles> aha
08:42:23 <drostie> Maybe ##cs is a better venue for this question because I'm not married to Haskell for this project, but what would the proper data structure be for a list which accepts inserts at any point inside of it? a self-balancing BST or so?
08:46:08 <monochrom> that works. also consider Data.Sequence
08:47:14 <drostie> monochrom: thanks. :D didn't know that Haskell had fingertrees. ^_^
08:48:06 <josephle> exit
08:48:09 <josephle> oops
08:48:49 <typoclass> drostie: i'm going to recommend what i always recommend ... try the simplest thing that could possibly work :-) use a plain old list. if measurements show it's getting too large and too slow, you can still switch to the complicated data structures
08:49:00 <ppremont> pl \x y -> compare (f x) (f y)
08:49:05 <ppremont> @pl \x y -> compare (f x) (f y)
08:49:06 <lambdabot> (. f) . compare . f
08:49:12 <dmwit> :t comparing
08:49:14 <lambdabot> Ord a => (b -> a) -> b -> b -> Ordering
08:49:18 <dmwit> :t on compare
08:49:19 <lambdabot> Ord b => (a -> b) -> a -> a -> Ordering
08:50:55 <drostie> typoclass: in principle that is what I will end up doing, but the question is slightly more interesting because it enters into a question opened a while back in the Darcs mailing list: is there a purely factive description of a set of revisions rather than a procedural description?
08:51:41 <typoclass> drostie: hmm interesting
08:51:51 <drostie> typoclass: basically there is a Here There Be Dragons moment where a researcher got factive inserts on lists by using sets of (rational number, object).
08:52:51 <ppremont> Hmm, there is a slight error in http://www.haskell.org/haskellwiki/Pointfree, the output for "pl \x y -> compare (f x) (f y)" lacks the first call to f
08:53:32 <drostie> And the reason there be dragons is because if you record the fact "set contains (1/3, x)" to get x between (0, y) and (1, z), and someone else records the fact (1/2, x'), then there is an ordering between x and x' when there shouldn't be.
08:54:12 <plotr> bos: ping :)
08:54:28 <drostie> (i.e. if you go to merge the two the system should say "merge conflict.")
08:55:19 <drostie> But if there's a functional way to do it in log(n) facts then that's acceptable if weird. ^_^
08:55:48 <Gurragchaa> are _|_ and Nothing the same idea?
08:56:06 <mapreduce> :t error
08:56:07 <geekosaur> no
08:56:08 <lambdabot> [Char] -> a
08:57:19 <geekosaur> _|_ is the nonterminating computation.  this nontermination may be an infinite loop, or an exception, or some other failure to produce a result; you cannot, in general, test for it.
08:57:22 <mapreduce> Nothing is an empty Just, like [] is an empty list.  _|_ is a failure to terminate (infinite loop or a crash)
09:02:32 <typoclass> Gurragchaa: Nothing is a normal haskell value that is used in normal haskell programs. _|_ is more theoretical. it's used when talking about programs and describing functions. it's not (as far as i know) a symbol in haskell that your program could use
09:03:24 <Gurragchaa> ok, thanks everyone
09:03:51 <hiptobecubic> there's undefined
09:04:22 <hiptobecubic> and all of the other million ways i've (accidentally) written bottom
09:04:30 <geekosaur> undefined or (as mentioned earlier) error
09:04:31 <quicksilver> let x = x in x
09:04:52 <quicksilver> last [0..]
09:04:59 <hiptobecubic> for exmaple
09:05:18 <typoclass> yup. however, Nothing is not one of them
09:06:56 <hiptobecubic> > forever Nothing
09:06:58 <lambdabot>   Nothing
09:07:05 <monochrom> ⊥ is not first-class
09:07:09 <hiptobecubic> lambdabot, we need to talk about "forever"
09:07:36 <rwbarton> Nothing is forever Nothing
09:07:49 <hiptobecubic> > forever $ Just Nothing
09:07:53 <lambdabot>   mueval-core: Time limit exceeded
09:07:53 <djcoin> I'm trying to compute a list where each elem will be the sum of elements seen so far. Yet it does not work with infinit list, one of my try:" foldl' (\acc x -> x + head(acc) : acc) [0] [1..] ". If anybody can bring some lights on this, thanks !
09:08:21 <hiptobecubic> rwbarton, apparently so.
09:08:32 <dmwit> foldl (and foldl') can't produce things lazily. Use foldr.
09:08:39 <hiptobecubic> djcoin, scanr?
09:08:39 <dmwit> See also the wiki page on foldr and foldl.
09:08:50 <dmwit> And, if this is not just an exercise, use scanl.
09:09:07 <hiptobecubic> yes, scanl sorry
09:09:07 <dmwit> hiptobecubic: scanr doesn't (can't) work for infinite lists, for the same reason foldl (foldl') can't. =)
09:09:09 <djcoin> dwierenga: foldl' can produce lazy thing no ? I misread maybe
09:09:20 <djcoin> hiptobecubic: dmwit ok thanks
09:09:39 <djcoin> dmwit: ^ (sorry I ping the wrong buddy :s)
09:10:15 <rwbarton> foldl' cannot consume an infinite list
09:11:51 <notdan> What's the perered way to generate Node id's (Ints) from the Strings?
09:12:00 <notdan> I tried using a hashing function but it overflows
09:13:19 <cgaebel> for each string, insert it into a HashMap String Int
09:13:33 <cgaebel> where the thing it maps to is increasing integers for every string in your graph
09:13:54 <ClaudiusMaximus> notdan: fgl? i tend to build a   Map String Int  inserting each new element with Map.size
09:13:57 <cgaebel> use a state monad, or manually pass the accumulator. up to you.
09:14:46 <notdan> Hm, maybe I should rethink my whole algorithm
09:17:21 <JavaSucksMan_> How can I check a data invariant, for example, data PythagoreanTriple Integer Integer Integer, but call error on the expression: PythagoreanTriple 3 4 6
09:18:03 <dmwit> JavaSucksMan_: Stick it in a module where you don't export PythagoreanTriple, but do export pythagoreanTriple :: Integer -> Integer -> Integer -> Maybe PythagoreanTriple.
09:18:10 <dmwit> (and whatever other operations you need on triples)
09:18:38 <notdan> http://hpaste.org/77288 I am trying to generate a class dependency graph, but the thing is, I don't know the order of the classes in my list, so I might as well process A before I process B, while A inherits B
09:18:49 <JavaSucksMan_> so hiding PythagoreanTriple hides the constructor, but not the type?
09:18:58 <quicksilver> right.
09:18:58 <notdan> And in order to add the edge A->B to the graph I need to know the id of the node B
09:19:04 <quicksilver> if you do it carefully :)
09:19:07 <dmwit> JavaSucksMan_: You can hide them independently.
09:19:10 <quicksilver> the constructor and type are separate things.
09:19:15 <quicksilver> even if they have the same name.
09:19:27 <JavaSucksMan_> how does hiding no which namespace you are talking about?
09:19:35 <quicksilver> dmwit: what is the syntax for exposing the constructor but hiding the type?
09:19:55 <dmwit> uh
09:19:56 <int-e> JavaSucksMan_: you can use Foo (Type ()) to export the type but not its constructors.
09:20:00 <int-e> quicksilver: does that make sense?
09:20:06 <dmwit> I am wrong.
09:20:17 <quicksilver> int-e: I think not. I was utilising the socratic method.
09:20:30 <int-e> quicksilver: how very didactic.
09:20:39 <quicksilver> it might merely have been rude, actually
09:20:43 <quicksilver> but I think dmwit will forgive me.
09:21:02 * dmwit is used to being wrong, and doesn't even feel that an apology is needed
09:21:13 <JavaSucksMan_> int-e: I think it makes sense
09:22:38 <dmwit> It's certainly possible to export things whose type you can't refer to outside that module. Whether it makes sense is a much deeper question than I care to tackle.
09:23:05 <int-e> Naa, it prevents the user from writing type signatures for some functions that he or she can write. That can't be good.
09:23:14 <JavaSucksMan_> what about exposing type, but hiding constructor?
09:23:25 <int-e> that makes much more sense to me.
09:23:27 <quicksilver> JavaSucksMan_: that way round makes a lot of sense.
09:23:31 <quicksilver> it's quite a common idiom.
09:23:33 <dmwit> JavaSucksMan_: That is the easy direction, yes, and definitely makes sense.
09:23:44 <int-e> in fact it's data encapsulation, generally considered to be a good thing in software engineering.
09:23:45 <JavaSucksMan_> whats the syntax, again?
09:24:10 <Guest66784> @pl (\ x -> x + x)
09:24:10 <lambdabot> join (+)
09:24:15 <JavaSucksMan_> yeah, I come from OO where it's pretty big... trying to learn haskell
09:24:45 <Guest66784> @pl (\ x -> x + x)
09:24:46 <lambdabot> join (+)
09:24:53 <ion> (*2)
09:25:15 <Guest66784> @pl (nx -> 4 * x) $ (ny -> 3 + y) 1
09:25:16 <lambdabot> (line 1, column 7):
09:25:16 <lambdabot> unexpected '>'
09:25:16 <lambdabot> expecting operator
09:25:36 <dmwit> JavaSucksMan_: The syntax for exporting types looks like TypeName(ConstructorName, ConstructorName2, Constructor3) or TypeName(..), so you can export a type without any of its constructors with TypeName or TypeName().
09:25:45 <Guest66784> @pl (\x -> 4 * x) $ (\y -> 3 + y) 1
09:25:45 <lambdabot> 16
09:26:30 <int-e> concepts are not automatically tainted just because they also appear in an OO context :-)
09:26:49 <JavaSucksMan_> them's fightin' words
09:27:07 <quicksilver> int-e: it's more like they're out on parole with very strict conditions?
09:27:20 <JavaSucksMan_> I <heart> mutable state
09:27:33 <int-e> quicksilver: I think data ... well, we say abstraction, I think ... is well established in Haskell :)
09:27:42 <tac> An abstract type is a good type.
09:27:48 <ciaranm> http://steve-yegge.blogspot.co.uk/2006/03/execution-in-kingdom-of-nouns.html etc
09:28:00 <ciaranm> also http://static.springsource.org/spring/docs/2.5.x/api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html
09:28:11 <monochrom> JavaSucksMan_: module MyModule (Typename, function) where data Typename = Ctor Int; function n = Ctor n
09:28:17 <Guest66784> @pl (\x -> 4 + x + (\x -> 3 + x) 3) 1
09:28:18 <lambdabot> 11
09:28:54 <int-e> ciaranm: Well, we have a ReaderWriterState(Monad)Transformer, only we call it RWST.
09:29:11 <djcoin> hiptobecubic: sorry to bother again, I'm trying to make a basic use of scanr (same goal: partial sum result), but it still hang on infinite list, here is my try: take 1 $ scanr (\x acc -> x + acc) 0 [1..]
09:29:24 <ion> http://svn.codehaus.org/grails-plugins/grails-searchable/branches/0_5_5_1/src/java/org/codehaus/groovy/grails/plugins/searchable/compass/config/mapping/SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator.java public class SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator implements SearchableGrailsDomainClassMappingConfigurator, Ordered {
09:29:38 <dmwit> djcoin: As we mentioned: you must use scanl, not scanr.
09:29:56 <djcoin> dmwit: damn, sorrryy
09:30:13 <djcoin> dmwit: ok it works =)
09:30:16 <djcoin> Thanks
09:31:10 <dmwit> Ordered, pfft
09:31:41 <monochrom> hiding the type name is allowed but strange, if you export a value whose type sig mentions that type
09:31:48 <Guest66784> @pl (\f -> f (f 2)) (*3)
09:31:49 <lambdabot> 18
09:31:56 <dmwit> more like TransitiveAntisymmetricTotalLattice, amirite?
09:32:37 <monochrom> > scanl (+) 0 [a, b, c]
09:32:39 <lambdabot>   [0,0 + a,0 + a + b,0 + a + b + c]
09:32:46 <dmwit> monochrom: The specific question is whether it's possible to export a *constructor* without exporting its type.
09:33:02 <tac> it shouldn't be
09:33:06 <dmwit> s/its/the type it's for/
09:33:07 <tac> The constructor references the type
09:33:16 <monochrom> IIRC not possible
09:33:35 <tac> It it were possible, I'd fear for our lives
09:34:01 <dmwit> tac: ...why?
09:34:04 <monochrom> tested, not possible
09:34:23 <monochrom> but I don't mind either way
09:34:29 <dmwit> Nothing goes wrong if you allow it, there's just no syntax for it is all.
09:34:33 <quicksilver> quite
09:34:38 <tac> dmwit: What would a constructor's type be if you couldn't see the datatype it belongs to?
09:34:44 <Guest66784> @pl (\x f -> x + f x ) 5 (*3)
09:34:44 <lambdabot> 20
09:34:47 <quicksilver> you can export a custom constructor and custom deconstructor.
09:34:50 <dmwit> tac: It would have a type that you couldn't write down. So?
09:34:56 <quicksilver> tac: it has the same type, you just can't write it
09:34:59 <edwardk> dmwit: you can;t. you can export a 'smart constructor' and/or a view, lens or traversal though
09:35:01 <dmwit> tac: It's already possible to export values whose type you can't write down.
09:35:09 * dmwit sighs at edwardk
09:35:28 <monochrom> as it is, you can already export other values without exporting the relevant types. ctors are just more values
09:35:29 <tac> dmwit: Is it now?
09:35:33 * tac fears for his life
09:35:50 <atriq> Data.Reflection?
09:36:17 <monochrom> module Strange(f) where data T = Ctor; f = Ctor
09:36:26 <tac> When would you ever want to have a situation where a type is hidden, but some value has a type referencing it?
09:36:38 <dmwit> I don't know that you would.
09:36:41 <edwardk> tac: Data.Constraint.Forall
09:37:06 <edwardk> http://hackage.haskell.org/packages/archive/constraints/0.3.2/doc/html/Data-Constraint-Forall.html
09:37:28 <edwardk> "A", "B", "F" and "M" are not exported by that module and it is key to their soundness
09:37:44 <monochrom> I look at it this way. there is much waste in adding more rules such as "if you export f, then you must export T"
09:38:01 <yitz> import qualified Org.Codehaus.Groovy.Grails.Plugins.Searchable.Compass.Config.Mapping.SearchableClassPropertySearchableGrailsDomainClassMappingConfigurator as O.C.G.G.P.S.C.C.M.SCPSGDCNC
09:38:15 <tac> edwardk: is it not sufficient to export them abstractly? (without exposing ctors?)
09:38:23 <edwardk> monochrom: especially since it may be a type synonym, etc.
09:39:01 <edwardk> tac: correct. they are only used at the type level. you cannot be allowed to write types involving them explicitly. the way they are used is such that if you have an instance for them it must be universally quantified because you can't name them
09:39:07 <ciaranm> i'm not sure which is worse... those java names, or operators like <???>
09:39:26 <tac> ah
09:39:26 <notdan> Sorry for a stupid question, but why can't I just putStr a Text value?
09:39:30 <tac> well there's your problem :P
09:39:35 <tac> type-level evaluation
09:39:39 <notdan> Data.Text provides that function
09:39:52 <dmwit> tac: Here's another use case: suppose you want to export a type from Data.ByteString and a function from Prelude.Dmwit that has ByteString in its type. You don't want to force Prelude.Dmwit to also export the ByteString type.
09:39:54 <edwardk> erm. i welcome your solution that doesn't use these ;)
09:39:55 <yitz> @type putStr -- notdan
09:39:57 <lambdabot> String -> IO ()
09:39:58 <monochrom> if you add that rule, soon you'll find yourself needing a more complicated rule. then you get c++, perl, php
09:40:12 <atriq> notdan, try using Data.Text.IO.putStr
09:40:43 <monochrom> consider: module Strange(g) where data T = Ctor Int; g :: Int -> T; ...
09:40:55 <dmwit> tac: (...and this use case has the advantage of not relying on the premise "I want to do crazy type-level hackery".)
09:41:02 <monochrom> because you export g, the rule says you must export Int and T
09:41:02 <tac> Would it make sense, theoretically speaking, to make A B C, etc in Forall to have an abstract *kind*?
09:41:06 <notdan> Right, thanks atriq
09:41:11 <notdan> and thamnks yitz
09:41:14 <yitz> notdan: you can say import qualified Data.Text.IO as TIO and then use TIO.putStr. Or something like that.
09:41:25 <ciaranm> i feel i'm missing out by not having done any crazy type level hackery yet
09:41:25 <monochrom> but wait, you will say that Int should be exempted
09:41:53 <tac> dmwit: indeed. Although, it seems like an artifact of Haskell's module system to me.
09:42:08 <dmwit> tac: Kind polymorphism would still allow you to declare a class instance for a type of abstract kind.
09:42:27 <monochrom> so now you have a rule that says "if you export a value, you must export the mentioned types, except for such and such types because of reason 1, but wait, for those types under reason 1, you still must export some of them because of reason 2, etc etc"
09:43:13 <monochrom> whenever you desire a rule but you find the need to pile up exceptions on it, even just one exception, that's a sign that you shouldn't bother in the first place
09:44:19 <dmwit> edwardk: That's a very strange module.
09:44:23 <monochrom> it is exactly why you like haskell more than you like python
09:44:31 <dmwit> edwardk: I guess you need (p A, p B) instead of just (p A) to deal with equality constraints?
09:45:37 <monochrom> python etc go like "we add more restrictions and exemptions because who would sanely disobey anyway?"
09:46:09 <monochrom> haskell goes like "we don't add this restriction because it's too complicated"
09:46:09 <ciaranm> honestly monochrom, next you'll be claiming it should make sense to divide by zero
09:46:15 <Jafet> I thought python was like "we don't really care to implement this"
09:46:20 <Jafet> > gcd 0 0
09:46:22 <lambdabot>   0
09:47:07 <monochrom> no, I don't claim that it "makes sense". be careful
09:47:34 <monochrom> haskell certainly does not syntactically forbid 1/0
09:47:43 <ciaranm> clearly 1 / 0 should be a type error
09:47:46 <tac> The problem Haskell has is no discretion when it comes to language complexity :)
09:48:14 <tac> Also, Haskell's type system is full of lies!
09:48:15 <dmwit> You are free to strictly adhere to Haskell 2010 if you like. It's a pretty simple language.
09:48:34 <tac> dmwit: Contravariance vs covariance.
09:48:45 <dmwit> The compiler will even check if you're adhering, so it's not just a discipline thing.
09:48:50 <dmwit> tac: sorry, what?
09:49:11 <tac> Because other people have the *freedom* not to stick to Haskell 2010, I have the *responsibility* to know much more than it :)
09:49:29 * dmwit nods agreeably
09:49:49 <tac> If Haskell has any great flaw, it's solely that.
09:50:06 <edwardk> dmwit: MPTCs with fundeps/equality constraints can see through a single choice, yes.
09:50:32 <tac> For example, I have no actual clue what constraint kinds are or what they're useful for.
09:50:32 <dmwit> pretty sneaky
09:50:38 <beaky> does Haskell have namespaces?
09:50:42 <edwardk> :k Eq
09:50:42 <monochrom> also,
09:50:43 <lambdabot> * -> Constraint
09:50:43 <ciaranm> also that i have to start every source file with {-# language TupleSections, NoMonomorphismRestriction, DerivingFunctor #-}
09:50:47 <ciaranm> clearly that should be fixed
09:50:48 <monochrom> > 1/0 :: Double
09:50:48 <edwardk> that is a constraint
09:50:50 <lambdabot>   Infinity
09:50:51 <edwardk> :k Monad
09:50:53 <Jafet> tac: C++ has this flaw too, it can't be that great
09:50:53 <lambdabot> (* -> *) -> Constraint
09:50:54 <tac> beaky: qualified import your modules, and yes.
09:50:56 <monochrom> is allowed at runtime
09:50:58 <edwardk> :k []
09:50:59 <beaky> ah
09:51:00 <lambdabot> * -> *
09:51:09 <edwardk> :k Monad []
09:51:09 <tac> Jafet: C++ is bad for that reason too :)
09:51:10 <lambdabot> Top level:
09:51:10 <lambdabot>     Illegal tuple constraint Monad []
09:51:10 <lambdabot>     (Use -XConstraintKinds to permit this)
09:51:19 <edwardk> bah
09:51:22 <beaky> what is the difference beween `import qualified My.Module as M` and `import My.Module as M` ?
09:51:27 <edwardk> that should say Constraint =)
09:51:44 <johnw> beaky: the latter still imports the functions into the global namespace
09:51:50 <beaky> ah
09:51:54 <johnw> beaky: it just also gives you an alias for directly qualifying the name
09:52:15 <monochrom> suppose My.Module contains value v. if you have "qualified", you can only use "M.v". if you don't have "qualified", then you can use both "v" and "M.v"
09:52:16 <beaky> I like using qualified, it makes my code look as enterprisey as Java :D
09:52:16 <edwardk> tac: making the type system contain "Constraint" directly as a kind greatly simplifies writing a haskell compiler.
09:52:18 <Jafet> ciaranm: alias ghc=...
09:52:34 <edwardk> tac: it also makes it possible to write some code generically that was impossible before
09:52:35 <dmwit> beaky: "as M" changes the qualified name; "qualified" removes the unqualified name
09:52:38 <tac> edwardk: Are they related to ~ in SystemFc?
09:52:57 <johnw> beaky: sometimes I'll do something like: import qualified Data.Text as T; import Data.Text (Text), that way I only have to qualify the functions, not the type
09:52:57 <monochrom> see my http://www.vex.net/~trebla/haskell/module.xhtml for the full story
09:53:00 <edwardk> tac: thats a type equality constraint. you can have constraint kinds without them (we do here)
09:53:00 <dmwit> tac: A bit; ~ is one Constraint constructor.
09:53:11 <beaky> johnw: ah thats a nice idiom
09:53:12 <tac> hm
09:53:25 <edwardk> Anything that goes on the left of an =>  is a constraint.
09:53:28 <beaky> makes the type signatures clean :D
09:53:43 <Eduard_Munteanu> I think ~ was introduced by type families.
09:54:12 <edwardk> :t (+)
09:54:13 <lambdabot> Num a => a -> a -> a
09:54:23 <beaky> I like type classes
09:54:25 <edwardk> Num a is a type of kind "Constraint"
09:54:31 * tac throws his hands up and does all his work in Idris from now on
09:54:32 <tac> :P
09:54:34 <atriq> Eduard_Munteanu, it's useful with MultiParamTypeClasses
09:54:43 <edwardk> tac: i'm sure that'll make your life easier ;)
09:54:45 <atriq> tac, Haskell is a living language
09:54:54 <tac> edwardk: ;)
09:55:14 <tac> atriq: yes. It's a dynamic language with a static type system.
09:55:37 <Eduard_Munteanu> Well, IDK, Haskell does look kinda messy compared to say, Agda, when it comes to advanced features.
09:55:47 <tac> edwardk: so do constraints just turn Num a => into a regular parameter or something like that?
09:56:12 <beaky> I like C++
09:56:31 <johnw> beaky: watch out, lambdabot may just kick you
09:56:49 <beaky> s/C++/Haskell/ :D
09:56:58 <Eduard_Munteanu> @protontorpedo
09:56:58 <lambdabot> so haskell is free?
09:57:05 <ciaranm> haskell is cofree
09:57:08 <bitonic``> Eduard_Munteanu: you mean GHC
09:57:10 <edwardk> tac: no, it just means that when you look at something like Monad []    that type has a kind. this means that the signature of a class looks like class foo => bar   and instance foo => bar   where foo and bar are valid types of kind Constraint instead of some other adhoc thing.
09:57:39 <edwardk> tac: having 'Constraint' directly usable as a kind means you can make type aliases for things like typeclasses too
09:57:40 <Eduard_Munteanu> bitonic``: yeah, Glasgow Haskell.
09:57:50 <tac> hmm
09:57:51 <edwardk> type BetterMonad m = (Monad m, Applicative m)
09:57:57 <Jafet> Glorious Glasgow Haskell
09:58:22 <bitonic> Eduard_Munteanu: to be honest now the System F used by GHC is pretty clean, the interface is kinda messy
09:58:22 <ciaranm> because microsoft bought out all glasgow's programming languages group
09:58:23 <edwardk> foo :: BetterMonad m => m a -> m b -> m (a, b)
09:58:28 <tac> type BestMonad m = (Functor m, ObeysMonadLaws m)
09:58:45 <thoughtpolice> you can reify all constraints and make them 'parameters' by using a constraint-based dictionary, but i think i've mostly used them for type aliases :)
09:59:05 <atriq> tac, try to write ObeysMonadLaws
09:59:18 <edwardk> tac: but it also lets you do things like   data Dict p where Dict :: p => Dict p     -- note p is a type variable of kind Constraint.
09:59:18 <atriq> Hint: it can't be done
09:59:28 <atriq> YET
09:59:31 <Eduard_Munteanu> bitonic: well, I was talking about all those extensions which bring in Agda-ish stuff
09:59:39 <edwardk> the constraint package is all about manipulating those kinds of 'Dict' values.
09:59:50 <Eduard_Munteanu> They look like a hack or an afterthought.
09:59:57 <edwardk> newtype a :- b = Sub (a => Dict b)
10:00:01 <johnw> hrmph, Idris is eagerly evaluated, that greatly diminishes my interest
10:00:07 <bitonic> Eduard_Munteanu: well I would say that the agda-ish stuff is just DataKinds, PolyKinds, and ConstraintKinds
10:00:12 <tac> atriq: it can be done plenty fine. Just not in Haskell :P
10:00:12 <bitonic> and GADTs
10:00:14 <edwardk> is an assertion that given a dictionary for 'a' you can derive a dictionary for 'b'
10:00:29 <Eduard_Munteanu> bitonic: yeah, maybe type-level nats too
10:00:35 <edwardk> e.g.   Ord a :- Eq a      follows from the fact that you have class Eq a => Ord a
10:00:39 <tac> johnw: Why's that?
10:00:43 <thoughtpolice> yeah, Dict also gives rise to the kind 'Constraint -> *', whereas the inverse is i guess just the kind of any class, i.e. Ord has the kind * -> Constraint
10:00:53 <johnw> tac: because lazy eval is one of my favorite things about Haskell
10:00:56 <thoughtpolice> i don't know if there's any kind of formalism there, but i'm sure edwardk does :P
10:00:56 <edwardk> Ord a :- Ord [a]  follows from the fact that you have instance Ord a => Ord [a]
10:01:11 <bitonic> Eduard_Munteanu: right, but I think that most of the cruft is elsewhere, but yes there's some overlap even between those extensions.  but that's OK, I guess research has to be organic
10:01:17 <tac> johnw: it's got some early support for lazy data types.
10:01:37 <edwardk> thoughtpolice: well, without the constraint kind you always had to deal with each such GADT that captures a constraint as a one-off hack
10:01:47 <edwardk> with constraint kinds you can write Dict once and for all.
10:01:49 <thoughtpolice> edwardk: right, Dict is the one to rule them all
10:02:41 <Eduard_Munteanu> bitonic: it's just they look outlandish in Haskell, more like a tumor than an internal organ :). In Agda, stuff like that looks a lot more natural.
10:02:43 <thoughtpolice> i was more wondering about if there was anything deeper relation to Dict's kind as opposed to the one of a regular class
10:03:33 <edwardk> tac: its just that while the same programs will terminate in a dependently typed language that is by-need or strict (with termination checking) the by-need one may finish in my lifetime, while the other may not ;)
10:03:50 <edwardk> tac: iirc there is a similar issue with the javascript back end for agda
10:03:51 <thoughtpolice> since they either yield regular kind * given a constraint, or a constraint given some kind, so there's just a bit of inverseness there
10:04:04 <JavaSucksMan_> what is ":-" in "Ord a :- Eq a" mean?
10:04:23 <edwardk> JavaSucksMan_: newtype a :- b = Sub (a => Dict b)
10:04:33 <edwardk> it says that a 'entails' b
10:04:57 <dmwit> edwardk: calibration point for your explanations: JavaSucksMan_ is still learning the syntax of Haskell
10:05:05 <bitonic> Eduard_Munteanu: they do, I agree.
10:05:06 <edwardk> you can write ordEq :: Ord a :- Eq a; ordEq = Sub Dict    -- and the compiler just proves it as it goes
10:05:09 <edwardk> dmwit: fair enough =)
10:05:11 <tac> edwardk: I'd like to see evaluation strategy decoupled from the compiler in total languages.
10:05:14 <JavaSucksMan_> is :- GHC syntax?
10:05:23 <edwardk> JavaSucksMan_: no its something i built in a library
10:05:24 <tac> edwardk: it seems like a good thing for a JIT to take care of.
10:05:30 <bitonic> Eduard_Munteanu: Haskell is still beautiful and I think it's pretty "complete", if you add ScopedTypeVariables by default
10:06:17 <dmwit> tac: Well, Coq doesn't have a compiler, but it does allow you some control over evaluation strategy during proofs.
10:06:31 <dmwit> Or is that not what you meant?
10:06:34 <osa1> if we think Haskell's type system as a programming language, what would be some properties of that language ? for instance, can we say that programs written in that language always terminates ? (I'm also considering type-system extensions like FunDeps, TypeFamilies, GADTs, UndecidableXs etc.)
10:06:41 <Eduard_Munteanu> It doesn't? I thought it did program extraction.
10:06:52 <tac> dmwit: I mean, for something more like Idris, where the goal is to actually execute the program...
10:07:01 <dmwit> osa1: UndecidableInstances = may not terminate (it's what undecidable means)
10:07:10 <tac> choosing between lazy and strict evaluation is something that is well-suited for a Just-In-Time compiler as part of the VM
10:07:30 <tac> You can profile your code as you run it, and it can freely choose whatever it finds at runtime is more efficient: lazy or strict
10:07:46 <JavaSucksMan_> so ':-' is some kind of type-level function?
10:07:57 <dmwit> JavaSucksMan_: It's a type constructor, yes.
10:08:03 <osa1> dmwit: hmm, when it's disabled, can we say that it always terminates ?
10:08:04 <JavaSucksMan_> like '->'
10:08:20 <dmwit> JavaSucksMan_: Compare "data Foo a b = Bar a | Baz b" with "data a :- b = Bar a | Baz b".
10:08:49 <dmwit> osa1: yes
10:09:01 <JavaSucksMan_> Now it looks like an infix Either?
10:09:04 <tac> dmwit: and as a PR bonus, if people come to the language and say "I heard lazy evaluation causes space leaks", you can tell them "well, you can turn laziness off if you want"
10:09:04 <dmwit> It's very nearly the simply-typed lambda calculus.
10:09:32 <osa1> dmwit: what about turing completeness ? how can we test that ?
10:09:46 <dmwit> osa1: always terminates => not Turing complete
10:09:47 <efie> rwbarton: using Data.ByteString.Lex.Double worked! thanks =)
10:10:40 <dmwit> JavaSucksMan_: In that example, yes. Not in edwardk's library, though.
10:11:05 <osa1> dmwit: but I read somewhere that we can express recursion (or maybe it was actually `structural recursion` but I don't know the differences), don't we have non-terminating programs with existance of recursion ?
10:11:40 <tac> general recursion = turing complete = recurse on whatever values you want.
10:11:44 <dmwit> There are many kinds of recursion. Not all of them can produce non-terminating programs.
10:12:05 <tac> structural recursion = not turing complete, but pretty damn useful = recurse on only values "smaller" than the input (sublists or predecessors)
10:12:15 <beaky> I use recursion everywhere I can
10:12:54 <JavaSucksMan_> like recursion in factorial vs. recursion in collatz
10:12:57 <osa1> tac: great, I didn't know that. but how can we test if the value we recurse on is "smaller" ?
10:13:17 <johnw> baeky: see this message for further information
10:13:19 <c_wraith> osa1: it's not a test. it's structural. It must be smaller, due to the nature of the recursion
10:13:34 <lispy> hello
10:13:41 <johnw> lispy: hello!
10:13:43 <tac> osa1: easy. If I have a list x : xs, xs is "smaller" than x : xs
10:13:58 <tac> osa1: If I have a natural number S n, then n is "smaller" than S n
10:14:10 <c_wraith> it's actually strictly smaller if you're using inductive datatypes, too.
10:14:10 <Philippa> osa1: one way of doing it is insisting that it must only be built from /components/ of the input, without adding a new constructor on top
10:14:19 <johnw> tac: you're talking about successors sets, yes?
10:14:28 <tac> If I have a tree, Branch [t1, t2, t3, t4, t5], then all of t1 t2 t3 t4 and t4 are smaller than the whole thing.
10:14:30 <c_wraith> haskell gives coinductive data types, though, so it's not actually strictly true
10:14:33 <osa1> Philippa: does that how haskell's structural recursion on type level work ?
10:14:46 <Philippa> ...Haskell does structural recursion?...
10:14:46 <tac> johnw: maybe it's related, but I don't know the term
10:15:12 <Philippa> (but it's part of how the instance selection mechanism decides an instance isn't going to make it stop terminating, yes)
10:16:03 <dmwit> (type families also have such checks)
10:16:52 <Igor_K> hi there
10:17:04 <tac> hi
10:17:29 <tac> osa1: Food for thought. All structurally recursive functions on lists can be written with foldr.
10:18:04 <osa1> tac: thanks
10:18:40 <Igor_K> i would like to ask question about functional programming in general. Is here a proper channel for that
10:18:46 <tac> Igor_K: ask away
10:24:03 <Saizan> Igor_K: it might be
10:24:31 <dmwit> better to ask forgiveness than permission anyway.
10:25:01 <Tekmo> I think you will get a good answer if you ask it here
10:32:45 <c_wraith> hmm.  Containers 0.5 deprecated a function I was using.  And also broke it.
10:33:18 * Eduard_Munteanu suspects "ask *away*" might've been misinterpreted
10:34:02 <cgaebel> It is quite vague.
10:35:08 <osa1> We enable the GHC
10:35:09 <osa1> option -fundecidable-instances [3] to allow general recursion at the type-level
10:35:11 <copumpkin> c_wraith: which?
10:35:20 <copumpkin> osa1: that's really old-school
10:35:33 <osa1> copumpkin: ?
10:35:34 <copumpkin> {-# LANGUAGE UndecidableInstances #-} at the top of your file is the preferred approach no
10:35:35 <copumpkin> now
10:35:42 <copumpkin> or -XUndecidableInstances on the command-line
10:35:59 <c_wraith> copumpkin: insertWith'
10:36:01 <osa1> I pasted this here because of previous discussion on structural recursion on type level
10:36:07 <osa1> I just read that in a paper
10:36:19 <c_wraith> copumpkin: it made it more strict than it used to be, and I was depending on the exact level of strictness it had.
10:36:20 <copumpkin> yeah, just saying that that approach is deprecated
10:36:37 <copumpkin> c_wraith: ezyang probably knows best about that stuff, maybe he can give suggestions
10:36:39 <c_wraith> copumpkin: fortunately, it looks like I can use the strict version of adjust instead
10:36:43 <dmwit> In #haskell, old-school means "more than a year old".
10:36:51 <c_wraith> copumpkin: unfortunately, that means I'll need CPP :(
10:37:23 <c_wraith> anyone recall offhand what the CPP macro to test for GHC 7.6 or higher is?
10:37:36 <osa1> so can anyone explain me why Haskell's type system is still not turing-complete, even with UndecidableInstances ?
10:37:45 <dmwit> Nobody claimed that.
10:37:50 <Tekmo> I thought it was
10:38:04 <c_wraith> osa1: the type system is turing complete with UndecideableInstances and either FunctionalDependencies or TypeFamilies
10:39:00 <ezyang> c_wraith: What's your problem?
10:39:30 <c_wraith> ezyang: mapWith' changed strictness, causing it to blow up on an undefined I was passing in when I knew it wouldn't be used
10:39:56 <c_wraith> ezyang: on the plus side, I can stop using that hack due to Data.Map.Strict's implementation of adjust
10:40:13 <ezyang> Are you using the Strict or Lazy Data.Map?
10:40:14 <c_wraith> ezyang: on the minus side, that means I need to CPP-ize this file
10:40:29 <c_wraith> ezyang: neither. The library predates that split
10:41:47 <ezyang> Wait, we had a mapWith'?
10:41:59 <cgaebel> c_wraith: #if __GLASGOW_HASKELL__ >= 706
10:42:00 <ezyang> I'm pretty sure there should have been no behavioral changes.
10:42:00 <c_wraith> ah, looks like I want #if __GLASGOW_HASKELL__ >= 706
10:42:05 <cgaebel> lol
10:42:06 <c_wraith> cgaebel: thanks. :)
10:42:12 <cgaebel> haha np
10:42:15 <nand`> mapWith?
10:42:44 <c_wraith> ezyang: well, the code certainly blows up on GHC 7.6, but works with 7.4...
10:42:55 <lispy> is there a way to make cabal return non-zero exit code when haddock fails?
10:43:04 <lispy> https://travis-ci.org/#!/haskell-opengl/OpenGL/builds/3070747
10:43:16 <dcoutts> lispy: if it doesn't now, it's a bug
10:43:23 <lispy> In that build, at the bottom haddock fails but the overall build succeeds
10:43:30 <lispy> this is 1.14
10:44:15 * ezyang goes and stares at the diff again 
10:44:23 <ezyang> c_wraith: And this is with no modifications on your part?
10:44:29 <c_wraith> ezyang: correct
10:44:37 <c_wraith> ezyang: https://github.com/chowells79/lrucache/issues/8
10:45:06 <lispy> dcoutts: I'll try installing the latest cabal-install before running haddock
10:45:41 <dcoutts> lispy: just checked: it works fine for me
10:45:42 <c_wraith> ezyang: I was more or less abusing mapWith' to get a strict version of adjust.  Now that there just *is* a strict version of adjust, I can use that instead.
10:45:58 <lispy> dcoutts: works fine == returns non-zero when haddock fails?
10:46:03 <dcoutts> lispy: yes
10:46:06 <lispy> dcoutts: what version?
10:46:13 <lispy> cabal --version, I mean
10:46:13 <dcoutts> 0.17
10:46:17 <lispy> hmm
10:46:18 <dcoutts> but I don't think it's a recent fix
10:46:28 <ezyang> Oh, but I didn't make this commit, it's Tibell's fault. Go yell at him :)
10:46:31 <lispy> I'm using whatever ships with 7.4
10:46:56 <c_wraith> ezyang: haha.  Anyway..  the presence of CPP just means it's battle-tested, right?
10:47:03 <ezyang> c_wraith: Yeah, using Data.Map.Strict seems like a better idea long term
10:47:03 <lispy> dcoutts: oh, I see the problem
10:47:11 <lispy> dcoutts: The problem is that 'cabal test' returns 0
10:47:11 <ezyang> c_wraith: The behavior shouldn't have changed though >:-(
10:47:17 <lispy> dcoutts: So, n/m
10:47:20 <dcoutts> ok
10:47:47 <ezyang> anyway, definitely shoot tibbe an email or something
10:48:34 <osa1> can anyone tell me some problems for solving with type system (FunDeps, TypeFamilies, UndecidableInstance, MPTCs etc.) as a learning exercise ?
10:48:59 <Philippa> osa1: honestly, those things tend to be better learned when you discover you need them
10:49:16 <Philippa> unless you're coming from more typeful languages and just want to learn how to get by
10:49:38 <osa1> Philippa: no, haskell is most typeful language I'm using
10:50:01 <nand`> well for example you can solve certain problems with MPTCs+FunDeps and never realize a type family would be much more appropriate
10:50:54 <lispy> dcoutts: I'll try moving the install action to the test phase and see if that allows me to detect a haddock failure
10:52:16 <Philippa> nand`: that's true
10:52:32 <Philippa> you'll know that some extension might be needed though, so at least you can ask around at that point
10:56:31 <codebrah> hay u litle haskells ;)
10:56:35 <codebrah> wat up
10:56:38 <johnw> hey!
10:56:57 <johnw> u can haz haskell 2
10:58:54 <Philippa> wait, did we revert language versioning schemes?
11:01:10 <edwardk> clearly -fundecidable-instances is a misnomer. They are neither fun nor decidable.
11:01:17 <simpson> Heh.
11:01:52 <codebrah> LOL
11:02:16 <codebrah> im pumping lema context free languag
11:02:22 <koala_man> :D
11:03:20 * hackagebot lrucache 1.1.1.2 - a simple, pure LRU cache  http://hackage.haskell.org/package/lrucache-1.1.1.2 (CarlHowells)
11:05:01 <tac> edwardk: :P
11:09:37 <codebrah>  so is haskell better than scheme
11:10:13 <mauke> yes
11:10:16 <Philippa> <insert holy war here>
11:10:20 <josephle> codebrah: define "better"
11:10:22 <Philippa> It's what I choose to use, of course
11:11:13 <ChristianS> if you like strong typing, choose haskell. if you like lots of parentheses, choose scheme.
11:11:40 <Philippa> Haskell's much better for typeful programming, has a different attitude to side-effects, and a reasonable compromise between minimal and overcomplicated syntax
11:12:09 <mauke> what if I like both? qi lisp?
11:12:22 <Philippa> typeful programming also enables a different approach to embedding languages in particular
11:12:26 <Peaker> What kind of type system is Qi?
11:12:31 <Philippa> mauke: liskell? :p
11:14:26 <codebrah> iv never used haskell, im doin the tutorial it said to chat here
11:14:53 <codebrah> ive only used scheme
11:15:04 <tac> Haskell is better because while Lisp is unsafe, Haskell is safe, except when it isn't.
11:15:22 <codebrah> l8r brahs, class is over!
11:15:26 <tac> The type system is always there to make sure you have to use unsafePerformIO to bypass it.
11:15:32 <nand`> @protontorpedo
11:15:33 <lambdabot> please expalin pure and lazy a little (im igonorant i know)?
11:16:19 <shachaf> tac: The type system has nothing to do with unsafePerformIO.
11:16:20 <lambdabot> shachaf: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:17:04 <mauke> shachaf: I can implement unsafeCoerce via unsafePerformIO. your argument is invalid
11:17:49 <tac> That's a good point. Haskell has multiple ways to break out of the type system that makes it so great. Thus, it's more expressive too ;)
11:17:58 <koala_man> let wtfJustDoIt = unsafePerformIO
11:18:26 <shachaf> tac: Haskell has multiple ways to "break out of the type system", but the way Haskell does IO has nothing to do with types.
11:19:12 <Palmik> Hi guys, is there a way to tell since when is certain language extension supported by GHC?
11:19:37 <nand`> the type system is always there to make sure you have to use unsafeCoerce to bypass it
11:19:40 <nand`> manual revisions would do it I guess
11:19:40 <nand`> though there may be an easier way
11:19:53 <shachaf> The type system isn't "keeping anything pure", or "stopping you from doing IO".
11:20:27 <kirindave> I am considering using Control.Monad.LoopWhile.
11:20:32 <kirindave> Is this evil?
11:20:36 <kirindave> Seems a bit out of date...
11:20:44 <monochrom> I think you need both unsafePerformIO and IORef
11:21:22 <nand`> shachaf: arguably, if you implement effectful actions as functions with some abstract arrow other than (->) to ensure that you can't actually apply them outside of primitives; then the type system *would* be preventing you from performing side effects?
11:21:50 <nand`> like IO a = ... | Run (FFI i o) i (o -> a)
11:21:56 <nand`> forall i o.*
11:22:27 <nand`> but that's outside the scope of Haskell
11:22:33 <nand`> since Haskell doesn't define IO actions that way
11:23:21 <Saizan> nand`: if you define IO that way you don't need the type system to keep you straight
11:23:21 * hackagebot chuchu 0.2.1 - Behaviour Driven Development like Cucumber for Haskell  http://hackage.haskell.org/package/chuchu-0.2.1 (FelipeLessa)
11:23:28 <kirindave> :\
11:23:50 <Saizan> nand`: it's when you do it the impure way that the type system helps keeping the abstraction sane
11:24:05 <shachaf> If you had an untyped language that did IO just like Haskell, it would have all the same properties as Haskell.
11:24:15 <mauke> did you mean: javascript
11:25:00 <c_wraith> jaspervdj: I fixed lrucache. Thanks for reporting that. (I should have tested it on 7.6 before I said it was compatible. That'll teach me.)
11:25:06 <shachaf> On the other hand, if you added a bunch of primitives like readFile :: FilePath -> String to Haskell, it would be just like other languages (except harder to reason about).
11:28:36 <c_wraith> shachaf: well, except for the fact that compiler makes a bunch of assumptions about purity that primitives like that would break.
11:28:58 <shachaf> Yes, harder for everyone to reason about. :-)
11:30:40 <josephle> that's one of the more interesting questions: how do we separate "benign" effects from other effects?
11:33:04 <Jafet> makeBenign :: IO a -> a
11:33:18 <beaky> How do I get the current date in haskell
11:33:23 <yitz> Jafet: unsafeMakeBenign you mean
11:33:49 <johnw> beaky: look at Data.Time
11:33:51 <dmwit> beaky: getCurrentTime
11:34:21 <beaky> ah that works!
11:34:21 <S11001001> @google current date haskell
11:34:23 <lambdabot> http://www.haskell.org/haskellwiki/Getting_the_current_date
11:34:23 <lambdabot> Title: Getting the current date - HaskellWiki
11:34:48 <johnw> Data.Time.Clock.getCurrentTime returns a UNIX-style time that can be converted to/from seconds with utcTimeToPOSIXSeconds and posixSecondsToUTCTime
11:35:26 <yitz> beaky: be careful though. you have to know in what time zone, and whether summer time is in effect
11:35:33 <beaky> ah :(
11:35:48 <beaky> time is hard
11:36:32 <johnw> time isn't so bad, it's synchronizing time...
11:37:19 <JavaSucksMan_> Don't forget about leap seconds
11:40:54 <Palmik> Hi guys, is there a way to tell since when is certain language extension supported by GHC?
11:41:44 <rwbarton> josephle: ultimately i think the notion of "benign effect" must be chosen depending on the problem at hand
11:44:17 <ski> shachaf : i saw an untyped language (for controlling some robotics, iirc) with Haskell-style I/O somewhere ..
11:44:19 <Philippa> rwbarton: yeah, it's entirely about how much of a mess it makes of your ability to reason about what you're actually doing. Local state is often /entirely/ benign for me, but I'm careful with how much I use
11:44:33 <Philippa> ski: heh, I've built one before too. It's not like it was hard to write the interpreter :-)
11:48:14 <tac> State really wants to bleed all over when you're prototyping.
11:48:29 <tac> And I think most code goes to production before it ever stops being a prototype :)
11:48:32 <bxx> is there a way to get a list of all the exported symbols in a module?
11:51:22 <rwbarton> I am thinking of examples like memory allocation vs. reading a file
11:52:04 <rwbarton> if I am doing batch processing of very large data files I might care quite a lot about when exactly I am allocating memory and not at all about when exactly I am reading the file
11:53:05 <rwbarton> the model of "spending time doing computations and allocating memory is pure, everything else is impure" is appropriate in many cases, but not all
11:54:19 <atriq> Ugh
11:54:26 <atriq> I uninstalled GHC to reinstall it
11:54:32 <atriq> (I really wanted lambdacase)
11:54:38 <c_wraith> ST exists to handle the cases of limited mutation, and is good for that.  What we need are more libraries for cases like that.
11:54:39 <atriq> And I can't install 7.6?
11:54:49 <shachaf> atriq: You don't need to uninstall 7.4 to install 7.6
11:54:56 <atriq> shachaf, too late now
11:55:03 <mauke> why can't you install 7.6?
11:55:11 <atriq> Configure script doesn't work
11:55:18 <shachaf> @where doesn'twork
11:55:18 <lambdabot> I know nothing about doesn'twork.
11:55:21 <mauke> "doesn't work" is useless
11:55:26 <byorgey> atriq: are you building it from source?
11:55:30 <atriq> configure: error: cannot determine current directory
11:55:33 <atriq> No, from binary
11:55:37 <atriq> Linux x86-64
11:56:13 <byorgey> atriq: can you paste the full error output somewhere?
11:56:38 <parcs`> atriq: do you have the required build programs installed?
11:56:38 <byorgey> I had a similar problem once and it turned out to be because the binary was built against a different version of libgmp than the one that I had
11:56:48 <byorgey> sadly the only solution was to build from source
11:56:49 <parcs`> apt-get install build-essentials
11:57:06 <DMcGill> Anybody familiar with Netwire here? Yampa has the occasionally construct where you specify the event density - i.e. occasionally 5 means the event will happen about once every 5 seconds. Netwire has wackelkontakt but that's not quite what I'm looking for
11:57:09 <shachaf> @google "configure: error: cannot determine current directory" ghc
11:57:10 <lambdabot> http://askubuntu.com/questions/95081/cannot-determine-current-directory-while-building-haskell
11:57:10 <lambdabot> Title: 11.10 - "cannot determine current directory" while building haskell - Ask Ubuntu
11:57:23 <atriq> parcs`, apt-get can't find that
11:57:24 <mauke> do you have utils/ghc-pwd/dist-install/build/tmp/ghc-pwd?
11:57:27 <shachaf> byorgey: I just installed another version of libgmp
11:57:31 <mauke> build-essential
11:57:31 <atriq> http://hpaste.org/77291
11:57:47 <atriq> That's the newest version
11:57:50 <byorgey> shachaf: true, that's the other solution, but I didn't have admin control over the particular machine in question
11:57:50 <atriq> That paste is the error
11:57:52 <mauke> atriq: ... so you decided to ignore the first error
11:58:23 * hackagebot OpenGL 2.6.0.1 - A binding for the OpenGL graphics system  http://hackage.haskell.org/package/OpenGL-2.6.0.1 (JasonDagit)
11:58:44 <atriq> mauke, how do I get that?
11:58:46 <lispy> That release fixes the haddock failures ^^
11:58:47 <atriq> I'm confused
11:59:04 <rwbarton> you type 'uname -a; file utils/ghc-pwd/dist-install/build/tmp/ghc-pwd'
11:59:04 <atriq> And one person give me step-by-step instructions?
11:59:21 <rwbarton> or can it be a linker error too
11:59:42 <atriq> rwbarton, that didn't change anything with the result of ./configure
11:59:55 <rwbarton> ... and show us the output
12:00:07 <mauke> atriq: it wasn't supposed to
12:00:08 <shachaf> atriq: Instead of step-by-step instructions, you should try for learning-to-solve-this-sort-of-thing-yourself instructions.
12:00:20 <atriq> Both would be nice
12:00:44 <atriq> http://hpaste.org/77292
12:01:07 <mauke> atriq: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd
12:01:08 <mauke> (run that)
12:01:18 <hpaste> sp3ctum pasted “Parsec - noneOf doesn't like me” at http://hpaste.org/77293
12:01:34 <atriq> "bash: utils/ghc-pwd/dist-install/build/tmp/ghc-pwd: cannot execute binary file"
12:01:43 <rwbarton> atriq: the output says you have a 32-bit linux but you downloaded the 64-bit binary distribution
12:01:51 <atriq> I'm... sure I'm on 64 bit
12:01:58 <sp3ctum> ^ could someone tell me what I'm doing wrong? I remember using noneOf earlier but it just doesn't work now..
12:02:07 <rwbarton> I'm sure you're not!
12:02:12 <atriq> So I'm not
12:02:15 <atriq> Huh
12:02:21 <atriq> Odd
12:02:23 <byorgey> sp3ctum: that error is just because the types s0 and m0 are ambiguous
12:02:27 <atriq> I'm sure I used to be
12:02:42 <byorgey> sp3ctum: however, I'm not sure what you expect evaluating noneOf "aeiou" at the prompt to do
12:02:47 <atriq> That is odd
12:03:15 <byorgey> sp3ctum: if you are having trouble using it in the context of some larger program then you should paste that (along with the error)
12:03:24 <atriq> Well, I'll get the 32 bit version
12:03:28 <atriq> Thanks, everyone
12:03:33 <Tekmo> byorgey: I have a question
12:03:42 <byorgey> Tekmo: ask away
12:03:50 <Tekmo> byorgey: I'm stopping by philadelphia on November 20th and maybe staying the night before or after
12:03:54 <parcs`> DMcGill: something like 'wackelkontakt 0.2 gen . periodically 1' perhaps
12:03:59 <sp3ctum> byorgey, you're right. adding a type declaration solves this. thanks!
12:04:01 <Tekmo> I wanted to know if I could stay at your place for a night
12:04:18 <sp3ctum> byorgey, i do have a context, but this was narrowed down as much as I could :)
12:04:18 <DMcGill> parcs`: thanks
12:04:37 <byorgey> sp3ctum: ok =)
12:05:13 <byorgey> sp3ctum: I just thought maybe you narrowed too much to get useful information out of #haskell... but it seems I was wrong =)
12:05:15 <parcs`> atriq: 'ghc-pwd: cannot execute binary file' likely means you are having gmp version as byorgey mentioned
12:05:25 <parcs`> atriq: gmp version issues*
12:05:28 <mauke> parcs`: read backlog
12:05:33 <atriq> Okay
12:06:09 <parcs`> oh, disregard.
12:06:28 <byorgey> Tekmo: I'll check!  How soon do you need an answer?
12:06:37 <byorgey> I am out of town at the moment
12:06:49 <Tekmo> byorgey: Not very urgent.  I think a few days is fine
12:07:03 <byorgey> ok.
12:07:10 <byorgey> ping me in a few days if you haven't heard from me yet.
12:07:19 <Tekmo> byorgey: Alright
12:07:53 <nejucomo> :t curry
12:07:55 <lambdabot> ((a, b) -> c) -> a -> b -> c
12:09:20 <shachaf> Cale: Can you turn on BangPatterns in lambdabot?
12:12:07 <atriq> Okay, the 32 bit version can't open libgmp.so.3, apparently
12:22:12 <atriq> Okay, GHC is working now
12:22:34 <byorgey> yay
12:22:40 <atriq> Installing cabal...
12:26:58 <atriq> Getting some interesting packages installed...
12:27:00 <crdueck> @src mapM_
12:27:00 <lambdabot> mapM_ f as = sequence_ (map f as)
12:27:37 <atriq> Blah, blah, blah, compiling Data.Text.Lazy
12:28:52 <atriq> @src sequence_
12:28:52 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
12:28:59 <atriq> @src sequence
12:28:59 <lambdabot> sequence []     = return []
12:29:00 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
12:29:00 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
12:39:48 <Polarina> lispy, it may be just me -- but with OpenGLRaw, it seems that the glGenVertexArray function is calling glGenVertexArraysAPPLE for me. And my driver doesn't support that extension, but it does have just "glGenVertexArrays'.
12:43:15 <efie> is there a function which turns a string into a unicode-presented-string? like "präsident" is turned into "pr\228sident"
12:43:26 * hackagebot hinotify 0.3.4 - Haskell binding to inotify  http://hackage.haskell.org/package/hinotify-0.3.4 (LennartKolmodin)
12:44:21 <mauke> > "präsident"
12:44:22 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
12:44:30 <Polarina> efie, that's just the Show instance for String.
12:44:32 <ben> tail . init . show maybe :)
12:44:32 * mauke shakes fist at lambdabot
12:49:46 <tomeo> What functions in Prelude would help me iterate over a string and check if the words of that string are in another list?
12:50:17 <byorgey> tomeo: words, all, any, map, filter, elem
12:50:29 <byorgey> (probably some subset of those)
12:50:31 <tomeo> thanks byorgey
12:52:28 <tomeo> Is there a function that works like any but will return the elements that matched instead of a bool?
12:53:04 <zspencer> Perchance Filter? http://hackage.haskell.org/packages/archive/base/latest/doc/html/Prelude.html#v:filter
12:53:05 <rwbarton> yes, it's in the list of functions byorgey mentioned :)
12:53:17 <saml> hey, data Foo = X Int | Y Int | ...;         data Bar = Bar Int Int Int Int ...;    how can I convert Foo to Bar ?
12:54:02 <saml> Plus (Plus (X 1) (Y 2))  (Z 3)    ==>   Bar  1 2 3 ..
12:54:53 <tac> saml: What do you mean "convert" a Foo to a Bar?
12:55:18 <byorgey> also, what does  ...  mean?
12:55:23 <saml> Foo is normal algebraic type.   Bar is flattened... denormalized...
12:55:30 <Tekmo> saml: I assume you mean define some sort of function of type "convert :: Foo -> Bar"?
12:55:33 <saml> Bar is a row that i'm inserting to a denormalized table.
12:55:43 <tac> ah
12:55:59 <scp> So, X 5 -> 5 0 0 0 ... ?
12:56:01 <saml> all my functions are written in terms of Foo..   given  a foo of type Foo, I want to flatten it out before inserting to db
12:56:05 <Tekmo> saml: Do you want default values for unused Ints?
12:56:06 <byorgey> saml: I assume you mean "how can I convert it without explicitly implementing a traversal over the whole data type"
12:56:22 <saml> scp, yah. i know what default value should be if things are missing
12:56:43 <byorgey> saml: and what if there are too many values?
12:56:50 <byorgey> saml: just throw away the extras?
12:56:51 <saml> that's a good question byorgey
12:56:52 <Tekmo> saml: convert (X n) = Bar n def def def -- where "def" is the default value
12:56:55 <saml> maybe my type is wrong
12:56:57 <Tekmo> Is that what you mean?
12:57:09 <byorgey> your type definitely seems questionable to me
12:57:15 <byorgey> why not  Bar = Bar [Int] ?
12:57:19 <saml> yes.  but Foo can be   data Foo = App Foo Foo
12:57:44 <saml> the order matters.  X is on the first spot (column)..
12:58:02 <saml> i'll ponder more
12:58:16 <saml> so this is not a common pattern
12:58:29 <Tekmo> Well, it seems like your database setup is flawed
12:58:38 <Tekmo> You have columns that sometimes don't hold a value
12:58:41 <saml> yah i tried to get around with single table :P
12:58:45 <saml> yup
12:58:59 <Tekmo> I've always wondered if there were a database setup for handling sum types
12:59:09 <Tekmo> Other than implementing a tagged union manually
12:59:16 <saml> yah having this single table does help building hierarchy  (parent-child)
13:00:56 <Tekmo> saml: Since all four fields are the same type, you can change your database row to be something like:
13:01:12 <Tekmo> saml: Field1: which constructor (marked by an int), Field2: The value
13:01:33 <Tekmo> So, (X 4) gets translated to something like "0, 4"
13:01:39 <saml> no they are different type. Int was an example.
13:02:07 <saml> yah. that reminds me of this perl database where perl objects are carefully serialized to database
13:02:21 <efie> > show "Präsident"
13:02:22 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
13:02:56 <mauke> Cale: do you know what's up with lambdabot and utf-8?
13:03:58 <tomeo> zspencer: I looked at filter but that wants a boolean value. I tried filter (=="am") r on  = [ ("am", "are"), ("was", "were") ] but was served with an error I dont quite understand
13:04:17 <tomeo> r = [ ("am", "are"), ("was", "were") ]
13:04:18 <zspencer> What was the error exactly?
13:04:42 <geekosaur> tomeo, if you wrote that exact thing then no, it won;t work.  what exactly did you write and what was the error?
13:04:44 <geekosaur> @paste
13:04:44 <lambdabot> Haskell pastebin: http://hpaste.org/
13:04:44 <tomeo> zspencer: http://pastie.org/5191904
13:04:57 <zspencer> Yea
13:04:58 <zspencer> that's what I thought
13:05:06 <zspencer> You've got a multidimensional list
13:05:15 <geekosaur> not exactly.  list of tuples
13:05:16 <tomeo> its a list of tuples
13:05:32 <zspencer> Yea sorry. I'm not a native speaker in Haskell yet ;)
13:05:41 <tomeo> Im far from it myself
13:05:41 <zspencer> your boolean should actually be a contains check
13:05:43 <geekosaur> filter ((== "am" . fst) -- perhaps
13:05:52 <zspencer> instead of an equality check
13:05:53 <geekosaur> which should give you back the first tuple
13:05:59 <clahey> ((== "am") . fst)
13:06:06 <tomeo> geekosaur: that means checking the first element of each tuple for "am" right?
13:06:12 <geekosaur> yes
13:06:15 <tomeo> sweet
13:06:21 <tomeo> the book has done some good :)
13:06:39 <zspencer> I've been trying to fight through Learn Me a Haskell
13:06:49 <johnw> Fight Me a Haskell, it's lesser known cousin
13:07:04 <zspencer> Is there something like the ruby koans that just has a shit ton of syntax for decoding?
13:07:07 <tomeo> zspencer: thats the one Im reading now too
13:07:26 <johnw> what is the sound of one type unboxing?
13:07:38 <simpson> Depends. Is it giftwrapped?
13:07:43 <zspencer> @johnw haha, exactly ;)
13:07:44 <lambdabot> Not enough privileges
13:07:51 <Palmik> Hmm, is there a simple way to tell since when is some language extension present in GHC (other than looking through the release history of GHC few years back).
13:08:18 <tomeo> that worked wonders, thanks clahey and geekosaur
13:08:29 <efie> Polarina: oh ups, thanks!
13:08:31 <Philippa> johnw: :t hadoken ?
13:09:05 <johnw> i didn't receive Haskell enlightenment until it had cut off my arm
13:09:21 <zspencer> I'm seeking more the ability to read it than enlightenment at th emoment
13:09:39 <johnw> zspencer: what trouble in particular are you having just now?
13:10:03 <zspencer> I just need syntax practice. Even a good library that I could comment deeply would be worthwhile
13:12:35 <tomeo> yay! I successfully picked the second word out of my tuple. but Im pretty sure this is not the proper way. Any functions I could look at that would make this prettier? snd ((filter ((== "am") . fst) r) !! 0)
13:12:37 <merijn> zspencer: Reading the Prelude would be a good start for the basics
13:12:46 <merijn> zspencer: Most Prelude functions are relatively simple
13:12:59 <clahey> zspencer: Oh, I'll give you mine to document once I get approval from legal to share it.
13:13:10 <geekosaur> tomeo: (!! 0) is head
13:13:21 <tomeo> geekosaur: oh true. thanks!
13:13:39 <clahey> @src head
13:13:39 <lambdabot> head (x:_) = x
13:13:39 <lambdabot> head []    = undefined
13:13:45 <clahey> @src !!
13:13:45 <lambdabot> xs     !! n | n < 0 = undefined
13:13:45 <lambdabot> []     !! _         = undefined
13:13:46 <lambdabot> (x:_)  !! 0         = x
13:13:46 <lambdabot> (_:xs) !! n         = xs !! (n-1)
13:13:53 <geekosaur> that said, we tend to prefer checking first since it's conceivable that the result might be empty at some point
13:14:07 <geekosaur> or:
13:14:10 <geekosaur> :t listToMaybe
13:14:12 <lambdabot> [a] -> Maybe a
13:14:13 <clahey> I wonder why head isn't just head = (!! 0)
13:14:33 <clahey> :t head'
13:14:34 <lambdabot>     Not in scope: head'
13:14:34 <lambdabot>     Perhaps you meant one of these:
13:14:34 <lambdabot>       `head' (imported from Data.List),
13:14:40 <clahey> Is there a safeHead?
13:14:42 <clahey> :t safeHead
13:14:44 <lambdabot> Not in scope: `safeHead'
13:14:47 <geekosaur> why go through the guard?
13:14:49 <tac> clahey: pattern match?
13:14:52 <tac> :)
13:14:52 <johnw> yes, in the safe package
13:14:52 <shachaf> @ty listToMaybe
13:14:54 <lambdabot> [a] -> Maybe a
13:15:54 <zspencer> @merijn what is "the Prelude?" /noob
13:15:54 <lambdabot> Unknown command, try @list
13:16:08 <atriq> zspencer, Prelude is the default package
13:16:12 <zspencer> Ah ok
13:16:14 <atriq> *module
13:16:16 <merijn> zspencer: The Prelude is the Haskell "standard library" that is always imported
13:16:23 <zspencer> And it's written in Haskell?
13:16:26 <atriq> It's imported by default and has a lot of functions
13:16:26 <atriq> Yes
13:16:29 <zspencer> Cool beans.
13:16:31 <zspencer> I'll check it out
13:16:37 <merijn> zspencer: Yes, it's the things like map, zip, head, etc.
13:17:30 <zspencer> Start here, I take it? http://www.haskell.org/onlinereport/standard-prelude.html
13:17:33 <zspencer> Or is there a git repo?
13:17:47 <hmax> guys, can someone point me towards good introduction to manifolds?
13:18:43 <merijn> zspencer: GHC has a git repo, but I'm not really sure where the Prelude is in the Git repo
13:18:49 <merijn> (github.com/ghc/ghc)
13:19:31 <geekosaur> ghc's version is not really ideal for learning from, though; the Prelude's is more didactic, GHC's has strange optimizations and still may have leftovers from support for older compilers (hugs and nhc98)
13:20:03 <fryguybob> merijn: I think you are looking for https://github.com/ghc/packages-base
13:20:04 <merijn> The Hackage page for Prelude seems to not correctly link to the source
13:20:07 <thoughtpolice> Prelude for GHC is in base, which is really just a module that re-exports stuff from some Data.* modules and internal GHC modules
13:20:43 <atriq> And Control.Monad, Applicative, Arrow, etc
13:20:46 <clahey> @hoogle [a] -> Maybe a
13:20:46 <lambdabot> Data.Maybe listToMaybe :: [a] -> Maybe a
13:20:46 <lambdabot> Data.List find :: (a -> Bool) -> [a] -> Maybe a
13:20:46 <lambdabot> Prelude head :: [a] -> a
13:20:50 <thoughtpolice> i also agree with geekosaur, the GHC libraries tend to have somewhat different definitions for a lot of things that may not be intuitively obvious, but exist for other reasons (typically performance)
13:21:02 <clahey> find (const True)  :)
13:21:23 <geekosaur> I meant "the Report's", oops
13:22:32 <rwbarton> foldr (const . Just) ow my fingers
13:22:53 <zspencer> When I was learning Ruby, I read and re-read the sinatra library a few times.
13:22:59 <zspencer> JAVA was mockito
13:23:24 <zspencer> I'm looking for something analogous to that. A library that is used on a regular basis and is being upgraded over time.
13:23:53 <zspencer> A standard lib is interesting, but I'm thinking more like "This is an implementation of an HTTP client in a haskell idiomatic way"
13:24:03 * zspencer is needy
13:24:25 <merijn> zspencer: The biggest problem is that many things like HTTP clients tend to use abstractions/features that might be overly complicated for beginners
13:24:58 <zspencer> I'm not worried about that. I'm not the kind of person who learns from the inside out. I have a hard time putting together all the pieces independently, but they make a lot of sense when I see them used together to perform some kind of work.
13:25:03 <merijn> zspencer: Altough xmonad might be interesting to look at? It's fairly small, I believe only like 1.2k lines of code
13:25:13 <zspencer> I'll check it out
13:25:35 <merijn> Parsec is also rather well known, but I'm not aware of it's internal complexity
13:27:06 <thoughtpolice> xmonad is a pretty good case study. just the regular old HTTP library is pretty cut-and-dried and easy to follow
13:27:49 <thoughtpolice> (i bring it up since sinatra etc was mentioned. you may like scotty, a haskell equivalent, but it builds on other things like warp. it's a matter of what you want to study and how far down you go, etc)
13:27:49 <beaky> ls
13:28:13 <fengshaun_> is space (function application) left associative or right associative?
13:28:23 <fengshaun_> it should be left, right?
13:28:23 <merijn> fengshaun_: Left
13:28:24 <thoughtpolice> cabal is also a pretty good case study i bet, it's fairly "classic" haskell, since it tends to shy away from lots of features/external dependencies
13:28:30 <fengshaun_> merijn, thanks
13:28:39 <dcoutts> thoughtpolice: partly by necessity
13:28:44 <thoughtpolice> dcoutts: right :)
13:28:47 <merijn> fengshaun_: i.e. "f g h" = "(f g) h"
13:28:52 <dcoutts> thoughtpolice: but there's far too much IO in it
13:29:12 <zspencer> @thoughtpolice thanks!
13:29:12 <lambdabot> Unknown command, try @list
13:29:17 <fengshaun_> merijn, yea, thanks!
13:29:19 <thoughtpolice> dcoutts: i haven't interacted with cabal in a while, but i've been tempted by all the GH activity it's seen :)
13:29:24 <thoughtpolice> er, the cabal source, i mean
13:30:09 * merijn is going to list his 1 character change as "cabal contributor" on his CV ;)
13:30:54 <thoughtpolice> actually, i may take the time to implement something i complained about to you a while ago, dcoutts, which was being able to add things to 'extra-source-files' by recursive glob and not requiring a suffix component in the path (i.e. you say 'foo/*' instead of being required to say 'foo/*.hs' or whatever)
13:31:17 <dcoutts> great
13:31:22 <thoughtpolice> dcoutts: would that be accepted, if it had some acceptable syntax or something? i kind of like not recursively grabbing everything, but when you need it, you *really* need/want it
13:31:22 <merijn> Oh, I lie. 2 characters :p
13:31:41 <thoughtpolice> just something like '**' for saying 'grab everything in this directory, or something similar
13:32:05 <dcoutts> thoughtpolice: with reasonable syntax, yes
13:32:40 <fengshaun_> As I understand, we can't assume a Monad is also an Applicative or a Functor.  But, we can treat it as such with liftM and ap and be sure that it works?
13:32:44 <thoughtpolice> OK, i may kick up a ticket to discuss it first and see what happens
13:33:44 <merijn> dcoutts: Any chance of the "license-files" pull request I see on the repo being merged? Right now there's no real way to properly specify LGPL3 since that uses two files.
13:34:37 <merijn> fengshaun_: Yes, logically all monads are functors and applicatives (i.e. monad operations are a superset of functor/applicative operations), the only reason why you can't assume it is because of hysterical raisins
13:35:13 <merijn> fengshaun_: i.e. the Monad typeclass doesn't actually require a Functor/Applicative instance, even though people should be able to write them
13:35:14 <fengshaun_> merijn, yes, hysterical raisins, but are there any exceptions?
13:35:49 <merijn> fengshaun_: I think all Monads in the standard libraries are also Functorss and Applicatives
13:35:56 <fengshaun_> can someone make a monad that follows monad laws, but would break when using liftM/ap?
13:36:04 <fengshaun_> yes, they are
13:36:07 <merijn> fengshaun_: No, not without breaking the monad laws
13:36:12 <fengshaun_> awesome
13:36:19 <fengshaun_> thanks
13:37:10 <merijn> Where can I read what "row types" mean?
13:40:23 <dcoutts> merijn: I commented on the pull request, did you see?
13:41:18 <merijn> dcoutts: No, it's not mine. I was just curious since I ran into the same problem :)
13:41:25 <dcoutts> oh ok
13:43:13 <krig> in case anyone is interested, I think I found and fixed a bug in emacs' haskell-mode indentation code: https://github.com/krig/haskell-mode/commit/af88155904e24abc9d4dfee133e0842197bf5e2e
13:44:17 <thoughtpolice> merijn: Michael Wand, "Type inference for record concatenation and multiple inheritence" is i think the paper that was the basis and spawned a lot of follow up
13:44:42 <johnw> krig: that makes sense to me
13:44:48 <johnw> krig: i was just editing that very function yesterday
13:44:57 <thoughtpolice> i found this paper after reading the Ur/Web paper, since Ur features strong metaprogramming based on row types. the ur paper also has some other references
13:45:10 <merijn> thoughtpolice: That's what made me curious
13:45:12 * ezyang likes row types! 
13:45:14 <thoughtpolice> merijn: so this http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.44.6387 and http://adam.chlipala.net/papers/UrPLDI10/UrPLDI10.pdf
13:45:26 <merijn> thoughtpolice: Although my first step would be to get MLton so I can actually build Ur/web
13:45:40 <krig> johnw: cool
13:45:41 <merijn> Apparently macports users aren't hardcore enough to have a mlton port
13:45:45 <thoughtpolice> i like ur. i've been writing up some patches i intend to send to adam
13:46:03 <thoughtpolice> merijn: ah, in brew it's just 'mlton' and works fine. most recent mlton is in every distro too, IIRC
13:46:36 <thoughtpolice> merijn: if you go to the mlton homepage and download the statically linked binary, it'll run fine
13:47:12 <thoughtpolice> the catch though, is mlton is statically linked against GMP (and probably won't work dynamically linked in my experience,) but the executables it generates WILL need a gmp to link to
13:47:36 <thoughtpolice> i had to fix this in the brew formula, by basically installing the static version, and having a false dependency on GMP, since anything it compiled would need GMP as a result
13:47:36 <merijn> thoughtpolice: I started playing with Yesod, but realised I can't be arsed with all that nonsense
13:47:51 <stepcut> merijn: :)
13:47:54 <mapf> is there mapLeft :: (a -> b) -> Either a c -> Either b c
13:47:55 <mapf> ?
13:48:11 <merijn> And then I thought "why not try Ur/web and increase my static typing machismo"
13:48:19 <johnw> mapf: did you check Data.Either?
13:48:22 <merijn> :t left
13:48:23 <lambdabot>     Ambiguous occurrence `left'
13:48:23 <lambdabot>     It could refer to either `Control.Arrow.left',
13:48:23 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
13:48:32 <merijn> :t Data.Either.left
13:48:34 <lambdabot>     Not in scope: `Data.Either.left'
13:48:34 <lambdabot>     Perhaps you meant `Data.Either.lefts' (imported from Data.Either)
13:48:37 <merijn> :t Data.Either.lefts
13:48:39 <lambdabot> [Either a b] -> [a]
13:48:41 <merijn> hmm
13:48:48 <merijn> Nope, that's not what I was thinking
13:48:57 <johnw> it's not in Data.Either, but would be trivial to write
13:49:11 <thoughtpolice> merijn: well, ur has it's own bit of catches. the operational model is vastly different (transactional, which makes some effects tricky to deal with, like sending emails or something else you can't rollback,) and Adam certainly has a 'vision' of what abstractions it provides, which isn't necessarily bad. but you likely will find some things may be 'missing' or are solved in very different ways
13:49:36 <thoughtpolice> overall i enjoy writing it a lot though. i like that focus at the same time, too, since it means i basically know what i'm dealing with
13:49:49 <beaky> haskell binaries are pretty huge :( any ideas on trimming them for size?
13:49:51 <mapf> johnw: yep, but it's better to use prelude when we can)
13:50:11 <merijn> thoughtpolice: I just want to write a small personal site, so I think it should be fine for that
13:50:19 <thoughtpolice> merijn: yeah, that's what i'm doing too. :)
13:50:26 <tomeo> I can't figure out why I'm getting compile error "Chatterbot.hs:42:1: Parse error in pattern: reflect" http://pastie.org/5192121. Could someone please lend me a hand?
13:50:28 <merijn> thoughtpolice: I don't suppose it has something like acid-state? :>
13:51:05 <merijn> tomeo: Try parentheses around "phr:phrs"
13:51:16 <thoughtpolice> merijn: all storage mechanisms lead to the database (sqlite, mysql or postgres.) keep in mind i haven't used acid state a lot
13:51:20 <merijn> tomeo: i.e. "reflect (phr:phrs)" instead of "reflect pth:pthrs"
13:51:29 <tomeo> thanks merijn Ill try that
13:51:38 <thoughtpolice> but in ur, the database is probably going to be one of the premier ways you deal with the outside world
13:52:10 <thoughtpolice> (for example, there is no native filesystem API. you could write one, but it's not in the box)
13:52:24 <merijn> thoughtpolice: Bleh, I wanted to avoid bothering with a database. Maybe I'll use SQLite for now...
13:53:30 * hackagebot AttoBencode 0.2 - Fast Bencode encoding and parsing library  http://hackage.haskell.org/package/AttoBencode-0.2 (FlorianHartwig)
13:53:43 <thoughtpolice> merijn: sqlite works just fine with it, i use it for dev but normally push out postgres for anything 'big' that i expect people to use
13:54:11 <tomeo> merijn: that worked. thanks a bunch. was pulling my hair :)
13:54:30 <merijn> thoughtpolice: It's just that I dislike using SQL for things where SQL doesn't make much sense :p
13:54:45 <merijn> Which is why I liked acid-state
13:55:58 <thoughtpolice> i mean, FWIW, you could probably just use a functor over some types to roll a type-safe interface that provides whatever abstraction you want, e.g. if you just wanted a K/V interface or a basic ORM
13:56:05 <thoughtpolice> the benefit is you can do that with lots of type safety
13:56:06 <thoughtpolice> :)
13:56:52 <thoughtpolice> merijn: to get an idea of what i mean, see this: http://impredicative.com/ur/more/ <- use the 'Orm1' demo, and then just look at the 'orm1.ur' source file
13:58:30 * hackagebot enummapmap 0.2.0 - Map of maps using Enum types as keys  http://hackage.haskell.org/package/enummapmap-0.2.0 (MatthewWest)
13:59:42 <thoughtpolice> merijn: for the most part though, because SQL tables act just like records where the table columns correspond to record fields (just like cookies, or any other basic record type,) aside from writing DML statements occasionally, the SQL actually 'blends in' very well. but i can see why that's still not satisfactory, it's kind of stupid to use SQL but feel like you throw it all away in one dumb table or something
14:00:09 <mcstar> can Ur/Web easily interface with jquery?
14:00:44 <johnw> merijn: what was the nonsense you encountered in particular with Yesod?
14:01:08 <merijn> johnw: It's just so opaque to figure out how to do things if you want to set up something minimal
14:01:31 <mcstar> merijn: have you watched the screencasts?
14:01:36 <merijn> Tweak one of 20 different auto generated typeclass instances with no good references
14:01:38 <thoughtpolice> i don't know what you mean, you'd have to be specific as to what jquery stuff you want. the client side model for ur/web is reminiscient of FRP, where you use discrete 'signals' to display information on a page, where you can periodically update signals, and the results change. as a result, you don't really end up doing similar DOM-style manipulation you would with jquery
14:01:41 <merijn> mcstar: No
14:01:49 <mcstar> merijn: i suggest you do, they are quite educational
14:02:01 <mcstar> (even if outdated..)
14:02:23 <thoughtpolice> they're probably not incompatible, but they're pretty fundamentally different models. jquery seems more like the thing ur/web would use, as an implementation detail (it doesn't, at the moment)
14:02:39 <merijn> mcstar: Except I don't want to really be a web developer and I prefer my code to be nice and understandable and I don't think any webcast will improve the overall quality of the Yesod code I've written so far
14:02:47 <thoughtpolice> if you just want stuff like jquery's trim or whatever, you can make an FFI call very easily to javascript
14:02:50 <thoughtpolice> and put that in your web-app
14:03:19 <mcstar> thoughtpolice: well, specifically, id want to use jqplot that depends on jquery, and theres a jquery datatable module, for showing and editing structured data
14:03:32 <merijn> I had ML's inline type annotations, though :(
14:03:45 <merijn> eh
14:03:48 <merijn> s/had/hate
14:03:53 <merijn> Dunno how that happened
14:04:02 <mcstar> s/hate/love
14:04:11 <thoughtpolice> mcstar: oh, sure, that's totally doable. just have it included on the page, and then you can use the FFI to call whatever you want, and in your app just call the JS function like you would an ur/web function
14:05:22 <mcstar> julius, cassius, hamlet, right?
14:05:30 <thoughtpolice> you may have to be a bit tricky with how you accomplish this (notably inserting the DOM elements, since Ur/Web has a typed AST of the XML it supports, so you'd have to be sneaky to coerce it,) but it's definitely doable. i don't think the trickiness is really innate, it could be overcome with toolchaining
14:05:40 <mcstar> is there another dsl for yesod? XD
14:06:11 <thoughtpolice> actually want of the proposals i want to make to Adam is to have users be able to write HTML tags. right now you have to patch the compiler just to use a tag it doesn't support
14:06:16 <thoughtpolice> like if you wanted to use <video> or whatever
14:06:17 <thoughtpolice> etc
14:06:24 <mcstar> i was looking around, looked at elm and fay
14:06:35 <mcstar> i couldnt get elm to build :(
14:06:47 <mcstar> (not elm itself, but a dependency)
14:16:22 <kv626> who
14:17:41 <ivanm> what
14:18:38 <simpson> when
14:23:21 <lightquake> i have an IntMap Entity deep within my data structure World's lenses, and i'd like to apply some f :: Entity -> m [Actions]  to every Entity in order and get out an m IntMap [Actions] (or an IntMap (m [Actions]), since i can just sequence over that)
14:23:36 <ivanm> lightquake: you broke the chain! *humph*
14:23:44 <lightquake> :(
14:24:09 <ivanm> the next thing that was meant to be said in this channel was "where"! ;-)
14:24:16 <shachaf> ivanm: "chains" like that are one of the worst thing about the Internet.
14:24:20 <shachaf> They deserve to be broken.
14:24:24 <ivanm> kv626: did you actually mean to ask us who we were?
14:24:46 <mcstar> chains that dont exist cant be broken
14:25:01 <ivanm> shachaf: my most humble apologies messer
14:25:39 <shachaf> Every chain in #haskell has an upper bound.
14:25:51 <ivanm> heh
14:28:16 <monochrom> hahaha
14:29:28 <ion> godwin Hitler :: Win
14:43:27 <phao> Hi.
14:43:39 <phao> Is there some article talking about the performance of code generated by ghc?
14:44:55 <merijn> phao: Lots, I think. Anything particular you're trying to find out?
14:45:20 <saiko-chriskun> so I just ran cabal install on osx... didn't add anything to ~/.cabal/bin, although it did add an executable to /Users/chriskun/Library/Haskell/ghc-7.4.1/lib/*/bin
14:45:33 <saiko-chriskun> anyone else here on a mac as well? how is ~/.cabal/bin managed?
14:45:39 <realazthat> hi
14:45:59 <phao> merijn, Nops... I was just wondering how well ghc does. I heard good stuff about it, but I'd like some specifics.
14:45:59 <dcoutts> saiko-chriskun: the default config on osx puts the bin dir where you just mentioned, not ~/.cabal/bin
14:46:10 <saiko-chriskun> so I manage it manually?
14:46:12 <dcoutts> saiko-chriskun: for details, see your ~/.cabal/config file
14:46:15 <merijn> saiko-chriskun: ~/Library/Haskell/bin is the default bin dir place on OSX
14:46:15 <saiko-chriskun> ok
14:46:15 <tomeo> Im running version 7.4.1 of Haskell but I would like to test my code in version 6.12.3. Is there an easy way of doing that?
14:46:25 <dcoutts> saiko-chriskun: you can customise it how you like
14:46:32 <saiko-chriskun> thankies :)
14:46:34 <merijn> (Well, symlinks to the actual binaries anyway)
14:46:39 <jaspervdj> c_wraith: thanks :-)
14:50:48 <merijn> phao: It really depends on the code, on average performance should be slightly faster than Java on the JVM (for as far as you can seriously talk about languages having speeds) with the best cases beating hand written C
14:50:52 <DanBurton> tomeo: erm... not really. Just download the old compiler and run it.
14:51:04 <merijn> phao: The usual disclaimer of "language speed is a silly notion" applies, of course
14:51:29 <DanBurton> tomeo: there might be a community resource that builds stuff against various versions of ghc, but I'm unaware of any such thing in actual existance
14:52:10 <tomeo> DanBurton: Our Prof. told us there was some kind of compatibility mode but he didn't tell us how it worked and I can't find any information about it on google :)
14:52:24 <merijn> phao: The garbage collection and some high level features add overhead, of course. On the other hand the purity lets GHC do really thorough overhauls of the code, optimising away or inlining huge pieces of code
14:52:55 <DanBurton> tomeo: hrm, never heard of it. I'm not exactly a ghc genius so if your prof says it exists then try emailing him about it. ;)
14:53:12 <merijn> Maybe he meant compiling with haskell98 instead of haskell2010?
14:53:28 <tomeo> merijn: thats what Im doing now. Ill have to ask him what he meant :)
14:53:51 <tomeo> But Im not sure what version of Haskell Haskell98 will be
14:53:55 <phao> merijn, but ghc can get to that sort code quality without me having to specially writing code to use stuff like faster primitives? For example, if I use a special + for small integers in my scheme implementation, it can do arithmetic much faster, but that's not the "standard way of adding"...
14:54:13 <aib> given an iteratable function (a -> a) and an initial value (a), if I want to iterate until f x = x, what do you suggest I do? sounds like a job for `fix`, but not quite. should I use `iterate` and do some kind of `takeWhile` on the resulting list or..?
14:54:28 <phao> So.. In there, I can get some performance, if I go down that path...
14:54:33 <edwardk> lightquake: 'traverse'
14:54:36 <DanBurton> tomeo: if you're interested in ghc-6.8.2 (which is... laughably ancient for ghc standards), you can use http://ideone.com
14:55:37 <DanBurton> and then there's http://codepad.org which uses hugs o_O
14:55:45 <sclv> 6.8.2 is a fine compiler
14:55:55 <warvickdavies> fold == accumulate? where does the name fold come from? fold something together?
14:56:03 <sclv> although i'll grant that there were more kinks worked out by the end of the 6 series
14:56:46 <tomeo> Thanks DanBurton. Our school doesn't update that often unless its a security patch. They have cycles and what not
14:57:38 <aib> and I keep running into this pattern (iterate until nothing new is being generated), especially with non-deterministic computations where I'll keep adding more and more probabilities to a list and then apply some filtering on it, until such a time that the filter takes out anything new added and I have a list of possible results. does this sound normal?
14:57:43 <merijn> phao: Well, in haskell that difference exists in the form of two different types, i.e. Int and Integer. The first is small machine based whereas the other is essentially unbounded
14:58:47 <merijn> aib: I think the takeWhile + iterate approach makes perfect sense
14:59:34 <phao> merijn, sure, but what I tried to say had more to do with "I could get performance there if I abandoned the usual way of doing things".
14:59:57 <merijn> phao: In haskell that mostly comes in the form of strictness annotations and unboxing
15:00:25 <merijn> phao: Tweak performance by modifying how lazy the code is
15:01:05 <warvickdavies> > let accum = foldl in accum (+) 0 [1..10]
15:01:06 <lambdabot>   55
15:01:28 <warvickdavies> > let accumulate = foldr in accumulate (*) 1 [1..5]
15:01:30 <lambdabot>   120
15:03:02 <monochrom> eh? there are new Cartesian Closed Comics!
15:03:10 <merijn> warvickdavies: I think the name comes from the idea of folding a list into a single value. Like taking a long sheet and folding it into a neat stack
15:20:30 <pordan30> @pl \f g (a,b) (c, d) -> (f a c, g b d)
15:20:32 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip flip snd . ((flip . ((flip . (ap .)) .)) .) . flip flip fst . ((flip . ((flip . ((.) .)) .)) .) . flip . (((.) . flip . (((.) . (,)) .)) .)
15:22:47 <kirindave> So. I have written an ugly, ugly bit of code.
15:22:57 <kirindave> And I know that this code can be made cleaner with lenses, I'm just not sure how.
15:23:07 <edwardk> kirindave: ?
15:23:34 <lightquake> edwardk: i'm not sure where/how to apply traverse
15:23:38 <kirindave> edwardk: I have a [Bucket] where bucket has a maxAmountLeft, and I want to fill the buckets until I have no water left. This is actually a financial algorithm.
15:23:48 <edwardk> :t traverse
15:23:49 <lambdabot> (Applicative f, Traversable t) => (a -> f b) -> t a -> f (t b)
15:23:51 <kirindave> Yeah but
15:24:04 <edwardk> lightquake: let t be 'IntMap'
15:24:06 <kirindave> What confuses me is how I "stop" filling the buckets when I run out of money.
15:24:18 <edwardk> f be your applicative
15:24:22 <kirindave> I ended up just MapMing
15:24:25 <kirindave> And then replacing that.
15:24:33 <dibblego> it might help to think of traverse as "same as map but some effect appears in all return positions"
15:24:51 <edwardk> :t Data.Traversable.mapAccumR
15:24:52 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
15:24:55 <edwardk> :t Data.Traversable.mapAccumL
15:24:56 <lambdabot> Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
15:25:09 <kirindave> And hiding the amount of water left in a StateT.
15:25:19 <kirindave> And so if I ran out of water before traversing the list of buckets
15:26:45 <kirindave> edwardk: Isn't t in that case my container and not my monad though? I'm using a writer to record what I do as I do it.
15:27:04 <dibblego> yes t=[]
15:27:56 <edwardk> StateT [Bucket] m  can work if need be. not sure what you mean by filling the buckets, etc.
15:28:11 <kirindave> edwardk: Just decremeneting from a variable until it reaches 0
15:28:23 <kirindave> And of course there are numerous strategies for doing that
15:28:55 <edwardk> so you are running a monadic action repeatedly until you have to throw away the bucket?
15:29:15 <edwardk> or you have a finite amount of water you want to work with
15:29:20 <kirindave> Finite water.
15:29:27 <kirindave> Fill the first bucket, then the second bucket, then the third
15:29:29 <edwardk> Int -> [Bucket] -> [Bucket]
15:29:32 <kirindave> Right.
15:29:39 <edwardk> and you just want the remaining unfilled buckets?
15:29:40 <kirindave> But as I'm going I'm using a WriterT
15:29:56 <kirindave> No I want to update the structure with the filled and partially bucket states and then know how much water I have left over
15:29:59 <edwardk> or do you want a bucket list with the fully filled buckets above you
15:30:06 <kirindave> In addition I am using WriterT to trace what I did.
15:30:11 <kirindave> Above me.
15:30:11 <edwardk> ok, then just write the boring recursive function or something
15:30:18 <kirindave> Yeah that's basically what I did.
15:30:40 <kirindave>  (remainder, newBuckets) <- incrementBucketGroupWhere amountOfWater (b ^. typeABuckets) (const True)
15:30:45 <kirindave> then
15:30:58 <kirindave> currentBucketSet.typeABuckets .= newBuckets
15:31:38 <edwardk> fill 0 xs = xs; fill n (Bucket k:xs) = case compare n k of GT -> Bucket 0 : fill (n - k) xs; _ -> Bucket (k - n) : xs   -- or something
15:31:43 <kirindave> Yeah
15:31:58 <kirindave> I just dont' think I can do it via a traverse.
15:32:08 <kirindave> Or rather it is probably more trouble than it's worth to do.
15:32:16 <edwardk> you can but you need to keep state for the amount of water left
15:35:56 <newbie1498> hi guys. I'm new to haskell. And for some reason I'm getting an error when compiling: Couldn't match expected type `Integer' with actual type `[Integer]'
15:36:06 <newbie1498> myrange :: (Integer, Integer) -> [Integer] myrange (x, y) | x > y     = []                | x == y    = [x]                | otherwise = myrange (x + 1, y) : [x]
15:36:37 <luite> newbie1498: function application binds tighter than the : constructor
15:36:43 <crdueck> if i have f :: a -> b -> c and g :: c -> d, why can't i do h = g . f? i have to do something like h = \a b -> g $ f a b
15:37:27 <dibblego> \a -> g . f a
15:37:27 <luite> newbie1498: err oops, i'm wrong
15:37:40 <dibblego> myrange (x + 1, y) : [x]
15:37:44 <dibblego> you probably want
15:37:46 <dibblego> myrange (x + 1, y) ++ [x]
15:37:48 <luite> newbie1498: myrange produces a list, : adds a single element to a list
15:37:53 <luite> right
15:38:34 <luite> perhaps even:  x : myrange (x+1,y)
15:38:34 <newbie1498> oh i see
15:38:49 <johnw> crdueck: h = (g .) . f
15:39:14 <johnw> means, bind g to the function returned from applying f
15:39:26 <newbie1498> @luite yes   x : myrange (x+1, y) fixed it
15:39:27 <crdueck> johnw: thats cleaner, thanks
15:39:27 <lambdabot> Maybe you meant: elite gsite quit quote
15:39:27 <newbie1498> thanks
15:40:03 <johnw> crdueck: in Data.Function.Pointless there is: h = g .: f
15:40:51 <johnw> which means "compose g with a function taking two arguments".  Same thing, perhaps clearer syntax, since it more explicitly states what you mean to do
15:43:17 <shachaf> @ty \(g :: c -> d) (f :: a -> b -> c) -> over (mapped.mapped) g f
15:43:18 <lambdabot> (c -> d) -> (a -> b -> c) -> a -> b -> d
15:43:45 <johnw_> points FP
15:43:55 <johnw> points for using lens!
15:44:04 <shachaf> I hope they're negative points.
15:48:40 <pordan30> is there a way to express <http://hpaste.org/77295> using predefined combinators without folding over a list of functions?
15:51:23 <lispy> pordan30: what about a list of numbers?
15:59:46 <pordan30> lispy: yeah - i'd like to eliminate the fold, however. i suppose it's no big deal.
16:01:34 <hpaste> “Eduard - Gabriel Munteanu” pasted “Separable” at http://hpaste.org/77296
16:06:12 <lispy> pordan30: I'm not sure why you would want to do that, but I don't see anything that would make it impossible. It does look like it would be ackward though.
16:08:32 <pordan30> at the moment, it's useful when dealing with repeated applications of partial functions returning in a monad like maybe or either
16:08:46 <Eduard_Munteanu> Oops, forgot to tell hpaste this was going to #agda.
16:31:40 <DanBurton> wait since when does caleskell include edwardk lenses?
16:31:49 <edwardk> DanBurton: since the other day ;)
16:31:55 <DanBurton> :)
16:32:21 <shachaf> Kaleskell
16:32:46 <edwardk> You need to watch your Calesterol.
16:33:07 <edwardk> Too much caleskel can be bad for you
16:33:51 <Cale> heh
16:33:51 <lambdabot> Cale: You have 2 new messages. '/msg lambdabot @messages' to read them.
16:35:09 <johnw> Calesthenics are my favorite way to avoid too much Calesterol
16:35:19 <edwardk> johnw: =)
16:35:51 <mauke> cale by value
16:36:11 <shachaf> shapr by need
16:36:15 <shachaf> @hej-shapr
16:36:16 <lambdabot> shapr!!
16:49:26 <Entroacceptor> dom96: do you still work on your irc client project?
17:04:23 <monochrom> interesting, I find that cabal-install calls ghc with -XHaskell98
17:05:36 <Igloo> It's because Haskell98 used to be the default, and we didn't want to break existing packages
17:05:52 <Igloo> There's a Cabal field to set the language you want, I think
17:08:41 * hackagebot edge 0.8 - Top view space combat arcade game  http://hackage.haskell.org/package/edge-0.8 (ChristopherHoward)
17:11:01 <acowley> Is there a canonical definition of a strict >=> anywhere?
17:11:12 <hpc> strict how?
17:11:35 <acowley> Here's what I use:
17:11:36 <acowley> f >=!> g !x = f x >>= (g $!)
17:13:06 <hpc> i don't think that exists anywhere, but i haven't looked for it
17:13:08 <acowley> The bang pattern is superfluous
17:13:10 <copumpkin> Cale: bot is fucked
17:13:13 <copumpkin> > 5
17:13:13 <lambdabot>   mueval-core: Prelude.read: no parse
17:13:17 <acowley> in my case at least
17:18:54 <dmwit> Any way to get a modern cabal-install on Windows without mingw or cygwin?
17:19:06 <dmwit> e.g. does anybody know of a place to get cabal-install-1.16 binaries?
17:19:23 <dmwit> (The official website only has 0.14.)
17:22:36 <acowley> Does the Windows HP not have a newer version?
17:23:26 <fryguybob> dmwit: cabal install cabal-install?
17:23:35 <dmwit> I don't even think 1.16 was out when the last HP went out. But I'll check.
17:23:45 <dmwit> fryguybob: "without mingw or cygwin"
17:23:57 <dmwit> (network has a configure script)
17:24:43 <dmwit> Yep, last HP had cabal-install-0.14, which isn't new enough to build most libraries on GHC 7.6.
17:24:56 <dmwit> (It still uses the old catch in auto-generated Paths files.)
17:25:29 <hpaste> int80_h pasted “fun with http-conduit ” at http://hpaste.org/77301
17:25:40 <zspencer> Is there a midje like library for haskell?
17:26:51 <sm> ooh! a new shoot-em-up
17:26:58 <dmwit> Maybe you'd better describe what you want. I don't think many of us know what midje is.
17:27:12 <int80_h> yeah I just googled it, still not clear.
17:27:41 <sm> http://frigidcode.com/code/edge/ .. awesome :)
17:28:11 <fryguybob> dmwit: It won't build against the network package that you have?
17:28:43 <dmwit> no =(
17:28:48 <dmwit> Also, I don't have a network package.
17:28:52 <acowley> Why are command line argument libraries so much more complicated than I expect them to be?
17:29:03 <zspencer> @dmwit essentially a haskell-oriented testing library
17:29:10 <lambdabot> Unknown command, try @list
17:29:13 <zspencer> that leverages the language features to reveal intent
17:29:20 <fryguybob> dmwit: I thought that was in the HP
17:29:41 <dmwit> Yeah, maybe I can install the HP and then cabal-install.
17:29:43 <zspencer> Marick made it for clojure: https://github.com/marick/Midje
17:29:43 <dmwit> That's possible.
17:29:47 <sm> acowley: good question.. I think it's 1. command line options are more complicated then we usually notice, 2. better apis have yet to be found
17:30:17 <dmwit> acowley: Because strings are a lousy data type.
17:30:20 <acowley> sm: I suppose so, but I really wish there was something that was not so flexible as what's on offer
17:30:31 <fryguybob> dmwit: Ah, I thought you already had.  I successfully built the new cabal with the latest HP on windows (and no ./configure support needed).
17:30:39 <sm> have you tried all the libs ? there are a couple aimed at simple use cases
17:31:30 <byorgey> zspencer: we have hunit, but perhaps that's not midje-like enough for you (I don't know midje).  However, we also have QuickCheck which is completely different but amazingly awesome.
17:31:45 <zspencer> I'll look into them both.
17:31:57 <hpaste> int80_h annotated “fun with http-conduit ” with “fun with http-conduit  (annotation)” at http://hpaste.org/77301#a77303
17:32:34 <dmwit> fryguybob: Great, thanks. I'll give it a shot.
17:32:40 <zspencer> Enjoyin' http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck
17:36:00 <dmwit> I guess there's also doctest and hspec, though I think they get a little less press.
17:38:51 <boris``> this may be a silly question
17:39:24 <dmwit> Silly questions are a bannable offense, better be careful.
17:39:28 <Cale> lol
17:39:34 <boris``> is there a way to force ghci to evaluate an IO action so i can store the result so i can do more complex things interactively?
17:39:45 <shachaf> > 1 + 1
17:39:47 <c_wraith> you can bind, like in do syntax
17:39:48 <dmwit> v <- {- complicated IO expression -}
17:40:01 <shachaf> boris``: You mean "execute" the action. The distinction is important in Haskell. :-)
17:40:04 <copumpkin> Cale: do you know what's up with lambdabot?
17:40:08 <beaky> hello
17:40:09 <c_wraith> shachaf: what'd you do to the poor bot?
17:40:18 <shachaf> (Unless you do mean "evaluate". But you probably don't.)
17:40:21 <dmwit> ?botsnack
17:40:24 <Cale> copumpkin: I tried to add some extensions, and now mueval has decided to stop working
17:40:28 <fengshaun> anybody experienced with archlinux?  They're not being helpful today!
17:40:39 <shachaf> #arch-haskell might know.
17:40:43 <boris``> ah, thank you, that's exactly what i want
17:40:48 <fengshaun> shachaf: oh thank you!
17:40:50 <boris``> shachaf: noted, thanks :)
17:44:19 <copumpkin> Cale: dayum
17:48:44 * hackagebot ply-loader 0.1.0.0 - PLY file loader.  http://hackage.haskell.org/package/ply-loader-0.1.0.0 (AnthonyCowley)
17:50:20 <int80_h> any ideas for my hpaste? I know I need to give a particular type, But I don't know what Request wants.
17:52:06 <rwbarton> int80_h: :t parseUrl
17:52:11 <rwbarton> er
17:52:17 <rwbarton> :t everything :/
17:53:04 <shachaf> @rwbarton Quick, let's take the opportunity to use lambdabot commands in ordinary conversation!
17:53:05 <int80_h> rwbarton, okay doing that.
17:53:48 <rwbarton> mostly parseUrl though i think
17:54:54 <beaky> > print [i | i <- [1..10], i /= 3]
17:55:00 <beaky> :(
17:55:08 <dmwit> <IO ()>
17:55:15 <beaky> ah
17:55:20 <beaky> > [i | i <- [1..10], i /= 3]
17:55:30 <dmwit> [1,2,4,5,6,7,8,9,10]
17:55:30 <beaky> :(
17:55:34 <beaky> :D
17:55:36 <int80_h> :t rwbarton :t parseUrl
17:55:36 <int80_h> parseUrl
17:55:36 <int80_h>   :: Control.Failure.Failure HttpException m =>
17:55:38 <int80_h>      String -> m (Request m')
17:55:39 <monochrom> @bots
17:55:44 <dmwit> :)
17:55:46 <rwbarton> still faster than lambdabot
17:55:49 <monochrom> @human
17:55:50 <int80_h> oops
17:56:02 <dmwit> Unknown command @human, maybe you meant one of: BUGGER OFF
17:56:30 <monochrom> sorry
17:56:31 <Nereid> :)
17:56:41 <monochrom> \∩/
17:56:45 <dmwit> If I'd been quicker I would have suggested @protontorpedo or something. =P
17:56:49 <beaky> > let f g x = if g x == x then x else f g (g x) in f cos 0
17:56:52 <rwbarton> int80_h: it has to choose the type m' where the parseUrl "http://10.64.251.32:8080" is executed
17:56:58 <monochrom> @quote monochrom IO.String
17:57:00 <rwbarton> but it doesn't know how so it picked m' = Any
17:57:15 <rwbarton> so write req' <- parseUrl "http://10.64.251.32:8080" :: IO (Request IO) or something
17:57:25 <dmwit> 0.7390851332151607
17:57:29 <int80_h> crap
17:57:42 <int80_h> I've seen this before, your answer reminded me
17:57:49 <shachaf> > last [1..1000000000000000000000000000000000000000]
17:57:51 <danharaj> hi I'm making GHC go out of memory
17:57:59 * monochrom meditates on the significance of 0.7390851332151607
17:58:05 <danharaj> I suspect it has to do with badly written Vector Unbox instances. How do I begin to debug?
17:58:19 <dmwit> dmwiteval: that looks like it would do bad things to my computer, terminated
17:58:38 <shachaf> dmwit: Wow, get a better optimizer.
17:58:41 <danharaj> weirdly: ghci doesn't break or anything
17:59:31 * beaky             1000000000000000000000000000000000000000
18:00:03 <dmwit> Hm, this doesn't look good. "Not in scope: `fromIntegral'"
18:00:13 <shachaf> > maxBound + 1 :: Int
18:00:22 <shachaf> (Undefined behavior! Now's your chance!)
18:00:28 <beaky> -2147483648
18:00:39 * beaky is 32-bit
18:00:43 <Ralith> no lambdabot?
18:01:19 <shachaf> Ralith: Could we get idrisbot in here?
18:01:41 <Ralith> shachaf: in due time.
18:01:41 <beaky> haskell is the best language for writing bots :D
18:02:14 <rwbarton> @arr
18:02:16 <Cale> copumpkin: Apparently hint has its own stupid copy of the list of GHC extensions.
18:02:18 * Ralith will probably actually write one, once he's satisfied with the state of his efforts on the compiler
18:02:25 <Cale> copumpkin: and it was out of date
18:02:26 <dmwit> fryguybob: ping
18:02:26 <copumpkin> oh
18:02:37 <rwbarton> dmwit: what kind of pirate-speak is that
18:02:47 <copumpkin> ARR
18:02:56 <dmwit> haha, whoops
18:03:23 <dmwit> Avast me smartly, ye lads and lasses! A bottle a rum to the first scrumptious tart to swab the deck.
18:03:59 <shachaf> Is that how pirates talk?
18:04:27 <Ralith> any pirates here to check?
18:04:32 <dmwit> shachaf: http://www.youtube.com/watch?v=t348e24vDyA
18:05:25 <fryguybob> dmwit: Yo
18:05:36 <dmwit> Does cabal-1.16 actually work for you once you build it?
18:05:42 <dmwit> It's generating some wonky looking stuff here.
18:06:04 <dmwit> import Prelude ((++), FilePath, IO, return) -- this list is woefully incomplete compared to what it uses in the rest of the generated file
18:06:30 <shachaf> whoa, dude
18:06:34 <shachaf> That's not nearly enough.
18:06:38 <shachaf> That list is whoafully incomplete.
18:07:17 <fryguybob> dmwit: It seems to work for me, what weirdness are you seeing?
18:07:38 <dmwit> It's generating bad Paths files. Better than 0.14, but still bad.
18:08:28 <dmwit> Let's see, what's a small package that uses Paths?
18:13:08 <dmwit> fryguybob: Create a file named Main.hs in a new directory foo containing "module Main where; import Paths_foo; main = return ()". Then cabal init, say it's an Executable (otherwise use defaults).
18:13:12 <dmwit> Can you cabal build the result?
18:13:27 <dmwit> Oh, you also have to put main-is: Main.hs in the executable section of the .cabal file that cabal init makes.
18:13:29 <fryguybob> dmwit: Checking.
18:14:52 <geekosaur> dmwit, xmonad (core, not contrib)?
18:15:40 <dmwit> geekosaur: Thanks for the suggestion, but probably not going to be a "small" build on Windows. =)
18:16:02 <dmwit> geekosaur: Anyway, a really minimal project does make the issue happen for me, so I'm not looking for suggestions any more.
18:17:42 <fryguybob> dmwit: Could not find module `Paths_foo'
18:18:13 <dmwit> ...huh
18:18:28 <dmwit> That's during "cabal build"?
18:18:34 <fryguybob> Yeah
18:18:47 <dmwit> Is your project named foo?
18:19:02 <fryguybob> Oh, missed that part.
18:19:29 <dmwit> Oh, yeah, the name of the module has to be whatever project name you chose, which is by default the name of the current directory when you run cabal init.
18:20:04 <startling> haha
18:20:37 <fryguybob> dmwit: Yes I see weirdness now.
18:21:48 <fryguybob> dmwit: Is happy to build it though cabal 1.14.0
18:22:03 <dmwit> Okay, great.
18:22:08 <dmwit> Thanks, I'll file a bug report.
18:22:15 * fryguybob somehow my that came out backwards.
18:26:43 <danharaj> No answers huh :[
18:27:13 <uniquenick> I have a type that is generated using #enum from hsc2hs, and when I try to pattern match with it I always get overlapping pattern warnings.  what am I doing wrong?
18:27:35 <dmwit> danharaj: Making GHC itself go out of memory? Tricky...
18:27:38 <startling> danharaj, I must've joined after your question, what is it?
18:27:47 <dmwit> maybe look into giving it less optimization fuel? no idea if that will even help
18:28:03 <startling> uniquenick: what does :info MyType say?
18:28:07 <danharaj> startling: my source is getting stuck on a particular file while building with ghc and going out of memory.
18:28:17 <danharaj> it loads into GHCi though!
18:28:17 <startling> hmmm weird
18:28:20 <rwbarton> uniquenick: i imagine you're "pattern matching" on values not constructors
18:28:26 <danharaj> ok
18:28:34 <danharaj> I turned off -O2 and it worked!
18:28:51 <danharaj> what is the option to get verbose output from ghc?
18:29:08 <uniquenick> rwbarton: that sounds like it.  what am I supposed to be doing?
18:29:36 <rwbarton> use guards and == i guess
18:29:37 <Cale> wtf, -XNoMonomorphismRestriction is causing a problem because of the "No"
18:29:44 <otters> reading the "Understanding GADTs" page on wikibooks, it has an example for lists that are specified to be empty or nonempty on the type level
18:29:50 <otters> doesn't that mean that the list contents have to be known at compile time?
18:29:51 <Cale> It's not in the list of known extensions for some reason
18:30:29 <rwbarton> otters: it means that whether the list is empty has to be known at compile time
18:30:41 <danharaj> what would I write on the command line to have GHC -v output diverted to a file?
18:30:47 <otters> doesn't that severely limit the practical use of that datatype
18:31:01 <otters> or am I missing something important
18:31:08 <rwbarton> why?
18:31:47 <otters> well, I mean, if you're making a list out of user input, you can't transform it into a SafeList
18:31:54 <geekosaur> danharaj, ghc -v ... 2> ghc.log
18:32:01 <rwbarton> make a Maybe SafeList
18:32:01 <geekosaur> (even on windows, I believe)
18:32:05 <otters> oh
18:32:12 <otters> I suppose
18:32:19 <uniquenick> how is trying to pattern match like "case code of kLeft -> blah blah" different from "case foo of 1 -> blah blah"?
18:32:38 <rwbarton> kLeft is a variable
18:32:51 <rwbarton> think "case code of x -> blah blah"
18:33:09 <rwbarton> in your case it shadows an existing variable
18:34:23 <rwbarton> it would be pretty bad if any code like "case code of x -> blah blah" would change its meaning when a variable x is added outside the case
18:34:58 <danharaj> Result size of Simplifier iteration =1 = {terms: 842,810, types: 339,197, coercions: 373}
18:35:04 <danharaj> (This looks ungood)
18:36:46 <Cale> > 1
18:36:59 <lambdabot>   1
18:37:03 <dmwit> \o/
18:37:05 <Cale> :k Monad []
18:37:07 * rwbarton applause
18:37:13 <lambdabot> Constraint
18:37:22 <dmwit> That's some pretty wicked-long turnaround time, though.
18:37:29 <dmwit> > 1 -- is it just as slow the second time?
18:37:35 <lambdabot>   1
18:37:36 <Cale> Just because it's joining channels and rate-limiting
18:37:45 <dmwit> ah, makes sense
18:38:04 <Cale> It has something like 80 channels to join
18:38:16 <Cale> because people only ever ask me to add channels
18:38:20 <Cale> never to remove them
18:38:36 <dmwit> sign of success =)
18:38:40 <danharaj> edwardk: you are a ghc output wizard right? :P Is there a way to see what term an optimization pass is working on? I need to figure out exactly where GHC is accidentally spewing 800,000 terms while 'simplifying'.
18:38:47 * hackagebot fsutils 0.1.2 - File system utilities for Haskell that are missing from built in libraries.  http://hackage.haskell.org/package/fsutils-0.1.2 (AnthonyGrimes)
18:38:56 <Cale> Then again, I don't know whether things like  join freenode:#uscs2010
18:38:59 <Cale> are really needed
18:39:14 <edwardk> thats not something i know my way around
18:39:25 <rwbarton> United States Customs Service?
18:39:38 <danharaj> ezyang: *poke*
18:39:39 <dmwit> There's only two people in that channel (other than me)...
18:39:41 <rwbarton> Oh, that stopped existing before 2010 so I guess not
18:39:49 <edwardk> i know how to smash inline pragmas around appropriately, and how to check the resulting core for faults. thats about it. ezyang is probably your man
18:40:07 <danharaj> edwardk: I knew it was one of the edwards ;)
18:40:13 <Cale> :k Gettable
18:40:19 <lambdabot> (* -> *) -> Constraint
18:40:25 <rwbarton> :k Dict
18:40:26 <edwardk> between us we cover a lot of skills/demographics
18:40:33 <lambdabot> Not in scope: type constructor or class `Dict'
18:40:36 <ion> (* -> *) looks like a Japanese smiley.
18:41:04 <Cale> (.____. ;)
18:42:25 <edwardk> rwbarton: lambdabot doesn't load the constraints package, though i suppose it could if you sweet talked cale. ;)
18:43:45 <Cale> Seems like something reasonable to add
18:43:48 <edwardk> it'd have to though i suppose if he were to add constraints he'd have to import Data.Constraint hiding ((***),(&&&))
18:43:56 <rwbarton> @let $( [| f x = x |] )
18:43:56 <lambdabot>   Parse error: $
18:44:06 <edwardk> nothing else in there conflicts
18:44:22 <Cale> Well, apart from the fact that it defines infix operators that overlap with Arrow
18:44:38 <Cale> and lists :P
18:44:40 <edwardk> cale: those are the only two and they are just a generalization of the arrow operators to a different kind
18:44:40 <rwbarton> i don't really know what one would do with it in lambdabot besides take :k of various things
18:44:52 <edwardk> :t (\\)
18:44:54 <lambdabot> Eq a => [a] -> [a] -> [a]
18:45:01 <edwardk> =/
18:45:18 <edwardk> :t (//)
18:45:20 <lambdabot> Ix i => Array i e -> [(i, e)] -> Array i e
18:45:34 <rwbarton> :k Bool
18:45:36 <lambdabot> *
18:45:36 <ion> / || \\ -- // || \\ --
18:45:39 <edwardk> no goodsubstitution operator left ;)
18:45:57 <Cale> :t subst
18:45:59 <lambdabot> (Eq a, Num a) => String -> Sym a -> Sym a -> Sym a
18:46:02 <Cale> of course
18:46:04 <dmwit> :t (|->)
18:46:05 <lambdabot>     Not in scope: `|->'
18:46:05 <Cale> lol
18:46:06 <lambdabot>     Perhaps you meant `Seq.|>' (imported from Data.Sequence)
18:46:12 <dmwit> YES
18:46:14 <rwbarton> oops
18:46:16 <rwbarton> :k True
18:46:17 <lambdabot>     Not in scope: type constructor or class `True'
18:46:17 <lambdabot>     Perhaps you meant `Tree' (imported from Data.Tree)
18:46:21 <edwardk> i could export a subst synonym from Data.Constraint
18:46:26 <ion> Inspired by s///: (///)
18:46:38 <edwardk> its not quite as elegant as the \\ for how it gets used in there, but it'd work
18:46:38 <ion> @hoogle sub
18:46:39 <lambdabot> Prelude subtract :: Num a => a -> a -> a
18:46:39 <lambdabot> Data.List subsequences :: [a] -> [[a]]
18:46:39 <lambdabot> Text.Html sub :: Html -> Html
18:47:00 <uniquenick> is there a way to do this without needing a lambda?  (\x -> max (x - 1) 0 )
18:47:12 <dmwit> max 0 . subtract 1
18:47:18 <Cale> @pl (\x -> max (x - 1) 0 )
18:47:18 <lambdabot> max 0 . subtract 1
18:47:28 <dmwit> oh snap
18:47:42 <edwardk> cale: if you import it hiding ((***),(&&&),(\\)) it can still be useful
18:47:46 <Cale> yeah
18:47:55 <Cale> and I can give those things other names
18:48:00 <edwardk> yeah
18:48:12 <Cale> :t -/-
18:48:13 <edwardk> well, (***) and (&&&) are pretty obscure in there ;)
18:48:14 <lambdabot> parse error on input `-/-'
18:48:20 <Cale> :t (-/-)
18:48:22 <lambdabot> Not in scope: `-/-'
18:48:26 <edwardk> :t (\\\)
18:48:26 <Cale> :t (-***-)
18:48:28 <lambdabot> Not in scope: `-***-'
18:48:28 <lambdabot>     Not in scope: `\\\'
18:48:28 <lambdabot>     Perhaps you meant one of these:
18:48:28 <lambdabot>       `\\' (imported from Data.List),
18:48:32 <Cale> :t (-*-)
18:48:34 <lambdabot> Not in scope: `-*-'
18:48:37 <Cale> :t (-&-)
18:48:38 <lambdabot> Not in scope: `-&-'
18:48:39 <dmwit> Nobody likes |->, huh?
18:48:48 <edwardk> looks a bit operatory
18:48:54 <edwardk> er type operatory
18:49:05 <Cale> |-> looks like an alternate syntax for lambda
18:49:11 <shachaf> @pl \x -> max (x - 1) (0 / 0)
18:49:11 <lambdabot> max (0 / 0) . subtract 1
18:49:19 <EvanR7> (@:-)
18:49:21 <shachaf> > (\x -> max (x - 1) (0 / 0)) 5
18:49:23 <lambdabot>   4.0
18:49:23 <edwardk> :t (\)
18:49:24 <lambdabot> parse error on input `)'
18:49:30 <shachaf> > (max (0 / 0) . subtract 1) 5
18:49:35 <lambdabot>   mueval-core: Time limit exceeded
18:49:37 <shachaf> > (max (0 / 0) . subtract 1) 5
18:49:40 <edwardk> oh yeah \ lambda ;)
18:49:43 <lambdabot>   mueval-core: Time limit exceeded
18:49:46 <shachaf> > (max (0 / 0) . subtract 1) 5
18:49:47 * shachaf sighs.
18:49:49 <dmwit> Oh, I didn't even look at the type of the thing we were suggesting names for.
18:49:50 <lambdabot>   mueval-core: Time limit exceeded
18:49:51 <dmwit> shame on me
18:49:54 <Cale> lol
18:49:56 <Cale> wat
18:50:01 <Nereid> > max (0/0) 4
18:50:03 <lambdabot>   NaN
18:50:06 <dmwit> I just saw "substitution" and went with it.
18:50:07 <EvanR7> :t (\)
18:50:09 <lambdabot> parse error on input `)'
18:50:09 <Nereid> what's up with that
18:50:13 <EvanR7> :t (\\)
18:50:14 <lambdabot> Eq a => [a] -> [a] -> [a]
18:50:16 <rwbarton> :t (-->)
18:50:17 <lambdabot> parse error (possibly incorrect indentation)
18:50:21 <shachaf> What's the deal with NaN?
18:50:21 <Cale> > (max (0 / 0) . subtract 1) 5
18:50:22 <edwardk> EvanR7: \x -> x   -- think lambda
18:50:24 <lambdabot>   NaN
18:50:27 <Cale> lol
18:50:27 <Nereid> heh
18:50:37 <Cale> Lambdabot just hates shachaf
18:50:41 <Nereid> :>
18:50:42 <EvanR7> edwardk: i know the lambda notation, but isnt \ a valid operator?
18:50:45 <shachaf> @slap lambdabot
18:50:45 <lambdabot> stop telling me what to do
18:50:54 <Nereid> EvanR7: no, because it's used for lambda notation
18:50:57 <EvanR7> oh
18:50:58 <edwardk> EvanR7: no, the \ is being used as the preamble to the lambda.
18:51:00 <edwardk> its syntax
18:51:00 <EvanR7> is \\ ?
18:51:03 <edwardk> \\ is fine
18:51:04 <Nereid> \\ is fine yes
18:51:11 <edwardk> thats the operator we're talking about =)
18:51:27 <shachaf> They should rename (/) (//), in honor of edwardk.
18:52:02 <dmwit> How does this type even parse?
18:52:13 <edwardk> dmwit: for (\\) ?
18:52:21 <Nereid> or just to spite people, use `λ` for an operator
18:52:24 <dmwit> Is it rank-2 or something?
18:52:24 <shachaf> What type?
18:52:25 <dmwit> edwardk: yeah
18:52:34 <Nereid> instead of \
18:52:34 <edwardk> (\\) :: a => (b => r) -> (a :- b) -> r
18:52:38 <dmwit> No, it clearly isn't rank-2.
18:52:38 <shachaf> rwbarton: Was in explicit foralls that was making the @type errors never show up before?
18:52:58 <rwbarton> i don't see how that would do it
18:52:59 <dmwit> Okay, I think I get it.
18:53:05 <ion> shachaf: (⧨)
18:53:10 <rwbarton> maybe just a detail of the pretty-printing
18:53:15 <Cale> @undefine
18:53:25 <Cale> :t (-\-)
18:53:26 <shachaf> > '.' `elem` [' '..'=']
18:53:26 <lambdabot> (a) => ((b) => r) -> (a :- b) -> r
18:53:27 <rwbarton> though it's not the sort of thing one expects to change very often
18:53:27 <lambdabot>   True
18:53:29 <ion> Err… I mean edwardk. Your nicks shouldn’t be colored with the same color!
18:53:35 <edwardk> given 'a', and a calculation that needs 'b' to give you an 'r', and a proof that you can use a to discharge an constraint of type b, get an r.
18:53:40 <Cale> interesting prettyprinting there
18:53:48 <shachaf> Wasn't a . sufficient?
18:53:49 <dmwit> edwardk: Forgive my obviously broken syntax, but could we write a similar operator with type (a :- b) -> (b => r) -> (a => r)
18:53:52 <dmwit> ?
18:53:54 <ion> and have the same length
18:54:03 <rwbarton> maybe there were just no single functions with long enough types :P
18:54:20 <edwardk> i think that will want to float the a => all the way out.
18:54:24 <dmwit> yes
18:54:31 <dmwit> hence the "forgive my obviously broken syntax" =)
18:54:33 <edwardk> that is effectively what the operator here is doing
18:54:38 <dmwit> Yes, okay.
18:54:43 <edwardk> its just lifted the a => because i had to
18:54:44 <shachaf> edwardk: Why do you gotta CPS our constraints, man?
18:54:46 <rwbarton> shachaf: the issue was nothing before the ::
18:54:53 <dmwit> got it
18:54:58 <edwardk> shachaf: because it doesn't compile otherwise? =)
18:55:00 <shachaf> rwbarton: Oh, right, the part before the :: mattered.
18:55:01 <Cale> :k (:-)
18:55:03 <lambdabot> Constraint -> Constraint -> *
18:55:08 <rwbarton> :t (-\-) :: (a :- b) -> (b => r) -> (a => r)
18:55:08 * edwardk hugs cale
18:55:09 <lambdabot>     Couldn't match expected type `a :- b' with actual type `(b0) => r0'
18:55:10 <lambdabot>     Expected type: (a :- b) -> ((b) => r) -> r
18:55:10 <lambdabot>       Actual type: ((b0) => r0) -> (a0 :- b0) -> r0
18:55:17 <rwbarton> er
18:55:26 <shachaf> Where does :- come from?
18:55:27 <edwardk> :t cls :: Ord a :- Eq a
18:55:28 <dmwit> Then I still think |-> is kind of an okay name (actually, <-| with the way the arguments are =).
18:55:29 <lambdabot> Ord a :- Eq a
18:55:30 <rwbarton> :t (-\-) :: (b => r) -> (a :- b) -> (a => r)
18:55:32 <lambdabot> (a) => ((b) => r) -> (a :- b) -> r
18:55:41 <edwardk> :k Class
18:55:41 <shachaf> Oh, constraints?
18:55:42 <lambdabot> Constraint -> Constraint -> Constraint
18:55:47 <edwardk> :k (:=>)
18:55:49 <lambdabot>     Ambiguous occurrence `:=>'
18:55:49 <lambdabot>     It could refer to either `Lens.:=>',
18:55:49 <lambdabot>                              imported from `Control.Lens' at State/L.hs:83:1-19
18:55:53 <edwardk> hrmm
18:55:56 <edwardk> thats annoying.
18:56:05 <edwardk> can you hide (:=>) from Control.Lens?
18:56:07 <rwbarton> @kind (:=>)
18:56:08 <lambdabot>     Ambiguous occurrence `:=>'
18:56:08 <lambdabot>     It could refer to either `Lens.:=>',
18:56:08 <lambdabot>                              imported from `Control.Lens' at State/L.hs:83:1-19
18:56:10 <edwardk> its just an alias for Simple Traversal
18:56:18 <Cale> Does the kind ??? really exist?
18:56:20 <shachaf> Does anyone ever use those Lens aliases?
18:56:23 <ion> ⧀ ⤽ ↮ ⊳ ⎩ ⥽ ⍼ ⇎ ⦼ ⧑ ⧋
18:56:28 <EvanR7> -\- -|- -/- -|- *gets stabbed through the internet*
18:56:42 <Cale> (⤽_⤽)
18:57:08 <rwbarton> :k (->)
18:57:09 <lambdabot> * -> * -> *
18:57:15 <Cale> :k (=>)
18:57:17 <lambdabot> parse error on input `=>'
18:57:18 <dmwit> > Sub Dict
18:57:19 <lambdabot>   Could not deduce (b0) arising from a use of `e_1'
18:57:20 <edwardk> :k (Data.Constraint.:=>)
18:57:22 <lambdabot> Constraint -> Constraint -> Constraint
18:57:27 <Cale> (=>) y u no first class?
18:57:39 <Nereid> lol
18:57:39 <dmwit> > Sub (Dict :: Eq a => Dict a)
18:57:41 <lambdabot>   Type of kind * used as a constraint
18:57:50 <edwardk> :t Sub Dict (() :- Eq Int)
18:57:52 <lambdabot>     Not in scope: data constructor `:-'
18:57:52 <lambdabot>     Perhaps you meant one of these:
18:57:52 <lambdabot>       `:+' (imported from Data.Complex),
18:58:00 <edwardk> :t Sub Dict :: () :- Eq Int
18:58:02 <lambdabot> () :- Eq Int
18:58:12 <edwardk> :t Sub Dict :: Ord Int  :- ()
18:58:14 <lambdabot> Ord Int :- ()
18:58:15 <dmwit> > Sub (Dict :: Dict (Eq Int))
18:58:17 <lambdabot>   Sub Dict
18:58:18 <edwardk> :t Sub Dict :: Ord Int  :- Ord [Int]
18:58:20 <dmwit> yay
18:58:20 <lambdabot> Ord Int :- Ord [Int]
18:58:27 <rwbarton> I think "Could not deduce (b0) arising from a use of `e_1'" may be my new favorite error message
18:58:29 <edwardk> :t Sub Dict :: Ord a  :- Ord [a]
18:58:31 <lambdabot> Ord a :- Ord [a]
18:58:35 <Nereid> :t Sub (Dict :: Dict (Eq Int))
18:58:36 <lambdabot> a :- Eq Int
18:58:36 <edwardk> :t Sub Dict :: Ord a  :- Ord [[a]]
18:58:38 <lambdabot> Ord a :- Ord [[a]]
18:58:39 <shachaf> It's a bit silly that lambda notation has both \ and ->
18:58:43 <edwardk> :t Sub Dict :: Ord [a]  :- Ord a
18:58:44 <lambdabot>     Could not deduce (Ord a1) arising from a use of `Dict'
18:58:45 <lambdabot>     from the context (Ord [a1])
18:58:45 <lambdabot>       bound by a type expected by the context: Ord [a1] => Dict (Ord a1)
18:58:48 <edwardk> and that fails as expected
18:59:16 <rwbarton> :t Super Dict :: Ord [a]  :- Ord a
18:59:17 <lambdabot> Not in scope: data constructor `Super'
18:59:36 <edwardk> :t ins :: Ord a :- Ord [a]
18:59:38 <lambdabot> Ord a :- Ord [a]
18:59:47 <edwardk> :t cls :: Ord a :- Eq a
18:59:49 <lambdabot> Ord a :- Eq a
18:59:50 <Nereid> :t ins
18:59:52 <lambdabot> b Data.Constraint.:=> h => b :- h
19:00:00 <Nereid> :=>
19:00:08 <Nereid> so many strange new smileys
19:00:12 <edwardk> (b :=> h) => b :- h
19:00:17 <edwardk> :t cls
19:00:19 <lambdabot> Class b h => h :- b
19:00:48 <rwbarton> :k Forall
19:00:49 <lambdabot> Not in scope: type constructor or class `Forall'
19:00:57 <edwardk> there are instances for things like instance Ord a :=> Ord [a] where ins = Sub Dict    to mirror the instance Ord a => Ord [a] where ...
19:01:00 <rwbarton> is that in a separate module
19:01:10 <edwardk> its in Data.Constraint.Forall
19:03:08 <dmwit> This can't be the right way to do this.
19:03:14 <edwardk> dmwit: ?
19:03:31 <dmwit> hundreds of lines of "instance _ where {cls,ins} = Sub Dict"
19:03:56 <dmwit> hundreds is probably an overestimate
19:03:56 <edwardk> dmwit: i thought about using template haskell to generate them, but there was an issue. at the time TH didn't support constraint kinds
19:04:36 <dmwit> oh, maybe not
19:05:30 <EvanR7> does template haskell give you sensible errors when you try to produce nonsense source code with it
19:05:38 <EvanR7> like, is there a template type checker
19:06:04 <ivanm> I think there's been proposals for typed vs untyped TH
19:06:06 <ivanm> but that's about it
19:06:20 <rwbarton> you can get some "impossible" errors if you do stuff like generate (-1)-tuples
19:07:01 <Lajjla> EvanR7, my old friend
19:07:07 <Lajjla> I like what you've done with your beard.
19:07:15 <EvanR7> wrong
19:09:14 <startling> I guess vim would probably be more efficient with asetniop than emacs
19:09:52 <startling> because emacs already does chording, and things like C-a, C-i, M-a, and M-o are impossible in asetniop
19:10:11 <startling> oops, wrong channel
19:16:41 <EvanR7> with attoparsec is there a way to 'get all bytes until some other parser succeeds'
19:17:00 <EvanR7> takeWhile works for parsers that need 1 byte
19:17:13 <EvanR7> but i need 5
19:19:11 <EvanR7> ah manyTill
19:21:56 <dibblego> is there a GHC warning for usage of error/undefined?
19:23:30 <monochrom> no
19:24:09 <monochrom> I guess "grep undefined *.hs" will have to do for now
19:25:02 <dada-cetacean> is there a specific IO function that lets me replace all instances of a string in a text file with another string?
19:25:22 <dibblego> dada-cetacean: why would such a function use IO?
19:25:47 <dibblego> there is a function in Data.String.Utils
19:25:53 <EvanR7> dada-cetacean: Data.ByteString.Search
19:25:57 <dibblego> but it's not using IO
19:26:00 <rwbarton> runProcess "/bin/sed"
19:26:04 <EvanR7> haha
19:26:22 <dada-cetacean> I thought anything that changed the state of a file was IO
19:26:31 <dada-cetacean> since it's the only thing that's allowed to have side effects
19:27:05 <dibblego> ok, yeah reading and writing a file is in IO (this is not a side-effect)
19:27:22 <dibblego> http://hackage.haskell.org/packages/archive/MissingH/1.0.0/doc/html/Data-String-Utils.html#v%3Areplace
19:27:24 <rwbarton> this would be a bizarrely specific thing to have a single function to do
19:27:27 <EvanR7> readFile >>= writeFile . BSS.relace "foo" "bar"
19:27:53 <dibblego> I think you couldn't use readFile/writeFile to the same file, unless you forced the spine
19:28:13 <EvanR7> yeah dont do that
19:28:27 <Zabolekar> @version
19:28:27 <lambdabot> lambdabot 4.2.2.1
19:28:28 <lambdabot> darcs get http://code.haskell.org/lambdabot
19:29:01 <Zabolekar> @pl \f -> \n -> f (n+1) - f n
19:29:01 <lambdabot> ap =<< ((-) .) . (. (1 +))
19:29:40 <Zabolekar> @pl \x -> x+1
19:29:41 <lambdabot> (1 +)
19:30:14 <EvanR7> but yeah sed -i ftw
19:30:59 <Zabolekar> @bf +++++++++++++++++++++++++.
19:30:59 <lambdabot>  Done.
19:31:28 <Zabolekar> @bf +++++[>+++++++++<-].
19:31:29 <lambdabot>  Done.
19:32:34 <Zabolekar> @help
19:32:34 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:32:40 <Zabolekar> @help bf
19:32:40 <lambdabot> bf <expr>. Evaluate a brainf*ck expression
19:33:24 <dibblego> Zabolekar: \f -> on (-) f =<< succ
19:33:36 <Zabolekar> oh
19:33:37 <dibblego> s/succ/(+1)
19:33:59 <ivanm> dibblego: oh, not a fan of succ?
19:34:11 <dibblego> I am not, but mostly, it's not quite the same
19:34:33 <EvanR7> succ sucks
20:04:58 <mm_freak> (just to break the silence)
20:05:41 * copumpkin silences mm_freak 
20:06:16 <thoughtpolice> barely 30 minutes, even
20:06:57 <shachaf> thanks a lot, mm_freak
20:13:07 <lpvb> can one develop using haskell for iOS/android?
20:15:09 <ParahSailin> lpvb not easily
20:17:39 <startling> can I bind haskell code to go code?
20:17:54 <startling> i.e. there's a library written in Go I might want to use.
20:18:17 <ParahSailin> @quote ffi
20:18:17 <lambdabot> mauke says: <geheimdienst> "yes yes, real men can handle c. no need to make it any safer or less cowboy" -> boom, 40 years of buffer overflows, security fuckups, memory leaks, data corruption  <
20:18:18 <lambdabot> mauke> many C programmers suffer from insufficient paranoia  <mauke> because the compiler *is* out to get you
20:18:47 <ParahSailin> well that probably doesnt apply to go
20:19:45 <neworder> Hi guys
20:19:57 <neworder> I want to retrieve the first element of the list
20:20:02 <coldpizza72i> does inserting elements into a red black tree in functional languages work the same way as in imperative ones?
20:20:07 <neworder> [1,2,3]=x:xs
20:20:14 <EvanR7> safeHead
20:20:14 <neworder> Of course it doesn't work..
20:20:19 <coldpizza72i> or does it do things completely different
20:20:20 <neworder> Any other ways
20:20:29 <guidj0s> coldpizza72i: Do you mean 'purely functional'?
20:20:32 <dibblego> listToMaybe = safeHead
20:20:32 <EvanR7> > let x:_ = [1,2,3] in x
20:20:34 <lambdabot>   1
20:20:43 <coldpizza72i> guidj0s: yes
20:20:45 <neworder> ah!
20:20:48 <neworder> Thanks a lot
20:20:49 <guidj0s> coldpizza72i: Then, no.
20:20:50 <EvanR7> > let x:_ = [] in x
20:20:52 <lambdabot>   *Exception: <interactive>:3:5-12: Irrefutable pattern failed for pattern x ...
20:21:08 <EvanR7> a spacecraft just fell out of the sky
20:21:16 <guidj0s> coldpizza72i: In pure languages, there is no insertion, ever. We call 'insert' the operation that returns a new tree, with the given addition.
20:21:37 <startling> guidj0s, ST wishes to have a word you.
20:21:47 <EvanR7> guidj0s: insertion at the beginning of a list better return the same list mostly ;)
20:22:00 <coldpizza72i> guidj0s: i think my question is a bit unclear
20:22:19 <guidj0s> startling: I'm not sure I understand.
20:22:35 <guidj0s> EvanR7: Talking of observable behavior.
20:22:55 <startling> guidj0s, in the ST monad, you can do actual modifications
20:23:11 <coldpizza72i> guidj0s: other then the fact that it is returning a completely new tree does the approach the insert function takes to decide where the new element is to go any different then in imperative languages
20:23:11 <geekosaur> you may have just corrected what startling was pointing to
20:23:13 <guidj0s> startling: We're talking about purely functional settings.
20:23:25 <dibblego> startling: that is not a Tree, but a STRef Tree
20:23:34 <guidj0s> coldpizza72i: The algorithm is the same, regardless.
20:23:49 <geekosaur> (ST can do destructive modification internally as long as what gets exposed to the outside-of-ST world is indistibguishable from a pure modification)
20:24:02 <startling> dibblego: fair enough
20:24:34 <guidj0s> coldpizza72i: See Chris Okasaki's `Purely Function Data Structures`.
20:25:05 <guidj0s> coldpizza72i: It's dense reading, but covers implementations of classic ADTs in purely functional settings.
20:25:33 <coldpizza72i> guidj0s: i just wasn't sure if anything fancy was going on with his balance function because it looks a bit obfuscated
20:26:13 <coldpizza72i> guidj0s: your saying that it does rotations etc to keep the RB properties as any imperative language would do correct?
20:26:31 <guidj0s> coldpizza72i: It maintains the red-black invariants.
20:27:00 <coldpizza72i> guidj0s: but using the same methods that imperative languages use to maintain them correct?
20:27:13 <dibblego> no, those methods look very different, in particular, their type
20:27:25 <guidj0s> coldpizza72i: Not sure what you mean by 'method'.
20:27:42 <dibblego> inserting at the front of a list has the type :: a -> [a] -> [a] rather than a -> [a] -> ()
20:29:37 <coldpizza72i> guidj0s: If i read the section on red black trees here: http://en.wikipedia.org/wiki/Introduction_to_Algorithms will it be doing the same things under the hood that chris okaskis implementation does?
20:29:41 <coldpizza72i> more or less
20:30:20 <guidj0s> coldpizza72i: To answer definitely, I'd have to read that entry, and re-read Chris'...
20:30:37 <guidj0s> coldpizza72i: Why's that a problem, though?
20:31:00 <guidj0s> coldpizza72i: As far as I can remember, he lays out the invariatns neatly and explains the maintenance.
20:32:09 <coldpizza72i> guidj0s: i need to give a presentation on how red black trees work in my functional class,,, but I'm concerned if i read basic algorithms books it will be completely different algorithms
20:33:34 <guidj0s> Sounds like you need to study different ways of doing it.
20:34:18 <dibblego> why don't you just write one? I'm sure you could get help
20:39:17 <shachaf> There should be a law against calling a binary tree "BTree".
20:39:32 <guidj0s> Hehe.
20:43:44 <applicative> coldpizza72i:  check out rampions avant garde redblack trees https://gist.github.com/2660297
20:43:48 <applicative> https://gist.github.com/2659812
20:48:51 * hackagebot type-level-natural-number 1.1.1 - Simple, Haskell 2010-compatible type level natural numbers  http://hackage.haskell.org/package/type-level-natural-number-1.1.1 (GregoryCrosswhite)
20:51:09 <shachaf> RULES are weird.
20:51:55 <Nereid> abolish all RULES!
20:52:02 <shachaf> Oh, this rule is only firing when I give my module a name.
20:52:09 <shachaf> It can be any name, even Main.
20:56:40 <ivanm> shachaf: is it just your rule, or any rule that fails to fire if it's defined in an unnamed module?
20:56:50 <shachaf> My rule.
20:57:28 <ivanm> interesting
21:02:58 <neworder> I was looking at the definition of zipWith
21:03:36 <neworder> I understand the first line where it says, zipWith z (a:as) (b:bs) = z a b : zipWith z as bs
21:04:05 <neworder> but I don't understand this part, zipWith _ _ _ = []
21:04:13 <neworder> Why do you even need it
21:04:35 <shachaf> @let neworder'sZipWith z (a:as) (b:bs) = z a b : zipWith z as bs
21:04:37 <lambdabot>  Defined.
21:04:46 <shachaf> > neworder'sZipWith (+) [1,2,3] [4,5,6]
21:04:48 <lambdabot>   [5,7,9]
21:04:54 <Nereid> neworder: explain
21:04:54 <shachaf> Er.
21:04:56 <shachaf> @undefine
21:04:56 <Nereid> er
21:04:59 <ivanm> neworder: what do you do when either the first or second list is empty?
21:05:00 <Nereid> shachaf: explain.
21:05:02 <Nereid> oh.
21:05:03 <shachaf> @let neworder'sZipWith z (a:as) (b:bs) = z a b : neworder'sZipWith z as bs
21:05:04 <Nereid> hahaha.
21:05:05 <lambdabot>  Defined.
21:05:06 <shachaf> > neworder'sZipWith (+) [1,2,3] [4,5,6]
21:05:08 <lambdabot>   [5,7,9*Exception: <local>:1:1-69: Non-exhaustive patterns in function newor...
21:05:14 <neworder> Ah!
21:05:17 <neworder> I see =)
21:05:18 <ivanm> neworder: you need to stop your recursion at some point!
21:05:27 <shachaf> neworder: You should get into the habit of trying these things out in ghci! :-)
21:05:28 <neworder> Hmm right
21:05:32 <ivanm> note that defining it in this way also means if one list is longer than the other, ignore the rest of the longer lists
21:05:36 <neworder> Haha, alright!
21:05:53 <shachaf> ivanm: Or that if the second list is undefined, it won't be used at all.
21:06:19 <ivanm> shachaf: you mean the rest of the second list?
21:06:29 <ivanm> > zipWith (+) [1,2,3] undefined
21:06:29 <shachaf> I mean the second list.
21:06:31 <lambdabot>   *Exception: Prelude.undefined
21:06:36 <Nereid> > zipWith (+) [] undefined
21:06:38 <lambdabot>   []
21:06:47 <shachaf> Well, yes, I forgot to specify that bit. :-)
21:06:49 <ivanm> oh, when it gets to that rule
21:06:56 <shachaf> Anyway, people use that fact all the time.
21:06:58 <Nereid> > zipWith (+) undefined []
21:07:00 <lambdabot>   *Exception: Prelude.undefined
21:07:07 <neworder> I'm curious, why is Haskell very popular
21:07:08 <ivanm> which people? >_>
21:07:17 <neworder> The number of people in the channel is one of the highest
21:07:19 <ivanm> neworder: it is?  by most indications it _isn't_ all that popular
21:07:20 <Nereid> I didn't know haskell was very popular
21:07:20 <shachaf> @let foo x = zip x (tail x)
21:07:22 <lambdabot>  Defined.
21:07:23 <shachaf> > foo []
21:07:23 <ivanm> oh, #haskell?
21:07:25 <lambdabot>   []
21:07:31 <ivanm> because people that tend to use Java, etc. don't hang around in IRC :p
21:07:35 <Nereid> haha
21:07:43 <ivanm> shachaf: ahhh, right
21:07:47 <Iceland_jack> Because they have jobs
21:07:49 * Iceland_jack ducks
21:07:51 <ivanm> never thought about that problem with zip`ap`tail
21:07:57 <ivanm> Iceland_jack: yeah :(
21:08:08 <neworder> haha ok
21:08:11 <shachaf> ivanm: That's what you get for not using Agda!
21:08:25 <Nereid> ivanm: yeah I noted that luckiness earlier.
21:08:31 <Nereid> who was it who suggested zip `ap` drop 1
21:08:43 <ivanm> shachaf: I'm having enough problem with "how do I explain my Haskell implementation being 30x slower than a possible C one" without using Agda!
21:08:58 <ivanm> Nereid: doesn't quite have the same ring to it
21:09:03 <Nereid> true
21:09:13 <shachaf> Nereid: Was it me?
21:09:29 <Nereid> shachaf: possibly
21:09:33 <shachaf> The logs confirm it.
21:09:51 <ivanm> I'm sure zip`ap`tail gets used often enough that adding it to some library somewhere would probably be a good idea
21:09:53 <Nereid> then it must have been.
21:10:13 <shachaf> zipWith`ap`tail
21:10:23 <dibblego> s/zipWith/liftA2
21:10:45 <Nereid> :t liftA2 `ap` tail
21:10:46 <shachaf> \f->zipWith f`ap`tail
21:10:46 <lambdabot>     Couldn't match expected type `a0 -> b0 -> c0'
21:10:47 <lambdabot>                 with actual type `[a1]'
21:10:47 <lambdabot>     Expected type: (a0 -> b0 -> c0) -> f0 a0
21:10:51 <shachaf> @pl \f->zipWith f`ap`tail
21:10:51 <lambdabot> (`ap` tail) . zipWith
21:11:05 <pordan30> according to several source, the optimal package for working with lenses is o'conner and kmett's data-lens package. is there a recommended resource for learning the pragmatic and internal aspects of this package?
21:11:10 <shachaf> @pl \f x -> zipWith f x (tail x)
21:11:10 <lambdabot> (`ap` tail) . zipWith
21:11:13 <Nereid> pordan30: no, use lens
21:11:27 <shachaf> pordan30: No, it's "lens".
21:11:29 <shachaf> data-lens is the old one.
21:11:46 <shachaf> lens has a lot more documentation. :-)
21:11:48 <shachaf> http://hackage.haskell.org/package/lens
21:12:05 <Nereid> it has a lot more everything
21:12:24 <shachaf> Nereid: As of today it has a lot more unsafeCoerce.
21:12:29 <Nereid> oh my, where
21:12:33 <shachaf> Everywhere!
21:12:39 <pordan30> nereid, shachaf: that is a lot of documentation, thanks.
21:12:42 <Nereid> all over? D:
21:12:52 <shachaf> +mutator# :: (a -> b) -> a -> Mutator b
21:12:52 <shachaf> +mutator# = unsafeCoerce
21:13:07 <pordan30> it remains template-haskell-less, however, as was data-lens (or so i have been told)?
21:13:11 <Nereid> shachaf: why's it so?
21:13:16 <shachaf> pordan30: No, it has TH.
21:13:34 <Nereid> it has everything
21:13:36 <Nereid> and more
21:13:37 <shachaf> Nereid: How would you write (Mutator .)?
21:13:46 <pordan30> in the interface or internally? (i should just read the documentation, now)
21:13:52 <Nereid> shachaf: why not (Mutator .)?
21:13:57 <shachaf> That is, how would you write (Mutator . f) such that it compiles down to f.
21:14:00 <shachaf> Rather than to (\x -> f x)
21:14:01 <Nereid> ah
21:14:08 <Nereid> oh.
21:14:17 <Nereid> what was wrong with \x -> f x again?
21:14:23 <shachaf> Well, it changes strictness.
21:14:25 <Nereid> oh yeah that bug
21:14:33 <shachaf> Ideally you want (over mapped) === fmap
21:15:37 <shachaf> So you can do (#) :: (b -> c) -> (a -> b) -> a -> c; f # g = f `seq` g `seq` \x -> f (g x)
21:15:49 <shachaf> But GHC has trouble strictness-analyzing and inlining it.
21:16:04 <shachaf> So you write lots of specialized function that look like (Mutator #) but act like unsafeCoerce.
21:17:34 <shachaf> Oh, this is weird.
21:17:53 <shachaf> (#) can be used both as a symbol and as part of an non-symbol identifier.
21:17:54 <applicative> member:pordan30 you dont have to use TH to use the lens package, there's  just a module that makes it easy to make lenses for your own types.
21:18:07 <applicative> pordan30: rather
21:19:05 <pordan30> applicative: that's good to know; the documentation and interface is surprisingly accessible, given the implementation :)
21:20:11 <applicative> the pong example is surprisingly helpful https://github.com/ekmett/lens/blob/master/examples/Pong.hs It does  use the TH incantation to avoid the inevitable boilerplate
21:22:30 <pordan30> applicative: thanks. i'll work through the pong example after finishing reading the introduction.
21:25:08 <ivanm> shachaf: so is the problem the usage of # as the operator?
21:25:50 <shachaf> ivanm: ?
21:25:53 <shachaf> This is unrelated to the bug.
21:26:00 <shachaf> Just a funny feature of GHC with MagicHash
21:26:19 <ivanm> ahhh, right
21:27:14 <sclv> @quote aztec
21:27:15 <lambdabot> quicksilver says: zip`ap`tail - the Aztec god of consecutive numbers
21:42:11 <startling> So I've got a zipper and some Simple Isos that shift the focus of the zipper.
21:42:47 <startling> data Direction = Ahead | Back; shift :: Direction -> Simple Iso (Zipper a) (Zipper a)
21:43:13 <startling> from this, I've derived one :: Direction -> Simple Lens (Zipper a) a
21:43:37 <startling> which is `one d = shift d . focus'
21:44:12 <startling> however, if I do `one Ahead %~ someFn $ myZipper', it doesn't 'un-shift' afterwards. Is there a way I can make it do that?
21:45:47 <ezyang> danharaj: poke back
21:49:19 <coldpizza72i> are splay heaps and splay trees the same thing?
21:50:39 <shachaf> https://en.wikipedia.org/wiki/Splay_heap suggests an answer.
21:52:13 <shachaf> That's a lot of C code for an article, don't you think, Wikipedia?
21:52:30 <startling> shachaf: at least it's not wikipedia's brand of pseudocode
21:52:58 <startling> that stuff is useless.
21:53:18 <danharaj> ezyang: I have an issue where if I {-# INLINE #-} a function, GHC goes bananas and Floats things until it produces 800,000 terms and runs out of memory.
21:53:50 <shachaf> That sounds more like it...
21:53:52 <shachaf> Doubles things.
21:54:14 <startling> groan.
21:54:36 <ivanm> *sigh* I got bitten by ghc-pkg changing flags :s
21:55:00 <ezyang> danharaj: That sounds eminently bisectable
21:55:40 <danharaj> ezyang: is there a way to get GHC to output what terms it is coming up with while it simplifies?
21:55:53 <ezyang> Alternatively, you could try toggling -ddump flags, -ddump-simpl-phases in particular
21:56:01 <danharaj> ezyang: danke
21:56:17 <ezyang> -dverbose-core2core also works pretty good
21:56:23 <startling> I guess my more general question is: how do I make a lens that runs an isomorphism forward on the input and runs it backwards on the output?
21:56:27 <ezyang> But honestly, I'd just delete half of your program and see if it still nonterminates
21:56:36 <startling> haha
21:57:20 <danharaj> ezyang: yeah I have to distill a simplest case eventually. :P
21:57:34 <danharaj> generally is this a caveat to mind when inlining or is it a GHC bug?
21:59:29 <ezyang> danharaj: Generally if you have a compiler bug a minimal test case is really good
21:59:34 <ivanm> why is there no time 1.4.1 on hackage?
21:59:46 <ezyang> Even if it's really simple all of the extra cruft can make it hard to see what the problem is
21:59:55 <shachaf> startling: By using an isomorphism?
22:00:23 <danharaj> ezyang: indeed. I'll do that tomorrow. It's a bit late so I'll just poke around and see what I can glean from verbosity.
22:00:40 <startling> shachaf, so someIso x . y will do that?
22:00:50 <Cale> danharaj: Also: maybe try INLINABLE?
22:00:50 <startling> er, someIso . y
22:00:50 <shachaf> Will do what?
22:01:14 <shachaf> I like all the ways GHC has to specify inlining behavior.
22:01:40 <shachaf> No pragma at all, {-# INLINE [stage] #-}, {-# INLINE [~stage] #-}, {-# NOINLINE [stage] #-}, {-# NOINLINE [~stage] #-}
22:01:44 <shachaf> And I guess INLINABLE
22:02:16 <Cale> oh, yeah, you might also put a phase restriction on it
22:02:17 <danharaj> I think -dverbose-core2core might have made ghc outright hang
22:02:42 <ion> {-# MAYBEINLINE [ifyoufeellikeit] #-}
22:03:09 <shachaf> Oh, phase, not stage.
22:03:10 <startling> shachaf: will run the isomorphism forward, then y, then run the isomorphism backwards
22:03:19 <ezyang> danharaj: Oooops :)
22:03:30 <shachaf> startling: I'm not sure what you're asking.
22:04:05 <shachaf> Where do lenses go into it? What's your isomorphism? What are the types of things involved?
22:04:09 <shachaf> ezyang: Are you using any lenses yet?
22:04:29 <danharaj> ezyang: apparently not, in the span of 5 seconds it just allocated 1GB of memory :P
22:04:42 <startling> shachaf, I said all the stuff much earlier; let me write a short example, though
22:04:50 <danharaj> The dump is 122MB.
22:04:52 <shachaf> startling: Oh, I wasn't here earlier.
22:05:40 <startling> shachaf: oh, I understand how my question would be really puzzling, then. :)
22:06:09 <shachaf> Ignore me. I thought that question was on its own.
22:09:11 <ezyang> shachaf: Nope, though I basically know how the simple ones should work
22:09:28 <danharaj> There is this massive function at the bottom of this core output that looks like a waveform with the way the layout undulates.
22:09:34 <ezyang> danharaj: What is the error spew, btw?
22:09:45 <danharaj> ezyang: out of memory
22:09:59 <ezyang> Erm, originally speaking.
22:10:05 <ezyang> (See, this is why you minimize :-)
22:10:15 <danharaj> hm? I'm not sure I understand.
22:11:36 <shachaf> ezyang: What about traversals?
22:11:54 <shachaf> They're great.
22:11:56 <danharaj> funny story: the function that seems to be causing this 'splosion is a traversal :P
22:14:01 <startling> shachaf: here's the full context; I'd appreciate if you could look at it https://gist.github.com/5cbb1119ae0cb2eb2a9f
22:14:53 <shachaf> startling: You know about zippers in lens, by the way, right? :-)
22:15:27 <startling> shachaf: nope! this is a simplification of my type, anyway
22:15:32 <Nisstyre> btw, the xmonad code helped me a lot with zippers
22:15:39 <Nisstyre> (reading it)
22:15:39 <startling> but such a thing might be useful
22:15:51 <startling> Nisstyre: this is more of a lens question than a zipper question
22:15:56 <Nisstyre> fair enough
22:16:15 <shachaf> The lens code will do very magical zippery things.
22:16:39 <shachaf> Anyway, let me see.
22:17:17 <shachaf> What version of lens are you using?
22:17:20 <shachaf> A really old one or something?
22:17:53 <startling> uhhh 2.9
22:17:58 <startling> I guess that's moderately old
22:18:14 <cl_away> shachaf: zippers and lens?
22:18:26 <shachaf> startling: Oh, that's before it started exporting names like "Zipper" and "focus". :-)
22:18:30 <shachaf> cl_away: Yep.
22:18:33 <startling> shachaf: heh
22:18:55 <startling> shachaf: C.L.Zipper does look promising, though, I'll probably use some of that
22:19:05 <Nisstyre> I was going to say, use a more descriptive name than "Zipper"
22:19:07 <startling> but I do need the Directions thing.
22:19:10 <Nisstyre> what does it actually represent here?
22:19:29 <Nisstyre> you're not writing a Zipper library, clearly
22:19:45 <startling> Nisstyre: a one-dimensional roguelike stage. long story
22:20:05 <Nisstyre> startling: well I know you've been working on that
22:20:13 <Nisstyre> but I just wasn't sure what this piece of code does specifically
22:20:55 <Nisstyre> why do you need a Zipper that is all 0s?
22:21:59 <ezyang> shachaf: As in, Traversable?
22:22:15 <shachaf> ezyang: As in Control.Lens.Traversal
22:22:18 <ezyang> danharaj: Yeah, it'd probably something recursive
22:22:20 <shachaf> (But also as in Traversable.)
22:22:31 <startling> Nisstyre: I don't, this is example code. I want a lens on any given coordinate from the origin.
22:22:40 <shachaf> Lens : Functor = Traversal : Applicative
22:23:33 <ezyang> Yeah, haven't used lense traversals yet ;)
22:23:52 <startling> ezyang: lenses *are* traversals
22:24:14 <Nisstyre> lenses are magic to me
22:24:41 <Nisstyre> I have not studied them really, all I know is that they're supposed to be replacing some other features that are considered ugly
22:25:13 <startling> Nisstyre, they're traversals, and you can use traversals as getter/setter pairs for e.g. record fields
22:25:25 <Nisstyre> I see the connection to lenses and zippers, though
22:25:48 <startling> uh
22:25:50 <Nisstyre> it would be rather cool to have a way to automatically differentiate something into a zipper, and then have a lens created for that
22:26:10 <Nisstyre> I believe this exists, right?
22:27:34 <lightquake> is there a way to pull the traverse 'outside' of the to in world^.monsters.to (traverse f)?
22:27:45 <lightquake> it seems like there should be
22:28:43 <shachaf> Why?
22:28:51 <shachaf> traverse f is just a function
22:29:02 <lightquake> well, right, but given that lenses are all about traversals in the first place
22:29:03 <startling> Nisstyre: what's the connection?
22:29:03 <cl_away> What is %?
22:29:10 <cl_away> :t (%)
22:29:14 <shachaf> flip ($)
22:29:15 <startling> cl_away, flip id
22:29:18 <lightquake> cl_away: rational number division
22:29:28 <lightquake> … wait, what?
22:29:30 <startling> lightquake: not in lens it isn't!
22:29:34 <lightquake> oh
22:29:58 <cl_away> Ah, basically allowing x f instead of f x
22:30:26 <cl_away> And right associative.  I like it.
22:30:32 <cl_away> Actually going home now.
22:30:34 <cl_away> :)
22:31:27 <cl_away> Okay.  That zipper library is insane.  oh my god.
22:31:32 <lightquake> so i guess world^.monsters % traverse f is the most idiomatic way to do what i want
22:31:41 <shachaf> That depends on what you want.
22:32:05 <liyang> There's no easy way to combine say _1, _2 :: Simple Setter (a, a) a into a single Setter, is there?
22:32:24 <Ralith> stephenjudkins: flip id doesn't quite work.
22:32:41 <startling> :t \fn -> _1 fn . _2 fn
22:32:45 <startling> err
22:32:49 <startling> no lambdabot. :(
22:32:55 <lightquake> f :: Entity -> Rand StdGen [EntityAction]; my world contains an IntMap of Entities, and i want to get a Rand StdGen (IntMap [EntityAction])
22:33:24 <startling> shachaf: any ideas?
22:34:06 <shachaf> Oh, right, the Zipper thing.
22:34:35 <startling> :)
22:37:26 <lightquake> but basically my suspicion that you can pull the traverse out is because lenses are *built* around traversals in the first place
22:37:30 <lightquake> well, edwardk lenses
22:37:54 <liyang> startling: that's a Setting, not a Setter right?
22:38:09 <startling> liyang: what is?
22:38:19 <liyang> startling: oh nevermind.
22:38:35 <liyang> Where is lambdabot? D:
22:39:33 <shachaf> startling: Oh, well, you're just using the isomorphism in one direction.
22:39:49 <startling> shachaf: hence my question: how do you use it in both directions?
22:44:06 <shachaf> Oh, this isn't what I thought.
22:47:28 <startling> shachaf: does my problem make sense, at least?
22:47:46 <statusfailed> hmmm, is this package dead/dying? http://hackage.haskell.org/package/regex-pcre-builtin-0.94.2.1.7.7
22:47:59 <startling> I guess I might need to wait until edwardk comes around. :(
22:48:06 <statusfailed> it doesn't build on GHC 7.6 because of this bug: http://hackage.haskell.org/trac/ghc/ticket/5610
22:51:19 <shachaf> startling: I don't think that's how you're supposed to use isomorphisms.
22:51:41 <shachaf> I mean, your isomorphism is made up of invalid lenses.
22:51:46 <shachaf> Or, er, those aren't lenses.
22:53:52 <shachaf> Oh, no, those are lenses.
22:53:54 <shachaf> But just by accident.
22:54:13 <shachaf> Because it can return any type.
22:55:37 <shachaf> shift Ahead :: (Zipper a -> b) -> Zipper a -> b
22:55:53 <shachaf> b is unifying with f (Zipper a),
22:55:56 <shachaf> s/.$//
22:56:55 <startling> shachaf, what's wrong with that?
22:57:21 <startling> Isn't that stronger than what's necesary for a lens?
23:03:13 <shachaf> startling: Oh.
23:03:27 <shachaf> shifted d = iso (shift d) (shift (invert d))
23:03:51 <shachaf> where shift Ahead (Zipper (a:as) c (d:ds)) = Zipper (c : a : as) d ds; shift Back (Zipper (a:as) c (d:ds)) = Zipper as a (c : d : ds)
23:04:27 <shachaf> That'll build an actual isomorphism of the sort you want.
23:05:33 <shachaf> The fn $ business got us off-track. :-)
23:05:35 <startling> shachaf: and then how would I use that?
23:06:13 <shachaf> shifted Ahead . focus .~ 13 $ zeroes
23:06:26 <shachaf> Or however you were doing it.
23:06:53 <shachaf> What you were doing was making an isomorphism between pairs of functions, and it happened to unify with lenses accidentally.
23:07:34 <startling> oh, I forgot to get rid of fn $
23:07:58 <shachaf> A type signature on shift would help you clear things up. :-)
23:08:07 <shachaf> I don't know where the fn $ bit came from.
23:08:34 <shachaf> This should be better documented. I haven't worked with this part of the code before.
23:09:50 <startling> shachaf: I'm getting "couldn't match expected type `Zipper a -> Zipper a' with actual type `Zipper a0' in  the return type of a call to `shift'.
23:10:11 <startling> oh, I see what's wrong, sorry
23:10:56 <startling> shachaf: works exactly as expected, thanks a bunch.
23:11:09 <shachaf> Oh, then I don't need to @paste my version. :-)
23:11:18 <startling> nope!
23:11:59 <shachaf> By the way, please do the (a:as) (b:bs) thing. Makes it so much easier to read. :-)
23:12:09 <shachaf> But you should look into the Zipper thing in lens!
23:12:16 <startling> shachaf: yeah, I should
23:12:26 <startling> my problem is that I *need* the Direction thing though
23:12:35 <startling> but I'll figure something out.
23:21:02 <startling> shachaf, just made this change to my real code, everything works like a charm. Thanks again.
23:23:55 * hackagebot resourcet 0.4.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.4.1 (MichaelSnoyman)
23:31:52 <lightquake> is there a nice way to write \(a, b) (c, d) -> (a+c, b+d)?
23:32:24 <shachaf> No.
23:32:26 <startling> > (1, 2) + (2, 1)
23:32:55 <startling> (you need a Caleskell Num instance)
23:33:24 <shachaf> @pl \(a, b) (c, d) -> (a+c, b+d)
23:33:46 <startling> where the hell is lambdabot
23:33:52 <shachaf> dmwit!
23:39:37 <Sculptor> it's on a lunch break
23:46:07 <lightquake> i wish there was an alias for pack.show
23:48:28 <Nereid> argh ctrl-w
23:50:54 <shachaf> @yarrgh
23:51:02 <ivanm> does Simon Meier hang out here?
23:51:20 <ivanm> wondering why blaze-builder hasn't been bumped to allow bytestring-0.10, when the other blaze packages have :s
23:54:53 <ivanm> gah, nvm, I misread <1.0 as <0.10
23:55:25 <Nereid> do we not have some (a -> b, a' -> b') -> (a,a') -> (b,b')?
23:56:22 <Jafet> :t both
23:56:42 <Jafet> both :: (a -> b) -> (a, a) -> (b, b)
23:57:10 <Nereid> yes, that's not what I want.
23:57:15 <Nereid> :v
23:57:16 <Jafet> Yes, Jafet, that's totally wrong.
23:57:47 <shachaf> Jafet: That's not both!
23:58:06 <Jafet> @hoogle both
23:58:09 <shachaf> both :: Traversal (a,a) (b,b) a b
23:59:10 <Jafet> Ok, figure out which combination of lenses does that.
23:59:50 <Nereid> expanding out: both :: Control.Applicative.Applicative f => (a -> f b) -> (a, a) -> f (b, b)
23:59:54 <Nereid> heh ghci
23:59:55 <shachaf> over both :: (a -> b) -> (a,a) -> (b,b)
