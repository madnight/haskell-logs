00:00:49 <Urthwhyte> I pray this isn't offtopic here - is there some sort of Haskell equivalent to VimClojure?
00:04:00 <mm_freak_> Urthwhyte: don't know the answer, just wanted to tell you it's not offtopic =)
00:04:43 <Urthwhyte> mm_freak_: Cheers, I'll just search around a bit; it's not quite as important with Haskell as with clojure, fortunately
00:06:36 <mm_freak_> what is it anyway?
00:07:57 <lpvb> Urthwhyte: vim2hs or haskell-mode for vim?
00:07:58 <Urthwhyte> It enables you to have a repl open in another buffer and generally interact with your code as you write it
00:08:22 <lpvb> https://github.com/lukerandall/haskellmode-vim
00:09:09 <Urthwhyte> evaluate top-level forms, lookup documentation, generally just makes it easier to stay within the editor and not need to have several panes open
00:09:52 <lpvb> I don't think there's top-level forms simply because haskell is not clojure
00:09:58 <lpvb> it has haddock integration
00:10:45 <lpvb> I don't use it though, I just use 'screen' :sh + xmonad
00:11:17 <Urthwhyte> Of course, generally just something that will let me find docs and such and create a split; those two you linked look great
00:11:40 <Urthwhyte> If only one could replace OSX's window manager; I sorely miss my xmonad config :(
00:12:55 <carmin> can someone point me some simple random function i could get a number between 0 - 255. I cant call the random functions while compiling, only on interpreter.
00:15:19 <koala_man> carmin: are you getting a compiler error about IO Something?
00:15:38 <shachaf> carmin: You should read an introduction to IO in Haskell.
00:15:39 <carmin> yup
00:15:42 <shachaf> @google introduction to IO in Haskell
00:15:45 <lambdabot> http://www.haskell.org/haskellwiki/Introduction_to_IO
00:15:45 <lambdabot> Title: Introduction to IO - HaskellWiki
00:16:19 <carmin> im trying to make a random rgb color
00:16:37 <`nand`> There should be a Word8 instance for Random
00:16:38 <carmin> im gonna take a look, thanks shachaf
00:17:45 <carmin> word8 `nand`?
00:18:03 <shachaf> Word8 is a number between 0 and 255.
00:18:07 <shachaf> But that's not really relevant here.
00:18:16 <shachaf> You need to understand how IO works in the first place first. :-)
00:18:25 <shachaf> Evaluating functions can never do I/O.
00:18:59 <`nand`> (you can generate pseudorandom numbers without ever touching I/O, mind. That being said, it's probably best you still understand how IO works in Haskell first)
00:19:02 <carmin> so long story short, theres no way without unsafe?
00:19:20 <shachaf> No.
00:19:28 <koala_man> long story short, you can do it, it just requires reading the long story
00:19:33 <shachaf> You just do it in IO.
00:19:41 <shachaf> It's the same as getting input from the user. :-)
02:01:40 <atriq> That HLearn stuff looks interesting
02:06:15 * hackagebot LambdaHack 0.2.6 - A roguelike game engine in early and active development  http://hackage.haskell.org/package/LambdaHack-0.2.6 (MikolajKonarski)
02:07:03 <newera> I am trying to infer the type of the following function
02:07:05 <newera> \f g -> g (f g)
02:07:34 <newera> How do I go about inferring the types
02:07:42 <atriq> Look at "g"
02:07:54 <atriq> It takes the result of "f g", and gives you something else
02:08:16 <atriq> So its type is "a -> b", where a is the result of "f g" and b could be anything
02:08:33 <atriq> Now look at "f"
02:08:49 <atriq> It takes what we know to be "a -> b", and gives you an "a"
02:08:57 <atriq> So, it's "(a -> b) -> a"
02:09:20 <atriq> So the whole thing is "((a -> b) -> a) -> (a -> b) -> b"
02:09:22 <atriq> :)
02:09:36 <newera> wow
02:09:59 <shachaf> Hmm, haven't we had this exact function before?
02:10:00 <atriq> Unless I've made a stupid mistake
02:10:10 <newera> g takes the result of "f g", and gives you something else
02:10:13 <darkf> shachaf: why not? it looks to be the Y combinator
02:10:16 <atriq> :t \f g -> g (f g)
02:10:18 <lambdabot> ((t1 -> t) -> t1) -> (t1 -> t) -> t
02:10:47 <newera> Yes shachaf, just wanted to refresh that I'm inferring the right way
02:10:56 <SoulRaven> i have a offtopic question, anybody knows any applicaion that combine multiple cloud storage solutions? like, drobox, amazon, gdrive, yandex, U1, skydrive?
02:10:58 <shachaf> darkf: No.
02:11:17 * hackagebot Allure 0.4.6 - Near-future roguelike game in very early and active development  http://hackage.haskell.org/package/Allure-0.4.6 (MikolajKonarski)
02:11:18 <atriq> newera, did I help at all?
02:11:28 <newera> yes atriq! Thanks
02:12:41 <atriq> :)
02:14:12 <newera> Just curious
02:14:25 <newera> Is this in any way related to fix f = f (fix f)
02:14:54 <atriq> :t fix f
02:14:56 <lambdabot> (Show a, FromExpr a) => a
02:15:00 <atriq> :t fix
02:15:02 <lambdabot> (a -> a) -> a
02:15:29 <shachaf> Not really.
02:15:35 <shachaf> fix f = f (f (f (f (f (f (f (f ...
02:16:36 <newera> ok
02:17:15 <darkf> what's the difference?
02:17:17 <`nand`> fix (\f g -> g (f g)) = fix ?
02:17:58 <shachaf> Yep.
02:18:17 <darkf> I don't get it, how does fix differ from \f g -> g $ f g ?
02:18:25 <shachaf> > fix (1:)
02:18:27 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
02:18:34 <shachaf> > (\f g -> g (f g)) (1:)
02:18:36 <lambdabot>   Couldn't match expected type `t1 -> t0' with actual type `[a0]'
02:19:13 <shachaf> OK, maybe it's a bit related, then.
02:19:23 <`nand`> > let x = \f g -> g (f g) in x undefined (1:)
02:19:25 <lambdabot>   [1*Exception: Prelude.undefined
02:19:29 <`nand`> > let x = \f g -> g (f g) in x (x undefined) (1:)
02:19:30 <shachaf> Good point, `nand`
02:19:31 <lambdabot>   [1,1*Exception: Prelude.undefined
02:19:35 <shachaf> Oh no, you grew another `
02:19:38 <shachaf> I hate those :-(
02:19:50 <atriq> :t fix fix
02:19:52 <lambdabot>     Occurs check: cannot construct the infinite type: a0 = a0 -> a0
02:19:52 <lambdabot>     Expected type: (a0 -> a0) -> a0 -> a0
02:19:52 <lambdabot>       Actual type: (a0 -> a0) -> a0
02:21:14 <`nand`> shachaf: `nand` has better symmetry than nand`, not to mention looking like infix application
02:21:26 <`nand`> and ‘nand’ was taken on this service :(
02:27:05 <shachaf> You should take a name without `s.
02:27:11 <shachaf> Much better.
02:34:40 <charliesome> shachaf: on the plus side, `nand` can be tab completed pretty easily
02:34:43 <neworder> \f g -> g (f g)
02:35:03 <neworder> For this function, It's an anonymous function which takes in 2 parameters f and g
02:35:17 <neworder> So is it incorrect to say that f is applied to g?
02:35:39 <charliesome> neworder: g is applied to the result of applying f to g
02:35:45 <neworder> (looking at the part before the arrow)
02:35:54 <charliesome> o
02:35:56 <shachaf> Yes, the part before the arrow is just arguments.
02:36:00 <shachaf> \f -> \g -> g (f g)
02:36:20 <neworder> Ah I See
02:36:23 <neworder> thanks
02:36:24 <typoclass> neworder: no, before the arrow is only defining the two names, nothing is being applied there
02:36:45 <neworder> alright
02:49:26 <Kosta> I'm in cabal hell. Could someone help me get out of there?
02:49:43 <atriq> What are you trying to install?
02:49:51 <Kosta> I installed warp, then yesod using cabal-install
02:50:09 <Kosta> cabal warned me that installing yesod might break exising warp. I said yeah whatever
02:50:22 <neworder> Is the cons operator in Haskell right associative?
02:50:23 <anssik> any idea why I get this error: http://hpaste.org/78209 when I try to use "cabal-dev ghci" on OSX?
02:50:50 <Kosta> Now when trying to compile a program that uses warp, that previously worked, I get:
02:50:50 <Kosta> Couldn't match expected type `resourcet-0.4.0.2:Control.Monad.Trans.Resource.ResourceT IO Response' with actual type `ResourceT IO Response'
02:50:57 <ozgura> neworder: try ":i (:)" in ghci
02:51:36 <fmap> Kosta: try `cabal install warp yesod'
02:52:02 <fmap> as a general advice: you shouldn't install such packages one by one
02:52:18 <Kosta> I wanted to first play around with yesod :)
02:52:22 <Kosta> err with warp
02:52:40 <Kosta> it says: cabal: The following packages are likely to be broken by the reinstalls: yesod-platform-1.1.4.1
02:53:29 <Kosta> yesod-1.1.2 (reinstall) changes: warp-1.3.4.1 -> 1.3.5
02:53:31 <neworder> data [] a = ... | a : [a]
02:53:37 <neworder> Don't understand the ... part
02:55:02 <shachaf> That's not real syntax.
02:55:10 <shachaf> You can ignore it.
02:55:20 <shachaf> Oh, this is about ghci
02:55:27 <Kosta> shouldn't I just uninstall warp-1.3.4.1?
02:55:28 <shachaf> ghci only shows you one constructor.
02:56:27 <Kosta> (how do you uninstall something with cabal?)
02:56:29 <neworder> So in short, (:) is right associative right? =) I'm pretty sure, just confirming
02:56:30 <neworder> haha
02:57:19 <shachaf> Yes.
02:57:25 <shachaf> Kosta: You don't.
02:57:30 <Kosta> great
02:57:33 <sw2wolf> From what i know, you cannot uninstall sth using cabal
02:57:34 <shachaf> You can ghc-pkg unregister to unregister a package, though.
02:58:02 <sw2wolf> ghc-pkg unregister & rm -fr :)
02:58:56 <Kosta> what exactly do I rm -rf?
02:58:58 <fmap> Kosta: problem is with `resourcet' package, not warp itself actually
02:59:16 <fmap> (you have two versions of resourcet installed)
02:59:23 <sw2wolf> ~/.ghci and ~/.cabal
02:59:31 <Kosta> yeah I'm doing import Data.Conduit (ResourceT)
02:59:38 <sw2wolf> ~/.ghc && ~/.cabal
03:00:00 <fmap> Kosta: what `ghc-pkg list resourcet' says?
03:00:24 <Kosta> WARNING: there are broken packages.  Run 'ghc-pkg check' for more details.
03:00:24 <Kosta> /usr/local/Cellar/ghc/7.4.2/lib/ghc-7.4.2/package.conf.d
03:00:24 <Kosta> /Users/kwelke/.ghc/x86_64-darwin-7.4.2/package.conf.d
03:00:24 <Kosta>    resourcet-0.4.0.2
03:00:24 <Kosta>    resourcet-0.4.3
03:01:23 <Kosta> ghc-pkg check 2>&1 | wc -l says 323
03:02:08 <fmap> oh well
03:02:19 <Kosta> I installed haskell-platform using brew
03:02:25 <Kosta> (on osx)
03:02:28 <Kosta> bad idea?
03:03:21 <fmap> I guess rm -rf ~/.ghc ~/.cabal; cabal install yesod-platform is faster way to solve problems then :[
03:03:37 <Kosta> ok sounds good :)
03:03:53 <shachaf> You might want to mv instead of rm
03:03:57 <k0ral> anyone familiar with the cmdlib options parsing utility ?
03:04:00 <shachaf> Or at least save .cabal/config if you have one.
03:04:10 <Kosta> shachaf: too late :)
03:04:11 <k0ral> I'm getting the exception "BUG: flag_set in Record used with wrong value type"
03:04:21 <Kosta> shachaf: Yes I will
03:04:37 <Kosta> (still had that open in a text editor)
03:05:21 <Kosta> is it bad style to let cabal's install-dirs user prefix and install-dirs global prefix point to the same dir?
03:05:48 <shachaf> Yes.
03:06:11 <shachaf> Why are you doing global installs?
03:06:13 <shachaf> Don't do that.
03:06:32 <Kosta> homebrew installs haskell-platform to /usr/local, which is user-writable
03:06:50 <Kosta> then, when I do cabal update, it tells me to do cabal install cabal-install
03:07:01 <Kosta> which installs into ~/.cabal/bin
03:07:12 <Kosta> I just want ONE place for ALL packages
03:10:24 <Kosta> ok am I too stupid or is cabal's user documentation non-existent
03:10:43 <Kosta> by "user" i mean someone running "cabal install", not someone trying to create a package
03:10:44 <shachaf> Kosta: You shouldn't do that.
03:10:53 <shachaf> Install things to ~/.{cabal,ghc}
03:11:00 <shachaf> Let the global installation be global.
03:11:08 <shachaf> /usr/local oughtn't be user-writable, anyway.
03:11:29 <Kosta> shachaf: That's how brew on osx works best
03:11:36 <shachaf> OK.
03:11:42 <shachaf> Then leave /usr/local however you want it.
03:11:53 <shachaf> Installing things for the user is how cabal works best. :-)
03:12:06 <notdan> Is it a bad idea to use -XFlexibleInstances?
03:12:13 <shachaf> Probably not.
03:12:18 <notdan> K, thx
03:12:18 <Kosta> yeah and then I end up with two cabal binaries.
03:12:18 <shachaf> But maybe.
03:12:25 <shachaf> Kosta: Just use the one in ~
03:12:36 <Kosta> ok I will try
03:12:48 <shachaf> notdan: Is it a bad idea to compute the length of a list?
03:13:08 <Kosta> so that means cabal update -> cabal install -> set path to ~/.cabal/bin -> cabal update
03:13:30 <notdan> shachaf: nope
03:13:35 <shachaf> Kosta: Yep.
03:13:45 <shachaf> You can just always have ~/.cabal/bin in your PATH
03:13:47 <notdan> shachaf: but I don't know uch about GHC extensions
03:14:01 <shachaf> notdan: My point is that it depends on what you're doing.
03:15:17 <Saizan> FlexibleInstances per se is fine, some of the instances it allows might overlap with others you might want, but you'll be told if that happens
03:18:15 <k0ral> https://gist.github.com/4143155
03:18:25 <k0ral> would anyone please tell me why this code doesn't work ?
03:18:41 <Kosta> ok, I'm re-installing yesod-platform
03:18:50 <Kosta> I'm working as a Java software developer by day. Might I say that your language is much better than Java but your packaging is really, really bad?
03:19:14 <Saizan> k0ral: which lib are you using?
03:19:27 <k0ral> Saizan: cmdlib
03:19:55 <k0ral> (& default)
03:20:53 <Saizan> Kosta: it has its flaws and there's devel work going into that but really, really bad is a bit much :P it's also trying to address an harder problem than most
03:21:05 <Saizan> ah, it was in the paste
03:22:00 <Kosta> I think Maven's (of Java fame) approach is right: Not to install stuff globally but to let every package explicitly say what they need. I think you're kind of trying to do that with virtualenv, I haven't looked into it
03:22:28 <Kosta> But I installed two related packages and was completely lost. That shouldn't happen :)
03:23:37 <typoclass> Kosta: yes, cabal has problems. but luckily, the guys are aware of it and are working on it. i heard that the new 1.16 version is already a big step up, and work is continuing
03:23:54 <Kosta> ok, let's hope for the best :)
03:24:14 <alpounet> Kosta, next version of cabal-install will support sandboxes
03:24:54 <alpounet> a bit like cabal-dev/virthualenv, but better
03:36:19 * hackagebot time 1.4.0.2 - A time library  http://hackage.haskell.org/package/time-1.4.0.2 (AshleyYakeley)
03:36:21 * hackagebot ot 0.1.2 - Real-time collaborative editing with Operational Transformation  http://hackage.haskell.org/package/ot-0.1.2 (TimBaumann)
03:47:58 <aranea> Could someone recommend me one particular FRP library? I'm a bit overwhelmed by the amount of them...
03:51:49 <Shapeshifter> While I can follow the examples for Functors and Applicative Functors, I don't really understand how they relate to each other. So a Functor is something that can be mapped over and it implements fmap which takes a 'normal' (a -> a) function and a Functor to produce a new Functor. And an Applicative implements <*> which takes a Functor which contains functions and another Functor which contains normal values to produce another Functor?
03:53:08 <neworder> Is there a difference between let f=(3+) in f 3 and let f=(+3) in f 3
03:53:15 <raek> it lets you apply functions "inside" the applicative functor
03:53:28 <xunatai> neworder: addition is cummutative, so no
03:53:47 <xunatai> commutative*
03:53:48 <Ferdirand> note that fmap = (<*>) . pure
03:53:49 <ramses_> Shapeshifter: for instance with lists, which model non-deterministic computations, you can use applicative to apply a list of functions over a list of values, as if both the calculation of the function to apply as the calculation of the value to apply them too, are non-deterministic
03:54:05 <neworder> Hmm I see, how are they computed then? For the first one
03:54:21 <sipa> (3+) is equal to (+) 3, while (+3) is equal to (\x -> (+) x 3)
03:54:21 <neworder> Can I just replace f in f 3
03:54:24 <ramses_> while with functor you can only apply a deterministic function over a non-deterministic value
03:54:25 <sipa> maybe the first is faster?
03:54:50 <neworder> Ah I see!
03:55:51 <raek> Shapeshifter: fmap has type Functor f => (a -> a) -> f a -> f b. in some sense it turns an "a -> b" function into a "f a -> f b" function
03:56:00 <neworder> Is it kind of intuitive that (+3) is equal to (\x -> (+) x 3)
03:56:04 <shachaf> sipa: I doubt it.
03:56:08 <Shapeshifter> ramses_: I can't wrap my head around the fact that this explanation does not lead to something like this: [(\x y -> x+y),(\x y -> x-y)] <*> [1,2,3] This doesn't work, but this is "a list of functions applied to a list of values".
03:56:18 <shachaf> neworder: (+ 3) ---> (\x -> x + 3)
03:56:21 <raek> Shapeshifter: but what if you want to turn "a -> b -> c" into "f a -> f b -> fc"?
03:56:25 <shachaf> (3 +) ---> (\x -> 3 + x)
03:56:33 <Sintendo> What is the definitive monad tutorial? I've tried 5, still didn't click
03:56:59 <shachaf> Sintendo: Did you see the FAQ?
03:57:00 <sipa> Sintendo: understanding monads is the same as wanting to write a monad tutorial
03:57:01 <raek> Sintendo: do you want to understand how to do I/O, or how monads work in general?
03:57:04 <shachaf> The answer is "don't worry about monads"
03:57:06 <shachaf> @where faq
03:57:07 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
03:57:07 <jesyspa> Shapeshifter: What do you mean with "doesn't work"?
03:57:11 <neworder> Much clearer thanks =)
03:57:14 <Ferdirand> > [(+),(-)] <*> [0,1] <*> [0,10]
03:57:16 <lambdabot>   [0,10,1,11,0,-10,1,-9]
03:57:35 <Ferdirand> looks like it is working fine
03:57:36 <ramses_> Shapeshifter: those functions take two arguments, so you need to supply two lists
03:57:41 <Shapeshifter> Ahhh
03:57:50 <ramses_> >  [(\x y -> x+y), (\x y -> x-y)] <*> [1,2,3] <*> [2,3,4]
03:57:52 <lambdabot>   [3,4,5,4,5,6,5,6,7,-1,-2,-3,0,-1,-2,1,0,-1]
03:57:58 <Shapeshifter> So if I were to use a tertiary function I could supply three lists?
03:58:07 <ramses_> yes
03:58:12 <jesyspa> Well, don't really *need* to; it just returns a list of functions.
03:58:29 <ramses_> if you supply one list, you partially evaluate the functions with one argument
03:58:34 <jesyspa> s/returns/evaluates to/
03:58:42 <raek> Shapeshifter: if you try to use fmap on a "a -> b -> c" function you get "f a -> f (b -> c)", and using only functors you can't "apply the second argument"
03:58:49 <xunatai> [(+3), (+4)] <*> [1, 2]
03:58:52 <raek> since the function is in the functor
03:58:53 <shachaf> ramses_: You probably don't partially evaluate anything. :-)
03:58:54 <ramses_> so if you want a result, you need to supply enough lists to fully evaluate the functions
03:58:55 <xunatai> > [(+3), (+4)] <*> [1, 2]
03:58:57 <lambdabot>   [4,5,5,6]
03:58:58 <Shapeshifter> I see, thanks
03:59:48 <raek> applicative functors split fmap into two parts: pure and (<*>). fmap can then be defined like this: fmap g x = pure g <*> x
03:59:55 <ramses_> shachaf: what do you mean? you'd get a list of partially evaluated functions, wouldn't you?
04:00:19 <shachaf> ramses_: Probably not. Partial evaluation means evaluating a function partially.
04:00:23 <shachaf> There's no evaluation going on here.
04:00:58 <ramses_> @type  [(\x y -> x+y), (\x y -> x-y)] <*> [1,2,3]
04:01:00 <lambdabot> Num a => [a -> a]
04:01:20 <shachaf> You might be looking for the term "partial application".
04:01:28 <shachaf> Though that term doesn't mean very much either.
04:01:30 <ramses_> that expression does construct a list of partially evaluated functions, doesn't it? Or is it just the lazyness that you're referring to
04:01:32 <shachaf> This is just plain application.
04:01:49 <ramses_> ahh, ok, that might be correct :)
04:03:36 <bxx> catch (handleArgs =<< getArgs) handleErrors  -- how come this isn't catching exceptions thrown in handleArgs?
04:04:05 <shachaf> bxx: I don't believe you.
04:04:09 <Ralith> Sintendo: implementing Monad Maybe and Monad List myself worked best for me.
04:04:11 <shachaf> bxx: I'll believe you if you @paste your code. :-)
04:06:55 <jesyspa> Sintendo: For me, comparing to applicatives did the trick.
04:07:33 <ijp> Sintendo: I usually think of "you could have invented monads" as the definitive one, but I presume you've read that already
04:08:03 <aranea> Could someone recommend me one particular FRP library for GUI programming? I'm a bit overwhelmed by the amount of them...
04:08:22 <neworder> >[100,130..140]
04:09:05 <xunatai> > [100,130..140]
04:09:07 <lambdabot>   [100,130]
04:09:25 <fujisan> http://arstechnica.com/information-technology/2012/11/how-is-lazy-evaluation-in-haskell-useful/
04:09:31 <bxx> a
04:09:36 <fujisan> oops wrong channel -_-
04:09:37 <bxx> here, errors not being caught: http://hpaste.org/78210
04:11:00 <neworder> I tried this [100,130..140]
04:11:04 <xunatai> > [100,130..140]
04:11:06 <lambdabot>   [100,130]
04:11:08 <xunatai> you need a space
04:11:11 <neworder> and it returns [100,130]
04:11:14 <neworder> oh
04:11:24 <xunatai> yes, that's correct
04:11:25 <neworder> Whay does it return [100,130]
04:11:41 <xunatai> it takes the difference between the first two, and uses that as the increment
04:11:58 <fujisan> i have a question
04:11:59 <xunatai> > [7,7..100]
04:12:01 <lambdabot>   [7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,...
04:12:09 <xunatai> [7,9,100]
04:12:10 <fujisan> i want to code a brain with haskell
04:12:14 <fujisan> how do i start
04:12:14 <neworder> haha
04:12:14 <xunatai> > [7,9..100]
04:12:16 <neworder> I see
04:12:16 <lambdabot>   [7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,5...
04:12:41 <ion> > takeWhile (<= 100) . iterate (+2) $ 7
04:12:44 <lambdabot>   [7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53,55,5...
04:12:45 <neworder> > [1,5..100]
04:12:47 <lambdabot>   [1,5,9,13,17,21,25,29,33,37,41,45,49,53,57,61,65,69,73,77,81,85,89,93,97]
04:12:54 <ion> > takeWhile (<= 140) . iterate (+30) $ 100
04:12:56 <lambdabot>   [100,130]
04:12:56 <fujisan> =.=
04:13:03 <neworder> > [1,6..100]
04:13:05 <lambdabot>   [1,6,11,16,21,26,31,36,41,46,51,56,61,66,71,76,81,86,91,96]
04:13:13 <fujisan> primes?
04:13:34 <fujisan> nvm
04:14:42 <fujisan> > [1,6,3,9,12,4,16,20,5,25..26]
04:14:44 <lambdabot>   <hint>:1:25: parse error on input `..'
04:15:12 <neworder> let fact x = let prod = foldr (*) 1 in prod [1..x] in fact 10
04:15:50 <fujisan> hmz
04:15:55 <neworder> For this, the scope of prod is till prod [1..x] or fact 10
04:16:13 <fujisan> interesting
04:16:31 <atriq> > fix (\r n -> if n == 0 then 1 else  n * r (n - 1)) 10
04:16:32 <lambdabot>   3628800
04:16:43 <xunatai> @src fix
04:16:44 <lambdabot> fix f = let x = f x in x
04:17:04 <fujisan> haskell is math?
04:17:20 <fujisan> i was watching this woman from my country on youtube
04:17:21 <atriq> Haskell is whatever you want it to be
04:17:25 <Ralith> haskell is candy!
04:17:59 <rtharper> lol Haskell is whatever you want it to be,so true
04:18:05 <rtharper> except dynamically typed
04:18:06 <fujisan> it was interesting she has the gift for math
04:18:09 <fujisan> http://www.youtube.com/watch?v=LSxqpaCCPvY
04:18:47 <bxx> can someone tell me why exception isn't being caught: http://hpaste.org/78210
04:18:56 <fujisan> she is a girl from a small traditional village where they are mostly fishermen
04:19:03 <Ralith> rtharper: nobody's shown you Dynamic?
04:19:12 <fujisan> so my theory is that a diet of fish provides smarter offspring
04:19:16 <rtharper> Forced it on me you mean? Yeha I have seen it
04:19:30 <fujisan> forced?
04:19:35 <shachaf> @where ops
04:19:36 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:19:42 <fujisan> hi shachaf
04:19:42 <rtharper> I work in a dynamic language every day, I'll have no truck with it in my private l ife
04:19:51 <Ralith> that's no excuse to lie to people.
04:19:53 <rtharper> needs maor ops
04:19:56 <k0ral> @hoogle String -> Maybe String
04:19:56 <lambdabot> Network.CGI.Cookie findCookie :: String -> String -> Maybe String
04:19:56 <lambdabot> System.Posix.Env getEnv :: String -> IO (Maybe String)
04:19:57 <lambdabot> Network.CGI getCookie :: MonadCGI m => String -> m (Maybe String)
04:20:23 <fujisan> what sort of entry level of knowledge do i need to start with haskell?
04:20:38 <fujisan> can i take a test to see if it's something for me
04:20:42 <rtharper> fujisan: it can be your first programming language
04:20:47 <fujisan> i fear that im not smart enough
04:20:54 <fujisan> but i want to try
04:21:03 <shachaf> fujisan: Please stop trolling.
04:21:05 <rtharper> fujisan: I don't think you need to worry ;)
04:21:06 <shachaf> Weren't you banned in here?
04:21:13 <fujisan> shachaf:  im a slow learner
04:21:17 <fujisan> that's not trolling
04:21:22 <k0ral> fujisan: smartness will only impact the time it takes to learn, but you'll always be able to learn it in the end
04:21:22 * hackagebot language-lua 0.1 - Lua parser and pretty-printer  http://hackage.haskell.org/package/language-lua-0.1 (OmerAgacan)
04:21:29 <fujisan> shachaf:  i dont know
04:21:39 <fujisan> i cant see the banlist in adium
04:21:45 <rtharper> smartness being a rather unquantifiable notion anyway =)
04:21:46 <fujisan> my irc client
04:22:08 <fujisan> shachaf:  cant we start over
04:22:10 <rtharper> have met many people smarter than I am who I can learn many things faster than
04:22:13 <rtharper> and vice versa, heh
04:22:22 <rtharper> depending on how you consider "smart"
04:22:28 <fujisan> i know i was naughty before but i want to apply myself and change
04:22:30 <k0ral> rtharper: well, one could try to define it as the time one take to learn a predefined concept
04:22:43 <rtharper> k0ral: what kind of concept?
04:22:46 <k0ral> rtharper: well, the inverse
04:22:57 <rtharper> some people rubbish at maths are wizards at literary theory, languages, etc
04:23:04 <rtharper> and vice versa
04:23:08 <k0ral> rtharper: smartness is domain-dependant :)
04:23:10 <rtharper> and some are good at both
04:23:11 <rtharper> hehe
04:23:12 <rtharper> aye
04:23:18 <fujisan> i consider Margot Gerritsen to be smart
04:23:43 <fujisan> rtharper:  yeah i know the einstein proverb right
04:23:59 <fujisan> everyone is a genius at something i forgot the exact words of it though
04:24:08 <rtharper> yeah
04:24:36 <k0ral> anyway, the point is: I think one should never consider any knowledge as unreachable
04:24:52 <rtharper> agreeeeed
04:24:53 <rtharper>  =)
04:25:01 <k0ral> it might just take a very long time, but it's always finite :)
04:25:52 <k0ral> fujisan: Haskell is not difficult, it's different
04:26:23 <k0ral> don't fear the different, it makes you stronger :)
04:26:27 <fujisan> i never did much programming
04:26:57 <k0ral> well, it will be even easier then since you're not polluted with imperative paradigm yet
04:28:27 <k0ral> would someone know of a f :: String -> Maybe String that does the following: [] -> Nothing, s -> Just s ?
04:28:47 <k0ral> I mean, an existing f in the base library, or a combination of existing functions that would do that
04:29:04 <k0ral> it seems simple enough so that I expect it to exist already :)
04:29:09 <fujisan> im interested in the aspect of coding which is erratic i mean when you run code you can get different outcomes
04:29:47 <k0ral> fujisan: well, you just pointed out one of the important concepts in functional programming: side effects
04:31:44 <fujisan> so the side effects are predictable ?
04:31:44 <Sintendo> Okay, a very high level question: I'm trying to implement Dijkstra's algorithm, and I've had to start over 3 times because I'm passing around a bunch of crap to maintain a state everywhere and at some point I'm just so confused I don't even know what I'm doing anymore.
04:32:08 <Sintendo> Would monads be helpful in any way for this?
04:32:52 <k0ral> fujisan: I did not say that
04:33:02 <fujisan> i know you didn't
04:33:08 <fujisan> i was just wondering
04:33:13 <Ferdirand> Sintendo: someone mentioned the ST monad precisely for A* the other day
04:33:58 <k0ral> fujisan: functions with side effects are functions for which knowing the input does not determine completely the output
04:34:04 <fujisan> i meant it more as input for error correcting code but i don't know much about the topic
04:34:13 * Ralith waves at Ferdirand 
04:34:19 <Sintendo> Okay, just asking so I know I'm not completely wasting my time trying to wrap my head around monads in the first place.
04:34:20 <fujisan> i guess im not thinking as programmer
04:34:52 <Ralith> Sintendo: passing state around in a lightweight fashion is one of the classic uses of monads.
04:35:16 <k0ral> so, in a sense, one could say that functions with side effects are unpredictable
04:35:34 <Ralith> Sintendo: and if you need perf (you probably don't) ST is the state monad of choice.
04:35:55 <fujisan> okay k0ral
04:36:01 <k0ral> but you could still consider it actually depends on an external state, and that knowing this state would actually completely determine the output
04:36:27 <Ralith> k0ral: what do you want a function like that for?
04:36:50 <fujisan> unpredictable because a lack of knowledge or deliberate for some random functionality?
04:36:52 <k0ral> fujisan: usually, these external states are from IOs, and you can never know for sure their state
04:37:03 <Sintendo> I don't really care about performance much, I'm not even using a priority queue for Dijkstra, which largely determines the algorithm performance.
04:37:18 <Sintendo> So guess I'm off reading some more monad stuff.
04:37:37 <k0ral> fujisan: in Haskell, there is a clear distinction between functions that have side effects and functions that have none
04:37:46 <fujisan> hmz okay
04:38:02 <k0ral> Ralith: it's for basic  commandline parsing
04:38:04 <Sintendo> Thanks btw :)
04:38:53 <k0ral> fujisan: whether a function has a side effect or not is directly indicated in its signature
04:39:01 <Ralith> Sintendo: I'll reiterate my recommendation that you not faff about with blog posts and tutorials, and instead just go implement them yourself.
04:39:06 <Kosta> Whats wrong with this line: "data Foo = Foo a". ghc says: Not in scope: type variable `a'
04:39:13 <Ralith> it's usually the most reliable way to learn a thing.
04:39:21 <k0ral> fujisan: and that property has to be propagated through every function that uses another function with side effects
04:39:36 <raek> Kosta: you need to write it like this: "data Foo a = Foo a"
04:39:45 <Ralith> k0ral: observe that GHC told you this.
04:39:46 <Ralith> er
04:39:48 <Ralith> Kosta: ^
04:39:54 <Sintendo> Ralith: Well, I do need some kind of starting point
04:40:32 <Ralith> Sintendo: once you know how to rewrite do notation as calls to >>=, you're fine.
04:42:13 <Ralith> the metaphors and so on are abstractly interesting, but not necessarily helpful to learning.
04:42:32 <Sintendo> Yeah, I've noticed that
04:42:34 <Kosta> raek, Ralith: thanks
04:43:24 <de> batan
04:43:31 <Kosta> actually, I want to do this: "data Foo a = Foo IORef a", but ghc says: "expecting one more argument to `IORef'"
04:43:41 <Kosta> but IORef only takes one arg?
04:45:04 <merijn> Kosta: Perhaps you meant to write "data Foo a = Foo (IORef a)"?
04:45:46 <fujisan> ok k0ral thanks for your explanations
04:45:53 <Kosta> merijn: Ah yes, I always screw up parenthesis in haskell :)
04:45:54 <merijn> Kosta: Which is "a constructor Foo taking an IORef a as argument", which is not the same as what you wrote. (Type application binds strongest, just like function application)
04:45:56 <fujisan> merijn hello
04:46:34 <Kosta> Ok, that works, thanks merijn! :)
04:47:45 <merijn> Kosta: In general if your constructors take argument of more than one word (syntax wise), such as "Maybe a", "Either a b", etc. you always have to parenthesise them
04:48:02 <fujisan> why?
04:48:36 <Kosta> merijn: Thanks. Good to know :)
04:48:39 <fujisan> because of (Type application binds strongest, just like function application)
04:48:45 <fujisan> or some other reason
04:48:57 <merijn> fujisan: Because "data Foo a b = Foo Either a b" parses as "(((Foo Either) a) b)" instead of the intended "Foo ((Either a) b)"
04:49:49 <fujisan> ok ty
04:51:36 <fujisan> btw how do you type so fast merijn?
04:52:29 <neworder> I was reading about the let bindings in learnyouahaskell
04:53:00 <neworder> let <bindings> in <expression>.
04:53:16 <merijn> fujisan: Lots of practice?
04:53:26 <fujisan> merijn okay
04:53:26 <merijn> And making lots of typos :>
04:53:33 <neworder> The names that you define in the let part are accessible to the expression after the in part.
04:53:51 <merijn> neworder: They're accessible sooner, you can also use them in the let part
04:54:12 <neworder> let fact x = let prod = foldr (*) 1 in prod [1..x] in fact 10
04:54:21 <neworder> Hmm I see
04:54:30 <neworder> For this equation
04:54:33 <fujisan> merijn also your english is very good but your nickname looks non-english
04:55:11 <neworder> can you help me with where each let binding is accessible in pls
04:55:31 <neworder> By putting brackets if it makes it clearer?
04:55:40 <merijn> neworder: "(let fact x = (let prod = foldr (*) 1 in prod [1..x]) in fact 10)"
04:55:41 <rwbarton> where's that online parser thing
04:56:26 <neworder>  (let prod = foldr (*) 1 in prod [1..x]) returns an expression right
04:56:33 <merijn> neworder: Yes
04:56:47 <merijn> :t \x -> let prod = foldr (*) 1 in prod [1..x]
04:56:49 <lambdabot> (Enum b, Num b) => b -> b
04:57:00 <neworder> which is prod[1..x] evaluated right? :)
04:57:01 <xunatai> fujisan: learn to touch type
04:57:06 <merijn> neworder: Yes
04:57:18 <neworder> Alright thanks =)
04:57:43 <merijn> neworder: Well, the "evaluated" in the sentence is debatable. But the result is "prod [1..x]" with prod defined in the preceeding let
04:57:45 <fujisan> i learned myself how to type my method is uses the backspace a lot
04:57:55 <fujisan> im a terrible typer
04:58:06 <neworder> Ah I see
04:58:28 <fujisan> think i get 50 wpm or lower
04:59:18 <schrimpschonger> hello there. i just started to learn haskell (and am also a first time IRC user...)
04:59:20 <merijn> neworder: By debatable I mean that the usual laziness caveats apply
04:59:27 <fujisan> s
04:59:32 <fujisan> schrimpschonger:  welcome
04:59:57 <neworder> Hmm ok
05:00:06 <neworder> Continuing with it
05:00:12 <neworder> (let fact x = (let prod = foldr (*) 1 in prod [1..x]) in fact 10)
05:00:12 <fujisan> merijn laziness is the desire to be efficient
05:00:32 <neworder> The result of this (let prod = foldr (*) 1 in prod [1..x]) is prod[1..x]
05:00:39 <neworder> so how does it continue
05:00:54 <neworder> let fact x= prod[1..x] in fact 10
05:01:11 <neworder> I see it
05:02:12 <schrimpschonger> i'm wondering: has anybody experience with parallelizing haskell programs? I'm just curious how it is achieved
05:02:30 <merijn> neworder: It defines a function "fact" and then uses that in the "in" part, that's all that's going on
05:02:35 <shachaf> schrimpschonger: You should see Simon Marlow's excellent slides on concurrent and parallel Haskell.
05:02:45 <shachaf> http://community.haskell.org/~simonmar/slides/cadarache2012/
05:02:57 <schrimpschonger> shachaf : thank you
05:03:02 <merijn> schrimpschonger: There is a lot of work in this, yes. Amongst other Simon's work
05:03:17 <neworder> So 10 is binded to x right
05:03:17 <shachaf> Those slides are a good general introduction
05:03:22 <shachaf> And they also go into some depth.
05:03:30 <shachaf> @where+ concpar http://community.haskell.org/~simonmar/slides/cadarache2012/
05:03:30 <lambdabot> It is stored.
05:03:56 <fujisan> im reading this channel while listening to supermario sounds from the new Wii U
05:04:07 <merijn> neworder: It's is *exactly* the same as defining a top level "fact" function and then just writing "fact 10". There is nothing special, the only thing let does is limit the scope where the function is defined
05:04:38 <merijn> neworder: Are you familiar with any other languages? (Hopefully something like Python, Ruby, JS)
05:04:46 <neworder> Yup yup
05:04:48 <neworder> I see
05:04:56 <neworder> Python, C...
05:05:01 <fujisan> so i was wondering is there a programming language entirely in sound
05:05:20 <merijn> neworder: It's just a local function definition, like how python lets you define a function inside the body of another function (only allowing you to use it in that scope)
05:05:28 <fujisan> or can i translate haskell into sound
05:05:37 <xunatai> you could map ascii characters to sound, then all programming languages can be translated to sound
05:05:44 <shachaf> fujisan: Please stop trolling.
05:05:48 <fujisan> would make it more interesting
05:05:54 <fujisan> it's not trolling
05:05:56 <shachaf> I'm pretty sure you're been banned from here.
05:05:58 <fujisan> it was just an idea
05:06:09 <xunatai> not a very on-topic idea
05:06:19 <k0ral> it really looks like trolling indeed
05:06:42 <fujisan> but i want to use haskell to learn about programming and at the same time combine it with my passion for sound
05:06:46 <fujisan> that's all i meant
05:06:57 <fujisan> im sorry if it that came across  as trolling
05:07:05 <knz_> side question: what's the shortest definition for the y combinator in haskell?
05:07:12 <neworder> Hmm alright, thanks merijn for the lengthy explanation,  Just wanted to ensure that I have the correct understanding
05:07:12 <knz_> obviously y f = f f does not work
05:07:42 <shachaf> knz: y f = f f isn't correct.
05:07:48 <shachaf> knz: y f = f (y f) is pretty short.
05:07:48 <knz> yeah that's what I said
05:07:50 <hpaste> merijn pasted “translated to python” at http://hpaste.org/78211
05:07:56 <knz> k
05:08:00 <shachaf> That's not Y, though.
05:08:04 <shachaf> It's just a fixed-point combinator.
05:08:06 <shachaf> @where y
05:08:06 <lambdabot> \f -> (\x -> f (outR x x)) (InR (\x -> f (outR x x)))
05:08:08 <merijn> neworder: See that paste to see a transliteration to python
05:08:09 <shachaf> That's Y.
05:08:30 <knz> @wher eoutR
05:08:30 <lambdabot> Maybe you meant: where where+
05:08:33 <knz> @where outR
05:08:34 <lambdabot> I know nothing about outr.
05:08:37 <knz> yeah right
05:08:44 <knz> you lier
05:09:02 <neworder> Thanks merijn
05:09:35 <fujisan> shachaf:  my idea was to make haskell multi-sensory for better and faster or even more efficient learning that's all i don't get why that is instantly considered trolling
05:11:23 <hiptobecubic> fujisan, your question was already answered anyway.
05:11:33 <fujisan> im sorry but i feel attacked
05:11:40 <hiptobecubic> fujisan, get over it.
05:11:59 <fujisan> i guess im just going to leave the channel i don't like to be called a troll
05:12:06 <fujisan> have a nice day all
05:12:17 <xunatai> i'm okay with that
05:12:53 <Sintendo> Just a sanity check: all monads really do is provide an interface that let's you chain thing together?
05:13:15 <shachaf> Sintendo: I wouldn't phrase it like that.
05:13:38 <shachaf> Oh, you're the person I told to see the FAQ. :-)
05:13:46 <shachaf> In fact, I wouldn't phrase it at all.
05:14:03 <hiptobecubic> Sintendo, i think it's more like an abstract DSL
05:14:15 <merijn> Sintendo: As long as you don't *really* believe that definition it is a helpful approximation to start with, as long as you plan to throw it away later :p
05:16:07 <raek> how is it inaccurate? (my intuitive picture of monads is something like that too...)
05:17:45 <Shapeshifter> Looking at this example http://www.haskell.org/haskellwiki/99_questions/Solutions/7 I don't understand why there's "List xs" at the end of this line: flatten (List (x:xs)) = flatten x ++ flatten (List xs). I mean, it looks like in (x:xs), xs is already a list, so why the additional List constructor?
05:17:56 <hiptobecubic> It's just not a very good description. Like saying a can opener is a thing that lets you cut metal.
05:18:13 <fmap> hiptobecubic: abstract specific language? :]
05:18:31 <hiptobecubic> fmap, yes :)
05:18:41 <Shapeshifter> mh. nevermind, the list is 'unpacked' in the pattern
05:19:02 <Thr> Anyone here?
05:19:12 <xunatai> there's always anyone here
05:19:47 <raek> hiptobecubic: so the description is true but too general to be useful (at least as a definition)?
05:21:38 <jesyspa> Sintendo: Well, applicatives already allow for a lot of chaining.
05:21:40 <hiptobecubic> raek, i think so. But I'm no monad scholar.
05:23:08 <Sintendo> Could you do IO using applicatives then?
05:23:21 <shachaf> What does that mean?
05:23:25 <shachaf> "IO" is a particular type.
05:23:38 <shachaf> It's an instance of the type class Monad. It's an instance of the type class Applicative.
05:23:46 <shachaf> If it wasn't, you could do all the same things with it.
05:25:02 <shachaf> Sintendo: I wrote a longer answer to a similar question recently: http://stackoverflow.com/questions/13536761/what-other-ways-can-state-be-handled-in-a-pure-functional-language-besides-with/13538351#13538351
05:25:51 <fliip> How would I modify a list of ((a,b),c) to a list of (a,b)?
05:25:57 <shachaf> map fst
05:26:04 <fliip> Thanks =)
05:26:45 <shachaf> > over mapped (view _1) [((1,2),3),((4,5),6)]
05:26:48 <lambdabot>   [(1,2),(4,5)]
05:27:07 <shachaf> > toListOf (folded._1) [((1,2),3),((4,5),6)]
05:27:10 <lambdabot>   [(1,2),(4,5)]
05:44:05 <neworder> let fib = 0:1:(zipWith (+) fib (tail fib))
05:45:16 <neworder> let fib = 0:1:(zipWith (+) fib (tail fib)) in take 10 fib
05:45:32 <barrucadu> > let fib = 0:1:(zipWith (+) fib (tail fib)) in take 10 fib
05:45:34 <lambdabot>   [0,1,1,2,3,5,8,13,21,34]
05:45:50 <neworder> I can see that lazy evaluation is taking place here, but I'm can't really see how it's computed
05:46:11 <jesyspa> > let fib = 0:1:((+) <$> fib <*> tail fib) in take 10 fib
05:46:13 <lambdabot>   [0,1,1,1,1,1,1,1,1,1]
05:46:16 <jesyspa> Why? :\
05:46:24 <neworder> At first , the fib is a list containing [0,1,..] right
05:46:42 <rwbarton> no
05:46:44 <rwbarton> oh
05:46:49 <neworder> what's that $ sighn
05:46:50 <rwbarton> well, what does ".." mean
05:47:14 <neworder> as in, lazy evaluation is taking place
05:47:17 <rwbarton> if it means "2,3,4,..." then no, if it mean "stuff that we don't know yet" then yes
05:47:21 <neworder> and the list only contains 0 and 1
05:47:32 <neworder> hmm yup
05:47:39 <neworder> stuff that we don't know yet
05:47:42 <rwbarton> it doesn't "only contain" 0 and 1... we just haven't computed the rest of it yet
05:47:45 <xunatai> at first it's [0, 1], then it uses that to produce [0, 1, 1], and it just keeps going
05:47:47 <ion> jesyspa: head ((+) <$> [0,1] <*> [1]) = 1
05:48:15 <rwbarton> jesyspa: because <*> for [] is not based on zip
05:48:24 <jesyspa> Oh, doh, I get it.  Thanks. :)
05:48:25 <ion> jesyspa: ((+) <$> [0,1,1] <*> [1,1]) !! 1 = 1
05:48:32 <neworder> Ahh I see how the fibonachi is computed!
05:48:44 <ion> ((+) <$> [0,1,1,1] <*> [1,1,1]) !! 2 = 1
05:49:00 <fliip> "ERROR file:.\Main.lhs - Module "xxxxxxxx" not previously loaded" - Anyone have any idea why that is in winhugs?
05:49:06 <neworder> doing a tail fib causes each element in the list to be added to the previous element
05:49:14 <shachaf> fliip: You probably shouldn't be using Hugs.
05:49:24 <ion> fliip: Hugs is dead, better use ghci.
05:49:29 <fliip> Oh ok thanks.
05:50:10 <jesyspa> Is there any nice operators @ and @@ to do f @ a @@ b @@ c @@ d ... @@ z such that it zips all the lists together?
05:50:15 <jesyspa> s/Is/Are/
05:50:31 <mSSM> Hey! I wanted to ask - how do I install pandoc via cabal without reverting all my other packages?
05:50:52 <ion> > getZipList $ (,,) <$> ZipList [0..5] <*> ZipList [0..5]
05:50:54 <lambdabot>   *Exception: showList: No overloading for function
05:51:11 <mSSM> That is, I have many packages which are in fact newer, and now cabal wants to install an older version of them for pandoc.
05:51:12 <ion> > getZipList $ (,,) <$> ZipList [0..5] <*> ZipList [0..5] <*> ZipList [0..5]
05:51:12 <jesyspa> Thanks, I see.
05:51:14 <lambdabot>   [(0,0,0),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]
05:51:16 <xunatai> there's zip2, zip3, zip4, ..., zip7
05:51:17 <yitz> mSSM: you can install it in a sandbox with a fresh cabal library using cabal-dev
05:51:41 <rwbarton> jesyspa, you can always define them using the same trick as ZipList if you find the ZipList/getZipList stuff too wordy
05:52:01 <rwbarton> > let (@) = map; (@@) = zipWith (+) in (,,) @ [0..5] @@ [0..5] @@ [0..5]
05:52:03 <lambdabot>   <hint>:1:6: parse error on input `@'
05:52:07 <rwbarton> oh no
05:52:21 <jesyspa> Thanks, I see.
05:52:25 <ion> OH YEAH!
05:52:29 <rwbarton> > let (&) = map; (&&) = zipWith ($) in (,,) & [0..5] && [0..5] && [0..5]
05:52:29 <jesyspa> @ was just a generic placeholder for any operator.
05:52:31 <lambdabot>   [(0,0,0),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]
05:52:34 <mSSM> yitz: that does sound a little complicated
05:52:35 <shachaf> @let (@@) = zipWith id in repeat (,,) @@ [0..5] @@ [0..5] @@ [0..5]
05:52:35 <lambdabot>   Parse error: in
05:52:38 <shachaf> > let (@@) = zipWith id in repeat (,,) @@ [0..5] @@ [0..5] @@ [0..5]
05:52:40 <lambdabot>   [(0,0,0),(1,1,1),(2,2,2),(3,3,3),(4,4,4),(5,5,5)]
05:53:11 <yitz> mSSM: it's not complicated at all. it's easy. just will take a few minutes longer to compile a new copy of everything.
05:53:39 <yitz> mSSM: cabal install cabal-dev, then cd into a new directory and say cabal-dev install pandoc
05:53:48 <Sintendo> I've been staring at monads for an hour now with virtually no progress, did you all have to go through this?
05:53:51 <rwbarton> mSSM: are you using ghc 7.6?
05:54:15 <Botje> Sintendo: just get your hands dirty with one of them.
05:54:29 <shachaf> pandoc is 7.6-compatible these days.
05:54:29 <Botje> once you no longer get type errors or understand /why/ you get them, you "get" monads.
05:54:40 <mSSM> rwbarton: I am
05:54:43 <rwbarton> oh really
05:55:28 <mSSM> yitz: even cabal dev wants to downgrade a couple of thiongs
05:58:08 <shachaf> mSSM: What things?
05:58:17 <shachaf> Maybe you just need to cabal update if you haven't done that in a while.
06:01:13 <mSSM> shachaf: bytestring, text
06:01:30 <mSSM> shachaf: cabal wants to go from 0.10 to 0.9.2.1
06:01:33 <mSSM> and others, too
06:01:36 <shachaf> Why?
06:01:39 <mSSM> shachaf: I have done a cabal update
06:01:46 <shachaf> Did you try -v?
06:02:00 <mSSM> -v on which?
06:02:03 <mSSM> update or install ?
06:02:06 <shachaf> install
06:02:41 <mSSM> shachaf: IT doesn't change anything; the same output is given
06:03:04 <mSSM> shachaf: It says, for example: text-0.11.2.3 (reinstall) changes: bytestring-0.10.0.0 -> 0.9.2.1
06:03:15 <shachaf> Yes, but this time it answers the magic question.
06:03:34 <mSSM> Alright, sorry; I had the same output without the -v flag
06:03:42 <mSSM> shachaf: So what is this about?
06:03:51 <shachaf> ?
06:04:01 <shachaf> cabal install -v gives the exact same output?
06:04:17 <shachaf> Try -v 3
06:04:33 <rwbarton> -v (fix Succ)
06:05:18 <neworder> pow = 1:map (2*) pow
06:05:22 <mSSM> shachaf: yes; exactly the same result
06:05:32 <neworder> I'm trying to expand this function to see how it works
06:05:57 <mSSM> shachaf: I am not sure what -v 3 is supposed to do? It says: cabal: The file does not exist '3'.
06:06:06 <shachaf> cabal install pandoc -v3
06:06:08 <shachaf> I don't know.
06:06:30 <neworder> pow = 1:map (2*) pow = 1:2:map (2*) pow
06:06:39 <neworder> Is my expansion correct?
06:06:39 <shachaf> neworder: No.
06:06:40 <mSSM> shachaf: Ok, v3 gives a lit more verbose output
06:06:53 <neworder> oh
06:06:53 <shachaf> neworder: 1:2:map (2*) (tail pow)
06:07:13 <shachaf> (Sort of. There's no actual "tail" call there, of course.)
06:07:37 <neworder> Ah I see
06:07:53 <shachaf> 1:2:map (2*) ?
06:07:53 <shachaf>    ^        /
06:07:53 <shachaf>     \-------
06:08:20 <shachaf> 1:2:4:map (2*) ?
06:08:20 <shachaf>      ^        /
06:08:20 <shachaf>       \-------
06:11:02 <mSSM> shachaf: here is the output: http://sprunge.us/WYhF
06:11:11 <mSSM> shachaf: this is for cabal install -v3 cabal-dev
06:11:25 <haisheng> hello, does anybody know the difference betweent TVar and TMVar..the book RWH says TMVar is equaivalent to MVar, which is confused to me.
06:11:50 <neworder> Hmm, I can't really see how this part keeps coming back, map (2*) pow
06:11:50 <shachaf> mSSM: I thought you were trying to install pandoc.
06:11:54 <rwbarton> it's "the STM equivalent to MVar"
06:11:56 <shachaf> I don't know anything about pandoc.
06:12:05 <shachaf> Er.
06:12:07 <shachaf> I don't know anything about cabal-dev.
06:12:10 <shachaf> Well, both are true. :-)
06:13:01 <mSSM> shachaf: well, somebody above suggested to go for cabal-dev
06:13:05 <mSSM> shachaf: either way, I get similar messages
06:13:15 <mSSM> as in, downgradingh stuff
06:13:18 <rwbarton> looks like cabal-dev needs old bytestring
06:13:22 <mSSM> exit
06:13:55 <shachaf> By "similar messages" do you mean "cabal mumbo jumbo full of version numbers"? :-)
06:14:07 <shachaf> Because the specific contents of the messages matter.
06:14:09 <rwbarton> forget cabal-dev, try the package you want to install
06:14:11 <neworder> Just curious what you guys are working on.. =)
06:14:16 <shachaf> cabal-dev requires bytestring <0.10
06:14:23 <neworder> Is it on a game engine or something?
06:14:23 <typoclass> shachaf: i think mumbo jumbo is not a technical term
06:14:33 <rwbarton> concrete nonsense
06:14:49 <haisheng> shachaf: sorry for missed some words..however my understanding is TVar is STM equivalent to MVar, is it correct?
06:14:50 <shachaf> The category theorist's worst nightmare?
06:15:16 <rwbarton> TVar is the STM equivalent to IORef
06:15:20 <rwbarton> it's just a cell
06:15:23 <haisheng> shachaf: since TMVar just add another Maybe layer
06:15:27 <rwbarton> TMVar can be empty or full, like an MVar
06:15:39 <rwbarton> and you take/put it rather than read/write it
06:15:56 <shachaf> haisheng: The implementation is in terms of Maybe but the behavior is like MVar.
06:16:12 <shachaf> Blocking when you take empty/put full, etc.
06:16:15 <rwbarton> I guess TMVar a looks a lot like TVar (Maybe a) once you have atomic transactions, though
06:16:34 <shachaf> rwbarton: Well, it's just a newtype over that.
06:16:44 <rwbarton> apparently!
06:17:06 <haisheng> as you see, the example given in RWH 28 ,is using TVar
06:17:09 <shachaf> But fortunately it's not used nearly as much.
06:17:27 <shachaf> For example TChan is implemented with TVars, not TMVars.
06:17:30 <shachaf> Makes it much easier to read.
06:17:37 <haisheng> thus my understanding is TVar is used for communication betwweent threads
06:17:45 <shachaf> @where concpar
06:17:46 <lambdabot> http://community.haskell.org/~simonmar/slides/cadarache2012/
06:17:51 <shachaf> haisheng: ☝ good slides.
06:17:57 <atriq> Is there a deriving Ix extension?
06:18:16 <shachaf> haisheng: Sections 3 and 4 are relevant to you here.
06:18:22 <haisheng> thanks lambdabot
06:18:35 <rwbarton> @thx
06:18:36 <lambdabot> you are welcome
06:18:46 <lambdabot> no problem haisheng
06:19:43 <haisheng> I'll read it to see if I can find more interesting information. ;)
06:20:39 <shachaf> data TChan a = TChan (TVar (TVarList a)) (TVar (TVarList a)); type TVarList a = TVar (TList a); data TList a = TNil | TCons a (TVarList a)
06:20:59 <rwbarton> I guess maybe TVar is the STM equivalent to MVar in some informal, practical sense
06:21:27 <shachaf> rwbarton: It's the equivalent in the sense that GHC gives you MVar# and TVar# :-)
06:21:55 <rwbarton> as in the simplest shared mutable variable you can reasonably do something with
06:21:59 <shachaf> Right.
06:22:10 <shachaf> You also need retry for STM, though.
06:24:04 * shachaf wonders whether something like Async takes a noticeable performance hit from being implemented via STM instead of MVars.
06:24:26 <shachaf> In most use cases of Async, you don't care about STM.
06:25:15 <haisheng> yes, Async is higher level..but juet curious a little more detail.
06:30:56 <Saizan> rwbarton: there's also TMVar that can be empty like a MVar, TVar is more like IORef except for the safeness
06:31:06 <rwbarton> well, that's what I was saying at first
06:31:16 <Saizan> ah, sorry
06:31:23 <yitz> cabal-dev does not depend on byte-string at all
06:31:32 <shachaf> Unfortunately only GHC is allowed to ™Var.
06:31:41 <shachaf> Other people have to use a different name.
06:31:45 <yitz> mSSM: ^
06:31:57 <mSSM> yitz: yeah, but I gave you my output ...
06:31:59 <yitz> mSSM: why are you trying to install byte-string?
06:32:04 <mSSM> yitz: i am not :(
06:32:13 <rwbarton> yes it does, there is a flag...
06:32:15 <mSSM> yitz: hold on
06:32:20 <rwbarton> see http://hackage.haskell.org/packages/archive/cabal-dev/0.9.1/cabal-dev.cabal
06:32:32 <yitz> rwbarton: hmm?
06:32:42 <shachaf>     Build-depends: bytestring >= 0.9 && < 0.10,
06:32:52 <mSSM> yitz: http://sprunge.us/WYhF
06:33:06 <rwbarton> Executable cabal-dev ... if flag(no-cabal-dev) Buildable: False else ... Build-depends: bytestring >= 0.9 && < 0.10,
06:33:07 <mSSM> yitz: I am not installing it, cabal is pulling it from cabal install cabal-dev
06:33:11 <shachaf> mSSM: Do you actually care about cabal-dev?
06:33:18 <yitz> ah i see it does. weird, doesn't show on hackage
06:33:20 <shachaf> I thought you wanted pandoc.
06:33:27 <mSSM> shachaf: I am not; but yitz suggested it would be easier to get pandoc that way.
06:33:47 <mSSM> shachaf: therefore, I would be happy to get just pandoc, but pandoc raises similar problems.
06:33:49 <shachaf> OK, but a couple of other people have suggested that you @paste the output for pandoc since then. :-)
06:33:52 <rwbarton> because you can build cabal-dev (the package) without cabal-dev (the executable) for some reason
06:33:56 <rwbarton> and yeah, that's annoying
06:34:09 <mSSM> shachaf: sure
06:34:11 <yitz> shachaf: if you want to install things from hackage without encountering cabal-hell, you want cabal-dev (or one of the other sandboxing tools). so yes, mSSM wants that.
06:34:14 <haisheng> rwbarton: Saizan exactly..What the MVar is "An MVar t is mutable location that is either empty or contains a value of type t.". TMVar has the same idea. So my understanding is from pratical perspective, TMVar is STM equivalent to MVar.. It is a little more clear.
06:34:30 <sankrant> Is Control.Concurrent standardised?
06:34:38 <shachaf> mSSM: I'm going to bet that they're not the same problems.
06:34:48 <shachaf> yitz: I don't use cabal-dev and pandoc installs fine for me.
06:34:50 <mSSM> shachaf: there you go http://sprunge.us/DYXd
06:34:55 <yitz> shachaf: roll of the dice
06:34:57 <shachaf> yitz: Also it's not GHC 7.6-compatible.
06:35:33 <yitz> shachaf: i don't know pandoc specifically, but people have been saying here that it has been resolved
06:35:37 <shachaf> mSSM: OK, it's conflicting with blaze-html for some reason.
06:35:43 <shachaf> yitz: What has been resolved?
06:36:34 <neworder> pow = 1:map (2*) pow
06:36:35 <shachaf> Wait, maybe I'm wrong.
06:36:45 <shachaf> Maybe I edited some .cabal files to get pandoc working?
06:36:48 <shachaf> I don't even remember.
06:37:03 <sankrant> Is Control.Concurrent standardised library?
06:37:21 <yitz> you can spend weeks fighting with one conflict after another. or you can just start with a fresh ghc install, optionally also HP, then immediately cabal install cabal-dev. then never touch cabal again. everything will always just work.
06:37:23 <shachaf> sankrant: It's not in the Report, if that's what you mean. :-)
06:37:30 <neworder> Here, what does pow on the right hand side of the equation contain?
06:37:31 <shachaf> yitz: No, I can't install cabal-dev
06:37:37 <shachaf> It's not compatible with my version of GHC.
06:38:12 <sankrant> shachaf: Anybody commiting to it?
06:38:17 <yitz> shachaf: maybe you mean hugs? or are you using ghc 6.* or something?
06:38:26 <shachaf> sankrant: Yes, it's maintained and very commonly used.
06:38:29 <shachaf> yitz: I'm using 7.6.
06:38:33 <shachaf> cabal-dev doesn't work with that.
06:38:40 <shachaf> That was mSSM's issue too.
06:39:04 <fmap> I think you need cabal-dev from git to install it on 7.6
06:39:09 <shachaf> OK.
06:39:24 <shachaf> I don't care that much about cabal-dev right now because cabal works OK for me.
06:39:31 <yitz> shachaf: why do you think cabal-dev is not compatible with 7.6? they use it at galois. i think they've heard of 7.6 there.
06:39:32 <shachaf> I'll wait for the next release, whenever that happens.
06:39:37 <rwbarton> lol
06:39:44 <shachaf> yitz: Maybe they use HEAD there. I don't know.
06:39:51 <shachaf> The .cabal file requires bytestring <0.10
06:40:25 <mSSM> Seriously guys, cabal for managing hackage packages seems to be a huge pain in the butt.
06:40:49 <shachaf> mSSM: This would probably go smoothly if you were using GHC 7.4
06:41:00 <shachaf> Unfortunately most packages haven't been updated for 7.6 compatibility yet.
06:41:08 <shachaf> Apparently pandoc is among those, and I was wrong about that.
06:41:18 <ramses_> neworder: that's basically a recursive definition without a bas case -> it produces on infinite list, every element being the previous * 2
06:41:27 <atriq> Cabal does what it's designed for, and not much else
06:41:32 <shachaf> ramses_: I see a base case.
06:41:46 <yitz> shachaf: why does bytestring <0.10 make it incompatible with ghc 7.6?
06:41:49 <shachaf> (Well, it's corecursive or something. But anyway.)
06:42:20 <shachaf> yitz: 06:32 <mSSM> yitz: http://sprunge.us/WYhF
06:42:37 <ramses_> shachaf: the recursion goes on indefinitely, doesn't it?
06:42:40 <shachaf> Whoops, looks like cabal-dev demands containers <0.5, too.
06:42:57 <rwbarton> how do I read this? "conflict: pandoc-1.9.4.5:blaze_html_0_5 => blaze-html>=0.4.3.0 && <0.5"
06:43:25 <shachaf> Oh...
06:43:32 <shachaf> blaze_html_0_5 is a flag.
06:43:40 <yitz> shachaf: i understand that mSSM's package database is messed up. it's obviously not an virgin ghc install.
06:43:42 <rwbarton> yes but...
06:44:09 <shachaf> mSSM: try cabal install pandoc -v3 -f blaze_html_0_5
06:44:11 <rwbarton> "trying: blaze-html-0.4.3.4:!test" i think this is the syntax for the flag being false?
06:44:21 <ramses_> shachaf: when viewed as corecursion, it has a base case indeed
06:44:32 <neworder> hmm
06:44:38 <neworder> What I'm confused about is that
06:44:38 <rwbarton> and pandoc-1.9.4.5:blaze_html_0_5 doesn't depend on blaze-html >= 0.4.3.0 && < 0.5, it depends on blaze-html >= 0.5 && < 0.6
06:44:50 <neworder> What's in the list at each point of execution
06:44:53 <yitz> shachaf: that is not evidence that there is any problem with cabal-dev and ghc 7.6.
06:45:05 <shachaf> rwbarton: OK, but the flag is false.
06:45:07 <neworder> At first, the list is like this right? [1]
06:45:13 <shachaf> yitz: If you use GHC 7.6, you have to use containers 0.5
06:45:27 <shachaf> Otherwise you're in trouble.
06:45:34 <yitz> shachaf: it's part of base now?
06:45:39 <neworder> then when applying the map function, it becomes like this> [1,2]
06:45:45 <shachaf> yitz: No, it's part of containers.
06:45:53 <shachaf> A lot of packages use containers, though.
06:45:57 <shachaf> And you can only use one version.
06:46:23 <shachaf> yitz: For example, template-haskell uses containers
06:46:24 <ramses_> neworder: it first evaluates the first element, which is defined to be 1
06:46:25 <yitz> shachaf: you only need to install one package: cabal-dev. on a virgin ghc install. i believe that works. after that, you're fine.
06:46:31 <shachaf> And it looks like cabal-dev uses template-haskell
06:46:51 <ramses_> then it goes on to evaluate the second (if asked), for which it takes what it knows already of pow and maps (*2) over it
06:46:57 <rwbarton> cabal-dev is really the new iteratees, huh
06:47:06 <shachaf> rwbarton: OK, I'm probably confused.
06:47:07 <neworder> This
06:47:09 <neworder> pow = 1:map (2*) pow
06:47:21 <shachaf> neworder: Not "[1,2]"
06:47:30 <shachaf> "[1,2,...]", *maybe*
06:47:34 <shachaf> (Really it's 1 : 2 : ...)
06:47:38 <rwbarton> 1 : 2 : ???
06:47:53 <yitz> shachaf: ghc 7.6 doesn't have template haskell?
06:47:58 <shachaf> yitz: It does.
06:48:01 <shachaf> And it uses containers.
06:48:42 <xunatai> let pow = 1:map (2*) pow in pow
06:48:46 <xunatai> > let pow = 1:map (2*) pow in pow
06:48:48 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:49:19 <ramses_> neworder: 1 : (map (*2) pow) -> 1 : 2*1 : map (*2) (map (*2) pow)
06:49:34 <rwbarton> shachaf: oh I see, [__7] trying: pandoc-1.9.4.5:-blaze_html_0_5
06:49:38 <hiptobecubic> > fix \self -> 1:map (2*) self
06:49:40 <lambdabot>   <hint>:1:5: parse error on input `\'
06:49:45 <hiptobecubic> > fix $ \self -> 1:map (2*) self
06:49:47 <lambdabot>   [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,...
06:49:58 <neworder> Ah!
06:49:59 <rwbarton> mSSM: did you try what shachaf said?
06:50:39 <rwbarton> I guess cabal "succeeded" with the flag false and therefore didn't backtrack to setting the flag true
06:51:04 <neworder> Can you expand this further pls? 1 : (map (*2) pow) -> 1 : 2*1 : map (*2) (map (*2) pow)
06:51:10 <mSSM> rwbarton: Going to try it now
06:51:14 <pauser> hello, ist it possible to avoid this:  show "test" -> "\"test\"" i want to receive again "test" ?
06:51:17 <mSSM> mSSM: although I don't like forcing stuff ...
06:51:30 * hackagebot aeson-lens 0.3.0.1 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.3.0.1 (HideyukiTanaka)
06:51:41 <rwbarton> it's not forcing. it's setting a flag
06:51:50 <rwbarton> but yes cabal ought to choose the right value of the flag for you
06:51:54 <Sintendo> I'm going to need more directions than 'just get your hand dirty with them' when it comes to monads :\
06:52:37 <rwbarton> unfortunately the flag defaults to false in the .cabal file
06:53:44 <shachaf> rwbarton: Cabal backtracks oflags?
06:53:57 <shachaf> I thought you always had to manually set them.
06:53:59 <rwbarton> was that 'o' a typo?
06:54:01 <shachaf> Yes.
06:54:03 <rwbarton> yes
06:54:14 <shachaf> Hm.
06:54:22 <rwbarton> if they are not "manual" flags
06:54:22 <ramses_> neworder: don't you see the pattern yet?
06:54:27 <neworder> haha
06:54:28 <shachaf> Ah.
06:54:36 <neworder> I keep seeing it like this
06:54:47 <shachaf> 1 : (map (*2) pow) -> 1 : 2*1 : map (*2) (map (*2) pow)
06:54:48 <neworder> I feel like map (2*) pow replaces the 1 in the list
06:54:50 <shachaf> That doesn't look right.
06:55:11 <rwbarton> that's how you express disjunctions in general, with an automatic flag
06:55:19 <yitz> shachaf: ok, i see that you do need to use cabal-dev from github, not from hackage, for 7.6.
06:55:20 <shachaf> Oh, well, I guess.
06:55:25 <shachaf> yitz: OK.
06:55:26 <geekosaur> pauser, no, that is what show does, if you don;t want that then you don't want show.  (It's not there to be a prettyprinter, it's there to serialize values.)
06:55:40 <shachaf> yitz: Fortunately my goal wasn't to install cabal-dev in the first place. :-)
06:55:53 <shachaf> GHC 7.6 has been out for almost a quarter of a year now?
06:56:06 <shachaf> Hopefully by the time I care about cabal-dev, it'll be up to date.
06:56:08 <yitz> shachaf: while development is active, no one has uploaded a new version to hackage for a long time. tickets requesting that have gone unanswered. that is very weird.
06:56:39 <neworder> At first, the list contains 1:[map (2*) pow] right?
06:56:54 <neworder> 1 cons with the rest of the list
06:57:09 <neworder> and the rest of the list is computed using the function map (2*) pow
06:57:09 <yitz> shachaf: but anyway, it works fine on ghc 7.6. but you have to use a version from github, for this and other reasons. the version on hackage is showing bitrot.
06:57:13 <neworder> Then after that
06:57:33 <neworder> On which list does map (2*) pow  work on?
06:57:48 <neworder> Sorry I'm getting confused :S
06:57:49 <atriq> Is it possible to derive Ix instances?
06:57:57 <shachaf> "just use HEAD" isn't really a reasonable thing to tell a user. :-)
06:59:32 <atriq> Oh, it is.
06:59:48 <atriq> Wish I realized earlier
07:01:08 <shachaf> neworder: pow = 1 : x
07:01:16 <shachaf> x = map (*2) pow
07:01:29 <shachaf> x = 2 : y
07:01:30 * hackagebot aeson-lens 0.4.0.1 - Lens of Aeson  http://hackage.haskell.org/package/aeson-lens-0.4.0.1 (HideyukiTanaka)
07:01:32 <shachaf> y = map (*2) x
07:01:34 <shachaf> ...
07:02:08 <neworder> How do you get from x = map (*2) pow to x = 2 : y
07:02:18 <shachaf> @src map
07:02:18 <lambdabot> map _ []     = []
07:02:19 <lambdabot> map f (x:xs) = f x : map f xs
07:02:27 <neworder> what is the argument of the map function
07:02:31 <shachaf> map (*2) (a:as) = a * 2 : map f as
07:02:47 <shachaf> neworder: I think you might want to look at simpler examples and make sure you understand them before coming back to this.
07:02:47 <yitz> shachaf: if their method of public releases is github, not hackage, then "just get it from github" is reasonable.
07:03:03 <shachaf> It's kind of confusing because you recursively use parts of the same list.
07:03:09 <yitz> shachaf: even though i, like you, find that approach annoying.
07:03:19 <neworder> hmm
07:03:42 <watermind> neworder: start with x = 1:x
07:03:58 <watermind> neworder: then x = 1 : map (+1) x
07:04:26 <neworder> Isn't this less confusing? =)
07:04:28 <neworder> pow = 1 : x
07:04:34 <shachaf> I think "start with non-infinite lists"
07:04:39 <neworder> x = map (*2) pow
07:04:43 <shachaf> You should understand how map works before doing any of this
07:04:45 <yitz> shachaf: as another example, i'm interested in music, and i like euterpea. but they keep saying, "we haven't had time to put together a stable release yet, so we haven't uploaded to hackage. just get it here, from darcs." for years. it makes not sense to me.
07:04:49 <yitz> s/not/no/
07:04:52 <ramses_> neworder: maybe try this function first: ones = 1 : ones
07:04:56 <neworder> Yup, map applies a function to every element in the list
07:05:16 <neworder> I mean takes in a function as an argument and applies it to every element in the list
07:05:18 <shachaf> neworder: More intuition that that. :-)
07:05:29 <shachaf> 07:02 <neworder> what is the argument of the map function
07:05:45 <yitz> shachaf: but for any of those things, as much as i disagree, i'm not going to shoot myself in the foot by not installing important packages just becasue i disagree with the package author's philosophoy about how to use hackage.
07:05:51 <neworder> ramses_ It's an infinite list of ones right
07:06:05 <shachaf> yitz: OK.
07:06:06 <ramses_> yes, do you see how every element gets generated?
07:06:11 <shachaf> I don't have much of a reason to use cabal-dev, though.
07:06:26 <neworder> Here I don't see what's the argument to the map function
07:06:28 <shachaf> If it turns out that not using cabal-dev is stupid and hopelessly broken, I can always install cabal-dev
07:06:31 * hackagebot ohloh-hs 0.0.1 - Interface to the Ohloh API  http://hackage.haskell.org/package/ohloh-hs-0.0.1 (FrankThomas)
07:06:36 <Shapeshifter> So, did I understand this correctly that both Functor and Monad require their instances to have exactly one type variable (i.e. kind * -> *)?
07:06:43 <yitz> shachaf: :)
07:06:44 <shachaf> Shapeshifter: Yes.
07:06:54 <shachaf> Well, the kind * -> * part is true.
07:07:00 <shachaf> I don't know what "exactly one type variable" is.
07:07:09 <shachaf> One argument (of kind *)? Yes.
07:07:15 <watermind> Shapeshifter: you can do :i Functor to confirm the kind is correct
07:07:20 <neworder> wait, lemme think, I tihnk it's getting clearer
07:07:43 <Shapeshifter> shachaf: basically between "data" and "=" there will be only one lower case character. E.g. data Foo a = Foo a.
07:08:08 <yitz> shachaf: well, i sure hope the cabal sandboxing upgrade will not get stuck like hackage 2. if it doesn't, this whole cabal-dev thing is only temporary anyway.
07:08:18 <shachaf> That's an awfully syntactic way of talking about it. :-)
07:08:25 <shachaf> Anyway, yes.
07:08:33 <shachaf> The kind is * -> *
07:08:53 <Shapeshifter> Ok thanks. That is kind of important, I never realized it while reading lyah but it makes thinking about monads easier if this much is clear.
07:09:44 <shachaf> Shapeshifter: The way to "understand monads", whatever that means, is to look at a lot of concrete examples without even thinking the M word in your head.
07:09:45 <watermind> Shapeshifter: you can infer that from the class declaration because in  class Monad m  where, you then have return :: a -> m a
07:10:09 <shachaf> You'll figure out the common pattern eventually. :-)
07:11:32 <watermind> Shapeshifter: and a :: *  and m a :: * because of the left and right hand sides of a -> m a
07:11:43 <yitz> lispy: ping
07:11:52 <watermind> Shapeshifter: therefore m :: * -> *
07:14:50 <neworder> pow = 1 : x
07:14:58 <neworder> x = map (*2) pow
07:15:04 <neworder> 2 is multiplied to every element in pow, Therefore
07:15:12 <neworder> x=2:2*x
07:15:17 <neworder> Then? =)
07:15:40 <watermind> neworder: just work equationally
07:15:45 <ramses_> neworder: looks correct :)
07:15:48 <shachaf> neworder: x=2:2*x is a type error
07:15:52 <shachaf> You can't multiply a list by 2.
07:16:02 <Sintendo> what's wrong with this for a State monad: (>>=) state1 f = MyState (\stateArg -> f (fst (run state1 stateArg)))
07:16:04 <neworder> Hmm ok
07:16:09 <neworder> So what should I do
07:16:19 <neworder> I mean I know that doesn't make sense
07:16:26 <neworder> but working it out mechanically
07:16:27 <ramses_> I think he just gave the idea
07:16:28 <neworder> I get that
07:16:31 <neworder> Yup
07:16:32 <shachaf> @ty foo state1 f = \stateArg -> f (fst (state1 stateArg))
07:16:34 <lambdabot> parse error on input `='
07:16:36 <shachaf> @ty let foo state1 f = \stateArg -> f (fst (state1 stateArg)) in foo
07:16:38 <lambdabot> (t1 -> (a, b)) -> (a -> t) -> t1 -> t
07:16:48 <shachaf> Sintendo: That type doesn't look right to me.
07:16:55 <shachaf> Trust your type checker!
07:16:57 <ramses_> neworder: 2*x should be map (*2) x
07:17:14 <shachaf> neworder: Work it out more mechanically.
07:17:17 <ramses_> from map's recursive definition
07:17:19 <neworder> AH!
07:17:19 <Sintendo> but f should be returning a m b?
07:17:33 <neworder> Think I get it!
07:17:38 <mbuf> what would be an alternative style of writing deeply nested levels of if-then-else where the if condition checks the exit status of a function call?
07:17:58 <shachaf> mbuf: Maybe?
07:18:04 <shachaf> Either?
07:18:09 <shachaf> Lots of things.
07:18:32 <mbuf> shachaf, is there an example I can refer?
07:18:58 <shachaf> > do { x <- Right 1; y <- Right 2; return (x + y) }
07:19:00 <lambdabot>   Right 3
07:19:05 <shachaf> > do { x <- Right 1; y <- Left "oh no!"; return (x + y) }
07:19:07 <lambdabot>   Left "oh no!"
07:19:38 <atriq> mbuf, what I think you are looking for is a case expression
07:20:03 <shachaf> mbuf: Without knowing your code there's only so much people can do.
07:20:18 <shachaf> I mean, I can make up some hypothetical code in nested style, and then convert it to unnested style.
07:20:31 <shachaf> But my hypothetical code won't be the same as your non-hypothetical code. :-)
07:21:01 <mbuf> shachaf, atriq for example https://gist.github.com/4143940
07:21:39 <parcs`> christ
07:22:19 <shachaf> Your indentation is all wrong. :-(
07:22:26 <shachaf> Those elses should line up with their thens.
07:22:44 <shachaf> What's the type of runRpmBuild?
07:22:45 <mbuf> shachaf, I see
07:22:54 <atriq> For a start, instead of saying "if a == True" you can say "if a"
07:23:11 <shachaf> mbuf: It makes the code hard to read.
07:23:30 <mbuf> shachaf, runRpmBuild :: String -> String -> IO (Bool, [Char])
07:23:45 <shachaf> You can probably abstract this whole thing into one list function.
07:23:45 <watermind> neworder: don't just "think you get it", derive it equationally... also personally I think x = map (*2) (1:x)    makes it more simpe
07:23:50 <shachaf> mbuf: What's the Bool for?
07:24:00 <watermind> neworder: get rid of the mutual recursion
07:24:05 <shachaf> What's the meaning of (False, "blah") and (True, "blah")?
07:24:05 <mbuf> shachaf, exit status, True or False
07:24:15 <shachaf> OK, so the text is just output.
07:24:19 <mbuf> shachaf, yes
07:24:31 <mbuf> shachaf, ExitSuccess, or if there is an error, it contains the error message
07:24:37 <neworder> Hmm yes watermind
07:24:55 <neworder> that looks simpler
07:24:58 <Sintendo> i don't get what >>= for a state monoid should be doing
07:25:25 <shachaf> Sintendo: (>>=) isn't for Monoid. :-)
07:25:32 <shachaf> Sintendo: I suggest you shouldn't worry about it right now.
07:25:35 <mbuf> shachaf, I have used if a, and also aligned the else with the then
07:25:44 <watermind> neworder: one second I'll paste something for you
07:25:47 <parcs`> mbuf: you can make a function 'runRpmBuilds :: Spec -> [String] -> IO ()'
07:25:48 <shachaf> Sintendo: Can you write some plain code without any monads, just passing the state through by hand?
07:26:09 <neworder> sure
07:26:17 <neworder> thanks
07:26:25 <k00mi> mbuf: did you write runRpmBuild?
07:26:26 <mbuf> shachaf, parcs` https://gist.github.com/4143940
07:26:30 <Sintendo> I tried writing dijkstra 3 times like that, and failed miserably because of all the crap I had to pass around all the time
07:26:44 <mbuf> k00mi, yes, I have pasted the function for it now
07:26:51 <k00mi> i see
07:27:07 <mbuf> just learning how to write it properly
07:27:21 <parcs`> mbuf: ok, now recursively define 'runRpmBuilds :: Spec -> [String] -> IO ()'
07:30:03 <mbuf> parcs`, [Strings] has ["-bp", "-bc", "-bb", "-bb"]? how would we handle the exit status?
07:30:47 <hpaste> watermind pasted “x = map (*2) (1:x)” at http://hpaste.org/78214
07:30:57 <watermind> neworder: there
07:31:02 <parcs`> mbuf: run the first build. if it succeeds, run the rest of the builds. if it fails, print a failure message. if there are no more builds, return ()
07:31:22 <neworder> ok
07:31:38 <parcs`> mbuf: you should reuse runRpmBuild
07:31:42 <shachaf> watermind is choosing a rather more call-by-namey interpretation than I would. :-)
07:31:49 <mbuf> parcs`, I see
07:31:53 <watermind> neworder: ops wait
07:31:59 <watermind> neworder: forgot to delete one line there
07:32:46 <Sintendo> so you're essentially telling me to give up on monads for now? Because that's not very... encouraging to ever pick them up at all.
07:33:00 <shachaf> Sintendo: Did you read the FAQ?
07:33:02 <FireFly> Couldn't you make use of Either and define a helper function like so:  f flag = runRpmBuild spec flag >>= \(status, res) -> if status then Right res else Left (flag ++ " failure")
07:33:03 <shachaf> @where faq
07:33:03 <hpaste> watermind pasted “x = map (*2) (1:x) ” at http://hpaste.org/78216
07:33:04 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
07:33:14 <Sintendo> several times now, yes
07:33:14 <watermind> neworder: ok, now it's fine :P
07:33:57 <shachaf> Sintendo: Did you see 8.3?
07:33:58 <watermind> neworder: see that derivation ^ http://hpaste.org/78216
07:33:59 <shachaf> And also 8.6
07:34:24 <Sintendo> yes
07:34:37 <shachaf> Do you understand everything mentioned there?
07:34:50 <Sintendo> for the most part, yes
07:35:31 <watermind> neworder: so you just successively substitute x by it's definition, and transform things of the form   map (*2) k:something  into   2*k : map (*2) something
07:35:34 <shachaf> "picking up monads" isn't somethig you do, really, in the same way that you "pick up" other things.
07:35:36 <watermind> neworder: that's all
07:35:52 <k00mi> FireFly: you could, but it would make more sense to rewrite runRpmBuild to use Either and parcs` probably doesn't want to mention monads to mbuf ye
07:35:56 <k00mi> +t
07:36:10 <FireFly> Oh, okay
07:36:17 <shachaf> Sintendo: Why are you so eager about it? Is it stopping you from learning some other concrete thing?
07:36:44 <Sintendo> Well, I kinda do have to understand them at some point for the exam
07:36:51 <shachaf> Oh.
07:36:56 <watermind> neworder: if you can reason equationally you can see the list being constructed from its definitions, and you don't need to guess the result
07:37:08 <shachaf> Well, unfortunately that's a bit of motivation I can't help you with. :-)
07:37:08 <Sintendo> and I was also hoping that it would help simplify some things we have to do for an assignment
07:37:23 <shachaf> Sintendo: My advice stays the same, though.
07:37:30 <shachaf> Understand a lot of individual things really well.
07:37:52 <shachaf> Includings lists and Maybe and IO (?) and functions and state-threading and what not.
07:38:29 <shachaf> Once you understand them all, it'll be relatively easy to see the abstraction that they all have in common.
07:39:05 <Saizan> or, you could understand typeclasses
07:39:14 <k0ral> is the Writer monad a good idea to have my functions log information (debug, warnings, errors...) ?
07:39:22 <shachaf> k0ral: Sure.
07:39:30 <shachaf> Depending on what you're doing.
07:39:39 <Sintendo> I thought I had most of that down pretty well at this point, but I guess maybe not
07:39:42 <k0ral> I have the feeling it only allows logs to be written at the end of the program
07:40:13 <k0ral> I mean: using a global runWriterT, I will only be able to collect the logs when the inner function exits
07:40:14 <shachaf> Sintendo: You just mentioned you had a lot of trouble writing a function of the type (s -> (a,s)) -> (a -> s -> (b,s)) -> s -> (b,s) that does what you want.
07:40:20 <neworder> watermind: Thanks a lot! Really really appreciate it! =D
07:40:23 <shachaf> That's a good exercise regardless of monads.
07:40:27 <parcs`> k00mi: i think monad transformers are overkill there
07:40:30 <shachaf> So figure that one out. :-)
07:40:33 <neworder> That was really helpful
07:41:09 <watermind> Sintendo: I think Monads are rather easy  IF  you start at the right place, with the right monads and with the right monadic functions, i.e.  fmap, return and join rather than  return and >>=
07:41:47 <shachaf> watermind: Everyone will tell you "monads are easy if you just look at it from my perspective!", though.
07:41:49 <watermind> Sintendo: what makes monads confusing is that sometimes people start with complicated monads, and then try to think about >>= which is weird
07:41:54 <k00mi> parcs`: it would be a wonderful demonstration IMHO
07:42:04 <watermind> schlumpi: well I think everyone is right then :P
07:42:21 <watermind> ops shachaf ^
07:42:45 <shachaf> People tend to be misguided when they say that.
07:42:49 <k0ral> if I have a pure fonction f from which I want some feedback, I would like not to turn it into IO just for the logging purpose
07:43:08 <watermind> shachaf: but it is easy... Maybe is very very simple, and then [ ] is ok too
07:43:13 <hiptobecubic> k0ral, Debug.Trace
07:43:21 <watermind> shachaf: fmap is trivial, return is trivial, and join is easy
07:43:51 <shachaf> Everything is trivial.
07:44:00 <watermind> shachaf: now if theystart with State and >>= they have a problem, because State is complicated and so is >>=
07:44:24 <k0ral> hiptobecubic: this is only useful for debugging
07:44:42 <shachaf> watermind: If you attempt to understand State in order to "understand monads", you're doing things wrong.
07:44:42 <latermuse> monads are quite strange. They are so easy, yet are difficult to learn. Everyone seems to require their own method of learning them.
07:44:49 <hiptobecubic> k0ral, oh, what do you want?
07:44:50 <shachaf> First figure out how state-threading works.
07:44:53 <k0ral> hiptobecubic: I also want to log useful information not related to debug
07:44:57 <shachaf> For its own sake -- it's a useful thing.
07:44:59 <watermind> shachaf: that's basically whaty I was saying :)
07:45:02 <shachaf> Then you can see how to generalize it.
07:45:11 <hiptobecubic> k0ral, so you want your pure function to have magic side effects?
07:45:20 <xunatai> hehe
07:45:24 <shachaf> watermind: Maybe. Who cares.
07:45:37 <watermind> shachaf: yes of course, you need many instances, my point is some people don't start with the simplest instances
07:45:57 <shachaf> Yes. And they shouldn't.
07:46:00 <watermind> shachaf: nor the simplest monad definition (which is not the one in Prelude)
07:46:11 <k0ral> hiptobecubic: well, from what I understand, if I want to keep my functions pure, I have to delay the display of logs until an IO function has the opportunity to deal side effects
07:46:24 <shachaf> "starting with Identity" in order to "understand monads"" is counterproductive.
07:46:30 <k0ral> basically, the closer caller function
07:46:32 <watermind> shachaf: well they should start with the definition of Monad of course, but they have to eventually see some instance of it
07:46:45 <hiptobecubic> k0ral, I am sure there is a monadic way to thread a log along with your computation
07:46:47 <watermind> shachaf: yeah that's why I said Maybe not Id
07:47:03 <k0ral> hiptobecubic: but I don't want this delay to be too long
07:47:05 <shachaf> watermind: Maybe is in the Prelude.
07:47:10 <shachaf> And it's also a bad example.
07:47:14 <k0ral> hiptobecubic: and I certainly don't want it to be random
07:47:23 <shachaf> It's almost 8 and I have yet to sleep.
07:47:36 <shachaf> I don't feel like getting into a fruitless argument about monad pedagogy.
07:47:36 <k0ral> hiptobecubic: the log threading is not the problem
07:47:52 <hiptobecubic> k0ral, you can't safely write out to a log in a pure function.
07:47:53 <watermind> shachaf: yes but studying its defintion is a good starting point... and why is it bad?
07:48:02 <k0ral> hiptobecubic: the problem is: how will I print them in real time
07:48:05 <shachaf> You should read byorgey's post on the topic, mostly because it'll teach you not to trust your intuition about how to teach this subject.
07:48:07 <watermind> shachaf: ouch ok
07:48:08 <shachaf> @where burrito
07:48:08 <lambdabot> http://byorgey.wordpress.com/2009/01/12/abstraction-intuition-and-the-monad-tutorial-fallacy/
07:48:14 <watermind> shachaf: thanks!
07:48:21 <shachaf> watermind: ☝ good post
07:48:24 <hiptobecubic> k0ral, then you need to be close to IO
07:48:31 <watermind> shachaf: I'll read it! thank you
07:48:58 <shachaf> watermind: (Nothing personal intended here, by the way. I've been part of this argument way too many times already. :-) )
07:49:01 <hiptobecubic> k0ral, maybe looping in IO and logging in between function calls?
07:49:08 <k0ral> hiptobecubic: I think I'll delay the log until the caller IO function gets the opportunity to print them
07:49:27 <Sintendo> My major issue is that I seem to understand the Maybe and [] monads, but fail to see their usefulness
07:49:28 <hiptobecubic> k0ral, that is all you can safely do I believe.
07:49:38 <Sintendo> while for State it's the exact opposite
07:49:38 <hiptobecubic> Sintendo, because you haven't used them.
07:49:52 <shachaf> Sintendo: What does it mean to "understand the [] monad"?
07:49:57 <shachaf> [] is a type which happens to be a monad.
07:50:03 <shachaf> An instance of Monad, that is.
07:50:12 <k0ral> hiptobecubic: allright, I just have to live with the fact that some logs may be lost in case there is an interruption between the moment logs are raised and the moment they are printed
07:50:14 <shachaf> Do you mean that you understand the implementations of (>>=) and return?
07:50:28 <Sintendo> yes, that's what i meant
07:50:38 <hiptobecubic> k0ral, you mean exception handling or something? Use bracketing maybe?
07:50:40 <Sintendo> I understand the implementation for those specific instantiations
07:51:32 <shachaf> Great.
07:51:39 <k0ral> hiptobecubic: yes, but power outage e.g. won't be handled
07:51:44 <shachaf> The only advantages of making these an instance of Monad are
07:51:52 <shachaf> (a) you get to use "do" notation
07:51:58 <shachaf> (b) you get to use functions from Control.Monad
07:52:10 <shachaf> > sequence ["hello","there"]
07:52:12 <lambdabot>   ["ht","hh","he","hr","he","et","eh","ee","er","ee","lt","lh","le","lr","le"...
07:52:31 <shachaf> > filterM (\_ -> [False,True]) "hello"
07:52:33 <lambdabot>   ["","o","l","lo","l","lo","ll","llo","e","eo","el","elo","el","elo","ell","...
07:52:40 <hiptobecubic> k0ral, it's pretty difficult write programs which guarantee execution in the face of hardware destruction, yes.
07:52:45 <hiptobecubic> difficult to*
07:54:44 <watermind> shachaf: it is an interesting post, and I agree with everything in it... but I don't see where it contradicts that it's easier to think about join and fmap than >>=, nor does it disagrees that the progression in concrete examples should be from simpler to more complex instances (which is a rather obvious observation), anyway I'll quite talking about this
07:54:51 <watermind> *quit
07:55:27 <hiptobecubic> @src sequence []
07:55:27 <lambdabot> Source not found. Just try something else.
07:55:31 <shachaf> It doesn't. I don't contradict that either.
07:55:41 <hiptobecubic> :t sequence
07:55:43 <lambdabot> Monad m => [m a] -> m [a]
07:55:46 <watermind> well that's the only point I was making
07:55:50 <hiptobecubic> :t filterM
07:55:51 <lambdabot> Monad m => (a -> m Bool) -> [a] -> m [a]
07:57:20 <hiptobecubic> :t lift
07:57:22 <lambdabot> (Monad m, MonadTrans t) => m a -> t m a
07:57:59 <hiptobecubic> :t return
07:58:00 <lambdabot> Monad m => a -> m a
07:58:44 <Sintendo> :t (<<=)
07:58:46 <lambdabot>     Not in scope: `<<='
07:58:46 <lambdabot>     Perhaps you meant one of these:
07:58:46 <lambdabot>       `<=' (imported from Data.Ord), `<<<' (imported from Control.Arrow),
07:58:48 <hiptobecubic> > filterM (return (const [False, True])) "Maybe?"
07:58:50 <lambdabot>   Couldn't match expected type `GHC.Types.Bool'
07:58:50 <lambdabot>              with actual type...
07:58:53 <Sintendo> oh crap wrong window
07:59:51 <hiptobecubic> > filterM (const [False, True]) "Oh, right."
07:59:53 <lambdabot>   ["",".","t","t.","h","h.","ht","ht.","g","g.","gt","gt.","gh","gh.","ght","...
08:00:11 <hiptobecubic> > filterM (return [False, True]) "Oh, right."
08:00:13 <lambdabot>   ["",".","t","t.","h","h.","ht","ht.","g","g.","gt","gt.","gh","gh.","ght","...
08:02:20 <hiptobecubic> > filterM (return [True, False]) "Oh, right."
08:02:22 <lambdabot>   ["Oh, right.","Oh, right","Oh, righ.","Oh, righ","Oh, rigt.","Oh, rigt","Oh...
08:03:24 <mbuf> shachaf, k00mi parcs` https://gist.github.com/4143940
08:03:42 <donri> silly question: what power does MonadPlus have that Monoid doesn't, seeing as all MonadPlus methods are "m a"?
08:04:02 <aristid> > filterM (return [False,True]) "Oh, right."
08:04:04 <lambdabot>   ["",".","t","t.","h","h.","ht","ht.","g","g.","gt","gt.","gh","gh.","ght","...
08:04:13 <yitz> donri: it can launch missiles
08:04:30 <aristid> donri: it's got a different kind.
08:04:46 <donri> but does the kind matter when all methods act on "m a" anyway?
08:05:01 <donri> i'm missing something obvious, i feel
08:05:05 <aristid> donri: it guarantees that _all_ m a are MonadPlus, for any a
08:05:09 <hiptobecubic> :t mplus
08:05:13 <lambdabot> MonadPlus m => m a -> m a -> m a
08:05:21 <hiptobecubic> :t mappend
08:05:21 <aristid> donri: it also has a Monad constraint ;)
08:05:22 <lambdabot> Monoid a => a -> a -> a
08:05:36 <parcs`> mbuf: that's a good start
08:05:39 <donri> aristid: sure but why not instance Monoid (SomeMonad a)
08:05:55 <shachaf> donri: There are laws about the interaction of MonadPlus and Monad
08:06:03 <aristid> donri: because that does not transparently guarantee that it works with all a
08:06:09 <aristid> shachaf: aren't those contested?
08:06:12 <aristid> @localtime shachaf
08:06:14 <lambdabot> Local time for shachaf is Sun Nov 25 08:05:55 2012
08:06:14 <mbuf> parcs`, looks better now; thanks!
08:06:24 <aristid> shachaf: zzzzZzzzZzzzzZ :P
08:08:03 <aristid> donri: the default Monoid instance for Maybe places a Monoid constraint on the inner a. for the MonadPlus instance, this would be illegal
08:08:44 <donri> ah yea
08:08:48 <shachaf> aristid: If they're contested, then why call it MonadPlus?
08:09:01 <copumpkin> MonadMinus
08:09:08 <copumpkin> it's a torsor!
08:09:43 <aristid> shachaf: i think people agree that it somehow relates to Monad, but _which_ laws exactly MonadPlus should follow is less clear:)
08:09:45 <notdan> Sorry for a noob question, but could it be that lifting (||) into a monad (State) might make it.. not lazy?
08:10:00 <aristid> i think associativity and mempty being the identity are the least controversial laws :D
08:10:45 <donri> do you mean mzero
08:12:05 <Prezioso> Im trying to cabal install a yesod init build. I get this error: .cabal/bin/.copyFile27984.tmp: inappropiate type
08:12:26 <atriq> It occurs to me I don't know GUI programming at all
08:14:58 <hpaste> haskelled pasted “GADT fails deriving read” at http://hpaste.org/78217
08:15:23 <haskelled> having some difficulty deriving read for a GADT, if anyone could help would be much appreciated
08:15:58 <haskelled> using a standalone deriving instance, it works for show but its complaining for read for some reason
08:16:34 * hackagebot cryptohash 0.7.9 - collection of crypto hashes, fast, pure and practical  http://hackage.haskell.org/package/cryptohash-0.7.9 (VincentHanquez)
08:19:09 <notdan> http://hpaste.org/78218 why am I getting an exception there?
08:19:18 <notdan> I thought (||) was lazy, even if you lift it
08:19:27 <Nereid> uh no
08:19:45 <Nereid> liftM2 is not.
08:20:05 <Nereid> returnTrue `orM` return undefined should work.
08:20:30 <Nereid> but orM evaluates its second argument regardless.
08:20:56 <notdan> Hm, I see. However, if I rewrite it using the sequence of if then else statements it works lazily
08:21:14 <Nereid> your rewrite is not the same then.
08:21:51 <Nereid> observe: orM x y = do { a <- x; b <- y; return (a || b) }
08:22:02 <Nereid> y is evaluated before the return
08:22:10 <shachaf> No, y is executed before the return.
08:22:11 <lambdabot> shachaf: You have 1 new message. '/msg lambdabot @messages' to read it.
08:22:15 <Nereid> fine.
08:22:20 <Nereid> y is evaluated before the whole thing is evaluated.
08:22:33 <notdan> Ah,I see
08:22:35 <notdan> you are right
08:22:49 <Nereid> else how would it know to distinguish between:
08:22:54 <notdan> Well, I guess I'll have to abandon liftM2 for now
08:22:57 <Nereid> > liftM2 (||) (Just True) (Just False)
08:22:59 <lambdabot>   Just True
08:23:00 <Nereid> > liftM2 (||) (Just True) Nothing
08:23:02 <lambdabot>   Nothing
08:24:20 <Nereid> but yes I meant executed, not evaluated.
08:25:09 <shachaf> Nereid: Depending on >>=, y might not be evaluated at all.
08:25:17 <Nereid> yes I know.
08:25:17 <shachaf> Execution is what counts here. :-)
08:25:22 <Nereid> I'm just tired.
08:26:17 <haskelled> anyone have some experience with GADTs and standalone deriving instances?
08:26:24 <Nereid> > liftM2 (||) Nothing (Just True)
08:26:26 <lambdabot>   Nothing
08:26:27 <Nereid> > liftM2 (||) Nothing undefined
08:26:29 <lambdabot>   Nothing
08:26:41 <Nereid> I have used GADTs and standalone deriving instances. what about them?
08:27:32 <notdan> Yeah, I was looking for this one http://hackage.haskell.org/packages/archive/syb/latest/doc/html/Data-Generics-Aliases.html#v:orElse
08:28:43 <haskelled> Nereid: I'm having some trouble deriving read for a GADT
08:28:52 <haskelled> http://hpaste.org/78217
08:30:39 <copumpkin> haskelled: you can't really have Read for a GADT that refines its indices
08:30:45 <copumpkin> you could make an existential wrapper around it and have Read on that
08:31:06 <copumpkin> but I doubt the deriving mechanism would work with that (it'd be awesome if it could though)
08:31:57 <Nereid> how would it infer which type to use for the arguments to Eq though?
08:32:10 <copumpkin> Eq?
08:32:16 <Nereid> the constructor Eq
08:32:25 <copumpkin> oh I see
08:32:29 <hiptobecubic> > (x :+ y) + 3
08:32:31 <lambdabot>   No instance for (GHC.Float.RealFloat Debug.SimpleReflect.Expr.Expr)
08:32:31 <lambdabot>    aris...
08:32:49 <hiptobecubic> Why does it want RealFloat for (+) ?
08:32:56 <Nereid> it wants RealFloat for :+
08:33:02 <Nereid> > x :+ y
08:33:03 <hiptobecubic> > (x :+ y)
08:33:04 <lambdabot>   x :+ y
08:33:05 <lambdabot>   can't find file: L.hs
08:33:08 <Nereid> hmm
08:33:15 <Sintendo> oh wow
08:33:17 <hiptobecubic> :t (x :+ y)
08:33:19 <lambdabot> Complex Expr
08:33:24 <Sintendo> I got my State monad to work
08:33:30 <Sintendo> I think I'm starting to get it now
08:33:31 <Nereid> or rather, it needs it for the Num instance
08:33:45 <Nereid> instance RealFloat a => Num (Complex a)
08:34:06 <hiptobecubic> hm
08:34:16 <hiptobecubic> :t (1 :+ 2)
08:34:18 <lambdabot> Num a => Complex a
08:34:29 <hiptobecubic> :t (1 :+ (2 :: Integer))
08:34:30 <lambdabot> Complex Integer
08:34:33 <Nereid> yes, it needs that to implement abs
08:34:35 <Nereid> :t magnitude
08:34:36 <lambdabot>     Ambiguous occurrence `magnitude'
08:34:37 <lambdabot>     It could refer to either `Data.Complex.magnitude',
08:34:37 <lambdabot>                              imported from `Data.Complex' at State/L.hs:24:1-19
08:34:37 <hiptobecubic> :t (1 :+ (2 :: Integer))  + 3
08:34:39 <lambdabot>     No instance for (RealFloat Integer)
08:34:39 <lambdabot>       arising from a use of `+'
08:34:39 <lambdabot>     Possible fix: add an instance declaration for (RealFloat Integer)
08:34:40 <Nereid> :t Data.Complex.magnitude
08:34:42 <lambdabot> RealFloat a => Complex a -> a
08:34:52 <hiptobecubic> that's unfortunate
08:34:59 <Nereid> a lot of things are unfortunate
08:35:34 <haskelled> copumpkin: ok thanks for looking at it
08:36:07 <hiptobecubic> :info RealFloat
08:36:11 <hiptobecubic> oh right
08:36:17 <Nereid> :i RealFloat
08:36:28 <Nereid> @info RealFloat
08:36:29 <lambdabot> RealFloat
08:36:36 <Nereid> great.
08:36:37 <hiptobecubic>  @info doens't exist
08:36:49 <Nereid> evidently it does, it's just useless
08:36:52 <hiptobecubic> but that's exactly what i said too
08:36:59 <hiptobecubic> it gets autocorrected to something else which i forgot
08:37:05 <Nereid> oh
08:37:08 <Nereid> @i
08:37:09 <lambdabot> Maybe you meant: id ignore index instances instances-importing irc-connect . ? @ v
09:00:08 <jamy> hello
09:00:28 <mapf> hi
09:02:08 <jamy> @let plusOne = fmap (+1)
09:02:10 <lambdabot>  Defined.
09:02:18 <xunatai> oh
09:02:22 <xunatai> so that's how you do that
09:02:35 <xunatai> plusOne [1,2]
09:02:40 <xunatai> > plusOne [1,2]
09:02:42 <lambdabot>   [2,3]
09:03:48 <jamy> > plusOne _|_
09:03:50 <lambdabot>   <hint>:1:10: parse error on input `|'
09:04:03 <jamy> > plusOne (_|_)
09:04:05 <lambdabot>   <hint>:1:11: parse error on input `|'
09:04:49 <jamy> > plusOne ['2', '3']
09:04:51 <lambdabot>   No instance for (GHC.Num.Num GHC.Types.Char)
09:04:51 <lambdabot>    arising from a use of `L.pl...
09:07:07 <jamy> > plusOne []
09:07:09 <lambdabot>   []
09:07:28 <donri> > plusOne undefined
09:07:30 <lambdabot>   No instance for (GHC.Show.Show (f0 b0))
09:07:31 <lambdabot>    arising from a use of `M51970928...
09:08:04 <donri> > plusOne undefined :: [Int]
09:08:06 <lambdabot>   *Exception: Prelude.undefined
09:08:14 <jamy> :t plusOne
09:08:16 <lambdabot> (Functor f, Num b) => f b -> f b
09:09:41 <jamy> > plusOne (1,2)
09:09:43 <lambdabot>   (1,3)
09:09:58 <jamy> > plusOne (1,2,3)
09:09:59 <lambdabot>   No instance for (GHC.Base.Functor ((,,) t0 t1))
09:10:00 <lambdabot>    arising from a use of `e...
09:11:34 <jamy> > plusOne (2,3)
09:11:36 <lambdabot>   (2,4)
09:11:47 <eikke> would anyone have reference material / pointers to papers about state-of-the-art persistent arrays?
09:13:13 <mapf> eikke: repa maybe?
09:14:13 <eikke> mapf: afaik repa works on continuous unboxed vectors and requires (after fusion) copying
09:16:50 <jamy> ping homosapiens
09:17:02 <mdszy> How do you create an instance of a custom data structure?
09:17:22 <eikke> mdszy: using its constructor?
09:17:23 <hpc> mdszy: do you mean a value of that type, or a class instance?
09:17:34 <mapf> eikke: i don't know if there are exist something more state-of-art'ish )
09:18:02 <eikke> mapf: I'm rather looking for something like Bagwell's VLists
09:18:06 <mdszy> one moment
09:18:16 <mdszy> this is my current program http://sprunge.us/DQFI?haskell
09:19:10 <mdszy> hpc, not with a type, I don't think. I think a class instance.
09:19:18 <Prezioso> How do I unstall in cabal? I tried --force-reinstalls yesod-platform since it gave me an error on installing a project.  I tried to use my distro (archlinux) to install yesod, but this is even worse :S
09:19:35 <eikke> mdszy: your Todo type has one constructor, Title
09:19:43 <geekosaur> Prezioso, cabal doesn;t uninstall.  ghc-pkg unregister
09:19:54 <mapf> Prezioso: cabal is not a package manager
09:19:55 <eikke> mdszy: so to create a "Todo", you'd use 'Title "a" "b" "c"'
09:20:52 <mdszy> eikke, I'm sorry, but I'm still confused
09:22:06 <Prezioso> geekosaur: Okay, so ghc-pkg unregister yesod and each of the dependencies?
09:22:41 <geekosaur> yes
09:23:05 <mapf> mdszy: you actually created 'instance' of your datatype in parseItem
09:23:20 <Prezioso> geekosaur: puuh... a lot of work :D
09:23:23 <mdszy> mapf, isn't that what I'm trying to do? Or do I have that wrong?
09:25:30 <mapf> mdszy: i'm not sure that do you want to do. parseItem can looks like: parseItem line = Todo a b c where [a, b, c] = words line
09:25:47 <mapf> but you should handle error cases
09:27:23 <donri> you don't need split for lines
09:27:39 <donri> > lines "hi\nthere"
09:27:40 <lambdabot>   ["hi","there"]
09:30:00 <xunatai> ah screw it, i'll run through the 99 haskell problems thing, i can't think of anything to program on my own accord
09:33:18 <xunatai> it's frustrating being so fascinated by haskell, but having no ideas for actually what to program
09:33:45 <zrxy> Docs say that the minimal, complete definition of Enum entails toEnum and fromEnum, but that doesn't seem enough for the [start ..] notation. http://hpaste.org/78222
09:34:32 <zrxy> How do I make a custom bounded enum for which [start ..] works?
09:37:36 <ParahSailin> Ord?
09:39:32 <zrxy> ParahSailin: adding Eq and Ord to 'deriving' doesn't have an effect
09:39:45 <ParahSailin> Ix?
09:40:01 <merijn> zrxy: Define a Bounded and Enum class for your type? (Or derive it automatically)
09:40:23 <hpc> you only need Bounded for minBound/maxBound
09:40:32 <zrxy> merijn: It's not derived automatically because I'm presenting a minimal case of something else
09:40:42 <nirodha> Does anyone know a good place to hire a Haskell developer?
09:40:45 <merijn> hpc: Sure, but if he says it's bounded he might want to add that anyway
09:40:52 <ParahSailin> nirodha, here
09:40:56 <merijn> zrxy: Can you pastebin the type?
09:40:56 <hpc> :P
09:40:58 <nirodha> I'm allowed to just ask?
09:41:16 <hpc> nirodha: no; you have to ask to ask first
09:41:16 <zrxy> It should at least have Eq, though
09:41:19 <merijn> nirodha: You mean as in you wanting to hire people?
09:41:21 <zrxy> wish I could edit the paste
09:41:24 <hpc> and before you ask, you must ask if you can ask if you can ask
09:41:25 <ParahSailin> easier to ask forgiveness
09:41:25 <hpc> ...
09:41:28 <nirodha> Yes
09:41:37 <Prezioso> if I run ghc-pkg check it gives me a long list og packages that are broken. How can I solve this? cabal install each of them, ghc-pkg unregister each of the or?
09:41:48 <merijn> nirodha: Here is probably fine if you don't spam, also try haskellers.com and the haskell-cafe mailing list?
09:41:55 <nirodha> Alright.
09:42:11 <nirodha> Seeking: Haskell freelancer for paid position for December. Selenium based project. Please PM.
09:42:30 <zrxy> merijn: what type?
09:42:31 <donri> <zrxy> Docs say that the minimal, complete definition of Enum entails toEnum and fromEnum -- I don't see that in docs?
09:42:46 <merijn> nirodha: Might want to specify location and whether you want remote workers or not
09:42:46 <zrxy> donri: http://zvon.org/other/haskell/Outputprelude/Enum_c.html
09:43:26 <nirodha> Seeking: Haskell freelancer for paid position for December. Selenium based project. Remote worker. Must be in constant communication via phone, email, and IM or no deal. PM please.
09:43:29 <donri> those aren't official docs i don't think
09:43:31 <merijn> zrxy: Oh, I see what you mean. Hmm, that's a good question
09:43:37 <donri> http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Prelude.html#t:Enum
09:43:39 <merijn> > [True ..]
09:43:41 <lambdabot>   [True]
09:43:46 <merijn> > [False ..]
09:43:48 <lambdabot>   [False,True]
09:44:42 <merijn> zrxy: Check the Prelude source for the Enum instance of Bool
09:44:54 <merijn> zrxy: Looks like you want boundedEnumFrom
09:45:09 <merijn> zrxy: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Enum.html#Enum
09:47:35 <zrxy> merijn: Can I get [start ..] to work using pure Haskell?
09:49:28 <donri> zrxy: you want to define enumFrom, and boundedEnumFrom is a valid implementation
09:50:07 <sm> morning all
09:50:15 <sm> Prezioso: https://gist.github.com/1185421
09:50:31 <sm> clean em out and reinstall as needed
09:51:19 <zrxy> donri: yes I know -- my question was about pure Haskell, as in not a GHC extension
09:51:34 <donri> zrxy: yes, it is pure haskell
09:51:38 <donri> enumFrom = boundedEnumFrom
09:51:40 <donri> done
09:51:53 <donri> in your Enum instance
09:52:13 <donri> but note that deriving (Enum, Bounded) is not an extension, that's plain haskell 98
09:52:29 <Prezioso> sm thnx
09:53:24 <donri> zrxy: also you can pass, i think it is -ddump-deriv, to ghc and it will show you the code it generates for deriving (...)
09:55:28 <zrxy> donri: aren't you talking about boundedEnumFrom in GHC.Enum?
09:56:19 <donri> ah yea it's not exported by prelude
09:56:35 <zrxy> but my point was "Portability	non-portable (GHC extensions)"
09:58:21 <zrxy> Did Haskell the language really miss the [a ...] specification for bounded enum (not automatically derived)?
09:59:57 <zrxy> (two dots)
10:05:01 <bash> hi to all
10:12:54 <donri> zrxy: you implement enumFrom. that's it. what are you trying to say?
10:14:44 <donri> if you mean the default implementation in terms of fromEnum and toEnum is only total if your type is isomorphic to Int then yes :)
10:15:12 <latermuse> are there any good beginner articles about functional reactive programming in haskell?
10:16:13 <donri> latermuse: maybe this? http://jshaskell.blogspot.se/2012/11/breakout-improved-and-with-netwire.html
10:18:40 <latermuse> donri: Thanks. I've seen that. I was more looking for something which could be a primer on functional reactive programming theory
10:19:36 <bla_> data Tree a b = Leaf a | Node (Tree a b) b (Tree a b)  --foldT fuer einen Tree foldT :: (a -> b -> b) -> a -> (Tree a b) -> a foldT func ini (Leaf a) 			= func ini a a  foldT func ini (Node left a right) 	= func a (foldT func ini left) (foldT func ini right)
10:19:45 <bla_> whats wrong with this?
10:20:18 <Botje> put that on hpaste please
10:20:20 <parcs`> it's unreadable
10:22:33 <hpaste> “sir stean” pasted “fold over a tree” at http://hpaste.org/78225
10:22:47 <bla_> again^
10:24:04 <bla_> i want to write a fold for my tree
10:26:45 <bla_> http://hpaste.org/78225 : nobody an idea whats wrong?
10:27:14 <copumpkin> your func doesn't take enough arguments
10:27:21 <copumpkin> a -> b -> b -> b
10:27:34 <copumpkin> also, your leaf case is wrong
10:27:57 <copumpkin> foldT :: (a -> b -> b -> b) -> (a -> b) -> Tree a b -> b
10:28:05 <copumpkin> see if you can write that
10:28:12 <copumpkin> oh wait
10:28:15 <copumpkin> your tree is weird :P
10:28:28 <bla_> sry i'm a beginner
10:28:32 <bla_> i ll try
10:28:36 <copumpkin> are you sure that's the type you want for your tree?
10:28:51 <Ferdirand> you want to store different types of values at the nodes and the leaves, right ?
10:28:51 <bla_> not really
10:29:00 <bla_> jep
10:29:05 <copumpkin> okay, in that case
10:29:20 <copumpkin> foldT :: (b -> c -> c -> c) -> (a -> c) -> Tree a b -> c
10:29:25 <copumpkin> that's the natural fold type for your tree
10:30:16 <bla_> so i have to functions?
10:30:20 <bla_> two
10:30:25 <copumpkin> yes
10:30:36 <copumpkin> one describes what you do to your leaves, the other describes what you do to the nodes
10:31:02 <pcavs> Your tree looks a little funky too
10:32:30 <pcavs> data Tree a b = Leaf a | Tree b (Tree a b) (Tree a b)
10:32:48 <pcavs> that seems more like what you might want to store different values at Leaf nodes vs. Internal nodes.
10:32:57 <copumpkin> [13:28:33] <Ferdirand>	 you want to store different types of values at the nodes and the leaves, right ?
10:33:00 <copumpkin> [13:28:43] <bla_>	 jep
10:33:11 <pcavs> doh that's what you have.
10:33:15 <pcavs> sry ignore me
10:33:22 <Ferdirand> that's the same type with two parameters flipped
10:33:36 <pcavs> yeah, I missed what copumpkin just quoted
10:33:38 <pcavs> but then saw that
10:33:38 <zrxy> donri: yes enumFrom is the formal specification for [x ..]. But is there a formal specification of what entails a minimal, complete Enum? I was pretty surprised that toEnum and fromEnum isn't enough, especially considering that the top google hit says it's enough
10:33:39 <pcavs> and changed it
10:33:44 <pcavs> and then realized they were the same =(
10:33:50 <bla_> yes i want to store 2 different types
10:33:52 <copumpkin> what'd be weirder is if you flipped `a` and `b` when recursing :)
10:34:07 <copumpkin> it makes for a much more interesting structure, especially if you flip one side and not the other
10:35:01 <copumpkin> data Tree a b = Leaf a | Tree b (Tree a b) (Tree b a)
10:35:02 <copumpkin> for example
10:35:14 <copumpkin> not sure what you'd use that for, but it'd be amusing :)
10:35:30 <zrxy> donri: My feeling is that the other enum functions should not be generated if there's a potential for them to be wrong
10:35:56 <donri> i'm inclined to agree, but there's lots of examples of that in haskell libs
10:36:01 <pcavs> copumpkin: seems like all that would do is do some sort of length parity encoding of the right sub tree
10:36:15 <copumpkin> pcavs: sure, but what does the fold look like?
10:36:18 <donri> e.g. Alternative has "optional" methods whose defaults are bottoms
10:36:32 <pcavs> not sure
10:36:38 <pcavs> sure seems interesting though =)
10:36:40 <copumpkin> pcavs: it means that depending on your right depth, your leaf type and node type might be different
10:36:46 <pcavs> yep
10:36:49 <copumpkin> I love weird non-regular types
10:36:55 <pcavs> haha
10:41:23 <bla_> hm, i am stucked
10:41:24 <bla_> http://hpaste.org/78228
10:42:00 <copumpkin> you threw an extra c in there that is unnecessary
10:42:08 <copumpkin> and you aren't calling yourself recursively correctly
10:42:15 <bla_> for the initial
10:42:23 <copumpkin> you need to think about this a bit harder :)
10:42:28 <copumpkin> funcLeaf ini a
10:42:30 <copumpkin> you have that
10:42:35 <copumpkin> what is the type of funcLeaf?
10:42:58 <copumpkin> there is no initial
10:43:01 <bla_> c
10:43:08 <copumpkin> no,
10:43:12 <copumpkin> funcLeaf has type (a -> b)
10:43:14 <copumpkin> I mean
10:43:15 <copumpkin> a -> c
10:43:18 <copumpkin> it's written right above
10:43:23 <bla_> ok
10:43:24 <copumpkin> so how many arguments does it take
10:43:36 <bla_> one argument
10:43:41 <copumpkin> why do you pass it two?
10:43:49 <bla_> hm :)
10:43:51 <copumpkin> funcLeaf ini a
10:44:02 <bla_> for sure
10:44:06 <bla_> thx
10:44:09 <copumpkin> now you have a similar problem with your recursive calls in the Node case
10:44:11 <bla_> funcLeaf a so
10:44:15 <copumpkin> yeah
10:44:16 <copumpkin> foldT funcNode ini left
10:44:32 <copumpkin> foldT takes another argument
10:44:38 <copumpkin> (the funcLeaf)
10:44:52 <copumpkin> if you put that in, it should work. But you'll notice that you never use ini :)
10:46:21 <bla_> ok thx, i give it a try
10:52:13 <zrxy> donri: I looked at the 1998 and 2010 Haskell reports, and neither mention that missing Enum functions should be generated. Is that itself a GHC extension?
10:53:00 <donri> no idea :)
10:53:33 <Igloo> What do you mean by "generated"? http://www.haskell.org/onlinereport/haskell2010/haskellch9.html shows a number of default methods
10:56:07 <zrxy> Igloo: I mean that "Minimal complete definition: to Enum, fromEnum" in that link is wrong.
10:57:25 <Igloo> zrxy: Why do you say that?
10:58:09 <geekosaur> zrxy, I am looking at the h2010 section on the prelude and it shows the minimal complete definition and the default implementations for the others
11:00:03 <zrxy> geekosaur: good find, I missed that. Those functions are wrong for a bounded enum.
11:00:14 <zrxy> http://hpaste.org/78222
11:01:28 <geekosaur> correct, there's no way to take Bounded into account automatically so Bounded instances must provide their own.  This is why they're defaults inside the class definition and not top level functions
11:02:10 <edwardk> > rezip $ zipper ("hello","world") & fromWithin (_1.traverse) & focus .~ 'j' & farthest Lens.right & focus .~ 'y' & up & focus.both.elements even %~ toUpper
11:02:13 <zrxy> I think any reasonable definition of "minimal, complete" would imply "correct".
11:02:13 <lambdabot>   ("JeLlY","WoRlD")
11:02:17 <edwardk> woot. new lens.
11:02:21 * edwardk hugs Cale
11:03:03 <geekosaur> zrxy, no, "minimal, complete" does not guarantee correctness, merely well-formed-ness.  Semantics largely lie outside what the language can either promise or enforce
11:03:10 <bla_> ok my foldTree compiles, but i dont how i can test it. I have two functions and i dont know what i need to write in the first one
11:03:10 <bla_> foldT :: (b -> c -> c -> c) -> (a -> c) -> Tree a b -> c
11:03:55 <copumpkin> bla_: depends what you want to do with it :P
11:04:10 <mapf> bla_: why just not make instance of Foldable?
11:04:14 <copumpkin> bla_: typical examples might be to add up all entries in a Tree Int Int
11:04:20 <bla_> for exemple just sum integers
11:04:22 <bla_> jep
11:04:48 <copumpkin> or you might have a Tree Int Bool where the bool at the nodes tells you whether to count the nodes below
11:04:54 <neworder> For this function I was discussing just now, let pow = 1:map (2*) pow
11:05:15 <geekosaur> zrxy: also note that even for what rules exist for Enum, there are standard instances that violate some of them.  (Double...)
11:05:22 <neworder> I feel like it's intuitive to think in this way
11:05:33 <copumpkin> bla_: well, say you want to add up all the Ints, what are `a`, `b`, and `c` then?
11:05:37 <geekosaur> you can try to be pedantic but this lands you up a creek pretty quickly
11:05:38 <zrxy> geekosaur: I think that's a bad idea. If something cannot be specified correctly, don't specify it. Haskell shouldn't be in the business of giving bogus default functions.
11:06:33 <bla_> they are all ints arent they
11:06:35 <geekosaur> the Haskell committe disagreed; argue with them about how Enum must be exterminated.  Good luck.  (note the anti-Double crusaders already tried...)
11:06:47 <neworder> map (*2) pow will produce the list 1:2:(map (*2) (map (*2) pow)
11:07:15 <neworder> I keep thinking the pow in here includes 1 and 2
11:07:17 <geekosaur> also note that the language standard's job is about balancing absolute pedantry against usability
11:08:01 <neworder> because it says map the function (*2) to every element in the list
11:08:12 <neworder> Does anyone know how I'm thinking about this?
11:08:14 <geekosaur> you can define a pedantic Haskell variant but it'll about as usable as Agda (where the only point of programs is getting them to compile at all)
11:08:24 <neworder> Any help? =)
11:08:29 <zrxy> geekosaur: correctness is quite far from "absolute pedantry"
11:08:42 <geekosaur> not at all
11:08:50 <geekosaur> you're doing nothing *but* pedantry here
11:09:02 <geekosaur> you are in articular not considering in any way usability
11:11:05 <edwardk> zrxy: Enum isn't going to change. It'd be nice to have a real Enumerable class that worked and was more rigorous. Copumpkin wrote one, but Enum in the core library will forever be this kinda hacked up hodgepodge to support Double. The battle has been fought and lost.
11:11:36 <neworder> watermind: The expansion you gave just now was helpful
11:11:43 <zrxy> geekosaur: I've noticed that you get strangely personal quite quickly.
11:12:25 <neworder> But I keep thinking that this part of the function "map (*2) pow" multiplies every element in the list by 2 instead of just multiplying the last element by 2
11:13:03 <neworder> And I think its quite intuitive
11:13:05 <neworder> haha
11:13:09 <neworder> Is it not?
11:15:43 <geekosaur> there is something personal about observing pedanticism?
11:15:46 <Boreeas> I have a function how do I divide to Num instances x and y? When I use "x / y", I get "    Could not deduce (Fractional a) arising from a use of `/'"
11:15:50 <geekosaur> as you wish then
11:16:07 <mapf> :t div
11:16:09 <lambdabot> Integral a => a -> a -> a
11:16:45 <geekosaur> btw what is your preferred definition for Enum?  or shuld it not exist at all since there's no way to automatically make it obey Bounded?
11:22:41 <shapr> geekosaur: be nice
11:22:49 <shapr> @tell zrxy be nice
11:22:50 <lambdabot> Consider it noted.
11:23:20 <shapr> geekosaur: Yes, it is personal to observe pedanticism.
11:23:32 <tufflax> Hm, why doesn't (foldl (\acc x -> acc ++ [x + 1]) [] [1..]) !! 3 work. I thought Haskell was lazy :p
11:24:31 <mapf> > foldl (\acc x -> acc ++ [x + 1]) [] [1..]) !! 3
11:24:33 <lambdabot>   <hint>:1:42: parse error on input `)'
11:24:58 <mapf> > foldl ((\acc x -> acc ++ [x + 1]) [] [1..]) !! 3
11:25:00 <lambdabot>   Couldn't match expected type `[a0]'
11:25:00 <lambdabot>              with actual type `a1 -> [b...
11:25:12 <tufflax> > (foldl (\acc x -> acc ++ [x + 1]) [] [1..]) !! 3
11:25:21 <lambdabot>   mueval: ExitFailure 1
11:25:21 <lambdabot>  mueval: Prelude.undefined
11:25:49 <lispy> tufflax: it is lazy, but computations that don't produce intermediate results can be a problem
11:26:35 <lispy> > reverse [1..] -- how can we know what the first element of the result should be?
11:26:37 <raek> hrm, when was 'void' added to Control.Monad?
11:26:39 <lambdabot>   mueval-core: Time limit exceeded
11:26:52 <lispy> raek: around the time the warn-unused-do-bind thingy was added
11:26:54 <tufflax> lispy, oh yeah, If it didn't produce a list, there is not way to know... yeah
11:26:56 <tufflax> I get it
11:27:12 <mapf> > (foldr (\x acc -> acc ++ [x + 1]) [] [1..]) !! 3
11:27:12 <parcs`> tufflax: foldl doesn't return anything until it has traversed the entire list
11:27:12 <lambdabot>   mueval-core: Time limit exceeded
11:28:09 <lispy> ?src reverse
11:28:09 <lambdabot> reverse = foldl (flip (:)) []
11:28:20 <lispy> tufflax: just to tie my reverse example to your foldl ^^
11:28:20 <mapf> i can't see why foldr doesnt work..
11:28:29 <foeniks> hey
11:28:42 <parcs`> > (foldr (\x acc -> (x+1):acc) [] [1..]) !! 3 -- mapf
11:28:44 <lambdabot>   5
11:28:47 <raek> I guess it's time to upgrade some packages... (or my OS, really)
11:29:16 <mapf> parcs`: ah, yes, i forgot to flip
11:29:19 <foeniks> when I load I .hs file in ghci
11:29:27 <foeniks> can I somewow bind variables to the REPL?
11:29:34 <lispy> foeniks: let
11:29:58 <lispy> in ghci you can say, > let x = 5
11:30:02 <lispy> and then use it later
11:30:09 <foeniks> I want to do it in the hs file
11:30:15 <Sintendo> I've got a [(n, Maybe Int)], is there a simple way to filter out the tuples that have Nothing as their second element and create a [(n, Int)] with the remaining elements?
11:30:19 <foeniks> so I do not have to build up complex data structures manually
11:30:26 <JoeyA> "<raek> hrm, when was 'void' added to Control.Monad?" Since base 4.3 (GHC 7.0), looking at the Hackage docs.
11:30:42 <foeniks> let x = 4  in the .hs file make ghci complain about indentation
11:30:46 <ion> sintendo: [(n, i) | (n, Just i) <- xs]
11:31:13 <Sintendo> thanks, gonna try that
11:31:35 <typoclass> JoeyA, raek: yes, void is only 1-2 years old if i remember correctly
11:31:47 <TBJoe> hey guys if i want to get into the theory behind haskell a bit ... is lambda calculus a good place to start with? just found 6 hours of university lectures for that topic
11:31:55 <lispy> foeniks: you could make a separate file, ghci.hs that you load insead of your module and that file imports your module and provides examples (provide them as normal top level definitions)
11:31:57 <raek> want to use function -> need to upgrade ghc -> need to upgrade OS -> need to upgrade computer habits
11:32:03 <raek> :(
11:32:08 <lispy> TBJoe: yes, good place to start
11:32:30 <lispy> raek: yay, upgrade sunday!
11:32:35 <raek> or is there a convenient way to build the latest haskell platform for an ancient ubuntu version?
11:33:02 <lispy> raek: if your kernel is new enough I bet you could just build stuff yourself.
11:33:06 <byorgey> raek: I mean, you can move to managing the Haskell install yourself
11:33:11 <lispy> raek: and the kernel doesn't even have to be that new
11:33:19 <JoeyA> It was in Foreign.Marshal.Error before that, but with a less general type.
11:33:21 <byorgey> i.e. uninstall the ubuntu packages and just install GHC + the HP manually
11:33:25 <JoeyA> :t Foreign.Marshal.Error.void
11:33:27 <lambdabot> IO a -> IO ()
11:33:57 <raek> ok, thanks all!
11:34:05 <typoclass> JoeyA: ... and it was in about 37 hackage libraries, i bet :-)
11:34:27 <JoeyA> lol
11:34:30 <foeniks> lispy, If I have a file that only containts "let x = 3" and I load it in ghci, it gives me the error message "test.hs:2:0: parse error (possibly incorrect indentation)"
11:34:51 <Sintendo> ion: thanks, that's much cleaner
11:34:58 <Sintendo> i was doing this: filter (\a -> a >= 0) (map (\(a, b) -> (a, maybe -1 id b)) xs)
11:35:29 <lispy> foeniks: right, that's not what I meant. You can type that into ghci and it works or you can load a normal haskell module that imports your modules and defines your examples as normal haskell definitions
11:35:47 <JoeyA> Write a package with 'void', and you have it for a day.  Bother Simon with a patch, and you have it for a lifetime.
11:36:02 <foeniks> I.e. are you talking about a different statement for binding the variables?
11:36:46 <lispy> foeniks: yes. You'd have a top level definition like "ex1 = 4"
11:37:12 <lispy> foeniks: and then when you load the module in ghci you can use ex1
11:37:13 <typoclass> JoeyA: istr that gwern said he lobbied for void being included in Control.Monad, and one of his arguments was that there were n implementations of it in various places, hence it must be useful
11:37:14 <foeniks> ah
11:37:19 <byorgey> no "let" is needed for a top-level definition in a .hs file
11:37:22 <byorgey> the ghci prompt is differet
11:37:25 <foeniks> I did not know that those assignments were possible
11:37:26 <JoeyA> typoclass: Ah, good point.
11:37:35 <JoeyA> So you have to do both, then.
11:37:54 <lispy> foeniks: the reason I recommend putting this in a separate module is that you probably don't want to have those names around in your actual code, just in your ghci playground
11:39:47 <art2art> join #emacs
11:40:14 <mapf> i did
11:40:40 <foeniks> lispy, sounds reasonable if my codebase grows more ;)
11:41:14 <art2art> hi all!
11:41:24 <typoclass> art2art: hello
11:52:27 <foeniks> When evalutating this in ghci I get a segmentation fault: Prelude> -1*log(10)
11:52:41 <atriq> > log 10
11:52:44 <lambdabot>   2.302585092994046
11:52:49 <atriq> > -1 * log 10
11:52:51 <lambdabot>   -2.302585092994046
11:52:53 <foeniks> log 10 works
11:53:05 <atriq> Doesn't segfault for me
11:53:10 <atriq> Which version of GHC do you have?
11:53:20 <typoclass> foeniks: some sort of gmp snafu?
11:53:21 <foeniks> 6.10.4
11:53:29 <atriq> Ooh, that's old
11:53:47 <foeniks> it seems to be related with multiplying by a negative value
11:54:15 <atriq> I'd suggest you upgrade GHC
11:54:23 <rwbarton> are you on Mac OS?
11:54:33 <foeniks> yes
11:55:38 <foeniks> thing is I am behind a limited connection, so I will not be able to download anything til january :(
11:55:43 <foeniks> googling alone is too bad
12:00:23 <bgamari> GHC's profiler maybe be flexible, but it isn't terribly easy to compare profiles
12:00:34 <bgamari> before: http://heap.ezyang.com/view/5dc50170ef4bd8dae3bfd18f16131a1edbaf68d3#form
12:00:42 <bgamari> after: http://heap.ezyang.com/view/29f050a61de54b6549f07ad5644d628ff0cbb67f#form
12:01:00 <bgamari> what are the dominant differences between those two profiles?
12:02:38 <bla_> now i need to map for my tree : data Tree a b = Leaf a | Node (Tree a b) b (Tree a b).
12:02:51 <bla_> mapT :: (b -> d) -> (a -> c)-> Tree a b -> Tree c d
12:02:55 <bla_> is the type ok?
12:03:10 <Saizan> it seems the after one is showing higher peaks but less long-term memory use
12:04:02 <Saizan> bla_: seems fine
12:04:15 <bla_> ok thx
12:05:28 <bgamari> shachaf, You mentioned yesterday that newtypes may result in RULES not firing
12:05:47 <bgamari> shachaf, How might I debug such a thing?
12:05:51 <foeniks> hmm, that bug seems to be display related
12:05:59 <lispy> bgamari: use the "Overlayed Area graph"
12:06:23 <lispy> bgamari: there is a flag that tells ghc to say something when rules fire.
12:06:49 <lispy> bgamari: http://www.haskell.org/ghc/docs/7.6.1/html/users_guide/rewrite-rules.html
12:06:57 <lispy> -ddump-simpl-stats
12:07:38 <bgamari> lispy, I think the change is an increase allocations from getMesh
12:08:37 <lispy> bgamari: tesselateLoop/getMesh hasn't changed
12:08:53 <bgamari> lispy, but I can't imagine you could regression in a program larger than 10 lines by looking through -ddump-simpl-stats
12:09:23 <bgamari> lispy, getMesh.segsV, midsX, midsY, objV seem to increase, no?
12:09:24 <lispy> bgamari: overall, the after one looks like a pessimization
12:10:04 <lispy> it takes more memory and more time
12:10:32 <bgamari> lispy, This is the result of a refactor wrapping some values in newtypes
12:12:27 <lispy> bgamari: I would guess from the shape of things that some deforestation is missing now
12:12:53 <bgamari> lispy, yes, the two plots I showed you are just looking at [] allocations
12:12:54 <lispy> it's building more and then collecting it at each spike
12:13:14 <bgamari> lispy, And getMesh.* are mostly lists
12:13:18 <lispy> ah
12:13:54 * lispy leaves
12:14:05 <bgamari> alright, thanks!
12:14:14 <bgamari> Any pointers before you go?
12:14:25 <ion> null
12:14:34 * bgamari hasn't the slightest idea how to identify why deforestation would fail due to a newtype
12:14:44 <xunatai> 0xF83AE44D
12:14:52 <bgamari> it seems like it should be gone right after typechecking
12:14:52 <bgamari> heh
12:15:07 <bgamari> I thought rules fired after this point
12:16:04 <startling> bgamari, newtypes are tree-sitting hippies
12:17:41 <parcs`> bgamari: you have to create custom rules for newtype wrappers
12:19:32 <bgamari> parcs`, This results in an exponential explosion of rules, no?
12:20:18 <parcs`> just linear, i think
12:20:46 <bgamari> parcs`, I suppose that's true
12:20:54 <parcs`> bgamari: what types are the newtypes wrapping?
12:20:57 <bgamari> tuples
12:21:11 <parcs`> polymorphic tuples?
12:21:40 <bgamari> parcs`, Nope
12:21:55 <bgamari> I'm wrapping (Double,Double) in newtype Point a = P a
12:24:51 <bgamari> getMesh is here, for those following from home https://github.com/bgamari/ImplicitCAD/blob/master/Graphics/Implicit/Export/Render.hs
12:25:02 <bgamari> it doesn't help that it's nearly impenetrable to begin with
12:28:19 <bgamari> it seems like [] is pretty questionable choice of data structure here regardless
12:28:24 <parcs`> bgamari: try comparing outputs of -ddump-rule-firings to get a better idea of what may be wrong
12:31:35 <bgamari> parcs`, that's what I'm doing at the moment; there are definite changes but it's not clear what actually is happening
12:31:59 <hpaste> “Ben Gamari” pasted “dump-simpl-post” at http://hpaste.org/78232
12:32:15 <hpaste> “Ben Gamari” pasted “dump-simpl-pre” at http://hpaste.org/78233
12:32:43 <bgamari> if anything a lot more rules are firing in Render
12:32:54 <bgamari> after the change
12:33:08 <bgamari> but that is expected as there is now more to optimize away
12:33:35 <twmb> Why do I need parentheses before reverse and after (<100) in the following:  reverse . sort . takeWhile (<100) [1..]
12:34:46 <parcs`> bgamari: -ddump-rule-firings should just list the particular rules that fire
12:34:48 <twmb> or a dollar after the (<100)
12:34:53 <fryguybob> twmb: Function application binds tighest
12:35:07 <rwbarton> where's that online parser that shows you the fully parenthesized form?
12:35:16 <twmb> fryguybob: what do you mean by "binds tightest"
12:35:22 <fryguybob> twmb: You are wanting to apply [1..] to the whole function you are building, not just takeWhile.
12:35:33 <ion> reverse . sort . takeWhile (<100) is a function. You can apply that to [1..]. takeWhile (<100> [1..] is not a function. You can not apply (.) to it.
12:36:17 <Shapeshifter> How do I get from [[1,2],[3,4],[5,6]] to [1,2] <*> [3,4] <*> [5,6]? Is there some way to map <*> over a list?
12:36:55 <twmb> but why does Haskell look at the [1..] when it sees the function application ?
12:37:01 <twmb> if that makes sense...
12:37:25 <rwbarton> twmb: if you write "a . b c" it means "a . (b c)" not "(a . b) c"
12:37:36 <ion> shapeshifter: That’s a type error.
12:37:37 <rwbarton> because function application binds tighter than any binary operator
12:37:54 <bgamari> parcs`, So claims the documentation as well. Sadly it doesn't seem to dump anything but "[10 of 10] Compiling Graphics.Implicit.Export.Render ( Graphics/Implicit/Export/Render.hs, Graphics/Implicit/Export/Render.o )"
12:38:17 <twmb> also, I've been reading that a few times in this LYAH - what is this binary operator?  I realize it in context every time I read it but forget it when I'm a page away
12:38:26 <rwbarton> which, .?
12:39:44 <osa1> hackage says that my package fails to build at ghc-7.6 but it doesn't say anything about 7.4, does that mean my package works in 7.4 ?
12:40:05 <rwbarton> it just means the current version that it tries to build things with is 7.6
12:40:07 <rwbarton> afaik
12:40:25 <parcs`> bgamari: hmm, strange. wait, are you working on the affine-space branch on github?
12:40:42 <bgamari> ahh, damn, wasn't compiling with -O
12:40:46 <bgamari> parcs`, yes
12:41:02 <typoclass> twmb: which operator do you mean?
12:41:17 <bgamari> that applies to the previous hpastes as well
12:41:24 <bgamari> things look a bit more interesting now
12:41:33 <twmb> " because function application binds tighter than any binary operator" -- ? What does it mean in this context?
12:42:04 <rwbarton> you know how a + b * c means a + (b * c) and not (a + b) * c, right
12:42:44 <rwbarton> then we say "* binds tighter than +"
12:43:22 <twmb> I see
12:43:42 <rwbarton> here function application (which isn't even an operator, you just write the function and then the argument) is playing the role of * and any other operator the role of +
12:43:52 <bgamari> parcs`, you may also find https://github.com/colah/ImplicitCAD/pull/75 interesting
12:44:32 <bgamari> parcs`, Unfortunately, there are no interesting differences in the rules fired
12:45:31 <bgamari> parcs`, A few rules from vector-space fired after the change which didn't fire before (which isn't surprising since vector-space) wasn't used before
12:45:52 <bgamari> parcs`, Otherwise it's identical
12:46:21 <bgamari> fold, map, and mapList all fire the same number of times, however
12:46:44 <bgamari> s/however//
12:46:59 <bgamari> A surprisingly low number of times at that
12:50:23 <hpaste> niteria pasted “alex build error” at http://hpaste.org/78235
12:51:12 <niteria> can anyone help with this ^ ?
12:51:47 <niteria> am I running ghc that is too recent (7.4.1) ?
12:51:48 <adimit> wait a minute… there *isn't* an iteratee that can write to a file in the iteratee package? Am I reading the docs correctly?
12:54:51 <bgamari> parcs`, I'm beginning to think this code may just want to be rewritten anyways
12:55:11 <bgamari> parcs`, Would you agree that [] is a slightly odd choice here?
13:01:13 <tomeo_> In a list comprehension, can I see what I have already put in the list? [x | x <- otherlist], can I write a predicate based upon what I have already put in x?
13:02:28 <Yuu-chan> tomeo_: can you write a more detailed description?
13:03:11 <ParahSailin> tomeo_, probably not?
13:03:19 <tomeo_> Yuu-chan: say that I am getting strings from otherlist, but I only want to add the string if they are longer than any other string I have already added
13:04:04 <tomeo_> Its just that I have started out trying to solve problems with list comprehensions and getting to where I need to know what I have in the list already and then had to solve it some other way. Was just wondering if it can be done
13:04:11 <Yuu-chan> tomeo_: well, no. List comprehensions are like map + filter. But you can rewrite via the fold
13:04:29 <tomeo_> Yuu-chan: oh okay
13:06:08 <ParahSailin> you could write it as a custom monad that could use the comprehension sugar
13:09:02 <lispy> bgamari: Do you know about unboxing?
13:09:05 <johnw> tomeo_: see also scanl, that may express what you're looking for
13:09:07 <Yuu-chan> tomeo_: the dumbest way would be something like foldl' (\l x -> if all (< length x) (map length l) then (x:l) else l) []
13:09:31 <tomeo_> johnw: isnt scanl just a fold with intermediate values?
13:10:12 <lispy> bgamari: when I was reading the scrollback I see that you use (Double,Double), but sadly that type is almost always wrong if you want fast numeric code
13:10:27 <bgamari> lispy, Yes, I went through this a few days ago as well
13:10:45 <bgamari> lispy, I was thinking that I should use an unpacked, strict datatype
13:10:55 <bgamari> lispy, but it would be a massive undertaking in this codebase
13:11:52 * hackagebot liblastfm 0.0.3.7 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.3.7 (MatveyAksenov)
13:12:07 <bgamari> lispy, In principle, the boxing overhead shouldn't be affecting me any more now than it did previously, correct?
13:12:41 <rwbarton> tomeo_, yes
13:13:25 <lispy> bgamari: RULEs are type sensitive. So you will need to recover the rules that were firing before to get back to the performance you had previously
13:13:44 <mdszy> how do you work with haskell-pcre's MatchArray type?
13:13:51 <mdszy> I can't figure out how to exract the values from it
13:13:52 <bgamari> lispy, I really can't tell which I'm currently lacking, unfortunately
13:14:02 <mdszy> it's apparently a type alias for  Array Int (MatchOffset, MatchLength)
13:14:18 <bgamari> lispy, I enumerated the rules that were/are firing above
13:14:23 <mdszy> MatchOffset and MatchLength are just Ints
13:14:28 <bgamari> lispy, As far as I can tell there are no significant differences
13:14:44 <bgamari> lispy, certainly nothing that would lead to lacking deforestation
13:14:45 <lispy> bgamari: bgamari no luck with -ddump-rule-firings ?
13:15:10 <bgamari> lispy, No luck with -ddump-simpl-stats
13:15:40 <hpaste> “Ben Gamari” pasted “Simpl stats (After)” at http://hpaste.org/78238
13:15:50 <lispy> I think I'd bite the bullet and see what happens with strict pairs.
13:15:52 <hpaste> “Ben Gamari” pasted “Simpl stats (Before)” at http://hpaste.org/78239
13:16:20 <bgamari> lispy, I suspect it'll take another weekend unfortunately
13:17:02 <bgamari> lispy, I just blew the last day ripping out the existing handling of vectors
13:17:29 <bgamari> lispy, I suspect changed datatypes outright is an even larger task
13:17:48 <lispy> bgamari: can make the change just in this module first?
13:18:24 <bgamari> lispy, Would you use [] like this? https://github.com/bgamari/ImplicitCAD/blob/master/Graphics/Implicit/Export/Render.hs#L105
13:18:41 <bgamari> lispy, It looks a bit funny to me, but maybe I'm the strange one
13:18:47 <bgamari> lispy, I suppose I can try
13:18:56 <lispy> data a :*: b = {-# UNPACK #-} !a :*: {-# UNPACK #-} !b; s2p :: a :*: b -> (a,b); p2s :: (a,b) -> a :*: b; etc
13:19:44 <lispy> bgamari: I would not do that. I'm not sure how to parse it
13:20:03 <bgamari> lispy, alright, I'm glad I'm not the only one
13:20:09 <rwbarton> yikes
13:20:16 <bgamari> yeah, it took me quite a while to decipher that
13:20:27 <rwbarton> that's very creative
13:20:35 <lispy> bgamari: I would try to find evidence for how to make this module faster (and just the module in question). Once you've figured it out, then try to push to convert more of the code to that style
13:20:58 <rwbarton> segsZ is even worse
13:21:03 <`Jake`> Can I span a list comprehension over multiple lines?
13:21:12 <rwbarton> what is that, a zip10
13:21:14 <rwbarton> `Jake`: yes
13:21:18 <rwbarton> see: https://github.com/bgamari/ImplicitCAD/blob/master/Graphics/Implicit/Export/Render.hs#L105
13:21:21 <bgamari> `Jake`, Look in the above snippet for evidence
13:21:28 <`Jake`> thanks
13:21:35 <bgamari> there's plenty of multiline list comprehensions
13:21:40 <lispy> bgamari: I don't know if hmatrix is compatible license-wise, but it would be leaps and bounds better than []
13:21:58 <bgamari> lispy, I'm thinking repa is suitable here
13:22:16 <bgamari> he wants parallelism anyways
13:22:21 <bgamari> which I suspect is why he's using []
13:22:23 * lispy needs to learn repa at some point
13:22:35 <lispy> There is something about repa that always scares me away, can't quite put my finger on it
13:27:58 <watermind> is there an emacs mode that does case splitting agda style?
13:28:11 <watermind> we don't have holes yet, but for function arguments for instance
13:28:30 <watermind> given   f : signature;  f =
13:30:43 <lispy> watermind: I thought we did have holes now
13:30:57 <geekosaur> I thought that was only in HEAD?
13:30:58 <startling> lispy, it's in GHC HEAD
13:31:00 <startling> yeah
13:31:21 <geekosaur> and not final even there, I think
13:31:26 <lispy> anyway, to answer your question, I thought there was something. Let me check
13:35:12 <lispy> watermind: this is what I was thinking of, but I don't think it has the feature you were asking about: http://www.mew.org/~kazu/proj/ghc-mod/en/
13:35:39 <lispy> watermind: case splitting would be a nice feature though. It would probably be enough to make me switch back to emacs
13:38:28 <twmb> I just read this:
13:38:28 <twmb>  It's usually better to use folds for this standard list recursion pattern instead of explicitly writing the recursion because they're easier to read and identify. Everyone knows it's a fold when they see the foldr call, but it takes some more thinking to read explicit recursion.
13:38:46 <mdszy> is it possible to make an array into a list?
13:38:53 <twmb> However, from what I understand, folds always iterate over the entire list, whereas with explicit recursion you can stop when you find the first true element
13:38:59 <twmb> isn't explicit recursion faster?
13:39:47 <jesyspa> Doesn't lazy evaluation mean that if the result is not used, it won't be calculated?
13:39:59 <ibid> you can stop a foldr just like recursion
13:40:28 <mdszy> nevermind, I got it now
13:41:18 <ibid> jesyspa: with caveats, yes
13:41:18 <gds> Hm - ghc-mod failing to build.
13:42:05 <gds> hlint-1.8.35 failed during the building phase. The exception was: ExitFailure 1
13:42:13 <twmb> how can haskell know that the result of the accumulator will not be used?  wouldn't it have to calculate the entire fold?
13:42:26 <lispy> twmb: one of the points of iteratees is that you can stop early (iteratees are folds over streams)
13:42:45 <rwbarton> I don't like to call the thing in foldr an "accumulator"
13:43:00 <lispy> gds: scroll up. When cabal hits a failure it tries to keep going for as long as it can
13:43:17 <lispy> gds: or repeat the command and the failure should happens sooner
13:43:17 <twmb> I'm only on modules of LYAH :/
13:43:35 <gds> lispy: Ah - thanks...
13:43:38 <d-snp> hi guys, I read "anatomy of a thunk leak" and was wondering couldn't GHC do a garbage collection like process on thunks?
13:43:38 <gds> src/Idea.hs:8:8:
13:43:38 <gds>     Could not find module `Language.Haskell.HsColour.Colourise'
13:43:38 <gds>     There are files missing in the `hscolour-1.20.3' package,
13:43:38 <gds>     try running 'ghc-pkg check'.
13:43:39 <scooty-puff> what is the fixity of ..?
13:43:44 <gds>  
13:43:50 <scooty-puff> ".."
13:43:52 <sipa> :i (..)
13:43:57 <sipa> :(
13:44:02 <rwbarton> it doesn't have one really
13:44:12 <scooty-puff> k
13:44:28 <rwbarton> it is just part of the syntax [a..b] (and [a,b..c] and so on)
13:44:29 <scooty-puff> because of all the delimiters? [, ]?
13:44:32 <scooty-puff> k
13:44:39 <ijp> twmb: one simple, if contrived example is foldr (\a b -> a ) 0 [1..]
13:44:40 <d-snp> like, could it detect a function is creating an excess of thunks that are not going to be evaluated in time, and make it strict before it gets out of hand?
13:44:41 <lispy> gds: oh, I haven't seen that before. Run the command they recommend and try again? If that doesn't help, do a --reinstall of hscolour?
13:45:25 <gds> lispy: I'll have a go. FWIW - I did mv .cabal .cabal_backup before starting, 'cause I was getting other weird errors previously...
13:45:41 <rwbarton> gds, you should have done mv .ghc .ghc_backup instead
13:46:02 <gds> Ah :)
13:46:04 <gds> Thanks
13:46:09 <lispy> the price we pay for not having sandboxes...
13:47:58 <twmb> ijp: how the heck does it do that...
13:48:41 <ijp> twmb: well, substituting for the definition of foldr we get (\a b -> a) 1 (foldr (\a b -> a) 0 [2..])
13:49:25 <ijp> and from there, it should be clear that to evaluate the function we don't need the value of that fold over the rest of the infinite list
13:49:27 <niteria> what's the best way to store line numbers in AST?
13:50:21 <twmb> That's pretty cool...I hadn't seen the definition before
13:50:35 <niteria> my aim is to have a line number when semantic analysis fails
13:50:48 <twmb> foldr suffers from stack overflow possibilities, right?
13:51:55 <Eduard_Munteanu> twmb: no, not generally
13:52:50 <Eduard_Munteanu> I'd argue foldr is generally nicer, being productive.
13:52:54 <niteria> hm maybe instead of storing them I can have AST node -> line map
13:53:30 <Eduard_Munteanu> niteria: why not store them within the AST?
13:54:25 <sclv> niteria: look at how haskell-src-exts does it
13:54:38 <sclv> you can have an ast parametric over some "annotation"
13:54:42 <sclv> such as source position
13:57:07 <gatlin_> may-day! I'm writing a literate haskell file for the first time and, well, this has a parse error on 'import': http://hpaste.org/78244
13:57:21 <gatlin_> these lines work as is in ghci, live
13:57:50 <rwbarton> have you written non-literate haskell files?
13:58:00 <rwbarton> you can't just stick an expression at the top level
13:58:15 <gatlin_> this is intended for ghci
13:59:26 <rwbarton> I don't think there is such a thing as "literate ghci input"
14:00:12 <gatlin_> I think you're correct, and I think I'm an idiot. Combination of bad memory and wanting to be lazy enough to copy my results from ghci
14:00:56 <niteria> sclv: nice, that's what I wanted
14:06:08 <monochrom> in a file, the import line goes first
14:06:44 <stean> how can i implement take for list only with fold?
14:07:20 <gatlin_> monochrom: I was under this mistaken impression that somehow magically ghci would just execute the statements
14:07:21 <monochrom> in a file also, standalone expressions don't work. only definitions work, i.e., you need =
14:08:30 <gatlin_> I actually write haskell all the time. I just decided randomly that, oh, ghci must do something totally and utterly different with literate files
14:08:37 <monochrom> yeah, too bad haskell files don't work like perl files, shell script files, python files...
14:08:57 <stean> how can i implement take for list only with fold?
14:09:00 <monochrom> but here is good news for haskell files that trumps all other language files:
14:09:03 <gatlin_> no, it does: those languages wrap everything in a giant IO monad
14:10:01 <monochrom> you can write at line 1: main = print Hello  -- where Hello comes from a user-defined type, hold on
14:10:44 <monochrom> then, 100 lines later, you give the Show instance for that to work: instance Show Hi where show Hello = "hello"
14:11:07 <monochrom> then, 100 more lines later, your user-defined type: data Hi = Hello
14:11:16 <monochrom> shell scripts files cannot take that!
14:11:22 <`nand`> of course, you'd do it the other way round in practice ;)
14:12:26 <monochrom> the only restriction is that, if you want "f [] = ..." and "f (x:xs) = ...", they must stick together, can't pull the above random separation trick
14:15:06 <monochrom> it actually sometimes annoy me (the shell script case). I read someone else's shell script file, it has to define all sorts of helper variables and helper procedures first, it's hard to locate the main program. and I invariably want to read the main program first (so I can decide which helpers I want to read)
14:15:44 * `nand` defines helper functions at the bottom but types at the top
14:16:56 <donri> gatlin_: hm literate need to be .lhs not .hs
14:18:36 <gatlin_> donri: my typo creating the hpaste, but I did at least know that much
14:18:51 <donri> ok :)
14:19:42 <donri> gatlin_: ghci is almost basically like inside the IO monad in a do-expression, but it also handles top-level statements like import specially
14:21:12 <gatlin_> donri: I've never even considered typing import statements inside a do-expression since those belong at the top, but the distinction is noted
14:21:15 <donri> gatlin_: without the literate style you could kinda do what you expected with ghci -ghci-script foo.hs
14:21:38 <monochrom> recent ghci supports "data Hi = Hello" and "instance Show Hi where show Hello = "hello"" and "class Greet g where ..." too
14:21:46 <donri> gatlin_: yea you can't import inside do; that's what i'm saying, ghci special-cases such input
14:21:56 * hackagebot forml 0.1.1 - A statically typed, functional programming language  http://hackage.haskell.org/package/forml-0.1.1 (AndrewStein)
14:23:40 <sclv> stepcut: ping
14:23:50 <sclv> stepkut: or ping
14:24:03 <raek> where can I read about how haskell handles bytes and characters?
14:25:01 <`nand`> raek: http://www.haskell.org/onlinereport/haskell2010/haskellch16.html#x24-21000016.1
14:25:20 <`nand`> and for ‘bytes’; I'm guessing you want http://www.haskell.org/onlinereport/haskell2010/haskellch23.html#x31-26000023
14:25:46 <nh2> could somebody try to clone https://github.com/bos/pcap and cabal build it? It seems not to work for me
14:26:32 <nh2> I think I do not use it correctly - it uses a configure script, but if I run autoconf and then cabal install, it complains about missing files
14:26:39 <raek> `nand`: I understand that haskell uses unicode characters internally, but I'm curious what happens when you read Strings from files, etc...
14:26:49 <gatlin_> donri: I just meant, I did not know that despite writing Haskell for two years because ... why? :)
14:26:59 <gatlin_> so thank you
14:27:06 <raek> I found this: http://hackage.haskell.org/trac/haskell-prime/wiki/CharAsUnicode
14:27:12 <`nand`> raek: depends on how you read it
14:28:29 <raek> for example, what determines the encoding used by 'getContents'?
14:28:49 <raek> there seems to be implicit encoding and decoding involved
14:29:10 <rwbarton> determined by handle encoding, which has default based on your locale
14:29:56 <raek> and if I want to read "raw bytes"? are there similar functions that don't perform any decoding?
14:30:22 <rwbarton> then you should use Data.ByteString
14:32:02 <raek> is there any guide for how to do text and binary I/O "properly"?
14:32:16 <raek> rwbarton: ok, will take a look at it
14:32:34 <gds> rwbarton: lispy : Thanks - that worked great :)
14:32:44 <kqr> what is the best way of building a list of empty lists with as many elements as another list?
14:33:02 <startling> raek, Text for sequences of characters, ByteString for sequences of bytes, String for being lazy
14:33:04 <startling> :t null
14:33:07 <lambdabot> [a] -> Bool
14:33:10 <startling> :t nulls
14:33:11 <lambdabot>     Not in scope: `nulls'
14:33:11 <lambdabot>     Perhaps you meant one of these:
14:33:11 <lambdabot>       `null' (imported from Data.List),
14:33:15 <startling> :t nullify
14:33:17 <lambdabot>     Not in scope: `nullify'
14:33:17 <lambdabot>     Perhaps you meant `nullOf' (imported from Control.Lens)
14:33:28 <startling> isn't that function somewhere?
14:33:40 <startling> kqr, anyway, fmap (const ()) or whatever works
14:33:47 <kqr> right
14:33:52 <kqr> i was doing something like that
14:34:17 <raek> are Text and ByteString represented in a more compact way than lists of Char/Word8?
14:34:37 <raek> startling: thanks for the summary
14:34:52 <startling> raek: yeah
14:35:28 <startling> by "being lazy" I mostly mean programmer laziness, but it's also evaluation-lazier for some things
14:44:44 <watermind> twmb: www.cs.nott.ac.uk/~gmh/fold.pdf
14:44:46 <watermind> ^
14:44:47 <watermind> read that
14:45:17 <twmb> k
14:45:34 <watermind> twmb: then this: http://www.cs.ox.ac.uk/publications/publication2335-abstract.html
14:46:22 <watermind> those papers are pretty good tutorials on programming with fold
14:46:46 <watermind> the first is about foldr for lists, how to use it and reason about it
14:47:09 <watermind> the second is about folds in a more general sense, and their composition with unfolds
14:48:02 <watermind> lispy: sorry got distracted, yes I have ghc-mod :)  it's pretty cool
14:48:15 <watermind> lispy: but I don't think it has case splitting sadly
14:50:52 <lispy> watermind: more to the point, you should add it!
14:51:38 <watermind> lispy: you're named lispy, if anyone here should be happy to program in elisp it's you :P
14:59:59 <Sonarpulse> OK, well I figured out how to make a CLI with cmdlib
15:00:07 <Sonarpulse> so now I am on to compiling the stand-alone binary
15:00:40 <Sonarpulse> While most of my "Library" code is in the heirarchy (Codec.Archive...)
15:01:00 <Sonarpulse> it seems ghc prefer's my executable to just be called main
15:01:07 <thirsteh> is there a shorthand for map (\(k, v) -> f k v) vs?
15:01:24 <Sonarpulse> thirsteh: map2 is probably what you wan't
15:01:31 <thirsteh> Sonarpulse: thanks, I knew it was something like that
15:01:37 <Sonarpulse> well that does two lists
15:01:42 <thirsteh> this is an AL
15:01:55 <etrepum> thirsteh: map (uncurry f)
15:01:58 <deus_rex> Sonarpulse: you could try map (uncurry f) s
15:02:00 <deus_rex> vs
15:02:03 <Sonarpulse> use can also use partition for [(a, b)] -> ([a]. [b])
15:02:04 <thirsteh> thanks!
15:02:05 <deus_rex> err, thirsteh
15:02:10 <dino-> Trying to cabal install something, just got notified that a major pile of stuff I have already installed will likely be broken. I'm thinking about how much easier it would be to just start over with installing stuff if I hadn't done --global for everthing. :/
15:02:26 <deus_rex> uncurry is one of my favorite HOF :)
15:02:35 <dmwit> thirsteh: Depending on how you're building your list, it's possible that you may be interested in
15:02:37 <Sonarpulse>  :t uncurry
15:02:38 <dmwit> :t zipWith
15:02:40 <lambdabot> (a -> b -> c) -> [a] -> [b] -> [c]
15:02:40 <Eduard_Munteanu> If you have two lists, you could use zipWith.
15:02:42 <deus_rex> @type uncurry
15:02:42 <dino-> Why have I always been so fixated on --global on this, basically, single user system?
15:02:44 <lambdabot> (a -> b -> c) -> (a, b) -> c
15:02:44 <thirsteh> I was thinking about curry/uncurry for the al but couldn't make it fit. makes sense now.
15:02:48 * dmwit high-fives Eduard_Munteanu 
15:03:06 <Sonarpulse> oh yeah, that's what I meant
15:03:08 <Sonarpulse> zipWith
15:03:19 <Sonarpulse> yeah, I would use zipWith and dispense with tuples
15:03:25 <dmwit> dino-: The correct thing to do is to invoke cabal install and tell it *all* the top-level things you want installed.
15:03:26 * `nand` uses --global on a single user system
15:03:32 <Sonarpulse> or use partition and zipwith together if you must have them
15:04:05 <dmwit> dino-: e.g. cabal install the-new-thing-you-want xmonad-contrib gtk # if all you care about besides the new thing is xmonad and gtk2hs ;-)
15:04:08 <Sonarpulse> (well actually uncurry+map is faster because you only go through the list once)
15:04:23 <thirsteh> I'm only traversing this particular AL once, naively, so map uncurry will do
15:04:25 <thirsteh> thanks again
15:04:27 <dcoutts_> dmwit: right, and the fact that people don't get this tells me that we need to change the UI to enforce that mode of operation
15:04:46 <Sonarpulse> does anybody know the answer to my compiling question?>
15:04:52 <dmwit> dcoutts_: My life has been about 30x better since you told me this, and I've had similar reports from several other people.
15:05:09 <Sonarpulse> should you always call your "non-library" module Main?
15:05:51 <`nand`> my life has seen an immeasurable increase in quality when I stopped using cabal-install :)
15:06:09 <dmwit> dcoutts_: Does (can) cabal track which things have been installed at the user's request (rather than as dependencies)?
15:06:25 <dcoutts_> dmwit: yes, that's what the world file contains
15:07:05 <dmwit> One very easy stopgap measure might be to change the "I'm going to reinstall things and that's bad" warning message to suggest a possible cabal-install invocation that would install those.
15:07:12 <Sonarpulse> speaking of package managers, I recently learned of http://nixos.org/nix/
15:07:20 <Sonarpulse> I feel like Cabal should work like that
15:07:22 <geekosaur> Sonarpulse, yes to Main (absent a --main-is)
15:07:23 <dmwit> e.g. "I'm going to reinstall things and that's bad, but maybe you'd like 'cabal install foo bar baz'"
15:07:33 <watermind> Sonarpulse: I don't think so, you do need to have a main  function though
15:07:33 <dmwit> Sonarpulse: I think there was a GSOC to do that kind of thing.
15:07:37 <dcoutts_> Sonarpulse: you're not the only one
15:07:44 <watermind> Sonarpulse: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
15:07:46 <`nand`> I've always wanted to try nix, but I'm too happy with portage to find the motivation to experiment
15:07:50 <`nand`> maybe I could install NixOS on my netbook
15:08:00 <dmwit> No idea if/when that work is going into mainline, though. (Maybe dcoutts_ knows more?)
15:08:03 <dcoutts_> Sonarpulse: we've had that in mind for years (and been making steps in that direction)
15:08:03 <Sonarpulse> also look up Gobo linux
15:08:09 <dmwit> Yeah, Gobo is pretty great.
15:08:22 <Sonarpulse> if Nix did it's directory's like gobo
15:08:26 <Sonarpulse> that would be perfect
15:08:28 <dcoutts_> dmwit: it needs more work, it's not ready to merge
15:08:41 * dmwit nods in resignation
15:09:02 <Sonarpulse> and then use plan9 style namespaces instead of a shit ton of symlinks
15:09:07 <Sonarpulse> and everything is perfect
15:09:12 <dino-> dmwit: Not sure what you mean. I want to install hakyll and if it brings in a newer pandoc, 25 other things will break.
15:09:25 <dino-> Is what it's telling me.
15:09:32 <dino-> So what's the list of top-level things in this case?
15:09:35 <dcoutts_> dmwit: don't take it as a negative. We made a lot of progress with that GSoC, but it's a bigger project.
15:10:06 <dcoutts_> it didn't start with that GSoC, and it will not end with it
15:10:15 <dmwit> great =)
15:10:31 <dmwit> dino-: I can't answer that; only you can know what things you definitely want to be installed.
15:10:55 <dmwit> dino-: However, as dcoutts_ has just been saying, taking a peek in your world file may give you a clue; probably most of the things in there are the "top-level" things.
15:11:17 <dmwit> ~/.cabal/world by default
15:11:40 <Sonarpulse> is this what you all mean? http://www.haskell.org/haskellwiki/Hack-Nix
15:12:23 <dino-> dmwit, dcoutts_: Ah, I didn't know of this world file. It would probably be great to upgrade all of those things anyway.
15:12:42 <monochrom> remember to review and edit the world file
15:12:45 <dcoutts_> dino-: you can see: cabal install world --dry-run
15:13:11 <Sonarpulse> wait, should your Main even have a module decleration at the top?
15:13:22 <monochrom> optional
15:13:42 <dmwit> Sonarpulse: I mean youtube.com/watch?v=h4QmkyN28Qs
15:13:52 <monochrom> but choose only from these two: no "module Main...", or "module Main(main)"
15:14:17 <monochrom> because normally "module Main" i.e. exporting everything is not what you want
15:14:54 <`nand`> monochrom: why?
15:15:13 <monochrom> well, I guess it doesn't hurt. but it makes your exe bigger
15:15:25 <lispy> watermind: I used to write way too much elisp, but isn't ghc-mod in Haskell?
15:15:35 <monochrom> (do you see why it makes the exe bigger?)
15:15:57 <lispy> watermind: http://hackage.haskell.org/package/ghc-mod
15:16:23 <`nand`> does leaving out the ‘module Main’ make it default to just exporting ‘main’, then?
15:16:29 <monochrom> yes!
15:16:47 <lispy> huh, learning something new everyday I guess
15:17:13 <watermind> lispy: oh you're right... it's haskell (well + some elisp of course) I didn't know that
15:17:25 <monochrom> hehehe, a hackage package of elisp files!
15:17:46 * monochrom prepares to upload php code to hackage!
15:18:23 <Saizan> monochrom: got hired by facebook too?
15:18:40 <monochrom> no
15:18:43 <lispy> monochrom: oh no, won't that result in a tremendous explosion?
15:18:58 <lispy> haskell + anti-haskell = Boom?
15:19:11 * Saizan guesses it wasn't a good joke
15:19:14 <deus_rex> what language is the antihaskell?
15:19:26 <monochrom> the tarball format protects us, don't worry
15:19:29 <deus_rex> is there some language which requires every function to hav side-effects?
15:19:32 <lispy> deus_rex: php?
15:19:42 <thoughtpolice> shouldn't it be cohaskell
15:19:53 <`Jake`> what about assembly?
15:19:55 <lispy> cohaskell would be your editor?
15:20:08 <monochrom> every haskell function has side effects: generates heat, for example
15:20:25 <lispy> monochrom: only if you run it!
15:20:33 <`nand`> only if you're evaluating it in our universe
15:20:33 <`Jake`> monochrom: That depends on the system you run it on
15:20:37 <donri> and not if they get optimized away!
15:20:47 <thoughtpolice> i mean, shouldn't it be s/antihaskell/cohaskell/ - although duals are perhaps a little bit different from haskell's direct antithesis
15:20:51 <monochrom> true, but the same can be said of main :: IO ()
15:20:52 <thoughtpolice> :P
15:21:15 <monochrom> well, maybe s/same/analogous/
15:22:04 <`nand`> `Jake` makes a good point; most machine languages have a side effect that modifies the instruction pointer on every single command; though I think some ‘jump 0’-like commands could leave a system unchanged
15:22:42 <Sonarpulse> basic
15:22:46 <`Jake`> `nand`: I think it does change the program counter
15:22:56 <Sonarpulse> also, won't it not matter what you "export" if you are compiling a native binary
15:23:03 <Sonarpulse> you don't export anything!
15:23:22 <thoughtpolice> Sonarpulse: GHC needs to see the main definition. it's not a linker-level thing, it's a language level thing
15:23:35 <thoughtpolice> (you can perfectly write a Main module and hide the main function)
15:23:54 <monochrom> I actually have a haskell module exporting nothing. the whole package's purpose is so I can run "cabal install --user --enable-documentation" on it to refresh .cabal/share/doc/index.html
15:24:31 <monochrom> and I have to do that because sometimes I install packages in --global
15:24:31 <dcoutts_> monochrom: and you use that after unregistering packages?
15:24:35 <dcoutts_> oh ok
15:24:51 <monochrom> I don't unregister packages anymore
15:25:44 <monochrom> yes! is there some kind of "cabal refresh-doc" command we can hope for in the future! :)
15:26:29 <dcoutts_> monochrom: should be simple for someone to write a patch for that, given the code to do it is already there
15:26:31 <`Jake`> I like how learning assembly teaches you why a function should be tail-recursive
15:29:24 <startling> it's just turning a call to a jump.
15:29:40 <`Jake`> exactly
15:29:51 <niteria> can you derive Typeable for type DummyType a if you don't know that a is Typeable?
15:30:04 <startling> niteria: yes
15:30:14 <`nand`> doesn't that get you Typeable2 DummyType or something
15:30:26 <startling> oh right
15:30:32 <rwbarton> @kind Typeable1
15:30:35 <lambdabot> (* -> *) -> Constraint
15:30:48 <cieplak> I am trying to model different types of financial statements
15:30:53 <cieplak> and am running into issues
15:31:05 <cieplak> because of multiple declarations of certain types
15:31:27 <startling> what's best practice for using mtl stuff? I'm using a lot of StateT Text Maybe -- should I use a type synonym, a newtype, or define my own thing and make it a MonadState instance?
15:31:36 <cieplak> I want to create two types of Income and Expense Statements
15:31:39 <hpaste> niteria pasted “Can't make a derived instance of `Typeable (Type l)” at http://hpaste.org/78248
15:32:01 <rwbarton> what's the rest of the error
15:32:04 <cieplak> that each share certain line items, but also have different line items
15:33:02 <startling> specifically I'm going to want MythingT m a = StateT Maybe (m a)
15:33:07 <niteria> You need -XDeriveDataTypeable to derive an instance for this class
15:33:09 <niteria>     In the data type declaration for `Program'
15:33:09 <startling> er, StateT Text maybe
15:33:23 <niteria> should I just add it?
15:33:24 <rwbarton> niteria: you left out LANGUAGE
15:33:31 <rwbarton> reading error messages works again
15:33:40 <cieplak> Is it possible to have two data types that have the same attribute names?
15:33:51 <startling> cieplak, not really.
15:34:13 <startling> if they're similarly typed, you could make a typeclass.
15:34:15 <niteria> sorry I have no idea what these pragmas mean
15:34:21 <startling> but you probably shouldn't.
15:34:24 <dmwit> cieplak: Yes, put them in different modules.
15:34:26 <rwbarton> {-# LANGUAGE DeriveDataTypeable #-}
15:34:31 <niteria> I though they were ortogonal
15:34:33 <rwbarton> not {-# DeriveDataTypeable #-}
15:34:39 <Sonarpulse> thanks everybody!
15:34:41 <startling> niteria, {-# Language DeriveDataTypeable #-} lets you derive Typeable
15:34:46 <rwbarton> the latter is just a useless comment
15:34:49 <twmb> As a general survey, does anybody have an opinion on which is best:  Snap, Yesod or Happstack?
15:35:39 <niteria> ok, I see, I thought Language was part of Language CPP
15:36:00 <lispy> twmb: I have only used snap, my program was near trivial, and snap was a pleasure to work with.
15:36:07 <cieplak> What is best practice for implementing data type inheritance in Haskell?
15:36:40 <lispy> cieplak: sum types
15:36:51 <niteria> what's BASE4 macro?
15:36:55 <lispy> data Parent = Child1 | Child2
15:36:58 <twmb> I've had Snap recommended on here before but I'm reading a tut about Yesod and the guy says that Yesod seems the most actively developed, and in reading it... Yesod looks easy to get in to
15:37:11 * `nand` is not sure what that has to do with inheritance
15:37:19 <cieplak> sum types? as in composing types
15:37:23 <lispy> twmb: Yesod also has an o'reilly book if that's you're thing
15:37:26 <lispy> your*
15:37:26 <dino-> I just don't understand what to do. installing world keeps insisting that some things have to be downgraded.
15:37:47 <`nand`> (this is probably not the best practice but one distinct approach is to use classy lenses :)
15:37:51 <twmb> my thing is "best", but that is always tough to evaluate ;)
15:37:56 <monochrom> `nand`: the statement means: the best way to implement inheritance is to circumvent inheritance :)
15:38:01 <lispy> cieplak: a sum type is when you have multiple data constructors, like in the example Parent type I gave
15:38:59 <dino-> Am I crazy, or is there way too much <= in cabal deps in projects when there should be >= used?
15:39:01 <lispy> cieplak: It's like this, data Shape = Circle | Square | Triangle
15:39:26 <dino-> I mean, I'd like to see things break in the other direction and everybody keep having to move forwards. As opposed to a package sticking in the past.
15:39:28 <lispy> cieplak: so then we can say, Circle is-a Shape
15:39:48 <lispy> cieplak: if you're working with type classes the solution is a little different
15:39:54 <dcoutts_> dino-: it's not so fun for the ordinary users who want things to work
15:40:03 <dino-> Or, put another way, I think you need to have a damn serious reason to use <=, and please avoid it
15:40:07 <cieplak> lispy: in your example is it possible to change Square to quadrilateral, and then define Square as a type of Quadrilateral?
15:40:39 <cieplak> so like:
15:40:56 <cieplak> data Quadrilateral = Square | Rhombus
15:41:13 <dino-> dcoutts_: But isn't this how things work more often in *nix packaging systems like deb or what-have-you?
15:41:15 <cieplak>  and data Shape = Quadrilateral | Triangle | Circle
15:41:30 <lispy> data Shape = Circle | Quad Quadrilateral | Triangle; data Quadrilateral = Square | Rhombus
15:41:36 <twmb> hmm but just googled it and snap looks better easily
15:41:45 <dcoutts_> dino-: the upper bounds or no upper bounds debate is fine and interesting, but all participants have to start by noting and admitting that there are tradeoffs in both directions, and the decision is about the balance between them
15:41:49 <lispy> cieplak: Shape has to have a distinct constructor to wrap the Quadrilateral in
15:41:53 <dmwit> dino-: In Debian and friends, there is a collection of people who choose a single blessed collection of package versions that are known to work well together.
15:42:11 <dmwit> dcoutts_++
15:42:20 <dmwit> dcoutts_--
15:42:21 <dino-> dmwit: I see, it's less 'people doing the right things' than I had guessed then
15:42:21 <dmwit> dcoutts++
15:42:22 <cieplak> Thanks lispy!
15:42:44 <dcoutts_> dmwit: heh, is that the ++ -- tradeoff?
15:42:52 <dmwit> heh
15:42:52 <lispy> cieplak: you're welcome, I hope you enjoy the Haskell
15:43:00 <cieplak> Before I wasn't wrapping Quadrilateral with its own type constructor in Shape
15:43:18 <monochrom> dino-: http://article.gmane.org/gmane.comp.lang.haskell.cafe/101665/
15:44:04 <monochrom> it is why and how a linux distro or freebsd or ... works. by throwing so many man-years at the problem
15:44:45 <monochrom> and in practice, it begins, not ends, with choosing versions
15:45:51 <dmwit> Just another example of "I don't know much about this (sub)field, but how hard can it possibly be?". =)
15:46:25 <dino-> dmwit: From outside it looks magically simpler than it is, I get what you're saying.
15:46:30 <monochrom> will someone take one lenses version, then cherry-pick patches from other lenses versions, so that the result works nicely with a particular version of yesod? when that day comes, you can fairly compare linux distros with haskell packages
15:46:46 <dino-> So, about my own system. Is it just a case where I should start over if installing world is failing?
15:46:52 <lispy> cieplak: if you looking to bring OO notions of programming to Haskell there is a temptation to (over) use typeclasses. My advice is to avoid creating new type classes until you're familiar with the language.
15:47:59 <lispy> (type classes are nice, but it's hard to explain how to make good use of them)
15:48:12 <monochrom> you are already starting over. one way or another, you may still want to install a set of packages not too different from world. then it's the same dilemma again
15:49:44 <monochrom> the only solution I know: consciously decide which main packages you want (maybe start from world but consciously edit it?), cabal install --dry-run, if it looks bad, find out why, find out who asks for the bad packages/versions
15:50:25 <monochrom> it is why I recommend against "cabal install world". like, do you even know what's in the world file?
15:51:02 <dino-> monochrom: I did look at it first, and it seemed ok I guess. Things that I installed at some point.
15:51:12 <dino-> Not everything is necessary probably.
15:51:42 <dino-> And some thing are installed because I had other problems in the past and troubleshot it by installing deps one by one
15:51:50 <dcoutts_> dino-: the problem with cabal install world (and why we don't heavily promote it at the moment) is that generally for that large a set of packages you've got no hope of having it all installed with consistent dependencies
15:52:06 <kqr> the wiki says that `seq x x' is redundant and equal to just `x'. does this apply even if `x' isn't used at all further down the line?
15:52:19 <monochrom> yes
15:52:31 <kqr> i want to force computation of a value that is never used
15:52:33 <monochrom> > const True (seq undefined undefined)
15:52:35 <kqr> for profiling purposes
15:52:35 <lambdabot>   True
15:52:53 <kqr> okay
15:52:54 <monochrom> then force it at a point that is forced
15:53:18 <kqr> like when? i can only think of printing it, which affects the results
15:53:20 <monochrom> e.g., "const True (seq x x)" is different from "seq x (const True x)"
15:53:29 <dcoutts_> kqr: you have to "attach" the forcing to something that you do use
15:53:37 <kqr> hm
15:53:41 <kqr> is there anywhere i could read about this?
15:53:49 <kqr> i'm not sure i follow
15:54:19 <monochrom> perhaps my http://www.vex.net/~trebla/haskell/lazy.xhtml
15:54:37 <dino-> It's weird, my world has xmonad -any and xmonad-contrib -any in it, system currently has v0.10 installed of those..
15:54:43 <dcoutts_> kqr: the first arg of seq is the thing you want force, that's fine and understandable. The more subtle thing is that the second arg is the thing which you're anchoring the evaluation to.
15:54:55 <dino-> And cabal install world says it will install v0.8 and break 0.10
15:55:07 <dino-> I wonder what's forcing 0.8 on it.
15:55:17 <rwbarton> "seq x y" is an expression which, *when evaluated*, will first evaluate x and then return y
15:55:22 <dcoutts_> kqr: so that when the second thing does get evaluated as normal, then the extra thing gets evaluated at that same point
15:55:38 <kqr> oh
15:55:39 <dmwit> dino-: This means you have some other package (perhaps xmonad-extras? or perhaps a dependency of xmonad that conflicts with other packages you're trying to install) that is forcing 0.8.
15:55:40 <kqr> wow
15:55:42 <kqr> haha
15:55:49 <kqr> i didn't realise it was that involved
15:56:08 <monochrom> dino-: perhaps paste the world file, I can try a couple of cabal install --dry-run to find out who
15:57:04 <monochrom> you can also ramp up the -v setting (to -v3? -v30?) but usually I think I am better than you at reading that output :)
15:57:26 <toktak> logout
15:57:28 <toktak> exit()
15:57:32 <monochrom> /quit
15:57:37 <dcoutts_> dino-: -v will tell you, but you can also often find out just by telling it to do what you want, and it'll either do that or tell you why it can't. ie in this case you add --constraint='blah >= 0.10'
15:57:54 <monochrom> oh, that's probably even better
15:57:56 <hpaste> dino- pasted “cabal world file” at http://hpaste.org/78250
15:58:23 <rwbarton> that looks pretty tame
15:58:30 <Sonarpulse> oops, thought I was almost done and I wasn't
15:58:36 <kqr> dcoutts_, rwbarton monochrom thanks, i figured it out :)
15:58:37 <dino-> dcoutts_: Ah, I didn't know of those techniques, the --constraint
15:58:46 <Sonarpulse> http://hackage.haskell.org/packages/archive/cmdlib/latest/doc/html/System-Console-CmdLib.html
15:58:56 <Sonarpulse> does anybody know how to give run' to main in that?
15:59:03 <Sonarpulse> the documentation is pretty spotty
15:59:11 * rwbarton has 67 lines in ~/.cabal/world
15:59:26 <shachaf> bgamari: Did you figure it out?
15:59:42 <bgamari> shachaf, Not yet
16:00:09 <bgamari> shachaf, I'm rewriting some of the code in question at the moment
16:00:35 <sclv> i'd love a "user's guide to modern/advanced cabal" blog post.
16:00:48 <bgamari> shachaf, the initial code was less than approachable
16:01:13 <dino-> That gtk2hs-buildtools keeps installing over and over :D, is that because it's only binaries and it can't be determined that it's already present from ghc-pkg?
16:01:24 <shachaf> bgamari: The issue I encountered with newtypes was http://hackage.haskell.org/trac/ghc/ticket/7398
16:01:52 <dcoutts_> dino-: oh yes, that's the other reason cabal install world is half baked at the moment
16:02:00 <shachaf> bgamari: Generally I came to that conclusion by compiling lots of different variations of the code and looking at the code and -ddump-rewrites
16:02:01 * hackagebot fdo-trash 0.0.0.1 - Utilities related to freedesktop Trash standard.  http://hackage.haskell.org/package/fdo-trash-0.0.0.1 (EmilKarlson)
16:02:30 <dino-> Hm, could be that xmobar is failing because of the Not in scope: `catch'
16:02:45 <bgamari> shachaf, It's definitely a tough problem
16:02:49 <shachaf> bgamari: I don't know much about your code specifically so I can't say much. :-)
16:02:56 <bgamari> shachaf, of course
16:04:01 <rwbarton> dino-, yes
16:04:21 <lispy> I had to reboot the server that lambdabot lives on, sorry
16:04:38 <rwbarton> did you migrate this world file from an older ghc version?
16:04:38 <lispy> Cale: I had to reboot, please restart lambdabot when you get a chance. Thanks!
16:04:58 <rwbarton> (Why doesn't hackage build executables?)
16:05:20 <dino-> rwbarton: Me? Maybe. It's something my backups have when I do new systems, so it's very likely.
16:06:05 <rwbarton> ISTR xmobar doesn't build on 7.6
16:06:37 <dino-> rwbarton: I have a running binary of it now, could just hang onto that.
16:07:05 <dino-> If it's just that catch thing, I could contribute a patch for xmobar
16:07:47 <dmwit> You should try xmobar from darcs first; maybe there's already a patch.
16:07:52 <dmwit> Have you cabal update'd recently?
16:07:56 <hpaste> JRoy pasted “Higher-Rank” at http://hpaste.org/78251
16:07:57 <monochrom> dino-: xmobar-0.15 (newest) wants X11-1.6.*, this forces older xmonad because newest xmonad-0.10 wants X11 < 1.6, whereas older xmonad-0.8 is lax on it. (xmonad-0.9 also wants X11 < 1.6)
16:08:01 <dmwit> Maybe the patch is already on Hackage and you just didn't even know it. =)
16:08:04 <dino-> dcoutts_: Yes, several times in the past hour even
16:08:13 <rwbarton> oh, it has a different maintainer now. promising
16:08:28 <dmwit> dino-: Oh, darcs xmonad{,-contrib,-extras} are X11-1.6-compatible.
16:08:35 <rwbarton> https://github.com/jaor/xmobar/commit/cbc0c9ac5219182ccd384eb5a4bbf3c4cad4f446
16:08:48 <monochrom> dino-: and then, if you add --constraint='xmonad >= 0.10', then it settles for older xmobar and older X11
16:09:05 <rwbarton> but latest hackage version is 5 months ago
16:09:40 <JRoy> is there any way to make http://hpaste.org/78251 work?
16:10:34 <mdszy> I don't think you can have statements in type definitions like that
16:10:52 <rwbarton> JRoy, well the type of k is too specific to be an argument to f
16:11:22 <dino-> I wonder why cabal install world was trying to get xmobar-0.14 when even hackage has 0.15
16:11:51 <dino-> Presumably nothing depends on xmobar
16:12:04 <monochrom> oh, i missed that one
16:12:18 <rwbarton> looks like 0.15 added some more specific version constraints
16:12:21 <dcoutts_> dino-: ask it, most likely it needs a later version of some other dep
16:12:45 <monochrom> rejecting: xmobar-0.15 (conflict: regex-base => mtl==2.1.2/installed-cf6..., xmobar => mtl==2.0.*)
16:12:51 <rcl> is GHC able to compile itself to C callable via FFI code for ARM? i have some code in an existing iOS program that I would like to rewrite as an experiment
16:13:07 <dcoutts_> dino-: btw, when experimenting with this stuff, can also be worth using --max-backjumps=-1 --reorder-goals
16:13:22 <dino-> How do I ask for things like that? I don't see it in -v output
16:13:42 <dino-> Ok, I think I need to read some docs.
16:13:42 <monochrom> xmobar-0.15 wants mtl==2.0.*, but you have mtl-2.1.* and something else wants it too (regex-base)
16:13:57 <dcoutts_> dino-: when I say ask, I mean tell it do to what you expected/want, --constraint='xmobar >= 0.15'
16:13:58 <monochrom> xmobar-0.14 wants mtl-any
16:14:23 <rcl> [A/window 1
16:14:57 <monochrom> I quickly read "cabal install world --dry-run -v3" :)
16:15:20 <dcoutts_> dino-: --constraint='xmobar >= 0.15'   is you asking the question, "would it work with xmobar-0.15?" to which it will either say yes, or no because of these constraints.
16:15:42 <dino-> dcoutts_: ok
16:16:01 <scp> @hoogle (a -> b -> c) -> m a -> m b -> mc
16:16:13 <scp> @hoogle (a -> b -> c) -> m a -> m b -> m c
16:16:22 <scp> hmm, what is wrong w/ my syntax?
16:16:26 <mm21> lamdabot is down atm
16:16:29 <scp> ah, ok
16:16:36 <deus_rex> scp: liftM2
16:16:51 <mm21> +b
16:17:00 <scp> ah, of course x_X
16:17:05 <scp> deus_rex, thanks =]
16:18:05 <JRoy> is it true that: forall a b. a ~ b => a -> b -> Bool   is equal to  forall a. a -> a -> Bool ?
16:19:32 <TheInfosphere> I want to build a METAR parser with Parsec, and I'm not a complete novice, but I'm not a guru either. Where should I start?
16:20:19 <Saizan> :t forever
16:21:47 <startlebot> Saizan: m a -> m b
16:23:27 <Saizan> thanks :)
16:23:30 * dcoutts_ tests his new implementation of "cabal build [target]"
16:23:34 <shachaf> JRoy: Yep.
16:24:09 <shachaf> @ty (==) :: (Eq a, a ~ b) => a -> b -> Bool
16:24:49 <startlebot> shachaf: (Eq a, a ~ b) => a -> b -> Bool
16:25:23 <rwbarton> startlebot must have a different version of ghc than i do
16:25:32 <shachaf> > upon last %~ succ $ [1,2,3,4]
16:25:48 <dino-> Well, I think it may just be safest to not upgrade xmobar today.
16:25:54 <dino-> This has been exhausting!
16:25:57 <shachaf> rwbarton: Well, it could be using a different type checker than GHC.
16:25:58 <startlebot> shachaf: <interactive>:5:1: Not in scope: `upon'
16:26:28 <dino-> Thank you all for helping, I really appreciate it. And I have taken notes on these cabal switches and techniques for solving these things.
16:26:49 <shachaf> :m + Unsafe.Coerce
16:27:00 <shachaf> :m + Data.Data.Lens
16:27:03 <shachaf> > upon last %~ succ $ [1,2,3,4]
16:27:36 <startlebot> shachaf: <interactive>:9:1: Not in scope: `upon'
16:29:13 <neworder> let pow = 1:map (2*) pow in take 10 pow
16:29:22 <neworder> I traced the code I got it actually but I keep thinking that this part of the function "map (*2) pow" multiplies every element in the list by 2 instead of just multiplying the last element by 2 and I feel this is more intuitive because of the "map (*2) pow". Did this type of thinking ever occur to you all?
16:29:57 <sclv> neworder: rename it to powers and it seems more intuitive to me
16:30:05 <latro`a> not sure why it would only multiply on the last element
16:30:09 <sclv> "pow" reads like a function name
16:30:18 <sclv> it isn't just the last element.
16:30:21 * startlebot suckerpunches neworder 
16:30:21 <latro`a> erm, why you would think it would do that
16:30:25 <sclv> its the remainder
16:30:32 <sclv> so you get [1,2,4,8] etc.
16:30:39 <latro`a> the first element is 1, then the rest of the list is 2 times the entire list
16:31:10 <shachaf> neworder: It does multiply every element of the list by 2
16:31:17 <latro`a> you can think of it as a fixed point: what list is such that, if you double every element then prepend a 1, the list doesn't change?
16:31:27 <neworder> Oh
16:31:56 <neworder> So, so why does the list keep changing?
16:32:03 <rwbarton> it doesn't change
16:32:04 <latro`a> what do you mean keep changing?
16:32:26 <latro`a> "let pow = 1:map (*2) pow in pow" === map (2^) [0..]
16:32:29 <neworder> As in
16:32:38 <latro`a> it doesn't change, it's exactly that (infinite!) list
16:32:42 <neworder> At first map(*2) [1..]
16:32:51 <neworder> map (*2) [2..]
16:33:01 <sclv> eta expand properly
16:33:06 <latro`a> that's not how the recursion proceeds
16:33:15 <sclv> 1 : 2 * 1 : 2 * 2 * 1 : 2 * 2 * 2* 1 ...
16:33:31 <latro`a> the first element is 1; the second element is the first element of the list where you multiply everything by 2
16:33:33 <latro`a> i.e. 2
16:33:39 <neworder> pow = 1 : x where x= map (*2) pow
16:33:41 <latro`a> the third element is the second element of the list where you multiply everything by 2
16:33:43 <latro`a> i.e. 4
16:33:46 <neworder> x = 2 : y
16:33:50 <latro`a> etc.
16:33:59 <sclv> take 10 $ iterate (*2) 1
16:34:01 <sclv> is the same thing
16:34:16 <sclv> and maybe easier to understand
16:34:42 <latro`a> it's a little bit less helpful, because it doesn't as clearly demonstrate *value recursion*
16:35:00 <latro`a> which is actually not a different concept from "ordinary" recursion, but it looks like it is
16:35:30 <latro`a> neworder--I think the fixed point perspective is the easiest one to grasp at first
16:36:05 <latro`a> "let pow = 1:map (*2) pow in pow" can be interpreted as an *equation* rather than a definition
16:36:15 <latro`a> pow is a list such that if you double every element, then prepend a 1, you have the same list
16:36:48 <latro`a> erm, "pow = 1:map (*2) pow" can be interpreted as an equation, rather
16:36:53 <neworder> Hmm
16:37:24 <sclv> i guess the problem is you're thinking of map (*2) as changing pow
16:37:38 <sclv> when its just creating a new list (let's call it pow2) that is defined in terms of pow
16:37:54 <latro`a> then 1:pow2 = pow
16:37:57 <neworder> Equationally, yeah, I can see what's going on, just that I thought that something about it  is a bit counter intuitive, lol
16:38:00 <sclv> so we have pow = 1 : pow2 where pow2 = map (*2) pow
16:38:14 <latro`a> value recursion is a little bit counterintuitive
16:38:22 <sclv> so pow2 starts at 2, actually…
16:38:48 <sclv> its just another way to rewrite the same thing that might help be clearer
16:39:00 <neworder> sclv: right, that's where it's confusing me!
16:39:30 <latro`a> pow's first element is 1; since pow2 doubles every element of pow, its first element is 2
16:39:43 <latro`a> then pow2's first element is pow's second element
16:40:04 <latro`a> then pow2's second element is twice pow's second element, i.e. 2*2=4
16:40:24 <latro`a> then pow2's second element is pow's third element, etc. ad infinitum
16:40:51 <sclv> pow = 1 : pow2 where pow2 = map (*2) pow --> pow = 1 : pow2 where pow2 = map (*2) (1 : pow2) --> pow = 1 : pow2 where pow2 = 2 : map (*2) pow3; pow3 = map (*2) pow2, etc.
16:40:54 <monochrom> put indexes into the equation. pow !! 0 = 1. pow !! 1 = (pow !! 0) * 2. etc
16:40:55 <sclv> dunno if that helps
16:41:14 <sclv> just substituting and rewriting promiscuously and sort of randomly will help you to think through what things "mean"
16:42:20 <neworder> Hmm alright thanks a lot guys
16:42:35 <monochrom> see my http://www.vex.net/~trebla/haskell/scanl.xhtml  for more fun
16:46:25 <neworder> ok
16:55:05 <aa_> sorry if this is spam, but might interest people involved in Snap, my writeup of getting started: http://unpythonic.blogspot.com/2012/11/building-haskell-web-app-with-snap-snap.html
16:55:58 <Tehnix> I have a list with the type `Maybe [T.Text]' and want to use elem to check if there is a value present in the list, but the value I'm checking for is simply of type `[T.Text]'. What would the general way of solving such a problem be?
16:57:31 <Tehnix> If that wasn't a too vague question?
16:59:09 <cieplak> Suppose you have a type constructor that takes ten arguments. How would you destructure a list containing the arguments that will be passed to the constructor?
16:59:27 <byorgey> Tehnix: something of type  Maybe [T.Text]  is not a list
16:59:36 <byorgey> it is either Nothing or Just (a list)
17:00:03 <byorgey> Tehnix: also, if you are using elem to check for a value in a list of type  [T.Text], the element would have type   T.Text
17:00:14 <byorgey> so I don't understand when you say that the value you're checking for is of type  [T.Text].
17:00:24 <cieplak> Essentially I have DataFoo [X, Y, Z] but need to get DataFoo X Y Z
17:00:40 <Tehnix> oh, yeah, sorry, just type Text (and th T. was just from my way of importing it)
17:00:43 <Tehnix> hmm
17:01:30 <byorgey> Tehnix: ok, so you have a  Maybe [Text]  and a  Text, right?
17:01:36 <Tehnix> y
17:01:54 <byorgey> and what result should you get if the Maybe [Text] is Nothing?  False?
17:02:04 * hackagebot OpenCLWrappers 0.1.0.2 - The OpenCL Standard for heterogenous data-parallel computing  http://hackage.haskell.org/package/OpenCLWrappers-0.1.0.2 (EmilKarlson)
17:02:11 <Tehnix> yes, that would be desired
17:02:14 <byorgey> Tehnix: ok, then the easiest way is to convert the  Maybe [Text]  to a  [Text]  first
17:02:19 <byorgey> using something like   fromMaybe []
17:02:30 <byorgey> > fromMaybe [] (Just [1,2,3])
17:02:45 <byorgey> oh, is lambdabot dead?
17:03:03 <byorgey> anyway,  fromMaybe :: a -> Maybe a -> a
17:03:10 <shachaf> Cale must be busy upgrading lens.
17:03:23 <Cale> ?
17:03:29 <byorgey> fromMaybe a (Just b) = b;  fromMaybe a Nothing = a
17:03:31 <Cale> I upgraded it a while ago
17:03:36 <byorgey> @botsnack
17:03:42 <fryguybob> :(
17:04:01 <byorgey> @botsnack
17:04:08 <lambdabot> :)
17:04:47 <byorgey> Tehnix: anyway, does that make sense?
17:05:07 <Tehnix> byorgey: yeah, didn't know about the fromMaybe function, neat :)
17:05:09 <Tehnix> thanks :)
17:06:31 <byorgey> Tehnix: you could also do it manually with a case statement :    case maybeList of { Nothing -> False; Just list -> t `elem` list }
17:06:59 <byorgey> it's probably a good idea to understand how to do it that way, so you understand that functions like fromMaybe are not magical, but just saving you some work =)
17:07:20 <byorgey> sorry, s/case statement/case expression/
17:07:51 <Tehnix> ah, yeah, actually thought it was magic, but that makes it more clear what it does
17:08:34 <shachaf> Cale: Hooray!
17:08:35 <shachaf> Cale++
17:09:09 <shachaf> > (upon (!!3) %~ succ) "Hello there"
17:09:11 <lambdabot>   "Helmo there"
17:09:16 <edwardk> :t upon
17:09:18 <lambdabot> (Data.Data.Data s, Typeable a, Applicative f, Indexed Int k) => (s -> a) -> k (a -> f a) (s -> f s)
17:09:30 <edwardk> > (1,2) & upon fst .~ 3
17:09:32 <lambdabot>   (3,2)
17:10:01 <edwardk> > [1,2,3,4,5] & uponTheDeep (tail.tail) .~ [6,7,8,9]
17:10:02 <byorgey> Tehnix: so maybe you should go implement fromMaybe yourself.  Once you have implemented it correctly, only then can you use it =)
17:10:05 <lambdabot>   [1,2,6,7,8,9]
17:10:30 <Tehnix> byorgey: heh, sounds like a good excersie :)
17:10:41 <Tehnix> s/excersie/excersise
17:10:53 <niteria> http://stackoverflow.com/questions/8384292/how-to-define-multiple-type-of-comment-block-in-parsec I don't understand how this works, don't functions implemented in terms of whiteSpace already hold a reference to old whiteSpace definition?
17:11:27 <Tehnix> exercise*
17:13:41 <neworder> Sorry to bring in this matter again, haha!
17:13:43 <byorgey> > let yo = head; ho = tail in  words "bottle of yum" & uponTheDeep (yo . ho . ho) .~ 'r'
17:13:45 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:13:45 <lambdabot>              with actual typ...
17:14:02 <neworder> For this 	"let pow = 1:map (*2) pow in pow"
17:14:17 <neworder> This is the way I think about it
17:14:19 <byorgey> aww, what did I do wrong?
17:14:35 <neworder> That pow keeps changing
17:14:44 <byorgey> neworder: no, it doesn't
17:14:50 <latro`a> anything where you think of it as changing will be approximate at best
17:15:06 <neworder> so First: pow=[1..]
17:15:07 <geekosaur> niteria, whiteSpace is a field selector
17:15:10 <byorgey> neworder: pow is always the same!  Say rather than pow is evaluated
17:15:10 <neworder> and then pow becomes
17:15:15 <neworder> pow =[1,2..]
17:15:30 <neworder> Ah!
17:15:34 <neworder> I see
17:15:39 <latro`a> I'd say a better interpretation is that pow starts as 1:indefinite
17:15:46 <byorgey> neworder: yes, that's a good way to think about it operationally
17:15:47 <neworder> So that's where there's a bug in my thinking!!!! Argh
17:15:52 <byorgey> latro`a: I think that's what neworder meant
17:15:55 <latro`a> (thinking in terms of evaluation order, not "reconstruction")
17:16:20 <geekosaur> we are not changing the thing other functions use, that thing is still a field selector.  we're coming up with a new record for that field selector to pull its field out of
17:16:43 <hpaste> niteria pasted “makeTokenParser source” at http://hpaste.org/78254
17:16:53 <geekosaur> "make a copy of originalTokenParser, and replace the thing in its 'whiteSpace' slot with this other thing instead"
17:17:50 <niteria> the part I don't understand is why other parsers pick up the new definiton
17:17:55 <geekosaur> (it's unforutnate that the Parsec surce uses the name name for the field selector and for the local binding)
17:18:00 <startling> can ghc work with ARM? does this work on android devices?
17:18:09 <geekosaur> because "whiteSpace" is not meaningful by itself
17:18:18 <geekosaur> it's always used as:  whiteSpace someParserDefinition
17:18:28 <geekosaur> we don't change whiteSpace; we change someParserDefinition
17:18:34 <geekosaur> make sense?
17:19:10 <niteria> so line 425, whiteSpace is a selector, not a let binding?
17:19:26 <niteria> or where binding
17:19:41 <geekosaur> that one is a local binding.  it is assigned into the record on line 106
17:19:54 <geekosaur> the fact that the same name is used is rather unfortunate
17:20:10 <edwardk> > let yo = head; ho = tail in words "bottle of beer" & uponTheDeep (yo.ho.ho) .~ "rum"
17:20:12 <lambdabot>   ["bottle","of","rum"]
17:20:50 <shachaf> > let yo = head; ho = tail in words "bottle of beer" & upon (yo.ho.ho) .~ "rum"
17:20:52 <lambdabot>   ["bottle","of","rum"]
17:21:03 <edwardk> yeah that doesn't need deep
17:21:11 <fryguybob> > let yo = head; ho = tail in  words "bottle of yum" & uponTheDeep (yo . yo . ho . ho) .~ 'r'
17:21:12 <niteria> so the only point where whiteSpace is a selector is in the pattern match, right?
17:21:13 <lambdabot>   ["bottle","of","rum"]
17:21:36 <geekosaur> which pattern match where?
17:21:41 <edwardk> > let yo = head; ho = tail in words "bottle of beer" & uponTheDeep (ho.ho.ho) .~ ""
17:21:43 <lambdabot>   Couldn't match expected type `GHC.Base.String'
17:21:43 <lambdabot>              with actual typ...
17:21:50 <niteria> I mean line 106
17:21:55 <edwardk> > let yo = head; ho = tail in "bottle of beer" & uponTheDeep (ho.ho.ho) .~ ""
17:21:57 <lambdabot>   "bot"
17:22:04 <edwardk> > let yo = head; ho = tail in "bottle of beer" & upon (ho.ho.ho) .~ ""
17:22:06 <lambdabot>   "b"
17:22:08 <edwardk> there
17:22:13 <edwardk> that is an example of upon going wrong
17:22:50 <geekosaur> 106 is not a pattern match, it is part of a record constructor.  the name on the left is a field selector, the one on the right is the local binding that comes from the where clause
17:25:10 <niteria> I think I understand what's local and what's a selector, but it still doesn't make sense to me
17:26:21 <geekosaur> anything that uses whiteSpace does not simply say 'whiteSpace'; it has to say 'whiteSpace someLanguageDef'
17:27:02 <geekosaur> the stackexchange thing creates a new languageDef from an old one by changing the parser it returns when it's asked for its whiteSpace
17:27:06 <edwardk> geekosaur: which is part of why i did them differently in tirfecta =P
17:27:10 <geekosaur> (i.e. whiteSpace newLanguageDef)
17:27:32 <monochrom> suppose you have data R = R{ xx :: Int }. then xx is a function, type R -> Int. so R{xx=xx} is a type error
17:27:49 <niteria> maybe I need to read monad instance for GenParser
17:27:50 <edwardk> geekosaur: the problem is that isn't sound iirc, because the other parsers already in the language def still reference the old approach
17:28:02 <geekosaur> yes
17:28:25 <edwardk> this was one of the factors that forced me to write language def stuff entirely differently
17:28:25 <geekosaur> well, unless they also indirect through the language definition, which they "should" but might not
17:28:31 <edwardk> they can't
17:28:38 <edwardk> they'd have to be passed the record as an argument
17:28:48 <edwardk> they don't take it, ergo, non-open recursion
17:28:52 <geekosaur> hm, right
17:33:22 <niteria> definition of GenParser blows my mind
17:33:40 <niteria> type Parser a           = GenParser Char () a
17:33:46 <niteria> newtype GenParser tok st a = Parser (State tok st -> Consumed (Reply tok st a))
17:33:51 <niteria> why is it recursive?
17:34:04 <startling> that's not recursive.
17:34:08 <Nereid> my god that is a gigantic record
17:34:16 <monochrom> you need sleep
17:34:22 <byorgey> Parser is the name of the constructor for GenParser
17:34:23 <scp> niteria, Parser is a Constructor, not the "Parser" type
17:34:29 <niteria> omg
17:34:33 <niteria> i need sleep
17:35:02 <startling> asked this before, but no answer: what's best practice for using mtl stuff? I'm using a lot of StateT Text Maybe -- should I use a type synonym, a newtype, or define my own thing and make it a MonadState instance?
17:35:25 <cieplak> In Haskell, is it possible to recursively pass type parameters to a type constructor, and essentially build the data type in steps?
17:35:33 <byorgey> startling: the last two
17:35:36 <monochrom> I think it's a type synonym or a newtype, depending on how much you want to hide
17:35:47 <byorgey> startling: make a newtype, and derive a MonadState instance using GeneralizedNewtypeDeriving
17:35:55 <startling> byorgey: cool, sounds good. thanks!
17:36:22 * byorgey just feels like it's cleaner using a newtype no matter how much you want to hide/expose
17:36:30 <byorgey> but I can see the argument for using a type synonym as well
17:37:10 * byorgey 'cabal install lens'-es
17:37:26 <Eduard_Munteanu> cieplak: I'm not sure what you mean, could you provide some sort of example?
17:37:40 <cieplak> yes
17:37:41 <edwardk> byorgey: trying the new hotness?
17:37:51 <byorgey> just trying it in general
17:38:03 <byorgey> trying to figure out why my piratey code didn't work
17:38:15 <edwardk> > let yo = head; ho = tail in words "bottle of beer" & uponTheDeep (yo.ho.ho) .~ "rum"
17:38:17 <lambdabot>   ["bottle","of","rum"]
17:38:22 <edwardk> you were off by a level
17:38:34 <cieplak> data Attributes = Attributes { a :: Maybe String                              , b :: Maybe String                              , c :: Maybe String }                  deriving (Show, Eq)
17:38:34 <byorgey> oh! now I get it, of course I was
17:38:40 <edwardk> > let yo = head; ho = tail in words "bottle of beer" & uponTheDeep (yo.yo.ho.ho) .~ 'r'
17:38:42 <lambdabot>   ["bottle","of","reer"]
17:38:43 <cieplak> hmm that didn't paste well
17:38:48 <edwardk> > let yo = head; ho = tail in words "bottle of yum" & uponTheDeep (yo.yo.ho.ho) .~ 'r'
17:38:50 <lambdabot>   ["bottle","of","rum"]
17:39:04 <byorgey> sure, but no self-respecting pirate would say "yo ho ho ho"
17:39:05 <edwardk> anyways you don't need upon the deep for that. upon will do
17:39:09 <Eduard_Munteanu> cieplak: ok, that's valid Haskell so far...
17:39:12 <edwardk> pirate santa would
17:39:18 <byorgey> hehe
17:39:22 <geekosaur> if you expected multiple lines, please use hpaste next time
17:39:24 <geekosaur> @paste
17:39:25 <lambdabot> Haskell pastebin: http://hpaste.org/
17:39:28 <cieplak> defaultAttributes = Attributes Nothing Nothing Nothing
17:39:41 <byorgey> edwardk: uponTheDeep just makes me think of pirates, that's all
17:39:42 <cieplak> I want to build defaultAttributes recursively
17:39:43 <monochrom> so far there is no recursion
17:39:52 <edwardk> byorgey: =) next up we need vastyDeep
17:40:01 <johnw> byorgey: it makes me think of cthulu
17:40:12 <deus_rex> > (any . (==)) 5 [1..10]
17:40:13 <Eduard_Munteanu> cieplak: well, what monochrom says, what is there to recurse on?
17:40:14 * geekosaur notes that 'uponTheDeep' makes him think of the Slow Zone
17:40:14 <lambdabot>   True
17:40:15 <scp> What are lenses?
17:40:15 <cieplak> so I need to create a function that accepts a partially applied constructor
17:40:22 <deus_rex> @let myElem = (any . (==))
17:40:23 <lispy> @tell Cale thanks!
17:40:25 <lambdabot>  Defined.
17:40:25 <lambdabot> Consider it noted.
17:40:29 <deus_rex> @type myElem
17:40:31 <lambdabot> Eq a => a -> [a] -> Bool
17:40:37 <monochrom> Attribute is not a recursive type to begin with
17:40:37 <byorgey> scp: special mind-control devices created by edwardk to enslave the populace of #haskell
17:40:40 <deus_rex> > 5 `myElem` [1..10]
17:40:42 <lambdabot>   True
17:40:54 <cieplak> the problem is that at each step of the recursion, the input type is different
17:40:57 <lispy> cieplak: constructors are functions too (which may help youthink about it)
17:40:58 <deus_rex> what the heck
17:40:59 <lispy> :t Just
17:41:01 <lambdabot> a -> Maybe a
17:41:03 <lispy> cieplak: ^^
17:41:09 <simpson> deus_rex: Which part of this confuses you?
17:41:13 <edwardk> scp: The lens package basically decomposes a lot of the classes folks already know how to use, functors, foldables, traversables, and functions into a more composable form. Lenses are a generalized notion of a 'getter and setter', but the package goes a lot deeper.
17:41:13 <Nereid> cieplak: what is it you actually want to do?
17:41:32 <byorgey> scp: seriously though, see https://github.com/ekmett/lens/wiki
17:41:34 <deus_rex> simpson: in my ghci, 'let myElem = (any . (==))' gives a function with type () -> [()] -> Bool
17:41:44 <deus_rex> the lambdabot behavior is what i'd expect
17:41:46 <byorgey> maybe https://github.com/ekmett/lens/wiki/Overview  in particular
17:41:55 <geekosaur> deus_rex, that's the monomorphism restriction plus extended defaulting
17:42:09 <geekosaur> @where dmr
17:42:09 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
17:42:12 <edwardk> scp: the overview in https://github.com/ekmett/lens#lens-lenses-folds-and-traversals is probably better than the current wiki writeup
17:42:14 <monochrom> you can write: x1 = Attribute{a=Nothing, b=Nothing, c=Nothing, d=Nothin}; x2 = x1{a=Just "hi"}; x3 = x2{b=Just "hello"}. but this is still not recursion.
17:42:15 <simpson> Yeah, definitely the DMR.
17:42:46 <cieplak> Nereid: My list of attributes is very long, and I would like to have a function that creates a default list of attributes, without having to copy and paste Nothing a hundred times
17:42:47 <edwardk> oh wait, i made that the wiki writeup ;)
17:43:06 <Eduard_Munteanu> cieplak: create a default attribute and modify it.
17:43:36 <Eduard_Munteanu> Oh, you want to avoid doing that at all.
17:44:29 <cieplak> My problem is that Attributes   :: Maybe String -> Maybe String -> Maybe String -> Attributes
17:44:32 <Eduard_Munteanu> Hrm, perhaps a datatype isn't what you want. Maybe a Map?
17:44:34 <monochrom> use TH for the default, if it's really a hundred Nothing's. but I doubt it
17:44:41 <cieplak> Attributes   :: Maybe String -> Maybe String -> Maybe String -> Attributes
17:45:18 <Nereid> data AttributeKey = X | Y | X; Attributes :: AttributeKey -> Maybe String
17:45:18 <Nereid> ?
17:45:23 <Nereid> X | Y | Z heh.
17:45:33 <scp> edwardk: thanks =]
17:45:41 <Nereid> or Map AttributeKey String or ....
17:45:58 <edwardk> scp: but, yes, it is really a mind control device.
17:47:54 <cieplak> Suppose I have a function that takes several parameters. I want to create a higher order function that recursively partially applies the arguments and passes the partially applied function back to the higher ordered function.
17:48:16 <cieplak> until the function has been fully applied
17:48:35 <Nereid> I don't think that's possible.
17:48:42 <cieplak> the problem is that the partially applied function has a different type signature at each step of the recursion
17:48:46 <Nereid> exactly.
17:50:31 <stepkut> sclv: what's up?
17:50:50 <sclv> nevermind, got it answered in #happstack
17:51:08 <sclv> it was a pretty basic question
17:51:32 <sclv> or in #happs, even
17:51:47 <Vyn> byorgey: Still here?
17:51:53 <johnw> cieplak: can you use a list to represent the arguments?
17:51:59 <Nereid> hmm
17:52:06 <Nereid> I wonder if you can do something with Data.Data
17:52:31 <johnw> also, shelly uses a "trick" for presenting variadic functions to the user
17:52:39 <cieplak> johnw: [x,y,z] -> f x y z
17:52:42 <johnw> see it's "cmd" function, which ostensibly takes a variable number of arguments
17:53:07 <sclv> text.printf does it too
17:53:08 <cieplak> the problem is that my data constructor takes separate arguments
17:53:37 <johnw> ok, so now you're adding in new requirements
17:53:46 <johnw> how about showing an example of how you want to use it?
17:54:21 <cieplak> johnw:
17:54:22 <cieplak> data Attributes = Attributes { a :: Maybe String                              , b :: Maybe String                              , c :: Maybe String }                  deriving (Show, Eq)  defaultAttributes = Attributes Nothing Nothing Nothing
17:54:25 <Vyn> byorgey: Finished that program I was working on that day, take a look if you want: http://codepad.org/DFyanJfe Thanks again :)
17:54:30 * Vyn away
17:54:53 <sclv> cieplak: ok, that's a nice data constructor. what do you want to do with it?
17:55:01 <johnw> cieplak: hpaste.org, if you would
17:55:07 <cieplak> for the defaultAttributes value, I would like to apply Nothing three times without having to write Nothing three times
17:55:13 <cieplak> ok
17:55:31 <johnw> I wonder if you want something like Data.Default
17:55:37 <johnw> but you're still going to have to write *something* three times
17:55:38 <hpaste> cieplak pasted “example” at http://hpaste.org/78255
17:55:52 <cieplak> oh thats cool
17:56:19 <johnw> also, Data.Typeable might be able to let you generate that constructor
17:56:29 <johnw> i haven't used it yet for that, though, so I'm not 100% sure
17:56:35 <johnw> I know TH could do it, but that's likely overkill here
17:56:49 <cieplak> my first inclination was defaultAttributes = Attributes $ replicate 3 Nothing
17:57:04 <cieplak> but that passes in a list
17:57:07 <sclv> you can write this with typeclasses, but it is sort of painful
17:57:21 <sclv> so unless you have a *lot* of default attributes, it is probably not worth it
17:57:35 <johnw> cieplak: map ($) Attributes (replicate 3 Nothing)
17:57:44 <johnw> err, foldr
17:58:15 <sclv> that shoudn't work
17:58:20 <sclv> too polymorphic
17:58:33 <johnw> hm
17:58:34 <Nereid> johnw: nice try ;)
17:58:44 <sclv> it would work in scheme :-P
17:58:49 <cieplak> haha
17:59:01 <johnw> yeah, in Lisp I'd just use `apply'
17:59:45 * shachaf finds foldr ($) x fs rather more confusing than foldr (.) id fs x
17:59:50 <shachaf> Maybe I shouldn't.
18:00:03 <liyang> @pl \ x -> f x x x
18:00:03 <lambdabot> join (join f)
18:00:06 <sclv> class CanApplyToNothing a b | a -> b where appToNothing :: a -> b; instance CanApplyToNothing b => canApplyToNothing (Maybe a -> b) b where appToNothing f = appToNothing $ f Nothing, etc.
18:00:06 <johnw> shachaf: but foldr (.) won't apply n arguments
18:00:15 <sclv> then you write an instance for each of your base cases
18:00:18 <Nereid> shachaf: you should because the thing on the left doesn't typecheck
18:00:21 <sclv> (Attribute, etc)
18:00:37 <Nereid> sclv: won't work
18:00:47 <liyang> > join (join Attribute) Nothing
18:00:48 <sclv> why not?
18:00:49 <lambdabot>   Not in scope: data constructor `Attribute'
18:00:57 <Nereid> you'll still have to write appToNothing three times
18:00:58 <sclv> i've done essentially that a zillion times
18:01:01 <sclv> no you don't
18:01:07 <sclv> appToNothing calls itself recursively
18:01:10 <Nereid> hmm
18:01:13 <sclv> and when you hit the base case its just id
18:01:38 <Nereid> hmmm
18:01:58 <sclv> i'm not guaranteeing the above code is perfect -- its off the top of my head, but the idea is sound.
18:02:12 <sclv> its just a bunch of work unless you really need it.
18:02:48 <sclv> and the "real" base case is just something that doesn't have a function arrow
18:03:12 <sclv> but you can't express that in normal haskell without oleg's typeCast, so I never do that
18:03:23 <shachaf> Nereid: ?
18:03:34 <shachaf> > foldr ($) 5 [(+1),(*2)]
18:03:35 <lambdabot>   11
18:03:38 <shachaf> > foldr (.) id [(+1),(*2)] 5
18:03:40 <lambdabot>   11
18:03:55 <cieplak> I don't want to have to write Nothing a hundred times.  I could use a dictionary, but I want to use haskell's type safety on my data type.
18:04:11 <johnw> shachaf: now apply a n-ray function to a list of n args
18:04:13 <cieplak> I'm guessing template haskell is my best bet
18:04:22 <sclv> cieplak: my suggestion works just fine
18:04:27 <johnw> rather than 1 arg to a list of functions
18:04:32 <sclv> if its like a hundered Nothings then its worth it
18:05:01 <shachaf> johnw: ?
18:05:14 <Nereid> hmm
18:05:15 <Nereid> it works
18:05:39 <Nereid> but seems like I need Flexible+UndecidableInstances
18:05:41 <sclv> of course it does, i wrote it :-P
18:05:57 <johnw> shachaf: your folds are the inverse of the problem being described
18:05:59 <sclv> both are sound extensions
18:06:19 <johnw> if f :: a -> a -> a -> a, he wants foldl ($) f [10, 20, 30]
18:06:52 <Nereid> oh yes I mean foldl ($) doesn't typecheck.
18:06:53 <johnw> i.e., ((f 10) 20) 30, but at each step the type signature of the accumulator changes
18:07:44 <shachaf> johnw: That's not fold[lr] ($)
18:07:53 <johnw> no?
18:07:55 <sclv> johnw: you can do it with hlists, but ick
18:12:45 <Nereid> sclv: you could generalize that to work on any constructor with Default arguments
18:12:47 <cieplak> sclv: I don't quite follow your class CanApplyToNothing
18:12:52 <johnw> stumbled on this by accident: http://common-lisp.net/project/cl-monad-macros/monad-macros.htm
18:13:16 <sclv> yeah, it should work with any default argument constructor, sure...
18:13:28 <Nereid> and then it's probably useful enough to be put in a library for everyone to use?
18:13:34 <sclv> i guess it could be packaged up and added to data default
18:13:38 <Nereid> yeah
18:13:47 <sclv> if you want to put it somewhere, go right ahead :-)
18:14:02 <sclv> cieplak: what don't you follow
18:14:50 <sclv> its a class with one method. that method invokes itself recursively. and if it is invoked on something that still has a function arrow in the type, then it applys it to Nothing and reinvokes
18:15:05 <sclv> and if it is invoked on a "base case" then it just stops
18:15:10 <johnw> "fill every argument position with Nothing"
18:15:20 <cieplak> oh wow that's pretty neat
18:15:34 <sclv> I didn't add that last instance -- instance CanApplyToNothing Attribute Attribute where canApplyToNothing x = x
18:16:41 <Nereid> and it should be generalized to replace Nothing with def.
18:16:41 <Nereid> :p
18:17:12 <sclv> using typeclasses for induction on the function arrow is a pretty powerful technique, but very underappreciated. i know of maybe two libraries (outside of my own) that use it.
18:18:23 <Nereid> seems like you still have to write an instance for each type that uses it.
18:18:58 <Nereid> anyway, that's cool.
18:19:05 <johnw> yes, quite cool
18:27:09 * hackagebot HLearn-distributions 0.0.1.2 - Distributions for use with the HLearn library  http://hackage.haskell.org/package/HLearn-distributions-0.0.1.2 (MikeIzbicki)
18:28:37 <cieplak> Thank you all for your help.  This is such a great community.
18:28:58 <johnw> we just insist on types, but yeah ;)
18:36:38 <startling> in general, if Monad m => M m is a monad, Functor f => M f is a Functor. Is this true of Applicative f => M f? It doesn't seem like it.
18:37:11 <johnw> every monad can also be an applicative
18:37:35 <Nereid> > set _1 "hello" (undefined, "world")
18:37:37 <lambdabot>   ("hello","world")
18:37:42 <startling> johnw, that's unelated.
18:37:48 <johnw> then i didn't understand your question
18:39:06 <Nereid> startling: every Applicative is a Functor, but I don't understand the question.
18:39:56 <dmwit> startling: What is M?
18:40:29 <johnw> and what does "this" mean in your sentence?
18:40:39 <startling> given that I have a valid instance Monad m => Monad (M m), there are simple trivial instances of Functor and Applicative using liftM and ap. On the other hand, it seems like you can always write the stronger "instance Functor f => Functor (M f)". It doesn't, however, seem like you can write an "instance Applicative f => Applicative (M f)".
18:41:01 <startling> dmwit, a weird take on StateT.
18:41:20 <Nereid> startling: oh.
18:41:24 <Nereid> you can't even write the Functor instance though
18:41:37 <Nereid> given just the Monad instance
18:41:58 <Nereid> at least, not in the obvious way
18:42:06 <dmwit> I doubt very much you can write instance Functor f => Functor (M f) without knowing the structure of M.
18:42:09 <Nereid> I wonder if there's a trick that lets you do it though
18:42:15 <Nereid> going via the free monad or something
18:42:30 <dmwit> So I conclude that you're asking about a particular M, but not telling us what that M is. That hardly seems fair to us.
18:42:31 <startling> e.g. StateT has Functor m => Functor (StateT s m) and Monad m => Monad (StateT s m) but their Applicative instance is (Functor m, Monad m) => Applicative (StateT s m).
18:42:52 <Nereid> well sure.
18:43:05 <Nereid> that's a choice.
18:43:15 <startling> dmwit: it's essentially StateT; I'm not asking for a solution per se, just if anyone else has noticed this pattern.
18:43:18 <Nereid> they didn't have to do it that way.
18:43:20 <johnw> you need fmap and >>=, don't you?
18:43:37 <dmwit> ?src Applicative
18:43:37 <lambdabot> class Functor f => Applicative f where
18:43:37 <lambdabot>     pure  :: a -> f a
18:43:37 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
18:43:39 <johnw> isn't that why you need both Functor and Monad for that Applicative instance?
18:44:00 <startling> :t ap
18:44:01 <lambdabot> Monad m => m (a -> b) -> m a -> m b
18:44:12 <johnw> ah, i keep forgetting about pa, sorry
18:44:13 <Nereid> or maybe they do need it.
18:44:17 <startling> it's weird that they have the Functor restraint, though.
18:44:21 <startling> *constraint
18:44:28 <Nereid> is it?
18:44:34 <Nereid> a lot of times, fmap is cheaper than liftM
18:45:59 <Nereid> I don't know, I guess the exercise is
18:46:11 <Nereid> "try to write an instance Applicative f => Applicative (StateT s f)
18:46:15 <startling> anyway, is there a way to write Applicative for StateT given that the transformed type has Applicative?
18:46:19 <startling> Nereid: heh, yeah
18:46:39 <Nereid> maybe something goes wrong, I don't konw
18:49:59 <dmwit> Something does go wrong, yes.
18:50:32 <dmwit> ...errr, hm
18:51:20 <dmwit> Right, yes. You need to feed the state from the "function" computation forward into the "argument" computation, and that's monadic.
18:51:43 <startling> ahh, yeah, that makes sense
18:51:47 <dmwit> You've got, roughly: (s -> m (a -> b, s)) -> (s -> m (a, s)) -> (s -> m (b, s))
18:53:20 <dmwit> In the "s -> m (a, s)" bit, the second "s" will eventually be substituted to "m (a -> b, s)" with Applicative munging, giving you "s -> m (a, m (a -> b, s))"
18:53:40 <dmwit> and now it's clear you have a "computation within a computation" that you need to flatten -- just what you need Monad to do
18:54:37 <johnw> byorgey: any chance your lectures could be video-taped?
18:55:35 <startling> dmwit: yeah, neat. thanks a bunch.
18:57:06 <xunatai> thank god for haskell's "Perhaps you meant..."
18:57:21 <startling> oh, I see why they have the (Functor m, Monad m) -- you need the Functor constraint because Applicative is a superclass of Functor.
18:58:41 <startling> so much could be made easier with a Functor/Applicative/Monad hierarchy. :(
18:58:46 <Sonarpulse> does anybody know what CnCLib does with user-creaed sum types?
18:58:54 <Sonarpulse> *CmdLib
18:58:55 <johnw> startling: i'm all for that
18:59:27 <startling> johnw: you should leave haskell for idris!
18:59:34 <Sonarpulse> I am deriving read and show, but it refuses to read anything logical i can think of
18:59:39 <johnw> startling: why?
18:59:51 <Sonarpulse> it does compile though
19:00:01 <johnw> i don't like that idris is eager
19:00:05 <Sonarpulse> code is at github.com/Sonarpulse/CnC-Red-Alert
19:00:22 <startling> johnw, it has a Functor/Applicative/Monad hierarchy! (I wrote it)
19:04:46 <rcl> Hi - I'm using ghc on X86 64bit environment and I want to compile haskell and output .o that are ARM v7 arch. Is this possible?
19:06:16 <Sonarpulse> I just looked up cross-compiling: not currently possible
19:06:30 <Sonarpulse> you may be able to build ghc on your arm device though
19:06:52 <Sonarpulse> and there is a chance what I saw was out of date, becuase in the comments people were saying they had made patches
19:09:01 <rcl> Sonarpulse: thanks for looking, I found a lot of fairly conflicting information; is it possible to achieve this in some other way?  (I saw something about compiling haskell with the output of C code, but I assume there's some kind of runtime still?)
19:09:15 <Sonarpulse> the run time is also C
19:09:26 <Sonarpulse> problem is I think ghc has moved towards C--
19:09:26 <rcl> Sonarpulse: how could I achieve that?
19:09:44 <Sonarpulse> I tried -fvia-c for unrelated reasons
19:09:56 <Sonarpulse> and ghc said that was depricated and no longer had any effect
19:10:10 <Sonarpulse> I think it can also do llvm bytecode
19:10:19 <Sonarpulse> can you cross compile clang for android?
19:10:45 <rcl> I'm doing iOS so yeah I'm already using LLVM
19:11:31 <Sonarpulse> oh, well you can probabl fine lots of stuff
19:11:37 <Sonarpulse> just forget arm and google haskell iphone
19:12:07 <Sonarpulse> lot's of "niche" language types like to try iphone because apples "C only" rule is so insulting
19:12:16 <Sonarpulse> it a challange basically
19:13:34 <rcl> Sonarpulse: you'd think there's lots of stuff but it all seems broken or out of date etc
19:14:37 <Sonarpulse> well, faild attempts then
19:14:53 <lispy> probably the only sane way, at the moment, to generate an iOS app with Haskell is to write in a DSL and generate code
19:15:14 <Sonarpulse> is there any android with exact same flavor of arm?
19:15:33 <lispy> I...have no idea
19:15:48 <lispy> I mostly ignore development on those platforms.
19:16:44 <Sonarpulse> eh, if you are jailbroken there is a "ghc-iphone" maybe
19:16:46 <rcl> It's all the same ARM flavors
19:17:06 <rcl> What about JHC I see they can cross compile to it but I see a lot of negative stuff about JHC it seems
19:17:08 <Sonarpulse> well you can try compiling on an android or something
19:17:28 <Sonarpulse> and if you get a really raw, self-contained binary you  can use that
19:17:29 <lispy> rcl: JHC is one man's attempt to learn Haskell by writing a compiler for it in it.
19:17:39 <lispy> rcl: It's not battle hardened, but it can do some stuff
19:17:55 <Sonarpulse> I have done PE to ELF conversions that kinda worked
19:17:57 <Sonarpulse> on x86
19:18:24 <Sonarpulse> I would jailbreak and try that
19:18:31 <Sonarpulse> if nothing else you can try porting it then
19:18:50 <Sonarpulse> Cydia gives you  a pretty good UNIX with debian packages even
19:20:22 <Sonarpulse> does anybody know the answer to my question from earlier?
19:20:56 <Sonarpulse> about sum types and System.Console.CmdLib
19:23:00 <lispy> Sonarpulse: I don't. I just use getopt whenever I need a cmdline parser
19:23:16 <mdszy> I feel accomplished. I finally managed to write a simple (and very ugly) parser for todo.txt files in Haskell.
19:23:20 <Sonarpulse> I am doing a fairly complicated "modal" CLI i just learend it's called
19:23:42 <Sonarpulse> CmdLib seems to work very nicely for 90%
19:23:56 <Sonarpulse> but it has potholes and seems to be sort of abandoned
19:24:27 <Sonarpulse> the documentation is very good in some bits, but looks like one person's stream of concious -- it hasn
19:24:30 <lispy> Sonarpulse: what is a 'modal' CLI? does that mean you have different top level commands?
19:24:35 <Sonarpulse> yeah
19:24:49 <Sonarpulse> CmdLib and CmdArgs both use the term, so I guess it's a thing
19:24:56 <lispy> Darcs has a modal CLI and it uses (or at least used initially) getopts for that
19:25:16 <Sonarpulse> Though my guess is it's a colosal mess
19:25:30 <lispy> but in darcs, it's detected by looking at the first command specified and switching the set of options based on that
19:25:35 <donri> optparse-applicative is nice, it has "subparser" for commands
19:26:03 <Sonarpulse> mine is just shy of 100 lines, and most of that is a bunch of record types
19:26:22 <Sonarpulse> and it makes really nice --helpS right out of the box
19:26:51 <Sonarpulse> perhaps this a a general parser issue that CmdLib just doesn't work around
19:27:03 <Sonarpulse> I can read my sumtype fine from ghci
19:27:31 <Sonarpulse> but CmdLib seems to work of deriving Typable and Data for stuff
19:27:45 <Sonarpulse> what exactly are those type classes?
19:29:14 <lispy> they work together to give you introspection
19:29:36 <shachaf> @google what exactly are those type classes? Typable Data
19:29:38 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
19:29:38 <lambdabot> Title: Data.Typeable
19:29:56 <lispy> Sonarpulse: http://stackoverflow.com/questions/6600380/what-is-haskells-data-typeable
19:30:24 <donri> lmgtfy has become "let me paste your exact question into google for you"
19:30:24 <Sonarpulse> oh interesting
19:31:15 <Sonarpulse> well, my sum type is sort of a manual "typable" i guess
19:31:34 <Sonarpulse> I import a number of similar types
19:31:36 <paul_> @pl \s->putStr s>>print s
19:31:36 <lambdabot> liftM2 (>>) putStr print
19:31:54 <donri> it's easier to help you if you paste code and ask a specific question
19:31:58 <donri> @hpaste
19:31:58 <lambdabot> Haskell pastebin: http://hpaste.org/
19:32:04 <Sonarpulse> and then use my sum type with a dispatcher on the equivalent functions for each of them
19:32:19 <paul_> @pl \s->f s (g s)
19:32:19 <lambdabot> ap f g
19:32:31 <Sonarpulse> well the code is here https://github.com/Sonarpulse/CnC-Red-Alert
19:33:08 <Sonarpulse> the problem is that CmdLib doesn't seem to be able to resolve any argument into the sum type as I have set it up
19:33:45 <Sonarpulse> but perhaps I am thinking there is a way to incorperate Typable and Data into my haskell interface so I don't even need the sum type
19:33:56 <paul_> shortest oneliner that prints itself: main=(\s->putStr s>>print s)"main=(\\s->putStr s>>print s)"
19:34:14 <paul_> liftM2(>>) will only make it longer
19:34:19 <Sonarpulse> oh sorry, paul_ I didn't realize those were directly at me
19:34:39 <Sonarpulse> I am not sure to what extent I can mix in such "manual" parsing with CmdLib
19:34:46 <Sonarpulse> but it's worth a try
19:34:57 <paul_> Sonarpulse, I just joined, and it was not a message to you
19:35:35 <Sonarpulse> oh well then doubly my bad
19:35:45 <Sonarpulse> i saw reads and prints and it sounded like my problem
19:36:07 <donri> that's a lot of code that isn't relevant to your question
19:36:25 <donri> please paste a short sample to get your question across
19:39:01 <Sonarpulse> Sorry I just figured that was easier cause it gives more context
19:39:10 <Sonarpulse> and the problem is split across two modules
19:39:46 <Sonarpulse> I have a sum type CnCGAME = TiberianDawn | RedAlert | ....
19:40:10 <Sonarpulse> in my list of record type of arguments I have mixType :: CnCGame
19:41:25 <Sonarpulse> the typing for CmdLib is a bit crazy but the normal way of getting an element is using the record-type accessory what amounts to the arguments pre-parsed into the proper record type (which is does do for other fields)
19:43:07 <Sonarpulse> Here's a real concrete question: is there a way to test Main :: IO () like functions in the REPL?
19:43:31 <Sonarpulse> It technically takes no arg's so I can't pass it a string
19:43:54 <otters> if you mean getArgs, no
19:43:56 <shachaf> Sonarpulse: Main
19:43:58 <shachaf> Er.
19:43:59 <shachaf> :main
19:44:06 <otters> wait
19:44:08 <otters> really?
19:44:22 <shachaf> Yep.
19:44:27 <otters> omfg
19:44:30 <otters> so much time wasted
19:45:02 <shachaf> Also, main isn't a function.
19:45:25 <Sonarpulse> yeah, I am not sure what to call monad things like it
19:45:45 <Sonarpulse> I mean it's since it's pure, lazy, and curried everything is :D
19:45:50 <Nereid> "IO action"?
19:46:31 <shachaf> Sonarpulse: What do you call [1,2,3]?
19:46:33 <Nereid> whoa I didn't know about :main, cool
19:47:02 <shachaf> See also withArgs
19:47:11 <rcl> Sonarpulse: thanks for your assistance earlier, one of the projects did pick back up lately and as of earlier this month it seems to all be working just fyi
19:47:15 <Nereid> @hoogle withArgs
19:47:15 <lambdabot> System.Environment withArgs :: [String] -> IO a -> IO a
19:47:21 <Nereid> handy
19:51:08 <Sonarpulse> shachaf "a thunk that produces...."
19:51:47 <shachaf> Sonarpulse: Huh?
19:51:53 <shachaf> What do thunks have to do with it?
19:52:22 <Sonarpulse> a joking responce to you question about what do I call the linked list of integers
19:55:30 <Sonarpulse> ok, exacty same behavior with :main not surprisingly
20:01:01 <Sonarpulse> rcl: no problem
20:01:05 <Sonarpulse> glad I could help
20:01:17 <scooty-puff> can anyone think of either a good name for this, or something that exists that already does it? (a -> Maybe a) -> (a -> Maybe a) -> a -> Maybe a
20:01:55 <Nereid> what does it do
20:01:57 <scooty-puff> the idea being that the both if possible, or just one, of the functions is applied
20:02:09 <lispy> ?hoogle (a -> Maybe a) -> (a -> Maybe a) -> a -> Maybe a
20:02:09 <lambdabot> Data.Generics.Aliases extMp :: (MonadPlus m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
20:02:10 <lambdabot> Data.Generics.Aliases extM :: (Monad m, Typeable a, Typeable b) => (a -> m a) -> (b -> m b) -> a -> m a
20:02:10 <lambdabot> Control.Monad (>=>) :: Monad m => (a -> m b) -> (b -> m c) -> (a -> m c)
20:02:11 <Nereid> is it >=> ?
20:02:16 <shachaf> tug f . tug g?
20:02:33 <hpaste> scooty-puff pasted “Combine Maybe functions” at http://hpaste.org/78260
20:02:49 <shachaf> Oh, not quite.
20:02:54 <lispy> > Just >=> Just $ 1
20:02:56 <lambdabot>   Just 1
20:03:02 <lispy> > Just >=> Nothing $ 1
20:03:04 <lambdabot>   Couldn't match expected type `b0 -> Data.Maybe.Maybe c0'
20:03:04 <lambdabot>              with ...
20:03:16 <Nereid> > Just >=> const Nothing $ 1
20:03:17 <scooty-puff> Just >=> const Nothing $ 1
20:03:18 <lambdabot>   Nothing
20:03:36 <geekosaur> @pl \f a = maybe a f a
20:03:36 <lambdabot> (line 1, column 6):
20:03:36 <lambdabot> unexpected "="
20:03:36 <lambdabot> expecting pattern or "->"
20:03:40 <scooty-puff> that being the problem (and why its a appears on both sides of the arrow)
20:03:42 <geekosaur> @pl \f a -> maybe a f a
20:03:42 <lambdabot> join . flip maybe
20:03:49 <Nereid> :t \f a -> maybe a f a
20:03:50 <lambdabot> (a -> Maybe a) -> Maybe a -> Maybe a
20:03:58 <geekosaur> hm, right
20:04:04 <Sonarpulse> I made a "maybe to either" function for my project
20:04:05 <geekosaur> wrong thing
20:04:09 <Sonarpulse> I guess that's sort of similar
20:04:24 <Sonarpulse> if just, it updates to b, if not it stays at a
20:04:27 <Nereid> :t \x -> maybe (Left x) Right
20:04:28 <lambdabot> a -> Maybe b -> Either a b
20:04:32 <Sonarpulse> you could use that twice for the same effect
20:05:14 <lispy> scooty-puff: Does the second computation depend on the first other than checking for isJust?
20:05:32 <lispy> scooty-puff: catMaybes may work here...
20:05:36 <scooty-puff> yes, if Just a, that is fed to the second function
20:05:42 <scooty-puff> otherwise, the input is
20:06:11 <scooty-puff> though if a lazy pattern match, could maybe get catMaybes to work
20:06:32 <lispy> I'm still not understanding the specification
20:06:49 <scooty-puff> http://hpaste.org/78260
20:06:49 <Nereid> > Nothing <|> Just 1
20:06:50 <donri> Sonarpulse: Either () a is isomorphic to Maybe, is that what you did?
20:06:51 <Nereid> > Just 2 <|> Just 1
20:06:51 <lambdabot>   Just 1
20:06:52 <lambdabot>   Just 2
20:07:05 <donri> seems more useful to downgrade eithers to maybes
20:07:13 <donri> the errors package provides that
20:07:26 <scooty-puff> if it helps,
20:07:38 <Nereid> eh
20:07:53 <scooty-puff> i'm using it with a set of functions that change a Domain, and have return type of Maybe Domain
20:07:55 <Sonarpulse> donri huh?
20:07:58 <donri> Sonarpulse: http://hackage.haskell.org/packages/archive/errors/1.3.1/doc/html/Control-Error-Util.html#g:1
20:07:59 <scooty-puff> Just if it was changed, Nothing otherwise
20:08:10 <scooty-puff> and i need to combine two things that change a Domain
20:08:15 <donri> Sonarpulse: that has maybe to/from either
20:08:29 <lispy> scooty-puff: I think this is something new and not a standard maybe combinator
20:08:34 <geekosaur> @pl \f a -> maybe id f a
20:08:35 <lambdabot> maybe id
20:08:41 <geekosaur> durr
20:08:43 <scooty-puff> lispy: k
20:08:47 <geekosaur> :t maybe id f a
20:08:48 <lambdabot>     Couldn't match expected type `Maybe a0' with actual type `Expr'
20:08:48 <lambdabot>     In the third argument of `maybe', namely `a'
20:08:48 <lambdabot>     In the expression: maybe id f a
20:08:49 <lispy> scooty-puff: it's like (>>=) but has a 'backtracking' sort of nature to it
20:08:53 <Nereid> :t \f g a -> (f a <|> Just a) >>= g
20:08:53 <Nereid> what happened.
20:08:54 <lambdabot> (a -> Maybe a) -> (a -> Maybe b) -> a -> Maybe b
20:08:56 <Sonarpulse> ah, what I did is closest to note
20:08:58 <geekosaur> :t maybe id f
20:08:59 <lambdabot> (Show a, Show a1, FromExpr a1) => Maybe a -> a1 -> a1
20:09:00 <Nereid> hmm laggy.
20:09:00 <scooty-puff> the closest i could think of (name is prob not right)
20:09:06 <scooty-puff> is a Monoid EndoMaybe
20:09:08 <scooty-puff> or some such
20:09:12 <Sonarpulse> but there is no exact equivalent, I checked with hoogle before i made it
20:09:19 <geekosaur> that seems not what I was looking for, sigh
20:09:24 <Nereid> \f g a -> (f a <|> Just a) >>= g  -- this does what you want, but as for a name...
20:09:27 <hpaste> neworder pasted “Split function” at http://hpaste.org/78261
20:09:28 <geekosaur> oh wait
20:09:43 <neworder> I have this function called split
20:09:53 <scooty-puff> Nereid: that is it
20:09:56 <neworder> I don't understand the structure of it
20:10:04 <geekosaur> (I think I amy be too tired for this, I know what I'm looking for but not seeing how to get there.  and ghci is dropping core locally... grh)
20:10:08 <neworder> I don't really want to understand what the code does for now
20:10:12 <lispy> Nereid: nice, that's a really succinct way to specify it
20:10:21 <Sonarpulse> maybeToEither f a = case f a of { Nothing -> Right a; Just b -> left b }
20:10:32 <neworder> what does this part mean? (ll,rr) = split l
20:10:55 <Nereid> neworder: split l is a tuple, so it's pattern matching
20:10:59 <lispy> neworder: split l returns a tuple and we're naming ll to the first part and rr to the second part
20:11:27 <geekosaur> :t maybe id ($) f
20:11:28 <lambdabot> FromExpr (Maybe (a -> a)) => a -> a
20:11:30 <lispy> neworder: knid of like this: let ll = fst (split l); rr = snd (split l)
20:11:48 <Nereid> :t maybe id ($) ?f
20:11:50 <lambdabot> (?f::Maybe (a -> a)) => a -> a
20:11:53 <donri> Sonarpulse: o_O that looks odd
20:11:55 <imeredith> Sonarpulse: isnt Nothing usually left when going maybe to either?
20:12:12 <imeredith> (at least thats what we do in scalaland)
20:12:15 <Nereid> :t \a -> maybe (Left a) Right
20:12:16 <lambdabot> a -> Maybe b -> Either a b
20:12:32 <donri> note :: a -> Maybe b -> Either a b -- as i linked before, seems rather more straight-forward
20:12:33 <neworder> hmm
20:12:40 <neworder> what is rr then
20:12:53 <neworder> how come it isn't defined and it can be used?
20:13:56 <Nereid> lambdabot seems slow today.
20:13:56 <Nereid> either that or my connection is being weird.
20:13:56 <geekosaur> was slow for me as well
20:13:56 <geekosaur> overloaded or otherwise unhappy hosting provider?  have had some other things I know to be hosted behaving oddly for me
20:13:58 <Nereid> or is it freenode?
20:14:22 <Nereid> neworder: it is defined.
20:14:22 <Nereid> on line 11.
20:14:27 <Sonarpulse> I have no idea what the convetion is
20:14:49 * liyang has no idea what convetion is either.
20:14:57 <Sonarpulse> It just seemed like right was more "foward" with english lrft-to-right reading habits
20:15:34 <Nereid> Sonarpulse: one of the common uses of Either is to represent a computation that possibly failed, in which case you have an error message
20:15:51 <Nereid> or whatever. in any case, you want easier access to the actual value
20:15:58 <donri> the mnemonic is that Right is the "right" value and Left is what you might be "left" with :)
20:16:04 <Nereid> so that you have functor/monad/whatever instances for Either e
20:16:14 <Sonarpulse> that's better
20:16:46 <Nereid> and they'd be useful, because usually you want to perform computations on the value rather than the error message.
20:17:05 <Nereid> also, note that Either () is isomorphic to Maybe
20:17:12 <donri> note a = maybe (Left a) Right -- even the definition is straight-forward! :)
20:17:25 <scooty-puff> Nereid: the name i'm going with is a think appendBinds
20:17:29 <lispy> Nereid: I've been having issues with it too
20:17:31 <scooty-puff> appendBinds f g a = (f a `mplus` return a) >>= g (based on yours)
20:18:05 <Sonarpulse> ok, I am fixing mine
20:18:21 <donri> Sonarpulse: even better, use the errors package. good to have around anyway
20:18:21 <Nereid> ok sure, that works on any MonadPlus.
20:18:44 <Nereid> no comment on the name
20:18:48 <Sonarpulse> I don't use it for errors though
20:19:04 <Sonarpulse> I use it for "merging" two lists
20:19:15 <Sonarpulse> if things line up, I acutally merge them
20:19:22 <Sonarpulse> if they don't I append on the end
20:19:34 <neworder> ( \ (c,a) e ->  case c of   [] -> ([e],a)  _ -> if e*(head c) < 0     then ([e],a++[c])  else (c++[e],a))
20:19:42 <Sonarpulse> the function is maybe because it may fail
20:19:56 <neworder> this anonymous function takes in a tuple and another argument right?
20:19:58 <Sonarpulse> my maybeToEither is basically saying "failure is ok" :D
20:20:13 <Nereid> > (Left 1, Right 2) & both . traverseLeft +~ 3
20:20:15 <lambdabot>   Not in scope: `traverseLeft'
20:20:15 <lambdabot>  Perhaps you meant one of these:
20:20:15 <lambdabot>    `traverseO...
20:20:22 <Nereid> uh
20:20:33 <rwbarton> @type _left
20:20:34 <lambdabot> Applicative f => (a -> f b) -> Either a c -> f (Either b c)
20:20:35 <donri> i think it's _left now or something
20:20:43 <Nereid> > (Left 1, Right 2) & both . _left +~ 3
20:20:45 <lambdabot>   (Left 4,Right 2)
20:20:48 <johnw> donri: yes
20:21:17 <latermuse> do any of the haskell platforms install correctly on centos?
20:21:32 <Nereid> Sonarpulse: in any case, the convention is generally that a "successful" value is a Right
20:22:49 <donri> latermuse: http://dl.fedoraproject.org/pub/epel/6/x86_64/repoview/haskell-platform.html
20:23:25 <latermuse> thanks donri!
20:24:02 <donri> latermuse: if you didn't know already http://fedoraproject.org/wiki/EPEL
20:24:36 <latermuse> wonderful, thanks
20:24:51 <donri> that's for centos6, no platform for 5
20:25:01 <latermuse> thanks
20:25:20 <Sonarpulse> fixing my code as we speek to work like that
20:25:33 <Sonarpulse> I am surprised I didn't get a type error when I flipeed the sides though
20:25:48 <Sonarpulse> I guess i was using it with a -> a functions
20:26:32 <latermuse> > (Left 1, Right 2) & both . _left +~ (-3)
20:26:34 <lambdabot>   (Left (-2),Right 2)
20:26:39 <latermuse> :-D
20:26:42 <donri> Sonarpulse: what i don't get is why you have an "f" argument
20:26:59 <johnw> latermuse: http://justhub.org
20:27:02 <Sonarpulse> because the input is not a maybe
20:27:06 <Sonarpulse> I have a value
20:27:09 <johnw> has haskell platform for various releases of CentOS
20:27:20 <Sonarpulse> I have a function that "Maybe" will work with it
20:27:43 <donri> Sonarpulse: but with 'note' you can do, note (f a), instead of maybeToEither f a
20:27:48 <Sonarpulse> If so, I take (f a), if not I take (a), but I use the Either to keep track of what i did
20:27:51 <latermuse> thanks johnw, checking it out now
20:27:57 <Sonarpulse> yeah, note is very close
20:28:05 <latermuse> why is there no official centos release on haskell.org?
20:28:09 <Sonarpulse> I might just make it a thin wrapper around instead
20:28:17 <donri> just seems really odd to pass in a function because it happens to be how you use it in some particular code
20:28:20 <johnw> latermuse: that's what I've been using, fwiw
20:29:34 <latermuse> it was easier to setup haskell on my raspberry pi than on my centos machine
20:29:38 <lispy> "John Hughes identified modularity as the single biggest blessing of functional programming. The obvious question is: how modular is the monadic interface? This really depends on you're definition of modularity. Let me be more specific. How can you combine two arbitrary monads? You can't. This is my greatest concern with monads. Once you choose your specific notion of computation, you have to stick to it through thick and thin."
20:29:38 <Sonarpulse> well, note isn't currently imported
20:29:45 <lispy> Interesting criticism that
20:30:39 <Sonarpulse> do you think it is worth importing note to shave ~20 characters off my function?
20:31:23 <Crockeo> The question I'd ask is if it's more elegant and more efficient.
20:31:31 <watermind> lispy:  :S
20:31:32 <Sonarpulse> hardly
20:31:41 <Crockeo> Then probably not worth it.
20:31:47 <donri> Sonarpulse: i think it's a useful package to have around, and reuse is good for more than shaving off characters. but you could just copy the definition, too.
20:31:57 <Sonarpulse> that is my thought
20:32:02 <Sonarpulse> which package is it again?
20:32:09 <donri> @hackage errors
20:32:09 <lambdabot> http://hackage.haskell.org/package/errors
20:32:11 <Sonarpulse> right now I am importing Data.Maybe and Data.Either
20:32:20 <Sonarpulse> oh note is there too?
20:32:32 <Sonarpulse> If i would no longer need one of those that would be ok
20:32:32 <watermind> lispy: that's part of the motivation for plotkin's algebraic effects I think
20:32:47 <Sonarpulse> Oh, and the other side of the story is I use it with partitionEither
20:32:48 <watermind> lispy: IIRC they can be combined
20:32:55 <donri> Sonarpulse: errors exports those modules plus "note" and more useful stuff under a single module Control.Error
20:33:01 <donri> so you could save some imports ;)
20:33:05 <Sonarpulse> ok
20:33:07 <Sonarpulse> that's good
20:33:45 <Nereid> I should get a raspberry pi.
20:33:45 <Crockeo> It seems like 99% of the questions in this IRC are about the libraries that come from Haskell.
20:33:47 <lispy> watermind: interesting
20:33:53 <lispy> attribute grammars sound interesting
20:34:01 <Crockeo> Probably because the base language is relatively easy to comprehend
20:34:11 <lispy> I wonder if they can be implemented as a DSL instead of a prepropcessor
20:34:21 <latermuse> crockeo: what counts as the base language?
20:34:28 <latermuse> crockeo: prelude?
20:34:34 <latermuse> crockeo: prelude is a library too though
20:34:38 <Nereid> no, not even prelude.
20:34:39 <Crockeo> latermuse: ... the interpreter?
20:34:42 <Crockeo> Prelude is just another library.
20:34:47 <Crockeo> (Or compiler)
20:35:04 <donri> Sonarpulse: also nice is that it hides evil things like fromJust so you don't use it by "accident"
20:35:09 <donri> > fromJust Nothing
20:35:10 <lambdabot>   *Exception: Maybe.fromJust: Nothing
20:35:30 <Nereid> there's a lot to the base language though.
20:35:30 <Nereid> ADTs, type classes, .....
20:35:30 <Nereid> :t fromMaybe Nothing
20:35:32 <lambdabot> Maybe (Maybe a) -> Maybe a
20:35:33 <Nereid> the most useful function in the world.
20:35:45 <Nereid> oh.
20:36:00 <Crockeo> I feel like I need to use Maybe more.
20:36:06 <Crockeo> Maybe seems incredibly helpful
20:36:19 <Nereid> :t fromMaybe
20:36:21 <lambdabot> a -> Maybe a -> a
20:36:24 <monochrom> "call me Maybe" :)
20:36:44 <slack1256> has anybody tried to compile haskell to BASIC
20:36:50 <slack1256> to make ti-89 programs
20:37:00 <donri> even better is when you can eliminate the need for a Maybe with a compile-time checked type
20:37:01 <slack1256> or is too mad scientist what I am saying?
20:37:14 <lispy> slack1256: I've seen the other way around (doing an embedded DSL that looks like BASIC in haskell)
20:37:31 <Crockeo> slack1256: Probably a little mad scientist but it can't hurt to mess around in it.
20:37:46 <slack1256> lispy: yeah, the BASIC library is cool, there is also a C-like one
20:37:47 <donri> http://augustss.blogspot.de/search/label/BASIC
20:38:21 <Crockeo> (Completely unrelated to Haskell, but I just got home from travelling for Thanksgiving.
20:38:28 <lispy> I wonder if you could use data-reify with that BASIC-in-Haskell library and generate actual BASIC but with all the powers of higher-order Haskell
20:38:30 <Crockeo> So happy to have my mechanical keyboard back.)
20:38:48 <monochrom> compiling haskell to basic, then to run on ti-89, seems impractical, very slow etc
20:38:52 <Nereid> donri: hahaha. :)
20:39:03 <Crockeo> monochrom: It may be impractical but it would be fun to try to execute.
20:39:25 <Crockeo> monochrom: It may be impractical but it would be fun to try to implement*.
20:39:42 <slack1256> or a subset of haskell
20:40:39 <slack1256> mmm but i can compile haskell code to the llvm IR
20:42:36 <lispy> slack1256: what about run-time support?
20:43:03 <lispy> Haskell (as I know it) has a large complicated RTS
20:43:19 <lispy> porting that tends to be one of the hardest parts of putting Haskell on exotic platforms
20:43:25 <stepkut> using template haskell is it possible to get the type of an expression?
20:43:42 <Sonarpulse> OK, one last question, is there a good built in function [FilePath -> [FilePath]
20:44:01 <lispy> Sonarpulse: look at the filepath package
20:44:02 <Sonarpulse> that recursively expands all directories into their contents untill only files remame?
20:44:04 <stepkut> Sonarpulse: needs more ]
20:44:04 <lispy> ?where filepath
20:44:04 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
20:44:46 <Sonarpulse> I earlier saw System.Directory
20:44:48 <lispy> Sonarpulse: I don't think that function exists or has the type you suggested (it needs IO)
20:44:52 <Sonarpulse> is that dpericated?
20:44:53 <Sonarpulse> ok
20:44:55 <Sonarpulse> IO is  fine
20:45:10 <Sonarpulse> I shouldn't have been so explicit with my type signiture
20:45:17 <Sonarpulse> I would have lifted it anyways
20:45:27 <lispy> System.Directory is still used, AFAIK, but I suggested filepath because that has all the combinators for combining filepaths
20:45:34 <slack1256> lispy: oh no. what I meant was compiling haskell code to BASIC code, not making executables, after all the TI-89 interprets the code
20:45:45 <startling> so I've got SomeT Maybe V; is there a way to map over the Maybe V in general?
20:45:52 <Nereid> ti-89 basic is slow as hell though :(
20:46:09 <johnw> lispy: I strongly recommend http://hackage.haskell.org/package/system-filepath
20:46:10 <slack1256> Nereid: is better than doing probability by hand
20:46:13 <Nereid> startling: what Maybe V?
20:46:14 <lispy> slack1256: well, what does a haskell thunk look like in ti-89 basic?
20:46:21 <johnw> and its partner package, system-fiolio
20:46:22 <johnw> fileio
20:46:48 <startling> siostiom-fiolio
20:46:53 <slack1256> lispy: touché
20:46:55 <johnw> hehe
20:46:56 <Nereid> I don't see any Maybe V.
20:47:07 <johnw> my fingers are very imprecise tonight
20:47:09 <lispy> johnw: why do I need this over the filepath package?
20:47:12 <startling> Nereid, are you trying to get the point across?
20:47:17 <startling> *a point, I guess
20:47:25 <johnw> lispy: Filesystem.Path is used by Shelly, and is based on Data.Text
20:47:28 <Nereid> (SomeT Maybe) V
20:47:46 <startling> sure
20:47:47 <Sonarpulse> hmm I don't actually see what I was looking for
20:47:59 <Nereid> I don't know what my point is.
20:48:02 <neworder> Why can
20:48:04 <startling> Nereid: a simple "no" would have done
20:48:12 <lispy> johnw: what is Shelly exactly?
20:48:22 <neworder> why can't I do this "let split1 = foldl ( \x -> x +1 ) 0"
20:48:24 <startling> I get now that it depends on the instance.
20:48:26 <johnw> lispy: a nice high-level library for doing shell-like things
20:48:31 <Sonarpulse> oh, lispy said he didn't think it would exist
20:48:38 <johnw> has good error handling and directory tracking
20:48:42 <Sonarpulse> not that he knew of something in specific with that type
20:48:51 <mauke> neworder: what would that do?
20:49:10 <monochrom> you are better off using haskell on a smartphone. http://xkcd.com/768/
20:49:16 <Sonarpulse> he is dead on about the IO part, it needs to read the filesystem to get it's job done
20:49:46 <neworder> mauke: "let foldtest= foldl ( \x -> x +1 ) 0"
20:49:51 <neworder> I wanted to do
20:49:53 <donri> johnw: only wish system-filepath would have the type safety of the pathtype package :(
20:49:57 <mauke> neworder: what would that do?
20:50:00 <neworder> foldtest [1,2,3,4]
20:50:27 <neworder> It will reduce the list
20:50:31 <mauke> neworder: what would that do?
20:50:47 <neworder> ohh
20:50:51 <neworder> wait
20:50:51 <johnw> donri: i bet it wouldn't be hard to add those types on top of FilePath, the key would be getting Shelly to use them
20:50:52 <neworder> haha
20:52:15 * hackagebot haskheap 0.1.1 - Haskell bindings to refheap.  http://hackage.haskell.org/package/haskheap-0.1.1 (AnthonyGrimes)
20:52:53 <lispy> johnw: interesting. I've been using a homegrown solution instead of shelly (I didn't write the current DSL) and it's nice to do shell scripting in Haskell. In the future, maybe I'll start with Shelly and build scripting DSLs on it.
20:53:12 <johnw> i use shelly quite a bit now, and once you get used to it, it's very nice
20:53:28 <johnw> it has well-chosen default behaviors, in my opinion, but it's easy to modify almost all of them
20:54:08 <lispy> the DSL i've been using orchestrates a bunch of slave machines for the purpose of multi-machine benchmarks. So it also has features for saving output of programs, logging stdout/stderr, and generating CSV
20:54:24 <Sonarpulse> well for starters isDirectory p = p == dropFileName p
20:54:24 <Sonarpulse>  
20:54:51 <monochrom> that may be wrong
20:55:09 <Sonarpulse> I hope not :)
20:56:18 <lispy> to really do things that are "correct" with the filesystem you have to consider that the fs is mutable and can be changed from under you. On Posix, the encoding (of pretty much everything including filenames) is not specified in general, and it's just a pain in the ass.
20:56:23 <lispy> In practice, it's not that bad.
20:56:48 <Sonarpulse> I just hope if you leave out the last / it won't screw up
20:56:50 <monochrom> that must be wrong. the type does not involve IO. if you don't do IO, you cannot know whether a pathname refers to a directory or not
20:57:03 <lispy> you can mostly assume utf-8 encoding or look in the environment. Windows has similar conventions
20:57:22 <Sonarpulse> well I start with it, then do better
20:57:32 <Sonarpulse> I am making an archiving tool
20:57:42 <Sonarpulse> so i hope the input is relatively static
20:57:59 <Sonarpulse> (archive as in normal tar usage, not daily backups)
20:58:00 <lispy> <shrug> even if you query the filesystem to know what type something is in the fs, it could change by the time you need it again
20:58:04 <latro`a> you can't really "add IO later" in haskell
20:58:23 <latro`a> which is occasionally annoying, actually
20:58:38 <Sonarpulse> I mean if you forgo do notation, it's a bit easier IMO
20:58:45 <Crockeo> latro`a: How do you mean?
20:58:47 <lispy> if you don't mind sacrificing correctness you can easily add it ;)
20:59:01 <Crockeo> Are you talking about having to plan your program around using IO?
20:59:18 <latro`a> more or less, yeah, though I was thinking more about being unable to make small additions
20:59:29 <latro`a> for example you can't really add a print inside a pure function
20:59:49 <Crockeo> latro`a: I quite like that.
20:59:56 <Crockeo> It keeps people from doing what they're not supposed to :P
20:59:57 <latro`a> it's a good thing overall
21:00:01 <latro`a> but occasionally annoying nonetheless
21:00:39 <Crockeo> I suppose so; though compared to C, which pretty much "gives you all you need to have to shoot yourself in the foot" Haskell is nice.
21:00:51 <donri> latro`a: Debug.Trace
21:00:57 <Crockeo> It's hard to learn, but that's because you can't do things as wrong as you can in imperative languages.
21:01:11 <Crockeo> For the most part.
21:01:16 <Crockeo> (AFAIK)
21:01:29 <latro`a> not quite the same, donri, but yes that's the equivalent
21:01:35 <lispy> Crockeo: you just reminded me of the Dennis Ritchie entry: http://james-iry.blogspot.com/2009/05/brief-incomplete-and-mostly-wrong.html
21:01:47 <monochrom> after you read this c++ code, you will wish that adding IO later were hard in c++ too. class ComplexNumber { public: ComplexNumber() { cout << "please enter the real part: "; cin >> realpart ...
21:01:54 <lispy> "1972 - Dennis Ritchie invents a powerful gun that shoots both forward and backward simultaneously. Not satisfied with the number of deaths and permanent maimings from that invention he invents C and Unix."
21:03:01 <monochrom> shooting both directions eliminates recoil :)
21:03:11 <Crockeo> lispy: Man, the hate on C; if done right it's a beautifully explicit language.
21:03:17 <Crockeo> Then again
21:03:28 <johnw> i don't mind C
21:03:28 <Crockeo> it's nearly impossible to 'do it right' and still get anything done.
21:03:46 <johnw> as long as it's the C that GHC translates my Haskell to
21:03:58 <monochrom> how many people are in the top 1% who are able to do it right? (rhetorical question)
21:04:00 <latermuse> c has its use, and will remain useful for a long time to come
21:04:17 <johnw> half of the people in the world have below average intelligence
21:04:43 <donri> "most people have average intelligence"
21:05:12 <Crockeo> johnw: I can only hope that I'm above average.
21:05:24 <johnw> i think the fact that you found this channel speaks in your favor
21:05:24 <latermuse> Haskell gets some resistance due to the complexity of using monads to control side effects. Wadler tries to appease critics by explaining that "a monad is a monoid in the category of endofunctors, what's the problem?"
21:05:29 <latermuse> XD
21:05:35 <Crockeo> johnw: :D
21:06:00 <Crockeo> And the fact that I can understand the merits of functional programming instead of just writing it off as 'too hard'.
21:06:11 <Sonarpulse> ah, in System.Directory doesDirectoryExist
21:06:15 <Sonarpulse> and it's an IO
21:06:21 <Sonarpulse> I guess the IO ones are in there
21:06:34 <Sonarpulse> whereas System.Filepath is all string based
21:06:50 <lispy> I don't want to program in C regularly, but C has its merits and I couldn't do my job without an intimate knowledge of C.
21:07:19 <lispy> But, with that said, I still join in the C hating :)
21:07:39 <Sonarpulse> I think a lot of people feel like it's more credible to hate on C++ than C
21:07:44 <monochrom> I am certainly annoyed by not supporting nesting function declarations
21:07:51 <Crockeo> "John Kemeny and Thomas Kurtz create BASIC, an unstructured programming language for non-computer scientists." *laughs hysterically*
21:08:01 <Crockeo> #haskell, the place to hate on not-Haskell
21:08:02 <Crockeo> haha
21:08:06 <monochrom> perhaps s/declaration/definition/ --- they have funny terminology
21:08:11 <shachaf> Crockeo: Not really.
21:08:13 <johnw> C is like *the* portable assembly language; C++ is a bit more... colorful
21:08:32 <popl> It's possible to hate on BASIC anywhere.
21:08:34 <Crockeo> scachaf: #haskell, the place to hate on imperative programming*?
21:08:34 <Crockeo> :P
21:08:36 <Sonarpulse> For me, C is most annoying when the asm would be easier
21:08:45 <latermuse> how would you guys like it if we didnt have C and had to program in ASM instead?
21:08:54 <popl> latermuse: I like assembler.
21:09:02 <monochrom> oh, speaking of C and asm, I am also annoyed that the carry flag is not exposed
21:09:07 <popl> latermuse: I use python in vim to generate it.
21:09:09 <Crockeo> popl: You may like it, but it's much less efficient than coding in C
21:09:10 <popl> :P
21:09:14 <johnw> latermuse: i would load my dismay into a register and then store it in this channel
21:09:15 <latermuse> popl: yes, assembler is nice, but only having asm and no C would be a pain in the butt
21:09:25 <popl> No kidding.
21:09:28 <popl> :)
21:09:44 <popl> Although we could have some other language instead of C.
21:09:44 <Sonarpulse> I learned asm is good so you and the compiler can relate
21:09:48 <Crockeo> To be fair, when programming in asm I /do/ feel like a badass.
21:09:49 <popl> You're speaking hypothetically anyhow.
21:09:52 <latermuse> i prefer the BF method of writing "close-to-the-metal" code
21:10:22 <latermuse> +>++++<.>.
21:10:43 <popl> latermuse: Seriously?
21:10:44 <Crockeo> latermuse: ಠ_ಠ
21:10:46 <Crockeo> DON'T EVEN REMIND ME
21:10:55 <Sonarpulse> I also dislike how C has extern to mean both importing and exporting global variables
21:11:00 <lispy> ?bf +>++++<.>.
21:11:01 <lambdabot>  Done.
21:11:02 <latermuse> popl: yes, i seriously prefer BF to asm
21:11:08 <Sonarpulse> it has been an issue once porting windows stuff
21:11:11 <latermuse> lispy: it doesnt do anything
21:11:27 <lispy> latermuse: sure, but lambdabot can still run bf programs :)
21:11:30 <popl> latermuse: Why?
21:11:34 <lispy> well, some of them...
21:11:36 <Crockeo> latermuse: Yeah it does, it-
21:11:37 <lispy> she can't ask for input
21:11:38 <Sonarpulse> and I wish it could do arrays be value on the stack
21:11:40 <Crockeo> I think I found my project
21:11:45 <lispy> Basically, all the IO gets stripped out...
21:11:47 <Crockeo> I'm going to write a brainfuck interpreter.
21:11:49 <Sonarpulse> I know that's a bad idea most of the time, but it would be nice occasionally
21:11:52 <latermuse> popl: its beautiful to me
21:11:55 <Sonarpulse> *by value
21:12:09 <popl> latermuse: Why?
21:12:12 <deus_rex> Crockeo: somewhere on my todo list is writing a forth in haskell
21:12:14 <lispy> Crockeo: i wrote the one in lambdabot when I was a wee haskell beginner. It even optimizes :)
21:12:31 <Crockeo> lispy: Ooooooh I like
21:12:37 <latermuse> popl: Controlling the exact placement of singular bits in an array excites me.
21:12:39 <Crockeo> lispy: Time to see how much better yours is than mine.
21:12:46 <popl> I like Ook. It is isomorphic to BF.
21:12:52 <popl> latermuse: Are you familiar with Ook?
21:12:59 <popl> latermuse: http://www.dangermouse.net/esoteric/ook.html
21:13:03 <roadfish> Eek
21:13:40 <latermuse> popl: yes. there are many funny languages like ook
21:13:48 <Crockeo> Man, this brings me back to my problem of returning a list with a changed element, unless there's a better way to implement it...
21:13:54 <lispy> ?version
21:13:54 <lambdabot> lambdabot 4.2.2.1
21:13:54 <lambdabot> darcs get http://code.haskell.org/lambdabot
21:13:57 <popl> It's the same as BF.
21:13:57 <Crockeo> Time to review Brainfuck. TO WIKIPEDIA!
21:14:12 <latermuse> popl: yeah, but the functions are named differently
21:15:04 <roadfish> Ook. Ook? Ook!
21:15:19 <johnw> don't they need to come in pairs?
21:15:28 <latermuse> ?ook Ook. Ook? Ook!
21:15:28 <lambdabot> Maybe you meant: ask do yow
21:15:48 <popl> So it is not the exact placement of bits in an array which excite you about BF but rather the look of the language, latermuse?
21:15:58 <popl> Or do you find Ook beautiful as well?
21:16:15 <roadfish> johnw: Sorry, I'm just human.
21:16:35 <popl> johnw: Yes.
21:16:38 <Sonarpulse> hmm, how would I use case an an IO Bool ?
21:16:41 <latermuse> popl: The way that the functions are named is irrelevant to their functionality
21:16:47 <Sonarpulse> my usual lifting and =<< tricks do not work
21:16:58 <johnw> Sonarpulse: x <- someIObool; case x of ...
21:17:00 <lispy> Crockeo: here are some example programs I collected when I was writing mine: http://code.haskell.org/lambdabot/brainfuck/Language/Brainfuck/Examples.hs
21:17:13 <Sonarpulse> no way without do notation?
21:17:23 <Sonarpulse> aha!
21:17:31 <Sonarpulse> >>= \x -> case x of
21:17:37 <johnw> someIObool >>= \case of ...
21:17:41 <johnw> if you want to use the new LambdaCase
21:17:53 <Sonarpulse> is that an extension?
21:17:57 <johnw> yes
21:17:58 <shachaf> Which you shouldn't use.
21:18:00 <johnw> GHC 7.6 extension
21:18:14 <johnw> which you should use just *because* shachaf doesn't like it
21:18:20 <johnw> and when your code is done, mail him a copy
21:18:23 <shachaf> johnw: I don't mind the extension.
21:18:33 <johnw> you mind code that uses the extension :)
21:18:43 <shachaf> But if you're still asking the sorts of questions Sonarpulse is asking, you shouldn't be using fancy extensions like that.
21:18:44 <lispy> lambdacase seems a little meh as far as extensions go
21:19:03 <johnw> he was wanting sexy, I gave him sexy
21:19:05 <Sonarpulse> shachaf, I think you should kno that typeclasses are now much rarer in my ocde
21:19:07 <johnw> let him make his choice
21:19:12 <Sonarpulse> I am from lisp-land
21:19:18 <Crockeo> lispy: I was alt-tabbed, but I'm back, so a belated thank you.
21:19:33 <Sonarpulse> everything is an expresion is what I am used to
21:19:35 <popl> latermuse: I didn't imply it was.
21:19:37 <popl> :)
21:19:38 <roadfish> popl: here is a real language ... from 1948 has 7 instructions of 3bit length:
21:19:41 <roadfish>   http://en.wikipedia.org/wiki/Manchester_Small-Scale_Experimental_Machine#Programming
21:19:46 <lispy> Crockeo: cool. If you want to compare the implementations, go up a directory at that URL and look around
21:19:53 <popl> roadfish: Real?
21:20:22 <Crockeo> Will do lispy; I'll probably bookmark the lambabot google code URL anyways.
21:20:39 <roadfish> popl: is the "first stored-program computer" ... ran for 52 minutes on June 21 1948
21:21:09 <popl> roadfish: That makes it a real language?
21:21:11 <lispy> roadfish: before printing "hello, world!"
21:21:12 <rwbarton> what did it compute on that momentous occasion?
21:21:15 <lispy> roadfish: ?
21:21:58 <roadfish> rwbarton: 131,072
21:22:18 <dibblego> is there a canonical representation of type-level naturals without any GHC extensions?
21:22:32 <roadfish> rwbarton: highest divisor of 131,072 ... was 17 instructions long.
21:22:34 <rwbarton> factoring a power of 2, impressive
21:22:44 <roadfish> no, I mean 262,144
21:23:14 <Nisstyre-laptop> dibblego: you mean like, without functional dependencies or anything like that?
21:23:19 <roadfish> and it ran for 52 minutes ... and probably could have heated your home for a week
21:23:21 <dibblego> Nisstyre-laptop: correct
21:23:41 <shachaf> dibblego: *Representing*?
21:23:50 <shachaf> Just data Z; data S n; presumably.
21:23:51 <dibblego> encoding
21:23:57 <shachaf> But doing anything with them is trickier.
21:24:01 <Nisstyre-laptop> you can obviously write a Nat type with no extensions
21:24:04 <dibblego> yeah, I was wondering if there is anything more than that
21:24:08 <roadfish> rwbarton: I just like looking at the op codes. How is given in full detail.
21:24:12 <Nisstyre-laptop> if you're asking if you can do type level hackery with it...I don't think so
21:25:07 <monochrom> it took 52 minutes because it used "data Z; data S n" :)
21:25:14 <startling> you can do data Zero = Zero; data Succ a = Succ a
21:25:20 <startling> heh
21:27:17 * hackagebot gloss 1.7.7.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.7.1 (BenLippmeier)
21:32:04 <hpaste> Sonarpulse pasted “getDirContentsRecursive” at http://hpaste.org/78262
21:32:19 * hackagebot gloss-raster 1.7.7.3 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.7.3 (BenLippmeier)
21:32:21 <Sonarpulse> yay got it
21:32:41 <Sonarpulse> oo, is that hlint that hpaste uses?
21:33:10 <shachaf> Yes.
21:33:20 <Sonarpulse> tis right about the if
21:33:59 <Crockeo> lispy: I'm looking over your code for Brainfuck.hs
21:34:16 <Crockeo> a quarter of the syntax you're using is foreign to me :P
21:34:24 <Crockeo> I should suck it up and just finish LYAH, shouldn't I?
21:35:49 <startling> syntax, or functions and operators?
21:35:59 <Crockeo> Mainly operators.
21:36:25 <Crockeo> (Which are just the soda of functions, right?)
21:36:29 <startling> operators are just functions, they're not hard.
21:36:48 <Crockeo> ('soda of functions' meaning they're just sugared functions)
21:37:08 <shachaf> Sonarpulse: Your code is broken.
21:37:15 <Crockeo> Okay, so {- -] is just multiline comments?
21:37:17 <Sonarpulse> in what way?
21:37:17 * hackagebot vector-th-unbox 0.2.0.1 - Deriver for Data.Vector.Unboxed using Template Haskell  http://hackage.haskell.org/package/vector-th-unbox-0.2.0.1 (LiyangHu)
21:37:21 <roadfish> ?Prelude
21:37:21 <lambdabot> Unknown command, try @list
21:37:34 <roadfish> @list Prelude
21:37:34 <lambdabot> No module "Prelude" loaded
21:37:44 <shachaf> Sonarpulse: I can tell because I tried to run it and it made my computer freeze for a while before I managed to kill it.
21:37:50 <shachaf> Now I have ~2GB in swap.
21:38:08 <Sonarpulse> ...sorry
21:38:24 <roadfish> where can I get a copy of Prelude.hs without downloading the source? Google just gives me Hugs versions of Prelude.hs
21:38:39 <roadfish> ... I mean the whole source of ghc
21:40:26 <shachaf> roadsource: cabal unpack base
21:42:03 <roadfish> ah, and I just saw the Source link at the top of the Prelude html page
21:42:22 <Sonarpulse> any idea what is wrong? shachaf?
21:43:25 <Sonarpulse> I did the things lint suggested, but otherwise It's the same (and of course lint shouldn't change the function of the code)
21:44:01 <stepkut> grammatical framework would be 10x more interesting if it include a good speech recognition system :-/
21:44:10 <stepkut> though, it is still quite interesting
21:44:37 <shachaf> Lots of things.
21:44:55 <roadfish> stepkut: you have a Haskell grammatical framework?
21:44:58 <Sonarpulse> ok
21:45:09 <shachaf> A couple:
21:45:23 <shachaf> Your function shouldn't take an IO argument (and it probably shouldn't take a list)
21:45:31 <shachaf> getDirectoryContents doesn't give you absolute paths
21:46:02 <shachaf> The -- oh, I don't know.
21:46:14 <shachaf> I'm not about to fiddle with that code and run it again. :-)
21:46:41 <Sonarpulse> A), well then the first recursion is a special case if I do it your way, and I want to run it on a list of paths anyways
21:46:58 <shachaf> No it's not.
21:48:09 <Sonarpulse> B) that is certainly something to look into, but then I would have expected it to return false for incorrect paths, and thereby return quicker
21:50:12 <Sonarpulse> ah!
21:50:24 <Sonarpulse> "." and ".." are in the resaults
21:55:45 <b__> does ghc 7.6.1 work okay (for mac)?
21:55:59 <Sonarpulse> works!
21:56:08 <Sonarpulse> I tested it this time
21:56:09 <Sonarpulse> :D
21:57:01 <hpaste> Sonarpulse pasted “New getDirContentsRecursive” at http://hpaste.org/78263
21:57:52 <Sonarpulse> I gotta love my second line (.... = (=<<) $ blah . blah . blah ....)
22:00:23 <Nereid> why not getDirContentsRecursive :: [FilePath] -> IO [FilePath]?
22:01:16 <Sonarpulse> I think what i did makes the recursion easier
22:01:24 <Crockeo> tsk tsk tsk
22:01:26 <Sonarpulse> but if not that would be nicer
22:01:48 <Crockeo> It /is/ an IO function, therefore it should return an IO value.
22:02:14 <Sonarpulse> yeah, certainly return an IO
22:02:23 <startling> IO [FilePath] -> IO [FilePath] is weird.
22:02:24 <Nereid> Sonarpulse: but then you could write getDirectoryContents p >>= getDirContentsRecursive
22:02:27 <Nereid> in the helper
22:02:56 <rwbarton> and delete (=<<) $ on line 2
22:03:06 <Nereid> yes
22:03:13 <Sonarpulse> I'll miss my line two :(
22:04:11 <latro`a> startling--depends?
22:04:12 <rwbarton> a -> IO b is sort of more informative than IO a -> IO b
22:04:14 <Nereid> and the whole thing is easy to write without any helper function
22:04:17 <latro`a> I mean, any fmap sort of thing will do that
22:05:27 <rwbarton> for example IO a -> IO b could run the input action twice. your function actually runs the input function always once
22:05:34 <rwbarton> and at the start
22:06:35 <Sonarpulse> this is better
22:06:47 <Sonarpulse> I also get to take the lifts off the helper functions
22:08:18 <Nereid> you also probably want to take out "." and ".."
22:08:45 <Sonarpulse> you mean remove them from the ouput? or remove that line?
22:09:19 <Sonarpulse> doesDirectoryExit "." reutrns true remember
22:09:53 <Nereid> I mean filter it out of your lists.
22:10:02 <Nereid> else it'll keep recursing into . and never produce anything
22:10:08 <Sonarpulse> I do do that,
22:10:18 <Nereid> not in your paste
22:10:33 <Sonarpulse> oh whoops
22:10:37 <Sonarpulse> left out the where
22:10:58 <Sonarpulse> oh wait, no there helpers aren't in there
22:11:05 <Sonarpulse> well i guess i'll just make another
22:11:39 <Nereid> and it also doesn't actually work
22:11:52 <hpaste> Sonarpulse pasted “New^2 getDirContentsRecursive” at http://hpaste.org/78264
22:11:54 <Nereid> since getDirectoryContents doesn't put the directory name in front of the contents
22:12:00 <Nereid> ah there.
22:12:08 <Sonarpulse> fixed that too
22:12:24 <Nereid> I think your "helper" function should be the main function.
22:13:09 <Sonarpulse> I could combine the map in appOld with the current "main" function
22:15:28 <Nereid> also it blows up when it can't read a directory :P
22:18:08 <Sonarpulse> hmm?
22:18:24 <Sonarpulse> dictionary as in dictionary passing?
22:18:37 <Nereid> who said dictionary?
22:18:42 <Sonarpulse> oh
22:18:43 <Sonarpulse> whoop
22:18:46 <Sonarpulse> s
22:18:52 <Sonarpulse> I must be getting tired
22:18:54 <Nereid> lol
22:19:05 <ion> snoyberg: Hi. Regarding <http://www.yesodweb.com/blog/2012/10/yesod-fay-js>, have you seen <http://www.meteor.com/>? It would be so awesome to have that, but in Haskell.
22:19:08 <Sonarpulse> yeah, that is built in. Not sure what I can do about it
22:19:17 <Nereid> you could catch an exception
22:19:25 <Sonarpulse> hopefully, doesDirectoryExist will weed them out
22:19:30 <Nereid> it doesn't
22:19:39 <Sonarpulse> it returns false for files/directories that don't exist
22:19:41 <ion> snoyberg: The two screencasts are worth watching.
22:19:48 <Nereid> but it returns true for directories that do exist but can't be read
22:19:55 <Sonarpulse> oh, I see
22:19:58 <Nereid> due to e.g. permissions
22:20:09 <Sonarpulse> I could use the permission helper
22:20:14 <Nereid> you could catch an exception
22:20:21 <Sonarpulse> though I imagine this will mainly be used by windows people
22:20:22 <Nereid> (there are other reasons why a directory read may fail)
22:20:23 <Zarathu> Hi! Simple question: is there a way to essentially perform an 'elem' on a list, but using a conditional? The only way I can think would be to map (func) list, which gives me a [Bool], and then `elem` True on it. Horribly inefficient. :/
22:20:40 <Nereid> filter?
22:20:46 <shachaf> Zarathu: any?
22:20:53 <Zarathu> No, filter goes through the entire--yay!
22:20:54 <shachaf> Zarathu: What's the type of the function you want?
22:21:02 <Nereid> oh
22:21:03 <shachaf> Zarathu: filter doesn't "go through the entire"
22:21:03 <Zarathu> Oh.
22:21:09 <Zarathu> It doesn't?
22:21:12 <shachaf> Nope.
22:21:17 <Nereid> only if you go through the entire result
22:21:30 <shachaf> > head (filter even [1..])
22:21:31 <lambdabot>   2
22:21:35 <shachaf> Infinite list!
22:21:37 <Nereid> it wasn't clear what you were asking for, sorry
22:22:02 <shachaf> Indeed it wasn't. When you ask a question like that you should specify an example and/or a type. :-)
22:22:24 <Nereid> but any ≡ elem True
22:22:36 <Nereid> oops
22:22:38 <Nereid> no, I'm thinking all
22:22:50 <Zarathu> shachaf: I'm looking for a function that returns: [a] -> ([a] -> Bool) -> Bool... I think.
22:22:52 <Nereid> no, I'm thinking or.
22:22:53 <Nereid> heh.
22:22:57 <Zarathu> That seems wrong, though.
22:22:58 <deus_rex> :t any
22:22:59 <lambdabot> (a -> Bool) -> [a] -> Bool
22:23:01 <Nereid> :t any
22:23:03 <lambdabot> (a -> Bool) -> [a] -> Bool
22:23:07 <Zarathu> Ah :D
22:23:09 <deus_rex> :t flip . any
22:23:10 <lambdabot>     Couldn't match expected type `b0 -> c0' with actual type `Bool'
22:23:10 <lambdabot>     Expected type: (a0 -> Bool) -> [a0] -> b0 -> c0
22:23:10 <lambdabot>       Actual type: (a0 -> Bool) -> [a0] -> Bool
22:23:12 <Nereid> :t flip any
22:23:13 <ion> @src any
22:23:13 <lambdabot> any p =  or . map p
22:23:13 <lambdabot> [a] -> (a -> Bool) -> Bool
22:23:14 <deus_rex> :t flip any
22:23:15 <lambdabot> [a] -> (a -> Bool) -> Bool
22:23:22 <Nereid> @src or
22:23:22 <lambdabot> or    =  foldr (||) False
22:23:27 <Nereid> heh
22:23:31 <Nereid> :t elem True
22:23:32 <lambdabot> [Bool] -> Bool
22:23:41 <Zarathu> Thanks everyone :D
22:23:45 <Nereid> is as good as or
22:24:33 <Nereid> :t or .: map
22:24:34 <lambdabot> (a -> Bool) -> [a] -> Bool
22:24:49 <shachaf> @hoogle [a] -> ([a] -> Bool) -> Bool
22:24:49 <lambdabot> Foreign.Marshal.Utils withMany :: (a -> (b -> res) -> res) -> [a] -> ([b] -> res) -> res
22:24:49 <lambdabot> System.Console.GetOpt ReqArg :: (String -> a) -> String -> ArgDescr a
22:24:49 <lambdabot> Data.Generics.Aliases ext1Q :: (Data d, Typeable1 t) => (d -> q) -> (forall e. Data e => t e -> q) -> d -> q
22:24:56 <shachaf> @hoogle [a] -> (a -> Bool) -> Bool
22:24:56 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
22:24:56 <lambdabot> Data.List all :: (a -> Bool) -> [a] -> Bool
22:24:57 <lambdabot> Prelude any :: (a -> Bool) -> [a] -> Bool
22:25:27 <Nereid> :t anyOf traverse
22:25:29 <lambdabot> Traversable t => (a -> Bool) -> t a -> Bool
22:25:38 <Nereid> :t anyOf folded
22:25:40 <lambdabot> Foldable f => (b -> Bool) -> f b -> Bool
22:27:26 <shachaf> @ty \f xs -> not $ nullOf (folded.filtered f) xs
22:27:27 <lambdabot> Foldable f => (a -> Bool) -> f a -> Bool
22:28:11 <Nereid> > (["hello","world"],3,"blah") & biplate %~ (reverse :: String -> String)
22:28:13 <lambdabot>   (["olleh","dlrow"],3,"halb")
22:28:17 <Nereid> fantastic
22:28:24 <ion> @ty unsafeCoerce :: (a -> Bool) -> [a] -> Bool
22:28:26 <lambdabot> Not in scope: `unsafeCoerce'
22:28:31 <lispy> oh, is  it time for lens golf again?
22:28:33 <Nereid> oops
22:28:39 <edwardk> heh
22:28:47 <edwardk> its always time for lens golf
22:29:02 <lispy> edwardk: that's par for the course :)
22:29:28 <lispy> (I have more golf jokes and they're all at least this funny, I promise)
22:29:29 <edwardk> :t findOf
22:29:30 <lambdabot> Getting (First a) s t a b -> (a -> Bool) -> s -> Maybe a
22:29:40 <Crockeo> As someone who knows nothing about lens, I'd have to say it's time for me to lose lens golf.
22:29:57 <edwardk> we'll spot you a few strokes
22:30:02 <Crockeo> :D
22:30:12 <Crockeo> Lets make a few = ~50
22:30:32 <lispy> You should start with puting
22:30:56 <Crockeo> I feel like I should start with learning how to begin to grasp the club.
22:31:09 <edwardk> > (1,2) & upon fst .~ 3
22:31:11 <lambdabot>   (3,2)
22:31:13 <Crockeo> I've nearly begun with that :P
22:31:14 <edwardk> ^- putt ;)
22:31:31 <shachaf> Yay, findOf folded f xs :: (a -> Bool) -> [a] -> Maybe a compiles to more or less optimal Core.
22:31:31 <Nereid> so
22:31:31 <Crockeo> Anyways, I ought to go to sleep
22:31:38 <Nereid> how do I reverse all the chars?
22:31:40 <Nereid> and not each string.
22:31:41 <Crockeo> either that or continue implementing Brainfuck.
22:31:41 <edwardk> shachaf: woot
22:32:00 <copumpkin> shachaf: that's pretty neat
22:32:15 <edwardk> Crockeo: https://github.com/ekmett/lens/blob/master/examples/Brainfuck.hs might serve as a little lens rosetta stone then ;)
22:32:43 <Crockeo> Maaaaaaaa
22:32:45 <Crockeo> (n)
22:32:49 <Crockeo> now I gotta go learn lens.
22:32:54 <edwardk> how is that for topical ;)
22:34:27 <Nereid> oh right.
22:34:35 <Nereid> > (["hello","world"],3,"blah") & partsOf biplate %~ (reverse :: String -> String)
22:34:36 <lambdabot>   (["halbd","lrowo"],3,"lleh")
22:35:26 <otters> biplate is cheating
22:35:30 <Nereid> :(
22:36:22 <Nereid> edwardk: I probably should try to find this myself, but is there a thing that lets us combine two traversals of the same type?
22:36:27 <Nereid> like _1 and _2 to get both
22:36:54 <Nereid> hmm, bad things could happen maybe.
22:37:24 <edwardk> Nereid: you can prove that with such a traversal you could derive join for any applicative.
22:37:46 <edwardk> so give me that and watch me bend reality
22:37:50 <Nereid> awesome :D
22:37:56 <Nereid> (how does it work?)
22:38:34 <edwardk> very carefully, but effectively you are composing two functions (s -> f t)    (t -> f u)
22:38:42 <edwardk> ignoring the (a -> f b) parts
22:38:53 <Nereid> hmm
22:38:53 <edwardk> so you can only do that by fmapping the one over the other
22:38:59 <edwardk> that gives you s -> f (f u)
22:39:09 <edwardk> now you need to flatten them and all you know about f is that f is a monad.
22:39:13 <edwardk> er f is an applicative
22:39:17 <edwardk> if it was a monad you could do it
22:39:20 <Nereid> yeah I think I see it.
22:39:48 <Nereid> I guess we could move to -lens.
22:39:51 <edwardk> i've been trying to find nice ways to do this and failing
22:40:17 <edwardk> well that has a completely unrelated lens discussion going ;)
22:40:28 <Nereid> heh
22:41:46 <Nereid> have you thought about the projection stuff some more?
22:41:58 <edwardk> working on it
22:42:06 <edwardk> i have a sketch of how i want it to work
22:42:25 <edwardk> but i'm trying to do it without forcing ghc to give me equalities its not willing to give me
22:42:42 <Nereid> mmm
22:42:53 <edwardk> data Isos afb sft where  Isos :: (s -> a) -> (a -> s) -> (t -> b) -> (b -> t) -> Isos (a -> f b) (s -> f t)
22:43:03 <edwardk> when you go to _use_ that you get some annoying problems
22:43:36 <edwardk> it isn't willing to know that the b it gets out is the b you put in
22:43:53 <edwardk> the -> f    forces it to freak out
22:44:08 <Nereid> :(
22:44:38 <Sonarpulse> well everything is working quite well
22:44:43 <Sonarpulse> thanks everybody
22:47:13 <Sonarpulse> actually one more question, is there any way I can do a remote windows compile?
22:47:33 <edwardk> i'm trying to see if i can pick particular 'f's in places or concoct something fancier
22:47:48 <edwardk> this is basically when i got stuck before and said !@(#*( it and made Projection.
22:48:36 <lispy> Sonarpulse: for testing your code on windows?
22:48:51 <lispy> Sonarpulse: do you have a windows machine you want to build on or do you need the windows machine?
22:51:17 <Crockeo> lispy: I heard there was a parentheses shortage. You should probably stock up! :P
22:51:43 <Sonarpulse> I have windows dule boot
22:51:53 <Sonarpulse> but I haven't installed haskell on windows yet
22:51:58 <Crockeo> (dual*)
22:52:06 <Crockeo> (Sorry, just a grammar nazi)
22:52:07 <Sonarpulse> yes, i am getting tired
22:52:12 <Sonarpulse> no worries :)
22:52:50 <lispy> Crockeo: on no, that sounds terrible
22:53:04 <Crockeo> lispy: Now we'll have to use proper-looking Haskell code.
22:53:17 <Crockeo> I feel as if I use parens way too much in Haskell
22:53:18 <lispy> Sonarpulse: I guess I don't really know what you want re: remote windows compile
22:53:19 <Sonarpulse> I have a dual in a duel
22:53:29 <latermuse> crockeo: learn $
22:53:33 <Sonarpulse> lispy: basically I don't wanna reboot
22:53:38 <Crockeo> latermuse: I use it, a lot.
22:53:42 <Sonarpulse> that's what it comes down too
22:53:45 <neworder> For this function here
22:53:50 <neworder> http://hpaste.org/78261
22:53:52 <Sonarpulse> I am making this mainly for people on windows
22:53:59 <Sonarpulse> so they will need windows binary
22:54:05 <lispy> Sonarpulse: I wish travis-ci had windows machines. I use them for linux builds
22:54:05 <neworder> It looks very different from the ones I'm seeing
22:54:07 <Sonarpulse> because they can't be arsed to download haskell
22:54:10 <Crockeo> latermuse: Is it possible to use it with functions that have multiple arguments, because that's usually where I use parens.
22:54:39 <Sonarpulse> is this some person that lets people do a remote linux compile?
22:54:46 <latermuse> crockeo: yes
22:54:50 <neworder> I'm used to this kind of functions where the arguments on the left hand site appear on the right hand side "foldr f z (x:xs) = f x (foldr f z xs)"
22:55:09 <neworder> Here, it's like split l = rr++[ll]
22:55:25 <neworder> which means the function split takes in a list
22:55:34 <Crockeo> latermuse: How would you implement it, because it ususally throws an error up for me.
22:55:40 <neworder> and seperates it into 2 parts?
22:55:46 <latermuse> crockeo: give an example
22:55:55 <Crockeo> One second, writing something up for hpaste.
22:55:57 <neworder> It's just the syntax which confused me
22:56:00 <neworder> something new
22:56:10 <neworder> confuses*
22:57:00 <hpaste> Crockeo pasted “Example” at http://hpaste.org/78265
22:57:06 <Crockeo> Am I using it wrong or..?
22:57:22 <Nereid> a $ b 1 2 3 = a (b 1 2 3)
22:57:30 <startling> so why don't we have transformers on lists of monads yet?
22:57:42 <Nereid> Crockeo: $ won't help you there.
22:57:54 <Nereid> (it would if it was infixl, though!)
22:58:12 <latermuse> a $ b 1 2 3 is not the same as a (b 1 2) 3
22:58:17 <Zarathu> I'm trying to take a list of Points (Int,Int) and groupBy the adjacent ones. Seems that groupBy is only comparing the next two with the current chunk. Is there any way to perform a sort of "exhaustive" groupBy?
22:58:36 <startling> I want MaybeT [IO, State, Writer] . :(
22:58:47 <Crockeo> Nereid: That's what I was wondering.
22:59:01 <Nereid> startling: because it's not a legal monad transformer
22:59:14 <Nereid> well, there is a ListT
22:59:15 <Crockeo> Nereid, latermuse: In that situation is when I usually use the most parens.
22:59:17 <Nereid> but it's not lega
22:59:17 <latermuse> b 1 2 `a` 3
22:59:18 <Nereid> l
22:59:47 <Crockeo> latermuse: Just infix the shit out of a?
22:59:47 <Crockeo> :P
22:59:48 <startling> Nereid, nah, I mean transformers parametrized over lists of transformed types
23:00:05 <Nereid> huh?
23:00:08 <startling> e.g. with DataKinds
23:00:08 <latermuse> b 1 2 `a` 3 = a (b 1 2) 3
23:00:09 <Nereid> Zarathu: what do you mean?
23:00:13 <Nereid> can you given a example?
23:00:24 <Zarathu> Yes, I'll paste the sauce.
23:00:33 <latermuse> crockeo: that is one way
23:00:42 <Zarathu> hpaste is asking for http basic auth :/
23:00:48 <startling> wrong hpaste
23:00:51 <Nereid> @paste
23:00:51 <lambdabot> Haskell pastebin: http://hpaste.org/
23:00:55 <Zarathu> :)
23:01:30 <hpaste> Zarathu pasted “z” at http://hpaste.org/78266
23:01:50 <Zarathu> This is a simple "adjacency" test for a multidimensional list
23:02:12 <Zarathu> groupBy (\x y -> pointsAreAdjacent x y) someList gives me: [[(0,1),(0,2),(1,1)],[(1,2),(1,3)],[(2,3)],[(4,4),(5,4)]]
23:02:21 <hpaste> Nereid annotated “z” with “z (annotation)” at http://hpaste.org/78266#a78267
23:02:25 <Nereid> ;)
23:02:26 <Nereid> anyway
23:02:44 <Zarathu> ;> thanks
23:02:59 <Zarathu> The result is only supposed to give me two chunks.
23:03:16 <Zarathu> Instead, it's giving me 4 because it's only comparing against the "current chunk"
23:03:28 <Nereid> so it splits a list into a bunch of chunks, where consecutive elements of the chunks are adjacent.
23:03:30 <deus_rex> is there some tool out there which will desugar a 'do'-notation block
23:03:32 <deus_rex> ?
23:03:42 <Nereid> @undo do { x <- a; b }
23:03:42 <lambdabot> a >>= \ x -> b
23:03:52 <deus_rex> oh, sweet
23:04:39 <Nereid> Zarathu: right, groupBy assumes that your relation is an equivalence relation
23:04:47 <Nereid> so it just compares with the first element of each chunk or something
23:04:48 <Nereid> hmm
23:04:53 <Zarathu> Yep; looking for a more suitable function.
23:05:18 <hpaste> Zarathu pasted “Shapes” at http://hpaste.org/78268
23:05:22 <Zarathu> ^ full program, btw.
23:05:43 <Zarathu> ah, ignore "groupedShapes"
23:05:59 <Nereid> yeah I don't know of a library function that does that.
23:06:01 <Nereid> but you can write your own.
23:06:48 <Zarathu> I started to write groupedShapes, which would just take the head of "points" and throw it into the list of shapes, or just add a new shape containing itself if one wasn't found.
23:07:07 <Zarathu> I could write my own function that behaves like groupBy, but it would end up being O(n^2)...
23:08:14 <Nereid> it should be O(n) though.
23:08:44 <Zarathu> Yep, definitely. It's better to iterate through the points I'm testing, instead of exhaustively grouping them.
23:08:50 <Zarathu> I will try this, sec
23:13:08 <Nereid> heh, I found a cute solution.
23:13:13 <Nereid> also evil and awful.
23:13:22 <Zarathu> Nereid: Link? :D
23:13:26 <Nereid> pasting.
23:14:16 <hpaste> Nereid pasted “groupBy'” at http://hpaste.org/78271
23:14:55 <Nereid> isn't it horrible.
23:15:40 <Zarathu> :/
23:16:04 <Nereid> :\
23:16:10 <Nereid> key:
23:16:21 <Nereid> > groupBy (/=) [False,True,True,False,True,False,False]
23:16:23 <lambdabot>   [[False,True,True],[False,True],[False],[False]]
23:16:37 <Nereid> > groupBy (const id) [False,True,True,False,True,False,False]
23:16:38 <lambdabot>   [[False,True,True],[False,True],[False],[False]]
23:16:42 <Nereid> haha that's even more amazing.
23:17:03 <copumpkin> conclusive proof that (/=) = const id
23:17:06 <copumpkin> who woulda thunk it
23:17:08 <Nereid> :D
23:17:15 <Zarathu> :D
23:17:31 <copumpkin> haskell probably woulda thunk it
23:17:33 <copumpkin> anyway
23:17:36 <copumpkin> sleep time :P
23:17:36 <Nereid> :D
23:17:39 <Nereid> you are horrible.
23:17:42 <Nereid> bye :)
23:17:45 <copumpkin> I try!
23:17:46 <copumpkin> ciao :P
23:18:19 <Nereid> Zarathu: I don't really like this though, I think it ends up going through the list twice
23:18:31 <notdan> > const id False True
23:18:32 <lambdabot>   True
23:18:55 <Zarathu> Nereid: n^2 times
23:19:07 <Zarathu> Oh, nvm
23:19:14 <Nereid> no, it's linear time
23:19:16 <Nereid> but also linear space
23:19:20 <Nereid> or rather
23:19:51 <Nereid> it goes through the list twice, so it has to store the whole list in memory
23:20:15 <Nereid> oh wait
23:20:17 <Nereid> never mind
23:20:31 <Nereid> or
23:20:44 <snoyberg> ion: i think we're headed towards supporting a lot of the same stuff as meteor, but with different initiatives, like keter for deployment, or WAI middleware, or fay+angular for the frontend data binding
23:20:45 <Nereid> yeah, it has to store the whole chunks.
23:21:00 <ion> snoyberg: Alright, nice.
23:22:09 <Nereid> (observe memory usage while running "last $ groupBy' ..." on an infinite list)
23:22:32 <Nereid> (it's constant if you have chunks of bounded size, but it grows if you have an infinite chunk)
23:24:09 <Zarathu> I'm almost done with my function... it's making my brain hurt.
23:24:11 <Nereid> :t const id `on` snd
23:24:12 <lambdabot> (a, c) -> (a, c) -> c
23:24:30 <Nereid> @unpl const id `on` snd
23:24:30 <lambdabot> (on (\ _ b -> b) snd)
23:24:35 <Nereid> blah
23:25:04 <Nereid> someone teach this bot about on
23:25:40 <Zarathu> haha
23:28:56 <edwardk> Would adding "Isos xs sx yt ty . Isos sa as tb bt = unsafeCoerce (Isos (unsafeCoerce sa.unsafeCoerce xs) (unsafeCoerce sx.unsafeCoerce as) (unsafeCoerce tb.unsafeCoerce yt) (unsafeCoerce ty.unsafeCoerce bt))" increase or decrease your confidence in the correctness of lens?
23:30:18 <latermuse> > meow
23:30:21 <lambdabot>   Not in scope: `meow'
23:30:27 <shachaf> @remember edwardk this breaks my previous record of 6 unsafeCoerce's in a line
23:30:27 <lambdabot> Nice!
23:30:47 <edwardk> ahaha
23:31:09 <Nereid> that is quite uh.
23:31:24 <zhulikas> @type unsafeCoerce
23:31:25 <lambdabot> Not in scope: `unsafeCoerce'
23:31:33 <shachaf> a -> b
23:31:50 <zhulikas> can I get an example?
23:32:05 <shachaf> No.
23:32:07 <shachaf> It's unsafe.
23:32:08 <zhulikas> ok :(
23:32:10 <zhulikas> haha
23:32:11 <mauke> coerce 42 :: [String]
23:32:12 <edwardk> zhulikas:   unsafeCoerce 3 ++ "The world just ended"
23:32:23 <shachaf> I bet that would work.
23:32:23 <zhulikas> > unsafeCoerce 3 ++ "The world just ended"
23:32:25 <lambdabot>   Not in scope: `unsafeCoerce'
23:32:30 <zhulikas> hm, ok
23:32:34 <shachaf> Try it in ghci
23:32:38 <zhulikas> yeah, sure
23:32:41 <zhulikas> thanks for an example
23:32:42 <shachaf> You'll probably make ghci crash pretty quickly.
23:32:59 <shachaf> zhulikas: unsafeCoerce behaves just like id, except it gives you any type you want.
23:33:03 <edwardk> >>> unsafeCoerce (Just 12) ++ "The world just ended"
23:33:03 <edwardk> "\f
23:33:27 <shachaf> > ord '\f'
23:33:28 <lambdabot>   12
23:33:30 <zhulikas> man, now that's scary
23:33:41 <edwardk> there that will crash ;)
23:33:54 <shachaf> λ> unsafeCoerce (Just 12) ++ "hi"
23:33:54 <shachaf> "\fhi"
23:34:02 <shachaf> λ> unsafeCoerce (Just 97) ++ "hi"
23:34:02 <shachaf> "aSegmentation fault
23:34:07 <shachaf> Erm.
23:34:16 <Nereid> lol
23:34:18 <shachaf> Anyway, I have no idea what's going on there.
23:35:12 <notdan> :t unsafeCoerce
23:35:13 <lambdabot> Not in scope: `unsafeCoerce'
23:35:24 <edwardk>   Isos xs sx yt ty . Isos sa as tb bt = unsafeCoerce (Isos (sa.xs) (sx.as) (unsafeCoerce tb.unsafeCoerce yt) (unsafeCoerce ty.unsafeCoerce bt))  -- its now under control ;)
23:35:31 <notdan> What does unsafeCoerce do?
23:35:39 <edwardk> generally? it crashes your program
23:35:41 <zhulikas> the idea behinf unsafeCoerce is to allow developers write JavaScript instead of Haskell
23:35:50 <shachaf> zhulikas: No, that's Dynamic
23:35:54 <zhulikas> ahh, ok
23:35:56 <Nereid> notdan: unsafeCoerce :: a -> b
23:36:01 <shachaf> unsafeCoerce lets you write assembly instead of Haskell
23:36:02 <zhulikas> so there are multiple ways to do javascript in haskell
23:36:02 <zhulikas> ok
23:36:40 <zhulikas> so... changing types... I wonder what sort of magic will work with your code
23:36:53 <zhulikas> with that line full of unsafeCoerce
23:37:42 <notdan> oh ok
23:40:25 <Zarathu> So crose!!
23:42:23 <Nereid> oh
23:42:26 <edwardk> zhulikas: its generally inadvisable if you don't know what you are doing.    its also inadvisable if you _do_ know.
23:42:30 <Nereid> turns out that this groupBy' doesn't use any more memory than groupBy
23:42:37 <Nereid> in either case
23:42:44 <Nereid> so I'd say it's as good as it'll get
23:43:01 <hpaste> Zarathu pasted “So far...” at http://hpaste.org/78274
23:43:02 <Nereid> asymptotically, anyway
23:43:21 <Nereid> use null
23:43:26 <Nereid> ... | null points = shapes
23:43:52 <Zarathu> Ah! Okay
23:44:22 <Nereid> edwardk: how do you like my groupBy'.
23:44:36 <edwardk> ?
23:44:39 <Nereid> http://hpaste.org/78273
23:44:50 <Nereid> breaks up the list where the relation doesn't hold for adjacent elements
23:44:51 <Zarathu> Line 8 is obviously incomplete, but the idea is to pop each of the points off individually, find the shape that it's "connected" to, and add it to that shape.
23:45:05 <edwardk> Nereid: ah
23:45:12 <edwardk> :t nubBy
23:45:13 <lambdabot> (a -> a -> Bool) -> [a] -> [a]
23:45:14 <Zarathu> Otherwise (case of Nothing), it makes a new shape in 'shapes' with itself.
23:45:26 <Nereid> no, nubBy isn't it.
23:45:31 <edwardk> nm, my trick wouldn't work
23:45:35 <Nereid> hmm
23:45:39 <Nereid> what's your trick?
23:45:57 <Nereid> I guess I could even have put undefined instead of False.
23:46:08 <Nereid> but that's even more disgusting.
23:47:23 * hackagebot markdown 0.1.1.1 - Convert Markdown to HTML, with XSS protection  http://hackage.haskell.org/package/markdown-0.1.1.1 (MichaelSnoyman)
23:50:23 <Nereid> :t (,)
23:50:25 <lambdabot> a -> b -> (a, b)
23:50:41 <Nereid> :t curry id
23:50:43 <lambdabot> a -> b -> (a, b)
23:51:01 <xunatai> @src curry
23:51:01 <lambdabot> curry f x y = f (x, y)
23:51:11 <xunatai> @src uncurry
23:51:11 <lambdabot> uncurry f p = f (fst p) (snd p)
23:51:17 <Zarathu> Holy shit.
23:51:17 <xunatai> hm
23:51:19 <Zarathu> I think I did it.
23:51:35 <Nereid> :t zipWith (curry ?f)
23:51:37 <lambdabot> (?f::(a, b) -> c) => [a] -> [b] -> [c]
23:51:49 <Nereid> :t map ?f .: zip
23:51:50 <lambdabot> (?f::(a, b1) -> b) => [a] -> [b1] -> [b]
23:53:24 <xunatai> > uncurry $ (+) (2, 3)
23:53:25 <lambdabot>   Couldn't match expected type `b0 -> c0' with actual type `(t0, t1)'
23:53:39 <xunatai> herp
23:53:42 <xunatai> > uncurry (+) (2, 3)
23:53:43 <lambdabot>   5
23:54:13 <xunatai> > curry (+) 2 3
23:54:14 <lambdabot>   *Exception: show: No overloading for function
23:54:35 <xunatai> > curry (+) (2, 3)
23:54:37 <lambdabot>   *Exception: show: No overloading for function
23:54:46 <Nereid> > curry (\(x,y) -> x + y) 2 3
23:54:48 <lambdabot>   5
23:55:13 <Nereid> :t curry ?f ?x ?y
23:55:14 <lambdabot> (?f::(a, b) -> c, ?x::a, ?y::b) => c
23:55:31 <Nereid> I'm loving ImplicitParams now.
23:55:57 <notdan> > curry . uncurry $ (+) 2 3
23:55:59 <lambdabot>   *Exception: show: No overloading for function
23:56:20 <Nereid> > (curry . uncurry $ (+)) 2 3
23:56:22 <lambdabot>   5
23:56:29 <notdan> > curry . uncurry $ (+) $ 2 3
23:56:30 <lambdabot>   *Exception: show: No overloading for function
23:56:36 <notdan> darn
23:56:36 <Nereid> that doesn't work because $ is infixr
23:56:40 <notdan> yea
23:56:45 <Nereid> it should be infixl :(
23:56:49 <notdan> > (curry . uncurry) (+) $ 2 3
23:56:51 <lambdabot>   *Exception: show: No overloading for function
23:56:58 <notdan> > (curry . uncurry) (+) 2 3
23:57:00 <lambdabot>   5
23:57:14 <Nereid> curry . uncurry = id, uncurry . curry = id
23:57:25 <xunatai> @src (+)
23:57:25 <lambdabot> Source not found. You type like i drive.
23:57:27 <Nereid> (at least in the total fragment of haskell)
23:57:37 <Nereid> is it bad that I misread that as "you type like I derive"
23:57:38 <Nereid> :(
23:58:05 <Nereid> > ?x + 1
23:58:06 <lambdabot>   mueval-core: internal error: PAP object entered!
23:58:06 <lambdabot>      (GHC version 7.4.2 fo...
23:58:17 <Nereid> ahh, 7.4.2 :)
