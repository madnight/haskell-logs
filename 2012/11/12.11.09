00:10:29 * hackagebot bindings-libzip 0.10.2 - Low level bindings to libzip.  http://hackage.haskell.org/package/bindings-libzip-0.10.2 (SergeyAstanin)
00:10:43 <Sonarpulse> can I override haskells heirarchy naming conventions?
00:11:27 <Sonarpulse> I have named my programs nicely, but because this is a small project I don't intend on merging int othe repositories yet, I figure it would be easier to put things in the expected subdirectories
00:15:31 * hackagebot LibZip 0.10.2 - Bindings to libzip, a library for manipulating zip archives.  http://hackage.haskell.org/package/LibZip-0.10.2 (SergeyAstanin)
00:18:32 <Sonarpulse> Also, can a typeclass demand another typeclass is implemented?
00:19:39 <ivanm> Sonarpulse: class (Foo a) => Bar a where ...
00:19:48 <ivanm> ^^ that requires that a is an instance of Foo before it's an instance of Bar
00:20:03 <Sonarpulse> oh good
00:20:17 <ivanm> as for the hierarchy naming conventions; you can use your own structure if you want to run the risk of getting beaten by a lambda :p
00:20:36 <ivanm> but GHC, etc. tend to assume that Foo.Bar.Baz is in Foo/Bar/Baz.[l]hs
00:21:07 <Sonarpulse> is there to lets say, import by filename?
00:21:19 <Sonarpulse> I'll promise GHC I'll do it the right way later
00:21:38 <ivanm> well, when you say "I want module Foo.Bar.Baz", it knows where to look for it
00:21:51 <ivanm> otherwise, you'll need to manually provide a compilation order for your modules
00:22:12 <Sonarpulse> where would the complation order be?
00:22:51 <Sonarpulse> On a related note, I was thinking of making such a makefile so that people without haskell could just compile the last generated C
00:23:03 <Sonarpulse> if that is too much of a Hassle too then I think I will do it right
00:23:31 <ivanm> the compilation order would be that you would have to manually find an ordering for your modules such that if module A precedes module B in the list, then module A does not (transitively) import module B
00:23:39 <ivanm> and then shove them into a makefile
00:24:13 <ivanm> Sonarpulse: unless you're planning on getting GHC to spit out the equivalent C code (and is that even possible any more?) then you might as well use Cabal
00:24:29 <ivanm> though some people still use Make, or something like waf for larger projects
00:24:33 <ivanm> or because they hate Cabal
00:24:47 <Sonarpulse> I have this on github as a branch of another project
00:24:57 <Sonarpulse> that is part of my rational
00:25:11 <Sonarpulse> that other project has a lot of chaning-makefiles
00:25:21 <ivanm> well, you can use makefiles if you want
00:25:31 <ivanm> or waf, or <insert other build system here>
00:25:49 <ivanm> if you're relying upon "ghc --make", then you need the module name to filename correspondence
00:26:13 <ivanm> otherwise, manually compile each module in the correct order and then pass all those object files to GHC to link them together
00:26:18 <Jafet> You need more-or-less a copy of GHC to compile C intermediate code produced by GHC.
00:26:25 <Jafet> It is totally pointless
00:26:30 <ivanm> Jafet: yeah, that's what I was thinking
00:26:36 <ivanm> unless you used JHC or something
00:26:39 <Sonarpulse> the C code won't compile with gcc?
00:26:45 <Sonarpulse> or linking errors?
00:27:06 <ivanm> GHC does lots of mangling of the generated C code if you use -fvia-c
00:27:21 <Sonarpulse> ok, I give in
00:27:21 <ivanm> and it definitely requires gcc rather than any other C compiler
00:27:28 <Jafet> Yes, you will also probably need a copy of perl.
00:27:37 <Sonarpulse> then I definitely give in
00:27:42 <ivanm> @google building Haskell projects with makefiles
00:27:44 <lambdabot> http://www.haskell.org/ghc/docs/5.00/building/sec-makefile-arch.html
00:27:44 <lambdabot> Title: The Makefile architecture
00:28:00 <ivanm> dunno if that's actually helpful or not though :p
00:28:32 <Jafet> Yes, just downgrade to the middle ages
00:30:24 <Sonarpulse> ok, well for cabal/hackage
00:31:00 <shachaf> You can build Haskell projects with Makefiles.
00:31:14 <shachaf> GHC does it, for example.
00:31:15 <Sonarpulse> is this good?
00:31:15 <shachaf> That has nothing to do with going through C, of course.
00:31:18 <Sonarpulse> https://en.wikibooks.org/wiki/Haskell/Packaging
00:31:19 <osfameron> in the middle ages, they used to throw the output of Makefiles from windows onto the street with cries of "Gardyloo!"
00:32:24 <Sonarpulse> that's all darcs
00:32:54 <Sonarpulse> I would like to try drarcs, but in order to maintain some compatability with my existing project is it is probably best to stick with git for now
00:33:08 <ivanm> what does darcs have to do with it?
00:35:25 <Sonarpulse> i dunno, the link i just read was using darcs and cabal together
00:36:56 <osa1> what is the standard way of dealing with sockets in Haskell ? I mean, the library
00:37:40 <fmap> @hackage network
00:37:41 <lambdabot> http://hackage.haskell.org/package/network
00:38:18 <osa1> thanks
00:40:49 <Sonarpulse> ok, I have things in the connonical supdirectory
00:41:53 <neutrino> don't use darcs.
00:42:09 <Sonarpulse> yeah I am using git
00:42:15 <fmap> osa1: if you are (or want to be) familiar with conduits there is network-conduit
00:42:27 <fmap> @hackage network-conduit
00:42:28 <lambdabot> http://hackage.haskell.org/package/network-conduit
00:42:34 <Sonarpulse> hmm, emacs+ghci keeps on wanting to change directories
00:43:36 <osa1> fmap: I have no idea what a conduit is, should I use that ?
00:44:42 <ivanm> probably not if you're just starting out
00:44:51 <Sonarpulse> would what a good name be for a console fronted to my library?
00:45:12 <Sonarpulse> if such a thing is standardized
00:45:39 <osa1> hmm. where's the bytestring module referred in Network.Socket documentation: "Do not use the send and recv functions defined in this module in new code, as they incorrectly represent binary data as a Unicode string. As a result, these functions are inefficient and may lead to bugs in the program. Instead use the send and recv functions defined in the ByteString module." because link doesn't work
00:46:07 <startling> Data.ByteString, in the package `bytestring`
00:47:25 <Sonarpulse> you probably want Data.ByteString.Lazy
00:47:48 <fmap> osa1: Network.Socket.ByteString
00:48:05 <fmap> (.Lazy)
00:49:42 <Girls_Escort> Porn Sex Girls Escorts (double click)--> Eagle 1 http://fredfilms.blogspot.com
00:49:43 <Girls_Escort> Porn Sex Girls Escorts (double click)--> Eagle 1 http://fredfilms.blogspot.com
00:50:35 <Sonarpulse> so If a define a class, and import and instantiate that class in a bunch of modules
00:50:44 <Sonarpulse> then import the modules qualified
00:50:48 <ivanm> wow, took the spammer long enough to actually spam
00:51:01 <Sonarpulse> will the overloading still work?
00:51:12 <Sonarpulse> or would I have to do a normal import
00:51:20 <fmap> instances are always imported
00:51:35 <startling> I like how they say to double click.
00:51:35 <Sonarpulse> imported unqualified?
00:52:00 <fmap> they are not qualified or unqualified
00:52:07 <startling> Sonarpulse, instances don't have names.
00:52:28 <Jafet> @quote const.succ
00:52:29 <lambdabot> Jafet says: > (.)(.) id const succ 5$ 0xb00b135
00:53:17 <Sonarpulse> oh good
00:56:57 <Sonarpulse> so does this make sense? I am making a library for a bunch of related file formats
00:57:11 <osa1> @hoogle send
00:57:12 <lambdabot> Network.Socket.ByteString send :: Socket -> ByteString -> IO Int
00:57:12 <lambdabot> Network.Socket.ByteString.Lazy send :: Socket -> ByteString -> IO Int64
00:57:12 <lambdabot> Network.Socket send :: Socket -> String -> IO Int
00:57:26 <Sonarpulse> I have data/enum of games
00:57:39 <Sonarpulse> each module implements one game
00:57:45 <Sonarpulse> do I even need the enum?
00:57:56 <startling> Sonarpulse: what's a data/enum
00:58:04 <startling> Jafet: five? all at once?
00:58:16 <Sonarpulse> data = asdf | asdf2 | asdf...
00:58:23 <Sonarpulse> with deriving Enum
00:58:45 <startling> I dunno, do you need it?
00:58:49 <Sonarpulse> I dunno
00:58:56 <startling> ...
00:59:05 <Sonarpulse> what is the most haskell way of doing things?
00:59:16 <Sonarpulse> I want to assimulate here :D
00:59:32 <startling> Sonarpulse, do you ever use the Enum functions, like succ?
00:59:43 <Sonarpulse> nope
00:59:52 <startling> or [asdf .. asdf1]?
00:59:55 <Sonarpulse> not yet
01:00:03 <osa1> in a context where I use lazy bytestrings, bytestring's read from file function returns a lazy bytestring, right ?
01:00:09 <startling> Sonarpulse: okay, then you don't *need* it.
01:00:12 <Sonarpulse> ok
01:00:21 <startling> Sonarpulse: it's common to derive as much as possible, though.
01:00:26 <startling> in case someone needs it someday
01:00:36 <Sonarpulse> well I will need to make some sort of "dispatcher" which will read the begining of the mix file
01:00:55 <Sonarpulse> and do some magic bit things to try to figure out what type it is
01:00:59 <startling> Sonarpulse, I don't know what that means
01:01:11 <Sonarpulse> Mix is the name of the archive file I am implementing
01:01:18 <Sonarpulse> http://xhp.xwis.net/documents/MIX_Format.html
01:01:27 <startling> okay.
01:01:28 <Sonarpulse> it is like a shitty tarball
01:01:33 <startling> so what's your question?
01:01:55 <Sonarpulse> There exists a couple of versions of it corospounding to the different games it is used in
01:02:15 <Sonarpulse> Well I am wondering what the best way to "arrange" things is
01:02:30 <Sonarpulse> maybe my emum should be one of those dictionaries?
01:02:36 <startling> huh?
01:02:56 <Sonarpulse> isn't there some thing were the first argument to a class shows which instance to use?
01:03:04 <Sonarpulse> dictionary passing?
01:03:07 <Sonarpulse> I read about it
01:03:10 <Sonarpulse> it seems relevant
01:06:07 <shachaf> MIX :-(
01:06:23 <shachaf> Why are you implementing Westwood-MIX?
01:07:01 <Sonarpulse> to create a build system to assemble the tons of fan-made things for red alert
01:07:09 <Sonarpulse> and because only GUI tools exit ATM
01:08:27 <Jafet> I wonder if Red Alert 4 will use MMIX
01:08:39 <Sonarpulse> who knows
01:08:52 <Sonarpulse> I have barely played cnc3 and nother after
01:09:01 <cornihilio> I put this into Cabal/Distribution/Simple/LHC.hs https://gist.github.com/4043558 and I can't seem to trigger the debugging statement. does anyone know what I might be doing wrong?
01:09:14 <shachaf> Jafet++
01:09:24 <Sonarpulse> I don't know too much about the later games
01:10:01 <dcoutts> cornihilio: why are you playing with the LHC module? you're not using lhc are you?
01:10:39 <cornihilio> dcoutts: no, I'm not using lhc, I was just tracking where the package index was being generated.
01:11:00 <ivanm> is LHC still being worked on?
01:11:03 <Sonarpulse> hmm my setup would be "game-name implements mix"
01:11:12 <cornihilio> I noticed that there isn't a Filepath to where the package is installed (if it is): https://gist.github.com/4043327
01:11:53 <cornihilio> which is what I'm looking for since I thought listing by global/user would be a good place to start
01:11:59 <Sonarpulse> but it seems a bit weird to then call each version of the data definition itself by the game name
01:12:39 <shachaf> What?
01:13:07 <dcoutts> cornihilio: no, there's no specific "place where it is installed", since the various kinds of files can be in various places
01:13:11 <manju> How do you make a CArray ?
01:13:32 <dcoutts> cornihilio: but the key ones are the importDirs and libraryDirs, that's where the .hi files and .a files live
01:14:35 <hpaste> Sonarpulse pasted “Building the Typeclass” at http://hpaste.org/77470
01:14:49 <cornihilio> dcoutts: I saw this and just assumed that these were user/global places: https://gist.github.com/4044694
01:15:07 <Sonarpulse> the bottom gives me and error presumably saying that the typeclass can't also be the data type
01:15:18 <dcoutts> cornihilio: yes they are
01:15:23 <Sonarpulse> but isn't the typeclass also a datatype with a monad?
01:15:30 <shachaf> I don't know what you're doing but I don't think you want a type class.
01:15:48 <cornihilio> dcoutts: I guess I'm confused. How am I supposed to figure out the FilePath for where a package is installed?
01:16:09 <dcoutts> cornihilio: you don't need to know that, and in any case it's not a well-defined concept
01:16:30 <Sonarpulse> well I need a filesToMix and MixToFiles for each of the games, so I would think the overloading therein nessesitates it
01:16:40 <cornihilio> err.. than how am I supposed to be able to list packages by whether they are installed for the user/globally?
01:16:56 <dcoutts> cornihilio: but you're also confusing two things: what the build system does (with the --prefix etc), with what the compiler needs to know about installed packages
01:17:04 <dcoutts> cornihilio: oh, that's easy
01:17:29 <dcoutts> cornihilio: the user and global are two separate package dbs.
01:17:51 <cornihilio> where are they defined?
01:18:25 <dcoutts> cornihilio: notice in getInstalledPackages and other similar functions you have a PackageDBStack?
01:18:57 <dcoutts> cornihilio: type PackageDBStack = [PackageDB]
01:19:16 <dcoutts> and PackageDB is either a global, user or specific package db
01:21:31 <cornihilio> but the PackageDBStack is already chosen when the flags are being passed, right?: https://gist.github.com/4044723
01:22:37 <cornihilio> also I'm quite bad at Emacs and I don't know how to see calling code for a given function, especially one like "list". Does anyone know the right emacs key chord for that?
01:22:44 <cornihilio> key combo*
01:24:20 <Sonarpulse> can I have "typeclasss" a be a single datatype?
01:24:46 <Sonarpulse> so I an have something like
01:25:09 <shachaf> No.
01:25:15 <shachaf> I recommend: Forget about type classes.
01:25:30 * hackagebot Network-NineP 0.0.2 - High-level abstraction over 9P protocol  http://hackage.haskell.org/package/Network-NineP-0.0.2 (SergeyAlirzaev)
01:26:13 <Sonarpulse> ooo 9P
01:26:54 <ivanm> if you don't need the function-reuse of typeclasses, then why bother?
01:27:10 <Sonarpulse> well I would like that
01:28:00 <rodlogic> In "/they provide a free/ 'Binary' /instance/" what does a free instance mean?
01:28:40 <Sonarpulse> I guess I will use <gamename> as type for each of the mixes
01:28:47 <cornihilio> dcoutts: err I think I'm on the wrong page then. What sort of PackageDB is being passed to list?
01:28:52 <Sonarpulse> and worry about using it for unrelated thigns later
01:30:29 <dcoutts> cornihilio: take a look at the Main.hs for cabal-install, the listAction
01:31:01 <cornihilio> dcoutts: thank you very much! I'll attempt to grok that
01:31:17 <dcoutts> cornihilio: grep is your friend here
01:31:24 <dcoutts> cornihilio: so currently the package db flags comes just from the config file
01:34:30 <shachaf> Sonarpulse: Based on what you've said before I don't think you understand type classes well enough to use them.
01:34:39 <Sonarpulse> I am getting them better now
01:34:46 <shachaf> People tend to abuse them a lot when they they're learning Haskell.
01:35:11 <shachaf> You don't need to use type classes for abstraction.
01:35:20 <Sonarpulse> Even not comming from a OO background at all I would have thought they are still deemed cleaner
01:35:36 <Sonarpulse> than a slew similarly named functions
01:35:39 <Sonarpulse> that do similar thigns
01:37:40 <Nimatek> For someone coming from OO, typeclasses are probably more like interfaces.
01:38:00 <t7> almost exactly like interfaces ... ?
01:38:00 <lambdabot> t7: You have 1 new message. '/msg lambdabot @messages' to read it.
01:38:06 <shachaf> Not really.
01:38:08 <Sonarpulse> I meant to say I have no OO background
01:38:23 <Sonarpulse> sorry it lookes like I meant the opposite
01:38:23 <shachaf> Sonarpulse: See, exactly the thing I said. :-)
01:39:34 <Sonarpulse> i don't get it
01:39:49 <shachaf> @where antipattern -- example
01:39:50 <lambdabot> http://lukepalmer.wordpress.com/2010/01/24/haskell-antipattern-existential-typeclass/
01:40:11 <dfeuer> Is there any function for showing floating point numbers (specifically, Doubles) that guarantees that they will be read back in correctly, down to the last bit?
01:40:58 <dfeuer> I'm looking to generate source code for numerical tables.
01:41:17 <startling> where is 'text' from in blaze-html?
01:41:19 <ivanm> I doubt it
01:41:29 <ivanm> dfeuer: ^^
01:41:42 <ivanm> startling: load that module into ghci and do ":i text" ?
01:41:49 <ivanm> but my guess is a pretty-printer
01:41:57 <ivanm> blaze-markup or something?
01:41:58 <startling> ivanm, tried, it's not in the main module
01:42:10 <ivanm> startling: well, whichever module uses it
01:42:17 <startling> ivanm, oh, maybe Text.Blaze, sec
01:42:37 <dfeuer> ivanm: I've considered using decodeFloat to make the table and encodeFloat to use it, but 1) that's quite ugly and 2) I'm not sure if it will incur a run-time cost.
01:42:48 <ivanm> @hoogle decodeFloat
01:42:49 <lambdabot> Prelude decodeFloat :: RealFloat a => a -> (Integer, Int)
01:42:55 <startling> ivanm: nope. I don't see it in a specific module, just all the examples.
01:42:56 <ivanm> hmmm
01:43:30 <dfeuer> ivanm: Haskell98 has some bizarrely low-level functions available for screwing around with floating-point numbers....
01:44:10 <Sonarpulse> Ok read it. I mean, part of me doesn't understand why we can't give different functions the same name and let GHC sort out the over loading
01:44:11 <Ralith> dfeuer: if you replace 'show' with 'serialize' then sure
01:44:17 <Ralith> @hoogle ieee
01:44:17 <lambdabot> package ieee
01:44:18 <lambdabot> package ieee-utils
01:44:18 <lambdabot> package ieee754
01:44:24 <Ralith> probably the last of those
01:44:34 <ivanm> startling: where are these examples?
01:44:37 <dfeuer> Ralith: thanks! I'll check it out.
01:44:46 <Sonarpulse> also, I will making some other functions which are combinations of the ones that need to be implemented
01:44:48 <startling> ivanm, http://hackage.haskell.org/packages/archive/blaze-html/0.5.1.0/doc/html/Text-Blaze-Html5.html
01:44:49 <ivanm> Sonarpulse: then how will it know which one to choose?
01:44:58 <dfeuer> But will that produce something suitable for using in source code?
01:44:58 <Sonarpulse> that I don't think you can do with out type classes
01:45:03 <startling> ivanm: under doctTypeHtml -- "docTypeHtml $ span $ text "foo""
01:45:25 <ivanm> yeah
01:45:26 <Sonarpulse> ivanm, they are implemented in terms of functions that work on all of course
01:45:37 <Sonarpulse> also I will have m "dynamic dispatcher"
01:45:46 <ivanm> startling: any idea which span function that's referring to?
01:45:54 <ivanm> Sonarpulse: huh?
01:46:00 <shachaf> dfeuer: Well, the Report specifies IEEE, right?
01:46:02 <Ralith> dfeuer: hm, I suspect encodeFloat/decodeFloat is what you really want.
01:46:04 <Saizan> Sonarpulse: i guess that article is pointing out that if you have to introduce type distinctions that wouldn't be there just to make new typeclass instances then you're doing it wrong
01:46:30 <startling> ivanm, span in Text.Blaze.Html5
01:46:39 <startling> ivanm, html tag, not list function
01:46:45 <ivanm> yes, that's what I figured
01:46:57 <ivanm> why can't they use 'span' in their examples? :s
01:47:12 <startling> hmm?
01:47:14 <Saizan> Sonarpulse: but if you have already useful type distinctions then i think typeclasses are fine
01:47:22 <dfeuer> Ralith: I would want it, except for the fact that I doubt the pieces will be put together at compile time. Won't that wait till runtime, if I have, say, map (uncurry encodefloat) whatever?
01:47:34 <ivanm> startling: if they used 'span' in their markup for the examples, then the haddock docs would have a link to it
01:47:45 <Saizan> Sonarpulse: another situation where typeclasses might be a problem is if you want some forms of implementation inheritance that they don't support
01:47:52 <ivanm> oh, the examples are automagically generated
01:47:55 <Ralith> dfeuer: it's not clear what you're trying to do; do you want to guarantee that literals in Haskell code are interpreted consistently?
01:48:00 <Ralith> because that should already be the case.
01:48:00 <ivanm> hence the example of ` span $ span $ text "foo" '
01:48:02 <dfeuer> Ralith: also, there's a nagging concern about portability with those functions...
01:48:16 <ivanm> startling: my guess is that it's Text -> Html5
01:48:20 <ivanm> but hayoo is being obstinant
01:48:29 <Saizan> Sonarpulse: you can try and see if they work for you
01:48:55 <bartavelle> what's the name of the function that spawns eventlogs already ?
01:49:02 <dfeuer> Ralith: I'm trying to make tables of numerical constants (e.g., to improve the implementations of factorial, logFactorial, etc.)
01:49:05 <Sonarpulse> ok
01:49:12 <dfeuer> and they should be absolutely as precise as possible.
01:49:13 <Sonarpulse> sorry I was  reading
01:49:26 <dfeuer> Having the last bit or two be wrong isn't really okay.
01:49:50 <startling> ivanm, oh, it's in Text.Blaze.Internal?
01:49:56 <ivanm> is it?
01:49:59 <startling> yes
01:50:57 <Ralith> dfeuer: well, conversion from rationals is deterministic, but you might find relying on that to be a lot of work.
01:51:11 <startling> maybe it's not what I'm looking for, then. Blargh
01:51:29 <Sonarpulse> The basic issue is while I have truely distring types of mixes, the "unpack mix" function will always be  ByteString -> to mix ____
01:51:33 <Sonarpulse> and unlike normally
01:51:34 <startling> I just want to put some Text into an html document. what do I use for that?
01:51:49 <Sonarpulse> one can't just be picked based on the type constraints of use
01:51:54 <dfeuer> Ralith: I think I see what you're saying, and all I'd need is a function that takes a Double and produces a suitable rational....
01:52:05 <Sonarpulse> rather it's a dynamic thing which depends on the bytestring being read
01:52:10 <Ralith> dfeuer: and such a function is eminently writable.
01:52:16 <Sonarpulse> and can't be known ahead of time
01:52:23 <ivanm> startling: there's a text :: Text -> Markup function...
01:52:31 <Ralith> dfeuer: I mean hell, go look up the inverse and algebraically invert it.
01:52:36 <ivanm> startling: or maybe just see the source of the documentation generator?
01:52:39 <startling> ivanm: yeah, but it's Text.Blaze.Internal, so probably unsafe?
01:52:42 <Saizan> Sonarpulse: if you go with typeclasses you'll need an existential type there
01:52:49 <dfeuer> Ralith: I believe such a function is probably somewhere in Data.Rational, now that I think about it.
01:53:07 * Ralith wouldn't know
01:53:10 <Ralith> good luck!
01:53:11 <dfeuer> But it may not be so pretty...
01:53:15 <bartavelle> ok there IS a function somewhere that lets me put arbitrary stuff in the eventlog, right ?
01:53:21 <Ralith> the guts of FP never is.
01:53:40 <Ralith> (floating point math, that is)
01:53:49 <dfeuer> 1.3452244244434524*2^250 is a very large Rational.
01:53:54 <bartavelle> traceEvent
01:54:08 <Ralith> dfeuer: hm, that's a good point.
01:54:39 <Ralith> dfeuer: I'm still not completely clear on what's going on here--you're generating Haskell code with TH or something?
01:54:39 <ivanm> startling: gah, the documentation is auto-generated
01:54:47 <ivanm> so it's quite likely that the text function no longer exists
01:54:47 <dfeuer> One option might be to start by using show, and then automate the trial-and-error of mucking about with the last digit or two.
01:55:13 <ivanm> startling: closest I can find is the toHtml function
01:55:16 <dfeuer> Ralith: I might be, but I'm too new at this to know how to use TH.
01:55:17 <ivanm> that converts it to Markup
01:55:46 <dfeuer> So I'm just looking at the nasty technique of "copy program output. paste into source code."
01:56:13 <dfeuer> And now
01:56:25 <Ralith> dfeuer: if you're generating literals, you're already relying on GHC to inline Num implementations; if anything, inlining encodeFloat should be easier on it than that.
01:56:26 <ivanm> oh, I do that
01:56:28 <startling> ivanm: I think I'll just use 'text' for now and switch it if it causes problems.
01:56:37 <ivanm> startling: so text _does_ exist?
01:56:45 <startling> ivanm: yes, in Text.Blaze.Internal
01:57:01 <ivanm> which package is that in? I can't find it :s
01:57:05 <dfeuer> Ralith: you mean there's a chance GHC doesn't inline fromFractional for known Doubles???
01:57:06 <startling> blaze-markup
01:57:25 <Ralith> dfeuer: I have no idea. Ask a GHC person.
01:57:27 <dfeuer> Known Double literals, I mean???
01:57:36 <dfeuer> That would be ... really really stupid, if so.
01:57:38 <Ralith> dfeuer: but even if it *doesn't* inline them, I believe encodeFloat will be executed at most once per callsite.
01:57:51 <Ralith> dfeuer: it wouldn't be any more stupid than not inlining calls to encodeFloat.
01:58:16 <ivanm> startling: well, toHtml should also work; since Html is just a type alias for Markup
01:58:22 <ivanm> @hoogle toHtml +blaze-html
01:58:23 <lambdabot> Could not find some databases: blaze-html
01:58:23 <lambdabot> Searching in:
01:58:23 <lambdabot>   .
01:58:25 <dfeuer> Does the inlining look through maps?
01:58:25 <ivanm> bah
01:58:33 <Ralith> dfeuer: I don't know what that means.
01:58:35 <startling> ivanm: I'll take a look at it, thanks
01:58:54 <dfeuer> Because I don't want to have to have a table reading [encodeFloat 324 24, encodeFloat 5 52, .....]
01:58:57 <startling> ivanm: I feel like this is one of the main things you'd do with blaze. it's weird that this isn't clear.
01:59:18 <Ralith> dfeuer: would you rather have a table reading [..., 1.3452244244434524*2^250, ...]?
01:59:23 <Ralith> the former's tidier :P
01:59:31 <Sonarpulse> can I not export a data definition?
01:59:43 <Sonarpulse> I had type defined in a module, and no I am exporting it from another
01:59:46 <Ralith> ultimately, my advice is to do it right first, then worry about making it fast.
01:59:56 <ivanm> startling: yeah; doesn't help when the auto-generated docs are dodgy :/
02:00:03 <dfeuer> I'd most rather have a table reading 0x4eo849289*2^230   (or whatever)
02:00:04 <startling> ivanm: indeed.
02:00:04 <Sonarpulse> but in the first module uses where ghci asks for a "type or data constructer"
02:00:10 <dfeuer> um... leave out the o.
02:00:14 <dfeuer> That was supposed to be hex.
02:00:16 <shachaf> dfeuer: You can probably figure out questions about generated code easily enough. :-)
02:00:18 <Sonarpulse> work, and ones where it just wants a data construtore don't
02:00:19 <ivanm> Sonarpulse: use an explicit export list and don't include data type?
02:00:41 <Sonarpulse> I have module ( ) where
02:00:45 <Sonarpulse> if that is what you mean
02:01:06 <dfeuer> Ralith: of course, there is theoretically a problem where the floating point radix might not be 2....
02:01:16 <Ralith> dfeuer: I believe IEEE floats are specified.
02:01:32 <ivanm> Sonarpulse: with an empty export list?
02:01:33 <yiannis_t> Sonarpulse: do you want to export the type or the data constructor?
02:01:38 <Ralith> dfeuer: anyway, just emit encodeFloat calls, refer to other people for help checking if or ensuring that GHC inlines them, and use TH to make it prettier when you get around to it.
02:01:41 <Sonarpulse> no with File
02:01:46 <dfeuer> Not by Haskell98. Else it wouldn't have a function to ask for the floating point radix....
02:01:47 <Sonarpulse> the constructor for the data
02:02:09 <yiannis_t> Sonarpulse: you have to include something like that: MyType(..)
02:02:13 <quicksilver> if you have a big table, who cares encodeFloat gets inlined?
02:02:17 <quicksilver> it's only going to be called once anyway
02:02:31 <yiannis_t> Sonarpulse: i mean, inside the parenthesis..
02:02:32 <quicksilver> I mean, I'm pretty sure it will be but I can't see that it matters if it isn't
02:02:37 <dfeuer> Oh, I'm sorry, that's confused. But still, IEEE floats are more .... recommended than specified.
02:02:48 * Ralith shrug
02:02:52 <Ralith> it's generated code
02:02:55 <ivanm> Sonarpulse: you said "can I not export a data definition"; I took this as meaning you didn't want to export it :s
02:03:03 <Ralith> if you need to port it to a moon computer ten years from now, all you'll have to patch is the generator
02:03:25 <Sonarpulse> oh sorry
02:03:27 <dfeuer> I MUST SLEEP.
02:03:31 <dfeuer> Good night all.
02:03:36 * startling teleports up to his moon computer.
02:03:36 <Ralith> ...okay then
02:03:38 <Sonarpulse> well i actually opted for an inplicit export list
02:03:40 <Sonarpulse> and it worked
02:03:43 <ivanm> *sigh* if I want this unsafe (in the sense of being easy to mis-use) function to remain only exported via my .Internal module, I need to shift a lot more functions into the .Internal module :s
02:03:51 * Ralith switches all startling's radixes
02:04:02 <Sonarpulse> once I have all my "interfaces" figured out I will do explicit export
02:04:12 <shachaf> ivanm: You could make a separate .Unsafe module.
02:04:20 * startling attaches a balloon to Ralith, sending him into near-space orbit.
02:04:29 <Ralith> wheeee
02:04:52 <ivanm> shachaf: well, yes, but I want to export a function that uses this unsafe one safely from the main module, which is where all the functions the unsafe relies upon lives :s
02:06:07 <ivanm> shachaf: so either _everything_ lives in a private module and then re-exported either via the public module or .Internal, or else I export an unsafe function through my public one
02:06:51 <Ralith> ivanm: I haven't been following, but why can't you just use an explicit export list in the public module and omit the unsafe function?
02:07:07 <ivanm> Ralith: I want it exported as well, as it can be useful
02:07:23 <shachaf> ivanm: Well, you can split things up into more modules, I guess.
02:07:27 <Ralith> ivanm: so also re-export it from somewhere else?
02:07:32 <ivanm> it's a PlanarGraph n e -> Tree n function; but if the graph doesn't represent a tree then it will go on for all eternity...
02:07:51 <ivanm> shachaf: yeah, but then it makes it even more a PITA to find where everything is for maintenance
02:08:02 <shachaf> ctags, man
02:08:05 <Ralith> ^
02:08:11 <ivanm> sure, I've used them
02:08:13 <ivanm> still a pain
02:08:36 * Ralith misses SLIME's universally reliable M-.
02:08:58 <manju> let bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0),(8:+0)]::CArray Int (Complex Double)
02:09:03 <manju> Why is this wrong ?
02:09:07 <manju> > bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0),(8:+0)]::CArray Int (Complex Double)
02:09:09 <lambdabot>   <hint>:1:6: parse error on input `='
02:09:13 <ivanm> manju: what's the error?
02:09:15 <manju> > let bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0),(8:+0)]::CArray Int (Complex Double)
02:09:17 <lambdabot>   not an expression: `let bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0)...
02:09:36 <ivanm> > let bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0),(8:+0)] in bleh
02:09:37 <manju> No instance for (Foreign.Storable.Storable (Complex Double)) arising from a use of `listArray'
02:09:37 <lambdabot>   array (1,5) [(1,4 :+ 0),(2,5 :+ 0),(3,6 :+ 0),(4,7 :+ 0),(5,8 :+ 0)]
02:09:41 <ivanm> @type let bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0),(8:+0)] in bleh
02:09:43 <lambdabot> (Num i, Num a, Ix i) => Array i (Complex a)
02:10:19 <ivanm> manju: well, there's your answer: if you want to use that array type, you need a Storable instance for Complex Double
02:10:41 <ivanm> any particular reason for using CArray (whatever it is) rather than normal Array ?
02:10:46 <manju> ivanm, I don't understand what that means.
02:10:54 <ivanm> manju: then why are you using that array type?
02:11:08 <manju> ivanm, the fftN function accepts only a CArray Complex a0 type
02:11:30 <manju> So I need to convert my input to a CArray Complex a0
02:11:41 <ivanm> which fftN function is this?
02:11:59 <manju> (FFTWReal r, Ix i, Shapable i) => [Int] -> CArray i (Complex r) -> CArray i (Complex r)
02:12:08 <manju> dftN
02:12:13 <ivanm> manju: Storable is used by the Haskell FFI; it tells GHC how to lay out a Haskell value in memory
02:12:21 <ivanm> @google haskell Complex Storable
02:12:23 <lambdabot> http://hackage.haskell.org/package/storable-complex-0.2.1
02:12:23 <lambdabot> Title: HackageDB: storable-complex-0.2.1
02:12:38 <manju> ivanm, Ah...
02:13:43 <Sonarpulse> what does this mean?     `filesoMixIO' is not a (visible) method of class `Mix'
02:14:04 <shachaf> It means you wrote instance Mix Blah where filesoMixIO = ...
02:14:08 <shachaf> But it doesn't belond there.
02:14:09 <Sonarpulse> the former being a function I am trying to define and the later a the class name
02:14:19 <shachaf> Also, it means you're using a type class. You probably shouldn't be doing that.
02:14:28 <startling> shachaf: such a h8r
02:14:36 <manju> Ah...ivanm thank you :-)
02:14:38 <Sonarpulse> in this case I am pretty sure I should
02:14:49 <Sonarpulse> what do you mean by "belong there" ?
02:15:06 <yiannis_t> Sonarpulse: it 's not a function of that class
02:15:17 <shachaf> startling: I am.
02:15:26 <yiannis_t> you shouldn't put it in the instance definition
02:15:41 <Sonarpulse> oh I think I know what the problem is
02:23:16 <HugoDaniel> is there any obfuscated haskell contest ?
02:25:20 <doomlord> lenses...
02:25:25 <doomlord> lol
02:25:32 * hackagebot http-conduit 1.8.2.1 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.8.2.1 (MichaelSnoyman)
02:26:04 <doomlord> obfuscated haskell - write everything as custom operators? all your functions infix called *:><><><:* etc
02:26:49 <doomlord> whilst generally being an amazing language... it provides amazing obfuscation ability to with [i]that[/i]
02:27:17 * barrucadu saw some horrific Haskell code that would probably do pretty well in such a contest
02:27:35 <barrucadu> A primality tester. Written as if Haskell were Lisp, and as if Lisp were lambda-calculus
02:28:01 <barrucadu> Everything was one huge block of anonymous functions. All functions only took one argument. Parens everywhere...
02:28:38 <startling> if only it had been a lambda calculus interpreter!
02:28:44 <barrucadu> If only
02:28:47 <startling> then it might be able to be self-hosting.
02:28:54 <barrucadu> Oh god
02:29:02 <startling> haha
02:29:12 * startling should write that.
02:30:15 <ivanm> @google haskell easter egg
02:30:17 <lambdabot> http://www.haskell.org/pipermail/haskell/2000-December/006297.html
02:30:17 <lambdabot> Title: old easter egg
02:30:32 * hackagebot hgeometry 0.1.0.0 - Geometry types in Haskell  http://hackage.haskell.org/package/hgeometry-0.1.0.0 (FrankStaals)
02:30:56 <ivanm> HugoDaniel: OK, that's not what I was after, but someone did a Haskell program that looked like a faberge egg or something, but when you ran it it was a web server with a message
02:31:14 <ziman> obfuscation needn't be syntactic; you might employ so much abstraction that the result is unintelligible despite its full readability :)
02:31:26 <ivanm> HugoDaniel: anyway, there's always http://www.haskell.org/haskellwiki/Obfuscation
02:32:07 <HugoDaniel> :D
02:32:13 <HugoDaniel> great
02:32:41 <Sonarpulse> what do you do to make (f1 . f2) if  f2 :: a -> b and monad m => f1 :: b -> m c
02:32:57 <ivanm> huh?
02:33:09 <Sonarpulse> lift will make (m c) (n (m c))
02:33:12 <ivanm> oh, right, f1 :: (monad m) => b -> m c
02:33:14 <Sonarpulse> * liftM
02:33:29 <ivanm> where's the problem?
02:34:02 <ivanm> @type (f1 :: Monad m => b -> m c) . (f2 :: a -> b)
02:34:03 <lambdabot>     Not in scope: `f1'
02:34:03 <lambdabot>     Perhaps you meant one of these:
02:34:03 <lambdabot>       `f' (imported from Debug.SimpleReflect),
02:34:04 <Sonarpulse> actually f2 :: monad m => m a -> b
02:34:10 <ivanm> oh
02:34:14 <ivanm> @type (>=>)
02:34:16 <lambdabot> Monad m => (a -> m b) -> (b -> m c) -> a -> m c
02:34:16 <Sonarpulse> so i can't promote f2 either
02:34:35 <ivanm> Sonarpulse: are you sure that's right? how do you get the `b' out of the monad?
02:34:51 <Sonarpulse> good question
02:35:06 <ivanm> if it's really f2 :: (Monad m) => m a -> b, then f1 . f2 :: (Monad m1, Monad m2) => m1 a -> m2 c
02:35:32 * hackagebot hipe 0.1.0.0 - Support for reading and writing ipe7 files (http://ipe7.sourceforge.net)  http://hackage.haskell.org/package/hipe-0.1.0.0 (FrankStaals)
02:35:34 <ivanm> HugoDaniel: http://pastebin.com/6kfwTsB0
02:35:48 <Sonarpulse> nevermind f1 and f2 are both from a type to a monad of another type
02:35:57 <Sonarpulse> f2 :: a -> m b
02:36:04 <Sonarpulse> f1 :: b -> mc
02:36:24 <ivanm> then it's either >=> or just use >>=
02:36:38 <Sonarpulse> ok
02:37:37 <Sonarpulse> so f2 >>= f1 ?
02:38:05 <shachaf> >=>
02:38:09 <Sonarpulse> ok
02:38:16 <shachaf> You can fit the types together yourself. :-)
02:38:26 <startling> why doesn't highlighting-kate have haddocks? >:(
02:38:46 <Jafet> #haskell -Wall -O2
02:39:05 <Jafet> @hackage highlighting-kate
02:39:06 <lambdabot> http://hackage.haskell.org/package/highlighting-kate
02:39:25 <ivanm> startling: by default it tries to use regex-pcre-builtin
02:39:28 <Jafet> Because it didn't build
02:39:32 <ivanm> which is regex-pcre with added C files
02:39:35 <ivanm> and that failed to build
02:39:37 <startling> ivanm: ah
02:39:57 <ivanm> I saw Audrey upload a new version of that the other day, so the next version of highlighting-kate will hopefully build
02:40:30 <ivanm> you could always go back a few versions
02:43:18 <ramses_> @pl \x -> (length x, head x)
02:43:19 <lambdabot> liftM2 (,) length head
02:43:44 <ivanm> ramses_: an alternate version is: length &&& head
02:43:51 <ivanm> @type length &&& head
02:43:52 <lambdabot> [c'] -> (Int, c')
02:46:25 <Jafet> :t map (length &&& head) . group . sort
02:46:27 <lambdabot> Ord c' => [c'] -> [(Int, c')]
02:48:35 <ramses_> okay, what are the exact semantics of &&& ?
02:48:40 <hpaste> Sonarpulse pasted “Building the Typeclass” at http://hpaste.org/77471
02:49:28 <Sonarpulse> Still not working for some reason
02:49:59 <ramses_> I see they are an arrow thing, I was planning to read up on them but haven't done so yet
02:50:00 <startling> ramses_: runs two arrows on a thing and produces two-tuple of the results
02:50:19 <startling> ramses_: functions are instances of Arrow, so it works for functions.
02:50:37 <Jafet> http://ro-che.info/ccc/12.html
02:50:48 <startling> what's the thing to unload modules in ghci?
02:50:56 <Jafet> :m -
02:51:07 <startling> thanks
02:52:34 <Sonarpulse> anybody fix mine?
02:53:27 <startling> Sonarpulse, you're going to have to go in more detail than that.
02:53:42 <Sonarpulse> did you see my hpaste?
02:53:49 <startling> yes..
02:54:07 <Sonarpulse> well the last two functions have a type error
02:54:20 <shachaf> You're almost certainly abusing type classes, Sonarpulse.
02:55:11 <ramses_> I'm actually a bit confused by the liftM2 version that lambdabot gave me
02:55:15 <Saizan> Sonarpulse: filexMixIO won't work because there's nothing the compiler can use to pick which type to use
02:55:19 <ramses_> :t liftM2 (,)
02:55:20 <lambdabot> Monad m => m a1 -> m a2 -> m (a1, a2)
02:55:24 <ramses_> :t liftM2 (,) head
02:55:26 <lambdabot> ([a1] -> a2) -> [a1] -> (a1, a2)
02:55:27 <startling> Sonarpulse: I'm not that good at type-checking. Luckily we have programs that can do it for us nowadays.
02:55:28 <Saizan> Sonarpulse: for the Mix methods you use there
02:55:30 <neutrino> :t (&&&)
02:55:32 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
02:55:34 <ramses_> how do these types work out?
02:56:06 <Saizan> ramses_: Control.Monad.Instances has a Monad ((->) r) instance
02:56:28 <Sonarpulse> hmm, it's too generic?
02:56:40 <Sonarpulse> well when I put it in the class definition it didn't like it either
02:57:00 <ramses_> Saizan: ah, that might explain it, but I'll have to write that out
02:57:08 <Saizan> Sonarpulse: it won't like it anywhere
02:57:28 <Saizan> Sonarpulse: also types are case sensitive, so [file] is not the same as [File]
02:57:35 <Sonarpulse> is there anything I can do about that?
02:57:46 <Jafet> Would it like it in a house? Would it like it with a mouse?
02:57:48 <neutrino> is it usual that lambdabot does not respond to :t in query?
02:57:53 <shachaf> Yes.
02:57:56 <neutrino> it does respond to @type
02:57:59 <shachaf> You can use @ty instead.
02:58:01 <neutrino> why is that so?
02:58:07 <shachaf> Quirk.
02:58:11 <neutrino> ok
02:58:55 <Sonarpulse> time to look up dynamic types i guess
02:58:59 <killy9999> I'm reading "Parallel Performance Tuning for Haskell" article and they are using operator I am unfamiliar with: >->
02:59:08 <killy9999> does anyone have an idea what does it denote?
02:59:13 <Sonarpulse> because filesToMix can tell at runtime
02:59:14 <neutrino> @hoogle (>->)
02:59:15 <lambdabot> No results found
02:59:22 <killy9999> hoogle and hayoo don't show any results
02:59:32 <neutrino> interesting
02:59:36 <neutrino> i've seen it once before
02:59:50 <killy9999> well, OK - hayoo shows one, but that is definitelyu not what they are using
03:00:35 <startling> Sonarpulse: ???
03:00:50 <ivanm> killy9999: maybe the paper defines what it is?
03:00:53 <startling> Sonarpulse: why not just have detectFileType and then dispatch on that?
03:01:03 <quicksilver> ask JaffaCake1 :)
03:01:15 <startling> Sonarpulse: or even have a sum type of all your file types?
03:01:20 <Sonarpulse> I could
03:01:39 <killy9999> ivanm: I skimmed the paper and it doesn't look like it is defined
03:01:41 <killy9999> http://research.microsoft.com/pubs/80976/ghc-parallel-tuning2.pdf
03:01:47 <killy9999> 3rd page, right column
03:02:22 <killy9999> from the context it looks like this is just a function composition
03:02:47 <killy9999> but if so I wonder why they didn't just use (.)
03:02:50 <Saizan> Sonarpulse: it's not just a problem of types, it's also a problem of having the logic for deciding which type to parse into somewhere
03:03:32 <Sonarpulse> for that "sum type"
03:03:43 <Sonarpulse> can I use Mix a => a
03:04:09 <Sonarpulse> as a type constraint or are they incompatable
03:04:32 <shachaf> killy9999: Maybe it's just function composition?
03:04:38 <shachaf> In the opposite direction, as in (>>>)
03:05:42 <quicksilver> maybe it was supposed to be >>> and some latex package misformatted it
03:05:45 <Sonarpulse> :t bool
03:05:46 <lambdabot> Not in scope: `bool'
03:07:02 <killy9999> shachaf: yeah, I think this would make sense
03:07:10 <killy9999> I wonder why tehy didn't define it...
03:07:25 <killy9999> :t Bool
03:07:26 <lambdabot> Not in scope: data constructor `Bool'
03:07:40 <Sonarpulse> (I meant to type that in ghci)
03:07:45 <killy9999> :i Bool
03:07:51 <Sonarpulse> but i got the right import so it works
03:08:02 <shachaf> killy9999: Control.Arrow has (>>>) = flip (.)
03:08:09 <shachaf> So maybe what quicksilver said.
03:08:13 <killy9999> mhm, I know
03:08:16 <killy9999> probably yes
03:08:34 <killy9999> looks like they ignored proofreading :)
03:09:59 <Sonarpulse> can I make a function return a type for my "what type of mix is this" predicate?
03:10:31 <killy9999> BTW, could you guys recommend a good tutorial on Arrows?
03:11:17 <killy9999> right now I know only a couple of functions from Control.Arrows, but would like to get an idea of what arrows are
03:11:36 <yiannis_t> Sonarpulse: "make a function return a type" what does this even mean?
03:12:04 <Saizan> yiannis_t: something of type ByteString -> * for example :)
03:12:05 <yiannis_t> maybe you could paste the intented type sig
03:12:09 <Saizan> yiannis_t: not possible though
03:12:45 <Saizan> Sonarpulse: well, it's not quite possible in plain haskell, but you could return the right parsing function, producing an existential
03:13:11 <Saizan> Sonarpulse: or take a continuation
03:13:13 <Sonarpulse> I saw something with data a | b | c | d
03:13:42 <Saizan> data T = A .. | B .. | C .. <- those are the sum types
03:13:47 <quicksilver> killy9999: arrows are functions which also have some kind of effect.
03:13:54 <Sonarpulse> http://www.joachim-breitner.de/blog/archives/398-Making-dictionary-passing-explicit-in-Haskell.html
03:14:11 <quicksilver> killy9999: in a similar (but not exactly the same) sense that monads are values/computations that also have an effect.
03:14:33 <killy9999> effect? like a side-effect?
03:14:39 <shachaf> Monadic actions. :-(
03:14:55 <Saizan> Sonarpulse: btw, maybe you should read more of whatever introduction to haskell you've chosen before you try to write such a program?
03:14:55 <shachaf> killy9999: Like the "effect" part of "side-effect", yes.
03:15:11 <Saizan> Sonarpulse: you'll get a better feeling for what the language has to offer.
03:15:36 <shachaf> ==Saizan
03:15:37 <Ralith> killy9999: except sometimes arrows are just functions.
03:15:48 <quicksilver> well that's the base case
03:15:50 <killy9999> I was wondering what effect does >>> have
03:15:54 <quicksilver> where the effect is nothing at all
03:15:59 <quicksilver> killy9999: >>> isn't an arrow.
03:16:02 <merijn> killy9999: Arrow composition
03:16:04 <Saizan> @where lyah
03:16:04 <lambdabot> http://www.learnyouahaskell.com/
03:16:06 <quicksilver> killy9999: >>> is a method (of arrows)
03:16:30 <Saizan> Sonarpulse: that's a good one btw ^^^
03:16:34 <quicksilver> the effect of "a >>> b" is the effect of a and then the effect of b
03:16:41 <quicksilver> where 'then' is a rather abstract notion.
03:16:55 <killy9999> mhm
03:17:18 <quicksilver> 99% of the time you see arrow combinators in this channel, it's the function arrow
03:17:20 <killy9999> I am also using &&& a lot in my code, because HLint suggested to do so, but I don't understand how that works
03:17:22 <quicksilver> then there are no effects involved.
03:17:31 <killy9999> which is something I don't like
03:17:33 <quicksilver> and the combinators are just "convenient combinators" for arrows and tuples.
03:17:35 <Ralith> :t (&&&)
03:17:36 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:17:40 <killy9999> to have a code in my program that I don't understand
03:17:47 <quicksilver> if you just use &&& on functions, there is nothign to understand.
03:17:50 <Sonarpulse> I haven't really read an introduction
03:17:58 <quicksilver> it's just a nice way of writing \x -> (f x, g x)
03:18:05 <Sonarpulse> but I have done some functional and static typed
03:18:06 <Saizan> Sonarpulse: then go with  http://www.learnyouahaskell.com/
03:18:16 <Saizan> Sonarpulse: which languages?
03:18:18 <Sonarpulse> I was reading bits of that out of order
03:18:24 <Ralith> killy9999: "Arrow a => a b c" can unify with "b -> c"
03:18:29 <Sonarpulse> Scheme (typed racket)
03:19:25 <Saizan> that's sufficiently different that you should take a proper look at a haskell introduction
03:19:32 <killy9999> quicksilver: I know, but I don't understand that from its type signature :/
03:19:47 <Ralith> killy9999: (->) is an Arrow.
03:19:49 <Sonarpulse> ok
03:20:07 <Saizan> killy9999: well, you also have to look at the code for instance Arrow (->)
03:20:10 <Ralith> (->) b c is another way of writing b -> c
03:20:29 <Saizan> though in this case free theorems would be enough, i guess
03:20:32 * hackagebot mighttpd2 2.8.3 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.8.3 (KazuYamamoto)
03:20:55 <Ralith> @djinn (b -> c) -> (b -> c') -> b -> (c, c')
03:20:55 <lambdabot> f a b c = (a c, b c)
03:21:11 <yiannis_t> Monad (->) and Arrow (->) are somethings that I feel incapable of understanding :-$
03:21:30 <Ralith> Arrow (->) is just a few simple function combinators
03:21:34 <killy9999> I think I managed to understand Monad (->)
03:21:42 <Ralith> much easier than Monad (->), imo
03:21:42 <killy9999> lyah exaplains that quite well
03:22:42 <lolcathost> You mean Monad ((->) r)?
03:22:52 <yiannis_t> lolcathost: yeap exactly
03:23:00 <killy9999> yes
03:23:38 <Saizan> yiannis_t: do you understand the Reader r monad?
03:23:40 <quicksilver> killy9999: well I think all you need to do is understand how to substitue (->) into &&&'s type signature.
03:23:58 <yiannis_t> Saizan: quite well i think :)
03:24:02 <quicksilver> killy9999: you don't actually need to read the definiton for &&& because it's obvious there is only one thing it can do, once you see the signature.
03:24:17 <Saizan> yiannis_t: Monad ((->) r) is the same but without the newtype
03:24:18 <quicksilver> :t (&&&)
03:24:20 <lambdabot> Arrow a => a b c -> a b c' -> a b (c, c')
03:24:22 <killy9999> quicksilver: I guess that's one of the reasons I like Haskell
03:24:29 <killy9999> some functions can only do one thing
03:24:37 <quicksilver> killy9999: so, you just swap all the "a" for "(->)"
03:24:44 <quicksilver> and then, probably, rewrite it infix whichis more familiar
03:24:46 <Jafet> :t undefined :: (->) b c -> (->) b c' -> (->) b (c, c')
03:24:48 <lambdabot> (b -> c) -> (b -> c') -> b -> (c, c')
03:24:49 <quicksilver> but one step at a time
03:25:02 <quicksilver> (->) b c -> (->) b c' -> (->) b (c,c')
03:25:04 <killy9999> this makes sense
03:25:06 <quicksilver> ... is the same as
03:25:08 <_xvilka> Hi! Anyone know where I can find Yices sources? http://yices.csl.sri.com/download-yices2-full.shtml
03:25:15 <quicksilver> (b -> c) -> (b -> c') -> (b -> (c,c')
03:25:26 <quicksilver> so you have a function which takes a b and gives a c, a function which takes a b and gives a c'
03:25:28 <killy9999> I understand
03:25:34 <quicksilver> and you combine them in the only way you can
03:25:40 <killy9999> still, I'd like to get some general overview of Arrows
03:25:43 <quicksilver> f &&& g = \x -> (f x, g x)
03:25:46 <Saizan> _xvilka: email them?
03:26:01 <quicksilver> well arrows are like functions which do a bit of other stuff too.
03:26:07 <killy9999> Hughes' paper will bo good for that?
03:26:22 <quicksilver> apart from functions, the most common ones come from monads
03:26:23 <Jafet> Try and get the source to Vampire, while you're at it
03:26:27 <quicksilver> a -> IO b is an arrow
03:26:38 <quicksilver> a -> m b for any monad m, in fact.
03:26:50 <_xvilka> Saizan: nevermind, thx
03:27:03 <quicksilver> you have to look quite a long way to find interesting arrows which are neither plain functions, or a -> mb "Kleisli arrows"
03:27:22 <lolcathost> How about (w a -> b) for any comonad?
03:28:07 <notdan> Hi guys! I am working on a model checker in Haskell, and I have a bunch of questions, since I am not a pro. So, first of all, what do you think might be a good state graph representation? Right now I am using FGL and I don't have much problems with it, altho in a bunch of places my code looks messy. And the second question is kinda vague. So, in model checking, a lot of algorithms are imperative, I managed to translate a bunch of algos to more or less ...
03:28:07 <notdan> ... functional Haskell, but using fixpoint, which I think is quite slow. Should I abandon the functional paradigm and start writing code in State monad?
03:28:49 <lolcathost> notdan: What would be a good state graph representation? --> Depends on what you intend to do with it.
03:29:35 <notdan> Well, traverse it a lot, mark nodes, etc
03:29:40 <killy9999> quicksilver: thanks
03:29:59 <Ralith> quicksilver: has anyone written a really good arrow-based parser yet?
03:30:03 <killy9999> I'll spend some time later trying to wrap my head around this
03:30:15 <killy9999> reight now I'm going back to paper on parallelism
03:30:26 <Jafet> notdan: what is a model checker like
03:30:47 <Saizan> Ralith: they switched to Applicative
03:30:57 <earthy> ralith: why would you want an arrow-based parser? an applicative is better
03:31:04 <Saizan> Ralith: and then figured out how to also make a Monad instance
03:31:18 <notdan> Jafet: well, my current implementation marks the nodes of a graph with formulae which are true in that state
03:31:27 <Jafet> earthy: so you can use Alternative like all the cool kids
03:31:29 <Ralith> Saizan: I remembered something about it arrows enabling better errors; did that turn out false?
03:31:34 <Jafet> Hm wait
03:31:51 <Jafet> That's Applicative
03:32:10 <earthy> better errors is mostly a matter of structuring the parser's grammar
03:32:44 <Saizan> Ralith: not sure what you're referring to there
03:32:57 <ramses_> @pl (\idx list -> list !! idx)
03:32:58 <lambdabot> flip (!!)
03:33:02 <Ralith> probably won't be able to find the page again; it was a while ago
03:33:28 <neutrino> notdan: you are trying to prove a model written in some language, you translated it to haskell, and are trying to prove that?
03:33:39 <Ralith> Saizan: what were you referring to?
03:33:49 <Jafet> I believe model checking is something like SAT solving
03:33:52 <Jafet> @hackage fgl
03:33:53 <lambdabot> http://hackage.haskell.org/package/fgl
03:34:04 <Saizan> Ralith: http://hackage.haskell.org/package/uu-parsinglib-2.7.4 <- that Swiestra moved to Applicative
03:34:10 <notdan> Yeah, I am using fgl atm
03:34:24 <Jafet> Is fgl fast
03:34:53 <notdan> neutrino: well, no. Rather I have a model (as a graph) as a Haskell datatype and a formula (in temporal logic, in my case)
03:35:01 <Ralith> Saizan: how's it compare to parsec?
03:35:20 <notdan> Jafet: well, I can't compare it to anything, but I've been told it's quite decent on small datasets (<gb)
03:35:51 <neutrino> notdan: and you're trying to ensure that the formula does not go outside the graph?
03:36:32 <Saizan> Ralith: "New version of the Utrecht University parser combinator library, which provides online, error correction, annotation free, applicative style parser combinators. "
03:36:52 <Ralith> Saizan: :P
03:36:54 <Ralith> fair enough
03:36:57 <Jafet> Well, if you want it to be as fast as a C program, you just need to write it like a C program
03:37:02 <Saizan> Ralith: http://www.cs.uu.nl/wiki/bin/view/HUT/ParserCombinators
03:37:09 <Ralith> ah, thanks
03:37:18 <neutrino> Einstein proved that Haskell can't be faster than c
03:37:21 <Jafet> In particular, you probably shouldn't do backtracking with a pure datastructure
03:38:02 <Sonarpulse> asm, faster than light
03:38:02 <notdan> neutrino: well, not sure what do you mean by "does not go outside the graph", but kinda
03:38:15 <Jeanne-Kamikaze> you can always roll some ST in that case
03:38:25 <neutrino> notdan: a state graph is usually a space of all transformations of a data structure from one state to another.
03:38:49 <Jafet> fgl has an IOArray graph, which you can fill with IORefs or some other silly thing
03:38:50 <neutrino> notdan: it is common to prove that all transformations you will perform on a data structure fit within that graph.
03:39:12 <Saizan> Jafet: you mean you shouldn't do backtracking at all?
03:39:58 <Jafet> Backtracking is a cool guy
03:40:03 <Sonarpulse> if I have a function :: ByteString -> a
03:40:12 <Sonarpulse> does a have to be static?
03:40:23 <Jafet> But yes, I wouldn't do him
03:40:39 <Saizan> a function ByteString -> a is impossible to do sanely
03:40:52 <Jafet> Sonarpulse: a function in a typeclass is not one function. It is a different function for each instance of the typeclass
03:40:57 <Saizan> because you're promising to be able to produce any 'a' that the caller asks you to
03:41:53 <Sonarpulse> I could do the sum class thing you mentioned earlier, and like what was in the post  Ifound
03:42:14 <Jafet> Sonarpulse: what is the result of (read "3")?
03:42:24 <Sonarpulse> but will I have to through out all my typeclasses then?
03:42:42 <Sonarpulse> hmmm interesting
03:43:08 <Sonarpulse> actually thought you meant 3
03:43:39 <Sonarpulse> yes ambiguous error
03:43:57 <Jafet> Ok, then what is the result of (show (read "3"))
03:44:25 <Sonarpulse> shoudl also be ambiguous error i presume
03:44:40 <Sonarpulse> well another error
03:44:51 <Jafet> Ok. So what is the result of mixToFiles (filesToMix x)
03:45:04 <Sonarpulse> I get that that is the same thing
03:46:36 <Jafet> So what is your question about
03:49:16 <startling> so for my markdown parser, I need to parse out span-level tags so I can get at the markdown inside of them. How should I represent these in my AST?
04:04:08 <efie> I want to try parallel programming and checked first if multiple cores are recognized with "getNumCapabilities >>= print". This gives me 1, I compiled with +RTS -N2. Shouldn't this print 2?
04:04:31 <shachaf> You want to *run* with +RTS -N2
04:04:48 <shachaf> You're telling GHC to use two cores, which isn't much use.
04:06:09 <Jafet> To compile TWICE AS FAST
04:07:15 <efie> shachaf: thanks. what do you mean by which isn't much use?
04:07:58 <efie> ah, this referred to compiling
04:08:09 <shachaf> Yes.
04:23:31 <fruitFly> any of you know about haskell web frame works
04:23:39 <fruitFly> ?
04:26:16 <solirc> fruitFly: maybe try #yesod or #snap
04:26:41 <shachaf> Or #haskell-web
04:26:41 <fruitFly> isn't snap only unix
04:26:50 <fruitFly> what about happstack?
04:26:59 <fruitFly> solirc:
04:27:15 <fruitFly> shachaf:
04:27:43 <shachaf> fruitFly: #haskell-web's topic mentions Yesod, Snap, and Happstack.
04:28:14 <fruitFly> shachaf: thanks
04:34:46 <cornihilio> I'm using haskell-mode installed from elpa for emacs 24 and it's really messing with the formatting
04:34:56 <seit> I'm trying to work with some openGL examples.  I need to get a (Data.Vector.Storable Word8  -> Ptr Word8) function.  Any ideas?
04:35:11 <cornihilio> I'm working with cabal code and my tabs are screwing everything up
04:35:56 <beaky> hello
04:36:01 <beaky> is if then else a function?
04:36:08 <shachaf> No.
04:36:09 <Botje> nope.
04:36:13 <Botje> @source if'
04:36:14 <lambdabot> if' not available
04:36:25 <beaky> so they are keywords?
04:39:55 <neutrino> there are no ternary functions in haskell
04:40:12 <neutrino> or rather ternary operators, sorry
04:40:58 <parcs`> seit: unsafeWith
04:41:56 <tasslehoff> Where do I start? I have coded much in other languages (c, c++, python, bash), and want to learn the basics of Haskell.
04:42:16 <Botje> follow along with LYAH?
04:42:22 <seit> parcs`: Sorry, I'm missing this still.  The type for unsafeWith is "Vector a -> (Ptr a -> IO b) -> IO b" ?
04:42:29 <Botje> or possibly real world haskell immediately
04:42:59 <seit> parcs`, I'd like "Vector a -> Ptr a"
04:43:43 <Botje> so do unsafeWith vec return
04:43:49 <parcs`> don't
04:43:58 <Botje> oh, because.. right.
04:44:06 <Botje> damn type system :P
04:44:26 <hayashi> mmm, type system
04:44:50 <parcs`> seit: perhaps you want unsafeToForeignPtr?
04:45:07 <parcs`> er, perhaps unsafeToForeignPtr will be sufficient
04:45:08 <tasslehoff> Botje: as in learnyouahaskell.com, I guess?
04:45:17 <Botje> yep
04:45:31 <tasslehoff> thanks. I'll give that a try
04:45:39 <parcs`> seit: a function Vector a -> Ptr a is unsafe, because when the ForeignPtr gets GCed then the Ptr gets GCed
04:45:52 <neutrino> tasslehoff: msg
04:46:06 <seit> parcs`, hmm.  The openGL data constructor I'm trying to create is: "PixelData PixelFormat DataType (Ptr a)"
04:46:55 <seit> Where PixelData, PixelFormat, DataType are straight forward algebraic parameters.  The "Ptr a" part is the problem
04:47:04 <solirc> Hm, how would I go about bindings to a C++ library, write a thin C wrapper?
04:47:59 <parcs`> seit: do you plan on texImage'ing the pixel data right away?
04:48:25 <seit> parcs`, yes.  I'm calling the drawPixels function
04:49:48 <parcs`> seit: then 'unsafeWith' will do the trick. it would look something like 'unsafeWith vector $ \ptr -> do let pixel_data = PixelData ... ... ptr; drawPixels pixel_data
04:50:08 <seit> parcs`, ah, I see.  Let me give it a shot.
04:52:46 <cornihilio> hey, what does this error mean?: https://gist.github.com/4045533
04:53:04 <seit> parcs`, Great! It builds, thanks
04:53:06 <cornihilio> I've used Debug.Trace before, I think in an absolutely similar manner, and I didn't have any issues with it
04:53:24 <seit> parcs`, it segfaults, but that is another problem :-)
04:53:35 <parcs`> seit: hehe
04:54:56 * nand`school waves
04:55:32 <parcs`> cornihilio: line 9 doesn't make sense. specifically, 'config <- ...' doesn't make sense all by itself. anyway, you can just use putStrLn instead of trace since you're in the IO monad
04:56:47 <parcs`> cornihilio: perhaps you wanted 'config <- Trace.trace "Hello" $ loadConfig verbosity (globalConfigFile globalFlags) mempty'
04:56:49 <cornihilio> parcs`: what do you mean about the 'config <- ..'? that was there before me, I only added the Trace stuff
04:57:04 <cornihilio> oh, okay, that's what you meant :)
04:58:08 <Botje> cornihilio: you can't do that..
04:58:23 <Botje> cornihilio: you're already in IO so why not just use print?
04:58:48 <Botje> cornihilio: or, if you insist, config <- Trace.trace "hello" $ loadConfig ...
05:01:38 <nand`school> What would be the opposite of 'lift'?
05:01:43 <cornihilio> Botje: ah, thank you
05:01:44 <bartavelle> I am using the renderString implementation described in http://hackage.haskell.org/packages/archive/bytestring/0.10.2.0/doc/html/Data-ByteString-Builder.html
05:02:02 <bartavelle> it is very slow, much slower than (BB.string8 . show)
05:02:07 <cornihilio> if I'm running 'cabal build' in cabal-install, how would I run the built binary?
05:02:11 <bartavelle> anything I am doing wrong ?
05:05:13 <parcs`> cornihilio: it should be inside the dist/ directory somewhere
05:08:48 <cornihilio> okay my code looks like this: https://gist.github.com/4045597 I am running the right binary, and it's not printing the extra values out. what did I screw up?
05:10:32 <parcs`> cornihilio: if it's not printing anytthing then the function is not getting called
05:10:42 <parcs`> listAction, that is
05:19:03 <nand`school> know what isn't fun? manually downloading, building and installing dependencies
05:19:11 <nand`school> this system doesn't have a package manager..
05:20:07 <ivanm> nand`school: get a pkg manager for ~/ ?
05:20:23 <ivanm> gentoo-prefix, nix, I think possibly you can even install a subset of fedora in ~/
05:20:51 <nand`school> ivanm: probably more complicated; I don't know if portage will run out of hte box even if I had a python interpreter, it's not a POSIX-compatible system; and I can't make it one with the rights I have
05:21:03 <nand`school> since that requires kernel patches
05:21:21 <ivanm> oh, yay :s
05:21:35 <ivanm> well, nix is written in C if memory serves
05:21:39 <ivanm> so you don't have the python issue
05:23:13 <nand`school> I'm not sure if it even has a half-working C compiler
05:23:24 <nand`school> oh, wait, there's a port of gcc
05:23:43 <nand`school> Either way, I'd like to know where exactly cabal installs packages to with --user
05:23:50 <nand`school> I don't seem to have a ~/.ghc
05:24:07 <Jeanne-Kamikaze> .cabal ?
05:24:24 <ivanm> Jeanne-Kamikaze: the actual libraries should be installed to ~/.ghc
05:24:27 <nand`school> doesn't seem to exist either
05:24:33 <ivanm> huh
05:24:34 <ivanm> weird
05:24:39 <Jeanne-Kamikaze> ah
05:24:43 <dcoutts_> nand`school: if you do cabal configure -v, it will tell you how the prefix, libdir, datadir etc etc resolve
05:24:51 <Jeanne-Kamikaze> install as in pkg-register or whatever it is ?
05:24:53 <ivanm> nand`school: ghc-pkg list should say which DB's it knows about
05:25:00 <Jeanne-Kamikaze> that
05:25:17 <dcoutts_> nand`school: it follows the autoconf/configure system of --prefix --libdir etc.
05:25:39 <dcoutts_> nand`school: the ~/.cabal/config gives the defaults for these for --user and --global
05:25:52 <ivanm> dcoutts_: he said he doesn't have a ~/.cabal/
05:26:05 <ivanm> which if he's run cabal-install, he should have... >_>
05:26:24 <nand`school> dcoutts_: thanks; it's in %APPDATA%
05:27:26 <dcoutts_> ah, windows, yes.
05:28:05 <nand`school> ivanm: I never mentioned cabal-install :P
05:28:26 <ivanm> nand`school: oh, you said "cabal" rather than Cabal...
05:28:36 <ivanm> and most people just say "cabal" when referring to cabal-install
05:28:39 <nand`school> ah
05:28:43 * ivanm has mainly given up on correcting people about that
05:29:25 <osa1> why this program fails with stack overflow: http://hpaste.org/77474
05:29:35 <nand`school> Can I splice something :: Q [Dec] in GHCi?
05:29:42 <nand`school> or do I need to write a file for it
05:30:07 <osa1> seems like forM uses recursion, I was expecting it to use accumulator and tail recursion
05:30:18 <ivanm> osa1: I'm going to guess that it's due to over-laziness
05:30:35 <ivanm> @src forM
05:30:35 <lambdabot> forM = flip mapM
05:30:52 <osa1> hmm
05:30:53 <ivanm> @type getStdRandom
05:30:54 <lambdabot> (StdGen -> (a, StdGen)) -> IO a
05:31:11 <ivanm> osa1: why are you doing 1000000 IO calls for random numbers?
05:31:38 <osa1> ivanm: I'm just generating random bytes
05:31:41 <ivanm> take 1000000 . randomRs (0,2^7)
05:31:46 <ivanm> @type take 1000000 . randomRs (0,2^7)
05:31:48 <lambdabot> (Num a, RandomGen g, Random a) => g -> [a]
05:32:05 <ivanm> osa1: ^^ get a seed and then use that!
05:32:35 <nand`school> speaking of cabal-install, that would make this recursive downloading/building of dependencies a lot easier
05:32:56 <nand`school> is there a list of libraries I need to manually download and compile somewhere to get cabal-install to run? so I don't have to recurse into each library's configure dialog
05:33:12 <_Null> Burpaline: The wonder world.  Salmy magoo goal greggats  Rump duh duh duh dump, duh duh duh demp doop dump, runna nuh nah  Riggity ass gaggags  iNiCC  Roddan raldwell  Roady carewell reggal mahole  Rup tup shmelly smelly shmebb ub.  Roady farewell rose bose mahaggal.  A pocahontas watch
05:33:13 <ivanm> there's a bootstrap list
05:33:14 <_Null> Blubbity ash hoosh her mellopath.  a Maticake for my buddy andy  Oh we-heh-heh-hell I'm thinking about the greg nargs, I'm thinkin about you!  End midal too walkin' with a dolphin.  I went up that street, you went up another street, we all up the presidio.  I'm goin out with arsenio!
05:33:20 <_Null> My mensan boyfriend got his ear pierced today, rum dum dacka lacka rum dum jay  Go out with jay, another blue jay we fixed my astercoil plather  I'm hickin' my dagger  Rum dickily toon witherspoons.  I'm a falcons baleiva work with the yake my 7'9'er forever tumchy tither
05:33:21 <_Null> i wrote my life story on my poop pad.  one of the greatest art exhibits of 1999 was in a new york museum of art.  In it, cow poop or fecal matter was put on a copy of the painting called "The Last Supper".  This was thought to be a form of modern art.  chumpin up the rears.  Rubb blillick bath.
05:33:21 <_Null> The shiny dot in the middle of the light blue circle or ring is glowing silver in color like steel or real silver.  Eating pings, eating pies, Snow quibbicker bather I'm a niner!  That's right I'M A NINER!  Dipoke when we dip oh blip we dip, chucka hand oh blip we dip.  yxoukcil polk jhaggel.
05:33:21 <ivanm> @where ops
05:33:22 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
05:33:23 <_Null> Whether muh luck lick whither spoons.  wups to the umpteenth hicka low daggal.  cckocket tlopres redda ropres HUCK DICKILI DOON!  Feelie wheelie whilla maluck lick.  Slimy boo beggats.  I'm saggat I'm zeggat ziggurats.  Poop is pee.  My name is Mr. Pochahantas.  I'm a cartoon or movie character.
05:33:23 <_Null> They put me on a watch today, sometimes I pee sometimes I'm James!  Whoodas pratts my nig names chats.  Challa-hoe banchee with a proodas made.  I'm chilly I'm child ugly daves don't go wild.  My wild, ugly boss suddenly became thin  frint glint chip.  chip chip microchip.  chip chip microchip!
05:33:25 <_Null> My little greg narg, My little greg narg, I have freedom of speech rights!  My little greg narg, my little greg narg, you wish I didn't have rights!
05:33:27 <_Null> Nockaragathan dick slam!  Chilly chilla choe-lal-lip!  Scuh loo lathian buck seats  Moan mlutha mah-lee black mam.  rudda doo din-ump dah doo-nah-nah
05:33:29 --- mode: ChanServ set +o dcoutts_
05:33:30 <_Null> Waar chawecka wipth wella jalipth  All kinds of |\|iggers and buffy-oh juice!  I'm bagging ack the hag.  Ran a plucky plunky item plains!  Bagging the nig nag.  Bagging like green grags.
05:33:31 <_Null> How do you wreck liss me.  Those fuckin' farts.  Wonter... a cloody a millickal bath.  Slurpy slick ass lots of pep  It's like scotch pithy.  I'm thinking about ruggity greggal.  Juvenile detention centers.  Slurpy pitch pot pee.  No likes.  Wobbity willow willa whop.  Willy wallow traps.  You can combine one or more of the darameters.
05:33:33 <_Null> I'm trhinking about the rich ass mechgeggals.  I'm thinking about the rich ass micgeggals. Cham cham chack a leek a horn teen!   Poot wardy whail wo hootin tood!  Holla hoolah hope, laser whip!
05:33:35 <_Null> Rabby dab runna ma nay  I'm dabster deester and I'm here to say... rump tump tigga ligger rump tump tay!  Frucky duck with the wenner hoopler wheel  Cruckity puck on an ass hole  Death bones doesn't like dlo flo.
05:33:35 --- mode: dcoutts_ set +b *!*mylittle@183.160.111.128
05:33:35 --- kick: _Null was kicked by dcoutts_ (_Null)
05:33:42 <shapr> Thanks
05:33:46 <typoclass> thanks dcoutts_
05:33:48 <ivanm> I'm hoping someone just accidentally piped a script in rather than doing it maliciously
05:33:52 <Sonderblade> what is the best http client library for haskell?
05:33:54 <nyc> Sorry I didn't step in fast enough.
05:33:56 <shapr> I need a script :-|
05:34:00 <ivanm> but it almost reads like the poetry from the Vogons
05:34:24 --- mode: ChanServ set -o dcoutts_
05:35:10 <osa1> ivanm: what will be the difference if I use take 10000 . randomRs instead ?
05:35:21 <t7> computer generated poetry ?
05:35:24 <typoclass> Sonderblade: i don't have any overview of http libraries, but http-conduit is easy to use, works well, and is nicely documented
05:35:35 <ivanm> it will be pure
05:35:38 <ivanm> and not in IO
05:35:46 <ivanm> and thus probably cheaper
05:36:05 <ivanm> also, no need for an explicit loop
05:36:16 <bartavelle> typoclass, Sonderblade : I also use http-client, but you have to be prepared for it to pull a lot of dependencies. Not sure if other libraries have the same problem.
05:36:22 <ivanm> you can use randomRs in your getStdRandom call as well if you'd prefer
05:36:51 <Sonderblade> bartavelle: that's not a problem for me
05:37:33 <bartavelle> the executable I am working on right now weights 53MB
05:37:43 <ivanm> osa1: also, your "return ()" is useless there, as BS.writeFile :: FilePath -> ByteString -> IO ()
05:37:48 <bartavelle> it is a profiling build though
05:37:54 <ivanm> osa1: oh, and why use fromIntegral? pretty sure Word8 is an instance of Random
05:37:57 <ivanm> @instance Random
05:37:58 <lambdabot> Maybe you meant: instances instances-importing
05:38:02 <ivanm> @instances Random
05:38:02 <lambdabot> Couldn't find class `Random'. Try @instances-importing
05:38:07 <typoclass> bartavelle: urgh, wow
05:38:11 <ivanm> @instances-importing System.Random Random
05:38:12 <lambdabot> Bool, Char, Double, Float, Int, Integer
05:38:33 <ivanm> yup, Word8 is an instance
05:38:36 <bartavelle> typoclass, yeah I should clean the imports a lot :(
05:38:48 <beaky> l
05:38:50 <ivanm> @hoogle IO StdGen
05:38:50 <lambdabot> Did you mean: :: IO StdGen
05:38:51 <lambdabot> No results found
05:39:06 <ivanm> isn't that what I searched for? :s
05:39:58 <osa1> ivanm: thanks. using randomRs solved stack overflow problem
05:40:11 <ivanm> osa1: so you can just say: do { g <- newStdGen; let l = take 1000000 $ randomRs (0, maxBound); BS.writeFile (path </> file) (BS.pack l) }
05:40:14 <Sonderblade> bartavelle: typoclass: i need something that supports 304, automatically following redirects, gzipped content, timeouts, changing user-agent..
05:40:30 <bartavelle> oh wow, no clue about this
05:43:52 <typoclass> Sonderblade: http-conduit follows redirects and does gzip. user-agent stuff should be a matter of setting a header. not sure about the other things
05:44:38 <ivanm> osa1: in general, doing random stuff in IO is wrong :)
05:44:52 <osa1> ivanm: random stuff ?
05:44:58 * ivanm -> sleep
05:44:59 <cornihilio> is there something like Debug.Trace but instead allows for logging?
05:45:14 <ivanm> osa1: getting random values
05:45:21 <ivanm> cornihilio: Writer monad?
05:45:56 <osa1> ivanm: can you explain or at least give me some pointers to learn why ?
05:45:57 <Jafet> {-# NOINLINE trace #-} trace s x = unsafePerformIO (hPutStrLn stderr s) `seq` x
05:46:14 <Jafet> That is Debug.Trace
05:46:30 <ivanm> osa1: because it's faster to get the seed and do it purely
05:46:46 <ivanm> otherwise, each time you make a call in IO, it has to get the current seed and set it again
05:46:51 <ivanm> which involves disk access, etc.
05:47:22 <ivanm> anyway, I'm off
05:49:14 <quicksilver> what ivanm said is not true
05:49:29 <quicksilver> there is no disk access involving in updating the global RNG seed.
05:49:53 <quicksilver> I'm not sure that the IO way will be measurably slower, but as ageneral rule it's certainly nicer not to bring in IO if you're not really using it.
05:50:49 <bartavelle> there is the monadic bind
05:50:57 <bartavelle> hum
05:50:59 <bartavelle> with State too :)
06:00:36 * hackagebot biosff 0.3.1 - Library and executables for working with SFF files  http://hackage.haskell.org/package/biosff-0.3.1 (KetilMalde)
06:01:53 <deech> Besides wxhaskell are there any other examples of exposing an OO C++ library in Haskell?
06:02:05 <quicksilver> there are qt bindings aren't there?
06:02:18 <quicksilver> and GTK is an OO C library with bindings in haskell
06:03:56 <deech> quicksilver: That's true I'd forgotten about Qt. I was wondering if someone was able to make a binding that would look somewhat familiar to an OO developer.
06:13:42 <pordan30> @pl \f g (x, y) -> f x (g y)
06:13:42 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . ((.) .)
06:13:51 <pordan30> @pl \c f g (x, y) -> c (f x) (g y)
06:13:52 <lambdabot> flip flip snd . ((flip . (ap .)) .) . flip flip fst . ((flip . ((.) .) . flip . ((.) .)) .) . (.)
06:14:01 <parcs`> i think monads are hard to learn because most people do not yet have a firm grasp of the fundamentals of haskell, ie parametric polymorphism, type classes, ADTs, type constructors, purity (and its consequences) and so on, before beginning to read about monads. it's like trying to understand calculus without having a firm grasp on algebra
06:15:36 * hackagebot cabal-meta 0.4 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.4 (GregWeber)
06:16:23 <pordan30> i think monads are hard to learn because most people learn about monad from bad monad tutorials. i find the clearest explanation to be wadler's tutorial introductions, which present them as a triple of a type constructor and two operations satisfying three laws, and continue to provide examples. this is how any algebraic structure is introduced, and it's served mathematicians well for over a century.
06:16:28 <parcs`> then again trying to understand monads is a great way to help solidify your understanding of the fundamentals
06:20:08 <ivasilov_> pordan30: can you send some links to those tutorials?
06:22:39 <pordan30> ivasilov_: see "the essence of functional programming" and "monads for functional programming" at wadler's homepage, here: <http://homepages.inf.ed.ac.uk/wadler/topics/monads.html>
06:26:24 <ivasilov_> pordan30: great, thanks
06:34:34 <merijn> "You Could Have Invented Monads (And Maybe Already Have!)" is also a good one
06:34:55 <merijn> http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html
06:37:41 <mauke> you could have prevented monads
06:38:22 <dgpratt> mauke: :)
06:38:35 <S11001001> I love foldMap
06:43:46 <ivasilov_> what's interesting to me about monads is that everybody has their own definition
06:44:19 <ivasilov_> monads are like art - highly subjective
06:44:22 <pckt> Other than all mathematicians
06:44:26 <EvanR_> lol
06:44:29 <signalsea> ivasilov_: http://unknownparallel.com/monads.php
06:44:36 <EvanR_> theres also the definition in haskell
06:44:47 <EvanR_> one definition ;)
06:45:13 <EvanR_> haha zero chit chat
06:45:26 <EvanR_> i would put that page in peoples faces if i didnt think it would confuse them more
06:45:30 <EvanR_> except for the typeclass thing
06:46:00 <barrucadu> ivasilov_: Monads are burritos: http://chrisdone.com/posts/2012-01-06-monads-are-burritos.html
06:46:15 <barrucadu> All other definitions are inferior
06:46:29 <signalsea> what about spacesuits
06:46:35 <dgpratt> it seems to be a hallmark of fundamental concepts that there is usually more than one valid way of conceptualizing them
06:46:37 <pordan30> EvanR_: that is a great page
06:46:39 <pckt> I love all those types of tutorial "Think of monads as..."
06:48:16 <EvanR_> yeah it is
06:48:29 <EvanR_> not sure its good for the target audience of monad tutorials
06:48:36 <signalsea> my grasp still isn't fantastic but they made me feel lost until i stopped trying to "think of monads as xyz"
06:49:04 <EvanR_> its like eating a burrito in a spacesuit
06:49:48 <dgpratt> EvanR_: heh, sounds messy
06:49:50 <quicksilver> some people use analogies when first understanding mutable variables.
06:50:10 <quicksilver> I remember reading books which described variables as boxes / pigeonholes
06:50:14 <quicksilver> which had bits of paper in them.
06:50:32 <quicksilver> it's not such a surprising teaching technique - but the right technique depends on the audience.
06:50:37 * hackagebot cpsa 2.2.12 - Symbolic cryptographic protocol analyzer  http://hackage.haskell.org/package/cpsa-2.2.12 (JohnRamsdell)
06:50:51 <EvanR_> heh
06:50:59 <EvanR_> mutable variables with mutable objects in them
06:51:13 <EvanR_> analogies ahoy
06:51:48 <EvanR_> but what are mutable objects really
06:51:54 <EvanR_> >:)
06:52:00 <pordan30> there should be a series of tutorials: "monads are like tacos," "burritos," "chile rellenos," "tamales," and so forth.
06:52:31 <strg> why is the cook the instance?
06:52:43 <dgpratt> pordan30: stop it, you're making me hungry
06:53:06 <dgpratt> pordan30: and lunch is still 2 hours away
06:53:47 <quicksilver> this one, I think - http://www.abebooks.co.uk/book-search/isbn/0860206742/
06:53:55 <quicksilver> but there appear to be no pictures to remind me
06:57:03 <pordan30> are the newaxioms features going to be released with the next version of ghc? the latest status update says the implementation has been prototyped, and is nearly completed.
06:59:29 <Sculptor> hi!
07:02:07 <otters> I'm starting to become irritated with cabal-dev
07:02:18 <otters> every syntax highlighting tool appears to tell me that "this multiline\
07:02:21 <otters> \ string"
07:02:23 <otters> is the right way to do it
07:02:31 <otters> but my project will only compile with "this multiline\
07:02:33 <otters>  string"
07:02:49 <mauke> are you using haskell?
07:02:53 <otters> but that makes hlint throw a parse error and it breaks github's and vim's syntax highlighters
07:02:59 <otters> yes
07:03:10 <otters> what gives
07:03:17 <mauke> testcase?
07:03:25 <otters> hang on
07:04:26 <geekosaur> cpp involved?
07:04:57 <EvanR_> seems like an overreaction to monad tutorials to insist on 'no analogy'
07:05:15 <EvanR_> on the other hand the analogies seem necessary because of the weird jargon
07:05:21 <EvanR_> theres no java interface analogies
07:05:30 <otters> OMG
07:05:38 <otters> geekosaur: I had CPP enabled and I don't even know why
07:05:43 <otters> removing that from the cabal file fixed it
07:05:54 <fryguybob> nice
07:08:06 <pordan30> i like the "value in a computational context" analogy
07:08:30 <quicksilver> otters: don't use string gaps anyway they're ugly
07:08:41 <Jafet> @quote kmc synonymous
07:08:42 <lambdabot> kmc says: monads are like containers, as long as you forget everything you know about the meaning of the word "container" and take it to be a totally abstract word synonymous with "monad"
07:08:52 <quicksilver> (just my opinion)
07:09:01 <otters> quicksilver: part of the style guidelines in this project are to keep all lines below 80 characters (excluding indentation)
07:10:16 <quicksilver> otters: sure. there are reasons to break strings across lines.
07:10:24 <quicksilver> otters: I just find string gaps an ugly way to do that.
07:10:37 <quicksilver> I prefer the look of concat ["foo", "bar", "baz"]
07:10:42 <otters> oh, I see
07:10:42 <Gomes> hallow
07:10:42 <quicksilver> break lines after commas
07:10:51 <quicksilver> or, unlines instead of concat
07:10:54 <otters> yeah
07:10:56 <quicksilver> if you want a newline at each comma
07:11:04 <quicksilver> unlines ["foo","bar","baz"]
07:11:04 <otters> that's more runtime computation though, isn't it
07:11:10 <quicksilver> it's one-off
07:11:13 <quicksilver> who cares :)
07:11:20 <otters> >_>
07:11:31 <quicksilver> lazy + persistent values ftw.
07:11:55 <Jafet> Like it's going to take longer than the conversion of the data to String
07:13:19 <Jafet> So, I'm looking at Language.Haskell.Exts.Syntax and I see things like "xml element", "negated pattern", "regular patterns", "infix class assertion"
07:13:57 <Jafet> Does anyone even use XML patterns
07:14:40 <Jafet> > let neg (-x) = x in neg 1
07:14:42 <lambdabot>   <hint>:1:10: Parse error in pattern: - x
07:17:12 <quicksilver> Jafet: I hadn't heard of them until just now.
07:25:38 * hackagebot hspec 1.4.1 - Behavior Driven Development for Haskell  http://hackage.haskell.org/package/hspec-1.4.1 (SimonHengel)
07:26:42 <caseyjames> Hi, does anyone here have any experience installing GHC for ios
07:28:40 <Marenz> hu. I want to register at an experimental haskell wiki .. and I think it has a spam protection.. problem is, it is for people that know haskell
07:28:43 <Marenz> and .. it asks me
07:28:48 <Marenz> What is the type of 'head'?
07:29:05 <otters> :t head
07:29:07 <lambdabot> [a] -> a
07:29:17 <otters> head ∷ [a] → a
07:29:23 <Clint> what is an experimental haskell wiki?
07:29:37 <S11001001> trick question, real answer is Foldable f => f a -> a
07:29:37 <Marenz> http://haskellwiki.gitit.net/
07:29:44 <Cale> I doubt that the captcha will want unicode syntax
07:29:46 <otters> @hoogle head
07:29:47 <lambdabot> Prelude head :: [a] -> a
07:29:47 <lambdabot> Data.List head :: [a] -> a
07:29:47 <lambdabot> Network.HTTP.Base HEAD :: RequestMethod
07:29:47 <EvanR_> Marenz: you can find out the type of stuff at ghci
07:29:51 <EvanR_> Marenz: :t head
07:29:53 <EvanR_> :t head
07:29:55 <lambdabot> [a] -> a
07:29:59 <EvanR_> and in the channel
07:30:42 <mapf> :t let f = f in f f
07:30:44 <lambdabot> t
07:30:48 <Marenz> k, i think it worked
07:30:52 <Marenz> [a] -> a
07:30:53 <mapf> well done
07:30:53 <Marenz> thanks
07:31:02 <Clint> now you can spam to your heart's content
07:31:15 <otters> :t undefined undefined
07:31:17 <lambdabot> t
07:31:25 <mhernand1z> :t
07:31:26 <Marenz> It will be most joyest spam that will enlightgen your heart!
07:31:34 <Marenz> And penis.
07:31:39 <Marenz> *ahem*.
07:32:12 <EvanR_> forall a. [a] -> a
07:32:49 <mapf> it's considered harmfull to set non-default precedence to infix functions?
07:33:15 <otters> @pl \f g a -> (f a, g a)
07:33:15 <lambdabot> liftM2 (,)
07:33:24 <mapf> i would like to remove some parens
07:33:39 <mapf> i hate parens a bit
07:34:03 <rwbarton> maybe if the functions have names like plus and times it is okay
07:34:27 <mapf> rwbarton: intersection, union etc
07:34:54 <rwbarton> ah
07:34:56 <quicksilver> mapf: it's not really harmful but it is another thing users have to learn
07:35:18 <quicksilver> precedence is never really intuitive, but if you always use things a certain way it may be worth it to save the parents
07:35:35 <rwbarton> designing a good set of precedences is tricky
07:35:46 <mapf> quicksilver: so i think this way too
07:36:10 <otters> given properly defined instances, can you replace any do notation with equivalent arrow notation?
07:36:44 <rwbarton> intersection and union having the same precedences as (&&) and (||) seems pretty intuitive to me
07:36:54 <neutrino> == rwbarton
07:37:08 <mapf> :i (&&)
07:37:16 <mapf> pff
07:38:58 <Marenz> I think I'll start learning haskell.
07:39:06 <Marenz> to work on gitit2.
07:39:40 <neutrino> Marenz: what's wrong with gitit as it is?
07:39:50 <neutrino> serious question, i'm thinking of using it
07:40:19 <Marenz> neutrino, https://groups.google.com/d/msg/gitit-discuss/GV64xqX-XuU/dgdh3cAI2N4J
07:40:42 <Marenz> the paragraph "State of the Code"
07:41:23 <pordan30> can you override an predefined instance or cause such an instance not to import? i have some datatypes with streams in them, and want to override the show instance for streams to converge, for the purposes of interactively testing, without writing show instances for all the datatypes that take some number of elements fro the streams.
07:41:44 <quicksilver> no.
07:41:58 <quicksilver> just get used to testing with a print functon that does what you want, instead
07:42:07 <quicksilver> pordan30s_show_function (myStream)
07:42:16 <quicksilver> (you may well choose a shorter name like 'p')
07:42:21 <hdev> say I have an class I a where some :: [a], now I want to define a function fun = head some, which i want to call like fun :: ConcreteType - whats the type signature of fun?
07:42:47 <quicksilver> I a => a
07:42:58 <quicksilver> (which incidentally isn't a function)
07:43:11 <pordan30> quicksilver: too bad, but thanks for the response
07:43:35 <mapf> flymake in emacs seems to me pretty helpful sometimes. it's need a time to stick with though
07:44:07 <mapf> and with haskell it's work nice
07:44:29 <int-e> quicksilver: I know what you mean, but you will have a hard time claiming that it's constant.
07:45:04 <quicksilver> int-e: it's a polymorphic value.
07:45:17 <Marenz> neutrino, was that any pleasing answer to your question? :)
07:46:17 <hdev> quicksilver: it will give me an error ambigious type variable
07:46:42 <int-e> quicksilver: so it's a family of values, indexed by types. I really prefer to think of that as a function.
07:47:30 <quicksilver> int-e: if you like, sure. But it isn't the normal haskell sense of function.
07:47:36 <pordan30> hdev: unless you can infer which instance of I to use, you must provide a type annotation, e.g.: fun :: AMonomorphicType
07:47:46 <int-e> hdev: you have to give a type signature or use the NoMonomorphismRestriction language extension.
07:48:06 <quicksilver> pordan30: doesn't need to be a monomorphic type
07:48:14 <quicksilver> can annotate it as fun :: I a => a
07:49:23 <hdev> int-e: this is what I was missing, thanks
07:49:44 <pordan30> quicksilver: i assumed from the error he reported that he was testing `fun' at the prompt; annotating with the constraint will give the same error, no?
07:53:05 <quicksilver> pordan30: well it will give an error about not having a Show instance
07:53:22 <quicksilver> pordan30: I think. Not one about ambiguous types. If you annotate it.
07:55:49 <signalsea> I've been reading about lenses recently and am wondering, does a polymorphic signature like Functor f => a -> ((b -> f b') -> a -> f a') -> b  necessarily imply that every 'a' must somehow "contain" a 'b'?
07:56:33 <pordan30> quicksilver: it gives both errors
07:57:03 <ParahSail1n> i want to get some experience with eDSLs, and i'd like to do a JIT implementation of awk as an exercise
07:57:45 <ParahSail1n> the naive approach would be to make a haskell code generator from awk, but would there be a more elegant way?
07:58:21 <t7> > length "((() () ()) (() ()) ())"
07:58:23 <lambdabot>   23
07:58:30 <t7> perfick
08:00:53 <beaky> How difficult is it to write a finite state machine in haskell
08:00:53 <hdev> Is there a way to make a function fun _ = some with I a => a -> a, which i call like fun (undefined :: ConcreteType)?
08:00:55 <beaky> compared to C
08:01:40 <rwbarton> @type (^.)
08:01:42 <lambdabot> s -> Getting a s t a b -> a
08:01:56 <donri> lambdabot has lens now?
08:02:08 <rwbarton> yep
08:02:11 <donri> coolness
08:02:21 <rwbarton> hdev: exactly that should work, if you provide that type signature
08:02:36 <donri> hdev: also see proxies, e.g. package 'tagged'
08:02:41 <S11001001> @ty read -- hdev
08:02:42 <lambdabot> Read a => String -> a
08:03:23 <S11001001> hdev: i.e. you don't need the argument at all
08:04:10 <S11001001> @ty mempty -- hdev also...
08:04:11 <lambdabot> Monoid a => a
08:04:37 <rwbarton> signalsea: shouldn't it be "a -> (forall f. Functor f => (b -> f b') -> a -> f a') -> b"?
08:05:21 <signalsea> rwbarton: yuppers
08:05:59 <rwbarton> it says if you have a value of type (forall f. Functor f => (b -> f b') -> a -> f a') then you have a way to get a 'b' out of an 'a'
08:06:19 <rwbarton> and there are a couple ways you can see that this is true
08:07:02 <signalsea> rwbarton: such as?
08:07:53 <Iceland_jack> 16:00 < beaky> How difficult is it to write a finite state machine in haskell
08:08:17 <rwbarton> one is to think "how can i define v :: forall f. Functor f => (b -> f b') -> a -> f a', I don't know what f is, so I can only produce f a' by fmapping on f x for some other x, and the only other way to get an f x is to use the b -> f b' parameter"
08:09:10 <rwbarton> my only way to get something into f is to combine this a argument with this b -> f b' argument
08:09:17 <rwbarton> so, I have to have a way to get a b from an a
08:10:02 <rwbarton> Or, you can magically guess that it would be a good choice to pick f = Const b
08:10:26 <rwbarton> so that the type specializes (up to newtypes) to (b -> b) -> (a -> b), and pass it id
08:11:39 <cornihilio> dcoutts: what does this line mean?: https://gist.github.com/4046550
08:12:43 <dcoutts_> cornihilio: it's a filter condition
08:12:57 <SamanthaAD> Hello
08:14:07 <cornihilio> if I have added a new flag like "    onlyUser = fromFlag (listUser listFlags)", how would I modify that filter condition?
08:14:36 <cornihilio> I guess it's just a bit hard for me to understand what I should do with that line, because I'm pretty certain that's what I should be modifying
08:14:55 <pordan30> beaky: it's not difficult: you can model the dfa as a record containing a transition function, current state, and list of final states, and run your dfa over an input list by transitioning using your transition function, then recursing using the updated state.
08:14:55 <dcoutts_> cornihilio: you can add an additional filter condition of course
08:15:05 <signalsea> thank you rwbarton
08:15:14 <beaky> ah
08:15:16 <beaky> right
08:15:36 <hpaste> pmade pasted “Rock-paper-scissors” at http://hpaste.org/77478
08:15:49 <dcoutts_> cornihilio: but onlyUser is a bit different right? isn't the easiest way to do that to only get the user package db and ignore all others?
08:16:02 <pmade> I just pasted my first Haskell "app".  If anyone has time I'd love some feedback.
08:16:04 <dcoutts_> rather than getting all the package dbs and then filtering the result
08:18:14 <vjousse> Hi guys
08:18:48 <vjousse> Seems like I'm having the exact same issue that was posted here some days http://hpaste.org/76770
08:18:54 <vjousse> I'm trying to install darcs
08:18:59 <vjousse> with cabal install darcs
08:19:11 <vjousse> but cabal can't resolves dependencies
08:20:02 <cornihilio> dcoutts_: you're right,  I guess I got kind of offtrack
08:20:18 <dcoutts_> vjousse: the info is all there, but it is a bit hard to decipher
08:20:52 <dcoutts_> vjousse: notice where it says that darcs-2.8.2 needs base>=4 && <4.4
08:21:01 <vjousse> hmm indeed, I may need a translator here ;)
08:21:37 <vjousse> yep I see it, but my limited knowledge in the domain may not help me much
08:22:00 <dcoutts_> vjousse: and you have base 4.6
08:22:42 <dcoutts_> vjousse: and cabal cannot install another version of base for you, because there's a constraint that we must always use an existing installed instance of base, never a new one built from source.
08:22:54 <dcoutts_> (which is because that would not work)
08:22:56 <cornihilio> dcoutts_: I got to this point trying to figure out what the flags were storing, and this error is not helping: https://gist.github.com/4046629
08:23:11 <cornihilio> I'm not sure what to do since ConfigFlags derives Show
08:23:27 <vjousse> so I'm basically screwed up? :) As I suppose that if I have base 4.6, it's because something else is requiring it
08:23:56 <rwbarton> "base 4.6" means "ghc 7.6"
08:24:04 <dcoutts_> vjousse: it's because you're using ghc-7.6 I presume, which is newer than the general stable version which is 7.4.x
08:24:21 <rwbarton> (btw is there a table of base vs. ghc versions somewhere?)
08:24:27 <dcoutts_> cornihilio: oh, just don't show the whole flags, as you can see there's an undefined member.
08:24:30 <vjousse> hmm ok, that's often the downside of using archlinux
08:24:54 <dcoutts_> if arch linux is packaging only 7.6 and not 7.4, they're doing it wrong.
08:25:07 * nand` would like for literals to be moved out into their own typeclass like IsString; which doesn't have any other operations like Num and Rational do
08:25:26 <vjousse> they are packaging 7.6 by default indeed, and as it's a rolling release, it's what you have
08:25:38 <vjousse> so downgrading to 7.4 may do the trick I suppose
08:25:40 <cornihilio> dcoutts_: ah, okay. Thanks for pointing that out!
08:25:55 <dcoutts_> vjousse: rolling release isn't the problem. They should be packaging the Haskell platform version.
08:26:48 <hdev> I have \_ -> map f (some :: a) :: I a => a -> String, but it can't deduce the inner type a. How would I write this correctly?
08:27:16 <vjousse> yep indeed, I'll give 7.4 a try, as xmobar is not compiling with 7.6 neither
08:27:23 <vjousse> thanks for the tips guys
08:27:53 <Igloo> dcoutts_: It's tricky for distros. What version should they pick if they will be freezing a release soon which will still be in the stable release of that distro in 2 years time?
08:28:00 <parcs`> hdev: remove the type annotation on 'some'
08:28:16 <parcs`> hdev: the 'a' in some :: a is not the same a as in :: I a => a -> String
08:28:22 <geekosaur> the arch folks don't care abotu the platform, they always package the latest version.  all I can recommend is don't use arch if you want a setup that works
08:28:28 <dcoutts_> Igloo: they should always pick the latest stable platform, not some mixture
08:28:44 <rwbarton> hdev: or use your 'fun' from earlier
08:28:48 <dcoutts_> geekosaur: right, they just need to redefine their notion of "latest"
08:28:54 <rwbarton> map f . some
08:28:57 <vjousse> @geekosaur :D
08:28:57 <lambdabot> Unknown command, try @list
08:28:58 <rwbarton> er
08:28:59 <rwbarton> map f . fun
08:29:13 <vjousse> let me try to downgrade before wipping out my install
08:29:22 <pordan30> hdev: \x -> map f some won't type check unless some :: [a] for some a coinciding with the domain of f
08:29:23 <dcoutts_> geekosaur: I bet they don't push out the latest glibc and gcc as soon as they're released, breaking other things
08:29:27 <geekosaur> they don't care.  their policy is latest everything
08:29:44 <hdev> pordan30: that's a typo, i meant [a]
08:29:49 <vjousse> @dcoutts_ they sometimes do indeed
08:29:49 <lambdabot> Unknown command, try @list
08:29:51 <geekosaur> actually, they pretty much do.  distribution policy is latest everything
08:29:55 <dcoutts_> geekosaur: do they push out the latest gtk before it's included with gnome?
08:30:02 <geekosaur> often, yes
08:30:05 <dcoutts_> they're mad
08:30:06 <vjousse> yep
08:30:07 <dcoutts_> that will not work
08:30:10 <geekosaur> yes, yes they are
08:30:21 <vjousse> ok so guys, what are you using as a distro?
08:30:34 <parcs`> fedora for desktop, debian for server :
08:30:44 <Clint> debian for desktop, debian for server
08:31:14 <SamanthaAD> kubuntu for my laptop, xubuntu for my friends' computers
08:31:18 <kranius> freebsd
08:31:26 <t7> same as Clint
08:31:26 <geekosaur> I like debian for servers, mint for desktops; I don't get to do that often, my linux setups currently are all centos
08:31:29 <dcoutts_> geekosaur: but it's also meaningless, "latest release" is just a label. If we told them it was a release candidate right up to the point when the platform came out, they'd do the right thing.
08:31:32 <mapf> debian
08:31:38 <geekosaur> maybe
08:31:39 <t7> and xmonad obviously
08:32:36 <vjousse> yeah ok, I have to admit that I love the "last version" philosophy of Arch. Even if I thought that it was the last "stable/ready for production" version
08:32:40 <hdev> parcs`: some is not monomorphic, so I need to provide a type annotation which i can't because i don't return a value with that type, so i wanted to provide it as a parameter (undefined :: ConcreteType), am I missing something?
08:32:50 <geekosaur> dcoutts_, look around in list and IRC archives for when ghc 7.4.1 was released, arch moved to it and there was a lot of screaming and brokenness.  an arch dev was here trying to demonstrate how it wasn't really a problem, after a week or so of fielding constant problems they became quite silent...
08:33:11 <Clint> it's useful to have someone finding the problems on the cutting edge
08:33:12 <rwbarton> any debian user can tell you the last stable version of ghc was 6.12.1
08:33:12 <geekosaur> but they're still following the same policy
08:33:31 <geekosaur> (indeed, arch is the anti-debian-stable)
08:33:49 <mapf> rwbarton: lol no. 7.4.1
08:33:57 <dcoutts_> it's a pity, when dons ran the arch haskell packages, they worked.
08:34:03 <t7> stable = platform
08:34:07 <t7> = 7.4.2
08:34:08 <mapf> oh
08:34:19 <SamanthaAD> vjousse: if you want a rolling release I would recommend Debian stable. The problem with a bleeding edge rolling release like Arch is that often the software doesn't integrate like it ought to and things break. Arch is awesome if you have the time or the desire to tinker with the internals, though.
08:34:36 <Clint> SamanthaAD: you mean testing
08:34:45 <SamanthaAD> no, I mean stable ;)
08:34:50 <t7> why not debian sid, it seems more stable than arch
08:35:04 <ChristianS> debian testing is nice, though
08:35:15 <Clint> haskell is a bit broken in sid right now
08:35:19 <rwbarton> anyways i just expect to install ghc from the binary installer, not through my package manager
08:35:24 <SamanthaAD> But yeah, for a desktop Debian testing is just fine. It has Debian unstable to work out the major kinks in it.
08:35:36 <vjousse> SamanthaAP what I love with archlinux approach is the "do it yourself, you just have to read the awesome wiki". I love it better than having script doing some black magic to maintain the system
08:36:07 <kranius> why not gentoo then
08:36:38 <SamanthaAD> I do miss that a bit since I switched to Ubuntu from Arch... the thing is that it's not quite that simple. Arch still uses scripts to do black magic it's just that Arch's scripts like their input in the form of text files whereas everyone else likes what they used to call "wizards".
08:37:32 <mapf> http://xmonad.wordpress.com/2009/09/09/the-design-and-implementation-of-xmonad/ nice slides if someone didn't see
08:37:37 <SamanthaAD> To be quite honest, I didn't learn that much about how Linux, in general works from my tenure using Arch. I *DID* learn how Arch works, though.
08:37:48 <vjousse> sure :)
08:38:26 <SamanthaAD> I think if I was to really make a project of "learning Linux" again I would set up a Linux From Scratch box as an educational thingy and keep Ubuntu/Debian/Fedora on my production machine.
08:39:22 <vjousse> I may give debian a try at some point, even if I still see it as a dinosaur distro. It's maybe not the case anymore
08:39:38 <nand`> It would be awesome to be able to compare arbitrary types of kind * for equality in a type family
08:40:41 <mapf> nand`: there is no way either?
08:40:43 <hdev> rwbarton: I figured it out, if I use my fun from earlier, it works - thanks for that hint
08:40:53 <SamanthaAD> vjousse: It still is a dinosaur distro but who doesn't want a pet dinosaur?! In all seriousness, though, that's a selling point.
08:41:13 <nand`> mapf: what do you mean?
08:41:45 <mapf> nand`: i mean it's impossible compare types of kind * for equality.
08:41:48 <vjousse> Well, I'm not especially in love with dinosaurs, but I don't judge people who are ;)
08:41:54 <mapf> any(!) type of kind *
08:42:22 <nand`> why is this necessarily impossible?
08:42:40 <nand`> all it would need is basically something like a type family with a ‘base case’
08:42:40 <cornihilio> dcoutts: is this the code I should be changing?: https://gist.github.com/4046718 should I be working to add more flags that filter out the packageDB being created?
08:43:01 <nand`> but I guess that might be impossible
08:43:08 * edwardk waves hello.
08:43:09 <mapf> nand`: i mean it's impossible to do now in haskell
08:43:17 <nand`> oh, yeah
08:43:20 <nand`> thus ‘it would be awesome’
08:43:21 <mapf> not at all)
08:43:27 * copumpkin waves at edwardk 
08:43:50 <pordan30> it might be coming soon, though: http://hackage.haskell.org/trac/ghc/wiki/NewAxioms
08:43:56 <edwardk> no you didn't. you're head down in your cube =P
08:44:48 <vjousse> ok, I've recompiled everything with 7.4, whish me good luck :D
08:44:51 <jimch> .
08:44:57 <spaceships> SamanthaAD: do you use pacman for haskell packages?
08:46:12 <SamanthaAD> spaceships: Sorry, I'm *just* dipping my toes with Haskell so I might not be able to naswer your question perfectly. That being said, a quick check of my distros repository shows a *lot* of haskell dev packages so I'm strongly inclined to say "yes"
08:46:56 <vjousse> awesome, downgrading to 7.4 has fixed my xmobar problem too (it was hidden below my windows)
08:46:59 <vjousse> thanks a lot guys.
08:47:15 <atriq> edwardk, may I annoy you with a tiny (tiny!) grievance regarding lens?
08:47:23 <jimch> Why am I getting stack overflow errors when trying to build a not so big map?  I am parsing a 3 MB text file and storing word count in a map. Herr are the functions I wrote for creating a map: http://hpaste.org/77482
08:47:27 <edwardk> sure
08:47:36 <spaceships> SamanthaAD: me too, but i think im looking for a better way...
08:48:01 <jimch> I get stack overflow with both versions
08:48:02 <SamanthaAD> SamanthaAD: A better way than using the package manager?! That's crazy talk!
08:48:22 <edwardk> grieve away =P
08:48:25 <atriq> edwardk, the big image in the docs isn't hosted locally. Is it possible to put that in the cabal doohicky?
08:48:35 <spaceships> SamanthaAD: maybe so
08:48:38 <atriq> Because sometimes I code offline
08:48:52 <SamanthaAD> spaceships: What problem are you having with pacman?
08:49:10 <edwardk> i could probably be talked into it. its available in the lens wiki, its just more duplication
08:49:10 <edwardk> i used to have the lens wiki attached as a git submodule
08:49:43 <edwardk> but that led to headaches as submodules tend to do
08:50:17 <edwardk> atriq: i don't know how to get it to work locally with the haddocks though
08:50:17 <spaceships> SamanthaAD: i dont know how to make it play nice with cabal
08:50:35 <atriq> Okay
08:50:39 * hackagebot parsers 0.3.2 - Parsing combinators  http://hackage.haskell.org/package/parsers-0.3.2 (EdwardKmett)
08:50:47 <atriq> If I feel like it later, I'll take a look at it
08:51:20 <edwardk> if you can find a way that the doc lives in the repository and gets copied to the right place for haddock, i'm all for it
08:51:44 <spaceships> SamanthaAD: i think its a problem of me not being smart enough. hence asking how you are doing it :)
08:51:54 <parcs`> jimch: fyi there's 'Map.fromListWith'
08:53:46 <jimch> parcs`: ok but I am learning and wanted to write my own function. Any idea why I am getting stack overflow?
08:53:56 <SamanthaAD> spaceships: in all honesty, I don't. I'm coming here because I want to learn Haskell. I'm currently a Scheme user. That being said, if Haskell libraries work anything like C libraries what you need to do is to just use the package manager to install the dev package and then start using it...
08:54:00 <parcs`> jimch: you're building up a chain of applications of insertWith
08:55:38 <spaceships> SamanthaAD: aur has had most of what I want so far (i'm only a few months in myself).. btw, welcome.
08:55:42 <parcs`> jimch: try http://hpaste.org/77482
09:00:39 * hackagebot SHA 1.6.0 - Implementations of the SHA suite of message digest functions  http://hackage.haskell.org/package/SHA-1.6.0 (RaphaelJavaux)
09:00:44 <jimch> parcs`: I am getting stack overflow with your function as well. I will post full program
09:03:22 <SamanthaAD> spaceships: Thanks!
09:03:50 <jimch> Here, just redirect a few MB text file to stdin.  http://hpaste.org/77482
09:05:44 <nand`> :(
09:07:09 <SamanthaAD> spaceships: What coaxed you into learning Haskell?
09:07:11 <nand`> is there any way to make :: (c == Bar) ~ True => Foo -> c -- less ugly?
09:10:40 * hackagebot hat 2.7.0.8 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.8 (OlafChitil)
09:10:52 <copumpkin> whoa, hat is alive?
09:10:56 <edwardk> type When p = c ~ True; make :: When (c == Bar) => Foo -> c  -- ?
09:11:09 <edwardk> type When p = p ~ True
09:11:26 <nand`> hmm, perhaps
09:11:33 <edwardk> maybe something other than When
09:11:48 <nand`> maybe ‘ForAll’; because that reads better in this context
09:11:50 <mauke> copumpkin: yes, it's a magic hat
09:11:57 <mauke> otherwise it couldn't speak, you know
09:12:05 <nand`> I want to write Foo -> Bar but I can't
09:12:24 <edwardk> what is == in this setting?
09:13:04 <nand`> edwardk: (==) :: Unit -> Unit -> Bool; tests for equality under commutation
09:13:10 <nand`> eg m*s = s*m
09:13:38 <nand`> but if the actual calculation results in ‘m*s’ and I want to write ‘s*m’ in the type signature, I have to do it that funny way
09:13:41 <nand`> it's that or leave off the type signature
09:14:27 <nand`> actually, this doesn't work either
09:14:29 <nand`> hmm
09:14:36 <nand`> I guess I have to write them in the right order or leave off the type sigs
09:14:44 <nand`> that's a damn shame
09:14:48 <spaceships> SamanthaAD: hmm... scip, i guess. lots of compelling examples on the internet. the initial hump took a while
09:15:33 <spaceships> SamanthaAD: i mean sicp
09:17:41 <SamanthaAD> spaceships: What made you choose to migrate from Scheme to Haskell?
09:17:49 <parcs`> jimch: ah, sorry. my annotation is the same as your original definition of buildMap2, so it does nothing. you said buildMap1 also stack overflows?
09:18:18 <jimch> Yes, all the versions on that paste overflow
09:19:15 <jimch> Is this related to lazy evaluation, or is neither function tail recursive?
09:20:27 <jimch> As far as i can see buildMap1 should be tail recursive
09:21:48 <spaceships> SamanthaAD: default laziness is very cool. subjective: haskell seems fresher, more vibrant, modern. i could be wrong. also, the high quality of #haskell
09:21:53 <parcs`> jimch: perhaps you are getting a stack overflow from the addition
09:22:42 <parcs`> jimch: try the latest annotation
09:22:43 * mietek <3 BangPatterns
09:22:46 <mietek> parcs`: thanks again
09:23:01 <spaceships> SamanthaAD: docs are huge too, and dispite the steep learning curve (because of it?), the docs are amazing (i like arch for this reason too)
09:23:28 <mietek> Constant-space execution feels good
09:24:02 <jimch> Still getting overflow
09:24:04 <spaceships> SamanthaAD: the books on haskell are top notch
09:25:35 <parcs`> jimch: strange. FWIW, i'm not getting an overflow from buildMap1 but i am getting one from buildMap2. try importing Data.Map.Strict instead of Data.Map
09:25:43 <jimch> I think that maybe it is trying to keep all those Maps on stack until buildMap unrolls?
09:26:09 <jimch> Really? How big of a text file did you try it with?
09:27:09 <mauke> jimch: what input should I use?
09:27:09 <SamanthaAD> spaceships: #haskell does seem pretty great. Is there a particular book that you recommend given that I'm coming from a SICP background? I'm most interested in a book that really focuses on the theory of functional program design for really large programs.
09:27:28 <parcs`> jimch: well the list i passed to buildMap1 has 1 million elements
09:27:34 <jimch> mauke it breaks on 3 MB text file in here
09:27:54 <SamanthaAD> spaceships: I'm looking at Haskell because I'm dissatisfied with Scheme/LISP's ability to take advantage of multi-core processors
09:28:11 <mauke> link?
09:28:25 <jimch> http://hpaste.org/77482
09:28:36 <spaceships> @where RWH
09:28:36 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:28:42 <mauke> jimch: that's not even close to 3 MB
09:28:47 <parcs`> jimch: i don't think you're getting a stack overflow from buildMap*
09:29:03 <spaceships> SamanthaAD: if that's too crazy at first (it was for me), try LYAH
09:29:10 <spaceships> @where LYAH
09:29:10 <lambdabot> http://www.learnyouahaskell.com/
09:29:12 <parcs`> buildMap1, anyway
09:29:19 <jimch> parcs Is Data.Map.Strict a third party lib? I dont have it
09:29:50 <jimch> Data.HashMap.Strict maybe?
09:29:59 <mauke> where's my input?
09:30:20 <parcs`> jimch: a recent version of 'containers' should have that module, alongside to Data.Map
09:30:27 <jimch> mauke just redirect any large text file to stdin
09:30:35 <mauke> jimch: where do I get a large text file?
09:30:40 * hackagebot hat 2.7.0.9 - The Haskell tracer, generating and viewing Haskell execution traces  http://hackage.haskell.org/package/hat-2.7.0.9 (OlafChitil)
09:31:06 <Jafet> IRC logs!
09:31:08 <int-e> jimch: it's new in containers-0.5.0.0
09:31:48 <mietek> mauke: you can borrow mine
09:31:50 <parcs`> jimch: okay, please try my latest annotation. i made buildMapHelper behave like foldl' and also strictified (+)
09:31:55 <jimch> Yeah irc log will dom
09:31:57 <spaceships> SamanthaAD: I dont know much about the thoery of large program design (for either book), but RWH is a nice place to start
09:32:00 <jimch> do
09:32:20 <mauke> mietek: url?
09:33:01 <jimch> parcs`: cool, it works fine now
09:33:36 <parcs`> yay
09:33:39 <taylanub> In computer science, is "monad" necessarily a type class, or how else could it be defined ?
09:34:11 <mauke> sigh, tunes.org is serving me files at the speed of molasses
09:34:18 <ciaranm> taylanub: in CS or in haskell?
09:34:37 <atriq> taylanub, could pass about a dictionary
09:34:57 <mietek> mauke: cat /dev/urandom | tr -dc '[:print:]'
09:34:58 <mietek> :)
09:35:03 <ciaranm> MIAOW
09:35:06 <ciaranm> you're abusing a cat!
09:35:11 <mietek> Right.
09:35:15 <taylanub> ciaranm: In CS.  Entering "Monad (computer science)" on Wikipedia redirects to "Monad (functional programming)" though so maybe that would be more correct.
09:35:18 <jimch> parcs`: What was causing it?
09:35:19 <mietek> ciaranm: I had a head in there.
09:35:23 <mietek> ciaranm: sorry!
09:35:37 <ciaranm> taylanub: in CS in general, monads are used in the mathematical sense
09:35:44 <parcs`> jimch: the problem is that buildMapHelper was accumulating a large chain of applications in its second argument and when it came time to evaluate that thunk it caused an evaluation-stack overflow
09:36:01 <SamanthaAD> spaceships: thanks for the recommendations!
09:36:08 <jimch> ah
09:36:18 <taylanub> ciaranm: Oh, didn't know that. I'm asking about the "functional programming" definition then.
09:36:30 <mauke> irc: <stdin>: hGetContents: invalid argument (invalid byte sequence)
09:36:33 <mauke> fuck this shit
09:36:33 <ciaranm> taylanub: type classes are a fairly haskell-centric concept still
09:37:18 <spaceships> SamanthaAD: :)
09:37:21 <hpaste> mauke annotated “building map” with “building map (annotation)” at http://hpaste.org/77482#a77489
09:37:28 <taylanub> I see.  Wikipedia says that "formally, a monad consists of a type constructor M and two operations, bind and return."  I should learn what a type constructor is I guess.
09:37:48 <neutrino> no don't
09:37:55 <ciaranm> taylanub: meh. don't learn that definition. learn the categorical definition instead.
09:38:10 <ciaranm> taylanub: the fmap / pure / join definition is better than the bind / return definition.
09:38:19 <mauke> jimch: ^ here's my (untested) attempt
09:38:20 <neutrino> just learn to write "instance ... Monad ... where ..." and learn how to define bind and return.
09:38:42 <ciaranm> forget bind and return!
09:38:51 <taylanub> ciaranm: Hrm, should I also directly go for Arrows maybe ?
09:38:56 <ciaranm> taylanub: no
09:39:07 <jimch> theres a different problem now though. if I feed it a much larger file (40 MB). Memory usage goes over 1 GB and I get MEM_COMMIT failed error
09:39:15 <SamanthaAD> @where RWH
09:39:16 <lambdabot> http://www.realworldhaskell.org/blog/ http://book.realworldhaskell.org/read/
09:40:00 <parcs`> jimch: see http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl' -- the original buildMap1 corresponds to foldl, the annotated buildMap1 corresponds to foldl' and buildMap2 corresponds to foldr
09:40:30 <jimch> I see
09:40:48 <Anpheus> If I am writing a cabal project that is a wrapper for a rarely-distributed but useful cross-platform library
09:41:08 <jimch> What about the issue I am having now?
09:41:41 <Anpheus> should I: include the library in the source, include compiled versions of the library as well as the source as binaries, or should I have the cabal package not have the library included at all?
09:42:12 <Anpheus> the concern I have is that this library, libuv, is rarely distributed except as a component of something else
09:42:56 <jimch> maybe I should be using ByteString when dealing with large files?
09:44:16 <Eduard_Munteanu> taylanub: http://en.wikipedia.org/wiki/Monad_(category_theory)#Formal_definition is a common definition
09:48:44 <parcs`> jimch: yes. Strings have enormous overhead
09:48:51 <taylanub> Eduard_Munteanu: As is usual with formal definitions, that uses a lot of terms which I'd have to learn first.
09:48:56 * nand` debates writing an implementation of type-level rationals
09:48:58 <mauke> jimch: I ran my version (with a sort fix applied) on 200 copies of a 529K file
09:49:01 <mauke> no problems
09:49:09 <mauke> > 200 * 529
09:49:11 <lambdabot>   105800
09:49:15 <mauke> > 200 * 529 / 1024
09:49:16 <lambdabot>   103.3203125
09:49:28 <mauke> should be about 100 MB
09:49:59 <neutrino> taylanub: have you learnt how to use and possibly write new monads yet? as in the routine ways, rather than the math behind it
09:50:11 <jimch> mauke I see
09:50:49 <mauke> (the "sort fix" was (flip $ comparing snd))
09:51:24 <taylanub> neutrino: I actually hope that I'll wrap my head around all these concepts without learning Haskell specifically.
09:53:00 <taylanub> The pragmatic approach is indeed great and usually works for me, but in those cases I'm usually motivated to learn the tool for its own sake and the concepts it uses just follow.  On the other hand I won't ever be writing much Haskell.  I also managed to learn a lot of concepts used by Scheme (e.g. continuations) without writing much.
09:53:25 <taylanub> Correction: Won't ever be writing much Haskell any time soon.
09:53:41 <Eduard_Munteanu> taylanub: well now it depends on what you're interested in, figuring monads as category-theoretic notions or as they're used in functional programming. You don't really need the former for the latter.
09:54:26 <nand`> Does anybody want to contribute a Units.Imperial module in the style of http://hub.darcs.net/nand/units/browse/SI.hs and http://hub.darcs.net/nand/units/browse/NonSI.hs ? I can't be bothered figuring out that backwards system
09:54:47 <taylanub> Is it true that data types in CS correspond to categories in maths ?
09:55:12 <c_wraith> Sure, but that alone isn't that insightful
09:55:22 <taylanub> My actual question follows ..
09:55:36 <Eduard_Munteanu> taylanub: not really
09:56:30 <taylanub> Wikipedia mentions the "category of sets" where the objects are sets and the arrows are functions.  Then it says types (I assume together with functions defined on them) are categories.  But don't all functions (irrespective of which type they're defined on) defined through a domain and codomain *set* ?
09:56:55 <taylanub> s/don't/aren't/
09:57:37 <Eduard_Munteanu> taylanub: well for example, Haskell's types aren't quite sets. You have to put that in a type-theoretic context.
09:57:48 <taylanub> (And well, they are "functions".)  So what's the difference between any CS type and the category of sets ?
09:57:55 <Eduard_Munteanu> Neither are Haskell's functions normal functions.
09:58:34 <taylanub> Eduard_Munteanu: I'm usually interested in maths for its own sake, in addition to its practical uses.
09:58:56 <jimch> mauke everything else the same except toSortedList m = sortBy (flip $ comparing snd) . Map.toList $ m ?
09:59:12 <Eduard_Munteanu> taylanub: neat, you should probably pick up Awodey's book on CT.
09:59:44 <taylanub> Ah, I reckon now that functions aren't *necessarily* defined through sets (3-tuple X Y F), it's just one possible definition ..
09:59:48 <Eduard_Munteanu> Also, there's ##categorytheory (and most of the people in there are in here as well).
10:01:16 <Eduard_Munteanu> taylanub: one particular difference is objects of Hask are always inhabited, at least by undefined values.
10:02:52 <Eduard_Munteanu> Even a better-behaved (more Set-like) Hask would be a bit different, consider computable functions.
10:03:39 <ctrl_> What Haskell wiki is written with? PHP?
10:04:45 <nand`> ctrl_: looks like it's running MediaWiki, which is written in PHP
10:04:55 <nand`> judging by the ‘Powered by MediaWiki’ logo at the bottom
10:07:15 <ctrl_> The site is fast and looks nice. It's surprising a bit, that it's powered by PHP. Thanks for the answer
10:08:04 <nand`> MediaWiki runs Wikipedia after all
10:08:13 <nand`> I wouldn't doubt its ability to run reasonably
10:08:18 <Eduard_Munteanu> Yeah, I guess we don't eat our own dog food as much as we should :P
10:08:42 <Clint> http://haskellwiki.gitit.net/
10:08:42 <nand`> heh
10:08:52 <nand`> I would be interested to see what Haskell wikis there are
10:09:11 <zomg> Man PHP sucks, it's hard to believe how well mediawiki actually works
10:09:16 <zomg> or wordpress for that matter
10:09:53 * nand` just read the introductory paragraph on that main page and was astonished by how little content it contains
10:10:06 <nand`> all it says is that Haskell is purely-functional and open-source
10:10:19 <johnw> you mean there's more?
10:11:15 <ctrl_> It also uses COOL words like "cutting-edge research", I like this wiki. He-he
10:12:47 <neutrino> or "dynamic"?
10:13:26 <nand`> Hmm. I forgot why I had to refactor this type to be in a different representation. I guess I have to refactor it back and figure out what broke again
10:14:05 <lispy> hello
10:14:17 <ctrl_> Hi.
10:14:19 <Eduard_Munteanu> Hi lispy
10:14:36 <mcstar> hello lispy
10:15:21 <SamanthaAD> thanks for all of your help but it's time for me to go now
10:15:23 <nand`> oh, now I remember, no refactoring fortunately
10:15:29 <neutrino> it would be so much fun if you could refactor types, and have the code change with them
10:16:05 <neutrino> for example, if you have a function -> (a, b) and you remove the b, the second part of the returned tuple and all code required to generate it would get removed
10:16:13 <ctrl_> Isn't there similiar features in any of the IDE's?
10:16:41 <lispy> This channel is always so friendly :)
10:17:04 <neutrino> and perhaps some other parts of the type could get reduced too
10:17:13 <lispy> neutrino: isn't that what HaRe is for?
10:17:29 <neutrino> for example if your function is a -> b -> c but the b isn't used anywhere then it could be removed
10:17:34 <lispy> neutrino: http://www.cs.kent.ac.uk/projects/refactor-fp/hare.html
10:17:38 <neutrino> and any code using it that isn't productive
10:17:59 <neutrino> i know of hare
10:18:09 <neutrino> but i think it mostly does other stuff
10:18:12 <lispy> ah
10:18:17 * lispy has never tried it
10:19:03 <neutrino> i read up on it but haven't tried it either
10:19:43 <ctrl_> I'm looking for a plugin for gedit, similiar to "source candy" in Leksah. Is there a one?
10:20:16 <lispy> ctrl_: I bet you won't find many people here that know the answer. Emacs and vim are used almost exclusively.
10:20:31 <lispy> Does gedit have a channel?
10:21:06 <ctrl_> Uhm thanks for the idea, it would be proper to ask in gedit channel
10:21:36 <zomg> Darn, C#'s type inference isn't smart enough to determine variable types if you don't initialize the variable
10:21:43 <zomg> Would've been neat though
10:21:56 <nand`> C# has type inferencing? Oh right, it's supposed to
10:22:03 <nand`> in practice I have to write out every single type
10:22:10 <zomg> Yeah you can use 'var foo = new Whatever()' instead of 'Whatever foo = new Whatever()'
10:22:10 <mcstar> why would you not initilize a variable?
10:22:15 <zomg> I guess it's sort of like inference but not really :P
10:22:28 <Jeanne-Kamikaze> java can also do that :)
10:22:35 <Jeanne-Kamikaze> or well
10:22:38 <zomg> Jeanne-Kamikaze: wow, it can? since when? :P
10:22:44 <Jeanne-Kamikaze> LinkedList<Foo> asdasd = new LinkedList<>();
10:22:46 <Jeanne-Kamikaze> since 7, I think
10:22:51 <arbn> zomg: C#'s type-inferencing is very useful, especially in code that uses generics heavily.
10:22:51 <zomg> Oh that's not the same though
10:22:56 <nand`> one thing I wish C# could do better is inference type parameters on generic stuff better
10:23:08 <Jeanne-Kamikaze> that's as far as its type inference goes though
10:23:21 <zomg> Yeah I was mostly refering to the 'var' keyword rather than generics :)
10:23:27 <nand`> in practice I have to write it out very often; even for banal stuff like the constructor on Tuple<a,b> or Either<a,b>
10:23:45 <nand`> or, worse, when pattern matching
10:24:16 <Rickasaurus> Tuples of dictionaries from string to list in C# have been known to make grown programmers cry
10:24:29 <arbn> zomg: Well, I often use the var keyword when using the iterator for-loop thing.
10:25:13 <arbn> for (var foo in evil_structure_with_verbose_generic_types) {}
10:25:26 <zomg> arbn: I use var as much as possible because I'm so used to it from JavaScript and because I don't want to type the same stuff everyhwere :D
10:26:12 <nand`> that's not the worst of it; http://hub.darcs.net/nand/csharp/browse/InfEnumerable/Enumerable.cs
10:26:27 <nand`> the function in line 50-61 makes me cry
10:26:42 <nand`> 71 isn't much better
10:27:41 <ctrl_> Still better syntax than C++ templates.
10:27:52 <arbn> nand`: Haha. That's a really, really good example, of why C# is not my favorite language, and I avoid it, after finishing my last C# job.
10:28:18 <Rickasaurus> Why not give F# a go instead :)
10:28:35 <arbn> Rickasaurus: The next time I have a reason to work with .NET, I plan to give F# a go.
10:28:55 <zomg> I'd use F# but I actually want to get this thing done rather than spend my time trying to understand the language
10:28:58 <zomg> :D
10:29:11 <Rickasaurus> F# is a pretty legit ML, but not Haskell for sure
10:29:16 <nand`> I tried to use F# a few times, it just doesn't work out very well for me - the tricks that I use in C# to simulate some of the things Haskell has don't seem to translate very well to F#
10:29:17 <arbn> zomg: F# is just OCaml.
10:29:24 <arbn> OCaml.NET == F#
10:29:25 <nand`> I often find myself defining types in C# just so I can import them in F#
10:29:33 <zomg> arbn: F# is brainfuck if you have never used OCaml
10:29:33 <zomg> ;)
10:29:37 <ctrl_> F# is just some twisted version of OCaml.
10:29:46 <Rickasaurus> ... Not really though, there's a lot of differences from OCaml
10:29:55 <Rickasaurus> Syntactically yes though
10:30:18 <nand`> arbn: oh yeah, here's the Haskell version of that entire C# file: http://hub.darcs.net/nand/csharp/browse/InfEnumerable/ListF.hs
10:31:36 <mcstar> whats the matter with your first lines?
10:31:56 <nand`> if you mean the indenting, that's a bug with hub.darcs.net
10:32:24 <mcstar> super annoying
10:32:31 <Rickasaurus> Most important difference is there's no giant lock
10:32:45 <arbn> nand`: Nice. Still, the Haskell-inspired features in C# are like ice water, when one is forced to visit hell.
10:32:55 <arbn> F# is probably worth a try, though.
10:33:04 <nand`> arbn: Func<> is nice when you need it
10:33:23 <mcstar> fsharp has static methods
10:33:24 <nand`> LinQ can be useful but tedious to write implementations for
10:33:31 <ctrl_> LINQ is nice, it's lazy
10:34:44 <nand`> that's not a propery of LinQ itself though is it? Just Func<>
10:36:00 <Rickasaurus> Func<> in C# isn't intrinsically lazy, it's all in how you use it just like a method
10:36:19 <arbn> My least favorite thing about C#, is the fact that, when you use lambdas or functions to enclose values in the surrounding scope, you have evil reference semantics to cope with. :(
10:37:02 <Rickasaurus> Oh yeah, lamdbas and IDisposable are not a fun combo
10:37:27 <ctrl_> My least favourite thing about C# - it doesn't have const modifier for function arguments and methods itself.
10:37:32 <arbn> I wish that C#, like Scala, had a 'val' type.
10:37:38 <arbn> Er. val declaration.
10:38:12 <Rickasaurus> arbn, what do you mean?
10:38:24 <Rickasaurus> val evaluates in Scala, yeah?
10:38:43 <arbn> Rickasaurus: In Scala, you can declare a reference with "var", or an immutable value, with "val". It would be nice to have both options in C#.
10:39:31 <Rickasaurus> ahh, got them backwards.  val var and def
10:40:08 <Rickasaurus> def is lazy, var is strict ref, val is strict immutable, yeah?
10:40:16 <arbn> Rickasaurus: Yeah.
10:40:24 <arbn> Rickasaurus: You can also specify that parameters are immutable, with 'val'. So, in Scala, it is possible to write functions that are pure, no matter what the caller tries to do. Not so in C#.
10:40:57 <Rickasaurus> Yeah, const in C# is a joke
10:41:42 <Rickasaurus> I like Scala, I just wish the inference was better.  It's like using C# but with very complex types, which I always found to be a headache.
10:41:42 <nand`> Does GHC memoize type families when type checking? Say I have some type family foo :: Nat -> Foo which may take a long while to compute at compile time; will mentioning ‘foo 4’ multiple times in a type share the result?
10:42:10 <Rickasaurus> And one of my favorite things about FP is structural typing / ADTs
10:42:23 <arbn> Rickasaurus: Scala has ADTs.
10:42:36 <Rickasaurus> Oh, I know.
10:43:01 <Rickasaurus> case classes and tuples, but you very often need to write out the signatures
10:43:11 <S11001001> Rickasaurus: scala's inference is quite a lot better than c#'s, but certainly miles away from haskell
10:44:09 <Rickasaurus> I've been taking the Scala class actually, to get a good handle on the language.
10:44:13 <arbn> Rickasaurus: Yeah. My Scala case-classes get cluttered.
10:44:41 <arbn> "def &  (that: Sentence) : Sentence = And(this, that)" is not as readable, to me, as the Haskell.
10:44:44 <Rickasaurus> It needs some work on error messages too.  Sometimes it's hard to figure out where your types went wrong
10:45:08 <Rickasaurus> The syntax was obviously designed to appeal to those coming from Java
10:45:57 <mattp_> checking version of ghc... 7.6.1
10:45:58 <mattp_> configure: error: The Haskell Platform version 2012.4.0.0 requires ghc-7.4.2
10:46:00 <mattp_>   It is recommended that you upgrade to ghc-7.4.2 however if you
10:46:02 <mattp_>   really want to use this release with an unsupported version of GHC
10:46:04 <mattp_>   then use ./configure --enable-unsupported-ghc-version
10:46:06 <mattp_> is it safe to do this with 7.6.1
10:46:08 <mattp_> ?
10:46:25 <mcstar> it is safe to use hpaste.org
10:46:38 <rwbarton> you almost certainly want to just use ghc 7.4.2
10:46:48 <arbn> Rickasaurus: I think Scala is probably the best language with a shallow learning curve for existing industry OO programmers, though, which is quite an accomplishment. Also, it's my language of choice for Android apps.
10:46:52 <mattp_> alright
10:46:53 <mattp_> thanks
10:46:57 <mattp_> mcstar: sorry
10:47:12 <Rickasaurus> Who knows though, Scala could be the real future of functional programming.  It may be that C-style syntax has already won the war and we're like southern folks with confederate flags.
10:47:37 <arbn> ... until someone gets Frege working with Android. :P
10:48:49 <Rickasaurus> arbn, I agree completely.  It probably has the lowest learning curve for someone experienced in C# or Java already.
10:50:02 <Rickasaurus> and if they could figure out a way to get inference on recursive functions I'd probably shut up with my complaining about having to write so many types
10:51:02 <arbn> Well, I think the Scala folk have run into some trouble with the limitations of the JVM. Didn't SPJ recently mention that the Scala folk were considering dropping higher-kinded type variables from the language?
10:51:29 <neutrino> wtf are you talking about
10:51:53 <neutrino> Rickasaurus: there's nothing wrong with haskell's indentation based syntax.
10:52:19 <neutrino> and if you think that's the defining feature of the language, then you're really missing the point.
10:53:01 <arbn> neutrino: I think he's talking about wide adoption, and there's a surprising number of people who raise a fuss about syntax.
10:54:19 <geekosaur> funny thing, python has fairly wide adoption with arguably stricter indentation based syntax
10:54:46 <arbn> geekosaur: Python is more verbose, though. To the uninitiated, Haskell can look like "line noise". Too many concise operators.
10:55:39 <geekosaur> if we're going there, just give up now; java-syntax or php-syntax haskell is not going to win anything, and that's abotu the only way to overcome the "ew syntax" crowd
10:55:42 * hackagebot happstack-server-tls 7.0.2 - extend happstack-server with https:// support (TLS/SSL)  http://hackage.haskell.org/package/happstack-server-tls-7.0.2 (JeremyShaw)
10:56:18 <arbn> geekosaur: Well, right. It's not worthwhile to conform to the laziest programmer's expectations.
10:56:27 <dstywho> what about in comparison to Closjure, Erlang and F#?
10:56:36 <dstywho> *Clojure
10:57:02 <nand`> Can anybody point me to an example of how to implement quotRem for integers?
10:57:37 <donri> infixl 9 :> "This type operator associates to the right" is this true?
10:58:11 <nand`> left, surely
10:58:44 <donri> edwardk: ^^^ Control.Lens.Zipper
10:59:04 <edwardk> donri: hah
10:59:57 <edwardk> https://github.com/ekmett/lens/commit/dd6b93e5ec7117d259b9ca1c25ecd3f16e8001cb
11:00:29 <donri> \o/
11:01:04 <Rickasaurus> neutrino_, I completely agree with you, just saying the vast majority of programmers are only comfortable with C style or some variant thereof
11:01:37 <neutrino_> are they
11:01:44 <arbn> Hehe.
11:02:08 <Rickasaurus> Java and C# programmers are like baby boomers
11:02:20 <Rickasaurus> There's a ton of them, and they're dragging us all down
11:03:57 <lispy> ?pl \xs -> length (filter id xs) > 1
11:03:57 <lambdabot> (> 1) . length . filter id
11:04:04 <lispy> Is there a nicer way to write that?
11:04:16 <lispy> I want to know if a list has multiple True
11:04:20 <lispy> 2 or more
11:04:33 <Rickasaurus> map sum?
11:04:46 <lispy> > map sum [True, True, False]
11:04:48 <lambdabot>   Couldn't match expected type `[b0]'
11:04:48 <lambdabot>              with actual type `GHC.Type...
11:04:58 <lispy> :t map sum
11:04:58 <clahey> So you want [Bool] -> Bool, that returns True if 2 or more are True?
11:04:59 <lambdabot> Num b => [[b]] -> [b]
11:04:59 <donri> neutrino_: oh, there's plenty wrong with the indentation syntax in haskell. overall i think it's a win though.
11:05:03 <lispy> clahey: yup
11:05:21 <lispy> kind of like or but needs at least 2 Trues
11:05:26 <lispy> :t or
11:05:27 <lambdabot> [Bool] -> Bool
11:05:28 <edwardk> > map (sum . fromEnum) [True, True, False]
11:05:30 <lambdabot>   Couldn't match expected type `[b0]'
11:05:30 <lambdabot>              with actual type `GHC.Type...
11:05:34 <nand`> “The numbers are represented as a Boolean Ring over a countable set of variables, in which for every element in the set there exists an n in N and a b in {T,F} such that forall n' >= n in N, x_i = b” <- /me looks at author => edwardk
11:05:47 <edwardk> ?
11:05:51 <clahey> So, the problem with what you've written there is that it has to process the entire list to reduce.
11:06:05 <edwardk> nand`: which package was that?
11:06:08 <nand`> type-int
11:06:16 <edwardk> ah sounds like the me of the time
11:06:17 <Rickasaurus> a simple recursive function with an accumulator?
11:06:18 <lispy> clahey: my lists are going to be small, but that's a good point
11:06:48 <clahey> So Any2 True:True:repeat False is going to take infinite time.
11:06:54 <lispy> > map fromEnum [True, True, False] :: [Int]
11:06:56 <edwardk> i try to be a little less stilted in my diction these days =)
11:06:56 <lambdabot>   [1,1,0]
11:07:19 <lispy> clahey: yes
11:07:23 <clahey> (>1) . sum . map fromEnum
11:07:42 <clahey> I think length . filter id is actually easier to read, personally.
11:09:12 <rwbarton> the standard lazy way would be something like not . null . drop 1 . filter id
11:10:02 <clahey> What I came up with was more complicated.
11:10:14 <clahey> or . dropWhile not
11:10:21 <neutrino_> donri: one improvement i would like in haskell is hyphenated-names.
11:10:22 <clahey> Actually, that isn't more complicated.
11:10:49 <donri> neutrino_: agreed. agda syntax is cute ;)
11:10:57 <neutrino_> donri: dunno about agda, never used it.
11:11:27 <donri> neutrino_: you can basically use anything in a name, save for some reserved punctuation like parenthesis
11:11:31 <clahey> or . drop 1 . dropWhile not
11:11:47 <donri> neutrino_: so you need whitespace around your operators
11:11:55 <neutrino_> donri: however, regarding indentation and syntax, it would be fun to have a language where you could define new keywords, and when you used them, the next more-indented block would be a completely new language.
11:12:02 <neutrino_> with possibly completely new keywords.
11:12:13 <neutrino_> or perhaps inheriting ones from the parent scope.
11:12:26 <Philippa_> neutrino_: so give or take, I had a work in progress implementation for a language like that
11:12:35 <Philippa_> well, still have, just haven't hacked on it in ages
11:12:50 <donri> neutrino_: you can kinda define your own keywords in agda, but don't think it affects layout. mixfix: if_then_else_ is a function that can be called like "if cond then true-branch else false-branch"
11:13:09 <neutrino_> mixfix isn't exactly there.
11:13:40 <donri> neutrino_: although what you're describing sound a bit like quasi-quoting but with indentation
11:13:51 <neutrino_> kinda, but also not really.
11:13:54 <neutrino_> but sorta, yes.
11:13:58 <donri> would be a bitch to write syntax highlighting for ;)
11:13:58 <arbn> edwardk: In your toy Objective-C bindings, you didn't implement upcasting and downcasting or inheritance trees, correct? I thought that was the main reason HOC was designed the way it was (using type-classes per-object and per-class, and generating that interface with TH). Do you have another idea about how to do that?
11:14:03 <Philippa_> donri: like QQ with a decent extensible parser
11:14:13 <donri> sugarhaskell?
11:14:19 <Philippa_> that's closer, yeah
11:14:22 <edwardk> i didn't get very far at all
11:14:23 <Philippa_> need to read the paper properly sometime
11:14:24 <Jafet> neutrino: http://augustss.blogspot.de/search/label/BASIC
11:14:51 <edwardk> the sketch of what is in that package isn't much related to how i intended the high level API to work
11:15:25 <arbn> edwardk: OK. What do you see the problems with HOC as being? I'm just trying to think through how to do the casting without the complexity of the HOC interface generator.
11:15:41 <edwardk> arbn: distracted IRL. will pm when free
11:15:54 <arbn> edwardk: ok. np.
11:17:12 <neutrino_> Jafet: fun!!!
11:17:18 <neutrino_> Jafet: like this, but MORE
11:18:17 <neutrino_> :))
11:23:34 <neutrino_> i wonder how minimal you could go with such a language
11:24:01 <neutrino_> what the minimal toolkit would be so that you can define everything else
11:26:34 <syskk> is there any Sinatra/Express.js like web server libraries for Haskell?
11:26:45 <luite> yeah, scotty
11:27:08 <Jafet> neutrino: defmacro
11:27:45 <nand`> neutrino_: SK with a C FFI
11:27:47 <nand`> you could probably go more minimal if you consider stuff like iota
11:28:12 <rwbarton> ah yes the SKF calculus
11:28:36 <Jafet> Is that what the unlambda c operator is for
11:29:39 <neutrino_> haha
11:29:55 <donri> luite: hm i wonder if scotty's name is a reference to its use of warp -> beam me up scotty
11:30:49 <donri> oh yea it actually uses that line in its hackage description
11:31:41 <dpratt71> unable to load package `network-2.3.2.0' ... unknown symbol `_acceptNewSock'
11:31:52 <dpratt71> does that mean anything to anyone?
11:33:45 <bfig> dgpratt, that looks like a linker error which kinda means you're missing files there?
11:34:07 <bfig> make sure you have the dependencies met, including OS packages
11:35:09 <dgpratt> I should mention that this on Windows (trying to cabal install cabal-dev)
11:38:05 <dgpratt> I'm quite sure I had cabal-dev installed on Windows at some point in the past, otherwise I would assume that cabal-dev (or maybe network) is just not Windows friendly
11:40:43 * hackagebot FixedPoint-simple 0.4.1 - Fixed point, large word, and large int numerical representations (types and common class instances)  http://hackage.haskell.org/package/FixedPoint-simple-0.4.1 (ThomasDuBuisson)
11:49:00 <mhernandez> asdass
11:49:01 <mhernandez> asd
11:49:17 <copumpkin> wow, we crossed 1000 users
11:49:22 <edwardk> woot
11:52:20 <Guest84154> testing an irc plugin for sublime text 2 that im writing
11:52:46 <Guest84154> received
11:55:12 <Eduard_Munteanu> Cool. I wonder if there are graphs of users per channel over time.
11:56:34 <Eduard_Munteanu> Hm, looks like there are: http://irc.netsplit.de/channels/details.php?room=%23haskell&net=freenode
11:56:54 <nand`> we've been over 1100 I think
12:06:13 <Spin1987> Hello
12:06:23 <Spin1987> im really new to haskell with scala background
12:06:43 <Spin1987> have to learn a little bit about haskell and a well reommended framework
12:06:48 <Spin1987> which schould i use?
12:07:03 <Spin1987> which is not complicated and like lift framework in scala
12:07:33 <Eduard_Munteanu> Spin1987: what sort of framework is that? Something for web development?
12:07:50 <Marenz> huu just learning haskell... and just did map(('a':)) [['b'],['c']]
12:07:52 * Marenz feels proud
12:08:00 <donri> Spin1987: duno what distinct design choices lift has made beyond its templating. as for templating, heist is a bit similar to lift's.
12:08:16 <byorgey> Marenz: nice =)
12:08:17 <dimka> Is there some implementation of boolean algebra class ? (like this one: http://en.wikipedia.org/wiki/Boolean_algebra_(structure))
12:08:26 <donri> Spin1987: a simple web framework that supports heist well is snap
12:08:28 <byorgey> Marenz: note one set of parentheses is redundant
12:08:31 <donri> @where snap
12:09:05 <ciaranm> Marenz: the cool kids spell that <$>
12:09:05 <Marenz> byorgey, I figured :)
12:09:15 <Marenz> ciaranm, hu?
12:09:37 <mauke> > ('a' :) <$> ["b", "c"]
12:09:37 <byorgey> Marenz: ciaranm is just showing off, you can ignore it for now =)
12:09:38 <lambdabot>   ["ab","ac"]
12:10:24 <Spin1987> thx guys
12:10:27 <pordan30> dimka: i think that data.algebra has a boolean class
12:10:30 <Spin1987> for fast response
12:10:39 <Spin1987> k i will have a look to snap
12:10:41 <Spin1987> :)
12:12:10 <pordan30> nevermind, it doesn't. sorry :/
12:13:22 <niteria> > ['a' :] <*> ["b", "c"]
12:13:23 <lambdabot>   A section must be enclosed in parentheses thus: ('a' :)
12:13:29 <donri> Spin1987: http://snapframework.com/ if you didn't find it already
12:13:32 <niteria> > [('a' :)] <*> ["b", "c"]
12:13:33 <lambdabot>   ["ab","ac"]
12:13:43 <Spin1987> donri :)
12:13:48 <donri> @where+ snap http://snapframework.com/  #snapframework
12:13:49 <lambdabot> It is forever etched in my memory.
12:15:18 <niteria> <$> = map, <*> = ?
12:16:16 <ciaranm> <$> = fmap
12:16:50 <niteria> :t <*>
12:16:51 <lambdabot> parse error on input `<*>'
12:16:54 <niteria> :t (<*>)
12:16:56 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
12:17:04 <donri> @src ap
12:17:05 <lambdabot> ap = liftM2 id
12:17:13 <niteria> :t ap
12:17:15 <lambdabot> Monad m => m (a -> b) -> m a -> m b
12:17:39 <byorgey> for lists,  fs <*> xs = [ f x | f <- fs, x <- xs ]
12:18:00 <Jambato> it sequences actions?
12:18:13 <ryanos> monad question: what are the advantages of using the same notation for constructor classes (in monads) and regular classes (in the rest of cases) ?  (instance Monad Maybe where) vs (instance Eq Int where)
12:18:32 <niteria> > [1,2] >>= [3, 4]
12:18:34 <lambdabot>   Couldn't match expected type `a0 -> [b0]' with actual type `[t0]'
12:18:39 <ryanos> i can "feel" it tries to generalize something
12:18:41 <Cale> ryanos: Not introducing lots of different notations for what is pretty much the same mechanism?
12:18:42 <niteria> > [1,2] >>= return [3, 4]
12:18:43 <ryanos> but not clear
12:18:43 <lambdabot>   [3,4,3,4]
12:18:44 <byorgey> ryanos: because it's simple and consistent
12:18:56 <rwbarton> no reason to stop at * -> * either
12:19:02 <ryanos> looks gcool and generic indeed
12:19:04 <rwbarton> :k MonadTrans
12:19:06 <lambdabot> ((* -> *) -> * -> *) -> Constraint
12:19:21 <ryanos> but a bit confusing for me
12:19:27 <byorgey> ryanos: Monad is not the only class like that.
12:19:29 <Eduard_Munteanu> ryanos: I don't understand how those two are comparable
12:19:31 <niteria> :t mplus
12:19:32 <lambdabot> MonadPlus m => m a -> m a -> m a
12:19:33 <byorgey> ryanos: do you know about kinds?
12:19:41 <niteria> [1,2] `mplus` [3,4]
12:19:44 <donri> Jambato: it takes a function in a context and applies it to a value in a context. sorta kinda.
12:19:45 <ryanos> byorgey: read a bit
12:19:47 <niteria> > [1,2] `mplus` [3,4]
12:19:49 <lambdabot>   [1,2,3,4]
12:20:15 <ryanos> byorgey: they look like a generalization for types (?)
12:20:21 <niteria> is there infix mplus?
12:20:36 <byorgey> ryanos: kinds *classify* types, just like types classify values
12:20:40 <donri> niteria: there's infix mappend, which is often what you actually want
12:20:42 <Eduard_Munteanu> ryanos: sort of, they're "types of types"
12:20:46 <ryanos> Eduard_Munteanu: not saying are comparable, just a bit confusing because one is at meta level the other at type level (imo)
12:21:15 <niteria> > [1,2] `mappend` [3, 4]
12:21:17 <lambdabot>   [1,2,3,4]
12:21:23 <niteria> :t mappend
12:21:24 <byorgey> ryanos: anyway, it seems to me that your questions will be answered by learning more about kinds
12:21:25 <lambdabot> Monoid a => a -> a -> a
12:21:36 <donri> <> in Data.Monoid
12:21:36 <ryanos> byorgey: sounds good, will do :)
12:21:49 <ryanos> Eduard_Munteanu: you read my mind
12:22:04 <byorgey> ryanos: "normal" type classes like Num, etc. abstract over types of kind *
12:22:14 <byorgey> ryanos: Monad  abstracts over types of kind  * -> *
12:22:21 <Guest84154> testing
12:22:25 <byorgey> ryanos: and in general you can have a type class which abstracts over any kind
12:22:45 <ryanos> byorgey: sounds good - moving to higher level of abstraction
12:23:24 <ryanos> byorgey: btw - what would be a good category theory to explain all of these levels of abstraction upfront (from haskell perspective - ideally)
12:23:37 <Guest84154> testing
12:23:38 <ryanos> byorgey: i meant "category theory book"
12:23:48 <Guest84154> testing
12:24:21 <byorgey> ryanos: this thing about kinds has little to do with category theory
12:24:32 <byorgey> it's type theory
12:24:45 <Eduard_Munteanu> ryanos: I don't know of any CT book that approaches it from the perspective of Haskell. The closest thing wrt kinds is probably a type theory book, say TAPL.
12:24:49 <byorgey> (though of course the two are connected, but at this point the connections are probably not helpful)
12:24:59 <byorgey> @where tapl
12:24:59 <lambdabot> http://www.cis.upenn.edu/~bcpierce/tapl/
12:25:09 <byorgey> ryanos: yes, try that one ^^^
12:25:16 <Eduard_Munteanu> Of course, one may argue *some* things in * -> * are functors in a CT sense, but not all of them are.
12:25:31 <pordan30> i've seen different opinions regarding whether monad transformer stacks should be constructed with type synonyms or newtypes, with the latter requiring the appropriate instances. because the former approach requires less work, what are the advantages of the latter?
12:25:36 <donri> Guest84154: you should test in your own channel ..
12:26:31 <ryanos> byorgey: Eduard_Munteanu: Cale: thanks gentlemen
12:26:34 <byorgey> pordan30: one is better abstraction, so you can prevent users from accessing the internals, or better yet ensure that they won't see the internals in error messages.
12:27:03 <nand`> the instances thing is nearly a non-argument with generalizednewtypederiving
12:27:05 <byorgey> pordan30: using newtypes really doesn't require much extra work, given GeneralizedNewtypeDeriving
12:27:15 * byorgey high-fives nand` 
12:27:23 <dimka> win 21
12:28:12 <nand`> I keep it as type synonyms if I use it internally
12:28:26 <nand`> but for exporting I'd probably newtype it, depending on how strong the abstraction should be
12:29:22 <pordan30> byorgey, nand: thank you. i didn't know that the instances could be derived automatically, which makes the suggestion much more reasonable for small projects or portions of code that wouldn't be revealed to a user.
12:30:08 <Guest84154> t
12:30:09 * byorgey always newtypes
12:30:09 <Eduard_Munteanu> pordan30: for newtypes it's *always* possible, it just does wrapping and unwrapping
12:30:32 <Guest84154> l
12:30:41 <byorgey> Guest84154: that's getting annoying, please stop.
12:30:46 <new> hello i need help please
12:31:08 <Eduard_Munteanu> new: hi
12:31:10 <byorgey> new: ask a question and someone may respond.
12:31:15 <new> okey
12:31:23 <pordan30> ryanos: if you don't want to buy types and programming languages, i believe that thompson's monograph on type theory is available online.
12:31:30 <nand`> hmm
12:31:42 <Eduard_Munteanu> For some reason I think Cale took care of that aspect. :P
12:31:42 <nand`> this function I wrote works fine on the value level, but promoted to types it doesn't terminate
12:32:01 <nand`> apparently, the ‘If True Foo Bar’ expression is evaluating Bar; which recurses into the same function
12:32:05 <donri> Eduard_Munteanu: i think it's broken for type families though
12:32:09 <ryanos> pordan30: thanks for input. the problem is not buying them, but finding the path of minimum resistance :)
12:32:34 <Marenz> How would this work properly? map (:t) [True,False]
12:32:36 <byorgey> nand`: ahhh, interesting, insufficient laziness?
12:32:57 <byorgey> Marenz: what are you trying to do there? ask for the types of True and False?
12:33:00 <Eduard_Munteanu> Marenz: if t is a list it's fine
12:33:02 <Marenz> yes
12:33:07 <byorgey> Marenz: :t
12:33:11 <nand`> byorgey: seems like it
12:33:17 <Eduard_Munteanu> :t map (: ?t) [True, False]
12:33:18 <lambdabot> (?t::[Bool]) => [[Bool]]
12:33:21 <nand`> byorgey: I'm really stumped now, I'm trying to implement quotRem
12:33:21 <rwbarton> do you mean :t as in "hey ghci what is the type of this"
12:33:23 <byorgey> Marenz: :t is not a function, it's a ghci command
12:33:28 <Marenz> oh, that's why
12:33:28 <ryanos> pordan30: always interested to hear what worked for people to "get the big picture" for CT and Types
12:33:40 <Marenz> thanks
12:33:44 <byorgey> Marenz: note, however, that all the elements of a list must have the same type
12:33:56 <Marenz> yeah i know :)
12:33:59 <byorgey> Marenz: so asking for the type of each element individually is not interesting
12:34:13 <Marenz> well, a lot of stuff I do at the beginning is not interesting :P
12:34:20 <new> im new in Haskell and i need a function that give me True or False if list a in list b but list b can have more numbers. For example [1,5,7] [2,1,2,5,8,7] = True because 1 5 7 are in list b, but [1,5,7] [2,1,7,5] is False because list a is not in same order in list b]
12:34:22 <byorgey> fair enough =)
12:34:34 <byorgey> > map typeOf [True, False]  -- note however, you can do this
12:34:35 <lambdabot>   [Bool,Bool]
12:34:54 <Marenz> ah.. so typeOf is the function equivalent
12:34:57 <donri> > typeOf show
12:34:59 <lambdabot>   () -> [Char]
12:35:03 <byorgey> new: is this for a homework assignment?
12:35:04 <donri> not always helpful
12:35:28 <nand`> I think this is the part where I have to drop the If (LessThan a b) (..) (...) and pattern match manually
12:35:30 * nand` shudders
12:35:31 <byorgey> Marenz: sort of, as donri shows it is not quite as useful as :t
12:35:42 <Marenz> > :t show
12:35:44 <lambdabot>   <hint>:1:1: parse error on input `:'
12:35:44 * hackagebot adp-multi 0.1.0 - ADP for multiple context-free languages  http://hackage.haskell.org/package/adp-multi-0.1.0 (MaikRiechert)
12:35:50 <Eduard_Munteanu> :t map typeOf [True, False]
12:35:52 <lambdabot> [TypeRep]
12:36:13 <Marenz> >:t show
12:36:18 <niteria> :t Nothing
12:36:19 <lambdabot> Maybe a
12:36:33 <niteria> > typeOf Nothing
12:36:34 <lambdabot>   Ambiguous type variable `a0' in the constraint:
12:36:35 <lambdabot>    (Data.Typeable.Internal....
12:36:36 <donri> :t show
12:36:38 <lambdabot> Show a => a -> String
12:36:48 <Marenz> I see
12:36:58 <Marenz> donri, coi btw
12:36:59 <byorgey> new: what have you tried so far?  e.g. do you have some code that doesn't work or doesn't type check?
12:37:00 <nand`> typeOf is fairly unconnected to GHCi's :t, no?
12:37:06 <donri> coi
12:37:19 <byorgey> nand`: indeed
12:38:05 <donri> there's typeOf in hint, though ;)
12:38:13 <donri> but it takes a string, not an arbitrary value
12:38:16 <Marenz> :t typeOf
12:38:18 <lambdabot> Typeable a => a -> TypeRep
12:38:31 <niteria> > typeOf typeOf
12:38:33 <lambdabot>   Ambiguous type variable `a0' in the constraint:
12:38:33 <lambdabot>    (Data.Typeable.Internal....
12:38:45 <niteria> > typeOf id
12:38:46 <lambdabot>   Ambiguous type variable `a0' in the constraint:
12:38:47 <lambdabot>    (Data.Typeable.Internal....
12:38:57 <donri> > show undefined
12:38:59 <lambdabot>   "*Exception: Prelude.undefined
12:39:20 <niteria> so only lists and builtins?
12:39:41 <niteria> by builtins I mean primitive types
12:39:44 <nand`> @ask jfischoff Do you have a working implementation of type-level rationals somewhere? I'm doing my best but QuotRem is proving to be problematic
12:39:44 <lambdabot> Consider it noted.
12:39:51 <otters> > typeOf 'c'
12:39:53 <lambdabot>   Char
12:40:41 <otters> > typeOf (typeOf ∷ Int → TypeRep)
12:40:41 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
12:40:44 <otters> oh
12:40:52 <rwbarton> fix your keyboard
12:41:08 <otters> are you kidding
12:41:11 <otters> it took a lot of work to get it this way
12:41:37 <donri> it took a lot of work to make it broken instead of just using compose
12:42:10 <otters> I don't have one ;_;
12:42:19 <donri> i map menu to compose
12:42:23 <neutrino_> →
12:42:43 * donri ♥ compose
12:42:49 <otters> fn, ctl, option, and command all have purposes on this machine
12:42:55 <otters> otherwise I would
12:43:30 <donri> oic mac. that explains the broken.
12:43:31 * donri ducks
12:43:57 <otters> yeah, I hear most other laptop brands have a compose key
12:43:59 <otters> oh wait
12:44:25 <donri> well i have a menu key that's easy to reach and pretty much useless anyway
12:44:41 <donri> who said anything about laptops anyway
12:44:53 <otters> yeah, I wish apple would add more useless buttons to their devices
12:44:59 <otters> well, my computer is a laptop
12:45:07 <niteria> use eject
12:45:07 * donri hugs his $200 keyboard
12:45:15 <otters> that might actually work
12:45:15 <neutrino_> donri: what keyboard would that be?
12:45:23 <niteria> very useful button
12:45:23 <donri> filco ninja tkl
12:45:33 <otters> I dunno
12:45:41 <nand`> (isn't that a bit expensive for a filco? Or did you replace the caps?)
12:45:42 <otters> it's tempting, but I can just turn on textexpander and type ::
12:45:55 <nand`> oh, wait, USD
12:46:10 <donri> yea more like 100 GBP plus shipping to sweden
12:46:11 <byorgey> #haskell-blah please
12:46:14 <donri> true
12:51:59 <hpaste> “New@Haskell” pasted “Haskell function sequence” at http://hpaste.org/77496
12:56:21 <pordan30> new: you asked before, but what are you having trouble with? from what you posted, it appears you haven't written the appropriate base cases for the recursion, and also aren't keeping track of the types of your variables in the function guards and recursive calls.
12:59:43 <arbn> new: Also, if this is homework, you should be getting help from the teacher of the course.
13:01:57 <pmade> Any recommendations for someone new to Haskell who wants someone to review some code and critique it?
13:02:36 <neothemachine> hey... maybe someone can help me, I'm a bit lost. For my first hackage release I cleaned up my cabal file and set some versions and now it says "Could not find module 'Data.Array'.." for one of my files, how is that possible?? see the diff here: https://github.com/neothemachine/adp-multi/commit/cc45c7d07f9a12898a0d3b417da60777126d2161
13:03:12 <dgpratt> pmade: maybe http://codereview.stackexchange.com/ (not sure how active that is for Haskell stuff)
13:03:24 <pmade> dgpratt: Thank you.
13:03:34 <rwbarton> neothemachine: what was the ".."
13:03:50 <neothemachine> "It is a member of the hidden package `array-0.4.0.0'."
13:04:17 <donri> neothemachine: you need to add array to build-depends of the executables that use it too
13:04:37 <donri> and test-suites
13:05:17 <neothemachine> hmm ok I'll try, although I find that quite not-dry
13:05:33 <kliko> Dear all, I have a problem implementing the following efficiently. Suppose I have a finite list [1,1,1,1,1,1,0,1,1,1], now I would like to traverse it from right to left (note: it has to be from right to left) and I would like to stop at the 0 and return true. Note I am well aware that I can do this with a simple \l -> or $ map (==0) l to detect whether there is a 0.
13:06:22 <kliko> is there a way to do this efficiently? (i.e. not first x:xs go to right and then go back
13:06:23 <kliko> )
13:06:54 <kliko> or am I missing the fact that the compiler might optimize on this?
13:07:14 <sfogarty> kliko: Lists are ordered left-to-right, so in order to access the last element you have to go through the whole list
13:07:16 <donri> neothemachine: if build-deps where project global that would make some things not possible... like using a different Data.Array in some executable
13:07:18 <simpson> kliko: Have you learned about foldr yet?
13:07:27 <sfogarty> you can simulate this with, yeah, foldr
13:07:34 <sfogarty> but it's still going to traverse the list
13:07:54 <arbn> kliko: You have to start with a *list*? You can't implement a different structure? Might as well just reverse the list at the beginning, I think.
13:08:12 <simpson> Uh, guys, no matter what, he's going to have to scroll through the list.
13:08:25 <simpson> It's not really that big of a deal though.
13:08:54 <rwbarton> you need a different data structure, either "a list but the rightmost element is first", or if you need efficient traversal in both directions, a Seq or something
13:08:55 <simpson> > any (== 0) [1,1,1,1,1,1,0,1,1,1]
13:08:56 <lambdabot>   True
13:09:02 <simpson> @src any
13:09:02 <lambdabot> any p =  or . map p
13:09:06 <pordan30> don't finger tree implementations of sequences give constant time access to the last element of the sequence? you could use something like that, right?
13:09:16 <donri> neothemachine: also it's better to depend on your own package instead of adding the src dir. that way you don't compile the same files multiple times.
13:09:20 <nand`> pordan30: aka Seq
13:09:46 <kliko> @simpson Yes I have learned about foldr
13:09:47 <lambdabot> Unknown command, try @list
13:10:01 <edwardk> @tell ocharles try now
13:10:02 <lambdabot> Consider it noted.
13:10:18 <neothemachine> donri: ah! I didn't know that's possible
13:10:39 <kliko> Oh I see, so list are ordered from left to right. I see
13:10:47 <kliko> and there is no way to speed it up
13:10:56 <kliko> without defining a new datastructure
13:10:58 <c_wraith> pordan30: finger trees don't necessarily give constant-time access to the ends - they give constant-time access to the fingers, which can really be arbitrarily placed. But the ends are common places for it, because it lets you build the tree in an interesting way
13:10:59 <kliko> Thanks!
13:11:07 <simpson> kliko: Hey, one other thing.
13:11:20 <kliko> yes?
13:11:26 <simpson> kliko: Why can't you go left-to-right?
13:13:03 <kliko> Well, I found this cool tutorial from Neil Mitchell about using Uniplate
13:13:03 <neothemachine> donri: the build is working again, thx :) if I now try to depend on my own package, do I have to install it everytime I change some source code?
13:13:09 <kliko> so I thought, maybe I should try this out
13:13:10 <kliko> http://community.haskell.org/~ndm/darcs/uniplate/uniplate.htm
13:13:25 <kliko> His first exercise was: Exercise: Write a function to test if an expression performs a division by the literal zero.
13:13:33 <kliko> Well I succeed it, however
13:13:42 <donri> neothemachine: as opposed to what? what are you doing now?
13:13:46 <kliko> the problem is that my function actually evaluates what's inside the div
13:14:02 <kliko> like Div a b, it evaluates b and checks whether that's zero
13:14:13 <kliko> I use the function universe to flatten my tree
13:14:19 <covi> I've seen the word 'benchmarking' for many times in different occasions. What does it mean
13:14:24 <kliko> The problem is this, if I have a div inside a div
13:14:41 <c_wraith> covi: measuring performance
13:14:43 <kliko> I will evaluate the first div, if the second div contains a division by 0, function crashes
13:14:50 <simpson> kliko: Yeah, so don't do that.
13:14:54 <kliko> That's why I thought, if I start from the right to the left
13:14:57 <neothemachine> donri: I'm using eclipsefp which compiles the tests and executables on every change... hmm I'm not really sure
13:15:03 <kliko> I will never get that case if I stop early
13:15:09 <covi> c_wraith: can you give an example?
13:15:14 <simpson> kliko: Simplify. Consider: f (Div a (Lit 0)) = True
13:15:27 <hpaste> nand` pasted “quotRem on integers” at http://hpaste.org/77498
13:15:31 <donri> neothemachine: duno what eclipsefp does. this change doesn't affect much what cabal does, anyway.
13:15:52 <nand`> that is some disturbingly ugly code; any suggestions?
13:15:53 <pordan30> c_wraith: sure, but the standard use of finger trees for defining sequences is precisely to provide constant time access to the ends of the sequence. that said, point taken.
13:16:00 <neothemachine> donri: suppose I don't have my own package installed, would it succeed if I try to install it using "cabal install --enable tests"?
13:16:19 <kliko> Simpson, are you telling me not to evaluate?
13:16:28 <neothemachine> donri: if I depend on it instead of using the source
13:16:29 <c_wraith> covi: usually it means measuring performance to compare two different things. One example would be writing two different algorithms to solve the same problem, and measuring their performance on what you expect your typical data set to look like
13:16:30 <kliko> oh no
13:16:31 <kliko> stupid me
13:16:33 <kliko> I get it
13:16:34 <simpson> kliko: I'm telling you to *pattern match*.
13:16:40 <donri> neothemachine: it always installs the library. there's no escaping that AFAIK.
13:16:56 <c_wraith> covi: Another example is testing minor tweaks of the same bit of code, to see whether you're making it faster or slower.
13:17:21 <neothemachine> donri: yes, sure, but are the tests run after the library was installed? hmm I guess so
13:17:34 <donri> neothemachine: sure
13:17:48 <roadfish> Is there texinfo pages for Haskell. Sothat I can use from emacs info.
13:17:54 <dimka> What is the best module for working with a two-dimension matrix with values of my type? `Working` means converting to matrix from list and size tuple, getting n-th row, getting n-th column
13:18:15 <donri> dimka: sounds like you want vector or repa
13:18:36 <dimka> donri: repa sounds like overkill
13:18:49 <rwbarton> vector sounds like underkill
13:19:02 <donri> underbirth?
13:19:14 <rwbarton> repa is the only array library i know of that supports slicing rows or columns of two-dimensional arrays
13:19:45 <covi> c_wraith: so for different languages, different benchmarking tools are built for these purposes?
13:20:15 <c_wraith> covi: not just languages - also applications. There are tools for benchmarking web servers, for instance.
13:20:24 <c_wraith> covi: but that's the basic idea, yes
13:21:05 * bgamari wishes there were a nice multidimensional vector-equivalent 
13:21:28 <c_wraith> bgamari: do you need something repa doesn't do?
13:21:31 <bgamari> supporting mutability, for one
13:21:37 <rwbarton> array?
13:21:54 <bgamari> rwbarton, Yeah, but array seems to be frowned upon for some reason
13:21:58 <covi> c_wraith: thx
13:22:02 <neothemachine> donri: so to test some internal code, I would have to expose those modules now with the library? isn't that a disadvantage?
13:22:07 <rwbarton> it's not trendy enough
13:22:28 <c_wraith> Array is frequently slow in ways you don't expect.
13:22:39 <c_wraith> But it does do the job it claims to
13:22:40 <nand`> heh
13:22:57 <nand`> dividing by zero in the type system makes compilation never terminate; just what I wanted
13:23:03 <bgamari> Moreover, the interoperability between vector and repa arrays is quite nice
13:23:12 <donri> neothemachine: yea, or put them in the tests tree. it's common to expose an Internal module or hierarchy, though
13:23:24 <rwbarton> that is true
13:23:25 <bgamari> I know of no way to get an array out of a repa array
13:23:30 <c_wraith> nand`: *never* terminate? That's a bug.
13:23:41 <nand`> c_wraith: -XUndecidableInstances
13:23:56 <rwbarton> i have found myself using vector and manual index calculations for repa computations i needed mutability to do (like scans)
13:23:57 <bgamari> at least no without going through storable or some other nonsense
13:24:00 <nand`> or do you mean there should be some sort of error if I wait long enough?
13:24:06 <bgamari> rwbarton, As have I
13:24:12 <c_wraith> nand`: it still should terminate - Just with an error message saying it couldn't find a solution after too many steps
13:24:15 <donri> neothemachine: you need an Internal hierarchy anyway if you want to test functions that aren't exported, rather than hiding entire modules
13:24:18 <nand`> oh, okay
13:24:36 <rwbarton> hmm, there's no Storable repa representation?
13:24:50 <rwbarton> oh it's F
13:25:09 <rwbarton> can't you use StorableArray and F matrices
13:25:13 <rwbarton> never tried myself though
13:25:19 <nand`> c_wraith: I let it run until the thread crashed because GHC ran out of memory, no error
13:25:35 <c_wraith> nand`: that might be worthy of a bug report, then.
13:25:46 <bgamari> rwbarton, Yes, I suppose you cna
13:26:51 <neothemachine> donri: hmm true
13:28:18 <c_wraith> I like providing an Internal hierarchy anyway - you never know what crazy thing someone will want to do with access to the details of your code.
13:28:34 <c_wraith> Sometimes they do really cool stuff and send you an email saying "hey, check this out"
13:29:01 <Sonarpulse> sup everybody
13:29:14 <Sonarpulse> anybody here that was helping me before?
13:29:23 <simpson> Maybe?
13:29:37 <simpson> Did you have more questions?
13:29:51 <neutrino_> he's conducting a census.
13:29:56 <simpson> Aha.
13:32:11 <scp> > liftA2 (*) id id 2
13:32:13 <lambdabot>   4
13:32:29 <mauke> that was pointless
13:32:44 <scp> (*) 2 2
13:32:47 <scp> so was that o_O
13:32:51 <mauke> > join (*) 2
13:32:52 <lambdabot>   4
13:33:03 <scp> cool
13:33:18 <nand`> Isn't there a Parser Rational somewhere in Parsec? The ‘haskell’ token parser just gives a float :: Parser Double; isn't that incorrect? I thought the rational literals in Haskell come from Rational internally
13:33:39 <scp> mauke: what are other functions useful for pointlessness?
13:34:10 <Ralith> scp: review Control.Arrow
13:34:35 <Cale> nand`: Probably the easiest thing to do would be to convert ReadS to Parser
13:34:49 <Cale> hmm
13:35:29 <mauke> scp: (.), ap, (=<<)
13:36:01 <rwbarton> flip
13:36:23 <mauke> flip can be done in terms of liftM :-)
13:36:38 <rwbarton> fix
13:41:16 <scp> :t (=<<)
13:41:17 <lambdabot> Monad m => (a -> m b) -> m a -> m b
13:41:29 <scp> :t (>>=
13:41:31 <lambdabot> parse error (possibly incorrect indentation)
13:41:32 <scp> :t (>>=)
13:41:33 <lambdabot> Monad m => m a -> (a -> m b) -> m b
13:42:19 <dimka> I have some valid type definition `type Matrix l = Array U ((Z :. Int) :. Int) l` and now I wanna put constraint incide this type definition like `type CDL l => Matrix l = Array U ((Z :. Int) :. Int) l` but this is not valid syntax. How it could be done?
13:49:13 <Sonarpulse> sorry, welll I have refactored my code into a "coding in the large" style
13:49:33 <Sonarpulse> those that were here then were dubvious that I understood typeclasses
13:49:50 <Sonarpulse> I think I understand them well enough to use them correctly
13:50:05 <Sonarpulse> but as to "best practices" in creating this type of interface
13:50:13 <Sonarpulse> I'd love some input
13:50:27 <Sonarpulse> the code is at github.com/Sonarpulse/CnC-Red-Alert
13:50:28 <Cale> dimka: Try putting the constraint on the other side of the = sign and maybe turning on whatever option it tells you to
13:52:42 <Sonarpulse> (incase that doesn't format the best for some people http://github.com/Sonarpulse/CnC-Red-Alert.git )
13:53:31 <dimka> Cale: thanks
13:53:37 <nooodl> what's the complexity of Data.List.isInfixOf? O(n^2)?
13:53:37 <lambdabot> nooodl: You have 1 new message. '/msg lambdabot @messages' to read it.
13:54:10 <lispy> nand`: what syntax do you want to parse as rational?
13:54:17 <lispy> :t 1 % 2
13:54:18 <lambdabot> Num b => b
13:54:23 <nand`> lispy: 0.5
13:54:25 <nand`> as 1/2
13:54:26 <lispy> > 1 % 2
13:54:28 <lambdabot>   2
13:54:29 <nand`> or 1%2 rather
13:54:39 <lispy> :t (%)
13:54:41 <lambdabot> a -> (a -> b) -> b
13:54:45 <lispy> wat?
13:54:47 <nand`> heh
13:54:55 <nand`> :t (Data.Ratio.%)
13:54:56 <lambdabot> Integral a => a -> a -> Ratio a
13:55:02 <nand`> poor ratio
13:55:07 <nand`> : 1/2 :: Rational
13:55:09 <nand`> :t 1/2 :: Rational
13:55:10 <lambdabot> Rational
13:55:24 <lispy> the literal 1 is really parsed as fromIntegral 1, right?
13:55:33 <lispy> I was wondering if rational does anything like that
13:55:33 <nand`> fromInteger 1
13:55:33 <neothemachine> donri: sometimes I see that for a test executable the "buildable: True" is guarded by a flag check which makes sense, but why is the "build-depends" also guarded in that block?
13:55:35 <fmap> nooodl: I'd say O(n*k)
13:55:37 <nand`> lispy: fromRational
13:55:37 <lispy> ah, fromInteger
13:55:42 <lispy> :t fromRational
13:55:43 <dgpratt> when ghc reports unknown symbol `x' in some .o file, what determines where ghc looked to try to find said symbol?
13:55:43 <lambdabot> Fractional a => Rational -> a
13:55:59 <nand`> GHC converts its literals "0.5" and so forth to actual Rationals
13:56:03 <lispy> dgpratt: --verbose=3
13:56:09 <nand`> which can actually get quite funny since they can get large for very small fractions
13:56:15 <dgpratt> lispy: thanks
13:56:19 <lispy> dgpratt: I would guess that it uses ld the same way gcc would
13:56:38 <lispy> dgpratt: if you asked about ghci I have different theories
13:56:42 <donri> neothemachine: there's an old cabal bug that it installs depends for unbuildable components
13:57:01 <lispy> > fromRational 0.5
13:57:02 <lambdabot>   0.5
13:57:08 <lispy> :t 0.5
13:57:11 <lambdabot> Fractional a => a
13:57:21 <neothemachine> donri: is this cabal bug fixed and can I ignore that now?
13:57:41 <donri> neothemachine: don't know
13:57:51 <lispy> nand`: is it the case that you can just treat anything that parses as a double as fromRational d
13:57:54 <lispy> nand`: ?
13:58:35 <otters> :t 0.5 :: Ratio Integer Integer
13:58:37 <lambdabot>     `Ratio' is applied to too many type arguments
13:58:37 <lambdabot>     In an expression type signature: Ratio Integer Integer
13:58:37 <lambdabot>     In the expression: 0.5 :: Ratio Integer Integer
13:58:38 <otters> oh wait
13:58:41 <otters> :t 0.5 :: Ratio Integer
13:58:43 <lambdabot> Ratio Integer
13:59:10 <nand`> lispy: I'm not sure what you mean
13:59:40 <lispy> nand`: If you want Rationals, could you use the parsec parser for Double and wrap the result in fromRational. I think that's why ghc does.
13:59:59 <lispy> s/why/what
14:00:07 * lispy seriously can't use the keyboard today
14:00:40 <nand`> lispy: that's what I'm doing now, but it doesn't make an awful lot of sense; since some Double can't store some values precisely
14:00:58 <nand`> you're parsing into something that has less precision, then converting to something that's supposed to have infinite precision
14:01:14 <lispy> nand`: Double/Float forces you to treat them as approximate.
14:01:22 <nand`> I'm not using Double or Float though
14:01:24 <nand`> that's the thing
14:01:37 <nand`> at least, I don't want to
14:02:28 <lispy> nand`: I guess the problem is that Double/Float/Integer/Int is more closely builtin than Rational.
14:02:38 <lispy> Rational is built on top of them
14:03:16 <nand`> Rational isn't built on Double; and I can tell you what the problem is - the problem is that Parsec hasn't defined a parser for this
14:03:25 <nand`> nothing less, nothing more
14:04:21 <lispy> In terms of the concrete syntax of haskell Rational is built on the language whereas Double/Float/Int/Integer are built into the language
14:04:49 <lispy> If my memory of the report is right, parsec's choice is the right now
14:04:51 <lispy> one*
14:05:10 <lispy> (and why Cale suggested using readS)
14:06:08 <rwbarton> floating point literals are defined in terms of Rational though
14:06:55 <JordiGH> > let repl :: (Num b, Ord b) => a -> b -> [a]; repl a n | n<= 0 = [] | otherwise = a:(repl a (n-1))
14:06:57 <lambdabot>   not an expression: `let repl :: (Num b, Ord b) => a -> b -> [a]; repl a n |...
14:07:02 <JordiGH> Hm.
14:07:09 <sfogarty> Is there a safe version of !!? Hoogle doesn't have an "[a] -> Int -> Maybe a"
14:07:16 <JordiGH> Anyways, why do I need to specify both Num and Ord for b? Surely numbers are ordered?
14:07:31 <rwbarton> complex numbers are in Num too
14:07:34 <JordiGH> Ah.
14:07:39 <mauke> :t listToMaybe .: drop
14:07:40 <lambdabot> Int -> [a] -> Maybe a
14:07:41 <lispy> rwbarton: Section 2 lists the syntax of floats, but there is no mention of rational yet
14:08:00 <rwbarton> lispy, keep reading :)
14:08:13 <lispy> Section 3 is where they introduce: An integer literal represents the application of the function fromInteger to the appropriate value of type Integer. Similarly, a floating point literal stands for an application of fromRational to a value of type Rational (that is, Ratio Integer).
14:08:35 <lispy> So the parser knows about floats, but that is translated into Rational?
14:08:53 <sfogarty> ugh, mauke.
14:08:59 <mauke> hmm?
14:09:08 <sfogarty> listToMaybe .: drop
14:09:13 <rwbarton> "float" is just the traditional name for literals that look like 0.12345 i guess
14:09:17 <mauke> sfogarty: what about it?
14:09:21 <nand`> hmm
14:09:23 <rwbarton> has nothing directly to do with Float/Double in Haskell
14:09:27 <sfogarty> It's not very elegant
14:09:33 <mauke> sfogarty: why not?
14:09:37 <nand`> I need to start optimizing for compile time, I think; these calculations are slowly starting to take their sweet time
14:09:46 <mauke> I think it's pretty much perfect
14:09:52 <nand`> I guess that means GHC doesn't memoize type families
14:10:30 <lispy> rwbarton: yeah, so phrased that way I do see what nand` is objecting to
14:10:58 <lispy> rwbarton: it should parse as fromRational (x % y) instead of fromRational (x'.y')
14:11:09 <rwbarton> i missed the context i think
14:11:12 <lispy> where the later is just sloppy way to say it's been converted to a Float
14:11:21 <nand`> > 1e-100 :: Double
14:11:23 <lambdabot>   1.0e-100
14:11:30 <nand`> > 1e-1000 :: Double
14:11:31 <lambdabot>   0.0
14:11:32 <nand`> > 1e-1000 :: Rational
14:11:34 <lambdabot>   1 % 10000000000000000000000000000000000000000000000000000000000000000000000...
14:11:42 <nand`> See why going through Double is problematic?
14:12:03 <mauke> > 1e99999
14:12:08 <lambdabot>   mueval-core: Time limit exceeded
14:12:10 <lispy> I interpret what the report says to mean that 3.1459 => fromRational (31459 % 1000)
14:12:16 <mauke> see why going through Rational is problematic? :-)
14:12:49 <lispy> nand`: yes, and I also understand what parsec should be doing there. Thanks
14:13:12 <lispy> (I think my exponent on the divisor is probably wrong)
14:13:18 <lispy> > 31459 % 1000
14:13:22 <lambdabot>   mueval-core: Time limit exceeded
14:13:29 <nand`> > 31459 / 1000
14:13:30 <lispy> > 31459 (Prelude.%) 1000
14:13:31 <lambdabot>   31.459
14:13:32 <lambdabot>   Not in scope: `Prelude.%'
14:13:32 <lambdabot>  Perhaps you meant one of these:
14:13:32 <lambdabot>    `Prelude.-' (...
14:13:37 <lispy> that :)
14:13:42 <lispy> But you get the idea
14:13:43 <neutrino_> hi
14:13:48 * nand` sees no reason to use % for ratios
14:14:03 <rwbarton> the great lens/Ratio war
14:14:16 <nand`> minor speed increase since you're saving the extra multiplication and pattern match on 1 I guess
14:14:29 <lispy> > 31459 / 10000 :: Rational
14:14:30 <lambdabot>   31459 % 10000
14:15:04 <edwardk> lens won
14:15:08 <lispy> heh
14:17:45 <dimka> How matrix-matrix multiplication could be defined with Repa.traverse?
14:19:26 <rwbarton> repa-algorithms has a naive matrix multiplication algorithm
14:20:44 <dimka> rwbarton: problem it that I wanna use my own quasi sum function insted of regular sum inside sumP
14:20:47 * hackagebot adp-multi 0.1.1 - ADP for multiple context-free languages  http://hackage.haskell.org/package/adp-multi-0.1.1 (MaikRiechert)
14:20:49 * hackagebot data-inttrie 0.0.8 - A lazy, infinite trie of integers.  http://hackage.haskell.org/package/data-inttrie-0.0.8 (LukePalmer)
14:21:14 <rwbarton> well, you can look at their implementation i guess, http://hackage.haskell.org/packages/archive/repa-algorithms/3.2.2.1/doc/html/src/Data-Array-Repa-Algorithms-Matrix.html#mmultP
14:22:02 <rwbarton> traverse is just a (sort of confusing) wrapper around fromFunction anyways
14:22:08 <neothemachine> donri: seems this cabal bug is still not fixed (https://github.com/haskell/cabal/issues/559)
14:22:19 <dimka> rwbarton: ok
14:24:07 <nyc> rwbarton: I really need sparse linear algebra stuff and it's quite lacking.
14:24:23 <nand`> oh crap, Data.Singletons doesn't promote Ord instances?
14:24:58 <nand`> great, does that mean I have to write all 2704 different cases?
14:29:35 <lispy> nyc: :( I haven't heard of any spare matrix stuff in Haskell. Is there a decent C lib you could bind to?
14:30:14 <nyc> lispy: Unknown. I'd love to hear more about such if so.
14:30:22 <hpc> http://hackage.haskell.org/package/sparse-lin-alg -- docs say it's only for integers though
14:34:15 <dimka> http://hackage.haskell.org/packages/archive/repa-algorithms/latest/doc/html/src/Data-Array-Repa-Algorithms-Matrix.html why there are Doubles everywhere? :[
14:36:47 <rwbarton> well you can just delete the type signature and it would generalize afaict
14:37:09 <dimka> Exactly
14:38:20 <latro`a> a random thing that bugs me about having general signatures: the constraint list can get really long and repetitive :/
14:39:08 <scp> nyc: I believe that GSL has good matrix routines
14:39:27 <nyc> scp: GSL is dense only
14:39:55 <scp> nyc: ok =[
14:40:15 <latro`a> example: (Fractional a1, Num a, Ord a1, Ord a) => (a1 -> a1) -> (a1,a1) -> a1 -> a -> (a1,[a1])
14:40:38 <latro`a> is the general signature of a function I have now
14:41:01 <donri> latro`a: yay ConstraintKinds
14:41:08 <latro`a> this is true
14:41:35 <donri> type C a b = (Fractional b, Num a, Ord b, Ord a)
14:42:11 <latro`a> still somewhat less explanatory IMO than the monomorphic version
14:42:35 <latro`a> (Double->Double) -> (Double,Double) -> Double -> Int -> (Double,[Double])
14:42:49 <donri> polymorphism can be more type safe though
14:42:53 <latro`a> true
14:43:02 <rwbarton> imo it makes sense to generalize a1 there but not a
14:43:33 <latro`a> a, by the way, would essentially *always* be Integral
14:43:37 <rwbarton> yes
14:43:43 <latro`a> er
14:43:44 <latro`a> wait
14:43:46 <latro`a> why would you know that
14:43:55 <latro`a> just from being Num and Ord there's no way to know that
14:43:55 <rwbarton> what else would you do with something that's Num and Ord
14:44:05 <latro`a> oh, I see
14:44:05 <rwbarton> where you don't output a new a
14:44:10 <latro`a> if that's all you're using it for, right
14:44:24 <latro`a> (it's a counter, if that's not obvious)
14:44:35 <rwbarton> i mean you could do n * n - n > 3, but that seems pretty unlikely
14:44:51 <rwbarton> it was obvious eventually
14:44:53 <latro`a> nope; it's just a counter that gets decremented at each step
14:44:57 <rwbarton> non-obviously obvious?
14:45:04 <latro`a> and then causes termination if it gets negative
14:45:27 <latro`a> eh, may as well paste the code while we're chatting about it, it's short and easy
14:45:49 <rwbarton> you could pass a [b] instead :P
14:45:51 <hpaste> latro`a pasted “adaptive trapezoidal rule” at http://hpaste.org/77499
14:46:22 <latro`a> not sure why the newlines showed up...
14:46:42 <rwbarton> only in some places, too
14:47:14 <donri> you probably have a mixture of lf and crlf
14:47:22 <latro`a> probably
14:48:16 <latro`a> anyway yeah, that little program implements the adaptive trapezoidal rule for integration
14:48:44 <latro`a> spits out the result and the nodes that were used
14:49:36 <latro`a> puts out the nodes in order, too, which is nice
14:50:27 <latro`a> oh, also
14:51:04 <latro`a> I have forgotten: does putting the constant arguments to a recursive function toward the front help with inlining at all?
14:51:45 <shachaf> latro`a: If you want to help with inlining, put the recursive part in a where.
14:51:46 <mm_freak> latro`a: it helps with sharing
14:51:57 <shachaf> (So I hear.)
14:51:59 <mm_freak> but you need to do that explicitly
14:52:16 <shachaf> mm_freak: You're talking about two different things. :-)
14:52:35 <latro`a> hm, maybe I should set up a timer and see if putting it in a where helps any
14:52:42 <latro`a> it's not in a where at all now -_-
14:52:49 <latro`a> in a let inside a guard
14:52:52 <lolcathost> Hello. I have a question - Is it possible to define iteratees in terms of the usual monad transformers in the mtl package?
14:53:18 <mm_freak> shachaf: not really, but argument order has little to do with inlining
14:53:33 <latro`a> if I explicitly defined atrap'' = atrap' f eps
14:53:44 <latro`a> would that lead to partial inlining?
14:53:50 <shachaf> mm_freak: OK, fair enough.
14:53:54 <latro`a> (might be saying this the wrong way)
14:54:03 <mm_freak> latro`a: do you want inlining or sharing?
14:54:09 <shachaf> But things like foldr k z = go where { go [] = z; go (y:ys) = y `k` go ys } do.
14:54:39 <latro`a> either really; I'm mostly just curious about any little tricks you can use to get speed boosts
14:54:48 <latro`a> this code isn't slow, but I'm curious anyway
14:55:13 <niteria> I'll ask coq question, hope you don't mind. I'm going through Software Foundations, http://www.cis.upenn.edu/~bcpierce/sf/Basics.html, on excercise mult_1_plus I just used reflexivity tactic and it felt like cheating, is that the way it was intended to be solved?
14:55:16 <latro`a> I imagine recursing a four argument function where two arguments are constant without any inlining/sharing isn't a great idea
14:55:24 <rwbarton> it would be an interesting experiment to perform the transformation shachaf mentioned and compare the two with criterion
14:56:50 <mm_freak> latro`a: my suggestion is not to bother about inlining…  GHC does a good job here by itself in most cases, and if you feel it doesn't, you should write INLINE/NOINLINE pragmas anyway
14:57:00 <latro`a> mmk
14:57:03 <mm_freak> GHC uses code size heuristics to decide whether a function is shared
14:57:09 <mm_freak> uhm
14:57:15 <mm_freak> whether a function is inlined
14:57:30 <shachaf> hi jlewis
14:57:34 <latro`a> is "partial inlining" a thing?
14:57:42 <shachaf> Clearly you're just not watching the right channels. :-)
14:57:49 <jlewis> clearly!
14:57:49 <latro`a> as in, can GHC do something like inline "atrap f eps"
14:57:57 <latro`a> without inlining all of atrap
14:58:06 <shachaf> latro`a: http://johantibell.com/files/slides.pdf
14:58:19 <mm_freak> latro`a: if "partial inlining" is "inlining of a closure", then yes, it's a thing, but i don't know whether GHC does that
14:58:23 <mm_freak> intuitively i'd say yes
14:58:24 <shachaf> Hmm, I'm not sure if those are the slides I'm thinking of.
14:58:34 <latro`a> yes I did mean inlining a closure
14:58:51 <mm_freak> like:  f x y = …
14:58:54 <tac> niteria: "cheating"? :)
14:58:57 <johnw> i enjoyed those slides
14:59:00 <mm_freak> where the implicit "\y -> …" is inlined
14:59:25 <mm_freak> anyway, put more focus on proper sharing
14:59:31 <niteria> tac: I think I was supposed to use rewrite somewhere and I didn't
14:59:38 <latro`a> how would you suggest doing that, mm_freak ?
14:59:54 <latro`a> in particular is there anything you'd suggest to improve my little toy program above?
14:59:59 <tac> niteria: tactics are programs that automatically write proof terms for you. Even though it's all under the hood, internally, reflexive (and all Coq tactics) provide a constructive proof (a program) of the theorem (the type)
15:00:12 <tac> If you can get to Qed, you win :)
15:00:25 <mm_freak> latro`a: example: "fix f = let x = f x in x" is much faster than "fix f = f (fix f)"
15:00:33 <latro`a> right
15:00:36 <lispy> tactic = higher-order proof
15:00:43 <latro`a> but I mean with that program up there
15:00:43 <lispy> tactical = higher-order tactic
15:00:44 <mm_freak> latro`a: could you gimme the link again?
15:00:48 <tac> tactic = code macro :)
15:00:49 <latro`a> sure
15:00:58 <latro`a> http://hpaste.org/77499
15:01:05 <niteria> tac: but that excerise was supposed to teach me something and if I didn't learn it I might've lost :)
15:01:09 <shachaf> mm_freak: Yes, but that's a completely different issue.
15:01:13 <rwbarton> tac: right but presumably for an exercise writing "magic_super_tactic" that works for your exercise doesn't actually teach whatever the exercise was intended to teach
15:01:26 <tac> heh, well luckily, that is an early chapter
15:02:02 <tac> niteria: If you want to understand what's going on "under the hood", I feel like Agda does a good job showing you how you can throw away your proof language, and instead work directly with a Haskell-looking programming language
15:02:14 <tac> to prove everything via well-founded recursion :)
15:02:35 <niteria> I need to learn coq
15:02:37 <mm_freak> latro`a: except for algorithmic optimizations i doubt that you can improve that code much further
15:02:45 <latro`a> mmk
15:02:57 <niteria> I think learning agda would be a lond detour
15:03:04 <niteria> s/lond/long
15:03:27 <mm_freak> latro`a: if i knew what you're doing there i could tell you how i would implement it
15:03:53 <latro`a> computing a definite integral of f on [a,b] by an adaptive integral method
15:04:09 <latro`a> (it occurs to me that "trap" could be an argument of atrap, rather than global)
15:04:12 <tac> niteria: yeah. Well, just take it with a leap of faith then for now :) Tactics get turned into proof terms.
15:04:55 <gertc> import Data.Aeson works import Data.Aeson (Object, object) does not find Object, why?
15:05:57 <mauke> ..
15:06:07 <tac> niteria: http://www.cs.st-andrews.ac.uk/~eb/drafts/impldtp.pdf <- section 4 of this paper (written for Idris, not Agda or Coq) explains the basic idea behind what a tactic system is doing.
15:06:09 <rwbarton> Object is (presumably) a data constructor
15:06:10 <tac> "under the hood"
15:06:20 <latro`a> so basically, given [a,b], compute the trapezoidal integral on [a,b] as well as by splitting it into [a,c] and [c,b], if the error estimate is small return, if not refine further
15:06:41 <rwbarton> import Data.Aeson (Value(Object), object) -- or whatever the type is called
15:06:56 <gertc> aaa yes thx :)
15:07:37 <tomeo> Hi. I thought my function had the type a -> a, but haskell tells me it is (Enum a, Num a) => a -> a. Could someone please explain why I have to add (Enum a, Num a) => ? http://pastie.org/5353507
15:07:54 <mm_freak> latro`a: so integrate by divide and conquer?
15:07:57 <latro`a> because you use an enumeration [1..n] and ^2
15:08:01 <latro`a> mm_freak, yes
15:08:17 <mauke> tomeo: what would sumsql "hello" do?
15:08:26 <Nereid> tomeo: the type of (^) requires the first argument to be a Num.
15:08:51 <Nereid> and [x..y] is the same as enumFromTo x y, which requires an Enum type
15:08:58 <mm_freak> latro`a: how do i estimate the error such that it also works for chaotic functions?
15:09:08 <hpc> tomeo: a part of the type signature which is hidden by default is "for all a"
15:09:14 <latro`a> that is a tremendously more difficult problem
15:09:19 <niteria> tac: thx, for now I'll take it on faith, I'll revisit this sometime in the future
15:09:24 <hpc> so "a -> a" is "for all a, function from a to a"
15:09:26 <latro`a> the math behind this method assumes the function is at least twice continuously differentiable
15:09:33 <tac> niteria: Software Foundations is pretty good, though :)
15:09:44 <hpc> "(Enum a, Num a) => a -> a" is "for all a that is a number and an enumeration, function from a to a"
15:10:08 <hpc> and yes, you're using enum and num stuff in that function, which is why the constraints are there to begin with
15:10:29 <tomeo> Nereid: so if I am using powers on a parameter I have to add Num a, and if I am using enumerations on parameters I have to use Enum?
15:10:48 <mm_freak> latro`a: given (^2) and i want to integrate [-1;1], would that algorithm terminate immediately?
15:11:26 <latro`a> as I recall for (^2) on [-1,1] it will need one more node
15:11:29 <tomeo> Is there an easy way to learn what types I have to add for each case in the future or should I just learn as I go?
15:11:35 <latro`a> and will then terminate with the floating-point-exact answer
15:12:02 <latro`a> an adaptive simpson rule would terminate immediately
15:12:07 <simpson> ?
15:12:09 <latro`a> ...lol
15:12:11 <mm_freak> lol
15:12:11 <simpson> Oh.
15:12:20 <hpc> that's even funnier than when someone mentions haskell program coverage
15:12:22 <tomeo> thanks everyone btw
15:12:24 <mauke> tomeo: just let the compiler tell you the type
15:12:49 <tomeo> mauke: I read it's good form to write it myself and I'm under the impression that I'll learn more if I do :)
15:12:50 <dimka> What haddock `{-# INLINE [3] sumAllP #-}` means?
15:13:06 <shachaf> It's not really Haddock.
15:13:09 <mauke> tomeo: then ask ghci for the types of whatever functions you're using
15:13:12 <shachaf> It's an optimization thing.
15:13:14 <mauke> :t (^)
15:13:15 <shachaf> @google ghc inline
15:13:17 <lambdabot> http://www.haskell.org/ghc/docs/7.0.4/html/users_guide/pragmas.html
15:13:17 <lambdabot> Title: 7.13.�Pragmas
15:13:17 <rwbarton> it controls the timing of inlining of sumAllP
15:13:17 <lambdabot> (Integral b, Num a) => a -> b -> a
15:13:27 <mauke> :t \n -> [1 .. n]
15:13:29 <lambdabot> (Enum t, Num t) => t -> [t]
15:13:43 <mauke> (that one is harder to check because it's syntactic sugar for enumFromTo)
15:13:45 <mauke> :t enumFromTo
15:13:47 <lambdabot> Enum a => a -> a -> [a]
15:13:50 <mauke> :t 1
15:13:51 <lambdabot> Num a => a
15:19:48 <tomeo> I have been given an assignment to write a function first using recursion and then pattern matching. From reading my book I've understood that recursion in haskell uses pattern matching. What is the difference?
15:20:34 <shachaf> It sounds like your assignment is nonsense or you're misunderstanding it.
15:20:42 <shachaf> Recursion is orthogonal to pattern-matching.
15:21:41 <tac> tomeo: pattern matching is when you break stuff apart by its constructors. Recursion is when a function calls itself
15:21:42 <tomeo> shachaf: haha, I read it wrong. It just says mapping. Not pattern matching
15:21:45 <mauke> I think you're supposed to write a recursive function, first without pattern matching and then with
15:21:53 <mauke> or that
15:22:05 <tomeo> sorry about that :)
15:22:41 <shachaf> tac: There are some examples of recursion where a function doesn't call itself.
15:22:59 <tac> shachaf: ehh?
15:23:06 <pordan30> mutual recursion?
15:23:12 <shachaf> let x = x in x
15:23:26 <tac> that's no function :P
15:23:42 <tac> but yeah, Haskell allows for recursive values too
15:23:42 <mauke> it's a space station
15:23:52 <gertc> why are class methodes not imported like a constructor? example FromJSON(parseJSON)
15:23:55 <tac> but you still have a self-reference instead of a self-call
15:23:57 <latro`a> oh hey, this looks a lot prettier now...
15:24:11 <hpaste> latro`a annotated “adaptive trapezoidal rule” with “adaptive trapezoidal rule (annotation)” at http://hpaste.org/77499#a77500
15:24:20 <latro`a> donri, good call with ConstraintKinds here
15:24:45 <mm_freak> tac: as a side note, recursion is a broader concept
15:24:52 <mm_freak> > let ones = 1 : ones in ones
15:24:54 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
15:25:06 <tac> mm_freak: that's still a self-reference.
15:25:15 <mm_freak> yeah, just not of a function =)
15:25:17 <tac> Recursion is whenever a function or value knows about itself.
15:25:28 <tac> In the case of a function, it most often calls itself
15:25:56 <mm_freak> i think it's safe to say that (monomorphic) recursion is "fix"
15:26:14 <tac> pfft. "general" recursion, maybe :P
15:26:20 <shachaf> mm_freak: That's totally corecursion, man.
15:26:29 <mm_freak> shachaf: "that"?
15:26:31 <tac> also, fix doesn't work in strict evaluation, IIRC
15:26:32 <shachaf> ones
15:26:37 <shachaf> Sure it does.
15:26:45 <mm_freak> yeah
15:26:57 <mauke> I've been using fix in Perl for years
15:27:01 <mm_freak> except that in haskell there is (unforutnately) no difference between recursion and corecursion
15:27:02 <tac> you have to be a little more clever, at least
15:27:03 <Philippa> tac: the classic Y operator doesn't, but so what?
15:27:04 <shachaf> You have to eta-expand, of course.
15:27:12 <tac> Philippa: sew buttons
15:27:28 <Philippa> hey, my arse isn't /that/ fat
15:28:15 <tac> Philippa: http://www.snpp.com/episodes/4F10.html CTRL+F sew buttons
15:28:51 <gertc> o wait you can import it also like FromJSON(parseJSON), and FromJSON, parseJSON doh :) can you deprecate teh second way, it confuses noobs :)
15:30:48 * hackagebot fsnotify 0.0.3 - Cross platform library for file creation, modification,  and deletion notification.  http://hackage.haskell.org/package/fsnotify-0.0.3 (RaphaelJavaux)
15:30:54 <rwbarton> what?
15:30:54 <lispy> That feeling when you implement something and 24 hours later think of a simpler yet more powerful representation.
15:31:05 <rwbarton> oh because it's a class method?
15:31:11 <gertc> yes
15:31:13 <parcs`> dat feel
15:31:47 <gertc> would it not be better you have to import it like this FromJSON(parseJSON)?
15:32:05 <gertc> and not FromJSON, parseJSON
15:32:34 <rwbarton> no
15:32:37 <gertc> or is there a difference?
15:32:39 <rwbarton> i'm surprised that works at all
15:32:49 <gertc> me too
15:33:19 <gertc> import Data.Aeson ((.:), (.=), Value(Object), FromJSON(parseJSON), ToJSON, toJSON, object, decode)
15:33:20 <rwbarton> anyways you surely shouldn't have to know whether or not parseJSON is a type class method if you just want to import it
15:33:28 <rwbarton> right, that is crazy
15:33:46 <rwbarton> import Data.Aeson ((.:), (.=), Value(Object), parseJSON, toJSON, object, decode)
15:33:49 <rwbarton> isn't this enough?
15:34:02 <rwbarton> or do you define FromJSON/ToJSON instances
15:34:09 <rwbarton> or need the class name for a type signature
15:34:29 <gertc> nope wait i will post full link
15:34:41 <rwbarton> the thing is with Object the Value(Object) syntax is necessary because otherwise it would't know whether you want the type Object or the value Object
15:34:44 <rwbarton> *wouldn't
15:35:01 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/Json.hs
15:35:20 <rwbarton> oh
15:36:54 <gertc> for me its realy confusing teh compiler alows ToJSON, toJSON
15:37:33 <atriq> Is Aeson the way to go for JSON in Haskell?
15:37:49 <Ralith> it has lens support
15:37:51 <Ralith> so probably
15:37:54 <gertc> i hope so i cost me a week to understand it :)
15:38:06 <johnw> striq: it's pretty easy to use
15:38:14 <johnw> strig: make sure to check out aeson-lens too
15:42:16 <Cale> Well, you should be able to easily construct lenses for any reasonable JSON representation
15:42:23 <Cale> But lenses are a good idea for that sort of thing
15:43:07 <gertc> when you are talking of lens stuff its all related to this right? http://hackage.haskell.org/packages/archive/lenses/0.1.2/doc/html/Data-Lenses.html
15:43:13 <johnw> no
15:43:21 <rwbarton> sort of related
15:43:30 <rwbarton> well, related but not exactly that package
15:43:45 <Cale> related, but really everyone is using the package called 'lens'
15:43:57 <Cale> http://hackage.haskell.org/package/lens-3.2
15:43:59 <otters> do the words "monad" and "monoid" come from the same root?
15:44:06 <pordan30> "one"
15:44:08 <ciaranm> otters: yes and no
15:44:13 <Cale> otters: monad is a blend of monoid and triad
15:44:13 <tomeo> matching in haskell /= pattern matching ?
15:44:14 <johnw> strangely, you can't find lens on Hoogle
15:44:25 <otters> okay
15:44:29 <johnw> tomeo: depends on what you mean by "matching" in the beginning of that sentence
15:44:35 <otters> I was trying to figure out the relationship between Monad and Monoid because they sounded similar
15:44:38 <Iceland_jack> otters: they are cognates
15:44:44 <otters> Monoid sounds like something that is Monad-y
15:44:48 <ciaranm> otters: a monad is a monoid in the category of endofunctors
15:44:49 <otters> Iceland_jack: okay
15:44:53 <otters> I'm aware of that
15:44:59 <Cale> (triad/triple/standard construction were early not-so-good names for what became "monad")
15:45:14 <otters> what does triple refer to?
15:45:16 <rwbarton> standard construction, shudder
15:45:19 <cmccann> monad, dyad, triad... uh, tetrad?
15:45:19 <tomeo> johnw: "Define a function that computes the sum of the squares of the numbers from 1 to n. Use recursion. Now use mapping instead"
15:45:27 <gertc> ok i will figure out the details later, at least i know where to start at http://hackage.haskell.org/package/lens-3.2
15:45:34 * cmccann doesn't think he's seen that sequence continued past three
15:45:37 <rwbarton> otters: the monad, return, join
15:45:41 <Cale> otters: The fact that it's (T, eta, mu), where T is an endofunctor C -> C, and eta: 1 -> T, mu: T^2 -> T
15:46:01 <johnw> tomeo: how is that related to matching?
15:46:04 <Cale> yeah, and "eta" = "return", "mu" = "join"
15:46:08 <otters> okay I definitely need to learn category theory
15:46:22 <johnw> otters: you'll thank yourself later
15:46:24 <tomeo> johnw: Im not sure. I haven't seen the term matching in haskell before. only pattern matching
15:46:36 <otters> no kidding
15:46:39 <otters> I love abstract math
15:46:42 <rwbarton> tomeo: so where do you see it
15:46:46 <rwbarton> > "mapping" == "matching"
15:46:47 <lambdabot>   False
15:46:57 <cmccann> btw, here's everything I know about where the term "monad" comes from: http://english.stackexchange.com/a/30661/10124
15:46:59 <Cale> "monoid" on the other hand is more closely related to the sense of "one"-ness
15:47:03 <cmccann> in case anyone is curious :P
15:47:07 <tomeo> rwbarton: in the sentence I wrote to johnw
15:47:15 <johnw> Cale: a monoid is a category with one object?
15:47:31 <Cale> johnw: hah, that's a good retroactive reason for the name
15:47:33 <otters> that's what wikipedia says
15:47:40 <otters> :p
15:47:43 <Cale> but really it's named after the fact that there's an identity element
15:47:51 <Cale> which is the "1" for the "multiplication"
15:48:00 <mauke> mono-id
15:48:04 <johnw> ahh
15:48:05 <arbn> johnw: A monoid is a "semigroup with unit".
15:48:09 <rwbarton> tomeo: sorry, which sentence exactly
15:48:23 <tomeo> rwbarton: : "Define a function that computes the sum of the squares of the numbers from 1 to n. Use recursion. Now use mapping instead"
15:48:28 <johnw> arbn: I always thought a semigroup was a monoid without unit ;)
15:48:29 <Cale> I think the category with one object is a better reason for the name than the original one though :)
15:48:32 <ciaranm> Aluffi, definition 1.1: a group is a groupoid with a single object
15:48:39 <rwbarton> > "matching" `elem` words "Define a function that computes the sum of the squares of the numbers from 1 to n. Use recursion. Now use mapping instead"
15:48:41 <lambdabot>   False
15:48:52 <rwbarton> i still don't see it
15:48:54 <otters> now all I want to know is why they're separated into Control and Data
15:48:54 <tomeo> damn
15:49:00 <otters> whose idea was that
15:49:00 <tomeo> rwbarton: sorry
15:49:05 <Cale> ciaranm: I fully support this approach to group theory :)
15:49:08 <tomeo> getting tired :)
15:49:31 <shachaf> Wait, didn't we have this exact thing a few minutes ago?
15:49:35 <rwbarton> yes
15:49:42 <tomeo> yes I'm an idiot
15:49:45 <otters> Monad etymology?
15:49:47 <atriq> http-conduit has a LOT of dependencies...
15:50:02 <Cale> imo, the reason that group theory is important is that every time we study something in mathematics, we always form categories of the structures we're considering, and every object in every category has an automorphism group
15:50:15 <rwbarton> yes. groups are for acting on things
15:50:40 <ciaranm> in that case yoneda is even more important!
15:51:10 <Cale> Categories are what come out of studying the analogies between structures. Groups are what come of studying the exact analogies between a structure and itself.
15:51:16 <johnw> striq: be thankful it doesn't depend on another version of itself
15:51:47 <cmccann> better that than a future version of itself
15:52:24 <Cale> (i.e. the symmetries of an object)
15:52:31 * cmccann makes all his code depend on future versions of itself so that he can just re-export the functionality from after it already exists
15:53:00 <ciaranm> i find myself needing something like symmetries but with weaker axioms.
15:53:07 <cmccann> closed timelike curve-driven development, gonna be the next big thing
15:53:27 <otters> all the bugs are prepatched too
15:54:02 <johnw> cmccann: isn't it already the next big thing?  we're just not there yet
15:54:24 <c_wraith> It's the current big thing, as soon as we fix the bugs.
15:54:27 <cmccann> johnw, well it's a lot like tying the knot, just with causality instead of data
15:54:37 <cmccann> a minor implementation detail really
15:54:45 <johnw> cmccann: does that mean it's an occasion to use codata?
15:54:47 <atriq> Ugh
15:55:00 <atriq> Just installed a lot of libraries and didn't tell Cabal to haddock them
15:55:15 <johnw> strig: set documentation = true in your ~/.cabal/config, stat!
15:55:30 * cmccann will never understand why that's not the default behavior in cabal :T
15:55:43 <johnw> that and library profiling should both be default
15:55:58 <johnw> learning that you need profiling to track down a problem after you've already installing 60 dependencies is a huge PITA
15:56:13 <cmccann> it would be wasteful for anyone who just wants to build and install an application
15:56:15 <ciaranm> what you need is a not crap package mangler!
15:56:20 <johnw> well, that's true
15:56:33 <johnw> the first time cabal is run, then, it should ask if you're a daveleoper or something
15:56:34 <cmccann> but really, how many people are going to be building a haskell program from source using cabal who aren't Haskell programmers anyway?
15:57:14 <cmccann> rather than downloading a binary or using a system package manager or whatever
15:57:26 <johnw> cmccann: future me says your future version works great, thank
15:57:28 <johnw> s
15:57:31 <cmccann> :D
15:57:33 <koala_man> I would have agreed before Gentoo
15:57:40 <ciaranm> integrating cabal with the system package mangler is a pain in the ass
15:57:46 <Cale> cmccann: Yeah, that's one of my top list of cabal annoyances too
15:57:56 <Cale> Documentation and profiling should be on by default
15:58:05 <Cale> and let people who want to save time turn them off explicitly
15:58:13 <otters> wow, codata.
15:58:17 <johnw> where's Johan, let's get this changed now!
15:58:22 <cmccann> my contention is that almost everyone who wouldn't want docs and profiling in cabal can use the system package manager and avoid cabal entirely
15:58:42 <thoughtpolice> i'd be OK with profiling by default, especially now that we have parallel dependency installs, which help cut down the time
15:58:53 <Cale> also, we should advertise the documentation feature better
15:58:58 <Cale> I don't know exactly how
15:59:12 <Cale> Maybe at the end of an install, a file URL to the docs :)
15:59:26 <johnw> Cale: error messages could link to documentation on the function being misused :)
15:59:27 <cmccann> I expect that the vast majority of people who use cabal with profiling and haddock disabled are the ones who forgot to turn it on and will be kicking themselves in a few days
15:59:46 <johnw> cmccann: 100% agree
15:59:54 <johnw> I was just such a person
16:00:08 <cmccann> I think most of us have at least once :[
16:01:34 <johnw> past me face-palms
16:02:04 <shachaf> cmccann: Or people who don't actually want to profile Haskell code.
16:02:05 <cmccann> that's the problem with past selves
16:02:09 <cmccann> they always make so many obvious mistakes
16:02:16 <shachaf> They just want xmonad and pandoc or something.
16:02:37 <cmccann> xmonad is probably the real counterargument here
16:02:49 <shachaf> The countercounterargument is apt-get install xmonad
16:03:11 <Saizan> the countercountercounterargument is custom xmonad.hs
16:03:19 <cmccann> does xmonad's recompilation stuff not need any haskell build stuff?
16:03:27 <shachaf> Saizan: the countercountercountercounterargument is apt-get install libghc-xmonad-dev
16:03:30 <int-e> Saizan: do you need cabal for that?
16:04:08 <Saizan> shachaf: there's also a xmonad-contrib?
16:04:15 <int-e> Saizan: I'd hope that xmonad just invokes ghc directly ... and not care about or use profiling.
16:04:33 <atriq> Whew, fixed it
16:04:39 <Saizan> int-e: yeah, my point is that you wouldn't use profiling
16:04:40 <typoclass> maybe pandoc is a better example? with xmonad, when you want to have anything but the most basic config, you need to configure it, i.e. edit a haskell source file and feed it into ghc
16:04:43 <caseyjames> Hi, does anyone have any experience setting upi haskell on ios/arm?
16:05:06 <Saizan> int-e: i wasn't thinking of -dev packages though
16:05:13 <niteria> don't xmonad users eventually become haskell programmers? They'll need profiling and docs eventually
16:05:19 <Saizan> i.e. i forgot about them
16:05:22 <shachaf> Saizan: libghc-xmonad-contrib-dev?
16:05:33 <Saizan> shachaf: then we're good
16:05:39 <int-e> Saizan: they are a bane to developers :P
16:06:08 <cmccann> int-e, users always are
16:06:18 <cmccann> programming is so much easier when you don't have to worry about users
16:06:24 <int-e> cmccann: not users, the dev packages
16:06:28 <int-e> Saizan: (this is one of the very few regrets that I had when switching from Gentoo to Debian)
16:06:34 <cmccann> oh ok then :P
16:06:58 <Saizan> you know what's worse than users? other devs reading your code
16:07:24 <cmccann> using gentoo is nice if you live in a cold climate, helps keep the room warm in winter
16:07:45 <Saizan> i use youtube for that
16:07:55 <int-e> Saizan: eek, you are using Cheddar cheese in your code? Wensleydale is much better!
16:08:24 <cmccann> most of the web runs on rotting maggot cheese though
16:08:42 <jmcarthur> i have thankfully never needed profiling for xmonade
16:08:44 <jmcarthur> *xmonad
16:08:48 <tomeo> Is there any special reason that one would use foldl (+) 0 list instead of just sum list?
16:08:58 <cmccann> (cf. http://en.wikipedia.org/wiki/Casu_marzu )
16:09:01 * int-e makes a note to try out Wensleydale ... I only know that from Wallace and Gromit.
16:09:22 <Saizan> tomeo: no, one might want to use foldl' (+) 0 list though
16:09:30 <jmcarthur> tomeo: not that i can think of, unless they use foldl' instead of foldl (but at least for the case of sum ghc with optimizations will catch it anyway)
16:09:32 <shachaf> "dons: Profiling your window manager so you don't have to."
16:09:50 <shachaf> That's completely untrue, of course. dons abandoned us years ago.
16:09:55 <jmcarthur> :(
16:10:13 <cmccann> I hear he was captured by the forces of evil
16:10:17 <tomeo> jmcarthur: can't find foldl' on google. is it an optimized version of foldl?
16:10:30 <shachaf> He didn't even reply to my patch fixing ghc-core.
16:10:35 <Saizan> @hoogle foldl'
16:10:35 <lambdabot> Data.List foldl' :: (a -> b -> a) -> a -> [b] -> a
16:10:35 <lambdabot> Data.Foldable foldl' :: Foldable t => (a -> b -> a) -> a -> t b -> a
16:10:36 <lambdabot> Data.ByteString.Char8 foldl' :: (a -> Char -> a) -> a -> ByteString -> a
16:10:39 <shachaf> Maybe I should take over maintaining ghc-core?
16:10:47 <Saizan> shachaf: you should!
16:11:13 <Saizan> shachaf: and add flags for less noisy output
16:11:51 <Saizan> tomeo: foldl' is a version of foldl which will reduce the accumulator to WHNF at every step
16:11:55 <shachaf> Saizan: There are so many fixes that could be made to it!
16:12:21 <Saizan> shachaf: make them!
16:12:52 <tomeo> Saizan: sad to say I don't know what that means
16:13:05 <shachaf> Saizan: If you get dons's approval.
16:13:06 <typoclass> how about this? turn on docs and profiling by default for everything. then allow an option "profiling: False" for xmonad.cabal, pandoc.cabal, and any package that serves mostly users who don't develop
16:13:36 <shachaf> typoclass: Not really.
16:13:37 <Saizan> tomeo: Weak Heah Normal Form means that the outermost constructor is evaluated
16:13:47 <shachaf> typoclass: Besides, library-profiling is already separate from executable-profiling.
16:14:07 <typoclass> tomeo: this might help explain http://www.haskell.org/haskellwiki/Foldr_Foldl_Foldl'
16:14:11 <int-e> typoclass: that sounds awful to me - packages randomly building without profiling ...
16:14:17 <Saizan> tomeo: it's paricularly useful for flat types like Int, where that means values of such types are completely evaluated
16:14:21 <jmcarthur> shachaf: please maintain ghc-core!
16:14:24 <tomeo> thanks Saizan typoclass
16:14:35 <jmcarthur> i will now blame you for it not keeping up with the times
16:14:41 <typoclass> int-e: hm, that's a good point
16:14:45 <shachaf> jmcarthur: Get hold of dons and I'll do it!
16:14:55 <shachaf> jmcarthur: I don't have push access to the darcs repository, see.
16:15:10 <Saizan> where's the repo?
16:15:27 <shachaf> code.haskell.org?
16:15:30 <shachaf> community.haskell.org
16:15:32 <shachaf> Something.
16:15:37 <shachaf> Also I don't want to use darcs.
16:15:54 <Saizan> ok, so we don't have to care about the repo
16:16:03 <shachaf> I think the code could be simplified a lot...
16:16:22 <edwardk> preflex: xseen ocharles
16:16:29 <edwardk> oh i guess we might not have preflex any more
16:17:28 <Saizan> mauke: maybe you could ask lispy if preflex can share a room with lambdabot
16:17:38 <shachaf> ocharles: hi
16:17:50 <jmcarthur> shachaf: you don't need access to it. just fork and start uploading to hackage. dons will catch up as long as you make an attempt to let him know
16:18:01 <int-e> dcoutts_: Hmm. Could one sensibly use separate package databases for profiled / vanilla / dynamic versions of libraries?
16:18:12 <jmcarthur> i see no reason to avoid darcs though... :(
16:18:55 <int-e> (oh he's probably asleep)
16:19:08 <shachaf> jmcarthur: darcs has a confusing UI
16:19:10 <jmcarthur> shachaf: actually, you could just fork it under a new name, even
16:19:10 <Saizan> shachaf: i think we could catch him easily on twitter
16:19:15 <jmcarthur> a confusing ui, wha-?
16:19:16 <shachaf> git makes much more sense.
16:19:17 <cmccann> I think "using github" is the main reason to avoid darcs
16:19:20 <jmcarthur> :o
16:19:36 <typoclass> shachaf: how do you mean? it's exactly the opposite of how i feel about it
16:19:40 <shachaf> Saizan: Oh, that's possible. Can you Twitterize at him to ask about #haskell taking over ghc-core?
16:19:51 <jmcarthur> the only reason i ever use git is if i didn't start the project
16:19:54 <shachaf> typoclass: git's UI and data model make perfect sense to me.
16:19:59 <shachaf> darcs is just weird.
16:20:16 <jmcarthur> i understand both git and darcs, and i think darcs is waaaay simpler
16:20:20 <shachaf> Note: The only reason this is true is that I've used git for a few years and almost haven't used darcs at all.
16:20:31 <cmccann> shachaf, I think you're the only person I've ever heard say that git makes more sense...
16:21:02 <Saizan> shachaf: i thought it was you rather than #haskell :)
16:21:17 <jmcarthur> i think the best technical argument against darcs i've heard is that you can't just give somebody a revision number when you're trying to describe the state of your repo (e.g. when doing a bug report or something)
16:21:41 <jmcarthur> unless it happens to coincide with a tag
16:22:27 <shachaf> Saizan: Well, whatever, man.
16:24:44 * nand` switched to darcs because git was so confusing
16:25:25 <Ralith> I get the impression that darcs is falling out of use lately; is this accurate?
16:25:45 <shachaf> Saizan: So you'll do it?
16:26:04 <cmccann> in my experience people who use darcs seem pretty dedicated to sticking with it...
16:26:04 <typoclass> Ralith: not sure. fwiw, i'm happy with darcs and abandoned git a few years ago
16:26:06 <lispy> Ralith: I'd say so. I felt like one of the holdouts and I converted to git/github a while back.
16:26:37 <lispy> The thing about git is that github is just too attractive.
16:26:40 <Ralith> perhaps someone just needs to write darcshub
16:26:48 <cmccann> git is just the price of admission :T
16:26:49 <Saizan> shachaf: https://twitter.com/saizan/status/267060514536972288
16:26:52 <lispy> Ralith: there have been 3-4 attempts at that
16:26:58 <Ralith> why'd they fail?
16:27:09 <rwbarton> darcshub.com redirects to github.com ... nice
16:27:15 <rwbarton> does github support darcs repos?
16:27:19 <lispy> because adoption is a very different problem to making software?
16:27:22 <rwbarton> that sounds like it would be a lot of work
16:27:33 <mauke> I abandoned darcs for git
16:27:35 <Saizan> http://hub.darcs.net/ <- farily recent
16:27:40 <Saizan> *fairly
16:27:45 <Ralith> lispy: I didn't ask "why aren't they as popular as github."
16:27:51 <mauke> git was about 400% more robust/stable
16:28:09 <Ralith> ah.
16:28:15 <lispy> Ralith: yes, but that is my direct answer to why they failed. I accidentally went to the next answer :)
16:28:16 <Ralith> I thought reliability was darcs' whole thing?
16:28:29 <typoclass> well, "was"
16:28:34 <Ralith> ?
16:28:42 <shachaf> I used to use darcs but the only reason I really used it was Haskell.
16:28:42 <mauke> when I was still using it, it semi-regularly corrupted its state
16:29:18 <typoclass> Ralith: sorry, i meant referring to mauke's comment that git *was* more robust
16:29:55 <Ralith> typoclass: ah.
16:29:56 <acowley> Let's also not forget git's speed. darcs has improved, but git forced the issue for everyone.
16:30:03 <Saizan> nah, reliability has never been darcs' big thing
16:31:09 <typoclass> acowley: that is an issue, but i feel it's smaller than people think. i'm not going to spend hours learning the weird complicated thing just to save 3 seconds of runtime now and then
16:31:45 <acowley> Can anyone offer any advice on how to debug ghc-mod not working for me anymore? Not sure what happened, but it doesn't seem to know about my user package db, and is generally disinclined to be its usual helpful self.
16:32:05 <mauke> which part of git is the weird/complicated bit?
16:32:09 <acowley> typoclass: I used bzr for a while, then went to git and it was night and day.
16:32:27 <acowley> typoclass: It's a small thing for most of us, admittedly, but speed is always nice to have.
16:32:43 <parcs`> darcs just feels fragile to me
16:32:54 <shachaf> You can't spell fragile without agile.
16:33:02 <acowley> hahaha
16:33:10 <typoclass> shachaf: also, 'rag'
16:33:19 <rwbarton> i found a bug in git once! it had already been fixed in the repo though
16:33:28 <rwbarton> i was very disappointed
16:33:53 <rwbarton> it was a good bug too, a function was returning a pointer to memory on its stack
16:33:57 <mauke> I found a bug in git once! it was caused by gentoo modifications to the package, apparently
16:34:09 <parcs`> i sent a documentation patch to git a week or two ago
16:35:14 <typoclass> i once asked #git if "git ls-files --cached" will list the cached files. they said of course not
16:35:20 <Saizan> i just wish i knew what the stash is about
16:35:44 <shachaf> git ls-files --stached
16:36:08 <geekosaur> here too?
16:36:11 <geekosaur> [09 19:13] <geekosaur> enh.  I had no trouble adopting distributed version control but git still feels like it has its skin on backwards to me
16:36:12 <mauke> Saizan: wasn't it just a stack of changesets?
16:36:19 <sm> darcs' big thing is simplicity
16:37:10 <acowley> For me, the big step up in usability is github's pull requests.
16:37:26 <acowley> --stached should probably be an option for every executable
16:37:28 <Saizan> mauke: could be, i've never looked into what it is or what its purpouse is
16:37:44 <mauke> acowley: for me it's the ability to go back to previous states of the source tree
16:37:51 <mauke> I never figured out how to do that with darcs
16:38:05 <parcs`> i don't really like pull requests. git format-patch and git send-email is much simpler and more versatile than pull requests
16:38:23 <typoclass> Saizan: it's perfectly simple. when you do "git prepare -u" for a reverse fast-forward, you can use stash in order to origin-fetch any stray refs in the index. you can backtrack to the last known treeish by just doing "git buddle --mode=penta -f=^HEAD"
16:38:46 <acowley> Saizan: it lets you push your changes onto a stack, patch a high priority issue, push that change, then pop the stack to get back to where you were. Most folks use branches for this sort of thing, but stash is arguably quicker/easier.
16:38:48 <Saizan> mauke: what i do is darcs get somewhere else and unpull
16:38:59 * cmccann tries to decide how much of what typoclass just said is a joke
16:39:08 * Ralith smacks typoclass 
16:39:20 <mauke> cmccann: everything
16:39:25 <donri> meh, who needs pull requests. on darcshub you can cherry pick patches from downstream right on the site.
16:39:34 <mauke> Saizan: ... that's ridiculous
16:39:35 <typoclass> cmccann: 99% is a good default if this guy "typoclass" is involved ...
16:39:48 <mauke> especially given how slow darcs is at ... everything
16:40:04 <cmccann> well, I try not to underestimate git's potential for having weird arcane crap
16:40:14 <Saizan> sometimes you darcs send -O instead, to save the patches you want to unpull
16:40:16 <parcs`> i use git stash when switching branches to keep track of any changes that do not (yet) warrant a commit
16:40:27 <donri> mauke: when did you last use darcs? it's certainly slower than git, but not ass-slow as used be.
16:40:30 <typoclass> cmccann: yeah, _that_ is the joke i was getting at :D
16:40:37 <mauke> donri: years ago
16:40:48 <Saizan> acowley: does each branch have its own stash?
16:40:50 <donri> mauke: ah. it's much faster these days.
16:41:17 <typoclass> mauke: well press alt-tab and enjoy some lolcats
16:41:23 <mauke> donri: does it still autogenerate conflicts in clean repositories?
16:41:37 <acowley> Saizan: I don't think so, but I don't use it myself so don't really know for sure.
16:41:41 <donri> don't know that behavior
16:41:56 <donri> what do you mean generate conflicts?
16:42:04 <geekosaur> last time i saw that behavior was rakudo's git repo...
16:42:09 <Saizan> acowley: i guess i'm not the only one staying away from it
16:42:14 <parcs`> does darcs have branches?
16:42:20 <donri> parcs`: not like git
16:42:36 <mauke> parcs`: no
16:42:46 <acowley> Saizan: Yeah, I try to encourage myself to be disciplined about branches. Anything more is asking too much :P
16:42:49 <parcs`> that's unfortunate
16:42:50 <mauke> parcs`: but you can cp -r your files to new directories
16:42:51 <donri> parcs`: each repo is considered a branch, and local copies share patches
16:42:54 <mauke> or something
16:43:09 <parcs`> donri: oh is that what ~/.darcs is?
16:43:22 <donri> i find many of the git uses of branches aren't needed as much with darcs, but when you do want branches it is less convenient in deed
16:43:39 <mauke> donri: I had darcs repositories that simply tracked upstream xmonad and xmonad-contrib
16:43:42 <donri> although it does simplify the UI a lot
16:43:53 <donri> parcs`: among other things yes
16:43:57 <parcs`> i love branches
16:44:07 <acowley> and branches love parcs
16:44:10 <donri> i love branches when i'm working with git ;)
16:44:39 <mauke> I don't remember the details but I got checksum errors / conflicts in them, even though I never modified any of their files
16:45:03 <donri> mauke: i've never had that and i do modify files
16:45:14 <sm> mauke: I do that all the time.. if you can reproduce it today I'm sure darcs devs will be interested
16:46:05 <donri> i didn't use darcs back when it had all these famous problems. seems most of the scarier ones are fixed today, not that darcs is perfect as-is now either.
16:47:33 <Saizan> there's been a bug with checksums cause of a gzip binding i think at some point
16:47:56 <donri> parcs parcs' advanced revision control system
16:52:22 <Guest91353> say I have a type Foo :: * -> * -> *
16:52:49 <Guest91353> and I define a type Bar a = Foo a a
16:53:09 <Guest91353> is there a way to make a class instance C Bar where ...
16:53:13 <Guest91353> or at least emulate doing that?
16:57:38 <parcs`> donri: lol
16:57:40 <typoclass> Guest91353: hello, is a "class instance" something enabled by a ghc extension? i'm not familiar with the term
16:57:59 <Guest91353> an instance of a class
16:58:10 <Guest91353> just instance, then
16:58:17 <Guest91353> disregard "class" in that sentence
16:58:41 <typoclass> Guest91353: ok i see :-) because the TypeFamilies extension offers "data instances" afaik
16:58:46 <Cale> Guest91353: You can't make instances for synonyms
16:58:48 <Guest91353> class instance is not a thing
16:58:57 <Guest91353> well
16:58:59 <Guest91353> that's a bummer
16:59:11 <Guest91353> because I remember it working in 7.4
16:59:11 <Cale> because they're not really separate types
16:59:25 <Guest91353> but they tightened up the "type synonyms need to be fully applied" rule in 7.6
16:59:42 <Cale> Oh
17:00:10 <pordan30> GGuest91353: like this? <http://hpaste.org/77505>
17:00:20 <Cale> Oh, right, there actually is a TypeSynonymInstances extension
17:00:36 <shachaf> What if you LiberalTypeSynonyms?
17:00:38 <OceanSpray> pordan30, not quite
17:00:56 <OceanSpray> gonna try these extensions
17:01:10 <rwbarton> pretty sure your original example never worked (and never will work!)
17:01:35 <nand`> shachaf: no, they still need to be fully applied
17:01:37 <nand`> higher order, but not first class
17:01:40 <pordan30> OceanSpray: why not? i don't follow.
17:01:51 <OceanSpray> yeah no, still doesn't work
17:01:59 <rwbarton> however "type Baz = Foo"; "instance C Baz where ..." works with TypeSynonymInstances
17:02:01 <OceanSpray> rwbarton, you talking to me?
17:02:02 <rwbarton> yes
17:02:07 <nand`> OceanSpray: you'd need a newtype
17:02:16 <OceanSpray> are you referring to a previous conversation?
17:02:30 <rwbarton> referring to "type Bar a = Foo a a; instance C Bar where ..."
17:02:38 <OceanSpray> oh that
17:02:47 <OceanSpray> maybe I remembered wrong
17:02:54 <OceanSpray> even so, I'd like to be able to do it, somehow
17:03:00 <rwbarton> it doesn't really make sense
17:03:02 <nand`> it's not possible currently
17:03:07 <typoclass> OceanSpray: if you hpaste code, people in here will be happy to throw that into ghc 7.4 to verify this change from 7.4 to your 7.6. if you want.
17:03:12 <OceanSpray> it's making me have to repeat a lot of code
17:03:35 <OceanSpray> well, disregard the claim that it worked in 7.4
17:03:42 <OceanSpray> I retract it
17:03:57 <acowley> type synonyms are really very limited
17:04:03 <typoclass> OceanSpray: no backsies! :-D
17:04:41 <nand`> mistakes are the foundation of learning
17:04:55 <OceanSpray> I'm going to craft a simplified example to hpaste and show you guys what I mean
17:05:01 <OceanSpray> hold
17:08:05 <pordan30> i'm kind of confused. this compiles fine for me, and seems to meet your description: <http://hpaste.org/77506>
17:09:28 <acowley> pordan30: I think the aim was to not fully apply the type synonym
17:09:45 <crdueck> ls
17:09:51 <acowley> pordan30: Think of a type class for types of kind * -> *, such as Functor
17:10:10 <acowley> crdueck: ., .., haskell.txt
17:10:27 <pordan30> acowley: ah, i see
17:12:28 <pordan30> when using transformer stacks, is it considered good style to terminate the stack using a transformer in order to run with identity, io, etc., or to terminate the stack using an ordinary monad?
17:13:31 <geekosaur> most of the time we do the latter; note that in modern mtl the "base" monads are themselves transformers on Identity
17:13:59 <acowley> why not leave it unterminated?
17:14:03 <acowley> seems more flexible
17:14:08 <geekosaur> if you're terminating the stack in IO, a transformer over IO is the only way to do it
17:16:26 <pordan30> geekosaur, acowley: thanks. so the former option is the most flexible, and necessary in some cases.
17:17:02 <geekosaur> right, and you're not losing anythhing over terminaing in an "ordinary" monads because they too are transformers
17:17:40 <pordan30> i didn't realize they were defined that way in the mtl library, so that makes sense
17:19:29 <geekosaur> mtl1 has them as independent monads, mtl2 is transformers over Identity
17:33:13 <startling> I want an inspectable representation of html trees that I can later render with blaze. should I use xmlhtml or something else?
17:34:39 <hpaste> “Ertugrul Söylemez” pasted “Efficient safe prime search” at http://hpaste.org/77507
17:44:31 <cornihilio> dcoutts: you there?
17:45:00 <hpaste> “Ertugrul Söylemez” annotated “Efficient safe prime search” with “Parallelized version” at http://hpaste.org/77507#a77508
17:53:50 <caseyjames> Hi anyone here experienced with installing Haskell on ios?
18:02:29 <Sonarpulse> how do you define a "special-character" function?
18:02:42 <Sonarpulse> (ie one that is infix by defult)
18:02:54 <rwbarton> what exactly are you asking
18:03:01 <rwbarton> how to write the definition?
18:03:10 <Sonarpulse> well the type signiture
18:03:16 <rwbarton> (&) :: ...
18:03:18 <Sonarpulse> I am making a type class
18:03:27 <Sonarpulse> I wanted to use (:) like cons
18:03:32 <Sonarpulse> and i got a parser error
18:03:36 <Sonarpulse> with and without parens
18:03:41 <rwbarton> (:) is a data constructor
18:03:51 <rwbarton> along with any other infix operator beginning with :
18:03:55 <rwbarton> so it can't be a type class method
18:04:15 <Sonarpulse> oh ok
18:04:52 <Sonarpulse> would you recommend i used "cons" instead (that is why Data.ByteVector does)
18:05:07 <Sonarpulse> or definite it as (:) but not in a type class
18:05:13 <typoclass> Sonarpulse: i think you're not doing yourself a favor if you try to redefine (:). but you could make up your own name, say (<:>) or (-:-) etc.
18:05:25 <Sonarpulse> ok, then I will use "cons"
18:05:47 <Sonarpulse> because as said ByteVectors provide a precidence for that
18:05:48 <rwbarton> Data.Seq uses (<|) / (|>)
18:06:08 <rwbarton> (for cons at the left / right)
18:06:38 <Sonarpulse> that looks like a a lot of special characters
18:06:54 <rwbarton> a <| b <| c <| empty
18:07:00 <Sonarpulse> and I only have cons at one end (the data structure in question involvses a link list
18:07:09 <rwbarton> can't go wrong with cons IMO
18:07:29 <Sonarpulse> <| looks cool but yet
18:07:32 <Sonarpulse> *yeah
18:07:39 <Sonarpulse> cons is staight-foward
18:11:58 <donri> @quote mappend
18:11:58 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
18:12:27 <ion> elliott++
18:13:16 <donri> edwardk: hey would it make any sense to use DefaultSignatures in Plated (others?) to default to uniplate?
18:13:57 <edwardk> donri: i debated about that. not sure why i didn't do it, but i remember having a reason =)
18:14:04 <edwardk> i just wish i could remember what it was
18:14:09 <ion> (Except that |\/|/-\|-|-|=|\||} isn’t a valid operator. |\/|/-\|-|-|=|\||>, anyone?)
18:15:00 <edwardk> ah it defaults to 'ignored'
18:15:09 <donri> edwardk: maybe because the "The former will only treat children directly in this tree as descendents, the latter will treat trees contained in the values under the tips also as descendants!"?
18:15:17 <edwardk> this was more in the spirit of the original uniplate
18:15:24 <rwbarton> @let (|\/|/-\|-|-|=|\||>) = mappend in "a" |\/|/-\|-|-|=|\||> "b"
18:15:24 <lambdabot>   Parse error: in
18:15:27 <rwbarton> > let (|\/|/-\|-|-|=|\||>) = mappend in "a" |\/|/-\|-|-|=|\||> "b"
18:15:28 <lambdabot>   "ab"
18:15:33 <edwardk> where many things in uniplate were trivial instances
18:15:53 <edwardk> i could come around
18:16:20 <donri> anyway what is the point of plated over uniplate? to not require Data?
18:17:09 <donri> "By implementing these combinators in terms of plate instead of uniplate additional type safety is gained, as the user is no longer responsible for maintaining invariants such as the number of children he received. " -- don't really know what that means :)
18:17:46 <edwardk> plated can be 3-4 times faster than uniplate
18:17:51 <donri> aha
18:18:08 <edwardk> also there are a lot of things that can't be made instances of Data
18:18:15 <edwardk> e.g. if it has a function in it
18:19:37 <donri> what about Generic tinplate, is that also slow
18:19:57 <edwardk> tinplate is much worse
18:20:21 <donri> heh ok
18:23:20 <donri> hm why does tinplate require Typable in addition to Generic?
18:24:08 <donri> wait did you think i was talking about Data tinplate
18:24:13 <donri> by Generic i meant GHC.Generics
18:25:43 <edwardk> the you need to have a way to compare the type of the target to the type of the source
18:26:08 <edwardk> ghc.generics.lens.tinplate is much slower than data.data.lens.tinplate
18:26:11 <donri> well Generic provides that i think?
18:26:41 <donri> the Datatype class
18:26:44 <edwardk> not quite. because i need the ways to find the original type even through nested terms of other types
18:27:41 <edwardk> you might be able to concoct a way to get the Datatype stuff to work
18:28:26 <edwardk> it does become ugly because you wind up with annoying extensions though, since you need to discriminate with flexible instances, etc.
18:29:11 <donri> i had to use scoped type variables and undefineds to get constructor names in web-routes...
18:38:51 <edwardk> if you can work out a version of tinplate that can get rid of the need for Typeable, I'll take the patch
18:39:27 <donri> unlikely, but roger :)
18:40:45 <OceanSpray> okay I have crafted my example
18:40:49 <OceanSpray> @hpaste
18:40:49 <lambdabot> Haskell pastebin: http://hpaste.org/
18:41:22 <hpaste> “Ertugrul Söylemez” annotated “Efficient safe prime search” with “Improved parallelized version” at http://hpaste.org/77507#a77509
18:41:43 <hpaste> OceanSpray pasted “Why can't we have nice things?” at http://hpaste.org/77510
18:42:36 <OceanSpray> try it
18:43:10 <OceanSpray> commenting out lines 11-13 and uncommenting 16-25 will cause GHC to be all in my grill
18:47:18 <rfw> hm, why isn't <*> called <$>?
18:47:32 <OceanSpray> because <*> isn't <$>
18:47:38 <rfw> i know but it seems weird
18:47:45 <rfw> <$> is just $ with a Functor
18:47:45 <OceanSpray> you'd rather they be switched?
18:47:48 <rfw> er, <*> sorry
18:47:56 <rfw> yeah because of the parallel between $ and <*>
18:48:00 <OceanSpray> :t (<*>)
18:48:02 <lambdabot> Applicative f => f (a -> b) -> f a -> f b
18:48:04 <OceanSpray> :t (<$>)
18:48:04 <rfw> it seems weird that <$> is actually fmap
18:48:05 <lambdabot> Functor f => (a -> b) -> f a -> f b
18:48:11 <OceanSpray> :t ($)
18:48:13 <lambdabot> (a -> b) -> a -> b
18:48:28 <shachaf> rfw: There are parallels between $ and both <$> and <*>
18:48:28 <OceanSpray> seems like <$> is closer to $ than <*> is
18:48:30 <shachaf> You have to pick one. :-)
18:48:35 <rfw> ah
18:48:38 <OceanSpray> one less f
18:48:49 <rfw> well it confused me for a while :P
18:49:01 <shachaf> OceanSpray: I can see the argument for calling it <$>
18:49:05 <shachaf> since it lifts both sides.
18:49:11 <OceanSpray> yeah I guess
18:49:15 <shachaf> But anyway it's pointless to argue about it since it won't change now. :-)
18:49:55 <OceanSpray> one more thing to consider, rfw
18:49:59 <typoclass> rfw: i think you're right, both name choices are plausible, if you look at how similar the types are
18:50:06 <OceanSpray> f $ x $ y
18:50:07 <OceanSpray> is not
18:50:11 <OceanSpray> f x y
18:50:34 <OceanSpray> whereas if you switch <*> and <$>, you'd write f <*> x <$> y
18:50:38 <rfw> typoclass: yeah i can see why fmap is <$> now
18:51:21 <OceanSpray> but then again, $ should be infixl in the first place
18:51:50 <OceanSpray> also typoclass see my hpaste
18:51:56 <OceanSpray> it explains the problem I had from earlier
18:52:37 <typoclass> OceanSpray: hmm
18:53:41 <OceanSpray> basically, I hate having to manually deconstruct Node every single time I encounter it
18:54:02 <OceanSpray> my real "Tree" has many constructors
18:54:08 <OceanSpray> and I hate boilerplate
18:57:38 <typoclass> this might be totally the wrong idea, but could you make a helper function that would let you change line 13 to "fmap f (Tree n1 n2) = Tree (foo f n1) (foo f n2)"
18:57:54 <typoclass> "foo" would be essentially line 20, only not being named fmap
18:58:07 <OceanSpray> what would the type of foo be?
18:58:29 <typoclass> who knows :-) i haven't thought this through at all
18:59:30 <OceanSpray> HM
18:59:39 <OceanSpray> I let foo = undefined and it passed the type checker
19:00:24 <OceanSpray> foo f (Node t x) = Node (fmap f t) (f x)
19:00:26 <OceanSpray> it works
19:00:33 <OceanSpray> it's just not called fmap
19:00:44 <typoclass> yeah, that's what i meant
19:01:01 <OceanSpray> I guess it does resolve the problem
19:01:03 <typoclass> now all you need is to compile it with -Wall and copy-paste the inferred type :-)
19:01:27 <OceanSpray> foo :: Functor f => (a -> b) -> Node (f a) a -> Node (f b) b
19:02:18 <typoclass> yeah, that looks good. line 20's effective type must have been the same
19:03:28 <OceanSpray> still
19:03:45 <OceanSpray> I want ghc to let me have a functor instance there
19:03:55 <OceanSpray> I guess the need is no longer that pressing
19:04:03 <OceanSpray> but it still grinds me gears somehow
19:05:08 <typoclass> OceanSpray: so, it didn't work with the 2 extensions that people recommended a few hours ago? http://hackage.haskell.org/trac/haskell-prime/wiki/LiberalTypeSynonyms was one, i forgot the name of the other TypeSynonymSomething
19:05:19 <OceanSpray> nope
19:05:21 <OceanSpray> doesn't work
19:05:39 <shachaf> What you're trying to do doesn't make sense.
19:05:51 <shachaf> Assuming it's the same thing it was last time I looked, that is.
19:05:55 <rwbarton> does anyone use aeson-lens?
19:06:15 <edwardk> rwbarton: i've seen a couple of people asking questions about how to use it
19:06:22 <rwbarton> do you have any opinion about it?
19:06:28 <rwbarton> that's what i'm really looking for
19:06:31 <edwardk> its there, and i didn't have to write it ;)
19:06:34 <rwbarton> heh
19:06:36 <rwbarton> ok
19:06:38 <edwardk> i just submitted a patch to it the other day
19:06:39 <rwbarton> i'll try it out
19:06:51 <edwardk> to let it change the types of the targets of the lens
19:07:23 <OceanSpray> shachaf, explain "doesn't make sense"
19:07:38 <shachaf> OceanSpray: "type" defines things approximate on the level of #define
19:07:44 <shachaf> ly
19:07:53 <OceanSpray> "foo" is basically "fmap" without the constraint of having to fully apply type synonyms
19:07:56 <shachaf> It doesn't give you magic powers.
19:08:00 <OceanSpray> well
19:08:02 <OceanSpray> it should
19:08:05 <OceanSpray> I want all the magic powers
19:08:10 <rwbarton> "(a -> b) -> Node (f a) a -> Node (f b) b" is not of the form "(a -> b) -> g a -> g b"
19:08:11 <shachaf> Intance resolution still works on actual types.
19:08:26 <typoclass> shachaf: would his thing work with a newtype instead of type? (modulo some wrapping and unwrapping)
19:08:32 <shachaf> typoclass: Yes.
19:08:54 <rwbarton> would ghc be able to derive that instance, i wonder
19:08:58 <rwbarton> i guess maybe?
19:09:01 <OceanSpray> "(a -> b) -> Node (f a) a -> Node (f b) b" is of the form "(a -> b) -> g a -> g b" if "g = \t -> Node (f t) t"
19:09:11 <rwbarton> but that is not a possible thing
19:09:26 <rwbarton> this way lies madness
19:10:20 <shachaf> Type lambdas gain you a lot but also lose you a lot.
19:10:40 <rwbarton> in particular, instance selection, which is the very thing you want to gain
19:11:11 <OceanSpray> gah
19:13:40 <OceanSpray> I bet agda would let me do this
19:13:48 <Nereid> I bet you could still write a traversal for Foo though
19:13:55 <Nereid> or something
19:14:44 <rwbarton> OceanSpray: well agda doesn't have type classes (does it?)
19:15:04 <rwbarton> so no, it would not let you do this
19:15:33 <Nereid> i.e. some traverseFoo :: Applicative f => (a -> f b) -> Foo a -> f (Foo b)
19:15:41 <gertc> can i conclude that lenses replaces Control.Monad.State and Control.Monad.Reader?
19:15:48 <Nereid> and then it would be as good as having a functor instance for Foo (where fmap would be over traverseFoo)
19:15:52 <shachaf> gertc: No.
19:16:03 <Nereid> gertc: no, but they complement them.
19:16:17 <edwardk> gertc: they just make it a lot easier to use. You still probably want to import MonadState and/or MonadReader
19:16:17 <rwbarton> you can even write fmapFoo :: (a -> b) -> Foo a -> Foo b
19:16:29 <OceanSpray> Nereid, the original problem was with Traversable in the first place
19:16:30 <rwbarton> no problem so far
19:16:37 <Nereid> OceanSpray: no, don't try to make it Traversable.
19:16:40 <Nereid> but write a Traversal for it.
19:16:46 <OceanSpray> it still requires full application of type synonyms, so the same problem exists
19:16:53 <Nereid> this is different.
19:16:56 <OceanSpray> okay
19:16:57 <OceanSpray> well
19:17:01 <OceanSpray> that's what I'm doing now
19:17:03 <shachaf> People are telling you not to use type classes. :-)
19:17:06 <OceanSpray> because it seems Good Enough
19:17:07 <Nereid> ^
19:17:27 <gertc> is there a lens version of Data.Map?
19:17:36 <Nereid> gertc: yes, look at indexed lenses
19:17:39 <Nereid> or rather
19:17:42 <Nereid> there are lenses for Data.Map
19:17:45 <Nereid> (indexed)
19:18:11 <edwardk> OceanSpray: "Traversal" /= "Traversable instance"
19:18:14 <Nereid> gertc: lens doesn't have any structures in it. it just gives you another interface for working with the structures we already have.
19:18:44 <edwardk> [22:08] OceanSpray: "(a -> b) -> Node (f a) a -> Node (f b) b" is of the form "(a -> b) -> g a -> g b" if "g = \t -> Node (f t) t"   -- you can't make instances like that
19:19:03 <OceanSpray> yes, I gathered
19:19:17 <edwardk> > Map.fromList [(1,"hello")] ^.at 1
19:19:19 <lambdabot>   Not in scope: `Map.fromList'
19:19:19 <lambdabot>  Perhaps you meant one of these:
19:19:19 <lambdabot>    `M.fromLis...
19:19:21 <Nereid> but you can still write a function that would play the role of traverse if it was
19:19:23 <edwardk> > Data.Map.fromList [(1,"hello")] ^.at 1
19:19:24 <lambdabot>   Not in scope: `Data.Map.fromList'
19:19:28 <edwardk> > M.fromList [(1,"hello")] ^.at 1
19:19:30 <lambdabot>   Just "hello"
19:19:45 <edwardk> > M.fromList [(1,"hello")] % at 3 ?~ "goodbye"
19:19:46 <lambdabot>   fromList [(1,"hello"),(3,"goodbye")]
19:19:58 <gertc> ok so Data.Map is already lens compatible?
19:20:06 <edwardk> > M.fromList [(1,"hello")] % at 3 ?~ "goodbye" % traverse %~ length
19:20:08 <lambdabot>   fromList [(1,5),(3,7)]
19:20:10 <rwbarton> more like lens is already Data.Map-compatible
19:20:12 <Nereid> gertc: no, lens has support for Data.Map
19:20:30 <edwardk> lens provides lenses and traversals for working with Data.Map, Data.IntMap and Data.HashMap
19:20:30 <rwbarton> > [1] % at 0 .~ 3
19:20:32 <lambdabot>  Terminated
19:20:34 <Nereid> > M.fromList [(1,"hello")] % at 1 .~ Nothing
19:20:35 <lambdabot>   fromList []
19:20:48 <rwbarton> > [1,2] % at 1 .~ 3
19:20:49 <shachaf> Well... Data.Map *does* have a Traversable instance.
19:20:49 <edwardk> [] can't be an instance of At
19:20:50 <lambdabot>   No instance for (Control.Lens.IndexedLens.At k0 [])
19:20:50 <lambdabot>    arising from a use o...
19:20:54 <shachaf> So you could call it lens-compatible.
19:20:59 <Nereid> heh
19:21:07 <edwardk> you can't do the right thing for setting it to Nothing or Just
19:21:07 <rwbarton> > listArray (1,2) [1,2] % at 1 .~ 3
19:21:09 <lambdabot>   No instances for (GHC.Num.Num (Data.Maybe.Maybe e0),
19:21:10 <lambdabot>                    Con...
19:21:21 <edwardk> 'ix' is the lens for Array
19:21:24 <edwardk> :t element
19:21:25 <lambdabot> (Functor f, Traversable t) => Int -> (a -> f a) -> t a -> f (t a)
19:21:26 <rwbarton> > listArray (1,2) [1,2] % ix 1 .~ 3
19:21:28 <lambdabot>   Not in scope: `ix'
19:21:28 <lambdabot>  Perhaps you meant one of these:
19:21:28 <lambdabot>    `id' (imported from ...
19:21:48 <edwardk> thats in Data.Array.Lens  -- not sure if cale imported it
19:21:54 <rwbarton> i see
19:22:14 <edwardk> it was pushing obscure enough that it didn't go into the default exports
19:23:03 <edwardk> > [1,2,3] ^. element 0
19:23:04 <lambdabot>   1
19:23:33 <Nereid> is the strictness bug for element fixed?
19:23:43 <rwbarton> > [1,2,3] % element 0 .~ 4
19:23:45 <lambdabot>   [4,2,3]
19:24:07 <Nereid> [1,2,3,4] % _tail .~ [5,6]
19:24:11 <Nereid> > [1,2,3,4] % _tail .~ [5,6]
19:24:13 <lambdabot>   Not in scope: `_tail'
19:24:13 <lambdabot>  Perhaps you meant one of these:
19:24:13 <lambdabot>    `tail' (imported ...
19:24:16 <Nereid> blah
19:25:07 <gertc> https://github.com/gertcuykens/haskell-design/blob/master/Json.hs should i rewrite my insertKey and lookupKey into something lensy?
19:25:18 <donri> > []^.element 0
19:25:21 <lambdabot>   *Exception: Prelude.(!!): index too large
19:25:53 * hackagebot husk-scheme 3.6 - R5RS Scheme interpreter, compiler, and library.  http://hackage.haskell.org/package/husk-scheme-3.6 (JustinEthier)
19:25:59 <edwardk> gertc: a few observations:
19:26:00 <edwardk> data KeyValue = KeyValue !(Map.Map Key User) deriving (Typeable)   can be rewritten into a newtype without the !
19:26:24 <Nereid> why can't it just be a type synonym?
19:26:25 <edwardk> newtype KeyValue = KeyValue (Map.Map Key User) deriving Typeable
19:26:45 <Nereid> anyway, a get/put pair can be replaced with modify
19:26:46 <edwardk> next you can makeIso ''KeyValue if you want. that will make an isomorphism named 'keyValue'
19:27:37 <edwardk> insertKey k v = at k ?= v
19:27:48 <edwardk> er
19:27:56 <edwardk> insertKey k v = keyValue.at k ?= v
19:28:11 <geekosaur> sounds like we have people insisting they must have partially applied type synonyms?  you can just give up on that, that amounts to type lambdas and is not supported
19:28:31 <edwardk> lookupKey k = query (keyValue.at k)
19:28:50 <Ralith> give up on it or move to idris
19:28:51 <Ralith> ^^
19:29:35 <geekosaur> there's a discussion of it on one of the haskell lists; my vague recollection is type lambdas make things too complex for ghc's type engine to deal with
19:29:36 <edwardk> gertc: so they become a bit nicer looking if nothing else, but its not a huge difference
19:30:26 <geekosaur> it's not a matter of a minor syntax extension, it's got some major repercussions in the type system
19:31:13 <edwardk> type lambdas make type inference intractable.   if you have Monad :: (* -> *) -> Constraint    and you have (,) :: * -> * -> *    , then you can have two monads one for the left side of (,) and one for the right.
19:31:19 <edwardk> which did you mean when both are in scope?
19:32:13 <rwbarton> it is very often requested though... it takes quite a bit of thinking about it to realize that it doesn't actually get you what you want
19:32:20 <edwardk> this is the hell that is working with scala, because they put those type lambdas in to "compensate" for the fact that they don't have curried types, because it appears more powerful at first blush. now they have two problems.
19:32:44 <gertc> edwardk, thx brain is busy processing
19:34:53 <Nereid> @ask byorgey any plans to update diagram to work on 7.6?
19:34:53 <lambdabot> Consider it noted.
19:35:14 <Nereid> diagrams*
19:35:15 <Nereid> shit
19:35:15 <typoclass> ... then type regexes. then they have three problems.
19:35:17 <typoclass> :)
19:35:54 * hackagebot listlike-instances 0.2.2.1 - Extra instances of the ListLike class  http://hackage.haskell.org/package/listlike-instances-0.2.2.1 (JohnLato)
19:38:25 <rodlogic> ola! do any of you know the current status of session types in haskell? I see some papers and talks about it from around 2008, but nothing recently.
19:41:50 <Ralith> session types?
19:42:32 <rwbarton> I'm still waiting for a session-pipes library
19:42:36 <rwbarton> just for the name
19:43:33 <fruitFly_> is happstack the best web framework? can you contrast some of them?
19:43:40 <OceanSpray> best?
19:43:42 <edwardk> rodlogic: a lot of people became disillusioned with session types, mostly because the actual types are eyebleedingly terrible. what session types give you is nice. what you have to do to satisfy them is pretty awful
19:43:46 <fruitFly_> yes... BEST
19:44:03 <fruitFly_> OceanSpray: not best
19:44:08 <Nereid> I don't know if there exists a "the best"
19:44:10 <stepcut> fruitFly_: it is the best for some particular set of needs
19:44:19 <fruitFly_> can anyone just contrast some of the webframeworks
19:44:40 <rwbarton> @google comparison of haskell web frameworks
19:44:42 <lambdabot> http://stackoverflow.com/questions/5645168/comparing-haskells-snap-and-yesod-web-frameworks
19:44:42 <lambdabot> Title: Comparing Haskell's Snap and Yesod web frameworks - Stack Overflow
19:44:57 <fruitFly_> what about happstack?
19:45:09 <tgeeky> django is the best
19:45:15 <rwbarton> it is mentioned in there too, also you can use google as well
19:45:43 <stepcut> fruitFly_: happstack has the type safety of yesod, but in a more modular fashion, and with less abuse of type classes, QuasiQuatation, and Template Haskell
19:45:46 <edwardk> rodlogic: also, IIRC (and i may be wrong) one of the authors of a lot of session type lib stuff got upset and stopped working on them after a paper was rejected
19:46:03 <Nereid> stepcut: how is it abuse?
19:46:15 <edwardk> at least i remember a very ranty "how could they reject my awesome paper" post
19:47:34 <Nereid> fruitFly_: and it's not like they're all monolithic things with tightly connected pieces
19:48:08 <fruitFly_> how much longer would it take to learn haskell for deploying web applications versus node.js? And what is really sacrificed with node?
19:48:38 <edwardk> rodlogic: Alec Heller (who was doing active research in that area in that same timeframe) has grumbled to me privately about them. You might be able to get a more coherent insider view from him.
19:50:00 <stepcut> fruitFly_: node does not have any compile time was to check type safety, and requires you to think in a odd callback oriented manner
19:50:17 <simpson> More importantly, Node is JS.
19:50:22 <stepcut> fruitFly_: it can be quick to prototype, but hard to unravel as you work on bigger projects
19:50:42 <stepcut> fruitFly_: especially when you have to start changing existing code
19:50:45 <Nereid> callbacks = turning your code inside out.
19:50:46 <Nereid> :s
19:50:54 * hackagebot bytestring-show 0.3.5.4 - Efficient conversion of values into readable byte strings.  http://hackage.haskell.org/package/bytestring-show-0.3.5.4 (DanDoel)
19:51:17 <rwbarton> edwardk: "them" = session types, or ...?
19:51:20 <donri> http://elm-lang.org/learn/Escape-from-Callback-Hell.elm some thoughts on callbacks
19:51:25 <edwardk> session types
19:51:38 <fryguybob> Nereid: Diagrams head works with 7.6, gtk2hs can be built now on 7.6 with the right patche.  We are working on a new release probably in December.
19:51:47 <edwardk> sorry for the indefinite antecedent ;)
19:52:06 <fruitFly_> do you achieve happiness from haskell (outside of work)?
19:52:13 <edwardk> (and i think it was sackman who posted the rant)
19:52:43 <fruitFly_> and is the node.js learning curve much shorter than a haskell webframework?
19:53:07 <edwardk> rwbarton: if you aren't familiar with session types. they are definitely… interesting. http://hackage.haskell.org/packages/archive/sessions/2008.7.18/doc/html/Control-Concurrent-Session.html provides some nice short examples
19:53:23 <rwbarton> I am familiar with the idea
19:53:29 <rwbarton> haha nice
19:53:33 <Nereid> fryguybob: head where? what I see in [1] requires base <4.6 and so on.  [1] http://patch-tag.com/r/byorgey/diagrams-core
19:53:44 <caseyjames> What are the rules of etiquette for putting the call out for help?  I'm looking for help compiling ghc for ios, is it decent to post every few hours?
19:54:00 <fryguybob> Nereid: We are on github now:  https://github.com/diagrams
19:54:13 <Nereid> ah!
19:54:28 <Nereid> you should update the webpage with that info then.
19:54:47 <Nereid> thanks.
19:55:12 <fruitFly_> Please excuse my crisis. Do you achieve happiness from haskell outside of work? If so might you want to tell me why?
19:55:22 <edwardk> caseyjames: i'd usually suggest posting to the haskell-cafe once for that sort of thing. you might also want to look up ryan trinkle's email address. his company did the original port, and he might be able to point you to more current info. you won't find TOO much help in here for it. Cale worked for Ryan around the time that was put together
19:55:54 <edwardk> caseyjames: you can feel free to sound out like sonar every once in a while in here, but i don't think you'll get a response for your efforts to be honest
19:56:39 <typoclass> fruitFly_: "do you get happiness from haskell" -- let me say it this way, some years ago my opinion was "i've never done python, i'll program something in python", then perl, then js, etc. i don't have that opinion anymore :-) nowadays other languages just annoy me. the step backward from haskell is just too big
19:57:04 <caseyjames> thanks for the leads, I will check those out.  Is your feeling that it is a particularly iffy path to go down?  I am excited about getting into haskell and I think it will be great for what I want to achieve but I'm out of my depth
19:57:37 <typoclass> caseyjames: have you tried this mailing list? send a mail, it be worth a shot http://www.haskell.org/mailman/listinfo/iphone
19:58:17 <caseyjames> yes I subscribed to day while I was doing the google hunt, I will send something out detailing what I've tried thus far
19:58:23 <edwardk> caseyjames: also, my recollection was that the ipwn port of ghc for the iphone was for something like ghc 6.10 or so. there were issues with updating the fork to work with the mainline build process changes that went in in 6.12 so it bitrotted. i know there was some interest later in reviving it once the cross-compilation stuff went in, but i lost track of it well before that happened if it did.
19:58:25 <fruitFly_> typoclass: but how does programming in haskell make you happy?
19:58:41 <fruitFly_> not just relative to other languages
19:59:14 <edwardk> caseyjames: (thats why your best bet might be following up with ryan to figure out the current status, his info will be much more recent than mine)
19:59:38 <fryguybob> Nereid: https://github.com/diagrams/diagrams-doc/commit/c8731a6b575505f73bac679642098350450e02c4
19:59:44 <typoclass> fruitFly_: well, stuff works better :-) ghc tells me all the things that are wrong with my code. in other languages (particularly in dynamic ones) it's frustrating because you have no such help and have to run it 100 times and test all the possibilities, and then you change something and have to start over with the testing ...
20:00:04 <typoclass> fruitFly_: in short, it's gratifying if stuff works, and frustrating if stuff doesn't work
20:01:30 <edwardk> caseyjames: using ghc on ios is definitely not for the faint of heart. you'll need to be both quite good with haskell, comfortable with all the ios build issues, willing to work around the vagaries of how hard it is to set up hooks to events, be comfortable with writing a lot of objective c and c glue, and be willing and able to build whatever the current cross-compiling environment is, etc.
20:01:36 <caseyjames> edwardk: awesome.  the authority.  I check these out. I was running out of leads having search google and github everywhich way
20:01:51 <Nereid> fryguybob: I meant this page. http://projects.haskell.org/diagrams/
20:02:52 <Nereid> er, under installation.
20:03:01 <edwardk> in general, if you are new to haskell i wouldn't recommend this as a way to learn. you'll probably come away from it scarred and unhappy with the process and it won't provide a very pleasant introduction to haskell =/
20:03:22 <Nereid> which still mentions darcs.
20:03:57 <guidj0s> Well, drop IOS. :-)
20:04:08 <caseyjames> I know, though after reading days of testaments on blogs and what not trying to figure this out.  I get that this is a language you end up at even if it take a few bounces to see the beauty -- or so they say
20:04:48 <rodlogic> edwardk: thanks for the details! Session types seem like a fantastic idea and was rather surprising to no mentions of it recently specially. I was also curious to what extent the latest haskel type system improvements such Polymorphic kinds and data promotion, kind variables, etc could have made session types more palatable
20:05:23 <edwardk> rodlogic: datakinds could make the types for session types a little more safe if nothing else
20:05:44 <edwardk> i don't see polykinds having a huge impact
20:06:40 <bfig> do you find yourself using more and more of haskell's more powerful type facilities? or do you try to keep it the lowest key possible?
20:07:14 <rodlogic> edwardk: and no libs on hackage that I could take a peak?
20:07:34 <bfig> (lowest key ~ least complicated possible)
20:08:01 <edwardk> rodlogic: for session types? or such with data kinds? there is plenty of session kind code. just nobody updating it to data kinds yet
20:08:40 <fryguybob> Nereid: The commit I linked to include that fix, we just haven't pushed those updates to the site.
20:08:40 <edwardk> rodlogic: i'd expect a greater uptick in feature use when we finally get a platform with datakinds officially supported in it. that'll probably be in Q2 2013
20:09:29 <jimch> I am a bit confused when to use Int, when Integer and when Num. can someone give me a quick guideline?
20:09:55 <Nereid> jimch: Int is the machine's native integer type. Integer can store arbitrary size integers.
20:10:08 <Nereid> Num is a different kind of thing (it's a typeclass)
20:10:54 <jimch> which one do people usually default to when doing integer math, Int or Integer?
20:11:12 <edwardk> Num is a constraint that can be satisfied by lots of numeric types. Int and Integer are both instances of Num, but so is Double, a bunch of stuff for polynomials, crazy types, etc.
20:11:20 <rodlogic> edwardk: sessions v2008.7.18 (Matthew Sackman) upload date: Fri Jul 18 14:20:12 UTC 2008, simples-sessions v0.1.1 (Jesse Tov) date : Wed Apr 29 10:45:25 UTC 2009, full-sessions Keigo IMAI date: Mon Jan 23 04:52:57 UTC 2012.
20:11:41 <rodlogic> edwardk: any other one that would be important to know?
20:11:51 <edwardk> Int is for 32 or 64 bit integers (depending on the platform) and is suitable for most uses. Integer is unbounded. you can have arbitrarily large integers.
20:12:49 <edwardk> Int comes out of things like 'length'. Integer is used as a temporary way to represent 'Integral' types when translating between Word8, Word16, Int32, etc with fromIntegral, and when you absolutely need arbitrarily large numbers.
20:13:17 <ion> I use Integer as my default integral type unless there’s a specific reason to use something else.
20:13:24 <edwardk> Integer is picked up 'defaulting' in ghci. so if you type 1 + 2. it'll add two Integers.
20:17:20 <rodlogic> edwardk: thanks a million for the insights.
20:17:49 <edwardk> rodlogic: i can't think of another off hand. heller might have something unpublished.
20:18:49 <edwardk> http://hcoop.net/~alec/
20:22:30 <hpaste> gertc pasted “ makeLensesWith: A single-constructor single-argument data type is required” at http://hpaste.org/77511
20:22:41 <fruitFly> I have an idea for a web service and don't quite have the knowledge right now to deploy it. How should one go about soliciting the talent and capital of others to build it while maintain a stake in the idea?
20:22:58 <fruitFly> maintaining*
20:23:12 <edwardk> gertc: strange
20:23:35 <edwardk> gertc: if you use newtype KeyValue = KeyValue { getKeyValue : Map.Map Key User }
20:23:37 <edwardk> what happens?
20:23:44 <edwardk> er :: Map.Map Key User
20:24:08 <gertc> sec
20:24:20 <fruitFly> I have an idea for a web service and don't quite have the knowledge right now to deploy it. How should one go about soliciting the talent and capital of others to build it while maintaining a stake in the idea?
20:24:31 <ion> fruitfly: A job offer on Craigslist.
20:25:22 <ivanm> ion: I realise CL is mainly a North American institution, but I had the impression that such offers were not often taken seriously :/
20:25:29 <fruitFly> can a contract really defend me from someone who wants to create it as their own ion:
20:25:30 <fruitFly> ?
20:25:46 <ivanm> fruitFly: we're not lawyers, but isn't that what NDA's are for?
20:26:27 <gertc> edwardk, makeLensesWith: A single-constructor single-argument data type is required
20:26:32 <gertc> same
20:26:59 <edwardk> fruitFly: the short answer is, you probably don't. no offense, but ideas are cheap. implementations are hard. if you have an idea without the resources to complete it, odds are 1000 other people have the same idea and also lack the resources to complete it.
20:27:04 <fruitFly> I'm sure it's possible. But I have very little capital. Is there something like a kick starter? Does anyone here interested in economics want me to bounce an idea off them?
20:28:16 <fruitFly> edwardk: probably don't what? have a unique/good idea?
20:28:36 <edwardk> fruitFly: this comes up all the time in places like the game industry. everyone i know of in the game industry gets tons of unsolicited emails from people talking about the awesome game they want to make. the secret is that all those people in the game industry have tons of awesome games they want to make too, and they've gone a lot farther towards putting themselves in the position to be able to make one of them.
20:29:18 <edwardk> fruitFly: i meant that "you probably don't" successfully solicit talent and capital while maintaining a stake in the idea, successfully.
20:29:44 <edwardk> fruitFly: a bit of startup advice. there is one question you should be able to successfully answer for your startup before you try to start it up.
20:29:44 <fruitFly> edwardk: aaaaaaah... that's what I suspected.
20:31:08 <fruitFly> edwardk: which is?
20:31:10 <edwardk> fruitFly: that is "Why me?" What is it that you bring to the equation that no other competitor does? What keeps you from taking your idea to market and having a competitor with 100x the resources available to it spend 10x as much as you did to steal away your customer base 6 months after you proved it was viable. why won't zynga or the equivalent for your ecological niche run you out of business once its proven viable?
20:31:47 <ivanm> @pl \ (a, b) -> (a, f a b)
20:31:47 <lambdabot> uncurry (liftM2 (.) (,) f)
20:31:49 <edwardk> and if nobody like that exists, in a world this large with this many niche players? why not? what is so toxic about the space you want to play in that nobody else is willing or able to touch it
20:32:10 <ivanm> @hoogle (a -> b -> c) -> (a,b) -> (a, c)
20:32:11 <lambdabot> Data.Array.IArray accum :: (IArray a e, Ix i) => (e -> e' -> e) -> a i e -> [(i, e')] -> a i e
20:32:11 <lambdabot> Data.Array.IArray accumArray :: (IArray a e, Ix i) => (e -> e' -> e) -> e -> (i, i) -> [(i, e')] -> a i e
20:32:40 <ivanm> @type \ f -> fst &&& f
20:32:42 <edwardk> fruitFly: i'm a serial entrepreneur. i've done this quite a few times, and i've had to abandon many of my own projects because i couldn't successfully answer that question.
20:32:42 <lambdabot> ((c, b) -> c') -> (c, b) -> (c, c')
20:32:50 <ivanm> success!
20:33:36 <ivanm> edwardk: Google isn't the usual suspect in someone taking your idea and running with it any more?
20:33:41 <edwardk> ivanm: you can also use 'extend'
20:33:48 <ivanm> @hoogle extend
20:33:49 <lambdabot> System.Posix.Terminal ExtendedFunctions :: TerminalMode
20:33:49 <lambdabot> Text.Regex.Posix.Wrap compExtended :: CompOption
20:33:49 <lambdabot> Text.Regex.Posix.String compExtended :: CompOption
20:33:55 <edwardk> Control.Comonad.extend
20:34:04 <edwardk> @hackage comonad
20:34:04 <lambdabot> http://hackage.haskell.org/package/comonad
20:34:08 <ivanm> yeah, not bringing in another library just for one simple function :)
20:34:17 <edwardk> just figured i'd mention it ;)
20:34:24 <ivanm> heh
20:34:42 <ivanm> edwardk: so, how long until we start talking about edwardkskell? :p
20:34:56 <edwardk> fruitFly: anyways, thats all a bit off topic. feel free to /msg me if you want to chatter about it further
20:35:29 <edwardk> edwardkaleskell
20:35:34 <fruitFly> edwardk: First and foremost I've thought my idea is unique.. pertains to providing infrastructure for consolidating and comparing a certain domain of content. I've thought that the implementation would have to be good as it hits market so as to build up a large enough user base to reach the tipping point where competitors with more resources would essentially be too late to the party
20:35:36 <edwardk> it still has traces of cale in it =)
20:36:08 <ivanm> oh, so you're still having the slight nod to Cale in there?
20:36:12 <ivanm> heh
20:36:36 <edwardk> its very hard to hit critical mass starting from zero money with hired developer resources
20:37:32 <edwardk> you can do better if you have a proven track record and know VCs, etc. but that doesn't sound like its the case
20:38:24 <ivanm> I admittedly have no experience in the area apart from reading people's blogs when they sound interesting, but my understanding is that you do need to bring something more to the party than "I have a great idea"
20:39:52 <edwardk> oh, whoa. i went to go find an old post by paul steed on this very topic, and just found out he passed away in august. =(
20:40:04 <c_wraith> the Id guy?
20:40:25 <fruitFly> ivanm: I agree, and that's why I've thought that I would have to start developing it myself. I'm ignorant and think haskell might work well, but I have to eat and am unsure if learning this all myself is the best usage of my time
20:40:28 <edwardk> the same
20:40:34 <c_wraith> I had no clue
20:41:29 <rwbarton> is it supposed to be possible that an attoparsec parser can fail but when I change an occurrence of takeWhile to takeWhile1 it now succeeds?
20:42:04 <gertc> what ever your great idea is, if it involves making mony forget about it, ask einstein :)
20:42:17 <c_wraith> rwbarton: that doesn't sound possible, offhand..  unless backtracking is involved
20:42:33 <rwbarton> I was under the impression that attoparsec always backtracked (re try: "This combinator is provided for compatibility with Parsec. Attoparsec parsers always backtrack on failure.")
20:43:05 <ivanm> rwbarton: my guess is that it doesn't actually do anything with takeWhile and moves onto the next parser, which sounds strange :s
20:43:08 <gertc> steve jobs just got lucky but the key part was he did not care
20:43:18 <rwbarton> wonder if i can cut down this example
20:43:46 <ivanm> gertc: I don't recall Einstein ever really trying to make money with the equivalent of a start-up...
20:45:31 <shachaf> I bet rwbarton would hate this # thing.
20:45:39 <gertc> true but the question is why not share the idea hope it will safe man kind :)
20:47:44 <edwardk> shachaf: =P
20:47:47 <gertc> einstein could share all of his ideas without fear, nobody would understand it anyway :)
20:48:16 <Ralith> oh!
20:48:22 <Ralith> that reminds me of what I wanted to nag edwardk about.
20:48:29 <edwardk> uhoh
20:48:34 <Nereid> :P
20:48:49 <Ralith> edwardk: when are you going to write your own version of pipes!
20:48:59 <edwardk> @hackage machines
20:48:59 <lambdabot> http://hackage.haskell.org/package/machines
20:49:00 <edwardk> done
20:49:19 <edwardk> eventually i'll even document it
20:49:23 <Ralith> oh gosh
20:49:42 <hpaste> rwbarton pasted “takeWhile/takeWhile1” at http://hpaste.org/77513
20:50:02 <rwbarton> shachaf: what # thing
20:50:04 <ivanm> edwardk: I'm not quite sure if there's meant to be a hidden sentence in the list of module names there...
20:50:11 <ivanm> "is mealy moore plan process source tee type unread wye"
20:50:15 <ivanm> it's _almost_ readable >_>
20:50:17 <Ralith> edwardk: do you know of any users of it that could be perused for example code?
20:50:20 <edwardk> ivanm: hahahaha
20:50:51 <edwardk> Ralith: Apocalisp has a scala port of it that he worked out with dolio.
20:50:53 <Ralith> and does it actually subsume pipes/conduits/etc?
20:50:59 <rwbarton> so anyone have any ideas about this takeWhile/takeWhile1 oddity?
20:51:21 <edwardk> https://github.com/runarorama/scala-machines/blob/master/src/main/scala/com/clarifi/machines/Example.scala shows a word count/line count example with the scala port
20:51:30 <edwardk> Ralith: not completely. its different
20:51:51 <ivanm> Ralith: surely the first bit is redundant in both these cases, right?
20:52:13 <edwardk> you build machines from 'plans'. a plan is a lot like the monad in pipes, the compiled machine is a lot like the pipec category, except you can make machines that take multiple inputs e.g. a Tee or Wye.
20:52:14 <ivanm> sorry, rwbarton, not Ralith
20:52:39 <shachaf> rwbarton: (NewtypeConstructor .) eta-expands, so lens is now full of newtypeConstructor# :: (a -> b) -> a -> NewtypeConstrucotr b; newtypeConstructor# = unsafeCoerce
20:52:49 <edwardk> then you can cap off the inputs by binding them to sources, which are either monadic, or which have been fed a given set of inputs, leaving zero or more inputs to drive, and feeding it to one.
20:52:50 <ivanm> rwbarton: I know the problem (I think)
20:52:53 <shachaf> And also uses of them everywhere. It makes everything so ugly.
20:53:06 <rwbarton> ivanm: what do you mean redundant
20:53:11 <ivanm> rwbarton: if it's takeWhile, the first one succeeds and has k = ""
20:53:17 <rwbarton> it doesn't match the particular input i am testing on
20:53:21 <edwardk> shachaf: benchmark the heck out of it. convince me its not worth doing
20:53:26 <rwbarton> ivanm, okay
20:53:28 <ivanm> rwbarton: yeah, I was just thinking that it shouldn't matter
20:53:33 <ivanm> but for takeWhile it _does_ succeed
20:53:48 <ivanm> then it fails for the `string ":"' bit
20:53:50 <Ralith> edwardk: well, better question then: is there any task for which conduits/pipes are appropriate that machines is not?
20:53:58 <rwbarton> then shouldn't it backtrack? that's what I don't get
20:53:58 <ivanm> that doesn't have any backtracking
20:54:11 <rwbarton> hm
20:54:17 <ivanm> rwbarton: it backtracks if you have ` pa <|> pb ' and pa fails
20:54:23 <ivanm> then it undoes what part of pa succeeded
20:54:25 <edwardk> Ralith: currently the common http pipe/conduit usecase is better served by them. they also do better resource tracking
20:54:34 <Ralith> currently?
20:54:46 <ivanm> rwbarton: if you have the bracketed case first, then you can use takeWhile for the non-bracketed case
20:54:50 <gertc> edwardk, any more sugestions about the A single-constructor single-argument data type is required?
20:54:54 <shachaf> edwardk: I think looking further into the RULES approach is worth it.
20:55:05 <rwbarton> I see, but pa >> pb can never backtrack into pa when pb fails
20:55:07 <edwardk> gertc: sorry. been flooded. it looks like a bug on my part
20:55:11 <ivanm> rwbarton: this is similar to how polyparse works, so I have a lot of experience :)
20:55:16 <ivanm> rwbarton: right
20:55:20 <edwardk> i'll put an issue in on lens and see what went wrong
20:55:21 <rwbarton> as it happens I want takeWhile1 anyways
20:55:26 <edwardk> do you have the link handy still?
20:55:40 <dolio> edwardk: The hours of tedious work, rewrite rules, etc. came before the benchmarks?
20:55:48 <rwbarton> but good to know it works this way, i will have to think whether that affects any of my other parsers
20:55:49 <edwardk> dolio: of course
20:55:52 <gertc> edwardk: like in haskell bug or bug in my source code?
20:56:02 <edwardk> gertc: i think its my bug honestly
20:56:16 <edwardk> dolio: it wasn't _that_ much work
20:56:25 <ivanm> edwardk: if nothing else, that machine library has restored faith that you really are edwardk, what with all the documentation you've been doing in other libraries recently :p
20:56:36 <edwardk> ivanm: =)
20:56:56 <edwardk> hey every function in machines at least has _some_ haddocks ;)
20:57:02 <edwardk> they just aren't very useful
20:58:01 <edwardk> shachaf: i'd be okay with reverting to the RULES approach, but if it also meant writing a 'dumb' constructor for every actual constructor, its net about the same cost
20:58:39 <shachaf> edwardk: Yes. But if nothing else you get to use infix operators instead of prefix names. :-)
20:58:51 <shachaf> Also, the RULES presumably get exported, unlike .Unsafe.
20:59:04 <rwbarton> shachaf: meh. i'm the one who wants to coerce between different strictnesses of data declarations :)
20:59:06 <shachaf> (Well, that only matters if (#) is exported.)
20:59:25 <shachaf> rwbarton: Good point!
21:00:10 <gertc> edwardk, same error when trying data KeyValue = KeyValue !(Map.Map Key User) deriving Typeable
21:00:55 * hackagebot hosc 0.12 - Haskell Open Sound Control  http://hackage.haskell.org/package/hosc-0.12 (RohanDrape)
21:04:29 <edwardk> gertc: makeIso is probably broken.
21:05:32 <gertc> its jsut genertaes code right?
21:05:39 <edwardk> gertc: try keyValue :: Simple Iso (Map Key User) KeyValue; keyValue = iso KeyValue getKeyValue -- using the newtype so you have getKeyValue
21:06:13 <shachaf> I'm annoyed that ((map.map).map) compiles to better Core than (map.(map.map))
21:06:14 <edwardk> and you may have to use "from keyValue.at k"  instead of 'keyValue.at k" in my examples
21:06:46 <edwardk> shachaf: especially with (.) infixr
21:06:53 <ivanm> @type (map.map).map
21:06:55 <lambdabot> (a -> b) -> [[[a]]] -> [[[b]]]
21:07:01 <shachaf> edwardk: Right.
21:07:29 <Jafet> :t zipWith (zipWith zip)
21:07:31 <lambdabot> [[[a]]] -> [[[b]]] -> [[[(a, b)]]]
21:08:55 <teh_qfrer> How does the grammar disambiguate between map . map and if map.map where the first map refrers to a module, just capitalization/
21:09:08 <ivanm> teh_qfrer: yes
21:09:08 <shachaf> teh_qfrer: Yep.
21:09:18 <shachaf> > [False..True] -- for example, this fails
21:09:20 <lambdabot>   A section must be enclosed in parentheses thus: (False.. True)Not in scope:...
21:09:35 <shachaf> > [False .. True]
21:09:36 <lambdabot>   [False,True]
21:09:51 <teh_qfrer> Ah yes, well, things like that are bound to happen I guess.
21:10:30 <shachaf> edwardk: If we use the "dumb constructor" approach, files will be convertible from one method to the other just by adding/removing {-# LANGUAGE MagicHash #-}!
21:10:44 <shachaf> teh_qfrer: Everybody wants .
21:10:46 <edwardk> shachaf: hahaha
21:11:05 <teh_qfrer> shachaf, what?
21:11:15 <shachaf> teh_qfrer: "." is a very popular character.
21:11:23 <teh_qfrer> Oh, in that way.
21:11:42 <shachaf> Similar to Larry Wall's law of programming language design, "everybody wants the colon"
21:11:51 <teh_qfrer> I guess 10.5 can be considered ambiguous as well yes. Well, not 'ambiguous', but you get what I mean.
21:11:53 <shachaf> (Was that him?)
21:11:57 <teh_qfrer> was that he*
21:12:08 <teh_qfrer> Let us not neglect the nominative complement on this fine saturday morning
21:12:30 <shachaf> Patch rejected.
21:12:35 <shachaf> > (10.5) 3
21:12:36 <lambdabot>   10.5
21:12:37 <shachaf> > (10 . 5) 3
21:12:39 <teh_qfrer> Queen of the England would not be pleased, were HRM to find out.
21:12:40 <lambdabot>   10
21:12:51 <teh_qfrer> shachaf, yes, quite, that stuff.
21:12:52 <rwbarton> shachaf: pretty close anyways
21:13:03 <rwbarton> no one would ever notice the difference
21:13:15 <mauke> > (10. 5) 3
21:13:17 <lambdabot>   10
21:13:26 <teh_qfrer> Truth be told, I would have probably just said that you're going to have to use spaces with infix notations, but you people have not yet elected me Queen bitch of the universe, you should really get on that, there would be less meaningless wars to start with.
21:13:53 <shachaf> teh_qfrer: *fewer* meaningless wars.
21:14:06 <teh_qfrer> shachaf, oh you enjoyed that didn't you?
21:14:20 <mauke> (less meaningless) wars
21:14:24 <shachaf> Surely.
21:14:38 <shachaf> teh_qfrer: Oh, you're Lajla. Could you stop changing your nick?
21:15:18 <teh_qfrer> shachaf, depends, is there any penalty involved for not doing so/
21:15:45 --- mode: ChanServ set +o shachaf
21:15:56 --- mode: shachaf set -o shachaf
21:15:56 * hackagebot hsc3 0.12 - Haskell SuperCollider  http://hackage.haskell.org/package/hsc3-0.12 (RohanDrape)
21:16:02 <Nereid> :i
21:18:01 <teh_qfrer> teh_qfrer, well, if this is implied to be on pain of banning then
21:18:22 <shachaf> @ty \unFoo foo f g -> unFoo . f (foo . g)
21:18:25 <lambdabot> (Functor f1, Functor f) => (a -> b) -> (a1 -> b1) -> (f1 b1 -> f a) -> f1 a1 -> f b
21:18:29 <shachaf> shapr: See what you did?
21:19:31 <Nereid> @ty (.)
21:19:32 <hpaste> gertc annotated “ makeLensesWith: A single-constructor single-argument data type is required” with “ makeLensesWith: A single-constructor single-argument data type is required (annotation)” at http://hpaste.org/77511#a77514
21:19:32 <lambdabot> Functor f => (a -> b) -> f a -> f b
21:21:16 <edwardk> gertc: the query you are calling isn't the one from lens. Not my fault. ;)
21:21:53 <gertc> ok :)
21:30:56 * hackagebot hsc3-dot 0.12 - haskell supercollider graph drawing  http://hackage.haskell.org/package/hsc3-dot-0.12 (RohanDrape)
21:36:47 <gertc> sorry i cant figure it out what this should be lookupKey k = query (from keyValue . at k)
21:37:41 <Nereid> gertc: you need to use query from lens
21:37:54 <edwardk> import Control.Lens as Lens
21:37:57 <edwardk> Lens.query (...)
21:38:21 <edwardk> one of those other modules happens to export something called query
21:38:26 <edwardk> i have no idea what it is
21:38:27 <Nereid> ah yes
21:38:37 <gertc> no i need to do it manually to be ably to make sense of it :) i need what function came form where :)
21:38:52 <gertc> jsut a sec
21:39:03 <Nereid> well the qualified import for Data.Acid imports query
21:39:19 <Nereid> er unqualified
21:39:24 <gertc> ok i pick the one from lens
21:40:56 * hackagebot hsc3-lang 0.12 - Haskell SuperCollider Language  http://hackage.haskell.org/package/hsc3-lang-0.12 (RohanDrape)
21:44:23 <augur> i feel like there needs to be a generic tree editor analogy to text editors
21:45:56 * hackagebot hsc3-db 0.12 - Haskell SuperCollider Unit Generator Database  http://hackage.haskell.org/package/hsc3-db-0.12 (RohanDrape)
21:48:24 <Cale> augur: Did you figure out the mysteries of the simplicial category?
21:48:36 <augur> Cale: maybe!
21:48:45 <augur> it was just a minor question, nothing serious
21:50:56 * hackagebot hmeap 0.12 - Haskell Meapsoft Parser  http://hackage.haskell.org/package/hmeap-0.12 (RohanDrape)
21:51:32 <gertc> aaa i think i got it i need 2 queries
21:55:57 * hackagebot hsdif 0.12 - Haskell SDIF  http://hackage.haskell.org/package/hsdif-0.12 (RohanDrape)
22:01:38 <gertc> the lookupKey :: Key -> Query KeyValue (Maybe User) this query needs to be from acidstate right? the u' <- query s' (LookupKey k) needs to be from lens
22:02:31 <edwardk> query uses MonadReader, you were calling 'ask'
22:02:41 <edwardk> query plays the role of 'asks'
22:02:51 <edwardk> but takes a getter (lens)
22:03:05 <johnw> edwardk: have you written a library for doing natural transformations?
22:03:45 <covi> What is a Haskell "binding"?
22:04:01 <johnw> covi: what is the context?
22:04:05 <edwardk> johnw: type Nat f g = forall x. f x -> g x
22:04:08 <edwardk> johnw: done
22:04:24 <edwardk> i have natural transformations in lots of libraries
22:04:48 <johnw> i mean transformation of functors
22:05:03 <hpaste> johnw pasted “Transforms.hs” at http://hpaste.org/77515
22:05:57 * hackagebot html-minimalist 0.12 - Minimalist haskell html library  http://hackage.haskell.org/package/html-minimalist-0.12 (RohanDrape)
22:05:59 * hackagebot hcg-minus 0.12 - haskell cg (minus)  http://hackage.haskell.org/package/hcg-minus-0.12 (RohanDrape)
22:06:29 <Cale> johnw: That doesn't correspond to the usual definition of a natural transformation...
22:06:42 <johnw> perhaps the sort I read skewed me
22:06:45 <johnw> s/sort/source
22:07:08 <johnw> it said that a morphism between functors is a natural transformation
22:07:12 <Cale> That says that f has an assignment *for every functor g*, and every arrow f a -> f b, some arrow g a -> g b
22:07:41 <Cale> yes, that's true, but "morphism between functors" doesn't tell you anything about the definition of a natural transformation
22:07:51 <johnw> ok
22:07:58 <johnw> i'll go back to the texts
22:08:02 <Cale> It tells you the context in which natural transformations live
22:08:21 <Cale> If C and D are categories, and F,G: C -> D are functors
22:09:01 <Cale> You can think of a functor F: C -> D as being a sort of "picture" of the category C sitting inside D, though perhaps squashed a bit
22:09:15 <Cale> right?
22:09:26 <johnw> doesn't |F(D)| == |C|?
22:09:32 <Cale> all the commutative triangles in C will be sent to commutative triangles in D
22:09:49 <Cale> but some objects in C might get sent to the same object in D
22:09:58 <johnw> ah, surjective, right?
22:10:02 <Cale> and some different arrows in C to the same arrow in D
22:10:09 <Cale> It needn't be surjective or injective
22:10:21 <johnw> doesn't squashed imply surjective?
22:10:25 <Cale> no
22:10:44 <Cale> surjective would mean that every object in D was the image of some object of C
22:11:00 <Cale> (and perhaps the same for arrows)
22:11:00 <gertc> victory! i had 3 query's lol forgot to remove one :)
22:11:09 <johnw> i don't see how what you just said is different
22:11:27 <Cale> By "squashed" I mean "not injective"
22:11:31 <johnw> (C(a),D(a)) and (C(b),D(a)), isn't that a surjective mapping?
22:11:44 <Cale> ?
22:11:48 <Cale> I can't tell
22:11:56 <johnw> where two objects in C map to the same object in D
22:12:11 <Cale> Let's look at some examples of functions then, and forget about categories for a moment
22:12:16 <johnw> like this picture: http://en.wikipedia.org/wiki/Surjective
22:12:18 <rwbarton> that is "not injective"
22:12:22 <rwbarton> a pretty useless notion
22:12:57 <johnw> oh, i didn't pay enough attention to the caption
22:13:09 <johnw> "every point in the codomain is the value of f(x) for at least one point x in the domain"
22:13:13 <johnw> and that isn't what you're saying
22:13:17 <Cale> johnw: The thing which makes the function in that diagram surjective is that for each element y of Y, there is some element x of X (and possibly more than one) which gets sent to y by the function
22:13:30 <johnw> ok
22:13:36 <rwbarton> anyways nothing about either surjectivity or injectivity was relevant to what Cale was saying
22:13:37 <johnw> so, "not injective"
22:13:48 <Cale> yeah, this is a total side-track
22:13:56 <johnw> sorry, just clarifying terminology
22:14:03 <rwbarton> "perhaps squashed" -> "perhaps not injective" -> nothing
22:14:06 <johnw> (this side-track was actually very useful for me)
22:14:47 <Cale> Yeah, I'm just trying to get a picture into your head -- the "perhaps squashed" thing isn't formally important.
22:15:17 <Cale> Okay, so we have our two pictures of C sitting inside D and we want to say what we mean by a mapping from one to the other.
22:17:02 <Cale> Well, for each object X in C, we'll want some way to send its image under F, that is, FX, to its image under G, which is GX
22:17:29 <Cale> So a natural transformation eta consists of, for each object X in C, an arrow eta_X: FX -> GX in D
22:18:10 <Cale> and if this translation didn't correspond in any way to the arrows of C, that would be pretty useless
22:18:34 <johnw> so C(a -> b) becomes D(Fa -> Fb)?
22:18:38 <Cale> So for each arrow f: X -> Y in C, we want something to hold between our images in D
22:18:56 <Cale> actually, let me call that a: X -> Y
22:19:01 <Cale> I don't want two f's
22:19:12 <Cale> So we have Fa: FX -> FY
22:19:19 <Cale> and Ga: GX -> GY
22:19:31 <Cale> and then we also have the maps eta_X: FX -> GX
22:19:38 <Cale> and eta_Y: FY -> GY
22:19:54 <Cale> and those fit together to form a square in D
22:20:13 <Cale> and we want that square to commute
22:20:17 <johnw> I'm reading an article with a picture of that square right now
22:20:28 <manju> I get this error with the latest HP
22:20:30 <manju> test.exe: MathFFTBase.hsc:471:37-55: Non-exhaustive patterns in lambda
22:20:49 <manju> This is the relevant code
22:20:51 <manju> adjust f i = uncurry (++) . second (\(x:xs) -> f x : xs) . splitAt i
22:21:02 <manju> The second lambda is a map right ?
22:21:13 <manju> Rather the lambda
22:21:13 <Nereid> manju: what does it do to [] ?
22:21:19 <manju> It doesn't
22:21:28 <Nereid> splitAt can easily return an empty list
22:21:30 <Cale> johnw: You can sort of think of the equality between the two paths around that square as in some way saying that the square is nicely "filled in" by a two dimensional sheet which lets us deform one pair of arrows nicely into the other.
22:21:36 <manju> Nereid,
22:21:41 <Nereid> well, pairs with empty lists
22:21:51 <Nereid> manju,
22:21:58 <Nisstyre-laptop> Okay, so does anyone know of a good math library on Hackage that will do Fractional sqrts?
22:22:03 <johnw> Cale: by composition
22:22:15 <Nereid> > splitAt 3 []
22:22:16 <lambdabot>   ([],[])
22:22:24 <Cale> johnw: Well, that's just the geometric intuition.
22:22:25 <Nereid> > splitAt 3 [a,b,c]
22:22:26 <lambdabot>   ([a,b,c],[])
22:22:29 <otters> @pl \x -> Yard x [] []
22:22:30 <manju> Nereid, yeah.
22:22:30 <lambdabot> flip (flip Yard []) []
22:22:35 <Cale> But formally, it's just an equation between these two compositions
22:22:47 <johnw> Cale: should we move to ##categorytheory?
22:22:49 <Nereid> manju: so I would never expect your code to work
22:22:58 <Cale> If you'd like
22:23:08 <manju> Nereid, yeah that is not my code, it is in the FFT library
22:23:17 <Nereid> ok, file a bug report then
22:23:17 <rwbarton> well it would work provided the list is long enough
22:23:22 <manju> Nereid, So can I do this then ?
22:23:22 <Nereid> although
22:23:30 <Nereid> manju: why are you trying to adjust something past the end of the list?
22:23:58 <manju> Nereid, I am not, I am just trying to compile a single program.
22:23:59 <Nereid> (don't file a bug report)
22:24:03 <manju> simple*
22:24:04 <Nereid> ok, and what's your program?
22:24:06 <neutrino_> hello
22:24:44 <neutrino_> i have translated this python program to haskell, but the haskell one is 50% larger. it's a command line interface for a module.
22:24:45 <Nereid> if there's any bug in the FFT library, it's that adjust could give you a more helpful error message.
22:24:58 <neutrino_> this was unexpected as the haskell code is much more dense.
22:25:05 <manju> http://hpaste.org/77518
22:25:11 <Nereid> neutrino_: of course haskell code would be no smaller if you translate it line for line.
22:25:21 <neutrino_> no i just translated the logic
22:25:22 <Nereid> oh, I thought you meant lots of lines.
22:25:28 <Nereid> fwiw you don't need :+ 0 at all
22:25:31 <neutrino_> yes, i meant lots of lines.
22:25:37 <Nereid> er
22:25:39 <Nereid> oops manju
22:25:50 <hpaste> jbracker pasted “Type level polymorphism on value level” at http://hpaste.org/77519
22:26:13 <Nereid> neutrino_: sorry I thought manju's paste was yours. :s
22:26:33 <jbracker> i am trying to capture type level polymorphism on value level to descript polymorphics functions with a GADT
22:26:38 <jbracker> but I am stuck
22:26:50 <jbracker> any ideas or suggestions?
22:27:17 <Nereid> neutrino_: so why are you trying to do a 2D FFT on some 1D data?
22:27:24 <Nereid> er sorry, that is supposed to be directed to manju
22:27:33 <Nereid> so confused.
22:27:36 <neutrino_> comedy
22:27:37 <manju> Nereid, Ah...well
22:27:44 <jbracker> I also tried to give TPoly a Int parameter, but that does not keep one from constructing things that don't fit together on type an value level
22:27:50 <neutrino_> get some sleep Nereid
22:28:38 <manju> Nereid, Alright, my bad.
22:29:10 <bfig> i didn't really like manju's. azuki beans are not very tasty
22:29:19 <Nereid> bfig: wanna fight?
22:29:25 <manju> bfig, Is that a restaurant ?
22:29:41 <bfig> http://en.wikipedia.org/wiki/Manj%C5%AB
22:29:42 <Nereid> no, it's a spurious apostrophe
22:29:54 <bfig> it's a 4:30 am spurious apostrophe
22:29:56 <Nereid> er
22:29:59 <Nereid> superfluous
22:30:03 <manju> What is happening ?
22:30:10 <Nereid> internet is happening.
22:30:20 <manju> Guys go to sleep :-)
22:30:35 <manju> Nereid, BTW is it possible to fix that function ?
22:30:40 <Nereid> manju: what function?
22:30:44 <manju> Nereid, to take [] into account
22:30:48 <manju> the adjust function
22:30:56 <Nereid> yes but it's not a bug.
22:31:07 <manju> Nereid, ok
22:31:13 <Nereid> just like erroring when you write [1,2,3] !! 400 is not a bug.
22:31:19 <manju> Nereid, Understood
22:31:51 <manju> bfig, manju in this case is from Sanskrit, not japanese.
22:31:54 <bfig> also why are you manju if not for the japanese dessert? :p
22:31:56 <bfig> ahh ok :D
22:32:02 <bfig> what's manju?
22:32:20 <Nereid> but the japanese one is much tastier
22:32:27 <bfig> lord shiva?
22:32:32 <manju> bfig, In south Indian language, it is snow. In Sanskrit it is gentle.
22:32:39 <manju> bfig, Also name of Lord Shiva.
22:32:53 <bfig> "Gentle Figares"
22:33:10 <bfig> Suave Figares... that would not be a bad name at all
22:33:14 <manju> bfig, It is what I am called in this life.
22:33:23 <bfig> cool :)
22:33:45 <bfig> you must be a sweet guy
22:34:02 <bfig> :p
22:34:31 <manju> bfig, Haha...I don't know, thanks though.
22:34:45 <manju> bfig, What is Figares ?
22:34:59 <bfig> a small town from Spain
22:35:17 <bfig> one day i'm gonna buy that town and convert it into a private villa
22:35:34 <manju> A bfig wonder why it takes me to a Renewable energy company...
22:35:49 <manju> bfig, I will come visiting, to say Hi...
22:35:58 * shachaf suspects this is getting off-topic.
22:36:05 <manju> shachaf, I agree
22:36:12 <bfig> sorry, sleep deprivation acting here! gonna go to sleep. good night
22:36:24 <manju> bfig, Good night.
22:37:01 <manju> Nereid, what does dftN expect for doing 2D transform ?
22:37:11 <Nereid> manju: the first argument is a list of dimensions
22:37:22 <Nereid> so
22:37:24 <Nereid> oh
22:37:29 <Nereid> well you'd need to give it a 2D array, obviously.
22:37:31 <Nereid> indexed by pairs
22:37:38 <manju> Nereid, I don't know how to make the second argument a 2D array ?
22:37:59 <manju> let bleh = listArray (1,5) [(4:+0),(5:+0),(6:+0),(7:+0),(8:+0)]::CArray Int (Complex Double)
22:38:13 <Nereid> make an array indexed by pairs, not by Int
22:38:13 <manju> This is how I make a 1D array, how to make a 2D array ?
22:38:32 <manju> Nereid, Can you please give a small example (2,2) ?
22:38:34 <Nereid> listArray ((1,1),(5,5)) [list with 25 things]
22:38:40 <Nereid> :: CArray (Int,Int) (...)
22:38:59 <manju> Nereid, Ah...beautiful..
22:39:22 <manju> Nereid, Thank you very much :-)
22:40:32 <manju> Nereid, the first argument of dftN, will be like [0,1]
22:40:58 * hackagebot hmt 0.12 - Haskell Music Theory  http://hackage.haskell.org/package/hmt-0.12 (RohanDrape)
22:41:06 <manju> Nereid, to indicate a 2D FFT ? So 3D is like [0,1,2] ? and ND is [0..N] ?
22:41:26 <Nereid> that last one is (N+1)D, but yeah.
22:41:29 <Nereid> at least, I think so.
22:41:38 <manju> Nereid, Ok. Thank you.
22:41:45 <Nereid> (I'm making lots of guesses here. I've never used the fft package)
22:42:07 <manju> Nereid, I am learning Haskell, so anything is great.
22:42:31 <manju> Nereid, I am poking around like a blind man
22:42:38 <Nereid> and you can transform just some of the dimensions
22:42:51 <manju> Nereid, Understood.
22:42:58 <Nereid> so dftN [1] ... would transform the second dimension of a 2-or-more-dimensional array
22:45:58 * hackagebot hly 0.12 - Haskell LilyPond  http://hackage.haskell.org/package/hly-0.12 (RohanDrape)
22:49:21 <manju> Hmm...
22:49:41 <manju> You guys are awesome. Pedantic, but awesome...
22:50:30 <astropirate> manju, how dare you sir!
22:50:58 * hackagebot hts 0.12 - Haskell Music Typesetting  http://hackage.haskell.org/package/hts-0.12 (RohanDrape)
22:55:38 * tsou wonders why a "haskell music typesetting" package was named "hts"
22:55:55 <pdxleif> Maybe it's French?
22:56:03 <pdxleif> wait, nevermind
22:56:40 <tsou> pdxleif: heh, living in france, I think I got what you meant though ;)
22:56:48 <Ralith> manju: you mean "precise," of course.
23:05:56 <Sankrant> Hey, I am really liking haskell after a day of its discovery.....
23:06:12 <shachaf> Sankrant: It'll pass.
23:06:22 <johnw> but then it will come
23:06:24 <johnw> back
23:06:37 <Ralith> might take a while, though
23:06:42 <Sankrant> means what??
23:06:58 <johnw> meaning that the rock may get rocky ahead, but keep on, the joy will return
23:07:01 * Ralith took about two years from 'hey haskell is neat' to 'hey haskell is awesome'
23:07:02 <johnw> s/rock/road
23:07:05 <shachaf> johnw: Eventually it'll pass forever.
23:07:24 <shachaf> Maybe you haven't gotten there yet. You will.
23:07:33 <johnw> shachaf: Are you being facetious?
23:07:52 <Sankrant> I don't fear the Road ahead... In front of fear, there stands victory.
23:08:03 <shachaf> johnw: I can't tell. :-(
23:08:30 * johnw pats shachaf on the back
23:08:55 <johnw> even you grew on me, so I have high hopes for Haskell :)
23:09:06 <shachaf> johnw: Don't worry, I hate all languages.
23:09:22 <Sankrant> Hey, dont scare me like that, I have gone through more terrible beasts like C++
23:09:39 <shachaf> And for many things I hate Haskell the least!
23:09:52 <johnw> shachaf: well, that is high praise then
23:09:53 <Sankrant> Haskell does not even looks like a beast...
23:10:40 <Nereid> alright, diagrams is really cool so far
23:10:51 <Sankrant> Haskell is good, why do people spread negetivity around it?
23:11:06 <Nereid> now to figure out how to use a backend without defaultMain...
23:11:11 <johnw> Sankrant: the same reason some people will spread negativity about absolutely anything under the sun
23:11:21 <johnw> Nereid: diagrams?
23:11:27 <Nereid> @hackage diagrams
23:11:27 <lambdabot> http://hackage.haskell.org/package/diagrams
23:11:29 <shachaf> @hackage diagrams , presumably.
23:11:30 <lambdabot> http://hackage.haskell.org/package/diagrams , presumably.
23:11:45 <shachaf> johnw: Yes, a little bit facetious.
23:11:50 <johnw> shachaf: :)
23:12:15 <johnw> with my smiley, and your frown, we're an isomorphism for perfect equanimity
23:12:42 <shachaf> Your smiley lacks a nose.
23:13:10 <Sankrant> johnw: Hmm, Haskell actually is more readable than erlang and lisp, and slightly less readable than python
23:13:22 <johnw> well, I did wonder why it couldn't smell
23:13:45 <johnw> Sankrant: readability in any language is largely a function of familiarity
23:13:58 <johnw> I find Lisp to be the most transparent of any language on first reading
23:14:14 <Sankrant> yeah...
23:14:37 <Sankrant> But I am so liking it from the first day I met it
23:15:05 <Sankrant> thay I am going to adopt it as my primary programming language
23:18:12 <Sankrant> Haskell, now its official, I am adopting you, as my primary programming language, to make good software; but first I have to date you for some time, and learn your ways.
23:20:02 <manju> @hoogle gettimeofday
23:20:03 <lambdabot> No results found
23:20:07 <manju> @hoogle gettimeoftheday
23:20:08 <lambdabot> No results found
23:20:14 <manju> @hoogle print
23:20:15 <lambdabot> Prelude print :: Show a => a -> IO ()
23:20:15 <lambdabot> System.IO print :: Show a => a -> IO ()
23:20:15 <lambdabot> Text.Printf printf :: PrintfType r => String -> r
23:20:19 <manju> Ok.
23:20:27 <manju> @hayoo gettimeofday
23:20:28 <lambdabot> Unknown command, try @list
23:20:34 <manju> @hoogle gettimeofday
23:20:35 <lambdabot> No results found
23:20:49 <manju> @hoogle getTimeOfDay
23:20:50 <lambdabot> No results found
23:20:56 <manju> ok...
23:22:10 <pdxleif> I thought type holes were supposed to be in 7.6.  I still have to wait?
23:22:20 <shachaf> Yep.
23:22:31 <shachaf> They're already in Agda, if that helps.
23:22:44 <Nereid> aaaaaahhhhhhhhhhhhhhhhh
23:22:57 <Nereid> diagrams why are you doing this
23:24:38 <Sankrant> functional programming is not a hard nut to crack, but its nuts :)
23:26:22 <Sankrant> Hey, how are the ways in which someone could help me grasp haskell?
23:26:52 <Sankrant> There are not many teachers here in India having some haskell knowledge
23:27:02 <shachaf> By telling you to read the FAQ.
23:27:02 <Nereid> read about it
23:27:04 <shachaf> @where faq
23:27:04 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
23:27:11 <typoclass> Sankrant: hello, welcome. do you know about lyah? it is a good book available free of charge
23:27:13 <typoclass> @where lyah
23:27:14 <lambdabot> http://www.learnyouahaskell.com/
23:27:15 <Nisstyre-laptop> learnyouahaskell.com
23:27:48 <startling> Sankrant: for what it's worth, there are not many haskell teachers anywhere.
23:27:48 <Nisstyre-laptop> I also recommend reading a good intro book on Abstract Algebra eventually >.>
23:27:54 <startling> except in here, I guess.
23:27:56 <Sankrant> Is self-study sufficient?
23:28:06 <startling> Sankrant: yes
23:28:09 <Nereid> Nisstyre-laptop: I wouldn't
23:28:14 <typoclass> Sankrant: sure :-) i bet most people in here have self-studied
23:28:16 <Nereid> well, I would, but not for haskell
23:28:19 <Nisstyre-laptop> Nereid: why's that?
23:28:22 * typoclass hugs nereid
23:28:29 <Nereid> Nisstyre-laptop: what do groups have to do with functional programming?
23:28:36 <Nisstyre-laptop> Nereid: people say "oh you don't need to know any of that to know Haskell", but its total bs
23:28:36 <startling> Nisstyre-laptop: then you'll start wanting typeclasses like Group and Field.
23:29:01 <Sankrant> And suppose I need help? I am very knew to functional programming...
23:29:02 <startling> we all know where *that* leads.
23:29:14 <startling> Sankrant, that's what we're all here for. :)
23:29:19 <Nisstyre-laptop> Nereid: if you want to really understand ADTs it's quite helpful to know a bit about abstract algebra
23:29:38 <Nisstyre-laptop> at least it's helped me
23:29:48 <pdxleif> I started with lambda calculus, and went from there...
23:30:01 <typoclass> Nisstyre-laptop: do you have a link about that? a blog post or something?
23:30:10 <Nisstyre-laptop> typoclass: no I don't.
23:30:23 <Sankrant> startling, You have raised my self-confidence.. thank you
23:30:43 <pdxleif> lambda calculus intro: http://web.cecs.pdx.edu/~black/CS311/Sanderson%20Ch%201.pdf
23:30:45 <startling> Sankrant: no problem! haskell isn't hard, just weird.
23:30:46 <Nisstyre-laptop> typoclass: I'm saying in general, it helps to see the connections between things
23:31:00 <typoclass> Nisstyre-laptop: yeah sure
23:31:17 <pdxleif> What'a Field?
23:31:38 <Sankrant> startling, Not as wierd as lisp, I suppose :)
23:31:40 <Nisstyre-laptop> typoclass: because you can say "oh, it makes sense to have type arithmetic, it's an algebra"
23:31:45 <Nereid> pdxleif: something you plant things in
23:31:54 <startling> Sankrant: weirder!
23:32:08 <startling> pdxleif: "In abstract algebra, a field is a commutative ring which contains a multiplicative inverse for every nonzero element, equivalently a ring whose nonzero elements form an abelian group under multiplication"
23:32:11 <Nereid> pdxleif: more seriously, http://en.wikipedia.org/wiki/Field_%28mathematics%29
23:32:39 <pdxleif> Oh.  Like a bigger version of a yard, I guess?
23:32:44 <startling> heh
23:32:45 <Nereid> (unfortunately "field" has a different, unrelated meaning in mathematics)
23:32:46 <Sankrant> startling, To me C++ looked wierd when I had to forcefully go through it, in school
23:32:50 <Nisstyre-laptop> pdxleif: it's important to realize it doesn't just apply to numbers also
23:32:51 <pdxleif> Wait, I remember... something about rings?
23:32:52 <typoclass> Nisstyre-laptop: but i'm not sure if math is the thing that helps. at least for me, it doesn't do much. often it feels like some small insight, almost a trivial insight, hidden behind tons of jargon, which invariably is only defined in terms of other jargon
23:33:15 <Nisstyre-laptop> typoclass: that's probably because you read wikipedia articles
23:33:19 <startling> haha
23:33:25 <Nisstyre-laptop> they aren't intended to give intuition or motivation
23:33:39 <startling> he has a point, though. names for things aren't always helpful.
23:33:56 <Nisstyre-laptop> startling: they aren't in programming either
23:34:01 <startling> sometimes it's helpful to be able tor recognize them and generalize along them, but.
23:34:15 <Nisstyre-laptop> you are an expert at programming though, so you don't understand how difficult it is to learn
23:34:23 <Nisstyre-laptop> myth of the expert or w/e it's called
23:34:30 <Nisstyre-laptop> it's a known cognitive bias
23:34:40 <Ralith> startling: are you an expert at programming?
23:34:50 <startling> I don't know, Nisstyre seems to think so.
23:35:01 <Nisstyre-laptop> sure he is
23:35:02 <pdxleif> The types are a field?
23:35:09 <Nereid> pdxleif: nothing in haskell is a field
23:35:10 <Sankrant> I want to have haskell as my primary development language, How much time will it take to learn it?
23:35:22 <Nereid> except maybe Rational and friends
23:35:33 <pdxleif> You can sum and multiply types - I can't think of what id or inverse would be, though.
23:35:43 <Ralith> pdxleif: there's a paper on that
23:35:45 <Nereid> yes, types do not form a field.
23:35:59 <pdxleif> A ring, maybe?
23:36:04 <Nereid> at best you get a monoid, and even that's only up to isomorphism.
23:36:05 <Nereid> er
23:36:07 <Nereid> semiring
23:36:16 <pdxleif> ringoid?
23:36:19 <Nereid> no
23:36:29 <Nereid> what's a ringoid
23:36:36 <Nereid> is that a preadditive category?
23:36:44 <pdxleif> Well, if you can have groupoid, monoid, yadda yadda...
23:36:53 <Nereid> monoid isn't a generalized mon
23:37:05 <shachaf> monoidoid
23:37:07 <Nereid> the -oid in monoid is different from the -oid in group.
23:37:11 <Nereid> and yes, a monoidoid is a category.
23:37:14 <Nereid> :p
23:37:23 <typoclass> Nisstyre-laptop: i agree that wikipedia doesn't often feature brilliant writing. but even with mediocre writing, i have no trouble reading articles about aviation or linguistics or whatever. articles about math however are usually completely opaque
23:37:28 <Sankrant> How much time does it take to master the basics of haskell?
23:37:34 <Nereid> and since a ring is a one-object preaddive category, a ringoid must be a preaddive category.
23:37:41 <Ralith> Sankrant: try it and see.
23:37:57 <Ralith> typoclass: I've noticed that too
23:37:58 <startling> typoclass, yeah, I wonder why that is.
23:38:01 <Nisstyre-laptop> typoclass: probably because aviation and linguistics are things that most people can grasp because they already know (at least a bit) about them
23:38:02 <Nereid> Sankrant: it's hard to say what "the basics of haskell" are
23:38:18 <Ralith> typoclass: they make perfectly clear sense if I'm already very familiar with the math, though
23:38:21 <Nisstyre-laptop> although linguistics has its own ub3r abstract stuff
23:38:28 <Nisstyre-laptop> like formal grammars, and whatnot
23:38:40 <Nereid> Nisstyre-laptop: yes, people tend to be able to grasp things if they can relate them to things they already know
23:38:41 <startling> maybe people are less likely to edit math pages for style etc
23:38:51 <startling> in fear of making mistakes
23:39:00 <Nisstyre-laptop> maybe
23:39:02 <rwbarton> the math pages are very useful to their target audience
23:39:05 <pdxleif> Sankrant: Just start writing functions and lists and stuff.
23:39:13 <Nisstyre-laptop> the math pages are usually really good
23:39:17 <Sankrant> By basic, I mean, I should be able to write small, bu usefull software?
23:39:21 <Nereid> Nisstyre-laptop: the basic ones, maybe.
23:39:24 <Nisstyre-laptop> but they aren't written with pedagogy in mind
23:39:28 <Nereid> they sure aren't.
23:39:29 <typoclass> Ralith: yeah that's right. but i still think it's kind of pointless to have a description that only someone can understand who already has detailed knowledge of the description ...
23:39:43 <Ralith> typoclass: well, they can be a useful reference.
23:40:26 <Sankrant> Ok, I am reading Learn You some Haskell.... Bye for now
23:40:39 <typoclass> Sankrant: good luck ;-)
23:41:03 <Nereid> diagrams, why do you do this
23:41:07 <Nereid> why are my circles disappearing!!!
23:45:00 <papyrus> hi, i have a question . i want to write lambda expresion  (\x -> x + 1) 1   like this , (prefix form) ,  ((->) \x (x+1)) 1 , but it do not works.
23:45:27 <startling> papyrus, -> is special syntax in lambda, not an operator
23:45:32 <shachaf> papyrus: Right, \ ... -> ... is magic syntax.
23:45:38 <papyrus> not operator ?
23:45:43 <shachaf> Correct.
23:45:47 <papyrus> hmm..
23:46:00 <papyrus> thanks a lot :-)
23:47:29 <hpaste> johnw pasted “sets.hs” at http://hpaste.org/77526
23:47:41 <johnw> ^^ shachaf: you asked me to implement some set operations for a -> Bool...
23:49:19 <pdxleif> papyrus: If you could do that, seems you could make your Haskell code look like Lisp.
23:49:26 <adnauseam> f a = a == a \o/
23:49:29 <Nereid> johnw: yep
23:49:37 <shachaf> johnw: Now write toList! :-)
23:49:41 <Nereid> haha
23:49:42 <johnw> shachaf: on it
23:49:59 <Nisstyre-laptop> if you could use type operators in prefix form you could do that
23:50:02 <Nisstyre-laptop> I think...
23:50:12 <Nereid> johnw: or, as an easier exercuse,
23:50:15 <Nereid> write null
23:50:16 <Nereid> exercise*
23:50:42 <Nereid> hmm
23:50:54 <johnw> toList means mapping over everything and submitting it to the test
23:51:03 <johnw> well, all "a"
23:51:17 <papyrus> pdxlefi : yes. i am thinking of that. :-)
23:51:22 <johnw> [ x | x <- [0..], set x ]
23:51:27 <Nisstyre-laptop> interesting that Racket lets you do "-> foo bar" for contracts/type signatures
23:51:45 <Nereid> oh huh.
23:51:49 <shachaf> [0..]?
23:52:20 <shachaf> I mean, sure, (filter set universe) will give you toList. But where do you get universe?
23:52:46 <johnw> is there some way, or is this a koan?
23:52:58 <Nereid> johnw: there isn't, unless you have an enumeration of a
23:53:12 <Nereid> so, you can write toList :: Enumerable a => Set a -> [a]
23:53:21 <Nereid> class Enumerable a where enumeration :: [a]
23:53:41 <johnw> but that's not really a true Set anymore
23:53:46 <Nereid> sure it is
23:53:51 <Nereid> it's just that you can't write toList for *any* set
23:53:53 <johnw> all sets are enumerable?
23:54:02 <johnw> i guess that's the essence of the axiom of extension
23:54:04 <Nereid> only sets whose member type is enumerable
23:54:18 <Nereid> (I should be careful with "only")
23:54:34 <johnw> empty = const False
23:54:34 <Nereid> (well, ok, it is "only" in this case.)
23:54:40 <Nereid> yes
23:54:40 <johnw> null = ...?
23:54:50 <Nereid> yes, that's hard too.
23:55:00 <johnw> s == const False.  next!
23:55:08 <shachaf> null set = not (any set enumeration)
23:55:26 <Nereid> well, not null on the right
23:55:42 <Nereid> except for infinite types it'll never terminate on the empty set
23:55:42 <Nereid> :v
23:55:58 <shachaf> Nereid: ?
23:56:08 <johnw> so, in Haskell it would be right to say null = undefined?
23:56:14 <Nereid> shachaf: how do you test if a set is empty without checking all possible members?
23:56:27 <shachaf> Nereid: You don't. That's why I used enumeration.
23:56:27 <Nereid> johnw: you can do better than undefined for some sets
23:56:32 <Nereid> shachaf: yes
23:56:32 <shachaf> Oh, now I see what you mean.
23:56:42 <Nereid> shachaf: now null (const False :: Set Int)
23:56:49 <shachaf> I thought you meant "infinite type" as in "the sort of thing GHC won't type-check"
23:56:55 <shachaf> a = [a] and all that
23:56:59 <Nereid> no, I ilterally mean an infinite type.
23:57:09 <shachaf> That's not what infinite type means. :-(
23:57:15 <Nereid> it's what it should mean!
23:57:16 <shachaf> It's a finite type with an infinite number of inhabitants.
23:57:31 <Nereid> what's infinite about a = [a]?
23:57:59 <Nereid> it's easy to write a type X which is isomorphic to [X]
23:58:14 <shachaf> Isomorphic, sure. But equal is tricker, in haskell. :-)
23:58:18 <Nereid> equal sucks
23:58:20 <startling> Nereid, [[[[[[[[[[[[[[[[[[[[[[[[[[[[[...
23:58:29 <shachaf> Well, I'm talking about equirecursive types here, man!
23:58:51 <johnw> equirecursive?
23:59:06 <shachaf> http://en.wikipedia.org/wiki/Recursive_data_type#Equirecursive_types
23:59:21 <johnw> #haskell is sometimes like reading Tolstoy; I used to have to lookup a word on almost every page
23:59:51 <shachaf> And at the end you've learned nothing useful?
23:59:58 <startling> johnw: k -> [(k, v)] -> Maybe v?
