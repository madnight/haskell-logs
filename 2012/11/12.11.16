00:00:37 <luite> how paste-unfriendly is -ddump-splices nowadays? recent ghc generates pasteable names, right?
00:01:06 <shachaf> I thought it generated fully-qualified names.
00:04:03 <hpaste> neutrino pasted “ap does not work - missing instance of Monad?” at http://hpaste.org/77806
00:04:24 * hackagebot shakespeare-js 1.0.2 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.2 (MichaelSnoyman)
00:04:26 * hackagebot shakespeare-js 1.1.0 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.1.0 (MichaelSnoyman)
00:04:28 * hackagebot yesod 1.1.4 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.1.4 (MichaelSnoyman)
00:04:30 * hackagebot yesod-auth 1.1.1.6 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.1.1.6 (MichaelSnoyman)
00:04:32 * hackagebot yesod-core 1.1.5 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.1.5 (MichaelSnoyman)
00:04:36 <neutrino_> hey guys, why does the pointfree version of this code break?
00:04:49 <neutrino_> do i need to add some instances so that i can use ap?
00:05:24 <luite> the monomorphism restriction
00:05:53 <neutrino_> why does this happen?
00:06:55 <luite> neutrino_: the pointsfree one is not a simple pattern binding, if the monomorphism restriction is enabled, the compiler will try to infer a monomorphic type for it
00:07:17 <neutrino_> how can i "fix" it?
00:07:19 <luite> f x = ... -- can be polymorpic, f = \x ->   -- monomorphic
00:07:27 <shachaf> @where dmr
00:07:27 <lambdabot> http://www.haskell.org/haskellwiki/Monomorphism_restriction
00:07:56 <neutrino_> ok so f x = ... can accept different types whereas f = \x -> .. can't?
00:07:57 <luite> neutrino_: you can give it a polymorphic type signature, or you disable the restriction with a LANGUAGE pragma
00:09:34 * hackagebot yesod-default 1.1.2 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.1.2 (MichaelSnoyman)
00:09:36 * hackagebot yesod-form 1.2.0 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.2.0 (MichaelSnoyman)
00:09:38 * hackagebot yesod-json 1.1.2 - Generate content for Yesod using the aeson package.  http://hackage.haskell.org/package/yesod-json-1.1.2 (MichaelSnoyman)
00:10:48 <neutrino_> luite: ?
00:10:49 <neutrino_> :)
00:11:29 <luite> neutrino_: if you just :t the non-pointsfree one and use that as a type sig for the pointsfree thing, then it should be ok
00:12:37 <neutrino_> yeah i did, but if i do that it gives me the same error
00:12:53 <neutrino_> if i do [a] -> [a] i get something else, let me paste it
00:13:21 <neutrino_> actually no
00:13:24 <luite> oh maybe is was wrong then :)
00:13:25 <neutrino_> because that would probably be wrong
00:13:31 <luite> i
00:14:07 <neutrino_> the pointful version works with [String] -> [String], the pointfree doesn't
00:15:53 <luite> neutrino_: import Control.Monad.Instances
00:16:12 <neutrino_> hmm
00:16:28 <luite> although it looks like it's deprecated now, what's the correct location to get the (->) r monad?
00:16:55 <luite> Control.Monad maybe?
00:16:55 <johnw> shachaf: I'm using agda-mode now to give me a better input method for type ⊥ and ∪ :)
00:17:00 <johnw> s/type/tying
00:17:56 <Sonderblade> anyone know of a sql parser in haskell? maybe with parsec?
00:18:05 <neutrino_> importing Control.Monad.Instances worked, but as you say it's deprecated?
00:18:30 <luite> Sonderblade: there is one in hssqlppp
00:18:54 <shachaf> Just use the ⊥ key.
00:19:04 <johnw> i have no such key
00:19:15 <shachaf> Ctrl-Shift-U 2 2 A 5 <space>
00:19:25 <johnw> \bot is easier now :)
00:19:57 <luite> neutrino_: does importing Control.Monad do the trick?
00:20:08 <neutrino_> it's Compose \bot here
00:20:13 <neutrino_> luite: nope
00:20:25 <neutrino_> luite: also, any idea how to import just the instance from C.M.I ?
00:20:39 <neutrino_> it's against my religion to do unqualified imports
00:20:58 <johnw> but if you import your religion, you'll have to qualify your beliefs
00:21:33 <neutrino_> i don't import it, it's in Prelude
00:21:38 <johnw> :)
00:24:36 <luite> neutrino_: you can import Control.Monad.Instances ()
00:25:00 <neutrino_> right, my issue is that it doesn't mention what i actually need to be imported
00:25:07 <neutrino_> i guess it's time to add a comment *sigh*
00:25:09 <luite> you always get instances
00:25:19 <po> hi
00:25:48 <neutrino_> luite: right, the idea is to document *why* that import line is there. never mind though, i can just comment.
00:25:56 <luite> neutrino_: ah the instance was moved into Prelude (actually GHC.Base)
00:25:57 <neutrino_> luite: btw, where did you see that C.M.I is deprecated?
00:26:07 <luite> so for newer GHC you can remove the import
00:26:22 <luite> newer ghc is probably 7.6
00:26:33 <luite> neutrino_: haddock
00:27:01 <neutrino_> i don't see it, where is it?
00:27:13 <luite> neutrino_: if you import () from a module, that implies that you only get instances. it defines 5 or so, so if you insist you can document which ones you acutally use
00:28:04 <luite> neutrino_: http://hackage.haskell.org/packages/archive/base/4.6.0.0/doc/html/Control-Monad-Instances.html
00:28:40 <neutrino_> oh i see it now
00:28:41 <neutrino_> yeah
00:28:46 <neutrino_> i was looking at the wrong version
00:29:27 <neutrino_> so the instance I am using is Monad ((->) r) i guess?
00:30:20 <luite> neutrino_: yes
00:30:55 <neutrino_> thanks luite
00:31:01 <neutrino_> that's great help
00:31:25 <luite> next time i will actually read the error message before i try to help ;)
00:32:31 <neutrino_> and the paste title
00:32:36 <neutrino_> and the question in irc
00:32:39 <neutrino_> ;)
00:34:05 <xkb> hmm anybody else having troubles using heroku-0.1 from hackage?
00:35:25 <luite> neutrino_: yeah, you do get missing instance errors though from the monomorphism restriction because type vars are ambiguous
00:35:38 <luite> but in this case it actually just was a missing instance :)
00:36:04 <neutrino_> oh do you?
00:36:09 <neutrino_> but wait
00:36:17 <luite> yeah try f = mappend or something
00:36:17 <neutrino_> then it mentions the "ambiguous type var" thing, right?
00:36:21 <luite> yes
00:36:32 <neutrino_> right, it didn't in this case, which is why i didn't know what to do
00:36:55 <neutrino_> "ambiguous type var" is afaik easily fixable with type annotations
00:37:16 <luite> right
00:37:29 <neutrino_> are there situations when it doesn't work?
00:38:28 <luite> uh you can always fix it that way, sometimes you might need ScopedTypeVariables
00:38:44 <neutrino_> hmm interesting, when do you need that?
00:39:57 <luite> if you have an outer type sig with a type variable, say 'a', and somewhere a local binding that has a type sig, and you want to use the same 'a' in there
00:40:20 <neutrino_> interesting, i didn't know you can (or needed to) do that
00:40:29 <neutrino_> what's an easy example where this is useful?
00:41:08 <luite> you need to 'forall a.' in this case
00:41:19 <luite> to make it a scoped variable
00:41:28 <neutrino_> i've never used forall
00:41:34 <neutrino_> maybe i'll learn about it some day ;)
00:42:36 <shachaf> If my TH code is slow, is there a way to get GHC to compile it instead of running it with the bytecode interpreter?
00:42:54 <johnw> what, you're using TH???
00:44:02 <luite> neutrino_: say you have f :: (Enum a, Bounded a, Show a) => a -> String   f x = show x ++ " is an element of " ++ show [minBound..maxBound]
00:44:23 <luite> then the list is ambiguous, and you might want to fix the type of its elements to be a
00:44:25 * hackagebot yesod-fay 0.1.0.2 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.0.2 (MichaelSnoyman)
00:44:52 <SaaMmY-laptop1> hi all good morning: is possible to convert haskell in some other language ?
00:45:18 <neutrino_> luite: go on
00:45:28 <luite> neutrino_: with ScopedTypeVariables you can use forall a. (Enum a, ....) => a -> String    f x = show ... ++ show [(minBound::a)..maxBound]
00:45:41 <neutrino_> SaaMmY-laptop1: you've asked the same question yesterday.
00:45:47 <SaaMmY-laptop1> nope
00:45:50 <SaaMmY-laptop1> I did not
00:45:51 <neutrino_> and you've been given several extensive answers.
00:45:57 <luite> to fix the type, a is a scoped variable, so the a in the minBound type sig refers to the same a as the one for the whole function
00:45:59 <shachaf> johnw: It's not my code.
00:46:44 <SaaMmY-laptop> I am sure it was not me neutrino_
00:47:21 <simpson> SaaMmY-laptop: Well, what are you building?
00:47:22 <luite> neutrino_: (there's another way to fix it here, for example by using (tail $ x:[minBound..maxBound]), since x :: a, the whole list must be :: [a]
00:47:29 <luite> neutrino_: but that's quite ugly :)
00:47:46 <neutrino_> yeah
00:47:58 <SaaMmY-laptop> maybe now I wish to read the history chat to have my informations
00:48:45 <neutrino_> SaaMmY-laptop: you're right, it might've been someone else
00:49:20 <simpson> SaaMmY-laptop: So, which languages are you targeting?
00:49:39 <neutrino_> SaaMmY-laptop: http://tunes.org/~nef/logs/haskell/12.11.14 at time 8:55
00:49:40 <SaaMmY-laptop> hmmm embarassing ... it's about linux terminal code
00:49:49 <SaaMmY-laptop> thank you
00:49:52 <neutrino_> yw
00:50:11 <neutrino_> also, just before you asked, hackagebot sayd: * hackagebot yesod-fay 0.1.0.2 - Utilities for using the Fay Haskell-to-JS compiler with Yesod.  http://hackage.haskell.org/package/yesod-fay-0.1.0.2 (MichaelSnoyman)
00:50:16 <neutrino_> *said
00:50:52 <luite> that's not quite the whole haskell though
00:51:08 <neutrino_> yeah
00:54:21 <pdxleif> ghcjs, c, llvm, ...?
00:58:05 <liamb> Hi guys, I just installed haskell-platform (64bit) on OSX and when I run "ghc-pkg check" I get a huge list of packages that ghc claims are broken. Is this normal?
00:58:27 <arbn> liamb: No.
00:59:00 <arbn> liamb: Did you install the command-line tools for XCode first?
00:59:19 <luite> liamb: you probably have an old package db lingering around, try to remove ~/.ghc
00:59:32 <liamb> yes I have all the Xcode tools I think this may be because in a previous install I tried to add yesod which messed things about
00:59:57 <luite> yeah best to install yesod with cabal-dev
01:00:13 <arbn> liamb: Oooh. Yeah. Yesod is a mess of dependencies that often don't match the platform.
01:00:54 <liamb> Thanks lute after removing the old package db I now just have three warnings
01:01:09 <liamb> 0 broken packages
01:04:38 <afgho> is there a faster way of getting a specific permutation without computing from the ground up like replicateM 4 [0..4] !! 20 but faster
01:05:47 <Cale> afgho: you're essentially computing a base 5 expansion of 20 there
01:06:06 <bartavelle> is the tls client auth code experimental ?
01:06:09 <Cale> afgho: So yes: use division instead :)
01:07:07 <luite> those are not permutations though :)
01:07:08 <Cale> Also, those aren't (just) permutations -- the permutations of [0..4] are the ones which have the same entries as [0..4] but in a different order.
01:08:18 <afgho> yeah sorry just begining
01:08:26 <Cale> > map (`mod` 5) . takeWhile (/= 0) . iterate (`div` 5) $ 20
01:08:29 <lambdabot>   [0,4]
01:08:45 <Cale> > map (`mod` 5) . take 4 . iterate (`div` 5) $ 20
01:08:47 <lambdabot>   [0,4,0,0]
01:08:51 <Cale> > reverse . map (`mod` 5) . take 4 . iterate (`div` 5) $ 20
01:08:54 <lambdabot>   [0,0,4,0]
01:09:03 <Cale> > replicateM 4 [0..4] !! 20
01:09:05 <lambdabot>   [0,0,4,0]
01:10:02 <afgho> nice :)
01:10:27 <Cale> > reverse . map (`mod` 5) . take 4 . iterate (`div` 5) $ 386
01:10:29 <lambdabot>   [3,0,2,1]
01:10:31 <afgho> there is so many ways to do things, it get confusing :P
01:10:33 <Cale> > replicateM 4 [0..4] !! 386
01:10:36 <lambdabot>   [3,0,2,1]
01:10:50 <Cale> Well, in general, there are infinitely many ways to do anything
01:11:14 <hkBst> do I understand correctly from RWH that type systems that reject more are stronger and thus for example calculus of constructions has a weaker type system than simply-typed lambda calculus?
01:11:17 <luite> afgho: hehe if it was actually permutations it would be a bit more difficult :)
01:11:58 <Cale> hkBst: Maybe in some technical sense.
01:12:22 <Cale> hkBst: (Well, in exactly that technical sense you described)
01:12:31 <ion> > (reverse . unfoldr (\n -> swap (n `quotRem` 5) <$ guard (n /= 0))) 386
01:12:33 <lambdabot>   [3,0,2,1]
01:13:44 <ion> > showIntAtBase 5 digitToInt 386 ""
01:13:46 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
01:13:46 <lambdabot>              with actual type ...
01:13:50 <ion> err
01:13:58 <ion> > showIntAtBase 5 intToDigit 386 ""
01:13:59 <lambdabot>   "3021"
01:14:23 <ion> For some reason, intToDigit 16 crashes.
01:14:26 <hkBst> Cale: it is confusing though, because I think Haskell would reject more untypable expressions and yet also be able to type more expressions at the same time than C, Perl. Making it both weaker and something else which is often called stronger informally.
01:15:22 <Cale> hkBst: It's hard to do this comparison if you're not talking about lambda calculi
01:15:22 <hkBst> oh, I got it wrong already, both stronger and something else which is also informally called stronger?
01:15:37 <ion> I wonder why not showIntAtBase :: Integral a => a -> (Int -> x) -> a -> [x] -> [x]?
01:16:05 <Cale> hkBst: Because you don't have the same set of programs then
01:16:08 <ion> showIntAtBase 5 id 386 [] == [3,0,2,1]
01:16:08 <sipa> hkBst: i think it means exactly that
01:16:11 <shachaf> ion: Probably some ShowS silliness.
01:16:37 <ion> shachaf: That’s the [x] -> [x] part in the end.
01:16:45 <shachaf> ion: Right.
01:16:51 <shachaf> I mean "making everything fit into ShowS" silliness.
01:16:53 <sipa> hkBst: but stronger type systems also meam you can rely more on the type system (polymorphism, for example)
01:17:01 <Cale> hkBst: Perhaps we should say that a type system is better if it can be used to reject more bad programs and accept more good ones, but that's already quite fuzzy :)
01:18:02 <sipa> worded differently: the stronger the type system, the more the compiler knows about your program
01:18:06 <Cale> There's stronger in the sense of "is able to give types to more programs", and stronger in the opposite sense of "is able to reject more programs"
01:18:20 <neutrino_> hey Cale, is the @pl in lambdabot the same as the pointfree package?
01:18:27 <t7> whats an inductive family of data types?
01:18:29 <Cale> It depends on which ordering you choose :)
01:18:32 <hkBst> Cale: ah nicely worded
01:19:23 <Cale> neutrino_: I don't know
01:19:56 <Cale> neutrino_: What I can tell you is that lambdabot's source code contains the code for @pl
01:20:05 <Cale> (everything that @pl is doing)
01:20:15 <Cale> So it's not just calling out to that other package
01:20:25 <hkBst> Cale: but in the lambda cube is n't it contradictory. A program is either well-typed or not, so you either accept it or reject it. To reject more programs you also simultaneously have to accept fewer programs?
01:20:29 <Ghoul> Anyone know any good papers on optimisation techniques for compiling imperative languages
01:20:48 <neutrino_> Cale: i know it contains @pl thanks
01:21:04 <neutrino_> i was just wondering why some inputs make pointfree hang whereas @pl is instant
01:21:33 <Cale> neutrino_: Well, it's probably not the same then ;)
01:21:37 <neutrino_> :)
01:22:03 <neutrino_> the lambdabot package doesn't allow using lambdabot commands as command-line tools, does it?
01:22:05 <lightquake> if i have some datatype data Foo = Foo | Bar | Baz | …, how asymptotically fast is pattern-matching against the constructor in the number of constructors?
01:22:51 <shachaf> lightquake: Presumably it's constant-time-ish, since it'll just turn into an indirect jump or something.
01:23:03 <lightquake> that's what i thought
01:23:09 <shachaf> (Though there's a big constant-factor improvement if it's smaller than 3/7.)
01:23:16 <lightquake> 3/7?
01:23:52 <shachaf> 3 or 7, depending on the size of your pointers.
01:24:08 <lightquake> ah
01:25:38 <neutrino_> Cale: ^
01:26:06 <Cale> neutrino_: Not as far as I know
01:26:11 <shachaf> I know some libraries have pretty big enums like that.
01:26:12 <Cale> (I only use the online mode)
01:26:27 <Cale> There's a lambdabot commandline
01:26:31 <lightquake> hkBst: I think what Cale means (correct me if I'm wrong) is that, for example, a language without a polymorphic type system can't really express map in a decent way
01:26:32 <shachaf> This one has 560
01:26:46 <shachaf> That's a lot of constructors.
01:26:47 <lightquake> so by adding polymorphism (i.e., strengthening the type system), you now accept map
01:26:52 <lightquake> shachaf: what is it?
01:26:55 <neutrino_> Cale: oh
01:26:57 <shachaf> hdis86
01:27:01 <shachaf> (x86 opcodes)
01:27:21 <Cale> neutrino_: if you just run the lambdabot binary without any parameters, that's what you get
01:27:32 <Cale> (a sort of repl thing)
01:28:10 <neutrino_> let me try it out!
01:28:13 <lightquake> shachaf: oh, yeah
01:29:13 <merijn> Cale: Ha, just the man I need (I think?) what's the way to get lambdabot to join another channel?
01:29:26 <Cale>  @join #channel
01:30:37 <hkBst> lightquake: right, but rejecting map as ill-typed is stronger than expanding your type system to accomodate it, counterintuitively...
01:31:05 <lightquake> not really
01:31:14 <lightquake> by that logic the strongest type system is the one that accepts no programs
01:31:24 <hkBst> lightquake: yes
01:31:30 <neutrino_> Cale: that works quite well! you can do lambdabot -e "cmd" 2> /dev/null
01:31:44 <lightquake> so i don't think 'rejects more programs' is what people mean when they say strong
01:31:54 <lightquake> i think it's something along the lines of 'can express more concepts', or something
01:32:15 <hkBst> lightquake: RWH claims that this is the precise academic meaning
01:32:31 <Cale> It is *a* precise academic meaning
01:32:35 <neutrino_> Cale: i do wish there would be separate executables for the different commands though. lambdabot startup takes a second. using the pointfree binary has instant startup..
01:32:47 <Cale> But since this is essentially mathematics, we can make the words mean whatever we want them to mean
01:32:53 <merijn> Cale: I don't have enough privileges to use @join, unfortunately
01:33:01 <Cale> merijn: ah
01:33:03 <hkBst> Cale: sure, but preferably not two different things at the same time :)
01:33:11 <Cale> merijn: which channel
01:33:22 <merijn> Cale: #csa_uva
01:33:33 <Cale> lambdabot: @join #csa_uva
01:33:43 <merijn> Cale: Thanks :)
01:34:15 <Cale> I can make it permanent
01:34:34 <merijn> Cale: That'd be great :)
01:35:14 <Cale> okay, done
01:44:01 <tomeo> Seems as though ghci is caching calculations. This makes it difficult to see if my optimisations are any good. Is there any way to disable the caching?
01:45:11 <neutrino_> use a non-functional language.
01:45:47 <tomeo> neutrino_: :)
01:47:13 <Eduard_Munteanu> tomeo: use something like 'criterion' to benchmark
01:47:29 <Eduard_Munteanu> @hackage criterion
01:47:29 <lambdabot> http://hackage.haskell.org/package/criterion
01:47:30 <hkBst> tomeo: what about the optimizations that the compiler will do. IIUC ghci doesn't compile
01:48:17 <Eduard_Munteanu> And yeah, you'd better compile with GHC instead.
01:49:13 <tomeo> Eduard_Munteanu: tack
01:49:59 <tomeo> hkBst: ah. yes I should probably be running ghc instead
01:50:59 <bookerz> Anyone familiar with cmdArgs know how to use it with options that are lists?
01:51:27 <bookerz> The docs suggest it's possible, but I can't actually figure out how to assign values of length greater than 1
01:57:59 <danr> is there an equivalent for Haskell's Chan in python?
01:58:45 <quicksilver> typed channels in an untyped language? :)
01:59:05 <c_wraith> eh, just a threadsafe queue
01:59:14 <c_wraith> and if there is, it's not in the standard libraries
01:59:28 <neutrino_> i remember there being a threadsafe queue
01:59:30 <shachaf> Everything is threadsafe when you have a GIL!
01:59:46 <neutrino_> Python is not CPython.
01:59:54 <danr> there's a Queue, yes. maybe I can use it
02:00:04 <neutrino_> danr: i think that might be it.
02:00:07 <danr> thanks all
02:00:11 <neutrino_> danr: why not use something like rabbitmq?
02:01:24 <danr> neutrino_: oh, thanks for the tip
02:02:08 <akustiker> Hi there!
02:03:13 <eikke> where should I look for functions like "ntohll"?
02:03:40 <eikke> or, otherwise, can I convert Int64's to 8-byte ByteStrings using given byte order
02:04:04 <shachaf> Yes -- you know what network byte order is.
02:04:35 <eikke> sure, si I could write such function myself, but it'd be nice if there'd be some existing implementations :)
02:06:33 <shachaf> eikke: Probably Data.Binary has something.
02:07:20 <eikke> ok, thanks
02:08:28 <t7> more people should do agda screen castthings
02:10:02 <ion> t7: Any currently existing ones you recommend?
02:10:30 <t7> icfp 12 agda curious
02:12:08 <ion> Alright, seen that one already.
02:14:27 * hackagebot yackage 0.6.0.1 - Personal Hackage replacement for testing new packages.  http://hackage.haskell.org/package/yackage-0.6.0.1 (MichaelSnoyman)
02:24:40 <neutrino_> is there any way to make lambdabot -e exit without error?
02:40:44 <neutrino_> @free
02:40:44 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:21-35
02:40:57 <neutrino_> y u broken :(
02:42:37 <Ralith> it probably expects an argument
02:43:22 <neutrino_> right
02:43:24 <neutrino_> i tried this:
02:43:26 <neutrino_> @free id
02:43:28 <lambdabot> f . id = id . f
02:43:31 <neutrino_> but i'm not sure how to use it..
02:46:53 <Ralith> that doesn't look very broken to me
02:47:16 <Ralith> not knowing how to use something is different than that something being broken.
02:47:28 <neutrino_> right, i figured out the argument thing after i said it was broken
02:47:33 <FireFly> @help free
02:47:33 <lambdabot> free <ident>. Generate theorems for free
02:47:34 <neutrino_> right now i just don't know how to use the argument
02:47:50 <neutrino_> FireFly: yeah... not sure how to apply that :)
02:48:13 <int-e> @free filter
02:48:16 <lambdabot> $map f . filter (g . f) = filter g . $map f
02:48:49 <neutrino_> @free map
02:48:50 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
02:48:53 <neutrino_> hmm
02:48:57 <neutrino_> i guess it makes sense
02:49:00 <neutrino_> @ft map
02:49:01 <lambdabot> Done.
02:49:09 <neutrino_> that... does not look right though?
02:49:55 <int-e> neutrino_: why?
02:50:27 <neutrino_> because @ft seems like it should be doing the same thing as @free
02:50:44 * Ralith wonders what neutrino_ is trying to accomplish
02:52:11 <neutrino_> i'm going through lambdabot commands that are useful in an editor, and adding support to Vim
02:55:39 <hkBst> neutrino_: it generates a theorem from the type of the expression (wadler theorems for free)
02:57:10 <neutrino_> @ft a -> a
02:57:12 <lambdabot> Done.
02:57:21 <neutrino_> @ft "a -> a"
02:57:23 <lambdabot> Done.
02:57:39 <hkBst> @help ft
02:57:40 <lambdabot> ft <ident>. Generate theorems for free
02:57:44 <hkBst> @help free
02:57:45 <lambdabot> free <ident>. Generate theorems for free
02:57:48 <neutrino_> yeah.
02:57:54 <neutrino_> what does @ft do then?
02:58:00 <neutrino_> i know about @free
02:58:15 <hkBst> seems like aliases to me
02:59:02 <neutrino_> no, they are defined in different files
02:59:07 <neutrino_> one is Free.hs the other is FT.hs
02:59:12 <neutrino_> weird :)
02:59:16 <Eelis> do i understand correctly that STM can only be used with IO ?
02:59:57 <Saizan> yes, running a transaction requires side-effects
03:00:11 <Eelis> ok, thanks
03:03:27 <Eelis> seems such a shame that it needs the IO kitchen sink though. do the side effects of transactions really need to live in the same monad as the side effects for things like, well, file I/O?
03:04:12 <shachaf> Concurrency in general is in IO.
03:04:22 <shachaf> (forkIO-style concurrency, I mean.)
03:04:23 <flux> hmm.. so how would it work, doing transactions inside a pure function? or doing transactions in multiple threads in a pure function so that the side effects never can be seen outside the function?
03:04:53 <flux> how could multiple threads work inside a pure function anyway..
03:06:07 <Eelis> no, but you could have multiple threads running pure functions :)
03:06:39 <shachaf> Concurrency means non-determinism.
03:06:46 <shachaf> (Well, OK, not strictly.)
03:06:55 <flux> so how would it be pure to do transaction inside a pure function?
03:07:01 <companion_cube> not in some cases, you can have deterministic concurrency
03:07:06 <shachaf> companion_cube: Right.
03:07:15 <shachaf> But not the sort of thing STM does, for the most part.
03:07:16 <companion_cube> (like data flow methods, I think)
03:07:19 <companion_cube> sure
03:08:21 <SaaMmY-laptop> hi all can I see some haskell webpage sample?
03:09:33 <Jafet> data IO = FileIO | TimeIO | STMIO | StateIO | ConcIO | UnsafeIO | EIEIO
03:10:49 <Jafet> saammy: http://haskell.org
03:11:58 <SaaMmY-laptop> I mean a haskell language webpage made
03:12:35 <bind> you mean a website constructed/generated by haskell code?
03:12:41 <SaaMmY-laptop> right
03:12:45 <SaaMmY-laptop> I am italian
03:12:46 <SaaMmY-laptop> XD
03:13:04 <bind> http://www.haskellers.com/
03:13:17 <lantti> www.yesodweb.com
03:13:17 <bind> source http://github.com/snoyberg/haskellers
03:13:18 <SaaMmY-laptop> thanks
03:13:21 <shachaf> Websites are boring.
03:13:56 <bind> boring?
03:14:00 <alpounet> http://www.happstack.com/ too
03:14:08 <alpounet> yu can also generate static sites with hakyll
03:14:10 <bind> and dont forget snap :-)
03:14:24 <lantti> Agreed, but that is the main use for computers from my point of view :)
03:14:47 <bind> websites indeed got boring once the blink and marquee tags got deprecated...
03:15:25 <SaaMmY-laptop> shit lol italy has very few haskellers
03:15:36 <bind> you will never know
03:15:49 <Eduard_Munteanu> There are a few in here.
03:16:15 <bind> there are probably more than you think ... and surely not all of them hang out on haskellers
03:16:34 <SaaMmY-laptop> ah ok
03:17:34 <bind> @free bind
03:17:35 <lambdabot> Extra stuff at end of line in retrieved type "    Not in scope: `bind'\n    Perhaps you meant one of these:\n      `find' (imported from Data.List),\n\n"
03:18:13 <bind> @free find
03:18:14 <lambdabot> $map_Maybe f . find (g . f) = find g . $map f
03:18:56 <bind> @help
03:18:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
03:19:03 <bind> @list
03:19:05 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:19:13 <bind> @lol
03:19:13 <lambdabot> Maybe you meant: do let pl url yow
03:19:28 <bind> @yow
03:19:29 <lambdabot> Couldn't find fortune file
03:20:25 <bind> @hoogle bind
03:20:26 <lambdabot> package bind-marshal
03:20:27 <lambdabot> Graphics.Rendering.OpenGL.GL.BufferObjects bindBuffer :: BufferTarget -> StateVar (Maybe BufferObject)
03:20:28 <lambdabot> Network.Stream bindE :: Result a -> (a -> Result b) -> Result b
03:21:10 <bind> @hackage bind-marshal
03:21:11 <lambdabot> http://hackage.haskell.org/package/bind-marshal
03:21:49 <bind> @poll poll-list
03:21:49 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
03:21:57 <Marenz> it is impressive how much of a hell cabal is
03:22:02 <bind> @poll-list
03:22:03 <lambdabot> ["\"MacGood\"","ConfusedWithVixenSituation","best-programming-language","food","naming","nethack","president","remove@src","sleep"]
03:22:12 <Marenz> I am trying for 4 days now to get the dependencies for a project I want to compile
03:22:22 <Eduard_Munteanu> lambdabot also answers to private queries. ;)
03:22:40 <bind> how would I do that? :-)
03:22:50 <Eduard_Munteanu> /query lambdabot
03:23:08 <SaaMmY-laptop> is hackage something for hacking?
03:23:11 <bind> thx
03:23:16 <bind> great
03:24:06 <bind> no ... its a package repository thing ...
03:24:07 <Eduard_Munteanu> SaaMmY-laptop: I guess it stands for Haskell and package
03:24:16 <SaaMmY-laptop> ah ok
03:24:16 <SaaMmY-laptop> lol
03:24:37 <Eduard_Munteanu> Though "hacking" works too I suppose.
03:25:29 <bind> Eduard_Munteanu lambdabot is a nice feature
03:26:26 <Eduard_Munteanu> You can install her locally too, but IIRC it's not that easy to build.
03:26:37 <Eduard_Munteanu> @hackage lambdabot
03:26:37 <lambdabot> http://hackage.haskell.org/package/lambdabot
03:26:59 <fmap> it should be easy on 7.4
03:29:53 <neutrino_> it built without an issue on my 7.4.1
03:30:07 <Eduard_Munteanu> Cool.
03:32:38 <fmap> Marenz: are you going to write something like http://www.txt.io/t-2kv5h ?
03:35:16 <Marenz> fmap, I have no intention to do so. I just had to get off my frustration for a minute. You know, I started with haskell also 4 days ago. And this is basically my first impression
03:35:54 <fmap> too bad, I like rants
03:36:09 <Marenz> i don't see much of a point in it
03:36:12 <fmap> Marenz: anyway, if you have a specific problem about cabal this channel is generally helpful
03:36:36 <Marenz> fmap, I do have one, but so far, as soon as I fixed one part of the problem another pops up
03:37:07 <Marenz> and I feel like I don't want to take up tooo much time of the people who help me
03:37:52 <hpaste> neutrino pasted “haskell vim stuff - updated” at http://hpaste.org/77809
03:40:09 <mSSM> Currently installing lambdabot for my ghci: what's the easiest way to give it stuff to undo? I.e., pipe some stuff into it so I don't have to type a string?
03:40:13 <Marenz>  fmap actually, that blog post summs it up pretty well
03:40:58 <Marenz> is there any movement going on to fix the cabal mess?
03:41:15 <Philippa> mSSM: you can define GHCi commands that execute console commands - do it that way?
03:41:34 <Philippa> (then the console commands fire up a simplified IRC client, talk to your lambdabot instance...)
03:42:00 <Philippa> oh, right, lambdabot probably won't pretend to be a trivial ircd, sorry :-)
03:42:11 <mSSM> Philippa: that souds a bit over the top :)
03:42:13 <Philippa> what's the preferred means for console apps to communicate with it, anyway?
03:42:32 <Philippa> mSSM: it's more like using the OS's basic tools to do everything using the interfaces provided? :-)
03:42:52 <Philippa> (besides, running a local lambdabot server means you're not tied to calling it from one app...)
03:44:08 <sopvop> Cabal is not a mess
03:44:16 <bind> oh my oh my ... why does lambdabot depend on brainfuck??
03:44:21 <mSSM> Philippa: oh well, it fails building anyhow :D
03:44:22 <fmap> Marenz: not until everybody write a rant
03:45:34 <Marenz> fmap, this explains it pretty well: http://www.reddit.com/r/haskell/comments/12alw1/why_inbreeding_is_bad_for_your_community_cabal/c6ugn7a
03:45:39 <bind> .o(sorry for that extra question mark)
03:45:40 <neutrino_> apparently you have to write a rant first and can't start working on the fix before
03:46:12 <shachaf> @bf ++++++++++++++++++++++++++++++++++++++++++++++++++++++.
03:46:13 <lambdabot>   6
03:46:28 <Marenz> neutrino_, oh, I'd have to learn proper haskell first. And I planned to do taht by playing around with a certain project. But i can't get it to compile because I have trouble getting the dependencies with cabal.
03:46:43 <sopvop> Marenz: Was that project using yesod by chance?
03:46:58 <Marenz> it was. But my problems started way earlier
03:47:03 <Philippa> mSSM: basically, if lambdabot was a server rather than a client it'd be a perfectly sensible way to do things without attempting to forcibly integrate stuff or mess with your development environment/scope :-)
03:47:06 <Marenz> it didn't even mention yesod yet
03:47:11 <sopvop> And which version of ghc do you use?
03:47:28 <Marenz> 7.6.1
03:47:38 <sopvop> use haskell-platform ffs
03:47:42 <sopvop> doh
03:47:59 <sopvop> There is a reason why next platform will still use 7.4.2
03:48:15 <Marenz> you have to explain me why it is better to not use the native package manager
03:48:19 <neutrino_> Marenz: then play around with a different certain project? :)
03:48:39 <Marenz> neutrino_, well, my playing around has an actual goal, something I want to create
03:48:49 <bind> shachaf : thx :-)
03:48:53 <sopvop> Because haskell packages are not .so, and not .py
03:49:18 <Marenz> sopvop, a package manager is not limited to .so and .py?
03:49:32 <sopvop> forget it
03:49:41 <sopvop> and do get platform
03:49:51 * Philippa recommends platform unless you know better
03:49:52 * sopvop is a victim of inbreeding
03:49:57 * Philippa has a use case for 7.6's PolyKinds...
03:50:07 <Marenz> Couldn't all those things not be easier if the libraries that cabal installs weren't precompiled.. or rather, if one could get all the libs one wanted as src first and then only compile them once everything is installed?
03:50:18 <bind> well ... generally IMHO... for development purposes you should use sandboxing mechanisms anyway
03:50:25 <Philippa> Marenz: one can
03:50:25 <Marenz> so that no instance-specific dependencies happen?
03:50:31 <sopvop> Marenz: one can sandbox shit
03:50:47 <Marenz> sopvop, yeah, funny story, I couldn't install cabal-dev :D
03:50:54 <Marenz> you know,, a dependency problem
03:50:56 <Marenz> *cough*
03:50:57 <bind> I would find it extremely frustrating if installing dependencies for a development project would mess with my system's libraries
03:51:03 <sopvop> Yes, because it does not support 7.6.1 yet
03:51:17 <bind> thats why people use virtualenv and stuffs over at python-land
03:52:30 <bind> you could try hsenv / virthualenv too ... those didn't give me an issue up to now ... using virthualenv from debian stable and sandboxing things from then on
03:52:36 <Tinned_Tuna> bind: is there an equivalent for Haskell development?
03:52:39 <Tinned_Tuna> ahh
03:52:47 <Marenz> Philippa, how can you do that?
03:52:48 * sopvop sandboxes the manual way
03:52:51 <bind> there are others of course..
03:53:09 <Tinned_Tuna> bind: is there a 'default' or 'standard' way (like python has virtualenv) ?
03:53:25 <fmap> Tinned_Tuna: there is cabal-dev, hsenv and next cabal-install release will have sandboxing hopefully
03:53:29 <bind> well ... not yet i guess ... no blessed way?
03:54:09 <fmap> I don't think we generally agree on default one though
03:54:11 <SaaMmY-laptop> why double ++ is needed for example in [0,1,2,3,4]++[5,10..100]
03:54:13 <bind> doesn't take away the recompilation problems ... but at least you dont have that much problems with your systems "haskell" libraries
03:54:30 * sopvop has a theory what cabal mess helps at avoiding success, at small cost
03:54:47 <sopvop> :t (++)
03:54:48 <lambdabot> Monoid m => m -> m -> m
03:54:48 <mauke> SaaMmY-laptop: because [0,1,2,3,4][5,10..100] is a type error
03:54:49 <sopvop> :t (+)
03:54:50 <lambdabot> Num a => a -> a -> a
03:54:56 <sopvop> wrong ++!
03:55:00 <Philippa_> hrmm, given that we should be recommending the Platform first...
03:55:05 --- mode: ChanServ set +o Philippa_
03:55:16 <bind> isnt a list a monoid?
03:55:18 <Tinned_Tuna> :t (>>=)
03:55:20 <lambdabot> Monad m => m a -> (a -> m b) -> m b
03:55:23 --- topic: set to '["Haskell Platform 2012.4: http://bit.ly/Clv5r ","GHC 7.6.1 http://v.gd/CEBRVo ","Paste code/errors: http://hpaste.org/new/haskell ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ "]' by Philippa_
03:55:25 <Tinned_Tuna> :t return
03:55:27 <lambdabot> Monad m => a -> m a
03:55:38 <Tinned_Tuna> bind: it's also a monad?
03:55:38 --- mode: Philippa_ set -o Philippa_
03:55:40 <Tinned_Tuna> :t []
03:55:42 <lambdabot> [a]
03:55:42 <sopvop> yes it is, but the ++ is different in base.
03:56:12 <bind> in base? :-)
03:56:25 <bind> would you mind to explain?
03:56:45 <sopvop> Prelude> :t (++)
03:56:45 <sopvop> (++) :: [a] -> [a] -> [a]
03:57:11 <SaaMmY-laptop> http://learnyouahaskell.com/starting-out#an-intro-to-lists
03:57:11 <sopvop> oh, I mean "base" a package
03:57:11 <bind> i see
03:57:23 <sopvop> :t (<>)
03:57:24 <lambdabot> Monoid m => m -> m -> m
03:59:11 <bind> @hoogle monoid
03:59:12 <lambdabot> Data.Monoid module Data.Monoid
03:59:12 <lambdabot> Data.Monoid class Monoid a
03:59:12 <lambdabot> package monoid-owns
03:59:25 <Marenz> sopvop, I am installing haskell plafrom now.. but it depenc ond ghc 7.6.1
03:59:36 <bind> .oO(monoid owns eh..?)
03:59:57 <Jafet> Eh doesn't afraid of anything except monoid.
04:00:19 <shachaf> What's this monoid-owns thing?
04:00:36 <bind> dunno ..
04:00:53 <bind> some package which owns?
04:01:08 <Marenz> pretty much every haskell package owns me
04:01:24 <Eduard_Munteanu> moans
04:01:25 <bind> @hoogle stereoid
04:01:25 <lambdabot> No results found
04:01:34 <bind> .oO(bummer)
04:01:45 <Jafet> @quote stereo
04:01:46 <lambdabot> dolio says: fasta: At least the 'stereo' quote is no longer in lambdabot. That was _way_ overused.
04:01:58 <shachaf> I move to @forget
04:02:06 <Jafet> @quote metastereo
04:02:07 <lambdabot> omnId says: geez, how many metastereo quotes are going to be @remembered?  >_>
04:02:14 <shachaf> I move to @forget
04:02:21 <Eduard_Munteanu> Steroids?
04:02:23 <Jafet> @quote \@forget
04:02:23 <lambdabot> remember says: @forget @remember
04:02:43 <Eduard_Munteanu> Sounds like a perfectly legitimate categorical abstraction.
04:03:07 <bind> but ... does this solve cabal-hell?
04:03:10 <cmears> Marenz: how are you installing the platform that it depends on ghc 7.6?
04:03:11 <shachaf> I move to @forget
04:03:12 <Eduard_Munteanu> (or maybe it's steroidoid)
04:03:39 <bind> steroidoid? ... sounds funny
04:03:44 <Jafet> Up next: monoids on steroids
04:03:59 <Eduard_Munteanu> Well, we already have monoidoids.
04:04:14 <Marenz> cmears, the packages is broken... aur package
04:04:41 <bind> shachaf move to @forget? dont want to be remembered?
04:05:07 <t7> what is a monoidoid ?
04:05:16 <Eduard_Munteanu> t7: a category
04:05:30 <Eduard_Munteanu> (any category, it's just another name)
04:05:41 <t7> oh
04:05:43 <bind> .o(monoidiot?)
04:06:53 <t7> ignoring syntactical errors, a sentence is an element in the free monoid of the english language?
04:07:27 <cmears> Marenz: oh, that's a shame. Maybe getting it from http://www.haskell.org/platform/ would work better
04:08:10 <sopvop> what is aur and why should we care?
04:08:11 <bind> my mind crumbles a little ...
04:08:13 <Marenz> cmears, guess where I got the idea from that the AUR package might be fine
04:08:27 <pordan30> t7: every syntactically and semantically well-formed sentence is, yes
04:08:41 <Marenz> sopvop, aur is arch user reposittory. User made packages
04:09:15 <bind> sopvop : aur is a package repository ... containing recipes to build stuff ... also haskell libs for Arch linux
04:09:17 <Marenz> sopvop, the haskell-platform website links to such an AUR.. which is a 404 btw.. but a search for the actual haskell-platform aur package finds it.. and explains that it's broken
04:09:31 <cornihilio> does anyone have problems with their TAG file and haskell-mode? when I M-. on blah' it takes me to blah
04:09:44 <sopvop> Marenz: So, how does that mean what cabal is shit?
04:10:10 * sopvop is inbreeding full force
04:10:31 <bind> i love cabal
04:10:35 <Tinned_Tuna> Hello there, I'm using GHC 6.12.1, but people are saying that hacksoc.org/courses/fun/exercises/exercises1.hs is not working for them in GHC 7.x (Even with the various solutions filled in correctly)
04:10:36 <Marenz> sopvop, I think that 4 days to get only the dependencies installed is just not okay, even if I am a novince user.
04:10:41 <sopvop> cabal is awesome
04:10:47 <Marenz> sopvop, no mattert what I do, it doesn't work.
04:10:52 <bind> no pun intended ...
04:10:53 <Tinned_Tuna> Aparently the type of min' and max' is busted :-/
04:10:57 <pordan30> a cabal of caballing caballers cabal install cabal-install
04:11:05 <Marenz> k, nevermind
04:11:33 <sopvop> Marenz: that's why platform is recommended. If your arch is doing platform wrong, thats not cabal's problem
04:12:03 <Marenz> I actually have doubts that having platform will change anything
04:12:22 <shachaf> Tinned_Tuna: "not working"?
04:12:35 <sopvop> That's because yesod is moving way to fast, and yesod is not cabal's problem also
04:12:39 <fmap> Marenz: as far as I read mailing lists haskell packages on Arch are not intended to provide nice experience for newbies
04:12:45 <sopvop> sandbox all the things!
04:12:46 <cmears> Marenz: I've had good luck (also with other distributions) getting the GHC binaries and starting from there
04:12:52 <bind> Marenz : did you try some sandboxing like hsenv? ... you can also point it to a ghc release (tarball-thing) and have it completely independent of your system I think
04:13:01 <Marenz> cmears, it feels so tainted to not use the pkg manager :/
04:13:12 <Tinned_Tuna> shachaf: type errors, apparently. But... It Works For Me (TM)
04:13:13 * sopvop usually installs ghc, then does everything in sandboxes
04:13:24 <bind> me too
04:13:27 <shachaf> Tinned_Tuna: Oh, *type errors*. Well then.
04:13:29 <Tinned_Tuna> i.e. what has happened to the type system between GHC6 and GHC7?
04:13:29 <Marenz> sopvop, I can't even use my ghc because it is too recent ;)
04:13:44 <shachaf> Tinned_Tuna: You are providing insufficient information to help you.
04:13:53 <sopvop> Marenz: get ghc from haskell.org, install with --prefix. What's the problem?
04:13:56 <cmears> Marenz: sure, but if the distributions don't always keep up you don't have a better option (:
04:14:13 <Tinned_Tuna> tl;dr; does Num a no longer imply Eq ?
04:14:17 <bind> just download a package from the ghc site ... configure --prefix=/whatever/you/want && make install ?
04:14:25 <sopvop> Or that Arch linux of yours does not allow to have several versions installed?
04:14:27 <Tinned_Tuna> I don't have access to GHC 7.x here
04:14:33 <Marenz> cmears, that's the thing, it _does_ keep up. too much apparently ;)
04:14:35 <shachaf> Tinned_Tuna: Correct.
04:14:54 <Tinned_Tuna> shachaf: That makes no sense.
04:15:09 <shachaf> Sorry. :-(
04:15:17 <Tinned_Tuna> shachaf: I'm not blaming you! Sorry!
04:15:22 <cmears> Marenz: ha, yes (:  [can you install GHC 7.4 via arch's package manager?]
04:15:25 <Tinned_Tuna> I just think that Num => Eq
04:15:32 <shachaf> You mean Eq => Num
04:15:37 <Jafet> > (1 :: (Int -> Int)) == 1
04:15:39 <lambdabot>   *Exception: (==): No overloading for function
04:15:43 <shachaf> Anyway, some things act like numbers and can't be compared.
04:15:48 <Tinned_Tuna> shachaf: e.g.
04:15:49 <Tinned_Tuna> ?
04:15:55 <shachaf> See one line above.
04:16:07 <Marenz> cmears, I could get the package build instructions and change the version
04:16:34 <Tinned_Tuna> > 1 :: (Int -> Int)
04:16:36 <lambdabot>   *Exception: show: No overloading for function
04:16:51 <cmears> Marenz: it might be easier to get the GHC binaries directly
04:16:53 <Tinned_Tuna> shachaf: I don't follow ...
04:16:56 <fmap> > 1 2
04:16:57 <shachaf> > ((*2) + 1) 5
04:16:58 <lambdabot>   1
04:16:59 <lambdabot>   can't find file: L.hs
04:17:01 <bind> Marenz : then you would mix your system up even more ..
04:17:02 <shachaf> > ((*2) + 1) 5
04:17:04 <lambdabot>   11
04:17:10 <Jafet> Why does vector-spaces still use Eq then
04:17:19 <Jafet> How archaic
04:17:31 <Tinned_Tuna> > (((*2) + 1) 5) == 11
04:17:32 <bind> Marenz : i guess ... using another ghc for the packages in your distro could break your system's libs
04:17:33 <lambdabot>   True
04:17:49 <bind> cmears : totally agree
04:18:30 <Tinned_Tuna> > 1 2
04:18:32 <lambdabot>   1
04:21:17 <Tinned_Tuna> > (1 2) == 1
04:21:19 <lambdabot>   True
04:21:25 <pordan30> how does (1 2) evaluate to 1, and what happened to the classic "no instance for num (a -> b) arising from..." error message?
04:21:35 <Jafet> > 1 undefined
04:21:37 <lambdabot>   1
04:21:44 <hpc> pordan30: lambdabot has that instance
04:21:48 <shachaf> 1defined
04:21:51 <hpc> (it has the technology)
04:21:52 <Tinned_Tuna> I'm going for lunch
04:21:57 <Tinned_Tuna> and to have a seethe about this...
04:22:00 <pordan30> hpc: oh, interesting
04:22:16 <shachaf> pordan30: You know how GHC always says "Possible fix: add an instance declaration for ..."?
04:22:21 <shachaf> Someone did it, for once.
04:22:29 <hpc> never do it again!
04:22:38 <malorie_> if I do `let s = show' in ghci, its type is `() -> String'. is this because there are additional type defaults in ghci?
04:22:47 <hpc> yes
04:22:53 <Eduard_Munteanu> Once you go Num (a -> b), you can never go back.
04:22:56 <shachaf> Yes. ExtendedDefaultRules.
04:23:21 <malorie_> thanks
04:23:27 <pordan30> > zipWith ($) [1..] (repeat 3)
04:23:28 <lambdabot>   Could not deduce (GHC.Enum.Enum (b0 -> c))
04:23:29 <lambdabot>    arising from the ambiguity ch...
04:23:30 <hpc> does ExtendedDefaultRules even add anything beyond defaulting to ()?
04:23:32 <cmears> I'm not sure that having lambdabot so different from standard Haskell is always helpful...
04:23:47 <shachaf> cmears: It's not.
04:23:54 <hpc> but it's sometimes neat
04:23:54 <Jafet> All of this is standard haskell
04:24:00 <hpc> i miss the cale-flip
04:24:03 <hpc> :t flip
04:24:05 <lambdabot> (a -> b -> c) -> b -> a -> c
04:24:26 <ion> @type (.)
04:24:28 <lambdabot> Functor f => (a -> b) -> f a -> f b
04:24:43 <hpc> :t \f x -> fmap ($ x) f
04:24:44 <lambdabot> Functor f => f (a -> b) -> a -> f b
04:25:15 <pordan30> @help
04:25:18 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
04:25:24 <pordan30> @help src
04:25:25 <lambdabot> src <id>. Display the implementation of a standard function
04:25:39 <pordan30> @src Num (a -> b)
04:25:40 <lambdabot> Source not found. Wrong!  You cheating scum!
04:26:04 <shachaf> @ty flip flop
04:26:08 <lambdabot> Functor f => f (a -> c) -> a -> f c
04:26:33 <Eduard_Munteanu> > flip table
04:26:35 <lambdabot>   Ambiguous occurrence `flip'
04:26:36 <lambdabot>  It could refer to either `L.flip', defined at ...
04:26:42 <shachaf> Who's @letting flip all the time?
04:26:46 <shachaf> Stop it. It's ambiguous.
04:26:48 <Eduard_Munteanu> > L.flip table
04:26:49 <shachaf> @undefine
04:26:51 <lambdabot>   "(\9583\176\9633\176\65289\9583\65077 \9531\9473\9531"
04:26:54 <Eduard_Munteanu> :(
04:27:04 <Jafet> http://hpaste.org/51474
04:29:38 <t7> 彡 is an awesome codepoint
04:29:48 <bind> Jafet : this ... is ... well ... blowing lambdabot?
04:30:08 <bind> > (ツ) = id
04:30:09 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
04:30:27 <Jafet> There she blows.
04:30:57 <t7> > let (ツ) = "ffo kcuf" in (ツ)
04:30:57 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
04:31:51 <shachaf> It won't work no matter how many times you do it.
04:33:13 <Jafet> > Just let it bе
04:33:14 <lambdabot>   mueval: recoverEncode: invalid argument (invalid character)
04:39:33 <Marenz> I must say, I am a bit deterrend by all those cabal issues
04:39:43 <Marenz> and I wonder whether haskell is worth all the hassle
04:40:07 <atriq> Marenz, Cabal issues are infrequent and mostly easy to fix
04:40:50 <Marenz> so far every single thing I tried failed with some cabal dependency problem. And I was not able to get a single thing working so far.
04:41:00 <Marenz> So my experience is exactly the opposite of what you just said
04:41:10 <Marenz> and i spent >4 days on fixing one of those problems.
04:41:15 <Marenz> so much about "easy to fix"
04:41:40 <Philippa> is there a lib with a simple function to yoink a named function definition out of some Haskell source?
04:41:40 <issimus1> haskell platformwrks out of the box
04:42:19 <shachaf> If I profile code with GHC and I see a lot of work attributed to MAIN, even with -auto-all, what does that mean?
04:42:54 <Philippa> I guess I should search HackageDB, my connection's a bit wobbly to do that 'til I'm home though
04:43:52 <atriq> Marenz, what have you tried to install?
04:44:51 <sopvop> yesod on 7.6.1
04:45:02 <Marenz> no
04:45:33 <Marenz> well, not only. it was part of the deps.
04:45:43 <Marenz> but it never came ot that
04:49:03 <neutrino_> considered contacting one of the developers?
04:49:05 <Marenz> hmm I can't build haskell-platform because on ubuntu the ghc is too old
04:49:19 <ramses_> @pl \s x -> abs (s*s - x)
04:49:20 <lambdabot> (abs .) . (-) . join (*)
04:49:30 * hackagebot static-resources 0.1.5.4 - JavaScript and Css files concat for http optimization. Now with LESS suppor.  http://hackage.haskell.org/package/static-resources-0.1.5.4 (MariuszRak)
04:49:43 <atriq> Marenz, either use the Ubuntu haskell-platform package, or download GHC manually
04:54:17 <ramses_> @pl \s x -> abs (s - x)
04:54:18 <lambdabot> (abs .) . (-)
04:54:26 <hpaste> mapf pasted “Writer ” at http://hpaste.org/77812
04:54:51 <mapf> is it in base?
04:55:27 <mapf> heh, unfortunately (a, w) are swapped
04:55:27 <DMcGill> ramses_: define (.:) = (.).(.) then you can use "abs .: (-)"
04:55:50 <mapf> DMcGill: looks like tits
04:56:07 <DMcGill> well you can use fmap . fmap or fmap fmap fmap if you prefer
04:56:22 <DMcGill> or (.) (.) (.)
04:56:37 <Marenz> The ghost of haskell doesn't like newcomers
04:56:52 <osfameron> triple breasted whore of eroticon six?
04:57:37 <Eduard_Munteanu> Total Recall FTW. :P
04:57:45 <wlangstroth> Marenz: there's a ghost of haskell?
04:58:23 <Marenz> and it doesn't like me.
04:58:52 <nicoo> wlangstroth: Its phantasmal essence is so pure you cannot see it interacting with the real wolrd.
04:59:12 <wlangstroth> Marenz: I missed which version of ubuntu, or did you say?
04:59:19 <wlangstroth> nicoo: !
04:59:30 <Marenz> i didn't. And I think I gave up anyway, so don't bother
04:59:38 <wlangstroth> m'kay
05:02:55 <bartavelle> FWIW, the ghc that ships with 12.04 randomly gives "strange lambda" errors at runtime
05:02:57 <bartavelle> for me
05:10:59 <nand`school> Trying to install network-2.4.0.1 on a pathologically posnix-unfriendly operating system (Windows XP, 32 bit); it requires some sort of shell to run ./configure - what's the most pain-free method of achieving this? cygwin? MinGW+MSYS?
05:11:07 <nand`school> (The ulterior goal is to get cabal-install running)
05:11:16 <nand`school> s/posnix/posix/
05:11:56 <nand`school> Or perhaps MinGW32
05:12:24 <nand`school> oh; I can just download a binary
05:13:17 <Jafet> Haskell is Windows-unfriendly
05:13:42 <nand`school> hrm
05:14:01 <nand`school> Is there some way I can download the package library cabal-install uses manually and stick it somewhere?
05:14:04 <nand`school> 'cabal update' fails
05:15:14 <merijn> Jafet: Isn't any language other than Python and .NET stuff windows unfriendly? :p
05:15:26 <merijn> Oh, I guess maybe Java works too, but I prefer to forget Java
05:16:30 <Philonous> merijn:  C++ used to work pretty well, even without .Net
05:20:14 <dcoutts> nand`school: yes, grab the 00-index.tar.gz from the hackage website, stick it in ~/.cabal/packages/hackage.haskell.org/
05:20:31 <dcoutts> nand`school: and gunzip it (but don't untar it)
05:21:34 <nand`school> dcoutts: perfect; thanks, I suppose I download packages this way as well?
05:21:47 <nand`school> fortunately, this braindead package manager doesn't actually untar it
05:22:09 <dcoutts> nand`school: obviously it'd be better if you worked out what was going on. Doing cabal update -v3 might help.
05:22:22 <dcoutts> nand`school: you might just need to set your HTTP proxy env var for example.
05:22:51 <dcoutts> nand`school: institutions often use proxies (and I note the "school" in your username :-) )
05:23:00 <nand`school> dcoutts: simple, HTTP 407; proxy doesn't like me
05:23:27 <nand`school> firefox works fine, even out of the obx
05:23:29 <nand`school> box*
05:23:34 <nand`school> so I figure it should be doable to auto-detect it somehow
05:24:02 <dcoutts> nand`school: that probably just means you need to use the proxy.
05:24:19 <dcoutts> nand`school: ie to set the http_proxy env var, to the same as what firefox is using
05:24:45 <nand`school> dcoutts: I have no idea what firefox is using for it; but I set it to the host:port of my proxy server
05:24:56 <nand`school> and I get a 407; if I don't set it (leave it blank), I get a 403 instead
05:25:15 <bind> Jafet : just sandbox linux in windows :P
05:25:27 <dcoutts> nand`school: does it need authentication?
05:25:42 <nand`school> dcoutts: presumably, that's what HTTP 407 is
05:25:43 <bind> Jafet : VM's ftw
05:25:49 <nand`school> I didn't need to enter any password in firefox though
05:26:35 <bind> Jafet : and another advantage ... in case the distro is broken (again) ... just trash the vm and start again (from a snapshot)
05:26:52 <nand`school> why would I break my distro? :P
05:27:05 <dcoutts> nand`school: browsers can do some proxy auto config (which actually needs a full JS interpreter!!)
05:27:18 <nand`school> ugh
05:27:26 <nand`school> so can I get the authentication data from firefox somehow?
05:27:32 <nand`school> and set HTTP_PROXY to that?
05:27:48 <rwbarton> there's some gconf way to get http proxy information too, that might be what firefox is using
05:27:53 <dcoutts> nand`school: you might be able to find it in the firefix properties/settings, the network tab
05:28:08 <bind> well ... you probably won't mean to ... but ... well ... installing things in ways the os's package manager does not support ... it could go wrong
05:28:41 <nand`school> bind: that's why I install everything through my OS's package manager
05:29:39 <nand`school> hrm, I downloaded the .tar files for the missing packages and stuck them into hackage.haskell.org; I guess I have to untar those into their respective versions as well?
05:30:03 <bind> nand`school : but then you either would have to package the stuff you need yourself or just bear with the lack of recent versions/ specific packages on occasion, wouldn't you?
05:30:14 <jmcarthur> bind: of course if the distro is broken you're just using the wrong distro :P
05:30:55 <nand`school> bind: or you could use HEAD
05:30:57 <jmcarthur> bind: oh, or you did something silly like not use the package manager, yes
05:31:01 <bind> jmcarthur : yeah :-) blame the distro!
05:31:19 <jmcarthur> there are very few distros i like
05:31:28 <rwbarton> nand`school: for example listed here http://ant.apache.org/manual/proxy.html -- scroll down to the list of gconf entries. can use gconftool-2 somehow to check whether those are set on your system
05:32:09 <bind> nand`school : but ... in case you use HEAD ... just don't install it in places your system libs are ... don't you think?
05:32:37 <nand`school> bind: I don't like doing things manually
05:32:40 <nand`school> it's why I switched away from debian
05:32:59 <nand`school> manually updating, rebuilding, installing etc. a few dozen libraries regularly got boring
05:33:17 <bind> jmcarthur : well ... it depends ... things can work out too without using the systems package manager ... just dont install stuff as root in distro's default locations i guess
05:33:23 <jmcarthur> nand`school: windows sounded better?
05:33:41 <nand`school> jmcarthur: I'm not sure what you mean
05:33:59 <jmcarthur> the problems your working through right now are windows-related, right?
05:34:05 <bind> nand`school : what are you using then? lfs?
05:34:14 <rwbarton> oh wait you are on windows, ignore me!
05:34:17 <jmcarthur> and in fact, it sounds like you are tweaking and building things manually...
05:34:29 * rwbarton thinks people using windows should have to have "win" in their username
05:34:51 <nand`school> jmcarthur: yes; windows doesn't have a package manager, so I'm using that ;)
05:35:05 <jmcarthur> maybe you actually meant that you switched away from debian for linux, but don't always use linux, but i misinterpreted that to mean you switched to windows
05:35:07 <nand`windows> rwbarton: apologies
05:35:12 <rwbarton> thanks :)
05:35:14 <wlangstroth> :)
05:35:16 <nand`windows> I should have made it more clear that I'm stuck on this idiotic platform
05:35:19 <bind> ooooh ... he is on windows...
05:35:35 <rwbarton> nah it was just poor reading comprehension on my part
05:35:38 <nand`windows> jmcarthur: ah, I switched to gentoo :)
05:35:40 <mauke> ~shun~
05:35:41 <DMcGill> no ssh into your home box?
05:35:44 <jmcarthur> ah, much better
05:35:46 <nand`windows> DMcGill: ssh blocked
05:35:51 <bind> now i get it ... but then again ... using stuff still needs someone to package it for windows ... doesnt it?
05:35:56 <nand`windows> DMcGill: I don't have an sshd set up either way, my home box is behind a NAT that I have no access to
05:36:33 <jmcarthur> as one who intends to release a game someday, i'm going to eventually have to figure out how to get my code working on windows. i do not look forward to it
05:36:51 <DMcGill> hopengl works fine on windows
05:37:06 <jmcarthur> i'm sure it does. the issue is *i* don't work fine on windows
05:37:06 <nand`windows> wait a minute, does gloss even run on windows?
05:37:09 <DMcGill> and both glut and glfw-b
05:37:33 <jmcarthur> most of the libraries i use (maybe even all) surely work on windows
05:37:34 <nand`windows> jmcarthur: you can release games without caring about windows
05:37:37 <DMcGill> I think so - it uses GLUT and OpenGl, both of which work fine
05:37:43 <bind> jmcarthur ... couldn't you just stay in linux ... and share your files through samba to your windows (box/vm)
05:37:49 <jmcarthur> nand`windows: i'd rather just support every platform i reasonably can
05:37:52 <DMcGill> the only package that explicitly doesn't work in windows is 'unix'
05:38:11 <DMcGill> perhaps unsurprisingly
05:38:15 <jmcarthur> bind: at minimum i need a working build environment on the windows side
05:38:29 <nand`windows> right now I'm trying to figure out how to install gloss on windows; it's a huge pain. I installed a few libraries manually, but I figured with the huge amount of dependenceis gloss is likely to pull in that an automatic dep resolution like cabal-install provides would be useful
05:38:32 <DMcGill> but one should never import unix, rather using unix-compat intead
05:38:40 <osfameron> bah.  Raincat linux build is no longer available from http://raincat.bysusanlin.com/
05:38:45 <bind> jmcarthur : I see
05:38:48 <jmcarthur> osfameron: :(
05:38:57 <nand`windows> but cabal-install can't download packages, due to proxy failures - I downloaded them manually, but I don't know where to place them so cabal-install is happy
05:38:57 * osfameron downloads the source (which is, for some reason)
05:39:15 <jmcarthur> bind: but beyond that, i will also want to play nicely with windows conventions to avoid shocking anybody
05:39:23 <jmcarthur> so my project will also be affected, surely
05:39:32 <DMcGill> nand`windows: can't you just call "cabal install pkg-nametar.gz"
05:39:38 <nand`windows> DMcGill: perhaps I can
05:39:41 <DMcGill> you can
05:39:59 <DMcGill> although I think you'd need to do it in reverse dependency order
05:40:25 <nand`windows> DMcGill: doable
05:40:35 <bind> jmcarthur : i hope it will work out for your ... game ... it was a game right?
05:40:38 <DMcGill> try "cabal install --dry-run"
05:40:38 <jmcarthur> i think you might even be able to download all the deps in advance and then just list them all out in one line to cabal install, but i'm not sure
05:40:46 <jmcarthur> bind: yeah it's a game
05:40:48 <DMcGill> and it'll give you a list to be installed, in what order
05:40:54 <nand`windows> still much less painful than extracting, configuring and installing it manually; especially because each time I run 'runhaskell Setup.hs' it needs like 20 seconds to build Setup.hs
05:41:03 <DMcGill> --dry-run on the top level package I mean
05:41:08 <bind> jmcarthur : interesting :-)
05:41:28 <jmcarthur> bind: we have a whole channel for haskell games!  #haskell-game
05:42:04 <jmcarthur> there's been activity there almost every day, but of course it comes in spurts
05:42:57 <nand`windows> #haskell-arcade
05:44:00 <jmcarthur> nand`windows: how does that differ from #haskell-game?
05:44:14 <nand`windows> haskell-arcade is for a particular library
05:44:18 <jmcarthur> ah
05:44:20 <nand`windows> or project
05:44:25 <nand`windows> but it sounded related
05:44:36 <jmcarthur> not the yampa arcade, right?
05:44:59 <nand`windows> I've never heard of 'yampa'
05:45:00 <parcs`> > 5726048256 / 1024^2
05:45:02 <lambdabot>   5460.78515625
05:45:10 <jmcarthur> yampa is that old afrp library
05:45:56 <jmcarthur> ah i found the library you're talking about i think
05:46:05 <jmcarthur> it's edwardk's?
05:46:28 <edwardk> haskell-arcade is more like an idea than a library right now =)
05:46:46 <jmcarthur> ah
05:47:20 <jmcarthur> sounds useful though
05:47:42 <atriq> edwardk, how is your surname pronounced?
05:48:53 <atriq> I'm guessing not "Kay-Met", how I've been pronouncing it in my head
05:49:00 <edwardk> Basically what I was doing was building a 2d physics engine in a purely functional form, so I could pause it, or let AI agents run a few frames of it (think of the infinite mario a* AI), and then describing a game in a way that i could send a dsl for approximating its gameplay forward to a client over the network and serve up all of the assets for that game over the web. (both the client and server were going to embed snap)
05:49:05 <nand`windows> I pronounce it like "mett" but with a "k" before it
05:49:11 <nand`windows> like a diphtong
05:49:12 <Eduard_Munteanu> I think it's ka-met
05:49:14 <edwardk> that way you get more or less a generic game client, and the ability to experiment with game types
05:49:22 <edwardk> Eduard_Munteanu wins the prize
05:49:52 <Eduard_Munteanu> Like ka in kaboom. :)
05:50:00 <edwardk> ka-MET or ku-MET
05:50:42 <nand`windows> * Missing C library: glut32
05:50:42 <nand`windows> oh god
05:51:29 <edwardk> jmcarthur: it was mostly an excuse for me to work on physics, which caused me to write a one module lens API because i didn't like lens-family, which you may have noticed got split out into its own package and grew quite a bit.
05:51:42 <jmcarthur> heh
05:51:48 <DMcGill> nand`windows: is that on runtime or install time?
05:51:50 <edwardk> so basically the haskell-arcade gave birth to lens
05:51:54 <nand`windows> DMcGill: install time
05:52:05 <nand`windows> DMcGill: I downloaded glut-3.7.6-bin; which includes a .dll, .lib, .def, .h
05:52:10 <nand`windows> but I don't know where to put it to make cabal happy
05:52:35 <DMcGill> look at cabal's help, it has --with-extra-lib or something
05:52:41 <edwardk> and physics was gutted and the core linear algebra primitives that are written as representable functors of polymorphic lenses was split out as 'linear' at acowley's request so he could use them in his crazy robotics projects
05:52:44 <DMcGill> two different ones, one for the lib and for for the h I believe
05:52:55 <nand`windows> edwardk's set of libraries is basically recursing into dependenices
05:53:34 <edwardk> nand`windows: pretty much. i find it to be a pretty productive way for me to work. in the end i get a lot of new primitives for the next big project ;)
05:54:03 <edwardk> it also helps inform the API for those smaller projects to have a larger project that will nominally consume them ;)
05:55:14 <mauke> http://en.genzu.net/sokumen/?n=haskell
05:55:49 <nand`windows> DMcGill: --extra-lib-dirs; worked like a charm :) thanks
05:56:04 <nyc> It's not clear to me how much linear algebra can be done numerically without support for sparse matrices.
05:56:08 <DMcGill> are you using freeglut or normal glut?
05:56:20 <DMcGill> note too that hopengl is in the haskell platform by default
05:56:36 <mSSM> In the following code, on line 93, is evalStateT responsible for "applying" the state `i' to the function? I don't understand how on line 55 the state is being obtained. And also, how is that `i' a state? https://github.com/aivuk/Simple-Ising/blob/master/ising.hs
05:57:21 <nand`windows> DMcGill: I'm not using the haskell platform; actually
05:57:27 <nand`windows> GHC 7.6.1
05:57:39 <nand`windows> No idea re: glut, I just got http://user.xmission.com/~nate/glut.html
05:58:44 <DMcGill> the proprietary version then
05:59:38 <Eduard_Munteanu> nyc: how do you mean? I think it depends a lot on the application.
05:59:49 <DMcGill> > let (-->) = (+) in 1 --> 2
05:59:51 <lambdabot>   3
05:59:58 <DMcGill> I was not expecting that to work
06:00:13 <fmap> why not?
06:00:27 <DMcGill> I would have thought it would comment out the "> 2"
06:01:02 <cornihilio> where could I find an example output of hslogger?
06:01:02 <mapf> it's why haddock have -- | and not --|
06:01:11 <byorgey> "An ordinary comment begins with a sequence of two or more consecutive dashes (e.g. --) and extends to the following newline. The sequence of dashes must not form part of a legal lexeme. For example, “-->” or “|--” do not begin a comment, because both of these are legal lexemes; however “--foo” does start a comment."
06:01:16 <byorgey> from the 2010 report
06:01:23 <nand`windows> hah, gloss works; but hangs when I close the window
06:01:24 <nand`windows> oh well, time's up
06:01:47 <parcs`> mSSM: evalStateT is responsible for unwrapping the StateT newtype constructor, applying the initial state to the unwrapped value (which has type 's -> m (a, s)'), and only returning 'm a' from the 'm (a,s)' result tuple
06:01:53 <fmap> I think Haskell98 repost says that too
06:01:59 <fmap> s/repost/report/
06:02:02 <byorgey> yes, I'm sure that part was not changed
06:03:05 <mSSM> parcs`: I understand that part. What I don't understand is how this works in the concrete example.
06:04:40 <parcs`> mSSM: in 'evalStateT (updateIsing 1000 t) i', (updateIsing 1000 t) has the type StateT Ising IO () and so i has the type Ising, and the type of the entire expression is IO ()
06:04:48 <edwardk> nyc: my goal with linear was to focus on low dimension counts. 3-6 dimensions, for problems that arise a lot in game physics: quaternions, plucker coordinates, homogeneous 3d coordinates, etc.
06:05:05 <edwardk> nyc: i admit sparse matrices are needed for most bigger applications
06:05:40 <mSSM> parcs`: hm, ok; thanks; I think that helps :)
06:06:26 <mSSM> parcs`: the magic going on in updateIsing is confusing, when it seems to get some state out of thin air with <- S.get
06:09:17 <parcs`> mSSM: the state is implicity handled by the definition of (>>=) for StateT. and 'get = StateT $ \s -> return (s,s)'
06:09:32 <ousado> I'm looking for something like a structural hash on types. basically something that would be used in a compiler-cache to determine whether recompilation is required. any pointers?
06:10:34 <nyc> edwardk: Those are to describe individual objects; when those objects proliferate, the system becomes large and sparse.
06:10:37 <osfameron> if RainCat's makefile complains about Graphics.UI.SDL.Video how do I know what to tell cabal to install?
06:11:27 <edwardk> yes, but we typically control that by other meta means rather than by trying to smash everything into an enormous matrix.
06:11:41 <osfameron> nothing obvious in cabal --help
06:11:58 <osfameron> well, 'list' looked promising, but doesn't find anything
06:12:01 <dcoutts> osfameron: you need to know which package provides that module
06:12:07 <Saizan> osfameron: http://www.google.co.uk/search?hl=en&as_sitesearch=hackage.haskell.org%2Fpackage&as_q=Graphics.UI.SDL.Video
06:12:12 <osfameron> dcoutts: why?  why can't cabal tell me?
06:12:19 <osfameron> but ok
06:12:34 <osfameron> cabal-- # weaksauce
06:12:37 <dcoutts> osfameron: try cabal list sdl, it'll be one of those
06:13:12 <byorgey> someone should implement an extension to 'cabal list' that looks for packages containing a given module name
06:13:12 <mSSM> parcs`: yeah, I think once again I needed to do some desugaring with the do
06:13:13 <dcoutts> osfameron: or use search on hackage
06:13:20 <dcoutts> byorgey: yes, would be useful
06:13:21 <byorgey> shouldn't be too hard, it would be a nice feature
06:13:24 <osfameron> from http://hackage.haskell.org/packages/archive/SDL/0.5.9/doc/html/Graphics-UI-SDL-Video.html how do I know which is the package?
06:13:43 <dcoutts> byorgey: main reason we don't yet is because we'd need a better cache for the index.
06:13:45 <osfameron> is it SDL-0.5.9: ?
06:13:49 <osfameron> that's at the top
06:13:51 <byorgey> osfameron: yep
06:13:56 <byorgey> osfameron: cabal install SDL
06:14:05 <SaaMmY-laptop> hi all: can haskell convert a list in a simple txt into a [....] list?
06:14:09 <osfameron> ah ok.  I think I did 'cabal install sdl' lower case...
06:14:13 <dcoutts> byorgey: otherwise you have to parse every .cabal file in the index to do the search, and that'll be very slow.
06:14:13 <byorgey> dcoutts: oh? why's that?
06:14:20 <byorgey> ahh, I see
06:14:27 <jmcarthur> SaaMmY-laptop: yes
06:14:35 <dcoutts> byorgey: there's about 25k .cabal files and the parser was not designed for speed
06:14:41 <jmcarthur> @faq can haskell convert a list in a simple txt into a [....] list?
06:14:42 <lambdabot> The answer is: Yes! Haskell can do that.
06:14:42 <byorgey> dcoutts: like, how slow?
06:14:54 <byorgey> like a few seconds, a few minutes, ...?
06:15:08 <dcoutts> byorgey: probably on the order of 30s
06:15:18 <nyc> edwardk: It's not apparent to me that they can be decoupled.
06:16:10 <byorgey> dcoutts: hmm, really?  But... cabal init now auto-guesses the package dependencies to add to the .cabal file, based on the names of imported modules
06:16:18 <byorgey> and it doesn't take 30s
06:16:32 <DMcGill> > read "[1,2,3]" :: [Int] -- SaaMmY-laptop, like this
06:16:34 <lambdabot>   [1,2,3]
06:16:39 <dcoutts> byorgey: it's presumably only looking at installed packages right?
06:16:44 <DMcGill> and you can use readFile to get the string from a file
06:16:48 <byorgey> dcoutts: oh! yes, of course =P
06:16:57 <byorgey> ignore me =)
06:17:05 <DMcGill> see also lines and words to split things up
06:17:08 <dcoutts> byorgey: and not only is that much smaller, it's also got a binary cache so it's quick (it used to be slow too)
06:17:09 <edwardk> nyc: well, i'll just point out that i can't think of a single game physics engine out there that smashes everything together like that. its a all about breaking things down into simpler swept volumes, checking those for overlap and them breaking things down to find the collision time, etc. the space under consideration gets considerably sped up by avoiding calculating anything that is already at rest and work is saved via contact patc
06:17:18 <byorgey> dcoutts: right, makes sense.
06:17:52 <dcoutts> byorgey: we'd need a binary format cache of the parsed packages, or to go further and make the search index once and cache that.
06:17:59 <edwardk> in practice once you've figured out what to calculate like that going sparse is a big nono because you keep everything as SIMD as you can, you don't even want branches in that code
06:18:06 <nyc> edwardk: The contexts I've seen are not games, so there' ssomething odd.
06:18:24 <edwardk> like i said, 'game physics', not particle physics ;)
06:19:31 <parcs`> mSSM: every action performed in the do block of the State monad has the form '\state -> (intermediate_return_value, new_state)', and the definition of (>>=) is responsible for composing two stateful actions into one by creating a new stateful function that threads the state from the first action to the second action
06:20:19 <osfameron> bah, failure installing haskell98 for Rain Cat
06:20:28 * osfameron gets on with some work instead
06:21:57 <mSSM> parcs`: yeah, I am desugaring stuff by hand right now
06:22:10 <mSSM> parcs`: maybe I will heed the suggestion in RealWorld Haskell and just not work with do right now
06:22:21 <mSSM> parcs`: having lambdas all over is ugly, but probably better for me
06:22:59 * mSSM drinks his coffee sans sugar!
06:23:18 <parcs`> yeah, that's a good idea. later on you should try to implement the Monad instance for State
06:26:15 <nyc> edwardk: It actually makes sense that the systems would be partitionable save for limited situations in terms of the kinematics.
06:26:28 <neutrino_> Haskeλλ
06:31:13 <nyc> edwardk: The relevance of the sparse numerical linear algebra affairs is probably therefore limited to radiosity rendering and maybe a few other isolated things in simulations that directly utilize physics.
06:31:14 <SaaMmY-laptop> what's <- ?
06:31:33 <linduxed> ok so i've got the function "distance :: Evol a => a -> a -> Double" and a list with Evol. i need to get a (length a)^2 matrix with all the combinations
06:31:49 <eikke> anyone familiar with conduit (and using it for writing network servers) around? been fighting some problems for a while now, and maybe I'm making some obvious mistake
06:32:02 <Saizan> SaaMmY-laptop: it's part of the syntax of do-notation or list comprehensions
06:32:21 <linduxed> my guess is that i could use list comprehension to generate all of the pairs, like [ (a,b) | a <- list, b <- list ]
06:32:25 <nyc> edwardk: I'm not really dealing with simulations or games, though.
06:32:37 <hpaste> neutrino pasted “how can i put this in @pl?” at http://hpaste.org/77817
06:33:00 <linduxed> but that returns a flat list, i need it to be split up across (length list) lists
06:33:01 <neutrino_> i'm having problems putting let blocks in @pl, any tips?
06:33:24 <neutrino_> eikke: hang around, someone's bound to show up.
06:33:25 <SaaMmY-laptop> I have followed the tutorial and I still don't understand <- what does it mean?
06:33:38 <Saizan> linduxed: [ map ((,) a) list | a <- list ]
06:33:45 <DMcGill> SaaMmY: think of it like "take the value out of the monad"
06:33:58 <DMcGill> except that you need to use it inside do-notation
06:34:11 <Iceland_jack> DMcGill: Do you honestly think namedroping “monad”s is helpful?
06:34:22 <SaaMmY-laptop> indeed
06:34:24 <edwardk> Come to think of it, I never even used sparse matrices for radiosity back in the day, and i don't use them in my metropolis light transport code now. The sparseness in each is handled by flipping control around and prioritizing the largest "undistributed packet of energy" rather than a proper sparse matrix.
06:34:24 <SaaMmY-laptop> XD
06:34:24 <latermuse> whats the best way to change every multiple of x in [1..100] to equal 0? so 3 -> [1,2,3,4,5] == [1,2,0,4,5]
06:34:34 <edwardk> (well, MLT uses something very different)
06:34:35 <latermuse> whats the best way to change every multiple of x in [1..100] to equal 0? so x=3 -> [1,2,3,4,5] == [1,2,0,4,5]
06:34:44 <DMcGill> think of it like taking the value out of the Maybe or IO or State or List or whatever
06:34:47 <linduxed> Saizan: i'll try that
06:34:52 <Iceland_jack> SaaMmY-laptop: [ a | a <- [1,2,3,4] ] is the same as [1,2,3,4]
06:34:55 <Iceland_jack> Does that make sense?
06:35:08 <SaaMmY-laptop> mmm
06:35:12 <Saizan> SaaMmY-laptop: "do x <- foo; ..." is an action which executes foo, binding its result to x, and then continues with ...
06:35:20 <DMcGill> so do{ string <- readFile filename; putStrLn (head string)}
06:35:29 <DMcGill> string contains the value from readFile
06:35:39 <edwardk> the cost of the branches is too high so it behooves you to flip to a domain specific solution
06:35:48 <DMcGill> then you apply "head" to it, and print that
06:36:07 <linduxed> Saizan: it worked!
06:36:16 <linduxed> Saizan: although i can't quite understand why
06:36:24 <linduxed> Saizan: trying to wrap my brain around it
06:36:31 <nyc> edwardk: I'm surprised, but not terribly much, as I'm not involved with games or graphics.
06:36:48 <SaaMmY-laptop> wtf is <- = belongs so like in math ?
06:36:53 <DMcGill> linduxed: in lists, "<-" is more like "get all possibles values from the list"
06:36:57 <SaaMmY-laptop> <-=belogns
06:37:01 <SaaMmY-laptop> *belongs
06:37:13 <Saizan> SaaMmY-laptop: in list comprehensions, yes
06:37:18 <SaaMmY-laptop> wow
06:37:23 <DMcGill> so [x | x <- [1,2,3]] is like "make a list of x where x is from the list [1,2,3]"
06:37:23 <SaaMmY-laptop> what the ....
06:37:23 <Saizan> linduxed: you could also desugar that as map (\a -> map ((,) a) list) list
06:37:26 <linduxed> DMcGill: it's not that part that confuses me
06:37:34 <SaaMmY-laptop> I understood now
06:37:48 <linduxed> DMcGill: it's just the curried function that i need to expand in my head
06:38:38 <DMcGill> ah, sorry I missed that bit
06:39:18 <DMcGill> that can be written as [[(a,b) | a <- list] | b <- list]
06:39:47 <DMcGill> so for each element in the list, you're making a new list
06:39:50 <SaaMmY-laptop> the best answer was [ a | a <- [1,2,3,4] ] is the same as [1,2,3,4] by Iceland_jack
06:40:24 <SaaMmY-laptop> it's the right parallelism for math knowers
06:41:08 <Saizan> DMcGill: [[(a,b) | b <- list] | a <- list] to be pedant :)
06:41:23 <DMcGill> my mistake, I always get them mixed up
06:41:55 <DMcGill> then linduxed if you desugar that, you get something like
06:42:17 <DMcGill> [map (\b -> (a,b)) list | a <- list]
06:42:29 <DMcGill> [map ((,) a) list | a <- list]
06:42:40 <linduxed> yey, now i see it
06:42:49 <SaaMmY-laptop> so what about -> ?
06:42:55 <linduxed> ok, all is good in haskell-land
06:42:56 <SaaMmY-laptop> is the same but reversely?
06:43:08 <DMcGill> no, "->" is used in lambda functions
06:43:20 <DMcGill> > (\x -> 2*x) 3
06:43:23 <lambdabot>   6
06:44:00 <SaaMmY-laptop> some trivia on haskell matter should fit well here
06:44:08 <SaaMmY-laptop> XD
06:45:43 <barrucadu> Why is Num not an instance of Eq in GHC 7.6.1? I'm looking at Haskell2010 and that behaviour doesn't make sense
06:46:23 <startling> barrucadu, Num isn't a type
06:46:40 <barrucadu> startling: Ok, why isn't the Num typeclass in Eq?
06:46:51 <startling> barrucadu, what do you mean?
06:47:01 <barrucadu> http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4
06:47:03 <DMcGill> do you mean why aren't all things that are in Num also in Eq?
06:47:08 <barrucadu> class  (Eq a, Show a) => Num a  where
06:47:11 <bartavelle> ok, I tried to understand http://logicaltypes.blogspot.fr/2012/11/coreader-x-costate-silver-bullet.html and didn't, then I tried to understand why I would want to use http://hackage.haskell.org/packages/archive/category-extras/0.53.5/doc/html/Control-Comonad-Reader.html, and found the description incredibly cryptic
06:47:14 <barrucadu> DMcGill: Yes
06:47:21 <bartavelle> when would you want to use the co-reader ?
06:47:31 <fmap> because not all numbers are comparable apparently
06:47:33 <DMcGill> > ((+1) + (+3)) 6
06:47:34 <startling> barrucadu: you mean, "why isn't Eq a superclass of Num"?
06:47:35 <lambdabot>   16
06:47:42 <barrucadu> startling: Yes
06:47:58 <bartavelle> I see how its type is related to that of the reader monad, but I can't see how that makes it useful
06:48:06 <bartavelle> (or even what it does)
06:48:18 <startling> barrucadu, look at what DMcGill wrote -- not all Num are inspectable
06:48:36 <startling> barrucadu: I also imagine that float/double equality isn't so clear
06:48:42 <Tinned_Tuna> :t ((+1) + (+3)) 6
06:48:44 <lambdabot> Num a => a
06:48:53 <jmcarthur> but float/double equality is at least defined
06:48:53 <barrucadu> But the behaviour of GHC is deviating from Haskell2010, and I don't have any language extensions turned on
06:49:14 <Saizan> barrucadu: the base library can deviate from the libs specified in haskell2010
06:49:16 <Tinned_Tuna> startling: so take Float & Double out of Num if they don't meet the criteria -- don't break Num
06:49:24 <DMcGill> Tinned_Tuna: that's equiv to (\x -> (x+1) + (x+3)) 6
06:49:36 <Saizan> barrucadu: there's the haskell2010 library if you want that
06:49:41 <DMcGill> Tinned_Tuna: then you couldn't use (+) on Floats
06:50:38 <Tinned_Tuna> DMcGill: that's fine. IEEE-754 is broken.
06:51:01 <DMcGill> well can you imagine the issues we'd get from people trying to use Haskell and non-integers?
06:51:20 <DMcGill> what's your suggestion, that nobody should attempt to add any Floats or Doubles?
06:51:48 <Tinned_Tuna> DMcGill: Not quite, but that it should be made clear that IEEE-754 is broken, and potentially put in a different typeclass.
06:52:14 <Saizan> Float and Double are instances of Eq
06:52:17 <DMcGill> "class NumF where (+F), (-F), (*F) = ..."?
06:52:41 <Saizan> they have nothing to do with why Eq is no longer a superclass of Num
06:53:09 <sw17ch> nand`: ping
06:53:54 <Tinned_Tuna> DMcGill: I am not sure how your anonymous function causes a problem.
06:54:05 <DMcGill> because functions aren't in Eq
06:54:15 <DMcGill> and can't be
06:54:23 <DMcGill> yet in lambdabot at least, they're in Num
06:54:30 <Tinned_Tuna> I agree, why does that function need to be in Eq?
06:54:46 <startling> Tinned_Tuna, it's used as Num
06:54:54 <DMcGill> because if Num needed Eq, then functions couldn't be an instance of Num
06:54:57 <startling> > (1 99)
06:54:58 <Tinned_Tuna> > (\x -> (x+1) + (x+3))
06:54:59 <lambdabot>   1
06:55:00 <lambdabot>   can't find file: L.hs
06:55:00 <DMcGill> when it'd valid
06:55:08 <Tinned_Tuna> :t 1
06:55:09 <lambdabot> Num a => a
06:55:10 <startling> Tinned_Tuna, not that, the other one.
06:55:19 <startling> > (+ 2) + (+ 5) $ 10
06:55:22 <lambdabot>   27
06:55:30 <Tinned_Tuna> :t (+2) + (+5)
06:55:32 <lambdabot> Num a => a -> a
06:55:45 <DMcGill> it's not just functions, there are other things that are also valid isntances of Num but not of Eq
06:56:20 <DMcGill> Wires for example
06:56:23 <Tinned_Tuna> I would follow for higer-dimensional structures, but for the standard typeclasses, there is nothing which can't be tested for equality
06:56:29 <Tinned_Tuna> *higher
06:56:45 <mauke_> yes, there is: functions
06:57:30 <Tinned_Tuna> mauke_: why are functions in Num?
06:57:48 <mauke_> because they support all required operations
06:57:54 <mauke_> why is Maybe in Monad?
06:57:55 <Saizan> Tinned_Tuna: if you require equality just require an additional Eq constraint, it's not a problem
06:59:03 <Tinned_Tuna> Where's the definition of (+) for Haskell2010
06:59:47 <jmcarthur> for what type?
06:59:55 <jmcarthur> or do you just mean the type class?
07:00:17 <Tinned_Tuna> jmcarthur: the type class, and what does something actually need to do to satisfy (+) ?
07:00:44 <scp> :t (+)
07:00:45 <lambdabot> Num a => a -> a -> a
07:01:08 <neutrino_> guys, any ideas how i could input this into lambdabot's @pl? http://hpaste.org/77817
07:01:09 <Tinned_Tuna> scp: that's the type, what does it actually need to satisfy ?
07:01:16 <DMcGill> Tinned_Tuna: http://lambda.haskell.org/hp-tmp/docs/2011.2.0.0/ghc-doc/libraries/base-4.3.1.0/src/GHC-Num.html#Num
07:01:25 <barrucadu> Tinned_Tuna: http://www.haskell.org/onlinereport/haskell2010/haskellch6.html#x13-1350006.4
07:01:28 <mauke_> Tinned_Tuna: define "actually"
07:01:28 <scp> @src Num
07:01:29 <lambdabot> class  (Eq a, Show a) => Num a  where
07:01:29 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:01:29 <lambdabot>     negate, abs, signum     :: a -> a
07:01:29 <lambdabot>     fromInteger             :: Integer -> a
07:02:40 <Tinned_Tuna> mauke_: for example, there are the monad laws which specify what properties (>>=) has, is there a similar thing for (+) ?
07:02:51 <atriq> @pl \xs -> let mw = (maximum . map length) xs; mkW x = x ++ (take (mw - (length x)) (repeat ' ')) in map mkW xs -- neutrino_
07:02:51 <lambdabot> ap ((. (ap (++) . flip flip (repeat ' ') . (take .) . (. length) . (-))) . flip map) (maximum . map length)
07:03:15 <neutrino_> atriq: ahhh thanks
07:03:30 <scp> Tinned_Tuna: I think that depends on how _you_ want it to behave.
07:03:46 <DMcGill> it's not like the laws are actually enforced
07:03:57 <Tinned_Tuna> DMcGill: that doesn't stop them mattering.
07:03:59 <DMcGill> and there's a few instances of Monad that don't satisfy the laws for example
07:04:03 <scp> Tinned_Tuna: check out http://en.wikipedia.org/wiki/Group_%28mathematics%29
07:04:14 <atriq> neutrino_, if it's ridiculous, it's generally a sign that it's a bad idea
07:04:16 <Tinned_Tuna> DMcGill: then they're not a monad.
07:04:22 <Tinned_Tuna> scp: So Num is supposed to be a group?
07:04:41 <scp> Tinned_Tuna: If you want it to. There aren't commonly discussed "Num laws" that I've ever heard of
07:04:53 * Tinned_Tuna facepalms
07:05:09 <neutrino_> atriq: yeah, this one was ridiculous.
07:05:13 <neutrino_> sometimes it works well though.
07:05:37 <scp> Tinned_Tuna: Why are you asking? The reason we have monad laws is so that you can have functions defined on monads work as expected.
07:05:42 <Kn|t3> Hi
07:05:43 <DMcGill> Num is a legacy from silly non-math programming ideas
07:05:49 <Kn|t3> So I am just starting with Haskell
07:05:53 <rwbarton> I think everyone expects Num to be at least a (possibly non-commutative) ring
07:05:55 <scp> Hi Kn|t3
07:05:55 <DMcGill> people just wanting to add things without worrying about laws and so on
07:06:08 <Kn|t3> Before I dive in, what are the best use cases where Haskell beats other languages hands down?
07:06:27 <Kn|t3> I think I would want to ask, what are the use cases where functional programming beats other programming paradigms
07:06:28 <DMcGill> Kn|t3: Haskell is very consise for parsing for example
07:06:35 <Tinned_Tuna> DMcGill: they don't want to worry about them, that's why the language maintainers do all of the worrying for you.
07:06:50 <DMcGill> having higher order functions makes parser combinators work
07:07:03 <Kn|t3> DMcGill: Parsing as in? You mean string parsing?
07:07:04 <FireFly> Kn|t3: functional programming often lets you abstract problems neatly
07:07:06 <DMcGill> so you can do "many (char '3')"
07:07:23 <xkb> hmm if I change parsedFeeding to feedingWithUser yield a no toJSON error.. any idea why? https://gist.github.com/4087945
07:07:26 <DMcGill> yes. Where 'char' is a parsing function
07:08:14 <FireFly> Kn|t3: my go-to example is implementing a sum function as a for-loop vs. something like "foldl1 (+)"
07:08:16 <Kn|t3> FireFly: Can't someone do that with CPP if he write well defined classes and functions?
07:08:26 <scp> Tinned_Tuna: why are you asking? Seems like we've got a bit of an x -> y problem here
07:08:54 <DMcGill> Kn|t3: well yes, it's not like Haskell has a monolopy on nice abstractions
07:09:15 <DMcGill> at the end of the day, everything is turing complete (unless it's on purpose)
07:09:27 <DMcGill> see Agda
07:09:39 <Kn|t3> So, I would like to ask this in a different way, are you guys using Haskell in daily use-cases?
07:09:45 <Kn|t3> Or is it mostly a hobby project?
07:09:58 <DMcGill> yes, I've written applications, courseworks and games in Haskell
07:10:02 <atriq> Kn|t3, it's used for web development a fair bit
07:10:12 <scp> Kn|t3: Another thing is, even if you don't end up using functinal programming for everything, learning about a vastly-different language like haskell help give you new perspectives on your standard OOP languages
07:10:18 <Tinned_Tuna> scp, Some typeclasses broke between GHC6 and GHC7 basically.
07:10:20 <DMcGill> it's a general programming language and can be used in any case C++ is used and vice versa
07:11:01 <DMcGill> there's a reason Java and python have started to add functional paradigms like lamda functions, higher order functions and list comprehensions
07:11:26 <DMcGill> (although I don't think Java has lists comprehensions yet)
07:11:38 <Kn|t3> Hmm, probably I should give Haskell a week's try and then I would be able to get some more idea.
07:11:41 <FireFly> I don't think the current version has lambdas either
07:11:44 <Kn|t3> Thanks so much.
07:11:58 <DMcGill> Kn|t3: have a go at tryhaskell.org lyah
07:11:58 <DMcGill> @where lyah
07:11:59 <lambdabot> http://www.learnyouahaskell.com/
07:12:12 <applicative> Kn|t3: one of the classical 'daily use cases'  that gets people attached to Haskell is the parsing libraries
07:12:15 <DMcGill> I meant "or lyah"
07:12:28 <MasseR> Kn|t3: Have you seen pandoc? It's a great swiss knife for document types. And have you heard about git-annex? Those are all written in haskell
07:12:41 <rwbarton> Tinned_Tuna: are you talking about the (former) Show and Eq superclasses of Num?
07:12:48 <Kn|t3> MasseR: Sorry, I haven't heard of those. I will look them up.
07:12:58 <Kn|t3> Thanks DMcGill  for the resources.
07:13:13 <Tinned_Tuna> rwbarton: according to haskell2010, Show and Eq are still superclasses.
07:13:19 <applicative> Kn|t3: pandoc is a good example of a practical use of the parsing libraries
07:13:19 <Saizan> Tinned_Tuna: if you want to know how it went http://www.haskell.org/pipermail/libraries/2011-September/016699.html
07:13:32 <MasseR> I'm currently writing myself a sort of a document management system. An intelligent / dummy server combined with 'modules' that can go either from parsing pdfs and providing them to the server or to giving a url which is then parsed and saved
07:13:34 <rwbarton> right but not in GHC 7.(something)
07:14:38 <DMcGill> Tinned_Tuna: do you really think that http://hackage.haskell.org/package/yap should be standard?
07:14:40 <geekosaur> Tinned_Tuna, if you ask for Haskell2010 compatibility you should still have those superclasses.  The default is to use ghc's "native" language which is not necessarily H'2010 compliant
07:14:56 <DMcGill> Then "you need to know abstract maths to program haskell" really would be true
07:16:55 <startling> can I use applicative style on an (f a), (fb), and (a -> b -> f c) to get an (f c), or is this outside the power of Applicative?
07:17:17 <copumpkin> it's outside the power
07:17:18 <applicative> that's exactly what a monad add
07:17:21 <applicative> adds
07:17:25 <copumpkin> applicative would know
07:17:28 <startling> hehe
07:17:40 <startling> applicative, insecurity complex?
07:17:53 * applicative hasn't been thinking about applicative, admittedly
07:17:55 <copumpkin> applicative has his/her own advantages
07:18:30 <startling> so I've got ((,) <$> a <*> b) >>= uncurry f , is this the best way to do that?
07:18:40 <copumpkin> no
07:18:55 <applicative> startling you can do it, but then do join
07:19:05 <copumpkin> :t \f a b -> join (liftA2 f a b)
07:19:06 <lambdabot> (Monad m, Applicative m) => (a1 -> b -> m a) -> m a1 -> m b -> m a
07:19:12 <bartavelle> copumpkin, are comonads something for the common haskell programmer, or something for people who write complicated libraries (such as lens stuff)
07:19:13 <bartavelle> ?
07:19:26 <startling> copumpkin: oh, good call
07:19:26 <copumpkin> you could get by just fine if you never learned comonads
07:19:32 * ski thinks that could be called `extendM2'
07:19:36 <DMcGill> or do {a' <- a; b' <- b; f a' b'} I think
07:19:39 <edwardk> they are useful, but they are something of an acquired taste ;)
07:19:41 <applicative> startling: the way to write it I think is join ( f <$> a <*> b)
07:19:41 <copumpkin> yeah
07:19:58 <copumpkin> you need the comonad design pattern achievement factory
07:20:05 * copumpkin gives edwardk the comonad achievement
07:20:09 * bartavelle likes achievements
07:20:09 <edwardk> monads abstract out a common usage pattern that you absolutely have to know to be productive. comonads abstract out a common usage pattern that is far less critical.
07:20:18 * applicative gives edwardk the factory
07:20:19 <copumpkin> edwardk is so comonadic, his website even says so
07:20:38 * applicative gives member:edwardk the factory achievement, rather
07:20:46 <copumpkin> edwardk: I brought in my magnets, btw
07:20:48 <bartavelle> but what is this usage pattern ? Can you give a specific example of something that a "common" haskeller might want to do ?
07:20:51 <dgpratt> are comonads considered dual to monads?
07:20:54 <edwardk> yeah i have the factory achievement. that lets me give out the base achievement
07:20:58 <copumpkin> dgpratt: yes
07:21:04 <startling> applicative: yeah, I just stumpled on that. :)
07:21:05 <bartavelle> As I said just a bit ago, I have no clue of what this is about : http://logicaltypes.blogspot.fr/2012/11/coreader-x-costate-silver-bullet.html
07:21:45 <startling> bartavelle, http://blog.sigfpe.com/2006/12/evaluating-cellular-automata-is.html
07:22:00 <startling> that's a common-ish use case of Comonad
07:22:09 <bartavelle> startling, thanks
07:22:23 <edwardk> bartavelle: i'm not entirely sure what its about either. part of it is the vocabulary shift. one sec
07:23:24 <bartavelle> edwardk, my intuition about this particular article this is about complexity, in the same sense of how the codensity thingie reduces asymptotic complexity
07:23:41 <edwardk> i follow it about half way through and then it starts jumping around too much
07:23:52 <bartavelle> but as I do not _really_ understand the codensity transformation and have no clue about what is happening in this particular article, I am probably entirely wrong
07:24:13 <bartavelle> but in the end he saves SQL queries
07:24:16 <bartavelle> ;)
07:24:22 <dgpratt> it's interesting because in the .NET space we have IQueryable/IEnumerable which is said to form a Monad and its dual IObservable, but I really don't think IObservable is a Comonad
07:24:23 <nand`> hrm; I compiled a library but I don't want to install it; can I still load it in GHCi and play around with it somehow? I'm not sure what I should be doing; ./dist/build has two .o files, an .a file and a .hi file
07:24:23 <lambdabot> nand`: You have 1 new message. '/msg lambdabot @messages' to read it.
07:24:25 <DMcGill> oh wow, I wish I'd known about this Comonad stuff before I wrote exactly all this code
07:24:27 <nand`> @messages
07:24:27 <lambdabot> sw17ch said 9h 8m 19s ago: I got a start on the xwiimote bindings we discussed earlier: https://github.com/sw17ch/hsxwiimote
07:24:58 <dgpratt> at least nothing I've read about comonads reminds me of IObservable
07:25:02 <bartavelle> DMcGill, what did you use "all that code" for ?
07:25:13 <edwardk> IObservable isnt a comonad (well, actually they make it one but thats another issue) it isn't dualizing along that axis. its dualizing control flow.
07:25:19 <DMcGill> I mean I wrote my own cellular automata program
07:25:25 <bartavelle> ah :)
07:26:32 <edwardk> dgpratt: there is a good talk on the topic of deriving the types for IObservable on channel 9 with erik and wes
07:26:56 <dgpratt> edwardk: yes, I think I watched it a while back
07:27:30 <edwardk> http://channel9.msdn.com/Shows/Going+Deep/E2E-Erik-Meijer-and-Wes-Dyer-Reactive-Framework-Rx-Under-the-Hood-1-of-2
07:27:59 <edwardk> in haskell it would wind up being a comonad over the kleisli category of IO or some such
07:28:59 <edwardk> dgpratt: to make that more concrete, you can dig through an aborted project of mine: https://github.com/ekmett/reactor/blob/master/Reactor/Observable.hs#L89 =)
07:29:36 <dgpratt> edwardk: oh, that looks very interesting!
07:29:43 <edwardk> newtype Observable a = Observable { subscribe :: Observer a -> Task Subscription }; data Observer a = Observer  { (!) :: a -> Task ()  , handle   :: SomeException -> Task ()  , complete :: Task ()  } -- should look a lot like what you know from .net
07:29:54 * applicative wonders what form of speed geoph f was taking when he wrote that; it might of use for something other composition
07:29:59 <sw17ch> nand`: it's not done yet, but i got a good start on it.
07:30:09 <sw17ch> particularly, i have no way of testing it, and i haven't checked if it links properly
07:30:21 * applicative means, something other than composition
07:30:24 <edwardk> applicative: i had the same thought. it started out pretty normal and then went off into deep end territory fast
07:31:22 <nand`> sw17ch: I seem to be having no way to test it either; simply because I don't know how to load it, or how to link it against the actual libxwiimote or whatever
07:31:39 <nand`> otherwise I would try playing around with it in GHCi
07:31:52 <nand`> at any rate, you need to loosen the base dependency; it builds fine on 4.6
07:32:13 <sw17ch> nand`: ah, i didn't bother to check. i just did a `cabal init` last night.
07:32:28 <sw17ch> hand`: do you have libxwiimote installed?
07:32:32 <sw17ch> nand`: ^^
07:32:39 <nand`> and also I guess an extra-libs: xwiimote
07:32:40 <nand`> yeah, I do
07:33:07 <nand`> extra-libraries*
07:34:39 <sw17ch> nand`: pushed a few changes. if you have the lib installed and the header is in the default search path, then it might build and link for you
07:35:28 <nand`> it builds and ‘In-place registers’
07:35:47 <nand`> but it didn't seem to link anything
07:37:24 <sw17ch> what happens if you attempt to import the file into something that defines a main?
07:37:32 <sw17ch> i'd expect that to fail on compile or fail on load
07:37:53 <nand`> Could not find module `XWiimote.FFI', etc; running ghc Test.hs -i/home/nand/dev/hsxwiimote/dist/build
07:39:34 <nand`> oh, lowercase m
07:39:40 <nand`> I think ‘Wiimote’ is a name
07:39:54 <nand`> sw17ch: linker errors, undefined reference to `xwii_monitor_poll' etc.
07:41:30 <applicative> it is a deep ground for preferring program X over Y that the stats for X say "15 MB total memory in use (0 MB lost due to fragmentation) " but for Y say "19 MB total memory in use (4 MB lost due to fragmentation)"
07:42:58 <applicative> that seems to be the only major difference between using Text (X) and Data.Vector.Unboxed.Vector Char (Y) for a complicated parsec problem
07:44:50 <DMcGill> applicative: have you profiled for speed and so on?
07:45:11 <osfameron> can you filter on the *result* of the map part of a list comp?
07:45:42 <rwbarton> [ result | x <- ..., let result = ..., foo result, ... ]
07:46:02 <applicative> DMcGilll yeah, the Vector Char is slightly slower.  This may be due to the ineptness of my parsec Stream instance or a number of other things
07:46:08 <osfameron> rwbarton: cool, thanks
07:46:20 <rwbarton> (or just a "filter foo" outside may be simpler)
07:46:37 <osfameron> I'm actually trying to figure out how you'd do that in python... doesn't seem to have the same possibility
07:46:43 <DMcGill> applicative: optimising Haskell is hard :(
07:46:45 <osfameron> yeah, filter outside seems ok, but a bit meh
07:46:53 <bartavelle> how does parsec work with Text ? Does "many1 letter" returns Text or [Char] ?
07:47:44 <applicative> many1 returns a []
07:47:56 <applicative> or am I hallucinating
07:48:14 <tomeo> \l -> [x] does this mean take element l and turn it into a list?
07:48:17 <bartavelle> no I believe you are right, IIRC I did things like fmap T.pack (many1 ...)
07:48:31 <bartavelle> but I wonder if there is a more effective way
07:48:48 <byorgey> bartavelle: many1 letter can *parse from* either a String or Text, depending on whether you import Text.Parsec.String or Text.Parsec.Text
07:48:52 <rwbarton> the more efficient way is to use attoparsec
07:48:57 <byorgey> bartavelle: but it will always *output* a [Char]
07:49:01 <applicative> bartavelle:  similarly with the much cooler Data.Vector.Unboxed.Vector Char, many1 (char 'a') returns a string
07:49:06 <latermuse> :tomeo \l -> [l] would take element l and turn it into a list
07:49:14 <tomeo> latermuse: thanks!
07:49:25 <bartavelle> attoparsec can return a Text from a many1 ?
07:49:46 <latermuse> l:[] would work too
07:49:49 <DMcGill> tomeo: '(:[])' or 'return' are nicer than a lambda function
07:50:15 <applicative> many1 :: Alternative f => f a -> f [a] in attoparsec as elsewhere
07:50:18 <tomeo> DMcGill: Do you mean \l:[] ?
07:50:23 <DMcGill> although exactly why 'return' works like that in this case is a little complicated, it might be better not to use it for a while
07:50:33 <DMcGill> > (:[]) 3
07:50:35 <lambdabot>   [3]
07:50:39 <tomeo> DMcGill: its an argument to mmap
07:50:47 <Iceland_jack> > (:) 3 []
07:50:48 <lambdabot>   [3]
07:50:49 <tomeo> DMcGill: so it has to be a function, as Ive understood it
07:50:57 <DMcGill> > map (:[]) [1,2,3]
07:50:59 <lambdabot>   [[1],[2],[3]]
07:51:00 <tomeo> ah
07:51:04 <tomeo> thanks DMcGill
07:51:06 <tomeo> thanks a lot :)
07:51:08 <DMcGill> it's called a section
07:51:29 <DMcGill> like Iceland_jack implied, it's actually doing \x -> (:) x []
07:51:31 <applicative> DMcGill: Vector Char was slightly faster than Text a bit ago, but now I seem to have gone too far with the INLINE pragmas...
07:51:40 <DMcGill> = \x -> x : []
07:51:46 <DMcGill> = \x -> (:[]) x
07:51:49 <DMcGill> = (:[])
07:51:55 <applicative> DMcGill: but they are uncannily similar in any case
07:52:33 <mm_freak> tomeo: f x y = x `f` y = (x `f`) y = (`f` y) x
07:52:54 <tomeo> thanks mm_freak
07:53:12 <DMcGill> or just to be clear, (*) x y = x * y = (x *) y = x (*y)
07:53:19 <mm_freak> just like:  (+) x y = x + y = (x +) y = (+ y) x
07:53:30 <DMcGill> as functions defined in symbols are implicitly infix
07:53:54 <tomeo> Are there any large comercial programs I may have heard of that are built with Haskell?
07:53:56 <DMcGill> to make them prefix, put brackets around them. Functions defined with letters are the other way around - to make them infix, put ` around them
07:54:05 <mm_freak> DMcGill: your last one there is probably a type error
07:54:07 <latermuse> tomeo: microsoft uses haskell
07:54:51 <byorgey> latermuse: really? for what?
07:54:55 <mm_freak> tomeo: some websites are implemented in haskell…  check out the commercial users of happstack, snap and yesod
07:55:12 <latermuse> byorgey: not sure, but they sure to put out a lot of research papers about haskell. must mean they have an internal interest in it
07:55:21 <tomeo> ah okay
07:55:29 <rwbarton> for writing ghc obviously :P
07:55:31 <tomeo> is it easy getting haskell to talk to databases?
07:55:31 <DMcGill> ops
07:55:34 <DMcGill> oops*
07:55:41 <mm_freak> tomeo: yes
07:55:46 <byorgey> latermuse: no, it's just that Microsoft Research employs several of the main GHC developers
07:55:48 <DMcGill> yes, there are bindings for it and also databases written in Haskell
07:56:02 <latermuse> tomeo: there are bindings for many databases. check on hoogle
07:56:08 <byorgey> latermuse: I don't think microsoft actually uses Haskell for anything, other than for generating ideas which then get incorporated into things like F#
07:56:09 <tomeo> nice
07:56:39 <mm_freak> tomeo: also i hear that some banks use haskell internally
07:56:55 <tomeo> I was thinking that maybe wolfram alpha uses it
07:57:05 <DMcGill> no, wolfram alpha uses mathematica
07:57:12 <nand`> do they really?
07:57:13 <tomeo> oh okay
07:57:14 <bitonic> tomeo: wolfram have their own languages
07:57:17 <bitonic> *language
07:57:39 <parcs`> mathematica is written in good ol c++
07:57:55 <DMcGill> Haskell is written in C right?
07:57:59 <DMcGill> MATLAB in fortran
07:58:08 <mm_freak> DMcGill: GHC is written in haskell
07:58:16 <mm_freak> the runtime system is written in C
07:58:23 <fryguybob> and cmm and haskell...
07:58:44 <bitonic> cmm is just an intermediate language
07:58:47 <rwbarton> used to be perl too
07:58:57 <bitonic> not anymore!
07:58:57 <rwbarton> (maybe still is?)
07:59:07 <bitonic> the evil mangler is gone
07:59:20 <bitonic> there are still perl scripts to fetch and build stuff
07:59:31 <fryguybob> bitonic: https://github.com/ghc/ghc/blob/master/rts/PrimOps.cmm
07:59:36 <arcatan> oh, the ever-so-evil mangler
07:59:46 <latermuse> xmonad is written in haskell
07:59:52 <bitonic> fryguybob: oh that, right :P
08:04:35 * hackagebot aivika 0.5.1 - A multi-paradigm simulation library  http://hackage.haskell.org/package/aivika-0.5.1 (DavidSorokin)
08:04:39 <applicative> import base_ControlziExceptionziBase_nestedAtomically_closure -- no thanks
08:05:40 <rwbarton> heh
08:06:36 * applicative expresses gratitude to the Nibelungen who write the .cmm files for ghc 
08:06:46 <rwbarton> was just thinking this is like alien C
08:07:07 <latermuse> do you guys often use the foreign funciton interface?
08:07:14 <ski> preflex: zdec base_ControlziExceptionziBase_nestedAtomically_closure
08:07:27 <mm_freak> i think i've never used the FFI directly
08:07:41 <rwbarton> stg_finalizzeWeakzh
08:07:46 <rwbarton> took me a while to realize this was not a typo
08:08:08 * applicative uses the FFI whenever someone on here gives a 6 line example to show how easy it is...
08:09:35 * hackagebot aivika-experiment 0.2 - Simulation experiments for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-0.2 (DavidSorokin)
08:09:37 * hackagebot aivika-experiment-chart 0.2 - Simulation experiments with charting for the Aivika library  http://hackage.haskell.org/package/aivika-experiment-chart-0.2 (DavidSorokin)
08:11:46 <chrisirc> Does it make sense that my GHC installation came without Control.Monad.State? (I'm on Debian.) At least it's not being found.
08:12:03 <quicksilver> yes.
08:12:09 <mm_freak> chrisirc: that's in the mtl library, not in base
08:12:13 <quicksilver> install libghc6-mtl-dev
08:12:17 <quicksilver> or some such name
08:12:18 <chrisirc> Aha, thanks.
08:12:22 <quicksilver> apt-cache search mtl
08:12:36 <latermuse> chrisirc: install it with cabal
08:12:45 <mm_freak> if you install GHC, you really just get a compiler and the base library
08:12:58 <quicksilver> or you could do that. But if there is a debian package I don't see a particular reason not to use it.
08:13:11 <quicksilver> at least you know it's the version which works with your compiler then.
08:13:18 <qwr> (on wheezy it is libghc-mtl-dev without 6, libghc6 is on squeeze)
08:13:36 <nand`> Haskell is written in english
08:13:44 <mm_freak> well, it wouldn't be surprising if debian had mtl 0.0.1 or something, so you may run into dependency issues
08:13:49 <startling> nand`: if only
08:13:53 <mm_freak> that's why i install everything through cabal
08:13:59 <nand`> startling: it isn't?
08:14:01 <qwr> ii  libghc-mtl-dev                                 2.1.1-1                           i386         Haskell monad transformer library for GHC
08:14:51 * qwr thinks it is much easier to install everything with aptitude ;)
08:15:15 <startling> nand`: I was being glib, but you could make an argument that haskell is like a foreign language with a lot of loan words
08:15:25 <startling> nand`: unless of course you mean the Haskell Report itself
08:15:37 <nand`> startling: I mean the Haskell Report
08:15:39 <quicksilver> mm_freak: debian will have the version that corresponds to the GHC version it has.
08:15:49 <nand`> Haskell code is written in Haskell
08:15:58 <quicksilver> mm_freak: with a library like mtl there is not much point using a newer version than the one that corresponds to the GHC.
08:16:10 <startling> nand`: alright. :)
08:16:47 <mm_freak> quicksilver: whenever i tried to use haskell on debian i mostly had to fight with the distribution package management
08:18:01 <b__> in Control.Lens, is there an abstraction that maps ^. (or whatever) over a bunch of records?
08:18:11 <qwr> fighting with it package manager isn't very helpful usually
08:18:23 <latermuse> mm_freak: download the haskell platform from haskell.org
08:18:38 * qwr takes what it gives, forcing deps usually breaks something
08:18:51 <fmap> > [(1,2),(3,4)] ^.. traverse . _1
08:18:53 <lambdabot>   [1,3]
08:19:19 <ramses_> @pl \x -> (x,x)
08:19:20 <lambdabot> join (,)
08:20:46 <b__> > (1,2) ^. _1
08:20:48 <lambdabot>   1
08:22:18 <tibbe> Do the Functor laws have to hold in presence of _|_. I can't see how they would.
08:22:37 <tibbe> e.g. fmap undefined x /= undefined x
08:22:50 <tibbe> (but fmap id x == id x is required)
08:24:18 <edwardk> tibbe: no. pretty much all the laws will have some fuzzy areas around _|_.
08:24:27 <edwardk> > fmap undefined [1,2,3,4]
08:24:29 <lambdabot>   [*Exception: Prelude.undefined
08:24:44 <edwardk> > mapped %~ undefined $ [1,2,3,4]
08:24:46 <lambdabot>   [*Exception: Prelude.undefined
08:24:58 <quicksilver> mm_freak: Yes. The don't use it at all. Not even for your GHC. But if you *are* using it for GHC you might as well use it for mtl.
08:25:04 <quicksilver> hence my advice.
08:26:21 <bitonic> debian is actually the system with the best Haskell packaging
08:26:46 <nand`> I would argue gentoo is
08:26:47 <tibbe> edwardk: http://hpaste.org/77819
08:26:52 <nand`> or maybe nixOS :P
08:26:59 <nand`> (disclaimer: I've never used nixos)
08:27:11 <tibbe> edwardk: I have this type that's isomorphic to Either. I wonder if I can make the constructors strict and still be OK law-wise
08:27:21 <bitonic> gentoo tries too hard to have everything last version, as far as I remember
08:27:29 <bitonic> debian testing is basically haskell platfrm
08:27:31 <tibbe> edwardk: I think I've convinced myself that the answer is yes
08:27:31 <bitonic> *platform
08:27:43 <edwardk> Error can be strict, but IIRC when you strictify Success you have problems, but the last time i worked through why was years ago
08:28:01 <tibbe> edwardk: any idea why I will have problems?
08:28:21 <edwardk> i think i posted something to the cafe about it but it was a long time ago
08:28:41 <afgho> how to define a variable at N and increment at each 'pass'
08:28:50 <copumpkin> it'd be like a strict Maybe, right? return a >>= f should equal f a. If return is strict, then it might not equal f a
08:29:09 <copumpkin> f might not force its argument
08:29:12 <nand`> bitonic: gentoo itself doesn't officially maintain packages; it's a group called gentoo-haskell - the thing about gentoo is that there's a program for automatically creating gentoo packages from hackage, batteries included; so you can just run it if you ever need a newer version than what gentoo-haskell has available (or an older version!); there are also a handful of live packages that are by design always
08:29:12 <nand`> up to date
08:29:16 <copumpkin> so
08:29:22 <nand`> ah, he left
08:29:23 <copumpkin> return undefined >>= const ()
08:29:24 <edwardk> compare: "fmap (const 12) . fmap error" to  "fmap const 12 . error"
08:29:33 <edwardk> tibbe: that is the culprit
08:29:57 <tibbe> I see
08:30:03 <copumpkin> also, I beg parser writers to make ADTs of parse errors, rather than strings/text :D
08:30:06 <edwardk> http://bb10.com/haskell-libraries/2011-02/msg00098.html
08:30:11 * copumpkin begs again
08:30:23 <copumpkin> strings suck
08:30:26 <edwardk> i think i mentioned this last time you brought up the topic, and then I promptly forgot it again ;)
08:31:10 <edwardk> (this is also why i don't have strict lenses)
08:31:32 <tibbe> copumpkin: I've been thinking of making it an ADT
08:31:48 <copumpkin> yay!
08:32:01 <copumpkin> then a separate layer converting that ADT to a human-readable parse error is good
08:32:01 <edwardk> copumpkin: hrmm i used to have more structure in the trifecta errors internally, but they got dumbed down to text ;)
08:32:13 <edwardk> it was a huge pain in the ass to work with in ADT form
08:32:15 <copumpkin> edwardk: http://nooooooooooooooo.com/
08:32:17 <ski> copumpkin : seconded
08:32:24 <copumpkin> edwardk: how come?
08:32:36 <applicative> copumpkin:  parsec has a special error type, but I was just suffering from its lack of a NFData instance
08:32:51 <startling> copumpkin, just write a parser for the error
08:32:54 <nand`> What's NFData again?
08:32:57 * copumpkin stabs startling 
08:33:01 <copumpkin> nand`: supports deepseq
08:33:02 <nand`> startling: ba dum tss
08:33:08 <edwardk> because you now have to deal with all of the random sources of internal parse errors, like 'many empty', i have a bunch of constructors to deal with plus your user constructors, it clutters every signature
08:33:30 <applicative> nand`: so you can use deepseq, and thus Criterion, in my present case
08:33:35 <copumpkin> edwardk: :(
08:33:55 <copumpkin> I think it's good to enumerate possible kinds of parse errors, and it's language-independent, and so on :P
08:34:05 <copumpkin> and MOAR COMPOASABL
08:34:07 * fryguybob writes a parser for parse errors that has its own errors as an ADT.
08:34:30 <copumpkin> but then again, it's easy to preach about code you don't have to write ;)
08:34:34 <geekosaur> houroboros?
08:36:33 * ski wonders whether "polymorphic variants" (lightweight variant/sum types) would be nice here
08:37:20 <startling> but yeah, I've tried writing a parser with error trees too
08:37:44 <tibbe> copumpkin: one issue is that I need to represent fail "foo" as a constructor
08:37:49 <tibbe> copumpkin: as the user might use that
08:38:03 <startling> in dynamic languages, you can usually inspect things to get decent error messages. not really true (or sane) in haskell
08:38:37 <copumpkin> tibbe: sure
08:39:05 <tibbe> copumpkin: that makes the ADT a bit ugly
08:39:23 <tibbe> data Error = SaneOpt1 | SaneOpt2 | BatshitCrazyUserString String
08:39:38 <copumpkin> a little more ugly, but not terrible. Ideally one would parametrize it by another user-generated error type, which they can provide values of in a parser combinator
08:39:54 <copumpkin> so you'd have two sources of user errors, fail, cause Monad sucks, and UserError which is polymoprhic
08:39:57 <copumpkin> morphic
08:42:46 <byorgey> polymoprhic comes from the greek "poly" (= many) + "mop" (= hairdo) + "rheo" (= to flow) = having long, flowing hair
08:44:05 <afgho> hmm i don't get how i am supposed to continually increment a value which i pass to a function in a loop
08:44:36 <startling> afgho, what kind of function is it?
08:44:40 <DMcGill> afgho: map (\i -> ...) [1..n]
08:44:45 <nand`> (are you thinking of iterate :: (a -> a) -> a -> [a] ?)
08:44:54 <DMcGill> or perhaps a fold
08:44:55 <startling> foldr might be useful, too
08:45:57 * applicative admires byorgey 's unusually learned specious etymology 
08:46:20 <ski> > let fromTo lo hi | lo > hi = [] | otherwise = lo : fromTo (lo + 1) hi in fromTo 3 8  -- incrementing in a loop
08:46:20 * applicative didnt mean 'unusually learned for byorgey'
08:46:22 <lambdabot>   [3,4,5,6,7,8]
08:46:28 <byorgey> =)
08:46:41 <nand`> applicative: oh..
08:46:45 <afgho> well i have a server running, each time a client send a message to the server, the server is supposed to compute something based on an index
08:47:01 <afgho> i just want to increment that index continually each time a client send a message
08:47:15 <afgho> however i don't get how to do it properly in haskell
08:47:49 <ski> if the server is a recursive loop, add an argument to it to keep count. increment it in the recursive call, after getting a message
08:49:41 <afgho> ah thank, was obvious
08:54:47 <tibbe> traverse is too lazy :(
08:55:12 <tibbe> giving me a Vector full of huge chunks
09:08:49 <tibbe> edwardk: ack, it's not even possible to write a strict traverse as the applicative can't look at the result
09:08:52 <tibbe> monads here we go
09:09:50 <atriq> Best way to take a slice of a Seq?
09:11:15 <edwardk> yep
09:11:41 <edwardk> tibbe: https://github.com/ekmett/lens/blob/master/src/Control/Lens/Combinators.hs#L21
09:12:02 <luqui> is there a thing of kind * -> Constraint  which matches all values.  A sort of  'Const ()'
09:12:19 <edwardk> luqui: i usually just write class Trivial a; instance Trivial a
09:12:21 <edwardk> and use that
09:12:27 <luqui> okey
09:13:54 <tibbe> edwardk: cons_f x ys = (:) <$!> f x <*> ys
09:14:05 <tibbe> edwardk: would that make the list head strict?
09:14:26 <edwardk> hrmm. i have to admit i never tried combining it with <*> i'd have to work through it
09:14:38 <tibbe> edwardk: alright, same here. thought that you might
09:14:44 <edwardk> but yes, i think it would
09:14:52 <tibbe> edwardk: since I need mapM' anyway I might just write that directly
09:21:08 <mightybyte_> Is hackage really slow for anyone?
09:21:18 <nand`> I usually call it class Empty
09:21:24 <nand`> but same thing really
09:28:19 <tac> How do I convert a String to a bytestring?
09:28:51 <quicksilver> pack
09:28:58 <c_wraith> what encoding?
09:28:59 <quicksilver> or choose and encoding and use that
09:28:59 <atriq> Data.Bytestring.Char8.pack
09:29:09 <tac> ty
09:29:17 <luqui> where is the canonical impl of newtype (:*:) f g x = (f x, g x)  ?
09:29:17 <k00mi> tac: http://www.haskell.org/hoogle/?hoogle=String+-%3e+ByteString
09:29:19 <c_wraith> that only works if the string is only ascii
09:29:39 <luqui> iirc there used to be such a thing in category-extras, but the organization of that module seems to have changed
09:29:52 * ski . o O ( "(f x, g \x)" ? )
09:30:43 <atriq> luqui, Data.Functor.Product?
09:30:58 <c_wraith> tac: if there's any chance of non-ascii characters being in the string, you should use a conversion that's encoding-aware.  I prefer utf-8, via Text.
09:31:23 <tac> c_wraith: I'm just looking for something quick and dirty right now, but thank you for the heads up
09:31:41 <tac> I am realizing more and more I only know haskell for the type system, and I don't actually know how to program anything in it :)
09:32:22 <tac> (and GHC still hasn't managed to make it so CTRL+c works for command line applications :[   )
09:33:07 <tac> Someone should come out with a new command prompt for windows where you can select "terminate program" from the menu or something
09:39:14 <latermuse> tac: control-c works for me in linux
09:39:27 <latermuse> tac: linux ghc i mean
09:40:47 <tac> latermuse: In Windows, CTRL+c in GHC-compiled applications or GHCi tends to be really unreliable
09:41:42 <latermuse> :tac are there any workarounds?
09:41:47 <latermuse> tac:
09:41:50 <latermuse> haha ;)
09:44:37 * hackagebot RSA 1.2.2.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.2.2.0 (AdamWick)
09:45:05 <edwardk> luqui: http://hackage.haskell.org/packages/archive/transformers/0.2.2.0/doc/html/Data-Functor-Product.html
09:48:56 <mm_freak> tac: did you try "+RTS --install-signal-handlers=no"?
09:49:14 <mm_freak> if that works you can have that RTS option by default via a GHC flag, whose name i always forget
09:49:42 <geekosaur> -with-rtsopts="..."
09:50:24 <bgamari> edwardk, might be nice to update your answer to http://stackoverflow.com/questions/5767129 to discuss your lens package
09:51:15 <FireFly> Are all MonadPlus'es Monoids?  it seems to me that a MonadPlus is basically a Monad that is also a Monoid
09:52:34 <tac> mm_freak: oh, interesting
09:52:43 <geekosaur> monoids but not Monoids; there's at least one case where MonadPlus is not merely a monadic version of the Monoid instance (Maybe)
09:52:45 <tac> so ghc is actually helping to make it difficult to work with :P
09:53:50 <atriq> FireFly, in principle, yes, but actually no
09:54:03 <edwardk> bgamari: it mentions it briefly at the bottom
09:54:13 <edwardk> under 'van Laarhoven lenses'
09:54:36 <bgamari> edwardk, ahh, yes. I missed that.
09:54:42 <atriq> Although instance MonadPlus m => Monoid (WrappedMonad m a) would make sense
09:54:50 <bgamari> edwardk, You consider data-lens to be deprecated, yes?
09:54:57 <edwardk> more or less
09:55:11 <edwardk> i've been working with anyone who was using data-lens to help them switch to lens
09:55:47 <edwardk> snap should be switching in 0.10, byorgey and mgsloan have been talking about some lenses for diagrams, etc.
09:56:14 <mm_freak> tac: GHC usually makes this stuff easy, but that can fail in weird environments like windows =)
09:57:25 <tac> mm_freak: You'd think having SPJ on the team they'd fix that kind of usability issue early on
09:57:33 <tac> But your work around should do the trick
09:59:07 <tac> mm_freak: geekosaur: Do you guys know if you can set "+RTS --install-signal-handlers=no" as a personal default in GHC?
09:59:15 <tac> (like a .ghcrc or something like that?)
09:59:18 <Leif_Bork> Hi, I get unknown symbols when I run unit tests of a library of mine. I've tried running cabal clean. What could be wrong?
09:59:19 <tomboy64> is there a simple way to see where a specific function was imported from in an arbitrary file? e.g. in a bigger project?
09:59:36 <geekosaur> export GHCRTS=--install-signal-handlers=no
09:59:38 <geekosaur> BUT
09:59:54 <geekosaur> there is no way to make -rtsopts a default, which would probably be necessary
09:59:58 <dcoutts> Leif_Bork: most likely you forgot to list all the modules in the .cabal file for your lib
10:00:10 <Leif_Bork> dcoutts: Aah thank you!
10:03:41 <tac> hm, ghc is saying "unrecognized flags: -with-rtsops"
10:05:08 <geekosaur> what version of ghc?
10:05:24 <geekosaur> (if you;re on debian stable with 6.whatever then you probably lose)
10:06:07 * doliator glares at the dolioid 
10:06:11 <jmcarthur> tac: if it's an old ghc, you don't even need that flag because it's the default
10:06:40 <geekosaur> jmcarthur, that's -rtsopts, they're asking about -with-rtsopts which specifies default rts options
10:06:40 <tac> hmm
10:06:44 <jmcarthur> oh!
10:06:47 <atriq> For some reason I was thinking about translating the lens library to Latin today
10:06:50 <jmcarthur> tac: ignore me
10:06:56 <geekosaur> and in older ghc the only ay to do it was a custom wrapper program :(
10:07:01 <jmcarthur> right
10:07:10 <saml> can i help you?
10:07:15 <edwardk> atriq: pig latin perhaps
10:07:16 <jmcarthur> well, it doesn't have to be a wrapper, exactly
10:07:36 <edwardk> Enslay s t a b
10:07:37 <jmcarthur> you could also have the program exec itself with different flags
10:07:45 <bfrog> does haskell have something akin to erlang's actors and supervision tree ideas?
10:08:01 <jmcarthur> bfrog: check out cloud haskell. it's new, but promising
10:08:02 <rwbarton> Enslay a b s t w a y
10:08:03 <edwardk> that works disturbingly well
10:08:06 <rwbarton> oops, -w
10:08:26 <bfrog> been using erlang for a couple of years now, but kind of interested ti try out haskell a bit
10:08:35 <rwbarton> is there any lens-y thing for [a] -> Int -> Maybe a?
10:08:53 <edwardk> Enslay say tay away bay
10:08:53 <jmcarthur> bfrog: erlangy stuff hasn't been haskell "killer app" so far, but who knows?
10:09:09 <simpson> One doesn't need a killer application or niche to become popular.
10:09:11 <jmcarthur> bfrog: haskell is very nice for undistributed concurrency already, though
10:09:24 <edwardk> :t iwhereOf (==5)
10:09:25 <jmcarthur> simpson: no claims to the contrary from me
10:09:26 <lambdabot>     Couldn't match expected type `Overloaded (Index i0) f0 s0 t0 a0 a0'
10:09:26 <lambdabot>                 with actual type `a1 -> Bool'
10:09:26 <lambdabot>     In the first argument of `iwhereOf', namely `(== 5)'
10:09:29 <edwardk> :t iwhereOf traverse (==5)
10:09:31 <lambdabot>     Couldn't match expected type `Overloaded (Index i0) f0 s0 t0 a0 a0'
10:09:31 <lambdabot>                 with actual type `(a1 -> f1 b0) -> t1 a1 -> f1 (t1 b0)'
10:09:31 <lambdabot>     In the first argument of `iwhereOf', namely `traverse'
10:09:36 <edwardk> :t iwhereOf itraversed (==5)
10:09:38 <lambdabot> (Eq i, Num i, Applicative f, TraversableWithIndex i f1, Indexed i k) => Overloaded k f (f1 a) (f1 a) a a
10:09:57 <rwbarton> > "abc" ^. iwhereOf itraversed (==1)
10:09:59 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
10:09:59 <lambdabot>    arising from a use o...
10:10:19 <edwardk> :t [1,2,3,4,5,6]^? iwhereOf itraversed (==5)
10:10:22 <lambdabot> Num t => Maybe t
10:10:25 <edwardk> [1,2,3,4,5,6]^? iwhereOf itraversed (==5)
10:10:34 <edwardk> > [1,2,3,4,5,6]^? iwhereOf itraversed (==5)
10:10:36 <lambdabot>   Just 6
10:10:44 <edwardk> its a bit convoluted ;)
10:11:05 <edwardk> there is 'elementOf' and 'element', but they lie and assume the element is present
10:11:15 <edwardk> :t elementOf
10:11:16 <lambdabot> Functor f => LensLike (Control.Lens.Internal.Bazaar a a) s t a a -> Int -> LensLike f s t a a
10:11:43 <rwbarton> i think this is all a bit overkill for me
10:11:46 <edwardk> > ("hello","world")^.elementOf both 0
10:11:47 <lambdabot>   "hello"
10:11:51 <edwardk> > ("hello","world")^.elementOf both 1
10:11:53 <lambdabot>   "world"
10:12:05 <atriq> lens is overkill.
10:12:08 <atriq> Haskell is overkill.
10:12:10 <simpson> > ("hi", "there!") ^. elementOf both 2
10:12:12 <lambdabot>   "*Exception: Prelude.(!!): index too large
10:12:21 <simpson> Mm. That's quite the lie.
10:12:22 <edwardk> iwhereOf and itraversed are pretty obscure ;)
10:12:34 <edwardk> simpson: its documented as partial in the haddocks
10:12:34 <atriq> Haskell resurrected a practically unused concept from an obscure branch of category theory just to do IO!
10:12:49 <simpson> edwardk: Good call. :3
10:12:50 <edwardk> atriq: monads are hardly obscure in category theory
10:12:50 <invariant> I was able to compile 33000 lines of code and run a full application in pascal in 2.4 seconds. With GHC, I cannot even compile one module of Pandoc in that time. What's so special about Haskell that you still want to use it despite these deficiencies?
10:13:00 <atriq> edwardk, perhaps!
10:13:14 <simpson> invariant: "Which flavor of Pascal?"
10:13:18 <atriq> But category theory is in of itself obscure
10:13:28 <invariant> simpson, free pascal
10:13:31 <atriq> Hence, while completely wrong in every way, my statement is true
10:13:37 <applicative> invariant:  the individual modules take that long?
10:13:42 <simpson> invariant: I'll take it! :3
10:13:55 <invariant> simpson, what do you mean?
10:14:08 <atriq> He means that's ridiculously fast
10:14:27 <invariant> applicative, installing an IDE for Pascal takes one download of 100MB containing everything.
10:14:33 <simpson> invariant: It's a joke. Treat "free" as an adjective.
10:14:57 <applicative> invariant:  hugs would load modules much more quickly ...
10:14:59 <invariant> applicative, for Haskell, I took EclipseFP, and its installer said it would install some modules automatically, which it didn't.
10:15:27 * applicative doesn't gnow anything about ExclipseFP 
10:15:35 <invariant> applicative, then I installed the components manually, which took 20 minutes. Finally, I ran EclipseFP again, and indeed, I was able to make it crash within 4 minutes.
10:15:57 <simpson> invariant: I should point out, BTW, that Pascal is a particularly curious thing to compare with, since it compiles in a single pass (!!) and is also ancient and difficult to read.
10:16:01 <invariant> applicative, meanwhile EclipseFP doesn't have any features worth mentioning.
10:16:13 <simpson> You're comparing last century's plantains and this century's bananas.
10:16:14 <applicative> invariant: I think you need Eclipse knowledge *and* a fair amount of GHC/cabal knowledge
10:16:31 <invariant> applicative, I got it to work.
10:16:32 <dna_> :r
10:16:35 <simpson> Also, there's actually Eclipse for Haskell? That sounds unfun.
10:16:37 <t7> su only lets me type one letter and then starts echoing back my password and give me auth failure
10:16:42 <applicative> invariant:  I'm pretty sure it has better support than what I use :)
10:16:43 <invariant> applicative, except it just doesn't work like it should.
10:17:06 <invariant> simpson, what are plantains?
10:17:07 <applicative> invariant: yes, I would advise against it unless you become genuinely interested in haskell
10:17:19 <invariant> applicative, against what?
10:17:22 <simpson> invariant: They are a relative of bananas.
10:17:23 <applicative> invariant: I mean, against EclipseFP.
10:18:43 <applicative> invariant: for some reason these Haskell people are generally against ide's unless you count emacs as one.
10:18:55 <Ralith> people other than java programmers use eclipse?
10:18:59 <simpson> Heh, "these Haskell people."
10:19:02 <simpson> I'm a Python person!
10:19:24 <simpson> And a C person. Just not a Java person.
10:20:00 <mcstar> make me one with everything!
10:20:09 <c_wraith> I tried eclipseFP once.  I couldn't figure out how to open a .cabal file as a project, and gave up.
10:20:17 <applicative> simpson if you use vim or emacs I'd go for the haskell machinery with one of them, people are always on here to help with details.
10:20:17 <Ralith> invariant: I was able to compile ∞ lines of opcodes typed directly into a hex editor in zero time. With $COMPILER, I cannot even compile one $COMPILATION_UNIT in that time. What's so special about compilers?
10:20:21 <c_wraith> That seems like the minimal thing that needs to be obvious
10:20:42 <applicative> has anyone used whatzit, Sublime Text with haskell?
10:20:48 <simpson> applicative: I figured out syntax highlighting for Haskell in vim, and that's all that I need. Oh, and indentation, but the filetype plugin appears to have that covered.
10:21:50 <Boreeas> I can't really work with emacs for anything but simple text editing. vim is right out.
10:22:55 <mcstar> you start with priting out reference cards
10:23:04 <mcstar> if you dont do that, you dont really want to learna either
10:23:07 <mcstar> -a
10:23:39 <Boreeas> I don't want to need reference cards to use a text editor
10:23:47 <mcstar> you dont need to
10:23:53 <mcstar> thats why you want to learn them
10:24:00 <jmcarthur> i'm against IDEs only insofar as every IDE i've used has sucked
10:24:01 <Boreeas> For now, I'll stay with Geany for code editing
10:24:01 <mcstar> and when the time comes, dispose of them
10:24:27 <t7> i only know like 5 commands for vim. seems to be enough
10:24:33 <applicative> invariant:  Free Pascal does manage to outdo haskell on one benchmark on the idiotic shootout.  http://shootout.alioth.debian.org/u64q/benchmark.php?test=all&lang=fpascal&lang2=ghc
10:24:44 <mcstar> what?
10:24:52 <mcstar> is Pascal incarcerated again?
10:24:58 <jmcarthur> it never went away
10:25:06 <Boreeas> mcstar: I was able to figure out every function of my IDE without reference cards.
10:25:07 <mcstar> everyone wants to free Pascal tonight..
10:25:30 <applicative> man this fannkuch-redux is pretty dreadful
10:26:11 <mcstar> Boreeas: did you use a menu with a lot of labeled items?
10:26:22 <mcstar> that is a built in reference card
10:26:51 <mcstar> emacs has a menu too, but why use it, when you can do better...
10:26:54 <Boreeas> Which is a lot nice than having physical notecards or notecards in another program
10:26:56 <mcstar> idk about vim
10:27:16 <mcstar> no, you PRINT them
10:27:20 <mcstar> physically
10:27:22 <mcstar> on a paper
10:27:30 <Boreeas> "[19:26:36]	Boreeas	Which is a lot nice than having physical notecards..."
10:28:01 <mcstar> and no, a menu is not nicer
10:28:08 <mcstar> you have to move the mouse and search in it
10:28:18 <mcstar> while you can quickly glance over a reference card
10:28:26 <mcstar> even mark it the way you want it
10:28:43 <mcstar> if you dont want power, then dont use emacs/vim, idc
10:28:45 <Boreeas> I do not have to scan through X items to find the one I want, though
10:29:24 <mcstar> lets just say, im using emacs right now on a remote machine, and i can do ANYTHING with it
10:29:34 <mcstar> edit code, compile code, open up terminals
10:29:37 <jmcarthur> menus are useful for discovering functionality you don't know about, but not for referring to all the time
10:29:58 <jmcarthur> and even then, a lot of functionality simply isn't in menus at all
10:30:53 * applicative finally noticed the package for getting TH to write Unbox instances; so much for his scheme of learning a bit of TH by writing one
10:31:23 <jmcarthur> it's a lovely package :)
10:32:06 <applicative> yeah? I have tried it a couple of times now, and was worried I was implicitly advising it on StackOverflow
10:32:40 <jmcarthur> it generates fine code at least, even INLINE pragmas
10:33:49 <mapf> that is recommended introduction to category theory for non-matematician?
10:34:09 <c_wraith> hang out in this channel for a few months
10:34:23 <c_wraith> works every time
10:34:28 <applicative> mapf Lawvere of course
10:35:30 * applicative means his goofy textbook.  No monads in it, though.  Maybe Awodey?  He claims to write also for non-mathematicians.
10:35:43 <mapf> c_wraith: well, it's too passive learning)
10:36:02 <mapf> applicative: thanks
10:38:17 <applicative> @google awodey category theory pdf
10:38:33 <lambdabot> Plugin `search' failed with: thread killed
10:38:45 <applicative> there have been copies of the manuscript version floating about.
10:40:36 <applicative> jmcarthur:  does the calling of the TH gods look right here? http://stackoverflow.com/questions/13409150/haskell-converting-from-list-to-data-vector/13421942#13421942
10:43:40 <ski> mapf : Lawvere's and Schanuel's "Conceptual Mathematics" is nice and simple
10:44:01 <ski> (Kindergarten examples)
10:44:24 <applicative> I got a copy of the second edition recently, which I think is much better than the first.
10:45:20 <mcstar> also, if invariant cares, he/she can give ocaml a try, it is known for very fast compilation
10:45:27 <applicative> the choice of examples is strange, inevitably, but interesting.  Awodey devotes an awful lot of attention to partial orders which arent exactly thriling
10:46:38 <applicative> mcstar after cabal install yesod-whatever, he was doing the most immense build available with a single 'cabal install ...' instruction
10:47:15 <sclv> i like the lawvere book for how it encourages you to think, even if it only covers a small amount of material
10:47:16 <mcstar> i see
10:48:09 <mapf> ski: thanks.
10:49:26 <invariant> applicative, but in the area of working programs that people actually use, which is the metric the real-world cares about, Pascal wins.
10:52:13 <simpson> invariant: Except when Perl, Python, Ruby, Java, and C win, of course.
10:52:24 <mcstar> or when haskell does
10:52:26 <simpson> And C#, Obj-C, C++ (!!!!), etc.
10:52:44 <invariant> simpson, C is fundamentally flawed.
10:52:49 <simpson> invariant: Go on.
10:53:00 <invariant> simpson, (because of its include semantics)
10:53:12 <simpson> invariant: 'k.
10:53:18 <mcstar> i thought, it sucked because of curly braces
10:53:35 <simpson> And yet we are all running on kernels composed of C right now.
10:54:39 * hackagebot ReadArgs 1.2.1 - Simple command line argument parsing  http://hackage.haskell.org/package/ReadArgs-1.2.1 (NoahEasterly)
10:54:40 <invariant> simpson, only because computers are relatively fast.
10:54:47 * applicative sees that pascal is approach the 1% of Ruby mark under the 'questions tagged x' heading on SO
10:54:56 <Dodek> funny how stuff is fundamentally flawed, and world doesn't care.
10:54:58 <applicative> appp
10:55:05 <applicative> approaching
10:55:11 <invariant> applicative, there is no need to ask a question about something that works.
10:55:23 <simpson> invariant: "If something is wrong, and it works, it's not wrong."
10:55:26 <neutrino_> hi
10:55:35 <applicative> hey, that's what we say :)
10:55:39 <neutrino_> is it only me or does writing code in pointfree style make compilation much slower?
10:55:52 <simpson> neutrino_: I think it might just be you. Do you have a specific example?
10:56:00 <Boreeas> simpson: Code can be "wrong" without being wrong :P
10:56:11 <neutrino_> hmm
10:56:23 <neutrino_> well i was just doing some refactoring and the compiler got real slow
10:56:26 <nand`> Ralith: I have a working Haskell -> Haskell compiler that's fairly fast
10:56:28 <mapf> neutrino_: there are no reasons
10:56:30 <neutrino_> the only refactoring i did was to make things pointfree
10:56:50 <neutrino_> maybe it's some os process, let me check..
10:56:57 <simpson> Boreeas: It could be a non-optimal or non-perfect solution, and there could be better solutions, but that doesn't mean that the given one is wrong.
10:57:01 <invariant> simpson, don't you think it is wrong in the Haskell ecosystem that there is no fast, but simple Haskelll compiler?
10:57:15 <Ralith> nand`: I wonder what you'd get if you built hardware for haskell...
10:57:17 <neutrino_> ghc is fast and simple
10:57:25 <simpson> invariant: Can we add in the third dimension of "Gives useful error messages?"
10:57:27 <neutrino_> Ralith: a quantum computer
10:57:38 <simpson> invariant: And the fourth dimension of "Emits correct code?"
10:57:40 <invariant> neutrino_, ghc is slow and complex.
10:57:41 <jmcarthur> applicative: looks reasonable to me
10:57:50 <applicative> invariant:  the Glorious Glasgow Compiler is rightly so called
10:57:52 <neutrino_> invariant: it is also fast and simple.
10:57:52 <invariant> neutrino_, ask the people that wrote it.
10:58:01 <neutrino_> dunno man
10:58:05 <applicative>   (Haskell Compiler)
10:58:07 <neutrino_> i compile things and it works fast
10:58:19 <mapf> g++ is slow, not ghc
10:58:32 <invariant> neutrino_, how large are these things you speak of?
10:58:35 <mcstar> 'is rightly called so'
10:58:37 <neutrino_> not large
10:58:45 <neutrino_> if you use a large project it's obvious it'll be slow to compile
10:58:48 <mcstar> no?
10:58:54 <invariant> neutrino_, that's not obvious.
10:59:01 <nand`> Can this discussion about pascal and whatnot be moved to #haskell-blah or something?
10:59:07 <invariant> neutrino_, like I said: 33000 lines in 2.4 seconds.
10:59:08 <tibbe> bgamari: I have fixed the issue
10:59:13 <neutrino_> of what
10:59:15 <tibbe> bgamari: will be fixed in the next release
10:59:16 <nand`> it's getting a bit noisy in here
10:59:31 <neutrino_> anyways, i wanted to ask if anyone here has used HaRe
10:59:32 <simpson> invariant: Anyway, did you just come in to argue?
10:59:38 <nand`> simpson: looks like it
10:59:52 <mapf> ghc comes really slow when you turn on TH, that's true
11:00:01 <tibbe> bgamari: the memory usage is still high (100M at peak) but it's much better
11:00:14 <invariant> mapf, how many lines does GHC do per second?
11:00:15 <applicative> jmcarthur: thanks .  I was irked he was importing Data.Vector not Data.Vector.Unboxed, and got slightly out of control
11:00:21 <simpson> invariant: Mu.
11:00:42 <mapf> invariant: i don't know. maybe 10-50 average
11:00:43 <nand`> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
11:00:43 <invariant> I think it doesn't get much more than about 1000.
11:00:44 <tibbe> bgamari: the issue is now that at some point we have the whole CSV files in memory as a Vector (Vector ByteString), which isn't super efficient as each ByteString and Vector value has a fixed overhead
11:00:44 <lambdabot> (Functor f2, Functor f1, Functor f) => (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b))
11:00:53 <simpson> invariant: Again, you're using a metric that only works for single-pass, and trying to compare it to a non-single-pass language.
11:01:00 <nand`> oh, I forgot how many fmaps I needed to make it take absurdly long
11:01:04 <mapf> with TH
11:01:16 <invariant> simpson, both are computer languages, and both are used to write real-world programs.
11:01:20 <nand`> :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
11:01:40 <jmcarthur> nand`: you broke lambdabot :(
11:01:42 <nand`> I.. oh
11:01:44 <nand`> that's unfortunate
11:01:46 <lambdabot> thread killed
11:01:49 <nand`> there we go
11:01:50 <jmcarthur> yay!
11:02:07 <simpson> invariant: Okay! Let's add in FORTH, shall we? FORTHs beat the crap out of Pascal in compile times.
11:02:08 <mapf> :t id id id id id id  id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id id
11:02:14 <applicative> see, ghc is so slow, it cant even get a type signature to you in time
11:02:17 <lambdabot> a -> a
11:02:18 <nand`> lambdabot must be running on a slow machine
11:02:26 <simpson> invariant: FORTH is a serious, real-world language that has been used to implement serious systems.
11:02:27 <mcstar> no
11:02:28 <nand`> on my machine, 32 fmaps type checks in like 2 seconds
11:02:41 <mapf> not so long ago many id's cause ghc panic or something
11:02:47 <mapf> *long tim
11:02:48 <rwbarton> lambdabot times out on stuff like 1 + 1
11:02:50 <simpson> invariant: And it is faster than just about anything. Additionally, it comes with an interpreter and compiler, both of which can be extended at runtime.
11:02:51 <mapf> *time
11:02:56 <nand`> > 1 + 1
11:03:00 <geekosaur> it's on a cheap vps, I think
11:03:00 <lambdabot>   mueval-core: Time limit exceeded
11:03:04 <nand`> rwbarton: .. wow
11:03:08 <rwbarton> heh
11:03:11 <nand`> I totally didn't expect that
11:03:20 <jerojasro> > 1.0 + 1.0
11:03:21 <rwbarton> @botsnack
11:03:22 <lambdabot> :)
11:03:24 <lambdabot>   mueval-core: Time limit exceeded
11:03:26 <applicative> two seconds for (Functor f, Functor f1, Functor f2) =>     (a -> b) -> f (f1 (f2 a)) -> f (f1 (f2 b)) ??
11:03:31 <jerojasro> huh?
11:03:36 <invariant> simpson, except it comes with nowhere near the tools which are in Lazarus IDE.
11:03:42 <Eduard_Munteanu> @undefine
11:03:44 <Eduard_Munteanu> > 1 + 1
11:03:45 <rwbarton> maybe it is still calculating :t fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
11:03:46 <invariant> simpson, there is no mature free Forth system.
11:03:48 <lambdabot>   2
11:03:50 <simpson> invariant: Factor.
11:03:55 <invariant> simpson, that's not Forth.
11:04:06 <nand`> rwbarton: probably
11:04:22 <simpson> invariant: FORTH is not a single language; it is an ever-evolving meta-system of languages that are hand-crafted for the task at hand.
11:04:23 <nand`> Eduard_Munteanu: interesting
11:04:24 <invariant> simpson, and that only proves me point; fast compilation time has a positive effect on development results.
11:04:27 <applicative> doesnt asm compile pretty quickly
11:04:29 <mcstar> if someone's here to troll, then someone's here to troll, simple fact of life
11:04:34 <simpson> invariant: Go read some of Chuck Moore's writings on FORTH.
11:04:38 <invariant> simpson, Forth doesn't have a garbage collector.
11:04:51 <simpson> invariant: Because FORTH has no garbage. >:3
11:04:54 <invariant> simpson, in Factor it's integrated and implemented in C.
11:05:03 <invariant> simpson, so Factor is most definitely not Forth.
11:05:03 <simpson> invariant: Factor's written in Factor. >:3
11:05:13 <Nafai> simpson: Chuck Moore certain has novel and interesting ideas
11:05:19 <nand`> applicative: depends on the dialect I think
11:05:33 <invariant> simpson, I know about Forth and even ColorForth.
11:05:45 <simpson> invariant: Anyway, you're clearly getting mad, so I'll leave you alone. I wanna go eat lunch now. :3
11:05:48 <mcstar> also, maybe they didnt tell you, but you can develop code in ghci
11:05:55 <invariant> simpson, mad?
11:06:00 <simpson> Super-mad.
11:06:02 <mcstar> you dont have to compile 33k lines of code, to try out your app
11:06:28 <mcstar> also, try a lisp, if you want incremental compilation
11:07:02 <invariant> At which point would you consider GHC to be too slow then?
11:07:03 <neutrino_> $ for i in {1..50}; do echo $i; f=$(yes "fmap" | head -n $i); echo $f; lambdabot -e "@type $f" 2>/dev/null; done
11:07:21 <neutrino_> i'm sad to disappoint you rwbarton but they all come out with the same type.
11:07:33 <rwbarton> i thought it cycled
11:07:38 <neutrino_> nope
11:07:51 <neutrino_> maybe we want fmap . fmap . fmap or something?
11:07:59 <rwbarton> well that certainly will grow
11:08:09 <applicative> @type fmap.fmap.fmap
11:08:17 <applicative> ha
11:08:23 <rwbarton> it looks like you are only passing one fmap on the @type line
11:08:39 <lambdabot> thread killed
11:09:14 <applicative> hm, same type as fmap ^ 32
11:09:16 <jmcarthur> fmap fmap fmap fmap fmap fmap fmap fmap = fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap fmap
11:09:22 <rwbarton> try "@type $(echo $f)"
11:09:33 <applicative> its obvious when you think about it
11:10:08 <rwbarton> lambdabot's @type plugin ignores input after the first line
11:13:32 <Jello_Raptor> what should I call a function " F :: (a -> b) -> ( (a,c) -> (b,c)) " that just creates a function that'll be apllied to the first element in a pair?
11:13:57 <neutrino_> rwbarton: why would you do "@type $(echo $f)"?
11:13:57 <Ralith> :t mapFst
11:14:09 <neutrino_> rwbarton: it's the same as "@type $f"
11:14:13 <lambdabot> thread killed
11:14:19 <invariant> Jello_Raptor, bogus?
11:14:37 <jmcarthur> :t first
11:14:37 <Jello_Raptor> Ralith: thanks (note: this is for oCaml, you guys are just more likely to know of a good name for it)
11:14:38 <JavaSucksMan> Does anybody now how to change the number of liones remembered in ghci's history?
11:14:41 <Ralith> Jello_Raptor: there are at least two implementations of what you probably mean
11:14:43 <lambdabot> Arrow a => a b c -> a (b, d) (c, d)
11:14:48 <Ralith> (in the platform libraries)
11:14:59 <jmcarthur> Jello_Raptor: it's the same as Control.Arrow.first
11:15:00 <JavaSucksMan> i mean lines
11:15:03 <applicative> Jello_Raptor: Control.Arrow.first I guess that
11:15:09 <applicative> has been made plain
11:15:14 <rwbarton> neutrino_: did you try it? it's not the same here
11:15:23 <Ralith> oh, ocaml
11:15:35 <Jello_Raptor> Ralith: I don't happen to be working in Haskell :P just needed a good name for that function, and you were the lot to ask
11:15:44 <rwbarton> because in "echo $f" the multiple lines of $f get passed as separate arguments to echo, which then pastes them back together with spaces
11:15:49 <Ralith> Jello_Raptor: mapFst is a name based on haskell conventions, of course.
11:16:00 <neutrino_> rwbarton: 1 sec
11:16:09 <jmcarthur> Jello_Raptor: in ocaml i think it would probably best be named something like map_first
11:16:19 <bgamari> tibbe, Thanks!
11:17:03 <Jello_Raptor> Ralith: jmcarthur: i've written a significant chunk of prelude just so i can code in oCaml without losing my mind, i'm pretty much already following haskell conventions whereever possible.
11:17:10 <tibbe> bgamari: the streaming interface will be even better in terms of space usage, at the cost of some inconvenience
11:17:27 <JavaSucksMan> Sure, everybody wants to explain applicative functors, but ask a simple question, and ......
11:17:28 <bgamari> tibbe, Might be nice to try though
11:17:34 <Jello_Raptor> (class project, aren't allowed to use any but two core oCaml libraries)
11:17:40 <Ralith> ah.
11:17:49 <Ralith> makes sense, then
11:18:05 <bgamari> tibbe, space usage now still scales linearly with number of records?
11:18:10 <applicative> >  _1 %~ (+10) $ (1,2)
11:18:18 <lambdabot>   mueval: ExitFailure 1
11:18:18 <lambdabot>  mueval: Prelude.undefined
11:18:23 <applicative> ??!
11:18:28 <Ralith> man lambdabot is really broken
11:18:35 <jmcarthur> Jello_Raptor: have you looked into batteries or core?
11:18:47 <Ralith> is this normal or should we ping Cale
11:18:50 <hpaste> nand` pasted “30,000 lines of Haskell” at http://hpaste.org/77824
11:18:59 <chrisirc> Why is it not an error when return'ing something in a monad although the context doesn't ask for a value? e.g. do { return 1; put 2 }. If I write a monad library, should I allow that? (Currently I'm giving an error as I thought that's natural and helps error detection.)
11:19:01 <jmcarthur> Ralith: nand` broke it :(
11:19:03 <bgamari> I guess I'll just try it
11:19:27 <tibbe> bgamari: yes, it did before too, but with a bad constant
11:19:28 <bgamari> tibbe, Forget the last question, of course it does. Not enough sleep
11:19:29 <jmcarthur> @undo do { return 1; put 2 }
11:19:29 <lambdabot> return 1 >> put 2
11:19:32 * Ralith heckles nand` 
11:19:36 <jmcarthur> chrisirc: ^^ that's why
11:19:39 <Jello_Raptor> jmcarthur: yes, we're not allowed anything but pervaisives and String, and it's a parsing/interpreter project. I figure I might as well just do it all in a haskelly way.
11:19:40 <jmcarthur> :t (>>)
11:19:41 <rwbarton> Ralith: pretty much normal
11:19:48 <bgamari> tibbe, alright
11:19:52 <nand`> mapf: 30,000 definitions via TH, 2.968s
11:19:53 <neutrino_> i think it starts cycling above 9
11:19:55 <jmcarthur> Jello_Raptor: i see
11:19:56 <lambdabot> thread killed
11:20:03 <applicative> Jello_Raptor:  anyway, in Control.Lens your F f is called _1 %~ f   as acting on the next element is _2 %~ f
11:20:09 <Jello_Raptor> hmm, is lambdabot's type lookup broken?
11:20:17 <invariant> applicative, regarding your benchmarks, Free Pascal is faster is almost all benchmarks or ties within statistical error.
11:20:19 <applicative> Jello_Raptor:  and so on up to _8 or something
11:20:33 <Cale> > 1
11:20:41 <lambdabot>   mueval: Prelude.undefined
11:20:41 <lambdabot>  mueval: ExitFailure 1
11:20:44 <Cale> heh
11:21:00 <nand`> Cale: I tried type checking {fmap}^32 :(
11:21:02 <JavaSucksMan> > 3 + 4
11:21:10 <lambdabot>   mueval: ExitFailure 1
11:21:10 <lambdabot>  mueval: Prelude.undefined
11:21:11 <Jello_Raptor> :t 1
11:21:13 <applicative> invariant: no, it wins on one, which is a noted catastrophe; though for all I know no one has worked on the Free Pascal entries for two years either
11:21:20 <Cale> > 1
11:21:25 <lambdabot>   mueval-core: Time limit exceeded
11:21:25 <Cale> hmm
11:21:32 <applicative> invariant: on the other hand I suppose the implementation hasn't changed much in two years either :)
11:21:33 <Jello_Raptor> :/ yup broken
11:21:35 <JavaSucksMan> >1::Int
11:21:52 <Cale> @undefine
11:21:55 <Cale> > 1
11:21:58 <lambdabot>   1
11:22:00 <Cale> okay
11:22:01 <hpaste> neutrino pasted “fmap fmap fmap fmap fmap fmap mushroom mushroom” at http://hpaste.org/77825
11:22:11 <JavaSucksMan> > 3 + 4
11:22:13 <lambdabot>   7
11:22:18 <JavaSucksMan> yay
11:22:19 <Cale> Probably someone @let some expression which took forever to typecheck or something
11:22:25 <neutrino_> here you go rwbarton
11:22:26 <edwardk> :t _9
11:22:28 <lambdabot> (Functor f, Field9 s t a b) => (a -> f b) -> s -> f t
11:22:29 <mcstar> wtf was contained in that paste, nand?
11:22:39 <Cale> Let's see if that works...
11:22:45 <mcstar> it broke my opera :(
11:22:49 <tibbe> bgamari: where is R2 defined?
11:22:51 <invariant> nand`, don't you think that the time parsing should be part of it?
11:23:02 <invariant> nand`, as such, you are comparing apples to oranges.
11:23:20 <bgamari> tibbe, Track
11:23:33 <bgamari> tibbe, It's just (Double,Double)
11:24:05 <Cale> @let f x = (x,x); f1 x = f (f x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x); f5 x = f4 (f4 x)
11:24:07 <lambdabot>  <local>:1:21:
11:24:07 <lambdabot>      Ambiguous occurrence `f'
11:24:07 <lambdabot>      It could refer to either `L...
11:24:10 <tibbe> bgamari: data R2 = R2 !Double !Double and -funbox-strict-fields would be better
11:24:11 <Cale> oh, derp
11:24:16 <Cale> @let f0 x = (x,x); f1 x = f0 (f0 x); f2 x = f1 (f1 x); f3 x = f2 (f2 x); f4 x = f3 (f3 x); f5 x = f4 (f4 x)
11:24:24 <Cale> > 1
11:24:27 <tibbe> bgamari: after parsing about 1/4-1/3 of all your data is (,)
11:24:41 <Cale> ^^ I bet that's what happened
11:24:43 <bgamari> tibbe, Ahh
11:24:45 <lambdabot>   thread killed
11:24:45 <lambdabot>  thread killed
11:24:55 <Cale> Well, something along those lines
11:24:56 <Cale> > 1
11:25:01 <lambdabot>   mueval-core: Time limit exceeded
11:25:04 <Cale> @undefine
11:25:05 <bgamari> tibbe, Let me try
11:25:06 <nand`> mcstar: it shouldn't have
11:25:08 <Cale> > 1
11:25:10 <tibbe> bgamari: otherwise the memory usage looks good after parsing is done
11:25:10 <felix2> do you have any list of project ideas for people wanting to contribute to the Haskell ecosystem?
11:25:11 <lambdabot>   1
11:25:15 <tibbe> bgamari: perhaps 10M or so
11:25:17 <neutrino_> guys has really no one here used HaRe? that's very surprising??
11:25:20 <bgamari> tibbe, Perfect
11:25:30 <neutrino_> it's supposed to be this super cool haskell tool
11:25:30 <Cale> neutrino_: Why would it be surprising?
11:25:31 <invariant> felix2, a small and fast compiler!
11:25:34 <c_wraith> hasn't HaRe been broken for a while?
11:25:36 <bgamari> tibbe, Thanks again!
11:25:37 <tibbe> (for the Vector FramePt)
11:25:38 <nand`> mcstar: just a ‘cat TH.hs’ -> a file with some TH to generate 30,000 values _0, _1, _2 etc all = (); followed by a ‘time ghc TH.hs’ -> real 0m2.968s
11:25:41 <tibbe> bgamari: you're welcome
11:25:43 <neutrino_> because automatic refactoring is so much fun!
11:25:58 <neutrino_> even with only lambdabot at my disposal i have infinite fun with it
11:26:00 <felix2> invariant, I'm not sure that's possible, unfortunately :(
11:26:02 <neutrino_> and use it all the time
11:26:11 <bgamari> tibbe, I'm looking forward to looking over your patches
11:26:21 <Cale> neutrino_: Have you ever tried to get HaRe to work?
11:26:22 <nand`> what does HaRe do? maybe I'd be interested, I do a lot of refactoring
11:26:23 <applicative> invariant: hugs is small and fast; I mean the program itself wont be so fast, but you seem not to care about the program
11:26:26 <neutrino_> c_wraith: i think the latest it built on was 6.12 or something
11:26:36 * bgamari clearly needs more experience with writing performant Haskell
11:26:36 <neutrino_> Cale: no.. i am debating setting up a VM for it
11:26:36 <invariant> felix2, writing a compiler is easy, convincing 10,000 people that your compiler is really not slow is hard.
11:26:44 <nand`> probably most of my time spent writing Haskell is thinking about how to layout things so they're as beautiful as possible, while staying within 80col
11:26:56 <neutrino_> nand`: it's a tool specifically geared for refactoring haskell programs.
11:27:06 <felix2> and *actually* making it not slow is hard too
11:27:10 <nand`> neutrino_: I knew that much
11:27:15 <invariant> applicative, hugs is also not compatible with basically all code.
11:27:17 <nand`> but beyond what the name stands for, I know nothing
11:27:29 <invariant> applicative, it's abandonware, if anything.
11:27:34 <bgamari> tibbe, There was nothing groundbreaking changed in the attoparsec tree, correct?
11:27:37 <bgamari> Just tweaks?
11:27:38 <neutrino_> nand`: it's the research project of several people. they added a lot of different refactoring techniques to it.
11:28:25 <neutrino_> nand`: do you by any chance use vim?
11:28:52 <neutrino_> if you do i made some lambdabot "plugins" for it
11:30:08 <felix2> but it's written in C, isn't it?
11:30:19 <neutrino_> what is written in C?
11:30:24 <felix2> hugs
11:30:28 <neutrino_> no idea.
11:30:36 <tibbe> bgamari: performance tweaks
11:30:42 <tibbe> bgamari: good ones though!
11:30:52 <applicative> hugs is a C program
11:30:55 <bgamari> tibbe, Alright, I'll try them
11:31:02 <tibbe> bgamari: about to make some more
11:31:20 <Cale> nand`: I just break the 80col rule whenever it suits me
11:31:40 <JavaSucksMan> does anybody use ghci extensively?
11:31:51 <Cale> nand`: though when things get ridiculous, I'll start working on wrapping things
11:32:00 <Cale> JavaSucksMan: Everyone?
11:32:11 <jmcarthur> JavaSucksMan: most of us, probably
11:32:17 <Cale> JavaSucksMan: It's hard not to use ghci extensively if you're writing Haskell code.
11:32:40 <JavaSucksMan> nobody ever answers my question, so I don't know whether it just gets lost in the noise, or if it's too hard
11:32:52 <Cale> ?
11:33:00 <Cale> JavaSucksMan: What's your question?
11:33:06 <johnw> i live in ghci while i'm developing
11:33:24 <JavaSucksMan> Does anybody now how to change the number of lines remembered in ghci's history?
11:33:35 <Cale> I don't know
11:33:43 <Cale> I've never thought about doing that
11:34:04 <Cale> Usually if something is more than 5 or 10 lines back, I'll just end up typing it again
11:34:06 <JavaSucksMan> I actually rebuild GHC from source...took about 3 hours... got to be an easier way
11:34:18 <Cale> So the history length doesn't bother me
11:34:22 <neutrino_> JavaSucksMan: read the documentation for Haskeline
11:34:26 <applicative> it doesn't take that long
11:34:29 <c_wraith> ghci uses haskeline for that
11:34:36 <fmap> JavaSucksMan: http://trac.haskell.org/haskeline/wiki/UserPrefs
11:34:38 <JavaSucksMan> I tried that already,
11:34:40 <c_wraith> I believe haskeline can be configured with a .haskeline file
11:34:47 <tibbe> javaSucksMan: I don't know, but I think it uses this library: http://hackage.haskell.org/package/haskeline That library might support a config file.
11:34:56 <neutrino_> and what did you find out
11:35:05 <tibbe> javaSucksMan: I was too slow. What fmap said.
11:35:12 <neutrino_> tibbe: i was just going to say that.
11:35:26 <JavaSucksMan> I think that might do the trick... thanks.
11:35:44 <edwardk> JavaSucksMan: in .haskeline    put maxhistorysize: Hist 10000
11:35:44 <applicative> hm, J Jacobson says "Also I limited the history to 100 items only when saving the file, during a GHCi run there is no limit (as before)."
11:35:47 <edwardk> er Just 1000
11:35:56 <Cale> If you have to press the up arrow more than, say, twice the number of characters in the line you'd be typing, you might as well just retype it usually, so there's not much point in having a history size longer than ~160
11:36:10 <rwbarton> ctrl-R?
11:36:21 <edwardk> Cale: well, you can go down that many too, so maybe 320? =)
11:36:31 <JavaSucksMan> I looked at the code,  Nothing means no line limit, which is what I want... I just couldn't find the config file
11:36:33 <c_wraith> yeah, ctrl-r is the main reason
11:36:34 <Cale> down?
11:36:45 <Cale> You can't go down from the beginning...
11:36:55 <bgamari> Sadly I lose the free VectorSpace, AdditiveGroup, etc. instance by defining my own R2
11:36:56 <bgamari> bah
11:37:08 <c_wraith> JavaSucksMan: yes, like most unix-style configuration files, it's only present if you created it to change something
11:37:10 <edwardk> oh guess it doesn't wrap
11:37:10 <edwardk> but yeah the ctrl-r example is compelling
11:37:19 <neutrino_> Cale: do you never use ctrl-r?
11:37:27 <Cale> neutrino_: I didn't know that it existed.
11:37:32 <Cale> (and no)
11:37:35 <jmcarthur> i keep my shell history insanely long just for control-r (or for the much nicer zsh feature where you can just type and then use the arrow keys to browse all matching lines in history)
11:37:46 <JavaSucksMan> I come from a smalltalk environment where nothing the user does ever get thrown away without explicitly requesting it.
11:37:55 <Cale> What's reverse-i-search?
11:38:02 <rwbarton> type "import"
11:38:05 <neutrino_> Cale: you press ctrl-r and start typing.
11:38:08 <jmcarthur> it allows you to search history via a substring
11:38:13 <neutrino_> it'll find the last time you typed that.
11:38:21 <neutrino_> press ctrl-r again and it'll find the previous time.
11:38:37 <edwardk> bgamari: what are you looking to use it for?
11:39:03 <Clint> the "i" is incremental
11:40:36 <neutrino_> if you do stty -ixon, then you can do ctrl-s to go forward
11:40:40 <neutrino_> opposite to ctrl-r
11:40:45 <neutrino_> you don't need zsh for that
11:41:10 <Cale> I don't know if I really like that feature. It seems good if you know for sure that you're going to find what you're looking for, but otherwise, you waste a bunch of time and end up typing it anyway.
11:41:27 <neutrino_> Cale: you normally find what you were looking for.
11:41:39 <neutrino_> Cale: you have to practice using it
11:41:46 <Cale> So you either save a little time, or (more than?) double the amount of time you used.
11:41:54 <rwbarton> it's amazingly useful
11:42:03 <neutrino_> Cale: trust me, it's very useful
11:42:10 <c_wraith> very often, you're searching for something you know you typed recently
11:42:17 <neutrino_> also: don't use the up arrow, use ctrl-p
11:42:19 <c_wraith> It's just that recently = 10 minutes and 30 lines
11:42:20 <neutrino_> and ctrl-n for down
11:42:24 <Cale> why?
11:42:28 <neutrino_> and don't use enter, use ctrl-m
11:42:36 <rwbarton> however it may not be that useful for searching thousands of lines of history earlier, I admit
11:42:43 <neutrino_> because this way you can keep your fingers in the home row Cale
11:42:48 <Cale> p and n aren't even near each other on the keyboard
11:43:02 <neutrino_> no, but that matters the least :)
11:43:07 <neutrino_> "previos" and "next"
11:43:13 <neutrino_> "previous"
11:43:42 <Cale> neutrino_: no, it matters quite a bit, because when you're using one, you're likely to want the other
11:43:53 <Cale> but you're not likely to be typing anything else
11:43:59 <Cale> until you've found what you want
11:44:11 <neutrino_> they're adjacent to the home row
11:44:25 <neutrino_> so my index finger is on n and pinky is on p
11:44:29 <Cale> I don't keep my hands on the keyboard when I'm not using it anyway :P
11:44:33 <neutrino_> and then i just type this way
11:44:43 <neutrino_> my hands are always on the keyboard, in my lap
11:45:03 <neutrino_> here's another one you might like Cale, for repeating sequences of commands
11:45:10 <hpaste> “Alex R” pasted “Deriving with kind tags” at http://hpaste.org/77827
11:45:12 <neutrino_> you go up to a command and press ctrl-o
11:45:30 <rwbarton> sadly missing from haskeline
11:45:30 <neutrino_> what happens is that the command gets executed, and the next command in the history gets selected
11:45:35 <neutrino_> you can keep pressing ctrl-o
11:45:38 <neutrino_> is it rwbarton?
11:45:45 <neutrino_> well, it works in everything else
11:45:53 <Cale> Sorry, but this all seems like stuff which isn't worth memorising to me :P
11:46:01 <atriq> Can I, with ViewPatterns, do something like foo {viewl -> a :< viewl -> b :< c}
11:46:05 <JavaSucksMan> Yay... so much more usefull.. got .haskeline working.....
11:46:11 <rpglover64> Anyone know how to deriving an Eq (or Ord) instance for a GADT with a phantom parameter of a lifted kind?
11:46:15 <Cale> If I have a sequence of commands I'd rather not type over and over, I'll give them a name and stick it into my source code
11:46:26 <rpglover64> e.g. code here: http://hpaste.org/77827
11:46:28 <neutrino_> Cale: you say that because you haven't memorized it all yet :p
11:46:38 <neutrino_> one day you'll grow out of this
11:46:49 <JavaSucksMan> Somebody should put the info at http://trac.haskell.org/haskeline/wiki/UserPrefs into the ghci manual page... would have saved me hours
11:46:52 <neutrino_> ;)
11:47:06 <neutrino_> JavaSucksMan: that someone is you
11:47:53 <Cale> neutrino_: Doubtful. I don't use any of the fancy features of my text editors, because they mostly waste time.
11:48:17 <neutrino_> you're such a luddite, Cale :)
11:48:50 <neutrino_> ;)
11:49:38 * neutrino_ fully expects Cale to smack him with a club or big dinosaur bone now.
11:49:42 <Cale> (give me syntax colouring and automatic conversion of tabs to spaces, and I'm happy)
11:50:15 <Cale> I use vim, but some people seem to hate the way that I use it :)
11:50:41 <edwardk> cale: dolio gives me endless amounts of crap for the same reason ;)
11:50:47 <Cale> (I use the arrow keys and mouse a fair bit)
11:50:54 <JavaSucksMan> neutrino: Hey I'm just starting out.... Don't know how (no edit button)
11:51:16 <Cale> I never ever use numbers for repetition
11:51:53 <strebe> Is anyone maintaining/modifying http://www.haskell.org/haskellwiki/Introduction_to_QuickCheck2 ? I'm using QuickCheck-2.4.2 and some parts simply don't work for me, like the definition of deepCheck
11:51:55 <dolio> Ed uses numbers for repititon.
11:53:13 <edwardk> even when i shouldn't =P
11:53:37 <JavaSucksMan> I guess register at GHC trac and put in a feature request for the documentation?
11:53:42 <neutrino_> edwardk: i'll have to take you to a vim bootcamp
11:53:53 <neutrino_> you'll be running on a treadmill typing combos
11:54:26 <neutrino_> with an i/v of whey protein
11:54:30 <edwardk> neutrino_: over the years i've known a disturbing amount about the internals of vi and vim and all the various macro tricks and vimscript, etc. and i've thankfully forgotten most of it
11:54:47 <neutrino_> haha
11:54:52 <neutrino_> i've never managed to forget it
11:55:09 <neutrino_> #vim is always helpful in case i'm missing something
11:55:20 <dolio> edwardk just does a lot of stuff that is less efficient, but he'd have to think more to do the more efficient thing, so it works out about equal probably.
11:55:36 <chrisirc> I seem to be unable to find some list monad example. I thought the list monad is basically a state monad that has an op to cons onto the existing state?
11:55:51 <jmcarthur> chrisirc: think of it as a nondeterminism monad
11:55:55 <johnw> you guys are all crazy, #emacs is the way to go
11:56:02 <jmcarthur> chrisirc: the resulting list is all possible choices
11:56:35 <jmcarthur> > do { x <- [a,b,c]; y <- [d,e,f]; return (x, y) }
11:56:36 <lambdabot>   [(a,d),(a,e),(a,f),(b,d),(b,e),(b,f),(c,d),(c,e),(c,f)]
11:56:40 <jmcarthur> chrisirc: ^^
11:56:56 <chrisirc> Interesting.
11:57:09 <jmcarthur> chrisirc: so it's just all possible choices of x and all possible choices of y
11:57:21 <neutrino_> edwardk: it's like the mental equivalent of a beer gut
11:57:43 <edwardk> neutrino_: i have one of those too.
11:57:54 <neutrino_> oops
11:58:00 <neutrino_> hahaha
11:58:21 <neutrino_> how do you fit in a plane?
11:58:26 <copumpkin> > liftA2 (=<<) zip (tail . tails) $ [a,b,c,d,e,f]
11:58:26 <neutrino_> ;)
11:58:30 <lambdabot>   mueval-core: Time limit exceeded
11:58:32 <copumpkin> > liftA2 (=<<) zip (tail . tails) $ [a,b,c,d,e,f]
11:58:34 <lambdabot>   [(a,b),(b,c),(c,d),(d,e),(e,f),(a,c),(b,d),(c,e),(d,f),(a,d),(b,e),(c,f),(a...
11:58:39 <copumpkin> > liftA2 (=<<) zip (tail . tails) $ [a,b,c,d]
11:58:41 <lambdabot>   [(a,b),(b,c),(c,d),(a,c),(b,d),(a,d)]
11:58:43 <neutrino_> that must look like a zeppelin ;)
11:59:25 <edwardk> neutrino_: my main thought about my text editor is i don't want to think about my text editing. i've been using vi or vim for something like 25-30 years now. i know the right things to do, i just don't do them when i'm thinking about deeper issues than the code i'm refactoring =P
11:59:49 <edwardk> neutrino_: my fitting on a plane issues are more a function of my height than my weight ;)
12:00:41 <neutrino_> and they gave you a license? ;)
12:03:56 <nand`> Cale: my vim usage basically limits itself to the ‘arrow keys’ (hjkl) and occasionally stuff like ‘gg’ or ‘G’; but I do most of my editing manually - I think one of the nice things about these sorts of editors in general is that they appeal to people of any level of expertise
12:04:09 <nand`> (on that note, my most used key sequence is probably ‘ciw’)
12:04:22 <Cale> Yeah, when I said arrow keys, I meant arrow keys :)
12:04:35 <parcs`> i just use bcw instead of ciw
12:05:19 <nand`> Cale: I'm glad I'm not the only one that thinks stuff like ctrl+p/ctrl+n is completely broken, though; I can't use the stuff like ‘previous word / next word’ either simply because they're so uncomfortable / arcane to press
12:05:33 <Cale> I don't use previous/next word
12:05:52 <parcs`>  why not?
12:05:56 <nand`> I would but I'm too lazy to rebind them
12:05:59 <FireFly> You mean b/w?
12:06:07 <nand`> maybe something like H/L could work
12:06:09 <rpglover64> Is it possible to derive (or something similar) an Eq (or Ord) instance for a GADT with a phantom parameter of a lifted kind? Code example here: http://hpaste.org/77827
12:06:10 <nand`> FireFly: yeah
12:06:12 <Cale> parcs`: because it's pointless? :)
12:06:13 <nand`> also e
12:06:20 <FireFly> They're very comfortable to press on dvorak :-)
12:06:23 <eroot> hey guys, can I use "let f = ..." in the Try Haskell interface?
12:06:31 * nand` is using QWERTY
12:06:41 <Cale> nand`: You can hold ctrl while you use the arrows if you really want
12:07:01 <dna_> I'm trying to write an edsl for boolean expressions, with the goal of being able to extract a dag from the expression
12:07:03 <nand`> I don't use the arrows though :)
12:07:08 <parcs`> Cale: what do you use instead ?
12:07:20 <nand`> actually, ctrl + arrow keys seems to insert stuff like ‘a’, ‘b’, ‘c’ and so forth
12:07:22 <c_wraith> eroot: Try Haskell processes each request independently - you can't set values and use them later.  However, you can construct expressions with "let ... in ..."
12:07:28 <nand`> I think it gets mapped to <Esc>Ox where x is some letter
12:07:35 <Cale> parcs`: if where I want to go is close, the arrow keys, if it's far, the mouse
12:07:35 <dna_> the problem I'm running in to is the problem of observable sharing, tried a lot of different approaches, olegs seems to be the most interesting one
12:07:36 <eroot> thanks c_wraith
12:07:59 <Cale> nand`: Doesn't do that for me
12:08:10 <dna_> the problem is that the expressions get really large, and thus hashconsing takes too long
12:08:35 <neutrino_> "when you use the arrows" saywha
12:08:45 <jmcarthur> dna_: ah, you're trying to detect existing sharing in the heap?
12:08:49 <dna_> I'm thinking that this would be solvable by using some kind of scoped hash-consing, but then I'm running into trouble when trying to use lists in the host language, i have no idea how to create scoping functions
12:09:10 <parcs`> my most used commands are probably {, }, ^D, ^U, *, n, N and C-6
12:09:27 <Cale> I use exactly zero of those
12:09:29 <dna_> jmcarthur, that is correct. Tried olegs approach, which works for small expressions. Also tried data-reify, but I'm lost on how to use lists in the host language with data-reify
12:09:34 <jmcarthur> dna_: see this package and the associated paper: http://hackage.haskell.org/package/data-reify
12:09:37 <jmcarthur> ah
12:09:38 <FireFly> { } ^U ^D are commonly used by me too
12:09:40 <nand`> ooh, I just figured out how to improve my vim experience
12:09:42 <jmcarthur> you were ahead of me
12:09:50 <dna_> thanks for the tip
12:10:06 <dna_> the problem is, that in the host language i need functions of type [Expr] -> [Expr]
12:10:14 <FireFly> (the fact that U/D are on dvorak F/H helps)
12:10:24 <FireFly> err, dvorak U/D are on qwerty F/H*
12:10:29 <dna_> and i need to reify functions over lists, but in the dag i don't need lists
12:10:35 <jmcarthur> dna_: i'm not sure i see the problem. is it that you find the result from data-reify to be awkward to use, or is it something you think is deeper?
12:10:37 <parcs`> yeah, dvorak is very vim-friendly
12:10:39 <nand`> :noremap j gj & noremap k gk
12:11:11 <parcs`> nand`: that's pretty much a no-op for well behaved text files
12:11:14 <dna_> jmcarthur: i understand how to use data-reify for primitive expressions, but not for expressions containing lists
12:11:29 <jmcarthur> isn't a list a primitive expression?
12:11:42 <Cale> Why the hell would someone use ^U and ^D when they have keys specifically for that purpose which are 1) right next to each other and 2) don't require awkwardly holding down a modifier key?
12:11:56 <nand`> parcs`: I regularly come across documents with very long lines, for example build logs
12:12:04 <jmcarthur> Cale: because you don't have to move your hands
12:12:17 <nand`> Cale: yeah; I don't understand why you would use those over hjkl either ;)
12:12:21 <parcs`> Cale: because Pg Up and Pg Down require movement of your entire arm
12:12:23 <Cale> jmcarthur: I don't comprehend that argument
12:12:27 <dna_> jmcarthur: yes, but not in the edsl, the edsl is defined on single bits, but i use lists in the host language to generate a large amount of edsl-expressions
12:12:27 <jmcarthur> Cale: (vim's keys are a bit nicer for this)
12:12:44 <Cale> But then, I remove my hands from my keyboard whenever I'm not actively typing
12:12:50 <Leif_Bork> Is it possible to serialize recursive data structures in any way, while not breaking referential transparency?
12:12:57 <jmcarthur> dna_: could you paste the ast on hpaste or something?
12:13:03 <jmcarthur> err, the type for it
12:13:19 <johnw> Leif_Bork: do you additionally want to be able to read them back in?
12:13:20 <dna_> jmcarthur: sure, doing it now
12:13:24 <pordan30> rpglover64: i believe the answer to your question is the answer to the question whether a promoted kind can be used wherever a kind ∗ is expected. i believe the answer to this question is that no, you can't. if so, the reason you can't derive a show instance is because the type variable parameterizing the show instance has kind ∗. there is a definite possibility that i'm wrong, however, so i defer to the next answer =)
12:13:25 <jmcarthur> Cale: sure, but don't you tend to interleave typing and moving around a lot?
12:13:35 <Cale> jmcarthur: Not that closely
12:13:45 <jmcarthur> ah, different styles then
12:13:46 <Leif_Bork> johnw: Yep
12:13:54 <Cale> I'm not going to type app<pgup>le
12:13:54 <pordan30> *promoted type, not kind
12:13:59 <Cale> that's just silly
12:14:00 <rpglover64> but deriving Show works just fine
12:14:10 <rpglover64> pordan30: deriving Eq doesn't work
12:14:11 <jmcarthur> i doubt most people would, but that's a bit of a strawman
12:14:12 <hpaste> dna pasted “edsl” at http://hpaste.org/77830
12:14:14 <rpglover64> and that makes sense
12:14:22 <jmcarthur> i tend to interleave the two a lot when refactoring, for example
12:14:23 <Cale> because you can't really guess where you're going to land very precisely when you pgup and pgdn anyway
12:14:31 <johnw> Leif_Bork: I don't know, haven't faced that problem yet
12:14:36 <Cale> so you *can't* interleave them without at least a short pause to look where you ended up
12:14:36 <jmcarthur> yeah, i'm not going to defend pgup and pgdn
12:14:45 <rpglover64> but I was wondering if there's an extension to the deriving mechanism or a library or something that _can_ derive Eq
12:14:47 <Cale> ^U and ^D are the same
12:14:48 * nand` never uses pgup/pgdn
12:14:51 <jmcarthur> i mean more directed forms of movement
12:14:53 <nand`> only for terminal scrolling
12:14:57 <dna_> jmcarthur: this is using olegs approach, but the Node-type is basically what i want after reification
12:15:20 <Leif_Bork> johnw: Okay, thanks anyways!
12:15:33 <JavaSucksMan> I use the mouse a lot for navigation... easier than remembering a bunch of key bindings
12:15:36 <Cale> jmcarthur: Even arrow keys, it's pretty weird to be interleaving much use of arrows and typing
12:15:37 <pordan30> rpglover64: ignore me, then. i guess i was talking out of my ass
12:15:52 <rpglover64> pordan30: But you were talking to me, so I appreciate it :)
12:16:04 <nand`> personally, my most tedious, laborious , manual form of editing which consumes probably the most amount of time is code alignment. I compulsively align things
12:16:21 <Cale> and even if you are doing a lot of that, in vim, you'll have an easier time with the real arrows, because you don't have to switch out of insert mode then
12:16:23 <jmcarthur> Cale: really? you've never, say, taken an expression that uses a prefix operator and changed it to use an infix one, for example?
12:16:31 <jmcarthur> s/you've never/you don't frequently/
12:16:43 <Cale> Not frequently enough to require anything special?
12:16:53 <arcatan> Leif_Bork: i don't think you can detect self-referential data structures
12:17:05 <nand`> Cale: speak for yourself; I've muscle memoried the whole ‘leaving insert mode after a handful of keystrokes’
12:17:20 <jmcarthur> dna_: not sure i see where lists come in
12:17:24 <nand`> I do it constantly, even when in other editors that don't actually have a separate insert mode
12:17:40 <Cale> nand`: Even if it's in muscle memory, it's still going to be more time than the empty sequence of actions
12:17:52 <jmcarthur> dna_: if you are trying to share subexpressions of several expressions, i would say that the ast should probably capture that itself
12:18:05 <nand`> arcatan: something something reify something IO something
12:18:36 <Cale> jmcarthur: There's also a sense in which a kind of Amdahl's law applies to this kind of thing
12:19:01 <Cale> At least if I'm programming in Haskell, I spend less than a tenth of my time programming on actually typing in code.
12:19:10 <Cale> So optimising that process is dumb
12:19:37 <jmcarthur> but that optimization is at least more straightforward than optimising your thinking
12:19:39 <nand`> Cale: you sound like me circa one year ago; I think every single argument you mentioned is one that I've brought up in the past :P
12:19:42 * hackagebot minimorph 0.1.3.0 - English spelling functions with an emphasis on simplicity.  http://hackage.haskell.org/package/minimorph-0.1.3.0 (EricKow)
12:19:52 <dna_> jmcarthur: they come in when trying to generate code for multiple boolean expressions at the same time
12:20:04 <jmcarthur> ah yeah, it's what i suspected
12:20:19 <dna_> jmcarthur: i.e. bit vectors in the host language, but the compile target doesn't have lists in this case
12:20:26 <nand`> (I don't mean to imply anything, merely thought it was amusing)
12:20:52 <edwardk> cale: nah. if you don't optimize it you'll never be more than 10x faster than you are now ;)
12:21:01 <Cale> jmcarthur: Well, if I have to be distracted by holding all this information about my text editor in my head all the time, it might feel like I'm getting more done somehow because I'm being successful with the stuff that I'm thinking about, but I'm no longer thinking about my problem and instead wasting time thinking about the cleverest way I can use my text editor to enter the code.
12:21:12 <jmcarthur> dna_: couldn't you just have this instead?    newtype N = N { unN :: State [BiMap Node] [Int] }
12:21:22 <jmcarthur> Cale: it becomes muscle memory
12:21:28 <nand`> ^
12:21:42 <parcs`> the powerful thing about vim is that all of its shortcuts are designed to work well together. if you single out a single shortcut it's easy to justify that it's not worth the effort to memorize, but once you've memorized multiple shortcuts your text-editing efficiency in vim is significantly greater than in traditional editors
12:21:55 <edwardk> but that said, in practice i work the same way, with just a different amount of muscle memory for text editor tricks
12:21:56 <nand`> when I switched to vim first, I was significantly slower than before; now I'm at about the same speed again, if not faster - I can't really compare it
12:22:09 <jmcarthur> parcs`: the same applies for emacs. your fingers just hurt more
12:22:14 <Cale> I've seen people who use vim "well", and I'm not so impressed that I actually care to waste my time on it.
12:22:24 <dna_> jmcarthur: i could try, thanks for the help
12:22:40 <nand`> personally I'm waiting for plaintext editors to become obsolete
12:22:47 <jmcarthur> dna_: i take that back, it's not what you want
12:23:03 <jmcarthur> dna_: that's what you want the final result to be, but not what you want client code to be using
12:23:24 <JavaSucksMan> nand: ever try leksah?
12:23:31 <dna_> jmcarthur: yeah, that's what i thought
12:23:31 <nand`> I feel like vim could be improved by having Haskell-aware navigation commands though, instead of just stuff like word-boundary-aware
12:23:33 <nand`> JavaSucksMan: for a few seconds
12:23:38 <Cale> I don't think I would ever recover the time which I spent learning how to use all those shortcuts better in actual improvements in time in the future, because there's a few orders of magnitude in difference there.
12:23:45 <jmcarthur> dna_: i'm guessing you might just need some sort of "merge" operation to apply to all the expressions at the end, whose result is ([BiMap Node], [Int])
12:23:49 <Blkt> good evening everyone
12:23:57 <JavaSucksMan> I'm tempted to do a Smalltalk-style IDE for GHC
12:24:00 <dna_> jmcarthur: i'll write together a small example of where i run into problems with data-reify as well
12:24:16 <jmcarthur> dna_: i won't have the time to help in the near future, though, sorry. good luck though
12:24:20 <nand`> What's a smalltalk-style IDE?
12:24:42 <Cale> I want a mathematica-style notebook IDE for Haskell.
12:24:49 <jmcarthur> Cale: yes!
12:25:08 <jmcarthur> shapr's SoC project gets close, i think, but needs polish and more features
12:25:08 <JavaSucksMan> That's where browsers came from.
12:25:12 <dna_> jmcarthur: thanks for the help anyway, sometimes it helps a lot just to explain a problem to someone else
12:25:46 <nand`> I'd be interested in light table for Haskell; but open source and console-based
12:26:25 <edwardk> nand`: well, the fpcomplete guys are going for something light table -ish but closed source and web based
12:26:38 <nand`> I saw the video
12:26:41 <nand`> none of it impressed me, tbh
12:26:55 <tromp> it is
12:27:07 <tromp> oops; wrong window
12:27:15 <edwardk> i'm somewhat neutral, cautiously curious to see how well it works. it strikes me as a terribly ambitious time table
12:27:37 <JavaSucksMan> light table is Smalltalk-inspired
12:27:43 <adek05> I am reading about State Monad. I am curious about one thing. Suppose I want to implement some kind of PushDownAutomata. I think I can implement it as a function: String -> (String, ParsedType). What is the advantage of using State Monad? Maybe in my example there is no difference. I want to feel it...
12:28:00 <nand`> on a related note; I think the modern craze of “let's make EVERYTHING a browser app” is unrealistic until we have a good browser
12:28:08 <nand`> on that matter, what ever became of HBro?
12:28:11 <tac> adek05: that's just the state monad "unrolled"
12:28:46 <edwardk> adek05: with your approach you have to make up a name for every intermediate state variable and manually plumb it to where it goes.
12:28:48 <nand`> adek05: you can use the polymorphic Monad functions; including but not limited to do-syntax
12:28:55 <tac> "state s a" is just an alias for "s -> (s, a)"
12:29:00 <edwardk> adek05: the issue is in the amount of useless boring names you have to come up with
12:29:06 <edwardk> er the difference
12:29:08 <jmcarthur> @unmtl State s a
12:29:08 <lambdabot> s -> (a, s)
12:29:24 * Cale still hates the mtl's pair ordering
12:29:29 <jmcarthur> me too
12:29:31 <JavaSucksMan> nand: https://www.youtube.com/watch?v=AjPLN8UoB-I is a decent into vid
12:29:34 <Cale> It's obviously backward
12:29:41 <nand`> Cale: why?
12:29:47 <jmcarthur> wouldn't  fmap = fmap . fmap  be so much more natural?
12:29:51 <mightybyte_> Is hackage slow for anyone other than me right now?
12:29:58 <nand`> jmcarthur: oh, yes, it would
12:30:02 <nand`> that makes sense
12:30:07 <tac> @unmtl State String ParsedType
12:30:08 <lambdabot> String -> (ParsedType, String)
12:30:08 <nand`> composition of a reader and writer, so to say
12:30:14 <tac> oops, well same thing :)
12:30:18 <Cale> (kind of)
12:30:30 <tac> Yeah
12:30:35 <edwardk> nand`: because we use (,) e  for writer, so you'd probably want (,) e  and (->) e to be adjoint, rather than the more traditional (->) e  and (,e) that gets used in category theory all the time.
12:30:50 <jmcarthur> nand`: i think of State is being like Endo with an extra result tacked on
12:30:55 <jmcarthur> *as being
12:31:09 <Sonderblade> does haskell have something for adding constraints to data types? e.g i want to define an Int that is >= 0
12:31:16 <Cale> The E x -- and -- x E are not distinguished so much in mathematics
12:31:23 <rpglover64> Re-asked here: http://stackoverflow.com/questions/13423961
12:31:31 <jmcarthur> Sonderblade: not built in
12:31:43 <jmcarthur> Sonderblade: you could use smart constructors, though
12:31:52 <edwardk> but the benefit of the encoding used in the mtl is that its leftAdjunct/rightAdjunct are just uncurry/curry, even though you can't use them directly as Functors
12:31:52 <luqui> I want to make a typeclass Foo a such that Foo a <-> exists b. a ~ IO b (i.e. it is derivable both ways).  Is this possible?
12:31:53 <jmcarthur> Sonderblade: or for that particular case you could just use Data.Word.Word
12:32:15 <luqui> I have an instance which will introduce, but it seems I need a constraint on the class to eliminate
12:33:07 <Sonderblade> jmcarthur: that was just a (simple) example, i might want a list of integer two-tuples (x,y) where x<=y and none of the tuples are overlapping
12:33:07 <pordan30> on second thought, in order to derive an instance for Eq, you would need to express the type Expr a -> Expr b -> Bool in the form a C a = a -> a -> Bool. this is probably why you can't use deriving.
12:33:21 <pordan30> s/=/=>/
12:33:26 <jmcarthur> Sonderblade: yeah this isn't really convenient in haskell at all
12:33:30 <adek05> Okay. Suppose I want to write TCP stream parser which will extract packets. The pattern I come up with is something like: foo :: Socket -> State -> (Packet, State). I can't see the difference. What could be the advantage of making it monad. The only thing it does in this case is wrap the function (State -> (Packet, State))
12:33:34 <Sonderblade> jmcarthur: seems to me like something lots of haskellers would already have thought of :)
12:33:42 <jmcarthur> Sonderblade: i wouldn't recommend trying to use types to do these constraints in haskell
12:33:55 <jmcarthur> Sonderblade: but if these kind of types interest you, you might want to look at dependently typed languages
12:34:02 <bgamari> edwardk, It's a data analysis script (particle tracking)
12:34:12 <nand`> how would you do it with dependent types? Sonderblade's x <= y example
12:34:44 <edwardk> bgamari: ah. i asked because i was going to mention https://github.com/ekmett/linear/blob/master/src/Linear/V2.hs#L23
12:34:58 <adek05> Would it be better if the parsing was done somehow by looping over each Character in it and then passing the state would be implicit?
12:35:17 <Sonderblade> jmcarthur: sql for example has a lot of data constraints like that
12:35:20 <jmcarthur> nand`: that would be a dependent sum. something like this in a madeup syntax:    ((x, y) : (Nat, Nat), x <= y)
12:35:26 <luqui> Sonderblade: if you have a type Nat, you could implement your tuples as simple pairs (n,m), where the second component of the tuple is n+m.
12:35:26 <adek05> Better == using State monad would make the code cleaner in that case
12:35:31 <jmcarthur> Sonderblade: ah but those are just runtime checks
12:36:05 <ski> Cale : `Writer's pair is also backward
12:36:11 <luqui> Sonderblade, nonoverlapping is harder, but you could do a similar trick where you always have the list sorted and use the difference from the endpoint of the last one
12:36:20 <ski> .. and `random'
12:36:32 <luqui> Sonderblade, i.e. you can pick a non-dependent representation that has the same invariants as your dependent one
12:36:34 <pordan30> Nil :: IntPairs; Cons :: ∀ (x y : Int) (xs :: IntPairs), x ≤ y → all (≠ (x, y)) xs → IntPairs in inductive style
12:36:41 <bgamari> edwardk, I must say I do like vector-space
12:36:47 <Cale> ski: agreed
12:36:50 <edwardk> bgamari: fair nuff
12:36:58 <Sonderblade> jmcarthur: yes i know, but very useful runtime checks. i've always wished for some general purpose language to have them
12:37:28 <bgamari> oh dear, is "type R2 = (!Double, !Double)" value
12:37:32 <bgamari> valid rather?
12:37:37 <edwardk> no
12:37:50 <jmcarthur> Sonderblade: you could just use smart constructors if you only want a runtime check
12:37:54 <edwardk> you'd need data R2 = R2 {-# UNPACK #-} !Double {-# UNPACK #-} !Double
12:37:56 <luqui> Sonderblade: if all you want is runtime checks, you should just use smart constructors
12:38:00 <nand`> !x isn't a valid type, just a valid pattern / field; no?
12:38:06 <luqui> stereo!
12:38:46 <bgamari> ghc 7.6.1 appears to panic when it sees it
12:38:54 <bgamari> edenc, Yeah, I was just hoping to reuse (,)
12:39:03 <bgamari> oh well
12:39:31 <kirindave> Can't you also do data R2 = R2 {-# UNPACK #-} (Double, Double) ?
12:39:45 <kirindave> I've seen that on the haskell wiki, I'm pretty sure.
12:40:06 <nand`> what about (# Double, Double #) also
12:40:29 <bgamari> edwardk, I guess scalar-vector multiplication in linear has to be done with fmap?
12:40:45 <c_wraith> you can't unpack (Double, Double)
12:41:11 <applicative> Leif_Bork:  I wonder if the funny graphs and trees in http://ropas.snu.ac.kr/~bruno/papers/StructuredGraphs.pdf http://ropas.snu.ac.kr/~bruno/papers/StructuredGraphs.zip couldn't be 'serialized'.  They have a show instance for their Graph type that seems to have the same to capture the elements of the simple Haskell expression
12:41:14 <edwardk> bgamari: https://github.com/ekmett/linear/blob/master/src/Linear/Vector.hs#L46
12:41:17 <c_wraith> You probably can unpack (# !Double, !Double #)
12:41:34 <bgamari> Ahh, I see. I guess I'm just blind
12:41:46 <c_wraith> Though that would be exactly the equivalent of just unpacking two !Double fields
12:42:02 <hpaste> dna pasted “edsl, data-reify” at http://hpaste.org/77831
12:42:10 <Leif_Bork> applicative: Thanks! Interesting!
12:42:17 <nand`> isn't there a flag that auto-unpacks strict fields?
12:42:20 <Sonderblade> luqui, jmcarthur: yes, but if i understand it correctly, they only work for simple constraints, not for exclusion constraints or when the data is constructed in another source than the smart constructor function
12:42:22 <dna_> jmcarthur: i just pasted the approach using data-reify
12:43:11 <dna_> jmcarthur: the problem is, if i just do mapM reifyGraph expression, i lose the sharing between sub-expressions in the list
12:47:13 <applicative> Leif_Bork: their effort is to get a form of 'tying the knot' etc that is robust enough to survive various kinds of transformation, as ones = 1:ones doesn't survive map (+1) and so on
12:47:15 <tibbe> kirindave: you can, but it only unpacks the pair, not the doubles in it
12:47:45 <tibbe> kirindave: data R2 = R2 {-# UNPACK #-} (Double, Double) === data R2 = R2 Double Double
12:47:47 <Leif_Bork> Aah
12:47:48 <luqui> Sonderblade: the point is that data is never constructed anywhere but the smart constructor function.  You can check anything computable with them
12:48:06 <luqui> Sonderblade: you can enforce this with module boundaries
12:48:21 <copumpkin> also note that doing a foldl' over a pair accumulator won't do what you think it will
12:48:28 <copumpkin> assuming you think it will do what it won't do
12:48:30 <copumpkin> ;)
12:49:23 <applicative> kirindave: you can read all about it in tibbe's tutorial
12:49:32 <Sonderblade> luqui: i dont think that would work well with code that deserializes to haskell values. like aeson, persistent and others
12:49:47 <kirindave> Where is your tutorial, tibbe?
12:50:06 <copumpkin> he's gone!
12:50:11 <kirindave> dangiiiiit.
12:50:12 <applicative> here is one http://www.slideshare.net/tibbe/highperformance-haskell
12:50:21 <kirindave> Thanks.
12:51:25 <applicative> the efficiency of my programs increased 1000 x after reading it, but maybe that's not saying much
12:51:42 <Ralith> after reading what?
12:52:05 <copumpkin> lispy: I think you accidentally a founder. Where'd he go?
12:52:34 <johnw> those are good slides
12:53:01 <applicative> here's a sort of case study kirindave http://johantibell.com/files/stanford-2011/performance.html#(1) there are others around, pressing similar points
12:53:07 <Heffalump> copumpkin: I think you accidentally lost a "lost" ;-)
12:53:14 <lispy> copumpkin: wait what?
12:53:29 <copumpkin> Heffalump: oh damn, I often words like that
12:53:43 <applicative> Ralith: http://www.slideshare.net/tibbe/highperformance-haskell
12:53:52 <copumpkin> Heffalump: thanks for catching that :)
12:54:03 <copumpkin> lispy: beats me!
12:54:11 <Heffalump> I was tempted to say "I think you accidentally a" but it would have been rather obscure..
12:54:22 <copumpkin> :)
12:54:48 <nand`> hrm
12:55:33 <jmcarthur> the whole thing!
12:55:34 <hpaste> nand` pasted “Nat pair with smart constructor” at http://hpaste.org/77832
12:55:44 <nand`> I wanted to do this with a GADT constructor but I couldn't figure out how
12:55:58 <kirindave> applicative: Thanks!
12:57:12 <copumpkin> nand`: data Pair where Pair :: (n <= m) -> SNat n -> SNat m -> Pair
12:57:35 <nand`> copumpkin: I guess so, but the intent was to have the actual ‘Pair’ contain the non-singleton versions
12:57:38 <nand`> oh well
12:57:45 <copumpkin> nand`: then you'd need dependent types :P
12:58:33 <hpaste> nand` annotated “Nat pair with smart constructor” with “Nat pair with GADT constructor” at http://hpaste.org/77832#a77834
13:00:25 <copumpkin> nand`: I'm not sure I'd try keeping it as a Constraint rather than a plain old typeclass
13:00:31 <johnw> applicative: thanks for that, it was a good refresher
13:00:35 <copumpkin> I mean a constraint type family
13:00:43 <copumpkin> you can write it as an MPTC or as a GADT witness
13:00:53 <copumpkin> and I think it'll be easier to work with as one of those, but I may be wrong
13:00:58 <nand`> MPTC would work; I just never liked writing out that extension's name
13:01:10 <copumpkin> hah okay
13:01:23 <copumpkin> I often have an MPTC with a method giving me a GADT witness
13:02:11 <copumpkin> because I don't think your current one will actually let you do anything with the information that one is less than the other
13:02:35 <nand`> the idea was just to limit the constructor
13:03:39 <nand`> copumpkin: you mean, like, if another function has an n <= m constraint and you try passing it the values obtained from some Pair?
13:04:00 <copumpkin> if GHC can't figure it out for you, you can't do anything to help it
13:04:14 <copumpkin> you can't write anything manipulating the knowledge that x <= y
13:08:49 <t7> anyone know of a paper that formalizes ADTs and patternmatching in some calculus ?
13:10:40 <nyc> Goddamn I can't stand the waiting for my weight, or more properly, midsection measurement, to come down with this fucking diet.
13:11:06 <nyc> Sorry, wrong channel.
13:12:22 <tac> t7: I think I have one... lemme grab it
13:12:44 <tac> t7: http://www.cs.cmu.edu/~rwh/plbook/book.pdf
13:13:19 <tac> Actually, I think the pattern matching and ADT chapters are disjoint
13:13:24 <tac> but it seems like a nice book
13:16:03 <t7> ah thanks
13:16:52 <arbn> Buy a copy once it's published, too. I'm pretty excited for that one.
13:17:24 <t7> will do :) i need more books
13:26:07 <dna_> :r
13:54:46 * hackagebot stm 2.4.2 - Software Transactional Memory  http://hackage.haskell.org/package/stm-2.4.2 (SimonMarlow)
14:15:02 <DMcGill> The source to yampa-glut is under GPLv3. That means that I can make a netwire-glfw-b using pretty much the same code with some function names changed right? Does that also have to be GPLv3?
14:16:54 * eikke just completed a pretty full-featured NBD (Network Block Device) implementation in plain Haskell, using a design which makes it easy to write a server exposing a normal file (as the demo), or anything else
14:17:44 <hfggh> !LIST
14:19:47 <luqui> Does anyone know if there is a type called "Effect" defined anywhere standard or popular.  Having a hard time tracking down something
14:20:12 <c_wraith> luqui: doesn't ring any bells
14:23:17 <DMcGill> http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=Effect
14:23:37 <DMcGill> a few, there's even an effects package
14:26:21 <cornihilio> I want to write a function that can operate on two kinds of points - 2d (Int, Int, Int) and 3d (Int, Int, Int). How do I do that in Haskell? What's that called? Type inheritance?
14:26:42 <ciaranm> you'll need to make a typeclass
14:27:17 <cornihilio> ciaranm: thank you!
14:29:47 * hackagebot kure 2.4.10 - Combinators for Strategic Programming  http://hackage.haskell.org/package/kure-2.4.10 (NeilSculthorpe)
14:47:51 <nand`> surely vector space type classes exist for this
14:47:59 <nand`> depending on what kinds of operation cornihilio wants
14:59:13 <mroman> @hoogle prime
14:59:14 <lambdabot> Data.HashTable prime :: Int32
14:59:14 <lambdabot> package primes
14:59:14 <lambdabot> package optimusprime
14:59:20 <simpson> Okay, I'm gonna figure out netwire and use it for my events. Is there recommended reading? Do I want netwire 3 or 4?
14:59:47 <parcs`> there's a tutorial in the root module of netwire 4
15:00:06 <parcs`> and use the latest version, of course
15:00:17 <simpson> 'k.
15:00:34 <simpson> How does netwire play with networking? Should/can I use conduits?
15:02:16 <parcs`> sure. netwire just gives you step function and it is up to you how you want to feed it
15:02:42 <simpson> Sweet.
15:18:10 <atriq> I was thinking earlier
15:18:36 <atriq> Maybe a is equivalent to (a -> b, b)
15:18:59 <atriq> I think
15:19:08 <atriq> I can't actually remember the conclusion I reached
15:19:27 <atriq> :t maybe
15:19:28 <lambdabot> b -> (a -> b) -> Maybe a -> b
15:19:35 <atriq> :t maybe Nothing Just
15:19:36 <lambdabot> Maybe a -> Maybe a
15:20:00 <shachaf> (a -> b, b)? How does that work?
15:20:22 <atriq> Wait
15:20:24 <atriq> It really isn;t
15:20:49 <atriq> I don't even know
15:21:26 <shachaf> You're thinking of forall b. (a -> b) -> b -> b
15:21:27 <c_wraith> I can see why you'd think that.
15:21:34 <c_wraith> yeah
15:21:35 <DMcGill> parcs`: does netwire have a reactimate function?
15:21:57 <atriq> shachaf, yeah
15:22:13 <DMcGill> can I just use step or stepWire or something for that effect?
15:25:56 <parcs`> DMcGill: i'm not very familiar with yampa but yes it looks doable with stepWire
15:27:46 <DMcGill> so all my call backs write the event and time to an IORef. My "runGame" function checks that ref and will call stepWire on the wire with that event and the diff between now and the time of the event. Does that sound good to you?
15:29:08 <DMcGill> and then does something with the result of the wire (i.e. draw it to screen)
15:31:53 <mpu> hi, can't I use 'let' on several lines in a do notation?
15:32:15 <startling> mpu: sure
15:32:30 <mpu> startling: I get parsing errors
15:32:39 <startling> mpu: probably something else. let's see your code
15:33:29 <mpu> http://hpaste.org/77836
15:33:53 <simpson> parcs`: Oho! This is nice. Netwire doesn't want me to turn everything inside-out just to glue things together. I like this.
15:34:21 <startling> mpu: dunno for sure but line 12 looks fishy
15:34:37 <rwbarton> lines 8-9 and 13 need to be indented more
15:34:42 <mpu> actually if fails before
15:34:46 <mpu> rwbarton: why?
15:34:52 <rwbarton> because you can writ
15:34:52 <rwbarton> e
15:34:54 <rwbarton> let x = foo
15:34:56 <rwbarton>     y = bar
15:34:59 <rwbarton> more stuff
15:35:08 <mpu> hm, I see
15:35:21 <mpu> this breaks my nice 4 spaces scheme
15:35:22 <rwbarton> so it thinks line 8 is a new declaration in the let block
15:35:37 <rwbarton> if you want to do that you have to put a newline after let
15:35:59 <rwbarton> (or just two 4-space indents)
15:37:00 <fmap> all these Justs look wrong
15:37:48 <fmap> unless you have a Map from something to Maybe anotherthing
15:37:55 <rwbarton> hmm yeah, what is the monad supposed to be
15:39:55 <gertc> from keyValue.at k ?= v what does the from part do? why not just put the from in the keyValue so you can do this keyValue.at k ?= v
15:40:17 <mpu> fmap: yes they are
15:48:48 <mpu> thank you guys
16:09:32 <dancannon> Hi, Im having an issue with pattern matching and data constructors, Could somebody let me know if the following code could possibly work somehow? http://pastebin.com/A7dfdVtC
16:09:36 <mauke> The paste A7dfdVtC has been copied to http://hpaste.org/77837
16:10:30 <Cale> dancannon: Move isn't a data constructor there
16:10:37 <Cale> dancannon: It's a type
16:10:49 <Cale> movePos (Click pos) = pos
16:10:57 <Cale> movePos (Flag pos) = pos
16:11:09 <dancannon> Cale: Ah right, to give more information I want to do a wilcard on Click/Flag
16:11:36 <Cale> dancannon: You might also consider having something like:
16:11:47 <Cale> data MoveType = Click | Flag
16:12:04 <Cale> data Move = Mv MoveType Pos
16:12:13 <Cale> or even:
16:12:18 <Cale> data Move = Move MoveType Pos
16:12:32 <rwbarton> data Move = Mov MvType Pos
16:12:39 <Cale> (The type and data constructor can be named the same because they live in different namespaces)
16:13:00 <Cale> But in any case, that would let you write movePos as you had it
16:13:10 <Cale> movePos (Move _ pos) = pos
16:13:22 <Cale> and that _ matches both Click and Flag now
16:14:18 <dancannon> Cale: Gotcha, I was almost there I had tried MoveType but didnt realise I should add the extra constructor. Thanks very much for your quick help
16:14:49 * hackagebot simple-log 0.2.0 - Simple log for Haskell  http://hackage.haskell.org/package/simple-log-0.2.0 (AlexandrRuchkin)
16:19:51 * hackagebot simple-log-syslog 0.1.0.0 - Syslog backend for simple-log  http://hackage.haskell.org/package/simple-log-syslog-0.1.0.0 (AlexandrRuchkin)
16:36:57 <fengshaun> has anybody here had problems with cabal on archlinux
16:37:13 <fengshaun> #archlinux is not helpful and #arch-haskell is dead
16:37:22 <fengshaun> I can't do cabal update as a normal user
16:37:33 <fengshaun> I get openTCPConnection: host lookup failure for ""
16:37:40 <fengshaun> and hackage.haskell.org is the only site I can't ping
16:41:08 <k00mi> fengshaun: cabal update does work as non-root for me (on arch), but for some reason i can't ping hackage.haskell.org either, though i can access the site
16:42:47 <troydm> k00mi: ping is disabled apparently
16:43:09 <fengshaun> weird
16:43:17 <fengshaun> I can't get it to work without sudo
16:43:46 <fengshaun> then if I use sudo, I can't use the packages I installed without running my programs as sudo
16:44:14 <fengshaun> I have removed .cabal/ several times now
16:44:20 <fengshaun> I guess cabal is just not for me
16:45:20 <luite> fengshaun: if you remove ~/.cabal you also need to remove ~/.ghc
16:45:57 <fengshaun> luite: let me try
16:46:40 <fengshaun> nope, still not working
16:49:50 * hackagebot aterm-utils 0.1.0.0 - Utility functions for working with aterms as generated by Minitermite  http://hackage.haskell.org/package/aterm-utils-0.1.0.0 (JasonDagit)
16:52:07 <startling> s
16:52:21 <geekosaur> p
17:02:03 <Superschrulle> m
17:02:33 <Superschrulle> ok
17:02:45 <Superschrulle> loololoooooooooool
17:13:32 <augur> can i just suggest to anyone interested in continuations that you read Barker and Shan's paper Donkey Anaphora is In-Scope Binding?
17:13:53 <augur> http://www.ling.ohio-state.edu/~plummer/courses/spring09/ling820/barker-shan2008.pdf
17:14:10 <augur> its not about PLT, its about natural language semantics, but they use a continuational approach and introduce a new notation for continuations that i think is incredibly useful
17:14:18 <augur> koninkje_away: ^
17:14:33 <augur> im sure you've read it, koninkje_away, but just in case you havent :)
18:20:27 <hpaste> jtlien pasted “convert vertical column data to vertical lines” at http://hpaste.org/77840
18:30:44 <hpaste> jtlien pasted “converting vertical column data to horizonal lines ” at http://hpaste.org/77841
19:01:16 <neutrino_> hi i have a question
19:01:33 <Ralith> questions are not allowed
19:01:34 <neutrino_> would =<< be a natural combination for a RPN calculator?
19:01:43 <neutrino_> or "useful operator"
19:03:26 <neutrino_> in fact i think it would be >>= in rpn since it's, well, reverse.
19:03:59 <ion> What monad are you thinking of?
19:05:03 <neutrino_> i have no idea
19:05:12 <neutrino_> the one where i can just apply functions
19:05:40 <neutrino_> i just look at =<< as "shift and request argument again"
19:06:23 <neutrino_> for example: pieceRemoveTopMargin = map =<< drop . pieceTopMarginSize
19:08:07 <neutrino_> pieceRemoveTopMargin x = map =<< drop . pieceTopMarginSize x = map =<< drop pieceTopMarginSizeX = map =<< dropMargin = map dropMargin x
19:09:53 <neutrino_> btw, how can i break up a long type signature of the form Foo, Bar, Baz :: Typehere ?
19:10:07 <jmcarthur> neutrino_: the structure of you definition of pieceRemoveTopMargin looks like you really mean (<=<), not (=<<)
19:10:18 <jmcarthur> neutrino_: i also don't really know what you intend, though
19:11:06 <neutrino_> jmcarthur: i use this equation for =<<: x a = y (z a) a  if and only if x = y =<< z
19:11:21 <jmcarthur> neutrino_: what do you mean by the monad where you "can just apply functions"?
19:11:29 <jmcarthur> oh, the function monad
19:11:32 <neutrino_> i don't know
19:11:34 <neutrino_> probably
19:11:51 <jmcarthur> @src (>>=) ((->) a)
19:11:51 <lambdabot> Source not found. My pet ferret can type better than you!
19:11:59 <jmcarthur> i always get that syntax wrong :\
19:12:00 <otters> @src (>>=) (->)
19:12:00 <lambdabot> Source not found. You type like i drive.
19:12:07 <otters> @src (->) (>>=)
19:12:08 <lambdabot> f >>= k = \ r -> k (f r) r
19:12:12 <jmcarthur> that's it
19:12:26 <otters> @pl \f k -> \r -> k (f r) r
19:12:27 <lambdabot> flip flip id . (ap .) . flip (.)
19:13:01 <otters> and there you go, a simple and intuitive definition of (>>=) in the (r ->) monad
19:13:03 <neutrino_> @pl x a = y (z a) a
19:13:04 <lambdabot> x = y =<< z
19:13:10 <jmcarthur> :t fmap join . fmap
19:13:12 <lambdabot> (Monad m, Functor m) => (a1 -> m a) -> m a1 -> m a
19:14:27 <jmcarthur> :t fmap join . fmap :: (a -> b -> c) -> (b -> a) -> (b -> c)
19:14:28 <lambdabot> (a -> b -> c) -> (b -> a) -> b -> c
19:14:40 <slack1256> sometimes API authors define too many datatypes and export them
19:14:46 <jmcarthur> :t (=<<) :: (a -> b -> c) -> (b -> a) -> (b -> c)
19:14:48 <lambdabot> (a -> b -> c) -> (b -> a) -> b -> c
19:15:14 <slack1256> this makes difficult check the relation between them, an old lisp adage says that is better have fewer types and more functions that operate on them than the other way around
19:15:33 <neutrino_> what
19:15:34 <slack1256> but that statement was made before the era a accesible type-systems
19:15:57 <neutrino_> how does that relate to the conversation?
19:16:17 <slack1256> neutrino_: that was to me?
19:17:01 <neutrino_> that was directed at you, yes
19:17:18 <slack1256> so when creating a API, it should be considered relationship between datatype a must or something that better interactivity (with ghci) should solve?
19:17:51 <slack1256> neutrino_: it was not related :), but one can support the burden of two questions on the same channel right?
19:17:54 <neutrino_> are you asking if you should include type signatures in your code?
19:18:05 <slack1256> no.
19:18:06 <rwbarton> I think that adage is still pretty much true
19:18:18 <neutrino_> what are you asking then?
19:18:36 <slack1256> flat out. Should i desing apis like this?
19:18:38 <slack1256> http://hackage.haskell.org/packages/archive/cmdtheline/0.2.1.1/doc/html/System-Console-CmdTheLine-Arg.html#t:OptInfo
19:18:52 <slack1256> check the relation with the Term function
19:19:00 <slack1256> *functor
19:19:59 <neutrino_> looks fine to me..
19:19:59 <slack1256> trying to learn to use that, i wondered if he defined too many ADT, but maybe i lack the domain knowledge that the author had.
19:20:32 <neutrino_> one issue i see is he uses records instead of lenses
19:20:42 <slack1256> neutrino_: that last one is trivial
19:20:44 <neutrino_> haskell records are considered crummy
19:20:56 <slack1256> neutrino:
19:21:17 <otters> what's wrong with records?
19:21:28 <otters> update syntax is about as concise as it could be under the circumstances
19:21:33 <slack1256> neutrino_:let's omit that to don't get into a cheap debate :-)
19:21:45 <slack1256> *so we don't get into
19:23:42 <neutrino_> otters: they pollute the namespace.
19:23:45 <rwbarton> I think the documentation for Term is not as clear as it could be
19:23:53 <otters> neutrino_: oh, that's right
19:23:55 <otters> but lenses do that too
19:24:03 <neutrino_> and the update syntax is nonuniform
19:24:07 <rwbarton> ugh
19:24:08 <otters> it is?
19:24:12 <otters> what does that mean
19:24:13 <neutrino_> yes
19:24:16 <rwbarton> this is like iteratees/lazy io all over again
19:24:33 <neutrino_> it means that sometimes to update you use a function named one thing, sometimes another
19:24:37 <neutrino_> never mind though
19:24:41 <otters> uhhhh
19:24:49 <neutrino_> slack1256: i still don't know what you're asking about
19:24:51 <otters> object { record = value } ?
19:24:59 <slack1256> rwbarton: the good thing is he has a github. when I understand this I'll discuss with him about documentation
19:25:28 * slack1256 should not have said anything about records
19:25:35 <neutrino_> that's ok
19:25:50 <rwbarton> I think it might be clearer (and hopefully correct) to say something like: "A Term represents a value that can depends on the command line arguments"
19:25:50 * slack1256 goes to get a bucket with cold water
19:25:52 <neutrino_> slack1256: it's a good idea to have many functions and few types, yes
19:25:58 <neutrino_> but not fewer types than necessary
19:26:43 <slack1256> neutrino_: the counter part of that idea is that you could end with too many constructors
19:27:21 <slack1256> rwbarton: a Term is clear to use. what i don't understand correctly is the relationship it has with Arg
19:27:55 <slack1256> at the end of the documentation of Arg it defines functions that make Term and Arg almost equal
19:28:36 <rwbarton> I think values of type Arg a are descriptions like "the value of the --foo option" or "the 3rd argument"
19:28:58 <rwbarton> while Term a can be any value built out of those
19:29:23 <rwbarton> I guess if there is no way to inspect the "Arg a"s except by turning them into "Term a"s, then I see exactly your point
19:29:36 <rwbarton> well
19:30:04 <rwbarton> there are multiple ways to do that I guess
19:30:30 <slack1256> simple show instance :-) I'll add one on my copy of cmdtheLine
19:30:50 <slack1256> that relationship make sense, with that the role of Term being a Functor is clearer
19:30:57 <rwbarton> oh it is just a newtype according to the source...
19:30:59 <rwbarton> of Term a
19:31:02 <rwbarton> hm
19:32:11 <neutrino_> slack1256: hmmm, yes, i guess a lot of constructors are a bit annoying, but not so much
19:32:18 <neutrino_> i mean if you have utility for them, that's not too bad
19:32:38 <neutrino_> i guess that's different from just having type aliases
19:32:59 <rwbarton> "as simple as possible, but no simpler" applied to types is a good principle. here it's not currently clear to me why it could not be simpler
19:33:12 <neutrino_> right
19:33:29 <neutrino_> i think the annoying part here is that you have to perform a lot of transformations between types before you can use your data
19:33:40 <neutrino_> so you have to hop around between types and cross fingers
19:34:10 <neutrino_> but i think the problem here isn't that there are too many types, but that there are not enough convenience functions, which take you all the way in a simple step
19:34:54 * hackagebot hledger-lib 0.19.1 - Core data types, parsers and utilities for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-lib-0.19.1 (SimonMichael)
19:34:56 * hackagebot hledger 0.19.1 - The main command-line interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-0.19.1 (SimonMichael)
19:36:37 <slack1256> neutrino_: maybe the base libraries got that right. 1 or 2 datatypes at the top of the modules, 500+ function that operate on them defined by sections
19:38:11 <neutrino_> might be
19:39:17 <zmoazeni> Hey all, does anyone know how to manually fail a parser with attoparsec? I'm parsing something that could have 1, 2 or no results. I'm using "try" and I want to manually fail in the "no results" case
19:39:32 <c_wraith> how severe of a failure?
19:39:41 <c_wraith> Do you want parsing to completely blow up?
19:39:52 <c_wraith> Or do you just want the sub-parser to not match the input?
19:39:54 * hackagebot chu2 2012.11.17 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.17 (JinjingWang)
19:39:56 <zmoazeni> Just simulate a "parse failure" so it will rewind input like it would normally do
19:40:08 <c_wraith> ah, ok
19:40:54 <c_wraith> it's an instance of alternative
19:41:13 <zmoazeni> oh
19:41:17 <c_wraith> So you can signify "no matches" with empty
19:41:41 <zmoazeni> c_wraith: Ah nice, trying now
19:43:47 <zmoazeni> c_wraith: So awesome, thanks a bunch
19:43:53 <c_wraith> you're welcome
19:48:55 <tomboy64> is there a quick-and-dirty way to see just the exports of a module?
19:49:56 <c_wraith> tomboy64: in ghci, you can use :browse Module
19:50:08 <shachaf> :bro
19:50:13 <shachaf> It used to be :b :-(
19:50:35 <tomboy64> great
19:50:36 <neutrino_> how can i break up a type sig of the form Foo, Bar, Baz :: Type?
19:50:38 <tomboy64> thanks
19:50:50 <neutrino_> without repeating "Type"
19:50:55 <geekosaur> huh?
19:51:27 <rwbarton> well you can use indentation and newlines I guess?
19:51:33 <rwbarton> not sure where you are going with this
19:51:54 <byorgey> type Quux = Type; Foo :: Quux; Bar :: Quux; Baz :: Quux
19:51:54 <neutrino_> err the type sig is of the form foo, bar, baz :: Type
19:51:55 <neutrino_> sorry
19:51:59 <byorgey> there, now you don't have to repeat Type
19:52:21 <neutrino_> not too happy about inventing too many type synonyms
19:52:30 * byorgey really isn't sure what neutrino_ want
19:52:33 <byorgey> *wants
19:52:39 <neutrino_> is there no way to have "foo,\nbar,\nbaz :: Type"?
19:52:45 <shachaf> Oh, that explains it.
19:52:45 <neutrino_> something like that at least
19:52:59 <rwbarton> did you try indenting the subsequent lines?
19:53:01 <byorgey> does   foo,\n  bar,\n  baz :: Type  work?
19:53:07 <neutrino_> oh, i haven't rwbarton
19:55:08 <neutrino_> yeah, that worked, but the syntax is a bit unsightly
19:55:19 <neutrino_> maybe i can do [foo, bar, baz] :: [Type]
19:56:36 <neutrino_> hmm, nope
19:57:26 <neutrino_> oh well
19:58:56 <byorgey> neutrino_: how is that any better than  foo, bar, baz :: Type  ?
19:59:28 <byorgey> note you *can* do   foo, bar, baz :: Type;  [foo,bar,baz] = ... list of Type values ...
20:00:15 <rwbarton> $(mapM (\x -> [d|$(x) :: Type]) ['foo, 'bar, 'baz])
20:01:34 <c_wraith> that amuses me
20:01:40 <rwbarton> I guess that doesn't work, foo has to be in scope already
20:01:53 <c_wraith> nothing like massively slowing down compilation time for no real reason!
20:02:06 <rwbarton> $(mapM (\x -> [d|$(mkName x) :: Type]) $ words "foo bar baz")
20:02:10 <rwbarton> or something
20:03:30 <c_wraith> there's no rule that says the type signature needs to be before the definition
20:03:37 <rwbarton> hmm
20:03:45 * rwbarton actually tests
20:04:55 * hackagebot hledger-web 0.19 - A web interface for the hledger accounting tool.  http://hackage.haskell.org/package/hledger-web-0.19 (SimonMichael)
20:05:42 <rwbarton> it doesn't seem to like my splice syntax
20:06:46 <neutrino_> byorgey: mhm
20:07:17 <neutrino_> rwbarton: haha
20:07:21 <neutrino_> rwbarton: i stay away from TH.
20:08:01 <byorgey> c_wraith: haha, somehow I never realized that (that you can put the type signature *after* the definition)
20:08:27 <c_wraith> byorgey: convention is a powerful thing
20:08:28 <rwbarton> c_wraith, it did work eventually with the type signature at the end, and not with it before
20:08:35 <shachaf> What's the convention for {-# INLINE #-}?
20:08:39 <shachaf> Before or after the definition?
20:08:44 <rwbarton> both
20:08:47 <c_wraith> I don't know if there is a convention for that
20:08:47 <rwbarton> let GHC know you mean it
20:08:59 <byorgey> right, and I guess the type signature can actually go anywhere, though multiple clauses of a definition have to stay together
20:08:59 <c_wraith> I see both relatively commonly
20:09:00 <shachaf> What if you put NOINLINE before and INLINE after?
20:09:14 <byorgey> then your computer explodes
20:09:22 <shachaf> I like how many different INLINE pragmas you can give.
20:09:28 <c_wraith> I only know of 3
20:09:29 <rwbarton> NOINLINE applies to code before the definition and INLINE applies to code after
20:09:41 <shachaf> INLINE, NOINLINE, INLINABLE, INLINE[x], INLINE[~x], NOINLINE[x], NOINLINE[~x], ...
20:09:48 <fryguybob> OUTLINE
20:09:58 <c_wraith> aren't the latter ones just stage restrictions, as a hint to the optimizer?
20:10:24 <shachaf> c_wraith: Right.
20:10:45 <shachaf> Well, all of INLINE is hints to the optimizer. :-)
20:10:58 <c_wraith> ok, yeah, good point :)
20:16:15 <neutrino_> @pl minimizeLayer x = head $ minimizePiece [x]
20:16:16 <lambdabot> minimizeLayer = head . minimizePiece . return
20:17:13 <neutrino_> why does the local version of lambdabot return a different version, and tell me to use @pl-resume because time was exceeded?
20:17:16 <neutrino_> this is weird.
20:43:27 <YayMe> Poking at yesod and I do not understand this statement: let submission = Nothing :: Maybe (FileInfo, Text)
20:44:09 <YayMe> am I remembering wrong, isn't :: supposed to be a type guide
20:44:18 <luite> YayMe: the :: is just the type signature
20:44:27 <YayMe> that's what I thought
20:44:36 <luite> so the value is Nothing
20:44:39 <YayMe> Right
20:44:43 <YayMe> which is why I'm confused
20:45:09 <YayMe> Ohh it has a type variable for a constraint regardless of the fact that the Nothing data constructor doesn't include the type value
20:45:13 <luite> the type sig is probably needed because the compiler cannot figure out the type from this value
20:45:35 <parcs`> it's the same as 'let submission :: Maybe (FileInfo,Text); submission = Nothing'
20:45:40 <luite> yeah, a plain  Notthing has type Maybe a
20:45:58 <luite> and the compiler might not be able to figure out what 'a' is
20:46:07 <YayMe> right
20:48:03 <arbn> Maybe (FileInfo, Text) is a valid type for a Nothing value.
20:48:05 <YayMe> I was jut not understanding why it would have a type signature on Nothing so didn't think it was a sig to begin with. But thinking about it I understand why; even though nothing doesn't have the type variable, it is still constrained to it as a part of it's type now due to the sig so it does carry that and is useful
20:48:54 <arbn> YayMe: Nothing is just a constructor for Maybe (FileInfo, Text) in this case. It means there is no Maybe (FileInfo, Text) value there, but there could be.
20:49:09 <YayMe> right
20:49:12 <YayMe> makes sense
20:50:13 <YayMe> I feel like yesod is using a DSL in some of it's .hs files... that let submission line is in a function that doesn't reference "submission" again for the length of it...
20:51:03 <luite> YayMe: hamlet templates can refer to a variable in scope
20:51:06 <YayMe> I must be misunderstanding this haskell though.. they wouldn't make a DSL out of this
20:51:13 <YayMe> luite: this isn't the hamlet though
20:51:23 <YayMe> luite: oh, in scope of the method?
20:51:32 <YayMe> luite: because submission is referenced in the hamlet...
20:51:44 <luite> yeah, everything in scope where the hamlet file/qq is inserted
20:52:54 <YayMe> so in the getHomeR function if I create a variable, the hamlet can access that variable even though the variable isn't the return value or passed to anything etc.. ?
20:53:08 <YayMe> that is really weird....
20:53:35 <rwbarton> welcome to macros (template haskell)
20:53:46 <shachaf> TH usually makes me sad. :-(
20:54:07 <shachaf> johnw is not surprised.
20:54:23 <luite> YayMe: yeah, only hamlet inserted in that function though
20:54:30 <YayMe> rwbarton: But doesn't that violate all the happy fun purity?
20:54:35 <rwbarton> no
20:54:47 <rwbarton> a thing in $(...) gets replaced by some other code at compile time
20:54:59 <YayMe> ahh
20:55:15 <YayMe> I thought it was some odd function I didn't recognize, which seemed strange
20:55:46 <arbn> YayMe: The template in the other file generates more monadic code at compile-time, yeah. So, it actually happens before the return expression of the do-block, so it's in the same lexical scope.
20:55:48 <rwbarton> it does mean you can't rename variables safely without knowing exactly what the $(...) expands to
20:56:11 <YayMe> luite: I'm starting to kind of see how these methods layout, i can kind of relate it to the nitrogen framework in erlang how it sequences elements in an array, but in yesod you sequence them in a monad
20:56:29 <shachaf> If I have some TH code which is really slow, is it possible to get GHC to compile it with -O2 and run it, rather than using the bytecode interpreter?
20:56:36 <YayMe> rwbarton: Ok, so it doesn't violate purity, but it violates what is that, referential transparency?
20:56:52 <rwbarton> sort of
20:57:12 <YayMe> I feel like it's breaking one of the tennets of haskell..
20:57:24 <arbn> YayMe: Because you could change the stuff in the template file?
20:57:27 <YayMe> ...tenets...tenents..screw it
20:57:34 <luite> YayMe: hmm, the monads are not really yesod specific, they're fairly standard monad uses
20:57:36 <rwbarton> well it is just replaced by ordinary haskell code
20:57:43 <YayMe> gotcha
20:57:51 <rwbarton> after the replacement, you can rename all you like
20:57:53 <bmer> Hey guys, maybe it's because I haven't eaten for the last 24 hours, but I am a little frustrated. I am a Haskell newbie, and I need some help on how to select/and or configure an editor I can use to comfortably code in Haskell (i.e. it takes care of all the indentation for me). Now, I heard Notepad++ could do that, but my vanilla setup is not doing it automatically. I am not sure what I am missing either. Same thing with Sublime Text 
20:57:57 <arbn> YayMe: Explain how it violates referential transparency. I don't see it.
20:57:59 <rwbarton> the expansion, would be a better term
20:58:03 <luite> Handler is IO with some state to get the request and global yesod object out
20:58:04 <YayMe> so like you said, macros; but in the C++ sense no? Or more the lisp macro?
20:58:25 <rwbarton> more like lisp macros but there's no fundamental difference
20:59:00 <bmer> This might be the most whiney, begging question on #haskell ever, and I am sorry. I should probably do some more Google searches...
20:59:14 <arbn> Isn't Handler a type synonym for ReaderT or something?
20:59:21 <arbn> I know it's some ordinary monad.
20:59:41 <YayMe> arbn: I think it's the separate file thing; it doesn't actually violate it but it just...feels odd that the variable defined is accessible to things that it wasn't explicitly given access to right there... TH does move that stuff into there so it's not violating anything.. it's just, odd
20:59:44 <shachaf> bmer: Almost any editor will do just fine.
21:00:05 <shachaf> Since indentation is significant in Haskell, the editor can't quite "take care of all" of it for you.
21:00:16 <arbn> YayMe: A *lot* of people find Yesod very inelegant because of its use of TH. If you feel that way, you might like Snap better.
21:00:18 <shachaf> But you shouldn't really care about your editor.
21:00:33 <bmer> shachaf: I don't want to spend a lot of time trying to carefully align the "|" bellow the first equal signs in a data type definition for instance
21:01:02 <arbn> bmer: The only editor I've found that does good auto-indentation for Haskell, would be emacs with haskell-mode.
21:01:03 <shachaf> bmer: Even if you had to type every single space manually, this would be a very small portion of the time spent writing code.
21:01:12 <bmer> hmm
21:01:12 <shachaf> It's really not worth worrying about.
21:01:34 <arbn> bmer: But, really, it's not a big deal, like shachaf says. I know someone who does his spacing manually in Notepad++, and is very productive.
21:01:47 <luite> YayMe: yeah some people want a clearer distinction between the hamlet-accessible things and the rest, a proposal was that only things with some specific name would be usable in hamlet. but i think that in the end, convenience won :) since all things hamlet can do are pure, nothing can have nasty side effects anyway
21:02:02 <YayMe> bmer: I second emacs, haskell is what caused me to learn it, but more importantly than the editor, seriously you ought not be having so much trouble with spacing...
21:02:05 <bmer> that's oddly, relieving to hear, if there isn't a "much better" way out there, then I am probably mostly okay, alright, thank you very much arbn and schachaf
21:02:41 <shachaf> Hmm, maybe there should be an editor question on the FAQ.
21:02:45 <shachaf> Not that anyone ever reads the FAQ...
21:03:05 <arbn> Haskell made me switch from vim to emacs, and I haven't quite forgiven it yet. :P
21:03:06 <YayMe> ...there's an faq? :)
21:03:07 <bmer> I went through the list of Haskell editors on the wiki
21:03:31 <YayMe> arbn: it made me switch from over a decade in visual studio... I forgave it promptly :)
21:03:34 <luite> YayMe: that said, if you really hate it, you can switch to another template engine, even with yesod :)
21:04:46 <johnw> I have lots of fun with Haskell in Emacs
21:05:12 <parcs`> shachaf: put the code in a separate module, compile it and then call the compiled function from a splice
21:05:12 <YayMe> luite: I tend to have faith in the process of canonicalization for haskell, if the community has stood up and declared hamlet correctest for now I'll go with that. But that's just haskell and partially because I'm still too lame at it to make strong analysis of competing approaches on my own
21:05:54 <arbn> YayMe: They haven't. There are a lot of people that don't like the design of Yesod, so you're not alone. Look at Snap and compare, then make up your own mind.
21:05:59 <luite> YayMe: there is no real concensus
21:06:05 <shachaf> parcs`: Hmm, that works?
21:06:39 <parcs`> shachaf: it should, because that's how it works in ghci
21:06:49 <YayMe> luite arbn: gotcha. Will install snap and give it a look. What I really want is the nitrogen framework with haskell's syntax
21:06:58 <shachaf> parcs`: Sounds good, thanks!
21:07:04 <shachaf> parcs++
21:07:10 <YayMe> arbn: Any familiarity with the nitrogen framework?
21:07:36 <arbn> YayMe: Nope. My webdev background was with Django, and then I learned and used Yesod, and I'm planning on looking into Snap soon.
21:07:47 <luite> YayMe: main alternatives: heist has a much stricter separation between code and templates, no compile time checking, explicitly pass parameters to templates. hsx is a haskell preprocessor where you have haskell in template files (like asp or php), you can do everything in templates.
21:07:57 <luite> YayMe: hamlet is sort of in the middle
21:08:23 <rwbarton> is there something between Lens and Traversal for zero-or-one?
21:08:58 <edwardk> rwbarton: not that i can package up nicely. you can make one though using Data.Pointed if you want, but they won't auto promote to full traversals, etc.
21:09:26 <rwbarton> also/alternatively: is there something like at but that's a SimpleIndexedTraversal (m v) v?
21:09:33 <edwardk> type PartialLens s t a b = forall f. (Pointed f, Functor f) => (a -> f b) -> s -> f t
21:09:45 <edwardk> :t traverseAt
21:09:47 <lambdabot> (Applicative f, At k m, Indexed k k1) => k -> k1 (v -> f v) (m v -> f (m v))
21:09:50 <YayMe> luite: my ideal is actually no templates. I've recently come to the conclusion HTML is a bad language end of story. It should be generated for us like assembly, it is after all the lowest level language of the web.
21:10:01 <rwbarton> aha
21:10:18 <edwardk> if Pointed was a superclass of Applicative you could use partiallenses as traversals automatically and all this would just work
21:10:22 <rwbarton> yeah
21:10:51 <shachaf> edwardk: I thought you were on the anti-Pointed side? :-)
21:10:53 <edwardk> if Apply was a superclass of Applicative you could use non-empty traversals as a traversals as well, and safely apply Min, Max, etc. to them
21:11:05 <edwardk> shachaf: i am, but it doesn't preclude me mentioning their actual usecase here.
21:11:07 <YayMe> http://nitrogenproject.com/demos/dragdrop and have a look at the source. Completely defined by object model, no markup.
21:11:42 <rwbarton> I'm messing around with alternatives to aeson-lens which is a little too overloaded for my taste
21:11:44 <edwardk> what i tend to endorse is to just use construct them as arbitrary traversals and use ^? and .~ to update them
21:11:46 <luite> YayMe: still some #span, <br>, #p
21:11:49 <YayMe> http://www.seaside.st/about/examples/task?_k=fQBCjQAs and another framework, this one in smalltalk
21:12:05 <edwardk> my problem with aeson lens is at last check some of their lenses aren't real lenses
21:12:16 <rwbarton> that was another problem I had
21:12:23 <luite> YayMe: if you want to generate html directly from haskell without templates, you can use blaze-html directly (it's what hamlet TH code compiles to)
21:12:35 <rwbarton> however, I don't understand why every type signature contains (FromJSON v, ToJSON v)
21:12:38 <edwardk> i welcome a better design. i've had no bandwidth to devote to them
21:12:45 <rwbarton> yeah, I will experiment
21:12:57 <edwardk> rwbarton: as opposed to the more overloaded FromJSON v, ToJSON u?
21:13:05 <rwbarton> heh
21:13:22 <edwardk> try using .~ or ^. on the more overloaded form without a signature. =(
21:13:27 <luite> YayMe: but i don't think any of the existing frameworks/template things come with a ready to use #draggable etc
21:13:31 <YayMe> luite: true, but by and large it allows you to lay out and create controls without html, a <br> here and there in your text isn't that big a deal compared to having to tie it all up
21:13:35 <rwbarton> I would rather not touch FromJSON/ToJSON at all
21:13:51 <edwardk> even better. this leads me to hope for your design
21:14:13 <YayMe> luite: I bring these up because when I was reading about different haskell frameworks, I didn't find much info on snaplets but what little I did sounded like it *might* have stuff similar
21:14:48 <luite> YayMe: in yesod, this would be a widget
21:14:52 <bmer> Thank you so much everyone, you were very patient with me :) Good night everyone, I love you all and Haskell
21:14:58 <YayMe> luite: thanks for mentioning the blaze-html though, I'll have to look at that; if it has a simple enough api it might not be difficult to put an abstraction over it for doing some simplistic things
21:15:25 <rwbarton> :t (^!)
21:15:27 <lambdabot> Monad m => s -> Acting m a s t a b -> m a
21:15:36 <luite> YayMe: a widget keeps track of some generated html and javascript. you insert it with ^{ } in hamlet
21:16:07 <YayMe> luite: cool, does it also have a tracked value in the function the hamlet TH is injected in?
21:16:52 <luite> YayMe: like an id you can refer to or something?
21:18:11 <rwbarton> the SimpleLens (Maybe s) (Maybe a) approach seems tolerable
21:18:33 <luite> YayMe: don't think there is
21:18:43 <rwbarton> though is that a legitimate lens? hmm
21:19:29 <edwardk> > "hello"^!traverse.act (\x -> [x,succ x])
21:19:32 <lambdabot>   No instance for (Data.Monoid.Monoid GHC.Types.Char)
21:19:32 <lambdabot>    arising from a use o...
21:19:34 <edwardk> hrmm
21:19:44 <edwardk> hrmm i don't have a ^!. =)
21:19:49 <YayMe> Ok. I come from years in ASP.NET so how the client side controls are accessed and values pulled out of them on server side is something I'm still trying to work out in my head
21:20:14 <rwbarton> if I have a law-abiding (total) lens SimpleLens s a then s ~ (a, b) for some b, right? at least "morally", even if I can't write b in Haskell necessarily?
21:20:27 <edwardk> rwbarton: yes
21:20:38 <rwbarton> okay
21:20:39 <luite> YayMe: yeah the only place where that's really automated is for forms
21:20:46 <edwardk> morally van laarhoven lenses and isomorphism lenses are the same
21:20:50 <YayMe> rwbarton: I have heard lens mentioned every single time I've been in here in the past 3 months... are lenses going to make haskell something spectularly amazing? Is it going to be as important to know lens in a year as it is to know attoparsec/parsec ?
21:20:54 <Sonarpulse> I have a data decleration in the forum of mydata = struct1 _ _ | struct2 _ _
21:21:00 <rwbarton> and clearly Maybe Value /~ (Maybe Number, b) for any b
21:21:22 <Sonarpulse> is there anyway I can pattern match which one it is in another function?
21:21:29 <shachaf> edwardk: What's that supposed to result in?
21:21:29 <edwardk> rwbarton: true
21:22:32 <edwardk> shachaf: i was trying to see if i could get a nice list of characters using the list monad. and an action.
21:22:49 <rwbarton> :t (^?!)
21:22:51 <lambdabot>     Not in scope: `^?!'
21:22:52 <lambdabot>     Perhaps you meant one of these:
21:22:52 <lambdabot>       `^!' (imported from Control.Lens),
21:22:52 <luite> YayMe: usually some variation of formlets is used (yesod-form, digestive-functors)
21:23:13 <rwbarton> kind of want to use something like this for "listToMaybe that fails at runtime if there is more than one"
21:23:15 <edwardk> the action stuff never really got used once i worked out that you couldn't do monadic lenses with nice properties
21:23:32 <rwbarton> probably this is a bad direction to go though
21:24:24 <edwardk> yeah messy. ^? will succeed if there are too many targets for that same reason
21:25:24 <rwbarton> but... I might want to do a "downcast" of some Value to Array, and then perform a traversal on that list
21:25:42 <luite> YayMe: but in general, you still have to do way more by hand with haskell web frameworks. there has been some talk about frp for web, but you need to be able to compile haskel (or a subset) to javascript for that, which is currently rather experimental
21:26:15 <rwbarton> then I don't have any way to express that the first step should be zero-or-one but the second step should be zero-or-one-or-many
21:26:20 <carter> @messages
21:26:21 <lambdabot> edwardk said 59m 11s ago: http://iamlasun8.mathematik.uni-karlsruhe.de/~ae16/preprnts/slides_neher_2003_aca03.pdf is a good, practical, taylor model overview
21:27:28 <Sonarpulse> Ok, I see how this normall works with something like f (constructor a b) =
21:27:53 <edwardk> right now i don't capture the 0-or-1-ness well in lens. the 'correct' way for me to do that would be to require a lot more classes for Traversals, e.g. type Traversal s t a b = forall f. (Applicative f, Apply f, Pointed f) => ...
21:27:59 <Sonarpulse> but say the function in question takes a list of them?
21:28:19 <YayMe> luite: frp for web?
21:28:21 <Sonarpulse> [constructor a b] seemsto only match for a single element list
21:28:23 <shachaf> Or to require a better hierarchy. :-)
21:28:42 <luite> YayMe: yes, functiona reactive programming
21:28:44 <luite> +l
21:28:54 <edwardk> then partial lenses and non-empty traversals would magically upgrade to traversals, but this means that you can't use them with user types without a bunch of instances, and the extra instance passing slows stuff down, etc.
21:29:11 <rwbarton> I see
21:29:23 <rwbarton> I think I'll just stick with traversals and not encode the fact that they are zero-or-one
21:29:34 <Sonarpulse> do you do something like cnstr a  => (a:[a]) ?
21:30:07 <YayMe> luite: reactive being the fancy new name for CPS because node is new and fresh and everyone knows it's not the same as that stuff that was designed decades ago ?
21:30:57 <shachaf> Zero-or-one traversals would be nice even just for having a different name than "traverse".
21:31:43 <shachaf> foo.traverse.blah works for Maybe but always seems a bit confusing to me.
21:32:30 <luite> YayMe: no, haskell has lightweight threads, so copying node ugliness is not something haskellers tend to do ;p
21:33:36 <YayMe> luite: I know, which is why I was curious, I saw a recent addition to C# being referred to as "reactive" that looked like the .NET team trying to play off the success of node by giving CPS some better libraries and facilities
21:34:35 <YayMe> though it's also possible I was misunderstanding what I read about the new reactive additions to .NET
21:34:41 <edwardk> shachaf: yeah, the issue with them is they make traversals harder/slower. and those seem a little more important to me ;) if i didn't have to pay a "correctness tax" for every traversal i'd be all about them
21:34:53 <edwardk> shachaf: that and it adds a dependency on a package i don't particularly like
21:35:06 <shachaf> edwardk: The issue with what, Pointer-style traversals?
21:35:21 <edwardk> pointed-style, yes
21:35:27 <shachaf> Er, yes, that.
21:35:42 <luite> YayMe: in general it's a way to describe how the system reacts to environment and time, with events and behaviours, see some netwire, yampa, reactive-banana introduction
21:36:21 <luite> YayMe: there are lots of libs, since it's not really a solved problem yet :)
21:36:27 <edwardk> :t let f?g = f.traverse.g in (?)
21:36:29 <lambdabot> Parse error in pattern: ?g
21:36:33 <edwardk> aw
21:37:05 <shachaf> ImplicitParams
21:37:14 <edwardk> @type let f ? g = f.traverse.g in (?)
21:37:15 <lambdabot> (Functor f, Applicative f1, Traversable t) => ((t a -> f1 (t b1)) -> b) -> f (a -> f1 b1) -> f b
21:37:49 <shachaf> When is inferring nice signatures for lenses going to go into GHC?
21:37:58 <edwardk> heh
21:38:11 <YayMe> luite: Gotcha, I must have misunderstood it in .NET because CPS was the only reasonable way to do it in .NET and it was being mentioned in relation to ASP.NET so it just looked like something for the web that was a huge hodgepodge of CPS ala node
21:38:12 <shachaf> For that matter, I think GHC should strive to avoid "t1"-style names.
21:38:36 <shachaf> CPS ala node? Is that a dessert?
21:39:01 <YayMe> one that tastes like nests
21:40:06 <Sonarpulse> sorry but anybody know the solution to my problem?
21:40:21 <shachaf> No one even knows what your problem is.
21:41:02 <Sonarpulse> https://github.com/Sonarpulse/CnC-Red-Alert/blob/mixer/Codec/Archive/CnCMix/TD.hs
21:41:19 <Sonarpulse> look at loadNames and saveNames
21:41:42 <Sonarpulse> it typechecks but the patern match is not what I want
21:41:59 <rwbarton> @type traverseAt
21:41:59 <ion> Is there a nice way to build an AST and generate Haskell code out of it? I’m not very happy with the ad-hoc code generation i use in https://github.com/ion1/beagle_bone_pins/blob/master/Generate/Haskell.hs
21:42:00 <lambdabot> (Applicative f, At k m, Indexed k k1) => k -> k1 (v -> f v) (m v -> f (m v))
21:42:02 <Sonarpulse> the data definition for File is in https://github.com/Sonarpulse/CnC-Red-Alert/blob/mixer/Codec/Archive/CnCMix/Backend.hs
21:42:15 <rwbarton> @type at
21:42:17 <lambdabot> (Functor f, At k m, Indexed k k1) => k -> k1 (Maybe v -> f (Maybe v)) (m v -> f (m v))
21:43:32 <shachaf> Sonarpulse: Hmm, aren't you the person who was making all those gratuitous type classes? :-(
21:43:40 <shachaf> Anyway, I'd recommend adding type signatures.
21:43:41 <edwardk> traverseAt k = at k <. traverse
21:45:50 <rwbarton> @type (<.)
21:45:52 <lambdabot> Indexed i k => Index i b c -> (a -> b) -> k a c
21:46:15 <edwardk> @type (<.>)
21:46:17 <lambdabot>     Ambiguous occurrence `<.>'
21:46:17 <lambdabot>     It could refer to either `Data.VectorSpace.<.>',
21:46:17 <lambdabot>                              imported from `Data.VectorSpace' at State/L.hs:77:1-44
21:46:18 <rwbarton> i can just use (.) if i'm not using the indexed part?
21:46:22 <edwardk> yes
21:46:32 <arbn> Can Cabal be used with a compiler other than the compilers it has flags for? I am somewhat curious whether it's possible to package up a Fay library using Cabal.
21:46:35 <edwardk> . will dumb an indexed foo down to a normal foo
21:46:54 <edwardk> <. will keep the index from the left, .> from the right <.> will pair them up
21:47:24 <edwardk> arbn: afaik you need to patch cabal to really use anything else
21:47:34 <edwardk> my attempts led me in that direction anyways
21:48:48 <arbn> edwardk: OK. Thanks. I guess that's a probable "no" for now, then. Maybe if Fay becomes popular, Cabal will support it.
21:48:50 <luite> yeah and it's not really built to be easily extensible
21:55:38 <Sonarpulse> schachaf, yes it is me with all the typeclasses :D
21:56:22 <Sonarpulse> the type in both cases is [File] -> [File]
21:56:48 <shachaf> Why do you have a function that takes a list of things and only works for a single-element list?
21:57:03 <Sonarpulse> thats the problem
21:57:06 <Sonarpulse> I didn't want to do that
21:57:19 <Sonarpulse> but each list will either be all one type of the file
21:57:25 <Sonarpulse> or the other type of File
21:57:28 <shachaf> What?
21:58:08 <Sonarpulse> Data File = FileW Word32 ByteString | FileS string ByteString
21:58:31 <Sonarpulse> I either have a list of FileW or list of FileS
21:59:57 * hackagebot chu2 2012.11.17.1 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.17.1 (JinjingWang)
21:59:59 * hackagebot chu2 2012.11.17.2 - FFI for Chu2 Agda Web Server Interface  http://hackage.haskell.org/package/chu2-2012.11.17.2 (JinjingWang)
22:00:14 <shachaf> If you want to keep that clear in the type, why not have separate types?
22:00:28 <Sonarpulse> That did occur to me
22:00:32 <shachaf> foo :: Either [FileW] [FileS]
22:00:36 <shachaf> Or who knows.
22:00:49 <Sonarpulse> I am pretty sure I have some functions that operate on both though
22:01:21 <Sonarpulse> When you use Either, to you also need a fromEither?
22:01:36 <shachaf> What's fromEither?
22:01:46 <shachaf> @ty view chosen
22:01:48 <lambdabot> Either a a -> a
22:01:57 <shachaf> (Not that that function is relevant to you.)
22:02:11 <Sonarpulse> ok
22:02:20 <shachaf> ?
22:02:34 <Sonarpulse> if I have a :: Either String Word32
22:02:49 <Sonarpulse> and f :: Word32 -> something
22:03:02 <Sonarpulse> is "f a" valid?
22:03:05 <shachaf> No.
22:03:07 <Sonarpulse> that is what I was trying to get at
22:03:08 <Clint> you want to learn about fmap
22:03:32 <shachaf> What would it do when a is Right?
22:03:33 <Sonarpulse> I have read a bit on functors
22:03:51 <rwbarton> though you should first learn about pattern matching, if you haven't already, and then about "either"
22:03:59 <shachaf> Yes.
22:04:11 <shachaf> Also, you should learn about pattern matching way, way before you learn about or use type classes.
22:04:17 <shachaf> It's much more fundamental.
22:04:45 <Sonarpulse> Ok
22:05:06 <shachaf> @ty over traverseLeft
22:05:08 <lambdabot> (a -> b) -> Either a c -> Either b c
22:05:15 <shachaf> traverseLeft is an awfully long name. :-(
22:05:35 <shachaf> Is that just because "left" is taken by Zipper, or what?
22:05:41 <rwbarton> i've been naming my json lenses 'asObject', 'asArray' etc.
22:05:52 <rwbarton> where by lenses i mean traversals
22:06:05 <shachaf> > asin 1
22:06:07 <lambdabot>   1.5707963267948966
22:06:14 <Sonarpulse> Either is an algebraic datatype right?
22:06:35 <shachaf> Yes. But that's just a word. :-)
22:06:43 <Sonarpulse> yeah
22:07:33 <Sonarpulse> In general though, isn't there an extensions that allows pattern matching beyond
22:07:50 <Sonarpulse> (constructor p1 p2 p3 ... pN) ?
22:07:55 <Sonarpulse> coudln't I use that here?
22:08:32 <shachaf> I don't know what "here" is.
22:08:47 <Sonarpulse> with my saveNames and loadNames problem
22:08:56 <Sonarpulse> with File as a sum type
22:09:15 <Sonarpulse> (is it still called a sum type when the constructors have parameters?)
22:10:19 <shachaf> > let left = traverseLeft in over left succ (Left 5)
22:10:22 <lambdabot>   Left 6
22:10:54 <mikeplus64> @src over
22:10:54 <lambdabot> Source not found. Just what do you think you're doing Dave?
22:11:30 <rwbarton> :t over traverseLeft
22:11:32 <lambdabot> (a -> b) -> Either a c -> Either b c
22:11:32 <rwbarton> :t left
22:11:34 <lambdabot>     Ambiguous occurrence `left'
22:11:35 <lambdabot>     It could refer to either `Control.Arrow.left',
22:11:35 <lambdabot>                              imported from `Control.Arrow' at State/L.hs:5:1-20
22:11:37 <rwbarton> oh you
22:11:40 <mikeplus64> :t over
22:11:42 <lambdabot> Setting s t a b -> (a -> b) -> s -> t
22:11:43 <shachaf> left is used in Control.Lens.Zipper
22:11:44 <mikeplus64> :i over
22:11:45 <rwbarton> :t Control.Arrow.left
22:11:47 <lambdabot> ArrowChoice a => a b c -> a (Either b d) (Either c d)
22:11:54 <shachaf> Oh, and Control.Arrow
22:12:11 <shachaf> lefts is used in Data.Either and Control.Lens.Zipper
22:12:33 <edwardk> the zipper code is a little greedy about names
22:14:46 <Sonarpulse> :t Either
22:14:48 <lambdabot>     Not in scope: data constructor `Either'
22:14:48 <lambdabot>     Perhaps you meant `Other' (imported from Math.OEIS)
22:14:57 <Sonarpulse> what do I need to include
22:15:03 <shachaf> Nothin'
22:15:17 <shachaf> Oh, you should include Hoogle in your set of tools:
22:15:19 <shachaf> @where hoogle
22:15:20 <lambdabot> http://haskell.org/hoogle
22:15:25 <Sonarpulse> but in my ghci it was also not in scope
22:15:41 <shachaf> Sonarpulse: It's in scope.
22:15:52 <shachaf> Try :i
22:15:53 <rwbarton> it's just not a value
22:16:20 <shachaf> @quote rwbarton
22:16:21 <lambdabot> rwbarton says: Num works for Float/Double, it's Float/Double that doesn't work for Num
22:16:31 <Sonarpulse> what is the corosponding constructor then?
22:16:40 <shachaf> Sonarpulse: :i will tell you that, too.
22:16:45 <shachaf> So will Hoogle. :-)
22:16:49 <Sonarpulse> ok
22:17:06 <Sonarpulse> and you were saying add hoogle to ghci?
22:17:12 <Sonarpulse> with .ghci or something similar?
22:17:46 <shachaf> So will most any introduction to Haskell, by the way.
22:17:52 <shachaf> No, I was saying use that web page I linked to.
22:18:19 <Sonarpulse> I have used hoogle, it is nice
22:20:06 <Sonarpulse> ooo! I just learned that you can use "/latest/" instead of "/version-number/" in a haskell URL
22:20:10 <Sonarpulse> now THAT is usefull
22:21:43 <Sonarpulse> Ok, now i got a problem I have been avoiding for quite awhile
22:21:45 <Sonarpulse> https://github.com/Sonarpulse/CnC-Red-Alert/blob/mixer/Codec/Archive/CnCMix.hs
22:22:10 <Sonarpulse> at the bottom there is a function called detect
22:22:19 <shachaf> But no type signature!
22:22:22 <shachaf> Why not?
22:22:37 <Sonarpulse> no good reason
22:22:55 <Sonarpulse> I can give it to you, and off the top of my head too to somewhat legitimize it :)
22:23:14 <shachaf> Your function should probably have a type like Word32 -> MixType
22:23:21 <shachaf> No need to tangle up the Data.Binary nonsense into it.
22:23:45 <Sonarpulse> well, at some level i will be using run get,
22:24:13 <Sonarpulse> this is a lazy byteString head ::: BS -> word8
22:24:24 <Sonarpulse> but no equivalent for Word32
22:24:46 <Sonarpulse> the problem is I want to dispatch based on it's return
22:24:53 <rwbarton> "import Data.Bool", huh
22:25:32 * shachaf didn't know about Data.Bool
22:25:33 <Sonarpulse> and I think I have learned enough enough HM typing so I know
22:25:40 <shachaf> Isn't everything it exports in the Prelude?
22:25:52 <rwbarton> i think so
22:26:07 <shachaf> "dispatch based on it's return"?
22:26:15 <Sonarpulse> f a = (decode :: ByteString -> a) is NOT going to work
22:26:24 <shachaf> Do you mean case detect x of RedAlert -> ...; TiberianSun -> ...?
22:26:34 <shachaf> ?
22:26:34 <Sonarpulse> yeah
22:26:43 * shachaf is confused.
22:26:56 <shachaf> (You may also be.)
22:27:00 <Sonarpulse> each one of those informally corosponds to an implementino of Binary
22:27:23 <Sonarpulse> problem with type classes is it's encodeFile for all of them
22:27:28 <Sonarpulse> * decode
22:27:35 <Sonarpulse> and the imput value is always a bytestring
22:27:56 <shachaf> Maybe type classes should be an advanced feature of Haskell that you have to unlock.
22:27:59 <Sonarpulse> to know how to deserialize the raw ByteString is an inherently run-time problem
22:28:15 <Sonarpulse> I know, I am writing my own argument on why not to use them
22:28:20 <Sonarpulse> despite all my other intentinos
22:28:38 <Sonarpulse> I mean I really wouldn't, but Data.Binary strongly pushes me in that direction
22:29:03 <Sonarpulse> or so i feel
22:29:04 <shachaf> It does?
22:29:33 <Sonarpulse> you import it it all by default, the docks suggest that
22:29:56 <Sonarpulse> internally it defines the same typeclasses for a bunch of stuff
22:30:10 <shachaf> OK, I don't think I can help. :-)
22:30:13 <Sonarpulse> and you do get "free" derived functions
22:30:31 <Sonarpulse> Well, for this problem I am willing to abandon typeclasses
22:30:35 <Sonarpulse> and refactor everything
22:31:12 <Sonarpulse> but even if I did, I still have the problem of dynamically choosing which decode<TypeName> to use
22:31:48 <rwbarton> that's not really a "problem"
22:31:50 <rwbarton> you just do it
22:31:59 <Sonarpulse> really?
22:32:20 <Sonarpulse> but then my return type is ambiguous
22:32:22 <rwbarton> where is the code that wants to call detect? does it exist yet?
22:32:39 <rwbarton> you will need to return a sum type
22:32:39 <Sonarpulse> well right now its defined in Codec.Archive.CnCMix.TD
22:33:02 <Sonarpulse> that is where the instance Binary is defined
22:33:36 <Sonarpulse> I can do "type Mix = TD.mix | RA.mix | etc"
22:34:20 <Sonarpulse> ideally I would make "dispatch" a function that takes an overloaded function
22:34:34 <shachaf> That doesn't sound ideal to me.
22:34:55 <rwbarton> data Mix = TD TD.Mix | RA RA.Mix | ...
22:35:16 <shachaf> Well, assuming that "overloaded" means "type-based dispatch".
22:36:10 <Sonarpulse> one thing that took me a while to understand was that (classname a) is a type constraint
22:36:26 <Sonarpulse> while (algebraic A) is a type in itself
22:36:27 <rwbarton> getMix = do { mixType <- getWord32le; case mixType of { 0x00010000 -> do { tdMix <- get; return TD tdMix } ; ... } }
22:37:49 <Sonarpulse> back to your sum type definition, why do you have TD TD.Mix ?
22:38:04 <rwbarton> do you understand Either?
22:38:07 <rwbarton> @src Either
22:38:08 <lambdabot> Source not found. My pet ferret can type better than you!
22:38:15 <rwbarton> (??)
22:38:20 <Sonarpulse> one sec
22:38:28 <Sonarpulse> it might be an issue of type vs data/newtype
22:38:43 <shachaf> rwbarton: I bet Lambdabot 2.0 wouldn't have that problem.
22:38:50 <rwbarton> seriously what
22:38:54 <rwbarton> @src Maybe
22:38:55 <lambdabot> data Maybe a = Nothing | Just a
22:38:59 <rwbarton> @src Either
22:39:00 <lambdabot> Source not found. Maybe if you used more than just two fingers...
22:39:02 <rwbarton> @src Either a
22:39:02 <lambdabot> Source not found. Maybe you made a typo?
22:39:03 <rwbarton> @src Either a b
22:39:04 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
22:39:31 <shachaf> rwbarton: Oh, it's in the file, but unlabeled.
22:39:50 <shachaf> @src data  Either a b  =  Left a | Right b
22:39:52 <rwbarton> lambdabot 2.0 would use TH Reify
22:39:53 <shachaf> @@ @show @src data  Either a b  =  Left a | Right b
22:39:53 <lambdabot>  ""
22:39:57 <shachaf> ☝
22:42:59 <Sonarpulse> ok I get it
22:43:27 <Sonarpulse> I though you could use | with plain old type
22:43:50 <Sonarpulse> but know, it is onely for 1-1 type synonyms
22:43:55 <Sonarpulse> I guessthat makes more sense
22:46:32 <Sonarpulse> well in that case do I need both MixType (my enum) and Mix as you defined it?
22:46:41 <rwbarton> you need some way to indicate which summand of the sum your value is in. after all you could repeat a type
22:46:46 <rwbarton> no
22:47:08 <Sonarpulse> I guess yeah, your function did not use MixType
22:47:16 <rwbarton> not unless you want to be able to talk about MixTypes without their associated Mix data
22:47:26 <Sonarpulse> yeah, that is usefull for debugging
22:48:21 <Sonarpulse> Is there an extension that allows you to return types and all that dynamic stuff?
22:48:34 <Sonarpulse> I promise I will try to avoid using it but just curious
22:49:00 <rwbarton> it's not really possible to answer that question at your current level of understanding i think
22:50:28 <rwbarton> what e.g. python calls a "type" is really just a particular kind of value
22:50:38 <Sonarpulse> I have never used python
22:50:57 <rwbarton> well I don't know what you mean by "return types" then
22:51:25 <Sonarpulse> I know haskell is statically typed
22:52:22 <Saizan> return types as in have the result of a function be a type?
22:52:25 <rwbarton> whatever a function returns is a value, types are not values, though you can construct values that represent types in a certain sense
22:52:41 <Sonarpulse> and I have learned that many of this "type returing" where yes, a type would be a value, breaks the assumptions of static typing
22:53:40 <Saizan> where have you learned that?
22:54:16 <Sonarpulse> talking to people irl
22:54:38 <Sonarpulse> it makes sense, if there is too much dynanism, type checking at compile time gets a whole lot harder
22:54:52 <Sonarpulse> at same level there is a trade off between safety and expressiveness
22:55:16 <rwbarton> "functions returning types" is not necessarily related to whether or not you have static checking
22:56:02 <Sonarpulse> well if you have a function that returns a type into an overloaded function that takes a type to decide which
22:56:42 <Sonarpulse> to call (not saying this can be done quite like that in haskell)
22:56:47 <Sonarpulse> but it makes sense in theory
22:56:48 <rwbarton> you can also do this
22:56:52 <rwbarton> in a sense
22:57:09 <Sonarpulse> "in a sense" the things fed are not really types right>
22:57:12 <rwbarton> however it's much easier to just have a function that returns a value to a normal function that takes a value to decide which to call
22:57:18 <Sonarpulse> yeah
22:57:45 <Sonarpulse> and I imagine with enough pain I could rig up something like that with MixType
22:57:54 <Sonarpulse> (my sum type)
22:58:01 <shachaf> rwbarton: I heard a rumour that your Python quiz vanished from the Internet.
22:58:26 <rwbarton> shachaf: kmc is supposedly on the case
22:58:42 <rwbarton> I haven't heard from him yet though.
22:59:00 <rwbarton> It's still around on archive.org
22:59:23 <rwbarton> kmc was going to blog about it
23:03:28 <taruti> How can I see the popularity of various hackage packages for the last 3-6 months?
23:03:53 <Clint> become psychic
23:07:08 <Sonarpulse> aha!
23:07:15 <Sonarpulse> well if I have MixType and Mix
23:07:28 <Sonarpulse> I can use detect for the case
23:07:36 <Sonarpulse> and then type classes actually are ok
23:07:57 <Sonarpulse> because it inferers the required type from the contructor (TD, RA, etc)
23:08:31 <Sonarpulse> I guess sum type deriving enum really is the "type as a value" way to go
23:10:10 <rwbarton> what passes for a "type" in a dynamic language is really a constructor of a sum type that can represent any value in the language
23:11:05 <Sonarpulse> makes sense
23:11:43 <Sonarpulse> maybe someday I can map something to MixType to get Mix
23:11:54 <Sonarpulse> first-class types
23:12:02 <Sonarpulse> or whatever, but this is good for now
23:12:30 <Sonarpulse> the coding-in-the-large style i am going for is already making things pretty crazy
23:12:39 <rwbarton> in Agda you can do more or less this
23:14:03 <Sonarpulse> I have heard a bit of these esoteric things
23:14:16 <Sonarpulse> should certainly try it someday
23:14:45 <shachaf> You might want to learn Haskell first. :-)
23:14:48 <Sonarpulse> my guess is something along these lines will be needed to bring Template Haskell to it's full potential
23:15:01 <shachaf> I don't think any of this has anything to do with TH
23:15:03 <Sonarpulse> shachaf: that is my plan :D
23:15:40 <Sonarpulse> The idea of "first-class types" evokes meta-programming in my head
23:16:21 <Sonarpulse> do you see/feel any informal similarity in purpose?
23:16:50 <shachaf> Too informal for me.
23:17:13 <shachaf> By which I mean I don't really know what those words mean. :-)
23:17:34 <Sonarpulse> well i guess consider the problem of statically typed var args
23:17:43 <Sonarpulse> I don't know all the details
23:17:55 <Sonarpulse> but theres certainly a reason why we have
23:18:01 <Sonarpulse> map, zipWith
23:18:17 <Sonarpulse> zipWith2
23:18:18 <Sonarpulse> etc
23:18:54 <Sonarpulse> I've never used template haskell, but it seems reasonable that I could make a macro to make mapN
23:19:34 <Sonarpulse> and I'd imagine "first-class types" would also provide a solution
23:19:55 <shachaf> Sure.
23:20:02 <Sonarpulse> maybe that's it, they don't work well together, and they share the same weekness that they impeed static type checking, but they have similar goals
23:20:03 <shachaf> They don't even need to be first-class for that, really.
23:21:36 <Sonarpulse> unless you did map :: degree (a1 -> a2 -> a3 ... ->aDegree -> b) etc
23:22:19 <Sonarpulse> but yeah, I was incorrectly using "first class" to get at "higher orderness" i general
23:22:55 <BMeph> My only issue (so far) with such "macro" manipulation is: What if you really want a list of functions?
23:23:12 <shachaf> What was that type someone mentioned that was like a list [f :: (b -> c), g :: (a -> b), ...]?
23:23:48 <Sonarpulse> mindfuck
23:23:52 <Cale> shachaf: That's called a thrist
23:23:55 <BMeph> shachaf: Do you mean Gabor Greif's Thrist class? :)
23:24:11 <Cale> http://hackage.haskell.org/package/thrist
23:24:16 * BMeph cyber-high-fives Cale!
23:25:10 <Sonarpulse> when you pass a polymorphic function from a typeclass
23:25:16 <Sonarpulse> can you only pass one variant
23:25:16 <shachaf> Cale: That's the one.
23:25:53 <shachaf> BMeph: Class?
23:27:10 <rwbarton> with an extension (RankNTypes) and an explicit type signature you can pass all versions at once
23:27:31 <shachaf> Or Rank2Types.
23:28:13 <shachaf> data Foo a = Some a | forall o. Map (o -> a) (Some o) is much less interesting, I suppose.
23:28:27 <shachaf> Is there a way to make that type more interesting? It's related to FunList, presumably.
23:28:46 <rwbarton> "Map (o -> a)"?
23:29:05 <taruti> Clint: I think there were some stastics done in at least 2010, just wondering if there are more recent statistics.
23:29:05 <hpaste> johnw pasted “Adjunction.hs” at http://hpaste.org/77843
23:29:41 <shachaf> rwbarton: Well, "Foo a" is a value of some type, and a list of functions that compose together to turn that type into an "a"
23:29:46 <shachaf> Of course Foo a ~ (Nat,a)
23:29:59 <rwbarton> oh duh
23:30:08 <rwbarton> I mentally inserted a constructor before Map
23:31:09 <shachaf> The goal was originally to make a noncompliant Functor instance.
23:31:38 <shachaf> Like data Nonoid a = NLeaf a | NEmpty | NAppend (Nonoid a) (Nonoid a)
23:32:04 <rwbarton> i was just thinking how it is sort of like a free functor-without-laws
23:32:16 <shachaf> Right.
23:32:24 <rwbarton> free functor-without-laws on the identity functor, i guess
23:32:26 <shachaf> ski called this kind of type "nonfree"
23:32:38 <Sonarpulse> dispatch :: L.ByteString -> (L.ByteString -> b) -> Mix
23:32:40 <shachaf> Sure, you could presumably generalize this from Identity.
23:32:51 <shachaf> Anyway I wonder if anything ahs been written about this pattern.
23:33:14 <shachaf> You can use Nonoid to good effect to use foldMap with first-class mappend and mempty.
23:33:24 <shachaf> (Otherwise you have to make a new Monoid instance for everything.)
23:33:27 <taruti> e.g. does it make sense to use HTTP or http-conduit for new code. Which of the tagsoup packages is actually used. And is HXT alive and kicking. etc.
23:35:18 <rwbarton> I think the long-awaited Hackage 2 will have some kind of popularity data (or ratings or something like that)
23:36:52 <shachaf> Is there a free Functor-with-laws?
23:43:14 <johnw> shachaf: http://ncatlab.org/nlab/show/free+functor
23:45:14 <BMeph> shachaf: Never mind; I hadn't noticed it's been "improved" with shiny-new kind-level functions. :)
23:47:39 <shachaf> I guess for Thrist you have to know the length (and types) of the list at compiletime.
23:49:11 <Sonarpulse> hmm, I just rigged up a dummy type class and I am still having problems
23:49:20 <shachaf> The type class is the root of your problems.
23:49:27 <shachaf> Well, OK, not the root. But it's way up/down there.
23:49:45 <Sonarpulse> I actually was doing pretty good as long as I make a dispatch for each function
23:50:01 <Sonarpulse> but as soon as I want to make a higher-order dispatch
23:50:10 <Sonarpulse> oh wait
23:51:04 <Sonarpulse> ok
23:51:12 <Sonarpulse> well i can make a generic dispatch
23:51:24 <Sonarpulse> but i have to pass the overloaded function to it multiple times
23:51:56 <Sonarpulse> So each paramenter get's it's own type inference
23:52:22 <Sonarpulse> but even with RankNTypes (the extension I was reffered to when I was trying to solve this)
23:52:27 <Sonarpulse> I can't use one argument for all of them
23:52:43 <shachaf> I don't think you should use RankNTypes.
23:52:52 <Sonarpulse> I won't it doesn't help
23:53:07 <Sonarpulse> looks interesting, but not for the problem at hand
23:53:15 <shachaf> I also don't think you should use type classes.
23:53:51 <Sonarpulse> well I can't say doing
23:54:14 <Sonarpulse> "dispatching encode encode encode encode encode encode encode"
23:54:23 <Sonarpulse> is any better than
23:54:45 <Sonarpulse> "dispatching RA.encode TD.encode TS.encode" etc
23:55:01 <shachaf> What?
23:55:03 <hpaste> Canar pasted “arg” at http://hpaste.org/77844
23:55:14 <Sonarpulse> I'll commit in a sec
23:55:18 <Sonarpulse> and then you can see my dispatch
23:55:34 <Canar> ^ yep, there's my question
23:55:40 <Canar> i'm trying to do something that should be simple:
23:55:51 <taruti> What is the current status of Haste vs Ghcjs vs UHC?
23:55:56 <shachaf> Canar: There are multiple bugs in that program.
23:56:03 <Canar> get Haskell to spit out ieee754 bytestreams from a list
23:56:07 <shachaf> Start with the list, which doesn't have commas.
23:56:09 <Canar> shachaf: I know, I'm learning.
23:56:18 <shachaf> Then look at the type of putFloat64le
23:56:37 <Canar> The problem is that I can get nowhere with the documentation.
23:56:48 <shachaf> The types are a good first step. :-)
23:56:50 <shachaf> Do you have ghci?
23:56:53 <Canar> yes
23:56:57 <shachaf> Start with ghci
23:57:02 <Canar> I've started there.
23:57:11 <shachaf> OK.
23:57:17 <Canar> putFloat returns a Writer monad
23:57:20 <Canar> or a Put monad
23:57:28 <shachaf> No, just a Put. :-)
23:57:32 <shachaf> s/No, //
23:57:34 <Canar> and I have no idea how to take that and do anything with it
23:57:41 <shachaf> Have you looked at the documentation?
23:57:45 <Canar> I have.
23:57:54 <shachaf> @hoogle Put
23:57:55 <lambdabot> Prelude putChar :: Char -> IO ()
23:57:56 <lambdabot> System.IO putChar :: Char -> IO ()
23:57:56 <lambdabot> Prelude putStr :: String -> IO ()
23:58:08 <shachaf> What are you using, cereal?
23:58:12 <Canar> Yes.
23:58:24 <shachaf> http://hackage.haskell.org/packages/archive/cereal/latest/doc/html/Data-Serialize-Put.html
23:58:27 <shachaf> Have you seen that page?
23:58:35 <Canar> Yep.
23:58:38 <Canar> Read it end to end.
23:58:56 <shachaf> OK, let's look at bit by bit. :-)
23:59:07 <shachaf> You have a Put and you want to turn it into something else, right?
23:59:13 <Canar> Yep.
23:59:30 <shachaf> So you want some function of the form "Put -> ..."
23:59:30 <Sonarpulse> oo, I could help if you were using Binary
23:59:34 <shachaf> Can you find any such function?
23:59:41 <shachaf> Sonarpulse: No, Canar doesn't need any type classes. :-)
23:59:52 <Canar> yes, runPut?
