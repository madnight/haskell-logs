00:22:11 <zzo38> How do I tell cabal to unregister a package, in case I have made modifications and want to test it in the interpreter before recompiling?
00:48:57 <osa1> are there any performance differences between running the program from source with runghc or compiling and running the executable?
00:49:48 <earthy> yes
00:49:54 <earthy> *huge* performance differences.
00:50:13 <earthy> running it from source with runghc interprets the program
00:50:26 <earthy> which implies no optimizations
00:50:26 <mysticc> zzo38: ghc-pkg unregister
00:50:37 <shachaf> osa1: I think I've heard 20-30x slower.
00:50:59 <mysticc> osa1: compiled vs interpreted
00:51:04 <shachaf> (You should definitely trust the number that some random person on IRC said they think they heard.)
00:51:44 <osa1> :) thanks
00:52:01 <osa1> I though runghc is actually compiling source to temporary place and then run from it
00:52:04 <osa1> thought*
00:52:13 <shachaf> osa1: GHC still "compiles".
00:52:32 <shachaf> But it makes a choice far to one side of the compilation-speed-to-execution-speed tradeoff.
01:00:57 <earthy> plus, it only compiles the modules that are on disk
01:01:39 <earthy> but it doesn't really compile as such the direct argument to runghc (or the input into ghci)
01:01:53 <earthy> it *does*, however, make use of compiled modules
01:02:30 <earthy> so, if all modules but the toplevel module are compiled, then runghc toplevelmodule need not be considerably slower
01:28:40 <zzo38> What does "Function `dvi-processing-0.2:Graphics.DVI.optimizePage{v r11R} [lid]' has 10 call patterns, but the limit is 3" means?
01:30:22 <zzo38> And why does the "cabal upload" command not automatically know which file you want to upload if you don't specify? It should use the filename that "cabal sdist" created
01:31:56 <Lemmih> zzo38: That's not obvious.
01:32:04 <Lemmih> zzo38: And ignore the warning.
01:34:11 <zzo38> I uploaded a package; will it display here?
01:34:45 * hackagebot dvi-processing 0.2 - Read/write DVI and TFM file  http://hackage.haskell.org/package/dvi-processing-0.2 (AaronBlack)
01:35:07 <zzo38> O, there it is.
01:36:15 <zzo38> Is it good one?
01:40:15 <zzo38> Later I can add mathematics typesetting to dvi-processing, and possibly other things; you can specify your ideas here please.
01:57:01 <zzo38> Have you ever used HPDF? dvi-processing is a similar idea, without all of the overly complicated and stupid PDF stuff. In addition, dvi-processing can use any TFM font, and can both read and write DVI files (HPDF writes only).
02:24:54 <gnoi> How can I break list into 2 parts? [1..10] -> ([1..5],[6..10])
02:25:18 <srhb> gnoi: splatAt
02:25:25 <srhb> gnoi: Er, splitAt. :-)
02:25:32 <gnoi> :t splitAt
02:25:33 <lambdabot> forall a. Int -> [a] -> ([a], [a])
02:26:18 <gnoi> > (\x -> splitAt (truncate . (\ 2) . length x) x) $ [1..10]
02:26:19 <lambdabot>   <no location info>: parse error on input `)'
02:26:48 <ivanm> gnoi: should that be (/2) rather than (\2) ?
02:26:52 <srhb> yep.
02:26:53 <gnoi> > (\x -> splitAt (truncate . (/ 2) . length x) x) $ [1..10]
02:26:54 <lambdabot>   Couldn't match expected type `f a'
02:26:55 <lambdabot>         against inferred type `GHC.Types...
02:26:56 <ivanm> if so, why not just use `div` ?
02:27:07 <gnoi> > (\x -> splitAt ((div 2) . length x) x) $ [1..10]
02:27:08 <lambdabot>   Couldn't match expected type `f t'
02:27:08 <lambdabot>         against inferred type `GHC.Types...
02:27:22 <srhb> flip div
02:27:22 <ivanm> > (\ x -> splitAt ((`div`2) $ length x) x) $ [1..1]0
02:27:23 <lambdabot>   Couldn't match expected type `t -> [a]'
02:27:23 <lambdabot>         against inferred type `[a1]'
02:27:28 <ivanm> > (\ x -> splitAt ((`div`2) $ length x) x) $ [1..10]
02:27:29 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
02:27:31 <ivanm> gnoi: ^^
02:27:56 <ivanm> let's golf!
02:28:20 <ivanm> > liftM2 splitAt (flip div 2 . length) id $ [1..10]
02:28:21 <lambdabot>   ([1,2,3,4,5],[6,7,8,9,10])
02:28:39 <ivanm> @pl (\ x -> splitAt ((`div`2) $ length x) x
02:28:39 <lambdabot> (line 1, column 40):
02:28:40 <lambdabot> unexpected end of input
02:28:40 <lambdabot> expecting variable, "(", operator or ")"
02:28:48 <ivanm> @pl \ x -> splitAt ((`div`2) $ length x) x
02:28:48 <lambdabot> splitAt =<< (`div` 2) . length
02:28:53 <ivanm> oh, right
02:29:19 <srhb> oh, that is pretty. how on earth does that work. Hmm
02:29:39 <ivanm> @src ((->) a) (>>=)
02:29:39 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:29:43 <ivanm> srhb: function monad!
02:31:26 <DijkstraGroupie> > map fib [0..20] where fib = mid . loop (1,0,1) (1,1,0) where { mid (x,y,z) = y ; loop coef base exp | exp == 0 = coef | mod exp 2 == 1 = loop (mul coef base) base (exp - 1) | otherwise = loop coef (mul base base) (div exp 2) where mul (a,b,c) (d,e,f) = (x,y,z) where { x = a*d + b*e ; y = a*e + b*f ; z = b*e + c*f } }
02:31:26 <lambdabot>   <no location info>: parse error on input `where'
02:31:55 <ivanm> DijkstraGroupie: use let rather than where
02:32:07 <DijkstraGroupie> ivanm: Okay.
02:32:08 <srhb> ivanm: What monad? :o
02:32:11 <ivanm> and you might want to use let to define it as a function
02:32:16 <ivanm> srhb: ((->) a)
02:32:21 <ivanm> it's defined in Control.Monad.Instances
02:32:41 <srhb> Don't think I've come across that one yet. Exciting.
02:32:43 <zzo38> It is also called a reader monad
02:32:56 <ivanm> > (do { x <- (2*); y <- (+1); return (x,y) }) 3
02:32:57 <lambdabot>   (6,4)
02:33:02 <ivanm> zzo38: yeah, poor man's reader
02:33:03 <zzo38> fmap = (.); return = const; join f x = f x x;
02:33:12 <ivanm> the actual Reader monad is basically a newtype wrapped around it
02:33:15 <zzo38> That is the definition.
02:33:39 <ivanm> zzo38: well, technically you need (>>=) for an *implementation* definition :p
02:34:00 <zzo38> ivanm: Yes; but that is the problem with Haskell.
02:34:13 <ivanm> zzo38: how is it *the* problem with Haskell?
02:34:20 <ivanm> (and how is it *a* problem for that matter anyway?)
02:34:45 <DijkstraGroupie> Can I nest let clauses the same way I nest where clauses?
02:34:53 <dobblego> DijkstraGroupie: sure
02:34:59 <srhb> How do I look up the source for bind for a particular monad?
02:35:00 <DijkstraGroupie> Nice!
02:35:19 <ivanm> srhb: look it up in the source of the module it's defined in? :p
02:35:25 <zzo38> Because the Monad class in Haskell is stupid. Better way would be:   class Functor m => Monad m where { return :: x -> m x; join :: m (m x) -> m x; };
02:35:27 <ivanm> the function monad is in C.M.I
02:35:38 <ivanm> zzo38: "stupid" ?
02:35:46 <ivanm> most people agree it needs a better hierarchy
02:35:48 <zzo38> ivanm: A little bit.
02:35:51 <ivanm> using Functor, Applicative, etc.
02:35:56 <ivanm> but I don't know about *stupid*
02:36:22 <zzo38> In (->) category all monads are applicative, but that might not necessarily be the case in other categories
02:36:42 <dobblego> @type \f g x -> f (g x) x
02:36:43 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
02:37:14 <zzo38> (where by applicative I actually mean fmap, pure, and liftPair)
02:37:20 <dobblego> Functor <- Apply <- Bind <- Monad
02:37:23 <ivanm> and what is liftPair ?
02:37:25 <statusfailed> is there shorthand for "modifying" a record field?
02:37:27 <srhb> Oh, simple.
02:37:33 <ivanm> statusfailed: foo { field = newValue }
02:37:34 <dobblego> "fuck point/return/pure" -- anon
02:37:41 <dobblego> statusfailed: data-lens
02:37:55 <ivanm> dobblego: why that rather than any other such library?
02:37:57 <statusfailed> dobblego: I thought there was an easy shorthand just using field names
02:37:59 <zzo38> ivanm:  liftPair :: (f x, f y) -> f (x, y);
02:38:06 <ivanm> statusfailed: yes, and I gave it to you!
02:38:16 <srhb> So from now on, if I have function that needs applying to a computation that requires that same value, I can use that pattern every time. Funky.
02:38:17 <statusfailed> ivanm: so you did... sorry! :D
02:38:21 <statusfailed> totally missed that :)
02:38:22 <dobblego> ivanm: because it is more complete than other libraries
02:38:38 <dobblego> (except yall, which I recently saw)
02:38:45 <ivanm> zzo38: I don't recall seeing anything like that in Applicative
02:39:03 <dobblego> liftPair = uncurry (liftA2 (,))
02:39:15 <ivanm> why are you using your own definition of typeclasses rather than the ones that are actually there?
02:39:23 <ivanm> dobblego: yeah, I worked that out
02:39:29 <zzo38> ivanm: Because the ones that are actually there are a bit stupid
02:39:35 <dobblego> liftPair is often given as the applicative primitive
02:39:38 <ivanm> zzo38: so *you* claim
02:39:52 <ivanm> and it doesn't matter, they are what actually exists
02:40:08 <dobblego> better would be (Pointed f, Bind f) => class Monad f
02:40:21 <DijkstraGroupie> > let fib = let { mid (x,y,z) = y ; mul (a,b,c) (d,e,f) = (a*d + b*e, a*e + b*f, b*e + c*f) ; loop coef base exp | exp == 0 = coef | mod exp 2 == 1 = loop (mul coef base) base (exp - 1) | otherwise = loop coef (mul base base) (div exp 2) } in mid . loop (1,0,1) (1,1,0) in map fib [0..30]
02:40:22 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
02:40:32 <ivanm> dobblego: where Bind defines >>= ?
02:40:34 <mauke> f <*> x = uncurry id `fmap` liftPair (f, x)
02:40:37 <dobblego> yes
02:40:48 <ivanm> are you assuming Functor => one of Pointed or Bind ?
02:41:04 <dobblego> class Functor f => Apply f; class Apply f => Bind f
02:41:04 <ivanm> so, which types can Bind be defined that Pointed can't?
02:41:11 <dobblego> about a zillion, pick one
02:41:26 <ivanm> dobblego: I can't think of one, which is why I'm asking *you* ;)
02:41:34 <dobblego> I am imploring you to imagine one :)
02:41:42 <dobblego> any semigroup that is not a monoid
02:41:47 <dobblego> i.e. a zillion
02:42:00 <DijkstraGroupie> Why doesn't lambdabot support where?
02:42:01 <ivanm> my head is currently thinking in terms of graphs, not category theory :p
02:42:11 <dobblego> DijkstraGroupie: it does
02:42:13 <Cale> DijkstraGroupie: it does
02:42:24 <ivanm> DijkstraGroupie: for starters, you weren't defining a function before
02:42:26 <zzo38> ivanm: Well, you can make a category from a digraph.
02:42:28 <dobblego> ivanm: http://hackage.haskell.org/package/semigroupoids knock yourself out
02:42:38 <Cale> Lambdabot wants expressions though, and where is part of the syntax of declarations (and case expressions)
02:42:45 <DijkstraGroupie> Oh.
02:43:28 <ivanm> dobblego: right, that would require me to understand edwardk's code, especially when he seems to think that documentation is optional... :p
02:43:34 <DijkstraGroupie> > map test [0..20] where test = (^2)
02:43:35 <lambdabot>   <no location info>: parse error on input `where'
02:43:42 <dobblego> I think he thinks documentation is so important that it belongs in types
02:43:56 <Cale> right, that's not an expression
02:43:59 <ivanm> rather than specifying the rationale, basis, usage, etc. of everything?
02:44:14 <Cale> > let foo = map test [0..20] where test = (^2) in foo
02:44:14 <ivanm> > let f = map test where test = (^2) in f [0..20]
02:44:15 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
02:44:15 <lambdabot>   can't find file: L.hs
02:44:21 <ivanm> > let f = map test where test = (^2) in f [0..20]
02:44:21 <lambdabot>   [0,1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400]
02:44:37 <dobblego> ivanm: yes, rather than blabbering useless nonsense and pretending you just said something that wasn't annoying :)
02:45:11 <DijkstraGroupie> It is kind of contrived to wrap everything in a let clause.
02:45:28 <srhb> lambdabot: is kind of contrived. :-)
02:45:49 <ivanm> DijkstraGroupie: try doing it in ghci...
02:45:53 <ivanm> it isn't a lambdabot-ism
02:46:02 <DijkstraGroupie> ivanm: Oh! The same thing happened.
02:46:07 <Cale> DijkstraGroupie: Well, the where clause there is part of the definition of foo (or f in ivanm's case)
02:46:09 <srhb> I thought they fixed that in the new GHCI?
02:46:24 <ivanm> srhb: you still need let IIRC
02:46:35 <srhb> Oh bah.
02:46:42 <DijkstraGroupie> Ah, I get it. That is why where clauses can span several guards.
02:46:45 <ivanm> or not, it just let me do "data Foo = Bar | Baz"
02:46:46 <Cale> yes
02:46:54 <DijkstraGroupie> Because it is bound to the left side of the definition.
02:46:55 <DijkstraGroupie> Dang.
02:47:11 <DijkstraGroupie> Makes perfect sense.
02:47:34 * ivanm goes back to trying to understand his old code and make it match the version he specified in his paper for comparison purposes
02:50:39 <kallisti> http://sprunge.us/BGCH?haskell  a normal number of imports in your typical Haskell program.
02:51:38 <ivanm> kallisti: if that's "normal", then I must be doing something wrong...
02:51:45 <kallisti> ivanm: more or less?
02:51:48 <DijkstraGroupie> Is ghci a giant IO monad?
02:51:55 <ivanm> kallisti: *much* less
02:51:59 <kallisti> DijkstraGroupie: kind of
02:52:08 <kallisti> it can compute pure expressions
02:52:12 <kallisti> and it's also a giant IO monad thing.
02:52:20 * kallisti technical terms.
02:52:35 <ivanm> I think the most I've ever had would be about 15 imports, including things like "import qualified Foo as F; import Foo(Foo)" as two separate lines
02:52:48 <kallisti> ivanm: do your programs practical or theoretical?
02:52:50 <kallisti> *are
02:53:04 <ivanm> kallisti: depends on how you define them :p
02:53:52 <ivanm> though CPP? really?
02:53:54 <kallisti> well, for this project I find myself importing a lot of things.
02:53:58 <kallisti> granted, I use a lot of stuff.
02:54:01 <kallisti> ivanm: yes.
02:54:11 <kallisti> see the instances for Int, Int8, Int16, Int32, ...
02:54:19 <ivanm> for that kind of static generation, you should really contain all the instances there explicitly
02:54:34 <kallisti> also I have a special case for darwin OS that I copied from the official Selenium code.
02:54:49 <kallisti> ivanm: hm
02:54:50 <kallisti> ?
02:54:54 <ivanm> kallisti: oh, that's one thing; I'm talking about the macro aspect
02:55:02 <kallisti> what's wrong with it.
02:55:10 <ivanm> not very Haskell-y :p
02:55:18 <kallisti> less typing. it's pretty clear.
02:55:20 <ivanm> if you *must* generate code, use TH or something! ;)
02:55:23 <kallisti> mtl does it. so I'm safe. :P
02:55:42 <ivanm> kallisti: less typing for a one-off
02:55:50 <ivanm> how many times in the future would you need to re-type them?
02:56:07 <kallisti> well... zero, of course. unless I plan to add more integral types.
02:56:13 <ivanm> right
02:56:21 <ivanm> and even then it's just a copy-paste with a bit of an edit
02:56:35 * kallisti refuses to listen to your appeal to more work.
02:56:42 <ivanm> how is it more work?
02:56:48 <ivanm> define one
02:57:16 <kallisti> because I've already completed it as is.. :P
02:57:26 <ivanm> then use C-M-% to transform them all!
02:57:43 * kallisti doesn't have a problem with CPP.
02:58:00 <kallisti> unless it's a hack..
02:58:11 <kallisti> but this is not a hack. it's abundantly clear what I'm doing.
02:58:25 <zzo38> CPP is good for C; it is not so good for Haskell.
02:59:28 <kallisti> I don't find it necessary to form black and white opinions on tools based on which language they're designed for.
02:59:46 <kallisti> I saw it being used to define tedious instances in mtl, and thought that was a good use case.
03:01:00 <zzo38> No, still, CPP is not so good for Haskell due to differences of syntax, such as the different comment syntax and the different use of ' in Haskell than it is in C.
03:01:58 <kallisti> if Haskell had better instance deduction, this wouldn't be a problem. :P
03:02:21 <kallisti> I could just make an instance (Integral a) => ToFirefox a
03:02:23 <kallisti> and be done with it.
03:03:46 <zzo38> It is why, we should make up the Ibtlfmm working group to invent the next programming language.
03:04:19 <kallisti> I don't see that going anywhere.
03:04:28 <kallisti> except maybe a lot of debate.
03:04:33 <kallisti> which could be useful.
03:05:04 <zzo38> kallisti: Yes, that is it. After it is a lot of debate then something else might be made from it too.
03:05:23 <zzo38> I can write what I have already, too.
03:05:47 <zzo38> I have a document structure in Plain TeX but is incomplete; perhaps the document can be made like a wiki
03:06:42 <kallisti> a good macro language would be of great benefit.
03:07:04 <DijkstraGroupie> > let fib = fst . loop (0,1) (1,0) where loop coef base exp | base == 0 = coef | mod exp 2 == 1 = loop (mul coef base) base (exp - 1) | otherwise = loop coef (mul base base) (div exp 2) where mul (a,b) (c,d) = (x,y) where { x = a*c + b*c + a*d ; y = a*c + b*d } in fib 0
03:07:05 <zzo38> kallisti: Yes that is already one of my ideas; to have good macros.
03:07:08 <lambdabot>   mueval-core: Time limit exceeded
03:09:31 <zzo38> But another idea is lacking multiline comments; they are not needed because you can use WEB documentation areas. (Single line comments are still existing.)
03:11:14 <zzo38> (If you do not want to use WEB, then simply begin your program by @{Main} and then write a program without WEB)
03:13:31 <DijkstraGroupie> Hello. How do I map a0 to every element in a list with an even index, and a1 to every element with an odd index?
03:14:34 <dobblego> DijkstraGroupie: I would start here: zip <*> tail
03:14:51 <DijkstraGroupie> dobblego: Okay, lemme see.
03:14:59 <dobblego> or here (might be easier): zip [0..]
03:15:36 <Lemmih> DijkstraGroupie: zipWith ($) (cycle [a1,a0])
03:16:16 <zzo38> Lemmih: Exactly my idea too (although I used id instead of ($))
03:16:33 <DijkstraGroupie> Let me even try to understand that.
03:16:44 <dobblego> zipWith ($) = (<*>) + juggling
03:18:08 <zzo38> To me ($) is like infix id isn't it?
03:18:19 <kallisti> to you and others
03:18:30 <zzo38> Yes, others too
03:18:39 <kallisti> you can also use `id` as a kind of ($) with reverse syntactic qualities
03:18:46 <kallisti> left associative and highest precendence.
03:18:47 <Lemmih> zzo38: It is function application to me.
03:19:15 <zzo38> Lemmih: That is its use
03:20:49 <kallisti> I wonder why faster HashMap is than Map on Text keys.
03:20:54 <kallisti> s/why/how much/
03:21:33 <Lemmih> kallisti: Johan does have benchmarks for that, I believe.
03:21:36 <zzo38> I don't know; I have only ever used HashMap with TypeRep as the keys
03:34:23 <bobry> Anyone aware of the package with polymorphic 'length' function?
03:34:44 <int-e> @type Data.List.genericLength
03:34:45 <lambdabot> forall b i. (Num i) => [b] -> i
03:34:47 <Lemmih> bobry: Prelude.
03:35:01 <bobry> well, polymorphic on the container level
03:35:04 <zhulikas> @type length
03:35:05 <lambdabot> forall a. [a] -> Int
03:35:14 <ivanm> bobry: there have been a few attemtps at such a typeclass
03:35:17 <ivanm> most have failed
03:35:24 <bobry> why?
03:35:36 <ivanm> bobry: it's too damn hard to try and cover every single possible one
03:35:40 <ivanm> (I tried making one)
03:36:18 <bobry> well, it's fine to cover the most usable subset :) 'containers' + 'bytestring' + 'text' for example
03:36:19 <int-e> oh, something in terms of Data.Foldable.Foldable.
03:36:28 <ivanm> bobry: even that becomes difficult
03:36:35 <ivanm> do you make it kind * -> * or just kind * ?
03:36:39 <ivanm> if the latter, you ditch mapping
03:36:51 <bobry> ah, right
03:36:57 <ivanm> then you have that "length" makes no sense in terms of a Map or a Set
03:37:06 <int-e> @type Data.Foldable.foldl' (+) 0 . fmap (const 1)
03:37:07 <lambdabot> forall a (t :: * -> *) a1. (Num a, Data.Foldable.Foldable t, Functor t) => t a1 -> a
03:37:11 <ivanm> bobry: the kind requirements was why I eventually gave up
03:37:14 <kallisti> I would 2 params for the container and the element
03:37:16 <kallisti> with a fundep
03:37:49 <ivanm> especially since I was also trying to use the Suitable stuff to let Set be a Monad, and to re-define all of Functor, Applicative, etc. to match the typeclassopedia
03:38:04 <ivanm> kallisti: well, I used TFs, but same thing
03:38:16 <ivanm> if you do that then you can't define map
03:38:29 <ivanm> unless you restrict it to (a -> a) that is
03:38:54 <ivanm> but you need to use Suitable if you want to allow * -> * kinds so that you can define map for Sets
03:39:29 <bobry> I see, it's not as obvious as I thought initially :)
03:40:09 <kallisti> well I see no problems with a typeclass that only overloads length.
03:40:14 <zzo38> I would also do something like this instead of genericLength:   length [] = zeroP; length (_ : x) = succP (length x);    where zeroP and succP are one typeclass. And then:   x !! y = maybe (head x) (tail x !!) (predP y);   where predP is another typeclass
03:40:44 <zzo38> I also wanted to be able to use constraints to restrict the types that can be used for objects in a Category as well
03:41:21 <int-e> bobry: of course a length function defined in terms of foldable will be less efficient than a container specific size function in some cases. The Data.Map one is constant time, for example.
03:42:36 <bobry> int-e: yup, O(n) independent of the container
03:44:00 <int-e> possibly worse ;) (but I don't know why such a container would be useful.)
03:44:32 <bobry> worse? hrm, how can that be?
03:45:14 <int-e> Ah, say you implement an "ordered list" container on top of an unordered list (that makes insertion fast, right?) Then fold will take O(n log(n)) time.
03:45:28 <kallisti> a sequence that get progressively more difficult to expand, requiring twice the number of elements inserted previously before its size increases. :P
03:46:13 <int-e> (I want Omega() there, really)
03:47:30 <ivanm> bobry: if you're only using [a], bytestring, text, etc. then using ListLike might work
03:47:39 <ivanm> make that String rather than [a]
03:47:41 <ivanm> (I think)
03:54:42 <dixie> am I blind? I can not find the wxLaunchDefaultBrowser impl. within wxhaskell
03:55:25 <nevrenato> does anyone know a good guide that explains how to upgrade applications from base3 to base4?
03:57:37 <dixie> http://sourceforge.net/tracker/?func=detail&atid=536848&aid=2796855&group_id=73133
03:58:00 <dixie> probably good chance to learn about FFI for me :)
04:05:43 <teneen> Is it possible to import a module and hide certain instances?
04:06:05 <kallisti> no
04:06:25 <teneen> How to workaround then? :D
04:06:34 <kallisti> depends on what you want.
04:07:20 <kallisti> the idea of instances is that they exist everywhere. once you've imported them they're defined everywhere.
04:07:38 <kallisti> (however, I do think that being able to control instance importing would be nice)
04:08:15 <teneen> I want to override a certain instance from Data.Monoid
04:08:32 <kallisti> which?
04:08:40 <teneen> (a -> b)
04:08:48 <ivanm> teneen: why?
04:09:12 <ivanm> nevrenato: the big change is Control.Exception
04:09:18 <ivanm> apart from that it should be pretty smooth sailing
04:09:24 <kallisti> well a common "workaround" to this sort of problem is to define newtypes which have specialized instances.
04:09:30 <teneen> Just for grasping the concept. I would like to see whether the laws hold for another instance I have in mind
04:09:47 <kallisti> for example, integers can have two different monoid instances, one with addition and one with multiplication
04:09:55 <kallisti> so there's Sum and Product which have these instances.
04:10:06 <nevrenato> ivanm:  OK thnks :)
04:10:18 <adnauseam> who's good with cabal and debian ? :[
04:10:27 <kallisti> > Sum 5 `mappend` Sum 6
04:10:28 <lambdabot>   Sum {getSum = 11}
04:10:36 <kallisti> adnauseam: I have both of those things. whether or not I'm good at them is debatable.
04:10:36 <ykm> kallisti: so anything with a mappend and mempty value is a monoid?
04:10:38 <ivanm> adnauseam: m3ga and nomeata I think
04:10:40 <teneen> kallisti: yes, and the problem is there is a very similar instance to what I have in mind, which is Endo
04:10:56 <teneen> kallisti: I prefer not using a wrapper
04:10:58 <ivanm> ykm: a *sane* mappend and mempty, yes
04:11:00 <kallisti> ykm: the Monoid typeclass defines two methods named mappend and mempty
04:11:16 <kallisti> and it has some laws associated with it
04:11:22 <kallisti> that aren't actually enforced.
04:11:27 <adnauseam> my lambdabot install is failing since transformers-base-0.4.1 failed to install. doing cabal install transformers-base fails with ExitFailure 1, cabal is version 0.8 (upgrading it fails for some reason) i want to hurt puppies... this has been going on since last night...
04:11:42 <adnauseam> =[
04:12:01 <adnauseam> it's a bit ironic, i know. still, puppies are not at any lesser risk
04:12:03 <kallisti> adnauseam: what does it say when it fails.
04:12:29 <adnauseam> i'll paste bin it
04:13:02 <kallisti> teneen: well, that's basically the only way to do it.
04:13:24 <kallisti> with generalizedNewtypeDeriving it's not really a huge issue to do so.
04:13:28 <kallisti> *G
04:13:59 <teneen> kallisti: I'll stick to it then. Thanks!
04:14:09 <adnauseam> ttp://pastebin.com/XSaWAHf9
04:14:11 <adnauseam> http://pastebin.com/XSaWAHf9
04:14:13 <mauke> The paste XSaWAHf9 has been copied to http://hpaste.org/66497
04:14:24 <adnauseam> pasteception
04:15:08 <kallisti> adnauseam: any particular reason for the --global install?
04:15:52 <kallisti> adnauseam: oh and I meant the error when attempting to upgrade cabal-install
04:15:58 <adnauseam> hpc instructions - i'm just following them. not doing --global has the same effect
04:16:03 <adnauseam> oh
04:16:10 <adnauseam> uno momento, i'll generate it again
04:16:23 <kallisti> hm, I don't get those errors when installing the same package
04:16:31 <kallisti> instead I get orphan instance warnings.
04:16:38 <kallisti> what version of ghc?
04:16:54 <kallisti> src/Control/Monad/Base.hs:63:10: Warning: orphan instance: instance Applicative (L.ST s)
04:16:57 <kallisti> src/Control/Monad/Base.hs:67:10: Warning: orphan instance: instance Applicative (S.ST s)
04:17:26 <kallisti> $ ghc --version
04:17:27 <kallisti> The Glorious Glasgow Haskell Compilation System, version 7.0.4
04:17:29 <adnauseam> ghc is newest, compiled and installed locally yesterday. 7.4.1
04:17:54 <kallisti> hm, that's the only thing I can guess, is that it has to do with the newer GHC.
04:17:55 <adnauseam> cabal fails with upgrade because this version doesn't allow upgrade,
04:18:31 <adnauseam> root@ragecage:~/haskell/lambdabot# cabal upgrade
04:18:32 <adnauseam> cabal: the 'upgrade' command (when used without any package arguments) has
04:18:32 <adnauseam> been disabled in this release.
04:18:41 <kallisti> huh..
04:18:52 <adnauseam> root@ragecage:~/haskell/lambdabot# cabal upgrade cabal-install
04:18:52 <adnauseam> Resolving dependencies...
04:18:52 <adnauseam> cabal: fromFlag NoFlag. Use fromFlagOrDefault
04:19:15 <kallisti> I think I just typed cabal install cabal-install ...
04:20:00 <kallisti> try that
04:20:13 <adnauseam> http://pastebin.com/mqdRTbj2\
04:20:15 <adnauseam> http://pastebin.com/mqdRTbj2
04:20:15 <mauke> The paste mqdRTbj2 has been copied to http://hpaste.org/66498
04:20:15 <mauke> The paste mqdRTbj2 has been copied to http://hpaste.org/66498
04:20:51 <kallisti> adnauseam: you're too new, man. :P
04:20:51 <Phlogistique> Is there somewhere an example of projects using QuickCheck ? (not tutorials explaining how to write a property)
04:20:58 <kallisti> no one can keep up with your cutting edge GHC.
04:21:24 <kallisti> Phlogistique: xmonad I believe uses quickcheck
04:21:26 <adnauseam> kallisti: :[
04:21:50 <Phlogistique> also: are people using QuickCheck and HUnit together on the same project, or only Quickcheck or only HUnit
04:21:56 <adnauseam> i'm trying to install the newer cabal now, it throws a hissy fit too, i'll show you when it errors out
04:22:20 <adnauseam> http://pastebin.com/sS0iHDg3
04:22:22 <mauke> The paste sS0iHDg3 has been copied to http://hpaste.org/66499
04:24:08 <adnauseam> kallisti: do y ou mean that i should just downgrade ghc ?
04:24:21 <kallisti> it just looks as though your base is too new.
04:24:36 <adnauseam> oh
04:24:38 <adnauseam> hrm
04:24:38 <kallisti> but there may be a fix I'm not aware of.
04:24:54 <kallisti> so I wouldn't recommend downgrading based on my word alone. :P
04:25:10 <adnauseam> i'll wait for hpc to wake up and shower him with questions ;p
04:25:23 <kallisti> I would think it's possible to have multiple versions of base installed.
04:26:02 <adnauseam> the problem with debian's prots is that the current version is ghc6
04:26:07 <adnauseam> ports*
04:26:20 <kallisti> are you on stable?
04:26:28 <kallisti> testing is on ghc 7
04:26:34 <Phlogistique> kallisti: looking at Properties.hs in XMonad
04:26:52 <adnauseam> i believe so - it's a virtual server
04:27:03 <Phlogistique> and uh, looks like the whole "running the tests" logic is implemented in there
04:27:39 <Phlogistique> isn't there a simple standard way to run quickchecks? It looks like there was a "runTests" in QuickCheck at some point but it somehow doesn't exist anymore?
04:27:46 <kallisti> adnauseam: you can check /proc/version to find out for sure
04:29:48 <adnauseam> it doesn't say if it's stable or not - the output wasn't too different from uname -a, : Linux version 2.6.32-5-xen-amd64 (Debian 2.6.32-38) (ben@decadent.org.uk) (gcc version 4.3.5 (Debian 4.3.5-4) ) #1 SMP Mon Oct 3 07:53:54 UTC 2011
04:29:58 * hackagebot hecc 0.3 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.3 (MarcelFourne)
04:30:05 <kallisti> 2.6 is stable I believe.
04:30:06 <kallisti> possibly older.
04:30:46 <kallisti> unless you're on a mixed release or something..
04:31:13 <adnauseam> i'll tap my sysadmin on the shoulder and ask him to help clear this out
04:32:47 <kallisti> adnauseam: oh found it.  cat /etc/issue
04:33:14 <adnauseam> ArcAngel: Debian GNU/Linux 6.0 \n \l
04:33:26 <adnauseam> Debian GNU/Linux 6.0 \n \l
04:33:44 <kallisti> yep. stable
04:34:13 <kallisti> I'm running GHC 7 with Debian wheezy and having no trouble installing anything.
04:34:43 <adnauseam> i think the problem's with cabal :/
04:34:54 <kallisti> it looks to me like it's a GHC compile error that's causing the issue.
04:35:04 <kallisti> but that could also be the fault of cabal, I think.
04:35:25 <adnauseam> i'm doing an apt purge
04:35:34 <adnauseam> and trying to do this again
04:40:28 <adnauseam> hmm, kallisti; alright, i apt purged and ran "sh bootstrap.sh" on my standalone source of cabal 0.10 and it still errored out with the same issues. so something is a foot here i think.
04:40:37 <kallisti> seems so.
04:40:45 <adnauseam> the thing is, what the hell are the unix\base and filepath extentions and where do i get them.
04:41:48 <kallisti> yeah the package says it was built on 7.4, so I'm confused as to why there's a compile error.
04:43:18 <kallisti> adnauseam: ah, yeah there's something wrong with the macros.
04:43:56 <hpaste> er pasted “erwe” at http://hpaste.org/66500
04:44:06 <kallisti> adnauseam: ^
04:44:47 <hpaste> “jpthing@online.no” pasted “confused” at http://hpaste.org/66501
04:44:58 <adnauseam> ]hrm
04:45:23 <Younder> Can anyone help me with the error in that last post?
04:45:42 <adnauseam> kallisti: was that link for m,e ?
04:45:46 <kallisti> adnauseam: so either cabal thinks you have a version lower than base 4.4 or that other macro isn't true
04:45:49 <kallisti> adnauseam: yes
04:45:58 <kallisti> adnauseam: that's where your error happens
04:47:40 <adnauseam> did you stumble upon a google link? i'm a tad bewildered as to which macro file that is. bootstrap.sh isn't the one
04:47:53 <kallisti> what?
04:48:10 <kallisti> that's source code from transformers-base
04:48:20 <adnauseam> oh
04:48:23 <kallisti> when you attempt to install it gives you a compile error
04:48:27 <kallisti> at that location
04:48:38 <kallisti> because base 4.4 defines instances for ST
04:49:21 <kallisti> so yeah I think cabal is misconfigured somehow.
04:51:16 <dcoutts> kallisti, adnauseam: put ()'s around the thing, so it's !(...)
04:52:42 <dcoutts> kallisti, adnauseam: there was a bug (now fixed) that the MIN_VERSION_blah macro expanded to an expression that was not itself surrounded by ()'s, so applying ! to it directly did the wrong thing.
04:53:15 <kallisti> heh
04:53:20 <kallisti> classic
04:53:38 <dcoutts> yay for cpp textual expansion
04:53:45 <hpaste> younder pasted “confused” at http://hpaste.org/66502
04:54:13 <adnauseam> hmm
04:54:19 <Younder> Any Ide what is causing this code form 'Real World Haskell' to fail
04:54:36 <adnauseam> i will try installing the newest cabal... then try again o_0
04:54:51 <ivanm> Younder: the exception stuff changed after RWH came out
04:54:53 <dcoutts> adnauseam: or just edit the code
04:54:55 <ivanm> and is now polymorphic
04:57:10 <LeXuS> come into ICQ chat UIN 559296087
04:57:44 <Younder> ivanm So what do I do about it?
04:57:44 <LeXuS> for an entrance press !start
04:57:56 <hiptobecubic> are there ops here?
04:58:26 <LeXuS> ehat?
04:58:29 <LeXuS> what?
04:58:36 <ivanm> Younder: you need to specify a type for the handler function
04:58:42 <ivanm> @where ops
04:58:42 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
04:58:48 --- mode: ChanServ set +o dcoutts
04:58:54 <ivanm> hiptobecubic: that will pull them out of the woodwork
04:59:12 <mauke> LeXuS: welcome to #haskell
04:59:33 <mauke> LeXuS: are you interested in learning about Haskell?
04:59:35 <LeXuS> I from Russia :)
04:59:42 <adnauseam> dcoutts: i'd edit the code if i was sure of what i was doing. i might break /everything/ if i do
04:59:43 <Younder> ivanm:  handle (const (return [])) :: [String] gave me another error. Where do I insert this type
04:59:50 <LeXuS> yes
05:00:36 <dcoutts> adnauseam: na, just stick () around that expression, so it reads: #if !(MIN_VER... etc && ...)
05:00:38 <ivanm> no, you need something like (\ _ :: SomeException -> return [])
05:01:21 <mauke> ivanm: \SomeException{} -> return []
05:01:31 <dcoutts> LeXuS: just for future reference, it's not a good idea to invite people off to ICQ, people will think you're a spammer :-)
05:01:33 <adnauseam> dcoutts: where ? :p
05:01:34 --- mode: ChanServ set -o dcoutts
05:01:37 <Younder> ivanm: ok I think I have it
05:01:52 <dcoutts> adnauseam: didn't you paste this? http://hpaste.org/66500
05:02:02 <adnauseam> oh
05:02:11 <adnauseam> no, it wasn't me that link
05:02:13 <ivanm> mauke: oh, right, forgot about just pattern matching on the constructor
05:02:17 <adnauseam> i pasted all the other ones :p
05:02:21 <dcoutts> hah hah
05:02:21 <dcoutts> ok
05:02:22 <ivanm> though in general SomeException shouldn't be used
05:02:30 <dcoutts> adnauseam: sorry, confusion
05:02:31 <LeXuS> no, it as dough :)
05:02:34 <LeXuS> > dcoutts >
05:02:35 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
05:03:40 <adnauseam> dcoutts: it's ok, it fits the theme :D
05:03:55 <LeXuS> > dcoutts > you from what city? I from Russia the city Ivanovo
05:03:56 <lambdabot>   Not in scope: `dcoutts'Not in scope: `you'Not in scope: `from'Not in scope:...
05:05:01 <dcoutts> adnauseam: if you're trying to build cabal-install-0.10.x with ghc-7.4, it's not going to work (especially with the bootstrap.sh)
05:05:20 <dcoutts> LeXuS: are you here to learn or talk about Haskell?
05:05:38 <LeXuS> > dcoutts > there are small knowledge of English, but here it not especially teach it
05:05:38 <lambdabot>   <no location info>: parse error on input `of'
05:05:45 <adnauseam> how should i go about it then man ?
05:06:00 <adnauseam> is there a newer version? should i get ghc6 ?
05:06:19 <dcoutts> adnauseam: either use a cabal binary that you built with older ghc, or use the darcs version. There'll be a new release in time for the next HP.
05:06:42 <hpaste> kak pasted “happy code” at http://hpaste.org/66503
05:06:44 <LeXuS> > dcoutts > about this programming language I have no knowledge
05:06:45 <lambdabot>   Not in scope: `dcoutts'Not in scope: `about'Not in scope: `this'Not in scop...
05:06:48 <hpc> adnauseam: still trying to install lambdabot?
05:07:05 <adnauseam> i installed it on my mint box
05:07:17 <adnauseam> now trying to install it on my debian virtual server so i can hook it up to irc
05:07:30 <hpc> yeah, then you want the darcs version of cabal
05:07:35 <adnauseam> and it's giving me a world of frustration
05:07:38 <adnauseam> oh ok
05:07:45 <hpc> because for lambdabot you need ghc 7.4.1
05:07:52 <hpc> to avoid going crazy
05:08:15 <dcoutts> adnauseam: otherwise I was going to suggest sticking to the released haskell platform, since it all works
05:08:29 <kak11> hello, I have problem regarding happy code is pasted at  http://hpaste.org/66503
05:08:42 <kak11> question is also there
05:09:20 <adnauseam> dcoutts: i wish it was that simple :p
05:09:38 <adnauseam> all these damn distros having different versions of everything...
05:10:48 <adnauseam> hpc, maybe this has to do with this : bash: ./bootstrap.sh: Permission denied
05:11:00 <adnauseam> i have to go and manually do sh bootstrap.sh
05:11:18 <adnauseam> instead of rely on your line of script, do you think there might be something afoot there ?
05:11:43 <adnauseam> i do think it's a bit odd to have it really matter
05:11:43 <kak11> hello, anyone doing parsing with happy here?
05:11:49 <adnauseam> but, might as well shoot in the darc
05:11:52 <adnauseam> dark* ;p
05:13:49 <adnauseam> hpc: http://pastebin.com/AWCQEUhT
05:13:51 <mauke> The paste AWCQEUhT has been copied to http://hpaste.org/66504
05:14:33 <adnauseam> it /seemed/ to go this well yesterday too, but i think it erored out as well. maybe now that i've apt purged cabal it'd do bette
05:15:01 <hpc> adnauseam: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13 -- how far ar you through here?
05:15:10 <hpc> oh wait, i see nvm
05:15:52 <adnauseam> aye *fingers crossed*
05:16:01 <kak11> how to do tree parsing using happy? any tutorials for this?
05:16:07 <hpc> adnauseam: the difference between "./" and "sh " shouldn't matter
05:16:14 <ivanm> kak11: any particular reason you want to use happy?
05:16:14 <adnauseam> what a nightmare. i'm guessing this will only get worse with future versions of the haskell platform?
05:16:27 <ivanm> my understanding is that happy is suited for cases where you have a pre-defined grammar
05:17:33 <kak11> ivanm: yes, because I think it has got better support for attributes than yacc.
05:17:43 <adnauseam> hpc - somehow it does on debian :/
05:17:46 <ivanm> kak11: so you *have* a grammar?
05:18:11 <ivanm> my point is more "why use happy over a combinator-parsing library" rather than "why use happy rather than yacc"
05:18:14 <ivanm> s/point/query/
05:18:51 <kak11> ivanm: my code is here, http://hpaste.org/66503
05:19:02 <hpc> adnauseam: freaky; updated with that info
05:19:19 <adnauseam> hpc: sweet!
05:19:24 <kak11> ivanm: because you can define grammars in a more simpler way in happy.
05:19:50 <ivanm> kak11: right, so you *have* a grammar?
05:20:09 <ivanm> I've never used happy before
05:20:18 <adnauseam> hpc: http://pastebin.com/jceNwwmS
05:20:22 <mauke> The paste jceNwwmS has been copied to http://hpaste.org/66505
05:20:23 <adnauseam> errored out just like last night
05:20:40 <adnauseam> no other errors
05:20:45 <ivanm> but I'd be more tempted to whip up something using a combinator parsing library to construct a Tree () value [or maybe a Forest () value]
05:20:52 <adnauseam> they follow directly after linking
05:22:55 <kak11> ivanm: please you give any links to combinator parsing library tutorials.
05:23:11 <ivanm> kak11: RWH has a chapter
05:23:16 <ivanm> LYAH might have one
05:23:25 <ivanm> @google parsec tutorial
05:23:27 <lambdabot> http://www.haskell.org/haskellwiki/Parsec
05:23:28 <lambdabot> Title: Parsec - HaskellWiki
05:24:36 <kak11> ivanm: thanks, i'll see that but do you have any idea whether you can compute attributes using the combinator parsing library?
05:24:40 <ivanm> your options include: parsec (common and popular); polyparse (not as common/popular but much simpler IMHO); attoparsec (better for binary data); uu-parsinglib (rather new, don't know if anyone is actually using it); trifecta (which I believe edwardk is still working on)
05:24:48 <ivanm> kak11: what do you mean by compute attributes?
05:25:49 <mauke> number :: Parser Integer; number = do { d <- many1 digit; return (read d) }
05:26:14 <kak11> ivanm: I mean, does it have some support for attributes that can be used to do syntax directed translation?
05:26:30 <ivanm> kak11: again, what does that mean? :)
05:26:42 <ivanm> what is an "attribute" in this context?
05:26:48 <edwardk> kak11: ultimately any parser combinator library can be used to parse an attribute grammar, synthesized and inherited attributes are just the argument to an applicative
05:27:04 <edwardk> ivanm: attribute grammars
05:27:07 <ivanm> ahhh
05:27:22 <ivanm> from working on graphviz for so long, attribute has come to mean something rather specific to me :p
05:27:34 <edwardk> yeah
05:28:18 <ivanm> don't think I've ever come across the term "attribute grammar" before
05:28:38 <edwardk> http://en.wikipedia.org/wiki/Attribute_grammar
05:28:39 <ivanm> my only real exposure to formal grammars is having to tutor them, and that's only for a week or two :p
05:29:50 <edwardk> a notable historical point about attribute grammars was that they were used to defined algol 68 (http://en.wikipedia.org/wiki/Van_Wijngaarden_grammar)
05:30:00 <earthy> those were not attribute grammers
05:30:05 <earthy> *grammars
05:30:14 <edwardk> they were van wijngaarden grammars
05:30:14 <earthy> they were 2-level grammars
05:30:23 <kak11> i mean, yacc doesn't have a good support for inherited attributes, I heard, that as haskell is declarative it has better support in happy. I am new to Haskell.
05:30:53 <earthy> attribute grammars are both more and less general than 2-level van Wijngaarden grammars
05:31:35 <edwardk> i was going to explain the difference ;)
05:32:20 <edwardk> kak11: inherited attributes can just be higher order functions in haskell
05:32:36 <ClaudiusMaximus> not knowing anything about attribute grammars, and naively looking on hackage, there seems to be some related packages from uu
05:32:49 <hpc> adnauseam: that's the output of bootstrap.sh?
05:33:01 <earthy> uu-parsinglib is quite cool
05:33:06 <kak11> edwardk: thanks,  in this code http://hpaste.org/66503, I am trying to copy the input bintree tree as an attribute named "value" in the grammar, but somehow it's not working
05:33:32 <ClaudiusMaximus> in particular http://hackage.haskell.org/package/uuagc says "Generates Haskell files from an attribute grammar specification "
05:34:11 <earthy> claudiusmaximus: yeah. that's different from uu-parsinglib though
05:34:12 <kak11> for any tree I am always getting this string "( root '(' )" as result.
05:36:06 <kak11> edwardk: is there anything wrong with my grammar there? I guess, happy is always short-circuiting the production "openB bin closedB", how to resolve it?
05:36:23 <edwardk> kak11: i don't tend to write parsers with happy so i'm not the best guy to ask
05:36:57 <kak11> edwardk: ok, thanks anyway.
05:37:30 <ivanm> earthy: in what way is it cool?
05:38:27 <mekeor> do you think the `eval'-function on https://github.com/MekeorMelire/hascal/blob/master/Hascal.hs could be written as a fold?
05:38:46 <edwardk> kak11: ok, i got the bug. now looking at the problem
05:39:32 <edwardk>    : openB bin closedB     { $$ = "( root " ++ (myshow $2) ++ " )" }
05:39:42 <edwardk> $1 is just the open brace ;)
05:40:05 <earthy> ivanm: uu-parsinglib will generate parsers that do not backtrack unless absolutely necessary
05:40:10 * hackagebot hecc 0.3.1 - Elliptic Curve Cryptography for Haskell  http://hackage.haskell.org/package/hecc-0.3.1 (MarcelFourne)
05:40:31 <ivanm> earthy: :o
05:40:41 <earthy> which, in many cases for well-written grammars, means that the parsers do not backtrack
05:40:48 <kak11> edwardk: thanks, will get back to you. :)
05:41:21 <earthy> they're quite efficient. ;)
05:41:43 <edwardk> uu-parsinglib is an interesting design
05:42:05 <earthy> plus, it's got S.D Swierstra inside. ;)
05:42:08 <edwardk> earthy: re backtracking, its a breadth first evaluation
05:42:14 <osa1> does anyone know what does "writev: invalid argument (Bad file descriptor)" mean? I'm getting this message while working with websosckets library
05:42:17 <kak11> edwardk: thanks, great... it resolved the issue.
05:42:24 <ivanm> edwardk: how would you compare it to trifecta and the other ones out there?
05:42:35 <mauke> osa1: man writev
05:42:45 <earthy> edwardk: no, it is not (at least, it was not last I looked at it)
05:43:00 <earthy> it is a variant of best first evaluation
05:43:11 <edwardk> ivanm: trifecta is a lot friendlier. uu-parsinglib is a nice proof of concept, but it strikes me as a bit naive in its assumptions about how to do error correction, etc.
05:43:16 <t7> roconnor: with your cryto method; 0, 1, p -1 and p - 2   all encode to themselves :( is this gonna be an issue?
05:43:39 <ivanm> edwardk: does trifecta work on lazy bytestrings, etc. yet?
05:43:50 <edwardk> ivanm: no
05:44:05 <ivanm> I still can't use it then :)
05:44:13 <edwardk> sorry, not my target audience ;)
05:44:15 <ivanm> though I found attoparsec's way of dealing with lazy bytestrings interesting
05:44:24 <ivanm> edwardk: yeah, I know, you are your own target audience :p
05:44:35 <edwardk> the 'leak memory like a sieve because everything backtracks approach?' yeah works well
05:45:18 <earthy> ah... *that* may be why I couldn't get my code running in constant space...
05:45:37 <ivanm> edwardk: hey, not *all* of my parsers require backtracking!
05:45:55 <ivanm> I'm even using attoparsec in my binary graph parsing stuff!
05:46:15 <ivanm> (because the only way I could get polyparse to be as fast as attoparsec was to *make* it attoparsec, and what's the point of that? :p)
05:47:20 <wunki> clintm: were you able to fix this: http://hpaste.org/66460
05:47:26 <wunki> I'm having the same problem
05:47:43 <edwardk> earthy: anyways, re the best vs breadth thing. http://www.cs.uu.nl/research/techreps/repo/CS-2008/2008-044.pdf it keeps track of the best n branches as it goes, but it never backtracks, since it advances all paths in parallel
05:48:13 <edwardk> i went and fixed up the guts of uu-parsinglib right after it was released because i couldn't read the code ;)
05:48:33 <earthy> edwardk: ISTR there's been an addition that allows it to backtrack in the case of using the Monad instance of the parser combinators
05:49:08 <earthy> (and yeah, the code was quite horrid... even with the authors around the corner it was tricky to comprehend)
05:49:21 <edwardk> well, there is the funny connection between the history and future parsers, is that what you're talking about?
05:49:39 <earthy> might well be
05:49:51 <earthy> it's been a few years since I last tried to grok the lib
05:49:57 <edwardk> likewise
05:50:08 <edwardk> i went and started porting it to scala at one point
05:50:14 <edwardk> but then i realized how bad an idea that was
05:50:27 <edwardk> because scala lacks a lazy pattern matcher
05:50:37 <edwardk> so you have to write EVERYTHING in terms of folds over the ADTs
05:50:41 <edwardk> and there are a lot of them
05:50:53 <edwardk> a rather frustrating exercise ;)
05:50:57 <mauke> smop
05:51:31 <earthy> :)
05:52:22 <edwardk> i have some toy GLL parser combinators i need to package up, but I can't get them to fit into the trifecta framework =/
05:53:06 <edwardk> I want them mostly because it'd be nice to have something that can do decent error recovery
05:57:11 <earthy> yeah. I should make some playtime to work on my ideas for parsing full 2VW grammars
06:00:27 <LambdaDusk> For one hour I am now trying to write a Function of the type [(a, Maybe b)] -> Maybe [(a,b)] and I seem to get nowhere, I feel so dumb. Anyone can help me?
06:00:35 <mauke> LambdaDusk: const []
06:01:07 <LambdaDusk> mauke: A function that does the same as sequence =/
06:01:16 <mauke> introduce intermediate step [Maybe (a,b)]
06:01:34 <mauke> :t sequence [Maybe (a,b)] -> Maybe [(a,b)]
06:01:35 <lambdabot> parse error on input `->'
06:01:40 <mauke> :t sequence :: [Maybe (a,b)] -> Maybe [(a,b)]
06:01:41 <lambdabot> forall a b. [Maybe (a, b)] -> Maybe [(a, b)]
06:01:53 <mauke> sequence does the rest
06:02:08 <mauke> now you just have to write [(a, Maybe b)] -> [Maybe (a, b)]
06:02:22 <mauke> there's a [] on both sides
06:02:34 <mauke> we can cancel that out with map
06:02:44 <mauke> :t map ?f :: [(a, Maybe b)] -> [Maybe (a, b)]
06:02:45 <lambdabot>     Could not deduce (?f::(a, Maybe b) -> Maybe (a, b))
06:02:45 <lambdabot>       from the context ()
06:02:45 <lambdabot>       arising from a use of implicit parameter `?f'
06:03:00 <mauke> now we just need an f::(a, Maybe b) -> Maybe (a, b)
06:03:26 <LambdaDusk> mauke: Yes, thanks. I could have though of that myself.
06:05:10 <copumpkin> it's called strength in some places
06:05:16 <copumpkin> :t uncurry (fmap . (,))
06:05:17 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => (a1, f a) -> f (a1, a)
06:09:38 <LambdaDusk> :t sequence . (map (uncurry (fmap . (,))))
06:09:38 <lambdabot> forall a (f :: * -> *) a1. (Monad f, Functor f) => [(a1, f a)] -> f [(a1, a)]
06:09:51 <LambdaDusk> :D
06:10:01 <edwardk> LambdaDusk: look at mapM
06:10:15 <LambdaDusk> :t mapM
06:10:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
06:10:35 <mauke> @src mapM
06:10:36 <lambdabot> mapM f as = sequence (map f as)
06:10:36 <LambdaDusk> hm
06:11:01 <LambdaDusk> :t mapM (uncurry (fmap . (,)))
06:11:02 <lambdabot> forall a (f :: * -> *) a1. (Functor f, Monad f) => [(a1, f a)] -> f [(a1, a)]
06:11:20 <edwardk> :t Data.Traversable.mapM (uncurry (fmap . (,)))
06:11:21 <lambdabot> forall a (f :: * -> *) a1 (t :: * -> *). (Functor f, Data.Traversable.Traversable t, Monad f) => t (a1, f a) -> f (t (a1, a))
06:11:32 <LambdaDusk> I bet I could spend another hour on this
06:11:33 <edwardk> for one further improvement ;)
06:11:52 <edwardk> the stock mapM is generalized in Data.Traversable
06:12:02 <LambdaDusk> it works fine
06:14:20 <LambdaDusk> one should think an instance Aeson -> Bson should be done easier
06:18:05 <smop> mauke: yes
06:18:20 <mauke> heh
06:19:43 <DijkstraGroupie> One question regarding nested wheres. In the following snippet: http://hpaste.org/66507...
06:20:29 <DijkstraGroupie> If I move the definition of "sign" inside a where clause subordinate to x', would sign be recomputed every time it is invoked?
06:27:19 <bscarlet> DijkstraGroupie: that's up to the compiler.
06:27:44 <bscarlet> DijkstraGroupie: (so hopefully not)
06:33:16 <t7> is theire a prettier function to make something into a list than (:[]) ?
06:33:28 <mauke> pure
06:34:13 <DijkstraGroupie> @hoogle fix
06:34:13 <lambdabot> Control.Monad.Fix module Control.Monad.Fix
06:34:13 <lambdabot> Data.Fixed module Data.Fixed
06:34:13 <lambdabot> Data.Function fix :: (a -> a) -> a
06:36:38 <Elemir> @src fix
06:36:38 <lambdabot> fix f = let x = f x in x
06:38:13 <DijkstraGroupie> Elemir: How does that work?
06:39:05 <Elemir> > fix f
06:39:06 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:39:07 <lambdabot>    `GHC.Show.Show a'
06:39:07 <lambdabot>      a...
06:39:12 <Elemir> > fix f 0
06:39:13 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> a)
06:39:13 <lambdabot>    arising from a use of `...
06:39:24 <Elemir> > fix (+ 1) 0
06:39:25 <lambdabot>   *Exception: stack overflow
06:39:30 <Elemir> Yes
06:39:37 <Elemir> It runs … $ f $ f $ f x
06:40:06 <DijkstraGroupie> @type fix
06:40:07 <lambdabot> forall a. (a -> a) -> a
06:40:09 <Test_> Tests-MacBook-Pro:PDE Test$ cabal install repa
06:40:10 <Test_> Resolving dependencies...
06:40:10 <Test_> cabal: cannot configure repa-2.2.0.1. It requires base ==4.4.*
06:40:10 <Test_> For the dependency on base ==4.4.* there are these packages: base-4.4.0.0 and
06:40:10 <Test_> base-4.4.1.0. However none of them are available.
06:40:10 <Test_> base-4.4.0.0 was excluded because of the top level dependen
06:40:18 <DijkstraGroupie> @type fix (+1)
06:40:19 <lambdabot> forall a. (Num a) => a
06:40:30 <DijkstraGroupie> > fix (+1)
06:40:31 <Test_> Anyone know what I should do to get repa to install?
06:40:34 <lambdabot>   mueval-core: Time limit exceeded
06:40:47 <DijkstraGroupie> > fix (+1) 0
06:40:48 <lambdabot>   *Exception: stack overflow
06:40:56 <Elemir> It can't finish
06:41:27 <Elemir> I don't understand why that function exists
06:41:54 <DijkstraGroupie> There is something I do not understand. What "seed value" does fix use?
06:42:05 <mauke> DijkstraGroupie: none
06:42:08 <mauke> it doesn't iterate
06:42:22 <DijkstraGroupie> Then?
06:42:30 <mauke> it calls a function with its result
06:42:43 <Elemir> Hem, no. I understand
06:42:44 <t7> @hoogle (<$>)
06:42:44 <lambdabot> Data.Functor (<$>) :: Functor f => (a -> b) -> f a -> f b
06:42:44 <lambdabot> Control.Applicative (<$>) :: Functor f => (a -> b) -> f a -> f b
06:43:00 <Elemir> Or not.
06:43:10 <t7> <$> is a different way round to >>=
06:43:27 <ciaranm> DijkstraGroupie: http://www.vex.net/~trebla/haskell/fix.xhtml
06:43:31 <Elemir> mauke: Why? That `fix' can't finish
06:43:49 <mauke> define "finish"
06:44:08 <ciaranm> > fix (1:)
06:44:09 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:44:21 <ciaranm> that's an easier to understand example
06:44:30 <Elemir> Hem
06:44:47 <Elemir> ok, lazy datatypes
06:44:56 <ciaranm> it's not exclusively to do with laziness
06:45:11 <ciaranm> but the infinite list of 1s is the "least" thing where 1:thing == thing
06:45:20 <DijkstraGroupie> > let fact f n = n * fact f (n - 1) in fix fact 5
06:45:21 <lambdabot>   *Exception: stack overflow
06:45:51 <ciaranm> trying to understand fix by feeding random stuff into it is a bad idea, anyway
06:46:13 <int-e> DijkstraGroupie: missing a base case.
06:46:22 <DijkstraGroupie> Oh, yes.
06:46:23 <DijkstraGroupie> Sorry.
06:46:36 <sizz> where are the best places to browse small haskell projects (for the purpose of learning)?
06:46:41 <DijkstraGroupie> > let fact f n = if n == 0 then 1 else n * fact f (n - 1) in fix fact 5
06:46:42 <lambdabot>   120
06:46:45 <DijkstraGroupie> Aha!
06:47:09 <DijkstraGroupie> But I do not get fix's signature.
06:47:11 <mauke> DijkstraGroupie: your 'fact' is recursive and doesn't use 'f'
06:47:13 <hiptobecubic> sizz, i find github pretty helpful. you can search by language.
06:47:17 <mauke> DijkstraGroupie: your use of 'fix' achieves nothing
06:47:27 <ciaranm> DijkstraGroupie: http://www.vex.net/~trebla/haskell/fix.xhtml . seriously.
06:47:32 <DijkstraGroupie> > let fact f n = if n == 0 then 1 else n * f f (n - 1) in fix fact 5
06:47:33 <lambdabot>   Occurs check: cannot construct the infinite type: t = t -> a -> a
06:47:41 <ciaranm> DijkstraGroupie: stop guessing
06:47:46 <DijkstraGroupie> Okay, okay.
06:47:54 <int-e> DijkstraGroupie: don't use f f, just f.
06:48:36 <mauke> > fix (\fact n -> if n <= 1 then 1 else n * fact (n - 1)) 5
06:48:37 <lambdabot>   120
06:49:14 <DijkstraGroupie> Okay, so fix takes a function and returns another function.
06:49:24 <int-e> > fix (\fibs -> 0 : zipWith (+) fibs (tail fibs)))
06:49:25 <lambdabot>   <no location info>: parse error on input `)'
06:49:30 <int-e> > fix (\fibs -> 0 : zipWith (+) fibs (tail fibs))
06:49:34 <lambdabot>   mueval-core: Time limit exceeded
06:49:37 <ciaranm> DijkstraGroupie: http://www.vex.net/~trebla/haskell/fix.xhtml . it is the way to be enlightened.
06:50:08 <int-e> > fix (\fibs -> 0 : 1 : zipWith (+) fibs (tail fibs)) -- oops. need two initial values.
06:50:09 <lambdabot>   [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946...
06:51:38 <DijkstraGroupie> ciaranm: I have read it.
06:51:59 <ciaranm> DijkstraGroupie: don't just read it. understand it.
06:52:12 <ciaranm> DijkstraGroupie: it will probably take you a few hours of careful thinking.
06:52:56 <int-e> @src fix
06:52:57 <lambdabot> fix f = let x = f x in x
06:53:15 <DijkstraGroupie> ciaranm: Yes, fix takes a function that takes two parameters, the first parameter is used to make the "recursive" call, and the second parameter is what would have been the parameter of the recursive function.
06:53:17 <int-e> ah, we did that 16 minutes ago.
06:53:53 <int-e> DijkstraGroupie: no. fix works perfectly well on any function of type a -> a.
06:53:53 <ciaranm> DijkstraGroupie: congratulations, you've managed to pick out one small bit of information whilst utterly missing the point
06:54:11 <int-e> > fix id -- although the result is often not so useful.
06:54:15 <lambdabot>   mueval-core: Time limit exceeded
06:55:20 <int-e> But in Haskell's denotational semantics even  fix id  has a value: it's  bottom.
06:56:55 <int-e> And laziness is essential for its definition to work -- you don't need an initial value for iteration; you can just use the result (yet uncomputed) and feed it to f. That's what  let x = f x  accomplishes.
06:56:58 <edwardk> DijkstraGroupie: perhaps this is a useful example: http://www.haskell.org/pipermail/haskell-cafe/2010-July/080119.html
06:57:13 <edwardk> > fix (1:)
06:57:14 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
06:58:01 <Ptival> that fixed it!
06:59:04 <edwardk> In the above fix (1:) = let x = 1 : x in x
07:00:00 <edwardk> which works just fine since we're lazy, and there is a constructor between us and the use of 'x'
07:01:13 <int-e> and note that (1:) is a function of only one argument (it has type Num a => [a] -> [a], or, to make it simpler, [Integer] -> [Integer])
07:03:22 <mikeplus32> > fix ((1:) . (\(x:xs) -> x+1:xs))
07:03:24 <lambdabot>   [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,...
07:03:58 <t7> Wow my encrypted poker deck of cards is 18k in base64
07:04:07 <t7> maybe i should do binary
07:04:37 <t7> is there a class i can derive for [Word8] encoding or something?
07:04:50 * shapr writes a GSoC proposal
07:05:54 <t7> cereal looks ok
07:05:58 <t7> do maybe people use this?
07:06:06 <Clint> people definitely use cereal
07:06:37 <mikeplus32> there are binary instances for vector
07:07:47 <mikeplus32> > fix ((1:) . (map (+1)))
07:07:49 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
07:07:51 <mikeplus32> neat.
07:15:25 <parcs`> t7: cereal can autoderive efficient binary serializations with the new generics stuff in 7.4
07:16:00 <t7> i wanna send a ByteString and recv the complete thing the other end
07:16:08 <t7> but im gonna have to send the length :(
07:17:24 <parcs`> no
07:17:46 <t7> ?
07:17:55 <parcs`> you don't have to send the length
07:18:28 <t7> how will it know when 1 bytestring finishes ?
07:18:41 <t7> (socket)
07:19:49 <Saizan> you can send a separator byte
07:21:54 <t7> Saizan: what if that appears in my bytestring?
07:21:54 <parcs`> you can use runGetPartial on a continuous stream of bytes to incrementally decode a value
07:22:26 <parcs`> most data type serializations don't need to be length-prefixed
07:25:14 * hackagebot yesod-rst 0.2 - Tools for using reStructuredText (RST) in a yesod application  http://hackage.haskell.org/package/yesod-rst-0.2 (PascalWittmann)
07:25:32 <t7> now i just need to get cereal to send data through a handle
07:25:58 <parcs`> use an incremental io library like cereal-conduit
07:28:33 <t7> fuck this, its gonna be easier to just send length
07:28:52 <squark42> hi. is there something like a simple read() for handles; that means, I want to read max. n bytes, so if no bytes are available I want to block, but if 0 < x <= n bytes are available I want to return immediately. sry for the maybe trivial question. In short: I want something like fdRead but operating on handles not Fd's
07:31:17 <dzhus> Latepoke calls for rescue! Maybe someone will care to check this out: http://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/dmitrydzhus/1002
07:36:15 <DevHC_> squark42: use FFI :}
07:42:20 <squark42> thx, but I just realised the simpler solution is to use readFd and link -threaded;
07:53:13 <Lemmih> thoughtpolice: ping.
07:53:47 <Lemmih> @tell thoughtpolice Do you happen to have a copy of the LHC repository around?
07:53:47 <lambdabot> Consider it noted.
07:57:11 <hpaste> xraycat pasted “euler 55” at http://hpaste.org/66508
08:01:07 <Lemmih> @tell thoughtpolice Nevermind.
08:01:08 <lambdabot> Consider it noted.
08:01:34 <xraycat> I have no idea where the problem is, tp is working fine in ghci
08:02:51 <xraycat> at least as expected
08:03:04 <zhulikas> xraycat, try with the same numbers
08:04:52 <xraycat> zhulikas: I can't follow
08:04:57 <zhulikas> nevermind
08:05:50 <zhulikas> I see tp doesn't work with n < 0
08:05:59 <zhulikas> gives exactly the same error
08:11:31 <xraycat> with that fixed there is at least no exception, just a wrong result :o
08:13:24 <shapr> Yay, Summor of Code project proposal submitted! w00t!
08:13:29 <shapr> Summer* even
08:13:30 <zhulikas> o/
08:13:36 <zhulikas> what's the project?
08:13:37 <xraycat> :-)
08:14:06 <shapr> zhulikas: Basically, I hope to integrate hpaste.org with tryhaskell.org but explicitly allow for multi-user sessions.
08:14:47 <shapr> But I'd also like to have a web-based irc client in there, and if things get done really quickly, integrate Google Hangouts! https://developers.google.com/+/hangouts/
08:15:46 <zhulikas> interesting :)
08:16:19 <zhulikas> ah, found your proposal :P
08:19:26 <zhulikas> shapr, I think you should have a more clear schedule and a list of things you plan to do
08:19:43 <zhulikas> would increase your chances of being accepted
08:20:32 <zhulikas> deadline in 3 hours
08:22:08 <xraycat> zhulikas: got it now, thx, numbers were getting to big apparently
08:22:18 <zhulikas> really?
08:22:29 <zhulikas> I tried tp with numbers of ~50digits or something
08:22:53 <copumpkin> byorgey: I think I found a bug in software foundations!
08:25:34 <xraycat> zhulikas: had to change tp to: tp :: Integer -> Integer, Lychrel as well
08:25:43 <zhulikas> ahh, of course
08:26:13 <zhulikas> mine was Num a, not Int
08:26:28 <zhulikas> tp :: (Read a, Num a) => a -> a
08:26:44 <zhulikas> hmm, that's probably the way to go
08:26:58 <zhulikas> as I solved some of project euler problems and was facing problems with Int boundaries
08:27:25 <xraycat> no idea, still a haskell newbie, but I have had similar troubles along the way
08:27:34 <xraycat> well, (haskell) newbie
08:30:13 <thoughtpolice> Lemmih: i do not :( my old laptop might if i can rip the hdd out of it
08:30:13 <lambdabot> thoughtpolice: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:31:10 <thoughtpolice> Lemmih: ah i assume you found one?
08:31:11 <Lemmih> thoughtpolice: I dug out my old laptop. The LHC repo is now on github. Didn't bother with the commit history, sorry.
08:31:50 <thoughtpolice> Lemmih: no big deal, better than no history at all!
08:33:06 <thoughtpolice> er, i meant code :p
08:34:15 <Lemmih> :)
08:35:57 <Lemmih> I've decided that supporting Haskell2010/Haskell98 is too much of a bother. LHC will now be a compiler for a Haskell-like language with a much simpler base library.
08:38:25 <shapr> zhulikas: Thanks, I'll work on that.
08:45:06 <jhance> Why can I not {-# UNPACK #-} a Blaze.ByteString.Builder? It is a single constructor type
08:45:10 <jhance> (newtype)
08:45:52 <Saizan> what's the inner type?
08:46:04 <Lemmih> jhance: Because it doesn't make sense to unpack in a newtype.
08:46:50 <jhance> Lemmih: Oh, duh, that is very true
08:48:08 <jhance> So if a newtype had a unpackable inner type would it be unpackable?
08:49:11 <copumpkin> a newtype is indistinguishable at runtime from the type inside it
08:49:35 <dzhus> newtype is transparent
08:49:53 <jhance> Yes, I understand, I was just wondering if it would then be possible to double-unpack
08:56:50 <Saizan> i think newtype Foo = Foo Int; data Bar = Bar {-# UNPACK #-} Foo makes sense
08:57:21 <Saizan> (adding a ! to the last Foo)
08:57:23 <copumpkin> yeah, I think GHC will "see through" it
08:58:39 * kallisti just got an excellent idea but is uncertain of the implementation.
08:58:54 <dgpratt> it seems that if I use a monad transformer with IO as the inner monad, liftIO and lift are equivalent (except that lift is more general); is this correct? is one or the other more idiomatic?
08:59:23 <Saizan> they are differently general
08:59:40 <Saizan> liftIO works even if you have more than one transformer on top of IO
08:59:56 <kallisti> what are some models of concurrent computation?
09:00:02 <Saizan> lift works for a single trasformer layer, but for all base monads
09:00:04 <kallisti> I need to brush up on theory first before I attempt this.
09:00:27 <dgpratt> Saizan: ah, good point
09:00:47 <copumpkin> kallisti: pi calculus?
09:00:59 <elliott> kallisti: pi calculus? CSP?
09:01:00 <kallisti> dgpratt: there's also MonadBase which generalizes to an arbitrary base monad.
09:01:19 <dgpratt> let me ask it this way: lift and liftIO are often interchangeable, yes? in such a case, which is more idiomatic?
09:01:33 <elliott> kallisti: actor model?
09:01:39 <elliott> FRP?
09:02:07 <kallisti> I don't know how to answer the questions.
09:02:11 <kallisti> I guess I'll go with: yes
09:02:23 <elliott> well, your question is impossible to answer without knowing what 'this" is
09:03:00 <Saizan> dgpratt: i'd use liftIO in that case
09:03:21 <dgpratt> Saizan: ok, thanks
09:04:11 <elliott> seconding Saizan
09:05:39 <kallisti> pi calculus looks good.
09:14:56 <nominolo> @seen andyjgill
09:14:56 <lambdabot> Unknown command, try @list
09:15:14 <elliott> preflex: xseen andyjgill
09:15:18 <elliott> oh, preflex isn't here
09:15:29 <elliott> mauke: preflex is your bot, right?
09:17:47 <nominolo> elliott: I'll consult my 250MB log file
09:18:32 <dzhus> kallisti: see rewriting logic too
09:22:33 <byorgey> copumpkin: NOT POSSIBLE
09:23:13 <byorgey> copumpkin: heh, just kidding, I'm sure it's full of bugs.  what is it?
09:23:37 <Mathnerd314> preflex: seen andyjgill
09:23:38 <preflex>  andyjgill was last seen on #ghc 1 year, 84 days, 11 hours, 27 minutes and 7 seconds ago, saying: Anyone around?
09:23:57 <Mathnerd314> elliott: why the extra x?
09:24:44 <Skola> has anyone here writter a nlp tokenizer in Haskell? What route is advisable? A proper parser, regexps, general functional approach?
09:26:15 <elliott> Mathnerd314: does all channels or something
09:26:18 <elliott> preflex: xseen andyjgill
09:26:18 <preflex>  andyjgill was last seen on freenode/#ghc 1 year, 84 days, 11 hours, 29 minutes and 47 seconds ago, saying: Anyone around?
09:26:20 <elliott> oh, all networks
09:30:00 <Mathnerd314> Skola: what are you writing it for?
09:30:41 <Skola> for tokenizing English text
09:30:56 <Skola> to perform all kinds of amateurish analysis on my favourite texts
09:31:15 <byorgey> Skola: http://projects.haskell.org/nlp/
09:31:52 <Skola> I've signed up to the nlp haskell mailing list
09:33:29 <oleiade> Hi! I've made a data type which has 4 members and I'd like to be able to construct it either from four params or from a list of values (as params), how can I do that? :-)
09:35:09 <Skola> but I was wondering if something like Parsec is ever used for natural languages
09:35:23 <Skola> for tokenization in particular
09:35:24 <byorgey> oleiade: just write a function  mkMyDataType :: [Param] -> MyDataType
09:35:41 <hpc> oleiade: assuming "data Foo = Bar X X X X", you write "mkFoo [a, b, c, d] = Bar a b c d"
09:36:02 <hpc> oleiade: but you don't want to do this, because a list of the wrong size will crash at runtime
09:36:04 <hpc> not compile-time
09:36:15 <liyang> And also write mkFoo _ = error "WTF?!" after that.
09:36:24 <liyang> (Don't do it.)
09:36:53 <oleiade> weel my turnaround until there has been to make a function which take a [a] and returns my data type
09:37:04 <oleiade> checking the given list size
09:37:59 <oleiade> How to make your solution pretty hpc? :-)
09:38:25 <elliott> hpc's solution is as pretty as it gets
09:38:30 <hpc> oleiade: by rethinking the problem so you don't have to make a list of params
09:38:32 <elliott> prettier still is not misusing lists for such things
09:38:41 <oleiade> I'll take it then! :-)
09:38:47 <oleiade> thank you very much :-)
09:39:11 <Skola> it seems libraries for tokenization in Haskell are also not well maintained
09:39:28 <hpc> Skola: you mean lexers? try alex
09:39:49 <Skola> will have a look, thanks
09:40:22 <hpc> (you aren't really writing haskell with alex though; if that actually matters for you, try parsec)
09:41:53 <copumpkin> byorgey: in the mutable references section, it says "Then a "nullable reference to a T" is simply an element of the type Option (Ref T)"
09:43:06 <Skola> hpc my problem might be overkill for something like Parsec, but I'm not sure yet
09:43:34 <Skola> nltk in python is hard to beat
09:43:43 <Skola> but I'd really prefer to do my analysis in haskell
09:44:08 <oleiade> Thank you very much hpc :-)
09:44:13 <elliott> Skola: there's a few libraries that bind haskell to python
09:45:44 <Skola> well I'd like to port some of nltk to haskell regardless
09:46:50 <Skola> but I have problems even with the simple decision of how to write my tokenizer
09:47:19 <Skola> + it isn't clear to me if I should be using Text or String for this kind of code
09:47:46 <ChristianS> Skola: when in doubt, use Text
09:49:33 <shapr> preflex: seen apfelmus
09:49:33 <preflex>  apfelmus was last seen on #haskell 275 days, 21 hours, 42 minutes and 7 seconds ago, saying: byorgey: Anyway. Let me know if you're taking the homebrew route, I'll be happy to contribute. :)
09:49:35 <shapr> bah
09:50:09 <byorgey> apfelmus seems to mostly eschew IRC
09:51:02 * elliott wonders what Igloo is doing
09:51:45 <Skola> ChristianS: I use pattern matching over Strings though. Is that possible with Text too? Do I have to pack/unpack?
09:52:29 * ksf can't install svgfonts because it pulls a reinstall of deepseq which then fails on a safe import of array.
09:53:19 <elliott> Skola: f "foo" will work
09:53:23 <elliott> f ('f':xs) won't
09:53:34 <Skola> yeah that's what I meant
09:53:37 <elliott> Skola: otoh, if you are writing a tokeniser you probably do not want to use explicit pattern matches
09:53:39 <Skola> what are those called btw?
09:53:40 <byorgey> ksf: oh? which version of deepseq does it try to reinstall?
09:53:44 <elliott> what's "those"?
09:53:53 <Skola> ('f':xs)
09:53:56 <Skola> this kind of pattern
09:53:59 <ksf> 1.3.0.0
09:54:03 <byorgey> ksf: also, SVGFonts doesn't have version bounds on most of its deps so I wonder what it is that's forcing the reinstall
09:54:05 <tsou> ksf: i can't install haskell platform at all, so consider yourself lucky :P
09:54:12 <elliott> Skola: That's just a pattern match on the (:) constructor.
09:54:13 <elliott> :t (:)
09:54:13 <lambdabot> forall a. a -> [a] -> [a]
09:54:34 <Skola> yeah sorry, I meant the specific case where you match on a literal value
09:54:38 <ksf> ...i have array 0.4.0.0 and 0.3.0.3 install, maybe that's the problem.
09:54:40 <byorgey> hmm, that's the most recent version
09:54:48 <monochrom> "pulls a reinstall" is usually a symptom of already existing problems
09:54:48 <byorgey> ksf: yeah, that doesn't sound good
09:54:57 <ChristianS> Skola: you you use guards such as T.isPrefixOf
09:55:18 <Skola> okay
09:55:18 <ChristianS> Skola: admittedly it's not a elegant as pattern matching on lists/strings
09:55:43 <Skola> right now I use a combo of pattern matching and guards for my string/token-list functions
09:55:57 <shapr> GSoC application period is over in three minutes!
09:56:05 <Skola> + I use the quite convenient Data.List.Split package
09:56:19 <ksf> oh. attoparsec-text needs array <0.4
09:56:32 <monochrom> see my http://www.vex.net/~trebla/haskell/sicp.xhtml . you will only run into more reinstalls, not less; and the problem is still unsolved
09:57:01 <ksf> byorgey, attoparsec-text is deprecated.
09:57:09 <byorgey> aha
09:57:32 <byorgey> hmm, I will stick a to-do item on my list to look into it
09:57:43 <byorgey> if it's deprecated presumably we can replace it with something that isn't.
09:57:48 * ksf cabal unpack svgfont
09:57:52 <ksf> attoparsec, probably.
09:57:53 <Skola> ChristianS: btw why Text over String (when in doubt)?
09:58:17 <monochrom> Text is more compact
09:58:19 <ChristianS> Skola: its faster and takes less storage
09:58:36 <byorgey> ksf: ah, yes, that's what the attoparsec-text page says
09:58:46 <Skola> but is it appropriate for intensive string manipulation?
09:59:07 <monochrom> depends on what you mean
09:59:59 <Skola> for example rewriting a list of tokens to account for contractions
10:00:21 * byorgey forks the SVGFonts repo
10:01:39 <shapr> Yay GSoC!
10:01:50 <ksf> byorgey, it's a matter of changing the dependency and importing many from Apllicative.
10:01:53 <ChristianS> Skola: sure, why not?
10:01:53 <tsou> monochrom: thanks for that link!
10:02:08 <byorgey> ksf: is that all? nice
10:02:28 <monochrom> thank you for choosing monochrom!
10:02:29 <ChristianS> Skhaz: also, Data.Text has a very rich api which is worth checking out.
10:02:36 <Skola> ChristianS: I am not quite sure. I guess I am apprehensive because I have relied a lot on using String as [Char]
10:02:49 <Skola> I will
10:04:07 <tsou> monochrom: anytime ;)  helped make sense of some errors i was getting in attempting to add Agda to my system...
10:05:31 <ChristianS> Skola: Data.Text provides equivalents for most of the generic list functions, and has some more.
10:05:36 <ChristianS> Skola: also, if you use Text, i would use the {-# LANGUAGE OverloadedStrings #-} extension so automatically convert literals into Text (when necessary).
10:05:58 <tsou> monochrom: in fact, i was trying to follow your first bullet at the end, with A and B coinciding, but that failed as well :|
10:06:11 <Skola> alright ChristianS, thanks
10:06:15 <tsou> Anyone running haskell on openbsd? :S
10:07:32 <honza> How can I easily install all the dependencies for a project with cabal?
10:07:42 <ksf> install --dependencies-only
10:07:47 <ksf> or --only-dependencies.
10:07:52 <ksf> I always forget which.
10:07:55 <monochrom> if you are doing a lot of f ('a':'b':'c':cs) = ... , look into stripPrefix
10:07:59 <ksf> in general, cabal install --help
10:08:18 <honza> ksf: I'm trying to install pandoc and I manually install all the deps and the compiler is still complaining that it can't find them.
10:08:50 <miden> hello! Does anyone know spin?
10:08:55 <ksf> doing it manually doesn't help with cabal in 101% of the cases.
10:09:05 <honza> ksf awesome!
10:09:11 <ksf> can you hpaste cabal's barfage when you try to install?
10:09:48 <miden> does anyone know how to use variables table?
10:10:00 <miden> in spin?
10:10:00 <roconnor> t7: I was thinking this morning, your messages shouldn't be 0, 1, or -1 (aka p - 2), but the rest should be fine.
10:10:33 <roconnor> t7: (p-1) doesn't count as a valid message since valid messages must be less than p-1.
10:10:46 <roconnor> t7: er wait
10:11:14 <hpaste> honza pasted “pandoc install fail” at http://hpaste.org/66512
10:11:44 <roconnor> t7: sorry, messages shouldn't be 0, 1 or (-1) which is (p - 1)
10:11:54 <roconnor> t7: p-2 should be fine
10:11:56 <honza> ksf do i have to do anything to my path?
10:12:17 <roconnor> t7: BBL
10:12:55 <ksf> honza, http://hackage.haskell.org/trac/hackage/wiki/CabalInstall
10:12:59 <ksf> ...it does everything for you.
10:13:13 <honza> ksf: ah! thanks
10:13:16 <ksf> if you have the platform you should have it installed.
10:13:27 <ksf> just cd into the directory and do "cabal install"
10:13:41 <ksf> or, fwiw, "cabal install pandoc" anywhere.
10:15:16 <honza> ksf: perfect, that's exactly what i want - thanks!
10:26:17 <byorgey> ksf: I just pushed the SVGFonts changes to github
10:26:36 <byorgey> I could see about making a new release to Hackage if it would be helpful to you.
10:27:46 <ksf> well, I've already got the fixed version installed
10:28:02 <byorgey> ok
10:28:05 <ksf> it surely won't hurt, though
10:29:18 <byorgey> yeah, I'll ping Tillmann
10:53:55 <jaspervdj> So if anyone's been following the updates around Notch's 0x10c, this might be interesting to you: https://github.com/jaspervdj/dcpu16-hs
10:58:54 <evancz> Does anyone know about creating executables of Haskell projects?
10:59:02 <elliott> evancz: What about it?
10:59:06 <elliott> That's what GHC does.
10:59:39 <evancz> I mean for distribution, so without the end user needing GHC
11:00:07 <evancz> I guess that means .msi and .deb files.
11:00:08 <monochrom> the end user will not need GHC
11:01:08 <elliott> evancz: You might need to statically link to remove the GMP dependency, but that's it.
11:01:22 <elliott> (Well, you might need to build a GHC with integer-simple if GMP's license is an issue when statically linking.)
11:02:05 <rewind24> could anyone please explain this: Couldn't match type `a' with `[a]'       `a' is a rigid type variable bound by           the type signature for             list2Tree :: (Eq a, Ord a) => [a] -> BS3 a -> BS3 a
11:02:20 <evancz> I think I have misunderstood earlier than your answer. Here's more context...
11:03:23 <hpaste> gngdhr pasted “When does readFile closes the handle” at http://hpaste.org/66513
11:03:27 <elliott> GHC creates executables that do not depend on any non-standard runtime libraries other than GMP for bignums.
11:03:36 <evancz> I am working on a compiler for Elm (http://elm-lang.org) and would like to make it easy for new users to get started. So I am looking to make the equivalent of a "Haskell Platform" that installs without any crap.
11:03:43 <byorgey> rewind24: it means you are passing something of the wrong type to list2Tree.  Perhaps you are passing it a list of lists instead of a list.
11:03:47 <elliott> gngdhr: when you evaluate the [] at the end of the string, unfortunately
11:04:00 <gngdhr> elliott: thanks for the reply
11:04:15 <byorgey> rewind24: it's hard to give more advice without seeing your code, feel free to paste it on hpaste.org
11:04:21 <gngdhr> the problem I am seeing with my code snippet is that the writeFile doesn't succeed because of the file being locked
11:04:23 <elliott> evancz: Well, that's not much to do with Haskell -- if you statically link the executable (probably with integer-simple), then you should be able to create an installer for it like you would any other program.
11:04:41 <tsou> evancz: you'd be surprised of the crap haskell platform needs to install :P
11:04:46 <gngdhr> I want to read a file, convert it to upper-case and write it back to the same file
11:05:14 <evancz> Ah, ok! I somehow got the impression that cabal had tools to do this.
11:05:48 <tsou> evancz: mostly yes.. mostly ;)
11:06:16 <elliott> evancz: well, there are some "dist" things
11:06:30 <elliott> I'm not sure it has anything to create fully-fledged Windows installers thoug.
11:06:32 <elliott> *though
11:06:56 <hpaste> rewind24 pasted “the paste” at http://hpaste.org/66514
11:07:24 <evancz> Hmm, so I would probably have better luck finding some specific tool for executable to distributable?
11:07:40 <rewind24> byorgey pasted it, hope you see the link on chan, pls say if you don't
11:07:44 <monochrom> replace [x:xs] by (x:xs)
11:07:51 <rewind24> pmg..
11:07:53 <rewind24> omg..
11:07:56 <monochrom> haskell is not prolog
11:08:05 <Clint> :-
11:08:42 <rewind24> monochrom : thank you
11:08:59 <DMcGill> rewind24: note "[]" still has to be square brackets
11:09:10 <rewind24> yes i know, that
11:09:17 <rewind24> 's where the confusion comes from
11:09:19 <evancz> Sorry for the basic questions. I am new to this aspect of programming. University does not talk much about this aspect of programming. I'll take a look around and see if I can find some nice tools for such a task. Thanks for your help!
11:12:52 <gngdhr> evancz: are you the author of elm?
11:13:08 <evancz> Yep!
11:14:11 <gngdhr> evancz: looks like an interesting project, especially the possibility of statically typed language to write web-code in (and let the compiler create the required HTML/CSS/Js)
11:14:29 <evancz> Thank you :)
11:14:47 <gngdhr> evancz: are you aware of any other projects which do something similar to this (I hope I got the basic gist of the project right)
11:16:42 <ksf> evancz, use any installer that you want, but avoid those that you can't script like the plague.
11:17:08 <ksf> that is, one that can't generate an installer via command-line or something, but needs gui interaction to do so.
11:17:25 <evancz> sorry, someone just came to chat.
11:17:40 <evancz> gngdhr: that is the main idea
11:17:59 <evancz> Another nice aspect is that it is a Functional Reactive language
11:18:05 <ksf> first I found it hard to believe that such abominations actually exist, then I found myself folding my boss for being an idiot and buying a licence.
11:18:28 <evancz> That means user interaction can be handled without event handlers or some other imperative abstraction
11:18:52 <evancz> ksf, haha, of course!
11:19:15 <evancz> Do you know of any installers that are command-line oriented?
11:19:48 <evancz> I am new to this whole thing (the real world :P)
11:20:00 <ksf> http://nsis.sourceforge.net/Main_Page
11:20:17 <evancz> gngdhr: as for similar projects, the closest is probably ClojureScript
11:20:22 <evancz> I think that's what it's called
11:20:46 <evancz> It seems pretty cool as well, but it is just for JavaScript
11:21:07 <evancz> I guess Google's GWT (Graphical Web Toolkit) is similar to Elm as well, but it is all Java.
11:21:30 <gngdhr> yeah, GWT, yes indeed
11:21:46 <gngdhr> are you trying to evaluate an installer system to install on various platforms?
11:22:00 <evancz> ksf: Thank you!
11:23:01 <evancz> Yes! I have not done a distribution like this before, and (mistakenly?) thought that there would be some Haskell specific tool for it.
11:23:17 <gngdhr> why not push it through cabal?
11:23:27 <ksf> as far as linux is concerned, releasing the whole thing on hackage is the first step.
11:23:48 <evancz> Can you describe this more? I have not used cabal from the developer side.
11:23:49 <ksf> as far as gentoo is concerned, just ping #gentoo-haskell and let them autogenerate things.
11:24:00 <ksf> the rest of the distributions autogenerate from cabal, too.
11:24:33 <ksf> unless you need some C dependencies the whole thing should be quite trivial.
11:24:37 <evancz> I think this would be a good call because I expect Haskell people will be the main audience for use and controbutions
11:24:59 <evancz> No, no crazy dependencies.
11:25:14 <gngdhr> yes, cabal will be a good approach, since users can do something like cabal install elm (or such)
11:25:16 <evancz> (That I know of)
11:25:29 <ksf> evancz, http://www.haskell.org/cabal/users-guide/
11:25:45 <evancz> Ok, great!
11:25:47 <gngdhr> do you expect a lot of dependencies for your compiler?
11:26:09 <evancz> On Parsec and HAppStack...
11:26:14 <ergot> could somebody explain me why this join is eliminated by pl
11:26:16 <ergot> @pl \x -> join "\n" $ xs ++ [show x]
11:26:16 <lambdabot> '\n' . (xs ++) . return . show
11:26:22 <evancz> Crap, HAppStack may not be so easy
11:26:27 <ksf> evancz, then http://hackage.haskell.org/packages/upload.html
11:26:57 <gngdhr> if you are trying to package the compiler, why do you need happstack? Are you using some libs from happstack?
11:27:07 <ksf> happstack is on hackage.
11:27:24 <gngdhr> ergot: can you please paste your code snippet on http://hpaste.org, so that it is easier to view
11:27:51 <ergot> gngdhr is just that line
11:27:55 <ksf> :t join
11:27:56 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
11:27:57 <evancz> gngdhr, I'd like to bundle some basic server that automatically serves .elm files
11:28:04 <gngdhr> aah ok
11:28:05 <ksf> ergot, insert m == []
11:28:25 <evancz> The idea being that you shouldn't have to mess with that whole mess if you just want to put something on the internet
11:28:30 <ksf> wait.
11:28:34 <ksf> there's more going on.
11:28:46 <gngdhr> then I'd suggest that you create a cabal-able install and then after the code reaches some maturity, try to package with something like izpack / nsis
11:28:51 <ksf> > '\n' . (xs ++) . return . show
11:28:53 <lambdabot>   Not in scope: `xs'
11:29:00 <evancz> Also, ksf: HAppStack can be quite painful to install through cabal on Windows.
11:29:12 <gngdhr> that way, you will get more users to use elm - they won't need to install Haskell to try Elm
11:29:23 <elliott> evancz: You could ask the darcs guys, they do binary installers for Windows.
11:29:25 <ksf> evancz, windows is another story.
11:29:35 <elliott> But on Linux/OS X, cabal-install-based installation is preferable.
11:29:40 <elliott> (Agda does that)
11:30:03 <rewind24> how can i create a list starting from the middle?
11:30:27 <rewind24> for example (add here) : x : (add here)
11:30:30 <gngdhr> rewind24: you mean, create a sub-list from a certain position in the list?
11:30:33 <elliott> foo ++ [x] ++ bar
11:30:42 <elliott> note: this is pretty inefficient
11:30:47 <elliott> if you need to do this a lot, consider using something other than lists
11:30:48 <evancz> gngdhr: that plan makes sense to me.
11:31:36 <rewind24> gngdhr : no, create a BinarySearchTree2List function
11:31:40 <evancz> elliott: I'll look around for the darcs IRC.
11:31:48 <monochrom> if you are giving out the elm compiler (it's built by GHC), that's just one executable. if you bundle with a web server (again built by GHC), that's just one more executable.
11:31:59 <gngdhr> note that most users who want to try a new system will prefer having to install the least number of components, so if you can give them an installer that they can give a spin in an hour or so, it'd be great (sort of your elevator pitch :) )
11:32:29 <gngdhr> rewind24: I think elliott's approach will work for you
11:32:36 <rewind24> gngdhr : foo (Node left x right) = (foo left) ++ x ++ (foo right)
11:32:52 <rewind24> ty
11:32:56 <ksf> I'd be surprised if elm needs installation on windows in the first place.
11:33:18 <elliott> evancz: #darcs
11:33:41 <ksf> a plain binary should actually suffice.
11:34:04 <elliott> rwinkler: wrong
11:34:06 <elliott> argh
11:34:08 <elliott> rewind24: wrong
11:34:09 <elliott> x is not [x]
11:34:16 <rewind24> elliott : thank you it works
11:34:17 <elliott> [x] is the list consisting of the single element x
11:34:23 <rewind24> that's what i want
11:34:27 <rewind24> a single element
11:34:27 <ksf> ...one that starts the server, generates an example project in the directory it's in and serves it.
11:34:29 <brownies> is it a true statement that a Type is just a set of Typeclasses?
11:34:33 <rewind24> and append to left and right of it
11:34:36 <ksf> ...and listens for changes.
11:34:45 <evancz> gngdhr: you can already write code online without any install (the easiest way!), but yeah, I am hoping for exactly that :)
11:34:48 <monochrom> false statement
11:34:48 <elliott> brownies: no
11:34:51 <hpaste> dgpratt pasted “gameLoop” at http://hpaste.org/66515
11:34:52 <elliott> brownies: not even wrong
11:34:53 <ksf> bonus points for making that example the documentation/tutorial
11:34:57 <dgpratt> it seems like there must be some way to nicely collapse the last two statements in that "do" expression...suggestions?
11:35:01 <elliott> "a typeclass is just a set of types" is also wrong, but a lot closer
11:35:02 <rewind24> elliott : i actually need to delete an element from a binary search tree
11:35:32 <rewind24> elliott : and turn the children of said element into list, delete element, and add it back to the tree
11:35:40 <gngdhr> evancz: true, I checked the site and you are right. But, if you want developers to start using the system, then an installer will surely help
11:35:53 <brownies> elliott: hmm, ok, just trying to build some intuition as i go through the intro docs.
11:36:07 <brownies> is a given Type a Typeclass?
11:36:10 <elliott> brownies: what are you reading?
11:36:14 <brownies> http://learnyouahaskell.com/types-and-typeclasses
11:36:14 <elliott> and i don't know what that means, so no
11:36:30 <monochrom> a type is not a type class
11:36:30 <elliott> a typeclass is just a certain interface
11:36:36 <elliott> types can be instances of typeclasses
11:36:46 <evancz> ksf, maybe something like that. That's what Yesod does, yes?
11:36:52 <brownies> well, the OOP analogy would be Classes and Interfaces, right...
11:36:52 <elliott> typeclass i.e. a certain class of types, classifying types according to certain interfaces
11:37:00 <brownies> ok, i see
11:37:02 <ksf> I think, yes.
11:37:17 <brownies> so they are separate concepts, but closely related.
11:37:24 <brownies> but they can't be defined in terms of each other.
11:37:26 <evancz> gngdhr, definitely. I am going to open source fairly soon, so I want people to be able to contribute and develop on their own machine.
11:37:43 <monochrom> I wouldn't use OOP analogy. but if you insist, "length xs" is calling the method "length" on the object "xs"
11:38:14 <dgpratt> brownies: you may find this useful: http://stackoverflow.com/questions/6948166/javas-interface-and-haskells-type-class-differences-and-similarities
11:38:25 <gngdhr> evancz: good to know that (and apologize that I implicitly assumed that the code will be open-sourced). I think you will find a good number of adopters
11:39:52 <brownies> dgpratt: ok that helps somewhat
11:39:52 <monochrom> s/method/"method"
11:40:27 <evancz> No worries, I am both excited and afraid to go open-source :) Open-source appears to be required for a language unless you are Microsoft :P Also, thank you! I hope so!
11:40:28 <brownies> i was comparing it to Obj-C interfaces, which i think are slightly more versatile (from looking at the top SO answer, anyway)
11:41:25 <hpc> evancz: open-sourcing a programming language shouldn't be that hard; you just release the spec
11:42:00 <gngdhr> evancz: well, even MS did release some part of F# and some of ECMA standard components I believe.
11:42:00 <monochrom> except programmers never write specs
11:42:49 <evancz> hpc: I think languages that do not release the compiler as open source have a hard time. I am specifically thinking of the lazy language that preceeded Haskell, but was propriatary.
11:43:24 <evancz> gngdhr: they are definitely moving more towards that, but I mean C#, which is widely used and closed-source.
11:44:42 <evancz> In any case, I am going for open-source :P
11:44:59 <gngdhr> evancz: good to know that, and good luck
11:45:27 <hpc> ah, right
11:45:48 <shapr> Does apfelmus visit here under some other nick?
11:45:56 <shapr> byorgey: Ah, I see your comment now.
11:46:20 <monochrom> if anything, open source means, if you disappear, someone else could continue it
11:46:48 <evancz> Just to make sure I have understood everything: (1) Initial release through cabal. Haskell programmers can get started fairly easily. Totally new programmers get a two for one deal :) (2) Once the source is more stable, go for an independent installer. Talk to darcs folks to gain wisdom.
11:47:06 <evancz> monochrom: I am hoping to avoid disappearance :)
11:47:20 <evancz> but that is a good point!
11:47:21 <gngdhr> evancz: yup, you got that right
11:48:32 <hpc> evancz: you never know when a more interesting project comes along
11:48:53 <rewind24> what's wrong here ? :  parse error on input `|'
11:49:02 <rewind24> | (not search3 x (Node a left right)) = Node a left right
11:49:08 <evancz> Great, thank you for your help and advice gngdhr, ksf, and elliott! Now to begin learning about cabal :)
11:49:08 <clsmith> quick question. am i right in thinking monoids needn't be commutative?
11:49:13 <Liskni_si> or when you die :-)
11:49:13 <dgpratt> :r
11:49:16 <dgpratt> heh
11:49:24 <dgpratt> y'all didn't see that, right
11:49:32 <clsmith> saw what? <.<
11:49:43 <dgpratt> clsmith: k, good :)
11:49:49 <monochrom> list is non-commutative monoid
11:50:04 * clsmith nods
11:50:08 <evancz> True enough :)
11:50:18 <evancz> Anyway, thanks again everyone! :)
11:50:59 <clsmith> i wonder why i didn't think of lists... i think i was getting confused about kinds again
11:53:37 <rewind24> if anyone could tell me what is wrong here, i would appreciate it :
11:53:39 <rewind24> | x == a = list2Tree( delete x (tree2List (Node a left right)))
11:54:08 <monochrom> you should learn that you shouldn't take code fragments out of context
11:54:14 <rewind24> list2Tree::(Eq a, Ord a)=> [a]->BS3 a-> BS3 a
11:54:22 <rewind24> tree2List::(Eq a, Ord a)=> BS3 a-> [a]
11:55:40 <hpaste> rewind24 pasted “BST” at http://hpaste.org/66516
11:56:06 <rewind24> monochrom : will do
11:56:46 <rewind24> the error is on the last line
11:57:16 <monochrom> the error is on the line before it. missing parenthesis
11:57:38 <Liskni_si> rewind24: list2tree expects 2 args
11:57:46 <Liskni_si> and then the missing paren
11:58:15 <rewind24> liskni_si : list2tree gets 2 args
11:58:25 <rewind24> monochrom : ty
11:58:42 <Liskni_si> then I'm blind :-)
11:58:48 <rewind24>  Not in scope: `delete'
11:59:10 <navaati> hi
11:59:20 <monochrom> yeah, what is delete and where does it come from?
11:59:23 <rewind24> liskni_si : my bad
11:59:32 <rewind24> delete should be from the list package
11:59:57 <rewind24> http://www.haskell.org/ghc/docs/6.12.2/html/libraries/base-4.2.0.1/Data-List.html#v%3Adelete
12:00:17 <monochrom> cool, so shouldn't you need an import statement?
12:00:23 <Aune> So, I am on a system where I do not have root privileges. There is an old version of haskell platform in /usr. But that wont be upgraded soon, so I have to install my own version in my home catalog.  What is the recommended way to go about doing this?
12:00:50 <rewind24> oh, how do i do that?
12:00:55 <rewind24> import Data.List ?
12:01:05 <monochrom> yes. put it near the beginning of the file
12:01:13 <elliott> Aune: do you want new ghc too?
12:01:15 <hpc> Aune: you can compile ghc with custom flags
12:01:15 <elliott> presumably yes
12:01:19 <elliott> since haskell platform is tied to ghc version
12:01:26 <hpc> telling it to use ~/.bin or something
12:01:27 <elliott> but iirc the last two hps have had the same ghc version
12:01:27 <Aune> Yeah, I want a new ghc
12:01:47 <elliott> Aune: OK, just compile it with --prefix=$HOME/whatever using the system GHC; it'll take hours, though
12:01:48 <Aune> The old one is 6.12.1
12:01:57 <Aune> elliot, ok.
12:02:00 <hpc> Aune: then do the same for cabal, and don't do --global installs
12:02:05 <monochrom> ./configure --prefix=/home/monochrom/ghc-7.0.4
12:02:09 <elliott> Aune: which GHC do you want?
12:02:15 <elliott> i guess 7.0.4 if you want the platform
12:02:24 <elliott> oh wait
12:02:29 <elliott> Aune: you can probably use a GHC binary
12:02:32 <hpc> Aune: (hint: you want 7.4.1 if you're compiling yourself anyway; it has the coolest toys and you can always install cabal yourself too)
12:02:33 <Liskni_si> is it that wrong to just use the binaries?
12:02:42 <Elemir> Hem, what does ⊥ means in type theory?
12:02:51 <elliott> hpc: that is not really helpful considering how many people come in here with their problems compiling packages with 7.4.1.
12:03:09 <navaati> Elemir: the type that is inhabited by no values
12:03:14 <hpc> elliott: orly? ive had 7.4.1 solve problems for me
12:03:39 <elliott> Aune: nab a binary from http://www.haskell.org/ghc/download_ghc_7_0_4#binaries; ./configure --prefix=$HOME/whatever && make install; nab http://lambda.haskell.org/platform/download/2011.4.0.0/haskell-platform-2011.4.0.0.tar.gz; ./configure --prefix=$HOME/whatever && make && make install
12:03:48 <elliott> Aune: that'll only take about 30 minutes rather than six hours :P
12:03:51 <Elemir> navaati: ooo… Thanks
12:03:59 <elliott> hpc: yes, orly, most people just give up and downgrade
12:03:59 <Aune> elliott, oh, thanks
12:04:02 <hpc> Elemir: if you're using your type theory in logic mode, it's the "false" type
12:04:04 <monochrom> see my http://www.vex.net/~trebla/haskell/haskell-platform.xhtml for instructions on installing GHC and/or haskell platform. if you just want GHC that's fine, instructions still included. instructions for "choosing my directory" included
12:04:27 <navaati> Elemir: i'm not an expert, though… are you trying to do some agda stuff ?
12:05:02 <Elemir> No, I'm trying to read about call/cc in type theory terms.
12:05:04 <elliott> hpc: I keep my type theory set to stun.
12:05:38 <navaati> Elemir: beware, if you're talking about programming, the meaning of _|_ could be different
12:06:24 <Elemir> That programming exactly means?
12:06:34 <hpc> http://www.haskell.org/haskellwiki/Bottom
12:06:38 <navaati> it's undefined :D
12:06:47 <Elemir> Ugly application of type theory? :3
12:07:42 <hpc> bottom: the dirty underside of program semantics
12:07:52 <monochrom> a type that has no value. a value that is in every type.
12:08:24 <navaati> monochrom: ah, said like that it makes sense !
12:08:35 <Elemir> Makes
12:08:52 <Elemir> So _|_ is a subtype for every type?
12:09:08 <hpc> Elemir: no, there's two bottoms being discussed
12:09:13 <hpc> there's:
12:09:20 <hpc> data Bottom -- empty type
12:09:22 <monochrom> I don't know which type theory promotes values to subtypes like that
12:09:32 <hpc> bottom = bottom -- value of type forall a. a
12:09:35 <monochrom> actually I know one, but you have not heard of it
12:09:59 <Elemir> Ah
12:10:19 <hpc> "bottom" is called "undefined" in haskell
12:10:22 <monochrom> but it proves the words a wise man once said:
12:10:27 <navaati> usually in haskell we talk about the bottom value, whereas in agda and (i suppose) type theory we talk about the type (since the value CANNOT exist)
12:10:29 <hpc> "Bottom" is sometimes called "Void"
12:10:41 <monochrom> if a person is learning type theory, everything looks like a type to him/her
12:10:53 <hpc> @quote hpc paper
12:10:53 <lambdabot> hpc says: when all you have is Haskell, everything looks like a research paper
12:11:09 <hpaste> rewind24 pasted “BST” at http://hpaste.org/66517
12:11:21 <rewind24> if anyone is willing to explain please
12:12:22 <monochrom> well that's what Liskni_si was talking about. not enough parameters passed to list2Tree. you give only one parameter
12:12:31 <hpc> Elemir: another way to think of it is
12:12:33 <rewind24> i changed it
12:12:43 <rewind24> put Empty3 after delete x
12:12:44 <hpc> Elemir: the only value of type "Bottom" is "bottom"
12:13:12 <monochrom> ok, look, list2Tree(.....), does that look like 2 parameters or 1?
12:13:30 <rewind24> so list2Tree takes the list returned by delete and Empty3 now
12:14:05 <monochrom> no, don't explain your mind to me, the computer doesn't examine your mind anyway
12:14:27 <monochrom> look at the syntax list2Tree (...), does that look like 2 parameters or 1? to the computer.
12:14:42 <navaati> oh, makes me think about a question : agda enforces that the programs terminate. must i conclude from this that agda is not turing-complet® ?
12:14:50 <rewind24> monochrom : it takes 2
12:14:50 <hpc> navaati: yes
12:15:15 <navaati> ah, great, everything becomes clear then
12:15:17 <rewind24> monochrom : oooh, i understand
12:15:32 <hpc> navaati: incidentally, you can turn off the termination checker with a flag, which you can add to files with {-# your favorite kind of comment #-} :D
12:15:41 <monochrom> see? all you need to do is just forget what you think
12:16:03 <rewind24> well, umm i thought i fixed it
12:16:09 <rewind24> same error keeps popping up
12:16:13 <hpc> obviously you lose logical consistency
12:16:21 <hpc> because you can write (fix id) :: \bot
12:16:37 <monochrom> you put Empty3 at the wrong place
12:16:38 <hpc> navaati: you should join #agda
12:17:30 <rewind24> monochrom : yes i did
12:17:49 <navaati> hpc : well… actually i have no idea of what i cannot do in agda even if it's not a turing-complet language
12:17:49 <rewind24> monochrom : it compiles now, thank you
12:17:54 <Twey> Hm… what's an example of a program that can't be expressed in Agda without turning off the termination-checker?
12:18:02 <Twey> Heh
12:18:28 <hpc> Twey: you can't write filter for infinite streams
12:18:51 <hpc> Twey: because filter (const false) (whatever you want here) will never terminate
12:18:58 <Saizan> you can always express a program in Agda, not as an Agda function maybe though :)
12:19:02 <rewind24> thank you for the help, i'm done
12:19:10 <t7> roconner! where art tho?
12:19:11 <rewind24> and it works
12:19:47 <hpc> Twey: you can write a wonky dependently typed version of filter with a proof that the result of filtering an infinite stream is also an infinite stream
12:20:03 <hpc> but at that point you basically have a definition of the output stream already
12:21:19 <Twey> hpc: Aha
12:21:20 <elliott> preflex: seen roconnor
12:21:21 <preflex>  roconnor was last seen on #haskell 2 hours, 9 minutes and 3 seconds ago, saying: t7: BBL
12:21:24 <Twey> Saizan: Oh?
12:22:10 <Twey> hpc: Hm, is that true?  Isn't it more that you can't express an infinite stream to start with?
12:22:23 <brownies> ok, so this is what i was talking about... (bear with my noob questions, please)
12:22:39 <Twey> hpc: Say you have an infinite list; you're reducing the list on each step, so the filter should pass the termination-checker
12:22:40 <brownies> isn't it the case that Int is just defined as "things that implement both Integral and Bounded" ?
12:22:47 <Twey> But you can't construct an infinite list
12:22:49 <hpc> Twey: you can, but it's subject to different rules
12:22:54 <Twey> (because there's nothing to reduce)
12:22:54 <monochrom> I would rather write just one version of filter, untyped. then prove various properties of it without changing its type. including the part about giving it a H-M type.
12:23:00 <hpc> that is, instead of terminating, every step has to be productive
12:23:07 <Twey> brownies: No, Int is a specific type
12:23:09 <hpc> ie, you can write things like
12:23:13 <t7> i have an encryption function which takes an integer from 0 to p (where p is HUGE). Whats an safe and efficient way to encrypt a [Word8]? at the moment i convert the [Word8] into a [Integer (Base p)] encrypt and convert back but this takes ages
12:23:15 <hpc> > fix ("hello "++)
12:23:17 <lambdabot>   "hello hello hello hello hello hello hello hello hello hello hello hello he...
12:23:20 <hpc> > fix (++
12:23:21 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
12:23:22 <brownies> mm, alright, will keep reading.
12:23:25 <Twey> brownies: They're machine integers
12:23:26 <hpc> > fix (++ "hello") -- but not this
12:23:30 <lambdabot>   mueval-core: Time limit exceeded
12:23:59 <Twey> brownies: Word* are different types that also implement Integral and Bounded, for example.
12:24:09 <hpc> the productivity checker uses a very conservative heuristic, so it's a pain in the ass to deal with atm :P
12:24:18 <hpc> this should be in #agda ;)
12:24:19 <Twey> hpc: *scratches head*
12:24:27 <Twey> Yeah
12:24:27 <brownies> ok, i get it -- the difference is that a Type also encompasses specific implementation details down to the machine level, whereas a Typeclass is just a "contract," if you will, that the methods can be called
12:25:47 <monochrom> I am not sure I would insist down to the machine level. but a type has an implementation, yes
12:26:05 <navaati> brownies: yeah, this kind of "contract" is usually called an interface
12:26:27 <nevrenato> hi Haskellers !! Does anyone know why i get the error unknown extension : NoMonoLocalBinds ? I'm using cabal 1.10.2
12:26:44 <elliott> nevrenato: doesn't matter what cabal version
12:26:46 <elliott> what ghc version?
12:26:55 <elliott> it is probably too old for that extension
12:27:21 <Saizan> Twey: using the same technique that let you define a type of infinite streams you can define a type for computations that might not terminate (as a monad btw)
12:27:44 <brownies> navaati, monochrom: ok, thanks.
12:28:01 <Twey> Saizan: Does that not make it Turing-complete, then?
12:28:07 <elliott> Twey: no, because you can't express
12:28:11 <elliott> final_result : Computation a -> a
12:28:15 <Twey> Ah
12:28:24 <Twey> But you could never get a result out of the Computation a, then, right?
12:28:26 <elliott> Twey: but you _can_ write a program that, e.g. prints every step of the computation as it goes
12:28:37 <elliott> because IO is codata, more or less
12:28:40 <Twey> Ah
12:28:44 <Twey> Cool.
12:28:48 <elliott> (codata = potentially infinite, basically, like streams)
12:28:50 <hpc> is there a finalResult : Computation a -> IO a?
12:28:53 <elliott> and if you have a nop action in IO
12:28:57 <elliott> then you can do what hpc said
12:29:05 <elliott> because you just translate each step into a nop, and the final result into a return
12:29:18 <elliott> I don't know much about Agda's model of IO but I suspect it does
12:29:23 <elliott> return () should work if it has a monadic interface
12:29:26 <Twey> It's just Haskell's
12:29:32 <Twey> Via FFI
12:29:40 <elliott> basically the IO monad supports all the operations of a partial computation monad
12:29:51 <Saizan> return () is nop enough
12:29:53 <elliott> so you can write programs that never terminate
12:30:23 <nevrenato> elliott : 7.0.3
12:30:27 <navaati> elliott: they never terminate IFF the input stream never terminates
12:30:32 <navaati> right ?
12:30:38 <elliott> navaati: no, I don't believe so
12:30:48 <Saizan> tbc, you don't have to use the partiality monad to deal with infinite structures
12:30:52 <honza> honza_: who do you think you are?
12:30:52 <elliott> since I think Agda's IO is codata rather than data
12:31:06 <Saizan> it just happens that the partiality monad is one of those
12:31:06 <elliott> honza: that's you.
12:31:09 <elliott> you have the same IP.
12:31:11 <navaati> uh, i still need to get this "codata" thing
12:31:14 <elliott> Saizan: right
12:31:23 <elliott> navaati: codata just means: infinite structures, but you must take finite time to produce each constructor
12:31:29 <elliott> navaati: 1 : (1 : (1 : ...)) is OK
12:31:33 <elliott> navaati: 1 : _|_ is not
12:31:43 <honza> elliott: shhhh, i'm messing around with two irc clients :)
12:31:44 <elliott> so, you can represent a never-terminating computation as just () : () : () : () : ...
12:31:47 <elliott> honza: ah :P
12:31:56 <navaati> ah, yeah, the "productivity" thing
12:32:28 <navaati> is this integrated into the language ?
12:32:46 <mekeor`> should i name my code "Generation.hs" or "Generate.hs" (or even "Gen.hs"??) ?
12:32:48 <elliott> codata is a language thing, just like data
12:32:52 <elliott> (n.b. I know little about Agda)
12:33:17 <monochrom> I named my code Gen.hs already. you should try a different name :)
12:34:04 <monochrom> also try Generator, Generatee, Generatorisimo
12:34:39 <mekeor`> monochrom: which'd you recommend?
12:34:56 <elliott> Generatorioriser
12:35:00 <elliott> ificator
12:35:04 <danharaj> Agda is the Church tarpit, where everything is typeable and nothing is typecheckable.
12:35:07 <monochrom> sometimes I recommend the shortest name. some other times I recommend the first name you thought of
12:35:31 <Feuerbach> elliott: codata isn't necessarily infinite, is it?
12:35:36 <elliott> G.hs
12:35:41 <mekeor`> :D
12:35:43 <elliott> Feuerbach: indeed, possibly-infinite
12:35:45 <elliott> .hs
12:36:07 <monochrom> codatatatatata.... . hs
12:36:28 <monochrom> is a possibly-infinite module name
12:36:38 <elliott> :D
12:37:44 <mekeor`> okay, i'll call my code ":D" then.
12:43:06 <niklasb> is it safe to use `fromEnum` and `toEnum` to convert between word8 and integer? is there a better way? :)
12:44:19 <hpc> niklasb: they're safe enough, if you know that an integer won't overflow a word8
12:44:57 <niklasb> hpc: hm, I'm not so sure of it. basically I'm using getChar >>= ord to get the int
12:45:19 <niklasb> can I get codepoints > 255 through getChar?
12:45:29 <hpc> niklasb: yes, by design
12:45:37 <niklasb> hpc: so the input is decoded?
12:45:39 <navaati> niklasb: iirc, it's in the hackage doc
12:45:57 <niklasb> navaati: thanks, will check :) guess I'll just truncate the rest
12:46:00 <mekeor`> theoretically, you can use toInteger, too. but there are no advantages, afaik.
12:46:48 <niklasb> mekeor`: thanks
12:47:05 <mekeor`> i didn't help. i just hoogled :)
12:47:14 <niklasb> mekeor`: clever :P
12:47:36 <mekeor`> niklasb: you can even use fromInteger! because Word8 is an instance of Num!
12:48:07 <niklasb> mekeor`: yeah, that'll just wrap the value around.. not pretty but acceptable
12:55:46 <honza_> q
13:03:26 <fuzzy_id> i'm trying to install yi
13:03:43 <fuzzy_id> but it needs happy >= 1.17
13:03:54 <fuzzy_id> and i cannot get it installed
13:04:09 <elliott> did you try cabal install happy
13:04:14 <fuzzy_id> yepp
13:04:22 <elliott> hpaste the error
13:04:24 <fuzzy_id> installed happy 1.18 or the like
13:04:47 <fuzzy_id> but, it doesn't appear in ghc-pkg list
13:04:51 <geekosaur> check it's in $PATH (you may need to add ~/.cabal/bin to $PATH)
13:05:53 <geekosaur> fuzzy_id, happy is not a library so doesn't show up in ghx-pkg list
13:05:58 <geekosaur> ghc-pkg
13:06:59 <fuzzy_id> ok, i'll try that
13:09:05 <fuzzy_id> geekosaur: it seems to work, thanks a lot
13:14:58 <roconnor_> t7: *ping*
13:20:12 <t7> hey
13:35:48 <FUZxxl> Ah...
13:36:46 <FUZxxl> Is installing darcs with a recent GHC just pain-in-the-ass or impossible?
13:37:07 <FUZxxl> I mean, with GHC 7.4.2
13:37:11 <bitonic> FUZxxl: you mean building?
13:37:51 <FUZxxl> yeah
13:38:08 <bitonic> anyways, last time I tried I couldn't compile it with 7.4, but it's one of those things for which is convenient to just install the binaries
13:39:16 <elliott> 7.4.2?
13:39:22 <elliott> there is no such thing
13:39:27 <elliott> so probably impossible :)
13:39:31 <elliott> oh, wait
13:39:37 <elliott> is an RC out?
13:44:25 <FUZxxl> elliott: hm...
13:44:37 <FUZxxl> Sorry. It was just 7.4.1
13:44:49 <FUZxxl> I constantly run into dependency-hell-like problems.
13:45:17 <FUZxxl> Why-the-fuck are there upper limits on each and every package included? This makes compilation so extremely difficult...
13:45:41 <FUZxxl> Especially if one of the packages you need to import don't compiles in an old version.
13:47:30 <elliott> FUZxxl: because PVP
13:48:10 <luite> the PVP doesn't scale very well though...
13:48:12 <mnieminen> how can I make my records to accept empty values
13:48:25 <acowley> FUZxxi: people were (are?) more worried about somebody releasing a new upstream package that broke their code
13:48:29 <gwern> > 6450000000 % 6900000
13:48:30 <lambdabot>   21500 % 23
13:48:41 <mnieminen> I've created a record where type of each value is "Maybe String"
13:48:51 <mnieminen> but the default constructor does not work
13:48:52 <acowley> But I think upper version constraints are falling out of favor due to the everyday problems people run into
13:48:53 <FUZxxl> PVP? What's that?
13:48:58 <elliott> http://www.haskell.org/haskellwiki/Package_versioning_policy
13:49:03 <FUZxxl> Ah.
13:49:07 <gwern> > 21500 / 23
13:49:07 <lambdabot>   934.7826086956521
13:49:26 <FUZxxl> IMHO, something is fundamentally broken with the way Haskell packaging works.
13:49:37 <bitonic> FUZxxl: that's a very unoriginal stance.
13:50:04 <elliott> It takes time for updates to propagate through Hackage.
13:50:12 <elliott> GHC 7.4 even broke backwards-compatibility.
13:51:11 <acowley> I guess the future is some kind of more cabal-dev-y solution that makes it easier to have multiple versions of a library on a system.
13:51:54 * elliott wonders why people are waiting for a cabal-dev-y solution when we have cabal-dev :)
13:52:05 <FUZxxl> Yeah. I mean, that's one of the biggest problems: The API's in cabal packages change too often, since people seeme to care a little about consistency
13:52:17 <acowley> elliot: it comes with a few annoyances
13:53:07 <acowley> elliott: it would be nice to register system-wide where some source lives, for example. If I have 10 libraries that I use in all my projects, the dance steps I have to perform to keep everything up to date are a bit fiddly
13:53:27 <acowley> elliott: I'd also like to see some sharing of compiled files for really big packages
13:53:28 <FUZxxl> I actually dislike the idea of having a dedicated packaging system for a programming language.
13:53:31 <bitonic> FUZxxl: that's the cost of Haskell faster-than-light progress rate
13:53:40 <elliott> acowley: well you can just "cabal-dev add-source a b c d" -- you could script that if you do it a lot... but it's not ideal
13:54:22 <acowley> elliott: yeah, I know. But it's having to do that add, then when you change a dependency you need to unregister in cabal-dev and re-add the source directory
13:55:47 <elliott> yeah
13:56:07 <FUZxxl> kinda
13:56:21 <luite> elliott: cabal-dev alone isn't enough imho, it only works well if you're working on a single package, and your dependencies are all (or almost all) already on hackage
13:59:02 <luite> acowley: you can use cabal-src-install to register new source packages on your system, they'll work for cabal and all cabal-dev
13:59:56 <acowley> luite: that looks great, thanks!
14:00:34 * hackagebot category-extras 1.0.2 - A meta-package documenting various packages inspired by category theory  http://hackage.haskell.org/package/category-extras-1.0.2 (DanielWagner)
14:02:22 <luite> acowley: there's also cabal-meta that can be useful to install a large tree of unreleased packages with dependencies, useful where you're working on something like yesod
14:02:44 <luite> and a few other hacks of things that probably should eventually end up in cabal-install in some form
14:02:53 <mekeor`> how do you run a monadic function n-times?  with 'forM_ [1..n] func' ?  or is there a better way?
14:03:01 <luite> replicateM
14:03:13 <mekeor`> ah, cool, nice. i remember… thanks. :)
14:03:19 <gspr> I find myself branching off into significant chunks of code using "when" from Control.Monad. Is there an agreed-upon way to format code using when, treating it sort of like a keyword, or should I just factor out the big chunk into a function?
14:03:50 <luite> mekeor`: or replicateM_ if you want to ignore results
14:04:08 <mekeor`> yep
14:05:36 <acowley> gspr: Refactor the code. You need to at least make the control flow as visible and easy to follow as possible.
14:06:52 <gspr> acowley: Yep, I thought so. I was just checking that it isn't common to, say, add some paranthesized indendet code block as the second argument to when to mimic imperative code
14:07:04 <gspr> *indented
14:11:29 <Mathnerd314> are there any libraries that someone wants but hasn't written yet?
14:12:18 <navaati> Mathnerd314: you are bored and looking for work ?
14:12:36 <Mathnerd314> navaati: basically :-)
14:13:09 <navaati> then i would love an EGL binding, or a working implementation of GObject Introspection :D
14:13:59 * Mathnerd314 attempts to figure out what those are
14:14:49 <navaati> complicated things
14:15:07 <copumpkin> Mathnerd314: I'd like a disk-based building block library that offers you a basic disk-based B-tree and a few othe common basic structures, that you can then build more complicated structures on top of.
14:15:15 <copumpkin> ideally with nice ACID guarantees and such :)
14:16:04 <navaati> copumpkin: are you asking for btrfs coded in haskell ?
14:16:30 <copumpkin> not really :) just building blocks to have efficient disk-based lookup structures
14:16:32 <tech2> navaati: or BeFS, or plenty of others
14:17:20 <navaati> tech2: yeah, i just said the first one that came to my head… BeFS, like the FS of BeOS ? woaw
14:17:34 <tech2> navaati: it was amazing in its time.
14:17:38 <Mathnerd314> navaati: this EGL? http://en.wikipedia.org/wiki/EGL_%28programming_language%29
14:18:20 <navaati> Mathnerd314: nop, this one : http://www.khronos.org/egl
14:18:43 <Mathnerd314> ah
14:19:10 <navaati> copumpkin: i don't really figure out what is the interface of a "disk based" library…
14:20:10 <Mathnerd314> navaati: and this is GObject introspection: http://live.gnome.org/GObjectIntrospection ?
14:20:18 <navaati> yes
14:20:30 <navaati> there is already haskell work on this
14:20:35 <copumpkin> a disk-based b-tree and a disk-based hashtable, both would give you data.map-like operations, but in IO (or some other more restricted type)
14:20:40 <navaati> i'm curious if it's still alive
14:22:19 <Mathnerd314> http://www.haskell.org/haskellwiki/GObjectIntrospection seems relatively recent
14:23:45 <Mathnerd314> so I don't think it counts, since somebody's written it (bugs don't count ofc)
14:23:46 --- mode: ChanServ set +o copumpkin
14:23:49 --- mode: ChanServ set -o copumpkin
14:24:41 <navaati> Mathnerd314: oh, there has been updating \o/ !
14:24:56 <navaati> yay
14:25:29 <acowley> GHC's error messages have improved tremendously over the years
14:25:45 <acowley> It now spoils me for other type checkers
14:26:33 <FUZxxl> wtf?
14:26:36 <dmwit> endojelly: For your next trick, spell "hello" (or any other word with two copies of a letter in a row).
14:27:04 <kaitocracy> this might be a stupid question but why doesn't this work? http://hpaste.org/66522
14:27:07 <dmwit> FUZxxl: Probably a joke in another channel.
14:27:16 <endojelly> dmwit, tricky 8) but in the interest of everyone here and elsewhere I will not attempt it...
14:27:27 <endojelly> dmwit, right on
14:28:03 <endojelly> dmwit, though I kinda wonder if it is possible in any way
14:28:05 <endojelly> probably not
14:28:09 <dmwit> kaitocracy: Because the type you gave flist requires the user to be able to choose any instance of Test.
14:28:10 <dolio> kaitocracy: Your type for flist is wrong.
14:28:28 <dmwit> kaitocracy: But you are giving a list whose elements are a particular instance of Test, instead.
14:29:08 <dmwit> compare "forall a. Test a => [a]" and "exists a. Test a => [a]"
14:29:10 <kaitocracy> dmwit: wait so what's wrong with that? I'm saying that the elements of flist will all be instances of Test
14:29:19 <dmwit> kaitocracy: No, you're not.
14:29:37 <kaitocracy> what am I saying?
14:29:40 <dmwit> kaitocracy: The type you gave is saying that, no matter what instance of Test I choose, the list you construct will have elements of that type.
14:29:56 <kaitocracy> ahhh
14:30:04 <kaitocracy> oh
14:30:07 <kaitocracy> so I need a forall
14:30:12 <dmwit> No, please.
14:30:18 <dmwit> Just give it the type you mean: [Text]
14:30:19 <dolio> It's already a forall.
14:30:36 <kaitocracy> wait so there's actually no way to create a heterogeneous list
14:30:36 <kaitocracy> huh
14:31:06 <dmwit> There is a way. But it's silly, and you shouldn't do it.
14:31:11 <dmwit> ?wiki existential type
14:31:11 <lambdabot> http://www.haskell.org/haskellwiki/existential_type
14:31:36 <kaitocracy> ahh hide the type using a forall I see
14:36:45 <acowley> It's like the pythons said, "On second thought, let's not use existential quantification to make a heterogenous list, it is a silly technique."
14:37:02 <kaitocracy> why is it silly?
14:37:41 <acowley> kaitocracy: whatever you want to do with your class-constrained values, you could just do
14:38:01 <kaitocracy> acowley: what do you mean?
14:38:04 <glguy> Yeah, who needs typeclasses when you can pass dictionaries around?
14:38:22 <acowley> kaitocracy: As per the usual example, if you have a hetero list of things that are Showable, why not just show each item and work with a [String]?
14:39:11 <kaitocracy> what if I have a list of monadic actions and I want to pass that around?
14:39:23 <elliott> glguy: except that lists of existential types are generally used when the types of the typeclass are irrelevant, and only being used to implement a dictionary
14:39:26 <elliott> kaitocracy: [m ()]
14:39:30 <elliott> or [m Int] or whatever
14:39:33 <elliott> for appropriate m
14:39:45 <kaitocracy> but they might be different monads for example
14:40:09 <Philippa> you're going to have a lot of trouble doing anything useful with that list even if you do use an existential, then
14:40:30 <acowley> There is an expectation that you will eventually do something with each item in the list.
14:40:41 <elliott> yeah, that's frankly pretty useless :P
14:40:44 <glguy> elliott: I don't know how to reconcile your response to my flippant comment :)
14:40:56 <elliott> unless you have like a (MonadState m) constraint... in which case just pass around State actions
14:41:09 <elliott> glguy: fair enough, i misinterpreted it as ha-ha-only-serious :)
14:41:19 <acowley> glguy: I didn't get your flippancy. I'm not advocating that we give up typeclasses!
14:41:25 <Philippa> so I suspect there's some value in getting to enforce instance coherency still
14:42:52 <acowley> Coming from dynamically typed languages, it does seem like you just need to hold your head under the kool-aid for long enough until you no longer want heterogenous collections.
14:44:11 * magicman enters yesod/conduit-dependency-hell.
14:44:53 <elliott> acowley: I think people use heterogeneous collections much less than they think they do
14:45:29 <elliott> I mean, duck typing obscures the issue, but usually it's all stuff with a very concrete common interface, and often even a list of subclasses of a common superclass, e.g.
14:45:38 <elliott> in which case the translation to haskell is really really simple :)
14:45:44 <acowley> elliott: Absolutely! But I grappled with it when I first started with Haskell, and it's a really common issue here. I think there's great intuitive appeal to it somehow.
14:45:49 <elliott> yeah
14:45:51 <glguy> I would guess that having algebraic data types reduces some of the need as well
14:45:55 <acowley> But it's an ad hoc interface
14:46:06 <elliott> it feels really constricting not being able to do it until you fully grasp how to implement interfaces with algebraic data types and functions
14:46:07 <Philippa> thing is, I know use cases where you need heterogenous collections /plus ways to do an 'interface query'/. If you want to make that scaleably extensible and typeful, Haskell's completely SOL anyway
14:46:41 <elliott> Philippa: [forall a. Proxy a -> Maybe a]?
14:46:49 <glguy> [Either A B] instead of a [Whoknows]
14:46:50 <acowley> Sounds like a use case for dependent pairs
14:47:56 <Mathnerd314> copumpkin: http://www.haskell.org/pipermail/haskell-cafe/2005-November/012009.html ?
14:48:46 <elliott> Philippa: oh wait, that obviously doesn't work
14:48:47 <elliott> parametricity
14:48:54 <elliott> [Dynamic] ;)
14:49:20 <bitonic> yes yes, Dynamic is the solution
14:49:39 <acowley> elliott: it's good to throw an unsafeCoerce in somewhere to make sure the square peg fits in the round hole
14:50:40 <Philippa> acowley: I don't know any non-dependently typed lang that can pull it off (typefully), though. And as I say, I know use cases
14:51:56 <acowley> Philippa: I don't either, but Haskell/GHC keeps getting closer
14:55:42 <Mathnerd314> does unsafeCoerce get removed in Core?
14:56:35 <elliott> no
14:56:38 <elliott> Core is typed
14:56:42 <monochrom> no. actually, GHC adds more unsafeCoerce's than you write
14:56:57 <dolio> It doesn't add unsafe coerces.
14:57:00 <Philippa> still?
14:57:08 <Philippa> I mean, it used to prior to System Fc...
14:57:42 <elliott> doesn't it use unsafeCoerce for newtype unwrapping?
14:57:43 <elliott> maybe i'm wrong
14:58:50 <monochrom> sorry, it adds a lot of "cast"s
14:59:17 <dolio> It has all kinds of baffling witnesses that indicate that its coercions are safe.
14:59:28 <seven7777> hi
14:59:36 <seven7777> any1 here
14:59:41 <seven7777> i have a question
15:00:05 <seven7777> im getting a strange error
15:00:06 <elliott> there are 871 people here, yes
15:00:14 <elliott> hpaste your full code and error, please :)
15:00:32 <seven7777> impelim :: Formel -> Formel impelim (Verbindung a b)      = Verbindung (impelim a) (impelim b) impelim (Disjunktion a b)     = Disjunktion (impelim a) (impelim b) imperim (Bedingt a b)         = Disjunktion (Negation $ impelim a) (impelim b) impelim (Bikonditionaler a b) = Verbindung (Disjunktion (impelim $ Negation a) (impelim b)) (Disjunktion (impelim $ Negation b) (impelim a))
15:00:34 <seven7777> sry
15:00:43 <seven7777> ill copy it nicer
15:00:51 <edwardk> @remember xplat i just finished the first exercise of TAPL in Agda. spent all afternoon building up enough definitions to be able to state the question.
15:00:51 <lambdabot> I will remember.
15:00:57 <seven7777> impelim :: Formel -> Formel
15:01:22 <Philippa> elliott: you certainly don't need to do that if you have System Fc - you declare coercions each way when you see the newtype decl and off you go
15:01:24 <seven7777> impelim (Verbindung a b)      = Verbindung (impelim a) (impelim b)
15:01:26 <edwardk> seven7777: please use something like
15:01:27 <edwardk> @hpaste
15:01:27 <lambdabot> Haskell pastebin: http://hpaste.org/
15:01:36 <edwardk> rather than flood the channel
15:01:40 <monochrom> http://www.vex.net/~trebla/humour/lazy-question-stream.html
15:01:44 <seven7777> ah ty :)
15:02:29 <hpaste> seven pasted “help” at http://hpaste.org/66523
15:02:56 <elliott> Philippa: yeah i was mistaking the casts for unsafeCoerces
15:03:07 <Twey> gspr: There's nothing wrong with passing a do-block as the second argument to ‘when’ and indenting as normal
15:03:10 <seven7777> im getting error Mulitiple declaration of impelim?
15:03:15 <Philippa> if it's any consolation, that's how it used to do it :-)
15:04:04 <elliott> seven7777: line 5, 6, 7
15:04:09 <elliott> look at the first words on each
15:04:11 <hpaste> Twey pasted “when … do … ” at http://hpaste.org/66524
15:04:19 <Twey> gspr: http://hpaste.org/66524
15:04:25 <elliott> lines 6 and 7 are starting new definitions
15:04:35 <Twey> Oh, the hpaste bot works now
15:05:36 <seven7777> oh damn
15:05:43 <seven7777> how stupid am i
15:05:48 <seven7777> thanks a lot :)
15:07:13 <stj> I'm writing my own linked list and experimenting with it... I can create a data constructor with name "append" just fine, but can't with name (:-:), why is that?
15:07:15 <elliott> np :P
15:07:16 <hpaste> stj pasted “Can't create an alias for a data constructor” at http://hpaste.org/66525
15:07:27 <elliott> stj: : starts a constructor
15:07:32 <elliott> it's the same reason you can't call it Append
15:07:36 <t7> how do i push a value down a conduit?
15:07:38 <elliott> : as first symbol is reserved for infix constructors
15:07:41 <elliott> try -:
15:07:49 <elliott> or data List a = Empty | a :-: List a
15:08:01 <elliott> stj: (btw, why are you using Hugs?)
15:08:11 <stj> cool, didn't know that, thanks! :)
15:08:17 <stj> it's GHCi
15:08:20 <elliott> oh, is it?
15:08:31 <elliott> did you add the "ERROR:"?
15:08:31 <stj> yep, not sure what makes you think it's Hugs :)
15:08:36 <stj> nope
15:08:38 <elliott> i've never seen GHCi give errors like that...
15:08:39 <elliott> what version?
15:08:40 <stj> yes, sorry*
15:08:44 <elliott> ah
15:08:45 <stj> I did put it
15:08:46 <elliott> that explains it, then ;)
15:09:01 <elliott> I have a rudimentary Hugs error pattern matcher in my head from helping people at university who are required to use Hugs, heh
15:09:46 <stj> I never used hugs :)
15:10:31 <elliott> edwardk: your portability field in reflection is out of date
15:10:32 <elliott> in the haddocks
15:10:40 <edwardk> elliott: ?
15:11:27 <elliott> edwardk: says it uses scoped types
15:11:32 <edwardk> ah
15:11:44 <elliott> urgent bug, naturally
15:12:50 <edwardk> obviously
15:13:45 <edwardk> i've been meaning to re-release it with a slightly different api again anyways
15:13:52 <edwardk> its been on the cusp of useful for too long ;)
15:14:18 <edwardk> (basically i want to swap the MPTC for a type family)
15:14:32 <edwardk> it wasnt possible when i first wrote it
15:14:38 <edwardk> but now it works fine
15:15:40 * hackagebot reflection 0.5.0.1 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.5.0.1 (EdwardKmett)
15:17:02 <edwardk> hrmm i wonder if i can make that a single parameter type class actually
15:17:31 <Mathnerd314> preflex: xseen Lemmih
15:17:32 <preflex>  Lemmih was last seen on freenode/#haskell 11 hours, 42 minutes and 45 seconds ago, saying: bobry: Prelude.
15:18:11 <Lemmih> Mathnerd314: Yo?
15:18:29 <t7> ;;seen litherum
15:18:45 <t7> Myles C. Maxfield ?
15:19:32 <Mathnerd314> Lemmih: just noticed you were author of the SDL package
15:22:57 <edwardk> sweet. i can get rid of the need for MPTCs/fundeps
15:23:03 <edwardk> and the api doesn't really change much
15:24:04 <sebasmagri> Hi! Have anyone worked with Aeson? I'm having troubles with generic records and json null values...
15:24:24 <edwardk> and flexible instancs
15:24:29 <edwardk> so now it only requires rank 2 types
15:24:34 <sebasmagri> how could I handle a value that could be Value or null?
15:24:51 <monochrom> use Maybe
15:25:11 <edwardk> reify :: a -> (forall s. Reifies s => Proxy (s a) -> w) -> w
15:25:26 <edwardk> :source Maybe
15:25:31 <edwardk> @source Maybe
15:25:31 <lambdabot> Maybe not available
15:25:34 <edwardk> @src Maybe
15:25:34 <lambdabot> data Maybe a = Nothing | Just a
15:27:33 <sebasmagri> monochrom, thanks..! makes a lot of sense...
15:28:07 <zzo38> The Haddock document for dvi-processing is now available. So now you can make typesetting with Haskell, too.
15:28:56 <zzo38> Now please tell me in case anything wrong with it!
15:31:06 <zzo38> I think someone wanted to use my dvi-processing package once, for including in pandoc?
15:35:26 <elliott> <edwardk> sweet. i can get rid of the need for MPTCs/fundeps
15:35:27 <elliott> whoa, how?
15:35:30 <elliott> ah
15:35:37 <elliott> that's awesome
15:35:41 <edwardk> yeah
15:35:48 <edwardk> i'm pushing it in a sec once i improve the docs a little
15:35:59 <DijkstraGroupie> Hello, I made a little benchmark to test two versions of Fibonacci function: http://hpaste.org/66527. I want to know why the version with the inner "sign" runs slower?
15:36:17 <DijkstraGroupie> s/inner/most inner/
15:36:35 <elliott> edwardk: now remove the horrible FFI stuff ;)
15:36:45 <edwardk> hah, needs stableptr =)
15:38:01 <parcs`> DijkstraGroupie: are you compiling with -O2
15:38:15 <navaati> damn, i didn't know it was possible to nest where blocks like this, great !
15:39:25 <monochrom> recursion (in the grammar) is a powerful and underappreciated idea
15:40:27 <parcs`> guards in case expressions are pretty cool too
15:40:40 <monochrom> e.g., if the type grammar allows "type -> type", people do not appreciate that it allows "(A->B) -> C". they think it's magic
15:41:21 <navaati> monochrom: well, actually i thought there was a stupid non-nesting limitation on where clauses, but i was wrong
15:41:42 <monochrom> C is the mother of stupid no-nesting limitations
15:41:56 <Twey> >.<
15:41:56 <monochrom> even Algol-60 was better
15:43:03 <DijkstraGroupie> parcs`: I am running everything from ghci.
15:43:36 <navaati> C is the mother of all evils, anyway, eh ?
15:43:37 <navaati> i've just realized a few days ago that haskell was just perfect to do good old imperative-manual-memory-management-manual-arbitrary-writing-in-memory programing
15:44:13 <navaati> which makes haskell a strict superset of C…
15:44:38 <monochrom> well, C just misses being the mother of this evil: being English. COBOL got that one
15:44:56 <zzo38> navaati: Is it? I don't think so.
15:44:57 <parcs`> DijkstraGroupie: ghci doesn't even do the obvious optimizations. perhaps 'sign' is being reconstructed for every time mul (x, y) is called
15:44:58 <DMcGill> what do you mean superset? Aren't they all equiv to turing machines anyway...
15:45:08 <elliott> navaati: Well, GHC still uses a GC...
15:45:11 <navaati> (well, with an exception : with this damn uncontrollable GC, it's impossible to do realtime stuff…)
15:45:15 <navaati> elliott: yeah
15:45:28 <zzo38> But, still, yes you can so those kind of things using malloc and peek and poke and so on; GHC does support those operations
15:45:35 <Mathnerd314> there's DDC iirc
15:45:53 <bitonic> zzo38: GHC != Haskell
15:46:18 <navaati> zzo38: yeah, that's what i was thinking about, it's really non-obvious that you can do that when you first come to haskell
15:46:22 <bitonic> wait, the malloc stuff might be in the report
15:46:30 <navaati> bitonic: it's in the FFI
15:46:38 <navaati> so it's standard stuff :)
15:46:42 <elliott> navaati: jhc does region inference for haskell
15:46:47 <elliott> but they have a gc too since it wasn't good enough i think
15:46:54 <bitonic> navaati: yes, in 2010 at least
15:46:59 <elliott> haskell is not really suited to memory management strategies other than gc
15:47:18 <monochrom> the FFI allows you to write C to call Haskell. now C is a superset of Haskell, too. equity is restored :)
15:48:47 <navaati> bitonic: the FFI was standardized only in 2010 ?
15:48:55 <monochrom> anyway, ghci performance measurements are pointless
15:49:04 <elliott> navaati: no
15:49:12 <elliott> it was folded into the report in 2010
15:49:14 <elliott> before that it was a separate spec
15:49:17 <navaati> aaaah
15:49:37 <navaati> yeah, it was already standard
15:51:09 <navaati> oh, btw, have you guys heard about any recent things related to that http://mikeburrell.wordpress.com/2007/02/01/real-time-haskell/ ?
15:51:30 <navaati> or anything else enabling to do RT in haskell ?
15:53:00 <zzo38> What is your others ideas for dvi-processing package?
15:54:23 <Twey> navaati: Sounds silly
15:54:35 <navaati> Twey: ?
15:54:54 <elliott> that was a less interesting proposal than i hoped
15:55:56 <navaati> ah, the link ? yeah, it's not the greatest thing i've seen, but… it's one of the only thing iv've found
15:56:24 <Twey> 1. Haskell code isn't that slow; laziness adds overhead, but not much compared to other languages like Python or Java.  2. Haskell performance constants can be unpredictable, but you can get an *upper bound* on complexity just as easily as with Java.  Java performance constants are even harder to predict, as you have to deal not only with (admittedly less drastic) compile-time optimization, but also with the VM optimizing your code *as it's running*:…
15:56:30 <Twey> … performance characteristics can be defined at runtime based on input, &c.
15:56:38 <parcs`> > let _ = case () of _ -> a where a = 4 where a = 3
15:56:39 <lambdabot>   not an expression: `let _ = case () of _ -> a where a = 4 where a = 3'
15:56:45 <parcs`> > let b = case () of _ -> a where a = 4 where a = 3 in b
15:56:46 <lambdabot>   4
15:57:00 <parcs`> isn't that ambiguous
15:57:08 <Twey> parcs`: No
15:57:15 <parcs`> let b = case () of _ -> a (where a = 4 where a = 3) in b vs
15:57:22 <monochrom> no fair citing python or java. they are not real-time either.
15:57:25 <elliott> Twey: GC is still a big problem for a real-time scenario though.
15:57:26 <Twey> let … in establishes a region
15:57:29 <parcs`> let b = (case () of _ -> a where a = 4) where a = 3 in b
15:57:37 <Twey> monochrom: The article cites Java as a better language for real-time programming
15:57:45 <elliott> parcs`: "a where a = 4" is not valid
15:57:47 <Twey> elliott: Yes; that's the only valid point the article makes.
15:57:50 <monochrom> oh haha
15:58:19 <Twey> monochrom: (well, not explicitly, but says it's more predictable and easier to analyse, performance-wise)
15:58:32 <parcs`> elliott: wait what's not valid?
15:58:39 <elliott> Twey: Yeah. The proposal just adds huge cognitive overhead to the point where using Haskell seems incredibly pointless (especially as it's IO-bound) without actually solving the problem of what happens if the GC can't reclaim the memory it needs in the time it's given...
15:58:44 <Twey> parcs`: ‘where’ does not attach to an arbitrary expression
15:58:45 <elliott> parcs`: case () of _ -> a where a = 4
15:59:00 <parcs`> > case () of _ -> a where a = 4
15:59:01 <lambdabot>   4
15:59:03 <elliott> wtf
15:59:05 <Twey> elliott: Yeah.  That's what I was thinking about that proposal.
15:59:07 <parcs`> AMBIGUITY
15:59:12 <parcs`> :D
15:59:12 <elliott> no seriously wtf?
15:59:14 <Twey> Also you'd end up with the need for a lot more IO code.
15:59:17 <stj> if I write x <- getLine and immediately after that y <- getLine, is it guaranteed that x will be read first, and only after that y?
15:59:22 <elliott> I don't understand how that's valid
15:59:22 <Twey> case can have a where
15:59:23 <Twey> No?
15:59:26 <elliott> Really?
15:59:29 <elliott> That's weird.
15:59:30 <Twey> I see no reason why not
15:59:36 <Twey> It's just another pattern-match
15:59:45 <monochrom> lambdabot turns your "> x" into "answer = x", so you can add where
15:59:51 <elliott> Twey: So?
15:59:57 <elliott> Pattern-matches don't all have where clauses.
15:59:58 <monochrom> using lambdabot to rationalize your wish is silly
16:00:01 <elliott> monochrom: Oh, that explains it.
16:00:05 <elliott> Wait, are you sure?
16:00:07 <Twey> Oh
16:00:08 <elliott> I thought it used mueval these days.
16:00:10 <Twey> elliott: But why wouldn't you?
16:00:18 <elliott> Twey: Wouldn't you what?
16:00:20 <Saizan> stj: yes
16:00:25 <Twey> Allow a where to attach to a case
16:00:33 <elliott> Because that's what let is for :P
16:00:35 <parcs`> it works in ghci too
16:00:44 <elliott> I guess it makes sense because of guards.
16:00:45 <parcs`> so i c, because ghci does the same
16:00:48 <Twey> elliott: Right
16:00:58 <elliott> Prelude> case () of () -> a where a = 42
16:00:58 <elliott> 42
16:01:05 <Twey> A case branch and a function definition are basically the same thing
16:01:05 <parcs`> but how do you explain
16:01:06 <elliott> Well, you learn something new every day.
16:01:07 <parcs`> > case () of _ -> (case () of _ -> a where a = 4)
16:01:08 <lambdabot>   4
16:01:16 <elliott> How do I explain it?
16:01:19 <elliott> There's nothing to explain.
16:01:24 <Twey> parcs`: The same as the other one
16:01:37 <Twey> You've just stuck it inside another case :þ
16:01:51 <parcs`> Twey: i was referring to monochrome's explanation
16:01:54 <elliott> <monochrom> recursion in the grammar!
16:01:55 <Twey> Oh
16:02:16 <Twey> Yeah, I don't think ‘answer = x’ is the solution
16:05:01 <elliott> still a bit shocked that cases can have wheres :)
16:05:03 <t7> is IO allways strict? or just special functions like print etc
16:05:19 <elliott> strictness is irrelevant
16:05:28 <elliott> in (m >> m'), m's IO effects will always happen before m', yes.
16:05:32 <elliott> *m''s
16:05:50 <parcs`> > let c = 5; d = c b = case () of _ -> c where c = 3 in d
16:05:51 <lambdabot>   <no location info>: parse error on input `='
16:05:52 <parcs`> > let c = 5; d = c; b = case () of _ -> c where c = 3 in d
16:05:53 <lambdabot>   5
16:05:58 <t7> IO a = someBigCalculation;   a >> print "hi"    will a get evald?
16:06:07 <parcs`> > let c = 5; d = c; b = case () of _ -> c where c = 3 where c = 100 in d
16:06:07 <lambdabot>   5
16:06:09 <Twey> t7: Evaluation ≠ execution
16:06:24 <t7> someBigCalculation that doesnt involve any IO actions other than return
16:06:27 <elliott> t7: return someBigCalculation >> m will not force someBigCalculation, no. You're confused about what's evaluation and what's execution.
16:06:33 <Twey> t7: Then no
16:07:01 <t7> what are my options for forcing it
16:07:07 <parcs`> > let c = 5; d = c; b = (case () of _ -> c where c = 3) where c = 100 in d
16:07:08 <lambdabot>   5
16:07:22 <t7> like i wanna force my key generation while im waiting for a message from peer
16:07:22 <Twey> t7: The (pure) IO value is evaluated or not according to the usual lazy Haskell rules.  The constructed IO program is then executed in order.
16:07:45 <elliott> evaluate :: a -> IO a.
16:07:47 <elliott> It evaluates to WHNF.
16:07:56 <Twey> You probably don't want that, though… consider par instead
16:07:57 <elliott> If you want RNF, evaluate . rnf (from Control.DeepSeq).
16:08:02 <elliott> evaluate is in Control.Exception.
16:08:03 <monochrom> mueval calls hint's eval. hint's eval builds "let answer = your string here in answer" and passes to GHC API. same difference
16:08:07 <elliott> Yes, par + strategies is a good solution.
16:08:10 <elliott> monochrom: I tested it in GHCi.
16:08:26 <monochrom> what did you test?
16:08:37 <Twey> Prelude> case () of _ -> a where a = 4
16:08:37 <Twey> 4
16:08:45 <Twey> Though GHCi has ‘it’
16:09:03 <elliott> yeah, that
16:09:06 <Twey> But I don't *think* it does a string substitution, and also consider the nested form as parcs` said
16:09:20 <elliott> yeah, GHC is not based on string substitution :P
16:09:28 <Twey> I hoped :þ
16:09:28 <elliott> otherwise "x `seq` (); x = blah" would work
16:09:34 <Twey> Yeah
16:09:38 <monochrom> case allows where. this is not a ghci artefact. this is haskell 98
16:09:47 <Twey> monochrom: Right
16:10:02 <elliott> monochrom: that's what the question was
16:10:04 <Twey> 235534 < monochrom> lambdabot turns your "> x" into "answer = x", so you can add where
16:10:19 <Twey> So that's not why ‘where’ works
16:10:26 <elliott> > () where x = x
16:10:27 <lambdabot>   <no location info>: parse error on input `where'
16:10:28 <monochrom> <monochrom> mueval calls hint's eval. hint's eval builds "let answer = your string here in answer" and passes to GHC API. same difference
16:10:41 <elliott> except that you can't actually add where like that
16:10:55 <elliott> > x; x = 42
16:10:55 <lambdabot>   <no location info>: parse error on input `;'
16:10:57 <monochrom> God, do you selectively read?
16:11:18 <elliott> no, admittedly I don't know what you're actually trying to demonstrate :P
16:11:22 <monochrom> I have an updated answer and all of you choose to be blind to it
16:11:24 * Twey didn't realize he'd been promoted to godhood already.
16:11:28 <parcs`> elliott: you can add a where to any binding
16:11:30 <parcs`> i think
16:11:44 <elliott> monochrom: yes, i just read your mueval line
16:11:44 <parcs`> you can add a let to any expression
16:11:49 <monochrom> I'm explaining why lambdabot supports "where"
16:11:50 <Twey> monochrom: You didn't explicitly update it so we were considering it an addition to your previous answer rather than a replacement
16:11:53 <elliott> it doesn't!
16:11:57 <elliott> > x where x = x
16:11:58 <lambdabot>   <no location info>: parse error on input `where'
16:12:42 <DanBurton> > let x = foo where foo = 3
16:12:43 <lambdabot>   not an expression: `let x = foo where foo = 3'
16:12:46 <DanBurton> > let x = foo where foo = 3 in x
16:12:47 <lambdabot>   3
16:13:03 <DanBurton> > x = foo where foo = 3
16:13:04 <lambdabot>   <no location info>: parse error on input `='
16:13:16 <DanBurton> > foo where foo = 3
16:13:16 <lambdabot>   <no location info>: parse error on input `where'
16:13:46 <monochrom> frankly I don't consider "answer = your string here" and "let answer = your string here in answer" to be all that different for the purpose of "where"
16:14:39 <elliott> monochrom: ... but we have no evidence it does either, and it clearly does *not* support where in the way that it would if it did either of those
16:14:39 <monochrom> the point is building or not building a declaration. exactly which style of declaration is pretty minor
16:14:50 <elliott> > let answer = x where x = () in answer
16:14:51 <lambdabot>   ()
16:14:53 <elliott> > x where x = ()
16:14:54 <lambdabot>   <no location info>: parse error on input `where'
16:15:04 <elliott> so i really don't know what you're trying to say...
16:15:50 <monochrom> ok but mueval does its own parsing too before handing to hint. then hint does its own parsing too before passing to GHC API. any one of them could ban things arbitrarily
16:16:31 <parcs`> > let c = 1; _ = case () of _ -> () where _ = () where c = 2 in c
16:16:32 <lambdabot>   1
16:16:36 <elliott> ...ok, so what's your point? :P
16:16:41 <parcs`> > let c = 1; _ = (case () of _ -> () where _ = () where c = 2) in c
16:16:42 <lambdabot>   1
16:16:46 <elliott> i thought it was about explaining why lambdabot supports where, which it doesn't
16:16:46 <parcs`> oops
16:16:48 <elliott> so i'm just confused
16:17:39 <monochrom> oh, it doesn't take "where" anymore? that's strange. it did very recently
16:30:53 <parcs`> can you think of a case where 'let _ = (case () of _ -> a where b = c where d = e)' is different from 'let _ = (case () of _ -> a where b = c) where d = e'
16:35:21 <edwardk> elliott: uploaded
16:37:17 <elliott> edwardk: cool
16:37:59 <elliott>  reflectT :: Reified s => p s a -> a
16:38:02 <edwardk> bulked up the documentation, added a changelog and an actual example
16:38:03 <elliott> edwardk: surely you're missing a constraint there
16:38:10 <edwardk> what constraint?
16:38:14 <elliott> well, dunno
16:38:18 <elliott> i don't see how that can work for arbitrary p
16:38:23 <edwardk> it doesn't use the p
16:38:25 <edwardk> just the type s
16:38:27 <elliott> oh, right
16:38:30 <edwardk> and the type a
16:38:30 <elliott> that's the get-the-value function
16:38:31 <edwardk> =)
16:38:34 <edwardk> yep
16:38:39 <edwardk> its magic ;)
16:38:43 <elliott> thought it was like reifyT
16:38:47 <elliott> reify, reflect, same thing
16:38:49 <edwardk> that way if you have your own. data M s a = M a
16:38:55 <edwardk> you can pass it to reflectT directly
16:39:11 <edwardk> reify and reflect are the opposite side of the transformation
16:39:22 * elliott wonders if the rank-2 type could be eliminated somehow...
16:39:40 <edwardk> http://stackoverflow.com/questions/5314884/what-reify-and-reification-means-in-the-context-of-functional-programming/5316014#5316014
16:39:42 <edwardk> it can't
16:39:45 <edwardk> that one is intrinsic
16:39:56 <edwardk> its like trying to run runST without rank 2 types
16:40:10 <elliott> yeah
16:40:21 <edwardk> you can make particular values of 's' that reflect concrete values
16:40:27 <elliott> (i do know how it works btw, i reimplemented reflection once :p)
16:40:31 <edwardk> but the dynamic construction of them needs it
16:40:43 * hackagebot reflection 0.6 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.6 (EdwardKmett)
16:41:47 <elliott> it's a lot simpler to implement when you only support one pointer size :p
16:42:20 <edwardk> ah, serializing ints rather than a list of ints?
16:42:42 <elliott> yeah, I just did "data Address a0 a1 ... a8"
16:42:43 <edwardk> i could in theory serialize the stableptr as an intptr directly
16:42:47 <elliott> and had T0, T1, T2 ... T255
16:42:53 <elliott> the idea was MOAR SPEED
16:42:58 <edwardk> did it matter?
16:43:07 <elliott> i never actually measured it :P
16:43:10 <edwardk> hahaha
16:43:21 <elliott> i was trying to get it to work by coercing directly to Addr#s and skipping the StablePtr stuff and just hoping the GC didn't run
16:43:24 <elliott> but it kept segfaulting on me
16:43:47 <elliott> newtype M (s :: * -> *) a = M { runM :: a }  -- who needs kind signatures when you have `type K a b = a`?!
16:43:52 <edwardk> hrmm
16:43:53 <edwardk> actually
16:43:58 <edwardk> that would work really well
16:44:06 <edwardk> castPtrToIntPtr . castStablePtrToPtr
16:44:09 <edwardk> done
16:44:15 <edwardk> then i can strip two levels out of the API
16:44:26 <elliott> oh, i assumed that's what you did
16:44:36 <edwardk> nah i implemented it oleg's way
16:44:45 <elliott> that's what mine did, StablePtr -> bytes
16:44:46 <edwardk> it serializes the stable ptr as a list of ints
16:44:52 <elliott> ah
16:44:53 <edwardk> i just want one int though
16:44:59 <edwardk> and IntPtr is integral
16:45:22 <elliott> i think coercing to Addr#s could avoid the GC issue actually
16:45:41 <elliott> if you just kept a reference around in reify
16:45:50 <elliott> but I couldn't even get it to run without segfaulting, so...
16:46:12 <edwardk> the stableptr alloc/dealloc isn't bad
16:47:23 <elliott> couldn't you also build the type level naturals out of Z, O n, I n?
16:47:38 <elliott> (or I guess 0, 1 + 2n, 2 + 2n if you want to avoid trailing 0s)
16:47:52 <elliott> i don't quite understand why Succ/Pred are necessary
16:48:19 <edwardk> i could
16:48:25 <edwardk> i went with the same construction oleg used
16:48:34 <elliott> right
16:48:47 <edwardk> i usually would use the infinite zero and infinite one tail and O and I prefixes
16:48:54 <edwardk> like i did i type-int
16:48:57 <edwardk> er in
16:49:31 <elliott> oh you need negatives? ok
16:50:27 <edwardk> nothing tells me intptr isn't negative
16:50:30 <edwardk> ;)
16:51:02 <elliott> > minBound :: IntPtr
16:51:03 <lambdabot>   Not in scope: type constructor or class `IntPtr'
16:51:07 <elliott> > minBound :: CIntPtr
16:51:07 <lambdabot>   Not in scope: type constructor or class `CIntPtr'
16:51:10 <elliott> uhh wait
16:51:12 <elliott> @hoogle IntPtr
16:51:13 <lambdabot> Foreign.Ptr data IntPtr
16:51:13 <lambdabot> Foreign.Ptr intPtrToPtr :: IntPtr -> Ptr a
16:51:13 <lambdabot> Foreign.C.Types data CIntPtr
16:51:16 <elliott> > minBound :: Foreign.Ptr.IntPtr
16:51:17 <lambdabot>   Not in scope: type constructor or class `Foreign.Ptr.IntPtr'
16:51:19 <elliott> ugh!
16:51:28 <elliott> yeah it's signed
16:51:43 <edwardk> hehghci> minBound :: IntPtr
16:51:43 <edwardk> -9223372036854775808
16:51:45 <edwardk> yeah
16:52:00 <edwardk> it'd better be, otherwise it should be WordPtr ;)
16:53:18 <ion> :-D
16:53:39 <elliott> i want to use reflection for something now. if only i had something to use it for
16:54:21 <elliott> edwardk: your Monoid example doesn't need reflectM does it?
16:54:23 <edwardk> trying to streamline the internals to just use an IntPtr now
16:54:23 <elliott> it's just reflectT
16:54:27 <monochrom> use reflection to do type case or compare functions
16:54:28 <edwardk> its not quite so simple
16:54:44 <edwardk> reflectT would work if the Monoid_ a was a
16:54:50 <edwardk> but i'm reflecting something else
16:54:52 <elliott> ah
16:54:54 <elliott> yes, right
16:55:02 <elliott> it has a stray where, at least :p
16:55:08 <edwardk> that it probably does =)
16:56:00 <elliott> you have a package that uses reflection to do modular arithmetic, right?
16:56:14 <ion> @hoogle reflectT
16:56:14 <lambdabot> No results found
16:56:21 <ion> @hackage reflection
16:56:21 <lambdabot> http://hackage.haskell.org/package/reflection
16:57:07 <edwardk> elliott: not any more
16:57:13 <edwardk> it was in monoids back around 0.1.36
16:57:21 <edwardk> but i dropped it when refactoring
16:57:36 <elliott> ah
16:58:25 <elliott> btw... it'd be convenient to have `(a -> b) -> Tagged a b` and `(a -> b) -> Proxy a -> b` in tagged, for using broken things that should use Proxy/Tagged but don't
16:58:31 <elliott> might be too ugly to include though :p
16:59:20 <mekeor`> sometimes, "∷" is really much nicer than "::" in source codes…
16:59:34 <edwardk> i don't really want to include those because they are unsafe
17:00:05 <elliott> yeah
17:00:20 <edwardk> i try to minimize the amount of lying i do in my types ;)
17:00:28 <elliott> btw, interestingly, in my implementation of reflection I actually had to use Proxy, the types didn't work out with Tagged
17:00:32 <mekeor`> edwardk: how do you mean? yes, of course, it's a language-extension, and furthermore, unicode-chars not always have the same width… but in that case it's fine, IMO.
17:00:37 <elliott> I had to convert from Tagged to Proxy in one place to get it working
17:00:50 <edwardk> mekeor`: i was talking about reflection
17:00:56 <mekeor`> oh, okay…
17:00:58 <elliott> tagged, no? :p
17:01:17 <edwardk> mekeor`: the :: vs ∷ thing i don't care too much about ;)
17:01:48 <edwardk> the 0.3 version was built entirely on Tagged
17:01:55 <elliott> I meant, "i was talking about reflection"
17:01:56 <edwardk> but it was harder to use
17:01:58 <crdueck> hello, i have a a pretty solid understanding of scheme (=> functional programming) and I'd like to learn Haskell. Can i get some reccomendations of resources to start learning that wont drag out the initial differences between imperative and functional programming?
17:02:02 <elliott> but my request was about tagged :P
17:02:07 <edwardk> elliott: oh
17:02:16 <elliott> crdueck: well, the best book to learn haskell is lyah
17:02:18 <elliott> @where lyah
17:02:18 <lambdabot> http://www.learnyouahaskell.com/
17:02:26 <elliott> crdueck: the thing is that haskell is still _very_ different from scheme
17:02:37 <elliott> and things that you think might be skippable are likely to turn out to not be so
17:02:39 <edwardk> crdueck: grab learn you a haskell and just read it really fast ;)
17:02:55 <iFire> edwardk: that doesn't work
17:03:01 * iFire is telling from experience
17:03:06 <edwardk> iFire: reading it fast?
17:03:08 <iFire> yeah
17:03:15 <edwardk> fair nuff
17:03:31 <Senmorta>  i like Real World Haskell
17:03:33 <crdueck> i know there are differences, i just dont want to have to skip past large intros of "variables cant be mutated, recursion etc"
17:03:39 <edwardk> my approach was just 'read enough academic papers all at once that it starts to make sense by osmosis'
17:03:45 <ikeg> I have a similar question lyah, but, I'm afraid to break into talks
17:03:58 <edwardk> RWH definitely spends time trying to break down the imperative mindset
17:04:09 <elliott> crdueck: well, the lack of mutation _does_ make haskell v. different, even if it's not common in scheme it's still there
17:04:15 <elliott> crdueck: and non-strictness is another huge difference
17:04:18 <edwardk> ikeg: just talk. the nice thing about irc is multiple conversations can happen =)
17:04:27 <ikeg> OK, thanks
17:04:31 <elliott> I don't like RWH as an introduction because of how out of date it is in places
17:04:37 <ikeg> A good news from Japan: "Learn You a Haskell for Great Good" will be translated and published in May.
17:04:43 <elliott> and I think it goes from "here's the basics" to "let's start writing big IO programs" too quickly
17:04:58 <edwardk> crdueck: for instance, one issue is that coming from scheme you've been conditioned to do things in tail recursive form. thats usually a bad idea in haskell
17:05:05 <ikeg> I have a naive question about how to learn Haskell by some books.
17:05:09 <edwardk> crdueck: so many of your intuitions don't transfer
17:05:15 <elliott> crdueck: it'll take patience to learn haskell, so you could see reading through the bits you already know as the first test :P
17:05:22 <ikeg> You know we have good books to learn Haskell.
17:05:32 <ikeg> http://www.haskell.org/haskellwiki/Books
17:05:32 <iFire> edwardk: that's called the read enough papers until you can recite the theory method
17:05:33 <edwardk> ikeg: Learn You a Haskell is a good resource.
17:05:34 <iFire> :)
17:05:37 <nart> ciao :)
17:05:48 <JoeyA> Is there a nice library for JavaScript code generation?
17:05:49 <edwardk> ikeg: Real World Haskell is another good resource
17:05:55 <monochrom> "the gentle introduction to haskell" is a fine tutorial for those who already know some functional programming: http://www.haskell.org/tutorial/
17:05:56 <nart> what are your thoughts about Qi/Shen ?
17:06:11 <elliott> more like "for those who already know ML"
17:06:15 <ikeg> Question: the LYAH book is self-contained or not?
17:06:24 <elliott> ikeg: it has no dependencies
17:06:30 <elliott> you will probably want to read more afterwards
17:06:36 <elliott> but it'll get you a long way
17:06:47 <monochrom> it doesn't explain the english language which it's written in
17:06:58 <elliott> monochrom: that's ok: <ikeg> A good news from Japan: "Learn You a Haskell for Great Good" will be translated and published in May.
17:07:03 <elliott> it only has to explain japanese ;)
17:08:28 <monochrom> there are several nice libraries for javascript output. but I've forgotten all their names
17:08:48 <elliott> wut
17:09:06 <sizz_> anyone know if there's another edition of RWH on the horizon?
17:09:08 <elliott> ikeg: LYAH doesn't really have all that much intro anyway, it intersperses the differences with actual code
17:09:16 <elliott> sizz_: i heard yes but have no source
17:09:19 <stephenjudkins> JoeyA: not immediately helpful, but if you're interested in that domain I would recommend reading https://dl.dropbox.com/u/12870350/article.pdf
17:09:25 * ksf shrieks in horror and hides under the desk
17:09:38 <ksf> *the code works and I can't explain why*
17:10:07 <JoeyA> ksf: That's happened to me before.
17:10:27 <JoeyA> stephenjudkins: Thanks.
17:10:50 <JoeyA> I think I'll just hand-roll my own generator.  My needs aren't that great.
17:11:02 <elliott> ksf: it's outsmarted you
17:11:04 <dmwit> crdueck: Read the Gentle Introduction.
17:11:10 <dmwit> crdueck: Absolutely no fluff, all content.
17:11:12 <dmwit> ?where gentle
17:11:12 <lambdabot> http://www.haskell.org/tutorial/
17:11:20 <JoeyA> (I'm generating code for my own EDSL)
17:11:26 <dmwit> It's not so much a fad as LYAH or RWH these days, but I still think it's quite good.
17:12:30 <elliott> Come on, doesn't the Gentle Introduction still teach non-hierarchical module names?
17:13:16 <dmwit> I don't think the module system is either complicated nor a core concept to writing good Haskell.
17:13:35 <dmwit> I don't really know exactly which of the words in that sentence to make negative. Maybe you understood my meaning anyway.
17:13:37 <stephenjudkins> JoeyA: i wrote a 10%-finished javascript interpreter in Scala.. parsing Javascript syntax was time-consuming but very simple. the AST is relatively simple to model.
17:13:44 <monochrom> it teaches a special case of hierarchical module names :)
17:13:58 <JoeyA> stephenjudkins: Cool
17:13:59 <stephenjudkins> if you do end up rolling your own, and open-source it, please post to hacker news or something so I can see it :)
17:14:00 <ksf_> hmm. I think elerea could be sped up significantly in practice by scattering stableptr comparisons all over the place.
17:14:18 <dmwit> Anyway, yes, the Gentle Intro does teach strict H98. There have been a few innovations since then, but it's a damn good introduction.
17:14:32 <dmwit> crdueck: So keep that in mind if you choose the Gentle Intro.
17:14:39 <elliott> dmwit: I did. But still...
17:14:43 <JoeyA> I'd love to open-source my dynamic HTML form generator EDSL, but it's probably too proprietary.
17:14:56 <JoeyA> (and probably not that great, anyway)
17:15:01 <ksf_> ...while comparing the pointers would still be pull, in practice that's implementing push semantics.
17:16:36 <elliott> ksf_: StablePtrs?
17:16:41 <elliott> why not just use reallyUnsafePtrEquality#?
17:16:48 <dmwit> "I think even the full module system is pretty simple, and you can write Haskell well even without an explicit introduction to it." <- positive is better than negative
17:17:14 <ksf_> I don't care, but pointer comparisons would be a good idea, through the whole net.
17:17:19 <elliott> oh, the Gentle Introduction also skips over Applicative entirely of course
17:17:21 <elliott> which is sin ;)
17:17:29 <dmwit> hah
17:17:36 <monochrom> in all fairness, elliott probably means "import List" vs "import Data.List"
17:17:39 <elliott> ksf_: are you the author of elerea?
17:17:41 <elliott> monochrom: i did, yse
17:17:42 <elliott> *yes
17:17:43 <ksf_> I find myself writing transfers that do nothing but cache based on Eq instances
17:17:44 <ksf_> nope.
17:17:52 <elliott> ksf_: ah, ok
17:17:56 <elliott> if you were, I'd apologise for ignoring it :)
17:18:21 <dmwit> I see.
17:18:37 <elliott> monochrom: which will also mean you pull in the haskell98 package
17:18:44 <elliott> which is just eurgh
17:19:00 <ksf_> well, in general it has the purity of interface as reactive does, and the real-world usability of yampa.
17:19:23 <elliott> ksf_: I use reactive-banana personally
17:19:29 <monochrom> there is not enough incentive to update the gentle introduction, since people so irrationally angrily shoot it down
17:19:39 <elliott> elera feels too... clocked for me
17:19:39 <ksf_> and it has *damn* good reasons to use IORefs under the hood.
17:19:46 <ksf_> semantic reasons, that is.
17:20:09 <ksf_> ...as a pure implementation of the semantics would emulate references
17:20:35 <elliott> that just means the semantics contain references, gross :P
17:20:35 <BrianHV> looking for some help understanding what's possible with existentially quantified types: https://gist.github.com/2324200
17:20:36 <monochrom> fortunately, other tutorials receive no update either
17:21:04 <monochrom> you can use an existential type like an OOP type
17:21:29 <elliott> BrianHV: #1 is impossible without additional Typeable constraint or such.
17:21:30 <monochrom> you get all the same abstract nonsense. you'll be just missing inheritance
17:21:45 <elliott> #3 is just plain impossible, breaks open world assumption
17:22:05 <elliott> but in general existentials are usually the wrong approach anyway.
17:22:33 <ksf_> elliott, nah, it arrives there by skewing the semantics to be restricted to the present.
17:22:35 <BrianHV> is there an alternative to existentials that meet my stated design goals?
17:23:13 <BrianHV> s/meet/meets/ ...
17:23:24 <elliott> yes
17:23:33 <ksf_> is there a technical description of reactive-banana, somewhere?
17:23:37 <elliott> BrianHV: write a record that describes your interface (likely with functions) instead, pass those records in
17:23:49 <elliott> BrianHV: see http://www.haskell.org/haskellwiki/FAQ#I.27m_making_an_RPG._Should_I_define_a_type_for_each_kind_of_monster.2C_and_a_type_class_for_them.3F
17:23:59 <mekeor`> reactive-banana is by apfeλmus, right?
17:24:02 <elliott> ksf_: yes, http://apfelmus.nfshost.com/blog.html (first post last)
17:24:04 <ksf_> yep.
17:24:05 <elliott> mekeor`: yes
17:24:22 <elliott> ksf_: other than that, the best resource is to read the code
17:24:27 <BrianHV> meh. now that you've said that, I'm pretty sure someone gave me that same answer a year ago when I last explored existentially quantified types. and of course I forgot it.
17:24:51 <dmwit> This FAQ page is amazing.
17:24:52 <monochrom> a record of functions will have problems with 1 and 3
17:24:56 <elliott> BrianHV: hehe
17:25:05 <elliott> dmwit: kmc's work
17:26:08 <elliott> monochrom: those were problems with details of the existing implementation, not design goals
17:26:11 <elliott> at least that was my interpretation
17:26:33 <ivanm> @pl \ (e,m) -> (inverseEdge m e, (o,m))
17:26:33 <lambdabot> uncurry ((`ap` (,) o) . ((,) .) . flip inverseEdge)
17:26:42 <BrianHV> monochrom: I think you're right. 3 is negotiable, but I really do need to be able to compare modules for equality...
17:26:43 <elliott> but yes, BrianHV will probably want to carry some kind of arbitrary identifier along with the records
17:26:47 <monochrom> "have to do Eq" sounds like a spec not an imp to me
17:26:54 <elliott> and have a registry of some kind for #3
17:27:03 <elliott> which would work for the existentially-quantified solution too, sure
17:27:09 <elliott> but that's irrelevant :)
17:27:19 <dmwit> kmc++
17:27:36 <dmwit> The answer to "How can I do X without resorting to threads?" is damn near perfect.
17:27:40 * BrianHV recodes as records. will probably be back here in an hour. ;)
17:27:46 <elliott> BrianHV: oh, wait...
17:27:48 <dmwit> Just... the whole thing is great.
17:27:55 <elliott> BrianHV: you're actually carrying around a lot of superclass constraints in that existential
17:27:58 <elliott> so it might be cleanest like that
17:28:04 <elliott> to not have to rewrite everyone else's code in record form too
17:28:11 <monochrom> in any case, this FAQ should be cited more often
17:28:17 <monochrom> @where faq
17:28:17 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
17:28:20 <monochrom> nice
17:28:36 <BrianHV> elliott: well, no one else's code exists yet, so that's not a problem.
17:28:45 <elliott> BrianHV: no, as in, the libraries you use
17:28:47 <elliott> aeson, quickcheck, etc.
17:28:52 <BrianHV> oh. yeah.
17:29:07 <elliott> so... this looks like one of the few cases you might actually want existentials
17:29:07 <ksf_> elliott, well, elerea supports dynamic event switching *now*
17:29:13 <elliott> esp. since your values actually contain relevant things
17:29:20 <elliott> ksf_: yeah, reactive-banana is getting it RSN though ;)
17:29:29 <BrianHV> and I do like the compiler errors I get when I fail to implement part of the module
17:30:11 <monochrom> I don't like "there is no reason to consider imperative language and functional language as opposites"
17:30:29 <BrianHV> I haven't really looked at Typeable yet. if I make my ModuleData typeable as well, should I be able to write an Eq instance?
17:30:33 <monochrom> they are opposites. they are not mutually exclusive. the latter is what you mean
17:30:42 <elliott> monochrom: it's a wiki ;)
17:31:16 <elliott> fixed it :P
17:31:42 <monochrom> haha thanks
17:31:45 <dmwit> monochrom: Nonsense! It's us vs. them! DO YOU WANT THE IMPERATORS TO WIN??
17:31:50 <ksf_> here's a good point http://just-bottom.blogspot.de/2010/04/programming-with-effects-story-so-far.html about functional vs. imperative.
17:31:59 <gnoi> Is there some arrow x -> (f x, g x)? Like `second (+5) . first (+8) . join (&&&) id $ 1'
17:32:07 <dmwit> :t (&&&)
17:32:08 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:32:10 <monochrom> I just want to be the imperator! (old way to say emperor)
17:32:18 <ksf_> in a nutshell, haskell is the better imperative language because it can not only do arrowchoice, but monad
17:32:31 <dmwit> gnoi: uh, (&&&) is already that.
17:32:42 <dmwit> > (f &&& g) x
17:32:43 <lambdabot>   Ambiguous type variable `c' in the constraints:
17:32:43 <lambdabot>    `GHC.Show.Show c'
17:32:43 <lambdabot>      a...
17:32:51 <BrianHV> and... I can't see how I would write an instance of Arbitrary even with a registry, since I don't know how to get the registry into the arbitrary function
17:32:52 <dmwit> > (f &&& g) x :: (Expr, Expr)
17:32:53 <lambdabot>   (f x,g x)
17:33:14 <gnoi> Lol ok
17:33:20 <elliott> oh!
17:33:24 <elliott> i read gnoi's request as a type.
17:33:27 <elliott> i was thoroughly confused
17:33:44 <elliott> i thought gnoi wanted an Arrow instance for type Foo f g x = x -> (f x, g x) or something
17:34:12 <elliott> BrianHV: oh, you'd need an unsafePerformIO'd global >_> ... or you could use edwardk's reflection package ;)
17:34:23 <edwardk> elliott: =P
17:34:36 <t7> god i hate conduit
17:34:42 * elliott edwardk promotional division
17:34:47 <t7> well... it just doesnt fit my domain
17:35:16 <BrianHV> elliott: both of those sound potentially frightening. :)  reflection sounds like it could at least be referentially transparent though
17:35:24 <elliott> well a global is referentially transparent
17:35:29 <elliott> the registry action would just be in IO
17:35:40 <elliott> reflection lets you have multiple registries though... if you want that for some reason
17:36:13 <elliott> BrianHV: one thing you should be thinking about is how you intend to actually collect all these things together to run your program with
17:36:24 <elliott> you'll probably end up needing a list with all the possible modules at some point.
17:36:39 <BrianHV> indeed.
17:37:22 <elliott> in which case, you already _have_ a registry.
17:39:16 <BrianHV> right... but I'd need unsafePerformIO to get it into arbitrary. and I'm new enough to still have an irrational fear of unsafePerformIO. ;)
17:40:52 <elliott> no
17:40:59 <elliott> if you just have a list with all the possible modules
17:41:01 <elliott> then you can just use it in arbitrary
17:41:14 <elliott> it does not require unsafePerformIO to reference a constant ;)
17:41:24 <BrianHV> oh, right.
17:42:08 <BrianHV> I'm overthinking this, obviously. I'd like this to reach a point where I can have plugins.
17:42:32 <elliott> yeah, in which case you'll be doing dynamic loading of code in IO
17:42:39 <elliott> so you can again just carry around a registry and add to it
17:42:57 <elliott> leading you back to either an unsafePerformIO'd global or reflection
17:43:05 <BrianHV> but in that case, it's no longer a reference to a constant
17:43:09 <BrianHV> ok, right
17:45:27 <BrianHV> so, how would I represent this list of modules? ideally I'd want something like   moduleTypes = [PostModule, MessageModule]    and    arbitrary = arbitrary :: oneof moduleTypes
17:45:30 <BrianHV> but that's absurd.
17:46:19 <ivanm> @pl mkDual (mrkd,m) = first ($mrkd) $ mobileDual m
17:46:20 <lambdabot> mkDual = uncurry ((. mobileDual) . first . flip id)
17:46:24 <ivanm> bah
17:46:40 <monochrom> you can use TH to generate a static registry. TH can do IO. in IO, you can scan the directory for files...
17:46:54 <BrianHV> oooh, neat idea.
17:47:42 <monochrom> TH takes the "functional" away from "functional compiler" :)
17:47:50 <BrianHV> :)
17:48:26 <BrianHV> but regardless of the mechanism, I still need a list of something to represent the modules...
17:49:07 <BrianHV> using the data constructors doesn't seem useful. perhaps I need a record that the modules need to register...
17:49:42 <monochrom> oh, there is a problem. GHC can decide that your module (it contains the list) needs no recompilation, therefore not even calling TH, but your list needs to be updated
17:50:44 <elliott> BrianHV: you might want the TypeRep perhaps
17:50:51 <elliott> except, you need a way to create these modules from your UI
17:50:58 <elliott> so it'll have to be a real interface of some kind
17:51:28 <BrianHV> clearly I'm going to have to figure out Typeable.
17:51:31 <elliott> edwardk: out of curiosity, how did your modular arithmetic stuff do Enum?
17:51:43 <edwardk> i don't recall if it did
17:51:50 <edwardk> succ probably wrapped though
17:52:29 <elliott> well it had to, if it had an Integral instance
17:52:34 <elliott> though I suppose you could undefined-stub it all out :p
17:52:50 <monochrom> OK, you're saying, you have 3 types T0, T1, T2. each is an Arbitrary. you now want an overarching Arbitrary, it first chooses a number n in 0,12, then go for the Arbitrary methods of Tn
17:52:55 <edwardk> well, you can redefine all the members of Enum by hand to get the desired behavior
17:53:09 * elliott isn't sure what the desired behaviour even is
17:53:20 <elliott> what's [0..20] mod 6?
17:53:25 <monochrom> I would say, don't store the "types" T0, T1, T2. store their methods in a record. (or an existential type)
17:53:36 <elliott> I would expect [0,1,2,3,4,5,0,1,2,...] etc. but succ isn't meant to be cyclic
17:53:44 <edwardk> elliott: i would argue thats [0,1,2,3,4,5,0,1,2,3,4..]
17:53:58 <elliott> edwardk: yep -- but that directly contradicts the rest of the instance
17:54:02 <elliott> because succ 5 = error
17:54:04 <edwardk> *shrug*
17:54:07 <elliott> (if you give a Bounded instance)
17:54:09 <edwardk> remove succ 5 = error
17:54:13 <elliott> that's not allowed
17:54:17 <elliott> succ maxBound = error is a law
17:54:17 <edwardk> or remove the Bounded because Bounded without Ord is silly
17:54:20 <edwardk> =P
17:54:27 <elliott> hmm, why wouldn't you have Ord?
17:54:29 <monochrom> oh bother, there are many details to be filled. nevermind
17:54:45 <edwardk> you have an Ordering, but the ordering isn't respected by the operations
17:54:58 <elliott> you could say the same of Int :p
17:54:59 <edwardk> its not an Ordered Field, its a field, and its ordered
17:55:11 <elliott> admittedly minBound is a bit... weird
17:55:38 <edwardk> anyways, in this case i'd basically say screw that law ;)
17:56:00 <magicman> Rebel.
17:56:05 <edwardk> yep
17:56:23 <elliott> not like Enum makes any sense anyway
17:56:38 <monochrom> > succ maxBound :: Int
17:56:38 <lambdabot>   *Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
17:56:57 <monochrom> that is actually required by the haskell report
17:57:19 <edwardk> In general you can take the stance that overflowing Int is an error. Overflowing a modular arithmetic type is a common and desired behavior
17:57:25 <edwardk> sure
17:57:47 <monochrom> of course, there is also:
17:58:05 <monochrom> > maxBound + 1 > (maxBound :: Int)
17:58:05 <lambdabot>   False
17:58:24 <edwardk> elliott: i uploaded 0.7 which drops ReifiedNums and ReifiedStorable
17:58:34 <edwardk> elliott: and which uses a faster way to count
17:58:36 <monochrom> so you could say that something is morally corrupt
17:58:54 <edwardk> sure, Int also fails to be an ordered ring ;)
17:58:59 <monochrom> I am equally morally corrupt, so don't mind me
18:00:11 <edwardk> but its mostly intended in many languages that one works with Int 'up to overflow' since minBound and maxBound vary by platform, and C semantics for overflow are very loosely defined
18:00:46 * hackagebot reflection 0.7 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.7 (EdwardKmett)
18:01:40 <danharaj> I wish saturated arithmetic were more common.
18:02:04 <edwardk> meh, just defers the problem
18:02:08 <elliott> edwardk: i knew it was only a matter of time before you tried to microoptimise counting itself
18:02:10 <edwardk> maxBound + 1 - maxBound = 0?
18:02:10 <edwardk>  =)
18:02:16 <edwardk> elliott: =P
18:02:24 <ksf_> reallyUnsafePointerEqualityThatShouldActuallyBeCalledSafePointerEqualityButWeWantToMakePeopleReadHaskellCafeDiscussions#
18:02:24 <elliott> arithmetic 2.0
18:02:27 <edwardk> elliott: also removed the Unused class, so its a lot less code
18:02:35 <danharaj> hey ain't nothing wrong with tropical arithmetic
18:02:36 <elliott> ksf_: edwardk says it can give you false positives, I think
18:02:39 <monochrom> the real problem is that different people want arithmetic to behave differently
18:02:44 <elliott> (but I don't understand his argument)
18:02:55 <djahandarie> Hmm, where has ddarius been lately?
18:02:55 <ksf_> the discussion says it's atomic wrt. the gc so that can't happen.
18:03:08 <edwardk> elliott: not on ghc at this time
18:03:27 <elliott> preflex: xseen ddarius
18:03:27 <preflex>  ddarius was last seen on freenode/#haskell 28 days, 22 hours, 55 minutes and 53 seconds ago, saying: BMeph: No.
18:03:31 <ksf_> anyway, there are stablenames.
18:03:35 <elliott> edwardk: hmm, how do you handle negatives?
18:03:35 <DijkstraGroupie> What garbage collection technique do Haskell implementations usually use?
18:03:37 <elliott> ksf_: sloooow! :D
18:03:46 <edwardk> djahandarie: he's been ridiculously busy at work and may have quit irc for a while
18:03:53 <elliott> DijkstraGroupie: nothing so general as "usually", but GHC has a fancy concurrent copying collector thing
18:03:57 <elliott> or was it parallel, I mix the two up
18:03:59 <elliott> generational and all that
18:04:01 <edwardk> elliott: same trick as before, i just replaced succ and pred  with succtwice and predtwice
18:04:09 <edwardk> since they were never used in isolation
18:04:11 <elliott> edwardk: oh, ah
18:04:14 <elliott> didn't notice the pred
18:04:21 <ksf_> yeah, for comparison they're overkill.
18:04:35 <edwardk> ksf_: depends, i wind up needing them a lot
18:04:42 <elliott> newtype Stable s a = Stable (Stable s a)
18:04:46 <elliott> A New Kind of Void
18:04:49 <edwardk> elliott: yeah
18:04:54 <edwardk> elliott: thats what Void uses
18:04:56 <elliott> @quote science of kind
18:04:56 <lambdabot> No quotes for this person. Sorry about this, I know it's a bit silly.
18:05:00 <elliott> argh
18:05:04 <elliott> i was referencing that monochrom quote :p
18:05:07 <elliott> (and thus indirectly wolfram)
18:05:13 <elliott> @quote monochrom science of kind
18:05:13 <lambdabot> monochrom says: rumour: SPJ will write a thick book "A New Science of Kind"
18:05:25 <edwardk> hah
18:05:29 <DijkstraGroupie> SPJ?
18:05:35 <elliott> since, you know... it has kind * -> * -> *... oh, I'll show myself out
18:05:38 <edwardk> simon peyton jones
18:05:40 <elliott> DijkstraGroupie: simon peyton jones
18:05:57 <gnoi> How can I simplify that? (listToMaybe . mapMaybe getPhone) &&& (listToMaybe . mapMaybe getBirthday)
18:06:00 <edwardk> elliott: anyways wrote it that way because it keeps it haskell 98
18:06:02 <elliott> DijkstraGroupie: major haskell + ghc contributor
18:06:11 <elliott> edwardk: yeah, i know the newtype formulation
18:06:18 <elliott> i was referring to the other kind of kind
18:06:33 * elliott installs the second version of reflection today
18:06:50 <t7> whats the best way to serialize data for sending over network
18:06:56 <edwardk> i do like the fact that that module keeps getting simpler and simpler
18:07:05 <t7> maybe a lazy list of data Packet
18:07:12 <t7> then Data.Binary ?
18:07:31 <elliott> edwardk: as soon as GHC can read Core you can just build an instance dictionary directly and it'll be 20 lines :p
18:07:37 <elliott> (as soon as = never)
18:07:57 <edwardk> elliott: i could just make a couple of foreign import prim's and do it now ;)
18:08:15 <elliott> oh, you could? neat
18:08:27 <elliott> i bet it'd be faster :p
18:08:45 <elliott> actually, if [0..20] mod 6 is [0,1,2,3,4,0,1,2,...] then what's [0..] mod 6?
18:08:52 <elliott> erm *add a 5 in there
18:09:04 <elliott> [0,1,2,3,4,5] would mean that specifying an upper bound actually shortens the list
18:09:04 <edwardk> elliott: pick. ultimately something is borked
18:09:09 <elliott> oh wait, [0..20] mod 6 can't be what i said
18:09:17 <elliott> because the parameters are of the same type
18:09:34 <elliott> so it'll inevitably have the same result as [0..2]
18:10:03 <elliott> meh, how silly
18:10:06 <elliott> stupid typeclasses
18:10:17 <edwardk> http://hackage.haskell.org/packages/archive/monoids/0.1.36/doc/html/Data-Ring-ModularArithmetic.html i didn't bother with Ord or Enum
18:10:22 <edwardk> =)
18:11:21 <elliott> .    signum = error "broken numerical type tower"
18:11:21 <elliott>     abs    = error "broken numerical type tower"
18:11:21 <elliott> edgy :)
18:11:38 <edwardk> =P
18:11:43 <edwardk> i was a rebel in those days
18:12:12 <ivanm> edwardk: you're claiming you're not anymore? :p
18:12:25 <edwardk> nope. i'm a fine upstanding member of society
18:12:39 <ivanm> you mean you've learnt how to use haddock? :o
18:12:41 <ivanm> ;)
18:12:45 <edwardk> not in general
18:12:52 <edwardk> though i did bother to haddock the new reflection for you ;)
18:13:19 <ivanm> awww, thanks!
18:13:26 <ksf_> oh.
18:13:28 <elliott> whoa, 0.7 got haddocked already
18:13:29 <ksf_> http://permalink.gmane.org/gmane.comp.lang.haskell.libraries/12513
18:13:49 * ivanm never bothered to getting around and trying to write a new multinomial library, instead just relying on HaskellForMaths
18:13:53 <edwardk> that was fast
18:14:07 <elliott> i think it's scared of the power you might wield with actual documentation :)
18:14:17 <ksf_> vacuum is using it.
18:14:33 <elliott> edwardk: what happened to .Internal>?
18:14:48 <edwardk> i folded it back in, since the only extra class was ReflectNum
18:14:58 <edwardk> and the only extra combinator was reifyIntegral
18:15:08 <edwardk> when it was 4 classes and crazy combinators it was worth hiding
18:15:16 <elliott> ah
18:16:43 <edwardk> technically the new construction is a little less safe, but i like it better
18:16:52 <elliott> howso?
18:16:55 <elliott> platforms with weird pointers?
18:17:03 <edwardk> Nothing keeps you from turning a Proxy (s a) into a Proxy (s b)
18:17:11 <edwardk> and reflecting out the wrong type
18:17:18 <elliott> oooh, ouch!!
18:17:22 <elliott> does that let you get garbage data??
18:17:26 <ivanm> so I'm comparing my a "reference" algorithm to the "optimised" algorithm
18:17:26 <edwardk> yeah
18:17:29 <elliott> :/
18:17:34 <elliott> :(
18:17:41 <edwardk> just realized that
18:17:42 <elliott> is there any way to fix that? :p
18:17:45 <ivanm> and when I wrote the specification of the reference algorithm in my paper draft, I did it in a clearer way than what I had actually done
18:17:48 <edwardk> not without MPTCs ;)
18:17:51 <elliott> ugh
18:17:52 <ivanm> turns out it's also much faster...
18:17:56 <byorgey> ivanm: hahaha
18:17:59 <ksf_> byorgey, is svgtext supposed to be fast? :)
18:18:01 * elliott likes MPTCs marginally more than unsafeCoerce
18:18:03 <elliott> ivanm: ha
18:18:09 <edwardk> well, just don't do that ;)
18:18:11 <ivanm> not faster than the optimised one
18:18:12 <byorgey> ksf_: I have no idea
18:18:17 <elliott> edwardk: that's what C programmers say :P
18:18:18 <byorgey> ksf_: is it not fast?
18:18:28 <ivanm> e.g. it used to be 3 min vs ~0s; now it's 19s vs ~0s
18:18:35 <elliott> edwardk: hmm, wait
18:18:38 <ivanm> and I've only partially switched over to the "reference" implementation
18:18:40 <ksf_> hmm. the main thing seems to be that rendering those gazillions of beziers is slow.
18:18:41 <elliott> edwardk: you could fix it by using an abstract proxy type
18:19:06 <edwardk> elliott: i could i suppose, but that makes it harder for folks to use the proxy conversions when they want to make instances
18:19:09 <ksf_> it's not slow in a total sense, though. just in a realtime sense
18:19:20 <edwardk> actually it makes most of the usecases impossible
18:20:20 <ksf_> ...I'm caching the results of textSVG but it's not helping a single bit.
18:20:26 <byorgey> ksf_: ok, good to know
18:20:39 <byorgey> yeah, so it's probably not SVGFonts' fault
18:20:43 <elliott> edwardk: well, I wasn't thinking there'd be *no* way to make a Proxy
18:20:50 <elliott> just not a way to make *any* Proxy
18:20:50 <byorgey> there are probably things we can do to optimize the diagrams core.
18:20:56 <ksf_> transparent caching of bitmaps?
18:21:06 <edwardk> torn. i like the simpler version
18:21:11 <edwardk> i also like safety
18:21:14 <byorgey> ksf_: that only helps if you're generating bitmaps.
18:21:17 <ksf_> though... nah, not transparent.
18:21:44 <elliott> technically the mptcs version would still be made simpler by the IntPtr stuff, right? ...but it still seems like there should be a way to reclaim the safety without them
18:21:53 <edwardk> yeah
18:22:08 <edwardk> i have already started gutting the MPTC'less version and making it use MPTCs ;)
18:22:23 <ksf_> I'm threading the whole thing through elerea, and I could cache it easily there, but diagrams has no chance of knowing whether something it rendered before is rendered again.
18:22:34 <elliott> edwardk: hmm...
18:22:40 <elliott> edwardk: you could try and encode the type in the instance head still
18:23:20 <elliott> class Reified s where reflect :: p s -> s and reify gives you a (s -> a) or something... ehh
18:23:25 <elliott> *an
18:24:04 <edwardk> if reify gives you the function you're still done for
18:24:10 <edwardk> because you can't use it in the instance
18:24:14 <elliott> hmm, right
18:25:24 <elliott> you could use implicit params :P
18:27:07 <edwardk> =P
18:27:18 <elliott> hmm
18:27:24 <ksf_> byorgey, I dont' think there are enough postscript displays around, anymore, to bother about realtime vector display
18:27:24 <elliott> what if using it required FlexibleContexts?
18:27:37 <elliott> instance (Reified (s (Monoid_ ...))) => Monoid ...
18:27:57 <elliott> the instance would be ReifiedNum => Reified (Stable s a)
18:28:12 <elliott> oh hmm
18:28:16 <elliott> that's back to the "reify gives you the function" thing
18:28:21 <elliott> pah
18:29:47 <dmwit> ksf_: " diagrams has no chance of knowing whether something it rendered before is
18:29:47 <elliott> edwardk: you should be able to use a TF rather than MPTC+FDs, right?
18:29:51 <edwardk> yeah
18:29:53 <dmwit>               rendered again" <- not quite true
18:29:59 <edwardk> thats the version i started implementing
18:30:04 <elliott> that seems like it'd be less ugly, since the instance heads stay small
18:30:05 <elliott> ah, OK
18:30:09 <edwardk> it used to not work
18:30:14 <elliott> erm not the heads, the... whatevers
18:30:14 <edwardk> back around 6.12 or so when i started it
18:30:19 <edwardk> the TF version was borked
18:30:24 <elliott> ah
18:30:33 <elliott> what's the type family called? Reified is taken now :P
18:30:34 <edwardk> i checked a year or so back at copumpkin's prodding and it worked
18:30:40 <edwardk> Reflected
18:30:42 <dmwit> ksf_: I mean it's seems plausible at least to implement some function "doSomeRenderingPreComputation :: Diagram -> Diagram" or something like that.
18:30:49 <edwardk> reflect :: p s -> Reflected s
18:30:52 <elliott> ah
18:30:55 <elliott> that works :)
18:30:58 <edwardk> er reflect :: Reified s => p s -> Reflected s
18:31:12 <elliott> hmm... couldn't that just be "reflect :: Reified s => Reflected s"? you don't actually need the proxy there
18:31:19 <elliott> oh, wait
18:31:21 <dmwit> ksf_: (Brent and I were discussing having "cat" do something like this just last week. Dunno if it's been implemented yet.)
18:31:23 <elliott> type family, not data family
18:32:15 <ksf_> another option would be to specify bitmap composition alongside vector composition
18:32:41 <edwardk> yeah
18:33:21 <dmwit> ksf_: Also, anything containing "realtime" in the sentence probably won't convince byorgey. =)
18:34:12 <ksf_> well, I was thingking along the lines of "not forcibly slower than cairo"
18:34:21 <tgeeky_> dmwit: "Cat" do something? False. Humans can't make cats do anything. Cats do their own deciding.
18:35:12 <elliott> Cats *are* decision.
18:35:40 <edwardk> hrmm, one problem is this version doesn't do defaulting as nicely
18:36:05 <elliott> compared to mptcs?
18:36:07 <edwardk> reify 6 reflect under 0.7 returns 6 at ghci
18:36:13 <edwardk> no compared to the current evil version
18:36:19 <dmwit> blech, nothing like trying to fix a system so broken you don't have a browser to look up error messages in
18:36:22 <elliott> ah
18:36:30 <edwardk> reify 6 reflect under the TF version requires a type signature
18:36:32 <elliott> well nobody uses reify directly, do they? :)
18:36:32 <tgeeky_> dmwit: lynx? :o
18:36:47 <elliott> all the wrappers you write over it shouldn't have that problem, right?
18:36:49 <edwardk> just inconvenient
18:36:52 <dmwit> zsh: correct 'lynx' to 'ln' [nyae]?
18:37:22 <tgeeky_> dmwit: uhhhhhhhhhhhhh. yes!
18:37:27 <dmwit> hehehe
18:37:35 <tgeeky_> hopefully something TRON-line will happen
18:38:07 <elliott> edwardk: unsafeCoerce is pretty convenient for making types work out too
18:38:13 <edwardk> =P
18:38:39 <elliott> edwardk: hmm
18:38:46 <elliott> oh, i was about to make another proposal
18:38:52 <elliott> but it amounted to "make p more abstract" again
18:39:21 <elliott> i was thinking "class Reified s where reflect :: s a -> a", and reify giving you a Stable, but that has the same problem
18:40:23 <dmwit> Is it *really* so bad to pass a real dictionary around??
18:40:45 <elliott> dmwit: how can you do modular arithmetic or edwardk's monoid example with that?
18:40:51 <BrianHV> this is so close to working...
18:41:10 <elliott> you'd have to change the entire numerical typeclass to accommodate your dictionary-passing
18:41:13 <elliott> *typeclasses
18:41:20 <edwardk> dmwit: the main example is making a monoid out of an arbitrary pair of functions you have lying about
18:41:32 <edwardk> er a function and a value
18:41:34 <elliott> (mempty isn't a function!)
18:41:44 <elliott> snap :)
18:44:00 <BrianHV> how would I write a quickcheck property that would fail if (==) were implemented as True?
18:44:28 <elliott> BrianHV: you can't, unless you have two known-unequal values handy...
18:45:02 <ivanm> byorgey, elliott: it might interest you to know that though the first step in converting to the "reference" implementation sped it up, the second step slowed it down again (though not as much)
18:45:07 <BrianHV> I could come up with a couple. but that would be more of a job for hunit...
18:45:26 <ivanm> and seems to produce different output... :/
18:45:35 <ivanm> (the right number, just not the same binary file)
18:47:33 <elliott> BrianHV: i mean, the property would look like "assuming x and y aren't equal, check x == y is false"
18:47:40 <elliott> but "x and y aren't equal" --> "x /= y"
18:47:49 <elliott> (and what if the type has only one value?)
18:48:29 <BrianHV> yeah. not worth it. :)
18:49:11 <BrianHV> so... my ModuleData now has a Typeable superclass. my (==) correctly compares the types of the modules.
18:49:22 <ivanm> BrianHV: you mean that there's a definition of _ == _ = True ?
18:49:24 <BrianHV> the only thing left to do is compare the values themselves if the types are equal
18:50:20 <BrianHV> ivanm: yeah. I was mostly bothered by the fact that another one of my tests was passing with that definition.
18:50:27 <BrianHV> but it's not really important.
18:50:33 <ivanm> I think that's just a matter of "stupid programmer"
18:50:46 <ivanm> unless you restrict the data type in question, there's no real way of knowing
18:50:58 <BrianHV> but I thought if haskell code compiled it was correct. ;)
18:51:00 <ivanm> e.g. if you had Enum, you could check x == succ x
18:51:36 <BrianHV> instance Eq PageModule where PageModule a == PageModule b = typeOf a == typeOf b
18:51:55 <BrianHV> at this point a and b are the same types, and are known elsewhere to be instances of Eq
18:52:10 <BrianHV> so... how can I actually compare a and b?
18:52:32 <edwardk> elliott: i have the cleaner version worked up
18:52:39 <edwardk> one sec. i'll upload to github
18:53:25 <elliott> BrianHV: use cast
18:53:26 <elliott> :t cast
18:53:27 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
18:53:56 <elliott> or, hmm
18:54:03 <elliott> yes, you should be able to
18:54:09 <elliott> ...maybe
18:54:38 <BrianHV> I'm afraid I find that type signature puzzling, at least in its application to my situation.
18:56:38 <edwardk> elliott: pushed
18:56:47 <edwardk> elliott: its not on hackage yet though
18:56:55 <edwardk> elliott: since i figured i should wait 5 minutes ;)
18:57:21 <elliott> hehe
18:57:29 <edwardk> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs is a lot cleaner
18:58:03 <elliott> yeah, that looks reasonable
18:58:08 <elliott> the larger constraints are a bit annoying but oh well
18:58:42 <edwardk> yeah
18:58:45 <elliott> edwardk: your other-extensions field grew more than you need
18:58:52 <Elemir> Hem-hem. Why not Clean expect of Haskell?
18:58:56 <edwardk> oh yeah
18:59:02 <elliott> Elemir: ?
18:59:03 <Elemir> Linear types look nice
18:59:14 <edwardk> Elemir: they also really complicate a LOT of things
18:59:38 <elliott> edwardk: btw, is there a reason you export ReifiedNum and friends? are they significantly faster than Reified if you're using a numeric type?
18:59:42 <edwardk> Elemir: many common optimizations are no longer sound in the presence of linear types, plus clean has lots of environment capture issues with partial application
18:59:57 <edwardk> elliott: reifiedNum could be faster, yes
19:00:03 <Twey> Linear types make sharing difficult
19:00:16 <Elemir> edwardk: But Clean is a faster than GHC!
19:00:20 <elliott> edwardk: i said "significantly" ;)
19:00:24 <elliott> Elemir: [citation needed]
19:00:29 <edwardk> Elemir: thats because it doesn't do anything
19:00:37 <edwardk> Elemir: have you actually looked through its standard libraries?
19:00:44 <Elemir> And you can use IO a = ST *Word a
19:01:01 <elliott> that's a benefit how?
19:01:13 <elliott> "internal representation of IO type" is not on my list of language features I care about ;)
19:02:04 * Elemir wants to alternative to monadic ways for working with Real World
19:02:55 <elliott> you'll want to use that monadically anyway
19:03:02 <Elemir> No
19:03:07 <elliott> just like you don't work with state in haskell by manually plumbing tuples
19:03:10 * Elemir want to use comonads
19:03:10 <elliott> it has the exact same structure
19:03:13 <elliott> what
19:03:17 <elliott> IO is plainly not comonadic
19:03:17 <Twey> o.@
19:03:25 <Elemir> IO — doesn't
19:03:25 <elliott> do you know what comonads are? :)
19:03:26 <edwardk> Elemir: comonadic IO is unsound
19:03:27 * Twey tries to imagine a comonadic IO
19:03:43 <Elemir> @hackage oi
19:03:44 <lambdabot> http://hackage.haskell.org/package/oi
19:03:47 <edwardk> Elemir: Kieburtz's OI comonad doesn't work
19:03:53 <Elemir> Twey: you are welcome
19:03:55 <edwardk> it overlooks a fundamental problem
19:04:00 <elliott> listen to edwardk, he's the world's expert in computational comonads :P
19:04:01 <edwardk> every functor in haskell is strong
19:04:57 <Twey> Elemir: Thanks :þ
19:05:25 <Elemir> 06:03 < edwardk> every functor in haskell is strong
19:05:26 <Elemir> ?
19:05:27 <elliott> hmm, what /is/ that OI thing even doing
19:06:02 <Elemir> It's doing nothing. It is proof of concept
19:06:07 <tgeeky_> @google every functor in haskell is strong
19:06:09 <lambdabot> http://comonad.com/reader/2008/deriving-strength-from-laziness/
19:06:09 <lambdabot> Title: The Comonad.Reader » Deriving Strength from Laziness
19:06:16 <edwardk> strength :: Functor f => a -> f b -> f (a, b)  -- it means that its possible to get values into your OI comonad without using sequencing, from other OI actions
19:06:19 <BrianHV> got it!
19:06:20 <edwardk> it makes the whole thing a joke
19:06:36 <edwardk> :t fmap . (,)
19:06:36 <elliott> is that the same OI comonad as in that package?
19:06:36 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f (a1, a)
19:06:37 <elliott> data OI a = OI { variable :: LeftValueOf (IO a), value :: a }
19:06:45 * BrianHV dances a haskell jig.
19:06:52 <elliott> LeftValueOf is apparently MVar.
19:07:34 <Elemir> AFAIR it isn't a Kieburtz's OI
19:09:19 <Vigor> Hello, basic question on all and any functions. If predicate is true for all elements of a set, shouldn't any also be true on the same set and predicate?
19:09:40 <BrianHV> elliott (or interested others): can you check this out and tell me if it's sensible? particularly the Eq instance and what I'm doing with registeredModules.  https://gist.github.com/2324200
19:09:45 <edwardk> hrmm, i don't think i believe the (#) is a valid duplicate for that OI comonad
19:10:20 <edwardk> in fact, i'm pretty sure it isn't
19:10:33 <elliott> it looks very much like one of those unsafe*s is going to leak out into the semantics
19:10:38 <elliott> and break a whole bunch of laws and your furniture
19:10:53 <elliott> BrianHV: Eq is correct
19:11:18 <elliott> BrianHV: registeredModules works but you will not be able to load new modules at runtime, of course
19:11:22 <elliott> if you're going with TH then that's fine
19:11:27 <elliott> however
19:11:42 <Elemir> elliott: Very much unsafes is a typical haskell problem. You can't invent unmonadic I/O without unsafes
19:11:57 <tgeeky_> Vigor: I think so. You mean "the same set, the same predicate". You're asking is the predicate always true after it's applied to the set?
19:12:00 <elliott> Elemir: you're talking nonsense frankly
19:12:02 <edwardk> Elemir: sure you can
19:12:16 <Elemir> #RealWorld is a real type now?
19:12:26 <edwardk> http://comonad.com/reader/2011/free-monads-for-less-3/
19:12:30 <elliott> BrianHV: data ModuleRegistration = forall md. ModuleData md => ModuleRegistration (Proxy md)
19:12:34 <elliott> BrianHV: get rid of those undefineds
19:12:53 <elliott> BrianHV: also, you should use a Map String ModuleRegistration to avoid that linear scan
19:12:57 <edwardk> Elemir: You can manually plumb State# RealWorld's all over the place if you want. just don't duplicate it
19:13:12 <edwardk> Elemir: you can track the contraction of it by hand if you need to
19:13:12 <elliott> edwardk: what's kieburtz's OI, out of curiosity?
19:13:20 <elliott> like, how would you define it, ignoring the massive problem :)
19:13:37 <edwardk> elliott: it was a proposal for how to do comonadic io based on a sort of parallel world model =)
19:13:48 <edwardk> its just not implementable
19:14:14 <Elemir> Working with non-linear RealWorld is harmful and unsafe itself
19:14:24 <elliott> edwardk: fair enough
19:14:35 <BrianHV> elliott: you mean instead of DL.find in parseJSON?
19:14:48 <edwardk> http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.46.5169
19:15:02 <tgeeky_> elliott: I don't buy that.
19:15:18 <elliott> edwardk: that blog post has unbalanced parens :(
19:15:19 <edwardk> Elemir: anyways, any OI comonad is provably unsound from a simple construction
19:15:20 <elliott> tgeeky_: buy what
19:15:23 <Elemir> Why must Elemir check linearity of RealWorld?
19:15:28 <Vigor> tgeeky_ I think if all is true for all elements of a set, then any must be true, example all even [2,4,6] -> True, so it must be true that any even [2,4,6] is True, but that is not the case for all sets
19:15:34 <edwardk> Elemir: Every comonad gives rise to a monad transformer.
19:15:35 <BrianHV> elliott: and are you talking about Data.Proxy?
19:15:39 <tgeeky_> elliott: that working with non-lienar RealWorld is a priori morally wrong.
19:15:43 <elliott> Elemir: because Elemir is trying to implement a new kind of IO
19:15:48 <elliott> tgeeky_: you are talking to the wrong person, methink
19:15:48 <elliott> s
19:15:54 <edwardk> Elemir: so you can trivially derive IOT from an OI comonad
19:16:03 <elliott> tgeeky_: perhaps you mean someone who starts with the same two letters as me :)
19:16:09 <elliott> BrianHV: yes, the tagged package
19:16:18 <elliott> [This message endorsed by edwardk industries.]
19:16:19 <tgeeky_> Elemir: that working with non-lienar RealWorld is a priori morally wrong.
19:16:28 <edwardk> Elemir: the problem is that linear types cost you other features. they interact non trivially with other type system extensions
19:16:28 <elliott> [Paid for by Haskellers for a Better America.]
19:16:32 <Elemir> Of cause
19:16:51 <Elemir> So it must be linear types in compiler :#
19:17:19 <edwardk> Elemir: I'm not willing to give up easy partial application, rank n types, type families, all the crazy kind system extensions, etc. just to start over with clean.
19:17:35 <BrianHV> elliott: great. thanks so much for your help. I'm very pleased with this solution.
19:18:05 <edwardk> Elemir: but even if you had linear types, the above issue would hold with any attempt at comonadic IO
19:18:09 <Elemir> edwardk: But we can invent linear types in a GHC, can't we?
19:18:29 <edwardk> Elemir: They don't interact well with many of the optimizations and type system extensions we HAVE though
19:18:56 <edwardk> Elemir: lambda lifting in the presence of linear types is harder, lots of standard compiler optimizations pick up a ton of side conditions, etc.
19:19:05 <edwardk> it makes it a lot harder to figure out how to improve the language
19:19:44 <tgeeky_> Vigor: I don't know set theory that well, but, so it may depend on what kind of predicate you use. Are you asking because you have a counterexample?
19:19:57 <edwardk> Elemir: when i first discovered haskell, i spent a lot of time obsessed with substructural type systems, and went off and spent much of my second thesis working on a type system that had linear, relevant, affine, and uniqueness types.
19:20:11 <edwardk> Elemir: Also note, that linear types are NOT the uniqueness types in clean!
19:20:26 <Elemir> Hem
19:20:40 <elliott> edwardk is totally ruining my burgeoning interest in substructural type systems.
19:20:42 <Elemir> What difference?
19:20:46 <elliott> My party is pooped.
19:21:20 <edwardk> Linear types are a forward facing temporal modality that say that you will never contract or weaken a type again. Uniqueness types are a backward facing temporal modality that say that you haven't contracted (and since its still here, you haven't weakened) a type yet
19:21:40 <edwardk> They are actually opposite ends of the substructural type spectrum
19:22:01 <edwardk> I can convert a uniqueness typed value to an unrestricted value, and an unrestricted value to a linear value, but i can't go the other way
19:22:24 <edwardk> But even if you have uniqueness, that isn't enough
19:22:32 <edwardk> because it doesn't tell you that you _should_ edit it in place
19:22:35 <edwardk> because you don't know relevance
19:22:53 <edwardk> so You need a continuum of relevant and potentially irrelevant types to make proper use of uniqueness.
19:23:16 <Vigor> tgeeky_ : I am not sure we need set theory here, I think this is basic logic.  If we say that all elements of a set are true, then any must be true too, but Haskell treats empty set differently. all returns true for empty set, but any returns false.  Does this make sense?
19:23:33 <edwardk> Then you can build up an affine chain of thunks for edits to potentially irrelevant uniqueness typed values, and do the edits in place for relevantly uniqueness typed values
19:23:42 <edwardk> clean gets this wrong
19:23:57 <tgeeky_> Vigor: yes.
19:24:04 <elliott> Vigor: not (exists (x \in emptyset), p x) for any p
19:24:08 <elliott> Vigor: but forall (x \in emptyset), p x
19:24:09 <elliott> for any p
19:24:14 <elliott> this is because no elements of the empty set exist
19:24:18 <elliott> quod erat etc.
19:24:26 <Elemir> Hem
19:24:27 <edwardk> Doing it wrong means you can convert some programs that terminate into programs that do not terminate in clean just by adding uniqueness type annotations
19:24:52 <edwardk> Elemir: please, believe me, its not a trivial extension. =)
19:24:56 <elliott> Vigor: basically, you're saying "a predicate holding of all elements of a set means that there must be an element of the set such that the predicate holds"
19:25:02 <elliott> Vigor: which makes it obvious that it doesn't apply to []
19:25:05 <elliott> because there exists no element of []!
19:25:19 <elliott> "any element satisfies p" ~ "there exists an element that satisfies p"
19:25:29 <tgeeky_> Vigor: in this case, you need neither set theory nor logic, but knowledge of Haskell specific stuff.
19:25:34 <edwardk> Also, even if you make relevant types, relevance is a conservative approximation of strictness
19:26:24 <elliott> tgeeky_: not really even haskell specific :)
19:26:31 <edwardk> We don't care that you never weaken any contraction of a type (relevance), we care that there exists one contraction that doesn't get weakened (strictness)
19:26:50 <Vigor> elliott: perhaps all should return False for empty set, since it's misleading to return True on any predicate when there are no elements to test against?
19:27:00 <tgeeky_> elliott: well, he didn't come to #haskell for Nothing :o
19:27:14 <elliott> Vigor: forall elements x of the empty set, p(x) holds
19:27:16 <elliott> for all predicates p
19:27:20 <elliott> this is, indeed, basic set theory
19:27:28 <elliott> see http://en.wikipedia.org/wiki/Vacuous_truth
19:27:35 <Veinor> Vigor: tat would break all p x && all p y = all p (x ++ y)
19:27:39 <Veinor> that
19:27:48 <elliott> oh sure, bring out the *practical* reasons
19:28:20 <Vigor> thanks for the link!
19:29:12 <Veinor> elliott: 'for all p :: a -> Bool, we want all p to be a homomorphism from the monoid [a] to the monoid {True, False} with and as its operation'
19:29:13 <Veinor> happy?
19:29:34 <elliott> Veinor: thanks
19:29:38 <elliott> much better
19:32:48 <edwardk> Veinor: better ;)
19:33:57 <elliott> when trying to reproduce the reflection bug: <interactive>: out of memory (requested 3117416448 bytes)
19:34:01 <elliott> that's way more fun than a segfault!
19:34:15 <Veinor> > 3117416448 / (10 ^ 9)
19:34:16 <lambdabot>   3.117416448
19:34:22 <Veinor> nice
19:35:03 <tgeeky_> elliott: you must have almost gotten halfway there (pi)
19:35:14 <tgeeky_> elliott: maybe you've run into zeno's paradox
19:37:01 <Luke> I'm trying to install snap with -fhint flag and then another package which depends on snap from github. when I install the second package, it reinstalls snap without the -fhint flag. anyone know why it's reinstalling snap even though it's already installed?
19:38:10 <elliott> Luke: cabal likes to do that
19:38:16 <elliott> try --avoid-reinstalls if you have darcs cabal-install
19:38:38 <Luke> darcs cabal-install? you mean installed from source?
19:39:13 <Luke> yeah looks like my version doesn't have that flag
19:39:21 <elliott> no, i mean installed from source from the darcs repository
19:39:26 <elliott> it also has a new modular solver
19:39:40 <Luke> yeah
19:39:41 <edwardk> elliott: monoid :: (a -> a -> a) -> a -> (Monoid a => r) -> r
19:39:44 <Luke> ok thanks
19:39:49 <edwardk> elliott: sufficiently evil looking?
19:39:53 <elliott> darcs get --lazy (or was it --partial?) http://darcs.haskell.org/cabal/
19:40:05 <elliott> then cd cabal/cabal-install, sh bootstrap.sh after blowing your existing ~/.{cabal,ghc} up, if you want it
19:40:09 <elliott> then you can use --solver=modular --avoid-reinstalls
19:40:12 <elliott> failing that, just wipe everything and try again :P
19:40:23 <elliott> Luke: you can also tell cabal to use a certain constraint for a dependency i think, but i forget how
19:40:25 <elliott> edwardk: with ConstraintKinds?
19:40:27 <elliott> oh wait
19:40:36 <elliott> edwardk: heh, how does that work?
19:40:36 <edwardk> behind the scenes, yes
19:40:36 <Luke> cool - thanks
19:40:41 <JoeyA> While it's on-topic, is there a way to make --force-reinstalls default (besides using an older version of cabal-install) ?
19:40:43 <elliott> with your evil lying Dict stuff?
19:40:46 <edwardk> elliott: working it up right now, but the plumbing is all there
19:40:47 <edwardk> yeah
19:40:52 <elliott> JoeyA: alias cabal="cabal ..."
19:40:59 <edwardk> putting a scarier monoid example in the package
19:41:07 <elliott> edwardk: please no examples with unsafeCoerce :)
19:41:17 <elliott> :P
19:41:26 <elliott> you're on a one-man mission to break the open world assumption
19:41:26 <shachaf> edwardk: That's a fancy-looking type you've got there!
19:41:28 <edwardk> there is one, its hidden in the Data.Constraint.Unsafe package
19:41:34 * shachaf reads context.
19:41:44 <edwardk> =)
19:41:45 * tgeeky_ corrupts shachaf's terminal
19:42:05 <shachaf> edwardk: Is that actually possible?
19:42:16 <elliott> shachaf: with ConstraintKinds, GADTs and unsafeCoerce, yes
19:42:17 <edwardk> read the articles on my blog about constraints
19:42:27 <elliott> and if anyone adds a Monoid instance for the type you're using
19:42:29 <elliott> then all bets are off
19:42:29 * shachaf looks.
19:42:37 <edwardk> elliott: there is that =)
19:42:45 <shachaf> edwardk: (Success! The ISP where I am right now isn't Comcast.)
19:42:48 <elliott> edwardk: at least put a comment above it telling people it's unsafe and evil :P
19:42:53 <edwardk> shachaf: btw- it works on comcast here
19:42:58 <edwardk> so there is something regional where you are
19:43:04 <shachaf> Probably.
19:43:27 <shachaf> edwardk: I don't think it really counts if you have an unsafeCoerce.
19:43:32 <JoeyA> I sometimes wish I could use . or $ in type definitions, e.g.:  ReaderT CurrentTarget $ WriterT (DList String) $ StateT Herp $ State Derp
19:43:37 <edwardk> shachaf: *shrug*
19:43:50 <edwardk> the unsafe coerce is to convert an instance for a newtype of a into an instance for a
19:44:01 <elliott> unsafeBreakOpenWorldAssumption
19:44:24 <elliott> :: (Newtype n o) => Dict (c n) -> Dict (c o)
19:45:40 <edwardk> elliott: thats 'https://github.com/ekmett/constraints/blob/master/Data/Constraint/Unsafe.hs#L29
19:45:49 <edwardk> er https://github.com/ekmett/constraints/blob/master/Data/Constraint/Unsafe.hs#L32
19:46:01 <shachaf> edwardk: Your weblog is advertising Erlang jobs!
19:46:03 <elliott> edwardk: That has far too benign a name.
19:46:10 <shachaf> That's because there are no Haskell jobs, right?
19:46:11 <edwardk> shachaf: its in a module named Unsafe ;)
19:47:10 <kallisti> is there a fast way to figure out cabal dependencies
19:47:19 <elliott> edwardk: so are unsafeCoerce and unsafePerformIO
19:47:23 <elliott> and they still have unsafe in the name :P
19:47:30 <elliott> kallisti: cabal init is getting guessing support soon.
19:47:31 <edwardk> *shrug*
19:47:40 <elliott> kallisti: if you use cabal-dev you can keep track of your dependencies from the start
19:47:50 <kallisti> ah okay.
19:47:53 <kallisti> I'll have to start using that perhaps.
19:47:56 <edwardk> then i have unsafeEvil -- and thats just silly
19:48:03 <elliott> edwardk: you telling me evil is safe?
19:48:08 <edwardk> nope
19:48:15 <elliott> kallisti: also gets you "cabal-dev ghci" which loads all your modules into a ghci
19:48:24 <elliott> (and isolated environments so you don't get cabal dependency hell)
19:51:04 <kallisti> ah a sandboxed cabal would be useful to figure out dependencies.
19:55:55 <donri> how do i work around this type error? http://hpaste.org/66534
19:57:17 <kallisti> donri: just give it a monomorphic type.
19:57:46 <donri> but the whole point here is the polymorphism
19:57:50 <elliott> donri: it doesn't know which ClientSession you want
19:57:59 <kallisti> oh you may want a asTypeOf
19:58:02 <elliott> you have to make it _more_ monomorphic - perhaps by unifying with another polymorphic variable
19:58:09 <elliott> kallisti: or just ScopedTypeVariables
19:58:12 <edwardk> elliott: its now 'unsafeCoerceConstraint'
19:58:22 <elliott> edwardk: acceptable
19:58:29 <elliott> I still prefer unsafeBreakOpenWorldAssumption :)
19:58:51 <edwardk> =P
19:58:56 <kallisti> elliott: "just"?  Shouldn't the just be applied to the thing that's baked into Prelude? :P
19:59:14 <kallisti> but yes, you can do that as well.
20:00:48 <donri> elliott: don't quite understand ...
20:00:53 * hackagebot constraints 0.3 - Constraint manipulation  http://hackage.haskell.org/package/constraints-0.3 (EdwardKmett)
20:01:15 <elliott> donri: well the problem is here:     new = do putSession' name age key empty
20:01:22 <kallisti> donri: it doesn't know that the value "empty" is the same type as the "a" in m a
20:01:27 <elliott> donri: it doesn't know which empty to use there
20:01:42 <donri> ooh i'm starting to see it
20:01:53 <elliott> new = do putSession' name age key (empty :: a) -- enable ScopedTypeVariables and put "forall m a." at the start of getSession''s type
20:02:04 <elliott> then it'll know that it has to be the same ClientSession as in the invocation
20:02:28 <kallisti> donri: there's also asTypeOf, which allows you unify 2 types.
20:02:30 <kallisti> :t asTypeOf
20:02:31 <lambdabot> forall a. a -> a -> a
20:02:41 <elliott> yes, except that donri has no handy "a" lying around here :p
20:02:59 <kallisti> not convenient, no. there may be one though..
20:03:10 <elliott> edwardk: btw wouldn't the pointer serialisation be even faster if you just gave instances for e.g. four and eight-tuples rather than allowing arbitrarily nested stacks?
20:03:13 <elliott> i know, i know, so unportable :)
20:03:26 <edwardk> not really
20:03:41 <donri> yay it type checks
20:03:42 <donri> thanks guys
20:03:56 <edwardk> you can make the instances per byte like you had
20:04:00 <edwardk> but thats kinda silly =)
20:04:18 <donri> and gals; let's not be sexist.
20:04:20 <edwardk> also note that this is only paid for once per reflection
20:04:26 <edwardk> er per reification
20:04:27 <elliott> edwardk: oh, i meant 32/64 tuples
20:04:30 <elliott> i guess those are a bit too big :P
20:04:34 <edwardk> yeah
20:04:53 <elliott> edwardk: you say silly, I say so fast I had to generate it with a perl script
20:05:12 <edwardk> try it and benchmark it ;)
20:05:33 <elliott> very well then!
20:05:46 <elliott> i can't think of an even vaguely reasonable benchmark, mind :P
20:06:25 <elliott> I guess reify bigStructure reflect would work
20:06:30 <elliott> oh, wait, size of structure is irrelevant
20:06:37 <elliott> reify () reflect a trillion times, then
20:08:10 <edwardk> reify every element in a huge list and force the answers
20:08:39 <elliott> nest the reifies, you mean?
20:08:40 <edwardk> show $ map (\x -> reify x reflect) [1…100000]
20:09:03 <edwardk> that should more or less test the round trip time
20:09:27 <edwardk> (or replace show with a deepSeq of some sort)
20:10:17 <tkahn6> hey guys i wrote a dcpu-16 emulator, any critique or suggestions on style? https://github.com/tkahn6/dcpu16-haskell
20:10:53 <elliott> edwardk: right
20:11:35 <tkahn6> i feel like i used fromIntegral a lot, any suggestions on how to be more coherent with my integral types would be greatly appreciated
20:11:36 <elliott> guess i'll use cpp to generate it this time 'round
20:12:31 <elliott> edwardk: out of curiosity, how much faster would that foreign import prim approach be?
20:12:37 <edwardk> no idea
20:13:47 <edwardk> tkahn6: that register file looks pretty slow
20:14:07 <tkahn6> edwardk: u think i should use data.map?
20:14:16 <edwardk> or just making something like
20:14:35 <edwardk> data Register= A | B | C | X | Y | Z | I | J deriving (Eq,Ord,Bounded,Enum,Show,Read)
20:14:55 <tkahn6> yeah i thought about pushing the register up into the type system
20:14:58 <tkahn6> registers*
20:15:15 <edwardk> data RegisterFile = RegisterFile {-# UNPACK #-} !Word16 {-# UNPACK #-} !Word16 … !Word16 !Word16 !Word16 ..
20:15:23 <tkahn6> ooh
20:15:41 <tkahn6> what does that UNPACK directive do?
20:15:42 <edwardk> and making combinators for getting and setting registers
20:16:06 <edwardk> it keeps those from being boxed values, in particular it makes those into actual machine 16 bit words stored in the RegisterFile constructor
20:16:13 <elliott> or just -funbox-strict-fields
20:16:32 <edwardk> elliott: i never like -funbox-strict-fields because i often have ones i don't want unboxed
20:16:39 <elliott> tkahn6: (someone else has already written one, btw :p)
20:16:46 <tkahn6> elliott: i saw tht!
20:16:49 <tkahn6> that*
20:16:51 <tkahn6> they use STM i think
20:16:58 <tkahn6> i opted to go with the State monad
20:17:00 <edwardk> i should write a dcpu tracing jit
20:17:12 <tkahn6> edwardk: do it. that would be really educational
20:17:12 <elliott> so predictable :P
20:17:17 <edwardk> do we have any actual dcpu code?
20:17:20 <mgsloan> does anyone have "Castable a b where { cast :: a -> b}" wrapped up somewhere?  I know it's awful, but I think it's got its uses
20:17:24 <elliott> notch has some examples i think
20:17:31 <elliott> mgsloan: :(
20:17:32 <tkahn6> edwardk: yeah there's an example in the spec
20:17:35 * elliott judges mgsloan
20:17:39 <mgsloan> :D
20:17:50 <elliott> edwardk: and someone's done fibonacci i think
20:17:59 <mgsloan> elliott: I have a very good reason for it.
20:18:10 <elliott> mgsloan: go on :P
20:18:46 <ClaudiusMaximus> mgsloan: http://hackage.haskell.org/package/convertible ?
20:18:58 <tkahn6> a lot of people have a broken implementation because there's an instruction IFE/IFN/IFG/IFB that will skip the next instruction if the condition is true, but in order to get the lenght of the next instruction, people will decode it and run the side effects of the instruction (like mutating the stack pointer)
20:19:29 <tkahn6> and notch's program doesn't break if yours does that
20:20:04 <tkahn6> since i'm using the state monad i just save the state, run the instruction side effects and then replace the state, only saving the program counter
20:20:14 <mgsloan> elliott: I'm typing up a blog post on the idea right now, but pretty much I want to propose a modification of the ECT ( http://www.haskell.org/haskellwiki/The_Monad.Reader/Issue2/EternalCompatibilityInTheory )
20:20:38 <mgsloan> which I discovered after reading up on the materials necessary to write up the proposal
20:20:59 * elliott thinks the ECT thing is crap :)
20:21:12 <mgsloan> anyway, in order to get cross-version module compatibility, you need to express coercions between data types
20:21:14 <napping> Can aeson be used for stricter validation? I don't see any quick way to look for unexpected fields
20:21:28 <elliott> "we can solve backwards-compatibility problems by maintaining every interface and bug, indefinitely, until the end of time"
20:21:40 <Elemir> @hoogle IO a -> (a, IO ())
20:21:41 <lambdabot> Data.Generics.Twins gmapAccumA :: (Data d, Applicative a) => (forall e. Data e => b -> e -> (b, a e)) -> b -> d -> (b, a d)
20:21:41 <lambdabot> Data.Traversable mapAccumL :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
20:21:41 <lambdabot> Data.Traversable mapAccumR :: Traversable t => (a -> b -> (a, c)) -> a -> t b -> (a, t c)
20:21:52 <Elemir> Hem
20:21:58 <mgsloan> elliott: I agree.  My variant is quite a bit better I think :)  I have some other reasons this would be beneficial
20:22:07 <mgsloan> I'll let you know when I've posted it
20:22:21 <elliott> mgsloan: fair enough
20:22:25 <elliott> Elemir: impossible
20:22:27 <Elemir> Is `IO a -> (a, IO ())' a really safe function?
20:22:30 <elliott> no
20:22:33 <elliott> Elemir: getLine
20:22:46 <elliott> foo getLine --> (an impossible string, something that reads a line and discards it)
20:22:49 <mgsloan> ClaudiusMaximus: Thanks!
20:24:18 <Elemir> Hem
20:25:13 <Elemir> And something like `IO a -> (a -> IO b) -> (b, IO ())'?
20:26:04 <elliott> that's the same thing.
20:26:07 <elliott> pass return as the second argument.
20:26:57 <Elemir> Of cause no, because we can use `\x -> x `thiscrap` return' to invent first `function'
20:28:15 <Elemir> Hem, how clean invent getLine?
20:28:26 <elliott> because clean has linear types
20:28:38 <elliott> erm
20:28:39 <elliott> uniqueness types
20:28:41 * elliott hides from edwardk
20:28:49 <Elemir> No-no, how does it looks?
20:29:27 <elliott> i don't know clean syntax but something like
20:29:29 <Elemir> It should has type *World -> (a, *World), yes?
20:29:32 <elliott> getLine :: !World -> (a, !World)
20:29:41 <edwardk> Elemir: both of those are unsafe in Haskell
20:29:49 <elliott> Elemir: you can't prove it's not referentially transparent, because you can never call it with the same World twice
20:29:56 <elliott> because your old World gets taken from you by the uniqueness
20:31:26 <tkahn6> .. what is World?
20:31:49 <donri> ah, the eternal question
20:32:01 <elliott> tkahn6: the semantically-dubious real world token
20:32:30 <elliott> not only does it represent the state of the entire universe, but if your language has forkIO, worlds can be merged!
20:33:02 <Elemir> World represent RTS, I think
20:33:24 <elliott> If you bake your RTS into the semantics of your language, then you have two problems.
20:33:28 <elliott> At least. Probably more.
20:33:31 <elliott> Probably more like 10 to 15 problems.
20:33:45 <Elemir> Infinity problems, heh
20:33:52 <JoeyA> What if you bake regular expressions into your RTS?
20:34:00 <tkahn6> zingg
20:34:04 <elliott> JoeyA: Surprisingly, that actually gets rid of all your problems.
20:34:04 <JoeyA> Is there a language that's done this?
20:39:36 <mgsloan1> elliott: a much more inflamatory suggestion for Convertible would be to integrate it into the base libraries, and add -XConvertible, switching to weak typing.  This wouldn't be as heinous as other uses of coercion, if only used to convert between different versions of data structures.
20:40:14 <elliott> /mode +b mgsloan
20:40:14 <elliott> /mode +b mgsloan
20:40:15 <elliott> /mode +b mgsloan
20:40:18 <mgsloan> :)
20:40:18 <elliott> help!! it isn't working
20:40:45 <tkahn6> mgsloan: what's the motivation behind Convertible?
20:40:58 <Elemir> Hem, *World in Clean not only unique, it's a linear. Because we can't forget a *World!
20:41:23 <mgsloan> elliott: I don't think it's that bad - particularly if it spews a warning at every usage site
20:41:53 <Elemir> Type of main is *World -> *World, so we must drag *World throw all program.
20:42:48 <elliott> Elemir: that doesn't make *World linear
20:42:57 <elliott> just means you don't have much choice but to use it linearly when you're writing main
20:43:05 <elliott> ok, they're observationally equivalent :P
20:43:49 <Elemir> All non-linear *World functions cannot be used in real program :3
20:45:05 <Elemir> But cause it will be better if compiler will check linearity not only uniqueness
20:45:43 <napping> What's different in wl-pprint-extras?
20:45:54 <elliott> napping: it has an "a"
20:46:05 <elliott> an effect type
20:46:08 <elliott> monadic
20:46:09 <elliott> wl-pprint-terminfo uses it to do ansi bold/colouring/etc.
20:46:35 <mgsloan> tkahn6: the idea is that you'd export Data.Conduit, Data.Conduit.V0_4_0_1 as a re-export, as well as Data.Conduit.V0_3_0, which would re-export the v0.3.0 subset, with function and type synonyms for any name changes.
20:46:38 <elliott> [This message approved by edwardk enterprises. Paid for by Haskellers for a Better America.]
20:46:45 <edwardk> mgsloan: the issue is that the confluence of compositions of convertible isn't decidable, also once you put in subtyping relationships like that everything decidable about type systems goes to hell
20:47:13 <mgsloan> edwardk: I'd only want it for monomorphic types
20:47:14 <napping> copying the module comment from wl-pprint was misleading
20:47:24 <elliott> No! It has a slightly different comment, I believe.
20:47:25 <mgsloan> yeah, I guess that is kinda ugly
20:47:28 <elliott> Slightly different.
20:47:47 <napping> having effects sounds nice, I think I used something like that to record offset
20:47:49 <edwardk> mgsloan: instance Coerce Int Byte; instance Coerce Byte String; instance Coerce Int String  -- if i coerce from Int to Byte first then to String i can get different answers than if i coerce from Int to String
20:47:54 <edwardk> thats the confluence concern
20:48:11 <napping> ah, a few extra things at the end of the list
20:48:13 <edwardk> so you can of course change it to only chain upcasts which preserve confluence, etc.
20:48:15 <napping> a pretty class too
20:48:24 <mgsloan> not being able to go polymorphic from your monomorphic variant would be worrisome.  Hrmm.
20:48:36 <tkahn6> edwardk: isnt that a problem in converting from the different integral types?
20:48:38 <edwardk> napping: wl-pprint-extras gives you a couple of combinators to track the current indentation level
20:48:46 <mgsloan> edwardk: couldn't you just define two for every pair of compatible types?  A lot of boilerplate, but aught to work
20:48:48 <edwardk> tkahn6: in general, yes
20:49:27 <tkahn6> edwardk: i see
20:49:28 <edwardk> mgsloan: its just not something we can 'flip on and forget about' try using it everywhere in your code and see how much stuff flips out because it can't default
20:49:43 <mgsloan> erp, for mine, since the data structures are ordered by version, we only have one per pair
20:49:59 <edwardk> mgsloan: remember, extended defauting won't fire in the presence of any uses of that, because its an MPTC
20:50:18 <edwardk> mgsloan: in practice this is what functions are for ;)
20:50:25 <mgsloan> edwardk: I'm aware.  I guess I want to be able to turn it on for pattern match sites
20:50:41 <mgsloan> (aware that you can't just slap in coercions)
20:50:43 <edwardk> mgsloan: view patterns
20:50:55 <mgsloan> yeah, I guess that's the correct answer
20:51:03 <mgsloan> I suppose that's good enough
20:51:17 <dmwit> ?ask notthemessiah Did you profile yeganesh? Is Read really to blame for the crappy performance?
20:51:17 <lambdabot> Consider it noted.
20:51:20 <mgsloan> and it only needs to be done by the bottom of the diamond in the cabal upper-bounds problem
20:51:41 <dmwit> Hm, I suddenly wonder...
20:51:45 <dmwit> ?tell DMWIT it works!
20:51:46 <lambdabot> You can tell yourself!
20:51:47 <napping> I guess I don't really need the generality yet
20:51:51 <dmwit> wonderful!
20:53:30 <Elemir> Hem
20:53:43 <mgsloan> edwardk: thanks! This means my post will consider this aspect
20:53:50 <Elemir> But
20:55:00 <dmwit_> o
20:55:00 <lambdabot> dmwit_: You have 1 new message. '/msg lambdabot @messages' to read it.
20:55:11 <Elemir> If I conctruct functor LR (as newtype LR a = LR a), hide a conctructor, so IO a -> LR (a, IO ()) can be logically safe, can't it?
20:55:26 <shapr> fallout is free this weekend on gog: http://www.gog.com/en/gamecard/fallout
20:55:37 <dmwit> shapr!!
20:55:46 <Elemir> or not…
20:56:04 <dmwit> Elemir: I'm not sure I understand the question.
20:56:15 <thlorenz> I am trying to change file permissions for ALL users … can't find the appropriate function. Asked on stackoverflow: http://stackoverflow.com/questions/10051582/how-can-i-set-file-permissions-for-all-users-from-haskell
20:56:22 <shapr> whoops, wrong channel, I meant to paste that on #haskell-blah!
20:56:45 <shapr> I should get some sleep...
20:56:46 <shachaf> Elemir: No, because you still need an "a" to construct the "LR".
20:56:52 <shachaf> Unless you do something unsafe like _|_
20:57:32 <dmwit> Ah, now I understand the question.
20:57:40 <dmwit> Depends on what operations you expose.
20:57:50 <dmwit> If you only expose the same operations that IO a exposes, you should be fine. =)
20:57:53 <shachaf> And on what you mean by "logically safe".
20:58:22 <sizz_> is Programming in Haskell --> Learn you a Haskell --> Real World Haskell   a) a good selection, and b) a sensible order in which to read these books?
20:59:50 <Elemir> dmwit: I'm trying to invent something like linear types but in haskell :3
21:00:22 <dmwit> Hm, I think one of my colleagues was trying to embed a linear type checker into functional dependencies.
21:00:45 <Elemir> Nice. How?
21:01:04 <dmwit> I dunno, and I can't Google things right now. =/
21:01:33 <dmwit> I do remember a rather stunning hour-long presentation that showed that there are things functional dependencies can do that type families can't.
21:02:04 <dmwit> You should start from Stephanie Weirich's page if you want to look for it manually; it was one of her students.
21:02:06 <Elemir> O_O. /me knows only cross depends
21:02:27 <lifestream> Hi sizz_, I'm new to Haskell myself, I'd recomend TryHaskell.org > LYAH > RWH. (I'm not sure about Programming in Haskell, I've not read it)
21:03:02 <shachaf> sizz: Programming in Haskell is a great introduction.
21:03:13 * Elemir recommends Scheme -> SML -> TAPL -> Haskell :3
21:03:23 <shachaf> sizz: If you have it handy I'd recommend it over most other introductory books I've seen.
21:03:29 <wollw> I'm reading LYAH right now and it's the only book I've used.
21:03:47 <shachaf> sizz: After you finish it you can probably skip a lot of LYAH, but maybe some parts are still useful.
21:03:51 <Elemir> Ou, I forgot `theory category for computer scientist'
21:03:56 <tkahn6> sizz: i found RWH to be boring and dry
21:04:09 <tkahn6> sizz: i've heard LYAH is good
21:04:36 <wollw> I like it so far.  I'm on chapter 7 (Modules).
21:04:40 <edwardk> elliott: > using (Monoid (+) 0) $ mappend mempty 12
21:04:56 <wollw> Knowing about currying and lazy evaluation before hand probably helped though...
21:05:10 <elliott> edwardk: neat
21:05:19 <sizz> thanks. i have a feeling that a bit of overlap with my learning resources might be useful!
21:05:32 <edwardk> elliott: the way thats done it takes about 8 lines to make a new class Reifiable
21:06:57 <tkahn6> sizz: i also recommend reading the typeclassopedia
21:07:16 <sizz> I like what I see of Haskell so far. The language itself seems very interesting and powerful. Plus there's a nice combination of community + libraries + documentation
21:07:27 <sizz> tkahn6: okay
21:09:49 <sizz> I'm coming from a Perl and R background. It's a shame that RWH gets such mixed reviews; I'd really like to have a Haskell 'cookbook'. I also think that this would be very useful for increasing the userbase (i.e. a pragmatic howto guide)
21:11:50 <lifestream> Haha :) "Linux doesn’t have an anti-virus program. Haskell doesn’t have a debugger." <3
21:12:21 <elliott> it does
21:12:29 <elliott> ghci hs
21:12:31 <elliott> has one
21:12:45 <elliott> and there are avs for linux too :p
21:13:02 <lifestream> Just reading an old blog post, interesting point nonetheless
21:13:24 <edwardk> sizz: RWH works well, if you havea solid background and are willing to puzzle through the errors in places
21:13:25 <elliott> sizz: rwh was good then its authors obsoleted it
21:13:36 <elliott> by making libraries
21:14:07 <mgsloan> * cough ECT' *
21:15:07 <elliott> mgsloan: that will not fix Text starting to exist
21:15:19 <elliott> making unicode ByteStrings obsolete
21:15:24 <sizz> maybe there'll be a new edition?
21:15:41 <elliott> i hear there will be
21:16:37 <mgsloan> elliott: You're probably right that there's been too much change, but could the unicode ByteStrings API potentially be defined as synonyms / trivial wrappers over stuff out of Text?
21:16:57 <sizz> i see that o'reilly have an errata page for RWH. Is it comprehensive?
21:17:04 <edwardk> mgsloan: unicode bytestrings and text have different usecases.
21:17:14 <edwardk> text in particular is quite bad at slicing up data
21:17:25 <mgsloan> ah
21:17:38 <edwardk> mgsloan: with a bytestring i can slice in O(1). with text its O(n)
21:17:55 <mgsloan> :/
21:18:05 <elliott> mgsloan: there was no unicde bytestring api
21:18:10 <elliott> that was the problem
21:18:12 <mgsloan> well I suppose that makes sense, you need to parse the unicode points
21:18:18 <edwardk> elliott: there was a utf8-string package, etc.
21:18:19 <elliott> sizz: doubtful
21:18:23 <edwardk> its just not easy to use
21:18:35 <elliott> read it after you know enough to write simple progs
21:18:39 <edwardk> mgsloan: well, you can do better if you are willing to add structure
21:18:47 <edwardk> mgsloan: i.e. i can make it O(log n)
21:18:50 <edwardk> and O(1) for ascii
21:18:53 <elliott> edwardk: did rwh use them?
21:19:01 <edwardk> elliott: not that i know of
21:19:05 <mgsloan> edwardk: yup, I've looked quite closely at trifecta :)
21:19:06 <elliott> right
21:19:26 <edwardk> mgsloan: well, trifecta doesn't bother speeding up anything but the current line
21:20:13 <edwardk> elliott: ok, i shipped 0.8
21:20:23 <edwardk> with the scary constraints example
21:20:30 <carter> edwardk: for a moment when reading the current chat I thought you guys were talking about bob harper
21:20:53 <carter> http://www.cs.cmu.edu/~rwh/
21:20:56 * hackagebot reflection 0.8 - Functional Pearl: Implicit Configurations  http://hackage.haskell.org/package/reflection-0.8 (EdwardKmett)
21:21:04 <edwardk> carter: i wonder what his errata would look like
21:21:22 <carter> it has a lot of thanks to many people
21:21:42 <carter> one of which is to me from when I was back in high school
21:21:42 <mgsloan> edwardk: but doesn't Delta represent line-deltas too?  So that you can use it as a monoid for the document's rope?
21:22:16 <edwardk> mgsloan: deltas do, but what i was talking about was i can support byte based indexing cheaply as well rather than just delta based indexing
21:22:23 <carter> http://www.cs.cmu.edu/~rwh/plbook/book.pdf
21:22:31 <edwardk> mgsloan: what you need is a tree that describes where the utf-8 tailbytes are
21:23:07 <carter> in the half decade since, its beefed up into a pretty nice pl theory text
21:23:16 <edwardk> mgsloan: then you can aggregate over that in O(log n) and use it to offset the character index into a byte inde
21:23:18 <edwardk> er index
21:23:36 <mgsloan> edwardk- yup! But you only need to store that in the leafs - just store the max index in the nodes
21:23:59 <edwardk> mgsloan: well, you don't want the rope structure to necessarily follow the structure of the tree
21:24:26 <edwardk> otherwise you need to clip your leaves to make them short when tail bytes are present
21:24:38 <mgsloan> yeah, you need to have the monoid represent if it's split across a codepoint
21:25:34 <mgsloan> s/represent if/store whether
21:25:46 <edwardk> in an old unreleased buffers package i have i tracked the utf8 tailbyte count in the leaf, then just didn't allow you to make a leaf longer than ~100 bytes which had a tailbyte in it
21:26:10 <edwardk> and used O(1) indexing on any missing them, and a slower scan for anything with them
21:26:26 <mgsloan> makes sense.
21:26:27 <edwardk> but that actually incurs a fair bit of overhead when someone gives you a big chunk at once
21:26:40 <zzing> I was just reading the 'golang faq' and ran into this: "Variant types, also known as algebraic types …"   some how that doesn't sound entirely accurate from my experience. What say you wise ones?
21:26:47 <edwardk> so i decided in the end that it was nicer to let the rope structure float completely independent of the tailbyte tracking
21:27:08 <mgsloan> edwardk: I've been considering implementing something like this for a Haskell document representation: http://hal.inria.fr/docs/00/44/59/75/PDF/icdcs09-treedoc.pdf
21:27:52 <mgsloan> I have a half-started treatment of crdts in a repository on my github
21:27:57 <edwardk> mgsloan: i should have some WOOT code lying around
21:28:52 <edwardk> http://hal.inria.fr/docs/00/07/12/40/PDF/RR-5580.pdf
21:28:52 <mgsloan> anyway, this'd allow for very pretty collaborative editing, and could still use all of the same monoidal annotations stuff
21:29:24 <edwardk> well, i've switched away from monoidal annotations ;)
21:29:51 <mgsloan> edwardk: looks cool!
21:29:52 <mgsloan> oh?
21:30:00 <mgsloan> using semigroup annotations now? ;)
21:30:10 <edwardk> nah, revisions
21:30:31 <edwardk> https://github.com/ekmett/revisions/blob/master/revisions.cabal
21:30:35 <mgsloan> is that to handle cacheing properly?
21:30:55 <edwardk> its a rather completely different idea
21:31:21 <edwardk> basically the notion is you get a monad (Rev s) that is like a concurrent form of ST
21:31:23 <elliott> edwardk: i'll try and dig up my old rewrite of reflection so you can see how hideous it is
21:31:57 <edwardk> with Rev when you make up a variable you specify a three way merge strategy for it, and you are allowed to fork and join
21:32:13 <edwardk> fork gives you a handle to a task, joining merges the changes from that task back in
21:32:25 <edwardk> each fork gets its own copy of the variables, they are resolved on join
21:32:51 <edwardk> but its a 3-way merge. so you get access to the least common ancestor as well
21:33:00 <mgsloan> hmm, interesting!
21:33:13 <edwardk> this lets you do things like compute a total with a 3 way merged variable that subtracts out their common ancestor to avoid double counting
21:33:40 <edwardk> and in and of itself this technique gets a pretty nice chunk of parallelism out of otherwise mostly sequential code with a few fork/join annotations
21:33:51 <edwardk> but there is a really fun thing you can do if you break the version control metaphor
21:34:21 <edwardk> and that is you can record a branching computation as you run it, so that you can replay it more efficiently in an edited context
21:34:22 <mgsloan> have you figured out a protocol for figuring out the lca over a distributed network?  This means both computers store the full history?  I guess that's irrelevant - the lca could be answered by a central server
21:34:40 <edwardk> record :: Rev s a -> Rev s (a, Rev s a)
21:35:00 <mgsloan> (distributed === we can't have a known topology / know anything about the patterns of clients pushing to eachother)
21:35:07 <edwardk> this is an in-process notion. i have another version i've been working on for checkpointing
21:35:40 <mgsloan> wow, that's pretty amazing.  Still working on groking it
21:35:48 <edwardk> i did figure out an asymptotic improvement in the known bounds of the online LCA algorithm while working on this though ;)
21:35:50 * elliott wonders what would happen if you transplant that back into version control
21:36:20 <edwardk> mgsloan: the idea is that your fork/join tree gives you information for use later during incrementalization
21:36:37 <edwardk> in particular if a branch only read from variables that didn't change its effects are easy to reuse
21:36:45 <edwardk> otherwise you need to break it apart and repeat the process
21:37:06 <Veinor> i think hackage should display a message when you're not looking at the latest version of a package
21:37:14 <elliott> edwardk: here: http://hpaste.org/55661
21:37:23 <elliott> edwardk: i think this actually forces the value you reify, it just needs a data Box a = Box a to fix it
21:37:28 <elliott> i've lost the original file so that's the only version i have
21:37:31 <edwardk> mgsloan: so if you take something like calculating css attributes, and then edit the layout of the page, the reflow will recycle many of the same calculations
21:37:40 <edwardk> and you get parallelism as well
21:37:41 <mgsloan> Veinor: That'd be neat - just make it a haddock flag
21:38:15 <edwardk> typically something like a 5x on 8 core parallelism boost, and a problem dependent incrementalization boost. often several x as well.
21:38:18 <mgsloan> edwardk: This is something I've been wanting for a while :) Thanks!
21:38:45 <edwardk> mgsloan: daan leijen, the font of all good things haskell came up with the original idea
21:39:17 <mgsloan> This can be used to make local updates to the structure more efficient too, right?
21:39:47 <mgsloan> in other words, if you express all of your updates in terms of merges
21:39:49 <edwardk> elliott: you didn't clean up your stable ptr!
21:40:05 <elliott> edwardk: wrong
21:40:08 <elliott> edwardk: i do it in the instance
21:40:22 <elliott> and since I seq the value, it's always done
21:40:29 <edwardk> ah
21:40:37 <elliott> except I should put the value in a Box first so it only runs the code and doesn't actually force the value... but like I said this is an older version
21:40:54 <edwardk> thats actually not terrible
21:40:57 <Veinor> mgsloan: i mean, it's more relevant in my opinion on hackage.haskell.org
21:41:06 <elliott> edwardk: wtf - have you SEEN it? :P
21:41:24 <Veinor> more than once i've googled 'haskell package' to find a package, wondered why the API wasn't working, only to find I was a major version behind
21:41:27 <elliott> ok, now I'll try and adapt something vaguely like that except not so horrendously unportable to the existing code
21:41:29 <edwardk> elliott: well, you could break it up further, into say, hex digits and it'd be smaller
21:41:37 <elliott> edwardk: more computation!
21:41:46 <elliott> edwardk: i tried to use datakinds nats first
21:41:49 <edwardk> depends
21:41:53 <elliott> but it turns out it doesn't work :(
21:42:00 <elliott> i.e. just lift addresses wholesale
21:42:13 <edwardk> not sure of the cost of reifyByte
21:42:20 <edwardk> that huge case may be quite expensive
21:42:39 <elliott> edwardk: well, it turns into a jump table
21:42:41 <elliott> i made sure of that
21:42:44 <edwardk> does it?
21:42:45 <edwardk> ok
21:42:46 <elliott> yes
21:42:48 <elliott> because i unbox it
21:42:50 <elliott> if i didn't it wouldn't
21:43:11 <elliott> which has to be one of the most low-hanging fruit optimisations ever, i have no idea why ghc doesn't do it
21:43:12 <edwardk> ah
21:43:55 <edwardk> next problem, your Address is huge ;)
21:44:03 <mgsloan> Veinor: Yeah, it's happened to me too.  There should be brightly colored messages on the documentation and package pages of old versions
21:44:16 <edwardk> hrmm
21:44:47 <edwardk> you don't need to writeStablePtrArray# you could just shift and mask
21:45:00 <edwardk> that'd avoid all the FreezeBytePtr silliness
21:45:09 <edwardk> er FreezeByteArray
21:45:25 <elliott> edwardk: you can shift StablePtrs?
21:45:33 <elliott> i did that as the equivalent to unsafeCoercing it to something integral
21:45:37 <edwardk> StablePtr can be cast to Ptr which can be cast to IntPtr
21:45:41 <elliott> well yeah
21:45:47 <elliott> but that'll end up doing the same thing, won't it?
21:45:48 <edwardk> which is a safe cast chain
21:45:51 <elliott> maybe a bit faster
21:46:23 <elliott> what's Word8's constructor again?
21:46:28 <elliott> W8#?
21:47:00 <edwardk> so benchmark it against the stock one so we can know if it helps =P
21:47:24 <elliott> edwardk: yeah, I'm "porting" the "ideas" to your codebase :P
21:47:28 <elliott> it involves a lot of CPP
21:47:34 <edwardk> heh
21:47:43 <elliott> btw what about 32-bit addresses? I guess there's a #define for that
21:47:53 <elliott> (what about other compilers?! ha ha, other compilers)
21:48:00 <edwardk> there are other compilers?
21:48:04 <elliott> ooh, I have no idea how to paste ## after a token in cpp
21:48:10 <elliott> oh wait i think i remember
21:49:49 <edwardk> mgsloan: anyways, daan has a nice couple of papers on the topic
21:50:13 <edwardk> mgsloan: but yes, updates to random variables in the form of merges is the main trick =)
21:50:37 <edwardk> mgsloan: though you can of course just compute with values in the monad and it'll do the right thing during merges as well
21:50:48 <edwardk> thats the major difference between my version and daan's is that you can join tasks that return values
21:51:10 <edwardk> (that and i spark rather than spawn IO threads, so you can just forget computations you don't need)
21:51:19 <elliott> grr, is there a ghc flag for "spit out what cpp spits out"?
21:51:46 <elliott> (btw, thanks for the explanation of this revisions stuff, I saw the code but thought I'd have no hope of understanding it -- now I'm thoroughly intrigued)
21:51:47 <edwardk> afk a bit
21:52:02 <edwardk> (unafk)
21:52:21 <edwardk> the main complexity is trying to do online LCA in sublinear time
21:53:16 <edwardk> to do that i calculate node identities in a rather novel way using a skew binary random access list of identities taken from a splittable variable supply
21:54:15 <edwardk> so basically a node id is a path of identities, and the common ancestor will be the longest shared tail of that path. so then all you need to do is do something that lets you cons onto the path in O(1) but check for a common tail in O(log n)
21:54:55 <edwardk> and then you can do online LCA in O(log n) lookup rather than O(n) lookup time
21:55:15 <zzo38> What are they called, something like an endofunctor in Haskell, but (x -> x) -> y -> y instead of having the type parameter? It seems to be something like a functor from one subcategory of (->) to another one? But even then, this is something more specific
21:55:17 <edwardk> its not as good as the offline algorithm where it can be O(n) preprocessing O(1) lookup
21:56:10 <elliott> what the heck? does a##b not work with ghc cpp?
21:56:28 <elliott> it's just spitting out a##b again
21:56:47 <zzo38> I did write another preprocessor Hampp which is meant for use with Haskell; but even that if there are some problems please fix it
21:57:51 <elliott> well this is bizarre
21:58:24 <edwardk> zzo38: well, here the goal isn't to require any more extensions or external tools than strictly necessary
21:58:52 <elliott> oh, so this trifecta dependency is right out then
21:59:01 <edwardk> elliott: =P
21:59:02 <zzo38> edwardk: Well, CPP is just bad for Haskell in general
21:59:04 <elliott> i was going to use it to parse the stableptr on the other end!
21:59:14 <edwardk> zzo38: but always there
21:59:23 * kallisti doesn't understand the "danger" of CPP.
21:59:32 <zzo38> edwardk: OK
21:59:47 <zzo38> kallisti: CPP is not bad for C; it is bad for Haskell and most other programming languages which aren't C.
21:59:56 <zzo38> edwardk: Maybe you know the answer to my first question?
21:59:58 <elliott> ok seriously, #define CAT(a,b) a##b
22:00:00 <elliott> CAT(what,thehell)
22:00:04 <elliott> --> what##thehell after preprocessing
22:00:08 <edwardk> zzo38: it doesn't really have a good name
22:00:13 <elliott> this can't be cpp
22:00:26 <edwardk> elliott: what about a ## b
22:00:29 <elliott> oh, it's passing -traditional... I forget what that changes
22:00:39 <elliott> edwardk: "what ## thehell"
22:00:45 <edwardk> fun
22:00:49 <zzo38> elliott: Can you remove the -traditional option?
22:00:55 <scientes> what the #&%!
22:01:01 <edwardk> just bang out a few lines of perl and include the generator script
22:01:10 <elliott> "The ISO stringification operator `#' and token paste operator `##' have no special meaning. As explained later, an effect similar to these operators can be obtained in a different way. Macro names that are embedded in quotes, either from the main file or after macro replacement, do not expand."
22:01:21 <elliott> you have to do
22:01:24 <elliott> #define CAT(a,b) a/**/b
22:01:59 <zzo38> edwardk: It doesn't have a good name? A name should be made up
22:03:15 <edwardk> zzo38: its a morphism between the exponentials of two endomaps or something like that
22:03:34 <zzo38> edwardk: Yes, it is something like that, but that name is too long
22:03:48 <edwardk> hence why i said it doesn't have a good name ;)
22:04:07 <elliott> ok, reifyByte is done, now for the ugly parts
22:04:08 <dmwit> Wait, does a/**/b parse as the identifier ab?
22:04:09 <zzo38> Is it possible to make up the good name by taking the first letters of the words?
22:04:16 <dmwit> > let a{--}b = 3 in ab
22:04:17 <lambdabot>   Not in scope: `ab'
22:04:45 <dmwit> (Obviously Haskell is not C, but if that works in C that's just pathological.)
22:05:02 <elliott> dmwit: Not in C.
22:05:05 <elliott> But in traditional cpp.
22:05:15 <elliott> In C, comments are whitespace.
22:05:18 <dmwit> what is traditional cpp
22:05:55 <elliott> How cpp used to act in the 80s, before civilisation began.
22:06:30 <shachaf> When did civilization begin?
22:06:41 <zzo38> shachaf: 42
22:06:53 <zzo38> (I don't mean the year 42)
22:06:55 <shachaf> zzo38: O, now I see.
22:07:22 <elliott> > 1 `shiftL` 1
22:07:22 <lambdabot>   Ambiguous type variable `a' in the constraint:
22:07:22 <lambdabot>    `Data.Bits.Bits a'
22:07:22 <lambdabot>      a...
22:07:25 <elliott> > 1 `shiftL` 1 :: Int
22:07:25 <lambdabot>   2
22:07:27 <elliott> > 1 `shiftR` 1 :: Int
22:07:27 <lambdabot>   0
22:07:39 <elliott> edwardk: what's your favourite endianness?
22:08:58 <zzo38>  
22:09:15 <dmwit> elliott: what is cpp, is that C++ or C pre-processor? If the pre-processor, then what does that have to do with how a/**/b parses?
22:10:08 <shachaf> dmwit: Presumably it has a lot to do with it?
22:10:14 <elliott> dmwit: latter
22:10:17 <shachaf> The question is whether it turns it into "a b" or "ab".
22:10:18 <elliott> and because it's done while preprocessing
22:10:27 <elliott> see http://gcc.gnu.org/onlinedocs/cpp/Traditional-macros.html#Traditional-macros
22:10:29 * shachaf has no idea what the question is.
22:10:34 <shachaf> I didn't read any of the context.
22:10:35 <dmwit> Wait, the traditional C preprocessor strips comments?
22:11:12 <elliott> The C preprocessor strips comments, yes.
22:11:15 <elliott> Even non-traditionally.
22:11:21 <DijkstraGroupie> Is there any standard function that takes an integer distinct than 0, and returns another integer with the same sign and whose absolute value is one less that the input?
22:11:51 <dmwit> elliott: owie, my separation of concerns =/
22:12:05 <DijkstraGroupie> I mean, if x > 0, then pred x, if x < 0, then succ x.
22:12:12 <dmwit> DijkstraGroupie: no
22:12:21 <DijkstraGroupie> dmwit: Okay, thanks.
22:12:37 <edwardk> elliott: little
22:12:40 <dmwit> DijkstraGroupie: However, if you're wishing for this because you're doing a conversion from a non-integral type, you may be using the wrong conversion.
22:12:54 <dmwit> DijkstraGroupie: There are at least four: floor, ceiling, round, and truncate
22:13:05 <DijkstraGroupie> dmwit: I am not manipulating nonintegral types.
22:13:09 <elliott> edwardk: hmm, does your code properly clean up the StablePtr if the function ignores it?
22:13:11 <dmwit> okay
22:13:15 <edwardk> elliott: yeah
22:13:20 <edwardk> i force the stable ptr first
22:13:23 <edwardk> see 'reflectBefore
22:13:25 <elliott> right
22:13:38 <NihilistDandy> DijkstraGroupie: What happens when it's equal to 0?
22:13:52 <DijkstraGroupie> NihilistDandy: The function will not be called.
22:13:57 <dmwit> NihilistDandy: i happens
22:14:03 <DijkstraGroupie> NihilistDandy: I am implementing a modified fast exponentiation algorithm.
22:14:18 <dmwit> NihilistDandy: Whether i or -i happens depends on whether you call the function on 0 or -0, of course.
22:14:19 <NihilistDandy> DijkstraGroupie: So why not if x > 0 then pred x else succ x?
22:14:26 <NihilistDandy> dmwit: Obviously. :D
22:14:39 <zzo38> f x = bool pred succ (x > 0) x;
22:14:51 <zzo38> f x = bool succ pred (x > 0) x;
22:15:02 <dmwit> Yes, thank you everybody, I'm sure DijkstraGroupie knows how to implement this function...
22:15:13 <shachaf> f x = pred bool succ (x ≫ 0) x;
22:15:30 <elliott> @hoogle Word8 -> IntPtr
22:15:30 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
22:15:30 <lambdabot> Control.OldException throwDyn :: Typeable exception => exception -> b
22:15:30 <lambdabot> Foreign.Ptr ptrToIntPtr :: Ptr a -> IntPtr
22:15:40 <elliott> Okay, it'll use unsafeCoerce. Thanks, lambdabot!
22:15:43 <elliott> *I'll
22:16:02 <NihilistDandy> Perfect code always with the magic of unsafeCoerce
22:16:38 <DijkstraGroupie> I have the following function: http://hpaste.org/66538
22:16:55 <DijkstraGroupie> I hate it when I define a function that looks like fun n = f $ g $ h n
22:17:07 <DijkstraGroupie> I would much rather use fun = f . g . h
22:17:15 <DijkstraGroupie> But n is needed in the where clause.
22:17:58 <elliott> edwardk: come to think of it, wouldn't quotRem be faster than masking and shifting?
22:18:15 <elliott> oh, probably not
22:18:49 <edwardk> elliott: this is why you need a benchmark =)
22:19:09 <elliott> yeah :p
22:19:17 <dmwit> I have a benchmark! It says my name and making it was probably illegal.
22:19:45 <NihilistDandy> dmwit: Depends on the font
22:20:28 <shachaf> @remember luite I think it uses levenshtein distance (he invented this distance because nobody could spell his name correctly)
22:20:28 <lambdabot> I will remember.
22:21:24 <elliott> woot, it works
22:22:22 <tkahn6> can y'all recommend a good parsec tutorial?
22:23:18 <zzo38> " a morphism between the exponentials of two endomaps" prehaps shorten it to "mobex" or something like that?
22:23:25 <zzo38> tkahn6: Do you know applicatives?
22:23:54 <tkahn6> zzo38: you mean like the type class?
22:23:57 <dmwit> tkahn6: The official one is good.
22:24:09 <tkahn6> dmwit: which one is that :p
22:24:32 <zzo38> tkahn6: Yes. Parsec is parsing using applicative; you can use monad as well but it is rarely useful to use Parsec with monads.
22:24:50 <dmwit> ?google parsec haskell
22:24:52 <lambdabot> http://www.haskell.org/haskellwiki/Parsec
22:24:52 <lambdabot> Title: Parsec - HaskellWiki
22:25:19 <dmwit> eh, ?google always fails me, yet my browser's I'm Feeling Lucky thing succeeds like 80% of the time
22:25:28 <zzo38> Usually it is work with applicatives
22:25:58 <tkahn6> dmwit: u mean the paper on parsec?
22:26:09 <hpaste> elliott pasted “uuuuuugh” at http://hpaste.org/66540
22:26:13 <elliott> now to benchmark it!
22:26:37 <dmwit> No, I'm thinking of a piece of HTML documentation.
22:26:49 <dmwit> If my box wasn't completely broken right now I'd just link you.
22:27:16 <zzo38> I have used Parsec so I know Parsec and can help with some question possibly.
22:27:20 <DijkstraGroupie> What looks less ugly to you: http://hpaste.org/66538 or http://hpaste.org/66539 ?
22:27:26 <elliott> edwardk: i like how in a day reflection has gone from "MPTCS + fundeps + rank-2 types + flexible instances" -> "rank-2 types" -> "rank-2 types + type families" -> "GHC"
22:27:31 <elliott> (last step tentative)
22:27:37 <edwardk> =P
22:27:51 <elliott> surprisingly GHC actually compiles this module in under a second
22:28:13 <tkahn6> edwardk: what does that do?
22:28:16 <tkahn6> or elliot
22:28:23 <edwardk> tkahn6: reflection?
22:28:30 <tkahn6> yeah
22:28:38 <edwardk> reify takes a term and makes a type out of it, then reflect lets you get it back down
22:28:57 <elliott> ...which means you can have things like instances that depend on runtime values
22:29:28 <edwardk> tkahn6: for instance
22:29:29 <edwardk> https://github.com/ekmett/reflection/blob/master/examples/Monoid.hs
22:29:30 <tkahn6> so you can lift values into the type sytem at runtime?
22:29:42 <zzo38> I looked at the codes but still cannot quite understand how that can possibly work
22:29:51 <edwardk> this lets you make a new monoid type dynamically using an operation and a unit you have lying around at runtime
22:29:54 <elliott> tkahn6: sort of -- you never get to find out what the "type" actually is
22:29:59 <elliott> it's just a token, basically
22:30:13 <elliott> zzo38: well, you can turn any Haskell value into an integer and back
22:30:23 <elliott> because you can put it in a StablePtr, and convert that to an integer and back
22:30:31 <edwardk> zzo38: do you accept that you can lift a number to a type? reifyInt :: Int -> (forall a. AnInt s => Proxy s -> r) -> r ?
22:30:54 <elliott> (where class AnInt s where getTheInt :: Proxy s -> Int)
22:31:01 <dmwit> hm, actually... that would be handy in my edit-lenses library
22:31:02 <elliott> (ok reflectInt)
22:31:10 <edwardk> zzo38: then all you have to do is make a stable pointer, convert that to an integral value since a stableptr can be cast to a ptr which can be cast to an intptr, and vice versa
22:31:17 <dmwit> I guess I have an answer to my poo-pooing question from earlier.
22:31:46 <edwardk> dmwit: did you bash it earlier? i missed it
22:31:57 <elliott> he asked whether it was such a pain to just carry an environment around
22:32:08 <elliott> i pointed out that you'd have to rewrite every typeclass to plumb an environment :p
22:32:18 <edwardk> dmwit; my major application is that given a state machine transition diagram i can make an instance of a monoid for tabulations of that state machine
22:32:31 <edwardk> elliott: plus you can't always do it. you get different strictness properties
22:33:19 <tkahn6> edwardk: the goal being to load the FSM representation in at runtime and have it generate for you a type based on that?
22:33:28 <edwardk> newtype M a = M (Monoid_ a -> a) has different properties than newtype M a s = M a
22:33:51 <tkahn6> i guess i've never thought about the corrospondance between monoids and state machines
22:34:00 <edwardk> tkahn6: yeah, that way each machine yields a tabulation monoid with a different type
22:34:30 <edwardk> so you can't try to mix and match, and don't need to worry about screwing up and connecting things from different machines
22:34:37 <tkahn6> that is pretty cool
22:34:51 <zzo38> OK
22:35:07 <dmwit> newtype M a = M (Monoid_ a -> a); newtype M' a s = M' a; does M a really have different properties than WhateverClass s => M a s?
22:35:13 <edwardk> consider a tabulation of state machine transitions for a given label. .e.g. what happens to the machine when you see an 'a'. you go from say state 1 to state 2, but stay in state 2 if you were there, etc.
22:35:32 <tkahn6> edwardk: k
22:35:37 <edwardk> dmwit: yes, because the instance gets hoisted out over all sorts of lambdas for you
22:35:51 <elliott> dmwit: ehm
22:35:52 <dmwit> aha
22:35:54 <elliott> where do you get mempty from?
22:35:57 <elliott> oh
22:35:58 <elliott> duh
22:36:17 <edwardk> tkahn6: then what we can do is make an array with an element for every state, which stores the new state number.
22:36:29 <edwardk> tkahn6: so mempty is just the array which maps every state to itself
22:36:56 <elliott> ok, time to remember how to use criterion
22:37:04 <edwardk> and 'a' is the array that indicates what happens to your states when you see an input 'a'. then you can compose these tabulations, the composition is associative, and it forms a monoid
22:37:19 <dmwit> Argh, I made two different type names so I could ask my question properly and then didn't even use the two type names in my question.
22:37:51 <tkahn6> ah like a caylay table?
22:37:55 <zzo38> I had a different idea for runtime values in types in Ibtlfmm (we should make up the Ibtlfmm working group), like this:   f x y = g (x :: T {y});   or whatever; if you use { } around a value expression to make a type, and its kind becomes the type of that value with { } around it
22:38:11 <edwardk> tkahn6: exactly
22:38:18 <tkahn6> edwardk: awesome!
22:38:31 <edwardk> tkahn6: you can then recognize a regular expression with the DFA for it monoidally
22:38:37 <edwardk> tkahn6: so you can parse in parallel
22:38:57 <zzo38> And yes I can see how you can make a state machine monoid like that now
22:39:01 <edwardk> tkahn6: similarly you can match up certain forms of visibly pushdown automata
22:39:12 <tkahn6> is that related to arrows?
22:39:37 <edwardk> tkahn6: so you can recognize any dyck language as well
22:39:39 <zzo38> Is it possible to make a category transformer lens type?
22:40:07 <dmwit> Just read about visibly pushdown automata. Can't say they seemed very useful for real (programming) languages, though, unless you separately had a parser for the non-visible version of the language.
22:40:11 <edwardk> zzo38: tricky because of the exponential it uses
22:40:34 <zzo38> Probably it cannot be a real category transformer because you cannot always lift a morphism, but just in case you could have a category as a type parameter
22:40:42 <tkahn6> so that is pretty cool, the parallel regex matching
22:40:58 <edwardk> dmwit: they can be quite useful. i pull out the VPL spine of my language which covers ()'s {}'s if..else, even haskell style layout under a sufficiently liberal interpretation, then parse within those blocks
22:41:18 <dmwit> Ah, that's cute.
22:41:24 <dmwit> I like that trick a lot.
22:41:36 <edwardk> dmwit: in particular the layout structure of a haskell style language is entirely determined by the VPL skeleton
22:41:58 <edwardk> so even if your entire language isn't parseable that way knowing the layout is determinable by VPL permits you a fair bit of parallel parsing
22:41:59 <dmwit> Can you say a tad more about layout being visible?
22:42:24 * elliott installs criterion
22:42:41 <zzo38> Please complain about dvi-processing if you want to
22:42:53 <edwardk> well, technically haskell layout i think fails subtly, but you can simplify it slightly and get something that can be parallel parsed
22:43:12 <edwardk> i haven't revisited full haskell layout in a while though
22:43:24 <elliott> haskell layout is kinda icky anyway
22:43:40 <dmwit> I wouldn't mind hearing the story for a simplified layout scheme.
22:43:45 <elliott> yay, cabal-install wants to reinstall everything
22:43:48 <edwardk> dmwit: lets take a step back for a second and go with the notion of a dyck language
22:43:57 <zzo38> I dislike Haskell layout; so Ibtlfmm omits layout, do-notation, and if/then/else.
22:43:58 <clinton> I'm coming from a C++ background here, is it correct to say that haskell does no "implicit" conversions (aside ones from constant ints etc)?
22:43:58 <edwardk> where you have paired opening and closing contexts
22:44:03 <edwardk> this should sound very VPL like ;)
22:44:14 <zzo38> What does VPL like mean?
22:44:15 <dmwit> Yes, matching parens is clearly VPL.
22:44:18 <elliott> clinton: yes (and even constant literals are not implicitly converted)
22:44:22 <elliott> clinton: they are actually just polymorphic
22:44:30 <elliott> i.e. 42 isn't converted to anything, it just can take any numeric type
22:44:34 <edwardk> http://www.cs.uiuc.edu/~madhu/vpa/
22:44:39 <dmwit> zzo38: visibly-pushdown language; it means the token you're parsing says whether it's going to push something on the stack, pop something off the stack, or not change the stack
22:44:55 <dmwit> (the pushdown automata stack, that is)
22:45:13 <edwardk> dmwit: did you ever see sigfpe's short post on recognizing parentheses monoidally?
22:45:31 <tkahn6> i'm taking a class on comparitive languages at university, on the exam was a question which was "which is more useful in day-to-day programming implicit type coercian or type inference"
22:45:39 <edwardk> dmwit: http://blog.sigfpe.com/2009/01/beyond-regular-expressions-more.html
22:45:39 <clinton> elliott: Can I make other things polymorthic? i.e, can I make a nullary function "fourtytwo" which I can replace the literal 42 with anywhere?
22:45:39 <dmwit> Forget the monoidal stuff, that's interesting but doesn't seem hard once you've got a VPL. =P
22:45:51 <elliott> clinton: No such thing as a nullary function.
22:45:53 <tkahn6> and the answer that the professor wanted was type coercion
22:45:56 <elliott> You can define your own polymorphic stuff, yes.
22:45:58 <tkahn6> :/
22:46:00 <zzo38> tkahn6: I think it depends on the programming language
22:46:04 <clinton> elliott: fourtytwo = 42 I guess would work yes?
22:46:04 <elliott> And fortytwo :: (Num a) => a; fortytwo = 42
22:46:11 <NihilistDandy> tkahn6: That's an awfully subjective question.
22:46:13 <elliott> Yes, you'll need the type signature though due to the dreaded monomorphism restriction
22:46:20 <elliott> If this sounds like I'm making stuff up, just pretend I am
22:46:21 <edwardk> dmwit: sure, but the key concern was that my monoid was a series of unmatched closing contexts, followed by a series of unmatched opening contexts
22:46:23 <edwardk> ))))(((((
22:46:40 <edwardk> this can of course be extended with multiple closing and opening context types
22:46:40 <tkahn6> yeah i said to him "this depends on the language and what i'm trying to achieve" and he was like "we covered what the answer is supposed to be in the review session"
22:46:55 <dmwit> yep
22:47:06 <NihilistDandy> Tell him to reword the question in the future :D
22:47:12 <elliott> tkahn6: lol
22:47:23 <edwardk> )))]])([[  +  ]]((( = ...
22:47:25 <NihilistDandy> "WHAT DID I TELL YOU WAS THE MOST IMPORTANT THING TO DAY-TO-DAY PROGRAMMING?"
22:47:35 <elliott> "SHOUTING"
22:47:42 <dmwit> )))]])((((, I suppose
22:47:45 <elliott> lets the computerk now you're serious
22:48:13 <NihilistDandy> AKA THE FORTRAN METHOD
22:48:14 <tkahn6> NihilistDandy: if i thought he was the type of professor to listen to his students like that, i would have suggested it to him, but i got the impression it just would have pissed him off to press the point
22:48:30 <edwardk> dmwit: now take layout and add a couple of extra opening contexts for it, a braced layout and an unbraced layout context
22:48:42 <tkahn6> so i wrote down the answer he wanted and put a 'but in my opinion' at the end
22:48:54 <dmwit> edwardk: That step is beyond me, still, I think.
22:49:04 <NihilistDandy> Lame
22:49:26 <edwardk> in addition to (' and {' you now have 'indented 8'
22:49:40 <NihilistDandy> You should have just written the answer you wanted, killed his dog, and used his grief over the event to delay correcting the exam until the semester's over~
22:49:46 <edwardk> (you can recycle the explicit { for braced layout)
22:49:52 <dmwit> edwardk: Do you have a preprocessor that does the "indentation -> how many in steps of layout" stuff?
22:49:58 <edwardk> dmwit: no
22:50:12 <edwardk> its accumulated in the monoid as you go
22:50:16 <dmwit> Okay. Then what are the tokens?
22:50:27 <clinton> elliott: I got caught out not using "liftIO" for monads. I guess I was assuming that the monad I was using was convertable to IO, so I didn't think about doing it. What are the reasons for not having implicit conversions in haskell (I'm sure there are good ones, I'm just interested regarding what they are)?
22:50:31 <tkahn6> NihilistDandy: of course! why didnt' i think of that
22:50:37 <zzo38> I have made a preprocessor for Haskell. It might not do exactly what you need; it does not support layout
22:50:58 <elliott> clinton: Messes up type inference and pretty much anything with the word "type" in it.
22:51:06 <elliott> clinton: Basically fundamentally in opposition with Haskell's design goals.
22:51:10 <NihilistDandy> tkahn6: Really, he just wanted to see how resourceful you were. Your reaction to the question was the real test.
22:51:15 <edwardk> i'll give you a token for the indentation level at the beginning of each line as you go, once the (  )'s around you collapse enough that its forced to be unambiguous those get smashed down to spaces, virtual semicolons and outdents
22:51:16 <NihilistDandy> lol
22:51:19 <tkahn6> hahaha
22:51:25 <elliott> clinton: In this case, your mistake is to assume that what you want is a "conversion" to IO... if anything, it would be a conversion from IO.
22:51:29 <elliott> clinton: But what you actually want is a lift.
22:51:49 <elliott> Lots of languages muddle lots of different functions under the guise of "conversion"/"coercion". (For instance, (int)myFloat in C-like languages.)
22:51:57 <elliott> Haskell tries to name them what they are instead.
22:52:15 <edwardk> basically your dyck language expands to have unparsed stuff between the contexts ..)…]…{..(…    + …)… =
22:52:22 <dmwit> edwardk: Oh! Your alphabet/grammar is largish, then, huh? Like infinite-ish.
22:52:47 <elliott> "Largish? Like, pretty infinite?"
22:52:54 <elliott> "I'd say it's about 3/4ths infinite."
22:53:02 <edwardk> which is why i care so much about the distinction where applicatives are context sensitive but only for finite alphabets ;)
22:53:25 <tkahn6> "We talking rational numbers infinite or integers infinite"
22:53:48 <edwardk> depends on how you view this
22:54:04 <elliott> tkahn6: You... realise those sets have the same cardinality, right?
22:54:09 <elliott> Just checkin' :P
22:54:28 <edwardk> my original goal when playing with this was to run the vpl skeleton over a simple lexing monoid, then let it feed into a locally context sensitive parser
22:54:55 <edwardk> in practice i've found that it works pretty well to just sprinkle error productions through my grammar in a way that i can use the trick from my original trifecta talk
22:55:05 <edwardk> and not bother with all this ;)
22:55:08 <elliott> Couldn't match type `b0' with `Int' `b0' is untouchable inside the constraints (Old.Reified s, Old.Reflected s ~ Int)
22:55:09 <NihilistDandy> Well, elliott, do you mean integers infinite, or more like even integers infinite?
22:55:11 <elliott> that's a new one...
22:55:39 <edwardk> since then i've gone even farther and started just looking at using the record feature of the revision control monad and using a packrat parser that uses a revision controlled symbol table as it parses
22:55:44 <edwardk> because it doesn't require anything strange at all
22:55:58 * hackagebot cereal-conduit 0.0.4 - Turn Data.Serialize Gets and Puts into Sources and Sinks  http://hackage.haskell.org/package/cereal-conduit-0.0.4 (MylesMaxfield)
22:55:59 <elliott> edwardk: any idea what that's about? oh, I think criterion's types are messing it up
22:56:02 <elliott> grr
22:56:03 <edwardk> rather i should say 'locally packrat'
22:56:06 <zzo38> Recently I have thought of a much simpler instance disambiguation system than what I have previously proposed. It is now as follows: * Instances can be hidden from import and export if specified using "hiding". * Instances defined in current module override instances imported.
22:56:34 <edwardk> elliott: not sure without context
22:56:50 <edwardk> zzo38: if you permit hiding of instances you lose confluence
22:56:57 <elliott> nf :: NFData b => (a -> b) -> a -> Pure
22:56:58 <zzo38> * Instances can be given explicit priorities, to make high priority instances override low priority instances. * Overridden instances do not affect calling imported functions unless that class is mentioned in the constraint of its type signature.
22:56:59 <elliott> and i'm doing: nf (map (\x -> Old.reify x Old.reflect)) [1..100000 :: Int]
22:57:05 <elliott> I guess the problem is that nf isn't allowed to "peek" at b
22:57:09 <elliott> because it's being guarded by a forall
22:57:10 <zzo38> edwardk: I wasn't finished; now I am finished.
22:57:32 <zzo38> *Now* you can tell me if you still think so or not
22:57:54 <tkahn6> elliott: hmm TIL rational numbers have the same cardinality as the integers
22:58:17 <NihilistDandy> Now the reals on the other hand...
22:58:21 <edwardk> zzo38: the problem is what happens when you call a local polymorphic function that then calls an imported function?
22:58:24 <edwardk> same problem
22:58:32 <elliott> tkahn6: Did you know that 2^S has greater cardinality than S for any S???
22:58:38 * elliott cardinality facts!
22:58:53 <tkahn6> elliott: that makes sense
22:59:03 <dmwit> Lots of things that make sense are false.
22:59:08 <zzo38> edwardk: Can you give an example of what being wrong?
22:59:21 <tkahn6> but then again, i've never studied this stuff
22:59:25 <dmwit> For example, you might thing that S x S has greater cardinality than S for any S makes sense.
22:59:53 <zzo38> There is already extensions for incoherent instances and that stuff; my proposal is a bit different
23:00:10 <edwardk> zzo38: foo :: Ord a => [a] -> [a]; foo = toList . Set.fromList; now your code calls foo
23:00:16 <tkahn6> dmwit: i suppose i could intuit both sides of tha argument
23:00:21 <edwardk> foo will pass along the Ord instance its given to Set
23:00:46 <edwardk> confluence is sneaky
23:00:55 <zzo38> edwardk: No; since the constraint says (Ord a) not (Ord Set)
23:01:13 <edwardk> Set.fromList uses the Ord instance
23:01:39 <hpaste> elliott pasted “speed” at http://hpaste.org/66544
23:01:43 <elliott> edwardk: ^
23:02:04 <elliott> that's like *almost twice as fast*!!!!!!
23:02:05 <elliott> 111
23:02:09 <edwardk> elliott: damn you
23:02:09 <edwardk> =)
23:02:27 <edwardk> at the expense of going completely non portable
23:02:28 <edwardk> yeah
23:02:42 <elliott> hey, it can be portable to multiple architectures
23:02:49 <edwardk> as long as they are al ghc ;)
23:02:53 <elliott> (and /technically/ it could be hidden behind __GLASGOW_HASKELL__...)
23:02:56 <elliott> (but i wouldn't recommend it)
23:03:02 <elliott> anyway actually not much of this is unportable
23:03:03 <edwardk> elliott: i'm kinda going there =)
23:03:10 <zzo38> edwardk: Well, yes, it would use that Ord instance for (a) passed on. I can see the problem but I think it could still be used
23:03:10 <edwardk> anything with a # in it ;)
23:03:15 <elliott> edwardk: well
23:03:22 <elliott> edwardk: that's not actually required, it's just an optimisation to make it into a jump table
23:03:31 <zzo38> (Like I have said, there are already extensions which override existing instances, but not in a very good way)
23:03:32 <elliott> it needs to know how big a pointer is in bytes, and it wants to unbox one function for speed
23:03:35 <edwardk> zzo38: well, once you let this cat out of the bag, you start getting Set Int's floating around sorted different ways
23:03:37 <elliott> other than that it's completely portable
23:04:02 <edwardk> zzo38: and they are also a bad idea to use. overlapping instances rarely does what you want and often leads to bad bad things
23:04:20 <elliott> edwardk: i'm going to play around some more to try and eke some more performance out of this monster
23:04:25 <edwardk> elliott: have an hpaste or code?
23:04:29 <edwardk> k
23:04:40 <elliott> edwardk: I did
23:04:46 <elliott> http://hpaste.org/66540
23:05:00 <zzo38> edwardk: I know. I can see that; but it won't seem to actually do that in most cases
23:05:14 <edwardk> zzo38: sounds like you'd love scala
23:05:39 <edwardk> zzo38: scala lets you pass around implicits for everything. and consequently its hell
23:06:58 <zzo38> Often I find, existing classes and existing instsances are bad and I want to override them
23:07:00 <elliott> edwardk: btw reifyIntegral/reflectNum is slow as heck in 0.8 for this tset
23:07:01 <elliott> test
23:07:12 <elliott> compared to even reify/reflect
23:07:16 <zzo38> And to make two classes to correspond to each other for use with other program that use one instead of another
23:07:19 <edwardk> elliott: good to know
23:07:21 <elliott> i don't think your current representation scales at all compared to the constant StablePtr overhead
23:07:33 <zzo38> And I don't know any other way to fix this
23:07:38 <edwardk> zzo38: that is what newtypes are for
23:08:16 <zzo38> edwardk: That can be used with instances; but then you have all the functions you have to adjust to use them, and also that doesn't work with classes it is for instances only
23:08:18 <edwardk> zzo38: you run into that in about 10-20% of your code, but the confluence guarantees help in the remaining 80-90%
23:08:36 <edwardk> you can always use the constraints package ;)
23:08:49 <elliott> edwardk: old reify/reflect: 190ms, old reifyIntegral/reflectNum: 915m2
23:08:50 <elliott> *ms
23:08:59 <elliott> for map (\x -> Old.reifyIntegral x Old.reflectNum) [1..100000] to NF
23:09:02 <edwardk> elliott: good. now i can kill em =)
23:09:07 <elliott> yeah
23:09:15 <elliott> ok, back to optimising :P
23:09:21 <edwardk> elliott: that makes it a lot less painful to put yours behind a big #ifdef
23:09:25 <zzo38> For example, existing Alternative IO and MonadPlus IO instances are no good
23:09:47 <zzo38> And the existing Monad class is also no good
23:10:02 <elliott> edwardk: i'm worried about how to find out the size of pointers at compile-time but i have an idea that might make it portable to any size of pointer without any #ifdefs
23:10:17 <edwardk> elliott: well, we can assume none are bigger than 8 bytes for now
23:10:29 <elliott> edwardk: have "packed" types for 4 and 8 bytes, and a type-level linked list; use sizeOf to determine which to use
23:10:35 <elliott> or that would work yeah :p
23:10:50 <edwardk> a little extra overhead on 32 bits is kinda trivial
23:10:59 <elliott> edwardk: well in that case all you need is an ifdef around a single function
23:11:01 <elliott> (reifyByte)
23:11:09 <edwardk> *nods*
23:11:45 <elliott> oh, ouch, my implementation is a bit broken
23:11:48 <elliott> easy to fix
23:11:59 <elliott> (the stable pointer deref/free is hidden behind the lambda)
23:12:03 <zzo38> And I don't know how to fix all of these things while remaining compatible with everything else; you could use newtype but that requires changing almost every function in every library if you want to use it like the other things, and then you have to change them even more when changing the classes too
23:12:30 <elliott> actually i'm not sure how to fix that, since I need the Proxy to dereference it
23:12:32 <qiuhw> Hi, I have problem install cabal-install.
23:12:36 <qiuhw> It keeps complain "ld: cannot find -lgmp".
23:12:38 <elliott> I could make the class member use Tagged instead
23:12:45 <elliott> and define reflect as a Proxy-based wrapper
23:13:05 <edwardk> elliott: i used the lambda itself
23:13:15 <qiuhw> Of course libgmp is installed for GCC requires libgmp to be installed.
23:13:16 <elliott> oh, that's smart
23:13:26 <edwardk> type the of (Proxy s -> …) gives me the info i need to extract s
23:13:45 <qiuhw> I don't have root priviledge, so I installed a different version of gcc and libgmp in my own folder. I have set LD_LIBRARY_PATH correctly, and even tried to set LDFLAGS, but without lucy.
23:13:55 <edwardk> elliott: thats what reflectBefore uses
23:14:23 <zzo38> For example, I want to define    class Functor f where { map :: (x -> y) -> f x -> f y; }; class Functor f => Applicative f where { pure :: x -> f x; liftPair :: (f x, f y) -> f (x, y); }; class Functor f => Monad f where { return :: x -> f x; join :: f (f x) -> f x; };    or something like that, for example; it can be done but won't be compatible with existing programs!!!
23:14:52 <roconnor__> Apparently at MSR-INRIA, we are developing a formal definition of a "Num" type class as part of the mathematical components project.
23:15:07 <roconnor__> with laws and stuff
23:15:15 <edwardk> roconnor__: hopefully it won't suck as bad as Num
23:15:21 <elliott> roconnor__: Num. Laws: {}
23:15:42 * elliott ghc-cores it up
23:16:38 <edwardk> elliott: anyways its just a few characters to shift to using the lambda. compare my reflect with yours
23:16:46 <elliott> yeah, i did :)
23:16:53 <edwardk> reflect = r rather than reflect s = r
23:16:53 <roconnor__> as I understand it is a normed ring with a non-negativity predicate P and a partial ordered defined as x <= y iff P (y - x).
23:16:54 <elliott> aw, fixing that bug makes it 186 vs 122... still winning though
23:17:03 <edwardk> hah
23:17:06 <zzo38> edwardk: O, another way I thought of, is if the types can have instance tags so that two (Set Int) with a different (Ord Int) instance are actually considered two different types
23:17:29 * elliott thinks: (let b = f Proxy in b `seq` const b) === (const $! f Proxy)
23:17:43 <zzo38> Will that work?
23:17:54 <edwardk> roconnor__: so that version precludes things like modular arithmetic?
23:18:08 <roconnor__> edwardk: yes
23:18:19 <edwardk> roconnor__: blech
23:18:30 <roconnor__> the existance of Num is no execuse not to have Ring, etc underneath
23:18:39 <edwardk> sure
23:19:01 <roconnor__> edwardk: but modular arithmetic has no modulus function (aka abs).
23:19:01 <edwardk> i've been meaning to clean up my algebra package using constraint kinds but i want a syntax to write polykinds with first =(
23:19:14 <zzo38> If newtypes are used then, for example,    putStr :: String -> IO ();   if you make a newtype wrapper around IO then you have to affect it for every time using putStr and so on
23:19:41 <elliott> edwardk: well we know AsKindOf is possible
23:19:46 <elliott> so you shouldn't technically need it :p
23:19:46 <edwardk> roconnor__: sure, though you can comply with the crappy laws we have on it in haskell with the abs = id; signum 0 = 0; signum _ = 1 version
23:19:53 <edwardk> elliott: its not enough
23:19:53 <roconnor__> edwardk: what are the odds we can extract (+) (-) (*) negate and fromInteger into a Ring class below Num in the next Haskell revision?
23:20:09 <edwardk> roconnor__: good luck
23:22:53 <roconnor__> I guess that wouldn't be very compatible.
23:23:04 <elliott> what happens if you deref a stableptr after freeing it?
23:23:06 <elliott> I guess segfaults
23:23:22 * elliott is wondering if any of the unsafePerformIOs can be unsafeDupablePerformIOs
23:23:36 <dmwit> tkahn6: http://legacy.cs.uu.nl/daan/parsec.html <- the official tutorial I was talking about earlier is here
23:23:41 <zzo38> Please tell me, would it work if the two (Set Int) types with a different (Ord Int) are considered two different types?
23:23:42 <edwardk> elliott: hah
23:24:01 <tkahn6> dmwit: thanks i'm actually reading that atm
23:24:08 <elliott> I think the one in reify actually can be
23:24:22 <elliott> zzo38: yes, but then you need to encode the instance in the type again
23:24:37 <elliott> int2Word# is free at runtime, right?
23:25:18 <zzo38> It does give me some idea. In Ibtlfmm, @ is the kind for program modules, so you could use it as an instance tag (if you define local instances in a part, it is considered a different module); possibly as a hidden parameter (which means the kind system needs to somehow support it? But also a way to override them if you need to)
23:26:48 <zzo38> But the kind system would then also need a way to associate those parameters with those classes. Possibly, by allowing kinds to also have constraints!
23:27:05 <dmwit> zzo38: Creating a system so complicated it's not obviously wrong doesn't seem like the right approach to language design.
23:27:11 <dmwit> (Though it is undoubtedly a popular one.)
23:27:21 <edwardk> elliott: yeah
23:28:03 <elliott> hmm, (Type.integerToWord (Type.smallInteger x)), never seen that before
23:28:19 <edwardk> zzo38: you may still run into the same confluence problems as generalized newtype deriving in the presence of MPTCs though
23:30:20 <zzo38> edwardk: I did think of that, as well as associated type families; and I didn't know any way to fix that. But now, instance tags seem a possible way.
23:31:06 <edwardk> dmwit++
23:31:21 <zzo38> (But Haskell cannot easily support all the things I am proposing; hence to make up a new programming language instead)
23:31:53 <iihavetoes26> -+++++++++++++++++++++
23:33:21 <zzo38> Actually now I thought of how to fix the hidden parameters problem. Using the example of Haskell's Set type in Ibtlfmm, make up Set_ which takes the instance tag, and Set which is a type synonym using the automatic instance tag, I suppose.
23:41:03 <zzo38> There are packages which provide instances for Alternative IO and MonadPlus IO but those instances are bad
23:43:04 <zzo38> Another problem is that two packages might both define instances for the same thing and then it will cause confliction! How do you deal with that?
23:44:55 <edwardk> what is your complaint about the MonadPlus for IO?
23:45:20 <zzo38> edwardk: It isn't a monoid
23:45:46 <edwardk> zzo38: ? checking
23:46:03 <zzo38> edwardk: What do you mean ? checking
23:46:42 <edwardk> zzo38: don't see the monoid failing off hand, might be wrong, but i'm not grokking that part yet
23:46:46 <zzo38> This is proper way:   instance Alternative IO where { empty = fail []; x <|> y = catch x $ \e -> modifyIOError (\z -> if z == userError [] then e else z) y; };
23:48:34 <edwardk> a <|> b <|> c under either parenthesization yields the result of the first computation that exits without an error, or the last error, with a unit. its a monoid, its just not the one you want
23:49:48 <zzo38> edwardk: Are you sure?    fail "wrong" <|> empty    with other one is not same as    fail "wrong"    I think
23:50:15 <edwardk> hrmm
23:50:19 <edwardk> you may be right
23:50:29 <edwardk> for some reason i was thinking of return not empty
23:53:28 <zzo38> And I think finally I know how to make the instance tag: Make it so you write     data Ord x => Set x = ......    and then an instance tag is attached (if the function using it does not mention (Ord x) constraint since it uses the instance tag of the type instead)! Isn't it? It currently doesn't work but they could make it to work
23:57:33 <tkahn6> that feeling when the official tutorial is out of date and has errors in the code given
23:59:17 <zzo38> Now, if only, they could actually make things like     data Ord x =>    to actually work
