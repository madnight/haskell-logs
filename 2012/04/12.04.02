00:24:29 <Rc43> Hi, guys.
00:27:02 <hpaste> Rc43 pasted “Gtk2hs strange mouse behaviour” at http://hpaste.org/66347
00:27:15 <Rc43> I have strange problem with Gtk2hs.
00:27:40 <Rc43> Mouse right click works only in bottom half of window.
00:29:12 <Rc43> Oh, I found mistake. It was obvious, sorry.
00:31:44 <Lemmih> Glad we could be of assistance.
00:32:58 <sabrehagen> hi everyone, i'm trying to print a value to the command line without using IO. I am using error (because I don't mind if my program crashes) and I want to print a float. How do I prepare the float for input to error which takes [char]?
00:33:26 <sabrehagen> alternatively, is there a debug output statement?
00:34:22 <earthy> Debug.Trace
00:35:03 <earthy> @hoogle Debug.Trace.trace
00:35:03 <lambdabot> Debug.Trace module Debug.Trace
00:35:03 <lambdabot> Debug.Trace trace :: String -> a -> a
00:35:04 <lambdabot> Debug.Trace traceShow :: Show a => a -> b -> b
00:35:36 <earthy> plus, most types have Show defined
00:35:46 <earthy> > show 3.2
00:35:47 <lambdabot>   "3.2"
00:35:56 <sabrehagen> thanks earthy, i'll try that and get back to you
00:35:56 <earthy> > show (3.2 :: Float)
00:35:57 <lambdabot>   "3.2"
00:36:23 <sabrehagen> show is returning the value rather than printing it to the command line so i'll try trace
00:36:49 <earthy> yes. show is a *function* that converts anything to string
00:36:54 <earthy> @hoogle show
00:36:54 <lambdabot> Prelude class Show a
00:36:55 <lambdabot> Text.Show class Show a
00:36:55 <lambdabot> Prelude show :: Show a => a -> String
00:38:00 <earthy> so, e.g.    trace (show float) float    is a *function* that has the same value as the float, but traces it to stderr in the process
00:38:18 <sabrehagen> ahh, that makes sense :)
00:39:12 <earthy> oh, it's usage is generally frowned upon, as it totally breaks optimization :)
00:39:27 <earthy> then again, for debugging it has it's uses. :)
00:39:43 <earthy> dang, too many apostrophes
00:39:59 * earthy is obviously still waking up
00:40:14 <earthy> time to write some code... less error prone as I have a compiler to check it for me ;)
00:40:28 <sabrehagen> haha gotcha :)
00:40:46 <sabrehagen> i'm working on an assignment for university at the moment and a function definition is as follows:
00:40:57 <sabrehagen> advanceWorld :: unused -> Float -> World -> World
00:41:09 <sabrehagen> why would there be a parameter called 'unused'?
00:42:45 <Lemmih> sabrehagen: No good reason.
00:43:06 <sabrehagen> would would it's purpose be, or do you need more information to know that?
00:43:18 <sabrehagen> basically, i need to implement the function
00:43:32 <Lemmih> It has no purpose. Just ignore it.
00:44:22 <sabrehagen> The spec says 'implement advanceWorld which ignores its first argument and gets the number of seconds...etc..."
00:44:32 <kallisti> sabrehagen: there you go
00:44:40 <kallisti> advanceWorld _ x y = ...
00:44:40 <sabrehagen> i've never seen a program that has that behaviour. it seems ridiculous...
00:45:05 <Lemmih> sabrehagen: You're in University. Get used to it.
00:45:30 <sabrehagen> eh...i guess i just have to do whatever it takes to get the marks!
00:45:54 <kallisti> the only reason that would be useful is that it saves you an application of const later.
00:46:03 <kallisti> and that's not a very good reason.
00:46:16 <glguy> yeah, once you get into the real world you'll never encounter seemingly senseless requirements ;)
00:47:33 <sabrehagen> bring it on!
00:47:55 * earthy rofls at glguy
00:49:12 <ClaudiusMaximus> i'm guessing next month's assignment might change it to something useful, and the prof didn't feel like writing two assignment test harnesses...
00:51:57 <sabrehagen> that sounds about right!
00:56:09 <earthy> plus, there's value in learning how to ignore an argument while developing base functionality
00:56:34 <earthy> (or even when implementing a given interface where you are given an argument you *really* do not need)
00:56:53 <Veinor> father forgive me for i have sinned
00:56:58 <Veinor> i have overly specialized a type for readability
00:57:16 <danr> or for optimisation?
01:03:55 <mysticc> I have written a ffi implementation of unistd fsync call .. but thee problem is it is closing the handle after sync .. http://paste.pocoo.org/show/574859/
01:06:07 <ClaudiusMaximus> mysticc: handleToFd closes the handle http://hackage.haskell.org/packages/archive/unix/latest/doc/html/System-Posix-IO-ByteString.html#v:handleToFd
01:06:51 <ClaudiusMaximus> oops, wrong version, but the other one does too
01:07:04 <mysticc> ClaudiusMaximus: What is the best way to do what I am trying to do ..
01:07:21 <mysticc> ClaudiusMaximus: I dont think there is a fsync in any haskell library
01:08:04 <mysticc> ClaudiusMaximus: I want the surity that buffers are written after sync .. System.IO sync just sends the data to operating systems buffers not to the disk ..
01:09:01 <ClaudiusMaximus> mysticc: hm, maybe use fdToHandle and return the new Handle ?  not very nice though :(
01:10:57 <mysticc> ClaudiusMaximus: Yeah not very nice because then there will be a lot of problems in the case I am using this .. cant I have something like that without closing the handles actually ..
01:11:29 <ClaudiusMaximus> mysticc: http://hackage.haskell.org/package/cautious-file perhaps
01:13:03 <ClaudiusMaximus> mysticc: but that seems to side-step the problem, perhaps it is unavoidable..
01:13:40 <mysticc> ClaudiusMaximus: So it is not possible to sync without actually closing the handle ..
01:14:32 <ClaudiusMaximus> mysticc: http://hackage.haskell.org/packages/archive/lio-eci11/latest/doc/html/LIO-TmpFile.html#v:hSync uses internal ghc things
01:16:41 <mysticc> ClaudiusMaximus: Thanks .. How did you actually find that ..
01:17:03 <ClaudiusMaximus> mysticc: http://holumbus.fh-wedel.de/hayoo/hayoo.html?query=fsync
01:24:00 <ClaudiusMaximus> @hoogle (w -> z) -> Writer w a -> Writer z a
01:24:00 <lambdabot> Data.Graph.Inductive.Graph nmap :: DynGraph gr => (a -> c) -> gr a b -> gr c b
01:24:00 <lambdabot> Control.Arrow (^>>) :: Arrow a => (b -> c) -> a c d -> a b d
01:24:00 <lambdabot> Data.Graph.Inductive.Basic elfilter :: DynGraph gr => (b -> Bool) -> gr a b -> gr a b
01:26:51 * hackagebot recursive-line-count 0.1 - Count lines in files and display them hierarchically  http://hackage.haskell.org/package/recursive-line-count-0.1 (JoeyAdams)
01:28:24 <ClaudiusMaximus> :t \f -> mapWriter (fmap f)
01:28:25 <lambdabot> forall w w' a. (w -> w') -> Writer w a -> Writer w' a
01:29:15 <ClaudiusMaximus> :t fmap fmap mapWriter
01:29:16 <lambdabot> forall (f :: * -> *) a w b w'. (Functor f) => ((a, w) -> (b, w')) -> f (Writer w a) -> f (Writer w' b)
01:51:52 * hackagebot websockets 0.6.0.2 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.6.0.2 (JasperVanDerJeugt)
02:12:51 <t7> @pl (\t -> return (fv, c, t))
02:12:51 <lambdabot> return . (,,) fv c
02:14:49 <koala_man> how would I write a regex that matches strings not containing the string "hi"? (seeing as how regular languages are closed under complement)
02:15:38 <flux> koala_man, first just translate that into an NFA, then into DFA, then reverse that, then convert back into NFA and then back in to regexp :)
02:15:46 <quicksilver> ([^h]|h[^i])*
02:15:56 <flux> or, just wait and listen what quicksilver says :)
02:16:12 <koala_man> quicksilver: that matches "hhi"
02:16:24 <mm|swarm> i just heard that april's fool xkcd was done in haskell
02:16:36 <mm|swarm> does anyone know where can I find all the comic possibilities?
02:17:48 <quicksilver> ([^h]|h+[^i])* perhaps?
02:17:54 <quicksilver> regexps aren't regular
02:18:10 <merijn> ([^hi]|h[^i])*
02:18:25 <quicksilver> and the standard translation of complement involves writing out the complement exhaustively AFAICR
02:18:42 <flux> you need to start with the regexp .*hi.* if you do it the dfa-way
02:19:00 <quicksilver> as a practical rule of thumb, avoid using regexps when your problem is complex enough to involve complement.
02:19:12 <merijn> quicksilver: For small regexes I just draw a finite state machine on paper and reverse it by hand :p
02:19:15 <quicksilver> or, as an even simpler practical rule of thumb, don't use regexps.
02:19:49 <merijn> oh, wait. My solution is obviously wrong, that's what I get for being hasty
02:20:07 <quicksilver> I think my second attempt is right isn't it?
02:20:33 <koala_man> quicksilver: still matches "hhi"
02:20:35 <quicksilver> well it's right if you believe that [^i] matches EOF
02:20:42 <merijn> ([^h]|h[^i])*
02:20:52 <quicksilver> koala_man: no it doesn't?
02:21:11 <koala_man> merijn: doesn't match "ih"
02:21:18 <quicksilver> well, not under greedy operational semantics.
02:21:19 <t7> > ( 1, 2 : 3, 4)
02:21:20 <lambdabot>   No instance for (GHC.Num.Num [t])
02:21:20 <lambdabot>    arising from a use of `e_11234' at <in...
02:21:46 <merijn> ([^h]|h[^i])*h?
02:21:52 <quicksilver> ([^h]|h+$|h+[^i])
02:21:54 <merijn> Question mark being part of the regex, obviously
02:22:03 <merijn> Problem solved :p
02:22:21 <flux> a proper solution would need to involve ^ and $ in it, wouldn't it? so not to match "hello world hi" ?
02:22:25 <koala_man> quicksilver: echo hhi | grep -c -E '^([^h]|h+[^i])*$'
02:22:57 <merijn> koala_man: The question mentioned matching any string not containing a "hi", I fail to see how ^ and $ are relevant?
02:23:00 <koala_man> the first iteration matches hh in the second case, the second iteration matches i in [^h]
02:23:31 <quicksilver> oh right,
02:23:38 <quicksilver> ([^h]|h+$|h+[^hi])
02:23:51 <koala_man> merijn: without ^$ in egrep, you implicitly sortof match .* on each side
02:24:08 <merijn> That's a flaw in the your regex logic
02:24:15 <merijn> No one specified grep semantics
02:24:42 <koala_man> merijn: no, that's why I added ^$ to make it use maths style semantics
02:24:45 <merijn> You need greedy semantics on the *
02:24:58 <merijn> Pretty sure there's a grep flag for that or something
02:25:01 <merijn> But maybe not
02:25:16 <koala_man> * are greedy in grep, but they're not what Sun once termed possessive
02:26:14 <merijn> The problem is that grep matches partial lines where you want to match entire lines, but that's hardly a problem with the regex
02:26:30 <koala_man> merijn: that's what the ^$ are for. they require matching the entire line.
02:26:31 <merijn> Just use python or perl or something instead of grep
02:26:36 <cheater> what is "posessive"?
02:26:41 <cheater> use awk
02:26:45 <cheater> or use grep -v
02:26:53 <cheater> there's a reason -v exists
02:26:56 <osfameron> or ack-grep
02:28:18 <BlankVerse> how to find out the line number where Exception: No match in record selector accurs
02:28:23 <koala_man> quicksilver: was there supposed to be a * on there?
02:28:27 <BlankVerse> *occurs
02:29:21 <mysticc> I am new to using type families .. I have defined a type data BlockNumber :: * -> * .. in my type class . But I also want a restriction on the type "Blocknumber b" to be of Eq class .. Can I have such constraints ?
02:32:56 <bitonic> mysticc: you want the types indexed by the type family under a constraint? or the indexes? anyways I don't thing you can do that, but you can put constraints on the class method
02:33:25 <t7> is this ugly code: Var v -> idType v c >>= \t -> return (fv, c, t)
02:33:34 <t7> should i use pf there?
02:33:49 <quicksilver> koala_man: certainly.
02:33:50 <t7> or fmap
02:36:51 <t7> :t (,,)
02:36:52 <lambdabot> forall a b c. a -> b -> c -> (a, b, c)
02:37:02 -ChanServ(ChanServ@services.)- Saizan set flags +votsriRfA on edwardk.
02:37:30 <t7> i dont think this is any better: Var v -> ((,,) fv c) <$> idType v c
02:37:43 <koala_man> quicksilver: awesome, seems to work
02:38:46 <quicksilver> koala_man: trial and error for the win :P
02:38:51 <bitonic> t7: no don't go pf, it's just more confusing. if anything, you can do 'do t <- idType v c; return (fv, c, t)'
02:39:01 <mysticc> bitonic: http://paste.pocoo.org/show/574892/
02:39:11 <koala_man> totally
02:39:35 <koala_man> I wrote an app for generating the solution, and it works, but it's longer than I can paste here
02:39:42 <koala_man> the regex, that is. not the app
02:40:06 <koala_man> well, both.
02:40:50 <t7> bitonic: (fv, c,) <$> idType v c     with TupleSections :) ?
02:41:05 <zzo38> Proof that Alternative and Comonad are mutually exclusive:     extract empty
02:42:22 <mysticc> bitonic: I think I should put constraints on the functions .. something like readBlock :: (Eq (BlockNumber b)) => Handle b -> BlockNumber b -> m a
02:42:47 <bitonic> mysticc: first of all, you want Blocknumber b :: *, not * -> *
02:43:21 <bitonic> mysticc: secondly, you can put the constraint in the class constraints
02:43:47 <bitonic> eg class (Show a, Eq (Blocknumber b)) => Backend b m a where
02:43:55 <bitonic> mysticc: actually sorry that's fine (the * -> *)
02:44:26 <t7> > (\x -> (x 1, x "hi")) (\x -> x)
02:44:27 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
02:44:27 <lambdabot>    arising from the literal ...
02:44:32 <bitonic> mysticc: I thought you were giving the args explicitly
02:44:50 <t7> > let x i = i in (x 1, x "hi")
02:44:51 <lambdabot>   (1,"hi")
02:47:46 <mysticc> bitonic: So there is no way to specify that in kind definition ?
02:52:19 <bitonic> mysticc: not that I know of
02:57:25 <quest> hey
02:57:36 <quest> could you tell me please what the partial numbers are?
02:58:43 <quest> just only _|_ ?
02:58:50 <quest> i mean bottom
03:00:19 <t7> whats (::) called?
03:00:23 <t7> type specification?
03:06:19 <jonkri> is there some convenient way to check if a function can throw an exception?
03:06:39 <quicksilver> no
03:06:57 <quicksilver> if you want type checked exceptions you don't want to use asynchronous exceptions
03:07:06 <quicksilver> you want to use some type-checked method like Either
03:08:32 <jonkri> quicksilver, like Control.Exception.try?
03:08:39 <earthy> t7: 'type signature' according to the haskell report
03:08:48 <earthy> (but that's :: including the type following it)
03:09:01 <quicksilver> jonkri: no.
03:09:20 <quicksilver> jonkri: you want to not use anything in Control.Exception.* or, probably, anything using the word 'exception'.
03:09:45 <quicksilver> most uses of the word 'exception' in the haskell libraries refer to asynchronous exceptions which are not type-checkable in the way you want (by design).
03:10:15 <quicksilver> "try" is certainly a way to get a function which definitely won't throw an exception
03:10:26 <quicksilver> but it doesn't do any checking on whether it can, or what types it can.
03:10:49 <jonkri> i see
03:10:58 <jonkri> quicksilver, connectTo throws such an asynchronous exception, right?
03:11:04 <quicksilver> very likely
03:11:12 <quicksilver> pretty much all the network stuff can in principle
03:12:23 <jonkri> quicksilver, do you prefer something other than try, such as ErrorT, when dealing with network code?
03:12:52 <jonkri> s/network code/the network api
03:12:56 <quicksilver> depends on context.
03:13:08 <quicksilver> obviously you can't do much about the fact that the network code uses async exceptions
03:13:24 <jonkri> it wasn't that obvious to me ;)
03:13:31 <jonkri> thank you
03:13:37 <quicksilver> and if the documentation of connectTo doesn't list the exceptions it can throw then that's anoying.
03:13:48 <quicksilver> I would catch the ones you know how to handle, and handle them as locally as you can.
03:14:00 <jonkri> aha :)
03:14:27 <quicksilver> if you suspect there are other exceptions you don't/can't handle but you'd still rather they didn't take out your whole thread
03:14:47 <quicksilver> then a 'try' at a high-ish level to catch them and maybe print an error "unexpected IO error received, trying to continue..." to some log file...
03:15:31 <jonkri> ok
03:22:47 <merijn> quicksilver: I think a bunch of the network stuff throws exceptions it shouldn't, though (i.e., in non-exceptional situations). Which is a bit annoying...
03:23:33 <quicksilver> In the IO monad using exceptions instead of return types to signal failure is not an unreasonable compromise.
03:23:45 <quicksilver> in an ideal world you might be able to choose your signalling method of choice.
03:23:57 <merijn> Yes but it throws an exception for reading from a socket with the remote side closed
03:23:58 <quicksilver> or their might be something like ErrorT IO to use
03:24:08 <quicksilver> that's progress merijn!
03:24:09 <merijn> Whereas the common unix semantics are to return 0 characters read
03:24:17 <quicksilver> it used to be a signal which killed your process.
03:24:35 <quicksilver> are you sure? I think the common unix semantics is to die screaming with SIGPIPE?
03:25:06 <merijn> For pipes and files
03:25:11 <merijn> Maybe just files
03:25:27 <merijn> read from a closed (remote socket) returns 0, because you can still write to it
03:25:29 <mauke> quicksilver: that's for writing to pipes whose read end is closed
03:25:41 <quicksilver> ah, that'll be it.
03:25:52 <quicksilver> merijn: maybe that's actually a bug then?
03:25:56 <mauke> and you can ignore that signal
03:26:00 <quicksilver> of course, yes.
03:26:11 * quicksilver has lots of code which ignores/handles that exception.
03:29:55 <t7> no one has liked the hindley milner type inference method on facebook :(
03:31:04 <merijn> t7: That's because all the haskell hackers are on G+ :p
03:31:25 <t7> its only haskell people who ever seem to post on g+
03:31:34 <t7> on mine anyway
03:31:46 <t7> should rename it h+
03:32:48 <t7> or monad plus
03:34:09 <blueonyx> hi, whats the fastest way to extract some tags from a xml file?
03:39:41 <t7> bitonic: do i only have to alpha rename when evaluating?
03:40:54 <jonkri> is there a more convenient way of doing "foreach" on a list than an iterative recursive function?
03:41:13 <ChristianS> jonkri: map
03:54:15 <t7> > (let y = x in \y -> (y 2, y "2")) (\x -> x)
03:54:16 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
03:54:16 <lambdabot>    arising from the literal ...
03:54:27 <t7> :/
03:54:55 <t7> why doesnt that work
03:55:02 <t7> i think that works in my type checker
03:55:05 <mauke> rank 1
03:59:50 <Saizan> what is the "y = x" supposed to do?
04:00:20 <t7> give y a poly type
04:00:23 <Saizan> that should be an out of scope error if we didn't have x :: Expr in scope
04:00:55 <mauke> t7: you never use that y
04:01:00 <t7> oh yeah :|
04:01:16 <t7> > (\x -> (let y = x in \y -> (y 2, y "2"))) (\x -> x)
04:01:17 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:01:17 <lambdabot>    arising from the literal ...
04:01:34 <t7> > (\x -> (let y = x in (y 2, y "2"))) (\x -> x)
04:01:34 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
04:01:35 <lambdabot>    arising from the literal ...
04:02:39 <Saizan> x already has a monotype, the let has nothing to generalize there
04:03:52 <t7> i thought let allways defines a poly type, am i way off the mark?
04:04:25 <Saizan> in this case you could think of y as having a polytype that quantifies over 0 type variables
04:05:08 <Saizan> because you've to remove the ones appearing in the surrounding context
04:05:14 <t7> o man i think my mental model of HM is very wrong
04:07:27 <t7> oh yeah
04:07:30 <t7> that makes sense
04:07:39 <t7> mine handles this the same way infact :)
04:08:42 <reinoud> @hoogle vector
04:08:42 <lambdabot> Test.QuickCheck.Arbitrary vector :: Arbitrary a => Int -> Gen [a]
04:08:42 <lambdabot> Test.QuickCheck vector :: Arbitrary a => Int -> Gen [a]
04:08:43 <lambdabot> package vector
04:09:15 <reinoud> @hoogle outproduct
04:09:16 <lambdabot> No results found
04:19:37 <t7> Saizan: could you look at some code for me and tell me if i have the right idea?
04:19:57 <t7> only 100 lines or so with white space and comments
04:20:34 <quicksilver> real men write H-M inference in 100 characters without whitespace or comments.
04:21:34 <t7> i thought mine was fairly consise...
04:22:59 <Saizan> t7: ok
04:23:23 <jonkri> thanks ChristianS :)
04:23:37 <hpaste> t7 pasted “HM ” at http://hpaste.org/66351
04:28:33 <quicksilver> t7: I was not being serious.
04:29:08 <t7> quicksilver: im sure it can be done in golfscript or something
04:29:43 <Saizan> you got your representation for polytypes wrong, and hence substitution
04:30:46 <Saizan> t7: not all the variables appearing in a polytype can be left alone
04:32:10 <merijn> Hmm, I need help designing a data structure. I have a graph where some vertices can be subdivided into 2 or more sets, each referring to a subset of the edges connected to that vertex. I'm unsure what a decent way of modelling this would be (graph itself and subset membership isn't changed, but information at each vertex will be)
04:32:43 <Saizan> you've to distinguish between those that appeared in the context when you created the polytype, which must be substituted into, and those that don't which have to be left alone by substitution but must be instantiated to fresh one by idType
04:32:48 <Saizan> *fresh ones
04:33:39 <t7> ah
04:33:51 <t7> how on earth am i gonna do that
04:34:06 <t7> have every type tagged as poly or mono?
04:34:34 <Saizan> just like now, except the Poly constructor needs another [Id] argument
04:35:11 <Saizan> which will be the vars that must not be touched inside that polytype
04:36:16 <t7> ok. Which ones should not be sub'd ?
04:36:56 <Saizan> vars ty1 \\ vars c'
04:37:57 <t7> ok cool
04:38:16 <t7> thankyou
04:38:26 <Saizan> that's hopefully correct enough,
04:39:09 <clsmith> hmm, is edward kmett not in here atm? (i don't remember if his nick was his name or not.)
04:39:45 <Saizan> clsmith: edwardk is the nick
04:40:04 <clsmith> oh yeah, that's it.
04:40:32 <clsmith> hmm, parted ~80 minutes ago. never mind.
05:00:20 <t7> Saizan: vars c' is free vars, right#?
05:01:03 <Saizan> t7: yeah, you must not count ones that are bound by the polytypes
05:03:49 <osa1> choice [string "login", string "leave", string "join"] in parsec always tries to match "login", does anyone know why?
05:04:51 <hpc> osa1: does it backtrack and try "leave" when "login
05:04:54 <hpc> " fails?
05:05:19 <osa1> hpc: seems like not
05:08:35 <killy9999> umm.. anyone responded to what I wrote a few minutes ago? I got disconnected...
05:08:36 <osa1> hpc: why doesn't it backtrack and try other choices? is it why we have `choice`
05:08:48 <osa1> isn't it*
05:09:38 <mikeplus32> killy9999: you didn't say anything
05:09:44 <t7> Saizan: hang on do you mean Poly needs a list of TVars or Vars ?
05:09:46 <killy9999> that explains much :)
05:09:50 <killy9999> so once again
05:10:13 <killy9999> RWH says: "The familiar Bool is the simplest common example of a category of type called an algebraic data type. An algebraic data type can have more than one value constructor."
05:10:31 <killy9999> this confuses me on what is the definition of ADT
05:10:48 <killy9999> if the data type has only one value constructor then it's not an ADT?
05:10:54 <opqdonut> it is
05:10:55 <t7> i assume TVars ...
05:11:01 <Saizan> t7: TVars
05:11:08 <sipa> killy9999: "can have" is not the same as "must have"
05:11:26 <Saizan> t7: sorry, i should have said [Int] instead of [Id]
05:11:31 <sipa> killy9999: it can have 1 or more constructors (and with an extension also 0)
05:11:44 <t7> so i just need to find the TVars that exist in the let but not in the context
05:11:46 <t7> ok cool
05:11:57 <killy9999> sipa: thx, that's why I felt confused
05:12:24 <killy9999> the book puts it in a way that suggests that having two value constryuctors is a distingishing feature of ADTs
05:12:26 <clsmith> does anyone know if any packages use edwardk's rope?
05:12:41 <Saizan> yeah, you don't need to look at the values to make this fix
05:12:45 <sipa> killy9999: no, the ability to have more than one constructor is the distinguishing feature
05:13:27 <merijn> killy9999: I (personally) think RWH can get a bit confusing sometimes because it tries to be so concise
05:13:49 <merijn> As a result I don't really like it as an intro book, I think it's nicer as a second book after getting the basics
05:15:36 <killy9999> merijn: I've read most of LYAH
05:15:43 <killy9999> and now I'm reading RWH
05:15:48 <merijn> ah, ok
05:16:01 <killy9999> so what is the definition of ADT?
05:16:38 <opqdonut> ADT is just a fancy name for the sort of datatypes you have in haskell
05:16:41 <merijn> My ADT definition is mostly extensional, so I couldn't really give you a good intensional one
05:16:41 <quicksilver> I'm not sure there is a universally accepted definition killy9999
05:17:00 <hpc> osa1: apparently for me that parser is a type error
05:17:02 <quicksilver> the "main point" is that you can do stuff like data Foo = Bar Int Int | Baz String (String,Char)
05:17:15 <hpc> and it's too early in the morning for me to figure out wtf it's complaining about
05:17:18 <hpc> :/
05:17:26 <quicksilver> precisely which cases count as 'ADT' is sometimes controversial.
05:17:46 <killy9999> aha, ok
05:17:55 <merijn> killy9999: I would just define it as the stuff LYAH described :p
05:18:02 <merijn> And not worry about it too much
05:18:05 <killy9999> merijn: :)
05:18:09 <killy9999> ok
05:18:10 <quicksilver> I think, in haskell, I'd define it as "stuff you define with the 'data' keyword"
05:18:42 <killy9999> quicksilbver: that's what I thought so far, but the RWH got me confused
05:18:58 * killy9999 has to go, will be back in 30 minutes
05:19:24 <hpc> https://en.wikipedia.org/wiki/Algebraic_data_type
05:19:51 <t7> Saizan: sorry to keep pestering, when getting TVars in the context should i include TVars in poly types in the context?
05:20:47 <hpc> wikipedia seems to more or less define ADT as "haskell data type"
05:22:00 <t7> this is getting confusing :|
05:23:56 <quicksilver> hpc: I think you can make a case that you shouldn't be allowed to use IO, and possibly not even functions, if you want to call the result an ADT. Since algebras are closed constructions.
05:24:25 <quicksilver> hpc: I think you can even possibly make a case that you shouldn't allow recursion, because recursion isn't a "normal" algebraic construction.
05:24:43 <quicksilver> hpc: but there isn't really a good reason to be this pedantic unless you have some goal in mind :)
05:24:56 <quicksilver> ...and if you're writing a paper on it, you just choose a definition and stick to it.
05:27:08 * hackagebot haskell-type-exts 0.1.0 - A type checker for Haskell/haskell-src-exts  http://hackage.haskell.org/package/haskell-type-exts-0.1.0 (NiklasBroberg)
05:27:51 <bitonic> oh well, that's interesting (haskell-type-exts).
05:30:23 <osa1> I added my question to so: http://stackoverflow.com/questions/9976388/haskell-text-parsec-combinator-choice-doesnt-backtrack
05:32:22 <quicksilver> osa1: string is just a sequence of char commands, it won't backtrack
05:32:28 <quicksilver> parsec does not backtrack.
05:32:44 <quicksilver> osa1: s/string/try $ string/g;
05:33:30 <nart> ciao :)
05:33:46 <osa1> quicksilver: so why does parseTest (choice [string "ok", string "nop"]) (pack "nop") work? I'm new at this stuff
05:34:07 <quicksilver> osa1: because no backtracking is required there
05:34:18 <quicksilver> because 'o' and 'n' are different letters.
05:34:21 <osa1> hmm
05:34:27 <quicksilver> your problem is that 'l' and 'l' are the same letter
05:34:33 <quicksilver> but this isn't a real problem ;)
05:34:41 <quicksilver> it just means you need to use try
05:34:42 <osa1> got it. so how can I solve this?
05:34:46 <osa1> ok, thanks
05:34:56 <osa1> I should look to try in documentation, I never used it
05:34:56 <quicksilver> well I told you but possibly I was too cryptic
05:34:59 <nart> i have a few words separated by space, i want to get them in a list
05:35:02 <nart> i would use sepBy
05:35:08 <quicksilver> osa1:  quicksilver> osa1: s/string/try $ string/g;
05:35:24 <nart> but these words can contain any kind of lettere num or symbol
05:35:27 <quicksilver> osa1: that is, where you use 'string' in that choice, replace it with try $ string
05:35:40 <nart> so i would use anyToken, but it matches also spaces :S
05:35:42 <osa1> quicksilver: whoa, thanks :) trying
05:35:59 <quicksilver> osa1: for performance, parsec does not backtrack by default. You need to mark your "backtracking points" explicitly with try'
05:36:30 <osa1> quicksilver: great, thanks, now it's working as expected
05:37:03 <quicksilver> nart: noneOf " "
05:37:15 <nart> quicksilver: thanks
05:37:28 <quicksilver> nart: possibly many (noneOf " ")
05:53:20 <nart> if have something like this in my code http://hpaste.org/66354, it means that every thread will have their own env state, and if i modify the state inside one thread the others won't see the change in their env ?
05:53:54 <nart> *every threads will have its own
05:54:03 <killy9999> anyone uses EclipseFP plugin to program in Haskell?
05:55:28 <quicksilver> nart: well, 'ReaderT' can't modify its environment anyway!
05:55:51 <nart> quicksilver: sorry, i forgot to say that i have some MVar in the env
05:56:01 <quicksilver> nart: ah well, an MVar is just an MVar.
05:56:06 <quicksilver> you haven't copied the contents
05:56:11 <quicksilver> so they're sharing it.
05:56:38 <nart> ah ok, so it's kind of passed by reference
05:57:27 <quicksilver> your language suggests that you're slightly misunderstanding, nart
05:57:37 <quicksilver> in haskell everything is by reference and everything is immutable
05:57:44 <quicksilver> there is only one 'env' and they can all see it.
05:57:50 <quicksilver> that env contains just the one MVar
05:58:12 <quicksilver> the MVar itself is immutable (warning! subtle pedantry) but it acts as the 'name' or 'location' of a truly mutable cell.
05:59:35 <nart> quicksilver: ah know i see, thanks for the explanation
05:59:41 <nart> *omg now i see
05:59:53 <quicksilver> :)
06:02:00 <int-e> quicksilver: not really true.
06:03:09 <killy9999> can I rely on HLint, even if it proposes to correct stuff copied from the documentation?
06:03:19 <killy9999> it advises to use "a" instead of ['a']
06:04:22 <ion> If you have a reason to prefer ['a'], just keep it as it is. But "a" is a more typical way to encode a list of characters.
06:05:00 <quicksilver> int-e: but a convenient simplification? Or do you think I mislead?
06:05:22 <int-e> quicksilver: Oh, I guess it depends on what exactly you mean by "the MVar". To me, the MVar is the object on the heap (which contains a reference that is mutable and points the the MVar's "current value"). What was copied between threads is the reference to the MVar.
06:05:41 <quicksilver> sure. naming is hard.
06:05:59 <quicksilver> I mean that the haskell value of type 'MVar Foo' is a normal, immutable, haskell value
06:06:15 <quicksilver> which happens to contain a reference/name/pointer/location to the mutable object of which you speak.
06:07:26 <int-e> quicksilver: Again, that's the same difference. I think of "values" as the heap objects, you think of them as the references that are actually passed around. So you're not wrong, you just view the same world from a slightly different angle.
06:10:55 <mysticc> @hoogle m m a -> m a
06:10:55 <lambdabot> Control.Monad.Trans.Identity runIdentityT :: IdentityT m a -> m a
06:10:55 <lambdabot> Control.Applicative unwrapMonad :: WrappedMonad m a -> m a
06:10:55 <lambdabot> Text.Regex.Base.RegexLike getAllMatches :: AllMatches f b -> (f b)
06:12:03 <quicksilver> @hoogle m(m a) -> m a
06:12:04 <lambdabot> Control.Monad join :: Monad m => m (m a) -> m a
06:12:04 <lambdabot> Test.QuickCheck.Property joinRose :: Rose (Rose a) -> Rose a
06:12:04 <lambdabot> Prelude concat :: [[a]] -> [a]
06:12:10 <quicksilver> mysticc: ^^ possibly more useful?
06:12:27 <mysticc> quicksilver: Thanks .. I was looking for join actually
06:12:30 <quicksilver> "m m a -> m a" is unlikely to be kind-correct
06:12:43 <quicksilver> unless you're doing something rather unusal with ghc extensions
06:12:46 <mysticc> quicksilver: Maybe (Maybe a) -> Maybe a ...
06:12:54 <mysticc> trivial :P
06:12:56 <quicksilver> indeed.
06:12:59 <quicksilver> join it is.
06:13:46 <danr> Any known names, libraries, or generalisations of this combinator? http://hpaste.org/66356
06:14:01 <joum> hi
06:14:14 <joum> _class_
06:14:59 <joum> >5+7
06:15:23 <killy9999> > 5+7
06:15:24 <lambdabot>   12
06:15:26 <quicksilver> danr: I've seen it discussed once or twice.
06:15:43 <quicksilver> danr: c.f. bool :: Bool -> (a -> r) -> (a -> r) -> r
06:15:45 <danr> quicksilver: I find it very useful with pointfree style
06:15:48 <quicksilver> oops
06:15:51 <quicksilver> danr: c.f. bool :: Bool -> (a -> r) -> (a -> r) -> a -> r
06:16:13 <danr> b ? f = bool b f id, then
06:16:17 <quicksilver> bool True f g = f; bool False f g = g
06:16:19 <quicksilver> yes indeed.
06:16:24 <danr> oh, False first
06:16:32 <danr> oh not
06:16:43 <quicksilver> I'm not sure it's completely standard which way around it.
06:17:05 <quicksilver> the simpler "bool :: Bool -> a -> a -> a" is the natural eliminator for bool
06:17:17 <quicksilver> the a->r version is the 'generalised' version
06:17:25 <quicksilver> conveniently, in haskell, they're the same anyway
06:17:29 <danr> or specialised, I guess?
06:17:30 <quicksilver> (and the generalised one isn't actually more general)
06:17:38 <danr> yes, indeed
06:17:49 <quicksilver> it's called 'general' as part of a logical family of elimination rules
06:18:08 <quicksilver> which all take forms like .... (A -> R) ... (B -> R) .... -> R
06:18:39 <quicksilver> by the magic of curried function and haskell's syntax the general one isn't really more general in this case.
06:19:11 <quicksilver> and, yes, your original one is the special case where one leg is 'id'.
06:19:16 <quicksilver> which restricts the type obviously.
06:19:27 <quicksilver> c.f. the difference between 'maybe' and 'fromMaybe'
06:19:48 <quicksilver> having said all that, I'm not sure I've actually said anything particularly useful.
06:29:27 <Saizan> in which system is bool :: Bool -> (a -> r) -> (a -> r) -> a -> r the more general one?
06:29:44 <Saizan> a strict language, i guess
06:33:24 <quicksilver> Saizan: I *think* it's more general not because it's more general in every case, but because it represents a general schema you can apply to any connective?
06:34:11 <quicksilver> that is, generalised eliminations rules are not more general in any particular case (they have the same logical power) but they represent a general form which can be applied formally to any connective you devise.
06:35:04 <bitonic> -define(DICT, dict).
06:35:06 <bitonic> -define(SETS, sets).
06:44:34 <Saizan> quicksilver: which general schema are you referring to? the church encoding would give us Bool -> r -> r -> r; c.f. either for Either () ()
06:45:49 <quicksilver> Saizan: in the sense of this abstract : http://ls.inf.uni-tuebingen.de/psh/forschung/publikationen/MontreuxAbstractNetz.ps
06:48:46 <quicksilver> Saizan: people seem to cite von Plato [2001] but I think the notion is older.
06:51:16 <snhmib> i notice that Network.HTTP puts together a chunked response completely (when you use simpleHTTP at least) and inserts a content-length header off the total number of bytes in all the chunks, doesn't that break lazy processing of big stuff on a chunked response?
06:52:35 <bitonic> oh. realized now I pasted some erlang in here. sorry about that :P
06:53:06 <int-e> bitonic: better than Java
06:53:22 <bitonic> it was erlang preprocessor actually. that's quite ugly :P
06:53:30 <bitonic> int-e: yeah, more fun for sure
06:55:43 <Saizan> quicksilver: for Bool we should take n = 0, m = 2, Delta1 = Delta2 = (), and so Bool -> (() -> r) -> (() -> r) -> r
06:56:41 <quicksilver> Saizan: yes, I believe you're right :) ah well. High level pattern recognition in human minds prone to false positives.
07:04:25 <Saizan> yeah, and some annoying bystander plays the role of the proof checker :)
07:07:25 <quicksilver> Saizan: on the contrary, clear-thinking bystander provides much-needed correction :)
07:08:56 <snhmib> huu maybe i'm wrong
07:11:51 <Saizan> snhmib: Network.HTTP might do different things depending on which type you use for the body of the Response
07:37:13 * hackagebot yesod-auth-fb 0.10.2 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-0.10.2 (FelipeLessa)
07:39:37 <mysticc> How to write arbitrary instance for data A = B | C | D ...
07:40:40 <sipa> instance for what class?
07:41:01 <bitonic> mysticc: there are tools to derive it automatically
07:41:27 <bitonic> I wrote a patch to add GHC.Generics support to QuickCheck but nobody replied me :P
07:42:10 <danr> bitonic: cool, who did you mail?
07:42:19 <t7> > 2016 / 14
07:42:19 <lambdabot>   144.0
07:42:26 <t7> > 144 / 24
07:42:27 <lambdabot>   6.0
07:42:34 <t7> 1 block every 10 mins :)
07:43:01 <bitonic> danr: yes
07:43:05 <mysticc> sipa: Instance of Arbitrary
07:43:05 <bitonic> to the quickcheck list
07:43:07 <mux> bitonic: I wrote a package to generate automatic NFData (for deepseq) instances using GHC.Generics, but noone cares =)
07:44:01 <mysticc> \me thinks we should kick nobody ..
07:44:10 * mysticc thinks we should kick nobody ..
07:49:54 <dreixel> bitonic: perhaps try haskell-cafe or libraries?
07:50:13 <mysticc> bitonic: I am still confused .. can you tell without the tools as I am learning quickcheck ..
07:50:20 <dreixel> I certainly support adding GHC.Generics stuff
07:50:30 <bitonic> dreixel: danr might merge now :P
07:51:01 <bitonic> mysticc: well if you want to do it manually, you have to use the Gen monad to generate random instances of that ADT
07:51:32 <Elemir> Guys, is there Either-based monad error monad transformer with throwTo implementation?
07:51:45 <dreixel> bitonic: great
07:51:48 <mysticc> my type is simple with only costructors ..
07:54:45 <bitonic> mysticc: well then you probably want to choose each of them with equal probability, and it's really easy to do  that e.g. with 'elements'
07:57:14 * hackagebot acme-http 0.2.0 - fastest Haskell PONG server in the world  http://hackage.haskell.org/package/acme-http-0.2.0 (JeremyShaw)
07:57:29 <merijn> > let (@) n = show n in (@) 5
07:57:30 <lambdabot>   <no location info>: parse error on input `@'
07:57:53 <Fifo> > let (@) n = show n in (@) 5
07:57:54 <lambdabot>   <no location info>: parse error on input `@'
07:58:06 <Fifo> >
07:58:09 <Fifo> > --
07:58:10 <merijn> > let (!) n = show n in (!) 5
07:58:10 <lambdabot>   not an expression: `--'
07:58:10 <lambdabot>   "5"
07:58:20 <merijn> > let (!) n = show n in ! 5
07:58:20 <lambdabot>   <no location info>: parse error on input `!'
07:58:28 <merijn> Operators only work infix?
07:58:29 <Fifo> > let (!) n = show n in (!) 5
07:58:29 <lambdabot>   "5"
07:58:38 <bitonic> merijn: yes
07:58:42 <merijn> Blah
07:58:47 <merijn> I wanted a postfix operator
07:59:10 <Fifo> Please join ##FifoChannel
07:59:34 <bitonic> merijn: you can't in haskell, sorry :P
07:59:46 <merijn> Lousy language ;p
08:00:24 <bitonic> merijn: having just infix has its advantages (sections)
08:00:34 <Fifo> > sort [42,13,22]
08:00:35 <lambdabot>   [13,22,42]
08:00:44 <Fifo> lambdabot: ...
08:01:27 <Fifo> > sort "chris"
08:01:28 <lambdabot>   "chirs"
08:01:40 <Fifo> > (28,"chirs")
08:01:41 <lambdabot>   (28,"chirs")
08:02:02 <Fifo> > fst (28,"chirs")
08:02:03 <lambdabot>   28
08:02:14 * hackagebot acme-http 0.2.1 - fastest Haskell PONG server in the world  http://hackage.haskell.org/package/acme-http-0.2.1 (JeremyShaw)
08:02:21 <Fifo> > let x = 4 in x * x
08:02:22 <lambdabot>   16
08:02:28 <int-e> Fifo: lambdabot replies to private messages, there's no need t spam the channel like that.
08:02:45 <Fifo> int-e: Thanks for replying.
08:07:16 * hackagebot swish 0.6.5.2 - A semantic web toolkit.  http://hackage.haskell.org/package/swish-0.6.5.2 (DouglasBurke)
08:07:18 * hackagebot unfoldable 0.2.0 - Class of data structures that can be unfolded from a seed value.  http://hackage.haskell.org/package/unfoldable-0.2.0 (SjoerdVisscher)
08:11:45 <mekeor> is there a type class (e.g. "Convertible") which includes a method to convert a type A to another type B?
08:12:18 <bitonic> mekeor: there is, and it's named exactly like that
08:12:22 <mekeor> i mean like "class Convertible a b where convert :: a -> b
08:12:29 <mekeor> bitonic: oh, cool :D
08:12:37 <bitonic> @hackage convertible
08:12:37 <lambdabot> http://hackage.haskell.org/package/convertible
08:12:49 <Fifo> Please /join ##FifoChannel!
08:13:01 <bitonic> @where ops
08:13:02 <lambdabot> shapr Cale glguy dons sjanssen dcoutts Saizan dibblego conal Philippa bos arjanb xerox Heffalump kosmikus wli Pseudonym Igloo quicksilver monochrom Lemmih jmcarthur copumpkin
08:13:18 --- mode: ChanServ set +o copumpkin
08:13:18 --- mode: ChanServ set +o dcoutts
08:13:18 --- mode: ChanServ set +o Igloo
08:13:23 <copumpkin> lol
08:13:29 <mekeor> Fifo: please don't spam the channel.
08:13:41 --- mode: ChanServ set -o dcoutts
08:13:43 <Fifo> mekeor: Sorry
08:14:41 <mekeor> bitonic: thank you.
08:16:08 <bitonic> mekeor: yw
08:25:36 <t7> @hoogle readHex
08:25:37 <lambdabot> Numeric readHex :: Num a => ReadS a
08:25:37 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
08:25:50 <t7> i need to read hex as ByteString
08:25:53 <Fifo> @hoogle readHex
08:25:53 <lambdabot> Numeric readHex :: Num a => ReadS a
08:25:53 <lambdabot> Text.Read.Lex readHexP :: Num a => ReadP a
08:25:55 <t7> or [Word8]
08:26:10 <merijn> @hoogle (m a, m b) -> m (a, b)
08:26:11 <lambdabot> No results found
08:26:49 <parcs`> :t uncurry (liftM2 (,))
08:26:49 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
08:27:03 <Fifo> :t uncurry (liftM2) (,))
08:27:04 <lambdabot> parse error on input `)'
08:27:24 <Fifo> :t uncurry (liftM2 (,))
08:27:25 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => (m a1, m a2) -> m (a1, a2)
08:32:12 <merijn> I'm doing (f &&& g)  where f and g are both "a -> IO b" and then I want to pass the b's to a new function. I'm sure there should be an elegant way to do it, but I can't really think of one so far...
08:32:32 <mysticc> I am having a data F a = D (Map String String) | ... .. Now I want to check property of a function f : F a -> String -> F a .. The property to be checked is f g v == f (f g v) v .. But there is one more constraint that String should be a key in the Map part of F .. How to  include this in quickcheck case
08:33:16 <merijn> Ah, wait
08:33:25 <merijn> I think I want "uncurry . liftM2"
08:33:33 <t7> @hoogle Integer -> ByteString
08:33:34 <lambdabot> Data.ByteString.Lazy unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:33:34 <lambdabot> Data.ByteString unfoldr :: (a -> Maybe (Word8, a)) -> a -> ByteString
08:33:34 <lambdabot> Data.ByteString.Lazy.Char8 unfoldr :: (a -> Maybe (Char, a)) -> a -> ByteString
08:33:43 <t7> @hoogle Integer -> [Word8]
08:33:43 <lambdabot> Data.Data gmapQ :: Data a => (forall d. Data d => d -> u) -> a -> [u]
08:33:43 <lambdabot> Data.List unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
08:33:44 <lambdabot> System.Random randoms :: (Random a, RandomGen g) => g -> [a]
08:33:50 <teneen> How to concatenate two parsers in Parsec?
08:35:41 <mysticc> Any help ..!!
08:36:12 <parcs`> teneen: there are many ways
08:37:55 <teneen> parcs`: Can you give a simple example?
08:39:16 <parcs`> do { a <- parser1; b <- parser2; return (a, b) }
08:39:23 <snhmib> t7 maybe readHex isn't the best solution
08:39:40 <parcs`> teneen: that's if you want to retain the value of both parsers
08:39:47 <t7> json is so annoying
08:39:54 <t7> just send binary people!
08:40:05 <snhmib> many more people would complain :P
08:40:10 <clintm> msgpack?
08:40:26 <parcs`> if you don't need the value of the first parser, then do { parser1; parser2 }
08:40:28 <snhmib> > read "0xff" :: Word8
08:40:29 <lambdabot>   255
08:41:05 <parcs`> i should say result instead of value
08:41:07 <teneen> parcs`: so there's no certain combinator, which can combine many parsers into one string?
08:41:26 <Ptival> where could I find info on what "cabal install" does exactly?
08:41:51 <bitonic> Ptival: that monochrom post
08:41:51 <clintm> Any of you who 1. are emacs users, and 2. who set 'haskell-font-lock-symbols' to 't', what font do you use?  I can't seem to find one that has the full set.  Something's always missing, resulting in big boxes here and there.
08:41:52 <Ptival> (except from the source)
08:41:54 <bitonic> @where sicp
08:41:54 <lambdabot> The Wizard book : "Structure and Interpretation of Computer Programs" at <http://mitpress.mit.edu/sicp/> by Hal Abelson,Gerald Jay Sussman with Julie Sussman, videos at <http://swiss.csail.mit.edu/
08:41:54 <lambdabot> classes/6.001/abelson-sussman-lectures/>
08:41:59 <bitonic> the other sicp!
08:42:02 <bitonic> ehe
08:42:27 <bitonic> Ptival: http://www.vex.net/~trebla/haskell/sicp.xhtml
08:42:29 <colock> having problems installing zlib-enum: Not in scope: withInflateInput
08:42:30 <colock> any idea?
08:43:06 <Ptival> bitonic: not "cabal install foo", but "cabal install" without any package name
08:43:15 <parcs`> teneen: if all the parsers result in a String then you can do something like do { rs <- sequence [parser1, parser2, parser3]; return (concat rs) }
08:43:33 <dcoutts_> Ptival: it's the same, it just applies to the package in the current dir
08:43:39 <parcs`> or more succinctly 'fmap concat . sequence'
08:43:46 <JamesJRH> How do I configure login priviledges for Gitit? And how do I make it aware that it is being proxied on /gitit ? Or is there a channel for Gitit or Happstack that I can ask on?
08:43:51 <dcoutts_> Ptival: it's the same as doing cabal install ./
08:43:58 <Ptival> dcoutts_: ok thanks
08:45:04 <parcs`> teneen: is that what you have in mindL?
08:45:40 <Drakken> Good morning, haskellers.
08:45:55 <colock> morning Drakken
08:45:56 <Ptival> bitonic: my answer is not obvious from your post :\
08:46:12 <Drakken> What's the simplest way to parse an L-attributed grammar with left recursion?
08:46:15 <bitonic> Ptival: if what do you want to know more specifically?
08:46:51 <bitonic> Ptival: cabal install fetches the dependencies, does 'configure', than 'build' and then it registers and puts the package in the correct locations
08:46:55 <Ptival> bitonic: the "steps" that are performed
08:46:59 <teneen> parcs`:  Yes, thanks a lot.
08:47:06 <parcs`> teneen: ok, great
08:47:40 <Ptival> bitonic: ok, so I'm interested in build now :d
08:48:44 <Drakken> Is there a better forum to ask about parsers?
08:48:55 <t7> stackoverflow
08:49:36 <gnoi> haskell-kafe
08:51:14 <quicksilver> god no, don't ask about L-attributed left recursion on haskell-cafe
08:52:12 <Drakken> would that start another Never-Ending Debate?
08:52:14 <quicksilver> you'll get 100 responses telling you things you already know about parsec and one tangential 200-email thread about which parsing packages the haskell platform should include.
08:52:41 <quicksilver> generally the answer is you eliminate the recursion by hand, I think, Drakken
08:53:07 <Drakken> camlp4 seems to work for non-attribute grammars.
08:54:08 <bitonic> Drakken: you can transform any left-recursive grammar to a non-left recursive one
08:54:18 <bitonic> but apart from that, since parsec & co. are lazy, you might not even need to
08:54:18 <quicksilver> camlp4 removes recursion automatically?
08:54:22 <mysticc> I am writing Arbitrary instance of a datatype and I am needed to take some elements from the given list l ... so given l generate s such that s is a subset of l .. thought of generating a bounded integral on lenght of l and then repeating oneof that many times.. Is there a better way ?
08:54:34 <quicksilver> it's quite possible to remove recursion programattically but most tool sdon't seem to do so.
08:55:05 <Drakken> When I write the parser in camlp4, I have to duplicate each entry to handle the different attribute values.
08:55:21 <bitonic> Drakken: I mean with parsec & backtracking you can write left-recursive grammars easily...
08:55:24 <Drakken> Yes, camlp4 seems to do something with left-recursive parser calls.
08:55:55 <Drakken> I think I read somewhere that parsec just puts a limit on the recursion depth.
08:56:45 <colock> ok, so i cannot build zlib-enum because zlib-bindins does not have a withInflateInput function. great. I should install the correct version,  i guess
08:57:47 <Saizan> bitonic: only by removing the left recursion, otherwise it's an endless loop
08:58:23 <bitonic> Saizan: yeah but what I meant is that it's still pretty easy since the recursive calls are lazy
08:59:21 <Saizan> bitonic: which lazyness are you referring to, and how does it help?
08:59:57 <Drakken> Aren't the rules for eliminating recursion pretty straightforward?
09:00:07 <bitonic> Saizan: I'm simply referring to the recursive references to the parser, e.g. expr = (char '(' >> expr) <|> whatever
09:00:39 <bitonic> in a strict setting that would loop
09:00:59 <Saizan> in a strict settings expr would be a no-arguments procedure
09:01:21 <quicksilver> incidentally that's not left recursion
09:01:25 <Saizan> right
09:01:31 <bitonic> Saizan: yes, which is why in my experience writing strict parser combinators is quite annoying
09:01:34 <parcs`> right recursion!
09:01:45 <Saizan> bitonic: but left-recursion is another problem entirely
09:01:55 <bitonic> Saizan: yeah yeah absolutely, sorry about the unrelated comment :P
09:02:13 <quicksilver> I did not find strict parser combinators particularly painful
09:02:20 <bitonic> I just meant that usually the process of eliminating left recursion with parsec is quite intuitive, that's all.
09:02:30 <quicksilver> having to eta-expand everything because of the value restriction is unaesthetic
09:02:32 <bitonic> quicksilver: which ones have you used?
09:02:38 <parcs`> even in a strict setting that wouldn't loop because the inner expr is enclosed under a lambda
09:02:38 <bitonic> yeah, very
09:02:39 <quicksilver> but it's not too syntactically heavy
09:02:49 <quicksilver> bitonic: I wrote my own in ocaml a couple of times
09:03:05 <bitonic> when I wrote one in SML it was really annoying. it worked, but it was still very noisy.
09:03:05 <quicksilver> based on the chapter in Paulson's book "learning ML"
09:03:12 <bitonic> quicksilver: yeah, exactly
09:03:44 <quicksilver> I'm not really sure this is about laziness, though
09:03:56 <quicksilver> the value restriction is just ML dirty laundry.
09:03:58 <bitonic> I was following that book as well, but his parser is extremely basic, and parses extremely basic things :P
09:04:13 <bitonic> oh yeah that too
09:04:21 <quicksilver> you could have a strict language which permitted expressions like expr = char '(' >> expr
09:04:32 <quicksilver> it's not inherentl a problem that it's strict I don't think
09:04:50 <quicksilver> although there might be a risk of stack overflow down the line if your recursion depth is limited.
09:05:00 <bitonic> quicksilver: you can by defining all parsers to be () -> whatever (which is what I did), but it's still quick awkward
09:05:11 <colock> ok, explicitly installing zlib-bindings-0.0.0 and manually removing zlib-bindings-0.1.0.1 did the trick :/
09:05:13 <bitonic> anyways, I derailed this discussion :P
09:06:25 <bitonic> *quite awkward
09:07:53 <Drakken> With a hand-written parser, the only way I can think of to implement operator precedence is more extra production rules:  Each operator level has a separate rule for its arguments, which is the next higher precedence term or its arguments.
09:08:14 <Drakken> That's something camlp4 does automatically.
09:08:40 <quicksilver> two-phase parsing is possible, Drakken
09:08:58 <quicksilver> parse the binary operators into an amorphous mess and do precedence resolution later.
09:09:25 <quicksilver> 'happy' has a predence parsing tool as I recally
09:09:38 <quicksilver> happy is perhaps the closest analog to camlp4 although they're pretty different.
09:10:22 <quicksilver> "more production rules" seems like a reasonable answer for a fixed grammar with a tiny list of operators, though.
09:10:56 <Drakken> I was thinking about that.  Just make a flat list of arg op arg op arg ... and then write some kind of recursive function to sort the operators by precedence.
09:11:01 <Saizan> maybe parsec's "expression parsers" handle precedence too?
09:11:13 <bitonic> Saizan: yes
09:11:38 <bitonic> Drakken: http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Expr.html
09:11:54 <quicksilver> that's right
09:11:58 <quicksilver> forgot about them.
09:12:24 <bitonic> that and Text.Parsec.Token are the best thing about parsec :P
09:12:33 <bitonic> sorry, Text.Parsec.Language
09:12:38 <Saizan> that doesn't seem to handle precedence, just associativity
09:12:55 <bitonic> ah no. I meant Token lol.
09:13:09 <bitonic> Saizan: An OperatorTable s u m a is a list of Operator s u m a lists. The list is ordered in descending precedence.
09:13:23 <bitonic> ah.
09:13:30 <bitonic> yeah
09:14:07 <Saizan> ok then :)
09:16:26 <clintm> when given a choice, the modern Haskell programmer chooses 'transformers' over 'mtl'.  Correct?
09:16:50 <Saizan> mtl depends on transformers
09:16:58 <Saizan> adding the classes
09:17:23 <clintm> *blink* oh...  I'm 'high definition' wrong.
09:17:47 <quicksilver> see also http://stackoverflow.com/questions/5797091/monad-transformers-libraries-which-one-to-use
09:18:03 <clintm> ooo... thanks, quicksilver
09:18:08 <parcs`> if you can, use just 'transformers' instead of 'mtl'
09:18:27 <quicksilver> stack overflow is increasingly becoming a curated FAQ
09:18:32 <quicksilver> dunno if that's good or bad
09:18:53 <bitonic> parcs`: if that means writing code without using the Monad classes, no :P
09:18:55 <clintm> parcs`: that's what I've been doing - though I haven't really needed anything outside of transformers yet.
09:19:33 <clintm> quicksilver: I think it's pretty good.  There's far worse places.
09:20:07 <clintm> quicksilver: the moderators seem to be pretty on the ball without being, at least in my experience, over zealous.
09:20:25 <clintm> hrm... overzealous doesn't look right.  over-zealous, maybe.
09:20:28 <bitonic> clintm: mtl let you write much more generic code, and removes all the ugly manual lifting. most of the times you should write code using mtl classes, without worrying about the actual transformer stack at all
09:21:10 <Drakken> thanks for the help
09:21:18 <clintm> bitonic: hrm... no lifting, more generic code.  I think I'm going to end up levelling up my haskell today.  I'm going to start reading on it.  Thanks!
09:22:36 * ski isn't sure he likes the classes
09:22:41 <bitonic> clintm: they're actually really easy to use (the mtl classes). for example if you need a state monad with an Int in it, your type sigs would be like 'MonadState Int m => Foo -> Bar -> m Baz'
09:24:24 <clintm> bitonic: oh... offhand, I think my intuition is only able to get part of the implications of that as opposed to my usual usage that results in "fx :: a -> MaybeT IO String" and the like.
09:24:31 <ski> (but i suspect something better would require type system extensions)
09:24:44 <bitonic> ski: why? the only disadvantage I can think of is that you're screwed when you have the same monads multiple time on the stack
09:24:57 <ski> bitonic : yeah, i'm thinking of that
09:24:59 <clintm> oh wait... no, that's awesome.
09:25:00 <bitonic> so monad stacks are not easily composable
09:25:04 <bitonic> yeah but it's hard to solve that
09:25:13 <ski> it seems to me that one should be able to name the transformers
09:25:30 <ski> (obviously using natural numbers with `lift' to reference them is bad)
09:25:51 <clintm> Damn.... when the typeclassopedia said 'learn how to read types', it/the author/  wasn't joking around.
09:26:37 <ski> (and by "name", i mean name the individual occrances of them in a transformer stack)
09:27:42 <clintm> That must be why there is very little lifting in Snap.  Most of my intermediate haskell has been written in something having to do with snap and web stuff.
09:27:46 <bitonic> ski: yeah but that would allow  you to write generic code anyways. what you can't do now and you should be able to is to have multiple things of the same monad transformers but different overall type, eg StateT Int and StateT String, and then use them with MonadState Int and MonadState String
09:27:50 <clintm> aside from liftIO
09:28:12 <bitonic> *wouldn't allow you
09:28:15 <ski> bitonic : one can of course use `newtype'-wrappings to distinguish different (e.g.) states of the same type -- but that also seems ugly, to me
09:28:29 <quicksilver> ski: I have always felt that if you have multiple instances of the same monad in the same stack you should write your own custom actions
09:28:37 <ski> clintm : yeah, `liftIO' is different
09:28:48 <quicksilver> ski: a complex custom mond should have its own DSL
09:29:03 <ski> quicksilver : what do you mean by "custom actions" here ?
09:29:06 <quicksilver> "getThisBit" and "getThatBit" rather than "get"; although in practice probably something more nuanced.
09:29:30 <bitonic> quicksilver: yeah but you break composability of functions that way
09:29:36 <bitonic> while generic functions are very reusable
09:29:40 <quicksilver> bitonic: in what way?
09:30:00 <ski> (bitonic : oh right, i forgot that one can't do that (the `newtype' thing) either, atm)
09:30:04 <bitonic> quicksilver: I can use MonadState Int with whatever state monad. I can use getThatInt only with my custom monad
09:30:11 <niklasb> quick question: why does `let test = (+5) . flip mod :: (Num a, Integral a) => a -> a -> a` not work?
09:30:12 <quicksilver> absolutely.
09:30:17 <quicksilver> but who cares?
09:30:27 <quicksilver> what remote use is an MonadState Int action?
09:30:36 <quicksilver> have you ever seen a generic MonadState Int action?
09:30:38 <quicksilver> :)
09:30:45 <bitonic> quicksilver: I do. I write code like that all the time
09:30:48 <quicksilver> you can certain provide adapters.
09:30:56 <quicksilver> but MonadState is not a useful abstraction.
09:30:57 <ski> quicksilver : yes, instead of `get' or `getThisBit' or `getThatBit', it should be parameterized by a name
09:31:13 <quicksilver> MonadicLensForInt
09:31:16 <quicksilver> is useful
09:31:36 <quicksilver> because you have a single monad providing N different monadic lenses for different bits of int "state"
09:31:42 <bitonic> quicksilver: It's not "powerful", (it's not even an abstraction really) but it's nice. I personally write almost exclusively generic functions
09:31:45 <hpaste> timthelion pasted “irratic mvar behavior” at http://hpaste.org/66361
09:31:51 <timthelion> Do MVars work at all in ghc 7.0.4?  I'm getting very irratic behavior with them.
09:31:56 <ski> @type let test :: (Num a, Integral a) => a -> a -> a; test = (+5) . flip mod in test
09:31:56 <lambdabot> forall a. (Integral a) => a -> a -> a
09:32:03 <ski> @type let test = (+5) . flip mod :: (Num a, Integral a) => a -> a -> a in test
09:32:03 <timthelion> takeMVar seems to quit the application :(
09:32:04 <lambdabot> forall a. (Integral a) => a -> a -> a
09:32:33 <ski> niklasb : i would suspect DMR, if in that doesn't work for you
09:32:37 <mysticc> @hoogle runTests
09:32:38 <lambdabot> No results found
09:32:49 <parcs`> timthelion: no error message?
09:32:51 * timthelion appoligises in advance for the fact that his code was computer generated and doesn't look very nice.
09:32:52 <mysticc> @hoogle Tests.QuickCheck.Batch
09:32:52 <lambdabot> No results found
09:32:56 <timthelion> parcs`: no error messages.
09:32:59 <niklasb> @ski: DMR? sry i'm new to haskell
09:32:59 <lambdabot> Unknown command, try @list
09:33:02 <timthelion> parcs`: it just quits
09:33:13 <quicksilver> timthelion: are you compiling with -threaded?
09:33:21 <timthelion> quicksilver: no, should I be?
09:33:30 <ski> niklasb : Dreaded Monomorphism Restriction
09:33:31 <quicksilver> yes, you should.
09:33:41 <bitonic> :t (+5) . flip (mod x)
09:33:42 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `Expr'
09:33:42 <lambdabot>     In the first argument of `mod', namely `x'
09:33:42 <lambdabot>     In the first argument of `flip', namely `(mod x)'
09:33:48 <bitonic> :t \x -> (+5) . flip (mod x)
09:33:49 <lambdabot> forall a b. (Num b, Integral (a -> b)) => (a -> b) -> a -> (a -> b) -> b
09:33:57 <bitonic> :t (+5) . flip mod
09:33:58 <lambdabot> forall a. (Integral a) => a -> a -> a
09:34:14 <ski> niklasb : to avoid it, you either need to (a) eta-expand the definition (if possible); (b) add a type signature; or (c) enable the `NoMonomorphismRestriction'
09:34:16 <quicksilver> timthelion: I can't explain why you don't see an error message but my guess is that the error was "blocked indefinitely on MVar" because, without true threading, your program couldn't proceed.
09:34:28 <Peaker> Hey, anyone here knows graphics-drawingcombinators?  I want to make an image half-transparent, but if I tint it to 1 1 1 0.5  then it tints each of the primitives that composes the image separately, which seems incorrect
09:34:58 <ski> niklasb : (b) is probably the simplest (since you already had a type ascription) -- but you might consider (c) as a default anyway, since DMR is a PITA
09:34:58 <timthelion> quicksilver: when I compile with the command $ghc examplegrid.hs -threaded exits instantly without message.
09:35:11 <timthelion> quicksilver: nevermind
09:35:42 <ski> niklasb : also, s/@ski:/ski :/ :)
09:35:42 <niklasb> ski: well, `let test = (+5) . flip mod :: Int -> Int -> Int` works neither... I think i'm doing a very basic mistake here, but I don't see it
09:35:43 <timthelion> quicksilver: when I deleted the excecutable ghc decided to recompile
09:36:04 <Peaker> Having "tint" expose the internal primitives of an image seems like a bug
09:36:04 <ski> niklasb : why not go for (b), add a type signature ?
09:36:17 <niklasb> ski: type signature for what?
09:36:18 <ski> (and no, what you did was *not* a type signature, it was a type ascription)
09:36:22 <ski> for `test'
09:36:31 <ski> like
09:36:32 <ski> @type let test :: (Num a, Integral a) => a -> a -> a; test = (+5) . flip mod in test
09:36:33 <niklasb> ski: same if I write it in a source file this way
09:36:33 <lambdabot> forall a. (Integral a) => a -> a -> a
09:36:34 <quicksilver> timthelion: so it works now?
09:36:45 <timthelion> quicksilver: threaded changes the behavior, but does not work
09:37:10 <niklasb> ski: http://pastie.org/3715415
09:37:25 <quicksilver> timthelion: I'm reasonably sure MVars aren't broken, anyhow, thousands of programs rely on them.
09:37:39 <ski> @type let test :: Int -> Int -> Int; test = (+5) . flip mod in test
09:37:40 <lambdabot> Int -> Int -> Int
09:37:46 <ski> niklasb : seems to work fine
09:38:23 <niklasb> ski: I don't see what I'm doing wrong, I'm basically only loading that exact source into GHCi using :load Test.hs
09:38:32 <ski> what is the error that you get ?
09:39:03 <niklasb> ski: http://pastie.org/3715425
09:39:26 <niklasb> ski: so do i need to add a type declaration for the (+5)?
09:39:40 <ski> ah, oh right
09:39:59 <ski> you're wanting to pass the two arguments to `mod', right ?
09:40:05 <niklasb> ski: yes
09:40:08 <ski> you want `.:', not `.'
09:40:09 <timthelion> quicksilver: Sorry, my aunt called.  I'm reasonably sure that my program should work.  Despite it's awquard syntax, it's very simple.  Furthermore, a very similar bit of code worked flawlessly on ghc 4.7.1.
09:40:31 <niklasb> ski: ahh, I see! thanks
09:40:44 <niklasb> of course, composition only works for functions taking one argument...
09:40:46 <quicksilver> timthelion: is it possible you're being confused by the fact that the second call to 'getChar' gets a newline character?
09:41:01 <ski> > let test :: Integral a => a -> a -> a; test = (+5) .: flip mod in zipWith test [7,7,-7,-7] [15,-15,15,-15]
09:41:03 <lambdabot>   [6,11,-1,4]
09:41:09 <ski> > let test :: Integral a => a -> a -> a; test = ((+5) .) . flip mod in zipWith test [7,7,-7,-7] [15,-15,15,-15]
09:41:11 <lambdabot>   [6,11,-1,4]
09:41:13 <quicksilver> timthelion: ...or that the program terminates when the main thread is done?
09:41:17 <ski> niklasb : yes
09:41:24 <quicksilver> timthelion: (these strike me as two possible confusing points in understanding that code)
09:41:25 <ski> (more or less)
09:41:30 <timthelion> quicksilver: aha, program terminates when main thread is done
09:41:42 <timthelion> quicksilver: that would be it.  Parent thread terminates, thank you
09:41:43 <niklasb> ski: what do you mean? :) willing to learn
09:41:47 <quicksilver> timthelion: :)
09:42:06 <timthelion> quicksilver: honestly, it never occured to me
09:42:17 <ski> niklasb : there is no problem using `.' with functions that take more than one argument, but for all that `.' cares, they only take one argument
09:42:35 <ski> niklasb : i.e. `.' will just thread one argument, ignoring potential others
09:42:40 <niklasb> ski: yeah, they're curried. okay
09:42:46 <niklasb> so the second function needs to take a partially applied function
09:43:03 <niklasb> can you quickly tell me where (.:) is defined?
09:43:10 <ski> > (mod . negate) 5 3
09:43:12 <lambdabot>   1
09:43:27 <ski> this is the same as `mod (negate 5) 3'
09:43:40 <niklasb> nice
09:43:45 <ski> the `.' only threads one argument, but that doesn't stop `mod' from being able to take another one
09:43:54 <ski> `.:' is defined in lambdabot
09:44:30 <ski> i invented it as `infixr 9 .:; (.:) = (.) . (.)'
09:44:31 <niklasb> ski: okay, so i'll take it as a quick exercise to define it
09:44:40 <niklasb> meh :P
09:44:41 <ski> also `infixr 9 .::; (.::) = (.) . (.) . (.)', &c.
09:44:58 <ski> niklasb : someone put it in a package somewhere, as well
09:45:06 * ski tries to recall which
09:46:33 <timthelion> quicksilver: is there a "wait indefinitely and do nothing" command?
09:46:49 <dmwit> timthelion: forever (threadDelay 1e6)
09:47:06 <timthelion> dmwit: and that isn't processor intensive I hope?
09:47:26 <dmwit> Try it and see. =)
09:47:51 <timthelion> dmwit: that's what my dad told me about the LSD.  Now I ask first.
09:48:09 <dmwit> There will be no permanent effects of trying this code.
09:48:18 <dmwit> And it will take about as long to ask your computer as it would to ask me.
09:49:02 <ski> niklasb : sorry, can't recall atm
09:49:17 <niklasb> ski: no problem at all, seeing that it's a one-line def :)
09:49:48 <niklasb> thank you very much
09:50:04 <timthelion> dmwit: hmm     No instance for (Fractional Int)
09:50:20 <ski> niklasb : anyway, the type ascription you did first threw me off from the main problem
09:50:40 <ski> @type 1e6
09:50:41 <lambdabot> forall t. (Fractional t) => t
09:50:51 <dmwit> timthelion: I bet you know how to fix it.
09:51:04 <timthelion> dmwit: I do
09:51:10 <ski> @type 10 ^ 6
09:51:11 <lambdabot> forall t. (Num t) => t
09:51:15 <timthelion> dmwit: did so already :)
09:52:18 * hackagebot smtp2mta 0.2 - Listen for SMTP traffic and send it to an MTA script  http://hackage.haskell.org/package/smtp2mta-0.2 (StephenWeber)
09:52:37 <aib> @pl (\x -> x > 4 && x < 42)
09:52:37 <lambdabot> liftM2 (&&) (> 4) (< 42)
09:53:20 <aib> ...and I've been wondering why liftM doesn't work *headdesk*
09:53:30 <clintm> Hrm... I don't see it, but I thought I'd ask anyway: is there an 'mtl' compliment package for Maybe?
09:54:17 <clintm> bah, I should use Error anyway - error messages are nice.
09:56:33 <bitonic> clintm: if you're asking for a MonadMaybe, I don't think there is one.
09:56:44 <dmwit> There's MaybeT
09:56:47 <bitonic> or MonadPartial maybe.
09:56:54 <bitonic> dmwit: I think he wants a related type class
09:57:18 * hackagebot intern 0.9 - Efficient hash-consing for arbitrary data types  http://hackage.haskell.org/package/intern-0.9 (EdwardKmett)
09:57:28 <companion_cube> coo
09:57:29 <dmwit> MonadError
09:57:29 <companion_cube> cool
09:57:44 <clintm> bitonic: yea, that's fine, I've always thought of my use of MaybeT from transformers as a bit of a lazy way out.  It's just a style thing, but I like to know what happened in the event of something unexpected.
09:57:44 <dmwit> ...is in mtl
09:58:09 <timthelion> dmwit: This doesn't work, since then I cannot quit the program.  Even System.exitWith doesn't work.  My sollution?...  Make an MVar called die, and take+put that MVar at the end of threads that should wait, and put that MVar using the thread who's end should kill the application.
09:58:11 <clintm> dmwit: that's what I'm refactoring to now. :)
09:58:34 <bitonic> dmwit: I thought he wanted something without the error, just a generic "fail".
09:59:21 <dmwit> timthelion: You asked for a "wait indefinitely" command. If you wanted a "wait until I say so" command, you should have said so.
10:00:01 <timthelion> dmwit: ;)  I don't even know what I want anymore.  Maybe I should quit programming and start a screemo deathmetal band
10:00:09 <dmwit> heh
10:01:37 * ski . o O ( picnic at hanging rock )
10:04:35 <clintm> timthelion: let me write songs for you.  I'll call the first one "These fscking monads"
10:05:04 <timthelion> dmwit: "I want that thread to die! Die! Die slowly, slowly die, waiting for the put of a mother fuckin MVar"
10:06:36 <timthelion> clintm: I think we'll have to take turns
10:06:45 <clintm> timthelion: works for me.
10:08:38 <clintm> ugh... 'type NewM = ErrorT String IO' and 'type NewM = ErrorT String IO Thing' are both legal, and, according to my poking via ghci, equivalent?  Does the former just imply an open type the nature of which will be decided later, and the latter actually more limiting, or is my intuition failing me already?
10:09:15 <dmwit> They are not equivalent.
10:09:27 <dmwit> The former can be used as "NewM Thing" or "NewM Bool"; the latter can't.
10:10:00 <dmwit> In fact, even "type NewM a = ErrorT String IO a" and "type NewM = ErrorT String IO" aren't equivalent, though that one is a bit more subtle.
10:10:35 <parcs`> why doesn't eta reduction get done there?
10:10:45 <dmwit> That's a perfectly legitimate question.
10:10:52 <dmwit> I think doing that has been proposed on the mailing lists.
10:10:54 <clintm> dmwit: I guess that wasn't exactly fair of me... the equivalent remark was a thinly veiled provocation of sorts.
10:11:51 <dmwit> (In fact, what was suggested was even a bit more sophisticated and involved some kind of analysis I didn't quite understand of multiple type aliases.)
10:13:50 <clintm> dmwit: so I was, maybe, 20% correct - it does leave the door open for any reasonable type, where ErrorT String IO Thing limits you to results of type IO Thing or String...
10:14:05 <clintm> just confirming my current 'intuition score'.
10:17:37 <dmwit> yes
10:18:15 <dolio> The current rule is pretty simple.
10:18:26 <clintm> dmwit: if you don't mind, or someone else, could you explain the subtleties in the difference between 'type NewM a = ErrorT String IO a" and 'type NewM = ErrorT String IO' ?  I can't reason out what they might be.
10:18:29 <dolio> The alternative is more difficult to spot.
10:20:07 <clintm> now that I've typed that, I bet there's a stackoverflow question regarding this. heh.
10:21:36 <parcs`> clintm: you can't partially apply a type synonym so in the former, using just NewM in a place where a type of kind * -> * is expected is invalid
10:24:05 <clintm> parcs`: good lord, that makes 90% sense.  I'm getting around the complete implications of * -> *
10:24:19 <monadic> hey
10:25:30 <timthelion> > reverse "yeh :cidanom"
10:25:30 <lambdabot>   "monadic: hey"
10:25:58 <parcs`> clintm: well for example 'StateT Int NewM String' would not work
10:26:04 <parcs`> :k StateT
10:26:05 <lambdabot> * -> (* -> *) -> * -> *
10:26:41 <parcs`> :k ErrorT String IO
10:26:42 <lambdabot> * -> *
10:27:29 <ski> @kind ErrorT String ReadS
10:27:29 <lambdabot> * -> *
10:28:01 <clintm> parcs`: I think I get it, though it definitely hasn't congealed yet.  I think I need to do some poking in the repl and emacs.
10:28:18 <clintm> parcs`: thanks for the explanation, by the way.
10:29:20 <ski> clintm : anyway, the restriction in `type NewM a = ... a' vs. `type NewM = ...' could be lifted -- but the one re `NewM :: * -> *' vs. `NewM :: *' can't
10:29:58 <parcs`> yeah kinds take a little while getting used to
10:30:46 <clintm> I'm one of those that you can talk and explain all day, but after a point, I just won't get it until I fiddle with it for a while.
10:30:47 <ski> well, it's basically the same as the type system, except one level up (and simpler)
10:30:57 * ski nods
10:31:03 <ski> experience is good
10:31:20 <aib> what's the best way to conditionally build a list?  Nothing : if x then Just 'x' else Nothing : if y then Just 'y' else Nothing : [] -- is there a Maybe-free way?
10:32:15 <ski>   ((if x then ('x':) else id) . (if y then ('y':) else id)) []
10:32:30 <ski>   ['x' | x] ++ ['y' | y]
10:32:43 <zhulikas> @hoogle [Maybe a] -> [a]
10:32:44 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
10:32:44 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
10:32:44 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
10:32:56 <ski> aib : there might be more sensible options
10:33:40 <aib> having a hard time trying to think of them.. hell, maybe I'm going about this the wrong way. Never used Graph before
10:33:49 <zhulikas> @hoogle [a] -> (a -> Maybe b) -> [Maybe b]
10:33:49 <lambdabot> Control.Monad forM_ :: Monad m => [a] -> (a -> m b) -> m ()
10:33:49 <lambdabot> Prelude mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
10:33:49 <lambdabot> Control.Monad mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
10:33:50 <clintm> don't forget your friend the 'monkey operator', as I like to call it.  (:[])
10:33:53 <ski>   runWriter $ do when x (tell "x"); when y (tell "y")
10:34:44 <aib> actually... I want to solve http://projecteuler.net/problem=15 using a graph. any suggestions?
10:35:22 <ski> @type flip (map `asAppliedTo` Just)
10:35:23 <lambdabot> forall a. [a] -> (a -> Maybe a) -> [Maybe a]
10:35:57 <ski> @type flip (map `asAppliedTo` const Nothing)  -- hrm
10:35:58 <lambdabot> forall a a1. [a] -> (a -> Maybe a1) -> [Maybe a1]
10:36:06 <zhulikas> more like this :)
10:36:18 <ski> zhulikas : what are you trying to do ?
10:36:23 <zhulikas> nothing
10:36:29 <zhulikas> that was kind of my suggestion for aib :D
10:36:37 <zhulikas> to conditionally construct a list
10:36:37 <ski> oh
10:36:53 <ski> i suppose you mean that, in composition with `catMaybes', then
10:36:58 <zhulikas> yes
10:37:22 <ski> @type catMaybes .: map
10:37:23 <lambdabot> forall a a1. (a1 -> Maybe a) -> [a1] -> [a]
10:37:32 <dmwit> :t \f xs -> [x | Just x <- map f xs]
10:37:33 <lambdabot> forall a t. (a -> Maybe t) -> [a] -> [t]
10:37:50 <ski> @hoogle (a -> Maybe b) -> ([a] -> [b])
10:37:50 <lambdabot> Data.Maybe mapMaybe :: (a -> Maybe b) -> [a] -> [b]
10:37:51 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:37:51 <lambdabot> Control.Monad mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:38:06 <dmwit> :t \f xs -> [y | x <- xs, Just y <- [f x]]
10:38:07 <lambdabot> forall t t1. (t -> Maybe t1) -> [t] -> [t1]
10:38:14 <aib> I was trying to avoid maybes altogether but yeah, those functions seem good to know about
10:38:14 * ski forgets `mapMaybe'
10:38:17 <dmwit> Depends which you think is more readable.
10:38:22 <zhulikas> oh, that's interesting :)
10:38:29 <dmwit> aib: Oh, without Maybe is even easier.
10:38:29 <zhulikas> I didn't expect there to be such function
10:38:40 <dmwit> :t \p f xs -> [f x | x <- xs, p x]
10:38:41 <lambdabot> forall t t1. (t -> Bool) -> (t -> t1) -> [t] -> [t1]
10:39:30 <ski> aib : hm, an interleaving problem
10:40:24 <dmwit> aib: Just looked at the problem description. Why do you want to use a graph?
10:40:51 <dmwit> This is a very straightforward dynamic programming problem. Shouldn't need any data structure more complicated than [].
10:40:59 <ski> > mergeByM (\_ _ -> [True,False]) "rr" "dd"  -- this is the `2' times `2' case
10:41:01 <lambdabot>   ["rrdd","rdrd","rddr","drrd","drdr","ddrr"]
10:41:18 <honza> Does anyone know of a short program that I can use to try out +RTS -Nx?
10:41:20 <dmwit> Oh, beautiful. Don't even need dynamic programming!
10:41:28 <aib> dmwit: well I want to learn to use Graph/fgl for one thing
10:41:38 <dmwit> Just plain combinatorics.
10:42:00 <ski> dmwit : well, i suspect the dynamic programming solution is more efficient
10:42:12 <dmwit> ski: Than combinatorics? No way!
10:42:23 <ski> than `mergeByM' above
10:42:29 <dmwit> Oh, yeah, probably.
10:42:45 <zhulikas> @hoogle mergeByM
10:42:45 <lambdabot> No results found
10:42:48 <zhulikas> uhm
10:42:50 <zhulikas> @type mergeByM
10:42:51 <lambdabot> forall a (m :: * -> *). (Monad m) => (a -> a -> m Bool) -> [a] -> [a] -> m [a]
10:42:51 <aib> I'm already stuck at the "build graph. find cycles." stage in another problem
10:42:54 <ski> > length (mergeByM (\_ _ -> [True,False]) `join` replicate 20 undefined)
10:42:57 <lambdabot>   mueval-core: Time limit exceeded
10:43:04 <dmwit> > let choose n k = product [n - k + 1 .. n] `div` product [2 .. k] in 4 `choose` 2
10:43:05 <lambdabot>   6
10:43:11 <dmwit> > let choose n k = product [n - k + 1 .. n] `div` product [2 .. k] in 20 `choose` 10
10:43:11 <lambdabot>   184756
10:43:14 <ski> zhulikas : defined in the obvious way
10:43:22 <dmwit> I bet 184756 is the answer to problem 15. =P
10:43:29 <dmwit> oops
10:43:35 <dmwit> > let choose n k = product [n - k + 1 .. n] `div` product [2 .. k] in 40 `choose` 20
10:43:35 <lambdabot>   137846528820
10:43:39 <dmwit> That one, I mean.
10:44:03 <aib> did you take "backtrack" to mean "go left or up" or "go back a path that was already crossed"?
10:44:35 <dmwit> The diagrams in problem 15 clearly show that going left or up are not allowed.
10:45:13 * ski wonders who mentioned "backtracking"
10:45:27 <dmwit> ski: The Project Euler problem mentions backtracking.
10:46:00 <aib> oh, right. you can still go left/up and solve it without going back a path in the example.. my bad
10:46:06 <ski> oh, right
10:46:48 <ski> aib : i think the intension is that you may only go down or right
10:47:07 <dmwit> I agree with ski.
10:47:25 <ski> (so going left or up using edges and nodes which haven't been used before is still not allowed)
10:48:05 <ski> otherwise there would be more than six solutions to the `2' times `2' problem
10:48:19 <yasar> Can I compare different types in haskell? For example, Can Int, Integer and Float types can be equated with each other?
10:48:39 <ski> yasar : they are different types
10:48:42 <aib> yeah, yeah. I thought the example was too small to show which sense of "backtrack" was being used. I see that it's clearly the left/up one now.
10:48:45 <ski> not sure what you mean by "compare" here
10:48:53 <dmwit> yasar: Yes, but not with (==).
10:49:11 <ski> yasar : what are you wanting to do ?
10:49:38 <aib> bah, it's just combinatorics now
10:49:52 <dmwit> > let compareIntInteger :: Int -> Integer -> Bool; compareIntInteger int integer = fromIntegral int == integer in compareIntInteger 3 3
10:49:53 <lambdabot>   True
10:49:54 <yasar> ski: Nothing spesific, I was just wondering if I could say 1 == 1.0
10:50:00 <dmwit> > 1 == 1.0
10:50:01 <lambdabot>   True
10:50:13 <ski> aib : still might be fun to write a program that (more or less) generates the solutions, instead of just doing the combinatorics numbers
10:50:15 <dmwit> (But there, both 1 and 1.0 are Double.)
10:50:35 <zhulikas> > 1::Int == 1.0::Double
10:50:36 <lambdabot>   <no location info>: parse error on input `1.0'
10:50:40 <zhulikas> woops
10:51:10 <parcs`> :t cast
10:51:11 <lambdabot> forall a b. (Typeable a, Typeable b) => a -> Maybe b
10:51:23 <parcs`> > cast 1 == 1.0
10:51:24 <lambdabot>   No instance for (GHC.Real.Fractional (Data.Maybe.Maybe b))
10:51:24 <lambdabot>    arising from ...
10:51:32 <parcs`> > cast 1 == Just 1.0
10:51:33 <lambdabot>   False
10:51:36 <parcs`> :t (===)
10:51:37 <lambdabot> Not in scope: `==='
10:51:46 <ski> @type \a -> maybe False (a ==) . cast
10:51:47 <lambdabot> forall a a1. (Eq a, Typeable a1, Typeable a) => a -> a1 -> Bool
10:51:47 <dmwit> parcs`: cast only returns Just when a ~ b
10:51:49 <aib> ski: and I still need to learn how to use a graph library anyway
10:51:54 <ski> aib : ok
10:52:02 <parcs`> dmwit: yeah, it seems pretty useless
10:52:20 * hackagebot attoparsec-conduit 0.4.0 - Turn attoparsec parsers into sinks.  http://hackage.haskell.org/package/attoparsec-conduit-0.4.0 (MichaelSnoyman)
10:52:50 <ski> parcs` : why ?
10:55:04 <parcs`> ski: i don't see a use case for it
10:55:07 <parcs`> do you have one?
10:55:13 <ski> of `cast' ?
10:55:16 <parcs`> yeah
10:55:27 <aib> dmwit: your previous solution would be the number of combinations of replicate 20 L ++ replicate 20 R, right?
10:55:27 <ski> or of having `Maybe' in the type of it ?
10:55:34 <dmwit> parcs`: For example, in implementing a heterogeneous container.
10:55:47 <ski> s/L/D/
10:56:16 <parcs`> dmwit: how exactly would cast be used?
10:56:23 <ski> dmwit : it would probably be nicer with typed keys, though
10:56:41 <dmwit> parcs`: Stick it in an existential box on its way in, cast it on its way out.
10:56:42 <ski> parcs` : well, i think dmwit would use `Dynamic', there
10:56:54 <ski> @src Dynamic
10:56:55 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
10:56:55 <dmwit> Dynamic is a particularly convenient existential box, yes.
10:57:16 <dmwit> aib: That's not totally clear to me. Usually combinations are assumed to be drawn from a set, not a bag.
10:57:22 * hackagebot blaze-builder-conduit 0.4.0 - Convert streams of builders to streams of bytestrings.  http://hackage.haskell.org/package/blaze-builder-conduit-0.4.0 (MichaelSnoyman)
10:57:24 * hackagebot conduit 0.4.0 - Streaming data processing library.  http://hackage.haskell.org/package/conduit-0.4.0 (MichaelSnoyman)
10:57:26 * hackagebot filesystem-conduit 0.4.0 - Use system-filepath data types with conduits.  http://hackage.haskell.org/package/filesystem-conduit-0.4.0 (MichaelSnoyman)
10:57:28 * hackagebot imagesize-conduit 0.4.0 - Determine the size of some common image formats.  http://hackage.haskell.org/package/imagesize-conduit-0.4.0 (MichaelSnoyman)
10:57:30 * hackagebot network-conduit 0.4.0 - Stream socket data using conduits.  http://hackage.haskell.org/package/network-conduit-0.4.0 (MichaelSnoyman)
10:58:06 <parcs`> dmwit: i see. why would you want a heterogenous list in the first place? it seems that you would be better off with a list of a sum type that can hold all the types that you would be casting to
10:58:12 <dmwit> aib: Choosing 20 positions in the length-40 string to mark as R (and marking all the rest as D) seems like a much clearer explanation of how to compute the answer.
10:58:18 <ski> we want `lookup1 :: Eq1 key => Map1 key value -> (key i -> Maybe (value i))' -- but how to generate new keys dynamically ?
10:58:33 <aib> dmwit: sorry. how about "combinations of length 40 drawn from [Right,Down] where there are 20 of each" ?
10:58:54 <aib> dmwit: right :)
10:58:56 <dmwit> parcs`: Because I want to abuse the open-world assumption to allow the multiple clients (who don't know anything about each other) to choose which types can be put in.
11:00:15 <dmwit> parcs`: (I, personally, have never wanted it. But I'm playing devil's advocate here.)
11:02:29 * ski for one welcomes our new dynamic overlords
11:02:32 * hackagebot zlib-conduit 0.4.0 - Streaming compression/decompression via conduits.  http://hackage.haskell.org/package/zlib-conduit-0.4.0 (MichaelSnoyman)
11:02:34 * hackagebot shakespeare 1.0.0 - A toolkit for making compile-time interpolated templates  http://hackage.haskell.org/package/shakespeare-1.0.0 (MichaelSnoyman)
11:09:37 <aib> if I have a combination function (combinations 3 "abcd") should I use Int, Integer or Integral a in the signature? it probably won't ever run with k > 2G, but it's a style thing.
11:10:43 <dmwit> For something like Project Euler, I'd probably just leave the type signature off.
11:10:44 <aib> I pattern-match the integer with 0 and use (-) on it, if it matters
11:10:50 <ChristianS> aib: i would make it as broad as reasonable.
11:11:06 <dmwit> Let GHC infer the most general type.
11:12:20 <aib> it infers Num a. should I use Num?
11:13:24 <dmwit> Sure, why not?
11:14:02 <byorgey> because combinations 2.4 "abcd" doesn't really make sense?
11:15:29 <dmwit> If I want "ab" and two-fifths "c", who are you to stop me??!
11:15:41 <aib> I'd have thought it would run forever (recursion with 2.4 1.4 0.4 -0.6 -1.6...) but I guess it matches 0 in the pattern
11:15:49 <byorgey> I wouldn't stop you, but the Combinatorics Police might
11:16:06 <dmwit> wait, what?
11:16:15 <dmwit> > let f 0 = "done"; f n = f (n-1) in f 2.4
11:16:19 <lambdabot>   mueval-core: Time limit exceeded
11:16:29 <dmwit> aib: You lie!
11:17:10 <Fabi> hello
11:17:12 <byorgey> aib: are you sure you don't have a check for  <= 0  or something?
11:17:16 <byorgey> hi Fabi
11:18:00 <aib> huh. I guess the list runs out before the number.
11:18:25 <aib> sorry, this place is getting increasingly unsuitable for thinking
11:18:44 <byorgey> aib: it has been for years.
11:18:58 <aib> I mean my physical location. now, phone calls... eugh!
11:19:06 <byorgey> oh, hehe, I thought you meant #haskell =)
11:19:28 <aib> nah, I love this place when I'm not being a complete idiot like right now
11:19:58 <aib> well, maybe not complete. 0 concentration /= 0 intelligence
11:22:49 <JamesJRH> I have some functions in a .hs file. If I copy-paste they work fine, but if I use :l there is a parse error. Any ideas why this is?
11:23:21 <c_wraith> JamesJRH: not without know more about the parse error
11:23:32 <c_wraith> "a parse error" isn't very descriptive
11:23:59 <Kucuq> I though i understood monads, but I never used them. Could somebody remove the do suggar from this littel pice of code?     http://pastebin.com/iKn0A6cQ
11:24:02 <mauke> The paste iKn0A6cQ has been copied to http://hpaste.org/66364
11:25:02 <dmwit> Kucuq: look "greeting" >>= \greeting -> look "noun" >>= \noun -> ok $ greeting ++ ", " ++ noun
11:25:14 <Kucuq> thanks
11:26:22 <JamesJRH> c_wraith: That's what I thought when it gave me this silly message:
11:26:24 <JamesJRH> triples.hs:2:0: parse error (possibly incorrect indentation)
11:26:38 <c_wraith> JamesJRH: are you using tabs?
11:26:44 <JamesJRH> No.
11:26:47 <dmwit> Kucuq: See the "Translation" box at http://www.haskell.org/onlinereport/exps.html#sect3.14 (the official language specification).
11:27:14 <JamesJRH> c_wraith: It works if I copy-paste though.
11:27:21 * hackagebot dtd 0.5.0 - Parse and render DTD files  http://hackage.haskell.org/package/dtd-0.5.0 (MichaelSnoyman)
11:27:23 * hackagebot uri-conduit 0.4.0 - Read and write URIs  http://hackage.haskell.org/package/uri-conduit-0.4.0 (MichaelSnoyman)
11:27:25 * hackagebot xml2html 0.1.2 - blaze-html instances for xml-conduit types  http://hackage.haskell.org/package/xml2html-0.1.2 (MichaelSnoyman)
11:27:25 <dmwit> JamesJRH: Just put your code and the exact error on hpaste.org.
11:27:30 <c_wraith> JamesJRH: then it's hard to say what the problem is, without seeing the code. It's likely to be an indentation error.
11:27:36 <dmwit> JamesJRH: We can't do anything useful until we can reproduce your problem.
11:27:54 <byorgey> JamesJRH: what do you mean, if you copy-paste?  If you copy the contents of the file into a new file?  Or do you mean if you paste them one line at a time into ghci?
11:28:14 <JamesJRH> byorgey: Yes, line by line.
11:28:30 <JamesJRH> dmwit, c_wraith: I'll do that now.
11:29:57 <hpaste> “James Haigh” pasted “triples.hs” at http://hpaste.org/66365
11:30:15 <aib> see you all later
11:30:27 <c_wraith> JamesJRH: you can't use let at the top-level in source files
11:30:32 <dmwit> "let" is unnecessary in files. Also, top-level commands (like "indexed_triples_1000") are not allowed.
11:31:34 <JamesJRH> Err, so what I type at GHCi, I can't just put it in a file and run it?
11:31:36 <hpaste> mekeor annotated “triples.hs” with “triples.hs (annotation)” at http://hpaste.org/66365#a66366
11:31:42 <mekeor> JamesJRH: ^ ?
11:32:07 <JamesJRH> mekeor: Right, thanks.
11:32:14 <mekeor> JamesJRH: yes, that's right.
11:32:27 * hackagebot xml-catalog 0.7.0 - Parse XML catalog files  http://hackage.haskell.org/package/xml-catalog-0.7.0 (MichaelSnoyman)
11:32:29 * hackagebot xml-conduit 0.7.0 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.7.0 (MichaelSnoyman)
11:32:31 * hackagebot xml-hamlet 0.3.0 - Hamlet-style quasiquoter for XML content  http://hackage.haskell.org/package/xml-hamlet-0.3.0 (MichaelSnoyman)
11:35:44 <JamesJRH> Hey? 'Warning: Use camelCase'?? Camel-case is usually discouraged in programming because it looks rubbish and other reasons. Underscores are better.
11:36:44 <sclv_> JamesJRH: the haskell world tends to use camel case.
11:36:55 <sclv_> so hlint, which makes style suggestions, in turn suggests camel case.
11:37:05 <sclv_> if you were running hlint locally, you could turn off that suggestion.
11:37:07 <bscarlet> JamesJRH: Absolute statements are bad.
11:37:25 <sclv_> always!
11:40:46 * ski thinks hyphenated-words looks nice
11:41:56 <ski> Kucuq : for future reference :
11:41:57 <ski> @undo do greeting <- look "greeting"; noun <- look "noun"; ok $ greeting ++ ", " ++ noun
11:41:57 <lambdabot> look "greeting" >>= \ greeting -> look "noun" >>= \ noun -> ok $ greeting ++ ", " ++ noun
11:42:45 <Kucuq> @undo do 		greeting <- look "greeting" 		ok $ greeting ++ ", "
11:42:45 <lambdabot>  Parse error at end of input
11:43:08 <ski> Kucuq : remove the tabs
11:43:33 <ski> Kucuq : also, use `;' instead of line-breaks, here
11:43:38 <Kucuq> @undo do greeting <- look "greeting" ; ok $ greeting ++ ", "
11:43:38 <lambdabot> look "greeting" >>= \ greeting -> ok $ greeting ++ ", "
11:43:42 <ski> (since you can't give multiple lines to lambdabot)
11:44:23 <ski> @undo do [a,b] <- getArgs; putStrLn (a ++ b)
11:44:24 <lambdabot> getArgs >>= \ c -> case c of { [a, b] -> putStrLn (a ++ b); _ -> fail ""}
11:44:48 <Authoritarianism> Is there any way to pattern-match the numerator and denominator in a Data.Ratio.Ratio?
11:45:52 <JamesJRH> bscarlet: What are 'absolute statements'?
11:46:14 <ski> > let numerator :% denominator = 12 / 10 in (numerator,denominator)
11:46:15 <lambdabot>   Not in scope: data constructor `:%'
11:46:18 <bscarlet> JamesJRH: for example, "Underscores are better," or "absolute statements are bad."
11:46:21 <ski> > let numerator Data.Ratio.:% denominator = 12 / 10 in (numerator,denominator)
11:46:22 <lambdabot>   Not in scope: data constructor `Data.Ratio.:%'
11:47:04 <ski> > let (numerator &&& denominator -> (n,d)) = 12 / 10 in (n,d)
11:47:04 <lambdabot>   (6,5)
11:47:09 <ski> @type numerator
11:47:10 <lambdabot> forall a. (Integral a) => Ratio a -> a
11:47:13 <ski> @type denominator
11:47:14 <lambdabot> forall a. (Integral a) => Ratio a -> a
11:47:26 <ski> Authoritarianism : i think that's the best you can get
11:47:29 <Authoritarianism> ski: Nice, thanks!
11:47:39 <ski> (that uses `ViewPatterns')
11:47:48 <Kucuq> I got it, thanks.
11:47:50 <ski> @src Ratio
11:47:50 <lambdabot> data (Integral a) => Ratio a = !a :% !a
11:49:17 <JamesJRH> If I capitalise the first letter, is that also CamelCase?
11:50:13 <c_wraith> JamesJRH: As far as haskell standards are concerned, yes.  But be aware that things starting with a capital letter are syntactically different in haskell.
11:51:38 <JamesJRH> c_wraith: Oh? In what way? It's just a name.
11:51:39 <sclv_> one cap is dromedaryCase, two caps are BactrianCase
11:52:15 <byorgey> things starting with lowercase letters are variables, things starting with uppercase letters are constructors.
11:52:16 <c_wraith> JamesJRH: tokens starting with capital letters are considered to be constructors or concrete types, depending on the context.
11:52:34 <JamesJRH> sclv_: Out of the 2, I prefer the later.
11:53:33 <ski> > let A = 0 in A
11:53:34 <lambdabot>   Not in scope: data constructor `A'Not in scope: data constructor `A'
11:55:12 <JamesJRH> byorgey, c_wraith: Ok, well I'm not using dromedaryCase. It's just ugly. Is this ok?: _BactrianCase
11:55:23 <byorgey> JamesJRH: no, it's ugly.
11:55:26 <sclv_> that's horrible!
11:55:52 <sclv_> (also i should clarify that the names i gave were jokes -- dromedaries have one hump, bactrians two)
11:56:03 <sclv_> if you want to use underscores, feel free to do so instead of camelcase
11:56:07 <c_wraith> JamesJRH: not only does it look bad, it's lying by convention. names that start with _ mean "unused", by convention
11:56:09 <sclv_> nobody will care. it's not that big a deal.
11:56:40 <sclv_> there's just a common style that people tend to use, and it gets recommended by (the very opinionated) hlint.
11:56:54 <JamesJRH> sclv_: Oh! Lol. I thought they were proper names. :-P
11:56:55 <c_wraith> JamesJRH: but the convention is even ingrained by the compiler. It will warn you about unused name bindings, unless they start with _
11:57:14 <sclv_> right -- convention for starting with underscores.
11:57:24 <JamesJRH> c_wraith: Ok.
11:57:26 <sclv_> i just mean that medial_underscores_seperating_words is fine.
11:57:34 <ski> JamesJRH : i think there's an option that warns about unused variables. starting with `_' will override that
12:01:22 <Clint> i need an algorithm to tell me the position of the leftmost 1 bit in an octet
12:01:49 <dmwit> x & (x-1)
12:01:59 <dmwit> I lied.
12:02:18 * Clint squints.
12:02:25 <dmwit> I'm sure it's on here, though.
12:02:27 <dmwit> http://graphics.stanford.edu/~seander/bithacks.html
12:02:42 <JamesJRH> sclv_: Well I'll just stick with underscores as separators like I'm use to in other languages. I'm no fan of CamelCase at all, especially if the capitalisation of the first letter is syntactically significant.
12:03:23 <JamesJRH> Can I use '#!' in a .hs file?
12:03:59 <Clint> dmwit: thanks
12:06:25 <dmwit> Clint: http://graphics.stanford.edu/~seander/bithacks.html#RoundUpPowerOf2 perhaps
12:06:26 <JamesJRH> How do I make this work?: $ ./triples.hs
12:06:41 <dmwit> JamesJRH: You don't. You make this work: runhaskell triples.hs
12:06:55 <dmwit> JamesJRH: (You can probably use #! in a .lhs file, though.)
12:07:09 <dmwit> Really, though, why not just compile the damn thing?
12:09:23 <JamesJRH> dmwit: Oh, of course! I forgot about that. I'm to used to interpreted languages. How do I do this? ghc triples.hs ?
12:11:49 <dmwit> Looks good (assuming a modern GHC).
12:11:58 <dmwit> ghc --make triples.hs otherwise
12:11:58 <ski> JamesJRH : `#!/usr/bin/runhaskell' works, though
12:13:21 <JamesJRH> ski: Yes, I got that now, thanks.
12:13:55 <ski> yeah, but it works in `*.hs' as well, not only `*.lhs'
12:14:36 <JamesJRH> I'm just using .hs, what is .lhs?
12:14:51 <copumpkin> literate haskell
12:14:54 --- mode: copumpkin set -o copumpkin
12:14:59 <DMcGill_> http://www.haskell.org/haskellwiki/Literate_programming
12:15:42 <Sgeo> >5 + 5
12:16:04 <Elemir> 10
12:16:06 <t7> space man
12:16:13 <JamesJRH> Hmm, both 'runhaskell triples.hs' and './a.out' return output in blocks of 2048. Can I change this?
12:16:14 <Sgeo> > 5 + 5
12:16:15 <lambdabot>   10
12:16:16 <t7> i allways wanted you to go into space man
12:16:16 <Sgeo> Ok
12:16:18 <ski> @karma+ Elemir
12:16:18 <lambdabot> Elemir's karma raised to 1.
12:16:27 <copumpkin> JamesJRH: turn off stdout buffering, maybe?
12:16:33 <JamesJRH> copumpkin, DMcGill_: Thanks.
12:16:58 <JamesJRH> copumpkin: How?
12:17:01 <Sgeo> I thought the answer was A
12:17:01 <Sgeo> ;)
12:17:02 <t7> @karma+ t7
12:17:02 <lambdabot> You can't change your own karma, silly.
12:17:05 <ski> @hoogle hSetBuggering
12:17:06 <lambdabot> No results found
12:17:07 <t7> >:(
12:17:11 <ski> @hoogle hSetBuffering
12:17:11 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
12:17:11 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
12:17:12 <Sgeo> 10 seems a bit high
12:17:12 <ski> :)
12:17:13 <copumpkin> ski: nice freudian slip
12:17:21 * ski grins
12:17:51 <DMcGill_> @hoogle BufferMode
12:17:52 <lambdabot> System.IO data BufferMode
12:17:52 <lambdabot> GHC.IO.Handle data BufferMode
12:17:52 <lambdabot> Graphics.Rendering.OpenGL.GL.Framebuffer data BufferMode
12:18:06 <ski> @karma+ t7
12:18:07 <lambdabot> t7's karma raised to 1.
12:18:10 <ski> satisfied ?
12:18:19 <DMcGill_> can lambdabot print off the constructors for a data type?
12:18:32 <ski> @hoogle NoBuffering
12:18:32 <lambdabot> System.IO NoBuffering :: BufferMode
12:18:33 <lambdabot> GHC.IO.Handle NoBuffering :: BufferMode
12:18:33 <t7> DMcGill_: @src ?
12:18:36 <ski> @hoogle LineBuffering
12:18:36 <lambdabot> System.IO LineBuffering :: BufferMode
12:18:36 <lambdabot> GHC.IO.Handle LineBuffering :: BufferMode
12:18:44 <ski> @hoogle BlockBuffering
12:18:45 <lambdabot> System.IO BlockBuffering :: (Maybe Int) -> BufferMode
12:18:45 <lambdabot> GHC.IO.Handle BlockBuffering :: (Maybe Int) -> BufferMode
12:18:49 <DMcGill_> @src BufferMode
12:18:50 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
12:18:51 <t7> @karma erus`
12:18:51 <lambdabot> erus` has a karma of 0
12:18:56 <t7> :O
12:19:12 <t7> i thought i was a valued member of the haskell community
12:19:22 <ski> `src' just contains a small hand-written database
12:19:31 <copumpkin> t7: oh, you're erus/
12:19:33 <copumpkin> ?
12:19:44 <copumpkin> preflex: seen erus
12:19:45 <preflex>  erus was last seen on #haskell 67 days, 1 hour, 49 minutes and 40 seconds ago, saying: But.. But... The wikipidia
12:19:45 <t7> yeah
12:19:49 <copumpkin> aha :)
12:20:05 <t7> preflex: seen erus`
12:20:05 <preflex>  erus` was last seen on #haskell 42 days, 2 hours, 37 minutes and 37 seconds ago, saying: you jelly? u mad?
12:20:17 <dmwit> DMcGill_: The haddocks have the constructors.
12:20:32 <t7> what was the date 42 days ago
12:20:36 <ski> t7 : well, they're different accounts (not that i think lambdabot would understand it anyway)
12:20:46 <DMcGill_> I was just wondering if we could inumerate it here in chat
12:20:55 <DMcGill_> unless there's a @haddock command I don't know baout
12:21:03 <dmwit> No, I don't think you can.
12:21:12 <copumpkin> I hope lambdabot isn't innumerate
12:21:15 <mk> if functions aren't in Eq, and functions must return the same (equivalent) value when given certain arguments, then how are second-order functions accounted for?
12:21:34 <DMcGill_>  enumerate of course ;)
12:21:45 <copumpkin> mk: can you rephrase
12:21:50 <dmwit> mk: Don't confuse Eq with extensional equality.
12:22:17 <shachaf> mk: You can talk about functions being the same even if you can't compare arbitrary functions.
12:22:31 <mk> copumpkin: second order functions return values (functons) that aren't equal between two invocations of the same function
12:22:32 <dmwit> There's at least three good kinds of equality between Haskell terms: decidable equality (e.g. Eq), intensional equality (e.g. are they defined the same way?), and extensional equality (e.g. do they have the same behavior?).
12:22:45 <copumpkin> mk: there's a distinction between a decision procedure and an equivalence
12:22:49 <shachaf> And unsafeCoerce# equality
12:22:50 <copumpkin> mk: I've never heard that term
12:23:11 <mk> dmwit: the extensional point sounds on the right track
12:23:11 <copumpkin> mk: in fact, it almost sounds like a contradiction to call what you said a function
12:23:43 <copumpkin> mk: oh, I think I get what you're asking
12:24:05 * dmwit points hopefully at Scott domains
12:24:14 <copumpkin> mk: if referential transparency means that for equal inputs, a function returns equal outputs, then how can we even talk about a function like (A -> B) -> C being referentially transparent?
12:24:20 <copumpkin> mk: is that what you're asking?
12:24:24 <mk> shachaf: well, compare (>) is a bit broad. I just want equality - that's probably what you meant
12:24:27 <ski> @source System.IO
12:24:27 <lambdabot> http://darcs.haskell.org/packages/base/System/IO.hs
12:24:49 <ski> apparently `BufferMode' is ultimately defined in `GHC.IO.Handle.Types', though
12:24:58 <shachaf> mk: I meant compare as in equality. :-)
12:25:39 <shachaf> mk: Anyway, the functions (\x -> x :: Bool) and (\x -> x == True) are clearly "equal" in some sense, right?
12:25:48 <shachaf> (In particular, extensionally, as dmwit mentioned.)
12:25:52 <mk> copumpkin: yes, though I also mentioned Eq, and functions not being in it
12:25:58 <JamesJRH> Can I flush the buffer twice a second, rather than set a lower buffer?
12:26:20 <shachaf> mk: Well, Eq is just a type class. :-)
12:26:21 <dmwit> JamesJRH: Yes, spawn a thread that does hFlush stdout >> threadDelay 2000000
12:26:24 <dmwit> or whatever
12:26:34 <shachaf> mk: There's also the problem that function equality in general is undecidable.
12:26:41 <shachaf> Type class or otherwise.
12:26:49 <copumpkin> mk: the distinction is between an underlying notion of equality and a decision procedure for it, then. Eq carries a decision procedure called (==) that is supposed to decide whether two things are equal or not. Extenional equality of (most) functions isn't decidable, so it can't have an Eq instance, but you can still say two things are equal if you have a proof of it
12:27:03 <shachaf> mk: But that doesn't mean that *talking* about it doesn't make sense -- it's very easy to define extensional equality, even if you can't compute it.
12:27:07 <mk> dmwit: so Eq is not meant to capture referential transparency?
12:27:16 <dmwit> mk: Definitely not.
12:27:52 <ski> mk : however, if `a == b = True', then `a' and `b' are supposed to be equal
12:28:07 <ski> iow `forall a b. a == b = True => a = b' ought to hold
12:28:17 <shachaf> ski: Well, you could have two different Sets that are (==) but have a different structure.
12:28:24 <dmwit> Aren't there some... yeah, what shachaf said.
12:28:31 <ski> (using observational/extensional equality, of course)
12:28:34 <mk> shachaf: right, I follow the undecidability problem, and the halting problem
12:28:45 <mk> (sorry delay, backlog of responses)
12:29:23 <ski> shachaf : though i agree Mercury distinguishes better between abstract equality and representational equality than Haskell
12:29:26 <dmwit> I think, practically speaking, there are some data types for which the Eq instance is a decision procedure for a coarser equality than extensional equality.
12:29:51 <dmwit> ...such as shachaf's Set example, where two different balancings of the same Set ought to compare as equal.
12:29:52 <shachaf> ski: Fair enough -- you're never supposed to export the constructor when you pull tricks like that, so observationally you're not supposed to be able to tell.
12:30:24 <shachaf> ski: I'm glad you agree with me on that -- I wish I knew what Mercury's solution was. :-)
12:30:28 <mk> ski: abstract vs. representational?
12:30:38 <ski> shachaf : in Mercury, when you have a user-defined (=)/2 for an abstract type, then unwrapping a value of that type to get at the representation is an "unsafe" (using Haskell terminology) operation, and you have to promise that you don't break the observational equality
12:31:19 <JamesJRH> Oh, wow! Haskell uses STM!
12:31:26 <ski> mk : like in `data Set a = MkSet (MyTree a)', `Set a' is the abstract type and `MyTree a' is the representation
12:31:33 <copumpkin> JamesJRH: and better than everyone else!
12:31:46 <ski> semantically, the abstract type is a quotient type of the representation type (or maybe of a subtype of the representation type)
12:31:50 <shachaf> copumpkin: That's not saying all that much...
12:32:04 <shachaf> (Does anyone else *actually* use STM?)
12:32:20 <ski> shachaf : and stating a promise to the compiler which isn't true invokes undefined behaviour
12:32:25 <copumpkin> clojure supposedly does
12:32:48 <mk> ski: like you can represent the same 2dpoint using a struct that (relative to 0,0) contains int x y, and another that contains int dist float rotation?
12:33:41 <mk> or how (immutable) arraylists and linkedlists in Java should be equal?
12:33:46 <ski> shachaf : see <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html> for an explanation of the Mercury approach
12:34:03 <ski> mk : yes, that's another example
12:34:26 <ski> mk : but in that case, two points are equal iff their representations are equal
12:34:35 <ski> not so with sets and maps, usually
12:35:02 <mk> ski: not sure I follow your statement about points
12:35:47 <ski> shachaf : re "you're never supposed to export the constructor when you pull tricks like that" -- the compiler don't know about this, though, and i think this restricts potential optimizations^Wimprovements
12:35:51 <companion_cube> are you comparing haskell and mercury because both are pure languages?
12:36:10 <ski> mk : the same point can't be represented in two different ways, using those representation
12:36:13 <mk> for example, xy(0,1) and len-rot(1,90deg) should be equal, even though the rep is different
12:36:22 <ski> (well, except for the origin in polar coordinates, i suppose)
12:36:35 <ski> mk : for sets, you can represent the same set as two different trees
12:37:09 <shachaf> ski: Well, you could have data Point = Cartesian R R | Polar R R, and not normalize points when you construct them.
12:37:17 <ski> mk : you're talking about comparing values from different representation types there -- i was talking about comparing values from the *same* representation type
12:37:35 <ski> shachaf : *nod*, so then we get a quotient type again
12:38:00 <shachaf> Another example would be saying that (2 % 1) == (4 % 2).
12:38:32 <shachaf> You have no idea how (4 % 2) is represented -- just that you can Show it in reduced form and compare it to (6 % 3) and so on.
12:38:34 <mk> I see. So for example len-rot(10,0deg) and len-rot(10,360deg)
12:38:42 <ski> ("quotient type" just means that two values can be (semantically) equal even if the representations aren't -- in effect, it means that the "constructor(s)" shouldn't be thought of as *injective* functions, anymore)
12:38:51 <dmwit> mk: Anyway, leaving aside the coarseness of Eq, referentially transparent means even the representations you get out are equal (provided the representations you put in are equal).
12:38:55 <shachaf> mk: That would be another example (probably).
12:39:30 <ski> (and that's exactly what happens in Mercury -- if you match a set `Set' on `set(ListRep)', then that is a (committed-choice) *nondeterministic* match)
12:39:55 <ski> mk : yes
12:40:02 <shachaf> Referential transparency in Haskell usually means a stronger type of equality than this "observational equality".
12:40:13 <ski> (assuming you allow non-normlalized arguments)
12:40:38 <shachaf> So "fromList list :: Set" will always give you a Set which is *structurally* the same, even if you can't observe it
12:41:13 <mk> dmwit: I don't see much of an issue there, because we might assume co-decidability for different representations (the function that takes linkedlists, and the one that takes arraylists)
12:41:19 <ski> shachaf : yes, but we'd like to allow optimizations which don't preserve representations
12:42:03 <mk> ski: what is the equality between different representations, which I brought up, called?
12:42:05 <companion_cube> ski: is mercury worth learning, as an alternative to prolog?
12:42:08 <shachaf> ski: Right. And you could do that, but the function is arguably not "referentially transparent" at that point.
12:42:08 <monochrom> almost everyone eventually proposes pure arrays to change internal representation under your nose
12:42:23 <ski> dmwit : .. and i think one wouldn't neccesarily want to enforce that
12:42:44 <ski> dmwit : consider computing the result using concurrency or randomness internally
12:43:11 <ski> mk : which do you mean ?
12:43:56 <JamesJRH> copumpkin, shachaf: I really don't know why more people don't use Haskell.
12:43:58 <mk> ski: referential equality is when the same representation types have equal "values" (0deg, 360deg). What about when two different representations have the same values?
12:44:17 <shachaf> More people are not using Haskell than ever before.
12:44:24 <shachaf> Every second another non-Haskell-user is born.
12:44:45 <t7> shachaf: yeah but what about percentage of population?
12:44:51 <t7> which is growing quicker?
12:45:33 * edwardk gives in and posts a rant on records on his blog
12:45:45 <ski> companion_cube : you should probably learn basic Prolog as well (partially because there's not that much learning material for Mercury) -- but Mercury is definitely interesting as a logic programming language -- unlike Prolog, it is pure, has a static type system (with type classes), a static mode and determinism system
12:46:15 <ski> companion_cube : some kinds of flexible nice logic programming things in Prolog aren't so easily translated to Mercury, though
12:46:57 <ski> (if the support for unique modes and for definite aliasing gets better, it would get easier)
12:47:28 <companion_cube> ski: you mean, cut?
12:47:42 <shachaf> edwardk: I wish I could see it.
12:47:45 <ski> shachaf : maybe not in Haskell, but in Mercury they would be, imo
12:47:46 <shachaf> edwardk: But, y'know, Comcast.
12:48:04 <companion_cube> I wonder whether learning a logic language would help me for logic-related programs, using built-in unification and indxing
12:48:06 <ski> companion_cube : cut, assert[az]/1,retract/1, var/1, side-effecting I/O
12:48:10 <edwardk> shachaf: wow, still glitching?
12:48:26 <shachaf> edwardk: Well, DNS lookup for comonad.com is failing.
12:48:27 <edwardk> shachaf: let me try something
12:48:33 <ski> companion_cube : could well be
12:48:41 <companion_cube> thanks
12:49:05 <edwardk> i'll point one of the domains i didn't get moved off of godaddy to it
12:49:15 <edwardk> (they bounced a bunch and i need to go back and fight with them)
12:49:20 <ski> companion_cube : learning at least one logic programming language is good. and Prolog is the main one. learning Mercury after Prolog shouldn't be that hard, if you understand the type system of Haskell (or the MLs)
12:49:42 <ski> companion_cube : oh, i forgot to say. Mercury also has a proper module system
12:50:41 <ski> shachaf : in Mercury, the equivalent of `data Set a = MkSet (SetRepr a)' would make `MkSet' a non-injective function
12:51:14 <Peaker> conal: Hey, you there?
12:51:15 <ski> (because they distinguish more clearly between the abstract type and the representation type -- see the link i mentioned above)
12:51:38 <ski> companion_cube : there are both ##prolog and #mercury here, btw
12:51:54 <companion_cube> ski: so, some reflection abilities of prolog are not in mercury, but mercury has a module system, and a type system, is that it?
12:52:13 <ski> Mercury is pure, in the same sense that Haskell and Clean is
12:52:21 <ski> no side-effects
12:52:27 * hackagebot web-routes-wai 0.22.1 - Library for maintaining correctness of URLs within an application.  http://hackage.haskell.org/package/web-routes-wai-0.22.1 (JeremyShaw)
12:52:49 <ski> companion_cube : Mercury also has a static mode&determinism system
12:53:11 <ski> but if you haven't seen any LP, it's harder to explain what that is
12:53:41 <ski> (Mercury also has support for FP, with functions and lambda)
12:53:59 <companion_cube> no, i'm familiar with prolog, although I did not write much code in t
12:54:00 <companion_cube> it*
12:54:32 <companion_cube> what do you call 'determinism system' then?
12:54:56 <tgeeky_> edwardk: you didn't make that blog post in time for April 1st.
12:55:09 <ski> companion_cube : ok, then consider calls like : (a) `append([0,1,2],[3,4],List)'; (b) `append([0,1,2],Suffix,[0,1,2,3,4])'; (c) `append(Prefix,Suffix,[0,1,2])'
12:55:15 <edwardk> tgeeky_: yes, because i was serious
12:55:37 <tgeeky_> edwardk: but but but
12:55:39 <tgeeky_> edwardk: hehe
12:55:44 <ski> companion_cube : in (a), we call append in the (+,+,-) mode; in (b), the (+,-,+) mode; in (c), the (-,-,+) mode
12:56:05 <companion_cube> (c) yields several results, doesn't it?
12:56:06 <ski> companion_cube : `+' meaning "input" and `-' meaning "output" (assuming the call succeeds)
12:56:09 <ski> yes
12:56:22 <`Jake`> Hi guys, on lyah.com, Miran writes that if you write "Right 3 >>= \x -> return (x + 100)" (Control.Monad.Error must be imported), ghci will give you an Error because you must add a type declaration. But if I try it in ghci, it works! Did I do something wrong? (It's here: http://learnyouahaskell.com/for-a-few-monads-more#error)
12:56:29 <ski> we say that the (+,+,-) mode has determinism `det', meaning that it will always have one solution
12:56:34 <`Jake`> not lyah.com, but you know what I mean
12:56:44 <ski> we say that the (+,-,+) mode has determinism `semidet', meaning that it will have at most one solution
12:56:55 <ski> we say that the (-,-,+) mode has determinism `multi', meaning that it will have at least one solution
12:56:59 <companion_cube> oh, I see
12:57:08 <companion_cube> so you can optimize a det as a function
12:57:09 <ski> there's also a determinism `nondet' meaning it can have any number of solutions
12:57:22 <ski> companion_cube : e.g., yes
12:57:27 * hackagebot multiarg 0.2.0.0 - Combinators to build command line parsers  http://hackage.haskell.org/package/multiarg-0.2.0.0 (OmariNorman)
12:57:43 <dmwit> edwardk: Simultaneously hilarious and depressing.
12:57:50 <edwardk> dmwit: =)
12:58:13 <ski> companion_cube : and in Mercury, since it has functions (unlike Prolog), this also applies to functions. so you can have a "backwards" mode of a function, allowing you to define stuff like `foo([0,1] ++ Xs) = ..Xs..'
12:58:32 <tgeeky_> edwardk: maybe if we get to 2^7, we can impose a group structure
12:58:41 <companion_cube> ski: what is '..' ?
12:58:48 <tgeeky_> edwardk: by the way, have you found anything useful in your little library of Alexandria?
12:58:57 <edwardk> ?
12:58:58 <ski> companion_cube : in this case calling the function (++)/2 in the backwards mode with left argument input, result input, and right argument output (and this has deterministm `semidet', of course)
12:59:02 <companion_cube> ski: oh, a bit like +k patterns in Haskell
12:59:10 <yan_> is there a built in function that provides a sliding window over lists? i.e. 'slide 3 [a,b,c,d,e,f...] -> [[a,b,c],[b,c,d],[c,d,e]...]
12:59:18 <edwardk> oh, haven't looked yet
12:59:22 <ski> companion_cube : `..Xs..' just means any expression potentially using `Xs'
12:59:31 <companion_cube> ok
12:59:33 <ski> companion_cube : yes, except (++)/2 is an ordinary function
12:59:42 <tgeeky_> edwardk: too busy helping xkcd guy make awesome things?
12:59:56 <ion> > takeWhile (not . null) . map (take 3) . iterate (drop 1) $ [0..4]
12:59:57 <lambdabot>   [[0,1,2],[1,2,3],[2,3,4],[3,4],[4]]
13:00:19 <dmwit> > map (take 3) . tails $ [0..4]
13:00:20 <lambdabot>   [[0,1,2],[1,2,3],[2,3,4],[3,4],[4],[]]
13:00:32 <yan_> and i'd just filter if i only want 3-tuples?
13:00:33 <companion_cube> ski: yes, of course, as long as it's syntactic (unifiable)
13:00:36 <ski> companion_cube : so, this is a more natural way to do "views"
13:01:00 <Saizan> `Jake`: no, you didn't, but the Monad instance for (Either e) changed after that paragraph got written
13:01:02 <companion_cube> looks very interesting
13:01:10 <ski> companion_cube : but you realize that to match on `[0,1] ++ Xs', it has to match the input argument elements with `0' and `1', using an equality
13:01:30 <ion> > do [a,b,c] <- map (take 3) . tails $ [0..4]; return (a,b,c)
13:01:32 <lambdabot>   [(0,1,2),(1,2,3),(2,3,4)]
13:01:37 <`Jake`> Saizan: Thanks, I guess I might write an E-mail to Miran about that
13:01:41 <Saizan> `Jake`: it doesn't require e to be an instance of the Error typeclass anymore, so you don't get that error
13:01:53 <ion> > [ (a,b,c) | [a,b,c] <- (map (take 3) . tails) [0..4] ]
13:01:54 <lambdabot>   [(0,1,2),(1,2,3),(2,3,4)]
13:01:57 <edwardk> tgeeky_: meh i just answered a few questions, i had no idea what they were doing =P
13:01:59 <ski> and it uses the built-in equality (=)/2, which must agree with semantical equality (unlike `(==)' in Haskell, where we merely like for that to be the case)
13:02:02 <`Jake`> Saizan: OK, I see
13:02:42 <tgeeky_> edwardk: i was rather impressed with the result. It sort of seems anti-WWW to make a page which intentionally looks different in all kinds of situations, but somehow it worked.
13:02:56 <companion_cube> ski: so, it would be more interesting to be able to deduce whether [a,b]++Xs matches [0,1,...] for some user definable =/2 ?
13:03:01 <edwardk> *nods*
13:03:30 <hiato> Hey guys, quick question here: Why does data (Num a) => Foo a = Bar a give an error and what does "Illegal Datatype Context" mean?
13:03:33 <edwardk> now davean gets to try to get all his patches into everything upstream
13:03:51 <ski> companion_cube : yes, and that is possible, if you make a user-defined (=)/2, for a user-defined abstract type -- see <http://www.mercury.csse.unimelb.edu.au/information/doc-latest/mercury_ref/User_002ddefined-equality-and-comparison.html>
13:03:57 <companion_cube> edwardk: did you write a hashconsing package?
13:03:57 <davean> edwardk: haha, 5 years later ...
13:04:19 <edwardk> companion_cube: yes, a long time ago =)
13:04:20 <companion_cube> ski: mercury `compiles' to C, right?
13:04:27 <hiato> (also, that code used to run on older versions of ghc, IIRC)
13:04:36 <companion_cube> edwardk: ok, I think I saw an update on hackage today
13:04:44 <ski> hiato : adding constraints on a `data' (or `newtype') definition like that doesn't work in an sensible way
13:04:59 <ski> hiato : it has been disabled by default in GHC, because of this
13:05:05 <edwardk> yeah, i removed a feature from it to make it more sound to do certain optimized instances in my as yet unreleased foreign package
13:05:09 <ski> (it was more or less a mistake in the 98 definition)
13:05:21 <edwardk> i use it there to memoize the constructions of ffilib ffi_cif and ffi_type structures
13:05:28 <hiato> ski: oh. Ok, so that is interesting.
13:05:49 <ski> hiato : the problem was that one'd like that matching on a constructor of that type brought the constraint into scope, but that's not what actually happens there
13:05:57 <edwardk> and mokus had a neat way to avoid having to store the identities
13:06:17 <ski> hiato : also, one still has to add the contraints in type signatures, when using the type
13:06:39 <edwardk> basically what i want is a nice call :: Foreign a => FunPtr a -> a  class that just does the right thing and deals with structure passing, etc.
13:06:39 <ChristianS> hiato: actually, constraints in data type declarations have been forbidden by the haskell 2010 report and ghc is just following the latest standard, if i remember correctly.
13:06:44 <hiato> ski: ok, so I see. So just leave the type unconstrained?
13:06:51 <hiato> and then enforec it in functions?
13:07:02 <hiato> Ok, heh
13:07:25 <ski> hiato : if you want to get the constraint into scope when match, you should use GADT syntax instead
13:07:37 <hiato> ski: right
13:07:38 <ski> hiato : yes, that is what is usually done, but also see ^
13:08:30 <edwardk> hiato: constraints on the data type never did what you probably wanted anyways
13:08:54 <edwardk> since all they were were constraints you had to satisfy, they were never supplied back to you when you needed them later
13:08:55 <hiato> ok, thanks guys
13:10:50 <ski> companion_cube : it has several backends, high-level C, low-level C, assembler, C#, IL, Java, Erlang
13:11:20 <ski> but i think some of these aren't complete (not all standard libraries available)
13:11:44 <monochrom> wait, what? mercury is on... hackage?!
13:11:47 <companion_cube> ski: does it has some support for concurrency? and ffi?
13:11:56 <ski> yes, and yes
13:12:04 <jay_gridley> hello guys, I need an advice, I am reading user input using readLn function. I want accept only String input from user, so I do it like this... do line <- readLn :: IO(String) and when user type in something that is not String, he gets error *** Exception: user error (Prelude.readIO: no parse), but I want to specify my error message, how can I do that? Thanks!
13:12:11 <ski> hiato : with GADT syntax, you'd say `data Foo a where Bar :: Num a => a -> Foo a'
13:12:32 <companion_cube> ski: ok, i'll definitely take a look :)
13:12:34 <jay_gridley> I need something like try {} catch {} from imperative languages...
13:12:38 <monochrom> at this rate, gcc will be on hackage in 10 years
13:12:49 <dmwit> jay_gridley: Use getLine and reads instead of readLn.
13:13:07 <ski> @hoogle catch
13:13:08 <lambdabot> Prelude catch :: IO a -> (IOError -> IO a) -> IO a
13:13:08 <lambdabot> System.IO.Error catch :: IO a -> (IOError -> IO a) -> IO a
13:13:08 <lambdabot> Control.OldException catch :: IO a -> (Exception -> IO a) -> IO a
13:13:08 <ski> @hoogle catchJust
13:13:09 <lambdabot> Control.OldException catchJust :: (Exception -> Maybe b) -> IO a -> (b -> IO a) -> IO a
13:13:09 <lambdabot> Control.Exception.Base catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
13:13:10 <lambdabot> Control.Exception catchJust :: Exception e => (e -> Maybe b) -> IO a -> (b -> IO a) -> IO a
13:13:12 <ski> @hoogle try
13:13:13 <lambdabot> Control.OldException try :: IO a -> IO (Either Exception a)
13:13:14 <lambdabot> System.IO.Error try :: IO a -> IO (Either IOError a)
13:13:16 <lambdabot> Control.Exception.Base try :: Exception e => IO a -> IO (Either e a)
13:13:22 <ski> @hoogle tryJust
13:13:24 <lambdabot> Control.OldException tryJust :: (Exception -> Maybe b) -> IO a -> IO (Either b a)
13:13:24 <dmwit> No need for exceptions and exception-catching.
13:13:25 <ski> &c.
13:13:26 <lambdabot> Control.Exception.Base tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
13:13:28 <lambdabot> Control.Exception tryJust :: Exception e => (e -> Maybe b) -> IO a -> IO (Either b a)
13:13:30 <aristid> monochrom: right after the hackage singularity
13:14:28 <ski> jay_gridley : what dmwit suggested is probably better
13:19:16 <jay_gridley> dmwit: can you give me some quick example how to use what you have sugegsted?
13:19:52 <dmwit> > reads "\"Hi, jay_gridley!\""
13:19:53 <lambdabot>   []
13:19:57 <monochrom> I should write tutorials on both the exception mechanism and on how to use reads without exceptions
13:20:01 <dmwit> > reads "\"Hi, jay_gridley!\"" :: [(String, String)]
13:20:02 <lambdabot>   [("Hi, jay_gridley!","")]
13:20:14 <dmwit> > reads "lexical error" :: [(String, String)]
13:20:15 <lambdabot>   []
13:21:23 <jay_gridley> dmwit: thanks
13:21:32 <monochrom> however, a reads tutorial is deemed pretty low-value because you move quickly to a real parser and forget about line-by-line input behind you
13:22:32 <monochrom> in the same sense that in C beginners may need help on scanf but it's just for educational toys
13:22:59 <mauke> scanf has its uses but it's definitely not for beginners
13:24:13 <monochrom> no, sscanf has production uses, but scanf is rare in production code
13:25:13 <monochrom> or perhaps I'm just giving a very low weight to microcontroller console input code when I count
13:25:29 * ski ponders writing a `scanf' in Haskell
13:26:18 <ski> > (reads :: ReadS Int) "496cruft"
13:26:46 <ski> dmwit : why not write like that instead ?
13:26:48 <ski> jay_gridley ^
13:27:34 <monochrom> @botsnack
13:29:45 <jonkri> for some reason, after forkIO'ing an io operation, my main thread freezes (on hSetBuffering of all things). any ideas why this could be? (what is supposed to happen when a forkIO thread throws an exception?)
13:34:52 <cgroza> Hello everyone. Does anyone know of an algorithm to parse a regexp?
13:36:27 <dcoutts> jonkri: when an exception occurs and propagates all the way back up to where it was forkIO'd, then the thread dies
13:36:42 <dcoutts> (though annoyingly I think currently it prints something to stderr)
13:39:19 <jonkri> dcoutts, so the main thread should die?
13:39:38 <dcoutts> jonkri: sorry I wasn't clear, the forkIO'd thread dies
13:39:57 <dcoutts> the parent thread is unaffected
13:40:24 <dcoutts> if you want to do something else, install an exception handler at the top level of your forkIO action
13:42:59 <jonkri> thanks :)
13:45:30 <jay_gridley> one more: May I redefine how call of funtion error is shown? It gives *** Exception: "text" and I want only "text"
13:46:42 <shachaf> jay_gridley: It sounds like you're doing something vaguely evil.
13:46:49 <shachaf> jay_gridley: What are you using this for?
13:47:39 <jay_gridley> I am making some parser and in case I find for example semantic error, I simply call error with message, but I dont like output formating for error function :-)
13:48:14 <Liskni_si> the formatting is different when you compile it, it's just programname: message
13:48:47 <shachaf> jay_gridley: Normally you would return the error using some other error mechanisms -- parser libraries usually have something for that.
13:51:40 <JamesJRH> dmwit: Nope, I'm confused. How do I spawn a thread for hFlush stdout >> threadDelay 500000 ?
13:52:26 <JamesJRH> Is it a one liner to spawn a thread?
13:52:35 <Lemmih> JamesJRH: forkIO
13:56:33 <c_wraith> though you probably want a forever in there, too.
13:58:40 <JamesJRH> Lemmih: Do I have to import forkIO?
14:01:09 <c_wraith> JamesJRH: it's in Control.Concurrent
14:12:58 <kallisti> anyone familiar with wxHaskell?
14:13:15 <kallisti> I'm trying to figure out how to reset the maximum value of a spinCtrl
14:20:52 <mneedham> Hey. haskell newbie and a bit stuck! I've created an Array using the 'array' described here - http://cvs.haskell.org/Hugs/pages/libraries/base/Data-Array.html#v%3Aarray - and I want to define a custom 'Show' function so that I can change how it's displayed on the REPL
14:21:08 <mneedham> Thought maybe I wanted something like this:
14:21:08 <mneedham> instance Show (Array x y) where
14:21:09 <mneedham>   show (Array i e) = "...."	
14:21:21 <mneedham> but that gives me - flood_fill.hs:20:9: Not in scope: data constructor `Array'
14:24:55 <geekosaur> mneedham, Array i e is a type constructor.  The data constructor is not exported, and (I'm looking at its definition in the compiler internals) not something you can easily mess with
14:25:07 <mneedham> ah
14:25:17 <mneedham> is there anyway to do what I want?
14:25:36 <geekosaur> data Array i e = Array !i !i !Int (Array# e) -- that last part is what makes exporting the data constructor difficult...
14:26:38 <mneedham> so that's in /GHC/Arr.lhs?
14:26:52 <geekosaur> actually the constructor is exported from GHC.Arr, and with -XMagicHash you could possibly do somehting.  but you should consider the need to do that as a strong hint that you shouldn't
14:27:20 <mneedham> haha ok
14:28:02 <Liskni_si> you don't need to deconstruct it using the data constr. to redefine Show
14:28:22 <mneedham> Liskni_si: what would I need to do instead?
14:28:59 <Liskni_si> mneedham: there should be a function in Data.Array to convert it to a list
14:29:04 <Liskni_si> you can use that, for example
14:29:24 <Liskni_si> or whatever other function that lets you read from an array :-)
14:29:33 <Veinor> FR: in addition to ghc telling you the most generic type signature, it also tells you the shortest one
14:31:25 <lcfrs> has anyone here done work with arrow combinators and Javascript? i'd like to get some thoughts if so: https://github.com/luciferous/samsara
14:35:48 <jonkri> anyone knows if you got to do anything more than "runResourceT $ sourceHandle handle $= parseBytes def $$ mySink" to get the xml events using xml-conduit? there should be some xml written to the handle, but i get no event using Data.Conduit.List.head
14:37:58 <kallisti> jonkri: shouldn't that be =$ mySink ?
14:38:16 <kallisti> jonkri: or is parseBytes a sink as well?
14:39:18 <kallisti> jonkri: ah nevermind
14:39:27 <kallisti> I forgot what $$ did. :P
14:41:19 <jonkri> kallisti, ok, thank you though :)
14:41:54 <kallisti> jonkri: well, you do have to print the result.
14:42:09 <kallisti> if you're not doing that then you're going to see anything.
14:42:10 <jonkri> $= "fuses" a source and a sink together, making them a source
14:42:13 <kallisti> yes
14:42:43 <jonkri> i'm printing all kinds of stuff. fact is that execution get stuck at Data.Conduit.List.head
14:42:43 <kallisti> what are you doing with the result currently?
14:42:53 <kallisti> print <=< runResourceT $ ...
14:43:00 <kallisti> would give you the output
14:44:12 <jonkri> kallisti, mySink never exits, and runResourceT doesn't exit neither
14:44:19 <kallisti> ah
14:44:39 <jonkri> maybe if i replace mySink with head or something
14:44:46 <kallisti> yes it could be an error in mySink
14:45:37 <jonkri> no, same thing. i just don't get any input. maybe there is some decoding issue or something
14:45:51 <jonkri> i'll skip the whole xml stuff and just take it one step at a time :) thanks
14:49:47 <jonkri> "parseBytes def" seems to be the problem...
14:50:47 <jonkri> i see now that it's under "Parsing XML files" in the documentation, so maybe it's assuming a complete file
14:51:54 <majuscule> I'm spawning processes with createProcess and runCommand, and they're litering my process list as defunct processes, how can I clear them?
14:52:08 <geekosaur> majuscule, see waitForProcess
14:52:51 <kaitocracy> is there a limit to how many monads transformers I should stack?
14:53:09 <kaitocracy> like say is 8 too many?
14:53:40 <kaitocracy> I'm doing some web development and I need
14:54:07 <alpounet> 8? wow
14:54:26 <kaitocracy> ReaderT Request, WriterT [Javascript], WriterT [Stylesheet], WriterT [Log], StateT [Connection], ResourceT
14:54:31 <kaitocracy> oh I guess that's 6
14:54:37 <kaitocracy> and I need to stack those on top of IO
14:54:40 <kaitocracy> is that bad?
14:54:42 <mauke> you don't need separate writers
14:54:51 <mauke> there's RWST
14:55:03 <kaitocracy> but that only supports on monoid right?
14:55:06 <kaitocracy> I mean it's a single writer
14:55:11 <kaitocracy> should I just make a tuple of monoids?
14:55:27 <mauke> or a custom record
14:55:30 <kaitocracy> like make the W in RWST be WriterT ([Javascript], [Stylesheet], [Log])
14:55:36 <kaitocracy> ahh I see okay I can do that
14:55:42 <kaitocracy> cool thanks
15:00:03 <jonkri> one final question before i give up for the day :)
15:01:21 <jonkri> any idea why "runResourceT $ sourceHandle handle $= parseBytes def $$ head" doesn't produce anything, while "runResourceT $ sourceHandle handle $$ head" produces Just "<?xml version='1.0'?><stream:stream xmlns='jabber:client' xmlns:stream='http://etherx.jabber.org/streams' id='acdf16e6-08ba-4bb9-99bb-aab1421d5caa' from='localhost' version='1.0' xml:lang='en'><stream:features><starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'><required/></starttls></stream:f
15:01:22 <jonkri> eatures>" ?
15:01:38 <jonkri> the first runResourceT gets stuck
15:01:48 <jonkri> it seems that parseBytes is blocking somehow
15:02:48 <jonkri> i expect to get a couple of Events from parseBytes, http://hackage.haskell.org/packages/archive/xml-conduit/0.6.1/doc/html/Text-XML-Stream-Parse.html#g:1
15:07:26 <jonkri> please leave me a memo if you see it :) nite!
15:09:45 <zzo38> What is the best way to learn which packages this package should need to depend?
15:12:13 <zhulikas> hmm, I have this strange concept
15:13:12 <zhulikas> if I define a custom grammar for quasi quoter which defines structures of some data... can I somehow take these structures, 'generate' haskell code for them and then in another syntax validate the quasi quoter against the given structures?
15:14:00 <zhulikas> let's say I define two possible structures in one quasi quoter. In other quasi quoter I expect that my syntax would match one of those structures (only in a different grammar)
15:17:05 <nart> ciao :)
15:17:53 <zzo38> How do I figure out exactly which version I am supposed to be depend on?
15:19:34 <smithw> http://hpaste.org/66368 <- is this somehow useful or am I reinventing the wheel here?
15:21:15 <tgeeky_> smithw: ??. The wheel is pretty useful.
15:21:42 <smithw> tgeeky_, indeed :p I just want to know if there is a more idiomatic way to accomplish what I'm trying to do
15:22:05 <JamesJRH> Does hdl have some standard meaning in Haskell? Other than Hardware Description Language?
15:22:39 <ski> mneedham : i think there is already a `Show' instance for `Array i e'
15:23:13 <mneedham> ski: yeh there is but it doesn't print the array out how I want
15:23:25 <mneedham> ski: wanted to try and print it out differently
15:23:26 <zzo38> Is there a program which will check which packages a module is using, so that you can make up the package file to mention the correct packages it depend on?
15:23:39 <JamesJRH> What does hdl mean in this context?: http://zvon.org/other/haskell/Outputio/hFlush_f.html
15:24:04 <srhb> JamesJRH: handle
15:24:12 <srhb> JamesJRH: (It actually says so, too. :-)
15:25:39 <Philonous> @tell jonkri xml-conduit has an issue where it tries to grab more data from a handle even though it could already produce Events. I've filed a bug report.
15:25:43 <ski> > array ((0,0),(2,1)) [((i,j),i^j) | i <- [0 .. 2] , j <- [0 .. 1]]
15:25:44 <ski> array ((0,0),(2,1)) [((0,0),1),((0,1),0),((1,0),1),((1,1),1),((2,0),1),((2,1),2)]
15:25:50 <ski> > listArray ((0,0),(2,1)) [i^j | i <- [0 .. 2] , j <- [0 .. 1]]
15:25:51 <ski> array ((0,0),(2,1)) [((0,0),1),((0,1),0),((1,0),1),((1,1),1),((2,0),1),((2,1),2)]
15:25:58 <alpounet> Philonous, lambdabot's gone
15:26:48 <ski> mneedham : imho, if you want to print it in a way that isn't a valid Haskell expression (e.g. using `array' as above, or using `listArray' or something), then you shouldn't use `Show' at all -- define your own function for printing them instead
15:27:07 <Philonous> Oh, bummer
15:27:24 <ski> Philonous : you could try `/msg MemoServ send jonkri ...'
15:27:33 <JamesJRH> srhb: Oh yes. I was expecting an initialism.
15:27:33 <DoctorSmaug> Hi guys, I have a conundrum.  I need to filter all items from one list out of another one.  Can't seem to work it out. Not homework. Any help?
15:27:35 <snhmib> email is like nice
15:28:04 <aristid> > (^) <$> [0..2] <*> [0..1]
15:28:17 <aristid> oh.
15:28:19 <aristid> lol
15:28:22 <geekagent> DoctorSmaug: Efficiency constraints?
15:28:23 <ski> [1,0,1,1,1,2]
15:28:32 <aristid> ski: good ski
15:28:38 <ski> :)
15:29:11 <DoctorSmaug> geekagent: As efficient as possible.  It'll be run on a lot of data, multiple times
15:29:16 <aristid> ski: what's the difference between mercury and elf?
15:29:22 <aristid> -elf+twelf
15:29:29 <aristid> i can't type today
15:29:37 <tgeeky_> smithw: unfortunately I can't comment on its usefulness, and I don't know if it's been done before
15:29:45 <snhmib> > [1..10] `intersect` [3..6]
15:29:46 <tgeeky_> smithw: you can search over types in hoogle or hayoo
15:29:51 <snhmib> :(
15:29:52 <zzo38> Are they good?   http://sprunge.us/FOMh
15:29:58 <ski>   (\\) :: Eq a => [a] -> [a] -> [a]  -- DoctorSmaug, like that ?
15:30:16 <DoctorSmaug> ski: Exactly
15:30:22 <ski> [3,4,5,6]
15:30:40 <ski> > [0,1,2,3] \\ [0,2,4,8]
15:30:41 <ski> [1,3]
15:30:41 <Philonous> ski:  Ah, nice, thanks
15:30:47 <smithw> tgeeky_, thanks anyway... hoogle doesn't show anything, and I wasn't aware of hayoo, will try that now :)
15:31:14 <DoctorSmaug> ski: Thanks ski :)
15:31:35 <ski> DoctorSmaug : you'll have to decide which of `intersect' and `(\\)' you want
15:31:50 <geekagent> DoctorSmaug: intersect and \\ are both O(n*m).
15:32:29 <geekagent> you might want to consider using sets.
15:32:48 * hackagebot hit 0.2.2 - Git operations  http://hackage.haskell.org/package/hit-0.2.2 (VincentHanquez)
15:32:50 * hackagebot tls-extra 0.4.4 - TLS extra default values and helpers  http://hackage.haskell.org/package/tls-extra-0.4.4 (VincentHanquez)
15:33:14 <DoctorSmaug> ski: \\ was what I wanted
15:33:15 <geekagent> DoctorSmaug: if the list of things to be removed is small (\\) is probably fine, but if it's big, using filter (-- set containment check) list could be faster.
15:34:18 <zzo38> I got the message "Function `dvi-processing-0.1:Graphics.DVI.optimizePage{v rNN} [lid]' has 10 call patterns, but the limit is 3" What does that mean?
15:34:27 <majuscule> I'm running waitForProcess(p) on my child processes but they're still turning into zombies :-/
15:35:26 <mneedham> ski: cool yeh that's what I'm trying now. THhanks
15:36:12 <ski> mneedham : generally, `Show' is (imho) meant to generate valid haskell expression (unfortunately there are existing exceptions)
15:36:14 <DoctorSmaug> Thanks guys, got to be off now
15:36:37 <ski> mneedham : i think if you just want to pretty-print things in some way, it's better to define a dedicated function for that
15:37:21 <ski> (in any case, if you have both `Show' and `Read', then `read . show' should be `id')
15:37:29 <ski> wb erus
15:38:11 <dylukes> What this tends to boil down to, for more complex data types...
15:38:13 <dylukes> is show produces lisp
15:38:14 <zzo38> Does the message I got prevent the program from compiling?
15:38:25 <dylukes> and read evaluates lisp into a haskell data structure >_>.
15:38:41 <dylukes> Well... it looks like lisp because ( ) + AST
15:39:44 <ski> (there is actually also another problem with the "`Show' should produce valid haskell code"-idea ..)
15:40:17 <majuscule> What is wrong with this line? `(_,_,_,p) <- createProcess(proc "volume-toggle" []); waitForProcess(p)`
15:40:55 <ski> not sure there's anything wrong with it (except brackets being written stranglely)
15:40:58 <zzo38> majuscule: One this is that it is not allowed outside of a do-block
15:41:03 <ski> majuscule : context ?
15:41:19 <majuscule> zzo38: it's in one, sorry i didn't know more context was needed :-/ i'll pastebin it
15:42:02 <majuscule> http://paste.pocoo.org/show/575241/
15:42:49 * hackagebot dvi-processing 0.1 - Read/write DVI and TFM file  http://hackage.haskell.org/package/dvi-processing-0.1 (AaronBlack)
15:42:51 * hackagebot happstack-hsp 7.0.1 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.0.1 (JeremyShaw)
15:43:02 <ski> majuscule : i think you need to indent the `else's more
15:43:09 <ski> majuscule : what is the error message, btw ?
15:43:25 <zzo38> There are so many different paste bin service... I prefer sprunge
15:43:30 <majuscule> ski: no error message, but my processes are sticking around as zombies
15:43:35 <ski> (also, the bracketting is strange)
15:43:52 <majuscule> ski: i'm real new to this :-)
15:44:14 <ski> majuscule : you don't need brackets around the condition part of `if'-`then'-`else's
15:44:24 <ski> majuscule : instead of `(time)', just `time'
15:44:48 <zzo38> I posted a new package is it good?
15:44:58 <zzo38> Do you like this?
15:45:54 <ski> majuscule : instead of `createProcess(proc "volume-toggle" [])' and `waitForProcess(p)', the convention is to write `createProcess (proc "volume-toggle" [])' and `waitForProcess p'
15:45:54 <zzo38> If you found anything wrong with it, then please notify me.
15:46:15 <majuscule> ski: thanks, i that makes sense, i'm not sure why i was doing that. I also think i uncovered the error. I removed the return () and I see that I'm getting `type `GHC.IO.Exception.ExitCode'`
15:46:38 <ski> majuscule : instead of `if foo then do ... else return ()' you can say `when foo $ do ...'
15:47:06 <majuscule> ski: i'd need to import that then no?
15:47:12 <majuscule> control monad i think?
15:47:45 <ski> yep
15:48:37 <ski> instead of `state <- updateButton state False; return state', you could say just `updateButton state False' (by one of the monad laws)
15:49:04 <ski> but if you intend to maybe add stuff after that `updateButton' later, it might be preferable to leave it as it is -- your choice
15:49:24 <ski> (though it's not really hard to change back, if needed later)
15:49:31 <majuscule> ski: oh that's cool, i'm gonna get rid of it, i actually have a bunch of em later and it'l help clean it up
15:50:07 <ski> majuscule : vtw, in the `then do if ... then ... else ...', the `do' is redundant (since there's only one command in it)
15:50:27 <ski> s/vtw/btw/
15:51:26 <majuscule> err, you mean on line 9?
15:52:42 <hpaste> int80_h pasted “read exception handling” at http://hpaste.org/66369
15:55:13 <majuscule> ski: if i get rid of that it errors (i tried getting rid of do and ; return ())
15:55:46 <majuscule> wait i'm an idiot, wrong line, sorry nevermind that
15:56:36 <acowley> I have an associated type default. I also have an instance that doesn't work unless I duplicate the associated type default in a particular instance. Has anyone seen anything like that?
15:56:41 <elliott> Cale: btw, lambdabot is down
15:57:18 <ski> majuscule : *nod*, line 6
15:57:29 <ski> er, line 4
15:57:40 <int80_h> heya ski
15:58:05 <int80_h> > read "1" :: Int
15:58:12 <int80_h> ah
15:59:25 <sohum> @src trace
15:59:29 <majuscule> ski: any ideas on that `type `GHC.IO.Exception.ExitCode'` though? I see getProcessExitCode, but the description doesn't sound like what I need even though the name does. And I don't want terminateProcess, so i'm confused
15:59:46 <sohum> oh, lambdabot's gone
16:00:56 <elliott> @tell Cale lambdabot's down :P
16:01:04 <ski> sohum : probably defined using `unsafePerformIO'
16:01:11 <mauke> preflex: tell Cale lambdabot's down
16:01:11 <preflex>  Consider it noted.
16:02:33 <shachaf> > 1 + 1
16:02:34 <kappabot>   2
16:03:18 <majuscule> zombies everywhere. they're everywhere.
16:03:53 <ski> lo int80_h
16:04:24 <ski> majuscule : is that a type-error ? what generates it ?
16:06:08 <sohum> ski: found it, cheers
16:06:17 <majuscule> ski: it's the error I get when I remove the `return ()` after waitForProcess. I thought it might be relevant for some reason, maybe that's totally off. My program runs fine with the return (), it's just still littering my system with zombie processes
16:07:28 <hpaste> “Kaiting Chen” pasted “Lose the ResourceT?” at http://hpaste.org/66370
16:07:36 <kaitocracy> can someone take a quick look at that hpaste?
16:07:46 <kaitocracy> and tell me if it's possible for me to "lose the ResourceT"
16:08:07 <kaitocracy> I don't think it would happen but I'm epically confused
16:08:19 <kaitocracy> when I do c <- getConnection, and then 'return c'
16:08:36 <kaitocracy> that should create a new ResourceT monad right?
16:08:53 <kaitocracy> and that new ResourceT monad doesn't have my cleanup action
16:09:07 <kaitocracy> so did I lose that cleanup action?
16:10:06 <dmwit> I think it's possible your question is okay, but there's a terminology problem.
16:10:20 <dmwit> A monad is a type together with some operations; you can't create new monads (at runtime).
16:10:44 <kaitocracy> I mean I can take something and wrap it in a blank monad right?
16:10:45 <kaitocracy> with return
16:11:09 <dmwit> Perhaps "action" is a better word than "monad" here.
16:11:10 <shachaf> Monads aren't things that "wrap" values.
16:11:31 <Enigmagic> monads are burritos
16:11:35 <kaitocracy> I can think about monads like things that wrap values right?
16:11:35 <shachaf> What do you call it when someone confuses kinds and types? It's not a kind error or a type error.
16:11:42 <shachaf> kaitocracy: Not really.
16:11:46 <shachaf> kaitocracy: It'll just mislead you.
16:11:50 <shachaf> And it's wrong.
16:11:53 <elliott> shachaf: Category error?
16:11:53 <dmwit> shachaf: Perhaps a level error.
16:11:59 <shachaf> @quote /bin/ls
16:11:59 <kappabot> No quotes match.
16:12:03 <kaitocracy> okay so with return I can take a value and wrap it in a blank action?
16:12:04 <elliott> :D
16:12:05 <shachaf> :-(
16:12:11 <elliott> @slap shachaf
16:12:11 * kappabot clobbers shachaf with an untyped language
16:12:23 <shachaf> kaitocracy: No. You can create an action that yields that value.
16:12:29 <elliott> "IO a contains a like /bin/ls contains a list of files" -- shachaf, paraphrased.
16:12:30 <elliott> HTH
16:12:44 <kaitocracy> okay so with return I create an action that yields some value
16:13:01 <nand`> elliott: that's a good one
16:13:12 <majuscule> I found on haskellwiki this line: "zombies could be created by multiple runplugs calls, leading to blocking on endless output. the resulting zombies accumulate, eventually leading to DOS. (if waitForProcess was broken)", which leads me to believe that waitForProcess IS the right call to use to clean up my proceses. And the docs describe it as blocking til the process exits, which makes sense. So why am I still getting defunct processes?
16:13:17 <shachaf> elliott: That's totally a level error.
16:13:21 <shachaf> Category error? Whatever.
16:15:04 <geekosaur> majuscule, you may need to pastebin the entirety of what you're writing, if that's not the only createProcess or whatever
16:19:23 <tech2> majuscule: do you understand why zombies exist in unix-like OS?
16:20:17 <ski> majuscule : well, the two branches of the conditional must have the same type -- the `else' branch ends with `return ()', so it has type `IO ()'
16:20:59 <ski> majuscule : but `waitForProcess p' in the other branch has type `IO ExitCode', so if you remove the `return ()', the two branches don't have the same type, so type error
16:22:53 <ski> kaitocracy : `getConnection' and `return c' there are monadic *actions*, not monads (`IO' is a monad)
16:23:53 <ski> monads (in haskell) are always types with kind `* -> *'
16:24:14 <ski> `IO' is a monad, `Maybe' is a monad, `Either e' is a monad for every type `e' (of kind `*')
16:28:32 <hpaste> “James Haigh” annotated “triples.hs” with “triples.hs (annotation) (annotation)” at http://hpaste.org/66365#a66371
16:29:19 <JamesJRH> Nope, I doing something wrong. It's not flushing.
16:29:38 <JamesJRH> Or it's just flushing it's own thread.
16:29:44 <kaitocracy> I feel like there's got to be a better way to do this than writing a bunch of boilerplate
16:29:45 <kaitocracy> withTitle x st = st { title = x }
16:29:45 <kaitocracy> withConnection x st = st { connection = x }
16:29:56 <JamesJRH> I'm*
16:30:43 <Axman6> kaitocracy: those look like ad hoc lenses to me
16:30:46 <Axman6> sort of
16:30:52 <elliott> yep
16:30:54 <elliott> you want lenses
16:31:11 <elliott> see http://stackoverflow.com/a/5769285/1097181
16:31:15 <kaitocracy> thanks
16:32:50 <dmwit> JamesJRH: Works here.
16:32:51 <JamesJRH> Removed the "Redundant do"s, still no good.
16:32:54 <dmwit> JamesJRH: Flushes occasionally.
16:33:10 <johannes__> who here thinks that haskell is one of the best languages. I do have one problem, it is not good for game development . do any of you know what the best language is other than c++
16:33:20 <dmwit> JamesJRH: How are you compiling?
16:33:31 <johannes__> vim
16:33:44 <elliott> Why do you think Haskell isn't good for game development? (Why do you think people in #haskell wouldn't think Haskell is a good language?)
16:33:44 <irene-knapp> johannes__: the best language other than C++ is Javanese
16:34:19 <JamesJRH> dmwit: Not 4 times a second though.
16:34:27 <JamesJRH> dmwit: ghc triples.hs
16:34:49 <JamesJRH> Or simply: ./triples.hs
16:34:52 <Axman6> JamesJRH: why not just tuen off buffering on stdout?
16:35:36 <johannes__> okay so i should use javanese. Can you give me a bit of code
16:35:40 <dmwit> JamesJRH: threads are not guaranteed to wake up after exactly the delay given.
16:35:49 <dmwit> JamesJRH: The only guarantee is that they don't wake up before the delay is done.
16:36:57 <johannes__> i am a c++ programmer. do you know a high level language that could help me with more user friendly code
16:37:32 <dmwit> ...you do know Javanese is a natural language, right?
16:38:19 <kallisti> anyone familiar with wxHaskell?
16:38:26 <johannes__> yes
16:38:33 <JamesJRH> Axman6: How do I do that? And isn't bufferring to increase performance? If I flush by time interval rather than data blocks it makes more sense.
16:38:40 <kallisti> what event is fired when a spinCtrl is changed?
16:38:46 <irene-knapp> dmwit: yes, that was the point
16:38:50 * elliott suspects johannes__ of treating us to a belated april fool's.
16:39:02 <elliott> irene-knapp: i believe dmwit was replying to johannes__ asking for a bit of javanese code ;)
16:39:10 <Sgeo> johannes__, what is "user-friendly"?
16:39:36 <dmwit> Yes, I was making sure johannes__ got the joke. =)
16:39:51 <kallisti> Sgeo: you know, a language you can really get along with. It wants to be your buddy.
16:40:02 <johannes__> yall do know that i only program on my free time, i am actually a particle physicist at the smithsonian
16:40:04 <aristid> woah, javanese has 85 million speakers
16:40:08 <nart> how can i run a fun passing to it arguments that are contained in a list, something like the lisp apply
16:40:08 <DaveNull> everything but C++ is friendly :)
16:40:12 <aristid> a lot for a language that i never heard about
16:40:42 <kallisti> nart: you'll need some type-level magic to get that done, unless all of the arguments are the same type (or conform to a particular typeclass)
16:40:42 <elliott> johannes__: please start being serious, or at least stop being unserious
16:41:12 <JamesJRH> dmwit: So how would I set it to update every second or so?
16:41:18 <nart> kallisti: gosh, i'll change my app then, thanks anyway
16:41:38 <JamesJRH> dmwit: Can threads be woken up?
16:41:39 <Axman6> nart: also, what you're asking for is not type safe
16:41:42 <hpaste> acowley pasted “Associated Type Defaults” at http://hpaste.org/66372
16:41:52 <Axman6> the result type cannot be determined at compile time
16:41:55 <acowley> can anyone let me know what I'm doing wrong there?
16:42:01 <kallisti> nart: yes, static typing makes that more difficult than in languages like lisp and Python, where passing around argument lists as heterogenous collections is pretty common practice.
16:42:07 <Axman6> f [] and f [1] would have to have different types
16:42:23 <dmwit> JamesJRH: Perhaps if you build with -threaded and run with +RTS -N2 your two threads will be run on actually different cores, in which case the delay should be much more predictable.
16:42:27 * dmwit tests
16:42:48 <dmwit> ...not much better =P
16:43:09 <kallisti> nart: I believe it would be somewhat easy with PolyKinds and DataKinds enabled.
16:43:11 <kappabot> http://i.imgur.com/ZUTx3.png
16:43:49 <singpolyma> I have a list, and I want to print each element of the list.  Is there a way to force the printing of each element to happen before the evaluation of the next element?
16:43:56 <Axman6> ok, there are well known ways to get the result JamesJRH is after. you just need a delayUntil function
16:44:03 <kallisti> singpolyma: mapM print myList
16:44:07 <kallisti> try that
16:44:12 <kallisti> (mapM is located in Control.Monad)
16:44:14 <Axman6> singpolyma: you could use mapM_ print
16:44:15 <singpolyma> kallisti: that's what I'm doing
16:44:25 <acowley> anyone get a chance to look at my hpaste?
16:44:53 <kallisti> singpolyma: IO computations chained together by >>= are evaluated sequentially, so that should do it.
16:45:01 <irene-knapp> dmwit: hehe okay then
16:45:17 <Sgeo> Before evaluation of the next element?
16:45:21 <singpolyma> maybe I'm wrong, but the operation processes for 10 seconds, and then all the output happens really fast
16:45:31 <singpolyma> I want one output, then processing, then more output
16:45:37 <shachaf> Cale++
16:45:41 <shachaf> @quit
16:45:46 <lambdabot> Not enough privileges
16:46:25 <Axman6> singpolyma: depends on what else your program is doing then. if the first element can't ve evaluated without doing lots of other computation, then it will have to do that before printing
16:48:42 <singpolyma> Axman6: replacing mapM_ with _ <- head $ map     is fast
16:49:07 <kallisti> singpolyma: your monad is just IO right?
16:49:14 <singpolyma> kallisti: yes
16:49:33 <Axman6> singpolyma: why don't you just share the code and we can tell you what your problem is
16:49:51 <kallisti> yeah it's impossible to tell what's going on without more details.
16:50:13 <Axman6> it's like trying to fix a diesel engine in the dark. possible, but really hard
16:50:48 <singpolyma> yeah, sorry.  It's a bit nontrivial, but here: http://pastie.org/3717612  the segment in question is line 273
16:51:03 <kallisti> also your diesel engine evaluates non-strictly (wait what)
16:51:05 <JamesJRH> Axman6: That sounds good, I guess it would allow the exact interval rather than in general just over. But I can't find it on Hoogle.
16:51:09 <Jafet1> It's like trying to fix a diesel engine over the internet
16:52:49 <kallisti> this paste site does not do horizontal scroll very well
16:53:02 <Axman6> singpolyma: i'm not sure that head $ map ... even does anything at all
16:53:09 <acowley> My hpaste is nice and simple. The might of #haskell should be able to solve the issue.
16:53:26 <JamesJRH> Axman6: Surely it's like trying fix a Bio-diesel engine, far more pure. :-P
16:53:29 <Axman6> acowley: i had a look, but i've got no idea :(
16:54:00 <dmwit> acowley: It's a bug.
16:54:07 <dmwit> acowley: Look forward to it being fixed in future GHCs.
16:54:13 <acowley> Axman6: thanks for taking a look!
16:54:18 <acowley> dmwit: a known bug?
16:54:18 <singpolyma> Axman6: it definitely does something, since I get output :)
16:54:26 <dmwit> acowley: Known and already fixed, I think.
16:55:03 <acowley> dmwit: okay, I guess I'll just duplicate the default everywhere appropriate until the next GHC
16:55:05 <kallisti> singpolyma: you lied, IO is not a MonadState
16:55:05 <Axman6> singpolyma: please turn off tabs in your editor >_<
16:55:07 <acowley> dmwit: thanks
16:55:36 <kallisti> unless that's a different put
16:56:00 <singpolyma> kallisti: I define put at the end.  It's just a chan write
16:56:12 <singpolyma> Axman6: why would I do that?  I am not evil
16:56:31 <Axman6> because tabs are evil. use spaces for tabs
16:56:32 <JamesJRH> Axman6: Could you tell me about delayUntil please.
16:56:59 <Axman6> JamesJRH: not sure it exists, but you can approximate it. let me have a go and see what I can do
16:56:59 <JamesJRH> No, that's what tabs are for.
16:57:00 <kallisti> singpolyma: ah, try using less strictness
16:57:16 <singpolyma> kallisti: less?
16:57:18 <kallisti> yes
16:57:22 <singpolyma> in which place
16:57:26 <Axman6> @hoogle delay
16:57:26 <lambdabot> Control.Concurrent threadDelay :: Int -> IO ()
16:57:26 <lambdabot> GHC.Conc.IO threadDelay :: Int -> IO ()
16:57:26 <lambdabot> GHC.Conc threadDelay :: Int -> IO ()
16:57:39 <kallisti> singpolyma: try removing the $! in put
16:57:41 <kallisti> and see what happens
16:58:16 <kallisti> your code is a maze though, so I may be going in the wrong direction
16:59:20 <singpolyma> kallisti: sorry.  it's sort of very work-in-process proof-of-concept
16:59:29 <kallisti> no worries. I'm written similar things. :P
16:59:38 <kallisti> *I've   I usually split it up into more functions at some point.
17:00:42 <singpolyma> kallisti: hmm, that doesn't seem to have made a change
17:00:51 * elliott notes that singpolyma uses put without defining it.
17:01:10 <singpolyma> elliott: put is the last line of the code
17:01:36 <singpolyma> kallisti: since it's a list of puts, wouldn't one put get full sent before the next one, though?
17:01:39 <elliott> Oh.
17:01:48 <kallisti> singpolyma: yes.
17:01:50 <elliott> You might want to call it something other than put, since the State monad uses that name.
17:01:52 <kallisti> so nevermind. just a hunch.
17:02:09 <singpolyma> elliott: hmm, maybe.  I've never used the State monad
17:02:30 <kallisti> singpolyma: my guess was that something was being strictly evaluated before the print calls.
17:04:01 <kallisti> perhaps your initialization is just slow? or you're not compiling with optimization? or you're using a lot of slow list functions? I don't know.
17:04:09 <kallisti> profiling would be of use.
17:07:24 <singpolyma> kallisti: yeah... I expect it to be slow.  I mostly just don't want it to build up a bit RAM structure of the stuff before printing it
17:07:31 <singpolyma> but maybe it's not and I'm just misunderstanding the behaviour
17:08:08 <kallisti> IO is strict. >>= and >> evaluate sequentially.
17:08:37 <kallisti> @src mapM
17:08:37 <lambdabot> mapM f as = sequence (map f as)
17:08:43 <kallisti> @src sequence
17:08:43 <lambdabot> sequence []     = return []
17:08:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
17:08:44 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
17:09:18 <singpolyma> yeah.  so maybe it's doing the strictness I need and jsut not the IO behaviour I'd ideally like or something
17:09:56 <kallisti> well, your outputting function is running concurrently with the processing functions.
17:10:11 <kallisti> I believe.
17:10:26 <singpolyma> should be.  I even tried running with +RTS -N2
17:10:57 <singpolyma> hmm, RAM usage does seem to climb as the thing runs
17:12:19 <singpolyma> kallisti: thanks for looking, anyway :)
17:12:37 <kallisti> the constant conversion from to/from Strings/ByteStrings is probably not good, nor is the use of functions like nub, and (!!)
17:13:27 <singpolyma> nub is only used on one thing that's really short
17:13:37 <hpc> @src nub
17:13:38 <lambdabot> nub = nubBy (==)
17:13:52 <hpc> a faster alternative to nub is to convert to/from Set
17:13:56 <hpc> but you lose ordering
17:14:03 <Axman6> singpolyma: have you tried using mapM_? not mapM?
17:14:22 <singpolyma> oh, hmm.  maybe I'm an idiot and the (!!) that I put in there "just temporarily" is the problem...
17:14:28 <singpolyma> Axman6: yes.  I am using mapM_
17:15:02 <Axman6> yeah, !! is not a good idea
17:18:53 <singpolyma> so, the numeric indexing is adding some overhead for sure, but I don't think that's it.  Whatever.  I'll do more instrumentation and look at it more later
17:18:57 <singpolyma> thanks for all the help :)
17:21:04 <kallisti> hm, so, if you added an extra type parameter to Functor for the element type, and a functional dependency, couldn't you have instances for monomorphic types such as ByteString?
17:21:40 <elliott> Yes, if you wanted to lose all laws and meaning about Functor.
17:22:09 <kallisti> that's fine.
17:22:21 <elliott> No it's not.
17:22:44 <kallisti> Sure it is. Just look at all the typeclasses that aren't Functor. They obviously don't uphold Functor laws.
17:22:47 <kallisti> and they're fine.
17:22:58 * kallisti logic.
17:23:43 <kallisti> (perhaps I should have been more specific that by "changed" I didn't mean "replaced")
17:23:55 <kallisti> or "added" I guess.
17:24:02 <kallisti> ...er, nevermind.
17:28:46 <singpolyma> in case anyone cares, I solved my performance issue
17:28:57 <kallisti> cool. what was the issue?
17:28:59 <singpolyma> I had a mapM earlier doing the reading, which forced it all too early
17:29:01 * singpolyma is dumb
17:32:23 <Mathnerd314> kallisti: is ByteString ~ [Byte]?
17:32:59 <mauke> more like (Int, Ptr Byte)
17:33:42 <shachaf> Even more like (Int, Int, Ptr Byte)
17:34:06 <shachaf> Implementationwise, anyway.
17:34:17 <shachaf> THe interface is a lot like [Byte], except not lazy.
17:34:35 <shachaf> (And with different performance, so more like Array Int Byte.)
17:39:24 <kallisti> I believe it's ByteString !Int !ForeignPtr !Ptr  internally
17:41:32 <jfischoff> Seems like CFloat in Foreign.C.Types doesn't have any constructors with base==4.4.1.0. That's odd. How does one make one?
17:41:33 <snhmib> haskell code bitrots so frieaking fast :(
17:42:07 <jfischoff> I feel like I must be missing something ...
17:42:22 <kallisti> > 3 :: CFloat
17:42:22 <lambdabot>   Not in scope: type constructor or class `CFloat'
17:42:31 <Axman6> probably fromRational or something
17:42:38 <Axman6> :t fromRational
17:42:39 <lambdabot> forall a. (Fractional a) => Rational -> a
17:42:51 <Axman6> mm
17:43:33 <jfischoff> yeah probably, its different in base == 4.5. You do get constructors, which way better.
17:43:34 <kallisti> realToFrac
17:44:04 <kallisti> :t realToFrac
17:44:05 <lambdabot> forall a b. (Real a, Fractional b) => a -> b
17:44:09 <kallisti> where Real is just a toRational method
17:44:34 <int80_h> \q
17:44:35 <int80_h> :q
17:44:43 <snhmib> anybody use/know conduit?
17:45:02 <snhmib> i'm getting like stuck on the 2nd example here http://www.yesodweb.com/book/conduits
17:45:15 <snhmib> with sumSink
17:46:27 <snhmib> apparently because "No instance for (Control.Monad.Trans.Control.MonadBaseControl IO m0) arrising from a use of `runResourceT'
17:47:15 <c_wraith> snhmib: the newest versions of the conduit library no longer work the way the book says.
17:48:08 <snhmib> but they still work?
17:49:49 <parcs`> presumably :P
17:52:28 <JamesJRH> Axman6: Did you figure out a way to do delayUntil?
18:16:49 <parcs`> does the gtk package target gtk3?
18:17:55 * hackagebot hsshellscript 3.1.0 - Haskell for Unix shell scripting tasks  http://hackage.haskell.org/package/hsshellscript-3.1.0 (VolkerWysk)
18:18:13 <dmwit> parcs`: no
18:18:17 <dmwit> parcs`: patches welcome
18:21:06 <parcs`> i'm darcs getting right now ;)
18:21:54 <parcs`> wow, gtk 3 was released last year
18:22:44 <iFire> ...
18:22:51 <iFire> and gtk4 in 2020?
18:26:52 <irene-knapp> parcs: wow, that's an entry for the "It is later than you think" file :)
18:47:15 <zmoazeni> Hey folks, if you're working with a package that has FFI bindings to a C library, is there anything prohibiting you from accepting and returning lazy bytestrings? I'm messing with https://github.com/kim/leveldb-haskell and wondering how difficult it would be to provide lazy bytestrings in addition to the existing strict ones.
18:47:32 <irene-knapp> nothing in particular, no
18:47:36 <irene-knapp> I haven't looked at that library though
18:47:53 <snhmib> ok just so i get this right, conduit without IO is stupid
18:47:57 <snhmib> is that right?
18:48:12 <zmoazeni> irene-knapp: Right on, thanks.
18:48:58 <irene-knapp> np
18:52:14 <nh2> why does cabal update take more than 2 minutes with neither CPU nor network?
18:53:25 <Axman6> well, you obviously need a CPU to use cabal =)
18:54:05 <sm> nh2: waiting for a network request ?
18:56:02 <nh2> phew looks like hackage runs on a dialup modem
18:57:56 * hackagebot aeson 0.6.0.1 - Fast JSON parsing and encoding  http://hackage.haskell.org/package/aeson-0.6.0.1 (AndrasSlemmer)
18:59:04 <zmoazeni> Is this correct? Normal (Strict) ByteStrings maintain the all the data in memory, while Lazy ByteStrings only maintain a portion of the underlying deta in memory at once? Lazy Bytestrings will "discover" more data from its source as necessary?
18:59:39 <monochrom> not accurate. sometimes true, sometimes false
19:00:07 <zmoazeni> monochrom: What would be a more accurate way of groking it?
19:01:27 <monochrom> if you want a short description, "lazy" is already it. if you want a long description, repeat the definition of "lazy"
19:04:08 <monochrom> my http://www.vex.net/~trebla/haskell/lazy.xhtml explains laziness. see the last two case studies. with lazy list, you can have the whole list in memory if you arrange it, or you can have at most one item in memory at a time if you arrange it. lazy bytestring is just coarser, one unit is about 64K
19:05:58 <zmoazeni> Oh right, I see my issue. A lazy implementation could have all the data in memory if the caller does something to force it. Like reversing a lazy list
19:09:27 <kallisti> zmoazeni: the difference in lazy and strict bytestrings involves what happens when their operations are evaluated.
19:09:41 <kallisti> strict ByteString operatons will do everything up front.
19:10:16 <kallisti> so evaluating "toUpper bstr" will uppercase the whole thing immediately.
19:10:50 <zmoazeni> kallisti: Mentally I keep thinking of lazy bytestrings are more memory efficient while strict bytestrings have a constant memory cost. But that's starting to feel wrong
19:13:49 <zmoazeni> I suppose efficiency is all up to the implementation. Lazy implementations "could" be more efficient, but not necessarily. Asking for the length of a lazy bytestring could be something that evaluates it fully.
19:13:58 <kallisti> correct
19:14:40 <kallisti> however, if you know that you'll be working with the data upfront in all circumstances, then strictness is often a better choice.
19:15:00 <snhmib> why?
19:15:22 <dibblego> !seen roconnor
19:16:23 <kallisti> snhmib: because you bypass the overhead associated with implementing lazy evaluation, of course.
19:16:27 <kallisti> when it's not doing anything for you.
19:16:56 <kallisti> why should I create a thunk every time I add 2 integers together?
19:20:24 <kallisti> > 0*undefined
19:20:25 <lambdabot>   *Exception: Prelude.undefined
19:21:09 <kallisti> a lazy implementation of multiplication could return 0 here.
19:21:55 <snhmib> o_O
19:22:23 <snhmib> that seems wrong
19:22:38 <kallisti> not really
19:22:45 <kallisti> think of undefined as an infinite loop
19:22:49 <kallisti> fix (0*)
19:22:58 <ion> > 0 `pmult` undefined
19:22:58 <lambdabot>   Not in scope: `pmult'
19:22:59 <kallisti> = 0 * 0 * 0 * 0 * 0 ...
19:23:20 <ion> λ> 0 `pmult` undefined
19:23:22 <ion> 0
19:23:28 <kallisti> in a lazy implementation, this would evaluate to 0
19:23:45 <kallisti> other things that would evaluate to 0:   0 * sum [1..]
19:23:50 <kallisti> and so on.
19:24:07 <zmoazeni> Yeah, I could see that. 0 * anything == 0, so the lazy implementation could optimize by ignore the latter part
19:24:18 <snhmib> oh ok i see
19:24:31 <hpaste> ion pasted “The best GHC output evar” at http://hpaste.org/66376
19:24:33 <zmoazeni> Although, I don't know if mathematically speaking 0 * undefined actually == 0
19:24:42 <kallisti> zmoazeni: Haskell's undefined means something else.
19:24:50 <kallisti> it means a non-terminating program.
19:25:04 <zmoazeni> Bottom right?
19:25:08 <kallisti> yes.
19:25:32 <kallisti> sum [1..] is also bottom
19:26:27 <kallisti> (though there is a certain practical distinction between actual non-terminating programs, and IO exceptions such as undefined)
19:27:44 <kallisti> but semantically they are the same thing; computations with undefined results.
19:30:50 <ion> @tell conal You might get a chuckle out of http://hpaste.org/66376
19:30:50 <lambdabot> Consider it noted.
19:32:57 <kallisti> ion: wat
19:36:59 <monochrom> what 0*undefined should be is largely opinion
19:38:45 <kallisti> monochrom: well yeah, that's why there's a "should" there.
19:38:59 <kallisti> I was just explaining how it makes sense when * is non-strict.
19:39:06 <monochrom> it happens that Prelude number types go with strict arithmetic. but you're welcome to cook up non-strict ones yourself, the Haskell Report doesn't lean either way
19:39:47 <monochrom> also I am not sure whether it's Prelude's choice or individual compiler's choice
19:40:11 <kallisti> monochrom: I would say that if undefined is undefined in the mathematical sense, then that operation is also undefined.
19:40:25 <kallisti> if undefined is a non-terminating computation, then it should be 0.
19:40:47 <kallisti> but this distinction isn't really made in Haskell.
19:41:02 <monochrom> what is the mathematical sense? is an example 1/0?
19:41:27 <kallisti> yes.
19:41:35 <kallisti> not meaningful.
19:41:51 <kallisti> whereas things like infinite sums and products have meaning.
19:41:55 <monochrom> ok, I have a black-box computation that may non-terminate, or may terminate with 1/0. what is 0*(my black-box computation)?
19:43:08 <kallisti> that depends on your representation of 1 and 0
19:44:19 * rasfar thinks unicode lambda looks really pretty in loom: http://fremissant.net/lambda.html
19:44:41 <kallisti> monochrom: well, I spoke too soon.
19:44:48 <zmoazeni> In the context of haskell, you can't determine beforehand that something will be non-terminating. And 1 / 0 == Infinity
19:44:56 <kallisti> that's probably not possible to check. which was my first impression but I decided to try anyway. :P
19:45:24 <zmoazeni> > 1 / 0
19:45:25 <lambdabot>   Infinity
19:46:50 <monochrom> lambda is bound to look nice in any lambda.html :)
19:48:12 <dibblego> (|||) on the Lens category is possible, but it is not bijective (Lens is not an Arrow) -- but it is still a reasonable function? (Russ O'Connor objected to it: https://github.com/roconnor/data-lens/commit/8f0158c89290271799d2c4cc1d6fd5193ed3da2a#commitcomment-1165378 but he is not online atm)
19:48:53 <dmwit> :t (|||)
19:48:53 <lambdabot> forall (a :: * -> * -> *) b d c. (ArrowChoice a) => a b d -> a c d -> a (Either b c) d
19:51:04 <dmwit> Am I misunderstanding that link? It looks to me like it is not only a reasonable function, but one he is explicitly including.
19:51:54 <dmwit> Oh, I see that I am misunderstanding it.
19:52:13 <dmwit> Also, I don't think the naive implementation of (|||) makes the relevant diagrams commute.
19:57:17 <jetru> In Parsec, is there a way in which I can parse (many p) but optionally throw out some content in-between that doesn't parse with p?
19:57:28 <mauke> sepBy
19:59:39 <jetru> But I don't know how many times the stuff that doesn't parse in-between comes…sepBy would work if it was regular
20:05:44 <parcs`> (`sepBy` many inBetweenStuff)
20:06:41 <vyom> does cabal test work with ghc 7.12 and cabal v1.8? I tried doing cabal configure --enable-tests and i still cant run cabal test
20:10:03 <ben> If I have a StateT with IO as the base monad and end up catching a UserInterrupt exception somewhere, is there a way to rejiggle the whole thing so that I can get the current state at the time of the exception rather at the point where the exception handler is introduced?
20:11:18 <kallisti> ben: you may be interested in lifted-base, which does this for you.
20:11:38 <kallisti> the Control.Exception.Lifted module has lifted exception handlers.
20:12:09 <parcs`> ben: use an IORef perhaps
20:12:50 <kallisti> ben: oh wait, nevermind. I'm not sure that it does that.
20:13:01 <ben> hm :)
20:14:37 <kallisti> ben: you could pass the state along with the exception. :D
20:14:58 <ben> kallisti: I thought about it, but it's not me throwing the UserInterrupt on ^C after all :)
20:15:14 <dibblego> dmwit: yeah his objection is that (|||) on Lens does not correspond to Control.Arrow.(|||) and is not bijective -- I am not convinced that is a reason to omit it altogether
20:17:24 <monochrom> http://www.vex.net/~trebla/haskell/reads.xhtml \∩/
20:17:24 <kallisti> ben: newtype StateT IO, rewrite the Monad instance so that it catches all IO exceptions, wraps them in a type that bundles your state, and rethrows it.
20:17:29 <kallisti> ben: should be simple.
20:18:17 <dmwit> I'm not sure I understand your bijective comment.
20:18:24 <dmwit> The whole point of lenses is that they're not bijective.
20:18:52 <dibblego> dmwit: the absence of the bijectivity of (|||) is roconnor's objection
20:19:36 <kallisti> ben: but first I would test out lifted-base and see if it does this for you.
20:19:50 <ben> Yeah, I'm trying right now.
20:19:56 <dmwit> dibblego: What are the two things which you can't put in bijection?
20:20:01 <dibblego> e.g.: id :: Lens (Either a b) (Either a b) -/-> (Lens a (Either a b), Lens b (Either a b))
20:20:23 <ben> Exception safety sure isn't a thing that a lot of people talk about when they discuss monad transformers
20:21:00 <dibblego> dmwit: roconnor argues that it would be reasonable to expect (|||) to be bijective, but it is not
20:21:01 <kallisti> I have a similar situation, myself.
20:21:09 <kallisti> so I think it crops up when you're dealing heavily with IO.
20:21:13 <dmwit> dibblego: Right, you keep saying that. But I don't understand the comment. Do you?
20:21:24 <dmwit> If you do understand it, what are the things which should be in bijection?
20:21:45 <dibblego> roconnor argues uncurry (|||) should be bijective
20:22:34 <dmwit> So, you don't understand his comment, either, then?
20:22:58 <dibblego> I understand that it is not bijective and does not correspond to Control.Arrow, but not why this is so important or desirable
20:23:28 <dmwit> "I understand that it is not bijective" <- can you say what this means?
20:23:49 <dmwit> "bijective" usually implies there are two objects (usually sets) and an isomorphism between them. What are the two objects?
20:24:10 <kallisti> I can't explain it very well but I can try circles and arrows and it'll probably make sense to you.
20:24:23 <dibblego> uncurry (|||) :: Lens a c -> Lens b c -> Lens (a b) c
20:24:26 <dibblego> oops
20:24:34 <dibblego> uncurry (|||) :: (Lens a c, Lens b c) -> Lens (a b) c
20:24:57 <dibblego> this is not a bijection e.g.  Lens (Either a b) (Either a b) -/-> (Lens a (Either a b), Lens b (Either a b))
20:25:04 <elliott> "(a b)"
20:25:07 <elliott> Don't you mean (Either a b)?
20:25:11 <dibblego> yeah that sorry
20:25:28 <dmwit> Okay, so the two objects that are not in bijection are "(Lens a c, Lens b c)" and "Lens (Either a b) c"?
20:25:34 <dibblego> correcty
20:25:46 <dmwit> If so, then I think this is basically what I was saying earlier: (|||) doesn't make the appropriate diagrams commute.
20:25:57 <dibblego> yes I think so too
20:26:05 <dmwit> In other words: there will come a time when you are programming with (|||) and its behavior surprises you, and there's no way to fix it.
20:26:06 <dibblego> but I do not understand why this is so important
20:26:16 <dibblego> so you agree with the objection?
20:26:36 <elliott> I understand the objection and I think I agree with it.
20:26:48 <elliott> There's no way to usefully use the lens (|||) outputs without fromLeft/fromRight.
20:26:52 <Orclev_> when ghci resolves a type to a particular instance is there a way to determine what that instance is?
20:26:55 <dmwit> My philosophy would be to provide it with warnings.
20:27:03 <elliott> Because it just doesn't make sense without the invariant that it keeps the same constructor you feed it in.
20:27:04 <dibblego> dmwit: that is my suggestion too
20:27:11 <dmwit> That's what e.g. Boomerang does.
20:27:11 <dibblego> elliott: what is fromLeft/Right
20:27:17 <elliott> dibblego: the obvious analogues of fromJust
20:27:21 <dibblego> oh right
20:27:44 <byorgey> Orclev_: "resolves a type to a particular instance" -- I'm not sure I understand what you mean.  Maybe give an example?
20:27:56 <kallisti> :t fromJust
20:27:58 <lambdabot> forall a. Maybe a -> a
20:28:05 <kallisti> oh right
20:28:10 <kallisti> that thing I avoid.
20:28:24 <Orclev_> byorgey: returnA :: Arrow a b b, returnA 4 <- what instance of arrow is that?
20:28:46 <kallisti> it's ambiguous here.
20:28:51 <kallisti> because 4 is overloaded to any Num instance
20:29:01 <kallisti> and well
20:29:01 <byorgey> Orclev_: well, you can always ask for the type of something in ghci.
20:29:04 <kallisti> the whole thing is ambiguous.
20:29:23 <Orclev_> yeah, it tells me the type is Num b, but it doesn't tell me what the arrow is
20:29:32 <kallisti> Orclev_: if it doesn't tell you then it doesn't know.
20:29:35 <Orclev_> that is, in Arrow a b b, b is Num, but what is a?
20:29:42 <byorgey> kallisti: it's not ambiguous.
20:29:50 <monochrom> :t safeFromJust
20:29:51 <lambdabot> forall a. Maybe a -> Maybe a
20:29:54 <monochrom> \∩/
20:30:00 <byorgey> Orclev_: in this case, in order to typecheck 'returnA 4', returnA has to have a function type, right?
20:30:16 <kallisti> byorgey: ah, indeed.
20:30:48 <byorgey> Orclev_: so in order to unify  a b b   with   something -> something,  we must have  a = (->)
20:30:50 <Orclev_> aren't ghci inputs evaluated as: m a
20:30:59 * kallisti should just stay quiet the remainder of the night until he passes out.
20:31:02 <Orclev_> specificaly IO a
20:31:05 <byorgey> Orclev_: no, only if they have an IO type
20:31:17 <Orclev_> hmm
20:31:23 <byorgey> Orclev_: if you enter an expression of some other type it just evaluates them and prints the result
20:31:31 <dibblego> dmwit: I comment that we should rename (|||) to be dissimilar to Control.Arrow and explicitly warn about its properties -- awaiting roconnor's response -- thanks for your opinion
20:32:19 <Orclev_> so if it resolves the arrow to be function (->) what's the input, and why does it print 4?... conceptually I thought returnA 4 was like (\_ -> 4)
20:32:36 <elliott> monochrom: That smiley always makes me think you're wearing a white sheet and pretending to be a ghost.
20:32:40 <byorgey> Orclev_: no, returnA is like  \x -> x
20:32:53 <byorgey> Orclev_: in fact, when a = (->)  returnA  IS  \x -> x
20:32:59 <monochrom> I'm pretending to be a robot, but ghost is also ok :)
20:33:00 <byorgey> so  (\x -> x) 4 = 4.
20:33:08 <Orclev_> so it's just id?
20:33:13 <byorgey> Orclev_: yep =)
20:33:44 <byorgey> Orclev_: in fact, it is implemented as 'returnA = arr id'
20:33:58 <byorgey> and for the (->) arrow,  arr is also id
20:34:18 <kallisti> > id id id id id id id id `id` 2
20:34:19 <lambdabot>   2
20:34:23 <Orclev_> is there a standard arrow function for (\_ -> x)?
20:35:01 <byorgey> Orclev_: arr const, but I don't think it has a special name
20:35:33 <Orclev_> ok, thanks
20:36:00 <kallisti> I wonder if there's ever a good reason to use `id` like $
20:36:19 <kallisti> I guess if you want to avoid parentheses but nest within a lower precedence operator.
20:36:51 <byorgey> no.
20:36:56 <byorgey> =)
20:36:58 <kallisti> [on command := void `id` do ...]
20:37:16 <byorgey> the only good reason I know of to use `id` like $ is to impress/confuse newbies
20:37:22 <byorgey> s/good//
20:38:01 <monochrom> > id do Nothing
20:38:01 <lambdabot>   <no location info>: parse error on input `do'
20:38:16 <monochrom> too bad. was going for both English and Haskell
20:38:38 <monochrom> > `id` do Nothing
20:38:39 <lambdabot>   <no location info>: parse error on input ``'
20:38:53 <kallisti> > (do Nothing `id`)
20:38:54 <lambdabot>   <no location info>: parse error on input `)'
20:39:00 <kallisti> no PostfixOperators I see.
20:39:01 <elliott> monochrom: guess we need i'd :: a -> a
20:41:02 * kallisti eagerly awaits OverloadedSequences, AgdaMixfix, InterpolatedString-Perl6, and UndecidableSyntax
20:44:10 <Orclev_> so, in arrow do notation, is (b -< a) approximately equivalent to (arr a >>> b)
20:47:01 <kallisti> Orclev_: not quite
20:47:13 <kallisti> that's an incomplete syntax fragment.
20:47:35 <kallisti> proc x ->  ...
20:47:37 <kallisti> part as well
20:48:11 <kallisti> oh wait
20:48:46 <Orclev_> I'm just trying to figure out how a block of do notation translates into an equivalent set of arrow combinators in the way monadic do notation translations into >>= and >>
20:52:08 <kallisti> Orclev_: a is the parameter to the lambda passed to arr
20:52:29 <kallisti> in...
20:52:46 <kallisti> proc a -> a -< f
20:53:12 <kallisti> so in just the syntactic form:  x -< y
20:53:22 <kallisti> x is the result of the lambda passed to arr.
20:53:30 <Orclev_> I thought it was the other way around, as in: proc x -> f -< x
20:53:47 <kallisti> er, right.
20:54:40 <kallisti> so that it looks more like function application.
20:54:53 <kallisti> rather than a right arrow composition.
21:08:01 * hackagebot path-pieces 0.1.1 - Components of paths.  http://hackage.haskell.org/package/path-pieces-0.1.1 (MichaelSnoyman)
21:09:48 <nyingen> @quote
21:09:48 <lambdabot> astrolabe says: I put my thing in inverted commas because it isn't a really stalactite, but it looks like one, and contains nitrates from urea.
21:10:16 <nyingen> lol wut
21:11:11 <Rotaerk> ..
21:12:15 <Orclev_> so, using a kleisli arrow you can wrap IO and use it with arrows, but what's the arrow equivalent of >>? I've got x bound to Kleisli IO Int () and y bound to Kleisli IO Int (), and now I want to return the equivalent of x >> y... returnA -< x >> y does what I want but feels hackish
21:13:45 <Orclev_> I've got a feeling my problem understanding this is because of the do notation and if I could write it without it I'd understand better
21:28:01 * hackagebot http-conduit 1.4.0 - HTTP client package with conduit interface and HTTPS support.  http://hackage.haskell.org/package/http-conduit-1.4.0 (MichaelSnoyman)
21:28:03 * hackagebot authenticate 1.2.0 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.2.0 (MichaelSnoyman)
21:33:03 * hackagebot wai 1.2.0 - Web Application Interface.  http://hackage.haskell.org/package/wai-1.2.0 (MichaelSnoyman)
21:37:22 <nyingen> @quote
21:37:22 <lambdabot> dibblego says: it's almost as if we should be using a lazy language
21:37:26 <nyingen> @quote
21:37:26 <lambdabot> darcs says: Repositories seem to be unrelated. Proceed?
21:37:33 <nyingen> heh
21:38:05 * hackagebot wai-app-static 1.2.0 - WAI application for static serving  http://hackage.haskell.org/package/wai-app-static-1.2.0 (MichaelSnoyman)
21:38:07 * hackagebot wai-eventsource 1.2.0 - WAI support for server-sent events  http://hackage.haskell.org/package/wai-eventsource-1.2.0 (MichaelSnoyman)
21:38:09 * hackagebot wai-extra 1.2.0 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.2.0 (MichaelSnoyman)
21:38:11 * hackagebot wai-frontend-monadcgi 1.2.0 - Run CGI apps on WAI.  http://hackage.haskell.org/package/wai-frontend-monadcgi-1.2.0 (MichaelSnoyman)
21:38:13 * hackagebot wai-handler-devel 1.2.0 - WAI server that automatically reloads code after modification.  http://hackage.haskell.org/package/wai-handler-devel-1.2.0 (MichaelSnoyman)
21:43:15 * hackagebot wai-handler-fastcgi 1.2.0 - Wai handler to fastcgi  http://hackage.haskell.org/package/wai-handler-fastcgi-1.2.0 (MichaelSnoyman)
21:43:18 * hackagebot wai-handler-launch 1.2.0 - Launch a web app in the default browser.  http://hackage.haskell.org/package/wai-handler-launch-1.2.0 (MichaelSnoyman)
21:43:20 * hackagebot wai-handler-scgi 1.2.0 - Wai handler to SCGI  http://hackage.haskell.org/package/wai-handler-scgi-1.2.0 (MichaelSnoyman)
21:43:21 * hackagebot wai-test 1.2.0 - Unit test framework (built on HUnit) for WAI applications.  http://hackage.haskell.org/package/wai-test-1.2.0 (MichaelSnoyman)
21:43:23 * hackagebot wai-websockets 1.2.0 - Provide a bridge betweeen WAI and the websockets package.  http://hackage.haskell.org/package/wai-websockets-1.2.0 (MichaelSnoyman)
21:45:57 <ion> Please stop writing software, everyone. You’re flooding the channel.
21:46:37 <luite> there will probably some more, I think he's uploading the Yesod 1.0 release after this
21:46:42 <nyingen> by 'everyone', you mean 'Michael Snoyman"
21:47:52 <nyingen> @quote
21:47:53 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
21:47:55 <nyingen> @quote
21:47:56 <lambdabot> Catfish_Man says: Well, at a first approximation Haskell is an overpowered DSL for generating Fibonacci numbers.
21:48:26 * hackagebot warp 1.2.0 - A fast, light-weight web server for WAI applications.  http://hackage.haskell.org/package/warp-1.2.0 (MichaelSnoyman)
21:48:28 * hackagebot warp-static 1.2.0 - Static file server based on Warp and wai-app-static  http://hackage.haskell.org/package/warp-static-1.2.0 (MichaelSnoyman)
21:48:30 * hackagebot warp-tls 1.2.0 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.2.0 (MichaelSnoyman)
21:48:32 * hackagebot authenticate 1.2.0.1 - Authentication methods for Haskell web applications.  http://hackage.haskell.org/package/authenticate-1.2.0.1 (MichaelSnoyman)
21:48:34 * hackagebot yaml 0.7.0 - Low-level binding to the libyaml C library.  http://hackage.haskell.org/package/yaml-0.7.0 (MichaelSnoyman)
21:53:36 * hackagebot json2yaml 0.3.1 - Utility to convert a file from JSON to YAML format.  http://hackage.haskell.org/package/json2yaml-0.3.1 (MichaelSnoyman)
21:53:38 * hackagebot tagstream-conduit 0.3.0 - streamlined html tag parser  http://hackage.haskell.org/package/tagstream-conduit-0.3.0 (MichaelSnoyman)
21:54:43 <lispy> I really liked the HERP and DERP proposal on haskell-cafe yesterday
21:54:46 <lispy> Quite cute.
21:56:20 <ion> :-)
21:58:04 * hackagebot crypto-conduit 0.3.0 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.3.0 (MichaelSnoyman)
21:58:06 * hackagebot hamlet 1.0.0 - Haml-like template files that are compile-time checked  http://hackage.haskell.org/package/hamlet-1.0.0 (MichaelSnoyman)
21:58:08 * hackagebot servius 1.0.0 - Serve Shakespearean templates via Warp  http://hackage.haskell.org/package/servius-1.0.0 (MichaelSnoyman)
22:00:52 <nyingen> lispy: yeah, it was a great practical joke
22:01:12 <nyingen> "Oh man, *another* record proposal? ..."
22:03:10 * hackagebot shakespeare-css 1.0.0 - Stick your haskell variables into css at compile time.  http://hackage.haskell.org/package/shakespeare-css-1.0.0 (MichaelSnoyman)
22:03:12 * hackagebot shakespeare-i18n 1.0.0 - A type-based approach to internationalization.  http://hackage.haskell.org/package/shakespeare-i18n-1.0.0 (MichaelSnoyman)
22:03:14 * hackagebot shakespeare-js 1.0.0 - Stick your haskell variables into javascript/coffeescript at compile time.  http://hackage.haskell.org/package/shakespeare-js-1.0.0 (MichaelSnoyman)
22:03:16 * hackagebot shakespeare-text 1.0.0 - Interpolation with quasi-quotation: put variables strings  http://hackage.haskell.org/package/shakespeare-text-1.0.0 (MichaelSnoyman)
22:08:04 * hackagebot authenticate-oauth 1.3.0 - Library to authenticate with OAuth for Haskell web applications.  http://hackage.haskell.org/package/authenticate-oauth-1.3.0 (HiromiIshii)
22:14:03 <nyingen> @quote
22:14:03 <lambdabot> X-G says: If you don't care so much about performance, but want to be able to mash random keys and have them be a program that ends world hunger, Perl is for you
22:18:04 * hackagebot persistent 0.9.0 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.9.0 (MichaelSnoyman)
22:18:06 * hackagebot persistent-mongoDB 0.9.0 - Backend for the persistent library using mongoDB.  http://hackage.haskell.org/package/persistent-mongoDB-0.9.0 (MichaelSnoyman)
22:18:08 * hackagebot persistent-mysql 0.9.0 - Backend for the persistent library using MySQL database server.  http://hackage.haskell.org/package/persistent-mysql-0.9.0 (MichaelSnoyman)
22:18:10 * hackagebot persistent-postgresql 0.9.0 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.9.0 (MichaelSnoyman)
22:18:12 * hackagebot persistent-sqlite 0.9.0 - Backend for the persistent library using sqlite3.  http://hackage.haskell.org/package/persistent-sqlite-0.9.0 (MichaelSnoyman)
22:23:14 * hackagebot persistent-template 0.9.0 - Type-safe, non-relational, multi-backend persistence.  http://hackage.haskell.org/package/persistent-template-0.9.0 (MichaelSnoyman)
22:23:16 * hackagebot xml-conduit 0.7.0.1 - Pure-Haskell utilities for dealing with XML with the conduit package.  http://hackage.haskell.org/package/xml-conduit-0.7.0.1 (MichaelSnoyman)
22:23:18 * hackagebot pool-conduit 0.1.0 - Resource pool allocations via ResourceT.  http://hackage.haskell.org/package/pool-conduit-0.1.0 (MichaelSnoyman)
22:36:58 <nyingen> @quote
22:36:58 <lambdabot> kmc: says: (): worst monoid ever
22:43:21 <mjrosenb> @quote
22:43:21 <lambdabot> urxvt-transparency says: http://lists.schmorp.de/pipermail/rxvt-unicode/2008q1/000552.html
22:43:38 <shachaf> @quote mjrosenb
22:43:38 <lambdabot> mjrosenb says: <3 #haskell; "why doesn't this program typecheck?" ;  5 hours of category theory later, op left 4 hours ago
22:45:33 <nyingen> @quote shachaf
22:45:34 <lambdabot> shachaf says: Sufficiently advanced misunderstanding is indistinguishable from trolling.
22:45:51 <nyingen> like that zzo87 guy?
22:45:55 <nyingen> and also protontorpedo
22:46:00 <nyingen> @protontorpedo
22:46:01 <lambdabot> whera re the end user apps?
22:48:18 <nyingen> @protontorpedo
22:48:19 <lambdabot> so haskell is new and improved c?
22:49:54 <tgeeky_> @quote futurama
22:49:54 <lambdabot> futurama says: And the box itself is probably worth something too!
23:13:06 * hackagebot tls-debug 0.1.0 - Set of programs for TLS testing and debugging  http://hackage.haskell.org/package/tls-debug-0.1.0 (VincentHanquez)
23:48:08 * hackagebot fclabels-monadlib 0.2.1 - MonadLib monadic interface for the "fclabels" package.  http://hackage.haskell.org/package/fclabels-monadlib-0.2.1 (BardurArantsson)
23:58:08 <osa1> does anyone here know a websocket server written in haskell? I'm having trouble catching disconnections and pinging
