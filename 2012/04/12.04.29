00:00:08 <salisbury> would it be beneficial to study lambda calculus?
00:00:50 <salisbury> or, should I say, what are the advantages to learning lambda calculus?
00:01:36 <dmwit> Are you, or will you ever be, interested in the internals of your compiler?
00:03:21 <salisbury> potentially
00:04:21 <yitz> salisbury: even if not, it's really cool stuff. i think every programmer ought to have seen at least the very basics of lambda calculus.
00:04:26 <dmwit> Okay. Most of the explanations of how things work are academic papers; the academic papers are generally phrased in terms of (typed, extended) lambda calculi.
00:04:52 <dmwit> So if you want to understand those, starting with the (untyped) lambda calculus will help a lot.
00:06:16 <salisbury> if you were to have the choice between working through a text on automata or lambda calc
00:06:49 <dmwit> Me? Lambda calculus, no contest.
00:06:56 <dmwit> But that doesn't necessarily make it the right choice for you.
00:07:29 <salisbury> I am primarily interesting in (eventually) writing a problem-specific language
00:07:49 <dmwit> If you don't know about regular languages, CFGs, (semi-)decidability, Turing machines... those things are pretty fundamental computer science, too.
00:07:51 <yitz> salisbury: automata is ok provided that you read roconnor's post about *-semirings
00:08:49 <dmwit> If your end goal is implementing your own language, though, lambda calculus is the place to start.
00:08:57 <dmwit> All sane type systems are phrased as lambda calculi.
00:09:50 <salisbury> are there any particular favoured/recommended texts?
00:10:08 <dmwit> Types and Programming Languages is great.
00:10:53 * hackagebot hoauth2 0.1.2 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.1.2 (HaishengWu)
00:12:43 <salisbury> oh, I actually own that
00:13:06 <roconnor> salisbury: I like TTFP
00:13:10 <roconnor> @where TTFP
00:13:11 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
00:14:53 <salisbury> hmm, TTFP seems to focus more exclusively  on lambda calc
00:16:36 <Ngevd> Hello
00:16:44 <salisbury> I think I will have a look at that. Thanks yitz, dmwit, roconnor for your input
00:18:39 <ment> how does one read little endian word32 from a handle? (aside from reading four word8 and shifting/oring them)
00:19:57 <dmwit> ment: Use the binary package.
00:20:03 <dmwit> getWord32le :: Get Word32
00:20:27 <dmwit> Of course internally it reads four Word8's and shift/or's them.
00:22:22 <ment> dmwit: thanks!
00:22:32 <shachaf> dmwit: That's "of course"?
00:23:29 <dmwit> Not much else you can do in a cross-platform language.
00:23:37 <ment> shachaf: otherwise you get lost in #ifdefs
00:27:48 <randomclown> how do I make a nth dimensional array?
00:28:02 <dmwit> ?hackage repa
00:28:02 <lambdabot> http://hackage.haskell.org/package/repa
00:28:16 <dmwit> Or just use Array.
00:28:46 <randomclown> I mean I don't know the size of the inital indexer
00:31:21 <brutax> Correct me if I'm wrong, but is an array really the right datastructure if you don't know the size?
00:31:30 <dmwit> randomclown: Use Array, and write an instance Ix a => Ix [a].
00:31:35 <dmwit> =P
00:32:11 <liyang> Who need some poncy data structure? In my day arrays were all we had!
00:32:34 <randomclown> well everything else is painful
00:32:56 <randomclown> for the longest common substring problem
00:33:33 <brutax> mmm, but is an array "read only" in that algorithm
00:33:53 <brutax> Because updating arrays is REALLY painful I believe
00:34:11 <dmwit> There are mutable arrays.
00:34:16 <brutax> Ooh1
00:34:25 <brutax> Which ones?
00:34:31 <randomclown> probably easier in Java
00:34:47 <dmwit> brutax: ...the ones with "M" in their name. =P
00:35:08 <brutax> Thanks, gotta check them out
00:35:10 <dmwit> There's {IO/ST}{U/}Array
02:37:13 --- topic: '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]'
02:37:13 --- topic: set by glguy on [Wed Apr 18 20:44:31 2012]
02:37:13 --- names: list (clog seafood nonefool MrFahrenheit rtharper vithos vodik Schadenfreude_ Peaker__ confab trin_cz tufisi btby cfricke LtWorf fxr bru` zhulikas aib raichoo drgreenthumb jeetu gniourf_gniourf owst ksf mceier c_wraith blobb_ dwhj dek5 allbery_b ceii__ DevHC^ djfxc asante nohonor dschoepe Palmik miclorb_ hrehf Claudius1aximus ablokzijl bitonic timthelion FACEFOX-DOT-COM benkolera cmears mcglk milessabin shintah wli insomniaSalt rprije kish Twey brutax yousong)
02:37:13 --- names: list (moriarty roconnor vlprans meanburrito920 Sondre_B ftrvxmtrx setekhid pikhq vili mysticc Hugglesworth treyka davidL tessier Beetny` julmuri boccato sizz Proge ProGen scm siracusa yonahw hamishmack yitz favonia kowalej fragamus Philonous_ otto_s wespee_ chu Darkflux MoALTz wollw Zamarok sd__ gienah Quantumplation salisbury mgsloan irene-knapp JaffaCake1 homie otters randomclown ulfdoz xarts_ timemage dirthead rfw_ descender Karmaon niloc132 ozgura Shanachan)
02:37:13 --- names: list (DustyDingo gentleben Tesseraction OlegYch|h dgpratt ormaaj waern adlan ipuustin Philippa amiri em Baughn JamesJRH bmfx mauke Paprikachu copumpkin junsuijin xinming Cale preflex alek_b alvis ben theorbtwo macobo geofft brisbin h0st1le Peaker master_of_master Lemon sporous jmcarthur quaestor Lennier ldj X-Scale hgolden xian jfredett elnn_ dobblego jonaskoelker dan_dan__ PointFree hiato yeltzooo milli rgr Boney iulian LeninParty anonus cheater__ Vq EarlGray nus)
02:37:13 --- names: list (DasIch SoupEvil ace2001ac Deewiant [[zz]] snorble_ AtnNn DrSyzygy augur dywi Elemir A1kmm EyesIsMine AlbireoX iFire dbank jsgf sgronblo drmegahertz m3ga noam kallisti Draconx Ralith mkaito parcs` almostsix blackdog tromp Plex- smarter The_third_man MrBusiness jbauman weexplat lambdanaut neptunepink magicman Alan kakos FACEFOX Sgeo_ kekimmo skiold perlite stepcut keseldude b52 Axman6 hashbrowncipher Khisanth wunki sanjoyd tgeeky dMazz dabradley andersk julmae)
02:37:13 --- names: list (coeus codekoala Apocalisp decltype xsysstar jonke_ florent_ Jaak TML demolithion edwinb akahn wto wires ski comak adimit dsfox Innominate schroedinbug albel727 olsner vold traviscline hive-mind bpg dom96 peddie silver __main__ Lemmih knyppeldynan mrno_ cods endojelly myme ment kaol absentswett Botje Ornedan_ saurik_ l4mbd4 Modius` birkenfeld bcoppens jml sunfun linduxed ahihi2 MostAwesomeDude retronym xnyhps kniu joeytwiddle levitation[A] sawjig tsuraan_)
02:37:13 --- names: list (SimonRC drdo gerard0 tempire tnzr jix stilgart EvanR akosch AntiSpamMeta reinoud dp_wiz gwern pcapriotti _null frigga1 quuxman seolfor tamiko mdmkolbe nowhereman tavelram Dashkal Luke Spockz Eiam Bwild ozataman mjo dan64 wilfredh sykora SmartViking tew88 otterdam c1de0x ocharles joe-generic Paks xarch thetallguy smly- freiksenet mattp_ MK_FG rhapsodhy Valodim zorzar_ robinbb brainproxy lambdabot __class__ amiller Tene `0660_ copton_ LauJensen mimi_vx)
02:37:13 --- names: list (mrdomino zenzike_ edwtjo_ flori_ Sunhay Martty alpounet sunnavy rwbarton arkx_ dlmalloc mikeplus64 spanner Utkarsh fireglow chops__ k6b hassing RogueShadow training4zombies Jonno_FTW dropdrive liesen SamB_XP pjdelport hiredman peterhil R496 thirsteh wo0kie average_drifter shachaf r126f ZenWare aristid-ic FalkoPeters bobry warpy Nisstyre brweber2_ NimeshNeema mndrix lopex puzza007 nkpart srid arnihermann_ ocharles_ Xorlev xrl tomh si14 mimico_afk IbnFirnas)
02:37:13 --- names: list (SeanTAllen tsou Nemykal blackrain welterde zk Zenith77 Phlogistique shoerain yrlnry Nshag identity_ dmwit gentz martiert ArchGT int-e sm Zephyrus _root_ ville jeff_s_ pyrtsa caligula jyyou zw01 moonlite Eliel saruman_ gwillen mxweas Counter-Strike Bassetts zygoloid jaxtr ivan\ tg klugez deggis kobsu drbean bddn vmeson frontendloader Gracenotes nyingen suiside mbernstein ja_ alang fmap owst_ setmeaway barrucadu wolong helgikrs kolmodin_ mee Jaxan_ andrewsw)
02:37:13 --- names: list (wagle wting petanqk shutdown_-h_now hayashi gdeest kaitocracy wavewave PreciousMetals Will| fukushim_ amiddelk olahol_ dnm Yarou ahf emias herself chris2 thetallguy1 untwisted kleini\ Urchin sordina1 Nimatek eXeC64 sclv profmakx i1126 agundry monochrom joachifm pantski bezik Masxmasx sipa solarus egerlach inr electrogeek jrockway hpaste_ noj septic OnionKnight Mitar Guest23437 ray Nereid phrst jlaire lomeo idnar integral samek ricky Derander prti opqdonut)
02:37:13 --- names: list (xaimus anssik chr1s_ Arnar dju noddy gereedy brendyn fabjan kalven quicksilver sagelywizard SHODAN dcolish dax S^T^R^A^G^E^R Wooga flamingspinach acfoltzer sohum MasseR zmoazeni_ Saizan nibalizer blast_hardcheese shepheb popx Belgarion0 cjay waterlaz kosmikus eintopf Varakh Entroacceptor CosmicRa` chra Ptival byorgey mornfall hpc fall_ DrMahogny Munksgaa1d anders^^ adnam lnostdal mjhan_ tlockney mm|swarm koninkje_away zeiris bxc dominikh tazjin lispy dumael)
02:37:13 --- names: list (lpsmith wereHamster danr rmunroe ByronJohnson audunska_ brett thoughtpolice_ Vulpyne_ seabot MrNibbles peterhil` niko Zarathu Tinned_Tuna sjl kiddesr_ duairc_ mokus dowski aliak_ flux Gilly angstrom luite jrk Fnar bogner sajith matthiasgorgens pqmodn FireFly norm2782 Dybber majuscule def-lkb oddraisent KitB dkasak scgilardi ppilate mehitabel hikingpete locci clsmith fwg identity1 mlh tzxn3 pfoetchen CindyLinz nimred ccasin jamiely_desktop1 qtplatypus Nanar)
02:37:13 --- names: list (newsham tapoutmma ps-auxw mm_freak zaiste adnauseam anachron koeskoes mux ggreg hyko tomprince certainty hugin maloi mike2 BMeph totte jssanders Cerise brandonw nlogax willb Internet13 rvchangue kizzo pr epsil jgr[detached] cola_zero Damn3d_ mateu djahandarie stepnem Enigmagic mn90018 nand` tauntaun etpace mrd eno gseitz djanatyn pharaun LeNsTR McManiaC mjrosenb adnap noplamodo simsaladin Ayvee Laney Dodek jrib tafryn kissyboy davean mtbeedee JoshAshby)
02:37:13 --- names: list (SonicvanaJr felipe_ sig_wall ahkurtz_ xplat BrianHV ft ChristianS dcoutts beppu fryguybob Pursuit cmrn nihtml fxkr henr_k Draggor PHO_ gemelen Obfuscate strlen limetree ehamberg gdsx_ jaspervdj bd_ pyykkis zomg johs _janne seats levi thoughtpolice Adios KaneTW snarkyboojum srcerer mendez thorkilnaur ybit liyang Aikawa gredman othiym23 Maxdamantus ivan` jayne eyck mrLite colah s4msung tomaw robbert pettter saiam routin mietek mantovani hackagebot tomku)
02:37:13 --- names: list (chipdude mrshoe BigEndian brixen Raynes dilinger Redshift64 Liskni_si tridactyla froztbyte pi8028 lokydor_ osfameron joe_k_ boyscared dixie dino- dqd majoh Gcool alexsdutton sully kkris pou joni6128 bens Gothmog_ Starfire canard earthy ousado rhodesd aluink companion_cube deavid jabirali srh jrslepak_neu @Igloo mroman_ obcode jackhill FUZxxl ernst absence mercury^ aristid Veinor kategeek Athas yan_ nathanel_ taruti flazz cynick Ke guerrilla confound ciaranm)
02:37:13 --- names: list (@ChanServ jlewis jd10 kloeri companion_square pdxleif rcj_ jlouis marienz ibid Astro- elgot koala_man Clex fattrat tsuraan__ ziman reacocard lebastr aszlig Razz smop chee1 statusfailed cschneid Clint idoru Guest69499 Yahovah BlastHardcheese)
02:40:54 <hpaste_> Sondre pasted “Haskell” at http://hpaste.org/67824
02:40:57 * hackagebot hedis-pile 0.5.3 - Caching mandatory data with Redis  http://hackage.haskell.org/package/hedis-pile-0.5.3 (AlexanderDorofeev)
02:41:48 <Sondre_B> Can someone please have a look at this code. Look at the solutions function. The error is pasted there, and example output. But I cannot get the code to work. Can anyone see what I am doing wrong?
02:41:49 <Sondre_B> http://hpaste.org/67824
02:47:38 <dmwit> Sondre_B: solutions returns a list, but in a clause like (x, solutions (f (Con x))), the second part of the tuple is expected to be a single value
02:48:28 <dmwit> you may be interested in concatMap
02:48:32 <dmwit> :t concatMap
02:48:33 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
02:51:37 <Sondre_B> well, I changed that part a little bit: (x, (f (Con x))) so now it will return (a, Formula as) but it wants (a, as). How do I get the as from Formula as?
02:52:34 <dmwit> Isn't that pretty much what solutions does?
02:53:08 <dmwit> I don't think it's wrong to call solutions recursively. You just need a bit more mangling of what it returns than just throwing it in the tuple.
02:53:53 <Sondre_B> well, I do.. this is the third and last line of the solutions: solutions (Forall (x:xs) f) = (x, (f (Con x))) : solutions (Forall xs f)
02:56:11 <Sondre_B> now, instead of returning (a, [as]) it will return (a, Formula as), which is still wrong. It should return (a, as). So you might as why I change from wrong to wrong. In the first solution i returned [()] as 'as', but that was hardcoded. It should return () because Formula is returning an empty tuple
02:56:25 <Sondre_B> not because I know that, and then just hardcode it in
02:57:01 <yitz> Sondre_B: why does the definition of Formula have the parameter ts that appears nowhere on the RHS?
02:58:20 <Sondre_B> ts is just a renaming of the value (tuple) passed in with Formula (no?)
02:59:12 <yitz> it is not a renaming of anything, the way you have it currently
02:59:48 <dmwit> yitz: I think maybe you are confused about GADT syntax.
03:00:01 <hpaste_> Sondre pasted “Haskell2” at http://hpaste.org/67825
03:00:08 <dmwit> yitz: "data Foo a" is not a binder for "a" when using GADTs.
03:00:23 <Sondre_B> but this works: http://hpaste.org/67825
03:00:45 <yitz> dmwit: ah i see. right. for Body, ts is (), and for Forall, it's the tuple. ok
03:01:39 <dmwit> yitz: I 100% agree with you that the definition of Formula is very weird, though.
03:01:49 <Sondre_B> dammit, cannot seem to solve this :(
03:02:31 <dmwit> I feel like giving any more hints would be going too far.
03:02:35 <dmwit> This is homework, right?
03:03:07 <dmwit> ?localtime Sondre_B
03:03:08 <lambdabot> Local time for Sondre_B is Sun Apr 29 20:02:47 2012
03:03:31 <Sondre_B> yes, the last part. I think my solution is very close, but there is just this.. cannot match 'as' with 'Formula as' that I can't seem to solve
03:03:36 <dmwit> I was going to suggest getting some rest, but it seems to be still early. =)
03:03:50 <Sondre_B> well, I got 4 more hours
03:04:07 <dmwit> Well, I've given my hints. The function "solutions" converts a Formula as to an [as], which is most of the way there.
03:05:16 <dmwit> I must say the sample inputs and outputs make me a bit nervous, though: they don't look like they're computing an *interesting* function, which makes me think you may have misunderstood the assignment.
03:05:18 <yitz> dmwit: well for the Forall constructor, sort of.
03:05:28 <Sondre_B> well, it only does that because I have hardcoded it to do so. Pattern match on body returns a [()]. I just think it should be a bit more generic?
03:05:57 <Sondre_B> the sample input and outputs are given to us
03:06:14 <yitz> Sondre_B: what of what you pasted is part of the original assignment, and what part did you write yourself?
03:07:13 <Sondre_B> I haven't included the parts I wrote myself, because they aren't reused in the last part. So the example functions, the output (comments) and the definitions are given to us. Not mine.
03:07:14 <dmwit> Oh, I see, I misread the samples.
03:07:54 <dmwit> So, yes, I'm even more confident of my advice now.
03:08:27 <Sondre_B> ok, I'll go back and explore concatMap a bit more then :)
03:13:37 <newbie2012> hello, as my name implies, I have a small question about haskell :)
03:13:52 <shachaf> You should ask it!
03:13:58 <shachaf> Otherwise you might never get an answer.
03:14:22 <newbie2012> ok, I'm having trouble reasoning about the way things are being evaluated, in the context of a performance issue
03:15:11 <newbie2012> take this little code: foldl' (\acc1 x-> Map.insert x True acc1 ) (Map.empty) [875714,875713..1]
03:15:26 <newbie2012> this runs reasonably fast
03:15:37 <newbie2012> but if I want to collect a tuple of maps, like
03:16:08 <newbie2012> foldl' (\(acc1,acc2) x-> (Map.insert x True acc1,Map.insert x 2 acc2) ) (Map.empty,Map.empty) [875714,875713..1] -- basically, collect 2 maps instead of one
03:16:27 <ment> @hoogle [a] -> Bool
03:16:27 <lambdabot> Prelude null :: [a] -> Bool
03:16:28 <lambdabot> Data.List null :: [a] -> Bool
03:16:28 <lambdabot> Prelude all :: (a -> Bool) -> [a] -> Bool
03:16:28 <dmwit> Surprise! Strictness only goes one constructor deep.
03:16:48 <dmwit> You can use seq to deal with this.
03:16:51 <dmwit> e.g.
03:16:57 <mauke> \(!acc1, !acc2) -> ?
03:16:58 <newbie2012> aa, I see, that's why memory for the second part blows to 200 megs
03:17:05 <dmwit> \(acc1,acc2) x -> acc1 `seq` acc2 `seq` (..., ...)
03:17:14 <shachaf> \(!acc1,!acc2) -> ... ?
03:17:18 <dmwit> or use bang patterns as mauke suggests
03:17:23 <shachaf> Oh.
03:17:32 <shachaf> Right, what mauke said.
03:17:36 <shachaf> Or use a strict pair type.
03:17:54 <mauke> data Pair a b = Pair !a !b
03:18:05 <shachaf> In this particular case you could use an unpacked strict pair of some Num type to reduce memory usage even more.
03:18:10 <shachaf> But that's a different sort of issue. :-)
03:18:21 <mauke> IntMap
03:18:22 <newbie2012> yes, I'm enlightened now, thank you very much :)
03:19:12 <shachaf> Also you can use a Set for a map-of-things-to-True. :-)
03:20:10 <dmwit> What if he wants a map-of-things-to-True-or-False?
03:20:11 <newbie2012> oh, I just made the example to not bother you with the more complicated things I have to hold in the maps :)
03:20:16 <mauke> and inRange for a contiguous set
03:21:43 <shachaf> And () for an empty set.
03:22:53 <dmwit> Somewhere there's a comment or quote along the lines of "GHC has a lot of zero-bit registers".
03:32:34 <timthelion> dmwit: they should have just made Maybe fundimental.  So that ALL types would be Maybe something :D
03:33:51 <timthelion> that way 1 / 0 could return Nothing, head [] Nothing, and we could have an error free Prelude :D
03:36:01 * hackagebot timeplot 1.0.7 - A tool for visualizing time series from log files.  http://hackage.haskell.org/package/timeplot-1.0.7 (EugeneKirpichov)
03:36:39 <yitz> @quote zero
03:36:39 <lambdabot> shapr says: <shapr> I completely misread that as "Man injured in possible math lab explosion" <catpants> divided by zero, eh?
03:36:46 <yitz> @quote zero
03:36:47 <lambdabot> MarkPilgrim says: "In the long run, the utility of all non-Free software approaches zero. All non-Free software is a dead end."
03:36:57 <yitz> @quote registers
03:36:58 <lambdabot> kmc says: SSE9. Where the registers are 1 megabyte long and there's an instruction for PACKED SATURATED DOUBLE-PRECISION PARSE XML AND CONSTRUCT FACEBOOK API QUERY. I believe the mnemonic is
03:36:58 <lambdabot> PSDPPXACFAQ
03:43:07 <ment> @hoogle Int64 -> Int
03:43:08 <lambdabot> Foreign.Storable alignment :: Storable a => a -> Int
03:43:08 <lambdabot> Foreign.Storable sizeOf :: Storable a => a -> Int
03:43:08 <lambdabot> Data.Generics.Schemes gsize :: Data a => a -> Int
03:43:32 <shachaf> ment: fromIntegral
03:43:37 <shachaf> @brain
03:43:38 <lambdabot> Well, I think so Brain, but what if we stick to the seat covers?
03:43:49 <shachaf> @brain
03:43:49 <lambdabot> Narf!
03:43:58 <ment> shachaf: thanks
04:01:04 * hackagebot http-proxy 0.0.12 - A library for writing HTTP and HTTPS proxies  http://hackage.haskell.org/package/http-proxy-0.0.12 (ErikDeCastroLopo)
04:01:21 <hpaste_> ment pasted “stack overflow” at http://hpaste.org/67826
04:01:36 <ment> why does this ^^ overflow the stack?
04:02:34 <ment> how to write this so it would be reasonably fast on large inputs and didn't have surreal memory requirements?
04:03:13 <Botje> acc accumulates in a thunk.
04:03:32 <Botje> checksum $! (acc `xor` acc') -- should do the trick
04:04:41 <ment> Botje: i see, thanks
04:05:08 <ment> it still takes 3.4 seconds to checksum 16MB worth of data though
04:06:01 <donri> @hackage digest
04:06:01 <lambdabot> http://hackage.haskell.org/package/digest
04:06:40 <Botje> ment: you're compiling with -O2, right?
04:06:49 <ment> Botje: nope
04:07:17 <ment> good, now it's down to 0.6 secs, that's reasonable
04:07:33 <donri> try adler32 from the digest package above
04:08:24 <ment> donri: the checksum function is not the point, i was trying to figure out why was reading stuff from bytestring so slow
04:08:48 <ment> donri: and i guess that the adler32 implementation relies on C anyway
04:08:54 <donri> yes
04:15:11 <roha> can somebody recommend a library for sending emails, possibly one which doesn't need a local mail server?
04:24:07 <jeetu> :q
04:25:05 <hpaste_> ment pasted “too slow” at http://hpaste.org/67828
04:25:15 <ment> any idea why is this so slow?
04:25:50 <ment> (or any recommended way how to read 16MB blob of binary data and convert it to some kind of immutable random access data structure?)
04:27:41 <flamingspinach> In the gentle introduction: "The way ":" is defined here is actually legal syntax---infix constructors are permitted in data declarations, and are distinguished from infix operators (for pattern-matching purposes) by the fact that they must begin with a ":" (a property trivially satisfied by ":").]"
04:27:42 <flamingspinach> The declaration it's referring to (as far as I can tell) is: "data [a] = [] | a : [a]"
04:27:42 <flamingspinach> Can someone explain what this is supposed to mean? Is it saying that in the RHS, "a : [a]" is an infix data constructor? If so, how could there be an infix operator there anyway? Where's the ambiguity?
04:27:47 <nand`> odd; I get hGetBufSome: failed (Bad address) from Data.ByteString.hGetSome
04:29:14 <donri> flamingspinach: what do you mean ambiguity? it's saying it's legal
04:29:17 <shachaf> flamingspinach: It's not *actually* legal syntax, I think, but if it was legal syntax it would be written like that.
04:29:24 <eviltwin_b> flamingspinach, (:) itself is a data constructor.  the ambiguity is that normally constructor vs variable is determined by case, but infix things have to be symbols and symbols dont have case
04:29:37 <liyang> ment: just read it as a strict ByteString.
04:29:54 <mauke> shachaf: the [] isn't legal syntax
04:29:55 <mauke> : is
04:30:01 <flamingspinach> donri: I meant the ambiguity that is resolved by requiring infix data constructors to start with ":"
04:30:11 <flamingspinach> and I think eviltwin_b answered my question
04:30:37 <shachaf> mauke: If you import Prelude hiding the default list constructor, can you define your own (:)?
04:30:38 <flamingspinach> however, why do they say "distinguished from infix operators (for pattern-matching purposes)"? How would an operator be on the RHS of a data declaration?
04:30:47 <mauke> good question
04:30:58 <mauke> flamingspinach: a data declaration isn't a pattern
04:31:01 <eviltwin_b> it can't, but an operator is as good a symbol as any other for pattern matching purposes
04:31:23 <shachaf> Looks like you can't even hide (:)
04:31:41 <flamingspinach> hm, I don't quite get it
04:32:11 <flamingspinach> what kind of pattern matching can you see in the RHS of a data declaration, anyway?
04:32:17 <mauke> flamingspinach: none
04:32:24 <flamingspinach> or maybe it means pattern matching when trying to decide the type of an expression?
04:32:34 <mauke> flamingspinach: no, it means pattern matching as in pattern matching
04:32:34 <flamingspinach> (and checking whether it fits the datatype being defined)
04:33:05 <shachaf> mauke: (:) is reserved so it's not actual valid syntax.
04:33:13 <mauke> I see
04:33:26 <flamingspinach> mauke: sorry, I'm quite a newbie :) I'm not sure what "pattern matching" means here, can you explain further?
04:33:26 <eviltwin_b> flamingspinach, pattern matches have specific contexts.  the point is, whether something is a constructor or not (that is, whether it's defined in a data declaration) determines its behavior in a pattern match.
04:33:33 <shachaf> s/\(:\)/:/
04:33:44 <mauke> flamingspinach: do you know case..of?
04:33:47 <eviltwin_b> pattern matching is used in "case" and in function definitions
04:34:19 <eviltwin_b> (and a few other places; ultimately it's always desugared to a case expression though)
04:34:25 <flamingspinach> mauke: I've just started the gentle introduction and am in chapter 2 - I've seen some brief examples of haskell syntax and noted pattern matching going on in function definitions though
04:35:17 <flamingspinach> hmm, well, I'll think about it some more. Maybe I'll get it when I learn more later on. Thanks for your help!
04:35:37 <mauke> flamingspinach: what is the difference between the patterns 'True' and 'true'?
04:35:40 <niteria> can I rename a function I export from a module?
04:35:55 <shachaf> Only by defining it explicitly.
04:36:18 <ment> liyang: it decreased the time from >10 minutes to 16 seconds, thanks
04:36:20 <roha> flamingspinach, maybe check out this section of RWH: http://book.realworldhaskell.org/read/defining-types-streamlining-functions.html#deftypes.pattern
04:36:36 <ment> liyang: but i still have no idea why is that
04:36:52 <flamingspinach> mauke: I don't know, what is the difference?
04:36:56 <flamingspinach> roha: thanks
04:37:28 <niteria> I have a module called Parser, I want to export function named parse, but I use Parsec, so I already have that function, I could import Parsec qualified, but I would have to change code everywhere
04:37:46 <eviltwin_b> ok, you need to read on to find out what this is about, then.
04:37:53 <flamingspinach> I guess so. Thanks :)
04:38:04 <liyang> ment: also, don't use Data.Array. It's horribly slow. Try vector if you must, or just work on the ByteString (it's essentially a pointer to a block of Word8s).
04:43:23 <ment> liyang: and just seek around with 'drop'?
04:43:56 <ment> oh, there's index function
04:43:58 <ment> nevermind hten
04:45:50 <liyang> A ByteString is a ForeignPtr Word8 along with an offset and a length. Operations like drop and index are O(1).
04:45:51 <niteria> ok, solved the problem with 2 import statements
04:49:47 <Franciman> hi all
04:50:18 <Franciman> people, how are mutable arrays implemented in haskell?
04:50:49 <Franciman> I mean, how do you "break rules" and mutate values?
04:50:51 <Botje> carefully.
04:51:14 <liyang> Mutable arrays are implemented by mutating them.
04:52:00 <c_wraith> Franciman: you can do it because reading a value from a mutable array is an IO action, not a pure computation.
04:52:38 <Franciman> ah
04:52:40 <Franciman> ok
04:53:18 <c_wraith> (well, IO or ST... but you can look at ST as a special case of IO)
04:53:26 <Franciman> yes
04:55:09 <Franciman> and IO actions, at the lowest level are system calls right?
04:55:22 <c_wraith> not necessarily
04:55:43 <c_wraith> things like reading a mutable array are just direct memory access
04:55:56 <Franciman> and you can do that directly in haskell
04:56:07 <Franciman> or need some FFI function?
04:56:12 <c_wraith> neither, actually
04:56:17 <niteria> is it common to have another module for data declaration?
04:56:35 <c_wraith> There are a bunch of primitives that are implemented in C or Cmm, and linked directly as part of the GHC runtime.
04:57:03 <niteria> I have 2 modules that share a common data structure (ast tree) and it belongs to neither
04:57:16 <Franciman> niteria, I think so
04:57:17 <c_wraith> niteria: yes, modules to just contain types are relatively common
04:57:33 <Franciman> c_wraith, so it's relatively some compiler magic?
04:58:23 <c_wraith> well. You can treat them as such.
04:58:56 <Franciman> for example if I wanted, theoretically, to write in haskell a new IO action that isn't implemented in that primitives
04:58:57 <c_wraith> So long as you know that magic is relative.
04:59:00 <Franciman> i cannot, right?
04:59:08 <Franciman> of course
04:59:17 <c_wraith> New primitives require a custom build of GHC, yes
04:59:39 <mm_freak> Franciman: you can consider FFI actions primitives
04:59:45 <c_wraith> building custom GHC versions isn't that uncommon for people playing with cutting edge stuff
04:59:54 <mm_freak> they are your interface to C, assembler or whatever you wish
05:00:00 <Franciman> yeah the alternative is FFI
05:00:09 <Franciman> well thanks for the clarification
05:08:35 <roconnor> It seems like in practice every dioid will be a kleene algebra. ... I can't really think of any dioid that isn't.
05:25:01 <fmap> is λx.xx in untyped λ-calculus roughly (\f -> f f) or (\f -> f . f) in haskell?
05:25:30 <liyang> The former.
05:25:56 <fmap> liyang: i see, thanks
05:36:34 <Peaker> fmap, it's expressible in Haskell if you use infinite type representations (via data or newtype)
05:41:17 <NewsReleases> Photo, pixel count, shape, number, landscape, data, photo, pixel change, handwriting, not formal, imagine, no numeric, how to turn these to functions.
05:42:46 <Botje> NewsReleases: THIS. STATEMENT. IS. FALSE. discuss.
05:45:04 <NewsReleases> False.01.01
05:45:49 --- mode: ChanServ set +o mauke
05:45:50 --- mode: mauke set +q *!*@58.253.218.82
05:45:54 <Botje> did I crash it?
05:46:00 <mauke> msg me if this is not some bizarre kind of spam
05:47:49 --- mode: mauke set -o mauke
05:51:29 <mm_freak> i noticed that the base library internally does IO by actually taking a world value around…  by the data dependencies a certain order of execution is guaranteed
05:51:53 <mm_freak> suppose a language had linear types you could actually expose this interface without problems, right?
05:53:18 <hpc> mm_freak: i think so
05:53:47 <mm_freak> would a uniqueness type for the world value suffice?  uniqueness types don't force you to apply
05:54:14 <mm_freak> that's what Clean does, and i think it's sound as long as main : World -> World
05:55:03 <hpc> looks like that works too
05:55:08 * hpc is just running off wikipedia though
05:55:14 <mysticc> what is NewsReleases
05:55:15 <mysticc> ?
05:55:18 <mm_freak> wikipedia didn't really help
05:55:57 <mm_freak> mysticc: NewsReleases is just ranking us up in search engines for less related terms
05:56:17 <mysticc> mm_freak: How ?
05:56:25 <mm_freak> see above
05:57:03 <mysticc> ohk
05:58:08 <mm_freak> t7: currently i have Set : Set, because a universe hierarchy really complicates the type-checking code =/
05:58:36 <t7> u wanna see mine?
05:58:42 <mm_freak> yeah, why not
05:58:49 <t7> its messy and probably broken somewhere
05:59:07 <mm_freak> i have checked my code extensively…  it seems to work even in edge cases
05:59:18 <mm_freak> but with a universe hierarchy it always failed in some
06:00:22 <mm_freak> t7: does yours infer Set 2 for Set -> Nat -> Set 1 -> Nat?
06:00:35 <t7> let me check
06:02:32 <t7> yeah set 2
06:02:41 <mm_freak> interesting…  mind showing me the code?
06:02:51 <mm_freak> i did it using a highestLevel function
06:03:35 <niteria> @hoogle Maybe a -> b -> Either b a
06:03:35 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
06:03:35 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
06:03:35 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
06:03:38 <hpaste_> t7 pasted “code” at http://hpaste.org/67836
06:04:21 <niteria> I would've expected there's a function like that already
06:05:02 <dixie> @hoogle b -> Maybe a -> Either b a
06:05:03 <lambdabot> Text.Parsec.Prim runP :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
06:05:03 <lambdabot> Text.Parsec.Prim runParser :: Stream s Identity t => Parsec s u a -> u -> SourceName -> s -> Either ParseError a
06:05:03 <lambdabot> Text.ParserCombinators.Parsec.Prim runParser :: GenParser tok st a -> st -> SourceName -> [tok] -> Either ParseError a
06:05:49 <nand`> :t \b -> maybe (Left b) Right
06:05:50 <lambdabot> forall a b. a -> Maybe b -> Either a b
06:06:02 <mm_freak> t7: thanks
06:06:29 <yitz> @type flip maybe Right . const . Left
06:06:31 <lambdabot>     Couldn't match expected type `Either a1 a'
06:06:31 <lambdabot>            against inferred type `b -> a2'
06:06:31 <lambdabot>     In the first argument of `(.)', namely `const'
06:07:05 <yitz> @pl \b -> maybe (Left b) Right
06:07:06 <lambdabot> flip maybe Right . Left
06:07:28 <mm_freak> t7: how extensively did you check your code?
06:07:42 <t7> not very
06:07:49 <mm_freak> t7: and where is your lambda?
06:07:54 <t7> Abs
06:07:54 <mm_freak> do you have only pi?
06:07:56 <mm_freak> ah
06:08:12 <mm_freak> t7: it probably fails for many cases
06:08:18 <mm_freak> like:  \(x : 3) -> x
06:08:23 <nand`> @pl \a b -> maybe (Left b) Right a
06:08:23 <lambdabot> flip (flip maybe Right . Left)
06:09:15 <mm_freak> t7: my type-checking code used to be similarly simple, but now it's a 127 LOC module
06:09:37 <mm_freak> and it doesn't even include a universe hierarchy yet
06:09:46 <mm_freak> but i'll try again now
06:09:52 <t7> how do you construct a value of type 3?
06:09:58 <niteria> turns out i can Just use maybe
06:10:05 <mm_freak> t7: it's a type error, because 3 is not a type
06:10:13 <mm_freak> your type checker would accept it, though
06:10:34 <t7> yeah but its like
06:13:33 <Philippa> 127 LoC can be pretty simple still - I find that's big enough that I start to really care about how high-level I've made my code though
06:14:33 <mm_freak> Philippa: dependently typed?
06:18:03 <Philippa> mm_freak: I haven't tackled that in particular, was more a general code comment though
06:18:23 <Philippa> (I know dependently-typed languages grow complexity pretty fast compared to most other languages)
06:18:31 <t7> mm_freak: paste your type check module
06:19:38 <t7> please :
06:20:27 <mm_freak> Philippa: ah, i see
06:20:43 <mm_freak> t7: sure, gimme a second to assemble
06:21:06 <mm_freak> note that i'm currently using named arguments
06:21:30 <t7> yeah i might switch again
06:21:33 <t7> lol
06:21:52 <hpaste_> niteria pasted “; ?” at http://hpaste.org/67837
06:22:02 <niteria> i don't understand
06:22:10 <niteria> I have no ; in my code
06:22:13 <mauke> niteria: you're in a do block
06:22:14 <mm_freak> t7: i think de bruijn indices are actually easier
06:22:31 <mauke> niteria: and you're using layout
06:22:32 <t7> yeah but when i need to debug bigger expressions its gonna get silly
06:22:35 <mm_freak> t7: i was concerned about error messages, but i found that it's not that bad
06:22:50 <mauke> niteria: that makes the parser insert { ; } automatically based on the indentation of your code
06:23:03 <mauke> tl;dr: indent the 'else' more
06:23:14 <niteria> oh, I see
06:23:51 <niteria> ugh, that's ugly
06:24:41 <hpaste_> “Ertugrul Söylemez” pasted “Type-checking code” at http://hpaste.org/67838
06:24:47 <mm_freak> t7: see paste
06:25:30 <mm_freak> t7: TC uses TcError IncompleteTypeCheck as 'empty'
06:25:41 <mm_freak> and ensures that empty <|> x = x <|> empty = x
06:25:57 <mm_freak> other type errors are left-biased
06:26:27 <mm_freak> the comments indicate that i had a universe hierarchy before, but removed it for now
06:28:27 <mm_freak> also IntT is not natural numbers, but integers…  it used to be natural numbers, hence the comment =)
06:29:00 <adamch> In compiling someone else's code that works with JSON, I'm getting an error message about lack of match between types `H.HashMap Text d0' and `Data.Map.Map Text Value'.  Does anyone know offhand what I'm likely doing wrong?  Probably wrong library version.
06:29:34 <mm_freak> adamch: well, a HashMap (hash table) is not a Map (tree-based map)
06:29:50 <mm_freak> that might not answer your question, but that's the cause of the type error
06:29:56 <adamch> mm_freak, certainly makes sense.  The question is which old version of which library did something differently. :)
06:30:12 <mm_freak> that's a good question =)
06:30:26 <mm_freak> but when you spotted it you can just constrain version numbers in the cabal file
06:30:50 <mm_freak> btw, are you actually using cabal to compile?
06:30:51 <adamch> I'm not very well-informed about Haskell.  I'm just trying to build a Haskell program which is needed to reproduce a bug in another program.
06:31:02 <mm_freak> or are you calling the compiler yourself?
06:31:05 <adamch> I installed libghc-*-dev packages in Debian, based on Google searches from error messages.
06:31:44 <adamch> Calling compiler like: ghc --make -c
06:31:53 <mm_freak> ah, you shouldn't do that
06:32:05 <adamch> This comes from the build script of the code I'm trying to debug.
06:32:10 <mm_freak> virtually all haskell packages use and rely on cabal for compilation and installation
06:32:15 <mm_freak> is there a .cabal file?
06:32:40 <adamch> No.
06:32:55 <adamch> It's not a real "package" yet.  It's a student project.
06:33:58 <mm_freak> well, then i'm sorry to tell you that you will have to figure out the right versions of the copackages manually…  trial and error might work, but it might take you a long time
06:34:14 <mm_freak> another thing to note is that in debian haskell packages are often terribly outdated
06:34:36 <mm_freak> most debian users would want to install the haskell platform by themselves
06:35:47 <adamch> OK. :(
06:38:36 <mm_freak> adamch: i would ask the developer which versions of which packages he has installed
06:45:49 --- mode: ChanServ set +o mauke
06:45:50 --- mode: mauke set -q *!*@58.253.218.82
06:47:49 --- mode: mauke set -o mauke
06:52:10 <mm_freak> isn't there something like blaze-builder, but for Text instead of ByteString?
06:56:18 <parcs`> mm_freak: http://hackage.haskell.org/packages/archive/text/0.11.2.0/doc/html/Data-Text-Lazy-Builder.html ?
06:56:56 <mm_freak> uh
06:57:04 <mm_freak> the Text package contains that itself…  interesting
06:57:26 <mm_freak> great…  thanks, parcs` =)
06:57:42 <mm_freak> parcs`: do you have experience with its performance?
07:01:09 <parcs`> mm_freak: nope
07:01:21 <parcs`> should be fast though, bos made it ;)
07:04:22 <mm_freak> alright =)
07:04:52 <mm_freak> sometimes it's a bit weird that [] is a type constructor, but not a value constructor
07:05:15 <mm_freak> well, it is, but i'm sometimes tempted to write [] x to mean [x]
07:06:42 <Tomsik> > (:[]) 5
07:06:43 <lambdabot>   [5]
07:06:48 <Tomsik> This works
07:06:53 <Tomsik> The monkey operator
07:08:55 <mm_freak> Tomsik: i prefer 'return' there
07:09:04 <mm_freak> or 'pure', if Control.Applicative happens to be in scope anyway
07:09:17 <Tomsik> You have something against the monkeys?
07:10:21 <bobry> Can somebody point me to a good explanation of 'GHC.Generics'? I've seen the paper, but I'm looking for additional examples.
07:20:08 <mm_freak> t7: before i add universes back, i'm once again switching to de bruijn indices…  the simplicity of your code in some places convinced me to take another look =)
07:21:05 <hpaste_> liyang annotated “stack overflow” with “I was procrastinating and made it faster” at http://hpaste.org/67826#a67841
07:21:53 <liyang> ment: try that if you're still working on it. Compile with -threaded and run with +RTS -N .
07:25:09 <kallisti> liyang: what happens when you don't compile with -threaded and use threads.
07:31:13 * hackagebot Dflow 0.0.1 - Processing Real-time event streams  http://hackage.haskell.org/package/Dflow-0.0.1 (PaulJohnson)
07:31:32 <hpaste_> niteria pasted “parsec” at http://hpaste.org/67842
07:31:43 <niteria> how to make this better?
07:33:50 <niteria> maybe i can use intersperse
07:34:28 <niteria> with some kind of fold
07:35:53 <niteria> or sequence
07:37:13 <gintas> I am interested in setting up a secure Haskell build sandbox that is just powerful enough to compile a single (untrusted) module and run QuickCheck tests.  I have found mueval (http://hackage.haskell.org/package/mueval-0.8.2) which deals with resource limits etc., and performs some validation of expressions to be evaluated, but its README expressly says that input files are not checked for evil things, only the expression is. Wh
07:37:13 <gintas> "evil things" in the source input file should I be concerned about, assuming that I limit imports to standard control structures and QuickCheck? Is this a difficult problem?
07:39:10 <Tomsik> If template haskell is not disabled then it's an issue
07:40:21 <gintas> I can do without Template Haskell.
07:42:38 <aristid> mm_freak: but keeping general recursion?
07:45:51 <mm_freak> aristid: yes…  until i find a way to add guarded corecursion without making it a headache to write practical I/O code
07:46:57 <mm_freak> or i could add something like a MustTerminate type for people wanting to write proofs
07:47:59 <Tomsik> Termination is not "termination in reasonable time"
07:48:16 <aristid> Tomsik: who said that?
07:49:25 <Tomsik> Nobody, but for practical use "nontermination" is same as "termination in a very very long time"
07:51:54 <mm_freak> another way is to have "data" and "codata", but i guess there is a good reason why the agda people replaced that distinction by guarded corecursion
07:55:18 <niteria> @hoogle if'
07:55:18 <lambdabot> No results found
07:55:21 <niteria> where is it?
07:55:41 <niteria> @pl (\c t f -> if c then t else f)
07:55:41 <lambdabot> if'
08:03:17 <fmap> niteria: i guess it's lambdabot-specific
08:07:17 <fmap> niteria: there is utility-ht package where it's defined though
08:08:11 <mysticc> niteria: define it yourself :)
08:10:02 <romildo> Hi.
08:11:36 <applicative> > let if'' p a b = if p then a else b in if'' (1 == 1) 2 (error "but 1 is 1 !")
08:11:38 <lambdabot>   2
08:11:58 <applicative> hi romildo
08:12:10 <hpaste_> romildo pasted “Expressions” at http://hpaste.org/67843
08:12:46 <romildo> How would be defined a Foldable instance for the type ExprF? http://hpaste.org/67843
08:15:48 <hpaste_> romildo annotated “Expressions” with “Expressions (annotation)” at http://hpaste.org/67843#a67844
08:16:27 <bitonic> romildo: mempty in place of the ???
08:16:39 <bitonic> I'm not sure how much it makes sense, but you can't use those numbers productively
08:16:46 <bitonic> are you following "data types a la carte"?
08:19:18 <romildo> bitonic, I am following "Generic Selections of Subexpressions" (by Martijn van Steenbergen)
08:19:45 <bitonic> romildo: ok
08:21:45 <romildo> http://martijn.van.steenbergen.nl/projects/Selections.pdf
08:22:51 <bitonic> romildo: I was just curious :)
08:26:34 <romildo> In his master thesis, Martijn uses a class (Traversable t) without any constraints on t, while the Traversable class from the library has the constraints (Functor t, Foldable t). So I need to write a Fodlable instance for my ExprF type.
08:27:52 <bitonic> romildo: the obvious way is with `mempty' in place of `Var' and the number thing.
08:30:40 <romildo> bitonic, then the first argument of foldMap (the function to be mapped) is never used. That does not look right.
08:30:52 <bitonic> of course it is, on the `r'
08:31:17 <bitonic> it's simply Bin _ l r -> f l `mappend' f r, no?
08:31:25 <bitonic> I'm not sure it's like that in your paste
08:31:52 <bitonic> romildo: I checked now, what you pasted wouldn't typecheck
08:32:03 <bitonic> (btw, you can derive Foldable automatically with an extension)
08:35:37 <romildo> bitonic, I have posted just a fragment of the code. That was m issing the Id type definition: type Id = String
08:36:59 <mm_freak> ok, once again i'm back to de bruijn indices =)
08:37:19 <bitonic> romildo: no I mean, your stub for the Foldable instance. you write `foldMap f (Bin op l r) = mappend (foldMap f l) (foldMap f r)', but that's wrong, since `l' and `r' are not ExprFs
08:37:34 <bitonic> it should be `f l `mappend` f r'
08:37:39 <bitonic> mm_freak: ah! so they are better ehe
08:39:06 <mm_freak> bitonic: well, i'm going to improve error messages by adding a source code position tag to every AST node
08:39:43 <bitonic> mm_freak: that's a solution I guess
08:40:18 <mm_freak> although i was quite proud of my alpha equivalence algorithm that performed almost as good as syntactic comparison =)
08:41:57 <romildo> Is it possible to see the code for the automatically derived instances by ghc?
08:42:29 <bitonic> romildo: yes, -ddump-deriv
08:42:57 <Philippa> mm_freak: how'd you go about it?
08:43:24 <mm_freak> Philippa: http://hpaste.org/67762
08:44:05 <Philippa> at a glance, the obvious way using de Bruijn indices as a normal form?
08:44:18 <mm_freak> it basically introduces de bruijn indices on the fly
08:45:10 <Philippa> yeah. The performance gap'll grow as you have more bound variables to deal with, but that's probably obvious, right?
08:45:25 <bitonic> romildo: GHC is going to derive what I told you, it can't do anything else
08:46:58 <gienah> maybe trying: emerge -av dev-haskell/resourcet dev-haskell/conduit # might give some hints
08:47:09 <gienah> sorry wrong channel
08:47:27 <mm_freak> Philippa: it grows only logarithmically
08:47:47 <mm_freak> while space usage of course grows like n * log n
08:47:53 <Philippa> *nod*
08:48:47 <Philippa> (I just used a fresh variable counter, which doesn't matter much so long as you propagate it in Reader-like fashion rather than State-like)
08:50:29 <romildo> bitonic, yes, ghc generates an equivalent definition for foldr.
08:50:45 <Philippa> (different ways to conceptualise - great fun!)
08:52:24 <bitonic> romildo: told ya! :)
08:52:33 <bitonic> pretty useless instance, but whatever
08:52:44 <romildo> I was thinking in terms of a tree with Num and Var leaves, and Bin nodes, and thought the functional should act on the leaves, like in a (Tree a).
08:53:04 <bitonic> romildo: with these two-level recursive types thing can get confusing yes
08:53:37 <bitonic> because you can't convince your brain that you don't know what's in the branches :P
08:53:41 <romildo> But ExprF is paremetrized on the type of the brances of the tree, not on the leaves.
08:54:11 <bitonic> romildo: yes, but that doesn't matter in that instance.
08:55:17 <adnauseam> is there a way to define functions with lambdabot ?
08:56:02 <bitonic> @let foo = "bar"
08:56:03 <lambdabot>  Defined.
08:56:07 <bitonic> > foo
08:56:09 <lambdabot>   "bar"
08:56:14 <bitonic> adnauseam: ^^^
08:56:16 * hackagebot zmidi-core 0.2.1 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.2.1 (StephenTetley)
08:56:19 <romildo> bitonic, and those abstractions (Foldable, Monoid, Traversable, Fix) are new to me and I am learning them in order to understand the thesis, and maybe use the ideas to annotate ast on a compiler I am writing.
08:56:40 <bitonic> romildo: they're nice abstraction, you'll get used to them quickly
08:57:33 <adnauseam> bitonic:  thanks man
08:57:40 <mm_freak> t7: i have quite a nice pretty printer for expressions now…  would you like to see it?
08:57:53 <mm_freak> with de bruijn indices
08:57:57 <bitonic> adnauseam: no problema
08:58:00 <t7> yeah
09:01:04 <hpaste_> “Ertugrul Söylemez” pasted “Pretty printer for CoC expressions with de Bruijn indices” at http://hpaste.org/67845
09:01:06 <mm_freak> t7: see paste
09:03:21 <romildo> bitonic, As I said, the author of the thesis defines the (Traversable t) class without any constraints. Why the base library added those two constraints: (Functor t) and (Foldable t)?
09:03:24 <adnauseam> bitonic: how do i "unset" the function ?
09:03:57 <bitonic> @let foo = "quux"
09:03:57 <lambdabot>  <local>:9:0:
09:03:57 <lambdabot>      Multiple declarations of `L.foo'
09:03:57 <lambdabot>      Declared at: <local>...
09:04:03 <bitonic> adnauseam: you know, I'm not sure :P
09:04:06 <adnauseam> yeah can't let twice :p
09:04:11 <adnauseam> hah :P i'll try and google it man
09:04:23 <bitonic> adnauseam: maybe it just expires
09:05:11 <adnauseam> bit the question is then after how long
09:05:18 <bitonic> romildo: because they make sense for Traversable
09:06:58 <wli> Did I accomplish anything by bounding the lists in http://hpaste.org/67812 ?
09:09:50 <romildo> bitonic, but that not seem to be a requirement. For instance, the idea of Foldable is to be able to reduce the structure to a summary value, and Traversable is to be able to traverse the structure from left to right, performing an action on each element. Apparently reducing to a summary value is not needed for traversing.
09:11:39 <bitonic> romildo: well that might be true for Foldable, but not for functor
09:11:49 <bitonic> you can define `fmap' in terms of the Traversable methods
09:13:50 <bitonic> romildo: and actually, you can define the Foldable methods in terms of Traversable
09:14:02 <copumpkin> really?
09:14:04 <bitonic> it's just converting to a list and calling the list `foldr'
09:14:06 <bitonic> no?
09:14:09 <copumpkin> oh
09:14:11 <copumpkin> no
09:14:16 <bitonic> why not?
09:14:27 <copumpkin> foldable is the class for converting to a list
09:14:31 <copumpkin> :t traverse
09:14:32 <lambdabot> Not in scope: `traverse'
09:14:39 <copumpkin> :t Data.Traversable.traverse
09:14:40 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
09:14:58 <copumpkin> how would you use that to convert to a list?
09:15:23 <bitonic> :t Data.Traversable.mapM
09:15:24 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
09:15:29 <copumpkin> still won't do it
09:15:32 <bitonic> mhm
09:17:07 <bitonic> can't you put the elements you encounter in a state or something?
09:17:27 <bitonic> or anyway accumulate them with the help of the `m'
09:19:44 <romildo> The default definition of the method traverse uses fmap, and that may be an explanation for making Functor a superclass of Traversable:
09:19:47 <romildo> traverse f = sequenceA . fmap f
09:20:40 <romildo> But none of the default definitions for the methods of Traversable requires Foldable.
09:21:21 <bitonic> copumpkin: yes, you can
09:21:25 <romildo> So I still does not understand why Foldable needs to be a superclass of Traversable.
09:21:42 <bitonic> copumpkin: \t -> reverse $ execState (mapM (\x -> modify (x :)) t) []
09:22:11 <bitonic> romildo: it makes sense because you don't want to explicitly add a constraint for Functor or Foldable when using Traversable
09:22:17 <bitonic> and we don't have to define things twice
09:22:32 <bitonic> the fact that Monad doesn't have a constraint for Applicative is incredibly anoying
09:23:20 <bitonic> in general if the methods of one class are a more powerful/generalised version of another, the other sould be a constraint
09:23:54 <sipa> bitonic: the reason is that Applicative is more recent :)
09:25:36 <bitonic> sipa: yeah, that's an historical reason
09:26:59 <romildo> bitonic, But it make thinks harder. If Foldable was not a requirement for Traversable, I would not have to write the instance (Foldable ExprF), which seems to be useless for the program.
09:27:49 <bitonic> romildo: you can define them recursively
09:28:00 <bitonic> romildo: define Traversable and then Foldable in terms of Traversable
09:28:03 <bitonic> Haskell won't complain
09:28:11 <bitonic> so there's no excuse :)
09:28:45 <copumpkin> bitonic: that's kind of cheating :P
09:28:52 <bitonic> copumpkin: how is it cheating?
09:29:14 <bitonic> the Traversable methods must traverse from left to right
09:29:31 <copumpkin> well, you make it strict, first of all
09:29:36 <copumpkin> although you can probably avoid that too
09:30:03 <bitonic> copumpkin: it was just to make my point :P
09:30:06 <copumpkin> but the real point is that not everything that supports Foldable necessarily supports Traversable
09:30:22 <bitonic> copumpkin: but I was saying the opposite
09:30:55 <bitonic> (I was justifying the Foldable constraint on Traversable)
09:31:09 <copumpkin> oh, okay
09:31:17 * hackagebot zmidi-core 0.3.0 - Read and write MIDI files.  http://hackage.haskell.org/package/zmidi-core-0.3.0 (StephenTetley)
09:31:48 <copumpkin> yeah, that's what foldMapDefault does, sort of
09:32:34 <Peaker> I don't understand the Foldable class.. it seems to make instances equivalent to lists.. Or could be expressed: class Foldable f where f a -> [a]    without losing anything?
09:33:05 <copumpkin> nah, I think Foldable should be called Listable :P
09:33:20 <Peaker> and have just the "f a -> [a]" method?
09:33:36 <Peaker> I guess the reason for the folding methods is to avoid the intermediate list representation? But is otherwise equivalent?
09:33:42 <bitonic> Peaker: yeah
09:33:56 <romildo> I think that by now I will stick with the definition of Traversable provided in the thesis, instead of using the one from the base library, and continue reading. Meanwhile those new structures will mature in my mind.
09:34:26 <bitonic> romildo: again, you can define Foldable and Functor instances *after* you defined the Traversable one
09:34:31 <bitonic> so you don't lose anything
09:35:08 <bitonic> (unless there's some fundamental difference in the Traversable definition)
09:54:12 <niteria> > Prelude.null [1]
09:54:13 <lambdabot>   False
09:54:13 <niteria> *** Exception: getCurrentDirectory: does not exist (No such file or directory)
09:54:20 <notthemessiah> any Paraiso (parallel PDE solving DSL) users out there?
09:54:20 <niteria> wtf?
09:54:42 <Enigmagic> did you delete the directory that you're in?
09:55:11 <niteria> yeah :D
09:55:14 <niteria> I see
10:24:31 <roha> somebody knows a simple library to send mail from within a haskell program without needing a local mailserver?
10:25:01 <hpc> @hoogle smtp
10:25:02 <lambdabot> package SMTPClient
10:25:02 <lambdabot> package hsmtpclient
10:25:02 <lambdabot> package ismtp
10:25:10 <hpc> any of those work?
10:26:03 <tazjin> hpaste_: I've used the SMTP library from HaskellNet before and it worked
10:26:09 <tazjin> @hoogle HaskellNet
10:26:10 <lambdabot> package HaskellNet
10:26:20 <roha> i think haskellnet fails to build on ghc7
10:26:39 <tazjin> Yeah, I pulled it form the repo and applied a patch, I think
10:27:04 <roha> do you happen to know where this patch can be found?
10:28:03 <tazjin> I'm trying to find it
10:28:33 <tazjin> roha: It's been merged into the repo: https://github.com/jtdaugherty/HaskellNet
10:28:56 <roha> tazjin, thanks!
10:29:20 <tazjin> and I just noticed I pinged the wrong guy, hope hpc saw it anyways :P
10:32:37 <altious> hi. could please someone give me some clues about STM. maybe you can recoment some online intro/tutorial
10:32:57 <bitonic> @google beautiful concurrency
10:33:00 <lambdabot> http://research.microsoft.com/pubs/74063/beautiful.pdf
10:33:00 <lambdabot> Title: Beautiful concurrency
10:33:01 <altious> i'm especially want to know how stm helps to achive high concurrency in practice
10:33:11 <bitonic> altious: ^^^
10:33:17 <altious> do stm work like transactions in dbms?
10:33:23 <bitonic> altious: no
10:33:30 <altious> or stmimply have such name
10:33:31 <bitonic> altious: well, it depends what you mean
10:33:44 <bitonic> they do in the sense that the are atomic
10:33:57 <altious> bitonic,  well, on every data conflict we need to restart one thread
10:33:59 <bitonic> but in practice they're often implemented differently
10:34:12 <altious> one unit of work
10:34:16 <bitonic> altious: I don't follow
10:34:36 <altious> thanks, i'll take a look
10:35:06 <bitonic> altious: np. that tutorial is not about performance, but it's a great intro to STM in haskell
10:36:04 <altious> hm, i dont quite know haskell
10:36:09 <altious> of want to learn it :(
10:37:09 <otters> you probably won't then
10:37:40 <bitonic> altious: you meant "or want to learn it"?
10:37:53 <altious> sorry, yes
10:38:01 <bitonic> Haskell is the language with the sanest STM right now, so it'll probably be useful to learn some Haskell
10:38:15 <bitonic> and I think that learning Haskell will teach you a lot of other things
10:38:25 <altious> i'm aware of many haskell idiosyncrasies
10:38:36 <altious> :)
10:38:39 <bitonic> altious: like what?
10:39:02 <bitonic> lazyness, purity! ehe
10:39:23 <altious> yes
10:39:36 <altious> and IO creep :)
10:39:54 <bitonic> altious: that shouldn't put you off. they make haskell very intersting
10:40:33 <brutax> Mm, at first it feels like writing a text without using the letter e or something, but it grows on you :P
10:40:48 <parcs`> do RULEs get fired for newtype wrappers?
10:41:00 <bitonic> parcs`: what do you mean?
10:41:04 <bitonic> ah.
10:41:24 <bitonic> parcs`: don't RULEs work at the function-level only?
10:42:30 <parcs`> i'd like to know if "realToFrac/Double->Float"  realToFrac   = double2Float
10:42:50 <altious> https://gist.github.com/2552181
10:42:54 <altious> oh suck a start
10:42:57 <parcs`> gets fired if i have a 'newtype F = F Double deriving (Real)'
10:42:57 <altious> *such
10:43:47 <altious> as far as i'm concerned transactions don't solve deadlock problems or help lock placement IN ANY WAY
10:44:02 <altious> they don't help priority inversion as well
10:44:28 <copumpkin> o.O
10:44:29 <altious> oh sorry missed document
10:44:33 <altious> this is not for you
10:45:07 * altious reading Software Transactional Memory Should Not Be Obstruction-Free
10:47:22 <parcs`> hmm, in Foreign.C there's '"realToFrac/CDouble->a"   realToFrac = \(CDouble  x) -> realToFrac x' so it seems like RULEs don't automatically get fired for newtype wrappers
10:48:48 <hayashi> @pl \f -> g <$> f a <*> f b <*> f c
10:48:48 <lambdabot> (g <$>) . ap ((<*>) . liftM2 (<*>) ($ a) ($ b)) ($ c)
10:48:52 * hayashi vomits
10:49:23 <parcs`> @hoogle unsafeCoerce
10:49:23 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
10:49:35 <parcs`> ah, right :)
10:58:17 <yitz> hayashi: perhaps you're looking for this:
10:58:23 <yitz> @type liftA3 . liftA3
10:58:24 <lambdabot> forall (f :: * -> *) a b c d (f1 :: * -> *). (Applicative f, Applicative f1) => (a -> b -> c -> d) -> f (f1 a) -> f (f1 b) -> f (f1 c) -> f (f1 d)
10:58:27 <parcs`> wow, rules don't even get fired for inlined function aliases
10:58:53 <hayashi> yitz: Yeah, probably
11:00:26 <parcs`> i have an INLINEd alias 'rtf = realToFrac' and using rtf instead of realToFrac causes the program to consume 20x more cpu doing Double -> Float conversions
11:00:56 <lobius> Twice as many people here as #java.  Interesting.
11:02:34 <lobius> #scheme
11:03:29 <donri> IRC isn't optimized for suites
11:22:18 <ericmj> how do I solve the problem that I can't do killThread on a thread blocking on a socket recv?
11:50:52 <Veinor> is there any way to generate haddock documentation for top-level declarations generated with hsc2hs's #enum ?
12:02:01 <hayashi> @pl \x -> ( f x ) >>= ( g x ) >>= ( h x )
12:02:01 <lambdabot> ap ((>>=) . liftM2 (>>=) f g) h
12:02:42 <strager> Yikes xD
12:03:13 <c_wraith> sometimes, points are good
12:03:23 <bitonic> Veinor: a way around that is to use #const manually, I think
12:03:44 <bitonic> hayashi: also, you don't need all those parens
12:04:21 <mm_freak> ericmj: you can't?
12:04:30 <hayashi> I tend to be consistently over-cautious with parens, and then throw hlint over the source afterwards >_<
12:04:32 <mm_freak> i do that successfully
12:05:00 <bitonic> hayashi: well, with operators vs. function application is easy. function application always wins
12:05:13 <mm_freak> hayashi: i tend to write more parentheses than other haskell programmers
12:05:32 <mm_freak> for example i prefer "print (f x)" over "print $ f x" or "print . f $ x"
12:05:45 <ericmj> mm_freak: it seems like the thread ignores killThread during some foreign calls
12:05:58 <bitonic> mm_freak: I'm pretty sure that most haskell programmers would prefer `print (f x)'
12:06:00 <bitonic> (at least I do)
12:06:05 <mm_freak> ericmj: if you use foreign calls to do your socket stuff, then this is not surprising
12:06:19 * hayashi wonders how to get an if-then-else in a do statement to span more than one line without throwing parse erros everywhere
12:06:33 <mm_freak> bitonic: i don't know…  my impression is that beginning haskell programmers are tempted to get rid of as many parentheses as possible
12:06:36 <ericmj> mm_freak: arent all socket stuff foreign calls in some form?
12:06:37 <hayashi> The solution is probably not to use a do statement
12:06:44 <bitonic> mm_freak: yes, but that's silly
12:06:50 <mm_freak> it is
12:07:04 <bitonic> likewise the obsession with point-free :P
12:07:06 <mm_freak> just as silly as the insistence of getting rid of all points
12:07:13 <mm_freak> yeah
12:07:15 * bitonic and mm_freak think alike
12:07:20 <mm_freak> ericmj: no
12:07:25 <bitonic> at least for this minute eh
12:07:29 <mm_freak> ericmj: socket calls are calls to the run-time system
12:07:42 <bitonic> hayashi: well, or you can indent if-then-else correctly :P
12:07:42 <Taneb> mm_freak, what's your opinion on my quest to make my family tree module to work across all compilers?
12:07:43 <bitonic> or you can use semicolons
12:07:50 <mm_freak> ericmj: ah, one reason might be that you may not have compiled with -threaded
12:07:56 <Taneb> s/module/library/
12:08:07 <mm_freak> for multi-threaded networking applications you really should compile with -threaded, even if you never use multiple threads
12:08:21 <ericmj> oh
12:08:22 <Philippa> mm_freak: I figure you probably shouldn't have parens nested too much within one line, so I use $ a fair amount, but I certainly don't look to eliminate them
12:08:24 <mm_freak> then the RTS uses non-blocking socket operations internally
12:08:35 <ericmj> i will try that
12:08:48 <mm_freak> Taneb: i'm not familiar with it
12:08:51 <Philippa> (I'm enjoying pointless style far more lately, but mostly because it annoys me if I need a name for something that doesn't have a sensible one)
12:08:53 * hayashi embarrassingly doesn't know what the correct indentation for if-then-else inside do notation is >_>
12:09:21 <Philippa> hayashi: I think keeping the then and else further indented than the if works reliably?
12:09:23 <mm_freak> Philippa: depends
12:09:37 <Taneb> bitonic thinks I'm mad
12:09:44 <mm_freak> Philippa: i prefer Lam (App (Var x) (Var y))
12:10:13 <mm_freak> though that seldomly arises, because i'd turn App into an operator =)
12:10:19 <mm_freak> Lam (Var x :$ Var y)
12:10:36 <Philippa> so I like Lam $ Var x `App` Var y
12:11:03 <Philippa> but it gets trickier when you have an identifier :p
12:11:08 <Philippa> well, not much. Lam i $ ...
12:11:12 <mm_freak> Philippa: parens make it apparent where the subexpression starts and ends…  it helps the eye
12:11:16 <Philippa> but gives you more room to fool the unaware
12:11:23 <hpaste_> bitonic pasted “do + if-then-else” at http://hpaste.org/67848
12:11:30 <bitonic> hayashi: ^^^ I do it like that
12:11:38 <Philippa> yeah. I have operator highlighting that works well enough for me, but I know exactly what you mean
12:11:48 <mm_freak> well, my Lam also takes a type…  when using multiple nested lambdas i use $ and multi-line
12:11:51 <hayashi> bitonic: ah, cheers
12:12:06 <mm_freak> Lam Typ $ \\ Lam (Var 0) $ \\ Var 0
12:12:07 <hayashi> stupid emacs indent mode and its very broken idea of what constitutes valid indentation for if-then-else inside do
12:12:11 <mm_freak> this is my identity function
12:12:24 <mm_freak> hayashi: for me it works well
12:12:30 <mm_freak> it indents then/else
12:12:35 <bitonic> hayashi: what you can't do is to put the "else" aligned with the other `do' statements
12:13:13 <bitonic> actually, I think you can even do that with an extension.
12:13:33 <bitonic> ah no, that's fine without anything
12:13:59 <hpaste_> bitonic annotated “do + if-then-else” with “do + if-then-else (annotation)” at http://hpaste.org/67848#a67849
12:14:44 <mm_freak> ericmj: did it work?
12:36:23 * hackagebot tablestorage 0.1.0.2 - Azure Table Storage REST API Wrapper  http://hackage.haskell.org/package/tablestorage-0.1.0.2 (PhilFreeman)
12:48:54 <parcs`> hmm, i'm getting "/usr/bin/ld: --hash-size=31: unknown option" with cabal install 1.14 and the gold linker
12:49:32 <dcoutts> parcs`: is /usr/bin/ld gold or ordinary bfd ld?
12:49:41 <parcs`> dcoutts: gold
12:50:03 <dcoutts> any idea where the --hash-size=31 flag is coming from?
12:51:39 <parcs`> no idea
12:51:47 <parcs`> i'm on ghc 7.4.1 if that matters
12:53:02 <fliiipy> How would I go about doing the following: ["how", "are"] ["hello", "how", "are", "you"] would return true as the first list is contained in the second list?
12:55:20 <bitonic> fliiipy: any + isPrefix + tails
12:55:44 <fliiipy> Sorry, can you explain a bit plase?
12:55:46 <fliiipy> please*
12:56:24 <bitonic> > any . map (isPrefixOf ["how", "are"]) . tails $ ["hello", "how", "are", "you"]
12:56:25 <lambdabot>   Couldn't match expected type `a -> GHC.Bool.Bool'
12:56:26 <lambdabot>         against inferred ...
12:57:15 <bitonic> > or . map (isPrefixOf ["how", "are"]) . tails $ ["hello", "how", "are", "you"]
12:57:17 <lambdabot>   True
12:57:27 <bitonic> fliiipy: so, step by step
12:57:30 <fliiipy> Oh I see!
12:57:34 <bitonic> ok :)
12:57:38 <fliiipy> Thank you.
12:57:43 <bitonic> (I had messed up any and or)
12:57:51 <bitonic> wait was that homework? I always make this mistake
12:57:56 <bitonic> well sometimes
12:57:58 <zuserm> or . map === any
12:58:09 <bitonic> zuserm: right
12:58:45 <parcs`> dcoutts: it's coming from /usr/lib/ghc/settings
12:59:08 <dcoutts> parcs`: hmm, that's a bit odd, is your ghc a distro package?
12:59:15 <parcs`> yeah, debian sid
12:59:27 <dcoutts> parcs`: my guess it's set by the deb then
12:59:42 <parcs`> ah, okay
12:59:44 <dcoutts> I don't recall ghc's configure doing anything clever with the linker like that
13:00:03 <parcs`> yeah i grepped the ghc source tree and found nothing
13:07:17 <parcs`> actually, https://github.com/ghc/ghc/commit/3275b7bd2a803a3adc0b952b6fbfeb738fc15a74
13:08:56 <parcs`> but the next commit https://github.com/ghc/ghc/commit/9ccb59ed6e5edf73c876e87429e69e8848162497 makes it so that it tests whether the flag works before using it
13:10:01 <parcs`> so this ghc was built with a linker that supports the flag, but then using ghc with another linker can break it
13:12:54 <parcs`> is this something that should be fixed in ghc?
13:26:36 <Phil> Hi, I tried to install template-haskell through cabal and got the error "Illegal instance declaration for `Show Doc' ..." in PprLib.hs. Any ideas how to resolve this? Googling found a bug list for this but no resolution
13:27:58 <Tomsik> Have you cabal update-ed?
13:28:18 <aristid> Phil: i think template-haskell comes with ghc, so installing it is not a good idea?
13:28:22 <Tomsik> Did you install Haskell Platform or some other package?
13:28:27 <rjk> Hi. I have a basic problem but need a quick help. I want to print a value inside a function that does not return IO. HOw do I do that?
13:29:46 <Phil> I installed Haskell Platform. But when I can't load XTemplateHaskell
13:29:49 <Tomsik> I remember there was a module with Debug in name
13:29:54 <Tomsik> and there was such an utility there
13:30:03 <Tomsik> but I can't seem to find it exactly
13:30:05 <Phil> *But I can't
13:30:16 <Tomsik> @rjk
13:30:16 <lambdabot> Maybe you meant: ask rc run
13:30:17 <Phil> I've just run cabal update again
13:30:18 <Phil> But not luck
13:30:35 <Phil> *But no luck
13:30:42 <kallisti> Phil: how are you attempting to use it ?
13:30:57 <rjk> Tomsik, I will google that Debug thing.
13:30:58 <Botje> rjk: Debug.Trace is a quick hack.
13:30:59 <BMeph> rjk: Debug.Trace.trace or showTrace
13:31:14 <rjk> Thanks : ).
13:31:15 <Botje> but that's not supposed to be used for anything but debug output
13:31:25 <Botje> (since it outputs to stderr and uses evilperformIO)
13:31:26 <rjk> I just have to print a value.
13:31:43 <Tomsik> and it might just not get called due to lazy evaluation
13:31:54 <Botje> then you either return it or thread your stuff through IO, sorry.
13:31:57 <rjk> And how should I do it "legally"?
13:31:59 <Philippa> beware that if this is a homework Q, whoever's evaluating it probably won't appreciate it unless they forced the type on you
13:32:16 <Philippa> do let v = pureFunction x y z; print v
13:32:24 <Botje> rjk: if you show us your code we can probably make better suggestions
13:32:46 <rjk> Okay. But first I will check these utitilities you gave me.
13:33:35 <Botje> Debug.Trace is really only for debugging output.
13:34:04 <Jacco> Hello, I'm having trouble installing wxHaskell using cabal, "cabal install wx" gives the error: wxcore-0.90 depends on wxc-0.90.0.2 which failed to install.
13:34:06 <Jacco> Any tips?
13:34:58 <Botje> Jacco: did you install some -devel version of the wx library?
13:35:39 <Jacco> what do you mean by -devel?, I've tried to install wxAsteroids first (which failed too), might that be a problem?
13:36:24 <Botje> a -devel version of a library includes the header files necessary to compile code against that library
13:37:04 <Jacco> I don't think I've installed any -devel version of wx
13:37:18 <Botje> what distribution are you on?
13:37:33 <Botje> or which OS, rather.
13:38:23 <Jacco> Windows 7
13:38:51 <Botje> ah. I have no idea about that.
13:39:20 <Botje> http://www.haskell.org/haskellwiki/WxHaskell/Windows
13:39:28 <Botje> this looks like a howto, but it's rather terse
13:39:44 <b52> Is anyone aware of neat excercises to get a deeper understanding of haskell?
13:39:55 <Jacco> thank you Botje
13:40:16 <Philippa> b52: I hear writing a Haskell implementation helps
13:40:27 <Botje> b52: have you tried https://dibblego.wordpress.com/2008/09/18/20-intermediate-haskell-exercises/ yet?
13:41:02 <Philippa> (slightly more seriously: coding up a haskell-like language gives you a lot of things to think about once you start SWeng "golfing" the code)
13:41:13 <mrbennett> GHC is telling me that equations for my function have different number of arguments. They do, as they're written in point free style. Why does GHC have a problem with it?
13:41:15 <Philippa> (but make it 'smaller' than Haskell if you can)
13:41:49 <b52> Botje: not yet, but I will now, thanks
13:42:19 <Tomsik> mrbennett, perhaps they have different number of type arguments
13:42:44 <Tomsik> if you'd be more specific it would be helpful
13:42:55 <mrbennett> Tomsik: but equations don't have type arguments - only functions
13:43:05 <Veinor> does there happen to be anybody on who can reset my hackage password?
13:43:14 <mrbennett> Tomsik: I'll minimise it and put it on pastebin
13:43:22 <Tomsik> mkay
13:43:44 <Veinor> mrbennett: i don't remember why ghc has a problem with it, but you're not allowed to have equations like that
13:43:46 <lispy> hello
13:43:53 <Veinor> so you can't have something like f 2 = 3; f = id
13:44:06 <mrbennett> Veinor: so it's some limitation, not anything wrong with my code?
13:44:09 <Veinor> yeah
13:44:33 <mrbennett> Tomsik: nm
13:44:38 <Tomsik> kay
13:44:48 <b52> Botje: not sure how to check if my answer is right Oo
13:45:47 <Botje> b52: well, it should compile, for once :)
13:45:50 <Botje> *for one
13:46:28 <Botje> b52: usually the implementation that typechecks is the correct one
13:46:47 <b52>  furry f x = map (f) x <- thats my solution for the first one
13:46:48 <mrbennett> Veinor: after looking into it, it's because the compiler performs desguaring to a one equation with pattern matching
13:46:51 <b52> compiles fine
13:47:15 <Botje> b52: that's fine, yes
13:47:19 <Botje> they are all relatively simple
13:48:39 <b52> stuck at the third .D
13:49:56 <PointFree> What does if' mean in Haskell?
13:50:21 <b52> is it furry f x = f . x ?
13:50:32 <b52> not sure about that one though
13:50:42 <PointFree> @pl f x = if x >= 0 then (x, pred, id) else (-x, succ, negate)
13:50:42 <lambdabot> (line 1, column 5):
13:50:42 <lambdabot> unexpected "="
13:50:42 <lambdabot> expecting variable, "(", operator or end of input
13:50:46 <b52> PointFree: looks like a custom function
13:50:51 <lispy> PointFree: it's usually if-then-else defined as a function. if' True t e = t; if' False t e = e
13:50:59 <PointFree> lispy: Oh!
13:51:21 <Botje> b52: work your way through the type :)
13:51:45 <PointFree> @pl if x >= 0 then (x, pred, id) else (-x, succ, negate)
13:51:46 <lambdabot> (line 1, column 36):
13:51:46 <lambdabot> unexpected "-"
13:51:46 <lambdabot> expecting lambda abstraction or expression
13:54:30 <PointFree> Why isn't lift in the Prelude?
13:55:11 <Taneb> Because there aren't any monad transformations in Prelude?
13:55:44 <kallisti> anyone familiar with wxHaskell
13:55:48 <PointFree> That is not an explanation, just a stronger statement.
13:55:50 <kallisti> http://pastebin.com/xxPsXcDT  trying to puzzle out these errors
13:55:52 <mauke> The paste xxPsXcDT has been copied to http://hpaste.org/67851
13:55:58 <kallisti> I'm guessing it's some kind of build/config issue
13:56:49 <zuserm> PointFree: there isn't very much in Prelude
13:56:59 <ipuustin> A quick newbie question: what's the efficient way of finding out if a list is a subset of another list?
13:57:25 <ipuustin> With filter etc. the problem is that I need to go through all variables, instead of just stopping when the first non-match is found
13:57:35 <zuserm> ipuustin: isInfixOf
13:57:39 <PointFree> I am trying to convert all my functions to point-free notation, but in a way that doesn't involve (too much) dot operator madness. I want an easy way to implement "f g x = g (signum x) (abs x)".
13:57:49 <kallisti> zuserm: I don't think he wants it to be concerned with ordering
13:57:50 <PointFree> s/notation/style/
13:57:52 <kallisti> as isInfixOf would be
13:58:03 <ipuustin> kallisti: that's right
13:58:10 <kallisti> PointFree: the functions all and any short-circuit in the way you're expecting
13:58:27 <PointFree> kallisti: Oh, thanks, let me check chose out.
13:58:32 <kallisti> er
13:58:34 <Botje> PointFree: isn't that f g = liftM2 g signum abs ?
13:58:41 <kallisti> I mean ipuustin
13:58:46 <kallisti> not PointFree :P
13:58:46 <kallisti> oops
13:58:51 <PointFree> Oooooooh.
13:59:06 <PointFree> Botje: liftM2 is not in the Prelude. I hate having to import modules just to do basic stuff.
13:59:09 <ipuustin> kallisti: all right, I'll check them out
13:59:35 <kallisti> PointFree: then you can't do what you want.
13:59:40 <Botje> PointFree: ah. there is no prelude-only equivalent i think.
14:00:06 <kallisti> your criterion is somewhat arbitrary though..
14:00:07 <stj> I have an [[Int]] filled with numbers representing brightness -- do you know a simple and straightforward to use way of drawing a PNG image with this data?
14:00:10 <PointFree> Dang, why do I always keep hitting the limitations of the languages I learn?
14:00:23 <zuserm> PointFree: You should just get used to it. There's way to much useful stuff in base that isn't in Prelude.
14:00:25 <c_wraith> stj: juicypixels, maybe?
14:00:26 <Botje> PointFree: it's not a limitation. Control.Monad is in bsae.
14:00:35 <PointFree> Oh, okay.
14:00:36 <kallisti> PointFree: are import statements limitations of Haskell?
14:00:39 <PointFree> No, no.
14:00:49 <PointFree> Not that there's anything wrong with importing stuff.
14:00:51 <Rakin05> hey guys. because haskell compiles to native code, you think it is possible to write device drivers with it?
14:01:13 * PointFree sighs.
14:01:16 <lispy> Rakin05: yes, it's been done
14:01:18 <PointFree> Thanks, people.
14:01:35 <zuserm> Rakin05: Galois was doing stuff like that, I seem to remember.
14:02:14 <stj> c_wraith: looks pretty good, thanks
14:02:19 <PointFree> Oh, the only Galois I knew was the French mathematician who died at 20 or 21, I don't remember well...
14:02:38 <PointFree> But a Google search led me to find Galois Connections, lol.
14:02:44 <lispy> Rakin05: there is halvm which takes the haskell run-time and runs it on the bare metal like an OS but also Tommd was writing kernel modules in Haskell
14:02:55 <Rakin05> lispy: sounds like paradise. why the hell i learned haskell so late :-(
14:03:05 <lispy> PointFree: if you mean the company, the "connections" part was dropped some time ago
14:03:16 <PointFree> Oh.
14:03:25 <PointFree> Rakin05: I have asked myself that very same question.
14:03:49 <lispy> You can also write gcc plugins in haskell
14:03:52 <PointFree> I thought I was a great programmer until I found that it took me none less than 12 years to find Haskell.
14:04:21 <lispy> I've been meaning to blog about the recipe for gcc plugins, it's a bit convoluted.
14:04:37 <Rakin05> PointFree: yesterday i realized that i can implement the solution for project euler problem 1 in Haskell in 1 Line. That makes me almost cry after 6 Years Java
14:04:37 <lispy> In practice I've been writing my gcc plugins in C
14:04:54 <kallisti> you can do problem 2 in one line too. :)
14:05:09 <PointFree> Aw, I used to like C++, but Java is just too bad, even for an unrefined moron like me.
14:05:19 <lispy> project euler is odd that way. I've done some of them using googel's search as a calculator :)
14:05:55 <Rakin05> lispy: i did the same with wolfram alpha :-D
14:06:12 <stilgart> I really wonder which problem can be solved this way... (with google's search)
14:06:38 <Rakin05> another question. which gui framework do you use?
14:07:00 <kallisti> I've been using wxHaskell as of late. I don't really know if I recommend it though.
14:07:05 <kallisti> haven't tried anything else.
14:07:15 <lispy> Rakin05: I don't feel like we have a good answer to that yet
14:07:16 <tazjin> Rakin05: Depends on which OS you want to target
14:07:32 <lispy> Rakin05: gtk2hs is big and featureful but good luck building it
14:07:35 <bitonic> Rakin05: wx and gtk are the popular ones
14:07:46 <tazjin> Rakin05: For example, there's no good way to make applications for OS X that really feel native. I think gtk is generally the most popular one
14:07:49 <bitonic> lispy: I had no problem building that - on linux, at least
14:07:54 <bitonic> tazjin: what about wx?
14:08:14 <Taneb> wx just looks wx-y, iirc
14:08:18 <Rakin05> i wanna try wx but it is not compiling with 2.8 on my ubuntu
14:08:30 <tazjin> bitonic: Wx is okay, but you never get a Mac-like feeling with a wx or gtk app
14:08:35 <kallisti> yeah you have to do a workaround
14:08:42 <kallisti> because Debian's package is missing stuff
14:08:46 <bitonic> Taneb: wx is a frontend to the various native things
14:08:58 <bitonic> tazjin: for example on Mac OS X they actually are cocoa applications in the end
14:09:02 <bitonic> iirc
14:09:07 <tazjin> bitonic: Doesn't matter so much on Windows because most things there are just randomly thrown together UI frameworks with no consistent feelings, but it makes a difference on OS X
14:09:11 <lispy> For opengl programs I use GLFW-b (on hackage)
14:09:14 <bitonic> that's the big sellin point for wx
14:09:23 <kallisti> deb http://apt.wxwidgets.org/ squeeze-wx main
14:09:23 <tazjin> bitonic: Yeah, but they still do things like their own toolbars etc.
14:09:23 <kallisti> deb-src http://apt.wxwidgets.org/ squeeze-wx main
14:09:42 <kallisti> Rakin05: ^ add that to your /etc/apt/sources.list, but change "squeeze" to whatever version of Ubuntu you have.
14:09:49 <bitonic> tazjin: afaik you can program "native" applications with wx and mac os x. iirc textmate was wx, for example.
14:09:59 <Rakin05> at the moment i use gtk with glade and it is doin' a pretty good job
14:10:13 <Rakin05> kallisti: thank you, will try that
14:10:16 <kallisti> then sudo apt-get install wx2.8-headers/squeeze-wx wxbase2.8-dev/squeeze-wx
14:10:21 <kallisti> etc.  again replacing squeeze
14:10:26 <kallisti> I think there's one more library you want.
14:10:33 <kallisti> it's kind of a pain..
14:11:17 <Rakin05> kallisti: what about deployment with wx. is it a pain too?
14:11:42 <kallisti> it's not too bad.
14:11:50 <kallisti> but it is a fairly thin layer over the wx libraries.
14:12:01 <kallisti> so it will feel like imperative code.
14:12:38 <kallisti> also documentation is a bit confusing.
14:12:56 <kallisti> but it's useable, and cross-platform.
14:13:15 <Rakin05> but thats the same with c++ libraries
14:14:10 <Rakin05> the only real good documentation for a gui library IMHO is the one of qt
14:14:12 <kallisti> I imagine it's step up from using the C++ libraries
14:14:16 <kallisti> simply because, well, it's Haskell. :P
14:14:17 <bitonic> Rakin05: I agree on that
14:14:21 <bitonic> (qt)
14:14:31 <bitonic> qt is quite nice to use
14:14:41 <Rakin05> yeah.... but c++
14:14:44 <bitonic> yeah
14:14:52 <bitonic> also, they've got their own weird preprocessor stuff
14:14:58 <bitonic> and their own libraries for everything
14:15:06 <bitonic> I mean it's Qt C++ :P
14:15:17 <lispy> IMO, the long term solution is to make something analogous to wx or gtk but using less C/C++ and more Haskell + native bindings
14:15:37 <Rakin05> every time i read some c++ source the only thing i see is stars :-D
14:15:42 <lispy> The problem is that it's a rather large undertaking and no one with sufficient time has stepped forward
14:16:11 <bitonic> lispy: that's a lot of work and it's near-impossible to make it work nice on all platform
14:16:28 <bitonic> in my experience, the best thing is Qt, but I don't have much experience
14:17:05 <Rakin05> is qt still part of nokia?
14:17:09 * lispy has to run
14:17:26 <bitonic> Rakin05: it's still nokia afaik
14:17:44 <Rakin05> bitonic: hope it will survive in the hands of nokia :-D
14:17:58 <Botje> anyone look at what the E17 guys are doing?
14:18:00 <bitonic> Rakin05: yeah, me too
14:18:50 <Rakin05> bitonic: but qt 5 is on it's way
14:20:28 <bitonic> we'll see
14:20:41 <bitonic> I hope I won't have to develop GUI apps in the future anyways :)
14:21:17 <PointFree> Can (->) be regarded as a normal type constructor?
14:21:37 <Rakin05> bitonic: i'm really not a fan of microsoft products but wpf is very very nice. did some things some time ago.
14:21:46 <t7> PointFree: yeah
14:21:46 <Cale> PointFree: yes
14:21:55 <PointFree> Ooooh.
14:22:02 <bitonic> Rakin05: have no idea about that
14:22:41 <Rakin05> bitonic: it is a way of writing the gui in a form of xml but taken to the extreme
14:25:14 <PointFree> Can I make (->) an instance of my custom typeclass?
14:25:22 <bitonic> PointFree: of course
14:25:41 <PointFree> Wow.
14:25:48 <bitonic> PointFree: just know that you can't section it - you have to write `(->) e' instead of `e ->'
14:26:37 <PointFree> That doesn't seem like a major annoyance, it's just a matter of syntax.
14:26:53 <Philippa> yeah, it's an intense but minor annoyance
14:27:28 <bitonic> and of course you need flexible instances to instantiate the partially applied one
14:29:14 <PointFree> The only real major annoyance I have found so far is that I cannot perform pattern-matching on functions composed using the dot operator.
14:29:21 <Rakin05> anyone got expirience with haskell on windows?
14:30:13 <sm> a little
14:30:16 <PointFree> If only (.) were a data constructor...
14:32:01 <t4nk009> hi guys
14:32:10 <captWheeto> Hey
14:32:25 <bitonic> PointFree: that would be problematic
14:32:40 <bitonic> to pattern patch on Haskell terms themselves
14:32:46 <bitonic> problematic on different levels :P
14:32:52 <bitonic> *various
14:32:55 <zuserm> PointFree: with some extensions you can can make a (:.) constructor to carry around composeable functions, and then you can match against it, or interpret it to get the composed function out
14:33:30 <PointFree> zuserm: What extensions? :O
14:34:05 <fragamus> howdy
14:34:29 <zuserm> PointFree: TypeOperators and GADTs, at least
14:35:09 <bitonic> PointFree: but that wouldn't "compose" functions. you'd just have a `data Func a b c = Func (a -> b) (b -> c)', or similar. then ofc you could have a function `Func a b c -> a -> c'
14:36:11 <bitonic> PointFree: pattern matching on Haskell terms would be very problematic, as I said, both for practical reasons and problems at the type level. Look at lisp if you want to do that :)
14:36:21 <PointFree> No, no.
14:36:41 <PointFree> I would much rather work around Haskell's limitations than use Lisp.
14:36:50 <PointFree> Haskell is much, much cleaner.
14:37:22 <zuserm> bitonic: right
14:37:22 <zuserm> PointFree: you don't really need GADTs I don't think, I was just distracted
14:37:32 * EnglishGent likes both (Haskell & Lisp)
14:37:33 <lambdabot> EnglishGent: You have 1 new message. '/msg lambdabot @messages' to read it.
14:37:47 <EnglishGent> I missed what this what about though :|
14:38:13 <PointFree> I want to do something like "derivative sin = cos ; derivative cos = negate . sin ; derivative exp = exp ; ..."
14:38:36 <bitonic> PointFree: no, you can't do that. and you never will, in Haskell
14:38:42 <bitonic> what's the type of that function, to begin with?
14:39:09 <PointFree> derivative :: (Floating a) => (a -> a) -> (a -> a)
14:39:10 <bitonic> well actually that's not a problem, `(Double -> Double) -> Double -> Double'
14:39:12 <bitonic> yeah
14:39:23 <Tomsik> you can do that, only you need a bit more type magic
14:39:44 <bitonic> Tomsik: no, you can't do that if that's the type signature
14:39:55 <PointFree> I would like to know what the data constructors of (->) a b are.
14:39:59 <bitonic> (e.g. if `sin' and `cos' are ordinary function)
14:40:12 <bitonic> *functions
14:40:16 <Tomsik> Well yes
14:40:17 <PointFree> But I guess they are hidden because otherwise optimizations cannot be performed.
14:40:24 <fragamus> pardon me, I have been out of practice with haskell for a while and I have a really basic question
14:40:30 <Tomsik> You might need a few constructors there and there
14:40:54 <bitonic> PointFree: it's not just optimizations
14:41:08 <fragamus> I have some old code and I am getting     Could not find module `Control.Monad.Loops'
14:41:19 <bitonic> if you can arbitrary pattern match on terms you lose nice properties
14:41:29 <fragamus> I just installed the Haskell paltform and I'm using GHC
14:41:34 <PointFree> bitonic: Like?
14:41:48 <bitonic> e.g. if you have a function that accepts a polymorphic type, you know that that function won't be able to get anything out of it
14:41:59 <Tomsik> actually, you can do just that, with rewrite rules
14:42:21 <bitonic> that's called parametricity and it's an important property
14:42:32 <bitonic> Tomsik: that's a different thing, you're just helping the compiler optimise
14:42:44 <Tomsik> derive?
14:42:59 <bitonic> Tomsik: ? you mean automatically deriving instances?
14:43:00 <fragamus> do I use cabal or what
14:43:04 <Tomsik> That's not an optimisation, it's a question if something is syntactically possible
14:43:10 <PointFree> fragamus: I think yeah.
14:43:16 <Tomsik> Are we both talking about PointFree's question?
14:43:36 <PointFree> fragamus: cabal install monad-loops
14:43:50 <bitonic> Tomsik: yes, which is "why can't I pattern match against arbitrary Haskell terms
14:43:54 <fragamus> thank you
14:44:24 * bitonic has to go
14:46:10 <rjk> Thank Botje BMeph Tomsik. Debug.Trace did it great for me.
14:46:25 <hpc> @quote oasis
14:46:25 <lambdabot> chromatic says: My productivity increased when Autrijus told me about Haskell's trace function. He called it a refreshing desert in the oasis of referential transparency.
14:47:22 <SuperSonicSound> Hello World!
14:47:26 <PointFree> @src trace
14:47:26 <lambdabot> trace string expr = unsafePerformIO $ do
14:47:26 <lambdabot>     hPutStrLn stderr string
14:47:26 <lambdabot>     return expr
14:48:02 <PointFree> I would never use such an ugly thing.
14:56:09 <PointFree> Sometimes, I wish the notions of "group under +", "group under *" were defined as separate Haskell typeclasses, instead of a single, dull typeclass "Num".
14:57:16 <Tomsik> Num is something more
14:57:26 <zuserm> PointFree: http://hackage.haskell.org/package/numeric-prelude
14:57:29 <Tomsik> Or less, depending on how you look at it
15:00:35 <PointFree> Tomsik: If there were a "multiplicative group only" typeclass, I would be able to implement a function that computes the n-th Fibonacci number using the exponentiation by squaring implementation provided in the Prelude.
15:01:00 <Tomsik> PointFree, well, you need a Monoid instance for this
15:01:02 <Tomsik> only that
15:01:13 <Tomsik> and you've got one
15:01:16 <PointFree> @type (^)
15:01:16 <lambdabot> forall a b. (Num a, Integral b) => a -> b -> a
15:01:53 <PointFree> @src Monoid
15:01:54 <lambdabot> class Monoid a where
15:01:54 <Tomsik> hmm
15:01:54 <lambdabot>     mempty  :: a
15:01:54 <lambdabot>     mappend :: a -> a -> a
15:01:54 <lambdabot>     mconcat :: [a] -> a
15:01:59 <PointFree> @hoogle Monoid
15:02:00 <lambdabot> Data.Monoid module Data.Monoid
15:02:00 <lambdabot> Data.Monoid class Monoid a
15:02:00 <lambdabot> package monoid-owns
15:02:17 <Tomsik> yeah, you'd need to define your own ^
15:02:25 <Tomsik> but that'd make sense
15:02:48 <Tomsik> (^) :: forall a b (Monoid a, Integral b) => a -> b -> a
15:03:00 <kallisti> I don't think anyone is actually using webdriver. I feel like I would be getting many more angry emails if they were.
15:03:05 <PointFree> Haskell is a beautiful language in search of a decent standard library.
15:03:14 <Plex-> with ghci, version 7.0.4, how would I import Data.Map (in the interpreter), as apparently something was changed in 6.8?
15:03:30 <kallisti> PointFree: base is not so bad. But yes, there's always the ability to improve.
15:03:35 <Tomsik> PointFree, I'm pretty sure that my (^) would scare newbies even more
15:03:41 <Plex-> also, I should note that I have almost no idea what i'm doing - i'm still reading Learn  You a Haskell
15:03:46 <kallisti> I think one of the design goals of Prelude is to be simple to understand
15:03:56 <Botje> Plex-: it's still :m +Data.Map
15:04:05 <Tomsik> There could be a more generic standard library, but it would be a great barrier for adoption
15:04:12 <Plex-> could not find module
15:04:13 <PointFree> I don't think the notions of "additive group" and "multiplicative group" are terribly hard to understand.
15:04:25 <kallisti> we say the same thing about monads. ;)
15:04:30 <Botje> Plex-: how did you install haskell?
15:04:35 <PointFree> kallisti: Yup.
15:04:51 <Botje> Plex-: unless you need the latest and greatest, the haskell platform is all you need
15:05:01 <Tomsik> PointFree, not for me, not for you, but I have to tell you that the bleak truth is that most of programmers have never heard of groups
15:05:21 <adnauseam> anyone got an idea how to unset a variable set by @let on lambda bot? they don't expire
15:05:27 <adnauseam> on my lamdabot
15:05:28 <Botje> @ unlet
15:05:46 <Plex-> Botje: I downloaded that, using t he openSUSE repository provided by haskell.org
15:06:02 <wli> Well, semigroup might be more accurate since inversion isn't required.
15:06:09 <adnauseam> btoje 100% ? it'sgivingme me "Template Haskell not enabled", and im not sure how to turn it on
15:06:50 <Tomsik> wli, monoids! You want x^0 to work (most of the time)
15:07:38 <wli> Tomsik: There should be some way to generalize identities over different kinds of (semi)groups.
15:07:48 <Peaker> PointFree, I think conal did a blog post about AD
15:08:13 <kallisti> yeah I think the more abstract algebra we adopt into Prelude, the less popular Haskell will become. Not that it's necessarily a bad thing, but I enjoy seeing Haskell's rise in use.
15:08:21 <PointFree> Peaker: Lemme see.
15:08:22 <adnauseam> @let a = "test"
15:08:23 <lambdabot>  Defined.
15:08:23 <Peaker> PointFree, http://conal.net/blog/posts/beautiful-differentiation
15:08:27 <adnauseam> @unlet a
15:08:27 <lambdabot>   TemplateHaskell is not enabled
15:08:39 <PointFree> Peaker: Oh, nice.
15:08:41 <adnauseam> @un let a
15:08:41 <lambdabot> Maybe you meant: undefine undo unlambda unmtl unpf unpl unpointless run wn
15:08:50 <adnauseam> @undefine a
15:08:55 <adnauseam> > a
15:08:56 <lambdabot>   a
15:09:37 <adnauseam> @undefine works
15:09:43 <adnauseam> <3
15:10:01 <wli> The "tower of derivatives" is called a jet.
15:10:04 <Botje> Plex-: hmm. it should be included :/
15:10:27 <Botje> gotta run though, sorry.
15:10:28 <zygoloid> The novice said to the master "Oh master, I need a monoid but all I have is a semigroup. Is there any hope for me?" The master replied "Maybe." The novice was enlightened.
15:10:28 <Plex-> Botje: I figured it out. 'ghci-containers-devel' and 'ghci-containers' needed to be installed. the default options from the repository did not include this
15:10:35 <Plex-> I figured something like that would be standard
15:11:01 <Botje> Plex-: ah. I'd think the haskell-platform package depends on ghci-containers.
15:11:16 <Plex-> then it was -devel. I have no idea, but it's working now
15:11:19 <Botje> maybe you only installed ghci instead of the haskell-platform package? (if that in fact exists in that opensuse repo)
15:11:52 <Plex-> too lazy to figure it out, i'll do that if something doesn't work later :P
15:12:24 <Tomsik> zygoloid: HEH
15:12:26 <Tomsik> ops
15:13:40 <Botje> Plex-: oh, opensuse doesn't have a platform. silly.
15:13:55 <Botje> well, ask around if you get more "cannot be found" errors
15:14:04 <Botje> I think you should be good until the parsec or monad chapters
15:14:09 <Botje> which should take you a few days anyway ;)
15:16:29 * hackagebot HaTeX 3.3 - The Haskell LaTeX library.  http://hackage.haskell.org/package/HaTeX-3.3 (DanielDiaz)
15:16:57 <kallisti> anyone familiar with wxHaskell? I'm trying to specify that a dialog has no parent
15:17:01 <kallisti> there doesn't seem to be any way to do that.
15:19:03 <kallisti> I'm looking everywhere and finding no sort special "empty frame" value
15:19:09 <kallisti> *sort of
15:19:10 <adnauseam> kallisti: i've no idea tbh, but can't it be its own parent ?
15:19:24 <adnauseam> then consider that as having no parent
15:19:45 <adnauseam> just trying my hand at thinking outiside of the box here
15:20:11 <kallisti> adnauseam: pretty sure I  can't do that.
15:20:20 <kallisti> I have to specify a parameter at initialization
15:20:33 <kallisti> so I've have to do some kind of MonadFix magic, which is likely not going to do what I want.
15:21:42 <kallisti> ah I found it
15:21:46 <kallisti> it's called objectNull
15:21:50 <kallisti> it took much clicking to find. :P
15:23:08 <Tomsik> This is a perverted mind that wants to wash away unwanted parameters with MonadFix
15:24:52 <Luke> I'm trying to use cabal-meta but every time I run it it tells me to install cabal-src (which I have). I've noticed that "cabal list" doesn't show an installed version of cabal-src though. anyone know what's up?
15:25:21 <dcoutts> Luke: we don't yet track the installed status of progs, only libs
15:26:27 <dcoutts> Luke: cabal list should say [ unknown ] rather than  [ not installed ]
15:26:34 <dcoutts> for progs
15:27:29 <PointFree> @type pure
15:27:29 <Luke> dcoutts: ah yeah that's what ti says
15:27:29 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
15:27:42 <PointFree> Wow.
15:27:46 <Luke> dcoutts: thanks. any idea why cabal-meta would be failing then?
15:28:01 <dcoutts> Luke: is it on the path?
15:28:09 <Luke> dcoutts: yeah
15:28:18 <dcoutts> sorry, no idea, never used cabal-meta
15:28:35 <Luke> dcoutts: thanks
15:29:09 <PointFree> Peaker: You still there?
15:29:19 <PointFree> Peaker: Thank you very much for that link.
15:29:23 <fragamus> wow I just had to put this in my ghc:       pgmgcc="/Applications/Xcode.app/Contents/Developer/usr/bin/gcc"
15:29:28 <Peaker> PointFree, no problem
15:29:44 <Peaker> PointFree, conal's blog is full of nice stuff :)
15:30:08 <fragamus> i hope that is the right approach
15:30:37 <Luke> dcoutts: looks like it works in the term but not eshell. definitely a path problem - thanks
15:30:46 <dcoutts> ah
15:31:26 <Rakin05> just seen {-# LANGUAGE ... -} in a source file. could someone explain what this is?
15:32:18 <zuserm> Rakin05: it enables that language extension, like passing -X... to GHC
15:32:49 <fragamus> I have another basic question but hopefully the answer will teach me to fish…  how can I determine the package name for, say,   Data.Random.Normal
15:32:53 <Rakin05> zuserm: what is it used for? any example?
15:33:25 <zuserm> Rankin05: depends on the extension, what's in the ... ?
15:33:49 <Rakin05> software transactional memory ... aka stm
15:34:15 <Rakin05> ohh you mean the language. it is a haskell file
15:34:20 <Rakin05> so .hs
15:35:18 <zuserm> Rakin05: I mean, what does it actually say in the {-# LANGUAGE ... -} ?
15:35:59 <zuserm> fragamus: you can search the module name on hayoo
15:36:03 <Rakin05> zuserm: {-# LANGUAGE GeneralizedNewtypeDeriving #-}
15:37:17 <fragamus> wow I had no idea hayoo existed
15:37:56 <nand`> http://www.haskell.org/hoogle/?hoogle=Data.Random.Normal also works
15:41:14 <zuserm> Rakin05: GeneralizedNewtypeDeriving lets you derive typeclass instances for newtypes based on the wrapped types
15:45:39 <PointFree> Sorry for the n00bness... what is wrong with
15:45:49 <PointFree> instance (Num a) => Num ((->) a a) where ...
15:46:42 <zuserm> PointFree: http://www.haskell.org/haskellwiki/Num_instance_for_functions
15:47:05 <rwbarton> that instance declaration is not Haskell 98 because the type variable a is repeated
15:47:31 <fragamus> whats the word on this:     ld: warning: could not create compact unwind for _ffi_call_unix64: does not use RBP or RSP based frame
15:47:40 <PointFree> rwbarton: lolwat
15:47:46 <rwbarton> ...
15:49:33 <PointFree> FML, defining Eq for functions is impossible.
15:50:45 <strager> Is there a way to create a type from an existing type, but only with a subset of that types constructors?  I know I can create a new data type by copy-pasting the implementation and removing constructors I don't want, and write a bunch of conversion code, but I'm looking for something like a GHC extension.
15:51:19 <dolio> No.
15:51:58 <aristid> PointFree: you can just error it all out (i.e. put error "This is not implemented" in the definitions)
15:52:16 <aristid> PointFree: i think Num dropped the dependency on Eq recently though
15:52:17 <zuserm> PointFree: you can define (Enum a, Bounded a, Eq  b) => Eq (a -> b), but it might take a while if you want to use it for say, Int -> Int
15:52:44 <aristid> PointFree: so if you install ghc 7.4.1, that would be fixed
15:52:52 <Saizan> strager: you could redefine the first type as a gadt with an index that specifies which constructors are allowed in the restricted one, could be overkill though, especially if you don't know gadts already
15:53:09 <strager> Saizan: Interesting.
15:53:15 <PointFree> aristid: I am too much of a coward / Linux n00b to install anything from other than a Debian package.
15:53:17 <strager> I have control over all the types so that may work.
15:53:29 <strager> I haven't used GADT's but I've read about them here and there.  I'll try them out; thanks.
15:57:42 <aristid> PointFree: i can only recommend using 7.4.1 though.
15:57:55 <aristid> PointFree: so if you ever feel courageous, do it :)
16:02:45 <parcs`> PointFree: install 7.4.1 from debian sid
16:03:11 <wo0kie> can someone point me in the direction of monadic parsing tutorials?
16:03:25 <wo0kie> I'm having a very difficult time with this homework I'm working on
16:03:52 <parcs`> wo0kie: http://book.realworldhaskell.org/read/using-parsec.html ?
16:04:08 <wo0kie> thanks
16:04:23 <PointFree> parcs`: Last time I tried to configure my /etc/apt/sources.list, I ended up having to reinstall everything.
16:04:24 <parcs`> also http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
16:04:48 <parcs`> PointFree: you probably did it wrong ;)
16:04:51 <PointFree> I'm not very knowledgeable about actual computers.
16:05:00 <PointFree> I just happen to be interested in computation.
16:05:02 <parcs`> PointFree: are you using debian stable or testing?
16:05:06 <PointFree> stable
16:05:12 <parcs`> hmm
16:05:25 <parcs`> then it's probably a bad idea to use a sid package
16:05:41 <parcs`> you should locally install the ghc linux binary from the ghc website
16:05:50 <parcs`> it's built on debian stable so it should work out of the box
16:08:04 <PointFree> parcs`: I will give it a try - just not right now.
16:10:16 <parcs`> :)
16:21:00 <adnauseam> > 1+1
16:21:00 <lambdabot>   2
16:22:15 <Mathnerd314> are there any inhabitants of data X = X -> Y other than _|_?
16:22:36 <Tomsik> how is Y quantified?
16:23:09 <Mathnerd314> Y is an arbitrary type, you can make it whatever
16:23:27 <rwbarton> how about const y for various values y of type Y
16:24:09 <rwbarton> once you have those, you can make more
16:24:10 <Tomsik> \_ -> _|_ seems valid
16:25:16 <wo0kie> man parsing is difficult
16:26:41 <Schadenfreude_> No manual entry for parsing
16:26:41 <Schadenfreude_> No manual entry for is
16:26:41 <Schadenfreude_> No manual entry for difficult
16:26:54 <Tomsik> heh
16:27:04 <Tomsik> Parsing men, halleluyah
16:27:11 <Schadenfreude_> :P
16:30:10 <salisbury> am I correct in saying that head normal form is the application of something to a normal form?
16:31:34 <Mathnerd314> rwbarton: so that suggests it's data X = Y | X -> Y
16:32:48 <Botje> salisbury: only up to the constructor.
16:33:52 <salisbury> Botje: what do you mean?
16:35:11 <Botje> HNF means that the head is in normal form, but the other parts might still be reducible.
16:35:43 <salisbury> or have no normal form at all, correct?
16:37:23 <Botje> hmm?
16:38:26 <salisbury> it is also possible the other parts may never terminate if one tries to reduce them?
16:38:56 <Peaker> what's the "weak" in WHNF?
16:39:22 <hpc> WHNF: distinguish _|_ from \_ -> _|_
16:39:36 <hpc> HNF: distinguish \_ -> constr from \_ -> _|_
16:40:29 <Tomsik> salisbury, that's the whole point of laziness
16:40:30 <dmwit> What, head normal form evaluates under binders?
16:40:31 <Peaker> I don't understand how deep HNF goes in there..?
16:41:15 <hpc> er
16:41:31 <hpc> HNF = \_ -> WHNF
16:41:36 <hpc> for lambdas
16:42:06 <hpc> HNF describes some notion of "productivity"
16:42:19 <hpc> for any value you pass to a HNF lambda, you will get at least a constructor back
16:42:47 <hpc> if that makes any sense
16:43:34 <hyped89> 5+5
16:43:38 <Peaker> I'm not sure I see why this is useful, though. it seems kind of arbitrary
16:43:54 <hpc> it is, imo
16:44:13 <dmwit> > 5+5 -- hyped89, you need a "> " at the beginning of the line to get lambdabot to execute your code
16:44:13 <salisbury> (F f) ->> f (F f)
16:44:13 <lambdabot>   10
16:44:14 <hpc> you can't evaluate under a lambda in haskell, anyway
16:44:23 <hpc> so HNF doesn't really exist as a language concept
16:44:29 <Tomsik> Peaker: normal forms are important for evaluation order
16:44:45 <Tomsik> and picking different form results in something different
16:45:00 <Botje> Tomsik: normal forms just tell you when to stop evaluating
16:45:20 <Tomsik> Exactly
16:45:28 <Tomsik> So you don't evaluate too much or not enough
16:55:44 <sajith> *cough*
16:55:49 <sajith> accelerate-examples refer to 'randomUArrayR' and 'convertUArray'
16:56:24 <sajith> where can I find these?
16:57:00 <hpc> @hoogle convertUArray
16:57:01 <lambdabot> No results found
16:57:06 <hpc> no idea :P
16:57:42 <rwbarton> google suggests they are defined in the accelerate-examples package itself
16:57:48 <rwbarton> http://hdiff.luite.com/cgit/accelerate-examples/commit?id=0.2.0.0
17:02:15 <Peaker> #python is bigger than #haskell again :-P
17:03:11 <Botje> woo! #1 at avoiding success!
17:03:17 <sajith> hpc: thought so. :)
17:04:51 <sajith> rwbarton: hmm, interesting. I don't see src/Random.hs and the such in accelerate-examples 0.12.0.0...
17:20:50 <mm_freak> t7: does your code type-check "\(A : Set) (f : A -> A) -> f" properly?
17:21:33 <mm_freak> you have the same type-checker for Abs and mine gives me something very weird
17:22:11 <mm_freak> TcResult (A : Set) → (x : A → A) → x → x
17:22:11 <mm_freak> \(A : Set) (x : A → A) → x
17:22:40 <copumpkin> wat
17:23:09 <copumpkin> you need to start distinguishing between lambda arrows and type arrows :P
17:23:16 <mm_freak> copumpkin: i do
17:23:25 <copumpkin> unless that says what I think it means, in which case I don't udnerstand
17:24:01 <t7> \(a : Set0) -> \(c : (b : a) -> b) -> b   <- this term?
17:24:01 <copumpkin> (A : Set) → (x : A → A) → x → x
17:24:11 <copumpkin> what are the inhabitants of x?
17:24:12 <mm_freak> t7: no
17:24:28 <mm_freak> copumpkin: i know…  the type-checker gives me a wrong result
17:24:41 <mm_freak> t7:         Lam Typ $ Lam (Var 0 :-> Var 1) $ Var 0
17:24:43 <copumpkin> oh, it's attempting to infer types?
17:24:56 <mm_freak> copumpkin: it doesn't infer
17:25:06 <t7> \(a : Set0) -> \(c : a -> a) -> a
17:25:33 <mm_freak> t7: again, that's not the same function
17:25:44 <t7> oh sorry
17:25:47 <mm_freak> \(A : Set) -> \(f : A -> A) -> f
17:25:50 <copumpkin> mm_freak: hmm, then if you wrote the type down yourself, I don't see how it makes sense :P
17:25:55 <mm_freak> an identity function for functions
17:26:30 <mm_freak> copumpkin: i'm just very puzzled why this doesn't work…  with named arguments the same type checker worked perfectly
17:26:44 <mm_freak> and i suspect that t7's type-checker will give the same weird result
17:27:30 <copumpkin> if it helps, Agda distinguishes between types and sorts
17:27:59 <mm_freak> copumpkin: i do that, too, but sorts aren't involved in this error
17:28:09 <aristid> copumpkin: Set 0 vs Set 2?
17:28:12 <copumpkin> oh, I'm just saying that the type (A : Set) → (x : A → A) → x → x makes no sense
17:28:16 <copumpkin> aristid: no
17:28:42 <mm_freak> the nature of the problem indicates that there is something wrong with my de bruijn indices and the type-checking context (which is a stack of types)
17:28:43 <t7> \(A : Set) -> \(f : A -> A) -> f    types as    (a : Set0) -> (a -> a) -> Set0
17:29:04 <aristid> copumpkin: what's the agda name for "sorts" then?
17:29:10 <mm_freak> t7: that's even weirder
17:29:22 <copumpkin> t7: that just looks like it thinks you're returning a instead of f
17:29:46 <t7> wow wait
17:29:48 <copumpkin> aristid: sorts are types of types
17:29:51 <t7> my term is still wrong
17:29:53 <copumpkin> at any level
17:30:10 <copumpkin> that is, their values can themselves have values
17:30:17 <copumpkin> you can't declare new ones
17:30:22 <mm_freak> t7: your term is right
17:30:28 <t7> \(a : Set0) -> \(c : a -> a) -> c    type checks as     (a : Set0) -> (c : a -> a) -> c -> c
17:30:49 <mm_freak> t7: ah, ok
17:30:57 <mm_freak> t7: then your type-checker has the same problem as mine
17:31:55 <aristid> copumpkin: i thought kinds are types of types, and if you can't declare new ones, which ones already exist?
17:32:02 <t7> going to bed
17:32:19 <copumpkin> aristid: all the Set ns
17:33:14 <mm_freak> i'm tempted to once again go back to named variables from de bruijn indices…  while they require an awkward alpha equivalence algorithm they are otherwise much easier to deal with =/
17:33:38 <aristid> mm_freak: maybe make two branches, so the cost of switching daily isn't that bad?
17:34:14 <mm_freak> aristid: i have that anyway, but now i should really decide which way to go, because i want to finish this thing some day =)
17:34:48 <mm_freak> and the difference is significant enough that i can't just later merge the branches
17:35:07 <aristid> copumpkin: and Set 1 / Set 2 can have types as parameters to their constructors, but because they _aren't_ the constructors, they aren't kinds/sorts? themselves?
17:36:05 <zuserm> Any suggestions for a good simple sound library?
17:36:38 <jfischoff> is the type looks analogous to polymorphic version (a -> a) -> (a -> a) -> a -> a or am I missing something?
17:36:46 <copumpkin> aristid: forget universe polymorphism. Set0, Set1, … are all sorts
17:36:58 <mm_freak> jfischoff: it's analogous to (a -> a) -> a -> a
17:37:09 <mm_freak> not only analogous…  it /is/ that
17:37:16 <copumpkin> huh
17:37:20 <copumpkin> jfischoff: nope, because that c is bound earlier in the type to be a value of type a -> a
17:37:34 <aristid> copumpkin: and what would be the equivalent of kinds?
17:37:44 <mm_freak> jfischoff: in haskell the first argument is implicit
17:37:47 <copumpkin> equivalent of kinds?
17:38:11 <mm_freak> and the type (A : Set) -> (A -> A) -> A -> A can be read as this haskell type:  forall a. (a -> a) -> a -> a
17:38:16 <aristid> copumpkin: IO :: * -> *
17:38:28 <copumpkin> IO : Set -> Set
17:38:34 <mm_freak> aristid: * is Set
17:38:38 <mm_freak> and Set is Set 0
17:38:49 <aristid> mm_freak: i know, but copumpkin tells me that Set is a sort, not a kind
17:38:53 <jfischoff> mm_freak: I was referring to what copumkin wrote: (A : Set) → (x : A → A) → x → x
17:39:13 <aristid> mm_freak: and i always thought the hierarchy was type/kind/sort
17:39:23 <mm_freak> aristid: the level hierarchy is different in a dependently typed language…  you can say that there are levels for values and types
17:39:27 <jfischoff> mm_freak: but I understand what your saying about (A : Set) -> (A -> A) -> A -> A
17:39:31 <mm_freak> and types are of types, not of kinds
17:39:40 <copumpkin> aristid: this is a different language
17:39:49 <mm_freak> jfischoff: that type is just incorrect
17:40:00 <aristid> copumpkin: so the concept just doesn't carry over?
17:40:00 <mm_freak> jfischoff: it results from a bug in the type checker i wrote
17:40:08 <copumpkin> aristid: there's no notion of kind in agda
17:41:08 <mm_freak> and i'm trying to find the cause of the bug for hours now =/
17:41:31 <aristid> copumpkin: you seem annoyed by my stupid questions. sorry
17:41:50 <copumpkin> not at all!
17:41:54 <jfischoff> copumpkin: I don't see why the type you wrote is uninhabited:  (A : Set) → (x : A → A) → x → x?
17:42:19 <jfischoff> or x that is
17:42:20 <copumpkin> jfischoff: x is a _value_ of the type A -> A, and as such it is a function. It is not a type, so it does not have inhabitants
17:42:38 <parcs`> am i in agda
17:42:41 <jfischoff> ah
17:42:53 <jfischoff> so you still write a function with that signature
17:43:14 <copumpkin> well, if you write it, it's badly typed
17:43:28 <copumpkin> aristid: sorry, just doing other stuff and not paying as close attention as I might otherwise
17:43:40 <jfischoff> then I don't understand. No worries :)
17:43:55 <copumpkin> the type of -> can't be expressed, but the closest you might get is Set -> Set -> Set
17:44:06 <copumpkin> as such, things on either side of it must have type Set
17:44:22 <alpounet> copumpkin, you have given an intro to agda talk right?
17:44:24 <copumpkin> in the type I wrote, the type of things on either side of the arrow have type A -> A
17:44:40 <copumpkin> alpounet: two! only one was recorded, and neither am I particularly proud of :P
17:45:13 <alpounet> uh? only watched the recorded one
17:45:16 <aristid> copumpkin: is it correct that Set 1 is a value (of type Set 2), a type, and a sort?
17:45:30 <jfischoff> copumpkin: I liked your talk
17:45:40 <copumpkin> jfischoff: thanks :)
17:45:51 <copumpkin> aristid: yeah, almost all types are values, too, and have types of their own
17:46:01 <alpounet> copumpkin, you should write a "Learn You a Agda for... Great CPU Load!"
17:46:05 <copumpkin> some types (and thus values) are also sorts, but that's an independent axis
17:46:13 <Brolapse> can anyone give me insight into error handling in haskell? like getting an int from input and verifying it's a number
17:46:35 <hpaste_> “Ertugrul Söylemez” pasted “Buggy type checker” at http://hpaste.org/67856
17:46:37 <dmwit> Not a lot of insight to give.
17:46:38 <dmwit> Use reads.
17:46:54 <mm_freak> the bug must be in the checkLam function
17:46:56 <copumpkin> aristid: the only place agda really mentions sorts is when defining types (it'll complain that the return type of your type must be a sort)
17:47:05 <copumpkin> gah, s/return//
17:47:10 <mm_freak> apparently i'm doing /something/ wrong with the type checking context
17:48:02 <dmwit> Unless you need speed, of course.
17:48:07 <copumpkin> mm_freak: now that I think about it, are you sure that it isn't just an off-by-one error in your de bruijn indices? the type would be correct if you replaced the last two Xs with As
17:48:29 <mm_freak> copumpkin: yeah, that's what i'm suspecting
17:48:34 <jfischoff> copumpkin: would this be okay: (A : Set) → (A → A) → (A -> A) → A -> A ?
17:48:39 <mm_freak> copumpkin: it's probably not an indexing error, but a context error
17:48:43 <aristid> copumpkin: ah, it all makes more sense now :)
17:49:01 <mm_freak> jfischoff: think of this haskell function:  id f = f
17:49:08 <copumpkin> jfischoff: yeah, sure, although the one corresponding to his definition would only have one function argument
17:49:23 <jfischoff> okay I understand now
17:49:36 <mm_freak> jfischoff: its type is a -> a, but i'm specializing it to (a -> a) -> (a -> a)
17:49:39 <aristid> mm_freak: can't resist. There are just two big problems in computer science: off-by-one errors, cache invalidation, and naming things.
17:49:57 <copumpkin> that's why we define fancy types that prevent off-by-one errors!
17:50:13 <copumpkin> then make everything as polymorphic as possible
17:50:19 <jfischoff> mm_freak: what sort language are you working on?
17:50:39 <aristid> copumpkin: and then we spend the rest of the day fighting the termination checker
17:50:42 <mm_freak> jfischoff: i'm writing a dependently typed core language…  the implementation is in haskell
17:50:49 <copumpkin> aristid: damn right
17:50:55 <mm_freak> i'll go over my code once more
17:50:58 <captWheeto>  /exit
17:51:00 <captWheeto> Whoops
17:51:08 <mm_freak> if i can't find the bug, i'll go back to named arguments
17:51:42 <jfischoff> mm_freak: nice, is it similar to pisigma http://hackage.haskell.org/package/pisigma ?
17:51:54 <mm_freak> jfischoff: yeah
17:52:06 <mm_freak> it's basically pisigma without sigma =)
17:52:26 <jfischoff> ha just dependent products, interesting
17:52:36 <mm_freak> the reason is that i'm going to add inductive families, thereby eliminating the need for a language-level sigma
17:52:50 <favonia> mm_freak: hmm... how about augmenting the "variable" with the size of the context (for debugging only)?
17:53:13 <mm_freak> favonia: could you elaborate?
17:53:18 <copumpkin> mm_freak: then you need to start thinking about what equality means :D
17:54:21 <mm_freak> copumpkin: it means nothing until i add pattern-matching =)
17:54:21 <favonia> mm_freak: when you put a variable into a term, put the de bruijn number + the size of the context together
17:54:33 <jfischoff> copumpkin: do you program in agda for work?
17:54:43 <mm_freak> favonia: when constructing the term?
17:54:53 <copumpkin> jfischoff: not really, nope :) but I work with lots of very haskelly/agdaey people
17:55:01 <favonia> mm_freak: yes. this may or may not help
17:55:06 <mm_freak> favonia: there is no context at that point
17:55:11 <randomclown> I have a list of strings ["a", "ab", "abc", "d", "def"] - some are substrings of other strings in the list. I only want the longest substrings so output should be ["abc", "def"]
17:55:23 <randomclown> I have an implementation but I want to see how you guys do it
17:55:24 <mm_freak> favonia: context is a type-checking feature, not an expression feature
17:55:41 <jfischoff> copumpkin: I bet. Still pretty early in the agda evolution anyways.
17:56:39 <byorgey> randomclown: I'd insert them all into a trie and then just read out all the paths to leaves
17:56:42 <jfischoff> is there a way to have cyclic imports?
17:56:54 <byorgey> jfischoff: there is.
17:57:22 <jfischoff> I'll find it thanks
17:57:27 <copumpkin> > nubBy isInfixOf . sortBy (flip (comparing length)) $ ["a", "ab", "abc", "d", "def"]
17:57:28 <lambdabot>   ["abc","def"]
17:57:32 <favonia> mm_freak: oh I meant... when you elaborate the external language into internal language, you can have those annotations to double check substitutions and other routines...
17:57:35 <copumpkin> (inefficient solution)
17:57:51 <mm_freak> favonia: i have only one language at this point
17:58:08 <copumpkin> jfischoff: yeah :) I'd love to write real software with it someday, when it's more usable
17:58:19 <byorgey> jfischoff: http://www.haskell.org/ghc/docs/latest/html/users_guide/separate-compilation.html#mutual-recursion
17:58:40 <jfischoff> byorgey: thanks. Google was not being helpful.
17:59:01 <favonia> mm_freak: ah, so the user write out de bruijn numbers directly?
17:59:29 <mm_freak> favonia: right now there is not even a parser…  there is only the AST
17:59:59 <mm_freak> favonia: the AST and type-checker are here:  http://hpaste.org/67856
18:00:19 <mm_freak> stripped to include only the parts relevant to the problem i'm having right now
18:00:21 <jfischoff> copumpkin: I have high hopes for agda. I can't really do anything with it personally, but I feel the potential is huge.
18:00:54 <mm_freak> jfischoff: i'm not as optimistic as you…  agda probably won't get far outside the theorem proving community
18:01:20 <mm_freak> at least not in the near future
18:01:46 <phischu> haskell is the new java, agda is the new haskell
18:01:52 <mm_freak> haskell has a greater momentum in that regard…  i just hope one day it replaces PHP
18:02:19 <jfischoff> mm_freak: perhaps but I can see other possible outcomes.
18:03:30 <fliiipy> Can anyone tell me the differences between Haskell and Prolog?
18:03:32 <mm_freak> jfischoff: the other outcome being that people actually care enough to familiarize themselves with formal logic and coinduction to write a program that displays "hello world" in an infinite loop? =)
18:03:50 <favonia> mm_freak: Is ctx something like Seq Type?
18:03:59 <mm_freak> favonia: it's exactly that
18:04:15 <copumpkin> only the most badass programmers write non-terminating agda programs in the partiality monad
18:04:33 <otters> that sounds just crazy enough to be true
18:04:34 <jfischoff> mm_freak: No. I can see a library of types and verified functions users pipe together.
18:04:49 <copumpkin> otters: it is a real thing :P
18:05:11 <copumpkin> from one viewpoint, nontermination is just another effect
18:05:22 <mm_freak> jfischoff: you will need to learn at least coinduction for virtually all non-command-line real world applications
18:06:05 <jfischoff> mm_freak: Or you write just the function signature, and crowd source the implementation.
18:06:25 <mm_freak> in agda i can totally see the compiler infer the program =)
18:06:39 <mm_freak> perhaps one day we will only write type signatures
18:06:49 <mm_freak> fliiipy: the two aren't really comparable
18:07:38 <aristid> @quote oleg.*prolog
18:07:39 <lambdabot> edwardk says: oleg doesn't write haskell. he writes prolog. he just happens to write it at the haskell type level.
18:07:53 <mm_freak> you could say that the question "what is the difference between haskell and prolog" is a type error =)
18:08:07 <mm_freak> only in haskell, of course…  in prolog you will get an infinite loop or a program crash ;)
18:08:28 <aristid> mm_freak: in haskell you might get an infinite loop or a program crash too
18:08:48 <mm_freak> aristid: not in this case though =)
18:08:57 <aristid> ok:)
18:09:05 <copumpkin> > undefined == ()
18:09:06 <lambdabot>   *Exception: Prelude.undefined
18:09:16 <copumpkin> > () == undefined
18:09:16 <lambdabot>   *Exception: Prelude.undefined
18:09:17 <kallisti> > [ ]
18:09:18 <lambdabot>   []
18:09:20 <fliiipy> Does haskell work from right to left?
18:09:24 <copumpkin> no
18:09:32 <fliiipy> Oh ok.
18:09:35 <aristid> it doesn't work from left to right either.
18:09:37 <mm_freak> fliiipy: haskell programmers often work from right to left
18:09:42 <mm_freak> f . g . h
18:09:52 <fliiipy> Ah ok.
18:09:54 <fliiipy> thanks.
18:09:59 <nand`> they also often work from left to right
18:10:03 <nand`> f >>= g >>= h
18:10:08 <kallisti> f >>> g >>> h
18:10:19 <kallisti> h >>> g >>> f   -- I guess
18:10:20 <aristid> and sometimes they mix awkwardly. f >>= (g .h)
18:10:40 <mm_freak> you should see the awkward mixes you get in agda ;)
18:10:54 <fliiipy> Ah ok. lol
18:11:11 <kallisti> I like my cat program because it composes left-to-right with >>=, >>>, and >=>
18:11:28 <kallisti> through the whole thing
18:11:35 <nand`> and sometimes they spawn abominations. f.g &&& y $ h >>= ((<$>).x)
18:12:07 <mm_freak> and sometimes they work from top to bottom
18:12:08 <copumpkin> :t ?f . ?g &&& ?y $ ?h >>= ((<$>) . ?x)
18:12:09 <lambdabot> forall a c c' a1 a2 b (f :: * -> *). (?f::a -> c, ?g::(f a2 -> f b) -> a, ?y::(f a2 -> f b) -> c', ?h::f a2 -> a1, Functor f, ?x::a1 -> a2 -> b) => (c, c')
18:12:11 <copumpkin> wow
18:12:14 <copumpkin> that actually typechecks
18:12:48 <mm_freak> reflect (Proxy :: Succ (Succ (Succ Zero)))
18:12:55 <mm_freak> and sometimes from bottom to top
18:13:26 <mm_freak> reifyNum :: Integer -> (forall n. (Num n) => Proxy n -> a) -> a
18:14:00 <nand`> (ghc :: String -> Maybe Program) . reverse
18:14:25 <mm_freak> =)
18:14:41 <mm_freak> you can omit the Maybe ;)
18:14:45 <nand`> haha
18:15:13 <nand`> I thought that was only valid for (perl :: String -> Abomination)
18:15:27 <nand`> wait, wouldn't that be (perl :: Abomination -> Abomination)
18:15:43 <mm_freak> perl :: a -> a
18:15:55 <mm_freak> short for abomination
18:16:49 <mm_freak> actually:  perl :: a' -> a
18:16:49 <fliiipy> Would Prolog or Haskell be better for pattern matching?
18:17:07 <aristid> mm_freak: so perl is falso
18:17:41 <mm_freak> fliiipy: prolog is more powerful at raw pattern matching
18:17:56 <fliiipy> Why's that?
18:18:04 <mm_freak> haskell can only match against a type's constructors
18:18:44 <nand`> *cough* n+k
18:18:59 <mm_freak> you can use guards, pattern guards, view patterns, etc., but all that is just sugar for simple constructor matching and what would otherwise be nested if-statements
18:19:29 <fliiipy> Ah ok.
18:19:31 <fliiipy> Thanks.
18:19:44 <Saizan> even in prolog you can just match on constructors, the difference is that you don't declare types
18:19:54 <mm_freak> fliiipy: to understand it, just think of a typed prolog
18:20:26 <Saizan> but prolog's unification is still more general because it's symmetric(/bidirectional)
18:21:04 <aristid> fliiipy: you might be interested in this, too: http://www.mercury.csse.unimelb.edu.au/ (a modern hybrid between prolog and haskell)
18:21:17 <fliiipy> Cool. cheers.
18:23:58 <mm_freak> is anyone else using de bruijn indices in a dependently typed language?  i'd be interested in the type-checking code
18:24:20 <favonia> mm_freak: sad. need to work on other projects now. good luck on your type checker anyway :o
18:24:42 <randomclown> is it possible to specialise a function of type f :: a -> a for any a?
18:25:50 <aristid> randomclown: that should happen automatically. if it doesn't, just write (f :: Int -> Int) if you specialise to Int
18:26:46 <Saizan> unless he meant {-# SPECIALIZE  .. #-}
18:26:51 <randomclown> oh I mean like in c++ templates where you can have a generic definition and then specialise a specific case
18:27:07 <mm_freak> randomclown: then what Saizan said
18:27:19 <mm_freak> {-# SPECIALIZE f :: Int -> Int #-}
18:27:22 <c_wraith> err...  Specialize how?
18:27:34 <c_wraith> Do you mean provide an alternate implementation for a specific type?
18:27:40 <aristid> randomclown: type classes.
18:27:43 <c_wraith> Because that requires type hackery, not the specialize pragma
18:28:01 <nand`> mm_freak: oh, I wanted to ask for your opinion on this: http://hpaste.org/67768
18:28:07 <mm_freak> randomclown: if you mean that you want to have a different /semantics/ for a particular type, that's not possible
18:28:07 <c_wraith> (hackery to have a default instance for everything that can be overridden for specific types)
18:28:17 <dmwit> SPECIALIZE is something different than the C++ sense of specialization.
18:29:08 <theorbtwo> SPECIALIZE is an optimization hint, and should have no semantic value.
18:29:28 <mm_freak> nand`: why are you reinventing hPutStrLn?
18:29:35 <randomclown> ah ok
18:30:22 <mm_freak> randomclown: you can do this in this case:  f :: (MyClass a) => a -> a
18:30:33 <mm_freak> but then you are limited by what is allowed through the type class system
18:30:36 <nand`> mm_freak: I guess I couldn't find it
18:30:55 <mm_freak> in particular it isn't straightforward to provide a generic implementation and a specialized implementation
18:31:25 <Luke> anyone here use cabal-meta with https github urls?
18:31:29 <mm_freak> finally this gives you full flexibility:  f :: MyClass a -> a -> a
18:31:30 <Luke> i can't seem to get it working
18:32:17 <mm_freak> nand`: by a first glance it seems reasonable
18:32:26 <mm_freak> nand`: although your code is probably a bit complicated for what it does
18:33:01 <mm_freak> nand`: try with only the IO monad…  you'll be surprised to find that it actually simplifies your code
18:33:04 <nand`> mm_freak: the reason I made it that complicated is to test the idea of wrapping many threaded StateT computations using an MVar to “synchronize” them
18:33:06 <mm_freak> in particular try without StateT
18:34:42 <nand`> reason I was hellbent on using a StateT is because the rest of the stuff I'm interfacing with is already a big StateT; and I just needed to add some networking code around it, and it seems to be working fine (though I haven't stress tested it)
18:35:50 <mm_freak> nand`: if you're interfacing with StateT-heavy code you could leave it that way, but it suggests that the other code could have made unfortunate design choices
18:36:55 <nand`> mm_freak: do you think making the rest live in IO and using an MVar s instead of a StateT s everywhere would be an improvement?
18:37:20 <nand`> or possibly a ReaderT (MVar s) for sanity
18:39:15 <mm_freak> nand`: i don't know
18:40:16 <nand`> alright
18:40:24 <nand`> thanks regardless
18:45:11 <kallisti> any idea why cabal would have amnesia?
18:45:24 <kallisti> I try to recompile xmonad, it complains that there's not xmonad-extras
18:45:26 <kallisti> I install that
18:45:27 <kallisti> it recompiles
18:45:31 <kallisti> next time I go to recompile
18:45:32 <kallisti> same problem.
18:48:42 <dmwit> local vs. global?
18:49:20 <dmwit> Give us the output of ghc-pkg list 'xmonad*' and xmonad --recompile
18:50:55 <bradleyayers> why does ghci quote things in `…', rather than the same character?
18:51:16 <dmwit> hmmm?
18:51:37 <bradleyayers> (in error messages)
18:51:43 <dmwit> Oh, you mean why use both ` and ' ?
18:51:48 <bradleyayers> yes
18:51:50 <dmwit> Because that's what they're for. =)
18:52:05 <bradleyayers> so the rest of the world does it wrong?
18:52:21 <dmwit> Neither one is wrong, really.
18:52:36 <bradleyayers> so I should just look up "backtick usage" ?
18:53:01 <dmwit> The thing is that so many people use ' and " as opening quotes that fonts have given up rendering them as closing quotes and moved to rendering them as equally-bad-opening-and-closing-quotes.
18:53:38 <bradleyayers> so is ' suppose to be a *forward tick*
18:53:57 <theorbtwo> Do you have any evidence that ` and ' were designed as an open-close / left-right pair?
18:53:59 <rasfar> i see `...' for often than not in other computer message contexts, but i'm not that fond of it as the ` and ' are invariably asymmetric-looking in my fonts
18:54:27 <dmwit> rasfar: Yes, see my explanation above for why they're asymmetric.
18:54:36 <bradleyayers> from english.stackexchange: "One place this persists is in the typesetting software TeX, where `` is for “, '' is for ”, and " goes unaltered."
18:54:39 <rasfar> oh! with pleasure... :)
18:55:06 <bradleyayers> thanks for the insight
18:55:32 <dmwit> These days it's sort of up to the renderer to turn ' into either a forward or backward tick, as appropriate.
18:55:38 <dmwit> Most renderers don't bother to try.
18:55:50 <rasfar> (don't really see your explanation; ah well)
18:56:26 <dmwit> Not much of an explanation, just that people use ' as opening quotes enough that fonts have to make them open- or close- agnostic.
18:57:43 <ninly> isn't that just an artifact from typewriters?
18:58:47 <ion> Yeah, and ASCII which had a similar goal of conserving as many codepoints as possible.
18:59:55 <dmwit> theorbtwo: To answer your question directly, I suppose I don't have any evidence.
18:59:58 <ion> Using `…' looks just horrible since the former is the accent over a in à and the latter is rendered as a straight line as it’s supposed to approximate both ‘ and ’.
19:01:35 <ninly> yeah, i think ' and " were meant to be symmetrical prior to ASCII. i think the common `...' usage among programmers was sort of foisted on the backtick.
19:01:48 <tgeeky> since I'm in windows, and somehow don't have unicode support, this conversation makes almost no sense to me.
19:02:09 <whittle> I’m new to Haskell, and trying to resolve a bunch of dependency conflicts. Where can I find the dependency information for packages?
19:02:34 <theorbtwo> Sadly, I can't find an image of the original RFC20 to see how the characters are written there (it's handwritten, and was distributed by photocopier and fax).
19:02:43 <theorbtwo> The text is somewhat ambigious, though.
19:02:44 <shachaf> whittle: In the Cabal file.
19:02:51 <theorbtwo> http://tools.ietf.org/html/rfc20
19:02:56 <sbahra> Hi shachaf
19:03:01 <sbahra> Be right back.
19:03:06 <ion> tgeeky: One does not lead to the another.
19:03:14 <shachaf> ...Hi sbahra!
19:04:09 <theorbtwo> ...and that copy seems to be missing appendex A.
19:04:17 <tgeeky> ion: hmm. I mean to say: it looks like people are arguing over: `,``,','',  'a(hat)|' and a(hat)
19:05:16 <whittle> shachaf: Where do I find the Cabal files? Particularly for packages that aren’t installed?
19:05:17 <ion> tgeeky: I mean, running Windows™ shouldn’t result in the lack of Unicode support on IRC. :-)
19:05:26 <shachaf> sbahra: Hi!
19:05:41 <shachaf> whittle: What's failing to install the package?
19:07:19 <hpaste_> whittle pasted “dependency conflicts” at http://hpaste.org/67858
19:08:00 <tgeeky> ion: indeed not. The real breadcrumbs show: Windows 7 -> [cygwin (defaultconfig)-> [irssi]]
19:08:04 <whittle> shachaf: That’s the result of running cabal-dev install from within the project dir of my yesod app.
19:08:09 <ion> tgeeky: MinTTY?
19:08:23 <shachaf> whittle: cabal-dev is getting the .cabal file from Hackage. Presumably you can do the same thing.
19:08:50 <whittle> shachaf: Got it.
19:08:55 <shachaf> You can also "cabal unpack packagename" or look at the .cabal files.
19:08:56 <tgeeky> ion: putty I think. I normally use Console2 with (msg/msys) behind it. Works great for everything else, including msysgit, Haskell, ruby, etc.
19:09:03 <shachaf> They should be somewhere on your disk.
19:09:04 <tgeeky> ion: but my irssi is totally seperate
19:09:22 <whittle> shachaf: Thank you. I’ll keep looking around.
19:09:26 <shachaf> whittle: "cabal info PACKAGENAME"
19:09:36 <ion> tgeeky: http://drupal.org/files/issues/putty-utf8-filenames.png
19:09:57 <whittle> shachaf: Ah-ha! That’s what I’m looking for! Thank you so much.
19:09:57 <tgeeky> ion: kthx, trying
19:11:20 <tgeeky> ion: hah. how about that. suddenly a-hats are not here
19:12:00 <tgeeky> ion++
19:12:01 <tgeeky> ion++
19:12:23 <shachaf> Karma inflation is getting pretty bad.
19:12:46 <shachaf> Remember when a karma point was worth a karma point? Now it's only worth half a point of karma.
19:12:48 <tgeeky> shachaf: you understimate the months of time this has annoyed me, and I have been too lazy to fix it.
19:13:30 <tgeeky> shachaf: I think you don't have to take it seriously until there's a Federal Reserve for Karma.
19:13:35 <ion> shachaf: Perhaps scale karma by the total of everyone’s karma!
19:14:38 <ion> teeky: A private bank from which we all have to borrow our karma and repay it later with interest (which can only be done by borrowing more) sounds great!
19:14:56 <shachaf> You should have to pay karma to increase someone else's karma.
19:15:11 <shachaf> ...And symmetrically you should get karma for decreasing someone else's karma. Or something.
19:15:41 <ion> shubshub is already @karma-’ing people, it will be even more fun when he also *gets* karma for doing that.
19:17:13 <tgeeky> ion: that will lead to karma hoarding, and then Tupac Shakur will give a sermon against usury and the karma hoarders -- the most historically recorded event in Tupac's life -- but in 2000 years all the Shakurians will have all but forgotten about this of Shakur's great lessons.
19:17:47 <tgeeky> or something along those lines.
19:19:45 <tgeeky> ion: this putty fix won't help though because I'm moving to Ubuntu newest tomorrow morning.
19:21:37 <theorbtwo> There we are: http://www.wps.com/J/codes/X3.4-1963/page5.JPG -- ' is described as apos, ` does not exist (lowercase doesn't exist either).
19:22:06 <yan_> i'm trying to use HXT to parse some HTML but it's aboarting on a single quote inside a <script> block.. is there a way i can make HXT ignore contents of those tags?
19:22:58 <shachaf> yan_: I would think that if you're parsing your average "real world" HTML, you'd want some sort of tag soup parser rather than an XML parser. :-)
19:23:22 <yan_> shachaf: fair enough, i can just regex out what i need, but i wanted to apply things consistently
19:24:04 <yan_> shachaf: in reality, i'm writing horrendous haskell right now as it is, so a few more hacks can't hurt heh
19:24:39 * shachaf is fortunate enough never to have needed to parse XML in Haskell.
19:27:10 <hayashi> yay, moving this parser into a purely applicative style has caused the parsing to go severely out of order
19:28:56 <Saizan> yan_: tagsoup on hackage is nice
19:29:24 <copumpkin> my fancy fingertree is proceeding
19:29:51 <shachaf> copumpkin: What's your fancy fingertree?
19:29:52 <hpaste_> copumpkin pasted “fastnub” at http://hpaste.org/67859
19:29:57 <rasfar> I believe HXT uses Tagsoup so you should be alright
19:30:13 <rasfar> (at least it does at your option)
19:30:15 <copumpkin> is there a higher-order way to write that?
19:30:25 <copumpkin> shachaf: the thing for representing an order book
19:30:26 <shachaf> copumpkin: Your fastNub isn't order-preserving. :-(
19:30:38 <copumpkin> shachaf: it isn't?
19:30:42 <c_wraith> looks like it is to me
19:30:47 <copumpkin> that's the whole reason I wrote it
19:30:50 <shachaf> Oh, wait.
19:30:56 <shachaf> I misread it completely.
19:31:05 <dmwit> copumpkin: Why not use a Map b a?
19:31:13 <shachaf> copumpkin++ # fastNub orderPreservation
19:31:19 <c_wraith> that's the standard hypothetical "you could do nub with an Ord constraint" thing
19:31:34 <shachaf> (...It wouldn't be a very good order book if it didn't preserve order!)
19:31:35 <dmwit> Oh, you want order-preservation.
19:31:44 <c_wraith> which is only faster when the number of distinct elements is > O(log length)
19:31:46 <copumpkin> yeah, otherwise I'd just do fromSet . toSet
19:32:45 <dmwit> I think I could do it in a higher-order way with scanl and filter. But it hardly seems worth it.
19:32:59 <dmwit> scanl to get pairs of (element, Set of all the elements so far)
19:33:00 <copumpkin> yeah, I thought of that
19:33:12 <copumpkin> was wondering if there was some mapAccum* that would work
19:33:34 <shachaf> The point of fastNubOn as opposed to fastNubBy is that it only computes f once, I guess?
19:34:08 <copumpkin> I'm not sure this approach is really conducive to a *By binary predicate
19:34:23 <copumpkin> but either way, whenever I see a *By, I typically just do f `on` ...
19:34:26 <shachaf> Oh, because you're using a Set.
19:34:28 <copumpkin> so I might as well use On
19:34:47 <shachaf> Is there a *By equivalent of Data.Set anywhere?
19:34:54 <shachaf> I suppose it would make things like unions tricky.
20:17:04 <Veinor> aw, hackagebot never announced my upload :(
20:17:12 <shachaf> hi hackagebot
20:18:42 * shachaf discount 0.1 - Haskell bindings to the discount Markdown library.  http://hackage.haskell.org/package/discount-0.1 (PatrickHurst)
20:19:10 <copumpkin> Veinor: happy now?
20:19:55 <Veinor> yes :)
20:21:28 <stj> what's the difference between 'when (cond) f' and 'if cond then f else return ()' ?
20:21:39 <rwbarton> @src when
20:21:39 <lambdabot> when p s = if p then s else return ()
20:21:58 <stj> wow, that was fast... thanks :)
20:22:01 <copumpkin> stj: and by referential transparency, there isn't
20:22:09 * copumpkin is tempted to use the pigeonhole principle
20:22:19 <stj> is there a tool that does does the same thing what lambdabot just did?
20:22:22 <Veinor> pigeonhole principle?
20:22:36 <copumpkin> Veinor: I'm used to saying "…and by the pigeonhole principle, X"
20:22:46 <Veinor> ah
20:23:09 <dmwit> stj: You may install lambdabot locally, or read the haddocks online.
20:23:13 <rwbarton> you could http://www.haskell.org/hoogle/?hoogle=when  and then click 'when' and then the source link for the real source, which in this case is the same as lambdabot's @src
20:27:16 <parcs`> @src unless
20:27:17 <lambdabot> unless p s = if p then return () else s
20:27:34 <parcs`> boo, it should be defined in terms of when
20:28:03 <c_wraith> remember, @src isn't authoritative
20:28:15 <c_wraith> it just shows some code with the correct semantics
20:32:27 * hayashi is currently having absolute fun where his applicatives are f (a -> b) and he's trying to plug in another applicative f (c -> a) to make f (c -> b).
20:32:56 <copumpkin> fmap (. ?f)
20:33:03 <shachaf> @ty liftA2 (Prelude..)
20:33:05 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
20:33:18 <hayashi> It's 4am over here and I'm feeling excruciatingly tired, so my brain's gone onto sleep mode and I only have half a clue what I'm doing, so this probably isn't the best time for me to be trying to learn his applicatives =P
20:33:25 <hayashi> ah, liftA2
20:33:34 <copumpkin> oh, I missed the f
20:40:11 <hayashi> urgh, I'm still not exactly following this >_>
20:40:59 <hayashi> where did lambdabot pull that type signature from?  =P
20:41:56 <hayashi> :t liftA2
20:41:57 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
20:42:18 <hayashi> @help @ty
20:42:19 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:42:21 <hayashi> @help ty
20:42:22 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
20:43:26 <hayashi> @ty liftA2 (Prelude..)
20:43:27 <lambdabot> forall b c a (f :: * -> *). (Applicative f) => f (b -> c) -> f (a -> b) -> f (a -> c)
20:43:39 <hayashi> huh.
20:43:44 <copumpkin> on your local one, liftA2 (.) will work too
20:43:50 <copumpkin> but the (.) in lambdabot is more general
20:43:58 <copumpkin> (which means it works too, but has a more obscure type)
20:44:17 <hayashi> Aha
20:45:02 <hayashi> that's where I was going wrong, I wasn't mentally parsing (Prelude..) correctly =P
20:47:54 <hayashi> ...and after all that juggling, my parser still doesn't work!  Joy
20:51:47 <PointFree> Hello. Could anyone help me make the "xs" disappear in this snippet: http://codepad.org/6Ex4Sca1 ?
20:52:31 <dmwit> yes, sure
20:52:44 <dmwit> Why pass an accumulator when you could just start returning things right away?
20:52:53 <rwbarton> why is this a loop instead of a scanl or something
20:53:20 <dmwit> loop _ 0 = [1]; loop i j = x : loop (succ i) (pred j)
20:53:41 <dmwit> whoops, didn't notice how x was computed
20:53:52 <dmwit> anyway, should be able to just pass the one value along instead of the whole list
20:54:05 <dmwit> And yes, I think this should probably be made into an unfoldr or similar.
20:54:20 <PointFree> Okay, let me see.
20:56:00 * hayashi is worried that he now has a situation where reversing the direction of his combinators completely changes whether the code is correct or not
20:56:03 <rwbarton> @type scanl1
20:56:04 <lambdabot> forall a. (a -> a -> a) -> [a] -> [a]
20:56:07 <rwbarton> @type scanl
20:56:08 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
20:56:23 <hayashi> Is it usual, when writing applicative parsing code, to rely on x <**> y having different results from y <*> x?
20:56:37 <hayashi> That just seems like I've done something hilariously wrong
20:56:56 <dmwit> Parsing is very order-sensitive.
20:57:07 <dmwit> :t (<**>)
20:57:08 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f a -> f (a -> b) -> f b
20:57:27 <rwbarton> > scanl (\x (i, j) -> div (x * j) i) 1 $ zip [1..10] [10,9..1]
20:57:28 <lambdabot>   [1,10,45,120,210,252,210,120,45,10,1]
20:57:49 <shachaf> rwbarton++
21:01:48 <PointFree> This is the best that I got.
21:01:51 <PointFree> > let binomial = let { loop _ 0 = id ; loop i j = loop (succ i) (pred j) . liftM2 (:) (flip div i . (j *) . head) id } in flip (loop 1) [1] in binomial 10
21:01:52 <lambdabot>   [1,10,45,120,210,252,210,120,45,10,1]
21:02:22 * hayashi just needlessly turned his ( Parser a -> Parser b )s into Parser ( a -> b )s then found out that that doesn't solve ordering issues
21:02:44 <hayashi> Silly hayashi.
21:10:33 <ezyang> Question for syb experts; given some datatype 'Foo a'; I want to count the number of fields in each constructor which reference the polymorphic variable. Is there an easy way to do this?
21:11:59 <kallisti> yeah it seems like ghc-pkg or cabal prediocally forgets everything that's been installed...
21:12:05 <kallisti> *periodically
21:15:07 <dmwit> More likely there's some versioning things you don't understand.
21:18:03 <rwbarton> unless the period coincides with the period of you upgrading ghc
21:18:18 <rwbarton> well, i suppose that may fall under that category
21:19:02 <kallisti> yep, so
21:19:07 <kallisti> if I cabal install xmonad-extras
21:19:24 <kallisti> it has to reinstall a lot of dependencies that were already installed previously
21:19:31 <kallisti> if I go back and cabal install wx
21:19:48 <kallisti> it ends up reinstall a bunch of dependencies
21:19:54 <kallisti> then I go right back to xmonad-extras and repeat the process.
21:20:14 <kallisti> they're both reinstalling network-2.3
21:20:16 <kallisti> over and over again
21:20:22 <kallisti> what is going on
21:21:12 <dmwit> Show us what cabal install --dry-run wx says.
21:21:16 <dmwit> Same for xmonad-extras.
21:21:41 <kallisti> oh well I have broken packages according to ghc-pkg check
21:22:11 <dmwit> I am becoming more and more certain of my hypothesis the more you tell me.
21:22:47 <kallisti> but what on earth is it?
21:23:10 <dmwit> What on earth is what?
21:23:16 <kallisti> the problem..
21:23:24 <kallisti> how do these packages become broken in such a strange way
21:23:29 <rwbarton> "You're doing it wrong"
21:23:43 <rwbarton> (no I don't know)
21:24:07 <dmwit> Some dependency far up the chain (above network, say) is bouncing back and forth between version 3.7 and 3.6.
21:25:48 <kallisti> I always end up re-installing both network and parsec.
21:26:14 <kallisti> dmwit: why does something "bounce back and forth"
21:26:17 <kallisti> what does that even mean.
21:27:53 <dmwit> How am I supposed to tell you what's wrong if you won't tell me the diagnostics I ask for?
21:28:31 <kulakowski> kallisti: what happens if you try to install both during the same invocation of cabal install?
21:28:51 <kallisti> dmwit: which broken state do you want it in first? :P
21:29:01 <kallisti> bear in mind I'm tinkering around myself and it takes a long time to compile this stuff over and over.
21:29:59 <kallisti> sorry for sounding rude or demanding. I'm tired and frustrating. :P
21:30:15 <kallisti> I think I should sleep before I try to fix this.
21:30:35 <kallisti> kulakowski: I'm currently trying to reinstall everything that was listed as having broken packages all at the same time.
21:31:10 <shachaf> ezyang: Are you sure Data.Data even exposes that information?
21:31:22 <ezyang> Nope!
21:42:04 * hackagebot hoauth2 0.2.0 - hoauth2  http://hackage.haskell.org/package/hoauth2-0.2.0 (HaishengWu)
22:35:20 <xil> hey everyone. I'm looking for a datastructure that does sorted inserts and less than linear removal of the minimum element. And permission of duplicate keys. Is there such a structure?
22:37:29 <wli> xil: Probably one of the heaps.
22:38:32 <shachaf> Probably something like Data.Set would also do.
22:38:51 <xil> wli: do you recommend a particular heap package?
22:39:05 <xil> shachaf: thanks I'll look at it. Never have
22:39:16 <shachaf> @ty S.minView
22:39:17 <lambdabot> forall a. S.Set a -> Maybe (a, S.Set a)
22:39:21 <shachaf> Hmm, how do heaps work in Haskell?
22:39:25 * shachaf should probably know that.
22:39:27 <wli> xil: I'd need to look closer at Data.Set to see if you can avoid the uniqueness issues.
22:39:30 <dmwit> You can just use a list if you don't care about linear insertion.
22:39:39 <dmwit> Otherwise, use one of the many priority queue implementations on Hackage.
22:39:57 <dmwit> (Lists have O(1) minView going for them.)
22:40:30 <xil> dmwit: I prefer non linear insert if I can also have non linear find and delete min, and permission of duplicates
22:40:55 <Veinor> xil: what exactly are you trying to do?
22:41:08 <xil> Veinor: A*
22:42:12 <dmwit> Yeah, those requirements sound sane
22:42:13 <dmwit> .
22:42:23 <wli> xil: PSQueue or priority-queue or pure-priority-queue sound plausible.
22:43:55 <Veinor> PSQueue will get you what you want, yeah
22:44:17 <mysticc> Just wondering at machine level which operation is cheaper .. x+x or x << 1 ..?
22:44:35 <copumpkin> depends on the machine
22:44:51 <copumpkin> chances are you should just write 2 * x and forget about micro-optimizations
22:45:59 <mysticc> copumpkin: Yeah .. I am not going to write micro optimizations .. Just wondering ,,
22:47:37 <Veinor> i think that's highly dependent on what x is
22:48:39 <mysticc> Veinor: Can you give example ?
22:49:41 <Veinor> well, if x is an instance of a type with a Bits and Num instance, and addition is cheap in that instance but it has an expensive bit-shift implementation...
22:49:49 <Veinor> (i can't think of any that have that property offhand)
22:52:01 <mysticc> Veinor: I was not talking about haskell level .. I was talking about machine instruction level ..
22:54:35 <mm_freak> i've had it with de bruijn indices…  ultimate choice: i'm going back to names
22:54:53 <shachaf> mm_freak: I have a strange feeling of déjà vu.
22:55:18 <mm_freak> shachaf: i gave them a last show and have been struggling for hours to figure out a weird type checking bug
22:55:24 <mm_freak> s/show/shot/
22:55:51 <shachaf> Just write code without bugs.
22:56:06 <mm_freak> oh, you're right…  that might do it ;)
22:56:14 <dmwit> Use unbound or whatever that library is.
22:56:52 <wli> I rarely get past the AST manipulation stage of things when I try to do interpreters anyway.
22:57:08 <mm_freak> dmwit: that one looks really useful…  thanks for the hint
22:57:39 <mm_freak> wli: eventually i want to end up with a compiler, not an interpreter…  that's why i'm spending so much time trying various designs
22:57:51 <shachaf> α≍
22:57:56 <shachaf> Hmm, I've never seen that character before.
22:58:02 <shachaf> 0224D   EQUIVALENT TO   [≍]
22:58:27 <rwbarton> That's because no one has ever used it before.
23:01:40 <xil> okay so I think I'm going to go with a heap to avoid having the key and val both be instances of Ord
23:02:07 <shachaf> Key and val?
23:02:10 <shachaf> I thought it was just keys.
23:02:28 <xil> well each datastruct uses different words
23:02:44 <xil> for heap it's priority and item
23:02:51 <xil> for priority queue it's key and priority
23:03:55 <xil> but for the PQ they both have to be instances of Ord. At least for PSQueue
23:04:54 <shachaf> Oh, "priority" being what would elsewhere be called an "index".
23:05:19 <c_wraith> priorities don't need to be consecutive or numerical
23:05:46 <shachaf> Right.
23:06:10 <c_wraith> the main idea of a priority search queue is that you can grab either the minimum (or maximum, depending on implementation) priority element efficiently, as well as search by key efficiently
23:06:25 <wli> Let's see if I can at least fetch lines from haskeline and pipe them through parsec.
23:07:46 <wli> Search by key is not typically part of priority queues. Usually it's enqueueing, dequeueing, determination of the extremal key and its associated record, and optionally priority adjustment of an already-enqueued element.
23:08:06 <c_wraith> wli: right. hence my statement being about priority *search* queues
23:17:43 * wli tries to remember and quickly look up enough of the parsec API to do anything.
23:19:02 <shachaf> wli: I heard Trifecta was the future these days.
23:19:07 <shachaf> preflex: seen edwardk
23:19:07 <preflex>  edwardk was last seen on #haskell-blah 4 days, 7 hours, 31 minutes and 50 seconds ago, saying: http://comonad.com/reader/2008/linear-bloom-filters/
23:19:18 <shachaf> preflex: seen ddarius
23:19:19 <preflex>  ddarius was last seen on #haskell 52 days, 4 hours, 11 minutes and 45 seconds ago, saying: BMeph: No.
23:19:23 <shachaf> I wonder what's with them.
23:20:33 <wli> shachaf: I'm not trying to do anything that advanced, just to sharpen up coding while woken in the middle of the night by health issues.
23:44:31 <xil> anyone know why some datatypes have both a "null" and "isEmpty" function, which seem to do the same?
23:45:32 <Saizan> wanting to fit into conflicting API conventions?
23:46:03 <xil> is there a standard convention for that kind of thing in Haskell overall?
23:49:13 <Saizan> you could look at Data.Map or Data.Set from containers
23:50:32 <ChristianS> xil: usually,  null x  checks whether x is empty, while  empty  creates a new empty thing.
23:50:48 <Saizan> their API has some flaws but as far as naming goes it seems to be standard
23:50:59 <xil> ChristianS: isEmpty
23:51:22 <xil> Saizan: okay, thanks =]
23:51:59 <xil> ChristianS: but yeah, I understand, it's not something well defined
23:52:10 <ChristianS> isEmpty  is probably a naming accident from somebody who has coded too much java ;-)
23:52:50 <xil> ChristianS: haha, good call
23:59:29 <ion> empty? :: [a] -> Bool
23:59:33 <ion> empty :: [a]
