00:31:23 * hackagebot haskell-src-exts 1.13.2 - Manipulating Haskell source: abstract syntax, lexer, parser, and pretty-printer  http://hackage.haskell.org/package/haskell-src-exts-1.13.2 (NiklasBroberg)
00:48:44 <DanielDiaz> @pl f (f (f (f x)))
00:48:45 <lambdabot> f (f (f (f x)))
00:49:24 <donri> @pl \x -> f (f (f (f x)))
00:49:24 <lambdabot> f . f . f . f
00:49:40 <DanielDiaz> @pl \f g (a,b) -> (f a, g b)
00:49:40 <DanielDiaz> @pl \x -> f (f (f (f x)))
00:49:40 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
00:49:40 <lambdabot> f . f . f . f
00:50:30 <merijn> DanielDiaz: For \f g (a, b) -> (f a, g b)
00:50:36 <merijn> you probably want (***)
00:50:58 <merijn> :t (+1) *** not
00:50:59 <lambdabot> forall b. (Num b) => (b, Bool) -> (b, Bool)
00:51:32 <DanielDiaz> yes... I was just testing the bot for first time.
00:52:27 <merijn> lambdabot also responds to private messages if you just want to test
00:52:56 <DanielDiaz> merijn: thanks :)
01:12:58 <liyang> > round (negate 1 / 0 :: Double) :: Int
01:12:59 <lambdabot>   0
01:13:31 <liyang> If you compile that in GHC with at least -O1, you get minBound :: Int instead.
01:13:38 <liyang> Just thought I'd share.
01:16:34 <merijn> :t round
01:16:35 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
01:16:58 <shachaf> liyang: What's wrong with that?
01:17:06 <merijn> (negate 1 /0) returns Infinity and I believe any arithmetic using infinity is undefined in IEEE754
01:17:33 <shachaf> Int overflow is undefined in Haskell, at any rate.
01:20:42 <liyang> merijn: IEEE-754 Infinity is well-defined for some operations; working with NaN OTOH would always give NaN.
01:21:28 <liyang> shachaf: Yup, I think it's reasonable enough. Saw someone else trip over that today though. Was in a sharing mood. :)
01:21:34 <merijn> liyang: I avoid double's like the plague, so I'm never sure :p
01:21:58 <shachaf> liyang: You should be happy it's not _|_!
01:22:03 <shachaf> (Or unhappy, really.)
01:22:04 <liyang> > let infty = 1/0 in negate 1 / infty
01:22:05 <lambdabot>   -0.0
01:22:55 <liyang> shachaf: I'd rather it did return error/undefined… that bug would have presented itself sooner!
01:23:02 <shachaf> Right.
01:23:23 <shachaf> Also Int with these kinds of constraints shouldn't be in the Report at all. :-)
01:23:54 <liyang> merijn: unfortunately in the real world… (also had to teach IEEE-754 at one point.)
01:27:10 <quicksilver> programming languages generically do a terrible job with int overflow
01:27:34 <quicksilver> which seems quite strange to me since CPUs, as far as I know, all contain some sensible way of detecting/responding to it efficiently.
01:28:13 <shachaf> quicksilver: Individual CPUs, yes.
01:28:23 <shachaf> But programming languages are generally meant to be portable across CPUs efficiently.
01:28:44 <liyang> lowest common denominator!
01:28:53 <quicksilver> are you suggesting that int overflow is so non-uniform between CPUS that programming languages couldn't hope to expose anything useful?
01:29:11 <quicksilver> I would have thought at least "did the last addition result in an overflow" or suchlike should be possible
01:29:26 <shachaf> For C, at least, probably.
01:29:32 <quicksilver> it certainly was on the Z80, the 68000, and the 386
01:29:35 <shachaf> C runs on some very strange architectures.
01:29:39 <quicksilver> and frankly, no other CPU matters.
01:30:06 <quicksilver> C runs on some architectures which don't support hardware floating point but that was never used as a reason not to have 'float' and 'double' in the language.
01:30:47 <merijn> Yeah, but you can do those in software
01:31:02 <merijn> You can't detect overflow in software
01:31:11 <quicksilver> you can, actually
01:31:26 <quicksilver> unless you actually don't know the size of your registeres
01:31:29 <quicksilver> which seems a bit odd
01:31:36 <quicksilver> you just check the high bits of both operands before the add.
01:31:49 <Chipmonkpyro> hey, whats the function to switch the arguments in a function with two arguments?
01:31:58 <merijn> :t flip
01:31:58 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
01:32:02 <Chipmonkpyro> thanks
01:32:08 <merijn> Well that's a confusing signature
01:32:14 <merijn> :t Prelude.flip
01:32:15 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:34:40 <liyang> TI's TMS320 series DSPs was the oddest one I had to work with. There a C char is 16-bit.
01:35:53 <merijn> liyang: Nice, a colleague worked with a platform where C chars where 32-bit
01:42:53 <osa1_> I'm trying to write a simple compiler with haskell, I'm parsing source language with Parsec, but I couldn't find any libraries to help code creation for creating the code in target language, can anyone help me? what are some common idioms to do that? I'm trying to compile a human-readable code(with correnct indentations etc.)
01:43:46 <charl> null
01:43:47 <merijn> osa1_: What is your target language?
01:44:33 <merijn> (Or your input language, for that matter)
01:45:47 <osa1_> merijn: my input language is a Lisp-like language that I've created, and target language is going to be ANSI C, btw this project is mostly for learning purposes
01:46:41 <merijn> You probably want to translate your Lisp AST into a C AST (or some intermediate AST) and then generate code from there
01:47:03 <quicksilver> there is a haskell library called Language.C, osa1_, which is among other things can generate C
01:47:18 <quicksilver> to be honest I think you might be best off doing it by hand, at least to start with.
01:47:55 <quicksilver> Language.C is large and fiddly, and contains a lot of things which are hard to comprehend if you haven't first spent some time trying to do it yourself and starting to recognise the issues involved.
01:48:11 <merijn> Especially when its for learning purposes then doing it by hand will likely be easier and more educational
01:48:37 <charl> it should be inherently informational
01:48:43 <charl> like this console
01:48:52 <charl> and you guys
01:48:53 <charl> :)
01:49:41 <osa1_> quicksilver, merijn: hmm, actually that was what I was thinking but I still wanted to see some examples to get some ideas.
01:50:01 <quicksilver> osa1_: well, http://hackage.haskell.org/package/language-c :)
01:50:02 <osa1_> I never worked on AST's, do you know any good reads about this stuff?
01:50:07 <osa1_> quicksilver: yes, thanks.
01:50:19 <quicksilver> people like the dragon book
01:50:28 <quicksilver> not sure if it's in print ... :(
01:50:33 <merijn> The dragon book is a bit heavy weight, isn't it?
01:50:40 <quicksilver> indeed.
01:50:57 <merijn> osa1_: Well, presumably you already have an AST for the Lisp you've parsed, right?
01:51:00 <quicksilver> I don't think there is a "Learn You An Abstract Syntax Tree For Light-Heared Joys"
01:51:11 <quicksilver> maybe there is a market there.
01:51:21 <shachaf> What is there to learn about ASTs?
01:51:24 <merijn> Start by creating a mapping between a minimal subset of your Lisp AST and a stripped C?
01:51:27 <shachaf> It's just a tree. Of your syntax.
01:51:38 <quicksilver> shachaf: also, it's abstract.
01:51:38 <merijn> For example just top level variables and functions
01:51:50 <quicksilver> osa1_: dragon book FWIW : http://en.wikipedia.org/wiki/Compilers:_Principles,_Techniques,_and_Tools
01:51:53 <shachaf> quicksilver: It's not even abstract!
01:52:05 <shachaf> It ought to be called a concrete syntax tree.
01:52:25 <quicksilver> shachaf: it (almost always) abstracts out certain details of the concrete syntax, like binary operator precedence and whitespace
01:52:35 <quicksilver> shachaf: that's what the word abstract is referring to
01:52:36 <quicksilver> (AFAIK)
01:52:49 <shachaf> Ah.
01:52:57 <shachaf> Well, OK.
01:53:02 <shachaf> Semi-concrete syntax tree.
01:53:16 <quicksilver> pebbledash syntax tree?
01:53:30 <shachaf> Asphalt syntax tree?
02:07:21 <hpaste_> merijn pasted “Canonical style?” at http://hpaste.org/67196
02:07:30 <merijn> Which is the preferred style?
02:08:38 <shachaf> merijn: Preferred style is probably something like "bracket". :-)
02:09:18 <hpaste_> mekeor annotated “Canonical style?” with “Canonical style? (annotation)” at http://hpaste.org/67196#a67197
02:09:21 <merijn> :t bracket
02:09:22 <lambdabot> Not in scope: `bracket'
02:09:25 <shachaf> @ty IO.bracket
02:09:26 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
02:09:54 <shachaf> bracket ... (... closeStream output(?)) $ \field -> ...
02:10:31 <merijn> shachaf: Yeah, horrible misuse of type aliases :p
02:11:04 <quicksilver> merijn: I personally don't see any value in naming and separating "helper"
02:11:17 <quicksilver> merijn: I think the anonymous function/do block is nicer.
02:11:46 <shachaf> There would be slightly more value to it if it had a better name than "helper".
02:12:13 <quicksilver> in general I wouldn't separate and naming something used only once. I'd separate an name things used multiple times (especially over multiple guards or code paths, etc)
02:12:40 <shachaf> quicksilver: Naming is often valuable for things that are only used once.
02:13:15 <quicksilver> well note that I said "in general" while you're saying "often".
02:13:17 <merijn> shachaf: True, but I can't think of any name for this except maybe "work" or something equally unhelpful
02:13:27 <quicksilver> so, those are hardly in opposition.
02:13:40 <merijn> I don't think bracket is likely to help here, though
02:13:58 <merijn> At least, any rewriting using bracket seems less readable
02:14:00 <cheater__> relating your constructs to language is often a good way to validate if they make sense at all.
02:14:13 <shachaf> Maybe write a function like bracket for your use case.
02:14:17 <quicksilver> but my experience of code pasted in this channel is that people name useless little things too often when an anonymous function or action is more readble :)
02:14:19 <merijn> As there is no real "open" action
02:14:28 <cheater__> on the other hand, it's also a way to make invalid connotations.
02:14:30 <merijn> shachaf: That's pretty much what boxLoop is already doing
02:14:32 <shachaf> merijn: I.e., something that takes a function like "helper", and abstract *that*.
02:14:37 <cheater__> such as calling an exception an error, or something like that.
02:14:45 <shachaf> Eh, maybe.
02:14:56 <shachaf> Except it's doing it backwards or something. :-)
02:15:28 <merijn> I originally had boxLoop also take the termination code (i.e. closeStream) but when I had some thing with multi line cleanup steps I figured I'd be better of just appending them after the return of boxLoop
02:22:13 <mekeor> > optional ""
02:22:14 <lambdabot>   [Nothing]
02:22:35 <mekeor> > optional $ return []
02:22:36 <lambdabot>   No instance for (GHC.Show.Show (f (Data.Maybe.Maybe [a])))
02:22:36 <lambdabot>    arising from ...
02:22:48 <mekeor> > optional $ (return [] :: IO [Integer])
02:22:49 <lambdabot>   No instance for (Control.Applicative.Alternative GHC.Types.IO)
02:22:49 <lambdabot>    arising f...
02:23:08 <srhb> f...
02:27:48 <merijn> @undo do { val <- foo $ \x -> do { bar; return x}}
02:27:49 <lambdabot>  Parse error at "}" (column 44)
02:27:58 <merijn> @undo do { val <- foo $ (\x -> do { bar; return x})}
02:27:58 <lambdabot>  Parse error at "}" (column 46)
02:28:28 <merijn> @undo do { val <- foo $ return }
02:28:28 <lambdabot>  Parse error at "}" (column 26)
02:29:42 <merijn> Why is that not parsing?
02:30:18 <quicksilver> merijn: do expressions must end with a simple expression
02:30:31 <quicksilver> @undo do { val <- foo $ return; return val }
02:30:32 <lambdabot> foo $ return >>= \ val -> return val
02:30:49 <merijn> oh, duh
02:30:57 <merijn> @undo do { val <- foo $ \x -> do { bar; return x}; return val}
02:30:57 <lambdabot> foo $ \ x -> bar >> return x >>= \ val -> return val
02:31:35 <merijn> That probably doesn't parse as I want it to, by the looks of it
02:32:21 <merijn> @undo do { val <- foo \x -> do { bar; return x}; return val}
02:32:21 <lambdabot>  Parse error at "\x" (column 17)
02:32:28 <merijn> @undo do { val <- foo (\x -> do { bar; return x}); return val}
02:32:28 <lambdabot> foo (\ x -> bar >> return x) >>= \ val -> return val
02:33:51 <edsko> @pl \x -> x
02:33:52 <lambdabot> id
02:34:16 <quicksilver> @. pl undo do { val <- foo (\x -> do { bar; return x}); return val}
02:34:16 <lambdabot> foo ((bar >>) . return)
02:34:26 <edsko> @pl \f g a b -> f (g a) (g b)
02:34:26 <lambdabot> join . ((flip . ((.) .)) .) . (.)
02:34:44 <edsko> @pl \f g -> \a b -> f (g a) (g b)
02:34:44 <lambdabot> join . ((flip . ((.) .)) .) . (.)
02:36:41 <colock> status of llvm support for ghc? something worth trying?
02:45:37 <Chipmonkpyro> can anyone think of any good ways to switch an [a] of length n*n to an [[a]] of length n containing arrays of length n?
02:47:03 <gdeest> Chipmonkpyro: so, turning [1,2,3,4] into [[1,2],[3,4]] is that it ?
02:47:11 <Chipmonkpyro> yes
02:51:36 <gdeest> well, "take" and "drop" might help, here
02:52:11 <mekeor> or rather splitAt and uncurry
02:52:55 <quicksilver> Chipmonkpyro: I recomment groupsOf n = takeWhile (not.null) . map (take n) . iterate (drop n)
02:53:16 <quicksilver> (partly because I think that's a pretty good example of haskell list processing functions)
02:53:23 <quicksilver> it's not in the standard library
02:53:36 <quicksilver> although Data.List.Split has something functionally equivalent.
02:53:48 <quicksilver> (which is in a hackage package)
02:55:00 <Chipmonkpyro> thanks, works great
03:09:01 <dcoutts> blackdog: (currently) cabal build will rebuild the test binary, cabal test just runs them
03:10:49 <Zedrikov> Assume I have one very big module hiding some definitions, and I want to split it in many modules, so that all modules have access to the hidden definitions, how can I do that?
03:10:49 <lambdabot> Zedrikov: You have 1 new message. '/msg lambdabot @messages' to read it.
03:11:22 <quicksilver> Zedrikov: put them in an 'Internal' module which exports everything, but which is only used by your own modules.
03:13:13 <Zedrikov> But if the modules have cross references, or at least refer to a same datatype defined in a module, and that this datatype is meant to be abstract for the user, I don't know how to do it.
03:13:37 <quicksilver> Zedrikov: I don't understand your remark.
03:13:53 <quicksilver> Zedrikov: how does the 'Internal' module not solve it?
03:16:18 <Zedrikov> I have a module A which defines a datatype T and make it abstract, and a whole bunch of functions using it, that I want to split in many modules. Each module must know the internal representation of T, but T must remain abstract. How can I do that ?
03:16:38 <relation> is there a simple way to show Dynamic's value insted of <<Int>> ? for example in: print $ toDyn (10::Int)
03:16:54 <Cale> relation: fromDyn it back?
03:17:10 <tdammers> Zedrikov: some module re-exporting magic maybe?
03:17:20 <relation> Cale: that will work, but then i have also to specify its type
03:17:51 <shachaf> Zedrikov: As long as the user doesn't import .Internal, it should be fine, shouldn't it?
03:18:06 <Cale> Since Typeable doesn't imply Show, it's hard to show an arbitrary Dynamic value any better than that.
03:18:21 <Zedrikov> tdammers: maybe, how do you do that?
03:18:32 <Cale> (for more than a handful of types)
03:19:45 <relation> Cale: ok, few types will be sufficient, i try to do it for them.. i will use something like DynamicShow a typeclass, that should work
03:19:53 <Zedrikov> shachaf: not really, the type T must be known to the user, but not its constructors, so the many files have to say they use the abstract type T but use its concrete representation
03:20:48 <relation> Cale: not a type class, but case of different types, i've got it now
03:20:52 <Cale> relation: If you know all the types up front, you could do a bunch of fromDynamics
03:20:53 <Cale> yeah
03:20:58 <Cale> pattern guards might help
03:21:06 <Cale> (to chain them)
03:21:35 <shachaf> Zedrikov: You can export a type without exporting its constructors.
03:21:36 <relation> Cale: thanks
03:21:47 <shachaf> Just reëxport T from non-.Internal modules.
03:22:32 <Zedrikov> So all modules must reexport the type T, even if it is intended to be the same?
03:23:02 <shachaf> Zedrikov: No, it *is* the same.
03:25:08 <tdammers> Zedrikov: pretty much what everyone is telling you.
03:25:47 <Zedrikov> I will experiment, and maybe put a pastebin to be more clear, if I fail.
03:26:15 <merijn> @pl let foo = undefined in \x -> maybe (return ()) foo x
03:26:15 <lambdabot> maybe (return ()) undefined
03:26:33 <reinoud> @hoogle SVD
03:26:34 <lambdabot> No results found
03:28:49 <relation> Cale: just wanted to say that pattern guard solution worked like a charm, thanks!
03:31:40 <quicksilver> Zedrikov: well the modules don't all have to if you don't want them to - just one has to.
03:32:06 <quicksilver> so you can pick one core interface to expose the types
03:32:17 <quicksilver> but it might make life simpler if they all do, and it's not hard to do so
03:34:10 <Zedrikov> Ok, in fact I did the things almost well before asking on the list. I just did a dummy mistake which has nothing to do with my problem, and thought it was due to the feature I was wanting to experiment.
03:35:47 <quicksilver> it gets annoying if you have recursive dependencies between your sub-modules
03:36:01 <quicksilver> because although haskell supports them, GHC makes you jump through hoops.
03:36:24 <quicksilver> mind you I still maintain that mutual dependencies are code smell, but others disagree :)
03:37:15 <Zedrikov> What do you mean by "code smell" (I am french, so I do not understand all idiomatic expressions)
03:38:42 <merijn> Zedrikov: A bad sign
03:39:05 <merijn> Zedrikov: Something that is not necessarily a problem, but usually indicates one
03:39:23 <hpaste_> JF pasted “my_test” at http://hpaste.org/67203
03:46:40 <mekeor> is it correct that continued-passing style mainly makes sense if you have a function returning a tuple, right?
03:47:12 <edwardk> its definitely useful for those cases, but also when you may want to reinvoke that continuation with different arguments
03:47:23 <Cale> mekeor: No, you can translate multiple constructors into separate continuation parameters
03:48:57 <mekeor> edwardk: how do you mean? what different arguments?
03:49:29 <Cale> e.g. if you have a function  f :: ... -> Either String Integer,  you can turn that into  f' :: ... -> (String -> c) -> (Integer -> c) -> c
03:49:44 <mekeor> Cale: yea, that's true.
03:50:09 <mekeor> Cale: so, i should replace "tuple" with "functor" or so, right?
03:51:01 <Cale> Well, I'm not sure if just fmap is enough, but results in an algebraic datatype seem like they should translate well enough.
03:51:41 <srhb> I'm wondering what my thought process ought to be when analyzing this snake game I made: I have a function advance world = morecheese . speedup . eat . die . move $ world, where world is a data type that has everywthing: The walls, the snakes, the cheeses, the move speed.. And my question is: Py "piping" world through these functions, am I creating a bit too much of data? How do I decide? How do I analyze the costs?
03:52:01 <srhb> (It just feels really neat to do it like that!)
03:52:14 <Cale> srhb: use the GHC profiler
03:52:31 <Cale> But compositions tend not to be problematic
03:52:44 <Cale> (on their own)
03:52:51 <merijn> It never occurred to me to implement the main loop that way...
03:52:57 <merijn> Neat
03:53:16 <srhb> It certainly feels very neat, and I can plug in new elements in a nice fashion.
03:53:29 <srhb> The data type is entirely pure, so I think there ought to be no nasty surprises.
03:53:45 <tdammers> I use pretty much the same approach for my sheet music processor
03:54:04 <luite> tdammers: including morecheese?
03:54:04 <srhb> Hm, wait, it isn't.. Gloss is fooling me.
03:54:11 <tdammers> no cheese, no...
03:54:14 <adamt> what would the type signature of the following function be? foo = return ()
03:54:15 <luite> aw :(
03:54:17 <tdammers> but the general principle is the same
03:54:34 <tdammers> I might add cheese later.
03:54:38 <srhb> :-)
03:55:10 <luite> adamt: Monad m => m ()
03:55:11 <srhb> adamt: m ()
03:55:16 <quicksilver> more cheese improves everything, sheet music is no exception.
03:55:31 <tdammers> true.
03:55:35 <Tinned_Tuna> quicksilver: I have to say, you got a point.
03:55:42 <tdammers> I just need to figure out a way to deal with the holes.
03:55:53 <tdammers> Maybe melt it.
03:56:25 <srhb> I wonder what my concerns should be about morecheese really, I do have an ugly unsafePerformIO to generate random cheeses.. I suppose I could pipe my world in a different fashion even if I make it an IO world, but it seems.. Worse. :P
03:56:32 <srhb> But of course, I'm only fooling myself right now.
03:57:05 <quicksilver> srhb: you should include a random seed in your 'world'
03:57:07 <tdammers> you could add a pure RNG to your world and update it along with the rest of the world
03:57:17 <quicksilver> and morecheese can use (and update) that seed
03:57:22 <adamt> Thanks.
03:57:26 <srhb> But if it's pure I'll just get the same ones, won't I?
03:57:29 <srhb> every time.
03:57:46 <tdammers> that's why you update it with the new RNG state after you've generated a cheese
03:57:48 <merijn> srhb: Not if you depend on a seed which you pass to the initial world
03:58:03 <srhb> Oh. Really? I thought IO would infect the entire world then. Shouldn't it?
03:58:23 <merijn> :t mkStdGen
03:58:24 <lambdabot> Int -> StdGen
03:58:29 <merijn> Pure
03:58:37 <srhb> Yes, but if the Int is the same, won't the numbers be the same?
03:58:56 <merijn> Yes, but you have a main calling your pure code, no?
03:59:05 <srhb> Oh, yes, of course.
03:59:10 <merijn> Just have main generate one int (in IO) and pass it to the main loop
03:59:18 <merijn> And then your pure loop stays pure
03:59:20 <srhb> Ah, so obvious..
03:59:25 <srhb> :-)
04:00:19 <tdammers> as an alternative, you could generate an infinite lazy list of random numbers in IO and pass that into your world
04:00:25 <Aufwind> Excuse me, I am doing the tryhaskell online tutorial an I am see in some syntax I don't get in the pattern matching part: let abc@(a,b,c) = (10, 20, 30) in (abc,a,b,c) What is the @ doing?
04:00:40 <merijn> Aufwind: An alias
04:00:41 <tdammers> and then in your pure loop, you can do things like
04:00:44 <quicksilver> Aufwind: if you try it, it's fairly obvious :)
04:00:57 <quicksilver> > let abc@(a,b,c) = (10,20,30) in (abc,a,b,c)
04:00:58 <lambdabot>   ((10,20,30),10,20,30)
04:01:17 <quicksilver> so abc gets the whole (10,20,30) thing, and a b and c get the components separately.
04:01:31 <tdammers> (randomNumber, newWorld) = (head $ randomNumbers world, world { randomNumbers = tail (randomNumbers world) })
04:01:40 <mekeor> srhb: see also 'next'.
04:01:42 <mekeor> @hoogle next
04:01:43 <lambdabot> System.Posix.DynamicLinker.Prim Next :: DL
04:01:43 <lambdabot> System.Random next :: RandomGen g => g -> (Int, g)
04:01:43 <lambdabot> System.Posix.DynamicLinker.Prim haveRtldNext :: Bool
04:01:47 <Aufwind> quicksilver: Ah ok, now I understand. I tried it in the online interpreter, but I didn't understand it Thank you!
04:02:10 <tdammers> but I guess using a pure RNG directly would be more elegant
04:02:30 <quicksilver> tdammers: well it's more flexible, in case you ever want something other than an Integer
04:02:39 <quicksilver> tdammers: (since the RNG knows how to generate other types too)
04:02:51 <tdammers> yeah
04:02:51 <quicksilver> tdammers: it's not *really* different, though
04:02:54 <tdammers> I know
04:03:10 <tdammers> it does encapsulate the RNG stuff inside the RNG though, which is kind of nice, maintenance-wise
04:03:35 <mbuf> if I have data like "1:10", "1:20", "1:30", "2:15", "2:25", how would I compute the sums for 1, and 2? I need to get total for 1 = 60 and total for 2 = 40
04:03:35 <lambdabot> mbuf: You have 1 new message. '/msg lambdabot @messages' to read it.
04:04:11 <mekeor> mbuf: so, it's a [String], isn't it?
04:04:20 <mbuf> mekeor: yes
04:04:36 <mbuf> mekeor: for example, I have given it as 1, but, it can be 3, 4, 5 etc.
04:05:13 <mekeor> > let f = sum . map (read . takeWhile (/=':')) in f ["1:2","2:1234","5:9"] :: Integer
04:05:15 <lambdabot>   8
04:06:02 <mekeor> i'm not sure whether i understood correctly though. so, this is 1+2+5.
04:06:26 <mbuf> mekeor: here I must get, total of 1 is 2, total of 2 is 1234 and total of 5 is 9
04:06:46 <quicksilver> mbuf: approach it as two problems.
04:06:48 <mbuf> mekeor: 1, 2, and 5 are of one type, and the value is on the right
04:06:56 <quicksilver> (1) parse the :-strings into numbers, probably pairs
04:07:02 <Rudi> hey guys
04:07:03 <quicksilver> (2) sum it.
04:07:03 <mbuf> quicksilver: hey!
04:07:08 <Philonous> Is it normal for a large amount of literal Text to take ages to compile?
04:07:14 <mbuf> quicksilver: I see
04:07:14 <quicksilver> the second part is really quite easy with groupBy
04:07:25 <mekeor> mbuf: use span
04:07:30 <mekeor> @type span
04:07:30 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:07:36 <mbuf> mekeor: quicksilver will try, thanks!
04:07:42 <Rudi> I was wondering, if you had a list and you wanted to map a certain function to even numbers only and map a certain function to the odd numbers in the list
04:07:45 <quicksilver> > groupBy ((==)`on`fst) [(1,10),(1,20),(1,30),(2,15),(2,25)]
04:07:46 <lambdabot>   [[(1,10),(1,20),(1,30)],[(2,15),(2,25)]]
04:07:57 <mekeor> @type break
04:07:57 <Rudi> can I use a single map?
04:07:57 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
04:08:09 <Rudi> or use predicates?
04:08:37 <mbuf> quicksilver: nice!
04:08:48 <Rudi> say i had the list [1,2,3,4,5], I want to only use map to square the even numbers and double the odd numbers. Not sure how i'd go around that
04:08:52 <quicksilver> > map (\xs -> (fst (head xs),sum . map snd $ xs)) . groupBy ((==)`on`fst) $ [(1,10),(1,20),(1,30),(2,15),(2,25)]
04:08:54 <lambdabot>   [(1,60),(2,40)]
04:09:28 <mm_freak> Rudi: the best way is to combine two component lists into a larger list
04:09:38 <mm_freak> if that's not possible you can always use a conditional mapping function
04:10:00 <mm_freak> > map (\x -> if even x then (^2) else (2*) $ x) [1..5]
04:10:01 <lambdabot>   No instance for (GHC.Real.Integral (a -> a))
04:10:01 <lambdabot>    arising from a use of `e_12...
04:10:16 <Rudi> so you can actually use predicates within a map?
04:10:17 <mm_freak> > map (\x -> (if even x then (^2) else (2*)) x) [1..5]
04:10:18 <lambdabot>   [2,4,6,16,10]
04:10:38 <mekeor> Rudi: of course, yes.
04:10:43 <quicksilver> Rudi:  you can use anything there, it's a completely general haskell function.
04:10:51 <quicksilver> which is very handy.
04:10:54 <Rudi> wow
04:11:06 <Rudi> Thank you guys so much. That makes sense
04:11:07 <mekeor> quicksilver: well. guards?!
04:11:29 <mm_freak> Rudi: there are very few special cases in haskell…  it would be stupid not to allow that
04:11:44 <Rudi> Thanks man :)
04:11:49 <mm_freak> haskell is a very simple language…  whenever something makes sense, it's probably possible to write
04:11:50 <Rudi> Amazing channel, definitely staying here
04:11:58 <mekeor> :)
04:12:08 <shachaf> mm_freak: Does the function f x y = x (x y) make sense?!
04:12:09 <quicksilver> mekeor: it's a completely general function. Guards are a syntax for pattern matches. There are a variation of ways that pattern matches can end up inside functions.
04:12:25 <mm_freak> shachaf: let's see
04:12:31 <mm_freak> :t \x y -> x (x y)
04:12:32 <quicksilver> mekeor: for example, case expressions, lets, and wheres.
04:12:32 <lambdabot> forall t. (t -> t) -> t -> t
04:12:36 <mm_freak> yes, it does make sense
04:12:49 <shachaf> mm_freak: Does writing Just (Just "hi") make sense?
04:12:58 <mm_freak> yes
04:13:02 <shachaf> > let f x y = x (x y) in f Just "hi"
04:13:03 <lambdabot>   Occurs check: cannot construct the infinite type:
04:13:03 <lambdabot>    t = Data.Maybe.Maybe t
04:13:04 <mekeor> quicksilver: alright
04:13:29 <mm_freak> shachaf: the combination doesn't make sense
04:13:31 <mekeor> > join $ Just $ Just "foo"
04:13:32 <lambdabot>   Just "foo"
04:13:35 <Rudi> so when you have (^2), that's basically a function right?
04:13:44 <Axman6> Rudi: yes
04:13:49 <mekeor> @type (^2)
04:13:49 <lambdabot> forall a. (Num a) => a -> a
04:13:51 <Axman6> @src (^)
04:13:51 <lambdabot> x ^ 0            =  1
04:13:51 <lambdabot> x ^ n | n > 0    =  f x (n-1) x
04:13:51 <lambdabot>   where f _ 0 y = y
04:13:51 <lambdabot>         f x n y = g x n
04:13:52 <lambdabot>           where g x n | even n  = g (x*x) (n `quot` 2)
04:13:53 <lambdabot>                       | otherwise = f x (n-1) (x*y)
04:13:56 <lambdabot> _ ^ _            = error "Prelude.^: negative exponent"
04:13:56 <mm_freak> shachaf: it would make sense in an untyped/dynamically typed language
04:14:01 <Axman6> it's a function that's been partially applied
04:14:35 <mm_freak> shachaf: also i can totally make this work with an explicit type signature and a language extension
04:14:40 <quicksilver> mm_freak, shachaf : and it would make sense in a language supporting higher rank types.
04:14:51 <shachaf> > let f :: forall a m. (forall a. a -> m a) -> a -> m (m a); f x y = x (x y) in f Just "hi"
04:14:51 <lambdabot>   Just (Just "hi")
04:14:53 <Philonous> Wow, a list with 1300 Text entries takes 46 seconds to compile, and uses roughly a GB of Memory, the same List as String take merely 2seconds and an negligible amount of RAM
04:14:57 <quicksilver> but I think shachaf is (a) using the platonic method or (b) trolling mildly or (c) a bit of both ;)
04:15:28 <mm_freak> hehe
04:15:55 <shachaf> quicksilver: I'm also mildly irritated.
04:16:19 <shachaf> > let f :: forall a m. (forall a. m a -> a) -> m (m a) -> a; f x y = x (x y) in f head [["hi"]]
04:16:19 <reinoud> is there a haskell routine for Singular Value Decomposition ?
04:16:20 <lambdabot>   "hi"
04:16:23 <cwl> @src fix
04:16:23 <lambdabot> fix f = let x = f x in x
04:16:59 <quicksilver> shachaf: mildly platonic, mildly trolling and mildly irritating?
04:16:59 <Philonous> Oh, only with OverloadedStrings. mapping Text.pack over the list of strings makes compile even faster !?!
04:17:01 <cwl> fix (\x -> x^2)
04:17:09 <cwl> > fix (\x -> x^2)
04:17:11 <reinoud> @hoogle lapack
04:17:11 <lambdabot> No results found
04:17:13 <lambdabot>   mueval-core: Time limit exceeded
04:17:20 <quicksilver> shachaf: sounds rather English, can I perhaps offer you a pint of mild and a packet of crisps?
04:17:24 <int-e> > error "can't fix: not broken"
04:17:25 <lambdabot>   *Exception: can't fix: not broken
04:17:30 <Zedrikov> how to ask lambdabot what are his functionnalities without polluting the chat?
04:17:43 <cwl> > fix (\x -> x+x)
04:17:47 <lambdabot>   mueval-core: Time limit exceeded
04:17:50 <quicksilver> Zedrikov: everything he does in #haskell he should also do in private message.
04:18:05 <quicksilver> Zedrikov: (except, weirdly, the ':t' shortcut, in private message you have to use '@type')
04:18:19 <Zedrikov> thanks
04:18:22 <reinoud> Numeric.LinearAlgebra.Algorithms?
04:18:34 <lambdabot> correct: everything except :t i also do in private message.
04:18:51 <bitonic> it's alive!
04:20:19 <shachaf> quicksilver: My complaint is that "f" can't be polymorphic.
04:20:23 <shachaf> Polly want a morphism!
04:21:38 <quicksilver> shachaf: is your complaint that type inference for higher rank types is not confluent and intractable?
04:21:51 <quicksilver> shachaf: I'm not sure where to direct that complaint, do you have a deity you respect?
04:22:18 <shachaf> quicksilver: I don't care about inference; I just want a function f that works for all three cases.
04:22:52 <quicksilver> are polykinds enough for that?
04:23:20 <quicksilver> I would have thought they would be but am not thinking clearly right now.
04:23:49 <shachaf> PolyKinds? Why?
04:23:59 <shachaf> (I, neither, am thinking clearly right now.)
04:25:31 <quicksilver> shachaf: no, you need quantification over type functions.
04:26:24 * shachaf goes to sleep.
04:26:25 <quicksilver> forall F :: TypeFun . (forall a . a -> F@a) -> a -> F@F@a
04:26:40 <shachaf> quicksilver: Well, sure, if you had an arbitrary type function.
04:26:55 <quicksilver> right
04:26:55 <shachaf> Anyway, /me sleep
04:26:58 <quicksilver> 'night
04:27:13 <mbuf> with GHC 7.0.2 for groupBy ((==) `on` fst) $ [(1,10),(1,20),(1,30),(2,15),(2,25)], I get "Not in scope: `on'"
04:27:27 <mbuf> but groupBy (\x y -> fst x == fst y) $ [(1,10),(1,20),(1,30),(2,15),(2,25)] works
04:27:32 <Axman6> you need to import Data.Function
04:27:48 <mbuf> Axman6: ahh! thanks
04:27:53 <Rudi> how can I test ZF expressions using the bot?
04:29:53 <rasfar> aren't those list comprehensions?
04:31:49 <hpaste_> identity_ pasted “Inefficient Trie implementation” at http://hpaste.org/67205
04:31:56 <identity1> Anyone care to take a look?
04:32:13 <identity1> It's much more inefficient than I'd hoped.
04:32:32 <identity1> The dict is about .. 24k words or so, and even on 1000 words there is a noticeable delay
04:37:15 <Axman6> so many brackets...
04:38:37 <identity1> Are you talkingabout the code or the Show representation of the trie?
04:38:42 <identity1> If the latter, then yes :|
04:39:10 <mbuf> how can I use the gzip quote file from http://code.haskell.org/lambdabot/State/quote with my own IRC bot from http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot?
04:39:36 <Axman6> identity1: the code
04:39:43 <siracusa> identity1: I guess it would be more efficent if you would use Data.Map for the subtrees, not a list
04:39:45 <identity1> Then :(
04:39:58 <identity1> siracusa: Hmm, good idea
04:41:48 <Rudi> another quick question, can you have conditions using foldr?
04:42:00 <Rudi> so for example, foldr (+) 0 [1,2,3,4,5]
04:42:08 <quicksilver> the answer is probably yes but I'm not quite sure what the question is
04:42:10 <Rudi> but I want to only add up certain elements (odd or even maybe?)
04:42:20 <gdeest> Ahum, filter ?
04:42:25 <quicksilver> it would be simpler to filter first
04:42:26 <merijn> > foldr (+) 0 . filter odd [1..5]
04:42:27 <lambdabot>   No instance for (GHC.Real.Integral [a])
04:42:27 <lambdabot>    arising from a use of `e_1015' a...
04:42:38 <quicksilver> but quite possible to alter the foldr directly
04:42:42 <quicksilver> if you really wanted to
04:42:47 <Rudi> ah, i thought foldr itself can filter
04:42:48 <merijn> > foldr (+) 0 . filter odd $ [1..5]
04:42:49 <lambdabot>   9
04:42:53 <quicksilver> Rudi: it can.
04:42:58 <quicksilver> you can write filter as a foldr if you want.
04:43:00 <Axman6> > foldl (\acc x -> if odd x then acc+x else acc) 0 [1..10]
04:43:01 <lambdabot>   25
04:43:17 <merijn> It's just much more convenient to filter separately from the fold step :p
04:43:33 <quicksilver> > foldr (\x acc -> acc + (if odd x then x else 0)) 0 [1..5]
04:43:33 <lambdabot>   9
04:44:13 <quicksilver> GHC has a specific set of optimisations called 'list fusion' which are designed to mean writing the filter separately is just as efficient
04:44:22 <chu> Axman6: ping
04:44:23 <quicksilver> (it gets automatically 'fused' into the foldr)
04:44:29 <Axman6> o/
04:45:12 <chu> Anything yet? :p
04:45:47 <Axman6> a bit, talked to Uwe today about it. planning on spending more time tomorrow on it
04:46:33 <chu> Do we get the spec shortly?
04:47:34 <Axman6> an initial version anyway. missing some stuff on testing currently
04:48:03 <chu> Sweet, is it dodgey of me to ask you to send me a copy now? :p
04:48:43 <Axman6> yes ;)
04:48:57 <mbuf> @quote haskell
04:48:57 <lambdabot> haskell says: "a programming language"
04:48:59 <Axman6> i didn't actually realise you were taking the course, is it just for funsies?
04:49:16 <Axman6> aren't you a CS kid?
04:49:32 <chu> I'm a philosophy student.
04:50:10 <Axman6> huh.
04:51:18 <Axman6> what're you doing at the CSIT building all the time then? :P
04:51:38 <chu> My degree is bachelor of arts with major in philosophy.
04:52:04 <merijn> Axman6: Ambition to do more than ask "do you want fried with that?"? *ducks*
04:52:12 <merijn> s/fried/fries
04:55:06 <Axman6> chu: what's the reason for doing COMP1100 then?
04:59:02 <bobry> is it possible to get a bi-directional func. dep? something like 'class Foo a b | a -> b, b -> a where ...'?
04:59:22 <Axman6> sure
05:00:28 <bobry> Axman6: how?
05:00:36 <Axman6> exactly like that
05:00:59 <bobry> oh my, sorry -- it just works :)
05:01:50 <chu> Axman6: My interest in philosophy is mainly using logic to model problems (something akin to Russell's definite descriptions/possible world semantics, etc). I am writing a SAT solver in Haskell, without actually knowing Haskell, so, COMP1100 is a way to learn :p
05:02:20 <chu> Also, my mate is taking COMP1100, and he knows nothing about logic, or programming, so I'm helping him a bit.
05:02:49 <Axman6> ha, sounds good
05:03:38 <merijn> @djinn (a -> [a]) -> b -> a -> (b, a)
05:03:39 <lambdabot> Error: Undefined type []
05:03:54 <merijn> @djinn (a -> m a) -> b -> a -> (b, m a)
05:03:54 <lambdabot> f a b c = (b, a c)
05:04:24 <chu> I spend my time in the CSIT labs since I've been using Linux for about 10 years now, I am pretty comfortable in the environment, and CSIT is the only lab with linux computers hanging around. To get access requires me to be a comp student, so I have done some stuff, but I won't ever get the degree.
05:04:44 <Axman6> chu: there's plenty of people at Galois interested in SAT solvers, Don Stewart has bindings to one of the top C ones i think
05:04:59 <chu> What is Galois?
05:05:12 <Axman6> a company that uses Haskell commercially for many different things
05:05:25 <mekeor> chu: he was a french mathematician, iirc.
05:05:28 <Axman6> they do things like high assurance systems stuff, some crypto and... other stuff
05:05:40 <t7> Galios = galwah
05:05:44 <chu> Yeah, I know *who* Galois was (amazing guy), but no idea what this Galois company is.
05:05:53 <mekeor> ah
05:05:56 <chu> Axman6: I spent the first week writing some stuff up. If you want a look I can send you some source.
05:06:31 <chu> But, I'm not interested in a job doing programming, thanks for the information though.
05:06:33 <gdeest> chu: are you writing a naive SAT solver, or a sophisticated one with nice heuristics ?
05:06:46 <chu> It's just a naive SAT solver. Nothing fancy.
05:07:14 <gdeest> OK
05:07:48 <chu> It's certainly not an efficient solver. But, if all goes well it will lay the ground work to some future stuff.
05:09:23 <gdeest> Are you working with arbitrary formulas, or only with formulas in clausal form ?
05:09:28 <Axman6> chu: you should make it a parallel SAT solver, should be trivial to do in Haskell =)
05:09:36 <chu> Arbitrary formulas.
05:09:40 <t7> chu: does it do a = true; a and b = false; b = ?
05:09:45 <chu> But, I have functions which reduce to clause form.
05:10:09 <chu> Axman6: Yeah, I'll get Bob to help with that when I need it.
05:10:39 <gdeest> chu: I am interested to see your source file :)
05:10:42 <chu> Actually, I'm having some difficulties with assignment at the moment, Bob recommended I look into these State monads, but I have been a busy little beaver.
05:10:53 <gdeest> especially the "clausal transformation" function
05:11:16 <Axman6> chu: parallelism in haskell is pretty trivial, like amazingly so (you'll probably end up making things too parallel)
05:11:19 <chu> So, I have an nnf function, which reduces to negation normal form, and a cnf for conjunction normal form.
05:11:33 <chu> Just to clarify, this is only propositional SAT, so I don't have any quantifiers.
05:11:43 <gdeest> sure
05:11:47 <chu> Usually, clausal normal form is used in the context of quantifiers, so...
05:12:19 <chu> Because of the pattern matching ability, it's actually pretty straightforward.
05:13:15 <merijn> @pl \f g -> const () . (f&&&g)
05:13:15 <lambdabot> (line 1, column 17):
05:13:15 <lambdabot> unexpected " "
05:13:16 <lambdabot> expecting variable, "(", operator or end of input
05:13:18 <chu> gdeest: Here: http://pastebin.com/rLitmcUj
05:13:21 <mauke> The paste rLitmcUj has been copied to http://hpaste.org/67206
05:13:21 <companion_cube> do you intend to implement a state-of-the-art SAT algorithm?
05:13:28 <chu> Not at all.
05:13:30 <merijn> @pl \f g -> const () . (f &&& g)
05:13:30 <lambdabot> (line 1, column 17):
05:13:30 <lambdabot> unexpected " "
05:13:30 <lambdabot> expecting variable, "(", operator or end of input
05:13:46 <chu> It's only a learning exercise.
05:14:10 <companion_cube> oh, ok
05:15:08 <merijn> @pl \f a b -> f a >> f b
05:15:09 <lambdabot> flip =<< (((.) . (>>)) .)
05:16:21 <chu> t7: In the end it will return a model of the expression (I guess provided the expression is true), but at the moment it doesn't do any crazy inference like that.
05:16:33 <gdeest> chu: Thanks :)
05:17:24 <gdeest> Indeed, very straight forward
05:17:25 <t7> is bottom false in the context of prop logic?
05:17:56 <companion_cube> chu: a SAT solver should either return a model, or return 'unsat' :)
05:17:58 <chu> Well, in my case yes.
05:18:04 <chu> companion_cube: Yeah
05:18:22 <chu> Or an empty model instead of unsat :p
05:19:08 <chu> t7: I just use Top and Bottom so I don't have to work with Haskell's True/False.
05:20:09 <companion_cube> I think you can write a very naive solver with the list monad :)
05:22:46 <mekeor> is there a "head' :: [a] -> Maybe a" ?  or how can i define it as easily as possible on-the-run (i mean, anonymously) ?
05:23:00 <chu> I really do not understand enough about Haskell to have any clue what you just said companion_cube :p
05:23:29 <companion_cube> never mind, then
05:24:47 <jgr> companion_cube: mom
05:24:53 <gdeest> > filterM (const [True,False]) [1..4]
05:24:54 <lambdabot>   [[1,2,3,4],[1,2,3],[1,2,4],[1,2],[1,3,4],[1,3],[1,4],[1],[2,3,4],[2,3],[2,4...
05:24:58 <TSC> mekeor: There's the "safe" package: http://hackage.haskell.org/packages/archive/safe/latest/doc/html/Safe.html
05:25:03 <gdeest> unleash the power of the list monad ! :)
05:25:34 <TSC> mekeor: (headMay is the function you want)
05:25:34 <jgr> companion_cube: for starters, you can check if the list is null before using first
05:26:36 <mekeor> TSC: cool. thank you
05:27:16 <gdeest> mekeor: \l -> if (null l) then Nothing else return (head l)
05:28:15 <mekeor> neat
05:28:32 <mekeor> gdeest: why return??
05:28:37 <mekeor> oh, of course.
05:28:53 <gdeest> yes, I could just have used ... Just
05:29:03 <mekeor> yep
05:29:14 <quicksilver> mekeor: listToMaybe
05:29:40 <quicksilver> gdeest: prefer "case" to combining "if" with a predicate which simply checks a constructor, IMO
05:29:51 <mekeor> quicksilver: that's best. thanks
05:29:59 <mekeor> (because it's in base)
05:30:03 <quicksilver> gdeest: so, case l of (x:_) -> Just x; _ -> Nothing
05:30:25 <gdeest> nice :)
05:30:38 <statusfailed> Can I comment type signatures to indicate what arguments are?
05:30:50 <quicksilver> you can put comments anywhere, statusfailed
05:30:57 <statusfailed> I mean for haddock
05:31:02 <quicksilver> if they're haddock-format comments you can even generate documentation
05:31:02 <quicksilver> yes.
05:31:10 <statusfailed> just -- ^ comment goes here?
05:31:12 <quicksilver> haddock supports per-parameter docs
05:31:37 <quicksilver> statusfailed: http://www.haskell.org/haddock/doc/html/ch03s02.html#id565220
05:32:08 <statusfailed> oh cool, thank you
05:40:39 <mekeor> wait! isn't "listToMaybe = head . optional" ?
05:40:45 <mekeor> > head $ optional []
05:40:46 <lambdabot>   Nothing
05:41:11 <mekeor> =)
05:41:15 <ben> What's optional?
05:41:31 <mekeor> > optional ["foo","bar","baz"]
05:41:32 <lambdabot>   [Just "foo",Just "bar",Just "baz",Nothing]
05:41:35 <mekeor> @type optional
05:41:35 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f (Maybe a)
05:45:46 <t7> @hlint map $ map
05:45:46 <lambdabot> No module "map $ map" loaded
05:46:20 <Tinned_Tuna> :t map $ map
05:46:21 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
05:46:38 <t7> @hoogle (a -> b) -> [[a]] -> [[b]]
05:46:38 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
05:46:38 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
05:46:39 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
05:48:31 <niklasb> what is the easiest way to achieve something like (,) <$> [1..] <*> [1..], but where both lists make "progress", so that every combination is actually reached?
05:49:24 <zhulikas> [(x,y) | x <- [1..], y <- [1..]] ?
05:49:45 <zhulikas> oh, both make progress
05:49:51 <zhulikas> that won't work like that then
05:49:58 <TSC> [(x,y) | y <- [1..], x <- [1..y] ] perhaps
05:50:13 <niklasb> hm, this never yields a pair (2,...)
05:50:20 <TSC> > take 10 [(x,y) | y <- [1..], x <- [1..y] ]
05:50:21 <lambdabot>   [(1,1),(1,2),(2,2),(1,3),(2,3),(3,3),(1,4),(2,4),(3,4),(4,4)]
05:50:26 <quicksilver> niklasb: LogicT ?
05:50:31 <niklasb> oO
05:50:51 <zhulikas> wow, nice
05:50:53 <quicksilver> http://hackage.haskell.org/package/logict
05:50:56 <zhulikas> I actually needed that as well
05:50:57 <zhulikas> :o
05:51:03 <quicksilver> also http://okmij.org/ftp/Computation/monads.html#LogicT
05:51:25 <niklasb> TSC: nice, thanks
05:51:29 <zhulikas> waaait...
05:51:38 <zhulikas> oh, ok
05:51:42 <niklasb> didn't think about it that way
05:51:43 <zhulikas> still produces all possible combinations
05:51:50 <niklasb> quicksilver: thanks too
05:51:51 <zhulikas> that's really cool :D
05:51:53 <niklasb> looks interesting
05:52:04 <jgr> list monad at it's finest.
05:52:07 <quicksilver> tsc's only produces half-combinatons
05:52:13 <quicksilver> which might be enough in some cases
05:52:16 <niklasb> quicksilver: hm?
05:52:18 <quicksilver> especially when the lists are the same!
05:52:29 <TSC> Ah, yes
05:52:41 <niklasb> quicksilver: yeah, in this case it works for me. but I'm interested in the more general case as well
05:52:44 <quicksilver> well it never produces (2,1)
05:52:49 <zhulikas> I see...
05:53:14 <zhulikas> that's what my 'waaait' was indicating but I thought I am halucinating and it actually DOES produce (2,1)
05:53:31 <niklasb> quicksilver: yep, I noticed that.. so LogicT could help me with the general case?
05:53:56 <quicksilver> I believe so, niklasb
05:53:59 <quicksilver> although I've never used it
05:54:04 <zhulikas> what about building values from two lists
05:54:11 <zhulikas> if this produces only half of the values
05:54:42 <niklasb> zhulikas: dunno, I thought this would be quite trivial. itertools.product does it without much problems in Python
05:54:57 <zhulikas> can you check the implementation?
05:55:05 <niklasb> zhulikas: of course
05:55:15 <TSC> You could take the half-combinations one and just flip each pair
05:55:33 <niklasb> TSC: as stated above, this would only work in this special case were both lists are the same
05:55:55 <TSC> Oh, yes
05:58:28 <quicksilver> niklasb: it is trivial, it just happens that logict is a convenient place it's packaged as far as I know
05:58:34 <quicksilver> it may also be written down somewhere else.
05:59:13 <quicksilver> the docs for itertools.product make no claim it works on infinite lists
05:59:16 <quicksilver> are you sure it does?
05:59:26 <quicksilver> they suggest it produces results in lexicographic order
05:59:37 <quicksilver> which is incompatible with making progress over infinite lists.
06:00:18 <niklasb> quicksilver: yep, I think I remembered that wrong
06:03:07 <t7> @hoogle [a] -> [a]
06:03:08 <lambdabot> Prelude cycle :: [a] -> [a]
06:03:08 <lambdabot> Data.List cycle :: [a] -> [a]
06:03:08 <lambdabot> Prelude init :: [a] -> [a]
06:03:30 <niklasb> why doesn't it list tail? oO
06:04:13 <TSC> If you don't want the logict version, you can do it the ad hoc way:
06:04:18 <TSC> > take 12 $ (\xs ys -> [ (x,y) | (n,x) <- (zip [1..] xs), y <- take n ys ]) [1..] ['a'..]
06:04:18 <lambdabot>   [(1,'a'),(2,'a'),(2,'b'),(3,'a'),(3,'b'),(3,'c'),(4,'a'),(4,'b'),(4,'c'),(4...
06:05:02 <niklasb> TSC: interesting :) but [1..] seems to occur twice here. why is that?
06:05:03 <TSC> Although that doesn't quite work either
06:05:05 <quicksilver> niklasb: it only shows the first 3
06:05:11 <niklasb> ah, makes sense
06:05:22 <quicksilver> niklasb: http://www.haskell.org/hoogle/?hoogle=%5Ba%5D-%3E%5Ba%5D
06:05:25 <quicksilver> full list
06:05:34 <quicksilver> in fact tail is number 4, it turns out
06:05:58 <TSC> That way doesn't give (1,'b')
06:05:59 <quicksilver> it's just to avoid spamming the channel
06:06:07 <niklasb> quicksilver: yeah, I figured that :P
06:06:33 <TSC> (niklasb, the inner [1..] is for internal use, the other one is an input list)
06:06:40 <niklasb> TSC: I think you'd have to use canton for that
06:07:06 <TSC> What's canton?
06:08:15 <ment> what value could possibly have type ((,) e) ?
06:08:39 <niklasb> ment: It's the same as (e,), I think
06:09:01 <quicksilver> ment: it doesn't have any values, it's a type constructor.
06:09:01 <niklasb> TSC: he proved that N x N is countable
06:09:16 <quicksilver> niklasb: (e,) is not valid haskell syntax but, intuitively that is indeed what it 'means'.
06:09:18 <TSC> Oh, Cantor (:
06:09:18 <ment> but what does that mean? it's shorthand for all tuples that have fst of type e?
06:09:24 <niklasb> quicksilver: oh, sry
06:09:29 <quicksilver> ment: it's not shorthand, no.
06:09:41 <quicksilver> ment: it's a type constructor which can be used to construct them
06:09:41 <niklasb> ment: It means that if you give it another type argument like x, you'll get the type (e,x)
06:09:41 <TSC> Thanks, I see what you mean
06:09:57 <quicksilver> ment: "((,)e) Int" is (e,Int), for example
06:10:00 <ment> niklasb: oh, now i get it
06:10:16 <amkh8581> hi
06:10:18 <niklasb> hi
06:10:33 <amkh8581> i have a question about datatype definition
06:10:41 <amkh8581> anyone can hel?
06:10:46 <amkh8581> help?
06:10:53 <ment> hi
06:10:59 <quicksilver> just ask away, amkh8581
06:11:06 <applicative> what's the trouble amkh8581
06:11:18 <amkh8581> ok
06:11:27 <amkh8581> consider a definition like :
06:12:02 <applicative> you can use hpaste.org if it's big
06:12:06 <amkh8581> datatype ty = Const1 of ty | Const2 of {a : Const1}
06:12:22 <amkh8581> this gives me error when compiling
06:12:27 <applicative> yes it would
06:12:31 <amkh8581> it is ML defenition actually
06:12:37 <niklasb> oO
06:12:51 <amkh8581> what is the correct way to define datatype like this?
06:13:12 <quicksilver> amkh8581: that's not even correct ML
06:13:14 <quicksilver> as far as I know
06:13:14 <amkh8581> i mean to use a constructor inside the definition itself from that definition
06:13:22 <amkh8581> yes i know it is not
06:13:23 <applicative> I dont see how it could be ML
06:13:24 <quicksilver> aren't you using Const1 as a type when it's a constructor
06:13:32 <amkh8581> but where is the problem?
06:13:43 <quicksilver> data Ty = Const1 Ty | Const2 Something
06:13:50 <quicksilver> ^^ that's the general haskell syntax
06:13:58 <quicksilver> but I'm not sure what you're hoping for 'Something'
06:14:10 <quicksilver> Constructors and Types are different things in ML as well as in Haskell.
06:14:12 <applicative> data Const a = Const1 a | Const (Const a)
06:14:22 <amkh8581> the problem is that ML complains that Cons1 is not defined
06:14:28 <amkh8581> altough it is
06:14:37 <niklasb> amkh8581: this channel is about Haskell, you realize that?
06:14:38 <quicksilver> so it's really an ML question not a haskell question?
06:14:46 <amkh8581> yes it is
06:14:51 <quicksilver> in that case you're in the wrong channel, although you already have an answer :)
06:14:51 <chu> lol
06:14:54 <bitonic> amkh8581: I answered you in SML, ask your question here
06:14:56 <quicksilver> the answer is that constructors are not types.
06:14:58 <bitonic> *there
06:15:31 <niklasb> amkh8581: are you having a problem with ML or with Haskell?
06:15:39 <amkh8581> ML
06:15:40 <amkh8581> :P
06:15:54 <niklasb> oh, sry didn't scroll down
06:16:30 <applicative> data Const  = Const1 | Const {a:: Const} is legit...
06:16:43 * hackagebot applicative-quoters 0.1.0.5 - Quasiquoters for idiom brackets and an applicative do-notation  http://hackage.haskell.org/package/applicative-quoters-0.1.0.5 (BenMillwood)
06:17:09 <amkh8581> no i want to use Const1 inside the Const2
06:17:13 <amkh8581> how shall i do that
06:17:14 <amkh8581> ?>
06:17:14 <lambdabot> Maybe you meant: . ? @ v
06:19:42 <t7> @hoogle a -> [b] -> [b]
06:19:42 <lambdabot> Data.List intersperse :: a -> [a] -> [a]
06:19:43 <lambdabot> Data.List genericDrop :: Integral i => i -> [a] -> [a]
06:19:43 <lambdabot> Data.List genericTake :: Integral i => i -> [a] -> [a]
06:22:39 <t7> @hoogle a [b] -> [[b]]
06:22:39 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
06:22:39 <lambdabot> Data.List inits :: [a] -> [[a]]
06:22:39 <lambdabot> Data.List permutations :: [a] -> [[a]]
06:23:56 <t7> anyone know of a function like  foo 3 [0,1]  ->  [ [0,0,0], [0,0,1], [0,1,0], [0,1,1] ...
06:24:53 <quicksilver> > replicateM 3 [0,1]
06:24:54 <lambdabot>   [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
06:24:57 <quicksilver> t7: ^^
06:25:10 <chu> Haha :)
06:25:10 <t7> ah cheers
06:25:22 <ment> what the...
06:25:56 <ment> quicksilver: oh, list monad, nice
06:26:05 <quicksilver> > [1..] >>= flip replicateM [0,1]
06:26:07 <lambdabot>   [[0],[1],[0,0],[0,1],[1,0],[1,1],[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1...
06:30:46 <t7> @hoogle (a -> b) -> [a] -> [(a, b)]
06:30:46 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:30:46 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:30:47 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:31:24 <t7> @hoogle (a -> b) -> a -> (a, b)
06:31:25 <lambdabot> Control.Monad.Writer.Class listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:31:25 <lambdabot> Control.Monad.Writer.Lazy listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:31:25 <lambdabot> Control.Monad.Writer.Strict listens :: MonadWriter w m => (w -> b) -> m a -> m (a, b)
06:31:43 <chu> wow, hoogle is amazing.
06:31:45 <t7> that would be useful in my humble opinion
06:32:43 <TSC> I think you want
06:32:46 <TSC> @type (id &&&)
06:32:47 <lambdabot> forall b c'. (b -> c') -> b -> (b, c')
06:33:05 <TSC> > (id &&&) even 6
06:33:05 <lambdabot>   (6,True)
06:33:12 <niklasb> nice
06:33:13 <TSC> Is that it?
06:33:37 <t7> > map ((id &&&) . even)) [1..10]
06:33:37 <lambdabot>   <no location info>: parse error on input `)'
06:33:41 <t7> > map ((id &&&) . even) [1..10]
06:33:42 <lambdabot>   Couldn't match expected type `b -> c''
06:33:42 <lambdabot>         against inferred type `GHC.B...
06:33:51 <t7> boo
06:34:03 <niklasb> what's wrong there?
06:34:07 <t7> oh wait
06:34:18 <t7> > map (id &&& even) [1..10]
06:34:19 <lambdabot>   [(1,False),(2,True),(3,False),(4,True),(5,False),(6,True),(7,False),(8,True...
06:34:27 <t7> fuck yeah, pro hacker
06:34:36 <niklasb> where is &&& defined?
06:34:42 <TSC> Control.Arrow
06:34:45 <niklasb> wow
06:36:44 * hackagebot shorten-strings 0.1.0.1 - Shorten a variety of string-like types adding ellipsis  http://hackage.haskell.org/package/shorten-strings-0.1.0.1 (ArashRouhani)
06:51:52 <ksf> conal, http://web.archive.org/web/20070927190552/http://users.ipa.net/~dwighth/smalltalk/Fabrik/Fabrik.html
06:52:15 <ksf> @tell conal http://web.archive.org/web/20070927190552/http://users.ipa.net/~dwighth/smalltalk/Fabrik/Fabrik.html
06:52:15 <lambdabot> Consider it noted.
06:53:26 <ksf> another instance of "if only CS was as advance as in the good ole days"
06:56:00 <rasfar> oh, that's 1988! -- i was going to say, trs trs retro graphics...
06:57:48 <ksf> am I the only one to think that Xaw has perfectly fine graphics?
06:58:21 <ksf> yes, different colours are nice to have to display things color-keyed and true colour is useful for displaying images, but...?
06:58:21 <rasfar> probably... Athena Widgets, yeesh...
06:59:14 <ksf> also. my xaw is styled a la zenburn.
06:59:33 <rasfar> i wonder if this paper influenced the AVS system, which i had to use in the mid-90's
06:59:46 <ksf> it's, therefore, the best styled among all the standard stuff here. because neither gtk nor qt work nicely with dark themes.
07:02:05 <rasfar> ksf, i'm just bored and being querrelous; i've very rarely used Xaw apps, and never coded any.  i think Xfig is the only one i've used in a serious way.
07:02:47 <ksf> xpdf, xmessage.
07:02:57 <rasfar> and xpdf, right
07:02:59 <ksf> though I admittedly use okular
07:03:08 <ksf> best kde program there is.
07:03:12 <ksf> ...short of konsole.
07:03:40 <ksf> xkeycaps
07:03:45 <rasfar> i've settled on epdfview, only someone needs to submit a patch to get it to scroll smoothly across page boundaries...
07:04:28 <ksf> well, okular does ps and djvu, too. it usually reads everything ebook-like you throw at it.
07:06:26 <rasfar> i'm used to being short of space so tend to resist installing the KDE deps, although i used to use CDE back in the day
07:07:34 <ksf> diskspace isn't the problem as I'm on a desktop. memory once was with my old box which had 1 gig.
07:08:14 <ksf> kwin is a nice thing, but a full-blown kde session is quite a ressource hog.
07:08:38 <Phlogistique> I should try a recent KDE someday
07:08:58 <hpc> last time i tried kde i couldn't figure out how to even get a terminal open
07:09:05 <rasfar> i still use a modded version of twm, always lightning fast :)
07:09:16 <hpc> the "start menu" buttons all did nothing
07:11:47 <ksf> hpc, a full-blown kde session wants to be started with some specific command.
07:12:24 <ksf> I once spent half a day, unsucessfully, trying to figure out how to open the start menu via dbus.
07:15:07 <hpc> ksf: i was using kubuntu :P
07:15:24 <hpc> install -> turn on -> nothing works
07:16:04 <ksf> yeah such things don't happen with gentoo.
07:16:33 <hpc> with gentoo it's configure -> build -> doesn't install
07:16:34 <hpc> ;)
07:17:11 <ksf> oh, over the time portage's dep resolver improved by magnitudes.
07:17:29 <ksf> but I'm constantly surprised how damn resiliant gentoo is.
07:18:02 <rasfar> i guess twm uses xaw also, come to think of it, although I don't see any widgets anymore
07:18:21 <rasfar> i'd very much like to try arch or gentoo for my next intall
07:18:48 <rasfar> ksf, any issues using Haskell/GHC with Gentoo?
07:18:55 <ksf> nope.
07:19:22 <rasfar> i suppose, like everything else in Gentoo, you compile GHC from source?
07:19:42 <ksf> you don't need to, as with all gigantonormous compiles there's binary versions.
07:19:51 <rasfar> ah
07:20:07 <rasfar> are you using 7.4.1 mainly?
07:20:20 <ksf> I didn't compile firefox or libreoffice either, for example.
07:20:29 <reinoud> @hoogle sort
07:20:30 <lambdabot> Data.List sort :: Ord a => [a] -> [a]
07:20:30 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:20:30 <lambdabot> Data.ByteString sort :: ByteString -> ByteString
07:20:31 <ksf> by now exclusively.
07:26:15 <t7> why does ML have let and letrec, why not just letrec?
07:27:34 <bitonic> t7: first, SML has let and fun. secondly, no particular reason
07:27:37 <ksf> why does haskell have do and do rec, and not just do rec
07:29:18 <companion_cube> there is a 'do rec' in haskell??
07:29:22 <t7> does  let a = 123; b = 321;   compile down to something  like let [(a, 123), (b, 321)]  in SML ?
07:29:52 <ksf> -XRecursiveDo
07:30:05 <ksf> (deprecating mdo)
07:30:21 <ksf> much nicer than writing things in terms of fixM
07:30:23 <t7> alything else would lead to an infinite loop i think
07:31:09 <ksf> one could say that it desugars to letrec a = 123 in letrec b = 3 2 1 in ...
07:32:29 <bitonic> t7: I'm not sure what you're asking...
07:33:01 <t7> does an sml program get turned into a single lambda calc expression ?
07:33:03 <reinoud> @hoogle sortBy
07:33:04 <lambdabot> Data.List sortBy :: (a -> a -> Ordering) -> [a] -> [a]
07:33:04 <lambdabot> Data.Sequence sortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
07:33:04 <lambdabot> Data.Sequence unstableSortBy :: (a -> a -> Ordering) -> Seq a -> Seq a
07:36:45 * hackagebot logic-classes 1.4.5 - Framework for propositional and first order logic, theorem proving  http://hackage.haskell.org/package/logic-classes-1.4.5 (DavidFox)
07:39:11 <sm> wow I'm having to help out cabal quite a bit here: cabal install cabal-install --avoid-reinstalls --constraint 'unix > 2.5' --constraint 'HTTP > 4000'
07:39:27 <t7> bitonic: you got 2 seconds to talk me through something
07:39:30 <sm> but it's working. Yay 0.14 release!
07:39:54 <bitonic> t7: I've been reading your questions but they don't make much sense :P
07:40:03 <t7> nah its something else :)
07:40:07 <bitonic> well just ask it here
07:40:35 <t7> its not really haskell, its hindley-milner inference
07:41:04 <bitonic> I think people won't mind if you ask a HM-related question here
07:41:21 <t7> > let y = 2 in (y :: Int, y :: Double)
07:41:22 <lambdabot>   (2,2.0)
07:41:29 <t7> wtf that doesnt work in ghci
07:41:30 <raichoo> afaik hindley-milner is a typesytem and the inference algorithm is damas-milner.
07:41:39 <sm> when does cabal 0.14 choose the modular solver ? GHC 7.4 and up ?
07:41:53 <sm> with --solver=choose
07:42:42 <bitonic> t7: ghci has slightly different rules to make interaction easier, let me find the right part of the manual...
07:42:53 <t7> :t \x -> let y = x in (y :: Int, y :: Double)
07:42:54 <lambdabot>     Couldn't match expected type `Double' against inferred type `Int'
07:42:54 <lambdabot>     In the expression: y :: Double
07:42:54 <lambdabot>     In the expression: (y :: Int, y :: Double)
07:43:27 <bitonic> t7: that's because of the monomorphism restriction
07:43:32 <t7> basicly i thought let defines a poly morphic type variable, eg one that shouldnt bind on first use
07:43:40 <bitonic> actually no
07:43:42 <bitonic> wait
07:44:44 <bitonic> t7: the second thing you posted doesn't make sense
07:45:19 <t7> yeah my brain is warped
07:46:12 <t7> why is y assigned the type of x and not a poly type
07:46:43 <bitonic> ok, wait
07:46:46 <bitonic> the first thing you posted
07:46:51 <bitonic> doesn't work in ghci, or in ghc
07:46:58 <bitonic> because of the monomorphism restriction
07:47:24 <bitonic> t7: which basically assigns monomorphic types to let/where bindings for performance reasons
07:47:32 <bitonic> (so that they don't have to be recomputed each time)
07:47:39 <t7> ok
07:47:47 <bitonic> you can disable it with -XNoMonomorphismRestriction
07:47:54 <bitonic> or you can simply give explicit types
07:48:20 * sm likes the modular solver's 3x speedup and increased verbosity
07:48:26 <cwl> apply f 1 = f; apply f n = apply (f . f) (n-1)
07:48:41 <cwl> Is apply already exists
07:49:45 <byorgey> cwl: no, but   apply f n x = iterate f x !! n
07:50:05 <yitz> the monomorphism restriction is unhelpful in ghci. i recommend disabling it there by putting the line ":set -XNoMonomorphismRestriction" in your .ghci file.
07:50:11 <t7> bitonic: aha im being an idiot!
07:50:12 <cwl> byorgey: (!!) is slow
07:50:55 <rwbarton> "(!!) is slow" considered harmful
07:50:55 <byorgey> cwl: "X is slow" makes no sense as an absolute statement.  In this case !! takes exactly as long as the repeated function application has to take anyway.
07:51:10 <magicman> apply f 1 = f; apply f n = apply (f . f) (n - 1); Does not do what you think it does.
07:51:28 <magicman> > let apply f 1 = f; apply f n = apply (f . f) (n - 1) in apply (+1) 5 1
07:51:29 <lambdabot>   17
07:51:34 <rwbarton> That's also true, for at least one value of "you".
07:51:40 <byorgey> oh, haha, good point magicman =)
07:51:47 * hackagebot shelly 0.4 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.4 (GregWeber)
07:51:48 * hackagebot circ 0.0.1 - A Compiler IR Compiler.  http://hackage.haskell.org/package/circ-0.0.1 (TomHawkins)
07:51:51 <magicman> Ambiguity ftw :P
07:52:24 <byorgey> my version with iterate does what I thought cwl wanted.  I didn't read the definition very carefully.
07:53:06 <magicman> I expect apply f 1 = f; apply f n = f . apply f (n - 1); (or perhaps apply f n = apply f (n - 1) . f, whichever) to perform similarly to \x -> iterate f x !! n.
07:53:54 <magicman> iterate will create cons-cells, but they're immediately disposed of by (!!). I wouldn't be surprised if GHC knows how to fuse them.
07:54:47 <bitonic> t7: back
07:54:49 <cwl> magicman: your version behaves what i expect
07:54:55 <mux> it didn't last time I checked; I had to code an iterate' with the obvious semantics
07:54:57 <yitz> magicman: unfortunately i don't think so. but often that doesn't matter much, and it's worth it for cleaner code.
07:55:15 <magicman> Not? Aww :(
07:55:20 <rwbarton> assuming f is significantly more expensive than allocating a single cons cell, who cares
07:55:31 <mux> I think I used suggest its addition in the libs but that was years ago and I don't think anything happens
07:55:55 <rwbarton> another issue though is strictness, you might not want to build up f (f (f ...))
07:56:08 <magicman> You have that in either case.
07:56:10 <mux> that's actually what I was talking about -_-
07:56:14 <rwbarton> yes i thought it might be
07:56:24 <cwl> > let apply f 0 = id; apply f n = f . apply f (n-1) in apply (+1) 5 1
07:56:26 <lambdabot>   6
07:57:03 <magicman> Although the iterate version will build f (f (f (... x))), and the directly recursive version will build f . f . ... . f.
07:57:23 <yitz> > let apply f 0 = id; apply f n = f . apply f (n-1) in apply (+1) 1000000 1
07:57:26 <lambdabot>   *Exception: stack overflow
07:57:31 <rwbarton> if f is strict, then the latter will essentially be transformed to the former
07:59:03 <Phlogistique> > let apply f 0 x = x; apply f n x = f $ apply f (n-1) x in apply (+1) 1000000 1
07:59:05 <lambdabot>   *Exception: stack overflow
07:59:07 <sm> is there more concise way to spell --constraint 'PKG OP VER' --constraint 'PKG OP VER' .... ?
08:01:47 * hackagebot shelly 0.4.1 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.4.1 (GregWeber)
08:02:00 <bitonic> t7: the problem is that in the second case the type of 'x' is not polymorphic
08:02:05 <bitonic> > let x = 2; y = x; in (y :: Int, y :: Double)
08:02:06 <lambdabot>   (2,2.0)
08:02:12 <bitonic> t7: ^^^ as you can see this works
08:02:45 <reinoud> i really wish haskell wouldn't be that fuzzy on say ints en reals
08:03:20 <t7> i need to keep track of which type variables a let can not freshen
08:05:36 <rwbarton> haskell is fuzzy on ints and reals?!
08:05:48 <rwbarton> are you sure you're not confusing it with [every other programming language]?
08:05:54 <Phlogistique> what does "fuzzy" mean?
08:05:59 <magicman> Hrm. iterate is defined using build. It's (!!) that isn't foldr, but does some bare metal Int# stuff.
08:06:04 <magicman> "fuzzy" considered fuzzy.
08:06:09 <rwbarton> magicman++
08:06:20 <bitonic> considered "fuzzy" considered fuzzy
08:07:00 <Phlogistique> fix $ considered "fuzzy"
08:08:10 <hayashi> 'considered "fuzzy" considered fuzzy' considered harmfully fuzzy
08:09:07 <Ptival> @tell raichoo As it was explained at Milner symposium, Hindley and Milner both found the unification algorithm, Milner added to that the let generalization, and Damas proved the completeness... so your definitions are not quite right.
08:09:07 <lambdabot> Consider it noted.
08:09:33 <bitonic> milner symposium?
08:09:59 <Ptival> bitonic: http://events.inf.ed.ac.uk/Milner2012/
08:10:11 <ksf> did anyone ever ponder writing CoIO?
08:10:17 <yitz> Ptival: ghc has dropped let generalization, so i guess it wasn't represented at the milner symposium.
08:10:29 <bitonic> damn, it looked like I missed that
08:11:12 <Ptival> yitz: SML and OCaml still have it, no?
08:11:47 * hackagebot wxdirect 0.90.0.1 - helper tool for building wxHaskell  http://hackage.haskell.org/package/wxdirect-0.90.0.1 (KidoTakahiro)
08:11:52 <Ptival> yitz: I'm not sure what your question is, about Haskell or about let generalization?
08:11:53 <yitz> Ptival: probably. haskell does too according to the report, but in practice ghc doesn't do it anymore.
08:12:01 <rwbarton> what was the motivation for that anyways
08:12:20 <Ptival> rwbarton: get the "most general type"?
08:12:31 <rwbarton> sorry, I meant ghc's removing let generalization
08:12:35 <Ptival> oh
08:12:47 <Ptival> @google let should not be generalized
08:12:51 <lambdabot> http://research.microsoft.com/en-us/um/people/simonpj/papers/constraints/let-gen.pdf
08:12:51 <lambdabot> Title: Let Should Not Be Generalised
08:13:16 <yitz> rwbarton: it made things much easier for the ghc implementors.
08:13:44 <rwbarton> but basically because of other type system features, i see
08:13:51 <yitz> right
08:13:59 <Ptival> and lack of actual need
08:14:13 <hpaste_> xraycat pasted “is there a better approach (more idiomatic)?” at http://hpaste.org/67211
08:15:47 <yitz> ksf: i think they call it OI
08:15:54 <hpaste_> xraycat annotated “is there a better approach (more idiomatic)?” with “is there a better approach (more idiomatic)? (annotation)” at http://hpaste.org/67211#a67213
08:16:49 <yitz> @google oi comonad
08:16:51 <lambdabot> http://www.haskell.org/pipermail/haskell-cafe/2006-November/019265.html
08:16:51 <lambdabot> Title: [Haskell-cafe] Towards an IO-Comonad that preserves referential transparency (wa ...
08:18:02 <ksf> it's like all functions suddenly have moustaches.
08:21:02 <xraycat> I'd appreciate any tipps, my overall objective is performance / efficiency
08:21:03 <hpaste_> swish pasted “Modular arithmetic module” at http://hpaste.org/67214
08:24:44 <hpaste_> xraycat annotated “is there a better approach (more idiomatic)?” with “is there a better approach (more idiomatic)? (annotation) (annotation)” at http://hpaste.org/67211#a67215
08:32:35 <t7> hindley milner is so confuse
08:32:46 <t7> i dont even know if my code is working right
08:32:53 <t7> dont know all the test cases
08:34:20 * Saizan wonders if quickcheck would help here
08:41:05 <rasfar> xraycat, even a million entries is still small -- is there some reason you haven't mentioned in the comments why efficiency is a concern for you?
08:41:46 <hayashi> *insert Night Trap reference here*
08:42:04 <rasfar> i'd go for clarity of the code if i were you -- i think your specification could stand to be clarified.  i don't understand how the result from your example (in the comments) represents a sum, for instance...
08:42:51 <rasfar> i am certain that, if you redrafted your spec, and rewrote the code (maybe a couple times), it would be 1/3 or 1/4 the size and make better sense
08:43:21 <xraycat> rasfar: well, it's more of an aggregation I guess
08:43:45 <rwbarton> applyPattern is a little wasteful
08:43:50 <yitz> xraycat: to start with, applyPattern is infinite recursion if the last element is anything other than * or _
08:44:13 <yitz> oh not to start with, others started already. anyway.
08:44:22 <rwbarton> how about using something other than strings "_" and "*" for elements of pattern?
08:44:45 <rwbarton> anyways all of applyPattern could be a zipWith
08:45:43 <yitz> rwbarton: that's probably the intention. as it stands the zipWith is not equivalent.
08:45:59 <rwbarton> (for example you could introduce  data PatternElem = Care | Don'tCare
08:45:59 <rwbarton> )
08:46:35 <rasfar> xraycat, you're in good hands ;)
08:46:38 <xraycat> rwbarton: I'll probably do that
08:48:00 <yitz> xraycat: if you're asking about idiomatic, i like the direction of rwbarton. in haskell the first thought would be to parse both the pattern and the input into data types, then work with those. that allows you to leverage haskell's type system better.
08:49:08 <rwbarton> takeWhile' looks sort of like the map (length && head) . group idiom
08:49:25 <rwbarton> i find it hard to tease out exactly what it does though
08:50:16 <xraycat> it is supposed to do the same thing as takeWhile, but counts the elements it takes along the way
08:50:36 <rwbarton> but it has a gazillion more arguments then takeWhile
08:52:09 <rwbarton> @type takeWhile
08:52:10 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
08:52:17 <rwbarton> @type span
08:52:18 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:52:52 <xraycat> the result ought to be the count, and two lists, one of which is the result with the elements dropped (count >= k) and the second list builds up the 'new' rest
08:54:05 <rwbarton> i always feel like i am decompiling when i read code like this
08:54:27 <xraycat> :-)
08:54:33 <xraycat> sorry for that :-)
08:55:49 <adnauseam> is there a failsafe way to get lambdabot to work?
08:56:33 <Phlogistique> adnauseam: yes, fire irssi with a connection to Freenode, and type "/query lambdabot"
08:57:04 <flebron> Hi. In replicateM :: (Monad m) => Int -> m a -> m [a], replicateM n act the documentation mentions it carries out the action n times. What would be the action in [1,2]?
08:57:27 <flebron> (In general, what is the concept of "action" for a Monad?)
08:57:47 <adnauseam> Phlogistique: can i actually get this lambdabot to connect to another network ? i suppose i'd have to talk to someone
08:57:55 <rwbarton> formally an (m-)action is just a value of type m a for some a
08:58:00 <Phlogistique> adnauseam: I was joking.
08:58:08 <BrianHV> > replicateM 3 [1, 2]
08:58:09 <lambdabot>   [[1,1,1],[1,1,2],[1,2,1],[1,2,2],[2,1,1],[2,1,2],[2,2,1],[2,2,2]]
08:58:09 <rwbarton> depending on what m is you think of actions differently
08:58:16 <adnauseam> Phlogistique: oh, i thought you were being mean
08:58:19 <rwbarton> here the action is nondeterministically choosing either the value 1 or the value 2
08:58:23 <hpaste_> rasfar annotated “is there a better approach (more idiomatic)?” with “is there a better approach (more idiomatic)? (annotation) (annotation) (annotation) (annotation) (annotation)” at http://hpaste.org/67211#a67219
08:58:27 <adnauseam> it's all good though
08:58:28 <adnauseam> :}
08:59:00 <rasfar> regarding idiomatic, i'd keep the lines shorter like that ^ but might depend on your IDE or whatever
08:59:14 <Phlogistique> xraycat: use spaces not tabs
08:59:41 <flebron> rwbarton, how is the action specified in terms of code?
08:59:47 <flebron> Is it the <- in bind?
09:00:07 <rwbarton> I don't know what to say besides what I already said
09:00:10 <BrianHV> > [1, 2] >> [1, 2]
09:00:11 <lambdabot>   [1,2,1,2]
09:00:18 <rwbarton> an "action" is just a value
09:00:32 <rwbarton> it is just a way of thinking about certain values
09:00:33 <flebron> Well, you said an m-action is a value of type m a, but that is not sufficiently defined, it just defined its type.
09:00:39 <rwbarton> any value
09:01:03 <rwbarton> if i have any value of type m a i can think of it as an "action" (in the m monad)
09:01:19 <flebron> OK, but what does it mean to "carry out" such an action?
09:01:31 <rwbarton> that depends on m
09:01:38 <flebron> (The verb "to carry out" is not inherited, if one is simply defining actions as elements of type m a)
09:01:44 <hpc> preflex: seen mauke
09:01:44 <preflex>  mauke was last seen on ##javascript 41 minutes and 36 seconds ago, saying: The paste kQmPVW10 has been copied to https://gist.github.com/2414103
09:02:07 <hpc> @ask mauke I've got a patch for lambdabot and Cale apparently isn't the maintainer; I was told to talk to you
09:02:07 <lambdabot> Consider it noted.
09:02:18 <mauke> wat
09:02:18 <lambdabot> mauke: You have 1 new message. '/msg lambdabot @messages' to read it.
09:02:18 <rwbarton> using the "carry out an action" language means you are thinking from the perspective of "inside the monad"
09:02:39 <rwbarton> e.g.
09:02:40 <mauke> hpc: who told you that?
09:02:41 <xraycat> Phlogistique: will do
09:02:46 <hpc> adnauseam
09:02:51 <rwbarton> > do { x <- [1, 2]; y <- [3, 4]; return (10 * x + y) }
09:02:52 <lambdabot>   [13,14,23,24]
09:03:04 <flebron> In terms of code, given an m a, what does it mean to carry it out? It can't depend on the monad more than just using the Monad typeclass functions, so replicateM must have some code in it that uses those functions (and no further knowledge of the specific monad) to "carry out" the element.
09:03:23 <rwbarton> well
09:03:30 * mauke is confused
09:03:36 <hpc> me too now
09:03:40 <adnauseam> mauke: if someone would have info, it might be too
09:03:43 <adnauseam> s/too/you
09:03:46 <rwbarton> for example, x >> y is the action that "carries out the action x and then carries out the action y"
09:03:59 <adnauseam> i wasn't clear enough about that ;p
09:04:14 <mauke> @where lambdabot
09:04:14 <lambdabot> http://haskell.org/haskellwiki/Lambdabot
09:04:16 <rwbarton> and yes replicateM is just built in terms of (>>=)
09:04:29 <flebron> Ok, so it is a series of >>=?
09:04:32 <adnauseam> mauke: that link doesn't have enough info :/
09:04:34 <Phlogistique> @src replicateM
09:04:34 <lambdabot> replicateM n x = sequence (replicate n x)
09:04:35 <rwbarton> @src replicateM
09:04:35 <lambdabot> replicateM n x = sequence (replicate n x)
09:04:43 <rwbarton> then @src sequence, etc.
09:04:44 <Phlogistique> @src sequence
09:04:44 <lambdabot> sequence []     = return []
09:04:44 <lambdabot> sequence (x:xs) = do v <- x; vs <- sequence xs; return (v:vs)
09:04:44 <lambdabot> -- OR: sequence = foldr (liftM2 (:)) (return [])
09:04:51 <adnauseam> do you not know any other sources we might reffer to ?
09:04:58 <hpc> oh, darcs send!
09:05:10 <hpc> ill try that
09:05:40 <mauke> according to the README the maintainer is Cale
09:05:41 <mauke> fun
09:06:05 <Phlogistique> AFAIK maintainer is lambdabot
09:06:19 <Phlogistique> but the documentation doesn't says so because the reader might not understand fix.
09:06:39 <adnauseam> *facepalm.jpgs*
09:06:41 <adnauseam> =[
09:06:48 * hackagebot postgresql-libpq 0.8.1 - low-level binding to libpq  http://hackage.haskell.org/package/postgresql-libpq-0.8.1 (LeonSmith)
09:07:11 <mauke> all recent commits are by gwern
09:07:27 <mauke> or maybe not
09:09:40 <mauke> yeah, gwern
09:09:42 <hpc> yeah, i just darcs sent
09:11:21 <rwbarton> flebron: it might help to consider what i call the two ways to think about monads, "outside the monad" and "inside the monad"
09:12:17 <rwbarton> in my example "do { x <- [1, 2]; y <- [3, 4]; return (10 * x + y) }" we can arrive at the result in two ways, the first is "shut up and calculate" and write to [1, 2] >>= \x -> [3, 4] >>= \y -> return (10 * x + y) and then use the definition of (>>=) and return for []
09:12:31 <rwbarton> this is thinking outside the monad
09:12:55 <rwbarton> alternatively we can tell a story about what happened from inside the monad, using the idea that [] represents a nondetermistic computation
09:13:01 <flebron> The other is using <- with do notation, I guess.
09:13:06 <rwbarton> first we chose x to be either the value 1 or 2, nondeterministically
09:13:15 <rwbarton> then we chose y to be either the value 3 or 4, nondeterministically
09:13:27 <rwbarton> then we produce (deterministically) the result 10 * x + y
09:13:42 <rwbarton> of course this is all just an invention
09:13:51 <rwbarton> but in practice it is the level of abstraction that it is helpful to think at
09:14:08 <rwbarton> and this is where it makes sense to say "carry out an action"
09:14:19 <yitz> hpc: darcs send works without specifying the email address of the maintainer with --to=? How does it decide where to send the patch?
09:14:23 <xraycat> thanks for all the help, much appreciated
09:14:51 <hpc> dunno
09:15:13 <hpc> ima just see what happens
09:15:26 <yitz> hpc: so how did you know to send to gwern?
09:15:36 <hpc> didn't; darcs send picked cale
09:15:43 <yitz> heh
09:16:57 <elliott> yitz: It's specified in the repo, I believe.
09:16:57 <lambdabot> elliott: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:18:54 <yitz> elliott: looking at some random darcs repo here, i don't see that anywhere in _darcs/prefs
09:19:45 <rasfar> xraycat: yw (and in case you missed it, http://hpaste.org/67211#a67219 for what is (imo) better layout)
09:19:56 <elliott> yitz: i don't think it's in every repo, but I'm not sure
09:20:17 <flebron> rwbarton, thanks
09:20:30 <xraycat> rasfar: yes, thanks
09:24:05 <flebron> Is there a cleaner (perhaps parenthesis-less) way of writing (foo `on` bar) x y?
09:24:22 <yitz> elliott: tried darcs send with that repo i looked at. it prompted for the email address.
09:24:29 <hpc> let f = foo `on` bar in f x y
09:24:30 <hpc> ?
09:24:39 <yitz> elliott: so i guess there must be something you can put in prefs optionally
09:24:41 <byorgey> flebron: that looks clean enough to me.
09:24:58 <flebron> Alright. Thanks.
09:25:01 <hpc> or maybe foo `on` bar $ x $ y
09:25:12 <gdeest> why to $ ?
09:25:13 <hpc> depending on how cooperative ($) is in this situation
09:25:24 <gdeest> and not simply: foo `on` bar $ x y ?
09:26:14 <flebron> "        cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression"
09:27:05 <sm> yitz, elliott: you set the target address in _darcs/prefs/email in the main repo, then darcs send will find that in the local repo, or look for it in the remote repo, I forget which
09:27:06 <yitz> elliott: yeah, the lambdabot repo has two extra files in prefs, author and email, both pointing to Cale. one of those must do it.
09:27:11 <rwbarton> foo `on` bar $ x y isn't the same thing anyways
09:27:25 <rwbarton> foo `on` bar $ x $ y only works in Cale's fantasy universe
09:27:29 <flebron> would it be foo `on` (bar ( x y ))?
09:27:41 <sm> cf http://darcs.net/manual/bigpage.html#SECTION00410000000000000000
09:27:47 <yitz> sm: ok got it thanks
09:29:44 <Phlogistique> :i $
09:29:49 <yitz> @type \foo bar x y -> foo `on` bar $ x $ y
09:29:50 <lambdabot>     Precedence parsing error
09:29:50 <lambdabot>         cannot mix `on' [infixl 0] and `$' [infixr 0] in the same infix expression
09:30:09 <yitz> @type \foo bar x y -> (foo `on` bar) x y
09:30:10 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
09:30:32 <rwbarton> you can also write   on foo bar x y  :)
09:31:07 <yitz> rwbarton: i usually do the parens thing
09:31:23 <Phlogistique> is there no $$ such as $$ = $; infixl 0 $$ ?
09:31:55 <Phlogistique> @type <$$>
09:31:56 <lambdabot> parse error on input `<$$>'
09:32:01 <Phlogistique> @type (<$$>)
09:32:01 <lambdabot> Not in scope: `<$$>'
09:32:04 <Phlogistique> @type (<$>)
09:32:05 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
09:32:08 <yitz> Phlogistique: `id`
09:32:33 <byorgey> yitz: I think `id` is infixl 9
09:32:44 <byorgey> i.e. the default
09:32:59 <Phlogistique> what, id takes only one argument.
09:33:02 <yitz> byorgey: ah right he wanted 0. it is left though.
09:33:10 <byorgey> Phlogistique: all functions take only one argument.
09:33:23 <byorgey> @type ($)
09:33:24 <lambdabot> forall a b. (a -> b) -> a -> b
09:33:26 <Phlogistique> byorgey: GHC's error message disagree with you
09:33:27 <rwbarton> i'm surprised `on` is level 0
09:33:31 <byorgey> @type id :: (a -> b) -> a -> b
09:33:32 <lambdabot> forall a b. (a -> b) -> a -> b
09:33:57 <yitz> rwbarton: yeah that's kind of annoying sometimes
09:34:19 <nand`> > concat $ zipWith replicate [1..] "bang!"
09:34:20 <lambdabot>   "baannngggg!!!!!"
09:34:23 <Phlogistique> byorgey: how is that possible?
09:34:31 <byorgey> Phlogistique: sometimes it's useful to think about functions of multiple arguments.  But they are really just one-argument functions that return functions.
09:34:42 <Phlogistique> byorgey: I know that much
09:35:06 <yitz> @type curry id -- Phlogistique think about this one
09:35:07 <byorgey> Phlogistique: OK, so what exactly are you confused about?
09:35:07 <lambdabot> forall a b. a -> b -> (a, b)
09:35:49 <Phlogistique> byorgey: I didn't realize that (a -> b) -> a -> b was a special case of type c -> c
09:35:57 <byorgey> Phlogistique: yes, with  c = a -> b
09:36:08 <zxspectrum> @pl zipWithM_ ($) ms $ as
09:36:08 <lambdabot> zipWithM_ id ms as
09:36:50 * hackagebot git-annex 3.20120418 - manage files with git, without checking their contents into git  http://hackage.haskell.org/package/git-annex-3.20120418 (JoeyHess)
09:36:55 <byorgey> and (a -> b) -> (a -> b) = (a -> b) -> a -> b  because -> associates to the right
09:37:45 <zxspectrum> is there an offline lambdabot?
09:37:55 <hpc> yes
09:37:56 <rwbarton> in theory, yes
09:38:05 <hpc> you can run lambdabot and not connect it to a network
09:38:14 <hpc> it takes commands from stdin
09:38:15 <rwbarton> in practice it's famously hard to build/install
09:38:31 <hpc> if you are up to the challenge, you can try this: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=13
09:38:36 <hpc> and see how well it works
09:38:59 <Luke> ozataman_:  think I found a bug in the csv-conduit stuff... if I'm reading multiple files in, it doesn't process the second files header as a header
09:39:02 <Luke> it passes it is as data
09:39:03 <Phlogistique> is "for = flip map" defined anywhere?
09:39:15 <hpc> no
09:39:23 <Phlogistique> OK.
09:39:24 <hpc> @hoogle for
09:39:29 <lambdabot> Data.Traversable for :: (Traversable t, Applicative f) => t a -> (a -> f b) -> f (t b)
09:39:29 <lambdabot> Data.Foldable for_ :: (Foldable t, Applicative f) => t a -> (a -> f b) -> f ()
09:39:29 <lambdabot> Foreign module Foreign
09:39:32 <Phlogistique> @hoogle [a] -> (a -> b) -> [b]
09:39:35 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
09:39:35 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
09:39:35 <lambdabot> Control.Parallel.Strategies parMap :: Strategy b -> (a -> b) -> [a] -> [b]
09:39:40 <ozataman_> Luke: yeah, I can see how this can happen. again, csv-conduit knows *nothing* about files.. just a stream of ByteString/Text
09:40:11 <hpc> if you use Traversable's for in the Identity applicative, you get what you want
09:40:41 <zxspectrum> hpc, looks like fun...
09:42:09 <Luke> ozataman_: but it does recognize the header on the first file, right?
09:42:13 <aristid> @quote prime sieve
09:42:13 <lambdabot> No quotes for this person. stty: unknown mode: doofus
09:42:17 <Luke> ozataman_: at least if you're using MapRows
09:42:18 <aristid> @quote prime.sieve
09:42:18 <lambdabot> xplat says: a prime sieve on modern hardware should be able to at least hit 101
09:42:23 <ozataman_> Luke: right, because that's the beginniing of the stream
09:42:39 <lowasser> Does anyone have any idea how to grab a single JSON object from stdin with aeson?
09:42:52 <Luke> ozataman_: oh i see - you mean it doesn't recognize the stream changing. what do you suggest I do?
09:43:24 <ozataman_> Luke: sounds like the easies would be to define your full pipeline for a single file and then mapM over multiple files
09:43:37 <ozataman_> then can all stream/append into same file of course
09:43:43 <ozataman_> if that's what you want
09:44:10 <Luke> ozataman_: yeah that sounds good
09:44:24 <Luke> ozataman_: I'm going to try to set that up myself but I may need some help defining that =)
09:45:12 <hpc> lowasser: write a parser that reads from the first '{' to the matching '}'
09:45:14 <xraycat> ok, applyPattern is now a single line zipWith; if I would make a datatype: data Alphabet = Box | Star and Pattern = [Alphabet] (?), what would my datatype for the general input look like? I'd need some sort of combination of Alphabet / String
09:45:17 <zxspectrum> @pl [ (ps ++ [p], xs') | (p, xs') <- f xs ]
09:45:17 <lambdabot> [(ps ++ [p], xs') | (p, xs') <- f xs]
09:45:20 <hpc> ignoring brackets in strings
09:45:28 <hpc> then pack it and decode
09:45:58 * hpc can't see a better way from a cursory glance at aeson, but there probably is one
09:46:06 <lowasser> hpc: that's what I was thinking, but aeson uses some mysterious internal parser monad that isn't really any good at the sort of continuations or "getting leftovers from parse"
09:46:19 <lowasser> I guess I have to do it on the input directly
09:46:40 <t7> bitonic: does your ml-w support mutually recursive functions?
09:46:41 <hpc> yeah
09:46:45 <hpc> with Parsec or something
09:47:19 <hpc> i don't expect it to be too hard, even if it is a waste of time
09:47:24 <lowasser> fair enough
09:47:24 <zxspectrum> @pl let alt f g xs = f xs ++ g xs
09:47:24 <lambdabot> (line 1, column 30):
09:47:24 <lambdabot> unexpected end of input
09:47:25 <lambdabot> expecting variable, "(", operator, ":", "++", "<+>", ";" or "in"
09:47:26 <lowasser> I buy it
09:48:03 <bitonic> t7: no
09:48:33 <t7> do you know how to implement it?
09:48:55 <c_wraith> lowasser: attoparsec is hardly mysterious
09:49:13 <bitonic> t7: it's a bit annoying but shouldn't be too hard... expecially if you have a designated "mutual" block
09:49:55 <lowasser> no, parsec won't be an issue
09:50:18 <hayashi> Aw.  There are packages for manipulating C source, Java source, Haskell source etc., but not PHP source.  I was hoping to replace my tiny-specialised-subset-of-PHP pretty-printer with a proper one =P
09:50:49 <bitonic> hayashi: PHP if probably i incredibly annoying to parse, if its grammar is like the rest of the language.
09:50:55 <bitonic> *is probably
09:51:02 * kallisti recommends a Perl parser
09:51:06 <kallisti> should be trivial.
09:51:08 <c_wraith> bitonic: fortunately, there are already packages for it on hackage
09:51:09 <hpc> ^
09:51:11 <companion_cube> interpreter, you mean?
09:51:17 <kallisti> same thing.
09:51:19 <Luke> ozataman_: oh yeah I see what you mean now - ease =)
09:51:21 <companion_cube> exactly :)
09:51:56 <kallisti> I don't think PHPs grammar is actually that difficult to parse.
09:51:58 <kallisti> but I could be mistaken.
09:52:13 <bitonic> companion_cube: wasn't hayashi suggesting the opposite?
09:52:23 <bitonic> sorry, c_wraith
09:53:02 <dmwit> http://lolphp.reddit.com
09:53:04 <hayashi> I'd knock this thing I've written through to become a generic PHP manipulation library and then float it as a package, but I'd probably choke on the effort involved given that for what I need it for I only need a pretty-printer and a small fraction of the AST
09:53:07 <rwbarton> php can't be that hard to parse, after all php does it
09:53:22 <hayashi> Wish I could just get rid of PHP completely and use HSP or whatever, though >_>
09:54:32 <hpc> hayashi: you should name your generic library php-haskell-parser
09:54:36 <c_wraith> hmm, maybe it's not on hackage
09:54:38 <c_wraith> hayashi: https://github.com/facebook/lex-pass
09:54:38 <hpc> then shorten it to PHP everywhere in the docs
09:55:00 <c_wraith> facebook has released haskell code for manipulating php
09:55:34 <adamt> ok i'm going to look the other way, because this discussion reminds me about my erlang on .net compiler-project. *shiver*
09:56:11 <hayashi> Hmn
09:56:35 <adnauseam> if one installs an older version of the haskell platform, would cabal packages be also of that time period
09:56:38 <adnauseam> ?
09:56:48 <c_wraith> adnauseam: no
09:56:50 <adnauseam> or is cabal and the haskell platform two seperate things
09:56:57 <hayashi> Last updated 2 years ago and not on hackage ;_;
09:57:06 <adnauseam> c_wraith: how do i get older cabale packages ?
09:57:17 <kallisti> you specify that you want that version
09:57:19 <c_wraith> adnauseam: specify version numbers
09:57:23 <adnauseam> oo
09:57:30 <adnauseam> i'll give it a go
09:57:47 <dmwit> eh, isn't the answer "yes", at least for the packages included in the platform?
09:59:25 <Luke> ozataman_: I can't seem to get the sinkFile not to overwrite the file between inputs. Effectively only saving the last input to the file.
10:00:09 <ozataman_> Luke: explicitly open a handle in AppendMode, then pass to sinkHandle instead of sinkFile
10:00:15 <lowasser> aha, I see the way to do it nicel
10:00:16 <lowasser> y
10:01:12 <ozataman_> Luke: I think I'll need to modify toCSV in any case. It needs a flag to know whether to print headers... you might still have this problem
10:01:29 <Luke> ozataman_: looks like sinkIOHandle has the close behavior as well. I think I need to do sinkIO directly
10:03:58 <Luke> ozataman_: oh yeah - sinkHandle (I was looking at sinkIOHandle) - thanks
10:04:34 <hayashi> Is there any sort of requirement for usefulness or quality on hackage?  Not saying that I'd want to spam hackage with useless toys or anything like that, but I'm a bit adverse to putting anything up there in case there's an expectation that hackage packages need to be useful for a wide audience or need to be the world's best haskell code
10:05:11 <byorgey> hayashi: no, upload away!
10:05:32 <rasfar> on a related note, are there any rules about the namespace?
10:06:25 <dmwit> Don't steal someone else's name.
10:06:43 <dmwit> (There is, unfortunately, no technical mechanism enforcing this rule.)
10:07:09 <sm> Don't grab a very high-value short name for something throwaway
10:07:23 <rasfar> dmwit: ? do you mean to say, it is possible to upload multiple modules with the same qualified name?
10:07:30 <lispy> rasfar: yes
10:07:45 <dmwit> rasfar: Oh, heck yes. You can even upload a package with the same name as somebody else's package.
10:07:53 <dmwit> (The latter is what I meant.)
10:07:57 <rasfar> thanks for the info; while i'm at it, what's the best way to get a list of ALL module names in hackage?
10:08:19 <rasfar> i spend a while searching my .cabal tree, and also my source of Hoogle (built), but no luck.
10:08:34 <dmwit> I don't know of a way.
10:08:55 <rasfar> i'd like to see that resource available.  shall i work on that?
10:09:03 <dmwit> That would be wonderful!
10:09:07 <rasfar> cool
10:09:15 <dmwit> You might look at "cabal info" to begin with.
10:09:29 * hayashi wonders what the correct way to go about naming a module that serves as a not very complete attempt at a syntax and pretty-printer for PHP 5.4 (with the unpromised hope of it becoming useful later) would be.  (The only reason I'm considering uploading it at all is so it isn't a pain to grab and install later)
10:09:33 <dmwit> It can print a list of modules for any package on Hackage, so you might want to see how it gets that information.
10:09:38 <rasfar> yes; it seemed to just give me package names (rather than modules), but there may be options to give more...
10:09:43 <rasfar> i see
10:09:45 <hayashi> I'd use language-php, but that implies that it's a complete and usable language transformation set
10:11:11 <adnauseam> i'm getting thefollowing message on many packages that i'm trying toinstall
10:11:12 <adnauseam> anwarson@Aiwar ~/Downloads/cs/inf2/haskell/lambdabot $ cabal install numbers
10:11:12 <adnauseam> Resolving dependencies...
10:11:12 <adnauseam> No packages to be installed. All the requested packages are already installed.
10:11:12 <adnauseam> If you want to reinstall anyway then use the --reinstall flag.
10:11:17 <adnauseam> what may be the issue ?
10:11:52 <dmwit> adnauseam: Well, do you already have the packages installed?
10:12:15 <adnauseam> dmwit: lambdabot's configure asks for them :/
10:12:38 <dmwit> If you want to install lambdabot, and lambdabot is a cabal package, why aren't you using "cabal install" to install it?
10:13:08 <adnauseam> because it doesn't work that way due to many incompatible versions of packages it used
10:13:12 <dmwit> (To answer your direct question, though, you probably have outdated or updated versions of the packages compared to what lambdabot is asking for.)
10:13:15 <adnauseam> i wish it just did
10:13:30 <dmwit> adnauseam: If cabal install won't do it, you won't be able to do it by hand.
10:13:35 <dmwit> That's sort of the point, I think.
10:13:43 <adnauseam> god damnit
10:14:03 <dmwit> Unless you think your brain is a better constraint solver than cabal-install's. =)
10:14:08 <sm> hayashi: language-php sounds like a good package name, since there's none, especially if it'll be contribution-friendly
10:14:18 <Luke> ozataman_: is the header writing flag an easy change?
10:14:18 <adnauseam> :/
10:14:38 <adnauseam> even if iti was, considering i've been studying haskell for a month, i won't get toofar :/
10:14:41 <sm> and maybe you can start from lex-pass
10:14:41 <adnauseam> without help ;p
10:14:56 <sm> or incorporate useful bits
10:15:15 <hayashi> sm: Main problem is that the AST'll probably need completely refactoring, as the one I'm using right now just grew out of something else rather than a definitive attempt to implement a PHP AST
10:15:32 <hayashi> as such it's got bits that are too high-level, or specialised, or completely missing
10:15:42 <dmwit> adnauseam: The easiest thing to try is to relax some dependencies in lambdabot's cabal file and try cabal-install again.
10:16:13 <dmwit> adnauseam: cabal-install will give you *some* information about why it's refusing to install if you ask with -v, which may help guide the relaxation process.
10:16:57 <hayashi> Oh cool, lex-pass is BSD3
10:17:04 <t7> bitonic: "mapM (const fresh) [1..gens]" tut tut... use replicateM :)
10:17:18 <sm> hayashi: some folks name their packages XX-NAME, where XX is their initials
10:17:32 <adnauseam> dmwit: i might as well stab myself.
10:17:40 <adnauseam> but don't mind me, i'm just frustrated
10:17:55 <adnauseam> there must be something, somewhere... out there. that works...
10:18:08 <bitonic> t7: is that in my code?
10:18:13 <t7> yea
10:18:18 <bitonic> :)
10:22:05 <hayashi> A library for the analysis and creation of Graphviz DOT files.  <-- Nyoron.  Why didn't I look for this before rolling my own bad AST/parser for dot too?
10:22:34 <hayashi> Wheel reinventing.  Fun for all the family
10:29:00 <Phlogistique> Who the hell uses "nyoron" as an actual word
10:30:46 <bitonic> Phlogistique: hayashi
10:30:50 * hayashi
10:30:52 <bitonic> :(
10:31:25 * hayashi learns how to use the pretty-printing combinators
10:31:43 <Hexmind> !asdf
10:31:45 * Hexmind asdf
10:35:45 <byorgey> I seem to have a vague recollection of an article by some well-known game developer person opining that FP was the future of game development.  Anyone have any idea what I'm talking about?
10:36:05 <byorgey> one of my Haskell students is interested in game development.
10:36:39 <hayashi> Was that Tim Sweeney?  I honestly can't remember.
10:36:54 <rwbarton> http://www.youtube.com/watch?v=4zgYG-_ha28&feature=player_detailpage#t=4193s
10:36:58 <bitonic> byorgey: Tim Sweeney and John Carmack
10:37:36 <bitonic> Tim Sweeney is more about dependent types iirc
10:38:15 <Hexmind> byorgey: Do you ever allow students to audit your course?
10:38:23 <byorgey> thanks all
10:38:30 <blackdog> hayashi: pretty sure it was tim sweeney
10:38:44 <byorgey> rwbarton: was that link for me? (I have youtube blocked during the workday)
10:38:53 <byorgey> Hexmind: yes, absolutely
10:39:21 <blackdog> byorgey: http://lambda-the-ultimate.org/node/1277 ?
10:39:22 <rwbarton> byorgey: yes
10:39:29 <rwbarton> http://www.reddit.com/r/haskell/comments/jap3x/im_very_tempted_to_want_to_move_to_a_functional/
10:39:47 <rwbarton> transcribed in first post
10:39:50 <Clint> byorgey: do you have competent students who want to do free haskell work in some kind of internship situation?
10:40:55 <byorgey> Clint: I have some competent students.  No idea about the second part.
10:41:06 <Clint> hmm
10:41:31 <byorgey> Clint: why do you ask?
10:41:59 <Clint> byorgey: softwarefreedom.org has need for free-to-barely-paid labor in that regard
10:42:48 <Hexmind> byorgey: Do you know if Penn LPS costs anything for auditing a course? Apparently you just need to fill out the form and obtain permission from the professor
10:43:05 <Hexmind> But I'm really not sure
10:43:41 <Hexmind> Wait never mind: understand that I will be charged the prevailing
10:43:41 <Hexmind> tuition and fees of the school or college that is offering the course
10:43:45 <sm> Clint: what does softwarefreedom.org use haskell for ?
10:44:05 <byorgey> Hexmind: where are you reading that?
10:45:02 <Hexmind> byorgey: Right off the Auditor form on UPenn's website: http://www.sas.upenn.edu/lps/auditor
10:45:11 <JoshTriplett> What's the correct bug tracker in which to file bugs about System.IO?
10:45:27 <JoshTriplett> The implementation of it, rather.
10:45:30 <Clint> sm: accounting, document collaboration and production, some administrative workflow stuff, file "sharing", possibly something else
10:45:58 <ciaranm> you could just show up to lectures. no-one will notice.
10:45:59 <sm> nice
10:46:32 <dmwit> JoshTriplett: If that's in base, your best bet is probably to complain on libraries@ first.
10:46:40 <byorgey> Hexmind: yeah, if you get permission from the instructor then no one can really stop you from just showing up.  I doubt most professors would really care.
10:47:01 <JoshTriplett> dmwit: For implementation issues?  I thought that was only for API-level issues.
10:47:11 <blackdog> Hexmind: when i was freelancing, i had heaps of free time, and i used to drop into random lectures at USyd constantly
10:47:25 <blackdog> no-one gives a damn, so long as they don't have to mark your work and you're not being disruptive.
10:47:45 <Hexmind> Thanks for the feedback guys
10:47:46 <EvanR> how to compare on more than one thing, like if the first criteria is EQ, check another criteria
10:47:53 <EvanR> for the purpose of sorting
10:47:57 <dmwit> JoshTriplett: The GHC Trac is probably a reasonable first place to look, too. Up to author preference, I guess.
10:48:02 <dmwit> JoshTriplett: What'd you discover?
10:48:06 <ciaranm> EvanR: it's a monoid
10:48:18 <jfischoff> EvanR: sortBy
10:48:35 <JoshTriplett> dmwit: I'd like to propose that mkTextEncoding and friends should avoid using glibc/gconv, because it utterly fails with static linking.
10:48:57 <JoshTriplett> dmwit: And given that it only promises to support UTF-{8,16,32} and a few //suffixes, that seems easy to do natively.
10:48:57 <dmwit> That sounds like a libraries@ thing, then.
10:48:57 <EvanR> whats that type called
10:49:02 <EvanR> EQ LT GT
10:49:05 <EvanR> Ordering
10:49:15 <JoshTriplett> dmwit: Fair enough.
10:49:18 <EvanR> k thanks
10:49:22 <JoshTriplett> dmwit: Thanks!
10:50:18 <ciaranm> > EQ `mappend` GT
10:50:19 <lambdabot>   GT
10:50:22 <ciaranm> > LT `mappend` GT
10:50:22 <lambdabot>   LT
10:50:52 <EvanR> now i just have to figure out how to do this in ruby :(
10:51:18 <dmwit> ?instances Monoid
10:51:19 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, First a, Last a, Maybe a, Ordering, Product a, Sum a, [a]
10:51:48 <EvanR> in other systems EQ GT LT is 0 1 -1
10:51:59 <ciaranm> other systems are silly
10:51:59 * EvanR wonders if the monoid operation can be done with numbers...
10:52:18 <ciaranm> of course it can
10:52:22 <hpc> EvanR: Sum, Product
10:52:30 <EvanR> no i mean
10:52:39 <EvanR> the Ordering operation, but with 0 1 -1 and + or * or something
10:52:49 <ciaranm> of course it can
10:52:53 <dmwit> > let fstThd = comparing (\(a,b,c) -> a) `mappend` comparing (\(a,b,c) -> c) in sortBy fstThd [(3,4,5), (3,4,6), (3,5,5), (4,4,4)]
10:52:54 <lambdabot>   [(3,4,5),(3,5,5),(3,4,6),(4,4,4)]
10:52:56 <EvanR> 0 ? 1 -> 1
10:53:00 <EvanR> -1 ? 1 -> -1
10:53:34 <byorgey> EvanR: maybe what you're really asking is "can it be done using some simple, well-known numeric operation"?
10:53:35 <hpc> instance some constraints => Monoid (Sum a) where mempty = 0; mappend (Sum a) (Sum b) = Sum (a + b)
10:53:43 <EvanR> was that mappend for functions?
10:53:43 <dmwit> EvanR: Don't be silly. Just write it with if/then/else s.
10:53:44 <hpc> repeat for Product, 1, (*)
10:53:54 <EvanR> dmwit: its going to be insane
10:54:00 <dmwit> Insane? It's like three clauses.
10:54:09 <EvanR> no... no ...
10:54:15 <dmwit> mappend 0 y = y; mappend x y = x
10:54:27 <dmwit> two clauses =)
10:54:35 <EvanR> because comparing nil and numbers is hilarious or an error in ruby
10:54:40 <dmwit> mappend x y = if x == 0 then y else x
10:54:54 <dmwit> I don't see where nil got into the picture here.
10:54:58 <ciaranm> if you're doing it in ruby, clearly the solution is to monkeypatch a new operator into Numeric
10:55:05 <EvanR> ciaranm: thats what they told me
10:55:09 <EvanR> :(
10:55:18 <ciaranm> for bonus points, give it a name that all your libraries will also use subtly differently
10:55:39 * EvanR wishes he had comparing
10:55:39 <ciaranm> so you have six different monkeypatched implementations of the same method, and the one that gets used is determined semi-randomly
10:55:46 <dmwit> Comparison functions that return nil get what they deserve.
10:56:10 <EvanR> 7 <=> nil, nil
10:56:13 <EvanR> nil <=> nil, 0
10:56:15 <EvanR> :(
10:56:20 <dmwit> I guess that's not fair, as "incomparable" is a completely sane result for a different typeclass than Ord.
10:56:26 <timthelion> is nil a value in haskell?
10:56:33 <EvanR> Nothing \o/
10:56:47 <timthelion> EvanR: Well I know that.
10:56:58 <EvanR> dmwit: well id rather it be comparible and behave in a certain way
10:57:04 <EvanR> less than all numbers etc
10:57:10 <dmwit> If nil is meant to represent "incomparable", then you probably want liftM2 mappend as your operation, not mappend.
10:57:20 <dmwit> EvanR: Sorry, what?
10:57:36 <EvanR> nil stuff sorted to the bottom
10:57:57 <dmwit> EvanR: Are we talking about comparing nil to other things, or managing a comparison function that returns nil?
10:58:10 <dmwit> EvanR: If the former, presumably that's not your problem when writing the mappend operation for -1, 0, 1.
10:58:12 <EvanR> sorting records by field which is number|nil
10:58:22 <EvanR> among other fields
10:58:34 <dmwit> I'm officially lost.
10:58:41 <EvanR> nvm, im going back to ruby
10:58:49 <EvanR> i already see its really easy in haskell
10:59:13 <bitonic> are there any good benchmarks for set-like data structures? this seems a bit limited: https://github.com/haskell/containers/blob/master/benchmarks/Set.hs
10:59:14 <adamt> I'm not sure that's the right attitude to approach a new thing in life with.
10:59:27 <EvanR> adamt: new thing?
11:00:49 <byorgey> bitonic: if you want really fast set-like data structures with good benchmarks, use the  unordered-containers package
11:00:58 <sclv> ah, byorgey beat me to it
11:01:35 <bitonic> byorgey: no I'd like a good benchmark, so that I can use it to test my own set-like data structure :)
11:01:54 <ciaranm> i want a really fast set of integers data structure where the bits are guaranteed to go from 0 to some known n that uses my nice shiny 256 bit registers
11:02:09 <sclv> bitonic: right. use the benchmarks in that package/repo!
11:02:16 <bitonic> byorgey: but this looks good: https://github.com/tibbe/unordered-containers/blob/master/benchmarks/Benchmarks.hs so thanks for mentioning unordered-containers!
11:02:25 <byorgey> sigh =)
11:02:28 <byorgey> that was my point =)
11:02:41 <sclv> can we argue about it anyway?
11:02:47 <byorgey> no!
11:02:53 <sclv> i want to argue!
11:02:53 <ciaranm> sclv: your mother was a hamster
11:02:53 <hpaste_> timthelion pasted “Random gtk errors that happen <1% of the time” at http://hpaste.org/67222
11:02:57 <dmwit> Nuh-uh, you said that package was for fast set-like data structures!!!
11:03:02 <timthelion> How might I go about debuging that?
11:03:14 <timthelion> as far as I can tell, the crash is 100% random...
11:03:28 <sclv> @slap ciaranm
11:03:28 <lambdabot> stop telling me what to do
11:03:32 <timthelion> aka, it's not like it happens only when I'm touching the edge of the scroll window or something...
11:03:34 <sclv> blah
11:03:36 <bitonic> byorgey: oh, ok sorry :)
11:04:15 <hamishmack> timthelion: Are you using -threaded?
11:04:20 <timthelion> hamishmack: yes
11:04:46 <timthelion> hamishmack: but I'm also doing it within a postGUIAsync...
11:05:14 <timthelion> hamishmack: and there is no way for me to make my program not threaded.
11:07:11 <acowley> A while ago I did some comparison of the PSQueue and fingertree-psqueue packages, and found PSQ to be much faster. Is anyone surprised by that result? (I'm trying to decide if I should revisit the issue.)
11:07:22 <dmwit> timthelion: If you ask it to dump core, it's possible gdb will understand enough to tell you which gtk function was topmost in the callstack when the double-free happened.
11:07:41 <timthelion> dmwit: ask ghc to dump core?
11:07:41 <dmwit> gdb is unlikely to be able to help you understand where in your Haskell program things died, though.
11:07:51 <dmwit> timthelion: No, ask your kernel to dump core. =)
11:08:08 <dmwit> timthelion: (Is this really a crash? Like, segfault or so?)
11:09:06 <timthelion> dmwit: well on the first error, it crashes with SIGABRT, the seccond one, the forkOS thread I gave to gtk freezes.
11:09:33 <dmwit> Freezing is harder, but you could send it a bad signal and still get some information out.
11:09:57 <dmwit> But yes, learn a bit about ulimit.
11:10:57 <dmwit> You will want to read about it in your shell's man pages, not the system-wide man pages.
11:11:35 <Clint> or in the setrlimit() man page
11:11:50 <timthelion> it's strange, because I keep finding bugs in GTK itself... For example the scrollCord function I wrote, SHOULD return upper, but has to return upper(as in the upper limit of scrolling in the scroll box as gotten by asking the scroll box for the upper limit, but the upper limit given by the adjustment is actually one "page size" too big.
11:12:24 <timthelion> it has to return upper minus the page size...
11:16:40 * timthelion sighs at the fact that most of the work is getting GTK2HS working, and almost no time gets spent programming.
11:17:59 <hamishmack> timthelion: I am going to play around with -threaded on Leksah again (probably tomorrow) and see if it is the same error I get there
11:18:28 <hamishmack> timthelion: I think the first one might be
11:19:11 <timthelion> hamishmack: are you a/the leksah dev?
11:19:26 <a7x> ohm
11:19:26 <hamishmack> timthelion: Yes one of them.
11:20:00 <timthelion> hamishmack: I am writing an IDE of sorts.  But very very different from leksah
11:20:43 <a7x> should i update cabal-install even if i'm on debian?
11:20:59 <hamishmack> timthelion: Cool
11:21:07 <timthelion> hamishmack: http://imageshack.us/f/94/gridediteditcell.jpg/
11:21:38 <timthelion> that is an image of my pre^24 alfa^32 version.
11:22:17 <hamishmack> Ah a visual language.  Very cool.
11:22:23 <timthelion> hamishmack: but it's haskell :)
11:24:01 <hamishmack> timthelion: I wrote a basic VL on top of a image processing scripting language for my finally year project at Uni
11:24:17 <timthelion> hamishmack: My idea, is a kind of web browser, where you can click on the function names and go to a new page, like if they where hyperlinks.  And since haskell is purely functional and has no side effects/global state, you'll be able to brouse other peoples code/like you would brouse the internet, and when you find a function you like with a type that is usefull, you'll just copy the link into your own program.
11:24:46 <timthelion> all code would be online, and would get downloaded compile time
11:24:58 * timthelion has a fealing he got cut off, but has no idea as to where.
11:25:27 <eacameron> I'm getting this warning when I build my (very simple) program: Use -fspec-constr-count=n to set the bound   - Any ideas?
11:25:42 <byorgey> timthelion: "...copy the link into your own program."  doesn't looks like you got cut off.
11:25:56 <timthelion> byorgey: nope :)
11:25:59 <eacameron> Actually, the warning says: Function `$w$j{v X1xq} [lid]' has one call pattern, but the limit is 0
11:26:15 <byorgey> eacameron: that was a bug in some versions of GHC, you can ignore it
11:26:41 <byorgey> eacameron: the bug was just that it printed a "warning" which is not really a warning, it's just telling you that some potential optimization did not happen
11:27:14 <eacameron> byorgey: ahh...that's comforting. Maybe I'll try a newer version of ghc when I get a chance.
11:27:43 <Clint> a7x: not if you don't need to
11:28:28 <TheLemonMan> im trying to go point free but this function seems to need type constraints
11:29:07 <byorgey> TheLemonMan: those two things should have nothing to do with each other.  unless maybe you are running into the monomorphism restriction.
11:29:32 <byorgey> TheLemonMan: can you paste some code/an explanation of the problem on hpaste.org?
11:30:03 <TheLemonMan> err, i'm pretty new to the whole thing so id better paste some code
11:30:34 <Cale> eacameron: SpecConstr is an optimisation which roughly applies to self-recursive functions where one or more parameters in a recursive call involve explicit constructor applications that are going to be deconstructed by the recursive call anyway
11:30:41 <monochrom> byorgey++ for fighting context-free questions
11:31:02 <TheLemonMan> http://hpaste.org/67223
11:31:32 <byorgey> TheLemonMan: those functions are not the same.
11:31:54 <Cale> eacameron: It specialises the function to eliminate the construction of those data, just by taking those things which would have been packaged up by the constructor as parameters in the specialised version. (Producing a version of the function which only works when that specific constructor is used.
11:31:55 <Cale> )
11:32:26 <byorgey> TheLemonMan: mask .&. (flip shiftR) s w   is really   mask .&. ((flip shiftR) s w)
11:32:58 <byorgey> TheLemonMan: but with the second version, you would have  ext n s w = (mask .&. (flip shiftR)) s w
11:33:04 <Cale> eacameron: The -spec-constr-count flag sets a limit on how many additional versions of the function this optimisation will produce (but in this case, you're just hearing noise made by that code)
11:33:05 <byorgey> see the difference?
11:33:27 <byorgey> TheLemonMan: I doubt the second version will even type check.
11:33:33 <TheLemonMan> oh, got it
11:33:51 <TheLemonMan> yep, in fact it returned obscure errors while compiling
11:34:04 <byorgey> TheLemonMan: I wouldn't worry about trying to make that function points-free, it's not worth it.
11:34:26 <byorgey> @pl ext n s w = mask .&. (flip shiftR) s w
11:34:27 <lambdabot> ext = const (((mask .&.) .) . flip shiftR)
11:34:35 <monochrom> talking of which, http://bm380.user.srcf.net/prettyparsetree.cgi shows you extra parentheses so you know you are wrong
11:34:50 <TheLemonMan> as a beginner im trying to make everything pointfree as addictional exercise
11:35:11 <byorgey> oh, that's fine then.
11:36:27 <byorgey> TheLemonMan: I find it helps to first transform infix operators into prefix applications, so  ext n s w = (.&.) mask (((flip shiftR) s) w)
11:36:33 <monochrom> to do pointfree, you should first eliminate all infix notation. ((.&.) mask) (((flip shiftR) s) w)
11:37:16 <byorgey> oh, yes, I forgot the extra parens around (.&.) mask
11:37:44 <TheLemonMan> oh, i didnt know about the infix elimination with parenthesis
11:40:03 <TheLemonMan> talking of pointfree, what should i do with the type declaration ?
11:40:47 <monochrom> use any type declaration that the compiler accepts
11:41:16 <TheLemonMan> do i have to put the missing arguments too ?
11:41:25 <monochrom> yes
11:41:28 <Luke> http://hpaste.org/67225 can anyone see why I wouldn't get any output from this?
11:41:39 <Luke> i was getting output but then refactored and broke it
11:42:21 <Luke> nevermind - forgot to close the file handler
11:51:24 <BrianHV> @djinn (Show a) => a -> b
11:51:25 <lambdabot> Error: Class not found: Show
11:53:54 <elliott> BrianHV: that's not a very possible type :)
11:54:47 <BrianHV> I suppose not. :)
11:54:52 <BrianHV> @djinn Int -> Int
11:54:52 <lambdabot> Error: Undefined type Int
11:55:11 <BrianHV> @djinn a -> a
11:55:11 <lambdabot> f a = a
11:55:16 <BrianHV> success!
11:57:03 <kamatsu> Hi, I'm writing an exercise for my students
11:57:18 <kamatsu> I'm having some problems with GHC parallelism
11:57:30 <kamatsu> seems like no matter what I do, GHC only creates one spark :/
11:58:34 <Saizan> compiling with -threaded, right?
11:59:15 <edwardk> kamatsu what build options are you using?
11:59:49 <kamatsu> yep
11:59:53 <kamatsu> -threaded -O2
11:59:56 <kamatsu> oh,
12:00:03 <kamatsu> i just realised, I am getting speed up
12:00:09 <kamatsu> and it is using more than one core with -N 4
12:00:11 <kamatsu> but for some reason
12:00:15 <kamatsu> -S says only one spark
12:01:06 <thoughtpolice> kamatsu: try the eventlog? for recent GHCs, threadscope+eventlog will give you information about the spark pool
12:01:20 <thoughtpolice> when it overflows, when they're created, etc
12:01:31 <thoughtpolice> may help you get a grip on what's going on
12:02:25 <kamatsu> i'm on a mac and I don't have GTK
12:03:06 <thoughtpolice> :( there really needs to be some kind of web interface for threadscope eventlogs or something
12:03:24 <acowley> Does EKG show the spark pool?
12:03:24 <thoughtpolice> er, well, eventlogs, but modeled on threadscope :)
12:03:48 <thoughtpolice> no, spark #s aren't included. EKG just uses the stats interface from the runtime, and almost all of that is GC related
12:03:57 <thoughtpolice> you can create your own events to report to the UI however
12:04:12 <acowley> I thought the GC also collected sparks?
12:04:30 <thoughtpolice> i coulda sworn it didn't have anything relevant to sparks, hold on
12:05:53 <kamatsu> nevermind
12:05:55 <kamatsu> i'm a derp
12:06:06 <kamatsu> recursively called the sequential version of the function
12:06:12 <thoughtpolice> acowley: nope, nothing sparks related - http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/GHC-Stats.html
12:06:32 <kamatsu> so, no sparks beyond the first call were created
12:06:33 <kamatsu> fixed now
12:07:59 <hayashi> I wonder if I'll ever get these pretty printer combinators to give me PHP code that'll pass PHP_CodeSniffer's brutal enforcement of its narrow opinions on what constitutes good PHP code or not
12:09:32 <acowley> thoughtpolice: that's a shame! I haven't used EKG, but it seems like a pretty fantastic tool. If it could do some of what ThreadScope does then it would really become a great showpiece of the GHC ecosystem.
12:11:59 <abacathoo> Hello, I have a question about associated data families
12:12:14 <monochrom> are the exact rules of PHP_CodeSniffer known? one could tailor to it
12:12:18 <thoughtpolice> acowley: indeed, at one point on my old (now dead) computer i also had a prototype of something that would stream GHC eventlogs (using attoparsec) to the browser with websockets, the idea being you could get a 'live' view of the parallelism as it's happening
12:13:00 <acowley> thoughtpolice: is there an implication that this code was not backed up anywhere?
12:13:18 <thoughtpolice> it was kind of a hack and only worked on linux/osx (because I secretly created a FIFO where the eventlog was going to be written to, thus blocking the RTS early during fwrite, and then another part of the server read the FIFO and streamed it
12:13:38 <thoughtpolice> acowley: i didn't get as far as actually displaying anything, just chunk-wise parsing and streaming it in via websockets
12:13:53 <thoughtpolice> i could probably recreate it in a day or two, dons' has a streaming ghc event log parser he wrote somewhere
12:14:02 <thoughtpolice> probably a little out of date with the recent eventlog format
12:14:36 <abacathoo> So you know how you can add data types within typeclasses. Can you set a default value for that data type?
12:14:56 <thoughtpolice> the funny thing was that eventlog enabled programs ran faster under my shim than normally, because parsing the eventlogs with attoparsec was actually faster than writing the log to disk :P
12:15:01 <thoughtpolice> which is kinda funny
12:15:06 <acowley> abacathoo: yes, but it doesn't work yet (at least with ConstraintKinds)
12:15:49 <abacathoo> acowley: okay, so this isn't in an availiable version of ghc then?
12:16:12 <acowley> abacathoo: that is my understanding. I'm told it's fixed in HEAD.
12:17:21 <kamatsu> alright, now I've got it to create sparks, but for some reason my program gets slower as i increase the number of execution contexts :/
12:18:30 <TheLemonMan> can i define a datatype as a possible combination of two datatypes ?
12:18:32 <acowley> kamatsu: making an algorithm slower with parallelization is usually easier than making it faster
12:18:43 <lowasser> TheLemonMan: what do you mean by "combination"?
12:19:06 <kamatsu> i am getting them to write a map function on binary trees
12:19:08 <acowley> TheLemonMan: I'm guessing you mean Either or (,)
12:19:09 <TheLemonMan> i have a type A and a type B, i want to make a general type C that could accept both
12:19:20 <acowley> type C = Either A B
12:19:22 <kamatsu> then parallel map, then parallel map with cut-off
12:19:25 <kamatsu> then strategies for trees
12:19:53 <kamatsu> my understanding of parallelism in Haskell was, however, entirely theoretical
12:19:59 <kamatsu> and I have never actually used it before
12:19:59 <acowley> kamatsu: I've gotten successful speedups with parallel tree map with cut-off.
12:20:04 <TheLemonMan> hrm, nothing w/o the use of Left/Right ?
12:20:04 <kamatsu> hence my current predicament.
12:20:38 <kamatsu> I wonder why mine is just slower then. What sort of figures should I aim for?
12:20:38 <abacathoo> acowley: thanks for your help. I'm guessing HEAD is not stable? I've never used it before.
12:20:53 <acowley> TheLemonMan: what is the objection to Left/Right? You could make your own data type isomorphic to Either with more relevant constructor names if you like.
12:21:17 <lowasser> You can just do the same thing as Either does, of course
12:21:26 <acowley> abacathoo: I stay away from HEAD because if/when you hit a problem it's basically your fault for using an unstable version.
12:21:29 <lowasser> data Foo = FooA AType | FooB BType
12:23:25 <kamatsu> TheLemonMan, if you really really need subtyping, it can be emulated in a number of ways, but I think you just want Either here
12:23:31 <acowley> kamatsu: aim for linear speedup. If you're constructing an example, just make the tree really big, or the mapped operation sufficiently non-trivial, and check strictness.
12:23:53 <abacathoo> acowley: great... I don't think I'll be able to wait for the new version to come out, i'm working to a class deadline... the thing is I have a load of default methods that depend on the default classes, so I can't think of how I can get round the problem
12:24:30 <TheLemonMan> i would need many cascaded Either in that way
12:24:39 <TheLemonMan> i think ill just redesign the function
12:24:48 <hpaste_> sanjoyd pasted “Solution to http://en.wikibooks.org/wiki/Haskell/GADT” at http://hpaste.org/67231
12:24:49 <acowley> abacathoo: in that case, sally forth into the land of HEAD brave Haskeller!
12:25:10 <sanjoyd> I'm trying to implement safeTail, is this a good way to do it?
12:25:17 <sanjoyd> Or is there a better way I've overlooked?
12:25:25 <Luke> I don't understand why Conduit.List (drop) is a Sink and not a Conduit. What's the point of dropping inputs if I cant get the leftover inputs?
12:25:44 <abacathoo> acowley:  I got a bad feeling about this, thanks for your help pal
12:26:05 <elliott> Luke: because you do (drop i >> etc)
12:27:03 <adamt> I know i asked already, but could somebody maybe explain what and why the type sig of a function like this would be (VehicleId as argument, always returning () )?: postRefillsR vehicleId = do [snip snip] return ()
12:27:44 <Luke> elliott: ah right - the inputs are still in the monad. I was thinking they'd be returned for some reason. thanks
12:28:37 <luite> adamt: sorry I missed the question, the type sig would be postRefillsR :: VehicleId -> Handler () ?
12:28:53 <Luke> elliott: well maybe I'm still confused... can I do (drop 1 >> filter f) ?
12:29:10 <elliott> Luke: yes (I think)
12:29:16 <sanjoyd> Moreover, I don't understand what "Example: A different approach" is trying to do.
12:29:24 <elliott> Luke: thanks to the unified Pipe instance
12:29:28 <Luke> elliott: I don't think so because drop is a Sink and filter needs a Conduit
12:29:33 <a7x> Building semigroups-0.8.3... <- Fails, may someone help me with this error?
12:29:34 <sanjoyd> There, "safeHead $ silly 5" throws a type error.
12:29:38 <elliott> Luke: I do think so, because they're all type aliases for Pipe.
12:29:49 <Luke> elliott: Basically the input type of the conduit is void for drop but not for filter
12:30:03 <adamt> luite: What if it didn't take an argument? Would it just be postRefillsR :: Handler ()      ?
12:30:12 <Luke> elliott: right... but look at the raw Pipe types... the Void doesn't line up from drop to filter
12:30:27 <luite> adamt: VehicleId would be the parameter, it depends on the database backend you use (integers for sql, object id for mongodb), you usually work in the Handler monad for these things, and you return ()
12:30:38 <luite> adamt: yeah
12:30:40 <adamt> (i think i've tried too many different things today, so i end up getting more confused than good is. :)
12:30:52 <elliott> Luke: oh, hmm
12:30:55 <elliott> Luke: ugh
12:31:04 <elliott> Luke: yeah, I don't know how you're meant to use drop. ask snoyman :P
12:31:06 <Luke> elliott: so I can't see how drop is useful =)
12:31:10 <Luke> ok thanks
12:31:19 <elliott> ah
12:31:22 <elliott> Luke: you can sinkToPipe (drop 1) >> filter f
12:31:24 <elliott> but that's hideous
12:31:26 <elliott> there must be a better way :p
12:31:27 <adamt> luite: Great, it works. One less warning in the output. :)
12:31:29 <EvanR> > drop 1 [1, 2, 3, 4]
12:31:30 <lambdabot>   [2,3,4]
12:31:40 <Luke> elliott: at leaset that works for now =)
12:31:40 <Luke> thanks
12:31:47 <luite> adamt: it would not necessarily be in the Handler monad (could be Widget for example, if you do widgetty things), that depends on the other things you do inside the do ...
12:32:00 <Luke> EvanR: if that was directed at us, we're talking about Conduit drop
12:32:05 <EvanR> oh
12:32:20 <kamatsu> I think the time taken to allocate my data structure is outweighing the time taken to actually perform the (relatively straightforward) parallel computation
12:32:48 <EvanR> fuck parallel processing
12:32:49 <Luke> elliott: where do you even see sinkToPipe?
12:32:53 <EvanR> its the next AI
12:32:55 <adamt> luite: Yeah, of course. Although I'm still looking forward to the day where the path to complete understanding of monads will be lit for me. :)
12:33:08 <elliott> Luke: Data.Conduit.Internal
12:33:11 <elliott> (a poor module name imo)
12:33:18 <Luke> elliott: hahaha ok thanks
12:33:23 <Luke> yeah definitely - i wouldn't look there
12:33:29 <Luke> maybe he thought we wouldn't need that
12:33:35 <EvanR> adamt: theres nothing to understand
12:34:48 <kamatsu> adamt, for me the understanding of monads only came after I learnt arrows and kleisli composition
12:34:57 <kamatsu> then the monad laws suffice to say kleisli arrows form a category
12:35:04 <EvanR> xD
12:35:25 <blackdog> kamatsu: there are many paths to enlightenment :)
12:35:35 <adamt> Yeah that sounds most delightful. ;)
12:35:52 <luite> adamt: don't hesitate to (re)ask this kind of questions in #yesod btw
12:36:01 <luite> since the channel is a bit quieter
12:36:21 <kamatsu> what's a fairly computation-heavy thing I can do to an Integer?
12:36:26 <adamt> luite: I just feel i'm asking way too much, and i try to ask in the channel i think is the best fit. But what do i know? :)
12:36:30 <kamatsu> (preferably already in the standard library)
12:36:37 <td123> kamatsu: check if it's a prime :P
12:36:48 <EvanR> find the divisors
12:36:58 <kamatsu> any of these already in base?
12:37:11 <EvanR> > divisors 10
12:37:12 <lambdabot>   Not in scope: `divisors'
12:37:27 <luite> adamt: nah just ask, most people there can answer this kind of questions
12:37:30 <monochrom> f n = f (n-1) is fairly computation-heavy. supply your base case.
12:38:04 <a7x> cabal install semigroups -> Data/List/NonEmpty.hs:115:4:    Can't make a derived instance of `Data (NonEmpty a)'       (You need -XDeriveDataTypeable to derive an instance for this class)    In the data type declaration for `NonEmpty'
12:38:09 <monochrom> if you want a fork bomb, f n = f (n-1) + f (n-1) and add a few par's
12:38:25 <adamt> luite: Yeah but it mostly seems like you're the one answering questions in #yesod, and i don't want to burden you too much, heh. ;)
12:39:01 <kamatsu> monochrom, I'd rather have something that at least looks kinda practical
12:40:05 <monochrom> Integer is not very practical to begin with, if "practical" = "useful"
12:40:23 <kamatsu> monochrom, it's for a student's exercise
12:40:33 <kamatsu> i'd rather they had some computational result to look at
12:40:51 <kamatsu> not just the same number they put in
12:41:02 <monochrom> ok, look, {heavy, practical, in the standard library, for students} is full of contradictions. please scale back your requirements
12:41:13 <luite> adamt: I try to answer questions when i think that they might go unanswered otherwise :)
12:41:25 <kamatsu> okay, subtract in standard library, but add short
12:41:47 <monochrom> the main conflict is between practical and for students
12:42:01 <kamatsu> practical may not be the right choice of words
12:42:06 <monochrom> also, if you add short, it also conflicts with practical
12:42:24 <kamatsu> but, perhaps something that does not simplify to a no-op
12:42:49 <monochrom> f n = f (n-1) + f (n-1) is not a no-op if you choose a good base case
12:44:55 <monochrom> factoring and/or primality tests are interesting too. use a dumb algorithm if you want short
12:45:13 <elliott> Is there a decent (f,z) to distinguish foldl from foldl'? Involving error, presumably.
12:45:24 <elliott> Er, (f,z,xs) that is.
12:47:16 <monochrom> since the python tutorial is not ashamed of a fibonacci example (to my surprise), you should not be ashamed of it either. do tell the students, "the python tutorial has fibonacci too, looks like real world programmers like it afterall"
12:47:55 <kamatsu> haha
12:48:47 <EvanR> use an example featuring zoo animals and inheritance
12:49:27 <Feuerbach> > foldl (flip const) () [undefined,()]
12:49:30 <lambdabot>   ()
12:49:34 <Feuerbach> > foldl' (flip const) () [undefined,()]
12:49:35 <lambdabot>   *Exception: Prelude.undefined
12:49:36 <kamatsu> okay, so computing factorial on a bunch of numbers in a binary tree with a parallel cutoff
12:49:43 <Feuerbach> elliott: ^^
12:49:47 <kamatsu> I just can not get any speedup
12:50:15 <monochrom> no speedup between -N1 and -N2? and you have enough pars?
12:51:06 <leino> is there a typeclass for types which are "listable" i.e. a such that there is listAllElements :: [a] ?
12:51:08 <kamatsu> my mistake, the speedup is very slight between -N1 and N2
12:51:14 <kamatsu> everything after that is much worse
12:51:18 <heatsink> leino, Traversable
12:51:35 <kamatsu> a fraction of a second less than N1 for N2
12:51:58 <monochrom> Integer is fairly allocation-heavy too, mallocing and calling GMP etc
12:52:07 <kamatsu> I might switch everything to Int
12:52:11 <heatsink> oh, actually, it's Foldable
12:52:38 <heatsink> :t foldMap return
12:52:39 <lambdabot> Not in scope: `foldMap'
12:52:51 <heatsink> :m +Data.Foldable
12:52:53 <heatsink> :t foldMap return
12:52:54 <lambdabot> Not in scope: `foldMap'
12:53:02 <heatsink> lambdabot, why are you not ghci?
12:53:08 <kamatsu> N1: 5.8, N2: 5.5, N3: 6.7
12:53:27 <kamatsu> (with Int now)
12:53:40 <monochrom> I should try pollard's rho on several sparks some day
12:53:42 <kamatsu> *N3 -> N4
12:54:17 <kamatsu> this is with a depth 20 tree and a cut off of just 4
12:55:39 <leino> heatsink: I don't think that's what I want. how do I write listAllElements :: [t] ? I want to list all elements *representable by the datatype*
12:56:01 <kamatsu> leino, not possible, not all types are enumerable
12:56:09 <kamatsu> for example, functions
12:56:16 <leino> ...hence the need for the typeclass
12:56:31 <heatsink> leino, foldMap return :: Foldable t => t a -> [a]
12:56:45 <heatsink> foldMap basically injects the contents of t into a monoid
12:56:54 <heatsink> and [a] is a monoid
12:57:15 <kamatsu> heatsink, I don't think that helps
12:57:28 <kamatsu> heatsink, leino has no traversable container here
12:57:31 <monochrom> there is no type class yet to do what you ask for. but you can create one and hope it becomes popular
12:57:48 <heatsink> Oh, sorry
12:57:52 <kamatsu> leino, do you mind explaining your use case?
12:57:53 <monochrom> Data.Ix comes close, actually. but just close.
12:57:55 <heatsink> You were talking about all elements of the type.
12:58:37 <leino> kamatsu: sure. I have a datatype to represent outcomes in games: data Winner = Neither | Both | Only Player, where data Player = First | Second
12:59:00 <monochrom> Enum also comes close, actually
12:59:01 <leino> I run some games and get a list of Winners
12:59:17 <heatsink> If your type is in Enum and Bounded, you can write [minBound .. maxBound]
12:59:38 <geekosaur> heatsink, this sounds more like a notional deepEnum
12:59:45 <geekosaur> hm, maybe
12:59:59 <geekosaur> nemmind me, still waking up
13:00:26 <leino> and now I want to write a function summarize :: Listable l => [l] -> [(l, Int)] which counts the number of distinct elements in a given list
13:00:48 <kamatsu> alright... so why do you need a list of everything in a type?
13:00:51 <leino> Winner should be an instance of "Listable"
13:01:07 <kamatsu> can't you just sort the list?
13:01:09 <geekosaur> no, I was right the first time; Enum only applies to nullary contructors
13:01:11 <kamatsu> and group equal stuff?
13:01:36 <leino> kamatsu: yeah I guess so
13:01:41 <monochrom> Eq should be enough for tallying, though slow. add Ord or Hashable for faster tallying
13:01:48 <heatsink> geekosaur, it's possible to write Enum instances for other types
13:02:01 <leino> monochrom: in this case, tallying is the least costly operation :)
13:02:12 <geekosaur> sure, it's just mind-dumbing
13:02:17 <geekosaur> numbing
13:02:55 <monochrom> the power of the XY Problem cannot be underestimated
13:03:08 <leino> huh?
13:03:10 <kamatsu> map (head &&& length) . group . sort $ [1,1,1,3,2,1,2,2]
13:03:15 <kamatsu> yep, works
13:03:52 <lispy> http://www.perlmonks.org/index.pl?node_id=542341
13:03:53 <monochrom> http://www.perlmonks.org/index.pl?node_id=542341
13:04:26 <kamatsu> :t (&&&)
13:04:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
13:04:30 <lispy> ?quote stereo
13:04:31 <lambdabot> Anonycale says: Welcome to #haskell, where your questions are answered in majestic stereo!
13:04:32 <kamatsu> cool, i can demonstrate with lambdabot
13:04:44 <lispy> :t head &&& length
13:04:44 <lambdabot> forall c. [c] -> (c, Int)
13:04:48 <monochrom> of course, I like the description "Men." the most :)
13:04:53 <leino> monochrom: fair enough, but I cant write a general tally function unless I have Listable :)
13:04:59 <kamatsu> > map (head &&& length) . group . sort $ [1,1,1,3,2,1,2,2]
13:05:01 <lambdabot>   [(1,4),(2,3),(3,1)]
13:05:18 <kamatsu> leino, this tally function is very general:
13:05:27 <kamatsu> :t map (head &&& length) . group . sort
13:05:28 <lambdabot> forall a. (Ord a) => [a] -> [(a, Int)]
13:05:37 <lispy> :t map (head &&& genericLength) . group . sort
13:05:38 <lambdabot> forall a i. (Num i, Ord a) => [a] -> [(a, i)]
13:05:57 <kamatsu> well, even more general
13:06:02 <monochrom> actually, I don't see how Listable would help. with Listable but no Eq, you still can't tally. with Eq, you don't need Listable.
13:06:02 <lispy> But...
13:06:26 <lispy> Oh wait, you do sort the list. n/m my "But..."
13:06:54 <leino> monochrom: I mean I cant write it the way I wanted to write it...
13:06:54 <lispy> You could write a more efficient version by writing a group . sort that is smarter
13:08:03 <leino> kamatsu: your solution would work. but what about laziness (lazyness)?
13:08:12 <kamatsu> what about it?
13:08:25 <monochrom> if you're counting, it cannot be too lazy
13:08:36 <leino> map (head &&& length) . group . sort $ [1 .. ]
13:08:47 <leino> uh oh
13:08:49 <kamatsu> you've got an infinite list of game results??
13:09:20 <kamatsu> it doesn't make computational sense to count the number of some element x in an infinite list
13:09:29 <monochrom> is tallying an infinite list meaningful to begin with?
13:09:32 <leino> no I dont, but laziness is good for other things than lazy lists
13:09:51 <kamatsu> i'm not denying that
13:09:52 <acowley> What if I can prove that the generator of the infinite list won't produce any more x's?
13:10:04 <leino> I mean infinite lists, not lazy lists
13:10:27 <monochrom> ok sure, is tallying a list of n items supposed to take less than Θ(n) time, even with laziness?
13:10:38 <acowley> I have some work involving coinductive proofs in Coq about streams of states produced by a controller.
13:11:17 <kamatsu> acowley, fun. I'm an Agda man myself, but I've never messed around with codata before.
13:11:18 <leino> monochrom: of course not, Im not thinking about performance
13:11:56 <acowley> kamatsu: the trick is finding something interesting to prove :/
13:12:13 <kamatsu> acowley, I'm formalising OutsideIn(X) in Agda
13:12:20 <kamatsu> (for my honours thesis)
13:12:24 <leino> monochrom: say I want a running tally of the results while Im still adding to the list of results
13:12:37 <acowley> kamatsu: Well that's pretty interesting to this audience!
13:12:43 <kamatsu> leino, then you'll need IO to observe that
13:12:56 <kamatsu> acowley, I hope so :)
13:13:00 <monochrom> then the type "[a] -> [(a,Int)]" is clearly inadequate
13:14:23 <monochrom> or it is adequate, but I am not going to give it the full list. I'm going to give it (take 10 the_full_list)
13:14:31 <kamatsu> the goal is to get a really solid formalisation of OI with all the not-so-formally specified stuff nailed down
13:14:39 <kamatsu> do the soundness and principality proofs
13:14:52 <kamatsu> and then that way we have a machine checked body of proofs to check future extensions against
13:15:17 <kamatsu> should prevent future issues in getting good inference and preserving soundness when enabling various combinations of compiler extensions
13:16:10 <monochrom> eventually, I will want "[(a,Int)] -> [a] -> [(a,Int)]", which means, I have some tallies of the previous chunks, now I have another chunk, I want to accumulate tallies
13:17:44 * hayashi wonders how to get Text.PrettyPrint's nest to nest inwards from the start of the last line rather than the end
13:18:44 <leino> monochrom: I think it would be nicer to work with tables instead of [(a,Int)], though
13:19:41 <leino> tally :: [a] -> (a -> Int)
13:19:48 <monochrom> sure, s/[(a,Int)]/AbstractTable a Int/, same difference
13:20:16 <kamatsu> leino, to prevent building complicated functions, consider using a Data.Map
13:20:16 <leino> and then "partialTallies :: [a] -> [a -> Int]"
13:20:39 <leino> to get laziness back
13:21:04 <kamatsu> why a list of functions from a -> Int?
13:21:19 <kamatsu> what purpose would they serve?
13:21:20 <leino> data Tally a = Tally (a -> Int)
13:21:31 <EvanR> so you can use map map
13:21:36 <EvanR> :t map map
13:21:37 <lambdabot> forall a b. [a -> b] -> [[a] -> [b]]
13:21:38 <monochrom> the nth item of the answer list is the tally of the first n items of the input list
13:22:24 <elliott> > foldl (const (const ())) undefined [1,2,3]
13:22:25 <lambdabot>   ()
13:22:25 <kamatsu> oh
13:22:26 <elliott> > foldl' (const (const ())) undefined [1,2,3]
13:22:26 <lambdabot>   ()
13:22:31 <elliott> huh?
13:22:37 <elliott> oh
13:22:47 <elliott> > foldl' (\a _ -> a) undefined [1,2,3]
13:22:48 <lambdabot>   *Exception: Prelude.undefined
13:22:57 <elliott> > foldl (\a _ -> a) undefined [1,2,3]
13:22:58 <lambdabot>   *Exception: Prelude.undefined
13:23:04 <elliott> hmm, this is tricky :P
13:23:15 <elliott> > foldl (\a b -> if b == 3 then () else a) undefined [1,2,3]
13:23:16 <lambdabot>   ()
13:23:17 <elliott> > foldl' (\a b -> if b == 3 then () else a) undefined [1,2,3]
13:23:17 <hpc> > foldl (\_ a -> a) undefined [1..10]
13:23:17 <lambdabot>   *Exception: Prelude.undefined
13:23:18 <lambdabot>   can't find file: L.hs
13:23:19 <elliott> > foldl' (\a b -> if b == 3 then () else a) undefined [1,2,3]
13:23:20 <lambdabot>   *Exception: Prelude.undefined
13:23:21 <hpc> > foldl (\_ a -> a) undefined [1..10]
13:23:22 <lambdabot>   10
13:23:26 <hpc> > foldl' (\_ a -> a) undefined [1..10]
13:23:27 <lambdabot>   10
13:23:34 <nart> ciao :)
13:23:34 <Feuerbach> elliott: have you seen my reply above?
13:23:39 <hpc> > foldl' (\_ a -> a) undefined (undefined : [1..10])
13:23:40 <lambdabot>   *Exception: Prelude.undefined
13:23:45 <hpc> > foldl (\_ a -> a) undefined (undefined : [1..10]) -- AHA!
13:23:46 <lambdabot>   10
13:23:48 <elliott> Feuerbach: oh, no -- aha, seen it, thanks!
13:24:02 <nart> how can i forkIO something like that "bsrc C.$$ sinkFile fp"
13:24:39 <monochrom> "ciao" is a good-bye IIRC
13:24:49 <elliott> nart: http://hackage.haskell.org/packages/archive/lifted-base/0.1.0.3/doc/html/Control-Concurrent-Lifted.html?
13:25:09 * hayashi tries the Wadler-Leijen pretty printer instead
13:25:32 <nart> monochrom: ciao is "hi or bye" in italian
13:25:49 <nart> it has a double meaning :)
13:25:58 <monochrom> darn
13:26:19 <monochrom> no wonder I saw an Italian restaurant having the name "Ciao"
13:26:30 <nart> thanks elliott
13:29:17 <nart> mmm i get this error, threadWait: invalid argument (Bad file descriptor)
13:29:37 <nart> what does it mean ? :S
13:29:43 <monochrom> yikes. some other thread probably closed it prematurely
13:30:13 <nart> ahhhh got it
13:30:21 <monochrom> what was it?
13:30:24 <nart> forgot to put a sleep in the main
13:30:28 <monochrom> haha
13:31:47 <shirt> what happens to threadDelay with a negative argument?
13:32:13 <hpc> shirt: time travel
13:32:25 <monochrom> I think it detects the negative number and aborts
13:32:38 <leino> or does nothing?
13:43:50 <mekeor`> Are there non-histrical reasons why Monad is not a sub-typeclass of Applicative? (I probably once asked this question but forgot the answers… :/)
13:44:23 <crdueck> hello, i'm very new to the language, but i'm really enjoying how easy it is to express mathematical problems using haskell. one question, i have 3 defined series, how do i filter these lists such that i only get the elements that are in all three lists?
13:44:57 <elliott> mekeor`: some people think we should hold off on adding Applicative as a superclass because there are some typeclasses in-between that we might want instead and we'd have to update all the code again
13:45:00 <elliott> but that's a historical reason too, so... no
13:45:20 <mekeor`> alright.
13:46:20 <mekeor`> crdueck: filter (\e->e`elem`otherList && e`elem`otherOtherList) list -- ?
13:46:43 <hayashi> Hmm, the Wadler-Leijen pretty printer is actually quite awesome
13:47:11 <mekeor`> hayashi: so it should be renamed into awesome-printer, right? =)
13:47:29 <Luke> ozataman_: you around?
13:48:48 <geekosaur> re threadDelay, I just went through the source tree, negative isn't handled --- at least in the threaded path, it effectively behaves as 0
13:49:00 <navaati> hi there
13:51:00 <mekeor`> hi
13:51:09 <dacc_> hello
13:51:22 <byorgey> crdueck: are these lists finite or infinite?  are they sorted?
13:51:43 <keep_learning> Hello all
13:52:00 <keep_learning> I have a data constructor data SMElement a = SMElement {-#UNPACK#-}!Int  {-#UNPACK#-}!Int {-#UNPACK#-}!a
13:52:02 <crdueck> byorgey: they are infinite, and sorted. they are triangle, pentagonal, and hexagonal number series respectively
13:52:41 <keep_learning> and I am creating a list creatMat a ( ( i , val ) : xs ) =   ( ( SMElement i a val ) : creatMat a xs )
13:53:10 <keep_learning> so will this list will be evaluated during the  function call or I have to pass this list to deepseq to fully evaluate ?
13:53:14 <byorgey> crdueck: ok. in that case mekeor`'s solution won't work because 'elem' will just go off to infinity looking for things that aren't there.
13:53:32 <a7x> hi i'm getting this error, while updating cabal: http://pastebin.com/dWTrtdsN may someone help me?
13:53:34 <mauke> The paste dWTrtdsN has been copied to http://hpaste.org/67243
13:53:41 <byorgey> crdueck: what I would do is first write a function to find the intersection of two sorted lists:  intersection :: Ord a => [a] -> [a] -> [a]
13:53:58 <byorgey> crdueck: intersection (x:xs) (y:ys) | x < y = ...  | x == y = ...  etc.
13:54:17 <byorgey> crdueck: then you can just call that function twice to find elements in all three lists
13:54:43 <crdueck> byorgey: alright, i'll give it a shot
13:54:52 <byorgey> crdueck: however, you have to write 'intersection' yourself, I don't know of a nice way to do it using just stuff in the standard libraries
13:55:05 <byorgey> though it's probably on Hackage somewhere
13:55:49 <byorgey> ah, so it is: http://hackage.haskell.org/package/data-ordlist
13:55:50 <byorgey> =)
13:57:35 <keep_learning> Any one please
13:58:07 <shirt> is there a name for: flip (.)
13:58:14 <elliott> byorgey: that's just list with Ord, though
13:58:17 <elliott> not sorted
13:58:24 <fmap> :t >>>
13:58:24 <lambdabot> parse error on input `>>>'
13:58:30 <fmap> :t (>>>)
13:58:31 <lambdabot> forall (cat :: * -> * -> *) a b c. (Control.Category.Category cat) => cat a b -> cat b c -> cat a c
13:59:35 <dacc> hmm, so, this one confuses me: let villain = (28, "chirs") in fst villain
13:59:38 <dacc> seems recursive
13:59:49 <hpc> dacc: it isn't
13:59:52 <hpc> the syntax for let is
13:59:59 <hpc> "let definitions in expression"
14:00:09 <hpc> "definitions" are in scope only for "expression"
14:00:17 <hpc> so it's the same as
14:00:23 <hpc> > fst (28, "chirs")
14:00:24 <lambdabot>   28
14:00:35 <dacc> hmm
14:00:39 <hpc> it's recursive if you have something like
14:01:01 <hpc> "let villain = (something that uses villain) in whatever"
14:01:24 <EvanR> > let x = 1:x in x
14:01:25 <lambdabot>   [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
14:01:32 <dacc> ah ok
14:02:35 <dacc> feels like it first binds (28,"chirs") to villain, then assigns the result of fst villain to villain
14:02:49 <EvanR> first it evaluates villain
14:02:59 <EvanR> er
14:03:01 <EvanR> first it evaluates fst villain
14:03:04 <nart> what is the best way to block till 4 threads have finished their jobs and then execute a function passing to it the result of the threads ?
14:03:24 <hpc> nart: 4 MVars
14:03:26 <elliott> dacc: no, it evaluates fst villain, where villain is (28,"chirs")
14:03:32 <EvanR> which is (\(x,_) -> x) villain
14:03:33 <elliott> there's no "assigning"
14:03:38 <hpc> make 4 empty MVars, pass one to each thread
14:03:44 <hpc> when threads finish, fill mvars
14:03:46 <byorgey> elliott: eh, what?
14:03:57 <elliott> byorgey: well, not in the sense that you can 'assign the result of fst villain to villain"
14:03:59 <hpc> main thread waits on all 4, then uses what's inside to do the final function
14:04:01 <byorgey> elliott: (re: data-ordlist)
14:04:03 <elliott> oh
14:04:05 <dacc> oh i see, i'm sorry
14:04:06 <nart> hpc: i see, thanks
14:04:11 <dacc> i thought this was about variable assignment
14:04:14 <elliott> dacc: no need to be sorry :)
14:04:17 <rasfar> keep_learning: I don't know, but could you can use the value "undefined" to write a test to see?
14:04:18 <elliott> well, it is variable assignment
14:04:24 <elliott> but variables never change in haskell, so it can't be what you said
14:04:24 <dacc> for the scope of body, though
14:04:27 <EvanR> you know what happens when you assign
14:04:30 <dacc> not for after the line runs
14:04:34 <elliott> byorgey: well, you said "intersection of sorted list"
14:04:41 <elliott> byorgey: which isn't "intersection of two lists whose elements are Ord"
14:04:42 <EvanR> you make an ass out of ign
14:04:46 <elliott> which is what data-ordlist gives
14:04:47 <shirt> fmap: thanks! should i import that from Control.Category or Control.Arrow?
14:04:55 <byorgey> elliott: but data-ordlist has the former.
14:05:04 <keep_learning> rasfar, Thank you
14:05:09 <byorgey> elliott: read the docs.
14:05:14 <rasfar> np :)
14:05:19 <EvanR> elliott: variables never change?
14:05:20 <dacc> heh
14:05:20 <elliott> byorgey: hmm, i did... maybe i missed it
14:05:47 <elliott> byorgey: are you referring to isect? because that looks like the latter
14:05:50 <EvanR> forM_ [1,2,3] (\i -> print i)
14:05:53 <elliott> oh, hmm
14:06:01 <elliott> I misinterpreted "ordered list", never mind :)
14:06:07 <elliott> EvanR: i doesn't change, it varies ;)
14:06:13 <EvanR> oh OKAY
14:06:16 <byorgey> elliott: see the first para at the top =)
14:06:34 <fmap> shirt: doesn't matter. Control.Arrow re-exports Control.Category.(>>>)
14:06:45 <elliott> yeah, right
14:06:52 <elliott> bit confusing to mix them both in one module
14:07:43 <EvanR> @src print
14:07:43 <lambdabot> print x = putStrLn (show x)
14:08:04 <EvanR> ewww pointlesslessness
14:09:32 <nart> what's the best way to join 2+ big files ?
14:09:37 <EvanR> cat
14:09:59 <nart> EvanR: i know it, but i would like to it in haskell :D
14:10:05 <nart> *to do it
14:10:06 <EvanR> shell exec
14:10:36 <dacc> heh
14:10:40 <hpc> :t mapM hGetContents
14:10:40 <lambdabot> Not in scope: `hGetContents'
14:10:53 <EvanR> lazy bytestring
14:10:55 <hpc> hmm
14:10:59 <keep_learning> rasfar, creatMat _ []  = [undefined]  and Its compiling fine. When I am running the output says "Main: Prelude.undefined"
14:11:24 <keep_learning> I am just calculating the length of list
14:11:28 <sanjoyd> nart: I don't think Haskell is the ideal tool for hta tjob.
14:11:30 <keep_learning> not evaluating it
14:11:32 <sanjoyd> *that job
14:11:49 <EvanR> do it in malbolge
14:12:10 <sanjoyd> But I guess you can write a Haskell program to generate that malbolge program.
14:12:27 <sanjoyd> Which you can then compile and run using industry standard malbolge compilers.
14:12:34 <hpaste_> keep_learning pasted “undefined” at http://hpaste.org/67244
14:12:40 <EvanR> i use my hardware malbolge
14:13:17 <hpaste_> keep_learning annotated “undefined” with “undefined (annotation)” at http://hpaste.org/67244#a67245
14:14:12 <sanjoyd> keep_learning: createMat _ [] = []
14:14:16 <sanjoyd> Not [undefined]
14:14:26 <sanjoyd> keep_learning: why were you using undefined in the first place?
14:14:33 <sanjoyd> It isn't like null.
14:14:42 <EvanR> :t null
14:14:43 <lambdabot> forall a. [a] -> Bool
14:14:47 <sanjoyd> It is more like (*(int *)0)++
14:15:00 <keep_learning> sanjoyd, to test if its lazy or evaluated during the function call
14:15:16 <sanjoyd> Which function call?
14:15:43 <sanjoyd> Anyways, it seems like you know what you're doing. :)
14:15:55 <EvanR> undefined is like segfaulting?
14:16:01 <sanjoyd> Why not?
14:16:27 <keep_learning> sanjoyd, creatMat function
14:16:45 <EvanR> you never know when either will occur...
14:17:00 <keep_learning> actually I have declared my data type data SMElement a = SMElement {-#UNPACK#-}!Int  {-#UNPACK#-}!Int {-#UNPACK#-}!a
14:17:07 <sanjoyd> Oh, okay.
14:17:14 <sanjoyd> I missed that part.
14:17:19 <keep_learning> and I wanted to know if its evaluating during the call
14:17:34 <keep_learning> or I have to evaluate it using deepseq
14:17:44 <keep_learning> so looks like its evaluating
14:17:50 <keep_learning> Am I correct ?
14:17:51 <sanjoyd> Yeah, that a legitimate use of undefined, I think. :)
14:18:13 <keep_learning> >seq [1,undefined] ( return () )
14:18:32 <sanjoyd> > seq [1,undefined] ( return () )
14:18:33 <lambdabot>   No instance for (GHC.Show.Show (m ()))
14:18:33 <lambdabot>    arising from a use of `M575653950...
14:18:45 <sanjoyd> :t seq
14:18:46 <lambdabot> forall a t. a -> t -> t
14:18:48 <Itkovian> evening
14:18:51 <sanjoyd> > seq [1,undefined] 10
14:18:52 <lambdabot>   10
14:18:53 <keep_learning> > deepseq [1,undefined] ( return () )
14:18:54 <lambdabot>   Not in scope: `deepseq'
14:18:54 <Itkovian> jaspervdj: al over uw mistake?
14:19:16 <keep_learning> > Control.DeepSeq.deepseq [1,undefined] ( return () )
14:19:17 <lambdabot>   Not in scope: `Control.DeepSeq.deepseq'
14:19:25 <sanjoyd> keep_learning: I think seq evaluates only till the WHNF, but deepseq evaluates it completely.
14:19:52 <mysticc> Is there any function to check given substring in the given string /
14:20:03 <EvanR> yes
14:20:06 <mysticc> @hoogle contains
14:20:07 <lambdabot> No results found
14:20:13 <mysticc> EvanR: Which one
14:20:45 <keep_learning> sanjoyd, On ghci prompt for deepseq [1,undefined] ( return () )  I am getting Exception: Prelude.undefined
14:20:54 <EvanR> mysticc: its in a library
14:21:05 <EvanR> do you want bytestring search or
14:21:08 <EvanR> arbitrary list search
14:21:09 <keep_learning> sanjoyd, On ghci prompt for seq [1,undefined] ( return () )   I am getting no error
14:21:10 <sanjoyd> keep_learning: yeah, so it presumably crashes when evaluating [1, undefined] completely.
14:21:17 <mysticc> EvanR: normal String
14:21:34 <EvanR> get list utils
14:21:39 <keep_learning> So it means my  list is evaluated during the call of function http://hpaste.org/67244
14:21:42 <keep_learning> ?
14:22:06 * hackagebot crypto-conduit 0.3.1 - Conduit interface for cryptographic operations (from crypto-api).  http://hackage.haskell.org/package/crypto-conduit-0.3.1 (FelipeLessa)
14:22:14 <keep_learning> I am just calling length  function on list return by creatMat
14:22:29 <EvanR> mysticc: subIndex :: Eq a => [a] -> [a] -> Maybe Int
14:22:30 <sanjoyd> Yeah, that is what I asked when I said which function call. ;)
14:22:49 <sanjoyd> > length [1, undefined]
14:22:50 <lambdabot>   2
14:23:00 <sanjoyd> Yeah, so I guess you're evaluating.
14:23:06 <sanjoyd> *evaluating strictly
14:23:37 <keep_learning> sanjoyd, Yes  and exploring every day some new in Haskell :)
14:24:24 <EvanR> mysticc: bytestrings will be way more efficient here, the relevant module is Data.ByteString.Search
14:25:17 <EvanR> indices :: ByteString -> ByteString -> [Int]
14:27:04 <EvanR> also includes methods for splitting, replacing, etc
14:31:05 <vhd> can I get random without IO monad?
14:31:39 <vhd> or rather I need random, but fear monads.
14:31:42 <otters> not without unsafePerformIO
14:31:48 <otters> or whatever it's called
14:31:55 <geekosaur> the only thing in IO is the standard seed, I believe
14:32:08 <copumpkin> sure you can
14:32:10 <EvanR> vhd: you can get random number generators without IO
14:32:11 <otters> oh
14:32:17 <EvanR> you also dont need IO for a seed
14:32:35 <vhd> anywhere I may see example code? or terms i can throw at google?
14:32:45 <EvanR> what are you really trying to do
14:32:51 <EvanR> 'get random' sounds funny but isnt descriptive
14:33:25 <vhd> I need to write a monte carlo tree traversing algorithm, so thats why I need random (numbers)
14:33:35 <EvanR> yeah no need for IO
14:33:37 <mekeor`> 'next' is pure, isn't it?
14:34:07 <EvanR> the standard library RNGs are pure and not monadic
14:34:18 <mekeor`> class RandomGen g where next :: g -> (Int, g); ...
14:35:26 <geekosaur> (well, it's a monad, just not phrased as such; that is State)
14:35:52 <geekosaur> (but if you're going to be pointlessly afraid of monads you're not going to get very much done)
14:35:53 <EvanR> its also a turing machine
14:35:56 <EvanR> big woop
14:36:09 <EvanR> you dont need and may not want monad interface to an rng
14:36:19 <elliott> you really do want a monda interface to RandomGen
14:36:25 <elliott> *monad
14:36:27 <elliott> threading the state explicitly is a huge pain
14:36:29 <elliott> that's why MonadRandom exists
14:36:33 <vhd> geekosaur, not pointlessly afraid I have tried but it just goes over my head.
14:37:51 <mekeor`> > map fst $ iterate (next . snd) (1, mkStdGen 5)
14:37:53 <lambdabot>   [1,199392,1508431622,1679949200,767230921,1593103527,247695788,503234447,15...
14:38:44 <mekeor`> @pl \f x -> f x x
14:38:44 <lambdabot> join
14:39:03 <mekeor`> @type join
14:39:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
14:39:16 <mekeor`> i do not understand this.
14:39:38 <mekeor`> > join (*) 2
14:39:39 <lambdabot>   4
14:40:08 <mekeor`> wait. is (->) a monad?
14:40:17 <geekosaur> vhd, my point is that if you understand what next does, you understand the State monad
14:40:28 <fmap> ((->) a) is
14:40:31 <geekosaur> mekeor`, ((-> e) is a monad
14:40:43 <geekosaur> that.  sigh
14:41:17 * mekeor` just read "fmap ((->) a) is" -- lol
14:42:38 <EvanR> fmap doesnt just speak code, he is code
14:43:21 <mekeor`> heh
14:44:53 <mekeor`> aah:  (a -> a -> a) = ((->) a ((->) a a)) = m (m a) -- got it.
14:45:16 <cleardance> I have a hole in my CV for about 2 years when I was depressed and unemplyed. I am called to an interviiew though. The problem is the hole is very recent. I was depressed(not diagnosed) and I just cant give a good answer to what i did those years. what would u say in an interview?
14:45:38 <rasfar> sorry keep_learning, i was cooking/babysitting and missed the last episode :)
14:45:40 <EvanR> explain how awesome you are
14:45:45 <hpc> cleardance: say it was classified ;)
14:45:47 <EvanR> and say if you dont want to hire me, go fuck yourself
14:45:51 <byorgey> cleardance: just be honest.
14:45:59 <EvanR> just be a badass
14:45:59 <keep_learning> rasfar,  No problem
14:46:09 <keep_learning> rasfar, you method worked well
14:46:16 <rasfar> great!
14:46:23 <mekeor`> byorgey: be honest: would you be honest?
14:46:24 <keep_learning> rasfar, Thanks again :)
14:46:30 <byorgey> mekeor`: yes, I would.
14:46:34 <rasfar> cheers
14:46:49 <mekeor`> nice
14:47:09 <byorgey> cleardance: I think most employers would much rather have someone honest than someone who papers over difficulties.
14:47:28 <byorgey> cleardance: and if they wouldn't, then it probably wouldn't be much fun working for them.
14:47:47 <mekeor`> byorgey is wise.
14:51:14 <EvanR> its not about your CV its about how you present yourself in the interview
14:51:22 <EvanR> this is not a computer
14:51:39 <vhd> If you have an interview they probably dont care too much about that gap in the cv.
14:52:17 <vhd> btw geekosaur I have bouts where I think I understand, but then realise I dont.
14:54:13 <geekosaur> there is less to understand than you think :)
14:59:00 <tew88> Is it possible to add class constraints to instance declarations? Specifically, I'm struggling with the following: http://pastebin.com/Qkxj0qkP
14:59:03 <mauke> The paste Qkxj0qkP has been copied to http://hpaste.org/67246
14:59:43 <tew88> Err, the n should be an a, too =)
14:59:56 <byorgey> tew88: yes, it is possible
15:00:06 <byorgey> tew88: it doesn't matter what you call the n.
15:00:18 <byorgey> tew88: what exactly are you struggling with?
15:01:45 <tew88> byorgey: GHC is giving me an error that I don't understand with that code. I don't want to have to add instances for all types of number, so figured a Num constraint would solve that for me
15:02:51 <byorgey> tew88: can you paste the error as well?
15:03:32 <byorgey> tew88: oh, you will need an Ord constraint as well, if you want to compare to zero like that
15:03:34 <tew88> byorgey: http://hpaste.org/67247
15:03:47 <tew88> Ahha, I'll try, thanks
15:04:02 <byorgey> tew88: aha, you just need to turn on the FlexibleInstances extension
15:04:32 <byorgey> tew88: oh, hmm, wait, do you have other YesNo instances as well?
15:04:38 <tew88> byorgey: I understood from that solution that what I was doing wasn't strictly correct
15:04:40 <tew88> byorgey: Nope
15:05:13 <byorgey> tew88: FlexibleInstances is a very simple and uncontroversial extension.  Basically the Haskell standard is quite conservative about the sorts of instances that are allowed, for historical reasons
15:05:43 <byorgey> it doesn't mean you're doing something that isn't correct.
15:06:01 <tew88> byorgey: Right, OK. Thank you =)
15:06:04 <byorgey> tew88: if that's the only YesNo instance that will ever exist, that code is fine
15:06:32 <byorgey> otherwise it is going to overlap with any other instances.
15:06:36 <tew88> byorgey: It's not practical code, I'm just learning the ropes
15:07:02 <tew88> byorgey: I see. I'll read some more. Thanks for the help.
15:13:05 <copumpkin> fancy: http://www.haskell.org/ghc/docs/latest/html/libraries/base-4.5.0.0/GHC-Stack.html
15:14:16 <tgeeky> lol
15:14:36 <tgeeky> that's the biggest understatement in Haskell history:   currentCallStack :: IO [ String ] -- returns a '[String]' representing the current call stack. This can be useful for debugging.
15:14:42 <rasfar> @tell dmwit  http://folk.ntnu.no/hammar/explore-hackage/ provides something very similar to what I would have done.  Last updated a year ago though.  And not, itself, on hackage :(
15:14:42 <lambdabot> Consider it noted.
15:16:05 <byorgey> whoCreated :: a -> IO [String]    -- o.O
15:16:52 <elliott> I like how they don't bother to put "unsafe" before these things nowadays.
15:17:02 <elliott> whoCreated sounds awesome, though!
15:17:06 <shachaf> elliott: They put it in the type!
15:18:03 <mekeor`> byorgey: why can't i load GHC.Stack? it's in base actually...
15:18:17 <byorgey> mekeor`: uh, don't ask me!
15:18:33 <elliott> mekeor`: 7.4.1 only
15:18:35 <elliott> or maybe even 7.6?
15:18:37 <geekosaur> I thought anything prefixed with "GHC." was considered inherently unsafe, or at least dubious
15:18:56 <mekeor`> elliott: ah
15:19:28 <blackdog> geekosaur: it might not be the most portable code in the world, i suppose.
15:19:47 <elliott> there's safe but unportable stuff in GHC.
15:20:02 <byorgey> well, base-4.5 only.
15:20:10 <byorgey> base-4.5 comes with ghc 7.4
15:20:14 <mekeor`> ah
15:20:25 <mekeor`> alright.
15:21:27 <dacc> hmm, seems like "> drop 3" should give me back an [a] -> [a], but i get: https://gist.github.com/2417026
15:22:01 <byorgey> dacc: you have to explicitly ask for the type if that's what you want
15:22:09 <byorgey> dacc: try "> :type drop 3"
15:22:29 <elliott> dacc: what that error is saying is, it doesn't know how to display a function of type [a] -> [a]
15:22:39 <elliott> it can only display values, not functions (there wouldn't be much interesting to display)
15:22:42 <dacc> oooh, ok =)
15:22:48 <elliott> (though you can give an instance that makes it print out the type)
15:22:53 <dacc> thanks
15:22:55 <elliott> (for interactive use)
15:24:04 <mekeor`> elliott: how?
15:24:50 <mekeor`> elliott: is there a function ':: a -> String' which returns the type signature or so?
15:26:07 <elliott> mekeor`: instance (Typeable a, Typeable b) => Show (a -> b)
15:26:17 <elliott> Typeable gives you TypeRep which lets you see the type name.
15:26:31 <mekeor`> cool! oO
15:26:39 <dacc> ack, no step > 33 on tryhaskell.org =)
15:26:39 <elliott> (In the case of [a] -> [a], though, it'd extended-default to showing [()] -> [()], which is probably more confusing...)
15:27:13 <hpaste_> keep_learning pasted “parallel strategy” at http://hpaste.org/67248
15:27:36 <sbi_> hi
15:27:39 <mekeor`> hi sbi_
15:27:54 <byorgey> @where lyah
15:27:54 <lambdabot> http://www.learnyouahaskell.com/
15:28:02 <byorgey> dacc: ^^^ you can continue with that =)
15:28:13 <dacc> ah nice, thanks
15:28:29 <keep_learning> i am trying to  evaluate a list  xs using parallel strategy but  this list  is not evaluated due to laziness
15:28:31 <keep_learning> http://hpaste.org/67248
15:29:32 <keep_learning> fun takes a list and increase every element value by 1
15:30:33 <keep_learning> now I am trying to evaluate this  fun [ 1.. 10^6 ) `using` parListChunk ( 500000 ) rdeepseq
15:30:59 <keep_learning> so why is this list is not evaluated ?
15:31:22 <ozgura> keep_learning: what about main = comp `deepseq` return () where comp = fun ...
15:32:38 <keep_learning> ozgura, I am in the impression that it will be evaluated due to parListChunk
15:33:22 <ozgura> once you evaluate comp, it will be. but if comp is never evaluated?
15:34:34 <ozgura> I am not sure though, you've got to try.
15:35:12 <mm_freak> keep_learning: that really looks like a syntax error to me
15:36:18 <keep_learning> mm_freak, Its working fine. let me check it again
15:36:36 <mm_freak> the thing you wrote above
15:38:00 <keep_learning> mm_freak, fun [ 1.. 10^6 ) `using` parListChunk ( 500000 ) rdeepseq ?
15:38:24 <mm_freak> yeah
15:38:27 <keep_learning> mm_freak, Oops put ) instead of ]
15:38:47 <keep_learning> mm_freak,  or is there something else ?
15:39:13 <mm_freak> rather ] instead of ), but i got it now
15:39:38 <mm_freak> sounds like you really want parMap
15:40:02 <keep_learning> mm_freak, I just wanted to understand the strategy
15:40:51 <keep_learning> I am under the impression that parListChunk takes a lazy list  and strategy and evaluates the chunks in parallel
15:41:03 <keep_learning> or I understood something wrong ?
15:42:22 <RenJuan> well it's marked non-portable and experimental
15:42:36 <RenJuan> reading the implementation might be in order
15:43:04 <mm_freak> keep_learning: that's what i'm reading in the doc
15:44:14 <keep_learning> mm_freak, or should i evaluate the list before calling  the fun ?
15:44:38 <mm_freak> no, that would be pretty pointless
15:44:50 <mm_freak> IMO lists are not suitable for parallelizing anyway
15:45:19 <tertl6> why not?
15:45:38 <tertl6> well I take that back
15:45:45 <mm_freak> because traversing a list becomes part of the parallelization
15:45:54 <mm_freak> and that's an inherently sequential process
15:46:05 <tertl6> i see
15:46:14 <tertl6> list = sequence
15:46:39 <mm_freak> that's not the problem, but usually the list is not in memory
15:46:40 <tertl6> but what is u think of a list like an array
15:46:56 <tertl6> multiply every number in the list by 2
15:47:09 <tertl6> list is 1024 numbers
15:47:12 <mm_freak> every list starts out as a thunk and every cons becomes a new thunk
15:47:30 <tertl6> do every mul at once
15:47:32 <mm_freak> so you need to traverse all those thunks before you get a list to parallelize in the first place
15:47:50 <tertl6> oh
15:47:54 <mm_freak> when you evaluate a vector you get a full vector at once
15:48:18 <tertl6> would it work in C?
15:48:31 <tertl6> I am new to Haskell so Im probably thinking in C
15:48:33 <mm_freak> in C you have vectors ("arrays") anyway
15:49:42 <keep_learning> mm_freak,  http://hackage.haskell.org/packages/archive/parallel/latest/doc/html/src/Control-Parallel-Strategies.html#parListChunk
15:49:52 <mm_freak> keep_learning: i read that, yeah
15:50:07 <keep_learning> mm_freak, This implementation suggest that list is broken into parts
15:50:15 <keep_learning> mm_freak, but I think no evaluated
15:50:24 <keep_learning> mm_freak, I am not sure
15:50:32 <mm_freak> yeah, the list is broken into parts and the given strategy is used on those parts
15:50:51 <mm_freak> keep_learning: have you tried repa or DPH?
15:51:15 <keep_learning> mm_freak, I tried DPH
15:51:43 <keep_learning> its still not very  good with my current requirement
15:51:54 <keep_learning> Thats why I switched to List
15:52:09 <keep_learning> but its also not looks good
15:52:18 <keep_learning> mm_freak, Thanks for your time
15:52:34 <mm_freak> if you're working with listlikes, try repa
15:53:04 <mm_freak> the last time i benchmarked it wasn't fast, but that's quite some time ago
15:53:25 <keep_learning> mm_freak, Ben update new library and its promising
15:57:45 <qnikst> hello, I need to 'quickcheck' function by testing it on special data [[Double]] where  all (Const  == length), and ((Const+1)==length . head )
15:59:15 <qnikst> should I create new data type with arbitrary instance?
16:07:19 <kallisti_> :t iterate
16:07:20 <lambdabot> forall a. (a -> a) -> a -> [a]
16:07:43 <kallisti_> > iterate (zipWith (+) `ap` tail) [0,1]
16:07:44 <lambdabot>   [[0,1],[1],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[],[...
16:08:11 <kallisti_> oh
16:09:10 <mm_freak> > iterate (liftA2 (++) tail (scanl (+) 0)) [0..]
16:09:11 <lambdabot>   [[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27...
16:09:23 <mm_freak> > map head . iterate (liftA2 (++) tail (scanl (+) 0)) $ [0..]
16:09:25 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:10:24 <kallisti_> > iterate (\x -> x ++ zipWith (+) x (tail x)) [0,1]
16:10:26 <lambdabot>   [[0,1],[0,1,1],[0,1,1,1,2],[0,1,1,1,2,1,2,2,3],[0,1,1,1,2,1,2,2,3,1,2,2,3,3...
16:12:32 <mm_freak> > fix (liftA2 (:) id . (. succ)) 0
16:12:34 <lambdabot>   [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
16:13:07 <mm_freak> > fix (liftA2 (:) id . (. (^2))) 2
16:13:09 <lambdabot>   [2,4,16,256,65536,4294967296,18446744073709551616,3402823669209384634633746...
16:13:32 <mm_freak> > let iterate f = fix (liftA2 (:) id . (. f)) in iterate (+ 2) 0
16:13:34 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
16:14:38 <kallisti_> what is liftA2 for functions?
16:14:56 <aristid> :t liftA2
16:14:57 <lambdabot> forall a b c (f :: * -> *). (Applicative f) => (a -> b -> c) -> f a -> f b -> f c
16:15:00 <kallisti_> oh wait I know
16:15:08 <mm_freak> > let iterateA f = fix (liftA2 (<|>) pure . (. f)) in iterateA (+ 2) 0 :: [[Integer]]
16:15:09 <copumpkin> it's sort of like on backwards
16:15:09 <lambdabot>   No instance for (GHC.Num.Num [GHC.Integer.Type.Integer])
16:15:09 <lambdabot>    arising from th...
16:15:25 <mm_freak> > let iterateA f = fix (liftA2 (<|>) pure . (. f)) in iterateA (+ 2) 0 :: [Integer]
16:15:27 <lambdabot>   [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,5...
16:15:29 <kallisti_> liftA2 f g h = (f . g) `ap` h
16:15:29 <elliott> liftA2 f g h i x = f (g x) (h x) (i x)
16:15:30 <kallisti_> right?
16:15:34 <elliott> no
16:15:42 <mm_freak> :t \f -> fix (liftA2 (<|>) pure . (. f))
16:15:43 <elliott> erm
16:15:43 <lambdabot> forall (f :: * -> *) a. (Alternative f) => (a -> a) -> a -> f a
16:15:48 <copumpkin> elliott: 3?
16:15:48 <elliott> liftA2 f g h x = f (g x) (h x)
16:15:49 <elliott> liftA2 f g h x = f (g x) (h x)
16:15:51 <elliott> yeah
16:15:52 <elliott> that was 3 :p
16:15:59 <aristid> :t liftA2 :: (a -> b -> c) -> (d -> a) -> (d -> b) -> (d -> c)
16:15:59 <lambdabot> forall a b c d. (a -> b -> c) -> (d -> a) -> (d -> b) -> d -> c
16:16:22 <mm_freak> > (\f -> fix (liftA2 (<|>) pure . (. f))) (+ 5) 10 :: Maybe Integer
16:16:23 <lambdabot>   Just 10
16:16:59 <kallisti_> @src liftA2
16:17:00 <lambdabot> liftA2 f a b = f <$> a <*> b
16:17:23 <kallisti_> er, is that not ap (fmap f a) b ?
16:17:28 <mm_freak> > liftA2 f g h x
16:17:28 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:17:29 <lambdabot>    `GHC.Show.Show a'
16:17:29 <lambdabot>      a...
16:17:33 <mm_freak> > liftA2 f g h x :: Expr
16:17:34 <lambdabot>   Ambiguous type variable `a' in the constraints:
16:17:34 <lambdabot>    `SimpleReflect.FromExpr ...
16:17:44 <elliott> kallisti_: Oh, right.
16:17:45 <qnikst> how to know infix priority for operation?
16:17:49 <c_wraith> kallisti_: except for the class constraint, yes
16:17:50 <elliott> qnikst: :info in GHCi
16:17:56 <kallisti_> c_wraith: right
16:17:56 <qnikst> thanks
16:18:05 <mm_freak> liftA2 f g h x = f (g x) (h x)
16:18:17 <kallisti_> that seems like it would be a useful idiom
16:18:23 <kallisti_> yet I don't see that pattern crop up often.
16:18:27 <mm_freak> it is useful
16:18:37 <mm_freak> once you know how liftA2 works for functions you use it all the time =)
16:19:15 <mm_freak> just look for cases where you pass the same argument to multiple functions
16:19:24 <mm_freak> and the accumulate the results
16:19:27 <kallisti_> well yeah, that much is obvious
16:19:34 <kallisti_> it's just more often that I have different arguments to different functions. :P
16:20:04 <mm_freak> of course that's more often =)
16:20:34 <aristid> kallisti_: but sometimes the arguments _are_ the same :)
16:20:51 <kallisti_> if only if there were a combinator for applying different functions to different arguments in a simple, straightforward way
16:20:54 <kallisti_> hmmm
16:20:56 <kallisti_> -if
16:21:14 <mm_freak> well, the application operator is pretty straightforward
16:21:22 <kallisti_> like some kind of application construct. :P
16:21:23 <mm_freak> you don't even have to write it…  it's implicit =)
16:21:56 <mm_freak> f x  -- what could be more straightforward than that?
16:21:59 * kallisti_ would use that all the time if Haskell had it.
16:22:15 <mm_freak> i'm not sure what you want
16:22:22 <mm_freak> are you inventing a problem?
16:22:25 <kallisti_> no
16:22:33 <kallisti_> I was executing a joke poorly. :P
16:22:46 <mm_freak> ah…  ok, let me laugh then =)
16:22:47 <kallisti_> you caught on, but it wasn't clear I was joking, I guess.
16:23:25 <kallisti_> mm_freak: yes. allow us to laugh together. ha. ha.
16:23:32 <mm_freak> well, apparently haskell has so many great features that people start to have problems with the trivial
16:23:45 <mm_freak> i wouldn't be surprised if people asked for a better way to apply functions to values =)
16:24:31 <blackdog> mm_freak: would "cabal" be considered a trivial problem? :)
16:24:45 <mm_freak> haskell solves problems you never had before =)
16:24:54 <elliott> and creates problems you never even dreamed of
16:25:08 <mm_freak> elliott: you never were aware of =)
16:25:12 <mm_freak> blackdog: no
16:25:23 <mm_freak> and how many cabal questions do you see here? ;)
16:25:42 <blackdog> mm_freak: learned helplessness
16:26:03 <blackdog> "oh, it's broken again? rm -rf ~/.ghc ~/.cabal; cabal update; go_for_a_beer"
16:26:12 <kallisti_> elliott: by now I could have rewritten your IRC stuff twice. :P maybe even added some cool new features!
16:26:34 <mm_freak> blackdog: cabal install world;  go for two beers
16:27:20 <mm_freak> why don't we just use nix?
16:27:25 <mekeor`> @pl \f x -> f x -- is this a bug? it should be ($), IMO.
16:27:25 <lambdabot> id
16:27:39 <mm_freak> mekeor`: id = ($)
16:27:41 <mm_freak> :t id
16:27:42 <lambdabot> forall a. a -> a
16:27:43 <mm_freak> :t ($)
16:27:43 <lambdabot> forall a b. (a -> b) -> a -> b
16:27:48 <mekeor`> oh
16:27:55 <mekeor`> okay
16:28:08 <mm_freak> ($) is just id with a more specialized type =)
16:28:18 <elliott> id is one letter shorter
16:28:20 <elliott> gotta have that pointlessness
16:28:22 <blackdog> mm_freak: .. is world actually a thing?
16:28:22 <mekeor`> yep, i see.
16:28:35 <mm_freak> blackdog: it's all packages in ~/.cabal/world
16:28:41 <mekeor`> elliott: $ is a symbol. you can use $, so $ is shorter :Þ
16:28:57 <mm_freak> i.e. all packages you installed specifically
16:29:01 <elliott> mekeor`: you can't use $ to represent the function (\f x -> f x)
16:29:03 <elliott> which is what you asked it :)
16:29:17 <kallisti_> mekeor`: in some since you can use `id` as a ($) with the reverse syntactic properties. left associative and highest precedence.
16:29:18 <elliott> anyway, most likely it does (\f x -> f x) --> (\f -> f) --> id
16:29:25 <kallisti_> *sense  ...
16:29:33 <blackdog> mm_freak: turns out my _particular_ problem was the result of the pub i'm hacking in being cheap about big downloads.
16:29:37 <mekeor`> kallisti_: nice.
16:29:51 <kallisti_> mekeor`: if you want people on #haskell (except me) to scoff and cringe.
16:29:58 <blackdog> mm_freak: rhino ➜  ~/src/virthualenv-0.2  cat ~/.cabal/packages/hackage.haskell.org/00-index.tar
16:30:01 <blackdog> <HTML><BODY>  <h2>Attention!!!</h2><p>The file "00-index.tar.gz" has been blocked.  The file is larger than the configured file size limit.</p> <p>URL = http://hackage.haskell.org/packages/archive/00-index.tar.gz</p> </BODY></HTML>
16:30:05 <blackdog> bad times
16:30:05 <mekeor`> elliott: wait. "you can't use $ to represent the function (\f x -> f x)" ?? yes i can! what??
16:30:12 <elliott> :t $
16:30:13 <lambdabot> parse error on input `$'
16:30:14 <elliott> No you can't.
16:30:37 <kallisti_> mekeor`: here the type is important (\f x -> f x)  has a different inferred type than ($)
16:30:38 <elliott> You asked @pl to minify (\f x -> f x); it did so. It could have picked "id" or "($)", but the former is shorter, so it did better.
16:30:43 <elliott> kallisti_: What?
16:30:50 <elliott> No it doesn't.
16:30:54 <mekeor`> @type \f x -> f x
16:30:55 <lambdabot> forall t t1. (t -> t1) -> t -> t1
16:30:58 <mekeor`> @type ($)
16:30:59 <lambdabot> forall a b. (a -> b) -> a -> b
16:31:05 <elliott> Well, I guess a =/= t and b =/= t1.
16:31:09 <mm_freak> well, @pl's answer might be considered wrong in this case
16:31:11 <kallisti_> elliott: oh nevermind.
16:31:14 <mm_freak> it has a more general type
16:31:16 <kallisti_> I was thinking of just \x -> x
16:31:20 <mm_freak> a proper @pl shouldn't change the type
16:32:28 <mekeor`> alright
16:32:55 <kallisti_> mm_freak: do you consider a change from f x (g x) to ap to be a change in type?
16:33:14 <mm_freak> kallisti_: in the same sense, yes
16:33:18 <mm_freak> 'ap' is more general
16:33:35 <elliott> mm_freak: your imagined proper @pl would be almost useless
16:33:53 <shachaf> hi @pl
16:34:21 <mm_freak> elliott: add an S combinator, then it's not that useless
16:35:06 <kallisti_> a sufficiently specific pointfree library makes his @pl useful!
16:39:11 <keep_learning> > 15.0 / 8.4
16:39:12 <lambdabot>   1.7857142857142856
17:07:53 <shirt> is there a strict version of Data.IntMap.map ?
17:08:30 <elliott> there might be a map' in recent versions? not sure
17:10:46 <shirt> hm... don't see it. maybe this will do the trick: http://www.mail-archive.com/haskell-cafe@haskell.org/msg54883.html
17:22:12 * hackagebot Clipboard 2.2.0.1 - System clipboard interface.  http://hackage.haskell.org/package/Clipboard-2.2.0.1 (DanielDiaz)
17:24:43 <kallisti_> hm, apparently Mozilla has a project called Marionette which allows you to automate Firefox directly.
17:26:05 <kallisti_> and it uses Selenium's JSON protocol. which means my webdriver package doubles as a Marionette client. wooo.
17:49:23 <t7> @djynn a
17:49:23 <lambdabot> -- f cannot be realized.
17:49:29 <t7> x = x
17:49:32 <t7> i win
17:51:10 <Guest87411> what module contains (<-) and (|) ... lambdabot spit them out, and i've not seen them before
17:51:27 <shachaf> They are syntax, not operators.
17:52:30 <Twey> Guest87411: <- is part of do-notation, and | is part of the guard syntax.
17:53:12 <Guest87411> Twey: that helps.  they looked foreign out of context
17:53:38 <shachaf> Twey: <- is part of list comprehension syntax, and | is part of list comprehension syntax.
17:53:44 <Twey> That too.
17:54:16 <hpc> | is part of fundeps and <- is part of arrow syntax
17:54:42 <keep_learning> Did any one use monad-par for writing parallel program ?
17:57:12 <Guest87411> k. when i asked lambdabot "@pl \xs -> [x*x | x <- xs]"  it generates "return . (x *) . ((x | x) <-)"       but typing this into ghci generates a parse error on input '|'     not quite what i was looking for
17:57:31 <shachaf> Guest87411: @pl doesn't know about list comprehensions.
17:57:55 <Guest87411> schachaf: that would explain a whole lot
17:58:08 <hpc> @undo \xs -> [x*x | x <- xs]
17:58:09 <lambdabot> \ xs -> concatMap (\ x -> [x * x]) xs
17:58:14 <shachaf> map (^2)
17:58:16 <hpc> @pl \ xs -> concatMap (\ x -> [x * x]) xs
17:58:16 <lambdabot> (join (*) `fmap`)
17:58:17 <shachaf> map (join (*))
17:58:30 <shachaf> @@ @pl @undo \xs -> [x*x | x <- xs]
17:58:31 <lambdabot>  (join (*) `fmap`)
17:58:33 <shachaf> @hi
18:00:28 <Guest87411> shachaf: that's a good trick... what's @@ ?
18:00:44 <shachaf> @help @
18:00:44 <lambdabot>  @ [args].
18:00:44 <lambdabot>  @ executes plugin invocations in its arguments, parentheses can be used.
18:00:44 <lambdabot>  The commands are right associative.
18:00:44 <lambdabot>  For example:    @ @pl @undo code
18:00:44 <lambdabot>  is the same as: @ (@pl (@undo code))
18:01:15 <shachaf> ?help ?
18:01:15 <lambdabot> ? [args].
18:01:15 <lambdabot> ? executes plugin invocations in its arguments, parentheses can be used.
18:01:16 <lambdabot>  The commands are right associative.
18:01:17 <lambdabot>  For example:    ? ?pl ?undo code
18:01:19 <lambdabot>  is the same as: ? (?pl (?undo code))
18:01:22 <shachaf> Hah.
18:01:24 <shachaf> Another fun combination is @@ @pl @djinn
18:02:31 <hayashi> @help @undo
18:02:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:02:40 <hayashi> @help undo
18:02:40 <lambdabot> undo <expr>
18:02:40 <lambdabot> Translate do notation to Monad operators.
18:04:23 <kallisti_> @tell elliott quick, what's a cereal-based library I could write that allows me to use the name sour-cereal?
18:04:24 <lambdabot> Consider it noted.
18:10:42 <mtbeedee> Hey, is there a way to like "FilePath ++ String" ?
18:10:56 <kallisti_> type FilePath = String
18:11:08 <mtbeedee> right but if I do something like...
18:11:10 <hpc> > "FilePath ++ String"
18:11:10 <lambdabot>   "FilePath ++ String"
18:11:28 <mtbeedee> getHomeDirectory ++ "/somefile"
18:11:29 <mtbeedee> I get errors
18:11:32 <kallisti_> if you're looking for a platform-independent way of creating file paths, you should check out
18:11:38 <byorgey> mtbeedee: getHomeDirectory is not a FilePath
18:11:41 <hpc> what's the type of getHomeDirectory?
18:11:43 <byorgey> mtbeedee: it is an  IO FilePath
18:11:48 <mtbeedee> getHomeDirectory :: IO FilePath
18:11:52 <kallisti_> http://hackage.haskell.org/package/filepath-1.3.0.0
18:12:09 <kallisti_> this has a </> operator
18:12:12 <kallisti_> for concatenating path names together
18:12:17 <kallisti_> and yeah, what  those guys said.
18:12:39 <byorgey> mtbeedee: you want something like    do home <- getHomeDirectory; ... home </> "somefile" ...
18:12:51 <mtbeedee> wait, you cant treat an IO Thing as a Thing that also returns an IO action?
18:12:57 <kallisti_> nope
18:12:58 <byorgey> mtbeedee: no
18:13:05 <mtbeedee> damn
18:13:19 <kallisti_> mtbeedee: it's not as bad as it sounds.
18:13:25 <byorgey> mtbeedee: an IO Thing is not a Thing.  It is a set of instructions which, when executed, will have some effects and also produce a Thing.
18:13:42 <mtbeedee> oh yea
18:14:57 <kallisti_> mtbeedee: consider the difficulties of lazy evaluation with expressions that generate side-effects on the real world.
18:16:16 <kallisti_> if getCurrentDirectory could be treated as a FilePath, its value would depend on when it was evaluated. This is no good.
18:16:58 <mtbeedee> I think I get it
18:17:09 <mtbeedee> this IO stuff gets confusing
18:19:04 <Cale> mtbeedee: Basically, there are two interleaved processes which take place when a Haskell program runs
18:19:20 <Cale> mtbeedee: There's evaluation, which turns expressions into values
18:19:28 <Cale> (and is pure, and has no visible effects)
18:19:51 <Cale> mtbeedee: and then there's execution of IO action values, which has arbitrary effects
18:20:43 <Cale> This separation means that can pass IO actions around to functions, put them in data structures, take them out again, and so on, without worrying about having them accidentally fire before you want them to.
18:21:32 <Cale> You can execute an IO action from inside another, in a do-block, writing  v <- x  which means "execute the action x, and call whatever its result is v"
18:21:58 <Cale> And then in a compiled program, main gets executed.
18:22:11 <Cale> mtbeedee: does that make sense?
18:22:40 <mtbeedee> yea, I think I get it
18:22:43 <kallisti_> mtbeedee: yes, the IO action bound to main is the only one that is ever executed
18:22:52 <kallisti_> but it can be composed of multiple IO actions in sequence.
18:23:34 <Cale> So, you can write a program like   main = do v <- getLine; putStrLn v   which will first execute the action 'getLine', whose result will be called v, and then execute  putStrLn v  which will evaluate to an action for printing v on the screen.
18:24:08 <cudima> greetings. I need some help building the hscurses package
18:24:45 <Cale> (we execute the action which is the result of evaluating  putStrLn v, to be as clear as I can be about things :)
18:24:48 <mtbeedee> is it normal to have a main that has like a dozen lines, each one having a <- ?
18:25:01 <Cale> It's not particularly unusual
18:25:10 <mtbeedee> and then a single putStrLn at the end just to satisfy the IO () thing?
18:25:10 <kallisti_> typically at some point you break it up into multiple functions
18:25:13 <kallisti_> which are called from main.
18:25:51 <Cale> mtbeedee: main doesn't have to be of type IO (), it can be IO A for any particular type A.
18:26:08 <mtbeedee> yea, I guess I could mush some of these functions together
18:26:13 <mtbeedee> but they look so nice on their own
18:26:14 <Cale> mtbeedee: also, if you didn't want to print something, return () is an action which does nothing and whose result is () every time.
18:26:21 <mtbeedee> oh
18:26:22 <mtbeedee> cool
18:26:33 <kallisti_> return allows you lift a pure value into IO
18:26:37 <kallisti_> +to
18:26:45 <shirt> Cale: do you have a copy of that old stoplight tutorial of yours?
18:27:18 <kallisti_> mtbeedee: so for example, in a do block:   v <- return 2
18:27:20 <Cale> shirt: It's on an old hard drive of mine that I need to get an IDE to SATA adapter to try to access.
18:27:24 <kallisti_> mtbeedee: v is bound to 2
18:27:54 <Cale> shirt: and I think the drive is failing anyhow, so I don't know.
18:28:46 <shirt> Cale: ok thanks anyway :|
18:29:30 <kallisti_> mtbeedee: here's an example of using do notation and return to write your own IO computations. appendCurrentDirectory path = do { cwd <- getCurrentdirectory; return (cwd </> path) }
18:29:30 <aufwind> Hello, as a complete newcomer to Haskell (my first day) with knowledge in python, java and C++ (which doesn't seem to pay off here ;-)) I am stuck with an exercise where I have to understand and reproduce a piece of Haskell Code in an other language. It is the former that hinders me fulfilling the latter. Would someone be so kind and help me through the part of the lines which I could'n "decode"? This is the link to the pasted snippet
18:29:31 <aufwind> Everything I figured out myself is included as a comment. The rest is a book with 7 seals to me - at least right now. :-) http://codepad.org/vywbSalY Thanks in advance for any advice!
18:30:18 <mtbeedee> kallisti_: I have a few functions that do some stuff like that...  they operate on pure values and then "return" it because the "pure" value was really an IO action
18:30:34 <kallisti_> mtbeedee: well it's because you can't "escape" IO
18:30:40 <mtbeedee> it's infectious
18:30:44 <kallisti_> yep.
18:30:55 <mtbeedee> so then doesn't everything need to be IO?
18:31:01 <kallisti_> no.
18:31:10 <kallisti_> you can seprate your pure logic from your side-effectful computations.
18:31:21 <byorgey> aufwind: show does not print, it simply converts its argument to a String.
18:31:21 <mtbeedee> any function that operates on data ...
18:31:26 <mtbeedee> that data comes from somewhere
18:31:32 <mtbeedee> Input
18:31:40 <kallisti_> mtbeedee: you can write functions which are completely agnostic about the source of their data
18:31:47 <aufwind> byorgey: Ah, ok, that is good to know.
18:31:51 <kallisti_> pure functions. and then use them in IO
18:31:56 <mtbeedee> but then once you pass them something that came from IO
18:32:01 <mtbeedee> now they need to be aware of it
18:32:04 <kallisti_> mtbeedee: no
18:32:10 <kallisti_> when you write:  v <- someIOAction
18:32:13 <kallisti_> v is a pure value
18:32:16 <mtbeedee> oh
18:32:29 <byorgey> aufwind: randomRs produces an infinite list of random numbers
18:32:30 <mtbeedee> so it's only under the someIOAction that it needs to be IO
18:32:52 <aufwind> byorgey: Is it some kind of generator (as in python)?
18:33:00 <kallisti_> mtbeedee: the result of the entire do block is an IO action itself.
18:33:03 <byorgey> aufwind: so as and bs are infinite lists of random numbers, drawn uniformly at random from the range 0..99
18:33:15 <kallisti_> mtbeedee: you're free to use pure functions in constructing your IO action.
18:33:19 <kallisti_> on pure values.
18:33:51 <kallisti_> mtbeedee: to really learn what's going on you need to desugar the do notation into monadic functions.
18:33:52 <byorgey> aufwind: not really, as and bs are just infinite lists. but because of Haskell's laziness those end up behaving sort of like Python's generators.
18:34:27 <aufwind> byorgey: Okay, what does the g1 mean behind (0,99)? How is it read?
18:34:52 <byorgey> aufwind: note that g1 is defined in the line  (g1,g2) = split g
18:35:10 <byorgey> aufwind: generate takes g as an argument, which is a psudorandom number generator
18:35:13 <kallisti_> mtbeedee: the result of the IO computation must always be some kind of IO a;   so for example:  do {v <- getCurrentDirectory; v}  is invalid
18:35:17 <cudima> hscurses has a function with the following signature:
18:35:21 <mtbeedee> kallisti_: so like x <- readFile and then pass x into some say ::String -> String function?
18:35:22 <cudima> throwIfErr s = throwIf (== (-1)) (\a -> "Curses[" ++ show a ++ "]:"  ++ s)
18:35:22 <byorgey> aufwind: then g gets 'split' into four independent generators
18:35:25 <kallisti_> mtbeedee: yes
18:35:30 <cudima> throwIfErr :: Num a => String -> IO a -> IO a
18:35:40 <kallisti_> mtbeedee: and then if you need to wrap the pure result into IO you use return.
18:35:57 <kallisti_> otherwise you'll get a type error, as in the erroneous example above.
18:36:06 <cudima> I just pasted the function itself above the signature. The problem is that Num doesn't have an instance of Eq or Show
18:36:11 <kallisti_> you would want return v instead of v, because the end result of the do block must always be IO.
18:36:40 <byorgey> aufwind: those generators then get passed to randomRs and randoms in order to generate as, bs, and fs
18:36:51 <cudima> this must have built in ghc7.2 - that's the requirement of the package
18:37:01 <mtbeedee> so within the do block, you can use like "let" or something to assign values through pure functions?
18:37:01 <byorgey> er, I guess it gets split into only three independent generators
18:37:02 <hpaste_> sizz pasted “code from LYAH - won't run” at http://hpaste.org/67249
18:37:09 <aufwind> byorgey: I understand, that I do have to read the code from down to top, crrect?
18:37:18 <kallisti_> mtbeedee: what do you mean by "through pure functions"
18:37:26 <byorgey> aufwind: the order doesn't matter
18:37:34 <kallisti_> mtbeedee: you can use let, yes. there's also a special form of let that's only available in do notation.
18:37:39 <byorgey> aufwind: the order only matters after a 'do'
18:37:54 <kallisti_> do {y <- someAction; let x = f y; someActionWith x}
18:38:08 <byorgey> aufwind: so in the definition of 'main' you have to read from top to bottom
18:38:08 <kallisti_> x is bound for the remainder of do block.
18:38:23 <mtbeedee> kallisti_: if I do something like... x <- readThing :: Int
18:38:24 <mtbeedee> and then let y = double x
18:38:32 <kallisti_> mtbeedee: okay
18:38:37 <kallisti_> yes that's allowed
18:38:41 <byorgey> aufwind: but everywhere else, the order doesn't matter, things are just evaluated in some order based on dependencies
18:38:42 <kallisti_> you need something else afterward though
18:38:45 <kallisti_> you can't end with a let
18:38:46 <mtbeedee> well yea
18:38:47 <mtbeedee> I get it
18:38:50 <kallisti_> or a v <- ...
18:39:12 <mtbeedee> kallisti_: but that's how you mix results from IO into pure functions?
18:39:15 <aufwind> byorgey: What does <- mean?
18:39:21 <kallisti_> mtbeedee: let isn't required no
18:39:44 <kallisti_> mtbeedee: in my example above you could just write that as:  do { y <- someAction; someActionWith (f y) }
18:39:47 <kallisti_> and skip binding to x
18:39:54 <byorgey> aufwind: the short, not actually correct answer is that in this case is it basically "assignment"
18:39:59 <kallisti_> let just binds pure values to new variables, as it always does.
18:40:11 <byorgey> aufwind: oh, wait, which <- are you looking at?
18:40:48 <aufwind> byorgey: lin 10
18:40:48 <byorgey> aufwind: the one on line 18 means, get the global default pseudorandom number generator and assign it to g
18:40:58 <mtbeedee> kallisti_: but if you aren't binding the result of a pure function, what's the point?  It won't have side effects and the result is discarded
18:41:08 <kallisti_> mtbeedee: hm?
18:41:33 <kallisti_> I'm passing the pure value (in this case, f y)  to an IO computation called someActionWith
18:41:34 <mtbeedee> if I had called "double 2" without let x = before it...
18:41:39 <mtbeedee> then the result is discarded
18:41:40 <kallisti_> mtbeedee: that would be a type error
18:41:54 <kallisti_> but you can do
18:42:00 <byorgey> aufwind: inside a list comprehension like on line 10, x <- ys  means that  x will take on every value from the list ys  in turn.  Just like  'x in ys'  in a Python list comprehension.
18:42:02 <kallisti_> someOtherIOThing (double x)
18:42:05 <kallisti_> no problem
18:42:06 <kallisti_> the let isn't required
18:42:12 <mtbeedee> oh ok
18:42:22 <aufwind> byorgey: Nice.
18:42:30 <kallisti_> mtbeedee: v <- someAction
18:42:36 <kallisti_> if someAction has type IO a,  v has type a
18:42:41 <byorgey> aufwind: so  [blah | foo <- bar]  would be  [blah for foo in bar] in Python
18:42:44 <kallisti_> so you can use v anywhere you can use a value of type a
18:43:13 <kallisti_> if someAction is IO String, then v is String, so you can pass v to, say, putStrLn
18:43:26 <kallisti_> :t putStrLn
18:43:27 <lambdabot> String -> IO ()
18:43:48 <byorgey> aufwind: so zip3 takes three lists and puts corresponding elements together in three-tuples
18:43:56 <byorgey> > zip3 [1,2,3] [4,5,6] [7,8,9]
18:43:57 <lambdabot>   [(1,4,7),(2,5,8),(3,6,9)]
18:44:03 <aufwind> byorgey: I see!
18:44:17 <kallisti_> mtbeedee: but like I said, to really learn what's going on you need to desugar the do notation into >>=
18:44:29 <kallisti_> do blocks are just syntax sugar.
18:44:36 <byorgey> aufwind: so  zip3 as bs fs  gives us an infinite list of 3-tuples, each consisting of two random numbers and one random Bool
18:44:40 <mtbeedee> but you cant do putStrLn (someAction) because there's no bind that forces the evaluation
18:44:44 <kallisti_> mtbeedee: once you desugar it the types may become more apparently
18:44:49 <aufwind> byorgey: Where is the random bool set?
18:44:57 <byorgey> aufwind: line 14
18:44:57 <aufwind> byorgey: It is the f, right?
18:44:59 <kallisti_> mtbeedee: there's no bind that forces the execution, technically. but yeah. it's also a type error.
18:45:03 <byorgey> aufwind: right
18:45:08 <mtbeedee> well, it's a type error for that reas
18:45:09 <mtbeedee> on
18:45:15 <kallisti_> mtbeedee: the types enforce that you execute the action to get the result.
18:45:18 <kallisti_> yes
18:45:19 <mtbeedee> it would be a String instead of IO String
18:45:23 <byorgey> aufwind: line 14 defines fs as an infinite list of random Bool values
18:45:26 <mtbeedee> so you need the bind first then and separately
18:45:31 <kallisti_> mtbeedee: yes
18:45:42 <mtbeedee> you cant compose IO and pure
18:45:43 <kallisti_> mtbeedee: here's how you would write it with >>=
18:45:48 <kallisti_> someAction >>= putStrLn
18:45:54 <byorgey> aufwind: although line 14 doesn't say anything about Bool, but type inference figures out that it must be Bool
18:46:08 <kallisti_> mtbeedee: no do block here.
18:46:11 <aufwind> byorgey: Okay, but what about the f? I don't see what it is good for?
18:46:19 <kallisti_> example :: IO (); example = someAction >>= putStrLn
18:46:36 <kallisti_> this is what:  do { v <- someAction; putStrLn v}
18:46:37 <kallisti_> actually means
18:47:03 <mtbeedee> oh, wow
18:47:09 <mtbeedee> that do notation really screws with what's going on
18:47:12 <kallisti_> yes
18:47:27 <kallisti_> once you remove it, you can really see what's going on.
18:47:32 <byorgey> aufwind: so the list comprehension syntax  [x | y <- zs, blah] is like Python's  [x for y in zs if blah]
18:47:46 <kallisti_> the do notation is just a convenient syntax that makes some imperative computations easier to follow.
18:47:53 <byorgey> aufwind: so  if f then a+b<100 else a>=b  is a condition saying whether to keep each (a,b,f) tuple
18:47:53 <copumpkin> what are some interesting properties we get by parametricity?
18:48:07 <aufwind> byorgey: Aaaah, ok! I see now!
18:48:10 <mtbeedee> i'll have to read about that other notation
18:48:16 <mtbeedee> and figure it out
18:48:16 <byorgey> aufwind: it says that if f is True, then keep the tuple only if a+b < 100... etc.
18:48:19 <copumpkin> preferably somethign that needs dinaturality instead of naturality
18:48:27 <copumpkin> and that isn't a pain of the ass
18:48:40 <aufwind> byorgey: It payed off that I  know python in this case. :-)
18:48:41 <kallisti_> mtbeedee: yep. also IO is just one particular kind of monad. there are many monads, and each one as their own meaning for >>=
18:48:46 <byorgey> aufwind: yes, it did =)
18:48:47 <kallisti_> *has
18:48:51 <aufwind> byorgey: I got ya!
18:48:58 <aufwind> byorgey: I think I am set now. :-)
18:49:02 <byorgey> aufwind: great!
18:49:02 <kallisti_> mtbeedee: IO is just a special case, because it's the only way Haskell allows you to interact with the outside world.
18:49:06 <aufwind> byorgey: Your help is much appreciated!
18:49:09 <kallisti_> mtbeedee: so it's likely the first you'll encounter.
18:49:12 <byorgey> aufwind: you're welcome!
18:49:50 <Saizan> copumpkin: maybe this? http://r6research.livejournal.com/23402.html
18:49:51 <aufwind> byorgey: I think I will write the thing in python and use as much functional programming it offers (like list comprehensions and such) to annoy my professor a little bit. :-D
18:49:58 <aufwind> byorgey: Well thanks again!
18:50:11 <mtbeedee> well, thanks
18:50:13 <copumpkin> Saizan: thanks!
18:50:17 <mtbeedee> I think I got my function working
18:50:23 <kallisti_> mtbeedee: cool
18:50:25 <mtbeedee> now I'll test it
18:50:40 <mtbeedee> you've been a big help
18:50:48 <shirt> anyway to view the long output of a ghci command in a pager?
18:50:48 <kallisti_> :D
18:51:46 <kallisti_> mtbeedee: how much Haskell do you know already?
18:52:21 <kallisti_> are you familiar with lambda syntax?
18:52:23 <mtbeedee> very little
18:52:28 <byorgey> shirt: no, but instead of typing an expression exp  you could write   writeFile "tmp.txt" (show exp)  and then view tmp.txt in a pager.
18:52:39 <mtbeedee> kallisti_: I am rewriting a tool I use at work that I wrote in ruby into haskell to learn
18:53:27 <shirt> byorgey: problem is i'm not looking at an expression. i'm looking at the output of a :print command
18:53:35 <kallisti_> mtbeedee: ah okay
18:53:36 <byorgey> shirt: oh, I see =P
18:53:54 <kallisti_> mtbeedee: I'm doing kind of the opposite actually. well it's not a Haskell tool to Ruby.
18:54:01 <kallisti_> I'm just switching my scripting habits to Ruby instead of Perl.
18:54:12 <mtbeedee> so the "do" itself returns an IO ()?
18:54:16 <kallisti_> no
18:54:20 <mgsloan> hmm, have people looked at lenses as "Bij a (a, b)", or, better yet, "Reduceable a b => Bij a (b, c)", class Reduceable a b where { reduce :: a -> b }
18:54:26 <kallisti_> the do itself has the type of whatever the last thing is.
18:54:37 <mtbeedee> but if you have a function
18:54:57 <kallisti_> ..yes?
18:55:18 <byorgey> mgsloan: yes, c is known as the 'complement'
18:55:20 <kallisti_> (go on. :P )
18:55:31 <mtbeedee> func = do something ; putStrLn "x" ; double 2
18:55:34 <mtbeedee> then
18:55:40 <mtbeedee> it's still an IO action function?
18:56:07 <mtbeedee> the last one is not IO action
18:56:10 <mgsloan> byorgey: yeah, this makes sense as we need less "context" information, in the case that we are going to be rebuilding with a new value for the projection
18:56:11 <mtbeedee> but there is one there.
18:56:47 <kallisti_> mtbeedee: that's a type error
18:56:47 <yan_> im trying to use hxt but feeling a bit overwhelmed.. is understanding  arrows necessary to grok hxt?
18:56:51 <mgsloan> byorgey: the problem I see "Bij a (a, b)" is that it doesn't encode that the forward direction should be of the form "id &&& f"
18:57:01 <mgsloan> but
18:57:04 <shirt> how can i write a strict value to a TVar? is there something like 'evaluate' for STM?
18:57:10 <mtbeedee> kallisti_: why?
18:57:16 <byorgey> yan_: yes, I believe it actually is...
18:57:20 <kallisti_> mtbeedee: because that's a requirement of the type of >>=
18:57:20 <mgsloan> "Bij a (b, c)" nicely solves that - gives you capabilities due to the types not needing to be the same
18:57:25 <byorgey> mgsloan: Bij a (a,b) doesn't make sense to me.
18:57:36 <byorgey> mgsloan: right
18:57:41 <mtbeedee> oh, so it goes back to that
18:57:42 <kallisti_> mtbeedee: in do notation terms, each line must be some IO a
18:57:44 <mtbeedee> I should go read about those things
18:57:45 <copumpkin> mgsloan: bij? http://www.youtube.com/watch?v=Z3N91VDtWL0
18:58:00 <mgsloan> copumpkin: Terminology out of fc-labels :)
18:58:08 <copumpkin> oh, so you have experienced bij
18:58:18 <kallisti_> mtbeedee: if double isn't an IO a, then it can't be sitting there by itself on a line in a do block.
18:58:38 <mtbeedee> oh
18:58:42 <mtbeedee> one min... brb
18:58:59 <mgsloan> byorgey: well, for that bij, the forward direction is extraction, and the backward direction is recombination
18:59:28 <kallisti_> mgsloan: if that were the case you could write:   example = do { v <- someAction; double v}
18:59:31 <kallisti_> er
18:59:34 <kallisti_> mtbeedee: ^
18:59:42 <byorgey> mgsloan: but it can't be an isomorphism, because the right hand side has more values than the left.  Or does Bij represent partial isomorphisms?
18:59:53 <kallisti_> now example has type Double (presumably, based on the name of this function), and yet it also computes a side-effect.
19:00:01 <kallisti_> this defeats the purpose of IO
19:00:45 <mgsloan> byorgey: good point!  I guess it's forgetful in the recombination (naturally, as that is setting)
19:01:33 <mtbeedee> kallisti_: what about "let" inside do
19:01:37 <mtbeedee> thats not an io action
19:01:49 <kallisti_> let inside do is just a regular let.
19:01:52 <kallisti_> it's just sugary
19:02:03 <kallisti_> it's like surrounding the rest of the do block in a let ... in ...
19:02:12 <mtbeedee> ahh
19:03:34 <copumpkin> Saizan: that only seems to use the naturality, not the dinaturality
19:03:41 <copumpkin> Saizan: but it's still a decent example to play with, thanks
19:03:47 <copumpkin> I know that fix works
19:03:51 <copumpkin> and foldr probably does too
19:03:58 <copumpkin> but foldr seems like a bit of a pain to work with
19:04:12 <byorgey> mgsloan: anyway, I suggest you read up on some literature, since otherwise it seems to me you are in danger of wasting your time rederiving well-understood ideas
19:04:13 <copumpkin> and fix is meh :P
19:04:23 <byorgey> mgsloan: though I don't want to discourage you from thinking creatively.
19:05:04 <sizz> Please can someone help me see what's wrong with this:  <hpaste_> sizz pasted “code from LYAH - won't run” at http://hpaste.org/67249
19:05:53 <geekosaur> indentation
19:06:12 <kallisti_> mtbeedee: the idea is that you extract pure values from executed computations, then manipulate those values with pure code, then pass them to other computations, etc
19:06:12 <mtbeedee> HA!  look at that, you're right
19:06:15 <geekosaur> haskell is whitespace-sensitive; you indented "latger" more than "smaller" so it's read as a continuation
19:06:30 <geekosaur> "later", sheesh, I can type
19:06:36 <mtbeedee> I had a function that did some things and had a bunch of return () on if branches that were otherwise pure
19:06:41 <kallisti_> mtbeedee: and return lifts a pure value into IO.
19:06:42 <mtbeedee> I removed all of that and it still works
19:06:46 <sizz> geekosaur: no, it's got the same indentation in my source file, it just messed up when I pasted it
19:06:50 <mtbeedee> right
19:06:55 <mtbeedee> so I had it returning an IO String
19:06:59 <geekosaur> which means you used tabs
19:07:01 <mtbeedee> but it only needed to be a String
19:07:15 <mtbeedee> I figured that since it takes some IO as input it needed to output IO
19:07:20 <byorgey> mgsloan: if you want some good recommendations of things to read, ask dmwit
19:07:22 <mtbeedee> like input variables
19:07:24 <mtbeedee> not IO input
19:07:42 <mgsloan> byorgey: hehe, thanks!  Yeah, I know.  There seems to be a lot of variation with lens library design, though.  While the concept is pretty well understood, I haven't seen a library that nicely / simply captures the interactions between bijections, lenses, and partial variants of those two things
19:07:44 <kallisti_> mtbeedee: well if it extracts the result of the IO input, it needs to be IO.
19:07:48 <geekosaur> don't use tabs; there is no consistent meaning for them, haskell standard defines it as every 8 spaces but other programs do their own things
19:07:58 <mtbeedee> no... some other function does the <-
19:08:01 <mtbeedee> then calls this one
19:08:07 <kallisti_> oh I see
19:08:10 <monochrom> hpaste is a good place to see what tabs become
19:08:16 <kallisti_> mtbeedee: yeah you're incorrect to say that you have "an IO input"
19:08:16 <sizz> geekosaur: you are right. it must be my vimrc that needs changing
19:08:18 <mgsloan> byorgey: willdo!  I'm also going to take a longer look at multiplate as tgeeky suggested
19:08:24 <mtbeedee> yea, I understand
19:08:25 <kallisti_> mtbeedee: at least from the perspective of typing
19:08:29 <byorgey> mgsloan: agreed, there is still lots of room for exploring the space of Haskell lens library design.
19:08:36 <mtbeedee> I meant... something that originally came from IO as an argument
19:08:40 <kallisti_> right
19:08:45 <sizz> vim is automatically tabbing
19:09:06 <kallisti_> mtbeedee: (\x -> ...)
19:09:07 <sizz> thanks
19:09:09 <kallisti_> this is a lambda. got it?
19:09:10 <kallisti_> :P
19:09:13 <mtbeedee> got iy
19:09:14 <mtbeedee> it
19:09:17 <kallisti_> cool
19:09:27 <byorgey> mgsloan: one problem I see is that the Haskell community tends to be sort of off in its own world doing stuff with lenses without making connections to the extensive literature on lenses + bidirectional programming
19:09:40 <byorgey> mgsloan: I think both worlds have things to offer the other
19:10:00 <kallisti_> mtbeedee: do {v <- m; n} is the same thing as m >>= (\v -> n)
19:10:15 <byorgey> mgsloan: I guess that's one part of what I'm trying to get at with my suggestion to do some reading =)
19:10:28 <kallisti_> mtbeedee: v is actually the parameter of a lambda.
19:10:41 <kallisti_> whose result is the rest of the do block
19:10:54 <kallisti_> (aka more >>= chains)
19:11:56 <kallisti_> >>= "extracts" the result of m, and applies it to a function that returns another action.
19:12:18 <mtbeedee> you are using that semicolon as a literal semicolon?  or as a statement separator?
19:12:21 <mm_freak> (>>=) allows you to give the result a name
19:12:23 <mm_freak> just like <- does
19:12:27 <kallisti_> mtbeedee: either
19:12:33 <kallisti_> mtbeedee: they're equivalent
19:12:43 <mtbeedee> so if you like...
19:12:44 <kallisti_> (Haskell lets you use semicolons and curly braces instead of indentation and newlines)
19:13:02 <mtbeedee> x <- someIOInteger
19:13:03 <mtbeedee> double
19:13:05 <mtbeedee> it works?
19:13:07 <kallisti_> no
19:13:10 <mm_freak> mtbeedee: it is useful to keep in mind that an IO action is /never/ run in haskell
19:13:13 <mm_freak> never
19:13:20 <mtbeedee> it needs the args
19:13:33 <kallisti_> it needs to be IO action
19:13:36 <kallisti_> double is a pure function
19:13:45 <kallisti_> :t (>>=)
19:13:46 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
19:14:01 <mm_freak> "a pure function" is kind of a funny term
19:14:04 <kallisti_> taking out the scary stuff, and using IO as an example
19:14:08 <kallisti_> that becomes:
19:14:20 <kallisti_> IO a -> (a -> IO b) -> IO b
19:15:03 <mtbeedee> ok, that stuff is confusing me
19:15:12 <mtbeedee> let me think a minute
19:15:13 <mgsloan> byorgey: likely so!  It's cool that we actually have people using lenses in Haskell - at least I do - definitely need the practice influencing the literature
19:15:34 <kallisti_> mtbeedee: more examples would probably help
19:15:39 <kallisti_> also understanding the type of >>=
19:16:41 <mtbeedee> so the do notation is just "composing" IO actions?
19:16:54 <kallisti_> the do notation is just sugar for >>=, which is just composing IO actions.
19:17:05 <mtbeedee> ahh ok
19:17:09 <kallisti_> in a very specific way.
19:17:14 <kallisti_> which you can figure out by looking at its type.
19:17:30 <mtbeedee> i'll have to read about that >>= thing
19:17:35 <kallisti_> (and if you're unfamiliar with typeclasses, I gave you the version of the type that applies strictly to IO, to help you understand)
19:17:43 <mm_freak> mtbeedee: again, remember that in haskell you never /run/ IO actions, you never /extract/ results
19:17:50 <mm_freak> you just compose IO actions to form larger IO actions
19:17:56 <mm_freak> that's what (>>=) allows you to do
19:18:07 <mm_freak> (>>) :: IO a -> IO b -> IO b
19:18:15 <mtbeedee> well, they do get "executed" by main
19:18:16 <mm_freak> this takes two IO actions and composes them to a single action
19:18:24 <mm_freak> no, they don't
19:18:46 <mm_freak> the difference between (>>) and (>>=) is that the latter allows the second action to use the value produced by the first
19:18:46 <monochrom> main is getting executed by something outside haskell
19:19:01 <mm_freak> it allows you to /refer/ to the result of the first action
19:19:09 <mm_freak> just like <- in do-notation
19:19:24 <mm_freak> do a; b; c = a >> b >> c
19:19:39 <mm_freak> do x <- a; b x; c = a >>= \x -> b x >> c
19:19:54 <mm_freak> you've just given the result of one action in the chain a name you can refer to
19:21:07 <kallisti_> mm_freak: not everyone has a builtin Haskell parser. brackets would help
19:21:35 <mtbeedee> all right
19:21:42 <mm_freak> sorry
19:21:53 <mm_freak> do { x <- a; b x; c } = a >>= \x -> b x >> c
19:21:54 <byorgey> when writing code in the IO monad one must always use the subjunctive
19:22:00 <aufwind> byorgey: May I bother yo one last time? The if clause in the list comprehension: [… | (as, bs, f) <- zip3 as bs fs if f then a+b<100 else a>=b ]   I understand, that if a+b < 100 the triple is withdrawn. But what does the "else a >=b part meanß
19:22:04 <monochrom> http://bm380.user.srcf.net/prettyparsetree.cgi for adding parentheses for you
19:22:05 <mtbeedee> thanks for the help guys... I think I get it now
19:22:12 <mtbeedee> I'll look at the >>= thing
19:22:18 <mtbeedee> and I was able to get me thing working
19:22:20 <mtbeedee> so that's good
19:22:39 <byorgey> aufwind: no, it decides whether to use a+b < 100 as the criterion or  a >= b  based on the value of f
19:23:12 <mm_freak> mtbeedee: you can safely replace every "m" in (>>=)'s type signature by "IO" and just drop the "(Monad m) =>" part
19:23:16 <byorgey> aufwind: so (3,4,True) will be kept (because 3+4 < 100)  but  (3,4,False) would be discarded  (because it is not true that 3 >= 4)
19:23:29 <aufwind> byorgey: Ah ok, no I am set. :D
19:23:32 <aufwind> byorgey: Thanks!
19:23:36 <byorgey> sure =)
19:24:00 <kallisti_> mtbeedee: do {x <- a; b x; c} = a >>= (\x -> (b x >> c))   -- parentehses get no love!
19:24:21 <barrucadu> mm_freak: Thanks for that explanation. The IO monad, and monads in general, now make sense to me!
19:24:34 <mm_freak> barrucadu: the IO monad makes sense to you now =)
19:24:39 <barrucadu> I had a rough idea of how they worked, but couldn't see how they retained purity
19:24:40 <mm_freak> that explanation really explains IO
19:24:56 <kallisti_> other monads are pure.
19:25:04 <mm_freak> all monads are pure
19:25:16 <kallisti_> sure
19:27:17 <kallisti_> but not all monads have fun little side-effects associated with their use.
19:27:38 <mm_freak> i think most useful monads do
19:27:43 <mm_freak> otherwise they are just Identity
19:27:50 <mm_freak> but wait
19:27:56 <tgeeky> @tell dmwit can you take a look at this (preprint?) http://www.cs.indiana.edu/~sabry/papers/rational.pdf -- section 3. Anything interesting? Anything related to bidirectional programming that are new to you?
19:27:56 <lambdabot> Consider it noted.
19:28:02 <mtbeedee> hey, a module question...
19:28:05 <mm_freak> none of them have "side effects"…  there are monads that do have "monadic effects"
19:28:08 <mm_freak> like Maybe
19:28:10 <kallisti_> yes
19:28:15 <mtbeedee> I am using a Data.List.Utils function called "contains"
19:28:20 <mtbeedee> but when I compile it says
19:28:21 <mtbeedee> Deprecated: "Use Data.List.isInfixOf, will be removed in MissingH 1.1.0"
19:28:41 <mtbeedee> but I can't find any docs on this isInfixOf and if I try to import Data.List and use it, it doesn't work
19:29:12 <kallisti_> mm_freak: I don't really have a problem with using "pure" as a synonym for "not IO"
19:29:15 <geekosaur> @index isInfixOf
19:29:15 <lambdabot> bzzt
19:29:20 <mm_freak> > "abc" `isInfixOf` "fsudngabcfisj"
19:29:21 <lambdabot>   True
19:29:24 <mm_freak> > "abc" `isInfixOf` "fsudngabfisj"
19:29:25 <lambdabot>   False
19:29:27 <byorgey> mtbeedee: did you search fo it on  haskell.org/hoogle?
19:29:30 <byorgey> it links right to the docs
19:29:37 <geekosaur> ...are you using hugs?
19:29:43 <byorgey> mtbeedee: and what do you mean "doesn't work"?
19:29:55 <mtbeedee> oh, I was looking in Hackage...
19:30:01 <mtbeedee> it complains that there is no such function
19:30:03 <mm_freak> kallisti_: yeah, the definition of "pure" is quite vague, so i set it equal to "referentially transparent" for my personal purposes
19:30:08 <mm_freak> by that haskell is a pure language
19:30:14 <kallisti_> yes
19:30:15 <mm_freak> otherwise it would be wrong to say that haskell is pure
19:30:27 <byorgey> mtbeedee: can you please paste the exact code you have, along with the exact error message, on hpaste.org?
19:30:31 <kallisti_> the semantics associated with IO are not, though. I feel that should count for something when discussing it.
19:30:42 <mtbeedee> file.hs:16:51: Not in scope: `isInfixOf'
19:31:05 <byorgey> mtbeedee: and you have   import Data.List  at the top of file.hs?
19:31:07 <mtbeedee> uniq [ x | x <- hosts, y <- filters, isInfixOf y x ]
19:31:11 <mtbeedee> hosts and filters are both lists of strings
19:31:42 <byorgey> yes, that looks fine
19:31:47 <geekosaur> compiler, version?  using haskell98 mode?
19:31:50 <mtbeedee> oh, this machine is using ghc 6
19:31:52 <mtbeedee> gah
19:32:06 <mm_freak> kallisti_: well, there are two semantics for IO
19:32:12 <mm_freak> the execution and the evaluation semantics
19:32:15 <geekosaur> isInfixOf goes back to at least 6.8, I think
19:32:25 <mtbeedee> 6.4.2
19:32:35 <mtbeedee> time for an upgrade
19:32:37 <mm_freak> IO is a strict monad in that (>>=) is strict in its first argument
19:32:42 <geekosaur> owwww
19:32:44 <byorgey> 6.4.2!!!
19:32:47 <monochrom> 6.4 is really old :)
19:32:49 <byorgey> wowie
19:32:49 <geekosaur> 6.4,2?!
19:32:50 <mtbeedee> yea
19:32:58 <byorgey> really, really old
19:32:59 <mtbeedee> it's an old linux machine
19:32:59 <mtbeedee> old
19:33:01 <mtbeedee> old
19:33:06 <mm_freak> or is it?
19:33:13 <geekosaur> (and I thought macports was behind the times...)
19:33:19 <parcs`> you're 1.0.1 versions behind!
19:33:20 <mtbeedee> at least a few years
19:33:21 <mm_freak> > (undefined >>= return) `seq` () :: IO ()
19:33:22 <lambdabot>   Couldn't match expected type `GHC.Types.IO ()'
19:33:22 <lambdabot>         against inferred typ...
19:33:23 <monochrom> although I still have copy of 4.08 packed up somewhere
19:33:25 <kallisti_> mm_freak: is the function passed to >>= also strict in its first argument?
19:33:33 <parcs`> wait no, 0.9.9 versions behind
19:33:41 <mm_freak> kallisti_: that's your choice of course =)
19:33:48 <shachaf> I remember the release of 6.6
19:33:50 <kallisti_> well I mean
19:33:51 <shachaf> That was exciting.
19:33:54 <mm_freak> > (undefined >>= return :: IO ()) `seq` ()
19:33:55 <lambdabot>   ()
19:33:58 <mm_freak> oh
19:34:12 <mm_freak> apparently (>>=) isn't strict in its first argument
19:34:17 <byorgey> ghc 6.4.2 was released almost exactly 6 years ago, on 19 April 2006
19:34:24 <mm_freak> > (undefined >>= undefined :: IO ()) `seq` ()
19:34:25 <lambdabot>   ()
19:34:31 <mm_freak> wow
19:34:41 <monochrom> "pure" to me means: with "x :: Int", x is the same number every time I look (up to large enough scope)
19:34:43 <mm_freak> IO is lazier than i thought =)
19:35:01 <mm_freak> monochrom: isn't that just "referentially transparent"?
19:35:21 <kallisti_> mm_freak: well, I think it's different when you're actually executing things.
19:35:33 <kallisti_> :t evaluate
19:35:34 <lambdabot> Not in scope: `evaluate'
19:35:35 <byorgey> I think when I started using Haskell the latest version of ghc was 6.6.
19:35:38 <kallisti_> @hoogle evaluate
19:35:38 <lambdabot> Control.Exception.Base evaluate :: a -> IO a
19:35:38 <lambdabot> Control.Exception evaluate :: a -> IO a
19:35:38 <lambdabot> Control.OldException evaluate :: a -> IO a
19:35:48 <mm_freak> kallisti_: of course, that's when IO actions get evaluated so that they can be executed
19:36:03 <geekosaur> when I started 6.6 was current and 6.4 was considered by many to be ancient history
19:36:14 <kallisti_> mm_freak: so everything is very lazy.
19:36:20 <kallisti_> (???)
19:36:23 <mm_freak> yeah
19:36:36 <mm_freak> well, obviously (>>=) can't be strict in its second argument
19:36:42 <mm_freak> otherwise 'forever' wouldn't work
19:37:17 <monochrom> and so, if you have "getChar :: IO Char", getChar is the same action --- not the same Char! read the type --- every time I look. this does not conflict with I/O seeing different Chars at different times
19:37:34 <byorgey> geekosaur: makes sense, there was more than a year between the releases of 6.6 and 6.8
19:39:47 <mm_freak> it's funny how we reached the good old "is IO pure?" discussion without anyone questioning =)
19:40:30 <kallisti_> mm_freak: I meant the argument of the second argument, not the second argument itself.
19:40:39 <mm_freak> kallisti_: i know
19:40:42 <mm_freak> that's your choice
19:41:21 <mm_freak> id is strict…  const x is nonstrict
19:41:22 <kallisti_> clearly there's some kind of "forcing" going on, especially with things like file input.
19:41:26 <kallisti_> maybe not semantically speaking
19:41:57 <mm_freak> not at all…  the argument is usually fully evaluated, because the previous IO action provided it that way
19:42:03 <mm_freak> but consider this:  return undefined >>= f
19:42:18 <kallisti_> right, so that's a property of the action.
19:42:23 <mm_freak> yeah
19:42:26 <kallisti_> not the semantics of the pure monad.
19:42:38 <monochrom> return undefined >>= const (putStrLn "hi")  will work fine
19:42:39 <kallisti_> all is sane, as I hoped.
19:42:58 <kallisti_> I was just double checking. Maybe I had brushed over some small important details when learning this stuff.
19:44:12 <kallisti_> I really meant something different than "strict"
19:44:18 <monochrom> but yes, getChar is not going to be that lazy
19:44:31 <mm_freak> well, getChar is actually nonstrict
19:44:35 <kallisti_> and something more like the "strictness" of the IO runtime implementation.
19:44:38 <mm_freak> most IO functions are nonstrict
19:44:46 <mm_freak> > getChar undefined `seq` ()
19:44:47 <lambdabot>   Couldn't match expected type `a1 -> a'
19:44:47 <lambdabot>         against inferred type `GHC.T...
19:44:51 <mm_freak> uhm
19:44:55 <mm_freak> > putChar undefined `seq` ()
19:44:56 <lambdabot>   ()
19:44:59 <mm_freak> there we go
19:45:14 <mm_freak> the action itself will make use of the value and force it along the way
19:45:20 <mm_freak> but that has nothing to do with strictness
19:45:27 <kallisti_> I don't think seq helps here.
19:45:30 <mm_freak> that is (lazy) evaluation
19:45:37 <kallisti_> to determine these things.
19:45:38 <mm_freak> seq helps analyzing the strictness of a function
19:45:45 <monochrom> right, mm_freak is showing you that seq does nothing for it
19:46:40 <kallisti_> :t throwIO
19:46:41 <lambdabot> Not in scope: `throwIO'
19:46:43 <kallisti_> :(
19:46:49 <mm_freak> :t Control.Exception.throwIO
19:46:50 <lambdabot> forall e a. (GHC.Exception.Exception e) => e -> IO a
19:47:21 <kallisti_> > Control.Exception.throwIO (Control.Exception.ErrorCall "help!") `seq` ()
19:47:22 <lambdabot>   Not in scope: `Control.Exception.throwIO'Not in scope: data constructor `Co...
19:48:00 <monochrom> lambdabot doesn't do IO for you
19:48:08 <kallisti_> I didn't really ask it to
19:48:16 <monochrom> oh, oops
19:48:24 <kallisti_> anyway the docs of Control.Exception explain what happens
19:48:28 <kallisti_> it returns (), no error is thrown
19:48:38 <monochrom> lambdabot accomplishes that by limiting imports
19:49:19 <monochrom> it is beyond "throwing out the baby with the water". it doesn't import the baby in the first place :)
19:50:27 <kallisti_> it's good that lambdabot has such a firm grasp of "family planning"
19:51:49 <monochrom> actually, I am not entirely right. there are some IO stuff it imports. in that case it knows to not execute.
19:52:01 <monochrom> i.e., evaluate, but don't execute
19:52:13 <monochrom> > putStrLn "<IO ()>"
19:52:14 <lambdabot>   <IO ()>
19:52:34 <cwl> church number https://gist.github.com/2413845
19:53:01 <mm_freak> does it evaluate?
19:53:05 <mm_freak> > undefined :: IO ()
19:53:06 <lambdabot>   <IO ()>
19:53:08 <mm_freak> it doesn't
19:53:19 <monochrom> that's strange
19:53:24 <cwl> I want a substract function, sub m n = m pred n
19:53:35 <cwl> but type not match
19:53:35 <monochrom> > if undefined then putChar 'x' else putChar 'x'
19:53:36 <lambdabot>   <IO ()>
19:53:46 <cwl> two pred -- type not match
19:54:10 <mm_freak> i guess it checks the type of the expression and only evaluates for non-IO types
19:54:12 <monochrom> I see. it evaluates show(your_expression). that becomes const for IO
19:54:20 <mm_freak> > Just (undefined :: IO ())
19:54:20 <lambdabot>   Just <IO ()>
19:55:08 <mm_freak> apparently there is just a Show instance like:  instance (Typeable a) => Show (IO a)
19:56:38 <kallisti_> > return (# 2, 2 #) :: IO a
19:56:39 <lambdabot>   Couldn't match expected type `a'
19:56:39 <lambdabot>         against inferred type `(# t, t1 #)...
19:56:48 <kallisti_> > return (# 2, 2 #) :: IO (# Int, Int #)
19:56:48 <lambdabot>   Kind mis-match
19:56:49 <lambdabot>  The first argument of `GHC.Types.IO' should have kind `*',
19:56:49 <lambdabot> ...
19:56:52 <cwl> :t \h g -> h (g 0)
19:56:53 <lambdabot> forall t t1 t2. (Num t) => (t1 -> t2) -> (t -> t1) -> t2
19:57:02 <cwl> :t \x -> x 0
19:57:02 <lambdabot> forall t t1. (Num t) => (t -> t1) -> t1
19:57:09 <cwl> :t \x -> x
19:57:10 <lambdabot> forall t. t -> t
19:57:14 <mm_freak> :k (#,#)
19:57:15 <lambdabot> ? -> ? -> (#)
19:57:23 <kallisti_> :t subtract
19:57:24 <lambdabot> forall a. (Num a) => a -> a -> a
19:57:26 <kallisti_> cwl: ^ ???
19:57:29 <monochrom> polymorphic things don't take (# #)
19:57:40 <cwl> kallisti_: what?
19:57:44 * kallisti_ was trying to find something without a Typeable instance.
19:57:55 <kallisti_> cwl: you said you wanted a subtract function.
19:58:02 <kallisti_> sub m  n = m pred n
19:58:05 <kallisti_> doesn't make any sense to me.
19:58:05 <cwl> kallisti_: for church number
19:58:10 <cwl> kallisti_: yes
19:58:12 <mm_freak> kallisti_: if something doesn't have a Typeable instance, then the programmer just didn't bother to derive it
19:58:21 <kallisti_> cwl: oh I see.
19:58:25 <kallisti_> carry on then. :P
19:58:35 <cwl> :)
19:58:57 <kallisti_> subtraction isn't really closed on church numbers though, last I checked.
19:59:12 <mm_freak> it isn't and can't be
19:59:31 <mm_freak> you can define it as:  ChurchInt -> ChurchInt -> Maybe ChurchInt
19:59:32 <cwl> mm_freak: why
19:59:33 <kallisti_> but you could always just "stop at zero"
19:59:45 <kallisti_> cwl: what is 2 - 5 ?
19:59:45 <cwl> yes
19:59:46 <mm_freak> cwl: because church numbers are natural numbers
19:59:54 <cwl> like pred 0 = 0
20:00:08 <mm_freak> i wouldn't use a natural number library that defined pred 0 = 0
20:00:12 <cwl> http://en.wikipedia.org/wiki/Church_encoding
20:00:12 <kallisti_> but yeah Maybe ChurchInt seems like a better idea
20:00:24 <kallisti_> since it distinguishes 0 from an actual undefined value.
20:00:43 <monochrom> it's customary to just define 2-5=0
20:01:01 <kallisti_> gross. :P
20:01:13 <mm_freak> well, if you want to make the same mistake that C has made for almost half a century, go on
20:01:17 <mm_freak> let 2 - 5 = 0
20:01:19 <kallisti_> clearly they should church encode option types.
20:01:21 <mm_freak> > let 2 - 5 = 0 in 2 - 5
20:01:22 <lambdabot>   0
20:01:53 <cwl> let 2 - 5 = 0 in 2 - 5 , lol, that's fun
20:02:24 <mm_freak> to see why this sucks…
20:02:27 <mm_freak> > let 2 - 5 = 0 in 2 - 6
20:02:28 <lambdabot>   *Exception: <interactive>:3:4-12: Non-exhaustive patterns in function -
20:02:29 <mm_freak> =)
20:02:30 <cwl> I just didn't realize that is a legal expression
20:02:50 <mm_freak> cwl: it just defines a local function (-) that has nothing to do with Prelude's (-)
20:03:11 <mm_freak> :t \2 5 -> 0
20:03:12 <lambdabot> forall t t1 t2. (Num t, Num t1, Num t2) => t -> t1 -> t2
20:03:25 <mm_freak> :t let 2 - 5 = 0 in (-)
20:03:26 <lambdabot> forall t t1 t2. (Num t2, Num t1, Num t) => t -> t1 -> t2
20:03:55 <cwl> mm_freak: yes, but it looks more like an Pseudocode than runable code
20:04:03 <kallisti_> > do let in 2
20:04:04 <lambdabot>   2
20:04:25 <kallisti_> Haskell is secretly an INTERCAL dialect
20:04:31 <mm_freak> > let 2 = 3 in 2
20:04:32 <lambdabot>   2
20:04:51 <mm_freak> > let fromInteger = const 5 in 3
20:04:52 <lambdabot>   3
20:04:55 <monochrom> it's customary to define 2-5=0 and pred 0 = 0 etc because church numerals appear only in academic homework toy settings, no one actually uses it in production, there is no need for a robust "report errors" library
20:05:06 <kallisti_> mm_freak: needs more RebindableSyntax
20:05:18 <cwl> > let 2 = 3 in 2
20:05:19 <lambdabot>   2
20:05:22 <cwl> > let 2 = 3 in 3
20:05:23 <lambdabot>   3
20:05:24 <mm_freak> monochrom: wait until we have functions in the type level =)
20:05:52 <mm_freak> actually we have them
20:05:59 <cwl> how to define substract base on https://gist.github.com/2413845 and http://en.wikipedia.org/wiki/Church_encoding
20:06:34 <mm_freak> cwl: you can't really define subtraction for church numerals without reconstructing the numeral
20:06:37 <cwl> I try many times, sub m n = (n pred) m fails cause by type not match
20:06:59 <rwbarton> haskell is not the untyped lambda calculus
20:07:08 <cwl> mm_freak: why
20:07:15 <mm_freak> cwl: because functions are opaque
20:07:21 <mm_freak> you can't deconstruct them
20:07:49 <monochrom> but supposed "pred" already does the reconstructing
20:07:52 <cwl> is a -> (b -> c) a sub-type of a -> b
20:08:06 <monochrom> no, there is no sub-type
20:08:17 <mm_freak> cwl: a -> b and a -> (b -> c) unify
20:08:18 <kallisti_> a b and c are universally quantified over all Haskell types.
20:08:23 <mm_freak> the latter is a special case of the former
20:08:41 <cwl> monochrom: I mean does (\a -> (\b -> 0)) has type a -> b
20:09:03 <mm_freak> no
20:09:16 <mm_freak> it has type (Num c) => a -> b -> c
20:09:19 <cwl> a -> b (b can be any type, one of them is (a -> b))
20:09:37 <kallisti_> correct
20:09:46 <mm_freak> note that in haskell (->) is right-associative
20:09:51 <mm_freak> a -> b -> c = a -> (b -> c)
20:10:04 <kallisti_> basically as long as you understand that it's not really a "subtype" then you're good. :P
20:10:12 <mm_freak> and application is left-associative:  f x y = (f x) y
20:10:20 <kallisti_> it's just a particular example of the universal quantification.
20:10:25 <mm_freak> that's basically what currying is all about
20:11:08 <monochrom> if you speak like "a -> b (b can be any type, one of them is (a -> b))", you're thinking of an infinite type, and haskell doesn't let you do it, unless you add a newtype wrapper
20:11:11 <cwl> > let \x -> \y -> 0 :: (a -> b)
20:11:12 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:11:52 <mm_freak> cwl: that's a type error
20:11:55 <mm_freak> :t \x -> \y -> 0 :: (a -> b)
20:11:56 <lambdabot>     Could not deduce (Num b) from the context ()
20:11:56 <lambdabot>       arising from the literal `0' at <interactive>:1:12
20:11:56 <lambdabot>     Possible fix:
20:12:02 <cwl> monochrom: when I tell compiler a type a -> b, then b cannot be a function?
20:12:07 <mm_freak> :t \x -> \y -> 0 :: (Num b) => a -> b
20:12:08 <lambdabot> forall t t1 a b. (Num b) => t -> t1 -> a -> b
20:12:16 <mm_freak> :t \x -> (\y -> 0) :: (Num b) => a -> b
20:12:17 <lambdabot> forall t a b. (Num b) => t -> a -> b
20:12:21 <mm_freak> there we go
20:12:31 <rwbarton> if b is a variable then it can be specialized to a function type (or any other type)
20:12:42 <monochrom> "cannot" is ambiguous
20:12:44 <mm_freak> cwl: b can be a function, but it can't refer to the type it appears in
20:13:03 <mm_freak> that's commonly called an infinite type and not allowed in haskell
20:13:14 <kallisti_> I don't hink that's what he meant.
20:13:24 <monochrom> you probably completely mistake what type variables mean in Hindley-Milner
20:13:48 <cwl> let three f = f . f . f
20:13:55 <cwl> > three f = f . f . f
20:13:56 <lambdabot>   <no location info>: parse error on input `='
20:14:01 <mm_freak> cwl: try to define:  type Inf a = a -> Inf a
20:14:01 <cwl> > let three f = f . f . f
20:14:02 <lambdabot>   not an expression: `let three f = f . f . f'
20:14:14 <kallisti_> let ... in ...
20:14:17 <kallisti_> not just let ...
20:14:23 <mm_freak> Inf Int = Int -> Int -> Int -> Int -> Int -> Int -> …
20:14:25 <geekosaur> :t let three f = f . f . f in three
20:14:26 <lambdabot> forall b. (b -> b) -> b -> b
20:15:04 <cwl> let three f = f.f.f; let pred n f x = n (\g h -> h (g f)) (\_ -> x) (\u -> u) in three pred
20:15:15 <cwl> > let three f = f.f.f; let pred n f x = n (\g h -> h (g f)) (\_ -> x) (\u -> u) in three pred
20:15:15 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
20:15:20 <kallisti_> same problem as before.
20:15:22 <kallisti_> with the lets.
20:15:31 <mm_freak> cwl: let { def; def; def; } in …
20:15:33 <cwl> > let three f = f.f.f; pred n f x = n (\g h -> h (g f)) (\_ -> x) (\u -> u) in three pred
20:15:34 <lambdabot>   Occurs check: cannot construct the infinite type:
20:15:34 <lambdabot>    t = (t -> t1) -> (t1 -...
20:15:44 <cwl>  cannot construct the infinite
20:15:45 <cwl>                    type:
20:16:19 <mm_freak> cwl: this is theoretically impossible…  for the same reason why you can't define a Y combinator in haskell using lambdas
20:16:20 <cwl> cannot construct infinite type, that is the problem
20:16:33 <mm_freak> a fixed point combinator that is
20:16:40 <mm_freak> or "the" Y combinator
20:16:41 <cwl> mm_freak: what is Y combinator?
20:16:58 <monochrom> (\x -> x x) is a type error
20:17:00 <mm_freak> cwl: the Y combinator is a way to define 'fix' in untyped lambda calculus
20:17:12 <cwl> :t (\x -> x x)
20:17:13 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:17:13 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:17:13 <lambdabot>     In the expression: x x
20:17:36 <mm_freak> i think you can make (\x -> x x) work
20:17:46 <monochrom> none of sweet-talking "but t 'can' be t->t1" is going to help
20:17:50 <otters> no you can't
20:18:23 <mm_freak> :t (\x -> x x) :: (forall a. a -> b) -> b
20:18:24 <lambdabot> forall b. (forall a. a -> b) -> b
20:18:27 <mm_freak> you can =)
20:18:51 <mm_freak> you just can't infer its type in H-M
20:19:14 <aristid> mm_freak: you can't use that as fix, i think :)
20:19:21 <mm_freak> no, you can't
20:19:43 <mm_freak> but that wasn't the point…  i just wanted to show that \x -> x x is well-typed in higher rank haskell =)
20:19:44 <nexion> if I create "data MyType a = ...", how can I constrain what 'a' can be? I'd like it to be any type of typeclass MessageType
20:19:54 <kallisti_> nexion: don't do that
20:20:00 <aristid> mm_freak: if useless
20:20:04 <kallisti_> there's not really a good reason to do that ever.
20:20:12 <kallisti_> it's better to constraint a within the types of individual functions
20:20:13 <mm_freak> nexion: constrain it in the functions you write for MyType
20:21:00 <mm_freak> i think you can also use a GADT, too
20:21:26 <mm_freak> data MyType :: * -> * where MyConstr :: (MessageType a) => a -> MyConstr a
20:22:14 <nexion> constraining it in the functions I write seems cleaner :)
20:22:23 <mm_freak> you'll have to do that anyway
20:22:31 <mm_freak> otherwise the functions would be ill-typed
20:22:35 <nexion> yep
20:22:39 <nexion> ty
20:22:50 <mm_freak> the GADT is a further safety
20:23:03 <mm_freak> such that wrong values can't be constructed
20:23:09 <nexion> what does GADT stand for?
20:23:17 <mm_freak> Generalized ADT
20:23:27 <mm_freak> the type i gave is not an ADT
20:23:45 <otters> https://gist.github.com/2418176
20:23:51 <otters> is this the right place to ask why this is happening ^
20:24:34 <mm_freak> otters: #arch-haskell
20:44:44 <nyingen> @quote
20:44:44 <lambdabot> joe6 says: <Kron> What is the meaning of life? D: <joe6> learning agda?
20:44:53 --- topic: set to '["Haskell Platform 2011.4: http://bit.ly/Clv5r ","Paste code/errors: http://hpaste.org/new/haskell ","GHC 7.4.1: http://is.gd/vkWMMa ","Haskell News: http://reddit.com/r/haskell ","The Haskell programming language http://haskell.org ","Logs: http://bit.ly/5mwtRQ ","admin/spam issues: #haskell-ops "]' by ChanServ
20:45:34 <nyingen> @quote
20:45:34 <lambdabot> cjeris says: instance (TicTacToe a) => (GlobalThermonuclearWar a) where ...
20:48:34 <JoeyA> Those parens are unnecessary...
20:51:25 <nyingen> I'd rather have unnecessary parens that "comma-first" lists
20:51:30 <nyingen> *than
20:51:38 <nyingen> @quote
20:51:38 <lambdabot> adam says: Lisp is like Ruby with an ugly syntax, impossible stdlib, and some macros that don't compensate for above shortcomings
20:52:08 <nyingen> 8/10
20:56:36 <cwl> http://stackoverflow.com/questions/6595749/subtraction-of-church-numerals-in-haskell
20:57:12 <cwl> @quote
20:57:12 <lambdabot> souwh says: <shapr> hm, I have extra spaces there. <souwh> oooh, those can be saved and reused later!
20:57:19 <cwl> @quote
20:57:19 <lambdabot> Plugin `quote' failed with: getRandItem: empty list
20:57:26 <cwl> @quote
20:57:26 <lambdabot> increpare says: I think I grew up on free products
21:04:10 <aufwind> Maybe this is the most trivial question ever asked in this channel, but why does multi a b = a*b throw a <interactive>:1:11: parse error on input `=' ?
21:04:27 <Axman6> aufwind: you need to use let
21:04:27 <kallisti_> aufwind: where?
21:04:29 <shachaf> aufwind: Because ghci isn't a Haskell file.
21:04:29 <aufwind> By the way multi(a,b) = a*b does so too
21:04:30 <Axman6> let multi...
21:04:33 <shachaf> Put "let" in front of it.
21:04:38 <aufwind> ah ok
21:04:39 <aufwind> thx
21:05:08 <shachaf> aufwind: "multi(a,b) = a*b" is misleading, by the way. It's a function that takes one argument which is a pair of two values. If you ever do have a reason to use that, write "multi (a,b)".
21:06:06 <aufwind> shachaf: need to write lcm respecting this signature: kgv :: (Int,Int) -> Int
21:06:19 <aufwind> shachaf: Thanks for pointing that out!
21:07:21 * hackagebot persistent-postgresql 0.9.0.2 - Backend for the persistent library using postgresql.  http://hackage.haskell.org/package/persistent-postgresql-0.9.0.2 (MichaelSnoyman)
21:11:17 <Axman6> cwl: is that your question on SO?
21:11:47 <cwl> Axman6: no, it is the same question I just asked in irc
21:12:20 <Axman6> ah. i believe it was asked by a friend/collegue of mine
21:12:29 <Axman6> colleague*
21:13:23 <Axman6> hmm, maybe not
21:14:39 <cwl> Axman6: Probie?
21:14:58 <Axman6> yeah, but i don't think that's the probie i know
21:15:37 <cwl> Axman6: ah. so you thought I am your friend/colleague
21:15:41 <cwl> :P
21:15:56 <Axman6> well, i was wondering =)
21:16:08 <Axman6> seems he is the guy i'm thinking of
21:19:12 <rsimoes> In what language did type classes originate? Is it somewhat fuzzy? Perl's tie system looks like it resembles a limited form of type classes
21:20:37 <aufwind> I have a file ggt.hs in which the a function ggt is defined (greatest common divisor). Now I added my great multi function and a kgv (lowest common multipliyer) to that file. I adapted the concept of ggt. When I :load the file into the interpreter the ggt works fine but the interpreter keeps complaining about "Not in scope" for kgv. http://codepad.org/7GdDPJHi What is wrong about that? Maybe each function must go into its separate fil
21:23:01 <rwbarton> your definition of kgv shouldn't type check
21:23:29 <rwbarton> so I suspect something else is wrong, perhaps something boring like "you forgot to save the file"
21:25:39 <aufwind> rwbarton: Hm, the content of the file is safed. Afterwards I did again :load ggt.hs and multi(2,3) throws the same error as above
21:25:53 <aufwind> Which is <interactive>:1:1: Not in scope: `multi'
21:28:21 <aufwind> Shame on me.
21:28:22 <rwbarton> oh
21:28:29 <aufwind> I was working on 2 files.
21:28:42 <aufwind> One was updated by me and the other one was loaded.
21:28:46 <monochrom> type class originated from a wadler paper, not from another language
21:28:57 <aufwind> rwbarton: Thanks for directing me to the right direction. *blush*
21:37:37 <twomashi> do { let (a, b) = returnsTuple }
21:37:56 <twomashi> ^^ syntax error, is tuple unwrapping possible in a do?
21:38:40 <kallisti_> twomashi: yes
21:38:40 <glguy> twomashi: not as the last line in a do-block
21:38:43 <glguy> What are you trying to do?
21:39:02 <twomashi> it's the first line.
21:39:09 <twomashi> partition a Map
21:39:15 <Cale> twomashi: Since it's also the last line, it's a problem :)
21:39:27 <twomashi> it isn't in my code, just in my example...
21:39:31 <Cale> twomashi: put some actual actions into the do-block :)
21:39:33 <Cale> ah
21:39:46 <Cale> in that case, hpaste your actual code perhaps?
21:40:04 <monochrom> what is the type of returnsTuple?
21:40:04 <twomashi> ok, dont laugh....
21:40:41 <sam8> Can I get some help on my code
21:40:42 <rwbarton> probably not a tuple type or it would just be called "tuple"
21:40:42 <sam8> http://hpaste.org/67254
21:40:52 <hpaste_> twomashi pasted “unpack in do” at http://hpaste.org/67255
21:40:55 <twomashi> http://hpaste.org/67255
21:41:24 <twomashi> thank you hpaste_
21:41:29 <monochrom> well, wrong indentation for the two lines below
21:41:32 <rwbarton> indent lines 3 and 4, they are supposed to be part of the let block, right?
21:41:43 <Cale> yeah, that looks like all it is
21:41:52 <twomashi> no they arent...
21:42:05 <Cale> twomashi: they should be :)
21:42:06 <rwbarton> then what on earth are they supposed to be
21:42:18 <monochrom> look, do-block does not accept = unless as part of "let"
21:42:36 <rwbarton> you could alternatively use three separate "let"s
21:42:54 <twomashi> Oh....
21:43:02 <twomashi> I missed that >.<
21:43:10 <twomashi> thanks
21:43:23 <Cale> sam8: maybe use ScopedTypeVariables to help...
21:43:43 <sam8> I already have it in my code...
21:43:57 <sam8> it is still giving me error2026 I'm not sure :(
21:44:05 <Cale> sam8: then you could forall the type variables in multiplyGH (which would let you use q in a type annotation for the PrimVector which is a parameter to multiply)
21:45:27 <Cale> multiplyGH :: forall q m r c. (ReifiesNum q, CyclotomicRing m r c) => PrimVector q c -> [[c]] -> [[c]] -> [[c]]
21:45:42 <Cale> multiplyGH (PrimVector gs) (h:hs) ls = multiply (PrimVector gs :: PrimVector q c) hs (ls ++ [(test gs h)])
21:46:24 <Cale> OR
21:46:35 <Cale> (now that I've looked at things a bit more closely)
21:47:18 <Cale> multiplyGH (g@(PrimVector gs)) (h:hs) ls = multiply g hs (ls ++ [(test gs h)])
21:47:36 <sam8> I tried some changes2026 http://hpaste.org/67256
21:47:45 <sam8> but still giving me error2026
21:48:16 <Cale> sam8: your client seems to randomly be putting character 001E followed by "2026"
21:48:34 <Cale> sam8: but in any case, that's only halfway to a solution there
21:48:40 <sam8> Ya2026 I'm not sure why its doing that
21:48:47 <Cale> sam8: you need the annotation on the parameter to multiply
21:48:53 <Cale> er...
21:48:56 <Cale> wait what?
21:49:12 <Cale> oh, multiplyGH is meant to be recursive?
21:49:20 <Cale> okay
21:49:48 <sam8> well changing it so that (g@(PrimVector gs)) did make it compile
21:50:04 <Cale> right
21:50:27 <Cale> because when you remake the PrimVector like that, you lose the q type parameter
21:50:29 <sam8> I thought @ is just giving a shorter name is it not?
21:50:34 <Cale> it is
21:50:51 <Cale> It's binding that parameter to a variable, and simultaneously pattern matching it
21:50:57 <Cale> here, gs :: [c]
21:51:12 <Cale> while  g :: PrimVector q c
21:51:21 <sam8> I see
21:51:31 <sam8> If I remove the forall, it still compiles now
21:51:33 <Cale> But if we take gs and remake a new PrimVector from it
21:51:35 <Cale> yes
21:52:02 <Cale> then we get something of type  forall q0. PrimVector q0 c
21:52:35 <Cale> and that q0 is not necessarily the same q that we want -- it's any q, and so we don't know which ReifiesNum instance to use then.
21:53:25 <sam8> haskell is tough :(
21:53:49 <Cale> Well, let's take a look at this ReifiesNum thing... what is it doing for you?
21:54:15 <sam8> by the way, are there any libraries in haskell for doing matrix operations like multiplications?
21:54:17 <Cale> There can be valid reasons to do this sort of thing, but this is a little strange.
21:54:37 <Cale> Sure, there are a few matrix and linear algebra libraries.
21:54:41 <sam8> I could only find ones that work with double types and could not find ones for general Num
21:55:08 <Cale> hmm
21:55:09 <sam8> Yes, this is for a research on cryptographic schemes
21:55:35 <sam8> we want to store q as a reifiesNum type as a modulo
21:55:54 <sam8> I saw the LUPAC but it worked for Doubles
21:56:18 <sam8> and I looked at Repa-algorithms but it worked for Doubles as well
21:57:03 <Cale> Hmm...
21:57:38 <Cale> vector-space has generalised linear maps, but not matrices exactly (you could extract the coefficients for a matrix representation pretty easily though)
21:57:45 <Cale> http://hackage.haskell.org/package/vector-space
21:58:19 <Cale> but yeah, now that you mention it, it is a little weird that all the linear algebra stuff is specialised to floating point arithmetic
21:59:50 <sam8> I see
22:01:06 <drdo> I'm not sure i understand this natural transformation idea, i don't get how it's any different from a functor, other than being a level up
22:01:52 <Cale> drdo: It's... well, other than the fact that natural transformations form the arrows of a category of parallel functors, they have very little in common?
22:01:55 <PatrickRobotham> drdo: Well, that's a good way to think of it. Functors are morphisms between categories. Natural Transformations are morphisms between functors.
22:02:51 <drdo> How is a nt from functors from C to D any different than just defining a category a categories with functors as morphisms ?
22:03:03 <drdo> Aren't the functors for the new category natural transformations ?
22:03:14 <Cale> ?
22:03:25 <Cale> If I have a pair of categories C and D, then a functor F: C -> D consists of:
22:03:37 <Cale> for each object X in C, an object FX in D
22:03:57 <Cale> for each arrow a: X -> Y in C, an arrow Fa: FX -> FY in D
22:05:08 <Cale> If I have a pair F,G of functors C -> D, then a natural transformation eta: F -> G consists of:
22:05:28 <Cale> for each object X in C, an arrow eta_X: FX -> GX in D
22:06:19 <Cale> The laws for a functor are that F(id_X) = id_(FX), and that F(a.b) = Fa . Fb (for any arrows a and b which compose)
22:07:13 <Cale> and for a natural transformation, we require that for any arrow a: X -> Y in C, we have eta_Y . Fa = Ga . eta_X
22:07:31 <drdo> Cale: I understand the definitions, what i'm really asking/thinking is if there's any point to the definition of natural transformations
22:07:47 <Cale> Well, what do you mean by that?
22:07:54 <sam8> Cale: am I aloud to do something like this? http://hpaste.org/67257
22:08:32 <PatrickRobotham> Cale: I think he's asking for some examples / applications of natural transformations.
22:08:40 <drdo> PatrickRobotham: It's not that
22:08:50 <PatrickRobotham> Well I'd like some examples :P
22:09:01 <Cale> Okay, let's look at an example in the context of Haskell.
22:09:55 <drdo> I mean, why is it interesting?
22:09:56 <Cale> We'll take the functor []: Hask -> Hask, which sends a type T to the type [T] of lists of elements of that type
22:10:16 <Cale> and the functor Tree: Hask -> Hask which does the same, but with, say, binary trees
22:10:19 <drdo> How is it interesting in a different way than a functor?
22:10:29 <Cale> data Tree a = Tip | Branch a (Tree a) (Tree a)
22:11:00 <Cale> There is a natural transformation   flatten: Tree -> [],  which we can realise as a polymorphic Haskell function
22:11:07 <Cale> flatten Tip = []
22:11:26 <Cale> flatten (Branch x l r) = flatten l ++ [x] ++ flatten r
22:11:47 <Cale> flatten :: forall a. Tree a -> [a]
22:12:23 * hackagebot persistent 0.9.0.2 - Type-safe, multi-backend data serialization.  http://hackage.haskell.org/package/persistent-0.9.0.2 (MichaelSnoyman)
22:12:24 <Cale> Why is this a natural transformation? Well, for any function f :: X -> Y, we have  flatten . fmap f = fmap f . flatten
22:12:25 * hackagebot wai-extra 1.2.0.3 - Provides some basic WAI handlers and middleware.  http://hackage.haskell.org/package/wai-extra-1.2.0.3 (MichaelSnoyman)
22:12:27 * hackagebot warp-tls 1.2.0.3 - SSL support for Warp via the TLS package  http://hackage.haskell.org/package/warp-tls-1.2.0.3 (MichaelSnoyman)
22:12:29 * hackagebot yesod 1.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-1.0.1 (MichaelSnoyman)
22:12:31 * hackagebot yesod-auth 1.0.1 - Authentication for Yesod.  http://hackage.haskell.org/package/yesod-auth-1.0.1 (MichaelSnoyman)
22:13:11 <drdo> Cale: I'm trying to figure out if there's something special about them or not
22:13:29 <drdo> i.e. transformations on natural transformations
22:13:32 <drdo> and so on
22:13:42 <Cale> flatten doesn't affect or depend on the elements of the tree when it constructs the list from them, while fmap doesn't touch the list or tree structure, it only affects the elements
22:13:45 <drdo> I'm trying to understand if this level is special or if it's just the same
22:13:48 <Cale> So those operations "commute"
22:14:38 <Cale> Natural transformations and functors are not the same thing
22:15:07 <drdo> Cale: Obviously
22:15:27 <drdo> What i'm trying to understand is if there's any new idea
22:15:37 <Cale> Sure?
22:15:56 <Cale> Naturality squares are quite different from the functor laws.
22:16:11 <drdo> Cale: Why did we stop here? Why not go into composition preserving transformations of natural transformations?
22:16:18 <Cale> Well, what are those?
22:17:03 <Cale> Suppose I have two natural transformations, say, alpha and beta: F -> G
22:17:24 <drdo> ok
22:17:33 * hackagebot yesod-core 1.0.1 - Creation of type-safe, RESTful web applications.  http://hackage.haskell.org/package/yesod-core-1.0.1 (MichaelSnoyman)
22:17:35 * hackagebot yesod-default 1.0.1 - Default config and main functions for your yesod application  http://hackage.haskell.org/package/yesod-default-1.0.1 (MichaelSnoyman)
22:17:37 * hackagebot yesod-form 1.0.0.2 - Form handling support for Yesod Web Framework  http://hackage.haskell.org/package/yesod-form-1.0.0.2 (MichaelSnoyman)
22:17:39 * hackagebot yesod-routes 1.0.1 - Efficient routing for Yesod.  http://hackage.haskell.org/package/yesod-routes-1.0.1 (MichaelSnoyman)
22:18:14 <Cale> So for each object X, we have some components alpha_X and beta_X: FX -> GX
22:18:33 <Cale> now, how should we relate them exactly?
22:20:25 <Cale> (there are probably some ways to do it, but I'm asking what you're thinking of :)
22:20:39 <drdo> Yes, hold on, i'm sketching!
22:20:55 <drdo> I haven't thought about it extensively, i read about it 15min ago
22:21:02 <Cale> okay :)
22:24:38 <kfish> You are sketching _a natural transformation_ for _Cale_
22:25:04 <Cale> kfish: He's doing it for himself
22:25:38 <kfish> Cale: i was just trying to come up with a new facebook game
22:26:18 <drdo> meh
22:26:29 <drdo> There's no where else to go in this fashion
22:26:59 <drdo> We need to abstract somewhere
22:27:45 <Cale> drdo: Well, one thing I guess we could do is to have for every object X in C, a pair of maps u_F,X and u_G,X, such that u_G,X . alpha_X = beta_X . u_F,X for every X
22:27:49 <wli> Cale: How do I use natural transformations and adjoint functors to write programs?
22:28:11 <Cale> wli: natural transformations correspond to parametrically polymorphic functions
22:28:14 <drdo> Is there something about transformations between functors between different categories?
22:28:20 <Cale> wli: So in a sense, you do that all the time :)
22:29:38 <Cale> drdo: Sure, those exist.
22:29:47 <drdo> Cale: Anything exists
22:29:52 <Cale> drdo: How much linear algebra do you know?
22:29:59 <drdo> The "interesting" part is implied
22:30:33 <drdo> Cale: To be honest, i never quite understood the point of that
22:30:41 <Cale> If we have a field, there are (at least) two things we can do to it to produce a group
22:31:07 <Cale> We can take the group of units of the field (which just amounts to removing 0, and not talking about addition :)
22:31:17 <drdo> One thing i thought about the other day, what's this fascination people seem to have with polynomials? They always seemed insanely specific and boring
22:31:31 <Cale> and we can take the group of invertible n-by-n matrices whose elements are in the field
22:32:00 <Cale> We'll call those F* and GL_n(F) respectively
22:32:14 <Cale> Those both happen to be functors from the category of fields to the category of groups
22:32:27 <Cale> and there's a natural transformation GL_n -> *
22:32:49 <Cale> whose components just take the determinants of the matrices :)
22:32:58 <drdo> Cale: What's a field exactly?
22:33:29 <drdo> I know about groups and friends
22:33:47 <Cale> ah, okay, in that case, I can be a bit terse about it :)
22:34:22 <drdo> I remember it being a couple of group-like things together with distribution or something
22:34:49 <Cale> kinda, yeah
22:34:56 <drdo> About that
22:35:16 <drdo> Why is a field of all things interesting?
22:35:54 <Cale> Fields are interesting because they're a specific generalisation of the concept of numbers.
22:36:25 <drdo> Oh, about that
22:36:40 <drdo> Is there anything about generalizations of the integral?
22:36:45 <Cale> With a lot of the basic nice properties we'd like to demand of numbers usually
22:37:11 <drdo> I.e. folds in sets that big
22:37:11 <Cale> Um, there's no shortage of them :)
22:37:20 <Cale> Measure theory does that
22:38:10 <drdo> Does anyone actually have any intuition for anything bigger than beth0 ? :P
22:38:17 <drdo> I know i don't
22:38:30 <ivanm> preflex: seen dcoutts
22:38:30 <preflex>  dcoutts was last seen on #ghc 8 hours, 35 minutes and 44 seconds ago, saying: Laney: looks like it didn't get updated
22:38:39 <dcoutts> @arr!
22:38:39 <lambdabot> I'll crush ye barnacles!
22:38:47 <Cale> I have plenty of intuition about beth_1
22:39:08 <ivanm> dcoutts: with the test support in cabal, is there any way of having some kind of flag be used to enable/disable other parts of the package?
22:39:30 <drdo> Cale: I do too in some sense
22:39:35 <Cale> and a little bit about beth_2
22:40:00 <Cale> I can think about sets of real numbers reasonably well
22:40:04 <drdo> I have zero intuition about beth2
22:40:17 <Cale> fsvo reasonably
22:40:18 <dcoutts> ivanm: no, because that would not make sense. You don't want to build the rest of the package differently. Consider what that'd do for gentoo users for example, if USE=test gave them a slow debugging version rather than just running the testsuite.
22:40:35 <Cale> I mean, I'm not some master of descriptive set theory or anything :)
22:41:12 <ivanm> dcoutts: well, my test suite currently has an optional part of the library be built, which is enabled with the test flag along with the executable stanza
22:41:28 <ivanm> but if I want to use the cabal test stuff, I can't do that
22:41:29 <drdo> Cale: I'm not sure what you mean by reasonably well, that's the trouble with this intuition thing, it's terribly hard to explain
22:41:32 <Cale> (those people have much better developed intuition about sets of real numbers than I would have)
22:41:42 <dcoutts> ivanm: that's ok, just have those modules be used by the testsuite directly.
22:42:10 <Cale> But I've had a course or so on measure theory, and a course on functional analysis
22:42:32 <dcoutts> ivanm: consider that many users will want the tests run as standard, but not to get some weird version of the library/executable installed.
22:42:39 <ivanm> dcoutts: they use internal parts of the library, and I'm wanting to have the test executable depend on the library to avoid recompilation
22:42:54 <drdo> I guess the real intuition killer for me is the idea of subsets of the same size
22:42:58 <Cale> (and a course on topology and one on metric spaces)
22:43:08 <ivanm> dcoutts: I fail to see why any users would want to run the tests anyway! ;-)
22:43:11 <Cale> well, what do you mean by size? :)
22:43:24 <dcoutts> ivanm: if they use internal parts of the lib then you definitely need to have the testsuite use those modules directly
22:43:36 <dcoutts> ivanm: if they're non-exposed modules I mean
22:43:38 <Cale> Do you mean sets of the same measure, or sets of the same cardinality?
22:43:48 <drdo> Cale: The usual idea, what cantor meant
22:43:59 <Cale> That'd be cardinality
22:44:34 <drdo> I've never looked into measure, no idea what that is
22:44:46 <ClaudiusMaximus> woe.  i have big efficiency problems, things are being recomputed too often.  tried  class MagicCache t where magic :: t -> Cache t  instance NaturalNumber p => MagicCache (Foo p) where magic = const cacheFoo
22:45:07 <ivanm> dcoutts: it uses non-exposed modules; but if I make the modules defining the instances & properties (which use the non-exposed modules) part of the test-suite, then I can't have the test-suite depend on the library
22:45:27 <Cale> ah, it's a way of assigning "lengths" (or "areas", "volumes", etc.) to a family of subsets of a space.
22:45:27 <dcoutts> ivanm: that's not quite true
22:45:35 <ivanm> dcoutts: oh? then how?
22:45:53 <dcoutts> ivanm: oh, well maybe it is since the instances and properties probably also depend on non-exposed modules.
22:46:03 <ivanm> yup
22:46:16 <ClaudiusMaximus> i also have   class NaturalNumber p => NeedsMagic (Foo p) where foo = ... magic ...
22:46:23 <ivanm> which is why I currently have it as part of the library, and the test executable just defines main, etc.
22:46:31 <dcoutts> ivanm: then yes, you have to have the testsuite use the lib modules directly, so it can get at everything
22:47:05 <dcoutts> ivanm: but if you were to do it that way, you'd be changing the library interface depending on if you built the testsuite or not
22:47:24 <dcoutts> which isn't sensible, and is greatly discouraged
22:47:33 <ClaudiusMaximus> would it help the magic cache actually cache in any way if i adjusted it all to be   class (NaturalNumber p, MagicCache (Foo p)) => NeedsMagic (Foo p) where ...
22:47:33 <ivanm> dcoutts: so if I want to avoid recompilation, then I either need to expose the internal modules or keep doing it my dodgy way without the test-suite stuff?
22:48:02 <ivanm> dcoutts: well, IMHO if anyone not hacking on it directly enables the test flag, then IMHO they're crazy :p
22:48:17 <dcoutts> ivanm: think of it like the gentoo USE=test thing
22:48:30 <ivanm> yeah, I never used that :p
22:48:41 <Cale> drdo: If we have some set X, then a subset F of its powerset is called a sigma-algebra for X if: 1) F is not empty, 2) F is closed under taking complements, that is, if A is in F, then so is X \ A = {x in X: x not in A}, and 3) F is closed under countable unions: If A_1, A_2, ... are in F, then so is union over i of A_i
22:48:54 <drdo> haha
22:49:03 <drdo> I was reading exactly that on wikipedia
22:49:33 <dcoutts> ivanm: many users did, and similarly build bots etc will, and then probably use those libs to compile other things. So you really don't want it giving you different things.
22:49:47 <ivanm> yeah
22:49:57 * ivanm grumbles
22:50:18 <ivanm> dcoutts: seeing as how it takes 9 min to compile, I was hoping I could avoid having the test-suite wanting to recompile everything :s
22:50:28 <drdo> Cale: One thing i've noticed that bothers me is that mathematicians don't abstract much
22:50:30 <ivanm> GHC doesn't seem to like data types with a large number of constructors :s
22:50:35 <Cale> drdo: okay, and you can probably look at the definition of a measure too
22:50:42 <Cale> drdo: What do you mean?
22:50:53 <dcoutts> ivanm: we're working on parallel builds, then it'll be ok :-)
22:50:59 <ivanm> heh
22:51:10 <ivanm> dcoutts: would that be in Cabal proper or cabal-install ?
22:51:13 <Cale> (they abstract a lot, you're just not looking far enough along :)
22:51:20 <ivanm> wait, do you mean parallel-within-a-package?
22:51:20 <dcoutts> ivanm: both actually
22:51:38 <ivanm> well, if it's in Cabal you'd hope it would be exposed in cabal-install
22:51:52 <Cale> drdo: The more that you abstract things, the more properties you lose.
22:52:03 <Cale> drdo: and the less you can say
22:52:05 <drdo> Cale: By definition of abstraction :P
22:52:12 <dcoutts> ivanm: the first bit is actually in cabal-install, and only parallel between packages, within a package will be later
22:52:18 <ivanm> ahhh
22:52:22 <ivanm> how *much* later? :p
22:52:26 <Cale> So at a point, it becomes counterproductive to abstract further in various settings.
22:52:53 <Cale> Unless you have some reason to be more inclusive.
22:54:13 <drdo> Cale: I can't give you any specific examples right now, but it happens a lot that i'm having trouble understanding something and when i finally understand it i realise it was just the guy explaining some particular case of a generalization i'm familiar with
22:54:52 <Cale> hmm
22:55:05 <Cale> Well, it's fairly common to learn these things in reverse order of generality
22:55:12 <ivanm> dcoutts: though I would have thought that some kind of optional flag would let you have QC instances, etc. be built and exposed, and then have the test-suite enable that flag
22:55:41 <dcoutts> ivanm: you're not allowed to change the library interface based on flags.
22:56:02 <ivanm> oh, right
22:56:09 <ivanm> you mean I've been doing it wrong all along?
22:56:13 <dcoutts> because other packages cannot depend on library+flags
22:56:22 <Cale> anyway, measure spaces give you a way to generalise integration
22:56:25 <dcoutts> because such deps cannot be translated into e.g. distro packages
22:57:08 <ivanm> dcoutts: though that means that any package that wants to define QC instances either needs to have a hard dependency on QC (whether someone wants test support or not) or expose enough to be able to define an alternate package with orphan instances
22:57:15 <qnikst> hm.. how to debug conduit? i.e. see data transfers I see only way of adding some logger inside, i.e. =$= (\x -> CL.map (case () of _ | trace (..) True -> id x)
22:57:24 <ivanm> wait, how can such deps not be translated into distro packages?
22:57:51 <drdo> Cale: A common pattern i just realised is that there seems to be some weird convention of never abstracting over functions
22:57:52 <dcoutts> ivanm: right, packages and classes are tricky, you can't have the optional deps that you might want
22:57:57 <ivanm> isn't that like how every C-based package has different compile-time options, and distros have multiple different builds, etc. ?
22:58:06 <Cale> drdo: oh?
22:58:16 <Cale> drdo: How so?
22:58:21 <drdo> That failing plan B seems to be fucking everything up until it's the least clear possible
22:59:03 <Cale> drdo: I don't understand what you mean at all
22:59:07 <dcoutts> ivanm: you can freeze the result of a source based dep resolution using flags into binary packages, you cannot translate directly into binary packages because of the combinatorial explosion
22:59:15 <drdo> Cale: specific example, differential and integral calculus
22:59:31 <dcoutts> ivanm: so yes, C packages do it a bit, but it's a headache for the distros
22:59:39 <Cale> What about them?
23:00:08 <dcoutts> ivanm: they deal with it on an ad-hoc basis, there's no systematic support
23:00:17 <ivanm> yeah
23:00:30 <drdo> Cale: They are exposed in a way that maximizes confunsion and minimizes insight
23:00:40 <ivanm> *sigh* so now I have to decide whether to expose some modules, or get back the recompilation...
23:00:49 <Cale> drdo: That's a bold assertion :)
23:01:09 <Cale> drdo: Who does this?
23:01:21 <Cale> drdo: What books are you reading?
23:01:33 <drdo> Cale: Pretty much everyone, we can start with the notation
23:01:53 <Cale> There are, I'll admit, a lot of shitty first-year Calculus textbooks for engineers and scientists.
23:02:09 <Cale> Have you read Spivak's Calculus though?
23:02:40 <drdo> I read a book by some guy....
23:02:49 * wli should track it down at some point.
23:02:56 <drdo> apostol i think
23:03:44 <Axman6> I have my first year calculus book sitting right here on my desk. it's being used as a stand for my monitor =)
23:03:52 <Cale> Ah, I'm not terribly familiar with Apostol, I've heard it's pretty decent, but I haven't checked to see if it actually is :)
23:04:08 <Axman6> reight under my CCNA companion guide
23:04:29 <ivanm> dcoutts: another question: have you considered switching the index-00 tarball to using rsync or something for syncing?
23:04:38 <ivanm> the tarball is starting to get rather large and take a while to download
23:04:46 <ivanm> when most of it doesn't change...
23:04:52 <wli> I should get Apostol too for reference if I should ever need it.
23:05:03 <dcoutts> ivanm: no, not rsync, but yes some incremental update scheme.
23:05:15 <dcoutts> ivanm: well yes, I have considered rsync.
23:05:19 <ivanm> well, I just pulled rsync out of nowhere ;)
23:05:35 <dcoutts> working with dumb http servers is a good thing
23:06:26 <wli> I finally tracked down the convolution rule for Newtonian generating functions, \sum_{i,j,k\geq 0, i+j+k=n} \binom{n}{i,j,k} f_{i+j}\cdot g_{j+k}
23:06:28 <ivanm> though that would cause problems on windows I take it (using an existing syncing tool I mean)?
23:06:54 <dcoutts> ivanm: yes, and cause problems because it's not http
23:07:18 <Cale> wli: what is this?
23:07:34 <ivanm> oh, yeah, I've had that before with dodgy proxies
23:07:48 <ivanm> dcoutts: so you're looking at writing Yet Another Syncer? :p
23:08:00 <wli> Cale: Newton generating function convolutions, coefs of multiplied Newton series.
23:08:18 <drdo> Cale: Take the idea of talking about areas when introducing the intregral
23:08:54 <Cale> drdo: You have a problem with geometric intuition? :)
23:08:56 <drdo> That has to be a someone's idea of a practical joke
23:09:15 <drdo> I never had any intuition until i started thinking of it as a fold
23:09:21 <dcoutts> ivanm: no, something much simpler
23:09:25 <Cale> drdo: But it's not a fold
23:09:34 <ivanm> dcoutts: oh? such as?
23:09:40 <dcoutts> ivanm: general syncing is not necessary, the index is mostly append-only
23:09:50 <drdo> Cale: It totally is!
23:10:02 <dcoutts> ivanm: it's almost as simply as just downloading the tail of the index
23:10:05 <Cale> Okay, maybe. What fold is it?
23:10:09 <dcoutts> simply/simple
23:10:10 <drdo> the fundamental theorem makes shitloads of intuitive sense then
23:10:18 <ivanm> you can download only a portion of a tarball?
23:10:43 <dcoutts> ivanm: how do you think http download resume works? it's http range requests.
23:10:56 <ivanm> ahhh, right
23:11:55 <Cale> drdo: How did you define the integral? The Darboux definition?
23:12:09 <drdo> f(a) + sum (D f) [a to b] = f(b) <-- this makes a ton of intuitive sense if you think about it as summing up the changes
23:12:38 <Cale> drdo: sup of lower sums = inf of upper sums?
23:13:13 <drdo> Cale: I never got any intuition from that
23:13:30 <Cale> Well, you seem to be talking about either a lower or upper sum there
23:13:41 <drdo> You can have me read the definition of the riemann integral for weeks and i never get intuition
23:13:52 <Cale> Riemann's definition sucks :P
23:14:06 <Cale> http://en.wikipedia.org/wiki/Darboux_integral
23:14:08 <drdo> Cale: I mean summing the infinitesimal changes
23:14:13 <Cale> ^^ that's the one everyone should use :)
23:14:18 <ivanm> does anyone know *why* GHC takes so long to compile modules with data types with a large number of constructors?
23:14:18 <drdo> as in some sort of fold over the continuum
23:14:37 <ivanm> I'm getting tempted to mark those modules to use -O0 :/
23:14:56 <Cale> drdo: You can do that, but try formalising it and it gets really hairy, and you end up talking about nonprincipal ultrafilters :)
23:15:31 <Cale> (which are much less intuitive than anything we've talked about so far :)
23:15:59 <Cale> (you can't construct them without the axiom of choice, for one)
23:16:25 <drdo> Cale: I've been reading about set theory lately, i'm not very happy with anything i've read
23:17:16 <Cale> Set theory beyond the basic stuff that everyone knows becomes insanely technical.
23:17:28 <drdo> Cale: no, the very axioms, they are all ugly
23:17:34 <Cale> meh, they're not bad
23:17:38 <drdo> the ones i've read
23:17:40 <tomprince> You should study type-theory instead. Nobody actually uses set theory formally (unless you are talking about how Halmos presents it)
23:18:29 <drdo> tomprince: Yeah, i was actually reading a book about it a few days ago
23:18:55 <Cale> Well, depending on what you mean by 'uses formally'. I'll agree that nobody in their right mind writes anything significant in plain symbolic first order logic with ZFC.
23:19:22 <Cale> But that's the place you work your way down to when eliminating confusion.
23:20:05 <qnikst> Cale, use lebeg one http://en.wikipedia.org/wiki/Lebesgue_integration =)
23:20:18 <Cale> qnikst: Well, that's not equivalent ;)
23:20:22 <Cale> qnikst: But sure.
23:21:01 <tomprince> Well, I think people might profess that is the case. But I don't think that really captures how people think about things.
23:21:49 <Cale> The important thing isn't to be formal, but to be formalisable :)
23:22:17 <tomprince> Sure, but I don't think ZFC is the right tool for that job.
23:22:27 <drdo> I don't like it
23:22:33 <drdo> I think it's beyond ugly
23:23:02 <drdo> You can feel the hacks while reading
23:23:09 <Cale> Like what?
23:23:16 <Cale> What's hacky about it?
23:23:49 <tomprince> As a tool for formalizing math, it is hacky.
23:24:15 <Cale> In what way though?
23:24:16 <tomprince> Definition of ordered pair, for example. An elegant hack, mind you.
23:24:41 <tomprince> The fact that \in is totatally defined.
23:24:46 <Cale> Well, there's not really one way to do that.
23:24:49 <drdo> Cale: It's just a bunch of seemengly unrelated axioms out of nowhere
23:24:55 <drdo> *seemingly
23:25:01 <Cale> drdo: Take more time to understand what they all mean?
23:25:44 <drdo> Cale: I made a note to define my own and see how it goes but i've been busy
23:26:30 <Cale> Most of them are things which we use constantly everywhere that we deal with sets in mathematics, apart from replacement and regularity.
23:26:59 <Cale> and the importance of those two makes itself pretty clear once you start diving into set theory proper
23:27:03 <drdo> The names as well, they seem to have been picked for minimum intuition
23:27:24 * hackagebot blaze-svg 0.3.0.0 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.0.0 (DeepakJois)
23:27:55 <Cale> What name would you like an explanation of?
23:28:25 <tomprince> replacement seems like an ugly artifact.
23:28:36 <drdo> I rememeber one that i called "filter axiom"
23:28:48 <drdo> and had a fucked up name
23:29:32 <drdo> something about always being able to make a subset by filtering out elements
23:29:41 <Cale> tomprince: It gets used to construct most of the ordinals.
23:29:54 <Cale> drdo: That one's usually called comprehension
23:30:11 <Cale> drdo: because it's what lets you make sense of things like {x in A: P(x)}
23:30:23 <drdo> Cale: That notation annoys me so much
23:30:45 <Cale> drdo: It says that if A is any set and P is any predicate on sets, then {x in A: P(x)} is a set, essentially.
23:31:25 <tomprince> I'm not denying its usefulness when doing zfc, just that it seems bothersome.
23:32:36 <drdo> I never enjoyed these axiomatic definitions
23:33:42 <drdo> They don't capture any of the original intuitive idea that led people to them
23:34:04 <Cale> tomprince: I wonder if those two could be replaced by some assertions about the von Neumann hierarchy
23:35:42 <drdo> Hmm, why do we need sets anyway?
23:35:52 <drdo> Sets like these anyway
23:36:34 <Cale> drdo: Why do we need any mathematics at all? :)
23:36:49 <drdo> Can't we just take the λ calculus and be happy?
23:37:30 <Cale> Which lambda calculus?
23:37:35 <tomprince> Which lambda calculs?
23:37:39 <tomprince> :)
23:37:50 <Cale> Are you essentially saying "why can't we get by defining everything in terms of predicate logic alone?"
23:38:13 <drdo> I only know one
23:38:16 <tomprince> Take a nice dependently typed one with inductive and coinductive definitions, and I'd say yes.
23:38:18 <drdo> typed ones don't count
23:38:28 <Cale> drdo: the untyped one is inconsistent
23:39:08 <tomprince> Untyped lambda calculus is at least as bad a formalism as zf. (for mathematics)
23:39:19 <Cale> It's much worse
23:39:23 <drdo> That's not really fair
23:39:40 <drdo> zf still uses a logic
23:39:43 <Cale> We *know* that the untyped lambda calculus is inconsistent
23:39:59 <Cale> We don't know (and don't suspect) that ZF/ZFC are.
23:40:51 <Cale> Personally, I like having a distinction between truth and falsity in my mathematics :)
23:41:00 <c_wraith> that seems unnecessarily complicated
23:41:53 <drdo> Cale: I've been wondering about truth, does it really matter?
23:42:05 <Cale> drdo: Does anything?
23:42:19 <drdo> Is there any point talking about the truth of something you can't prove or disprove?
23:42:22 <ivanm> why doesn't having ":set -fno-warn-unused-do-bind" in a .ghci file work?
23:42:37 <Cale> drdo: Only in a technical sense where it's defined.
23:42:52 <yitz> hi Cale
23:42:56 <Cale> hello
23:43:03 <ivanm> oh, does the $HOME/.ghci file get loaded after the local one?
23:43:13 <Cale> drdo: If I'm using ZFC to prove things about some other logical system, say L
23:43:21 <yitz> the topic of "who is the maintainer of lambdabot" came up here yesterday
23:43:27 <Cale> drdo: and I have an interpretation of statements of L as statements about sets in ZFC
23:43:41 <timthelion> drdo: I cannot prove that food tastes good, but the truth of the matter is quite fundumental to my daily ruitine.
23:43:42 <yitz> Cale: you always say that you are the operator, not the maintainer, of lambdabot
23:43:46 <Cale> drdo: then even if L doesn't prove or disprove some statement internally
23:43:57 <Cale> drdo: I can still ask about whether its interpretation is true or false
23:44:09 <drdo> timthelion: Your problem is not even that, you can't even define what you're trying to talk about :P
23:44:16 <Cale> (in ZFC, now)
23:44:24 <Cale> yitz: indeed
23:44:32 <Cale> yitz: there is none
23:44:38 <mm_freak> pure, lazy functional languages are translated to a core language that is then compiled…  i wonder:  isn't there a core language implementation ready to be used?
23:44:44 <yitz> Cale: however, on the lambdabot home page - namely the wiki page - the "current maintainer" is defined as the one who gets patches sent to them when you use darcs send
23:44:46 <Cale> yitz: Or maybe it's gwern
23:44:48 <yitz> Cale: that's you
23:45:02 <Cale> yitz: what's that? I didn't write that page.
23:45:12 <Cale> yitz: :)
23:45:30 <yitz> Cale: so if you don't want to be defined as the maintainer, you may want to commit a change to the darcs repo that fixes that.
23:45:33 <mm_freak> how useful is pisigma?
23:45:50 <timthelion> Cale: you were folunteered.
23:45:57 <drdo> Cale: What do you mean you can still ask?
23:45:59 <Cale> timthelion: Sure seems that way
23:46:39 <timthelion> s/f/v/
23:47:13 <Cale> drdo: I mean that you can apply your interpretation to turn the statement in L into a statement of ZFC
23:47:43 <Cale> drdo: and you can actually do something more refined than this
23:48:15 <Cale> drdo: and ask if the statement is true in all models
23:48:27 <timthelion> drdo: I don't think it's so difficult to define tasting good.  The trouble is trying to define the difference between "wanting to do something, and doing something because there is a gun pointed at you"
23:48:27 <drdo> Cale: The thing is that we have proven that there's stuff we can't prove or disprove
23:48:38 <drdo> What is the sense in talking about the truth of such things?
23:49:04 <Cale> drdo: There's only sense in asking about it in the context where we have one logical system embedded inside another
23:49:30 <timthelion> drdo: the sense is, in that food tastes good, but for example the flying wombats in space don't concern us.  Every single seccond we act on our knowledge of unprovable truths.
23:49:36 <Cale> drdo: and it's not well-defined until we actually specify what that is.
23:49:50 <drdo> timthelion: Oh you don't think? I'll tell you something, pick any word you like and define it and i'll show you how it either doesn't include plenty of stuff you wanted to include (or includes too much)
23:49:54 <Cale> I'm talking about mathematics here :)
23:50:02 <Cale> not bread
23:50:47 <timthelion> Cale: mathematicians cannot even attempt to prove or disprove something, before breakfast :)
23:51:12 <Cale> timthelion: Well, before coffee at least.
23:51:18 <ivanm> dcoutts: ummm.... why does listing a Build-Depends of QC in the test-suite section make it a dep for the library when I haven't enabled the test suite?
23:51:27 <Cale> drdo: The truth or falsity of mathematical statements always comes down to what can be proved about them in some system or another.
23:51:41 <drdo> Cale: I'm talking about logics
23:51:43 <Cale> drdo: So don't worry about that :)
23:51:45 <yitz> timthelion: the opposite is true. mathematicians can't sit down to breakfast until they have first proven something.
23:51:55 <yitz> Cale may be right about the coffee though.
23:52:08 <drdo> mathematics is a level up
23:52:57 <Cale> drdo: When people talk about a statement being true but unprovable, there's an implied framework which involves a bunch of not-just-logic mathematics.
23:53:33 <drdo> Cale: Can i have an example?
23:53:41 <Cale> drdo: Where you build up a logic as a mathematical object in your ambient mathematical system, so that you can actually talk about the statements of that logic as mathematical objects.
23:53:42 <drdo> Something that people say is true but can't be proved
23:54:01 <drdo> (and no, making up some gimped logic doesn't count)
23:54:27 <Cale> But making up a gimped logic is the easiest way to see what's going on :)
23:54:50 <drdo> What's going on is fairly simple
23:55:05 <Cale> Like, if I just take the first order language with addition, say
23:55:09 <drdo> We humans sort of agree on some rules and we follow them
23:55:15 <Cale> but take no axioms
23:55:58 <Cale> Then I can have an interpretation of that logic, which consists of a set over which the quantifiers will be taken to range, and a binary function to take the place of +
23:56:08 <drdo> Cale: what do you mean by first order language?
23:56:32 <drdo> the usual thing propositional logic + quantification over variables and so on?
23:56:51 <timthelion> Cale: So a system, founded on a set of axioms, contains three sets of statements, those who's truth our provable, those who have a truth, but who's truth is unprovable, and those who's truth are undefined.  And as you add axioms, the first two categories grow, untill you come across inconsistency and everything becomes undefined again.  Do I understand?
23:56:56 <Cale> yeah, plus a binary function symbol +
23:57:19 <drdo> Cale: I never quite understood what the hell they mean with functions there
23:57:20 <Cale> Honestly, I don't think it's even a good thing to discuss this
23:57:24 <Cale> because there's too much setup
23:57:42 <ivanm> dcoutts: nvm, read the dist/setup-config file wrong
23:57:54 <Cale> and it's easy to think you understand without actually doing so when it comes to stuff like this :S
23:58:02 <Cale> So: take a course on model theory :)
23:58:20 <timthelion> Cale: it takes a lot of set up to get down to the bare basics...
23:58:35 <Cale> timthelion: when you have an inconsistency, everything is true :)
23:58:39 <Cale> (and false)
23:58:53 <Cale> But I want to be clear here.
23:58:59 <drdo> The trouble with talking about logic is that it's unstable
23:59:00 <Cale> There's no objective reality for mathematics
23:59:04 <timthelion> Cale: isn't that the same as being undefined?
23:59:11 <Cale> Ultimately
23:59:15 <drdo> just one slip and we'll be going down the slope of pointless philosophy
23:59:27 <Cale> timthelion: Sort of, I guess.
