00:02:34 <Orclev_> is there an equivalent to mod for floating point numbers?
00:03:32 <copumpkin> :t mod'
00:03:33 <lambdabot> forall a. (Real a) => a -> a -> a
00:04:59 <Orclev_> copumpkin: perfect, thanks, just took me a min to track that down in the Data.Fixed module
00:05:08 <copumpkin> yeah, not sure it really belongs in there
00:05:16 <c_wraith> @src Real
00:05:16 <lambdabot> class  (Num a, Ord a) => Real a  where
00:05:16 <lambdabot>     toRational      ::  a -> Rational
00:05:31 <c_wraith> yeah, that doesn't looked Fixed
00:13:09 <adnauseam> is quot = quotient ?
00:14:01 <adnauseam> nvm, got it
00:23:45 * hackagebot wai-app-file-cgi 0.5.9 - File/CGI/Rev Proxy App of WAI  http://hackage.haskell.org/package/wai-app-file-cgi-0.5.9 (KazuYamamoto)
00:28:45 * hackagebot mighttpd2 2.5.10 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.10 (KazuYamamoto)
01:08:43 <womb_> > 7*7
01:08:44 <lambdabot>   49
01:09:11 <mauke> > ord '1'
01:09:12 <lambdabot>   49
01:18:20 <rekado> Hi, is it possible to define a FromJSON instance for a custom type such that it outputs a list of missing keys (i.e. Either [String] a) instead of Nothing?
01:18:46 * hackagebot hsx 0.10.2 - HSX (Haskell Source with XML) allows literal XML syntax in Haskell source code.  http://hackage.haskell.org/package/hsx-0.10.2 (NiklasBroberg)
01:18:48 * hackagebot HJScript 0.6.1 - HJScript is a Haskell EDSL for writing JavaScript programs.  http://hackage.haskell.org/package/HJScript-0.6.1 (NiklasBroberg)
01:18:50 * hackagebot hsp 0.7.1 - Haskell Server Pages is a library for writing dynamic server-side web pages.  http://hackage.haskell.org/package/hsp-0.7.1 (NiklasBroberg)
01:19:40 <womb_> ord '1'
01:19:46 <womb_> > ord '1'
01:19:47 <lambdabot>   49
01:20:31 <rekado> Hi, is it possible to define an Aeson FromJSON instance for a custom type such that it outputs a list of missing keys (i.e. Either [String] a) instead of Nothing?
01:21:42 <rekado> or do I need to change my data type so that all fields are wrapped in a Maybe?
01:24:52 <mm_freak> rekado: as far as i see you can't really do that with aeson's interface, but you aren't supposed to anyway…  i recommend to understand aeson as an encoding library, from which you translate your data into a higher level representation
01:25:15 <mm_freak> at least for more complicated applications
01:26:58 <rekado> mm_freak: I see. I'm using Aeson to parse JSONs that come in over a socket. They may be malformed and I want to respond with better error messages than just "parse failed".
01:27:48 <rekado> I think I could parse the JSON as a HashMap first and do lookups.
01:27:55 <rekado> but that seems hackish.
01:28:33 <mm_freak> rekado: you can provide a parser manually
01:28:50 <mm_freak> the parser combinators aeson uses support more meaningful error messages
01:30:10 <rekado> mm_freak: do you mean in the instance declaration of parseJSON?
01:31:06 <mm_freak> yeah
01:31:22 <mm_freak> although on a second look i don't see how to raise custom error messages
01:31:30 <mm_freak> probably by using 'fail'
01:52:51 <rekado> mm_freak: thanks, I think I can make this work with `fail`
02:11:54 <mrout> What's a monad?
02:12:30 <MHD0> mrout: A category-theoretic construct that chains computations sequentially
02:12:41 <startling> monad definition?
02:12:58 <mrout> MHD0: category-theoretic?
02:13:11 <tzxn3> a burrito
02:13:12 <jgr> mrout: a party of mathematics.
02:13:14 <MHD0> mrout: It's a more general version of Set theory
02:13:16 <jgr> *part
02:13:21 <drgreenthumb> A monad is simply a monoid in the category of endofunctors. [sorry couldn't resist]
02:13:34 <jgr> guys, don't be that mean ^^
02:13:52 <mauke> mean?
02:13:59 <startling> so what's a functor in category theory?
02:14:03 <shachaf> MHD0: That's both wrong and unhelpful.
02:14:14 <merijn> mrout: If you were asking from a "learning haskell"-perspective I wouldn't worry to much about the existing explanations and confusing answers here and just study the implementation and type signatures
02:14:15 <jgr> like, killing an newbie with theoretical stuff.
02:14:18 <MHD0> shachaf: It is how I think about it
02:14:22 <shachaf> mrout: You should read what the FAQ has to say! It might answer your question even if you're not sure what your question is.
02:14:25 <shachaf> @where faq
02:14:25 <lambdabot> http://www.haskell.org/haskellwiki/FAQ
02:14:37 <mauke> jgr: the "newbie" started it
02:14:42 <MHD0> Anyway, Monads allow you to "do" stuff
02:14:50 <MHD0> do x; y; z
02:14:53 <jgr> mauke: yeah, but he didn't know.
02:14:56 <shachaf> mauke: What do you mean?
02:14:56 <mrout> I'm interested in both how it applies to programming AND mathematically
02:14:56 <tzxn3> it's a type that defines bind and return functions
02:15:00 <mauke> jgr: how do you know?
02:15:00 <tzxn3> :p
02:15:12 <MHD0> mrout: Arrows are more fun anyway
02:15:15 <jgr> mauke: if he does, don't feed him.
02:15:16 <merijn> mrout: They're just another abstraction, unfortunately they're abstract to the extent that they're not that easy to explain (other than generalising from various examples)
02:15:17 <tzxn3> which obey the monad laws
02:15:58 <merijn> mrout: From a programming perspective I would first look at the implementation of the Maybe, Either and list monads
02:16:37 <MHD0> mrout: And also look at the definition of the Monad class as well, and how the "do" statement is syntactic sugar
02:16:53 <shachaf> This channel is horrible.
02:17:04 <MHD0> shachaf: how so?
02:17:09 <timthelion> @seen dmwit
02:17:09 <lambdabot> Unknown command, try @list
02:17:18 <stefan-_> monad = chainable datastructure?
02:17:34 <timthelion> no @seen?
02:17:36 <MHD0> stefan-_: Mmmmm. Some of them are.
02:17:40 <shachaf> stefan-_: No.
02:17:42 <timthelion> !seen dmwit
02:17:45 <shachaf> The FAQ has good answers for this.
02:17:57 <merijn> stefan-_: chainable operations resulting in a datastructure would be a better, but still not completely correct definition
02:18:00 <tzxn3> not a data structure
02:18:01 <mrout> So IN HASKELL a monad is a composition of functions?
02:18:06 <jgr> mrout: no
02:18:07 <donri> preflex: xseen dmwit
02:18:07 <preflex>  dmwit was last seen on freenode/#haskell 4 hours, 43 minutes and 48 seconds ago, saying: If it builds after relaxing the constraints, you're probably fine (but no guarantees).
02:18:08 <tzxn3> chainable computation
02:18:10 <stefan-_> data + functions
02:18:18 <MHD0> mrout: it is a chainable computation
02:18:19 <mauke> mrout: in Haskell, Monad is a typeclass
02:18:21 <shachaf> mrout: No, it isn't. Did you look at the FAQ?
02:18:23 <merijn> stefan-_: For example, the "(->) r" and IO monads are not really data structures
02:18:37 <shachaf> This channel is full of misinformation right now so I'd recommend that you read that instead.
02:18:42 <stefan-_> yep, i mean it in a more abstract way
02:18:51 <stefan-_> it can contain data and has at least 3 functions
02:18:54 <tzxn3> or just forget monads
02:19:03 <merijn> stefan-_: It's not a completely stupid intuition, if that's what you're asking
02:19:06 <blackdog> shachaf: it does look a bit like the blind men trying to describe the elephant
02:19:11 <stefan-_> right =)
02:19:17 <jgr> i'm gonna go and forget about this channel for 10 minutes. maybe the discussion will be over ;)
02:19:27 <merijn> stefan-_: Just be aware it's not fully accurate
02:19:29 <tzxn3> youcan use them without understanding the underlying API
02:19:30 <timthelion> mauke: what are you talking about, monads are burritoes inside onions being thrown out of jet planes and observed by quantum phisicists.
02:19:30 <shachaf> blackdog: I'm probably best off following jgr's lead here.
02:19:40 <shachaf> Rather than getting annoyed about it.
02:19:47 <MHD0> Sometimes it hurst me that there isn't a Point class that implements the return/pure/w/e function
02:19:50 <merijn> blackdog, shachaf: I think it mostly people trying to copy the in-jokes at a time that they are wildly inappropriate
02:19:54 <mauke> @quote .chocolate
02:19:54 <lambdabot> SimonBrenner says: 2kg of chocolate 'thunks' to 'force' really might 'blow your stack' later on.
02:20:01 <MHD0> and that not all Monads by definition are Applicative
02:20:06 <stefan-_> merijn, so it is rather a chainable computation?
02:20:19 <MHD0> stefan-_: yes
02:20:23 <stefan-_> aka you build the computation before executing it
02:20:23 <shachaf> stefan-_: "chainable computation" is a meaningless phrase unless you say what it means.
02:20:33 <shachaf> But for any reasonable meaning of that phrase I can think of, the answer is "no".
02:20:40 <MHD0> hehehe
02:20:44 <mauke> shachaf: how do you execute a list?
02:20:49 <mauke> er
02:20:51 <mauke> stefan-_:
02:20:52 <shachaf> mauke: Huh?
02:20:54 <shachaf> Ah.
02:20:56 <merijn> stefan-_: I would say composable and I'm not sure I would agree with the use of computation for all possible instances.
02:20:59 <MHD0> mauke: The list is nondeterministic computation
02:21:09 <MHD0> it generates every result
02:21:13 <mauke> MHD0: so how do you execute a list?
02:21:14 <mrout> I feel slightly closer to understanding this.
02:21:27 <merijn> stefan-_: Composable computation is a nice view for the IO monad, though.
02:21:39 <timthelion> mauke: I execute a list every time I folow directions :)
02:21:43 <MHD0> mauke: [1, 2] is a variable that is either 1 or 2 and the list monad will generate the result accordingly
02:21:44 <shachaf> Do you want to learn about "monad" or about "IO"?
02:21:47 <shachaf> IO is a terrible example of a monad.
02:21:49 <mauke> MHD0: so how do you execute a list?
02:21:52 <MHD0> mauke: thin Prolog
02:21:52 <stefan-_> mauke, you can apply a filter to a list
02:21:54 <shachaf> Is it even a monad?
02:21:57 <MHD0> mauke: think
02:21:58 <tzxn3> monad is a broad, abstract category
02:22:02 <mauke> MHD0: so how do you execute a list?
02:22:19 <mauke> stefan-_: er. and?
02:22:25 <stefan-_> mauke, that is a computation on a list
02:22:28 <MHD0> mauke: do x <- [1, 2]; return (x + 2)  ? what exactly are you asking?
02:22:31 <mauke> stefan-_: and?
02:22:37 <timthelion> mauke: it's easy to execute a list.  That has nothing to do with IO monad though.
02:22:43 <stefan-_> <mauke> shachaf: how do you execute a list?
02:22:53 <MHD0> > do x <- [1, 2]; y <- [3,4]; return (x, y)
02:22:54 <lambdabot>   [(1,3),(1,4),(2,3),(2,4)]
02:23:02 <mauke> stefan-_: I wasn't asking for computations on lists
02:23:04 <jgr> *sigh*
02:23:27 * timthelion goes back to banging his head against the wall.
02:23:34 <stefan-_> mauke, you mean the term execution?
02:23:38 <mauke> yes
02:23:53 <mauke> <stefan-_> aka you build the computation before executing it
02:24:31 <mauke> if we take the "computation" provided by MHD0 (do x <- [1, 2]; y <- [3,4]; return (x, y)), we get [(1,3),(1,4),(2,3),(2,4)]
02:24:38 <mauke> so how do we "execute" it?
02:24:47 <MHD0> mauke: taboo execute
02:25:01 <MHD0> mauke: replace the symbol with substance
02:25:18 <merijn> drgreenthumb: btw, the monads are a monoid in the category of endofunctors (or whatever the proper formulation is) "joke" is completely unhelpful and terribly confusing to newcomers. So I would ask you to control yourself and refrain from making it when people are asking confused questions
02:25:24 <stefan-_> mauke, not sure if there is a better term
02:25:32 <mauke> stefan-_: for what?
02:25:40 <stefan-_> for running the monad
02:25:42 <timthelion> mauke: data Command = Turn Int | Go Int ; list :: Command ; list = [Go 20,Turn 90,Go 30,Turn 30];-- a perfectly excecutable list :D
02:25:48 <stefan-_> or the composition
02:25:50 <mauke> stefan-_: you don't run a monad
02:25:54 <mauke> stefan-_: or composition
02:25:56 <stefan-_> nvm
02:26:06 <mauke> stefan-_: I think my issue is with concepts, not terms
02:26:20 <MHD0> mauke: a computation is a Monad
02:26:23 <timthelion> s/:: Command/:: [Command]/
02:26:33 <MHD0> mauke: a sequenctial computation that is
02:26:35 <mauke> timthelion: yeah, but [] :: [()] is still a monadic value :-)
02:26:41 <relation> hi, any idea how can one upgrade the Cabal library?
02:26:51 <mauke> MHD0: what do you mean by "computation"?
02:26:53 <shachaf> mauke: I think "execute" has a reasonable meaning for []
02:26:55 <dcoutts_> relation: cabal install Cabal
02:27:04 <merijn> MHD0: Not it isn't, I'm pretty sure the STM monad can do non-sequential computation
02:27:05 <MHD0> mauke: look up the definition made by computer science
02:27:05 <mauke> shachaf: is it id?
02:27:08 <relation> dcoutts_: thanks
02:27:14 <mauke> MHD0: where?
02:27:24 <merijn> s/Not/No
02:27:32 <MHD0> mauke: http://en.wikipedia.org/wiki/Computation
02:27:35 <MHD0> There?
02:27:35 <relation> dcoutts_: that simple, it should be better if google had a case sensitive search and maybe it has
02:27:35 <shachaf> mauke: It's "choose nondeterministically", in the context of do { x <- listAction; ... }
02:27:44 <merijn> mauke: In the official TCS handbook, didn't you get a copy with your degree? :)
02:28:00 <timthelion> mauke: that wasn't [()] but [Command] :D  It's easy to make an excecutble list(that WAS the original IO method for haskell), the tricky bit is making it interactive...
02:28:15 <mauke> shachaf: if that's the "execution" bit, what is the "build the computation" bit?
02:28:24 <jtobin> what are people using for linear algebra with repa?
02:28:27 <shachaf> mauke: I have no idea what "build a computation" means.
02:28:34 <mauke> timthelion: ok, I have no idea what you're talking about now
02:28:42 <jtobin> i assume that everyone isn't rolling their own LU/inverse functions
02:29:26 <mauke> shachaf: my context is still <stefan-_> merijn, so it is rather a chainable computation? <stefan-_> aka you build the computation before executing it
02:29:36 <timthelion> mauke: read up on the history of Haskell :)  Origionally, there was no IO Monad, just a lazy list of Outputs that where output, and another lazy list of Inputs that where eaten by the program...
02:29:40 <mauke> i.e. some kind of two-phase thing
02:29:47 <mauke> timthelion: I know?
02:30:04 <shachaf> mauke: As far as I can tell from those words, "execute" would just be "id" there.
02:30:12 <timthelion> mauke: that list of outputs, could contain commands.  Those commands could then be excecuted.
02:30:14 <shachaf> Or it would be whatever you do with the list. I don't know.
02:30:27 <mauke> timthelion: I know
02:30:28 <shachaf> I didn't write those words -- I don't want to justify them with meaning either. :-)
02:30:41 <timthelion> mauke: so then what's so hard about excecuting a list?
02:30:55 <mauke> timthelion: "a list" means "any list"
02:31:11 <mauke> because I'm specifically referring to 'instance Monad []'
02:31:13 <stefan-_> mauke, you can for example build a reader monad
02:31:29 <mauke> stefan-_: I'm building the [] monad
02:31:38 <stefan-_> ye, im giving another example
02:32:01 <mauke> I'm insisting on using an example that contradicts your explanation
02:32:29 <stefan-_> [] is an empty list?
02:32:44 <mauke> no, a type constructor
02:32:57 <mauke> in the context of 'instance Monad []', that is
02:33:00 <stefan-_> (im not a haskell coder, sorry)
02:33:58 <mauke> damn, MHD0 is gone
02:34:12 <mauke> I was about to ask them what they meant by "a computation"
02:35:08 <shachaf> A computation is a value :: m a for some monad m and type a.
02:35:27 <mauke> heh, isn't that circular now?
02:35:46 <mauke> we've explained monads as "sequential computation" and computation as "a monadic value"
02:35:51 <shachaf> The important part is that you can't argue with that definition.
02:35:56 <mauke> haha
02:36:13 <merijn> shachaf: Ha! You wish
02:36:38 <shachaf> mauke: Anyway, nothing wrong with a circular definition.
02:36:43 <shachaf> The conclusion is just that Monad = _|_
02:36:43 <srhb> Monadception.
02:37:01 <mauke> newtype Void = Void Void
02:37:07 <shachaf> This channel is horrible.
02:37:25 <merijn> shachaf: Nah, it is still one of the most helpful and intelligent channels
02:37:36 <merijn> It's just that sometimes the people inside forget that
02:37:54 <shachaf> Over 20 minutes of active useless discussion prompted by a single line.
02:38:06 <mauke> merijn: that just means other channels are more horrible
02:38:18 <shachaf> "#haskell one of the most helpful and intelligent channels on Freenode", reports #haskell
02:38:40 <merijn> mauke: I like to hold an optimist's view?
02:39:03 <mauke> shachaf: everything starts somewhere
02:39:33 <shachaf> And I'm part of the problem. :-(
02:39:36 <mauke> the only way to avoid "20 minutes of active useless discussion prompted by a single line" would be not having any 20 minutes of active useless discussion at all
02:39:41 <stefan-_> mauke, http://en.wikipedia.org/wiki/Free_monoid#Free_monoids_and_computing
02:39:58 <mauke> stefan-_: ?
02:40:29 <merijn> shachaf: You don't watch the Dog Whisperer? Every mistake is a chance for rehabilitation :)
02:40:57 <merijn> (In this case making it clear that complex monad jokes, while occasionally funny, are not appropriate for newbies asking questions)
02:41:23 <stefan-_> afaik free monoid ~ lists
02:41:31 <mauke> stefan-_: yes, and?
02:41:40 <stefan-_> you were talking about lists earlier
02:41:47 <mauke> and?
02:41:55 <stefan-_> i thought that could be interesting to you =)
02:42:52 <shachaf> stefan-_: Do you see what that link is saying?
02:42:52 <mauke> stefan-_: http://en.wikipedia.org/wiki/Gunter%27s_chain
02:43:21 <shachaf> It's saying: "free monoid on A" is a phrase that means "list of As".
02:43:33 <stefan-_> mauke, whats that?
02:43:45 <mauke> a url
02:43:52 <stefan-_> mauke, too nice =)
02:44:08 <mauke> I wanted to reciprocate
02:44:18 <stefan-_> you asked how you can execute sth on a list
02:44:23 <mauke> stefan-_: no
02:44:31 <mauke> I asked how to execute a list
02:44:36 <relation> any idea where can be the problem - i updated Cabal, but cabal --version shows still the same version?
02:44:45 <mauke> relation: Cabal is the library
02:44:55 <shachaf> relation: "cabal --version" runs "cabal-install", not "Cabal".
02:45:07 <dcoutts_> relation: the cabal-install package provides the cabal command line program
02:45:13 <relation> but using version 1.10.1.0 of the Cabal library
02:45:21 <stefan-_> mauke, ok imho you execute sth on a monad
02:45:21 <Saizan> relation: you've to rebuild cabal-install
02:45:58 <relation> i've ran cabal install cabal-install, but it does not help
02:46:59 <relation> can it be some path issue?
02:47:17 <dcoutts_> relation: the default version of cabal-install at the moment is the one that came with the last HP release, but you can explicitly ask for the version we released the other day: cabal install 'cabal-install >= 0.14'
02:47:41 <dcoutts_> we didn't want to break everyone's installs all at once :-)
02:47:50 <dcoutts_> so it's not yet the default version
02:48:12 <relation> dcoutts_: looks great
02:48:27 <timthelion> Is there a way to create an accont on the tack page for gtk2hs?
02:48:34 <t7> whats a type that can be expressed in system F but not HM? someone showed me ((A : *) -> A -> A) -> ((B : *) -> B -> B)     but isnt that just  A, B => (A -> A) -> (B -> B) ?
02:48:39 <timthelion> or do I have to always log in as guest
02:48:40 <timthelion> ?
02:49:01 <shachaf> t7: No.
02:49:27 <shachaf> t7: It is (B : *) -> ((A : *) -> A -> A) -> (B -> B), though.
02:49:38 <timthelion> and does anyone actually read the bug reports?
02:50:00 <dcoutts_> timthelion: seems that it's set up so that people reporting bugs use the guest account
02:50:33 <timthelion> dcoutts_: OK, more importantly, does anyone look at those bug reports?
02:50:42 <dcoutts_> timthelion: there's a new maintainer, I'm not quite sure
02:51:09 <dcoutts_> timthelion: you can ask on the mailing list for the full story
02:51:22 <timthelion> dcoutts_: OK
02:52:19 * timthelion hates mailing lists :(
02:56:04 <dcoutts_> timthelion: there's certainly development activity, I'm just not quite sure how they're using the trac
02:57:10 <timthelion> dcoutts_: OK.  I've reported two bugs and I thought at least one deserved an answer, since it was simple and obvious, but neither of them did.
02:58:31 <timthelion> I have a third bug, and I think I'll post it to the list, since it will want further discussion.
03:00:53 <srhb> Does anyone know of some recent REPA-benchmarks?
03:02:17 <dcoutts_> timthelion: my guess is you're more likely to get an answer that way, and ask what their plans with the trac are
03:04:17 <ment> @hoogle (a, b) -> (b, a)
03:04:17 <lambdabot> Data.Tuple swap :: (a, b) -> (b, a)
03:04:17 <lambdabot> Data.Graph.Inductive.Query.Monad (><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
03:04:18 <lambdabot> Data.Graph.Inductive.Query.Monad mapSnd :: (a -> b) -> (c, a) -> (c, b)
03:05:05 <ment> hoogle is so damn cool
03:07:00 <womb_> @hoogle map
03:07:00 <lambdabot> Prelude map :: (a -> b) -> [a] -> [b]
03:07:00 <lambdabot> Data.List map :: (a -> b) -> [a] -> [b]
03:07:01 <lambdabot> Prelude mapM :: Monad m => (a -> m b) -> [a] -> m [b]
03:07:13 <womb_> yes it is
03:12:23 <ment> @hoogle (a -> Bool) -> [a] -> [a]
03:12:23 <lambdabot> Prelude dropWhile :: (a -> Bool) -> [a] -> [a]
03:12:23 <lambdabot> Data.List dropWhile :: (a -> Bool) -> [a] -> [a]
03:12:23 <lambdabot> Prelude filter :: (a -> Bool) -> [a] -> [a]
03:16:27 <t7> @check f x y = not x && not y == not (x && y)
03:16:27 <lambdabot>   Parse error at "=" (column 7)
03:16:43 <t7> @check \x y -> not x && not y == not (x && y)
03:16:44 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nFalse\n"
03:20:11 <bitonic> t7: de morgan law anyone?
03:20:44 <fmap> @check \x y -> not x && not y == not (x || y)
03:20:45 <lambdabot>   "Falsifiable, after 3 tests:\nTrue\nTrue\n"
03:21:06 <t7> @check \x y -> not x || not y == not (x && y)
03:21:07 <lambdabot>   "OK, passed 500 tests."
03:21:09 <byorgey> @check \x y -> not x && not y == not (x || y)
03:21:10 <lambdabot>   "Falsifiable, after 0 tests:\nTrue\nTrue\n"
03:21:47 <byorgey> oh! hehehe
03:22:12 <byorgey> @check \x y -> (not x && not y) == not (x || y)
03:22:13 <t7> @check \x -> x == not $ not x
03:22:13 <lambdabot>   "OK, passed 500 tests."
03:22:14 <lambdabot>   Couldn't match expected type `a -> b'
03:24:34 <byorgey> darn precedence
03:24:39 <shachaf> drecedence
03:24:54 <byorgey> @check \x -> x == (not $ not x)
03:24:55 <lambdabot>   "OK, passed 500 tests."
03:25:10 <ment> why does lambdabot need 500 tests for expression with just one boolean variable?
03:25:10 <byorgey> yeah, we ought to be using smallcheck
03:25:17 <byorgey> @scheck \x -> x == (not $ not x)
03:25:17 <mauke> @check \x -> length (nub [x, not $ not x]) == 1
03:25:18 <lambdabot>   "OK, passed 500 tests."
03:25:18 <lambdabot>   "OK, passed 500 tests."
03:25:23 <byorgey> except lambdabot is being super slow.
03:25:52 <byorgey> ment: QuickCheck (the library @check uses) doesn't do any analysis like that, it just generates a bunch of random inputs
03:26:00 <byorgey> ment: but there's another library called SmallCheck designed to do exhaustive testing
03:26:12 <byorgey> hmm, I guess @scheck isn't it
03:26:15 <mauke> @smallcheck
03:26:15 <lambdabot> Unknown command, try @list
03:26:21 <byorgey> @list
03:26:21 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
03:26:53 <byorgey> apparently it's supposed to be scheck, but it doesn't seem to work
03:28:48 <ment> @check \x -> length x == 3
03:28:49 <lambdabot>   "Falsifiable, after 0 tests:\n[]\n"
03:29:11 <geekosaur> @listmodules
03:29:11 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact free fresh ft haddock help hoogle instances irc karma localtime more oeis offlinerc pl pointful poll pretty quote search
03:29:12 <lambdabot> slap source spell state system tell ticker todo topic type undo unlambda unmtl version where
03:29:22 <geekosaur> @list check
03:29:22 <lambdabot> check provides: check
03:29:45 <geekosaur> no smallcheck in this lambdabot, it seems
03:30:01 <ment> @check \x -> length x < 15
03:30:01 <lambdabot>   "Falsifiable, after 44 tests:\n[(),(),(),(),(),(),(),(),(),(),(),(),(),(),(...
03:30:07 <byorgey> geekosaur: I see, it doesn't have the small module included
03:30:09 <ment> byorgey: well it already has to figure out the domain just to be able to pass "something"
03:30:15 <mauke> ment: no, actually
03:30:15 <byorgey> ment: yes, but "figuring out" the domain is just type inference, nothing special
03:30:30 <ment> byorgey: like fromInteger or something?
03:30:57 <mauke> @check join (==)
03:30:58 <lambdabot>   "OK, passed 500 tests."
03:31:06 <byorgey> ment: yes, it's type inference + a type class that says how to generate random things of various types
03:31:21 <mauke> @check ?x
03:31:22 <lambdabot>   Unbound implicit parameter (?x::a)
03:31:22 <lambdabot>    arising from a use of implicit parame...
03:31:24 <ment> byorgey: nice
03:32:39 <mauke> @check read ""
03:32:42 <lambdabot>   Add a type signature
03:32:48 <mauke> :-(
03:34:41 <mauke> @check ()
03:34:42 <lambdabot>   "Arguments exhausted after 0 tests."
03:35:09 <byorgey> heh, never seen that one before
03:35:32 <mauke> @check pi
03:35:32 <lambdabot>   Add a type signature
03:35:48 <bitonic> @type pi
03:35:49 <lambdabot> forall a. (Floating a) => a
03:36:00 <bitonic> @src pi
03:36:01 <lambdabot> Source not found. You untyped fool!
03:36:03 <bitonic> eh.
03:36:11 <bitonic> ah right.
03:36:13 <bitonic> it's in Floating eheh
03:37:31 <mauke> @check Just ()
03:37:32 <lambdabot>   No instance for (Test.QuickCheck.Testable (Data.Maybe.Maybe ()))
03:37:32 <lambdabot>    arising...
03:38:05 <sipa> @check pi < 4
03:38:07 <lambdabot>   "OK, passed 500 tests."
03:39:55 <donri> @check const True
03:39:56 <lambdabot>   "OK, passed 500 tests."
03:55:47 <Kakadu> a little bit offtoptic. We can I read about two approaches of backtracking in parser-combinators?
03:57:47 <t7> coding in c++ seems such hard work now
03:58:04 <t7> so much boiler plate and shared_ptr crap
03:58:20 <t7> but i do like that it isnt garbage collected. I should make my mind up
04:04:03 <bitonic> Kakadu: what two approaches? whether <|> should or shouldn't backtrack?
04:04:39 <Saizan> depth-first or breath-first i guess
04:04:53 <Kakadu> bitonic: I think people want to hear about naive approach and packrat
04:04:57 <bitonic> oh
04:05:28 <bitonic> isn't packrat something specifig to PEGs?
04:05:54 <Kakadu> O don't kno much about PEG
04:05:56 <Kakadu> I*
04:06:10 <Kakadu> It seems that packrat memoizes results
04:06:15 <bitonic> well, I don't know much either, so you'll have to wait for someone else :)
04:06:43 <bitonic> but I never heard of "two approaches" to backtracking, apart maybe what Saizan said
04:13:55 <t7> can type Constructors be infix?
04:14:04 <Eduard_Munteanu> Is there any connection between monads and hylomorphisms? I figured since any monad T comes from an adjunction F -| U, T = UF, one might interpret that as building up a structure and collapsing it.
04:14:14 <quicksilver> t7: yes.
04:14:14 <hpc> t7: yes; might need an extension though
04:14:20 <hpc> they also need to start with a capital symbol
04:14:24 <quicksilver> it doesn't need an extension.
04:14:28 <hpc> which at the moment means it has to start with ':'
04:14:54 <t7> thats clever :)
04:14:56 <Eduard_Munteanu> Not necessarily freely (as in free -| forgetful), I figure you can pick something that makes sense.
04:15:33 <geekosaur> I'd have said "generalization of infix (:)" but whatever
04:15:33 <quicksilver> data Bar = Bar Int Int; x = 4 `Bar` 5
04:15:57 <Eduard_Munteanu> You need an extension for infix *type* constructors IIRC.
04:16:40 <t7> what about kind constructors?
04:16:49 <adamt> Sorry about the log{in,out} spam, this network has less bandwidth than you get by plugging your ethernet cable into a rock.
04:17:11 <hpc> can't write your own kinds, afaik
04:17:28 <Eduard_Munteanu> Well, there's only (->) for kinds, no?
04:17:35 <Alan> when making a type an instance of Show, is there a way to fall back to the "default" show for all cases except one?
04:17:44 <quicksilver> Alan: no.
04:17:47 <Alan> i.e. what you'd get if you just did "deriving (Show)"
04:17:57 <Alan> because I just want to handle one special case :|
04:18:05 <quicksilver> you're doing it wrong.
04:18:11 <quicksilver> there should be no special cases for Show.
04:18:15 <quicksilver> use deriving (Show)
04:18:26 <quicksilver> and use some other function name, if you want something different.
04:18:26 <t7> whats the next universe up from kinds? and does that have infix operators?
04:18:37 <bitonic> t7: sorts
04:18:41 <Eduard_Munteanu> t7: there isn't, not in Haskell.
04:18:50 <hpc> Alan: in general, if Show isn't really easy to deal with, you don't need to use it
04:19:15 <Alan> so is Show the wrong place to put a "nice" output format for your type then?
04:19:18 <hpc> (unless you really want to be able to 'show' a pretty-print or something, in which case you write the whole printer yourself)
04:19:34 <hpc> Alan: essentially, yes
04:19:35 <quicksilver> Alan: yes, it is the wrong place for that.
04:19:35 <bitonic> Alan: if you can read back the "nice" output than it's OK
04:19:38 <Eduard_Munteanu> Alan: exactly. You probably want to use pretty-printing combinators anyway.
04:19:49 <bitonic> Alan: otherwise you might want another function
04:20:00 <hpc> Alan: nicePrint (SpecialConstr a b c) = "MAGIC!"; nicePrint x = show x
04:20:33 <Alan> hpc: fair enough
04:21:37 <hpc> in general, Show is for "what does this thing's innards look like"
04:21:40 <ktosiek> Hi! Is it possible to have a package built with different version of dependency that is common to that package and one of depended on?
04:21:45 <Alan> i wondered if i might have been doing it wrong
04:21:54 <hpc> > Map.fromList [(0, 1), (1, 1), (1, 15)]
04:21:54 <Alan> it's just so tempting to abuse it...
04:21:55 <lambdabot>   Not in scope: `Map.fromList'
04:22:02 <hpc> > M.fromList [(0, 1), (1, 1), (1, 15)]
04:22:03 <lambdabot>   fromList [(0,1),(1,15)]
04:22:24 <ktosiek> like: A depends on B,C; B depends on C; B is built with C-0.1; can A be build with C-0.2 _and_ the version of B that is available?
04:22:54 <hpc> it's sort of an unwritten contract for Show that you should be able to evaluate the string it returns as haskell code, and get the thing back
04:23:07 <Alan> hpc: it's actually a written contract in the documentatino :P
04:23:08 <hpc> or at least, a convention
04:23:10 <Alan> *documentation
04:23:14 <hpc> Alan: orly? nifty
04:23:15 <ktosiek> hpc: unwritten as in "only in documentation"?
04:23:20 <hpc> shuddup :P
04:23:23 <Alan> or do you mean unwritten as in unenforced?
04:23:44 <hpc> i meant the wrong thing :P
04:23:54 <hpc> it's definitely unenforced though
04:23:57 <hpc> :t text
04:23:59 <lambdabot> String -> Doc
04:23:59 <ktosiek> I wonder how something like that would be even forceable
04:24:03 <hpc> > text "abcdefg"
04:24:04 <lambdabot>   abcdefg
04:24:07 <hpc> > "abcdefg"
04:24:08 <lambdabot>   "abcdefg"
04:24:17 <hpc> > text 15
04:24:18 <lambdabot>   No instance for (GHC.Num.Num GHC.Base.String)
04:24:18 <lambdabot>    arising from the literal `...
04:24:19 <hpc> > 15
04:24:19 <lambdabot>   15
04:24:26 <hpc> > text "15" -- :(
04:24:27 <lambdabot>   15
04:24:44 <ktosiek> > read "15" :: Doc
04:24:44 <lambdabot>   No instance for (GHC.Read.Read Text.PrettyPrint.HughesPJ.Doc)
04:24:44 <lambdabot>    arising fr...
04:25:07 <hpc> aw, i was kinda hoping for "read = text" there
04:26:16 <timthelion> preflex: xseen dmwit
04:26:16 <preflex>  dmwit was last seen on freenode/#haskell 6 hours, 51 minutes and 57 seconds ago, saying: If it builds after relaxing the constraints, you're probably fine (but no guarantees).
04:30:46 <womb> > ord 'A'
04:30:47 <lambdabot>   65
04:31:03 <womb> > ord 'J'
04:31:03 <lambdabot>   74
04:31:22 <fmap> > ord '1'
04:31:22 <lambdabot>   49
04:32:01 <byorgey> ktosiek: re: your question about versions, it is *possible* but strongly not recommended, as it can lead to runtime crashes
04:32:32 <ktosiek> byorgey: would cabal do this to me without some --I-know-I-know-just-do-it?
04:32:38 <byorgey> no
04:33:07 <byorgey> at least, it's not supposed to
04:33:51 <ktosiek> I'm installing a few packages not from hackage, and they have different base dependencies, should I just install them with one cabal install invocation?
04:34:02 <ktosiek> as in cabal install dir1/ dir2/ ?
04:34:13 <dcoutts> ktosiek: if you want to use them together, yes
04:34:15 <Ptival> http://haskell.xelpaste.org/4892 < question here
04:34:24 <ktosiek> thanks :-D
04:37:17 <Kakadu> bitonic: two approaches: fast back and slow back. Does these words say you something?
04:37:40 <bitonic> Kakadu: nope, sorry :P
04:38:20 <Kakadu> oh. I'm very tired from my diploma
04:40:07 <merijn> I don't suppose there's a value equivalent to _ for type variables?
04:40:54 <geekosaur> no, because _ is actually pattern syntax and you can't pattern match types
04:41:20 <sipa> geekosaur: a typeclass instance can be seen as pattern matching on types
04:41:35 <geekosaur> (you could infer this. if there were such a thing we'd probably use it to type `undefined`)
04:41:38 <Jaak> > let _ = 1 in _
04:41:39 <lambdabot>   Pattern syntax in expression context: _
04:41:52 <Jaak> mm, nice to know
04:42:04 <sipa> > let _ = 1 in 2
04:42:05 <lambdabot>   2
04:42:08 <merijn> Jaak: _ matches any pattern and ignores it
04:42:30 <sipa> > let a@_ = 1 in a
04:42:31 <lambdabot>   1
04:42:32 <merijn> Jaak: Sort of a "I don't care" for pattern matching
04:42:55 <Jaak> i know, i didn't know you couldn't use it in expression context
04:43:18 <geekosaur> what would it mean?  (other than being a very short undefined?)
04:43:27 <sipa> > let (_,_) = (1,2) in _
04:43:28 <lambdabot>   Pattern syntax in expression context: _
04:43:29 <Ptival> I would like my main file to call a function f :: typeA -> typeB, where f, typeA and typeB are defined in another file (that I can change to get different behaviors). How should I go about that?
04:43:32 <sipa> Jaak: what would that mean?
04:44:01 <merijn> geekosaur: Was that a question for me?
04:44:30 <ktosiek> Ptival: as in, change it at runtime?
04:44:37 <Ptival> I thought about using a multiparamtypeclass, but can't get things to work out
04:44:42 <Ptival> ktosiek: no, compile time
04:44:45 <ktosiek> Ptival: or just compile with different OtherFiles?
04:44:52 <geekosaur> no, it was a response to Jaak's "I didn't know you couldn't use it in expression context"
04:45:23 <Jaak> sipa: i'm not attaching any meaning to it, i just noted that it was nice to know that you couldn't do that. and that makes sense
04:45:48 <sipa> Jaak: ok :)
04:47:21 <ktosiek> Ptival: would just exporting f, typeA, typeB from that other file suffice?
04:47:48 <quicksilver> merijn: you're no the first to want it, though : http://cdsmith.wordpress.com/2010/10/24/the-need-for-partial-type-annotations/
04:48:19 <Ptival> ktosiek: hum, then I need to modify the main file (to change the import), or to modify the files on my disk (to rename the external into what is imported by the main)
04:48:51 <Ptival> I was wondering if there was a possibility of this just happening by doing ghc Main.hs OptionA.hs
04:49:22 <donri> Ptival: -XCPP?
04:49:26 <merijn> quicksilver: I had a type signature using s to denote state and then added a another input to the function (which had it's own concept of state), so I naively ended up using s for that one two, which means I had two conflicting values of s which made me go "it'd be nice to match anything without capturing it in the rest of the type"
04:49:28 <ktosiek> sounds like something for preprocessor to me, but I never used such a thing with haskell
04:49:54 <hpc> i wouldn't use CPP though
04:50:02 <hpc> it has some ridiculous C quirks
04:50:05 <hpc> better to use TH
04:50:17 <donri> can you control imports with TH?
04:50:28 <ktosiek> hpc: can TH take command line arguments?
04:50:55 <bitonic> ktosiek: yes
04:51:02 <bitonic> @hoogle runIO
04:51:02 <lambdabot> Language.Haskell.TH.Syntax runIO :: IO a -> Q a
04:51:03 <lambdabot> Language.Haskell.TH runIO :: IO a -> Q a
04:51:03 <lambdabot> Language.Haskell.TH.Syntax qRunIO :: Quasi m => IO a -> m a
04:51:54 <bitonic> you can sneak a "rm -rf /" in a TH expression ehe
04:52:39 <seven_sir> 有人在么？
04:52:40 <seven_sir> hello?
04:52:48 <Eduard_Munteanu> seven_sir: hi
04:52:51 <geekosaur> not quite sure about command line arguments but environment would work
04:53:13 <seven_sir> where are from?
04:53:24 <bitonic> @type runIO getArgs
04:53:25 <lambdabot> Not in scope: `runIO'
04:53:25 <lambdabot> Not in scope: `getArgs'
04:53:48 <bitonic> well, it'd be 'Q [String]'.
04:54:14 <geekosaur> oh, sure, you could getArgs, the question is how to keep the rest of ghc from processing them as well
04:54:40 <donri> but what would [String] be? might depend on the compiler etc, and you'd have to parse out your own args and make sure the compiler doesn't choke on them
04:54:56 <seven_sir> 我看不懂、我英语不好、
04:54:57 <seven_sir> i dont konw、my english very poor
04:55:11 <bitonic> geekosaur, donri: right. I'm sure you can hack your way around that.
04:55:22 <donri> but is that better than CPP, then?
04:55:27 <bitonic> oh no :P
04:55:41 <bitonic> I'd never do something like that
04:56:09 <seven_sir> What？
04:56:10 <osa1> I'm getting an error about a package I already have installed, can anyone help me? http://paste.pocoo.org/show/586445/
04:56:15 <hpaste_> merijn pasted “redundant code” at http://hpaste.org/67530
04:56:37 <donri> seven_sir: i'm from sweden, there are people from all over the world in here.
04:56:44 <Eduard_Munteanu> seven_sir: well, this is an English channel, and there are multiple discussions going on.
04:56:57 <merijn> The above paste shows a repeating pattern I have (the only changing thing is the inside body of the loop), but I can't figure out how to abstract it away without passing a lot of extra variables along everywhere
04:57:00 <rzys> question: how can i round/truncate a double to a given number of digits after the point? for example: 0.333333333333333 to 0.333
04:57:00 <merijn> Any suggestions?
04:57:03 <Eduard_Munteanu> English-speaking channel, rather.
04:57:09 <seven_sir> yes
04:57:44 <merijn> rzys: You need to convert to something with a fixed precision, I guess
04:57:56 <hpc> rzys: the cheating way is to multiply by 10**digits, round, then divide
04:58:01 <geekosaur> osa1, did you by any chance install/reinstall template-haskell along the line?  that wll break a whole lot of stuff
04:58:10 <hpc> with some fromIntegrals sprinkled in to make the types cooperate
04:58:16 <merijn> hpc: That won't work if the double has no exact representation, no?
04:58:29 <geekosaur> and older cabal-install (that is, anything you'd likely encounter in the wild) will do the wrong thing more or less automatically
04:58:39 <hpc> merijn: like i said, "cheating"
04:58:41 <osa1> geekosaur: I have no idea. I just installed some haskelldb packages and then I got this
04:58:41 <bitonic> you can use printf and then read it back! ehe
04:58:54 <hpc> though it's not like there's an easy "right way" to do anything floaty
04:59:00 <rzys> hpc, thanks! ill try that right away
04:59:01 <seven_sir> 我是中国人、
04:59:02 <seven_sir> i am a chinese
04:59:28 <merijn> hmm, I just saw I typo'd the type of loop in my paste, but still close enough...
04:59:32 <bitonic> seven_sir: I like the characters, but again this is an English channel. you might want to try #haskell-ch or #haskell.ch
04:59:44 <quicksilver> > showFFloat (Just 3) 0.3333333  ""
04:59:45 <lambdabot>   "0.333"
04:59:47 <seven_sir> I need help、How to learn English
04:59:59 <quicksilver> ^^ rzys , hpc
05:00:01 <hpc> @google learn you an english for great good
05:00:03 <lambdabot> http://learnyouahaskell.com/modules
05:00:03 <lambdabot> Title: Modules - Learn You a Haskell for Great Good!
05:00:07 <hpc> lol
05:00:10 <Eduard_Munteanu> Heh.
05:00:15 <ktosiek> almost
05:00:31 <unknownwarrior> hey guys, in a recusive function i first want to putstrln an integer and then in the next line recall the function with changed parameters. but what haskell tells me is an error in the line i recall the function "no instance..."
05:00:45 <hpc> @where hpaste
05:00:46 <lambdabot> http://hpaste.org/
05:00:50 <hpc> unknownwarrior: paste your code ^
05:00:50 <Eduard_Munteanu> seven_sir: I guess you want to learn English somewhere else first, but anyway, you might be able to handle a discussion here.
05:00:57 <adamt> seven_sir: Not in here. :)
05:00:58 <hpc> (and the error)
05:01:35 <donri> seven_sir: do you know what this chat room is for?
05:01:42 <hpaste_> unknownwarrior pasted “tower” at http://hpaste.org/67531
05:01:56 <seven_sir> Anything else？
05:02:15 <unknownwarrior> tower.hs:6:39:     No instance for (Num String)       arising from the literal `100'     Possible fix: add an instance declaration for (Num String)     In the first argument of `(/)', namely `100'     In the second argument of `(+)', namely `(100 / n)'     In the second argument of `tower', namely `(hoehe + (100 / n))'  tower.hs:6:42:     No instance for (Fractional String)       arising from a use of `/'     Possible fix: a
05:02:25 <bitonic> @where hpaste
05:02:25 <lambdabot> http://hpaste.org/
05:02:28 <bitonic> unknownwarrior: use hpaste
05:02:32 <donri> seven_sir: it's for discussing a computer programming language called haskell
05:02:40 <merijn> unknownwarrior: Can you write down what you think the type of tower is?
05:02:54 <seven_sir> sorry
05:02:54 <donri> seven_sir: if you don't know what that is, you might have come to the wrong place by accident (it happens!)
05:02:56 <hpaste_> unknownwarrior annotated “tower” with “tower (annotation)” at http://hpaste.org/67531#a67532
05:03:21 <merijn> unknownwarrior: Because I'm very sure that the type of tower is not the type you think it is
05:03:38 <byorgey> or else the type of putStrLn is not the type that unknownwarrior thinks it is
05:03:47 <merijn> byorgey: Also possible
05:03:53 <byorgey> tower does not have a type.
05:04:19 <unknownwarrior> in the end the type of tower is only IO, because its an endless loop
05:04:30 <merijn> unknownwarrior: What are the input types?
05:04:45 <unknownwarrior> integers first but later float
05:05:00 <merijn> And what is the input of putStrLn?
05:05:29 <unknownwarrior> a number .. but even if i write: putstrln (read height)
05:05:32 <unknownwarrior> there is an error
05:05:41 <merijn> :t putStrLn
05:05:41 <lambdabot> String -> IO ()
05:05:56 <fmap> :t read
05:05:56 <lambdabot> forall a. (Read a) => String -> a
05:06:00 <merijn> putStrLn takes a String, thus the type inferrer says "height" must be a string
05:06:14 <unknownwarrior> oh!
05:06:23 <merijn> The errors are saying that Strings are not numbers
05:06:23 <geekosaur> read is the opposite of what you want there
05:06:35 <merijn> Because you're trying to add/multiply
05:06:45 <unknownwarrior> okey what i want is ...
05:06:49 <merijn> :t show
05:06:50 <lambdabot> forall a. (Show a) => a -> String
05:06:53 <merijn> or
05:06:55 <merijn> :t print
05:06:55 <lambdabot> forall a. (Show a) => a -> IO ()
05:07:05 <merijn> print == putStrLn . show
05:07:27 <fmap> @src print
05:07:28 <lambdabot> print x = putStrLn (show x)
05:07:30 <unknownwarrior> oh thats nice, show compiles ;)
05:07:44 <t7> someone should make a plugin for ghc that uses djinn to try to solve any binding type declarations that dont have bodies
05:08:05 <t7> :)
05:08:15 <merijn> unknownwarrior: It helps to always write out the top level type signature for functions like type. That way the compiler will say the types don't match rather than the more cryptic "instance not found" errors
05:08:52 <danr> t7: yeah, I hate when it happens that I remember the S combinators type, but not its definition
05:09:00 <unknownwarrior> okey but what really works in this case is: print. show does nothing ..
05:09:07 * hackagebot repa 3.1.3.2 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.3.2 (BenLippmeier)
05:09:45 <merijn> unknownwarrior: show converts to a string but doesn't print. putStrLn prints, but only works for strings
05:11:45 <donri> @src print
05:11:45 <lambdabot> print x = putStrLn (show x)
05:13:30 <hpaste_> merijn annotated “tower” with “either” at http://hpaste.org/67531#a67534
05:13:38 <merijn> Or some variation along those lines
05:15:09 <unknownwarrior> merijn: okey thank you, i will keep that function signature thing in mind. :)
05:15:47 <merijn> I have this pattern (http://hpaste.org/67530) repeating a lot of times with only the inner body differing. Anyone that can help me think of a way to abstract the pattern away without having to pass a billion extra variables around?
05:16:04 <merijn> (The inner body being the \field lambda)
05:16:41 <quicksilver> by "a million" variables, you mean "output" and "info" ?
05:17:05 <quicksilver> for values of a million approaching two.
05:17:12 <merijn> Close enough :)
05:17:52 <ppseafield> Is there a way in case expressions to catch multiple patterns for one body? e.g. case x of { Just 5 | Just 7 -> ...; Nothing -> ...; }
05:17:58 <merijn> Actually there's 1 or 2 more that I left out, I think. But my last attempt wound up with two extra functions both having to pass those variables around
05:18:00 <quicksilver> I think you need to show me two examples before I can abstract.
05:18:21 <quicksilver> but possibly, you can define "get" and "write" such that you can just have
05:18:30 <mauke> ppseafield: no
05:18:40 <quicksilver> (\field -> f <- get; write f)
05:19:02 <ppseafield> mauke: Ok, thanks.
05:19:18 <quicksilver> (\field -> f <- get field ; write f) rather
05:19:33 <quicksilver> which in turn you can write as (\field -> get field >>= write)
05:20:35 <mauke> >=>
05:21:32 <quicksilver> and that too, yes
05:22:07 <quicksilver> merijn: so I'm pretty sure that the answer is yes, but you're going to need to supply more concrete info if you want an actual example.
05:23:39 <mm_freak> i learned that in a logically consistent language i can't have inductive families with only type indices, but i also need type parameters
05:23:49 <mm_freak> i.e. this is impossible:  data Vec : Set -> Nat -> Set
05:24:00 <mm_freak> but what if i allow Set : Set?
05:24:07 * hackagebot regex-pderiv 0.1.1 - Replaces/Enhances Text.Regex  http://hackage.haskell.org/package/regex-pderiv-0.1.1 (KennyLu)
05:24:27 <bitonic> mm_freak: paradoxes ensue
05:24:35 <mm_freak> bitonic: disregarding them
05:24:50 <mm_freak> my question is whether /technically/ i would get along with only type indices
05:24:50 <bitonic> well then you can flatten all your types in one type I guess.
05:25:05 <mm_freak> i mean, would i lose expressiveness?
05:25:10 <bitonic> what does /technically/ mean?
05:25:50 <mm_freak> i'm implementing a dependently typed core language, which i'm developing with logic in mind (i.e. Set /: Set)
05:26:17 <mm_freak> in such a language i definitely need type parameters, if only to be logically consistent
05:26:34 <mm_freak> but if logical consistency wouldn't be a concern, would i get along with only indices?
05:27:03 <bitonic> well yes
05:27:10 <bitonic> it depends what you mean with "get along" really
05:27:12 <bitonic> you can prove bottom
05:27:28 <mm_freak> don't think in theorem proving…  think in programming
05:27:30 <bitonic> but I don't see why you can't program in it
05:28:05 <mm_freak> i don't think that language can be used for theorem proving anyway, because i will at some point add general recursion
05:28:10 <bitonic> I mean the first publication of TT itself had just one universe
05:28:41 <bitonic> mm_freak: why do you need that anyways? the classic solution to that is to have a hierarchy of universes
05:28:57 <mm_freak> bitonic: i'm curious
05:28:59 <bitonic> which works well as far as I can see
05:29:07 <bitonic> mm_freak: I
05:29:09 <bitonic> oops.
05:29:23 <bitonic> @where TTFP
05:29:23 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
05:29:31 <mm_freak> read that one
05:29:33 <bitonic> mm_freak: ^^^ check the section about universes
05:29:38 <mm_freak> my question isn't really covered there
05:29:53 <mm_freak> and you might have misunderstood it
05:30:13 <bitonic> oh, maybe. I read it as 'what happen if I allow Set : Set'
05:30:26 <mm_freak> try to understand inductive families as a feature of a programming language…  a generalization of GADTs
05:30:41 <bitonic> mm_freak: I know what they are, I use them in agda
05:30:44 <mm_freak> in a consistent language there must be a clear distinction between type parameters and type indices
05:31:12 <mm_freak> now if i /were/ to allow Set : Set, would i still need that distinction to retain their full power?
05:31:32 <bitonic> ah, I see.
05:32:05 <bitonic> well I'm not sure I see how the two things are related. btw, #agda might be a better channel for this :P
05:32:20 <mm_freak> true
05:32:41 <mm_freak> well, i found that in agda, when i enable Set : Set, i can get along only with indices for all the examples i tried out
05:33:26 <bitonic> mm_freak: oh so you're using indices only. I was thinking it the other way
05:33:54 <mm_freak> well, in my implementation i thought that i might get along with this:  WithType :: Name -> Type -> Expr -> Expr
05:34:10 <mm_freak> bringing the type given by the name into scope for the given expression, and the type has the given type
05:34:18 <Philippa> FWIW: so long as nobody wants to talk something more on-topic, go for it here?
05:34:40 <mm_freak> well, as i'm implementing it in haskell, i feel it's somewhat on-topic =)
05:34:46 <mm_freak> this is really about implementation, less about theory
05:35:01 <bitonic> Philippa: usually type-related stuff is kinda accepted here :P
05:35:10 <quicksilver> I've always taken that view, Philippa, especially when the topic is in the wider arena of functional programming or type sytesm
05:35:33 <mm_freak> well, i'm not talking about PHP, am i? =P
05:35:37 <quicksilver> and if other people are being impeded in their search for haskell answers, sent the type implementors off to -overflow or something.
05:36:28 <mm_freak> although it sounds intriguing to compile a dependently typed language to PHP, so that you can get your everyday work done in a sane language
05:36:52 * bitonic goes for lunch
05:36:57 <Philippa> bitonic: sorry, should I repeat that with my op hat on? :-)
05:37:12 <bitonic> mm_freak: I'll think about that while eating :P
05:37:22 <mm_freak> go ahead =)
05:37:22 <Philippa> quicksilver: yeah
05:37:35 <bitonic> Philippa: I misunderstood what you were saying sorry :P
05:38:06 * Botje sticks some gold stars on Philippa's op hat
05:38:24 <Botje> because EVERYTHING is better with gold stars.
05:44:07 * hackagebot gloss 1.7.4.1 - Painless 2D vector graphics, animations and simulations.  http://hackage.haskell.org/package/gloss-1.7.4.1 (BenLippmeier)
05:44:09 * hackagebot gloss-raster 1.7.4.1 - Parallel rendering of raster images.  http://hackage.haskell.org/package/gloss-raster-1.7.4.1 (BenLippmeier)
05:44:11 * hackagebot gloss-examples 1.7.4.1 - Examples using the gloss library  http://hackage.haskell.org/package/gloss-examples-1.7.4.1 (BenLippmeier)
05:46:37 <danr> Philippa: I did not get what you meant. Did you mean that people should go for talking about less on-topic things when nobody else does? Or were you saying the opposite of that?
05:54:08 * hackagebot clientsession 0.7.5 - Securely store session data in a client-side cookie.  http://hackage.haskell.org/package/clientsession-0.7.5 (FelipeLessa)
05:54:30 <hpc> danr: yes
05:56:11 <danr> hpc: there's something ironic in answering yes when there were two alternatives
05:59:23 <burbul> @pl solutions reqs = runWriterT . solutions' reqs
05:59:24 <lambdabot> solutions = (runWriterT .) . solutions'
06:00:07 <hpc> :t \reqs -> runWriterT . ?f reqs
06:00:08 <lambdabot> forall w (m :: * -> *) a t (f :: * -> *). (?f::t -> f (WriterT w m a), Functor f) => t -> f (m (a, w))
06:00:17 <hpc> :t \reqs -> runWriterT Prelude.. ?f reqs
06:00:18 <lambdabot> forall w (m :: * -> *) a t a1. (?f::t -> a1 -> WriterT w m a) => t -> a1 -> m (a, w)
06:01:03 <burbul> (the runWriterT isn't really important ...   I was just seeing if there was a nicer way to write
06:01:13 <burbul> f x = h . (g x)
06:01:28 <hpc> > h . (g x) $ y :: Expr
06:01:29 <lambdabot>   Ambiguous type variable `a' in the constraints:
06:01:29 <lambdabot>    `SimpleReflect.FromExpr ...
06:01:40 <hpc> > h Prelude.. (g x) $ y :: Expr
06:01:41 <lambdabot>   Not in scope: `Prelude..'
06:02:20 <hpc> burbul: (.:) = fmap . fmap
06:02:28 <hpc> solutions = runWriterT .: solutions'
06:02:53 <hpc> it's general for all functors, but for (->) it's basically "compose over two arguments)
06:03:05 <hpc> there's a quote in there somewhere
06:03:47 <hpc> :t runWriterT .: ?f
06:03:48 <lambdabot> forall w (m :: * -> *) a (f :: * -> *) (g :: * -> *). (?f::f (g (WriterT w m a)), Functor f, Functor g) => f (g (m (a, w)))
06:05:49 <burbul> thanks!
06:06:52 <burbul> by the way, what does the '?' in '?f' mean?
06:07:19 <quicksilver> implicit parameter
06:07:44 <quicksilver> an experimental GHC extension widely considered to be bad for real programming
06:07:50 <quicksilver> but handy for type checking tricks :)
06:07:53 <burbul>  ok -- thanks
06:08:35 * Eduard_Munteanu would like something like Agda's implicits, dunno how much overlap there is, haven't used the Haskell stuff too much
06:10:49 <hpc> Eduard_Munteanu: i am not sure what utility implicits would have in haskell
06:10:51 <Baikonur> never seen more ugly and horrible piece of haskell that the line i just wrote
06:11:09 <Botje> Baikonur: Challenge accepted! :)
06:11:38 <hpc> in agda, implicits hint that the thing should be inferred, but haskell already has "implicit implicits", so to speak
06:11:44 <hpc> just because of how type inference works
06:12:00 <Baikonur> it retrieves stuff from a binary search tree, but only if the stuff in said tree is digits as chars
06:12:59 <hpc> > let let'in = let let' = otherwise in let' in let in' otherwise = if not otherwise then otherwise else let' in in' let'
06:12:59 <lambdabot>   Not in scope: `let''Not in scope: `let''
06:13:37 <hpc> > let let' = otherwise in let'in = let let' in let in' otherwise = if not otherwise then otherwise else let' in in' let'
06:13:38 <lambdabot>   <no location info>: parse error on input `='
06:13:41 <hpc> pah
06:13:52 <hpc> i could make it work but it's too early in the morning
06:14:24 <hpc> > let let'in = let let' = otherwise in let' in let in' otherwise = if not otherwise then otherwise else let' in in' let'in
06:14:25 <lambdabot>   Not in scope: `let''
06:14:32 <bitonic> Eduard_Munteanu: implicits work well for types more than for values
06:14:35 <hpc> > let let'in = let let' = otherwise in let' in let in' otherwise = if not otherwise then otherwise else let'in in in' let'in
06:14:35 <bitonic> in agda anyways
06:14:36 <lambdabot>   True
06:14:38 <hpc> yes!
06:14:38 <bitonic> and in my experience :P
06:14:39 <Baikonur> and it does so by looking up the largest digit in the tree, and then testing every digit from '0' to the largest digit, for whether or not it is in the tree
06:15:40 <Eduard_Munteanu> Yeah, maybe there isn't much use in Haskell, looking at how we deal with quantification.
06:17:09 <burbul> I know this will be obvious to all of you, but I've only just figured out why monad transformers appear in types in the opposite order to what you'd expect... and AFAIK it's not in any tutorials (probably because it doesn't occur to anyone that newbies would find it confusing)
06:17:40 <burbul> I was always puzzled by the fact that if you want a writer 'inside' some nondeterminism you write
06:18:00 <burbul> WriterT _ []
06:18:04 <burbul> Rather than
06:18:18 <burbul> ListT Writer
06:19:34 <burbul> But I think I can now make sense of it as a last-in first-out thing... you need to run the WriterT before the ListT, so you need the WriterT at the top of your stack.
06:20:55 <hpc> burbul: you would write LogicT Writer, i think
06:21:17 <burbul> I don't know what LogicT is... let me just look it up
06:21:22 <hpc> unless i am misunderstanding 'inside'
06:21:27 <burbul> (I have everything working with WriterT _ [].)
06:21:28 <hpc> LogicT is the unbroken ListT
06:21:44 <hpc> so it remains a monad even if you transform over a non-commutative monad
06:21:51 <burbul> ah
06:21:56 <hpc> (it's just a bugfix by a complicated name, essentially)
06:22:03 <quicksilver> burbul: in general "FooT Bar" will look, as a type, something like "Bar (Foo a)"
06:22:20 <quicksilver> burbul: for example, MaybeT IO is "IO (Maybe a)"
06:22:27 <burbul> quicksilver: yes, I know, but that confused me greatly when I was reading tutorials
06:22:42 <hpc> ListT Writer will give you a single log
06:22:43 <quicksilver> so the order in the transformer expansion is the opposite to the order in the nested type
06:22:54 <hpc> WriterT _ [] will give you non-deterministic logs
06:22:55 <burbul> I knew it was the case but I didn't understand *why* the order had to be reversed
06:23:06 <burbul> It seemed very counterintuitive
06:23:25 <burbul> and vaguely non-compositional
06:23:58 <quicksilver> well monad transformers exist because monads are non-compositional
06:24:26 <quicksilver> and thought is required to work out how to recover some compositionality
06:24:59 <burbul> Intuitively it feels like if you take, say, ListT (or LogicT) and apply it to an argument T, you should be adding some nondeterminism that outscopes everything in T
06:25:08 <burbul> -- sorry, T was a bad choice of letter
06:26:53 <quicksilver> I know what you mean.
06:26:59 <quicksilver> I'm not sure my intuition was that strong though.
06:27:07 <quicksilver> you just have to learn what it means :)
06:27:16 <navaati> hi
06:27:24 <burbul> well, the LIFO thing perspective really helped me!
06:27:35 <hpc> it might also help to think
06:27:45 <hpc> in (ListT M), M is being transformed
06:27:48 <hpc> not []
06:28:05 <hpc> you're applying [] to the "inside" of M
06:28:07 <hpc> so to speak
06:28:38 <hpc> or maybe i am making it more confusing
06:29:33 <burbul> At the moment I can't  assimilate but probably once I've had time to think on it it will help -- thanks for the perspective.
06:29:49 <burbul> *assimilate it
06:29:55 <hpc> ass-laminate
06:30:05 <womb> > 7*7
06:30:06 <lambdabot>   49
06:33:09 <Philippa> a useful mnemonic: there's no IOT because you can't actually modify the World like that
06:33:26 <Philippa> (so the bottom of the stack has precedence)
06:37:10 <navaati> Philippa: ah, great tip !
06:38:06 <Philippa> (I keep telling people the world-passing interpretation has its uses...)
06:39:03 <ClaudiusMaximus> is there a package with extra functions like   aZipWith :: (Ix i, IArray aa a, IArray ab b, IArray ac c) => (a -> b -> c) -> aa i a -> ab i b -> Maybe (ac i c) -- returns Nothing when the intersection of the bounds is empty
06:39:56 <ClaudiusMaximus> currently i have a rudimentary implementation that returns Nothing when the bounds aren't identical
06:41:06 <ClaudiusMaximus> (actually, would it require an IxPlus class to provide intersections?)
06:42:06 <ClaudiusMaximus> i do also need aZipWith6, and chances are that any such package would only go up to 5
06:43:49 <ClaudiusMaximus> mm, seems there is nothing, going by Hayoo
06:44:57 <armand0> всем привет!
06:47:53 <armand0> есть кто из России?
06:48:05 <Eduard_Munteanu> armand0: English please.
06:48:30 <oddraisent> armand0: по-английски, пожалуйста
06:49:18 <armand0> my English is very bad. I'm from Russia
06:49:33 <mauke> my russian is non-existent
06:50:20 <armand0> =)
06:51:34 <Elemir> Also there is no russian channel about haskell at freenode. Russkie migrated to jabber
06:52:20 <armand0> can you help me? i need some simple examples about using Haskell
06:53:16 <albel727> а может быть ты будешь делать свою домашнюю работу самостоятельно? или заюзаешь google?
06:53:23 <mauke> > 2 + 2
06:53:23 <lambdabot>   4
06:53:30 <mauke> > [1 ..]
06:53:30 <lambdabot>   [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28...
06:53:57 <Ptival> I understood the last word \o/
06:54:10 <albel727> yeah, russian is THAT simple.
06:54:14 <albel727> =)
06:55:28 <armand0> albel727 у нас не преподают ФП, я даже до сегодняшнего дня не слышал об этом
06:55:32 <burbul> @pl  do { pforms <- lift pformsL; tell [pforms]; lift $ cancel_pforms reqs pforms}
06:55:32 <lambdabot> (line 1, column 4):
06:55:32 <lambdabot> unexpected "{"
06:55:33 <lambdabot> expecting variable, "(", operator or end of input
06:55:44 <albel727> armand0: ну и зачем тебе тогда хаскел?
06:56:14 <armand0> albel727 интересно стало
06:56:20 <burbul> @pl  cancel_and_tell' reqs pformsL = do { pforms <- lift pformsL; tell [pforms]; lift $ cancel_pforms reqs pforms}
06:56:20 <lambdabot> (line 1, column 36):
06:56:20 <lambdabot> unexpected "{"
06:56:20 <lambdabot> expecting variable, "(", operator or end of input
06:56:25 <mauke> burbul: you need to @undo first
06:56:35 <burbul> thanks
06:56:46 <burbul> @undo do { pforms <- lift pformsL; tell [pforms]; lift $ cancel_pforms reqs pforms}
06:56:46 <lambdabot> lift pformsL >>= \ pforms -> tell [pforms] >> lift $ cancel_pforms reqs pforms
06:56:56 <Elemir> armand0: Do you have a jabber account?
06:56:59 <mauke> hah, I understand хаскел!
06:57:07 <burbul> @pl cancel_and_tell' reqs pformsL = lift pformsL >>= \ pforms -> tell [pforms] >> lift $ cancel_pforms reqs pforms
06:57:07 <lambdabot> cancel_and_tell' = flip ((>>=) . lift) . ap ((>> lift) . tell . return) . cancel_pforms
06:57:20 <burbul> Now that really makes my head hurt.
06:57:24 <armand0> albel727 в rsdn статью прочитал и ошалел
06:57:25 <navaati> UTF8 fuck yea.
06:57:36 <armand0> Elemir no
06:58:10 <albel727> armand0: ну если с английским у тебя плохо, то это проблема. туториалов про него мало.
06:58:15 <burbul> Is there any command other than @pl for simplifying things? (I know that's not quite what @pl does, but it often helps me.)
06:58:22 <albel727> (на русском)
06:58:32 <quicksilver> burbul: well, using 'pforms' twice gives you an (ap) on (>>)
06:58:35 <Elemir> Sad, haskell@conference.jabber.ru nice for haskell-starter
06:58:37 <armand0> albel727 я уж так и понял...
06:58:48 <quicksilver> burbul: tell.return is tell [ ]
06:59:19 <quicksilver> burbul: and the flip is just getting args in the right place.
06:59:33 <burbul> Now you've said that I can sort of see where the bits come from...
06:59:39 <burbul> but I was looking for something much more basic!
06:59:46 <quicksilver> @pl \x -> foo x >> bar x
06:59:46 <lambdabot> liftM2 (>>) foo bar
06:59:56 <armand0> albel727 в принципе основы я уже вроде бы понял, но вот про применение почитал бы... кстати читаю я по английски лучше чем пишу =)
06:59:59 <quicksilver> hmm that was supposed to be a simple example of the ap cause but it went further :)
07:00:01 <burbul> I'm pretty new to this (especially monads) so often I write something that is more complicated than it needs to be
07:00:15 <quicksilver> liftM2 is very closely related to ap anyhow
07:00:41 <burbul> e.g I just had     do { ... ; reqs <- lift $ cancel_pforms reqs pforms; return reqs }
07:00:41 <mauke> http://mauke.hopto.org/tmp/flow.png :-D
07:00:42 <albel727> armand0: а что тебе непонятно с применением? он так же, как любой другой язык применяется. берёшь и пишешь =)
07:01:06 <armand0> albel727 ваще плёвое дело как я понимаю =)
07:01:18 <quicksilver> burbul: well there is hlint
07:01:22 <quicksilver> it's not much like @pl
07:01:27 <armand0> albel727 а вы откуда будете?
07:01:29 <quicksilver> but it does suggest simplifications sometimes
07:01:40 <burbul> mauke: nice!
07:01:47 <nus> armand0, http://progbook.ru/haskell/
07:01:54 <armand0> albel727 может есть другие способы связи с вами?
07:01:55 <quicksilver> armand0, albel727 : I'm all in favour of being helpful but this is an english language channel.
07:02:06 <nus> and /join #haskell-ru or something
07:02:22 <burbul> quicksilver: yup, I have hlint set up + it's often very useful
07:02:26 <mauke> which probably doesn't exist
07:02:32 <armand0> nus thanks!
07:02:50 <quicksilver> mauke: still, if  three people join it  on nus's suggestion it has a purpose
07:02:55 <quicksilver> even if only a short-term one
07:03:03 <quicksilver> channels don't need a long-term identityto be useful
07:04:13 <armand0> удачи вам всем, буду пробовать разбираться самостоятельно =)
07:05:03 <mauke> FWIW, I have nothing against this russian conversation
07:05:17 <nus> armand0, http://chatlogs.jabber.ru/haskell@conference.jabber.ru/
07:05:18 <mauke> if anything it's easier to separate from the rest of the channel
07:05:39 * albel727 is glad to hear that.
07:06:23 <armand0> nus it's really cool =)))
07:09:10 * hackagebot IntervalMap 0.2.3.3 - Maps from Intervals to values, with efficient search.  http://hackage.haskell.org/package/IntervalMap-0.2.3.3 (ChristophBreitkopf)
07:09:11 <ktosiek> can I install new GHC with Cabal?
07:09:34 <ktosiek> something as easy as cabal install ghc would be if it worked?
07:09:45 <byorgey> ktosiek: no, you can't
07:10:05 <navaati> ktosiek: cabal builds things. GHC is f*cking heavy to build. do you really want that ?
07:10:44 <mauke> sometimes, yes
07:10:46 <ktosiek> not really, I just want ghc > 7.0
07:10:47 <byorgey> navaati: of course ktosiek really wants that.  Wouldn't you?  It would be great if installing new things was that easy.
07:11:21 <byorgey> ktosiek: what OS are you using?
07:11:31 <navaati> i said that because of the word "install". cabal does not just "install"
07:11:33 <ktosiek> Linux Mint Katya
07:12:04 <ktosiek> it's based on ubuntu natty
07:12:30 <byorgey> navaati: ah, ok, point taken
07:12:31 <navaati> (dreads, natty dreads)
07:12:44 <navaati> isn't there a PPA with a recent version of GHC ?
07:12:47 <byorgey> ktosiek: does it have a haskell-platform package?
07:12:50 <ktosiek> yes
07:12:52 <byorgey> or is it really old?
07:13:28 <ktosiek> with base 3.0.3.2
07:13:52 <ktosiek> GHC 6.12.3
07:13:52 <byorgey> oh, I see, yes, it is old
07:14:36 <byorgey> ktosiek: well, your best bet in that case is to first go to http://www.haskell.org/ghc/download_ghc_7_4_1, ignore the warning labeled "Stop!", and download a binary package
07:18:01 <ktosiek> https://launchpad.net/~gspreemann/+archive/haskell?field.series_filter=natty ← GHC 7.0.3 for natty :-D
07:19:56 <byorgey> ktosiek: sure, that works too =)
07:21:10 <womb> > 7*7
07:21:10 <lambdabot>   49
07:24:17 <burbul> I've just solved the subproblem I'm working on, and the code is working correctly, but I feel like I may be misusing WriterT.
07:24:23 <burbul> It's not that important, but if anyone is not too busy, could you have a look at http://hpaste.org/67537 ?
07:25:05 <burbul> (Misusing WriterT in the sense that there is a cleaner solution.)
07:25:12 <navaati> use camelCase :p
07:25:35 <burbul> I'm using dictation software (RSI) -- it's a lot easier to dictate underscores than camelcase.
07:26:24 <burbul> Though maybe someday I'll write a script to convert everything to camelcase.
07:26:53 <navaati> don't worry, it's just that hlint made me smile
07:26:57 <burbul> ah
07:28:53 <navaati> well, i don't really understand all of the code but couldn't you use ListT instead of WriterT ?
07:29:16 <byorgey> burbul: looks fine to me
07:29:45 <burbul> navaati: do you mean by calling sequence on the [[PForms]], or something like that?
07:29:49 <burbul> byorgey: thanks!!
07:30:06 <byorgey> burbul: and don't worry about under_scores vs camelCase =)
07:34:14 * hackagebot tamarin-prover-utils 0.4.0.0 - Utility library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-utils-0.4.0.0 (SimonMeier)
07:34:16 * hackagebot tamarin-prover-term 0.4.0.0 - Term manipulation library for the tamarin prover.  http://hackage.haskell.org/package/tamarin-prover-term-0.4.0.0 (SimonMeier)
07:34:18 * hackagebot tamarin-prover 0.4.0.0 - The Tamarin prover for security protocol analysis.  http://hackage.haskell.org/package/tamarin-prover-0.4.0.0 (SimonMeier)
07:34:20 * hackagebot yesod-test 0.2.0.2 - integration testing for WAI/Yesod Applications  http://hackage.haskell.org/package/yesod-test-0.2.0.2 (MichaelSnoyman)
07:38:38 <navaati> wow http://hackage.haskell.org/trac/ghc/wiki/TypeNats/Basics is this going to be in ghc 7.6 ?
07:43:08 <bitonic> navaati: I think so, it's already in HEAD iirc
07:43:50 <navaati> sounds great
07:44:10 <bitonic> yeah, but prepare for a lens-like situation but with record libraries :P
07:44:16 <bitonic> lens-like or worse
07:44:41 <navaati> by lens-like you mean a whole bunch of thousands of very similar libs ?
07:45:29 <bitonic> navaati: yes
07:45:33 <navaati> there is an obvious solution to that : include one into base even before 7.6 is released
07:45:47 <bitonic> navaati: that is silly, you can't really predict what people will like
07:46:05 <bitonic> also, using such an experimental feature in base doesn't sound like a good idea
07:46:41 <Entroacceptor> just make sure there's a good documented overview and let evolution work
07:46:53 <navaati> for the first point, i know, i know… for the 2nd, well, at a time fundeps were experimentals, though monad classes are in base, aren't they ?
07:47:42 <navaati> btw, do lens use an experimental type feature ?
07:48:15 <hpc> navaati: i am sure some implementations do
07:48:22 <hpc> you can get lenses without, though
07:55:30 <lpsmith> uniquenick,
07:55:34 <lpsmith> :t (<$>
07:55:35 <lambdabot> parse error (possibly incorrect indentation)
07:55:35 <lpsmith> :t (<$>)
07:55:36 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
07:55:39 <womb> :t map
07:55:40 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:57:13 <hpaste_> stefanooldeman pasted “can't resolve this error ” at http://hpaste.org/67538
07:57:31 <lpsmith> :t (<$>) :: (a -> b) -> IO a -> IO b
07:57:32 <lambdabot> forall a b. (a -> b) -> IO a -> IO b
07:57:43 <lpsmith> uniquenick, ^
07:57:53 <hpaste_> stefanooldeman annotated “can't resolve this error ” with “can't resolve this error  (annotation)” at http://hpaste.org/67538#a67539
07:59:14 * hackagebot HsOpenSSL 0.10.3.1 - (Incomplete) OpenSSL binding for Haskell  http://hackage.haskell.org/package/HsOpenSSL-0.10.3.1 (MasatakeDaimon)
08:06:19 <hpaste_> merijn annotated “redundant code” with “more examples” at http://hpaste.org/67530#a67541
08:06:49 <merijn> quicksilver: Sorry, my supervisor dragged me away for a meeting, I pasted a couple more examples I had of the pattern I have
08:18:48 <Alan> :t liftM concat
08:18:49 <lambdabot> forall a (m :: * -> *). (Monad m) => m [[a]] -> m [a]
08:19:40 <Alan> that feels like something that should exist... is it?
08:20:07 <Axman6> yes, you just defined it
08:20:07 <int-e> liftM concat  is perfectly fine.
08:20:17 <Alan> ok, i was wondering if i was being redundant
08:20:21 <navaati> @hoogle m [[a]] -> m [a]
08:20:21 <lambdabot> Prelude concat :: [[a]] -> [a]
08:20:21 <lambdabot> Data.List concat :: [[a]] -> [a]
08:20:22 <lambdabot> Data.List transpose :: [[a]] -> [[a]]
08:20:41 <hpc> > concat <$> [["abc", "def"], ["argle", "blargle"]]
08:20:42 <lambdabot>   ["abcdef","argleblargle"]
08:20:44 <Alan> yeah, i did just check hoogle for the type signature afterwards
08:20:45 <Axman6> why would we have something that exists like that that's soo a) easy to construct from more general pieces, and b) so constrained?
08:20:51 <merijn> :t mconcat
08:20:52 <Axman6> :t liftM join
08:20:52 <lambdabot> forall a. (Monoid a) => [a] -> a
08:20:52 <lambdabot> forall (m :: * -> *) a (m1 :: * -> *). (Monad m, Monad m1) => m1 (m (m a)) -> m1 (m a)
08:21:17 <Alan> Axman6: well, true
08:21:22 <int-e> or fmap concat, as some would have it. (fmap is also known as (<$>) (defined in Control.Applicatvie), so you can write  concat <$> ...)
08:21:41 <int-e> caveat, fmap does not work for all monads (although it should)
08:21:41 <typoclass> Axman6: well, things like concatMap exist ...
08:21:53 <hpc> typoclass: you mean (>>=)? ;)
08:22:13 <Axman6> typoclass: several specialised functions exist in the prelude because they have good educational value
08:22:22 * hpc still says concat/concatMap should just be their monad alternatives
08:22:28 <salisbury> I'm getting a new haskell setup going. Which version of GHC is recommended?
08:22:49 <navaati> salisbury: the last, if you can get it, i guess
08:22:55 <fmap> int-e: <$> is defined in Data.Functor
08:23:08 <salisbury> 7.4? I  noticed a lot of libraries don't build under 7.4
08:23:09 <t7> can dependent types be implemented without polymorphism or type constructors?
08:23:12 <Alan> :t fmap
08:23:12 <int-e> meh things keep moving around.
08:23:13 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:23:13 <hpc> salisbury: 7.4.1 is the latest stable version; if you're on debian or whatever, the version in apt will be older but should work fine
08:23:35 <Alan> i see
08:23:40 <hpc> t7: ive noticed the opposite; a lot of libs build under 7.4.1 and 6.12.1, but not 7.0.4
08:23:51 <t7> :|
08:23:59 <merijn> salisbury: 7.2 I think is stable?
08:24:17 <salisbury> hpc: I was looking at cuda for example, and a few image libs
08:24:18 <hpc> merijn: 7.4, dunno what .2 is
08:24:19 <merijn> salisbury: To be honest you should just grab Haskell Platform and use whatever comes with that
08:24:21 <rwbarton> I thought 7.0.4 was the most recent stable version
08:24:30 <merijn> @where platform
08:24:30 <lambdabot> http://hackage.haskell.org/platform/
08:24:31 <salisbury> platform is 7.0.4
08:24:39 <Eduard_Munteanu> @seen edwardk
08:24:40 <lambdabot> Unknown command, try @list
08:24:41 <hpc> http://www.haskell.org/ghc/download_ghc_7_4_1
08:24:47 <Eduard_Munteanu> preflex: seen edwardk
08:24:48 <preflex>  edwardk was last seen on #haskell 16 hours, 45 minutes and 53 seconds ago, saying: gotta run
08:24:59 <hpc> er
08:25:00 <hpc> http://www.haskell.org/ghc/download
08:25:09 <merijn> salisbury: Platform is the semi-official "stable" version (as in, all major libraries work with it)
08:25:14 <int-e> fmap: hmm, been there for quite some time. thanks. (that said, I'll continue to include Control.Applicative for that operator)
08:25:34 <int-e> (because I usually want the rest of that module, too.)
08:25:36 <merijn> salisbury: The next release of platform will probably move to 7.4, but unless you really need the most advanced features (unlikely if you're just starting) it is fine
08:25:54 <Alan> is there any advantage/disadvantage to using liftM instead of fmap? i'm assuming that fmap is the more general solution
08:25:56 <Eduard_Munteanu> Does anyone care to guess whether it's possible to get an adjunction from a monad in Haskell (say, via the Kleisli construction)?
08:25:58 <hpc> @quote Control.Applicative
08:25:58 <lambdabot> EvilTerran says: if three of those lines aren't import Control.Monad; import Control.Arrow; import Control.Applicative;, you can make it shorter ;]
08:26:06 <burbul> @pf tidy l@((a,_):_) = (a, map snd l)
08:26:06 <lambdabot> Maybe you meant: bf pl
08:26:07 <salisbury> merijn: not just starting, however I don't do much advanced language stuff
08:26:13 <copumpkin> Eduard_Munteanu: automatically?
08:26:45 <merijn> Alan: Well, liftM is more restricted, yes. In general there shouldn't be much difference
08:26:46 <copumpkin> Eduard_Munteanu: did you see the parametricity stuff in agda, by the way?
08:26:46 <Eduard_Munteanu> copumpkin: well, yeah. Like I can already get a monad from an adjunction
08:26:53 <salisbury> merijn: it should be good if I use platform, these things are just so difficult to uninstall completel
08:26:54 <merijn> Alan: (<$>) can be nice to use in some situations
08:27:05 <copumpkin> Eduard_Munteanu: no, I don't think there's any automatic procedure for "uncomposing" the functors
08:27:05 <merijn> :t (<$>)
08:27:06 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:27:14 <hpc> burbul: tidy = (fst . head) &&& (map snd)
08:27:19 <hpc> :t (fst . head) &&& (map snd)
08:27:20 <lambdabot> forall a b. [(a, b)] -> (a, [b])
08:27:31 <Eduard_Munteanu> copumpkin: yep. I'm not sure how much that actually represents parametricity. Do the free theorems get you parametricity? I thought it was the other way around.
08:27:53 <hpc> burbul: passing an empty list is an error at runtime though
08:27:58 <rwbarton> the Kleisli construction is one way to get an adjunction
08:28:06 <Alan> merijn: so <$> is a combination of fmap and $?
08:28:13 <hpc> @src (<$>)
08:28:13 <lambdabot> f <$> a = fmap f a
08:28:15 <copumpkin> Eduard_Munteanu: parametricity implies dinaturality, supposedly, so it gets you some of it at least
08:28:27 <Alan> i see
08:28:27 <burbul> hpc: it was safe in the context I was using it...
08:28:30 <Eduard_Munteanu> Yeah, or the Eilenberg-Moore one, I'm not sure how or if that can be expressed in Haskell.
08:28:30 <hpc> (<$>) = fmap
08:28:31 <merijn> Alan: It's just infix fmap
08:28:32 <burbul> collateByFst = map tidy . groupBy ((==) `on` fst) . sortBy (comparing fst)
08:28:50 <rwbarton> yeah, me neither
08:28:59 <merijn> > let foo = (+1) in foo <$> [1..10]
08:29:00 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:29:14 * Eduard_Munteanu hasn't even seen EM in Haskell, but he came up with a formulation... newtype EM m a b = EM ((a, m a -> a) -> (b, m b -> b))   (I hope it's right)
08:29:20 <hpc> > let foo = (+1) in foo `fmap` [1..10]
08:29:21 <lambdabot>   [2,3,4,5,6,7,8,9,10,11]
08:29:31 <Alan> merijn: :D
08:29:44 <burbul> Where do you read up on the connections between category theory and Haskell?
08:29:59 <navaati> burbul: you hang on #haskell
08:30:01 <merijn> Scary blogposts :p
08:30:10 <mauke> scary papers
08:30:10 <hpc> wikipedia, to a lesser extent
08:30:17 <Eduard_Munteanu> burbul: well, edwardk's blog can be quite useful
08:30:21 <burbul> ok -- thanks
08:30:30 <Eduard_Munteanu> http://comonad.com/reader/
08:30:32 <hpc> and you can look for even scarier languages than haskell
08:30:50 <hpc> where more notions of CT are expressable
08:30:55 <merijn> Epigram > Coq > Agda? :p
08:30:58 <typoclass> burbul: do you have an interest in CT?
08:31:09 <merijn> (I'm letting scary syntax influence ordering there)
08:31:12 <copumpkin> Eduard_Munteanu: I don't think that's it
08:31:34 <burbul> typoclass: I took a grad category theory class, but it was a long time ago
08:31:37 <navaati> though it's not really category theory, there is this nice stuff about denotational semantic in the haskell wikibook
08:31:40 <hpc> i would say agda is more similar to haskell than coq
08:31:44 <hpc> and significantly less scary
08:31:46 <copumpkin> Eduard_Munteanu: the thing about EM is that your _objects_ are T-algebras, as far as I know, and the morphisms are T-algebra morphisms
08:32:05 <merijn> hpc: The greater than sign was with regards to scariness, so Agda was least scary there
08:32:09 <hpc> ah
08:32:17 <merijn> And Epigram scariest
08:32:22 <burbul> typoclass: So my category theory is rusty, but it would still be interesting to see the connections to Haskell
08:32:27 <merijn> Because the syntax looks like it mugs old ladies
08:32:30 <copumpkin> Eduard_Munteanu: and a T-algebra morphism is just a function between the objects of the T-algebra (along with a proof that the diagram commutes)
08:32:33 <rwbarton> epigram is scary largely because everything written about it is in scottish
08:32:34 <burbul> Epigram is the dependent types thing?
08:32:55 <merijn> burbul: All three are dependently typed
08:32:57 <navaati> Coq and Agda are as well
08:33:03 <copumpkin> Eduard_Munteanu: I haven't implemented EM, but I think it's basically the same as https://github.com/copumpkin/categories/blob/master/Categories/Functor/Algebras.agda with s/F-Algebra/T-Algebra/
08:33:04 <hpc> merijn: oh god epigram's syntax
08:33:14 <hpaste_> “Eduard - Gabriel Munteanu” pasted “Monads and adjunctions” at http://hpaste.org/67543
08:33:30 <merijn> hpc: It looks pretty when he renders it in LaTeX, but otherwise...
08:34:08 <Eduard_Munteanu> That's what I was playing with ^^. Only looked at edwardk's stuff for some inspiration for a reasonable adjunction I could implement :)
08:34:25 * navaati looking at Epigram wikipedia page
08:34:26 <navaati> oO
08:34:28 <navaati> omg
08:35:01 <merijn> navaati: Big mistake :p
08:35:10 <hpc> epigram: horrible syntax coerced into niceness with latex
08:35:12 <Eduard_Munteanu> (At times, I *really* wanted to fire Agda up to avoid Haskell's quirkiness :D)
08:35:22 <hpc> coq: mediocre syntax coerced into horribleness with tactics
08:35:36 <merijn> I wish haskell had mixfix...
08:35:38 <hpc> agda: beautiful syntax coerced into horribleness with huge proofs with huger identifiers
08:35:58 <burbul> Haskell's quirkiness <--- curious about this
08:35:59 <navaati> oh, yeah, the latex rendering is ice, but… you need to type the horrible thing first
08:36:08 <merijn> We'd be EDSL kings, crushing the Lisp fools under our type theory powered death machine
08:36:26 <Botje> merijn: i would like one of those
08:36:31 <merijn> navaati: The goal of Epigram is that you don't have to type everything
08:36:36 <hpc> nothing like "lemma-⊕-×-¬∀A-F" to identify one of five proof assumptions
08:36:47 <hpc> (read: one of five function parameters)
08:36:49 <merijn> navaati: The goal is to have programmer controlled type directed program generation
08:37:03 <Eduard_Munteanu> burbul: I mostly mean the need for newtype wrappers
08:37:30 <merijn> Eduard_Munteanu: Like runIdentity for Data.Functor.Identity and getCompose for Data.Functor.Compose?
08:37:50 <navaati> and Kleisly !
08:37:54 <merijn> Those suck balls...ruin very readable typeclass coding :<
08:38:06 <merijn> If haskell had instance chains you wouldn't need them :D
08:38:11 <burbul> ah, ok
08:38:15 <Eduard_Munteanu> Yeah, I wasted quite a bit of time getting the wrapping/unwrapping part right.
08:38:35 <merijn> Then you could close instances and without open world assumption you can generate the code without wrappers, I think
08:38:40 <burbul> I've got frustrated at the fact that I can't say   Type1 = Type 2 | Type3  without a wrapper... sounds like you're having the same headache a couple of days octaves up
08:38:45 <Eduard_Munteanu> I guess TypeSynonymInstances is a way around it, but I hear it sucks wrt correctness.
08:38:45 <burbul> *couple of octaves
08:38:58 <rwbarton> TypeSynonymInstances is fine
08:39:03 <rwbarton> it also doesn't solve this problem
08:39:22 <Eduard_Munteanu> Oh, right, synonyms must be fully applied.
08:39:37 <rwbarton> TypeSynonymInstances just means you can use a type synonym in an instance head in a position where it can be expanded, yes
08:40:03 <rwbarton> There ought to be some standard place to point people who want to write instances for things like the composition of two type constructors...
08:40:06 <Eduard_Munteanu> I can't say  type Compose f g x = f (g x)   and have   instance ... => Monad (Compose g f)
08:42:48 <rwbarton> is UnsafeQuasiQuotes a real thing?
08:43:26 <byorgey> rwbarton: there is.  Data.Functor.Compose from the transformers package.
08:43:38 <Eduard_Munteanu> Anybody remember what's the "best" approach on combining monads and comonads? I remember edwardk saying the distributivity thingy (like Uustalu and Vene did (and edwardk himself at some point :D)) is pretty bad.
08:44:05 <rwbarton> I meant an explanation for why Haskell doesn't have "type-level functions" and especially why they could not be instances of type classes
08:44:16 * hackagebot selenium 0.2.5 - Test web applications through a browser.  http://hackage.haskell.org/package/selenium-0.2.5 (AaronTomb)
08:44:17 <byorgey> oh, sorry, I misunderstood.
08:45:04 <byorgey> I could probably write such an explanation.  But it's not actually that clear-cut.
08:45:14 <navaati> does running haddock fully typechecks a program ? because it's faster than building, and most of the time when I build I actually only want to verify that it typechecks
08:45:17 <merijn> rwbarton: It's mostly just because the typeclass coding suffers from open world assumption, no?
08:45:23 <rwbarton> no
08:45:34 <merijn> Enlighten me, then?
08:45:38 <rwbarton> it's because you could (almost) never infer what instance to select from the usage
08:45:57 <merijn> Oh, yeah. That's a problem too
08:45:59 <rwbarton> well, perhaps you call this "suffering from open world assumption"
08:46:29 <merijn> No, open world assumption is mostly complaints about overlappinginstances
08:47:00 <merijn> Actually, not even that, strictly speaking
08:47:06 <rwbarton> since you can't infer what instance to use, you would have to add some annotations somehow, and already you have lost the advantage of having a type class in the first place
08:49:12 <Eduard_Munteanu> I think in my case it would be fine... e.g. if there's F -| U, you can unambiguously get a monad for U o F, and there's no instance for anything that might be similar to that (i.e. a general functor T).
08:52:56 <Eduard_Munteanu> Another thing I was wondering earlier was whether you can see monads as some kind of hylomorphisms. For example if you squint at a corresponding F -| U adjunction and see free -| forgetful.
08:53:13 <mm_freak> navaati: haddock does not type-check
08:53:21 <mm_freak> but it parses type signatures
08:53:50 <Eduard_Munteanu> I mean, some adjunctions corresponding to it might have a unit that pretty much builds up a structure and collapses it afterwards.
08:53:57 <navaati> mm_freak: ah ? maybe it was only syntax errors that i got with it, then
08:54:08 <mm_freak> i could imagine it does type inference, but i've never tried it out
08:54:25 <navaati> is there a way to make ghc typecheck but not generate object code ?
08:54:36 <mm_freak> load it in GHCi
08:54:42 <navaati> after all, in haskell, "if it compiles, it works"
08:54:54 <mm_freak> if it compiles, it's consistent
08:55:14 <hpc> navaati: you can even use ":r" in ghci to reload the file
08:55:24 <hpc> and do interactive messing-with-it as you code
08:55:35 <burbul> @pl map (first head . unzip) . groupBy ((==) `on` fst) . sortBy (comparing fst)
08:55:35 <lambdabot> map (first head . unzip) . groupBy ((==) `on` fst) . sortBy (comparing fst)
08:55:37 <navaati> ah, i thought that ghci built things JIT
08:55:40 <navaati> great then, thanks
08:55:46 <Eduard_Munteanu> (Well, with the somewhat weird addition that you can get from T^2 to T)
08:55:51 <burbul> @help
08:55:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
08:55:52 <mm_freak> if you use emacs, you can also use the inferior mode, which gives you a nice interface to compilation, evaluation and type-checking
08:56:20 <mm_freak> navaati: GHCi specifically differentiates between interpreted and compiled modules
08:56:30 <burbul> Is there someone I can play with lambdabot without hassling you all with the text I produce?
08:56:33 <merijn> navaati: Defining functions as undefined is great if you have a type signature and no real implementation yet
08:56:40 <mm_freak> it does compile to an internal representation, the core language
08:56:42 <merijn> burbul: Lambdabot responds to privmsg
08:56:45 <navaati> burbul : you can /msg lambdabot
08:56:45 <Eduard_Munteanu> burbul: /query lambdabot
08:56:48 <mm_freak> but it does not compile to object code
08:56:55 <navaati> ah, great
08:56:55 <burbul> thanks!
08:57:15 <Eduard_Munteanu> burbul: mind :t doesn't work there, you have to use @type (or an abbreviation of it)
08:57:22 <burbul> thanks again
08:57:27 <donri> undefined is mostly useful for development, for which i find file-location more useful ($undef also points to the location)
08:57:43 <t7> whats -> in prop logic?
08:57:57 <Eduard_Munteanu> t7: implication
08:57:58 <mm_freak> merijn: it's a way, but not a great way…  you're proving bottom and you might forget to remove such a proof, which leads to run-time bugs
08:58:14 <navaati> not really : git grep undefined
08:58:15 <Axman6> a -> b | a = b | otherwise = True
08:58:39 <merijn> mm_freak: Depends, I usually start by defining type signatures with no associated implementation
08:58:52 <merijn> mm_freak: Otherwise things won't load/be type checked
08:58:54 <navaati> hum, i've never got the inferior mode to work, because it launches ghci in the file's dire instead of launching it at the root of the project…
08:59:09 <navaati> undefined is like goals in Agda…
08:59:39 <mm_freak> merijn: yeah, it's unfortunate…  i'd love to have agda's goals in haskell
08:59:52 <mm_freak> navaati: undefined is nothing like agda's goals
09:00:07 <navaati> i mean it's usage
09:00:18 <hpc> mm_freak: in the "type-check everything, and assume the holes are filled" way
09:00:35 <rzys> question: is there some kind of function like iterate which accepts a predicate as an argument and stops the iteration if the predicate holds/doesn't hold?
09:00:49 <hpc> @hoogle until
09:00:49 <lambdabot> Prelude until :: (a -> Bool) -> (a -> a) -> a -> a
09:01:00 <mm_freak> navaati: not quite…  agda's goals are editor-supported
09:01:12 <rzys> hpc, awesome! thanks
09:01:31 <hpc> @hoogle untilM
09:01:32 <navaati> yeah, they're nicer than using undefined, but… it's all that we have :)
09:01:32 <lambdabot> No results found
09:01:37 <hpc> :(
09:01:47 <mm_freak> rzys: i'd use filter f . iterate g
09:01:48 <bitonic> mm_freak: but they're not editor-dependent. both undefined and goals are what you stick in to-be implemented functions :P
09:01:54 <navaati> (well, no, a better thing than undefined is $ error "TODO"
09:02:11 <mm_freak> bitonic: have you ever asked for the type of a certain 'undefined'?
09:02:36 <Eduard_Munteanu> mm_freak: mm, I don't think that'll give you the end of the list.
09:02:57 <bitonic> mm_freak: again, they're both used in functions that you're going to implement at some point. they're similar in that regard.
09:03:02 <mm_freak> Eduard_Munteanu: if you want only the first result, add a 'head'
09:03:05 <bitonic> but yes goals are much more powerful
09:03:41 <mm_freak> bitonic: goals have a broader set of possible applications
09:04:14 <rzys> mm_freak, because of speed or just preference ?
09:04:28 <mm_freak> rzys: the latter
09:04:29 <bitonic> mm_freak: I. understand. But they have similar use cases.
09:05:06 <mm_freak> one great thing about goals is that their value can be inferred…  not just their type
09:05:20 <mm_freak> djinn on steroids, basically
09:05:24 <Eduard_Munteanu> mm_freak: I mean you'll get something like a:b:c:_|_ if f matches up to c and the input list is infinite.
09:05:26 <rzys> mm_freak, which one would you think is faster (if any)? because i need to optimize my code :)
09:05:45 <burbul> gah, I'm sitting here just trying to make my (working) Haskell code look prettier and prettier rather than actually achieving anything...
09:05:51 <mm_freak> Eduard_Munteanu: you'll run into the same problem with 'until'
09:06:22 <mm_freak> rzys: usually explicit recursion gives you the fastest code, but that doesn't mean it's faster than other methods
09:06:26 <Eduard_Munteanu> Yeah... I guess takeWhile f . iterate g does it though.
09:07:17 <mm_freak> rzys: in a certain edge case using abstractions can lead to faster code, namely when the abstraction causes optimization rules to fire
09:07:26 <mm_freak> so i would always try the high level approach first in haskell
09:08:26 <navaati> burbul: ahahah, yeah, i've spent weeks doing that :D
09:08:55 <sm> is it not possible to set --ghc-options via ~/.cabal/config ?
09:09:32 <rzys> mm_freak, thanks! i'll need to look into that
09:10:54 <hpaste_> kermit pasted “match” at http://hpaste.org/67544
09:11:39 <rwbarton> kermit_, you need () around baum:[] and so on
09:12:09 <rwbarton> "(Node _ baum:[])" is "((Node _ baum):[])"
09:12:55 <rwbarton> you want "(Node _ (baum:[]))"
09:13:18 <statusfailed> In the statistics package, why does the StudentT distribution not have parameters for location and scale?
09:13:43 <kermit_> i read realworldhaskell and learnyouahaskell - but i was not able to figure out, how to solve - can someone give me a hint please?
09:14:11 <rwbarton> kermit_, see above
09:16:52 <kermit_> thanks for the awnsers - but i do not understand _why_ it has to be done this way
09:17:14 <rwbarton> just like "f x y+z" means "(f x y)+z"
09:17:15 <Eduard_Munteanu> kermit_: precedence
09:17:24 <rwbarton> application binds tighter than binary operators
09:19:13 <kermit_> got it - thanks
09:20:10 <monochrom> full parenthesizer: http://bm380.user.srcf.net/prettyparsetree.cgi
09:21:32 <monochrom> @quote data.*string
09:21:32 <lambdabot> kmc says: Java programmers learning Haskell write code like this:  data Hello = Hello; class HasMessage t where { getMessage :: t -> String }; instance HasMessage Hello where { getMessage Hello = "
09:21:32 <lambdabot> Hello, world!" }; main = putStrLn (getMessage Hello)
09:21:46 <monochrom> @quote string.*data
09:21:47 <lambdabot> roconnor says: String is kinda a poor data type for strings.
09:21:52 <monochrom> haha
09:21:58 <monochrom> @quote string.*obscure
09:21:58 <lambdabot> No quotes match. I feel much better now.
09:22:03 <monochrom> @quote string.*obscur
09:22:03 <lambdabot> No quotes match. I feel much better now.
09:22:04 <MaskRay> hot do you deduce what (.) . (.) do?
09:22:07 <MaskRay> how
09:22:32 <monochrom> I consider what happens to "((.) . (.)) x"
09:22:35 <dmwit> MaskRay: By evaluating it by hand.
09:22:46 <dmwit> MaskRay: Or by looking at its type, which can't have very many implementations. =)
09:22:50 <monochrom> and yes, s/consider/calculate/
09:22:53 <rzys> mm_freak, filter (< 10) . iterate (*2) $ 1   ghci hangs at [1,2,4,8   do you know what could be wrong?
09:23:14 <dmwit> rzys: Nothing is wrong.
09:23:24 <danr> rzys: you might want to use takeWhile instead
09:23:25 <monochrom> if necessary, I go further and calculate "((.) . (.)) x y"
09:23:29 <MaskRay> a much abstruser problem is to get (.) . (.) from  (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:24:14 <dmwit> MaskRay: It's easy to get from that signature to \f g a b -> f (g a b).
09:24:16 <dmwit> MaskRay: And then
09:24:22 <dmwit> ?pl \f g a b -> f (g a b)
09:24:22 <lambdabot> (.) . (.)
09:24:25 <dmwit> =)
09:24:34 <rwbarton> @. pl djinn (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
09:24:34 <lambdabot> f = (.) . (.)
09:24:37 <rzys> so filter doesn't work on infinite lists?
09:24:53 <dmwit> rzys: What are you talking about?
09:24:55 <dmwit> It's working fine.
09:25:01 <statusfailed> rzys: filter returns a list without any elements matching the predicate
09:25:05 <monochrom> FSVO "work"
09:25:20 <rzys> so for an infinite list it would return another infinite list without those elements?
09:25:24 <monochrom> it's all about managing expectations
09:25:25 <statusfailed> it doesn't know that your infinite list won't contain any smaller elements later
09:25:26 <byorgey> rzys: filter works on infinite lists.  It is quite happily continuing to work on your infinite list, and never finding any elements that match the predicate.
09:25:28 <dmwit> monochrom: Yes, part of my annoying responses is to try to get rzys to say carefully what he doesn't like. =)
09:25:32 <rwbarton> it will never return a *finite* list when passed an infinite list
09:25:39 <byorgey> rzys: filter cannot magically figure out that the predicate will never be satisfied after a certain point.
09:25:54 <byorgey> because it does not know how the list was constructed.
09:26:01 <statusfailed> *suddenly, everyone*
09:26:21 <monochrom> but yeah, it totally "work"s for me, FMVO "work"
09:26:27 <byorgey> @quote stereo
09:26:27 <lambdabot> Cale says: Welcome to #haskell, where your questions are answered in glorious stereo!
09:26:33 <statusfailed> haha
09:26:36 <dmwit> Oh, is that quote back in now?
09:26:40 <byorgey> no
09:26:51 <dmwit> Do we have a metaquote about that ?quote stereo appearing and disappearing yet?
09:27:00 <monochrom> at least it is not "majestic stereo" :)
09:27:08 <byorgey> @remember dmwit Do we have a metaquote about that ?quote stereo appearing and disappearing yet?
09:27:08 <lambdabot> Done.
09:27:12 <dmwit> haha
09:27:24 <statusfailed> Isn't that a meta-metaquote?
09:27:31 <byorgey> indeed, we still don't have a metaquote
09:27:50 <statusfailed> that'll keep 'em guessing
09:29:08 <rzys> thanks, makes sense. sorry about the dumb questions. :S
09:29:09 <monochrom> we need to manage (lower) expectations of people who come to haskell from the math angle i.e. "I'm attracted to haskell because it looks so much like math!"
09:29:26 <monochrom> dude, it's a programming language, not a CAS, not a theorem prover
09:29:39 <navaati> we maybe need to redirect them to agda, then
09:30:01 <byorgey> rzys: it wasn't a dumb question.
09:30:01 <luite> no we need to write more math libs and expression rewriting stuffin haskell!
09:30:37 <navaati> and write a book "imaginary world haskell" :p ?
09:30:52 <byorgey> hehe, I would totally buy such a book
09:31:11 <byorgey> a book full of beautiful, amazing code which is completely useless
09:31:30 <PatrickRobotham> monochrom: Direct them to Coq or Agda?
09:31:35 <monochrom> [ (x,y,z) | x<-[1..], y<-[1..], z<-[1..], x^3 + y^3 == z^3 ] is not going to take O(1) time just because "we" "know" the answer "mathematically". and so, no, agda does not help either
09:31:38 <luite> hmm, that does sound great
09:31:41 <danr> terminatingTuringMachines = filter terminates turingMachines
09:31:52 <albel727> heh
09:32:36 <navaati> lol = terminates terminatingTuringMachines
09:32:48 <danr> navaati: ouch
09:32:48 <mm_freak> danr: that list could totally be infinite =)
09:33:07 <mm_freak> just write 'turingMachines' properly
09:33:13 <int-e> > head [(x,y,z) | x<-[1..], y<-[1..], z<-[1..], x^3 + y^3 == z^3] :: (Int8,Int8,Int8) -- ;-)
09:33:14 <lambdabot>   (1,2,25)
09:33:30 <monochrom> Coq may be right. it doesn't even run your programs. O(0) time.
09:33:32 <byorgey> hehehe
09:34:17 * hackagebot compdata 0.5.3 - Compositional Data Types  http://hackage.haskell.org/package/compdata-0.5.3 (PatrickBahr)
09:34:18 <navaati> when beginning with Agda I had a very har time trying to understand it's execution model. until i realized there is no…
09:34:44 <monochrom> eh? it surely has an execution model, someone uses it for web apps
09:34:58 <mm_freak> navaati: sure there is…  in fact you can't even typecheck without it in agda
09:35:06 <byorgey> it also has to reduce terms in order to do type checking.
09:35:13 <mm_freak> in a dependently typed language type checking involves evaluation
09:35:26 <navaati> yeah, it has but… well, you know what i mean ;)
09:35:32 <mm_freak> no =)
09:35:38 <bitonic> yes, but the execution model is not specified in agda
09:35:40 <byorgey> it's certainly true that the execution model is not emphasized very much
09:35:51 <monochrom> oh! it has no "execution" model, it has an "evaluation" model, is that what you mean?
09:36:07 <navaati> something like that
09:36:14 <bitonic> yeah maybe the right word is evaluation? boh
09:36:17 <mm_freak> navaati: there are three agda compilers
09:36:24 * monochrom doesn't like that bikeshed
09:36:39 <danr> plenty of talk about Agda in #haskell recently :)
09:36:40 <mm_freak> so there certainly is also an execution model, but it depends on the compiler
09:36:48 <int-e> spring is the perfect time for bikeshedding and shedding in general.
09:37:18 <monochrom> but it is not yet spring in toronto. still get flurries
09:37:20 <navaati> mm_freak: yeah, i discovered that latter, but they are not usually used
09:37:24 <mm_freak> if you use the MAlonzo compiler you get haskell code, so the execution model is the same as haskell's
09:37:33 <bitonic> monochrom: it's not bikeshed, things are much less clear in Agda
09:37:40 <Eduard_Munteanu> danr: how else would we get #agda to grow? :P
09:37:41 <monochrom> OTOH we had two days of summer earlier this month
09:37:42 <bitonic> mm_freak: well not really, it's just compiled down to haskell
09:38:04 <mm_freak> bitonic: the IO combinators are translated almost verbatim
09:38:06 <danr> int-e: shedding? is this what you're talking about? http://en.wikipedia.org/wiki/Moult
09:38:10 <bitonic> and in fact there is a lot of talk on the mailing list recently on how things are executed in the type checker as well
09:38:18 <bitonic> mm_freak: what do you mean? the foreign binding to IO
09:38:27 <monochrom> oh, I really mean: I don't like the bikeshed of evaluation/execution for even haskell
09:38:38 <mm_freak> yeah…  i don't know what semantics agda has for evaluation
09:38:39 <navaati> bwahaha, Vala guys think they are high-level because they compile down to C, but… there is worse
09:38:44 <int-e> danr: yes.
09:39:13 <danr> int-e: eww
09:39:20 * monochrom compiles assembly down to C
09:39:29 <int-e> danr: actually I was thinking of mammals, and hair.
09:39:40 <mm_freak> but i would expect that the evaluation strategy of agda is far less lazy than the one of haskell, because for typechecking you need to compare normal forms
09:40:13 <mm_freak> i'd even expect it to be nonlazy, unless you use coinduction
09:41:23 * monochrom compiled turing machines down to this language: http://en.wikipedia.org/wiki/Turing_%28programming_language%29
09:41:38 <bitonic> mm_freak: evaluating to normal form doesn't clash with lazy evaluation
09:41:48 <monochrom> it sounds ironic in retrospect, haha
09:42:23 <bitonic> mm_freak: actually lazy evaluation is useful to eliminate computationally irrelevant stuff, but I don't know how agda works so I'll shut up :P
09:43:19 <mm_freak> bitonic: in a total language the normal form is independent of the evaluation strategy
09:43:21 <Eduard_Munteanu> I guess you normalize compile-time known things in Agda.
09:43:43 <jfischoff> where's copumkin
09:44:10 <Eduard_Munteanu> Around ;)
09:44:16 <jfischoff> he mentioned something in his video on Agda
09:44:18 <jfischoff> :)
09:44:34 <monochrom> he's compiling some agda code. it hasn't finished
09:45:03 <jfischoff> he just needs 12 gigs and he'll be fine
09:45:17 <bitonic> mm_freak: yeah exactly. so you can happily be lazy and evaluate to normal form (my comment was related to your comment saying that agda is probably stricted because it needs to compute normal forms)
09:46:16 <monochrom> you see the fun in talking about termination without mentioning the time spent
09:46:57 <monochrom> my supervisor thinks it's a cheesy philosophical position, and I agree mostly
09:47:12 <Eduard_Munteanu> It's more like you can evaluate however you want and the semantics are the same.
09:47:12 <rak_> hi
09:47:20 <Eduard_Munteanu> rak_: hi
09:48:37 <Eduard_Munteanu> monochrom: the other side of that might be fun too... like, what sort of theorems can you write if you add asymptotic time bounds on top of non-termination?
09:48:45 <monochrom> oh, I know all the counter arguments. if your semantics does away with costs, sure. precisely why my supervisor is against that and I agree with him. a semantics that ignores costs is impractical
09:49:24 * hackagebot web-routes-hsp 0.23.0 - Adds XMLGenerator instance for RouteT monad  http://hackage.haskell.org/package/web-routes-hsp-0.23.0 (JeremyShaw)
09:51:01 <mm_freak> bitonic: what i mean is that it would be totally reasonable to evaluate eagerly where it gives you a speed gain…  this is hypothetical, as i don't know what the interpreter/compiler do
09:51:47 <bitonic> mm_freak: yes but you have the disadvantage that you might end up computing computationally irrelevant stuff. lazy evaluation automatically avoids that (again, I have no idea what Agda actually does).
09:52:08 <bitonic> since with dependent types you will have a lot of computationally irrelevant stuff :P
09:52:18 <mm_freak> well, we don't know
09:52:18 <Eduard_Munteanu> Well, it compiles to Haskell code, so every runtime value seems to get lazily evaluated.
09:52:45 <mm_freak> Eduard_Munteanu: only the MAlonzo /compiler/ compiles to haskell code
09:52:50 <bitonic> Eduard_Munteanu: you can write strict haskell.
09:52:54 <mm_freak> otherwise it is an interpreter
09:53:04 <Eduard_Munteanu> It's a bit like asking whether doing optimization on 1 + 1 in Haskell amounts to strictness.
09:53:24 <Eduard_Munteanu> Yeah, it does depend on the backend.
09:53:41 <bitonic> Eduard_Munteanu: and there's the typchecker, which evaluates as well
09:54:25 * hackagebot digestive-functors-hsp 0.5.0 - HSP support for digestive-functors  http://hackage.haskell.org/package/digestive-functors-hsp-0.5.0 (JeremyShaw)
09:54:27 * hackagebot happstack-hsp 7.1.0 - Support for using HSP templates in Happstack  http://hackage.haskell.org/package/happstack-hsp-7.1.0 (JeremyShaw)
09:54:37 <Eduard_Munteanu> bitonic: but those reductions work on compile-time known expressions, so we'd only be talking about time spent / shortcuts taken in the typechecker.
09:54:46 <Eduard_Munteanu> (which is also written in Haskell, btw :D)
09:55:14 <bitonic> Eduard_Munteanu: yes but it's still a big problem
09:56:13 <Eduard_Munteanu> I'm not so sure... can't the same argument be applied to GHC?
09:57:12 <bitonic> Eduard_Munteanu: no, because no evaluation of terms takes place when typechecking Haskell
09:57:36 <Eduard_Munteanu> Some terms might be evaluated during optimization.
09:57:54 <bitonic> ? I'm talking about type checking
09:58:39 <Eduard_Munteanu> Or even during typechecking, AFAIU, e.g. doing type system tricks.
09:59:00 <Eduard_Munteanu> Anyway, I'm saying it doesn't really matter when we're talking about the runtime evaluation strategy.
10:00:23 <bitonic> Eduard_Munteanu: in agda it matters because you don't want to wait incredible amounts of time to typecheck stuff. OFC you can do strange stuff with Haskell + UndecidableInstances, but it's nothing compared to Agda :P
10:01:13 <Eduard_Munteanu> Ah, sure. Though it's a matter of asking "how optimal is Agda's typechecking algorithm?".
10:04:26 * hackagebot hsx-jmacro 7.1.0 - hsx+jmacro support  http://hackage.haskell.org/package/hsx-jmacro-7.1.0 (JeremyShaw)
10:17:00 <statusfailed> Why can't I call lnGamma on Prelude.pi ?
10:17:14 <Axman6> what is lnGamma?
10:17:15 <statusfailed> oh I can.
10:17:24 <statusfailed> Axman6: it's the log of the gamma function
10:18:24 <Axman6> well, how could we answer your question without knowing that? you have to give context when asking questions. a better questions would have been "I have a function lnGamma :: foo -> bar -> baz, why can't I do X?"
10:18:32 <jfischoff> looks like "in gamma"
10:18:51 <statusfailed> Axman6: I was going to get around to it, but the test case I had appears to be wrong
10:18:55 <statusfailed> I'm working on it :P
10:18:59 <statusfailed> sorry ^^
10:19:05 <Axman6> s'all good =)
10:19:47 <statusfailed> unrelatedly, is naming variables things like α, β, γ a bad idea? :D
10:19:48 <dzhus> where is this «new locale library» mentioned at http://hackage.haskell.org/package/old-locale-1.0.0.3?
10:19:48 <lambdabot> dzhus: You have 1 new message. '/msg lambdabot @messages' to read it.
10:20:44 <dzhus> (i need just defaultTimeLocale)
10:24:01 <navaati> :t ($) . ($)
10:24:02 <lambdabot> forall a b. (a -> b) -> a -> b
10:24:27 <navaati> :t \f e -> f e e
10:24:28 <lambdabot> forall t t1. (t -> t -> t1) -> t -> t1
10:25:11 <navaati> @pl \f e -> f e e
10:25:11 <lambdabot> join
10:25:17 <navaati> -_-
10:25:21 <aib> :)
10:25:49 <navaati> i knew this was join, but i was looking at a clever way to write it, thank you lambdabot :)
10:26:49 <mauke> @unpl join
10:26:49 <lambdabot> (\ b -> b >>= \ a -> a)
10:26:58 <mauke> there you go
10:27:41 <navaati> not really : it still uses the (-> r) monad instance
10:27:57 <danr> no
10:28:03 <navaati> (i didn't know this @unpl thing, though)
10:28:05 <navaati> ah ?
10:28:15 <danr> :t \b -> b >>= \a -> a
10:28:16 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
10:28:29 <danr> it's the ordinary join, also written (>>= id)
10:28:32 <danr> :t (>>= id)
10:28:32 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
10:28:44 <edwardk> preflex: xseen bos
10:28:44 <preflex>  bos was last seen on freenode/#darcs 38 days, 21 hours, 6 minutes and 10 seconds ago, saying: I installed darcs-beta with -fbase44, but darcs-fastconvert - even when patched to depend on darcs-beta - cannot be built because cabal is selecting the wrong deps
10:29:10 <bos> edwardk: hi
10:29:14 <edwardk> heya
10:29:21 <edwardk> i just replied on google+ to your LCA post
10:29:23 <McManiaC> what could be wrong/missing if GHC doesnt look in ~/.ghc for packages?
10:29:30 <bos> edwardk: i'm sitting in a google hangout talking about exactly this topic
10:29:30 <int-e> @type (. (id &&& id)) . uncurry
10:29:31 <lambdabot> forall b b1. (b1 -> b1 -> b) -> b1 -> b
10:29:33 <edwardk> i spelled out more or less the algorithm I'm using
10:29:46 <bos> oh cool
10:29:47 <edwardk> good timing =)
10:29:57 <edwardk> basically I can compute online LCAs in O(log n)
10:30:01 <navaati> int-e: ah, great, this is what i was looking for :)
10:30:10 <edwardk> if you have the entire graph a priori, you can of course do better
10:30:20 <edwardk> but in my case I'm building it as I'm computing
10:32:33 <bos> edwardk: fascinating
10:32:52 <edwardk> bos: i'm just amazed that it hasn't appeared in literature before
10:33:17 <edwardk> even wikipedia cites O(n)
10:34:18 <bos> edwardk: so your algorithm is online?
10:34:22 <edwardk> yes
10:34:36 <edwardk> I'm computing it as I'm growing the dag in my case
10:34:46 <edwardk> as long as I have a unique node ID supply it works great
10:34:52 <bos> what's that revisions tree?
10:35:22 <edwardk> basically the idea is you have a monad which has a few operations, notably fork and join, and the ability to allocate version controlled variables
10:35:34 <edwardk> the variables specify a 3 way merge strategy when you declare them
10:36:26 <edwardk> so when you fork each fork gets its own copy of the variables, and when you join, if both branches edited something, then the 3 way merge is invoked using the LCA'd version and the two edited copies.
10:36:42 <bos> edwardk: your level of information density is terrifyingly high
10:37:06 <edwardk> so if you want to compute, say a running total, you can use a versioned sum, where you add the two new versions and subtract their common ancestor
10:37:48 <edwardk> thats the basic revision control monad, and it can get a ~5x speedup on 8 cores or so but you can do better
10:38:01 <jfischoff> edwardk: not distract from the LCA part, can you explain more merge strategies.
10:38:14 <jfischoff> err s/more/more about
10:38:32 <edwardk> the next idea is to use the fork/join model to not just spark background computation, but to do incremental recomputation when you want to recompute something in an edited context.
10:39:52 <edwardk> so what you can do then is make a record :: Rev s a -> Rev s (a, Rev s a)  action, that executes your fork/join graph but also computes an optimized action, that when run in an edited context, works out what variables each branch read from, and if none of them have changed the answer from that branch can be reused.
10:40:10 <edwardk> jfischoff: daan leijen has a nice paper on the topic which gives a few more examples
10:40:14 <adnauseam> in which module do i find "first" ?
10:40:22 <mauke> @hoogle first
10:40:22 <lambdabot> Data.Monoid First :: Maybe a -> First a
10:40:22 <lambdabot> Data.Monoid newtype First a
10:40:23 <lambdabot> Control.Arrow first :: Arrow a => a b c -> a (b, d) (c, d)
10:40:24 <edwardk> adnauseam: Control.Arrow
10:40:27 <jfischoff> edwardk: thanks I'll search for the link
10:40:28 <adnauseam> thanks man
10:41:04 <adnauseam> thanks mauke too :}
10:41:20 <edwardk> jfischoff: i also simplified the problem somewhat because you also sometimes want to do something the first time a versioned variable is accessed in a fork
10:43:43 <edwardk> bos: with record you can do some neat things. notably, if you have a structure you are going to make small edits to and recompute answers from (say, css layout for a web page, or something FRPish, game AI state, parse trees in an editor, type error slicing in a typechecker, etc.) you can record an initial run, and then run the recorded computation after each edit
10:43:59 <rzys> aaaah, how nice if several hours of optimization results in half the runtime of the unoptimized one.
10:44:50 <rzys> (and yes the first version, and probably even this one is totally inefficient :)
10:45:34 <edwardk> with that you can get something like an 60x speedup on 8 cores for css layout by just adding the fork/join annotations needed for parallelism, and recycling them for incrementalization. of course this is subject to how fine grained the revision controlled variables are made, and how big the edits are
10:45:54 <edwardk> but it gives you a nice way to exploit 'temporal coherence'.
10:46:42 <jfischoff> edwardk: Sounds similar to partial application specialization
10:46:53 <edwardk> yep
10:47:10 <edwardk> oops, css layout was 27x, not 60x
10:47:29 <edwardk> but thats because it only got 1.8x speedup from parallelism
10:48:31 <edwardk> but going from 185ms to 6.9ms is kinda nice ;)
10:49:18 <Saizan> "kinda"
10:50:31 <edwardk> saizan: its scarier with the type error slicing
10:51:25 <edwardk> saizan: there i'm using it to run O(n) passes which are usual linear time each in what feels like O(1) each
10:52:02 <edwardk> i say feels like because of course its a type checking problem so the algorithms are nominally exponential but linear in practice
10:52:30 <edwardk> making them constant in practice for the subsequent slices is pretty spiffy
10:54:18 <Saizan> of course now i'm wondering if these huge speedups would apply to typechecking itself, for a dep. typed lang :)
10:58:07 <edwardk> saizan: that and decent hash consing are two thoughts i've had when playing around with little dependently typed language designs
10:58:41 <edwardk> Saizan: but i've only really thought about it from the standpoint of error slicing, to figure out a minimal set of source ranges involved in the error
11:00:01 <cheater> edwardk: hi, got a sec? :)
11:04:26 <edwardk> heya cheater
11:04:53 <cheater> hey :) can i msg you?
11:05:13 <edwardk> sure
11:05:28 <Chaze> do you know a good book about "higher higher-order programming"? i mean programming which takes the abstraction level a bit further than simply passing around one level of functions..
11:05:39 <Chaze> you know, stuff like (((Function) -> (Function -> Function)) -> Function)
11:05:51 * edwardk gets the distinct impression he's going to be dispensing fitness advice for the next hour ;)
11:07:11 <Alan> bleh, my parser isn't working :(
11:09:12 <Alan> https://gist.github.com/a815aa2de0df4b1ddbb7
11:09:46 <edwardk> chaze: not that i can think of
11:09:52 <Alan> i know that's a pretty small fragment, but hopefully it's enough ... basically, i only ever get the first line from parseAsm
11:10:07 <Alan> parseLine seems to work correctly
11:11:26 <b0fh_ua> Hi all! Which function may produce all selections by n items from list of m items?
11:12:10 <jfischoff> bofh_ua: do you mean combinations?
11:12:46 <rwbarton> can you repeat elements, does the order matter, etc.
11:13:35 <b0fh_ua> jfischoff: yeah
11:14:10 <jfischoff> b0fh_ua: http://hackage.haskell.org/package/permutation
11:15:31 <rwbarton> > let choose 0 _ = [[]]; choose n xs = [ x : ys | x : rest <- tails xs, ys <- choose (n-1) rest ] in choose 2 [1..4]
11:15:32 <lambdabot>   [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]]
11:17:33 <b0fh_ua> thanks
11:19:04 <Alan> aha, i think i've found the root cause of my problem...
11:19:15 <jfischoff> rwbarton: nice answer
11:42:34 <Rakin05> hey guys. got a question. i learn haskell for personal interest since 2 weeks now. today i've seen a video of simon peyton jones where he says that haskell is useless compared to c or c#. now im confused. is haskell really as useless as he says?
11:43:38 <uniquenick> I have some functions that take really long strings for their argument, and I'd like to work some magic to load those strings from files instead at compile time
11:44:14 <uniquenick> do I want to use quoteFile and create a QuasiQuoter that just returns the text as is?
11:45:17 <parcs`> Rakin05: yes
11:45:54 <parcs`> Rakin05: what video are you talknig about btw
11:46:05 <parcs`> i don't recall him ever saying that
11:46:26 <JuanDaugherty> poor english skills is the explanation
11:46:39 <JuanDaugherty> apparently
11:46:41 <rwbarton> http://www.youtube.com/watch?v=iSmkqocn0oQ
11:46:56 <Rakin05> parcs: http://www.youtube.com/watch?v=iSmkqocn0oQ
11:47:21 <parcs`> that video is SIX minutes long. got a timestamp?
11:47:53 <rwbarton> six minutes of SPJ, how can you not watch it
11:48:07 <Rakin05> parcs: not really. maybe 1:30 . Look at the Diagram
11:48:21 <Eduard_Munteanu> Probably his British humor :P
11:51:57 * JuanDaugherty watched 4:19 of it.
11:52:47 <Lorehead> I doubt anyone who agrees that Haskell is literally useless would bother to show up here.  Take that as hyperbole.
11:53:02 <JuanDaugherty> classic academic cluelessness
11:53:45 <Lorehead> The point he makes that a language must have some side-effects to be useful, but that side-effects are unsafe in the sense hes talking about, is correct.
11:53:55 <Cale> Rakin05: He's being diplomatic ;)
11:54:08 <JuanDaugherty> he really seems to be out of touch with the current state of haskell
11:54:11 <Cale> Rakin05: But that's also not exactly what he's saying
11:54:18 <parcs`> Rakin05: if you watch the entire video it seems spj meant haskell started out as a useless language
11:54:23 <Cale> He's saying that Haskell started out being less "useful"
11:54:32 <JuanDaugherty> or maybe the current state of the world where people make a living outside tenure
11:54:36 <Cale> but more safe
11:54:44 <Rakin05> at first i could'nt believe that he says that. i come from a strong java background and enjoy haskell so much
11:54:51 <Cale> and has been moving in the direction of usefulness
11:54:55 <Lorehead> You can use it to do (just about) anything you can do in C.  One exception actually came up in my upcoming GSoC project, which will be to make Haskell a little bit more useful.
11:54:59 <Lorehead> In his sense.
11:55:00 <JuanDaugherty> or corporate sinecures
11:55:08 <c_wraith> JuanDaugherty: that's an interesting assertion to make about one of the two main authors of GHC.  he knows *very well* what it can do.
11:55:51 <c_wraith> JuanDaugherty: he's been an author of GHC for the last 20 years or so.
11:56:01 <JuanDaugherty> yes, I found it (what the video showed) interesting too
11:56:17 <JuanDaugherty> c_wraith, I'm well aware of this
11:56:30 <Lorehead> But there are some things that Haskell expresses very elegantly and naturally, and others that get really ugly.
11:56:57 <Rakin05> Lorehead: do you have examples for uglyness?
11:57:09 <JuanDaugherty> one does wonder sometimes though if all the h's are for helium
11:57:31 <Lorehead> Well, last term, in my machine-learning class, part of one of my projects was to implement a simulator for arbitrary Markov Decision Processes.
11:57:45 <Lorehead> And part of that involved being able to generate a string of random numbers.
11:58:00 <c_wraith> Anyway...  His main point was that haskell's design started in the "useless but safe" area of the diagram, and then has tried to move away from useless while staying safe. (It's done pretty well, but it's not a finished product)
11:58:42 <Lorehead> This involved monads; at first, two different kinds of monads, but it turned out somebody had already combined them into a third kind of monad, which saved me some time.
11:58:50 <Rakin05> c_wraith: but, are there any finished products in terms of programming language out there?
11:58:57 <JuanDaugherty> yeah his perspective seemed in the hyperbole seemed to be anchored in the Std ML of NJ days
11:59:43 <Lorehead> And one of the roots of that problem was that, even when, logically, you dont care what order your pseudo-random numbers get generated in, as far as Haskell is concerned, each call to the PRNG changes the state of the PRNG.
11:59:52 <c_wraith> Rakin05: sure. Many claim to be perfect. Until they release a new perfecter version.
12:00:11 <Lorehead> And each call to the system PRNG does I/O.  So it all has to be sequenced.
12:00:55 <luite> Lorehead: have you looked into MonadRandom ?
12:01:10 <Lorehead> And therefore it all has to be written in the type system and syntax for sequenced code.  And every code that depends on that code needs to be sequenced, too.
12:01:18 <Lorehead> Yes, MonadRandom is what I ended up using. :)
12:01:31 <Rakin05> c_wraith: Haskell is the first programming that not leads me into pitfalls while learning it
12:01:32 <luite> ah but then i guess you used a pure rng, right?
12:01:34 <Lorehead> I guess I shouldve called it a class.
12:01:37 <iisjmii> Hello all, I have been learning Haskell since today. To test what I've learned so far I solved the first problem from the Euler website. Can anybody please comment on my style? http://pastebin.com/Lw0wt3TJ
12:01:39 <mauke> The paste Lw0wt3TJ has been copied to http://hpaste.org/67546
12:02:40 <c_wraith> Rakin05: Oh. Well, there are some... Maybe you've been lucky to avoid them, maybe you just haven't hit them yet. Several only show up when you start designing larger programs, and you find what worked in small examples doesn't work so well in large ones
12:03:22 <Lorehead> Anyway, I ended up handing in that assignment late. :)
12:04:04 <Rakin05> c_wraith:i use haskell only for private little projects. for example the last days i wrote a little network chat that communicates via udp and really enjoyed it
12:04:18 <Lorehead> iisjmii: Looks nice, but a few comments.  Should I share them here or in PM?
12:04:28 <parcs`> Lorehead: annotate it :)
12:04:45 <iisjmii> both is fine by me
12:04:57 <Lorehead> Not familiar with how to annotate pastebins?
12:05:16 <Botje> annotate hpaste
12:05:33 <parcs`> iisjmii: your use of guards is redundant, and there already exists a 'sumOfList' function, called 'sum'
12:05:50 <Lorehead> Okay, first, no reason to count down instead of up.  Second, the sum function exists in the Prelude.  Third, if youre writing your own sum for ints, you can use foldl' instead of fold to get tail-recursion elimination.
12:06:21 <hpc> @src sum
12:06:21 <lambdabot> sum = foldl (+) 0
12:06:42 <iisjmii> Lorehead: thx, one moment girlfriend is shouting...
12:06:54 <Lorehead> Fourth, there are faster algorithms you can use. :)
12:07:50 <rwbarton> also you can just write multipleOf x y = mod x y == 0
12:08:00 <Lorehead> The sum of all numbers divisible by either 3 or 5 is the sum of all numbers divisible by 3 plus the sum of all numbers divisible by 5 minus the sum of all numbers divisible by both, which would be counted twice.
12:08:04 <rwbarton> oh that's what parcs` was saying
12:08:15 <Lorehead> Numbers divisible by both are those divisible by 15.
12:09:02 <iisjmii> those are those mistakes I was afraid to make
12:09:05 <Lorehead> Furthermore, the sum of {3, 6, 9, ... n} is 3 times the sum {1, 2, 3, ..., n/3}.
12:09:17 <Lorehead> For which you can use Gauss closed-form formula.
12:09:44 <Lorehead> And get the answer in O(1) time using O(1) memory.
12:10:02 <Lorehead> Likewise for 5 and 15.
12:10:03 <mn90018> what is wrong with this? newtype Interval a a = Interval { getInterval :: (a,a) }
12:10:19 <rwbarton> "newtype Interval a a"
12:10:22 <hpc> newtype Interval a = Interval {getInterval :: (a, a)}
12:10:23 <parcs`> you have two type parameters of the same name
12:10:27 <iisjmii> I didn't know about that formula, I'll musr read in to it.
12:11:52 <adnauseam> which vim plugins do you guys reccomend ?
12:11:54 <adnauseam> recommend*
12:11:57 <Lorehead> See here: http://mathworld.wolfram.com/ArithmeticSeries.html
12:12:28 <Botje> adnauseam: I don't use any special plugins for haskell.
12:12:42 <mn90018> hpc: but i wish to use two variables that are the same type
12:12:55 <Botje> I do use surround.vim though
12:13:05 <mn90018> that goes through the compiler, but the my instance functor (Interval a) does not...
12:13:20 <hpc> instance Functor Interval where ...
12:13:55 <mn90018> okay thanks.. was just trying the follow the learn you a haskell book
12:13:57 <adnauseam> botje ; full monty no-plugin programming ? :o
12:14:09 <adnauseam> no auto complete? indentation ?
12:14:16 <Botje> those aren't plugins
12:14:28 <adnauseam> im not a vim expert
12:14:30 <iisjmii> Your Lorehead: multipleOf functions is indeed much simpler as mine. I wonder why I didn't think about it.
12:14:32 <adnauseam> =p
12:14:38 <adnauseam> i'll rephrase
12:14:44 <hpc> mn90018: "instance Functor foo" -- foo is a thing that takes a type and makes a type
12:14:44 <rzys> adnauseam, plugins for haskell or for general programming?
12:14:53 <adnauseam> how your vim setup for programming haskell looklike ? ;p
12:14:56 <iisjmii> Thanks very much, it all makes sense.
12:15:00 <hpc> "newtype Interval a = ..." -- Interval takes a type 'a' and makes a type "interval a"
12:15:08 <Eduard_Munteanu> Hmm... can you actually get an adjunction from a Kleisli construction on a monad without knowing the comonad?
12:15:08 <hpc> so Interval is what you give for "foo"
12:15:10 <adnauseam> both actually, i;'m trying to setup Vim, i've been using it for two months now
12:15:37 <Eduard_Munteanu> Assuming F -| U, I wonder how one goes about writing the counit of the adjunction.
12:15:47 <Botje> adnauseam: are you using text objects yet?
12:15:49 <adnauseam> it would be nice if you recommende a couple of plugins/anything else that imrpoves the overall editing experiencde
12:15:53 <adnauseam> no
12:15:56 <adnauseam> :o
12:16:05 <Botje> they're built in to vim. learn them. live them. love them.
12:16:13 <hiptobecubic> adnauseam, are you not using the arrow keys yet?
12:16:23 <adnauseam> i use hjkl :o
12:16:30 <Botje> how many times? :)
12:16:33 <adnauseam> damnit dont make funny of me ;p
12:16:34 <Eduard_Munteanu> Hm, wait... maybe my types are wrong.
12:16:36 <adnauseam> all the time
12:16:42 <adnauseam> fun*
12:16:43 <Botje> (okay, maybe we should switch to another channel)
12:16:53 <hpc> Botje: text objects?
12:17:13 <rzys> adnauseam, fuzzy finder, minibufexplorer, surround, snipmate, autoclose by thiago alves (there are two), easytags
12:17:24 <kallisti> I knew something bad was  going to happen when I said "I can solve this problem with a typeclass!"
12:17:35 * adnauseam amkes notes 
12:17:38 <adnauseam> i get
12:17:52 <Botje> hpc: step inside a (block like this) and hit 'cib'
12:18:10 <hiptobecubic> adnauseam, ghc-mod + neco + neocomplcache is pretty necessary I think.
12:18:13 <hpc> Botje: hotdamn
12:18:15 <merijn> kallisti: Whenever I say that I end up learning a lot about type theory and GHC, but invariably still do it the "ugly way" at the end...
12:18:27 <Botje> hpc: more goodness at :he text-objects (iirc)
12:18:30 <rzys> adnauseam, search for them on vim.org, they should be all there! oh and don't forget to download the colorscheme "mustang2" <3
12:18:39 <hiptobecubic> I also use a Hoogle plugin which helps sometimes, although really someone needs to make a plugin for lambdabot
12:18:57 <adnauseam> most excellent :o
12:19:14 <wires> Hello, a question about monads. in order to define [join :: m (m a) -> m a] on can say join = (>>= id)
12:19:35 <wires> but [flip >>=] has type (a -> m b) -> m a -> m b
12:19:55 <parcs`> :t (flip >>=)
12:19:55 <lambdabot> forall (f :: * -> *) a b b1. (Functor f) => ((a -> f b) -> f (a -> b) -> b1) -> f (a -> b) -> b1
12:20:10 <ment> is there a way how to define something from within hugs repl (like define x to be something read from a file)
12:20:17 <wires> why does flip >>= id typecheck, since id :: a -> a not id :: a -> m b
12:20:33 <adnauseam> rzys: i use nightelf :p i'll give mustang2 a try! does it work well with terminal vim? i dont run gvim
12:20:36 <hpc> wires: id :: a -> a
12:20:41 <hpaste_> rzys pasted “vimrc” at http://hpaste.org/67549
12:20:50 <parcs`> wires: id causes 'a' and 'm b' to unify
12:20:52 <Botje> ment: in GHCi you can do "let f x = x + 1"
12:20:56 <hpc> er, that
12:21:01 * hpc was going to do that long version
12:21:07 <wires> hpc, i guess i'm being somehow stupid.. so m in this case is id
12:21:11 <hpc> wires: let 'a' = 'm b'
12:21:14 <Botje> ment: not sure about hugs. but then again you should seriously consider switching to GHCi, it's more modern.
12:21:17 <rzys> ^^ my vimrc, no sadly it only works in gvim
12:21:17 <hpc> id :: m b -> m b
12:21:24 <hpc> (>>= id) :: m (m b) -> m b
12:21:24 <wires> ahhh
12:21:26 <wires> jezus
12:21:29 <wires> sorry
12:21:33 <wires> haha :)
12:21:34 <hpc> :t (>>= ?id)
12:21:35 <lambdabot> forall (m :: * -> *) a b. (?id::a -> m b, Monad m) => m a -> m b
12:22:21 <wires> ^^ what does that do?
12:22:34 <ment> Botje: hmm doesn't work in hugs but ghci looks interesting
12:22:35 <wires> the ?id
12:22:38 <hpc> it's just fanciness in showing types
12:22:56 <ment> Botje: however i use hugs because it runs everywhere (plan 9/linux/windows) and i don't care about performance anyway
12:22:57 <hpc> it more or less says "show me the type of this too"
12:23:09 <wires> right, i see now,.. thanks
12:23:15 <hpc> it's implicit parameters though, so it's not the actual 'id' it's using
12:23:17 <rzys> adnauseam, oh and don't forget to install the plugin pathogen. with pathogen you can manage your plugins much more easily and your .vim directory won't get messy :)
12:23:20 <Botje> ment: GHCi also has nicer error messages. I don't know about plan9 but it works in the other two.
12:23:21 <hpc> :t ?this_isn't_defined
12:23:22 <lambdabot> forall t. (?this_isn't_defined::t) => t
12:23:34 <ment> Botje: i'll look into it, thanks
12:24:00 <wires> hpc,parcs` thanks
12:24:04 <Botje> rzys: you should probably guard those iabbrs with an autogroup.
12:24:31 <wires> :t ?id
12:24:32 <lambdabot> forall t. (?id::t) => t
12:24:57 <adnauseam> rzys: i tried  pathogen.. i must say that i hae no idea how it works, evenafter following the howtos, setting it up and all. i think i just have too few plugins installed to really find it pathogen useful
12:24:58 <wires> i was kind of expecting, forall t. id :: t -> t
12:25:11 <rzys> Botje, ah thanks. i think i can delete them anyway since i never use them :)
12:25:17 <Botje> thought so :P
12:25:45 <adnauseam> is there a good haskell-auto-completer for vim ?
12:25:51 <wires> :t (+ ?x)
12:25:51 <lambdabot> forall a. (?x::a, Num a) => a -> a
12:27:00 <rzys> adnauseam, basically you just have to put pathogen.vim in .vim/autoload and start your .vimrc with      call pathogen#infect('bundle')        then you can throw all your plugins and their quadrillion subdirectories in .vim/bundle. trust me, once you get addicted to trying various plugins you'll be happy about it :)
12:28:05 <adnauseam> mhm, you do have a point. i'veactually experienced that once already and "broke" vim. fixed by deleting everything =P i'll setup pathogen correctly this time then
12:29:46 <merijn> And then after a few months you realise you're mostly wasting your time and the plugins aren't available on most systems you work on and you go back to a single .vimrc and 1 or 2 plugins ;p
12:30:04 <hpaste_> mn90018 pasted “Interval ” at http://hpaste.org/67553
12:30:16 <mn90018> what is wrong with that paste?
12:30:49 <mn90018> learn you a haskell says I should do instance Functor (Interval c) where...
12:30:50 <Rakin05> andauseam: ever thought about emacs?
12:30:52 <rwbarton> what makes you think there is something wrong?
12:30:57 <mn90018> but doesn't help me at all..
12:31:36 <merijn> mn90018: You can't patternmatch like that on record syntax, I think. Did you try calling "getInterval" to get the tuple and go from there?
12:32:06 <hpc> merijn: you can
12:32:08 <hpc> it should work
12:32:09 <shachaf> merijn: Sure you can.
12:32:25 <hpc> compiles for me
12:32:29 <mn90018> well basically the following should work after my paste: fmap (+1) Interval (1,2)
12:32:40 <rwbarton> no
12:32:40 <mn90018> but it doesn't..
12:32:46 <hpc> fmap (+1) (Interval (1,2))
12:32:50 <Botje> mn90018: that applies three arguments to fmap.
12:32:50 <merijn> shachaf: So you can just pattern match on record syntax? neat
12:32:54 <Botje> you want what hpc said
12:33:02 <mn90018> oh man! :D
12:33:10 <mn90018> feeling kind of stupid now..
12:33:24 <mn90018> the error was not clear (in my defence)
12:33:40 <rwbarton> it helps to actually provide us with the code that has the error
12:33:43 <rwbarton> as well as the error itself
12:33:56 <lysgaard> I have a monad I want to extend with mutable state, a-la the State monad.
12:34:17 <rwbarton> ghc error messages do take some getting used to, but they are quite helpful once you are accustomed to them
12:34:20 <hpc> State isn't mutable state
12:34:54 <lysgaard> hpc: You're right. I just want to add the functionallity of the State monad to the existing monad.
12:35:19 <hpc> lysgaard: what's your monad?
12:35:28 <hpc> you can probably do StateT foo YourMonad
12:35:38 <hpc> or YourMonadT (State s)
12:36:11 <lysgaard> My monad is the Process Monad if the remote package. It's really complex and I don't know it's internals.
12:36:17 <hpc> ah
12:36:21 <hpc> StateT it is
12:36:32 <hpc> :t lift
12:36:32 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
12:36:42 <hpc> :t lift get
12:36:44 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadState a m, MonadTrans t) => t m a
12:36:55 <hpc> (etc, etc)
12:37:41 <shachaf> merijn: You can always pattern match like Interval { getInterval = x }, too.
12:37:59 <shachaf> merijn: There exist some records that you can't do anything *but* pattern-match on!
12:38:13 <shachaf> (They sort of have accessors but you can't actually use them because they can't be typed.)
12:39:55 <lysgaard> hpc: Would one lift the get and put ++ functions from StateT intoo the Process monad?
12:40:27 <rwbarton> you lift Process actions into StateT foo Process
12:40:33 <rwbarton> use get and put directly
12:41:32 <hpc> er wait, i have it backwards
12:41:40 <hpc> lysgaard: you lift the Process actions into StateT
12:41:52 <hpc> :t lift (putStrLn "like this, for IO")
12:41:53 <lambdabot> forall (t :: (* -> *) -> * -> *). (MonadTrans t) => t IO ()
12:42:23 <hpc> usually what people do is write stuff like
12:42:28 <hpc> bigProcessAction = lift $ do
12:42:30 <hpc>   ...
12:42:43 <hpc> and do that for a small set of "primitives"
12:42:47 <lysgaard> Ok. Is it usual to define a new "wrapper Monad" that hides all this lifting?
12:42:52 <hpc> and define the rest in terms of those and forget about lifting entirely
12:43:32 <hpc> lysgaard: as in newtype Wrapped a = Wrapped {runWrapped :: StateT S Process a}?
12:43:33 <hpc> no
12:44:38 <seanhess> What's the "right" way to specify cabal dependencies for my project? I can get them all working, but then if I try to upgrade a single package, everything starts to conflict with the dependencies of my dependencies
12:45:56 <hpc> seanhess: i write my depends without version constraints and just let it fail to install if something goes wrong
12:46:12 <rwbarton> lysgaard: it can be a good idea, if you expect that you might extend Wrapped with another transformer later
12:46:26 <seanhess> hpc: how do you fix it when something does go wrong?
12:46:26 <hpc> and then if there's a bug of some sort that i really don't want my package to encounter, then add a constraint
12:46:33 <statusfailed> hahah, I just accidentally tried to write a quine
12:46:54 <seanhess> for example, I'm using scotty http://hackage.haskell.org/package/scotty-0.4.0.
12:46:58 <statusfailed> I wrote a snippet to generate my .xmodmap file, and then thought "would it be nice if this program also output itself in the comments of that file so I knew what had generated it!"
12:47:13 <seanhess> I was using 0.2.0, which depended on warp 1.0.x
12:47:26 <statusfailed> not quite a quine, but still ^^
12:47:40 <seanhess> but when I upgraded to 0.4.0, everything went crazy because scotty depended on a certain version of conduit, but warp 1.0.x depended on another
12:47:48 <seanhess> I'm using "cabal install --only-dependencies"
12:47:55 <seanhess> it doesn't seem to upgrade them appropriately
12:48:51 <dcoutts> seanhess: it'll install deps appropriately for the thing you're trying to build, but probably not appropriately for other things you had installed already
12:48:53 <hpc> seanhess: cabal update; cabal install scotty --reinstall
12:49:06 <hpc> should install latest version that doesn't crap out on you, in theory
12:49:14 <captWheeto>  Is Real World Haskell meant to be read cover to cover, anyone?
12:49:21 <hpc> captWheeto: not really
12:49:27 <seanhess> would "cabal install --only-dependencies --reinstall" work?
12:49:28 <hpc> it's a bit out of date too
12:49:32 <captWheeto> Phew, I was feeling guilty
12:49:34 <seanhess> captWheeto: I wouldn't. It's too thick for that
12:49:45 <hpc> seanhess: no; scotty won't get installed
12:49:45 <seanhess> I'm new too, and writing my first complete programs without finishing it
12:49:49 <seanhess> LYAH is great though
12:50:08 <captWheeto> I've read LYAH and thought it was great. Then started on RWH and it didn't capture me at all
12:50:11 <hpc> captWheeto: RWH is very much a reference book with a bunch of "learn haskell" chapters at the start
12:50:13 <captWheeto> Thought I was doing something wrong
12:50:15 <seanhess> same
12:50:29 <hpc> seanhess: lemme try installing scotty
12:50:46 <dcoutts> seanhess: what goes wrong with cabal install --only-dependencies ?
12:50:47 <seanhess> hpc: I think it'll work fine. It's just *upgrading* that gets crazy
12:50:58 <hpc> seanhess: oh, i see what you mean now
12:51:00 <seanhess> dcoutts: it doesn't seem to upgrade the packages
12:51:06 <tdammers> another cabal question here
12:51:16 <Eduard_Munteanu> Hrm... I guess I need a functor between Categories.
12:51:17 <tdammers> suppose I have a library in ~/foo
12:51:24 <tdammers> cabalized and all, but no on hackage
12:51:37 <hpaste_> niez pasted “yesod installation problem” at http://hpaste.org/67554
12:51:38 <tdammers> and then another cabalized project in ~/bar that depends on foo
12:51:42 <Eduard_Munteanu> I guess Functor is only Hask -> Hask.
12:51:49 <dcoutts> seanhess: it doesn't try to use the latest versions if they're already installed, but it should give you versions that are consistent with the thing you're trying to build
12:51:55 <tdammers> how would I get cabal-dev to install foo as a dependency of bar?
12:52:09 <seanhess> dcoutts: I miss npm :) everything was local
12:52:31 <seanhess> got it. I'll try to be less picky in my cabal file
12:52:32 <lysgaard> hpc: Seems like I can't wrap the Process Monad in StateT, cause the only way to do something usefull with Process is using: runProcess :: Process a -> IO a
12:52:37 <lysgaard> Am I outta luck?
12:52:48 <jfischoff> Eduard_Munteanu: yeah Functor is an endofunctor in the category of Hask
12:52:59 <dcoutts> seanhess: but you can ask it to upgrade specific deps, just ask to install them, but ask for all of them in one go so it'll pick their deps consistently
12:53:43 <seanhess> dcoutts: I don't understand. How would I ask it to upgrade specific deps. Do you mean typing "cabal install x --reinstall"? Or is there something I should do in my .cabal file
12:54:07 <dcoutts> seanhess: I'm still not sure if I get what the problem is, can you actually configure the package you're interested in?
12:54:33 <dcoutts> cabal install --only-dependencies  should mean that you can then cabal configure
12:54:39 <hpc> lysgaard: you mean there's no (stuff -> Process a) actions at all?
12:55:03 <seanhess> The problem is that if I want to upgrade scotty from 0.2.0 to 0.4.0, I have to change my .cabal file to also require the versions of wai and warp that scotty requires, or it doesn't install. Even though my package doesn't actuall require those versions of wai and warp
12:55:17 <hpc> seanhess: it might require ghc 7.4.1
12:55:20 <hpc> and just not mention it
12:55:29 <c_wraith> which morphism is map?
12:55:36 <seanhess> hpc: I'm updating to 7.4.1 now (from 7.2.2)
12:56:19 <dcoutts> seanhess: do you mean that cabal install reports a dependency problem and doesn't get to the stage of actually building anything?
12:56:22 <niez> it's the first time when i'm using cabal, and I'm getting errors: http://hpaste.org/67554 any suggestions for newcomer?
12:56:28 <c_wraith> ah, it's a homomorphism
12:56:50 <seanhess> exactly.
12:57:07 <dcoutts> seanhess: in principle you're doing the right thing, you should not need to adjust your wai & warp deps if your package would still work with the older ones, the solver should just work it out
12:57:24 <geekosaur> niez, what version of ghc do you have installed?
12:57:25 <dcoutts> seanhess: ok, my suggestion is to try cabal-install-0.14, it's got the new solver
12:57:29 <niez> this reminds me dependency hell in gentoo
12:57:57 <seanhess> great
12:57:58 <lysgaard> hpc: Yeah there are. But to use the Process monad my main would look like this: main = runProcess action
12:58:01 <niez> geekosaur, The Glorious Glasgow Haskell Compilation System, version 6.12.3
12:58:08 <seanhess> Best way to install is cabal install cabal cabal-install ?
12:58:12 <hpc> gentoo: the only distro where "configure build install" turns into "configure configure configure configure build configure configure build configure install configure build install"
12:58:14 <seanhess> I'm getting dependency conflicts on that too :)
12:58:37 <Botje> hpc: you missed out "screw up system due to wonky dependency on unstable package"
12:58:38 <dcoutts> seanhess: you need cabal install 'cabal-install >= 0.14' since it's not the default version yet
12:58:43 <seanhess> ah
12:58:51 <lysgaard> hpc: Now, I don't see how I would get action to have a state, cause that would change it's type and runProcess can only run things of type Process a -> IO a
12:59:05 <hpc> lysgaard: change your main to look like runProcess (execStateT action initialState)
12:59:08 <hpc> or something like that
12:59:14 <Eduard_Munteanu> I guess I want... class (Category c) => GFunctor c f where gfmap :: c a b -> c (f a) (f b)
12:59:16 <hpc> :t execStateT
12:59:17 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m s
12:59:22 <hpc> :t evalStateT
12:59:23 <lambdabot> forall s (m :: * -> *) a. (Monad m) => StateT s m a -> s -> m a
12:59:27 <hpc> use evalStateT
12:59:33 <geekosaur> unsatisfied base dependency secretly means wrong ghc version, since it's wired into the compiler (which is also why the unfortunate messages about base -any)
12:59:40 <geekosaur> and 6.12.3 is too old for yesod
12:59:43 <hpc> you have to run the "outer" monad to get a thing of the "inner"
12:59:43 <dcoutts> niez: yes, yesod wants a later ghc, the error message really means that it needs a later version of base, and base can only be upgraded with ghc itself not separately
12:59:44 <Eduard_Munteanu> And I'll use Kleisli for 'c' in my case... I hope that does it.
13:00:36 <lysgaard> hpc: Yeah, that would work! Thanks =)
13:01:00 <dcoutts> tdammers: cabal install ./foo ./bar  -- it'll work out the dependencies
13:01:06 <hpc> lysgaard: for extra credit, that "run from the outside in" is the reason you will never find an IO transformer
13:01:17 <hpc> @hoogle IO a -> a
13:01:17 <lambdabot> Foreign.Marshal unsafeLocalState :: IO a -> a
13:01:18 <lambdabot> System.IO.Unsafe unsafePerformIO :: IO a -> a
13:01:18 <lambdabot> Foreign unsafePerformIO :: IO a -> a
13:01:18 <tdammers> dcoutts: thanks, I'll try that
13:01:36 <dcoutts> tdammers: and --dry-run is handy
13:02:18 <niez> ok, any hints how to upgrade ghc in ubuntu 10.04 lts?
13:02:52 <Lorehead> niez: The latest Ubuntu beta has GHC 7.4.1.
13:02:53 <lysgaard> hpc: Makes sense, cool
13:02:54 <tdammers> hold on, will that work with cabal-dev, or do I have to go with cabal proper?
13:03:20 <dcoutts> niez: if you cannot find a ubuntu package you'd need to get a binary package from the ghc site and install it in /usr/local
13:03:32 <hpc> @where ghc
13:03:33 <lambdabot> http://haskell.org/ghc
13:03:39 <dcoutts> tdammers: I presume it'd work with cabal-dev too, it's a wrapper for cabal
13:03:40 <seanhess> Speaking of cabal-dev, has the community settled on a local dependency cabal alternative yet? Is it cabal-dev?
13:03:46 <Lorehead> iisjmii: Went ahead and wrote my own Haskell solution for Project Euler problem 1.
13:03:59 <tdammers> even if foo and bar are in different sandboxes?
13:04:05 <Lorehead> http://pastebin.com/q3gVLVuV
13:04:07 <dcoutts> seanhess: it's not bad in the meantime, but the plan is to do it properly and more generally
13:04:08 <mauke> The paste q3gVLVuV has been copied to http://hpaste.org/67555
13:04:36 <dcoutts> tdammers: oh I don't think cabal-dev makes it easy to move things between sandboxes, they have to be in the same one
13:04:41 <seanhess> dcoutts: thanks. cabal-dev is the best of the current options though?
13:04:56 <dcoutts> seanhess: well they each do different things, so it depends what you want to do
13:05:29 <seanhess> I'm writing an application. I just want to manage my dependencies easily, without conflicts, and deploy to a ubuntu server and have it just work
13:05:40 <seanhess> Not sure if that's one of the use cases :)
13:05:55 <tdammers> dcoutts: heh, actuall cd ./bar && cabal-dev install ../foo does the trick
13:06:06 <tdammers> actuall*y*
13:06:14 <seanhess> But I LOVE how http://npmjs.org/ (node.js) installs everything locally. The dependencies of your dependencies are sandboxed
13:06:23 * dcoutts was writing up design notes for cabal and package environments at the hackathon this weekend
13:06:24 <dcoutts> http://hackage.haskell.org/trac/hackage/wiki/PackageEnvironments
13:07:25 <dcoutts> seanhess: sounds like cabal-dev is the closest fit for now
13:09:33 * hackagebot HaskellForMaths 0.4.5 - Combinatorics, group theory, commutative algebra, non-commutative algebra  http://hackage.haskell.org/package/HaskellForMaths-0.4.5 (DavidAmos)
13:17:55 <seanhess> to start using cabal-dev, do I need to remove all the packages from the system database?
13:18:10 <luite> no
13:18:16 <luite> it automatically hides that
13:18:51 <dcoutts> seanhess: my understanding is that the global package db is visible in the cabal-dev sandbox
13:18:51 <wires> seanhess, virthualenv is probably quick hacky, but I've had much more success with it than cabal-dev
13:18:59 <wires> s/quick/quite/
13:19:03 <dcoutts> since that's where the rts and base packages live
13:19:32 <dcoutts> and the cabal-dev docs say you should keep the global db for system packages, by which it means ghc core libs
13:19:54 <seanhess> Yeah, that's the part I'm reading. Made me think I needed to uninstall my stuff from the global db
13:20:16 <dcoutts> luite: sadly hiding the global db is not really possible (except using a GHC_PACKAGE_PATH env hack, but I don't think cabal-dev uses that)
13:20:20 <luite> oh hm, it does enable the pacakge config, but it hides all packages
13:20:26 <dcoutts> seanhess: probably so
13:20:28 <luite> enables the configured package id's
13:20:42 <luite> +global
13:21:11 <luite> dcoutts: ah
13:21:32 <dzhus> why there's no standard (<<)?
13:21:41 <dcoutts> luite: right, Cabal always hides all packages and selects only the ones needed
13:21:52 <seanhess> I think I'll wait on cabal-dev. I'll be on a plane soon and want to be able to work
13:22:46 <seanhess> I just upgraded to cabal 1.14, and "cabal install --only-dependencies" in my app folder says "HTTP-4000.2.3" will likely be broken, should I force reinstalls? (I don't know what that http package is)
13:23:26 <dcoutts> seanhess: if you don't recognise or care about the broken ones it's probably ok, if it looks like a core package then don't do it
13:23:32 <seanhess> ok
13:23:42 <luite> HTTP is not a core one, but cabal-install uses it
13:24:01 <dcoutts> seanhess: cabal handles broken packages by ignoring them, so it's easy enough to install them again later if anything needs it
13:24:08 <seanhess> cool.
13:24:43 <luite> i'm really happy that a recent cabal-install is now on hackage btw :)
13:24:45 <dcoutts> seanhess: handy thing before jumping on a place is to use "cabal fetch"
13:24:56 <seanhess> what does that do?
13:25:29 <dcoutts> seanhess: like install, but just makes sure the sources are downloaded
13:25:41 <dcoutts> e.g. cabal fetch yesod-platform
13:26:11 <luite> you can also wget all archives first, only 20000 files or so ;)
13:26:14 <dcoutts> means you'll be able to cabal install yesod-platform when offline
13:26:24 <seanhess> oh, super cool
13:30:20 <jfischoff> has anyone used Lennart's traced package? http://hackage.haskell.org/package/traced
13:30:27 <Eduard_Munteanu> Dang, I need to parametrize by a second category.
13:33:04 <jfischoff> Eduard_Munteanu: you might find this helpful http://www.cl.cam.ac.uk/~dao29/drafts/subcategories-in-haskell-dorchard11.pdf
13:33:25 <jfischoff> and http://dorchard.wordpress.com/2011/10/18/subcategories-in-haskell-exofunctors/
13:34:40 <Eduard_Munteanu> Thanks, I'll have a look.
13:34:59 * Eduard_Munteanu is trying to get adjunctions from monads via the Kleisli construction
13:35:53 <jeff_s_> Does anyone have a recommendation as to which JSON package I should try next? I used Aeson initially due to its promise of speed, but now I'm seeing that the json, json2, an d json-b packages use Rational, which is much better for use with JSON numbers. There are even more JSON libraries I haven't looked at.
13:36:19 <jfischoff> jeff_s_: Aeson
13:36:38 <jeff_s_> jfischoff, I meant other than Aeson. :)
13:36:47 <jfischoff> hehe
13:40:14 <seanhess> dcoutts: everything working nicely after ghc 7.4.1 and cabal 1.14. Thanks for your help
13:43:40 <dzhus> 1. How to express (>>) with (>>=)?
13:43:48 <copumpkin> use const
13:43:58 <copumpkin> x >> y = x >>= const y
13:44:58 <dzhus> ok, now 2. Is there a name for (f ??? g) = (\x -> f x >> g)? (Like Kleisli composition but with discarding)
13:45:26 <Botje> @pl \f g -> \x -> f x >> g
13:45:27 <lambdabot> flip . ((>>) .)
13:45:30 <Botje> ew.
13:45:42 <Botje> @pl \x -> f x >> g
13:45:42 <lambdabot> (>> g) . f
13:45:51 <acowley> I would say the name is still Kleisli composition.
13:46:29 <dzhus> acowley: yes, looks like it's still composition but after just applying const to second argument
13:51:14 <Alan> hmmm, i feel like i'm missing something ... i've got a recurring pattern of do { a <- foo ; bar ; return a }
13:51:29 <Botje> foo <* bar
13:51:40 <ktosiek> Botje: *_*
13:51:52 <ktosiek> my Parsec code will get sooo clearer now
13:51:58 <Alan> Botje: :D
13:52:03 <Alan> thank you
13:52:11 <Alan> i hoped that if i asked here somebody would recognise the pattern
13:52:26 <jfischoff> ditto
13:52:28 <Botje> Alan: #haskell is almost as good at lambdabot at spotting such patterns :)
13:52:28 <ktosiek> but where <* lives?
13:52:34 <Botje> Control.Applicative iirc
13:52:38 <Botje> @hoogle (<*)
13:52:38 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
13:52:39 <lambdabot> Control.Applicative (<**>) :: Applicative f => f a -> f (a -> b) -> f b
13:52:39 <lambdabot> Control.Applicative (<*>) :: Applicative f => f (a -> b) -> f a -> f b
13:52:57 <Alan> i would have asked lambdabot if i had the brainpower to figure out the type :P
13:53:33 <Botje> I think \bot would've given you <<
13:53:48 <Alan> oh look, i already have control.applicative imported
13:54:08 <bitonic> @undo do { a <- foo ; bar ; return a }
13:54:08 <lambdabot> foo >>= \ a -> bar >> return a
13:54:16 <bitonic> @pl foo >>= \ a -> bar >> return a
13:54:17 <lambdabot> (bar >>) . return =<< foo
13:54:19 <bitonic> damnit
13:54:27 <Alan> @hoogle Applicative f => f a -> f b -> f a
13:54:28 <lambdabot> Control.Applicative (<*) :: Applicative f => f a -> f b -> f a
13:54:28 <lambdabot> Control.Applicative (*>) :: Applicative f => f a -> f b -> f b
13:54:28 <lambdabot> Control.Applicative liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c
13:54:36 <Alan> haha, not specific enough
13:54:39 <bitonic> technically you can't just put a *> there, because Monad does not imply Applicative
13:54:43 <Alan> but now i get it :D
13:54:54 <Alan> it doesn't?
13:55:15 <Botje> well, no
13:55:21 <Botje> but odds are the specific monad you're using does.
13:55:33 <Alan> yeah, fair enough
13:55:48 <Alan> ah, i see
13:55:56 <Alan> i just looked up what Applicative defines
13:56:59 <Alan> so is >> equivalent to *> then? except that *> is defined on Applicative and >> on Monad?
13:57:30 <Botje> > [1,2] *> [3,4]
13:57:31 <lambdabot>   [3,4,3,4]
13:57:40 <Botje> looks like it.
13:58:06 <Alan> but there's no equivalent of <* on Monad?
13:58:49 <hpc> Alan: no
13:59:07 <hpc> it's not clear if (<<) should be (<*) or (flip (>>))
13:59:53 <Alan> I see - (<<) = flip (>>) would evaluate the 2nd before the 1st?
14:00:07 <Alan> whereas <* still evaluates the first then the second?
14:00:50 <adnauseam> rzys: dude, about pathogen, does each "plugin" need to have its own dir under /autoload ?
14:05:45 <rzys> adnauseam, you should throw all plugins in a dir .vim/bundle
14:05:56 <rzys> adnauseam, only pathogen.vim needs to be in autoload
14:07:50 <rzys> bundle is just the default name for the directory which pathogen scans when you call pathogen#infect() from your vimrc
14:07:51 <adnauseam> rzys: does that mean just unzip/unload them into bundle, or create a directory for each one ?
14:08:17 <rzys> doesn't really matter, i have some in there which are just plan .vim files
14:08:29 <rzys> others are whole directory structures with their subdirs etc.
14:09:15 <rzys> but they have to be unzipped
14:09:35 <adnauseam> alright, i did that, now lets try
14:24:52 * EvanR gets confused by syntax...
14:25:02 <EvanR> i see this in a do block
14:25:05 <EvanR> FastCGIState { request = Just request } <- getFastCGIState
14:25:09 <EvanR> o_O
14:25:29 <augur> EvanR: whats the problem now?
14:25:42 <EvanR> uhm, what does that mean
14:25:46 <bitonic> EvanR: that's pattern matching on record
14:25:54 <bitonic> it's extracting the 'request' field
14:25:55 <augur> indeed
14:25:57 <augur> EvanR: consider:
14:26:04 <bitonic> and an usual patterm matching on Just
14:26:07 <augur> data Foo = Foo { x :: a, y :: b }
14:26:13 <bitonic> and binding a variable named 'request'
14:26:20 <augur> this is sort of like data Foo = Foo a b
14:26:41 <EvanR> ok so its like [(x,_)] <- foo
14:26:45 <augur> except the order of the a and b elements are sort of .. ignored (tho really you can still match as if it were Foo a b because it is)
14:26:51 <EvanR> sets x
14:26:58 <EvanR> or fails
14:27:14 <augur> but what you're doing iwhen you do the first one is you're defining some field names which, at top level, get bound to accessor methods
14:27:24 <augur> but in record contexts they refer to the slots
14:27:45 <augur> so FastCGIState { request = Just request } <- getFastCGIState
14:27:49 <augur> is the same as
14:28:04 <augur> FastCGIState _ _ (Just request) _ _ <- getFastCGIState
14:28:04 <EvanR> pattern match on record using update syntax is standard?
14:28:07 <EvanR> or an extension
14:28:20 <augur> its standard afaik
14:28:24 <augur> but its not really update syntax
14:28:30 <EvanR> it looks like update syntax
14:28:38 <augur> it also looks like definition syntax
14:28:47 <bitonic> it's standard
14:28:48 <augur> all you're doing is omitting irrelevant fields
14:28:49 <augur> i mean
14:28:50 <augur> why do
14:28:58 <EvanR> yeah yeah
14:29:04 <augur> Foo { x = _, y = y }
14:29:12 <augur> when you can just do Foo { y = y }
14:29:39 <EvanR> or foo { x = x foo, y = y' }
14:30:10 <EvanR> and i thought i knew everything ;)
14:30:13 <augur> im not sure what thats suppose to mean
14:30:34 <EvanR> maybe i dont remember update syntax
14:34:27 <Bytter> Does someone reccomend a nice, introductory book on equational reasoning with haskell? I'm trying to follow "Pearls of Functional Algorithm Design" but I find myself blocking at (supposedly) basic things.
14:35:22 <augur> Bytter: im not sure i have a good reference for you, but you might want practice points-free-ifying things
14:36:02 <augur> i mean, there are some algebra-of-programming things that i guess i could point you to. they're not specifically about haskell
14:36:16 <augur> but they might suffice
14:36:23 <c_wraith> Ugh.  associated type families aren't really nicely compatible with the Show hack.  Why can't String have been a real type?
14:37:26 <EvanR> String a new type, wouldnt it be hard to treat it as just a list ;)
14:37:46 <Bytter> augur: ok
14:45:06 <monochrom> talking about "richard bird": http://www.amazon.com/How-Grow-Squashes-Pumpkins-practical/dp/1844765660/
14:45:24 <monochrom> copumpkin will like to know that a "richard bird" likes pumpkins!
14:45:26 <augur> Bytter: An Introduction to the Bird-Meertens Formalism - Gibbons
14:45:31 <copumpkin> yay
14:45:37 <augur> thats one that introduces the typical formalism
14:45:45 <augur> but its a bit dense and inscrutible in many ways
14:45:59 <Bytter> augur: i'll take a look at that one
14:46:28 <augur> Bytter: try startng with chapter 5 of Algebraic and Coalgebraic Methods in the Mathematics of Program Construction - Backhouse, Crole, and Gibbons
14:46:53 <augur> also known as CalcFP
14:46:55 <augur> @where calcfp
14:46:56 <lambdabot> I know nothing about calcfp.
14:46:58 <augur> :(
14:47:55 <augur> http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/acmmpc-calcfp.pdf
14:48:06 <augur> copumpkin: how do i make lambdabot remember something
14:48:22 <copumpkin> you use @where+
14:49:12 <augur> copumpkin: syntax?
14:49:36 <copumpkin> @where+ howtousewhere+ you type @where+ name fact and other stuff
14:49:36 <lambdabot> I will remember.
14:49:43 <copumpkin> @where howtousewhere+
14:49:43 <lambdabot> you type @where+ name fact and other stuff
14:49:49 <augur> lolol
14:49:54 <augur> @where+ calcfp http://www.cs.ox.ac.uk/people/jeremy.gibbons/publications/acmmpc-calcfp.pdf
14:49:54 <lambdabot> I will never forget.
14:49:55 <monochrom> that is so meta
14:50:22 * monochrom sends copumpkin an email on how to read emails
14:50:32 <augur> copumpkin: do you happen to have any interest in chatbots and/or intelligent agents?
14:50:41 <copumpkin> thanks! I've been wondering about how to read them for a while now
14:50:55 <copumpkin> augur: not in particular, over the baseline
14:51:09 <EvanR> how to read a book
14:51:22 <monochrom> also some jokes about some sysadmins suggesting "if your email software has problems, send me an email"
14:51:38 <EvanR> lol
14:52:01 <augur> EvanR: http://www.amazon.com/How-Read-Book-Touchstone-book/dp/0671212095/ref=sr_1_1?ie=UTF8&qid=1335304290&sr=8-1
14:52:32 <EvanR> augur: yep
14:52:33 <EvanR> classic
14:53:12 <copumpkin> :t newListArray ((1,m),(1,m)) ([((i,j), if i == j then 1.0 else 0.0) | i <- [1..m], j <- [1..m]] :: [((Int,Int), Double)])
14:53:12 <lambdabot> Not in scope: `newListArray'
14:53:23 <augur> EvanR: calcfp is probably the best place to start
14:53:31 <monochrom> listArray
14:53:36 <augur> just, re-emphasizing this
14:53:54 <copumpkin> apparently newListArray exists too
14:53:54 <copumpkin> newListArray :: (MArray a e m, Ix i) => (i, i) -> [e] -> m (a i e)	
14:53:58 <augur> brb
14:54:06 <monochrom> ah, lambdabot probably doesn't have it
14:56:35 <EvanR> the documentation for mysql-simple says in fold... the result consumer is responsible for evaluating its result to avoid space leaks, because 'its not strict'
14:56:43 <EvanR> so at this point i guess i cant ignore the lazy/strict thing
14:56:47 <EvanR> and i need to learn something
14:57:22 <EvanR> result consumer needs to do something special, or is it normally ok
14:57:34 <monochrom> http://www.vex.net/~trebla/haskell/lazy.xhtml
14:58:03 <EvanR> nice
15:03:33 <gwern> does anyone know where the full GSoC propoals are? I cant find like half of them, eg "Sandboxed builds and isolated environments for Cabal"
15:04:34 <edwardk> gwern: had you signed up as a mentor this year you could have seen the whole proposal while they were still being voted on =P
15:04:53 <gwern> edwardk: but would I be able to link them from my page? I think not
15:04:54 <dcoutts_> gwern: some are available from the gsoc site, but some are apparently private, I don't know why some are public and some not
15:05:09 <gwern> dcoutts_: that's lame
15:05:21 <edwardk> let me see if i can flag them public or not
15:05:48 <dcoutts_> edwardk: if we can, the ones that were accepted ought to be public I think
15:05:59 <edwardk> sure
15:06:24 <edwardk> looks like we can't
15:06:51 <edwardk> it was probably a flag when the student created it or some other melange-related nonsense
15:06:56 <dcoutts_> edwardk: do we know what determines that status?
15:06:58 <dcoutts_> hmm
15:07:20 <dcoutts_> perhaps we can get the students to do it?
15:07:39 <dcoutts_> it would be useful to be able to point to the accepted proposals
15:07:43 <edwardk> i'm not sure there is a flag at all
15:07:55 <edwardk> all i can find are the public abstracts
15:08:00 <gwern> edwardk: did any voters register their predictions of success?
15:08:17 <edwardk> gwern: not on a rigorous project by project basis
15:08:24 * gwern thought so
15:08:49 <EvanR> monochrom: so, there are pitfalls when trying to explicitly sum or average stuff, but youre ok if you use the standard library?
15:08:51 * copumpkin thought gwern would think so
15:09:09 <gwern> "Haskell-Type-Exts" is weird... isn't that already done
15:09:13 <EvanR> i guess theres pitfalls trying everything
15:09:15 <edwardk> we're limited to accepting proposals we receive, to work on stuff that we have mentors available to work on. its not like we have complete freedom
15:09:21 <EvanR> since theres no always a library implementation
15:09:23 <copumpkin> gwern: where?
15:09:37 * hackagebot bytestring-progress 1.0.2 - A library for tracking the consumption of a lazy ByteString  http://hackage.haskell.org/package/bytestring-progress-1.0.2 (AdamWick)
15:09:50 <gwern> copumpkin: http://hackage.haskell.org/package/haskell-type-exts
15:10:05 <dcoutts_> and we often have to take a gamble on students, we don't know them all beforehand and it'd be little unfair if we did only work with students we already knew well
15:10:19 <gwern> hm, I guess the idea is to expand it
15:10:24 <edwardk> the proposal included a number of distinct improvements to it
15:10:40 <gwern> it would be easier to understand it if the haskell-type-exts proposal was public...
15:10:42 <edwardk> notably haskell 2010 support rank n types, switching to explicit substitutuions, etc.
15:11:20 <gwern> looks like there's exactly 4 porposals public: https://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/bsrkaditya/14002 https://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/lorehead/1 https://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/phischu/1 https://www.google-melange.com/gsoc/proposal/review/google/gsoc2012/shapr/1
15:11:35 <monochrom> the standard library still explicitly sums, it just adds a "seq" at the right place, which I haven't covered yet and I call it "magic" at the moment
15:11:36 <monochrom> IOW foldl'
15:11:36 <monochrom> actually maybe lambdabot has it
15:11:36 <monochrom> @src foldl'
15:11:36 <lambdabot> foldl' f a []     = a
15:11:36 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
15:12:00 <copumpkin> gwern: then ask on the gsoc IRC channel how others can be made public?
15:12:04 <monochrom> as for average, you are just not supposed to use "sum xs / length xs". nothing can improve it. use another algorithm
15:13:32 <EvanR> @src avg
15:13:32 <lambdabot> Source not found. I've seen penguins that can type better than that.
15:13:35 <EvanR> @src average
15:13:35 <lambdabot> Source not found. :(
15:13:39 <EvanR> monochrom: meh
15:14:00 <EvanR> what about calculating sum and length at the same time
15:14:10 <EvanR> then dividing
15:14:11 <monochrom> yes, do that
15:14:19 <EvanR> ok so thats a library waiting to happen
15:14:37 * hackagebot HandsomeSoup 0.1 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.1 (AdityaBhargava)
15:15:19 * EvanR checks out handsomesoup
15:15:32 <EvanR> im currently looking through the current webscape for haskell
15:18:12 <hpaste_> “Eduard - Gabriel Munteanu” pasted “Decomposing into adjunctions” at http://hpaste.org/67565
15:18:29 <Eduard_Munteanu> Does this look sane so far? I can't test it yet... http://hpaste.org/67565
15:18:57 <Eduard_Munteanu> The idea is decomposing arbitrary monads into adjunctions, going through the Kleisli construction.
15:20:23 <Eduard_Munteanu> I'm hoping some additional type/instance hackery might allow me to automatically test them/
15:20:32 <rzys> hey if somebody had some tips how to improve my code (style/speed/anything) id would be greatly appreciated. the program should visualize a fractal. i suppose my english is quite off at some points :) here's the code:
15:20:35 <hpaste_> rzys pasted “julia set: visualization of prisoner values” at http://hpaste.org/67566
15:22:16 <Eduard_Munteanu> rzys: it's not bad, although you might want to add more type signatures.
15:22:20 <Botje> rzys: convertToDots can be written using catMaybes
15:23:51 <rzys> thanks, noted :) do you see some obvious speed issues?
15:23:53 <Botje> and line 43 can probably be flattened into one list comprehension, unless i'm mistaken.
15:25:06 <EvanR> monochrom: this is good stuff monochrom. but im still not sure what this means for a mysql simple fold consumer
15:25:10 <rzys> first i did it in one line but then i got a warning about parallel list comprehensions
15:25:57 <Botje> rzys: [ re :+ im | im <- [...], re <- [...] ]
15:26:04 <monochrom> I haven't finished it. it's a big project. I also have more urgent projects such as my thesis.
15:26:39 <louislacroix> hi... noob here... i don't understand how you "connect" an editor to the ghc...
15:26:53 <tryitout> @lambdabot \n u l -> concat (n:u:l)
15:26:53 <lambdabot> Unknown command, try @list
15:27:03 <tryitout> @list
15:27:03 <lambdabot> http://code.haskell.org/lambdabot/COMMANDS
15:27:11 <Botje> louislacroix: you can load files with :l, reload with :r
15:27:18 <Botje> (in GHCi, that is)
15:27:32 <tryitout> @pl \n u l -> concat (n:u:l)
15:27:33 <lambdabot> ((join .) .) . (. (:)) . (.) . (:)
15:27:57 <tryitout> @pl \n l -> concat (n:l)
15:27:57 <lambdabot> (join .) . (:)
15:28:10 <louislacroix> hmm.... I want to be able to use an editor with all the indentation and colors... and when I want to run it I just click run and it compiles... is that what you answered?
15:28:59 <Botje> louislacroix: depends on your editor.
15:29:01 <rzys> Botje, thanks, i'll try that
15:29:08 <louislacroix> ok... textmate.
15:29:09 <Botje> emacs is very nice in tha tregard.
15:29:15 <Botje> no clue.
15:29:34 <Botje> probably other people here know, but I stay far away from textmate :)
15:29:38 * hackagebot RSA 1.2.1.0 - Implementation of RSA, using the padding schemes of PKCS#1 v2.1.  http://hackage.haskell.org/package/RSA-1.2.1.0 (AdamWick)
15:29:48 <jfischoff> louislacroix: I use Textmate, there is a haskell bundle.
15:29:58 <Botje> http://stackoverflow.com/questions/5682339/setting-up-textmate-for-haskell-programming-on-mac-os-x
15:30:05 <Botje> this looks relevant.
15:30:08 <louislacroix> that includes ghc?
15:30:39 <jfischoff> louislacroix: yes but I don't use it. I use ghci in a terminal
15:31:08 <louislacroix> ghci vs. ghc? what's the diff?
15:32:06 <Botje> one is interactive, the other is a compiler
15:32:22 <Botje> in ghci you can load your file and try out stuff with immediate feedback
15:32:34 <louislacroix> I installed Haskell Platform on my XP box, but I don't understand how you use it in editor mode...
15:32:53 <louislacroix> it wants a file... can't you create a new one?
15:33:29 <Eduard_Munteanu> louislacroix: you can use any editor/IDE you want
15:33:48 <louislacroix> But how is it connected to ghc???
15:33:55 <Eduard_Munteanu> Not sure what to recommend though.
15:34:07 <Botje> louislacroix: you start up a ghci session and load your .hs file using :l
15:34:21 <cg_morton> louislacroix: ghc is a program that takes a text file and creates an executable file from it
15:34:26 <monochrom> http://vim-adventures.com/ hahahaha
15:34:47 <Botje> louislacroix: read http://learnyouahaskell.com/starting-out
15:34:49 <EvanR> monochrom: so would you say that all the 'problems with' foldr and foldl are caused by strict consumers, like hardware arithmetic
15:34:55 <jfischoff> louislacroix: are you running ghci from the command line? Or are you double clicking the exe?
15:35:01 <Eduard_Munteanu> louislacroix: the HP doesn't include an IDE, if that's what you're looking for
15:35:11 <Botje> it walks you through some basic ghci functionally and tells you how to load files.
15:35:29 <Botje> it's also a fantastic book :)
15:35:40 <Eduard_Munteanu> See e.g. Leksah for an IDE, although I can't really recommend any of those.
15:35:48 <monochrom> I am not sure what you mean, but I guess yes.
15:35:52 <EvanR> pirateat42: pics or didnt happen
15:36:04 <copumpkin> EvanR: lol
15:36:19 <EvanR> monochrom: like does lazy arithmetic make foldl' unnecessary
15:36:54 <monochrom> yes, but how often do you use lazy arithmetic?
15:37:00 <EvanR> never
15:37:08 <Eduard_Munteanu> EvanR: I'm still unsure you'd want foldl in that case
15:37:12 <Eduard_Munteanu> Most likely foldr.
15:37:24 <EvanR> yeah i usually use foldr
15:37:25 <matthiasgorgens> Is there a data-structure that can be lazily-infinite like lists, but has logarithmic access to elements?  (or more specifically, has somebody implemented something like this on hackage?)
15:37:26 <cg_morton> wait, how is lazy arithmetic different from lazy evaluation?
15:37:46 <cg_morton> because I use that all the time
15:38:06 <Eduard_Munteanu> My guess is you only want foldl when your operation is lazy and non-associative.
15:38:59 <Eduard_Munteanu> cg_morton: you don't really use lazy arithmetic that often though... think Peano numbers.
15:39:28 <louislacroix> argh... they should make it easier for noobs... really. I'll continue reading thanks... I wish it was just a matter of opening an editor and writing... it's never explained with noobs in mind...
15:39:49 <EvanR> noobs should stay away from IDEs
15:40:03 <cg_morton> louislacroix, are you looking for something like Eclipse that integrates all the development steps?
15:40:07 <EvanR> health hazard
15:40:09 <bitonic> matthiasgorgens: logerithmic in respect to what? if the number of elements is infinite...
15:40:19 <Eduard_Munteanu> louislacroix: it is a matter of opening an editor. It's just not integrated in a common environment.
15:40:20 <louislacroix> ok.. Eclipse... I'll check it out... thanks
15:40:41 <jfischoff> EvanR: totally and yet that is what I was fed
15:40:54 <Eduard_Munteanu> Well, does Eclipse support Haskell/GHC?
15:40:58 <monochrom> I am no longer sure what "easy for noobs" means. every noob means a different thing.
15:41:23 <louislacroix> but frankly it's fucking difficult... yeah, all I need to do is add a few lines of code the .emacs in ELisp.. no prob... :(
15:42:00 <EvanR> haskell for emacs is pretty popular i heard
15:42:04 <Eduard_Munteanu> @google leksah
15:42:04 <EvanR> haskell mode?
15:42:06 <lambdabot> http://leksah.org/
15:42:06 <lambdabot> Title: Leksah - Haskell IDE in Haskell
15:42:41 <louislacroix> leksah.org looks like something I could use.. thanks.
15:42:59 <monochrom> is this what you call difficult? 1. open one window for your editor, any editor you are used to; 2. open another window for ghci
15:43:07 <EvanR> ^
15:43:24 <jfischoff> louislacroix: Make it even easier. Start with just running ghci by itself.
15:43:45 <Eduard_Munteanu> I guess it's more of a "I don't know what editor to use" problem.
15:43:54 <louislacroix> monochrom: I want indentation and colors and compiling... in one window.
15:43:58 <Eduard_Munteanu> (and yeah, Notepad isn't a sensible choice)
15:44:21 <rzys> louislacroix, take it from a newb: learn the basic ghci commands and you can try stuff out much faster than you could ever in an IDE
15:44:38 <cg_morton> I thought haskell was really simple to start using.  You have to know to use :load and :reload, but that was right there in the book
15:44:40 <Eduard_Munteanu> Or ask lambdabot :D
15:44:41 * hackagebot fb-persistent 0.1.2 - Provides Persistent instances to Facebook types.  http://hackage.haskell.org/package/fb-persistent-0.1.2 (FelipeLessa)
15:44:43 * hackagebot fb 0.9 - Bindings to Facebook's API.  http://hackage.haskell.org/package/fb-0.9 (FelipeLessa)
15:44:55 <louislacroix> I'm not interested in an interpreter.. I want to write code
15:45:17 <cg_morton> louislacroix, why do you need it in one window?
15:45:18 <monochrom> well ok, I regret to say what you want does not have a plentiful supply
15:45:20 <bitonic> louislacroix: what's wrong with using ghci? do you have any good reason apart from habit (which might be a good reason eh)
15:45:21 <stilgart> then write code and use :load :)
15:45:31 <rzys> louislacroix, yes you split your screen    editor | ghci     then you can do both
15:45:47 <cg_morton> if you really hate an interactive interpreter, you can use runghc from the command line
15:46:27 <louislacroix> rzys: thx... i'm understanding more... but what about colors?
15:46:35 <louislacroix> indentation?
15:46:36 * Eduard_Munteanu would have pointed louislacroix to a Windows port of vim or something like that
15:46:42 <bitonic> louislacroix: colors where? most editors will syntax highlight Haskell
15:46:43 <EvanR> louislacroix: two windows is better than one
15:46:53 <monochrom> anyway, you do confirm my stance about "easy for noobs" being completely ambiguous and personal
15:47:01 <EvanR> now your window manager can do stuff with them
15:47:14 <bitonic> louislacroix: also, what do you mean by "indentation"? you can't automatically indent haskell, but there are tools that help
15:47:16 <jfischoff> louislacroix: you are using textmate right so … https://github.com/textmate/haskell.tmbundle
15:47:17 <bitonic> it's not that important anyways
15:47:25 <cg_morton> since when is haskell easy for noobs?  The language itself is the hardest thing I've learned in months
15:47:35 <bitonic> Haskell is not hard for "noobs"
15:47:41 <EvanR> its hard if youre coming from C etc
15:47:44 <Eduard_Munteanu> It does depend on the noob.
15:47:46 <blackdog> cg_morton: it's often harder for people who've learned other languages
15:47:48 <bitonic> Haskell is they first language they teach at my university, nobody complains.
15:47:51 <rzys> louislacroix, most of the editors provide this. vim for sure, gedit etc. as well i'm sure.
15:47:59 <Eduard_Munteanu> Mainly, his expectations, experience, what he considers to be noobish and so on.
15:48:12 <monochrom> no, cg_morton, pretty sure it is meant to be "easy environment setup for noobs", but that is still totally ambiguous and personal
15:48:21 <bitonic> well actually the people who used big Java IDEs before complain :P
15:48:42 <cg_morton> I agree the environment is easy to setup, that's one thing I already love about haskell
15:49:23 <louislacroix> alright.. thx guys... I'll go back and try again... thx again.
15:49:31 <Eduard_Munteanu> Well, I'm not sure if you compare feature for feature... e.g. how easy it is to Cabalize your project.
15:49:42 * hackagebot yesod-auth-fb 1.0.1 - Authentication backend for Yesod using Facebook.  http://hackage.haskell.org/package/yesod-auth-fb-1.0.1 (FelipeLessa)
15:51:15 <monochrom> my complain is that people really mean "easy for me" but are unwilling to admit that, so they hide it behind "easy for <stereotype>"
15:51:56 <bitonic> there are problems in the haskell environment, but starting to write haskell code to learn is super easy
15:52:14 <bitonic> much easier than, say, C
15:53:11 <raboof> monochrom: i'm not sure it's a matter of 'hiding', I think people tend to honestly over-estimate the size of the groups they consider themselves part of
15:53:41 <dylukes> bitonic: I think Haskell is something that grows on your slowly.
15:53:59 <bitonic> it grew pretty quickly on me.
15:54:11 <bitonic> and it was the first PL I learnt seriously
15:54:45 <raboof> it's said that it's easier to start with a functional language instead of the other way around - less stuff to un-learn ;)
15:54:46 <jfischoff> bitonic: maybe that is why. I had to unlearn years of OO
15:54:53 <rzys> yea but for people who are in a java mindset it can be extremely confusing to not just put a system.out.println everywhere they want
15:55:57 <cg_morton> java as a first language ruins people, imo
15:56:12 <sipa> yes, they should start with brainfuck
15:56:18 <bitonic> jfischoff: well but I had no problem learning OO langs, what gives :P? I think it's just that if you program in something 5 years, you lose flexibility... also, some people just like imperative programming, or being in control (C/C++)
15:56:28 <bitonic> *program exclusively in something
15:56:43 <cg_morton> at least with C you can see how it translates to machine code, but Java is so many layers of abstraction away from that
15:57:05 <Eduard_Munteanu> Maybe you can only learn one native language, like IRL :P
15:57:12 <cg_morton> hehe
15:57:40 <rzys> cg_morton, java is great for learning OO concepts imo. but one should learn C, java, Haskell simultanously, even if it isn't that realistic
15:59:06 <cg_morton> depends what you're training for.  My university was apparently aiming to create cheap Java laborers, you could easily go through a whole degree with only 2 classes not in Java
15:59:30 <EvanR> bitonic: so people should like the inline assembler to be included in their imperative system of choice
15:59:56 <EvanR> so they can do a manual for loop just in case
15:59:57 <bitonic> EvanR: mhm?
16:00:05 <EvanR> re 'people like being in control'
16:00:23 <EvanR> i.e. the whole powerful buzzthing
16:00:23 <cg_morton> in our 'programming languages' course we spent a solid 3 weeks learning OCaml, but then switched back to Java because it would be 'a good language to learn concurrency in'
16:00:26 <bitonic> ah. well, there are shades of grey :P
16:00:38 <bitonic> I know some great people that wouldn't code in anything but C...
16:00:49 <c_wraith> java is a great language to learn everything that can go wrong with concurrency in.
16:01:05 <EvanR> pretty sure the websters would really love a system which exposes microcode of the cpu
16:01:11 <EvanR> because its so powerful
16:01:25 <bitonic> there's that great java concurrency book
16:01:29 <bitonic> with that white train.
16:01:32 <bitonic> that's interesting
16:01:50 <EvanR> pthreads style concurrency is horrible
16:01:51 <raboof> concurrency in practice
16:01:55 <bitonic> raboof: that
16:01:57 <rzys> cg_morton, yea it's mostly java/c++ here as well. i don't think there's a single course which even mentions functional programming.
16:02:16 <c_wraith> rzys: if it's hidden away, it's probably in a Languages course
16:02:20 <bitonic> that book tells you a lot of things that can go wrong, it's pretty scary
16:02:58 <bitonic> that and "effective java" are actually great books
16:03:09 <raboof> my main takeaway was 'getting this right is too hard this way, you need better abstractions instead'
16:03:16 <bitonic> raboof: yeah
16:03:33 <raboof> though some of the new apis are quite pretty
16:03:42 <cg_morton> as I say, they were prepping us for enterprise work.  They didn't touch on web technologies either - I left college not knowing what PHP or JS were
16:04:07 <bitonic> cg_morton: oh you missed all that sweet type coercion...
16:05:39 <cg_morton> luckily I overcame my training and ended up here in the land of milk, honey, and strict typing
16:06:39 <Bytter> Is there any "interactive" tool for equational reasoning?
16:06:53 <Bytter> i'm not looking for a full-blown theorem prover
16:07:22 <t7> can i run a single expression through ghci
16:07:28 <t7> and then return to the shell?
16:07:32 <monochrom> not yet. all the interactive proof people believe in adding more icing to natural deduction only
16:07:40 <Bytter> just something that allows to generate equational substitutions like those on "pearls of functional algorithm design"
16:07:56 <Bytter> monochrom: bah... it sux
16:08:39 <monochrom> it's really weird. if you bring up "equational", people think it must be automated. if you bring up "interactive", people think it must be like natural deduction
16:09:09 <monochrom> by "people" I mean the relevant research groups
16:09:13 <geekosaur> t7, perhaps you want ghc -e?
16:09:46 <bitonic> Bytter: you want something that checks if the subsitutions hold by simply replacing the relevant variables in the terms?
16:09:49 <bitonic> well in the definitions
16:10:02 <bitonic> because that wouldn't be enough
16:10:19 <t7> geekosaur: ah cheers
16:10:33 <Bytter> bitonic: yes
16:10:55 <Bytter> bitonic: it doesn't need to check if an arbitrary substituion is right
16:10:57 <Bytter> bitonic: of course...
16:11:00 <bitonic> e.g. you can't prove that 'map (f . g) === map f . map g' in haskell... ok you could define it as a rule and then use it, but then what is the added value compared to writing it on pepar?
16:11:12 <Bytter> bitonic: just that a well-known substitution can be applied
16:11:20 <Bytter> bitonic: pedagogical value :P
16:11:32 <Bytter> bitonic: the computer can check if I'm making simple mistakes
16:11:38 <Bytter> bitonic: it's good for exploration
16:11:50 <Bytter> bitonic: etc...etc...
16:11:57 <bitonic> Bytter: mah, ok. I think people didn't put efforts in it because it wouldn't be of much use in terms of research
16:12:12 <bitonic> but I see your point
16:12:57 <Bytter> bitonic: it could even support more evolved (though simple) forms, like induction
16:13:21 <Bytter> bitonic: for new things, it could always automatically generate some specs that could be searched in a limited vector space...
16:13:52 <Bytter> i see many applications... granted, it won't replace coq or agda...
16:13:57 <bitonic> I'm not following you now (the vector space stuff) :P
16:14:17 <Bytter> bitonic: you know, stuff like Allow
16:14:19 <augur> mmm
16:14:22 <Bytter> Alloy*
16:14:43 <augur> is it model theory that will talk about what classes of objects can be expressed in logics?
16:14:48 <bitonic> no, I don't now, but it's fine ehe
16:15:13 <cg_morton> say, is IO a strictly unique part of haskell, or can it be expressed in terms of monads/other language features?
16:15:22 <Bytter> cg_morton: monads
16:15:23 <EvanR> IO is magic
16:15:44 <cg_morton> I see
16:16:02 <Bytter> cg_morton: you can't see magic :P
16:16:14 <Bytter> cg_morton: but, here, take a look at this: http://www.haskell.org/haskellwiki/IO_inside
16:16:28 <t7> IO is impure *ducks*
16:16:35 <Bytter> cg_morton: if you want to see it in other languages, take a look at Scala and Scalaz...
16:16:38 <c_wraith> Ugh, that page is horrible
16:17:16 <rzys> c_wraith, why?
16:17:31 <c_wraith> Very little of it is about the deep terrifying implementation details of IO
16:17:42 <Bytter> anyway, back to my question, so no one knows of any equational reasoning tool for haskell besides a full-blown proof assistant?
16:18:04 <c_wraith> Most of its content would be better in a page about IO for beginners.
16:18:23 <Bytter> which makes it safe to say that I could build one without incurring in the 2^100 time i reinvent the square wheel? :P
16:19:08 <cg_morton> the page does seem a little hand-holdy
16:19:18 <c_wraith> The last few sections, starting at 9, actually get interesting
16:19:25 <bitonic> Bytter: you wouldn't do any harm building one!
16:19:33 <bitonic> I have never heard of something like that here
16:19:36 <c_wraith> The rest is useful, but not really the deep dark secrets
16:19:38 <rzys> c_wraith, ah ok. yea it reads like a explanation for beginners. maybe not so much 'inside'.
16:20:00 <t7> Bytter: at least raise to a power of two...
16:20:02 <t7> 128
16:20:42 <acowley> I usually think of IO as being an API to the RTS. The interface is monadic, but that's just a property of the interface.
16:21:21 <c_wraith> yeah.  IO isn't intrinsically something that is made up of magic monadism.  It's just that the IO type was constructed such that it supported that interface.
16:21:52 <Bytter> c_wraith: really? i was under the impression that the monadic IO was actually a breakthrough, historic-wise
16:22:07 <cg_morton> ah, even in section 9 it's using silly metaphors!  'As you should remember this is prohibited by requiring the RealWorld "baton" in order to call an IO action.'
16:22:09 <c_wraith> Bytter: the discovery that you could construct the type that way was the big breakthrough
16:22:13 <t7> which came first, IO or do notation?
16:22:18 <c_wraith> t7: IO
16:22:25 <bitonic> Bytter: the gbreackthrough is that you can keep purity with monadic IO actions
16:22:27 <acowley> It was a breakthrough to find a generalization that specifically expresses desirable properties of the IO API.
16:22:46 <Bytter> 3 breakthroughs :P going 1... twice...
16:22:57 <c_wraith> It's all the same thing
16:23:01 <acowley> yeah
16:23:26 <mauke> bitonic: that seems wrong
16:23:36 <c_wraith> http://research.microsoft.com/en-us/um/people/simonpj/papers/lazy-functional-state-threads.ps.Z  Heh.  if you can read that, it's the paper that describes the innovation
16:23:39 <cg_morton> my basic guess is that IO is a monad that binds with the external state, am I on the right track thinking that way?
16:23:39 <mauke> because the other two implementations of IO are still pure
16:24:01 <Eduard_Munteanu> cg_morton: define "binds"
16:24:07 <c_wraith> cg_morton: actually, bind is "make this IO action and that function that returns an IO action into one big IO action"
16:24:10 <bitonic> mauke: yes but they're not nearly as expressive...
16:24:24 <bitonic> also, I'm not sure about "other 2", I was aware of only 1
16:24:25 <c_wraith> cg_morton: the implementation in terms of world token passing is irrelevant to the semantics of bind
16:24:29 <bitonic> (the stream-based IO)
16:24:34 <mauke> bitonic: the continuation thing looked more or less identical
16:24:45 <cg_morton> hmm, maybe I don't know what I'm talking about.
16:24:49 <Bytter> c_wraith: thx for the paper... so the State monad appeared before the IO?
16:24:50 <bitonic> mauke: I don't know about that. link?
16:24:58 <mauke> sorry, don't have one
16:25:05 <mauke> only murky memories
16:25:15 <c_wraith> Bytter: the name State in that paper doesn't mean State monad as it exists now
16:25:17 <acowley> cg_morton: IO just happens to be a monad. You can (and should) explore the IO API without worrying about monads.
16:25:20 <bitonic> mauke: a name at least?
16:25:42 <Eduard_Munteanu> I guess Moggi's paper came before IO.
16:25:51 <bitonic> because reconciling IO with purity is a big deal
16:26:02 <bitonic> Eduard_Munteanu: was Moggi concerned with IO at all?
16:26:05 <Eduard_Munteanu> And state is pretty straightforward.
16:26:10 <Eduard_Munteanu> *State
16:26:51 <Eduard_Munteanu> bitonic: not AFAIR, I mean it's likely the simple monads like State were already figured out before IO.
16:26:56 <t7> is STM still cool even though C and C++ can do it now?
16:27:09 <bitonic> t7: C and C++ can't do it.
16:27:19 <t7> atomic is in the new standard
16:27:25 <bitonic> t7: can you use printf inside a transaction?
16:27:44 <t7> if it doesnt interfere with an object i think yes
16:27:50 <Eduard_Munteanu> Mm, atomic types doesn't say much.
16:27:57 <c_wraith> wtf does "interfere with an object" mean?
16:28:03 <bitonic> t7: vague answer :P
16:28:05 <mauke> t7: what does atomic do?
16:28:15 <Eduard_Munteanu> Isn't that something like Linux's atomic_t = int for x86, for example?
16:28:23 <bitonic> t7: but the problem with STM implementations in impure langauges is that you can't really rollback transactions.
16:28:54 <bitonic> which is OK in practice, if you're careful (see clojure :P)
16:29:00 <bitonic> but in C++ it's probably not
16:29:07 <bitonic> since most libraries will be side-effecting
16:29:25 <t7> ITC: haskel users getting hot and bothered that other people are implementing STM
16:29:26 <bitonic> most existing code will hide some stateful computation
16:29:48 <mauke> bitonic: found http://tlau.org/research/papers/haskell-io.ps with google
16:30:01 <c_wraith> t7: it's not really STM if rollbacks don't work.  Just ask microsoft.
16:30:10 <Twey> *Badly*
16:30:28 <adnauseam> anyone use geco-ghc ? maybe i've understood the meaning of "Unarchive neco-ghc and put it into a dir of your &rtp." wrong. what's the &rtp? isn't /bundle?
16:30:30 <Eduard_Munteanu> I'm guessing it's just "hey, if you write to this int I guarantee it's atomic".
16:30:39 <bitonic> mauke: I'll read it sometime, but I doubt it's as nice as monadic IO. if it was and it came up before monads they would have used that :P
16:31:00 <Bytter> AH! Found one: http://www.haskell.org/haskellwiki/Haskell_Equational_Reasoning_Assistant
16:31:06 <Eduard_Munteanu> While STM attempts to do significantly more.
16:31:16 <mauke> <bitonic> Bytter: the gbreackthrough is that you can keep purity with monadic IO actions
16:31:41 <Twey> http://www.dcs.ed.ac.uk/home/pgh/iorep.ps is cool.
16:31:53 <mauke> bitonic: ^ my point is that purity isn't the main effect/breakthrough of monadic IO
16:32:00 <bitonic> mauke: ok, add "while being usable".
16:32:03 <Twey> Oops, wrong paper
16:32:08 <mauke> well, yes :-)
16:32:36 <bitonic> I think that's the main thing, the fact that you're restricting side effects at the type level
16:32:54 <mauke> but monads are pretty continuationy anyway, so I wouldn't be surprised if they're interexpressible
16:33:10 <mauke> bitonic: I disagree with that
16:33:26 <bitonic> mauke: with what exactly?
16:33:33 <mauke> you can do Haskell-style IO in an untyped language
16:33:51 <mauke> side effects aren't restricted at the type level; they simply don't exist in Haskell
16:34:19 <bitonic> mauke: you can? how? what prevents me from sticking some IO action in a pure computation?
16:34:26 <bitonic> well.
16:34:27 <mauke> nothing
16:34:32 <mauke> IO actions are pure
16:34:50 <mauke> > length [putStr "hello world"]
16:34:51 <lambdabot>   1
16:34:58 <bitonic> yes, that's the main point
16:35:15 <bitonic> (which is what I meant with reconciling purity & IO)
16:35:29 <bitonic> but types play an important role
16:35:35 <t7> > length [unsafePerformIO $ putStr "Hi"]
16:35:36 <lambdabot>   Not in scope: `unsafePerformIO'
16:35:38 <mauke> bitonic: why?
16:37:12 <bitonic> mauke: because that concept has proven extremely fruitful in haskell programming
16:37:13 * Twey imagines a weakly-typed language trying to figure out what to make of an IO value.
16:37:25 <bitonic> mauke: to separate different kinds of side effects
16:37:29 <bitonic> e.g. ST, STM
16:37:37 <bitonic> with IO on top
16:37:50 <Saizan> bitonic: but you don't need the types for this
16:37:59 <t7> are ST actions side effects...
16:38:15 <Twey> t7: Yes, but a particular class of side effects that can be safely confined
16:38:55 <bitonic> Saizan: no, but types make things much nicer, in the same way that they make programming nicer eh. the fact that you can "type" type effects is extremely nice
16:38:59 <Saizan> bitonic: i.e. it's not hard to imagine an untyped semantics of "length [putStr "hello world"]" that still doesn't print "hello world"
16:39:21 <bitonic> Saizan: yes, of course you can do that.
16:40:12 <Saizan> bitonic: so you see how you can do haskell-style IO in an untyped language?
16:40:22 <bitonic> still, I think that you'd have to strong typed
16:40:24 <bitonic> Saizan: yes
16:40:35 <bitonic> I never said the contrary
16:40:51 <Cale> Depends on how Haskell-like it needs to be in order to be Haskell-style IO :)
16:41:12 <bitonic> yeah, it's a bit vague put like that. but that's not my point anyways :P
16:41:23 <Saizan> you'd just lose typeclasses
16:41:25 <Cale> Monad libraries are frustratingly annoying to use in an untyped setting because of the polymorphism in the codomain that return has :)
16:41:37 <bitonic> my point is that separating side effects at the type level with monadic interfaces has proven a reat technique
16:41:42 <bitonic> *great
16:41:42 <Cale> But specific monads can still be okay'
16:42:04 <Cale> Yeah, everyone should me making that separation anyway
16:42:05 <Cale> I agree
16:42:22 <Saizan> i think you can have the same amout of separation without types
16:43:08 <navaati> is there a way to make eclipsefp and cabal-dev work together ?
16:43:31 <bitonic> Saizan: the advantage is mostly a practical and conceptual one
16:43:55 <bitonic> I can definitely see how you can do those things in a dynamically & strong typed language
16:44:05 <bitonic> but it's not my point really
16:49:56 <mauke> t7: so what does atomic do?
16:50:05 <t7> dunno
16:50:05 <Q8701> I wrote a custom hook for cabal (setup.hs), Is there any way to make the `cabal` command run the custom setup?
16:50:40 <mauke> t7: then why did you say that C and C++ have STM now?
16:50:50 <t7> just trying to fit in
16:51:03 <mauke> what?
16:51:37 <Eduard_Munteanu> :)
16:52:12 <hector123> Hello everyone, I need some help with wxWidget on c++, im making a simple stopwatch , who is crashing (or slowing a lot) everytime i pause it
16:52:13 <Eduard_Munteanu> Like ... Perl has zygohistomorphic prepromorphisms.
16:52:16 <Eduard_Munteanu> :P
16:52:41 <bitonic> hector123: if that's a C++ question, this is not the right channel
16:52:42 <Eduard_Munteanu> hector123: C++?
16:52:51 <hector123> I'm pasting the code soon
16:53:00 <hector123> yes c++ ..pastie.org right?
16:53:11 <t7> hector123: pm me if you want
16:53:23 <hector123> alright :)
16:53:33 <bitonic> hector123: this channel is not about C++, sorry
16:53:50 <Saizan> ##c++ is, i think
16:54:20 <t7> is there a type theory channel?
16:54:55 <hector123> oups I,m sorry for the error...btw pastie.org is offline? is there a good alternative?
16:55:11 <luite> hpaste.org works ok
16:55:13 <Eduard_Munteanu> Hard to say, that might sometimes be reasonable to ask about in here, or in -blah or related channels.
16:55:24 <mauke> hector123: codepad.org
16:56:24 <hector123> thanks for the answers...there are now in my favorites :)
17:11:03 <kallisti> @src foldr
17:11:04 <lambdabot> foldr f z []     = z
17:11:04 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
17:11:08 * gwern posts his Summer of Code predictions http://www.gwern.net/Haskell%20Summer%20of%20Code#predictions 
17:17:24 <Twey> Summer of Codes?  Summers of Code?
17:17:56 <luite> gwern: are there predictions for the 2012 proposals in there?
17:19:05 <gwern> yes
17:19:17 <gwern> may need to refresh
17:20:20 <luite> 4 is basically improving the yesod devel server
17:20:21 <hpc> segfault of cupcakes
17:20:43 <luite> for which i wrote most of the code, i think
17:20:55 <Eduard_Munteanu> BTW, are the students in here?
17:21:24 <luite> a lot of it is really new and not really released, but in a github branch
17:21:41 * Eduard_Munteanu is curious, he usually hanged around IRC during his SoCs.
17:21:51 <luite> 7. will probably not start with mueval, at least if i can get my code ready in time :)
17:22:40 <luite> i'll probably help out with that project
17:24:12 <luite> problem with 7. is that there is a minor conflict of interest: the mentor is more interested in a ghci with web interface, while shapr mainly the public website and multiuser
17:24:57 <luite> i think it should be possible to get both out of the gsoc project though
17:27:18 <luite> for 4. one criterion would be a cabal package for a cross-platform event based file watcher (inotify, fsevents, the windows version that i forgot the name of)
17:27:42 <luite> but that's only a small part
17:27:51 <glguy> ?hoogle CSSize
17:27:51 <lambdabot> System.Posix.Types data CSsize
17:27:57 <c_wraith> That would be a wonderful package to have
17:28:21 <luite> i wrote the fsevents bindings 2 months ago or so, because that seemed to be the missing platform :)
17:28:40 <luite> unfortunately freebsd won't be supported due to the lack of operating system support
17:28:56 <luite> at least it couldn't find any
17:29:06 <luite> kqueue is not suitable for watching large directory trees
17:29:19 <luite> i couldn't find any
17:30:10 <DanielDiaz> @pl \x y -> x + x + y
17:30:10 <lambdabot> (+) . join (+)
17:31:27 <DanielDiaz> haha Great! Where I can found a paper (or such) explaining how @pl works?
17:31:31 <t7> :t join
17:31:32 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:32:05 <luite> gwern: can mueval actually support sessions like ghci?
17:33:18 <gwern> luite: obviously not, or it wouldn't be a SoC
17:34:24 <luite> gwern: well, even if it did, there would still need to be a web interface :)
17:34:44 <gwern> luite: I'm hopeful that if all it was was a web interface, the mentors would've voted it down
17:35:06 <luite> but I mean, it looks not terribly easy to support things like import X.Y.Z (or :m +X) in mueval
17:35:14 <luite> and let bindings
17:35:23 <hpc> eh
17:35:46 <hpc> mueval's a very specific program
17:35:56 <hpc> adding the extra functionality should be split into another package
17:37:46 <gwern> yeah. ideally mueval would be more of a library, with a bunch of security-related functions
17:37:51 <gwern> but that's work
17:38:00 <luite> hmm
17:41:13 <luite> if you require safehaskell, what kind of things would be left?
17:42:28 <gwern> luite: can you trust safehaskell?
17:43:05 <luite> dunno, personally i didn't want to rely on it, but that was because I didn't want to disallow IO
17:46:41 <luite> gwern: (that means that it's a lot more difficult to setup, since the operating system has to provide the security)
17:47:05 <gwern> yeah, OS sandboxes are pretty lame
17:47:18 <gwern> what are you gonna do? set up a chroot, basically
17:47:59 <luite> well, a bit more, restrict syscalls, network access, signals that can be sent
17:48:29 <Rudi> yo
17:50:13 <luite> gwern: i'm not sure if it's possible to reliably kill spawned processes, so far it looks ok, otherwise i'll also disable that
17:50:16 * monochrom is tempted to add a sarcastic remark to the IsString thread on the GHC mailing list
17:50:43 <luite> but it would be nice if you could call graphviz for example
17:50:56 <gwern> monochrom: 'in soviet russia, we produce very good sentences -  IsString, IsTractor, IsBytestring, IsToothpasteToo!'
17:51:09 <Rudi> quick question guys, what's the most efficient way for doing say, taking in a list of integers and returning a tuple consisting of the sum and product (in that order)
17:51:27 <Rudi> using sum and product is a no no I think
17:51:39 <Rudi> just not sure how I could do it without traversing through the list twice
17:51:45 <gwern> Rudi: foldr with a tuple accumaltor?
17:51:51 <monochrom> summary of the IsString thread: debating on the prospect of fromInteger and fromString being partial functions, therefore number literals and string literals being partial values
17:52:13 <Rudi> can you have two functions in foldr? or?
17:53:00 <gwern> f (s,p) (x:xs) = f (s + x, p * x) xs
17:53:22 <monochrom> summary of my sarcastic remark: fromInteger :: (Num a) => Integer -> Maybe a, fromString :: (IsString a) => String -> Maybe a, in fact (-) :: (Num a) => a -> a -> Maybe a is long overdue
17:54:28 <gwern> wrapper and basecases left as an exercise for Rudi
17:54:38 <Rudi> man, what is this lol
17:54:59 <gwern> also, versions using foldr and arrows
17:55:02 <monochrom> dude, this is haskell code lol
17:55:03 <luite> hmm, there was some blog post about exactly this
17:55:14 <luite> but i guess it's uncommon enough to become some pattern
17:55:49 <Lorehead> Rudi: you can have an accumulator that's a tuple.
17:55:52 <luite> (folds with multiple independent results from the same list)
17:56:13 <byorgey> luite: yeah, I remember that blog post
17:56:30 <Rudi> I see
17:56:38 <Rudi> so this traverses through the list once?
17:56:51 <gwern> my version, anyway.
17:57:56 <Lorehead> It could.  Keep in mind, either way youre performing one addition and one multiplication per list item, so it only becomes more efficient to do them in one pass if youve got a lot of cache misses or something to worry about.
17:58:35 <gwern> Lorehead: or you'd rather not have huge memory usage
17:59:07 <Lorehead> The list already exists, though, whether youre going through it once or twice?
17:59:13 <gwern> does it?
17:59:27 <Lorehead> There are some algebraic optimizations where it might not, I suppose.
18:00:17 <luite> http://squing.blogspot.com/2008/11/beautiful-folding.html
18:00:27 <luite> looks like twanvl and conal have written some followups
18:01:48 <Rudi> I see how this works :D
18:02:19 <Lorehead> Thanks for that link.
18:02:33 <Rudi> Thanks a lot guys
18:03:40 <Rudi> thanks for the link too luite
18:05:29 <Rudi> Time to sleep! Really appreciate the help and advice.
18:05:29 <Rudi> :)
18:20:29 <boccato> https://gist.github.com/0403364acfa0edfc023a
18:20:39 <boccato> Can anyone tell me what I am doing wrong?
18:21:04 <rwbarton> The compiler might be giving you a hint...
18:21:14 <Cale> boccato: Suppose n = 1, but the list has more than one element.
18:21:44 <Cale> myElementAt [1,2,3] 1 = myElementAt [2,3] 0
18:21:58 <Cale> = myElementAt [3] (-1)
18:22:03 <Cale> = myElementAt [] (-2)
18:22:08 <Cale> -> pattern match fail
18:22:10 <boccato> hmm
18:23:00 <boccato> myElementAt (x:xs) 1 = x --worked
18:23:39 <Cale> yep!
18:24:24 <boccato> Why doesn't "myElementAt [x] 1 = x" work?
18:24:44 <cmears> [x] matches only a singe-element list
18:25:25 <boccato> oh... same mistake...
18:26:21 <wo0kie> hey guys :)
18:26:29 <wo0kie> question (regarding hw)
18:27:45 <wo0kie> http://pastebin.com/Y9mMYucT
18:27:50 <mauke> The paste Y9mMYucT has been copied to http://hpaste.org/67571
18:27:57 <wo0kie> I have a monad set up to thread a result through a computation
18:28:36 <wo0kie> I need to define a function sizeAs that when run, leaves the array unchanged and yields the size of the array as the computation result. In essence, sizeAS applies the size function of the Array type class to the array threaded through the computation.
18:28:43 <hpaste_> vhd pasted “qsort” at http://hpaste.org/67572
18:28:49 <wo0kie> I think what I have may be correct
18:28:52 <wo0kie> but I'm not certain
18:29:18 <vhd> anyone know how to fix that error? ^
18:30:08 <rwbarton> vhd: you forgot one of the arguments to qsort
18:30:24 <rwbarton> at both call sites
18:30:36 <wo0kie> is my sizeAS function close to correct with respect to the monad I defined?
18:30:37 <vhd> *facepalm
18:30:52 <wo0kie> or do I need to use the >>= to actually thread the size function through the Monad?
18:30:58 <vhd> thanks rwbarton, tis late and it shows
18:31:26 <rwbarton> wo0kie: yes, sizeAS is fine
18:31:33 <wo0kie> :D!
18:31:52 <wo0kie> monads are still a bit mysterious to me
18:31:56 <wo0kie> thanks rwbarton :)
18:34:19 <augur> anyone interested in AI/mind stuff?
18:40:28 * ion
18:41:46 <wo0kie> http://pastebin.com/ztRdTxRa
18:41:48 <mauke> The paste ztRdTxRa has been copied to http://hpaste.org/67573
18:41:55 <wo0kie> does this look right for idxAS?
18:42:12 <wo0kie> "In
18:42:12 <wo0kie> essence, idxAS applies the idx function of the Array type class to the array threaded through the
18:42:12 <wo0kie> computation."
18:42:31 <wo0kie> seems to me the only way to get it to work
18:43:47 <wo0kie> wish there were a way to test this lol
18:43:55 <wo0kie> perhaps there is, but I don't know about it
18:46:07 <monochrom> never heard of "idx"
18:46:30 <wo0kie> oh woops
18:46:32 <wo0kie> hold on
18:46:52 <wo0kie> http://pastebin.com/Uw1YMD9w
18:46:54 <mauke> The paste Uw1YMD9w has been copied to http://hpaste.org/67574
18:46:59 <wo0kie> this is where idx and size functions come from
18:49:07 <monochrom> presumably idx already tests index bounds, so idxAS doesn't have to test again
18:49:38 <wo0kie> hmm
18:49:58 <monochrom> MkArrayState (\arr -> (idx arr i, arr))
18:49:59 <wo0kie> guessing that means my compare case is redundant?
18:50:05 <wo0kie> exactly
18:50:50 <wo0kie> thank you monochrom :)
18:50:59 <monochrom> your >>= looks right
18:55:05 <copumpkin> anyone know of an example of someone constructing something just like a Map using fingertree?
18:58:38 <dmwit> copumpkin: No, but it shouldn't be too much work.
18:58:45 <copumpkin> what monoid do you use?
18:59:02 <dmwit> bleh, I had one in mind when I wrote the answer but I realize now it's bunk
18:59:44 <dmwit> oh
18:59:46 <dmwit> Max
18:59:49 <rwbarton> ("Data.Map")
18:59:57 <rwbarton> er
19:00:03 <copumpkin> rwbarton is suggesting the string (list) monoid!
19:00:07 <dmwit> MaxPriority, which is a newtype for Maybe
19:00:08 <copumpkin> ;)
19:00:12 <rwbarton> I meant the Data.Map.Map monoid
19:00:15 <copumpkin> dmwit: hmm, I could see that
19:01:04 <dmwit> You wishing for one to benchmark? What spawned the question?
19:01:33 <copumpkin> can I maintain two measures and look up efficiently by both, assuming one is monotonic with the other
19:01:49 <copumpkin> it's a data structure I've been meaning to construct for a while and was wondering how much of a pain it would be
19:02:23 <Saizan> http://hackage.haskell.org/package/fingertree-psqueue <- might be of inspiration?
19:02:29 <dmwit> You can look up efficiently by either measure, yes.
19:02:41 <dmwit> No need for assumptions about any relationship between them.
19:02:52 <dmwit> Sort of the magic of finger trees.
19:03:02 <copumpkin> yeah, hmm
19:03:14 <copumpkin> Saizan: thanks
19:03:23 <copumpkin> yeah, I guess I need three measures
19:04:18 <monochrom> wow, three measures!
19:04:25 <Saizan> split seems to be where the magic happens
19:04:32 <copumpkin> watch out, or I'll up it to five
19:04:41 <copumpkin> http://www.theonion.com/articles/fuck-everything-were-doing-five-blades,11056/
19:10:37 <monochrom> hahaha, how about 5 blades, 3 aloe strips (for moisture!), and 2 silicone strips (for lubrication!)? (all prime numbers!)
19:12:29 <copumpkin> wow
19:12:37 <copumpkin> not sure even the manliest of men could handle that yet
19:12:40 <copumpkin> the world isn't ready yet
19:13:25 <otters> primes?
19:13:28 <otters> hm
19:13:36 <otters> what about 13 blades and 11 aloe strips
19:14:05 <monochrom> that may make the whole thing too heavy, but otherwise why not :)
19:14:06 <cg_morton> you have just blown my mind
19:14:25 <cg_morton> your skin would by like satin...
19:14:47 <monochrom> actually, your skin would no longer exist :)
19:15:35 <monochrom> also, I observe that we can s/prime/fibonacci/ with my 5-3-2 scheme :)
19:16:58 <cg_morton> or even better: 89-13-5
19:17:36 <cg_morton> that's right, I skipped -right over- 13-5-3.  I think the reasoning for that is clear
19:18:15 <monochrom> that would be an elephant shave...
19:18:57 <monochrom> ObTopic: why does GHC generate executables as huge as cg_morton's 89-blade shave? :)
19:19:53 <cg_morton> hey, where is the Regex module?  I don't see it under Text.
19:20:25 <monochrom> in package "regex-compat"
19:21:04 <JoeyA> I made a simple EDSL describing an editor for JSON-esque data.  I'm trying to figure out how to generate JavaScript that both generates form elements from source data, along with JavaScript for reading the data back.  I've accomplished the first part, but am having trouble with the second.  Where might I look for inspiration?
19:21:25 <JoeyA> Currently, I have a monad for code generation that's very similar to HJScript.
19:21:56 <JoeyA> (I probably could have used HJScript, since my code does a lot of what it does)
19:22:35 <JoeyA> However, this code generator only produces code for rendering DOM from data.  I'm trying to figure out a nice way to implement the corresponding mapping, too.
19:24:10 <JoeyA> I suppose I could have it be a writer over two simultaneous JavaScript streams.  The problem is, information from the DOM generator may be needed to read the fields back (though all that info could probably be passed through expandos).
19:25:43 <JoeyA> (an "expando" is an arbitrary property attached to a DOM node)
19:32:04 <JoeyA> Maybe I should finish reading the Elm thesis ( http://www.testblogpleaseignore.com/wp-content/uploads/2012/03/thesis.pdf ).
19:32:48 <JoeyA> (which gives a really nice overview of the types of FRP, by the way)
19:43:10 <nyingen> @quote
19:43:10 <lambdabot> jessenoller says: [On Python:] The closest we get to "type safety" is function annotations, which make me feel funny in sensitive places.
19:47:56 <mm_freak> in typed lambda calculus is type equivalence a precondition to alpha equivalence?
19:49:06 <mm_freak> i.e. given that two lambda expressions that would be alpha-equivalent when disregarding types, but have mismatching types, are they alpha-equivalent?
19:49:25 <mm_freak> or is that a wrong question to ask?
19:54:12 <mm_freak> also are \x -> x and \y -> x supposed to be alpha-equivalent?  i guess not
19:54:22 <rwbarton> no
20:09:52 <parcs`> does ghc automagically not inline things using unsafePerformIO?
20:10:01 <ClaudiusMaximus> I need a fast way to (de)serialize UArray(Int,Int)Bool - any suggestions?
20:12:05 <parcs`> cereal
20:13:05 <JoeyA> parcs`: unsafePerformIO itself is marked {-# NOINLINE #-}
20:13:43 * adu <3 unsafePerformIO
20:14:43 <JoeyA> Err, unsafeDupablePerformIO is marked {-# NOINLINE #-}
20:14:59 <JoeyA> and is called by unsafePerformIO
20:18:23 <ClaudiusMaximus> parcs`: unfortunately cereal seems to do things that will break things for me:  1. it puts the bounds of the array  2. it puts the elems as a list (which also puts the length)  3. it puts Bool as a Word8
20:19:44 <ClaudiusMaximus> essentially i want to write a 128x128 UArray of Bool as 128*128/8 bytes, and read it back as quickly as possible
20:23:47 <JoeyA> Well, a 128x128 UArray of Bool is going to be encoded with 32 bits per Bool (or whatever sizeOf (undefined :: Bool) gives you)
20:23:49 <mm_freak> wow, alpha conversion is not as trivial as i thought
20:24:11 <JoeyA> So converting that to bits means constructing and deconstructing bitmaps in any case.
20:24:35 <shachaf> mm_freak: Why not? And why are you doing alpha conversion?
20:25:05 <mm_freak> shachaf: i need beta equivalence for type checking, which is basically alpha equivalence of normal forms
20:25:22 <copumpkin> Cale: you around?
20:25:34 <mm_freak> i used to compare the normal forms, but obviously that's wrong
20:25:38 <shachaf> mm_freak: Why not just use De Bruijn indices?
20:25:42 <Cale> copumpkin: what's up?
20:25:52 <shachaf> hi Cale
20:25:57 <Cale> hi
20:26:00 <parcs`> ClaudiusMaximus: i don't know if such a thing is predefined, but you can use cereal's Get and Put monads to write that serialization algorithm
20:26:19 <mm_freak> shachaf: well, i made a test implementation using them and the rules feel slightly more difficult
20:26:35 <ClaudiusMaximus> JoeyA: this says UArray .. Bool is packaed as bits http://stackoverflow.com/questions/6006304/what-haskell-representation-is-recommended-for-2d-unboxed-pixel-arrays-with-mil
20:26:45 <shachaf> mm_freak: But alpha-equivalence is so easy to compute! :-)
20:26:48 <copumpkin> Cale: I was looking at http://hackage.haskell.org/packages/archive/fingertree-psqueue/0.3/doc/html/src/Data-FingerTree-PSQueue.html#Binding and was wondering why you reimplemented the Last monoid (as Key) in there, and why it's there at all. I get the Prio monoid but am not sure what Key adds
20:27:21 <JoeyA> ClaudiusMaximus: Ah, didn't know that
20:27:29 <parcs`> JoeyA: so unsafePerformIO is just an uninlineable alias for unsafeDupableIO, and an unsafePerformIO'd action is guaranteed to get executed at most once?
20:27:29 <mm_freak> shachaf: de bruijn indices make other things less trivial
20:27:47 <mm_freak> it's certainly intriguing not to need substitution, though
20:28:03 <shachaf> I like how Last is a Monoid instead of a Semigroup and thus uses Maybe.
20:28:12 <copumpkin> yeah :)
20:28:24 <Cale> copumpkin: The idea is to have a structure which is both a priority queue *and* a finite map structure
20:28:35 <copumpkin> yeah
20:28:52 <Cale> I'm not sure there was a Last monoid at the time I wrote that code.
20:28:59 <rwbarton> parcs`: you need to take care that a definition using unsafePerformIO is not itself inlined, though
20:29:08 <copumpkin> oh, so the Last monoid gives you a finite map structure and the Max monoid gives you the priority thing?
20:29:12 <Cale> right
20:29:18 <copumpkin> interesting
20:29:33 <JoeyA> parcs`: I believe so, but
20:29:46 <JoeyA> but I hit enter by accident
20:29:54 <Cale> that KPS monoid is being used to annotate the nodes of the fingertree
20:29:59 <copumpkin> yeah
20:30:14 <parcs`> rwbarton: that's what i thought..
20:30:34 <parcs`> stupid magical ghc execution model
20:31:10 <shachaf> So magical, man.
20:31:18 <JoeyA> parcs`: However, the comment below fixIO casts doubt on "unsafePerformIO-guaranteed-to-run-once":  http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/System-IO.html#fixIO
20:32:05 <Cale> er, hmm
20:32:17 <mm_freak> ah, i remember what was difficult about de bruijn indices:  computing normal forms
20:32:18 <Cale> I forget some of the details of how this works :P
20:32:20 <copumpkin> Cale: so say I wanted to make a new fingertree structure that stores pairs of numbers and: 1) lets me look up the pairs like a map based on one of the two elements of the pair 2) lets me split the tree based on the cumulative sum of the other element 3) lets me split the tree based on the cumulative sum of the numbers' product
20:32:25 <shachaf> mm_freak: Why?
20:32:35 <mm_freak> shachaf: because you need to shift the indices around all the time
20:32:39 <JoeyA> Here's a fun fact: the definition of "async exception" GHC uses when deciding whether to suspend or abort a pure computation is not where the exception came from, it's whether its type is AsyncException (I think).
20:32:40 <copumpkin> Cale: that seems feasible, right?
20:32:46 <shachaf> mm_freak: What do you mean?
20:33:38 <parcs`> JoeyA: that uses unsafeInterleaveIO
20:33:41 <copumpkin> preflex: seen dons
20:33:42 <preflex>  dons was last seen on #haskell 100 days, 9 hours, 19 minutes and 41 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
20:34:04 <JoeyA> parcs`: Ah, right.
20:34:19 <mm_freak> shachaf: say you have (\0 1) 1, you need  replace that by 1 0
20:34:34 <mm_freak> you need to shift the inner indices down after the application
20:34:40 <Cale> copumpkin: Oh, right, when I build the fingertree, I sort the elements by key, but I have the min priority of each subtree in the annotations, so I can still cut the tree around the minimum priority quickly.
20:35:03 <Cale> (and I have the size, so I can also cut it into parts by size)
20:35:09 <mm_freak> similarly for type checking, for every lambda you encounter you need to shift the context
20:35:19 <Cale> So, let's see.
20:35:21 <mm_freak> so while alpha equivalence becomes trivial, other things become more difficult
20:35:37 <copumpkin> Cale: yeah, so it seems like my question boils down to two Sums (one computed by multiplication) and one Last, all paired up
20:35:37 <Cale> copumpkin: (1) seems tricky already
20:35:41 <copumpkin> Cale: oh?
20:36:17 <copumpkin> by one, I mean a fixed one
20:36:21 <copumpkin> not either
20:36:26 <Cale> oh, okay
20:36:37 <Cale> In that case, easy :)
20:36:47 <copumpkin> so it's Last/Sum/Sum ?
20:37:23 <Cale> yeah
20:37:31 <copumpkin> I'll be amazed if this works :)
20:37:40 <copumpkin> I've wanted this datastructure for a while
20:38:06 <Cale> Fingertree is nice for that
20:38:28 * copumpkin tries to figure out if he'll need Min/Max for anything too
20:38:36 <Cale> It gets you asymptotically optimal implementations of lots of stuff quickly
20:38:42 <mm_freak> although i think i can optimize the type checking by keeping a stack of innermost indices
20:39:30 <Cale> and the idea behind it, just the simple idea of a monoidally indexed tree, is something I'm amazed isn't being taught in every undergrad CS course :P
20:39:31 <copumpkin> Cale: anything stopping me from having "duplicate" keys by the map-style lookup?
20:39:35 <copumpkin> yeah
20:39:40 <Cale> (it is taught for some specific monoids)
20:39:58 <Cale> There's nothing stopping you
20:40:04 <Cale> your lookup is going to split the tree
20:40:08 <copumpkin> I get it in principle but have never really worked through the details
20:40:08 <copumpkin> yeah
20:40:19 <Cale> and then you just have to grab all the elements from there
20:40:25 <copumpkin> cool
20:40:31 <Cale> it's still up to you to keep them in order
20:40:38 <copumpkin> yeah
20:41:41 <wli> Cale: http://hpaste.org/67521 <— the Newton series bit I went on about, still a bit inefficient, but I'm not doing anything more with its implementation (I may use it for twiddling with some numbers)
20:41:50 <Cale> Heh, in fact, you could do two splits and extract the entire fingertree of the ones which match that key
20:42:01 <copumpkin> yeah, I was thinking of doing that :)
20:42:10 <copumpkin> can you guess what this structure is for, by the way?
20:42:38 <rwbarton> i was trying to figure that out
20:42:42 <copumpkin> :P
20:42:54 <wli> I'd just use an expression graph and label some nodes with their associated identifiers or some such.
20:43:24 <Cale> I haven't really got any idea... maybe something to do with probability?
20:43:33 <copumpkin> it might be kind of an obscure application, but I'm sure something like it is used a lot
20:43:52 <copumpkin> it's actually for representing orders on an exchange
20:44:20 <copumpkin> and to be able to efficiently compute how new orders intersecting existing orders will affect things
20:44:43 <Cale> wli: What do Newton generating series count? It seems like some sort of labelled structures...
20:45:15 <copumpkin> the two numbers are price and quantity, and you want to be able to look up (possibly duplicate) orders by price, but also chop up the depth by cumulative order value (Sum (price * quantity)) and also by cumulative quantity (Sum quantity)
20:45:58 <wli> Cale: I've never seen a combinatorial interpretation, but it's plausible. Mostly I anticipate using them where finite differences are wanted elsewhere and products happen.
20:46:38 <Cale> wli: It looks remarkably similar (though slightly different) to series on the basis (x;n)
20:46:44 <Cale> (binomial coefficient)
20:47:28 <wli> Cale: They're usually written C(x+n, n) or some such.
20:47:46 <Cale> Yeah, it's a modified version of that
20:47:55 <Cale> right, you have (x+n; n)
20:49:43 <Cale> The product without that extra n at the top is (x;n) (x;m) = sum over 0 <= k <= m of (m+n-k; k, m-k, n-k) (z; m+n-k)
20:49:54 <Cale> which has a nice combinatorial interpretation
20:49:55 * hackagebot resourcet 0.3.2.1 - Deterministic allocation and freeing of scarce resources.  http://hackage.haskell.org/package/resourcet-0.3.2.1 (MichaelSnoyman)
20:51:15 <Cale> where you take two structures labelled with {1,...,n} and {1,...,m} respectively, and you've glued them together at their first k labels, and redistributed the remaining labels between the rest in all possible ways
20:51:31 <Cale> (keeping things in order)
20:52:00 <Cale> hopefully that makes sense... it's a bit hard to explain clearly :)
20:52:26 <Cale> But you end up with a structure with m+n-k labels
20:52:31 <wli> I'm very close to crashing, combinatorial interpretations are of interest, though.
20:52:58 <Cale> and related to this is the falling factorial basis
20:53:32 <Cale> (this is to exponential generating series what the falling factorial is to ordinary generating series)
20:53:58 <Cale> (x)_m (x)_n = sum over k = 0 to m of (m;k)(n;k) k! (x)_(m+n-k)
20:54:58 <Cale> and you can interpret that coefficient there as picking k subobjects from each of the structures of weight n and m respectively, and choosing a bijection between them to identify them
20:55:12 <Cale> So it's all possible gluings
20:56:34 <Cale> Is there a straightforward identity for (x+n;n) (x+m;m) as a linear combination of (x+k;k)'s?
20:56:58 <Cale> actually you may already have one there...
20:57:16 <wli> I think there has to be.
20:57:29 <wli> Heck, substitute y = x + n and use your identity.
20:58:02 <wli> Maybe not.
20:58:13 <Cale> yeah, doesn't quite work out
20:58:30 <Cale> because you end up with a (x+n;m+n-k) or something
20:58:51 <Cale> where you want a (x+(m+n-k);m+n-k)
20:59:30 <Cale> But we have a general formula for the convolution there
20:59:49 <Cale> So, we're not far, just have to plug in simple things for A(z) and B(z)
21:02:41 <rwbarton> (x+n;n) is related to something like (-(x+1);n)
21:02:49 <rwbarton> if I understand what you mean by (x;n)
21:05:59 <mm_freak> i think i found an efficient way to implement de bruijn indices
21:06:12 <mm_freak> i just shouldn't use Map =)
21:08:42 <Cale> oh
21:08:56 <Cale> I have a combinatorial interpretation of sorts, I think...
21:08:57 <copumpkin> Cale: is there a big difference between using First and Last for the plain lookup monoids?
21:09:30 <Cale> copumpkin: I honestly forget, but I doubt it.
21:09:47 <Cale> It seems like it shouldn't matter
21:09:50 <copumpkin> yeah
21:10:32 <Cale> oh, this is actually really nice
21:10:46 <copumpkin> ?
21:11:48 <Cale> the combinatorial interpretation of these Newton series things which wli has been studying
21:12:29 <wli> Cale: You figured it out? What is it?
21:15:06 <Cale> If we take something of weight n and something of weight m, then in the product, we have sum over k from 0 to n+m-k of (n+m-k; k, n-k, m-k) things
21:16:38 <Cale> and this is like taking two labelled structures, and gluing them together at their first k labels, but then redistributing the n+m-k labels between the three parts in all possible ways
21:17:35 <wli> Works for me. Now I drop.
21:17:53 <Cale> So whereas with the (x;n) basis, we only redistributed the labels between the unglued portions, with the (x+n;n) basis, we're allowed to have any labels on the glued section as well
21:18:24 <Cale> (which might be considered more natural in a lot of cases)
21:18:59 <Cale> It's too bad these things are only a polynomial basis...
21:19:10 <Cale> hmm
21:20:05 <Cale> actually, no, they should be fine for formal power series, I think...
21:21:53 <Cale> I wonder what sum over n >= 0 of (x+n;n) is. Mathematica says HypergeometricPFQ[{1 + x}, {}, 1]
21:21:58 <Cale> which is oddly appropriate
21:22:12 <Cale> seeing as this is analogous to 1/(1+x) in a certain way
21:22:28 <Cale> er, no 1/(1-x) rather
21:22:33 <Cale> derp, not as nice
21:26:11 <Cale> It also doesn't appear to converge much. Not that I tend to care about that :P
21:27:10 <Cale> oh, no, actually I do care here
21:27:20 <Cale> It doesn't converge in the combinatorial sense either
21:27:33 <Cale> because there are infinite contributions to the coefficient of 1
21:27:44 <Cale> (and all the other terms)
21:28:06 <Cale> So yeah, no hope of using these things to count infinite sets
21:28:21 <Cale> Or not much anyway
21:37:15 <Cale> Or hmm, do we just need to rethink our topology a bit and grade the ring differently? If we have something of weight n in the product, then all the contributions to that term should come from looking at things of weight less than or equal to n -- if either structure starts out with weight more than n, then the result will have weight more than n as well, no matter how we glue them.
21:39:57 <Cale> So I think it should be perfectly okay to work with formal infinite series on the basis (x+n;n) -- you just can't turn them into ordinary power series.
21:41:07 <Cale> and we should be able to do infinite sums and such, but we don't have the luxury of pre-existing notations for anything much
22:03:08 <monochrom> the damage is done. I have suggested the absurd: http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/22065
22:03:36 <mendez> monochrom: lol
22:04:08 <monochrom> oh darn, instead of OverloadedList, maybe TypeDirectedListResolution is more funny :)
22:04:17 <Twey> Heh
22:04:34 <Twey> If you leave out the c -> e, you get OverloadedStrings for free
22:07:57 <nyingen> Since haskell beginners aren't frightened much by monads anymore, we should expose them to iteratees instead
22:08:06 <nyingen> iteratee-based hello world, etc
22:08:22 <Twey> ITYM conduits
22:08:53 <monochrom> how do I go from Iteratee IO to IO?
22:09:03 <nyingen> iteratees are the most unintuitive thing ever
22:09:08 <monochrom> oh wait, that actually has an answer...
22:09:09 <Twey> Haha
22:09:19 <nyingen> every time I think I've figured out how they work, my code results in a maze of type errors
22:09:24 <Twey> Heh
22:09:26 <MaskRay> Could someone explain the rationale beneath in the transition from unit () to Void in Conduit-0.4 ?
22:09:57 * hackagebot tablestorage 0.1.0.1 - Azure Table Storage REST API Wrapper  http://hackage.haskell.org/package/tablestorage-0.1.0.1 (PhilFreeman)
22:10:04 <mendez> i know i do too much lisp when i yell "go what i mean!" at ghc
22:10:14 <mendez> *do
22:10:42 <Twey> MaskRay: I guess because it doesn't take any input values
22:11:18 <Twey> Semantically it might be a little nicer to say Void than to say (), which has a value… assuming you never have to pass anything there
22:15:12 <MaskRay> Suppose we do not have any backward compatibility, then should putStr and many others be made to ... -> Void
22:17:15 <MaskRay> Perhaps there is a way to differentiate Source, Conduit and Sink
22:18:45 <MaskRay> Void has a hint that either `i'(input) or `o'(output) is not used
22:32:31 <glguy_> MaskRay: Which putStr?
22:32:47 <Twey> MaskRay: Hmn, no, because as monads they have to provide something to the computation that follows them
22:33:11 <Twey> It would be a nasty hack to pass undefined or something into the continuation
22:33:43 <Twey> Void is good only when there is no way to get at the value and no need to pass it
22:34:10 <glguy_> Void is for inputs you don't touch, () is for outputs you trivially produced
22:38:07 <mysticc> Why there is no native haskell database (not talking about inmemory acid-state) ?
22:39:41 <copumpkin> mysticc: probably because someone hasn't written one yet.
22:40:49 <mysticc> copumpkin: How difficult and useful will it be to write one .
22:41:51 <tgeeky> mysticc: that depends on the design, features, performance?
22:42:03 <tgeeky> i'm surprised there isn't a native db of some sort
22:42:13 <tgeeky> (if that's true)
22:42:46 <mysticc> tgeeky: What kind of features will one be interested in ..
22:43:28 <tgeeky> mysticc: atomicity? paralleism? concurrency? SQL? network database? storage structure?
22:43:56 <tgeeky> all of the questions you'd ask when making your own db elsewhere, which I've never been brave enough to try
23:01:34 <abdulsattar> `sequence (repeat (putStrLn "hello")) >>= return . take 10' goes on inifinitely because laziness wont work this case, right?
23:01:34 <lambdabot> abdulsattar: You have 1 new message. '/msg lambdabot @messages' to read it.
23:02:39 <abdulsattar> @messages
23:02:39 <lambdabot> You don't have any new messages.
23:03:09 <abdulsattar> byorgey: `sequence (repeat (putStrLn "hello")) >>= return . take 10' goes on inifinitely because laziness wont work this case, right?
23:28:53 <Axman6> why the hell are the defaults for HsColour so dumb. black background, with no obvious way to change it? wtf?
23:45:26 <jfischoff> Is there a trick for getting around writing a monadic version and pure version of function, if both are needed?
23:45:50 <jfischoff> can one be derived from the other in certain cases in some automated fashion?
23:47:08 <blackdog> jfischoff: what do you mean by a monadic version?
23:47:20 <jfischoff> fold and foldM for instance
23:47:34 <blackdog> ie, if you have f :: a -> b -> c -> d, you can easily translate that to fm :: a->b->c -> m d
23:47:53 <jfischoff> by hand or with a tool?
23:51:27 <blackdog> jfischoff: it might be possible to automate for simple cases, but usually it's not simple
23:52:06 <jfischoff> blackdog: I bet. Its annoying when it is simple. I wonder if it is simple if I am doing it wrong :(
23:52:20 <blackdog> for instance, the fold & foldM things are only lightly related - how would an automated tool know that the function exists in the monad, but not the initial value?
23:52:28 <blackdog> :t foldl
23:52:29 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
23:52:33 <blackdog> :t foldM
23:52:34 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
23:53:01 <Cale> jfischoff: Well, what does it mean for a monadic version of a function to be the monadic version of that function? :)
23:53:06 <blackdog> jfischoff: one insight that may help is that often, you can cast things in applicative syntax
23:53:19 <jfischoff> yeah, I am not interested in something that works in all cases. Djinn can only derive some functions, its still useful.
23:53:38 <Cale> jfischoff: It usually means that if you use the identity monad, it reduces to the original thing.
23:53:43 <jfischoff> Cale: if it is polymorphic in the result
23:53:48 <jfischoff> yep
23:53:49 <blackdog> if you ever find yourself writing "do a <- getA; b <- getB; return $ c a b", you can replace that with "c <$> getA <*> getB"
23:54:03 <Cale> So you can use runIdentity to extract the plain version
23:54:07 <jfischoff> Cale: but I don't want to have to call runIdentity for the pure one
23:54:14 <jfischoff> noise
23:54:31 <jfischoff> I guess I could just hide it
23:54:44 <jfischoff> through the interface I offer
23:55:36 <jfischoff> Yeah alright, it seems obvious in hindsight
23:58:41 <burbul> @djinn Ord a => [(a,b)] -> [(a,[b])]
23:58:41 <lambdabot> Error: Undefined type []
23:59:00 <burbul> ^^?
23:59:29 <burbul> Ord a => List (a,b) -> List (a,List b)
23:59:34 <burbul> @djinn Ord a => List (a,b) -> List (a,List b)
23:59:35 <lambdabot> Error: Undefined type List
23:59:58 <burbul> any ideas?
