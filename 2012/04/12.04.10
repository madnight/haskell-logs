00:02:56 <zzo38> And (Cologic []) is the non-empty list comonad too
00:04:30 <zzo38> I also think the instance Alternative (and MonadPlus) for Free is wrong too
00:07:04 <zzo38> From what I can think, the only possible proper instance would be:    empty = Free empty; Pure x <|> _ = Pure x; _ <|> Pure x = Pure x; Free x <|> Free y = Free (x <|> y);
00:07:31 <zzo38> Maybe that's wrong too......
00:08:02 <zzo38> No, I think it seems correct
00:10:22 <zzo38> It makes (Free Finalize) act like Maybe
00:12:44 <zzo38> The way they have it now is clearly not following the identity law
00:15:45 * hackagebot soyuz 0.0.0 - DCPU-16 architecture utilities for Notch's 0x10c game.  http://hackage.haskell.org/package/soyuz-0.0.0 (AlexKropivny)
00:16:40 <zzo38> Can you please fix it?
00:21:13 <zzo38> I think the default zipped applicative for Cofree will be (Cofree Maybe) like non-empty ZipList
00:29:01 <khs> Hi, is there a irc channel for cabal developers?
00:29:12 <Axman6> khs: you might try #hackage
00:29:36 <bxc> is it to complain about how profiling doesn't interact nicely with cabal?
00:33:05 <khs> no
00:35:11 <Axman6> bxc: works fine, if you turn on profiling by default
00:48:54 <sopvop> Why the hell have I googled "yesod vs happstack vs snap". Just lost 3 hours of my life and still can't choose one to use on a project :(
00:55:47 <Axman6> sopvop: yesod is probably the best documented, i'd recommend going with that
00:55:59 <bombel8> @sopvop just go through tutorials and docs quickly and see which has more clear and easy to get knowledge base
00:56:00 <lambdabot> Unknown command, try @list
00:56:54 <bombel8> i'm newbie and i die when i'm reading Real World Haskell chapter when he parses images, i have read all except this one with good understanding.
00:57:07 <bombel8> why when i read it i think my mind is melting ;/
00:57:59 <c_wraith> bombel8: real world haskell isn't really intended as a beginner's book.  It's a book for transitioning from "I understand the syntax and concepts" to "I see how to use this to build real software"
00:58:43 <Axman6> bxc: feel free to ask questions about what's confusing you though. we're very helpful here
00:59:04 <c_wraith> bombel8: I think Axman6's comment was intended for you.  Also, true. :)
00:59:33 <Axman6> uh, yes
00:59:43 <Axman6> sorry bxc =)
01:00:05 <Axman6> bitonic: what's confusing you?
01:00:31 <Axman6> argh, bombel8, not bitonic
01:00:34 <bombel8> i think after years of imperative programming switching to pure functional is a pain
01:00:53 <Axman6> bitonic: it's supposed to be, to punish you for all the time you've spent sinning ;)
01:01:00 <bombel8> i was doing erlang but it is much easier then Haskell haskell has insane amount of "new syntaxes" each corner :D
01:01:05 * Axman6 ragequits and learns to type
01:01:25 <bitonic> Axman6: :)
01:02:04 <c_wraith> bombel8: much of the syntax isn't actually for new ideas though.  Most of haskell's new ideas are in the easy syntax.  The edge cases are just convenience stuff.
01:02:23 <sopvop> I've looked through tutorial on all of them. Yesod tutorials are all about TH and the like, and it looks like much automagic for me. Which is not nice. I've used django once (and yesod looks pretty much like django), and automagic usually bites you in the end. Looks easier to begin though.
01:02:32 <bitonic> bombel8: Haskell syntax is not much bigger than erlang in the end. a lot of stuff overlaps
01:03:35 <bombel8> yeah erlang syntax set is tiny comparing to haskell
01:03:52 <mm_freak> sopvop: there isn't as much automagic going on in yesod as you might think, and it really doesn't bite you
01:03:57 <bombel8> and when someone uses "flip" in haskell is get blackout
01:04:07 <nus> @src flip
01:04:08 <lambdabot> flip f x y = f y x
01:04:17 <bitonic> bombel8: it's not much smaller. 'flip' is not syntax, it's just a function
01:04:38 <mm_freak> sopvop: i recommend going with yesod if you want to get things done quickly…  it comes with batteries included, but doesn't prevent you from using your own batteries, if you want to
01:05:24 <bombel8> yeah i know flip is not syntax most confusing thing for me is now | thing for (if / case like syntax)
01:05:39 <mm_freak> for example i use yesod without scaffolding and with acid-state instead of its builtin database abstration
01:05:46 <bombel8> @src putStrLn
01:05:46 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
01:05:51 <bombel8> wow
01:05:57 <Axman6> bombel8: do you mean guards?
01:06:02 <bitonic> bombel8: really? | is like 'when' in erlang but better
01:06:04 <bombel8> yes guards
01:06:18 <bitonic> (you can have multiple cases)
01:06:24 <bombel8> i like improved pattern matching also this rox
01:06:44 <bombel8> but often i have to split my functions into 3-5 support functions
01:07:51 <sopvop> Yeah, think I'll use yesod. I really like yesod's templates, how easy it would be to use them with other web servers and routes if I decide to switch later? Also, It looks like persistent (models) and forms are too coupled, how easy it would be to use forms without persistent?
01:08:23 <bombel8> yesod uses something like haml for templating ye ?
01:08:32 <bitonic> bombel8: no, yesod is a web framework
01:08:44 <bombel8> but for generating html
01:08:45 <bitonic> it includes a templating system
01:08:50 <sopvop> they have hamlet
01:08:57 <bombel8> haml is evil
01:08:59 <bitonic> bombel8: not specifically, it can do that of course
01:09:17 <bombel8> one problem i had was that nobody else wanted to coop with me using haml like designers or ux people
01:09:28 <bombel8> so i had to translate it back and forward ;/
01:11:42 <sopvop> hamlet looks like html without closing tags, pretty clean
01:13:08 <mm_freak> hamlet is like layout-based HTML
01:13:30 <bombel8> oh yesod homepage now looks much better, i used to look at it ages ago and it was so poor.
01:13:42 <bombel8> thanks for help guys :)
01:13:42 <mm_freak> the docs state that hamlet is inspired by haml
01:13:53 <mm_freak> sopvop: forms are not in any way coupled with persistent
01:14:01 <mm_freak> as said, i use yesod without persistent entirely
01:15:41 <mm_freak> sopvop: it's just that if you have a record type you can easily make a form for it…  there is a convenient applicative language to do it
01:16:07 <mm_freak> if that one isn't flexible enough there is also a monadic language, but usually you would want to go with the applicative one
01:16:46 <sopvop> Oh, I just misunderstood 1.0 introduction screencast forms part.
01:20:35 <sopvop> mm_freak: Is it possible to generate persistent stuff for externally defined data types, not in model?
01:21:37 <mm_freak> sopvop: well, you can always write the class and type instances yourself, but it's not very convenient
01:21:40 <sopvop> I mean, I could write instances by hand. but something like $(generateFoo 'blah) would be nice.
01:21:45 <sopvop> :)
01:22:06 <mm_freak> otherwise i don't think so…  you'll have to write everything manually
01:22:28 <mm_freak> you can also have an isomorphic type in your model and define mappings between that one and the external type
01:24:44 <sopvop> Good idea, thanks
01:30:19 <dropfatdiva> hi, i am trying to understand category theory specific to haskell from Steve Awodey's book on Category theory. Is it recommended to go through all chapters rigorously or just by reading some specific chapters, one can get a good grip of all concepts used in Haskell?
01:31:46 <roconnor> dropfatdiva: FWIW, the only book on category theory that I've been able to understand is Barr & Well's "Category Theory for Computing Science"
01:31:46 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
01:34:17 <roconnor> dropfatdiva: though I've never tried Awodey's book
01:35:06 <Cale> dropfatdiva: If you're not familiar with a lot of mathematics already, it's probably better to read the chapters in order.
01:35:59 <Cale> If you've already had courses in commutative algebra or something which uses a lot of categorical concepts without quite treating them as such, it's possible that you might be able to skip ahead.
01:36:24 <Cale> Well, hmm...
01:36:28 <nus> dropfatdiva, http://www.haskell.org/haskellwiki/User:Michiexile/MATH198 is a good outline
01:36:53 <Cale> If you're just trying to understand monads from a categorical perspective, say, then it's not *really* necessary to understand all that classical stuff about limits.
01:37:58 <Cale> So you can try just familiarising yourself with the concepts of categories, functors and natural transformations, and then jump right in. You might also watch some of the videos on TheCatsters YouTube channel.
01:38:22 <dropfatdiva> roconnor|cale: Well, I've only read one chapter yet which seemed reasonably understandable. I dont have background in categorical concepts and my foray into category theory is only because of Haskell. So all concepts like limits, equalizers etc. seemed a bit extraneous
01:38:50 <shachaf> dropfatdiva: Are you reading this book in order to learn Haskell?
01:38:53 <Cale> dropfatdiva: Yeah, well, there's a nice way to relate limits to recursion/fixed point theory.
01:39:12 <Cale> If your goal is just to understand Haskell, then learning CT is extraneous.
01:39:49 <Cale> (Because you can do perfectly fine entirely without that background)
01:39:59 <dropfatdiva> i am reading this book to understand why haskell is based on category theory..because it seemed to be the first/only? language based on it
01:40:27 <Cale> We steal concepts from category theory because it's a rich library of abstractions which are waiting to be stolen. :)
01:41:05 <Cale> I like to think of CT as a useful tool when you're studying some new area and you don't quite know what the right definitions to be thinking about are.
01:41:30 <Cale> It can provide strong generalised suggestions which have worked well in many other settings.
01:41:45 <roconnor> CAML stands for categorical abstract machine langauge.
01:41:50 <Cale> indeed
01:42:19 <Cale> People have been applying category theory to the semantics of programming languages for a while, and it started leaking into the actual programming languages that those people designed.
01:43:00 <Cale> and the libraries too :)
01:43:03 <Cale> (like with monads)
01:43:46 <dropfatdiva> i have some background in scala, so i am aware of a lot of functional concepts used in Haskell including the type system etc. Other strong point or point that i didnt/dont know about Haskell is category theory. Wish there was something explaining Category theory in plain Haskell terms. Also what led me to category theory was the Typeclassopedia paper
01:44:18 <dropfatdiva> Thanks for all your inputs. Didnt know CAML was based on Category theory too.
01:44:27 <|Steve|> dropfatdiva: I don't find thinking about category theory helpful for understanding Haskell.
01:44:35 <Cale> Well, the point of category theory is to be general so that it can be applied in many different contexts. You can use it in those contexts without ever talking about categories in general.
01:44:55 <|Steve|> E.g., I know what a functor is, but the Functor type class has no obvious relation to it.
01:45:04 <Cale> I have found it helpful for library design :)
01:45:26 <Cale> The FRP system that we've been working on at iPwn takes some inspiration from monoidal categories.
01:45:45 <Cale> (symmetric monoidal categories)
01:46:17 <Cale> But if you don't know about all that stuff, you can still go about your business of writing programs without it without missing much.
01:49:01 <dropfatdiva> That's my point. I have found that people who have better category theory background to have much better understanding of haskell. I do understand that I can write programs without understanding Category theory completely since most libraries would designate some real-life use. But I would certainly like to get a taste of some general category theory concepts in its mathematical form. So I'll look at  Barr and Wells since its 
01:49:09 <dropfatdiva> and go from there.
01:49:20 <dropfatdiva> Thanks everybody for their replies!
01:50:48 * hackagebot ministg 0.3 - an interpreter for an operational semantics for the STG machine.  http://hackage.haskell.org/package/ministg-0.3 (BerniePope)
02:08:16 <osager> hi all in a module definition, what does for example Tree(..) mean ? those two dots
02:08:37 <Cale> osager: export all the constructors of that datatype as well
02:08:38 <roconnor> osager: all the constructors for Tree
02:08:53 <osager> thank you all
02:09:15 <osager> what if i dont have those dots ?
02:09:31 <osager> it means i wont export the constructors ?
02:09:37 <roconnor> osager: right
02:09:55 <roconnor> osager: you can also export individual constructors by name e.g. Tree(Leaf)
02:10:25 <osager> and this is only for data types, not functions ?
02:11:03 <roconnor> yes
02:11:18 <osager> great
02:11:19 <osager> thanks
02:45:31 <ksf__> http://www.reddit.com/r/haskell/comments/s0vln/ghc_head_now_has_type_level_natural_number/
02:45:32 <ksf__> \o/
02:47:34 <ion> cool
02:52:05 <dibblego> roconnor: you there?
02:52:14 <dibblego> nullPL is missing a "not"
02:52:22 <dibblego> or s/isJust/isNothing
02:53:09 <t7> anyone know a babbys first guide to writing arbitrary precision arithmetic ?
02:57:03 <quicksilver> t7: some links here : http://www.haskell.org/haskellwiki/Exact_real_arithmetic
02:57:15 <quicksilver> (CReal is an implementation of Vuillemin's ideas I believe)
03:05:50 * hackagebot select 0.1 - Give the select(2) POSIX function a simple STM interface  http://hackage.haskell.org/package/select-0.1 (GardSpreemann)
03:10:50 * hackagebot stm-split 0.0 - TMVars, TVars and TChans with distinguished input and output side  http://hackage.haskell.org/package/stm-split-0.0 (HenningThielemann)
03:15:53 * hackagebot concurrent-split 0.0 - MVars and Channels with distinguished input and output side  http://hackage.haskell.org/package/concurrent-split-0.0 (HenningThielemann)
03:22:14 <t7> x86 is little endian so 0x112233ff is stored in memory as ff332211 ?
03:23:10 <cheater> endianness means swapping every second byte
03:23:42 <cheater> so iirc it would be 2211ff33
03:24:09 <t7> wikipedia doesnt say that...
03:24:39 * cheater checks
03:25:25 <earthy> that depends on the atomic element size, cheater
03:26:49 <sipa> t7: it is stored as the byte array {0xff,0x33,0x22,0x11}
03:27:13 <sipa> and it is that way for every little-endian architecture alive today, afaik
03:27:24 <t7> why do they switch numbers
03:27:32 <t7> nothing is ever simple in IT
03:27:44 <sipa> "switch" ?
03:28:10 <sipa> except when parsing or printing number, the cpu never sees any big-endian value
03:28:10 <t7> most significant unit in standard notation is to the left
03:28:16 <sipa> for humans, yes
03:28:20 <cheater> earthy, i was just going to comment on that
03:28:50 <danbst> Hello guys! How to convert list of tuples(,) to tuple of lists?
03:29:00 <sipa> t7: for example, i have a pointer to a 32-bit integer in memory, but want to pass this to a function that expects a pointer to a 16-bit integer
03:29:17 <t7> ah yeah that makes sense
03:29:17 <sipa> t7: in litte-endian, you can just use that pointer (at assemble level)
03:29:27 <sipa> in big-endian, you need to add 2
03:30:06 <opqdonut> danbst: unzip
03:30:09 <opqdonut> :t unzip
03:30:10 <lambdabot> forall a b. [(a, b)] -> ([a], [b])
03:30:14 <quicksilver> Foreign.Marshal.Alloc Foreign Numeric> alloca (\wordptr -> poke wordptr (0x112233ff :: Word32) >> fmap (map (\x -> showHex x "")) (peekArray 4 (castPtr wordptr :: Ptr Word8)))
03:30:17 <quicksilver> ["ff","33","22","11"]
03:30:19 <quicksilver> t7: ^^
03:30:29 <quicksilver> (which just confirms what sipa has been saying)
03:30:40 <quicksilver> that was run on x86.
03:30:50 * quicksilver doesn't have a PPC machine to hand to compare + contrast.
03:30:54 <danbst> opqdonut: thanks!
03:32:57 <mekeor> i've got a question regarding >>=. here it is:
03:32:57 <hpaste> mekeor pasted “do-notation as >>=” at http://hpaste.org/66756
03:35:30 <mekeor> :t (>>=)
03:35:30 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
03:36:13 <mekeor> so, yes, it is; right? is it? yes. really? no? but yes, it is. i'm not sure. are you?
03:36:31 <quicksilver> mekeor: the difference between those two fragments is that "x" remains in scope in the first
03:36:45 <mekeor> quicksilver: good.
03:36:52 <mekeor> quicksilver: thank you.
03:37:04 <mekeor> quicksilver: the ONLY difference, right?
03:37:11 <quicksilver> mekeor: also calling "monadicFunction" a monadic function may be confusing, since it doesn't appear to be a function.
03:37:23 <quicksilver> that's the only difference I can think of.
03:37:52 <mekeor> okay.
03:38:00 <mekeor> quicksilver: how would you call it, btw?
03:38:14 <quicksilver> mekeor: I tend to call them "actions"
03:38:32 <quicksilver> "values" is quite reasonable but, obviously, rather generic.
03:38:47 * int-e agrees with 'action'
03:38:47 <mekeor> ah, yea, "action" is nice.
03:39:07 * mokus likes the term "procedure" because it already has the connotations of "function with effects"
03:39:34 <mokus> i use "action" too though
03:39:43 <mokus> and "procedure" mostly if the monad in question is IO
03:40:30 <quicksilver> mokus: "not a function" with effects ;)
03:40:37 <quicksilver> but yes, procedure works fine
03:40:53 <quicksilver> it just causes pathological pascal flashbacks which impair my normal faculties a bit.
03:40:54 <mokus> well, "like a function but with effects" is more what i meant
03:41:10 <hpaste> mekeor pasted “quicksilver: this was my problem” at http://hpaste.org/66757
03:41:11 <mokus> in the C sense of the word "function"
03:41:22 <mekeor> quicksilver: ^
03:41:30 <quicksilver> mekeor: right.
03:41:43 <mekeor> thanks once more
03:41:59 <quicksilver> because "otherAction $ foo" is not a valid sub-part of "otherAction $ foo x"
03:42:20 <quicksilver> much like "6 + 3" is not a sub-part of "6 + 3 * 5"
03:42:26 <mokus> the nice thing about "procedure" is that it causes imperative programmers less confusion too - you just explain that what they think they know already about "functions vs procedures" is enforced strictly by Haskell
03:42:38 <mekeor> quicksilver: hah. nice example, yea.
03:43:04 <quicksilver> one of the reasons people like to use (.) instead of ($)
03:43:15 <quicksilver> is precisely to make that transformation you just did more natural.
03:44:03 <mekeor> cool.
03:45:05 <quicksilver> so you could have written it as otherAction . foo $ x
03:45:07 <quicksilver> in the first place
03:45:30 <mekeor> yep
03:47:08 <talin> hello. what programming language is haskell written in?
03:47:27 <Cale> talin: There's more than one implementation
03:47:37 <Cale> talin: But GHC is written in Haskell
03:48:24 <talin> Cale: oh. thank you
03:48:43 <quicksilver> (mostly, and some Cmm and some C and perhaps a little assembly)
03:49:01 <mokus> and some crazy perl unless the mangler is gone now ;)
03:49:16 <danbst> I was always wondering, how language can be written with in self. That's like egg and a chick )
03:49:47 <mokus> typically you start with an interpreter for a small subset of your language, write the first compiler in that, and then go from there
03:50:31 <mokus> (a simple interpreter so you don't waste too much time on it)
03:50:33 <quicksilver> mokus: the mangler is gone.
03:50:43 <quicksilver> mokus: (in the sense that the default backend no longer uses it)
03:50:48 <mokus> ah, ok - doesn't surprise me, i know they've been wanting it gone a long time
03:51:03 <quicksilver> I think the via-C backend does still exist, but it may be deprecated now.
03:51:15 <mokus> yea, i believe that is the case
03:51:48 <quicksilver> you may also use another implementation for your first version
03:51:53 <quicksilver> and move to self-hosting later.
03:52:02 <quicksilver> JHC is a haskell compiler which was developed with GHC, for example.
03:52:08 <quicksilver> not sure if it self-hosts.
03:52:12 <mokus> yea, that's what you do when you're not writing the very first implementation of the language
03:52:43 <quicksilver> mokus: the GHC authors were not writing the first.
03:53:18 <mokus> i know, I was just answering the question in general - because it's the basic chicken and egg problem that I assume is the hard part to grasp
03:53:22 <talin> is haskell a general-purpose language, or is it trying to be better at some niche thing like Go trying to be a network server lang?
03:57:54 <mokus> talin: I'd say it's a general purpose language, but it does have a bit of a 'niche' as a language researchers modify to test their ideas
04:00:36 <talin> mokus: i see
04:01:13 <talin> i read an article yesterday, saying that haskell is probably going to be good for multicore programming
04:01:21 <mokus> it doesn't have as big a community churning out libraries as, say, python, but the libraries it does have are extremely diverse
04:01:41 <mokus> yea, there's a lot of impressive work in that area for Haskell
04:01:58 <mokus> i wouldn't call it Haskell's "niche", though, just something it happens to be pretty good at
04:02:13 <mokus> "niche" to me implies that it's the only thing it's good at ;)
04:02:30 <talin> yep, it's probably not the right word
04:02:36 <mbuf> is there a Haskell bot (with source) that people recommend?
04:02:56 <mekeor> is there something like findM, that is findM :: (a -> m Bool) -> [a] -> Maybe a -- ?  what could i use instead?
04:03:05 <talin> what concerns me though, is that i'm not sure that "most people" are capable or willing to learn haskell. mostly because they are lazy and unwilling to change their habits
04:03:19 <bitonic> mbuf: well, lambdabot source is available... but I wouldn't reccomend reading it
04:03:22 <quicksilver> mekeor: there is pretty much a shortage of generic "loop-like" monad combinators int he standard library.
04:03:35 <quicksilver> mekeor: just replicateM, mapM, forM, and friends.
04:03:43 <quicksilver> mekeor: there is control.monad.loops on hackage
04:03:50 <opqdonut> mekeor: filterM will get you pretty far
04:03:59 <mekeor> thanks guys =)
04:04:03 <mekeor> you're awesome.
04:04:09 <mokus> talin: that may be true, but "most people" probably won't need to - computers are fast enough now that most people's code really doesn't need the last bit of performance that can be wrung out
04:04:27 <mbuf> bitonic: thanks
04:04:55 <mokus> talin: and also, Haskell is gradually becoming easier to learn, IMO, because of better idioms, better teaching materials, and better APIs for commonly-used libraries
04:05:14 <mokus> talin: not to mention the way more and more of its ideas are creeping into languages that those people already know
04:05:49 <talin> mokus: good point. it certainly is the most exciting language i have ever seen
04:06:07 <mokus> i don't think it'll ever be as easy to dive into as python or ruby, but it can certainly keep getting easier than it is now
04:07:25 * mokus just hopes that if it ever does _really_ take off, the haskell community doesn't get crushed by the inrushing multitudes like so many other great communities before it
04:07:41 <mokus> because that's one of its great assets too
04:08:32 <xcvd> 'learn you a haskell for a great good' is nice , friendly and free
04:10:00 <covi> Hi guys I'm looking for the following function: if I have a string "123", I want to insert each of ['a'..'z'] after every char, and return a list. E.g. ['1a23', '1b23', .., '12z3', ...]
04:10:16 <mokus> yea, i think that's one that lowered the barrier to entry in the past, even if only a bit - it's less "correct" than what existed before but seems to be more effective as a teaching tool
04:11:50 <mekeor> covi: just split the function into smaller once and solve each small problem itself first.
04:12:25 <Cale> covi: I recommend starting with a function which produces all ways of splitting the string into two parts
04:12:53 <mekeor> covi: also take a look at Data.List, e.g. splitAt could be useful.
04:13:08 <mekeor> Cale: yea, therefore, splitAt is nice, isn't it?
04:13:24 <covi> aha
04:13:39 <covi> map (splitAt (1)) xs?
04:13:47 <covi> wrong...
04:14:07 <covi> anyway I think I got your point, Cale & mekeor
04:14:15 <Cale> mekeor: Reasonably so. There's a way to do it without using indices or having to compute the length of the list, but it'll work reasonably well :)
04:14:39 <mekeor> > let str = "123" in map (\i->splitAt 1 str) [1..length str]
04:14:39 <lambdabot>   [("1","23"),("1","23"),("1","23")]
04:14:42 <mikeplus32> what's the "standard" way to store the output of a command?
04:14:45 <mekeor> nah
04:14:58 <mekeor> > let str = "123" in map (\i->splitAt i str) [1..length str]
04:14:59 <lambdabot>   [("1","23"),("12","3"),("123","")]
04:15:01 <ville> mikeplus32: C++ has no commands.
04:15:11 <mekeor> > let str = "123" in map (\i->splitAt i str) [1..length str-1]
04:15:12 <lambdabot>   [("1","23"),("12","3")]
04:15:17 <ville> haha wrong channel. doh
04:15:20 <mikeplus32> lol
04:15:22 <mekeor> :)
04:15:31 <covi> mekeor: nice!
04:15:38 <Lemmih> mikeplus32: What do you mean by 'command'?
04:15:54 <mysticc> @hoogle Memo
04:15:54 <lambdabot> package memoize
04:15:54 <lambdabot> Codec.Compression.Zlib.Internal MemoryLevel :: Int -> MemoryLevel
04:15:54 <lambdabot> Codec.Compression.Zlib.Raw MemoryLevel :: Int -> MemoryLevel
04:15:55 <mikeplus32> /bin/echo, /bin/cat etc
04:16:04 <Lemmih> mikeplus32: See System.Process
04:16:38 <mikeplus32> but I'm not sure how to store their output rather than just run them, because the file handles close as soon as the command has finished
04:17:34 <mikeplus32> oh, maybe I shouldn't have been using runProcess
04:17:43 <Lemmih> mikeplus32: You can put the output in a ByteString.
04:17:44 <mikeplus32> (and instead runCommand)
04:17:49 <mikeplus32> how?
04:18:11 <Lemmih> Read it from the output handle.
04:18:17 <mikeplus32> OK
04:23:39 <mysticc> mikeplus32: what about readProcess
04:23:45 <mysticc> @hoogle readProcess
04:23:45 <lambdabot> System.Process readProcess :: FilePath -> [String] -> String -> IO String
04:23:45 <lambdabot> System.Process readProcessWithExitCode :: FilePath -> [String] -> String -> IO (ExitCode, String, String)
04:23:50 <mikeplus32> that works fine
04:24:06 <mikeplus32> but I wanted something other than [Char] for the output
04:24:20 <mikeplus32> but yeah I should have just read the haddock page for System.Process
04:24:22 <covi> let str="123" in map (\i -> splitAt i str) [1..length str - 1]
04:24:24 <mikeplus32> had what I wanted at the top
04:24:37 <covi> let str="123" in map (\i->splitAt i str) [1..length str - 1]
04:25:36 <covi> let str="123" in map (\i->splitAt i str) [1..length str - 1]
04:26:00 <covi> > let str="123" in map (\i->splitAt i str) [1..length str - 1]
04:26:01 <lambdabot>   [("1","23"),("12","3")]
04:27:18 <roconnor> > zip <$> inits <*> tails $ "123"
04:27:19 <lambdabot>   [("","123"),("1","23"),("12","3"),("123","")]
04:28:09 <roconnor> > splits "123"
04:28:10 <lambdabot>   Not in scope: `splits'
04:30:22 <roconnor> > let splits []= [([],[])]; splits l@(h:t) = ([],l):(map (first (h:)) (splits t)) in splits "123"
04:30:23 <lambdabot>   [("","123"),("1","23"),("12","3"),("123","")]
04:31:09 <covi> Why there's an error when I run the above code (the map one) on my computer...
04:31:25 <covi> lexical error in string/character literal at character '2'
04:32:22 <roconnor> covi: I'm not sure; can you paste the code and the error
04:32:58 <covi> roconnor: sure! pls wait a sec
04:33:19 <mokus> my guess is missing import Control.Arrow
04:33:46 <roconnor> mokus: that wouldn't cause a lexical error
04:34:11 <mokus> oh, nevermind... i should read more lines before answering :)
04:34:19 <roconnor> mokus: no worries
04:34:31 <covi> http://hpaste.org/66758
04:35:09 <roconnor> covi: strings need to be in double quotes
04:35:11 <roconnor> on line 9
04:35:34 <roconnor> covi: single quotes are for characters
04:36:23 <covi> roconnor: thanks... I was using the Python convention.
04:52:17 <ksf__> @hoogle Int -> (a -> a) -> a -> a
04:52:17 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
04:52:17 <lambdabot> Data.Sequence adjust :: (a -> a) -> Int -> Seq a -> Seq a
04:52:17 <lambdabot> Data.IntMap adjust :: (a -> a) -> Key -> IntMap a -> IntMap a
04:52:26 <ksf__> @hoogle iterate
04:52:27 <lambdabot> Prelude iterate :: (a -> a) -> a -> [a]
04:52:27 <lambdabot> Data.List iterate :: (a -> a) -> a -> [a]
04:52:27 <lambdabot> Data.ByteString.Lazy.Char8 iterate :: (Char -> Char) -> Char -> ByteString
04:52:37 <ksf__> @hoogle iterateN
04:52:37 <lambdabot> Data.Sequence iterateN :: Int -> (a -> a) -> a -> Seq a
04:52:40 <ksf__> hmmm.
04:54:36 <ksf__> @djinn Int -> (a -> a) -> a -> a
04:54:36 <lambdabot> Error: Undefined type Int
04:54:43 <ksf__> @djinn Integer -> (a -> a) -> a -> a
04:54:44 <lambdabot> Error: Undefined type Integer
05:18:36 <ksf__> > (1:2:3:)
05:18:36 <lambdabot>   The operator `:' [infixr 5] of a section
05:18:36 <lambdabot>      must have lower precedence th...
05:18:40 <ksf__> that *ought* to work.
05:18:55 <ksf__> it's perfectly unambigious.
05:19:39 <mauke> yes, and it's an error
05:20:25 <mauke> you want it to desugar to (1 :) . (2 :) . (3 :) ?
05:20:31 <ksf__> yep.
05:20:35 <mauke> hmm
05:20:47 <ksf__> (++ "foo" ++), too.
05:22:06 <mauke> in which order?
05:22:27 <ksf__> (\x y -> x ++ "foo" ++ y)
05:23:59 <zzing> If I need to handle natural numbers, what is the best type to use?
05:24:08 <zzing> (set N_0)
05:24:20 <mauke> depends on the operations you need
05:25:27 <zzing> These are line numbers essentially, I want all the normal operations because I don't know what I will be using on them
05:26:33 <mauke> line numbers are usually small
05:26:40 <zzing> likely yes
05:26:41 <zzing> Would Integral be appropriate?
05:26:44 <mauke> so I guess Int or Integer
05:26:48 <mauke> Integral is not a type
05:27:03 <zzing> ok
05:27:34 <zzing> What is the difference between Int and Integer?
05:27:40 <hpc> > maxBound :: Int
05:27:41 <lambdabot>   9223372036854775807
05:27:46 <hpc> > maxBound :: Integer
05:27:47 <lambdabot>   No instance for (GHC.Enum.Bounded GHC.Integer.Type.Integer)
05:27:47 <lambdabot>    arising from...
05:27:57 <hpc> Integer is the "as big as you want" integer
05:28:00 <hpc> Int is a machine-word
05:28:09 <hpc> (in GHC at least; only guaranteed to be 30 bits)
05:28:49 <zzing> ok, and is there a value I can assign to an Int that is testable and not a number?
05:29:12 <zzing> I want to have a number without it being a Maybe type, but will do it if necessary
05:29:58 <mux> are you asking for some kind of null/undef value?
05:30:05 <mux> if so, use Maybe Int
05:30:08 <mux> embrace Maybe :-)
05:30:24 <zzing> Maybe :P
05:30:28 <zzing> yes it is done
05:30:30 <mux> heh
05:30:46 <zzing> I have decided to implement 'edlin' as an exercise to come back to haskell.
05:31:08 <mauke> how do you store text?
05:31:15 <zzing> Haven't decided that problem yet
05:31:21 <zzing> command parsing first
05:31:57 <zzing> I wouldn't think a list would be the best method because who knows how many lines I would have
05:32:44 <zzing> I have a class on Miranda in the summer, and need to make sure I can prepare for doing some of that kind of stuff, and also be able to clense my brain of the language afterwards. So Haskell is perfect for both :P
05:33:06 <mauke> well, list of what?
05:33:24 <zzing> String
05:34:03 <zzing> If I were doing C++, I would be using a vector most likely
05:35:34 <roconnor> a class on Miranda?
05:35:39 <bitonic> zzing: didn't Miranda die a long time ago? You should convince them to use Haskell...
05:35:48 <adu> yes
05:36:50 <adu> zzing: and you can convince them that if they can't change the class from Miranda to Haskell, then they shouldn't be teachers
05:37:07 <zzing> bitonic, You know when you have a teacher that has been there for a rather long time and has a thing for a certain language?
05:37:15 <zzing> I do hear they are actually thinking about it now though
05:37:49 <adu> zzing: Haskell is basically Miranda 2.0 anyways
05:37:52 <bitonic> zzing: yeah but that's going a bit too far, I'd have guessed that the last version of miranda was released in the late 80s :P
05:38:54 <adu> zzing: ya, using Miranda when Haskell is available is like forcing yourself to write K&R C
05:39:05 <zzing> adu, I actually liked K&R :P
05:40:00 <bitonic> adu: no, K&C is much closer to today's C than Miranda is to Haskell
05:41:18 <zzing> What datatype for storing a list of something allows for constant access by index (specifically ranges), and not horrible at doing whatever the equivalent operation to inserting would be?
05:41:51 <roconnor> zzing: constant time lookup is impossible
05:42:11 <mauke> roconnor: it's possible if you limit the maximum size
05:42:16 <bitonic> roconnor: well, you have Array/Vector
05:42:18 <zzing> roconnor, a vector in C++ can do it.
05:42:59 <mauke> zzing: Data.Sequence, maybe
05:43:03 <roconnor> zzing: a vector in C++ is limited in maximum size.
05:43:08 <bitonic> zzing: you have those kind of structures in Haskell as well (Array, Vector) but then you'll have to copy the whole thing when you want to insert. You can have hybrid structures of course, it depends what you need to do
05:43:28 <bitonic> zzing: you most likely don't need constant time access anyways, what is it that you need to do?
05:43:35 <zzing> bitonic, Well this is for an edlin implementation
05:43:51 <mm_freak> zzing: i recommend to go with logarithmic access and insertion
05:44:11 <mm_freak> you can also have a look into the unordered-containers package
05:44:17 <zzing> mm_freak, ok, what can do that?
05:44:19 <bitonic> zzing: ok, edlin seems to be an editor
05:44:23 <mm_freak> zzing: Map
05:44:37 <bitonic> what do you need to do? are you looking for a data structure to store the buffers?
05:44:45 <mm_freak> zzing: IntMap can do constant time access and logarithmic time insert
05:45:04 <mm_freak> but that "constant" is basically "bounded logarithmic"
05:45:12 <bitonic> because in that case the size of the key is limited
05:45:13 <zzing> bitonic, basically I would otherwise be doing a list of String and need to access lines by number
05:45:13 <mm_freak> it's still a speed gain though
05:45:30 <mm_freak> zzing: i found that HashMap Integer is faster than Map Integer
05:45:42 <bitonic> zzing: you still haven't told us what you're actually trying to do :P
05:45:48 <mm_freak> might be true for other types as well and in my specific case the keys were effectively random
05:45:57 <opqdonut> Maps are kind of bad for storing consecutive things
05:45:57 <mm_freak> structured keys might perform worse with HashMap
05:46:04 <opqdonut> e.g. lines of text
05:46:09 * hackagebot mathgenealogy 0.0.1 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-0.0.1 (PeterRobinson)
05:46:17 <opqdonut> inserting something in between w/o breaking indexing takes time
05:46:28 <opqdonut> whereas Data.Sequence should work nicely
05:46:29 <mm_freak> zzing: if the order isn't important and duplicates are disallowed you should use Set (or IntSet)
05:47:13 <mm_freak> if you strictly need the vector style you can go with Sequence or Vector…  Vector has very fast access, but slow insertion
05:47:23 <mm_freak> for Sequence both are /reasonably/ fast
05:48:05 <bitonic> Sequence and Vector are very different structures
05:48:07 <zzing> ok, I will try with Sequence for now
05:48:28 <zzing> bitonic, I cannot say everything I am doing to be doing because I don't have 100% knowledge yet
05:48:31 <bitonic> zzing: the best thing is that you describe the use case. otherwise is just guessing
05:48:57 <bitonic> well but at least, what operations will you do more often? are you just going to append to this list or insert at random indices? what are the numbers involved?
05:49:02 <zzing> But I think I can generalize to say that I will be inserting, deleting, replacing, appending on whatever data structure.
05:49:06 <zzing> bitonic, it is up to the user
05:49:13 <zzing> edlin is a command based editor
05:49:41 <bitonic> zzing: yes but what are you storing in this data structure?
05:49:56 <zzing> It is lines of text,  likely a String for each line
05:50:00 <bitonic> is it the file buffer? because in that case there are really good structures to do that (ropes, finger trees)
05:50:27 <zzing> bitonic, what do you mean the file buffer?
05:50:43 <bitonic> zzing: lines of text holding a file you're editing? in that case you can make good guesses about the size of the file
05:50:59 <opqdonut> zzing: for storing lines I recommend Data.Sequence
05:51:02 <bitonic> zzing: I just mean the text you're editing
05:51:26 <opqdonut> zzing: http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Sequence.html
05:52:57 <zzing> What is a rope and finger tree?
05:53:08 <opqdonut> you don't need to know :)
05:53:29 <opqdonut> but it's a (somewhat complicated) tree structure
05:53:38 <bitonic> ropes are not complicated at all
05:53:44 <opqdonut> with fast indexing, splitting and concatenation
05:53:53 <opqdonut> (I was talking about finger trees)
05:54:50 <bitonic> I don't think that Sequence as it is would be good for storing text
05:55:13 <opqdonut> a sequence of lines will do the things zzing needs
05:55:25 <opqdonut> with very little hassle
05:55:43 <zzing> I am tending to agree, it doesn't have to be ideal
05:56:00 <opqdonut> he could of course start with [String] and only throw in a nicer structure as needed
05:56:17 <bitonic> yeah that's what I'd do anyways
05:57:02 <bitonic> what I meant is that the Sequence interface is not ideal to hold text you're editing
05:57:05 <clinton_> is it true that 'tvar' works by trying transactions in parallel, but then aborting and re-running transactions if one completes?
05:58:27 <zzing> What is the best introduction to parsec 3? I am reading chapter 16 in "real world haskell" right now and it has a CSV parser. I have not used anything like this before, and it blew my mind when I tried it a year ago
05:58:35 <merijn> clinton_: As far as I recall they work by optimistic locking, yes.
05:59:10 <dp_wiz> What's the difference between parsec-3.1.2 and parsec3-1.0.0.4 ?
05:59:26 <teneen> Let's say I define the combinator "double f = f . map f". If try "double sort" it gives me an infinite type error. However, "sort . map sort" typechecks and works just fine. Why?
05:59:41 <bitonic> zzing: that chapter is ok.
05:59:50 <zzing> bitonic, ok
05:59:52 <bitonic> ignore all the part about Applicative not being present, because it is now
06:00:11 <merijn> teneen: Because both sort's in that function have different types
06:00:26 <kallisti> wait so, if I type "cabal install" within a directory with a .cabal file, then it automatically configure and builds as well, yes?
06:00:31 <zzing> The kind of line I am parsing is [startline],[endline],toline[,times]C     [ ] denoting optional
06:00:42 <kallisti> but if I do runhaskell Setup.hs install it doesn't?
06:00:45 <teneen> merijn: so I should use a Higher-rank type?
06:00:48 * kallisti is confused about the difference between the two.
06:00:49 <merijn> teneen: The first is "[[a]] -> [[a]]", the second is "[a] -> [a]".
06:01:35 <merijn> teneen: Depending on the type of 'f' it may not be valid to apply f to both an [a] list and an [[a]] list
06:01:41 <bitonic> teneen: it would be solved with a higher ranked type, yes.
06:02:25 <dcoutts_> kallisti: that's right
06:02:51 <teneen> merijn, bitonic: Thanks :)
06:03:14 <kallisti> dcoutts_: so in my installation instructions which should I use? I've noticed a lot of people have the Cabal build instructions, but why not just use the much simpler cabal-install based instructions?
06:04:06 <merijn> teneen: Especially if you don't specify f types I think the type inferer gets stuck of a loop of constructing types like "[a] -> [a]" (which means f must also apply to "[[a]] -> [[a]]", "[[[a]]] -> [[[a]]]", you can see where this goes...)
06:04:45 <merijn> Mind you, I mind be talking out my ass with that last line, I'm sure someone will yell at me for being wrong if I am :p
06:06:21 <bitonic> the problem is that GHC infers 'double :: [[a]] -> [a] -> [[a]] -> a', which is the best it can do
06:06:44 <bitonic> while you want 'double :: (forall a. [a] -> [a]) -> [[b]] -> [[b]]'
06:06:52 <kallisti> dcoutts_: I suppose because that assumes you have cabal-install, whereas Setup.hs needs only Cabal.
06:07:18 <bitonic> sorry, it infers 'double :: forall b. ([b] -> b) -> [[b]] -> b'
06:07:32 <Taneb> Hello
06:07:34 <bitonic> which makes pefrect sense sense
06:07:43 <bitonic> but it's not what teenen wants
06:07:47 <bitonic> teneen:
06:08:02 <Taneb> The other day I was thinking about the reverse of the monad tutorial fallacy
06:08:09 <Taneb> i.e., burritos are like monads
06:09:48 <teneen> bitonic, merijn: That's a goog use case for higher-rank types
06:10:13 <teneen> bitonic: So the type inferer never infers higher-rank types by it's own?
06:10:59 <mauke> teneen: higher-rank type inference is undecidable
06:11:08 <mauke> I think rank-2 is solvable but complicated
06:11:25 <bitonic> teneen: no
06:11:34 <bitonic> rank-2 is not solvable
06:11:39 <bitonic> e.g. in this case, it's rank 2
06:11:46 <bitonic> and you have two perfectly good ways to type the same function
06:12:03 <jsims> Hello?
06:12:29 <dcoutts_> kallisti: a lot of instructions were written before cabal-install, or before it became part of the standard install
06:12:59 <Ngevd> How much did I get before I got disconnected?
06:13:21 <teneen> mauke, bitonic: Amazing! thanks a lot!
06:13:40 <Taneb> Did I say that burritos are like Monads?
06:13:41 <mauke> bitonic: no, rank-2 type inference is decidable
06:13:48 <bitonic> mauke: how do you decide in this case?
06:13:56 <Taneb> Ah yes
06:14:09 <mauke> bitonic: I don't know
06:14:12 <Taneb> But what got me thinking was how light in a lens bends
06:14:21 <Taneb> This is almost entirely off-topic, so I'll shut up
06:14:23 <mauke> but I found http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.144.1202
06:14:39 <bitonic> mauke: they're both equally good... it's undecidable, I think it's decidable if you say "I always choose the lower ranked one"
06:15:25 <mokus> bitonic, mauke: in this case the 2 types mentioned can be unified because the inferred one is a special case of the other
06:16:29 <bitonic> mokus: are they? it doesn't look like it to me, '(forall a. [a] -> [a]) -> [[a]] -> [[a]]' and ([a] -> a) -> [[a]] -> a'
06:16:40 <bitonic> how do you unify those two?
06:17:29 <mokus> oh, i misread the second as ([a] -> [a]) -> ...
06:18:03 <mokus> i.e., basically the same but without the nested forall
06:20:53 <zzing> What is the difference between Text.ParserCombinators.Parsec.Char  and Text.Parsec.Char
06:21:10 * hackagebot webdriver 0 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0 (AdamCurtis)
06:21:28 <bitonic> zzing: nothing, the former is exported for compatibility with parsec 2.
06:21:41 <zzing> So I should be using the Text.Parsec.*?
06:21:52 <hiptobecubic> Are people actually using Haskell with Selenium?
06:22:30 <hpc> hiptobecubic: not yet apparently; that library is at version 0 :P
06:22:45 <hiptobecubic> hpc, oh. that's what that is. :D
06:22:54 <hiptobecubic> i thought it was just a stupid name :)
06:23:10 <Taneb> Hmm, Gedcom X
06:24:16 <Taneb> This could be useful to my purposes
06:25:54 <kallisti> hiptobecubic: I am
06:26:39 <bitonic> zzing: if you don't care about parsec 2, yes
06:26:56 <zzing> Is there any way I can do something like this? numbers <- sepBy integer comma  ?   Apparently 'integer' is GenTokenParser s1 u1 m1 -> ParsecT s1 u1 m1 Integer
06:26:57 <kallisti> hpc: it's a surprisingly working version 0. :D
06:27:14 <zzing> I would rather not have to work with individual digits
06:27:24 <kallisti> zzing: yes you should be able to do that no problem
06:27:29 <luite> does anyone know how to instal a working cabal-install for ghc 7.4? apparently just fixing the dependencies isn't enough (the 'fixed' version on hackage has broken sdist), and the darcs head version doesn't work because it requires Cabal >= 1.15
06:27:54 <dcoutts_> luite: you can install a new Cabal lib version
06:28:19 <gienah> luite: there's a cabal 1.14 branch
06:28:21 <dcoutts_> luite: there's also the 1.14 branch
06:28:25 <zzing> This is the error and source I am getting with that exact line: https://gist.github.com/10689b27a1090d0b9750
06:29:24 <luite> dcoutts_: oh I always thought that Cabal was one of those libs for which you really should use the version that came with GHC to avoid problems
06:30:47 <luite> but any reason that there's no 1.14 branch cabal-install on hackage? this isn't a terribly user-friendly way to install this
06:31:17 <td123> luite: agreed, there is cabal-install-ghc74 as a workaround though
06:31:39 <luite> td123: yes but it's an older version with problems
06:32:43 <td123> ah I misread you :), I thought you were talking about something compatible with cabal 1.14 :P
06:33:07 <dcoutts_> luite: there will be a release when it's ready
06:33:20 <dcoutts_> luite: and in time for the next HP release
06:33:23 <luite> dcoutts_: anything in particular holding back a release?
06:33:32 <dcoutts_> bugs, features, testing
06:33:35 <dcoutts_> the usual
06:33:39 <td123> probably man power
06:33:42 <dcoutts_> mainly testing
06:33:49 <gienah> luite: its included in the ghc 7.4.1 source code, and a tarball of that is here: http://code.haskell.org/~slyfox/snapshots/cabal-install-0.13.3.tar.gz
06:34:17 <dcoutts_> note that's a random snapshot, no better than current cabal-1.14 branch
06:34:17 <td123> gienah: the one included in the 7.4.1 source code is incompatible with ghc 7.4.1 :P
06:35:06 <gienah> td123: really, well I guess I don't use it much so haven't noticed that it doesn't work :-/
06:36:35 <luite> dcoutts_: is there a list of tasks of things that should be tested somewhere, or perhaps a mailing list discussion?
06:36:38 <td123> here's a related thread http://haskell.1045720.n5.nabble.com/ANNOUNCE-GHC-7-4-1-Release-Candidate-2-td5437004i20.html
06:36:56 <dcoutts_> luite: yes, the trac has the tickets for the milestone and there's the cabal-devel list
06:37:57 * gienah has only used the ghc 7.4.1 cabal-install-0.13.3 for doing cabal build; cabal init; but never actually cabal install (I used gentoo ebuilds instead)
06:38:57 <zzing> When making a function: comma = char ','    I get an error: No instance for (Stream s0 m0 Char)    I would have expected this to be available already. Where does this Stream thing come from?
06:39:48 <bitonic> zzing: Text.Parsec.String
06:39:58 <bitonic> well, you get the instance you want from there
06:40:10 <luite> dcoutts_: oh last time I found a cabal mailing list, it only had message copied from the trac and darcs
06:40:19 <bitonic> zzing: Stream is the type that parsec uses to consume input
06:40:26 <bitonic> *type class
06:40:36 <dcoutts_> luite: discussion takes place there too
06:40:38 <zzing> bitonic, importing Text.Parsec.String does not make the problem go away, same error
06:40:43 <dcoutts_> luite: and in the trac comments
06:40:54 <luite> ah I guess I should have a better look then
06:41:11 <bitonic> zzing: import that and write explicit signatures with the 'Parser' type provided in that module
06:42:40 <bitonic> (I don't have time to actually check what's happening now, but that should make things clearer)
06:43:55 <zzing> hmm, unfortunately not :-(    type Parser = Parsec String ()   When I use Parser it says it expects another argument for Parser
06:44:28 <zzing> I have to start doing something else now, so I think I will just post a Q on stack overflow and see where it leads me tomorrow when I can look at this stuff again
06:44:34 <zzing> Thank you all for your help
06:44:51 <arossouw> hi, how do i ignore negative integers in function declaration?
06:45:53 <bitonic> zzing: just 'Parser ()', not Parsec
06:45:59 <bitonic> Parser is defined in Text.Parsec.String
06:46:04 <bitonic> arossouw: what do you mean?
06:46:47 <zzing> bitonic, Parser () didn't work, but Parser Char compiled perfectly
06:46:49 <zzing> Thank you
06:47:07 <arossouw> if i create a function sum and i perform - 1,complains about literal
06:47:20 <zzing> If I have my function that is a parser, how do I test it with sample input?
06:47:49 <byorgey> arossouw: can you paste the code and the exact error message on hpaste.org?
06:48:01 <byorgey> arossouw: it's hard to know from your description exactly what is wrong
06:48:58 <bitonic> zzing: look at the 'parse' function. read that RWH chapter :P
06:49:07 <byorgey> zzing: Text.Parsec exports a function  parseTest :: Parsec s () a -> s -> IO ()
06:49:28 <byorgey> which is the easiest way to test a parser (though not how you would actually run it in an application of course)
06:49:47 <zzing> bitonic, reading and remembering details is difficult when I am figuring things out :P
06:50:18 <hpaste> Arno pasted “Display Integer” at http://hpaste.org/66760
06:50:27 <arossouw> http://hpaste.org/66760
06:50:41 <bitonic> zzing: yeah but I'm sure any parsec tutorial explains how to run a parser
06:50:45 <arossouw> just want to know to to catch exception with -
06:50:59 <byorgey> arossouw: that type will not work for getInt
06:51:08 <arossouw> ok
06:51:22 <byorgey> arossouw: that type says that if you give it an Int, it can give you back a 'Maybe a' for any type that *you* (the caller of the function) choose
06:51:35 <arossouw> ok
06:51:50 <zzing> One last problem: I have a module Parser that exports parseCommand. When I use ghci to import Parser and then checking the type of Parser.parseCommand it says "attempting to use module `Parser' (./Parser.hs) which is not loaded"  what am I missing here?
06:51:56 <zzing> byorgey, merci
06:52:03 <byorgey> but obviously it can't actually do that.  if you give it an Int, it gives you a Maybe Int.
06:52:16 <byorgey> arossouw: you could give it the type  Int -> Maybe Int, or   a -> Maybe a
06:52:17 <arossouw> ok, so should be Int -> Int
06:52:34 <arossouw> ok
06:52:51 <arossouw> i see
06:53:01 <byorgey> zzing: 'when I use ghci to import Parser' -- how do you do that, exactly?
06:53:12 <zzing> import
06:53:20 <byorgey> zzing: ok, don't do that, use :load instead
06:53:30 <zzing> ok
06:53:33 <byorgey> import is only for modules that are in installed packages
06:53:41 <byorgey> not for stuff in the current directory
06:53:50 <byorgey> I don't remember why there's a distinction.
06:54:40 <zzing> byorgey, so I would import Text.Parsec but :load my_own_module?
06:55:53 <zzing> awesome, my parser works for numbers
06:55:57 <zzing> lists of them that is
06:56:12 <zzing> I think this is going to turn into an affair.
06:56:20 <byorgey> zzing: right
06:57:30 <byorgey> zzing: =D
07:00:23 <arossouw> is there a way to read bytestrings as text, just seen examples of manipulation of numbers from files using bytestring
07:01:32 <bitonic> arossouw: there is no one way, because it depends on the encoding of the ByteString.
07:01:43 <arossouw> ok, i'll try utf8
07:01:44 <bitonic> if the ByteString is UTF-8 text, you can use the Text UTF-8 methods
07:01:51 <arossouw> ok
07:02:21 <bitonic> arossouw: http://hackage.haskell.org/packages/archive/text/0.11.2.0/doc/html/Data-Text-Encoding.html
07:02:27 <arossouw> cool
07:02:54 <arossouw> trying to write email log parser, thinking that bytestrings might be overcomplicating it
07:03:13 <merijn> No
07:03:40 <merijn> Oh, wait. e-mail log...in that case I'll downgrade my "no" to a "maybe"
07:03:56 <arossouw> well files average about 700 to 800 mb
07:04:42 <albel727> preprocess with iconv to utf-8 and downgrade to definite yes. depends on the log, though. if it includes encoded body parts in different encodings...
07:04:49 <bitonic> arossouw: if you have to parse a protocol ByteString is probably better
07:04:55 <arossouw> ok
07:05:07 <bitonic> you definitely don't want to convert the email to Text
07:05:08 <merijn> The solution is to understand encoding and unicode
07:05:16 <bitonic> before you parsed it
07:05:20 <merijn> Otherwise you are just part of the problem making life hard for the rest of the world...
07:05:35 <arossouw> i just want the queue number for specific email, let program loop through that maybe map it to a list
07:05:46 <arossouw> then based on list find matches for it
07:06:21 <arossouw> merijn: ok, i'll read up on encoding some more
07:07:23 <merijn> arossouw: This is the article you want to read: http://www.joelonsoftware.com/printerFriendly/articles/Unicode.html
07:07:49 <arossouw> thanks :-)
07:08:22 <kallisti> GHC badly requires cross compilation
07:08:51 <bitonic> that article looks like an incredible wall of text if it explains what ASCII and UTF-8 is :P
07:08:56 <bitonic> kallisti: it's coming soon, next release
07:09:02 <bitonic> *are
07:09:22 <kallisti> oh excellent
07:09:25 <kallisti> any idea when that will be?
07:14:14 <bitonic> kallisti: well it'll be via LLVM
07:15:34 <bitonic> I'm not 100% about the "next release" thing, but Cale friends are writing an iPhone game and they developed that, and I think they were about to merge it, it's probably in some branch
07:16:51 <bitonic> kallisti: ah, I misread the "when" :P
07:16:56 <bitonic> no idea about when it'll be
07:17:40 <merijn> bitonic: No, it explains what unicode and encodings are, why they exist and why programmers that pretend that they do not exist should be lynched by the rest of us :p
07:18:30 <bitonic> merijn: I'd still get bored after two paragraphs, just tell me how ascii works, then how Unicode works, and how UTF-8 works
07:18:47 <bitonic> but maybe someone will appreciate the story :P
07:19:12 <merijn> bitonic: Sure, but it wasn't written for you :p
07:19:21 * kallisti doesn't know of any actual programmers who pretend that Unicode doesn't exist.
07:19:32 <merijn> kallisti: Try "the majority"
07:19:51 <Botje> bitonic: ascii sucks, unicode doesn't. utf-8 is a means of encoding unicode into bytes. it happens to look like ascii for characters < 0x80.
07:20:02 <merijn> I learned that article is a life saver during my time in #python. Explaining people why they need to know about encodings gets old after a while
07:20:40 <bitonic> Botje: I know what ascii, unicode and utf8 is
07:20:41 <kallisti> the way Python handles Unicode is kind of silly anyway.
07:21:02 <Botje> bitonic: that's the three sentence explanation I give out to people in #perl
07:21:03 <merijn> kallisti: Fixed in python3
07:21:20 <kallisti> which still hasn't caught traction yet..
07:21:36 <merijn> They're only in year 3 or so of their 5-10 year upgrade plan
07:22:03 <bitonic> kallisti: at least it looks like they're going to make it. better than perl 6 anyways
07:22:09 <mekeor> so, what's the best way to get familiar with encodings (unicode, utf-8, ascii, etc.) ?  the link above?
07:22:09 <td123> py 3.3 should introduce changes which make it easier to port py2 to py3 :)
07:22:31 <merijn> mekeor: The one I linked gives a nice history of the how/what/where
07:22:33 <kallisti> bitonic: oh really? I thought perl 6's Unicode handling looked sensible, at least on paper.
07:22:42 <bitonic> kallisti: no I mean, perl 6 is never coming out.
07:22:49 <kallisti> oh, right.
07:22:51 <kallisti> there's always that.
07:22:59 <bitonic> mekeor: wikipedia ASCII, Unicode, UTF-8 :P
07:23:11 <Botje> mekeor: that, screwing around with utf8 stuff on your own, and maybe perldoc perlunitut
07:23:12 <mekeor> bitonic: hm. hm. hmmm.
07:23:25 <Botje> even if you don't know/program perl, it's a good checklist of things to worry about
07:23:30 <mekeor> Botje: hm? perldoc?
07:23:41 <mekeor> Botje: hm? perlunitut?
07:23:56 * mekeor googles.
07:24:04 * mekeor ... successfully.
07:24:45 <kallisti> bitonic: but what if it did...?
07:24:47 <kallisti> one can hope.
07:25:23 <bitonic> kallisti: yeah I'm sure it will, someday
07:25:50 <danbst> Hello. Is there standart function, that does this - expand 5 "hell" ---> "hell ", expands string with empty elements to given length? It's easy to write one (expand n xs = xs ++ (replicate (n-length xs) ' ')), but I'm curious if there is standart
07:25:55 <mauke> mekeor: 'perldoc' is a program
07:26:08 <mauke> mekeor: it provides access to core perl and library documentation
07:26:49 <bitonic> danbst: no, by any definition of "standard" I can think of :P
07:27:01 <bitonic> @hoogle Int -> String -> String
07:27:02 <lambdabot> Test.QuickCheck.Text number :: Int -> String -> String
07:27:02 <lambdabot> Test.QuickCheck.Text short :: Int -> String -> String
07:27:02 <lambdabot> Prelude drop :: Int -> [a] -> [a]
07:27:07 <mekeor> mauke: cool.
07:27:27 <Botje> danbst: I don't think so. Also, i'd go for take 5 (xs ++ repeat ' ')
07:27:28 <mauke> > printf "%*s" 5 "hell" :: String
07:27:29 <lambdabot>   " hell"
07:27:34 <mauke> > printf "%-*s" 5 "hell" :: String
07:27:35 <lambdabot>   "hell "
07:28:15 <danbst> wow
07:28:31 <danbst> printf is cool
07:28:42 <ion> and evil
07:28:44 <bitonic> 'take 5 (xs ++ repeat ' ')' is better
07:28:49 <bitonic> printf is dangerous
07:29:08 <mauke> bitonic: even with TH?
07:29:15 <bitonic> mauke: that's not TH
07:29:44 <bitonic> and TH is not needed (in this case) and not standard
07:29:46 <fryguybob> > printf "%-*s" "five" "hell" :: String
07:29:47 <lambdabot>   "hell*Exception: Printf.printf: bad argument
07:29:49 <timthelion> How can I make a function that passes a Widget of type WidgetClass?  http://hackage.haskell.org/packages/archive/gtk/latest/doc/html/Graphics-UI-Gtk-Abstract-Widget.html#v:widgetGrabFocus
07:30:10 <timthelion> Sorry, I'm an idiot.
07:30:12 <danbst> Botje: thanks for suggestion. curious if there is simpler pointless version
07:30:26 <timthelion> I tried WidgetClass and it didn't work.  I presume I need WidgetClass a
07:30:28 <ChristianS> printf is cool, but why should it be evil?
07:30:39 <bitonic> ChristianS: it's unsafe
07:30:39 <Botje> > take 5 . (++ repeat ' ') $ "hell"
07:30:41 <lambdabot>   "hell "
07:30:56 <rwbarton> I was going to suggest the take 5 thing also but it will shorten your string if it is longer than 5 to start
07:31:04 <ion> It lacks proper static type checking.
07:31:28 <Botje> rwbarton: ooh, right
07:31:32 <danbst> Botje: thanks!
07:31:51 <ChristianS> some compilers do static type checking for printf, not sure if ghc is one of them
07:32:20 <bitonic> > (\n xs -> take (max n (length xs) (xs ++ repeat ' ')) 5 "foo"
07:32:22 <lambdabot>   <no location info>: parse error (possibly incorrect indentation)
07:32:38 <kallisti> there should be an RSS feed for Hackage uploads or something.
07:32:56 <Tinned_Tuna> Aww yea, I've got Dons' paper 'Plugging Haskell In'
07:32:59 <bitonic> ChristianS: GHC has nothing to do with it. You can't have a variadic printf that works parsing a string that is checked at compile time
07:33:12 <bitonic> > (\n xs -> take (max n (length xs)) (xs ++ repeat ' ')) 5 "foo"
07:33:13 <lambdabot>   "foo  "
07:33:19 <byorgey> kallisti: http://hackage.haskell.org/packages/archive/recent.rss
07:33:20 <bitonic> > (\n xs -> take (max n (length xs)) (xs ++ repeat ' ')) 5 "fooooooo"
07:33:22 <lambdabot>   "fooooooo"
07:33:31 <bitonic> ChristianS: not with haskell type system anyways
07:34:32 <reinoud> maybe a strange beginners question.... but i can prepend a list by using (4:[1,4,5]) but how to append a value to a list?
07:34:41 <kallisti> reinoud: with ++
07:34:54 <reinoud> duh! thanks!!! I completely forgot!
07:34:54 <byorgey> > [1,4,5] ++ [4]
07:34:55 <ChristianS> bitonic: good c compilers do it, but you're probably right about the haskell type system
07:34:56 <lambdabot>   [1,4,5,4]
07:35:09 <byorgey> reinoud: however, note it takes linear time to do that, because the entire list must be traversed
07:35:16 <bitonic> ChristianS: what C compiler does it? It's beyond C anyways
07:35:20 <merijn> ChristianS: Only when the string is a constant string
07:35:24 <byorgey> reinoud: so you should avoid it if possible.  or use a different data structure.
07:35:24 <hpc> C compilers do it with special case goofiness
07:35:27 <geekosaur> it's not about the type system so much, you could do it in ghc by mixing the levels (..e. TH)
07:35:32 <bitonic> and it's a special case printf hack
07:35:33 <merijn> bitonic: clang does it for string constants
07:35:43 <merijn> But yes, it's a special case hack
07:35:47 <reinoud> hmmm :-/
07:35:59 <geekosaur> gcc does it if you have an __attribute (printftype) thing on the function telling it which prameter should be a constant string format
07:36:05 <bitonic> geekosaur: with TH you're converting the string to something else that can be typechecked
07:36:08 <hpc> you can write a variadic printf that checks strings at compile-time if you have a dependently-typed language
07:36:12 <kallisti> reinoud: if that's a performance issue for your program you want be interested in other sequence types.
07:36:15 <bitonic> hpc: yes! ehe
07:36:26 <kallisti> s/want/may/
07:36:28 <geekosaur> enables both (a) security warning for nonconstant format (b) statically checking constant format string
07:36:30 <byorgey> reinoud: if you need to repeatedly append to the end of a list, you can also keep the list in reverse order (so the appends become prepends) and then reverse it at the very end
07:37:00 <hpc> reinoud: you can also use a difference list
07:37:10 <hpc> reinoud: and if your list is actually a string, you can use Text
07:37:11 <ChristianS> bitonic: gcc with the -Wformat option
07:37:16 <geekosaur> bitonic, yoy're not thinking creatively enough
07:37:26 <kallisti> hpc: or a Data.Sequence! :D
07:37:33 <kallisti> er...  reinoud: ^
07:37:48 <kallisti> so many options!
07:38:14 <bitonic> ChristianS: again, it's a special case that works only if the string is known at compile time (admittedly that would be 99% of the time with printf, hopefully)
07:38:49 <reinoud> its a function that tries to order stuff. It gets pairs of (a,b), (c,b), (..) and then results in (a,b) (b,c), ... etc so lines that are not yet placeable should come later, hence then put at the end of the list of unused tuples
07:39:58 <byorgey> reinoud: probably the best advice is to just ignore us for now. =)  Get it working using whatever methods occur to you.  Then later you can think about how to improve it.
07:40:18 <reinoud> lol
07:40:49 <byorgey> reinoud: how long are these lists of tuples going to be?
07:41:24 <byorgey> a few tuples?  hundreds? millions? etc.
07:41:45 <reinoud> at most say a 50 or so
07:42:04 <reinoud> i think on average about 5
07:42:20 <kallisti> "We should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil" -- Donald Knuth
07:42:38 <bitonic> reinoud: you'll be fine with ++
07:42:44 <reinoud> :)
07:45:34 <byorgey> indeed.
07:45:52 * byorgey repents of his misguided guidance
07:46:25 <kallisti> sinner.
07:46:46 <rasfar> haha
07:48:48 <hpaste> timthelion pasted “How to I return a Widget then???” at http://hpaste.org/66762
07:48:57 * timthelion cries
07:49:08 <bitonic> reinoud: in fact, you'll most likely be better off with ++!
07:49:24 <timthelion> I don't understand how haskell deals with polymorphic objects passed from C...
07:50:31 <timthelion> kallisti: that sort of thing is said a lot.  But think of all the projects that have failed because of a thousand tiny preformance hogs...
07:50:41 <hpc> timthelion: WidgetClass is a class
07:50:54 <timthelion> hpc: so how do I pass a Widget?
07:51:25 <hpaste> hpc annotated “How to I return a Widget then???” with “How to I return a Widget then??? (annotation)” at http://hpaste.org/66762#a66763
07:51:38 <hpc> Widget is an instance of WidgetClass
07:51:49 <mekeor> can i do 'not (null someList) && (head someList /= someElement)' ?   i mean, i don't want head to throw an error.
07:51:54 <rwbarton> more likely you should return whatever you want to return
07:51:55 <kallisti> timthelion: yes. Those are the 3% of the time.
07:52:07 <timthelion> hpc: thanks
07:52:24 <timthelion> rwbarton: nah, in this case, it could be any one of a number of things.
07:52:27 <rwbarton> what hpc wrote is probably not what you want, but who knows
07:52:33 <rwbarton> that is not what hpc wrote
07:52:38 <rwbarton> afaict
07:52:47 <rwbarton> do you have an implementation for buildTable?
07:52:53 <timthelion> rwbarton: yes
07:53:02 <timthelion> it's 300loc though, so I didn't paste it
07:53:02 <rwbarton> what happens if you let GHC infer the type
07:53:04 <hpc> yeah, all i did was make the type signature valid
07:53:36 <Botje> mekeor: sure. are you checking that list for the null case a lot?
07:53:47 <timthelion> rwbarton: right now, the type signature could be IO Button(it was before), but now I want to either return a Button or an Entry.
07:54:03 <mekeor> Botje: er.. no.
07:54:13 <rwbarton> well maybe this is naive but... return IO (Either Button Entry)?
07:54:19 <timthelion> and I don't see why I should recreate a data type of focusable when all widgets are focusable.
07:54:20 <rwbarton> or am I thinking too simple
07:54:52 <mekeor> Botje: but without lazy evaluation, the above snippet wouldn't work, right?
07:54:56 * timthelion see's Either for the first time in his life.
07:55:20 <Clint> is Data.Map efficient if I add the same value with a dozen different keys?
07:55:21 <Botje> mekeor: most languages support shortcircuiting to support this kind of things.
07:55:33 <timthelion> rwbarton: in this case it is CORRECT to return a WidgetClass, as I'm passing the return result strait into the widgetGrabFocus function
07:55:39 <rwbarton> it is not CORRECT
07:55:41 <hpc> Clint: are you going to be looking up the keys from the value?
07:55:48 <timthelion> rwbarton: how so?
07:55:59 <rwbarton> if you write buildTable :: WidgetClass a => ScrolledWindow -> ThreadObject Grid -> ThreadObject (Maybe DisplayCell.DisplayCell) -> Grid -> IO a
07:56:02 <Clint> hpc: probably not
07:56:05 <bitonic> Clint: that doesn't make any difference from adding a dozen different values with a dozen different keys, so I'm not sure what you mean
07:56:10 <rwbarton> that means the caller gets to decide what type to return as long as it is an instance of WidgetClass
07:56:22 <timthelion> rwbarton: which is exactly what I want
07:56:29 <rwbarton> I highly doubt that
07:56:32 <rwbarton> try reading again
07:56:34 <timthelion> rwbarton: wait, the caller
07:56:37 <rwbarton> indeed
07:56:46 <timthelion> like then it would be buildTable :: Button ?
07:56:46 <hpc> Clint: then yes; Data.Map is more interested in the keys than the values
07:56:50 <timthelion> to call
07:56:58 <Clint> great, thanks
07:56:59 <rwbarton> well not exactly but something like that
07:57:16 <hpc> Clint: if you were saving multiple values to the same key, you would want something like Map key [value], or similar
07:57:16 <timthelion> rwbarton: then how does one return a polymorphic object?
07:57:22 <rwbarton> wut
07:57:36 <timthelion> rwbarton: it's a C object...
07:57:41 <rwbarton> C doesn't have objects
07:57:49 <timthelion> well it's a C something.
07:57:54 <mekeor> Botje: also, '(head someList /= someElement) && not (null someList)' wouldnt work, right?
07:58:00 <rwbarton> well it is obviously a Haskell value since you are writing a Haskell program
07:58:01 <Clint> hpc: no, i just want several different indices for the same data
07:58:09 <Botje> mekeor: indeed.
07:58:12 <rwbarton> you mean something like "return a value of unknown type"
07:58:15 <rwbarton> which is useless as stated
07:58:32 <rwbarton> i'm not familiar with gtkhs but probably there is some Widget type that you can convert Button and Entry to
07:58:35 <hpc> :t read -- like this?
07:58:36 <lambdabot> forall a. (Read a) => String -> a
07:58:42 <mekeor> Botje: thanks
07:58:49 <hpaste> timthelion annotated “How to I return a Widget then???” with “How to I return a Widget then??? (annotation)” at http://hpaste.org/66762#a66764
07:59:17 <timthelion> rwbarton: look at what I'm doing.  I'm calling buildTable from syncGridwithScrwin
08:00:16 <timthelion> rwbarton: the Widget returned from buildTable must be focused and then forgoten about.  The widgetGrabFocus function takes any widget.  And I might want to return any type of widget.
08:01:22 <rwbarton> if this is the only place you use buildTable you can move widgetGrabFocus into buildTable
08:01:34 <rwbarton> otherwise  < rwbarton> i'm not familiar with gtkhs but probably there is some Widget type that you can convert Button and Entry to
08:01:55 <timthelion> rwbarton: unfortunately I cannot :(  I have to pack the scrwin first...
08:02:14 <rwbarton> you could return the action widgetGrabFocus focusedWidget
08:02:33 <timthelion> rwbarton: that's an interesting thought...
08:03:01 <timthelion> but why couldn't I just return a Widget, it seems a relatively simple and obvious thing to do..
08:03:11 <rwbarton> < rwbarton> otherwise  < rwbarton> i'm not familiar with gtkhs but probably there is some Widget type that you can convert Button and Entry to
08:03:28 <hpc> there is
08:03:31 <hpc> it's called Widget
08:04:12 <timthelion> hpc: but I have to convert a Button to a Widget,  a button is not a Widget, correct?  If so, how do I convert a Button to a Widget?
08:04:40 <rwbarton> according to that page you linked me to, toWidget
08:04:49 <timthelion> Oh, ok.
08:05:07 * timthelion appoligizes for not understanding how Haskell's type system works.
08:05:14 <srhb>  toWidget :: WidgetClass o => o -> Widget
08:05:36 <hpc> timthelion: you should learn how type classes work before mucking around with gtk
08:05:40 <srhb> Of which Button is an instance of.
08:05:44 <srhb> er, minus the of.
08:05:45 <hpc> gtk uses them everywhere for somewhat-gross tricks
08:06:30 <hpc> http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101 -- start here
08:06:33 <hpc> http://learnyouahaskell.com/making-our-own-types-and-typeclasses#typeclasses-102 -- continue here
08:07:02 <timthelion> hpc: OK.  I was told to learn how to use monads before trying to understand them.  Now you're telling me the oposite is true of typeclasses... Am I understanding correctly?
08:07:50 <srhb> Monad is a typeclass.
08:08:03 <srhb> And you should definitely understand how they work.
08:08:07 <srhb> Type classes, that is.
08:08:15 <srhb> (It will also make you understand monads)
08:08:50 <srhb> Is it type class or typeclass?
08:08:53 <antibot> Is there a plugins-like package that works with ghc-7.4.1 and supports Safe Haskell?
08:09:18 <hpc> "type class" -- a class of types
08:09:26 <kallisti> srhb: I've seen both.
08:09:28 <hpc> LYAH uses both
08:09:31 <kallisti> but most commonly I see typeclass
08:10:29 <srhb> English ought to have rules for these things. :(
08:10:34 <rwbarton> I'm pretty sure the Report uses "type class"
08:10:45 <byorgey> srhb: originally, it was 'type class'.  Over time, it has been shifting to 'typeclass' (as often happens with things that start out as open compounds and eventually become closed compounds, like 'cupboard' and 'fireman' and...)
08:11:20 <byorgey> yes, the report and early papers on type classes all use 'type class'.
08:11:51 <byorgey> but I (now) think it would be overly pedantic to insist that everyone saying 'typeclass' is wrong.
08:11:52 <srhb> Indeed. In my native tongue, nouns from two nouns are always written in one word. In English it feels like 50/50 chance of getting it right. :-)
08:12:16 <koeien> are you saying german > english? ;)
08:12:26 <hpc> > "german" > "english"
08:12:27 <lambdabot>   True
08:12:34 <srhb> There we go.
08:12:35 <srhb> :-)
08:12:46 <byorgey> > "German" > "english"
08:12:47 <lambdabot>   False
08:12:55 <byorgey> ;)
08:12:57 <hpc> > "everything else" > "french"
08:12:58 <lambdabot>   False
08:13:02 <hpc> nooooo!
08:13:21 <byorgey> > "everything else" > " french"
08:13:21 <lambdabot>   True
08:13:46 <hpc> > "five" > "four"
08:13:47 <lambdabot>   False
08:14:32 <hpc> anyhoo, type classes are what make haskell go 'round
08:15:11 <srhb> Which reminds me, can I get lambdabot to give me the source of instances?
08:15:18 <Peaker> I gave up on fclabels due to the polymorphic records problem. The type: ((field -> field) -> record -> record) is too restrictive.  Does any Lens library have a solution to this problem?
08:16:46 <mysticc> I was just wondering , how do you actually write a language extension ? to see code of some of them do I need to doenload the whole code of ghc ?
08:16:53 <koeien> yes, mysticc
08:17:18 <koeien> an alternative approach is to write a preprocessor (for example, arrows was originally written like that iirc)
08:17:26 <koeien> ArrowSyntax, that is
08:18:08 <bitonic> or HSP
08:18:12 <mysticc> koeien: where can I read more about that
08:18:16 <bitonic> well, HSP is still like that.
08:18:17 <koeien> about ArrowSyntax?
08:18:26 <bitonic> mysticc: write a preprocessor, and then use the -F flags
08:18:45 <bitonic> is it -F? can't remember
08:18:49 <bitonic> the ghc manual has it
08:18:53 <mysticc> bitonic: hmm .. and what if I want to patch my ghc code to make it an extension
08:19:03 <koeien> that's possible but probably a lot of work
08:19:26 <bitonic> mysticc: well you might as well start like that then, and use GHC environment
08:19:40 <bitonic> if you write a preprocessor you're going to parse the code and do something with it
08:20:39 <mysticc> bitonic: Where can I see some example code of a preprocessor
08:21:46 <bitonic> mysticc: https://github.com/scvalex/interpol/blob/master/Main.hs
08:22:14 <bitonic> in this case, he's using haskell-src-exts to parse the code. you probably want to do the same.
08:23:12 <Peaker> Does anyone know the graphics-drawingcombinators package?  Or the combinatorial approach to images?
08:23:23 <Peaker> I'm wondering about a problematic example I have regarding color tinting
08:23:25 <hpc> diagrams?
08:23:45 <Peaker> It's probably similar, yeah
08:24:31 <bitonic> Peaker: just ask the question :)
08:24:39 <Peaker> In graphics-drawingcombinators, I can compose a bunch of shapes together into a single shape, with overlaps. Then if I "tint" a color over that composition, I'd expect the image to just change its color uniformly. For example, if I add transparency. But due to the overlaps, the transparency is not uniform
08:25:01 <Peaker> Because behind the scenes, the "tint" is just passing a different context to the drawing of all the sub-shapes in the image
08:25:19 <Peaker>  But the documentation for "tint" says it applies to the image as a whole. Which doesn't even expose the overlaps before transparency is added
08:25:28 <Peaker> I am wondering if this is a bug, and if so, how it can be corrected in the combinatorial approach
08:25:45 <hpc> oh, thought you were asking what the name of the package was <.<
08:26:07 <Peaker> nope, I was just having trouble composing a transparent rounded-corner rectangle :-)
08:26:30 <Peaker> I draw the rectangle by drawing two overlapping rectangles forming a "plus" sign, and then I draw small circles in the corners
08:27:03 <Peaker> it looks good as opaque, but if I try to tint it to be transparent, I am exposed to the "implementation details" of the final shape, which I'm guessing should be considered a bug
08:27:55 <Peaker> http://hackage.haskell.org/packages/archive/graphics-drawingcombinators/1.1.1/doc/html/Graphics-DrawingCombinators.html#v:tint
08:34:09 <netman_> hi
08:34:23 <byorgey> hi netman_
08:35:02 <netman_> have you played around with Haskell much?
08:35:09 <koeien> byorgey has.
08:35:13 <koeien> lol :)
08:35:25 <byorgey> netman_: yep, lots of people here have =)
08:35:58 <netman_> i am checking it out see if it fits any development i do.
08:36:14 <koeien> probably, what are you developing?
08:36:16 <byorgey> netman_: what sorts of developement do you do?
08:36:31 <rasfar> mysticc: you might also find my Haskell extension (written as a pre-processor) useful for reference, http://fremissant.net/freesect
08:36:48 <rasfar> there are some problems with using ghc -F though, in my experience
08:36:59 <koeien> mysticc left.
08:37:00 <byorgey> netman_: it is a general-purpose language and there are lots of libraries etc., so it can be used for almost anything.
08:37:04 <rasfar> aw shucks
08:37:20 <rasfar> (sorry, i don't see the join/part messages anymore)
08:38:04 <byorgey> netman_: however, it involves many quite different ways of thinking about/organizing code, so how to accomplish certain things are often not initially obvious to people coming from a background in other languages.
08:40:26 <mekeor> ... e.g., there's the great 'diagrams'-library with which you can make diagrams.
08:40:55 <byorgey> oh, yeah, I love that library
08:41:01 <byorgey> ;)
08:41:33 <koeien> somehow i'm not surprised by the field "Author" of that library ;)
08:42:29 <mekeor> @where diagrams
08:42:30 <lambdabot> http://projects.haskell.org/diagrams/
08:43:05 <t7> what are my options for storing a list/array larger then i can fit in ram?
08:43:21 <t7> is there an abstraction to a local db or something?
08:43:34 <koeien> no, not automatically
08:43:38 <koeien> you could let the OS swap
08:43:48 <Botje> mmap?
08:43:59 <koeien> bytestring-mmap ?
08:44:00 <dmwit> I don't know of any libraries for hard-drive backed data structures other than the two mmap libraries.
08:44:01 <Enigmagic> koeien: bad idea with GHC's GC
08:44:10 <koeien> Enigmagic: ah yeah
08:44:20 <koeien> that will constantly pull in stuff
08:44:58 <rwbarton> well it wouldn't pull in e.g. the middle of a big unboxed array right
08:45:10 <koeien> true
08:45:48 <t7> maybe i could just store as files
08:45:54 <t7> load and unload as i go
08:46:05 <t7> might kill the disk though
08:50:29 <parcs`> buy more ram
08:52:05 <merijn> Rent an EC2 machine with more RAM :p
09:04:33 <mekeor> is unsafePerformIO implemented in Haskell itself?
09:04:44 <dmwit> No.
09:04:50 <mekeor> good :)
09:04:54 <dmwit> Or rather, probably, but eventually it bottoms out at a primitive call.
09:05:17 <dmwit> Like, it calls something even unsafer, I think.
09:05:27 <geekosaur> no, it's in (extended) Haskell
09:05:28 <srhb> unsafeDupablePerformIO (noDuplicate >> m)
09:05:43 <ClaudiusMaximus> aargh - the pain of Rank2Types...   I have some  f  and  let g = ... in f g g g g  works fine but  let g = ... ; h k = f k k k k in h g  fails
09:05:44 <srhb> oops, forgot the argument. You get the gist.
09:05:59 <srhb> unsafeDupablePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
09:06:02 <srhb> (whatever that means)
09:06:15 <byorgey> ClaudiusMaximus: o.O
09:06:49 <dmwit> ClaudiusMaximus: Yes, that h will be rank-1 unless you explicitly ask for it to be otherwise.
09:06:51 <geekosaur> srhb: IO is a newtype for an unboxed tuple (the (# #))
09:07:02 <srhb> Ah!
09:07:12 <srhb> Never encountered those hashes before.
09:07:52 <ClaudiusMaximus> maybe it's not actually Rank2Types to blame here?  can a single function argument be used at different types?
09:08:36 <dmwit> Yes, if it's given a polymorphic type, i.e. the function whose argument it is is given a Rank-2 type. =)
09:09:04 <mekeor> geekosaur: oO -- are you a GHC-dev?
09:09:06 <covi> Hi all! If I have (f, s) of type (String, String), how can I do something like this: f ++ [head s] ++ [last f] ++ s?
09:09:10 <dmwit> > let f :: (forall a. a -> a) -> (String, Int); f h = (h "hey", h 3) in f id
09:09:10 <mekeor> hey covi
09:09:11 <lambdabot>   ("hey",3)
09:09:13 <geekosaur> mekeor, no
09:09:20 <covi> mekeor: hi !
09:09:21 <ClaudiusMaximus> dmwit: well, i got lots of "ghc couldnt' deduce  t1 ~ t2  errors" in my real code
09:09:24 <dmwit> > let f h = (h "hey", h 3) in f id -- without the type signature, type error
09:09:24 <lambdabot>   No instance for (GHC.Num.Num [GHC.Types.Char])
09:09:25 <lambdabot>    arising from the literal ...
09:09:28 <mekeor> geekosaur: but you could be, right? :)
09:09:38 <geekosaur> probably not
09:09:44 <dmwit> > let f h = (h "hey", h (3 :: Int)) in f id -- without the type signature, type error
09:09:45 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:09:45 <lambdabot>         against inferred type ...
09:09:48 <mekeor> geekosaur: why not?
09:10:26 <dmwit> ClaudiusMaximus: GHC does not even attempt to infer rank-2 types; you have to ask for them explicitly if you want them. Are you asking for "h" to have a rank-2 type?
09:10:51 <dmwit> ClaudiusMaximus: You may also have MonoLocalBinds on or something, in which case you probably have to give "g" a polymorphic type, too.
09:11:06 <dmwit> Though the fact that the let g = ... in f g g g g version worked makes me suspect that's not the problem.
09:11:25 <dmwit> ?hpaste your code, it's probably the easiest way to cut through the conjectures.
09:11:25 <lambdabot> Haskell pastebin: http://hpaste.org/
09:12:15 <geekosaur> (1) this isn't ghc internals, it's runtime library internals.  big difference.  (for one, I am really weak on type inference/System F...)
09:12:47 <geekosaur> (2) even given that, GHC source assumes rather better understanding of FP than I yet have
09:13:13 <byorgey> covi: you just do it in exactly the way you wrote.
09:13:36 <byorgey> covi: if there's some particular code that you can't get to work, you can paste it (along with the error message) on hpaste.org
09:15:46 <covi> byorgey: ty :)
09:15:52 <mekeor> geekosaur: oh.. okay.
09:16:19 * hackagebot RepLib 0.5.2.1 - Generic programming library with representation types  http://hackage.haskell.org/package/RepLib-0.5.2.1 (BrentYorgey)
09:16:21 * hackagebot unbound 0.4.0.2 - Generic support for programming with names and binders  http://hackage.haskell.org/package/unbound-0.4.0.2 (BrentYorgey)
09:16:43 <hpaste> ClaudiusMaximus pasted “pain with rank2types” at http://hpaste.org/66767
09:18:45 <ClaudiusMaximus> annotated with part of the error, there's much more of the same
09:19:02 <dmwit> ClaudiusMaximus: I expect you actually need to write the "forall r.", no?
09:19:10 <covi> What's the appropriate data structure (spec. for haskell) for task like this: takes in a big text corpus and analyze/store the frequency of each word, for uses later in the program?
09:19:20 <danbst> covi: maybe this: f ++ head s : last f : s
09:19:33 <dmwit> > let f :: (Eq a => a -> a) -> (String, Int); f g = (g "hey", g 3) in f id
09:19:34 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:19:34 <lambdabot>         against inferred type ...
09:19:37 <dmwit> yeah
09:19:40 <covi> danbst: [head s] and [last f] works quite well :) but thanks
09:20:09 <dmwit> danbst: GHC will perform that "optimization" for you.
09:20:14 <dmwit> So write what you mean instead. =)
09:20:28 <tnzr> hi guys, I'm trying to define the type for a function that takes a list of pairs (String, Num) and returns a pair of lists ([String], [String]) ... little help? :)
09:20:37 <danbst> dmwit: oh, cool
09:20:40 <dmwit> covi: I would use a Map String Int or so for the frequency map.
09:20:45 <koeien> tnzr: Num is not a type
09:20:55 <tnzr> koeien: sorry, Int
09:21:06 <koeien> tnzr: what would you like the function to do?
09:21:16 <dmwit> tnzr: I think you just wrote the type, but with English instead of (->)...
09:21:25 <dmwit> (String, Int) -> ([String], [String])
09:21:26 <ClaudiusMaximus> dmwit++ fixing my types
09:21:51 <covi> dmwit: ty, will give it a look
09:22:01 <tnzr> koeien: well the pairs in the input list are  ("name", grade) and the output is a pair of lists where fst is the list of names whose grades were >= 70 and snd is all teh rest
09:22:07 <koeien> [(String, Int)] -> ([String], [String]) rather
09:22:19 <tnzr> I have the function written but I want to figure out the type, but after reading what dmwit just said, I'll give that a shot :)
09:22:19 <koeien> tnzr: hint: use "partition"
09:22:31 <koeien> oh, you can ask ghci
09:22:36 <koeien> :t yourFunction
09:22:36 <dmwit> Oh, yes, I missed the "list of" instead of "[]" in his English.
09:22:37 <lambdabot> Not in scope: `yourFunction'
09:22:52 <tnzr> oh neat, so I can just define it without the type definition and haskell will infer what it is?
09:22:56 <koeien> yes
09:23:00 <tnzr> wow ok
09:23:05 <tnzr> thanks guys
09:23:19 <mekeor> what's the operator precedence of `foo` ?
09:23:57 <mekeor> i mean, the fixity..
09:25:04 <danbst> 9 or something like that
09:25:07 <ClaudiusMaximus> though i'm confused why it's necessary,  something about  B b => a -> (b -> c) -> c  vs  a -> (B b => b -> c) -> c  vs  a -> (forall b . B b => b -> c) -> c
09:25:40 <bitonic> ClaudiusMaximus: the second one doesn't mean much, unless you're implying it to be like the third one
09:26:00 <ClaudiusMaximus> bitonic: in my n00bness i thought it would be the same as the third, but it isn't
09:26:15 <koeien> ow, is that legal?
09:26:31 <dmwit> ClaudiusMaximus: I think in newer GHC's, the second is illegal.
09:26:33 * koeien would always write the first or the third, depending on what you mean.
09:26:48 <bitonic> ClaudiusMaximus: in haskell, every type with type variables implicitly quantifies, e.g. 'a -> b' is equivalent to 'forall a b. a -> b'
09:27:03 <dmwit> ...or perhaps it's putting the class constraint outside of the parentheses that's illegal.
09:27:15 <bitonic> for higher-ranked types you have to explicitly quantify to avoid ambiguities
09:27:20 <dmwit> > let f :: a -> Eq b => b -> b; f = const in f 3 4
09:27:20 <lambdabot>   Couldn't match expected type `b' against inferred type `a'
09:27:20 <lambdabot>    `b' is a rigi...
09:27:24 <dmwit> yikes
09:27:31 <dmwit> I thought I'd filed a GHC bug about this.
09:27:36 <ClaudiusMaximus> dmwit: ok - i'm on 7.4.1
09:28:33 <covi> dmwit: I've been thinking how to count the frequencies. There seems no Haskell-equivalent to 'freq[word] += 1'...
09:29:04 <koeien> covi: split your input in words, then fold over them, using a Map Text Integer
09:29:34 <koeien> foldr (Map.insertWith (+) 0) Map.empty . words -- or something like this
09:29:35 <dmwit> Oh, I misremembered the bug.
09:29:42 <dmwit> covi: Check out fromListWith.
09:29:48 <dmwit> koeien: foldr is too complicated =)
09:29:55 <dmwit> http://hackage.haskell.org/trac/ghc/ticket/3272
09:30:05 <dmwit> ClaudiusMaximus: It used to not work, but now it does. I had the polarity of the bug reversed. =)
09:30:07 <covi> koeien: sounds about right!
09:30:33 <koeien> maybe foldl, maybe I missed something, probably there should be a 1 instead of a 0, and so on
09:31:14 <dmwit> :t fromListWith (+) . zip (repeat 1)
09:31:15 <lambdabot> Not in scope: `fromListWith'
09:31:23 <dmwit> :t M.fromListWith (+) . zip (repeat 1)
09:31:24 <lambdabot> forall a k. (Num a, Ord k, Num k) => [a] -> M.Map k a
09:31:31 <dmwit> whoops
09:31:42 <dmwit> :t M.fromListWith (+) . (`zip` repeat 1)
09:31:43 <lambdabot> forall a a1. (Num a, Ord a1) => [a1] -> M.Map a1 a
09:31:43 <covi> koeien: ty
09:31:49 <covi> dmwit: ty, will check it out
09:32:22 <parcs`> mekeor: infixl 9
09:32:23 <dmwit> :t \words -> M.fromListWith (+) [(word, 1) | word <- words]
09:32:24 <lambdabot> forall a t. (Num a, Ord t) => [t] -> M.Map t a
09:32:36 <dmwit> That's probably more readable.
09:32:42 <koeien> map (,1) words
09:32:53 <dmwit> Unfortunately, doesn't work.
09:32:59 <koeien> porque?
09:33:01 <dmwit> (flip (,) 1) is significantly less pretty.
09:33:07 <dmwit> :t (,1)
09:33:08 <lambdabot> Illegal tuple section: use -XTupleSections
09:33:12 <koeien> yes use TupleSections.
09:33:19 <dmwit> Oh, hey, didn't know about TupleSections. Great!
09:33:42 <koeien> M.fromListWith (+) . words -- quite neat.
09:34:08 <koeien> M.fromListWith (+) . map (,1) . T.words -- even better.
09:37:57 <covi> what is T.?
09:38:06 <dmwit> Data.Text, probably
09:38:09 <koeien> import qualified Data.Text as T
09:38:26 <koeien> it's *way* faster than String
09:39:22 <covi> okay :) thanks
09:40:15 <rasfar> see, people like tuple sections but not free sections :-/
09:41:35 <geekosaur> of couyrse the problem with tuple sections is it makes tuple look like a type.  it's not; it's a family of types
09:47:48 <rasfar> i'm experiencing a weird problem using randomR
09:48:21 <rasfar> (n,_) = randomR (nlo,nhi) g  -- always gives n==nhi
09:48:38 <rasfar> if i trace the values of nlo,nhi they are 3 and 8
09:48:52 <rasfar> (if i put the literals in, i get variation of course)
09:49:04 <rwbarton> what do you mean "always"
09:49:17 <rwbarton> if you put the same g in you will get the same random number out
09:49:18 <rasfar> i mean i always get n == 8
09:49:32 <rwbarton> and as you don't use the "new g"...
09:49:32 <monochrom> what is the type of nlo, nhi?
09:49:33 <rasfar> i am mkStdGen on a list of seeds
09:49:41 <rwbarton> don't do that
09:49:41 <jeff_s_> I discovered my "Pattern matches overlap" problem with strings. It was caused by the OverloadedStrings language extension. Apparently that breaks string pattern matching, even when the value being matched on is a String.
09:49:49 <rasfar> Int type, explicitly, in the Config datatype
09:50:01 <rwbarton> correlated seeds will give you correlated initial random values
09:50:06 <rasfar> rwbarton: why not?  worked for my many times before!
09:50:11 <jeff_s_> It turns out that I don't need OverloadedStrings, so I'm all set.
09:50:21 <rasfar> what??
09:50:41 <monochrom> @let (nlo, nhi) = (3 :: Int, 8)
09:50:41 <rwbarton> you got lucky before? i don't know what to say
09:50:41 <rasfar> well, correlated i can deal with, but constant is a bit much
09:50:42 <lambdabot>  Defined.
09:50:44 <monochrom> nlo
09:50:48 <monochrom> > nlo
09:50:50 <lambdabot>   3
09:51:13 <rwbarton> is your list of seeds a list of consecutive integers?
09:51:15 <monochrom> > let (n,_) = randomR (nlo, nhi) (mkStdGen 42) in n
09:51:15 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:51:15 <lambdabot>         against inferred type ...
09:51:26 <rasfar> rwbarton: yep, it is [10000..]
09:51:26 <monochrom> @type mkStdGen
09:51:27 <lambdabot> Int -> StdGen
09:51:38 <rwbarton> :t nhi
09:51:39 <lambdabot> Integer
09:51:42 <monochrom> > let (n,_) = randomR (mkStdGen 42)  (nlo, nhi) in n
09:51:43 <lambdabot>   Couldn't match expected type `(t, t)'
09:51:43 <lambdabot>         against inferred type `System...
09:51:48 <monochrom> @type randomR
09:51:49 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
09:52:22 <rasfar> > let (n,_) = randomR (nlo,nhi) (mkStdGen 42) in n
09:52:22 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:52:23 <lambdabot>         against inferred type ...
09:52:23 <monochrom> > let (n,_) = randomR (nlo, nhi) (mkStdGen 42) in n
09:52:23 <lambdabot>   Couldn't match expected type `GHC.Types.Int'
09:52:23 <lambdabot>         against inferred type ...
09:52:27 <monochrom> @more
09:52:30 <rwbarton> nlo :: Int  nhi :: Integer
09:52:38 <monochrom> oh, darn
09:52:41 <monochrom> @undefine
09:52:52 <Veinor> i have an a -> m b, and I want Maybe a -> m (Maybe b)
09:52:56 <monochrom> @let (nlo, nhi) = (3::Int, 8::Int)
09:52:56 <lambdabot>  Defined.
09:53:00 <Veinor> is this possible
09:53:01 <monochrom> > let (n,_) = randomR (nlo, nhi) (mkStdGen 42) in n
09:53:01 <Veinor> ?
09:53:02 <lambdabot>   8
09:53:10 <monochrom> > let (n,_) = randomR (nlo, nhi) (mkStdGen 1942) in n
09:53:10 <rasfar> > let (n,_) = randomR (nlo,nhi) (mkStdGen 43) in n
09:53:11 <lambdabot>   can't find file: L.hs
09:53:12 <lambdabot>   8
09:53:29 <rasfar> and yet...
09:53:37 <rasfar> > let (n,_) = randomR (3,8) (mkStdGen 42) in n
09:53:37 <monochrom> > let (n,_) = randomR (nlo, nhi) (mkStdGen 1453) in n
09:53:38 <lambdabot>   8
09:53:39 <lambdabot>   8
09:53:41 <rasfar> > let (n,_) = randomR (3,8) (mkStdGen 43) in n
09:53:42 <lambdabot>   8
09:53:45 <rwbarton> try a larger number
09:53:47 <rasfar> wth?
09:53:52 <rasfar> > let (n,_) = randomR (3,8) (mkStdGen 10000) in n
09:53:53 <lambdabot>   8
09:53:53 <rwbarton> uh?
09:54:07 <rwbarton> > let (n,_) = randomR (3,8) (mkStdGen 1000000000) in n
09:54:09 <lambdabot>   6
09:54:14 <rasfar> i swear i'm seeing a good uniform distribution with the literals on my machine...
09:54:28 <rasfar> wow
09:54:52 <rasfar> okay, so i really ... need to thread the StdGen's all over the place ....
09:55:08 <rasfar> or generate a truly random list of seeds spanning the Int range?
09:55:16 <hpc> if you have no problem with being a terrible person, you can use the IO random functions
09:55:19 <koeien> not really, there is a random monad somewhere I think
09:55:19 <hpc> :t randomRIO
09:55:20 <lambdabot> forall a. (Random a) => (a, a) -> IO a
09:55:32 <koeien> you can generate an infinite list of random numbers as well
09:55:36 <hpc> or State StdGen
09:55:40 <koeien> yup
09:56:10 <b0fh_ua> Hi all! Is there something available in Haskell to convert data type to json? Like Show/Read classes?
09:56:16 <koeien> yes b0fh_ua.
09:56:17 <rasfar> what still puzzles me is that i see different results with literals, and with int constants...
09:56:31 <rasfar> thanks for the options people
09:56:41 <b0fh_ua> koeien: what is the name of the magic package? ;)
09:56:49 <koeien> b0fh_ua: look at aeson.
09:56:51 <hpc> rasfar: try it with Integer constants
09:56:52 <rwbarton> well a priori there's no reason why randomR at Int and randomR at Integer should produce the "same" random numbers
09:57:07 <monochrom> "when confronted with the problem of functionally generating random numbers, some people say, 'I know, I will feed it random seeds'. now they have two problems." :)
09:57:09 <rasfar> hpc: will do, that would be the quickest fix if it helps me
09:57:27 <danbst> @hoogle json
09:57:27 <lambdabot> package json
09:57:27 <lambdabot> package json-b
09:57:27 <lambdabot> package json-builder
09:57:29 <rasfar> lol monochrom
09:57:46 <rasfar> :t 3
09:57:47 <lambdabot> forall t. (Num t) => t
09:57:51 <rwbarton> it's still wrong to pass in a bunch of sequential seeds to generators and expect uncorrelated random outputs
09:57:54 <rasfar> um, yeah
09:57:57 <monochrom> @undefine
09:58:13 <rwbarton> I would suggest 'split' but it's also heavily broken
09:58:17 <rasfar> actually:
09:58:20 <rasfar> --       (nNodes,_) = randomR ((3,8)::(Int,Int)) g_nNodes  -- works!
09:58:36 <koeien> rwbarton: yes that is wrong but surprises many people
09:58:55 <rasfar> i use split all the time, too...  i should look into using State.
09:59:15 <rasfar> (not that that will help where i've been relying on split, come to think of it)
09:59:28 <hpc> :t split
09:59:29 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
09:59:55 <rwbarton> someone had a cool example where quickcheck "checked" that there were no numbers congruent to 4 mod 11, or something like that
09:59:58 <rasfar> in recursive functions which branch it's really hard to avoid that
10:00:19 <c_wraith> @check \x -> x `mod` 11 == 4
10:00:20 <lambdabot>   "Falsifiable, after 0 tests:\n0\n"
10:00:27 <c_wraith> @check \x -> x `mod` 11 /= 4
10:00:28 <lambdabot>   "Falsifiable, after 11 tests:\n4\n"
10:00:29 <rwbarton> it was something mod 11
10:00:56 <koeien> perhaps with another data type?
10:00:58 <geekosaur> @quote @check
10:00:58 <lambdabot> dons says: dons has quit ("improve @check")
10:01:14 <rwbarton> oh it was a little different
10:01:20 <hpc> preflex: seen dons
10:01:21 <preflex>  dons was last seen on #haskell 85 days, 22 hours, 47 minutes and 20 seconds ago, saying: btw, 884 nicks is the all time record (afaik) for #haskell. that's cool
10:01:21 <rwbarton> http://hackage.haskell.org/trac/ghc/ticket/3620
10:01:25 <c_wraith> @check \xs -> xs == reverse xs
10:01:26 <lambdabot>   "OK, passed 500 tests."
10:01:44 <dolio> @check \i -> i < 10000
10:01:46 <lambdabot>   "OK, passed 500 tests."
10:02:00 <c_wraith> dolio has proven all numbers are less than ten thousand!
10:02:03 <koeien> c_wraith: that's because of defaulting?
10:02:07 <koeien> [()]
10:02:10 <c_wraith> koeien: yes
10:03:26 <c_wraith> :t randomR
10:03:27 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
10:05:12 <dolio> @check (/= 317)
10:05:14 <lambdabot>   "OK, passed 500 tests."
10:05:15 <rwbarton> rasfar: do you really use each RandomGen just once? or is this a simplified example
10:05:43 <c_wraith> > map (head &&& length) . group . map fst $ [ randomR (1, 6) $ mkStdGen i | i <- [0..] ]
10:05:47 <lambdabot>   mueval-core: Time limit exceeded
10:06:12 <boku> @pl \x y -> x + y
10:06:12 <lambdabot> (+)
10:06:13 <c_wraith> > map (head &&& length) . group . map fst . take 10000 $ [ randomR (1, 6) $ mkStdGen i | i <- [0..] ]
10:06:15 <lambdabot>   [(6,10000)]
10:06:20 <rwbarton> if you do use each one just once then it should be fine to seed them with a sequence of random seeds (as generated by randomRs across the whole range of possible seeds)
10:06:21 * hackagebot data-accessor 0.2.2.2 - Utilities for accessing and manipulating fields of records  http://hackage.haskell.org/package/data-accessor-0.2.2.2 (HenningThielemann)
10:06:23 * hackagebot data-accessor-mtl 0.2.0.3 - Use Accessor to access state in mtl State monad class  http://hackage.haskell.org/package/data-accessor-mtl-0.2.0.3 (HenningThielemann)
10:06:24 <rwbarton> well
10:06:25 * hackagebot data-accessor-monads-tf 0.2.1.4 - Use Accessor to access state in monads-tf State monad type family  http://hackage.haskell.org/package/data-accessor-monads-tf-0.2.1.4 (HenningThielemann)
10:06:27 * hackagebot data-accessor-transformers 0.2.1.4 - Use Accessor to access state in transformers State monad  http://hackage.haskell.org/package/data-accessor-transformers-0.2.1.4 (HenningThielemann)
10:06:29 <rwbarton> I guess that is still sketchy
10:06:54 <boku> @pl \a b c d -> min ((min a b) (min c d))
10:06:54 <lambdabot> (((min .) .) .) . flip flip min . (((.) . (.)) .) . min
10:07:19 <boku> @pl \a b c d -> min (min a b) (min c d)
10:07:19 <lambdabot> flip flip min . (((.) . (.) . min) .) . min
10:07:40 <zhulikas> looks like a mess
10:08:16 <boku> @pl \a b c d -> min (min a b) (min c d)
10:08:16 <lambdabot> flip flip min . (((.) . (.) . min) .) . min
10:08:19 <rwbarton> or you can generate a sequence of numbers to throw away, but keep the RandomGens to pass around, that should be safe-ish
10:09:31 <nick8325> @check liftM2 (/=) (return () >> choose (0, 10)) (choose (0, 10))
10:09:32 <lambdabot>   Not in scope: `choose'Not in scope: `choose'
10:09:39 <rasfar> well, i use random numbers a lot in various ways, but in this spot i am using them just once, so i'll try a spanning list of random seeds instead.
10:09:50 <nick8325> doh. that passes in ghci
10:11:11 <b0fh_ua> With GHCI, how can I test TemplateHaskell things?
10:11:21 * hackagebot equal-files 0.0.4 - Shell command for finding equal files  http://hackage.haskell.org/package/equal-files-0.0.4 (HenningThielemann)
10:11:21 <parcs`> what do you mean test?
10:11:24 <parcs`> use them interactively?+
10:11:26 <boku> @pl \a b c d -> min (min a b) $ min c d
10:11:27 <lambdabot> flip flip min . (((.) . (.) . min) .) . min
10:11:43 <koeien> boku: minimum [a,b,c,d]
10:11:44 <b0fh_ua> parcs`: yep
10:12:25 <boku> thx, but i'm trying point-free notation :)
10:12:33 <parcs`> :set -XTemplateHaskell and it should "just work"
10:13:52 <rasfar> rwbarton: yeah, that does it. :)
10:15:56 <ksf__> @djinn (a -> b -> b) -> (a -> b) -> [a] -> b
10:15:56 <lambdabot> Error: Undefined type []
10:16:05 <ksf__> no induction?
10:16:10 <hpc> @djinn-env
10:16:10 <lambdabot> data () = ()
10:16:10 <lambdabot> data Either a b = Left a | Right b
10:16:10 <lambdabot> data Maybe a = Nothing | Just a
10:16:10 <lambdabot> data Bool = False | True
10:16:10 <lambdabot> data Void
10:16:12 <lambdabot> type Not x = x -> Void
10:16:14 <lambdabot> class Monad m where return :: a -> m a; (>>=) :: m a -> (a -> m b) -> m b
10:16:15 <boku> guys, can i make my commands (pl) not visible to you?
10:16:16 <lambdabot> class Eq a where (==) :: a -> a -> Bool
10:16:20 <hpc> oh god
10:16:24 * hackagebot event-list 0.1.0.1 - Event lists with relative or absolute time stamps  http://hackage.haskell.org/package/event-list-0.1.0.1 (HenningThielemann)
10:16:25 * hackagebot explicit-exception 0.1.7 - Exceptions which are explicit in the type signature.  http://hackage.haskell.org/package/explicit-exception-0.1.7 (HenningThielemann)
10:16:25 <hpc> boku: PM lambdabot
10:16:27 <ksf__> boku, /msg lambdabot
10:16:27 * hackagebot liblastfm 0.0.2.1 - Wrapper to Lastfm API  http://hackage.haskell.org/package/liblastfm-0.0.2.1 (MatveyAksenov)
10:17:01 <boku> thanks and sorry, sorry, sorry
10:17:51 * ksf__ thinks that type there for a fold is quite curious.
10:18:09 <boku> pm lambdabot
10:18:20 <ksf__> the (a -> b) is there just so that the types don't get unified.
10:19:29 <covi> words "hi." will return "hi." as a token, instead of "hi". How to get around with this?
10:19:52 <ksf__> > filter (isAlpha) "hi."
10:19:53 <lambdabot>   "hi"
10:20:01 <ksf__> > filter (isAlpha) "Hello, World!"
10:20:02 <lambdabot>   "HelloWorld"
10:20:11 <ksf__> words just breaks at spaces.
10:20:55 <koeien> don't use () there
10:21:13 <koeien> (well, you are allowed to, but it's not necessary and bad style)
10:21:23 <ksf__> I know
10:21:43 <ksf__> but I usually don't bother until I get tired and do a round of hlint.
10:21:55 <covi> ksf__: thanks
10:22:42 <ksf__> I might want to insert "not ." there, for example. prematurely deleting the parens would make me re-insert them.
10:23:10 <fmap> covi: you should take a look into wordsBy from Data.List.Split
10:25:25 <rasfar> split has been heavily broken for what, 20 years?  what is best practice where split is the obvious choice?  i'll look for a blog or something...
10:26:19 <ksf__> rasfar, http://hpaste.org/63500 ?
10:26:22 * hackagebot iteratee 0.8.8.2 - Iteratee-based I/O  http://hackage.haskell.org/package/iteratee-0.8.8.2 (JohnLato)
10:26:24 * hackagebot iteratee-stm 0.1.2 - Concurrent iteratees using STM  http://hackage.haskell.org/package/iteratee-stm-0.1.2 (JohnLato)
10:27:27 <untitled> hi, how can I not omit "Nothing" if it occurs when adding something to list?
10:28:05 <parcs`> > catMaybes [Nothing, Just 5, Nothing, Nothing, Just 8]
10:28:06 <lambdabot>   [5,8]
10:28:12 <rasfar> ksf__: we are talking about random numbers here, right?
10:28:26 <ksf__> oh, that split.
10:28:26 <colah> Anyone feel like looking at a rought draft of an introduction to monads I'm writing? https://github.com/colah/colah-essays/blob/master/monads.md
10:28:26 <lambdabot> colah: You have 1 new message. '/msg lambdabot @messages' to read it.
10:28:48 <ksf__> I didn't even yet hear anyone I'd trust about it that split has a sane formal basis.
10:29:08 <rasfar> yeah, but if your "f" was stochastic you might have had something there... ;)
10:30:01 <rasfar> i've found a haskell-cafe topic and a few other bits, just looking now
10:30:43 <ksf__> apart from numerological issues, I think just taking every other number in the sequence for each side of the split seems sensible.
10:30:56 <ksf__> doesn't scale beyond a couple of splits, of course.
10:31:26 * hackagebot hCsound 0.4.1 - interface to CSound API  http://hackage.haskell.org/package/hCsound-0.4.1 (JohnLato)
10:31:28 * hackagebot x-dsp 0.2.3 - A embedded DSL for manipulating DSP languages in Haskell  http://hackage.haskell.org/package/x-dsp-0.2.3 (JohnLato)
10:31:30 * hackagebot board-games 0.1.0.1 - Three games for inclusion in a web server  http://hackage.haskell.org/package/board-games-0.1.0.1 (HenningThielemann)
10:32:27 <untitled> parcs`: thanks
10:32:30 <rasfar> ksf__, i typically only feel a need for split when i'm sending two hopefully uncorrelated generators down each of a pair of recursive calls
10:32:43 <rasfar> in which case there is a lot of splitting happening
10:33:31 <lysgaard> Does there exist a modulo function for non integers in prelude?
10:33:40 <koeien> lysgaard: what would that be?
10:33:52 <koeien> you mean, arbitrary calculations in GF(p) or GF(q) ?
10:34:01 <byorgey> lysgaard: properFraction
10:34:12 <ClaudiusMaximus> @index mod'
10:34:12 <lambdabot> bzzt
10:34:22 <byorgey> if you want mod 1
10:35:32 <kallisti> $ cloc --exclude-dir=.git,.svn sel/rb/lib/selenium/webdriver/ sel/py/selenium/ sel/dotnet/src/WebDriver/ sel/java/client/src/org/openqa/selenium/ hs-webdriver | sprunge
10:35:39 <lysgaard> I want the remainder of a divided by b when a and be aren't integers. I know it's trivial to implement and I did, but I don't understand why it's not present in prelude.
10:35:43 <kallisti> http://sprunge.us/TEIO
10:35:47 <kallisti> ...what did I do wrong.
10:37:27 <mm_freak> lysgaard: yes there is, let me look it up
10:39:26 <bitonic> kallisti: are they all on par for what regards functionality?
10:39:31 <mm_freak> lysgaard: see Data.Fixed
10:39:45 <kallisti> bitonic: mine is lacking a few things. A few hundred lines of code at most, I'd estimate.
10:40:08 <kallisti> ...the Java one /must/ be doing something special.
10:40:14 <kallisti> bitonic: but otherwise that's a difficult thing to measure.
10:40:15 <bitonic> kallisti: probably a lot of tests.
10:40:24 <kallisti> bitonic: no the tests are elsewhere. or at least I think they are...
10:40:27 <bitonic> exclude tests from the measurement
10:40:35 <kallisti> the other bindings are not including tests.
10:40:38 <kallisti> but the Java one may be.
10:40:38 <bitonic> if they are, then they are doing something strange, yes.
10:40:46 <bitonic> otherwise it fits eheh
10:41:04 <bitonic> the fact that ruby is twice the size as python is interesting
10:41:13 <bitonic> but in the end it depends on the developers
10:41:58 <kallisti> bitonic: no tests in the Java directory it seems.
10:42:49 <bitonic> kallisti: lol ok. if they really are all in par, then it's a good case study :P
10:43:04 <lysgaard> mm_freak: Thanks, that was just what I wanted
10:43:17 <kallisti> bitonic: I'm only missing a few features, so my code isn't completely up to par.
10:43:35 <bitonic> kallisti: well finish it, and compare again
10:43:39 <kallisti> yes.
10:43:40 <mm_freak> @hoogle (Real a) => a -> a -> a
10:43:40 <lambdabot> Data.Fixed mod' :: Real a => a -> a -> a
10:43:40 <lambdabot> Prelude asTypeOf :: a -> a -> a
10:43:40 <lambdabot> Network.BufferType buf_append :: BufferOp a -> a -> a -> a
10:43:47 <mm_freak> hehe, there we go
10:43:52 <bitonic> kallisti: actually, finish it, use it for 6 months, compare again :P
10:44:00 <mm_freak> > mod' 5 2.4
10:44:01 <lambdabot>   0.20000000000000018
10:44:11 <kallisti> bitonic: it's received about a month of use. so it is working, for what it's worth.
10:44:21 <mm_freak> > mod' 5 (2 + 2%5)
10:44:22 <lambdabot>   1 % 5
10:44:49 <bitonic> kallisti: for what concerns Java, it's more about the java colture than about java, the language...
10:45:34 <bitonic> I'm also quite impressed with the amount of comments :P
10:46:09 <kallisti> bitonic: yes there's more C# comments than C# code.
10:46:22 * hackagebot http-monad 0.1.0.2 - Monad abstraction for HTTP allowing lazy transfer and non-I/O simulation  http://hackage.haskell.org/package/http-monad-0.1.0.2 (HenningThielemann)
10:47:55 <kallisti> bitonic: my commenting is spare in comparison. roughly the same comment/code ratio as the Ruby code.
10:48:01 <kallisti> granted, I'm not an entire development team.
10:49:32 <bitonic> kallisti: the project I'm working on now has almost 0 "code" comments, just essays at the top of each file.
10:49:40 <kallisti> bitonic: the large Java count is a result of having a lot of extra server-side stuff unrelated to the actual client, it turns out.
10:50:05 <bitonic> kallisti: ok, so what is it in the end? I'd guess a bit more than C# :P
10:50:12 <kallisti> probably.
10:50:19 <kallisti> but... I don't know
10:50:24 <kallisti> laziness sets in. :P
10:51:01 <kallisti> I'll probably do a more through measurement when I finish version 1.0, which will have most of the features I want.
10:51:07 <kallisti> *thorough
10:51:22 * hackagebot iff 0.0.3 - Constructing and dissecting IFF files  http://hackage.haskell.org/package/iff-0.0.3 (HenningThielemann)
10:56:24 * hackagebot internetmarke 0.0.3 - Shell command for constructing custom stamps for German Post  http://hackage.haskell.org/package/internetmarke-0.0.3 (HenningThielemann)
10:56:26 * hackagebot jack 0.6.1 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.6.1 (HenningThielemann)
10:56:50 <kallisti> bitonic: there's a third-party PHP client from Facebook that weighs in at 434 lines.
10:57:23 <kallisti> it basically does dynamic typing tricks to directly mimic the actual HTTP/JSON protocol.
11:00:40 <keep_learning> Hello all
11:01:09 <teneen> How to see the generated core when compiling with GHC?
11:02:21 <keep_learning> teneen, ghc -O2 -ddump-simpl G.hs
11:02:28 <c_wraith> teneen: the easiest is the ghc-core tool on hackage
11:03:14 <monochrom> -dsuppress-uniques helps readability and reduces noise
11:03:51 <monochrom> the ghc-core program adds all-natural colouring
11:03:58 <keep_learning> I am looking for fast priority queue .
11:04:18 <keep_learning> Kindly suggest me a package priority queue package
11:04:27 <teneen> Ok Thanks all :)
11:04:41 <keep_learning> which is fast
11:04:55 <keep_learning> not necessary pure
11:05:15 <Mathnerd314> @google haskell priority queue
11:05:17 <lambdabot> http://hackage.haskell.org/package/priority-queue-0.2.2
11:05:17 <lambdabot> Title: HackageDB: priority-queue-0.2.2
11:05:48 <monochrom> the problem is I don't know which one is fast enough. I have the hunch that they are all pretty close
11:06:05 <teneen> Why do functions in normal haskell code don't get their same name in the core output, unless a module is declared?
11:06:36 <Mathnerd314> @google fast haskell priority queue
11:06:41 <lambdabot> http://en.literateprograms.org/Priority_Queue_(Haskell)
11:06:41 <lambdabot> Title: Priority Queue (Haskell) - LiteratePrograms
11:06:54 <t7> teneen: they are not exported so it doesnt matter
11:07:02 <monochrom> because human-chosen names are too easy to clash
11:10:37 <monochrom> another point is your code receive pretty drastic re-arrangement by compilation. what you write as a function gets inlined and is no longer a function. what you don't write as a function gets pulled out as a function. your names no longer have a reason to exist, and there need new names you have never named.
11:11:07 <koeien> there is a reason: readability of core output
11:14:33 <monochrom> do you know what is inlining?
11:15:40 <monochrom> you write "haha x = x+5", and "main = print (haha 10)". compiler changes that to "main = print (10 + 5)". where do you attach the name "haha"?
11:16:11 <monochrom> or are you suggesting for the sake of readability, nothing should be inlined?
11:17:52 <mekeor> GHCi needs a feature to find out the fixity of an operator.
11:18:05 <mekeor> (does lambdabot have such a feature?)
11:18:07 <monochrom> try :info +
11:18:34 <mekeor> monochrom: well. that doesn't work for everything, unfortunately.
11:18:37 <Mathnerd314> hmm, why can't you cabal install ghc?
11:19:01 <dcoutts> Mathnerd314: nobody has bothered to write the custom Setup.hs that would be necessary
11:19:01 <merijn> mekeor: What doesn't it work for?
11:19:46 <monochrom> it works for everything. if it doesn't display a "infix blah blah" line for a particular operator, that means the default is in effect, i.e., infixl 9 IIRC
11:20:13 <merijn> Default is infixl 9 for functions, for operators it's infixl 6
11:20:29 <monochrom> no
11:20:36 <merijn> No?
11:20:44 <mekeor> merijn: e.g. (!!)
11:20:56 <merijn> nvm
11:20:57 <monochrom> I'm going to quote Haskell 2010 to you
11:21:00 <merijn> You're right
11:21:04 <monochrom> ok good
11:21:05 <mekeor> or (!) from Text.Blaze.Html5
11:21:14 <merijn> In h98 anyway, I assume 2010 didn't change it
11:21:36 <monochrom> they receive the default, so ghci doesn't bother to display it
11:21:44 <Mathnerd314_> dcoutts: presumably it would be better than the collection of scripts that are there now
11:22:13 <dcoutts> Mathnerd314_: not really since it'd just wrap those ./configure and Makefile scripts
11:22:24 <mekeor> monochrom: hm. you seem to be right.
11:23:09 <monochrom> because I have verified empirically. the scientific method.
11:23:12 <Mathnerd314_> dcoutts: what are the scripts doing that cabal can't do?
11:23:23 <mekeor> monochrom: heh :)
11:23:59 <monochrom> write a module to test it. make 3 new operators. 1st one has infixr 4 or something. 2nd one has explicit infixl 9. 3rd one let it default. try :info on all of them
11:24:12 <dcoutts> Mathnerd314: the ghc build is made up of loads of components, it doesn't really fit the Cabal model of a package
11:24:29 <dcoutts> Mathnerd314: internally ghc uses Cabal to build all the libs
11:24:34 <Mathnerd314> loads of components = loads of packages?
11:24:44 <monochrom> you will be, for example, quite amused that even for the 2nd one (explicit infixl 9), :info omits the fixity line
11:25:18 <monochrom> it is unsatisfactory UI IMO, but that's the current, verifiable behaviour
11:25:40 <mekeor> okay.
11:26:15 <mekeor> when i grow up, i add that feature to ghc.
11:26:37 <dmwit> More like remove that misfeature.
11:26:45 <mekeor> haha :D
11:26:51 <dmwit> I'm sure there's an "if" in there that checks if it's infixl 9 and then intentionally doesn't print it.
11:27:04 <mekeor> hmm
11:29:12 <keep_learning> @google fast priority queue in monad
11:29:15 <lambdabot> http://www.haskell.org/hoogle/?hoogle=Queue+-network+%2Bpackage
11:29:15 <lambdabot> Title: Queue -network +package - Hoogle
11:29:56 <monochrom> by 2020, "cabal install gcc" will be available. however, "cabal install ghc" is postponed to 2025
11:30:45 <byorgey> monochrom: following the complete rewrite of gcc in Haskell?
11:31:02 <mokus> what about "cabal install plan9"?
11:31:03 <dcoutts> heh heh
11:31:40 <monochrom> the Kyoto Protocol requires that "cabal install ubuntu" and "cabal install arch" must be ready by 2050. however, some countries like Canada and the US have renouned it
11:31:53 <byorgey> hehehe
11:32:46 <t7> i pray by 2020 we have a cabal replacement
11:32:54 <t7> with strong AI to resolve conflicts
11:33:02 <t7> and write the code for me
11:33:09 <Clint> and shared libraries with stable ABI
11:33:09 <dcoutts> t7: try the new solver in the darcs version
11:33:28 <byorgey> the darcs version of cabal has a strong AI
11:34:04 <byorgey> and a natural language interface, inspired by Wolfram Alpha
11:34:22 <alpounet> and makes coffee.
11:34:27 <t7> ponies
11:34:29 <byorgey> cabal --nl "Install pandoc but don't break anything kthx"
11:34:52 <lysgaard> ah, what a wonderfull world that would be...
11:35:18 <alpounet> byorgey, "Can't satisfy: don't break anything kthx"
11:35:25 <mokus> i'd totally use cabal --nl "file my tax return"
11:35:31 <t7> so xxd is cool then
11:35:41 <t7> all this cool stuff built right into the os
11:39:50 <t7> cmon windows, you got some catching up todo
11:40:20 <dmwit> xxd isn't exactly built into the operating system.
11:40:37 <t7> bundled with
11:40:46 <t7> at least i think it was
11:41:08 <dmwit> It's bundled in some distributions, yep. But the distribution includes considerably more than just the operating system.
11:41:11 <dmwit> usually.
11:41:19 <t7> i thought a distro was an OS
11:41:25 <t7> linux was a kernel
11:41:27 * hackagebot jack 0.6.1.1 - Bindings for the JACK Audio Connection Kit  http://hackage.haskell.org/package/jack-0.6.1.1 (HenningThielemann)
11:41:47 <dmwit> I would call the kernel + drivers the operating system.
11:41:53 <byorgey> what counts as part of the "OS" and what doesn't is sort of a blurry line.
11:42:02 <dmwit> That's true enough.
11:42:04 <t7> dmwit: dont tell that to stallman
11:42:10 <rwbarton> but surely calling some random userspace program "built right into the os" is misleading at best
11:42:26 <dmwit> t7: Why not? Isn't that sort of his whole point with the "It's called GNU/Linux" thing?
11:42:35 <byorgey> rwbarton: oh, agreed
11:43:00 <dmwit> Linux is the OS, GNU is the set of tools that basically every distribution includes.
11:43:04 <monochrom> I would just phrase it as "xxd comes out of the box"
11:43:14 <rwbarton> yes
11:43:18 <rwbarton> they throw a lot of stuff into the box
11:43:42 <mokus> like ddate
11:43:58 <t7> ive been proven wrong, this is when i like to call you all autistic to make myself feel better
11:44:02 <mokus> i'd hardly call that a "part of" the OS, but you can hardly find a linux distro without it
11:46:27 * hackagebot lazyio 0.0.3.1 - Run IO actions lazily while respecting their order  http://hackage.haskell.org/package/lazyio-0.0.3.1 (HenningThielemann)
11:48:22 <monochrom> ironically, microsoft was the one championing the blurring of the OS boundary.
11:48:57 <merijn> dmwit: I disagree that linux is the OS, you need multiple tools just to be able to boot...
11:49:35 <merijn> I would argue that booting is the very least you have to be able to do to call yourself an OS...
11:49:50 <dmwit> pfft, booting is for the weak
11:50:00 <int-e> merijn: but linux takes over pretty much completely afterwards. that's what makes it an OS.
11:50:06 <ique> I have some questions about concurrency.. I'm not sure I've wrapped my head around MVars correctly or if I really need them.. I have a list of IO (Something) functions that return Something.. And I want to execute them concurrently and save all the Somethings in a list.
11:50:12 <earthy> linux used to be able to boot
11:50:31 <Mathnerd314> ah, it appears cabal / ghc don't do parallel builds, so they used make (which does)
11:50:41 <mm_freak> merijn: there is a good reason for that
11:50:43 <merijn> int-e: Completely is a big word...
11:51:20 <merijn> mm_freak: Sure, I'm not arguing its dumb or bad. I'm just saying that it disqualifies linux (as in just the kernel) from being an OS
11:51:25 <ique> Should I. spawn every IO action in a thread (forkIO) and then when it's done at the end take a list from an MVar, but the results in it and put it back in the MVar right away, or is there a better way?
11:51:27 * hackagebot lazyio 0.0.3.2 - Run IO actions lazily while respecting their order  http://hackage.haskell.org/package/lazyio-0.0.3.2 (HenningThielemann)
11:51:44 <dmwit> ique: There's a better way.
11:51:46 <merijn> ique: Do you care about the ordering of the results?
11:51:50 <mm_freak> merijn: yeah, that's true
11:51:53 <ique> merijn: no
11:52:01 <merijn> If not, use a Chan and have all workers put an item into the Chan
11:52:14 <merijn> Have a single worker read items and put them in a list
11:52:35 <ique> merijn: ah.. clever
11:52:49 <monochrom> how does the single worker know the end?
11:52:55 <merijn> You probably want some kind of termination item/counter to figure out when the final task has finished
11:53:00 <ique> merijn: but how do I signify that all threads are done then?
11:53:04 <mm_freak> ique: that usage of MVar seems perfectly reasonable…  just note that the threads might live longer than necessary with that approach
11:53:25 <mm_freak> ique: i wouldn't care though…  Chan could make them terminate earlier, but at the expense of more computing power
11:53:31 <ique> merijn: ah i see.. I know how many tasks (length of the original list) that are supposed to be done, so that should't be hard
11:53:32 <monochrom> then again, the original approach faces the same question
11:54:21 <merijn> ique: Yeah, just have a special termination value that each thread writes when it is done. Keep a counter in the merger that decrements whenever you read a termination item. Terminate when the counter hits zero, something like that
11:54:27 <mm_freak> ique: if you know the number of threads a quick-n-dirty way is to use replicateM_
11:54:44 <mm_freak> results <- replicateM n (takeMVar resultVar)
11:55:10 <monochrom> but I would use as low-tech as atomicModifyIORef until more requirements force me up
11:56:31 <mauke> preflex: seen Igloo
11:56:31 <preflex>  Igloo was last seen on #ghc 7 days, 3 hours, 30 minutes and 13 seconds ago, saying: luite: There are also various thing in Confg that might be useful
11:57:14 <ique> mm_freak: mhm! that's true.. but then the question is if I should start a thread for every action or run 4 threads for number of cores and execute the tasks serially on the threads.. they're pretty long-running tasks though, like 200ms, and I don't know how much overhead forkIO causes
11:57:38 <tkahn6> i'm getting a parse error in hlint but that same file is compiling fine with GHC
11:57:42 <tkahn6> do i submit a bug?
11:58:00 <mekeor> does blaze-html have a channel?
11:58:04 <mm_freak> ique: unless you have tens of millions of tasks there is nothing wrong with starting a thread for each task
11:58:21 <mm_freak> ique: to limit the concurrency you can use a semaphore
11:58:25 <byorgey> ique: forkIO causes very little overhead.
11:58:29 <mm_freak> see QSem
11:58:37 <ique> mm_freak: alright! i'll probably have a few thousand maximum so then there should be much of a problem
11:58:48 <ique> shouldn't*
11:59:18 <mm_freak> ique: but usually you would do that only to limit the side effects, not the concurrency itself
11:59:22 <byorgey> tkahn6: what version of hlint, and what version of GHC?
11:59:30 <mm_freak> like:  you want up to 500 network connections
11:59:41 <byorgey> tkahn6: if there is a bug it would be in haskell-src-exts (which is what hlint uses for parsing)
11:59:44 <ique> mm_freak: i see, thanks
11:59:46 <mm_freak> the distribution among processors is handled just fine by the RTS
12:00:30 <tkahn6> byorgey: The Glorious Glasgow Haskell Compilation System, version 7.0.4 and HLint v1.8.21, (C) Neil Mitchell 2006-2011
12:00:48 <ique> mm_freak: i'll try to create an MVar and then replicateM at the end and make every thread write it's result to the MVar
12:01:16 <ique> mm_freak: and then I can see if I'll learn of some reason not to do that from doing it ^^
12:01:28 * hackagebot language-javascript 0.5.0 - Parser for JavaScript  http://hackage.haskell.org/package/language-javascript-0.5.0 (AlanZimmerman)
12:01:35 <tkahn6> byorgey: haskell-src-exts 1.11.1
12:01:41 <byorgey> tkahn6: OK, well, 1.8.21 uses haskell-src-exts 1.11, and the latest version of hlint (1.8.28) uses the latest haskell-src-exts (1.13)
12:01:47 <mm_freak> sounds reasonable…  you might also try monochrom's approach with atomicModifyIORef, but that's going to be slower when there is a lot of concurrency…  also i'd expect the MVar variant to be more convenient
12:01:56 <byorgey> tkahn6: so before filing a bug I would check whether the bug still happens with the latest version of hlint
12:02:02 <tkahn6> byorgey: ok i'll update
12:02:03 <tkahn6> thanks
12:04:16 <mekeor> i have got a problem. it's illustrated here:
12:04:18 <hpaste> mekeor pasted “IO action in a do-block of an action of type :: ServerPartT IO Response ??” at http://hpaste.org/66773
12:04:44 <dmwit> mekeor: Probably "l <- liftIO getLine".
12:04:57 <dmwit> mekeor: Assuming ServerPartT offers a MonadIO instance.
12:05:12 <shergill> i'm trying to get rss feeds (using yesod-newsfeed 1.0) for my site to work, but for some reason it's escaping the feed description incorrectly: http://hpaste.org/66772. any ideas?
12:05:20 <mekeor> it does, iirc
12:05:26 <mekeor> yep
12:05:33 <mekeor> @hoogle liftIO
12:05:34 <lambdabot> Network.CGI liftIO :: MonadIO m => IO a -> m a
12:05:34 <lambdabot> Control.Monad.IO.Class liftIO :: MonadIO m => IO a -> m a
12:05:34 <lambdabot> Network.CGI liftIO :: MonadIO m => forall a. IO a -> m a
12:05:46 <mekeor> dmwit: Control.Monad.IO.Class.liftIO ?
12:05:59 <monochrom> yeah
12:06:03 <dmwit> I suppose. It's probably available from a more convenient module.
12:06:14 <mekeor> dmwit: awesome.
12:06:22 <mekeor> #haskell is awesome. thanks again, guys.
12:06:28 * hackagebot llvm-extra 0.3.0.1 - Utility functions for the llvm interface  http://hackage.haskell.org/package/llvm-extra-0.3.0.1 (HenningThielemann)
12:06:30 * hackagebot markov-chain 0.0.3.2 - Markov Chains for generating random sequences with a user definable behaviour.  http://hackage.haskell.org/package/markov-chain-0.0.3.2 (HenningThielemann)
12:07:00 <dmwit> mekeor: Slightly more generally (in one axis) and less generally (in another axis), "l <- lift getLine", assuming ServerPartT offers a MonadTrans instance.
12:07:42 <dmwit> liftIO is specialized to lifting IO actions, but general over how many transformers it will lift through; lift is generalized over what monad's actions it lifts, but specialized to lifting through exactly one transformer.
12:08:05 <byorgey> I think liftIO would be preferred in this case.
12:08:20 <dmwit> I agree, but I predict this kind of question with a non-IO type in the future.
12:08:35 <mekeor> dmwit: it is indeed in monadtrans.
12:08:52 <byorgey> a reasonable prediction.
12:09:10 <mekeor> :)
12:09:23 <t7> anyone know the unix syscall for putc?
12:09:33 <t7> or just writing 1 char to stdout
12:09:38 <ksf__> why does my non-paralellised code run faster with -N1 than with -N4?
12:09:54 <ksf__> t7, depends on kernel.
12:09:59 <ksf__> syscalls aren't standardised.
12:10:31 <ksf__> I can tell you the linux one for write...
12:10:32 <ksf__> it's three.
12:11:08 <t7> write writes a string ?
12:11:12 <t7> or a char
12:11:21 <ksf__> string.
12:11:44 <int-e> ksf__: just a thought: the IO manager is an extra Haskell thread. But this may be a case for threadscope.
12:12:08 <ksf__> t7, http://hpaste.org/66774
12:12:16 <ksf__> don't ask me where I got them from.
12:12:35 <ksf__> oh, and don't use int 0x80, there's the syscall insn.
12:12:48 <mekeor> ksf__ is a true hacker.
12:13:07 <ksf__> heh, that was part of an assignment.
12:13:15 <dcoutts> ksf__: perhaps the parallel GC is taking longer, see +RTS -s
12:13:25 <ksf__> writing arcanoid in assembly
12:13:47 <ksf__> I made it interesting by doing it under linux and going for realistic collision.
12:14:24 <Mathnerd314> interesting: http://www.eweek.com/c/a/Application-Development/Why-Programmers-Should-Use-the-Haskell-Language-Now-669827/
12:14:47 <int-e> Mathnerd314: thank you for not posting a reddit link.
12:15:23 <ksf__> hmm. it might even be the case that linux doesn't know putc.
12:15:30 <ksf__> I've got it as a library function, here.
12:15:46 <Mathnerd314> int-e: hmm?
12:16:27 <int-e> ksf__: who needs putc when one has 'write'?
12:16:29 * hackagebot mohws 0.2.1.2 - Modular Haskell Web Server  http://hackage.haskell.org/package/mohws-0.2.1.2 (HenningThielemann)
12:16:38 <ksf__> exactly.
12:17:34 <ksf__> anyhow, there should be little you can't write with those syscalls I posted.
12:18:09 <ksf__> in fact, if you're ioctl'ing you're probably beyond all hope.
12:18:34 <mekeor> Mathnerd314: that website is blank for me.
12:18:40 <Mathnerd314> int-e: so are you saying I should post it on the Haskell reddit, or what?
12:18:45 <mm_freak> when i need a portable machine-level language what functional languages are there?
12:18:47 <t7> damn write takes a ptr
12:18:54 <t7> i need to allocate space for my char
12:19:00 <ksf__> Mathnerd314, mekeor for me too
12:19:05 <mekeor> ah, now.
12:19:06 <t7> how on earth do i do that
12:19:20 <sm> forth ?
12:19:21 <Mathnerd314> ksf__: interesting.
12:19:24 <monochrom> curious, blank here too, but I will try turning off adblock in a moment
12:19:26 <ique> Hmm.. I implemented the MVar and it produces all the right output, but it's only running 150% CPU and actually taking a lot longer than single-threaded
12:19:37 <mekeor> sm: a concatenative programming language.
12:19:55 <rwbarton> t7: how about on the stack? what are you doing anyways
12:20:02 <ique> I suspect I'm running into some laziness issues here, can you get that with IO?
12:20:05 <dmwit> t7: write(&'a', 1) ;-)
12:20:13 <monochrom> yeah, it's adblocked
12:20:19 <t7> dmwit: i know how todo it in c :P
12:20:26 <mauke> dmwit: "a"
12:20:34 <t7> its asm im rubbish at
12:20:43 <dmwit> mauke: That allocates two bytes -- what are you, BLEEDING memory over there??
12:20:58 <mauke> dmwit: ok, but at least it compiles :-)
12:21:18 <ksf__> Mathnerd314, gosh what horrendeous marketspeak.
12:21:26 <mauke> (char [1]){'a'}  // OPTIMIZED
12:21:30 * hackagebot opensoundcontrol-ht 0.1.1.1 - Haskell OpenSoundControl utilities  http://hackage.haskell.org/package/opensoundcontrol-ht-0.1.1.1 (HenningThielemann)
12:21:47 <dmwit> haha
12:21:58 <dmwit> It's true, I'm lousy at C.
12:22:24 <ksf__> "haskell is good for implementing homomorphic encryption" omg.
12:23:00 <int-e> Mathnerd314: no. I truly dislike those indirect links.
12:23:23 <merijn> dmwit: In all likelihood you're not even programming C, but rather some C-like dialect commonly accepted by C compilers and mistakenly referred to as C :p
12:23:37 <ksf__> -std=C99 -pedantic
12:23:43 <mauke> *c99
12:23:44 <ksf__> (seriously)
12:24:03 <Mathnerd314> haskell is good for debugging - right.... :p
12:24:12 <ksf__> if you need anything different, at least have the common decency to factor it out.
12:24:17 <merijn> ksf__: I've long ago learned and accepted that I can't C :p
12:24:35 <merijn> ksf__: Even then you can do lots of things which are wrong, but work
12:25:00 <merijn> i.e. people casting pointers to int's, that sorta thing
12:25:04 <monochrom> I am most offended by having models pose for some of the slides. it is like a supermarket ad?
12:25:12 <ksf__> oh. -Wall
12:25:13 <dmwit> merijn: Pfft, my C-like dialect isn't even accepted by C compilers. Take that!
12:26:04 <merijn> Fun fact of the day, pointer arithmetic is signed! (Or at least undefined and happening to be implemented as signed in gcc for x86...)
12:26:14 <Mathnerd314> monochrom: those are probably just stock photos
12:26:35 <monochrom> in retrospect, adblock made the right decision to block it
12:27:06 <monochrom> it is more ad-like than real ads
12:27:41 <t7> when i compile putchar it does callq instead of int 80h
12:27:44 <t7> thats cheating
12:28:32 <mauke> haha
12:28:59 <mauke> http://mauke.hopto.org/stuff/haskell/hell.hs this is how I haskell
12:29:17 <monochrom> onoes
12:29:18 <rwbarton> looks legit
12:29:28 <t7> how the hell do people write code in asm
12:29:40 <dmwit> Slowly. And with lots of bugs.
12:29:41 <c_wraith> usually one byte at a time.
12:29:41 <ksf__> t7, relocations.
12:29:43 <t7> i am very impressed by anyone who can
12:29:46 <ksf__> t7, with nasm.
12:30:09 <monochrom> mauke, of all people, you should be using a Bytestring for that!
12:30:18 <ksf__> you really don't need to emulate libc.
12:30:18 <merijn> mauke: Reminds me of:
12:30:19 <merijn> @quote augustss ioccc
12:30:20 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
12:30:25 <ksf__> it's doing lots of fluff.
12:30:31 <ksf__> if you want a model, use tinylibc.
12:30:47 <ksf__> or http://www.fefe.de/dietlibc/
12:31:16 <mauke> monochrom: I like the irony
12:31:24 <mekeor> so, with -XOverloadedStrings, "foo" isn't String anymore but IsString a ?
12:31:38 <mekeor> ksf__: r u from germany?
12:31:52 <ksf__> yep
12:31:54 <mizu_no_oto> I'm currently taking Abstract Algebra 1, and part of the course is going to be doing a project.  So far, we've been talking mostly about different groups (the textbook, as far as I can tell, never even mentions monoids!, just groups, rings, etc).  What's the most useful group from a Functional Programming perspective, and why?  Also, other than Monoids, what's the most important algebraic...
12:31:55 <mizu_no_oto> ...structure for Haskellers to grok?
12:32:04 <monochrom> t7: I can write in asm. just small programs of course. now, how? I already have a high-level version in my mind, then I just hand-compile to asm, that's how
12:32:18 <ksf__> "I read fefe, but only the code sections" :)
12:32:19 <monochrom> sure, it's tedious, so I only do it for small programs
12:32:31 <mekeor> ksf__: lol :D
12:32:47 <t7> can i define data in the code section?
12:32:52 <koeien> mizu_no_oto: groups are more important in mathematics for various reasons. not mentioning monoids is strange though
12:33:20 <Mathnerd314> mizu_no_oto: which textbook?
12:33:38 <Mathnerd314> *are you using
12:33:50 <monochrom> most abstract algebra courses do not mention monoids
12:34:28 <monochrom> "strange" is about right for how programmers (even haskell programmers) view mathematicians. no news.
12:34:45 <monochrom> (the sentiment is mutual)
12:34:58 <rwbarton> basically the goal of the undergrad algebra sequence is to get to galois theory
12:35:04 <rwbarton> you don't need monoids for that
12:35:11 <int-e> monochrom: but we could all be stranger together! :)
12:35:38 <monochrom> well yeah, everyone else views both groups as strange together
12:35:43 <merijn> monochrom: "strange" is about right for how anyone (even other mathematicians) view mathematicians. no news. :p
12:35:54 <monochrom> ha!
12:36:05 <t7> yey it works
12:36:30 * hackagebot sox 0.2.1.1 - Play, write, read, convert audio signals using Sox  http://hackage.haskell.org/package/sox-0.2.1.1 (HenningThielemann)
12:36:31 <t7> im hardcore bare metal hacker
12:36:32 * hackagebot spreadsheet 0.1.2.1 - Read and write spreadsheets from and to CSV files in a lazy way  http://hackage.haskell.org/package/spreadsheet-0.1.2.1 (HenningThielemann)
12:36:34 * hackagebot storable-record 0.0.2.5 - Elegant definition of Storable instances for records  http://hackage.haskell.org/package/storable-record-0.0.2.5 (HenningThielemann)
12:36:36 * hackagebot storablevector 0.2.7.3 - Fast, packed, strict storable arrays with a list interface like ByteString  http://hackage.haskell.org/package/storablevector-0.2.7.3 (HenningThielemann)
12:36:37 <mizu_no_oto> mathnerd: Contemporary Abstract Algebra, by Gallian.  At the very least, monoids don't appear in the index.  And yeah, the book goes Groups -> Rings -> Fields, so it seems that galois theory is a goal
12:37:11 <monochrom> anyway you will not find much relevance to haskell from your abstract algebra course, save for comparing Num with rings
12:38:50 <monochrom> the common haskell beginner's impulse to "haskell has inspired me to take more math courses, even a math degree" is understandable but utterly unwise. disappointment is certain.
12:39:43 <t7> >ord '0'
12:39:45 <t7> > ord '0'
12:39:46 <lambdabot>   48
12:39:50 <mizu_no_oto> Are Symmetric groups useful at all from a FP perspective?
12:40:21 <shachaf> It is a sobering thought that by the time Galois was my age, he had been dead for a month and a half.
12:41:22 <lysgaard> To understand the theoretical foundation of Haskell what math/theory do you need to learn?
12:41:26 <t7> can i get a ptr to aregister?
12:41:35 <mauke> t7: no
12:41:39 <mauke> registers aren't memory
12:41:51 <monochrom> an example disappointment is that the real analysis course is not going to use Coq or Agda or any of those curry-howard koolaids for proofs
12:42:01 <Eduard_Munteanu> lysgaard: maybe some type theory
12:42:05 <int-e> mauke: well :)
12:42:07 <rwbarton> in fact you are not even going to be able to prove your real analysis theorems in coq/agda
12:42:11 <mizu_no_oto> lysgaard:  learning some lambda calculus and type theory is good.
12:42:32 <edwardk> monochrom++
12:42:53 <lysgaard> Are there some good books on type theory and lambda calculus?
12:43:01 <edwardk> monochrom: yeah if you go too far down that path you turn into roconnor
12:43:02 <monochrom> yeah, classical logic is pervasive there, your intuitionistic feeling will be hurt. guaranteed.
12:43:23 <mizu_no_oto> Types and Programming Languages, Ben Peirce
12:43:37 <mizu_no_oto> Is a classic text
12:43:51 <edwardk> http://arxiv.org/abs/0805.2438
12:43:59 <int-e> mauke: (I've recently seen an architecture where most registers were addressable through the IO address space. (some AVR microcontroller))
12:44:35 <t7> how do i know which memory i can write/read to?
12:44:45 <mauke> int-e: C still doesn't let you take the address of a variable with 'register' storage :-)
12:44:59 <int-e> mauke: which makes sense in an odd way: you don't need dedicated load instructions for rarely modified registers. :)
12:45:23 <int-e> mauke: yeah, I'm just relating a story here, not seriously contesting your point.
12:46:30 * hackagebot supercollider-ht 0.1.1.1 - Haskell SuperCollider utilities  http://hackage.haskell.org/package/supercollider-ht-0.1.1.1 (HenningThielemann)
12:48:11 <lysgaard> mizu_no_oto: Thanks
12:50:42 <ique> I'm trying to add an instance of NFData for MongoDB's Document (http://hackage.haskell.org/packages/archive/bson/0.1.7/doc/html/Data-Bson.html#t:Document) but I'm not really sure how to do it
12:50:57 <ique> Can anyone give some tips?
12:52:39 <ique> essentially I want to force the full evaluation of the Document because I'm doing it in a thread so I want it to actually be done in that thread
12:53:34 <gzmask> what's the difference between $ and . ?
12:54:15 <c_wraith> gzmask: their types
12:54:30 <shachaf> And their values.
12:54:35 <c_wraith> gzmask: Their types tell you everything those functions do
12:54:39 <shachaf> And also their names. Other than that, nothing.
12:54:40 <c_wraith> :t ($)
12:54:41 <lambdabot> forall a b. (a -> b) -> a -> b
12:55:14 <mizu_no_oto> :t (.)
12:55:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
12:55:20 <c_wraith> There's only one thing ($) can do with that type, that isn't completely broken...  Apply the function passed as its first argument to the value passed as its second argument
12:55:34 <gzmask> oh I see... function combination vs function application
12:55:43 <c_wraith> yep
12:55:48 <dmwit> ($) = unsafeCoerce
12:55:57 <c_wraith> dmwit: that's always possible
12:55:59 <dmwit> 100% safe and correct
12:56:05 <c_wraith> except for the safe part
12:56:13 <dmwit> No, it really is 100% safe and correct.
12:56:43 <c_wraith> huh.
12:56:46 <c_wraith> I guess $ is id
12:56:52 <dmwit> yes
12:56:52 <c_wraith> so it's fine, I suppose
12:57:20 <shachaf> @quote unsafeCoerce.*id
12:57:20 <lambdabot> benmachine says: unsafeCoerce is just a generalisation of id
12:57:33 <mizu_no_oto> $ is id with low precedence
12:59:04 * roconnor uses classical logic for his constructive analysis all the time.
12:59:25 <roconnor> I even write in my thesis how I use the pigeon hole principle to construct compact sets.
13:01:46 * hackagebot supercollider-midi 0.2.1 - Demonstrate how to control SuperCollider via ALSA-MIDI  http://hackage.haskell.org/package/supercollider-midi-0.2.1 (HenningThielemann)
13:01:48 * hackagebot splice 0.1 - Socket to Socket Data Splicing  http://hackage.haskell.org/package/splice-0.1 (CetinSert)
13:06:28 <t7> roconnor i hear purecoin is a functional node
13:06:34 <t7> is ther code anywhere?
13:08:09 <roconnor> t7: it isn't functional
13:08:23 <roconnor> t7: I can tell you where to get the code if you like.  Do you have darcs installed?
13:08:32 <t7> yup
13:08:39 <t7> why you not put it on github or something?
13:08:45 <roconnor> t7: actually depending on your definition of functional, it might be functional
13:08:56 <roconnor> t7: darcs get http://r6.ca/Purecoin/
13:09:16 <roconnor> t7: I'm pretty excited about your mental poker implementation
13:09:50 <roconnor> t7: oh, you can also rip out and take the elliptic curve code from Purecoin if you want yet another way to do commutative encryption.
13:09:59 <t7> im writing the poker betting rules at the moment
13:10:05 <t7> as a seperate library
13:10:11 <t7> its quite complicated
13:10:16 <roconnor> I bet
13:10:40 <t7> hoho
13:11:37 <roconnor> :S
13:11:46 * hackagebot xchat-plugin 0.0.2 - XChat  http://hackage.haskell.org/package/xchat-plugin-0.0.2 (CedricAuger)
13:12:15 <t7> this is cool you should chuck on github, get some interest drummed up
13:12:58 <roconnor> t7: I've got a small rant against git on my blog :)
13:13:01 <P3nisSujo> I keep getting this error message in my program
13:13:09 <P3nisSujo> and it doesn't let me copy it
13:13:11 <P3nisSujo> http://i.imgur.com/AJWVC.jpg
13:13:18 <P3nisSujo> I checked it over and over agin the code
13:13:55 <P3nisSujo> anyhow there is the screencap
13:14:09 --- mode: ChanServ set +o mauke
13:14:09 --- mode: mauke set +b *!*@gateway/web/freenode/ip.200.79.144.108
13:14:18 --- kick: P3nisSujo was kicked by mauke (P3nisSujo)
13:16:18 --- mode: mauke set -o mauke
13:24:37 <mm_freak> does anyone know a library to handle object format files (.o)?
13:26:34 <uniquenick> I think I am getting confused about types vs constructors: I have a data Event = Event and when I try to use Event in a type signature I get "Event is applied to too many type arguments"
13:26:46 * hackagebot data-lens 2.10.0 - Haskell 98 Lenses  http://hackage.haskell.org/package/data-lens-2.10.0 (RussellOConnor)
13:26:56 <sipa> uniquenick: paste your code somewhere
13:26:58 <sipa> (hpaste.org)
13:27:04 <mm_freak> uniquenick: using it like Event X?
13:27:45 <uniquenick> using it like "foo :: Event Int Int"
13:27:54 <koeien> yes that's not possible
13:28:01 <koeien> Event is a type, it has kind *
13:28:08 <sipa> uniquenick: in that case it would have to be data Event a b = ...
13:28:14 <koeien> do you want something like data Event a b = ... ?
13:29:06 <mm_freak> uniquenick: check the definition of Maybe
13:29:14 <mm_freak> data Maybe a = Just a | Nothing
13:29:23 <mm_freak> then (Just (x :: Int) :: Maybe Int)
13:31:04 <uniquenick> yeah, my mistake was far dumber than that.  I just forgot that "Event Int Int" and "Event -> Int -> Int" aren't the same thing
13:38:21 <luite> what can be the problem when after installing the haskell platform on OS X, running ghc results in: ghc: could not execute: /Developer/usr/bin/gcc
13:38:39 <luite> (my gcc is /usr/bin/gcc )
13:38:47 <glguy> luite: What version of GHC?
13:38:55 <luite> 7.0.3, latest platform
13:39:01 <luite> xcode 4.3
13:39:39 <glguy> The lastest XCode got rid of /Developer and now is in /Applications
13:40:34 <lulf> luite: just editing /usr/bin/ghc and fix the path worked for me
13:40:35 <luite> yeah, I know that some things have changed, but is the only solution to manually edit the wrapper scripts, or should i have done something before (or during?) installation of the haskell platform?
13:41:04 <lulf> i think its solved in ghc 7.4 ?
13:41:31 <luite> ok, good news, I'm just installing this to bootstrap ghc 7.4 anyway :)
13:42:07 <glguy> yeah, I'm using 7.4.1 with current xcode without any fus
13:45:39 <gzmask> >:m Control.Applicative
13:45:57 <gzmask> :m Control.Applicative
13:46:00 --- mode: ChanServ set +o glguy
13:46:02 --- mode: glguy set -b *!*@unaffiliated/spice
13:46:04 --- mode: glguy set -o glguy
13:46:48 <gzmask> >check
13:47:34 <gzmask> :t []
13:47:34 <lambdabot> forall a. [a]
13:49:17 <kallisti> http://hackage.haskell.org/packages/archive/webdriver/0/logs/failure/ghc-7.4
13:49:21 <kallisti> any idea why this happened?
13:49:21 <gzmask> @run [ x++y | x <- ["yes", "no"] , y <- ["?", "??", "!", "!!"]]
13:49:23 <lambdabot>   ["yes?","yes??","yes!","yes!!","no?","no??","no!","no!!"]
13:50:54 <rwbarton> kallisti: if you ^F c_opendir there are some errors
13:51:04 <rwbarton> when it tries to build directory
13:51:25 <kallisti> hm
13:51:35 <kallisti> so there's not really anything I can do about it.
13:51:37 <rwbarton> probably it shouldn't be trying to build directory, that may be the real problem?
13:51:47 * hackagebot GPipe 1.3.1 - A functional graphics API for programmable GPUs  http://hackage.haskell.org/package/GPipe-1.3.1 (TobiasBexelius)
13:52:15 <kallisti> well, I do depend on it.
13:53:33 <rwbarton> isn't it part of ghc though
13:53:46 * kallisti has no clue.
13:53:50 <rwbarton> i have ghc-7.0.4, it comes with directory-1.1, so the version it chose is super old
13:54:04 <kallisti> rwbarton: what makes it choose that one?
13:54:10 <rwbarton> good question
13:54:17 <rwbarton> i would guess, one of your other dependencies
13:54:28 <kallisti> I have directory == 1.*
13:55:00 <rwbarton> yes but monad-control (to pick an implausible candidate at random) may depend on directory == 1.0.*
13:56:49 * hackagebot GPipe-Collada 0.1.2 - Load GPipe meshes from Collada files  http://hackage.haskell.org/package/GPipe-Collada-0.1.2 (TobiasBexelius)
13:56:51 * hackagebot GPipe-TextureLoad 1.0.3 - Load GPipe textures from filesystem  http://hackage.haskell.org/package/GPipe-TextureLoad-1.0.3 (TobiasBexelius)
13:57:28 <kallisti> the only thing I see on the first depth is directory >= 1.0 & < 1.2  from temporary
13:58:20 <rwbarton> what version of ghc do you have locally?
13:58:37 <kallisti> 7.0
13:59:34 <kallisti> builds fine on my system.
13:59:59 <azm> can I find the current directory the  ghci is please ?
14:00:22 <azm> Im trying to :l a function but it still opens some other stuff
14:00:24 <kallisti> azm: in what context?
14:00:31 <kallisti> oh
14:00:43 <kallisti> it would just be whatever directory you started it in
14:01:21 <azm> which is weird because I rewrote the function saved reloaded but it still while :edit opens the old text
14:01:43 <zzo38> Do you like this kind of prelude?    http://sprunge.us/MCRA
14:01:47 * hackagebot persistent-protobuf 0.1.4 - Template-Haskell helpers for integrating protobufs with persistent.  http://hackage.haskell.org/package/persistent-protobuf-0.1.4 (MichaelStone)
14:02:22 <eacameron> If I compile this code, it doesn't actually ask me for user input. I'm guessing it has something to do with laziness and me being ignorant: https://gist.github.com/2354444
14:02:43 <koeien> eacameron: buffering
14:02:45 <c_wraith> eacameron: actually, it's because terminal IO defaults to line-buffered mode
14:02:54 <c_wraith> eacameron: and you're not ending a line before asking for input
14:03:08 <hepek> hey guys, did you ever have to use 'printf debugging'? I was experimenting with Data.Binary.Get
14:03:09 <eacameron> c_wraith: how do I change that?
14:03:12 <kallisti> rwbarton: I think it complained when I removed the directory dependency
14:03:22 <koeien> hepek: Debug.Trace
14:03:24 <c_wraith> eacameron: something like hSetBuffering
14:03:25 <kallisti> or rather, it complained that it wasn't there
14:03:32 <c_wraith> @hoogle hSetBuffering
14:03:32 <lambdabot> System.IO hSetBuffering :: Handle -> BufferMode -> IO ()
14:03:32 <lambdabot> GHC.IO.Handle hSetBuffering :: Handle -> BufferMode -> IO ()
14:03:54 <c_wraith> eacameron: look at the related stuff in System.IO
14:03:57 <hepek> Debug.Trace is too verbose, i punched a hole using unsafePerformIO
14:04:05 <c_wraith> too verbose?
14:04:56 <c_wraith> « trace "foo" bar » is too verbose when you want to output "foo" when bar is evaluated?
14:04:56 <rwbarton> > (compare `on` length) "unsafePerformIO" "trace"
14:04:57 <lambdabot>   GT
14:05:24 <rwbarton> anyways trace just uses unsafePerformIO
14:05:31 <hepek> it makes the code look different, if you know what I mean
14:05:57 <hepek> i made an infix function .--
14:06:13 <hepek> that could be easily converted to plain comment, when done tracing
14:06:34 <c_wraith> hepek: and why didn't you define it to be equal to trace?
14:06:46 <hepek> yeah, that's what I'm thinking right now :D
14:06:59 <c_wraith> hepek: well, flip trace :)
14:08:09 <gzmask> is haskore and supercollider easy to install on osx 10.6?
14:08:11 <hepek> a lot less complicated than (unsafePerformIO$ print trace) `seq` left
14:10:13 <azm> I dint get it
14:10:22 <azm> hos is the win ghci is supposes to work?
14:10:33 <azm> Main.hs:1:1: Not in scope: data constructor `MyFunc'
14:11:23 <azm> If I open winghci in eg. Program Files-Haskell Platform-ghci
14:11:26 <eacameron> Also, I have this function: isWhitespace x = x `elem` " \t"
14:11:35 <eacameron> is there a way to use partials instead of repeating x?
14:11:43 <azm> then open and save the My Func.hs file in the same directory
14:11:56 <azm> and :load it, it should work I guess?
14:12:14 * dmwit rages at the GHC user guide's title attributes
14:12:34 <t7> i wish i had your problems
14:12:40 <dmwit> azm: Yes, that sounds about right.
14:12:58 <azm> then im doing utterly worng
14:13:03 <azm> x0
14:13:05 <dmwit> eacameron: Yes, isWhitespace = (`elem` " \t")
14:13:16 <dmwit> eacameron: or isWhitespace = flip elem " \t"
14:13:25 <dmwit> eacameron: But there's also Data.Char.isWhitespace, I think.
14:13:29 <dmwit> :t isWhite
14:13:29 <lambdabot> Not in scope: `isWhite'
14:13:32 <dmwit> :t isWhitespace
14:13:33 <lambdabot> Not in scope: `isWhitespace'
14:13:43 <dmwit> ah
14:13:47 <dmwit> :t Data.Char.isSpace
14:13:48 <lambdabot> Char -> Bool
14:13:50 <dmwit> phew
14:14:10 --- mode: ChanServ set +o mauke
14:14:10 --- mode: mauke set -b *!*@gateway/web/freenode/ip.200.79.144.108
14:14:13 <dmwit> ?hpaste the file you're trying to load, azm
14:14:13 <lambdabot> Haskell pastebin: http://hpaste.org/
14:14:44 <azm> dmwit, its one line: myfunc x = x + x
14:14:49 <azm> :)
14:14:58 <dmwit> azm: And then what do you type in (win)ghci?
14:15:00 <eacameron> dmwit: cool! thanks
14:15:09 <azm> so I save this line to  Main.hs
14:15:17 <azm> then I type :l Main
14:15:28 <azm> like :load Main
14:15:31 <dmwit> yes
14:15:37 <azm> Main.hs:1:1: Not in scope: data constructor `MyFunc'
14:16:06 <dmwit> azm: Are you definitely loading the file you think you're loading? Also, is the one line literally "myfunc x = x + x", or are you lying about capitalization?
14:16:06 <azm> it seems like the hp does not update or something
14:16:10 --- mode: mauke set -o mauke
14:16:43 <azm> dmwit, its MyFunc x = x + x
14:16:47 <azm> copypasted
14:16:57 <dmwit> azm: That is not correct. Functions must begin with a lower-case letter.
14:17:03 <dmwit> s/correct/correct Haskell/
14:17:24 <azm> oh
14:17:31 <azm> Did not know that
14:17:38 <azm> Thanks
14:17:46 <dmwit> (Not quite true. Functions can also be infix, in which case they aren't allowed to start with letters at all. But you get the point.)
14:17:52 <kallisti> can someone with GHC 7.4 and git help me out real quick?
14:17:59 <dmwit> kallisti: shoot
14:19:19 <zzo38> Can you look at my typesetting library so that you could use and to complain about it so that I can correct it and improve it if you have a suggestion?
14:20:17 <kallisti> dmwit: git clone git://github.com/kallisti-dev/hs-webdriver.git; cd hs-webdriver; cabal install
14:21:48 <kallisti> dmwit: tell me if that complains
14:22:41 <dmwit> cabal install --only-dependencies has neither complained nor finished; will let you know when either happens.
14:25:05 <vhd> How do you declare type synonyms in ghci?
14:25:16 <dmwit> vhd: step 1 is upgrade to the very newest GHC
14:25:36 <dmwit> (It's only available in ghci-7.4 and later.)
14:26:14 --- mode: ChanServ set +o glguy
14:26:18 <dmwit> kallisti: Dependencies installed; webdriver configured; cabal build complains about Test.WebDriver.Firefox.Profile:101:10
14:26:38 <dmwit> You want the whole error?
14:26:45 --- mode: glguy set +b *!*@*.dsl.dyn.telnor.net$#haskell-ops
14:26:56 <kallisti> sure.
14:27:05 <vhd> hm guess mine cant do it then, have 7.0.3
14:27:10 <luite> does anyone know how to fix the divide by zero error when building ghc, it happens when building docs
14:27:13 <kallisti> I should really just get GHC 7.4
14:27:17 <hpaste> dmwit pasted “hs-webdriver” at http://hpaste.org/66777
14:27:18 <kallisti> but I prefer to have what is in repo
14:27:42 <dmwit> vhd: Just stick it in a file and :l that file.
14:27:43 <kallisti> that error makes no sense to me.
14:28:01 <dmwit> String is not a type variable.
14:28:01 <kallisti> oh I see.
14:28:10 <kallisti> hm weird, 7.0 doesn't complain at all
14:28:13 <kallisti> that must be a bug in 7.0 then
14:28:29 <dmwit> I think more extensions implied FlexibleInstances in 7.0 than in 7.4.
14:29:08 --- mode: glguy set +b-o $r:*.dsl.dyn.telnor.net/*$#haskell-ops glguy
14:29:58 * dmwit struggles to read that modeline
14:30:08 <dmwit> Did glguy just ban himself from #haskell-ops?
14:30:25 * glguy sure hopes not ;-)
14:30:26 <mauke> obfuscated irc contest
14:30:36 <copumpkin> he deopped himself
14:30:40 <copumpkin> in the same line as adding a ban
14:30:58 <azm> if I edit and reload the file and then edit again it still shows the old file
14:30:59 <alpounet> it's like point-free for IRC commands
14:31:17 <rwbarton> zipWith ["+b", "-o"] ["$r:*.dsl.dyn.telnor.net/*$#haskell-ops", "glguy"]
14:31:24 <rwbarton> ... zipWith something
14:31:37 <rwbarton> I guess.
14:31:43 <copumpkin> zipWithM
14:31:52 <copumpkin> zipWithM_
14:31:53 <copumpkin> :P
14:32:05 <kallisti> dmwit: would you mind repeating that procedure? Also, approximately how annoying is it to upgrade GHC by hand?
14:32:14 <dmwit> zipWithM_ confuseDmwitT
14:32:29 <azm> seriosly
14:32:37 <azm> how do I please resolve it
14:32:46 <azm> such mundane stuff I know
14:32:49 <rwbarton> save the file?
14:32:55 <azm> I did
14:33:00 <azm> I even restarted HP
14:33:06 <azm> then :loaded
14:33:09 <azm> and :edited
14:33:16 <azm> and there are old lines
14:33:35 <azm> while when I open it in notepad++ there are new
14:34:08 <dmwit> Do ghci and notepad++ have the same working directory?
14:34:13 <dmwit> kallisti: zsh: exit 0
14:34:17 <dmwit> kallisti: plenty of warnings, though
14:34:54 <dmwit> kallisti: Upgrading GHC is easy as pie. Download the binary, ./configure && make && make install && cabal install world
14:35:40 <kallisti> dmwit: if they're the same warnings as before they should be fine.
14:35:54 * kallisti is stubborn and does not suppress warnings just because they exist.
14:36:25 <azm> well the launcher winghci and the Main.hs is in the same folder
14:36:46 <azm> I wanted to edit and reload the code while reading book
14:36:59 <dmwit> Yes, it should work fine.
14:37:09 <dmwit> It's not 100% clear what it is that's going wrong.
14:37:22 <dmwit> Can you describe in excruciating detail the sequence of actions you perform?
14:38:01 <azm> ok so I have total commader open in dir where ghci and Main.hs is
14:38:18 <azm> when I click on Main.hs and edit in notepad++ I see code
14:38:27 <cadabra> Is there code anywhere to escape a string for inclusion in a regular expression as a literal?
14:38:29 <azm> doubleSmallNumber
14:38:29 <azm> x = if x > 100
14:38:29 <azm> then x
14:38:29 <azm> else x*2
14:38:40 <azm> now I close the file
14:38:44 <cadabra> I guess I would expect each Text.Regex backend to have an implementation.
14:38:45 <azm> go to winghci
14:38:56 <azm> put :load Main.hs
14:39:11 <azm> or just :load Main
14:39:16 <azm> the :edit
14:39:27 <kallisti> dmwit: I appreciate the help. I guess I'll go ahead and get 7.4
14:39:30 <azm> And I see
14:39:30 <azm> doubleMe x = x + x
14:39:31 <cadabra> Apparently .NET has System.Text.RegularExpressions.Escape
14:39:44 <azm> opened in normal notepad
14:40:16 <dmwit> Crazy. And your file manager (total commander?) isn't hiding extensions from you or something like that?
14:40:31 <azm> I dont think so
14:40:47 <rwbarton> can you get normal notepad to show you where the file it has open lives
14:40:50 <azm> I will try to edit stuff in the normal textpad
14:40:55 <azm> I tried
14:40:58 <azm> cant see it
14:41:10 <rwbarton> i suggest you just use notepad++ and use :r rather than :edit
14:41:13 <azm> well when I go save as
14:41:16 <rwbarton> ah
14:41:20 <azm> its directory is Desktop
14:41:48 * hackagebot webdriver 0.0.1 - a Haskell client for the Selenium WebDriver protocol  http://hackage.haskell.org/package/webdriver-0.0.1 (AdamCurtis)
14:41:49 <rwbarton> well what does ghci actually load
14:41:53 <azm> where I have Main
14:41:56 <dmwit> (By the way, you can use ":set editor" to change from Notepad to Notepad++.)
14:41:56 <azm> too
14:42:00 <azm> I deleted it now
14:42:05 <azm> and try again
14:42:16 <azm> oh thanks for tip dmarkey
14:42:25 <azm> dmwit,
14:42:59 <dmwit> There's a config file somewhere that gets executed every time ghci starts, too, to make the change permanent. Dunno where that lives on Windows, though.
14:43:23 <azm> how do I leave from *Main to prelude ?
14:43:31 <dmwit> :m
14:44:09 <azm> well Im going back to linux soon
14:45:08 <kallisti> PVP mentions that A.B is a major version
14:45:16 <kallisti> but it never mentions when you should change A
14:45:26 <kallisti> is that pretty much arbitrary then?
14:45:31 <azm> meh
14:45:33 <dmwit> yes, by author's aesthetics
14:45:48 <azm> its still keep opening text file which does not exist
14:45:53 <vhd> how can I use Data.Sequence in a type synonym? type testa = Seq (Seq Int) <-- is illegal
14:46:05 <dmwit> type Testa = Seq (Seq Int)
14:46:27 <vhd> -_-!
14:46:35 <vhd> no wait
14:46:49 * hackagebot ad 1.5 - Automatic Differentiation  http://hackage.haskell.org/package/ad-1.5 (EdwardKmett)
14:46:55 <vhd> I have, type SeqBoard = Seq (Seq Int) <-- still illegal
14:47:12 <kallisti> dmwit: I guess I would change A for very large API incompatabilities, and B for lesser ones (API changes that only affect particular modules or not commonly used features)
14:47:18 <edwardk> kallisti: i usually use the A part of the version just to denote 'here is a ridiculous change worth taking note of' or 'its ready for prime time'  or 'I've updated the B part enough that its getting silly' ;)
14:47:19 <dmwit> vhd: Why not paste the file and exact error message to hpaste.org?
14:47:30 <kallisti> edwardk: heh
14:47:40 <kallisti> 0.22.0.1
14:47:44 <edwardk> kallisti: for instance trifecta is overdue for an A bump
14:48:02 <dmwit> edwardk: An A bump? Does that mean... dun dun dun... it's being DOCUMENTED?
14:48:09 <azm> does the ghci have some buffer ?
14:48:10 <edwardk> dmwit: heh
14:48:19 <azm> I deleted all .hs files
14:48:25 <azm> and it still loads it
14:48:25 <edwardk> dmwit: i take patches ;)
14:48:33 <kallisti> so is Hackage never going to build docs for version 0, since it's never going to build on GHC 7.4?
14:48:38 <dmwit> hah
14:48:47 <dmwit> I would write documentation if I could make heads or tails of it.
14:48:51 <edwardk> azm: were there object files or .hi files or something left?
14:49:00 <edwardk> dmwit: so would i
14:49:07 <kallisti> dmwit: just refer to documentation to write documentation, what's the problem?
14:49:09 <clsmith> lol
14:49:25 <azm> edwardk, well no, I deleted everything
14:49:36 <azm> what was created by the compilation process
14:49:58 <azm> I remember exactly same thing happend like 2 years ago
14:50:07 <azm> when I wanted to learn haskell
14:50:08 <edwardk> actually the next release may change the package name
14:50:11 <dmwit> Hm, I've started the ghci debugger and reached a breakpoint, but none of the variables bound in my "where" clause are in scope. What gives?
14:50:12 <azm> and I left
14:50:17 <azm> because of it x)
14:50:34 <edwardk> since i've been working on it in an entirely different project
14:50:35 <hpaste> vhd pasted “Using Sequence in type.” at http://hpaste.org/66778
14:50:44 <vhd> dmwit ^
14:51:01 <dmwit> vhd: Oh, well, you have two choices.
14:51:11 <azm> will try the nonwin ghci
14:51:15 <dmwit> vhd: Either add another import, "import Data.Sequence (Seq)", or use the qualified name you asked for.
14:51:25 <dmwit> vhd: type SeqBoard = Sequence.Seq (Sequence.Seq Int)
14:51:36 <vhd> ah I see
14:51:46 <acowley> dmwit: you may have to take one or two steps into the function
14:51:53 <dmwit> vhd: Or you could just drop the "qualified" keyword.
14:52:11 <vhd> hmm I need it due to ambiguity
14:52:30 <dmwit> vhd: "as" and "qualified" are independent, did you know that?
14:52:44 <vhd> nope
14:52:44 <dmwit> Just checking. "qualified" may still be more convenient for you.
14:53:14 <vhd> I thought qualified ads usage of the import by name, and as allows to give an alternate name
14:54:00 <dmwit> vhd: You might like the section on imports in this answer:
14:54:04 <dmwit> http://stackoverflow.com/questions/8327032/write-this-scala-matrix-multiplication-in-haskell/8331995#8331995
14:56:09 <azm> oh great
14:56:20 <azm> the cmd version ghci.exe works
14:56:29 <azm> at least this
14:56:36 <azm> and the winghci has bug
14:56:50 <dmwit> azm: My guess is that winghci has a different working directory than you think it has.
14:57:08 <dmwit> azm: Try explicitly using :cd C:\The\Directory\You\Want\To\Be\In and doing :edit again.
14:57:33 <azm> ok
14:57:48 <acowley> Does :! pwd work from ghci in Windows?
14:58:14 <azm> but I need sleep a lot. Thanks a lot for kindness. See you tomorrow.
14:58:32 <dmwit> acowley: Thanks for the :step hint.
14:58:36 <acowley> dramatic exit
14:58:48 <acowley> dmwit: np!
14:58:53 <dmwit> acowley: It's a bit odd. I'm not sure I understand exactly when (and why) these things are coming into scope.
14:59:55 <dmwit> After zero steps, nothing is in scope; one step, the "path" argument is in scope; two steps, the "lifetime" argument is in scope (but "path" isn't any more??)...
14:59:58 <acowley> I would guess that they come into scope after the function's arguments since the closure depends on the args.
15:02:38 <acowley> Actually… of course it can't be that simple since GHC can do clever things with lambda lifting as I recall. Enforcing a lexical notion of evaluation on GHC via the debugger seems to surface an impedance mismatch.
15:03:47 <ciaranm> for c there's all kinds of voodoo in the debug info which lets the debugger pretend optimisations haven't happened. it's rather horrible.
15:04:02 <dmwit> But, this code is interpreted.
15:04:06 <dmwit> Optimization isn't an issue.
15:04:58 <ciaranm> i don't think that follows, unless your interpreter is silly and doesn't do what a compiler does
15:05:45 <dmwit> This doesn't seem to be an optimization thing, anyway, just a very counterintuitive way of displaying the evaluation of guards.
15:05:58 <dmwit> I think I understand it now (though I don't like it).
15:06:15 <dmwit> It's only showing as "in-scope" those variables needed to decide whether the guard is true.
15:06:18 <scooty-puff> given data A a where A :: Int -> A a; B :: Int -> A True
15:06:26 <scooty-puff> is it possible to write a function A a -> A True
15:06:32 <dmwit> Presumably after a few more steps here it will get past the guards onto a RHS and then suddenly all the arguments will spring into scope.
15:06:36 <scooty-puff> that doesn't unbox, rebox A?
15:06:37 <dmwit> At least, that's what I'm hoping.
15:07:00 <dmwit> scooty-puff: unsafeCoerce
15:07:45 <scooty-puff> k - i'm fine even typing out the unbox/box, if the generated code maybe removed it (i know its probably not a performance issue, just wondering)
15:07:53 <phil___> stupid beginner question: can I easily run Haskell programs on a hosted web server - can anyone point me to a page on how to publish a haskell program? thanks
15:07:54 <scooty-puff> to avoid unsafeCoerce anyways
15:08:31 <scooty-puff> (i added ! to the data constructors - didn't help)
15:08:34 <lispy> phil___: what do you mean by hosted? Do you mean something like a linode?
15:08:43 <scooty-puff> (in case it had to do it because of strictness)
15:08:59 <phil___> no, like a run-of-the-mill hosted web server, w/ PHP
15:09:05 <lispy> phil___: Moving a binary to a machine without ghc can sometimes be problematic, but once you get all the right shared libs on there, it should just work
15:09:12 <dmwit> scooty-puff: I don't think there is a well-typed term that avoids reboxing.
15:09:20 <scooty-puff> k
15:09:26 <phil___> ah, so I do need to install stuff first
15:09:39 <phil___> sounds like I need root access
15:09:47 <lispy> phil___: if you run ldd on a program you will see what it depends on
15:10:07 <lispy> phil___: so build a hello world program and run ldd on it. You should see a libgmp dependency
15:10:24 <acowley> phil__: a good approach to dealing with shared hosts is to setup a VM on your dev machine that matches the shared host OS
15:10:52 <lispy> phil___: You could experiment with installing dependencies in your homedir and playing with LD_LIBRARY_PATH
15:10:55 <dmwit> acowley++ this is what I did and it works great
15:11:10 <dmwit> Also, VMs: *pretty* awesome.
15:11:18 <dmwit> Snapshotting is just the coolest thing ever.
15:11:28 <phil___> so, if I understand correctly, haskell code gets *compiled*, and I don't need anything like a "PHP interpreter" or the like
15:11:38 <dmwit> phil___: correct
15:11:55 <phil___> ok, I'll try the VM - thanks for your help
15:14:11 <conal> is there a ghci flag that prevents ghci from listing all of the loaded modules after a :l or :r ?
15:14:11 <lambdabot> conal: You have 1 new message. '/msg lambdabot @messages' to read it.
15:14:14 <dmwit> acowley: Do you know of a way to ask the debugger what symbols it's defined for me?
15:14:29 <lispy> I agree about VMs. I use a macbook for my laptop and then I do 90% of my development on linux either locally in a VM or on a VM server.  The remaining 10% of the dev I do is locally either on OSX or windows. Often just for portability.
15:14:34 <acowley> dmwit: not off the top of my head.
15:14:36 <lispy> virtualbox is my firend.
15:14:40 <lispy> friend, even
15:14:47 <merijn> conal: I think so, but I never remember. You can use ":set PROMPT='> '" to change the prompt to a static one
15:15:29 <merijn> Wait, I screwed that up...
15:15:34 <dmwit> merijn: I think he means the "Loading package array-0.4.0.0 ... linking ... done.", not the "Data.Array Main*> ".
15:15:40 <merijn> Ah
15:15:48 <acowley> My issue with VMs is that I run into drive size pains, spotty USB device support, and partially broken OpenGL.
15:15:58 <dmwit> just at a guess, though, maybe we should ask conal for clarity =P
15:16:18 <acowley> conal: chris done's newer haskell-mode stuff trims that out
15:16:21 <merijn> dmwit: Going for a hat trick, wrong solution and wrong problem :p
15:16:28 <lispy> acowley: yeah, running out of space for all those virtual hds can be an issue. I haven't run into the other two problems
15:16:44 <merijn> (Turns out the correct syntax is ":set prompt "> ""...)
15:16:49 * hackagebot majordomo 0.1.5 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1.5 (MarkWotton)
15:16:53 <conal> acowley: oh, nice. looking forward to playing with that mode.
15:17:23 <conal> i'm talking about the line "Okay, modules loaded: Foo.hs, Bar.hs, ..."
15:17:27 <dmwit> Software OpenGL is way slow. USB devices I've found to be quite good once I managed to work my way through VirtualBox's user guide's chapter on setting up USB passthrough.
15:17:31 <acowley> I plug lots of mysterious looking things into my computers. VMs get confused, and device makers (justifiably) don't want to support such a configuration.
15:18:06 <dmwit> Ah, yes, the sentence of the support email where you go "and this is where they'll stop reading"...
15:19:51 <acowley> conal: This screencast shows the behavior I mentioned about 4:30 in
15:19:55 <acowley> conal: http://www.youtube.com/watch?v=E6xIjl06Lr4
15:20:55 <conal> acowley: cool!
15:21:59 <lispy> startup idea: unified service for software companies to push out their software updates. Think linux style package manager but for the not so FOSS world. Windows/OSX would be the main platforms to target.
15:22:45 <lispy> It would be great if this service could fix the issue where I only find out that the software I'm using is out of date if I visit a plugin checker webpage or start up adobe to be told that I now need to download updates and restart adobe.
15:22:48 <acowley> lispy: The Mac App Store covers much of that need on OS X.
15:23:31 <acowley> some code I've been fighting for over a day just type checked and now I don't know what to do with myself
15:23:45 <davorb> yeah but there's nothing on windows
15:23:46 <dmwit> acowley: Nice! Now you don't even have to run it.
15:23:47 <lispy> acowley: ship it, that's what you do with yourself ;)
15:23:55 <dmwit> I mean, it type-checked, you know it does what you told it to do. =)
15:23:59 <acowley> Yes!
15:24:06 <singpolyma> is there a library for a datastructure that I can slice like a list/array/vector (using, say, take/drop) but can also efficiently have an element removed, and ideally can be efficiently indexed into?
15:24:28 <davorb> by efficiently you mean O(1)?
15:24:36 <lispy> singpolyma: Hmm...I think Data.Vector supports slices, but I'm not certain
15:24:48 <acowley> singpolyma: removing arbitrary elements is hard to deal with efficiently. I'd turn to Seq.
15:24:51 <acowley> lispy: it does
15:24:56 <singpolyma> lispy: it supports slices, but not deletions
15:25:23 <lispy> singpolyma: use a binding to the same library that numpy uses :)
15:25:56 <lispy> (I don't know if numpy supports deletions, but I couldn't resist...)
15:26:19 <acowley> Has anybody made a library for a data structure that is effectively a list of vectors?
15:27:16 <singpolyma> acowley: Seq seems interesting, but also does not support delete easily
15:28:19 <acowley> singpolyma: appends should be more efficient, so something like (<>) <$> take (n-1) <*> drop n
15:28:29 <dmwit> singpolyma: Weird, that seems like an oversight in the API. Anyway, it gives you splitAt and append.
15:28:41 <acowley> even better
15:29:05 <dmwit> It calls append (><) for some reason.
15:29:44 <singpolyma> I guess splitAt then append is logarithmic, so that's probably my best bet
15:30:34 <acowley> singpolyma: if deletion is rare compared to indexing, I'd investigate using a list of vectors that you periodically compact
15:31:01 <dmwit> You might also consider looking at a zipper, depending on exactly what you mean by "indexing".
15:31:10 <singpolyma> dmwit: the user input is a number
15:31:50 <singpolyma> acowley: a list of vectors?
15:33:17 <acowley> singpolyma: yes, and layer a vector-like API on top of it to support simple indexing, deletion, and insertion. That way you can delete an item leaving yourself with two vector slices, then indexing just has to check up to two cons cells to decide which piece the index lies in.
15:33:48 <acowley> more deletions would lead to a longer list, hence the periodic compaction
15:33:59 <singpolyma> interesting
15:34:38 <dmwit> data SpaceAgeList a = { compactionIn :: Int, values :: [Vector a] }
15:34:43 <dmwit> compactionIn 3, 2, 1...
15:35:14 <singpolyma> ok, well, thanks for the help everyone ! :)
15:40:27 <dmwit> ack, this is beyond confusing
15:41:04 <dmwit> I can't see which variables are defined by the current debugging stack frame, which means I can't tell if the variable I just printed is live in the current stack frame or coming from a previous (recursive) invocation of the same function.
15:46:51 * hackagebot pem 0.1.0 - Privacy Enhanced Mail (PEM) format reader and writer.  http://hackage.haskell.org/package/pem-0.1.0 (VincentHanquez)
15:54:00 <teneen> I remember using a numeric datatype before (in some library probably) which is more efficient than "Integer" for small numbers but supports arbitrary length numbers. Does anybody know the name of such a datatype?
15:54:56 <bitonic> teneen: if there was something like that and it worked well, it'd be used instead of integer. there was an haskell replacement to Integer, but I doubt it's faster
15:55:09 <shachaf> How is it more efficient than Integer?
15:55:39 <bitonic> teneen: integer-simple
15:55:54 <glguy> integer-simple is definitely not more efficient
15:56:08 <bitonic> yeah
15:56:19 <glguy> it simply has a less restrictive license
15:57:00 <dcoutts> teneen: I'd also be surprised about there being an impl more efficient than Integer for small numbers
15:57:25 <dcoutts> since it already handles machine sized ints as a special case
15:58:10 <hpc> @src Integer
15:58:10 <lambdabot> data Integer = S# Int#
15:58:11 <lambdabot>              | J# Int# ByteArray#
15:58:18 <edwardk> teneen: I'm not aware of such a library
15:58:25 <hpc> im not sure what S and J are short for
15:58:35 <bitonic> small and jumbo.
15:58:41 <hpc> haha, i hope so
15:58:54 <hpc> "jumbo" is a delightful adjective
15:58:56 <teneen> I think I got confused between Integer and it's implementation. I'm sorry guys :)
15:59:40 <hpc> entertainingly, you can convert from Int to Integer with unsafeCoerce
16:00:31 <shachaf> It's very entertaining.
16:00:53 <shachaf> Whenever I'm bored I unsafeCoerce Ints to Integers (and sometimes back, if they fit).
16:01:13 <hpc> quiet, you :P
16:02:40 <Nebu> Hi, I'm new to Haskell, and I was wondering if someone could help me understand how the <*> operator from Applicative is implemented for Either
16:03:22 <glguy> Nebu: have you seen the actual implementation yet?
16:03:23 <JoeyA> > Right (+2) <*> Right 2
16:03:23 <lambdabot>   Right 4
16:03:24 <Nebu> I can see on http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Either.html#t:Either that Either is an "instance" (is that the right word?) of Applicative, but then when I click on "Source" to see the source code for Either I expected to see some implementation of <*> somewhere, but I didn't see anything like that.
16:03:33 <JoeyA> > Right (+2) <*> Left "boom!"
16:03:34 <lambdabot>   Left "boom!"
16:03:42 <JoeyA> > Left "bang!" <*> Right 2
16:03:42 <lambdabot>   Left "bang!"
16:04:05 <Nebu> Left "a" <*> Left "b"
16:04:20 <glguy> Nebu: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html
16:04:21 <Nebu> > Left "a" <*> Left "b"
16:04:22 <lambdabot>   Left "a"
16:04:22 <JoeyA> Nebu: That is the right word.  Unfortunately, Haddock doesn't support jumping to the implementation of class instances.
16:04:29 <glguy>     Left  e <*> _ = Left e
16:04:30 <glguy>     Right f <*> r = fmap f r
16:04:39 <hpc> Nebu: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Control-Applicative.html#Applicative -- scroll down a bit
16:05:11 <Nebu> Great, thanks everybody. This was exactly what I was looking for.
16:06:09 <dmwit> shachaf: "when they fit" is so tricky
16:06:15 <dmwit> Prelude Unsafe.Coerce> y < fromIntegral (maxBound :: Int)
16:06:16 <dmwit> True
16:06:16 <dmwit> Prelude Unsafe.Coerce> unsafeCoerce y
16:06:16 <dmwit> <interactive>: internal error: stg_ap_v_ret
16:06:32 <dmwit> Oh, whoops, no type signature.
16:06:50 <glguy> defaulting saves the day!
16:07:24 <dmwit> Anyway, unsafeCoerce gives back a different number as an Int than y is, even though y is small enough to fit in an Int.
16:07:41 <hpc> ghci's tag bits are wonky
16:07:49 <hpc> if you compile it with ghc it works right
16:08:01 <dmwit> hpc: Not what I wrote. =)
16:08:23 <dmwit> hpc: unsafeCoerce (2^30) :: Int works okay, but unsafeCoerce (2^65 `div` 2^35) :: Int doesn't.
16:08:38 <hpc> oh, huh
16:08:41 <hpc> oh! clever
16:08:42 <dmwit> ...unless perhaps you're on one of those 128-bit machines.
16:08:57 <glguy> dmwit: maybe just wrap that unsafeCoerce in a test to check if it is in the right range? ;)
16:09:00 <hpc> so Integer doesn't normalize
16:09:13 <dmwit> glguy: 2^65 `div` 2^35 is in the right range, but has the wrong tag.
16:09:17 <dmwit> glguy: That's my whole point.
16:09:29 <dmwit> glguy: "when they fit" is so tricky
16:09:30 <glguy> OK, check the tag bits first, too!
16:10:20 <dmwit> glguy: Have you got a proof that this is now a sufficient number of checks to make this unsafeCoerce safe? =)
16:10:35 <dmwit> "Just tack on enough checks that I can't think of any counterexamples" isn't exactly sound programming.
16:10:36 <glguy> Hmm, better use quickcheck
16:12:28 <shachaf> dmwit: Sure. But that's a different matter.
16:12:53 <glguy> dmwit: Who said anything about sound programming? o.O
16:13:04 * lispy wonders what mess dmwit has gotten himself into but is afraid to find out
16:13:13 <hpc> a good C programmer can write C in any language
16:13:17 <lispy> sound programming, you want OpenAL ;)
16:13:29 <hpc> once said programmer figures out how to perform a reinterpret cast
16:13:37 * dmwit kicks and screams, but only gets mired further into his mess
16:22:58 <hpc> are there numeric instances for ordinals anywhere?
16:23:20 <hpc> ω, ℵ0, ℵ1, ...
16:24:44 <sipa> what is omega?
16:24:50 <sipa> finite?
16:25:12 <hpc> the cardinality of countably infinite sets
16:25:32 <sipa> isn't that aleph 0?
16:26:15 <Younder> Ok. I mentioned earlier I had some trouble with Adowey's Category theory. Well I find Robert Goldblat's Topoi The categorical theory of logic' easier going as it starts with set theory and gives it some 'meat' to go on. recommended
16:26:16 <lispy> sipa: Hmm...that's how I learned it, but I have seen omega to.
16:26:41 <lispy> Younder: hmm...thanks for the recommendation
16:26:56 <kallisti> I wonder how implicit configuration could be used with type families to alter constructors based on runtime info.
16:27:04 * lispy complains, "So many great books, so little time."
16:27:24 <hpc> oh, hmm
16:27:34 <hpc> https://en.wikipedia.org/wiki/Ordinal_number -- uses ω
16:27:40 <Younder> why all these hmm's :)
16:27:57 <lispy> Younder: hidden markov models are very popular right now
16:28:04 <lispy> Makes you say hmm
16:28:24 <hpc> https://en.wikipedia.org/wiki/Cardinal_number -- uses aleph
16:28:31 <Younder> And I use themin AI, but you are digressing
16:28:51 <lispy> I'm still digressing what you said (oh the puns...)
16:30:36 <Younder> Lispy: I am old school. No formal education in category theory. Education has CHANGED over the last 20 years. I used sets. So I can relate to that.
16:30:52 <kallisti> relate? get it.
16:31:06 <kallisti> er.. relate. get it?
16:31:09 <dmwit> I don't think CT is necessarily standard now.
16:31:19 <dmwit> even now, I mean.
16:32:17 <lispy> Younder: I feel your pain. I have a BS in math from around 2004 and I never once hear mention of CT when I was at university. Even though I took a year of "graduate" algebra :(
16:32:53 <lispy> Younder: I have the conceptual mathematics book on CT, but I'm still at the beginning as I just find it hard to find time for all my side projects.
16:33:18 <kallisti> I'm having a hard time understanding how type families can be used outside of type classes.
16:34:01 <lispy> (really the only reason algebra was a graduate level course at my school was that our math department existed mainly to support the engineering college and was thus very applied)
16:34:09 <mm_freak> kallisti: do you know the automaton arrow?
16:34:14 <kallisti> no
16:34:32 <mm_freak> newtype Auto a b = Auto (a -> (b, Auto a b))
16:34:33 <kallisti> is the answer "by using other type-level voodoo?"
16:34:43 <mm_freak> it's a function that returns a result along with a new version of itself
16:34:55 <kallisti> okay.
16:35:18 <mm_freak> it makes sense to turn this into an arrow transformer:  newtype Auto (>~) a b = Auto (a >~ (b, Auto (>~) a b))
16:35:32 <mm_freak> now when (>~) = (->), this is just the arrow above
16:35:52 <kallisti> okay
16:35:53 <mm_freak> but now you can use a Kleisli arrow as (>~) allowing monadic effects
16:36:17 * kallisti is not familiar with Kleisli arrows either, but he understands the arrow transformer bit.
16:36:35 <mm_freak> Auto (Kleisli IO) a b corresponds to:  a -> IO (b, Auto (Kleisli IO) a b)
16:36:46 <glguy> kallisti: You can use type families outside of type classes if you apply the type family to a concrete type, for one. The other reason to have them outside of classes is that they might not fit inside any one class, you might want to use them in multiple
16:36:46 <hpc> kallisti: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=8 -- this might get you started on Kleisli
16:36:54 <mm_freak> but now you have that ugly Kleisli wrapper all over your code
16:37:02 <mm_freak> to prevent that you can define a newtype family instead
16:37:18 <mm_freak> newtype family Auto (>~) a b
16:37:25 <hpc> kallisti: or at least, help you to see that it's a category, and what the operations are
16:37:37 <mm_freak> newtype instance Auto (Kleisli m) a b = AutoM (a -> m (b, Auto (Kleisli m) a b))
16:37:57 <mm_freak> now Kleisli is really only used for the type…  it isn't present at data level anymore
16:38:16 <mm_freak> this gives a huge speedup and simplifies code extremely
16:38:23 <kallisti> hpc: well I understand that kleisli composition forms a category over a monad.
16:38:44 <mm_freak> you really don't need any CT to understand this
16:38:47 <dmwit> kallisti: Eh, type families are identical outside of type classes.
16:38:50 <dmwit> type family Foo a
16:38:54 <dmwit> type instance Foo Int = Bool
16:39:06 <dmwit> type instance Foo String = [Tree Int]
16:39:19 <mm_freak> of course type synonym families can be used as type functions, but i thought you might be interested in use cases for data/newtype families
16:39:25 <kallisti> yes they're identical. I'm just having trouble finding out how you can tangible do anything with them in that context. But I see how they could be useful if they're used in multiple type classes, for example.
16:40:03 <dmwit> I think I use them outside a typeclass in edit-lenses, like this:
16:40:09 <mm_freak> one particularly simple use case for non-associated type families is:  data family Map k a
16:40:23 <mm_freak> data instance Map Int a = {- IntSet -}
16:40:30 <mm_freak> uhm
16:40:32 <kallisti> for instance, in a instance declaration you have the benefit of knowing what your constructor is.
16:40:34 <mm_freak> {- IntMap -}
16:40:37 <dmwit> type family L a; type family R a; type instance L (k :+: l) = Either (L k) (L l); type instance R (k :+: l) = Either (R k) (R l)
16:40:40 <dmwit> for example
16:40:56 <dmwit> type instance L (Id a) = a; type instance R (Id a) = a
16:41:06 <dmwit> type instance L (Const a b) = a; type instance R (Const a b) = b
16:41:08 <dmwit> and so forth
16:41:13 <mm_freak> kallisti: with data/newtype families you will indeed use type classes extensively
16:41:28 <mm_freak> at least if you have common operations among the instances
16:41:53 * hackagebot ssh 0.2.8 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.8 (AlexSuraci)
16:42:02 <kallisti> you can't do anything with them if they're fully polymorphic on their arguments, and they're redundant if you use them with an explicit monomorphic argument..
16:42:13 <kallisti> so yes, typeclasses are the only time they seem to provide a use.
16:42:20 <mm_freak> class Delay (>~) where delay :: Auto (>~) a a;  instance (Monad m) => Delay (Kleisli m) where delay = …
16:42:24 <kallisti> at least for homely, value-level programming. :P
16:42:53 <dmwit> Yes, any interesting value with a type family in its type will also have a class constraint.
16:43:24 <dmwit> That's why associated types are the most common way to use them.
16:43:33 <dmwit> But that doesn't mean there's always a canonical class to associate them with.
16:43:38 <kallisti> right
16:43:52 <dmwit> And, I think you'll find that even some "uninteresting" (namely, monomorphic) uses are quite... "interesting". =)
16:43:55 <kallisti> are they even in scope outside of that class and its instance declarations?
16:44:02 <dmwit> yes
16:44:22 <kallisti> so basically all associated types do is add restrictiosn on the type arguments.
16:44:27 <kallisti> or is there something else?
16:44:28 <dmwit> You can control their exposure the same way you control the exposure of class methods.
16:44:41 <dmwit> Associated types make the errors more readable, when they're possible.
16:45:18 <kallisti> ah okay, in addition to the restrictions (the arguments have to be a permutation of the subsets of the class variables, or something like that)
16:45:39 <dmwit> Actually, those restrictions don't come into play as much as you might think.
16:45:57 <dmwit> Even if there's no instance for Foo, you can still write foo :: AssociatedType Foo. It will just be hard to implement.
16:46:19 <kallisti> and type synonym families are just a simpler, less noisy version of data families.
16:46:31 <kallisti> no constructors, just type relationships.
16:46:42 <dmwit> Mmm, they're actually quite different.
16:46:48 <dmwit> Data families are injective in the following sense:
16:47:02 <dmwit> if a /= b, then DataFamily a /= DataFamily b
16:47:08 <dmwit> whereas you can certainly write
16:47:17 <kallisti> ah I see.
16:47:19 <dmwit> type family Foo Int = Bool and type family Foo String = Bool
16:47:22 <kallisti> yes
16:47:37 <dmwit> ...and this matters a lot for type-checking.
16:48:07 <kallisti> I misworded my question a bit.
16:48:38 <kallisti> it was supposed to be something like "do I understand the differences between the two?", but that's a bad question to ask. :P
16:48:44 <dmwit> heh
16:48:50 <kallisti> so I just asked another question to make sure I've got it.
16:49:38 <kallisti> hm that's interesting.
16:57:14 * kallisti thinks it would be nice if you could update documentation and cabal files on Hackage after the fact, but also realizes the inherent difficulty in allowing that without also allowing arbitrary source code changes.
16:59:04 <Liskni_si> if the documentation change is worth it, it's okay to issue a real minor update, I guess
16:59:48 <Liskni_si> people do use local documentation, at least I do
17:00:15 <kallisti> well my version 0 is completely useless to anyone with GHC 7.4
17:00:24 * kallisti tested and built with GHC 7.0
17:00:50 <kallisti> the only fix required is to fix a dependency and then add a LANGUAGE pragma to one file.
17:01:02 <kallisti> but I guess that should be a bug fix release.
17:01:19 <dmwit> I'm glad that cabal files can't be updated without changing the version number.
17:01:22 <dmwit> That would be damn confusing.
17:01:37 <kallisti> sure, for old packages.
17:01:46 <kallisti> but for packages that were uploaded within the past, say, 6 hours
17:01:52 <kallisti> it's not going to matter much if you revise something.
17:02:15 <dmwit> Yes, the question I want to add to my repertoire is "did you happen to try cabal installing that within six hours of its release?".
17:03:04 <hpc> yeah, there's a good reason for source control revision numbers to autoincrement ;)
17:03:13 <kallisti> dmwit: it's not too bad if you practice it a bit. :P
17:03:57 <kallisti> I suppose I shouldn't treat version numbers are precious resources.
17:04:05 <kallisti> but it does seem like a silly thing to make a new version over.
17:04:10 <kallisti> *as
17:04:50 <hpc> one thing i wish more things would do is treat revision numbers as real version numbers
17:05:01 <hpc> the only big piece of code i have ever seen that with is supreme commander
17:05:17 <hpc> which launched as version 3189 or something like that
17:05:35 <kallisti> no problem, I'll just write a script that automatically uploads new commits to cabal.
17:05:38 <hpc> it nicely side-steps the "major version / minor version" thing
17:05:45 <hpc> kallisti: haha
17:05:56 <mm_freak> i think the major/minor thing is great
17:05:58 <kallisti> er, I meant Hackage.
17:06:16 <kallisti> I think it should go something like this
17:06:40 <mm_freak> a good library author will ensure that the interface does not change between patch levels
17:06:48 <kallisti> <PAY ATTENTION TO THIS KTHX>.<API change>.<new features>.<bug fixes>.<oops stupid stuff>
17:06:53 <mm_freak> the revision number doesn't tell you anything about that
17:07:08 <mgsloan>  yeah, the version number is very informative
17:07:15 <luite> does anyone have problems compiling shakespeare-css ghc 7.4.1? on my computer it seems to hang after [3 of 4] Compiling Text.Cassius
17:07:34 <mgsloan> it'd be reasonable to put the revision number as the "D" in "A.B.C.D"
17:07:39 <mm_freak> no need to differentiate between bugs and stupid mistakes
17:08:03 <mm_freak> luite: which version?
17:08:05 <kallisti> some things are just so silly that I don't want to think of them as bugs.. ;_;
17:08:52 <waxjar> i read this http://semver.org/ and it makes sense.
17:09:16 <luite> mm_freak: shakespeare-css-1.0.1.1, with text 0.11.2.0
17:09:42 <luite> mm_freak: the latest, if you do cabal update and then cabal-dev install shakespeare-css you should get those versions
17:11:24 <dmwit> kallisti: Do function/instance additions count as new features or API changes?
17:11:31 <mm_freak> then no idea, sorry
17:11:57 <mm_freak> dmwit: function additions probably count as new features…  new instances might break code
17:12:10 <kallisti> new functions can break code, but it's their fault if it does. :P
17:12:12 <dmwit> Function additions might break code, too.
17:12:14 <geekosaur> dmwit, depends on whether proper use of the library by existing code requres use of the new function (API change) or if it's a new feature
17:12:24 <geekosaur> that wasn't available before, tht is
17:12:44 <mm_freak> well, new functions might cause name clashes…  it breaks compilation, but not really the code
17:12:56 <mm_freak> new instances can be a more serious problem
17:13:33 <mm_freak> also the new functions may not even be part of "the interface"
17:14:00 <kallisti> new typeclass methods should count as API changes unless old instances can safely work without defining them.
17:16:08 <dmwit> I'm not convinced the API change/new feature distinction is helpful, if that's your stance.
17:16:24 <dmwit> In the sense that I would never depend on A.B rather than A.B.C.
17:16:32 <smop> so every time ghc gets updated it breaks everything?
17:16:46 <monochrom> rather it ignores everything
17:16:55 * hackagebot kqueue 0.1.2.3 - A binding to the kqueue event library.  http://hackage.haskell.org/package/kqueue-0.1.2.3 (ErikHesselink)
17:16:57 <kallisti> I don't think it's perfect, but it's certainly helpful in a world where I don't have infinite free time to maintain package dependencies.
17:17:12 <monochrom> it cannot use object code made by older compilers, that's why
17:17:32 <monochrom> or rather, it could try, but that would be very unsafe
17:18:18 <kallisti> the difficult arises because it's not always possible to ensure that something a package maintainer considers "minor" to actually be that.
17:18:23 <kallisti> *difficulty
17:18:41 <kallisti> but that's not a flaw in the PVP, just a flaw with people. Good luck fixing that.
17:19:59 <kallisti> I guess a more specific definition of "API change" could be useful.
17:24:22 <kallisti> what would be better is if Hackage notified you every new version of every dependency you had.
17:25:28 <kallisti> and uploading a new version of a package caused Hackage to attempt to rebuild every package that depends on it with that specific version, and notifying the maintainer if the build fails.
17:26:11 <luite> hm, it looks like ghc hangs in an infinite loop (100% cpu) just when it starts loading packages (TH) for compiling that file
17:27:42 <monochrom> a specific definition of "API change" that works for a large class of libraries may need very advanced category theory :)
17:28:27 <kallisti> monochrom: finally an application for CT.
17:28:53 <c_wraith> especially since some API changes don't change any type signatures.
17:29:04 <kallisti> hmm, maybe I should submit some patches to hackage2
17:29:51 <Enigmagic> how about packages with tests defined?
17:30:25 <luite> what's the correct way to uninstall the haskell platform on OS X? running the uninstaller doesn't remove /Library/Haskell, can I just rm -r that dir?
17:30:37 <Mathnerd314> c_wraith: that's just because you don't have very good types
17:31:55 * hackagebot majordomo 0.1.6 - Majordomo protocol for ZeroMQ  http://hackage.haskell.org/package/majordomo-0.1.6 (MarkWotton)
17:32:40 <kallisti> it's not good when the first results for "polykinds haskell" are error messages and bug reports.
17:33:06 <Enigmagic> kallisti: it's not officially supported yet
17:33:15 <Enigmagic> i think it will be in 7.6.x
17:34:15 <Enigmagic> i've been using it though and it seems to work for my simple scenarios
17:55:52 <drdo> Is there some way to write something like this: foo `liftA2 (++)` bar ?
17:56:09 <elliott__> no
17:56:31 <elliott__> well i think there's some really ugly trick involving defining a set of identifiers that work with typeclass ugliness to allow you to do that
17:56:42 <elliott__> but no :)
17:57:06 <c_wraith> I think there's a package that does something like that.
17:57:40 <c_wraith> http://hackage.haskell.org/packages/archive/InfixApplicative/1.1/doc/html/Control-Applicative-Infix.html
17:58:11 <c_wraith> unfortunately, the haddocks for that package are malformed
17:58:27 <elliott__> was about to say
17:58:28 <elliott__> http://hackage.haskell.org/packages/archive/InfixApplicative/1.1/doc/html/src/Control-Applicative-Infix.html#%21BF
17:58:32 <drdo> By the way, to be clear, by "something like this", i'm talking purely about syntax
17:58:34 <elliott__> that's less ugly than the hack i know
17:58:42 <elliott__> i still wouldn't recommend it though :p
17:58:54 <elliott__> if you want that use she and get proper idiom brackets
17:58:56 <elliott__> (| foo ++ bar |)
17:59:34 <kallisti> elliott__: when using implicit configurations, the type parameters that represent the reified value are unified with the type itself, not the Proxy, right?
17:59:45 <kallisti> ....does that question even make sense?
18:01:20 <hpaste> mikeplus64 pasted “i suck at state” at http://hpaste.org/66789
18:01:43 <elliott__> kallisti: i don't know what that means.
18:01:44 <mikeplus32> I'm trying to build a record like this
18:01:52 <mikeplus32> but it's obviously not working
18:01:56 * hackagebot hOpenPGP 0.2 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.2 (ClintAdams)
18:01:57 <elliott__> kallisti: does the type of "reify" answer your question?
18:02:21 <drdo> c_wraith: I was asking if there was some syntax in Haskell to allow me to use a function infix when the syntax inside the ` ` is not a single identifier, not specifially about any of those functions :)
18:02:54 <kallisti> elliott__: in my use case, for example, is the "v" parameter of my various types a Proxy a or just a?
18:03:00 <kallisti> is basically what I'm asking. I think it's a
18:03:04 <byorgey> drdo: no, there isn't.
18:03:06 <elliott__> drdo: that package lets you write [1,2] <^(+)^> [2,3]@
18:03:10 <elliott__> *scratch the @
18:03:13 <elliott__> for liftA2 (+) [1,2] [2,3]
18:03:17 <elliott__> so, it *is* related :)
18:03:24 <byorgey> <^(+)^>, the happy pig operator
18:04:00 <elliott__> kallisti: "a" is misleading. "a" is the *type* of the value. The reified-value-as-a-type is usually called "s" or "p". In which case, you can tell from the type of reify -- reify :: a -> (forall s. (Reifies s a) => Proxy s -> r) -> r -- the answer.
18:04:41 <kallisti> ah, should be s then.
18:06:36 <drdo> elliott__: Oh, indeed, i guess i'll use it then since i asked about it when working with Applicatives anyway
18:07:53 <elliott__> drdo: imo it's uglier than liftA2, but whatever you like :)
18:07:57 <elliott__> is anyone using the new haskell-mode?
18:08:14 <drdo> Ah, nevermind, doesn't build anyway
18:08:31 <kallisti> elliott__: if it was in Debian stable repo this morning, yes.
18:08:40 <elliott__> no
18:08:42 <drdo> Something about the Prelude module being both base and haskell98
18:08:49 <drdo> *being in
18:08:50 <elliott__> drdo: oh, yeah, it's an old package.
18:09:08 <elliott__> drdo: it's only two trivial functions though
18:09:16 <elliott__> (<^) = flip fmap; (^>) = (<*>)
18:09:33 <hpc> wow, i would rather just use (<$>)
18:09:53 * elliott__ too
18:10:09 <elliott__> hpc: the idea is foo <^(+)^> bar, if you didn't see
18:10:10 <hpc> it's hard to tell that the (+) in that ascii mess is a separate token
18:10:30 <kallisti> elliott__: oh I see. you can get away with the forall s because of the functional dependeny in Reifies, yes?
18:11:36 <elliott__> kallisti: actually i do not believe the functional dependency is required for anything other than convenience
18:11:53 <elliott__> the "forall" just means that you don't get to know what the reified type is, it's phantom, the smoke and mirrors behind the scenes is irrelevant to you
18:12:00 <elliott__> indeed in the current implementation it never even commits to a type s
18:13:55 <drdo> In this specific case, i wanted to write something like "(x `liftA2 (<>)` y) `liftA2 (|>)` z" instead of "(|>) <$> ((<>) <$> x <*> y) <*> z".
18:14:29 <elliott__> liftA2 (|>) (liftA2 (<>) x y) z
18:14:32 <elliott__> much better
18:14:51 <drdo> elliott__: I prefer the infix version :P
18:14:53 <elliott__> fwiw, you can give an instance Monoid a => Monoid (MyApplicative a) where mempty = pure mempty; mappend = liftA2 (*)
18:14:57 <elliott__> then you could say just (x <> y)
18:15:02 <elliott__> but that's kind of evil
18:15:10 <elliott__> drdo: anyway with she that'd look like (| (| x <> y |) |> z |)
18:15:58 <Axman6> :t (\x y z -> (\a b c -> (a <> b) |> c) <$> x <*> y <*> z)
18:15:59 <lambdabot> Not in scope: `|>'
18:16:07 <Axman6> :t (\x y z -> (\a b c -> (a <> b) <|> c) <$> x <*> y <*> z)
18:16:08 <lambdabot>     Couldn't match expected type `f a' against inferred type `Doc'
18:16:08 <lambdabot>     In the first argument of `(<|>)', namely `(a <> b)'
18:16:08 <lambdabot>     In the expression: (a <> b) <|> c
18:16:20 <elliott__> :t (\x y z -> (\a b c -> (a ++ b) <|> c) <$> x <*> y <*> z)
18:16:21 <lambdabot> forall (f :: * -> *) a (f1 :: * -> *). (Monoid (f a), Alternative f, Applicative f1) => f1 (f a) -> f1 (f a) -> f1 (f a) -> f1 (f a)
18:16:50 <kallisti> :t ($)
18:16:51 <lambdabot> forall a b. (a -> b) -> a -> b
18:16:54 <drdo> elliott__: That Monoid instance wouldn't really help in this case because of the (|>)
18:17:39 <drdo> Well it would sort of partially help i guess
18:17:53 <dibblego> roconnor: ping
18:17:55 <kallisti> :t const
18:17:56 <lambdabot> forall a b. a -> b -> a
18:20:44 <kallisti> elliott__: so you use the Magic existential to create a dictionary at runtime, and then the unsafeCoerce followed by application somehow magically makes reflect = const a?
18:22:20 <drdo> Is there some haskell-mode indentation option that aligns arguments in multiple lines? i.e.
18:22:23 <drdo> f x
18:22:24 <drdo>   y
18:22:38 <kallisti> none that I know of.
18:22:59 <kallisti> it would severely increase the amount of tab-spamming you would have to do.
18:23:06 <elliott__> kallisti: It turns (forall s. (Reifies s a) => Proxy s -> r) into (forall s. (forall proxy. proxy s -> a) -> Proxy s -> r), where the first argument is the dictionary of (Reifies s a), and then gives (const a).
18:23:31 <elliott__> kallisti: (Actually, I lie, it turns (forall s. (Reifies s a) => Proxy s -> r) into ((Any -> a) -> Proxy Any -> r).)
18:23:38 <kallisti> elliott__: so the dictionary is literally equivalent to the internal representation of the function?
18:23:40 <drdo> kallisti: I find the current choice quite unreadable
18:23:42 <elliott__> kallisti: (So you could make an argument it picks s = Any.)
18:23:44 <elliott__> kallisti: Yes.
18:23:50 <elliott__> But that's an implementation detail.
18:23:59 <kallisti> what happens with classes that have multiple methods?
18:24:04 <kallisti> multi-argument function?
18:24:13 <kallisti> er, I mean.
18:24:15 <kallisti> if there were 2 methods
18:24:19 <kallisti> you would just apply 2 functions?
18:24:30 <elliott__> No.
18:24:32 <kallisti> or, is the 1-method representation a special case?
18:24:36 <elliott__> I think so, yes.
18:24:46 <elliott__> All my attempts to get it working with multiple-element classes fail.
18:25:00 <elliott__> I didn't try passing multiple parameters, but I kind of doubt that would work, going by the Core I've read.
18:25:22 <elliott__> In the slow implementation, for what it's worth, it picks s = Stable b0 b1 b2 b3 b4 b5 b6 b7 a.
18:25:32 <elliott__> Which is a phantom type with no values.
18:25:44 <elliott__> b{0..7} are the type-level bytes of the StablePtr.
18:25:51 <kallisti> ..
18:26:03 <elliott__> Then the instance drags those bytes out of the type and dereferences the pointer.
18:26:16 <kallisti> no. too much magic. I can't handle it.
18:26:57 * hackagebot data-clist 0.0.7.2 - Simple functional ring type.  http://hackage.haskell.org/package/data-clist-0.0.7.2 (JohnVanEnk)
18:27:46 <kallisti> elliott__: so what happens when GHC devs decide to change that representation?
18:29:23 <elliott__> kallisti: Which one?
18:29:38 <kallisti> the one you're relying on to make reflection fast, currently.
18:29:46 <elliott__> kallisti: They won't. It works on Hugs, too.
18:29:57 <elliott__> But if that *did* happen, everyone would just rebuild with -fslow.
18:30:19 <elliott__> I can't think of any such change which wouldn't make GHC's programs slower for no reason, though.
18:32:16 <kallisti> speaking of which, is it possible to specify that my package depends on certain flags? probably not.
18:32:30 <kallisti> I guess you would just change -fslow to be the default and push a new version, if that happened.
18:33:02 <elliott__> No, you can't depend on flags. Doing so in this case would be incorrect.
18:33:08 <elliott__> Flags shouldn't affect a package's API.
18:33:41 <kallisti> oh right cabal will attempt to build with multiple flags until it works.
18:35:54 <elliott__> It would build if the representation changed.
18:35:59 <elliott__> unsafeCoerce isn't that smart.
18:40:55 <ddfisher> hi all
18:41:13 <ddfisher> I'm having some problems getting a trivial program using parsec to compile
18:41:37 <ddfisher> I'm getting: Not in scope: type constructor or class `Parser'
18:41:40 <hpaste> ddfisher pasted “Trivial Parse” at http://hpaste.org/66791
18:45:55 <tkahn6> ddfisher: add a NoMonomorphismRestriction to the top and remove the type signature, i'm fairly certain it's not valid in the newwer version of Parsec which is in Text.Parsec
18:46:09 <hitnes> need help
18:46:35 <elliott__> hitnes: just ask your question
18:46:52 <tkahn6> ddfisher: here's an assembler I wrote with parsec the other day, https://github.com/tkahn6/dcpu16-haskell/blob/master/DCPU16/Assembler.hs
18:46:53 <elliott__> ddfisher: import Text.Parsec.String?
18:46:58 * hackagebot aws 0.4.0 - Amazon Web Services (AWS) for Haskell  http://hackage.haskell.org/package/aws-0.4.0 (AristidBreitkreuz)
18:46:58 <elliott__> that should make Parser Int valid
18:48:00 <ddfisher> elliott__: that only makes Parser Char valid, it seems
18:48:42 <ddfisher> tkahn6: awesome assembler
18:48:52 <ddfisher> I'd like to keep the type signature if possible, though :/
18:49:07 <drdo> Is there a site providing Hoogle over all of Hackage?
18:49:13 <elliott__> drdo: hayoo
18:49:14 <elliott__> @where hayoo
18:49:14 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
18:49:22 <elliott__> ddfisher: I don't quite understand
18:49:23 * BMeph swears that one day he will successfully see the function 'unsafeCoerce' without immediately following it in his head with "high school girls"...
18:49:42 <c_wraith> BMeph: I've never once had that thought. >_>
18:49:59 <elliott__> ddfisher: it exports type Parser = Parsec String ()
18:50:01 <elliott__> so it should work fine
18:50:08 <shachaf> ddfisher: (Hi!)
18:50:12 <hpc> BMeph: ever seen an Aronofsky movie?
18:50:14 <elliott__> import it as well as Text.Parsec.Char
18:50:14 <BMeph> c_wraith: Count yourself lucky. :)
18:50:22 <hpc> BMeph: unsafePerformSwanLake
18:50:34 <ddfisher> hi shachaf!
18:50:55 <BMeph> hpc: unsafeCoerceNataliePortman? ;þ
18:51:05 <ddfisher> elliott__: "Couldn't match expected type `Int' with actual type `Char'"
18:51:15 <elliott__> ddfisher: that just means your parser parses a Char, but you said it parses an Int :)
18:51:22 <elliott__> indeed, digit :: Parser Char
18:51:30 <ddfisher> elliott__: Ah, of course! >.<
18:52:01 <elliott__> there's stuff in http://hackage.haskell.org/packages/archive/parsec/3.1.2/doc/html/Text-Parsec-Token.html to help you parse numbers but it's quite involved, so you might just want to write your own parsing code
18:52:19 <elliott__> :t readDec
18:52:20 <lambdabot> forall a. (Num a) => String -> [(a, String)]
18:52:20 <elliott__> might help
18:52:24 <tkahn6> yeah ddfisher what are you tring to parse?
18:52:53 <elliott__> a digit, one presumes :P
18:53:01 <ddfisher> xD
18:53:17 <ddfisher> I know how to parse things with parsec in general
18:53:21 <kallisti> he's trying to parse characters, duh.
18:53:53 <ddfisher> I'd used attoparsec in the past
18:55:10 <tkahn6> parsec is a beautiful thing. i only started using it a few days ago but it's so intuitive
18:55:14 <ddfisher> and IIRC importing Data.Attoparsec included the Parser datatype/class
18:56:04 <ddfisher> thanks for the help! :)
18:57:17 <kallisti> _-- _--
18:57:47 <xemdetia> Is there any way to do reflection so you could do something like show (function name) and have it spit out the function's name without doing anything too crazy?
18:57:58 <elliott> No.
18:58:02 <xemdetia> Thanks!
18:58:05 <elliott> (Hugs can do that! Except not with "show".)
18:58:10 <elliott> xemdetia: You might find the GHCi debugger helpful?
18:58:12 <shachaf> elliott: It can?
18:58:16 <elliott> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghci-debugger.html
18:58:24 <shachaf> elliott: Does it do it in an evil way?
18:58:26 <elliott> shachaf: Yes, you have to tell it to use its internal printer rather than its Show-based printer.
18:58:34 <elliott> So it's not any evil trick.
18:58:35 <shachaf> Ah, OK.
18:59:37 <elliott> N.B. Above statements are not endorsements of using Hugs in 2012.
19:00:47 * BMeph concurs: Use Drugs, not Hugs!
19:01:39 <xemdetia> elliott: Thanks, I was using ghci already but what I was working on didn't really make sense to have a show instance.
19:01:43 <tkahn6> anyone here have experience implementing a plugin system?
19:03:46 <ddfisher> what do you mean by plugin system?
19:04:36 <dibblego> once I plugged f into g with .
19:04:45 <tkahn6> like dynamically loaded files consisiting of heterogeneous data types that are part of a type class that an be forkIO'd at runtime
19:04:48 <c_wraith> a real plugin system?  Not exactly.  I did implement Snap's dynamic reloading.
19:05:15 <c_wraith> Not exactly the same thing, but it shares some properties
19:05:19 <tkahn6> basically i'm working on a DCPU emulator and i'd like to have an extenson system, threads that talk over a 'memory bus'
19:05:50 <ddfisher> and you want to dynamically load haskell files?
19:05:51 <kallisti> one way to do plugins is via shared libraries
19:06:15 <ddfisher> there's System.Plugins
19:06:19 <c_wraith> tkahn6: I'm not sure you need plugins for that.  Why not just design your emulator as a library that allows you to pass in things to modify behavior?
19:06:21 <tkahn6> ddfisher: yeah i think so, like the user would specify in a config file which extensions he has installed that he wants loaded
19:06:33 <shachaf> dons did hs-plugins years ago.
19:06:40 <shachaf> ddfisher: Didn't you do a project that used that?
19:06:51 <ddfisher> shachaf: yeah
19:07:05 <tkahn6> c_wraith: well i'd like it to be done at runtime, dynamically loading extensions that are installed
19:07:08 <elliott> tkahn6: Don't say "heterogeneous data types". :(
19:07:14 <tkahn6> hehe
19:07:17 <ddfisher> shachaf: https://github.com/sakana/HaPy
19:07:27 <ddfisher> allows one to call haskell functions from python
19:07:34 <ddfisher> hackish
19:07:40 <tkahn6> data types that are instances of a type class
19:07:41 <ddfisher> still not fully stable
19:07:41 <shachaf> Yes, Bill showed it to me at one point.
19:09:26 <nand`> Is any haskell compiler capable of producing shared libraries?
19:09:31 <nand`> that can be called from C
19:09:54 <shachaf> Yes.
19:10:12 <nand`> Which ones, how well does it work and how well is it documented?
19:10:25 <elliott> "Which ones"?
19:10:28 <elliott> It can produce any one you make.
19:10:32 <nand`> Which compilers
19:10:40 <elliott> GHC.
19:10:45 <elliott> There aren't any other compilers (that matter).
19:10:55 <elliott> (Sorry, jhc & UHC folks!)
19:11:02 <elliott> I think jhc compiles to C though. So it might be able to do that.
19:12:08 <elliott> See http://www.haskell.org/ghc/docs/latest/html/users_guide/ffi-ghc.html, "8.2.1.2. Making a Haskell library that can be called from foreign code".
19:12:23 <nand`> My ultimate goal is to add Haskell scripting support to the WeeChat IRC client; so to do this I'd need to write a shared library that will be called from within weechat, which is written in C, using its existing APIs. I am wondering if I can write this “Haskell plugin” in Haskell itself. Do you think this is feasible?
19:12:30 <nand`> Or will I require cooperation on the C side of things?
19:13:24 <elliott> You will need to write C code, because you have to initialise the RTS.
19:13:49 <elliott> But assuming WeeChat will call an initialisation function for you, etc., then it should work.
19:14:33 <nand`> Okay. Maybe I can split it into two stages; an ultraminimal C wrapper that simply initializes the RTS and passes on a bunch of calls, and an accompanying Haskell library that actually pulls in GHC and compiles/executes the scripts
19:15:03 <nand`> I'll have to look into the weechat plugin API but it sounds reassuring
19:18:29 <dibblego> tensorpudding_: you there?
19:24:50 <td123> nand`: are you writing haskell plugin support for weechat?
19:25:08 <nand`> td123: planning to
19:25:17 <nand`> td123: I'll first have to get comfortable with the FFI
19:25:25 <nand`> (which is something I ought to do either way)
19:26:01 <td123> good luck :)
19:27:24 <tkahn6> is there a version of tail that yields an empty list if the list is empty?
19:27:33 <tkahn6> and not an error
19:27:45 <Clint> type error
19:27:45 <scombinator> myTail [] -> []
19:27:55 <scombinator> myTail x -> tail x
19:28:20 <dibblego> tkahn6: there is in data-lens
19:28:20 <tkahn6> ... thanks scombinator i'm looking for a std library version...
19:28:33 <scombinator> why?
19:29:00 <elliott> tkahn6: drop 1
19:29:15 <tkahn6> elliott: u rock
19:29:21 <elliott> i know
19:29:35 <tkahn6> elliott: my favorite part is your modesty
19:29:37 <tkahn6> :p
19:29:58 <tkahn6> scombinator: cuz i'd rather not litter my file with trivial implementations of built-in things
19:29:59 <elliott> that's my favourite part as well!
19:30:02 <tkahn6> haha
19:30:29 <tkahn6> scombinator: but i do appreciate your help
19:30:52 <dibblego> getorEmptyPL tailLens id
19:31:16 <elliott> that's a lot uglier than drop 1 :P
19:31:33 <dibblego> I don't rock as much as you though
19:31:36 <scombinator> It's a lot clearer than drop 1
19:31:39 <elliott> (is it really "getor" and not "getOr"? :( )
19:31:50 <dibblego> yes it really is -- we are looking for better names
19:31:52 <elliott> scombinator: Yeah, "get or empty pl tail lens id" is a lot clearer than "drop 1 [element]"
19:32:01 <dibblego> http://hackage.haskell.org/packages/archive/data-lens/2.10.0/doc/html/Data-Lens-Partial-Common.html
19:32:15 <elliott> dibblego: /me would suggest omitting "P" from "PL" and having people import qualified instead, perhaps?
19:32:24 <elliott> since most lenses aren't partial, people won't want to import the operators anyway
19:32:35 <dibblego> most lenses are partial though
19:32:50 <nand`> elliott: I'm getting a strange error when compiling my main.c (using GHC): main.c: undefined reference to `foo'; I double checked that it includes “Foo_stub.h” and that Foo_stub.h declares extern HsInt foo(HsInt a1);
19:32:53 <nand`> Do you know why this could be?
19:33:14 <dibblego> not most, more like, partial lenses are as common as summation, which is not more or less common than multiplication
19:33:26 <elliott> nand`: not sure, sorry; ISTR someone else having a similar problem, though
19:33:29 <elliott> dibblego: fair enough
19:33:35 <elliott> dibblego: maybe both modules should be designed to be imported qualified, then
19:33:48 <elliott> null :: PartialLens a b  -- hmm, isn't (PartialLens a b) a monoid?
19:33:49 <dibblego> elliott: yall generalises on the functor -- I'm torn over thisapproach at the moment
19:34:10 <dibblego> elliott: No. There is no (+++) for Lens
19:34:18 <elliott> what's wrong with: instance Monoid (PartialLens a b) where mempty = PLens (const Nothing); mappend (PLens f) (PLens g) = PLens (\x -> f x <|> g x)
19:34:40 <elliott> it merges the information
19:35:14 <dibblego> I shall have to inspect that later for laws
19:35:20 <dibblego> all these points are good though
19:35:34 <dibblego> there is a mergePL which uses Either
19:35:59 * elliott just hates to see functions which look like they could be typeclass instance methods instead :)
19:36:42 <dibblego> well, they are in my personal implementation -- but I am compromising here and trying to work out for sure what is best
19:37:03 * elliott *really* doesn't like yall's approach
19:37:10 <dibblego> elliott: why?
19:37:13 <elliott> because m and w are totally unrelated, you can't provide any laws
19:37:18 <dibblego> yes right
19:37:25 <dibblego> what about a middle ground? remove the w
19:37:47 <elliott> that might be ok -- but isn't that generalising based on the "optimised implementation" of PLens, rather than its abstract semantics?
19:37:54 <elliott> that seems like a bad idea, IMO
19:38:12 * elliott isn't really sure what other "m"s apart from Maybe would work there. you can't do IO, because anything that requires IO to get is gonna requrie IO to set
19:38:15 <dibblego> I'm not sure what you mean there
19:38:31 <mgsloan> the nice thing about yall is that you can have partiality in one direction.  There are plenty of cases where you have a partial getter, total setter, and vice versa.
19:38:32 <elliott> dibblego: well roconnor keeps going on about how PLens a b is _really_ a -> Either a (b, a -> b)
19:38:42 <dibblego> you can do "anything Traversable" (which IO is not)
19:38:42 <elliott> and the Maybe representation is just an ugly optimisation that people should ignore :p
19:38:55 <elliott> because it doesn't ahve the abstract backing
19:39:10 <elliott> so, it seems to me that generalising based on the Maybe representation is a bad idea
19:39:26 <dibblego> elliott: so then, how would you distinguish Lens and PLens operators?
19:39:44 <elliott> add a ? to the end of all of them? :P
19:39:44 <nand`> elliott: Ah, I figured it out, used an incorrect command line to GHC
19:39:49 <dibblego> class Op f where :: f a b; instance Op Lens; instance Op PLens -- perhaps?
19:39:49 <elliott> I dunno, I hate the operators.
19:39:53 <mgsloan> well, Maybe = Either ()
19:39:57 <elliott> Oh, which operators are you talking about?
19:39:57 <kallisti> anyone wanna help me with some math homework? (it's a proof)
19:39:59 <elliott> The actual infix ones?
19:40:04 <dibblego> elliott: any of them
19:40:11 <elliott> Well, do you mean "function", or "infix operator"?
19:40:14 <dibblego> elliott: the dichotomy between thisL and thisPL
19:40:17 <elliott> Right.
19:40:35 <elliott> Well, I don't think the typeclass approach is a good idea.
19:40:54 <elliott> I'd probably remove the "L" and "PL" from both and tell people to import them qualified as L and PL. But I don't know.
19:41:16 <elliott> Right now your infix operators clash between the two, which is no good, since you either have to get redundancy with "PL.fooPL" to not have the operators clash, or use explicit import lists.
19:41:18 <dibblego> OK, well you are roughly where I am at in my "I don't know"-ness
19:41:28 <elliott> awesome!
19:41:55 <dibblego> OK, I think that's bad -- didn't notice
19:42:00 <elliott> I'll take a closer look later and will perhaps be able to give more concrete feedback
19:42:04 <dibblego> ta
19:42:07 <elliott> dibblego: fwiw, if you need to change the operators I'd append ? to them
19:42:17 <elliott> the infix ones that is
19:42:19 <elliott> but I hate data-lens' infix operators with a fiery passion anyway
19:42:31 <dibblego> haskell won't allow appending ?
19:42:36 <elliott> ugh
19:42:42 <elliott> well, append a symbol ugly enough that everybody will use the words instead
19:42:49 <elliott> like $%^
19:43:03 <nand`> Can I pass a null pointer to hs_init's second argument (argv) if argc=0?
19:43:08 <dibblego> oh sorry, you mean the infix operators
19:43:15 <dibblego> yes can do that
19:43:19 <elliott> right
19:43:26 <elliott> well, anyway, like I said I'll look at it closer tomorrow or so
19:43:31 <dibblego> k
19:43:32 <elliott> I haven't used data-lens since before it grew these complicated partial lenses
19:43:53 <dibblego> roconnor and I worked on it
19:44:34 <zzing> I noticed I didn't get parsec documentation when I installed it, was there an option I needed to turn on to get cabal to generate it?
19:45:12 <elliott> you need to set documentation: True in ~/.cabal/config
19:46:09 <zzing> elliott, is there a way to go back and have it generate all documentation for every package?
19:47:37 <elliott> only cabal install --reinstall world
19:47:42 <elliott> sorry :(
19:47:57 <zzing> hmm, if I did that would that be enough and not break anything? :P
19:48:12 <elliott> possibly!
19:48:18 <elliott> it'll take a while though
19:48:27 <zzing> elliott, I don't have much installed tbh
19:48:30 <zzing> I don't use platform
19:50:27 <nand`> http://paste.pocoo.org/show/579299/ <- any ideas?
19:51:09 <nand`> for reference: main.c http://paste.pocoo.org/show/579300/ Foo.hs http://paste.pocoo.org/show/579301/
19:51:59 * hackagebot mighttpd2 2.5.8 - High performance web server on WAI/warp  http://hackage.haskell.org/package/mighttpd2-2.5.8 (KazuYamamoto)
19:53:41 <luite> wow scary how few version constraints that package has
19:57:42 <zzing> Love documentation :P
19:58:05 <ddfisher> nand`: how was Foo.hs compiled?
19:58:11 <nand`> ddfisher: “ghc Foo.hs”
19:58:40 <ddfisher> try
19:58:47 <ddfisher> "ghc -fPIC Foo.hs"
19:58:54 <shachaf> Cale: Did lambdabot's database get wiped again?
19:59:19 <Cale> shachaf: I don't know. I didn't do anything intentionally.
19:59:29 <Cale> shachaf: I just run it again when it goes down.
19:59:35 <shachaf> @karma-all
19:59:35 <lambdabot>  "C/C"                  80
19:59:37 <lambdabot>  "("                    72
19:59:39 <lambdabot>  "g"                    30
19:59:41 <lambdabot>  "dmwit"                26
19:59:43 <lambdabot>  "monochrom"            17
19:59:45 <lambdabot> [738 @more lines]
19:59:46 <shachaf> Some quotes also seem to be missing.
20:03:05 <nand`> ddfisher: http://paste.pocoo.org/show/579304/ <- slightly altered the files as well, have a look
20:04:14 <sizz> how can I use Data.Char in ghci?
20:04:29 <tgeeky> :m +Data.Char
20:04:34 <elliott> > import Data.Char
20:04:35 <lambdabot>   <no location info>: parse error on input `import'
20:04:43 <elliott> tgeeky: 6.12er :P
20:04:51 <tgeeky> elliott: ewwwww
20:04:57 <elliott> or actually i think it worked then too
20:05:06 <tgeeky> I find it funny that "C/C" is the highest thing
20:05:08 <elliott> "import Data.Char" has worked for years anyway
20:05:11 <tgeeky> as opposed to one or the other
20:05:23 <elliott> C has an exception
20:05:33 <tgeeky> elliott: I deduced that
20:05:40 <elliott> :)
20:05:41 <shachaf> As does "C" \\ "++"
20:05:46 <tgeeky> but not (++
20:06:03 <elliott> i++
20:06:07 <elliott> @karma i
20:06:07 <lambdabot> i has a karma of 6
20:06:08 <elliott> i++
20:06:09 <elliott> @karma i
20:06:09 <lambdabot> i has a karma of 7
20:06:15 <ddfisher> nand`: okay, so what's worked for me in the past is something like:
20:06:28 <ddfisher> ghc -fPIC -dynamic -c Foo.hs
20:06:51 <ddfisher> err
20:06:54 <ddfisher> what do you want to end up with?
20:07:05 <ddfisher> an executable, or a shared object library?
20:07:09 <nand`> ddfisher: the latter
20:07:31 <nand`> ddfisher: ghc -fPIC -dynamic Foo.hs seems to have done the trick; I can successfully compile a.out (a shared library) with ghc -fPIC -shared -dynamic foo.c Foo.h
20:07:35 <nand`> s/Foo.h/Foo.o/
20:07:51 <nand`> I have succeeded in compiling an executable already
20:07:59 <nand`> (which did not need -fPIC or -dynamic)
20:09:00 <ddfisher> nand`: you probably also should do: "ghc -dynamic -shared" when you compile the shared object library
20:09:45 <ddfisher> nand`: nvm, you're already doing that x_x
20:10:32 <nand`> ddfisher: yeah, found that online simultaneously; in a post that read “using -shared without -dynamic should be rejected” <- so I figured I needed both
20:12:43 <ddfisher> nand`: Cool! Glad it's working. :)
20:17:00 <nand`> http://weblog.haskell.cz/pivnik/building-a-shared-library-in-haskell/ <- this is surprising me somewhat; in his test.c he never calls library_init and library_exit
20:17:12 <nand`> and indeed, if I don't call them, it immediately segfaults
20:17:19 <nand`> what's up with that?
20:20:30 <nand`> hmm, calling library_init is what segfaults me, before it ever reaches the code in Foo.so, that's interesting
20:22:09 <kallisti> "However, type families - in contrast to GADTs - are open; i.e., new instances can always be added, possibly in other modules. Supporting pattern matching across different data instances would require a form of extensible case construct."
20:22:13 <nand`> even dlclose(dl); segfaults, I'm guessing the issue is with test.c and not the library. I'll just test it with weechat and see what happens
20:22:15 <kallisti> almost like a type class or something
20:27:00 * hackagebot splice 0.2 - Socket to Socket Data Splicing  http://hackage.haskell.org/package/splice-0.2 (CetinSert)
20:28:08 <elemir> @hoogle :: Eq a => a -> [a] -> ([a], [a])
20:28:08 <lambdabot> Prelude splitAt :: Int -> [a] -> ([a], [a])
20:28:08 <lambdabot> Data.List splitAt :: Int -> [a] -> ([a], [a])
20:28:08 <lambdabot> Data.List genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
20:28:11 <elemir> Hem
20:29:42 <elemir> Sad
20:30:27 <parcs`> :t span
20:30:28 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:30:31 <parcs`> :t partition
20:30:32 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:31:51 <elemir> > span (== " ") "meow meow meow"
20:31:53 <lambdabot>   Couldn't match expected type `[GHC.Types.Char]'
20:31:53 <lambdabot>         against inferred ty...
20:32:03 <elemir> Ah
20:32:05 <parcs`> > partition (==' ') "moo moo moo"
20:32:06 <lambdabot>   ("  ","moomoomoo")
20:32:08 <elemir> > span (== ' ') "meow meow meow"
20:32:09 <lambdabot>   ("","meow meow meow")
20:32:22 <parcs`> > span (=/ ' ') "moo moo moo"
20:32:23 <lambdabot>   Not in scope: `=/'
20:32:26 <parcs`> > span (/= ' ') "moo moo moo"
20:32:27 <lambdabot>   ("moo"," moo moo")
20:32:47 <elemir> Ah, nice
20:32:59 <elliott> break too
20:33:09 <elemir> :t break
20:33:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
20:34:50 <parcs`> it would be cool if hoogle knew that 'Eq a => a -> b' ~ '(a -> Bool) -> b'
20:35:30 <elemir> Not, it isn't
20:35:53 <elemir> Because where are two ways to convert 'Eq a => a -> b' to '(a -> Bool) -> b'
20:35:57 <elemir> *there
20:37:17 <parcs`> what are the two ways?
20:37:21 <kallisti> hmm, I don't see a way to specify a changelog in cabal files.
20:37:53 <elemir> :t \a -> (/= a)
20:37:54 <lambdabot> forall a. (Eq a) => a -> a -> Bool
20:38:42 <parcs`> so the two ways are (a -> Bool) and (a -> Bool)
20:39:14 <elemir> No, (== x) and (/= x)
20:39:24 <kallisti> >_>
20:39:38 <parcs`> their types are the same, and one can be defined in terms of the othe
20:40:03 <elemir> So you can proof '(a -> Bool) -> b' from 'Eq a => a -> b'
20:40:08 <elemir> *cannot
20:40:38 <elemir> And hoogle shouldn't convert unproofable shit
20:41:26 <parcs`> you are describing the value-level difference between == and /=
20:41:41 <nand`> ddfisher: now I'm getting some interesting results. Although it compiles fine, I get “/usr/lib64/ghc-7.4.1/ghc-prim-0.2.0.0/libHSghc-prim-0.2.0.0-ghc7.4.1.so: undefined symbol: stg_newByteArrayzh” when trying to load the plugin in weechat
20:42:33 <elemir> Type-level should be used only for proofable things
20:43:14 <parcs`> -_-
20:43:18 <parcs`> good night
20:44:02 <elemir> > night
20:44:03 <lambdabot>   Not in scope: `night'
20:44:19 <elemir> lambdabot: stupid unIRCable bot
20:44:53 <elemir> @localtime
20:44:55 <ddfisher> nand`: yikes
20:44:56 <lambdabot> Local time for elemir is Wed Apr 11 07:44:31 2012
20:45:16 <nand`> ddfisher: and this sums up why I hate working with languages other than Haskell :)
20:45:29 <ddfisher> nand`: Haha. What do the files look like now?
20:46:49 <kallisti> nand`: I had problems similar to this, and I believe the solution was to manually reference some shared library via -I
20:47:08 <nand`> http://paste.pocoo.org/show/579312/ <- should contain relevant info
20:47:08 <ddfisher> nand`: -package may also help
20:49:12 <kallisti> nand`: try using -make and see what happens
20:49:47 <nand`> kallisti: as in, just append --make to the latter invocation of ghc? same error
20:53:01 <kallisti> nand`: try adding -I/path/to/libHSbase-2.5.0.0-ghc7.4.1.so
20:53:21 <kallisti> -shrug- I remember doing something equally silly when I had a very similar error and it kind of just worked.
20:53:39 <nand`> kallisti: “/path/to” ?
20:53:43 <kallisti> yes
20:54:55 <nand`> I don't seem to have that file in /usr; just /usr/lib64/ghc-7.4.1/base-4.5.0.0/libHSbase-4.5.0.0-ghc7.4.1.so; it may still be in /lib
20:55:08 <kallisti> nand`: should be like /usr/lib/ghc/omething
20:55:12 <nand`> Nope, isn't in /lib either
20:55:57 <kallisti> oh well
20:56:02 <nand`> there's /usr/lib/ghc-7.4.1/libHSrts-ghc7.4.1.so but nothing about HSbase
20:56:03 <kallisti> you want base 4.5 linked apparently
20:56:10 <nand`> I'll try that
20:56:33 <kallisti> oh nevermind the path is right there in ldd
20:56:43 <kallisti> /usr/lib64/ghc-7.4.1/base-4.5.0.0/libHSbase-4.5.0.0-ghc7.4.1.so
20:57:55 <lilcyber> Hey
20:58:03 <kallisti> hello
20:58:21 <lilcyber> Why is Haskell called the lazy language?
20:58:40 <kallisti> is that a setup for a joke? :P
20:58:50 <lilcyber> No, it's not.
20:59:03 <kallisti> I've never heard it referred to in such a way, but it is lazily evaluated, which is what is meant by "lazy"
20:59:07 <nand`> kallisti: -I expects a directory; did you mean -l?
20:59:18 <kallisti> nand`: no I meant -I/usr/lib64/ghc-7.4.1/base-4.5.0.0/libHSbase-4.5.0.0-ghc7.4.1.so
20:59:31 <nand`> kallisti: that fails “not a directory”
20:59:36 <lilcyber> kallisti: Ah I see.
20:59:52 <kallisti> nand`: that was the output from ldd so.... -shrug-
21:00:08 <kallisti> just do a find
21:00:33 <nand`> kallisti: the file exists
21:00:36 <nand`> but it's not a directory
21:00:42 <ddfisher> nand`: it's worth trying -l
21:00:43 <kallisti> oh... maybe I did mean -i
21:00:47 <kallisti> oh that's what it was
21:01:26 <kallisti> yes I used -L but maybe -l would work as well.
21:01:45 <kallisti> -lHSbase  then try -L<path>
21:02:05 <kallisti> nand`: I had similar errors compiling with similar options when writing a plugin for a C IRC bot.
21:02:16 <kallisti> and linking one of those libraries manually fixed it.
21:02:52 <kallisti> and I think HSbase probably contains the ByteArray# stuff, which is the symbol that was missing in the error output.
21:04:20 <nand`> managed to get it to compile; with -L/usr/lib64/ghc-7.4.1/base-4.5.0.0 -lHSbase-4.5.0.0-ghc7.4.1; same error
21:06:39 <nand`> ah, that got me set on the right track though
21:06:47 <nand`> I can manually -L and -l the libraries listed in the error
21:07:15 <kallisti> that does no good because you're already linking those.
21:07:24 <kallisti> nand`: did you use /both/ options? you only want one or the other.
21:07:31 <nand`> kallisti: the error message changes though
21:07:42 <nand`> what do you mean by “both options”? both -L and -l?
21:07:49 <kallisti> yes
21:08:14 <nand`> yes, here's my full command line
21:08:26 <kallisti> use just the one that works..
21:08:31 <kallisti> I don't think the -l one will work
21:08:33 <nand`> http://paste.pocoo.org/show/579319/
21:09:24 <nand`> the error I'm getting from the output of that is: /usr/lib64/ghc-7.4.1/base-4.5.0.0/libHSbase-4.5.0.0-ghc7.4.1.so: undefined symbol: stg_getMaskingStatezh
21:11:42 <nand`> if I omit the -l (keeping just the -L) I'm back to the first error (stg_newByteArrayzh in libHSghc-prim-0.2.0.0-ghc7.4.1.so)
21:17:22 <nand`> interestingly enough, the only search result I seem to be pulling up for stg_getMaskingStatezh is one to GHC's linker.c source code, not very helpful here
21:17:30 <nand`> seems nobody else has gotten this error message (and written about it online) before
21:25:50 <nand`> The problem is definitely not on weechat's side; if I comment out the hs_init stuff and compile weehaskell.c manually (with clang -c weehaskell.c && ld -shared weehaskell.o) I can load the plugin fine
21:25:58 <nand`> maybe I'll have better success by doing all of the linking manually
21:29:22 <gienah> nand`: I wasn't really paying attention, but I wonder if you need: #ifdef __GLASGOW_HASKELL__
21:29:37 <gienah> hs_add_root(__stginit_Semantic);
21:29:39 <gienah> #endif
21:29:59 <nand`> gienah: I don't see how that would help linking
21:30:00 <gienah> where Semantic is changed to something more relevant to your linker error
21:30:05 <nand`> but I could try it
21:30:19 <gienah> nand`: you could try it
21:31:04 <nand`> same error
21:31:57 <gienah> nand`: you need to use the right name after the __stginit
21:32:02 * hackagebot mathgenealogy 0.0.2 - Discover your (academic) ancestors!  http://hackage.haskell.org/package/mathgenealogy-0.0.2 (PeterRobinson)
21:32:09 <lispy> oh neat
21:33:00 <nand`> gienah: what __stginit?
21:33:49 <blah_> @pl \f g x y -> f (g x) (g y)
21:33:49 <lambdabot> join . ((flip . ((.) .)) .) . (.)
21:34:05 <gienah> nand`: am I guessing right that you are calling Haskell from a C program with main in the C program?
21:34:11 <blah_> @djinn @pl \f g x y -> f (g x) (g y)
21:34:11 <lambdabot> Cannot parse command
21:34:15 <nand`> gienah: no
21:34:22 <blah_> @djinn \f g x y -> f (g x) (g y)
21:34:22 <lambdabot> Cannot parse command
21:34:30 <blah_> @djinn f (g x) (g y)
21:34:30 <lambdabot> -- f cannot be realized.
21:34:47 <nand`> gienah: I am calling Haskell from within a C library that will itself be called from main in a different C program
21:35:13 <blah_> anyone have a pretty way to write f (g x) (g y)
21:35:13 <nand`> main.c -> weehaskell.c -> WeeHaskell.hs
21:35:24 <Orclev_> I'm looking for a good library to perform updates on data structures... lenses seem to be the traditional solution, but I'm also looking at fclabels... anyone have any experience that could recommend one vs. the other?
21:36:08 <nand`> @pl \x y -> f (g x) (g y)
21:36:08 <lambdabot> (. g) . f . g
21:37:13 <elliott> Orclev_: "lenses" the library is not popular
21:37:20 <blah_> @djinn  (t1 -> t1 -> t) -> (t2 -> t1) -> t2 -> t2 -> t
21:37:20 <lambdabot> f a b c _ = a (b c) (b c)
21:37:21 <elliott> the popular ones are data-lens and fclabels
21:37:25 <elliott> I prefer the former; YMMV
21:37:30 <elliott> see also http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
21:38:21 <gienah> nand`: I'm searching for that symbol to try and see which library it is in
21:38:38 <nand`> gienah: if you want to play around with the source directly; http://ompldr.org/vZGMzYw/weehaskell.tar.gz
21:40:17 <Orclev_> elliott: thanks for the link, looking through all that right now and it looks like exactly what I was looking for
21:40:46 <Orclev_> elliott: I had actually searched stackoverflow for [haskell] lens but hadn't found that post yet
21:41:00 <elliott> it's a bit of an old post though
21:41:11 <elliott> only data-lens and fclabels have the traction nowadays
21:41:23 <elliott> (and fclabels has changed internal representation drastically)
21:43:36 <Orclev_> elliott: I'm not really concerned about the internals so much, just so long as it's easy to work with, and performance doesn't completely suck
21:44:22 <Orclev_> elliott: I'm just looking for something cleaner than: blah a@Foo { bar = b } = a { bar = b + 1 }
21:44:43 * elliott recommends data-lens, then
21:44:44 <hayashi> @pl \f g a b -> f a (g b)
21:44:45 <lambdabot> flip . ((.) .)
21:44:48 <elliott> simple and fast
21:44:49 <dibblego> data-lens
21:44:55 <elliott> blah = modL bar (+1)
21:45:14 <dibblego> succL bar -- missing?
21:45:53 <gienah> nand`: stg_getMaskingStatezh seems to be defined in integer-gmp-0.4.0.0/libHSinteger-gmp-0.4.0.0-ghc7.4.1.so
21:46:29 <nand`> gienah: I'll give it a try
21:46:29 <gienah> nand`: so of course you can try adding library to your link line
21:47:18 <elliott> dibblego: not every composition of functions must be predefined! :)
21:47:31 <dibblego> oh I was hoping to write every program ever
21:47:44 <gienah> nand`: so to find that, I did: cd /usr/lib64/ghc-7.4.1; for i in **/*.so; do; echo $i; readelf -s $i | grep stg_getMaskingStatezh; done
21:48:00 <nand`> gienah: I'm already pulling in libHSinteger-gmp
21:48:05 <nand`> but still getting that error
21:48:28 <elliott> dibblego: someone did that once
21:48:36 <dibblego> oh can I download it?
21:48:37 <elliott> dibblego: the resulting natural disaster was nicknamed "category-extras"
21:48:42 <dibblego> haha
21:48:54 <elliott> unfortunately it exploded
21:48:55 <dibblego> still, succL and predL are probably worth it
21:49:14 <nand`> I managed to get the library to compile with “ghc --make -no-hs-main -dynamic -shared -fPIC -optl '-shared' -optc '-DMODULE=WeeHaskell' -o weehaskell.so WeeHaskell.hs weehaskell.c -optl-Wl -lHSrts-ghc7.4.1” <- but weechat crashed instantly with a stack trace when I tried to load the plugin
21:49:29 * elliott sees nothing wrong with (modL foo succ) or (foo ^%= succ)
21:49:42 <elliott> anyway, succ and pred are rubbish at overflow :(
21:49:50 <dibblego> yeah just remembered that
21:49:52 <shachaf> (foo ^%$&#&&$*!!= succ)
21:49:59 <nand`> @quote mappend.operator
21:50:00 <lambdabot> elliott says: |\/|/-\|-|-|=|\||} is my preferred mappend operator
21:50:07 <elliott> shachaf: i've pleaded with roconnor to ditch the infix operators!!
21:50:16 <elliott> you can't blame me!
21:50:24 <shachaf> Wait, roconnor is maintaining data-lens?
21:50:33 <dibblego> roconnor and I
21:50:38 <shachaf> Ah.
21:50:42 <shachaf> Could be worse.
21:50:44 <shachaf> Could be elliott.
21:50:50 <elliott> dibblego: btw, data-lens-fd is currently depending on the wrong version of data-lens
21:50:50 <shachaf> Then we wouldn't have any infix operators.
21:50:59 <dibblego> wtf is data-lens-fd?
21:51:08 <elliott> dibblego: mtl+MonadState support
21:51:09 -ChanServ(ChanServ@services.)- glguy set flags -b on *!*@adsl-68-125-54-81.dsl.pltn13.pacbell.net.
21:51:11 <elliott> provides the Data.Lens module
21:51:17 <dibblego> ok, I knew nothing of that
21:51:22 <elliott> i think it's what you're meant to use
21:51:25 <elliott> if you're not a haskell 98 fanatic :)
21:51:39 <elliott> ...same goes for data-lens-template, but i guess that might require more work to support partial lenses etc.
21:52:02 * shachaf much prefers Haskell0x.
21:52:05 <gienah> nand`: so tried to reproduce the error, I'm missing a header file: fatal error: /usr/include/weechat/weechat-plugin.h: No such file or directory
21:52:08 -ChanServ(ChanServ@services.)- glguy removed *!*@adsl-68-127-209-207.dsl.pltn13.pacbell.net from the AKICK list.
21:52:14 * elliott wonders wtf data-lens-fd depends on comonad-transformers for
21:52:23 <elliott> oh, for Store
21:52:26 <nand`> gienah: you'd need weechat installed to reproduce it either way; do you have weechat?
21:52:28 -ChanServ(ChanServ@services.)- glguy removed *!*@pool-71-109-50-108.lsanca.dsl-w.verizon.net from the AKICK list.
21:52:50 -ChanServ(ChanServ@services.)- glguy removed *!*@adsl-68-121-148-82.dsl.pltn13.pacbell.net from the AKICK list.
21:53:04 * BMeph likes HaskelCreamCheese... ;þ
21:53:21 <Guest81312> hi
21:53:24 <gienah> nand`: no, running emerge weechat
21:53:25 -ChanServ(ChanServ@services.)- glguy removed *!*@pool-71-109-189-52.lsanca.dsl-w.verizon.net from the AKICK list.
21:53:55 <gienah> nand`: so I'll have weechat installed soon
21:53:58 <Guest81312> i am very eager to learn haskel can please any one quide me
21:54:03 <Guest81312> guide*
21:54:38 <gienah> nand`: I ran ./build # no errors, built fine :-/
21:54:57 <nand`> gienah: right; when you do, to repro, run ./build in my folder and then /plugin load /path/to/weehaskell/weehaskell.so
21:55:00 <nand`> gienah: it builds fine
21:55:04 <nand`> gienah: it just errors when trying to load
21:55:13 <hayashi> @pl \f g h x -> f (g x) (h x)
21:55:14 <lambdabot> liftM2
21:56:21 <nand`> gienah: you should be getting something like: Error: unable to load plugin "/home/nand/dev/haskell/weehaskell/weehaskell.so": /usr/lib64/ghc-7.4.1/base-4.5.0.0/libHSbase-4.5.0.0-ghc7.4.1.so: undefined symbol: stg_getMaskingStatezh
21:56:29 <gienah> nand`: right, but to debug those type of errors the thing to do is run: ldd -r weehaskell.so
21:57:07 <gienah> nand`: then: scanelf -n weehaskell.so
21:57:37 <nand`> gienah: here's the output of the former: http://paste.pocoo.org/show/579329/
21:57:45 <gienah> nand`: and then try to figure out which NEEDED libraries you need to add to make the ldd -r run without missing symbols
21:57:49 <nand`> and the latter: http://paste.pocoo.org/show/579330/
21:58:35 <nand`> gienah: you confirmed stg_getMaskingSTatez was in libHSinteger-gmp-0.4.0.0-ghc7.4.1.so, right? which is shown in the output of ldd -r
21:58:38 <nand`> that's what confuses me
21:58:49 <nand`> it's clearly linked against the libHSinteger but still can't find the symbol
22:00:40 -ChanServ(ChanServ@services.)- glguy removed *!*@adsl-68-127-29-90.dsl.pltn13.pacbell.net from the AKICK list.
22:00:54 -ChanServ(ChanServ@services.)- glguy removed *!*@pool-71-105-96-215.lsanca.dsl-w.verizon.net from the AKICK list.
22:01:34 -ChanServ(ChanServ@services.)- glguy removed *!*@78-1-20-229.adsl.net.t-com.hr from the AKICK list.
22:02:34 -ChanServ(ChanServ@services.)- glguy removed *!*@193.216.161.248 from the AKICK list.
22:02:35 <nand`> all this dynamic linking issue has got me wondering
22:02:40 <nand`> why can't I simply build a static library
22:04:30 <elliott> because you can't dlopen those
22:04:42 <nand`> oh, shame
22:04:54 <hayashi> @pl \f g h i a b -> f g h ( i a b )
22:04:54 <lambdabot> ((((.) . (.)) .) .)
22:05:01 <hayashi> o_O
22:05:11 -ChanServ(ChanServ@services.)- glguy removed *!n=palomer@* from the AKICK list.
22:05:18 -ChanServ(ChanServ@services.)- glguy removed *!*=fefe@* from the AKICK list.
22:05:24 -ChanServ(ChanServ@services.)- glguy removed *!n=gschuett@* from the AKICK list.
22:05:24 <Orclev_> is there a way to do the equivalent of cabal configure && cabal build using just a single cabal invocation?
22:05:27 <hayashi> I'll pass on that one
22:06:55 <nand`> hmm
22:07:10 -ChanServ(ChanServ@services.)- glguy removed *!n=lehka@* from the AKICK list.
22:07:31 -ChanServ(ChanServ@services.)- glguy removed *!*@bas3-montreal02-1096681481.dsl.bell.ca from the AKICK list.
22:07:40 -ChanServ(ChanServ@services.)- glguy removed *!*@c-24-6-97-120.hsd1.ca.comcast.net from the AKICK list.
22:07:41 <nand`> seeing as it's pretty much impossible to write my shared library in Haskell itself, how easy would it be, for somebody with zero C knowledge, to invoke GHC to compile and run some .hs files from within C?
22:08:00 <nand`> Actually that might be trivial if I just shell call “runhaskell Foo.hs” and communicate via STDIN/STDOUT
22:08:05 <hayashi> hmm
22:08:11 <nand`> yes I think that'll be easiest
22:08:14 <elliott> Orclev_: "cabal-dev install" ;)
22:08:22 <hayashi> @pl \f g a b -> f ( g a b )
22:08:22 <lambdabot> (.) . (.)
22:08:27 <elliott> nand`: it's not pretty much impossible
22:08:31 <elliott> plenty of people manage it ;)
22:08:36 <elliott> ask about your linker errors on SO??
22:08:59 <nand`> elliott: doesn't that require an account?
22:09:13 <hayashi> d'oh, of course that would be that ._.  I'm going to be able to detect and derive these by hand one of these decades.
22:09:19 -ChanServ(ChanServ@services.)- glguy removed *!*@AVelizy-153-1-56-37.w86-205.abo.wanadoo.fr from the AKICK list.
22:09:37 <elliott> nand`: just an openid login
22:09:50 <elliott> answering questions doesn't, but that doesn't help you much ;)
22:10:04 -ChanServ(ChanServ@services.)- glguy removed *!*@80.80.168.71 from the AKICK list.
22:10:30 -ChanServ(ChanServ@services.)- glguy removed *!*@69.106.58.193 from the AKICK list.
22:10:36 <nand`> I don't think I have an OpenID login
22:11:25 <elliott> do you have a google, yahoo, facebook or wordpress account?
22:11:37 <blah_> hayashi: was that regarding my q?  i don't grok the connection yet...
22:11:40 <nand`> elliott: no
22:11:47 <elliott> i don't believe you :)
22:12:11 <nand`> elliott: I'm quite sure I have neither of those
22:12:19 -ChanServ(ChanServ@services.)- glguy removed *!*@66.0.46.210 from the AKICK list.
22:12:34 <hayashi> blah_: nope, sorry, I was just messing around with pl and mumbling to myself =/
22:12:36 <elliott> they have a non-openid signup form, anyway -- i only suggested it since nobody online right now seems to know and I've seen several FFI questions get answered there before
22:13:18 <nand`> elliott: I'll take it into consideration; but I'm hesitant to create an account anywhere. I'll see if I can come up with an alternative solution first, but thanks
22:13:31 <gienah> nand`: the procedure I gave to solve the problem was correct, I just mis-read which library the symbol was in, it is actually defined in libHSrts-ghc7.4.1.so or there are some others that it is also defined in
22:13:58 <nand`> gienah: I see
22:14:06 <gienah> nand`: so after finding the correct library it was in, I change the link line to:
22:14:17 <gienah> ghc -dynamic -shared -fPIC weehaskell.c WeeHaskell.o -o weehaskell.so --make -L/usr/lib64/ghc-7.4.1/base-4.5.0.0/ -L/usr/lib64/ghc-7.4.1/ghc-prim-0.2.0.0 -lHSghc-prim-0.2.0.0-ghc7.4.1 -lHSbase-4.5.0.0-ghc7.4.1 -L/usr/lib64/ghc-7.4.1/integer-gmp-0.4.0.0 -lHSinteger-gmp-0.4.0.0-ghc7.4.1 -L/usr/lib64/ghc-7.4.1 -lHSrts-ghc7.4.1
22:14:30 <Orclev_> elliott: slight wrinkle, I've got a local library installed that isn't on hackage, when I cabal-dev install it complains it can't find it, any idea how to work around that?
22:14:41 <gienah> and then the: scanelf -n weehaskell.so
22:14:48 <elliott> Orclev_: cabal-dev add-source /path/to/lib
22:14:51 <elliott> nand`: you have an account here :)
22:15:10 <elliott> there are services offering throwaway openids fwiw
22:15:22 <nand`> elliott: that sounds interesting, I'll look them up
22:15:25 <Veinor> what's the best way to turn a UTCTime value into a String?
22:15:27 <gienah> nand`: shows it has one more NEEDED library (showing the link line had some effect), and the ldd -r has less errors (but still needs more libraries)
22:16:29 <nand`> gienah: if I add libHSrts-ghc7.4.1.so my ldd -r comes out with zero errors
22:16:51 <gienah> nand`: yeah I was just noticing that :]
22:16:54 <nand`> gienah: which is a marked improvement, now I just need to figure out how to load it without weechat crashing instantly :)
22:17:32 <gienah> nand`: ok, will let you figure that out (me has to go do other stuff) :-)
22:17:42 <yqq> hi all, I recently found Clojure to be also an intriguing language. But I couldn't find an in-depth comparison of haskell vs Clojure. So pointers to such articles are greatly appreciated!
22:17:42 <nand`> gienah: thanks for the assistance
22:17:55 <gienah> nand`: no worries
22:18:04 <Orclev_> oh god what have I done... now it's complaining about mtl and transformers... last time I ran into something like this I had to nuke my entire ghc install and start from scratch to full eliminate the problems
22:19:08 <elliott> Orclev_: with cabal-dev install it installs all the dependencies in a sandbox from scratch
22:19:13 <elliott> so it can't break anything
22:21:59 <ceasarbautista> Can someone help me understand why I'm unable to compile a sort of 'generic type'? Particularly the line "data DFA a b = DFA [a] [b] (a -> b -> a) a [a]" is giving me trouble.
22:22:14 <ceasarbautista> Err, "data DFA = DFA [a] [b] (a -> b -> a) a [a]"
22:22:46 <augur> anyone know of any type systems with a sort of dual to function types? so what im thinking is something where like, you have an inference rule like   f : X  x : X ~> Y  =>  fx : X
22:22:59 <ivanm> ceasarbautista: you either need a and b on the LHS, or to use a forall on the RHS
22:23:14 <augur> or where you have something intermediate like   f : X -> Y   x : X ~> Z  => fx : Y
22:23:38 <monochrom> you should just use "data DFA a b = ... the rest"
22:24:57 <ivanm> make that _two_ foralls
22:25:17 <ceasarbautista> ivanm: Ah, wasn't even aware that was a thing.
22:25:34 <ivanm> well, you shouldn't use it
22:25:47 <ivanm> for your case, it appears you really should have data DFA a b = ...
22:25:57 <ceasarbautista> Yeah, taking a look monochrome's suggestion is more sensible.
22:26:04 <elliott_> augur: (~>) = flip (->)
22:26:18 <ceasarbautista> For some reason I read that and interpreted it as 'a' and 'b' being instances, rather than types.
22:26:46 <Orclev_> is there a way to get cabal to spit out which package is responsible for which dependency? I tried with -v3 and that provides a lot, but not who is requiring what specifically
22:26:53 <augur> elliott_: except in the first example, at least, that means x : Y -> X, and it's certainly not true that   f : X  x : Y -> X  =>  fx : X
22:29:42 <hayashi> @pl \f a -> (f a, a)
22:29:42 <lambdabot> ((,) =<<)
22:30:26 <Orclev_> is mtl one of those that's part of the core ghc libraries, or is it safe to install newer versions?
22:31:06 <hayashi> well, that's me learning a valuable life lesson: , is an infix operator, of course it can be used as a function to make tuples
22:31:24 <monochrom> mtl doesn't come with ghc. it is less problematic to have multiple versions. just less problematic
22:34:42 <ClaudiusMaximus> aarg, my implementation of  race :: [IO a] -> IO a  doesn't work for the particular case I want it to work for, presumably because one of the actions gets into a tight loop that doesn't allocate :(
22:35:47 <shachaf> mzero: I didn't get any email about the venue change, for what it's worth.
22:35:54 <shachaf> (I did find out about it, but independently.)
22:36:03 <mzero> that's worth alot
22:36:28 <shachaf> (I did get your most recent email, but I assume you were referring to an earlier one.)
22:37:33 <mzero> hmmm... I'm looking at the info in mail - and see your e-mail listed in the giant bcc list.
22:37:49 <shachaf> What was the subject?
22:38:00 <mzero> "BayHac '12 - Important Details" should was sent on April 5th
22:38:12 <shachaf> The new email, by the way, isn't using a bcc list at all, apparently.
22:38:20 <shachaf> At least I see a bunch of addresses that it was sent to.
22:38:36 <mzero> yes, I just realized I screwed that up
22:38:38 <mzero> d'oh
22:38:41 <shachaf> mzero: Gmail marked it spam. :-(
22:38:44 <hayashi> @pl \f (a,b) -> (f a, b)
22:38:45 <lambdabot> (`ap` snd) . (. fst) . ((,) .)
22:38:47 <shachaf> I trust their filter too much.
22:39:00 <shachaf> "Why is this message in Spam? It's similar to messages that were detected by our spam filters."
22:39:27 <mzero> :t second
22:39:28 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
22:39:37 <mzero> :t first
22:39:38 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
22:39:46 <shachaf> mzero: OK, good to hear.
22:40:11 <shachaf> mzero: Am I listed as being able to go on Friday?
22:40:12 <mzero> > first (+10) (7, "hi")
22:40:13 <lambdabot>   (17,"hi")
22:40:44 <mzero> shachaf: yes
22:41:09 <mzero> hayashi: first and second are in Control.Arrow and are very nice
22:41:55 <mzero> see also conal's blog post on semantic editors: http://conal.net/blog/posts/semantic-editor-combinators
22:42:00 <hayashi> hmm, I still haven't go to the point where I know what an arrow is >_<
22:42:34 <mzero> actually, nor do I, hayashi -- but  the type   a -> b   is  an   Arrow a b
22:42:51 --- mode: ChanServ set +o glguy
22:42:53 --- mode: glguy set -bo *!~PenisSujo@201.170.67.45.dsl.dyn.telnor.net glguy
22:42:54 <Orclev_> this is probably wrong in several very important aspects, but at its core an arrow is just a function with one argument
22:43:11 <mzero> and so the Arrow combintors work with functions, transforming functions into other useful functions
22:43:36 <hayashi> I'm still letting the idea of a -> b being a monad that lambdabot hit me over the head with a few minutes ago slowly sink in =P
22:43:55 <Orclev_> wait, what?
22:44:12 <mzero> see conal's post to learn a nice way to understand first and second in the context you're trying to use 'em
22:44:16 <conal> like Functor, Applicative, Monad, etc, Arrow is not anything concrete. rather, it's a family of binary type constructors that have a common subset of operations & axioms. (->) is one example of an arrow.
22:44:23 <shachaf> glguy: Are you sure it's a good idea to ban that person?
22:44:33 <mzero> oh - speak of the devil! hi conal!
22:44:51 <shachaf> glguy: They've spammed #haskell with links to images that I was advised not to click on twice in the last few days.
22:45:03 <conal> and if you're using first & second just for functions, you needn't think about the fact that they're associated with the more general abstraction.
22:45:14 <conal> s/the more/a more/
22:45:26 <conal> mzero: hi :)
22:45:40 <augur> conal! :o
22:45:42 <augur> hey you
22:45:53 <conal> augur: hi
22:46:01 <augur> sup dudedede
22:47:05 <Orclev_> I'm trying to run cabal sdist on my project and it keeps complaining the sdist doesn't exist... I thought that was the point of the sdist command, to package up the source, or am I'm really confused here?
22:48:00 <ivanm> Orclev_: did you run "cabal configure" first?
22:48:07 <Orclev_> ivanm: yeah
22:48:21 <ivanm> huh
22:48:40 <ivanm> Orclev_: WORKSFORME
22:49:35 <mzero> Orclev_: can you put the actual output of 'cabal sdist' on hpaste for us to see?
22:50:05 <zzo38> If they fixed the instances for Free and Cofree like I said then you can have. The constant functor ConstM (like Constant but with MonadPlus), can make many things. The codensity monad of that becomes continuations; the free monad becomes Either; the free comonad becomes Writer.
22:50:46 <hpaste> Orclev_ pasted “cabal sdist output” at http://hpaste.org/66796
22:50:50 <nexion> what library should I use to parse HTTP requests? I'm not looking for a complete webserver, just something I can feed an HTTP request to and extract its parameters (or fail gracefully if the request is incomplete)
22:52:06 <Orclev_> cabal configure and cabal install work perfectly fine though
22:52:10 <mzero> Orclev_: I think the error (lines 1 - 4) is probably causing the later part of the sdist proecess to fail
22:52:17 <ivanm> Orclev_: "ghc-pkg check" ?
22:52:38 <mzero> add the indicated cabal-version: >= 1.4 directive
22:52:46 <ivanm> which OS ?
22:53:20 <Orclev_> adding the cabal version removed the version warning, but still get the same error at the end
22:53:25 <glguy> shachaf (or anyone else): join #haskell-ops if you have ban questions
22:53:39 <shachaf> glguy: Ah, OK.
22:53:55 <Orclev_> ivanm: if you're talking to me, Linux, arch specifically
22:54:35 <ivanm> version of GHC?
22:54:47 <Orclev_> ivanm: 7.4.1
22:55:10 <Orclev_> cabal-install 0.10.4, 1.14.0 of Cabal library
22:55:20 <ivanm> so you built it with an earlier GHC?
22:55:35 <hayashi> mzero, conal_: wow, Haskell never fails to blow my mind.  Thanks, though I'll probably not understand the theory behind this for a long while~
22:55:44 <Orclev_> ivanm: I'm not sure I follow, built what?
22:56:12 <ivanm> cabal-install
22:56:21 <Orclev_> ivanm: no, I don't think so
22:56:25 <ivanm> IIRC you can't build 0.10.4 on 7.4.1
22:56:29 <ivanm> huh
22:57:45 <Orclev_> ivanm: I'm using the arch build of ghc and cabal-install, might it be a platform packaging bug?
22:59:39 <hayashi> I was wondering why the only place I could find a function (a->b) -> (a, c) -> (b, c) was in an obscure library; I didn't realise that that's exactly first being used on ->
23:00:09 <Orclev_> ivanm: I notice it yells at me for not having a source-repository section, does that matter? I assumed it would just package up the sources in the hs-source-dirs
23:00:53 <zzo38> hayashi: Yes it is. And then you can use *** and &&& and ||| and +++ too, which I sometimes do and you might find useful too
23:02:43 <ivanm> Orclev_: that's for upstream repos (git, darcs, etc.)
23:03:06 <ivanm> hayashi: or you can use the Arrow function instance
23:03:19 <ivanm> oh, right, you spotted that
23:04:38 <Orclev_> hmm, according to my cabal, 0.10.4 is the latest version of cabal-install
23:05:08 <zzo38> Yes, the Arrow and ArrowChoice and stuff for the (->) category can be used; arr is simply the identity functor from (->) to (->)
23:05:21 <hayashi> This whole idea of functions being types with instances and suchlike is a complete mindscrew to someone like me who's only just got into functional programming a few months ago =P
23:05:22 <hayashi> Woo
23:05:46 <Orclev_> hayashi: yeah, blew my mind too when I saw "instance Arrow (->) where"
23:06:01 <zzo38> hayashi: Well, (->) is a type with two parameters, like any other type are also other types, it is useful to
23:07:07 <ivanm> Orclev_: the source tarball for 7.4.1 includes a copy that builds with it
23:07:27 <Orclev_> so, I see cabal-install-ghc74 out there... how bad an idea do you think it would be to install that and see if that helps at all?
23:09:11 <ivanm> you could
23:09:19 <ivanm> or use a snapshot of HEAD
23:10:56 <NemesisD> i'm pretty sure i've stumbled into dependency hell again. i've got a bunch of erros at the end of installing saying some packages failed to install
23:11:04 <Orclev_> well, if the newly installed version works I'm going to go on the assumption it's a problem with the arch build of cabal-install and follow up in the arch channel
23:11:16 <NemesisD> is there any way to communicate that those should be installed again? this always destroys my productivity
23:11:53 <NemesisD> i always end up having to nuke my cabal dir and that means i have to wait forever to build everything in cabal again
23:12:56 <Orclev_> NemesisD: ghc-pkg check and if it finds problems you can ghc-pkg unregister the broken ones and re-install them
23:13:11 <Orclev_> you can also force a re-install with cabal
23:13:28 <Orclev_> depending on what's wrong it may or may not solve your problem
23:14:27 <Orclev_> sometimes it helps to install all the packages at the same time rather than individually, then if there's a dependency conflict cabal will complain about it right then instead of after you've already install 6 packages
23:16:48 <Enigmagic> ghc-pkg check --simple-output | xargs cabal install --solver=modular --force-reinstalls
23:17:16 <Enigmagic> tends to fix things if you have a recent-ish build of cabal-install
23:19:05 <Orclev_> ... so, doing runhaskell Setup.hs sdist succeeded
23:23:02 <Rmx> I'm looking for good material about problems with applicative vs monads. I would like better intuition about applicative/monads, which one to chose according to which situation.
23:23:57 <dropfatdiva> As a full fledged IDE for Haskell, is EclipseFP more mature featurewise or Leskah?
23:24:36 <zzo38> Rmx: All monads on (->) are applicative as well, so you can use both ways whichever is useful. Look at other program see what it does
23:25:29 <Rmx> I understand monads are applicative, but don't have clear vision and understanding of this little bonus they provide
23:25:39 <dibblego> they compose
23:25:50 <Rmx> I understand they provide a way to use the result of the computation to define the composition
23:25:58 <Rmx> applicative compose too, in a way..?
23:26:01 <dibblego> (Applicative f, Applicative g) => Compose f g
23:26:08 <dibblego> er
23:26:12 <dibblego> (Applicative f, Applicative g) => Applicative (Compose f g)
23:26:22 <dibblego> (Monad f, Monad g) => Monad (Compose f g) // not gunna happen
23:27:06 * hackagebot darcsden 0.5 - darcs project hosting and collaboration  http://hackage.haskell.org/package/darcsden-0.5 (AlexSuraci)
23:27:21 <mzero> dropfatdiva: not sure what you're after with "full fledged".... and I can't speak to EclipseFP, as I've never used it.... but Leksah makes for a nice environment to work in - I use it for my Haskell projects
23:27:30 <zzo38> Applicative lacks join, is one difference
23:27:43 <Rmx> zzo38, that's precisely my point
23:27:58 <Rmx> while able to use monads well, I got use to them all the time
23:28:02 <Rmx> and never use applicative
23:28:03 <zzo38> Just use them and learn how it is helpful that way
23:28:13 <zzo38> I use monad and applicative commonly
23:28:40 <Rmx> for instance, why do people use Maybe monad?
23:28:51 <Rmx> is this a nonsense? or do I lack in some understandings?
23:30:00 <zzo38> The Maybe monad is the monad having the possibility of holding a value or not holding a value. And then from the monad law it follows what it is you can see it hopefully.
23:30:07 <dropfatdiva> mzero: my concern is only to start with an editor that is feature-wise more mature. I guess its better to give both a shot and see for myself.
23:32:00 <zzo38> For example you might use the Maybe monad with guard
23:32:46 <zzo38> The Either monad is a monad that you can depend a new value from the old one (Right) until it is stopped and has a final value which won't change from more fmap/join/bind/etc (Left).
23:33:21 <mzero> Leksah's editor is pretty std - offers project sensitive completion (with types displayed!), you can easily navigate to compilation errors (the big win for me) (continuous compilation is an option), file and project-wide search, declaration search and hyper-linking.
23:33:32 <mzero> I can't speak to the debugger -- as I never ever use it
23:33:54 <zzo38> I wrote a program called dvi-processing which uses much of applicative and monad for IO, as well as some for Maybe and [] as well; but many people think it is difficult to read.
23:34:24 <mzero> no refactoring to speak of... but not a biggie for me
23:34:39 <augur> edwardk! :D
23:34:51 * edwardk hides
23:35:48 <augur> edwardk: you know of any type systems with something vaguely like a dual to a function type? eg where like...   f : X  +  x : X ~> Y  =  fx : X
23:35:48 <augur> ?
23:35:58 <augur> not necessarily that specifically, but something like that
23:36:12 <augur> where the "argument" has a requirement that the "function" satisfies
23:37:06 * hackagebot ssh 0.2.9 - A pure-Haskell SSH server library.  http://hackage.haskell.org/package/ssh-0.2.9 (AlexSuraci)
23:37:21 <edwardk> augur: you mean coexponentials?
23:37:23 <augur> but where the "argument" is not strictly an actual function, in that the resultant type is determined by the "function" thing f
23:37:26 <augur> edwardk: maybe!
23:37:42 <edwardk> well: coexponentials and exponentials don't coexist well
23:38:01 <zzo38> edwardk: If the intsances for Free and Cofree are changed to what I have suggested would the MonadPlus version of the constant functor make the things I have mentioned above?
23:38:02 <augur> ah. do they exist well, tho?
23:38:06 <augur> x3
23:38:08 <edwardk> if you have arbitrary exponentials and coexponentials you can show the category collapses to a poset, so there exists only one function between any two types =(
23:38:42 <edwardk> zzo38: i need to go back through and look at it, there was a reason for choosing the Applicative I chose for Comonad though
23:38:44 <Rmx> dropfatdiva, zzo38, ahhhhhh, sorry, but monad compositions give applicatives, and why ever should we use composition with monad when we have transformers ?
23:39:17 <augur> edwardk: in what sense?
23:39:30 <zzo38> edwardk: OK, I understand; still, there could be a wrapper to make the different instance for Comonad. Also, the Alternative and MonadPlus instances for Free are wrong
23:40:08 <augur> edwardk: well, actually, can you explain coexponentials to me briefly?
23:40:25 <zzo38> s/for Comonad/for Cofree/
23:40:29 <arossouw> whats the safest way to determine the amount of elements of list if the list is very big ( getting memory exhausted)
23:40:31 <edwardk> augur: look at categories. Control.Category.Cartesian.Closed
23:41:09 <zzo38> arossouw: Possibly, use something other than []
23:41:23 <arossouw> ok
23:41:34 <edwardk> i'll have to look at the free monad alternative. i recall it being slightly off, but its useful enough that i'm hesitant to remove it
23:41:48 <arossouw> zzo38: what are the alternatives?
23:41:58 <zzo38> edwardk: Well, it is wrong.
23:42:03 <zzo38> arossouw: Data.Sequence
23:42:10 <arossouw> great, thx
23:42:11 <augur> edwardk: i have no idea whats going on in this file
23:42:13 <edwardk> zzo38: can you email me with the violated law example?
23:42:14 <augur> what is this <= thing
23:42:35 <edwardk> zzo38: ekmett@gmail.com  -- or better yet open an issue on github on the free package?
23:42:37 <edwardk> http://hackage.haskell.org/packages/archive/categories/1.0/doc/html/Control-Category-Cartesian-Closed.html
23:42:40 <edwardk> go to the current version
23:42:44 <edwardk> which doesn't use infix
23:42:50 <edwardk> haddock sucks at infix types
23:43:16 <edwardk> coapply :: b `k` Sum k (Coexp k a b) a
23:43:23 <edwardk> cocurry :: (c `k` Sum k a b) -> Coexp k b c `k` a
23:43:29 <edwardk> uncocurry :: (Coexp k b c `k` a) -> c `k` Sum k a b
23:43:45 <edwardk> those are the key operations associated with coexponentials
23:44:00 <augur> i dont understand :(
23:44:16 <augur> can you tell me in normal CT? :P
23:44:33 <edwardk> compare to apply :: (a -> b, a) -> b, curry, and uncurry
23:44:41 <edwardk> this _is_ normal category theory =P
23:44:48 <augur> no this is haskell!
23:44:54 <zzo38> edwardk: I can do neither, but I can post the violation right here.   pure 5 = Pure 5    pure 5 <|> empty = Free (pure (Free 5) <|> pure empty)
23:44:54 <edwardk> to have arrows as objects we have exponentials
23:45:00 <augur> i mean real CT not haskell encodings
23:45:16 <edwardk> zzo38: ah, yes
23:45:17 <augur> which presuppose that i understand how CT is represented in haskell type classes
23:45:19 <augur> (i dont)
23:45:33 <augur> ive really never been able to grok it very well, im afraid
23:45:44 <edwardk> just think about Hask as a category with -> as an arrow or exponential
23:45:51 <NemesisD> heres a fun one: ghc-7.4.1 requires containers ==0.4.0.0 however containers-0.4.0.0 was excluded because ghc-7.4.1 requires containers ==0.4.2.1
23:46:19 <augur> no i get that, edwardk. but what on earth does, for instance, Sum k a b mean
23:46:31 <edwardk> zzo38: the main issue is i don't keep channel logs so sufficiently complicated worked examples that don't wind up in my inbox or issues list eventually get forgotten
23:46:43 <edwardk> Sum k is asking for the Either equivalent for the category k
23:46:52 <zzo38> Then send it to yourself on your email or Github
23:47:53 <edwardk> zzo38: i asked precisely because i was spread to thin at the moment to deal with it. nevermind
23:48:16 <augur> edwardk: i see... so for a co-CCC with sum operator +, coapply is a natural transformation forall X and Y, X -> X + (X <= Y)
23:48:19 <zzo38> edwardk: OK, but I don't have those things that is why I didn't do it
23:48:39 <zzo38> Is this instance correct?     empty = Free empty; Pure x <|> _ = Pure x; _ <|> Pure x = Pure x; Free x <|> Free y = Free (x <|> y);
23:49:14 <augur> right ok, that makes sense if a coexponential is the dual of an exponential
23:49:53 <edwardk> x -> (x - y) + y
23:50:02 <ClaudiusMaximus> my problem continues... i have a program that works when i intersperse my work with (threadDelay 1) but fails with (threadDelay 0) or (yield) -- failure takes the form of ^C in ghci doing nothing and second ^C giving back the prompt but leaving spinning threads in the background...
23:50:05 <augur> er, right, typo :p
23:50:19 <edwardk> zzo38: if you read Coexp like -, the types make sense when you think about it
23:50:32 <augur> so no, i dont think i mean a coexponential -- i just mean something that is like an expoential, in that the "functiony" bit determines the output type in such and such way
23:51:02 <augur> but that the "argumenty" bit's type is the thing that determines whether it can combine with the "functiony" bit
23:51:08 <edwardk> cocurry :: (c -> (a + b)) -> (c - b) -> a
23:51:40 <edwardk> oh, i have nothing
23:51:42 <augur> ok
23:52:16 <edwardk> zzo38: the fact that it uses the <|> only on Free is a bit awkward, since things with the same shape will just forget the right hand value using Pure
23:52:24 <edwardk> zzo38: i'd probably just cut the instance entirely
23:52:31 <zzo38> And OK if you have a good reason for using your zipping-based Applicative for Cofree; but perhaps there can still be another wrapper which mean using the Alternative-based Monad instance, let's called AltCofree. And then let's have ConstM like Constant but using <|> instead of <*> as the monoid lifted (which makes it a MonadPlus).
23:52:33 <edwardk> but I need to spend some time looking through the packages that use it
23:53:39 <BMeph> augur: Sounds like you're thinking about something like answer types, although they're something different.
23:54:08 <edwardk> Well, given that it only needs the semigroup structure it'd probably use Plus rather than Alternative, but thats not a big difference
23:54:09 <zzo38> Pretend that there is a Alternative and MonadPlus instances for Either (if the left type is a monoid); then, (Free (ConstM l) r) acts like (Either l r) with this instance
23:54:11 <augur> BMeph: tell me more
23:55:03 <BMeph> augur: They're more of a continuation description thing.
23:55:12 <augur> BMeph: tell me even more
23:55:12 <zzo38> Is this correct?
23:55:22 * BMeph pokes around in his "sin bin" for papers
23:55:42 <edwardk> zzo38: it appears so on the surface, though i haven't worked out the details
23:56:55 <zzo38> It also makes (AltCofree (ConstM x) y) like (Writer x y) and (Codensity (ConstM x) y) like (Cont x y)
23:58:04 <zzo38> And (AltCofree [] x) like (Tree x)
23:58:05 <BMeph> augur: Eh, I'm off to bed now, but poke around for stuff by Hayo Thielecke; if he isn't writing it, he's referring to it. :)
23:58:21 <edwardk> Codensity (Const r) a = Cont r a, not sure about the M there
23:58:34 <augur> BMeph: ok
23:58:46 <edwardk> guess it doesn't use the monoid either way
23:59:25 <zzo38> edwardk: Const and ConstM is same except that Constant lifts the monoid to <*> and ConstM lifts to <|> making it also a monad (but I cannot find the equivalent of ConstM in a library). But, yes, in this case it doesn't matter
