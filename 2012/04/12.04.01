00:31:36 <poliquin> Can some kind soul help me with Text.PrettyPrint .. I'm trying to print some test data in 'table' format and striking out.
00:31:40 <hpaste> poliquin pasted “Pretty Print Play” at http://hpaste.org/66309
00:32:35 <poliquin> Just pasted the code. Near the bottom I've included what I desire and what I'm getting.
00:33:16 <poliquin> I could write it by hand but I really wanted to understand PrettyPrint which so far I have failed at.
00:36:39 <JuanDaugherty> I haven't looked at your paste, but normally pretty printing is for code and stuff and you take the pkg that does it more or less as it is.
00:37:07 <JuanDaugherty> adjust code to it more often that it to code
00:37:43 <JuanDaugherty> as distinct from general output formatting such as data in a table
00:38:09 <poliquin> Thanks .. that's the kind of feedback I needed .. my ladder is up against the wrong wall :-)
00:39:11 <JuanDaugherty> np
00:54:01 <poliquin> JuanDaugherty, Just tried the 'boxes' packages and it worked great. Thanks again.
00:54:42 <poliquin> JuanDaugherty, s/packages/package/
00:54:50 <JuanDaugherty> :)
00:55:42 <edwardk> byorgey++ datakinds are awesome
01:01:03 <kallisti> so with DataKinds
01:01:05 <kallisti> the type of the ADT becomes a kind, and the constructors are types?
01:05:28 * hackagebot elerea 2.7.0.2 - A minimalistic FRP library  http://hackage.haskell.org/package/elerea-2.7.0.2 (GergelyPatai)
01:11:29 <kulin> Control.Concurrent is not a part of haskell2010? What should I use instead?
01:14:15 <kallisti> kulin: why is that important?
01:14:47 <kulin> i thought haskell2010 and base were exclusive in a project?
01:15:06 <Cale> Generally, use base
01:15:21 <kallisti> exclusive?
01:15:24 <kulin> what is haskell2010 then?
01:15:50 <kallisti> I believe it's the modules defined in the Haskell 2010 report
01:16:14 <Cale> Though, haskell2010 depends on base anyway
01:16:29 <Cale> So there's actually no problem with using it.
01:16:32 <kulin> oh ok, i thought it was what you were suppose to be using for new programs, as in base was slowly being factored out
01:16:47 <cheater> was it?
01:16:53 <kallisti> there's hardly anything available in haskell2010
01:16:55 <kallisti> so no.
01:16:57 <Cale> haskell2010 is just the modules which are standardised
01:17:06 <kulin> oh ok, great thanks all
01:17:20 <Cale> (but you need a lot more to get many real-world projects done)
01:17:40 <killerswan> the standard vs. each compiler's implementation, heh
01:17:48 <kallisti> yes, anything in hackage is fair game, if you're distributing your code via cabal.
01:17:57 <killerswan> what is the usage of non-GHC compilers, statistically?
01:18:05 <cheater> 0%
01:18:43 <Cale> They're used to experiment with feature and implementation ideas, basically.
01:18:43 <cheater> however, in an attempt not to paint ourselves into a corner by getting locked into a single compiler, we still pretend there are other compilers that are worth using
01:19:04 <Cale> (and yeah, keep the tools reasonably honest)
01:19:09 <kallisti> I think Hugs still sees use in education.
01:20:29 <kallisti> hm, can class constraints appear in kind signatures now that we have DataKinds and ConstraintKinds?
01:24:03 <Guest93757> ciao
01:24:15 <Guest93757> !
01:24:28 <Guest93757> !.
01:24:32 <Guest93757> .!
01:24:36 <Guest93757> !.
01:26:33 <wo0kie> Enya + Haskell somehow go wonderfully together
01:29:29 <kallisti>   HCons :: a -> HList t -> HList (a ': t)
01:29:34 <kallisti> what. where did this ': come from
01:31:38 <c_wraith> kallisti: part of the PolyKinds extension
01:31:54 <kallisti> oh I see
01:32:00 <kallisti> I thought it was showing how they were defined
01:32:03 <kallisti> not an example of their use.
01:33:02 <kallisti> interesting that there's only one tuple kind. :P
01:33:16 <kallisti> and not 100-something or however many n-tuples GHC defines.
01:33:27 <c_wraith> eh?
01:33:38 <kallisti> there appears to be only 2-tuples at the type level.
01:33:50 <c_wraith> (,) has the kind * -> * -> *.  (,,) has the kind * -> * -> * -> *
01:33:54 <c_wraith> @kind (,,)
01:33:55 <lambdabot> * -> * -> * -> *
01:34:13 <c_wraith> @kind (,,,,,,)
01:34:14 <kallisti> @kind (,,,)
01:34:14 <lambdabot> * -> * -> * -> * -> * -> * -> * -> *
01:34:15 <lambdabot> * -> * -> * -> * -> *
01:34:16 <kallisti> oh...
01:34:18 <kallisti> nevermind then.
01:34:25 <kallisti> GHCs documentation is very scant.
01:34:30 <kallisti> with the extensions
01:34:46 <c_wraith> most of the documentation is in the paper
01:36:35 <c_wraith> There's only one kind for *unboxed* tuples
01:36:55 <c_wraith> @kind (# 1, 2 #)
01:36:55 <lambdabot> Only unit numeric type pattern is valid
01:37:00 <c_wraith> err
01:37:06 <c_wraith> @kind (# Int, Int #)
01:37:07 <lambdabot> (#)
01:37:28 <kallisti> @kind (Int, Int)
01:37:29 <lambdabot> *
01:37:42 <kallisti> ...as would be expected?
01:37:46 <c_wraith> yep
01:38:48 <kallisti> @kind '(# Int, Int #)
01:38:49 <lambdabot>     lexical error in string/character literal at character '#'
01:39:37 <c_wraith> ghc's support for polykinds is incomplete
01:39:46 <c_wraith> You can't specify kind signatures involving them
01:39:54 <kallisti> unboxed tuple kind of would make no sense.
01:39:59 <c_wraith> that's also true
01:40:06 <kallisti> not (#)
01:40:07 <kallisti> that's fine I guess
01:40:16 <kallisti> I mean like a (# *, * #)
01:40:28 <c_wraith> types are strict, though
01:40:29 <kallisti> ...unboxed at the type level?
01:40:34 <c_wraith> so boxing doesn't make sense
01:40:37 <kallisti> right
01:40:59 <kallisti> at first I thought you were talking about a new unboxed tuple kind of that form.
01:41:43 <kallisti> @kind '[Int, Char, Bool]
01:41:44 <lambdabot>     lexical error in string/character literal at character 'I'
01:41:45 <kallisti> :P
01:42:37 <kallisti> when it first showed the HList example I thought I was supposed to be referring to HList as a promoted type.
01:42:54 <kallisti> the notational similarities can be highly confusing.
01:43:37 <kallisti> @kind 2
01:43:38 <lambdabot> Only unit numeric type pattern is valid
01:43:44 <c_wraith> 2 is a value, not a type
01:43:45 <kallisti> @kind True
01:43:46 <lambdabot> Not in scope: type constructor or class `True'
01:43:53 <c_wraith> ah, and yeah
01:43:53 <kallisti> I was testing to make sure I knew what @kind was doing.
01:44:06 <ferreal> @kind 1
01:44:07 <lambdabot> *
01:44:56 <kallisti> maybe I don't understand this extension. it looks as though arbitrary types are lifted to kinds automatically.
01:45:26 <kallisti> doesn't that mean that True is now a type with kind Bool?
01:46:35 <c_wraith> It means it can be interpreted that way
01:46:44 <c_wraith> that doesn't mean lambdabot has the extension enabled
01:46:48 <kallisti> ah okay.
01:47:01 <c_wraith> ask your local ghci
01:47:26 <c_wraith> But there are rough edges to the extension
01:47:34 <kallisti> I was confused because you seemed to be using DataKinds with @kind
01:47:37 <c_wraith> some thing work, but ghc doesn't have the tools to talk about them
01:47:50 <c_wraith> No..  remember, (,) is both the type and value constructor
01:47:53 <kallisti> as I mentioned the lack of type-level 3-tuples, 4-tuples, ...
01:48:07 <kallisti> right, yes.
01:48:50 <c_wraith> But there's nothing interesting about (,) as a type.
01:48:58 <c_wraith> or other tuples
01:49:07 <c_wraith> they just follow the exact same rules as anything else
01:50:23 <kallisti> I think I understand type families as well.
01:50:37 <kallisti> they essentially act as type-level functions, with instances being cases.
01:51:04 <c_wraith> yeah.  They're limited to pattern-matching as the only calculation
01:51:11 <c_wraith> But they are functions
01:52:44 <kallisti> c_wraith: can constraints be used in kind signatures?
01:52:48 <kallisti> that would be interesting.
01:53:05 <kallisti> kindclasses. :D
01:53:11 <c_wraith> I don't believe so, in the way you mean
01:53:32 <kallisti> yes I mean lifting types of kind Constraint to be kinds.
01:53:39 <kallisti> in the same way that types of kind * can be promoted.
01:54:03 <kallisti> with => notation in kind signatures
01:54:09 <c_wraith> yeah, that's not there
01:54:22 <kallisti> I wonder if that will happen.
01:55:03 <kallisti> I'm not even sure what you could do with such a thing.
01:55:55 <kallisti> I suppose instance kinds could define their own type family instances.
01:57:20 <kallisti> I'm interested to see how these type-level extensions pan out in the long-term.
02:16:05 <hpaste> cspollard pasted “reactive-0.11.5 Build Errors” at http://hpaste.org/66310
02:17:14 <gregATio> Im getting the error could not find module 'Text.Regex.Posix' how to fix?
02:18:36 <cspollard> Hi all, I'm having trouble installing reactive-0.11.5 under ghc 7.0.4. Type problems in Serial.hs (http://goo.gl/0X08M). Errors here: http://hpaste.org/66310
02:19:17 <cspollard> GHC is confused by (forall a. IO a -> IO a) vs (IO a -> IO a), but not sure what the fix is.
02:21:15 <Elemir> gregATio: Install regex-posix
02:21:29 <gregATio> thanks , that would be cabal install regex-posix?
02:22:10 <Elemir> Yes
02:22:15 <gregATio> thanks
02:24:48 <Cale> cspollard: Try just eliminating the type synonym and filling in the polymorphic types
02:25:19 <Cale> cspollard: Or maybe try adding LiberalTypeSynonyms?
02:25:32 <Cale> I'm not sure how important the ImpredicativeTypes thing is
02:25:51 <cspollard> Yeah, I don't really understand what's going on in those extensions.
02:26:12 <Cale> oh
02:26:12 <cspollard> I'm worried about getting rid of the type synonym since it is exported, but I'll give it a try
02:26:24 <Cale> makeSerial :: IO (forall a. IO a -> IO a)
02:26:32 <Cale> ^^ yeah, that's impredicative
02:26:40 <Cale> hmm
02:26:44 <Cale> I don't know
02:26:50 <cspollard> thanks for the help, btw
02:27:02 <Cale> There was a period in time where impredicative types were deprecated/unsupported
02:27:09 <Cale> I'm not sure if that's still true or not
02:27:35 <Cale> (simply because not so many people use them, and they're apparently hard to implement)
02:35:31 <cspollard> ok, the Serial type only showed up in a few places. Replaced it with (IO a -> IO a). The build makes it past those files now.
02:35:34 <cspollard> Thanks!
02:43:54 <reinoud> hi
02:44:01 <reinoud> i am trying to figure out what is wrong with:
02:44:05 <reinoud> -- Create the triangles from the list of vertices
02:44:05 <reinoud> split3 :: [ℝ3] -> [Triangle]
02:44:05 <reinoud> split3 [] = []
02:44:05 <reinoud> split3 [a:b:c:rest] = (a, b, c) : split3 rest
02:44:19 <reinoud> it complains about the last line :)
02:44:55 <reinoud> i thought i could specify a:b:c:rest as the 3 elements on top of the rest of the list?
02:45:16 <reinoud> Graphics/Implicit/Export/MarchingCubes.hs:796:9:
02:45:16 <reinoud>     Couldn't match expected type `(â, â, â)' with actual type `[t0]'
02:45:16 <reinoud>     In the pattern: a : b : c : rest
02:45:16 <reinoud>     In the pattern: [a : b : c : rest]
02:45:16 <reinoud>     In an equation for `split3':
02:45:16 <reinoud>         split3 [a : b : c : rest] = (a, b, c) : split3 rest
02:46:15 <shachaf> reinoud: You should probably @paste that many lines on hpaste.org instead of in the channel.
02:46:43 <shachaf> reinoud: In this case the issue is with your list pattern, which only matches a singleton list-of-lists.
02:47:01 <shachaf> reinoud: Compare: foo [] = ...; foo [x:xs] = ...
03:00:15 <free_beard> hi, can someone please share a copy of hutton's tutorial? cs.nott.ac.uk seems to be down for me
03:00:32 * hackagebot darcs-beta 2.7.99.1 - a distributed, interactive, smart revision control system  http://hackage.haskell.org/package/darcs-beta-2.7.99.1 (FlorentBecker)
03:01:32 <shachaf> free_beard: You mean of _Programming in Haskell_? I don't think you can get the text of that from there anyway.
03:02:01 <free_beard> shachaf: no, i mean a tutorial on the universality and expressivenes of fold, it's available for free
03:02:31 <free_beard> shachaf: i know you can get it frome his homepage, but it's down atm
03:02:47 <reinoud> shachaf: oh sorry... on other channels i am active on they don't mind :-/ but with 850+ ppl. this is a lot more populated! :-)
03:03:02 <shachaf> free_beard: Ah.
03:03:14 <shachaf> free_beard: http://citeseer.ist.psu.edu/viewdoc/summary?doi=10.1.1.34.1618 seems to have a copy.
03:04:04 <free_beard> shachaf: thx, i thought it would redirect me to the homepage
03:04:27 <reinoud> is there another way to convert [a,b,c, ...] into [(a,b,c), (d...] ?
03:04:54 <reinoud> i once stumbled on it... but i can't remember :(
03:05:08 <shachaf> reinoud: Yes, there are many other ways. But what you were doing will probably work if you just fix the error.
03:05:23 <shachaf> Do you see the error in foo [] = ...; foo [x:xs] = ...?
03:05:29 <matiit> Hey, i've got smth like that: http://pastebin.com/w3ypzL9k and it does not compile. Here are errors: http://pastebin.com/XQjhRMhf I am new in haskell and i dont know how to handle it
03:05:41 <shachaf> reinoud: It should (probably) be foo [] = ...; foo (x:xs) = ...
03:05:58 <reinoud> oh!
03:06:01 <reinoud> lets try!!!
03:06:08 <reinoud> silly beginners mistake i guess :)
03:06:11 <shachaf> matiit: You're redefining (+), which is an operator that is already defined.
03:06:27 <reinoud> yeah!
03:06:51 <shachaf> matiit: Either use a different name or hide the Prelude names. I recommend the former.
03:06:52 <reinoud> ugh... not awake enough yet i guess :-D
03:07:17 <shachaf> matiit: (Alternatively, you can make a Num instance, if you know about type classes. But it's probably simpler to just use a different name.)
03:07:38 <matiit> schlaftier: ok, i will use other names (could it be for example (++)?)
03:08:11 <Botje> matiit: ++ is also defined.
03:08:14 <shachaf> matiit: No, (++) is also taken.
03:08:22 <shachaf> You can use +. or something.
03:09:16 <matiit> sbahra: ok, thank you
03:12:00 <reinoud> now lets see if my algorithm does work as i specified it
03:15:33 * hackagebot snaplet-hdbc 0.7.2.3 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.7.2.3 (JurrienStutterheim)
03:15:35 * hackagebot snaplet-hdbc 0.8 - HDBC snaplet for Snap Framework  http://hackage.haskell.org/package/snaplet-hdbc-0.8 (JurrienStutterheim)
03:16:31 <matiit> oh, and how to add my Nat datatype to be Num instance? I tried deriving but it's not working
03:17:08 <shachaf> matiit: You should probably understand type classes much better before you do that.
03:17:35 <shachaf> matiit: The keyword you're looking for is "instance", though. But please read about what type classes are and aren't. :-)
03:18:02 <matiit> shachaf: ok, i will
03:25:34 <Palmik> Hmm, have anyone here encountered this problem with cabal sdist http://hpaste.org/66314 (I found related ticket here http://hackage.haskell.org/trac/hackage/ticket/897 which indicates that it might be a packaging error (on my distribution's (archlinux) side))
03:26:39 <dcoutts_> Palmik: yes, the 897 ticket explains the issue
03:27:34 <dcoutts_> Palmik: and yes, archlinux provides a broken config
03:28:10 <Palmik> dcoutts_, wonderful, thanks for your confirmation. :)
03:35:37 * hackagebot websockets 0.6.0.1 - A sensible and clean way to write WebSocket-capable servers in Haskell.  http://hackage.haskell.org/package/websockets-0.6.0.1 (JasperVanDerJeugt)
03:40:37 * hackagebot derive 2.5.8 - A program and library to derive instances for data types  http://hackage.haskell.org/package/derive-2.5.8 (NeilMitchell)
03:45:38 * hackagebot swift-lda 0.4.0 - Online sampler for Latent Dirichlet Allocation  http://hackage.haskell.org/package/swift-lda-0.4.0 (GrzegorzChrupala)
04:10:32 <jonkri> how can i run a list of io operations? [IO a] -> IO [a], or rather [IO ()] -> IO () if possible
04:11:01 <sipa> mapM_
04:11:18 <sipa> :t mapM_
04:11:19 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
04:11:39 <sipa> :t sequence_
04:11:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
04:11:41 <Botje> jonkri: sequence or sequence_
04:11:49 <Botje> you want sequence_, in this case.
04:11:54 <jonkri> thanks
04:41:53 <Rc43> Hi, guys.
04:42:41 <Rc43> Anybody knows good article about different redundancy elimination optimisations?
04:43:05 <Rc43> There are a lot of different materials, but I want get structure between optimisations.
04:43:19 <Rc43> Which s partial case of which, etc.
04:49:13 <Botje> you mean optimisations on code?
04:51:20 <Rc43> Botje, yes.
04:51:39 <Rc43> Common Subexpression Elimination, Loop-Invariant Code, etc.
04:52:53 <Botje> good question.
04:53:05 <Botje> have you looked at books about advanced or expert optimisation?
04:53:37 <Botje> I'm guessing they will have sections starting with "this optimisation is an improved form of X, but only if you know Y"
04:53:47 <Rc43> Botje, at this moment, I have collected about 10 links from google.
04:53:57 <Rc43> I will look.
04:54:54 <Rc43> Botje, about links - I mean that it is only what I have, didn't look at books, yet.
04:57:00 <Botje> maybe you can find some survey papers on optimization
05:17:17 <ivanm> if I have a Map where the keys are Enums (if it matters, specifically Word values), is it possible to find the smallest value *not* in the Map?
05:17:28 <ivanm> (without actually traversing through all possible ones, etc.)
05:22:20 <Axman6> ivanm: if you can get access to the constructors, then sure
05:22:55 <Axman6> actually, wouldn't pred . map fst . assocs do it?
05:23:32 <ivanm> Axman6: does that even type-check?
05:23:35 <ivanm> @type pred . map fst
05:23:36 <lambdabot> forall a b. (Enum [a]) => [(a, b)] -> [a]
05:23:36 <mgsloan> ivanm: Maybe you could something similar to an IntervalMap, but with monoidal annotations indicating how many unoccupied keys there are in an interval?  That'd require being able to efficiently calculate the distance between to elements of the Enum - which is given by fast fromEnum
05:23:50 <ivanm> mgsloan: maybe...
05:23:55 <matiit> i need to define swap function which is correct for that: flip(curry f) = curry(f . swap), i read about types but it's all not so clear for me yet, i need some directions
05:24:07 <Axman6> ivanm: missed a head in there
05:24:22 <ivanm> Axman6: that doesn't find "gaps" though
05:24:39 <ivanm> or I could just use an auxiliary data structure to keep track of keys I've deleted that aren't larger than the current largest key
05:27:08 <ivanm> (since I'm controlling manipulation of the Map)
05:27:42 <reinoud> @hoogle fromIntegral
05:27:42 <lambdabot> Prelude fromIntegral :: (Integral a, Num b) => a -> b
05:27:58 <reinoud> @hoogle Num
05:27:58 <lambdabot> Prelude class (Eq a, Show a) => Num a
05:27:58 <lambdabot> Data.Ratio numerator :: Integral a => Ratio a -> a
05:27:59 <lambdabot> Numeric module Numeric
05:32:41 <ivanm> Axman6: though I can't see how having direct access to the constructors would help either, unless you went to key-by-key finding a gap
05:56:03 <snhmib> why is there a ByteString (strict) and a ByteString (lazy) wouldn't it be easier if ByteString were like a type class?
05:58:58 <Axman6> snhmib: that doesn't make sense, normal type classes are just a bunch of functions, which work on certain types
05:59:01 <snhmib> example Network.Socket.ByteString and Network.Socket.ByteString.Lazy -- both just want to push bytes around, why should they care what they come from? but it's annoying now you have to think what to import
05:59:29 <snhmib> Axman6: yes so you make a class ByteString with instances StrictByteString and LazyByteString or something
05:59:51 <Axman6> Nereid: the difference between lazy and strict are important enough that the programmer should know what they're doing with them
06:00:12 <Nereid> ????????????
06:00:45 <Azel> snhmib: I would say that if you use ByteStrings, you're doing low-level enough programming that the behavioural differences between a strict and a lazy type shouldn't be hidden
06:00:54 <Axman6> for example, if you're reading in the contents of a large file, you probably do not want to read it in as a strict bytestring
06:03:52 <ivanm> snhmib: what would be better would be ML-style Functors
06:04:04 <ivanm> but there are some API differences between strict and lazy bytestrings (e.g. length)
06:04:12 <ivanm> but I believe there is someone working on such a typeclass
06:04:25 <ivanm> Axman6: I can't see how having direct access to the constructors would help either, unless you went to key-by-key finding a gap
06:05:16 <Axman6> well, it's a balanced binary tree no? so the furthest left key is the successor of the lowest key not in the map
06:06:09 <snhmib> Azel, Axman6: ok maybe you're right, but still in alot of cases you just want some bytes & then it's a bit annoying :( maybe yet another typeclass or something :P
06:06:54 <ivanm> Axman6: maybe I didn't explain myself properly: if we have "keys m = [0,1,2,5,6,10]", then I want "nextKey m = Maybe 3" for example
06:09:15 <Axman6> ah, you want the next free key then?
06:10:22 <ivanm> yup
06:10:31 <snhmib> if keys is lazy you can do something with "keys map" i guess?
06:10:53 <Zedrikov> I think you should need
06:10:57 <Zedrikov> sorry
06:11:20 <ivanm> so I can directly search for it (e.g. using bird's approach in his book or a direct traversal of keys), or I can keep an auxiliary data structure as I remove keys (since if there are no gaps then I just create a new one on the end)
06:11:21 <Zedrikov> I guess you can't do "keys map" if you allow non finite lists
06:11:30 <ivanm> Zedrikov: huh?
06:11:40 <ivanm> sure you can
06:11:51 <ivanm> since the keys in a Map will be finite
06:12:06 <Zedrikov> you can do map, but you cannot find "the next key"
06:12:16 <yasar> Does this operator have a name? <*>
06:12:26 <Botje> shiny star? :)
06:12:32 <ivanm> Zedrikov: dropWhile with zip`ap`tail woudl do it
06:12:47 <Zedrikov> What insurance do you have that a Map is finite?
06:12:51 <ivanm> and if the resulting list is empty, just get succ $ maxKey m
06:13:00 <ivanm> Zedrikov: the way the data structure is defined?
06:13:19 <ivanm> I don't think Data.Map allows for infinite Maps
06:13:33 <Zedrikov> So you have some strictness annotations I guess
06:14:02 <ivanm> either way, merging two such Maps (in the sense of "give each (key,value) pair in the second Map a new value and return the mapping function") would be difficult
06:14:07 <ivanm> Zedrikov: wtf?
06:14:13 <ivanm> what do strictness annotations have to do with it?
06:14:54 <danbst> yasar: ap
06:15:01 <snhmib> you can do operations on a infinite map?
06:15:04 <ivanm> > Map.elems . Map.fromList $ map (flip (,) ()) [1..]
06:15:04 <lambdabot>   Not in scope: `Map.elems'Not in scope: `Map.fromList'
06:15:10 <ivanm> > M.elems . M.fromList $ map (flip (,) ()) [1..]
06:15:14 <lambdabot>   mueval-core: Time limit exceeded
06:15:17 <Saizan> ivanm: strict fields are how you ensure a datatype has to be finite (or bottom)
06:15:18 <Zedrikov> the way the data structure is defined? ← How can you define it to ensure it is finite?
06:15:20 <ivanm> ^^ if Maps were lazy, that would work
06:15:26 <ivanm> Saizan: I know what strict fields are
06:15:36 <ivanm> but what do they have to do with Data.Map
06:15:44 <ivanm> Zedrikov: you do know what Data.Map is, right?
06:15:47 <Saizan> look at Data.Map definition
06:18:00 <matiit> Is there any explanation on the internet how to deduce :t (.)(.) or :t flip flip and so on? I can't figure it out. I would love to read something good about it
06:18:01 <ivanm> Saizan: yeah, it uses it; but I have never heard anyone before try to claim that Data.Map allowed for infinite Maps
06:18:35 <ivanm> matiit: maybe see if LYAH has a section on deriving type signatures?
06:18:41 <ivanm> @google haskell derive type signature
06:18:44 <lambdabot> http://book.realworldhaskell.org/read/using-typeclasses.html
06:18:44 <lambdabot> Title: Chapter 6. Using Typeclasses
06:18:46 <Botje> matiit: eta-expand them until you get to fully-defined functions
06:19:21 <ivanm> e.g. flip flip; to avoid confusion call the second flip " flip2 "
06:19:51 <ivanm> so we know that flip :: (a -> b -> c) -> b -> a -> c
06:19:56 <Saizan> ivanm: we're in fact saying that the way you ensure a Data.Map can't be infinite are those strict fields (even if they are probably there also for other performance purpouses)
06:20:15 <ivanm> so in "flip flip2", we must have that flip2 :: (a -> b -> c)
06:20:34 <ivanm> but from the definition, flip2 :: (d -> e -> f) -> e -> d -> f
06:20:55 <ivanm> so a == (d -> e -> f), b == e and c == (d -> f)
06:21:34 <ivanm> we thus have that flip flip2 :: ((d -> e -> f) -> e -> d -> f) -> e -> (d -> e -> f) -> (d -> f)
06:21:36 <ivanm> @type flip flip
06:21:37 <lambdabot> forall (f :: * -> *) a b. (Functor f) => a -> f (a -> b) -> f b
06:21:37 <Zedrikov> iwann: yeah, it uses it; but I have never heard anyone before try to claim that Data.Map allowed for infinite Maps ← you can perfectly do Data.Map implementations which allows infinite Maps
06:21:53 <matiit> ivanm: it makes sense, thank you very much, i nee to read it and understand
06:22:08 <ivanm> Zedrikov: you can do lookup table implementations that allow for infinite Maps, but they wouldn't be *Data.Map*
06:22:21 <ivanm> and to avoid confusion you would hope that anyone else would use a different name
06:22:21 <danbst> @type flip
06:22:22 <lambdabot> forall (f :: * -> *) a b. (Functor f) => f (a -> b) -> a -> f b
06:22:32 <ivanm> oh, ignore the type lambdabot gives
06:22:40 * ivanm curses Caleskell
06:23:02 <Zedrikov> In Coq, there is a FMap module for specifically finite maps.
06:23:02 <ivanm> wait, slight mistake, I forgot to drop the first argument
06:23:13 <ivanm> flip flip2 :: e -> (d -> e -> f) -> (d -> f)
06:23:33 <ivanm> Zedrikov: right, and I believe that Data.Map used to be called FiniteMap or something
06:23:37 <ivanm> but Haskell /= Coq
06:23:44 <ivanm> and I was asking about Haskell :)
06:24:25 <danbst> why lambdabot gives strange types?
06:25:10 <Zedrikov> Maybe, but that means also that no one imposes Data.Map to be finite.
06:25:14 <ivanm> danbst: Caleskell
06:25:29 <ivanm> Zedrikov: by implementation it is; I think people would get rather annoyed if it suddenly changed tomorrow
06:25:34 <Zedrikov> And indeed by removing strictness annotations you can build non finite maps.
06:26:45 <ivanm> Zedrikov: sure, you can
06:26:50 <ivanm> but it isn't
06:27:23 <hpc> matiit: http://hpc.dyndns-web.com:8000/blog/view.cgi?id=4 -- this covers exactly what you're asking
06:27:29 <ivanm> and I highly doubt it will, unless somehow GHC manages to optimise it a hell of a lot better in the common cases without strictness annotations
06:28:25 <Saizan> actually, i've seen benchmarks where the strict fields were a pessimization
06:28:26 * ivanm -> land of nod
06:28:33 <Saizan> but that was a few years ago
06:28:37 <ivanm> Saizan: oh?
06:28:45 <ivanm> how common/likely were they?
06:29:10 <ivanm> with all the work people have put into Data.{Map,Set} lately, I would find that surprising if it was still the case
06:29:11 <Saizan> i don't remember the details
06:29:17 <ivanm> *nod*
06:29:22 * ivanm really goes to sleep now
06:29:41 <Saizan> i don't think much work went into Data.Map itself?
06:30:16 <matiit> hpc: thanks
06:47:12 <roconnor> preflex: seen dibblego
06:47:13 <preflex>  dibblego was last seen on #haskell 2 days, 10 hours, 35 minutes and 40 seconds ago, saying: distributive
06:52:48 <darkangel> Hi All. I there way to do overloading based on typeclasses? Say I have typeclasses Simple and Complex and want to do different things based on that. Can I do that?
06:55:05 <timthelion> darkangel: the way I do that, is I make a data SimpleOrComplex = Simple a | Complex a
06:55:46 <timthelion> darkangel: moment, I meant data SimpleOrComplex = Simple' Simple | Complex' Complex
06:56:20 <timthelion> and then I patern match in the function f (Simple' mySimple) =... and f (Complex' myComplex) = ...
06:56:28 <darkangel> instance Complex String; instance Simple Int; need to do apply a for Int and String with different implementations for Int and String
06:57:07 <timthelion> I don't follow
06:57:47 <hpc> darkangel: what are the functions you are trying to write (without type classes)?
06:58:00 <hpc> @where hpaste
06:58:00 <lambdabot> http://hpaste.org/
06:59:43 <darkangel> I am traying to implement some remote calling interface and for that I need function that will take some function and xmk node and than parse and invoke it
07:00:32 <darkangel> I have two different logic for handling simple types like Int and complex type like records
07:01:11 <darkangel> I what to do different thing based on types
07:01:34 <darkangel> but I don't know that type in advance
07:01:42 <timthelion> darkangel: why don't you just make two different functions invokeParseSimple and invokeParseComplex?
07:02:11 <darkangel> foo :: Int -> Foo - will not go
07:02:23 <timthelion> darkangel: how can you not know the type in advance?  Are you getting these functions as arguments?
07:02:36 <darkangel> mkInvoker foo - and upps
07:03:03 * timthelion doesn't know the answer to this question.
07:03:23 <darkangel> timthelion: Yes, I pass it to mkInvoker
07:03:32 <reinoud> @hoogle ONum
07:03:32 <lambdabot> Network.BSD protoNumber :: ProtocolEntry -> ProtocolNumber
07:04:32 <darkangel> timthelion: but mkInvoker should take any function and run different parse algorithm based on arguments in passed function
07:05:08 <timthelion> darkangel: but if YOU are passing the function, then it's not a problem, because you do know the type.
07:06:03 <darkangel> timthelion: I now, but how generic mkInvoker will handle that?
07:06:10 <darkangel> timthelion: I know, but how generic mkInvoker will handle that?
07:06:32 * timthelion doesn't know.
07:06:48 * timthelion isn't familliar with mkInvoker :)
07:07:40 <darkangel> timthelion: If I have some way to overload parse based on typeclasses that I will write one for Complex argument and one for Simple
07:07:55 <darkangel> timthelion: but how to do such overloading....
07:08:34 <hpc> why not
07:08:59 <hpc> simpleParser :: (a -> Thing) -> a -> Thing -- add other (a -> whatever) parsing functions as arguments
07:09:05 <hpc> complexParser :: the same type
07:10:46 * timthelion cries, cyclical imports.
07:13:13 <timthelion> Is there a way to devide a project into files, without modules?  I'd like ghc to just "stitch" the files together wantonly...  Fuck cyclicle imports!
07:13:46 <Saizan> use cpp?
07:13:49 <hpc> use CPP, then hate yourself
07:13:56 <hpc> (the second step is important ;))
07:14:06 <timthelion> hpc: I already do the seccond step
07:14:07 <darkangel> :))
07:14:25 <timthelion> hpc: Of course I hate myself, I have a cyclical import!
07:15:20 <hpc> there's also hs-boot files, which might or might not suck even worse :P
07:15:52 <timthelion> I have two data's one looks like data Cell = ThingWithChildren Children , and data Children = ThingThatHasCells Cell
07:16:08 <timthelion> and I want them to be in their own files.  But it's IMPOSSIBLE!
07:16:54 * timthelion doesn't see what's so wrong about copy paste wantonly concatinating files before building them.
07:17:41 <mm_freak> timthelion: you're not the first to complain about that
07:17:56 <timthelion> Am I right, that what I'm trying to do is impossible?
07:18:00 <mm_freak> mutually dependent modules should really become possible
07:18:17 <mm_freak> that's why most haskell programmers have a Types module and various functionality modules
07:18:32 <timthelion> mm_freak: that's ugly though
07:18:50 <hpc> i like it better than two modules depending on each other
07:18:57 <hpc> plus it makes the compiler a bit simpler
07:19:20 <timthelion> hpc: it's still more complex than C or pythons...
07:19:21 <hpc> compile = compile depends >>= compile module
07:19:24 <mm_freak> hpc: it's ugly, because it makes it hard to implement things in isolation
07:19:47 <mm_freak> plus you have to jump back and forth between two files all the time
07:19:52 <timthelion> they should solve it by allowing for multifile modules.
07:19:56 <hpc> mm_freak: i think it reduces that
07:20:11 <hpc> if you're getting circular dependencies when you try to isolate something, it wasn't isolated to begin with
07:20:32 <timthelion> hpc: I just don't like scrolling up and down so much :)
07:21:03 <timthelion> it's convenient to have 20 files and 10 workspaces and you know, just flip between them, instead of navigating a 1000 line code file.
07:21:05 <ozgura_> timthelion: I beliee what you want is possible, yet quite ugly: via hs-boot files.
07:21:17 <timthelion> ozgura_: ok, thank you
07:21:19 <ozgura_> creating hs-boot files is almost mechanical
07:21:41 <mm_freak> hpc: you know, haskell's quality is related to the fact that it doesn't allow the programmer to do stupid things, but you shouldn't do the mistake to generalize "stupid things" to everything
07:21:43 <ozgura_> what I don't understand is why we don't have a tool which does that
07:21:47 <ozgura_> if not ghc itself
07:22:00 <mm_freak> circular modules can be a useful feature from time to time, and GHC does not allow them
07:22:31 <mm_freak> boot files are even uglier than using a Types module
07:22:56 <ozgura_> if you have to manage them, yes.
07:23:08 <timthelion> I already created a module called Super, which I use to define idiotic things like type Point = (Int, Int)...
07:23:51 <mm_freak> timthelion: just go with Types modules and the module hierarchy…  it works quite well and isn't that ugly
07:24:31 <mm_freak> say you have concepts A, B and C and B and C depend on each other:  Data.A, Data.BC.Types, Data.BC.B, Data.BC.C
07:24:37 <timthelion> I think I'll just put my simpler data type into the same module as the more complex one it mutually depends on.
07:24:56 <mm_freak> you can also add proxy modules Data.B and Data.C that just reexport Data.BC.B and Data.BC.Types or Data.BC.C and Data.BC.Types respectively
07:27:31 <wunki> when I start building a library, what's the best way to "dogfood" that library. Do you just test the functions or have an "examples" directory in the library?
07:27:41 <wunki> or maybe a seperate project which uses the library?
07:28:26 <timthelion> mm_freak: I don't have that much in terms of methods that I'm defining.  One of the type declarations however is over 100 lines long with comments, so it makes no sense to shred everything further. but thanks for your advice
07:28:35 <hpc> wunki: i start with a project, with the intention of turning it into a library
07:28:40 <hpc> and then never get around to it :P
07:29:13 <timthelion> wunki: examples directories are your friend.  I almost never use libraries that don't provide an examples directory somewhere.
07:30:42 <mm_freak> wunki: a separate proof of concept package is very useful
07:30:53 <wunki> hpc: but the sole purpose is a library, so that's not an option for me. Because I would do the same :)
07:31:03 <mm_freak> also make sure your haddocks are complete and understandable to someone not knowing your library
07:31:30 <wunki> timthelion, mm_freak is it possible to use the library in progress without recompiling and installing it
07:31:37 <mm_freak> haskell programmers (including me) often learn a library by only looking at the function names and their types, and sometimes the haddock docs
07:31:43 <wunki> relative imports or something
07:31:46 <wunki> I'm a complete beginner here
07:32:01 <mm_freak> wunki: well, you can put executables into the library
07:32:41 <mm_freak> you can have up to one Library and arbitrarily many Executable clauses in your cabal file
07:32:49 <timthelion> wunki: of course it is.  You just need to create a main module, which you would then delete later.
07:33:07 <hpc> mm_freak: i also learn a library by seeing which functions have the most haddock
07:33:14 <mm_freak> you don't even need to delete it…  i usually just comment out the Executable clause when releasing the library
07:33:22 <hpc> because even without knowing anything else about a library, those are the most interesting functions
07:33:25 <hpc> or the most used
07:33:35 <wunki> ah, I understand. And the executable is where I use and test the library
07:33:44 <mm_freak> wunki: where you test the library
07:34:22 <wunki> ok, I will do a quick readup on Haddock and then start typing. Thanks for the help
07:53:54 <mysticc> @hoogle Word64->Integer
07:53:55 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
07:53:55 <lambdabot> Prelude floatRadix :: RealFloat a => a -> Integer
07:53:55 <lambdabot> Prelude toInteger :: Integral a => a -> Integer
07:57:24 <Peaker> > floatRadix 12345.6789
07:57:25 <lambdabot>   2
08:06:21 <JamesJRH> Is there a channel for Gitit? If not, how do I configure login priviledges? And how do I make it aware that it is being proxied on /gitit ?
08:14:58 <etpace> I've asked questions along this line before, but I seem to confuse myself eachtime I readover my implementation: When typing mutually recursive groups, we type them each monomorphically, but when we generalise -- what judgement do we use? Consider "gamma |- x_1 :: tau_1, ... , x_n :: tau_n", do we then generalise so that x_i :: foralll A_i. tau_i, where A_i = fv(tau_i) - fv(gamma) - fv(tau_j) for all j /= i, or simply A_i = fv(tau_i) - fv(gamma)
08:17:44 <ski> @type let even [] = True; even (_:as) = odd as; odd [] = False; odd (_:as) = even as in even
08:17:45 <lambdabot> forall t. [t] -> Bool
08:17:48 <ski> etpace : i think the latter
08:18:48 <etpace> me too, thanks
08:19:07 <etpace> I can't find much literature on the topic of why that is the sensible option
08:19:14 <ski> in this case we get `even :: [a] -> Bool; odd :: [a] -> Bool'
08:19:35 <etpace> but thats forall a. before each right?
08:19:54 <etpace> even though they will always be unified in this example
08:20:14 <ski> if we had `(even,odd) :: ([a] -> Bool,[a] -> Bool', one could generalize to `forall a. ([a] -> Bool,[a] -> Bool)' -- but this is basically the same as `(forall a. [a] -> Bool,forall a. [a] -> Bool)'
08:20:29 <ski> which should help explain why each binding gets a `forall'
08:20:47 <ski> and of course variables not mentioned in the type can be removed from the `forall'
08:21:13 <etpace> ok, thanks
08:46:13 * hackagebot digestive-functors-snap 0.3.1.0 - Snap backend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-snap-0.3.1.0 (JasperVanDerJeugt)
08:49:50 <wunki> \q
08:59:52 <timthelion> What's that magical function that takes a list of Maybe s and returns the items that have Just?
09:01:28 <ClaudiusMaximus> :t catMaybes
09:01:28 <lambdabot> forall a. [Maybe a] -> [a]
09:01:36 <ChristianS> @hoogle [Maybe a] -> [a]
09:01:36 <lambdabot> Data.Maybe catMaybes :: [Maybe a] -> [a]
09:01:37 <lambdabot> Data.Maybe maybeToList :: Maybe a -> [a]
09:01:37 <lambdabot> Prelude sequence :: Monad m => [m a] -> m [a]
09:02:05 <timthelion> > catMaybes [Just "hi",Nothing,Just "bye"]
09:02:06 <lambdabot>   ["hi","bye"]
09:02:14 <timthelion> thanks
09:16:02 <monochrom> oh hi. haskell.org and hackage are both giving me 401 errors. (April 1st joke)
09:16:13 * hackagebot acme-http 0.1 - fastest Haskell PONG server in the world  http://hackage.haskell.org/package/acme-http-0.1 (JeremyShaw)
09:16:55 <mm_freak> a better joke would be if haskell.org and hackage would 301 to php.net
09:16:59 <shergill> oh ok now the acme package makes sense
09:17:11 <hpaste> whittle pasted “ghc-pkg check” at http://hpaste.org/66318
09:17:12 <shergill> ha
09:17:15 <shergill> *haha
09:17:17 <shergill> *hah
09:17:22 <shergill> dammit. i need coffee
09:17:45 <whittle> I'm new to Haskell and trying to get used to the toolset. I get several problems when running ghc-pkg check. How should I go about fixing these issues?
09:19:29 <Axman6> delete everything, start again
09:19:47 <Sedrikov> whittle: Can't you try to reinstall broken packages with cabal?
09:20:10 <Saizan> depends on which packages they are
09:21:01 <monochrom> how did you come to missing those files? did you delete those files?
09:21:10 <Sedrikov> So what packages are reported to go wrong?
09:21:12 <whittle> Sedrikov: `cabal install --reinstall monads-tf-0.1.0.0`?
09:21:25 <shergill> whittle: if you're just starting, using sandboxing tools/mechanisms like virthualenv are recommended
09:22:13 <Sedrikov> yes
09:23:09 <whittle> shergill: What if I’m trying to install Yi? Just stick with Emacs?
09:23:10 <Sedrikov> In fact I am not sure, but I think it is pointless to do that for the packages contained in "/usr/lib/ghc-7.4.1/package.conf.d/"
09:23:43 <Sedrikov> for the others it should be ok
09:24:27 <Sedrikov> (so it should be ok for monads-tf-0.1.0.0)
09:24:57 <shergill> whittle: ah. ghc-pkg unregistering the faulty packages and then reinstalling them doesn't work?
09:25:59 <whittle> Sedrikov: I’m using haskell-platform-2011.4.0.0. Should I upgrade by ghc from 7.0.4 to 7.4.1?
09:26:46 <shergill> whittle: you probably don't want that. more packages will break for you
09:26:48 <Sedrikov> I am not expert, but I guess I shouldn't advice you to do so
09:27:04 <Sedrikov> I am sorry for the path I gave
09:27:13 <Sedrikov> You should adapt to your version
09:29:19 <whittle> Sedrikov: I wasn't trying to be critical. I just didn't want to waste anyone's time because I'm on an old version. I'm new to Haskell, but I've been around open-source long enough that I try not to ask for help for unsupported versions.
09:31:59 <Sedrikov> I guess I should apologize if I made you thinking that I believed you were critical. You didn't seem critical to me. For the story of the old version, you have no choice, since it is the last version of the Haskell-platfrom AFAIK
09:32:11 <whittle> Sedrikov: Gotcha.
09:32:58 <whittle> Reinstalling monads-tf-0.1.0.0 got rid of ghc-pkg errors.
09:33:11 <Sedrikov> ok, cool
09:33:13 <whittle> Reinstalling ghc-paths-0.1.0.8 got rid of ghc-pkg errors.
09:33:30 <whittle> Unregistering ghc-paths-0.1.0.6 got rid of errors.
09:33:58 <mk> is let just for interactive mode?
09:34:11 <whittle> And it looks like dyre-0.8.6 builds now!
09:34:50 <Sedrikov> yes, the "ghc-paths" belongs to the "/usr/lib/ghc-<version>/package.conf.d/"
09:35:11 <Sedrikov> so it is not a good idea to unregister it I think
09:36:13 <whittle> Sedrikov: The packages in /ghc-<version>/package.conf.d/ are special because they’re part of GHC?
09:36:28 <byorgey> mk: you can have an expression  let x = blah in e   anywhere
09:36:38 <mk> in e?
09:36:51 <byorgey> mk: just saying  let x = y   by itself  only works in a do-block or at the ghci prompt
09:36:57 <byorgey> mk:  where e is any expression, like this:
09:37:05 <mk> I see - what's a do block?
09:37:05 <byorgey> > let x = 3 + 5 in 2*x
09:37:06 <lambdabot>   16
09:37:19 <Sedrikov> the one you can unregister are those in your "~/.ghc/<version>/packages.conf/"
09:37:33 <byorgey> mk: if you don't know what a do block is then don't worry about it yet.  it's special syntax for use with monads.
09:37:35 <Sedrikov> whittle: yes
09:37:46 <Sedrikov> whittle: but once again I am not expert
09:38:38 <mk> byorgey: ok, good - I'd seen it there before, so I wasn't sure. Does let work at ghci because it's in IO?
09:38:44 <whittle> Sedrikov: You are far more expert than I.
09:39:16 <byorgey> mk: yes, the ghci prompt can be (mostly) thought of as if it's inside a giant do-block for the IO monad.
09:39:51 <CarmineM74> Hi everybody. I'm a Haskell newbie (Just reading learn you a haskell for good; pun intended). And am facing difficulties on Applicative functors. As far as I have understood [] is a functor, then why writing "pure zip <*> [1,2,3,4] <*> [5,6,7,8]" makes GHCI complain? Thanks for your help.
09:39:56 <byorgey> though that has to be taken with a grain of salt, it's actually more general than that =)
09:40:08 <mk> ok, great - otherwise, when I'm writing a script, let x = 1 should just be written as x = 1?
09:40:36 <whittle> shergill: Is virthualenv preferred to cabal-dev?
09:40:43 <byorgey> CarmineM74: because the types don't match.
09:41:08 <byorgey> CarmineM74: zip applies to two lists, but doing  pure zip <*> blah <*> blah  is going to apply zip to every possible pair of *elements* from the two lists
09:41:32 <CarmineM74> indeed that's what I expected out of it
09:41:32 <byorgey> > pure (+) <*> [1,2,3,4] <*> [5,6,7,8]
09:41:33 <lambdabot>   [6,7,8,9,7,8,9,10,8,9,10,11,9,10,11,12]
09:41:42 <CarmineM74> ah, ok
09:41:48 <byorgey> CarmineM74: zip can't be applied to two numbers
09:42:01 <CarmineM74> I thought it would have produced all the pairs of numbers
09:42:11 <shergill> whittle: this is something you should probably figure out for yourself since it's subjective. i like virthualenv coz i have it integrated with my pre-existing python's virtualenv based workflow
09:42:11 <byorgey> for that you want to use (,) instead of zip
09:42:17 <byorgey> > pure (,) <*> [1,2,3,4] <*> [5,6,7,8]
09:42:18 <lambdabot>   [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4...
09:42:18 <geekosaur> CarmineM74, zip does that directly
09:42:30 <whittle> shergill: Ah, I see. Thank you.
09:42:36 <mk> when a script is loaded, is it evaluated as much as it can be?
09:42:42 <geekosaur> ?
09:42:58 <byorgey> geekosaur: no, zip doesn't produce *all* pairs.
09:43:08 <byorgey> mk: no
09:43:15 <byorgey> mk: quite the opposite.
09:43:45 <shergill> whittle: np
09:43:57 <geekosaur> byorgey, yeh, misread.  was actually ging for the point you made
09:44:23 <CarmineM74> the whole thing works if i use pure before the lists too
09:45:10 <byorgey> CarmineM74: well, doing  pure f <*> pure x <*> pure y  is the same as doing  pure (f x y)
09:45:14 <CarmineM74> that should be because the lists get turned into a functor too (lifted?)
09:45:19 <byorgey> yeah
09:45:20 <navaati> hello
09:45:33 <mk> when I let a = 1:[] or load, :t a is [Integer], but :t 1:[] is Num a=> [a]
09:45:35 <byorgey> I'm not sure what functor it is picking though.
09:45:59 <mk> why are the types different?
09:46:02 <geekosaur> mk, that's the monomorphism restriction
09:46:09 <CarmineM74> Thanks, now you've shed some light over this!
09:46:19 <navaati> i've just seen the news about happstack 7 and it makes me wondering : what's the difference between this and, say, yesod ? their features seem to converge a lot…
09:46:20 <byorgey> mk: that's because of the silly monomorphism restriction.  You should turn it off by putting {-# LANGUAGE NoMonomorphismRestriction #-} at the top of your file, and/or :set -XNoMonomorphismRestriction at the ghci prompt.
09:46:30 <mk> geekosaur: sounds scarily complicated
09:46:57 <mk> what does it... do?
09:47:17 <navaati> mk : it annoys everyone
09:47:20 <luite> navaati: yesod is much cooler obviously ;p
09:47:33 <mk> why is it the default?
09:47:47 <navaati> perf issues, iirc
09:47:59 <navaati> not sure if it is still relevant
09:48:06 <mk> so it evaluates things? or?
09:48:36 <byorgey> mk: it forces some things to have a monomorphic (i.e. non-polymorphic type)
09:48:58 <byorgey> mk: that is why when you do  a = 1:[]  it is forcing a to have the type [Integer], even though it could be more general
09:49:04 <geekosaur> it forces a single type on a binding with no parameters, on the assumtpion that you intended it to only be evaluated once (if it's polymorphic then it normally has to be evaluated at each type it is used in)
09:49:21 <navaati> byorgey: isn't this defaulting rather than monomorphism restriction ?
09:49:21 <mk> I see - thanks
09:49:34 <byorgey> navaati: it's both.
09:49:43 <whittle> Is there a way to recompile ghci to use Readline without fubarring my entire haskell-platform install?
09:49:50 <geekosaur> navaati, defaulting is the mechanism the monomorphism restriction uses to determine the type
09:50:05 <byorgey> it is forced to have a monomorphic type by the MR, and ghc chooses [Integer] in particular because of the defaulting rules.
09:50:16 <navaati> both being a pain in the ass
09:50:25 <geekosaur> yep :/
09:50:28 <byorgey> whittle: probably not.
09:50:56 <navaati> and how does GHC for types on which there is no defaulting (that is something else than Num a and IsString s) ?
09:51:04 <navaati> how does GHC choose*
09:52:33 <mk> can I make it so that a script will run as if typed into ghci, when loaded via :l?
09:52:34 <whittle> byorgey: Okay. I’ll wait until I have more experience with the toolchain before customizing.
09:52:36 <byorgey> navaati: it doesn't, you just get an ambiguous type error.
09:54:16 <byorgey> mk: yes, just load it with  :script  instead of :load
09:54:18 <whittle> Is the cabal commandline tool a wrapper for ghc-pkg the way that on Debian, apt is a wrapper for dpkg?
09:54:36 <mk> byorgey: unknown command
09:54:37 <byorgey> whittle: yes
09:54:50 <byorgey> mk: what version of ghci do you have?
09:55:11 <whittle> byorgey: Good to know. Thanks.
09:55:22 <mk> byorgey: 7 0 3
09:55:56 <byorgey> mk: ah, yeah, it looks like :script did not exist in 7.0.3
09:56:15 <byorgey> it got added in 7.2
10:03:20 <mysticc> Does haskell automatically closes the handle of a file during a program .. ?
10:03:55 <mysticc> I am referring to file handle from System.IO
10:05:42 <t7> @seen bitonic
10:05:42 <lambdabot> Unknown command, try @list
10:06:18 * hackagebot hlint 1.8.28 - Source code suggestions  http://hackage.haskell.org/package/hlint-1.8.28 (NeilMitchell)
10:06:32 <geekosaur> mysticc, handles are closed when they go out of scope and are garbage collected; note that that may not be immediate
10:06:32 <monochrom> no, doesn't
10:07:28 <mysticc> geekosaur: I am storing handles inside IORef .. Can this happen that they are still garbage collected even before the program is finished
10:07:38 <hpc> mysticc: the OS closes them when the process exits, sometimes
10:08:01 <geekosaur> "sometimes"?
10:08:11 <hpc> if the handle is open when it's garbage-collected, it doesn't get closed - or at least, you should assume it won't be closed
10:08:14 * monochrom frowns. don't rely on automatic closing. murphy's law. will always conspire against you
10:08:53 <hpc> don't assume the OS will close them when the process exits either
10:08:53 <geekosaur> monochrom, except in *very* spare embedded environments, if the OS is not closing those files on process exit the OS is extremely buggy
10:09:03 <geekosaur> ...ok, assume the OS is unusably buggy, fine
10:09:03 <hpc> most linuxes will, but windows won't
10:09:21 <geekosaur> windows ... excuse me?  it had bugs like that... when it was based on DOS
10:09:32 <hpc> it doesn't close network handles
10:09:40 <hpc> it might close file handles; i haven't tested
10:10:14 <Enigmagic> hpc: uhm, windows definitely closes file and socket handles
10:10:23 <Enigmagic> when a process exits
10:11:00 <mysticc> hpc: In my case opposite is happening .. when I am trying to readfrom Handle which I stored in an IORef after sometimes it is saying handle is closed ..
10:11:09 <Sgeo> So my for my April Fools project
10:11:09 <Sgeo> :(
10:11:21 <geekosaur> mysticc, are you using lazy I/O on it by any chance?
10:11:37 <hpc> (ie, hGetContents)
10:11:39 <geekosaur> hGetContents will leave the handle in a "semi-closed" state
10:11:41 <mysticc> geekosaur: What this has to do with lazy IO ..
10:11:49 <mysticc> geekosaur: No ..
10:11:54 <monochrom> it is also said that if you had the quota of 1G handles the same way you have the quota of 1G memory bytes, automatic closing would be practical.
10:11:55 <timthelion> Sgeo: We should rewrite ghc in Perl.
10:12:23 <hpc> timthelion: pppsh, write it in agda
10:12:28 * Sgeo was thinking a prelude with things that do IO via unsafePerformIO
10:12:29 <mysticc> geekosaur: I am using Bytestring hGet
10:12:37 <Sgeo> Sequencing things with pseq
10:13:36 <timthelion> Sgeo: Don't we already have that for sort :( ?
10:14:08 <Sgeo> I meant, as in getLine would be :: String
10:14:28 <Sgeo> I was told (by one person, I should have asked around) that it simply would not work
10:14:38 <timthelion> Sgeo: it would work
10:14:50 <timthelion> Sgeo: but it would kind of ruin the type system :)
10:15:06 <monochrom> it will work or not work depending on details
10:15:12 <monochrom> very tiny details
10:15:16 <timthelion> Sgeo: Haskell needs typological fassism
10:20:48 <mysticc> geekosaur: hpc : Any help .. Can I prevent gc from closing my handle ..
10:21:24 <geekosaur> mysticc, gc would not close it if you still have a reference to it; that includes an IORef
10:21:32 <geekosaur> so I presume something else is happening
10:22:47 <mysticc> I dont think so .. I am not closing the handle anywhere but when I am trying to read I am getting error that handle is closed ..
10:24:17 <mk> what's the multiline comment in haskell?
10:24:22 <stepkut> mk: {
10:24:25 <stepkut> {- -}
10:24:44 <mk> thanks
10:24:56 <stepkut> is there is a utility for counting Haskell 'lines of code'. Something that ignores comments, whitespace, and imports?
10:28:29 <aristid> haskell should rename undefined to FILE_NOT_FOUND.
10:28:56 <monochrom> except it still have to start with a lowercase letter
10:28:57 <sm> stepkut: maybe sloccount has haskell support ? I forget
10:29:16 <companion_cube> data Bool = True | False | FileNotFound
10:29:16 <Saizan> mysticc: are you using withFile, perhaps?
10:29:41 <aristid> monochrom: if it was uppercase, it would be possible to pattern match on it
10:29:57 <aristid> wouldn't that be practical? just pattern match, and solve the halting problem.
10:30:12 <monochrom> that's just half of the halting problem
10:30:45 <aristid> monochrom: why?
10:30:55 <monochrom> the other half hides in infinite loops
10:31:43 <aristid> monochrom: those would return FILE_NOT_FOUND, too
10:32:05 <monochrom> I have never observed that behaviour. good luck.
10:32:33 <mornfall> Eventually. :P
10:32:47 <monochrom> you will observe a magnetic monopole long before you will observe that behaviour
10:33:19 <aristid> monochrom: well, we only need to set one of the simons on the task of finding a magnetic monopole, then
10:33:31 <monochrom> http://perl.plover.com/classes/OOPSLA/samples/slide067.html
10:33:56 <monochrom> "infinite loops will return FILE_NOT_FOUND? sure, when Arnold is elected president!"
10:34:17 <mornfall> Eventually is a long time.
10:35:08 <monochrom> btw great scheme to catch some infinite loops by looking at inferred types :)
10:35:32 <aristid> monochrom: a wonderful picture
10:36:03 <monochrom> it's Markus Dominus's talk on the benefit of haskell types
10:36:03 <brisbin> i have a lot of "if cond then [x] else []"'s in a particular function and feel there could be a more general approach i don't know of. i know lists act as a lot of different things and thought "when cond x" might be it, but when is m (). is there another way?
10:36:21 <hpaste> t7 pasted “Can I replace this with a fold?” at http://hpaste.org/66327
10:36:44 <monochrom> in short, you write a sort function, it has bugs, inferred type is (Ord a) => [a] -> [b]. that indicates an infinite loop
10:37:43 <hpc> @src when
10:37:43 <lambdabot> when p s = if p then s else return ()
10:38:12 <aristid> monochrom: he should just have used agda, and it would have punished him with THE RED
10:38:32 <luite> > let f x c = [x' | x' <- [x], c] in f 1 False  -- this is shorter right ;p
10:38:33 <lambdabot>   []
10:39:10 <brisbin> luite: lol
10:39:55 <hpc> > let f x c = [x | [x], c] in f 1 False
10:39:56 <lambdabot>   Couldn't match expected type `GHC.Bool.Bool'
10:39:56 <lambdabot>         against inferred type ...
10:40:12 <hpc> aw
10:40:20 <newsham> ?src guard
10:40:20 <lambdabot> guard True  =  return ()
10:40:20 <lambdabot> guard False =  mzero
10:40:23 <luite> > let f x c = guard c >> [x] in f 1 False -- even shorter
10:40:24 <lambdabot>   []
10:40:34 <brisbin> i'm just using http://sprunge.us/FMVO?hs right now
10:40:50 <newsham> > mzero :: [Int]
10:40:51 <lambdabot>   []
10:42:33 <parcs`> stepkut: cloc
10:42:56 <newsham> > do { guard (5 == 5) ; guard (isDigit '5'); [25] }
10:42:56 <lambdabot>   [25]
10:43:23 <dmwit> > let f x c = [x | c] in f 1 False
10:43:24 <lambdabot>   []
10:43:31 <dmwit> You guys are making it way too long. =D
10:43:54 <newsham> dmwit: i'm trying to anticipate the code beyond what he's given
10:44:02 <dmwit> > [25 | 5 == 5, isDigit '5']
10:44:03 <lambdabot>   [25]
10:44:09 <newsham> i'm guessing guard will prob fit well with what he wants to do
10:44:10 <aristid> > [25]
10:44:11 <lambdabot>   [25]
10:44:14 <aristid> shortest.
10:44:20 <parcs`> :t [?x|?c]
10:44:21 <lambdabot> Not in scope: `|?'
10:44:28 <dmwit> aristid: That doesn't perform the same computation.
10:44:33 <aristid> :t [?x | ?c]
10:44:34 <lambdabot> forall t. (?x::t, ?c::Bool) => [t]
10:44:38 <dmwit> newsham: guard can be shortened to | in list comprehensions. =)
10:44:43 <aristid> dmwit: but it has the same result:)
10:44:49 <parcs`> :t [?x | ?c | ?D]
10:44:50 <lambdabot> parse error on input `?'
10:44:52 <parcs`> :t [?x | ?c | ?d]
10:44:53 <lambdabot> forall t. (?x::t, ?d::Bool, ?c::Bool) => [t]
10:44:54 <newsham> dmwit: but if he's doing lots of list work it might not all fit in a comprehension well
10:45:10 <brisbin> i can link to the context, one sec
10:45:15 <dmwit> Anything that can be written well with a do-block can be written well with a comprehension.
10:45:34 <newsham> dmwit: also it might be more general than list.
10:45:40 <monochrom> you can add line-breaks in comprehension, too
10:45:40 <brisbin> this could be x y, so there maybe an entirely different approach anyway: https://github.com/pbrisbin/yesod-paginator/blob/master/Yesod/Paginator/Widget.hs#L63
10:45:49 <dmwit> newsham: Now that is a reasonable argument.
10:45:57 <dmwit> Luckily, we have monad comprehensions these days... =D
10:46:19 * hackagebot acme-http 0.1.1 - fastest Haskell PONG server in the world  http://hackage.haskell.org/package/acme-http-0.1.1 (JeremyShaw)
10:46:32 <dmwit> iff p x = [x | p]
10:46:36 <dmwit> In fact, I usually just inline iff.
10:47:24 <aristid> :t let iff p x = p >> return x
10:47:25 <lambdabot> <no location info>:
10:47:25 <lambdabot>     not an expression: `let iff p x = p >> return x'
10:47:31 <aristid> :t let iff p x = p >> return x in iff
10:47:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> b -> m b
10:47:48 <dmwit> :t let iff p x = guard p >> return x in iff -- aristid, somebody already suggested this one
10:47:48 <lambdabot> forall b (m :: * -> *). (MonadPlus m) => Bool -> b -> m b
10:48:04 <Entroacceptor>  he updated acme-http??
10:48:12 <aristid> oh, the fastest haskell pong server
10:48:13 <brisbin> yes, that's more the answer i was expecting. though i appreciate your golfing on iff dmwit
10:48:17 <aristid> but is it as fast as warp?!
10:48:45 <newsham> :t \p x -> guard p >> x
10:48:46 <lambdabot> forall (m :: * -> *) b. (MonadPlus m) => Bool -> m b -> m b
10:49:02 <stepkut> aristid: about 4x faster on my machine
10:49:14 * dmwit uses the [x | p] idiom more than he expected to when he learned it
10:49:17 <newsham> firstLink = guard (pg > 1) $ Enabled 1 "1" "prev"
10:49:37 <newsham> concat [ guard (pg > 1) $ Enabled 1 "1" "prev",  guard ... ]
10:49:51 <brisbin> newsham: i thought guard took only one argument?
10:50:20 <newsham> oops, s/$/>>/
10:50:37 <aristid> stepkut: and the good thing is, michael snoyman uses the same benchmarks :D
10:50:39 <brisbin> ah yes then
10:50:54 <dmwit> newsham: Even then you need to wrap [] around the second "argument".
10:51:06 <newsham> err >> return $
10:51:24 <dmwit> newsham: This solution is looking less and less appealing than writing "iff" the more we fix it. =P
10:51:28 <newsham> yup
10:51:30 <brisbin> indeed
10:51:53 <roconnor> do people consider seq as something that breaks referential transparency?
10:52:26 <hpc> not usually
10:52:28 * Saizan pushes [ Enabled 1 "1" "prev" | pg > 1 ] one more
10:52:42 <newsham> :)
10:52:44 <hpc> it breaks a few assumptions about strictness, sometimes
10:52:51 <dmwit> Saizan++
10:52:56 <t7> > let f x = x in f f
10:52:57 <lambdabot>   Overlapping instances for GHC.Show.Show (t -> t)
10:52:57 <lambdabot>    arising from a use of `...
10:53:02 <t7> :t let f x = x in f f
10:53:03 <lambdabot> forall t. t -> t
10:53:25 <dmwit> > id id 1
10:53:26 <lambdabot>   1
10:53:32 <dmwit> :t id id
10:53:33 <lambdabot> forall a. a -> a
10:53:36 <brisbin> Saizan: i like it. using it :)
10:53:46 * dmwit throws his hands up in the air
10:54:10 <newsham> poor dmwit
10:54:48 <Saizan> dmwit++ #balancing karma
10:54:53 <dmwit> lol
10:57:04 <t7> 81 chars >:(
10:57:49 <newsham> ?type foldl mplus mzero . map (\(p, x) -> guard p >> x)
10:57:50 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [(Bool, m a)] -> m a
10:58:19 <newsham> guardedmconcat
10:59:28 <Saizan> s/foldl/foldr/
10:59:44 <newsham> foldr? i hardly knowr!
11:01:20 <hpaste> IanCal pasted “FFI unusually high memory usage?” at http://hpaste.org/66328
11:02:15 <IanCal> I'm having an issue with trying to load some data onto the gpu with opencl, and it seems to be using a lot more memory than it needs. I've got a reduced example here : http://hpaste.org/66328
11:02:34 <parcs`> IanCal: the haskellArray is using majority of the memory
11:02:44 <Saizan> IanCal: haskellArray is actually a linked list
11:02:57 <IanCal> aha
11:03:17 <parcs`> you should use a Vector from the 'vector' package
11:03:19 <ski> roconnor : it breaks eta-conversion
11:03:25 <Saizan> so it's not wise to have it all in memory at once, but if you don't print its size you can exploit laziness
11:03:44 <IanCal> Saizan, parcs` ahh, thank you
11:03:59 <Saizan> though i guess newArray takes its length to allocate the array memory
11:04:11 <Saizan> so that alone wouldn't help
11:04:22 <IanCal> it does, yes, although I can know that without looking at the array
11:04:23 <c_wraith> arrays are kind of non-lazy in the allocation portion, yeah
11:04:47 <IanCal> I think it'd be rare for me to be loading unknown sized arrays for opencl work
11:04:53 <IanCal> so I'm probably safe there
11:05:57 <IanCal> I'll give Vector a go, thanks for the help
11:08:59 <roconnor> ski: do you think let z = foo in const y z === y is referential transparency?
11:09:19 <roconnor> *is part of referential transparency?
11:09:24 <timthelion> ach, that awful feeling, when your major project compiles, and it says "Linking xxx..." and you just know that you're going to get some error when you run it.
11:10:43 <t7> timthelion: fuck it, if it compiles - ship it
11:10:57 <danbst> > print "hello world"
11:10:58 <lambdabot>   <IO ()>
11:12:12 <hpaste> “threads + IO meuh” pasted “snhmib” at http://hpaste.org/66330
11:12:21 <danbst> > getChar
11:12:22 <lambdabot>   <IO Char>
11:13:43 <danbst> > getCurrentTime
11:13:44 <lambdabot>   Not in scope: `getCurrentTime'
11:14:05 <danbst> lambdabot: you are boring
11:14:10 <snhmib> the way to do this (this= forwarding a stream) is like this right? i.e. spawn 2 threads with forkIO, 1 for each handle, there is no select like function? :(
11:14:57 <dmwit> select is hidden (and done better) by the IO manager.
11:15:02 <dmwit> What is the top-level goal you have?
11:15:27 <snhmib> ok, is there any way that both doing this:  (copy from filehandle to other handle `finally` killThread brother thread) could go wrong?
11:15:33 <dmwit> I'm not sure what "forwarding a stream" means, but is Chan what you're looking for?
11:15:58 <snhmib> dmwit: no i want to make a simple proxy, but not sure how to best do it
11:16:33 <dmwit> Define "go wrong".
11:16:41 <dmwit> It could be racy if they're both looking at the same handle.
11:16:48 <mysticc> Saizan: No .. I am using openBinaryFile and the hGet from ByteString
11:17:42 <snhmib> well, one is happily copying stuff, gets exception from brother, sends exception from brother (that is either dead or past the `finally` code) what happens? :)
11:18:07 <ski> roconnor : i'm not clear on the definition of RT
11:18:13 <roconnor> heh
11:18:15 <roconnor> okay
11:18:33 <roconnor> neither am I
11:18:34 <snhmib> dmwit: i.e. if throwing an exception to an non-existing thread or a uncatched exception is ignored that's fine by me, but i'm not sure that's the case
11:18:48 <ski> roconnor : afaik, the term derives from uses in logic and philosophy, where "referential opacity" is also used
11:19:02 <dmwit> I'm not 100% sure I've understood the question yet.
11:20:07 <dmwit> If you want to behave differently on different exceptions (e.g. the "I'm getting killed by my brother" exception and the "something bad happened when reading/writing" exception), then `finally` is not the way to go.
11:21:08 <snhmib> err oh yea
11:21:46 <Saizan> killing a dead thread is fine
11:22:17 <dmwit> Excellent, I like that interpretation of the question, too.
11:22:56 <snhmib> hehe
11:23:04 <whittle> The fact that `cabal info enumerator` includes escape literals in the description for me; is that a display issue on my side, or are cabal package descriptions no actually supposed to include en-dashes?
11:23:15 <ski> roconnor : e.g. knowing the morning star is the same as the evening star, we still can't claim "Dalyn believes Amaena saw the morning star." is equivalent to "Dalyn believes Amaena saw the evening star.", since Dalyn might not know they are the same thing, and "Dalyn believes ..." is a referentially opaque context
11:23:54 <ski> roconnor : in modal logic one uses this terminology to explain how you can't "replace equals for equals" across modal operators
11:24:00 <dmwit> whittle: Cabal package descriptions are written in Haddock format.
11:24:05 <dmwit> (approximately)
11:24:36 <ski> roconnor : i'm not clear on how this relates to semantics of programming languages, but i suspect it is about this idea of being able to replace equals for equals
11:26:57 <roconnor> ski: well naively I've been assuming that it means that you can replace a defined variable(s) with its definitions without changing its semantics.
11:27:23 * ski nods
11:27:30 <roconnor> In that case let z = foo in const y z is only equal to let z = foo in y by RT.
11:28:07 <snhmib> what actually happens when you do 'hGetContents inhandle >>= hPut outhandle' and outhandle is closed?
11:28:24 <ski> in the simplest case, `let x = e0 in e1[y |-> x]' being equal to `let x = e0 in e1[y |-> e0]'
11:28:55 <ski> roconnor : yes, and then you can use a GC rule to remove the vacuous `let'
11:29:04 <snhmib> maybe i should just stop writing 1 liners and add more error handling code :S
11:29:06 <roconnor> ski: well, maybe not in a strict language
11:29:15 <whittle> dmwit: Looking at the Haddock docs, and the the enumerator.cabal file, it looks like that’s all in order.
11:29:15 <roconnor> ski: for some definition of strict
11:29:21 <Saizan> snhmib: you could test those one liners :)
11:29:27 <ski> roconnor : *nod*, if we have nontermination
11:29:53 <snhmib> :)
11:29:59 <ski> roconnor : however, strict languages only have a weaker variant of the beta-rule, as well
11:30:12 <Saizan> snhmib: hGetContents truncates the output there if the handle is closed
11:30:19 <ski> (usually beta-value)
11:30:59 <ski> snhmib : you should not manually close a `Handle' passed to `hGetContents' -- it is already in a "semi-closed" state
11:33:22 <dmwit> ski, Saizan: He's asking about closing outhandle; your comments seem to be addressing the closing of inhandle.
11:33:41 <whittle> In Hoogle, the page for the enumerator package processes the escapes correctly, but the expandable description of enumerator on the search page does not process the escapes, and even though it is clearly processing something as it turns unescaped slash-pairs into italicize directives.
11:33:58 <Saizan> dmwit: oh, right
11:34:43 <Saizan> snhmib: sorry, my answer was for when inhandle is closed, i'm not sure but i think you get an exception if you hPut on a closed handle
11:34:51 <dmwit> Anyway, the answer is probably exception...
11:34:56 <dmwit> yeah, what Saizan said =)
11:34:58 <snhmib> i.e. it's a socket and it could get closed no?
11:35:51 <Saizan> from whom?
11:36:14 <ski> dmwit : oh, you're right
11:36:38 <dgpratt> roconnor, or anyone else for that matter, what's your current feelings about using spoon?
11:36:41 <snhmib> Saizan: on the other end
11:36:49 <ski> dmwit : evil :)
11:36:52 <ski> er
11:36:56 <ski> dgpratt ^
11:37:52 <notthemessiah> this important news regarding cabal might need to be put in today's topic: http://www.yesodweb.com/blog/2012/04/replacing-cabal
11:37:58 <snhmib> Saizan: i'm always confused what happens when you write/send on a socket :)
11:38:09 <dgpratt> ski: evil + smiley == mixed message
11:38:29 <snhmib> as long as all goes fine it's fine, but when it doesn't  ... :/
11:39:22 <Saizan> i think each endpoint can only close its own outgoing side
11:39:37 <roconnor> dgpratt: It might be a pragmatic way of overcoming badly designed, but I'm not a pragmatic person.  I'd just patch the offensive library.
11:39:43 <ski> dgpratt : i wouldn't use it, except as a temporary measure, or as an impure implementation of something which still has a pure interface (in case that is indeed possible)
11:40:55 <dgpratt> roconnor, ski: ok, thanks
11:41:04 <Saizan> (in TCP at least)
11:42:03 <snhmib> Saizan: i think most stacks only do half-open connections when you ask for it... not sure though, anyway i wanna stop and kill everything so i was asking how to detect this in haskell
11:45:22 <Saizan> snhmib: i see now, i don't know though
11:46:17 <Saizan> maybe hPut will throw an exception in that case, or maybe there's something in network you can call to check
11:46:47 <ski> @hoogle hPut
11:46:47 <lambdabot> System.IO hPutBuf :: Handle -> Ptr a -> Int -> IO ()
11:46:47 <lambdabot> GHC.IO.Handle hPutBuf :: Handle -> Ptr a -> Int -> IO ()
11:46:47 <lambdabot> System.IO hPutBufNonBlocking :: Handle -> Ptr a -> Int -> IO Int
11:58:29 <kowalej> Hey, is there a way to write a zip function that takes n number of lists? Or any "variadic" function at all?
11:58:58 <ski> see `printf'
11:59:17 <ski> (and yes, this is typically considered a bad idea)
11:59:31 <dmwit> kowalej: For zip specifically, we have ZipList.
12:00:00 <ski> > let a = 3 in printf "%s is %02d" "a" a :: String
12:00:01 <lambdabot>   "a is 03"
12:00:39 <dmwit> :t (<*>)
12:00:40 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
12:00:40 <kowalej> dmwit Thanks
12:01:06 <merijn> I got all the way to the mention of "Homotopy Extensional Records Proposal (HERP)" before I realised the new record syntax proposal was an April Fool's joke >.>
12:01:08 <ski> > let a = 3 in printf "%s is %02d" a "a" :: String  -- run-time error !
12:01:08 <lambdabot>   "*Exception: Printf.printf: bad argument
12:01:20 <dmwit> > getZipList ((\x y z w -> x + y + z - w) <$> ZipList [1..5] <*> ZipList [1..5] <*> ZipList [1..6] <*> ZipList [30..35])
12:01:21 <lambdabot>   [-27,-25,-23,-21,-19]
12:01:49 <dmwit> > getZipList ((\x y z w -> x + y + z - w) <$> ZipList [1..5] <*> ZipList [1..5] <*> ZipList [1..6] <*> ZipList [30..35] <*> ZipList [5..10]) -- compile-time error!
12:01:50 <lambdabot>   No instance for (GHC.Enum.Enum (a -> a1))
12:01:50 <lambdabot>    arising from a use of `e_11515...
12:02:27 <akosch> What's up with the record syntax? I've heard people don't like it for a number of reasons (also there is NoTraditionalRecordSyntax in GHC now). Are there alternatives available which are preferable to it?
12:02:52 <Rotaerk> akosch, what's wrong with it?
12:02:55 <dmwit> akosch: Search the mailing lists. Please don't start the discussion here. It never ends.
12:02:57 <ski> akosch : none implemented, afaik
12:03:24 <akosch> Sorry, I don't want to start a flame war :)
12:03:36 <merijn> akosch: No implemented alternatives, the basic problem boils down to the function name of record fields are top level, so you cannot have to records with the same fields. People disagree on whether this is a problem
12:03:41 <monochrom> merijn: it is a nice touch that the references contain a Rick-roll :)
12:03:42 * Rotaerk sets akosch on fire.
12:04:03 <ski> merijn : also the nested update problem -- and also the light-weight records discussion
12:04:28 <merijn> Inevitably someone will propose a solution using the period (to mimic OO), which then starts a flame war whether that becomes confusing with (.) being function composition
12:05:09 <akosch> merijn: I usually prefix the record fields with something so they don't clash. As I understand these 'accessors' are just plain functions defined by syntactic sugar...
12:05:15 <Rotaerk> member syntax isn't bad due to confusion but due to the fact that it's got weaker type constraints
12:05:28 <ski> akosch : .. not *quite* just plain functions
12:05:36 <dmwit> merijn: Too late, already been done.
12:05:49 <Rotaerk> in "f x", it's clear which f you're talking about
12:05:59 <akosch> not quite?
12:06:02 <Rotaerk> in x.f, which f you're talking about is dependent on the type of x
12:06:14 <ski> akosch : you have the `foo {x = blah}' syntax
12:06:24 <Rotaerk> akosch, quite.
12:06:41 <snhmib> where do i find this mythical ResourceVanished that's documented at hPutBuf
12:06:49 <ski> Rotaerk : i believe that was a response to my comment
12:06:51 <akosch> ski: oh, ok...
12:06:59 <hpc> @hoogle resourcevanished
12:06:59 <lambdabot> No results found
12:07:02 <Rotaerk> k
12:07:45 <geekosaur> snhmib, what is your real question?
12:08:51 <hpaste> snhmib pasted “hPut(Buf) error” at http://hpaste.org/66333
12:08:57 <geekosaur> ResourceVanished is the Haskell image of EPIPE, the POSIX error code returned on an attempt to write to a pipe or socket whose read end has been closed/gone away, when SIGPIPE has been ignored
12:09:08 <snhmib> yea
12:09:30 <snhmib> i was wondering where to find it so i can catch it in this test
12:10:45 <snhmib> had the same problem with hoogle as hpc :)
12:10:52 <geekosaur> my guess is you'd see it if you were importing System.IO instead of IO
12:11:00 <geekosaur> since IO sticks to Haskell98
12:11:31 <geekosaur> although you might need Control.Exception as well (and, oddly, hayoo is not finding it either, just telling me about HPutBuf)
12:12:21 <ClaudiusMaximus> snhmib: http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/GHC-IO-Exception.html
12:19:24 <snhmib> thanks :)
12:21:21 * hackagebot unfoldable 0.1.0 - Class of data structures that can be unfolded from a seed value.  http://hackage.haskell.org/package/unfoldable-0.1.0 (SjoerdVisscher)
12:22:18 <dmwit> Oh, hey!
12:22:23 <hpc> ooh
12:22:30 <dmwit> http://hackage.haskell.org/packages/archive/data-ordlist/0.4.5/doc/html/Data-List-Ordered.html has a bunch of functions I've been looking for!
12:23:50 <hpc> unfoldable would be a nifty interface for PRNGs
12:24:30 <Authoritarianism> Hello. Why is 4 * $ 3 - 1 illegal?
12:24:40 <byorgey> dmwit: oh, nice
12:24:59 <roconnor> Authoritarianism: sections like (4 *) always use parentheses
12:25:04 <byorgey> Authoritarianism: you can't have two infix operators next to each other like that
12:25:14 <danbst> (4 *) $ 3 - 1
12:25:22 <Authoritarianism> roconnor, byorgey: Thanks.
12:25:22 <byorgey> Authoritarianism: note that there is nothing special about $, it is just a normal infox operator
12:25:31 <byorgey> *infix
12:25:33 <roconnor> > let f = 2 * in f 7
12:25:34 <lambdabot>   <no location info>: parse error on input `in'
12:25:40 <koala_man> does O(n log n) have a name like how O(n^2) is quadratic?
12:25:40 <roconnor> > let f = (2 *) in f 7
12:25:40 <lambdabot>   14
12:26:02 <Authoritarianism> Oh.
12:26:50 <byorgey> koala_man: good question, I've never heard of one
12:27:09 <dmwit> Both of the things I thought of (log-linear and polylogarithmic) are already terms taken for another meaning. =(
12:27:11 <byorgey> "log-linear" could be a good name perhaps?
12:27:15 <byorgey> oh.
12:28:00 <cy1> "order of en log en"
12:28:23 <dmwit> heh
12:28:31 <byorgey> dmwit: what does log-linear mean?
12:29:02 <dmwit> It means exp(linear function), weirdly.
12:29:06 <dmwit> http://en.wikipedia.org/wiki/Log-linear
12:29:17 <koala_man> linearithmic
12:29:26 <koala_man> http://en.wikipedia.org/wiki/Time_complexity#Linearithmic.2Fquasilinear_time
12:29:50 <dmwit> cute
12:30:15 <dmwit> Oh, I've heard the term subquadratic before. It's not as precise, but still pretty descriptive.
12:30:35 <dmwit> (And even someone who doesn't know the term could guess what it means with pretty good confidence.)
12:31:57 <int80_h> in RWH ch15/MonadHandle.hs, a class definition begins "class Monad m => MonadHandle h m | m -> h where ..." could someone explain that? I'm not familiar with the use of '|' and '->' in this context.
12:32:02 <ColonelJ> Hi, I'm after a bit of terminology here
12:32:32 <dmwit> int80_h: It's called "functional dependency", and there should be a wiki page on it and a section of the GHC user's guide on it that are quite googlable.
12:32:33 <byorgey> for some reason it only recently sank in for me that O(n log n) is practically speaking very very close to O(n), and O(n^2) is not even in the same ballpark.
12:32:40 <dmwit> (But hard to google without knowing that term. =)
12:32:54 <byorgey> previously I just knew that O(n) < O(n log n) < O(n^2)
12:33:03 <edwardk> byorgey: ಠ_ಠ
12:33:23 <byorgey> I consider this a major gap in my foundational CS education.
12:33:23 <ColonelJ> if you have a list [(1,"one"),(2,"two"),(3,"three")] what would you call a function that gives you [1,2,3] or similarly ["one","two","three"]
12:33:26 <carter> you could call it log stirling
12:33:27 <carter> :)
12:33:33 <carter> or log factorial
12:33:37 <carter> http://en.wikipedia.org/wiki/Stirling's_approximation
12:33:40 <exFalso> :t map fst
12:33:41 <lambdabot> forall a b. [(a, b)] -> [a]
12:33:51 <byorgey> ColonelJ: map fst  or  map snd?
12:33:53 <carter> log(n!)= O(nlogn)
12:33:58 <dmwit> It's so weird that ln . factorial is very nearly id.
12:34:04 <ColonelJ> yea that's what I mean but what would you describe that kind of function as
12:34:04 <dmwit> edwardk: (that was at you)
12:34:09 <ColonelJ> I was thinking "projection mapping"
12:34:15 <edwardk> byorgey: thats why we have Õ notation
12:34:26 <int80_h> dmwit: thanks, I'm reading the wiki page now :)
12:34:34 <macobo> byorgey: think about it this way. log 10000000 == 7, meaning that the "constant" before n is only 7. So really on realistic data O(nlogn) might be faster than O(n)
12:34:38 <byorgey> ColonelJ: sure, "projection" is a good general term for that sotr of thing
12:34:38 <carter> the Otilde's lie
12:34:43 <ColonelJ> looking for the proper technical term for something like that
12:34:45 <exFalso> ColonelJ: it -is- a projection
12:34:45 <byorgey> macobo: yep.
12:34:54 <edwardk> carter: but only a little bit
12:35:02 <ColonelJ> exFalso: oh so it's just a projection?
12:35:10 <exFalso> yes
12:35:28 <ColonelJ> I thought a projection was like fst or snd (without the map)
12:35:32 <carter> edwardk: true, but theres usually a huge mess of polylogs living under that tilde
12:35:43 <exFalso> those are also projections
12:35:46 <edwardk> carter: sure
12:35:57 <exFalso> lemme google product for you :P
12:36:05 <edwardk> macobo: yeah. i always in practice read alpha(n) as 4. ;)
12:36:05 <merijn> ColonelJ: Projection is a general term for taking a part of data type X and returning that part
12:36:22 <ColonelJ> right, but I was looking for a term for applying it across a vector/list
12:36:24 <int80_h> dmwit: would | be interpreted "such that'. as in " In the class MonadHandle there is a value h and a value m suck that there is only one m for every h."
12:36:26 <exFalso> ColonelJ: http://en.wikipedia.org/wiki/Product_(category_theory)
12:36:30 <carter> though it admittedly lies with the hidden poly log constants if it matters or not
12:36:35 <dmwit> int80_h: That reading sounds good to me.
12:36:42 <int80_h> dmwit: *scuh that*!!!
12:36:46 <int80_h> ugh
12:36:51 <merijn> ColonelJ: Still projection, as now your projecting part of the original list resulting in a new list :p
12:36:53 <int80_h> heh okay I think I have it
12:37:11 <dmwit> int80_h: Might want to change "only one" to "at most one", otherwise yes.
12:37:13 <ColonelJ> merijn: ok I guess that makes sense.  So maybe "list projection"?
12:37:19 <dmwit> int80_h: Wait, non.
12:37:31 <merijn> ColonelJ: Sure, sound reasonable enough
12:37:34 <dmwit> int80_h: "there is a value h and a value m such that m *determines* h"
12:37:36 <int80_h> dmwit: non?
12:37:40 <dmwit> int80_h: typo of "no"
12:37:41 <int80_h> ah
12:38:05 <dmwit> int80_h: There might be many "m" for that associate with a particular "h"; but for any given "m", there's at most one "h" associated with it.
12:38:16 <byorgey> ColonelJ: out of curiosity, why do you need a name for it?
12:38:33 <dmwit> You could also write "class Foo a b c | a b -> c", which should be read as "a and b together determine c".
12:38:35 <ColonelJ> byorgey: I'm designing a programming language
12:39:08 <ColonelJ> I made a new syntax to allow to pattern match with projections on a list
12:39:11 <dmwit> exFalso: In what category are "map fst" and "map snd" projections?
12:39:21 <int80_h> dmwit: thanks :)
12:39:39 <hpc> :t map fst
12:39:40 <lambdabot> forall a b. [(a, b)] -> [a]
12:40:04 <exFalso> dmwit: in Hask?
12:40:08 <dmwit> nope
12:40:21 <byorgey> dmwit: the category with infinite lists as objects and *something something functions* as arrows
12:40:27 <dmwit> byorgey: heh
12:40:44 <exFalso> they are projections in Hask
12:40:47 <dmwit> P.S. do we have CT reading group tomorrow or is Vilhelm still away?
12:40:56 <byorgey> I think Vilhelm is still away
12:41:05 <byorgey> exFalso: what's your definition of "projection"?
12:41:10 <ski> byorgey : maybe causal stream transformers ?
12:41:21 <byorgey> ski: sure, that sounds good =)
12:41:27 <ski> (or anti-causal, if you prefer)
12:41:31 <exFalso> byorgey: i define products in terms of projections
12:42:24 * ski . o O ( Vilhelm ? )
12:42:53 <exFalso> a product is a limit on a diagram with 3 objects X1, X2 and X1*X2 and two morphisms called the canonical projections blablabla
12:42:57 <byorgey> ski: http://www.seas.upenn.edu/~vilhelm/
12:43:13 <DrSyzygy> exFalso: Sure; but map fst is not acting on a product in Hask.
12:43:19 <byorgey> exFalso: right
12:43:22 <DrSyzygy> exFalso: it's acting on the functorial image of a product.
12:43:23 <dmwit> exFalso: Alright. I hand you two functions, (\_ -> []) and (\_ -> [3]). What is your unique function "f" for which "map fst . f = (\_ -> [])" and "map snd . f = (\_ -> [3]"?
12:43:27 <ski> exFalso : actually, it should be a limit of a diagram with *two* objects (and zero morphisms)
12:43:50 <exFalso> ski: right sorry
12:43:58 <hpc> wikipedia seems to say projection = arrow of type (tuple ~> element)
12:44:07 <dmwit> exFalso: (Hint: it can't be done, because "map" preserves lengeth, and hence "map fst" and "map snd" aren't projections for any product.)
12:44:11 <DrSyzygy> hpc: Yup. Since the tuple is the product in Hask.
12:44:11 <hpc> so... what byorgey said
12:44:33 <hpc> it's not a projection in hask
12:44:34 <ski> hpc : i sometimes use "projection" to mean an epic morphism (well, usually split, i think)
12:44:54 <dmwit> It might be a projection in some suitable category, but that's not a priori clear to me.
12:46:22 <roconnor> I sometimes use "projection" to mean idempotent
12:46:38 <dmwit> yikes
12:46:54 <roconnor> especially in linear algebra
12:47:28 <exFalso> hmm i thought it is the same as when you have cartesian products in Set and you take the superset functor on it
12:49:01 <dmwit> [] isn't quite the same as a powerset
12:49:40 <dmwit> The elements are ordered and repeatable.
12:50:23 * byorgey is going to start referring to lists as "ordered multisets"
12:50:47 <jmcarthur> what's wrong with "list"?
12:51:07 <DrSyzygy> byorgey: nice
12:51:10 <dmwit> jmcarthur: Doesn't scare enough people away
12:51:14 <jmcarthur> or maybe a bit more abstractly, "sequence"
12:51:19 <ColonelJ> ok by the sounds of it I should be calling it "projection list" rather than "list projection"
12:51:39 <ski> roconnor : i've seen that usage -- also common in physics, i think
12:52:47 * ski isn't quite sure what ColonelJ's "it" is referring to
12:53:14 <ColonelJ> I'm referring to my syntax which allows you to bind a name to the list of projected elements
12:53:15 <dmwit> ColonelJ: Either is probably fine.
12:53:37 <byorgey> "projection list" sounds like it is actually a list of some sort.
12:53:51 <ColonelJ> and it is
12:53:56 <byorgey> oh, I see, it is.
12:54:12 <ski> ColonelJ : and what is that syntax ?
12:54:38 <ColonelJ> @{>{elem1 elem2 elem3}}
12:54:38 <lambdabot> Unknown command, try @list
12:55:07 <ColonelJ> I mean @{>{elem1s elem2s elem3s}}
12:56:10 <ColonelJ> "{{1 2 3} {4 5 6} {7 8 9}} @{{x y z}>{elem1s elem2s elem3s}}" gives x=1 y=2 z=3 elem1s={4 7} elem2s={5 8} elem3s={6 9}
12:56:11 <Nisstyre> I'm having some trouble using the readline library here: http://hackage.haskell.org/packages/archive/readline/1.0.1.0/doc/html/System-Console-Readline.html
12:56:13 <ski> is this supposed to be a hypothetical haskell extension ?
12:56:16 <Nisstyre> http://codepad.org/KOTFiYLH
12:56:24 <Nisstyre> apparently there is a linking problem
12:56:25 <Nisstyre> I'm not sure how to fix it
12:56:33 <ColonelJ> ski: nothing to do with haskell whatsoever I just like asking awkward questions in here
12:56:50 <Nisstyre> the codepad link includes the OS, ghc, and cabal versions
12:57:34 <dmwit> Nisstyre: Have you got your distribution's ncurses package installed?
12:57:46 <Nisstyre> dmwit: yes, I have ncurses installed
12:58:06 <ColonelJ> ski: I don't think haskell has anything in its pattern matching which allows this sort of thing/
12:58:27 <Nisstyre> dmwit: http://codepad.org/bRobJtUe
12:58:51 <Nisstyre> dmwit: I have a 32 bit version and a 64 bit version installed
12:59:03 <ski> ColonelJ : i'm trying to determine atm what "this sort of thing" refers to ..
12:59:24 <ColonelJ> binding a name to a projection across a list
12:59:27 <Nisstyre> version is 5.9-3
12:59:29 <ski> ColonelJ : ok, i see
12:59:33 <dmwit> Nisstyre: Dunno for sure; does /usr/lib/libncurses.so exist?
12:59:45 <ski> ColonelJ : you can do this sort of thing with `...' in `syntax-rules' in Scheme
12:59:48 <Nisstyre> file /usr/lib/libncurses.so
12:59:49 <Nisstyre> /usr/lib/libncurses.so: ASCII text
13:00:00 <ski> (and `syntax-case' as well, i think)
13:00:16 <dmwit> strange
13:00:40 <Nisstyre> dmwit: the only thing in it is "INPUT(-lncursesw)"
13:00:58 <Nisstyre> I have no idea what that is supposed to do
13:01:12 <ski> ColonelJ : join #scheme ?
13:01:31 <ski> (if you want to see it in action)
13:01:35 <ColonelJ> are you talking about implementation or an actual feature of scheme
13:01:38 <dmwit> Nisstyre: Perhaps you should check "pkgfile libncursesw.so".
13:01:39 <ColonelJ> but yea I'll go there
13:01:48 <ski> i'm talking about the standard macro system of Scheme
13:02:00 <Clint> what does "Could not deduce (a1 ~ [Char])" mean?
13:02:08 <dmwit> Though here that claims core/ncurses ought to provide that file, too.
13:02:14 <dmwit> So I really don't know what's wrong.
13:02:22 <dmwit> (<- also an Arch user)
13:02:51 <Nisstyre> dmwit: yeah I'm not sure what's going on
13:05:53 <ski> Clint : i would guess you're treating an abstract polymorphic thing as if it was a string
13:06:40 <ski> @paste your code ?
13:06:40 <lambdabot> Haskell pastebin: http://hpaste.org/
13:07:23 <hpaste> Clint pasted “failed deduction” at http://hpaste.org/66334
13:09:15 <dmwit> Clint: fromString only applies to String's, not IsString instances.
13:09:18 <dmwit> ...I think
13:09:30 <dmwit> Yes, hoogle backs me up here. =)
13:09:32 <ClaudiusMaximus> Clint: fromString :: IsString a => String -> a
13:09:46 <dmwit> Clint: So when you write "fromString k" and "fromString v", that's not right.
13:09:53 <dmwit> k and v are IsString instances, not Strings.
13:10:01 <Clint> oh, i see
13:12:14 <Nisstyre> dmwit: I'm rebuilding readline with abs to see if that makes any difference
13:12:28 <mk> if I do data Test = Ab Int | Cd Int, values constructed using Ab and Cd will differ, even when the same Int is given, correct?
13:12:49 <Botje> yes
13:13:04 <mk> thanks
13:13:13 <Nisstyre> nope :\
13:13:33 <Nisstyre> I guess I'll try rebuilding ncurses
13:14:11 <geekosaur> <Nisstyre> dmwit: the only thing in it is "INPUT(-lncursesw)"
13:14:30 <Nisstyre> geekosaur: that confused me
13:14:35 <Nisstyre> I'm not sure what that even does
13:14:37 <geekosaur> that's a linker script, and it should work as is
13:14:47 <Nisstyre> any ideas as to why it's not?
13:16:49 <geekosaur> you might want to read up on liner scripts in the GNU ld manual.  but I can see a simple fix (and don;t know offhand if the problem is with ld or with the linker script)
13:17:31 <dmwit> s/can see/can't see/?
13:17:34 <geekosaur> change the file to say "INPUT(/usr/lib/libncurses.so)"
13:17:51 <dmwit> eh... isn't that recursive?
13:18:04 <geekosaur> whoops. sorry\
13:18:04 <dmwit> (This is the contents of /usr/lib/libncurses.so)
13:18:09 <geekosaur> change the file to say "INPUT(/usr/lib/libncursesw.so)"
13:18:12 <geekosaur> typo
13:18:50 <geekosaur> the point is that ncurses was changed at some point so that instead of separate normal and wide character versions the same library worked for both, so -lncurses now is just a pointer to -lncursesw
13:18:50 <Nisstyre> geekosaur: that fixed it
13:18:56 <Nisstyre> geekosaur: what was the problem?
13:19:12 <Nisstyre> ah
13:19:57 <geekosaur> I am guessing that whoever set that linker script up thought that INPUT() would be read before preprocessing so could use the -l shorthand for a path search, when in fact it has to explicitly reference a shared object by name
13:20:24 <geekosaur> I don't know if that varies by ld version (or ld vs. gold), would have to read details of the linker script stuff that I haven't touched in ages
13:20:37 <Nisstyre> geekosaur: so should I file a bug with the ncurses maintainer?
13:20:54 <geekosaur> if you don't feel like trying to track it down yourself, yes
13:21:02 <Nisstyre> okay, I'll do that then
13:49:23 <zzo38> Finally I have gotten dvi-processing to work and here is a program which typesets the Lord's Prayer:   http://sprunge.us/ERMQ
13:50:14 <dmwit> Odd; you use both layout and explicit {;}?
13:50:33 <gereedy> Is it possible using syb stuff to do a transformation from F a to F b?
13:50:49 <Peaker> gereedy: why not "deriving Functor"?
13:50:53 <dreixel> gereedy: not without some awful hackery, no
13:50:56 <zzo38> dmwit: Do you mean me? Or someone else?
13:51:01 <dmwit> yes, you
13:51:38 <zzo38> I don't use layout it is nonlayout mode, although I am using indentation, just it is manual instead of automatically determining the blocks due to indentation.
13:52:06 <dmwit> Yes, I know. I observed that you're using explicit {;} mode. But you have, by accident, also written something that would work fine if all the {;} were omitted.
13:52:10 <dmwit> So why do you use them?
13:52:56 <zzo38> Since sometimes I will write something which would be indented differently; I also dislike layout mode, and non-layout mode works better with macros in case they will ever be used
13:53:25 <dmwit> You have weird taste.
13:53:50 <zzo38> OK
13:55:37 <gereedy> Peaker: unfortunately the conversion from a to b is context sensitive
13:55:39 <zzo38> Currently this program is not perfect, but it does typeset the Lord's Prayer in a reasonable way. It does not implement TeX's line breaking algorithm yet; it does, however, implement TeX's page breaking algorithm (but this fits entirely on one page so it doesn't matter).
13:55:50 <gereedy> Peaker: so Functor isn't enough
13:56:07 <zzo38> HPDF implements TeX's line breaker but that is PDF not DVI, so it won't work.
13:56:50 <ski> zzo38 : macros should be independent of layout, i think
13:57:05 * ski thinks zzo38 should typeset it in tengwar
13:57:36 <zzo38> HPDF is LGPL and dvi-processing is public domain; so if implemented, I should put the HPDF's typesetting stuff for DVI, in a separate package, because it is different license.
13:59:36 <zzo38> But I might implement other modules in the dvi-processing package (so far only Graphics.DVI, and I won't add other stuff to that module other than bug fixes) for such things as drawing lines and circles, mathematics typesetting, Black Associates specials, etc.
14:03:29 <zzo38> I also want to add a module to send the generated (or read) DVI to printer, but I don't know how to make a Haskell program to do that.
14:03:51 <zzo38> Do you know how?
14:04:23 <dmwit> gtk has some printing functions
14:04:24 <hpc> look for an interface to CUPS
14:04:31 <hpc> or gtk, apparently
14:04:44 <zzo38> hpc: I want it to work on both UNIX and on Windows.
14:05:08 <tgeeky> zzo38: printing is something which probably isn't unified in any way across Win/Linux
14:06:12 <tgeeky> zzo38: perhaps I sit corrected. GTK might do it.
14:06:49 <zzo38> Is there a way to use Kpathsea with Haskell, so that I can add an extra module which allows it to use Kpathsea to find the TFM and GF/PK font files?
14:07:14 <zzo38> (dvi-processing can already read TFM files)
14:08:57 <tgeeky> zzo38: uhh, that program looks to be something of the type [Directory] -> FilePath
14:10:08 <tgeeky> zzo38: but you could directly use the C library it exports (if any), you could use the command line program that it builds (which I'd *guess* won't be cross-platform (I doubt it works right on Windows))
14:11:19 <zzo38> tgeeky: Well, there is options such as printer resolution and which printer the fonts are compiled for; so simply [Directory] -> FilePath doesn't work
14:12:40 <zzo38> ski: If you have a METAFONT program for Tengwar then it can work in Tengwar as well.
14:17:13 <zzo38> Is there a common way which I can access printer resolution and printable area, and then send the bitmap to print?
14:17:43 <Taneb> Can I provide an alternative if a pattern match in a do-expression fails?
14:17:57 <dmwit> Taneb: No, it will always call fail.
14:18:03 <dmwit> Taneb: You can do something like this, though:
14:18:10 <dmwit> do { x <- whatever; case x of {...} }
14:18:22 <Taneb> dmwit, thanks
14:18:42 <ski> zzo38 : .. i don't know that much about printing and font
14:19:02 <asante> can i read a bytestring from /dev/urandom with ByteString.readFile "/dev/urandom" ?
14:19:52 <tgeeky> might it just be faster to try it?
14:19:54 <zzo38> What I do know, is on Ubuntu, to print a TeX document I will just use   dvilj4 - < document.dvi | lp   and then it will print. But this is specific to UNIX and only for PCL printers.
14:21:11 <earthy> um
14:21:15 <asante> tgeeky: i get an "hFileSize: inappropriate type (not a regular file)" which i cannot explain.. cause in ghci everything worked fine.. so i just thought, someone could tell me, if its wrong anyway
14:21:21 <strager> I'm playing with HUnit and test-framework, and I'm wondering how I can add information to an assertion.  Specifically, I want to show the function inputs (in addition to output and expected).
14:21:29 <earthy> pdftex, anyone?
14:22:17 <earthy> zzo38: oh, wait, other type of question. printable area is in postscript printer description files
14:22:35 <earthy> which are published using e.g. Internet Printing Protocol, which is the protocol underlying e.g. CUPS
14:22:46 <earthy> lp is *old* style printing on unix
14:24:58 <zzo38> earthy: I know pdftex; but I just use dvilj4 and lp
14:25:22 <zzo38> (I don't have pdftex here; but some other people have tried to use pdftex with my documents and apparently some of them don't work with pdftex)
14:27:47 <monochrom> nice! if I have identifier x'y, haddock lets me write 'x'y' for hyperlinking to it :)
14:31:28 * hackagebot sparse-lin-alg 0.4 - Effective linear algebra on sparse matrices  http://hackage.haskell.org/package/sparse-lin-alg-0.4 (AlexeyAlekhin)
14:31:30 * hackagebot cmathml3 0.1 - Data model, parser, serialiser and transformations for Content MathML 3  http://hackage.haskell.org/package/cmathml3-0.1 (AndrewMiller)
14:58:34 <causative> has anyone worked out something like combinatory logic except where all functions commute?
15:00:32 <causative> where f(a,b) = f(b,a) for all f
15:03:15 <jonkri> what is the name of the concurrent channel implementation that supports reading events based on certain properties, such as priority?
15:03:25 <ski> causative : sounds very strange
15:03:39 <jonkri> s/events/values
15:08:05 <causative> it's difficult to even define any basic combinators that commute
15:08:17 <causative> that do anything
15:09:54 <ski> causative : well, i suppose one could consider symmetric polynomials ..
15:11:47 <jmcarthur> causative: you mean where function composition is commutative, or something else?
15:12:13 <causative> where each parameter of every function commutes with the other parameters of the function
15:12:23 <jmcarthur> oh, that's even tighter
15:12:37 <aristid> causative: does that apply to curried functions, too?
15:12:49 * ski would assume no curried functions in this formalism
15:13:14 <jmcarthur> which means it's probably first order, i guess
15:13:24 <carter> causative : if you are ok with 1 parameter being either anti commutative or not commutative, you can get something
15:13:49 <jonkri> is there a channel implementation which supports fifo and "lifo" inserts?
15:13:56 <carter> but I assume you mean a la sk combinators rather than predicated in FOL
15:14:08 <carter> in which case I have no clue
15:15:29 <ski> symmetric polynomials compose
15:15:32 <jmcarthur> jonkri: you could always just use an appropriate data structure with an MVar or STM or something
15:15:36 <causative> you could define a basic combinator that is not evaluated, that commutes in all parameters, like B a b = B b a, then you could define slightly more interesting combinators like C a b = B (a b) (b a)
15:16:01 <jmcarthur> jonkri: that is, if you need anything that might not exist already
15:19:13 <ski> causative : would symmetric polynomials, or something like that, be of interest ?
15:22:22 <ClaudiusMaximus> is there some State/Writer hybrid that also "tell"s every "put"?
15:22:23 <jonkri> it was http://hackage.haskell.org/packages/archive/cml/0.1.3/doc/html/Control-Concurrent-CML.html i was looking for earlier
15:25:08 <dmwit> ClaudiusMaximus: tellPut x = tell [x] >> put x
15:25:09 <dmwit> ;-)
15:26:30 <dobblego> there is a Reader/State/Writer hybrid
15:26:36 <dobblego> @hoogle RWST
15:26:36 <lambdabot> Control.Monad.RWS.Lazy RWST :: (r -> s -> m (a, s, w)) -> RWST r w s a
15:26:36 <lambdabot> Control.Monad.RWS.Strict RWST :: (r -> s -> m (a, s, w)) -> RWST r w s a
15:26:36 <lambdabot> Control.Monad.Trans.RWS.Lazy RWST :: (r -> s -> m (a, s, w)) -> RWST r w s m a
15:27:55 <dmwit> You could also newtype DebuggableStateT s m a = DebuggableStateT (WriterT [s] (StateT s m) a)
15:28:07 <dmwit> and then in your instance of MonadState, write a put that also tells
15:28:15 <dmwit> (and don't make an instance for MonadWriter)
15:28:37 <ClaudiusMaximus> dmwit: ah, that's indeed more along the lines of what i want
15:29:04 <ClaudiusMaximus> but i think i need to sit and think a bit more about what i actually need, rather than rushing into code without a clear idea
15:30:32 <ClaudiusMaximus> i'm trying to make a sequence of diagrams showing how an algorithm works, so a sequence of states would be a start, but i also want to highlight the differences between successive states
15:31:03 <irene-knapp> ahhh interesting approach
15:31:58 <irene-knapp> one solution would be to define a monad that's like
15:32:12 <irene-knapp> getField1, putField1, getField2, putField2
15:32:15 <irene-knapp> for every field in the state
15:32:27 <irene-knapp> then the sequence of differences just falls out
15:32:34 <irene-knapp> it's potentially a lot of boilerplate though
15:32:58 <dmwit> Making a good diagram will depend a lot on the algorithm.
15:33:24 <irene-knapp> if we had first-class lenses, …. :)
15:33:26 <dmwit> For example, lots of different people have made sorting diagrams showing the differences between the different sorting algorithms.
15:33:50 <dmwit> Second-class lenses seem fine.
15:33:58 <irene-knapp> oh, yeah, I remember Knuth has those railway-style diagrams showing the sequence of comparisons in sort algorithms
15:37:35 <ClaudiusMaximus> this is the particular algorithm i'm trying to visualize: https://gitorious.org/ruff/ruff/blobs/master/Fractal/RUFF/Mandelbrot/Address.hs#line400
15:53:35 <zzo38> I use TeX for many things on my computer; and on UNIX I do use lp to send things to the printer even in case you dislike it
15:55:03 <zzo38> Do you know about annotation monad/comonad?
15:55:32 <Senmorta> I don't
15:56:00 <zzo38> Do you know about the free Alternative/MonadPlus instance for (ContT r f) if f is Applicative and r is Monoid? I think there is possible to make up such a things but don't know how well its use
15:57:00 <Senmorta> I'm still learning and don't know much yet.
15:57:20 <zzo38> Does edwardk know about this things?
15:57:28 * edwardk looks up
15:58:21 <edwardk> makes sense, but you can simplify that
15:58:34 <edwardk> just think about Cont r a where r is a monoid
15:58:41 <edwardk> since the Applicative wrapped around the Monoid is just a fancy monoid
15:59:02 <edwardk> As for that, I do use it ;)
15:59:03 <zzo38> edwardk: True, it is; I have figured out how to make monoid from such Applicative too.
15:59:43 <edwardk> https://github.com/ekmett/algebra/blob/master/Numeric/Covector.hs
16:00:02 <edwardk> that is a version based on the use of linearity on 'r' to model covectors for a vector space
16:00:23 <edwardk> if you let addition be your monoid, you can see the connection
16:00:58 <edwardk> in particular the Monoidal r => Alternative (Covector r) instance
16:01:07 <edwardk> and Monoidal r => MonadPlus (Covector r)
16:01:29 <edwardk> now, you have to be careful though
16:01:38 <edwardk> because if you are after linearity then callCC actually violates it
16:01:50 <edwardk> so thats why Covector r is not an instance of MonadCont
16:03:29 <zzo38> As far as I can tell it can also make a ring from (Cont r a) if r is ring, although it will not be a computable ring.
16:05:21 <edwardk> zzo38: you have Covector r a = r^(r^a). Which admits a trivial coalgebra, giving you a ring, and since it can only inspect the (a -> r) a finite number of times you remain computable
16:05:28 <edwardk> subject to the unverifiable linearity constraint
16:05:38 <edwardk> you can make a version that enforces linearity but its terribly inefficient
16:06:28 <edwardk> the version i use requires you to explicitly supply a counital coalgebra
16:06:32 <edwardk> instance (Ring r, CounitalCoalgebra r m) => Ring (Covector r m)
16:06:39 <edwardk> rather than assume its the trivial coalgebra
16:07:56 <mm_freak> edwardk: why is your data-lens library based on a store and not just the getter and setter functions?
16:08:05 <edwardk> for most of my numeric types i actually augment it with the trivial counital coalgebra
16:08:18 <zzo38> Would it be possible to make a lens using StoreT instead of Store to make LensT?
16:08:30 <edwardk> mm_freak: i actually would like to break it up into a -> (b, b -> a) rather than its current form a -> Store b a
16:08:39 <edwardk> mm_freak: but there is a reason to fuse the two functions
16:08:54 <edwardk> http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio/5769285#5769285
16:08:57 <edwardk> talks a bit about it
16:09:11 <edwardk> otherwise mutations have to walk all the way down twice
16:09:18 <edwardk> rather than 'open' it and plug in the answer
16:09:36 <edwardk> which can make a big difference in the performance of the functor based lens operations
16:09:51 <edwardk> zzo38: the question then becomes what laws does it satisfy?
16:09:58 <edwardk> i'm relatively unhappy with partial lenses
16:10:09 <edwardk> they give pretty crappy laws
16:10:20 <zzo38> edwardk: Yes I think of it too
16:10:35 <edwardk> you can make store transformer coalgebras, just most are boring
16:11:50 <edwardk> roconnor did manage to put partial lenses on a pretty good footing though with (Identity :+ Store b) coalgebras though
16:13:23 <mm_freak> edwardk: i'm asking because i found data-lens to be extraordinarily fast…  switching to it sometimes even outperformed my more legacy ad-hoc code (probably because often i didn't bother to use sharing)
16:13:53 <mm_freak> i see how a -> (b, b -> a) makes more sense than (a -> b, b -> a -> a)
16:14:24 <edwardk> mm_freak: thats what i like to hear =)
16:15:30 <roconnor> edwardk: what's the difference between a -> (b, b -> a) and a -> Store b a?
16:15:41 <edwardk> roconnor: one is less scary to newcomers
16:15:56 <zhulikas> none
16:16:05 <mm_freak> well, the former misses some instances
16:16:08 <strager> @pl a <$> b <*> c
16:16:08 <lambdabot> a <$> b <*> c
16:16:15 <strager> @pl (,) <$> b <*> c
16:16:15 <lambdabot> (,) <$> b <*> c
16:16:20 <edwardk> roconnor: and might get better optimizations spotted because it doesn't have the T version mucking up its internals
16:16:41 <mm_freak> strager: code without lambdas is already pointfree
16:16:59 <strager> I was thinking maybe @pl would rewrite it into something nicer-looking for me anyway ;P
16:17:01 <mm_freak> strager: @pl does not perform the transformation for applicative points
16:17:10 <mm_freak> well:  liftA2 (,) b c
16:17:11 <mm_freak> =)
16:17:11 <edwardk> roconnor: the main problems facing lenses are lack of adoption, so anything that simplifies the presentation strikes me as good
16:17:21 <strager> Not much prettier
16:17:27 <mk> if a typeclass defines 2 functions (methods?), can more functions be added to it later?
16:17:30 <edwardk> but i do love the coalgebra presentation
16:17:37 <mm_freak> well, on a single line i find liftA* easier to read than <*>
16:17:50 <mm_freak> on multiple lines i usually prefer <*>
16:18:15 <mm_freak> mk: classes can't be extended, but they can be subclassed
16:18:31 <mm_freak> class (Functor f) => Applicative f
16:18:45 <mm_freak> class (GameObject a) => EnemyObject a
16:18:55 <edwardk> mk: if you wrote the typeclass you are of course free to go edit the source file, you can also make subclasses of that class that have more things, or later on edit it and add more methods possibly with default signatures if possible to avoid breaking existing users
16:19:18 * BMeph likes to "newc" newcomers...
16:19:23 <mk> in order to implement the class, must all of the specified functions be implemented?
16:19:48 <mm_freak> mk: missing functions cause a compiler warning, but not an error
16:20:03 <mm_freak> mk: you can provide default implementations in the class itself
16:20:17 <edwardk> mk: if you don't implement them you get a warning at compile time and an error at runtime when you invoke them
16:20:22 <mk> I would have guessed it was an error - why only a warning?
16:20:32 <mm_freak> class Eq a where (==), (/=) :: a -> a -> Bool; x /= y = not (x == y)
16:20:52 <mm_freak> mk: probably historical…  view that warning as an error
16:21:33 <mk> edwardk: mm_freak: thanks
16:23:02 <strager> Hmm, is it possible to hide warnings occuring within a template instantiation (Template Haskell)?
16:23:33 <strager> Apparently a name is clashing (shadowing) in a template I have little control over.
16:23:34 <ByronJohnson> mk: AFAIK: it should be an error, but isn't; an exception will be thrown if you evaluate a method that doesn't exist, IIRC.
16:24:57 <mm_freak> strager: unfortunately no
16:25:26 <mm_freak> you could move the template invocation to a separate module and set the warnings for that module using the OPTIONS_GHC pragma
16:28:53 <strager> Well I'm using the template in a bunch of modules so that's not an good option.  =]  I think I'll just disable that specific warning (name shadowing) for those modules.
16:31:55 <mm_freak> strager: huh?  that sounds like it would be a good option to me
16:32:26 <mm_freak> ML style functors would really help here
16:32:47 <mm_freak> module MyModule x = myTemplate x
16:38:52 <hiroaki> #yesod
16:39:10 <ssbr_> How should I explain datatypes and the difference between a value constructor and a value?
16:39:54 <ssbr_> I think of them in the same terms that I think of e.g. functional terms, and don't remember how I learned
16:39:59 <ssbr_> (functional terms from Prolog)
16:40:52 <ski> hm, is there any lens package that allows you to combine `IORef a' with `Lens a b' ?
16:42:07 <ski> shergill : a data constructor ("functor" in Prolog) takes `n' argument values and packages them up into a single compound value, which can later be decomposed
16:42:11 <ski> we
16:42:12 <ski> er
16:42:15 <ski> ssbr_ ^
16:44:29 <strager> mm_freak: I would have to make one module for each module which uses the template.  And actually, I can't do that, because the template depends on the module itself (as it looks at declared functions).
16:44:37 <strager> mm_freak: (This is test-framework-th)
17:02:48 <ClaudiusMaximus> dmwit: i ended up just using Writer, http://hpaste.org/66341
17:03:24 <dmwit> great =)
17:03:36 <ivanm> oh, yay, when parsing in data and then trying to assign unique IDs, it looks like I have to provide temporary IDs first and then go through and give them all real ones afterwards :s
17:04:20 <aristid> ClaudiusMaximus: signature on wakees might make the code more readable
17:05:01 <ClaudiusMaximus> aristid: i didn't feel like figuring it out, could ask GHCI i guess
17:05:45 <aristid> oO
17:06:19 <aristid> ClaudiusMaximus: oleg omits type signatures because they are obvious to him. you omit them because you don't feel like figuring them out? :)
17:07:17 <ClaudiusMaximus> aristid: i omitted them because i kept getting it wrong and it wouldn't compile, once it compiled i didn't care enough to add them
17:08:33 <ClaudiusMaximus> aristid: it's (Rational, Rational) -> Integer -> Writer [Log] [(Rational, Rational)]   (or something roughly equivalent)
17:09:48 * ski knows Hughes usually codes without signatures
17:09:56 <aristid> :)
17:12:08 <Saizan> ghci is so much better at writing signatures most of the time,
17:12:55 <elliott> <ski> hm, is there any lens package that allows you to combine `IORef a' with `Lens a b' ?
17:13:32 <elliott> ski: you can always do: with :: IORef a -> State a b -> IO b; with ref = atomicModifyIORef ref . runState
17:13:43 <elliott> (and use the state-based combinators they all provide)
17:13:48 <parcs`> there's StateVar
17:14:07 <ski> elliott : i meant combine into a single reference-like thing
17:14:48 <elliott> i don't quite understand, then
17:15:26 <ski>   data LensRef ref lens b = forall a. LR (ref a) (lens a b)
17:15:48 <ski>   instance MonadRef (LensRef IORef Lens) IO
17:15:54 <ski> or something along those lines
17:16:32 <ski> i want to be able to compose an `IORef', or `STRef s', with a lens, and get something i can use more or less as `IORef'/`STRef s'
17:16:45 <mm_freak> newtype Lens (>~) a b = Lens (a >~ (b, b >~ a))
17:16:45 <elliott> ah
17:16:58 <elliott> ski: well, you can give a StateVar instance like that, yes
17:17:06 <mm_freak> fstDebug :: Lens (Kleisli IO) (a, b) a
17:17:14 <elliott> mm_freak: that's a poor definition if you want e.g. Lens Maybe for a partial lens
17:17:24 <elliott> (since the inner (>~) can lie and return Nothing on you)
17:17:27 <ski> mm_freak : well, that's a different thing from what i was talking about
17:17:36 <mm_freak> elliott: true
17:17:59 <ski> elliott : `StateVar' ?
17:18:03 <danharaj> Is there a standard reference for lens?
17:18:10 <elliott> ski: http://hackage.haskell.org/package/StateVar, it's used by OpenGL
17:18:18 <elliott> danharaj: depends what you mean by reference, I like this SO answer:
17:18:31 <mm_freak> ski: well, what are you talking about?  lenses for mutable data?
17:18:36 <elliott> danharaj: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
17:18:55 * ski was just about to hand danharaj that link :)
17:19:18 <ski> mm_freak : see `LensRef' above. plug any standard lens into `lens'
17:19:19 <elliott> danharaj: the simplest description is simply: Lens a b lets you get a b from an a, and change the b in an a; think Lens Record Field
17:19:28 <elliott> *a "b" from an "a", and change the "b" in an "a"
17:19:54 <danharaj> thanks.
17:19:58 <ski> mm_freak : then define `readRef' and `writeRef' for `LensRef', in terms of operations on `IORef', and lens operstions
17:20:37 <danharaj> Wasn't there a PL based on lenses?
17:20:38 <ski> mm_freak : i want to be able to treat parts of an `IORef Foo' mostly as if they were individual `IORef's
17:20:48 <elliott> ski: it would be nice if IORef had a Somethingfunctor instance (whichever one is both co and contra)
17:20:54 <elliott> so you could build things like that yourself
17:21:05 <mm_freak> ski: i see
17:21:14 <elliott> danharaj: maybe you're thinking of lenses in the bananas, lenses, envelopes and barbed wire sense?
17:21:20 <elliott> danharaj: I doubt it, since Lenses are a pretty trivial concept really
17:21:21 <ski> elliott : well, you can easily build `ReadIORef' and `WriteIORef', the first of which is covariant, the second contravariant
17:21:29 <elliott> I don't see how you could build a language out of them
17:21:36 <mm_freak> ski: and you want to be able to perform side effects while modifying?
17:21:38 <danharaj> I remember now
17:21:39 <danharaj> http://www.seas.upenn.edu/~harmony/
17:21:47 <jonkri> given newtype XMPPT m a = XMPPT { runXMPPT :: StateT (State m) m a }  and  stateLoop :: MonadIO m => XMPPT m ()  and  execStateT stateLoop (State chan idGen []), what does the error "Couldn't match expected type `StateT a0 m a1' with actual type `XMPPT m0 ()'" mean?
17:21:50 <elliott> ski: sure
17:22:01 <elliott> ski: but the former might as well be IO, latter is pretty useless without the former
17:22:14 <elliott> jonkri: it means you used an XMPPT where a StateT was expected
17:22:22 <ski>   data ReadRef ref b = forall a. RRef (ref a) (a -> b)
17:22:23 <ski>   data WriteRef ref a = forall b. WRef (ref b) (a -> b)
17:22:24 <elliott> jonkri: you need to explicitly unwrap it from that constructor with runXMPPT to get a StateT
17:22:38 <ski> mm_freak : no
17:22:42 <elliott> ski: what I meant was, if IORef had such an instance, you could build your functionality for free, as
17:22:54 <elliott> mapRefL :: Lens a b -> IORef a -> IORef b
17:22:55 <mm_freak> ski: then is there anything wrong with modifyIORef together with a regular lens?
17:23:26 <mm_freak> modifyIORef myRef (a . b . c ^= 3)
17:23:35 <ski> mm_freak : i want `readRef :: LensRef IORef Lens a -> IO a',  `writeRef :: LensRef IORef Lens a -> a -> IO ()',  `modifyRef :: LensRef IORef Lens a -> (a -> a) -> IO ()'
17:23:42 <elliott> danharaj: i don't think that's the same kind of lens
17:23:53 <elliott> hmm, actually it might be
17:23:57 <elliott> i think i've heard of this language before actually
17:24:36 <mm_freak> ski: except the explicit call to readRef/writeRef/modifyRef that really still sounds like regular lenses could do that easily
17:24:46 <mm_freak> maybe i'm misunderstanding the problem
17:24:47 <jonkri> elliott, great explanation! thanks :)
17:24:48 <ski> mm_freak : nothing wrong with that, except that sometimes one'd like to package the `myRef' and the lens as a single abstract reference, and possibly send it to polymorphic code which doesn't know whether it's using `IORef' or an abstraction on top of it
17:25:26 <ski> elliott : "the former might as well be IO" meaning ?
17:25:45 <mm_freak> well, you could define:  data LensRef ref a b = LensRef (ref a) (Lens a b)
17:26:08 <ski> is there a point to not hiding the `a' here ?
17:26:29 <mm_freak> well, you could hide it
17:26:30 <elliott> ski: well, why do you care when you would have a (ReadIORef a) vs. a (IO a)?
17:26:38 <elliott> *an, to taste
17:26:50 <mm_freak> data LensRef ref a = forall a'. LensRef (ref a') (Lens a' a)
17:27:03 <ski> elliott : an `IO a' could do anything, any I/O effects. a `ReadIORef a' couldn't
17:27:11 <elliott> ski: fair enough
17:27:18 <elliott> ski: you could see that as a disadvantage :)
17:27:35 <ski> mm_freak : yeah, which is basically my version
17:27:51 <mm_freak> ski: i see
17:27:55 <elliott> who uses IORefs, anyway :)
17:28:10 <mm_freak> well, 'ref' could be anything
17:28:26 <mm_freak> but i think i mostly use lenses with acid-state
17:28:28 <ski> elliott : pondering `mapRefL :: Lens a b -> IORef a -> IORef b' .. "what I meant was, if IORef had such an instance, you could build your functionality for free, as" -- "such an instance" referring to ?
17:29:16 <ski> elliott : "you could see that as a disadvantage :)" -- *nod*, goes both ways
17:29:46 <JoeyA> Do any of the GUI packages (wxHaskell, Gtk2Hs, etc.) work on GHC 7.4 yet?
17:29:49 <mm_freak> ski: i wonder if it's not smarter to pass the reference with a polymorphic type and a lens to deal with it
17:29:56 * ski looks at `Data.StateVar'
17:30:00 <mm_freak> myModifier :: IORef a -> Lens a Int -> IO ()
17:30:01 <JoeyA> I'm trying to build wxcore, but it's taking more RAM than I have.
17:30:24 <mm_freak> myModifier couldn't possibly do anything to the 'a', but it can use and modify an Int property of it
17:30:24 <JoeyA> (might be able to build it by unpacking the source and building in pieces)
17:30:45 <ski> mm_freak : the difference (apart from not bundling together the two things in a conceptual single thing) ?
17:31:10 <elliott> <ski> elliott : pondering `mapRefL :: Lens a b -> IORef a -> IORef b' .. "what I meant was, if IORef had such an instance, you could build your functionality for free, as" -- "such an instance" referring to ?
17:31:12 <dcoutts_> JoeyA: yes, gtk2hs does
17:31:15 <elliott> ski: a Somethingfunctor, I forget the name exactly
17:31:24 <elliott> ski: the one with bothmap :: (a -> b) -> (b -> a) -> f a -> f b
17:31:26 <ski> i want to be able to pass it to functions with signature `foo :: MonadRef ref m => ref Foo -> ... -> m Blah'
17:31:27 <elliott> (it's not called bothmap)
17:31:34 <mm_freak> ski: well, i'm not sure this bundling is a good idea…  reading the type signature of myModifier i have a good idea about what it does
17:31:35 <elliott> oh, wait, mapRefL is actually more powerful than that
17:31:42 <elliott> Somethingfunctor restricts you to Iso, not Lens
17:31:43 <ski> where `ref' in this case would be instantiated to `LensRef IORef Lens'
17:31:44 <edwardk> elliott: invariant
17:32:00 <elliott> edwardk: thanks (is it in any common library?)
17:32:09 <elliott> (or uncommon library, I guess :))
17:32:43 <ski> elliott : anyway, i don't see how you could implement that `mapRefL' nicely
17:32:47 <edwardk> http://hackage.haskell.org/package/invariant
17:32:51 <ski> you could do something with threads, maybe
17:32:58 <mm_freak> too many layers of abstraction can make code harder to understand and to write
17:33:10 <mm_freak> i'd go with explicitly passing a reference and a lens
17:33:36 * ski smiles
17:33:38 <elliott> ski: I thought you could do it if IORef had bothmap, like I said, but you can't
17:34:39 <ski> elliott : anyway, `IORef' isn't a functor, but `ReadIORef' is (it is basically `CoYoneda IORef', and `CoYoneda f' is always a `Functor')
17:34:47 <elliott> edwardk: before clicking I would have bet large amounts of money that was your package :)
17:35:00 <edwardk> elliott: i did give him the idea for the name :)
17:35:02 <elliott> ski: yes, i never said it was a Functor :)
17:35:37 <elliott> edwardk: i think all of those Invariant instances are just Functors or Contravariants, heh
17:35:49 * ski wonders whether the two arguments of `invmap' are supposed to be inverses
17:35:54 <Orclev_> anyone on have experience with FRP, and reactive banana in particular?
17:35:59 <edwardk> elliott: he forgot Endo
17:36:15 <elliott> edwardk: ha
17:36:18 <elliott> Orclev_: some, yes
17:37:05 <mm_freak> Orclev_: FRP yes, reactive-banana no
17:37:27 <Orclev_> elliott: I've got a behavior that has a value that changes from time to time, but the event driving it has  bunch of duplicate values... is there any way for it to only trigger when the value actually changes? I thought that's what the changes function did, but apparently not
17:37:37 <JoeyA> dcoutts_: Thanks
17:38:18 <elliott> Orclev_: are these duplicates simultaneous? if so, use the "calm" function, if not, you could write a calmEq
17:38:23 <mm_freak> Orclev_: i don't know the internals of reactive-banana, but perhaps you can adapt netwire's 'diff' wire to it
17:38:41 <elliott> Orclev_: the changes function is for getting the underlying change event of a behaviour, it's for gluing to outside frameworks only
17:38:56 <Orclev_> if you represent the event stream as a list, what I'm looking for is something like nub
17:39:01 <elliott> yes, I understand :)
17:39:06 <elliott> Orclev_: but -- how are you observing this "trigger"?
17:39:22 <elliott> as in, behaviours offer no way to observe their changing in pure FRP code, so presumably you are using "changes"|, right?
17:39:45 <Orclev_> yeah, I'm feeding the event into changes, but it doesn't do what I thought it would
17:39:52 <elliott> "feeding the event into changes"?
17:39:57 <elliott> changes takes a behaviour, I don't understand
17:40:04 <Orclev_> I wrapped it in a stepper
17:40:14 <elliott> well... that's pointless,  changes (stepper x e) = return (calm e)
17:40:21 <elliott> in fact, that's changes's only law :)
17:40:35 <elliott> Orclev_: ok, let me try again: how do you know the behaviour is updating more often than you want it?
17:40:39 <elliott> i.e., how are you observing this fact?
17:41:17 <Orclev_> oh, I attached an IO action to it using the reactimate function... I wanted it to only fire when the value changed to something different
17:41:40 <elliott> ok, so... where is the behaviour here?
17:41:41 <Orclev_> sorry if this is a bit hard to understand I'm still trying to learn FRP
17:41:45 <elliott> reactimate takes an event
17:41:55 <Orclev_> the event is the one from changes
17:42:16 <elliott> but you said you only used changes in an attempt to get this behaviour from an event, no? :)
17:42:31 <elliott> _without_ anything you've tried to solve it, is there a behaviour at all?
17:42:37 <Orclev_> well, I used changes because I thought it would act like nub
17:42:42 <Orclev_> no
17:42:44 <JoeyA> Orclev_: Did you see that Elm thesis?  http://www.reddit.com/r/haskell//comments/rkyoa/my_thesis_is_finally_complete_elm_concurrent_frp/
17:42:58 <JoeyA> It is astoundingly accessible.
17:43:02 <elliott> Orclev_: ok, then you just want a calmEq
17:43:27 <Orclev_> elliott: sounds like that's about right... is that part of something, or something I need to write?
17:43:44 <elliott> Orclev_: you can write calmEq :: (Eq a) => Event t a -> NetworkDescription t (Event t a) easily, ideally it wouldn't have that NetworkDescription in there, it's common enough that I suggest adding a feature request on the issue tracker asking for it
17:43:48 <elliott> but, the former is easy to implement:
17:44:08 <mm_freak> reactive-banana is based on an applicative functor, isn't it?  if it uses the stream concept it shouldn't be too hard to port things from netwire to reactive-banana
17:44:13 <mm_freak> netwire has almost everything builtin
17:44:24 <Orclev_> mm_freak: yeah, it's applicative based
17:44:38 <Orclev_> I had seen netwire, but I haven't looked at it yet
17:44:49 <mk> is a function of type "a->m b" a suitable candidate for being pure/return, or must it have the form "a->m a"?
17:44:55 <elliott> mk: latter
17:44:56 <elliott> :t return
17:44:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:44:59 <elliott> :t pure
17:45:00 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
17:45:24 <mk> thanks
17:45:27 <Orclev_> mk: how would you determine the value to use for b given a?
17:45:36 <mm_freak> well, netwire is more powerful, but unfortunately also harder to learn…  also there is no GUI library based on netwire, because i haven't written it with GUIs in mind
17:45:54 * elliott isn't sure netwire will be more powerful once dynamic event switching is in?
17:46:04 <Orclev_> mm_freak: I'm actually trying to write a SDL adapter for reactive banana
17:46:19 <danharaj> What's a good fixity for type-level products and coproducts?
17:46:20 <mm_freak> elliott: what is that?
17:46:33 <danharaj> i.e. :+ and :*
17:46:41 <elliott> Orclev_: ugh, writing calmEq is actually pretty ugly
17:46:47 <elliott> you basically just use an IORef and construct a new AddHandler
17:47:03 <elliott> mm_freak: erm... http://apfelmus.nfshost.com/blog/2011/05/15-frp-dynamic-event-switching.html and http://apfelmus.nfshost.com/blog/2012/01/01-frp-api-0-5.html might help
17:47:36 * elliott doesn't see how reactive-banana is less powerful apart from (afaik) netwire having dynamic event switching and reactive-banana not having it just yet
17:47:59 <mm_freak> elliott: you mean something like yampa's rpSwitch?
17:48:40 <elliott> mm_freak: i don't know yampa -- the first blog post there explains it better than i could
17:49:01 * elliott isn't sure on what basis you're saying reactive-banana is less powerful, anyway, that was just my guess
17:49:07 <mm_freak> elliott: netwire has collections of behaviours that allow a behaviour to choose from this set
17:49:32 <mm_freak> basically yampa's rpSwitch, but much easier to use
17:49:58 <mm_freak> see the 'context' wire
17:50:01 <mm_freak> http://hackage.haskell.org/packages/archive/netwire/3.1.0/doc/html/Control-Wire-Trans-Combine.html
17:50:09 <elliott> maybe i should just ask what you meant by saying reactive-banana is less powerful :p
17:52:26 <mm_freak> well, as an example consider a label that should act like the behavior x when another control w has a certain value, otherwise it should act like y
17:52:43 <mm_freak> in netwire that's just:  x . require (== 15) . w <|> y
17:53:38 * elliott has never denied that netwire has dynamic event switching
17:53:55 <mm_freak> that's not dynamic event switching
17:54:20 <elliott> yes, it is
17:54:31 <mm_freak> dynamic event switching would be something like:  context x
17:54:37 <elliott> wait, no, it isn't
17:54:40 <mm_freak> where the current version of x is determined by the current context
17:54:40 <elliott> then i'm not sure what your point is :p
17:54:59 <mm_freak> the point is:  you can add such features easily without fearing any of the classic FRP problems
17:55:14 <mm_freak> the structure of netwire (or AFRP in general) makes sure that those can't happen
17:56:00 <mm_freak> the context wire has been there since version 1.0 and i've written a proof of concept web framework based on it, where i use it to distinguish between user sessions
17:56:13 <mm_freak> it's on hackage:  webwire
17:56:26 <mm_freak> it's based on an old version of netwire though
17:56:55 <mm_freak> it's really just that heinrich has much better PR than me…  i don't have the time to run an FRP blog =)
17:57:33 * elliott still doesn't know the answer to his question, but ok :P
17:59:50 <mm_freak> elliott: well, to answer your question the internal structure of wires is powerful enough to get along without ever needing switches or an explicit event type
17:59:57 <mm_freak> netwire has only a single type:  Wire
18:00:38 <elliott> *shrug* -- i'd say that's more a matter of taste than power; you can say that one type is simpler than two but that doesn't mean they're more powerful, imo
18:01:01 <JoeyA> In gtk2hs, where is 'set' documented?
18:01:23 <mm_freak> elliott: it's more powerful in the same sense that haskell is more powerful than C
18:01:30 <dcoutts_> JoeyA: glib
18:01:38 <JoeyA> Thanks
18:01:55 <elliott> mm_freak: i think that is a very biased view :)
18:01:58 <Orclev_> well, I thought I understood arrows, but looking at netwire apparently I don't
18:02:23 <mm_freak> Orclev_: you don't need arrows for netwire…  nowadays i'd recommend the applicative interface
18:02:36 <mm_freak> Orclev_: as said, netwire is more difficult to get into
18:02:55 <mm_freak> i'm writing it mainly for my own purposes, but i'd be happy to see other people use it =)
18:03:31 <mm_freak> elliott: you may want to look up a few of my old -cafe messages to see demonstrations
18:05:15 <mm_freak> AFRP is more powerful than traditional behavior-based FRP, yet nobody uses it (except me)…  the power lies in both flexibility and invariants…  it's about the same sad story as parsers
18:05:41 <mm_freak> arrowized parsers are more powerful, yet everybody uses traditional monadic parsers
18:11:15 <aristid> mm_freak: how are they more powerful?
18:12:52 <mm_freak> aristid: basically they can do what monadic parsers can do, but they also can perform some automatic optimizations that are impossible in the monadic framework
18:14:10 <aristid> mm_freak: because ArrowApply is not used automatically, unlike >>=?
18:14:21 <mm_freak> basically with an arrowized parser you can do a lot of things without backtracking
18:14:41 <mm_freak> aristid: for arrows without ArrowApply there is no equivalent to (>>=)
18:14:54 <mm_freak> but yes, the problem lies in (>>=), because its second argument is a function
18:15:46 <mm_freak> Category conceptually replaces m a -> (a -> m b) -> m b by m (a -> b) -> m (b -> c) -> m (a -> c)
18:15:59 <mm_freak> note how the 'm' is always directly accessible without ever needing to apply a function
18:16:57 <mm_freak> btw, when i say "arrowized" nowadays i think of it as a combination of Category and Applicative
18:20:25 <aristid> mm_freak: does netwire even have an instance of arrow, then?
18:20:54 <aristid> mm_freak: maybe you should, for marketing purposes, call it CAFRP or so, to get rid of the unbeloved Arrow word ;)
18:22:14 <mm_freak> aristid: yes, it does
18:22:22 <mm_freak> the arrow instance can be useful at times
18:22:35 <elliott> Call it Category Reactive Applicative Programming, or CRAP for short.
18:22:36 <aristid> do you use proc/do notation
18:22:38 <aristid> ?
18:22:39 <elliott> *Categorical
18:22:59 <mm_freak> aristid: sometimes
18:23:01 <aristid> elliott: that would bring the masses to it
18:24:15 <mm_freak> aristid: netwire does in fact support sequential programming…  imagine an HTTP bot that tries various things until it succeeds…  along the way switching and mutation may be involved
18:24:23 <mm_freak> like sidestepping to another procedure, etc.
18:25:07 <mm_freak> that's why the latest version of netwire, AFRP is just an example use case
18:26:30 <mm_freak> "… for arrowized functional reactive programming or automaton programming in general."
18:26:38 <aristid> mm_freak: if you have Applicative... would a Monad instance be possible? :)
18:26:51 <mm_freak> yes, but you wouldn't like it =)
18:26:58 <aristid> hmm
18:27:08 <mm_freak> a Monad instance is possible, but it would be a time leak no matter how you use it
18:27:59 <mm_freak> aristid: if you can write an efficient Monad instance for ZipList or ZipStream, please tell me =)
18:29:01 <aristid> mm_freak: i thought a Monad instance for ZipList was impossible?
18:29:02 <elliott> you can't write a monad instance for ZipList full stop
18:29:14 <mm_freak> the semantics should be:  do x <- [1,2,3]; y <- [x + 1, x - 1, 2*x]; return (x, y) = [(1,2), (2,1), (3,6)]
18:29:17 <mm_freak> you can
18:29:22 <mm_freak> but it will be a massive space leak
18:29:25 <aristid> no
18:29:32 <aristid> it won't follow the monad laws
18:29:54 <Orclev_> ok, I've been down this rabbit hole long enough... maybe I'm just doing things wrong... given a series of events like [1,3,4,5,8,20,21,22,23,24,27,30,31,33,34,42,43] how can I transform them to something of the form [0,2,3,4] (that is, the value of the 10s digit with no duplicates)? Is the answer still calmEq?
18:30:16 <mm_freak> which one will be broken?
18:30:23 <elliott> mm_freak: you can't
18:30:46 <elliott> this is a well-known fact, actually, i don't know who originally observed it or where a proof is (although iirc i've seen one)
18:30:57 <mm_freak> i'd like to see it
18:30:57 <elliott> but multiple people have tried, the problem is the non-rectangularity
18:31:30 <mm_freak> actually i'm not sure about ZipList
18:31:32 <elliott> join always ends up throwing away non-rectangular information you're not allowed to, or changing the shape to fit it in a way that breaks the laws
18:31:38 <elliott> mm_freak: does "conor mcbride said so" count as a proof?
18:31:39 <mm_freak> but i'm pretty sure you can write a Monad instance for ZipStream
18:31:50 <elliott> what is ZipStream? Reader Nat?
18:31:59 <elliott> in which case, yes, clearly
18:32:15 <mm_freak> ZipStream is ZipList without finite lists
18:32:23 <Saizan> > nub . map (`div` 10) $ [1,3,4,5,8,20,21,22,23,24,27,30,31,33,34,42,43]
18:32:25 <lambdabot>   [0,2,3,4]
18:32:49 <elliott> mm_freak: yes
18:32:52 <mm_freak> well, AFRP is ZipStream
18:32:55 <elliott> an infinite stream is isomorphic to (Nat -> a)
18:33:01 <scooty-puff-sr> ?unmtl WriterT [String] (ErrorT e m) a
18:33:01 <lambdabot> m (Either e (a, [String]))
18:33:14 <elliott> (btw, this is why I don't like AFRP... it either suffers from the "dense events" problem, or is not continuous at all)
18:33:35 <scooty-puff-sr> ?unmtl ErrorT e (WriterT [String] m) a
18:33:36 <lambdabot> m (Either e a, [String])
18:34:23 <mm_freak> well, the dense events problem can be solved…  you shouldn't set AFRP equal to yampa
18:34:28 <mm_freak> yampa suffers from a lot of problems
18:34:51 <elliott> i never set AFRP equal to yampa
18:35:22 <elliott> but, if you're saying that netwire is essentially a ZipStream-y model, then it's Nat -> a, and so does not have continuous time (which is what happens with an automaton arrow-based system)
18:36:26 <mm_freak> it's not Nat -> a…  in fact netwire has a notion of absolute time
18:36:41 <Orclev_> if I'm understanding correctly, "nub . map (`div` 10)" is equivalent to "calmEq $ (`div` 10) <$> einputs" correct?
18:37:17 <elliott> mm_freak: ZipList without finite lists _is_ Nat -> a
18:37:43 <mm_freak> elliott: AFRP is Nat -> a
18:37:46 <mm_freak> but netwire is not AFRP
18:37:54 <elliott> data ZipStream a = Cons a (ZipStream a); oneway 0 xs = xs; oneway n ~(Cons _ xs) = oneway (n-1) xs; theotherway f = Cons (f 0) (theotherway (f . succ))
18:38:09 <Orclev_> also, is there an implementation of calmEq somewhere I can look at to try and figure out how to implement it in reactive banana?
18:38:22 <elliott> Orclev_: well i started to write it
18:38:42 <elliott> it's nothing "clever", just ugly -- create a new event with newEvent, reactimate on all the occurrences of the input event, use an IORef to keep track of the last value so you know whether it's equal or not
18:39:10 <elliott> mm_freak: huh? netwire isn't AFRP? that directly contradicts what you said above...
18:39:19 <Orclev_> elliott: I started to do just that, but it was getting ugly so I wanted to verify if I was going down the right path
18:39:22 <mm_freak> netwire is an extension of AFRP
18:39:55 <mm_freak> AFRP is:  SF a b = DTime -> a -> (b, SF a b)
18:40:22 <mm_freak> netwire is:  Wire (>~) a b = a >~ (Maybe b, Wire (>~) a b)
18:41:02 <mm_freak> (conceptually…  the real type is slightly different)
18:41:07 <elliott> i think that's an unnecessarily restrictive definition of AFRP but ok -- that still doesn't have continuous behaviours though
18:41:29 <elliott> Orclev_: i can't think of anything nicer -- like i said, ask for a function of type calmEq :: (Eq a) => Event t a -> Event t a on the github issue tracker, it'd be useful
18:41:30 <mm_freak> it does…  note the absence of DTime
18:41:54 <mm_freak> a traditional behavior is a special case of Wire
18:42:12 <mm_freak> one that never mutates and always results
18:42:34 <kallisti> what does -fglasgow-exts enable exactly
18:42:59 <elliott> deprecation
18:44:28 <kallisti> elliott: oh thanks
18:44:34 <elliott> you aren't meant to use it, it's deprecate
18:44:34 <elliott> d
18:44:39 <kallisti> I know
18:44:42 <kallisti> that was not my question.
18:44:43 <elliott> k
18:44:51 <elliott> well the answer is in the ghc docs
18:45:20 <elliott> http://www.haskell.org/ghc/docs/7.4.1/html/users_guide/ghc-language-features.html#options-language
18:45:35 <mm_freak> among some language extensions it enables the nasty deprecation warning =)
18:46:43 <mm_freak> btw, i'd find something like -fglasgow-exts really useful for GHCi…  one that enables some common extensions
18:47:15 <elliott> just put it in ~/.ghci?
18:47:47 <mm_freak> well, you don't want to have them enabled all the time
18:49:08 <elliott> well, you can :def an alias for turning on lots of extensions with :set
18:49:25 <rasfar> is it just me, or do the GHC HTML pages pop up the page title over the cursor continuously (firefox and chrome)? grumble
18:49:34 <mm_freak> uh, didn't know about :def
18:49:37 <mm_freak> thanks
18:51:12 <elliott> rasfar: section title rather
18:53:23 <carter> as a sociological question: anyone else here observe the okcupid security vulnerability these weekend?
18:53:43 <elliott> er, you're in #haskell
18:59:14 <carter> it was sociological question
18:59:48 <carter> nevermind
18:59:57 <elliott> ...lol
19:00:03 <danthedev> lol
19:05:57 <rasfar> okay section title (as if that makes it better!) -- why oh why do that to the peeps? :(  thankfully Haddock doesn't do it to the API pages.
19:06:15 <elliott> rasfar: because the element enclosing each section has a title attribute
19:06:22 <elliott> which should probably be removed :)
19:07:01 <rasfar> yeah i know the low-level cause; i've written scripts to fix it on my local files.  glad you agree it should be removed.
19:07:47 <rasfar> (i volunteer to do that if there's interest)
19:10:14 <elliott> well it's not in anything the ghc devs control afaik
19:10:19 <elliott> it's docinfo or something
19:10:24 <elliott> not docinfo
19:10:25 <elliott> docbook
19:12:47 <rasfar> oh i see.  i wonder what the docbook rationale is for that?  there must be a reason.  a HXT postprocessing pass might be in order.
19:13:14 <elliott> well it is possible that the title attribute is semantically appropriate there
19:13:19 <elliott> and just has undesirable behaviour with common user agents
19:13:47 <elliott> HXT postprocessing would add a bunch of boot libs, it'll have to be a perl script ;)
19:15:15 <rasfar> ah, right.  then i'd have to learn perl (i did it using some mixture or ed, ex and vim batch mode iirc)
19:15:31 <rasfar> *mixture of
19:17:02 <elliott> I'd suggest going upstream to the docbook to HTML people really
19:17:08 <elliott> better than propagating perl
19:19:34 <rasfar> ah, right.  then i'd have to learn perl (i did it using some mixture of ed, ex and vim batch mode iirc)
19:19:43 <rasfar> maybe there's a docbook configuration setting, i'll try to find out...
19:19:47 <magicman> @pl \x y f -> f x y
19:19:47 <lambdabot> flip . flip id
19:20:32 <elliott> rasfar: i have this funny feeling of deja vu...
19:21:57 <rasfar> wouldn't surprise me; it's extremely annoying, someone must have tried before
19:22:18 <elliott> rasfar: i meant
19:22:19 <elliott> <rasfar> ah, right.  then i'd have to learn perl (i did it using some mixture or ed, ex and vim batch mode iirc)
19:22:20 <elliott> [...]
19:22:22 <elliott> <rasfar> ah, right.  then i'd have to learn perl (i did it using some mixture of ed, ex and vim batch mode iirc)
19:22:23 <elliott> :)
19:24:09 <rasfar> oh, sorry -- i was disconnected, thought that line didn't make it
19:36:27 <JoeyA> With Gtk2Hs TreeView, how does it know how to render elements of a TreeStore?
19:36:40 <JoeyA> I'm not seeing any type class contexts that would tell it that.
19:36:41 * hackagebot hOpenPGP 0.1 - native Haskell implementation of OpenPGP (RFC4880)  http://hackage.haskell.org/package/hOpenPGP-0.1 (ClintAdams)
19:36:51 <JoeyA> treeStoreNew :: Forest a -> IO (TreeStore a)
19:37:04 <elliott> does it?
19:37:06 <JoeyA> treeViewNewWithModel :: TreeModelClass model => model -> IO TreeView
19:37:13 <elliott> I think it just renders labels and lets you get the corresponding values or something
19:37:17 <JoeyA> instance TreeModelClass (TreeStore a)
19:37:17 <dmwit> JoeyA: You might want to look at the TreeView demo code.
19:37:22 <dmwit> JoeyA: I found it very enlightening.
19:37:27 <JoeyA> Thanks
19:37:28 <elliott> note: I'm just inferring from my limited experience with gtk2hs, I've never used that part
19:38:15 <dmwit> It doesn't just render labels. It's quite complicated, actually.
19:38:50 <dmwit> JoeyA: Do you have the demos lying around? They're in gtk/demo/treelist if you have a copy of the repository.
19:39:00 <dmwit> If not, I can upload one or two to hpaste if you like.
19:39:38 <JoeyA> I'll find them ;-)
19:39:56 <JoeyA> Unless a raptor chews up my network cable because I used goto a few weeks ago.
19:40:15 <JoeyA> By the way, I'm quite pleased with Gtk2Hs.  I was able to implement my favorite programmer-usability test of GUI frameworks:
19:40:18 <hpaste> “Joey Adams” pasted “Implementing something that should be easy in Gtk2Hs is easy enough” at http://hpaste.org/66345
19:40:45 <JoeyA> I like being able to say "containerAdd" instead of (stuff I can't remember)_pack_(stuff I can't remember)
19:59:45 <rasfar> for the record, this SO question has an answer to the tooltip issue:
19:59:55 <rasfar> http://stackoverflow.com/questions/6448355/docbook-xsl-how-do-i-stop-html-generation-from-outputing-a-title-attribute
20:32:36 <kallisti> > [x+y | x<-[1..] | y<-[1..]]
20:32:37 <lambdabot>   [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,...
20:34:09 <kallisti> > [x | x<-[1..], then take 5]
20:34:10 <lambdabot>   Illegal transform or grouping list comprehension: use -XTransformListComp
20:41:14 <kowalej> When I use Maybe, in the condition where I return Nothing, how can I also output an error message with this?
20:41:26 <dmwit> Use Either instead.
20:41:38 <dmwit> e.g. Either String theTypeOfTheActualResultYou'reInterestedIn
20:45:33 <Veinor> why do i have a horrible urge to use unsafeinterleaveio
20:46:21 <elliott> you restrain yourself to unsafeInterleaveIO?
20:46:27 <elliott> every week I have to convince myself I don't really need an unsafeCoerce
20:46:46 <shachaf> Veinor: Better to return . unsafePerformIO! The "return" makes it safe.
20:47:08 <shachaf> You can also do return . f . unsafePerformIO and that makes the whole thing safe.
20:47:52 <Veinor> i want to do something similar to sqlalchemy's whole thing where you can use post.tag[0].slug and that will perform the necessary sql lookups
20:50:26 <DijkstraGroupie> Does Haskell provide a function that returns the index of the first ocurrence of an element in a list?
20:50:29 <kowalej> dmwit: Thanks again, took awhile to figure out I needed to use "Left"/"Right" but I got it working
20:51:01 <Veinor> @hoogle (Eq a) => [a] -> a -> Maybe Int
20:51:02 <lambdabot> Data.List elemIndex :: Eq a => a -> [a] -> Maybe Int
20:51:02 <lambdabot> Data.Sequence elemIndexL :: Eq a => a -> Seq a -> Maybe Int
20:51:02 <lambdabot> Data.Sequence elemIndexR :: Eq a => a -> Seq a -> Maybe Int
20:51:04 <elliott> @hooogl e
20:51:04 <lambdabot> Prelude data Either a b
20:51:04 <lambdabot> Data.Either data Either a b
20:51:04 <lambdabot> Prelude either :: (a -> c) -> (b -> c) -> Either a b -> c
20:51:05 <elliott> dammit
20:51:06 <dmwit> kowalej: You can use "return" and "fail" if you like.
20:51:39 <dmwit> "throwError" is conceptually cleaner than "fail".
20:51:56 <elliott> Veinor: you could define an Applicative for access to nested database structures
20:51:57 <DijkstraGroupie> Thanks.
20:52:06 <elliott> that would also let you optimise queries behind the scenes without a ton of ugliness
20:52:13 <Veinor> like?
20:52:20 <elliott> "like?"? :)
20:52:24 <elliott> (but of course you still have to sprinke (<$>) and (<*>) everywhere unless you have idiom brackets)
20:52:24 <Veinor> i mean
20:52:27 <Veinor> how would i do that
20:53:19 <ski> @type \f -> return . f . System.IO.Unsafe.unsafePerformIO
20:53:20 <elliott> well, i didn't think that far :) but you could have e.g. tags :: DB Post -> DB [Tag] or such, building up a tree
20:53:20 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a) -> IO a1 -> m a
20:53:39 <kowalej> dmwit: These are used in conjunction with Either?
20:53:45 <elliott> Veinor: anything's nicer than unsafeInterleaveIO, anyway, esp. since when the IO happens really matters in your case
20:53:50 <elliott> (since the database can change over time, etc.)
20:53:56 <Veinor> elliott: yeah, i wasn't seriously tempted to do unsafeInterleaveIO :)
20:55:13 <dmwit> kowalej: yes
20:55:49 <notthemessiah> anyone here have much experience with monte carlo simulations?
20:58:58 <Veinor> elliott: the other thing i was considering was something like data LoadedPost = LoadedPost Post [Tag] and load :: Post -> DB LoadedPost
20:59:17 <elliott> Veinor: that would work, but means you unconditionally load every tag
20:59:21 <kowalej> dmwit: Ok I just did it using the error function now, without using Either
20:59:23 <Veinor> right
20:59:26 <elliott> Veinor: which is probably fine for tags of course
20:59:43 <dmwit> kowalej: error was not one of my suggestions; that's a bad idea in the long run.
20:59:52 <Veinor> your way is more efficient if i won't always need the tags, mine is  more efficient if i might need the tags in multiple parts and don't want to pass them around
21:00:02 <dmwit> kowalej: (Because it throws an exception, which can't be dealt with in pure code.)
21:00:33 <Veinor> then again given that any sensible database engine is going to cache the result of tags anyway...
21:01:43 <kowalej> dmwit: Oh, my bad
21:01:54 <kowalej> dmwit: I will do it your way
21:03:14 <nyingen> @quote
21:03:14 <lambdabot> gzl says: [on why monads are scary] maybe it's because people look up monad on wikipedia, find the category theory page, and crap themselves
21:03:46 <iFire> is that true?
21:03:49 <elliott> Veinor: yeah, but imagine something other than tags
21:03:52 <iFire> I'm new to haskell.
21:03:58 <elliott> iFire: is what true?
21:04:05 <iFire> [on why monads are scary]
21:04:09 <elliott> it's a joke
21:04:20 <elliott> Veinor: if you have 100 children of something you probably don't want to load them every time with the parent object, though
21:04:33 <iFire> I'm thinking of writing a sql database with redis
21:04:33 <Veinor> yeah
21:04:51 <iFire> from not knowing haskell
21:04:56 <Veinor> in python you can choose between lazy/strict loading
21:04:58 <DijkstraGroupie> @hoogle toUpper
21:04:59 <lambdabot> Data.Char toUpper :: Char -> Char
21:04:59 <lambdabot> Data.Text toUpper :: Text -> Text
21:04:59 <lambdabot> Data.Text.Lazy toUpper :: Text -> Text
21:05:14 <Veinor> that is, in sqlalchemy
21:16:44 <ski> iFire : have you found any tutorial or book to follow, yet ?
21:16:56 <elliott> @where lyah
21:16:56 <lambdabot> http://www.learnyouahaskell.com/
21:16:58 <elliott> They have now!
21:17:11 <iFire> ski got the learn you a haskell book
21:17:16 <iFire> it's beside me
21:17:20 <ski> nice :)
21:17:30 <elliott> They still make paper?
21:17:44 <iFire> I don't want to know where all the good bits go..
21:18:48 <iFire> I mean with electronic books.
21:21:58 <pdxleif> Are there folds / maps defined on trees?
21:22:10 <elliott> sure
21:22:22 <pdxleif> I mean like a rose tree or something - the specific case I had in mind was filesytem-like, like XML
21:22:34 <shachaf> @get-shapr
21:22:35 <lambdabot> shapr!!
21:22:44 <elliott> pdxleif: http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Tree.html
21:22:52 <elliott> Functor instance gives the map (fmap)
21:23:01 <shachaf> Wait, shapr isn't even here.
21:23:03 <elliott> ... no foldTree, interestingly
21:23:15 <elliott> but defining one should be easy, theoretically :P
21:23:38 <elliott> foldTree :: (a -> [b] -> b) -> Tree a -> b
21:23:39 <elliott> or such
21:23:49 <pdxleif> It says there's a Foldable instance
21:23:58 <pdxleif> I never even knew there was a Foldable typeclass
21:24:03 <elliott> foldTree f (Tree root forest) = f root $ map (foldTree f) forest
21:24:14 <elliott> pdxleif: oh, right -- you can use foldMap
21:24:17 <elliott>     foldMap f (Node x ts) = f x `mappend` foldMap (foldMap f) ts
21:24:23 <elliott> yeah, it has a tree-y foldMap
21:24:33 <pdxleif> Cool, thanks a bunch!
21:24:45 <elliott> (foldMap maps to a Monoid, then mappends them all)
21:24:57 <kallisti> what was the first language to employ type inference?
21:25:23 <ski> pdxleif : note that `Foldable' essentially means `Listlike', though
21:25:51 <pdxleif> So, I'd define a monoid instance for the structure I'm mapping to?
21:25:54 <elliott> ski: well, that's not really fair -- fold/foldMap makes it more "tree-like"
21:26:11 <elliott> pdxleif: depends what you're doing
21:26:43 <ski> @type Data.Foldable.foldMap
21:26:44 <lambdabot> forall a m (t :: * -> *). (Data.Foldable.Foldable t, Monoid m) => (a -> m) -> t a -> m
21:26:44 <Axman6> :t foldMap
21:26:45 <lambdabot> Not in scope: `foldMap'
21:27:14 <ski> elliott : that doesn't reflect the tree structure, only the linear ordering
21:27:42 <pdxleif> Specifically, I want to parse annotations (in attributes) out of XHTML, and build up a sub-tree of an RDF graph... a SPARQL CONSTRUCT statement or something.
21:27:45 <shachaf> foldMap is an abomination.
21:27:49 <shachaf> Well, a pseudo-abomination.
21:27:50 <ski> (how would you write `mirrorTree' using `foldTree', e.g. ?)
21:28:02 <shachaf> preflex: seen ddarius
21:28:02 <preflex>  ddarius was last seen on #haskell 24 days, 2 hours, 20 minutes and 29 seconds ago, saying: BMeph: No.
21:28:10 <shachaf> How ddariusy
21:28:46 <ski> kallisti : ML
21:28:54 <elliott> ski: well, yes, you can't reconstruct it
21:28:56 <elliott> it's for elimination only
21:28:59 <elliott> that's what Traversable is for
21:29:27 <ski> can you write `mirrorTree' using that ?
21:29:27 <elliott> fold :: (Monoid m) => t m -> m; sequenceA :: (Applicative f) => t (f a) -> f (t a) -- I don't see what's so listy about either of these, really
21:29:40 <elliott> the fact that foldr/l are class members is irrelevant, their default impls are awkward anyway
21:29:45 <ski> the monoid is listy
21:29:47 <elliott> ski: well, no again, since it preserves structure :)
21:30:03 <elliott> or rather...
21:30:09 <elliott> you might be able to with Cont actually
21:30:13 <ski> i can write it easily using `foldTree', otoh
21:30:23 <iFire> what's the difference between foldr and foldl
21:30:31 <elliott> > foldr f z [a,b,c,d]
21:30:32 <lambdabot>   f a (f b (f c (f d z)))
21:30:33 <elliott> > foldl f z [a,b,c,d]
21:30:34 <lambdabot>   f (f (f (f z a) b) c) d
21:30:48 <ski> (damn elliott and his fast fingers ;)
21:30:49 <elliott> or perhaps:
21:30:51 <elliott> > foldr f z [a,b,c,d]
21:30:52 <lambdabot>   f a (f b (f c (f d z)))
21:30:53 <elliott> > foldl (flip f) z [a,b,c,d]
21:30:56 <lambdabot>   f d (f c (f b (f a z)))
21:30:56 <elliott> might help you see more clearly
21:31:14 <elliott> right-associative vs. left-associative folds, basically
21:31:15 <iFire> foldr looks uh normal
21:31:23 <iFire> kinda like multipling
21:31:35 <elliott> multiplying?
21:31:40 <iFire> well
21:31:46 <iFire> the structure
21:31:55 <iFire> there's probably a hidden structure
21:32:07 <elliott> probably trying to understand foldr vs. foldl is pointless if you don't know any haskell yet :P
21:32:21 <elliott> or do you, I've lost track
21:32:21 <ski> > foldr (/) z [a,b,c,d]
21:32:22 <lambdabot>   a / (b / (c / (d / z)))
21:32:23 <ski> > foldl (/) z [a,b,c,d]
21:32:24 <lambdabot>   z / a / b / c / d
21:32:41 <iFire> O.o
21:33:04 <ski> @src and
21:33:04 <lambdabot> and   =  foldr (&&) True
21:33:06 <ski> @src or
21:33:07 <lambdabot> or    =  foldr (||) False
21:33:08 <iFire> > foldr (*) [a,b,c,d]
21:33:08 <lambdabot>   No instance for (GHC.Num.Num [SimpleReflect.Expr])
21:33:09 <lambdabot>    arising from a use of...
21:33:16 <iFire> > foldr (*) z [a,b,c,d]
21:33:17 <lambdabot>   a * (b * (c * (d * z)))
21:33:23 <iFire> > foldl (*) z [a,b,c,d]
21:33:24 <lambdabot>   z * a * b * c * d
21:33:31 <ski> @src maximum
21:33:31 <lambdabot> maximum [] = undefined
21:33:31 <lambdabot> maximum xs = foldl1 max xs
21:33:54 <iFire> so left is normal order
21:33:58 <elliott> no
21:34:08 <elliott> i'm sure lyah explains it well in good time :P
21:34:12 <iFire> z * [a,b,c,d]
21:34:15 <elliott> (I don't remember lyah talking about the folds but surely it does)
21:34:19 <elliott> iFire: erm...
21:34:32 <iFire> [] being a list
21:34:36 <iFire> tuple
21:34:42 <iFire> hmm
21:34:43 <elliott> lists aren't tuples
21:34:50 <elliott> and you can't multiply lists by integers :)
21:34:53 <elliott> (assuming z is an integer)
21:35:07 <iFire> .
21:35:13 <ski> > let f a b = 10 * a + b  in  foldl f 0 [1,2,3,4]
21:35:14 <lambdabot>   1234
21:35:15 <ski> > let f b a = 10 * a + b  in  foldr f 0 [1,2,3,4]
21:35:16 <lambdabot>   4321
21:35:28 <elliott> iFire: do you know any haskell yet?
21:35:29 <iFire> now I'm just confused
21:35:31 <iFire> not really
21:35:34 <iFire> I read the book
21:35:37 <iFire> but I don't understand it
21:35:45 <elliott> read it again, slower this time :)
21:35:59 <ski> > let f a b = 10 * a + b  in  foldl f 0 [1,2,3,4] :: Expr
21:36:00 <lambdabot>   10 * (10 * (10 * (10 * 0 + 1) + 2) + 3) + 4
21:36:08 <ski> > let f b a = 10 * a + b  in  foldr f 0 [1,2,3,4] :: Expr
21:36:09 <lambdabot>   10 * (10 * (10 * (10 * 0 + 4) + 3) + 2) + 1
21:36:22 <iFire> is this related to infix vs postfix
21:36:26 <elliott> no
21:38:15 <Veinor> does christopher done hang out in here?
21:39:59 <dmwit> ?seen chrisdone
21:39:59 <lambdabot> Unknown command, try @list
21:40:06 <dmwit> preflex: seen chrisdone
21:40:06 <preflex>  chrisdone was last seen on #haskell 1 day, 6 hours, 31 minutes and 7 seconds ago, saying: Phlogistique: could call it 'cond'  a la lisp
21:40:12 <iFire> hmm
21:40:21 <iFire> do you guys recommend an irc bot?
21:40:25 <iFire> I heard about lamdabot
21:40:34 <dmwit> Recommend it for what?
21:40:35 <iFire> maybe playing with a both is good to learn
21:40:47 <iFire> I'm thinking of creating a bot for my channel
21:40:51 <iFire> it's for game development
21:41:19 <dmwit> Yes, that sounds like a good way to learn Haskell.
21:41:28 <dmwit> ?google build an irc bot haskell
21:41:32 <lambdabot> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
21:41:33 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
21:42:03 <iFire> on ubuntu 12.04
21:42:13 <iFire> I think the haskell platform is new enough
21:42:26 <iFire> 7.4.1
21:43:01 <iFire> ooh and I can maybe learn that database thing
21:44:30 <kaitocracy> hi can someone explain to me what conduit is for? The Yesod book says that it's to guarantee release of resources when performing lazy IO, but isn't that what resourcet is for?
21:48:22 <realitygrill> i have a question... so i am a beginning programmer
21:48:53 <ski> please state your question
21:49:02 <dmwit> Don't ask to ask, just ask. If someone knows, they'll answer.
21:49:02 <realitygrill> and basically all my experience is from watching the sicp videos (and now going through the book) .. i have the aim of learning haskell after
21:49:08 <realitygrill> sorry, i was just typing
21:49:18 <ski> no worry
21:50:09 <realitygrill> anyway i just tried to write a sample program and failed miserably; i'm thinking it's because i suck at thinking about state, or keeping track of it
21:50:54 <realitygrill> should i go off and learn imperative stuff now or just keep going?
21:51:19 <realitygrill> i guess what i'm asking is if keeping track of state is a separate skill to be cultivated outside of this fun FP stuff
21:51:34 <monochrom> must you have state?
21:52:00 <realitygrill> i have no idea. the problem was to give coordinates of saddle points in a 5x5 matrix
21:52:00 <dmwit> Don't give up.
21:52:14 <realitygrill> ok :)
21:52:38 <monochrom> then you don't need state. do it functionally.
21:52:55 <realitygrill> i was getting all screwy trying to pass around the coordinates so i could list them out..
21:53:04 <realitygrill> ah.. i don't see how yet
21:54:40 <monochrom> if I were given a list and were to find the position of a minimum, the position, the index, not just the value of the minimum...
21:54:54 <iFire> is there a default haskell project folder style?
21:55:01 <iFire> I mean organization.
21:55:04 <monochrom> I would first turn the list [a,b,c,d] into [(a,0), (b,1), (c,2), (d,3)]
21:55:34 <monochrom> at least, as my first simplistic approach
21:55:37 <dmwit> iFire: Yes. Module Foo.Bar.Baz should go in Foo/Bar/Baz.hs.
21:55:46 <dmwit> (Or Foo/Bar/Baz.lhs, of course.)
21:56:34 <realitygrill> monochrom: oh, hm, that's a good idea
22:31:12 <ivanm> the docs for Data.Attoparsec.Combinator use a function called "symbol" in the examples; is that a copy-paste error from parsec?
22:31:28 <ski> (:
22:31:50 <free_beard> thx, didn't realize i didn't connect
22:32:05 * ski suspected so
22:33:58 <nyingen> @quote
22:33:59 <lambdabot> sixthgear says: "apparently, i procreated at some point"
22:51:05 <JoeyA> What's a good way to launch an external program from Haskell?  I don't care about its output, except that I don't want it to appear in the caller's console.
22:51:28 <geekosaur> see System.Process
22:58:01 <monochrom> open /dev/null for writing and tie that to the program's stdout
22:59:45 <JoeyA> That's platform-specific and vague...
23:00:28 <dmwit> April Fool's! That's not the best way at all.
23:04:22 <ClaudiusMaximus> i'm guessing an inefficient way is runInteractiveProcess with forkIO (forever (hGetChar handleOfProgramStdOut))
23:06:19 <JoeyA> What if I just use CreatePipe and mapM_ hClose stdin, stdout, and stderr?
23:06:48 <JoeyA> Err, mapM_ hClose [stdin, stdout, stderr]
23:08:07 <ClaudiusMaximus> possibly your external program will crash with SIGPIPE when it tries to IO
23:08:51 <JoeyA> That's what I was thinking might happen.
23:13:50 <JoeyA> I guess I'll just fork a thread and have it swallow bytes using ByteString.hGetSome
23:14:38 <|Steve|> You can't close it and then have it read from/write to /dev/null?
23:14:58 <geekosaur> ^^
23:14:58 <JoeyA> 1) How would I do that?  2) How would I do that on Windows?
23:15:07 <geekosaur> Windows calls it NUL or NUL:
23:17:26 <JoeyA> Hmm, I'm not sure this would work for the process's stdin.  For that, I would have to arrange to prevent the Handle from getting GCed somehow.
23:30:52 <geekosaur> hm?
23:46:48 * hackagebot iproute 1.2.5 - IP Routing Table  http://hackage.haskell.org/package/iproute-1.2.5 (KazuYamamoto)
