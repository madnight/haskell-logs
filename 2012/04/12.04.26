00:04:58 <Sgeo> What if you're just playing a board game with a friend?
00:40:04 <mysticc> > [0.0,0.2..1]
00:40:04 <lambdabot>   [0.0,0.2,0.4,0.6000000000000001,0.8000000000000002,1.0000000000000002]
00:40:36 <mysticc> >[0.1,0.3..1]
00:40:43 <mysticc> > [0.1,0.3..1]
00:40:44 <lambdabot>   [0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
00:41:25 <dmwit> > [1,4..6.0]
00:41:26 <lambdabot>   [1.0,4.0,7.0]
00:41:39 <dmwit> > [1.5 .. 4]
00:41:40 <lambdabot>   [1.5,2.5,3.5,4.5]
00:41:43 <dmwit> > [1.5 .. 5]
00:41:43 <lambdabot>   [1.5,2.5,3.5,4.5,5.5]
00:42:12 <dmwit> Huh, I was expecting banker's rounding to come in. I guess not.
00:42:38 <ion> > [0.1,0.3..1] :: [CReal]
00:42:39 <lambdabot>   [0.1,0.3,0.5,0.7,0.9]
00:42:57 <mysticc> > [1,3..10]
00:42:57 <lambdabot>   [1,3,5,7,9]
00:43:03 <mysticc> > [1,3..10] :: [Double]
00:43:04 <lambdabot>   [1.0,3.0,5.0,7.0,9.0,11.0]
00:43:10 <mysticc> dmwit: ^^
00:43:20 <cmears> This behaviour caused me some trouble just a few days ago (:
00:43:22 <dmwit> mysticc: Still not banker's rounding.
00:43:50 <ion> cmears: Your mistake was using enumeration with floats. :-)
00:43:57 <cmears> Yes, exactly
00:44:14 <dmwit> > [0.1999999999999999999999999999999999999999999999999,0.4 .. 1] :: [CReal]
00:44:15 <lambdabot>   [0.2,0.4,0.6,0.8,1.0]
00:44:20 <dmwit> CReal is not immune from problems.
00:44:31 <dmwit> (Because it has an Eq instance for some reason.)
00:46:14 <dmwit> Oh, that example wasn't as damning as I could have made it. Let's see if the more damning one still works.
00:46:16 <ion> Something like “crealEq 100 a b” might be more sensible than the Eq instance. You pick the precision you deem appropriate.
00:46:35 <dmwit> > [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1]
00:46:36 <lambdabot>   [0.2,0.4,0.6000000000000001,0.8000000000000002,1.0000000000000002]
00:46:42 <dmwit> There we go.
00:46:45 <dmwit> That's pretty damning.
00:46:51 <dmwit> ack
00:46:57 <dmwit> > [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1] :: [CReal]
00:46:58 <lambdabot>   [0.2,0.4,0.6,0.8,1.0]
00:47:09 <dmwit> That last one compares as larger than 1. =)
00:47:43 <dmwit> > let [two,four,six,eight,appreciate] = [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1] :: [CReal] in appreciate - 1
00:47:44 <lambdabot>   0.0
00:47:46 <phryk> dcoutts: elliott, monochrom, rwbarton: Thanks for helping me out yesterday evening. On my desktop after deleting ~/.ghc and rebuilding everything I installed with cabal install, all works fine and is found :)
00:47:47 <dmwit> bleh
00:48:01 <dmwit> > let [two,four,six,eight,appreciate] = [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1] :: [CReal] in 1e30 * (appreciate - 1)
00:48:02 <lambdabot>   0.0000000000000000000001
00:48:29 <dmwit> ion: Yes, definitely.
00:48:36 <cmears> dmwit: is it just the printing that is rounding it to "1.0" ?
00:49:44 <ion> > map (showCReal 50) [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1]
00:49:45 <lambdabot>   ["0.2","0.4","0.6","0.8","1.0"]
00:49:53 <ion> > map (showCReal 100) [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1]
00:49:54 <lambdabot>   ["0.2000000000000000000000000000000000000000000000000001","0.40000000000000...
00:50:08 <ion> > (showCReal 100 . last) [0.2000000000000000000000000000000000000000000000000001,0.4000000000000000000000000000000000000000000000000001 .. 1]
00:50:11 <lambdabot>   "1.0000000000000000000000000000000000000000000000000001"
00:50:21 <osfameron> eeeek!
00:50:48 <dmwit> cmears: Unfortunately, no. The comparison operations (like (==)) are also rounding it.
00:50:49 <mysticc> @hoogle CReal
00:50:50 <lambdabot> No results found
00:51:03 <mysticc> :t CReal
00:51:04 <lambdabot> Not in scope: data constructor `CReal'
00:51:18 <mysticc> @hoogle showCReal
00:51:18 <lambdabot> No results found
00:51:42 <mysticc> ion: What is CReal ?
00:52:46 <ion> mysticc: It implements numbers as functions from the desired precision n to integers (that are scaled by 2^n).
00:53:02 <ion> http://hackage.haskell.org/packages/archive/numbers/3000.0.0.0/doc/html/Data-Number-CReal.html
01:01:00 <c_wraith> pi = 16 * atan (fromRational (1 % 5)) - 4 * atan (fromRational (1 % 239))
01:01:03 <c_wraith> wtf
01:01:31 <c_wraith> why is *that* the definition CReal uses?
01:01:45 <qnikst> > 16 * atan (fromRational (1 % 5)) - 4 * atan (fromRational (1 % 239))
01:01:46 <lambdabot>   3.1415926535897936
01:01:51 <Twey> ‘Close enough’?
01:01:58 <c_wraith> I'm sure it's exact
01:02:09 <c_wraith> Just...  Why that formulation?
01:02:12 <qnikst> yep, exact
01:02:18 <shachaf> c_wraith: What would you use?
01:02:24 <cmears> 22/7
01:02:54 <ion> > 4 * atan 1 :: CReal
01:02:54 <qnikst> c_wraith: what would be better, and work on all hosts?
01:02:55 <lambdabot>   3.1415926535897932384626433832795028841972
01:03:18 <shachaf> Hmm.
01:03:22 <c_wraith> something like ion's example seems much easier, yes
01:03:29 <c_wraith> still defined in terms of atan, even!
01:03:38 <ion> > ((==) `on` showCReal 200) (4 * atan 1) (16 * atan (1/5) - 4 * atan (1/239))
01:03:38 <lambdabot>   True
01:03:42 <ion> > ((==) `on` showCReal 1000) (4 * atan 1) (16 * atan (1/5) - 4 * atan (1/239))
01:03:45 <lambdabot>   True
01:03:59 <shachaf> Good point.
01:04:23 <c_wraith> qnikst: everything works on all hosts with CReal.  That's what I dug up the source for
01:04:47 <qnikst> > ((==) `on` showCReal 1000) (4 * atan 1)^3 (16 * atan (1/5) - 4 * atan (1/239))^3
01:04:48 <lambdabot>   No instance for (GHC.Num.Num GHC.Bool.Bool)
01:04:48 <lambdabot>    arising from a use of `GHC.R...
01:05:04 <qnikst> > ((==) `on` showCReal 1000) ((4 * atan 1)**3) ((16 * atan (1/5) - 4 * atan (1/239))**3)
01:05:05 <c_wraith> qnikst: doesn't parse the way you want
01:05:05 <lambdabot>   True
01:06:38 <randomclown> what's the function that lets you zip a list with it's index?
01:06:48 <randomclown> i'm not talking about zip [1..] xs
01:06:49 <c_wraith> zip
01:06:53 <adnauseam> zip
01:07:01 <ion> zip
01:07:05 <c_wraith> then... what do you mean?
01:07:22 <randomclown> hmm vagely remember something that did jsut that
01:07:29 <randomclown> doesn't matter
01:07:34 <shachaf> zip [0..] is pretty standard.
01:07:34 <ion> Also, [0..]
01:07:34 <adnauseam> zipping a list with it's index? hmm, zipWith ?
01:07:54 <adnauseam> then define  what the list's head is
01:08:12 <shachaf> Maybe you're thinking of Python. :-)
01:08:29 <adnauseam> i guess something along the lines of (\x:xs -> zipWith (x) xs) ?
01:08:36 <adnauseam> :[
01:08:57 <mysticc> @slap
01:08:58 * lambdabot will count to five...
01:09:03 <mysticc> @slap
01:09:03 * lambdabot smacks  about with a large trout
01:09:04 <adnauseam> =[
01:09:28 <ski> @botsmack
01:09:28 <lambdabot> :)
01:09:36 <mysticc> @botsmack
01:09:37 <lambdabot> :)
01:09:38 <mysticc> @botsmack
01:09:39 <lambdabot> :)
01:09:40 <osfameron> kinky bot ;-)
01:09:48 <osfameron> @botsnack
01:09:48 <lambdabot> :)
01:09:49 <mysticc> @slap lambdabot
01:09:49 <lambdabot> I don't perform such side effects on command!
01:09:59 <mysticc> hahahaa
01:10:03 <adnauseam> lol
01:11:04 <mysticc> @version
01:11:04 <lambdabot> lambdabot 4.2.2.1
01:11:05 <lambdabot> darcs get http://code.haskell.org/lambdabot
01:11:27 <mysticc> @uptime
01:11:27 <lambdabot> uptime: 3d 9h 47m 55s, longest uptime: 1m 10d 23h 44m 29s
01:12:44 <mysticc> @keal
01:12:44 <lambdabot> nsa prevent me from returning to math on efnet
01:20:20 <jtobin> any repa users around?
01:26:33 * hackagebot Elm 0.1.0 - The Elm compiler and server.  http://hackage.haskell.org/package/Elm-0.1.0 (EvanCzaplicki)
01:29:40 * jtobin casts a line for repa users again
01:31:33 * hackagebot wai-middleware-route 0.5.0 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.5.0 (AlexanderDorofeev)
01:41:14 <xarch> which GHC version is required to have the PolyKinds extension?
01:41:33 <QinGW2> test
01:42:02 <Saizan> xarch: 7.4.1
01:43:10 <randomclown> how do I preserve the global state with the state monad?
01:43:35 <randomclown> each call to evalState I need to put in an inital value
01:43:44 <xarch> oh, ok
01:43:46 <xarch> thanks
01:44:14 <xarch> also, is there any paper or document about Frank, except the slides from 2007?
01:44:57 <randomclown> or do I have to do all of my computation inside the state monad?
01:45:39 <xarch> yeah randomclown I guess
01:46:29 <randomclown> so the question is now how do I do IO inside the state monad...
01:46:41 <xarch> StateT
01:46:47 <xarch> learn about monad transformers
01:47:12 <luite> randomclown: you can use runState instead of evalState, and you will also get the final state for your state computation
01:47:22 <luite> then you can use that one for the next
01:47:47 <randomclown> that's no better than passing state around though
01:48:45 <luite> depends on how much you can do inside the state monad
01:51:33 * hackagebot wai-middleware-route 0.5.1 - Wai dispatch middleware  http://hackage.haskell.org/package/wai-middleware-route-0.5.1 (AlexanderDorofeev)
02:11:34 * hackagebot hMollom 0.4.0 - Library to interact with the @Mollom anti-spam service  http://hackage.haskell.org/package/hMollom-0.4.0 (AndyGeorges)
02:12:21 <t7> mm_freak: did it work? :)
02:30:13 <mm_freak> t7: i'm back to lambda and pi =)
02:30:36 <t7> how does pi work? is it another abstraction?
02:31:26 <xarch> isn't it something about dependent types?
02:31:39 <xarch> dependent function space iirc
02:32:42 <Alan> hmm, probably a very basic question, but... what precedence does function application have?
02:32:42 <mm_freak> t7: dependent products aka the dependent function arrow
02:32:48 <Alan> is it the highest precedence?
02:32:57 <mm_freak> t7: so i'm back to differentiating between \x -> y and x -> y
02:32:59 <Saizan> yes
02:33:08 <t7> aha
02:33:24 <Saizan> except for record update syntax
02:33:39 <mm_freak> record syntax in general binds tighter
02:33:47 <mm_freak> f X { a = b } = …
02:35:29 <Alan> ok, cool
02:35:31 <Alan> useful to know
02:35:36 <Alan> i must have known that at one point in the past
02:35:36 <Ptival> highest among infix operators
02:35:57 <Alan> and then ($) is lowest precedence function application
02:36:20 <Alan> for those frequent moments when you don't want lots of brackets
02:36:21 <mm_freak> Alan: one of them
02:36:30 <Ptival> $ $!
02:36:41 <Alan> :t $!
02:36:41 <lambdabot> parse error on input `$!'
02:36:47 <Ptival> :t ($!)
02:36:48 <lambdabot> forall a b. (a -> b) -> a -> b
02:36:49 <mm_freak> you can define functions to bind as loose as ($), but you can't define a function to bind tighter than application or record syntax
02:36:52 <Alan> haha, good point
02:36:57 <Alan> :info ($!)
02:36:58 <randomclown> can a data construction be partially applied?
02:37:06 <randomclown> constructor(
02:37:17 <Alan> .... why do both exist?
02:37:18 <merijn> randomclown: Constructors behave the same as functions, so yes
02:37:31 <randomclown> right ty
02:37:43 <Alan> according to :info in ghci they're the same precedence
02:37:57 <Alan> is one of them strict or something?
02:37:59 <merijn> Alan: ($!) is strict, I think
02:38:14 <Ptival> Alan: yes
02:38:14 <merijn> (Safe bet, everything with a ! seems to be related to strictness :p)
02:38:21 <t7> when will it by my turn for dependant types?
02:38:45 <Alan> ok
02:39:32 <t7> mm_freak: could you point me to some typing rules for pi ?
02:39:33 <Ptival> t7: cut yourself some of that pi! :)
02:40:13 <t7> i found this:
02:40:38 <t7> Context |- t1 :P (x : o) -> t[x]
02:40:50 <t7> whats t[x] mean? i havnt seen it before
02:41:18 <merijn> Usually "x substituted with t" (or was it the reverse?)
02:41:35 <Ptival> merijn: I don't think so
02:42:57 <merijn> oh, wait I guess I'm thinking of t[x/y] or similar
02:43:21 <Ptival> t7: I think it's just an application
02:43:27 <Ptival> merijn: yes
02:43:52 <Ptival> type t is abstracted over a term x
02:44:09 <Ptival> type t is abstracted over a term
02:44:28 <Ptival> t[x] is the application of that abstraction to the term x
02:44:50 <t7> but x is sigma, which means type(scheme) right?
02:44:52 * Ptival might be wrong
02:45:22 <t7> (x : sigma) -> tau[x]
02:46:43 <xarch> that seems to make sense
02:46:59 <xarch> (that it's an application, or something like that)
02:47:35 <Ptival> t7: I don't know about what these notations are, I can't answer
02:50:34 <elliott> What's the formal name for an [a,b..c]?
02:50:43 <elliott> Range? Range generator? List range? Range comprehension?
02:51:01 <t7> range in python i think
02:51:39 <ehamberg> an enumeration
02:51:52 <ehamberg> http://zvon.org/other/haskell/Outputprelude/enumFromTo_f.html
02:53:25 <mm_freak> t7: that's not a typing rule, but an evaluation rule
02:53:58 <elliott> ehamberg: no, that refers to the Enum class.
02:54:08 <mm_freak> t7: typing is as simple as checking consistency of all types involed and checking that application is type-correct
02:55:04 <t7> how do i type a pi ?
02:56:51 <mm_freak> (x : A) -> B
02:57:20 <mm_freak> pi is just the dependent function arrow
02:57:23 <t7> pi is just arrow then?
02:57:31 <mm_freak> yeah
02:58:01 <mm_freak> it's a generalization of the usual function arrow A -> B, where B can depend on the value of the argument of type A
02:58:14 <t7> aha
03:02:08 <t7> so is this a valid term: λ(X : Set) - > λ(x : X) -> x       or do i need a Π instead?
03:02:58 <bitonic> t7: you don't need pi for that, that's a simple identity functio
03:03:00 <bitonic> n
03:03:50 <Saizan> there's two pi's in the type of that though
03:04:20 <bitonic> Saizan: but you discard the values
03:04:52 <bitonic> well you don't use the values
03:05:04 <t7> λ(X : Set) - > λ(x : X) -> x    has the type     Π(X : Set) -> Π(_ : X) -> X    ?
03:05:39 <mm_freak> Saizan: where are the pis there?
03:05:47 <mm_freak> ah, in the type
03:05:51 <mm_freak> ok
03:05:59 <bitonic> t7: you need pi for something like \(x : Bool) -> if x then "foo" else 42, where the type of this is (x : Bool) -> if x then String else Int
03:06:01 <mm_freak> t7: yeah, that's the type
03:06:39 <randomclown> fastest method of partition a list of [Int] into n partitions?
03:06:47 <randomclown> partitioning*
03:06:58 <mm_freak> randomclown: what type of partitions?
03:06:59 <mm_freak> chunks?
03:07:08 <t7> bitonic: wow is that a valid term
03:07:10 <randomclown> lists
03:07:14 <randomclown> so chucks yeah
03:07:14 <bitonic> t7: yes
03:07:32 <mm_freak> > takeWhile (not . null) . map (take 3) . iterate (drop 3) $ [1..]
03:07:34 <lambdabot>   [[1,2,3],[4,5,6],[7,8,9],[10,11,12],[13,14,15],[16,17,18],[19,20,21],[22,23...
03:07:48 <mm_freak> you can remove the takeWhile if the input is always an infinite list
03:07:49 <bitonic> mm_freak: he means based on the length of the list
03:07:56 <mm_freak> oh
03:08:06 <bitonic> randomclown: I don't think there's a better way than length + what mm_freak said
03:08:06 <randomclown> yep based on the length of the list
03:08:21 <bitonic> you're going to traverse the list twice
03:08:27 <bitonic> unless I'm not seeing something
03:09:15 <Saizan> bitonic: nope, you don't, Π(X : Set) -> Π(_ : X) -> X <- you need that X
03:09:30 <bitonic> Saizan: you need the type, but you don't need the value.
03:10:08 <bitonic> that type is not dependent
03:10:22 <bitonic> unless you use "dependent type" to say "type dependent on types" :P
03:10:31 <Saizan> you need the pi to refer to the type you're abstracting over
03:10:53 <bitonic> Saizan: I understand, but you can do that with normal, system-f style quantification
03:10:56 <Saizan> i never said anything about dependent type btw :)
03:10:59 <liyang> > let split n = unfoldr $ \ xs -> if null xs then Nothing else Just (splitAt n xs)
03:11:00 <lambdabot>   not an expression: `let split n = unfoldr $ \ xs -> if null xs then Nothing...
03:11:08 <Saizan> bitonic: yeah, which is still a pi
03:11:17 <bitonic> Saizan: my point is just that you don't need the power of pi to do that
03:11:21 <mm_freak> > take 3 . transpose . takeWhile (not . null) . iterate (drop 3) $ [1..30]
03:11:22 <lambdabot>   [[1,4,7,10,13,16,19,22,25,28],[2,5,8,11,14,17,20,23,26,29],[3,6,9,12,15,18,...
03:11:50 <Saizan> bitonic: my point is that it's still a pi even if the domain is *
03:11:52 <mm_freak> should also work in infinite lists
03:11:54 <mm_freak> > take 3 . transpose . takeWhile (not . null) . iterate (drop 3) $ [1..]
03:11:56 <lambdabot>   [[1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,7...
03:12:01 <mm_freak> it does =)
03:12:01 <bitonic> Saizan: ok, never said it isn't :)
03:12:13 <mm_freak> > take 3 . transpose . takeWhile (not . null) . iterate (drop 3) $ ['a'..'z']
03:12:14 <lambdabot>   ["adgjmpsvy","behknqtwz","cfilorux"]
03:12:21 <Saizan> bitonic: you keep doing that..
03:12:32 <t7> what is the type of Π(X : Set) -> Π(_ : X) -> X   ?   * or Set or something i guess...
03:12:37 <bitonic> Saizan: ? I said you don't *need* pi
03:12:41 <bitonic> to express that type
03:12:44 <mm_freak> t7: Set
03:12:50 <liyang> How do I load module, lambdabot? D:
03:13:06 <t7> mm_freak: does pi allways have the type Set?
03:13:25 <bitonic> Saizan: since I thought that t7 would be interested in an example where you do need pi
03:13:28 <Saizan> t7: Set1 in agda
03:13:44 <mm_freak> t7: depends on whether you have universes
03:14:15 <t7> il get babby first dependant types working first before i try adding universes
03:14:15 <mm_freak> then what Saizan said
03:14:28 <Saizan> bitonic: your meaning of pi is not canonical
03:14:34 <mm_freak> t7: then just Set
03:14:42 <mm_freak> or whatever you call it
03:14:56 <randomclown> what about random partitions?
03:15:09 <bitonic> Saizan: can you elaborate? all I said is that you don't need dependent functions to express that type
03:15:14 <mm_freak> randomclown: then lists are the wrong data structure
03:15:24 <randomclown> well assume I'm on arrays
03:15:26 <mm_freak> randomclown: it's possible, but you won't like the performance of that
03:15:57 <randomclown> currently I'm just zipping an infinite list of random numbers in the parition range and then filtering
03:16:18 <mm_freak> randomclown: you should use a tree structure for the input data and a Seq for the output
03:16:37 <randomclown> why tree?
03:16:43 <mm_freak> then successively iterate the output sets adding a random element from the input set
03:16:47 <Saizan> bitonic: basically, System F's forall _is_ already pi
03:16:55 <mm_freak> because you need to remove taken elements
03:17:15 <mm_freak> you can also use marking, but removing might be faster
03:17:15 <danr> Saizan: what makes you say so?
03:17:35 <mm_freak> randomclown: the easiest method is to just use the one i've given you, but randomly permute the list before you do
03:17:44 <mm_freak> there is an algorithm by knuth for doing that
03:18:07 <Saizan> Pure Type Systems, more or less
03:18:21 <Axman6> Given data Foo = Bar | Baz | Quux, data Blah = Blah Int Int, data Thing = Thing Blah Foo, and 64 bit Ints, how many possible values does this have, including anywhere where there may be bottom (I get something like: 2*(2^64+1)*3+1+1)
03:18:32 <liyang> @let split n = unfoldr $ \ xs -> if null xs then Nothing else Just (splitAt n xs)
03:18:33 <lambdabot>  <local>:4:0:
03:18:33 <lambdabot>      Warning: Pattern match(es) are overlapped
03:18:33 <lambdabot>               In...
03:18:43 <mm_freak> Saizan: it's a special case of pi, because you can't make types depend on the argument's value
03:18:47 <bitonic> Saizan: I'm not sure what you mean here. Do we agree that in System-F types can't depend on values? You wouldn't be able to stick pi in type signatures
03:19:01 <liyang> > split 3 [0..16]
03:19:01 <lambdabot>   Ambiguous occurrence `split'
03:19:02 <lambdabot>  It could refer to either `L.split', defined a...
03:19:23 <liyang> @let chunky n = unfoldr $ \ xs -> if null xs then Nothing else Just (splitAt n xs)
03:19:24 <lambdabot>  Defined.
03:19:26 <Saizan> bitonic: pi is not just types depending on values
03:19:31 <liyang> > chunky 3 [0..16]
03:19:32 <lambdabot>   [[0,1,2],[3,4,5],[6,7,8],[9,10,11],[12,13,14],[15,16]]
03:19:33 <mm_freak> Axman6: Foo is a sum type and Blah and Thing are product types
03:19:47 <mm_freak> Axman6: that indicates how to calculate the number of possible values
03:19:56 <bitonic> Saizan: ... I know, but it is also that
03:20:12 <Axman6> mm_freak: sure, i'm just making sore I've calculated it correctly =)
03:20:17 <Axman6> sure*
03:20:21 <mm_freak> Foo = 1 + 1 + 1
03:20:27 <mm_freak> Var = Int^2
03:20:30 <mm_freak> s/Var/Bar/
03:20:32 <luite> Axman6: looks way too low :p
03:20:36 <mm_freak> s/Bar/Blah/
03:20:37 <mm_freak> lol
03:20:46 <mm_freak> Thing = Blah * Foo
03:21:21 <Axman6> mm_freak: i'm including undefined as a possible "value" (i see the irony there), so Bar would be 1+1+1+1
03:21:27 <mm_freak> that makes 3 * Int^2 defined values
03:21:27 <luite> Axman6: since the product of two ints is already (2^64+1)^2
03:21:40 <liyang> +1 to everything!
03:21:53 <Axman6> \o|
03:21:57 <Sgeo> > (maxBound :: Int) + 1
03:21:58 <lambdabot>   -9223372036854775808
03:23:19 <Guest8537> > (2^40)
03:23:20 <lambdabot>   1099511627776
03:23:25 <Guest8537> > (2^999)
03:23:26 <lambdabot>   535754303593133660474212524530000905280702405852766803721875194185175525562...
03:23:32 <Guest8537> > (9^9^9)
03:23:34 <bitonic> Saizan: I still don't get what you were trying to say. whatever :P
03:23:37 <lambdabot>   mueval: ExitFailure 1
03:23:37 <lambdabot>  mueval: Prelude.undefined
03:24:26 <mm_freak> > (9^9)^9
03:24:27 <lambdabot>   196627050475552913618075908526912116283103450944214766927315415537966391196...
03:29:59 <hpaste_> jtobin pasted “extract diagonal from DIM2 repa array” at http://hpaste.org/67641
03:30:33 <jtobin> better way to extract a diagonal from a (2d) repa array?
03:31:39 * hackagebot Monatron-IO 1.0 - MonadIO instances for the Monatron transformers.  http://hackage.haskell.org/package/Monatron-IO-1.0 (TobiasBrandt)
03:36:01 <mm_freak> > zipWith (flip (!!)) [0..] $ ["abcd", "efgh", "ijkl", "mnop"]
03:36:03 <lambdabot>   "afkp"
03:38:12 <mysticc> > 2^999 :: Int
03:38:13 <lambdabot>   0
03:38:21 <mysticc> > 2^999 :: Integer
03:38:22 <lambdabot>   535754303593133660474212524530000905280702405852766803721875194185175525562...
03:38:27 <mysticc> > 2^999 :: Double
03:38:29 <lambdabot>   5.357543035931337e300
03:38:34 <mysticc> > 2^999 :: Word32
03:38:35 <lambdabot>   0
03:38:38 <mysticc> > 2^999 :: Word64
03:38:39 <lambdabot>   0
03:38:43 <mysticc> > 2^64 :: Word64
03:38:44 <lambdabot>   0
03:38:47 <mysticc> > 2^63 :: Word64
03:38:48 <lambdabot>   9223372036854775808
03:39:19 <mysticc> > 2^64 -1 :: Word64
03:39:20 <lambdabot>   18446744073709551615
03:39:26 <mysticc> > 2^64 -1 + 1:: Word64
03:39:28 <lambdabot>   0
03:39:30 <merijn> mysticc: You can privmsg lambabot
03:39:45 <t7> overflow = 0?
03:39:59 <ment> > (read $ reverse $ show (2^63 :: Word64)) :: Word64
03:40:00 <lambdabot>   8085774586302733229
03:40:05 <merijn> overflow is probably undefined
03:40:07 <t7> > 257 :: Word8
03:40:08 <lambdabot>   1
03:40:23 <danr> > 129 :: Word8
03:40:23 <lambdabot>   129
03:40:32 <t7> word is unsigned
03:40:33 <mysticc> > 2^8 + 1:: Word8
03:40:34 <lambdabot>   1
03:40:55 <mysticc> > 2^8 + 10:: Word8
03:40:56 <lambdabot>   10
03:41:10 <mysticc> t7: I think it starts again from 0 ..
03:41:11 <jtobin> mm_freak vrai, probably a bit cleaner
03:45:02 <liyang> IIRC, Word8 is actuall a machine int with an AND 0xff after every op.
03:46:40 <bitonic> liyang: what? I don't think so
03:46:44 <bitonic> at least not in GHC
03:46:48 <bitonic> that would be very disappointing :P
03:46:57 <bitonic> liyang: http://hackage.haskell.org/packages/archive/base/latest/doc/html/src/GHC-Word.html#Word8
03:47:30 <liyang> Isn't it? A Word# is a machine-sized word.
03:48:23 <merijn> liyang: That would seem highly inefficient, given that most CPUs support addressing by half words and bytes (if not all CPUs that GHC supports)
03:48:39 <bitonic> liyang: I'm not sure about how the operators are defined, which is the bad part
03:48:57 <liyang> narrow8Word# would be the AND 0xff (or something similar) part.
03:49:09 <bitonic> liyang: yeah. well.
03:49:16 <bitonic> that is disappointing then :P
03:49:56 <liyang> That is disappointing, but it's true. D:
03:50:28 <mysticc> @hoogle narrow8Word
03:50:29 <lambdabot> No results found
03:50:37 <bitonic> liyang: well, good to know :P. maybe they do some optimization down the line
03:50:54 <bitonic> or maybe it just was never a problem
03:51:52 <ziman> hm.
03:51:58 <mysticc> Word8 is represented in the same way as Word ...
03:52:06 <ziman> so if I have an unboxed array of Word8, it's four times the size?
03:52:22 <mysticc> ziman: yeah
03:52:36 <mysticc> data Word8 = W8# Word#
03:52:55 <liyang> No, that'd be further down the line, and actually only takes 1 byte I believe^Whope.
03:53:37 <mysticc> liyang: How ?
03:53:43 <ziman> that's weird, so you need to expand C strings when converting to ByteStrings etc.?
03:54:13 <bitonic> ziman: ByteStrings are packed
03:54:35 <bitonic> they're very much like a C string, + size
03:56:23 <liyang> mysticc: not sure. :-/ The Storable instance for Word8 treats them as single bytes.
03:56:44 <ziman> ah, ForeignPtr Word8, I see.
03:59:34 <liyang> But yeah, a [Word8] takes the same space as a [Char] of the same length.
04:00:22 <bitonic> ziman: I don't know how unboxed vectors work, but I'd expect them to pack them as well
04:02:34 <liyang> Unboxed vectors does.
04:05:37 <ziman> hopefully
04:06:17 <bitonic> tbh the fact that they take a word is to be expected
04:06:30 <bitonic> I'm more surprised about the masking bit
04:06:41 <ziman> well, it's probably okay for a single Word8 to have the size of a full Word as long as unboxed arrays are reasonably compact
04:16:39 <t7> whats the type of Set4 -> Set5   Set1 ?
04:17:47 <t7> i duno what agda says because windows terminal doesnt like unicode :(
04:19:25 <bitonic> t7: Set5
04:19:41 <bitonic> if you were asking "What's the type of Set4 -> Set5'
04:19:59 <t7> yeah, how is it typed?
04:20:10 <bitonic> when using type constructor the resulting type is in the universe given by the upper bound of the universes passed to the constructor
04:20:18 <t7> ah i though so :)
04:20:25 <bitonic> least upper bound
04:20:36 <mm_freak> jtobin: ?
04:21:00 <mm_freak> bitonic: the type of Set 4 -> Set 5 is Set 5?
04:21:40 <t7> do i need to differenciate between (x : Y) -> Z    and     Y -> Z   ?
04:23:03 <mm_freak> i'd vote for Set6
04:25:12 <t7> that makes sense: Bool -> Bool has type *
04:31:32 <mm_freak> t7: if in "(x : Y) -> Z" x doesn't appear in Z then it's exactly the same as Y -> Z
04:31:47 <mm_freak> and Set4 -> Set5 has type Set6, not Set5
04:32:28 <mm_freak> as far as i know Set x -> Set y : Set (succ (max x y))
04:44:30 <av> hi, I need some help (once again) with attoparsec
04:46:04 <av> I want to parse a string containing a list of words separated by whitespace, but only the span of words that don't appear in a list (of keywords) -- is there an elegant way of doing this?
04:51:44 <t7> do i need to worry about alpha renaming in lambda calc? or just when i make continuations and stuff....
04:52:02 <jgr> t7: basicly never.
04:52:18 <merijn> t7: Well, depends on how naively you implement substitution
04:52:20 <mm_freak> t7: in a dependently typed language yes, you need to worry
04:52:38 <mm_freak> you can also use de bruijn indices
04:52:45 <merijn> ^^
04:52:56 <merijn> de Bruijn indices are a much smarter approach
04:54:24 <mm_freak> t7: background:  to match types you need to find out whether the normal forms of two terms are alpha-equivalent
04:54:44 <t7> ah of course :|
04:54:56 <t7> de bruijn here i come
04:55:49 <bitonic> mm_freak: no, it's Set5
04:56:16 <mm_freak> bitonic: agda disagrees
04:56:18 <mm_freak> x : Set6
04:56:21 <bitonic> ah wait, right
04:56:31 <bitonic> I think both are fine
04:57:01 <bitonic> @where TTFP
04:57:01 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/TTFP/
04:57:33 <t7> 20 year old book
04:57:47 <bitonic> t7: still the best reference for this stuff :(
04:59:10 <t7> £40 for dead tree format :(
04:59:17 <t7> i need a new book to read
05:00:16 <bitonic> mm_freak: I got confused, but it is the maximum of the types, which in that case is Set6
05:00:21 <bitonic> since Set5 : Set6
05:00:58 <bitonic> t7: it's free on PDF
05:01:05 <bitonic> also, the actual book is out of print
05:01:14 <bitonic> you might find it in libraries (at least I did)
05:04:11 <t7> might print it off at work
05:06:42 <bitonic> t7: most university libraries probably have it
05:06:54 <t7> i have a real job :(
05:07:41 <bitonic> t7: a lot of libraries are public
05:09:11 <drdo> I printed that book recently
05:10:50 <otters> @pl \a b -> f a ++ f b
05:10:51 <lambdabot> (. f) . (++) . f
05:10:59 <otters> @pl \a b -> (f a) ++ (f b)
05:10:59 <lambdabot> (. f) . (++) . f
05:11:01 <otters> oh
05:15:25 <fmap> > ((++) `on` show) 1 2
05:15:27 <lambdabot>   "12"
05:15:56 <merijn> fmap: How to implement PHP in 3 easy functions? :)
05:21:03 <Axman6> merijn: that would be ((+) `on` show), and would give exactly the same result as above :P
05:21:32 <merijn> > let (+) = (++) `on` show in 1 + 2
05:21:34 <lambdabot>   "12"
05:22:14 <t7> bitonic: are abstractions allways in universe 0. e.g.    \(x : Set5) -> Set4     :     Set0 ?
05:26:36 <bitonic> t7: uh? \(x : Set5) -> Set4 has type Set5 -> Set5
05:27:00 <t7> ah yeah im being a wally
05:28:03 <hpaste_> keep_learning pasted “same function declaration for different data types” at http://hpaste.org/67646
05:28:11 <bitonic> t7: btw, all these questions are OK in #haskell but you'll get better answers in #agda
05:28:13 <keep_learning> Hello All
05:28:17 <bitonic> hello
05:28:32 <dblhelix> hi, keep_learning
05:28:44 <keep_learning> I have a data type  data Point a = Point Int Int  a
05:28:56 <keep_learning> dblhelix: Hi
05:29:12 <keep_learning> a can be Double or Bool
05:31:11 <keep_learning> When its bool then anding the last  parameter otherwise multiply
05:31:28 <keep_learning> I am getting the error of multiple declaration
05:31:37 <keep_learning> How to do this ?
05:32:10 <dblhelix> keep_learning: you can use a type class for this
05:32:46 <dblhelix> keep_learning: for example:
05:32:50 <bitonic> in fact, (+) is a member of a typeclass (Num)
05:32:54 <dblhelix> class C	a where
05:32:54 <dblhelix>   op ::	a -> a -> a
05:32:55 <bitonic> but Num might do too much for you
05:32:56 <dblhelix> instance C Bool	where
05:32:57 <dblhelix>   op = (&&)
05:32:58 <dblhelix> instance C Double where
05:32:58 <dblhelix>   op = (*)
05:33:26 <bitonic> well, it'd be more appropriate to have instance C (Point Int Int Bool) and C (Point Int Int Double)
05:33:54 <dblhelix> keep_learning: and then use the class as in
05:33:55 <dblhelix> g :: C a => Point a -> Point a -> Point a
05:33:55 <dblhelix> g (Point x y z) (Point u v w) = Point (x + u) (y + v) (z `op` w)
05:34:55 <dblhelix> bitonic: depends on the actual application of course; not possible to say s/t about this without knowing the context
05:36:13 <dblhelix> bitonic: moreover, such instances require language extensions
05:36:14 <keep_learning> dblhelix: bitonic Thank you
05:36:38 <bitonic> dblhelix: true, but FlexibleInstances is pretty accepted by now.
05:38:37 <dblhelix> bitonic: if the only difference is in the operation ((&&) vs. (*)), then I like my approach better as it only abstracts out the essentials
05:39:14 <dblhelix> bitonic: then again, it could just be a matter of taste
05:40:06 <bitonic> dblhelix: mhm. it looks like those operations are specific to the `Point' context
05:40:28 <bitonic> that's why I suggested to instantiate Point and not Double and Bool, since they probably don't make much sense on their own
05:40:37 <dblhelix> bitonic: interesting, how do you know that?
05:41:12 <bitonic> dblhelix: my gut told me
05:41:48 <dblhelix> bitonic: they make a lot of sense on their own: they are the associative operations of respective monoidal structures, for example
05:42:30 <bitonic> dblhelix: yes but I'm not sure there is a typeclass that makes sense in that case. Then you might as well just use the already existing Monoid instances.
05:42:46 <dblhelix> bitonic: I typically feel better if I can abstract out bits that make sense in a wider context than de app at hand; it's an indication of robustness
05:43:26 <bitonic> dblhelix: it doesn't make sense if the specific implementation is related to the nature of Point, which I think is the case in this case. keep_learning can settle this debate :P
05:43:27 <roha> quick question: i spent the last hour or so trying to think why fmap on two functions is just function composition. am i right in that it is function composition because it is defined like that and not because it follows out of category theory. the only thing that follows out of category theory is that the types just happen to be just the type signature of (.) ?
05:43:35 <bitonic> dblhelix: of course if they make sense on their own they should be on their own.
05:43:52 <dblhelix> bitonic: I agree, and, indeed, if it were my app, I would hope that I wouldn't need the new class and could use s/t like Monoid instead
05:44:09 <dblhelix> bitonic: seems like we're starting to agree :)
05:44:12 <opqdonut> roha: something like that
05:44:17 <opqdonut> but disregard category theory
05:44:38 <opqdonut> you can think of a Functor as a container
05:45:00 <opqdonut> and a function (e.g.) Int->a is a container of a's: you supply an index and it gives you the value
05:45:01 <bitonic> dblhelix: my comment was just backed by my intuition related to that operation, so I never really disagreed with you :)
05:45:12 <dblhelix> opqdonut: not just the types, also the associated laws
05:45:19 <keep_learning> dblhelix: bitonic Both solutions are acceptable but Point as instance of class is bit more clear :)
05:45:29 <opqdonut> dblhelix: yes, of course
05:45:51 <opqdonut> but in the case of (a->) the only thing that types also satisfies the laws
05:46:04 <bitonic> keep_learning: if dblhelix solution is acceptable in every case (in other words, if the operation on the `a' is completely indipendent from Point) then you should use a typeclass specific to `a' as he said
05:46:47 <bitonic> if the `a' might change how the rest of the operation is performed, than use a typeclass for Point
05:48:18 <t7> what are the rules for alpha renaming?
05:48:39 <merijn> t7: ill-defined :p
05:49:07 <t7> at the moment i rename every Variable i substitute
05:49:16 <t7> which seems a bit silly
05:49:56 <MaskRay> how to handle cookies with http-conduit ?
05:52:01 <roha> opqdonut, ok thanks. i need to think about that for a moment :).
05:58:33 <michaelfeathers> Anyone have time for a question?
05:58:55 <hpc> yes, but you used it all up with that question ;)
05:59:08 <merijn> michaelfeathers: That probably depends on the question, so you're better of just asking
05:59:08 <hpc> (don't ask to ask, just ask your question)
06:00:55 <michaelfeathers> Okay :)   So, I often run into this problem where I want to build up a list, but only based on certain elements of another list that I can only determine as I'm traversing it.  It seems sort of map-y and fold-y.
06:02:16 <Axman6> or intersecty?
06:02:22 <michaelfeathers> Imagine I have a function f which returns the next element of the list I should visit.  Then, I apply that function to that element, do some work, and visit the element returned by the function.  I want to skip across a list.
06:02:54 <merijn> michaelfeathers: That sounds more random access-like than list-like
06:03:10 <merijn> Are you sure you want a list and not an array?
06:04:08 <michaelfeathers> merijin: definitely a list
06:04:11 <cg_morton> sounds like you just need filter
06:04:33 <ClaudiusMaximus> I need bitpacked unboxed multi-dimensional Bool array with fast aggregate operations and interchange between linear arrays of bytes.  none of these packages on hackage meet all my requirements: array, vector, bit-vector, bitstring, bitarray, bitstream, uvector, repa.  what should i do?
06:05:28 <michaelfeathers> cg_morton: hmm..
06:05:29 <quicksilver> ClaudiusMaximus: give up.
06:05:57 <merijn> Implement in C and use FFI? :p
06:07:32 <bitonic> ClaudiusMaximus: do you have any example of such a structure outside haskell?
06:08:49 <ClaudiusMaximus> bitonic: only the one i implemented in C for the special case of 128x128 bits
06:09:06 <ClaudiusMaximus> bitonic: so, not in general :)
06:09:43 <bitonic> ClaudiusMaximus: ok, do you have an example of what you want but with different values (e.g. ints and not bool)
06:09:49 <bitonic> it looks like you want a sophisticated bitmap
06:09:51 <cg_morton> what do you mean by 'unboxed'?  isn't that redundant with bit-packed?
06:11:18 <ClaudiusMaximus> cg_morton: probably
06:13:06 <cg_morton> and by fast aggregate operations, do you mean matrix operations ala linear algebra?  Or do you just need efficiently cached random access?
06:13:24 <ClaudiusMaximus> bitonic: repa is pretty much ideal, apart from the bit packing thing
06:13:53 <ClaudiusMaximus> cg_morton: i mean things like map, zip, fold
06:14:11 <nand`> huh
06:14:21 <nand`> Loading package cereal-0.3.5.1 ... can't load .so/.DLL for: libHScereal-0.3.5.1.so (libHScereal-0.3.5.1.so: cannot open shared object file: No such file or directory)
06:14:31 <drdo> Is there some sort of haskell interpreter with dynamic type checking, specifically, for the purpose of debugging? (I don't know if this even makes much sense, haven't thought much about it. But once in a while one gets a type checking error for which it is quite hard to track down the problem due to the generality, and finds out, after tens of minutes, it was a really trivial mistake)
06:15:23 <nand`> This error has me confused because cereal-0.3.5.1 is installed
06:15:26 <ClaudiusMaximus> cg_morton: so "zip :: (Bool -> Bool -> Bool) -> BoolArray -> BoolArray -> BoolArray" would actually do bitwise operations on Word64, instead of extracting/packing bits
06:15:36 <ClaudiusMaximus> s/zip/zipWith
06:16:35 <bitonic> ClaudiusMaximus: bools are not packed in repa?
06:16:42 <parcs`> drdo: ghc 7.6 has a flag that defers type errors to runtime
06:16:56 <ClaudiusMaximus> bitonic: repa uses vector, vector uses Word8 for Bool
06:17:20 <ClaudiusMaximus> bitonic: uvector did bit packing, but that's deprecated in favour of vector
06:17:34 <bitonic> ClaudiusMaximus: oh well, today I find out a lot of stuff about packed data structures :)
06:18:06 <parcs`> drdo: is that what you're asking for?
06:18:08 <cg_morton> yeah, doesn't seem to be an existing solution for your problem
06:18:32 <bitonic> ClaudiusMaximus: maybe fork repa? :)
06:18:48 <drdo> parcs`: Got any link at hand where i can check it out?
06:19:16 <bitonic> parcs`: really? so they don't erase types at runtime? is there a paper about this?
06:19:39 <t7> is Set0 the set of all types?
06:19:58 <bitonic> t7: you mean all values?
06:20:05 <ClaudiusMaximus> bitonic: i'm not quite that insane :)
06:20:14 <bitonic> ClaudiusMaximus: why not? how hard can it be
06:20:31 <t7> erm... does Bool live in the same universe as True?
06:20:40 <parcs`> bitonic: ghc just replaces the faulty expression with 'error particularTypeErrorMsg'
06:20:47 <bitonic> t7: no
06:20:58 <bitonic> parcs`: ok but that means that they have to keep the type at runtime, something that doesn't happen now
06:20:59 <drdo> t7: Bool is a type, True inhabits Bool
06:21:07 <parcs`> bitonic: why?
06:21:19 <bitonic> parcs`: ...because you have to check if the types match?
06:22:05 <drdo> bitonic: Like i said before, i haven't thought much about the idea. But at a first glance it seems like a trivial thing to do if you already have a static checker.
06:22:10 <bitonic> t7: you probably meant "Is Set0 the type of all values' types", which is true I guess
06:22:21 <bitonic> drdo: it's not, because right now GHC erases types at runtime
06:22:27 <parcs`> bitonic: they either do or they don't, and that's still determined at compile time. the only difference now is that if they don't the expression gets replaced with the error message that would've been emitted
06:22:45 <bitonic> parcs`: to check if they match you have to have a reified form of the type at runtime
06:22:58 <drdo> bitonic: Indeed, and the trivial thing i was thinking about would be just not doing it
06:23:16 <bitonic> drdo: if you don't do that you'd have segfaults all over the place
06:23:27 <drdo> Talking strictly about interpretation here, compilation would need major changes to data representation
06:23:35 <drdo> Which isn't that trivial
06:23:51 <bitonic> drdo: I was thinking about compilation, ok
06:23:52 <t7> can i define a function     (True : Bool) -> True   ? i know i can never use it because nothing types to Tru
06:24:09 <bitonic> drdo: still you need to carry around the type even when interpreting
06:24:32 <drdo> bitonic: Yes of course, but that's not terribly hard
06:25:05 <bitonic> drdo: and you need to check for each function application, it's a fair amount of work
06:25:05 <parcs`> perhaps drdo is asking for something else, because -fdefer-type-errors definitely doesn't need to carry around type information. the patch was like 100 lines long
06:26:21 <bitonic> parcs`: what that does is to put an error preemtpively where there is a type error
06:26:25 <bitonic> which is different from what drdo wants
06:26:32 <drdo> parcs`: I mean an interpreter that delays type checking as much as possible into runtime so that one can experiment/debug
06:26:50 <parcs`> experiment/debug how?
06:26:50 <bitonic> drdo: oh. maybe that does what you want the.
06:26:52 <bitonic> *then
06:27:06 <parcs`> http://www.haskell.org/pipermail/cvs-ghc/2012-January/069676.html
06:27:27 <bitonic> that patch afais replaces each ill-typed expression with `error "blah"'
06:27:37 <bitonic> it basically puts 'undefined' for you.
06:27:45 <bitonic> which can be useful, I guess.
06:27:49 <drdo> You can still do some conservative (i.e. never fail) checking statically, but that's merely an optimization and of no concern to me
06:28:06 <bitonic> parcs`: also,  45 files changed, 1340 insertions(+), 1126 deletions(-)
06:28:15 <parcs`> yeah :P
06:28:36 <bitonic> the net delta in the end is 200 lines, but still
06:28:43 <drdo> Pretty much what any language with dynamic type checking does
06:29:08 <parcs`> bitonic: it's damn useful combined with ghci because when you reload a module with a type error you still have access to all the bindings of the module
06:29:29 <bitonic> parcs`: yeah but it doesn't turn Haskell into a dynamic language, which drdo wanted as I understood
06:29:32 <drdo> Like i explained above, some type checking errors are hard to track down when the code looks pretty much correct and it's a tiny mistake
06:29:35 <bitonic> a dynamic, strong language
06:29:54 <bitonic> but I think I misunderstood and that patch is good enough for drdo
06:30:09 <parcs`> you can use -fdefer-type-errors and just ignore the warnings ;)
06:30:18 <efie> A few days ago I asked, i, if a function is called several times in a program with the same paramters, the result is stored so that the function does not have to be evaluted every single time. I was told that this is not the case in general. But now I read: https://en.wikipedia.org/wiki/Evaluation_strategy#Call_by_need : "Call-by-need is a memoized version of call-by-name where, if the function argument is evaluated, that value is stor
06:30:23 <drdo> And being able to play around in a repl makes those much much easier to find
06:31:07 <efie> As Haskell uses call-by-need I am confused.. can someone shed some light on this?
06:31:08 <bitonic> efie: that happens only in one instance, e.g. if you have `let foo = bar baz', foo will be evaluated once
06:31:25 <bitonic> that doesn't mean that all the other calls too `bar baz' will be memoized
06:31:35 <bitonic> note that in a pure language the compiler might do that anyways
06:31:54 <bitonic> but it's obviously not feasible/convenient to do that in the general case
06:32:33 <efie> what if I have a function and in its body / recursive calls the one function is used several times?
06:32:43 <bitonic> efie: note that in classic "call by value", if we have `let foo = bar baz', foo will be evaluated each time its value is needed
06:32:52 <bitonic> sorry, "call by name"
06:33:03 <nand`> hmm
06:33:09 <bitonic> efie: you have no guarantees apart from the memoization of a single instance
06:33:19 <drdo> bitonic: Oh, about that, do you know where i can find reading material about partial evaluation in languages similar to haskell? I'm specifically interested in "how does one know when to stop?"
06:33:23 <bitonic> the easiest thing is just to bind the call in a let
06:33:24 <cg_morton> but in something like zip (boo baz) (boo baz), if you did that the compiler would probably only call boo baz once wouldn't it?
06:33:37 <bitonic> cg_morton: it might
06:33:44 <bitonic> again, you have no guarantees about that
06:34:12 <bitonic> drdo: more than "when do you stop" is "when do you start"
06:34:21 <bitonic> in lazy languages the answer is "as late as possible"
06:34:27 <drdo> And not in the sense of knowing when to stop because you might get stuck in an infinite loop, but how to choose the right trade off between space and time
06:34:28 <bitonic> only when you actually need to inspect that value in some way
06:34:37 <bitonic> oh wait, I think I misunderstood
06:34:51 * nand` wonders if memoization would make “let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib n” evaluate in O(n) time
06:35:11 <nart> hi :)
06:35:21 <bitonic> drdo: sorry, I misunderstood your question. I don't know much about partial evaluation
06:35:28 <t7> whats the type of a universe.... its types all the way down
06:35:30 <ClaudiusMaximus> bitonic: i think i'll go and try building something on top of repa.  thanks bitonic, cg_morton for helping clarify my ideas
06:35:31 <nart> i get this weird error trying to install cabal from darcs with ghc 7.4.1 ... Configuring cabal-install-0.15.0...
06:35:31 <nart> Setup: At least the following dependencies are missing:
06:35:31 <nart> Cabal >=1.15.0 && <1.16
06:35:48 <cg_morton> nand`: doesn
06:35:53 <cg_morton> 't look like it
06:35:54 <drdo> bitonic: I guess one can see it as a generalization of inlining
06:36:02 <dcoutts> nart: not very weird, it does need Cabal-1.15.*
06:36:05 <byorgey> nart: well, what version of the Cabal library do you have installed?
06:36:19 <byorgey> you need the darcs version of that too
06:36:24 <efie> bitonic: thanks for your answer
06:36:25 <dcoutts> nart: you want to do: cabal install ./Cabal/ ./cabal-install
06:36:34 <bitonic> drdo: yeah, I think someone had some project related to supercompilation in Haskell
06:36:44 <bitonic> efie: yw
06:36:49 <drdo> bitonic: What is supercompilation?
06:36:56 <bitonic> drdo: I think it's some form of partial evaluation
06:37:03 <dcoutts> nart: ie in the darcs repo, install both Cabal and cabal-install
06:37:11 <bitonic> but again, I don't know much
06:37:16 <drdo> Hmm, now i'm surprised
06:37:18 <byorgey> dcoutts: btw, how's work on Hackage 2 coming? or is there someone else I should ask?
06:37:32 <dcoutts> byorgey: you can ask me, want to help? :-)
06:37:33 <nart> dcoutts: ahh now i see
06:37:53 <nart> thanks
06:37:58 <dcoutts> byorgey: there's a live instance of the server running, with live mirroring
06:38:01 <byorgey> dcoutts: well, sure!  I'll probably have a bit of time this summer =)
06:38:06 <nand`> cg_morton: the idea is that since fib (n-1) in turn evaluates fib (n-2) and fib (n-3); the next argument to (+), fib (n-2), has already been calculated
06:38:11 <dcoutts> byorgey: people are using it successfully in house at a few companies
06:38:16 <byorgey> dcoutts: nice
06:38:25 <dcoutts> byorgey: great, it needs more love
06:38:32 <byorgey> dcoutts: so what's still left to do before rolling it out for real?
06:38:36 <bitonic> nand`: in theory a compiler could optimise that. GHC won't.
06:38:40 <nand`> the same goes for fib (n-2) which in turn evaluates fib (n-3) and fib (n-4); so each successive application makes its latter argument “already calculated”
06:38:40 <drdo> I haven't read much about what compilation of haskell and/or similar languages. For some reason i always assumed partial evaluation was the main thing everyone did with other minor optimizations on top
06:38:44 <dcoutts> byorgey: there's a fair bit of info on this on the trac
06:39:01 <byorgey> dcoutts: ok, I'll take a look
06:39:14 <bitonic> drdo: I'm not an expert either. You may want to ask on #ghc as well
06:39:28 <dcoutts> byorgey: but two big things: getting build and doc builder clients running, and testing of the database dump / restore
06:39:35 <nand`> bitonic: I'm aware GHC doesn't do it; I was just wondering whether it would be feasible or sensible to have a compiler easily optimize that; maybe by adding a keyword to tell the compiler to “store the results of this function in memory”
06:39:49 <byorgey> dcoutts: ok, got it
06:40:18 <bitonic> nand`: it's definitely not an "easy" problem. There are really nice frameworks to memoize seamlessly in haskell
06:40:24 <dcoutts> byorgey: there's a doc builder client been written but not yet in use, we need something similar for ordinary build success/failure results
06:40:32 <bitonic> @hackage MemoTrie
06:40:33 <lambdabot> http://hackage.haskell.org/package/MemoTrie
06:41:12 <drdo> nand`: Interesting. Have you thought about that idea or did it just come up?
06:41:36 <byorgey> dcoutts: sounds hairy ;)
06:42:36 <dcoutts> byorgey: it's not too bad, cabal-install can already generate the structured format for build results
06:42:47 <byorgey> dcoutts: ah, ok
06:42:59 <byorgey> dcoutts: I just meant in terms of sandboxing, dependencies, etc. etc.
06:43:06 <hpaste_> nart pasted “cabal-install” at http://hpaste.org/67647
06:43:19 <dcoutts> byorgey: yeah, the sandboxing is more interesting, at least if you mean security
06:43:23 <nart> how do i solve this ^ ?
06:43:33 <byorgey> dcoutts: I don't even know what I mean, which is why it sounds hairy =)
06:43:40 <dcoutts> byorgey: isolated builds is easy enough, just need --package-db= flags etc
06:43:48 <efie> I ran an example from the haskell homepage showing how to program the fib-function using parallelism... however it was as fast as the fib-function which did not use parallelism. is this due to GHC optimized this while compiling (e.g. seeing that this can be made parallel) or is this due to the hardware in my pc realizing that this could be distriubuted on more than core?
06:43:49 <byorgey> dcoutts: ok, true
06:44:11 <efie> one core*
06:44:12 <dcoutts> byorgey: but I think the answer is not to solve the security problem, just tell people setting up build bots to only do it within a security sandbox
06:44:22 <byorgey> dcoutts: fair enough.
06:44:22 <nand`> drdo: it just came up
06:44:27 <dcoutts> byorgey: it's so OS-specific anyway
06:44:35 <byorgey> true
06:45:07 <dcoutts> byorgey: and we have an existing mirroring client that polls for changes, and that skeleton could be reused for a builder client
06:45:16 <byorgey> dcoutts: ah, cool
06:45:31 <dcoutts> byorgey: and there's also the doc builder client code, all in the same source repo
06:45:38 <dcoutts> so plenty to work from
06:45:56 <cg_morton> oh, nand`: I said doesn't look like fib memoizes because fib 10 took < 1s  and fib 30 was still running a minute later
06:46:07 <drdo> nand`: What is the idea, more precisely? (In a general sense, i do get the gist of what you mean by the factorial example)
06:46:10 <sipa> cg_morton: which code?
06:46:16 <cg_morton> the one you gave
06:46:33 <sipa> who? me?
06:46:46 <cg_morton> actually fib 30 did finish, but fib 100 is still going
06:46:55 <nand`> sipa: fib n = fib (n-1) + fib (n-2)
06:47:00 <bitonic> drdo: the idea is memoize automatically function calls
06:47:04 <sipa> that will certainly not memoize
06:47:43 <scooty-puff> so for record access, assuming extensible records, parameterized by by a type of kind [(Symbol, *)], given (#.) as a function for access, would r#."test" not be possible, instead requiring r#.(sing :: Sing? "test")
06:47:55 <scooty-puff> err, move that ? to the end of the line
06:47:55 <drdo> bitonic: Ah, that's fairly easy then, i wasn't sure if there was something more general there
06:48:03 <byorgey> dcoutts: cool. I may or may not find time to work on it soon -- realistically I probably won't have any time until July.  But if there's still stuff that needs doing then I may try to help out some.
06:48:19 <dcoutts> byorgey: there will always be something to do :-)
06:48:21 <bitonic> drdo: but it's impossible in the general case
06:48:23 <drdo> The hard part is of course choosing when to do
06:48:26 <nand`> drdo: the idea is to seamlessly and naively track all evaluations of a function in a table in the runtime which will be queried for each successive evaluations to see if that input has been evaluated already; and expose this behavior as an optional GHC pragma that can be applied to functions
06:48:36 <bitonic> scooty-puff: yeah you need the type explicitly
06:48:42 <byorgey> dcoutts: good point =)
06:48:46 <scooty-puff> bitonic: k
06:49:27 <nand`> basically; instead of trying to make a hyper-intelligent memoization algorithm that will be applicable in all cases; make a dumb/naive algorithm that the programmer can choose to use when he knows it won't cause problems
06:49:42 <bitonic> scooty-puff: which is annoying. BUT you can write CPP macros!
06:50:15 <scooty-puff> k - yeah, that would probably be the least intrusive (compared to some template haskell solution - which would be verbose anyways) way
06:50:28 <bitonic> so you might have simply r#.p("test"), where #define p(S) sing :: Sing? S or whatever
06:50:46 <bitonic> for maximum hackiness
06:50:49 <drdo> nand`: I see. That sounds like something at the a pretty good level of difficulty/modularity for someone without much experience to implement (Such as myself. Perhaps it applies to you as well?)
06:50:56 <drdo> s/at the/at/
06:51:11 <nand`> hmm.. would it be possible to write “memoize :: Ord k => (k -> a) -> (k -> a)” that uses unsafePerformIO and an IORef (Map k a) to memoize behind the scenes?
06:51:57 <bitonic> nand`: yes you could
06:51:57 <drdo> I don't see why not, it was the first thing i thought about (minus the unsafe part)
06:52:47 <levkin> Hi . Trying to use hoogle (application) offline after installing haskell platform on Ubuntu 8 . After 'cabal install iteratee' I tried to 'hoogle iteratee' however no specific information on functions was returned . What am I missing ?
06:52:48 <nand`> drdo: I don't know how to implement it without unsafe if you don't want to bug the programmer with including a StateT or an IO in the new type
06:52:49 <drdo> I'm not familiar with how ghc treats unsafe IO but i'd wager there are lots of implications for optimization
06:53:15 <bitonic> nand`: yeah, you need unsafePerformIO to keep that type
06:54:36 <drdo> nand`: Yes, i understand it, was mainly wondering how such a thing might affect optimization
06:55:22 <bitonic> maybe you can even create a typeclass that works for arbitrary functions (as long as the arguments are Ord or whatever you need), check Testable out for inspiration
06:55:29 <scooty-puff> bitonic: i guess adding test :: Sing "test"; test = sing atleast doesn't have the namespace problem that data Test; test = Test has
06:55:33 <nand`> I also don't know how that would even work for recursion; you'd probably have to have something like “fib = memoize fib'; fib' n = fib (n-1) + fib (n-2)”
06:56:09 <nand`> but then you have to know GHC won't re-evaluate “fib” (assuming memoize uses unsafe IO to create a new IORef for every invocation)
06:56:18 <bitonic> nand`: well, concurrent access to your map would be even more worrying :P
06:56:26 <bitonic> I mean it's not something you actually want to do
06:56:29 <nand`> bitonic: true; that's a whole new can of worms
06:56:32 <drdo> nand`: I would probablity right seomthing like: fib = memo fib' (newline) where  ...
06:56:36 <drdo> *something
06:57:26 <nand`> I'm still confused as to why GHC can't find HScereal-0.3.5.1
06:58:11 <nand`> “ghc test.hs” returns a link error “cannot find -lHScereal-0.3.5.1” and trying to load it in ghci returns “libHScereal-0.3.5.1.so: cannot open shared object file: No such file or directory”
06:58:25 <drdo> I have been meaning to read more about ghc packages, cabal, etc
06:58:27 <nand`> I've already tried reinstalling cereal
06:59:03 <drdo> Once in a while i get some weird problems i have no clue about
06:59:59 <drdo> And i still don't really understand the deal with cabal-install's update command being problemmatic
07:00:09 <nand`> I don't even have “cabal-install”
07:00:11 <cg_morton> one memo solution is to pass around a memo table, which to my limited understanding seems amenable to monad-ization
07:00:23 <drdo> Or the broken packages dark magic
07:00:37 <cg_morton> is that entirely impractical or am I actually a genius?
07:01:01 <nand`> cg_morton: you mean like “memo :: Key k => (k -> a) -> k -> State (Map k a) a” ?
07:01:01 <drdo> cg_morton: Neither, it's called a state monad
07:01:04 <bitonic> cg_morton: they've done it already
07:01:08 <bitonic> again
07:01:10 <bitonic> @hackage MemoTrie
07:01:10 <lambdabot> http://hackage.haskell.org/package/MemoTrie
07:01:22 <nand`> err (Ord k) =>
07:01:22 <bitonic> actually, that is not a monad :P
07:01:30 <cg_morton> ha, well okay.  semi-genius then
07:02:09 <bitonic> also
07:02:15 <bitonic> @hackage data-memocombinators
07:02:16 <lambdabot> http://hackage.haskell.org/package/data-memocombinators
07:02:28 <bitonic> also, http://stackoverflow.com/questions/3208258/memoization-in-haskell
07:03:08 <bitonic> data-memocombinators has a fib example! ehe
07:10:20 <nand`> Data.MemoTrie is fun to play with
07:13:30 <nand`> the (usually O(n²)) representation doesn't seem much slower than the canonical O(n) representation “fibs = 1:1: zipWith fibs (tail fibs)”
07:13:40 <nand`> when calculating the 100,000th number
07:15:09 <hpaste_> keep_learning annotated “same function declaration for different data types” with “same function declaration for different data types (annotation)” at http://hpaste.org/67646#a67649
07:15:14 <scooty-puff> data Stream = a :| Stream a; infixr 5 :|; fibs = 1 :| 1 :| zipWith fibs (Stream.tail fibs)
07:15:19 <scooty-puff> that [] case bugs me..
07:15:24 <Brolapse> scooty puff jr!
07:15:37 <keep_learning> dblhelix: Hi
07:15:39 <scooty-puff> SR!  THE DOOMBRINGER!
07:15:54 <Brolapse> <3
07:15:57 <wli> nand`: http://www.haskell.org/haskellwiki/The_Fibonacci_sequence#Fastest_Fib_in_the_West
07:17:18 <keep_learning> I have  Point a = Point Int Int a which can be instance of Double and Bool
07:17:44 <keep_learning> I have defined the multiplication for Double and Bool
07:18:04 <keep_learning> and now want to define multiplication for Double and Bool
07:18:23 <keep_learning> Could some one please tell me how to do this
07:18:31 <keep_learning> http://hpaste.org/67646
07:19:20 <dblhelix> keep_learning: didn't you ask about this two hours ago already? :)
07:19:44 <t7> @pl (\(a, _) -> a !! i)
07:19:45 <lambdabot> (!! i) . fst
07:19:46 <rwbarton> I suggest you not do what it looks like you want to do
07:19:47 <keep_learning> dblhelix: Yes
07:20:04 <keep_learning> but Now I am trying to do this for Double and bool
07:20:18 <dblhelix> keep_learning: what function are you trying to define then?
07:20:23 <keep_learning> dblhelix: http://hpaste.org/67646
07:20:45 <keep_learning> dblhelix: multPointsDB
07:21:04 <dblhelix> keep_learning: ah, okay.. let's have a look ...
07:21:10 <keep_learning> dblhelix: how to make it some thing like instance
07:21:24 <scooty-puff> multi param type class with fun deps
07:21:47 <scooty-puff> http://www.haskell.org/haskellwiki/Functional_dependencies
07:21:54 <scooty-puff> i'm just guessing
07:22:25 <scooty-puff> you need to have the original type class have 3 type params, where the first two determine the last
07:22:30 <rwbarton> why not just write a conversion function Point Bool -> Point Double
07:22:43 <scooty-puff> class Sparse a b c | a b -> c where mult :: a -> b -> c
07:22:44 <scooty-puff> or that
07:24:30 <keep_learning> rwbarton: So before multiplying  convert bool into Double and then multiply them.
07:25:09 <t7> i wish windows console would outpute unicode :'(
07:25:20 <rwbarton> yes
07:25:26 <rwbarton> I mean the fundep approach will work too
07:25:35 <keep_learning> rwbarton: scooty-puff dblhelix Thank you
07:25:45 <scooty-puff> btw, instance Sparse (Point Bool) (Point Bool) (Point Bool) where mult = multPointsB; instance Sparse (Point Double) (Point Bool) (Point Double) where mult = multPointsDB
07:26:22 <scooty-puff> assuming the type class i mentioned earlier
07:26:57 <keep_learning> Just curious but type families are some how  related to functional dependencies ?
07:28:03 <t7> > chr 48
07:28:04 <lambdabot>   '0'
07:28:06 <scooty-puff> this won't be the best answer, but: type families and fundeps solve the same problem, and both can represent the same things
07:28:09 <t7> > ord a
07:28:10 <lambdabot>   Couldn't match expected type `GHC.Types.Char'
07:28:10 <lambdabot>         against inferred type...
07:28:12 <t7> > ord 'a'
07:28:13 <lambdabot>   97
07:28:21 <scooty-puff> type families are newer, and often preferred for type level arithmetic, etc.
07:28:22 <t7> wtf
07:28:24 <scooty-puff> i prefer fundeps personally
07:28:35 <scooty-puff> to do this with type families:
07:28:36 <bitonic> scooty-puff: type families are more powerful than fundeps, but can solve the same problems
07:28:48 <sipa> t7: what's so wtf?
07:28:49 <scooty-puff> k
07:29:03 <t7> i though 'a' had ascii around 40
07:29:14 <scooty-puff> keep_learning: with type families: class Sparse a b where type C a b; mult :: a -> b -> C a b
07:29:23 <aristid> bitonic: i think fundeps still have an advantage or two for some problems.
07:29:25 <scooty-puff> you'll want to use a better name than "C" for the associated type
07:29:31 <nand`> > map chr [30..50]
07:29:32 <lambdabot>   "\RS\US !\"#$%&'()*+,-./012"
07:29:32 <bitonic> fundeps are tricky, those two conditions are annoying. imo type families are much more intuitive, imho.
07:29:38 <bitonic> aristid: which ones?
07:29:49 <bitonic> > ord 'a'
07:29:50 <lambdabot>   97
07:29:56 <bitonic> t7: nope
07:29:57 <aristid> bitonic: more concise syntax, and bidirectional dependencies are things i can think of
07:30:00 <rwbarton> 'A' is 0x41 if that's what you're thinking
07:30:10 <sipa> t7: digits are 0011...., uppercase is 010....., lowercase is 011..... in binary
07:30:31 <nand`> > chr 0x41
07:30:32 <bitonic> aristid: you can express bidirectional dependencies with type families
07:30:32 <lambdabot>   'A'
07:30:33 <keep_learning> @google type families
07:30:35 <lambdabot> http://www.haskell.org/haskellwiki/GHC/Type_families
07:30:36 <lambdabot> Title: GHC/Type families - HaskellWiki
07:30:39 <aristid> bitonic: how?
07:30:43 <bitonic> aristid: but I suppose you have to type less yeah
07:31:10 <aristid> bitonic: i'm for using both type families and fundeps, depending on what is more appropriate for the problem at hand.
07:31:19 <bitonic> aristid: with "bidirectional deps" you just mean "... | a -> b, b -> a" right? You'll just have two type families Foo a and Foo b
07:31:35 <bitonic> aristid: I'm pretty sure they proved that you can do everything you can do with fundeps with type families
07:31:53 <bitonic> sorry, Foo a and Bar b
07:32:19 <hpaste_> dblhelix pasted “A solution to keep_learning's problem” at http://hpaste.org/67652
07:32:23 <aristid> wouldn't that require making both a and b non-parameters?
07:32:39 <bitonic> non-parameters to what?
07:32:45 <dblhelix> keep_learning: for a solution with type families: http://hpaste.org/67652
07:32:45 <aristid> to the type class
07:32:48 <bitonic> why?
07:33:03 <aristid> because they need to be expressed by the type family?
07:33:05 <bitonic> ah, right
07:33:27 <aristid> if you replace a fundep with a type family, the right-hand side of the fundep becomes a non-parameter
07:33:44 <aristid> but with bidirectional fundeps, both sides are lifted, and i'm not sure how that can be solved
07:34:03 <bitonic> well, you can have them both and enforce stuff with type equality
07:34:12 <bitonic> Foo a ~ b, Bar b ~ a
07:34:14 <bitonic> maybe.
07:34:24 <bitonic> I'd have to code it to see better :P
07:34:54 <aristid> bitonic: ok, that might work. i'm not very familiar with advanced uses of equality constraints :)
07:34:55 <keep_learning> dblhelix: Now we have multiparameter class with functional dependency
07:35:02 <keep_learning> dblhelix: Thank you
07:35:13 <dblhelix> keep_learning: w/o fundeps, w/type families
07:35:16 <bitonic> aristid: as I said, I think they proved that everything you can do with fundeps, you can do with type families
07:36:17 <aristid> bitonic: i actually find fundeps easier to understand btw. :D but there's a big problem i have with fundeps:
07:36:46 <aristid> bitonic: they can pollute the class parameter space. and if you have classes that depend on other classes, it can get worse. type families keep that much tidier
07:37:10 <bitonic> aristid: I think they'e easier superficially (maybe) but the conditions to make everything work nicely are very subtle
07:37:14 <keep_learning> bitonic: is functional dependency only reason to introduce type families ?
07:37:28 <bitonic> keep_learning: eh?
07:37:38 <aristid> keep_learning: no, they are different attempts at solving roughly the same problem
07:37:43 <bitonic> aristid: see coverage & paterson condition
07:37:52 <aristid> bitonic: got a link?
07:38:09 <keep_learning> bitonic: Just asking I am almost new to  both concept :)
07:38:46 <aristid> bitonic: i think for verbosity reasons alone, there will always be a place for fundeps in my code :D
07:38:49 <bitonic> aristid: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-class-extensions.html , section 7.6.3.2
07:39:15 <bitonic> actually the paterson condition seems to be unrelated to fundeps, I remembered otherwise
07:39:42 <aristid> bitonic: heh, i just add the extensions that ghc demands and it works :D
07:40:22 <bitonic> aristid: UndecidableInstaces tsk
07:40:37 <bitonic> then the type classes sytem becomes turing complete ehe
07:41:08 <aristid> bitonic: look at how type families and fundeps are mixed in the same class here: https://github.com/aristidb/aws/blob/master/Aws/Transaction.hs
07:42:53 <bitonic> aristid: :) I guess that sometimes fundeps are more concise
07:43:04 <bitonic> but type families make much more sense, imo
07:50:14 <roha> does somebody know of simpler xml parsing library than HXT which has some documentation?
07:50:31 <t7> \(A : Set0) -> (a : A) -> a      my type checker returns    (a : Set0) -> (b : a) -> b
07:50:36 <t7> does that seem correct?
07:51:09 <t7> i thought it might be (a : Set) -> a -> a
07:51:39 <t7> are they equivalent ?
07:51:47 <bitonic> what's \(A : Set0) -> (a : A) -> a? a type? a function?
07:51:51 <bitonic> did you forget a lambda?
07:52:04 <bitonic> e.g. \(A : Set0) -> \(a : A) -> a?
07:52:05 <t7> \ means lambda
07:52:25 <bitonic> ok
07:53:28 <bitonic> so wait, you actually mean what you write? because as a type (a : A) -> a doesn't make much sense
07:53:36 <b0fh_ua> Hi all! Given list of [1..N] how do I split it in lists by M items in each?
07:53:40 <quicksilver> roha: haxml?
07:53:58 <t7> bitonic: its the id function
07:54:03 <bitonic> t7: then you forgot a lambda
07:54:11 <t7> it starts with a \
07:54:16 <bitonic> the second lambda
07:54:17 <scooty-puff> some syntax i am unfamiliar with: in https://github.com/ghc/packages-base/blob/b5b5ec18819fb85ebf1bdb6345ac031787e6fd54/GHC/TypeLits.hs, what does the export list's type (<=), type (+), etc. mean?
07:54:21 <scooty-puff> vs. (<=), (+)
07:54:39 <bitonic> t7: anyways, the type of that is (A : Set) -> A -> A
07:54:44 <bitonic> what you wrote is not a valid type
07:54:50 <t7> bugger
07:55:09 <t7> do i need a special type application construct or something
07:55:42 <bitonic> what do you mean? I don't even know what type checker you're programming
07:56:26 <hpaste_> t7 pasted “t7's dependant lambda calc” at http://hpaste.org/67655
07:56:37 <roha> quicksilver, hmm i couldn't find that many examples for haxml. but i suppose i'll try again :> thanks
07:57:39 <mjo> There is no documentation for any of the XML libraries, you have to find a project that uses it and figure it out =)
07:57:51 <quicksilver> that's not my recollection
07:57:53 <bitonic> roha: I think I've seen some HXT tutorials floating around... you can probably find help here if you have problems
07:57:56 <quicksilver> I recall haxml having documentation.
07:58:21 <bitonic> quicksilver: they probably mean prose & examples
07:59:03 <mjo> There's API docs, which are useless
07:59:25 <quicksilver> there are API docs which are not remotely useless.
07:59:27 <bitonic> mjo: they're not
07:59:33 <quicksilver> and there are also some tutorials
07:59:35 <quicksilver> and some papers
07:59:59 <mjo> The API docs are only useful if you know which functions to call, which you don't unless you already know how to use the library
08:00:08 <quicksilver> that's not true.
08:00:16 <mjo> The paper and tutorial are for ancient versions and irrelevant
08:00:17 <quicksilver> you can browse the API looking at the different functions
08:00:31 <bitonic> mjo: you get used to explore api docs
08:00:32 <quicksilver> as far as I recall the ancient version is only slightly different
08:00:39 <quicksilver> so "irrelevant" is more hyperbole
08:00:47 <quicksilver> if you were to say more reasonable things like
08:00:50 <mjo> After about three days of that, you might be able to parse an XML file. I know, because three days is how long it took me to do it.
08:00:57 <t7> i think i need forall
08:00:59 <t7> :(
08:01:01 <quicksilver> "it's annoying that the tutorial is for an old version, some stuff has changed"
08:01:05 <quicksilver> then I'd agree.
08:01:18 <bitonic> t7: you already have forall
08:01:48 <bitonic> I mean if you can typechecked what you posted
08:01:57 <mjo> If you don't know the old version, you don't know the new version, and you don't know what changed and which parts of the paper/tutorial are reliably, they aren't very useful.
08:02:04 <mjo> *reliable
08:02:08 <t7> bitonic: its not working correctly
08:02:28 <mjo> I don't want to learn combinator theory, I want to parse this damned file.
08:02:33 <bitonic> t7: oh, that's another story :)
08:02:45 <quicksilver> mjo: talking of "not very useful", saying "there is no documentation for any of the XML libraries" is not very useful.
08:02:49 <quicksilver> since it's not true.
08:02:50 <bitonic> mjo: still reading the papers usually gives a very good idea on what the package is about
08:03:01 <bitonic> mjo: for example the best resource for template haskell is an outdated paper
08:03:04 <t7> λ(T : Set) -> (x : T) -> x     is type checking as     (T : Set) -> (x : T) -> x
08:03:10 <quicksilver> saying "the API docs are hard to get started in, and the tutorial is outdated" would be much more useful
08:03:18 <bitonic> mjo: the names/syntax changed, but the concepts still apply
08:03:52 <cg_morton> b0fh_ua: I don't think anyone answered you.  One thing that would work is: "let splitn n [] = [[]]; splitn n xs = [take n xs] ++ splitn n (drop n xs)"
08:04:19 <mjo> Sorry, I didn't mean to come off as offensive, but the result is the same with or without the sugar coating. There's nothing that tells a new user how to use the XML libraries.
08:04:30 <bitonic> b0fh_ua: btw, if you look at the logs for this morning, someone answered exactly the same question
08:04:57 <bitonic> mjo: the problem is that haskellers are kind of used to api docs and papers
08:05:03 <bitonic> so it's a bit of a vicious circles
08:05:05 <bitonic> *circle
08:05:15 <hpc> cg_morton: write that as "splitn n xs = (take n xs) : splitn n (drop n xs)
08:05:17 <hpc> "
08:05:19 <mjo> I am too, but it sucks if you just want to get work done.
08:05:24 <imi> hi
08:05:26 <quicksilver> mjo: http://www.haskell.org/haskellwiki/HXT
08:05:29 <hpc> [x] ++ xs = (x : xs)
08:05:38 <quicksilver> mjo: appears to be studded with tutorial sections and example code.
08:05:40 <imi> can I somehow create a nameless lambda function like 2->3 3->4 ?
08:05:49 <imi> \(2->3, 3->4) doesn't work
08:05:50 <bitonic> mjo: more like "if you want to hack something together quickly"
08:05:57 <bitonic> mjo: which is important sometimes eh
08:06:04 <quicksilver> imi: (\x -> case x of 2 -> 3; 3 -> 4)
08:06:31 <imi> quicksilver in this case syntax can I use any proper pattern matching?
08:06:37 <quicksilver> I haven't actually used HXT, though, just haxml, which is why I happened to suggest haxml
08:06:39 <mjo> "This page was last modified 22:19, 24 April 2012" so I may be talking out of my ass with respect to HXT =)
08:06:52 <cg_morton> hpc: yeah good call.  Cheers
08:07:00 <merijn> Also, the average haskell users seems likely to despise XML
08:07:17 <cg_morton> wait, why do we despise XML?
08:07:21 * hackagebot hjsmin 0.1.1 - Haskell implementation of a javascript minifier  http://hackage.haskell.org/package/hjsmin-0.1.1 (AlanZimmerman)
08:07:24 <hpc> imi: case is what other forms of pattern-matching desugar to
08:07:25 <hpc> so yes
08:07:30 <hpc> by definition
08:07:39 <imi> ok. thanks
08:07:45 <bitonic> mjo: HXT is a bit harder to begin with because of Arrows, but otherwise more powerful than haxml
08:08:21 <hpc> merijn: the average programmer in general will likely despise XML
08:08:24 <merijn> @quote PhilWadler xml
08:08:24 <lambdabot> PhilWadler says: The essence of XML is this: the problem it solves is not hard, and it does not solve the problem well. (POPL2003)
08:08:34 <hpc> except java programmers
08:08:41 <merijn> hpc: True
08:08:41 <tim_>   <# <
08:09:05 <merijn> cg_morton: Because it's a lousy format with no redeeming qualities other than "there is already a lot of software for it"
08:09:07 <cg_morton> so we prefer... json?
08:09:12 <mux> I for one have absolutely no problems with XML... I however despise people that use it where it's obviously not appropriate
08:09:15 <merijn> cg_morton: That depends on the problem
08:09:31 <merijn> cg_morton: I'd just as soon use plain s-exprs than XML
08:09:36 <imi> hpc, quicksilver: thanks, my code works fine
08:09:46 <mux> pffft, s-exprs...
08:09:57 <merijn> mux: i.e. almost everywhere? :p
08:10:03 <mux> merijn: far from it
08:10:07 <mysticc> Can somebody point to specific examples where Data.Functions.fix is used elegently .. I am trying to understand practical uses of fixed point combinators .. I have seen the example of memoization ..
08:10:11 <hpc> one nice thing i will say about XML is that the steps from
08:10:24 <hpc> the steps from "xml parser" to "html parser" are simple and small
08:10:29 <hpc> *simple and few
08:10:32 * hpc lrns2type
08:10:45 <merijn> hpc: Assuming you don't intend to parse actual HTML, you mean
08:10:52 <ment> the steps from xml parser to html parser are mindblowing and surreal
08:11:26 <mux> the strengths of XML are obvious: plenty of standards describing precisely what it is, plenty of DOM/SAX parsers available in pretty much any language, which makes it adequate for cross-platform data exchange between software components.
08:11:27 <hpc> haha
08:11:32 <merijn> Also, you are probably confusing XHTML (which no one uses, and 90% of the people claiming they do in their doctypes are lying)
08:11:50 <merijn> There's also HTML4 (no way even remotely close to XML) and HTML5 (which I have no clue about)
08:12:06 <cg_morton> hehe, I don't even try to use XHTML, because nobody cares
08:12:07 <hpc> HTML5 is closer to XML
08:12:19 <hpc> perhaps i should have said "generating XML" / "generating HTML"
08:12:35 <hpc> and in the case of stuff like SVG, you can even embed XML directly in the page
08:13:23 <mux> HTML5 only provides an XHTML-like variant, it's not really closer to XML
08:13:44 <mux> and the HTML5 term encompasses many more interesting stuff, many of which have to do with JavaScript rather than HTML
08:13:53 <Elemir> XML-troll ITC
08:14:04 <chris2> i thought there was a function to apply a function at one side of a tuple, like b -> c -> (a,b) -> (a,c), but i cant find it
08:14:20 <merijn> :t second
08:14:22 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (d, b) (d, c)
08:14:35 <merijn> :t second (+1)
08:14:35 <lambdabot> forall b d. (Num b) => (d, b) -> (d, b)
08:14:43 <chris2> thanks!
08:15:25 <merijn> chris2: It's part of the Arrow typeclass, which is (in general) quite useful to occasionally look at to remember what functions it offers
08:15:28 <imi> there was a (\(a,b)->a) function is ir first, or fst, or ...?
08:15:38 <chris2> merijn: i remotely remembered it
08:15:39 <merijn> imi: That's fst
08:15:45 <chris2> but i only checked in applicative
08:16:52 <barrucadu> Is there a built-in function to replace the Nth item of a list?
08:17:11 <merijn> @hoogle [a] -> Int -> a -> [a]
08:17:12 <lambdabot> Network.CGI.Protocol replace :: Eq a => a -> a -> [a] -> [a]
08:17:12 <lambdabot> Data.IntMap findWithDefault :: a -> Key -> IntMap a -> a
08:17:13 <lambdabot> Prelude enumFromThenTo :: Enum a => a -> a -> a -> [a]
08:17:40 <tromp> it's easily defined from splitAt
08:17:44 <tromp> :t splitAt
08:17:45 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:18:28 <barrucadu> Thanks
08:20:22 <mysticc> barrucadu: You should avoid its use as much as possible because it will be really inefficient ..
08:20:36 <merijn> That or define one yourself "update (x:xs) 0 val = val : xs; update (x:xs) n val = x : update xs (n-1) val; update [] _ _ = []"
08:23:13 <bitonic> or you can use `break'
08:23:23 <bitonic> @type break
08:23:24 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
08:23:27 <bitonic> no.
08:23:29 <imi> thanks for your help. bye
08:23:32 <bitonic> @type splitAt
08:23:33 <lambdabot> forall a. Int -> [a] -> ([a], [a])
08:23:34 <mysticc> merijn: Will multiple update use fuse together ?
08:23:35 <bitonic> that
08:24:03 <merijn> They can, I think
08:24:14 <merijn> bitonic: To late, someone already mentioned that :p
08:24:26 <mysticc> merijn: I thought using builtin functions like map , fold etc only fuse ?
08:24:45 <merijn> No clue
08:24:57 <mysticc> bitonic: ^^ ??
08:25:42 <quicksilver> I think 'drop' can fuse
08:25:51 <quicksilver> and the back-half of splitAt is like drop
08:25:52 <parcs`> mysticc: they fuse because there are rewrite rules written for them
08:25:54 <quicksilver> who knows :)
08:26:23 <rwbarton> fusion isn't going to fix your asymptotic performance here anyways
08:26:25 <mysticc> quicksilver: I was talking about the update definition given by merijn
08:26:50 <quicksilver> no, merijn's one won't fuse.
08:26:51 <hpc> i would rather use a better data structure
08:27:03 <mysticc> rwbarton: Yeah , but I was talking about several updates used together .. will really boost up the space consumption
08:27:10 <rwbarton> no
08:27:28 <rwbarton> they will just cause more cons cells to be allocated and then gced, repeatedly
08:27:49 <mysticc> rwbarton: oops .. I meant more work for gc :)
08:28:42 <roconnor> Philippa: do you have any recommended resource for understanding the proof that system F is strongly normalizing?
08:28:42 <lambdabot> roconnor: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:28:59 <quicksilver> I knew what mysticc meant.
08:29:00 <hpc> those conses aren't concerning so much as the list traversals that build them
08:29:18 <quicksilver> mysticc: normally we would talk of increased allocation (rather than consumption)
08:29:30 <mjo> The hello world examples from that HXT page don't actually work: gantu ~ $ ./testhxt hello.xml
08:29:30 <mjo> testhxt: user error (Pattern match failure in do expression at testhxt.hs:12:7-16)
08:29:33 <quicksilver> mysticc: because the memory is allocated, and that is an expense, but it is immediately GCed so it's not "consumed" in a sense.
08:29:56 <bitonic> roconnor: just as a curiosity, wouldn't it be one of those Tait-style proofs? I'm interested as well anyways
08:30:06 <mysticc> quicksilver: Sorry for my term mistake .. feeling is what is important
08:32:09 <rwbarton> under good gc conditions, at least, the extra allocation should amount to just a constant factor increase in run time
08:36:06 <roconnor> bitonic: I think they are all based on Tait, but some proofs are supposed to be somewhat easier to understand.
08:36:32 <roconnor> bitonic: although I find the whole thing pretty mysterious.
08:36:56 <bitonic> roconnor: actually I searched for "system f reducibility" and this came up: http://queuea9.wordpress.com/2010/07/26/reducibility-method-for-cbv-system-f/ , which kinda suggests that Girard's proof does not use that method
08:37:22 * hackagebot ImperativeHaskell 1.0.0.1 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-1.0.0.1 (MatthewMirman)
08:37:45 <bitonic> roconnor: FWIW, TTFP offers a Tait-style proof for the lambda-calculus and type theory and they're readable :P
08:38:29 <bitonic> kind of readable
08:38:36 <bitonic> as far as I remember :P
08:39:39 <roconnor> :)
08:40:24 <bitonic> and I'm definitely not a maths person so you shouldn't have any sorts of problem
08:40:42 <bitonic> at least the lambda-calculus one, I can't remember if I understood the other one :P
08:59:37 <tdammers> I'm currently investigating Haskell as an option for a few production projects
09:00:03 <tdammers> can anyone point me at some resources regarding security?
09:00:15 <tdammers> particularly, the situation of the haskell platform itself
09:00:23 <merijn> tdammers: What kind of security? What's your threat model?
09:00:25 <tdammers> plus the web frameworks
09:01:33 <tdammers> varies per project, between internal web application with limited public exposure up to full-paranoia
09:01:48 <tdammers> I'd like to know if anyone has performed professional-grade audits or similar research
09:01:57 <tdammers> Google doesn't help much in this regard
09:02:35 <merijn> That's not a threat model. Will people have access to the machine the code runs on? Do you want to protect against (D)DoS, remote exploits, etc.
09:02:48 <tdammers> let's see...
09:03:10 <tdammers> the machine the code runs on is going to be a dedicated server somewhere
09:03:22 <tdammers> (proper data center and all, so no unauthorized physical access)
09:04:19 <tdammers> I'm thinking it would be best to run behind a proven-technology web server, say apache or nginx
09:05:14 <merijn> You can, but I'm not sure whether it'll add much security. nginx is probably a better bet than Apache, because its lighter weight and less complex (and thus easier to secure)
09:05:17 <tdammers> but still, the thing is going to be public-facing, so I do need to protect against MITM, DoS, and the usual stuff
09:06:35 <tdammers> the main consideration for running behind another server is serving static files
09:06:35 <tdammers> so that the actual app server can focus on the application itself
09:06:35 <tdammers> and in my situation, I think we have more apache know-how in house than nginx, but I may be wrong
09:06:53 <merijn> I'm sure the available web frameworks will let you use HTTPS (or otherwise you use apache/nginx as a frontend) so that solves MITM
09:07:00 <tdammers> yep
09:07:20 <merijn> DoS, not really much you can do to secure against them
09:07:23 <tdammers> I'm mostly concerned about hashdos, and potential flaws in the GHC runtime and the frameworks
09:08:40 <rs46> I'm trying to use traceEvent in Debug.Trace. My program compiles (with ghc 7.4), but my string messages are not appearing in threadscope.
09:08:47 <rs46> Should they be appearing in threadscope ?
09:10:23 <tdammers> my gut feeling says that Haskell is probably a much better bet than the alternative, Python
09:10:23 <tdammers> but then, python has seen massive public exposure...
09:10:23 <tdammers> so people consider it a safe bet
09:10:24 <tdammers> with Haskell, I need to do some serious convincing ;)
09:10:41 <nus> tdammers, how much would the application logic depend on unrestricted user input?
09:10:47 <Clint> network effects
09:11:26 <sipa> tdammers: i'm sure in some contexts, Haskell and Python can be considered alternatives, but surely there are dozens of languages to consider in that case
09:11:29 <hpc> tdammers: equational reasoning in haskell makes it harder to insert security holes of your own, perhaps?
09:11:55 <merijn> hpc: Also, newtype to enforce escaping in the type system :)
09:12:07 <sipa> i can't imagine a task where i'd say "wow, this looks something where either python or haskell are particularly good at, but no other languages!"
09:12:21 <merijn> sipa: Pretty syntax?
09:12:31 <bitonic> STM?
09:12:36 <hpc> the GHC RTS is already well-understood and it's unlikely you will find a DoS or memory-safety hole anywhere in there
09:12:40 <merijn> python doesn't have STM
09:12:51 <hpc> unless you are doing unsafe* stuff
09:13:03 <hpc> in which case, don't do unsafe* stuff
09:13:05 <bitonic> merijn: but Haskell does, and it's hard to have in impure languages
09:13:37 <merijn> bitonic: The observation was "things where either python or haskell would be good at, but no other languages", unless you were replying to something else?
09:13:38 <tdammers1> hpc: yes, I know all that, but I would like some documentation to back me up
09:14:13 <bitonic> merijn: I was replying to that, and Haskell is good at STM, and no other mainstream langauges I know of can
09:14:27 <merijn> Clojure
09:14:51 <tdammers1> well, the situation is that python is our default choice, and I'm trying to pitch Haskell for a project that I think would be an excellent fit
09:15:00 <bitonic> merijn: clojure has side effect => you can't roll back from transactions
09:15:03 <merijn> I hear their STM is pretty well-performing, unlike any of the JVM/.NET/whatever implementations
09:15:11 <bitonic> still usable STM, but much less guarantees
09:15:40 <tdammers1> doesn't clojure itself run on the jvm?
09:16:00 <merijn> tdammers1: I meant Java, I guess
09:16:27 <tdammers1> well, I heard they are working on a standalone implementation...
09:16:58 <hpc> perl6-hugs has STM via the haskell library
09:17:23 * hackagebot unfoldable 0.5.0 - Class of data structures that can be unfolded.  http://hackage.haskell.org/package/unfoldable-0.5.0 (SjoerdVisscher)
09:17:29 <bitonic> hpc: again, impure langauges will never be as good as Haskell at STM
09:20:14 <mm_freak> i don't get this de bruijn monad
09:22:39 <bitonic> mm_freak: link?
09:22:47 <FliipDude> Hey guys, is there a clean way of writing this function? http://pastebin.com/aNqAYiZA
09:22:51 <mauke> The paste aNqAYiZA has been copied to http://hpaste.org/67657
09:23:12 <mm_freak> bitonic: http://www.soi.city.ac.uk/~ross/papers/debruijn.ps.gz
09:23:26 <rwbarton> FliipDude: you could use cycle
09:23:41 <rwbarton> > cycle [1,2,3]
09:23:41 <lambdabot>   [1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,2,3,1,...
09:23:51 <FliipDude> Im trying not to use too many inbuilt functions if possible.
09:24:11 <rwbarton> well mod and length are Prelude functions also ;)
09:24:17 <hpc> and (!!)
09:24:22 <FliipDude> Well I know... lol
09:24:26 <rwbarton> yes but you wouldn't get rid of !!
09:24:29 <bitonic> mm_freak: thanks
09:24:43 <FliipDude> I just mean is that the cleanest way to write it?
09:24:44 <bitonic> we should really create a haskell papers collection
09:24:50 <mm_freak> i suspect this to get even more complicated when i add types
09:24:51 <bitonic> haskell or haskell-vaguely-related
09:24:59 <mm_freak> i guess i'll go back to integer indices for now
09:25:21 <hpc> FliipDude: getSentence x ss = cycle ss !! (x - 1)
09:25:48 <FliipDude> Ok thank you =)
09:25:52 <hpc> it's easier to tell what values of x will crash at runtime
09:25:58 <hpc> and it works for infinite sentence lists
09:26:13 <mm_freak> hpc: that function is inefficient for short lists
09:26:29 <mm_freak> i would write two versions:  one for cases where you know the list is short and the index is large
09:26:56 <mm_freak> whenever you go over the length of the list a mod+length would be more efficient
09:27:26 <hpc> i would redesign the code around the function :P
09:27:51 <hpc> it smells of "lists as arrays"
09:28:18 <FliipDude> lol
09:30:15 <FliipDude> I timed out yesterday and the day before and the usernames I used are still in here...
09:31:13 <FliipDude> Nevermind...
09:31:42 <hpaste_> “Ertugrul Söylemez” pasted “Efficient cyclic list indexing” at http://hpaste.org/67658
09:31:55 <mm_freak> hpc: that's my variant of your function =)
09:32:23 * hackagebot crypto-api 0.10.2 - A generic interface for cryptographic operations  http://hackage.haskell.org/package/crypto-api-0.10.2 (ThomasDuBuisson)
09:33:06 <absence> not sure if this is the right place to ask, but i did "darcs get http://code.joyridelabs.de/nikki" as suggested by the nikki web site, but all i got was a file called .boring (and the _darcs subdir). is this a common problem? i'm on windows btw
09:34:17 <hpc> absence: wat
09:34:19 <hpc> i get the same thing
09:35:05 <absence> hpc: :(
09:35:18 <mysticc> what is going on here : http://www.reddit.com/r/haskell/comments/stcmq/extensible_records_using_ghcs_new_kind_level/ ?
09:35:20 <hpc> debian testing, darcs from apt-get
09:35:49 <absence> hpc: safe to say it's the repository's fault and not my setup then i guess
09:37:03 <hpc> probably
09:39:01 <mysticc> @hoogle typelits
09:39:01 <lambdabot> No results found
09:40:00 <hpc> mysticc: it looks like manual duck typing
09:40:16 <EvanR_> whats a good way to make a osx gui app
09:40:17 <EvanR_> gtk?
09:40:52 <Twey> No
09:40:58 <EvanR_> which lib
09:40:59 <Eiam> EvanR_: Cocoa
09:41:01 <Twey> Nothing except Cocoa looks decent on OS X
09:41:06 <EvanR_> oh
09:41:17 <EvanR_> is there a cocoa lib
09:41:31 <Twey> There's http://hoc.sourceforge.net/
09:41:48 <Twey> It hasn't been maintained in a while
09:41:58 <Eiam> 2004
09:41:59 <Eiam> =0
09:42:04 <EvanR_> shit
09:42:07 <EvanR_> :(
09:42:22 <EvanR_> doesnt look good
09:42:24 <bitonic> EvanR_: you could try wxwindows
09:42:31 <bitonic> wxwidgets
09:43:04 <EvanR_> gross
09:43:14 <bitonic> EvanR_: why?
09:43:24 <bitonic> it has good Haskell bindings
09:43:37 <EvanR_> will it look good on osx?
09:43:43 <bitonic> EvanR_: yes
09:44:06 <EvanR_> and i can bundle it with the app
09:44:15 <bitonic> what do you mean
09:44:19 <bitonic> it's an haskell library
09:44:27 <EvanR_> wx
09:44:51 <bitonic> I know nothing about mac os x "apps"
09:44:57 <bitonic> if you're referring to those
09:45:31 <EvanR_> yeah
09:45:36 <EvanR_> app bundles
09:46:29 <bitonic> @faq can wx be "bundled with the app"?
09:46:29 <lambdabot> The answer is: Yes! Haskell can do that.
09:47:01 <cg_morton> o.O  How did it do that?
09:47:07 <bitonic> cg_morton: magic
09:47:16 <tgeeky> @faq can haskell solve the halting problem?
09:47:16 <lambdabot> The answer is: Yes! Haskell can do that.
09:47:28 <tgeeky> cg_morton: lies and deception
09:47:40 <cg_morton> ah, stage magic
09:57:12 <mm_freak> tgeeky: actually there are languages for which the halting problem doesn't exist =)
09:57:52 <cg_morton> really?  turing complete languages?
09:57:58 <c_wraith> no
09:58:00 <c_wraith> that's the point
09:58:21 <c_wraith> But it turns out that most problems don't require being turing complete to solve
09:58:44 <c_wraith> In fact, the very nature of "solving a problem" suggests that termination is important
09:58:57 <EvanR_> yet another episode in 'more powerful doesnt mean more better'
09:59:53 <c_wraith> You can sort of see Turing completeness of a language as a trap.
10:00:11 <c_wraith> It allows you to make mistakes that a language that enforces termination doesn't
10:00:38 <mm_freak> you can actually write nonterminating programs in such a language
10:00:51 <mm_freak> the difference is that the compiler can figure out where and when it terminates
10:01:04 <parcs`> roconnor: ping
10:01:12 <c_wraith> The trick is designing languages that let you solve real problems that stop short of letting you stumble into those mistakes.
10:01:40 <monochrom> the catch is that people have been talking about, but not using, such nice languages
10:02:02 <c_wraith> and what a big catch that is.
10:02:15 <cg_morton> what does that even mean, 'enforces termination'
10:02:37 <mm_freak> cg_morton: it means that you can't recurse in every way you want
10:03:05 <monochrom> well, except for SQL and spreadsheets
10:03:06 <mm_freak> either you terminate or you don't do so productively
10:03:32 <parcs`> cg_morton: it means that it has to be obvious to the compiler that something terminates
10:03:40 <tgeeky> mm_freak: do "we" know which kinds of recursion schemes can't be used? Like the list of patterns that edwardk lists
10:04:07 <mm_freak> tgeeky: i don't understand your question
10:04:23 <EvanR_> when im playing a game id be ok if doing nothing and waiting did not eventually lead to termination ;)
10:04:37 <mm_freak> tgeeky: if it's related to the current discussion:  you need to add a constructor layer before recursing
10:04:54 <mm_freak> EvanR_: the program doesn't have to terminate =)
10:05:07 <mm_freak> "enforces termination" is a common misconception
10:05:15 <mm_freak> "not turing-complete" doesn't mean that all programs terminate
10:05:24 <EvanR_> oh
10:05:36 <cg_morton> so I write a program that recurses over Mersenne primes, and if it compiles that proves the number of Mersenne primes is finite
10:05:53 <monochrom> the situation is like #math people wishing for IRC plugins for LaTeX. they have talked about it for 15 years. then one is written for pidgin, finally. then they don't use it, and will keep talking about it for another 15 years
10:06:32 <mm_freak> monochrom: well, there is a simple reason for that…  let me take agda and idris as examples
10:06:57 <monochrom> I forgot agda. there is actually one person using agda for web apps
10:07:01 <mm_freak> agda is simply unusable for practical programming…  i tried to use it many times, but it's simply not meant to be used that way
10:07:01 <tgeeky> mm_freak: does the state of the art research in such languages tell us which, if any, of the recursion schemes listed: http://hackage.haskell.org/packages/archive/recursion-schemes/2.0.1/doc/html/Data-Functor-Foldable.html --  also somewhere in edwardk's blog -- are all of these things permitted?
10:07:11 <mm_freak> idris is still in its infancy
10:07:28 <Phlogistique> 19:06:35 < monochrom> I forgot agda. there is actually one person using agda for web apps <- who's that? is there some code available?
10:07:44 <parcs`> i really hate that the data-lens State operators return a result
10:08:06 <mm_freak> tgeeky: that module requires you to know quite some CT, which i don't
10:08:25 <monochrom> I don't know where to find him or his work. I only heard about it here. he started from ruby for web apps, then he picked up agda, now he tells ruby people about agda
10:08:56 <mm_freak> tgeeky: consuming recursion and guarded corecursion are allowed
10:08:56 <EvanR_> i tried to talk about compile time checking of your code in ruby they laughed at me :(
10:09:20 <mm_freak> monochrom: you mean the lemmachine guy?
10:09:21 <cg_morton> yeah, should ruby programmers really be his target audience?
10:09:29 <monochrom> I don't know
10:09:37 <mm_freak> lemmachine is an HTTP framework for agda
10:09:42 <mm_freak> there is also a javascript compiler for agda
10:10:05 <ment> what's agda
10:10:38 <cg_morton> it's a theorem prover that you can compile
10:10:40 <tgeeky> @google agda
10:10:42 <lambdabot> http://wiki.portal.chalmers.se/agda/
10:10:42 <lambdabot> Title: The Agda Wiki - Agda
10:11:16 <mm_freak> ment: where haskell is a language that ruins you for almost all other languages used in production, agda is a language that ruins you for haskell =)
10:11:29 <ment> sounds good
10:11:49 <ment> how many years do i have to study some kind of type theory before i can write "hello world" on my own?
10:11:50 <mm_freak> i never complained about haskell, until i met agda
10:12:19 <mm_freak> ment: one day for a simple hello world
10:12:35 <mm_freak> one year for a program that prints hello world infinitely
10:12:39 <cg_morton> geezus, provable IO?  how is that even possible?
10:13:09 <parcs`> does anyone know of a lens package that provides MonadState combinators?
10:13:12 <mm_freak> cg_morton: you prove things about IO-involving computations all the time in haskell
10:13:15 <parcs`> aside from data-lens-fd
10:13:37 <cg_morton> mm_freak: maybe you do, I just let it happen.  I am not that advanced yet
10:13:41 <monochrom> provable IO is possible because unprovable IO is impossible
10:14:28 <mm_freak> cg_morton: every other line of IO in advanced haskell code makes use of the fact that 'return' by definition can't have side effects
10:14:56 <cg_morton> okay...
10:15:02 <mm_freak> you use regions, where you prove that a resource cannot leave a region…  you use ST, where you prove that destructive update can't be observed from outside, etc.
10:15:34 <monochrom> anyway, my point is that if you are stuck at saying "property _____ would be very nice" but you have problem recommending a thing with property _____ for use, that's just a lot of hot air.
10:16:23 <monochrom> (except that, like I said, you can already use SQL today!)
10:16:34 <mm_freak> monochrom: not sure about that…  unlike other productive languages haskell is often not only about practical uses, but also about elegance
10:17:03 <EvanR_> ask ruby and javascript people they will not stop talking about whats elegant
10:17:10 <monochrom> haskell is not hot air. you have no problem recommending haskell for many uses
10:17:36 <mm_freak> monochrom: i'm not talking about haskell, i'm talking about haskell features
10:17:43 <monochrom> recommend me one non-Turing-complete language for use
10:17:52 <cg_morton> ruby and javascript people -have- to talk about what's elegant, because it's so easy to write inelegant code in those languages
10:18:02 <mm_freak> if i could, i probably wouldn't use haskell
10:18:42 <EvanR_> elegant needs to stop being jargon for mainstream code
10:18:57 <mm_freak> cg_morton: haskell disables you to acknowledge untyped elegance
10:23:22 <c_wraith> untyped elegance is cute for something you write about in your blog and never see again.
10:23:37 <c_wraith> It's terrible for throwing into the middle of real, continuously evolving software
10:24:08 <c_wraith> It does not stay elegant as you tack on exceptions and special cases as your needs in bizarre situations evolve
10:25:46 <c_wraith> I have a lot of experience with this pattern now. For long-term maintenance, you want some assistance from the language/environment. It's just so much easier to work with when the system is trying to help you, rather than saying "sure, whatever you say is probably fine, I'll just blow up if it isn't"
10:27:48 <mm_freak> c_wraith: unfortunately long-term experience with PHP disables many people to acknowledge the virtues of a useful type system
10:28:19 <mm_freak> of course there are other languages with that behavior, but PHP is the canonical example
10:28:39 <c_wraith> python and ruby are actually the languages I have experience with long-term project maintenance in
10:28:46 <c_wraith> (other than haskell)
10:28:58 <mm_freak> "elegance" in PHP always boils down to using better names for your classes
10:29:42 <mm_freak> AFAIK python is at least strongly typed…  i know nothing about ruby
10:30:17 <cg_morton> wow, haskell has ruined me, I'm trying to think of a situation where weak typing is advantageous, and I -can't-
10:31:59 <c_wraith> ruby is basically a lisp with clumsier syntax and no macros
10:33:30 <tgeeky> c_wraith: no macros? Its entire universe is runtime-redefinable.
10:33:43 <uniquenick> lisp with no macros isn't really lisp though.  I think smalltalk with perlisms is good description of ruby
10:33:56 <c_wraith> with the standards of software engineering used by rails, I'm glad ruby doesn't have macros. They'd significantly increase the incomprehensibility
10:34:14 <c_wraith> rails abuses the crap out of redefining the entire universe at runtime
10:34:37 <tgeeky> c_wraith: I didn't say it was a good thing at all. In fact, I think the opposite is true.
10:34:50 <tgeeky> But surely it's a "powerful" approach, in some sense
10:35:45 <tgeeky> say, in the sense that thermonuclear weapons are a "powerful" way to build residential houses.
10:36:07 <c_wraith> I'm mostly withholding judgement.  Rails is...  very good for what it's intended for.  And its name is exact. Stay on the rails, and you're good. Try to do anything different, and you get a train wreck.
10:36:59 <c_wraith> I just wish I'd known that before starting big projects in it
10:37:45 <roha> somebody familiar with hxt?
10:38:19 <uniquenick> I have two types: User { usermin :: UserMin, more, fields, here } and UserMin { id, name }
10:38:51 <uniquenick> I'd like to have the "id" and "name" functions work on either a User or a UserMin, is there any way to do something like that?
10:39:11 <mm_freak> uniquenick: yes, but only ugly ways
10:39:35 <uniquenick> how ugly?
10:39:52 <mm_freak> uniquenick: you can abuse type classes
10:40:17 <mm_freak> together with lenses you get both getters and setters for 'id' for both User and UserMin
10:40:32 <roha> if so: i need to scan a website which lists events for changes. each event is represented in the html table as a row <tr> with three cells <td>. i neet to get some text out of those cells. heres what i cam up with. it basically works, i just can't extract the middle <td>. any ideas?
10:40:36 <hpaste_> roha pasted “website scanner” at http://hpaste.org/67662
10:41:25 <roha> just a snippet of the html and the the filter function.
10:41:50 <FliipDude> What is the best way to get the last element from a list? The last function?
10:41:58 <mm_freak> FliipDude: yeah
10:42:02 <FliipDude> Ok thanks.
10:43:24 <roha> i would need to extract for each table row the text which is "Flugplatz Dbendorf" in this case
10:43:49 <mysticc> FliipDude: Remember its O(n) ..
10:44:06 <singpolyma> Is there any way to make every instance of someclass also an instance of a new class?  Something like http://pastebin.com/PYx3GX5g -- but that doesn't work
10:44:08 <mauke> The paste PYx3GX5g has been copied to http://hpaste.org/67663
10:44:20 <rwbarton> no
10:44:50 <shepheb> a coworker is looking for a good introduction to Haskell and functional programming concepts. any recommendations?
10:45:17 <singpolyma> rwbarton: Ok.  That's sort of sad (you were replying to me, and not something from before I joined, yes?)
10:45:39 <roha> shepheb, how about real world haskell and learn yourself a haskell for free?
10:45:46 <rwbarton> singpolyma: yes
10:45:55 <rwbarton> it is not really compatible with the open nature of type classes
10:46:02 <singpolyma> shepheb: Learn You a Haskell for Great Good is where I started
10:46:21 <singpolyma> rwbarton: ok.  It seems unambiguous to me, but I'm sure I'm misunderstanding something
10:46:54 <rwbarton> more accurately, you can have your instance (Thing a) => SafeThing a, but then you are not allowed to have any other instances, since someone might create an instance of Thing for the same time and disaster would ensue
10:47:38 <rwbarton> think of the instance declarations in a program as incomplete information, they are just the instances you know about
10:47:48 <rwbarton> you can never assert that a type is *not* an instance of a class
10:48:31 <rwbarton> (also, you wrote "instance (Thing a) => SafeThing t", that's not what you wanted surely)
10:51:28 <Luke> ozataman: I was on vacation for a week. Did you ever make the header changes to csv conduit stuff?
10:52:38 <singpolyma> rwbarton: oh, I see.  that makes sense
10:53:02 <singpolyma> newtypes it is!
10:53:45 <singpolyma> thanks :)
10:55:43 <ozataman> Luke: sorry, been real busy. I intend to take a look at it soon though
10:56:51 <Luke> ozataman: any idea for a workaround? I'm trying to use it for work so my boss is waiting on me =)
10:58:04 <ozataman> Luke: hmmm. well, if you're using one of the Row instances, all you gotta do is drop 1 row from the pipeline
10:58:11 <ozataman> before calling fromCSV
10:58:34 <ozataman> if you're using MapRow, that's where you need to wait for my change
11:01:10 <Luke> ozataman: I'm using MapRow
11:01:23 <Luke> ozataman: I tried doing exactly what you said... is there a way to convert the conduit to a Row conduit?
11:01:30 <Luke> convert from MapRow to Row that is
11:01:50 <ozataman> sure, just go ahead and create a conduit that would do the conversion
11:02:04 <ozataman> type Row ByteString = [ByteString]
11:02:31 <Luke> ozataman: sounds good - thanks man
11:03:04 <ozataman> calling M.elems on any MapRow would give you the [ByteString]
11:03:12 <Luke> ozataman: yeah
11:03:34 <Luke> ozataman: just didn't know if there was any other trickiness involved
11:14:00 <LambdaDusk> If I only want to store key-value pairs, but not really want to do any searching in them (i.e. I only ever touch the thing as a whole), a list of pairs is better than a Map?
11:14:31 <Botje> sure.
11:15:22 <Botje> if you don't mind duplicate keys
11:18:22 <LambdaDusk> Botje: Well, not really.
11:23:47 <clintm> Any recommendations for reading if I want to go from 0 to understaning and possbily using FRP?  Not necessarily looking for a royal road, but I'd like to inject it into my brain all Matrix style if at all possible.
11:24:23 <Leif_Bork> When using compositions of map and filter, would it be better to use a list comprehension instead, when performance is important?
11:25:48 <bitonic> Leif_Bork: map and filter will fuse anyways. let's say that with a list comprehension you're certain that they will
11:26:43 <Leif_Bork> bitonic: Thank you
11:26:46 <bitonic> bitonic: but on GHC map and filter will fuse
11:26:51 <bitonic> lol, Leif_Bork
11:28:19 <Leif_Bork> But what compositions should I look out for?
11:28:37 <clintm> nm, I believe I found it on Conal's blog.
11:28:40 <bitonic> Leif_Bork: what do you mean?
11:29:05 <hpaste_> “Popescu Andrei” pasted “Errors” at http://hpaste.org/67665
11:29:26 <Leif_Bork> is there something commonly used by people that wont fuse?
11:30:17 <andrei> Hello! I am having trouble  with some haskell code.  Is it possible to ask for a bit of help here?
11:30:43 <cg_morton> andrei: no place better
11:30:43 <sclv> yes it is!
11:30:45 <tgeeky> andrei: it's not only possible, it's encouraged
11:31:16 <bitonic> Leif_Bork: uhm. that is an interesting question, I'd say that most simple compositions that can fuse will be fused
11:31:35 <Leif_Bork> what about sum . map?
11:31:46 <Luke> ozataman: can you think of a way I can easily sum the columns?
11:32:03 <bitonic> Leif_Bork: that can't fuse
11:32:07 <Cale> Leif_Bork: that has foldr/build fusion
11:32:10 <bitonic> ah? ok
11:32:11 <ozataman> Luke: just pushed to github and explicit writeHeaders function
11:32:21 <Luke> ozataman: thanks =)
11:32:24 <ozataman> Luke: have no time to test, so can't release to Hackage before we confirm it works
11:32:33 <Cale> er, well, we should check :)
11:32:37 <Clint> what's a sane way to write code that can be used with both strict and lazy bytestrings?
11:32:44 <bitonic> Cale: well ok I guess that map is a form of unfoldr
11:32:49 <Luke> ozataman: right - I'm just trying to hack thought his as quickly as possible and then will circle back and do it right with the new stuff you add
11:33:26 <sclv> As I recall ghc has folder/build fusion turned on.
11:33:43 <ozataman> Luke: for summing, just map them into numbers and use 'sum'
11:33:56 <bitonic> map f = unfoldr (fmap f . listToMaybe)
11:34:00 <hpaste_> “Popescu Andrei” pasted “Robot” at http://hpaste.org/67666
11:34:07 <andrei> Thank you ! Then, here it is. I have to write a haskell program that "walks" a map of Point's and collect minerals. I am trying to build a secondary function that recieves two parameters: a list of tiles that are not walkable  and a memory block containing current position and a list with tiles walked so far
11:34:09 <sclv> I'd actually like a good "state of fuion" blogpost since I don't remember exactly what ghc does and doesn't do at the moment.
11:34:25 <andrei>  These are the errors I recieve : http://hpaste.org/67665 and this is my code http://hpaste.org/67666
11:35:24 <bitonic> Leif_Bork: so yeah sorry map should fuse, my bad
11:35:30 <Cale> andrei: In your data declaration, you name the data constructor Me, but you use Mem
11:35:47 <Leif_Bork> Thanks =)
11:36:08 <sclv> andrei: also I think you mean "where dir = " not "while dir ="
11:36:13 <sclv> and the where clause needs to be indented a bit
11:36:29 <sclv> so it starts further in that the function defintion it augments
11:36:53 <andrei> Thanks everyone! I ll fix the matters and come back here
11:37:34 <mdmkolbe> In the Haskell report what does the "infix conop" annotation beside one of the productions for constr mean (page 40 of Haskell 2010)?  Is it a side condition or just annotating what that production is?
11:37:38 <Cale> I just checked using a simple program and -ddump-simpl-stats, and I see fold/build fusion happening
11:38:13 <nand`> What's the simplest and most straightforward way to convert a Crypto.Types.PubKey.RSA.PublicKey ( http://hackage.haskell.org/packages/archive/crypto-pubkey-types/0.1.1/doc/html/Crypto-Types-PubKey-RSA.html#t:PublicKey ) to and from base64 representation?
11:38:29 <sclv> I guess duncan's thesis is a good current resource describing not only stream fusion but what ghc actually does with fold/build: http://code.haskell.org/~duncan/thesis.pdf
11:38:30 <Cale> mdmkolbe: what section?
11:38:42 <Cale> page 40 of the pdf you mean?
11:39:02 <nand`> I'm thinking something alone the lines of keyToBase64 = encodeBase64 . (serializeKey :: PublicKey -> ByteString)
11:39:05 <monochrom> yeah, I can't find the exact string "infix conop"
11:39:06 <mdmkolbe> Cale: yeah, section 4.2.1
11:39:10 <Cale> yeah, that looks like an annotation explaining what that production is for
11:39:48 <monochrom> it is a comment
11:40:14 <mdmkolbe> Cale, monochrom: ok.  I guess what through me is the use of the bold font which isn't used in other comments
11:40:24 <monochrom> although, similarly positioned things like "k≥0" are more than comments
11:40:57 <dcoutts> sclv: I think the only new thing since my thesis is the simple arity raising transform in GHC which should in theory help build/foldr fusion for foldl but I don't think anyone has tried doing it
11:41:25 <monochrom> the bold font means it is a non-terminal, not English
11:41:27 <Cale> If you look up the syntax for conop, then you'll find that it actually has to be syntactically an infix operator anyway.
11:41:30 <sclv> dcoutts: thanks! good to know.
11:41:37 <Cale> (starting with a : as well)
11:41:53 <mdmkolbe> monochrom: I mean the bold "infix" not the italic "conop"
11:42:09 <Cale> infix doesn't appear bold in my copy...
11:42:10 <andrei> Here is another question, I have  data Cardinal = N | E | S | W deriving (Eq, Show, Ord, Enum) .  I would like
11:42:11 <andrei> get_pos  dir (x,y)
11:42:13 <andrei> 	|dir == N = (x - 1,y)
11:42:22 <andrei> to return a Cardinal instead of an (Int, Int)
11:42:36 <monochrom> that is bold too? oh well, then sorry, I have never read the pdf version (and will not), I only use the html version
11:42:43 <dcoutts> sclv: and yes you recall right, foldr/build is there and has hardly changed for years afaik
11:42:50 <Cale> It's not bold in the pdf I'm looking at
11:43:22 <hpaste_> “Popescu Andrei” pasted “Robot” at http://hpaste.org/67668
11:43:23 <Cale> andrei: It looks like the job of that function would be defeated by having it produce a Cardinal
11:43:40 <mdmkolbe> Cale: hmm, maybe it just looks bold next to all the other italic text
11:43:44 <Cale> andrei: But also, it looks like you'd be better off with pattern matching rather than guards
11:44:16 <Cale> mdmkolbe: Yeah, it's just medium roman type, but it looks a little heavier than the italics
11:51:15 <andrei> Cale: I do recieve http://hpaste.org/67668 .  What I wanted to do is call something like a Cardinal constructor . I don't know how to solve this type conflict
11:59:22 <Cale> andrei: well, what do you want perceiveAndAct to do?
12:00:39 <andrei> I have updated my source a bit , I will paste it in a second. PercieveAndAct is intented to move the robot on the next tile and update it's location / cs(list on unwalkable elements)
12:00:46 <andrei> just a second, I will upload the code again
12:01:33 <hpaste_> “Popescu Andrei” pasted “Newest Code” at http://hpaste.org/67670
12:01:41 <andrei> there it is : http://hpaste.org/67670
12:06:54 <timthelion> Does ghc know how to simplify something like (\a->(\b->b)a) to (\a->a)???
12:07:29 <Botje> it can inline stuff, sure
12:07:35 <timthelion> Like if I make an onion a million layers thick will my resulting program be slower than one which was identical but only one layer?
12:08:30 <Botje> probably not.
12:08:38 <timthelion> good :)
12:08:38 <oddraisent> How can I find number of list which x is element of? :: a -> [[a]] -> Maybe Int. Like f 1 [[1,2],[3,4]] = Just 0
12:08:57 <rwbarton> someone actually benchmarked a program that was like print $ map (id . id . id . id . id . id . id . id . id . id) [1..1000000]
12:09:17 <EvanR_> > indexOf [1,2,3] 2
12:09:18 <lambdabot>   Not in scope: `indexOf'
12:09:20 <timthelion> rwbarton: and?
12:09:33 <rwbarton> the results were useless because their program's running time was dominated by IO
12:09:50 <Botje> oddraisent: find (1 `elem`)
12:10:07 <rwbarton> @type find
12:10:07 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
12:10:08 <byorgey> > elemIndex 2 [1,2,3]
12:10:09 <lambdabot>   Just 1
12:10:14 <andares> rwbarton: isn't there a way to attach some code that times individual sections of the program?
12:10:18 <EvanR_> > find (==2) [1,2,3]
12:10:20 <lambdabot>   Just 2
12:10:21 <timthelion> rwbarton: well ok, I'm generating code, and I'm just trying to figure out how careless I can be...
12:10:22 <andares> like dynamic byte instrumentation?
12:10:30 <andares> that way you could measure around the IO
12:10:41 <byorgey> EvanR_: use elemIndex
12:10:56 <EvanR_> :t elemIndex
12:10:57 <lambdabot> forall a. (Eq a) => a -> [a] -> Maybe Int
12:11:06 <EvanR_> ok
12:11:11 <rwbarton> well the IO will occur interleaved with the "computation", maybe the profiler could do it
12:11:16 <rwbarton> anyways the whole thing was silly :)
12:11:33 <timthelion> > id . id . id . id 1
12:11:34 <lambdabot>   No instance for (GHC.Num.Num (f a))
12:11:34 <lambdabot>    arising from a use of `e_11' at <int...
12:11:35 <hpaste_> “Popescu Andrei” pasted “Errors” at http://hpaste.org/67673
12:11:47 <andrei> here are the errors that I currently recieve : http://hpaste.org/67673
12:12:04 <timthelion> lambdabot: wut?
12:12:10 <Botje> timthelion: you missed a $
12:12:22 <timthelion> Botje: where?
12:12:35 <timthelion> > $ id . id . id 1
12:12:36 <lambdabot>   <no location info>: parse error on input `$'
12:12:38 <Botje> right before the 1
12:12:44 <timthelion> Botje: why do I need it?
12:12:49 <bitonic> @type id
12:12:50 <lambdabot> forall a. a -> a
12:12:52 <bitonic> @type id 1
12:12:53 <lambdabot> forall t. (Num t) => t
12:12:56 <timthelion> > id . id . id $ 1
12:12:58 <lambdabot>   1
12:13:06 <Botje> timthelion: id . id 1 === \x -> id (id 1 x)
12:13:55 <bitonic> timthelion: what you wrote evaluates to 'id . id . 1'
12:14:20 <bitonic> well, if there wasn't a type checker :)
12:14:57 <timthelion> > id 1
12:14:58 <lambdabot>   1
12:15:04 <timthelion> hmm
12:15:41 <bitonic> timthelion: id . id 1 === id . (id 1)
12:15:55 <bitonic> function application always binds tighter than operator
12:15:57 <bitonic> s
12:16:48 <timthelion> > id . id (1)
12:16:49 <lambdabot>   No instance for (GHC.Num.Num (f a))
12:16:49 <lambdabot>    arising from a use of `e_11' at <int...
12:17:05 <bitonic> timthelion: that doesn't change anything, try '(id . id) 1'
12:17:27 <timthelion> so $ != putting parens around everything...
12:17:51 <bitonic> timthelion: $ is an operator with really low priority that simply applies the function on the left to the argument on the right.
12:17:53 <bitonic> @src $
12:17:54 <lambdabot> f $ x = f x
12:17:54 <ion> f $ x = f x
12:17:54 <timthelion> x $ y == (x) (y)?
12:18:11 <quuxman> Is there a language that's similar in spirit to Haskell with a clean syntax, easy HOFs, etc, but more like C in that it's strict evalutaion, and allows unsafe type casting?
12:18:26 <c_wraith> quuxman: disciple?
12:18:45 <ion> GHC Haskell allows unsafe type casting.
12:18:45 <bitonic> quuxman: SML, OCaml are strict, and you probably can do unsafe type casting. why do you want to do that anyways?
12:18:49 <bitonic> @type unsafeCoerce
12:18:50 <lambdabot> Not in scope: `unsafeCoerce'
12:18:51 <timthelion> quuxman: why u want?
12:18:54 <bitonic> @hoogle unsafeCoerce
12:18:54 <lambdabot> Unsafe.Coerce unsafeCoerce :: a -> b
12:19:12 <rwbarton> "unsafe type casting" and "easy HOFs" are somewhat at odds with each other
12:19:28 <jfischoff> maybe DDC?
12:19:30 <rwbarton> well, maybe I mean "safe type casting"
12:19:32 <sam0> can I get some help? http://hpaste.org/67675
12:19:35 <byorgey> http://www.haskell.org/haskellwiki/DDC
12:19:42 <rwbarton> "unsafe type casting" hardly sounds like a feature though :P
12:20:11 <quuxman> rwbarton: honestly it's been a long time since I've written C, but I do remember that being convenient from time to time
12:20:15 <EvanR_> now with long jump!
12:20:28 <Botje> @quote
12:20:28 <lambdabot> sethg says: I feel like I still don't understand comonads.  Maybe I just need a Zen comaster to hit me with a costick and then I'll become coenlightened.
12:20:29 <EvanR_> goto ON ACID
12:20:37 <rwbarton> right, but it was useful because it had some predictable semantics
12:20:43 <bitonic> quuxman: it's convenient in C for reason that are irrelevant in Haskell
12:20:52 <rwbarton> compiler-dependent, sure
12:21:15 <timthelion> rwbarton: hey, it's usefull, for example, in C, you load a 3 byte per collor bitmap extremely quickly, by loading the file into an array, and then creating a new array of Collor pointers to every third byte... :)  Talk about efficiency...
12:21:41 <timthelion> rwbarton: unsafe casts
12:22:47 <rwbarton> right, however C lacks parametric polymorphism
12:22:51 <cg_morton> unsafe casts are useful because it's a low-level language, but any functional language is high-level pretty much by definition
12:23:44 <EvanR_> interesting
12:23:44 <rwbarton> if you try to implement polymorphism by boxing all your values, suddenly casting that byte array to an array of pixels doesn't look too appealing
12:23:48 <cg_morton> rwbarton: in C++, the only legitimate use for unsafe casting is to make OO polymorphism work
12:23:49 <EvanR_> functional machine code
12:24:29 <hpaste_> “Popescu Andrei” pasted “Env.hs” at http://hpaste.org/67676
12:24:46 <andrei> Cale : here is the file in which the error is caused : http://hpaste.org/67676
12:25:26 <monochrom> hahaha Appel is great. in his compiler textbook(s) (the "Tiger" books), the chapter on OO languages, the chapter starting quote is: "ob-ject: to feel distates for something   webster's dictionary"
12:25:42 <EvanR_> lol
12:26:11 <EvanR_> objectionable orientation
12:27:23 <t7> its a shame they stopped developing bitc
12:27:29 <t7> that was a really cool idea
12:27:29 <jfischoff> OO does appear good for at least one thing
12:27:39 <t7> game engines?
12:27:43 <EvanR_> uhg
12:27:44 <EvanR_> no
12:28:01 <jfischoff> graphs where the edge labels are different types based on the type of the node
12:28:03 <dgpratt> jfischoff: making us appreciate FP?
12:28:07 <gwern> 'I am also an ardent supporter of Occam, *THE* language for user-space parallel processing (IMHO, anyway). Completely 100% explicit userspace threading, no room for discretion by compiler or OS, explicit synchronization and explicit affiliation between threads. It's so explicit, even the compiler needs to be over 18 to read it.'
12:28:12 <gwern> https://lwn.net/Articles/492714/
12:28:26 <jfischoff> basically OO object graphs
12:28:35 <jfischoff> are easiest to work with in a OO language
12:28:50 <EvanR_> sounds questionable
12:29:09 <jfischoff> EvanR_: please tell me I am doing it wrong
12:29:24 <monochrom> that is like saying "I know a great use of functional languages! to implement functional languages!"
12:29:48 <EvanR_> represent a graph some other way
12:29:58 <EvanR_> than machine pointers pointing to each other
12:30:03 <EvanR_> use values
12:30:23 <jfischoff> go on
12:30:43 <timthelion> t7: Did they really, the web page doesn't say bitc devel stopped.
12:31:21 <EvanR_> a directed graph is just a list of node pairs
12:31:28 <jfischoff> yep
12:31:29 <t7> last preview release was 4 years ago...
12:31:38 <EvanR_> nodes can be whatever
12:31:46 <EvanR_> edges can be whatever
12:31:55 <EvanR_> in addition to nodes
12:32:16 <Luke> ozataman: i'm actually trying to sum a column and then add the sum to a new row (for each column) back into the same file... is that possible?
12:32:52 <jfischoff> yeah, but the nodes can only have certain edge labels. What is the best way to structure things so that the types are enforced
12:33:20 <EvanR_> making a type which enforces stuff thats too complex might be hard
12:33:37 <EvanR_> but putting checks in is just like how youd do it in a oop class
12:33:46 <EvanR_> checks in the constructors
12:33:49 <EvanR_> and manipulators
12:34:03 <jfischoff> here are some examples approaches http://stackoverflow.com/questions/2363264/how-do-you-manage-an-object-graph-in-haskell
12:34:44 <jfischoff> ekmett's I think is best, but I still don't think it is as easy to work with in Haskell as it is in an OO language
12:34:51 <FliipDude> How do you use an or statement in list comprehension?
12:35:04 <EvanR_> jfischoff: er. what about this is 'object' oriented. why are these values 'objects' ?
12:35:10 <Botje> FliipDude: a || b?
12:35:16 <EvanR_> mutable?
12:35:23 <FliipDude> Its just like that?
12:35:40 <FliipDude> Sorry, I presumed that since and was , it was something different.
12:36:10 <Botje> well, comma isn't really and.
12:36:23 <Botje> it's two consecutive filters.
12:36:28 <zhulikas> Haskell is hard only until you figure out how to think in it
12:36:31 * zhulikas didnt figure it out yet :(
12:36:46 <FliipDude> Oh ok. But it works like and.
12:36:52 <EvanR_> i wonder why people think oop is easy to think in
12:37:00 <EvanR_> it always ends in disaster
12:37:05 <jfischoff> no no its just that in OO you create these restricted hypergraphs, ports and edges and whatnot by connecting up different objects to the properties on them. Doing the same in Haskell is more difficult
12:37:27 <EvanR_> jfischoff: you mean with assignments to object fields?
12:37:31 <EvanR_> thats gross
12:37:31 <jfischoff> yeah
12:37:39 * hackagebot hashtables 1.0.1.5 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.5 (GregoryCollins)
12:37:40 <jfischoff> it just happens
12:37:51 <EvanR_> assigning stuff field by field with imperative commands is a silly way to define values
12:38:14 <jfischoff> hmm not sure what you mean in relation to OO graphs there
12:38:14 <zhulikas> it sucks how much code needs to be written in OOP to solve simple things
12:38:16 <EvanR_> its usually not the goal
12:38:43 <EvanR_> jfischoff: i dont know what you mean by 'oo graph'
12:39:12 <jfischoff> object graph. The graph of how the objects are connected which are currently in memory
12:39:24 <EvanR_> jfischoff: why are they objects in your problem?
12:39:38 <jfischoff> http://en.wikipedia.org/wiki/Object_graph
12:40:06 <jfischoff> well I have an importer and exporter in haskell that takes objects from one OO language to another
12:40:18 <EvanR_> oh :S
12:40:34 <EvanR_> its like that because its literally a tool for oop language
12:40:41 <jfischoff> yeah
12:41:05 <EvanR_> well anyway, just make a regular graph and forget the pointers
12:41:17 <EvanR_> import and export it as regular data as usual
12:41:56 <jfischoff> Thats what I did but I lost a lot of type safety by making it an explicit graph
12:42:02 <EvanR_> maybe theres a way to enforce data validity with the type system, or maybe its not worth it
12:42:23 <jfischoff> There is definitely a trade off as I see it
12:42:31 <EvanR_> importing from an external system, you have no safety anyway
12:42:33 <EvanR_> you need checks
12:43:00 <EvanR_> dependent types ftw?
12:43:06 <jfischoff> yeah
12:43:35 <hpaste_> “Popescu Andrei” pasted “code” at http://hpaste.org/67678
12:43:57 <yan_> can anyone confirm that the hoauth package from cabal is broken? i try installing it and receive back: hoauth-0.3.3 failed during the building phase. The exception was: ExitFailure 1 (Not in scope: type constructor or class `R.PrivateKey')
12:44:12 <jfischoff> I feel with a dependent version of something like fgl you might get the best of both worlds
12:44:27 <jfischoff> generic algorithms and type safety
12:44:34 <jfischoff> right now I get one or the other
12:45:02 <andrei> sorry for the lack of patience, could anyone please point out what am I doing wrong here : http://hpaste.org/67678 ?
12:45:07 <andrei> here are the errors http://hpaste.org/67673
12:46:40 <rwbarton> andrei: that code does not match those errors
12:47:02 <rwbarton> "p' = maybe p (increase p) act", where is this in your pasted code
12:47:30 <andrei> it's a separate file I linked a bit earlier, just a second , I ll repost it
12:47:39 * hackagebot hashtables 1.0.1.6 - Mutable hash tables in the ST monad  http://hackage.haskell.org/package/hashtables-1.0.1.6 (GregoryCollins)
12:47:43 <andrei> here is the code http://hpaste.org/67676
12:47:51 <mobiusbox> hello, I'm having problem using hGetNonBlocking on Windows - it still blocks when using a network handle
12:48:09 <mobiusbox> problems*
12:48:25 <rwbarton> andrei, well, what do you think perceiveAndAct returns
12:48:41 <rwbarton> or
12:48:44 <EvanR_> use a non blocking handle
12:48:50 <rwbarton> I guess I don't know what "Action" is
12:49:04 <andrei> rwbarton : it should return a direction ( Type Cardinal )
12:49:11 <mobiusbox> EvanR_, is that in the Network module?
12:49:17 <andrei> and  the updateted memory date
12:49:22 <rwbarton> you should write type signatures on top-level functions
12:49:53 <rwbarton> anyways on lines 18 and 27 you seem to think act :: Maybe something, when that's not the case, as the error message tells you, not sure what to say
12:51:05 <andrei> this is the  type signature I tried to write : givedir :: [Cardinal] -> a -> Cardinal  but it does not appear to work
12:51:31 <rwbarton> 'a' can't be right
12:51:33 <Cale> andrei: That says that the function givedir takes a list of Cardinals, and a value *of any type whatsoever*
12:51:36 <dmwit> Can't do much with an input of type "a".
12:51:37 <Cale> and produces a Cardinal
12:51:53 <andrei> indeed
12:51:55 <Cale> If givedir doesn't know what type its second parameter is, it won't be able to do anything at all with it.
12:52:15 <andrei> so it should look like givedir :: [Cardinal] -> Mem -> Cardinal ?
12:52:26 <rwbarton> that looks right
12:52:29 <rwbarton> don't ask us, ask ghc!
12:53:07 <nick> Is it possible to define a recursive function where the type class constraints vary based on the types of the values passed to the recursive call?
12:53:30 <dmwit> No, types are one-shot only.
12:53:36 <dmwit> No fair going changing them.
12:53:57 <dmwit> If you tell us what you're trying to do, we might be able to give more help (like a suggested alternative).
12:55:21 <andrei> the function still doesn't work, I will probably give it up.  It s purpose was to take the memory block ( containing curent position and the already-visited tiles) and the " no-go tiles" and to select a valid Cardinal. Is there another easy to comprehend alternative ?
12:55:58 <rwbarton> what do you mean "doesn't work"
12:56:16 <andrei> the compiler outputs the exact same error
12:56:45 <rwbarton> that error is totally unrelated, it isn't even in the same module
12:56:51 <nick> Well, I have a class with an associated function foo :: (a -> Maybe b), and many instances for different types. Now I want to write a regular function  (a -> Maybe d) that through recursion expands to (a -> Maybe b) -> (b -> Maybe c) -> (c -> Maybe d) where each individual function corresponds to an instance of the aforementioned class
12:59:26 <dmwit> nick: Pop up another level. What do you want to do that makes you wish you could write some function that behaved that way?
12:59:52 <mobiusbox> can anyone help with the hGetNonBlocking function?
13:00:31 <EvanR_> open the socket non blocking
13:00:47 <EvanR_> why youd want to do that i dont know
13:00:52 <EvanR_> use a thread and a block socket
13:00:54 <EvanR_> way simpler
13:00:58 <EvanR_> blocking*
13:01:12 <mobiusbox> I need to interact with a telnet server, EvanR_
13:01:36 <EvanR_> use threads
13:01:45 <EvanR_> you will thank me later
13:01:51 <mobiusbox> isn't multithreading more complicated?
13:01:55 <EvanR_> not in haskell
13:02:02 <EvanR_> non blocking sockets is more complicated
13:02:24 <dmwit> Threads are very cheap in Haskell, and immutability makes for some very beautiful models of concurrency.
13:02:54 <mobiusbox> so I presume that I would use MVars to get the telnet input from the telnet thread?
13:03:10 <rwbarton> or a Chan
13:03:13 <thoughtpolice> the runtime also takes care of all this blocking/nonblocking/async stuff transparently these days. just read from the socket, write to the socket, and use threads. they're all very cheap
13:03:25 <mobiusbox> okay
13:03:58 <EvanR_> <3 MVars
13:04:00 <nick> dmwit: I tryto encode the super type relation in the class system: http://www.gitpaste.com/paste/671/EvxuSn4F7yZiD9rLGTjUN63 . This might make things more clearer...
13:05:58 <dmwit> Haskell doesn't do subtyping. You can't really coerce it to do subtyping, either.
13:06:11 <dmwit> So, you'll need to pop up another level: what are you doing that makes you wish you had subtyping?
13:06:26 <mobiusbox> why would you use a class-centric OO model in Haskell, anyway?
13:06:39 <EvanR_> because i just think that way
13:06:43 <dmwit> mobiusbox: Because it's what you're used to from other languages.
13:07:03 <dmwit> It's not a good fit in Haskell, but it can be hard to switch idioms when they're pretty ingrained.
13:07:18 <EvanR_> its a really weird way in itself to make new types from old
13:07:20 <dmwit> But don't worry. With some work, you, too, can start to think in Haskell. =P
13:09:06 <FliipDude> How do you only let a function run if a condition is true?
13:09:27 <mmos> I need debugging tips for a program that hangs. I tried commenting out sections of code to see if it would terminate, but no luck. I am baffled. Is there a way to find out what line it is executing when I ctrl-c? maybe the debugger would help?
13:09:32 <c_wraith> FliipDude: what does "run" mean?
13:09:39 <FliipDude> Ie, the precondition is false
13:09:45 <donri> FliipDude: perhaps you need the type to be Maybe a
13:09:50 <cg_morton> FliipDude: condition && function
13:09:56 <mobiusbox> mmos, can't you trace in GHCi?
13:10:01 <FliipDude> Ok thank you.
13:10:04 <nick> well, http://homepages.cwi.nl/~ralf/OOHaskell/ seems to get pretty far :) disregarding whether you actually want to do oo programming or not
13:10:05 <rwbarton> I think FliipDude meant in Haskell
13:10:12 <FliipDude> I do mean haskell
13:10:24 <c_wraith> FliipDude: no, seriously, what does "run" mean. evaluate, or execute an action? This matters.
13:10:32 <mmos> mobiusbox: I don't understand. I am running ghci. what does "trace" mean?
13:10:44 <mmos> running the debugger?
13:10:52 <mobiusbox> mmos, http://www.haskell.org/ghc/docs/7.2.2/html/users_guide/ghci-debugger.html
13:11:27 <FliipDude> I need it to give an type output but only if the condition is true.
13:11:35 <FliipDude> Im just not sure if you can give a null output in haskell
13:11:44 <rwbarton> what are you going to do with this output
13:11:48 <mobiusbox> FliipDude, there is no such thing as "null output"
13:11:56 <mobiusbox> you're thinking in wrong terms
13:12:13 <mobiusbox> a function has to have an output value for its entire domain
13:12:20 <FliipDude> Im working through a worksheet for uni and it just says that a function has a precondition.
13:12:23 <mobiusbox> for every member, that is
13:12:25 <FliipDude> and im not really sure what it means.
13:12:28 <c_wraith> FliipDude: it really is important - what do you want to avoid? evaluating a function on some arguments? Or executing an action (say an IO action)?
13:12:30 <cg_morton> ohhh
13:12:41 * hackagebot HandsomeSoup 0.2 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.2 (AdityaBhargava)
13:12:52 <cg_morton> precondition usually means that that condition will always be true for the data they're testing your function on
13:13:06 <donri> i bet they're talking about guards
13:13:14 <mmos> since I don't know where it is looping, I would have to set many breakpoints and guess where. Is there a way to find out where it stopped without using breakpoints?
13:13:16 <cg_morton> it's saying 'we will only run your function on data that meets this condition'
13:13:24 <mobiusbox> mmos, I just told you
13:13:26 <mobiusbox> trace
13:13:36 <FliipDude> Ah ok. So is that a guard?
13:13:49 <mobiusbox> it doesn't sound like guards to me
13:14:02 <FliipDude> Ok thanks, ill read up about guards! lol =)
13:14:08 <mmos> okay I ran ":trace main", then ":list" and it said "nothing to list, not stopped at a breakpoint"
13:14:13 <cg_morton> if it's the wording I suspect, you don't need guards at all for this particular assignment
13:14:20 <mmos> so I am stuck
13:14:38 <mobiusbox> did you check hist?
13:14:50 <cg_morton> seeing the actual wording would be great at this point
13:14:57 <hpaste_> brolapse pasted “brolapse” at http://hpaste.org/67679
13:15:03 <mmos> :hist says "not stopped at a breakpoint"
13:15:13 <mobiusbox> that's the only thing?
13:15:19 <mmos> that's all it says
13:15:26 <FliipDude> Ok hang on.
13:15:35 <Brolapse> anyone help me understand why when i changed my type declaration of Rating and Film to data rather than type that now I get errors like Couldn't match expected type `Rating' with actual type `(t0, t1)'
13:15:42 <dmwit> mmos: You might consider adding a few calls to "trace" if you're into that kind of debugging.
13:15:53 <mobiusbox> so does your main function actually have anything in it?
13:15:58 <dmwit> mmos: Add it in a few functions that are likely to be involved in the loop and watch what arguments they're called with.
13:16:22 <nand`> What's the easiest way to make lazy and script bytestrings coexist peacefully?
13:16:28 <mmos> dmwit: that's one of the things I tried, and so far nothing revealed.
13:16:53 <dmwit> Brolapse: The code you pasted compiles fine here.
13:17:02 <mobiusbox> ok, so what happens when you use step?
13:17:02 <mmos> is there a quick way to set breakpoints on all functions?
13:17:12 <mobiusbox> can you step through main?
13:17:16 <mmos> :step says "not stopped at a breakpoint"
13:17:39 <c_wraith> mmos: add a breakpoint then
13:17:41 * hackagebot alsa-pcm 0.6 - Binding to the ALSA Library API (PCM audio).  http://hackage.haskell.org/package/alsa-pcm-0.6 (HenningThielemann)
13:17:42 <EvanR_> setting breakpoints everywhere doesnt sound like the right way to 'step'
13:17:54 <mmos> mobiusbox: if you mean ":step" it's a bit confusing if you write "step" -- I am having a hard time following you in general, sorry
13:18:02 <dmwit> Brolapse: But if you changed something like "type Rating = (Username, Score)" to "data Rating = {- what you pasted -}", then it's clear why there's a type mismatch: data declarations declare new types that aren't equal to any existing one (including tuples)!
13:18:07 <EvanR_> stop debugging and just type the IO actions one by one into ghci
13:18:12 <nand`> to clarify; I have a bunch of functions that work with strict ByteStrings; and I want to mix some functions in that work with lazy ByteStrings. Is all hope lost?
13:18:27 <rwbarton> Brolapse: in particular somewhere else you are apparently still trying to use a tuple as a Rating
13:18:42 <EvanR_> nand`: well use qualified imports LBS. vs BS. for example
13:18:44 <mmos> okay, I need to familiarize myself more with the debugger so I'll go off and do that.
13:18:56 <nand`> in other words; is it possible to write fromLazyToStrict :: (LBS.ByteString -> LBS.ByteString) -> (BS.ByteString -> BS.ByteString)
13:18:58 <mmos> thanks everyone.
13:19:22 <rwbarton> well you can convert in both directions, so sure
13:19:29 <dmwit> nand`: Yes, LBS.ByteString and BS.ByteString are isomorphic.
13:19:41 <dmwit> fromLazyToStrict f = from . f . to
13:19:42 <nand`> EvanR_: the problem is; I don't know how to convert between the two. there's only toChunks and fromChunks and both work on lists of strict bytestrings. I don't want lists; since I need them to be whole in the end. Or do I have to just fold using append?
13:19:50 <dmwit> where from and to are the respective conversion functions
13:20:12 <dmwit> Yes, you have to just fold using append.
13:20:35 <rwbarton> BS.concat . BS.toChunks, or something like that.
13:20:47 <nand`> dmwit: is there a better way to write toLazy = fromChunks . pure; fromLazy = foldl append empty . toChunks
13:20:48 <rwbarton> *LBS.toChunks
13:20:59 <nand`> dmwit: that answers my question
13:21:44 <dmwit> rwbarton++ for actually knowing the API a bit
13:22:25 <EvanR_> do lazy bytestrings have the same 'problem' as hGetContents lazy IO
13:22:52 <ion> @type let foo f = BS.concat . BSL.toChunks . f . BSL.fromChunks . pure in foo
13:22:52 <lambdabot> (BSLC.ByteString -> BSLC.ByteString) -> BSC.ByteString -> BSC.ByteString
13:23:01 <ion> Lazy bytestrings have nothing to do with lazy IO.
13:23:09 <EvanR_> ok
13:23:28 <rwbarton> except to the extent that LBS.hGetContents etc. use lazy IO
13:23:33 <rwbarton> while BS.hGetContents does not
13:24:18 <EvanR_> how is lazy bytestring the type different from normal
13:24:24 <EvanR_> bytestring
13:24:38 <rwbarton> it's just a list of strict bytestrings.
13:24:52 <EvanR_> ah
13:25:06 <ion> nand: See “foo” above.
13:25:29 <dmwit> This gets requested often enough that maybe they should just be added to the library.
13:26:03 <EvanR_> so the choice of which type to use is purely a performance thing?
13:26:06 <dmwit> Lazy.ByteString.noTheOtherKind :: L.BS -> S.BS
13:26:15 <EvanR_> up to the different semantics of hGetContents
13:26:15 <dmwit> Strict.ByteString.noTheOtherKind :: S.BS -> L.BS
13:35:48 <fmap> Why isn't -XUnicodeSyntax enabled by default :(
13:36:10 <hpaste_> “Popescu Andrei” pasted “Type Matching” at http://hpaste.org/67681
13:37:22 <dmwit> "module Robot" -- like it already
13:37:56 <Cale> fmap: because people actually using it is a bit obnoxious :)
13:38:20 <Cale> It's one of those things that seems like it'd be a good idea until you actually try doing it
13:38:41 <roha> ahem, could somebody help me connecting these 3 little functions:
13:38:46 <hpaste_> roha pasted “how to connect these functions” at http://hpaste.org/67682
13:38:55 <andrei> is there a possible way to obtain type matching between the 3 functions( get_pos , givedir and percieveAndAct)  and to get this source to sucesfully compile ?   I m really stuck on it
13:39:07 <andrei> http://hpaste.org/67681 here s the code
13:39:07 <monochrom> people just complain that they can't enter the symbols from their own keyboards
13:39:29 <roha> i wasn't able to find something with the help of ghci :>
13:39:30 <dmwit> Why are you using Maybe in get_pos/givedir?
13:39:32 <monochrom> @quote ray 1970
13:39:32 <lambdabot> ray says: when you're dealing with programmers you are often dealing with people who voluntarily use 1970s terminals. they cannot be reasoned with
13:39:34 <Cale> roha: do accts <- getAccountsFromFile; pages <- mapM getPage accts; return (map parsePage pages)
13:39:41 <dmwit> The one never returns Nothing, and the other crashes if you hand it Nothing.
13:39:45 <dmwit> That seems like a bad match.
13:40:02 <otters> what's the alternative to 1970s terminals
13:40:06 <roha> ou i should have mentioned: preferably without do. at least if there is some short way to do it
13:40:11 <monochrom> ipad :)
13:40:22 <EvanR_> otters: redesign of the entire computer system ecosystem
13:40:29 <EvanR_> which sounds pretty fun
13:40:40 <otters> hmm
13:40:41 <Cale> monochrom: I *can* enter the symbols with my keyboard, but it doesn't really mean that I want to... plain symbols which are a single keystroke are still nicer to type.
13:40:43 <EvanR_> we can keep sata
13:40:49 <otters> well, at least the quote is pithy
13:41:07 <scooty-puff> is there any reason to use the non-church encoded free monad over the standard free monad? (http://hackage.haskell.org/packages/archive/free/2.1/doc/html/Control-Monad-Free.html, http://hackage.haskell.org/packages/archive/kan-extensions/2.1.2/doc/html/Control-Monad-Free-Church.html)
13:41:10 <Cale> Even symbols which are made from multiple characters are still nicer to type than using LaTeX-SCIM or something.
13:41:32 <EvanR_> Cale: you need a bigger keyboard then
13:41:34 <scooty-puff> *over the standard free monad -> over the church encoded free monad
13:41:44 <Cale> roha: well, we can translate that do-notation away
13:41:45 <monochrom> ok, more seriously, there are several easy ways to arrange for painless entering of the more commom symbols. the setup is easy, and the result is painless. they are just not well known
13:41:52 <Cale> roha: in a number of ways
13:43:15 <rwbarton> scooty-puff: the plain old Free monad can be better for sharing purposes
13:43:18 <dmwit> scooty-puff: Well, the typical reason to use data over functions is that data need only be computed once.
13:43:58 <dmwit> scooty-puff: Perhaps you know more about the two versions of the Free monad than I do, and can take that comment a bit farther. I don't know what the consequences of that are.
13:44:19 <scooty-puff> rwbarton dmwit: k
13:44:29 <roha> Cale, would you think do-notation is the cleanest way to do it in this case? i was just wondering if i was missing some elegant way to do it without do-notation
13:45:05 <Cale> roha: I don't see a particular reason to avoid do-notation here.
13:46:09 <roha> Cale, okay, i think i'll go with do-notation then, thanks!
13:46:30 <monochrom> the particular reason is some zealot's blog article against do-notation
13:46:55 <EvanR_> do notation for concat is annoying
13:47:02 <EvanR_> mconcat
13:47:07 <Cale> You could also write   mapM (fmap parsePage . getPage) <=< getAccountsFromFile
13:47:32 <dmwit> readable
13:47:37 <EvanR_> haha
13:48:09 <dmwit> (Though with suitably renamed and monomorphed functions it might actually be readable.)
13:48:52 <Cale> It's readable for me, but probably not as easy for beginners
13:48:57 <rwbarton> I would have tried something more like   map parsePage <$> mapM getPage =<< getAccountsFromFile
13:49:02 <Cale> and there's nothing wrong with the do-block either
13:49:06 <rwbarton> not sure whether that needs more ()
13:49:15 <Cale> rwbarton: Needs a parameter to getAccountsFromFile
13:49:25 <rwbarton> "do accts <- getAccountsFromFile; pages <- mapM getPage accts; return (map parsePage pages)" ?
13:49:35 <Cale> actually, I messed that up too!
13:49:38 <rwbarton> aha :)
13:49:41 <rwbarton> I didn't actually look at the original.
13:50:17 <dmwit> Cale: I would find it more readable for the same reason I find map and (.) more readable than fmap (when they are the right function).
13:50:42 <roha> monochrom, i was just thinking i should try to write stuff without do-notation at the beginning for developing a better understanding
13:50:48 <dmwit> Namely, the type inference engine I've implemented in wetware isn't as efficient and correct as the type inference engine available in GHC.
13:51:08 <Cale> roha: Well, you should be aware of what you're writing when you use do-notation
13:51:22 <Cale> roha: but there is a reason that do-notation exists
13:51:56 <Cale> getAccountsFromFile f >>= \accts -> mapM getPage accts >>= \pages -> return (map parsePage pages)
13:51:59 <Cale> will also work
13:52:15 <Cale> but do you really want to write like that? :)
13:52:37 <monochrom> I thought you asked about elegance, not understanding
13:53:13 <monochrom> to understand, write both. to search for elegance, write both then pick the maximum
13:53:23 <roha> not really but i think it's good brain gymnastics :>
13:53:58 <monochrom> sorry, I do not see "understand" in "Cale, would you think do-notation is the cleanest way to do it in this case? i was just wondering if i was missing some elegant way to do it without do-notation"
13:54:55 * monochrom is quite impressed by human brain's ability of self-destructive-update
13:55:43 <nand`> How do I resolve ambiguous module names? I have both mtl and monads-tf; and I want to import Control.Monad.State.Strict from the former
13:56:01 <dmwit> monochrom: That's not evidence of destructive update, only of lying. =)
13:56:21 <donri> nand`: there's an extension for package imports
13:56:38 <dmwit> nand`: Use cabal.
13:56:39 <donri> then you can do import "mtl" Control...
13:56:45 <monochrom> oh, what the saying goes, "don't attribute to malice what can be attributed to mutable state" or something :)
13:56:51 <dmwit> heh
13:57:01 <donri> oh, you don't actually depend on both?
13:57:30 <nand`> donri: nope
13:57:37 <donri> in that case, what dmwit said :)
13:58:04 <dolio> getAccountsFromFile f >>= mapM getPage >>= return . map parsePage
13:58:08 <nand`> I don't want to use cabal for absolutely everything though; including one-filers and stuff like ghci
13:58:18 <nand`> a simple “import Control.Monad.State” in ghci fails if I have both installed
13:58:37 <nand`> I think I may just avoid packages which use monads-tf instead
13:59:05 <nand`> In which case; what's a good package for AES en/de-cryption that doesn't pull in monads-tf?
13:59:11 <dmwit> nand`: ghc-pkg hide monads-tf
13:59:48 <monochrom> "ghci -hide-package monads-tf"
14:00:13 <dmwit> You have to do that every time, though, which is a bit annoying.
14:00:42 <monochrom> yeah, it's the same old imperative vs functional trade-off
14:01:06 <nand`> ghc-pkg hide monads-tf did the trick
14:01:12 <nand`> what do you mean by “You have to do that every time”?
14:01:16 <nand`> or was that in response to monochrom
14:01:43 <dmwit> It was in response to monochrom.
14:02:06 <monochrom> "ghci -hide-package monads-tf" is a functional solution and has to be done every time. just like "I have to pass the same parameter every time"
14:03:20 <dmwit> Meh.
14:03:28 <monochrom> the time is ripe for a Reader monad for unix shells
14:04:01 <dmwit> Maybe if you had suggested a command line that mentioned whether to hide or use every package in your database I would believe your commitment to functional programming.
14:06:13 <monochrom> "cabal build" then, which does exactly that :)
14:06:15 <nand`> monochrom: sure; but only if you also mix in a StateT Environment
14:07:47 <dmwit> monochrom: (on Reader) Just read every command "foo" as a "local foo $ rest of whatever you're doing in your shell" and you're good to go.
14:08:24 <hpaste_> “Popescu Andrei” pasted “Issue” at http://hpaste.org/67683
14:09:27 <andrei> I have done some work on my file , but now I get a wierd number of argumments error. : http://hpaste.org/67683
14:09:41 <andrei>   The function `get_pos' is applied to three arguments,
14:09:42 <andrei>     but its type `Maybe Cardinal -> Point -> Point' has only two
14:10:11 <monochrom> "(Just N)"
14:10:53 <monochrom> use http://bm380.user.srcf.net/prettyparsetree.cgi to see what your expressions really mean
14:11:29 <monochrom> http://bm380.user.srcf.net/prettyparsetree.cgi?exp=get_pos+Just+N+%28poz+m%29
14:12:17 <andrei> monochrom, thank you very much now it's working perfectly
14:18:09 <gwern> @remember Morandat "The astute reader will have noticed that the above example clashes with our claim that R is lexically scoped. As is often the case, R is lexically scoped up to the point it is not."
14:18:09 <lambdabot> Good to know.
14:18:14 <gwern> @flush
14:18:58 <monochrom> hahaha
14:19:36 <monochrom> IIRC @flush is recognized iff issued by selected people
14:19:50 <dmwit> It complains if it doesn't like you.
14:19:51 <dmwit> ?flush
14:19:51 <lambdabot> Not enough privileges
14:19:56 <monochrom> oh, nice
14:20:24 <dmwit> hm
14:20:29 <gwern_> ?flush
14:20:30 <lambdabot> Not enough privileges
14:21:11 <monochrom> I think it's just because of the _
14:21:33 <gwern> the admin parameters are static strings, not prefixes...
14:22:45 * hackagebot digestive-functors-heist 0.3.0.1 - Heist frontend for the digestive-functors library  http://hackage.haskell.org/package/digestive-functors-heist-0.3.0.1 (JasperVanDerJeugt)
14:23:50 <gwern> 'One of our discoveries while working out the semantics was how eager evaluation of promises turns out to be. The semantics captures this with C[]; the only cases where promises are not evaluated is in the arguments of a function call and when promises occur in a nested function body, all other references to promises are evaluated. In particular, it was surprising and unnecessary to force assignments as this hampers building infinite structures. Many ...
14:23:56 <gwern> ... basic functions that are lazy in Haskell, for example, are strict in R, including data type constructors. As for sharing, the semantics cleary demonstrates that R prevents sharing by performing copies at assignments. '
14:24:37 <hpaste_> dmwit pasted “code review” at http://hpaste.org/67684
14:24:52 <dmwit> andrei: ^^
14:25:14 <dmwit> I would say as a final piece of code review that your naming scheme is very inconsistent.
14:25:30 <dmwit> You should probably rename "givedir" to "give_dir" and "perceiveAndAct" to "perceive_and_act".
14:25:57 <dmwit> Alternately, if you want to mesh with other Haskell programmer's naming schemes, convert all of the functions to camelCase, so "giveDir", "getPos", and "validDir".
14:28:11 <iisjmii> Quick cery newbie question, can anybody direct me to info on what !! does? I cannot google it.
14:28:23 <dmwit> Use hoogle instead.
14:28:24 <dmwit> ?where hoogle
14:28:25 <lambdabot> http://haskell.org/hoogle
14:28:27 <dmwit> ?where hayoo
14:28:27 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
14:28:41 <monochrom> [a0, a1, a2, a3] !! 2 gives you a2
14:28:58 <dmwit> Give a man a fish...
14:29:35 <iisjmii> Thanks for the the fish and the fishing-rod :)
14:29:38 <monochrom> and he starve for the day for not knowing how to cook
14:29:44 <Botje> ... and he'll resell it on ebay?
14:30:22 <monochrom> give him a sponge, and he has got a job washing dishes
14:31:06 <monochrom> due to this story happening in a country with no lowest-wage law, he still starves :)
14:31:59 <monochrom> anyway, I don't use hoogle, so hoogle doesn't come to my mind
14:32:28 <dmwit> ?. djinn type (!!)
14:32:29 <lambdabot> Error: Undefined type []
14:32:34 <dmwit> oh right
14:32:54 <hayashi> Hmm, language-java's parser blew up on every Java file I tried to parse.  Not sure if that's me using it incorrectly or the actual library not working
14:32:54 <albel727> (as if in a country with lowest-wage law he'll be ok. he just won't be hired, unless he agrees to return all "excess" salary cash to his employer.)
14:33:27 <dmwit> The US has a minimum wage and doesn't have that problem.
14:33:45 <dmwit> Seems like whatever country you're thinking of needs a few brave whistle-blowers. =P
14:33:48 * dmwit puts finger on nose
14:33:51 <monochrom> I agree with that too. it's the last line of my joke but I decided to drop it
14:34:24 <statusfailed> Is there a recommended/decent way to handle nested state monads?
14:34:32 <dmwit> lenses
14:34:35 <albel727> you really have to have guts for whistle-blowing, especially if you're illegal mexican immigrant, e.g.
14:34:42 <statusfailed> DAMNIT i'm finally going to have to learn them D:
14:34:42 <dmwit> Or did you mean StateT s (StateT s')
14:34:48 <statusfailed> not directly nested, no
14:35:00 <statusfailed> dmwit: can you sell Lenses to me? why would they help?
14:35:11 <dmwit> albel727: yeah, very, very gutsy thing to do
14:35:26 <albel727> to the point of being pointless.
14:35:32 <dmwit> statusfailed: There's a function of type foo :: Lens a b -> StateT b m r -> StateT a m r
14:35:36 <albel727> (b/c you just get deported)
14:35:54 <dmwit> statusfailed: Shouldn't need much more of a sales pitch than that.
14:35:59 <dmwit> Actually, the type is probably more like
14:36:18 <dmwit> ...something typeclassy
14:36:39 <statusfailed> haha
14:36:47 <dmwit> statusfailed: Lenses are pretty easy to understand, let me send you my favorite explanation of them.
14:36:52 <monochrom> is it typical that "b" is part of "a"? or the other way round?
14:36:52 <Peaker> I can say that Lens are problematic because they make polymorphic record updates more of a pain...
14:37:01 <dmwit> http://twanvl.nl/blog/haskell/overloading-functional-references
14:37:03 <statusfailed> actually, question: Why is State s = StateT s Identity? Doesn't StateT have 3 type params?
14:37:07 <dmwit> monochrom: b is part of a, typically
14:37:16 <monochrom> nice
14:37:33 <dmwit> statusfailed: Yes, but type State s a = StateT s Identity a can't be used in as many places (because type aliases must always be fully applied).
14:37:46 * hackagebot shelly 0.6 - shell-like (systems) programming in Haskell  http://hackage.haskell.org/package/shelly-0.6 (GregWeber)
14:38:51 <dmwit> statusfailed: On the term level, this kind of transformation from "foo x = (...) x" to "foo = (...)" is pretty common, too.
14:39:36 <dmwit> Peaker: Lenses don't make polymorphic record update any more of a pain than they were to begin with.
14:39:44 <dmwit> You just can't do them with lenses.
14:40:01 <Peaker> dmwit, what kind of lenses do you have? monomorphic records mostly?
14:40:16 <statusfailed> dmwit: That functional references thing _is_ lenses?
14:40:22 <dmwit> I mean: the existence of a nice facility for monomorphic record update does not make polymorphic record update harder.
14:40:27 <dmwit> statusfailed: Yup!
14:40:29 <statusfailed> sick
14:40:33 <statusfailed> saving that :D
14:40:36 <statusfailed> cheers!
14:40:51 <dmwit> And here's the author now. =)
14:40:57 <dmwit> Hiya, twanvl!
14:41:10 <statusfailed> well that's well timed :p
14:41:21 <twanvl> hi
14:42:14 <statusfailed> twanvl: dmwit was just showing your post on functional references: http://twanvl.nl/blog/haskell/overloading-functional-references
14:42:20 <statusfailed> so cheers for that :D
14:42:48 * hackagebot ImperativeHaskell 1.1.0.0 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-1.1.0.0 (MatthewMirman)
14:45:02 <plumenator> I have a phone interview with NTT Data for a Haskell job (Re-engineering work, they said). Anybody know what questions I can expect?
14:46:29 <mdmkolbe> How does GHC's parser resolve the ambiguity between a stmt that is "pat <- exp" and one that is "exp"?  In an LR parser "pat" and "exp" can get conflated so I don't see how this doesn't lead to a reduce/reduce conflict.
14:47:49 <twanvl> mdmkolbe: patterns are parsed as expressions
14:48:50 <mdmkolbe> twanvl: are all expressions valid patterns?
14:49:07 <twanvl> no, things like function applications aren't
14:49:57 <twanvl> but I believe that is handled by a separate check
14:50:17 <twanvl> something like a function  expToPat :: Exp -> Either Error Pat
14:51:39 <mdmkolbe> twanvl: hmm, ugly but I guess it works/is nessisary
14:53:16 * hayashi decides to learn parsec
14:53:32 <Peaker> dmwit, I want what lens do, for my polymorphic records.. Given we already have composeable getters, all that's missing is composable setters which I get with a bit of TH, and then I only lack the ability to treat the getter/setter as a single value, but it's relatively rarely valuable in my experience
14:55:18 <dmwit> Sure, sounds useful.
14:55:40 <stepkut> in theory, what would you call the type class that contains <*> but does not require/imply 'pure'
14:55:55 <twanvl> do you actually have a good application for polymorphic record updates? I have never used them
14:56:35 <Peaker> twanvl, yeah, in https://github.com/Peaker/bottle I use a lot of them
14:56:38 <dmwit> stepkut: "weird"
14:56:48 <twanvl> stepkut: strong lax semimonoidal endofunctor? or just call the typeclass "Apply"
14:56:57 <c_wraith> dmwit: highly technical terminology
14:56:57 <twanvl> http://hackage.haskell.org/packages/archive/semigroupoids/1.2.6.1/doc/html/Data-Functor-Apply.html#g:2
14:57:04 <fmap> @pl \f a b x -> a `f` x `f` b
14:57:04 <lambdabot> (flip .) . ((.) =<< (.))
14:57:11 <monochrom> impure applicative :)
14:57:59 <stepkut> dmwit: I have a type like, Foo a b, for whice I can implement <*> for (Foo a), but to implement pure I would need restrict it to (Foo ())..
14:58:03 <dmwit> I mean, the whole idea of Applicative is that it generalizes "zip" to any number of arguments by giving a "zip" for 0-ary functions and a way to turn n-ary zips into (n+1)-ary zips.
14:58:20 <stepkut> so I could have a Pointed instance for (Foo ())
14:58:27 <stepkut> but for <*> I want (Foo a)
14:58:41 <dmwit> (Plus a law saying that 1-ary zips are, actually, fmap.)
14:58:56 <plumenator> I have a phone interview with NTT Data for a Haskell job (Re-engineering work, they said). Anybody know what questions I can expect?
14:59:31 <Peaker> stepcut, Foo :: * -> *?
14:59:55 <statusfailed> Hmm, the lenses package requires TemplateHaskell < 2.6, but 2.5 fails to build for me
15:00:12 <statusfailed> what do?
15:00:26 <dmwit> There's lots of lens packages.
15:00:28 <stepkut> Peaker: no, Foo :: * -> * -> *
15:00:35 <statusfailed> oh, I was just looking at "lenses"
15:00:37 <dmwit> You can try relaxing the constraints in "lenses", or use one of the other packages.
15:00:44 <statusfailed> dmwit: could you recommend me one?
15:01:06 <dmwit> statusfailed: http://stackoverflow.com/questions/5767129/lenses-fclabels-data-accessor-which-library-for-structure-access-and-mutatio
15:01:29 <dmwit> See the "implementations" section for a discussion of tradeoffs.
15:01:30 <stepkut> I think what I actually have is 'indexed application functions' maybe, but I have not gotten that far yet
15:01:38 <stepkut> s/functions/functors/
15:01:48 <shachaf> stepkut: Is Foo different from (,)?
15:02:32 <shachaf> For (w,) there's an Applicative instance if (Monoid w).
15:03:20 <statusfailed> dmwit: thanks!
15:03:39 <frigga1> Anyone know why "generate n = withSystemRandom . asGenIO $ genContVar (normalDistr n 0.1)" doesn't type check?
15:04:08 <shachaf> Probably because of the types of those functions you're using there.
15:04:23 <shachaf> Mentioning those types (and the error) would be helpful. :-)
15:04:27 <dmwit> Clearly you're frobnosticating the widget generator when you should be frobnosticating the widget factory.
15:04:36 <shachaf> Oh, right, dmwit has it.
15:06:25 <dylukes> frigga1: Is this mwc-random?
15:06:30 <frigga1> Yeah
15:06:43 <dmwit> But yes, posting the error message (say, on hpaste.org) would be nice of you.
15:07:47 * hackagebot cabal-meta 0.2.0 - build multiple packages at once  http://hackage.haskell.org/package/cabal-meta-0.2.0 (GregWeber)
15:07:57 <frigga1> dylukes: genContVar and normalDistr are from statistics though.
15:08:11 <dylukes> I dunno ay of the libraries :\.
15:09:46 <frigga1> The error I'm getting is "Couldn't match expected type 'GenIO' with actual type 'mwc-random...MWC.Gen ...'
15:10:54 <frigga1> Oh, duh.  It looks like it's a package version issue.
15:17:50 <nand`> Is the usage of Control.Monad.Error still recommended? I want to add the ability to fail gracefully to my monad
15:18:13 <Feuerbach> nand`: sure, why not
15:18:52 <gwern> and people complain about haskell: 'We found performance hard to predict. Without a solid understanding of the implementation, users are bound to be surprised by the impact of seemingly small changes to their code. In the binary tree program, adding an extra (and unneeded) return statement or a pair of parentheses () will impact performance in a noticeable way.'
15:19:26 <gwern> 'As a language, R is like French; it has an elegant core, but every rule comes with a set of ad-hoc exceptions that directly contradict it.'
15:20:01 <jfischoff> gwern: in other words "we screwed up"
15:20:08 <c_wraith> that's ok for R. it's not general-purpose. People forgive all kinds of foibles in DSLs
15:20:09 <Peaker> gwern, are you randomly quoting stuff on languages?
15:20:11 <hpc> as a language, agda is like chinese
15:20:17 <hpc> it takes 50 years just to learn the alphabet
15:20:49 <hpc> c_wraith: s/R/$language_of_choice/ :D
15:20:58 <gwern> Peaker: well, the authors are basically comparing R with Haskell - lazy functional languages
15:21:04 <gwern> 'The balance between imperative and functional features is fascinating. We agree with the designers of R that a purely functional language whose main job is to manipulate massive numeric arrays is unlikely to be a success. It is simply too useful to be able to perform updates and have a guarantee that they are done in place rather than hope that a smart compiler will be able to optimize them. The current design is a compromise between the functional ...
15:21:10 <gwern> ... and the imperative; it allows local side effects, but enforces purity across function boundaries. '
15:21:27 <Peaker> "purely functional" is such a misnomer..
15:21:42 <Peaker> "typed effects" could have given people a much better idea of what it is about
15:22:14 <hpc> Peaker: not to mention the ambiguity between "pure, functional" and "entirely functional"
15:25:18 <nand`> Is there a reverse of “IsString” that has “toString :: X s => s -> String”? And I don't mean “show”; I mean something where (toString :: String -> String) = id
15:27:08 <Feuerbach> nand`: ListLike is close
15:27:26 <acowley> I think one of the few upsides of the word "pure" in this context is the emphasis it places on writing code without side effects. Yes, you could put all your functions in IO and have printfs everywhere, but that's not idiomatic.
15:27:49 * hackagebot blaze-svg 0.3.1.0 - SVG combinator library  http://hackage.haskell.org/package/blaze-svg-0.3.1.0 (DeepakJois)
15:29:18 <hpc> acowley: much better to use trace, and enforce ordering with pseq
15:29:25 <hpc> a good programmer can write C in any language :D
15:30:37 <acowley> Indeed. If you emphasize typed effects, it brings to mind something like checked exceptions which are often associated with doing the same thing you were doing, but now it's more difficult.
15:30:54 <acowley> Actually, does pseq actually do something different than seq in that usage?
15:32:49 * hackagebot yesod-paginator 0.3 - A pagination approach for yesod  http://hackage.haskell.org/package/yesod-paginator-0.3 (PatrickBrisbin)
15:33:13 <stepkut> shachaf: yeah, my solution for now was to add a class that can provide a default value for the 'a' type.. but that is not really right for my application
15:33:28 <hayashi> Is there any way to specify end-of-file in a string literal?  I assume not
15:34:04 <EvanR> end of file isnt a character
15:34:16 <EvanR> string is a list of Char
15:34:56 <EvanR> if the string is the contents of a file, the end of the string is at the same place as the end of the file
15:35:22 <hayashi> fair enough, I'm getting confused with control-D and its character-like properties
15:35:30 <EvanR> thats a terminal thing
15:38:11 <hayashi> oh hang on, I'm misreading this error message COMPLETELY
15:39:05 <hayashi> I'm having a very confused ten minutes, ignore me.
15:42:06 <stepkut> shachaf: though, I guess the monoid instance normally makes sense because you do still have to combine the values in the <*>
15:46:45 <FliipDude> if I have ("x", ["p", "y", "z"]) how can I make: [("x", "p"), ("x", "y"), ("x", "z")]?
15:47:20 <shachaf> > (\(x,l) -> map (x,) l) ("x",["p","y","z"])
15:47:21 <lambdabot>   Illegal tuple section: use -XTupleSections
15:47:28 <shachaf> > (\(x,l) -> map ((,) x) l) ("x",["p","y","z"])
15:47:29 <lambdabot>   [("x","p"),("x","y"),("x","z")]
15:47:33 <FliipDude> thanks =)
15:47:58 <EvanR> why is it in a tuple ;)
15:48:04 <EvanR> to begin with
15:48:08 <t7> @pl (\(x,l) -> map ((,) x) l) ("x",["p","y","z"])
15:48:08 <lambdabot> map ((,) "x") ["p", "y", "z"]
15:48:19 <t7> beautiful code
15:48:23 <FliipDude> the letters are just arbiatry. They will be Strings and Ints.
15:48:38 <shachaf> FliipDude: EvanR's question was why you have the tuple in the first place.
15:48:49 <FliipDude> What do you mean?
15:48:55 <EvanR> > (\x l -> map ((,) x) l) "x" ["p","y","z"]
15:48:55 <lambdabot>   [("x","p"),("x","y"),("x","z")]
15:49:05 <EvanR> @pl (\x l -> map ((,) x) l) "x" ["p","y","z"]
15:49:05 <lambdabot> map ((,) "x") ["p", "y", "z"]
15:49:55 <EvanR> @pl (\x l -> map ((,) x) l)
15:49:55 <lambdabot> map . (,)
15:50:32 <EvanR> :t uncurry
15:50:33 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
15:50:50 <EvanR> use map . (,) and if somehow your params are in a tuple compose uncurry
15:51:09 <sykora> :t uncurry $ map . (,)
15:51:10 <lambdabot> forall a a1. (a, [a1]) -> [(a, a1)]
15:51:10 <shachaf> EvanR: Why is (map . (,)) better than (\x l -> map (x,) l)?
15:51:17 <EvanR> i didnt say it was
15:51:27 <shachaf> You said "use map . (,)".
15:51:28 <EvanR> er or are you not talking about the pl
15:51:44 <shachaf> I sometimes wish this channel would stop with the gratuitous @pling whenever a beginner asks a question.
15:51:51 <EvanR> haha
15:51:55 <shachaf> There are cases when it's justified, and then there are most cases.
15:51:56 <EvanR> they started it
15:52:06 <fmap> > (\(a, b) -> zip (repeat a) b) ("x", ["p", "y", "z"])
15:52:07 <lambdabot>   [("x","p"),("x","y"),("x","z")]
15:52:20 <shachaf> "they started it" is one of the worst mindsets in IRC in this context.
15:52:32 <jfischoff> yeah its not always helpful, but when I was a beginner I though it was cool
15:52:40 <FliipDude> lol, thanks guys =)
15:52:45 <EvanR> variables are for losers
15:52:50 <t7> shachaf: stop bringing your bad vibes into our happy channel
15:53:52 <hpc> wait, we are on IRC
15:53:56 <hpc> why do we need to be helpful?
15:53:57 <hpc> :D
15:54:29 <luite> wow it took me a while before i got what @pling meant :)
15:57:37 <EvanR> @pl (\(x,l) -> map ((,) x) l)
15:57:37 <lambdabot> uncurry (map . (,))
15:57:46 <EvanR> @pl (\x l -> map ((,) x) l)
15:57:46 <lambdabot> map . (,)
15:58:14 <EvanR> actually map . (,) is weird
15:58:23 <EvanR> :t (.:)
15:58:24 <lambdabot> forall a b (f :: * -> *) (g :: * -> *). (Functor f, Functor g) => (a -> b) -> f (g a) -> f (g b)
15:58:35 <EvanR> :t map .: (,)
15:58:36 <lambdabot>     Couldn't match expected type `a -> b'
15:58:36 <lambdabot>            against inferred type `(a1, b1)'
15:58:37 <lambdabot>     Probable cause: `(,)' is applied to too many arguments
15:58:39 <EvanR> :(
15:59:19 <EvanR> nvm
16:44:16 <Peaker> acowley, seq only gives denotational semantics guarantees, pseq gives operational guarantees
16:46:05 <acowley> right, and we don't want our debug printf coming out *after* our C-in-Haskell-clothes
16:47:04 <Cale> Does anyone here happen to know how unwinding in proof theory works? (in the sense of a technique for being able to construct concrete bounds on values proven to exist in an apparently nonconstructive way)
16:48:16 <Lemon> since type families are open type-level functions
16:48:31 <Lemon> wouldn't it be more general to allow "kind-classes"?
16:48:51 <Lemon> like, type classes but one level up
16:49:27 <Cale> Lemon: give it time :D
16:50:18 <Cale> Lemon: They've only just extended the kind system to be more interesting than having just * and (->) and a handful of kinds for unboxed stuff.
16:50:56 <Cale> and only just added real kind polymorphism
16:51:25 <Cale> I'm not even completely sure what I'd so with kindclass polymorphism :)
16:51:28 <Cale> do*
16:52:13 <kallisti> overloaded type families.
16:52:31 <Lemon> wait, I confused myself
16:52:44 <Lemon> typeclasses are open functions from types to values
16:52:53 <Lemon> type families are open functions from types to types
16:52:53 * hackagebot sshtun 1.0.0 - Wrapper daemon to manage an ssh tunnel  http://hackage.haskell.org/package/sshtun-1.0.0 (DinoMorelli)
16:53:01 <Lemon> for which there is no value-level equivalent
16:53:46 <Lemon> also, why don't we have closed functions from types to values?
16:54:16 <Lemon> or open functions from values to values?
16:58:02 <Ignorante> Hay alguien aquí que escriba en español?
16:58:58 <Ignorante> Necesito que me recomiende algún tutorial o libro que me permita aprender haskell
17:00:21 <kallisti> @where lyah
17:00:21 <lambdabot> http://www.learnyouahaskell.com/
17:00:27 <kallisti> Ignorante: ^
17:00:38 <kallisti> I don't know of a Spanish tutorial, however.
17:01:24 <Lemon> run it through google translate
17:01:45 <kallisti> he was asking for a book that would allow him to learn Haskell.
17:01:50 <kallisti> oh. you mean LYAH
17:01:52 <kallisti> ha.
17:02:20 <ski> Cale : i want type records ..
17:02:21 <Ignorante> Gracias lambdot: ya lo veo... Espero que esté en españo...  como verás es mi  gran limitación para aprender estas cosas.
17:02:25 <ski> (or at least type tuples)
17:02:26 <kallisti> Ignorante: este es un libro de Ingles.
17:02:50 <lambdabot> Who is "lambdot"? Do we have a zero-dimensional sheep now?
17:03:10 <Ignorante> Si.. alo veo.
17:03:28 <Ignorante> ¿nosabes de algo enespañol que me permita iniciarme?
17:03:29 <ski> -!- There is no such nick lambdot
17:03:59 <acowley> Lemon: GADTs give you a kind of closed function from types to values, no?
17:04:04 <Ignorante> Estoy intentando aprender de http://tryhaskell.org/#14
17:04:19 <ski> Ignorante : /join #haskell.es
17:04:37 <Ignorante> OK ve ahi entonces. Graciasl,
17:04:42 <kallisti> Ignorante: lo siento. no se de un libro en espanol.
17:04:51 <ski> Ignorante : alternatively, try to phrase your questions in english
17:06:02 <ski> acowley : .. to values ?
17:07:24 <acowley> ski: I probably should have thought about it a bit more. But what I meant is that the data constructors produce values while carrying type parameters that may now/soon be restricted by a data kind.
17:07:55 <Pseudonym> Yes.
17:08:29 <Pseudonym> One thing I use GADTs for is to implement monads quickly.
17:08:43 <shapr> ski: or swedish...
17:09:02 <Lemon> I thought GADTs were a function from values to types, sort of
17:09:05 * kallisti got to use his aging high school spanish knowledge today. :P
17:09:07 <ski> shapr : ja, men jag antog att Ignorante inte kunde svenska :)
17:09:22 <Pseudonym> The API for a state monad, for example, include things like this:
17:09:38 <shapr> ski: jo, jag håller med dig, eftersom inte så många kan tala svenska
17:09:39 <Pseudonym> gets :: (s -> a) -> State s a
17:09:52 <Pseudonym> modify :: (s -> s) -> State s ()
17:10:09 <Pseudonym> Which, if you think about it, are modelled quite well by GADTs.
17:10:14 <shapr> ski: nästa tid, får jag en kurs portugues! Jag trot att det blir jättekul!
17:10:26 <Pseudonym> data State s a where { StModify :: (s -> s) -> State s () }
17:10:28 <Pseudonym> and so on
17:10:47 <ski> shapr : du ska lsa portugisiska nsta termin ?
17:10:50 <Pseudonym> Cxi vi ne parolas Esperanton?
17:11:04 <shapr> ski: So perhaps I can use Aarne Ranta's GF to learn basic Portugues vocabulary and grammar the same way I did that with Swedish :-)
17:11:26 <Pseudonym> Estas bedauxrinda.
17:11:27 <shapr> ski: jo, läsa kurs... har glömt mycket svenska :-/
17:11:32 <ski> you used GF to learn swedish ?
17:11:35 <shapr> Sure!
17:11:44 * ski is impressed :)
17:12:07 <tsou> shapr: what's GF?  i'm in the process of learning portuguese..  (i had to double-check the channel i'm on before i typed that!)
17:12:24 <shapr> I plugged GF into a super-basic webapp using HWS, told it to generate random sentences and I would translate them to myself to learn both vocabulary and grammar.
17:12:29 <ski> @where GF
17:12:29 <lambdabot> Grammatical Framework, dependently typed FPL, categorial grammar formalism, supporting multilingual grammar applications for e.g. natural language processing, at <http://www.grammaticalframework.org/
17:12:30 <lambdabot> >. (An old `Alfa' interface is at <http://web.archive.org/web/*/http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>)
17:12:40 <ericmj> Aarne Ranta... är du chalmerist?
17:12:42 <shapr> ski: It didn't seem like a big deal at the time, if I hack it up again I'll put it on Hackage this time :_)
17:12:53 <shapr> ericmj: Nej, jag ar Alabamsk
17:12:53 * hackagebot Frank 0.0 - An experimental programming language with typed algebraic effects  http://hackage.haskell.org/package/Frank-0.0 (ConorMcBride)
17:12:58 <ski> ericmj : vid GU
17:13:15 <tsou> interesting
17:13:23 <tsou> on the other hand swedish is a very easy language..
17:13:28 <ski> shapr : it sounded fun and interesting :)
17:13:37 <shapr> tsou: I think so too, but not everyone would agree
17:13:48 <Pseudonym> shapr, do you think GF would work well with languages which have initial consonant modification?
17:13:54 <shapr> tsou: Portugues is far more challenging, it looks crazier than French!
17:14:02 * ski . o O ( "Mastering Swedish -- Lesson 1" <http://www.slayradio.org/mastering_swedish.php> )
17:14:07 <tsou> shapr: they are close...
17:14:14 <Pseudonym> I'm thinking Celtic languages like Welsh or Sindarin.
17:14:21 <tsou> shapr: i don't think anyone can argue that swedish is not easy..
17:14:21 <shapr> Pseudonym: Heck if I know... I do know it worked for me with Swedish. Which languages have ICM?
17:14:36 <Pseudonym> Not that I need to learn Sindarin, of course.
17:14:45 <shapr> Pseudonym: Oh, no idea... I don't think GF would have helped me try to learn Finnish, for example.
17:14:51 <shapr> Finnish is an entirely different challenge.
17:14:52 <tsou> that is, if you take lsitening/speaking aside and focus on reading/writing of course :P
17:15:18 <Pseudonym> tsou: That's actually a mistake with most language courses, I think.
17:15:21 <ski> tsou : saw a local arabic program (in arabic, with swedish subtitles) about arabic-speaking immigrants learning swedish, and how they thought it was a hard language
17:15:26 <shapr> tsou: I'm from Alabama in the USA, where learning a second language is rare. The fact that I speak Swedish, some Finnish, and snippets of several other languages amazes everyone here.
17:15:32 <Pseudonym> Children learn to speak a language before they learn to read or write it.
17:15:42 <shapr> tsou: I think that people with a background in English and Dutch will find Swedish easy to learn.
17:15:50 <luite> it amazes no one where that i speak english :(
17:15:53 <luite> here
17:16:19 <shapr> luite: Yah, .nl is different like that :-)
17:16:33 <Pseudonym> Celtic languages have... well, let
17:16:38 <Pseudonym> 's take Welsh as an example.
17:16:47 <tsou> shapr: i mean that msot things are very simple in swedish..  there's no conjugation of verbs.. no inclinations, all you pretty much have to do is learn vocabulary and which article each noun "gets"
17:17:02 <Pseudonym> Actually, let's not. Don't have time to explain now.
17:17:07 <shapr> tsou: I don't know if GF has a Portuguese grammar, but if you find out, please tell me!
17:17:32 <shapr> tsou: Oh I agree! Finnish conjugation is terrifying! Swedish doesn't even have a future tense!
17:17:33 <tsou> Pseudonym: depends on what you're interested in.  If it is living.. focus should be on listening/speaking..
17:17:45 <Pseudonym> Even if it isn't, IMO.
17:18:06 <Pseudonym> Think of your native language. One of the key ways that you know if you're using language correctly is if it sounds correct.
17:18:16 <tsou> shapr: finnish is a different beast :P  I speak greek, english, and currently learning portuguese even though i'm living in france :P
17:18:19 <Pseudonym> People don't speak Latin enough
17:18:59 <shapr> tsou: I spent a week or two in Athens, but was unable to pick up any Greek. But in most countries, a week is enough to pick up a decent amount of beginner vocabulary.
17:19:01 <Pseudonym> Perhaps we should take the linguistics to #haskell-blah.
17:19:05 <shapr> perhaps
17:19:14 <tsou> seems fitting :P
17:19:23 <shapr> but I'm trying to persuade tsou to hook GF up to a Portuguese grammar so we'll both have study tools :-)
17:19:26 <shapr> @where GF
17:19:26 <lambdabot> Grammatical Framework, dependently typed FPL, categorial grammar formalism, supporting multilingual grammar applications for e.g. natural language processing, at <http://www.grammaticalframework.org/
17:19:26 <lambdabot> >. (An old `Alfa' interface is at <http://web.archive.org/web/*/http://www.cs.chalmers.se/~hallgren/Alfa/Tutorial/GFplugin.html>)
17:19:38 <tsou> hah
17:19:55 <shapr> tsou: And so I won't have to do the work ;-)
17:20:08 <shapr> Ah, GF has had lots of development since I was learning Swedish, wow!
17:20:38 <shapr> I know earlier GF versions were using hacked up dependent types to get the grammars to work out, have they started using GADTs or something?
17:21:15 * shapr looks for GF grammars
17:29:27 <hpaste_> mmos pasted “hang problem” at http://hpaste.org/67685
17:38:11 * hayashi falls in love with parsec.
17:38:27 <shapr> hayashi: yes!
17:39:00 <shachaf> hi ezyang, shapr, hayashi
17:39:11 <hayashi> hi shachaf
17:39:31 <ezyang> What's the usual way of printing an expression with infix operators with the minimal number of parentheses while still being unambiguous?
17:39:41 <ezyang> shachaf: Hallo.
17:39:57 <shachaf> ezyang: You mean what showsPrec does?
17:40:11 <ezyang> Maybe.
17:40:55 <acowley> ezyang: I usually get the impression that it is hard to do so, so we instead argue that over-parenthesization is a boon to clarity and pretend it's not a problem :/
17:41:15 <ezyang> I think I'll just channel Piponi and do what he did here http://blog.sigfpe.com/2010/12/generalising-godels-theorem-with_24.html
17:41:18 <acowley> Where can I find a revdeps server for hackage?
17:41:39 <ezyang> I dunno if there are any running atm
17:42:33 <luite> packdeps.haskellers.com has reverse deps, but i think only direct dependencies
17:43:14 <acowley> luite: thanks!
17:43:14 <shachaf> Oh, looks like showsPrec doesn't actually do it for infix operators.
17:43:24 <shachaf> Which makes some sense, I guess...
17:43:43 <acowley> It looks like nobody is applying comonad in anger.
17:47:55 * hackagebot openpgp-asciiarmor 0.1 - OpenPGP (RFC4880) ASCII Armor codec  http://hackage.haskell.org/package/openpgp-asciiarmor-0.1 (ClintAdams)
18:12:44 <mmos> finally figured out my infinite loop: not sure exactly how to explain why it happened, but the cause was an incorrect instance of Ord on a type that was used as the key in a Map. the map insertion hung
18:13:33 <glguy> dcoutts: You about?
18:16:58 <acowley> Why can't I use ⊕ as an operator?
18:17:27 <shachaf> > let (⊕) = (+) in 3 ⊕ 2
18:17:28 <lambdabot>   5
18:18:02 <ski> mmos : hm, ok
18:18:27 <acowley> what?!
18:19:07 <acowley> Oh wow, thanks shachaf!
18:19:18 <ski> mmos : is there a reason why `SD.barObjType' returns a string ?
18:19:21 <acowley> I didn't have the parentheses in the type signature and gave up on it too quickly
18:20:55 <ski> can't you merge the return types of `SD.barObjType' and `SD.barObjDetails' (and maybe `SD.barObjPos' as well) into a single type (and those functions into a single function, as well) ?
18:21:40 <mmos> ski: just checking to see if you noticed I figured it out --- now I will look at your comment
18:22:04 <ski> (btw, just so you know, you could use `where' instead of `let'-`in' there, if you wanted to)
18:22:15 <ski> yes, i noticed :)
18:23:24 <ski> just saying that the use of strings there suggest to me that maybe a new type would be more appropriate here
18:24:04 <ski> (also, see the `hlint' suggestions at the end of your <http://hpaste.org/67685> paste)
18:25:04 <mmos> ski: this program converts from something that reads a text file and uses all-string data into a more proper type --- somewhere I have to check the literal string
18:25:45 <mmos> if I used a proper type there, it would just push the case statement to somewhere else
18:26:25 <ski> mmos : true
18:26:32 <mmos> what is the "eta reduce" mean?
18:26:59 <dolio> Go from \x -> f x to f
18:27:14 <ski> i just wasn't sure that was what was happening here, with your matches on `"NoteRest"' and `"BarRest"'
18:27:31 <ski> well, or in this case, it's really extensionality, going from
18:27:38 <ski>   computeChords mis bars = foldr (oneBarChords mis) M.empty bars
18:27:38 <ski> to
18:27:43 <ski>   computeChords mis = foldr (oneBarChords mis) M.empty
18:27:49 <mmos> ski: yes, I see that
18:27:51 <ski> (or even one step further, to
18:28:10 <ski>    computeChords = (`foldr` M.empty) . oneBarChords
18:28:11 <ski> )
18:28:40 <ski> however, you don't need to do any of these steps, but you could consider doing them, pondering which is most clear to you
18:29:40 <mmos> ski: yes, I try to learn more idiomatic haskell when I can. This whole program is not very idiomatic,.. I 'm still an imperative programmer who thinks folds are cool but otherwise doesn't think functionally yet
18:30:46 <mmos> I'm a music student writing some code to help me compose, unfortunately the school deadlines and limited time I have for programming limit me to working with inferior knowledge, for now, but I try to pay attention. hey! I should make a habit of running hlint
18:35:23 <ezyang> @seen AntC
18:35:23 <lambdabot> Unknown command, try @list
18:35:28 <ezyang> ,seen AntC
18:35:43 <ezyang> um
18:38:00 * hackagebot repa 3.1.3.3 - High performance, regular, shape polymorphic parallel arrays.  http://hackage.haskell.org/package/repa-3.1.3.3 (BenLippmeier)
18:38:25 <ski> preflex: xseen AntC
18:38:26 <preflex>  Sorry, I haven't seen AntC
19:18:01 * hackagebot HandsomeSoup 0.3 - Work with HTML more easily in HXT  http://hackage.haskell.org/package/HandsomeSoup-0.3 (AdityaBhargava)
19:31:08 <singpolyma> I'm writing a module that imports different things based on a CPP #ifdef.   My cabal file only lists the libraries that are enabled by the currently defined CPP macros.  Everything builds fine, but cabal haddock --hyperlink-source complains that the library that is *not* imported by the current settings cannot be found (because cabal is hiding it because it is not listed in the depends).   is there something I need to do to make haddock respect CPP, o
19:31:58 <ybit> where is the source for foldl, foldr, map, etc.?
19:32:13 <Mathnerd314_> singpolyma: your message cut off after "to make haddock respect CPP,"
19:32:31 <Mathnerd314> ybit: the Prelude
19:33:13 <ybit> Mathnerd314: where is that?
19:33:14 <Mathnerd314> or Data.List, your pick
19:33:32 <ybit> hadoop
19:33:33 <ybit> right
19:33:36 <ybit> something like that
19:33:37 <ybit> it's been awhile
19:33:45 <Mathnerd314> http://hackage.haskell.org/package/base
19:33:51 <Mathnerd314> @hoogle foldr
19:33:52 <lambdabot> Prelude foldr :: (a -> b -> b) -> b -> [a] -> b
19:33:52 <lambdabot> Data.List foldr :: (a -> b -> b) -> b -> [a] -> b
19:33:52 <lambdabot> Prelude foldr1 :: (a -> a -> a) -> [a] -> a
19:33:58 <ybit> hoogle*
19:35:12 <singpolyma> Mathnerd314: all I said after that was ", or can I not do that?"
19:35:28 <ski> @src map
19:35:28 <lambdabot> map _ []     = []
19:35:28 <lambdabot> map f (x:xs) = f x : map f xs
19:35:31 <ski> @src foldr
19:35:32 <lambdabot> foldr f z []     = z
19:35:32 <lambdabot> foldr f z (x:xs) = f x (foldr f z xs)
19:35:57 <ski> ybit : you might have luck with <http://darcs.haskell.org/packages/base/GHC/Base.lhs>,<http://darcs.haskell.org/packages/base/GHC/List.lhs>
19:38:19 <scooty-puff> i've heard of using a church-encoded free monad to improve the performance of substitutions on trees
19:38:31 <scooty-puff> i assume this would apply to applying a substitution to a type tree?
19:38:49 <scooty-puff> perhaps not noticeable since a type tree would probably not be very deep
19:39:12 <byorgey> it doesn't improve the performance of a single substitution, but of iterated/nested substitutions.
19:39:35 <scooty-puff> does that still count if the type structure is pattern matched upon?  i would guess not
19:39:53 <byorgey> I'm not sure I understand the question
19:40:17 <byorgey> scooty-puff: read this: http://blog.ezyang.com/2012/01/problem-set-the-codensity-transformation/
19:40:26 <scooty-puff> k
19:40:39 <byorgey> (well, don't just read, do the exercises =)
19:42:05 <ybit> eh, it's been awhile... this: sum' :: (Num a) => [a] -> a  ...says that sum has a type of Num and it takes a list of some arbritrary value and returns an arbitrary value?
19:42:30 <ybit> i should probably read tutorials again...
19:43:01 <ybit> ah
19:43:17 <ybit> a is of type Num, sum' takes a list of Nums and returns a Num
19:43:21 <ybit> got it
19:43:52 <ybit> yeah, kind of embarassing, but oh well, carrying on
19:43:55 <ybit> thanks for the link ski
19:45:23 <ski> ybit : s/a is of type Num/a is a type belonging to the type class Num/
19:46:16 <ski> so, *assuming* `a' is a type in the type class `Num' (`a' being an instance of that type class), the function takes a list of `a's as argument, and returns a value of type `a'
19:46:29 <ybit> translating foldl intu js is a little more difficult than i imagained
19:46:33 <ybit> into*
19:46:40 <ybit> imagined
19:48:13 * ski doesn't really know ECMAScript, but imagines it probably shouldn't be that hard
19:51:38 <singpolyma> ok, it seems that running    cabal haddock --ghc-options="-DHAHA"  does not pass the right options to haddock to have it pass -DHAHA to ghc ...
19:57:07 <romildo> @pl \x y -> Expr (In (Bin Add x y))
19:57:07 <lambdabot> ((Expr . In) .) . Bin Add
19:59:40 <yan_> if i have a IO String val inside an IO do block, how do i get the String out of the monad?
20:00:16 <yan_> so i'm doing some computations inside the do.. block, and one of the returns is an 'IO String', and i'm trying to pass it to a pure String -> .. function
20:00:25 <yan_> oh hrm, that's just a bind isn't it
20:01:34 <shachaf> Yep. :-)
20:01:36 <shachaf> @quote /bin/ls
20:01:37 <lambdabot> shachaf says: getLine :: IO String contains a String in the same way that /bin/ls contains a list of files
20:02:02 <shachaf> You never "get the String \"out of\" the IO String", because it isn't in there in the first place.
20:02:12 <shachaf> You can execute the IO String, though, and it'll yield a String.
20:02:45 <ski> romildo : `(Expr . In) .: Bin Add'
20:02:59 <gwern> ' Interestingly, Mu eschews Haskell’s laziness and is a strict language instead. A number of pragmatic design decisions were made: most performance sensitive code reuses C++ from in-house libraries, and strings in Mu are not lists of characters. Furthermore, recursion is provided only optionally (and only 6% of their modules make use of it). Mu provides a fine-grained I/O monad, allowing for both ”I/O” and ”O” (output only). In order to ...
20:03:06 <gwern> ... attain easy interprocess communication, all values in Mu are serializable. ' <-- wait, output only? that seems... a little restricted
20:03:07 <shachaf> In do-notation, you can say do { x <- action; ... x ... }, where "x" is just a String.
20:03:22 <yan_> shachaf: er yea, a lot of this looks super elementary in retrospect but i get caught up in getting stuff through the type checker that i'm just drooling+staring at the end of it
20:04:28 <ski> gwern : that reminds me of "The O in O'Haskell should be interpreted as standing for both Objects and what remains of IO when the Evil I is removed." at <http://web.archive.org/web/20090517021445/http://www.cs.chalmers.se/~nordland/ohaskell/>
20:04:32 <shachaf> yan_: It's not *really* the type checker...
20:04:38 <ski> (possibly Timber <http://timber-lang.org/home.html> does this as well ?)
20:04:45 <ski> gwern : where's that quote from ?
20:04:50 <gwern> cufp
20:04:50 <shachaf> I mean, the type checker tells you when you've gotten something wrong, but if it wasn't there you would just get a runtime error.
20:04:59 <yan_> shachaf: i don't mean the type checker for the question, i mean in general
20:05:08 <ski> (gwern : do you have a direct link ?)
20:05:15 <shachaf> Ah. Well, you come to appreciate it eventually. :-)
20:05:44 <gwern> ski: no
20:07:55 <gwern> oh, naughty dog is back to using lisp. good for them.
20:08:58 <jfischoff> really?
20:09:07 <ski> gwern : is it from a paper, or a presentation, or what ?
20:09:20 <gwern> summary of presentations
20:09:24 <gwern> it's on reddit
20:16:10 <Orclev_> is it possible to re-export only part of a module?
20:16:31 <shachaf> Only by hand, I think.
20:18:56 <jfischoff> so yes
20:19:27 <shachaf> You can reëxport anything you can refer to.
20:19:27 <dncr> is there anything like cscope for haskell?
20:19:30 <shachaf> (And some things you can't.)
20:19:45 <jfischoff> what's cscope?
20:19:46 <shachaf> There's, uh, htags. Or hasktags. Or whatever it's called.
20:20:09 <dncr> jfischoff: it's ctags & more
20:20:25 <jfischoff> sounds cool how is it better than crags?
20:20:34 <jfischoff> autocorrect I swear
20:20:39 <jfischoff> ctags
20:21:10 <dncr> shachaf: ok.  hasktags doesn't seem to associate B to the line of "class A => B"
20:21:43 <dncr> maybe i can fix it to do that
20:21:46 <shachaf> Hmm. That's unfortunate.
20:21:49 <shachaf> You should fix it, indeed!
20:22:24 <jfischoff> does hasktags use Template haskell or haskell-src?
20:22:36 <dncr> jfischoff: cscope allows you to cycle thru the places an identifier is used
20:23:01 <jfischoff> huh that sounds like a trivial enhancement
20:23:23 <dncr> like grep but indexed anh respecting syntax
20:23:49 <jfischoff> you can most definitely get the info you need with Template Haskell. So it should to be hard to fix
20:24:05 <dncr> i see
20:24:55 <romildo> ski, which module defines (.:) ?
20:25:05 <shachaf> romildo: Lambdabot's L.hs
20:25:15 <jfischoff> dncr: but I think you will still need the to use haskell-src to collect all of the classes in the file
20:25:26 <dncr> right
20:25:36 <kallisti> huh... is there a symbol for the set of irrational numbers?
20:25:43 <kallisti> I guess I can just denote it as R - Q
20:25:53 <shachaf> Yep.
20:25:58 <dncr> or R \ Q
20:26:21 <dncr> i bet - is hipper these days
20:26:25 <shachaf> What about the set of uncomputable numbers?
20:26:29 <ski> romildo : `infixr 9 .:' with `(.:) = (.) . (.)'
20:26:53 <jfischoff> shachaf: what for :)
20:27:01 <dncr> though confusable w/ {a - b | a <- R, b <- Q}?
20:27:04 <shachaf> jfischoff: ?
20:27:29 <ski> dncr : `liftM2 (-) R Q'
20:28:17 <jfischoff> shachaf: stupid joke I guess, because we will never now what they are, without some sort of oracle I guess.
20:28:32 <dncr> indeed.  life needs an (import Control.Monad).
20:28:41 <jfischoff> haha
20:29:19 <shachaf> jfischoff: That doesn't mean we don't want to talk about the set as a whole!
20:29:20 <jfischoff> Or better import Control.Monad.Reader
20:29:30 <romildo> @pl \x y -> Expr (In (Bin Add (runExpr x) (runExpr y)))
20:29:30 <lambdabot> ((Expr . In) .) . (. runExpr) . Bin Add . runExpr
20:29:31 <shachaf> jfischoff: For that matter, I don't know of a symbol for computable numbers, either.
20:29:47 <kallisti> shachaf: you could call it ???
20:29:58 <jfischoff> shachar: Good point, infact there is almost I would like to talk about more.
20:30:32 <dncr> {any description here}
20:30:33 <shachaf> kallisti: Is that some fancy Unicode my IRC client isn't rendering, or just question marks?
20:30:34 <jfischoff> shachaf: I tried to talk about this stuff on MathOverflow, man that was a mistake
20:30:58 <shachaf> MathOverflow is weird.
20:31:47 <jfischoff> shachaf: I have only amazing stories, and very, very embarrassing stories
20:32:46 <jfischoff> http://www.ma.utexas.edu/users/goddardb/WCNT11/problems2010.pdf
20:33:02 <jfischoff> shachaf: Search for Math Overflow
20:34:25 <ski> shachaf : looks like question marks to me
20:36:11 <shachaf> jfischoff: There are several occurences of that in the text. Better to say "search for Fischoff". :-)
20:37:25 <ski> romildo :  (Expr . In) .: (Bin Add `on` runExpr)
20:39:02 <jfischoff> shachaf: More accurate that way. So that is one of my amazing stories. My embarrassing story was in related to the countability of sets of infinite Kolmogorov complexity. It got down voted so much they took it off the site.
20:39:50 <ski>   curry ((Expr . In) . uncurry (Bin Add) . join (***) runExpr)  -- is an alternative
20:39:57 <shachaf> What's "infinite Kolmogorov complexity"?
20:40:21 <c_wraith> shachaf: cannot be represented in any way with finite bits
20:40:34 <shachaf> Is it different from "uncomputable"?
20:40:35 <jfischoff> shachaf: numbers that are uncomputable. Numbers that need infinite turing machines
20:40:41 <jfischoff> no
20:41:23 <shachaf> Saying "infinite Kolmogorov complexity" sounds a bit like saying "infinite number" to me. :-)
20:41:44 <jfischoff> right
20:42:16 <jfischoff> exactly. I didn't realize how is it is to say nonsense when talking about Kolmogorov complexity.
20:42:25 <romildo> ski, is (.:) defined in some library? I am not finding it.
20:42:27 <jfischoff> s /how/how easy
20:42:41 <jfischoff> romildo: attoparsec
20:42:53 <jfischoff> romildo:maybe something else
20:43:00 <jfischoff> ?where hayoo
20:43:01 <lambdabot> http://holumbus.fh-wedel.de/hayoo/hayoo.html
20:43:47 <ski> romildo : at some point Cale added it to lambdabot after me using it enough here -- also someone made a package including it, but i can't recall which :/
20:44:16 <shachaf> (.:) = fmap fmap fmap
20:44:27 <jfischoff> yeah
20:44:35 <ski> yes, combining it with a Caleskellism
20:44:44 <ski> (that wasn't present in my original formulation)
20:45:31 <jfischoff> I remember e -> the k saying he used that one
20:47:44 * ski stares blankly
20:49:27 <jfischoff> e -> k <-> ekmett
20:49:33 --- mode: ChanServ set +o copumpkin
20:50:14 <dropdrive> Is Monad an instance of Traversable?
20:50:27 <shachaf> Monad is a type class, not a type.
20:50:47 <dropdrive> Blargh, thanks.
20:50:47 <jfischoff> Nor is it a superclass
20:50:49 <shachaf> (But there are many instances of Monad that aren't Traversable.)
20:50:52 <romildo> @pl \_ x y -> 1 + max x y
20:50:52 <lambdabot> const (((1 +) .) . max)
20:51:27 <danharaj> I'm troubled that that @pl makes perfect sense to me.
20:51:47 <danharaj> I think I actually use (.) sections in some of my code.
20:51:52 <shachaf> const ((1+) .: max)
20:51:55 <danharaj> I shouldn't ever let anyone read my code.
20:52:19 <shachaf> danharaj: Go write in a concatenative language.
20:52:23 <danharaj> gross
20:52:50 <danharaj> my section limit is 1 for (.)
20:52:57 --- mode: copumpkin set -o copumpkin
20:53:08 <danharaj> so now you're cpumpkin?
20:53:44 <rekado> I'm trying to build a monad, but I'm not sure how to do it well.
20:53:54 <copumpkin> danharaj: guess so :P
20:53:55 <lambdabot> copumpkin: You have 1 new message. '/msg lambdabot @messages' to read it.
20:54:13 <Pseudonym> radako: You've come to the right place.
20:54:17 <jfischoff>  danharaj: cocatenative language are easier to make reversible
20:54:19 <rekado> my application is a simple server
20:54:36 <Pseudonym> Do you just want it to run to debug the API, or do you need it fast now?
20:54:45 <shachaf> jfischoff: What about contracatenative languages?!
20:55:02 <Pseudonym> Or ncatenative languages.
20:55:05 * ski idly ponders "coconcatenative" ("ncatenative" ?)
20:55:14 <jfischoff> shachaf: The are easy to make reversible
20:55:17 <Pseudonym> Ha ha, everyone's a median.
20:55:23 <jfischoff> easier
20:55:39 <shachaf> ski: n-catenative-lab?
20:55:44 <rekado> a connection sounds to me like something that could be abstracted with a monad
20:55:55 <ski> shachaf : that crossed my mind, yes
20:56:06 <Pseudonym> redako: I would suggest using the MTL/
20:56:32 <Pseudonym> Check out the lambdabot source code, for example.
20:56:47 <rekado> Pseudonym: I'm using part of it already.
20:57:04 <rekado> my target is to make it easy to abort connections with a certain error.
20:57:14 <Pseudonym> Ah.
20:57:14 <rekado> the error may not just be a simple string, though.
20:57:17 <Pseudonym> Yes.
20:57:32 <rekado> errors are JSONs, built with Aeson.
20:57:42 <Pseudonym> So something eith ErrorT in it, then?
20:58:01 <rekado> Pseudonym: I'm not quite sure.
20:58:15 <rekado> I have response functions that take a connection and return a connection
20:58:24 <rekado> i.e. they modify state
20:59:07 <rekado> an error right now is just a connection with an error message.
20:59:32 <rekado> I think I should be using Either MyError Connection instead
20:59:55 <Pseudonym> You could do that. But you can use ErrorT if you want to do IO as well.
21:00:22 <rekado> ErrorT sounds good
21:00:39 <rekado> is there some similar code I could look at to learn from?
21:00:42 <Pseudonym>  type ErrorAndStateWithIO e s a = ErrorT e (StateT s IO) a -- Very common combination.
21:00:57 <rekado> Pseudonym: thanks
21:01:05 <rekado> that looks useful
21:01:15 <Pseudonym> However, one more option.
21:01:29 <Pseudonym> If you're using IO, you could use ReaderT instead, and store IOVars in your Reader.
21:01:40 <Pseudonym> IIRC, lambdabot does that.
21:01:50 <ski> (itym `IORef' or `MVar' ..)
21:01:54 <Pseudonym> It's been ages since I wrote that code, and it's been rewritten several times since then. :-)
21:02:19 <Pseudonym> Yes, IORef.
21:02:21 <Pseudonym> Sorry.
21:02:54 <rekado> Pseudonym: I'm not familiar with IORefs, but I think that's enough to find more to learn
21:03:00 <Pseudonym> Yeah.
21:03:06 * hackagebot couchdb-conduit 0.8.1 - Couch DB client library using http-conduit and aeson  http://hackage.haskell.org/package/couchdb-conduit-0.8.1 (AlexanderDorofeev)
21:03:09 <rekado> thank you
21:03:16 <Pseudonym> Basically, you store your state in the IO monad, and use ReaderT to pass around references to it.
21:03:25 <Pseudonym> ReaderT is slightly more light-weight than StateT.
21:03:31 <rekado> ok
21:03:59 <Pseudonym> Besides, you're going to hide all this behind an API, right?
21:05:07 <Pseudonym> Plan B, of course, is to roll your own. I'd only recommend that if you have a specific algebra in mind.
21:05:09 <rekado> Pseudonym: yes. None of this will be accessible from the outside.
21:05:44 <rekado> I really just want to simplify my code; now I have to check return values too often to determine if I should terminate a connection or not.
21:05:50 <Pseudonym> Right.
21:05:56 <Pseudonym> So it sounds like MTL is what you want, then.
21:06:14 <rekado> cool
21:07:50 <Pseudonym> Rolling your own is also useful if you want your various monad operations to interact in nontrivial ways.
21:08:14 <rekado> I don't think I will go beyond what Either provides.
21:08:15 <Pseudonym> e.g. if throwing an error should actually roll back some IO.
21:08:57 <rekado> this won't be necessary; just terminating the connection is enough.
21:09:03 <Pseudonym> Cool.
21:09:16 <rekado> thanks again
21:09:36 <Pseudonym> Oh, here's another MTL example: http://www.ninebynine.org/Software/Swish-0.2.1/HaskellRDF/Dfa/Dfa.lhs
21:09:45 <Pseudonym> May or may not help you.
21:12:45 <dropdrive> I'm having trouble defining the Traversable instance here: http://stackoverflow.com/a/10242673
21:13:21 * ski misses the `Monad Re' instance ..
21:14:12 <dropdrive> To those who "get it": is "traverse f x" of the form "<*> ..."?
21:14:34 <dropdrive> (I mean, "... <*> ...".)
21:15:32 <dropdrive> Also, is there a simple example of Applicative that is neither Monad nor Alternative?
21:15:51 <dropdrive> Erm, an instance of Applicative that is neither an instance of Monad nor an instance of Alternative.
21:17:17 <ski> @type Data.Traversable.traverse
21:17:18 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
21:17:51 <dropdrive> ski: IIUC I'm trying to implement that for "t" being "Triple"
21:18:28 <kallisti> time to catch up on my haskell-cafe feed.
21:19:42 <ski> dropdrive : yes, i think `(<*>)' is apparopriate here
21:20:01 <ski> (one could also use another `Applicative' operation)
21:20:31 <applicative> instance Traversable Triple where   sequenceA (Tr fx fy fz) = Tr <$> fx <*> fy <*> fz
21:21:19 <dropdrive> applicative: What, Tr is...a value?
21:21:45 <applicative> Its a constructor so it's a function
21:22:38 <dropdrive> applicative: You mean it's of type x -> x -> x -> Tr x ?
21:22:46 <dropdrive> Interesting.
21:22:47 <applicative> yes
21:23:24 <ski> you could also say `pure Tr <*>' instead of `Tr <$>' there
21:23:46 <ski> (no, the type of `Tr' is `x -> x -> x -> Triple x' :)
21:24:25 <applicative> Oh the type is called Triple, yes.  I n GADT and suchlike syntax this is explicit; you would write the data definition as:  data Triple a where a -> a -> a -> Tr a
21:24:32 <applicative> got that reversed
21:24:38 <applicative> aarrr
21:24:40 <applicative> aarrr
21:24:55 <applicative>  data Triple a where Tr:: a -> a -> a -> Triple a
21:25:19 <ski> @arr
21:25:19 <lambdabot> Avast!
21:26:11 <dropdrive> applicative: Dammit, that was obvious (?)
21:29:20 <applicative> it's not as obvious as people make out, but it's inevitable.  If we didn't think of it that way I could still write (\x y z ->  Tr x y z)  <$> fx <*> fy <*> fz  which would be a little tiresome
21:32:16 <dropdrive> applicative: I guess I still don't quite see it, as (handwaving) Tr isn't of the form "? -> Triple a" (or is it?)
21:32:49 <applicative> well you construct a Triple by putting three expressions after it
21:32:58 <applicative> after Tr
21:33:31 <dropdrive> applicative: Oh, wait, I see.
21:33:43 <dropdrive> applicative: The real question now is, how should I have thought of this?
21:34:50 <dropdrive> applicative: I had been staring at this for a long time: f (? -> t b) -> f ? -> f t b  and was trying to figure out what ? was
21:35:28 <applicative> hm well, I think the real problem is what order the Foldable instance is supposed to be in
21:35:33 <applicative> instance Foldable Triple where  foldr op b (Tr ax ay az) = op az (op ay (op ax b))
21:35:47 <dropdrive> applicative: Hrm, I guess I should have concluded that ? = a, and therefore I need to find f (a -> t b), and hence f (a -> a -> tb), etc.
21:36:00 <applicative> right
21:36:12 <dropdrive> I didn't take that second step.  Darn.
21:36:40 <dropdrive> I'm not following your point about Foldable.
21:38:07 * hackagebot ImperativeHaskell 1.1.0.1 - A library for writing Imperative style haskell.  http://hackage.haskell.org/package/ImperativeHaskell-1.1.0.1 (MatthewMirman)
21:41:41 <Orclev_> what's the simplest way to write: * -1
21:42:32 <Orclev_> > negate 42
21:42:33 <lambdabot>   -42
21:42:35 <Orclev_> ah
21:42:38 <Orclev_> perfect
21:45:47 <applicative> of course (* negate 1) is the same as negate, no?
21:45:58 <applicative> @check \x -> negate x == (* negate 1) x
21:45:59 <lambdabot>   "OK, passed 500 tests."
21:46:32 <shachaf> > (negate x :: Expr) == (x * negate 1 :: Expr)
21:46:33 <lambdabot>   False
21:46:43 <dropdrive> @check \x -> x > negate x
21:46:43 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
21:46:46 <applicative> uh oh
21:47:33 <dropdrive> > 4 ^ 2
21:47:34 <lambdabot>   16
21:47:54 <dropdrive> @check \x -> (x - 5) > 0
21:47:55 <lambdabot>   "Falsifiable, after 0 tests:\n-2\n"
21:48:02 <dropdrive> @check \x -> (x - 5) ^ 2 > 0
21:48:03 <lambdabot>   "Falsifiable, after 25 tests:\n5\n"
21:50:01 <dropdrive> applicative: Moving on in my Stackoverflow exercise, if I want to implement instance (App f, App g) => App (f :. g), will I have to first make (f :. g) an instance of Functor?
21:50:11 <applicative> yes
21:50:33 <dropdrive> That's a lot of typing!
21:50:42 <applicative> but f and g are both functors, so you need to find a way to use both fmaps
21:52:54 <applicative> well, ghc can infer the Functor instance for Triple a, so you already typed too much.  Except that {-#LANGUAGE DeriveFunctor #-} is about the same amount of typing
21:56:08 <dropdrive> applicative: I previously had "instance Functor Triple where...".  I commented that out and added DeriveFunctor; but GHC barfs.
21:57:08 <applicative> data Triple a = Tr a a a deriving (Functor, Show, Traversable, Foldable) is working fine here, with the half-page of language extensions
21:57:18 <mzero> does anyone know if the GHC IO RTS opens two pipes?
21:58:10 <dropdrive> applicative: Oh, I didn't do "deriving".  Thanks.
21:59:57 <applicative> incredibly it even allows newtype (:.) f g x = Comp {comp :: f (g x)} deriving (Functor, Show, Foldable, Traversable)
22:00:11 <applicative> that's cheating!
22:05:55 <dropdrive> applicative: I'm getting confused by the newtype.  When implementing pure, what do I put for ???: pure (????) = ...
22:06:07 <ski> just a variable name
22:06:16 <ski>   pure :: a -> Triple a
22:06:28 <dropdrive> ski: Oops, yes.
22:06:36 <ski> so your `????' has type `a' here, which is (from the point of view of `pure') an unknown type
22:07:17 <ski> so there'sn't much else you can do with that input, than naming it
22:18:09 * hackagebot hmatrix-repa 0.1.0.1 - Adaptors for interoperability between hmatrix and repa  http://hackage.haskell.org/package/hmatrix-repa-0.1.0.1 (VivianMcPhail)
22:21:51 <dropdrive> @pl \x y -> (<*>) <$> x <*> y
22:21:51 <lambdabot> (((<*>) <$>) .) . (<*>)
22:33:50 <ski> @type \x y -> (<*>) <$> x <*> y
22:33:50 <lambdabot> forall (f :: * -> *) a b (f1 :: * -> *). (Applicative f, Applicative f1) => f1 (f (a -> b)) -> f1 (f a) -> f1 (f b)
22:35:14 <ski>   comp .: ((<*>) `on` Comp)  -- except the types don't like it
22:41:46 <jfischoff> what's a good symbol for the mathematical operation of factorizing?
23:41:34 <ppilate> Hi
23:42:11 <zomg> sup
23:43:20 <Apes> The tutorial at tryhaskell.org links to this channel. Is this good or bad?
23:45:15 <c_wraith> Apes: neither
23:49:07 <ski> Apes : do you have some haskell question yet ?
23:50:36 <zomg> Is it efficient (or a good idea to begin with) to use 'repeat (do some IO; some other IO)' and then 'sequence $ take 5 list' to repeat some IO actions several times?
23:51:34 <mauke> zomg: why create that list at all?
23:52:04 <ski> why not `replicateM 5 $ do some IO; some other IO' ?
23:52:24 <ski> (or `replicateM_' instead, if you really meant `sequence_' there)
23:52:51 <zomg> mauke: because I didn't know of replicateM it would seem
23:52:58 <zomg> ski: thanks, that seems like a better way to do it :)
23:53:12 <ski> @type replicateM
23:53:13 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
23:53:14 <ski> @type replicateM_
23:53:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m ()
23:53:29 <mauke> zomg: you still could've used sequence (take 5 (replicate ...))
23:53:30 <ski> if you don't care about the list of results, use `replicateM_' instead
23:53:35 <mauke> er
23:53:35 <mauke> repeat
23:53:43 <Apes> ski: I have a lot of questions, but I still have a lot to read about Haskell first. Thank you though.
23:53:45 <ski> @src replicateM
23:53:45 <lambdabot> replicateM n x = sequence (replicate n x)
23:53:47 <ski> @src replicateM_
23:53:47 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
23:54:00 <ski> Apes : ok
23:55:09 <zomg> mauke: true
23:58:37 <ppilate> Can someone please help me out with an example of a "functor" which satisfies associativity law, but not the identity law?
23:59:39 <c_wraith> ppilate: what makes you think such an example exists?
23:59:43 <ski>   data Foo a = MkF a a
23:59:48 <ski>   instance Functor Foo
23:59:50 <ski>     where
